(* autogenerated from go-mvcc/txn *)
From Perennial.goose_lang Require Import prelude.
Section code.
Context `{ext_ty: ext_types}.
Local Coercion Var' s: expr := Var s.

From Goose Require go_mvcc.config.
From Goose Require go_mvcc.gc.
From Goose Require go_mvcc.index.
From Goose Require go_mvcc.tsc.
From Goose Require go_mvcc.tuple.

(* txn.go *)

(* *
    * We need `key` as to match in the local write set *)
Definition WrEnt := struct.decl [
  "key" :: uint64T;
  "val" :: uint64T;
  "tuple" :: struct.ptrT tuple.Tuple
].

(* *
    * `wset` as a `map[uint64]WrEnt` has the issue of allocating and deallocating
    * many `WrEnt`. *)
Definition Txn := struct.decl [
  "tid" :: uint64T;
  "wset" :: slice.T (struct.t WrEnt);
  "sid" :: uint64T;
  "idx" :: struct.ptrT index.Index;
  "txnMgr" :: struct.ptrT TxnMgr
].

Definition Txn__Put: val :=
  rec: "Txn__Put" "txn" "key" "val" :=
    let: "found" := ref_to boolT #false in
    ForSlice (struct.t WrEnt) "i" <> (struct.loadF Txn "wset" "txn")
      (if: ("key" = struct.get WrEnt "key" (SliceGet (struct.t WrEnt) (struct.loadF Txn "wset" "txn") "i"))
      then
        let: "went" := SliceRef (struct.t WrEnt) (struct.loadF Txn "wset" "txn") "i" in
        struct.storeF WrEnt "val" "went" "val";;
        "found" <-[boolT] #true
      else #());;
    (if: ![boolT] "found"
    then #true
    else
      let: "idx" := struct.loadF Txn "idx" "txn" in
      let: "tuple" := index.Index__GetTuple "idx" "key" in
      let: "ok" := tuple.Tuple__Own "tuple" (struct.loadF Txn "tid" "txn") in
      (if: ~ "ok"
      then #false
      else
        struct.storeF Txn "wset" "txn" (SliceAppend (struct.t WrEnt) (struct.loadF Txn "wset" "txn") (struct.mk WrEnt [
          "key" ::= "key";
          "val" ::= "val";
          "tuple" ::= "tuple"
        ]));;
        #true)).

Definition Txn__Get: val :=
  rec: "Txn__Get" "txn" "key" :=
    let: "found" := ref_to boolT #false in
    let: "val" := ref_to uint64T #0 in
    ForSlice (struct.t WrEnt) "i" <> (struct.loadF Txn "wset" "txn")
      (if: ("key" = struct.get WrEnt "key" (SliceGet (struct.t WrEnt) (struct.loadF Txn "wset" "txn") "i"))
      then
        let: "went" := SliceRef (struct.t WrEnt) (struct.loadF Txn "wset" "txn") "i" in
        "val" <-[uint64T] struct.loadF WrEnt "val" "went";;
        "found" <-[boolT] #true
      else #());;
    (if: ![boolT] "found"
    then (![uint64T] "val", #true)
    else
      let: "idx" := struct.loadF Txn "idx" "txn" in
      let: "tuple" := index.Index__GetTuple "idx" "key" in
      let: ("valTuple", "foundTuple") := tuple.Tuple__ReadVersion "tuple" (struct.loadF Txn "tid" "txn") in
      ("valTuple", "foundTuple")).

Definition Txn__Begin: val :=
  rec: "Txn__Begin" "txn" :=
    let: "tid" := TxnMgr__activate (struct.loadF Txn "txnMgr" "txn") (struct.loadF Txn "sid" "txn") in
    struct.storeF Txn "tid" "txn" "tid";;
    struct.storeF Txn "wset" "txn" (SliceTake (struct.loadF Txn "wset" "txn") #0);;
    #().

Definition Txn__Commit: val :=
  rec: "Txn__Commit" "txn" :=
    ForSlice (struct.t WrEnt) <> "wrent" (struct.loadF Txn "wset" "txn")
      (let: "val" := struct.get WrEnt "val" "wrent" in
      let: "tuple" := struct.get WrEnt "tuple" "wrent" in
      tuple.Tuple__AppendVersion "tuple" (struct.loadF Txn "tid" "txn") "val");;
    TxnMgr__deactivate (struct.loadF Txn "txnMgr" "txn") (struct.loadF Txn "tid" "txn");;
    #().

Definition Txn__Abort: val :=
  rec: "Txn__Abort" "txn" :=
    ForSlice (struct.t WrEnt) <> "wrent" (struct.loadF Txn "wset" "txn")
      (let: "tuple" := struct.get WrEnt "tuple" "wrent" in
      tuple.Tuple__Free "tuple" (struct.loadF Txn "tid" "txn"));;
    TxnMgr__deactivate (struct.loadF Txn "txnMgr" "txn") (struct.loadF Txn "tid" "txn");;
    #().

(* txnmgr.go *)

Definition TxnSite := struct.decl [
  "latch" :: lockRefT;
  "tidLast" :: uint64T;
  "tidsActive" :: slice.T uint64T;
  "padding" :: arrayT uint64T
].

Definition TxnMgr := struct.decl [
  "latch" :: lockRefT;
  "sidCur" :: uint64T;
  "sites" :: slice.T (struct.t TxnSite);
  "idx" :: struct.ptrT index.Index;
  "gc" :: struct.ptrT gc.GC
].

Definition MkTxnMgr: val :=
  rec: "MkTxnMgr" <> :=
    let: "txnMgr" := struct.alloc TxnMgr (zero_val (struct.t TxnMgr)) in
    struct.storeF TxnMgr "latch" "txnMgr" (lock.new #());;
    struct.storeF TxnMgr "sites" "txnMgr" (NewSlice (struct.t TxnSite) config.N_TXN_SITES);;
    let: "i" := ref_to uint64T #0 in
    (for: (λ: <>, ![uint64T] "i" < config.N_TXN_SITES); (λ: <>, "i" <-[uint64T] ![uint64T] "i" + #1) := λ: <>,
      let: "g" := SliceRef (struct.t TxnSite) (struct.loadF TxnMgr "sites" "txnMgr") (![uint64T] "i") in
      struct.storeF TxnSite "latch" "g" (lock.new #());;
      struct.storeF TxnSite "tidsActive" "g" (NewSlice uint64T #0);;
      Continue);;
    struct.storeF TxnMgr "idx" "txnMgr" (index.MkIndex #());;
    struct.storeF TxnMgr "gc" "txnMgr" (gc.MkGC (struct.loadF TxnMgr "idx" "txnMgr"));;
    "txnMgr".

Definition TxnMgr__New: val :=
  rec: "TxnMgr__New" "txnMgr" :=
    lock.acquire (struct.loadF TxnMgr "latch" "txnMgr");;
    let: "txn" := struct.alloc Txn (zero_val (struct.t Txn)) in
    struct.storeF Txn "wset" "txn" (NewSlice (struct.t WrEnt) #0);;
    let: "sid" := struct.loadF TxnMgr "sidCur" "txnMgr" in
    struct.storeF Txn "sid" "txn" "sid";;
    struct.storeF Txn "idx" "txn" (struct.loadF TxnMgr "idx" "txnMgr");;
    struct.storeF Txn "txnMgr" "txn" "txnMgr";;
    struct.storeF TxnMgr "sidCur" "txnMgr" ("sid" + #1);;
    (if: (struct.loadF TxnMgr "sidCur" "txnMgr" = config.N_TXN_SITES)
    then struct.storeF TxnMgr "sidCur" "txnMgr" #0
    else #());;
    lock.release (struct.loadF TxnMgr "latch" "txnMgr");;
    "txn".

Definition genTID: val :=
  rec: "genTID" "sid" :=
    let: "tid" := ref (zero_val uint64T) in
    "tid" <-[uint64T] tsc.GetTSC #();;
    "tid" <-[uint64T] (![uint64T] "tid" `and` ~ (config.N_TXN_SITES - #1)) + "sid";;
    ![uint64T] "tid".

Definition getSID: val :=
  rec: "getSID" "tid" :=
    let: "sid" := ("tid" `and` config.N_TXN_SITES - #1) in
    "sid".

Definition TxnMgr__activate: val :=
  rec: "TxnMgr__activate" "txnMgr" "sid" :=
    let: "site" := SliceRef (struct.t TxnSite) (struct.loadF TxnMgr "sites" "txnMgr") "sid" in
    lock.acquire (struct.loadF TxnSite "latch" "site");;
    let: "tid" := ref (zero_val uint64T) in
    "tid" <-[uint64T] genTID "sid";;
    Skip;;
    (for: (λ: <>, ![uint64T] "tid" ≤ struct.loadF TxnSite "tidLast" "site"); (λ: <>, Skip) := λ: <>,
      "tid" <-[uint64T] genTID "sid";;
      Continue);;
    struct.storeF TxnSite "tidLast" "site" (![uint64T] "tid");;
    struct.storeF TxnSite "tidsActive" "site" (SliceAppend uint64T (struct.loadF TxnSite "tidsActive" "site") (![uint64T] "tid"));;
    lock.release (struct.loadF TxnSite "latch" "site");;
    ![uint64T] "tid".

Definition findTID: val :=
  rec: "findTID" "tid" "tids" :=
    let: "idx" := ref_to uint64T #0 in
    ForSlice uint64T "i" "x" "tids"
      (if: ("tid" = "x")
      then "idx" <-[uint64T] "i"
      else #());;
    ![uint64T] "idx".

(* *
    * Precondition:
    * 1. `xs` not empty.
    * 2. `i < len(xs)` *)
Definition swapWithEnd: val :=
  rec: "swapWithEnd" "xs" "i" :=
    let: "tmp" := SliceGet uint64T "xs" (slice.len "xs" - #1) in
    SliceSet uint64T "xs" (slice.len "xs" - #1) (SliceGet uint64T "xs" "i");;
    SliceSet uint64T "xs" "i" "tmp";;
    #().

(* *
    * This function is called by `Txn` at commit/abort time.
    * Precondition:
    * 1. The set of active transactions contains `tid`. *)
Definition TxnMgr__deactivate: val :=
  rec: "TxnMgr__deactivate" "txnMgr" "tid" :=
    let: "sid" := getSID "tid" in
    let: "site" := SliceRef (struct.t TxnSite) (struct.loadF TxnMgr "sites" "txnMgr") "sid" in
    lock.acquire (struct.loadF TxnSite "latch" "site");;
    let: "idx" := findTID "tid" (struct.loadF TxnSite "tidsActive" "site") in
    swapWithEnd (struct.loadF TxnSite "tidsActive" "site") "idx";;
    struct.storeF TxnSite "tidsActive" "site" (SliceTake (struct.loadF TxnSite "tidsActive" "site") (slice.len (struct.loadF TxnSite "tidsActive" "site") - #1));;
    lock.release (struct.loadF TxnSite "latch" "site");;
    #().

Definition TxnMgr__getMinActiveTIDSite: val :=
  rec: "TxnMgr__getMinActiveTIDSite" "txnMgr" "sid" :=
    let: "site" := SliceRef (struct.t TxnSite) (struct.loadF TxnMgr "sites" "txnMgr") "sid" in
    lock.acquire (struct.loadF TxnSite "latch" "site");;
    let: "min" := ref_to uint64T config.TID_SENTINEL in
    ForSlice uint64T <> "tid" (struct.loadF TxnSite "tidsActive" "site")
      (if: "tid" < ![uint64T] "min"
      then "min" <-[uint64T] "tid"
      else #());;
    lock.release (struct.loadF TxnSite "latch" "site");;
    ![uint64T] "min".

(* *
    * This function returns the minimal TID of the active txns. If there is no
    * active txns, it returns `config.TID_SENTINEL`. *)
Definition TxnMgr__getMinActiveTID: val :=
  rec: "TxnMgr__getMinActiveTID" "txnMgr" :=
    let: "min" := ref_to uint64T config.TID_SENTINEL in
    let: "sid" := ref_to uint64T #0 in
    (for: (λ: <>, ![uint64T] "sid" < config.N_TXN_SITES); (λ: <>, "sid" <-[uint64T] ![uint64T] "sid" + #1) := λ: <>,
      let: "tid" := TxnMgr__getMinActiveTIDSite "txnMgr" (![uint64T] "sid") in
      (if: "tid" < ![uint64T] "min"
      then
        "min" <-[uint64T] "tid";;
        Continue
      else Continue));;
    ![uint64T] "min".

(* *
    * Probably only used for testing and profiling. *)
Definition TxnMgr__getNumActiveTxns: val :=
  rec: "TxnMgr__getNumActiveTxns" "txnMgr" :=
    let: "n" := ref_to uint64T #0 in
    let: "sid" := ref_to uint64T #0 in
    (for: (λ: <>, ![uint64T] "sid" < config.N_TXN_SITES); (λ: <>, "sid" <-[uint64T] ![uint64T] "sid" + #1) := λ: <>,
      let: "site" := SliceRef (struct.t TxnSite) (struct.loadF TxnMgr "sites" "txnMgr") (![uint64T] "sid") in
      lock.acquire (struct.loadF TxnSite "latch" "site");;
      "n" <-[uint64T] ![uint64T] "n" + slice.len (struct.loadF TxnSite "tidsActive" "site");;
      lock.release (struct.loadF TxnSite "latch" "site");;
      Continue);;
    ![uint64T] "n".

Definition TxnMgr__StartGC: val :=
  rec: "TxnMgr__StartGC" "txnMgr" :=
    Fork (Skip;;
          (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
            TxnMgr__runGC "txnMgr";;
            Continue));;
    #().

Definition TxnMgr__runGC: val :=
  rec: "TxnMgr__runGC" "txnMgr" :=
    let: "tidMin" := TxnMgr__getMinActiveTID "txnMgr" in
    (if: "tidMin" < config.TID_SENTINEL
    then
      gc.GC__Start (struct.loadF TxnMgr "gc" "txnMgr") "tidMin";;
      #()
    else #()).

End code.
