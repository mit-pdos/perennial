(* autogenerated from go-mvcc/tuple *)
From Perennial.goose_lang Require Import prelude.
Section code.
Context `{ext_ty: ext_types}.
Local Coercion Var' s: expr := Var s.

From Goose Require go_mvcc.config.

Definition Version := struct.decl [
  "begin" :: uint64T;
  "end" :: uint64T;
  "val" :: uint64T
].

(* *
    * `tidown`
    *		An TID specifying which txn owns the permission to update this tuple.
    * `tidrd`
    *		An TID specifying the last txn (in the sense of the largest TID, not
    *		actual physical time) that reads this tuple.
    * `tidwr`
    *		An TID specifying the last txn (in the sense of the largest TID, not
    *		actual physical time) that writes this tuple. `tidwr` should be the same
    *		as the begin timestamp of the latest version. For tuples without any
    *		version, this field is set to 0.
    *
    * Invariants:
    *		1. `tidown != 0` -> this tuple is read-only
    *		2. `vers` not empty -> exists a version whose `end` is
    *			config.TID_SENTINEL
    *		3. `len(vers) != 0` -> `tidwr == vers[len(vers) - 1].begin`
    * 		4. `len(vers) == 0` -> `tidwr == 0` *)
Definition Tuple := struct.decl [
  "latch" :: lockRefT;
  "rcond" :: condvarRefT;
  "tidown" :: uint64T;
  "tidrd" :: uint64T;
  "tidwr" :: uint64T;
  "vers" :: slice.T (struct.t Version)
].

(* *
    * TODO: Maybe start from the end (i.e., the newest version). *)
Definition findRightVer: val :=
  rec: "findRightVer" "tid" "vers" :=
    let: "ret" := ref (zero_val (struct.t Version)) in
    let: "found" := ref_to boolT #false in
    ForSlice (struct.t Version) <> "ver" "vers"
      (if: (struct.get Version "begin" "ver" ≤ "tid") && ("tid" < struct.get Version "end" "ver")
      then
        "ret" <-[struct.t Version] "ver";;
        "found" <-[boolT] #true
      else #());;
    (![struct.t Version] "ret", ![boolT] "found").

(* *
    * Preconditions:
    *
    * Postconditions:
    * 1. On a successful return, the txn `tid` get the permission to update this
    * tuple (when we also acquire the latch of this tuple). *)
Definition Tuple__Own: val :=
  rec: "Tuple__Own" "tuple" "tid" :=
    lock.acquire (struct.loadF Tuple "latch" "tuple");;
    (if: ("tid" < struct.loadF Tuple "tidrd" "tuple") || ("tid" < struct.loadF Tuple "tidwr" "tuple")
    then
      lock.release (struct.loadF Tuple "latch" "tuple");;
      #false
    else
      (if: struct.loadF Tuple "tidown" "tuple" ≠ #0
      then
        lock.release (struct.loadF Tuple "latch" "tuple");;
        #false
      else
        struct.storeF Tuple "tidown" "tuple" "tid";;
        lock.release (struct.loadF Tuple "latch" "tuple");;
        #true)).

(* *
    * Preconditions:
    * 1. The txn `tid` has the permission to update this tuple. *)
Definition Tuple__AppendVersion: val :=
  rec: "Tuple__AppendVersion" "tuple" "tid" "val" :=
    lock.acquire (struct.loadF Tuple "latch" "tuple");;
    (if: slice.len (struct.loadF Tuple "vers" "tuple") > #0
    then
      let: "idx" := slice.len (struct.loadF Tuple "vers" "tuple") - #1 in
      let: "verPrevRef" := SliceRef (struct.t Version) (struct.loadF Tuple "vers" "tuple") "idx" in
      struct.storeF Version "end" "verPrevRef" "tid"
    else #());;
    let: "verNext" := struct.mk Version [
      "begin" ::= "tid";
      "end" ::= config.TID_SENTINEL;
      "val" ::= "val"
    ] in
    struct.storeF Tuple "vers" "tuple" (SliceAppend (struct.t Version) (struct.loadF Tuple "vers" "tuple") "verNext");;
    struct.storeF Tuple "tidown" "tuple" #0;;
    struct.storeF Tuple "tidwr" "tuple" "tid";;
    lock.condBroadcast (struct.loadF Tuple "rcond" "tuple");;
    lock.release (struct.loadF Tuple "latch" "tuple");;
    #().

(* *
    * Preconditions: *)
Definition Tuple__Free: val :=
  rec: "Tuple__Free" "tuple" "tid" :=
    lock.acquire (struct.loadF Tuple "latch" "tuple");;
    struct.storeF Tuple "tidown" "tuple" #0;;
    lock.condBroadcast (struct.loadF Tuple "rcond" "tuple");;
    lock.release (struct.loadF Tuple "latch" "tuple");;
    #().

(* *
    * Preconditions: *)
Definition Tuple__ReadVersion: val :=
  rec: "Tuple__ReadVersion" "tuple" "tid" :=
    lock.acquire (struct.loadF Tuple "latch" "tuple");;
    Skip;;
    (for: (λ: <>, ("tid" ≥ struct.loadF Tuple "tidwr" "tuple") && (struct.loadF Tuple "tidown" "tuple" ≠ #0)); (λ: <>, Skip) := λ: <>,
      lock.condWait (struct.loadF Tuple "rcond" "tuple");;
      Continue);;
    (if: struct.loadF Tuple "tidrd" "tuple" < "tid"
    then struct.storeF Tuple "tidrd" "tuple" "tid"
    else #());;
    let: ("ver", "found") := findRightVer "tid" (struct.loadF Tuple "vers" "tuple") in
    (if: ~ "found"
    then
      lock.release (struct.loadF Tuple "latch" "tuple");;
      (#0, #false)
    else
      let: "val" := struct.get Version "val" "ver" in
      lock.release (struct.loadF Tuple "latch" "tuple");;
      ("val", #true)).

(* *
    * Remove all versions whose `end` timestamp is less than or equal to `tid`.
    * Preconditions: *)
Definition Tuple__RemoveVersions: val :=
  rec: "Tuple__RemoveVersions" "tuple" "tid" :=
    lock.acquire (struct.loadF Tuple "latch" "tuple");;
    let: "idx" := ref_to uint64T #0 in
    ForSlice (struct.t Version) <> "ver" (struct.loadF Tuple "vers" "tuple")
      (if: struct.get Version "end" "ver" ≤ "tid"
      then "idx" <-[uint64T] ![uint64T] "idx" + #1
      else #());;
    struct.storeF Tuple "vers" "tuple" (SliceSkip (struct.t Version) (struct.loadF Tuple "vers" "tuple") (![uint64T] "idx"));;
    lock.release (struct.loadF Tuple "latch" "tuple");;
    #().

Definition MkTuple: val :=
  rec: "MkTuple" <> :=
    let: "tuple" := struct.alloc Tuple (zero_val (struct.t Tuple)) in
    struct.storeF Tuple "latch" "tuple" (lock.new #());;
    struct.storeF Tuple "rcond" "tuple" (lock.newCond (struct.loadF Tuple "latch" "tuple"));;
    struct.storeF Tuple "tidown" "tuple" #0;;
    struct.storeF Tuple "tidrd" "tuple" #0;;
    struct.storeF Tuple "tidwr" "tuple" #0;;
    struct.storeF Tuple "vers" "tuple" (NewSlice (struct.t Version) #0);;
    "tuple".

End code.
