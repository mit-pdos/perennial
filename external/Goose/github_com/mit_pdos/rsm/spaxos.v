(* autogenerated from github.com/mit-pdos/rsm/spaxos *)
From Perennial.goose_lang Require Import prelude.
From Goose Require github_com.goose_lang.std.

Section code.
Context `{ext_ty: ext_types}.

Definition Paxos := struct.decl [
  "mu" :: ptrT;
  "nid" :: uint64T;
  "termc" :: uint64T;
  "termp" :: uint64T;
  "decreep" :: stringT;
  "learned" :: boolT;
  "sc" :: uint64T;
  "peers" :: mapT ptrT
].

Definition MAX_NODES : expr := #16.

Definition NextAligned: val :=
  rec: "NextAligned" "current" "interval" "low" :=
    let: "delta" := ref (zero_val uint64T) in
    let: "rem" := "current" `rem` "interval" in
    (if: "rem" < "low"
    then "delta" <-[uint64T] ("low" - "rem")
    else "delta" <-[uint64T] (("interval" + "low") - "rem"));;
    std.SumAssumeNoOverflow "current" (![uint64T] "delta").

Definition Paxos__advance: val :=
  rec: "Paxos__advance" "px" :=
    Mutex__Lock (struct.loadF Paxos "mu" "px");;
    let: "term" := NextAligned (struct.loadF Paxos "termc" "px") MAX_NODES (struct.loadF Paxos "nid" "px") in
    struct.storeF Paxos "termc" "px" "term";;
    let: "termp" := struct.loadF Paxos "termp" "px" in
    let: "decreep" := struct.loadF Paxos "decreep" "px" in
    Mutex__Unlock (struct.loadF Paxos "mu" "px");;
    ("term", "termp", "decreep").

Definition Paxos__prepare: val :=
  rec: "Paxos__prepare" "px" "term" :=
    Mutex__Lock (struct.loadF Paxos "mu" "px");;
    (if: "term" < (struct.loadF Paxos "termc" "px")
    then
      Mutex__Unlock (struct.loadF Paxos "mu" "px");;
      (#0, #(str""), #false)
    else
      struct.storeF Paxos "termc" "px" "term";;
      let: "termp" := struct.loadF Paxos "termp" "px" in
      let: "decreep" := struct.loadF Paxos "decreep" "px" in
      Mutex__Unlock (struct.loadF Paxos "mu" "px");;
      ("termp", "decreep", #true)).

Definition Paxos__major: val :=
  rec: "Paxos__major" "px" "n" :=
    "n" > ((struct.loadF Paxos "sc" "px") `quot` #2).

Definition Paxos__prepareAll: val :=
  rec: "Paxos__prepareAll" "px" "term" "terma" "decreea" :=
    let: "termLargest" := ref_to uint64T "terma" in
    let: "decreeLargest" := ref_to stringT "decreea" in
    let: "nPrepared" := ref_to uint64T #1 in
    MapIter (struct.loadF Paxos "peers" "px") (λ: <> "peer",
      let: (("termPeer", "decreePeer"), "ok") := Paxos__prepare "peer" "term" in
      (if: "ok"
      then
        "nPrepared" <-[uint64T] ((![uint64T] "nPrepared") + #1);;
        (if: "termPeer" > (![uint64T] "termLargest")
        then
          "termLargest" <-[uint64T] "termPeer";;
          "decreeLargest" <-[stringT] "decreePeer"
        else #())
      else #()));;
    (if: (~ (Paxos__major "px" (![uint64T] "nPrepared")))
    then (#0, #(str""), #false)
    else (![uint64T] "termLargest", ![stringT] "decreeLargest", #true)).

Definition Paxos__accept: val :=
  rec: "Paxos__accept" "px" "term" "decree" :=
    Mutex__Lock (struct.loadF Paxos "mu" "px");;
    (if: "term" < (struct.loadF Paxos "termc" "px")
    then
      Mutex__Unlock (struct.loadF Paxos "mu" "px");;
      #false
    else
      (if: struct.loadF Paxos "learned" "px"
      then
        Mutex__Unlock (struct.loadF Paxos "mu" "px");;
        #false
      else
        struct.storeF Paxos "termc" "px" (std.SumAssumeNoOverflow "term" #1);;
        struct.storeF Paxos "termp" "px" "term";;
        struct.storeF Paxos "decreep" "px" "decree";;
        Mutex__Unlock (struct.loadF Paxos "mu" "px");;
        #true)).

Definition Paxos__acceptAll: val :=
  rec: "Paxos__acceptAll" "px" "term" "decree" :=
    let: "nAccepted" := ref_to uint64T #1 in
    MapIter (struct.loadF Paxos "peers" "px") (λ: <> "peer",
      let: "ok" := Paxos__accept "peer" "term" "decree" in
      (if: "ok"
      then "nAccepted" <-[uint64T] ((![uint64T] "nAccepted") + #1)
      else #()));;
    Paxos__major "px" (![uint64T] "nAccepted").

Definition Paxos__learn: val :=
  rec: "Paxos__learn" "px" "term" "decree" :=
    Mutex__Lock (struct.loadF Paxos "mu" "px");;
    (if: "term" < (struct.loadF Paxos "termc" "px")
    then
      Mutex__Unlock (struct.loadF Paxos "mu" "px");;
      #()
    else
      struct.storeF Paxos "termc" "px" (std.SumAssumeNoOverflow "term" #1);;
      struct.storeF Paxos "termp" "px" "term";;
      struct.storeF Paxos "decreep" "px" "decree";;
      struct.storeF Paxos "learned" "px" #true;;
      Mutex__Unlock (struct.loadF Paxos "mu" "px");;
      #()).

Definition Paxos__learnAll: val :=
  rec: "Paxos__learnAll" "px" "term" "decree" :=
    MapIter (struct.loadF Paxos "peers" "px") (λ: <> "peer",
      Paxos__learn "peer" "term" "decree");;
    #().

(* Note that @Propose returning true doesn't mean that @v is chosen, but only
   that @v is successfully proposed. Call @Outcome to know the actual chosen
   value.

   We could prove a stronger spec that says:
   (Case chosen) @v is successfully chosen.
   (Case proposed) @v is successfully proposed.
   (Case not proposed) @v is not proposed.
   For now it's unclear this stronger spec is useful, so we're proving a spec
   where the successful case essentially merge the first two cases above. *)
Definition Paxos__Propose: val :=
  rec: "Paxos__Propose" "px" "v" :=
    let: (("term", "terma"), "decreea") := Paxos__advance "px" in
    let: (("terml", "decreel"), "prepared") := Paxos__prepareAll "px" "term" "terma" "decreea" in
    (if: (~ "prepared")
    then #false
    else
      let: "decree" := ref (zero_val stringT) in
      let: "helping" := ref (zero_val boolT) in
      (if: "terml" = #0
      then
        "decree" <-[stringT] "v";;
        "helping" <-[boolT] #false
      else
        "decree" <-[stringT] "decreel";;
        "helping" <-[boolT] #true);;
      let: "proposed" := Paxos__accept "px" "term" (![stringT] "decree") in
      (if: (~ "proposed")
      then #false
      else
        let: "accepted" := Paxos__acceptAll "px" "term" (![stringT] "decree") in
        (if: (~ "accepted")
        then (~ (![boolT] "helping"))
        else
          Paxos__learn "px" "term" (![stringT] "decree");;
          Paxos__learnAll "px" "term" (![stringT] "decree");;
          (~ (![boolT] "helping"))))).

Definition Paxos__outcome: val :=
  rec: "Paxos__outcome" "px" :=
    Mutex__Lock (struct.loadF Paxos "mu" "px");;
    let: "decree" := struct.loadF Paxos "decreep" "px" in
    let: "learned" := struct.loadF Paxos "learned" "px" in
    Mutex__Unlock (struct.loadF Paxos "mu" "px");;
    ("decree", "learned").

Definition Paxos__Outcome: val :=
  rec: "Paxos__Outcome" "px" :=
    let: ("decree", "ok") := Paxos__outcome "px" in
    ("decree", "ok").

(* TODO: This really should be returning a slice of paxos objects, but now for
   simplicity let's just return one of them. *)
Definition MkPaxos: val :=
  rec: "MkPaxos" <> :=
    let: "px" := ref (zero_val ptrT) in
    ![ptrT] "px".

(* The goals of this example are:

   1. Show the basic usage of consensus: getting the same value from two
   successful @px.Outcome.

   2. Show how to construct invariants on the candidate set, and then transfer
   those invariants to the consensus using the inclusion property between the
   consensus and the candidate set. *)
Definition example1: val :=
  rec: "example1" <> :=
    let: "px" := MkPaxos #() in
    Paxos__Propose "px" #(str"hello");;
    Paxos__Propose "px" #(str"world");;
    let: ("v1", "ok1") := Paxos__Outcome "px" in
    let: ("v2", "ok2") := Paxos__Outcome "px" in
    (if: "ok1" && "ok2"
    then
      control.impl.Assert ("v1" = "v2");;
      control.impl.Assert ((StringLength "v1") = #5);;
      #()
    else #()).

End code.
