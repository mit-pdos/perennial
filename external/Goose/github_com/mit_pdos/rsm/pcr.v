(* autogenerated from github.com/mit-pdos/rsm/pcr *)
From Perennial.goose_lang Require Import prelude.
From Goose Require github_com.goose_lang.std.

Section code.
Context `{ext_ty: ext_types}.

Definition Value := struct.decl [
  "b" :: boolT;
  "s" :: stringT
].

Definition WriteEntry := struct.decl [
  "k" :: stringT;
  "v" :: struct.t Value
].

Definition N_SHARDS : expr := #2.

(* @ts
   Starting timestamp of this version, and also ending timestamp of the next
   version. Lifetime is a half-open interval: [ts of this, ts of next).

   @val
   Value of this version. *)
Definition Version := struct.decl [
  "ts" :: uint64T;
  "val" :: struct.t Value
].

Definition Tuple__Own: val :=
  rec: "Tuple__Own" "tuple" "tid" :=
    #false.

Definition Tuple__ReadVersion: val :=
  rec: "Tuple__ReadVersion" "tuple" "tid" :=
    (struct.mk Version [
     ], #false).

Definition Tuple__Extend: val :=
  rec: "Tuple__Extend" "tuple" "tid" :=
    #false.

Definition Tuple__AppendVersion: val :=
  rec: "Tuple__AppendVersion" "tuple" "tid" "val" :=
    #().

Definition Tuple__KillVersion: val :=
  rec: "Tuple__KillVersion" "tuple" "tid" :=
    #().

Definition Tuple__Free: val :=
  rec: "Tuple__Free" "tuple" :=
    #().

(* @owned
   Write lock of this tuple. Acquired before committing.

   @tslast
   Timestamp of the last reader or last writer + 1.

   @vers
   Versions. *)
Definition Tuple := struct.decl [
  "latch" :: ptrT;
  "owned" :: boolT;
  "tslast" :: uint64T;
  "vers" :: slice.T (struct.t Version)
].

Definition Index := struct.decl [
].

Definition Index__GetTuple: val :=
  rec: "Index__GetTuple" "idx" "key" :=
    struct.new Tuple [
    ].

Definition Cmd := struct.decl [
  "kind" :: uint64T;
  "ts" :: uint64T;
  "pwrs" :: slice.T (struct.t WriteEntry);
  "key" :: stringT
].

Definition TxnLog := struct.decl [
].

(* Arguments:
   @ts: Transaction timestamp.

   Return values:
   @lsn (uint64): @lsn = 0 indicates failure; otherwise, this indicates the
   logical index this command is supposed to be placed at.

   @term (uint64): The @term this command is supposed to have.

   Notes:
   1) Passing @lsn and @term to @WaitUntilSafe allows us to determine whether
   the command we just submitted actually get safely replicated (and wait until
   that happens up to some timeout).

   2) Although @term is redundant in that we can always detect failure by
   comparing the content of the command to some application state (e.g., a reply
   table), it can be seen as a performance optimization that would allow us to
   know earlier that our command has not been safely replicated (and hence
   resubmit). Another upside of having it would be that this allows the check to
   be done in a general way, without relying on the content. *)
Definition TxnLog__SubmitCommit: val :=
  rec: "TxnLog__SubmitCommit" "log" "ts" "pwrs" :=
    (#0, #0).

(* Arguments and return values: see description of @SubmitPrepare. *)
Definition TxnLog__SubmitAbort: val :=
  rec: "TxnLog__SubmitAbort" "log" "ts" :=
    (#0, #0).

(* Arguments:
   @lsn: LSN of the command whose replication to wait for.

   @term: Expected term of the command.

   Return values:
   @replicated (bool): If @true, then the command at @lsn has term @term;
   otherwise, we know nothing, but the upper layer is suggested to resubmit the
   command.

   TODO: maybe this is a bad interface since now the users would have to make
   another call. *)
Definition TxnLog__WaitUntilSafe: val :=
  rec: "TxnLog__WaitUntilSafe" "log" "lsn" "term" :=
    #false.

(* Argument:
   @lsn: Logical index of the queried command. *)
Definition TxnLog__Lookup: val :=
  rec: "TxnLog__Lookup" "log" "lsn" :=
    (struct.mk Cmd [
     ], #false).

Definition PrepareProposal := struct.decl [
  "rank" :: uint64T;
  "dec" :: boolT
].

Definition PrepareStatusEntry := struct.decl [
  "rankl" :: uint64T;
  "prep" :: struct.t PrepareProposal
].

Definition Replica := struct.decl [
  "mu" :: ptrT;
  "rid" :: uint64T;
  "txnlog" :: ptrT;
  "lsna" :: uint64T;
  "prepm" :: mapT (slice.T (struct.t WriteEntry));
  "ptgsm" :: mapT (slice.T uint64T);
  "pstbl" :: mapT (struct.t PrepareStatusEntry);
  "txntbl" :: mapT boolT;
  "idx" :: ptrT;
  "rps" :: mapT ptrT;
  "leader" :: uint64T
].

(* Arguments:
   @ts: Transaction timestamp.

   Return values:
   @terminated: Whether txn @ts has terminated (committed or aborted). *)
Definition Replica__queryTxnTermination: val :=
  rec: "Replica__queryTxnTermination" "rp" "ts" :=
    let: (<>, "terminated") := MapGet (struct.loadF Replica "txntbl" "rp") "ts" in
    "terminated".

Definition Replica__QueryTxnTermination: val :=
  rec: "Replica__QueryTxnTermination" "rp" "ts" :=
    Mutex__Lock (struct.loadF Replica "mu" "rp");;
    let: "terminated" := Replica__queryTxnTermination "rp" "ts" in
    Mutex__Unlock (struct.loadF Replica "mu" "rp");;
    "terminated".

(* Arguments:
   @ts: Transaction timestamp.

   Return values:
   @ok: If @true, this transaction is committed. *)
Definition Replica__Commit: val :=
  rec: "Replica__Commit" "rp" "ts" "pwrs" :=
    let: "committed" := Replica__QueryTxnTermination "rp" "ts" in
    (if: "committed"
    then #true
    else
      let: ("lsn", "term") := TxnLog__SubmitCommit (struct.loadF Replica "txnlog" "rp") "ts" "pwrs" in
      (if: "lsn" = #0
      then #false
      else
        let: "safe" := TxnLog__WaitUntilSafe (struct.loadF Replica "txnlog" "rp") "lsn" "term" in
        (if: (~ "safe")
        then #false
        else #true))).

(* Arguments:
   @ts: Transaction timestamp.

   Return values:
   @ok: If @true, this transaction is aborted. *)
Definition Replica__Abort: val :=
  rec: "Replica__Abort" "rp" "ts" :=
    let: "aborted" := Replica__QueryTxnTermination "rp" "ts" in
    (if: "aborted"
    then #true
    else
      let: ("lsn", "term") := TxnLog__SubmitAbort (struct.loadF Replica "txnlog" "rp") "ts" in
      (if: "lsn" = #0
      then #false
      else
        let: "safe" := TxnLog__WaitUntilSafe (struct.loadF Replica "txnlog" "rp") "lsn" "term" in
        (if: (~ "safe")
        then #false
        else #true))).

(* Arguments:
   @ts: Transaction timestamp.
   @key: Key to be read.

   Return values:
   @value: Value of the key.
   @ok: @value is meaningful iff @ok is true. *)
Definition Replica__Read: val :=
  rec: "Replica__Read" "rp" "ts" "key" :=
    let: "terminated" := Replica__QueryTxnTermination "rp" "ts" in
    (if: "terminated"
    then
      (struct.mk Version [
       ], #false)
    else
      let: "tpl" := Index__GetTuple (struct.loadF Replica "idx" "rp") "key" in
      Tuple__Extend "tpl" "ts";;
      let: ("v", "ok") := Tuple__ReadVersion "tpl" "ts" in
      ("v", "ok")).

Definition Replica__acquire: val :=
  rec: "Replica__acquire" "rp" "ts" "pwrs" :=
    let: "pos" := ref_to uint64T #0 in
    Skip;;
    (for: (λ: <>, (![uint64T] "pos") < (slice.len "pwrs")); (λ: <>, Skip) := λ: <>,
      let: "ent" := SliceGet (struct.t WriteEntry) "pwrs" (![uint64T] "pos") in
      let: "tpl" := Index__GetTuple (struct.loadF Replica "idx" "rp") (struct.get WriteEntry "k" "ent") in
      let: "ret" := Tuple__Own "tpl" "ts" in
      (if: (~ "ret")
      then Break
      else
        "pos" <-[uint64T] ((![uint64T] "pos") + #1);;
        Continue));;
    (if: (![uint64T] "pos") < (slice.len "pwrs")
    then
      let: "i" := ref_to uint64T #0 in
      Skip;;
      (for: (λ: <>, (![uint64T] "i") < (![uint64T] "pos")); (λ: <>, Skip) := λ: <>,
        let: "ent" := SliceGet (struct.t WriteEntry) "pwrs" (![uint64T] "i") in
        let: "tpl" := Index__GetTuple (struct.loadF Replica "idx" "rp") (struct.get WriteEntry "k" "ent") in
        Tuple__Free "tpl";;
        "i" <-[uint64T] ((![uint64T] "i") + #1);;
        Continue);;
      #false
    else #true).

Definition RESULT_OK : expr := #0.

Definition RESULT_COMMITTED_TXN : expr := #1.

Definition RESULT_ABORTED_TXN : expr := #2.

Definition RESULT_STALE_COORDINATOR : expr := #3.

Definition RESULT_FAILED_VALIDATION : expr := #4.

Definition RESULT_INVALID_RANK : expr := #5.

(* Arguments:
   @ts: Transaction timestamp.
   @pwrs: Write set of transaction @ts.
   @ptgs: Participant groups of transaction @ts.

   Return values:
   @error: Error code. *)
Definition Replica__validate: val :=
  rec: "Replica__validate" "rp" "ts" "pwrs" "ptgs" :=
    let: ("cmted", "done") := MapGet (struct.loadF Replica "txntbl" "rp") "ts" in
    (if: "done"
    then
      (if: "cmted"
      then RESULT_COMMITTED_TXN
      else RESULT_ABORTED_TXN)
    else
      let: (<>, "validated") := MapGet (struct.loadF Replica "prepm" "rp") "ts" in
      (if: "validated"
      then RESULT_OK
      else
        let: "acquired" := Replica__acquire "rp" "ts" "pwrs" in
        (if: (~ "acquired")
        then RESULT_FAILED_VALIDATION
        else
          MapInsert (struct.loadF Replica "prepm" "rp") "ts" "pwrs";;
          MapInsert (struct.loadF Replica "ptgsm" "rp") "ts" "ptgs";;
          RESULT_OK))).

(* Keep alive coordinator for @ts at @rank. *)
Definition Replica__refresh: val :=
  rec: "Replica__refresh" "rp" "ts" "rank" :=
    #().

Definition Replica__Validate: val :=
  rec: "Replica__Validate" "rp" "ts" "rank" "pwrs" "ptgs" :=
    Mutex__Lock (struct.loadF Replica "mu" "rp");;
    let: "res" := Replica__validate "rp" "ts" "pwrs" "ptgs" in
    Replica__refresh "rp" "ts" "rank";;
    Mutex__Unlock (struct.loadF Replica "mu" "rp");;
    "res".

(* Arguments:
   @ts: Transaction timestamp.

   @pwrs: Transaction write set.

   Return values:

   @error: Error code. *)
Definition Replica__fastPrepare: val :=
  rec: "Replica__fastPrepare" "rp" "ts" "pwrs" "ptgs" :=
    let: ("cmted", "done") := MapGet (struct.loadF Replica "txntbl" "rp") "ts" in
    (if: "done"
    then
      (if: "cmted"
      then RESULT_COMMITTED_TXN
      else RESULT_ABORTED_TXN)
    else
      let: ("ps", "ok") := MapGet (struct.loadF Replica "pstbl" "rp") "ts" in
      (if: "ok"
      then
        let: "pp" := struct.get PrepareStatusEntry "prep" "ps" in
        (if: #0 < (struct.get PrepareProposal "rank" "pp")
        then RESULT_STALE_COORDINATOR
        else
          (if: (~ (struct.get PrepareProposal "dec" "pp"))
          then RESULT_FAILED_VALIDATION
          else RESULT_OK))
      else
        let: "acquired" := Replica__acquire "rp" "ts" "pwrs" in
        let: "pp" := struct.mk PrepareProposal [
          "rank" ::= #0;
          "dec" ::= "acquired"
        ] in
        let: "psnew" := struct.mk PrepareStatusEntry [
          "rankl" ::= #1;
          "prep" ::= "pp"
        ] in
        MapInsert (struct.loadF Replica "pstbl" "rp") "ts" "psnew";;
        (if: (~ "acquired")
        then RESULT_FAILED_VALIDATION
        else
          MapInsert (struct.loadF Replica "prepm" "rp") "ts" "pwrs";;
          MapInsert (struct.loadF Replica "ptgsm" "rp") "ts" "ptgs";;
          RESULT_OK))).

Definition Replica__FastPrepare: val :=
  rec: "Replica__FastPrepare" "rp" "ts" "pwrs" "ptgs" :=
    Mutex__Lock (struct.loadF Replica "mu" "rp");;
    let: "res" := Replica__fastPrepare "rp" "ts" "pwrs" "ptgs" in
    Replica__refresh "rp" "ts" #0;;
    Mutex__Unlock (struct.loadF Replica "mu" "rp");;
    "res".

(* Accept the prepare decision for @ts at @rank, if @rank is most recent.

   Arguments:
   @ts: Transaction timestamp.
   @rank: Coordinator rank.
   @dec: Prepared or unprepared.

   Return values:
   @error: Error code. *)
Definition Replica__acceptPreparedness: val :=
  rec: "Replica__acceptPreparedness" "rp" "ts" "rank" "dec" :=
    let: ("cmted", "done") := MapGet (struct.loadF Replica "txntbl" "rp") "ts" in
    (if: "done"
    then
      (if: "cmted"
      then RESULT_COMMITTED_TXN
      else RESULT_ABORTED_TXN)
    else
      let: ("ps", "ok") := MapGet (struct.loadF Replica "pstbl" "rp") "ts" in
      (if: "ok" && ("rank" < (struct.get PrepareStatusEntry "rankl" "ps"))
      then RESULT_STALE_COORDINATOR
      else
        let: "pp" := struct.mk PrepareProposal [
          "rank" ::= "rank";
          "dec" ::= "dec"
        ] in
        let: "psnew" := struct.mk PrepareStatusEntry [
          "rankl" ::= "rank" + #1;
          "prep" ::= "pp"
        ] in
        MapInsert (struct.loadF Replica "pstbl" "rp") "ts" "psnew";;
        RESULT_OK)).

Definition Replica__Prepare: val :=
  rec: "Replica__Prepare" "rp" "ts" "rank" :=
    Mutex__Lock (struct.loadF Replica "mu" "rp");;
    let: "res" := Replica__acceptPreparedness "rp" "ts" "rank" #true in
    Replica__refresh "rp" "ts" "rank";;
    Mutex__Unlock (struct.loadF Replica "mu" "rp");;
    "res".

Definition Replica__Unprepare: val :=
  rec: "Replica__Unprepare" "rp" "ts" "rank" :=
    Mutex__Lock (struct.loadF Replica "mu" "rp");;
    let: "res" := Replica__acceptPreparedness "rp" "ts" "rank" #false in
    Replica__refresh "rp" "ts" "rank";;
    Mutex__Unlock (struct.loadF Replica "mu" "rp");;
    "res".

Definition Replica__inquire: val :=
  rec: "Replica__inquire" "rp" "ts" "rank" :=
    let: ("cmted", "done") := MapGet (struct.loadF Replica "txntbl" "rp") "ts" in
    (if: "done"
    then
      (if: "cmted"
      then
        (struct.mk PrepareProposal [
         ], #false, RESULT_COMMITTED_TXN)
      else
        (struct.mk PrepareProposal [
         ], #false, RESULT_ABORTED_TXN))
    else
      let: ("ps", "ok") := MapGet (struct.loadF Replica "pstbl" "rp") "ts" in
      (if: "ok" && ("rank" ≤ (struct.get PrepareStatusEntry "rankl" "ps"))
      then
        (struct.mk PrepareProposal [
         ], #false, RESULT_INVALID_RANK)
      else
        let: "pp" := struct.get PrepareStatusEntry "prep" "ps" in
        let: "psnew" := struct.mk PrepareStatusEntry [
          "rankl" ::= "rank";
          "prep" ::= "pp"
        ] in
        MapInsert (struct.loadF Replica "pstbl" "rp") "ts" "psnew";;
        let: (<>, "vd") := MapGet (struct.loadF Replica "prepm" "rp") "ts" in
        ("pp", "vd", RESULT_OK))).

Definition Replica__Inquire: val :=
  rec: "Replica__Inquire" "rp" "ts" "rank" :=
    Mutex__Lock (struct.loadF Replica "mu" "rp");;
    let: (("pp", "vd"), "res") := Replica__inquire "rp" "ts" "rank" in
    Replica__refresh "rp" "ts" "rank";;
    Mutex__Unlock (struct.loadF Replica "mu" "rp");;
    ("pp", "vd", "res").

Definition Replica__query: val :=
  rec: "Replica__query" "rp" "ts" "rank" :=
    let: ("cmted", "done") := MapGet (struct.loadF Replica "txntbl" "rp") "ts" in
    (if: "done"
    then
      (if: "cmted"
      then RESULT_COMMITTED_TXN
      else RESULT_ABORTED_TXN)
    else
      let: ("ps", "ok") := MapGet (struct.loadF Replica "pstbl" "rp") "ts" in
      (if: "ok" && ("rank" < (struct.get PrepareStatusEntry "rankl" "ps"))
      then RESULT_STALE_COORDINATOR
      else RESULT_OK)).

Definition Replica__Query: val :=
  rec: "Replica__Query" "rp" "ts" "rank" :=
    Mutex__Lock (struct.loadF Replica "mu" "rp");;
    let: "res" := Replica__query "rp" "ts" "rank" in
    Replica__refresh "rp" "ts" "rank";;
    Mutex__Unlock (struct.loadF Replica "mu" "rp");;
    "res".

Definition Replica__multiwrite: val :=
  rec: "Replica__multiwrite" "rp" "ts" "pwrs" :=
    ForSlice (struct.t WriteEntry) <> "ent" "pwrs"
      (let: "key" := struct.get WriteEntry "k" "ent" in
      let: "value" := struct.get WriteEntry "v" "ent" in
      let: "tpl" := Index__GetTuple (struct.loadF Replica "idx" "rp") "key" in
      (if: struct.get Value "b" "value"
      then Tuple__AppendVersion "tpl" "ts" (struct.get Value "s" "value")
      else Tuple__KillVersion "tpl" "ts");;
      Tuple__Free "tpl");;
    #().

Definition Replica__applyCommit: val :=
  rec: "Replica__applyCommit" "rp" "ts" "pwrs" :=
    let: "committed" := Replica__queryTxnTermination "rp" "ts" in
    (if: "committed"
    then #()
    else
      Replica__multiwrite "rp" "ts" "pwrs";;
      MapDelete (struct.loadF Replica "prepm" "rp") "ts";;
      MapInsert (struct.loadF Replica "txntbl" "rp") "ts" #true;;
      #()).

Definition Replica__abort: val :=
  rec: "Replica__abort" "rp" "pwrs" :=
    ForSlice (struct.t WriteEntry) <> "ent" "pwrs"
      (let: "key" := struct.get WriteEntry "k" "ent" in
      let: "tpl" := Index__GetTuple (struct.loadF Replica "idx" "rp") "key" in
      Tuple__Free "tpl");;
    #().

Definition Replica__applyAbort: val :=
  rec: "Replica__applyAbort" "rp" "ts" :=
    let: "aborted" := Replica__queryTxnTermination "rp" "ts" in
    (if: "aborted"
    then #()
    else
      let: ("pwrs", "prepared") := MapGet (struct.loadF Replica "prepm" "rp") "ts" in
      (if: "prepared"
      then
        Replica__abort "rp" "pwrs";;
        MapDelete (struct.loadF Replica "prepm" "rp") "ts"
      else #());;
      MapInsert (struct.loadF Replica "txntbl" "rp") "ts" #false;;
      #()).

Definition Replica__apply: val :=
  rec: "Replica__apply" "rp" "cmd" :=
    (if: (struct.get Cmd "kind" "cmd") = #0
    then #()
    else
      (if: (struct.get Cmd "kind" "cmd") = #1
      then
        Replica__applyCommit "rp" (struct.get Cmd "ts" "cmd") (struct.get Cmd "pwrs" "cmd");;
        #()
      else
        Replica__applyAbort "rp" (struct.get Cmd "ts" "cmd");;
        #())).

Definition Replica__Start: val :=
  rec: "Replica__Start" "rp" :=
    Mutex__Lock (struct.loadF Replica "mu" "rp");;
    Skip;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "lsn" := std.SumAssumeNoOverflow (struct.loadF Replica "lsna" "rp") #1 in
      let: ("cmd", "ok") := TxnLog__Lookup (struct.loadF Replica "txnlog" "rp") "lsn" in
      (if: (~ "ok")
      then
        Mutex__Unlock (struct.loadF Replica "mu" "rp");;
        time.Sleep (#1 * #1000000);;
        Mutex__Lock (struct.loadF Replica "mu" "rp");;
        Continue
      else
        Replica__apply "rp" "cmd";;
        struct.storeF Replica "lsna" "rp" "lsn";;
        Continue));;
    #().

Definition GCOORD_VALIDATING : expr := #0.

Definition GCOORD_PREPARING : expr := #1.

Definition GCOORD_UNPREPARING : expr := #2.

Definition GCOORD_WAITING : expr := #3.

Definition GCOORD_PREPARED : expr := #4.

Definition GCOORD_COMMITTED : expr := #5.

Definition GCOORD_ABORTED : expr := #6.

Definition GCOORD_FAST_PREPARE : expr := #0.

Definition GCOORD_VALIDATE : expr := #1.

Definition GCOORD_PREPARE : expr := #2.

Definition GCOORD_UNPREPARE : expr := #3.

Definition GCOORD_QUERY : expr := #4.

Definition GCOORD_COMPLETE : expr := #5.

Definition GroupCoordinator := struct.decl [
  "rps" :: mapT ptrT;
  "pwrs" :: mapT (struct.t Value);
  "mu" :: ptrT;
  "leader" :: uint64T;
  "phase" :: uint64T;
  "fresps" :: mapT boolT;
  "sresps" :: mapT boolT
].

(* Argument:
   @rid: ID of the replica to which a new action is performed.

   Return value:
   @action: Next action to perform. *)
Definition GroupCoordinator__action: val :=
  rec: "GroupCoordinator__action" "gcoord" "rid" :=
    (if: (struct.loadF GroupCoordinator "phase" "gcoord") = GCOORD_VALIDATING
    then
      let: (<>, "fresp") := MapGet (struct.loadF GroupCoordinator "fresps" "gcoord") "rid" in
      (if: (~ "fresp")
      then GCOORD_FAST_PREPARE
      else
        let: (<>, "validated") := MapGet (struct.loadF GroupCoordinator "sresps" "gcoord") "rid" in
        (if: (~ "validated")
        then GCOORD_VALIDATE
        else GCOORD_QUERY))
    else
      (if: (struct.loadF GroupCoordinator "phase" "gcoord") = GCOORD_PREPARING
      then
        let: (<>, "prepared") := MapGet (struct.loadF GroupCoordinator "sresps" "gcoord") "rid" in
        (if: (~ "prepared")
        then GCOORD_PREPARE
        else GCOORD_QUERY)
      else
        (if: (struct.loadF GroupCoordinator "phase" "gcoord") = GCOORD_UNPREPARING
        then
          let: (<>, "unprepared") := MapGet (struct.loadF GroupCoordinator "sresps" "gcoord") "rid" in
          (if: (~ "unprepared")
          then GCOORD_UNPREPARE
          else GCOORD_QUERY)
        else
          (if: (struct.loadF GroupCoordinator "phase" "gcoord") = GCOORD_WAITING
          then GCOORD_QUERY
          else GCOORD_COMPLETE)))).

Definition GroupCoordinator__Action: val :=
  rec: "GroupCoordinator__Action" "gcoord" "rid" :=
    Mutex__Lock (struct.loadF GroupCoordinator "mu" "gcoord");;
    let: "act" := GroupCoordinator__action "gcoord" "rid" in
    Mutex__Unlock (struct.loadF GroupCoordinator "mu" "gcoord");;
    "act".

Definition GroupCoordinator__tryResign: val :=
  rec: "GroupCoordinator__tryResign" "gcoord" "res" :=
    (if: GCOORD_PREPARED ≤ (struct.loadF GroupCoordinator "phase" "gcoord")
    then #true
    else
      (if: "res" = RESULT_COMMITTED_TXN
      then
        struct.storeF GroupCoordinator "phase" "gcoord" GCOORD_COMMITTED;;
        #true
      else
        (if: "res" = RESULT_ABORTED_TXN
        then
          struct.storeF GroupCoordinator "phase" "gcoord" GCOORD_ABORTED;;
          #true
        else
          (if: "res" = RESULT_STALE_COORDINATOR
          then
            struct.storeF GroupCoordinator "phase" "gcoord" GCOORD_WAITING;;
            #true
          else #false)))).

Definition FastQuorum: val :=
  rec: "FastQuorum" "n" :=
    (("n" + #1) * #3) `quot` #4.

Definition ClassicQuorum: val :=
  rec: "ClassicQuorum" "n" :=
    ("n" `quot` #2) + #1.

Definition Half: val :=
  rec: "Half" "n" :=
    ("n" + #1) `quot` #2.

Definition GroupCoordinator__fquorum: val :=
  rec: "GroupCoordinator__fquorum" "gcoord" "n" :=
    (FastQuorum (MapLen (struct.loadF GroupCoordinator "rps" "gcoord"))) ≤ "n".

Definition GroupCoordinator__cquorum: val :=
  rec: "GroupCoordinator__cquorum" "gcoord" "n" :=
    (ClassicQuorum (MapLen (struct.loadF GroupCoordinator "rps" "gcoord"))) ≤ "n".

Definition countbm: val :=
  rec: "countbm" "m" "b" :=
    let: "n" := ref_to uint64T #0 in
    MapIter "m" (λ: <> "v",
      (if: "v" = "b"
      then "n" <-[uint64T] ((![uint64T] "n") + #1)
      else #()));;
    ![uint64T] "n".

Definition GroupCoordinator__tryBecomeAborted: val :=
  rec: "GroupCoordinator__tryBecomeAborted" "gcoord" :=
    let: "n" := countbm (struct.loadF GroupCoordinator "fresps" "gcoord") #false in
    (if: GroupCoordinator__fquorum "gcoord" "n"
    then
      struct.storeF GroupCoordinator "phase" "gcoord" GCOORD_ABORTED;;
      #()
    else #()).

Definition GroupCoordinator__tryBecomePrepared: val :=
  rec: "GroupCoordinator__tryBecomePrepared" "gcoord" :=
    let: "n" := countbm (struct.loadF GroupCoordinator "fresps" "gcoord") #true in
    (if: GroupCoordinator__fquorum "gcoord" "n"
    then
      struct.storeF GroupCoordinator "phase" "gcoord" GCOORD_PREPARED;;
      #true
    else #false).

Definition GroupCoordinator__tryBecomePreparing: val :=
  rec: "GroupCoordinator__tryBecomePreparing" "gcoord" :=
    let: "n" := MapLen (struct.loadF GroupCoordinator "sresps" "gcoord") in
    (if: GroupCoordinator__cquorum "gcoord" "n"
    then
      struct.storeF GroupCoordinator "phase" "gcoord" GCOORD_PREPARING;;
      struct.storeF GroupCoordinator "sresps" "gcoord" (NewMap uint64T boolT #());;
      #()
    else #()).

Definition GroupCoordinator__processFastPrepareResult: val :=
  rec: "GroupCoordinator__processFastPrepareResult" "gcoord" "rid" "res" :=
    (if: GroupCoordinator__tryResign "gcoord" "res"
    then #()
    else
      (if: "res" = RESULT_FAILED_VALIDATION
      then
        MapInsert (struct.loadF GroupCoordinator "fresps" "gcoord") "rid" #false;;
        GroupCoordinator__tryBecomeAborted "gcoord";;
        #()
      else
        MapInsert (struct.loadF GroupCoordinator "fresps" "gcoord") "rid" #true;;
        (if: GroupCoordinator__tryBecomePrepared "gcoord"
        then #()
        else
          (if: (struct.loadF GroupCoordinator "phase" "gcoord") ≠ GCOORD_VALIDATING
          then #()
          else
            MapInsert (struct.loadF GroupCoordinator "sresps" "gcoord") "rid" #true;;
            GroupCoordinator__tryBecomePreparing "gcoord";;
            #())))).

Definition GroupCoordinator__ProcessFastPrepareResult: val :=
  rec: "GroupCoordinator__ProcessFastPrepareResult" "gcoord" "rid" "res" :=
    Mutex__Lock (struct.loadF GroupCoordinator "mu" "gcoord");;
    GroupCoordinator__processFastPrepareResult "gcoord" "rid" "res";;
    Mutex__Unlock (struct.loadF GroupCoordinator "mu" "gcoord");;
    #().

Definition GroupCoordinator__processValidateResult: val :=
  rec: "GroupCoordinator__processValidateResult" "gcoord" "rid" "res" :=
    (if: GroupCoordinator__tryResign "gcoord" "res"
    then #()
    else
      (if: (struct.loadF GroupCoordinator "phase" "gcoord") ≠ GCOORD_VALIDATING
      then #()
      else
        (if: "res" = RESULT_FAILED_VALIDATION
        then #()
        else
          MapInsert (struct.loadF GroupCoordinator "sresps" "gcoord") "rid" #true;;
          GroupCoordinator__tryBecomePreparing "gcoord";;
          #()))).

Definition GroupCoordinator__ProcessValidateResult: val :=
  rec: "GroupCoordinator__ProcessValidateResult" "gcoord" "rid" "res" :=
    Mutex__Lock (struct.loadF GroupCoordinator "mu" "gcoord");;
    GroupCoordinator__processValidateResult "gcoord" "rid" "res";;
    Mutex__Unlock (struct.loadF GroupCoordinator "mu" "gcoord");;
    #().

Definition GroupCoordinator__ProcessPrepareResult: val :=
  rec: "GroupCoordinator__ProcessPrepareResult" "gcoord" "rid" "res" :=
    Mutex__Lock (struct.loadF GroupCoordinator "mu" "gcoord");;
    (if: GroupCoordinator__tryResign "gcoord" "res"
    then
      Mutex__Unlock (struct.loadF GroupCoordinator "mu" "gcoord");;
      #()
    else
      MapInsert (struct.loadF GroupCoordinator "sresps" "gcoord") "rid" #true;;
      let: "n" := MapLen (struct.loadF GroupCoordinator "sresps" "gcoord") in
      (if: GroupCoordinator__cquorum "gcoord" "n"
      then struct.storeF GroupCoordinator "phase" "gcoord" GCOORD_PREPARED
      else #());;
      Mutex__Unlock (struct.loadF GroupCoordinator "mu" "gcoord");;
      #()).

Definition GroupCoordinator__ProcessUnprepareResult: val :=
  rec: "GroupCoordinator__ProcessUnprepareResult" "gcoord" "rid" "res" :=
    Mutex__Lock (struct.loadF GroupCoordinator "mu" "gcoord");;
    (if: GroupCoordinator__tryResign "gcoord" "res"
    then
      Mutex__Unlock (struct.loadF GroupCoordinator "mu" "gcoord");;
      #()
    else
      MapInsert (struct.loadF GroupCoordinator "sresps" "gcoord") "rid" #true;;
      let: "n" := MapLen (struct.loadF GroupCoordinator "sresps" "gcoord") in
      (if: GroupCoordinator__cquorum "gcoord" "n"
      then struct.storeF GroupCoordinator "phase" "gcoord" GCOORD_ABORTED
      else #());;
      Mutex__Unlock (struct.loadF GroupCoordinator "mu" "gcoord");;
      #()).

Definition GroupCoordinator__ProcessQueryResult: val :=
  rec: "GroupCoordinator__ProcessQueryResult" "gcoord" "rid" "res" :=
    Mutex__Lock (struct.loadF GroupCoordinator "mu" "gcoord");;
    GroupCoordinator__tryResign "gcoord" "res";;
    Mutex__Unlock (struct.loadF GroupCoordinator "mu" "gcoord");;
    #().

Definition GroupCoordinator__PrepareDone: val :=
  rec: "GroupCoordinator__PrepareDone" "gcoord" :=
    Mutex__Lock (struct.loadF GroupCoordinator "mu" "gcoord");;
    let: "done" := GCOORD_PREPARED ≤ (struct.loadF GroupCoordinator "phase" "gcoord") in
    Mutex__Unlock (struct.loadF GroupCoordinator "mu" "gcoord");;
    "done".

Definition GroupCoordinator__GetPhase: val :=
  rec: "GroupCoordinator__GetPhase" "gcoord" :=
    Mutex__Lock (struct.loadF GroupCoordinator "mu" "gcoord");;
    let: "phase" := struct.loadF GroupCoordinator "phase" "gcoord" in
    Mutex__Unlock (struct.loadF GroupCoordinator "mu" "gcoord");;
    "phase".

Definition GroupCoordinator__changeLeader: val :=
  rec: "GroupCoordinator__changeLeader" "gcoord" :=
    #().

Definition slicem: val :=
  rec: "slicem" "m" :=
    slice.nil.

Definition GroupCoordinator__BeginSession: val :=
  rec: "GroupCoordinator__BeginSession" "gcoord" "rid" "ts" "ptgs" :=
    let: "rp" := Fst (MapGet (struct.loadF GroupCoordinator "rps" "gcoord") "rid") in
    let: "pwrs" := slicem (struct.loadF GroupCoordinator "pwrs" "gcoord") in
    let: "act" := ref_to uint64T (GroupCoordinator__Action "gcoord" "rid") in
    Skip;;
    (for: (λ: <>, (![uint64T] "act") ≠ GCOORD_COMPLETE); (λ: <>, Skip) := λ: <>,
      (if: (![uint64T] "act") = GCOORD_FAST_PREPARE
      then
        let: "res" := Replica__FastPrepare "rp" "ts" "pwrs" "ptgs" in
        GroupCoordinator__ProcessFastPrepareResult "gcoord" "rid" "res"
      else
        (if: (![uint64T] "act") = GCOORD_VALIDATE
        then
          let: "res" := Replica__Validate "rp" "ts" #1 "pwrs" "ptgs" in
          GroupCoordinator__ProcessValidateResult "gcoord" "rid" "res"
        else
          (if: (![uint64T] "act") = GCOORD_PREPARE
          then
            let: "res" := Replica__Prepare "rp" "ts" #1 in
            GroupCoordinator__ProcessPrepareResult "gcoord" "rid" "res"
          else
            (if: (![uint64T] "act") = GCOORD_UNPREPARE
            then
              let: "res" := Replica__Unprepare "rp" "ts" #1 in
              GroupCoordinator__ProcessUnprepareResult "gcoord" "rid" "res"
            else
              (if: (![uint64T] "act") = GCOORD_QUERY
              then
                let: "res" := Replica__Query "rp" "ts" #1 in
                GroupCoordinator__ProcessQueryResult "gcoord" "rid" "res"
              else #())))));;
      "act" <-[uint64T] (GroupCoordinator__Action "gcoord" "rid");;
      Continue);;
    #().

Definition TXN_PREPARED : expr := #0.

Definition TXN_COMMITTED : expr := #1.

Definition TXN_ABORTED : expr := #2.

(* Arguments:
   @ts: Transaction timestamp.

   Return values:
   @status: Transaction status. *)
Definition GroupCoordinator__Prepare: val :=
  rec: "GroupCoordinator__Prepare" "gcoord" "ts" "ptgs" :=
    MapIter (struct.loadF GroupCoordinator "rps" "gcoord") (λ: "ridloop" <>,
      let: "rid" := "ridloop" in
      Fork (GroupCoordinator__BeginSession "gcoord" "rid" "ts" "ptgs"));;
    Skip;;
    (for: (λ: <>, (~ (GroupCoordinator__PrepareDone "gcoord"))); (λ: <>, Skip) := λ: <>,
      Continue);;
    let: "phase" := GroupCoordinator__GetPhase "gcoord" in
    (if: "phase" = GCOORD_COMMITTED
    then TXN_COMMITTED
    else
      (if: "phase" = GCOORD_ABORTED
      then TXN_ABORTED
      else TXN_PREPARED)).

Definition GroupCoordinator__Commit: val :=
  rec: "GroupCoordinator__Commit" "gcoord" "ts" :=
    let: "pwrs" := slicem (struct.loadF GroupCoordinator "pwrs" "gcoord") in
    Skip;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "rp" := Fst (MapGet (struct.loadF GroupCoordinator "rps" "gcoord") (struct.loadF GroupCoordinator "leader" "gcoord")) in
      let: "ok" := Replica__Commit "rp" "ts" "pwrs" in
      (if: "ok"
      then Break
      else
        GroupCoordinator__changeLeader "gcoord";;
        Continue));;
    #().

Definition GroupCoordinator__Abort: val :=
  rec: "GroupCoordinator__Abort" "gcoord" "ts" :=
    Skip;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "rp" := Fst (MapGet (struct.loadF GroupCoordinator "rps" "gcoord") (struct.loadF GroupCoordinator "leader" "gcoord")) in
      let: "ok" := Replica__Abort "rp" "ts" in
      (if: "ok"
      then Break
      else
        GroupCoordinator__changeLeader "gcoord";;
        Continue));;
    #().

Definition GroupReader := struct.decl [
  "rps" :: mapT ptrT;
  "mu" :: ptrT;
  "rds" :: mapT (struct.t Value);
  "versm" :: mapT (mapT (struct.t Version))
].

Definition Txn := struct.decl [
  "ts" :: uint64T;
  "wrs" :: mapT (mapT (struct.t Value));
  "grds" :: mapT ptrT;
  "leaders" :: mapT uint64T
].

Definition TxnCoordinator := struct.decl [
  "ts" :: uint64T;
  "gcoords" :: mapT ptrT
].

Definition GetTS: val :=
  rec: "GetTS" <> :=
    #0.

Definition Txn__begin: val :=
  rec: "Txn__begin" "txn" :=
    struct.storeF Txn "ts" "txn" (GetTS #());;
    #().

(* Main proof for this simplified program. *)
Definition TxnCoordinator__prepare: val :=
  rec: "TxnCoordinator__prepare" "tcoord" :=
    let: "ptgs" := ref_to (slice.T uint64T) (NewSliceWithCap uint64T #0 (MapLen (struct.loadF TxnCoordinator "gcoords" "tcoord"))) in
    MapIter (struct.loadF TxnCoordinator "gcoords" "tcoord") (λ: "gid" <>,
      "ptgs" <-[slice.T uint64T] (SliceAppend uint64T (![slice.T uint64T] "ptgs") "gid"));;
    let: "status" := ref_to uint64T TXN_PREPARED in
    let: "gid" := ref_to uint64T #0 in
    Skip;;
    (for: (λ: <>, (![uint64T] "gid") < (MapLen (struct.loadF TxnCoordinator "gcoords" "tcoord"))); (λ: <>, Skip) := λ: <>,
      let: "gcoord" := Fst (MapGet (struct.loadF TxnCoordinator "gcoords" "tcoord") (![uint64T] "gid")) in
      "status" <-[uint64T] (GroupCoordinator__Prepare "gcoord" (struct.loadF TxnCoordinator "ts" "tcoord") (![slice.T uint64T] "ptgs"));;
      (if: (![uint64T] "status") ≠ TXN_PREPARED
      then Break
      else
        "gid" <-[uint64T] ((![uint64T] "gid") + #1);;
        Continue));;
    ![uint64T] "status".

Definition TxnCoordinator__commit: val :=
  rec: "TxnCoordinator__commit" "tcoord" :=
    MapIter (struct.loadF TxnCoordinator "gcoords" "tcoord") (λ: <> "gcoord",
      GroupCoordinator__Commit "gcoord" (struct.loadF TxnCoordinator "ts" "tcoord"));;
    #().

Definition TxnCoordinator__abort: val :=
  rec: "TxnCoordinator__abort" "tcoord" :=
    MapIter (struct.loadF TxnCoordinator "gcoords" "tcoord") (λ: <> "gcoord",
      GroupCoordinator__Abort "gcoord" (struct.loadF TxnCoordinator "ts" "tcoord"));;
    #().

Definition KeyToGroup: val :=
  rec: "KeyToGroup" "key" :=
    #0.

Definition GroupReader__cquorum: val :=
  rec: "GroupReader__cquorum" "grd" "n" :=
    (ClassicQuorum (MapLen (struct.loadF GroupReader "rps" "grd"))) ≤ "n".

Definition GroupReader__latestVersion: val :=
  rec: "GroupReader__latestVersion" "grd" "key" :=
    let: "latest" := ref (zero_val (struct.t Version)) in
    let: "vers" := Fst (MapGet (struct.loadF GroupReader "versm" "grd") "key") in
    MapIter "vers" (λ: <> "ver",
      (if: (struct.get Version "ts" (![struct.t Version] "latest")) < (struct.get Version "ts" "ver")
      then "latest" <-[struct.t Version] "ver"
      else #()));;
    ![struct.t Version] "latest".

Definition GroupReader__replicaDone: val :=
  rec: "GroupReader__replicaDone" "grd" "rid" "key" :=
    let: (<>, "final") := MapGet (struct.loadF GroupReader "rds" "grd") "key" in
    (if: "final"
    then #true
    else
      let: "vers" := Fst (MapGet (struct.loadF GroupReader "versm" "grd") "key") in
      let: (<>, "responded") := MapGet "vers" "rid" in
      (if: "responded"
      then #true
      else #false)).

Definition GroupReader__ReplicaDone: val :=
  rec: "GroupReader__ReplicaDone" "grd" "rid" "key" :=
    Mutex__Lock (struct.loadF GroupReader "mu" "grd");;
    let: "ready" := GroupReader__replicaDone "grd" "rid" "key" in
    Mutex__Unlock (struct.loadF GroupReader "mu" "grd");;
    "ready".

Definition GroupReader__processReadResult: val :=
  rec: "GroupReader__processReadResult" "grd" "rid" "key" "ver" :=
    let: (<>, "final") := MapGet (struct.loadF GroupReader "rds" "grd") "key" in
    (if: "final"
    then #()
    else
      let: "vers" := Fst (MapGet (struct.loadF GroupReader "versm" "grd") "key") in
      let: (<>, "responded") := MapGet "vers" "rid" in
      (if: "responded"
      then #()
      else
        MapInsert "vers" "rid" "ver";;
        let: "n" := MapLen "vers" in
        (if: (~ (GroupReader__cquorum "grd" "n"))
        then #()
        else
          let: "latest" := GroupReader__latestVersion "grd" "key" in
          MapInsert (struct.loadF GroupReader "rds" "grd") "key" (struct.get Version "val" "latest");;
          MapDelete (struct.loadF GroupReader "versm" "grd") "key";;
          #()))).

Definition GroupReader__ProcessReadResult: val :=
  rec: "GroupReader__ProcessReadResult" "grd" "rid" "key" "ver" :=
    Mutex__Lock (struct.loadF GroupReader "mu" "grd");;
    GroupReader__processReadResult "grd" "rid" "key" "ver";;
    Mutex__Unlock (struct.loadF GroupReader "mu" "grd");;
    #().

Definition GroupReader__BeginSession: val :=
  rec: "GroupReader__BeginSession" "grd" "rid" "ts" "key" :=
    let: "rp" := Fst (MapGet (struct.loadF GroupReader "rps" "grd") "rid") in
    Skip;;
    (for: (λ: <>, GroupReader__ReplicaDone "grd" "rid" "key"); (λ: <>, Skip) := λ: <>,
      let: ("ver", "ok") := Replica__Read "rp" "ts" "key" in
      (if: "ok"
      then
        GroupReader__ProcessReadResult "grd" "rid" "key" "ver";;
        Continue
      else Continue));;
    #().

Definition GroupReader__Done: val :=
  rec: "GroupReader__Done" "grd" "key" :=
    Mutex__Lock (struct.loadF GroupReader "mu" "grd");;
    let: (<>, "final") := MapGet (struct.loadF GroupReader "rds" "grd") "key" in
    Mutex__Unlock (struct.loadF GroupReader "mu" "grd");;
    "final".

Definition GroupReader__Read: val :=
  rec: "GroupReader__Read" "grd" "ts" "key" :=
    MapIter (struct.loadF GroupReader "rps" "grd") (λ: "ridloop" <>,
      let: "rid" := "ridloop" in
      Fork (GroupReader__BeginSession "grd" "rid" "ts" "key"));;
    Skip;;
    (for: (λ: <>, (~ (GroupReader__Done "grd" "key"))); (λ: <>, Skip) := λ: <>,
      Continue);;
    Mutex__Lock (struct.loadF GroupReader "mu" "grd");;
    let: "v" := Fst (MapGet (struct.loadF GroupReader "rds" "grd") "key") in
    Mutex__Unlock (struct.loadF GroupReader "mu" "grd");;
    "v".

Definition Txn__Read: val :=
  rec: "Txn__Read" "txn" "key" :=
    let: "gid" := KeyToGroup "key" in
    let: "grd" := Fst (MapGet (struct.loadF Txn "grds" "txn") "gid") in
    let: "v" := GroupReader__Read "grd" (struct.loadF Txn "ts" "txn") "key" in
    "v".

Definition Txn__Write: val :=
  rec: "Txn__Write" "txn" "key" "value" :=
    let: "gid" := KeyToGroup "key" in
    let: "pwrs" := Fst (MapGet (struct.loadF Txn "wrs" "txn") "gid") in
    let: "v" := struct.mk Value [
      "b" ::= #true;
      "s" ::= "value"
    ] in
    MapInsert "pwrs" "key" "v";;
    #().

Definition Txn__Delete: val :=
  rec: "Txn__Delete" "txn" "key" :=
    let: "gid" := KeyToGroup "key" in
    let: "pwrs" := Fst (MapGet (struct.loadF Txn "wrs" "txn") "gid") in
    let: "v" := struct.mk Value [
      "b" ::= #false
    ] in
    MapInsert "pwrs" "key" "v";;
    #().

Definition Txn__mkTxnCoordinator: val :=
  rec: "Txn__mkTxnCoordinator" "txn" :=
    let: "gcoords" := NewMap uint64T ptrT #() in
    MapIter (struct.loadF Txn "grds" "txn") (λ: "gid" "grd",
      let: "gcoord" := struct.mk GroupCoordinator [
        "rps" ::= struct.loadF GroupReader "rps" "grd";
        "leader" ::= Fst (MapGet (struct.loadF Txn "leaders" "txn") "gid");
        "pwrs" ::= Fst (MapGet (struct.loadF Txn "wrs" "txn") "gid");
        "phase" ::= GCOORD_VALIDATING;
        "fresps" ::= NewMap uint64T boolT #();
        "sresps" ::= NewMap uint64T boolT #()
      ] in
      MapInsert "gcoords" "gid" "gcoord");;
    let: "tcoord" := struct.new TxnCoordinator [
      "ts" ::= struct.loadF Txn "ts" "txn";
      "gcoords" ::= "gcoords"
    ] in
    "tcoord".

(* Main proof for this simplifed program. *)
Definition Txn__Run: val :=
  rec: "Txn__Run" "txn" "body" :=
    Txn__begin "txn";;
    let: "cmt" := "body" "txn" in
    (if: (~ "cmt")
    then #false
    else
      let: "tcoord" := Txn__mkTxnCoordinator "txn" in
      let: "status" := TxnCoordinator__prepare "tcoord" in
      (if: "status" = TXN_COMMITTED
      then #true
      else
        (if: "status" = TXN_ABORTED
        then
          TxnCoordinator__abort "tcoord";;
          #false
        else
          TxnCoordinator__commit "tcoord";;
          #true))).

Definition NewTxn: val :=
  rec: "NewTxn" <> :=
    struct.new Txn [
    ].

Definition BackupGroupCoordinator := struct.decl [
  "rps" :: mapT ptrT;
  "pwrs" :: mapT (struct.t Value);
  "mu" :: ptrT;
  "leader" :: uint64T;
  "phase" :: uint64T;
  "pps" :: mapT (struct.t PrepareProposal);
  "resps" :: mapT boolT
].

Definition BGCOORD_INQUIRING : expr := #0.

Definition BGCOORD_VALIDATING : expr := #1.

Definition BGCOORD_PREPARING : expr := #2.

Definition BGCOORD_UNPREPARING : expr := #3.

Definition BGCOORD_OVERTHROWN : expr := #4.

Definition BGCOORD_PREPARED : expr := #5.

Definition BGCOORD_COMMITTED : expr := #6.

Definition BGCOORD_ABORTED : expr := #7.

Definition BGCOORD_INQUIRE : expr := #0.

Definition BGCOORD_VALIDATE : expr := #1.

Definition BGCOORD_PREPARE : expr := #2.

Definition BGCOORD_UNPREPARE : expr := #3.

Definition BGCOORD_QUERY : expr := #4.

Definition BGCOORD_COMPLETE : expr := #5.

(* Argument:
   @rid: ID of the replica to which a new action is performed.

   Return value:
   @action: Next action to perform. *)
Definition BackupGroupCoordinator__action: val :=
  rec: "BackupGroupCoordinator__action" "gcoord" "rid" :=
    (if: (struct.loadF BackupGroupCoordinator "phase" "gcoord") = BGCOORD_INQUIRING
    then
      let: (<>, "inquired") := MapGet (struct.loadF BackupGroupCoordinator "pps" "gcoord") "rid" in
      (if: (~ "inquired")
      then BGCOORD_INQUIRE
      else BGCOORD_QUERY)
    else
      (if: (struct.loadF BackupGroupCoordinator "phase" "gcoord") = BGCOORD_VALIDATING
      then
        let: (<>, "inquired") := MapGet (struct.loadF BackupGroupCoordinator "pps" "gcoord") "rid" in
        (if: (~ "inquired")
        then BGCOORD_INQUIRE
        else
          let: (<>, "validated") := MapGet (struct.loadF BackupGroupCoordinator "resps" "gcoord") "rid" in
          (if: (~ "validated")
          then BGCOORD_VALIDATE
          else BGCOORD_QUERY))
      else
        (if: (struct.loadF BackupGroupCoordinator "phase" "gcoord") = BGCOORD_PREPARING
        then
          let: (<>, "prepared") := MapGet (struct.loadF BackupGroupCoordinator "resps" "gcoord") "rid" in
          (if: (~ "prepared")
          then BGCOORD_PREPARE
          else BGCOORD_QUERY)
        else
          (if: (struct.loadF BackupGroupCoordinator "phase" "gcoord") = BGCOORD_UNPREPARING
          then
            let: (<>, "unprepared") := MapGet (struct.loadF BackupGroupCoordinator "resps" "gcoord") "rid" in
            (if: (~ "unprepared")
            then BGCOORD_UNPREPARE
            else BGCOORD_QUERY)
          else BGCOORD_COMPLETE)))).

Definition BackupGroupCoordinator__Action: val :=
  rec: "BackupGroupCoordinator__Action" "gcoord" "rid" :=
    Mutex__Lock (struct.loadF BackupGroupCoordinator "mu" "gcoord");;
    let: "act" := BackupGroupCoordinator__action "gcoord" "rid" in
    Mutex__Unlock (struct.loadF BackupGroupCoordinator "mu" "gcoord");;
    "act".

Definition BackupGroupCoordinator__fquorum: val :=
  rec: "BackupGroupCoordinator__fquorum" "gcoord" "n" :=
    (FastQuorum (MapLen (struct.loadF BackupGroupCoordinator "rps" "gcoord"))) ≤ "n".

Definition BackupGroupCoordinator__cquorum: val :=
  rec: "BackupGroupCoordinator__cquorum" "gcoord" "n" :=
    (ClassicQuorum (MapLen (struct.loadF BackupGroupCoordinator "rps" "gcoord"))) ≤ "n".

Definition BackupGroupCoordinator__hcquorum: val :=
  rec: "BackupGroupCoordinator__hcquorum" "gcoord" "n" :=
    (Half (ClassicQuorum (MapLen (struct.loadF BackupGroupCoordinator "rps" "gcoord")))) ≤ "n".

Definition BackupGroupCoordinator__tryResign: val :=
  rec: "BackupGroupCoordinator__tryResign" "gcoord" "res" :=
    (if: BGCOORD_PREPARED ≤ (struct.loadF BackupGroupCoordinator "phase" "gcoord")
    then #true
    else
      (if: "res" = RESULT_COMMITTED_TXN
      then
        struct.storeF BackupGroupCoordinator "phase" "gcoord" BGCOORD_COMMITTED;;
        #true
      else
        (if: "res" = RESULT_ABORTED_TXN
        then
          struct.storeF BackupGroupCoordinator "phase" "gcoord" BGCOORD_ABORTED;;
          #true
        else
          (if: "res" = RESULT_STALE_COORDINATOR
          then
            struct.storeF BackupGroupCoordinator "phase" "gcoord" BGCOORD_OVERTHROWN;;
            #true
          else #false)))).

Definition BackupGroupCoordinator__ProcessPrepareResult: val :=
  rec: "BackupGroupCoordinator__ProcessPrepareResult" "gcoord" "rid" "res" :=
    Mutex__Lock (struct.loadF BackupGroupCoordinator "mu" "gcoord");;
    (if: BackupGroupCoordinator__tryResign "gcoord" "res"
    then
      Mutex__Unlock (struct.loadF BackupGroupCoordinator "mu" "gcoord");;
      #()
    else
      MapInsert (struct.loadF BackupGroupCoordinator "resps" "gcoord") "rid" #true;;
      let: "n" := MapLen (struct.loadF BackupGroupCoordinator "resps" "gcoord") in
      (if: BackupGroupCoordinator__cquorum "gcoord" "n"
      then struct.storeF BackupGroupCoordinator "phase" "gcoord" BGCOORD_PREPARED
      else #());;
      Mutex__Unlock (struct.loadF BackupGroupCoordinator "mu" "gcoord");;
      #()).

Definition BackupGroupCoordinator__ProcessUnprepareResult: val :=
  rec: "BackupGroupCoordinator__ProcessUnprepareResult" "gcoord" "rid" "res" :=
    Mutex__Lock (struct.loadF BackupGroupCoordinator "mu" "gcoord");;
    (if: BackupGroupCoordinator__tryResign "gcoord" "res"
    then
      Mutex__Unlock (struct.loadF BackupGroupCoordinator "mu" "gcoord");;
      #()
    else
      MapInsert (struct.loadF BackupGroupCoordinator "resps" "gcoord") "rid" #true;;
      let: "n" := MapLen (struct.loadF BackupGroupCoordinator "resps" "gcoord") in
      (if: BackupGroupCoordinator__cquorum "gcoord" "n"
      then struct.storeF BackupGroupCoordinator "phase" "gcoord" BGCOORD_ABORTED
      else #());;
      Mutex__Unlock (struct.loadF BackupGroupCoordinator "mu" "gcoord");;
      #()).

(* Return value:
   @latest: The latest non-fast proposal if @latest.rank > 0; @gcoord.pps
   contain only fast proposals if @latest.rank == 0. *)
Definition BackupGroupCoordinator__latestProposal: val :=
  rec: "BackupGroupCoordinator__latestProposal" "gcoord" :=
    let: "latest" := ref (zero_val (struct.t PrepareProposal)) in
    MapIter (struct.loadF BackupGroupCoordinator "pps" "gcoord") (λ: <> "pp",
      (if: (struct.get PrepareProposal "rank" (![struct.t PrepareProposal] "latest")) < (struct.get PrepareProposal "rank" "pp")
      then "latest" <-[struct.t PrepareProposal] "pp"
      else #()));;
    ![struct.t PrepareProposal] "latest".

(* Return value:
   @nprep: The number of fast unprepares collected in @gcoord.pps. *)
Definition BackupGroupCoordinator__countFastUnprepare: val :=
  rec: "BackupGroupCoordinator__countFastUnprepare" "gcoord" :=
    let: "nprep" := ref (zero_val uint64T) in
    MapIter (struct.loadF BackupGroupCoordinator "pps" "gcoord") (λ: <> "pp",
      (if: ((struct.get PrepareProposal "rank" "pp") = #0) && (~ (struct.get PrepareProposal "dec" "pp"))
      then "nprep" <-[uint64T] ((![uint64T] "nprep") + #1)
      else #()));;
    ![uint64T] "nprep".

Definition BackupGroupCoordinator__processInquireResult: val :=
  rec: "BackupGroupCoordinator__processInquireResult" "gcoord" "rid" "pp" "vd" "res" :=
    (if: BackupGroupCoordinator__tryResign "gcoord" "res"
    then #()
    else
      (if: ((struct.loadF BackupGroupCoordinator "phase" "gcoord") = BGCOORD_PREPARING) || ((struct.loadF BackupGroupCoordinator "phase" "gcoord") = BGCOORD_UNPREPARING)
      then #()
      else
        MapInsert (struct.loadF BackupGroupCoordinator "pps" "gcoord") "rid" "pp";;
        (if: "vd"
        then MapInsert (struct.loadF BackupGroupCoordinator "resps" "gcoord") "rid" #true
        else #());;
        let: "n" := MapLen (struct.loadF BackupGroupCoordinator "pps" "gcoord") in
        (if: (~ (BackupGroupCoordinator__cquorum "gcoord" "n"))
        then #()
        else
          let: "latest" := BackupGroupCoordinator__latestProposal "gcoord" in
          (if: (struct.get PrepareProposal "rank" "latest") ≠ #0
          then
            (if: struct.get PrepareProposal "dec" "latest"
            then struct.storeF BackupGroupCoordinator "phase" "gcoord" BGCOORD_PREPARING
            else struct.storeF BackupGroupCoordinator "phase" "gcoord" BGCOORD_UNPREPARING);;
            #()
          else
            let: "nfu" := BackupGroupCoordinator__countFastUnprepare "gcoord" in
            (if: BackupGroupCoordinator__hcquorum "gcoord" "nfu"
            then
              struct.storeF BackupGroupCoordinator "phase" "gcoord" BGCOORD_UNPREPARING;;
              #()
            else
              let: "nvd" := MapLen (struct.loadF BackupGroupCoordinator "resps" "gcoord") in
              (if: BackupGroupCoordinator__cquorum "gcoord" "nvd"
              then
                struct.storeF BackupGroupCoordinator "phase" "gcoord" BGCOORD_PREPARING;;
                #()
              else
                struct.storeF BackupGroupCoordinator "phase" "gcoord" BGCOORD_VALIDATING;;
                #())))))).

Definition BackupGroupCoordinator__ProcessInquireResult: val :=
  rec: "BackupGroupCoordinator__ProcessInquireResult" "gcoord" "rid" "pp" "vd" "res" :=
    Mutex__Lock (struct.loadF BackupGroupCoordinator "mu" "gcoord");;
    BackupGroupCoordinator__processInquireResult "gcoord" "rid" "pp" "vd" "res";;
    Mutex__Unlock (struct.loadF BackupGroupCoordinator "mu" "gcoord");;
    #().

Definition BackupGroupCoordinator__processValidateResult: val :=
  rec: "BackupGroupCoordinator__processValidateResult" "gcoord" "rid" "res" :=
    (if: BackupGroupCoordinator__tryResign "gcoord" "res"
    then #()
    else
      (if: (struct.loadF BackupGroupCoordinator "phase" "gcoord") ≠ BGCOORD_VALIDATING
      then #()
      else
        (if: "res" = RESULT_FAILED_VALIDATION
        then #()
        else
          MapInsert (struct.loadF BackupGroupCoordinator "resps" "gcoord") "rid" #true;;
          let: "nvd" := MapLen (struct.loadF BackupGroupCoordinator "resps" "gcoord") in
          (if: BackupGroupCoordinator__cquorum "gcoord" "nvd"
          then
            struct.storeF BackupGroupCoordinator "phase" "gcoord" BGCOORD_PREPARING;;
            #()
          else #())))).

Definition BackupGroupCoordinator__ProcessValidateResult: val :=
  rec: "BackupGroupCoordinator__ProcessValidateResult" "gcoord" "rid" "res" :=
    Mutex__Lock (struct.loadF BackupGroupCoordinator "mu" "gcoord");;
    BackupGroupCoordinator__processValidateResult "gcoord" "rid" "res";;
    Mutex__Unlock (struct.loadF BackupGroupCoordinator "mu" "gcoord");;
    #().

Definition BackupGroupCoordinator__ProcessQueryResult: val :=
  rec: "BackupGroupCoordinator__ProcessQueryResult" "gcoord" "rid" "res" :=
    Mutex__Lock (struct.loadF BackupGroupCoordinator "mu" "gcoord");;
    BackupGroupCoordinator__tryResign "gcoord" "res";;
    Mutex__Unlock (struct.loadF BackupGroupCoordinator "mu" "gcoord");;
    #().

Definition BackupGroupCoordinator__BeginSession: val :=
  rec: "BackupGroupCoordinator__BeginSession" "gcoord" "rid" "ts" "rank" "ptgs" :=
    let: "rp" := Fst (MapGet (struct.loadF BackupGroupCoordinator "rps" "gcoord") "rid") in
    let: "pwrs" := slicem (struct.loadF BackupGroupCoordinator "pwrs" "gcoord") in
    let: "act" := ref_to uint64T (BackupGroupCoordinator__Action "gcoord" "rid") in
    Skip;;
    (for: (λ: <>, (![uint64T] "act") ≠ BGCOORD_COMPLETE); (λ: <>, Skip) := λ: <>,
      (if: (![uint64T] "act") = BGCOORD_INQUIRE
      then
        let: (("pp", "vd"), "res") := Replica__Inquire "rp" "ts" "rank" in
        BackupGroupCoordinator__ProcessInquireResult "gcoord" "rid" "pp" "vd" "res"
      else
        (if: (![uint64T] "act") = BGCOORD_VALIDATE
        then
          let: "res" := Replica__Validate "rp" "ts" "rank" "pwrs" "ptgs" in
          BackupGroupCoordinator__ProcessValidateResult "gcoord" "rid" "res"
        else
          (if: (![uint64T] "act") = BGCOORD_PREPARE
          then
            let: "res" := Replica__Prepare "rp" "ts" "rank" in
            BackupGroupCoordinator__ProcessPrepareResult "gcoord" "rid" "res"
          else
            (if: (![uint64T] "act") = BGCOORD_UNPREPARE
            then
              let: "res" := Replica__Unprepare "rp" "ts" "rank" in
              BackupGroupCoordinator__ProcessUnprepareResult "gcoord" "rid" "res"
            else
              (if: (![uint64T] "act") = BGCOORD_QUERY
              then
                let: "res" := Replica__Query "rp" "ts" "rank" in
                BackupGroupCoordinator__ProcessQueryResult "gcoord" "rid" "res"
              else #())))));;
      "act" <-[uint64T] (BackupGroupCoordinator__Action "gcoord" "rid");;
      Continue);;
    #().

Definition BackupGroupCoordinator__InquireDone: val :=
  rec: "BackupGroupCoordinator__InquireDone" "gcoord" :=
    Mutex__Lock (struct.loadF BackupGroupCoordinator "mu" "gcoord");;
    let: "done" := BGCOORD_PREPARED ≤ (struct.loadF BackupGroupCoordinator "phase" "gcoord") in
    Mutex__Unlock (struct.loadF BackupGroupCoordinator "mu" "gcoord");;
    "done".

Definition BackupGroupCoordinator__GetPhase: val :=
  rec: "BackupGroupCoordinator__GetPhase" "gcoord" :=
    Mutex__Lock (struct.loadF BackupGroupCoordinator "mu" "gcoord");;
    let: "phase" := struct.loadF BackupGroupCoordinator "phase" "gcoord" in
    Mutex__Unlock (struct.loadF BackupGroupCoordinator "mu" "gcoord");;
    "phase".

Definition BackupGroupCoordinator__changeLeader: val :=
  rec: "BackupGroupCoordinator__changeLeader" "gcoord" :=
    #().

(* Arguments:
   @ts: Transaction timestamp.

   Return values:
   @status: Transaction status.
   @valid: The @Inquire process goes through without encountering a more recent
   coordinator. @status is meaningful iff @valid is true. *)
Definition BackupGroupCoordinator__Inquire: val :=
  rec: "BackupGroupCoordinator__Inquire" "gcoord" "ts" "rank" "ptgs" :=
    MapIter (struct.loadF BackupGroupCoordinator "rps" "gcoord") (λ: "ridloop" <>,
      let: "rid" := "ridloop" in
      Fork (BackupGroupCoordinator__BeginSession "gcoord" "rid" "ts" "rank" "ptgs"));;
    Skip;;
    (for: (λ: <>, (~ (BackupGroupCoordinator__InquireDone "gcoord"))); (λ: <>, Skip) := λ: <>,
      Continue);;
    let: "phase" := BackupGroupCoordinator__GetPhase "gcoord" in
    (if: "phase" = BGCOORD_OVERTHROWN
    then (TXN_PREPARED, #false)
    else
      (if: "phase" = GCOORD_COMMITTED
      then (TXN_COMMITTED, #true)
      else
        (if: "phase" = GCOORD_ABORTED
        then (TXN_ABORTED, #true)
        else (TXN_PREPARED, #true)))).

Definition BackupGroupCoordinator__Commit: val :=
  rec: "BackupGroupCoordinator__Commit" "gcoord" "ts" :=
    let: "pwrs" := slicem (struct.loadF BackupGroupCoordinator "pwrs" "gcoord") in
    Skip;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "rp" := Fst (MapGet (struct.loadF BackupGroupCoordinator "rps" "gcoord") (struct.loadF BackupGroupCoordinator "leader" "gcoord")) in
      let: "ok" := Replica__Commit "rp" "ts" "pwrs" in
      (if: "ok"
      then Break
      else
        BackupGroupCoordinator__changeLeader "gcoord";;
        Continue));;
    #().

Definition BackupGroupCoordinator__Abort: val :=
  rec: "BackupGroupCoordinator__Abort" "gcoord" "ts" :=
    Skip;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "rp" := Fst (MapGet (struct.loadF BackupGroupCoordinator "rps" "gcoord") (struct.loadF BackupGroupCoordinator "leader" "gcoord")) in
      let: "ok" := Replica__Abort "rp" "ts" in
      (if: "ok"
      then Break
      else
        BackupGroupCoordinator__changeLeader "gcoord";;
        Continue));;
    #().

Definition BackupTxnCoordinator := struct.decl [
  "ts" :: uint64T;
  "rank" :: uint64T;
  "ptgs" :: slice.T uint64T;
  "gcoords" :: mapT ptrT
].

Definition Replica__mkBackupTxnCoordinator: val :=
  rec: "Replica__mkBackupTxnCoordinator" "rp" "ts" :=
    let: "gcoords" := NewMap uint64T ptrT #() in
    let: "ptgs" := Fst (MapGet (struct.loadF Replica "ptgsm" "rp") "ts") in
    ForSlice uint64T <> "gid" "ptgs"
      (let: "gcoord" := struct.mk BackupGroupCoordinator [
        "leader" ::= struct.loadF Replica "leader" "rp";
        "rps" ::= struct.loadF Replica "rps" "rp";
        "phase" ::= BGCOORD_INQUIRING;
        "pps" ::= NewMap uint64T (struct.t PrepareProposal) #();
        "resps" ::= NewMap uint64T boolT #()
      ] in
      MapInsert "gcoords" "gid" "gcoord");;
    let: "ps" := Fst (MapGet (struct.loadF Replica "pstbl" "rp") "ts") in
    let: "rank" := (struct.get PrepareStatusEntry "rankl" "ps") + #1 in
    let: "tcoord" := struct.new BackupTxnCoordinator [
      "ts" ::= "ts";
      "rank" ::= "rank";
      "ptgs" ::= "ptgs";
      "gcoords" ::= "gcoords"
    ] in
    "tcoord".

Definition BackupTxnCoordinator__inquire: val :=
  rec: "BackupTxnCoordinator__inquire" "tcoord" :=
    let: "status" := ref_to uint64T TXN_PREPARED in
    let: "valid" := ref_to boolT #true in
    let: "gid" := ref_to uint64T #0 in
    Skip;;
    (for: (λ: <>, (![uint64T] "gid") < (MapLen (struct.loadF BackupTxnCoordinator "gcoords" "tcoord"))); (λ: <>, Skip) := λ: <>,
      let: "gcoord" := Fst (MapGet (struct.loadF BackupTxnCoordinator "gcoords" "tcoord") (![uint64T] "gid")) in
      let: ("0_ret", "1_ret") := BackupGroupCoordinator__Inquire "gcoord" (struct.loadF BackupTxnCoordinator "ts" "tcoord") (struct.loadF BackupTxnCoordinator "rank" "tcoord") (struct.loadF BackupTxnCoordinator "ptgs" "tcoord") in
      "status" <-[uint64T] "0_ret";;
      "valid" <-[boolT] "1_ret";;
      (if: (~ (![boolT] "valid"))
      then Break
      else
        (if: (![uint64T] "status") ≠ TXN_PREPARED
        then Break
        else
          "gid" <-[uint64T] ((![uint64T] "gid") + #1);;
          Continue)));;
    (![uint64T] "status", ![boolT] "valid").

Definition BackupTxnCoordinator__commit: val :=
  rec: "BackupTxnCoordinator__commit" "tcoord" :=
    MapIter (struct.loadF BackupTxnCoordinator "gcoords" "tcoord") (λ: <> "gcoord",
      BackupGroupCoordinator__Commit "gcoord" (struct.loadF BackupTxnCoordinator "ts" "tcoord"));;
    #().

Definition BackupTxnCoordinator__abort: val :=
  rec: "BackupTxnCoordinator__abort" "tcoord" :=
    MapIter (struct.loadF BackupTxnCoordinator "gcoords" "tcoord") (λ: <> "gcoord",
      BackupGroupCoordinator__Abort "gcoord" (struct.loadF BackupTxnCoordinator "ts" "tcoord"));;
    #().

(* Top-level method of backup transaction coordinator. *)
Definition BackupTxnCoordinator__Finalize: val :=
  rec: "BackupTxnCoordinator__Finalize" "tcoord" :=
    let: ("status", "valid") := BackupTxnCoordinator__inquire "tcoord" in
    (if: (~ "valid")
    then #()
    else
      (if: "status" = TXN_COMMITTED
      then #()
      else
        (if: "status" = TXN_ABORTED
        then
          BackupTxnCoordinator__abort "tcoord";;
          #()
        else
          BackupTxnCoordinator__commit "tcoord";;
          #()))).

(* Example *)
Definition swap: val :=
  rec: "swap" "txn" :=
    let: "x" := Txn__Read "txn" #(str"0") in
    let: "y" := Txn__Read "txn" #(str"1") in
    Txn__Write "txn" #(str"0") (struct.get Value "s" "y");;
    Txn__Write "txn" #(str"1") (struct.get Value "s" "x");;
    #true.

Definition AtomicSwap: val :=
  rec: "AtomicSwap" <> :=
    let: "txn" := NewTxn #() in
    let: "committed" := Txn__Run "txn" swap in
    "committed".

End code.
