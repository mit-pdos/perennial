(* autogenerated from github.com/mit-pdos/go-journal/txn *)
From Perennial.goose_lang Require Import prelude.
From Perennial.goose_lang Require Import ffi.disk_prelude.

From Goose Require github_com.mit_pdos.go_journal.addr.
From Goose Require github_com.mit_pdos.go_journal.jrnl.
From Goose Require github_com.mit_pdos.go_journal.lockmap.
From Goose Require github_com.mit_pdos.go_journal.obj.
From Goose Require github_com.mit_pdos.go_journal.util.

(* Package txn implements a full transaction interface on top of GoJournal.

   Transactions in this package do not have to implement concurrency control,
   since the package uses two-phase locking to automatically synchronize
   transactions. Lock ordering is still up to the caller to avoid deadlocks. *)

Definition Log := struct.decl [
  "log" :: struct.ptrT obj.Log;
  "locks" :: struct.ptrT lockmap.LockMap
].

Definition Txn := struct.decl [
  "buftxn" :: struct.ptrT jrnl.Op;
  "locks" :: struct.ptrT lockmap.LockMap;
  "acquired" :: mapT boolT
].

Definition Init: val :=
  rec: "Init" "d" :=
    let: "twophasePre" := struct.new Log [
      "log" ::= obj.MkLog "d";
      "locks" ::= lockmap.MkLockMap #()
    ] in
    "twophasePre".

(* Start a local transaction with no writes from a global Log. *)
Definition Begin: val :=
  rec: "Begin" "tsys" :=
    let: "trans" := struct.new Txn [
      "buftxn" ::= jrnl.Begin (struct.loadF Log "log" "tsys");
      "locks" ::= struct.loadF Log "locks" "tsys";
      "acquired" ::= NewMap boolT #()
    ] in
    util.DPrintf #5 (#(str"tp Begin: %v
    ")) #();;
    "trans".

Definition Txn__acquireNoCheck: val :=
  rec: "Txn__acquireNoCheck" "txn" "addr" :=
    let: "flatAddr" := addr.Addr__Flatid "addr" in
    lockmap.LockMap__Acquire (struct.loadF Txn "locks" "txn") "flatAddr";;
    MapInsert (struct.loadF Txn "acquired" "txn") "flatAddr" #true;;
    #().

Definition Txn__isAlreadyAcquired: val :=
  rec: "Txn__isAlreadyAcquired" "txn" "addr" :=
    let: "flatAddr" := addr.Addr__Flatid "addr" in
    Fst (MapGet (struct.loadF Txn "acquired" "txn") "flatAddr").

Definition Txn__Acquire: val :=
  rec: "Txn__Acquire" "txn" "addr" :=
    let: "already_acquired" := Txn__isAlreadyAcquired "txn" "addr" in
    (if: ~ "already_acquired"
    then
      Txn__acquireNoCheck "txn" "addr";;
      #()
    else #()).

Definition Txn__ReleaseAll: val :=
  rec: "Txn__ReleaseAll" "txn" :=
    MapIter (struct.loadF Txn "acquired" "txn") (λ: "flatAddr" <>,
      lockmap.LockMap__Release (struct.loadF Txn "locks" "txn") "flatAddr");;
    #().

Definition Txn__readBufNoAcquire: val :=
  rec: "Txn__readBufNoAcquire" "txn" "addr" "sz" :=
    let: "s" := util.CloneByteSlice (struct.loadF buf.Buf "Data" (jrnl.Op__ReadBuf (struct.loadF Txn "buftxn" "txn") "addr" "sz")) in
    "s".

Definition Txn__ReadBuf: val :=
  rec: "Txn__ReadBuf" "txn" "addr" "sz" :=
    Txn__Acquire "txn" "addr";;
    Txn__readBufNoAcquire "txn" "addr" "sz".

(* OverWrite writes an object to addr *)
Definition Txn__OverWrite: val :=
  rec: "Txn__OverWrite" "txn" "addr" "sz" "data0" :=
    let: "data" := util.CloneByteSlice "data0" in
    Txn__Acquire "txn" "addr";;
    jrnl.Op__OverWrite (struct.loadF Txn "buftxn" "txn") "addr" "sz" "data";;
    #().

Definition Txn__ReadBufBit: val :=
  rec: "Txn__ReadBufBit" "txn" "addr" :=
    let: "dataByte" := SliceGet byteT (Txn__ReadBuf "txn" "addr" #1) #0 in
    (#(U8 1) = ("dataByte" ≫ ((struct.get addr.Addr "Off" "addr") `rem` #8) `and` #(U8 1))).

Definition bitToByte: val :=
  rec: "bitToByte" "off" "data" :=
    (if: "data"
    then (#(U8 1)) ≪ "off"
    else #(U8 0)).

Definition Txn__OverWriteBit: val :=
  rec: "Txn__OverWriteBit" "txn" "addr" "data" :=
    let: "dataBytes" := NewSlice byteT #1 in
    SliceSet byteT "dataBytes" #0 (bitToByte ((struct.get addr.Addr "Off" "addr") `rem` #8) "data");;
    Txn__OverWrite "txn" "addr" #1 "dataBytes";;
    #().

(* NDirty reports an upper bound on the size of this transaction when committed.

   TODO: number of locks acquired also bounds size of transaction

   The caller cannot rely on any particular properties of this function for
   safety. *)
Definition Txn__NDirty: val :=
  rec: "Txn__NDirty" "txn" :=
    jrnl.Op__NDirty (struct.loadF Txn "buftxn" "txn").

Definition Txn__commitNoRelease: val :=
  rec: "Txn__commitNoRelease" "txn" :=
    util.DPrintf #5 (#(str"tp Commit %p
    ")) #();;
    jrnl.Op__CommitWait (struct.loadF Txn "buftxn" "txn") #true.

Definition Txn__Commit: val :=
  rec: "Txn__Commit" "txn" :=
    let: "ok" := Txn__commitNoRelease "txn" in
    Txn__ReleaseAll "txn";;
    "ok".
