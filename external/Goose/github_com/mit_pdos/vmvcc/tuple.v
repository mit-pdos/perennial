(* autogenerated from github.com/mit-pdos/vmvcc/tuple *)
From Perennial.goose_lang Require Import prelude.
From Goose Require github_com.mit_pdos.vmvcc.common.

Section code.
Context `{ext_ty: ext_types}.
Local Coercion Var' s: expr := Var s.

(* @ts
   Starting timestamp of this version, and also ending timestamp of the next
   version. Lifetime is a half-open interval: (ts of this, ts of next].

   @del
   Tombstone of this version.

   @val
   Value of this version. *)
Definition Version := struct.decl [
  "ts" :: uint64T;
  "del" :: boolT;
  "val" :: stringT
].

(* @owned
   Write lock of this tuple. Acquired before committing.

   @rcond
   Condition variable to wake up readers of this tuple.

   @tslast
   Timestamp of the last reader or last writer + 1.

   @vers
   Versions. *)
Definition Tuple := struct.decl [
  "latch" :: ptrT;
  "rcond" :: ptrT;
  "owned" :: boolT;
  "tslast" :: uint64T;
  "vers" :: slice.T (struct.t Version)
].

Definition findVersion: val :=
  rec: "findVersion" "tid" "vers" :=
    let: "ver" := ref (zero_val (struct.t Version)) in
    let: "length" := slice.len "vers" in
    let: "idx" := ref_to uint64T #0 in
    Skip;;
    (for: (λ: <>, (![uint64T] "idx") < "length"); (λ: <>, Skip) := λ: <>,
      "ver" <-[struct.t Version] (SliceGet (struct.t Version) "vers" (("length" - (![uint64T] "idx")) - #1));;
      (if: "tid" > (struct.get Version "ts" (![struct.t Version] "ver"))
      then Break
      else
        "idx" <-[uint64T] ((![uint64T] "idx") + #1);;
        Continue));;
    ![struct.t Version] "ver".

Definition Tuple__Own: val :=
  rec: "Tuple__Own" "tuple" "tid" :=
    lock.acquire (struct.loadF Tuple "latch" "tuple");;
    (if: "tid" < (struct.loadF Tuple "tslast" "tuple")
    then
      lock.release (struct.loadF Tuple "latch" "tuple");;
      common.RET_UNSERIALIZABLE
    else
      (if: struct.loadF Tuple "owned" "tuple"
      then
        lock.release (struct.loadF Tuple "latch" "tuple");;
        common.RET_RETRY
      else
        struct.storeF Tuple "owned" "tuple" #true;;
        lock.release (struct.loadF Tuple "latch" "tuple");;
        common.RET_SUCCESS)).

(* Call @WriteOpen before @AppendVersion and @KillVersion. *)
Definition Tuple__WriteOpen: val :=
  rec: "Tuple__WriteOpen" "tuple" :=
    lock.acquire (struct.loadF Tuple "latch" "tuple");;
    #().

Definition Tuple__appendVersion: val :=
  rec: "Tuple__appendVersion" "tuple" "tid" "val" :=
    let: "verNew" := struct.mk Version [
      "ts" ::= "tid";
      "del" ::= #false;
      "val" ::= "val"
    ] in
    struct.storeF Tuple "vers" "tuple" (SliceAppend (struct.t Version) (struct.loadF Tuple "vers" "tuple") "verNew");;
    struct.storeF Tuple "owned" "tuple" #false;;
    struct.storeF Tuple "tslast" "tuple" ("tid" + #1);;
    #().

(* Append a new version (@tid, @val) to this tuple. *)
Definition Tuple__AppendVersion: val :=
  rec: "Tuple__AppendVersion" "tuple" "tid" "val" :=
    Tuple__appendVersion "tuple" "tid" "val";;
    lock.condBroadcast (struct.loadF Tuple "rcond" "tuple");;
    lock.release (struct.loadF Tuple "latch" "tuple");;
    #().

Definition Tuple__killVersion: val :=
  rec: "Tuple__killVersion" "tuple" "tid" :=
    let: "verNew" := struct.mk Version [
      "ts" ::= "tid";
      "del" ::= #true
    ] in
    struct.storeF Tuple "vers" "tuple" (SliceAppend (struct.t Version) (struct.loadF Tuple "vers" "tuple") "verNew");;
    struct.storeF Tuple "owned" "tuple" #false;;
    struct.storeF Tuple "tslast" "tuple" ("tid" + #1);;
    #true.

(* Append a tombstone version of timestamp @tid to this tuple. *)
Definition Tuple__KillVersion: val :=
  rec: "Tuple__KillVersion" "tuple" "tid" :=
    let: "ok" := Tuple__killVersion "tuple" "tid" in
    let: "ret" := ref (zero_val uint64T) in
    (if: "ok"
    then "ret" <-[uint64T] common.RET_SUCCESS
    else "ret" <-[uint64T] common.RET_NONEXIST);;
    lock.condBroadcast (struct.loadF Tuple "rcond" "tuple");;
    lock.release (struct.loadF Tuple "latch" "tuple");;
    ![uint64T] "ret".

(* Release the write lock without modifying the tuple. *)
Definition Tuple__Free: val :=
  rec: "Tuple__Free" "tuple" :=
    lock.acquire (struct.loadF Tuple "latch" "tuple");;
    struct.storeF Tuple "owned" "tuple" #false;;
    lock.condBroadcast (struct.loadF Tuple "rcond" "tuple");;
    lock.release (struct.loadF Tuple "latch" "tuple");;
    #().

(* Call @ReadWait before @ReadVersion.
   This design allows us to resolve the prophecy at the txn level. *)
Definition Tuple__ReadWait: val :=
  rec: "Tuple__ReadWait" "tuple" "tid" :=
    lock.acquire (struct.loadF Tuple "latch" "tuple");;
    Skip;;
    (for: (λ: <>, ("tid" > (struct.loadF Tuple "tslast" "tuple")) && (struct.loadF Tuple "owned" "tuple")); (λ: <>, Skip) := λ: <>,
      lock.condWait (struct.loadF Tuple "rcond" "tuple");;
      Continue);;
    #().

Definition Tuple__ReadVersion: val :=
  rec: "Tuple__ReadVersion" "tuple" "tid" :=
    let: "ver" := findVersion "tid" (struct.loadF Tuple "vers" "tuple") in
    (if: (struct.loadF Tuple "tslast" "tuple") < "tid"
    then struct.storeF Tuple "tslast" "tuple" "tid"
    else #());;
    lock.release (struct.loadF Tuple "latch" "tuple");;
    (struct.get Version "val" "ver", (~ (struct.get Version "del" "ver"))).

Definition Tuple__removeVersions: val :=
  rec: "Tuple__removeVersions" "tuple" "tid" :=
    let: "idx" := ref (zero_val uint64T) in
    "idx" <-[uint64T] ((slice.len (struct.loadF Tuple "vers" "tuple")) - #1);;
    Skip;;
    (for: (λ: <>, (![uint64T] "idx") ≠ #0); (λ: <>, Skip) := λ: <>,
      let: "ver" := SliceGet (struct.t Version) (struct.loadF Tuple "vers" "tuple") (![uint64T] "idx") in
      (if: (struct.get Version "ts" "ver") < "tid"
      then Break
      else
        "idx" <-[uint64T] ((![uint64T] "idx") - #1);;
        Continue));;
    struct.storeF Tuple "vers" "tuple" (SliceSkip (struct.t Version) (struct.loadF Tuple "vers" "tuple") (![uint64T] "idx"));;
    #().

(* Remove all versions whose lifetime ends before @tid. *)
Definition Tuple__RemoveVersions: val :=
  rec: "Tuple__RemoveVersions" "tuple" "tid" :=
    lock.acquire (struct.loadF Tuple "latch" "tuple");;
    Tuple__removeVersions "tuple" "tid";;
    lock.release (struct.loadF Tuple "latch" "tuple");;
    #().

Definition MkTuple: val :=
  rec: "MkTuple" <> :=
    let: "tuple" := struct.alloc Tuple (zero_val (struct.t Tuple)) in
    struct.storeF Tuple "latch" "tuple" (lock.new #());;
    struct.storeF Tuple "rcond" "tuple" (lock.newCond (struct.loadF Tuple "latch" "tuple"));;
    struct.storeF Tuple "owned" "tuple" #false;;
    struct.storeF Tuple "tslast" "tuple" #1;;
    struct.storeF Tuple "vers" "tuple" (NewSliceWithCap (struct.t Version) #1 #1);;
    SliceSet (struct.t Version) (struct.loadF Tuple "vers" "tuple") #0 (struct.mk Version [
      "del" ::= #true
    ]);;
    "tuple".

End code.
