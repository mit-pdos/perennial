(* autogenerated from github.com/mit-pdos/tulip/util *)
From Perennial.goose_lang Require Import prelude.
From Goose Require github_com.goose_lang.std.
From Goose Require github_com.mit_pdos.tulip.tulip.
From Goose Require github_com.tchajed.marshal.

From Perennial.goose_lang Require Import ffi.grove_prelude.

Definition NextAligned: val :=
  rec: "NextAligned" "current" "interval" "low" :=
    let: "delta" := ref (zero_val uint64T) in
    let: "rem" := "current" `rem` "interval" in
    (if: "rem" < "low"
    then "delta" <-[uint64T] ("low" - "rem")
    else "delta" <-[uint64T] (("interval" + "low") - "rem"));;
    std.SumAssumeNoOverflow "current" (![uint64T] "delta").

Definition swap: val :=
  rec: "swap" "ns" "i" "j" :=
    let: "tmp" := SliceGet uint64T "ns" "i" in
    SliceSet uint64T "ns" "i" (SliceGet uint64T "ns" "j");;
    SliceSet uint64T "ns" "j" "tmp";;
    #().

Definition Sort: val :=
  rec: "Sort" "ns" :=
    let: "i" := ref_to uint64T #1 in
    Skip;;
    (for: (λ: <>, (![uint64T] "i") < (slice.len "ns")); (λ: <>, Skip) := λ: <>,
      let: "j" := ref_to uint64T (![uint64T] "i") in
      Skip;;
      (for: (λ: <>, (![uint64T] "j") > #0); (λ: <>, Skip) := λ: <>,
        (if: (SliceGet uint64T "ns" ((![uint64T] "j") - #1)) ≤ (SliceGet uint64T "ns" (![uint64T] "j"))
        then Break
        else
          swap "ns" ((![uint64T] "j") - #1) (![uint64T] "j");;
          "j" <-[uint64T] ((![uint64T] "j") - #1);;
          Continue));;
      "i" <-[uint64T] ((![uint64T] "i") + #1);;
      Continue);;
    #().

Definition CountBoolMap: val :=
  rec: "CountBoolMap" "m" "b" :=
    let: "n" := ref_to uint64T #0 in
    MapIter "m" (λ: <> "v",
      (if: "v" = "b"
      then "n" <-[uint64T] (std.SumAssumeNoOverflow (![uint64T] "n") #1)
      else #()));;
    ![uint64T] "n".

Definition EncodeInts: val :=
  rec: "EncodeInts" "bs" "ns" :=
    let: "data" := ref_to (slice.T byteT) (marshal.WriteInt "bs" (slice.len "ns")) in
    ForSlice uint64T <> "s" "ns"
      ("data" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "data") "s"));;
    ![slice.T byteT] "data".

Definition DecodeInts: val :=
  rec: "DecodeInts" "bs" :=
    let: ("n", "bs1") := marshal.ReadInt "bs" in
    let: "data" := ref_to (slice.T byteT) "bs1" in
    let: "ents" := ref_to (slice.T uint64T) (NewSliceWithCap uint64T #0 "n") in
    let: "i" := ref_to uint64T #0 in
    Skip;;
    (for: (λ: <>, (![uint64T] "i") < "n"); (λ: <>, Skip) := λ: <>,
      let: ("s", "bsloop") := marshal.ReadInt (![slice.T byteT] "data") in
      "ents" <-[slice.T uint64T] (SliceAppend uint64T (![slice.T uint64T] "ents") "s");;
      "data" <-[slice.T byteT] "bsloop";;
      "i" <-[uint64T] ((![uint64T] "i") + #1);;
      Continue);;
    (![slice.T uint64T] "ents", ![slice.T byteT] "data").

Definition EncodeString: val :=
  rec: "EncodeString" "bs" "str" :=
    let: "bs1" := marshal.WriteInt "bs" (StringLength "str") in
    let: "data" := marshal.WriteBytes "bs1" (StringToBytes "str") in
    "data".

Definition EncodeStrings: val :=
  rec: "EncodeStrings" "bs" "strs" :=
    let: "data" := ref_to (slice.T byteT) (marshal.WriteInt "bs" (slice.len "strs")) in
    ForSlice stringT <> "s" "strs"
      ("data" <-[slice.T byteT] (EncodeString (![slice.T byteT] "data") "s"));;
    ![slice.T byteT] "data".

Definition DecodeString: val :=
  rec: "DecodeString" "bs" :=
    let: ("sz", "bs1") := marshal.ReadInt "bs" in
    let: ("bsr", "data") := marshal.ReadBytes "bs1" "sz" in
    (StringFromBytes "bsr", "data").

Definition DecodeStrings: val :=
  rec: "DecodeStrings" "bs" :=
    let: ("n", "bs1") := marshal.ReadInt "bs" in
    let: "data" := ref_to (slice.T byteT) "bs1" in
    let: "ents" := ref_to (slice.T stringT) (NewSliceWithCap stringT #0 "n") in
    let: "i" := ref_to uint64T #0 in
    Skip;;
    (for: (λ: <>, (![uint64T] "i") < "n"); (λ: <>, Skip) := λ: <>,
      let: ("s", "bsloop") := DecodeString (![slice.T byteT] "data") in
      "ents" <-[slice.T stringT] (SliceAppend stringT (![slice.T stringT] "ents") "s");;
      "data" <-[slice.T byteT] "bsloop";;
      "i" <-[uint64T] ((![uint64T] "i") + #1);;
      Continue);;
    (![slice.T stringT] "ents", ![slice.T byteT] "data").

Definition EncodePrepareProposal: val :=
  rec: "EncodePrepareProposal" "bs" "pp" :=
    let: "bs1" := marshal.WriteInt "bs" (struct.get tulip.PrepareProposal "Rank" "pp") in
    let: "data" := marshal.WriteBool "bs1" (struct.get tulip.PrepareProposal "Prepared" "pp") in
    "data".

Definition DecodePrepareProposal: val :=
  rec: "DecodePrepareProposal" "bs" :=
    let: ("rank", "bs1") := marshal.ReadInt "bs" in
    let: ("prepared", "data") := marshal.ReadBool "bs1" in
    let: "pp" := struct.mk tulip.PrepareProposal [
      "Rank" ::= "rank";
      "Prepared" ::= "prepared"
    ] in
    ("pp", "data").

Definition EncodeValue: val :=
  rec: "EncodeValue" "bs" "v" :=
    (if: (~ (struct.get tulip.Value "Present" "v"))
    then
      let: "data" := marshal.WriteBool "bs" #false in
      "data"
    else
      let: "bs1" := marshal.WriteBool "bs" #true in
      let: "data" := EncodeString "bs1" (struct.get tulip.Value "Content" "v") in
      "data").

Definition DecodeValue: val :=
  rec: "DecodeValue" "bs" :=
    let: ("b", "bs1") := marshal.ReadBool "bs" in
    (if: (~ "b")
    then
      let: "v" := struct.mk tulip.Value [
        "Present" ::= #false;
        "Content" ::= #(str"")
      ] in
      ("v", "bs1")
    else
      let: ("s", "data") := DecodeString "bs1" in
      let: "v" := struct.mk tulip.Value [
        "Present" ::= #true;
        "Content" ::= "s"
      ] in
      ("v", "data")).

Definition EncodeVersion: val :=
  rec: "EncodeVersion" "bs" "x" :=
    let: "bs1" := marshal.WriteInt "bs" (struct.get tulip.Version "Timestamp" "x") in
    let: "data" := EncodeValue "bs1" (struct.get tulip.Version "Value" "x") in
    "data".

Definition DecodeVersion: val :=
  rec: "DecodeVersion" "bs" :=
    let: ("ts", "bs1") := marshal.ReadInt "bs" in
    let: ("v", "data") := DecodeValue "bs1" in
    let: "x" := struct.mk tulip.Version [
      "Timestamp" ::= "ts";
      "Value" ::= "v"
    ] in
    ("x", "data").

Definition EncodeWriteEntry: val :=
  rec: "EncodeWriteEntry" "bs" "x" :=
    let: "bs1" := EncodeString "bs" (struct.get tulip.WriteEntry "Key" "x") in
    let: "data" := EncodeValue "bs1" (struct.get tulip.WriteEntry "Value" "x") in
    "data".

Definition DecodeWriteEntry: val :=
  rec: "DecodeWriteEntry" "bs" :=
    let: ("k", "bs1") := DecodeString "bs" in
    let: ("v", "data") := DecodeValue "bs1" in
    let: "x" := struct.mk tulip.WriteEntry [
      "Key" ::= "k";
      "Value" ::= "v"
    ] in
    ("x", "data").

Definition EncodeKVMap: val :=
  rec: "EncodeKVMap" "bs" "m" :=
    let: "data" := ref_to (slice.T byteT) (marshal.WriteInt "bs" (MapLen "m")) in
    MapIter "m" (λ: "k" "v",
      let: "x" := struct.mk tulip.WriteEntry [
        "Key" ::= "k";
        "Value" ::= "v"
      ] in
      "data" <-[slice.T byteT] (EncodeWriteEntry (![slice.T byteT] "data") "x"));;
    ![slice.T byteT] "data".

Definition EncodeKVMapFromSlice: val :=
  rec: "EncodeKVMapFromSlice" "bs" "xs" :=
    let: "data" := ref_to (slice.T byteT) (marshal.WriteInt "bs" (slice.len "xs")) in
    ForSlice (struct.t tulip.WriteEntry) <> "x" "xs"
      ("data" <-[slice.T byteT] (EncodeWriteEntry (![slice.T byteT] "data") "x"));;
    ![slice.T byteT] "data".

Definition DecodeKVMapIntoSlice: val :=
  rec: "DecodeKVMapIntoSlice" "bs" :=
    let: ("n", "bs1") := marshal.ReadInt "bs" in
    let: "data" := ref_to (slice.T byteT) "bs1" in
    let: "ents" := ref_to (slice.T (struct.t tulip.WriteEntry)) (NewSliceWithCap (struct.t tulip.WriteEntry) #0 "n") in
    let: "i" := ref_to uint64T #0 in
    Skip;;
    (for: (λ: <>, (![uint64T] "i") < "n"); (λ: <>, Skip) := λ: <>,
      let: ("x", "bsloop") := DecodeWriteEntry (![slice.T byteT] "data") in
      "ents" <-[slice.T (struct.t tulip.WriteEntry)] (SliceAppend (struct.t tulip.WriteEntry) (![slice.T (struct.t tulip.WriteEntry)] "ents") "x");;
      "data" <-[slice.T byteT] "bsloop";;
      "i" <-[uint64T] ((![uint64T] "i") + #1);;
      Continue);;
    (![slice.T (struct.t tulip.WriteEntry)] "ents", ![slice.T byteT] "data").

Definition DecodeKVMap: val :=
  rec: "DecodeKVMap" "bs" :=
    let: ("n", "bs1") := marshal.ReadInt "bs" in
    let: "data" := ref_to (slice.T byteT) "bs1" in
    let: "m" := NewMap stringT (struct.t tulip.Value) #() in
    let: "i" := ref_to uint64T #0 in
    Skip;;
    (for: (λ: <>, (![uint64T] "i") < "n"); (λ: <>, Skip) := λ: <>,
      let: ("x", "bsloop") := DecodeWriteEntry (![slice.T byteT] "data") in
      MapInsert "m" (struct.get tulip.WriteEntry "Key" "x") (struct.get tulip.WriteEntry "Value" "x");;
      "data" <-[slice.T byteT] "bsloop";;
      "i" <-[uint64T] ((![uint64T] "i") + #1);;
      Continue);;
    ("m", ![slice.T byteT] "data").
