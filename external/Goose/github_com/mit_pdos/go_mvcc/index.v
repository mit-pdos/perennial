(* autogenerated from github.com/mit-pdos/go-mvcc/index *)
From Perennial.goose_lang Require Import prelude.
Section code.
Context `{ext_ty: ext_types}.
Local Coercion Var' s: expr := Var s.

From Goose Require github_com.mit_pdos.go_mvcc.config.
From Goose Require github_com.mit_pdos.go_mvcc.tuple.

Definition IndexBucket := struct.decl [
  "latch" :: ptrT;
  "m" :: mapT ptrT
].

Definition Index := struct.decl [
  "buckets" :: slice.T ptrT
].

Definition MkIndex: val :=
  rec: "MkIndex" <> :=
    let: "idx" := struct.alloc Index (zero_val (struct.t Index)) in
    struct.storeF Index "buckets" "idx" (NewSlice ptrT config.N_IDX_BUCKET);;
    let: "i" := ref_to uint64T #0 in
    (for: (λ: <>, ![uint64T] "i" < config.N_IDX_BUCKET); (λ: <>, "i" <-[uint64T] ![uint64T] "i" + #1) := λ: <>,
      let: "b" := struct.alloc IndexBucket (zero_val (struct.t IndexBucket)) in
      struct.storeF IndexBucket "latch" "b" (lock.new #());;
      struct.storeF IndexBucket "m" "b" (NewMap ptrT #());;
      SliceSet ptrT (struct.loadF Index "buckets" "idx") (![uint64T] "i") "b";;
      Continue);;
    "idx".

Definition getBucket: val :=
  rec: "getBucket" "key" :=
    "key" `rem` config.N_IDX_BUCKET.

(* *
    * Note that `GetTuple` will always create a tuple when there is no entry in
    * `m`. This design choice seems to be wasting memory resource as we'll always
    * allocate a `Tuple` even with an empty `txn.Get`, but is actually a must: A
    * `txn.Get` should prevent earlier txns from creating new versions, even when
    * it fails to retrieve a value. More specifically, this requirement is enforced
    * with the `tidrd` field of each tuple. *)
Definition Index__GetTuple: val :=
  rec: "Index__GetTuple" "idx" "key" :=
    let: "b" := getBucket "key" in
    let: "bucket" := SliceGet ptrT (struct.loadF Index "buckets" "idx") "b" in
    lock.acquire (struct.loadF IndexBucket "latch" "bucket");;
    let: ("tupleCur", "ok") := MapGet (struct.loadF IndexBucket "m" "bucket") "key" in
    (if: "ok"
    then
      lock.release (struct.loadF IndexBucket "latch" "bucket");;
      "tupleCur"
    else
      let: "tupleNew" := tuple.MkTuple #() in
      MapInsert (struct.loadF IndexBucket "m" "bucket") "key" "tupleNew";;
      lock.release (struct.loadF IndexBucket "latch" "bucket");;
      "tupleNew").

Definition Index__GetKeys: val :=
  rec: "Index__GetKeys" "idx" :=
    let: "keys" := ref (zero_val (slice.T uint64T)) in
    "keys" <-[slice.T uint64T] NewSlice uint64T #0;;
    let: "b" := ref_to uint64T #0 in
    (for: (λ: <>, ![uint64T] "b" < config.N_IDX_BUCKET); (λ: <>, "b" <-[uint64T] ![uint64T] "b" + #1) := λ: <>,
      let: "bucket" := SliceGet ptrT (struct.loadF Index "buckets" "idx") (![uint64T] "b") in
      lock.acquire (struct.loadF IndexBucket "latch" "bucket");;
      MapIter (struct.loadF IndexBucket "m" "bucket") (λ: "k" <>,
        "keys" <-[slice.T uint64T] SliceAppend uint64T (![slice.T uint64T] "keys") "k");;
      lock.release (struct.loadF IndexBucket "latch" "bucket");;
      Continue);;
    ![slice.T uint64T] "keys".

End code.
