(* autogenerated from github.com/mit-pdos/pav/alicebob *)
From Perennial.goose_lang Require Import prelude.
From Goose Require github_com.goose_lang.std.
From Goose Require github_com.mit_pdos.pav.advrpc.
From Goose Require github_com.mit_pdos.pav.cryptoffi.
From Goose Require github_com.mit_pdos.pav.kt.

Section code.
Context `{ext_ty: ext_types}.

(* alicebob.go *)

Definition aliceUid : expr := #0.

Definition bobUid : expr := #1.

(* setupParams describes different security configs with the
   servGood and adtrGood params. *)
Definition setupParams := struct.decl [
  "servGood" :: boolT;
  "servAddr" :: uint64T;
  "servSigPk" :: cryptoffi.SigPublicKey;
  "servVrfPk" :: slice.T byteT;
  "adtrGood" :: boolT;
  "adtrAddrs" :: slice.T uint64T;
  "adtrPks" :: slice.T cryptoffi.SigPublicKey
].

(* setup starts server and auditors. *)
Definition setup: val :=
  rec: "setup" "servAddr" "adtrAddrs" :=
    let: (("serv", "servSigPk"), "servVrfPk") := kt.NewServer #() in
    let: "servVrfPkEnc" := cryptoffi.VrfPublicKeyEncode "servVrfPk" in
    let: "servRpc" := kt.NewRpcServer "serv" in
    advrpc.Server__Serve "servRpc" "servAddr";;
    let: "adtrPks" := ref (zero_val (slice.T cryptoffi.SigPublicKey)) in
    ForSlice uint64T <> "adtrAddr" "adtrAddrs"
      (let: ("adtr", "adtrPk") := kt.NewAuditor #() in
      let: "adtrRpc" := kt.NewRpcAuditor "adtr" in
      advrpc.Server__Serve "adtrRpc" "adtrAddr";;
      "adtrPks" <-[slice.T cryptoffi.SigPublicKey] (SliceAppend cryptoffi.SigPublicKey (![slice.T cryptoffi.SigPublicKey] "adtrPks") "adtrPk"));;
    time.Sleep #1000000;;
    struct.new setupParams [
      "servGood" ::= #true;
      "servAddr" ::= "servAddr";
      "servSigPk" ::= "servSigPk";
      "servVrfPk" ::= "servVrfPkEnc";
      "adtrGood" ::= #true;
      "adtrAddrs" ::= "adtrAddrs";
      "adtrPks" ::= ![slice.T cryptoffi.SigPublicKey] "adtrPks"
    ].

Definition alice := struct.decl [
  "servGood" :: boolT;
  "servSigPk" :: cryptoffi.SigPublicKey;
  "cli" :: ptrT;
  "hist" :: slice.T ptrT
].

Definition bob := struct.decl [
  "servGood" :: boolT;
  "servSigPk" :: cryptoffi.SigPublicKey;
  "cli" :: ptrT;
  "epoch" :: uint64T;
  "isReg" :: boolT;
  "alicePk" :: slice.T byteT
].

Definition checkCliErr: val :=
  rec: "checkCliErr" "servGood" "servPk" "err" :=
    (if: (struct.loadF kt.ClientErr "Evid" "err") ≠ #null
    then std.Assert (~ (kt.Evid__Check (struct.loadF kt.ClientErr "Evid" "err") "servPk"))
    else #());;
    (if: "servGood"
    then
      std.Assert (~ (struct.loadF kt.ClientErr "Err" "err"));;
      #()
    else
      control.impl.Assume (~ (struct.loadF kt.ClientErr "Err" "err"));;
      #()).

(* histEntry from history.go *)

Definition histEntry := struct.decl [
  "isReg" :: boolT;
  "pk" :: slice.T byteT
].

(* extendHist to length numEpochs.
   numEpochs must not be smaller than length hist. *)
Definition extendHist: val :=
  rec: "extendHist" "hist" "numEpochs" :=
    let: "histLen" := slice.len "hist" in
    std.Assert ("histLen" ≤ "numEpochs");;
    let: "last" := ref (zero_val ptrT) in
    (if: "histLen" = #0
    then
      "last" <-[ptrT] (struct.new histEntry [
      ])
    else "last" <-[ptrT] (SliceGet ptrT "hist" ("histLen" - #1)));;
    let: "newHist" := ref_to (slice.T ptrT) "hist" in
    let: "i" := ref_to uint64T "histLen" in
    Skip;;
    (for: (λ: <>, (![uint64T] "i") < "numEpochs"); (λ: <>, "i" <-[uint64T] ((![uint64T] "i") + #1)) := λ: <>,
      "newHist" <-[slice.T ptrT] (SliceAppend ptrT (![slice.T ptrT] "newHist") (![ptrT] "last"));;
      Continue);;
    ![slice.T ptrT] "newHist".

(* alice__run from alicebob.go *)

Definition alice__run: val :=
  rec: "alice__run" "a" :=
    let: "i" := ref_to uint64T #0 in
    (for: (λ: <>, (![uint64T] "i") < #20); (λ: <>, "i" <-[uint64T] ((![uint64T] "i") + #1)) := λ: <>,
      time.Sleep #5000000;;
      let: "pk" := SliceSingleton #(U8 1) in
      let: ("epoch", "err0") := kt.Client__Put (struct.loadF alice "cli" "a") "pk" in
      checkCliErr (struct.loadF alice "servGood" "a") (struct.loadF alice "servSigPk" "a") "err0";;
      struct.storeF alice "hist" "a" (extendHist (struct.loadF alice "hist" "a") "epoch");;
      struct.storeF alice "hist" "a" (SliceAppend ptrT (struct.loadF alice "hist" "a") (struct.new histEntry [
        "isReg" ::= #true;
        "pk" ::= "pk"
      ]));;
      Continue);;
    #().

Definition bob__run: val :=
  rec: "bob__run" "b" :=
    time.Sleep #120000000;;
    let: ((("isReg", "pk"), "epoch"), "err0") := kt.Client__Get (struct.loadF bob "cli" "b") aliceUid in
    checkCliErr (struct.loadF bob "servGood" "b") (struct.loadF bob "servSigPk" "b") "err0";;
    struct.storeF bob "epoch" "b" "epoch";;
    struct.storeF bob "isReg" "b" "isReg";;
    struct.storeF bob "alicePk" "b" "pk";;
    #().

(* mkRpcClients from helpers.go *)

Definition mkRpcClients: val :=
  rec: "mkRpcClients" "addrs" :=
    let: "c" := ref (zero_val (slice.T ptrT)) in
    ForSlice uint64T <> "addr" "addrs"
      (let: "cli" := advrpc.Dial "addr" in
      "c" <-[slice.T ptrT] (SliceAppend ptrT (![slice.T ptrT] "c") "cli"));;
    ![slice.T ptrT] "c".

Definition updAdtrsOnce: val :=
  rec: "updAdtrsOnce" "upd" "adtrs" :=
    ForSlice ptrT <> "cli" "adtrs"
      (let: "err" := kt.CallAdtrUpdate "cli" "upd" in
      control.impl.Assume (~ "err"));;
    #().

Definition updAdtrsAll: val :=
  rec: "updAdtrsAll" "servAddr" "adtrAddrs" :=
    let: "servCli" := advrpc.Dial "servAddr" in
    let: "adtrs" := mkRpcClients "adtrAddrs" in
    let: "epoch" := ref (zero_val uint64T) in
    Skip;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: ("upd", "err") := kt.CallServAudit "servCli" (![uint64T] "epoch") in
      (if: "err"
      then Break
      else
        updAdtrsOnce "upd" "adtrs";;
        "epoch" <-[uint64T] ((![uint64T] "epoch") + #1);;
        Continue));;
    #().

Definition doAudits: val :=
  rec: "doAudits" "cli" "adtrAddrs" "adtrPks" :=
    let: "numAdtrs" := slice.len "adtrAddrs" in
    let: "i" := ref_to uint64T #0 in
    (for: (λ: <>, (![uint64T] "i") < "numAdtrs"); (λ: <>, "i" <-[uint64T] ((![uint64T] "i") + #1)) := λ: <>,
      let: "addr" := SliceGet uint64T "adtrAddrs" (![uint64T] "i") in
      let: "pk" := SliceGet cryptoffi.SigPublicKey "adtrPks" (![uint64T] "i") in
      let: "err" := kt.Client__Audit "cli" "addr" "pk" in
      control.impl.Assume (~ (struct.loadF kt.ClientErr "Err" "err"));;
      Continue);;
    #().

(* testAliceBob from alicebob.go *)

Definition testAliceBob: val :=
  rec: "testAliceBob" "setup" :=
    let: "aliceCli" := kt.NewClient aliceUid (struct.loadF setupParams "servAddr" "setup") (struct.loadF setupParams "servSigPk" "setup") (struct.loadF setupParams "servVrfPk" "setup") in
    let: "alice" := struct.new alice [
      "servGood" ::= struct.loadF setupParams "servGood" "setup";
      "servSigPk" ::= struct.loadF setupParams "servSigPk" "setup";
      "cli" ::= "aliceCli"
    ] in
    let: "bobCli" := kt.NewClient bobUid (struct.loadF setupParams "servAddr" "setup") (struct.loadF setupParams "servSigPk" "setup") (struct.loadF setupParams "servVrfPk" "setup") in
    let: "bob" := struct.new bob [
      "servGood" ::= struct.loadF setupParams "servGood" "setup";
      "servSigPk" ::= struct.loadF setupParams "servSigPk" "setup";
      "cli" ::= "bobCli"
    ] in
    let: "wg" := waitgroup.New #() in
    waitgroup.Add "wg" #1;;
    waitgroup.Add "wg" #1;;
    Fork (alice__run "alice";;
          waitgroup.Done "wg");;
    Fork (bob__run "bob";;
          waitgroup.Done "wg");;
    waitgroup.Wait "wg";;
    let: ("selfMonEp", "err0") := kt.Client__SelfMon (struct.loadF alice "cli" "alice") in
    checkCliErr (struct.loadF setupParams "servGood" "setup") (struct.loadF setupParams "servSigPk" "setup") "err0";;
    struct.storeF alice "hist" "alice" (extendHist (struct.loadF alice "hist" "alice") ("selfMonEp" + #1));;
    (if: struct.loadF setupParams "adtrGood" "setup"
    then
      updAdtrsAll (struct.loadF setupParams "servAddr" "setup") (struct.loadF setupParams "adtrAddrs" "setup");;
      doAudits (struct.loadF alice "cli" "alice") (struct.loadF setupParams "adtrAddrs" "setup") (struct.loadF setupParams "adtrPks" "setup");;
      doAudits (struct.loadF bob "cli" "bob") (struct.loadF setupParams "adtrAddrs" "setup") (struct.loadF setupParams "adtrPks" "setup")
    else #());;
    control.impl.Assume ((struct.loadF bob "epoch" "bob") ≤ "selfMonEp");;
    let: "aliceKey" := SliceGet ptrT (struct.loadF alice "hist" "alice") (struct.loadF bob "epoch" "bob") in
    std.Assert ((struct.loadF histEntry "isReg" "aliceKey") = (struct.loadF bob "isReg" "bob"));;
    (if: struct.loadF histEntry "isReg" "aliceKey"
    then
      std.Assert (std.BytesEqual (struct.loadF histEntry "pk" "aliceKey") (struct.loadF bob "alicePk" "bob"));;
      #()
    else #()).

(* testSecurity Assume's no errors in client-server calls and
   has clients contact the auditor. *)
Definition testSecurity: val :=
  rec: "testSecurity" "servAddr" "adtrAddrs" :=
    let: "s" := setup "servAddr" "adtrAddrs" in
    struct.storeF setupParams "servGood" "s" #false;;
    struct.storeF setupParams "adtrGood" "s" #true;;
    testAliceBob "s";;
    #().

(* testCorrectness Assert's no errors in client-server calls and
   does not use auditors. *)
Definition testCorrectness: val :=
  rec: "testCorrectness" "servAddr" "adtrAddrs" :=
    let: "s" := setup "servAddr" "adtrAddrs" in
    struct.storeF setupParams "servGood" "s" #true;;
    struct.storeF setupParams "adtrGood" "s" #false;;
    testAliceBob "s";;
    #().

(* helpers.go *)

(* history.go *)

End code.
