(* autogenerated from github.com/mit-pdos/pav/kt *)
From Perennial.goose_lang Require Import prelude.
From Goose Require github_com.goose_lang.std.
From Goose Require github_com.mit_pdos.pav.advrpc.
From Goose Require github_com.mit_pdos.pav.cryptoffi.
From Goose Require github_com.mit_pdos.pav.cryptoutil.
From Goose Require github_com.mit_pdos.pav.marshalutil.
From Goose Require github_com.mit_pdos.pav.merkle.
From Goose Require github_com.tchajed.marshal.

Section code.
Context `{ext_ty: ext_types}.

(* auditor.go *)

Definition Auditor := struct.decl [
  "mu" :: ptrT;
  "sk" :: ptrT;
  "keyMap" :: ptrT;
  "histInfo" :: slice.T ptrT
].

(* MapValPre from serde.go *)

Definition MapValPre := struct.decl [
  "Epoch" :: uint64T;
  "PkCommit" :: slice.T byteT
].

(* MapValPreDecode from serde.out.go *)

Definition MapValPreDecode: val :=
  rec: "MapValPreDecode" "b0" :=
    let: (("a1", "b1"), "err1") := marshalutil.ReadInt "b0" in
    (if: "err1"
    then (slice.nil, slice.nil, #true)
    else
      let: (("a2", "b2"), "err2") := marshalutil.ReadSlice1D "b1" in
      (if: "err2"
      then (slice.nil, slice.nil, #true)
      else
        (struct.new MapValPre [
           "Epoch" ::= "a1";
           "PkCommit" ::= "a2"
         ], "b2", #false))).

(* checkOneUpd from auditor.go *)

(* checkOneUpd checks that an update is safe to apply, and errs on fail. *)
Definition checkOneUpd: val :=
  rec: "checkOneUpd" "keys" "nextEp" "mapLabel" "mapVal" :=
    (if: (slice.len "mapLabel") ≠ cryptoffi.HashLen
    then #true
    else
      let: ("inTree", <>) := merkle.Tree__Get "keys" "mapLabel" in
      (if: "inTree"
      then #true
      else
        let: (("valPre", "rem"), "err1") := MapValPreDecode "mapVal" in
        (if: "err1"
        then #true
        else
          (if: (slice.len "rem") ≠ #0
          then #true
          else
            (if: (struct.loadF MapValPre "Epoch" "valPre") ≠ "nextEp"
            then #true
            else #false))))).

Definition checkUpd: val :=
  rec: "checkUpd" "keys" "nextEp" "upd" :=
    let: "loopErr" := ref (zero_val boolT) in
    MapIter "upd" (λ: "mapLabel" "mapVal",
      (if: checkOneUpd "keys" "nextEp" (StringToBytes "mapLabel") "mapVal"
      then "loopErr" <-[boolT] #true
      else #()));;
    ![boolT] "loopErr".

(* UpdateProof from serde.go *)

Definition UpdateProof := struct.decl [
  "Updates" :: mapT (slice.T byteT);
  "Sig" :: slice.T byteT
].

(* applyUpd from auditor.go *)

(* applyUpd applies a valid update to the previous map. *)
Definition applyUpd: val :=
  rec: "applyUpd" "keys" "upd" :=
    MapIter "upd" (λ: "label" "val",
      let: "err0" := merkle.Tree__Put "keys" (StringToBytes "label") "val" in
      std.Assert (~ "err0"));;
    #().

(* PreSigDig from serde.go *)

Definition PreSigDig := struct.decl [
  "Epoch" :: uint64T;
  "Dig" :: slice.T byteT
].

(* PreSigDigEncode from serde.out.go *)

Definition PreSigDigEncode: val :=
  rec: "PreSigDigEncode" "b0" "o" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (struct.loadF PreSigDig "Epoch" "o"));;
    "b" <-[slice.T byteT] (marshalutil.WriteSlice1D (![slice.T byteT] "b") (struct.loadF PreSigDig "Dig" "o"));;
    ![slice.T byteT] "b".

(* AdtrEpochInfo from serde.go *)

Definition AdtrEpochInfo := struct.decl [
  "Dig" :: slice.T byteT;
  "ServSig" :: slice.T byteT;
  "AdtrSig" :: slice.T byteT
].

(* Update checks new epoch updates, applies them, and errors on fail. *)
Definition Auditor__Update: val :=
  rec: "Auditor__Update" "a" "proof" :=
    Mutex__Lock (struct.loadF Auditor "mu" "a");;
    let: "nextEp" := slice.len (struct.loadF Auditor "histInfo" "a") in
    (if: checkUpd (struct.loadF Auditor "keyMap" "a") "nextEp" (struct.loadF UpdateProof "Updates" "proof")
    then
      Mutex__Unlock (struct.loadF Auditor "mu" "a");;
      #true
    else
      applyUpd (struct.loadF Auditor "keyMap" "a") (struct.loadF UpdateProof "Updates" "proof");;
      let: "dig" := merkle.Tree__Digest (struct.loadF Auditor "keyMap" "a") in
      let: "preSig" := struct.new PreSigDig [
        "Epoch" ::= "nextEp";
        "Dig" ::= "dig"
      ] in
      let: "preSigByt" := PreSigDigEncode (NewSliceWithCap byteT #0 ((#8 + #8) + cryptoffi.HashLen)) "preSig" in
      let: "sig" := cryptoffi.SigPrivateKey__Sign (struct.loadF Auditor "sk" "a") "preSigByt" in
      let: "newInfo" := struct.new AdtrEpochInfo [
        "Dig" ::= "dig";
        "ServSig" ::= struct.loadF UpdateProof "Sig" "proof";
        "AdtrSig" ::= "sig"
      ] in
      struct.storeF Auditor "histInfo" "a" (SliceAppend ptrT (struct.loadF Auditor "histInfo" "a") "newInfo");;
      Mutex__Unlock (struct.loadF Auditor "mu" "a");;
      #false).

(* Get returns the auditor's dig for a particular epoch, and errors on fail. *)
Definition Auditor__Get: val :=
  rec: "Auditor__Get" "a" "epoch" :=
    Mutex__Lock (struct.loadF Auditor "mu" "a");;
    let: "numEpochs" := slice.len (struct.loadF Auditor "histInfo" "a") in
    (if: "epoch" ≥ "numEpochs"
    then
      Mutex__Unlock (struct.loadF Auditor "mu" "a");;
      (struct.new AdtrEpochInfo [
       ], #true)
    else
      let: "info" := SliceGet ptrT (struct.loadF Auditor "histInfo" "a") "epoch" in
      Mutex__Unlock (struct.loadF Auditor "mu" "a");;
      ("info", #false)).

Definition NewAuditor: val :=
  rec: "NewAuditor" <> :=
    let: "mu" := newMutex #() in
    let: ("pk", "sk") := cryptoffi.SigGenerateKey #() in
    let: "m" := merkle.NewTree #() in
    (struct.new Auditor [
       "mu" ::= "mu";
       "sk" ::= "sk";
       "keyMap" ::= "m"
     ], "pk").

(* client.go *)

Definition Client := struct.decl [
  "uid" :: uint64T;
  "nextVer" :: uint64T;
  "seenDigs" :: mapT ptrT;
  "nextEpoch" :: uint64T;
  "servCli" :: ptrT;
  "servSigPk" :: cryptoffi.SigPublicKey;
  "servVrfPk" :: ptrT
].

(* ClientErr abstracts errors that potentially have irrefutable evidence. *)
Definition ClientErr := struct.decl [
  "Evid" :: ptrT;
  "Err" :: boolT
].

(* ServerPutArg from serde.go *)

Definition ServerPutArg := struct.decl [
  "Uid" :: uint64T;
  "Pk" :: slice.T byteT
].

(* ServerPutArgEncode from serde.out.go *)

Definition ServerPutArgEncode: val :=
  rec: "ServerPutArgEncode" "b0" "o" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (struct.loadF ServerPutArg "Uid" "o"));;
    "b" <-[slice.T byteT] (marshalutil.WriteSlice1D (![slice.T byteT] "b") (struct.loadF ServerPutArg "Pk" "o"));;
    ![slice.T byteT] "b".

(* ServerPutRpc from rpc.go *)

Definition ServerPutRpc : expr := #0.

Definition ServerGetRpc : expr := #1.

Definition ServerSelfMonRpc : expr := #2.

Definition ServerAuditRpc : expr := #3.

Definition AdtrUpdateRpc : expr := #0.

Definition AdtrGetRpc : expr := #1.

(* SigDig from serde.go *)

Definition SigDig := struct.decl [
  "Epoch" :: uint64T;
  "Dig" :: slice.T byteT;
  "Sig" :: slice.T byteT
].

(* SigDigDecode from serde.out.go *)

Definition SigDigDecode: val :=
  rec: "SigDigDecode" "b0" :=
    let: (("a1", "b1"), "err1") := marshalutil.ReadInt "b0" in
    (if: "err1"
    then (slice.nil, slice.nil, #true)
    else
      let: (("a2", "b2"), "err2") := marshalutil.ReadSlice1D "b1" in
      (if: "err2"
      then (slice.nil, slice.nil, #true)
      else
        let: (("a3", "b3"), "err3") := marshalutil.ReadSlice1D "b2" in
        (if: "err3"
        then (slice.nil, slice.nil, #true)
        else
          (struct.new SigDig [
             "Epoch" ::= "a1";
             "Dig" ::= "a2";
             "Sig" ::= "a3"
           ], "b3", #false)))).

(* CommitOpen from serde.go *)

Definition CommitOpen := struct.decl [
  "Val" :: slice.T byteT;
  "Rand" :: slice.T byteT
].

(* CommitOpenDecode from serde.out.go *)

Definition CommitOpenDecode: val :=
  rec: "CommitOpenDecode" "b0" :=
    let: (("a1", "b1"), "err1") := marshalutil.ReadSlice1D "b0" in
    (if: "err1"
    then (slice.nil, slice.nil, #true)
    else
      let: (("a2", "b2"), "err2") := marshalutil.ReadSlice1D "b1" in
      (if: "err2"
      then (slice.nil, slice.nil, #true)
      else
        (struct.new CommitOpen [
           "Val" ::= "a1";
           "Rand" ::= "a2"
         ], "b2", #false))).

(* Memb from serde.go *)

Definition Memb := struct.decl [
  "LabelProof" :: slice.T byteT;
  "EpochAdded" :: uint64T;
  "PkOpen" :: ptrT;
  "MerkleProof" :: slice.T byteT
].

(* MembDecode from serde.out.go *)

Definition MembDecode: val :=
  rec: "MembDecode" "b0" :=
    let: (("a1", "b1"), "err1") := marshalutil.ReadSlice1D "b0" in
    (if: "err1"
    then (slice.nil, slice.nil, #true)
    else
      let: (("a2", "b2"), "err2") := marshalutil.ReadInt "b1" in
      (if: "err2"
      then (slice.nil, slice.nil, #true)
      else
        let: (("a3", "b3"), "err3") := CommitOpenDecode "b2" in
        (if: "err3"
        then (slice.nil, slice.nil, #true)
        else
          let: (("a4", "b4"), "err4") := marshalutil.ReadSlice1D "b3" in
          (if: "err4"
          then (slice.nil, slice.nil, #true)
          else
            (struct.new Memb [
               "LabelProof" ::= "a1";
               "EpochAdded" ::= "a2";
               "PkOpen" ::= "a3";
               "MerkleProof" ::= "a4"
             ], "b4", #false))))).

(* NonMemb from serde.go *)

Definition NonMemb := struct.decl [
  "LabelProof" :: slice.T byteT;
  "MerkleProof" :: slice.T byteT
].

(* NonMembDecode from serde.out.go *)

Definition NonMembDecode: val :=
  rec: "NonMembDecode" "b0" :=
    let: (("a1", "b1"), "err1") := marshalutil.ReadSlice1D "b0" in
    (if: "err1"
    then (slice.nil, slice.nil, #true)
    else
      let: (("a2", "b2"), "err2") := marshalutil.ReadSlice1D "b1" in
      (if: "err2"
      then (slice.nil, slice.nil, #true)
      else
        (struct.new NonMemb [
           "LabelProof" ::= "a1";
           "MerkleProof" ::= "a2"
         ], "b2", #false))).

(* ServerPutReply from serde.go *)

Definition ServerPutReply := struct.decl [
  "Dig" :: ptrT;
  "Latest" :: ptrT;
  "Bound" :: ptrT;
  "Err" :: boolT
].

(* ServerPutReplyDecode from serde.out.go *)

Definition ServerPutReplyDecode: val :=
  rec: "ServerPutReplyDecode" "b0" :=
    let: (("a1", "b1"), "err1") := SigDigDecode "b0" in
    (if: "err1"
    then (slice.nil, slice.nil, #true)
    else
      let: (("a2", "b2"), "err2") := MembDecode "b1" in
      (if: "err2"
      then (slice.nil, slice.nil, #true)
      else
        let: (("a3", "b3"), "err3") := NonMembDecode "b2" in
        (if: "err3"
        then (slice.nil, slice.nil, #true)
        else
          let: (("a4", "b4"), "err4") := marshalutil.ReadBool "b3" in
          (if: "err4"
          then (slice.nil, slice.nil, #true)
          else
            (struct.new ServerPutReply [
               "Dig" ::= "a1";
               "Latest" ::= "a2";
               "Bound" ::= "a3";
               "Err" ::= "a4"
             ], "b4", #false))))).

(* CallServPut from rpc.go *)

Definition CallServPut: val :=
  rec: "CallServPut" "c" "uid" "pk" :=
    let: "arg" := struct.new ServerPutArg [
      "Uid" ::= "uid";
      "Pk" ::= "pk"
    ] in
    let: "argByt" := ServerPutArgEncode (NewSlice byteT #0) "arg" in
    let: "replyByt" := ref (zero_val (slice.T byteT)) in
    let: "err0" := advrpc.Client__Call "c" ServerPutRpc "argByt" "replyByt" in
    (if: "err0"
    then (slice.nil, slice.nil, slice.nil, #true)
    else
      let: (("reply", <>), "err1") := ServerPutReplyDecode (![slice.T byteT] "replyByt") in
      (if: "err1"
      then (slice.nil, slice.nil, slice.nil, #true)
      else (struct.loadF ServerPutReply "Dig" "reply", struct.loadF ServerPutReply "Latest" "reply", struct.loadF ServerPutReply "Bound" "reply", struct.loadF ServerPutReply "Err" "reply"))).

(* CheckSigDig from evidence.go *)

(* Check rets err if signed dig does not validate. *)
Definition CheckSigDig: val :=
  rec: "CheckSigDig" "o" "pk" :=
    let: "pre" := struct.new PreSigDig [
      "Epoch" ::= struct.loadF SigDig "Epoch" "o";
      "Dig" ::= struct.loadF SigDig "Dig" "o"
    ] in
    let: "preByt" := PreSigDigEncode (NewSlice byteT #0) "pre" in
    cryptoffi.SigPublicKey__Verify "pk" "preByt" (struct.loadF SigDig "Sig" "o").

(* Evid is evidence that the server signed two conflicting digs. *)
Definition Evid := struct.decl [
  "sigDig0" :: ptrT;
  "sigDig1" :: ptrT
].

(* checkDig from client.go *)

Definition checkDig: val :=
  rec: "checkDig" "servSigPk" "seenDigs" "dig" :=
    let: "stdErr" := struct.new ClientErr [
      "Err" ::= #true
    ] in
    let: "err0" := CheckSigDig "dig" "servSigPk" in
    (if: "err0"
    then "stdErr"
    else
      (if: (~ (std.SumNoOverflow (struct.loadF SigDig "Epoch" "dig") #1))
      then "stdErr"
      else
        let: ("seenDig", "ok0") := MapGet "seenDigs" (struct.loadF SigDig "Epoch" "dig") in
        (if: "ok0" && (~ (std.BytesEqual (struct.loadF SigDig "Dig" "seenDig") (struct.loadF SigDig "Dig" "dig")))
        then
          let: "evid" := struct.new Evid [
            "sigDig0" ::= "dig";
            "sigDig1" ::= "seenDig"
          ] in
          struct.new ClientErr [
            "Evid" ::= "evid";
            "Err" ::= #true
          ]
        else
          struct.new ClientErr [
            "Err" ::= #false
          ]))).

(* MapLabelPre from serde.go *)

Definition MapLabelPre := struct.decl [
  "Uid" :: uint64T;
  "Ver" :: uint64T
].

(* MapLabelPreEncode from serde.out.go *)

Definition MapLabelPreEncode: val :=
  rec: "MapLabelPreEncode" "b0" "o" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (struct.loadF MapLabelPre "Uid" "o"));;
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (struct.loadF MapLabelPre "Ver" "o"));;
    ![slice.T byteT] "b".

(* checkLabel from client.go *)

(* checkLabel checks the vrf proof, computes the label, and errors on fail. *)
Definition checkLabel: val :=
  rec: "checkLabel" "servVrfPk" "uid" "ver" "proof" :=
    let: "pre" := struct.new MapLabelPre [
      "Uid" ::= "uid";
      "Ver" ::= "ver"
    ] in
    let: "preByt" := MapLabelPreEncode (NewSliceWithCap byteT #0 #16) "pre" in
    cryptoffi.VrfPublicKey__Verify "servVrfPk" "preByt" "proof".

(* CommitOpenEncode from serde.out.go *)

Definition CommitOpenEncode: val :=
  rec: "CommitOpenEncode" "b0" "o" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (marshalutil.WriteSlice1D (![slice.T byteT] "b") (struct.loadF CommitOpen "Val" "o"));;
    "b" <-[slice.T byteT] (marshalutil.WriteSlice1D (![slice.T byteT] "b") (struct.loadF CommitOpen "Rand" "o"));;
    ![slice.T byteT] "b".

Definition MapValPreEncode: val :=
  rec: "MapValPreEncode" "b0" "o" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (struct.loadF MapValPre "Epoch" "o"));;
    "b" <-[slice.T byteT] (marshalutil.WriteSlice1D (![slice.T byteT] "b") (struct.loadF MapValPre "PkCommit" "o"));;
    ![slice.T byteT] "b".

(* compMapVal from server.go *)

(* compMapVal rets mapVal (epoch || Hash(pk || rand)). *)
Definition compMapVal: val :=
  rec: "compMapVal" "epoch" "pkOpen" :=
    let: "openByt" := CommitOpenEncode (NewSliceWithCap byteT #0 (((#8 + (slice.len (struct.loadF CommitOpen "Val" "pkOpen"))) + #8) + cryptoffi.HashLen)) "pkOpen" in
    let: "commit" := cryptoutil.Hash "openByt" in
    let: "v" := struct.new MapValPre [
      "Epoch" ::= "epoch";
      "PkCommit" ::= "commit"
    ] in
    MapValPreEncode (NewSliceWithCap byteT #0 ((#8 + #8) + cryptoffi.HashLen)) "v".

(* checkMemb from client.go *)

(* checkMemb errors on fail. *)
Definition checkMemb: val :=
  rec: "checkMemb" "servVrfPk" "uid" "ver" "dig" "memb" :=
    let: ("label", "err") := checkLabel "servVrfPk" "uid" "ver" (struct.loadF Memb "LabelProof" "memb") in
    (if: "err"
    then #true
    else
      let: "mapVal" := compMapVal (struct.loadF Memb "EpochAdded" "memb") (struct.loadF Memb "PkOpen" "memb") in
      merkle.Verify #true "label" "mapVal" (struct.loadF Memb "MerkleProof" "memb") "dig").

(* checkNonMemb errors on fail. *)
Definition checkNonMemb: val :=
  rec: "checkNonMemb" "servVrfPk" "uid" "ver" "dig" "nonMemb" :=
    let: ("label", "err") := checkLabel "servVrfPk" "uid" "ver" (struct.loadF NonMemb "LabelProof" "nonMemb") in
    (if: "err"
    then #true
    else merkle.Verify #false "label" slice.nil (struct.loadF NonMemb "MerkleProof" "nonMemb") "dig").

(* Put rets the epoch at which the key was put, and evid / error on fail. *)
Definition Client__Put: val :=
  rec: "Client__Put" "c" "pk" :=
    let: "stdErr" := struct.new ClientErr [
      "Err" ::= #true
    ] in
    let: ((("dig", "latest"), "bound"), "err0") := CallServPut (struct.loadF Client "servCli" "c") (struct.loadF Client "uid" "c") "pk" in
    (if: "err0"
    then (#0, "stdErr")
    else
      let: "err1" := checkDig (struct.loadF Client "servSigPk" "c") (struct.loadF Client "seenDigs" "c") "dig" in
      (if: struct.loadF ClientErr "Err" "err1"
      then (#0, "err1")
      else
        (if: (struct.loadF SigDig "Epoch" "dig") < (struct.loadF Client "nextEpoch" "c")
        then (#0, "stdErr")
        else
          (if: checkMemb (struct.loadF Client "servVrfPk" "c") (struct.loadF Client "uid" "c") (struct.loadF Client "nextVer" "c") (struct.loadF SigDig "Dig" "dig") "latest"
          then (#0, "stdErr")
          else
            (if: (struct.loadF SigDig "Epoch" "dig") ≠ (struct.loadF Memb "EpochAdded" "latest")
            then (#0, "stdErr")
            else
              (if: (~ (std.BytesEqual "pk" (struct.loadF CommitOpen "Val" (struct.loadF Memb "PkOpen" "latest"))))
              then (#0, "stdErr")
              else
                (if: checkNonMemb (struct.loadF Client "servVrfPk" "c") (struct.loadF Client "uid" "c") ((struct.loadF Client "nextVer" "c") + #1) (struct.loadF SigDig "Dig" "dig") "bound"
                then (#0, "stdErr")
                else
                  MapInsert (struct.loadF Client "seenDigs" "c") (struct.loadF SigDig "Epoch" "dig") "dig";;
                  struct.storeF Client "nextEpoch" "c" ((struct.loadF SigDig "Epoch" "dig") + #1);;
                  struct.storeF Client "nextVer" "c" (std.SumAssumeNoOverflow (struct.loadF Client "nextVer" "c") #1);;
                  (struct.loadF SigDig "Epoch" "dig", struct.new ClientErr [
                     "Err" ::= #false
                   ])))))))).

(* ServerGetArg from serde.go *)

Definition ServerGetArg := struct.decl [
  "Uid" :: uint64T
].

(* ServerGetArgEncode from serde.out.go *)

Definition ServerGetArgEncode: val :=
  rec: "ServerGetArgEncode" "b0" "o" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (struct.loadF ServerGetArg "Uid" "o"));;
    ![slice.T byteT] "b".

(* MembHide from serde.go *)

Definition MembHide := struct.decl [
  "LabelProof" :: slice.T byteT;
  "MapVal" :: slice.T byteT;
  "MerkleProof" :: slice.T byteT
].

(* MembHideDecode from serde.out.go *)

Definition MembHideDecode: val :=
  rec: "MembHideDecode" "b0" :=
    let: (("a1", "b1"), "err1") := marshalutil.ReadSlice1D "b0" in
    (if: "err1"
    then (slice.nil, slice.nil, #true)
    else
      let: (("a2", "b2"), "err2") := marshalutil.ReadSlice1D "b1" in
      (if: "err2"
      then (slice.nil, slice.nil, #true)
      else
        let: (("a3", "b3"), "err3") := marshalutil.ReadSlice1D "b2" in
        (if: "err3"
        then (slice.nil, slice.nil, #true)
        else
          (struct.new MembHide [
             "LabelProof" ::= "a1";
             "MapVal" ::= "a2";
             "MerkleProof" ::= "a3"
           ], "b3", #false)))).

(* MembHideSlice1DDecode from serde_misc.go *)

Definition MembHideSlice1DDecode: val :=
  rec: "MembHideSlice1DDecode" "b0" :=
    let: (("length", "b1"), "err1") := marshalutil.ReadInt "b0" in
    (if: "err1"
    then (slice.nil, slice.nil, #true)
    else
      let: "loopO" := ref_to (slice.T ptrT) (NewSliceWithCap ptrT #0 "length") in
      let: "loopErr" := ref (zero_val boolT) in
      let: "loopB" := ref_to (slice.T byteT) "b1" in
      let: "i" := ref_to uint64T #0 in
      (for: (λ: <>, (![uint64T] "i") < "length"); (λ: <>, "i" <-[uint64T] ((![uint64T] "i") + #1)) := λ: <>,
        let: (("a2", "loopB1"), "err2") := MembHideDecode (![slice.T byteT] "loopB") in
        "loopB" <-[slice.T byteT] "loopB1";;
        (if: "err2"
        then
          "loopErr" <-[boolT] #true;;
          Break
        else
          "loopO" <-[slice.T ptrT] (SliceAppend ptrT (![slice.T ptrT] "loopO") "a2");;
          Continue));;
      (if: ![boolT] "loopErr"
      then (slice.nil, slice.nil, #true)
      else (![slice.T ptrT] "loopO", ![slice.T byteT] "loopB", #false))).

(* ServerGetReply from serde.go *)

Definition ServerGetReply := struct.decl [
  "Dig" :: ptrT;
  "Hist" :: slice.T ptrT;
  "IsReg" :: boolT;
  "Latest" :: ptrT;
  "Bound" :: ptrT
].

(* ServerGetReplyDecode from serde.out.go *)

Definition ServerGetReplyDecode: val :=
  rec: "ServerGetReplyDecode" "b0" :=
    let: (("a1", "b1"), "err1") := SigDigDecode "b0" in
    (if: "err1"
    then (slice.nil, slice.nil, #true)
    else
      let: (("a2", "b2"), "err2") := MembHideSlice1DDecode "b1" in
      (if: "err2"
      then (slice.nil, slice.nil, #true)
      else
        let: (("a3", "b3"), "err3") := marshalutil.ReadBool "b2" in
        (if: "err3"
        then (slice.nil, slice.nil, #true)
        else
          let: (("a4", "b4"), "err4") := MembDecode "b3" in
          (if: "err4"
          then (slice.nil, slice.nil, #true)
          else
            let: (("a5", "b5"), "err5") := NonMembDecode "b4" in
            (if: "err5"
            then (slice.nil, slice.nil, #true)
            else
              (struct.new ServerGetReply [
                 "Dig" ::= "a1";
                 "Hist" ::= "a2";
                 "IsReg" ::= "a3";
                 "Latest" ::= "a4";
                 "Bound" ::= "a5"
               ], "b5", #false)))))).

(* CallServGet from rpc.go *)

Definition CallServGet: val :=
  rec: "CallServGet" "c" "uid" :=
    let: "arg" := struct.new ServerGetArg [
      "Uid" ::= "uid"
    ] in
    let: "argByt" := ServerGetArgEncode (NewSlice byteT #0) "arg" in
    let: "replyByt" := ref (zero_val (slice.T byteT)) in
    let: "err0" := advrpc.Client__Call "c" ServerGetRpc "argByt" "replyByt" in
    (if: "err0"
    then (slice.nil, slice.nil, #false, slice.nil, slice.nil, #true)
    else
      let: (("reply", <>), "err1") := ServerGetReplyDecode (![slice.T byteT] "replyByt") in
      (if: "err1"
      then (slice.nil, slice.nil, #false, slice.nil, slice.nil, #true)
      else (struct.loadF ServerGetReply "Dig" "reply", struct.loadF ServerGetReply "Hist" "reply", struct.loadF ServerGetReply "IsReg" "reply", struct.loadF ServerGetReply "Latest" "reply", struct.loadF ServerGetReply "Bound" "reply", #false))).

(* checkMembHide from client.go *)

(* checkMembHide errors on fail. *)
Definition checkMembHide: val :=
  rec: "checkMembHide" "servVrfPk" "uid" "ver" "dig" "memb" :=
    let: ("label", "err") := checkLabel "servVrfPk" "uid" "ver" (struct.loadF MembHide "LabelProof" "memb") in
    (if: "err"
    then #true
    else merkle.Verify #true "label" (struct.loadF MembHide "MapVal" "memb") (struct.loadF MembHide "MerkleProof" "memb") "dig").

(* checkHist errors on fail. *)
Definition checkHist: val :=
  rec: "checkHist" "servVrfPk" "uid" "dig" "membs" :=
    let: "err0" := ref (zero_val boolT) in
    ForSlice ptrT "ver" "memb" "membs"
      ((if: checkMembHide "servVrfPk" "uid" "ver" "dig" "memb"
      then "err0" <-[boolT] #true
      else #()));;
    ![boolT] "err0".

(* Get returns if the pk was registered, the pk, and the epoch
   at which it was seen, or an error / evid.
   Note: interaction of isReg and hist is a potential source of bugs.
   e.g., if don't track vers properly, bound could be off.
   e.g., if don't check isReg alignment with hist, could have fraud non-exis key. *)
Definition Client__Get: val :=
  rec: "Client__Get" "c" "uid" :=
    let: "stdErr" := struct.new ClientErr [
      "Err" ::= #true
    ] in
    let: ((((("dig", "hist"), "isReg"), "latest"), "bound"), "err0") := CallServGet (struct.loadF Client "servCli" "c") "uid" in
    (if: "err0"
    then (#false, slice.nil, #0, "stdErr")
    else
      let: "err1" := checkDig (struct.loadF Client "servSigPk" "c") (struct.loadF Client "seenDigs" "c") "dig" in
      (if: struct.loadF ClientErr "Err" "err1"
      then (#false, slice.nil, #0, "err1")
      else
        (if: ((struct.loadF SigDig "Epoch" "dig") + #1) < (struct.loadF Client "nextEpoch" "c")
        then (#false, slice.nil, #0, "stdErr")
        else
          (if: checkHist (struct.loadF Client "servVrfPk" "c") "uid" (struct.loadF SigDig "Dig" "dig") "hist"
          then (#false, slice.nil, #0, "stdErr")
          else
            let: "numHistVers" := slice.len "hist" in
            (if: ("numHistVers" > #0) && (~ "isReg")
            then (#false, slice.nil, #0, "stdErr")
            else
              (if: "isReg" && (checkMemb (struct.loadF Client "servVrfPk" "c") "uid" "numHistVers" (struct.loadF SigDig "Dig" "dig") "latest")
              then (#false, slice.nil, #0, "stdErr")
              else
                let: "boundVer" := ref (zero_val uint64T) in
                (if: "isReg"
                then "boundVer" <-[uint64T] ("numHistVers" + #1)
                else #());;
                (if: checkNonMemb (struct.loadF Client "servVrfPk" "c") "uid" (![uint64T] "boundVer") (struct.loadF SigDig "Dig" "dig") "bound"
                then (#false, slice.nil, #0, "stdErr")
                else
                  MapInsert (struct.loadF Client "seenDigs" "c") (struct.loadF SigDig "Epoch" "dig") "dig";;
                  struct.storeF Client "nextEpoch" "c" ((struct.loadF SigDig "Epoch" "dig") + #1);;
                  ("isReg", struct.loadF CommitOpen "Val" (struct.loadF Memb "PkOpen" "latest"), struct.loadF SigDig "Epoch" "dig", struct.new ClientErr [
                     "Err" ::= #false
                   ])))))))).

(* ServerSelfMonArg from serde.go *)

Definition ServerSelfMonArg := struct.decl [
  "Uid" :: uint64T
].

(* ServerSelfMonArgEncode from serde.out.go *)

Definition ServerSelfMonArgEncode: val :=
  rec: "ServerSelfMonArgEncode" "b0" "o" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (struct.loadF ServerSelfMonArg "Uid" "o"));;
    ![slice.T byteT] "b".

(* ServerSelfMonReply from serde.go *)

Definition ServerSelfMonReply := struct.decl [
  "Dig" :: ptrT;
  "Bound" :: ptrT
].

(* ServerSelfMonReplyDecode from serde.out.go *)

Definition ServerSelfMonReplyDecode: val :=
  rec: "ServerSelfMonReplyDecode" "b0" :=
    let: (("a1", "b1"), "err1") := SigDigDecode "b0" in
    (if: "err1"
    then (slice.nil, slice.nil, #true)
    else
      let: (("a2", "b2"), "err2") := NonMembDecode "b1" in
      (if: "err2"
      then (slice.nil, slice.nil, #true)
      else
        (struct.new ServerSelfMonReply [
           "Dig" ::= "a1";
           "Bound" ::= "a2"
         ], "b2", #false))).

(* CallServSelfMon from rpc.go *)

Definition CallServSelfMon: val :=
  rec: "CallServSelfMon" "c" "uid" :=
    let: "arg" := struct.new ServerSelfMonArg [
      "Uid" ::= "uid"
    ] in
    let: "argByt" := ServerSelfMonArgEncode (NewSlice byteT #0) "arg" in
    let: "replyByt" := ref (zero_val (slice.T byteT)) in
    let: "err0" := advrpc.Client__Call "c" ServerSelfMonRpc "argByt" "replyByt" in
    (if: "err0"
    then (slice.nil, slice.nil, #true)
    else
      let: (("reply", <>), "err1") := ServerSelfMonReplyDecode (![slice.T byteT] "replyByt") in
      (if: "err1"
      then (slice.nil, slice.nil, #true)
      else (struct.loadF ServerSelfMonReply "Dig" "reply", struct.loadF ServerSelfMonReply "Bound" "reply", #false))).

(* SelfMon self-monitors for the client's own key, and returns the epoch
   through which it succeeds, or evid / error on fail. *)
Definition Client__SelfMon: val :=
  rec: "Client__SelfMon" "c" :=
    let: "stdErr" := struct.new ClientErr [
      "Err" ::= #true
    ] in
    let: (("dig", "bound"), "err0") := CallServSelfMon (struct.loadF Client "servCli" "c") (struct.loadF Client "uid" "c") in
    (if: "err0"
    then (#0, "stdErr")
    else
      let: "err1" := checkDig (struct.loadF Client "servSigPk" "c") (struct.loadF Client "seenDigs" "c") "dig" in
      (if: struct.loadF ClientErr "Err" "err1"
      then (#0, "err1")
      else
        (if: ((struct.loadF SigDig "Epoch" "dig") + #1) < (struct.loadF Client "nextEpoch" "c")
        then (#0, "stdErr")
        else
          (if: checkNonMemb (struct.loadF Client "servVrfPk" "c") (struct.loadF Client "uid" "c") (struct.loadF Client "nextVer" "c") (struct.loadF SigDig "Dig" "dig") "bound"
          then (#0, "stdErr")
          else
            MapInsert (struct.loadF Client "seenDigs" "c") (struct.loadF SigDig "Epoch" "dig") "dig";;
            struct.storeF Client "nextEpoch" "c" ((struct.loadF SigDig "Epoch" "dig") + #1);;
            (struct.loadF SigDig "Epoch" "dig", struct.new ClientErr [
               "Err" ::= #false
             ]))))).

(* AdtrGetArg from serde.go *)

Definition AdtrGetArg := struct.decl [
  "Epoch" :: uint64T
].

(* AdtrGetArgEncode from serde.out.go *)

Definition AdtrGetArgEncode: val :=
  rec: "AdtrGetArgEncode" "b0" "o" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (struct.loadF AdtrGetArg "Epoch" "o"));;
    ![slice.T byteT] "b".

Definition AdtrEpochInfoDecode: val :=
  rec: "AdtrEpochInfoDecode" "b0" :=
    let: (("a1", "b1"), "err1") := marshalutil.ReadSlice1D "b0" in
    (if: "err1"
    then (slice.nil, slice.nil, #true)
    else
      let: (("a2", "b2"), "err2") := marshalutil.ReadSlice1D "b1" in
      (if: "err2"
      then (slice.nil, slice.nil, #true)
      else
        let: (("a3", "b3"), "err3") := marshalutil.ReadSlice1D "b2" in
        (if: "err3"
        then (slice.nil, slice.nil, #true)
        else
          (struct.new AdtrEpochInfo [
             "Dig" ::= "a1";
             "ServSig" ::= "a2";
             "AdtrSig" ::= "a3"
           ], "b3", #false)))).

(* AdtrGetReply from serde.go *)

Definition AdtrGetReply := struct.decl [
  "X" :: ptrT;
  "Err" :: boolT
].

(* AdtrGetReplyDecode from serde.out.go *)

Definition AdtrGetReplyDecode: val :=
  rec: "AdtrGetReplyDecode" "b0" :=
    let: (("a1", "b1"), "err1") := AdtrEpochInfoDecode "b0" in
    (if: "err1"
    then (slice.nil, slice.nil, #true)
    else
      let: (("a2", "b2"), "err2") := marshalutil.ReadBool "b1" in
      (if: "err2"
      then (slice.nil, slice.nil, #true)
      else
        (struct.new AdtrGetReply [
           "X" ::= "a1";
           "Err" ::= "a2"
         ], "b2", #false))).

(* CallAdtrGet from rpc.go *)

Definition CallAdtrGet: val :=
  rec: "CallAdtrGet" "c" "epoch" :=
    let: "arg" := struct.new AdtrGetArg [
      "Epoch" ::= "epoch"
    ] in
    let: "argByt" := AdtrGetArgEncode (NewSlice byteT #0) "arg" in
    let: "replyByt" := ref (zero_val (slice.T byteT)) in
    let: "err0" := advrpc.Client__Call "c" AdtrGetRpc "argByt" "replyByt" in
    (if: "err0"
    then (slice.nil, #true)
    else
      let: (("reply", <>), "err1") := AdtrGetReplyDecode (![slice.T byteT] "replyByt") in
      (if: "err1"
      then (slice.nil, #true)
      else (struct.loadF AdtrGetReply "X" "reply", struct.loadF AdtrGetReply "Err" "reply"))).

(* auditEpoch from client.go *)

(* auditEpoch checks a single epoch against an auditor, and evid / error on fail. *)
Definition auditEpoch: val :=
  rec: "auditEpoch" "seenDig" "servSigPk" "adtrCli" "adtrPk" :=
    let: "stdErr" := struct.new ClientErr [
      "Err" ::= #true
    ] in
    let: ("adtrInfo", "err0") := CallAdtrGet "adtrCli" (struct.loadF SigDig "Epoch" "seenDig") in
    (if: "err0"
    then "stdErr"
    else
      let: "servDig" := struct.new SigDig [
        "Epoch" ::= struct.loadF SigDig "Epoch" "seenDig";
        "Dig" ::= struct.loadF AdtrEpochInfo "Dig" "adtrInfo";
        "Sig" ::= struct.loadF AdtrEpochInfo "ServSig" "adtrInfo"
      ] in
      let: "adtrDig" := struct.new SigDig [
        "Epoch" ::= struct.loadF SigDig "Epoch" "seenDig";
        "Dig" ::= struct.loadF AdtrEpochInfo "Dig" "adtrInfo";
        "Sig" ::= struct.loadF AdtrEpochInfo "AdtrSig" "adtrInfo"
      ] in
      (if: CheckSigDig "servDig" "servSigPk"
      then "stdErr"
      else
        (if: CheckSigDig "adtrDig" "adtrPk"
        then "stdErr"
        else
          (if: (~ (std.BytesEqual (struct.loadF AdtrEpochInfo "Dig" "adtrInfo") (struct.loadF SigDig "Dig" "seenDig")))
          then
            let: "evid" := struct.new Evid [
              "sigDig0" ::= "servDig";
              "sigDig1" ::= "seenDig"
            ] in
            struct.new ClientErr [
              "Evid" ::= "evid";
              "Err" ::= #true
            ]
          else
            struct.new ClientErr [
              "Err" ::= #false
            ])))).

Definition Client__Audit: val :=
  rec: "Client__Audit" "c" "adtrAddr" "adtrPk" :=
    let: "adtrCli" := advrpc.Dial "adtrAddr" in
    let: "err0" := ref_to ptrT (struct.new ClientErr [
      "Err" ::= #false
    ]) in
    MapIter (struct.loadF Client "seenDigs" "c") (λ: <> "dig",
      let: "err1" := auditEpoch "dig" (struct.loadF Client "servSigPk" "c") "adtrCli" "adtrPk" in
      (if: struct.loadF ClientErr "Err" "err1"
      then "err0" <-[ptrT] "err1"
      else #()));;
    ![ptrT] "err0".

Definition NewClient: val :=
  rec: "NewClient" "uid" "servAddr" "servSigPk" "servVrfPk" :=
    let: "c" := advrpc.Dial "servAddr" in
    let: "pk" := cryptoffi.VrfPublicKeyDecode "servVrfPk" in
    let: "digs" := NewMap uint64T ptrT #() in
    struct.new Client [
      "uid" ::= "uid";
      "servCli" ::= "c";
      "servSigPk" ::= "servSigPk";
      "servVrfPk" ::= "pk";
      "seenDigs" ::= "digs"
    ].

(* evidence.go *)

(* Check returns an error if the evidence does not check out.
   otherwise, it proves that the server was dishonest. *)
Definition Evid__Check: val :=
  rec: "Evid__Check" "e" "servPk" :=
    let: "err0" := CheckSigDig (struct.loadF Evid "sigDig0" "e") "servPk" in
    (if: "err0"
    then #true
    else
      let: "err1" := CheckSigDig (struct.loadF Evid "sigDig1" "e") "servPk" in
      (if: "err1"
      then #true
      else
        (if: (struct.loadF SigDig "Epoch" (struct.loadF Evid "sigDig0" "e")) ≠ (struct.loadF SigDig "Epoch" (struct.loadF Evid "sigDig1" "e"))
        then #true
        else std.BytesEqual (struct.loadF SigDig "Dig" (struct.loadF Evid "sigDig0" "e")) (struct.loadF SigDig "Dig" (struct.loadF Evid "sigDig1" "e"))))).

(* history.go *)

Definition HistEntry := struct.decl [
  "Epoch" :: uint64T;
  "HistVal" :: slice.T byteT
].

(* GetHist searches hist at the epoch and rets the latest val, or false
   if there's no registered val. *)
Definition GetHist: val :=
  rec: "GetHist" "o" "epoch" :=
    let: "isReg" := ref (zero_val boolT) in
    let: "val" := ref (zero_val (slice.T byteT)) in
    ForSlice ptrT <> "e" "o"
      ((if: (struct.loadF HistEntry "Epoch" "e") ≤ "epoch"
      then
        "isReg" <-[boolT] #true;;
        "val" <-[slice.T byteT] (struct.loadF HistEntry "HistVal" "e")
      else #()));;
    (![boolT] "isReg", ![slice.T byteT] "val").

(* rpc.go *)

(* ServerPutArgDecode from serde.out.go *)

Definition ServerPutArgDecode: val :=
  rec: "ServerPutArgDecode" "b0" :=
    let: (("a1", "b1"), "err1") := marshalutil.ReadInt "b0" in
    (if: "err1"
    then (slice.nil, slice.nil, #true)
    else
      let: (("a2", "b2"), "err2") := marshalutil.ReadSlice1D "b1" in
      (if: "err2"
      then (slice.nil, slice.nil, #true)
      else
        (struct.new ServerPutArg [
           "Uid" ::= "a1";
           "Pk" ::= "a2"
         ], "b2", #false))).

(* Work from workq.go *)

Definition Work := struct.decl [
  "done" :: boolT;
  "Req" :: ptrT;
  "Resp" :: ptrT
].

(* WQReq from server.go *)

Definition WQReq := struct.decl [
  "Uid" :: uint64T;
  "Pk" :: slice.T byteT
].

(* WorkQ from workq.go *)

Definition WorkQ := struct.decl [
  "mu" :: ptrT;
  "work" :: slice.T ptrT;
  "condCli" :: ptrT;
  "condWorker" :: ptrT
].

Definition WorkQ__Do: val :=
  rec: "WorkQ__Do" "wq" "r" :=
    Mutex__Lock (struct.loadF WorkQ "mu" "wq");;
    struct.storeF WorkQ "work" "wq" (SliceAppend ptrT (struct.loadF WorkQ "work" "wq") "r");;
    Cond__Signal (struct.loadF WorkQ "condWorker" "wq");;
    Skip;;
    (for: (λ: <>, (~ (struct.loadF Work "done" "r"))); (λ: <>, Skip) := λ: <>,
      Cond__Wait (struct.loadF WorkQ "condCli" "wq");;
      Continue);;
    Mutex__Unlock (struct.loadF WorkQ "mu" "wq");;
    #().

(* Server from server.go *)

Definition Server := struct.decl [
  "mu" :: ptrT;
  "sigSk" :: ptrT;
  "vrfSk" :: ptrT;
  "commitSecret" :: slice.T byteT;
  "keyMap" :: ptrT;
  "userInfo" :: mapT ptrT;
  "epochHist" :: slice.T ptrT;
  "workQ" :: ptrT
].

Definition WQResp := struct.decl [
  "Dig" :: ptrT;
  "Lat" :: ptrT;
  "Bound" :: ptrT;
  "Err" :: boolT
].

(* Put errors iff there's a put of the same uid at the same time. *)
Definition Server__Put: val :=
  rec: "Server__Put" "s" "uid" "pk" :=
    let: "work" := struct.new Work [
      "Req" ::= struct.new WQReq [
        "Uid" ::= "uid";
        "Pk" ::= "pk"
      ]
    ] in
    WorkQ__Do (struct.loadF Server "workQ" "s") "work";;
    let: "resp" := struct.loadF Work "Resp" "work" in
    (struct.loadF WQResp "Dig" "resp", struct.loadF WQResp "Lat" "resp", struct.loadF WQResp "Bound" "resp", struct.loadF WQResp "Err" "resp").

(* SigDigEncode from serde.out.go *)

Definition SigDigEncode: val :=
  rec: "SigDigEncode" "b0" "o" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (struct.loadF SigDig "Epoch" "o"));;
    "b" <-[slice.T byteT] (marshalutil.WriteSlice1D (![slice.T byteT] "b") (struct.loadF SigDig "Dig" "o"));;
    "b" <-[slice.T byteT] (marshalutil.WriteSlice1D (![slice.T byteT] "b") (struct.loadF SigDig "Sig" "o"));;
    ![slice.T byteT] "b".

Definition MembEncode: val :=
  rec: "MembEncode" "b0" "o" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (marshalutil.WriteSlice1D (![slice.T byteT] "b") (struct.loadF Memb "LabelProof" "o"));;
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (struct.loadF Memb "EpochAdded" "o"));;
    "b" <-[slice.T byteT] (CommitOpenEncode (![slice.T byteT] "b") (struct.loadF Memb "PkOpen" "o"));;
    "b" <-[slice.T byteT] (marshalutil.WriteSlice1D (![slice.T byteT] "b") (struct.loadF Memb "MerkleProof" "o"));;
    ![slice.T byteT] "b".

Definition NonMembEncode: val :=
  rec: "NonMembEncode" "b0" "o" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (marshalutil.WriteSlice1D (![slice.T byteT] "b") (struct.loadF NonMemb "LabelProof" "o"));;
    "b" <-[slice.T byteT] (marshalutil.WriteSlice1D (![slice.T byteT] "b") (struct.loadF NonMemb "MerkleProof" "o"));;
    ![slice.T byteT] "b".

Definition ServerPutReplyEncode: val :=
  rec: "ServerPutReplyEncode" "b0" "o" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (SigDigEncode (![slice.T byteT] "b") (struct.loadF ServerPutReply "Dig" "o"));;
    "b" <-[slice.T byteT] (MembEncode (![slice.T byteT] "b") (struct.loadF ServerPutReply "Latest" "o"));;
    "b" <-[slice.T byteT] (NonMembEncode (![slice.T byteT] "b") (struct.loadF ServerPutReply "Bound" "o"));;
    "b" <-[slice.T byteT] (marshal.WriteBool (![slice.T byteT] "b") (struct.loadF ServerPutReply "Err" "o"));;
    ![slice.T byteT] "b".

Definition ServerGetArgDecode: val :=
  rec: "ServerGetArgDecode" "b0" :=
    let: (("a1", "b1"), "err1") := marshalutil.ReadInt "b0" in
    (if: "err1"
    then (slice.nil, slice.nil, #true)
    else
      (struct.new ServerGetArg [
         "Uid" ::= "a1"
       ], "b1", #false)).

(* userState from server.go *)

Definition userState := struct.decl [
  "numVers" :: uint64T;
  "plainPk" :: slice.T byteT
].

Definition servEpochInfo := struct.decl [
  "updates" :: mapT (slice.T byteT);
  "dig" :: slice.T byteT;
  "sig" :: slice.T byteT
].

Definition getDig: val :=
  rec: "getDig" "hist" :=
    let: "numEpochs" := slice.len "hist" in
    let: "lastInfo" := SliceGet ptrT "hist" ("numEpochs" - #1) in
    struct.new SigDig [
      "Epoch" ::= "numEpochs" - #1;
      "Dig" ::= struct.loadF servEpochInfo "dig" "lastInfo";
      "Sig" ::= struct.loadF servEpochInfo "sig" "lastInfo"
    ].

(* compMapLabel rets the vrf output and proof for mapLabel (VRF(uid || ver)). *)
Definition compMapLabel: val :=
  rec: "compMapLabel" "uid" "ver" "sk" :=
    let: "l" := struct.new MapLabelPre [
      "Uid" ::= "uid";
      "Ver" ::= "ver"
    ] in
    let: "lByt" := MapLabelPreEncode (NewSliceWithCap byteT #0 #16) "l" in
    cryptoffi.VrfPrivateKey__Prove "sk" "lByt".

(* getHist returns membership proofs for the history of versions
   up until the latest. *)
Definition getHist: val :=
  rec: "getHist" "keyMap" "uid" "numVers" "vrfSk" :=
    (if: "numVers" = #0
    then slice.nil
    else
      let: "hist" := ref_to (slice.T ptrT) (NewSliceWithCap ptrT #0 ("numVers" - #1)) in
      let: "ver" := ref_to uint64T #0 in
      Skip;;
      (for: (λ: <>, (![uint64T] "ver") < ("numVers" - #1)); (λ: <>, Skip) := λ: <>,
        let: ("label", "labelProof") := compMapLabel "uid" (![uint64T] "ver") "vrfSk" in
        let: (("inMap", "mapVal"), "mapProof") := merkle.Tree__Prove "keyMap" "label" in
        std.Assert "inMap";;
        "hist" <-[slice.T ptrT] (SliceAppend ptrT (![slice.T ptrT] "hist") (struct.new MembHide [
          "LabelProof" ::= "labelProof";
          "MapVal" ::= "mapVal";
          "MerkleProof" ::= "mapProof"
        ]));;
        "ver" <-[uint64T] ((![uint64T] "ver") + #1);;
        Continue);;
      ![slice.T ptrT] "hist").

Definition compCommitOpen: val :=
  rec: "compCommitOpen" "secret" "label" :=
    let: "b" := ref_to (slice.T byteT) (NewSliceWithCap byteT #0 (#2 * cryptoffi.HashLen)) in
    "b" <-[slice.T byteT] (SliceAppendSlice byteT (![slice.T byteT] "b") "secret");;
    "b" <-[slice.T byteT] (SliceAppendSlice byteT (![slice.T byteT] "b") "label");;
    cryptoutil.Hash (![slice.T byteT] "b").

(* getLatest returns whether a version is registered, and if so,
   a membership proof for the latest version. *)
Definition getLatest: val :=
  rec: "getLatest" "keyMap" "uid" "numVers" "vrfSk" "commitSecret" "pk" :=
    (if: "numVers" = #0
    then
      (#false, struct.new Memb [
         "PkOpen" ::= struct.new CommitOpen [
         ]
       ])
    else
      let: ("label", "labelProof") := compMapLabel "uid" ("numVers" - #1) "vrfSk" in
      let: (("inMap", "mapVal"), "mapProof") := merkle.Tree__Prove "keyMap" "label" in
      std.Assert "inMap";;
      let: (("valPre", <>), "err1") := MapValPreDecode "mapVal" in
      std.Assert (~ "err1");;
      let: "r" := compCommitOpen "commitSecret" "label" in
      let: "open" := struct.new CommitOpen [
        "Val" ::= "pk";
        "Rand" ::= "r"
      ] in
      (#true, struct.new Memb [
         "LabelProof" ::= "labelProof";
         "EpochAdded" ::= struct.loadF MapValPre "Epoch" "valPre";
         "PkOpen" ::= "open";
         "MerkleProof" ::= "mapProof"
       ])).

(* getBound returns a non-membership proof for the boundary version. *)
Definition getBound: val :=
  rec: "getBound" "keyMap" "uid" "numVers" "vrfSk" :=
    let: ("label", "labelProof") := compMapLabel "uid" "numVers" "vrfSk" in
    let: (("inMap", <>), "mapProof") := merkle.Tree__Prove "keyMap" "label" in
    std.Assert (~ "inMap");;
    struct.new NonMemb [
      "LabelProof" ::= "labelProof";
      "MerkleProof" ::= "mapProof"
    ].

(* Get returns a complete history proof for uid.
   if uid is not yet registered, it returns an empty memb proof for
   for the latest version. *)
Definition Server__Get: val :=
  rec: "Server__Get" "s" "uid" :=
    RWMutex__RLock (struct.loadF Server "mu" "s");;
    let: "user" := Fst (MapGet (struct.loadF Server "userInfo" "s") "uid") in
    let: "numVers" := ref (zero_val uint64T) in
    let: "plainPk" := ref (zero_val (slice.T byteT)) in
    (if: "user" ≠ #null
    then
      "numVers" <-[uint64T] (struct.loadF userState "numVers" "user");;
      "plainPk" <-[slice.T byteT] (struct.loadF userState "plainPk" "user")
    else #());;
    let: "dig" := getDig (struct.loadF Server "epochHist" "s") in
    let: "hist" := getHist (struct.loadF Server "keyMap" "s") "uid" (![uint64T] "numVers") (struct.loadF Server "vrfSk" "s") in
    let: ("isReg", "latest") := getLatest (struct.loadF Server "keyMap" "s") "uid" (![uint64T] "numVers") (struct.loadF Server "vrfSk" "s") (struct.loadF Server "commitSecret" "s") (![slice.T byteT] "plainPk") in
    let: "bound" := getBound (struct.loadF Server "keyMap" "s") "uid" (![uint64T] "numVers") (struct.loadF Server "vrfSk" "s") in
    RWMutex__RUnlock (struct.loadF Server "mu" "s");;
    ("dig", "hist", "isReg", "latest", "bound").

(* MembHideEncode from serde.out.go *)

Definition MembHideEncode: val :=
  rec: "MembHideEncode" "b0" "o" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (marshalutil.WriteSlice1D (![slice.T byteT] "b") (struct.loadF MembHide "LabelProof" "o"));;
    "b" <-[slice.T byteT] (marshalutil.WriteSlice1D (![slice.T byteT] "b") (struct.loadF MembHide "MapVal" "o"));;
    "b" <-[slice.T byteT] (marshalutil.WriteSlice1D (![slice.T byteT] "b") (struct.loadF MembHide "MerkleProof" "o"));;
    ![slice.T byteT] "b".

(* MembHideSlice1DEncode from serde_misc.go *)

Definition MembHideSlice1DEncode: val :=
  rec: "MembHideSlice1DEncode" "b0" "o" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (slice.len "o"));;
    ForSlice ptrT <> "e" "o"
      ("b" <-[slice.T byteT] (MembHideEncode (![slice.T byteT] "b") "e"));;
    ![slice.T byteT] "b".

(* ServerGetReplyEncode from serde.out.go *)

Definition ServerGetReplyEncode: val :=
  rec: "ServerGetReplyEncode" "b0" "o" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (SigDigEncode (![slice.T byteT] "b") (struct.loadF ServerGetReply "Dig" "o"));;
    "b" <-[slice.T byteT] (MembHideSlice1DEncode (![slice.T byteT] "b") (struct.loadF ServerGetReply "Hist" "o"));;
    "b" <-[slice.T byteT] (marshal.WriteBool (![slice.T byteT] "b") (struct.loadF ServerGetReply "IsReg" "o"));;
    "b" <-[slice.T byteT] (MembEncode (![slice.T byteT] "b") (struct.loadF ServerGetReply "Latest" "o"));;
    "b" <-[slice.T byteT] (NonMembEncode (![slice.T byteT] "b") (struct.loadF ServerGetReply "Bound" "o"));;
    ![slice.T byteT] "b".

Definition ServerSelfMonArgDecode: val :=
  rec: "ServerSelfMonArgDecode" "b0" :=
    let: (("a1", "b1"), "err1") := marshalutil.ReadInt "b0" in
    (if: "err1"
    then (slice.nil, slice.nil, #true)
    else
      (struct.new ServerSelfMonArg [
         "Uid" ::= "a1"
       ], "b1", #false)).

(* Server__SelfMon from server.go *)

Definition Server__SelfMon: val :=
  rec: "Server__SelfMon" "s" "uid" :=
    RWMutex__RLock (struct.loadF Server "mu" "s");;
    let: "user" := Fst (MapGet (struct.loadF Server "userInfo" "s") "uid") in
    let: "numVers" := ref (zero_val uint64T) in
    (if: "user" ≠ #null
    then "numVers" <-[uint64T] (struct.loadF userState "numVers" "user")
    else #());;
    let: "dig" := getDig (struct.loadF Server "epochHist" "s") in
    let: "bound" := getBound (struct.loadF Server "keyMap" "s") "uid" (![uint64T] "numVers") (struct.loadF Server "vrfSk" "s") in
    RWMutex__RUnlock (struct.loadF Server "mu" "s");;
    ("dig", "bound").

(* ServerSelfMonReplyEncode from serde.out.go *)

Definition ServerSelfMonReplyEncode: val :=
  rec: "ServerSelfMonReplyEncode" "b0" "o" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (SigDigEncode (![slice.T byteT] "b") (struct.loadF ServerSelfMonReply "Dig" "o"));;
    "b" <-[slice.T byteT] (NonMembEncode (![slice.T byteT] "b") (struct.loadF ServerSelfMonReply "Bound" "o"));;
    ![slice.T byteT] "b".

(* ServerAuditArg from serde.go *)

Definition ServerAuditArg := struct.decl [
  "Epoch" :: uint64T
].

(* ServerAuditArgDecode from serde.out.go *)

Definition ServerAuditArgDecode: val :=
  rec: "ServerAuditArgDecode" "b0" :=
    let: (("a1", "b1"), "err1") := marshalutil.ReadInt "b0" in
    (if: "err1"
    then (slice.nil, slice.nil, #true)
    else
      (struct.new ServerAuditArg [
         "Epoch" ::= "a1"
       ], "b1", #false)).

(* Server__Audit from server.go *)

(* Audit returns an err on fail. *)
Definition Server__Audit: val :=
  rec: "Server__Audit" "s" "epoch" :=
    RWMutex__RLock (struct.loadF Server "mu" "s");;
    (if: "epoch" ≥ (slice.len (struct.loadF Server "epochHist" "s"))
    then
      RWMutex__RUnlock (struct.loadF Server "mu" "s");;
      (struct.new UpdateProof [
         "Updates" ::= NewMap stringT (slice.T byteT) #()
       ], #true)
    else
      let: "info" := SliceGet ptrT (struct.loadF Server "epochHist" "s") "epoch" in
      RWMutex__RUnlock (struct.loadF Server "mu" "s");;
      (struct.new UpdateProof [
         "Updates" ::= struct.loadF servEpochInfo "updates" "info";
         "Sig" ::= struct.loadF servEpochInfo "sig" "info"
       ], #false)).

(* ServerAuditReply from serde.go *)

Definition ServerAuditReply := struct.decl [
  "P" :: ptrT;
  "Err" :: boolT
].

(* MapstringSlbyteEncode from serde_misc.go *)

Definition MapstringSlbyteEncode: val :=
  rec: "MapstringSlbyteEncode" "b0" "o" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (MapLen "o"));;
    MapIter "o" (λ: "k" "v",
      "b" <-[slice.T byteT] (marshalutil.WriteSlice1D (![slice.T byteT] "b") (StringToBytes "k"));;
      "b" <-[slice.T byteT] (marshalutil.WriteSlice1D (![slice.T byteT] "b") "v"));;
    ![slice.T byteT] "b".

(* UpdateProofEncode from serde.out.go *)

Definition UpdateProofEncode: val :=
  rec: "UpdateProofEncode" "b0" "o" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (MapstringSlbyteEncode (![slice.T byteT] "b") (struct.loadF UpdateProof "Updates" "o"));;
    "b" <-[slice.T byteT] (marshalutil.WriteSlice1D (![slice.T byteT] "b") (struct.loadF UpdateProof "Sig" "o"));;
    ![slice.T byteT] "b".

Definition ServerAuditReplyEncode: val :=
  rec: "ServerAuditReplyEncode" "b0" "o" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (UpdateProofEncode (![slice.T byteT] "b") (struct.loadF ServerAuditReply "P" "o"));;
    "b" <-[slice.T byteT] (marshal.WriteBool (![slice.T byteT] "b") (struct.loadF ServerAuditReply "Err" "o"));;
    ![slice.T byteT] "b".

Definition NewRpcServer: val :=
  rec: "NewRpcServer" "s" :=
    let: "h" := NewMap uint64T ((slice.T byteT) -> ptrT -> unitT)%ht #() in
    MapInsert "h" ServerPutRpc (λ: "arg" "reply",
      let: (("argObj", <>), "err0") := ServerPutArgDecode "arg" in
      (if: "err0"
      then #()
      else
        let: ((("ret0", "ret1"), "ret2"), "ret3") := Server__Put "s" (struct.loadF ServerPutArg "Uid" "argObj") (struct.loadF ServerPutArg "Pk" "argObj") in
        let: "replyObj" := struct.new ServerPutReply [
          "Dig" ::= "ret0";
          "Latest" ::= "ret1";
          "Bound" ::= "ret2";
          "Err" ::= "ret3"
        ] in
        "reply" <-[slice.T byteT] (ServerPutReplyEncode (![slice.T byteT] "reply") "replyObj");;
        #())
      );;
    MapInsert "h" ServerGetRpc (λ: "arg" "reply",
      let: (("argObj", <>), "err0") := ServerGetArgDecode "arg" in
      (if: "err0"
      then #()
      else
        let: (((("ret0", "ret1"), "ret2"), "ret3"), "ret4") := Server__Get "s" (struct.loadF ServerGetArg "Uid" "argObj") in
        let: "replyObj" := struct.new ServerGetReply [
          "Dig" ::= "ret0";
          "Hist" ::= "ret1";
          "IsReg" ::= "ret2";
          "Latest" ::= "ret3";
          "Bound" ::= "ret4"
        ] in
        "reply" <-[slice.T byteT] (ServerGetReplyEncode (![slice.T byteT] "reply") "replyObj");;
        #())
      );;
    MapInsert "h" ServerSelfMonRpc (λ: "arg" "reply",
      let: (("argObj", <>), "err0") := ServerSelfMonArgDecode "arg" in
      (if: "err0"
      then #()
      else
        let: ("ret0", "ret1") := Server__SelfMon "s" (struct.loadF ServerSelfMonArg "Uid" "argObj") in
        let: "replyObj" := struct.new ServerSelfMonReply [
          "Dig" ::= "ret0";
          "Bound" ::= "ret1"
        ] in
        "reply" <-[slice.T byteT] (ServerSelfMonReplyEncode (![slice.T byteT] "reply") "replyObj");;
        #())
      );;
    MapInsert "h" ServerAuditRpc (λ: "arg" "reply",
      let: (("argObj", <>), "err0") := ServerAuditArgDecode "arg" in
      (if: "err0"
      then #()
      else
        let: ("ret0", "ret1") := Server__Audit "s" (struct.loadF ServerAuditArg "Epoch" "argObj") in
        let: "replyObj" := struct.new ServerAuditReply [
          "P" ::= "ret0";
          "Err" ::= "ret1"
        ] in
        "reply" <-[slice.T byteT] (ServerAuditReplyEncode (![slice.T byteT] "reply") "replyObj");;
        #())
      );;
    advrpc.NewServer "h".

(* MapstringSlbyteDecode from serde_misc.go *)

Definition MapstringSlbyteDecode: val :=
  rec: "MapstringSlbyteDecode" "b0" :=
    let: (("length", "b1"), "err1") := marshalutil.ReadInt "b0" in
    (if: "err1"
    then (slice.nil, slice.nil, #true)
    else
      let: "loopO" := NewMap stringT (slice.T byteT) #() in
      let: "loopErr" := ref (zero_val boolT) in
      let: "loopB" := ref_to (slice.T byteT) "b1" in
      let: "i" := ref_to uint64T #0 in
      (for: (λ: <>, (![uint64T] "i") < "length"); (λ: <>, "i" <-[uint64T] ((![uint64T] "i") + #1)) := λ: <>,
        let: (("a2", "loopB1"), "err2") := marshalutil.ReadSlice1D (![slice.T byteT] "loopB") in
        "loopB" <-[slice.T byteT] "loopB1";;
        (if: "err2"
        then
          "loopErr" <-[boolT] #true;;
          Break
        else
          let: (("a3", "loopB2"), "err3") := marshalutil.ReadSlice1D (![slice.T byteT] "loopB") in
          "loopB" <-[slice.T byteT] "loopB2";;
          (if: "err3"
          then
            "loopErr" <-[boolT] #true;;
            Break
          else
            MapInsert "loopO" (StringFromBytes "a2") "a3";;
            Continue)));;
      (if: ![boolT] "loopErr"
      then (slice.nil, slice.nil, #true)
      else ("loopO", ![slice.T byteT] "loopB", #false))).

(* UpdateProofDecode from serde.out.go *)

Definition UpdateProofDecode: val :=
  rec: "UpdateProofDecode" "b0" :=
    let: (("a1", "b1"), "err1") := MapstringSlbyteDecode "b0" in
    (if: "err1"
    then (slice.nil, slice.nil, #true)
    else
      let: (("a2", "b2"), "err2") := marshalutil.ReadSlice1D "b1" in
      (if: "err2"
      then (slice.nil, slice.nil, #true)
      else
        (struct.new UpdateProof [
           "Updates" ::= "a1";
           "Sig" ::= "a2"
         ], "b2", #false))).

(* AdtrUpdateArg from serde.go *)

Definition AdtrUpdateArg := struct.decl [
  "P" :: ptrT
].

(* AdtrUpdateArgDecode from serde.out.go *)

Definition AdtrUpdateArgDecode: val :=
  rec: "AdtrUpdateArgDecode" "b0" :=
    let: (("a1", "b1"), "err1") := UpdateProofDecode "b0" in
    (if: "err1"
    then (slice.nil, slice.nil, #true)
    else
      (struct.new AdtrUpdateArg [
         "P" ::= "a1"
       ], "b1", #false)).

(* AdtrUpdateReply from serde.go *)

Definition AdtrUpdateReply := struct.decl [
  "Err" :: boolT
].

(* AdtrUpdateReplyEncode from serde.out.go *)

Definition AdtrUpdateReplyEncode: val :=
  rec: "AdtrUpdateReplyEncode" "b0" "o" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (marshal.WriteBool (![slice.T byteT] "b") (struct.loadF AdtrUpdateReply "Err" "o"));;
    ![slice.T byteT] "b".

Definition AdtrGetArgDecode: val :=
  rec: "AdtrGetArgDecode" "b0" :=
    let: (("a1", "b1"), "err1") := marshalutil.ReadInt "b0" in
    (if: "err1"
    then (slice.nil, slice.nil, #true)
    else
      (struct.new AdtrGetArg [
         "Epoch" ::= "a1"
       ], "b1", #false)).

Definition AdtrEpochInfoEncode: val :=
  rec: "AdtrEpochInfoEncode" "b0" "o" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (marshalutil.WriteSlice1D (![slice.T byteT] "b") (struct.loadF AdtrEpochInfo "Dig" "o"));;
    "b" <-[slice.T byteT] (marshalutil.WriteSlice1D (![slice.T byteT] "b") (struct.loadF AdtrEpochInfo "ServSig" "o"));;
    "b" <-[slice.T byteT] (marshalutil.WriteSlice1D (![slice.T byteT] "b") (struct.loadF AdtrEpochInfo "AdtrSig" "o"));;
    ![slice.T byteT] "b".

Definition AdtrGetReplyEncode: val :=
  rec: "AdtrGetReplyEncode" "b0" "o" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (AdtrEpochInfoEncode (![slice.T byteT] "b") (struct.loadF AdtrGetReply "X" "o"));;
    "b" <-[slice.T byteT] (marshal.WriteBool (![slice.T byteT] "b") (struct.loadF AdtrGetReply "Err" "o"));;
    ![slice.T byteT] "b".

Definition NewRpcAuditor: val :=
  rec: "NewRpcAuditor" "a" :=
    let: "h" := NewMap uint64T ((slice.T byteT) -> ptrT -> unitT)%ht #() in
    MapInsert "h" AdtrUpdateRpc (λ: "arg" "reply",
      let: (("argObj", <>), "err0") := AdtrUpdateArgDecode "arg" in
      (if: "err0"
      then #()
      else
        let: "ret0" := Auditor__Update "a" (struct.loadF AdtrUpdateArg "P" "argObj") in
        let: "replyObj" := struct.new AdtrUpdateReply [
          "Err" ::= "ret0"
        ] in
        "reply" <-[slice.T byteT] (AdtrUpdateReplyEncode (![slice.T byteT] "reply") "replyObj");;
        #())
      );;
    MapInsert "h" AdtrGetRpc (λ: "arg" "reply",
      let: (("argObj", <>), "err0") := AdtrGetArgDecode "arg" in
      (if: "err0"
      then #()
      else
        let: ("ret0", "ret1") := Auditor__Get "a" (struct.loadF AdtrGetArg "Epoch" "argObj") in
        let: "replyObj" := struct.new AdtrGetReply [
          "X" ::= "ret0";
          "Err" ::= "ret1"
        ] in
        "reply" <-[slice.T byteT] (AdtrGetReplyEncode (![slice.T byteT] "reply") "replyObj");;
        #())
      );;
    advrpc.NewServer "h".

Definition ServerAuditArgEncode: val :=
  rec: "ServerAuditArgEncode" "b0" "o" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (struct.loadF ServerAuditArg "Epoch" "o"));;
    ![slice.T byteT] "b".

Definition ServerAuditReplyDecode: val :=
  rec: "ServerAuditReplyDecode" "b0" :=
    let: (("a1", "b1"), "err1") := UpdateProofDecode "b0" in
    (if: "err1"
    then (slice.nil, slice.nil, #true)
    else
      let: (("a2", "b2"), "err2") := marshalutil.ReadBool "b1" in
      (if: "err2"
      then (slice.nil, slice.nil, #true)
      else
        (struct.new ServerAuditReply [
           "P" ::= "a1";
           "Err" ::= "a2"
         ], "b2", #false))).

Definition CallServAudit: val :=
  rec: "CallServAudit" "c" "epoch" :=
    let: "arg" := struct.new ServerAuditArg [
      "Epoch" ::= "epoch"
    ] in
    let: "argByt" := ServerAuditArgEncode (NewSlice byteT #0) "arg" in
    let: "replyByt" := ref (zero_val (slice.T byteT)) in
    let: "err0" := advrpc.Client__Call "c" ServerAuditRpc "argByt" "replyByt" in
    (if: "err0"
    then (slice.nil, #true)
    else
      let: (("reply", <>), "err1") := ServerAuditReplyDecode (![slice.T byteT] "replyByt") in
      (if: "err1"
      then (slice.nil, #true)
      else (struct.loadF ServerAuditReply "P" "reply", struct.loadF ServerAuditReply "Err" "reply"))).

Definition AdtrUpdateArgEncode: val :=
  rec: "AdtrUpdateArgEncode" "b0" "o" :=
    let: "b" := ref_to (slice.T byteT) "b0" in
    "b" <-[slice.T byteT] (UpdateProofEncode (![slice.T byteT] "b") (struct.loadF AdtrUpdateArg "P" "o"));;
    ![slice.T byteT] "b".

Definition AdtrUpdateReplyDecode: val :=
  rec: "AdtrUpdateReplyDecode" "b0" :=
    let: (("a1", "b1"), "err1") := marshalutil.ReadBool "b0" in
    (if: "err1"
    then (slice.nil, slice.nil, #true)
    else
      (struct.new AdtrUpdateReply [
         "Err" ::= "a1"
       ], "b1", #false)).

Definition CallAdtrUpdate: val :=
  rec: "CallAdtrUpdate" "c" "proof" :=
    let: "arg" := struct.new AdtrUpdateArg [
      "P" ::= "proof"
    ] in
    let: "argByt" := AdtrUpdateArgEncode (NewSlice byteT #0) "arg" in
    let: "replyByt" := ref (zero_val (slice.T byteT)) in
    let: "err0" := advrpc.Client__Call "c" AdtrUpdateRpc "argByt" "replyByt" in
    (if: "err0"
    then #true
    else
      let: (("reply", <>), "err1") := AdtrUpdateReplyDecode (![slice.T byteT] "replyByt") in
      (if: "err1"
      then #true
      else struct.loadF AdtrUpdateReply "Err" "reply")).

(* serde.go *)

(* serde.out.go *)

(* Auto-generated from spec "github.com/mit-pdos/pav/kt/serde.go"
   using compiler "github.com/mit-pdos/pav/serde". *)

Definition PreSigDigDecode: val :=
  rec: "PreSigDigDecode" "b0" :=
    let: (("a1", "b1"), "err1") := marshalutil.ReadInt "b0" in
    (if: "err1"
    then (slice.nil, slice.nil, #true)
    else
      let: (("a2", "b2"), "err2") := marshalutil.ReadSlice1D "b1" in
      (if: "err2"
      then (slice.nil, slice.nil, #true)
      else
        (struct.new PreSigDig [
           "Epoch" ::= "a1";
           "Dig" ::= "a2"
         ], "b2", #false))).

Definition MapLabelPreDecode: val :=
  rec: "MapLabelPreDecode" "b0" :=
    let: (("a1", "b1"), "err1") := marshalutil.ReadInt "b0" in
    (if: "err1"
    then (slice.nil, slice.nil, #true)
    else
      let: (("a2", "b2"), "err2") := marshalutil.ReadInt "b1" in
      (if: "err2"
      then (slice.nil, slice.nil, #true)
      else
        (struct.new MapLabelPre [
           "Uid" ::= "a1";
           "Ver" ::= "a2"
         ], "b2", #false))).

(* serde_misc.go *)

(* server.go *)

Definition mapper0Out := struct.decl [
  "latestVrfHash" :: slice.T byteT;
  "latestVrfProof" :: slice.T byteT;
  "boundVrfHash" :: slice.T byteT;
  "boundVrfProof" :: slice.T byteT;
  "mapVal" :: slice.T byteT;
  "pkOpen" :: ptrT
].

(* WorkQ__Get from workq.go *)

Definition WorkQ__Get: val :=
  rec: "WorkQ__Get" "wq" :=
    Mutex__Lock (struct.loadF WorkQ "mu" "wq");;
    Skip;;
    (for: (λ: <>, (struct.loadF WorkQ "work" "wq") = slice.nil); (λ: <>, Skip) := λ: <>,
      Cond__Wait (struct.loadF WorkQ "condWorker" "wq");;
      Continue);;
    let: "work" := struct.loadF WorkQ "work" "wq" in
    struct.storeF WorkQ "work" "wq" slice.nil;;
    Mutex__Unlock (struct.loadF WorkQ "mu" "wq");;
    "work".

(* Server__mapper0 from server.go *)

(* mapper0 makes mapLabels and mapVals. *)
Definition Server__mapper0: val :=
  rec: "Server__mapper0" "s" "in" "out" :=
    let: "user" := Fst (MapGet (struct.loadF Server "userInfo" "s") (struct.loadF WQReq "Uid" "in")) in
    let: "numVers" := ref (zero_val uint64T) in
    (if: "user" ≠ #null
    then "numVers" <-[uint64T] (struct.loadF userState "numVers" "user")
    else #());;
    let: ("latHash", "latProof") := compMapLabel (struct.loadF WQReq "Uid" "in") (![uint64T] "numVers") (struct.loadF Server "vrfSk" "s") in
    let: ("boundHash", "boundProof") := compMapLabel (struct.loadF WQReq "Uid" "in") ((![uint64T] "numVers") + #1) (struct.loadF Server "vrfSk" "s") in
    let: "nextEpoch" := slice.len (struct.loadF Server "epochHist" "s") in
    let: "r" := compCommitOpen (struct.loadF Server "commitSecret" "s") "latHash" in
    let: "open" := struct.new CommitOpen [
      "Val" ::= struct.loadF WQReq "Pk" "in";
      "Rand" ::= "r"
    ] in
    let: "mapVal" := compMapVal "nextEpoch" "open" in
    struct.storeF mapper0Out "latestVrfHash" "out" "latHash";;
    struct.storeF mapper0Out "latestVrfProof" "out" "latProof";;
    struct.storeF mapper0Out "boundVrfHash" "out" "boundHash";;
    struct.storeF mapper0Out "boundVrfProof" "out" "boundProof";;
    struct.storeF mapper0Out "mapVal" "out" "mapVal";;
    struct.storeF mapper0Out "pkOpen" "out" "open";;
    #().

(* updEpochHist does a signed history update with some new entries. *)
Definition updEpochHist: val :=
  rec: "updEpochHist" "hist" "upd" "dig" "sk" :=
    let: "epoch" := slice.len (![slice.T ptrT] "hist") in
    let: "preSig" := struct.new PreSigDig [
      "Epoch" ::= "epoch";
      "Dig" ::= "dig"
    ] in
    let: "preSigByt" := PreSigDigEncode (NewSliceWithCap byteT #0 ((#8 + #8) + cryptoffi.HashLen)) "preSig" in
    let: "sig" := cryptoffi.SigPrivateKey__Sign "sk" "preSigByt" in
    let: "newInfo" := struct.new servEpochInfo [
      "updates" ::= "upd";
      "dig" ::= "dig";
      "sig" ::= "sig"
    ] in
    "hist" <-[slice.T ptrT] (SliceAppend ptrT (![slice.T ptrT] "hist") "newInfo");;
    #().

(* mapper1 computes merkle proofs and assembles full response. *)
Definition Server__mapper1: val :=
  rec: "Server__mapper1" "s" "in" "out" :=
    let: (("latIn", <>), "latMerk") := merkle.Tree__Prove (struct.loadF Server "keyMap" "s") (struct.loadF mapper0Out "latestVrfHash" "in") in
    std.Assert "latIn";;
    let: (("boundIn", <>), "boundMerk") := merkle.Tree__Prove (struct.loadF Server "keyMap" "s") (struct.loadF mapper0Out "boundVrfHash" "in") in
    std.Assert (~ "boundIn");;
    struct.storeF WQResp "Dig" "out" (getDig (struct.loadF Server "epochHist" "s"));;
    struct.storeF WQResp "Lat" "out" (struct.new Memb [
      "LabelProof" ::= struct.loadF mapper0Out "latestVrfProof" "in";
      "EpochAdded" ::= (slice.len (struct.loadF Server "epochHist" "s")) - #1;
      "PkOpen" ::= struct.loadF mapper0Out "pkOpen" "in";
      "MerkleProof" ::= "latMerk"
    ]);;
    struct.storeF WQResp "Bound" "out" (struct.new NonMemb [
      "LabelProof" ::= struct.loadF mapper0Out "boundVrfProof" "in";
      "MerkleProof" ::= "boundMerk"
    ]);;
    #().

(* WorkQ__Finish from workq.go *)

Definition WorkQ__Finish: val :=
  rec: "WorkQ__Finish" "wq" "work" :=
    Mutex__Lock (struct.loadF WorkQ "mu" "wq");;
    ForSlice ptrT <> "x" "work"
      (struct.storeF Work "done" "x" #true);;
    Mutex__Unlock (struct.loadF WorkQ "mu" "wq");;
    Cond__Broadcast (struct.loadF WorkQ "condCli" "wq");;
    #().

Definition Server__Worker: val :=
  rec: "Server__Worker" "s" :=
    let: "work" := WorkQ__Get (struct.loadF Server "workQ" "s") in
    let: "uidSet" := NewMap uint64T boolT #() in
    ForSlice ptrT <> "w" "work"
      (struct.storeF Work "Resp" "w" (struct.new WQResp [
      ]);;
      let: "uid" := struct.loadF WQReq "Uid" (struct.loadF Work "Req" "w") in
      let: (<>, "ok") := MapGet "uidSet" "uid" in
      (if: "ok"
      then
        struct.storeF WQResp "Err" (struct.loadF Work "Resp" "w") #true;;
        struct.storeF WQResp "Lat" (struct.loadF Work "Resp" "w") (struct.new Memb [
          "PkOpen" ::= struct.new CommitOpen [
          ]
        ]);;
        struct.storeF WQResp "Bound" (struct.loadF Work "Resp" "w") (struct.new NonMemb [
        ])
      else MapInsert "uidSet" "uid" #false));;
    let: "outs0" := NewSlice ptrT (slice.len "work") in
    let: "wg" := ref_to ptrT (waitgroup.New #()) in
    let: "i" := ref (zero_val uint64T) in
    Skip;;
    (for: (λ: <>, (![uint64T] "i") < (slice.len "work")); (λ: <>, "i" <-[uint64T] ((![uint64T] "i") + #1)) := λ: <>,
      let: "resp" := struct.loadF Work "Resp" (SliceGet ptrT "work" (![uint64T] "i")) in
      (if: (~ (struct.loadF WQResp "Err" "resp"))
      then
        let: "req" := struct.loadF Work "Req" (SliceGet ptrT "work" (![uint64T] "i")) in
        let: "out0" := struct.new mapper0Out [
        ] in
        SliceSet ptrT "outs0" (![uint64T] "i") "out0";;
        waitgroup.Add (![ptrT] "wg") #1;;
        Fork (Server__mapper0 "s" "req" "out0";;
              waitgroup.Done (![ptrT] "wg"));;
        Continue
      else Continue));;
    waitgroup.Wait (![ptrT] "wg");;
    RWMutex__Lock (struct.loadF Server "mu" "s");;
    let: "upd" := NewMap stringT (slice.T byteT) #() in
    "i" <-[uint64T] #0;;
    Skip;;
    (for: (λ: <>, (![uint64T] "i") < (slice.len "work")); (λ: <>, "i" <-[uint64T] ((![uint64T] "i") + #1)) := λ: <>,
      let: "resp" := struct.loadF Work "Resp" (SliceGet ptrT "work" (![uint64T] "i")) in
      (if: (~ (struct.loadF WQResp "Err" "resp"))
      then
        let: "req" := struct.loadF Work "Req" (SliceGet ptrT "work" (![uint64T] "i")) in
        let: "out0" := SliceGet ptrT "outs0" (![uint64T] "i") in
        let: "label" := struct.loadF mapper0Out "latestVrfHash" "out0" in
        let: "err0" := merkle.Tree__Put (struct.loadF Server "keyMap" "s") "label" (struct.loadF mapper0Out "mapVal" "out0") in
        std.Assert (~ "err0");;
        MapInsert "upd" (StringFromBytes "label") (struct.loadF mapper0Out "mapVal" "out0");;
        let: "user" := ref_to ptrT (Fst (MapGet (struct.loadF Server "userInfo" "s") (struct.loadF WQReq "Uid" "req"))) in
        (if: (![ptrT] "user") = #null
        then
          "user" <-[ptrT] (struct.new userState [
          ])
        else #());;
        struct.storeF userState "numVers" (![ptrT] "user") ((struct.loadF userState "numVers" (![ptrT] "user")) + #1);;
        struct.storeF userState "plainPk" (![ptrT] "user") (struct.loadF WQReq "Pk" "req");;
        MapInsert (struct.loadF Server "userInfo" "s") (struct.loadF WQReq "Uid" "req") (![ptrT] "user");;
        Continue
      else Continue));;
    updEpochHist (struct.fieldRef Server "epochHist" "s") "upd" (merkle.Tree__Digest (struct.loadF Server "keyMap" "s")) (struct.loadF Server "sigSk" "s");;
    RWMutex__Unlock (struct.loadF Server "mu" "s");;
    "wg" <-[ptrT] (waitgroup.New #());;
    "i" <-[uint64T] #0;;
    Skip;;
    (for: (λ: <>, (![uint64T] "i") < (slice.len "work")); (λ: <>, "i" <-[uint64T] ((![uint64T] "i") + #1)) := λ: <>,
      let: "resp" := struct.loadF Work "Resp" (SliceGet ptrT "work" (![uint64T] "i")) in
      (if: (~ (struct.loadF WQResp "Err" "resp"))
      then
        let: "out0" := SliceGet ptrT "outs0" (![uint64T] "i") in
        waitgroup.Add (![ptrT] "wg") #1;;
        Fork (Server__mapper1 "s" "out0" "resp";;
              waitgroup.Done (![ptrT] "wg"));;
        Continue
      else Continue));;
    waitgroup.Wait (![ptrT] "wg");;
    WorkQ__Finish (struct.loadF Server "workQ" "s") "work";;
    #().

Definition NewWorkQ: val :=
  rec: "NewWorkQ" <> :=
    let: "mu" := newMutex #() in
    let: "condCli" := NewCond "mu" in
    let: "condWork" := NewCond "mu" in
    struct.new WorkQ [
      "mu" ::= "mu";
      "condCli" ::= "condCli";
      "condWorker" ::= "condWork"
    ].

Definition NewServer: val :=
  rec: "NewServer" <> :=
    let: "mu" := newRWMutex #() in
    let: ("sigPk", "sigSk") := cryptoffi.SigGenerateKey #() in
    let: ("vrfPk", "vrfSk") := cryptoffi.VrfGenerateKey #() in
    let: "sec" := cryptoffi.RandBytes cryptoffi.HashLen in
    let: "keys" := merkle.NewTree #() in
    let: "users" := NewMap uint64T ptrT #() in
    let: "hist" := ref (zero_val (slice.T ptrT)) in
    updEpochHist "hist" (NewMap stringT (slice.T byteT) #()) (merkle.Tree__Digest "keys") "sigSk";;
    let: "wq" := NewWorkQ #() in
    let: "s" := struct.new Server [
      "mu" ::= "mu";
      "sigSk" ::= "sigSk";
      "vrfSk" ::= "vrfSk";
      "commitSecret" ::= "sec";
      "keyMap" ::= "keys";
      "userInfo" ::= "users";
      "epochHist" ::= ![slice.T ptrT] "hist";
      "workQ" ::= "wq"
    ] in
    Fork (Skip;;
          (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
            Server__Worker "s";;
            Continue));;
    ("s", "sigPk", "vrfPk").

(* workq.go *)

(* DoBatch is unverified. it's only used as a benchmark helper for
   unmeasured batch puts. *)
Definition WorkQ__DoBatch: val :=
  rec: "WorkQ__DoBatch" "wq" "r" :=
    Mutex__Lock (struct.loadF WorkQ "mu" "wq");;
    struct.storeF WorkQ "work" "wq" (SliceAppendSlice ptrT (struct.loadF WorkQ "work" "wq") "r");;
    Cond__Signal (struct.loadF WorkQ "condWorker" "wq");;
    let: "rLen" := slice.len "r" in
    Skip;;
    (for: (λ: <>, (~ (struct.loadF Work "done" (SliceGet ptrT "r" ("rLen" - #1))))); (λ: <>, Skip) := λ: <>,
      Cond__Wait (struct.loadF WorkQ "condCli" "wq");;
      Continue);;
    Mutex__Unlock (struct.loadF WorkQ "mu" "wq");;
    #().

End code.
