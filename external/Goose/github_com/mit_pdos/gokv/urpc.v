(* autogenerated from github.com/mit-pdos/gokv/urpc *)
From Perennial.goose_lang Require Import prelude.
From Goose Require github_com.goose_lang.std.
From Goose Require github_com.tchajed.marshal.

From Perennial.goose_lang Require Import ffi.grove_prelude.

Definition Server := struct.decl [
  "handlers" :: mapT ((slice.T byteT) -> ptrT -> unitT)%ht
].

Definition Server__rpcHandle: val :=
  rec: "Server__rpcHandle" "srv" "conn" "rpcid" "seqno" "data" :=
    let: "replyData" := ref (zero_val (slice.T byteT)) in
    let: "f" := Fst (MapGet (struct.loadF Server "handlers" "srv") "rpcid") in
    "f" "data" "replyData";;
    let: "data1" := NewSliceWithCap byteT #0 (#8 + (slice.len (![slice.T byteT] "replyData"))) in
    let: "data2" := marshal.WriteInt "data1" "seqno" in
    let: "data3" := marshal.WriteBytes "data2" (![slice.T byteT] "replyData") in
    grove_ffi.Send "conn" "data3";;
    #().

Definition MakeServer: val :=
  rec: "MakeServer" "handlers" :=
    struct.new Server [
      "handlers" ::= "handlers"
    ].

Definition Server__readThread: val :=
  rec: "Server__readThread" "srv" "conn" :=
    Skip;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "r" := grove_ffi.Receive "conn" in
      (if: struct.get grove_ffi.ReceiveRet "Err" "r"
      then Break
      else
        let: "data" := struct.get grove_ffi.ReceiveRet "Data" "r" in
        let: ("rpcid", "data") := marshal.ReadInt "data" in
        let: ("seqno", "data") := marshal.ReadInt "data" in
        let: "req" := "data" in
        Fork (Server__rpcHandle "srv" "conn" "rpcid" "seqno" "req");;
        Continue));;
    #().

Definition Server__Serve: val :=
  rec: "Server__Serve" "srv" "host" :=
    let: "listener" := grove_ffi.Listen "host" in
    Fork (Skip;;
          (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
            let: "conn" := grove_ffi.Accept "listener" in
            Fork (Server__readThread "srv" "conn");;
            Continue));;
    #().

Definition callbackStateWaiting : expr := #0.

Definition callbackStateDone : expr := #1.

Definition callbackStateAborted : expr := #2.

Definition Callback := struct.decl [
  "reply" :: ptrT;
  "state" :: ptrT;
  "cond" :: ptrT
].

Definition Client := struct.decl [
  "mu" :: ptrT;
  "conn" :: grove_ffi.Connection;
  "seq" :: uint64T;
  "pending" :: mapT ptrT
].

Definition Client__replyThread: val :=
  rec: "Client__replyThread" "cl" :=
    Skip;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "r" := grove_ffi.Receive (struct.loadF Client "conn" "cl") in
      (if: struct.get grove_ffi.ReceiveRet "Err" "r"
      then
        lock.acquire (struct.loadF Client "mu" "cl");;
        MapIter (struct.loadF Client "pending" "cl") (λ: <> "cb",
          (struct.loadF Callback "state" "cb") <-[uint64T] callbackStateAborted;;
          lock.condSignal (struct.loadF Callback "cond" "cb"));;
        lock.release (struct.loadF Client "mu" "cl");;
        Break
      else
        let: "data" := struct.get grove_ffi.ReceiveRet "Data" "r" in
        let: ("seqno", "data") := marshal.ReadInt "data" in
        let: "reply" := "data" in
        lock.acquire (struct.loadF Client "mu" "cl");;
        let: ("cb", "ok") := MapGet (struct.loadF Client "pending" "cl") "seqno" in
        (if: "ok"
        then
          MapDelete (struct.loadF Client "pending" "cl") "seqno";;
          (struct.loadF Callback "reply" "cb") <-[slice.T byteT] "reply";;
          (struct.loadF Callback "state" "cb") <-[uint64T] callbackStateDone;;
          lock.condSignal (struct.loadF Callback "cond" "cb")
        else #());;
        lock.release (struct.loadF Client "mu" "cl");;
        Continue));;
    #().

Definition TryMakeClient: val :=
  rec: "TryMakeClient" "host_name" :=
    let: "host" := "host_name" in
    let: "a" := grove_ffi.Connect "host" in
    let: "nilClient" := ref (zero_val ptrT) in
    (if: struct.get grove_ffi.ConnectRet "Err" "a"
    then (#1, ![ptrT] "nilClient")
    else
      let: "cl" := struct.new Client [
        "conn" ::= struct.get grove_ffi.ConnectRet "Connection" "a";
        "mu" ::= lock.new #();
        "seq" ::= #1;
        "pending" ::= NewMap uint64T ptrT #()
      ] in
      Fork (Client__replyThread "cl");;
      (#0, "cl")).

Definition MakeClient: val :=
  rec: "MakeClient" "host_name" :=
    let: ("err", "cl") := TryMakeClient "host_name" in
    (if: "err" ≠ #0
    then
      (* log.Printf("Unable to connect to %s", grove_ffi.AddressToStr(host_name)) *)
      #()
    else #());;
    control.impl.Assume ("err" = #0);;
    "cl".

Notation Error := uint64T (only parsing).

Definition ErrNone : expr := #0.

Definition ErrTimeout : expr := #1.

Definition ErrDisconnect : expr := #2.

Definition Client__CallStart: val :=
  rec: "Client__CallStart" "cl" "rpcid" "args" :=
    let: "reply_buf" := ref (zero_val (slice.T byteT)) in
    let: "cb" := struct.new Callback [
      "reply" ::= "reply_buf";
      "state" ::= ref (zero_val uint64T);
      "cond" ::= lock.newCond (struct.loadF Client "mu" "cl")
    ] in
    (struct.loadF Callback "state" "cb") <-[uint64T] callbackStateWaiting;;
    lock.acquire (struct.loadF Client "mu" "cl");;
    let: "seqno" := struct.loadF Client "seq" "cl" in
    struct.storeF Client "seq" "cl" (std.SumAssumeNoOverflow (struct.loadF Client "seq" "cl") #1);;
    MapInsert (struct.loadF Client "pending" "cl") "seqno" "cb";;
    lock.release (struct.loadF Client "mu" "cl");;
    let: "data1" := NewSliceWithCap byteT #0 ((#8 + #8) + (slice.len "args")) in
    let: "data2" := marshal.WriteInt "data1" "rpcid" in
    let: "data3" := marshal.WriteInt "data2" "seqno" in
    let: "reqData" := marshal.WriteBytes "data3" "args" in
    (if: grove_ffi.Send (struct.loadF Client "conn" "cl") "reqData"
    then
      (struct.new Callback [
       ], ErrDisconnect)
    else ("cb", ErrNone)).

Definition Client__CallComplete: val :=
  rec: "Client__CallComplete" "cl" "cb" "reply" "timeout_ms" :=
    lock.acquire (struct.loadF Client "mu" "cl");;
    (if: (![uint64T] (struct.loadF Callback "state" "cb")) = callbackStateWaiting
    then lock.condWaitTimeout (struct.loadF Callback "cond" "cb") "timeout_ms"
    else #());;
    let: "state" := ![uint64T] (struct.loadF Callback "state" "cb") in
    (if: "state" = callbackStateDone
    then
      "reply" <-[slice.T byteT] (![slice.T byteT] (struct.loadF Callback "reply" "cb"));;
      lock.release (struct.loadF Client "mu" "cl");;
      #0
    else
      lock.release (struct.loadF Client "mu" "cl");;
      (if: "state" = callbackStateAborted
      then ErrDisconnect
      else ErrTimeout)).

Definition Client__Call: val :=
  rec: "Client__Call" "cl" "rpcid" "args" "reply" "timeout_ms" :=
    let: ("cb", "err") := Client__CallStart "cl" "rpcid" "args" in
    (if: "err" ≠ #0
    then "err"
    else Client__CallComplete "cl" "cb" "reply" "timeout_ms").
