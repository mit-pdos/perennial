(* autogenerated from github.com/mit-pdos/gokv/vrsm/paxos *)
From Perennial.goose_lang Require Import prelude.
From Goose Require ..sync.
From Goose Require github_com.goose_lang.std.
From Goose Require github_com.mit_pdos.gokv.asyncfile.
From Goose Require github_com.mit_pdos.gokv.reconnectclient.
From Goose Require github_com.mit_pdos.gokv.urpc.
From Goose Require github_com.tchajed.marshal.

From Perennial.goose_lang Require Import ffi.grove_prelude.

(* 0_marshal.go *)

Definition Error: ty := uint64T.

Definition ENone : expr := #0.

Definition EEpochStale : expr := #1.

Definition EOutOfOrder : expr := #2.

Definition ETimeout : expr := #3.

Definition ENotLeader : expr := #4.

Definition applyAsFollowerArgs := struct.decl [
  "epoch" :: uint64T;
  "nextIndex" :: uint64T;
  "state" :: slice.T byteT
].

Definition encodeApplyAsFollowerArgs: val :=
  rec: "encodeApplyAsFollowerArgs" "o" :=
    let: "enc" := ref_to (slice.T byteT) (NewSliceWithCap byteT #0 ((#8 + #8) + (slice.len (struct.loadF applyAsFollowerArgs "state" "o")))) in
    "enc" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "enc") (struct.loadF applyAsFollowerArgs "epoch" "o"));;
    "enc" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "enc") (struct.loadF applyAsFollowerArgs "nextIndex" "o"));;
    "enc" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "enc") (struct.loadF applyAsFollowerArgs "state" "o"));;
    ![slice.T byteT] "enc".

Definition decodeApplyAsFollowerArgs: val :=
  rec: "decodeApplyAsFollowerArgs" "s" :=
    let: "enc" := ref_to (slice.T byteT) "s" in
    let: "o" := struct.alloc applyAsFollowerArgs (zero_val (struct.t applyAsFollowerArgs)) in
    let: ("0_ret", "1_ret") := marshal.ReadInt (![slice.T byteT] "enc") in
    struct.storeF applyAsFollowerArgs "epoch" "o" "0_ret";;
    "enc" <-[slice.T byteT] "1_ret";;
    let: ("0_ret", "1_ret") := marshal.ReadInt (![slice.T byteT] "enc") in
    struct.storeF applyAsFollowerArgs "nextIndex" "o" "0_ret";;
    "enc" <-[slice.T byteT] "1_ret";;
    struct.storeF applyAsFollowerArgs "state" "o" (![slice.T byteT] "enc");;
    "o".

Definition applyAsFollowerReply := struct.decl [
  "err" :: Error
].

Definition decodeApplyAsFollowerReply: val :=
  rec: "decodeApplyAsFollowerReply" "s" :=
    let: "o" := struct.alloc applyAsFollowerReply (zero_val (struct.t applyAsFollowerReply)) in
    let: ("err", <>) := marshal.ReadInt "s" in
    struct.storeF applyAsFollowerReply "err" "o" "err";;
    "o".

Definition encodeApplyAsFollowerReply: val :=
  rec: "encodeApplyAsFollowerReply" "o" :=
    let: "enc" := ref_to (slice.T byteT) (NewSliceWithCap byteT #0 #8) in
    "enc" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "enc") (struct.loadF applyAsFollowerReply "err" "o"));;
    ![slice.T byteT] "enc".

Definition enterNewEpochArgs := struct.decl [
  "epoch" :: uint64T
].

Definition encodeEnterNewEpochArgs: val :=
  rec: "encodeEnterNewEpochArgs" "o" :=
    let: "enc" := ref_to (slice.T byteT) (NewSliceWithCap byteT #0 #8) in
    "enc" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "enc") (struct.loadF enterNewEpochArgs "epoch" "o"));;
    ![slice.T byteT] "enc".

Definition decodeEnterNewEpochArgs: val :=
  rec: "decodeEnterNewEpochArgs" "s" :=
    let: "o" := struct.alloc enterNewEpochArgs (zero_val (struct.t enterNewEpochArgs)) in
    let: ("0_ret", "1_ret") := marshal.ReadInt "s" in
    struct.storeF enterNewEpochArgs "epoch" "o" "0_ret";;
    "1_ret";;
    "o".

Definition enterNewEpochReply := struct.decl [
  "err" :: Error;
  "acceptedEpoch" :: uint64T;
  "nextIndex" :: uint64T;
  "state" :: slice.T byteT
].

Definition decodeEnterNewEpochReply: val :=
  rec: "decodeEnterNewEpochReply" "s" :=
    let: "o" := struct.alloc enterNewEpochReply (zero_val (struct.t enterNewEpochReply)) in
    let: "enc" := ref_to (slice.T byteT) "s" in
    let: "err" := ref (zero_val uint64T) in
    let: ("0_ret", "1_ret") := marshal.ReadInt (![slice.T byteT] "enc") in
    "err" <-[uint64T] "0_ret";;
    "enc" <-[slice.T byteT] "1_ret";;
    struct.storeF enterNewEpochReply "err" "o" (![uint64T] "err");;
    let: ("0_ret", "1_ret") := marshal.ReadInt (![slice.T byteT] "enc") in
    struct.storeF enterNewEpochReply "acceptedEpoch" "o" "0_ret";;
    "enc" <-[slice.T byteT] "1_ret";;
    let: ("0_ret", "1_ret") := marshal.ReadInt (![slice.T byteT] "enc") in
    struct.storeF enterNewEpochReply "nextIndex" "o" "0_ret";;
    "enc" <-[slice.T byteT] "1_ret";;
    struct.storeF enterNewEpochReply "state" "o" (![slice.T byteT] "enc");;
    "o".

Definition encodeEnterNewEpochReply: val :=
  rec: "encodeEnterNewEpochReply" "o" :=
    let: "enc" := ref_to (slice.T byteT) (NewSliceWithCap byteT #0 (((#8 + #8) + #8) + (slice.len (struct.loadF enterNewEpochReply "state" "o")))) in
    "enc" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "enc") (struct.loadF enterNewEpochReply "err" "o"));;
    "enc" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "enc") (struct.loadF enterNewEpochReply "acceptedEpoch" "o"));;
    "enc" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "enc") (struct.loadF enterNewEpochReply "nextIndex" "o"));;
    "enc" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "enc") (struct.loadF enterNewEpochReply "state" "o"));;
    ![slice.T byteT] "enc".

Definition applyReply := struct.decl [
  "err" :: Error;
  "ret" :: slice.T byteT
].

Definition encodeApplyReply: val :=
  rec: "encodeApplyReply" "o" :=
    let: "enc" := ref_to (slice.T byteT) (NewSliceWithCap byteT #0 (#8 + (slice.len (struct.loadF applyReply "ret" "o")))) in
    "enc" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "enc") (struct.loadF applyReply "err" "o"));;
    "enc" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "enc") (struct.loadF applyReply "ret" "o"));;
    ![slice.T byteT] "enc".

Definition decodeApplyReply: val :=
  rec: "decodeApplyReply" "s" :=
    let: "enc" := ref_to (slice.T byteT) "s" in
    let: "o" := struct.alloc applyReply (zero_val (struct.t applyReply)) in
    let: "err" := ref (zero_val uint64T) in
    let: ("0_ret", "1_ret") := marshal.ReadInt (![slice.T byteT] "enc") in
    "err" <-[uint64T] "0_ret";;
    "enc" <-[slice.T byteT] "1_ret";;
    struct.storeF applyReply "err" "o" (![uint64T] "err");;
    struct.storeF applyReply "ret" "o" (![slice.T byteT] "enc");;
    "o".

Definition boolToU64: val :=
  rec: "boolToU64" "b" :=
    (if: "b"
    then #1
    else #0).

(* paxosState from server.go *)

Definition paxosState := struct.decl [
  "epoch" :: uint64T;
  "acceptedEpoch" :: uint64T;
  "nextIndex" :: uint64T;
  "state" :: slice.T byteT;
  "isLeader" :: boolT
].

Definition encodePaxosState: val :=
  rec: "encodePaxosState" "ps" :=
    let: "e" := ref_to (slice.T byteT) (NewSlice byteT #0) in
    "e" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "e") (struct.loadF paxosState "epoch" "ps"));;
    "e" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "e") (struct.loadF paxosState "acceptedEpoch" "ps"));;
    "e" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "e") (struct.loadF paxosState "nextIndex" "ps"));;
    "e" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "e") (boolToU64 (struct.loadF paxosState "isLeader" "ps")));;
    "e" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "e") (struct.loadF paxosState "state" "ps"));;
    ![slice.T byteT] "e".

Definition decodePaxosState: val :=
  rec: "decodePaxosState" "enc" :=
    let: "e" := ref_to (slice.T byteT) "enc" in
    let: "leaderInt" := ref (zero_val uint64T) in
    let: "ps" := struct.alloc paxosState (zero_val (struct.t paxosState)) in
    let: ("0_ret", "1_ret") := marshal.ReadInt (![slice.T byteT] "e") in
    struct.storeF paxosState "epoch" "ps" "0_ret";;
    "e" <-[slice.T byteT] "1_ret";;
    let: ("0_ret", "1_ret") := marshal.ReadInt (![slice.T byteT] "e") in
    struct.storeF paxosState "acceptedEpoch" "ps" "0_ret";;
    "e" <-[slice.T byteT] "1_ret";;
    let: ("0_ret", "1_ret") := marshal.ReadInt (![slice.T byteT] "e") in
    struct.storeF paxosState "nextIndex" "ps" "0_ret";;
    "e" <-[slice.T byteT] "1_ret";;
    let: ("0_ret", "1_ret") := marshal.ReadInt (![slice.T byteT] "e") in
    "leaderInt" <-[uint64T] "0_ret";;
    struct.storeF paxosState "state" "ps" "1_ret";;
    struct.storeF paxosState "isLeader" "ps" ((![uint64T] "leaderInt") = #1);;
    "ps".

(* 2_internalclerk.go *)

Definition RPC_APPLY_AS_FOLLOWER : expr := #0.

Definition RPC_ENTER_NEW_EPOCH : expr := #1.

Definition RPC_BECOME_LEADER : expr := #2.

(* these clerks hide connection failures, and retry forever *)
Definition singleClerk := struct.decl [
  "cl" :: ptrT
].

Definition MakeSingleClerk: val :=
  rec: "MakeSingleClerk" "addr" :=
    let: "ck" := struct.new singleClerk [
      "cl" ::= reconnectclient.MakeReconnectingClient "addr"
    ] in
    "ck".

Definition singleClerk__enterNewEpoch: val :=
  rec: "singleClerk__enterNewEpoch" "s" "args" :=
    let: "raw_args" := encodeEnterNewEpochArgs "args" in
    let: "raw_reply" := ref (zero_val (slice.T byteT)) in
    let: "err" := reconnectclient.ReconnectingClient__Call (struct.loadF singleClerk "cl" "s") RPC_ENTER_NEW_EPOCH "raw_args" "raw_reply" #500 in
    (if: "err" = #0
    then decodeEnterNewEpochReply (![slice.T byteT] "raw_reply")
    else
      struct.new enterNewEpochReply [
        "err" ::= ETimeout
      ]).

Definition singleClerk__applyAsFollower: val :=
  rec: "singleClerk__applyAsFollower" "s" "args" :=
    let: "raw_args" := encodeApplyAsFollowerArgs "args" in
    let: "raw_reply" := ref (zero_val (slice.T byteT)) in
    let: "err" := reconnectclient.ReconnectingClient__Call (struct.loadF singleClerk "cl" "s") RPC_APPLY_AS_FOLLOWER "raw_args" "raw_reply" #500 in
    (if: "err" = #0
    then decodeApplyAsFollowerReply (![slice.T byteT] "raw_reply")
    else
      struct.new applyAsFollowerReply [
        "err" ::= ETimeout
      ]).

Definition singleClerk__TryBecomeLeader: val :=
  rec: "singleClerk__TryBecomeLeader" "s" :=
    let: "reply" := ref (zero_val (slice.T byteT)) in
    reconnectclient.ReconnectingClient__Call (struct.loadF singleClerk "cl" "s") RPC_BECOME_LEADER (NewSlice byteT #0) "reply" #500;;
    #().

(* server.go *)

Definition Server := struct.decl [
  "mu" :: ptrT;
  "ps" :: ptrT;
  "storage" :: ptrT;
  "clerks" :: slice.T ptrT
].

Definition Server__withLock: val :=
  rec: "Server__withLock" "s" "f" :=
    sync.Mutex__Lock (struct.loadF Server "mu" "s");;
    "f" (struct.loadF Server "ps" "s");;
    let: "waitFn" := asyncfile.AsyncFile__Write (struct.loadF Server "storage" "s") (encodePaxosState (struct.loadF Server "ps" "s")) in
    sync.Mutex__Unlock (struct.loadF Server "mu" "s");;
    "waitFn" #();;
    #().

Definition Server__applyAsFollower: val :=
  rec: "Server__applyAsFollower" "s" "args" "reply" :=
    Server__withLock "s" (λ: "ps",
      (if: (struct.loadF paxosState "epoch" "ps") ≤ (struct.loadF applyAsFollowerArgs "epoch" "args")
      then
        (if: (struct.loadF paxosState "acceptedEpoch" "ps") = (struct.loadF applyAsFollowerArgs "epoch" "args")
        then
          (if: (struct.loadF paxosState "nextIndex" "ps") < (struct.loadF applyAsFollowerArgs "nextIndex" "args")
          then
            struct.storeF paxosState "nextIndex" "ps" (struct.loadF applyAsFollowerArgs "nextIndex" "args");;
            struct.storeF paxosState "state" "ps" (struct.loadF applyAsFollowerArgs "state" "args");;
            struct.storeF applyAsFollowerReply "err" "reply" ENone;;
            #()
          else
            struct.storeF applyAsFollowerReply "err" "reply" ENone;;
            #())
        else
          struct.storeF paxosState "acceptedEpoch" "ps" (struct.loadF applyAsFollowerArgs "epoch" "args");;
          struct.storeF paxosState "epoch" "ps" (struct.loadF applyAsFollowerArgs "epoch" "args");;
          struct.storeF paxosState "state" "ps" (struct.loadF applyAsFollowerArgs "state" "args");;
          struct.storeF paxosState "nextIndex" "ps" (struct.loadF applyAsFollowerArgs "nextIndex" "args");;
          struct.storeF paxosState "isLeader" "ps" #false;;
          struct.storeF applyAsFollowerReply "err" "reply" ENone;;
          #())
      else
        struct.storeF applyAsFollowerReply "err" "reply" EEpochStale;;
        #())
      );;
    #().

(* NOTE:
   This will vote yes only the first time it's called in an epoch.
   If you have too aggressive of a timeout and end up retrying this, the retry
   might fail because it may be the second execution of enterNewEpoch(epoch) on
   the server.
   Solution: either conservative (maybe double) timeouts, or don't use this for
   leader election, only for coming up with a valid proposal. *)
Definition Server__enterNewEpoch: val :=
  rec: "Server__enterNewEpoch" "s" "args" "reply" :=
    Server__withLock "s" (λ: "ps",
      (if: (struct.loadF paxosState "epoch" "ps") ≥ (struct.loadF enterNewEpochArgs "epoch" "args")
      then
        struct.storeF enterNewEpochReply "err" "reply" EEpochStale;;
        #()
      else
        struct.storeF paxosState "isLeader" "ps" #false;;
        struct.storeF paxosState "epoch" "ps" (struct.loadF enterNewEpochArgs "epoch" "args");;
        struct.storeF enterNewEpochReply "acceptedEpoch" "reply" (struct.loadF paxosState "acceptedEpoch" "ps");;
        struct.storeF enterNewEpochReply "nextIndex" "reply" (struct.loadF paxosState "nextIndex" "ps");;
        struct.storeF enterNewEpochReply "state" "reply" (struct.loadF paxosState "state" "ps");;
        #())
      );;
    #().

Definition Server__TryBecomeLeader: val :=
  rec: "Server__TryBecomeLeader" "s" :=
    (* log.Println("started trybecomeleader") *)
    sync.Mutex__Lock (struct.loadF Server "mu" "s");;
    (if: struct.loadF paxosState "isLeader" (struct.loadF Server "ps" "s")
    then
      (* log.Println("already leader") *)
      sync.Mutex__Unlock (struct.loadF Server "mu" "s");;
      #()
    else
      let: "clerks" := struct.loadF Server "clerks" "s" in
      let: "args" := struct.new enterNewEpochArgs [
        "epoch" ::= (struct.loadF paxosState "epoch" (struct.loadF Server "ps" "s")) + #1
      ] in
      sync.Mutex__Unlock (struct.loadF Server "mu" "s");;
      let: "numReplies" := ref_to uint64T #0 in
      let: "replies" := NewSlice ptrT (slice.len "clerks") in
      let: "mu" := lock.new #() in
      let: "numReplies_cond" := lock.newCond "mu" in
      let: "n" := slice.len "clerks" in
      ForSlice ptrT "i" "ck" "clerks"
        (let: "ck" := "ck" in
        let: "i" := "i" in
        Fork (let: "reply" := singleClerk__enterNewEpoch "ck" "args" in
              sync.Mutex__Lock "mu";;
              "numReplies" <-[uint64T] ((![uint64T] "numReplies") + #1);;
              SliceSet ptrT "replies" "i" "reply";;
              (if: (#2 * (![uint64T] "numReplies")) > "n"
              then sync.Cond__Signal "numReplies_cond"
              else #());;
              sync.Mutex__Unlock "mu"));;
      sync.Mutex__Lock "mu";;
      Skip;;
      (for: (λ: <>, (#2 * (![uint64T] "numReplies")) ≤ "n"); (λ: <>, Skip) := λ: <>,
        sync.Cond__Wait "numReplies_cond";;
        Continue);;
      let: "latestReply" := ref (zero_val ptrT) in
      let: "numSuccesses" := ref_to uint64T #0 in
      ForSlice ptrT <> "reply" "replies"
        ((if: "reply" ≠ #null
        then
          (if: (struct.loadF enterNewEpochReply "err" "reply") = ENone
          then
            (if: (![uint64T] "numSuccesses") = #0
            then "latestReply" <-[ptrT] "reply"
            else
              (if: (struct.loadF enterNewEpochReply "acceptedEpoch" (![ptrT] "latestReply")) < (struct.loadF enterNewEpochReply "acceptedEpoch" "reply")
              then "latestReply" <-[ptrT] "reply"
              else
                (if: ((struct.loadF enterNewEpochReply "acceptedEpoch" (![ptrT] "latestReply")) = (struct.loadF enterNewEpochReply "acceptedEpoch" "reply")) && ((struct.loadF enterNewEpochReply "nextIndex" "reply") > (struct.loadF enterNewEpochReply "nextIndex" (![ptrT] "latestReply")))
                then "latestReply" <-[ptrT] "reply"
                else #())));;
            "numSuccesses" <-[uint64T] ((![uint64T] "numSuccesses") + #1)
          else #())
        else #()));;
      (if: (#2 * (![uint64T] "numSuccesses")) > "n"
      then
        Server__withLock "s" (λ: "ps",
          (if: (struct.loadF paxosState "epoch" "ps") ≤ (struct.loadF enterNewEpochArgs "epoch" "args")
          then
            (* log.Printf("succeeded becomeleader in epoch %d\n", args.epoch) *)
            struct.storeF paxosState "epoch" "ps" (struct.loadF enterNewEpochArgs "epoch" "args");;
            struct.storeF paxosState "isLeader" "ps" #true;;
            struct.storeF paxosState "acceptedEpoch" "ps" (struct.loadF paxosState "epoch" "ps");;
            struct.storeF paxosState "nextIndex" "ps" (struct.loadF enterNewEpochReply "nextIndex" (![ptrT] "latestReply"));;
            struct.storeF paxosState "state" "ps" (struct.loadF enterNewEpochReply "state" (![ptrT] "latestReply"));;
            #()
          else #())
          );;
        sync.Mutex__Unlock "mu";;
        #()
      else
        sync.Mutex__Unlock "mu";;
        (* log.Println("failed becomeleader") *)
        #())).

Definition Server__TryAcquire: val :=
  rec: "Server__TryAcquire" "s" :=
    let: "retErr" := ref (zero_val Error) in
    sync.Mutex__Lock (struct.loadF Server "mu" "s");;
    (if: (~ (struct.loadF paxosState "isLeader" (struct.loadF Server "ps" "s")))
    then
      sync.Mutex__Unlock (struct.loadF Server "mu" "s");;
      let: "n" := ref (zero_val ptrT) in
      (ENotLeader, ![ptrT] "n", slice.nil)
    else
      let: "tryRelease" := (λ: <>,
        struct.storeF paxosState "nextIndex" (struct.loadF Server "ps" "s") (std.SumAssumeNoOverflow (struct.loadF paxosState "nextIndex" (struct.loadF Server "ps" "s")) #1);;
        let: "args" := struct.new applyAsFollowerArgs [
          "epoch" ::= struct.loadF paxosState "epoch" (struct.loadF Server "ps" "s");
          "nextIndex" ::= struct.loadF paxosState "nextIndex" (struct.loadF Server "ps" "s");
          "state" ::= struct.loadF paxosState "state" (struct.loadF Server "ps" "s")
        ] in
        let: "waitFn" := asyncfile.AsyncFile__Write (struct.loadF Server "storage" "s") (encodePaxosState (struct.loadF Server "ps" "s")) in
        sync.Mutex__Unlock (struct.loadF Server "mu" "s");;
        "waitFn" #();;
        let: "clerks" := struct.loadF Server "clerks" "s" in
        let: "numReplies" := ref_to uint64T #0 in
        let: "replies" := NewSlice ptrT (slice.len "clerks") in
        let: "mu" := lock.new #() in
        let: "numReplies_cond" := lock.newCond "mu" in
        let: "n" := slice.len "clerks" in
        ForSlice ptrT "i" "ck" "clerks"
          (let: "ck" := "ck" in
          let: "i" := "i" in
          Fork (let: "reply" := singleClerk__applyAsFollower "ck" "args" in
                sync.Mutex__Lock "mu";;
                "numReplies" <-[uint64T] ((![uint64T] "numReplies") + #1);;
                SliceSet ptrT "replies" "i" "reply";;
                (if: (#2 * (![uint64T] "numReplies")) > "n"
                then sync.Cond__Signal "numReplies_cond"
                else #());;
                sync.Mutex__Unlock "mu"));;
        sync.Mutex__Lock "mu";;
        Skip;;
        (for: (λ: <>, (#2 * (![uint64T] "numReplies")) ≤ "n"); (λ: <>, Skip) := λ: <>,
          sync.Cond__Wait "numReplies_cond";;
          Continue);;
        let: "numSuccesses" := ref_to uint64T #0 in
        ForSlice ptrT <> "reply" "replies"
          ((if: "reply" ≠ #null
          then
            (if: (struct.loadF applyAsFollowerReply "err" "reply") = ENone
            then "numSuccesses" <-[uint64T] ((![uint64T] "numSuccesses") + #1)
            else #())
          else #()));;
        (if: (#2 * (![uint64T] "numSuccesses")) > "n"
        then "retErr" <-[Error] ENone
        else "retErr" <-[Error] EEpochStale);;
        ![Error] "retErr"
        ) in
      (ENone, struct.fieldRef paxosState "state" (struct.loadF Server "ps" "s"), "tryRelease")).

Definition Server__WeakRead: val :=
  rec: "Server__WeakRead" "s" :=
    sync.Mutex__Lock (struct.loadF Server "mu" "s");;
    let: "ret" := struct.loadF paxosState "state" (struct.loadF Server "ps" "s") in
    sync.Mutex__Unlock (struct.loadF Server "mu" "s");;
    "ret".

Definition makeServer: val :=
  rec: "makeServer" "fname" "initstate" "config" :=
    let: "s" := struct.alloc Server (zero_val (struct.t Server)) in
    struct.storeF Server "mu" "s" (lock.new #());;
    struct.storeF Server "clerks" "s" (NewSlice ptrT #0);;
    ForSlice uint64T <> "host" "config"
      (struct.storeF Server "clerks" "s" (SliceAppend ptrT (struct.loadF Server "clerks" "s") (MakeSingleClerk "host")));;
    let: "encstate" := ref (zero_val (slice.T byteT)) in
    let: ("0_ret", "1_ret") := asyncfile.MakeAsyncFile "fname" in
    "encstate" <-[slice.T byteT] "0_ret";;
    struct.storeF Server "storage" "s" "1_ret";;
    (if: (slice.len (![slice.T byteT] "encstate")) = #0
    then
      struct.storeF Server "ps" "s" (struct.alloc paxosState (zero_val (struct.t paxosState)));;
      struct.storeF paxosState "state" (struct.loadF Server "ps" "s") "initstate"
    else struct.storeF Server "ps" "s" (decodePaxosState (![slice.T byteT] "encstate")));;
    "s".

Definition StartServer: val :=
  rec: "StartServer" "fname" "initstate" "me" "config" :=
    let: "s" := makeServer "fname" "initstate" "config" in
    let: "handlers" := NewMap uint64T ((slice.T byteT) -> ptrT -> unitT)%ht #() in
    MapInsert "handlers" RPC_APPLY_AS_FOLLOWER (λ: "raw_args" "raw_reply",
      let: "reply" := struct.alloc applyAsFollowerReply (zero_val (struct.t applyAsFollowerReply)) in
      let: "args" := decodeApplyAsFollowerArgs "raw_args" in
      Server__applyAsFollower "s" "args" "reply";;
      "raw_reply" <-[slice.T byteT] (encodeApplyAsFollowerReply "reply");;
      #()
      );;
    MapInsert "handlers" RPC_ENTER_NEW_EPOCH (λ: "raw_args" "raw_reply",
      let: "reply" := struct.alloc enterNewEpochReply (zero_val (struct.t enterNewEpochReply)) in
      let: "args" := decodeEnterNewEpochArgs "raw_args" in
      Server__enterNewEpoch "s" "args" "reply";;
      "raw_reply" <-[slice.T byteT] (encodeEnterNewEpochReply "reply");;
      #()
      );;
    MapInsert "handlers" RPC_BECOME_LEADER (λ: "raw_args" "raw_reply",
      Server__TryBecomeLeader "s";;
      #()
      );;
    let: "r" := urpc.MakeServer "handlers" in
    urpc.Server__Serve "r" "me";;
    "s".
