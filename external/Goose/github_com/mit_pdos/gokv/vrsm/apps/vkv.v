(* autogenerated from github.com/mit-pdos/gokv/vrsm/apps/vkv *)
From Perennial.goose_lang Require Import prelude.
From Goose Require github_com.mit_pdos.gokv.kv.
From Goose Require github_com.mit_pdos.gokv.map_string_marshal.
From Goose Require github_com.mit_pdos.gokv.vrsm.apps.exactlyonce.
From Goose Require github_com.mit_pdos.gokv.vrsm.storage.
From Goose Require github_com.tchajed.marshal.

From Perennial.goose_lang Require Import ffi.grove_prelude.

(* clerk.go *)

Definition Clerk := struct.decl [
  "cl" :: ptrT
].

Definition MakeClerk: val :=
  rec: "MakeClerk" "confHosts" :=
    struct.new Clerk [
      "cl" ::= exactlyonce.MakeClerk "confHosts"
    ].

(* PutArgs from server.go *)

(* begin arg structs and marshalling *)
Definition PutArgs := struct.decl [
  "Key" :: stringT;
  "Val" :: stringT
].

Definition OP_PUT : expr := #(U8 0).

Definition OP_GET : expr := #(U8 1).

Definition OP_COND_PUT : expr := #(U8 2).

Definition encodePutArgs: val :=
  rec: "encodePutArgs" "args" :=
    let: "enc" := ref_to (slice.T byteT) (NewSliceWithCap byteT #1 (#1 + #8)) in
    SliceSet byteT (![slice.T byteT] "enc") #0 OP_PUT;;
    "enc" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "enc") (StringLength (struct.loadF PutArgs "Key" "args")));;
    "enc" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "enc") (StringToBytes (struct.loadF PutArgs "Key" "args")));;
    "enc" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "enc") (StringToBytes (struct.loadF PutArgs "Val" "args")));;
    ![slice.T byteT] "enc".

Definition Clerk__Put: val :=
  rec: "Clerk__Put" "ck" "key" "val" :=
    let: "args" := struct.new PutArgs [
      "Key" ::= "key";
      "Val" ::= "val"
    ] in
    exactlyonce.Clerk__ApplyExactlyOnce (struct.loadF Clerk "cl" "ck") (encodePutArgs "args");;
    #().

Notation getArgs := stringT (only parsing).

Definition encodeGetArgs: val :=
  rec: "encodeGetArgs" "args" :=
    let: "enc" := ref_to (slice.T byteT) (NewSliceWithCap byteT #1 #1) in
    SliceSet byteT (![slice.T byteT] "enc") #0 OP_GET;;
    "enc" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "enc") (StringToBytes "args"));;
    ![slice.T byteT] "enc".

Definition Clerk__Get: val :=
  rec: "Clerk__Get" "ck" "key" :=
    StringFromBytes (exactlyonce.Clerk__ApplyReadonly (struct.loadF Clerk "cl" "ck") (encodeGetArgs "key")).

(* begin arg structs and marshalling *)
Definition CondPutArgs := struct.decl [
  "Key" :: stringT;
  "Expect" :: stringT;
  "Val" :: stringT
].

Definition encodeCondPutArgs: val :=
  rec: "encodeCondPutArgs" "args" :=
    let: "enc" := ref_to (slice.T byteT) (NewSliceWithCap byteT #1 (#1 + #8)) in
    SliceSet byteT (![slice.T byteT] "enc") #0 OP_COND_PUT;;
    "enc" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "enc") (StringLength (struct.loadF CondPutArgs "Key" "args")));;
    "enc" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "enc") (StringToBytes (struct.loadF CondPutArgs "Key" "args")));;
    "enc" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "enc") (StringLength (struct.loadF CondPutArgs "Expect" "args")));;
    "enc" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "enc") (StringToBytes (struct.loadF CondPutArgs "Expect" "args")));;
    "enc" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "enc") (StringToBytes (struct.loadF CondPutArgs "Val" "args")));;
    ![slice.T byteT] "enc".

Definition Clerk__CondPut: val :=
  rec: "Clerk__CondPut" "ck" "key" "expect" "val" :=
    let: "args" := struct.new CondPutArgs [
      "Key" ::= "key";
      "Expect" ::= "expect";
      "Val" ::= "val"
    ] in
    StringFromBytes (exactlyonce.Clerk__ApplyExactlyOnce (struct.loadF Clerk "cl" "ck") (encodeCondPutArgs "args")).

(* clerkpool.go *)

(* TODO: should implement clerk pool at the exactlyonce level, so that we can
   avoid aking ownership of a whole clerk just to do a Get(). *)
Definition ClerkPool := struct.decl [
  "mu" :: ptrT;
  "cls" :: slice.T ptrT;
  "confHosts" :: slice.T uint64T
].

Definition MakeClerkPool: val :=
  rec: "MakeClerkPool" "confHosts" :=
    struct.new ClerkPool [
      "mu" ::= lock.new #();
      "cls" ::= NewSlice ptrT #0;
      "confHosts" ::= "confHosts"
    ].

(* TODO: get rid of stale clerks from the ck.cls list?
   TODO: keep failed clerks out of ck.cls list? Maybe f(cl) can return an
   optional error saying "get rid of cl". *)
Definition ClerkPool__doWithClerk: val :=
  rec: "ClerkPool__doWithClerk" "ck" "f" :=
    lock.acquire (struct.loadF ClerkPool "mu" "ck");;
    let: "cl" := ref (zero_val ptrT) in
    (if: (slice.len (struct.loadF ClerkPool "cls" "ck")) > #0
    then
      "cl" <-[ptrT] (SliceGet ptrT (struct.loadF ClerkPool "cls" "ck") #0);;
      struct.storeF ClerkPool "cls" "ck" (SliceSkip ptrT (struct.loadF ClerkPool "cls" "ck") #1);;
      lock.release (struct.loadF ClerkPool "mu" "ck");;
      "f" (![ptrT] "cl");;
      lock.acquire (struct.loadF ClerkPool "mu" "ck");;
      struct.storeF ClerkPool "cls" "ck" (SliceAppend ptrT (struct.loadF ClerkPool "cls" "ck") (![ptrT] "cl"));;
      lock.release (struct.loadF ClerkPool "mu" "ck");;
      #()
    else
      lock.release (struct.loadF ClerkPool "mu" "ck");;
      "cl" <-[ptrT] (MakeClerk (struct.loadF ClerkPool "confHosts" "ck"));;
      "f" (![ptrT] "cl");;
      lock.acquire (struct.loadF ClerkPool "mu" "ck");;
      struct.storeF ClerkPool "cls" "ck" (SliceAppend ptrT (struct.loadF ClerkPool "cls" "ck") (![ptrT] "cl"));;
      lock.release (struct.loadF ClerkPool "mu" "ck");;
      #()).

Definition ClerkPool__Put: val :=
  rec: "ClerkPool__Put" "ck" "key" "val" :=
    ClerkPool__doWithClerk "ck" (λ: "ck",
      Clerk__Put "ck" "key" "val";;
      #()
      );;
    #().

Definition ClerkPool__Get: val :=
  rec: "ClerkPool__Get" "ck" "key" :=
    let: "ret" := ref (zero_val stringT) in
    ClerkPool__doWithClerk "ck" (λ: "ck",
      "ret" <-[stringT] (Clerk__Get "ck" "key");;
      #()
      );;
    ![stringT] "ret".

Definition ClerkPool__CondPut: val :=
  rec: "ClerkPool__CondPut" "ck" "key" "expect" "val" :=
    let: "ret" := ref (zero_val stringT) in
    ClerkPool__doWithClerk "ck" (λ: "ck",
      "ret" <-[stringT] (Clerk__CondPut "ck" "key" "expect" "val");;
      #()
      );;
    ![stringT] "ret".

Definition MakeKv: val :=
  rec: "MakeKv" "confHosts" :=
    let: "ck" := MakeClerkPool "confHosts" in
    struct.new kv.Kv [
      "Put" ::= ClerkPool__Put "ck";
      "Get" ::= ClerkPool__Get "ck";
      "ConditionalPut" ::= ClerkPool__CondPut "ck"
    ].

(* server.go *)

Definition KVState := struct.decl [
  "kvs" :: mapT stringT;
  "vnums" :: mapT uint64T;
  "minVnum" :: uint64T
].

Definition decodePutArgs: val :=
  rec: "decodePutArgs" "raw_args" :=
    let: "enc" := ref_to (slice.T byteT) (SliceSkip byteT "raw_args" #1) in
    let: "args" := struct.alloc PutArgs (zero_val (struct.t PutArgs)) in
    let: "l" := ref (zero_val uint64T) in
    let: ("0_ret", "1_ret") := marshal.ReadInt (![slice.T byteT] "enc") in
    "l" <-[uint64T] "0_ret";;
    "enc" <-[slice.T byteT] "1_ret";;
    struct.storeF PutArgs "Key" "args" (StringFromBytes (SliceTake (![slice.T byteT] "enc") (![uint64T] "l")));;
    struct.storeF PutArgs "Val" "args" (StringFromBytes (SliceSkip byteT (![slice.T byteT] "enc") (![uint64T] "l")));;
    "args".

Definition decodeGetArgs: val :=
  rec: "decodeGetArgs" "raw_args" :=
    StringFromBytes (SliceSkip byteT "raw_args" #1).

Definition decodeCondPutArgs: val :=
  rec: "decodeCondPutArgs" "raw_args" :=
    let: "enc" := ref_to (slice.T byteT) (SliceSkip byteT "raw_args" #1) in
    let: "args" := struct.alloc CondPutArgs (zero_val (struct.t CondPutArgs)) in
    let: "l" := ref (zero_val uint64T) in
    let: ("0_ret", "1_ret") := marshal.ReadInt (![slice.T byteT] "enc") in
    "l" <-[uint64T] "0_ret";;
    "enc" <-[slice.T byteT] "1_ret";;
    let: ("keybytes", "enc2") := marshal.ReadBytes (![slice.T byteT] "enc") (![uint64T] "l") in
    struct.storeF CondPutArgs "Key" "args" (StringFromBytes "keybytes");;
    let: ("0_ret", "1_ret") := marshal.ReadInt "enc2" in
    "l" <-[uint64T] "0_ret";;
    "enc" <-[slice.T byteT] "1_ret";;
    struct.storeF CondPutArgs "Expect" "args" (StringFromBytes (SliceTake (![slice.T byteT] "enc") (![uint64T] "l")));;
    struct.storeF CondPutArgs "Val" "args" (StringFromBytes (SliceSkip byteT (![slice.T byteT] "enc") (![uint64T] "l")));;
    "args".

(* end of marshalling *)
Definition KVState__put: val :=
  rec: "KVState__put" "s" "args" :=
    MapInsert (struct.loadF KVState "kvs" "s") (struct.loadF PutArgs "Key" "args") (struct.loadF PutArgs "Val" "args");;
    NewSlice byteT #0.

Definition KVState__get: val :=
  rec: "KVState__get" "s" "args" :=
    StringToBytes (Fst (MapGet (struct.loadF KVState "kvs" "s") "args")).

Definition KVState__apply: val :=
  rec: "KVState__apply" "s" "args" "vnum" :=
    (if: (SliceGet byteT "args" #0) = OP_PUT
    then
      let: "args" := decodePutArgs "args" in
      MapInsert (struct.loadF KVState "vnums" "s") (struct.loadF PutArgs "Key" "args") "vnum";;
      KVState__put "s" "args"
    else
      (if: (SliceGet byteT "args" #0) = OP_GET
      then
        let: "key" := decodeGetArgs "args" in
        MapInsert (struct.loadF KVState "vnums" "s") "key" "vnum";;
        KVState__get "s" "key"
      else
        (if: (SliceGet byteT "args" #0) = OP_COND_PUT
        then
          let: "args" := decodeCondPutArgs "args" in
          (if: (Fst (MapGet (struct.loadF KVState "kvs" "s") (struct.loadF CondPutArgs "Key" "args"))) = (struct.loadF CondPutArgs "Expect" "args")
          then
            MapInsert (struct.loadF KVState "vnums" "s") (struct.loadF CondPutArgs "Key" "args") "vnum";;
            MapInsert (struct.loadF KVState "kvs" "s") (struct.loadF CondPutArgs "Key" "args") (struct.loadF CondPutArgs "Val" "args");;
            StringToBytes #(str"ok")
          else StringToBytes #(str""))
        else
          Panic "unexpected op type";;
          #()))).

Definition KVState__applyReadonly: val :=
  rec: "KVState__applyReadonly" "s" "args" :=
    (if: (SliceGet byteT "args" #0) ≠ OP_GET
    then Panic "expected a GET as readonly-operation"
    else #());;
    let: "key" := decodeGetArgs "args" in
    let: "reply" := KVState__get "s" "key" in
    let: ("vnum", "ok") := MapGet (struct.loadF KVState "vnums" "s") "key" in
    (if: "ok"
    then ("vnum", "reply")
    else (struct.loadF KVState "minVnum" "s", "reply")).

Definition KVState__getState: val :=
  rec: "KVState__getState" "s" :=
    map_string_marshal.EncodeStringMap (struct.loadF KVState "kvs" "s").

Definition KVState__setState: val :=
  rec: "KVState__setState" "s" "snap" "nextIndex" :=
    struct.storeF KVState "minVnum" "s" "nextIndex";;
    struct.storeF KVState "vnums" "s" (NewMap stringT uint64T #());;
    struct.storeF KVState "kvs" "s" (map_string_marshal.DecodeStringMap "snap");;
    #().

Definition makeVersionedStateMachine: val :=
  rec: "makeVersionedStateMachine" <> :=
    let: "s" := struct.alloc KVState (zero_val (struct.t KVState)) in
    struct.storeF KVState "kvs" "s" (NewMap stringT stringT #());;
    struct.storeF KVState "vnums" "s" (NewMap stringT uint64T #());;
    struct.new exactlyonce.VersionedStateMachine [
      "ApplyVolatile" ::= KVState__apply "s";
      "ApplyReadonly" ::= KVState__applyReadonly "s";
      "GetState" ::= (λ: <>,
        KVState__getState "s"
        );
      "SetState" ::= KVState__setState "s"
    ].

Definition Start: val :=
  rec: "Start" "fname" "host" "confHosts" :=
    replica.Server__Serve (storage.MakePbServer (exactlyonce.MakeExactlyOnceStateMachine (makeVersionedStateMachine #())) "fname" "confHosts") "host";;
    #().
