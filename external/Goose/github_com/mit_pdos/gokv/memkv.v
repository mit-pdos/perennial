(* autogenerated from github.com/mit-pdos/gokv/memkv *)
From Perennial.goose_lang Require Import prelude.
From Goose Require github_com.goose_lang.std.
From Goose Require github_com.mit_pdos.gokv.connman.
From Goose Require github_com.mit_pdos.gokv.erpc.
From Goose Require github_com.mit_pdos.gokv.urpc.
From Goose Require github_com.tchajed.marshal.

From Perennial.goose_lang Require Import ffi.grove_prelude.

(* 0_common.go *)

Notation HostName := uint64T (only parsing).

Notation ValueType := uint64T (only parsing).

Notation ErrorType := uint64T (only parsing).

Definition ENone : expr := #0.

Definition EDontHaveShard : expr := #1.

Definition NSHARD : expr := #65536.

Definition KV_FRESHCID : expr := #0.

Definition KV_PUT : expr := #1.

Definition KV_GET : expr := #2.

Definition KV_CONDITIONAL_PUT : expr := #3.

Definition KV_INS_SHARD : expr := #4.

Definition KV_MOV_SHARD : expr := #5.

Definition shardOf: val :=
  rec: "shardOf" "key" :=
    "key" `rem` NSHARD.

Definition PutRequest := struct.decl [
  "Key" :: uint64T;
  "Value" :: slice.T byteT
].

(* doesn't include the operation type *)
Definition EncodePutRequest: val :=
  rec: "EncodePutRequest" "args" :=
    let: "num_bytes" := std.SumAssumeNoOverflow (#8 + #8) (slice.len (struct.loadF PutRequest "Value" "args")) in
    let: "e" := marshal.NewEnc "num_bytes" in
    marshal.Enc__PutInt "e" (struct.loadF PutRequest "Key" "args");;
    marshal.Enc__PutInt "e" (slice.len (struct.loadF PutRequest "Value" "args"));;
    marshal.Enc__PutBytes "e" (struct.loadF PutRequest "Value" "args");;
    marshal.Enc__Finish "e".

Definition DecodePutRequest: val :=
  rec: "DecodePutRequest" "reqData" :=
    let: "req" := struct.alloc PutRequest (zero_val (struct.t PutRequest)) in
    let: "d" := marshal.NewDec "reqData" in
    struct.storeF PutRequest "Key" "req" (marshal.Dec__GetInt "d");;
    struct.storeF PutRequest "Value" "req" (marshal.Dec__GetBytes "d" (marshal.Dec__GetInt "d"));;
    "req".

Definition PutReply := struct.decl [
  "Err" :: ErrorType
].

Definition EncodePutReply: val :=
  rec: "EncodePutReply" "reply" :=
    let: "e" := marshal.NewEnc #8 in
    marshal.Enc__PutInt "e" (struct.loadF PutReply "Err" "reply");;
    marshal.Enc__Finish "e".

Definition DecodePutReply: val :=
  rec: "DecodePutReply" "replyData" :=
    let: "reply" := struct.alloc PutReply (zero_val (struct.t PutReply)) in
    let: "d" := marshal.NewDec "replyData" in
    struct.storeF PutReply "Err" "reply" (marshal.Dec__GetInt "d");;
    "reply".

Definition GetRequest := struct.decl [
  "Key" :: uint64T
].

Definition GetReply := struct.decl [
  "Err" :: ErrorType;
  "Value" :: slice.T byteT
].

Definition EncodeGetRequest: val :=
  rec: "EncodeGetRequest" "req" :=
    let: "e" := marshal.NewEnc #8 in
    marshal.Enc__PutInt "e" (struct.loadF GetRequest "Key" "req");;
    marshal.Enc__Finish "e".

Definition DecodeGetRequest: val :=
  rec: "DecodeGetRequest" "rawReq" :=
    let: "req" := struct.alloc GetRequest (zero_val (struct.t GetRequest)) in
    let: "d" := marshal.NewDec "rawReq" in
    struct.storeF GetRequest "Key" "req" (marshal.Dec__GetInt "d");;
    "req".

Definition EncodeGetReply: val :=
  rec: "EncodeGetReply" "rep" :=
    let: "num_bytes" := std.SumAssumeNoOverflow (#8 + #8) (slice.len (struct.loadF GetReply "Value" "rep")) in
    let: "e" := marshal.NewEnc "num_bytes" in
    marshal.Enc__PutInt "e" (struct.loadF GetReply "Err" "rep");;
    marshal.Enc__PutInt "e" (slice.len (struct.loadF GetReply "Value" "rep"));;
    marshal.Enc__PutBytes "e" (struct.loadF GetReply "Value" "rep");;
    marshal.Enc__Finish "e".

Definition DecodeGetReply: val :=
  rec: "DecodeGetReply" "rawRep" :=
    let: "rep" := struct.alloc GetReply (zero_val (struct.t GetReply)) in
    let: "d" := marshal.NewDec "rawRep" in
    struct.storeF GetReply "Err" "rep" (marshal.Dec__GetInt "d");;
    struct.storeF GetReply "Value" "rep" (marshal.Dec__GetBytes "d" (marshal.Dec__GetInt "d"));;
    "rep".

Definition ConditionalPutRequest := struct.decl [
  "Key" :: uint64T;
  "ExpectedValue" :: slice.T byteT;
  "NewValue" :: slice.T byteT
].

Definition ConditionalPutReply := struct.decl [
  "Err" :: ErrorType;
  "Success" :: boolT
].

Definition EncodeConditionalPutRequest: val :=
  rec: "EncodeConditionalPutRequest" "req" :=
    let: "num_bytes" := std.SumAssumeNoOverflow ((#8 + #8) + #8) (std.SumAssumeNoOverflow (slice.len (struct.loadF ConditionalPutRequest "ExpectedValue" "req")) (slice.len (struct.loadF ConditionalPutRequest "NewValue" "req"))) in
    let: "e" := marshal.NewEnc "num_bytes" in
    marshal.Enc__PutInt "e" (struct.loadF ConditionalPutRequest "Key" "req");;
    marshal.Enc__PutInt "e" (slice.len (struct.loadF ConditionalPutRequest "ExpectedValue" "req"));;
    marshal.Enc__PutBytes "e" (struct.loadF ConditionalPutRequest "ExpectedValue" "req");;
    marshal.Enc__PutInt "e" (slice.len (struct.loadF ConditionalPutRequest "NewValue" "req"));;
    marshal.Enc__PutBytes "e" (struct.loadF ConditionalPutRequest "NewValue" "req");;
    marshal.Enc__Finish "e".

Definition DecodeConditionalPutRequest: val :=
  rec: "DecodeConditionalPutRequest" "rawReq" :=
    let: "req" := struct.alloc ConditionalPutRequest (zero_val (struct.t ConditionalPutRequest)) in
    let: "d" := marshal.NewDec "rawReq" in
    struct.storeF ConditionalPutRequest "Key" "req" (marshal.Dec__GetInt "d");;
    struct.storeF ConditionalPutRequest "ExpectedValue" "req" (marshal.Dec__GetBytes "d" (marshal.Dec__GetInt "d"));;
    struct.storeF ConditionalPutRequest "NewValue" "req" (marshal.Dec__GetBytes "d" (marshal.Dec__GetInt "d"));;
    "req".

Definition EncodeConditionalPutReply: val :=
  rec: "EncodeConditionalPutReply" "reply" :=
    let: "e" := marshal.NewEnc (#8 + #1) in
    marshal.Enc__PutInt "e" (struct.loadF ConditionalPutReply "Err" "reply");;
    marshal.Enc__PutBool "e" (struct.loadF ConditionalPutReply "Success" "reply");;
    marshal.Enc__Finish "e".

Definition DecodeConditionalPutReply: val :=
  rec: "DecodeConditionalPutReply" "replyData" :=
    let: "reply" := struct.alloc ConditionalPutReply (zero_val (struct.t ConditionalPutReply)) in
    let: "d" := marshal.NewDec "replyData" in
    struct.storeF ConditionalPutReply "Err" "reply" (marshal.Dec__GetInt "d");;
    struct.storeF ConditionalPutReply "Success" "reply" (marshal.Dec__GetBool "d");;
    "reply".

Definition InstallShardRequest := struct.decl [
  "Sid" :: uint64T;
  "Kvs" :: mapT (slice.T byteT)
].

(* NOTE: probably can just amortize this by keeping track of this with the map itself *)
Definition SizeOfMarshalledMap: val :=
  rec: "SizeOfMarshalledMap" "m" :=
    let: "s" := ref (zero_val uint64T) in
    "s" <-[uint64T] #8;;
    MapIter "m" (λ: <> "value",
      let: "v" := std.SumAssumeNoOverflow (slice.len "value") (#8 + #8) in
      "s" <-[uint64T] (std.SumAssumeNoOverflow (![uint64T] "s") "v"));;
    ![uint64T] "s".

Definition EncSliceMap: val :=
  rec: "EncSliceMap" "e" "m" :=
    marshal.Enc__PutInt "e" (MapLen "m");;
    MapIter "m" (λ: "key" "value",
      marshal.Enc__PutInt "e" "key";;
      marshal.Enc__PutInt "e" (slice.len "value");;
      marshal.Enc__PutBytes "e" "value");;
    #().

Definition DecSliceMap: val :=
  rec: "DecSliceMap" "d" :=
    let: "sz" := marshal.Dec__GetInt "d" in
    let: "m" := NewMap uint64T (slice.T byteT) #() in
    let: "i" := ref_to uint64T #0 in
    Skip;;
    (for: (λ: <>, (![uint64T] "i") < "sz"); (λ: <>, Skip) := λ: <>,
      let: "k" := marshal.Dec__GetInt "d" in
      let: "v" := marshal.Dec__GetBytes "d" (marshal.Dec__GetInt "d") in
      MapInsert "m" "k" "v";;
      "i" <-[uint64T] ((![uint64T] "i") + #1);;
      Continue);;
    "m".

Definition encodeInstallShardRequest: val :=
  rec: "encodeInstallShardRequest" "req" :=
    let: "num_bytes" := std.SumAssumeNoOverflow #8 (SizeOfMarshalledMap (struct.loadF InstallShardRequest "Kvs" "req")) in
    let: "e" := marshal.NewEnc "num_bytes" in
    marshal.Enc__PutInt "e" (struct.loadF InstallShardRequest "Sid" "req");;
    EncSliceMap "e" (struct.loadF InstallShardRequest "Kvs" "req");;
    marshal.Enc__Finish "e".

Definition decodeInstallShardRequest: val :=
  rec: "decodeInstallShardRequest" "rawReq" :=
    let: "d" := marshal.NewDec "rawReq" in
    let: "req" := struct.alloc InstallShardRequest (zero_val (struct.t InstallShardRequest)) in
    struct.storeF InstallShardRequest "Sid" "req" (marshal.Dec__GetInt "d");;
    struct.storeF InstallShardRequest "Kvs" "req" (DecSliceMap "d");;
    "req".

Definition MoveShardRequest := struct.decl [
  "Sid" :: uint64T;
  "Dst" :: HostName
].

Definition encodeMoveShardRequest: val :=
  rec: "encodeMoveShardRequest" "req" :=
    let: "e" := marshal.NewEnc (#8 + #8) in
    marshal.Enc__PutInt "e" (struct.loadF MoveShardRequest "Sid" "req");;
    marshal.Enc__PutInt "e" (struct.loadF MoveShardRequest "Dst" "req");;
    marshal.Enc__Finish "e".

Definition decodeMoveShardRequest: val :=
  rec: "decodeMoveShardRequest" "rawReq" :=
    let: "req" := struct.alloc MoveShardRequest (zero_val (struct.t MoveShardRequest)) in
    let: "d" := marshal.NewDec "rawReq" in
    struct.storeF MoveShardRequest "Sid" "req" (marshal.Dec__GetInt "d");;
    struct.storeF MoveShardRequest "Dst" "req" (marshal.Dec__GetInt "d");;
    "req".

(* FIXME: these should just be in goose std or something *)
Definition EncodeUint64: val :=
  rec: "EncodeUint64" "i" :=
    let: "e" := marshal.NewEnc #8 in
    marshal.Enc__PutInt "e" "i";;
    marshal.Enc__Finish "e".

Definition DecodeUint64: val :=
  rec: "DecodeUint64" "raw" :=
    marshal.Dec__GetInt (marshal.NewDec "raw").

Definition encodeShardMap: val :=
  rec: "encodeShardMap" "shardMap" :=
    let: "e" := marshal.NewEnc (#8 * NSHARD) in
    marshal.Enc__PutInts "e" (![slice.T uint64T] "shardMap");;
    marshal.Enc__Finish "e".

Definition decodeShardMap: val :=
  rec: "decodeShardMap" "raw" :=
    let: "d" := marshal.NewDec "raw" in
    marshal.Dec__GetInts "d" NSHARD.

(* 1_memkv_shard_clerk.go *)

Definition KVShardClerk := struct.decl [
  "erpc" :: ptrT;
  "host" :: HostName;
  "c" :: ptrT
].

Definition MakeFreshKVShardClerk: val :=
  rec: "MakeFreshKVShardClerk" "host" "c" :=
    let: "ck" := struct.alloc KVShardClerk (zero_val (struct.t KVShardClerk)) in
    struct.storeF KVShardClerk "host" "ck" "host";;
    struct.storeF KVShardClerk "c" "ck" "c";;
    let: "rawRep" := ref (zero_val (slice.T byteT)) in
    connman.ConnMan__CallAtLeastOnce (struct.loadF KVShardClerk "c" "ck") "host" KV_FRESHCID (NewSlice byteT #0) "rawRep" #100;;
    let: "cid" := DecodeUint64 (![slice.T byteT] "rawRep") in
    struct.storeF KVShardClerk "erpc" "ck" (erpc.MakeClient "cid");;
    "ck".

Definition KVShardClerk__Put: val :=
  rec: "KVShardClerk__Put" "ck" "key" "value" :=
    let: "args" := struct.alloc PutRequest (zero_val (struct.t PutRequest)) in
    struct.storeF PutRequest "Key" "args" "key";;
    struct.storeF PutRequest "Value" "args" "value";;
    let: "req" := erpc.Client__NewRequest (struct.loadF KVShardClerk "erpc" "ck") (EncodePutRequest "args") in
    let: "rawRep" := ref (zero_val (slice.T byteT)) in
    connman.ConnMan__CallAtLeastOnce (struct.loadF KVShardClerk "c" "ck") (struct.loadF KVShardClerk "host" "ck") KV_PUT "req" "rawRep" #100;;
    let: "rep" := DecodePutReply (![slice.T byteT] "rawRep") in
    struct.loadF PutReply "Err" "rep".

Definition KVShardClerk__Get: val :=
  rec: "KVShardClerk__Get" "ck" "key" "value" :=
    let: "args" := struct.alloc GetRequest (zero_val (struct.t GetRequest)) in
    struct.storeF GetRequest "Key" "args" "key";;
    let: "req" := erpc.Client__NewRequest (struct.loadF KVShardClerk "erpc" "ck") (EncodeGetRequest "args") in
    let: "rawRep" := ref (zero_val (slice.T byteT)) in
    connman.ConnMan__CallAtLeastOnce (struct.loadF KVShardClerk "c" "ck") (struct.loadF KVShardClerk "host" "ck") KV_GET "req" "rawRep" #100;;
    let: "rep" := DecodeGetReply (![slice.T byteT] "rawRep") in
    "value" <-[slice.T byteT] (struct.loadF GetReply "Value" "rep");;
    struct.loadF GetReply "Err" "rep".

Definition KVShardClerk__ConditionalPut: val :=
  rec: "KVShardClerk__ConditionalPut" "ck" "key" "expectedValue" "newValue" "success" :=
    let: "args" := struct.alloc ConditionalPutRequest (zero_val (struct.t ConditionalPutRequest)) in
    struct.storeF ConditionalPutRequest "Key" "args" "key";;
    struct.storeF ConditionalPutRequest "ExpectedValue" "args" "expectedValue";;
    struct.storeF ConditionalPutRequest "NewValue" "args" "newValue";;
    let: "req" := erpc.Client__NewRequest (struct.loadF KVShardClerk "erpc" "ck") (EncodeConditionalPutRequest "args") in
    let: "rawRep" := ref (zero_val (slice.T byteT)) in
    connman.ConnMan__CallAtLeastOnce (struct.loadF KVShardClerk "c" "ck") (struct.loadF KVShardClerk "host" "ck") KV_CONDITIONAL_PUT "req" "rawRep" #100;;
    let: "rep" := DecodeConditionalPutReply (![slice.T byteT] "rawRep") in
    "success" <-[boolT] (struct.loadF ConditionalPutReply "Success" "rep");;
    struct.loadF ConditionalPutReply "Err" "rep".

Definition KVShardClerk__InstallShard: val :=
  rec: "KVShardClerk__InstallShard" "ck" "sid" "kvs" :=
    let: "args" := struct.alloc InstallShardRequest (zero_val (struct.t InstallShardRequest)) in
    struct.storeF InstallShardRequest "Sid" "args" "sid";;
    struct.storeF InstallShardRequest "Kvs" "args" "kvs";;
    let: "req" := erpc.Client__NewRequest (struct.loadF KVShardClerk "erpc" "ck") (encodeInstallShardRequest "args") in
    let: "rawRep" := ref (zero_val (slice.T byteT)) in
    connman.ConnMan__CallAtLeastOnce (struct.loadF KVShardClerk "c" "ck") (struct.loadF KVShardClerk "host" "ck") KV_INS_SHARD "req" "rawRep" #100;;
    #().

Definition KVShardClerk__MoveShard: val :=
  rec: "KVShardClerk__MoveShard" "ck" "sid" "dst" :=
    let: "args" := struct.alloc MoveShardRequest (zero_val (struct.t MoveShardRequest)) in
    struct.storeF MoveShardRequest "Sid" "args" "sid";;
    struct.storeF MoveShardRequest "Dst" "args" "dst";;
    let: "rawRep" := ref (zero_val (slice.T byteT)) in
    connman.ConnMan__CallAtLeastOnce (struct.loadF KVShardClerk "c" "ck") (struct.loadF KVShardClerk "host" "ck") KV_MOV_SHARD (encodeMoveShardRequest "args") "rawRep" #100;;
    #().

(* The coordinator, and the main clerk, need to talk to a bunch of shards. *)
Definition ShardClerkSet := struct.decl [
  "cls" :: mapT ptrT;
  "c" :: ptrT
].

Definition MakeShardClerkSet: val :=
  rec: "MakeShardClerkSet" "c" :=
    struct.new ShardClerkSet [
      "cls" ::= NewMap HostName ptrT #();
      "c" ::= "c"
    ].

Definition ShardClerkSet__GetClerk: val :=
  rec: "ShardClerkSet__GetClerk" "s" "host" :=
    let: ("ck", "ok") := MapGet (struct.loadF ShardClerkSet "cls" "s") "host" in
    (if: (~ "ok")
    then
      let: "ck2" := MakeFreshKVShardClerk "host" (struct.loadF ShardClerkSet "c" "s") in
      MapInsert (struct.loadF ShardClerkSet "cls" "s") "host" "ck2";;
      "ck2"
    else "ck").

(* 2_memkv_shard.go *)

Notation KvMap := (mapT (slice.T byteT)) (only parsing).

Definition KVShardServer := struct.decl [
  "me" :: stringT;
  "mu" :: ptrT;
  "erpc" :: ptrT;
  "shardMap" :: slice.T boolT;
  "kvss" :: slice.T KvMap;
  "peers" :: mapT ptrT;
  "cm" :: ptrT
].

Definition PutArgs := struct.decl [
  "Key" :: uint64T;
  "Value" :: ValueType
].

Definition KVShardServer__put_inner: val :=
  rec: "KVShardServer__put_inner" "s" "args" "reply" :=
    let: "sid" := shardOf (struct.loadF PutRequest "Key" "args") in
    (if: (SliceGet boolT (struct.loadF KVShardServer "shardMap" "s") "sid") = #true
    then
      MapInsert (SliceGet (mapT (slice.T byteT)) (struct.loadF KVShardServer "kvss" "s") "sid") (struct.loadF PutRequest "Key" "args") (struct.loadF PutRequest "Value" "args");;
      struct.storeF PutReply "Err" "reply" ENone;;
      #()
    else
      struct.storeF PutReply "Err" "reply" EDontHaveShard;;
      #()).

Definition KVShardServer__PutRPC: val :=
  rec: "KVShardServer__PutRPC" "s" "args" "reply" :=
    Mutex__Lock (struct.loadF KVShardServer "mu" "s");;
    KVShardServer__put_inner "s" "args" "reply";;
    Mutex__Unlock (struct.loadF KVShardServer "mu" "s");;
    #().

Definition KVShardServer__get_inner: val :=
  rec: "KVShardServer__get_inner" "s" "args" "reply" :=
    let: "sid" := shardOf (struct.loadF GetRequest "Key" "args") in
    (if: (SliceGet boolT (struct.loadF KVShardServer "shardMap" "s") "sid") = #true
    then
      struct.storeF GetReply "Value" "reply" (Fst (MapGet (SliceGet (mapT (slice.T byteT)) (struct.loadF KVShardServer "kvss" "s") "sid") (struct.loadF GetRequest "Key" "args")));;
      struct.storeF GetReply "Err" "reply" ENone;;
      #()
    else
      struct.storeF GetReply "Err" "reply" EDontHaveShard;;
      #()).

Definition KVShardServer__GetRPC: val :=
  rec: "KVShardServer__GetRPC" "s" "args" "reply" :=
    Mutex__Lock (struct.loadF KVShardServer "mu" "s");;
    KVShardServer__get_inner "s" "args" "reply";;
    Mutex__Unlock (struct.loadF KVShardServer "mu" "s");;
    #().

Definition KVShardServer__conditional_put_inner: val :=
  rec: "KVShardServer__conditional_put_inner" "s" "args" "reply" :=
    let: "sid" := shardOf (struct.loadF ConditionalPutRequest "Key" "args") in
    (if: (SliceGet boolT (struct.loadF KVShardServer "shardMap" "s") "sid") = #true
    then
      let: "m" := SliceGet (mapT (slice.T byteT)) (struct.loadF KVShardServer "kvss" "s") "sid" in
      let: "equal" := std.BytesEqual (struct.loadF ConditionalPutRequest "ExpectedValue" "args") (Fst (MapGet "m" (struct.loadF ConditionalPutRequest "Key" "args"))) in
      (if: "equal"
      then MapInsert "m" (struct.loadF ConditionalPutRequest "Key" "args") (struct.loadF ConditionalPutRequest "NewValue" "args")
      else #());;
      struct.storeF ConditionalPutReply "Success" "reply" "equal";;
      struct.storeF ConditionalPutReply "Err" "reply" ENone;;
      #()
    else
      struct.storeF ConditionalPutReply "Err" "reply" EDontHaveShard;;
      #()).

Definition KVShardServer__ConditionalPutRPC: val :=
  rec: "KVShardServer__ConditionalPutRPC" "s" "args" "reply" :=
    Mutex__Lock (struct.loadF KVShardServer "mu" "s");;
    KVShardServer__conditional_put_inner "s" "args" "reply";;
    Mutex__Unlock (struct.loadF KVShardServer "mu" "s");;
    #().

(* NOTE: easy to do a little optimization with shard migration:
   add a "RemoveShard" rpc, which removes the shard on the target server, and
   returns half of the ghost state for that shard. Meanwhile, InstallShard()
   will only grant half the ghost state, and physical state will keep track of
   the fact that the shard is only good for read-only operations up until that
   flag is updated (i.e. until RemoveShard() is run). *)
Definition KVShardServer__install_shard_inner: val :=
  rec: "KVShardServer__install_shard_inner" "s" "args" :=
    SliceSet boolT (struct.loadF KVShardServer "shardMap" "s") (struct.loadF InstallShardRequest "Sid" "args") #true;;
    SliceSet (mapT (slice.T byteT)) (struct.loadF KVShardServer "kvss" "s") (struct.loadF InstallShardRequest "Sid" "args") (struct.loadF InstallShardRequest "Kvs" "args");;
    #().

Definition KVShardServer__InstallShardRPC: val :=
  rec: "KVShardServer__InstallShardRPC" "s" "args" :=
    Mutex__Lock (struct.loadF KVShardServer "mu" "s");;
    KVShardServer__install_shard_inner "s" "args";;
    Mutex__Unlock (struct.loadF KVShardServer "mu" "s");;
    #().

Definition KVShardServer__MoveShardRPC: val :=
  rec: "KVShardServer__MoveShardRPC" "s" "args" :=
    Mutex__Lock (struct.loadF KVShardServer "mu" "s");;
    let: (<>, "ok") := MapGet (struct.loadF KVShardServer "peers" "s") (struct.loadF MoveShardRequest "Dst" "args") in
    (if: (~ "ok")
    then
      let: "ck" := MakeFreshKVShardClerk (struct.loadF MoveShardRequest "Dst" "args") (struct.loadF KVShardServer "cm" "s") in
      MapInsert (struct.loadF KVShardServer "peers" "s") (struct.loadF MoveShardRequest "Dst" "args") "ck"
    else #());;
    (if: (~ (SliceGet boolT (struct.loadF KVShardServer "shardMap" "s") (struct.loadF MoveShardRequest "Sid" "args")))
    then
      Mutex__Unlock (struct.loadF KVShardServer "mu" "s");;
      #()
    else
      let: "kvs" := SliceGet (mapT (slice.T byteT)) (struct.loadF KVShardServer "kvss" "s") (struct.loadF MoveShardRequest "Sid" "args") in
      SliceSet (mapT (slice.T byteT)) (struct.loadF KVShardServer "kvss" "s") (struct.loadF MoveShardRequest "Sid" "args") (NewMap uint64T (slice.T byteT) #());;
      SliceSet boolT (struct.loadF KVShardServer "shardMap" "s") (struct.loadF MoveShardRequest "Sid" "args") #false;;
      KVShardClerk__InstallShard (Fst (MapGet (struct.loadF KVShardServer "peers" "s") (struct.loadF MoveShardRequest "Dst" "args"))) (struct.loadF MoveShardRequest "Sid" "args") "kvs";;
      Mutex__Unlock (struct.loadF KVShardServer "mu" "s");;
      #()).

Definition MakeKVShardServer: val :=
  rec: "MakeKVShardServer" "is_init" :=
    let: "srv" := struct.alloc KVShardServer (zero_val (struct.t KVShardServer)) in
    struct.storeF KVShardServer "mu" "srv" (newMutex #());;
    struct.storeF KVShardServer "erpc" "srv" (erpc.MakeServer #());;
    struct.storeF KVShardServer "shardMap" "srv" (NewSlice boolT NSHARD);;
    struct.storeF KVShardServer "kvss" "srv" (NewSlice KvMap NSHARD);;
    struct.storeF KVShardServer "peers" "srv" (NewMap HostName ptrT #());;
    struct.storeF KVShardServer "cm" "srv" (connman.MakeConnMan #());;
    let: "i" := ref_to uint64T #0 in
    (for: (λ: <>, (![uint64T] "i") < NSHARD); (λ: <>, "i" <-[uint64T] ((![uint64T] "i") + #1)) := λ: <>,
      SliceSet boolT (struct.loadF KVShardServer "shardMap" "srv") (![uint64T] "i") "is_init";;
      (if: "is_init"
      then
        SliceSet (mapT (slice.T byteT)) (struct.loadF KVShardServer "kvss" "srv") (![uint64T] "i") (NewMap uint64T (slice.T byteT) #());;
        Continue
      else Continue));;
    "srv".

Definition KVShardServer__GetCIDRPC: val :=
  rec: "KVShardServer__GetCIDRPC" "s" :=
    erpc.Server__GetFreshCID (struct.loadF KVShardServer "erpc" "s").

Definition KVShardServer__Start: val :=
  rec: "KVShardServer__Start" "mkv" "host" :=
    let: "handlers" := NewMap uint64T ((slice.T byteT) -> ptrT -> unitT)%ht #() in
    let: "erpc" := struct.loadF KVShardServer "erpc" "mkv" in
    MapInsert "handlers" KV_FRESHCID (λ: "rawReq" "rawReply",
      "rawReply" <-[slice.T byteT] (EncodeUint64 (KVShardServer__GetCIDRPC "mkv"));;
      #()
      );;
    MapInsert "handlers" KV_PUT (erpc.Server__HandleRequest "erpc" (λ: "rawReq" "rawReply",
      let: "rep" := struct.alloc PutReply (zero_val (struct.t PutReply)) in
      KVShardServer__PutRPC "mkv" (DecodePutRequest "rawReq") "rep";;
      "rawReply" <-[slice.T byteT] (EncodePutReply "rep");;
      #()
      ));;
    MapInsert "handlers" KV_GET (erpc.Server__HandleRequest "erpc" (λ: "rawReq" "rawReply",
      let: "rep" := struct.alloc GetReply (zero_val (struct.t GetReply)) in
      KVShardServer__GetRPC "mkv" (DecodeGetRequest "rawReq") "rep";;
      "rawReply" <-[slice.T byteT] (EncodeGetReply "rep");;
      #()
      ));;
    MapInsert "handlers" KV_CONDITIONAL_PUT (erpc.Server__HandleRequest "erpc" (λ: "rawReq" "rawReply",
      let: "rep" := struct.alloc ConditionalPutReply (zero_val (struct.t ConditionalPutReply)) in
      KVShardServer__ConditionalPutRPC "mkv" (DecodeConditionalPutRequest "rawReq") "rep";;
      "rawReply" <-[slice.T byteT] (EncodeConditionalPutReply "rep");;
      #()
      ));;
    MapInsert "handlers" KV_INS_SHARD (erpc.Server__HandleRequest "erpc" (λ: "rawReq" "rawReply",
      KVShardServer__InstallShardRPC "mkv" (decodeInstallShardRequest "rawReq");;
      "rawReply" <-[slice.T byteT] (NewSlice byteT #0);;
      #()
      ));;
    MapInsert "handlers" KV_MOV_SHARD (λ: "rawReq" "rawReply",
      KVShardServer__MoveShardRPC "mkv" (decodeMoveShardRequest "rawReq");;
      "rawReply" <-[slice.T byteT] (NewSlice byteT #0);;
      #()
      );;
    let: "s" := urpc.MakeServer "handlers" in
    urpc.Server__Serve "s" "host";;
    #().

(* 3_memkv_coord.go *)

Definition COORD_ADD : expr := #1.

Definition COORD_GET : expr := #2.

Definition KVCoord := struct.decl [
  "mu" :: ptrT;
  "shardMap" :: slice.T HostName;
  "hostShards" :: mapT uint64T;
  "shardClerks" :: ptrT
].

Definition KVCoord__AddServerRPC: val :=
  rec: "KVCoord__AddServerRPC" "c" "newhost" :=
    Mutex__Lock (struct.loadF KVCoord "mu" "c");;
    (* log.Printf("Rebalancing\n") *)
    MapInsert (struct.loadF KVCoord "hostShards" "c") "newhost" #0;;
    let: "numHosts" := MapLen (struct.loadF KVCoord "hostShards" "c") in
    let: "numShardFloor" := NSHARD `quot` "numHosts" in
    let: "numShardCeil" := (NSHARD `quot` "numHosts") + #1 in
    let: "nf_left" := ref (zero_val uint64T) in
    "nf_left" <-[uint64T] ("numHosts" - (NSHARD - (("numHosts" * NSHARD) `quot` "numHosts")));;
    ForSlice uint64T "sid" "host" (struct.loadF KVCoord "shardMap" "c")
      (let: "n" := Fst (MapGet (struct.loadF KVCoord "hostShards" "c") "host") in
      (if: "n" > "numShardFloor"
      then
        (if: "n" = "numShardCeil"
        then
          (if: (![uint64T] "nf_left") > #0
          then
            "nf_left" <-[uint64T] ((![uint64T] "nf_left") - #1);;
            KVShardClerk__MoveShard (ShardClerkSet__GetClerk (struct.loadF KVCoord "shardClerks" "c") "host") "sid" "newhost";;
            MapInsert (struct.loadF KVCoord "hostShards" "c") "host" ("n" - #1);;
            MapInsert (struct.loadF KVCoord "hostShards" "c") "newhost" ((Fst (MapGet (struct.loadF KVCoord "hostShards" "c") "newhost")) + #1);;
            SliceSet uint64T (struct.loadF KVCoord "shardMap" "c") "sid" "newhost"
          else #())
        else
          KVShardClerk__MoveShard (ShardClerkSet__GetClerk (struct.loadF KVCoord "shardClerks" "c") "host") "sid" "newhost";;
          MapInsert (struct.loadF KVCoord "hostShards" "c") "host" ("n" - #1);;
          MapInsert (struct.loadF KVCoord "hostShards" "c") "newhost" ((Fst (MapGet (struct.loadF KVCoord "hostShards" "c") "newhost")) + #1);;
          SliceSet uint64T (struct.loadF KVCoord "shardMap" "c") "sid" "newhost")
      else #()));;
    (* log.Println("Done rebalancing") *)
    (* log.Printf("%+v", c.hostShards) *)
    Mutex__Unlock (struct.loadF KVCoord "mu" "c");;
    #().

Definition KVCoord__GetShardMapRPC: val :=
  rec: "KVCoord__GetShardMapRPC" "c" <> "rep" :=
    Mutex__Lock (struct.loadF KVCoord "mu" "c");;
    "rep" <-[slice.T byteT] (encodeShardMap (struct.fieldRef KVCoord "shardMap" "c"));;
    Mutex__Unlock (struct.loadF KVCoord "mu" "c");;
    #().

Definition MakeKVCoordServer: val :=
  rec: "MakeKVCoordServer" "initserver" :=
    let: "s" := struct.alloc KVCoord (zero_val (struct.t KVCoord)) in
    struct.storeF KVCoord "mu" "s" (newMutex #());;
    struct.storeF KVCoord "shardMap" "s" (NewSlice HostName NSHARD);;
    let: "i" := ref_to uint64T #0 in
    (for: (λ: <>, (![uint64T] "i") < NSHARD); (λ: <>, "i" <-[uint64T] ((![uint64T] "i") + #1)) := λ: <>,
      SliceSet uint64T (struct.loadF KVCoord "shardMap" "s") (![uint64T] "i") "initserver";;
      Continue);;
    struct.storeF KVCoord "hostShards" "s" (NewMap HostName uint64T #());;
    MapInsert (struct.loadF KVCoord "hostShards" "s") "initserver" NSHARD;;
    struct.storeF KVCoord "shardClerks" "s" (MakeShardClerkSet (connman.MakeConnMan #()));;
    "s".

Definition KVCoord__Start: val :=
  rec: "KVCoord__Start" "c" "host" :=
    let: "handlers" := NewMap uint64T ((slice.T byteT) -> ptrT -> unitT)%ht #() in
    MapInsert "handlers" COORD_ADD (λ: "rawReq" "rawRep",
      let: "s" := DecodeUint64 "rawReq" in
      KVCoord__AddServerRPC "c" "s";;
      #()
      );;
    MapInsert "handlers" COORD_GET (KVCoord__GetShardMapRPC "c");;
    let: "s" := urpc.MakeServer "handlers" in
    urpc.Server__Serve "s" "host";;
    #().

(* 4_memkv_seq_clerk.go *)

Definition KVCoordClerk := struct.decl [
  "host" :: HostName;
  "c" :: ptrT
].

Definition KVCoordClerk__AddShardServer: val :=
  rec: "KVCoordClerk__AddShardServer" "ck" "dst" :=
    let: "rawRep" := ref (zero_val (slice.T byteT)) in
    connman.ConnMan__CallAtLeastOnce (struct.loadF KVCoordClerk "c" "ck") (struct.loadF KVCoordClerk "host" "ck") COORD_ADD (EncodeUint64 "dst") "rawRep" #50000;;
    #().

Definition KVCoordClerk__GetShardMap: val :=
  rec: "KVCoordClerk__GetShardMap" "ck" :=
    let: "rawRep" := ref (zero_val (slice.T byteT)) in
    connman.ConnMan__CallAtLeastOnce (struct.loadF KVCoordClerk "c" "ck") (struct.loadF KVCoordClerk "host" "ck") COORD_GET (NewSlice byteT #0) "rawRep" #50000;;
    decodeShardMap (![slice.T byteT] "rawRep").

(* "Sequential" KV clerk, can only be used for one request at a time.
   NOTE: a single clerk keeps quite a bit of state, via the shardMap[], so it
   might be good to not need to duplicate shardMap[] for a pool of clerks that's
   safe for concurrent use *)
Definition SeqKVClerk := struct.decl [
  "shardClerks" :: ptrT;
  "coordCk" :: ptrT;
  "shardMap" :: slice.T HostName
].

Definition SeqKVClerk__Get: val :=
  rec: "SeqKVClerk__Get" "ck" "key" :=
    let: "val" := ref (zero_val (slice.T byteT)) in
    Skip;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "sid" := shardOf "key" in
      let: "shardServer" := SliceGet uint64T (struct.loadF SeqKVClerk "shardMap" "ck") "sid" in
      let: "shardCk" := ShardClerkSet__GetClerk (struct.loadF SeqKVClerk "shardClerks" "ck") "shardServer" in
      let: "err" := KVShardClerk__Get "shardCk" "key" "val" in
      (if: "err" = ENone
      then Break
      else
        struct.storeF SeqKVClerk "shardMap" "ck" (KVCoordClerk__GetShardMap (struct.loadF SeqKVClerk "coordCk" "ck"));;
        Continue));;
    ![slice.T byteT] "val".

Definition SeqKVClerk__Put: val :=
  rec: "SeqKVClerk__Put" "ck" "key" "value" :=
    Skip;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "sid" := shardOf "key" in
      let: "shardServer" := SliceGet uint64T (struct.loadF SeqKVClerk "shardMap" "ck") "sid" in
      let: "shardCk" := ShardClerkSet__GetClerk (struct.loadF SeqKVClerk "shardClerks" "ck") "shardServer" in
      let: "err" := KVShardClerk__Put "shardCk" "key" "value" in
      (if: "err" = ENone
      then Break
      else
        struct.storeF SeqKVClerk "shardMap" "ck" (KVCoordClerk__GetShardMap (struct.loadF SeqKVClerk "coordCk" "ck"));;
        Continue));;
    #().

Definition SeqKVClerk__ConditionalPut: val :=
  rec: "SeqKVClerk__ConditionalPut" "ck" "key" "expectedValue" "newValue" :=
    let: "success" := ref (zero_val boolT) in
    Skip;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "sid" := shardOf "key" in
      let: "shardServer" := SliceGet uint64T (struct.loadF SeqKVClerk "shardMap" "ck") "sid" in
      let: "shardCk" := ShardClerkSet__GetClerk (struct.loadF SeqKVClerk "shardClerks" "ck") "shardServer" in
      let: "err" := KVShardClerk__ConditionalPut "shardCk" "key" "expectedValue" "newValue" "success" in
      (if: "err" = ENone
      then Break
      else
        struct.storeF SeqKVClerk "shardMap" "ck" (KVCoordClerk__GetShardMap (struct.loadF SeqKVClerk "coordCk" "ck"));;
        Continue));;
    ![boolT] "success".

Definition SeqKVClerk__Add: val :=
  rec: "SeqKVClerk__Add" "ck" "host" :=
    KVCoordClerk__AddShardServer (struct.loadF SeqKVClerk "coordCk" "ck") "host";;
    #().

Definition MakeSeqKVClerk: val :=
  rec: "MakeSeqKVClerk" "coord" "cm" :=
    let: "cck" := struct.alloc KVCoordClerk (zero_val (struct.t KVCoordClerk)) in
    let: "ck" := struct.alloc SeqKVClerk (zero_val (struct.t SeqKVClerk)) in
    struct.storeF SeqKVClerk "coordCk" "ck" "cck";;
    struct.storeF KVCoordClerk "host" (struct.loadF SeqKVClerk "coordCk" "ck") "coord";;
    struct.storeF KVCoordClerk "c" (struct.loadF SeqKVClerk "coordCk" "ck") "cm";;
    struct.storeF SeqKVClerk "shardClerks" "ck" (MakeShardClerkSet "cm");;
    struct.storeF SeqKVClerk "shardMap" "ck" (KVCoordClerk__GetShardMap (struct.loadF SeqKVClerk "coordCk" "ck"));;
    "ck".

(* 5_memkv_clerk.go *)

Definition KVClerk := struct.decl [
  "mu" :: ptrT;
  "freeClerks" :: slice.T ptrT;
  "cm" :: ptrT;
  "coord" :: HostName
].

Definition KVClerk__getSeqClerk: val :=
  rec: "KVClerk__getSeqClerk" "p" :=
    Mutex__Lock (struct.loadF KVClerk "mu" "p");;
    let: "n" := slice.len (struct.loadF KVClerk "freeClerks" "p") in
    (if: "n" = #0
    then
      Mutex__Unlock (struct.loadF KVClerk "mu" "p");;
      MakeSeqKVClerk (struct.loadF KVClerk "coord" "p") (connman.MakeConnMan #())
    else
      let: "ck" := SliceGet ptrT (struct.loadF KVClerk "freeClerks" "p") ("n" - #1) in
      struct.storeF KVClerk "freeClerks" "p" (SliceTake (struct.loadF KVClerk "freeClerks" "p") ("n" - #1));;
      Mutex__Unlock (struct.loadF KVClerk "mu" "p");;
      "ck").

Definition KVClerk__putSeqClerk: val :=
  rec: "KVClerk__putSeqClerk" "p" "ck" :=
    Fork (Mutex__Lock (struct.loadF KVClerk "mu" "p");;
          struct.storeF KVClerk "freeClerks" "p" (SliceAppend ptrT (struct.loadF KVClerk "freeClerks" "p") "ck");;
          Mutex__Unlock (struct.loadF KVClerk "mu" "p"));;
    #().

(* the hope is that after a while, the number of clerks needed to maintain a
   request rate for an open system benchmark will stabilize. *)
Definition KVClerk__Put: val :=
  rec: "KVClerk__Put" "p" "key" "value" :=
    let: "ck" := KVClerk__getSeqClerk "p" in
    SeqKVClerk__Put "ck" "key" "value";;
    KVClerk__putSeqClerk "p" "ck";;
    #().

Definition KVClerk__Get: val :=
  rec: "KVClerk__Get" "p" "key" :=
    let: "ck" := KVClerk__getSeqClerk "p" in
    let: "value" := SeqKVClerk__Get "ck" "key" in
    KVClerk__putSeqClerk "p" "ck";;
    "value".

Definition KVClerk__ConditionalPut: val :=
  rec: "KVClerk__ConditionalPut" "p" "key" "expectedValue" "newValue" :=
    let: "ck" := KVClerk__getSeqClerk "p" in
    let: "ret" := SeqKVClerk__ConditionalPut "ck" "key" "expectedValue" "newValue" in
    KVClerk__putSeqClerk "p" "ck";;
    "ret".

(* FIXME: rename to AddShardServer *)
Definition KVClerk__Add: val :=
  rec: "KVClerk__Add" "p" "host" :=
    let: "ck" := KVClerk__getSeqClerk "p" in
    SeqKVClerk__Add "ck" "host";;
    KVClerk__putSeqClerk "p" "ck";;
    #().

(* returns a slice of "values" (which are byte slices) in the same order as the
   keys passed in as input
   FIXME: benchmark *)
Definition KVClerk__MGet: val :=
  rec: "KVClerk__MGet" "p" "keys" :=
    let: "vals" := NewSlice (slice.T byteT) (slice.len "keys") in
    std.Multipar (slice.len "keys") (λ: "i",
      SliceSet (slice.T byteT) "vals" "i" (KVClerk__Get "p" (SliceGet uint64T "keys" "i"));;
      #()
      );;
    "vals".

Definition MakeKVClerk: val :=
  rec: "MakeKVClerk" "coord" "cm" :=
    let: "p" := struct.alloc KVClerk (zero_val (struct.t KVClerk)) in
    struct.storeF KVClerk "mu" "p" (newMutex #());;
    struct.storeF KVClerk "coord" "p" "coord";;
    struct.storeF KVClerk "cm" "p" "cm";;
    struct.storeF KVClerk "freeClerks" "p" (NewSlice ptrT #0);;
    "p".
