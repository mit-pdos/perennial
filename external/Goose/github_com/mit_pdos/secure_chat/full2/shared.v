(* autogenerated from github.com/mit-pdos/secure-chat/full2/shared *)
From Perennial.goose_lang Require Import prelude.
From Goose Require github_com.tchajed.marshal.

Section code.
Context `{ext_ty: ext_types}.
Local Coercion Var' s: expr := Var s.

Definition ErrorT: ty := uint64T.

Definition ErrNone : expr := #0.

Definition ErrSome : expr := #1.

Definition RpcGet : expr := #1.

Definition RpcPut : expr := #2.

Definition AliceNum : expr := #0.

Definition BobNum : expr := #1.

Definition MaxSenders : expr := #2.

Definition AliceMsg : expr := #10.

Definition BobMsg : expr := #11.

Definition SigLen : expr := #69.

Definition MsgT := struct.decl [
  "Body" :: uint64T
].

Definition NewMsgT: val :=
  rec: "NewMsgT" "body" :=
    struct.new MsgT [
      "Body" ::= "body"
    ].

Definition MsgT__Equals: val :=
  rec: "MsgT__Equals" "m" "o" :=
    (struct.loadF MsgT "Body" "m") = (struct.loadF MsgT "Body" "o").

Definition MsgT__Copy: val :=
  rec: "MsgT__Copy" "m" :=
    struct.new MsgT [
      "Body" ::= struct.loadF MsgT "Body" "m"
    ].

Definition MsgT__Encode: val :=
  rec: "MsgT__Encode" "m" :=
    let: "b" := ref_to (slice.T byteT) (NewSlice byteT #0) in
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (struct.loadF MsgT "Body" "m"));;
    ![slice.T byteT] "b".

Definition DecodeMsgT: val :=
  rec: "DecodeMsgT" "b" :=
    let: ("body", "b2") := marshal.ReadInt "b" in
    (NewMsgT "body", "b2").

Definition CopyMsgTSlice: val :=
  rec: "CopyMsgTSlice" "sl" :=
    let: "sl2" := ref_to (slice.T ptrT) (NewSlice ptrT (slice.len "sl")) in
    ForSlice ptrT "i" "v" "sl"
      (SliceSet ptrT (![slice.T ptrT] "sl2") "i" (MsgT__Copy "v"));;
    ![slice.T ptrT] "sl2".

Definition IsMsgTSlicePrefix: val :=
  rec: "IsMsgTSlicePrefix" "short" "long" :=
    (if: (slice.len "long") < (slice.len "short")
    then #false
    else
      let: "ret" := ref_to boolT #true in
      ForSlice ptrT "i" "m" "short"
        ((if: (~ (MsgT__Equals "m" (SliceGet ptrT "long" "i")))
        then "ret" <-[boolT] #false
        else #()));;
      ![boolT] "ret").

Definition EncodeMsgTSlice: val :=
  rec: "EncodeMsgTSlice" "sl" :=
    let: "b" := ref_to (slice.T byteT) (NewSlice byteT #0) in
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (slice.len "sl"));;
    ForSlice ptrT <> "v" "sl"
      ("b" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "b") (MsgT__Encode "v")));;
    ![slice.T byteT] "b".

Definition DecodeMsgTSlice: val :=
  rec: "DecodeMsgTSlice" "b" :=
    let: "b2" := ref_to (slice.T byteT) "b" in
    let: ("l", "b2") := marshal.ReadInt (![slice.T byteT] "b2") in
    let: "sl" := NewSlice ptrT "l" in
    let: "i" := ref_to uint64T #0 in
    (for: (λ: <>, (![uint64T] "i") < "l"); (λ: <>, "i" <-[uint64T] ((![uint64T] "i") + #1)) := λ: <>,
      let: ("0_ret", "1_ret") := DecodeMsgT (![slice.T byteT] "b2") in
      SliceSet ptrT "sl" (![uint64T] "i") "0_ret";;
      "b2" <-[slice.T byteT] "1_ret";;
      Continue);;
    ("sl", ![slice.T byteT] "b2").

Definition PutArg := struct.decl [
  "Sender" :: uint64T;
  "Sig" :: slice.T byteT;
  "LogB" :: slice.T byteT
].

Definition NewPutArg: val :=
  rec: "NewPutArg" "sender" "sig" "logB" :=
    struct.new PutArg [
      "Sender" ::= "sender";
      "Sig" ::= "sig";
      "LogB" ::= "logB"
    ].

Definition PutArg__Encode: val :=
  rec: "PutArg__Encode" "pa" :=
    control.impl.Assume ((slice.len (struct.loadF PutArg "Sig" "pa")) = SigLen);;
    let: "b" := ref_to (slice.T byteT) (NewSlice byteT #0) in
    "b" <-[slice.T byteT] (marshal.WriteInt (![slice.T byteT] "b") (struct.loadF PutArg "Sender" "pa"));;
    "b" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "b") (struct.loadF PutArg "Sig" "pa"));;
    "b" <-[slice.T byteT] (marshal.WriteBytes (![slice.T byteT] "b") (struct.loadF PutArg "LogB" "pa"));;
    ![slice.T byteT] "b".

(* Input comes from adv RPC, so need to validate it. *)
Definition DecodePutArg: val :=
  rec: "DecodePutArg" "b" :=
    (if: (slice.len "b") < #8
    then (slice.nil, ErrSome)
    else
      let: ("sender", "r2") := marshal.ReadInt "b" in
      (if: (~ ((#0 ≤ "sender") && ("sender" < MaxSenders)))
      then (slice.nil, ErrSome)
      else
        (if: (slice.len "r2") < SigLen
        then (slice.nil, ErrSome)
        else
          let: ("sig", "logB") := marshal.ReadBytes "r2" SigLen in
          (NewPutArg "sender" "sig" "logB", ErrNone)))).

End code.
