(* autogenerated from github.com/mit-pdos/secure-chat/chat4 *)
From Perennial.goose_lang Require Import prelude.
From Goose Require github_com.tchajed.marshal.

Section code.
Context `{ext_ty: ext_types}.
Local Coercion Var' s: expr := Var s.

(* encoding.go *)

Definition errorT: ty := boolT.

Definition ERRNONE : expr := #false.

Definition ERRSOME : expr := #true.

Definition msgT := struct.decl [
  "tag" :: uint64T;
  "body" :: uint64T;
  "pin" :: uint64T
].

Definition MSGT_SIZE : expr := (#8 + #8) + #8.

Definition newMsgT: val :=
  rec: "newMsgT" "tag" "body" "pin" :=
    struct.new msgT [
      "tag" ::= "tag";
      "body" ::= "body";
      "pin" ::= "pin"
    ].

Definition encodeMsgT: val :=
  rec: "encodeMsgT" "m" :=
    let: "b1" := NewSlice byteT #0 in
    let: "b2" := marshal.WriteInt "b1" (struct.loadF msgT "tag" "m") in
    let: "b3" := marshal.WriteInt "b2" (struct.loadF msgT "body" "m") in
    let: "b4" := marshal.WriteInt "b3" (struct.loadF msgT "pin" "m") in
    "b4".

Definition decodeMsgT: val :=
  rec: "decodeMsgT" "b" :=
    let: ("tag", "b2") := marshal.ReadInt "b" in
    let: ("body", "b3") := marshal.ReadInt "b2" in
    let: ("pin", "b4") := marshal.ReadInt "b3" in
    (newMsgT "tag" "body" "pin", "b4").

Definition msgWrapT := struct.decl [
  "msg" :: ptrT;
  "sig" :: slice.T byteT;
  "sn" :: uint64T
].

Definition SIG_LEN : expr := #64.

Definition MSGWRAPT_ADD_SIZE : expr := SIG_LEN + #8.

Definition MSGWRAPT_SIZE : expr := MSGT_SIZE + MSGWRAPT_ADD_SIZE.

Definition newMsgWrapT: val :=
  rec: "newMsgWrapT" "msg" "sig" "sn" :=
    struct.new msgWrapT [
      "msg" ::= "msg";
      "sig" ::= "sig";
      "sn" ::= "sn"
    ].

Definition newMsgWrapTSlice: val :=
  rec: "newMsgWrapTSlice" <> :=
    NewSlice byteT MSGWRAPT_SIZE.

Definition encodeMsgWrapT: val :=
  rec: "encodeMsgWrapT" "m" :=
    let: "b1" := encodeMsgT (struct.loadF msgWrapT "msg" "m") in
    let: "b2" := marshal.WriteBytes "b1" (struct.loadF msgWrapT "sig" "m") in
    let: "b3" := marshal.WriteInt "b2" (struct.loadF msgWrapT "sn" "m") in
    "b3".

Definition decodeMsgWrapT: val :=
  rec: "decodeMsgWrapT" "b" :=
    let: ("msg", "b2") := decodeMsgT "b" in
    let: ("sig", "b3") := marshal.ReadBytesCopy "b2" SIG_LEN in
    let: ("sn", "b4") := marshal.ReadInt "b3" in
    (newMsgWrapT "msg" "sig" "sn", "b4").

(* ffi.go *)

Definition rpcIdT: ty := uint64T.

Definition RPCGET : expr := #1.

Definition RPCPUT : expr := #2.

(* Don't have an err ret here bc semantics are to just fill "out" with "len(out)" arbitrary bytes. *)
Definition rpcCall: val :=
  rec: "rpcCall" "rpcId" "in" "out" :=
    #().

(* Right now, Go's notion of private (non-exported)
   lower-case fields prevents the owner of signerT from
   accessing the underlying key. *)
Definition signerT := struct.decl [
  "key" :: slice.T byteT
].

(* Arbitrarily made keys 64 bytes for now. *)
Definition makeKeys: val :=
  rec: "makeKeys" <> :=
    let: "s" := struct.new signerT [
      "key" ::= NewSlice byteT #64
    ] in
    ("s", NewSlice byteT #64).

(* Generate signature.
   For now, sign is UB when you try to call it with an invalid signing key
   or an invalid predicate.
   The sig is SIG_LEN bytes. *)
Definition signerT__sign: val :=
  rec: "signerT__sign" "s" "data" :=
    NewSlice byteT SIG_LEN.

(* Verify a signature.
   The actual implementation would return an err if the
   verification key is invalid or if the verification failed. *)
Definition verify: val :=
  rec: "verify" "vk" "data" "sig" :=
    ERRNONE.

(* prot.go *)

Definition aliceMain: val :=
  rec: "aliceMain" "skAlice" "vkBob" :=
    let: "tag1" := #1 in
    let: "body1" := #3948 in
    let: "pin1Empt" := #0 in
    let: "msg1" := newMsgT "tag1" "body1" "pin1Empt" in
    let: "msg1B" := encodeMsgT "msg1" in
    let: "sig1" := signerT__sign "skAlice" "msg1B" in
    let: "sn1Scratch" := #0 in
    let: "msgWrap1" := newMsgWrapT "msg1" "sig1" "sn1Scratch" in
    let: "msgWrap1B" := encodeMsgWrapT "msgWrap1" in
    let: "ret1Empt" := NewSlice byteT #0 in
    rpcCall RPCPUT "msgWrap1B" "ret1Empt";;
    let: "args2Empt" := NewSlice byteT #0 in
    let: "msgWrap2B" := newMsgWrapTSlice #() in
    rpcCall RPCGET "args2Empt" "msgWrap2B";;
    let: ("msgWrap2", <>) := decodeMsgWrapT "msgWrap2B" in
    let: "args3Empt" := NewSlice byteT #0 in
    let: "msgWrap3B" := newMsgWrapTSlice #() in
    rpcCall RPCGET "args3Empt" "msgWrap3B";;
    let: ("msgWrap3", <>) := decodeMsgWrapT "msgWrap3B" in
    let: "msg3B" := encodeMsgT (struct.loadF msgWrapT "msg" "msgWrap3") in
    let: "err3" := verify "vkBob" "msg3B" (struct.loadF msgWrapT "sig" "msgWrap3") in
    (if: "err3"
    then (#0, "err3")
    else
      (if: (struct.loadF msgWrapT "sn" "msgWrap2") â‰  (struct.loadF msgT "pin" (struct.loadF msgWrapT "msg" "msgWrap3"))
      then (#0, ERRSOME)
      else (struct.loadF msgWrapT "sn" "msgWrap2", ERRNONE))).

Definition bobMain: val :=
  rec: "bobMain" "skBob" "vkAlice" :=
    let: "args1Empt" := NewSlice byteT #0 in
    let: "msgWrap1B" := newMsgWrapTSlice #() in
    rpcCall RPCGET "args1Empt" "msgWrap1B";;
    let: ("msgWrap1", <>) := decodeMsgWrapT "msgWrap1B" in
    let: "tag2" := #2 in
    let: "body2" := #8959 in
    let: "msg2" := newMsgT "tag2" "body2" (struct.loadF msgWrapT "sn" "msgWrap1") in
    let: "msg2B" := encodeMsgT "msg2" in
    let: "sig2" := signerT__sign "skBob" "msg2B" in
    let: "sn2Scratch" := #0 in
    let: "msgWrap2" := newMsgWrapT "msg2" "sig2" "sn2Scratch" in
    let: "msgWrap2B" := encodeMsgWrapT "msgWrap2" in
    let: "ret2Empt" := NewSlice byteT #0 in
    rpcCall RPCPUT "msgWrap2B" "ret2Empt";;
    (struct.loadF msgWrapT "sn" "msgWrap1", ERRNONE).

(* Returns true if protocol error'd out or passed.
   Returns false if adversary defeated main protocol goal. *)
Definition game: val :=
  rec: "game" <> :=
    let: ("skAlice", "vkAlice") := makeKeys #() in
    let: ("skBob", "vkBob") := makeKeys #() in
    let: "aliceSn" := ref (zero_val uint64T) in
    let: "aliceErr" := ref (zero_val boolT) in
    let: "bobSn" := ref (zero_val uint64T) in
    let: "bobErr" := ref (zero_val boolT) in
    let: "wg" := waitgroup.New #() in
    waitgroup.Add "wg" #1;;
    Fork (let: ("0_ret", "1_ret") := aliceMain "skAlice" "vkBob" in
          "aliceSn" <-[uint64T] "0_ret";;
          "aliceErr" <-[boolT] "1_ret";;
          waitgroup.Done "wg");;
    waitgroup.Add "wg" #1;;
    Fork (let: ("0_ret", "1_ret") := bobMain "skBob" "vkAlice" in
          "bobSn" <-[uint64T] "0_ret";;
          "bobErr" <-[boolT] "1_ret";;
          waitgroup.Done "wg");;
    waitgroup.Wait "wg";;
    ((![boolT] "aliceErr") || (![boolT] "bobErr")) || ((![uint64T] "aliceSn") = (![uint64T] "bobSn")).

End code.
