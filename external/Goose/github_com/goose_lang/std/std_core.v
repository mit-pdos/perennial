(* autogenerated from github.com/goose-lang/std/std_core *)
From Perennial.goose_lang Require Import prelude.

Section code.
Context `{ext_ty: ext_types}.

(* std_core is a subset of std that uses very little of the goose model

   It is used for bootstrapping goose. *)

(* Returns true if x + y does not overflow *)
Definition SumNoOverflow: val :=
  rec: "SumNoOverflow" "x" "y" :=
    ("x" + "y") ≥ "x".

(* SumAssumeNoOverflow returns x + y, `Assume`ing that this does not overflow.

   *Use with care* - if the assumption is violated this function will panic. *)
Definition SumAssumeNoOverflow: val :=
  rec: "SumAssumeNoOverflow" "x" "y" :=
    control.impl.Assume (SumNoOverflow "x" "y");;
    "x" + "y".

(* MulNoOverflow returns true if x * y does not overflow *)
Definition MulNoOverflow: val :=
  rec: "MulNoOverflow" "x" "y" :=
    (if: ("x" = #0) || ("y" = #0)
    then #true
    else "x" ≤ (((#1 ≪ #64) - #1) `quot` "y")).

(* MulAssumeNoOverflow returns x * y, `Assume`ing that this does not overflow.

   *Use with care* - if the assumption is violated this function will panic. *)
Definition MulAssumeNoOverflow: val :=
  rec: "MulAssumeNoOverflow" "x" "y" :=
    control.impl.Assume (MulNoOverflow "x" "y");;
    "x" * "y".

(* Shuffle shuffles the elements of xs in place, using a Fisher-Yates shuffle. *)
Definition Shuffle: val :=
  rec: "Shuffle" "xs" :=
    (if: (slice.len "xs") = #0
    then #()
    else
      let: "i" := ref_to uint64T ((slice.len "xs") - #1) in
      (for: (λ: <>, (![uint64T] "i") > #0); (λ: <>, "i" <-[uint64T] ((![uint64T] "i") - #1)) := λ: <>,
        let: "j" := (rand.RandomUint64 #()) `rem` ((![uint64T] "i") + #1) in
        let: "temp" := SliceGet uint64T "xs" (![uint64T] "i") in
        SliceSet uint64T "xs" (![uint64T] "i") (SliceGet uint64T "xs" "j");;
        SliceSet uint64T "xs" "j" "temp";;
        Continue);;
      #()).

(* Permutation returns a random permutation of the integers 0, ..., n-1, using a
   Fisher-Yates shuffle. *)
Definition Permutation: val :=
  rec: "Permutation" "n" :=
    let: "order" := NewSlice uint64T "n" in
    let: "i" := ref_to uint64T #0 in
    (for: (λ: <>, (![uint64T] "i") < "n"); (λ: <>, "i" <-[uint64T] ((![uint64T] "i") + #1)) := λ: <>,
      SliceSet uint64T "order" (![uint64T] "i") (![uint64T] "i");;
      Continue);;
    Shuffle "order";;
    "order".

End code.
