(* autogenerated from github.com/goose-lang/goose/channel *)
From Perennial.goose_lang Require Import base_prelude.

Section goose_lang.
Context `{ext_ty: ext_types}.

Definition Channel (T: ty) : descriptor := struct.decl [
  "lock" :: ptrT;
  "closed" :: boolT;
  "buffer" :: slice.T T;
  "first" :: uint64T;
  "count" :: uint64T;
  "v" :: T;
  "receiver_ready" :: boolT;
  "sender_ready" :: boolT;
  "receiver_done" :: boolT;
  "sender_done" :: boolT
].

(* buffer_size = 0 is an unbuffered channel *)
Definition NewChannel (T:ty): val :=
  rec: "NewChannel" "buffer_size" :=
    struct.mk (Channel T) [
      "buffer" ::= NewSlice T "buffer_size";
      "lock" ::= newMutex #();
      "first" ::= #0;
      "count" ::= #0
    ].

(* buffer_size = 0 is an unbuffered channel *)
Definition NewChannelRef (T:ty): val :=
  rec: "NewChannelRef" "buffer_size" :=
    struct.new (Channel T) [
      "buffer" ::= NewSlice T "buffer_size";
      "lock" ::= newMutex #();
      "first" ::= #0;
      "count" ::= #0
    ].

(* c.Send(val)

   is equivalent to:

   c <- val *)
Definition Channel__Send (T:ty): val :=
  rec: "Channel__Send" "c" "val" :=
    (if: "c" = #null
    then
      Skip;;
      (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
        Continue)
    else #());;
    let: "buffer_size" := ref_to uint64T (slice.len (struct.loadF (Channel T) "buffer" "c")) in
    (if: (![uint64T] "buffer_size") ≠ #0
    then
      Skip;;
      (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
        Mutex__Lock (struct.loadF (Channel T) "lock" "c");;
        (if: struct.loadF (Channel T) "closed" "c"
        then Panic "send on closed channel"
        else #());;
        (if: (struct.loadF (Channel T) "count" "c") ≥ (![uint64T] "buffer_size")
        then
          Mutex__Unlock (struct.loadF (Channel T) "lock" "c");;
          Continue
        else
          let: "last" := ref_to uint64T (((struct.loadF (Channel T) "first" "c") + (struct.loadF (Channel T) "count" "c")) `rem` (![uint64T] "buffer_size")) in
          SliceSet T (struct.loadF (Channel T) "buffer" "c") (![uint64T] "last") "val";;
          struct.storeF (Channel T) "count" "c" ((struct.loadF (Channel T) "count" "c") + #1);;
          Mutex__Unlock (struct.loadF (Channel T) "lock" "c");;
          Break));;
      #()
    else
      let: "return_early" := ref_to boolT #false in
      Skip;;
      (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
        Mutex__Lock (struct.loadF (Channel T) "lock" "c");;
        (if: struct.loadF (Channel T) "closed" "c"
        then Panic "send on closed channel"
        else #());;
        (if: struct.loadF (Channel T) "receiver_ready" "c"
        then
          struct.storeF (Channel T) "receiver_ready" "c" #false;;
          struct.storeF (Channel T) "sender_done" "c" #true;;
          struct.storeF (Channel T) "v" "c" "val";;
          Mutex__Unlock (struct.loadF (Channel T) "lock" "c");;
          "return_early" <-[boolT] #true;;
          Break
        else
          (if: (((~ (struct.loadF (Channel T) "receiver_ready" "c")) && (~ (struct.loadF (Channel T) "sender_ready" "c"))) && (~ (struct.loadF (Channel T) "receiver_done" "c"))) && (~ (struct.loadF (Channel T) "sender_done" "c"))
          then
            struct.storeF (Channel T) "v" "c" "val";;
            struct.storeF (Channel T) "sender_ready" "c" #true;;
            Mutex__Unlock (struct.loadF (Channel T) "lock" "c");;
            Break
          else
            Mutex__Unlock (struct.loadF (Channel T) "lock" "c");;
            Continue)));;
      (if: ![boolT] "return_early"
      then
        Skip;;
        (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
          Mutex__Lock (struct.loadF (Channel T) "lock" "c");;
          (if: (~ (struct.loadF (Channel T) "sender_done" "c"))
          then
            Mutex__Unlock (struct.loadF (Channel T) "lock" "c");;
            Break
          else
            Mutex__Unlock (struct.loadF (Channel T) "lock" "c");;
            Continue));;
        #()
      else
        Skip;;
        (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
          Mutex__Lock (struct.loadF (Channel T) "lock" "c");;
          (if: struct.loadF (Channel T) "closed" "c"
          then Panic "send on closed channel"
          else #());;
          (if: struct.loadF (Channel T) "receiver_done" "c"
          then
            struct.storeF (Channel T) "receiver_done" "c" #false;;
            Mutex__Unlock (struct.loadF (Channel T) "lock" "c");;
            Break
          else
            Mutex__Unlock (struct.loadF (Channel T) "lock" "c");;
            Continue));;
        #())).

(* Equivalent to:
   value, ok := <-c
   Notably, this requires the user to consume the ok bool which is not actually required with Go
   channels. This should be able to be solved by adding an overload wrapper that discards the ok
   bool. *)
Definition Channel__Receive (T:ty): val :=
  rec: "Channel__Receive" "c" :=
    (if: "c" = #null
    then
      Skip;;
      (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
        Continue)
    else #());;
    let: "ret_val" := ref (zero_val T) in
    let: "buffer_size" := ref_to uint64T (slice.len (struct.loadF (Channel T) "buffer" "c")) in
    let: "closed" := ref_to boolT #false in
    (if: (![uint64T] "buffer_size") ≠ #0
    then
      Skip;;
      (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
        Mutex__Lock (struct.loadF (Channel T) "lock" "c");;
        (if: (struct.loadF (Channel T) "closed" "c") && ((struct.loadF (Channel T) "count" "c") = #0)
        then
          Mutex__Unlock (struct.loadF (Channel T) "lock" "c");;
          "closed" <-[boolT] #true;;
          Break
        else
          (if: (struct.loadF (Channel T) "count" "c") = #0
          then
            Mutex__Unlock (struct.loadF (Channel T) "lock" "c");;
            Continue
          else
            "ret_val" <-[T] (SliceGet T (struct.loadF (Channel T) "buffer" "c") (struct.loadF (Channel T) "first" "c"));;
            struct.storeF (Channel T) "first" "c" (((struct.loadF (Channel T) "first" "c") + #1) `rem` (![uint64T] "buffer_size"));;
            struct.storeF (Channel T) "count" "c" ((struct.loadF (Channel T) "count" "c") - #1);;
            Mutex__Unlock (struct.loadF (Channel T) "lock" "c");;
            Break)));;
      (![T] "ret_val", (~ (![boolT] "closed")))
    else
      let: "return_early" := ref_to boolT #false in
      Skip;;
      (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
        Mutex__Lock (struct.loadF (Channel T) "lock" "c");;
        (if: struct.loadF (Channel T) "closed" "c"
        then
          Mutex__Unlock (struct.loadF (Channel T) "lock" "c");;
          "closed" <-[boolT] #true;;
          Break
        else
          (if: struct.loadF (Channel T) "sender_ready" "c"
          then
            struct.storeF (Channel T) "sender_ready" "c" #false;;
            struct.storeF (Channel T) "receiver_done" "c" #true;;
            "ret_val" <-[T] (struct.loadF (Channel T) "v" "c");;
            Mutex__Unlock (struct.loadF (Channel T) "lock" "c");;
            "return_early" <-[boolT] #true;;
            Break
          else
            (if: (((~ (struct.loadF (Channel T) "receiver_ready" "c")) && (~ (struct.loadF (Channel T) "sender_ready" "c"))) && (~ (struct.loadF (Channel T) "receiver_done" "c"))) && (~ (struct.loadF (Channel T) "sender_done" "c"))
            then
              struct.storeF (Channel T) "receiver_ready" "c" #true;;
              Mutex__Unlock (struct.loadF (Channel T) "lock" "c");;
              Break
            else
              Mutex__Unlock (struct.loadF (Channel T) "lock" "c");;
              Continue))));;
      (if: ![boolT] "closed"
      then (![T] "ret_val", (~ (![boolT] "closed")))
      else
        (if: ![boolT] "return_early"
        then
          Skip;;
          (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
            Mutex__Lock (struct.loadF (Channel T) "lock" "c");;
            (if: (~ (struct.loadF (Channel T) "receiver_done" "c"))
            then
              Mutex__Unlock (struct.loadF (Channel T) "lock" "c");;
              Break
            else
              Mutex__Unlock (struct.loadF (Channel T) "lock" "c");;
              Continue));;
          (![T] "ret_val", (~ (![boolT] "closed")))
        else
          Skip;;
          (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
            Mutex__Lock (struct.loadF (Channel T) "lock" "c");;
            (if: struct.loadF (Channel T) "closed" "c"
            then
              Mutex__Unlock (struct.loadF (Channel T) "lock" "c");;
              "closed" <-[boolT] #true;;
              Break
            else
              (if: struct.loadF (Channel T) "sender_done" "c"
              then
                struct.storeF (Channel T) "sender_done" "c" #false;;
                "ret_val" <-[T] (struct.loadF (Channel T) "v" "c");;
                Mutex__Unlock (struct.loadF (Channel T) "lock" "c");;
                Break
              else
                Mutex__Unlock (struct.loadF (Channel T) "lock" "c");;
                Continue)));;
          (![T] "ret_val", (~ (![boolT] "closed")))))).

(* c.Close()

   is equivalent to:

   close(c) *)
Definition Channel__Close (T:ty): val :=
  rec: "Channel__Close" "c" :=
    (if: "c" = #null
    then Panic "close of nil channel"
    else #());;
    Mutex__Lock (struct.loadF (Channel T) "lock" "c");;
    (if: struct.loadF (Channel T) "closed" "c"
    then Panic "close of closed channel"
    else #());;
    struct.storeF (Channel T) "receiver_ready" "c" #false;;
    struct.storeF (Channel T) "sender_ready" "c" #false;;
    struct.storeF (Channel T) "closed" "c" #true;;
    Mutex__Unlock (struct.loadF (Channel T) "lock" "c");;
    #().

(* v := c.ReceiveDiscardOk

   is equivalent to:
   v := c<-
   It seems like Go requires ignored return values to be annotated with _ but channels don't
   require this so this will need to be translated. *)
Definition Channel__ReceiveDiscardOk (T:ty): val :=
  rec: "Channel__ReceiveDiscardOk" "c" :=
    let: "return_val" := ref (zero_val T) in
    let: ("0_ret", "1_ret") := Channel__Receive T "c" in
    "return_val" <-[T] "0_ret";;
    "1_ret";;
    ![T] "return_val".

(* This:

   	for {
   		selected, val, ok := ch.TryReceive()
   		if !ok {
   			break
   		}
   		if selected {
   			<body>
   		}
   	}

   is equivalent to:

   	for v := <-ch {
   			<body>
   	}

   This:

   	selected, val, ok := c.TryReceive()
   	if selected {
   		<first case body>
   	} else {
   		selected = c.TrySend(0)
   		if selected {
   			<second case body>
   		} else {
   			<default block body>
   		}
   	}

   is equivalent to:

   	select {
   		case <-c:
   			<first case body>
   		case c <- 0:
   			<second case body>
   		default:
   			<default body>
   		}

   This:

   	for {
   		selected, val, ok := c.TryReceive()
   		if selected {
   			<first case body>
   			break
   		} else {
   			selected = c.TrySend(0)
   			if selected {
   				<second case body>
   				break
   			}
   		}
   	}

   is equivalent to:

   	select {
   		case <-c:
   			<first case body>
   		case c <- 0:
   			<second case body>
   		}

   Note: Technically speaking, Go only compiles select statements to if/else blocks when there is 1
   case statement with a default block. When there are multiple statements, the Go code will choose
   a case statement with uniform probability among all "selectable" statements, meaning those that
   have a waiting sender/receiver on the other end and receives on closed channels. Since threading
   behavior means that it already can't be assumed with certainty which blocks are selected, the if/
   else block translation should be equivalent from a correctness perspective. There are at least 2
   notable unsound property with this approach:
   1. Once a channel is closed, a receive case statement on said channel will always be selectable.
   This means that after the channel is closed, this case statement will always be selected above
   other statements below. This is considered an antipattern in the Go community and it is
   recommended that if a select case permits a closed channel receive, the channel is set to nil so
   that the statement will no longer be selectable. We can prevent this with the specfication by
   forcing the receiver to renounce receive ownership after receiving on a closed channel.
   2. When there are multiple blocking select statements(no default case) with 2 cases: a send and
   a receive statement on the same unbuffered channel running concurrently, this model's
   implementation will livelock since neither goroutine will communicate to the other that it is
   waiting with a matching send/receive statement, so TrySend/TryReceive will fail repeatedly. See
   TestSelfSelect in https://go.dev/src/runtime/chan_test.go for the unit test that brought
   attention to this issue.

   We will eventually be able to make this model sound for 1. once we have support for random
   permutations using a similar approach to dynamic select statements in the reflect package but for
   now our specification will prevent code that isn't equivalent from being verified which should
   be good enough.

   For 2, I believe that if we have support for random numbers we can implement blocking select
   statements with unbuffered channels by randomly selecting a case with an unbuffered channel
   using the following algorithm:
   1. Attempt each case's channel operation with TrySend/TryReceive. If one of them succeeds,
   select this case and execute its block
   2. For each case statement with an unbuffered channel, lock the associated channel
   3. Randomly select an unbuffered channel and set the sender_ready or receiver_ready flag for a
   Send/Receive operation respectively.
   4. Unlock all of the unbuffered channels
   5. Lock the channel that was chosen in step 3 and if the ready flag has been set to false,
   continue the send/receive using the same procedure as Send()/Receive(), unlock the channel and
   execute the associated case block
   6. Otherwise, unlock the channel and go back to step 1.
   This is not particularly graceful and relies on the sending thread being preempted in between
   steps 4 and 5 and the goroutine with the goroutine executing the matching select statement
   acquiring the lock in between but it should eventually be able to make progress eventually. This
   is indeed a tough edge case for real channels as well as it breaks an otherwise powerful
   invariant as described in the comment on line 10 in the runtime
   implementation(https://go.dev/src/runtime/chan.go), so I don't think there will be a
   particularly graceful solution here. I also don't know of any useful patterns that would require
   a select statement of this sort so it may be worth it to fix this problem lazily i.e. if/when a
   use case happens to call for it in the future.

   Note: The above code technically makes it so the top block's expression variables
   are in scope in all of the other blocks. This would error in the Go code before it is translated
   so this shouldn't matter for practical purposes. *)
Definition Channel__TryReceive (T:ty): val :=
  rec: "Channel__TryReceive" "c" :=
    let: "ret_val" := ref (zero_val T) in
    (if: "c" = #null
    then (#false, ![T] "ret_val", #false)
    else
      let: "buffer_size" := ref_to uint64T (slice.len (struct.loadF (Channel T) "buffer" "c")) in
      let: "closed" := ref_to boolT #false in
      let: "selected" := ref_to boolT #false in
      (if: (![uint64T] "buffer_size") ≠ #0
      then
        Mutex__Lock (struct.loadF (Channel T) "lock" "c");;
        (if: (struct.loadF (Channel T) "count" "c") = #0
        then
          (if: struct.loadF (Channel T) "closed" "c"
          then
            "closed" <-[boolT] #true;;
            "selected" <-[boolT] #true
          else #());;
          Mutex__Unlock (struct.loadF (Channel T) "lock" "c")
        else
          "ret_val" <-[T] (SliceGet T (struct.loadF (Channel T) "buffer" "c") (struct.loadF (Channel T) "first" "c"));;
          struct.storeF (Channel T) "first" "c" (((struct.loadF (Channel T) "first" "c") + #1) `rem` (![uint64T] "buffer_size"));;
          struct.storeF (Channel T) "count" "c" ((struct.loadF (Channel T) "count" "c") - #1);;
          "selected" <-[boolT] #true;;
          Mutex__Unlock (struct.loadF (Channel T) "lock" "c"));;
        (![boolT] "selected", ![T] "ret_val", (~ (![boolT] "closed")))
      else
        Mutex__Lock (struct.loadF (Channel T) "lock" "c");;
        (if: struct.loadF (Channel T) "closed" "c"
        then
          "closed" <-[boolT] #true;;
          "selected" <-[boolT] #true
        else
          (if: struct.loadF (Channel T) "sender_ready" "c"
          then
            struct.storeF (Channel T) "sender_ready" "c" #false;;
            struct.storeF (Channel T) "receiver_done" "c" #true;;
            "ret_val" <-[T] (struct.loadF (Channel T) "v" "c");;
            "selected" <-[boolT] #true
          else #()));;
        Mutex__Unlock (struct.loadF (Channel T) "lock" "c");;
        (if: ![boolT] "closed"
        then (![boolT] "selected", ![T] "ret_val", (~ (![boolT] "closed")))
        else
          (if: ![boolT] "selected"
          then
            Skip;;
            (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
              Mutex__Lock (struct.loadF (Channel T) "lock" "c");;
              (if: (~ (struct.loadF (Channel T) "receiver_done" "c"))
              then
                Mutex__Unlock (struct.loadF (Channel T) "lock" "c");;
                Break
              else
                Mutex__Unlock (struct.loadF (Channel T) "lock" "c");;
                Continue))
          else #());;
          (![boolT] "selected", ![T] "ret_val", (~ (![boolT] "closed")))))).

(* See comment in TryReceive for how this is used to translate selects. *)
Definition Channel__TrySend (T:ty): val :=
  rec: "Channel__TrySend" "c" "val" :=
    (if: "c" = #null
    then #false
    else
      let: "selected" := ref_to boolT #false in
      let: "buffer_size" := ref_to uint64T (slice.len (struct.loadF (Channel T) "buffer" "c")) in
      (if: (![uint64T] "buffer_size") ≠ #0
      then
        Mutex__Lock (struct.loadF (Channel T) "lock" "c");;
        (if: struct.loadF (Channel T) "closed" "c"
        then Panic "send on closed channel"
        else #());;
        (if: (~ ((struct.loadF (Channel T) "count" "c") ≥ (![uint64T] "buffer_size")))
        then
          let: "last" := ref_to uint64T (((struct.loadF (Channel T) "first" "c") + (struct.loadF (Channel T) "count" "c")) `rem` (![uint64T] "buffer_size")) in
          SliceSet T (struct.loadF (Channel T) "buffer" "c") (![uint64T] "last") "val";;
          struct.storeF (Channel T) "count" "c" ((struct.loadF (Channel T) "count" "c") + #1);;
          "selected" <-[boolT] #true
        else #());;
        Mutex__Unlock (struct.loadF (Channel T) "lock" "c");;
        ![boolT] "selected"
      else
        Mutex__Lock (struct.loadF (Channel T) "lock" "c");;
        (if: struct.loadF (Channel T) "closed" "c"
        then Panic "send on closed channel"
        else #());;
        (if: struct.loadF (Channel T) "receiver_ready" "c"
        then
          struct.storeF (Channel T) "receiver_ready" "c" #false;;
          struct.storeF (Channel T) "sender_done" "c" #true;;
          struct.storeF (Channel T) "v" "c" "val";;
          "selected" <-[boolT] #true
        else #());;
        Mutex__Unlock (struct.loadF (Channel T) "lock" "c");;
        (if: ![boolT] "selected"
        then
          Skip;;
          (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
            Mutex__Lock (struct.loadF (Channel T) "lock" "c");;
            (if: (~ (struct.loadF (Channel T) "sender_done" "c"))
            then Break
            else
              Mutex__Unlock (struct.loadF (Channel T) "lock" "c");;
              Continue))
        else #());;
        ![boolT] "selected")).

(* c.Len()

   is equivalent to:
   len(c)

   This might not be worth specifying since it is hard to make good use of channel length
   semantics. *)
Definition Channel__Len (T:ty): val :=
  rec: "Channel__Len" "c" :=
    (if: "c" = #null
    then #0
    else
      let: "chan_len" := ref_to uint64T #0 in
      Mutex__Lock (struct.loadF (Channel T) "lock" "c");;
      "chan_len" <-[uint64T] (struct.loadF (Channel T) "count" "c");;
      Mutex__Unlock (struct.loadF (Channel T) "lock" "c");;
      ![uint64T] "chan_len").

(* c.Cap()

   is equivalent to:
   cap(c) *)
Definition Channel__Cap (T:ty): val :=
  rec: "Channel__Cap" "c" :=
    (if: "c" = #null
    then #0
    else slice.len (struct.loadF (Channel T) "buffer" "c")).

End goose_lang.
