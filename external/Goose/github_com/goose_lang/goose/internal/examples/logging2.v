(* autogenerated from github.com/goose-lang/goose/internal/examples/logging2 *)
From Perennial.goose_lang Require Import prelude.

From Perennial.goose_lang Require Import ffi.disk_prelude.

(* logging2.go *)

Definition LOGCOMMIT : expr := #0.

Definition LOGSTART : expr := #1.

Definition LOGMAXBLK : expr := #510.

Definition LOGEND : expr := LOGMAXBLK + LOGSTART.

Definition Log := struct.decl [
  "logLock" :: ptrT;
  "memLock" :: ptrT;
  "logSz" :: uint64T;
  "memLog" :: ptrT;
  "memLen" :: ptrT;
  "memTxnNxt" :: ptrT;
  "logTxnNxt" :: ptrT
].

Definition Log__writeHdr: val :=
  rec: "Log__writeHdr" "log" "len" :=
    let: "hdr" := NewSlice byteT #4096 in
    UInt64Put "hdr" "len";;
    disk.Write LOGCOMMIT "hdr";;
    #().

Definition Init: val :=
  rec: "Init" "logSz" :=
    let: "log" := struct.mk Log [
      "logLock" ::= newMutex #();
      "memLock" ::= newMutex #();
      "logSz" ::= "logSz";
      "memLog" ::= ref (zero_val (slice.T disk.blockT));
      "memLen" ::= ref (zero_val uint64T);
      "memTxnNxt" ::= ref (zero_val uint64T);
      "logTxnNxt" ::= ref (zero_val uint64T)
    ] in
    Log__writeHdr "log" #0;;
    "log".

Definition Log__readHdr: val :=
  rec: "Log__readHdr" "log" :=
    let: "hdr" := disk.Read LOGCOMMIT in
    let: "disklen" := UInt64Get "hdr" in
    "disklen".

Definition Log__readBlocks: val :=
  rec: "Log__readBlocks" "log" "len" :=
    let: "blks" := ref_to (slice.T (slice.T byteT)) (NewSlice disk.blockT #0) in
    let: "i" := ref_to uint64T #0 in
    (for: (λ: <>, (![uint64T] "i") < "len"); (λ: <>, "i" <-[uint64T] ((![uint64T] "i") + #1)) := λ: <>,
      let: "blk" := disk.Read (LOGSTART + (![uint64T] "i")) in
      "blks" <-[slice.T (slice.T byteT)] (SliceAppend (slice.T byteT) (![slice.T (slice.T byteT)] "blks") "blk");;
      Continue);;
    ![slice.T (slice.T byteT)] "blks".

Definition Log__Read: val :=
  rec: "Log__Read" "log" :=
    Mutex__Lock (struct.get Log "logLock" "log");;
    let: "disklen" := Log__readHdr "log" in
    let: "blks" := Log__readBlocks "log" "disklen" in
    Mutex__Unlock (struct.get Log "logLock" "log");;
    "blks".

Definition Log__memWrite: val :=
  rec: "Log__memWrite" "log" "l" :=
    let: "n" := slice.len "l" in
    let: "i" := ref_to uint64T #0 in
    (for: (λ: <>, (![uint64T] "i") < "n"); (λ: <>, "i" <-[uint64T] ((![uint64T] "i") + #1)) := λ: <>,
      (struct.get Log "memLog" "log") <-[slice.T (slice.T byteT)] (SliceAppend (slice.T byteT) (![slice.T (slice.T byteT)] (struct.get Log "memLog" "log")) (SliceGet (slice.T byteT) "l" (![uint64T] "i")));;
      Continue);;
    #().

Definition Log__memAppend: val :=
  rec: "Log__memAppend" "log" "l" :=
    Mutex__Lock (struct.get Log "memLock" "log");;
    (if: ((![uint64T] (struct.get Log "memLen" "log")) + (slice.len "l")) ≥ (struct.get Log "logSz" "log")
    then
      Mutex__Unlock (struct.get Log "memLock" "log");;
      (#false, #0)
    else
      let: "txn" := ![uint64T] (struct.get Log "memTxnNxt" "log") in
      let: "n" := (![uint64T] (struct.get Log "memLen" "log")) + (slice.len "l") in
      (struct.get Log "memLen" "log") <-[uint64T] "n";;
      (struct.get Log "memTxnNxt" "log") <-[uint64T] ((![uint64T] (struct.get Log "memTxnNxt" "log")) + #1);;
      Mutex__Unlock (struct.get Log "memLock" "log");;
      (#true, "txn")).

(* XXX just an atomic read? *)
Definition Log__readLogTxnNxt: val :=
  rec: "Log__readLogTxnNxt" "log" :=
    Mutex__Lock (struct.get Log "memLock" "log");;
    let: "n" := ![uint64T] (struct.get Log "logTxnNxt" "log") in
    Mutex__Unlock (struct.get Log "memLock" "log");;
    "n".

Definition Log__diskAppendWait: val :=
  rec: "Log__diskAppendWait" "log" "txn" :=
    Skip;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "logtxn" := Log__readLogTxnNxt "log" in
      (if: "txn" < "logtxn"
      then Break
      else Continue));;
    #().

Definition Log__Append: val :=
  rec: "Log__Append" "log" "l" :=
    let: ("ok", "txn") := Log__memAppend "log" "l" in
    (if: "ok"
    then Log__diskAppendWait "log" "txn"
    else #());;
    "ok".

Definition Log__writeBlocks: val :=
  rec: "Log__writeBlocks" "log" "l" "pos" :=
    let: "n" := slice.len "l" in
    let: "i" := ref_to uint64T #0 in
    (for: (λ: <>, (![uint64T] "i") < "n"); (λ: <>, "i" <-[uint64T] ((![uint64T] "i") + #1)) := λ: <>,
      let: "bk" := SliceGet (slice.T byteT) "l" (![uint64T] "i") in
      disk.Write ("pos" + (![uint64T] "i")) "bk";;
      Continue);;
    #().

Definition Log__diskAppend: val :=
  rec: "Log__diskAppend" "log" :=
    Mutex__Lock (struct.get Log "logLock" "log");;
    let: "disklen" := Log__readHdr "log" in
    Mutex__Lock (struct.get Log "memLock" "log");;
    let: "memlen" := ![uint64T] (struct.get Log "memLen" "log") in
    let: "allblks" := ![slice.T (slice.T byteT)] (struct.get Log "memLog" "log") in
    let: "blks" := SliceSkip (slice.T byteT) "allblks" "disklen" in
    let: "memnxt" := ![uint64T] (struct.get Log "memTxnNxt" "log") in
    Mutex__Unlock (struct.get Log "memLock" "log");;
    Log__writeBlocks "log" "blks" "disklen";;
    Log__writeHdr "log" "memlen";;
    (struct.get Log "logTxnNxt" "log") <-[uint64T] "memnxt";;
    Mutex__Unlock (struct.get Log "logLock" "log");;
    #().

Definition Log__Logger: val :=
  rec: "Log__Logger" "log" :=
    Skip;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      Log__diskAppend "log";;
      Continue);;
    #().

(* txn.go *)

Definition Txn := struct.decl [
  "log" :: ptrT;
  "blks" :: mapT disk.blockT
].

(* XXX wait if cannot reserve space in log *)
Definition Begin: val :=
  rec: "Begin" "log" :=
    let: "txn" := struct.mk Txn [
      "log" ::= "log";
      "blks" ::= NewMap uint64T disk.blockT #()
    ] in
    "txn".

Definition Txn__Write: val :=
  rec: "Txn__Write" "txn" "addr" "blk" :=
    let: "ret" := ref_to boolT #true in
    let: (<>, "ok") := MapGet (struct.get Txn "blks" "txn") "addr" in
    (if: "ok"
    then MapInsert (struct.get Txn "blks" "txn") "addr" (![slice.T byteT] "blk")
    else #());;
    (if: (~ "ok")
    then
      (if: "addr" = LOGMAXBLK
      then "ret" <-[boolT] #false
      else MapInsert (struct.get Txn "blks" "txn") "addr" (![slice.T byteT] "blk"))
    else #());;
    ![boolT] "ret".

Definition Txn__Read: val :=
  rec: "Txn__Read" "txn" "addr" :=
    let: ("v", "ok") := MapGet (struct.get Txn "blks" "txn") "addr" in
    (if: "ok"
    then "v"
    else disk.Read ("addr" + LOGEND)).

Definition Txn__Commit: val :=
  rec: "Txn__Commit" "txn" :=
    let: "blks" := ref (zero_val (slice.T disk.blockT)) in
    MapIter (struct.get Txn "blks" "txn") (λ: <> "v",
      "blks" <-[slice.T (slice.T byteT)] (SliceAppend (slice.T byteT) (![slice.T (slice.T byteT)] "blks") "v"));;
    let: "ok" := Log__Append (struct.load Log (struct.get Txn "log" "txn")) (![slice.T (slice.T byteT)] "blks") in
    "ok".
