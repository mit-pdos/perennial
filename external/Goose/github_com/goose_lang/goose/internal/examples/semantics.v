(* autogenerated from github.com/goose-lang/goose/internal/examples/semantics *)
From Perennial.goose_lang Require Import prelude.

From Perennial.goose_lang Require Import ffi.disk_prelude.

(* allocator.go *)

Definition unit := struct.decl [
].

Definition findKey: val :=
  rec: "findKey" "m" :=
    let: "found" := ref_to uint64T #0 in
    let: "ok" := ref_to boolT #false in
    MapIter "m" (λ: "k" <>,
      (if: (~ (![boolT] "ok"))
      then
        "found" <-[uint64T] "k";;
        "ok" <-[boolT] #true
      else #()));;
    (![uint64T] "found", ![boolT] "ok").

Definition allocate: val :=
  rec: "allocate" "m" :=
    let: ("k", "ok") := findKey "m" in
    MapDelete "m" "k";;
    ("k", "ok").

Definition freeRange: val :=
  rec: "freeRange" "sz" :=
    let: "m" := NewMap uint64T (struct.t unit) #() in
    let: "i" := ref_to uint64T #0 in
    (for: (λ: <>, (![uint64T] "i") < "sz"); (λ: <>, "i" <-[uint64T] ((![uint64T] "i") + #1)) := λ: <>,
      MapInsert "m" (![uint64T] "i") (struct.mk unit [
      ]);;
      Continue);;
    "m".

Definition testAllocateDistinct: val :=
  rec: "testAllocateDistinct" <> :=
    let: "free" := freeRange #4 in
    let: ("a1", <>) := allocate "free" in
    let: ("a2", <>) := allocate "free" in
    "a1" ≠ "a2".

Definition testAllocateFull: val :=
  rec: "testAllocateFull" <> :=
    let: "free" := freeRange #2 in
    let: (<>, "ok1") := allocate "free" in
    let: (<>, "ok2") := allocate "free" in
    let: (<>, "ok3") := allocate "free" in
    ("ok1" && "ok2") && (~ "ok3").

(* append.go *)

Definition testSingleAppend: val :=
  rec: "testSingleAppend" <> :=
    let: "ok" := ref_to boolT #true in
    let: "a" := ref (zero_val (slice.T uint64T)) in
    "a" <-[slice.T uint64T] (SliceAppend uint64T (![slice.T uint64T] "a") #1);;
    "ok" <-[boolT] ((![boolT] "ok") && ((SliceGet uint64T (![slice.T uint64T] "a") #0) = #1));;
    ![boolT] "ok".

Definition testAppendToCapacity: val :=
  rec: "testAppendToCapacity" <> :=
    let: "ok" := ref_to boolT #true in
    let: "a" := ref (zero_val (slice.T uint64T)) in
    "a" <-[slice.T uint64T] (NewSliceWithCap uint64T #0 #1);;
    "a" <-[slice.T uint64T] (SliceAppend uint64T (![slice.T uint64T] "a") #1);;
    "ok" <-[boolT] ((![boolT] "ok") && ((SliceGet uint64T (![slice.T uint64T] "a") #0) = #1));;
    ![boolT] "ok".

Definition testAppendSlice: val :=
  rec: "testAppendSlice" <> :=
    let: "ok" := ref_to boolT #true in
    let: "a" := ref (zero_val (slice.T uint64T)) in
    let: "b" := ref (zero_val (slice.T uint64T)) in
    "b" <-[slice.T uint64T] (SliceAppend uint64T (![slice.T uint64T] "b") #1);;
    "b" <-[slice.T uint64T] (SliceAppend uint64T (![slice.T uint64T] "b") #2);;
    "a" <-[slice.T uint64T] (SliceAppendSlice uint64T (![slice.T uint64T] "a") (![slice.T uint64T] "b"));;
    "ok" <-[boolT] (((![boolT] "ok") && ((SliceGet uint64T (![slice.T uint64T] "a") #0) = #1)) && ((SliceGet uint64T (![slice.T uint64T] "a") #1) = #2));;
    ![boolT] "ok".

(* assign_ops.go *)

Definition testAssignAddSub: val :=
  rec: "testAssignAddSub" <> :=
    let: "ok" := ref_to boolT #true in
    let: "x" := ref_to uint64T #1 in
    "x" <-[uint64T] ((![uint64T] "x") + #5);;
    "ok" <-[boolT] ((![boolT] "ok") && ((![uint64T] "x") = #6));;
    "x" <-[uint64T] ((![uint64T] "x") - #3);;
    "ok" <-[boolT] ((![boolT] "ok") && ((![uint64T] "x") = #3));;
    ![boolT] "ok".

Definition testAssignBitwise: val :=
  rec: "testAssignBitwise" <> :=
    let: "ok" := ref_to boolT #true in
    let: "x" := ref_to uint64T #123 in
    "x" <-[uint64T] ((![uint64T] "x") `or` #31);;
    "ok" <-[boolT] ((![boolT] "ok") && ((![uint64T] "x") = (#123 `or` #31)));;
    "x" <-[uint64T] ((![uint64T] "x") `and` #15);;
    "ok" <-[boolT] ((![boolT] "ok") && ((![uint64T] "x") = ((#123 `or` #31) `and` #15)));;
    "x" <-[uint64T] ((![uint64T] "x") `xor` #170);;
    "ok" <-[boolT] ((![boolT] "ok") && ((![uint64T] "x") = (((#123 `or` #31) `and` #15) `xor` #170)));;
    ![boolT] "ok".

(* atomic.go *)

Definition testAtomicLoadStore64: val :=
  rec: "testAtomicLoadStore64" <> :=
    let: "x" := ref (zero_val uint64T) in
    let: "ok" := ref_to boolT #true in
    atomic.StoreUint64 "x" #42;;
    let: "y" := atomic.LoadUint64 "x" in
    "ok" <-[boolT] ((![boolT] "ok") && ("y" = #42));;
    atomic.StoreUint64 "x" #1;;
    let: "z" := atomic.LoadUint64 "x" in
    "ok" <-[boolT] ((![boolT] "ok") && ("z" = #1));;
    ![boolT] "ok".

Definition testAtomicPointers: val :=
  rec: "testAtomicPointers" <> :=
    let: "p" := ref (zero_val ptrT) in
    let: "x" := ref (zero_val uint64T) in
    atomic.Pointer__Store uint64T "p" "x";;
    let: "y" := atomic.Pointer__Load uint64T "p" in
    "y" <-[uint64T] #1;;
    let: "ok" := ref_to boolT #true in
    "ok" <-[boolT] ((![boolT] "ok") && ((![uint64T] "x") = #1));;
    ![boolT] "ok".

(* closures.go *)

Notation AdderType := (uint64T -> uint64T)%ht (only parsing).

Notation MultipleArgsType := (uint64T -> boolT -> uint64T)%ht (only parsing).

Definition adder: val :=
  rec: "adder" <> :=
    let: "sum" := ref_to uint64T #0 in
    (λ: "x",
      "sum" <-[uint64T] ((![uint64T] "sum") + "x");;
      ![uint64T] "sum"
      ).

Definition testClosureBasic: val :=
  rec: "testClosureBasic" <> :=
    let: "pos" := adder #() in
    let: "doub" := adder #() in
    let: "i" := ref_to uint64T #0 in
    (for: (λ: <>, (![uint64T] "i") < #10); (λ: <>, "i" <-[uint64T] ((![uint64T] "i") + #1)) := λ: <>,
      "pos" (![uint64T] "i");;
      "doub" (#2 * (![uint64T] "i"));;
      Continue);;
    (if: (("pos" #0) = #45) && (("doub" #0) = #90)
    then #true
    else #false).

(* comparisons.go *)

Definition testCompareAll: val :=
  rec: "testCompareAll" <> :=
    let: "ok" := ref_to boolT #true in
    let: "nok" := ref_to boolT #false in
    "ok" <-[boolT] ((![boolT] "ok") && (#1 < #2));;
    "nok" <-[boolT] ((![boolT] "ok") && (#2 < #1));;
    "ok" <-[boolT] ((![boolT] "ok") && (#1 ≤ #2));;
    "ok" <-[boolT] ((![boolT] "ok") && (#2 ≤ #2));;
    "nok" <-[boolT] ((![boolT] "ok") && (#2 ≤ #1));;
    (if: ![boolT] "nok"
    then #false
    else ![boolT] "ok").

Definition testCompareGT: val :=
  rec: "testCompareGT" <> :=
    let: "x" := ref_to uint64T #4 in
    let: "y" := ref_to uint64T #5 in
    let: "ok" := ref_to boolT #true in
    "ok" <-[boolT] ((![boolT] "ok") && ((![uint64T] "y") > #4));;
    "ok" <-[boolT] ((![boolT] "ok") && ((![uint64T] "y") > (![uint64T] "x")));;
    ![boolT] "ok".

Definition testCompareGE: val :=
  rec: "testCompareGE" <> :=
    let: "x" := ref_to uint64T #4 in
    let: "y" := ref_to uint64T #5 in
    let: "ok" := ref_to boolT #true in
    "ok" <-[boolT] ((![boolT] "ok") && ((![uint64T] "y") ≥ #4));;
    "ok" <-[boolT] ((![boolT] "ok") && ((![uint64T] "y") ≥ #5));;
    "ok" <-[boolT] ((![boolT] "ok") && ((![uint64T] "y") ≥ (![uint64T] "x")));;
    (if: (![uint64T] "y") > #5
    then #false
    else ![boolT] "ok").

Definition testCompareLT: val :=
  rec: "testCompareLT" <> :=
    let: "x" := ref_to uint64T #4 in
    let: "y" := ref_to uint64T #5 in
    let: "ok" := ref_to boolT #true in
    "ok" <-[boolT] ((![boolT] "ok") && ((![uint64T] "y") < #6));;
    "ok" <-[boolT] ((![boolT] "ok") && ((![uint64T] "x") < (![uint64T] "y")));;
    ![boolT] "ok".

Definition testCompareLE: val :=
  rec: "testCompareLE" <> :=
    let: "x" := ref_to uint64T #4 in
    let: "y" := ref_to uint64T #5 in
    let: "ok" := ref_to boolT #true in
    "ok" <-[boolT] ((![boolT] "ok") && ((![uint64T] "y") ≤ #6));;
    "ok" <-[boolT] ((![boolT] "ok") && ((![uint64T] "y") ≤ #5));;
    "ok" <-[boolT] ((![boolT] "ok") && ((![uint64T] "x") ≤ (![uint64T] "y")));;
    (if: (![uint64T] "y") < #5
    then #false
    else ![boolT] "ok").

(* conversions.go *)

Definition literalCast: val :=
  rec: "literalCast" <> :=
    let: "x" := #2 in
    "x" + #2.

Definition stringToByteSlice: val :=
  rec: "stringToByteSlice" "s" :=
    let: "p" := StringToBytes "s" in
    "p".

Definition byteSliceToString: val :=
  rec: "byteSliceToString" "p" :=
    StringFromBytes "p".

(* tests *)
Definition testByteSliceToString: val :=
  rec: "testByteSliceToString" <> :=
    let: "x" := NewSlice byteT #3 in
    SliceSet byteT "x" #0 #(U8 65);;
    SliceSet byteT "x" #1 #(U8 66);;
    SliceSet byteT "x" #2 #(U8 67);;
    (byteSliceToString "x") = #(str"ABC").

Notation args := stringT (only parsing).

Definition testStringToByteSliceAlias: val :=
  rec: "testStringToByteSliceAlias" <> :=
    let: "x" := #(str"ABC") in
    (SliceGet byteT (StringToBytes "x") #0) = #(U8 65).

(* copy.go *)

Definition testCopySimple: val :=
  rec: "testCopySimple" <> :=
    let: "x" := NewSlice byteT #10 in
    SliceSet byteT "x" #3 #(U8 1);;
    let: "y" := NewSlice byteT #10 in
    SliceCopy byteT "y" "x";;
    (SliceGet byteT "y" #3) = #(U8 1).

Definition testCopyShorterDst: val :=
  rec: "testCopyShorterDst" <> :=
    let: "x" := NewSlice byteT #15 in
    SliceSet byteT "x" #3 #(U8 1);;
    SliceSet byteT "x" #12 #(U8 2);;
    let: "y" := NewSlice byteT #10 in
    let: "n" := SliceCopy byteT "y" "x" in
    ("n" = #10) && ((SliceGet byteT "y" #3) = #(U8 1)).

Definition testCopyShorterSrc: val :=
  rec: "testCopyShorterSrc" <> :=
    let: "x" := NewSlice byteT #10 in
    let: "y" := NewSlice byteT #15 in
    SliceSet byteT "x" #3 #(U8 1);;
    SliceSet byteT "y" #12 #(U8 2);;
    let: "n" := SliceCopy byteT "y" "x" in
    (("n" = #10) && ((SliceGet byteT "y" #3) = #(U8 1))) && ((SliceGet byteT "y" #12) = #(U8 2)).

(* encoding.go *)

(* helpers *)
Definition Enc := struct.decl [
  "p" :: slice.T byteT
].

Definition Enc__consume: val :=
  rec: "Enc__consume" "e" "n" :=
    let: "b" := SliceTake (struct.loadF Enc "p" "e") "n" in
    struct.storeF Enc "p" "e" (SliceSkip byteT (struct.loadF Enc "p" "e") "n");;
    "b".

Definition Dec := struct.decl [
  "p" :: slice.T byteT
].

Definition Dec__consume: val :=
  rec: "Dec__consume" "d" "n" :=
    let: "b" := SliceTake (struct.loadF Dec "p" "d") "n" in
    struct.storeF Dec "p" "d" (SliceSkip byteT (struct.loadF Dec "p" "d") "n");;
    "b".

Definition roundtripEncDec32: val :=
  rec: "roundtripEncDec32" "x" :=
    let: "r" := NewSlice byteT #4 in
    let: "e" := struct.new Enc [
      "p" ::= "r"
    ] in
    let: "d" := struct.new Dec [
      "p" ::= "r"
    ] in
    UInt32Put (Enc__consume "e" #4) "x";;
    UInt32Get (Dec__consume "d" #4).

Definition roundtripEncDec64: val :=
  rec: "roundtripEncDec64" "x" :=
    let: "r" := NewSlice byteT #8 in
    let: "e" := struct.new Enc [
      "p" ::= "r"
    ] in
    let: "d" := struct.new Dec [
      "p" ::= "r"
    ] in
    UInt64Put (Enc__consume "e" #8) "x";;
    UInt64Get (Dec__consume "d" #8).

(* tests *)
Definition testEncDec32Simple: val :=
  rec: "testEncDec32Simple" <> :=
    let: "ok" := ref_to boolT #true in
    "ok" <-[boolT] ((![boolT] "ok") && ((roundtripEncDec32 #(U32 0)) = #(U32 0)));;
    "ok" <-[boolT] ((![boolT] "ok") && ((roundtripEncDec32 #(U32 1)) = #(U32 1)));;
    "ok" <-[boolT] ((![boolT] "ok") && ((roundtripEncDec32 #(U32 1231234)) = #(U32 1231234)));;
    ![boolT] "ok".

Definition failing_testEncDec32: val :=
  rec: "failing_testEncDec32" <> :=
    let: "ok" := ref_to boolT #true in
    "ok" <-[boolT] ((![boolT] "ok") && ((roundtripEncDec32 #(U32 3434807466)) = #(U32 3434807466)));;
    "ok" <-[boolT] ((![boolT] "ok") && ((roundtripEncDec32 (#1 ≪ #20)) = (#1 ≪ #20)));;
    "ok" <-[boolT] ((![boolT] "ok") && ((roundtripEncDec32 (#1 ≪ #18)) = (#1 ≪ #18)));;
    "ok" <-[boolT] ((![boolT] "ok") && ((roundtripEncDec32 (#1 ≪ #10)) = (#1 ≪ #10)));;
    "ok" <-[boolT] ((![boolT] "ok") && ((roundtripEncDec32 (#1 ≪ #0)) = (#1 ≪ #0)));;
    "ok" <-[boolT] ((![boolT] "ok") && ((roundtripEncDec32 ((#1 ≪ #32) - #1)) = ((#1 ≪ #32) - #1)));;
    ![boolT] "ok".

Definition testEncDec64Simple: val :=
  rec: "testEncDec64Simple" <> :=
    let: "ok" := ref_to boolT #true in
    "ok" <-[boolT] ((![boolT] "ok") && ((roundtripEncDec64 #0) = #0));;
    "ok" <-[boolT] ((![boolT] "ok") && ((roundtripEncDec64 #1) = #1));;
    "ok" <-[boolT] ((![boolT] "ok") && ((roundtripEncDec64 #1231234) = #1231234));;
    ![boolT] "ok".

Definition testEncDec64: val :=
  rec: "testEncDec64" <> :=
    let: "ok" := ref_to boolT #true in
    "ok" <-[boolT] ((![boolT] "ok") && ((roundtripEncDec64 #62206846038638762) = #62206846038638762));;
    "ok" <-[boolT] ((![boolT] "ok") && ((roundtripEncDec64 (#1 ≪ #63)) = (#1 ≪ #63)));;
    "ok" <-[boolT] ((![boolT] "ok") && ((roundtripEncDec64 (#1 ≪ #47)) = (#1 ≪ #47)));;
    "ok" <-[boolT] ((![boolT] "ok") && ((roundtripEncDec64 (#1 ≪ #20)) = (#1 ≪ #20)));;
    "ok" <-[boolT] ((![boolT] "ok") && ((roundtripEncDec64 (#1 ≪ #18)) = (#1 ≪ #18)));;
    "ok" <-[boolT] ((![boolT] "ok") && ((roundtripEncDec64 (#1 ≪ #10)) = (#1 ≪ #10)));;
    "ok" <-[boolT] ((![boolT] "ok") && ((roundtripEncDec64 (#1 ≪ #0)) = (#1 ≪ #0)));;
    "ok" <-[boolT] ((![boolT] "ok") && ((roundtripEncDec64 ((#1 ≪ #64) - #1)) = ((#1 ≪ #64) - #1)));;
    ![boolT] "ok".

(* first_class_function.go *)

Definition FirstClassFunction: val :=
  rec: "FirstClassFunction" "a" :=
    "a" + #10.

Definition ApplyF: val :=
  rec: "ApplyF" "a" "f" :=
    "f" "a".

Definition testFirstClassFunction: val :=
  rec: "testFirstClassFunction" <> :=
    (ApplyF #1 FirstClassFunction) = #11.

(* function_ordering.go *)

(* helpers *)
Definition Editor := struct.decl [
  "s" :: slice.T uint64T;
  "next_val" :: uint64T
].

(* advances the array editor, and returns the value it wrote, storing
   "next" in next_val *)
Definition Editor__AdvanceReturn: val :=
  rec: "Editor__AdvanceReturn" "e" "next" :=
    let: "tmp" := ref_to uint64T (struct.loadF Editor "next_val" "e") in
    SliceSet uint64T (struct.loadF Editor "s" "e") #0 (![uint64T] "tmp");;
    struct.storeF Editor "next_val" "e" "next";;
    struct.storeF Editor "s" "e" (SliceSkip uint64T (struct.loadF Editor "s" "e") #1);;
    ![uint64T] "tmp".

(* we call this function with side-effectful function calls as arguments,
   its implementation is unimportant *)
Definition addFour64: val :=
  rec: "addFour64" "a" "b" "c" "d" :=
    (("a" + "b") + "c") + "d".

Definition Pair := struct.decl [
  "x" :: uint64T;
  "y" :: uint64T
].

(* tests *)
Definition failing_testFunctionOrdering: val :=
  rec: "failing_testFunctionOrdering" <> :=
    let: "arr" := ref_to (slice.T uint64T) (NewSlice uint64T #5) in
    let: "e1" := struct.mk Editor [
      "s" ::= SliceSkip uint64T (![slice.T uint64T] "arr") #0;
      "next_val" ::= #1
    ] in
    let: "e2" := struct.mk Editor [
      "s" ::= SliceSkip uint64T (![slice.T uint64T] "arr") #0;
      "next_val" ::= #101
    ] in
    (if: ((Editor__AdvanceReturn "e1" #2) + (Editor__AdvanceReturn "e2" #102)) ≠ #102
    then #false
    else
      (if: (SliceGet uint64T (![slice.T uint64T] "arr") #0) ≠ #101
      then #false
      else
        (if: (addFour64 (Editor__AdvanceReturn "e1" #3) (Editor__AdvanceReturn "e2" #103) (Editor__AdvanceReturn "e2" #104) (Editor__AdvanceReturn "e1" #4)) ≠ #210
        then #false
        else
          (if: (SliceGet uint64T (![slice.T uint64T] "arr") #1) ≠ #102
          then #false
          else
            (if: (SliceGet uint64T (![slice.T uint64T] "arr") #2) ≠ #3
            then #false
            else
              let: "p" := struct.mk Pair [
                "x" ::= Editor__AdvanceReturn "e1" #5;
                "y" ::= Editor__AdvanceReturn "e2" #105
              ] in
              (if: (SliceGet uint64T (![slice.T uint64T] "arr") #3) ≠ #104
              then #false
              else
                let: "q" := struct.mk Pair [
                  "y" ::= Editor__AdvanceReturn "e1" #6;
                  "x" ::= Editor__AdvanceReturn "e2" #106
                ] in
                (if: (SliceGet uint64T (![slice.T uint64T] "arr") #4) ≠ #105
                then #false
                else ((struct.get Pair "x" "p") + (struct.get Pair "x" "q")) = #109))))))).

Definition storeAndReturn: val :=
  rec: "storeAndReturn" "x" "v" :=
    "x" <-[uint64T] "v";;
    "v".

(* Goose has a right-to-left evaluation order for function arguments,
   which is incorrect. *)
Definition failing_testArgumentOrder: val :=
  rec: "failing_testArgumentOrder" <> :=
    let: "x" := ref_to uint64T #0 in
    addFour64 (storeAndReturn "x" #1) (storeAndReturn "x" #2) (storeAndReturn "x" #3) (storeAndReturn "x" #4);;
    let: "ok" := (![uint64T] "x") = #4 in
    "ok".

(* generics.go *)

Definition pair := struct.decl [
  "a" :: uint64T;
  "b" :: uint64T
].

Definition newGeneric (T:ty): val :=
  rec: "newGeneric" <> :=
    ref (zero_val T).

Definition storeAndLoadGeneric (T:ty): val :=
  rec: "storeAndLoadGeneric" "t" "v" :=
    "t" <-[T] "v";;
    ![T] "t".

Definition testGenerics: val :=
  rec: "testGenerics" <> :=
    let: "x" := newGeneric (struct.t pair) #() in
    let: "res" := storeAndLoadGeneric (struct.t pair) "x" (struct.mk pair [
      "a" ::= #10;
      "b" ::= #37
    ]) in
    ((struct.get pair "a" "res") = #10) && ((struct.get pair "b" "res") = #37).

(* int_conversions.go *)

Definition testU64ToU32: val :=
  rec: "testU64ToU32" <> :=
    let: "ok" := ref_to boolT #true in
    let: "x" := #1230 in
    let: "y" := #(U32 1230) in
    "ok" <-[boolT] ((![boolT] "ok") && ((to_u32 "x") = "y"));;
    "ok" <-[boolT] ((![boolT] "ok") && ((to_u64 "y") = "x"));;
    ![boolT] "ok".

Definition testU32Len: val :=
  rec: "testU32Len" <> :=
    let: "s" := NewSlice byteT #100 in
    (to_u32 (slice.len "s")) = #(U32 100).

Definition Uint32: ty := uint32T.

(* https://github.com/goose-lang/goose/issues/14 *)
Definition failing_testU32NewtypeLen: val :=
  rec: "failing_testU32NewtypeLen" <> :=
    let: "s" := NewSlice byteT #20 in
    (slice.len "s") = #(U32 20).

(* interfaces.go *)

Definition geometryInterface := struct.decl [
  "Square" :: (unitT -> uint64T)%ht;
  "Volume" :: (unitT -> uint64T)%ht
].

Definition measureArea: val :=
  rec: "measureArea" "t" :=
    (struct.get geometryInterface "Square") "t".

Definition measureVolumePlusNM: val :=
  rec: "measureVolumePlusNM" "t" "n" "m" :=
    (((struct.get geometryInterface "Volume") "t") + "n") + "m".

Definition measureVolume: val :=
  rec: "measureVolume" "t" :=
    (struct.get geometryInterface "Volume") "t".

Definition SquareStruct := struct.decl [
  "Side" :: uint64T
].

Definition SquareStruct__Square: val :=
  rec: "SquareStruct__Square" "t" :=
    (struct.get SquareStruct "Side" "t") * (struct.get SquareStruct "Side" "t").

Definition SquareStruct__Volume: val :=
  rec: "SquareStruct__Volume" "t" :=
    ((struct.get SquareStruct "Side" "t") * (struct.get SquareStruct "Side" "t")) * (struct.get SquareStruct "Side" "t").

Definition SquareStruct__to__geometryInterface: val :=
  rec: "SquareStruct_to_geometryInterface" "t" :=
    struct.mk geometryInterface [
      "Square" ::= SquareStruct__Square "t";
      "Volume" ::= SquareStruct__Volume "t"
    ].

Definition testBasicInterface: val :=
  rec: "testBasicInterface" <> :=
    let: "s" := struct.mk SquareStruct [
      "Side" ::= #2
    ] in
    ((measureArea (SquareStruct__to__geometryInterface "s"))) = #4.

Definition testAssignInterface: val :=
  rec: "testAssignInterface" <> :=
    let: "s" := struct.mk SquareStruct [
      "Side" ::= #3
    ] in
    let: "area" := (measureArea (SquareStruct__to__geometryInterface "s")) in
    "area" = #9.

Definition testMultipleInterface: val :=
  rec: "testMultipleInterface" <> :=
    let: "s" := struct.mk SquareStruct [
      "Side" ::= #3
    ] in
    let: "square1" := (measureArea (SquareStruct__to__geometryInterface "s")) in
    let: "square2" := (measureArea (SquareStruct__to__geometryInterface "s")) in
    "square1" = "square2".

Definition testBinaryExprInterface: val :=
  rec: "testBinaryExprInterface" <> :=
    let: "s" := struct.mk SquareStruct [
      "Side" ::= #3
    ] in
    let: "square1" := (measureArea (SquareStruct__to__geometryInterface "s")) in
    let: "square2" := (measureVolume (SquareStruct__to__geometryInterface "s")) in
    ("square1" = ((measureArea (SquareStruct__to__geometryInterface "s")))) && ("square2" = ((measureVolume (SquareStruct__to__geometryInterface "s")))).

Definition testIfStmtInterface: val :=
  rec: "testIfStmtInterface" <> :=
    let: "s" := struct.mk SquareStruct [
      "Side" ::= #3
    ] in
    (if: ((measureArea (SquareStruct__to__geometryInterface "s"))) = #9
    then #true
    else #false).

(* interfaces_failing.go *)

(* lock.go *)

(* We can't interpret multithreaded code, so this just checks that
   locks are correctly interpreted *)
Definition testsUseLocks: val :=
  rec: "testsUseLocks" <> :=
    let: "m" := newMutex #() in
    Mutex__Lock "m";;
    Mutex__Unlock "m";;
    #true.

(* loops.go *)

(* helpers *)
Definition standardForLoop: val :=
  rec: "standardForLoop" "s" :=
    let: "sumPtr" := ref (zero_val uint64T) in
    let: "i" := ref_to uint64T #0 in
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      (if: (![uint64T] "i") < (slice.len "s")
      then
        let: "sum" := ![uint64T] "sumPtr" in
        let: "x" := SliceGet uint64T "s" (![uint64T] "i") in
        "sumPtr" <-[uint64T] ("sum" + "x");;
        "i" <-[uint64T] ((![uint64T] "i") + #1);;
        Continue
      else Break));;
    let: "sum" := ![uint64T] "sumPtr" in
    "sum".

(* based off diskAppendWait loop pattern in logging2 *)
Definition LoopStruct := struct.decl [
  "loopNext" :: ptrT
].

Definition LoopStruct__forLoopWait: val :=
  rec: "LoopStruct__forLoopWait" "ls" "i" :=
    Skip;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "nxt" := struct.get LoopStruct "loopNext" "ls" in
      (if: "i" < (![uint64T] "nxt")
      then Break
      else
        (struct.get LoopStruct "loopNext" "ls") <-[uint64T] ((![uint64T] (struct.get LoopStruct "loopNext" "ls")) + #1);;
        Continue));;
    #().

(* tests *)
Definition testStandardForLoop: val :=
  rec: "testStandardForLoop" <> :=
    let: "arr" := ref_to (slice.T uint64T) (NewSlice uint64T #4) in
    SliceSet uint64T (![slice.T uint64T] "arr") #0 ((SliceGet uint64T (![slice.T uint64T] "arr") #0) + #1);;
    SliceSet uint64T (![slice.T uint64T] "arr") #1 ((SliceGet uint64T (![slice.T uint64T] "arr") #1) + #3);;
    SliceSet uint64T (![slice.T uint64T] "arr") #2 ((SliceGet uint64T (![slice.T uint64T] "arr") #2) + #5);;
    SliceSet uint64T (![slice.T uint64T] "arr") #3 ((SliceGet uint64T (![slice.T uint64T] "arr") #3) + #7);;
    (standardForLoop (![slice.T uint64T] "arr")) = #16.

Definition testForLoopWait: val :=
  rec: "testForLoopWait" <> :=
    let: "ls" := struct.mk LoopStruct [
      "loopNext" ::= ref (zero_val uint64T)
    ] in
    LoopStruct__forLoopWait "ls" #3;;
    (![uint64T] (struct.get LoopStruct "loopNext" "ls")) = #4.

Definition testBreakFromLoopWithContinue: val :=
  rec: "testBreakFromLoopWithContinue" <> :=
    let: "i" := ref_to uint64T #0 in
    Skip;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      (if: #true
      then
        "i" <-[uint64T] ((![uint64T] "i") + #1);;
        Break
      else Continue));;
    (![uint64T] "i") = #1.

Definition testBreakFromLoopNoContinue: val :=
  rec: "testBreakFromLoopNoContinue" <> :=
    let: "i" := ref_to uint64T #0 in
    Skip;;
    (for: (λ: <>, (![uint64T] "i") < #3); (λ: <>, Skip) := λ: <>,
      (if: #true
      then
        "i" <-[uint64T] ((![uint64T] "i") + #1);;
        Break
      else
        "i" <-[uint64T] ((![uint64T] "i") + #2);;
        Continue));;
    (![uint64T] "i") = #1.

Definition testBreakFromLoopNoContinueDouble: val :=
  rec: "testBreakFromLoopNoContinueDouble" <> :=
    let: "i" := ref_to uint64T #0 in
    Skip;;
    (for: (λ: <>, (![uint64T] "i") < #3); (λ: <>, Skip) := λ: <>,
      (if: (![uint64T] "i") = #1
      then
        "i" <-[uint64T] ((![uint64T] "i") + #1);;
        Break
      else
        "i" <-[uint64T] ((![uint64T] "i") + #2);;
        "i" <-[uint64T] ((![uint64T] "i") + #2);;
        Continue));;
    (![uint64T] "i") = #4.

Definition testBreakFromLoopForOnly: val :=
  rec: "testBreakFromLoopForOnly" <> :=
    let: "i" := ref_to uint64T #0 in
    Skip;;
    (for: (λ: <>, (![uint64T] "i") < #3); (λ: <>, Skip) := λ: <>,
      "i" <-[uint64T] ((![uint64T] "i") + #2);;
      Continue);;
    (![uint64T] "i") = #4.

Definition testBreakFromLoopAssignAndContinue: val :=
  rec: "testBreakFromLoopAssignAndContinue" <> :=
    let: "i" := ref_to uint64T #0 in
    Skip;;
    (for: (λ: <>, (![uint64T] "i") < #3); (λ: <>, Skip) := λ: <>,
      (if: #true
      then
        "i" <-[uint64T] ((![uint64T] "i") + #1);;
        Break
      else
        "i" <-[uint64T] ((![uint64T] "i") + #2);;
        Continue));;
    (![uint64T] "i") = #1.

Definition testNestedLoops: val :=
  rec: "testNestedLoops" <> :=
    let: "ok1" := ref_to boolT #false in
    let: "ok2" := ref_to boolT #false in
    let: "i" := ref_to uint64T #0 in
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "j" := ref_to uint64T #0 in
      (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
        (if: (![uint64T] "j") > #5
        then Break
        else
          "j" <-[uint64T] ((![uint64T] "j") + #1);;
          "ok1" <-[boolT] ((![uint64T] "j") = #6);;
          Continue));;
      "i" <-[uint64T] ((![uint64T] "i") + #1);;
      "ok2" <-[boolT] ((![uint64T] "i") = #1);;
      Break);;
    (![boolT] "ok1") && (![boolT] "ok2").

Definition testNestedGoStyleLoops: val :=
  rec: "testNestedGoStyleLoops" <> :=
    let: "ok" := ref_to boolT #false in
    let: "i" := ref_to uint64T #0 in
    (for: (λ: <>, (![uint64T] "i") < #10); (λ: <>, "i" <-[uint64T] ((![uint64T] "i") + #1)) := λ: <>,
      let: "j" := ref_to uint64T #0 in
      (for: (λ: <>, (![uint64T] "j") < (![uint64T] "i")); (λ: <>, "j" <-[uint64T] ((![uint64T] "j") + #1)) := λ: <>,
        (if: #true
        then Break
        else Continue));;
      "ok" <-[boolT] ((![uint64T] "i") = #9);;
      Continue);;
    ![boolT] "ok".

Definition testNestedGoStyleLoopsNoComparison: val :=
  rec: "testNestedGoStyleLoopsNoComparison" <> :=
    let: "ok" := ref_to boolT #false in
    let: "i" := ref_to uint64T #0 in
    (for: (λ: <>, (![uint64T] "i") < #10); (λ: <>, "i" <-[uint64T] ((![uint64T] "i") + #1)) := λ: <>,
      let: "j" := ref_to uint64T #0 in
      (for: (λ: <>, (![uint64T] "j") < (![uint64T] "i")); (λ: <>, "j" <-[uint64T] ((![uint64T] "j") + #1)) := λ: <>,
        (if: #true
        then Break
        else Continue));;
      "ok" <-[boolT] ((![uint64T] "i") = #9);;
      Continue);;
    ![boolT] "ok".

(* maps.go *)

Definition IterateMapKeys: val :=
  rec: "IterateMapKeys" "m" :=
    let: "sum" := ref (zero_val uint64T) in
    MapIter "m" (λ: "k" <>,
      "sum" <-[uint64T] ((![uint64T] "sum") + "k"));;
    ![uint64T] "sum".

Definition IterateMapValues: val :=
  rec: "IterateMapValues" "m" :=
    let: "sum" := ref (zero_val uint64T) in
    MapIter "m" (λ: <> "v",
      "sum" <-[uint64T] ((![uint64T] "sum") + "v"));;
    ![uint64T] "sum".

Definition testIterateMap: val :=
  rec: "testIterateMap" <> :=
    let: "ok" := ref_to boolT #true in
    let: "m" := NewMap uint64T uint64T #() in
    MapInsert "m" #0 #1;;
    MapInsert "m" #1 #2;;
    MapInsert "m" #3 #4;;
    "ok" <-[boolT] ((![boolT] "ok") && ((IterateMapKeys "m") = #4));;
    "ok" <-[boolT] ((![boolT] "ok") && ((IterateMapValues "m") = #7));;
    ![boolT] "ok".

Definition testMapSize: val :=
  rec: "testMapSize" <> :=
    let: "ok" := ref_to boolT #true in
    let: "m" := NewMap uint64T uint64T #() in
    "ok" <-[boolT] ((![boolT] "ok") && ((MapLen "m") = #0));;
    MapInsert "m" #0 #1;;
    MapInsert "m" #1 #2;;
    MapInsert "m" #3 #4;;
    "ok" <-[boolT] ((![boolT] "ok") && ((MapLen "m") = #3));;
    ![boolT] "ok".

(* multiple_assign.go *)

Definition multReturnTwo: val :=
  rec: "multReturnTwo" <> :=
    (#2, #3).

Definition testAssignTwo: val :=
  rec: "testAssignTwo" <> :=
    let: "x" := ref_to uint64T #10 in
    let: "y" := ref_to uint64T #15 in
    let: ("0_ret", "1_ret") := multReturnTwo #() in
    "x" <-[uint64T] "0_ret";;
    "y" <-[uint64T] "1_ret";;
    ((![uint64T] "x") = #2) && ((![uint64T] "y") = #3).

Definition multReturnThree: val :=
  rec: "multReturnThree" <> :=
    (#2, #true, #(U32 1)).

Definition testAssignThree: val :=
  rec: "testAssignThree" <> :=
    let: "x" := ref_to uint64T #10 in
    let: "y" := ref_to boolT #false in
    let: "z" := ref_to uint32T #(U32 15) in
    let: (("0_ret", "1_ret"), "2_ret") := multReturnThree #() in
    "x" <-[uint64T] "0_ret";;
    "y" <-[boolT] "1_ret";;
    "z" <-[uint32T] "2_ret";;
    (((![uint64T] "x") = #2) && ((![boolT] "y") = #true)) && ((![uint32T] "z") = #(U32 1)).

Definition testMultipleAssignToMap: val :=
  rec: "testMultipleAssignToMap" <> :=
    let: "x" := ref_to uint64T #10 in
    let: "m" := ref_to (mapT uint64T) (NewMap uint64T uint64T #()) in
    let: ("0_ret", "1_ret") := multReturnTwo #() in
    "x" <-[uint64T] "0_ret";;
    MapInsert (![mapT uint64T] "m") #0 "1_ret";;
    ((![uint64T] "x") = #2) && ((Fst (MapGet (![mapT uint64T] "m") #0)) = #3).

(* multiple_return.go *)

Definition returnTwo: val :=
  rec: "returnTwo" <> :=
    (#2, #3).

Definition testReturnTwo: val :=
  rec: "testReturnTwo" <> :=
    let: ("x", "y") := returnTwo #() in
    ("x" = #2) && ("y" = #3).

Definition testAnonymousBinding: val :=
  rec: "testAnonymousBinding" <> :=
    let: (<>, "y") := returnTwo #() in
    "y" = #3.

Definition returnThree: val :=
  rec: "returnThree" <> :=
    (#2, #true, #(U32 1)).

Definition testReturnThree: val :=
  rec: "testReturnThree" <> :=
    let: (("x", "y"), "z") := returnThree #() in
    (("x" = #2) && ("y" = #true)) && ("z" = #(U32 1)).

Definition returnFour: val :=
  rec: "returnFour" <> :=
    (#2, #true, #(U32 1), #7).

Definition testReturnFour: val :=
  rec: "testReturnFour" <> :=
    let: ((("x", "y"), "z"), "w") := returnFour #() in
    ((("x" = #2) && ("y" = #true)) && ("z" = #(U32 1))) && ("w" = #7).

(* nil.go *)

Definition failing_testCompareSliceToNil: val :=
  rec: "failing_testCompareSliceToNil" <> :=
    let: "s" := NewSlice byteT #0 in
    "s" ≠ slice.nil.

Definition testComparePointerToNil: val :=
  rec: "testComparePointerToNil" <> :=
    let: "s" := ref (zero_val uint64T) in
    "s" ≠ #null.

Definition testCompareNilToNil: val :=
  rec: "testCompareNilToNil" <> :=
    let: "s" := ref (zero_val ptrT) in
    (![ptrT] "s") = #null.

Definition testComparePointerWrappedToNil: val :=
  rec: "testComparePointerWrappedToNil" <> :=
    let: "s" := ref (zero_val (slice.T byteT)) in
    "s" <-[slice.T byteT] (NewSlice byteT #1);;
    (![slice.T byteT] "s") ≠ slice.nil.

Definition testComparePointerWrappedDefaultToNil: val :=
  rec: "testComparePointerWrappedDefaultToNil" <> :=
    let: "s" := ref (zero_val (slice.T byteT)) in
    (![slice.T byteT] "s") = slice.nil.

(* operations.go *)

(* helpers *)
Definition reverseAssignOps64: val :=
  rec: "reverseAssignOps64" "x" :=
    let: "y" := ref (zero_val uint64T) in
    "y" <-[uint64T] ((![uint64T] "y") + "x");;
    "y" <-[uint64T] ((![uint64T] "y") - "x");;
    "y" <-[uint64T] ((![uint64T] "y") + #1);;
    "y" <-[uint64T] ((![uint64T] "y") - #1);;
    ![uint64T] "y".

Definition reverseAssignOps32: val :=
  rec: "reverseAssignOps32" "x" :=
    let: "y" := ref (zero_val uint32T) in
    "y" <-[uint32T] ((![uint32T] "y") + "x");;
    "y" <-[uint32T] ((![uint32T] "y") - "x");;
    "y" <-[uint32T] ((![uint32T] "y") + #1);;
    "y" <-[uint32T] ((![uint32T] "y") - #1);;
    ![uint32T] "y".

Definition add64Equals: val :=
  rec: "add64Equals" "x" "y" "z" :=
    ("x" + "y") = "z".

Definition sub64Equals: val :=
  rec: "sub64Equals" "x" "y" "z" :=
    ("x" - "y") = "z".

(* tests *)
Definition testReverseAssignOps64: val :=
  rec: "testReverseAssignOps64" <> :=
    let: "ok" := ref_to boolT #true in
    "ok" <-[boolT] ((![boolT] "ok") && ((reverseAssignOps64 #0) = #0));;
    "ok" <-[boolT] ((![boolT] "ok") && ((reverseAssignOps64 #1) = #0));;
    "ok" <-[boolT] ((![boolT] "ok") && ((reverseAssignOps64 #1231234) = #0));;
    "ok" <-[boolT] ((![boolT] "ok") && ((reverseAssignOps64 #62206846038638762) = #0));;
    "ok" <-[boolT] ((![boolT] "ok") && ((reverseAssignOps64 (#1 ≪ #63)) = #0));;
    "ok" <-[boolT] ((![boolT] "ok") && ((reverseAssignOps64 (#1 ≪ #47)) = #0));;
    "ok" <-[boolT] ((![boolT] "ok") && ((reverseAssignOps64 (#1 ≪ #20)) = #0));;
    "ok" <-[boolT] ((![boolT] "ok") && ((reverseAssignOps64 (#1 ≪ #18)) = #0));;
    "ok" <-[boolT] ((![boolT] "ok") && ((reverseAssignOps64 (#1 ≪ #10)) = #0));;
    "ok" <-[boolT] ((![boolT] "ok") && ((reverseAssignOps64 (#1 ≪ #0)) = #0));;
    "ok" <-[boolT] ((![boolT] "ok") && ((reverseAssignOps64 ((#1 ≪ #64) - #1)) = #0));;
    ![boolT] "ok".

Definition failing_testReverseAssignOps32: val :=
  rec: "failing_testReverseAssignOps32" <> :=
    let: "ok" := ref_to boolT #true in
    "ok" <-[boolT] ((![boolT] "ok") && ((reverseAssignOps32 #(U32 0)) = #(U32 0)));;
    "ok" <-[boolT] ((![boolT] "ok") && ((reverseAssignOps32 #(U32 1)) = #(U32 0)));;
    "ok" <-[boolT] ((![boolT] "ok") && ((reverseAssignOps32 #(U32 1231234)) = #(U32 0)));;
    "ok" <-[boolT] ((![boolT] "ok") && ((reverseAssignOps32 #(U32 3434807466)) = #(U32 0)));;
    "ok" <-[boolT] ((![boolT] "ok") && ((reverseAssignOps32 (#1 ≪ #20)) = #(U32 0)));;
    "ok" <-[boolT] ((![boolT] "ok") && ((reverseAssignOps32 (#1 ≪ #18)) = #(U32 0)));;
    "ok" <-[boolT] ((![boolT] "ok") && ((reverseAssignOps32 (#1 ≪ #10)) = #(U32 0)));;
    "ok" <-[boolT] ((![boolT] "ok") && ((reverseAssignOps32 (#1 ≪ #0)) = #(U32 0)));;
    "ok" <-[boolT] ((![boolT] "ok") && ((reverseAssignOps32 ((#1 ≪ #32) - #1)) = #(U32 0)));;
    ![boolT] "ok".

Definition testAdd64Equals: val :=
  rec: "testAdd64Equals" <> :=
    let: "ok" := ref_to boolT #true in
    "ok" <-[boolT] ((![boolT] "ok") && (add64Equals #2 #3 #5));;
    "ok" <-[boolT] ((![boolT] "ok") && (add64Equals ((#1 ≪ #64) - #1) #1 #0));;
    ![boolT] "ok".

Definition testSub64Equals: val :=
  rec: "testSub64Equals" <> :=
    let: "ok" := ref_to boolT #true in
    "ok" <-[boolT] ((![boolT] "ok") && (sub64Equals #2 #1 #1));;
    "ok" <-[boolT] ((![boolT] "ok") && (sub64Equals ((#1 ≪ #64) - #1) (#1 ≪ #63) ((#1 ≪ #63) - #1)));;
    "ok" <-[boolT] ((![boolT] "ok") && (sub64Equals #2 #8 ((#1 ≪ #64) - #6)));;
    ![boolT] "ok".

Definition testDivisionPrecedence: val :=
  rec: "testDivisionPrecedence" <> :=
    let: "blockSize" := #4096 in
    let: "hdrmeta" := #8 in
    let: "hdraddrs" := ("blockSize" - "hdrmeta") `quot` #8 in
    "hdraddrs" = #511.

Definition testModPrecedence: val :=
  rec: "testModPrecedence" <> :=
    let: "x1" := #513 + (#12 `rem` #8) in
    let: "x2" := (#513 + #12) `rem` #8 in
    ("x1" = #517) && ("x2" = #5).

Definition testBitwiseOpsPrecedence: val :=
  rec: "testBitwiseOpsPrecedence" <> :=
    let: "ok" := ref_to boolT #true in
    "ok" <-[boolT] ((![boolT] "ok") && ((#222 `or` #327) = #479));;
    "ok" <-[boolT] ((![boolT] "ok") && ((#468 `and` #1191) = #132));;
    "ok" <-[boolT] ((![boolT] "ok") && ((#453 `xor` #761) = #828));;
    "ok" <-[boolT] ((![boolT] "ok") && (((#453 `xor` #761) `or` #121) = #893));;
    "ok" <-[boolT] ((![boolT] "ok") && (((#468 `and` #1191) `or` #333) = #461));;
    "ok" <-[boolT] ((![boolT] "ok") && ((#222 `or` (#327 `and` #421)) ≠ #389));;
    ![boolT] "ok".

Definition testArithmeticShifts: val :=
  rec: "testArithmeticShifts" <> :=
    let: "ok" := ref_to boolT #true in
    "ok" <-[boolT] ((![boolT] "ok") && ((#672 ≪ #3) = #5376));;
    "ok" <-[boolT] ((![boolT] "ok") && ((#672 ≪ #51) = #1513209474796486656));;
    "ok" <-[boolT] ((![boolT] "ok") && ((#672 ≫ #4) = #42));;
    "ok" <-[boolT] ((![boolT] "ok") && ((#672 ≫ #12) = #0));;
    "ok" <-[boolT] ((![boolT] "ok") && (((#672 ≫ #4) ≪ #4) = #672));;
    ![boolT] "ok".

Definition testBitAddAnd: val :=
  rec: "testBitAddAnd" <> :=
    let: "tid" := #17 in
    let: "n" := #16 in
    (("tid" + "n") `and` (~ ("n" - #1))) = #32.

Definition testManyParentheses: val :=
  rec: "testManyParentheses" <> :=
    (((#1 `rem` #2) `or` (#3 `rem` #4)) * #6) = (#3 * #6).

Definition testPlusTimes: val :=
  rec: "testPlusTimes" <> :=
    ((#2 + #5) * #2) = #14.

(* precedence.go *)

Definition testOrCompareSimple: val :=
  rec: "testOrCompareSimple" <> :=
    (if: (#3 > #4) || (#4 > #3)
    then #true
    else #false).

Definition testOrCompare: val :=
  rec: "testOrCompare" <> :=
    let: "ok" := ref_to boolT #true in
    (if: (~ ((#3 > #4) || (#4 > #3)))
    then "ok" <-[boolT] #false
    else #());;
    (if: (#4 < #3) || (#2 > #3)
    then "ok" <-[boolT] #false
    else #());;
    ![boolT] "ok".

Definition testAndCompare: val :=
  rec: "testAndCompare" <> :=
    let: "ok" := ref_to boolT #true in
    (if: (#3 > #4) && (#4 > #3)
    then "ok" <-[boolT] #false
    else #());;
    (if: (#4 > #3) || (#2 < #3)
    then #()
    else "ok" <-[boolT] #false);;
    ![boolT] "ok".

Definition testShiftMod: val :=
  rec: "testShiftMod" <> :=
    (#20 ≫ (#8 `rem` #4)) = #20.

(* prims.go *)

Definition testLinearize: val :=
  rec: "testLinearize" <> :=
    let: "m" := newMutex #() in
    Mutex__Lock "m";;
    Linearize;;
    Mutex__Unlock "m";;
    #true.

(* shortcircuiting.go *)

(* helpers *)
Definition BoolTest := struct.decl [
  "t" :: boolT;
  "f" :: boolT;
  "tc" :: uint64T;
  "fc" :: uint64T
].

Definition CheckTrue: val :=
  rec: "CheckTrue" "b" :=
    struct.storeF BoolTest "tc" "b" ((struct.loadF BoolTest "tc" "b") + #1);;
    struct.loadF BoolTest "t" "b".

Definition CheckFalse: val :=
  rec: "CheckFalse" "b" :=
    struct.storeF BoolTest "fc" "b" ((struct.loadF BoolTest "fc" "b") + #1);;
    struct.loadF BoolTest "f" "b".

(* tests *)
Definition testShortcircuitAndTF: val :=
  rec: "testShortcircuitAndTF" <> :=
    let: "b" := struct.new BoolTest [
      "t" ::= #true;
      "f" ::= #false;
      "tc" ::= #0;
      "fc" ::= #0
    ] in
    (if: (CheckTrue "b") && (CheckFalse "b")
    then #false
    else ((struct.loadF BoolTest "tc" "b") = #1) && ((struct.loadF BoolTest "fc" "b") = #1)).

Definition testShortcircuitAndFT: val :=
  rec: "testShortcircuitAndFT" <> :=
    let: "b" := struct.new BoolTest [
      "t" ::= #true;
      "f" ::= #false;
      "tc" ::= #0;
      "fc" ::= #0
    ] in
    (if: (CheckFalse "b") && (CheckTrue "b")
    then #false
    else ((struct.loadF BoolTest "tc" "b") = #0) && ((struct.loadF BoolTest "fc" "b") = #1)).

Definition testShortcircuitOrTF: val :=
  rec: "testShortcircuitOrTF" <> :=
    let: "b" := struct.new BoolTest [
      "t" ::= #true;
      "f" ::= #false;
      "tc" ::= #0;
      "fc" ::= #0
    ] in
    (if: (CheckTrue "b") || (CheckFalse "b")
    then ((struct.loadF BoolTest "tc" "b") = #1) && ((struct.loadF BoolTest "fc" "b") = #0)
    else #false).

Definition testShortcircuitOrFT: val :=
  rec: "testShortcircuitOrFT" <> :=
    let: "b" := struct.new BoolTest [
      "t" ::= #true;
      "f" ::= #false;
      "tc" ::= #0;
      "fc" ::= #0
    ] in
    (if: (CheckFalse "b") || (CheckTrue "b")
    then ((struct.loadF BoolTest "tc" "b") = #1) && ((struct.loadF BoolTest "fc" "b") = #1)
    else #false).

(* slices.go *)

(* helpers *)
Definition ArrayEditor := struct.decl [
  "s" :: slice.T uint64T;
  "next_val" :: uint64T
].

Definition ArrayEditor__Advance: val :=
  rec: "ArrayEditor__Advance" "ae" "arr" "next" :=
    SliceSet uint64T "arr" #0 ((SliceGet uint64T "arr" #0) + #1);;
    SliceSet uint64T (struct.loadF ArrayEditor "s" "ae") #0 (struct.loadF ArrayEditor "next_val" "ae");;
    struct.storeF ArrayEditor "next_val" "ae" "next";;
    struct.storeF ArrayEditor "s" "ae" (SliceSkip uint64T (struct.loadF ArrayEditor "s" "ae") #1);;
    #().

(* tests *)
Definition testSliceOps: val :=
  rec: "testSliceOps" <> :=
    let: "x" := NewSlice uint64T #10 in
    SliceSet uint64T "x" #1 #5;;
    SliceSet uint64T "x" #2 #10;;
    SliceSet uint64T "x" #3 #15;;
    SliceSet uint64T "x" #4 #20;;
    let: "v1" := SliceGet uint64T "x" #2 in
    let: "v2" := SliceSubslice uint64T "x" #2 #3 in
    let: "v3" := SliceTake "x" #3 in
    let: "v4" := SliceRef uint64T "x" #2 in
    let: "ok" := ref_to boolT #true in
    "ok" <-[boolT] ((![boolT] "ok") && ("v1" = #10));;
    "ok" <-[boolT] ((![boolT] "ok") && ((SliceGet uint64T "v2" #0) = #10));;
    "ok" <-[boolT] ((![boolT] "ok") && ((slice.len "v2") = #1));;
    "ok" <-[boolT] ((![boolT] "ok") && ((SliceGet uint64T "v3" #1) = #5));;
    "ok" <-[boolT] ((![boolT] "ok") && ((SliceGet uint64T "v3" #2) = #10));;
    "ok" <-[boolT] ((![boolT] "ok") && ((slice.len "v3") = #3));;
    "ok" <-[boolT] ((![boolT] "ok") && ((![uint64T] "v4") = #10));;
    ![boolT] "ok".

Definition testSliceCapacityOps: val :=
  rec: "testSliceCapacityOps" <> :=
    let: "x" := NewSliceWithCap uint64T #0 #10 in
    let: "sub1" := SliceTake "x" #6 in
    SliceSet uint64T "sub1" #0 #1;;
    let: "sub2" := SliceSubslice uint64T "x" #2 #4 in
    SliceSet uint64T "sub2" #0 #2;;
    let: "ok" := ref_to boolT #true in
    "ok" <-[boolT] ((![boolT] "ok") && ((slice.len "sub1") = #6));;
    "ok" <-[boolT] ((![boolT] "ok") && ((slice.cap "sub1") = #10));;
    "ok" <-[boolT] ((![boolT] "ok") && ((SliceGet uint64T (SliceTake "x" #10) #0) = #1));;
    "ok" <-[boolT] ((![boolT] "ok") && ((slice.len "sub2") = #2));;
    "ok" <-[boolT] ((![boolT] "ok") && ((slice.cap "sub2") = #8));;
    "ok" <-[boolT] ((![boolT] "ok") && ((SliceGet uint64T (SliceTake "x" #10) #2) = #2));;
    ![boolT] "ok".

Definition testOverwriteArray: val :=
  rec: "testOverwriteArray" <> :=
    let: "arr" := ref_to (slice.T uint64T) (NewSlice uint64T #4) in
    let: "ae1" := struct.new ArrayEditor [
      "s" ::= SliceSkip uint64T (![slice.T uint64T] "arr") #0;
      "next_val" ::= #1
    ] in
    let: "ae2" := struct.new ArrayEditor [
      "s" ::= SliceSkip uint64T (![slice.T uint64T] "arr") #1;
      "next_val" ::= #102
    ] in
    ArrayEditor__Advance "ae2" (![slice.T uint64T] "arr") #103;;
    ArrayEditor__Advance "ae2" (![slice.T uint64T] "arr") #104;;
    ArrayEditor__Advance "ae2" (![slice.T uint64T] "arr") #105;;
    ArrayEditor__Advance "ae1" (![slice.T uint64T] "arr") #2;;
    ArrayEditor__Advance "ae1" (![slice.T uint64T] "arr") #3;;
    ArrayEditor__Advance "ae1" (![slice.T uint64T] "arr") #4;;
    ArrayEditor__Advance "ae1" (![slice.T uint64T] "arr") #5;;
    (if: ((((SliceGet uint64T (![slice.T uint64T] "arr") #0) + (SliceGet uint64T (![slice.T uint64T] "arr") #1)) + (SliceGet uint64T (![slice.T uint64T] "arr") #2)) + (SliceGet uint64T (![slice.T uint64T] "arr") #3)) ≥ #100
    then #false
    else ((SliceGet uint64T (![slice.T uint64T] "arr") #3) = #4) && ((SliceGet uint64T (![slice.T uint64T] "arr") #0) = #4)).

(* strings.go *)

(* helpers *)
Definition stringAppend: val :=
  rec: "stringAppend" "s" "x" :=
    "s" + (uint64_to_string "x").

Definition stringLength: val :=
  rec: "stringLength" "s" :=
    StringLength "s".

(* tests *)
Definition failing_testStringAppend: val :=
  rec: "failing_testStringAppend" <> :=
    let: "ok" := ref_to boolT #true in
    let: "s" := ref_to stringT #(str"123") in
    let: "y" := ref_to stringT (stringAppend (![stringT] "s") #45) in
    (![boolT] "ok") && ((![stringT] "y") = #(str"12345")).

Definition failing_testStringLength: val :=
  rec: "failing_testStringLength" <> :=
    let: "ok" := ref_to boolT #true in
    let: "s" := ref_to stringT #(str"") in
    "ok" <-[boolT] ((![boolT] "ok") && ((StringLength (![stringT] "s")) = #0));;
    "s" <-[stringT] (stringAppend (![stringT] "s") #1);;
    "ok" <-[boolT] ((![boolT] "ok") && ((StringLength (![stringT] "s")) = #1));;
    "s" <-[stringT] (stringAppend (![stringT] "s") #23);;
    (![boolT] "ok") && ((StringLength (![stringT] "s")) = #3).

(* struct_pointers.go *)

Definition Bar := struct.decl [
  "a" :: uint64T;
  "b" :: uint64T
].

(* Foo contains a nested struct which is intended to be manipulated through a
   Foo pointer *)
Definition Foo := struct.decl [
  "bar" :: struct.t Bar
].

Definition Bar__mutate: val :=
  rec: "Bar__mutate" "bar" :=
    struct.storeF Bar "a" "bar" #2;;
    struct.storeF Bar "b" "bar" #3;;
    #().

Definition Foo__mutateBar: val :=
  rec: "Foo__mutateBar" "foo" :=
    Bar__mutate (struct.loadF Foo "bar" "foo");;
    #().

Definition failing_testFooBarMutation: val :=
  rec: "failing_testFooBarMutation" <> :=
    let: "x" := struct.mk Foo [
      "bar" ::= struct.mk Bar [
        "a" ::= #0;
        "b" ::= #0
      ]
    ] in
    Foo__mutateBar "x";;
    (struct.get Bar "a" (struct.get Foo "bar" "x")) = #2.

(* structs.go *)

Definition TwoInts := struct.decl [
  "x" :: uint64T;
  "y" :: uint64T
].

Definition S := struct.decl [
  "a" :: uint64T;
  "b" :: struct.t TwoInts;
  "c" :: boolT
].

Definition NewS: val :=
  rec: "NewS" <> :=
    struct.new S [
      "a" ::= #2;
      "b" ::= struct.mk TwoInts [
        "x" ::= #1;
        "y" ::= #2
      ];
      "c" ::= #true
    ].

Definition S__readA: val :=
  rec: "S__readA" "s" :=
    struct.loadF S "a" "s".

Definition S__readB: val :=
  rec: "S__readB" "s" :=
    struct.loadF S "b" "s".

Definition S__readBVal: val :=
  rec: "S__readBVal" "s" :=
    struct.get S "b" "s".

Definition S__updateBValX: val :=
  rec: "S__updateBValX" "s" "i" :=
    struct.storeF TwoInts "x" (struct.fieldRef S "b" "s") "i";;
    #().

Definition S__negateC: val :=
  rec: "S__negateC" "s" :=
    struct.storeF S "c" "s" (~ (struct.loadF S "c" "s"));;
    #().

Definition failing_testStructUpdates: val :=
  rec: "failing_testStructUpdates" <> :=
    let: "ok" := ref_to boolT #true in
    let: "ns" := NewS #() in
    "ok" <-[boolT] ((![boolT] "ok") && ((S__readA "ns") = #2));;
    let: "b1" := ref_to (struct.t TwoInts) (S__readB "ns") in
    "ok" <-[boolT] ((![boolT] "ok") && ((struct.get TwoInts "x" (![struct.t TwoInts] "b1")) = #1));;
    S__negateC "ns";;
    "ok" <-[boolT] ((![boolT] "ok") && ((struct.loadF S "c" "ns") = #false));;
    struct.storeF TwoInts "x" "b1" #3;;
    let: "b2" := ref_to (struct.t TwoInts) (S__readB "ns") in
    "ok" <-[boolT] ((![boolT] "ok") && ((struct.get TwoInts "x" (![struct.t TwoInts] "b2")) = #1));;
    let: "b3" := ref_to ptrT (struct.fieldRef S "b" "ns") in
    "ok" <-[boolT] ((![boolT] "ok") && ((struct.loadF TwoInts "x" (![ptrT] "b3")) = #1));;
    S__updateBValX "ns" #4;;
    "ok" <-[boolT] ((![boolT] "ok") && ((struct.get TwoInts "x" (S__readBVal "ns")) = #4));;
    ![boolT] "ok".

Definition testNestedStructUpdates: val :=
  rec: "testNestedStructUpdates" <> :=
    let: "ok" := ref_to boolT #true in
    let: "ns" := ref_to ptrT (NewS #()) in
    struct.storeF TwoInts "x" (struct.fieldRef S "b" (![ptrT] "ns")) #5;;
    "ok" <-[boolT] ((![boolT] "ok") && ((struct.get TwoInts "x" (struct.loadF S "b" (![ptrT] "ns"))) = #5));;
    "ns" <-[ptrT] (NewS #());;
    let: "p" := ref_to ptrT (struct.fieldRef S "b" (![ptrT] "ns")) in
    struct.storeF TwoInts "x" (![ptrT] "p") #5;;
    "ok" <-[boolT] ((![boolT] "ok") && ((struct.get TwoInts "x" (struct.loadF S "b" (![ptrT] "ns"))) = #5));;
    "ns" <-[ptrT] (NewS #());;
    "p" <-[ptrT] (struct.fieldRef S "b" (![ptrT] "ns"));;
    struct.storeF TwoInts "x" (struct.fieldRef S "b" (![ptrT] "ns")) #5;;
    "ok" <-[boolT] ((![boolT] "ok") && ((struct.get TwoInts "x" (struct.load TwoInts (![ptrT] "p"))) = #5));;
    "ns" <-[ptrT] (NewS #());;
    "p" <-[ptrT] (struct.fieldRef S "b" (![ptrT] "ns"));;
    struct.storeF TwoInts "x" (struct.fieldRef S "b" (![ptrT] "ns")) #5;;
    "ok" <-[boolT] ((![boolT] "ok") && ((struct.loadF TwoInts "x" (![ptrT] "p")) = #5));;
    ![boolT] "ok".

Definition testStructConstructions: val :=
  rec: "testStructConstructions" <> :=
    let: "ok" := ref_to boolT #true in
    let: "p1" := ref (zero_val ptrT) in
    let: "p2" := ref (zero_val (struct.t TwoInts)) in
    let: "p3" := struct.mk TwoInts [
      "y" ::= #0;
      "x" ::= #0
    ] in
    let: "p4" := struct.mk TwoInts [
      "x" ::= #0;
      "y" ::= #0
    ] in
    "ok" <-[boolT] ((![boolT] "ok") && ((![ptrT] "p1") = #null));;
    "p1" <-[ptrT] (struct.alloc TwoInts (zero_val (struct.t TwoInts)));;
    "ok" <-[boolT] ((![boolT] "ok") && ((![struct.t TwoInts] "p2") = "p3"));;
    "ok" <-[boolT] ((![boolT] "ok") && ("p3" = "p4"));;
    "ok" <-[boolT] ((![boolT] "ok") && ("p4" = (struct.load TwoInts (![ptrT] "p1"))));;
    "ok" <-[boolT] ((![boolT] "ok") && ("p4" ≠ (![ptrT] "p1")));;
    ![boolT] "ok".

Definition testIncompleteStruct: val :=
  rec: "testIncompleteStruct" <> :=
    let: "ok" := ref_to boolT #true in
    let: "p1" := struct.mk TwoInts [
      "x" ::= #0
    ] in
    "ok" <-[boolT] ((![boolT] "ok") && ((struct.get TwoInts "y" "p1") = #0));;
    let: "p2" := struct.mk S [
      "a" ::= #2
    ] in
    "ok" <-[boolT] ((![boolT] "ok") && ((struct.get TwoInts "x" (struct.get S "b" "p2")) = #0));;
    "ok" <-[boolT] ((![boolT] "ok") && ((struct.get S "c" "p2") = #false));;
    ![boolT] "ok".

Definition StructWrap := struct.decl [
  "i" :: uint64T
].

Definition testStoreInStructVar: val :=
  rec: "testStoreInStructVar" <> :=
    let: "p" := ref_to (struct.t StructWrap) (struct.mk StructWrap [
      "i" ::= #0
    ]) in
    struct.storeF StructWrap "i" "p" #5;;
    (struct.get StructWrap "i" (![struct.t StructWrap] "p")) = #5.

Definition testStoreInStructPointerVar: val :=
  rec: "testStoreInStructPointerVar" <> :=
    let: "p" := ref_to ptrT (struct.alloc StructWrap (zero_val (struct.t StructWrap))) in
    struct.storeF StructWrap "i" (![ptrT] "p") #5;;
    (struct.loadF StructWrap "i" (![ptrT] "p")) = #5.

Definition testStoreComposite: val :=
  rec: "testStoreComposite" <> :=
    let: "p" := struct.alloc TwoInts (zero_val (struct.t TwoInts)) in
    struct.store TwoInts "p" (struct.mk TwoInts [
      "x" ::= #3;
      "y" ::= #4
    ]);;
    (struct.get TwoInts "y" (struct.load TwoInts "p")) = #4.

Definition testStoreSlice: val :=
  rec: "testStoreSlice" <> :=
    let: "p" := ref (zero_val (slice.T uint64T)) in
    let: "s" := NewSlice uint64T #3 in
    "p" <-[slice.T uint64T] "s";;
    (slice.len (![slice.T uint64T] "p")) = #3.

Definition StructWithFunc := struct.decl [
  "fn" :: (uint64T -> uint64T)%ht
].

Definition testStructFieldFunc: val :=
  rec: "testStructFieldFunc" <> :=
    let: "a" := struct.alloc StructWithFunc (zero_val (struct.t StructWithFunc)) in
    struct.storeF StructWithFunc "fn" "a" (λ: "arg",
      "arg" * #2
      );;
    ((struct.loadF StructWithFunc "fn" "a") #10) = #20.

(* vars.go *)

Definition testPointerAssignment: val :=
  rec: "testPointerAssignment" <> :=
    let: "x" := ref (zero_val boolT) in
    "x" <-[boolT] #true;;
    ![boolT] "x".

Definition testAddressOfLocal: val :=
  rec: "testAddressOfLocal" <> :=
    let: "x" := ref_to boolT #false in
    let: "xptr" := "x" in
    "xptr" <-[boolT] #true;;
    (![boolT] "x") && (![boolT] "xptr").

Definition testAnonymousAssign: val :=
  rec: "testAnonymousAssign" <> :=
    #1 + #2;;
    #true.

(* wal.go *)

(* 10 is completely arbitrary *)
Definition MaxTxnWrites : expr := #10.

Definition logLength : expr := #1 + (#2 * MaxTxnWrites).

Definition Log := struct.decl [
  "d" :: disk.Disk;
  "l" :: ptrT;
  "cache" :: mapT disk.blockT;
  "length" :: ptrT
].

Definition intToBlock: val :=
  rec: "intToBlock" "a" :=
    let: "b" := NewSlice byteT disk.BlockSize in
    UInt64Put "b" "a";;
    "b".

Definition blockToInt: val :=
  rec: "blockToInt" "v" :=
    let: "a" := UInt64Get "v" in
    "a".

(* New initializes a fresh log *)
Definition New: val :=
  rec: "New" <> :=
    let: "d" := disk.Get #() in
    let: "diskSize" := disk.Size #() in
    (if: "diskSize" ≤ logLength
    then Panic "disk is too small to host log"
    else #());;
    let: "cache" := NewMap uint64T disk.blockT #() in
    let: "header" := intToBlock #0 in
    disk.Write #0 "header";;
    let: "lengthPtr" := ref (zero_val uint64T) in
    "lengthPtr" <-[uint64T] #0;;
    let: "l" := newMutex #() in
    struct.mk Log [
      "d" ::= "d";
      "cache" ::= "cache";
      "length" ::= "lengthPtr";
      "l" ::= "l"
    ].

Definition Log__lock: val :=
  rec: "Log__lock" "l" :=
    Mutex__Lock (struct.get Log "l" "l");;
    #().

Definition Log__unlock: val :=
  rec: "Log__unlock" "l" :=
    Mutex__Unlock (struct.get Log "l" "l");;
    #().

(* BeginTxn allocates space for a new transaction in the log.

   Returns true if the allocation succeeded. *)
Definition Log__BeginTxn: val :=
  rec: "Log__BeginTxn" "l" :=
    Log__lock "l";;
    let: "length" := ![uint64T] (struct.get Log "length" "l") in
    (if: "length" = #0
    then
      Log__unlock "l";;
      #true
    else
      Log__unlock "l";;
      #false).

(* Read from the logical disk.

   Reads must go through the log to return committed but un-applied writes. *)
Definition Log__Read: val :=
  rec: "Log__Read" "l" "a" :=
    Log__lock "l";;
    let: ("v", "ok") := MapGet (struct.get Log "cache" "l") "a" in
    (if: "ok"
    then
      Log__unlock "l";;
      "v"
    else
      Log__unlock "l";;
      let: "dv" := disk.Read (logLength + "a") in
      "dv").

Definition Log__Size: val :=
  rec: "Log__Size" "l" :=
    let: "sz" := disk.Size #() in
    "sz" - logLength.

(* Write to the disk through the log. *)
Definition Log__Write: val :=
  rec: "Log__Write" "l" "a" "v" :=
    Log__lock "l";;
    let: "length" := ![uint64T] (struct.get Log "length" "l") in
    (if: "length" ≥ MaxTxnWrites
    then Panic "transaction is at capacity"
    else #());;
    let: "aBlock" := intToBlock "a" in
    let: "nextAddr" := #1 + (#2 * "length") in
    disk.Write "nextAddr" "aBlock";;
    disk.Write ("nextAddr" + #1) "v";;
    MapInsert (struct.get Log "cache" "l") "a" "v";;
    (struct.get Log "length" "l") <-[uint64T] ("length" + #1);;
    Log__unlock "l";;
    #().

(* Commit the current transaction. *)
Definition Log__Commit: val :=
  rec: "Log__Commit" "l" :=
    Log__lock "l";;
    let: "length" := ![uint64T] (struct.get Log "length" "l") in
    Log__unlock "l";;
    let: "header" := intToBlock "length" in
    disk.Write #0 "header";;
    #().

Definition getLogEntry: val :=
  rec: "getLogEntry" "d" "logOffset" :=
    let: "diskAddr" := #1 + (#2 * "logOffset") in
    let: "aBlock" := disk.Read "diskAddr" in
    let: "a" := blockToInt "aBlock" in
    let: "v" := disk.Read ("diskAddr" + #1) in
    ("a", "v").

(* applyLog assumes we are running sequentially *)
Definition applyLog: val :=
  rec: "applyLog" "d" "length" :=
    let: "i" := ref_to uint64T #0 in
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      (if: (![uint64T] "i") < "length"
      then
        let: ("a", "v") := getLogEntry "d" (![uint64T] "i") in
        disk.Write (logLength + "a") "v";;
        "i" <-[uint64T] ((![uint64T] "i") + #1);;
        Continue
      else Break));;
    #().

Definition clearLog: val :=
  rec: "clearLog" "d" :=
    let: "header" := intToBlock #0 in
    disk.Write #0 "header";;
    #().

(* Apply all the committed transactions.

   Frees all the space in the log. *)
Definition Log__Apply: val :=
  rec: "Log__Apply" "l" :=
    Log__lock "l";;
    let: "length" := ![uint64T] (struct.get Log "length" "l") in
    applyLog (struct.get Log "d" "l") "length";;
    clearLog (struct.get Log "d" "l");;
    (struct.get Log "length" "l") <-[uint64T] #0;;
    Log__unlock "l";;
    #().

(* Open recovers the log following a crash or shutdown *)
Definition Open: val :=
  rec: "Open" <> :=
    let: "d" := disk.Get #() in
    let: "header" := disk.Read #0 in
    let: "length" := blockToInt "header" in
    applyLog "d" "length";;
    clearLog "d";;
    let: "cache" := NewMap uint64T disk.blockT #() in
    let: "lengthPtr" := ref (zero_val uint64T) in
    "lengthPtr" <-[uint64T] #0;;
    let: "l" := newMutex #() in
    struct.mk Log [
      "d" ::= "d";
      "cache" ::= "cache";
      "length" ::= "lengthPtr";
      "l" ::= "l"
    ].

(* disabled since performance is quite poor *)
Definition disabled_testWal: val :=
  rec: "disabled_testWal" <> :=
    let: "ok" := ref_to boolT #true in
    let: "lg" := New #() in
    (if: Log__BeginTxn "lg"
    then Log__Write "lg" #2 (intToBlock #11)
    else #());;
    "ok" <-[boolT] ((![boolT] "ok") && ((blockToInt (Log__Read "lg" #2)) = #11));;
    "ok" <-[boolT] ((![boolT] "ok") && ((blockToInt (disk.Read #0)) = #0));;
    Log__Commit "lg";;
    "ok" <-[boolT] ((![boolT] "ok") && ((blockToInt (disk.Read #0)) = #1));;
    Log__Apply "lg";;
    "ok" <-[boolT] ((![boolT] "ok") && ((![uint64T] (struct.get Log "length" "lg")) = #0));;
    ![boolT] "ok".
