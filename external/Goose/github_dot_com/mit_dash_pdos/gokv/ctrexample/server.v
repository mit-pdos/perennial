(* autogenerated from github.com/mit-pdos/gokv/ctrexample/server *)
From Perennial.goose_lang Require Import prelude.
From Goose Require github_dot_com.mit_dash_pdos.gokv.grove__ffi.
From Goose Require github_dot_com.mit_dash_pdos.gokv.urpc.
From Goose Require github_dot_com.tchajed.marshal.
From Goose Require sync.

From Perennial.goose_lang Require Import ffi.grove_prelude.

Definition CtrServer := struct.decl [
  "mu" :: ptrT;
  "val" :: uint64T;
  "filename" :: stringT
].

(* requires lock to be held *)
Definition CtrServer__MakeDurable: val :=
  rec: "CtrServer__MakeDurable" "s" :=
    let: "s" := ref_to ptrT "s" in
    let: "e" := ref_zero (struct.t marshal.Enc) in
    let: "$a0" := marshal.NewEnc #8 in
    do:  "e" <-[struct.t marshal.Enc] "$a0";;;
    do:  marshal.Enc__PutInt (![struct.t marshal.Enc] "e") (struct.loadF CtrServer "val" (![ptrT] "s"));;;
    do:  grove__ffi.FileWrite (struct.loadF CtrServer "filename" (![ptrT] "s")) (marshal.Enc__Finish (![struct.t marshal.Enc] "e"));;;
    do:  #().

Definition CtrServer__FetchAndIncrement: val :=
  rec: "CtrServer__FetchAndIncrement" "s" :=
    let: "s" := ref_to ptrT "s" in
    do:  sync.Mutex__Lock (struct.loadF CtrServer "mu" (![ptrT] "s"));;;
    let: "ret" := ref_zero uint64T in
    let: "$a0" := struct.loadF CtrServer "val" (![ptrT] "s") in
    do:  "ret" <-[uint64T] "$a0";;;
    do:  struct.storeF CtrServer "val" (![ptrT] "s") ((struct.loadF CtrServer "val" (![ptrT] "s")) + #1);;;
    do:  CtrServer__MakeDurable (![ptrT] "s");;;
    do:  sync.Mutex__Unlock (struct.loadF CtrServer "mu" (![ptrT] "s"));;;
    return: (![uint64T] "ret");;;
    do:  #().

(* the boot/main() function for the server *)
Definition main: val :=
  rec: "main" <> :=
    let: "me" := ref_zero uint64T in
    let: "$a0" := #53021371269120 in
    do:  "me" <-[uint64T] "$a0";;;
    let: "s" := ref_zero ptrT in
    let: "$a0" := struct.alloc CtrServer (zero_val (struct.t CtrServer)) in
    do:  "s" <-[ptrT] "$a0";;;
    let: "$a0" := struct.alloc sync.Mutex (zero_val (struct.t sync.Mutex)) in
    do:  struct.storeF CtrServer "mu" (![ptrT] "s") "$a0";;;
    let: "$a0" := #(str "ctr") in
    do:  struct.storeF CtrServer "filename" (![ptrT] "s") "$a0";;;
    let: "a" := ref_zero (slice.T byteT) in
    let: "$a0" := grove__ffi.FileRead (struct.loadF CtrServer "filename" (![ptrT] "s")) in
    do:  "a" <-[slice.T byteT] "$a0";;;
    (if: (slice.len (![slice.T byteT] "a")) = #0
    then
      let: "$a0" := #0 in
      do:  struct.storeF CtrServer "val" (![ptrT] "s") "$a0";;;
      do:  #()
    else
      let: "d" := ref_zero (struct.t marshal.Dec) in
      let: "$a0" := marshal.NewDec (![slice.T byteT] "a") in
      do:  "d" <-[struct.t marshal.Dec] "$a0";;;
      let: "$a0" := marshal.Dec__GetInt (![struct.t marshal.Dec] "d") in
      do:  struct.storeF CtrServer "val" (![ptrT] "s") "$a0";;;
      do:  #());;;
    let: "handlers" := ref_zero (mapT (arrowT unitT unitT)) in
    let: "$a0" := NewMap uint64T (arrowT unitT unitT) #() in
    do:  "handlers" <-[mapT (arrowT unitT unitT)] "$a0";;;
    let: "$a0" := (Î»: "args" "reply",
      let: "v" := ref_zero uint64T in
      let: "$a0" := CtrServer__FetchAndIncrement (![ptrT] "s") in
      do:  "v" <-[uint64T] "$a0";;;
      let: "e" := ref_zero (struct.t marshal.Enc) in
      let: "$a0" := marshal.NewEnc #8 in
      do:  "e" <-[struct.t marshal.Enc] "$a0";;;
      do:  marshal.Enc__PutInt (![struct.t marshal.Enc] "e") (![uint64T] "v");;;
      let: "$a0" := marshal.Enc__Finish (![struct.t marshal.Enc] "e") in
      do:  (![ptrT] "reply") <-[slice.T byteT] "$a0";;;
      do:  #()
      ) in
    do:  MapInsert (![mapT (arrowT unitT unitT)] "handlers") #0 "$a0";;;
    let: "rs" := ref_zero ptrT in
    let: "$a0" := urpc.MakeServer (![mapT (arrowT unitT unitT)] "handlers") in
    do:  "rs" <-[ptrT] "$a0";;;
    do:  urpc.Server__Serve (![ptrT] "rs") (![uint64T] "me");;;
    do:  #().
