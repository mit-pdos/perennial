(* autogenerated from github.com/mit-pdos/gokv/bank *)
From Perennial.goose_lang Require Import prelude.
From Goose Require github_dot_com.mit_dash_pdos.gokv.kv.
From Goose Require github_dot_com.mit_dash_pdos.gokv.lockservice.
From Goose Require github_dot_com.tchajed.goose.machine.
From Goose Require github_dot_com.tchajed.marshal.

Section code.
Context `{ext_ty: ext_types}.
Local Coercion Var' s: expr := Var s.

Definition BAL_TOTAL : expr := #1000.

Definition BankClerk := struct.decl [
  "lck" :: ptrT;
  "kvck" :: ptrT;
  "accts" :: slice.T stringT
].

Definition acquire_two_good: val :=
  rec: "acquire_two_good" "lck" "l1" "l2" :=
    let: "l2" := ref_to stringT "l2" in
    let: "l1" := ref_to stringT "l1" in
    let: "lck" := ref_to ptrT "lck" in
    (if: (![stringT] "l1") < (![stringT] "l2")
    then
      do:  lockservice.LockClerk__Lock (![ptrT] "lck") (![stringT] "l1");;;
      do:  lockservice.LockClerk__Lock (![ptrT] "lck") (![stringT] "l2");;;
      do:  #()
    else
      do:  lockservice.LockClerk__Lock (![ptrT] "lck") (![stringT] "l2");;;
      do:  lockservice.LockClerk__Lock (![ptrT] "lck") (![stringT] "l1");;;
      do:  #());;;
    return: (#());;;
    do:  #().

Definition acquire_two: val :=
  rec: "acquire_two" "lck" "l1" "l2" :=
    let: "l2" := ref_to stringT "l2" in
    let: "l1" := ref_to stringT "l1" in
    let: "lck" := ref_to ptrT "lck" in
    do:  lockservice.LockClerk__Lock (![ptrT] "lck") (![stringT] "l1");;;
    do:  lockservice.LockClerk__Lock (![ptrT] "lck") (![stringT] "l2");;;
    return: (#());;;
    do:  #().

Definition release_two: val :=
  rec: "release_two" "lck" "l1" "l2" :=
    let: "l2" := ref_to stringT "l2" in
    let: "l1" := ref_to stringT "l1" in
    let: "lck" := ref_to ptrT "lck" in
    do:  lockservice.LockClerk__Unlock (![ptrT] "lck") (![stringT] "l1");;;
    do:  lockservice.LockClerk__Unlock (![ptrT] "lck") (![stringT] "l2");;;
    return: (#());;;
    do:  #().

Definition encodeInt: val :=
  rec: "encodeInt" "a" :=
    let: "a" := ref_to uint64T "a" in
    return: (StringFromBytes (marshal.WriteInt slice.nil (![uint64T] "a")));;;
    do:  #().

Definition decodeInt: val :=
  rec: "decodeInt" "a" :=
    let: "a" := ref_to stringT "a" in
    let: <> := ref_zero (slice.T byteT) in
    let: "v" := ref_zero uint64T in
    let: ("$a0", "$a1") := marshal.ReadInt (StringToBytes (![stringT] "a")) in
    do:  "$a1";;;
    do:  "v" <-[uint64T] "$a0";;;
    return: (![uint64T] "v");;;
    do:  #().

(* Requires that the account numbers are smaller than num_accounts
   If account balance in acc_from is at least amount, transfer amount to acc_to *)
Definition BankClerk__transfer_internal: val :=
  rec: "BankClerk__transfer_internal" "bck" "acc_from" "acc_to" "amount" :=
    let: "amount" := ref_to uint64T "amount" in
    let: "acc_to" := ref_to stringT "acc_to" in
    let: "acc_from" := ref_to stringT "acc_from" in
    let: "bck" := ref_to ptrT "bck" in
    do:  acquire_two (struct.loadF BankClerk "lck" (![ptrT] "bck")) (![stringT] "acc_from") (![stringT] "acc_to");;;
    let: "old_amount" := ref_zero uint64T in
    let: "$a0" := decodeInt ((struct.loadF kv.Kv "Get" (struct.loadF BankClerk "kvck" (![ptrT] "bck"))) (![stringT] "acc_from")) in
    do:  "old_amount" <-[uint64T] "$a0";;;
    (if: (![uint64T] "old_amount") ≥ (![uint64T] "amount")
    then
      do:  (struct.loadF kv.Kv "Put" (struct.loadF BankClerk "kvck" (![ptrT] "bck"))) (![stringT] "acc_from") (encodeInt ((![uint64T] "old_amount") - (![uint64T] "amount")));;;
      do:  (struct.loadF kv.Kv "Put" (struct.loadF BankClerk "kvck" (![ptrT] "bck"))) (![stringT] "acc_to") (encodeInt ((decodeInt ((struct.loadF kv.Kv "Get" (struct.loadF BankClerk "kvck" (![ptrT] "bck"))) (![stringT] "acc_to"))) + (![uint64T] "amount")));;;
      do:  #()
    else #());;;
    do:  release_two (struct.loadF BankClerk "lck" (![ptrT] "bck")) (![stringT] "acc_from") (![stringT] "acc_to");;;
    do:  #().

Definition BankClerk__SimpleTransfer: val :=
  rec: "BankClerk__SimpleTransfer" "bck" :=
    let: "bck" := ref_to ptrT "bck" in
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "src" := ref_zero uint64T in
      let: "$a0" := machine.RandomUint64 #() in
      do:  "src" <-[uint64T] "$a0";;;
      let: "dst" := ref_zero uint64T in
      let: "$a0" := machine.RandomUint64 #() in
      do:  "dst" <-[uint64T] "$a0";;;
      let: "amount" := ref_zero uint64T in
      let: "$a0" := machine.RandomUint64 #() in
      do:  "amount" <-[uint64T] "$a0";;;
      (if: (((![uint64T] "src") < (slice.len (struct.loadF BankClerk "accts" (![ptrT] "bck")))) && ((![uint64T] "dst") < (slice.len (struct.loadF BankClerk "accts" (![ptrT] "bck"))))) && ((![uint64T] "src") ≠ (![uint64T] "dst"))
      then
        do:  BankClerk__transfer_internal (![ptrT] "bck") (SliceGet stringT (struct.loadF BankClerk "accts" (![ptrT] "bck")) (![uint64T] "src")) (SliceGet stringT (struct.loadF BankClerk "accts" (![ptrT] "bck")) (![uint64T] "dst")) (![uint64T] "amount");;;
        do:  #()
      else #());;;
      do:  #()).

Definition BankClerk__get_total: val :=
  rec: "BankClerk__get_total" "bck" :=
    let: "bck" := ref_to ptrT "bck" in
    let: "sum" := ref (zero_val uint64T) in
    do:  ForSlice stringT <> "acct" (struct.loadF BankClerk "accts" (![ptrT] "bck"))
      (do:  lockservice.LockClerk__Lock (struct.loadF BankClerk "lck" (![ptrT] "bck")) (![stringT] "acct");;;
      let: "$a0" := (![uint64T] "sum") + (decodeInt ((struct.loadF kv.Kv "Get" (struct.loadF BankClerk "kvck" (![ptrT] "bck"))) (![stringT] "acct"))) in
      do:  "sum" <-[uint64T] "$a0";;;
      do:  #());;;
    do:  ForSlice stringT <> "acct" (struct.loadF BankClerk "accts" (![ptrT] "bck"))
      (do:  lockservice.LockClerk__Unlock (struct.loadF BankClerk "lck" (![ptrT] "bck")) (![stringT] "acct");;;
      do:  #());;;
    return: (![uint64T] "sum");;;
    do:  #().

Definition BankClerk__SimpleAudit: val :=
  rec: "BankClerk__SimpleAudit" "bck" :=
    let: "bck" := ref_to ptrT "bck" in
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      (if: (BankClerk__get_total (![ptrT] "bck")) ≠ BAL_TOTAL
      then
        do:  Panic "Balance total invariant violated";;;
        do:  #()
      else #());;;
      do:  #()).

Definition MakeBankClerkSlice: val :=
  rec: "MakeBankClerkSlice" "lck" "kv" "init_flag" "accts" :=
    let: "accts" := ref_to (slice.T stringT) "accts" in
    let: "init_flag" := ref_to stringT "init_flag" in
    let: "kv" := ref_to ptrT "kv" in
    let: "lck" := ref_to ptrT "lck" in
    let: "bck" := ref_zero ptrT in
    let: "$a0" := struct.alloc BankClerk (zero_val (struct.t BankClerk)) in
    do:  "bck" <-[ptrT] "$a0";;;
    let: "$a0" := ![ptrT] "lck" in
    do:  struct.storeF BankClerk "lck" (![ptrT] "bck") "$a0";;;
    let: "$a0" := ![ptrT] "kv" in
    do:  struct.storeF BankClerk "kvck" (![ptrT] "bck") "$a0";;;
    let: "$a0" := ![slice.T stringT] "accts" in
    do:  struct.storeF BankClerk "accts" (![ptrT] "bck") "$a0";;;
    do:  lockservice.LockClerk__Lock (struct.loadF BankClerk "lck" (![ptrT] "bck")) (![stringT] "init_flag");;;
    (if: ((struct.loadF kv.Kv "Get" (struct.loadF BankClerk "kvck" (![ptrT] "bck"))) (![stringT] "init_flag")) = #(str "")
    then
      do:  (struct.loadF kv.Kv "Put" (struct.loadF BankClerk "kvck" (![ptrT] "bck"))) (SliceGet stringT (struct.loadF BankClerk "accts" (![ptrT] "bck")) #0) (encodeInt BAL_TOTAL);;;
      do:  ForSlice stringT <> "acct" (SliceSkip stringT (struct.loadF BankClerk "accts" (![ptrT] "bck")) #1)
        (do:  (struct.loadF kv.Kv "Put" (struct.loadF BankClerk "kvck" (![ptrT] "bck"))) (![stringT] "acct") (encodeInt #0);;;
        do:  #());;;
      do:  (struct.loadF kv.Kv "Put" (struct.loadF BankClerk "kvck" (![ptrT] "bck"))) (![stringT] "init_flag") #(str "1");;;
      do:  #()
    else #());;;
    do:  lockservice.LockClerk__Unlock (struct.loadF BankClerk "lck" (![ptrT] "bck")) (![stringT] "init_flag");;;
    return: (![ptrT] "bck");;;
    do:  #().

Definition MakeBankClerk: val :=
  rec: "MakeBankClerk" "lck" "kv" "init_flag" "acc1" "acc2" :=
    let: "acc2" := ref_to stringT "acc2" in
    let: "acc1" := ref_to stringT "acc1" in
    let: "init_flag" := ref_to stringT "init_flag" in
    let: "kv" := ref_to ptrT "kv" in
    let: "lck" := ref_to ptrT "lck" in
    let: "accts" := ref (zero_val (slice.T stringT)) in
    let: "$a0" := SliceAppend stringT (![slice.T stringT] "accts") (![stringT] "acc1") in
    do:  "accts" <-[slice.T stringT] "$a0";;;
    let: "$a0" := SliceAppend stringT (![slice.T stringT] "accts") (![stringT] "acc2") in
    do:  "accts" <-[slice.T stringT] "$a0";;;
    return: (MakeBankClerkSlice (![ptrT] "lck") (![ptrT] "kv") (![stringT] "init_flag") (![slice.T stringT] "accts"));;;
    do:  #().

End code.
