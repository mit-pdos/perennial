(* autogenerated from github.com/mit-pdos/gokv/cachekv *)
From Perennial.goose_lang Require Import prelude.
From Goose Require github_dot_com.mit_dash_pdos.gokv.grove__ffi.
From Goose Require github_dot_com.mit_dash_pdos.gokv.kv.
From Goose Require github_dot_com.tchajed.marshal.
From Goose Require sync.

From Perennial.goose_lang Require Import ffi.grove_prelude.

Definition cacheValue := struct.decl [
  "v" :: stringT;
  "l" :: uint64T
].

Definition CacheKv := struct.decl [
  "kv" :: ptrT;
  "mu" :: ptrT;
  "cache" :: mapT (struct.t cacheValue)
].

Definition DecodeValue: val :=
  rec: "DecodeValue" "v" :=
    let: "v" := ref_to stringT "v" in
    let: "e" := ref_to (slice.T byteT) (StringToBytes (![stringT] "v")) in
    let: "vBytes" := ref_zero (slice.T byteT) in
    let: "l" := ref_zero uint64T in
    let: ("$a0", "$a1") := marshal.ReadInt (![slice.T byteT] "e") in
    do:  "vBytes" <-[slice.T byteT] "$a1";;;
    do:  "l" <-[uint64T] "$a0";;;
    return: (struct.mk cacheValue [
       "l" ::= ![uint64T] "l";
       "v" ::= StringFromBytes (![slice.T byteT] "vBytes")
     ]);;;
    do:  #().

Definition EncodeValue: val :=
  rec: "EncodeValue" "c" :=
    let: "c" := ref_to (struct.t cacheValue) "c" in
    let: "e" := ref_to (slice.T byteT) (NewSlice byteT #0) in
    let: "$a0" := marshal.WriteInt (![slice.T byteT] "e") (struct.get cacheValue "l" (![struct.t cacheValue] "c")) in
    do:  "e" <-[slice.T byteT] "$a0";;;
    let: "$a0" := marshal.WriteBytes (![slice.T byteT] "e") (StringToBytes (struct.get cacheValue "v" (![struct.t cacheValue] "c"))) in
    do:  "e" <-[slice.T byteT] "$a0";;;
    return: (StringFromBytes (![slice.T byteT] "e"));;;
    do:  #().

Definition max: val :=
  rec: "max" "a" "b" :=
    let: "b" := ref_to uint64T "b" in
    let: "a" := ref_to uint64T "a" in
    (if: (![uint64T] "a") > (![uint64T] "b")
    then
      return: (![uint64T] "a");;;
      do:  #()
    else #());;;
    return: (![uint64T] "b");;;
    do:  #().

Definition Make: val :=
  rec: "Make" "kv" :=
    let: "kv" := ref_to ptrT "kv" in
    return: (struct.new CacheKv [
       "kv" ::= ![ptrT] "kv";
       "mu" ::= struct.alloc sync.Mutex (zero_val (struct.t sync.Mutex));
       "cache" ::= NewMap stringT (struct.t cacheValue) #()
     ]);;;
    do:  #().

Definition CacheKv__Get: val :=
  rec: "CacheKv__Get" "k" "key" :=
    let: "key" := ref_to stringT "key" in
    let: "k" := ref_to ptrT "k" in
    do:  sync.Mutex__Lock (struct.loadF CacheKv "mu" (![ptrT] "k"));;;
    let: "ok" := ref_zero boolT in
    let: "cv" := ref_zero (struct.t cacheValue) in
    let: ("$a0", "$a1") := Fst (MapGet (struct.loadF CacheKv "cache" (![ptrT] "k")) (![stringT] "key")) in
    do:  "ok" <-[boolT] "$a1";;;
    do:  "cv" <-[struct.t cacheValue] "$a0";;;
    let: "high" := ref_zero uint64T in
    let: <> := ref_zero uint64T in
    let: ("$a0", "$a1") := grove__ffi.GetTimeRange #() in
    do:  "high" <-[uint64T] "$a1";;;
    do:  "$a0";;;
    (if: (![boolT] "ok") && ((![uint64T] "high") < (struct.get cacheValue "l" (![struct.t cacheValue] "cv")))
    then
      do:  sync.Mutex__Unlock (struct.loadF CacheKv "mu" (![ptrT] "k"));;;
      return: (struct.get cacheValue "v" (![struct.t cacheValue] "cv"));;;
      do:  #()
    else #());;;
    do:  MapDelete (struct.loadF CacheKv "cache" (![ptrT] "k")) (![stringT] "key");;;
    do:  sync.Mutex__Unlock (struct.loadF CacheKv "mu" (![ptrT] "k"));;;
    return: (struct.get cacheValue "v" (DecodeValue ((struct.loadF kv.Kv "Get" (struct.loadF CacheKv "kv" (![ptrT] "k"))) (![stringT] "key"))));;;
    do:  #().

Definition CacheKv__GetAndCache: val :=
  rec: "CacheKv__GetAndCache" "k" "key" "cachetime" :=
    let: "cachetime" := ref_to uint64T "cachetime" in
    let: "key" := ref_to stringT "key" in
    let: "k" := ref_to ptrT "k" in
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "enc" := ref_zero stringT in
      let: "$a0" := (struct.loadF kv.Kv "Get" (struct.loadF CacheKv "kv" (![ptrT] "k"))) (![stringT] "key") in
      do:  "enc" <-[stringT] "$a0";;;
      let: "old" := ref_zero (struct.t cacheValue) in
      let: "$a0" := DecodeValue (![stringT] "enc") in
      do:  "old" <-[struct.t cacheValue] "$a0";;;
      let: "latest" := ref_zero uint64T in
      let: <> := ref_zero uint64T in
      let: ("$a0", "$a1") := grove__ffi.GetTimeRange #() in
      do:  "latest" <-[uint64T] "$a1";;;
      do:  "$a0";;;
      let: "newLeaseExpiration" := ref_zero uint64T in
      let: "$a0" := max ((![uint64T] "latest") + (![uint64T] "cachetime")) (struct.get cacheValue "l" (![struct.t cacheValue] "old")) in
      do:  "newLeaseExpiration" <-[uint64T] "$a0";;;
      let: "resp" := ref_zero stringT in
      let: "$a0" := (struct.loadF kv.Kv "ConditionalPut" (struct.loadF CacheKv "kv" (![ptrT] "k"))) (![stringT] "key") (![stringT] "enc") (EncodeValue (struct.mk cacheValue [
        "v" ::= struct.get cacheValue "v" (![struct.t cacheValue] "old");
        "l" ::= ![uint64T] "newLeaseExpiration"
      ])) in
      do:  "resp" <-[stringT] "$a0";;;
      (if: (![stringT] "resp") = #(str "ok")
      then
        do:  sync.Mutex__Lock (struct.loadF CacheKv "mu" (![ptrT] "k"));;;
        let: "$a0" := struct.mk cacheValue [
          "v" ::= struct.get cacheValue "v" (![struct.t cacheValue] "old");
          "l" ::= ![uint64T] "newLeaseExpiration"
        ] in
        do:  MapInsert (struct.loadF CacheKv "cache" (![ptrT] "k")) (![stringT] "key") "$a0";;;
        break: #();;;
        do:  #()
      else #());;;
      do:  #()).

Definition CacheKv__Put: val :=
  rec: "CacheKv__Put" "k" "key" "val" :=
    let: "val" := ref_to stringT "val" in
    let: "key" := ref_to stringT "key" in
    let: "k" := ref_to ptrT "k" in
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "enc" := ref_zero stringT in
      let: "$a0" := (struct.loadF kv.Kv "Get" (struct.loadF CacheKv "kv" (![ptrT] "k"))) (![stringT] "key") in
      do:  "enc" <-[stringT] "$a0";;;
      let: "leaseExpiration" := ref_zero uint64T in
      let: "$a0" := struct.get cacheValue "l" (DecodeValue (![stringT] "enc")) in
      do:  "leaseExpiration" <-[uint64T] "$a0";;;
      let: <> := ref_zero uint64T in
      let: "earliest" := ref_zero uint64T in
      let: ("$a0", "$a1") := grove__ffi.GetTimeRange #() in
      do:  "$a1";;;
      do:  "earliest" <-[uint64T] "$a0";;;
      (if: (![uint64T] "leaseExpiration") > (![uint64T] "earliest")
      then
        continue: #();;;
        do:  #()
      else #());;;
      let: "resp" := ref_zero stringT in
      let: "$a0" := (struct.loadF kv.Kv "ConditionalPut" (struct.loadF CacheKv "kv" (![ptrT] "k"))) (![stringT] "key") (![stringT] "enc") (EncodeValue (struct.mk cacheValue [
        "v" ::= ![stringT] "val";
        "l" ::= #0
      ])) in
      do:  "resp" <-[stringT] "$a0";;;
      (if: (![stringT] "resp") = #(str "ok")
      then
        break: #();;;
        do:  #()
      else #());;;
      do:  #()).
