(* autogenerated from github.com/mit-pdos/gokv/etcd/election *)
From Perennial.goose_lang Require Import prelude.

Section code.
Context `{ext_ty: ext_types}.
Local Coercion Var' s: expr := Var s.

Definition Election := struct.decl [
  "lease" :: stringT;
  "keyPrefix" :: stringT;
  "leaderLease" :: stringT;
  "leaderKey" :: stringT;
  "leaderRev" :: uint64T
].

Definition Error: ty := uint64T.

Definition ErrNone : expr := #0.

Definition ErrElectionNotLeader : expr := #1.

Definition Txn := struct.decl [
].

Definition Op := struct.decl [
].

Definition OpGet: val :=
  rec: "OpGet" "key" :=
    let: "key" := ref_to stringT "key" in
    do:  Panic "axiom";;;
    do:  #().

Definition OpPutWithLease: val :=
  rec: "OpPutWithLease" "key" "val" "lease" :=
    let: "lease" := ref_to stringT "lease" in
    let: "val" := ref_to stringT "val" in
    let: "key" := ref_to stringT "key" in
    do:  Panic "axiom";;;
    do:  #().

Definition OpDelete: val :=
  rec: "OpDelete" "key" :=
    let: "key" := ref_to stringT "key" in
    do:  Panic "axiom";;;
    do:  #().

Definition StartTxn: val :=
  rec: "StartTxn" <> :=
    do:  Panic "axiom";;;
    do:  #().

Definition Txn__IfCreateRevisionEq: val :=
  rec: "Txn__IfCreateRevisionEq" "txn" "k" "ver" :=
    let: "ver" := ref_to uint64T "ver" in
    let: "k" := ref_to stringT "k" in
    let: "txn" := ref_to ptrT "txn" in
    do:  Panic "axiom";;;
    do:  #().

Definition Txn__Then: val :=
  rec: "Txn__Then" "txn" "" :=
    let: "" := ref_to ptrT "" in
    let: "txn" := ref_to ptrT "txn" in
    do:  Panic "axiom";;;
    do:  #().

Definition Txn__Else: val :=
  rec: "Txn__Else" "txn" "" :=
    let: "" := ref_to ptrT "" in
    let: "txn" := ref_to ptrT "txn" in
    do:  Panic "axiom";;;
    do:  #().

Definition ResponseHeader := struct.decl [
  "Revision" :: uint64T
].

Definition KeyValue := struct.decl [
  "Key" :: stringT;
  "Value" :: stringT;
  "CreateRevision" :: uint64T
].

Definition RangeResponse := struct.decl [
  "Kvs" :: slice.T ptrT
].

Definition ResponseOp: ty := struct.t RangeResponse.

Definition TxnResponse := struct.decl [
  "Succeeded" :: boolT;
  "Header" :: ptrT;
  "Responses" :: slice.T ptrT
].

Definition Txn__Commit: val :=
  rec: "Txn__Commit" "txn" :=
    let: "txn" := ref_to ptrT "txn" in
    do:  Panic "axiom";;;
    do:  #().

Definition waitDeletes: val :=
  rec: "waitDeletes" "pfx" "rev" :=
    let: "rev" := ref_to uint64T "rev" in
    let: "pfx" := ref_to stringT "pfx" in
    do:  Panic "axiom";;;
    do:  #().

(* Resign lets a leader start a new election. *)
Definition Election__Resign: val :=
  rec: "Election__Resign" "e" :=
    let: "e" := ref_to ptrT "e" in
    (if: (struct.loadF Election "leaderLease" (![ptrT] "e")) = #(str "")
    then
      return: (ErrNone);;;
      do:  #()
    else #());;;
    let: "err" := ref_zero uint64T in
    let: <> := ref_zero ptrT in
    let: ("$a0", "$a1") := Txn__Commit (Txn__Then (Txn__IfCreateRevisionEq (StartTxn #()) (struct.loadF Election "leaderKey" (![ptrT] "e")) (struct.loadF Election "leaderRev" (![ptrT] "e"))) (OpDelete (struct.loadF Election "leaderKey" (![ptrT] "e")))) in
    do:  "err" <-[uint64T] "$a1";;;
    do:  "$a0";;;
    let: "$a0" := #(str "") in
    do:  struct.storeF Election "leaderKey" (![ptrT] "e") "$a0";;;
    let: "$a0" := #(str "") in
    do:  struct.storeF Election "leaderLease" (![ptrT] "e") "$a0";;;
    return: (![uint64T] "err");;;
    do:  #().

(* Proclaim lets the leader announce a new value without another election. *)
Definition Election__Proclaim: val :=
  rec: "Election__Proclaim" "e" "val" :=
    let: "val" := ref_to stringT "val" in
    let: "e" := ref_to ptrT "e" in
    (if: (struct.loadF Election "leaderLease" (![ptrT] "e")) = #(str "")
    then
      return: (ErrElectionNotLeader);;;
      do:  #()
    else #());;;
    let: "txn" := ref_to ptrT (Txn__IfCreateRevisionEq (StartTxn #()) (struct.loadF Election "leaderKey" (![ptrT] "e")) (struct.loadF Election "leaderRev" (![ptrT] "e"))) in
    let: "$a0" := Txn__Then (![ptrT] "txn") (OpPutWithLease (struct.loadF Election "leaderKey" (![ptrT] "e")) (![stringT] "val") (struct.loadF Election "leaderLease" (![ptrT] "e"))) in
    do:  "txn" <-[ptrT] "$a0";;;
    let: "terr" := ref_zero uint64T in
    let: "tresp" := ref_zero ptrT in
    let: ("$a0", "$a1") := Txn__Commit (![ptrT] "txn") in
    do:  "terr" <-[uint64T] "$a1";;;
    do:  "tresp" <-[ptrT] "$a0";;;
    (if: (![uint64T] "terr") ≠ ErrNone
    then
      return: (![uint64T] "terr");;;
      do:  #()
    else #());;;
    (if: (~ (struct.loadF TxnResponse "Succeeded" (![ptrT] "tresp")))
    then
      let: "$a0" := #(str "") in
      do:  struct.storeF Election "leaderKey" (![ptrT] "e") "$a0";;;
      return: (ErrElectionNotLeader);;;
      do:  #()
    else #());;;
    return: (ErrNone);;;
    do:  #().

Definition Election__Campaign: val :=
  rec: "Election__Campaign" "e" "val" :=
    let: "val" := ref_to stringT "val" in
    let: "e" := ref_to ptrT "e" in
    let: "l" := ref_zero stringT in
    let: "$a0" := struct.loadF Election "lease" (![ptrT] "e") in
    do:  "l" <-[stringT] "$a0";;;
    let: "k" := ref_zero stringT in
    let: "$a0" := (struct.loadF Election "keyPrefix" (![ptrT] "e")) + (![stringT] "l") in
    do:  "k" <-[stringT] "$a0";;;
    let: "txn" := ref_to ptrT (Txn__IfCreateRevisionEq (StartTxn #()) (![stringT] "k") #0) in
    let: "$a0" := Txn__Then (![ptrT] "txn") (OpPutWithLease (![stringT] "k") (![stringT] "val") (struct.loadF Election "lease" (![ptrT] "e"))) in
    do:  "txn" <-[ptrT] "$a0";;;
    let: "$a0" := Txn__Else (![ptrT] "txn") (OpGet (![stringT] "k")) in
    do:  "txn" <-[ptrT] "$a0";;;
    let: "resp" := ref (zero_val ptrT) in
    let: "err" := ref (zero_val uint64T) in
    let: ("$a0", "$a1") := Txn__Commit (![ptrT] "txn") in
    do:  "err" <-[uint64T] "$a1";;;
    do:  "resp" <-[ptrT] "$a0";;;
    (if: (![uint64T] "err") ≠ ErrNone
    then
      return: (![uint64T] "err");;;
      do:  #()
    else #());;;
    let: "$a0" := ![stringT] "k" in
    do:  struct.storeF Election "leaderKey" (![ptrT] "e") "$a0";;;
    let: "$a0" := struct.loadF ResponseHeader "Revision" (struct.loadF TxnResponse "Header" (![ptrT] "resp")) in
    do:  struct.storeF Election "leaderRev" (![ptrT] "e") "$a0";;;
    let: "$a0" := ![stringT] "l" in
    do:  struct.storeF Election "leaderLease" (![ptrT] "e") "$a0";;;
    let: "done" := ref_to boolT #false in
    (if: (~ (struct.loadF TxnResponse "Succeeded" (![ptrT] "resp")))
    then
      let: "kv" := ref_zero ptrT in
      let: "$a0" := SliceGet ptrT (struct.loadF RangeResponse "Kvs" (SliceGet ptrT (struct.loadF TxnResponse "Responses" (![ptrT] "resp")) #0)) #0 in
      do:  "kv" <-[ptrT] "$a0";;;
      let: "$a0" := struct.loadF KeyValue "CreateRevision" (![ptrT] "kv") in
      do:  struct.storeF Election "leaderRev" (![ptrT] "e") "$a0";;;
      (if: (struct.loadF KeyValue "Value" (![ptrT] "kv")) ≠ (![stringT] "val")
      then
        let: "$a0" := Election__Proclaim (![ptrT] "e") (![stringT] "val") in
        do:  "err" <-[uint64T] "$a0";;;
        (if: (![uint64T] "err") ≠ ErrNone
        then
          do:  Election__Resign (![ptrT] "e");;;
          let: "$a0" := #true in
          do:  "done" <-[boolT] "$a0";;;
          do:  #()
        else #());;;
        do:  #()
      else #());;;
      do:  #()
    else #());;;
    (if: ![boolT] "done"
    then
      return: (![uint64T] "err");;;
      do:  #()
    else #());;;
    let: "$a0" := waitDeletes (struct.loadF Election "keyPrefix" (![ptrT] "e")) ((struct.loadF Election "leaderRev" (![ptrT] "e")) - #1) in
    do:  "err" <-[uint64T] "$a0";;;
    (if: (![uint64T] "err") ≠ ErrNone
    then do:  #()
    else #());;;
    return: (ErrNone);;;
    do:  #().

End code.
