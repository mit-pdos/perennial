#!/usr/bin/env python3

import os
import re
import sys
from dataclasses import dataclass
from pathlib import Path
from typing import List


class TemplateProcessor:
    """Processes template files with marked sections."""

    TEMPLATE_BEGIN = "(* BEGIN TEMPLATE *)"
    TEMPLATE_END = "(* END TEMPLATE *)"
    AUTO_GEN_BEGIN = "(* AUTO-GENERATED - DO NOT EDIT *)"
    AUTO_GEN_END = "(* END AUTO-GENERATED *)"

    def __init__(self, filepath):
        self.filepath = filepath
        self.content: str | None = None
        self.template: str | None = None
        self._before_auto_gen = None
        self._after_auto_gen = None

    def read_file(self):
        """Read the file content."""
        try:
            with open(self.filepath, "r") as f:
                self.content = f.read()
        except FileNotFoundError:
            print(f"Error: File '{self.filepath}' not found.", file=sys.stderr)
            sys.exit(1)
        except Exception as e:
            print(f"Error reading file: {e}", file=sys.stderr)
            sys.exit(1)

    def _parse_template(self):
        """Extract the template section from the file."""
        assert self.content is not None
        template_pattern = (
            # exclude the newline after the begin marker, so it isn't part of the template
            re.escape(self.TEMPLATE_BEGIN) + r"\n(.*?)" + re.escape(self.TEMPLATE_END)
        )
        m = re.search(template_pattern, self.content, re.DOTALL)

        if m:
            self.template = m.group(1)
        else:
            raise ValueError(
                f"template not found (starting with {self.TEMPLATE_BEGIN})"
            )

    def _parse_auto_gen_section(self):
        """Find the auto-generated section where template output should go.

        To insert the output here, we just track the contents before and after.
        """
        assert self.content is not None
        m = re.search(re.escape(self.AUTO_GEN_BEGIN), self.content)
        if m:
            self._before_auto_gen = self.content[: m.end(0)]
        else:
            raise ValueError("auto gen start not found")
        m = re.search(re.escape(self.AUTO_GEN_END), self.content)
        if m:
            self._after_auto_gen = self.content[m.start(0) :]
        else:
            raise ValueError("auto gen end not found")

    def process(self):
        """Main processing function."""
        self.read_file()
        self._parse_template()
        self._parse_auto_gen_section()

    def output(self, auto_gen_content):
        """Output file with auto-generated section replaced.

        The caller should do the template processing and produce
        auto_gen_content.
        """
        # indent the generated content to make it visually separate from the
        # hand-written template
        auto_gen_indented = "  " + auto_gen_content.replace("\n", "\n  ")
        # remove lines with only whitespace
        auto_gen_indented = "\n".join(
            [line if line.strip() else "" for line in auto_gen_indented.splitlines()]
        )
        return (
            f"{self._before_auto_gen}\n"
            + f"{auto_gen_indented}\n"
            + f"{self._after_auto_gen}"
        )


@dataclass
class IntType:
    name: str
    typ_: str


def generic_template(tmpl: str, base: IntType, configs: List[IntType]) -> str:
    components = [f"(* auto-generated by {os.path.basename(__file__)} *)"]
    for config in configs:
        new = tmpl.replace(base.name, config.name).replace(base.typ_, config.typ_)
        components.append(f"(** {config.name} *)\n{new}")
    return "\n".join(components)


def int_template(tmpl: str) -> str:
    return generic_template(
        tmpl,
        IntType("Uint64", "w64"),
        [
            IntType("Int64", "w64"),
            IntType("Uint32", "w32"),
            IntType("Int32", "w32"),
        ],
    )


def signed_int_template(tmpl):
    return generic_template(
        tmpl,
        IntType("int64", "w64"),
        [
            IntType("int32", "w32"),
            IntType("int16", "w16"),
            IntType("int8", "w8"),
        ],
    )


def main():
    import argparse

    parser = argparse.ArgumentParser(
        description=f"""
Generalize a template written for u64 to other integer types. For examples, see
new/proof/sync/atomic.v and new/golang/theory/builtin.v. The template and
auto-generated output are placed between comment markers within the input file:

    {TemplateProcessor.TEMPLATE_BEGIN}
        <code that uses Uint64 or w64>
    {TemplateProcessor.TEMPLATE_END}
    {TemplateProcessor.AUTO_GEN_BEGIN}
        <will be filled in by this script>
    {TemplateProcessor.AUTO_GEN_END}
""",
        formatter_class=argparse.RawTextHelpFormatter,
    )
    parser.add_argument("template_file", type=Path)
    parser.add_argument(
        "--signed-int",
        action="store_true",
        help="use the config for signed ints (for new/golang/theory/builtin.v)",
    )
    args = parser.parse_args()

    filepath = args.template_file
    processor = TemplateProcessor(filepath)
    processor.process()
    assert processor.template is not None

    if args.signed_int:
        output = processor.output(signed_int_template(processor.template))
    else:
        output = processor.output(int_template(processor.template))
    if processor.content != output:
        print(f"updated {filepath}")
        with open(args.template_file, "w") as f:
            f.write(output)


if __name__ == "__main__":
    main()
