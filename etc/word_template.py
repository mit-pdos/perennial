#!/usr/bin/env python3

import os
import re
import sys
from pathlib import Path
from dataclasses import dataclass

# TODO: this is a copy paste of int_template.py -
# the commonalities should be abstracted away so it works for both.
#
# The ideal interface would be that the template itself contains the
# configuration for what replacements should be made.


class TemplateProcessor:
    """Processes template files with marked sections."""

    TEMPLATE_BEGIN = "(* BEGIN TEMPLATE *)"
    TEMPLATE_END = "(* END TEMPLATE *)"
    AUTO_GEN_BEGIN = "(* AUTO-GENERATED - DO NOT EDIT *)"
    AUTO_GEN_END = "(* END AUTO-GENERATED *)"

    def __init__(self, filepath):
        self.filepath = filepath
        self.content = None
        self.template = None
        self._before_auto_gen = None
        self._after_auto_gen = None

    def read_file(self):
        """Read the file content."""
        try:
            with open(self.filepath, "r") as f:
                self.content = f.read()
        except FileNotFoundError:
            print(f"Error: File '{self.filepath}' not found.", file=sys.stderr)
            sys.exit(1)
        except Exception as e:
            print(f"Error reading file: {e}", file=sys.stderr)
            sys.exit(1)

    def _parse_template(self):
        """Extract the template section from the file."""
        template_pattern = (
            # exclude the newline after the begin marker, so it isn't part of the template
            re.escape(self.TEMPLATE_BEGIN) + r"\n(.*?)" + re.escape(self.TEMPLATE_END)
        )
        m = re.search(template_pattern, self.content, re.DOTALL)

        if m:
            self.template = m.group(1)
        else:
            raise ValueError(
                f"template not found (starting with {self.TEMPLATE_BEGIN})"
            )

    def _parse_auto_gen_section(self):
        """Find the auto-generated section where template output should go.

        To insert the output here, we just track the contents before and after.
        """
        m = re.search(re.escape(self.AUTO_GEN_BEGIN), self.content)
        if m:
            self._before_auto_gen = self.content[: m.end(0)]
        else:
            raise ValueError("auto gen start not found")
        m = re.search(re.escape(self.AUTO_GEN_END), self.content)
        if m:
            self._after_auto_gen = self.content[m.start(0) :]
        else:
            raise ValueError("auto gen end not found")

    def process(self):
        """Main processing function."""
        self.read_file()
        self._parse_template()
        self._parse_auto_gen_section()

    def output(self, auto_gen_content):
        """Output file with auto-generated section replaced.

        The caller should do the template processing and produce
        auto_gen_content.
        """
        # indent the generated content to make it visually separate from the
        # hand-written template
        auto_gen_indented = "  " + auto_gen_content.replace("\n", "\n  ")
        return (
            f"{self._before_auto_gen}\n"
            + f"{auto_gen_indented}\n"
            + f"{self._after_auto_gen}"
        )


@dataclass
class IntType:
    name: str
    typ_: str


def int_template(tmpl):
    base = IntType("int64", "w64")
    components = [f"(* auto-generated by {os.path.basename(__file__)} *)"]
    for config in [
        IntType("int32", "w32"),
        IntType("int16", "w16"),
        IntType("int8", "w8"),
    ]:
        new = tmpl.replace(base.name, config.name).replace(base.typ_, config.typ_)
        components.append(f"(** {config.name} *)\n{new}")
    return "\n".join(components)


def main():
    import argparse

    parser = argparse.ArgumentParser(
        description="""
Generalize a template written for w64 to other integer widths (for example, see
new/golang/theory/builtin.v). The template and auto-generated output are placed
between comment markers within the input file.
"""
    )
    parser.add_argument("template_file", type=Path)
    args = parser.parse_args()

    filepath = args.template_file
    processor = TemplateProcessor(filepath)
    processor.process()

    output = processor.output(int_template(processor.template))
    if processor.content != output:
        print(f"updated {filepath}")
        with open(args.template_file, "w") as f:
            f.write(output)


if __name__ == "__main__":
    main()
