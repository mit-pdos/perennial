(* autogenerated by goose proofgen; do not modify *)
Require Export New.proof.grove_prelude.
Require Export New.generatedproof.github_com.mit_pdos.gokv.grove_ffi.
Require Export New.golang.theory.

Require Export New.code.github_com.mit_pdos.tulip.tulip.

Set Default Proof Using "Type".

Module tulip.

(* type tulip.Value *)
Module Value.
Section def.
Context `{ffi_syntax}.
Record t := mk {
  Present' : bool;
  Content' : go_string;
}.
End def.
End Value.

Section instances.
Context `{ffi_syntax}.

Global Instance settable_Value : Settable Value.t :=
  settable! Value.mk < Value.Present'; Value.Content' >.
Global Instance into_val_Value : IntoVal Value.t :=
  {| to_val_def v :=
    struct.val_aux tulip.Value [
    "Present" ::= #(Value.Present' v);
    "Content" ::= #(Value.Content' v)
    ]%struct
  |}.

Global Program Instance into_val_typed_Value : IntoValTyped Value.t tulip.Value :=
{|
  default_val := Value.mk (default_val _) (default_val _);
|}.
Next Obligation. solve_to_val_type. Qed.
Next Obligation. solve_zero_val. Qed.
Next Obligation. solve_to_val_inj. Qed.
Final Obligation. solve_decision. Qed.

Global Instance into_val_struct_field_Value_Present : IntoValStructField "Present" tulip.Value Value.Present'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_Value_Content : IntoValStructField "Content" tulip.Value Value.Content'.
Proof. solve_into_val_struct_field. Qed.


Context `{!ffi_model, !ffi_semantics _ _, !ffi_interp _, !heapGS Σ}.
Global Instance wp_struct_make_Value Present' Content':
  PureWp True
    (struct.make #tulip.Value (alist_val [
      "Present" ::= #Present';
      "Content" ::= #Content'
    ]))%struct
    #(Value.mk Present' Content').
Proof. solve_struct_make_pure_wp. Qed.


Global Instance Value_struct_fields_split dq l (v : Value.t) :
  StructFieldsSplit dq l v (
    "HPresent" ∷ l ↦s[tulip.Value :: "Present"]{dq} v.(Value.Present') ∗
    "HContent" ∷ l ↦s[tulip.Value :: "Content"]{dq} v.(Value.Content')
  ).
Proof.
  rewrite /named.
  apply struct_fields_split_intro.
  unfold_typed_pointsto; split_pointsto_app.

  rewrite -!/(typed_pointsto_def _ _ _) -!typed_pointsto_unseal.
  simpl_one_flatten_struct (# (Value.Present' v)) tulip.Value "Present"%go.

  solve_field_ref_f.
Qed.

End instances.

(* type tulip.WriteEntry *)
Module WriteEntry.
Section def.
Context `{ffi_syntax}.
Record t := mk {
  Key' : go_string;
  Value' : Value.t;
}.
End def.
End WriteEntry.

Section instances.
Context `{ffi_syntax}.

Global Instance settable_WriteEntry : Settable WriteEntry.t :=
  settable! WriteEntry.mk < WriteEntry.Key'; WriteEntry.Value' >.
Global Instance into_val_WriteEntry : IntoVal WriteEntry.t :=
  {| to_val_def v :=
    struct.val_aux tulip.WriteEntry [
    "Key" ::= #(WriteEntry.Key' v);
    "Value" ::= #(WriteEntry.Value' v)
    ]%struct
  |}.

Global Program Instance into_val_typed_WriteEntry : IntoValTyped WriteEntry.t tulip.WriteEntry :=
{|
  default_val := WriteEntry.mk (default_val _) (default_val _);
|}.
Next Obligation. solve_to_val_type. Qed.
Next Obligation. solve_zero_val. Qed.
Next Obligation. solve_to_val_inj. Qed.
Final Obligation. solve_decision. Qed.

Global Instance into_val_struct_field_WriteEntry_Key : IntoValStructField "Key" tulip.WriteEntry WriteEntry.Key'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_WriteEntry_Value : IntoValStructField "Value" tulip.WriteEntry WriteEntry.Value'.
Proof. solve_into_val_struct_field. Qed.


Context `{!ffi_model, !ffi_semantics _ _, !ffi_interp _, !heapGS Σ}.
Global Instance wp_struct_make_WriteEntry Key' Value':
  PureWp True
    (struct.make #tulip.WriteEntry (alist_val [
      "Key" ::= #Key';
      "Value" ::= #Value'
    ]))%struct
    #(WriteEntry.mk Key' Value').
Proof. solve_struct_make_pure_wp. Qed.


Global Instance WriteEntry_struct_fields_split dq l (v : WriteEntry.t) :
  StructFieldsSplit dq l v (
    "HKey" ∷ l ↦s[tulip.WriteEntry :: "Key"]{dq} v.(WriteEntry.Key') ∗
    "HValue" ∷ l ↦s[tulip.WriteEntry :: "Value"]{dq} v.(WriteEntry.Value')
  ).
Proof.
  rewrite /named.
  apply struct_fields_split_intro.
  unfold_typed_pointsto; split_pointsto_app.

  rewrite -!/(typed_pointsto_def _ _ _) -!typed_pointsto_unseal.
  simpl_one_flatten_struct (# (WriteEntry.Key' v)) tulip.WriteEntry "Key"%go.

  solve_field_ref_f.
Qed.

End instances.

(* type tulip.Version *)
Module Version.
Section def.
Context `{ffi_syntax}.
Record t := mk {
  Timestamp' : w64;
  Value' : Value.t;
}.
End def.
End Version.

Section instances.
Context `{ffi_syntax}.

Global Instance settable_Version : Settable Version.t :=
  settable! Version.mk < Version.Timestamp'; Version.Value' >.
Global Instance into_val_Version : IntoVal Version.t :=
  {| to_val_def v :=
    struct.val_aux tulip.Version [
    "Timestamp" ::= #(Version.Timestamp' v);
    "Value" ::= #(Version.Value' v)
    ]%struct
  |}.

Global Program Instance into_val_typed_Version : IntoValTyped Version.t tulip.Version :=
{|
  default_val := Version.mk (default_val _) (default_val _);
|}.
Next Obligation. solve_to_val_type. Qed.
Next Obligation. solve_zero_val. Qed.
Next Obligation. solve_to_val_inj. Qed.
Final Obligation. solve_decision. Qed.

Global Instance into_val_struct_field_Version_Timestamp : IntoValStructField "Timestamp" tulip.Version Version.Timestamp'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_Version_Value : IntoValStructField "Value" tulip.Version Version.Value'.
Proof. solve_into_val_struct_field. Qed.


Context `{!ffi_model, !ffi_semantics _ _, !ffi_interp _, !heapGS Σ}.
Global Instance wp_struct_make_Version Timestamp' Value':
  PureWp True
    (struct.make #tulip.Version (alist_val [
      "Timestamp" ::= #Timestamp';
      "Value" ::= #Value'
    ]))%struct
    #(Version.mk Timestamp' Value').
Proof. solve_struct_make_pure_wp. Qed.


Global Instance Version_struct_fields_split dq l (v : Version.t) :
  StructFieldsSplit dq l v (
    "HTimestamp" ∷ l ↦s[tulip.Version :: "Timestamp"]{dq} v.(Version.Timestamp') ∗
    "HValue" ∷ l ↦s[tulip.Version :: "Value"]{dq} v.(Version.Value')
  ).
Proof.
  rewrite /named.
  apply struct_fields_split_intro.
  unfold_typed_pointsto; split_pointsto_app.

  rewrite -!/(typed_pointsto_def _ _ _) -!typed_pointsto_unseal.
  simpl_one_flatten_struct (# (Version.Timestamp' v)) tulip.Version "Timestamp"%go.

  solve_field_ref_f.
Qed.

End instances.

(* type tulip.PrepareProposal *)
Module PrepareProposal.
Section def.
Context `{ffi_syntax}.
Record t := mk {
  Rank' : w64;
  Prepared' : bool;
}.
End def.
End PrepareProposal.

Section instances.
Context `{ffi_syntax}.

Global Instance settable_PrepareProposal : Settable PrepareProposal.t :=
  settable! PrepareProposal.mk < PrepareProposal.Rank'; PrepareProposal.Prepared' >.
Global Instance into_val_PrepareProposal : IntoVal PrepareProposal.t :=
  {| to_val_def v :=
    struct.val_aux tulip.PrepareProposal [
    "Rank" ::= #(PrepareProposal.Rank' v);
    "Prepared" ::= #(PrepareProposal.Prepared' v)
    ]%struct
  |}.

Global Program Instance into_val_typed_PrepareProposal : IntoValTyped PrepareProposal.t tulip.PrepareProposal :=
{|
  default_val := PrepareProposal.mk (default_val _) (default_val _);
|}.
Next Obligation. solve_to_val_type. Qed.
Next Obligation. solve_zero_val. Qed.
Next Obligation. solve_to_val_inj. Qed.
Final Obligation. solve_decision. Qed.

Global Instance into_val_struct_field_PrepareProposal_Rank : IntoValStructField "Rank" tulip.PrepareProposal PrepareProposal.Rank'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_PrepareProposal_Prepared : IntoValStructField "Prepared" tulip.PrepareProposal PrepareProposal.Prepared'.
Proof. solve_into_val_struct_field. Qed.


Context `{!ffi_model, !ffi_semantics _ _, !ffi_interp _, !heapGS Σ}.
Global Instance wp_struct_make_PrepareProposal Rank' Prepared':
  PureWp True
    (struct.make #tulip.PrepareProposal (alist_val [
      "Rank" ::= #Rank';
      "Prepared" ::= #Prepared'
    ]))%struct
    #(PrepareProposal.mk Rank' Prepared').
Proof. solve_struct_make_pure_wp. Qed.


Global Instance PrepareProposal_struct_fields_split dq l (v : PrepareProposal.t) :
  StructFieldsSplit dq l v (
    "HRank" ∷ l ↦s[tulip.PrepareProposal :: "Rank"]{dq} v.(PrepareProposal.Rank') ∗
    "HPrepared" ∷ l ↦s[tulip.PrepareProposal :: "Prepared"]{dq} v.(PrepareProposal.Prepared')
  ).
Proof.
  rewrite /named.
  apply struct_fields_split_intro.
  unfold_typed_pointsto; split_pointsto_app.

  rewrite -!/(typed_pointsto_def _ _ _) -!typed_pointsto_unseal.
  simpl_one_flatten_struct (# (PrepareProposal.Rank' v)) tulip.PrepareProposal "Rank"%go.

  solve_field_ref_f.
Qed.

End instances.

(* type tulip.CoordID *)
Module CoordID.
Section def.
Context `{ffi_syntax}.
Record t := mk {
  GroupID' : w64;
  ReplicaID' : w64;
}.
End def.
End CoordID.

Section instances.
Context `{ffi_syntax}.

Global Instance settable_CoordID : Settable CoordID.t :=
  settable! CoordID.mk < CoordID.GroupID'; CoordID.ReplicaID' >.
Global Instance into_val_CoordID : IntoVal CoordID.t :=
  {| to_val_def v :=
    struct.val_aux tulip.CoordID [
    "GroupID" ::= #(CoordID.GroupID' v);
    "ReplicaID" ::= #(CoordID.ReplicaID' v)
    ]%struct
  |}.

Global Program Instance into_val_typed_CoordID : IntoValTyped CoordID.t tulip.CoordID :=
{|
  default_val := CoordID.mk (default_val _) (default_val _);
|}.
Next Obligation. solve_to_val_type. Qed.
Next Obligation. solve_zero_val. Qed.
Next Obligation. solve_to_val_inj. Qed.
Final Obligation. solve_decision. Qed.

Global Instance into_val_struct_field_CoordID_GroupID : IntoValStructField "GroupID" tulip.CoordID CoordID.GroupID'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_CoordID_ReplicaID : IntoValStructField "ReplicaID" tulip.CoordID CoordID.ReplicaID'.
Proof. solve_into_val_struct_field. Qed.


Context `{!ffi_model, !ffi_semantics _ _, !ffi_interp _, !heapGS Σ}.
Global Instance wp_struct_make_CoordID GroupID' ReplicaID':
  PureWp True
    (struct.make #tulip.CoordID (alist_val [
      "GroupID" ::= #GroupID';
      "ReplicaID" ::= #ReplicaID'
    ]))%struct
    #(CoordID.mk GroupID' ReplicaID').
Proof. solve_struct_make_pure_wp. Qed.


Global Instance CoordID_struct_fields_split dq l (v : CoordID.t) :
  StructFieldsSplit dq l v (
    "HGroupID" ∷ l ↦s[tulip.CoordID :: "GroupID"]{dq} v.(CoordID.GroupID') ∗
    "HReplicaID" ∷ l ↦s[tulip.CoordID :: "ReplicaID"]{dq} v.(CoordID.ReplicaID')
  ).
Proof.
  rewrite /named.
  apply struct_fields_split_intro.
  unfold_typed_pointsto; split_pointsto_app.

  rewrite -!/(typed_pointsto_def _ _ _) -!typed_pointsto_unseal.
  simpl_one_flatten_struct (# (CoordID.GroupID' v)) tulip.CoordID "GroupID"%go.

  solve_field_ref_f.
Qed.

End instances.

(* type tulip.KVMap *)
Module KVMap.
Section def.
Context `{ffi_syntax}.
Definition t := loc.
End def.
End KVMap.

(* type tulip.AddressMap *)
Module AddressMap.
Section def.
Context `{ffi_syntax}.
Definition t := loc.
End def.
End AddressMap.

(* type tulip.AddressMaps *)
Module AddressMaps.
Section def.
Context `{ffi_syntax}.
Definition t := loc.
End def.
End AddressMaps.

Section names.

Class GlobalAddrs :=
{
}.

Context `{!GlobalAddrs}.
Context `{!heapGS Σ}.
Context `{!goGlobalsGS Σ}.

Definition var_addrs : list (go_string * loc) := [
  ].

Global Instance is_pkg_defined_instance : IsPkgDefined tulip :=
{|
  is_pkg_defined := is_global_definitions tulip var_addrs;
|}.

Definition own_allocated : iProp Σ :=
True.

End names.
End tulip.
