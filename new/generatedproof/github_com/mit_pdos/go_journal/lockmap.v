(* autogenerated by goose proofgen; do not modify *)
Require Export New.proof.proof_prelude.
Require Export New.generatedproof.sync.
Require Export New.golang.theory.

Require Export New.code.github_com.mit_pdos.go_journal.lockmap.

Set Default Proof Using "Type".

Module lockmap.

Module lockState.
Section def.
Context `{ffi_syntax}.
Record t := mk {
  held' : bool;
  cond' : loc;
  waiters' : w64;
}.
End def.
End lockState.

Section instances.
Context `{ffi_syntax}.

Global Instance settable_lockState : Settable _ :=
  settable! lockState.mk < lockState.held'; lockState.cond'; lockState.waiters' >.
Global Instance into_val_lockState : IntoVal lockState.t :=
  {| to_val_def v :=
    struct.val_aux lockmap.lockState [
    "held" ::= #(lockState.held' v);
    "cond" ::= #(lockState.cond' v);
    "waiters" ::= #(lockState.waiters' v)
    ]%struct
  |}.

Global Program Instance into_val_typed_lockState : IntoValTyped lockState.t lockmap.lockState :=
{|
  default_val := lockState.mk (default_val _) (default_val _) (default_val _);
|}.
Next Obligation. solve_to_val_type. Qed.
Next Obligation. solve_zero_val. Qed.
Next Obligation. solve_to_val_inj. Qed.
Final Obligation. solve_decision. Qed.

Global Instance into_val_struct_field_lockState_held : IntoValStructField "held" lockmap.lockState lockState.held'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_lockState_cond : IntoValStructField "cond" lockmap.lockState lockState.cond'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_lockState_waiters : IntoValStructField "waiters" lockmap.lockState lockState.waiters'.
Proof. solve_into_val_struct_field. Qed.


Context `{!ffi_model, !ffi_semantics _ _, !ffi_interp _, !heapGS Σ}.
Global Instance wp_struct_make_lockState held' cond' waiters':
  PureWp True
    (struct.make #lockmap.lockState (alist_val [
      "held" ::= #held';
      "cond" ::= #cond';
      "waiters" ::= #waiters'
    ]))%struct
    #(lockState.mk held' cond' waiters').
Proof. solve_struct_make_pure_wp. Qed.


Global Instance lockState_struct_fields_split dq l (v : lockState.t) :
  StructFieldsSplit dq l v (
    "Hheld" ∷ l ↦s[lockmap.lockState :: "held"]{dq} v.(lockState.held') ∗
    "Hcond" ∷ l ↦s[lockmap.lockState :: "cond"]{dq} v.(lockState.cond') ∗
    "Hwaiters" ∷ l ↦s[lockmap.lockState :: "waiters"]{dq} v.(lockState.waiters')
  ).
Proof.
  rewrite /named.
  apply struct_fields_split_intro.
  unfold_typed_pointsto; split_pointsto_app.

  rewrite -!/(typed_pointsto_def _ _ _) -!typed_pointsto_unseal.
  simpl_one_flatten_struct (# (lockState.held' v)) lockmap.lockState "held"%go.
  simpl_one_flatten_struct (# (lockState.cond' v)) lockmap.lockState "cond"%go.

  solve_field_ref_f.
Qed.

End instances.

Module lockShard.
Section def.
Context `{ffi_syntax}.
Record t := mk {
  mu' : loc;
  state' : loc;
}.
End def.
End lockShard.

Section instances.
Context `{ffi_syntax}.

Global Instance settable_lockShard : Settable _ :=
  settable! lockShard.mk < lockShard.mu'; lockShard.state' >.
Global Instance into_val_lockShard : IntoVal lockShard.t :=
  {| to_val_def v :=
    struct.val_aux lockmap.lockShard [
    "mu" ::= #(lockShard.mu' v);
    "state" ::= #(lockShard.state' v)
    ]%struct
  |}.

Global Program Instance into_val_typed_lockShard : IntoValTyped lockShard.t lockmap.lockShard :=
{|
  default_val := lockShard.mk (default_val _) (default_val _);
|}.
Next Obligation. solve_to_val_type. Qed.
Next Obligation. solve_zero_val. Qed.
Next Obligation. solve_to_val_inj. Qed.
Final Obligation. solve_decision. Qed.

Global Instance into_val_struct_field_lockShard_mu : IntoValStructField "mu" lockmap.lockShard lockShard.mu'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_lockShard_state : IntoValStructField "state" lockmap.lockShard lockShard.state'.
Proof. solve_into_val_struct_field. Qed.


Context `{!ffi_model, !ffi_semantics _ _, !ffi_interp _, !heapGS Σ}.
Global Instance wp_struct_make_lockShard mu' state':
  PureWp True
    (struct.make #lockmap.lockShard (alist_val [
      "mu" ::= #mu';
      "state" ::= #state'
    ]))%struct
    #(lockShard.mk mu' state').
Proof. solve_struct_make_pure_wp. Qed.


Global Instance lockShard_struct_fields_split dq l (v : lockShard.t) :
  StructFieldsSplit dq l v (
    "Hmu" ∷ l ↦s[lockmap.lockShard :: "mu"]{dq} v.(lockShard.mu') ∗
    "Hstate" ∷ l ↦s[lockmap.lockShard :: "state"]{dq} v.(lockShard.state')
  ).
Proof.
  rewrite /named.
  apply struct_fields_split_intro.
  unfold_typed_pointsto; split_pointsto_app.

  rewrite -!/(typed_pointsto_def _ _ _) -!typed_pointsto_unseal.
  simpl_one_flatten_struct (# (lockShard.mu' v)) lockmap.lockShard "mu"%go.

  solve_field_ref_f.
Qed.

End instances.

Module LockMap.
Section def.
Context `{ffi_syntax}.
Record t := mk {
  shards' : slice.t;
}.
End def.
End LockMap.

Section instances.
Context `{ffi_syntax}.

Global Instance settable_LockMap : Settable _ :=
  settable! LockMap.mk < LockMap.shards' >.
Global Instance into_val_LockMap : IntoVal LockMap.t :=
  {| to_val_def v :=
    struct.val_aux lockmap.LockMap [
    "shards" ::= #(LockMap.shards' v)
    ]%struct
  |}.

Global Program Instance into_val_typed_LockMap : IntoValTyped LockMap.t lockmap.LockMap :=
{|
  default_val := LockMap.mk (default_val _);
|}.
Next Obligation. solve_to_val_type. Qed.
Next Obligation. solve_zero_val. Qed.
Next Obligation. solve_to_val_inj. Qed.
Final Obligation. solve_decision. Qed.

Global Instance into_val_struct_field_LockMap_shards : IntoValStructField "shards" lockmap.LockMap LockMap.shards'.
Proof. solve_into_val_struct_field. Qed.


Context `{!ffi_model, !ffi_semantics _ _, !ffi_interp _, !heapGS Σ}.
Global Instance wp_struct_make_LockMap shards':
  PureWp True
    (struct.make #lockmap.LockMap (alist_val [
      "shards" ::= #shards'
    ]))%struct
    #(LockMap.mk shards').
Proof. solve_struct_make_pure_wp. Qed.


Global Instance LockMap_struct_fields_split dq l (v : LockMap.t) :
  StructFieldsSplit dq l v (
    "Hshards" ∷ l ↦s[lockmap.LockMap :: "shards"]{dq} v.(LockMap.shards')
  ).
Proof.
  rewrite /named.
  apply struct_fields_split_intro.
  unfold_typed_pointsto; split_pointsto_app.

  rewrite -!/(typed_pointsto_def _ _ _) -!typed_pointsto_unseal.

  solve_field_ref_f.
Qed.

End instances.

Section names.

Class GlobalAddrs :=
{
}.

Context `{!GlobalAddrs}.
Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context `{!goGlobalsGS Σ}.

Definition var_addrs : list (go_string * loc) := [
  ].

Global Instance is_pkg_defined_instance : IsPkgDefined lockmap :=
{|
  is_pkg_defined := is_global_definitions lockmap var_addrs;
|}.

Definition own_allocated : iProp Σ :=
True.

Global Instance wp_func_call_mkLockShard :
  WpFuncCall lockmap "mkLockShard" _ (is_pkg_defined lockmap) :=
  ltac:(apply wp_func_call'; reflexivity).

Global Instance wp_func_call_MkLockMap :
  WpFuncCall lockmap "MkLockMap" _ (is_pkg_defined lockmap) :=
  ltac:(apply wp_func_call'; reflexivity).

Global Instance wp_method_call_lockShard'ptr_acquire :
  WpMethodCall lockmap "lockShard'ptr" "acquire" _ (is_pkg_defined lockmap) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_lockShard'ptr_release :
  WpMethodCall lockmap "lockShard'ptr" "release" _ (is_pkg_defined lockmap) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_LockMap'ptr_Acquire :
  WpMethodCall lockmap "LockMap'ptr" "Acquire" _ (is_pkg_defined lockmap) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_LockMap'ptr_Release :
  WpMethodCall lockmap "LockMap'ptr" "Release" _ (is_pkg_defined lockmap) :=
  ltac:(apply wp_method_call'; reflexivity).

End names.
End lockmap.
