(* autogenerated by goose proofgen; do not modify *)
Require Export New.proof.disk_prelude.
Require Export New.generatedproof.github_com.goose_lang.primitive.disk.
Require Export New.generatedproof.github_com.mit_pdos.go_journal.common.
Require Export New.generatedproof.github_com.tchajed.marshal.
Require Export New.generatedproof.github_com.mit_pdos.go_journal.util.
Require Export New.generatedproof.sync.
Require Export New.generatedproof.github_com.goose_lang.primitive.
Require Export New.golang.theory.

Require Export New.code.github_com.mit_pdos.go_journal.wal.

Set Default Proof Using "Type".

Module wal.

(* type wal.LogPosition *)
Module LogPosition.
Section def.
Context `{ffi_syntax}.
Definition t := w64.
End def.
End LogPosition.

(* type wal.Update *)
Module Update.
Section def.
Context `{ffi_syntax}.
Record t := mk {
  Addr' : w64;
  Block' : slice.t;
}.
End def.
End Update.

Section instances.
Context `{ffi_syntax}.

Global Instance settable_Update : Settable Update.t :=
  settable! Update.mk < Update.Addr'; Update.Block' >.
Global Instance into_val_Update : IntoVal Update.t :=
  {| to_val_def v :=
    struct.val_aux wal.Update [
    "Addr" ::= #(Update.Addr' v);
    "Block" ::= #(Update.Block' v)
    ]%struct
  |}.

Global Program Instance into_val_typed_Update : IntoValTyped Update.t wal.Update :=
{|
  default_val := Update.mk (default_val _) (default_val _);
|}.
Next Obligation. solve_to_val_type. Qed.
Next Obligation. solve_zero_val. Qed.
Next Obligation. solve_to_val_inj. Qed.
Final Obligation. solve_decision. Qed.

Global Instance into_val_struct_field_Update_Addr : IntoValStructField "Addr" wal.Update Update.Addr'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_Update_Block : IntoValStructField "Block" wal.Update Update.Block'.
Proof. solve_into_val_struct_field. Qed.


Context `{!ffi_model, !ffi_semantics _ _, !ffi_interp _, !heapGS Σ}.
Global Instance wp_struct_make_Update Addr' Block':
  PureWp True
    (struct.make #wal.Update (alist_val [
      "Addr" ::= #Addr';
      "Block" ::= #Block'
    ]))%struct
    #(Update.mk Addr' Block').
Proof. solve_struct_make_pure_wp. Qed.


Global Instance Update_struct_fields_split dq l (v : Update.t) :
  StructFieldsSplit dq l v (
    "HAddr" ∷ l ↦s[wal.Update :: "Addr"]{dq} v.(Update.Addr') ∗
    "HBlock" ∷ l ↦s[wal.Update :: "Block"]{dq} v.(Update.Block')
  ).
Proof.
  rewrite /named.
  apply struct_fields_split_intro.
  unfold_typed_pointsto; split_pointsto_app.

  rewrite -!/(typed_pointsto_def _ _ _) -!typed_pointsto_unseal.
  simpl_one_flatten_struct (# (Update.Addr' v)) wal.Update "Addr"%go.

  solve_field_ref_f.
Qed.

End instances.

(* type wal.circularAppender *)
Module circularAppender.
Section def.
Context `{ffi_syntax}.
Record t := mk {
  diskAddrs' : slice.t;
}.
End def.
End circularAppender.

Section instances.
Context `{ffi_syntax}.

Global Instance settable_circularAppender : Settable circularAppender.t :=
  settable! circularAppender.mk < circularAppender.diskAddrs' >.
Global Instance into_val_circularAppender : IntoVal circularAppender.t :=
  {| to_val_def v :=
    struct.val_aux wal.circularAppender [
    "diskAddrs" ::= #(circularAppender.diskAddrs' v)
    ]%struct
  |}.

Global Program Instance into_val_typed_circularAppender : IntoValTyped circularAppender.t wal.circularAppender :=
{|
  default_val := circularAppender.mk (default_val _);
|}.
Next Obligation. solve_to_val_type. Qed.
Next Obligation. solve_zero_val. Qed.
Next Obligation. solve_to_val_inj. Qed.
Final Obligation. solve_decision. Qed.

Global Instance into_val_struct_field_circularAppender_diskAddrs : IntoValStructField "diskAddrs" wal.circularAppender circularAppender.diskAddrs'.
Proof. solve_into_val_struct_field. Qed.


Context `{!ffi_model, !ffi_semantics _ _, !ffi_interp _, !heapGS Σ}.
Global Instance wp_struct_make_circularAppender diskAddrs':
  PureWp True
    (struct.make #wal.circularAppender (alist_val [
      "diskAddrs" ::= #diskAddrs'
    ]))%struct
    #(circularAppender.mk diskAddrs').
Proof. solve_struct_make_pure_wp. Qed.


Global Instance circularAppender_struct_fields_split dq l (v : circularAppender.t) :
  StructFieldsSplit dq l v (
    "HdiskAddrs" ∷ l ↦s[wal.circularAppender :: "diskAddrs"]{dq} v.(circularAppender.diskAddrs')
  ).
Proof.
  rewrite /named.
  apply struct_fields_split_intro.
  unfold_typed_pointsto; split_pointsto_app.

  rewrite -!/(typed_pointsto_def _ _ _) -!typed_pointsto_unseal.

  solve_field_ref_f.
Qed.

End instances.

(* type wal.sliding *)
Module sliding.
Section def.
Context `{ffi_syntax}.
Record t := mk {
  log' : slice.t;
  start' : LogPosition.t;
  mutable' : LogPosition.t;
  needFlush' : bool;
  addrPos' : loc;
}.
End def.
End sliding.

Section instances.
Context `{ffi_syntax}.

Global Instance settable_sliding : Settable sliding.t :=
  settable! sliding.mk < sliding.log'; sliding.start'; sliding.mutable'; sliding.needFlush'; sliding.addrPos' >.
Global Instance into_val_sliding : IntoVal sliding.t :=
  {| to_val_def v :=
    struct.val_aux wal.sliding [
    "log" ::= #(sliding.log' v);
    "start" ::= #(sliding.start' v);
    "mutable" ::= #(sliding.mutable' v);
    "needFlush" ::= #(sliding.needFlush' v);
    "addrPos" ::= #(sliding.addrPos' v)
    ]%struct
  |}.

Global Program Instance into_val_typed_sliding : IntoValTyped sliding.t wal.sliding :=
{|
  default_val := sliding.mk (default_val _) (default_val _) (default_val _) (default_val _) (default_val _);
|}.
Next Obligation. solve_to_val_type. Qed.
Next Obligation. solve_zero_val. Qed.
Next Obligation. solve_to_val_inj. Qed.
Final Obligation. solve_decision. Qed.

Global Instance into_val_struct_field_sliding_log : IntoValStructField "log" wal.sliding sliding.log'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_sliding_start : IntoValStructField "start" wal.sliding sliding.start'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_sliding_mutable : IntoValStructField "mutable" wal.sliding sliding.mutable'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_sliding_needFlush : IntoValStructField "needFlush" wal.sliding sliding.needFlush'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_sliding_addrPos : IntoValStructField "addrPos" wal.sliding sliding.addrPos'.
Proof. solve_into_val_struct_field. Qed.


Context `{!ffi_model, !ffi_semantics _ _, !ffi_interp _, !heapGS Σ}.
Global Instance wp_struct_make_sliding log' start' mutable' needFlush' addrPos':
  PureWp True
    (struct.make #wal.sliding (alist_val [
      "log" ::= #log';
      "start" ::= #start';
      "mutable" ::= #mutable';
      "needFlush" ::= #needFlush';
      "addrPos" ::= #addrPos'
    ]))%struct
    #(sliding.mk log' start' mutable' needFlush' addrPos').
Proof. solve_struct_make_pure_wp. Qed.


Global Instance sliding_struct_fields_split dq l (v : sliding.t) :
  StructFieldsSplit dq l v (
    "Hlog" ∷ l ↦s[wal.sliding :: "log"]{dq} v.(sliding.log') ∗
    "Hstart" ∷ l ↦s[wal.sliding :: "start"]{dq} v.(sliding.start') ∗
    "Hmutable" ∷ l ↦s[wal.sliding :: "mutable"]{dq} v.(sliding.mutable') ∗
    "HneedFlush" ∷ l ↦s[wal.sliding :: "needFlush"]{dq} v.(sliding.needFlush') ∗
    "HaddrPos" ∷ l ↦s[wal.sliding :: "addrPos"]{dq} v.(sliding.addrPos')
  ).
Proof.
  rewrite /named.
  apply struct_fields_split_intro.
  unfold_typed_pointsto; split_pointsto_app.

  rewrite -!/(typed_pointsto_def _ _ _) -!typed_pointsto_unseal.
  simpl_one_flatten_struct (# (sliding.log' v)) wal.sliding "log"%go.
  simpl_one_flatten_struct (# (sliding.start' v)) wal.sliding "start"%go.
  simpl_one_flatten_struct (# (sliding.mutable' v)) wal.sliding "mutable"%go.
  simpl_one_flatten_struct (# (sliding.needFlush' v)) wal.sliding "needFlush"%go.

  solve_field_ref_f.
Qed.

End instances.

(* type wal.WalogState *)
Module WalogState.
Section def.
Context `{ffi_syntax}.
Record t := mk {
  memLog' : loc;
  diskEnd' : LogPosition.t;
  shutdown' : bool;
  nthread' : w64;
}.
End def.
End WalogState.

Section instances.
Context `{ffi_syntax}.

Global Instance settable_WalogState : Settable WalogState.t :=
  settable! WalogState.mk < WalogState.memLog'; WalogState.diskEnd'; WalogState.shutdown'; WalogState.nthread' >.
Global Instance into_val_WalogState : IntoVal WalogState.t :=
  {| to_val_def v :=
    struct.val_aux wal.WalogState [
    "memLog" ::= #(WalogState.memLog' v);
    "diskEnd" ::= #(WalogState.diskEnd' v);
    "shutdown" ::= #(WalogState.shutdown' v);
    "nthread" ::= #(WalogState.nthread' v)
    ]%struct
  |}.

Global Program Instance into_val_typed_WalogState : IntoValTyped WalogState.t wal.WalogState :=
{|
  default_val := WalogState.mk (default_val _) (default_val _) (default_val _) (default_val _);
|}.
Next Obligation. solve_to_val_type. Qed.
Next Obligation. solve_zero_val. Qed.
Next Obligation. solve_to_val_inj. Qed.
Final Obligation. solve_decision. Qed.

Global Instance into_val_struct_field_WalogState_memLog : IntoValStructField "memLog" wal.WalogState WalogState.memLog'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_WalogState_diskEnd : IntoValStructField "diskEnd" wal.WalogState WalogState.diskEnd'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_WalogState_shutdown : IntoValStructField "shutdown" wal.WalogState WalogState.shutdown'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_WalogState_nthread : IntoValStructField "nthread" wal.WalogState WalogState.nthread'.
Proof. solve_into_val_struct_field. Qed.


Context `{!ffi_model, !ffi_semantics _ _, !ffi_interp _, !heapGS Σ}.
Global Instance wp_struct_make_WalogState memLog' diskEnd' shutdown' nthread':
  PureWp True
    (struct.make #wal.WalogState (alist_val [
      "memLog" ::= #memLog';
      "diskEnd" ::= #diskEnd';
      "shutdown" ::= #shutdown';
      "nthread" ::= #nthread'
    ]))%struct
    #(WalogState.mk memLog' diskEnd' shutdown' nthread').
Proof. solve_struct_make_pure_wp. Qed.


Global Instance WalogState_struct_fields_split dq l (v : WalogState.t) :
  StructFieldsSplit dq l v (
    "HmemLog" ∷ l ↦s[wal.WalogState :: "memLog"]{dq} v.(WalogState.memLog') ∗
    "HdiskEnd" ∷ l ↦s[wal.WalogState :: "diskEnd"]{dq} v.(WalogState.diskEnd') ∗
    "Hshutdown" ∷ l ↦s[wal.WalogState :: "shutdown"]{dq} v.(WalogState.shutdown') ∗
    "Hnthread" ∷ l ↦s[wal.WalogState :: "nthread"]{dq} v.(WalogState.nthread')
  ).
Proof.
  rewrite /named.
  apply struct_fields_split_intro.
  unfold_typed_pointsto; split_pointsto_app.

  rewrite -!/(typed_pointsto_def _ _ _) -!typed_pointsto_unseal.
  simpl_one_flatten_struct (# (WalogState.memLog' v)) wal.WalogState "memLog"%go.
  simpl_one_flatten_struct (# (WalogState.diskEnd' v)) wal.WalogState "diskEnd"%go.
  simpl_one_flatten_struct (# (WalogState.shutdown' v)) wal.WalogState "shutdown"%go.

  solve_field_ref_f.
Qed.

End instances.

(* type wal.Walog *)
Module Walog.
Section def.
Context `{ffi_syntax}.
Record t := mk {
  memLock' : loc;
  d' : disk.Disk.t;
  circ' : loc;
  st' : loc;
  condLogger' : loc;
  condInstall' : loc;
  condShut' : loc;
}.
End def.
End Walog.

Section instances.
Context `{ffi_syntax}.

Global Instance settable_Walog : Settable Walog.t :=
  settable! Walog.mk < Walog.memLock'; Walog.d'; Walog.circ'; Walog.st'; Walog.condLogger'; Walog.condInstall'; Walog.condShut' >.
Global Instance into_val_Walog : IntoVal Walog.t :=
  {| to_val_def v :=
    struct.val_aux wal.Walog [
    "memLock" ::= #(Walog.memLock' v);
    "d" ::= #(Walog.d' v);
    "circ" ::= #(Walog.circ' v);
    "st" ::= #(Walog.st' v);
    "condLogger" ::= #(Walog.condLogger' v);
    "condInstall" ::= #(Walog.condInstall' v);
    "condShut" ::= #(Walog.condShut' v)
    ]%struct
  |}.

Global Program Instance into_val_typed_Walog : IntoValTyped Walog.t wal.Walog :=
{|
  default_val := Walog.mk (default_val _) (default_val _) (default_val _) (default_val _) (default_val _) (default_val _) (default_val _);
|}.
Next Obligation. solve_to_val_type. Qed.
Next Obligation. solve_zero_val. Qed.
Next Obligation. solve_to_val_inj. Qed.
Final Obligation. solve_decision. Qed.

Global Instance into_val_struct_field_Walog_memLock : IntoValStructField "memLock" wal.Walog Walog.memLock'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_Walog_d : IntoValStructField "d" wal.Walog Walog.d'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_Walog_circ : IntoValStructField "circ" wal.Walog Walog.circ'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_Walog_st : IntoValStructField "st" wal.Walog Walog.st'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_Walog_condLogger : IntoValStructField "condLogger" wal.Walog Walog.condLogger'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_Walog_condInstall : IntoValStructField "condInstall" wal.Walog Walog.condInstall'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_Walog_condShut : IntoValStructField "condShut" wal.Walog Walog.condShut'.
Proof. solve_into_val_struct_field. Qed.


Context `{!ffi_model, !ffi_semantics _ _, !ffi_interp _, !heapGS Σ}.
Global Instance wp_struct_make_Walog memLock' d' circ' st' condLogger' condInstall' condShut':
  PureWp True
    (struct.make #wal.Walog (alist_val [
      "memLock" ::= #memLock';
      "d" ::= #d';
      "circ" ::= #circ';
      "st" ::= #st';
      "condLogger" ::= #condLogger';
      "condInstall" ::= #condInstall';
      "condShut" ::= #condShut'
    ]))%struct
    #(Walog.mk memLock' d' circ' st' condLogger' condInstall' condShut').
Proof. solve_struct_make_pure_wp. Qed.


Global Instance Walog_struct_fields_split dq l (v : Walog.t) :
  StructFieldsSplit dq l v (
    "HmemLock" ∷ l ↦s[wal.Walog :: "memLock"]{dq} v.(Walog.memLock') ∗
    "Hd" ∷ l ↦s[wal.Walog :: "d"]{dq} v.(Walog.d') ∗
    "Hcirc" ∷ l ↦s[wal.Walog :: "circ"]{dq} v.(Walog.circ') ∗
    "Hst" ∷ l ↦s[wal.Walog :: "st"]{dq} v.(Walog.st') ∗
    "HcondLogger" ∷ l ↦s[wal.Walog :: "condLogger"]{dq} v.(Walog.condLogger') ∗
    "HcondInstall" ∷ l ↦s[wal.Walog :: "condInstall"]{dq} v.(Walog.condInstall') ∗
    "HcondShut" ∷ l ↦s[wal.Walog :: "condShut"]{dq} v.(Walog.condShut')
  ).
Proof.
  rewrite /named.
  apply struct_fields_split_intro.
  unfold_typed_pointsto; split_pointsto_app.

  rewrite -!/(typed_pointsto_def _ _ _) -!typed_pointsto_unseal.
  simpl_one_flatten_struct (# (Walog.memLock' v)) wal.Walog "memLock"%go.
  simpl_one_flatten_struct (# (Walog.d' v)) wal.Walog "d"%go.
  simpl_one_flatten_struct (# (Walog.circ' v)) wal.Walog "circ"%go.
  simpl_one_flatten_struct (# (Walog.st' v)) wal.Walog "st"%go.
  simpl_one_flatten_struct (# (Walog.condLogger' v)) wal.Walog "condLogger"%go.
  simpl_one_flatten_struct (# (Walog.condInstall' v)) wal.Walog "condInstall"%go.

  solve_field_ref_f.
Qed.

End instances.

Section names.

Class GlobalAddrs :=
{
}.

Context `{!GlobalAddrs}.
Context `{!heapGS Σ}.
Context `{!goGlobalsGS Σ}.

Definition var_addrs : list (go_string * loc) := [
  ].

Global Instance is_pkg_defined_instance : IsPkgDefined wal :=
{|
  is_pkg_defined := is_global_definitions wal var_addrs;
|}.

Definition own_allocated : iProp Σ :=
True.

Global Instance wp_func_call_MkBlockData :
  WpFuncCall wal "MkBlockData" _ (is_pkg_defined wal) :=
  ltac:(apply wp_func_call'; reflexivity).

Global Instance wp_func_call_initCircular :
  WpFuncCall wal "initCircular" _ (is_pkg_defined wal) :=
  ltac:(apply wp_func_call'; reflexivity).

Global Instance wp_func_call_decodeHdr1 :
  WpFuncCall wal "decodeHdr1" _ (is_pkg_defined wal) :=
  ltac:(apply wp_func_call'; reflexivity).

Global Instance wp_func_call_decodeHdr2 :
  WpFuncCall wal "decodeHdr2" _ (is_pkg_defined wal) :=
  ltac:(apply wp_func_call'; reflexivity).

Global Instance wp_func_call_recoverCircular :
  WpFuncCall wal "recoverCircular" _ (is_pkg_defined wal) :=
  ltac:(apply wp_func_call'; reflexivity).

Global Instance wp_func_call_hdr2 :
  WpFuncCall wal "hdr2" _ (is_pkg_defined wal) :=
  ltac:(apply wp_func_call'; reflexivity).

Global Instance wp_func_call_Advance :
  WpFuncCall wal "Advance" _ (is_pkg_defined wal) :=
  ltac:(apply wp_func_call'; reflexivity).

Global Instance wp_func_call_mkSliding :
  WpFuncCall wal "mkSliding" _ (is_pkg_defined wal) :=
  ltac:(apply wp_func_call'; reflexivity).

Global Instance wp_func_call_absorbBufs :
  WpFuncCall wal "absorbBufs" _ (is_pkg_defined wal) :=
  ltac:(apply wp_func_call'; reflexivity).

Global Instance wp_func_call_installBlocks :
  WpFuncCall wal "installBlocks" _ (is_pkg_defined wal) :=
  ltac:(apply wp_func_call'; reflexivity).

Global Instance wp_func_call_mkLog :
  WpFuncCall wal "mkLog" _ (is_pkg_defined wal) :=
  ltac:(apply wp_func_call'; reflexivity).

Global Instance wp_func_call_MkLog :
  WpFuncCall wal "MkLog" _ (is_pkg_defined wal) :=
  ltac:(apply wp_func_call'; reflexivity).

Global Instance wp_func_call_doMemAppend :
  WpFuncCall wal "doMemAppend" _ (is_pkg_defined wal) :=
  ltac:(apply wp_func_call'; reflexivity).

Global Instance wp_func_call_copyUpdateBlock :
  WpFuncCall wal "copyUpdateBlock" _ (is_pkg_defined wal) :=
  ltac:(apply wp_func_call'; reflexivity).

Global Instance wp_method_call_circularAppender'ptr_Append :
  WpMethodCall wal "circularAppender'ptr" "Append" _ (is_pkg_defined wal) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_circularAppender'ptr_hdr1 :
  WpMethodCall wal "circularAppender'ptr" "hdr1" _ (is_pkg_defined wal) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_circularAppender'ptr_logBlocks :
  WpMethodCall wal "circularAppender'ptr" "logBlocks" _ (is_pkg_defined wal) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_sliding'ptr_append :
  WpMethodCall wal "sliding'ptr" "append" _ (is_pkg_defined wal) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_sliding'ptr_clearMutable :
  WpMethodCall wal "sliding'ptr" "clearMutable" _ (is_pkg_defined wal) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_sliding'ptr_deleteFrom :
  WpMethodCall wal "sliding'ptr" "deleteFrom" _ (is_pkg_defined wal) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_sliding'ptr_end :
  WpMethodCall wal "sliding'ptr" "end" _ (is_pkg_defined wal) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_sliding'ptr_get :
  WpMethodCall wal "sliding'ptr" "get" _ (is_pkg_defined wal) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_sliding'ptr_intoMutable :
  WpMethodCall wal "sliding'ptr" "intoMutable" _ (is_pkg_defined wal) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_sliding'ptr_memWrite :
  WpMethodCall wal "sliding'ptr" "memWrite" _ (is_pkg_defined wal) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_sliding'ptr_posForAddr :
  WpMethodCall wal "sliding'ptr" "posForAddr" _ (is_pkg_defined wal) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_sliding'ptr_takeFrom :
  WpMethodCall wal "sliding'ptr" "takeFrom" _ (is_pkg_defined wal) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_sliding'ptr_takeTill :
  WpMethodCall wal "sliding'ptr" "takeTill" _ (is_pkg_defined wal) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_sliding'ptr_update :
  WpMethodCall wal "sliding'ptr" "update" _ (is_pkg_defined wal) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_WalogState'ptr_cutMemLog :
  WpMethodCall wal "WalogState'ptr" "cutMemLog" _ (is_pkg_defined wal) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_WalogState'ptr_endGroupTxn :
  WpMethodCall wal "WalogState'ptr" "endGroupTxn" _ (is_pkg_defined wal) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_WalogState'ptr_memEnd :
  WpMethodCall wal "WalogState'ptr" "memEnd" _ (is_pkg_defined wal) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_WalogState'ptr_memLogHasSpace :
  WpMethodCall wal "WalogState'ptr" "memLogHasSpace" _ (is_pkg_defined wal) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_WalogState'ptr_readMem :
  WpMethodCall wal "WalogState'ptr" "readMem" _ (is_pkg_defined wal) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_WalogState'ptr_updatesOverflowU64 :
  WpMethodCall wal "WalogState'ptr" "updatesOverflowU64" _ (is_pkg_defined wal) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_Walog'ptr_Flush :
  WpMethodCall wal "Walog'ptr" "Flush" _ (is_pkg_defined wal) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_Walog'ptr_LogSz :
  WpMethodCall wal "Walog'ptr" "LogSz" _ (is_pkg_defined wal) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_Walog'ptr_MemAppend :
  WpMethodCall wal "Walog'ptr" "MemAppend" _ (is_pkg_defined wal) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_Walog'ptr_Read :
  WpMethodCall wal "Walog'ptr" "Read" _ (is_pkg_defined wal) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_Walog'ptr_ReadInstalled :
  WpMethodCall wal "Walog'ptr" "ReadInstalled" _ (is_pkg_defined wal) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_Walog'ptr_ReadMem :
  WpMethodCall wal "Walog'ptr" "ReadMem" _ (is_pkg_defined wal) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_Walog'ptr_Shutdown :
  WpMethodCall wal "Walog'ptr" "Shutdown" _ (is_pkg_defined wal) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_Walog'ptr_flushIfNeeded :
  WpMethodCall wal "Walog'ptr" "flushIfNeeded" _ (is_pkg_defined wal) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_Walog'ptr_installer :
  WpMethodCall wal "Walog'ptr" "installer" _ (is_pkg_defined wal) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_Walog'ptr_logAppend :
  WpMethodCall wal "Walog'ptr" "logAppend" _ (is_pkg_defined wal) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_Walog'ptr_logInstall :
  WpMethodCall wal "Walog'ptr" "logInstall" _ (is_pkg_defined wal) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_Walog'ptr_logger :
  WpMethodCall wal "Walog'ptr" "logger" _ (is_pkg_defined wal) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_Walog'ptr_startBackgroundThreads :
  WpMethodCall wal "Walog'ptr" "startBackgroundThreads" _ (is_pkg_defined wal) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_Walog'ptr_waitForSpace :
  WpMethodCall wal "Walog'ptr" "waitForSpace" _ (is_pkg_defined wal) :=
  ltac:(apply wp_method_call'; reflexivity).

End names.
End wal.
