(* autogenerated by goose proofgen; do not modify *)
Require Export New.proof.disk_prelude.
Require Export New.generatedproof.github_com.goose_lang.primitive.
Require Export New.generatedproof.github_com.goose_lang.primitive.disk.
Require Export New.generatedproof.github_com.mit_pdos.go_journal.common.
Require Export New.generatedproof.github_com.mit_pdos.go_journal.util.
Require Export New.generatedproof.github_com.tchajed.marshal.
Require Export New.generatedproof.sync.
Require Export New.golang.theory.
Require Export New.code.github_com.mit_pdos.go_journal.wal.

Set Default Proof Using "Type".

Module wal.
Module Update.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : wal.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance Update_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (wal.Update.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "Addr" ∷ l.[(wal.Update.t), "Addr"] ↦{dq} v.(wal.Update.Addr') ∗
      "Block" ∷ l.[(wal.Update.t), "Block"] ↦{dq} v.(wal.Update.Block') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance Update_into_val_typed
   :
  IntoValTypedUnderlying (wal.Update.t) (wal.Updateⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance Update_access_load_Addr l (v : (wal.Update.t)) dq :
  AccessStrict
    (l.[(wal.Update.t), "Addr"] ↦{dq} (v.(wal.Update.Addr')))
    (l.[(wal.Update.t), "Addr"] ↦{dq} (v.(wal.Update.Addr')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Update_access_store_Addr l (v : (wal.Update.t)) Addr' :
  AccessStrict
    (l.[(wal.Update.t), "Addr"] ↦ (v.(wal.Update.Addr')))
    (l.[(wal.Update.t), "Addr"] ↦ Addr')
    (l ↦ v) (l ↦ (v <|(wal.Update.Addr') := Addr'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Update_access_load_Block l (v : (wal.Update.t)) dq :
  AccessStrict
    (l.[(wal.Update.t), "Block"] ↦{dq} (v.(wal.Update.Block')))
    (l.[(wal.Update.t), "Block"] ↦{dq} (v.(wal.Update.Block')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Update_access_store_Block l (v : (wal.Update.t)) Block' :
  AccessStrict
    (l.[(wal.Update.t), "Block"] ↦ (v.(wal.Update.Block')))
    (l.[(wal.Update.t), "Block"] ↦ Block')
    (l ↦ v) (l ↦ (v <|(wal.Update.Block') := Block'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End Update.

Module circularAppender.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : wal.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance circularAppender_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (wal.circularAppender.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "diskAddrs" ∷ l.[(wal.circularAppender.t), "diskAddrs"] ↦{dq} v.(wal.circularAppender.diskAddrs') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance circularAppender_into_val_typed
   :
  IntoValTypedUnderlying (wal.circularAppender.t) (wal.circularAppenderⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance circularAppender_access_load_diskAddrs l (v : (wal.circularAppender.t)) dq :
  AccessStrict
    (l.[(wal.circularAppender.t), "diskAddrs"] ↦{dq} (v.(wal.circularAppender.diskAddrs')))
    (l.[(wal.circularAppender.t), "diskAddrs"] ↦{dq} (v.(wal.circularAppender.diskAddrs')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance circularAppender_access_store_diskAddrs l (v : (wal.circularAppender.t)) diskAddrs' :
  AccessStrict
    (l.[(wal.circularAppender.t), "diskAddrs"] ↦ (v.(wal.circularAppender.diskAddrs')))
    (l.[(wal.circularAppender.t), "diskAddrs"] ↦ diskAddrs')
    (l ↦ v) (l ↦ (v <|(wal.circularAppender.diskAddrs') := diskAddrs'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End circularAppender.

Module sliding.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : wal.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance sliding_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (wal.sliding.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "log" ∷ l.[(wal.sliding.t), "log"] ↦{dq} v.(wal.sliding.log') ∗
      "start" ∷ l.[(wal.sliding.t), "start"] ↦{dq} v.(wal.sliding.start') ∗
      "mutable" ∷ l.[(wal.sliding.t), "mutable"] ↦{dq} v.(wal.sliding.mutable') ∗
      "needFlush" ∷ l.[(wal.sliding.t), "needFlush"] ↦{dq} v.(wal.sliding.needFlush') ∗
      "addrPos" ∷ l.[(wal.sliding.t), "addrPos"] ↦{dq} v.(wal.sliding.addrPos') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance sliding_into_val_typed
   :
  IntoValTypedUnderlying (wal.sliding.t) (wal.slidingⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance sliding_access_load_log l (v : (wal.sliding.t)) dq :
  AccessStrict
    (l.[(wal.sliding.t), "log"] ↦{dq} (v.(wal.sliding.log')))
    (l.[(wal.sliding.t), "log"] ↦{dq} (v.(wal.sliding.log')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance sliding_access_store_log l (v : (wal.sliding.t)) log' :
  AccessStrict
    (l.[(wal.sliding.t), "log"] ↦ (v.(wal.sliding.log')))
    (l.[(wal.sliding.t), "log"] ↦ log')
    (l ↦ v) (l ↦ (v <|(wal.sliding.log') := log'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance sliding_access_load_start l (v : (wal.sliding.t)) dq :
  AccessStrict
    (l.[(wal.sliding.t), "start"] ↦{dq} (v.(wal.sliding.start')))
    (l.[(wal.sliding.t), "start"] ↦{dq} (v.(wal.sliding.start')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance sliding_access_store_start l (v : (wal.sliding.t)) start' :
  AccessStrict
    (l.[(wal.sliding.t), "start"] ↦ (v.(wal.sliding.start')))
    (l.[(wal.sliding.t), "start"] ↦ start')
    (l ↦ v) (l ↦ (v <|(wal.sliding.start') := start'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance sliding_access_load_mutable l (v : (wal.sliding.t)) dq :
  AccessStrict
    (l.[(wal.sliding.t), "mutable"] ↦{dq} (v.(wal.sliding.mutable')))
    (l.[(wal.sliding.t), "mutable"] ↦{dq} (v.(wal.sliding.mutable')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance sliding_access_store_mutable l (v : (wal.sliding.t)) mutable' :
  AccessStrict
    (l.[(wal.sliding.t), "mutable"] ↦ (v.(wal.sliding.mutable')))
    (l.[(wal.sliding.t), "mutable"] ↦ mutable')
    (l ↦ v) (l ↦ (v <|(wal.sliding.mutable') := mutable'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance sliding_access_load_needFlush l (v : (wal.sliding.t)) dq :
  AccessStrict
    (l.[(wal.sliding.t), "needFlush"] ↦{dq} (v.(wal.sliding.needFlush')))
    (l.[(wal.sliding.t), "needFlush"] ↦{dq} (v.(wal.sliding.needFlush')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance sliding_access_store_needFlush l (v : (wal.sliding.t)) needFlush' :
  AccessStrict
    (l.[(wal.sliding.t), "needFlush"] ↦ (v.(wal.sliding.needFlush')))
    (l.[(wal.sliding.t), "needFlush"] ↦ needFlush')
    (l ↦ v) (l ↦ (v <|(wal.sliding.needFlush') := needFlush'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance sliding_access_load_addrPos l (v : (wal.sliding.t)) dq :
  AccessStrict
    (l.[(wal.sliding.t), "addrPos"] ↦{dq} (v.(wal.sliding.addrPos')))
    (l.[(wal.sliding.t), "addrPos"] ↦{dq} (v.(wal.sliding.addrPos')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance sliding_access_store_addrPos l (v : (wal.sliding.t)) addrPos' :
  AccessStrict
    (l.[(wal.sliding.t), "addrPos"] ↦ (v.(wal.sliding.addrPos')))
    (l.[(wal.sliding.t), "addrPos"] ↦ addrPos')
    (l ↦ v) (l ↦ (v <|(wal.sliding.addrPos') := addrPos'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End sliding.

Module WalogState.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : wal.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance WalogState_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (wal.WalogState.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "memLog" ∷ l.[(wal.WalogState.t), "memLog"] ↦{dq} v.(wal.WalogState.memLog') ∗
      "diskEnd" ∷ l.[(wal.WalogState.t), "diskEnd"] ↦{dq} v.(wal.WalogState.diskEnd') ∗
      "shutdown" ∷ l.[(wal.WalogState.t), "shutdown"] ↦{dq} v.(wal.WalogState.shutdown') ∗
      "nthread" ∷ l.[(wal.WalogState.t), "nthread"] ↦{dq} v.(wal.WalogState.nthread') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance WalogState_into_val_typed
   :
  IntoValTypedUnderlying (wal.WalogState.t) (wal.WalogStateⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance WalogState_access_load_memLog l (v : (wal.WalogState.t)) dq :
  AccessStrict
    (l.[(wal.WalogState.t), "memLog"] ↦{dq} (v.(wal.WalogState.memLog')))
    (l.[(wal.WalogState.t), "memLog"] ↦{dq} (v.(wal.WalogState.memLog')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance WalogState_access_store_memLog l (v : (wal.WalogState.t)) memLog' :
  AccessStrict
    (l.[(wal.WalogState.t), "memLog"] ↦ (v.(wal.WalogState.memLog')))
    (l.[(wal.WalogState.t), "memLog"] ↦ memLog')
    (l ↦ v) (l ↦ (v <|(wal.WalogState.memLog') := memLog'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance WalogState_access_load_diskEnd l (v : (wal.WalogState.t)) dq :
  AccessStrict
    (l.[(wal.WalogState.t), "diskEnd"] ↦{dq} (v.(wal.WalogState.diskEnd')))
    (l.[(wal.WalogState.t), "diskEnd"] ↦{dq} (v.(wal.WalogState.diskEnd')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance WalogState_access_store_diskEnd l (v : (wal.WalogState.t)) diskEnd' :
  AccessStrict
    (l.[(wal.WalogState.t), "diskEnd"] ↦ (v.(wal.WalogState.diskEnd')))
    (l.[(wal.WalogState.t), "diskEnd"] ↦ diskEnd')
    (l ↦ v) (l ↦ (v <|(wal.WalogState.diskEnd') := diskEnd'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance WalogState_access_load_shutdown l (v : (wal.WalogState.t)) dq :
  AccessStrict
    (l.[(wal.WalogState.t), "shutdown"] ↦{dq} (v.(wal.WalogState.shutdown')))
    (l.[(wal.WalogState.t), "shutdown"] ↦{dq} (v.(wal.WalogState.shutdown')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance WalogState_access_store_shutdown l (v : (wal.WalogState.t)) shutdown' :
  AccessStrict
    (l.[(wal.WalogState.t), "shutdown"] ↦ (v.(wal.WalogState.shutdown')))
    (l.[(wal.WalogState.t), "shutdown"] ↦ shutdown')
    (l ↦ v) (l ↦ (v <|(wal.WalogState.shutdown') := shutdown'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance WalogState_access_load_nthread l (v : (wal.WalogState.t)) dq :
  AccessStrict
    (l.[(wal.WalogState.t), "nthread"] ↦{dq} (v.(wal.WalogState.nthread')))
    (l.[(wal.WalogState.t), "nthread"] ↦{dq} (v.(wal.WalogState.nthread')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance WalogState_access_store_nthread l (v : (wal.WalogState.t)) nthread' :
  AccessStrict
    (l.[(wal.WalogState.t), "nthread"] ↦ (v.(wal.WalogState.nthread')))
    (l.[(wal.WalogState.t), "nthread"] ↦ nthread')
    (l ↦ v) (l ↦ (v <|(wal.WalogState.nthread') := nthread'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End WalogState.

Module Walog.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : wal.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance Walog_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (wal.Walog.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "memLock" ∷ l.[(wal.Walog.t), "memLock"] ↦{dq} v.(wal.Walog.memLock') ∗
      "d" ∷ l.[(wal.Walog.t), "d"] ↦{dq} v.(wal.Walog.d') ∗
      "circ" ∷ l.[(wal.Walog.t), "circ"] ↦{dq} v.(wal.Walog.circ') ∗
      "st" ∷ l.[(wal.Walog.t), "st"] ↦{dq} v.(wal.Walog.st') ∗
      "condLogger" ∷ l.[(wal.Walog.t), "condLogger"] ↦{dq} v.(wal.Walog.condLogger') ∗
      "condInstall" ∷ l.[(wal.Walog.t), "condInstall"] ↦{dq} v.(wal.Walog.condInstall') ∗
      "condShut" ∷ l.[(wal.Walog.t), "condShut"] ↦{dq} v.(wal.Walog.condShut') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance Walog_into_val_typed
   :
  IntoValTypedUnderlying (wal.Walog.t) (wal.Walogⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance Walog_access_load_memLock l (v : (wal.Walog.t)) dq :
  AccessStrict
    (l.[(wal.Walog.t), "memLock"] ↦{dq} (v.(wal.Walog.memLock')))
    (l.[(wal.Walog.t), "memLock"] ↦{dq} (v.(wal.Walog.memLock')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Walog_access_store_memLock l (v : (wal.Walog.t)) memLock' :
  AccessStrict
    (l.[(wal.Walog.t), "memLock"] ↦ (v.(wal.Walog.memLock')))
    (l.[(wal.Walog.t), "memLock"] ↦ memLock')
    (l ↦ v) (l ↦ (v <|(wal.Walog.memLock') := memLock'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Walog_access_load_d l (v : (wal.Walog.t)) dq :
  AccessStrict
    (l.[(wal.Walog.t), "d"] ↦{dq} (v.(wal.Walog.d')))
    (l.[(wal.Walog.t), "d"] ↦{dq} (v.(wal.Walog.d')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Walog_access_store_d l (v : (wal.Walog.t)) d' :
  AccessStrict
    (l.[(wal.Walog.t), "d"] ↦ (v.(wal.Walog.d')))
    (l.[(wal.Walog.t), "d"] ↦ d')
    (l ↦ v) (l ↦ (v <|(wal.Walog.d') := d'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Walog_access_load_circ l (v : (wal.Walog.t)) dq :
  AccessStrict
    (l.[(wal.Walog.t), "circ"] ↦{dq} (v.(wal.Walog.circ')))
    (l.[(wal.Walog.t), "circ"] ↦{dq} (v.(wal.Walog.circ')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Walog_access_store_circ l (v : (wal.Walog.t)) circ' :
  AccessStrict
    (l.[(wal.Walog.t), "circ"] ↦ (v.(wal.Walog.circ')))
    (l.[(wal.Walog.t), "circ"] ↦ circ')
    (l ↦ v) (l ↦ (v <|(wal.Walog.circ') := circ'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Walog_access_load_st l (v : (wal.Walog.t)) dq :
  AccessStrict
    (l.[(wal.Walog.t), "st"] ↦{dq} (v.(wal.Walog.st')))
    (l.[(wal.Walog.t), "st"] ↦{dq} (v.(wal.Walog.st')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Walog_access_store_st l (v : (wal.Walog.t)) st' :
  AccessStrict
    (l.[(wal.Walog.t), "st"] ↦ (v.(wal.Walog.st')))
    (l.[(wal.Walog.t), "st"] ↦ st')
    (l ↦ v) (l ↦ (v <|(wal.Walog.st') := st'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Walog_access_load_condLogger l (v : (wal.Walog.t)) dq :
  AccessStrict
    (l.[(wal.Walog.t), "condLogger"] ↦{dq} (v.(wal.Walog.condLogger')))
    (l.[(wal.Walog.t), "condLogger"] ↦{dq} (v.(wal.Walog.condLogger')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Walog_access_store_condLogger l (v : (wal.Walog.t)) condLogger' :
  AccessStrict
    (l.[(wal.Walog.t), "condLogger"] ↦ (v.(wal.Walog.condLogger')))
    (l.[(wal.Walog.t), "condLogger"] ↦ condLogger')
    (l ↦ v) (l ↦ (v <|(wal.Walog.condLogger') := condLogger'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Walog_access_load_condInstall l (v : (wal.Walog.t)) dq :
  AccessStrict
    (l.[(wal.Walog.t), "condInstall"] ↦{dq} (v.(wal.Walog.condInstall')))
    (l.[(wal.Walog.t), "condInstall"] ↦{dq} (v.(wal.Walog.condInstall')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Walog_access_store_condInstall l (v : (wal.Walog.t)) condInstall' :
  AccessStrict
    (l.[(wal.Walog.t), "condInstall"] ↦ (v.(wal.Walog.condInstall')))
    (l.[(wal.Walog.t), "condInstall"] ↦ condInstall')
    (l ↦ v) (l ↦ (v <|(wal.Walog.condInstall') := condInstall'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Walog_access_load_condShut l (v : (wal.Walog.t)) dq :
  AccessStrict
    (l.[(wal.Walog.t), "condShut"] ↦{dq} (v.(wal.Walog.condShut')))
    (l.[(wal.Walog.t), "condShut"] ↦{dq} (v.(wal.Walog.condShut')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Walog_access_store_condShut l (v : (wal.Walog.t)) condShut' :
  AccessStrict
    (l.[(wal.Walog.t), "condShut"] ↦ (v.(wal.Walog.condShut')))
    (l.[(wal.Walog.t), "condShut"] ↦ condShut')
    (l ↦ v) (l ↦ (v <|(wal.Walog.condShut') := condShut'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End Walog.

End wal.
