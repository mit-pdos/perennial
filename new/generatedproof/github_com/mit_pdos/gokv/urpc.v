(* autogenerated by goose proofgen; do not modify *)
Require Export New.proof.grove_prelude.
Require Export New.generatedproof.github_com.goose_lang.primitive.
Require Export New.generatedproof.github_com.goose_lang.std.
Require Export New.generatedproof.github_com.mit_pdos.gokv.grove_ffi.
Require Export New.generatedproof.github_com.tchajed.marshal.
Require Export New.generatedproof.log.
Require Export New.generatedproof.sync.
Require Export New.generatedproof.time.
Require Export New.golang.theory.
Require Export New.code.github_com.mit_pdos.gokv.urpc.

Set Default Proof Using "Type".

Module urpc.
Module Server.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : urpc.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance Server_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (urpc.Server.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "handlers" ∷ l.[(urpc.Server.t), "handlers"] ↦{dq} v.(urpc.Server.handlers') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance Server_into_val_typed
   :
  IntoValTypedUnderlying (urpc.Server.t) (urpc.Serverⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance Server_access_load_handlers l (v : (urpc.Server.t)) dq :
  AccessStrict
    (l.[(urpc.Server.t), "handlers"] ↦{dq} (v.(urpc.Server.handlers')))
    (l.[(urpc.Server.t), "handlers"] ↦{dq} (v.(urpc.Server.handlers')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Server_access_store_handlers l (v : (urpc.Server.t)) handlers' :
  AccessStrict
    (l.[(urpc.Server.t), "handlers"] ↦ (v.(urpc.Server.handlers')))
    (l.[(urpc.Server.t), "handlers"] ↦ handlers')
    (l ↦ v) (l ↦ (v <|(urpc.Server.handlers') := handlers'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End Server.

Module Callback.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : urpc.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance Callback_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (urpc.Callback.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "reply" ∷ l.[(urpc.Callback.t), "reply"] ↦{dq} v.(urpc.Callback.reply') ∗
      "state" ∷ l.[(urpc.Callback.t), "state"] ↦{dq} v.(urpc.Callback.state') ∗
      "cond" ∷ l.[(urpc.Callback.t), "cond"] ↦{dq} v.(urpc.Callback.cond') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance Callback_into_val_typed
   :
  IntoValTypedUnderlying (urpc.Callback.t) (urpc.Callbackⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance Callback_access_load_reply l (v : (urpc.Callback.t)) dq :
  AccessStrict
    (l.[(urpc.Callback.t), "reply"] ↦{dq} (v.(urpc.Callback.reply')))
    (l.[(urpc.Callback.t), "reply"] ↦{dq} (v.(urpc.Callback.reply')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Callback_access_store_reply l (v : (urpc.Callback.t)) reply' :
  AccessStrict
    (l.[(urpc.Callback.t), "reply"] ↦ (v.(urpc.Callback.reply')))
    (l.[(urpc.Callback.t), "reply"] ↦ reply')
    (l ↦ v) (l ↦ (v <|(urpc.Callback.reply') := reply'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Callback_access_load_state l (v : (urpc.Callback.t)) dq :
  AccessStrict
    (l.[(urpc.Callback.t), "state"] ↦{dq} (v.(urpc.Callback.state')))
    (l.[(urpc.Callback.t), "state"] ↦{dq} (v.(urpc.Callback.state')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Callback_access_store_state l (v : (urpc.Callback.t)) state' :
  AccessStrict
    (l.[(urpc.Callback.t), "state"] ↦ (v.(urpc.Callback.state')))
    (l.[(urpc.Callback.t), "state"] ↦ state')
    (l ↦ v) (l ↦ (v <|(urpc.Callback.state') := state'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Callback_access_load_cond l (v : (urpc.Callback.t)) dq :
  AccessStrict
    (l.[(urpc.Callback.t), "cond"] ↦{dq} (v.(urpc.Callback.cond')))
    (l.[(urpc.Callback.t), "cond"] ↦{dq} (v.(urpc.Callback.cond')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Callback_access_store_cond l (v : (urpc.Callback.t)) cond' :
  AccessStrict
    (l.[(urpc.Callback.t), "cond"] ↦ (v.(urpc.Callback.cond')))
    (l.[(urpc.Callback.t), "cond"] ↦ cond')
    (l ↦ v) (l ↦ (v <|(urpc.Callback.cond') := cond'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End Callback.

Module Client.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : urpc.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance Client_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (urpc.Client.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "mu" ∷ l.[(urpc.Client.t), "mu"] ↦{dq} v.(urpc.Client.mu') ∗
      "conn" ∷ l.[(urpc.Client.t), "conn"] ↦{dq} v.(urpc.Client.conn') ∗
      "seq" ∷ l.[(urpc.Client.t), "seq"] ↦{dq} v.(urpc.Client.seq') ∗
      "pending" ∷ l.[(urpc.Client.t), "pending"] ↦{dq} v.(urpc.Client.pending') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance Client_into_val_typed
   :
  IntoValTypedUnderlying (urpc.Client.t) (urpc.Clientⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance Client_access_load_mu l (v : (urpc.Client.t)) dq :
  AccessStrict
    (l.[(urpc.Client.t), "mu"] ↦{dq} (v.(urpc.Client.mu')))
    (l.[(urpc.Client.t), "mu"] ↦{dq} (v.(urpc.Client.mu')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Client_access_store_mu l (v : (urpc.Client.t)) mu' :
  AccessStrict
    (l.[(urpc.Client.t), "mu"] ↦ (v.(urpc.Client.mu')))
    (l.[(urpc.Client.t), "mu"] ↦ mu')
    (l ↦ v) (l ↦ (v <|(urpc.Client.mu') := mu'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Client_access_load_conn l (v : (urpc.Client.t)) dq :
  AccessStrict
    (l.[(urpc.Client.t), "conn"] ↦{dq} (v.(urpc.Client.conn')))
    (l.[(urpc.Client.t), "conn"] ↦{dq} (v.(urpc.Client.conn')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Client_access_store_conn l (v : (urpc.Client.t)) conn' :
  AccessStrict
    (l.[(urpc.Client.t), "conn"] ↦ (v.(urpc.Client.conn')))
    (l.[(urpc.Client.t), "conn"] ↦ conn')
    (l ↦ v) (l ↦ (v <|(urpc.Client.conn') := conn'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Client_access_load_seq l (v : (urpc.Client.t)) dq :
  AccessStrict
    (l.[(urpc.Client.t), "seq"] ↦{dq} (v.(urpc.Client.seq')))
    (l.[(urpc.Client.t), "seq"] ↦{dq} (v.(urpc.Client.seq')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Client_access_store_seq l (v : (urpc.Client.t)) seq' :
  AccessStrict
    (l.[(urpc.Client.t), "seq"] ↦ (v.(urpc.Client.seq')))
    (l.[(urpc.Client.t), "seq"] ↦ seq')
    (l ↦ v) (l ↦ (v <|(urpc.Client.seq') := seq'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Client_access_load_pending l (v : (urpc.Client.t)) dq :
  AccessStrict
    (l.[(urpc.Client.t), "pending"] ↦{dq} (v.(urpc.Client.pending')))
    (l.[(urpc.Client.t), "pending"] ↦{dq} (v.(urpc.Client.pending')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Client_access_store_pending l (v : (urpc.Client.t)) pending' :
  AccessStrict
    (l.[(urpc.Client.t), "pending"] ↦ (v.(urpc.Client.pending')))
    (l.[(urpc.Client.t), "pending"] ↦ pending')
    (l ↦ v) (l ↦ (v <|(urpc.Client.pending') := pending'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End Client.

End urpc.
