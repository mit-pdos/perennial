(* autogenerated by goose proofgen; do not modify *)
Require Export New.proof.grove_prelude.
Require Export New.generatedproof.github_com.goose_lang.primitive.
Require Export New.generatedproof.github_com.goose_lang.std.
Require Export New.generatedproof.github_com.mit_pdos.gokv.grove_ffi.
Require Export New.generatedproof.github_com.mit_pdos.gokv.reconfig.replica.becomeprimaryargs_gk.
Require Export New.generatedproof.github_com.mit_pdos.gokv.reconnectclient.
Require Export New.generatedproof.github_com.mit_pdos.gokv.urpc.
Require Export New.generatedproof.github_com.mit_pdos.gokv.vrsm.configservice.
Require Export New.generatedproof.github_com.mit_pdos.gokv.vrsm.replica.applyasbackupargs_gk.
Require Export New.generatedproof.github_com.mit_pdos.gokv.vrsm.replica.applyreply_gk.
Require Export New.generatedproof.github_com.mit_pdos.gokv.vrsm.replica.becomeprimaryargs_gk.
Require Export New.generatedproof.github_com.mit_pdos.gokv.vrsm.replica.err_gk.
Require Export New.generatedproof.github_com.mit_pdos.gokv.vrsm.replica.getstateargs_gk.
Require Export New.generatedproof.github_com.mit_pdos.gokv.vrsm.replica.getstatereply_gk.
Require Export New.generatedproof.github_com.mit_pdos.gokv.vrsm.replica.increasecommitargs_gk.
Require Export New.generatedproof.github_com.mit_pdos.gokv.vrsm.replica.setstateargs_gk.
Require Export New.generatedproof.log.
Require Export New.generatedproof.sync.
Require Export New.golang.theory.
Require Export New.code.github_com.mit_pdos.gokv.vrsm.replica.

Set Default Proof Using "Type".

Module replica.
Module StateMachine.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : replica.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance StateMachine_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (replica.StateMachine.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "StartApply" ∷ l.[(replica.StateMachine.t), "StartApply"] ↦{dq} v.(replica.StateMachine.StartApply') ∗
      "ApplyReadonly" ∷ l.[(replica.StateMachine.t), "ApplyReadonly"] ↦{dq} v.(replica.StateMachine.ApplyReadonly') ∗
      "SetStateAndUnseal" ∷ l.[(replica.StateMachine.t), "SetStateAndUnseal"] ↦{dq} v.(replica.StateMachine.SetStateAndUnseal') ∗
      "GetStateAndSeal" ∷ l.[(replica.StateMachine.t), "GetStateAndSeal"] ↦{dq} v.(replica.StateMachine.GetStateAndSeal') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance StateMachine_into_val_typed
   :
  IntoValTypedUnderlying (replica.StateMachine.t) (replica.StateMachineⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance StateMachine_access_load_StartApply l (v : (replica.StateMachine.t)) dq :
  AccessStrict
    (l.[(replica.StateMachine.t), "StartApply"] ↦{dq} (v.(replica.StateMachine.StartApply')))
    (l.[(replica.StateMachine.t), "StartApply"] ↦{dq} (v.(replica.StateMachine.StartApply')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance StateMachine_access_store_StartApply l (v : (replica.StateMachine.t)) StartApply' :
  AccessStrict
    (l.[(replica.StateMachine.t), "StartApply"] ↦ (v.(replica.StateMachine.StartApply')))
    (l.[(replica.StateMachine.t), "StartApply"] ↦ StartApply')
    (l ↦ v) (l ↦ (v <|(replica.StateMachine.StartApply') := StartApply'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance StateMachine_access_load_ApplyReadonly l (v : (replica.StateMachine.t)) dq :
  AccessStrict
    (l.[(replica.StateMachine.t), "ApplyReadonly"] ↦{dq} (v.(replica.StateMachine.ApplyReadonly')))
    (l.[(replica.StateMachine.t), "ApplyReadonly"] ↦{dq} (v.(replica.StateMachine.ApplyReadonly')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance StateMachine_access_store_ApplyReadonly l (v : (replica.StateMachine.t)) ApplyReadonly' :
  AccessStrict
    (l.[(replica.StateMachine.t), "ApplyReadonly"] ↦ (v.(replica.StateMachine.ApplyReadonly')))
    (l.[(replica.StateMachine.t), "ApplyReadonly"] ↦ ApplyReadonly')
    (l ↦ v) (l ↦ (v <|(replica.StateMachine.ApplyReadonly') := ApplyReadonly'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance StateMachine_access_load_SetStateAndUnseal l (v : (replica.StateMachine.t)) dq :
  AccessStrict
    (l.[(replica.StateMachine.t), "SetStateAndUnseal"] ↦{dq} (v.(replica.StateMachine.SetStateAndUnseal')))
    (l.[(replica.StateMachine.t), "SetStateAndUnseal"] ↦{dq} (v.(replica.StateMachine.SetStateAndUnseal')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance StateMachine_access_store_SetStateAndUnseal l (v : (replica.StateMachine.t)) SetStateAndUnseal' :
  AccessStrict
    (l.[(replica.StateMachine.t), "SetStateAndUnseal"] ↦ (v.(replica.StateMachine.SetStateAndUnseal')))
    (l.[(replica.StateMachine.t), "SetStateAndUnseal"] ↦ SetStateAndUnseal')
    (l ↦ v) (l ↦ (v <|(replica.StateMachine.SetStateAndUnseal') := SetStateAndUnseal'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance StateMachine_access_load_GetStateAndSeal l (v : (replica.StateMachine.t)) dq :
  AccessStrict
    (l.[(replica.StateMachine.t), "GetStateAndSeal"] ↦{dq} (v.(replica.StateMachine.GetStateAndSeal')))
    (l.[(replica.StateMachine.t), "GetStateAndSeal"] ↦{dq} (v.(replica.StateMachine.GetStateAndSeal')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance StateMachine_access_store_GetStateAndSeal l (v : (replica.StateMachine.t)) GetStateAndSeal' :
  AccessStrict
    (l.[(replica.StateMachine.t), "GetStateAndSeal"] ↦ (v.(replica.StateMachine.GetStateAndSeal')))
    (l.[(replica.StateMachine.t), "GetStateAndSeal"] ↦ GetStateAndSeal')
    (l ↦ v) (l ↦ (v <|(replica.StateMachine.GetStateAndSeal') := GetStateAndSeal'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End StateMachine.

Module SyncStateMachine.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : replica.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance SyncStateMachine_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (replica.SyncStateMachine.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "Apply" ∷ l.[(replica.SyncStateMachine.t), "Apply"] ↦{dq} v.(replica.SyncStateMachine.Apply') ∗
      "ApplyReadonly" ∷ l.[(replica.SyncStateMachine.t), "ApplyReadonly"] ↦{dq} v.(replica.SyncStateMachine.ApplyReadonly') ∗
      "SetStateAndUnseal" ∷ l.[(replica.SyncStateMachine.t), "SetStateAndUnseal"] ↦{dq} v.(replica.SyncStateMachine.SetStateAndUnseal') ∗
      "GetStateAndSeal" ∷ l.[(replica.SyncStateMachine.t), "GetStateAndSeal"] ↦{dq} v.(replica.SyncStateMachine.GetStateAndSeal') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance SyncStateMachine_into_val_typed
   :
  IntoValTypedUnderlying (replica.SyncStateMachine.t) (replica.SyncStateMachineⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance SyncStateMachine_access_load_Apply l (v : (replica.SyncStateMachine.t)) dq :
  AccessStrict
    (l.[(replica.SyncStateMachine.t), "Apply"] ↦{dq} (v.(replica.SyncStateMachine.Apply')))
    (l.[(replica.SyncStateMachine.t), "Apply"] ↦{dq} (v.(replica.SyncStateMachine.Apply')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance SyncStateMachine_access_store_Apply l (v : (replica.SyncStateMachine.t)) Apply' :
  AccessStrict
    (l.[(replica.SyncStateMachine.t), "Apply"] ↦ (v.(replica.SyncStateMachine.Apply')))
    (l.[(replica.SyncStateMachine.t), "Apply"] ↦ Apply')
    (l ↦ v) (l ↦ (v <|(replica.SyncStateMachine.Apply') := Apply'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance SyncStateMachine_access_load_ApplyReadonly l (v : (replica.SyncStateMachine.t)) dq :
  AccessStrict
    (l.[(replica.SyncStateMachine.t), "ApplyReadonly"] ↦{dq} (v.(replica.SyncStateMachine.ApplyReadonly')))
    (l.[(replica.SyncStateMachine.t), "ApplyReadonly"] ↦{dq} (v.(replica.SyncStateMachine.ApplyReadonly')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance SyncStateMachine_access_store_ApplyReadonly l (v : (replica.SyncStateMachine.t)) ApplyReadonly' :
  AccessStrict
    (l.[(replica.SyncStateMachine.t), "ApplyReadonly"] ↦ (v.(replica.SyncStateMachine.ApplyReadonly')))
    (l.[(replica.SyncStateMachine.t), "ApplyReadonly"] ↦ ApplyReadonly')
    (l ↦ v) (l ↦ (v <|(replica.SyncStateMachine.ApplyReadonly') := ApplyReadonly'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance SyncStateMachine_access_load_SetStateAndUnseal l (v : (replica.SyncStateMachine.t)) dq :
  AccessStrict
    (l.[(replica.SyncStateMachine.t), "SetStateAndUnseal"] ↦{dq} (v.(replica.SyncStateMachine.SetStateAndUnseal')))
    (l.[(replica.SyncStateMachine.t), "SetStateAndUnseal"] ↦{dq} (v.(replica.SyncStateMachine.SetStateAndUnseal')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance SyncStateMachine_access_store_SetStateAndUnseal l (v : (replica.SyncStateMachine.t)) SetStateAndUnseal' :
  AccessStrict
    (l.[(replica.SyncStateMachine.t), "SetStateAndUnseal"] ↦ (v.(replica.SyncStateMachine.SetStateAndUnseal')))
    (l.[(replica.SyncStateMachine.t), "SetStateAndUnseal"] ↦ SetStateAndUnseal')
    (l ↦ v) (l ↦ (v <|(replica.SyncStateMachine.SetStateAndUnseal') := SetStateAndUnseal'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance SyncStateMachine_access_load_GetStateAndSeal l (v : (replica.SyncStateMachine.t)) dq :
  AccessStrict
    (l.[(replica.SyncStateMachine.t), "GetStateAndSeal"] ↦{dq} (v.(replica.SyncStateMachine.GetStateAndSeal')))
    (l.[(replica.SyncStateMachine.t), "GetStateAndSeal"] ↦{dq} (v.(replica.SyncStateMachine.GetStateAndSeal')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance SyncStateMachine_access_store_GetStateAndSeal l (v : (replica.SyncStateMachine.t)) GetStateAndSeal' :
  AccessStrict
    (l.[(replica.SyncStateMachine.t), "GetStateAndSeal"] ↦ (v.(replica.SyncStateMachine.GetStateAndSeal')))
    (l.[(replica.SyncStateMachine.t), "GetStateAndSeal"] ↦ GetStateAndSeal')
    (l ↦ v) (l ↦ (v <|(replica.SyncStateMachine.GetStateAndSeal') := GetStateAndSeal'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End SyncStateMachine.

Module Clerk.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : replica.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance Clerk_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (replica.Clerk.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "cl" ∷ l.[(replica.Clerk.t), "cl"] ↦{dq} v.(replica.Clerk.cl') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance Clerk_into_val_typed
   :
  IntoValTypedUnderlying (replica.Clerk.t) (replica.Clerkⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance Clerk_access_load_cl l (v : (replica.Clerk.t)) dq :
  AccessStrict
    (l.[(replica.Clerk.t), "cl"] ↦{dq} (v.(replica.Clerk.cl')))
    (l.[(replica.Clerk.t), "cl"] ↦{dq} (v.(replica.Clerk.cl')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Clerk_access_store_cl l (v : (replica.Clerk.t)) cl' :
  AccessStrict
    (l.[(replica.Clerk.t), "cl"] ↦ (v.(replica.Clerk.cl')))
    (l.[(replica.Clerk.t), "cl"] ↦ cl')
    (l ↦ v) (l ↦ (v <|(replica.Clerk.cl') := cl'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End Clerk.

Module Server.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : replica.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance Server_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (replica.Server.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "mu" ∷ l.[(replica.Server.t), "mu"] ↦{dq} v.(replica.Server.mu') ∗
      "epoch" ∷ l.[(replica.Server.t), "epoch"] ↦{dq} v.(replica.Server.epoch') ∗
      "sealed" ∷ l.[(replica.Server.t), "sealed"] ↦{dq} v.(replica.Server.sealed') ∗
      "sm" ∷ l.[(replica.Server.t), "sm"] ↦{dq} v.(replica.Server.sm') ∗
      "nextIndex" ∷ l.[(replica.Server.t), "nextIndex"] ↦{dq} v.(replica.Server.nextIndex') ∗
      "canBecomePrimary" ∷ l.[(replica.Server.t), "canBecomePrimary"] ↦{dq} v.(replica.Server.canBecomePrimary') ∗
      "isPrimary" ∷ l.[(replica.Server.t), "isPrimary"] ↦{dq} v.(replica.Server.isPrimary') ∗
      "clerks" ∷ l.[(replica.Server.t), "clerks"] ↦{dq} v.(replica.Server.clerks') ∗
      "isPrimary_cond" ∷ l.[(replica.Server.t), "isPrimary_cond"] ↦{dq} v.(replica.Server.isPrimary_cond') ∗
      "opAppliedConds" ∷ l.[(replica.Server.t), "opAppliedConds"] ↦{dq} v.(replica.Server.opAppliedConds') ∗
      "leaseExpiration" ∷ l.[(replica.Server.t), "leaseExpiration"] ↦{dq} v.(replica.Server.leaseExpiration') ∗
      "leaseValid" ∷ l.[(replica.Server.t), "leaseValid"] ↦{dq} v.(replica.Server.leaseValid') ∗
      "committedNextIndex" ∷ l.[(replica.Server.t), "committedNextIndex"] ↦{dq} v.(replica.Server.committedNextIndex') ∗
      "committedNextIndex_cond" ∷ l.[(replica.Server.t), "committedNextIndex_cond"] ↦{dq} v.(replica.Server.committedNextIndex_cond') ∗
      "confCk" ∷ l.[(replica.Server.t), "confCk"] ↦{dq} v.(replica.Server.confCk') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance Server_into_val_typed
   :
  IntoValTypedUnderlying (replica.Server.t) (replica.Serverⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance Server_access_load_mu l (v : (replica.Server.t)) dq :
  AccessStrict
    (l.[(replica.Server.t), "mu"] ↦{dq} (v.(replica.Server.mu')))
    (l.[(replica.Server.t), "mu"] ↦{dq} (v.(replica.Server.mu')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Server_access_store_mu l (v : (replica.Server.t)) mu' :
  AccessStrict
    (l.[(replica.Server.t), "mu"] ↦ (v.(replica.Server.mu')))
    (l.[(replica.Server.t), "mu"] ↦ mu')
    (l ↦ v) (l ↦ (v <|(replica.Server.mu') := mu'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Server_access_load_epoch l (v : (replica.Server.t)) dq :
  AccessStrict
    (l.[(replica.Server.t), "epoch"] ↦{dq} (v.(replica.Server.epoch')))
    (l.[(replica.Server.t), "epoch"] ↦{dq} (v.(replica.Server.epoch')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Server_access_store_epoch l (v : (replica.Server.t)) epoch' :
  AccessStrict
    (l.[(replica.Server.t), "epoch"] ↦ (v.(replica.Server.epoch')))
    (l.[(replica.Server.t), "epoch"] ↦ epoch')
    (l ↦ v) (l ↦ (v <|(replica.Server.epoch') := epoch'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Server_access_load_sealed l (v : (replica.Server.t)) dq :
  AccessStrict
    (l.[(replica.Server.t), "sealed"] ↦{dq} (v.(replica.Server.sealed')))
    (l.[(replica.Server.t), "sealed"] ↦{dq} (v.(replica.Server.sealed')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Server_access_store_sealed l (v : (replica.Server.t)) sealed' :
  AccessStrict
    (l.[(replica.Server.t), "sealed"] ↦ (v.(replica.Server.sealed')))
    (l.[(replica.Server.t), "sealed"] ↦ sealed')
    (l ↦ v) (l ↦ (v <|(replica.Server.sealed') := sealed'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Server_access_load_sm l (v : (replica.Server.t)) dq :
  AccessStrict
    (l.[(replica.Server.t), "sm"] ↦{dq} (v.(replica.Server.sm')))
    (l.[(replica.Server.t), "sm"] ↦{dq} (v.(replica.Server.sm')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Server_access_store_sm l (v : (replica.Server.t)) sm' :
  AccessStrict
    (l.[(replica.Server.t), "sm"] ↦ (v.(replica.Server.sm')))
    (l.[(replica.Server.t), "sm"] ↦ sm')
    (l ↦ v) (l ↦ (v <|(replica.Server.sm') := sm'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Server_access_load_nextIndex l (v : (replica.Server.t)) dq :
  AccessStrict
    (l.[(replica.Server.t), "nextIndex"] ↦{dq} (v.(replica.Server.nextIndex')))
    (l.[(replica.Server.t), "nextIndex"] ↦{dq} (v.(replica.Server.nextIndex')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Server_access_store_nextIndex l (v : (replica.Server.t)) nextIndex' :
  AccessStrict
    (l.[(replica.Server.t), "nextIndex"] ↦ (v.(replica.Server.nextIndex')))
    (l.[(replica.Server.t), "nextIndex"] ↦ nextIndex')
    (l ↦ v) (l ↦ (v <|(replica.Server.nextIndex') := nextIndex'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Server_access_load_canBecomePrimary l (v : (replica.Server.t)) dq :
  AccessStrict
    (l.[(replica.Server.t), "canBecomePrimary"] ↦{dq} (v.(replica.Server.canBecomePrimary')))
    (l.[(replica.Server.t), "canBecomePrimary"] ↦{dq} (v.(replica.Server.canBecomePrimary')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Server_access_store_canBecomePrimary l (v : (replica.Server.t)) canBecomePrimary' :
  AccessStrict
    (l.[(replica.Server.t), "canBecomePrimary"] ↦ (v.(replica.Server.canBecomePrimary')))
    (l.[(replica.Server.t), "canBecomePrimary"] ↦ canBecomePrimary')
    (l ↦ v) (l ↦ (v <|(replica.Server.canBecomePrimary') := canBecomePrimary'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Server_access_load_isPrimary l (v : (replica.Server.t)) dq :
  AccessStrict
    (l.[(replica.Server.t), "isPrimary"] ↦{dq} (v.(replica.Server.isPrimary')))
    (l.[(replica.Server.t), "isPrimary"] ↦{dq} (v.(replica.Server.isPrimary')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Server_access_store_isPrimary l (v : (replica.Server.t)) isPrimary' :
  AccessStrict
    (l.[(replica.Server.t), "isPrimary"] ↦ (v.(replica.Server.isPrimary')))
    (l.[(replica.Server.t), "isPrimary"] ↦ isPrimary')
    (l ↦ v) (l ↦ (v <|(replica.Server.isPrimary') := isPrimary'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Server_access_load_clerks l (v : (replica.Server.t)) dq :
  AccessStrict
    (l.[(replica.Server.t), "clerks"] ↦{dq} (v.(replica.Server.clerks')))
    (l.[(replica.Server.t), "clerks"] ↦{dq} (v.(replica.Server.clerks')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Server_access_store_clerks l (v : (replica.Server.t)) clerks' :
  AccessStrict
    (l.[(replica.Server.t), "clerks"] ↦ (v.(replica.Server.clerks')))
    (l.[(replica.Server.t), "clerks"] ↦ clerks')
    (l ↦ v) (l ↦ (v <|(replica.Server.clerks') := clerks'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Server_access_load_isPrimary_cond l (v : (replica.Server.t)) dq :
  AccessStrict
    (l.[(replica.Server.t), "isPrimary_cond"] ↦{dq} (v.(replica.Server.isPrimary_cond')))
    (l.[(replica.Server.t), "isPrimary_cond"] ↦{dq} (v.(replica.Server.isPrimary_cond')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Server_access_store_isPrimary_cond l (v : (replica.Server.t)) isPrimary_cond' :
  AccessStrict
    (l.[(replica.Server.t), "isPrimary_cond"] ↦ (v.(replica.Server.isPrimary_cond')))
    (l.[(replica.Server.t), "isPrimary_cond"] ↦ isPrimary_cond')
    (l ↦ v) (l ↦ (v <|(replica.Server.isPrimary_cond') := isPrimary_cond'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Server_access_load_opAppliedConds l (v : (replica.Server.t)) dq :
  AccessStrict
    (l.[(replica.Server.t), "opAppliedConds"] ↦{dq} (v.(replica.Server.opAppliedConds')))
    (l.[(replica.Server.t), "opAppliedConds"] ↦{dq} (v.(replica.Server.opAppliedConds')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Server_access_store_opAppliedConds l (v : (replica.Server.t)) opAppliedConds' :
  AccessStrict
    (l.[(replica.Server.t), "opAppliedConds"] ↦ (v.(replica.Server.opAppliedConds')))
    (l.[(replica.Server.t), "opAppliedConds"] ↦ opAppliedConds')
    (l ↦ v) (l ↦ (v <|(replica.Server.opAppliedConds') := opAppliedConds'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Server_access_load_leaseExpiration l (v : (replica.Server.t)) dq :
  AccessStrict
    (l.[(replica.Server.t), "leaseExpiration"] ↦{dq} (v.(replica.Server.leaseExpiration')))
    (l.[(replica.Server.t), "leaseExpiration"] ↦{dq} (v.(replica.Server.leaseExpiration')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Server_access_store_leaseExpiration l (v : (replica.Server.t)) leaseExpiration' :
  AccessStrict
    (l.[(replica.Server.t), "leaseExpiration"] ↦ (v.(replica.Server.leaseExpiration')))
    (l.[(replica.Server.t), "leaseExpiration"] ↦ leaseExpiration')
    (l ↦ v) (l ↦ (v <|(replica.Server.leaseExpiration') := leaseExpiration'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Server_access_load_leaseValid l (v : (replica.Server.t)) dq :
  AccessStrict
    (l.[(replica.Server.t), "leaseValid"] ↦{dq} (v.(replica.Server.leaseValid')))
    (l.[(replica.Server.t), "leaseValid"] ↦{dq} (v.(replica.Server.leaseValid')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Server_access_store_leaseValid l (v : (replica.Server.t)) leaseValid' :
  AccessStrict
    (l.[(replica.Server.t), "leaseValid"] ↦ (v.(replica.Server.leaseValid')))
    (l.[(replica.Server.t), "leaseValid"] ↦ leaseValid')
    (l ↦ v) (l ↦ (v <|(replica.Server.leaseValid') := leaseValid'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Server_access_load_committedNextIndex l (v : (replica.Server.t)) dq :
  AccessStrict
    (l.[(replica.Server.t), "committedNextIndex"] ↦{dq} (v.(replica.Server.committedNextIndex')))
    (l.[(replica.Server.t), "committedNextIndex"] ↦{dq} (v.(replica.Server.committedNextIndex')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Server_access_store_committedNextIndex l (v : (replica.Server.t)) committedNextIndex' :
  AccessStrict
    (l.[(replica.Server.t), "committedNextIndex"] ↦ (v.(replica.Server.committedNextIndex')))
    (l.[(replica.Server.t), "committedNextIndex"] ↦ committedNextIndex')
    (l ↦ v) (l ↦ (v <|(replica.Server.committedNextIndex') := committedNextIndex'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Server_access_load_committedNextIndex_cond l (v : (replica.Server.t)) dq :
  AccessStrict
    (l.[(replica.Server.t), "committedNextIndex_cond"] ↦{dq} (v.(replica.Server.committedNextIndex_cond')))
    (l.[(replica.Server.t), "committedNextIndex_cond"] ↦{dq} (v.(replica.Server.committedNextIndex_cond')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Server_access_store_committedNextIndex_cond l (v : (replica.Server.t)) committedNextIndex_cond' :
  AccessStrict
    (l.[(replica.Server.t), "committedNextIndex_cond"] ↦ (v.(replica.Server.committedNextIndex_cond')))
    (l.[(replica.Server.t), "committedNextIndex_cond"] ↦ committedNextIndex_cond')
    (l ↦ v) (l ↦ (v <|(replica.Server.committedNextIndex_cond') := committedNextIndex_cond'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Server_access_load_confCk l (v : (replica.Server.t)) dq :
  AccessStrict
    (l.[(replica.Server.t), "confCk"] ↦{dq} (v.(replica.Server.confCk')))
    (l.[(replica.Server.t), "confCk"] ↦{dq} (v.(replica.Server.confCk')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Server_access_store_confCk l (v : (replica.Server.t)) confCk' :
  AccessStrict
    (l.[(replica.Server.t), "confCk"] ↦ (v.(replica.Server.confCk')))
    (l.[(replica.Server.t), "confCk"] ↦ confCk')
    (l ↦ v) (l ↦ (v <|(replica.Server.confCk') := confCk'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End Server.

End replica.
