(* autogenerated by goose proofgen; do not modify *)
Require Export New.proof.grove_prelude.
Require Export New.generatedproof.github_com.mit_pdos.gokv.grove_ffi.
Require Export New.generatedproof.github_com.mit_pdos.gokv.kv.
Require Export New.generatedproof.github_com.mit_pdos.gokv.map_string_marshal.
Require Export New.generatedproof.github_com.mit_pdos.gokv.vrsm.apps.exactlyonce.
Require Export New.generatedproof.github_com.mit_pdos.gokv.vrsm.apps.vkv.condputargs_gk.
Require Export New.generatedproof.github_com.mit_pdos.gokv.vrsm.apps.vkv.getargs_gk.
Require Export New.generatedproof.github_com.mit_pdos.gokv.vrsm.apps.vkv.putargs_gk.
Require Export New.generatedproof.github_com.mit_pdos.gokv.vrsm.storage.
Require Export New.generatedproof.sync.
Require Export New.golang.theory.
Require Export New.code.github_com.mit_pdos.gokv.vrsm.apps.vkv.

Set Default Proof Using "Type".

Module vkv.
Module Clerk.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : vkv.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance Clerk_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (vkv.Clerk.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "cl" ∷ l.[(vkv.Clerk.t), "cl"] ↦{dq} v.(vkv.Clerk.cl') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance Clerk_into_val_typed
   :
  IntoValTypedUnderlying (vkv.Clerk.t) (vkv.Clerkⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance Clerk_access_load_cl l (v : (vkv.Clerk.t)) dq :
  AccessStrict
    (l.[(vkv.Clerk.t), "cl"] ↦{dq} (v.(vkv.Clerk.cl')))
    (l.[(vkv.Clerk.t), "cl"] ↦{dq} (v.(vkv.Clerk.cl')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Clerk_access_store_cl l (v : (vkv.Clerk.t)) cl' :
  AccessStrict
    (l.[(vkv.Clerk.t), "cl"] ↦ (v.(vkv.Clerk.cl')))
    (l.[(vkv.Clerk.t), "cl"] ↦ cl')
    (l ↦ v) (l ↦ (v <|(vkv.Clerk.cl') := cl'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End Clerk.

Module ClerkPool.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : vkv.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance ClerkPool_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (vkv.ClerkPool.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "mu" ∷ l.[(vkv.ClerkPool.t), "mu"] ↦{dq} v.(vkv.ClerkPool.mu') ∗
      "cls" ∷ l.[(vkv.ClerkPool.t), "cls"] ↦{dq} v.(vkv.ClerkPool.cls') ∗
      "confHosts" ∷ l.[(vkv.ClerkPool.t), "confHosts"] ↦{dq} v.(vkv.ClerkPool.confHosts') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance ClerkPool_into_val_typed
   :
  IntoValTypedUnderlying (vkv.ClerkPool.t) (vkv.ClerkPoolⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance ClerkPool_access_load_mu l (v : (vkv.ClerkPool.t)) dq :
  AccessStrict
    (l.[(vkv.ClerkPool.t), "mu"] ↦{dq} (v.(vkv.ClerkPool.mu')))
    (l.[(vkv.ClerkPool.t), "mu"] ↦{dq} (v.(vkv.ClerkPool.mu')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance ClerkPool_access_store_mu l (v : (vkv.ClerkPool.t)) mu' :
  AccessStrict
    (l.[(vkv.ClerkPool.t), "mu"] ↦ (v.(vkv.ClerkPool.mu')))
    (l.[(vkv.ClerkPool.t), "mu"] ↦ mu')
    (l ↦ v) (l ↦ (v <|(vkv.ClerkPool.mu') := mu'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance ClerkPool_access_load_cls l (v : (vkv.ClerkPool.t)) dq :
  AccessStrict
    (l.[(vkv.ClerkPool.t), "cls"] ↦{dq} (v.(vkv.ClerkPool.cls')))
    (l.[(vkv.ClerkPool.t), "cls"] ↦{dq} (v.(vkv.ClerkPool.cls')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance ClerkPool_access_store_cls l (v : (vkv.ClerkPool.t)) cls' :
  AccessStrict
    (l.[(vkv.ClerkPool.t), "cls"] ↦ (v.(vkv.ClerkPool.cls')))
    (l.[(vkv.ClerkPool.t), "cls"] ↦ cls')
    (l ↦ v) (l ↦ (v <|(vkv.ClerkPool.cls') := cls'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance ClerkPool_access_load_confHosts l (v : (vkv.ClerkPool.t)) dq :
  AccessStrict
    (l.[(vkv.ClerkPool.t), "confHosts"] ↦{dq} (v.(vkv.ClerkPool.confHosts')))
    (l.[(vkv.ClerkPool.t), "confHosts"] ↦{dq} (v.(vkv.ClerkPool.confHosts')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance ClerkPool_access_store_confHosts l (v : (vkv.ClerkPool.t)) confHosts' :
  AccessStrict
    (l.[(vkv.ClerkPool.t), "confHosts"] ↦ (v.(vkv.ClerkPool.confHosts')))
    (l.[(vkv.ClerkPool.t), "confHosts"] ↦ confHosts')
    (l ↦ v) (l ↦ (v <|(vkv.ClerkPool.confHosts') := confHosts'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End ClerkPool.

Module KVState.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : vkv.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance KVState_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (vkv.KVState.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "kvs" ∷ l.[(vkv.KVState.t), "kvs"] ↦{dq} v.(vkv.KVState.kvs') ∗
      "vnums" ∷ l.[(vkv.KVState.t), "vnums"] ↦{dq} v.(vkv.KVState.vnums') ∗
      "minVnum" ∷ l.[(vkv.KVState.t), "minVnum"] ↦{dq} v.(vkv.KVState.minVnum') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance KVState_into_val_typed
   :
  IntoValTypedUnderlying (vkv.KVState.t) (vkv.KVStateⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance KVState_access_load_kvs l (v : (vkv.KVState.t)) dq :
  AccessStrict
    (l.[(vkv.KVState.t), "kvs"] ↦{dq} (v.(vkv.KVState.kvs')))
    (l.[(vkv.KVState.t), "kvs"] ↦{dq} (v.(vkv.KVState.kvs')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance KVState_access_store_kvs l (v : (vkv.KVState.t)) kvs' :
  AccessStrict
    (l.[(vkv.KVState.t), "kvs"] ↦ (v.(vkv.KVState.kvs')))
    (l.[(vkv.KVState.t), "kvs"] ↦ kvs')
    (l ↦ v) (l ↦ (v <|(vkv.KVState.kvs') := kvs'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance KVState_access_load_vnums l (v : (vkv.KVState.t)) dq :
  AccessStrict
    (l.[(vkv.KVState.t), "vnums"] ↦{dq} (v.(vkv.KVState.vnums')))
    (l.[(vkv.KVState.t), "vnums"] ↦{dq} (v.(vkv.KVState.vnums')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance KVState_access_store_vnums l (v : (vkv.KVState.t)) vnums' :
  AccessStrict
    (l.[(vkv.KVState.t), "vnums"] ↦ (v.(vkv.KVState.vnums')))
    (l.[(vkv.KVState.t), "vnums"] ↦ vnums')
    (l ↦ v) (l ↦ (v <|(vkv.KVState.vnums') := vnums'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance KVState_access_load_minVnum l (v : (vkv.KVState.t)) dq :
  AccessStrict
    (l.[(vkv.KVState.t), "minVnum"] ↦{dq} (v.(vkv.KVState.minVnum')))
    (l.[(vkv.KVState.t), "minVnum"] ↦{dq} (v.(vkv.KVState.minVnum')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance KVState_access_store_minVnum l (v : (vkv.KVState.t)) minVnum' :
  AccessStrict
    (l.[(vkv.KVState.t), "minVnum"] ↦ (v.(vkv.KVState.minVnum')))
    (l.[(vkv.KVState.t), "minVnum"] ↦ minVnum')
    (l ↦ v) (l ↦ (v <|(vkv.KVState.minVnum') := minVnum'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End KVState.

End vkv.
