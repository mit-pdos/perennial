(* autogenerated by goose proofgen; do not modify *)
Require Export New.proof.grove_prelude.
Require Export New.generatedproof.github_com.goose_lang.primitive.
Require Export New.generatedproof.github_com.goose_lang.std.
Require Export New.generatedproof.github_com.mit_pdos.gokv.grove_ffi.
Require Export New.generatedproof.github_com.mit_pdos.gokv.reconnectclient.
Require Export New.generatedproof.github_com.mit_pdos.gokv.urpc.
Require Export New.generatedproof.github_com.mit_pdos.gokv.vrsm.configservice.config_gk.
Require Export New.generatedproof.github_com.mit_pdos.gokv.vrsm.paxos.
Require Export New.generatedproof.github_com.mit_pdos.gokv.vrsm.replica.err_gk.
Require Export New.generatedproof.github_com.tchajed.marshal.
Require Export New.generatedproof.log.
Require Export New.generatedproof.sync.
Require Export New.golang.theory.
Require Export New.code.github_com.mit_pdos.gokv.vrsm.configservice.

Set Default Proof Using "Type".

Module configservice.
Module Clerk.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : configservice.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance Clerk_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (configservice.Clerk.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "mu" ∷ l.[(configservice.Clerk.t), "mu"] ↦{dq} v.(configservice.Clerk.mu') ∗
      "cls" ∷ l.[(configservice.Clerk.t), "cls"] ↦{dq} v.(configservice.Clerk.cls') ∗
      "leader" ∷ l.[(configservice.Clerk.t), "leader"] ↦{dq} v.(configservice.Clerk.leader') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance Clerk_into_val_typed
   :
  IntoValTypedUnderlying (configservice.Clerk.t) (configservice.Clerkⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance Clerk_access_load_mu l (v : (configservice.Clerk.t)) dq :
  AccessStrict
    (l.[(configservice.Clerk.t), "mu"] ↦{dq} (v.(configservice.Clerk.mu')))
    (l.[(configservice.Clerk.t), "mu"] ↦{dq} (v.(configservice.Clerk.mu')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Clerk_access_store_mu l (v : (configservice.Clerk.t)) mu' :
  AccessStrict
    (l.[(configservice.Clerk.t), "mu"] ↦ (v.(configservice.Clerk.mu')))
    (l.[(configservice.Clerk.t), "mu"] ↦ mu')
    (l ↦ v) (l ↦ (v <|(configservice.Clerk.mu') := mu'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Clerk_access_load_cls l (v : (configservice.Clerk.t)) dq :
  AccessStrict
    (l.[(configservice.Clerk.t), "cls"] ↦{dq} (v.(configservice.Clerk.cls')))
    (l.[(configservice.Clerk.t), "cls"] ↦{dq} (v.(configservice.Clerk.cls')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Clerk_access_store_cls l (v : (configservice.Clerk.t)) cls' :
  AccessStrict
    (l.[(configservice.Clerk.t), "cls"] ↦ (v.(configservice.Clerk.cls')))
    (l.[(configservice.Clerk.t), "cls"] ↦ cls')
    (l ↦ v) (l ↦ (v <|(configservice.Clerk.cls') := cls'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Clerk_access_load_leader l (v : (configservice.Clerk.t)) dq :
  AccessStrict
    (l.[(configservice.Clerk.t), "leader"] ↦{dq} (v.(configservice.Clerk.leader')))
    (l.[(configservice.Clerk.t), "leader"] ↦{dq} (v.(configservice.Clerk.leader')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Clerk_access_store_leader l (v : (configservice.Clerk.t)) leader' :
  AccessStrict
    (l.[(configservice.Clerk.t), "leader"] ↦ (v.(configservice.Clerk.leader')))
    (l.[(configservice.Clerk.t), "leader"] ↦ leader')
    (l ↦ v) (l ↦ (v <|(configservice.Clerk.leader') := leader'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End Clerk.

Module state.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : configservice.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance state_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (configservice.state.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "epoch" ∷ l.[(configservice.state.t), "epoch"] ↦{dq} v.(configservice.state.epoch') ∗
      "reservedEpoch" ∷ l.[(configservice.state.t), "reservedEpoch"] ↦{dq} v.(configservice.state.reservedEpoch') ∗
      "leaseExpiration" ∷ l.[(configservice.state.t), "leaseExpiration"] ↦{dq} v.(configservice.state.leaseExpiration') ∗
      "wantLeaseToExpire" ∷ l.[(configservice.state.t), "wantLeaseToExpire"] ↦{dq} v.(configservice.state.wantLeaseToExpire') ∗
      "config" ∷ l.[(configservice.state.t), "config"] ↦{dq} v.(configservice.state.config') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance state_into_val_typed
   :
  IntoValTypedUnderlying (configservice.state.t) (configservice.stateⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance state_access_load_epoch l (v : (configservice.state.t)) dq :
  AccessStrict
    (l.[(configservice.state.t), "epoch"] ↦{dq} (v.(configservice.state.epoch')))
    (l.[(configservice.state.t), "epoch"] ↦{dq} (v.(configservice.state.epoch')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance state_access_store_epoch l (v : (configservice.state.t)) epoch' :
  AccessStrict
    (l.[(configservice.state.t), "epoch"] ↦ (v.(configservice.state.epoch')))
    (l.[(configservice.state.t), "epoch"] ↦ epoch')
    (l ↦ v) (l ↦ (v <|(configservice.state.epoch') := epoch'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance state_access_load_reservedEpoch l (v : (configservice.state.t)) dq :
  AccessStrict
    (l.[(configservice.state.t), "reservedEpoch"] ↦{dq} (v.(configservice.state.reservedEpoch')))
    (l.[(configservice.state.t), "reservedEpoch"] ↦{dq} (v.(configservice.state.reservedEpoch')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance state_access_store_reservedEpoch l (v : (configservice.state.t)) reservedEpoch' :
  AccessStrict
    (l.[(configservice.state.t), "reservedEpoch"] ↦ (v.(configservice.state.reservedEpoch')))
    (l.[(configservice.state.t), "reservedEpoch"] ↦ reservedEpoch')
    (l ↦ v) (l ↦ (v <|(configservice.state.reservedEpoch') := reservedEpoch'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance state_access_load_leaseExpiration l (v : (configservice.state.t)) dq :
  AccessStrict
    (l.[(configservice.state.t), "leaseExpiration"] ↦{dq} (v.(configservice.state.leaseExpiration')))
    (l.[(configservice.state.t), "leaseExpiration"] ↦{dq} (v.(configservice.state.leaseExpiration')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance state_access_store_leaseExpiration l (v : (configservice.state.t)) leaseExpiration' :
  AccessStrict
    (l.[(configservice.state.t), "leaseExpiration"] ↦ (v.(configservice.state.leaseExpiration')))
    (l.[(configservice.state.t), "leaseExpiration"] ↦ leaseExpiration')
    (l ↦ v) (l ↦ (v <|(configservice.state.leaseExpiration') := leaseExpiration'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance state_access_load_wantLeaseToExpire l (v : (configservice.state.t)) dq :
  AccessStrict
    (l.[(configservice.state.t), "wantLeaseToExpire"] ↦{dq} (v.(configservice.state.wantLeaseToExpire')))
    (l.[(configservice.state.t), "wantLeaseToExpire"] ↦{dq} (v.(configservice.state.wantLeaseToExpire')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance state_access_store_wantLeaseToExpire l (v : (configservice.state.t)) wantLeaseToExpire' :
  AccessStrict
    (l.[(configservice.state.t), "wantLeaseToExpire"] ↦ (v.(configservice.state.wantLeaseToExpire')))
    (l.[(configservice.state.t), "wantLeaseToExpire"] ↦ wantLeaseToExpire')
    (l ↦ v) (l ↦ (v <|(configservice.state.wantLeaseToExpire') := wantLeaseToExpire'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance state_access_load_config l (v : (configservice.state.t)) dq :
  AccessStrict
    (l.[(configservice.state.t), "config"] ↦{dq} (v.(configservice.state.config')))
    (l.[(configservice.state.t), "config"] ↦{dq} (v.(configservice.state.config')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance state_access_store_config l (v : (configservice.state.t)) config' :
  AccessStrict
    (l.[(configservice.state.t), "config"] ↦ (v.(configservice.state.config')))
    (l.[(configservice.state.t), "config"] ↦ config')
    (l ↦ v) (l ↦ (v <|(configservice.state.config') := config'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End state.

Module Server.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : configservice.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance Server_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (configservice.Server.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "s" ∷ l.[(configservice.Server.t), "s"] ↦{dq} v.(configservice.Server.s') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance Server_into_val_typed
   :
  IntoValTypedUnderlying (configservice.Server.t) (configservice.Serverⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance Server_access_load_s l (v : (configservice.Server.t)) dq :
  AccessStrict
    (l.[(configservice.Server.t), "s"] ↦{dq} (v.(configservice.Server.s')))
    (l.[(configservice.Server.t), "s"] ↦{dq} (v.(configservice.Server.s')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Server_access_store_s l (v : (configservice.Server.t)) s' :
  AccessStrict
    (l.[(configservice.Server.t), "s"] ↦ (v.(configservice.Server.s')))
    (l.[(configservice.Server.t), "s"] ↦ s')
    (l ↦ v) (l ↦ (v <|(configservice.Server.s') := s'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End Server.

End configservice.
