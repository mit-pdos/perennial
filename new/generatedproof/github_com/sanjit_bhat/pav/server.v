(* autogenerated by goose proofgen; do not modify *)
Require Export New.proof.proof_prelude.
Require Export New.generatedproof.github_com.goose_lang.std.
Require Export New.generatedproof.github_com.sanjit_bhat.pav.advrpc.
Require Export New.generatedproof.github_com.sanjit_bhat.pav.cryptoffi.
Require Export New.generatedproof.github_com.sanjit_bhat.pav.hashchain.
Require Export New.generatedproof.github_com.sanjit_bhat.pav.ktcore.
Require Export New.generatedproof.github_com.sanjit_bhat.pav.merkle.
Require Export New.generatedproof.github_com.sanjit_bhat.pav.safemarshal.
Require Export New.generatedproof.github_com.tchajed.marshal.
Require Export New.generatedproof.sync.
Require Export New.generatedproof.time.
Require Export New.golang.theory.
Require Export New.code.github_com.sanjit_bhat.pav.server.

Set Default Proof Using "Type".

Module server.
Module StartChain.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : server.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance StartChain_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (server.StartChain.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "PrevEpochLen" ∷ l.[(server.StartChain.t), "PrevEpochLen"] ↦{dq} v.(server.StartChain.PrevEpochLen') ∗
      "PrevLink" ∷ l.[(server.StartChain.t), "PrevLink"] ↦{dq} v.(server.StartChain.PrevLink') ∗
      "ChainProof" ∷ l.[(server.StartChain.t), "ChainProof"] ↦{dq} v.(server.StartChain.ChainProof') ∗
      "LinkSig" ∷ l.[(server.StartChain.t), "LinkSig"] ↦{dq} v.(server.StartChain.LinkSig') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance StartChain_into_val_typed
   :
  IntoValTypedUnderlying (server.StartChain.t) (server.StartChainⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance StartChain_access_load_PrevEpochLen l (v : (server.StartChain.t)) dq :
  AccessStrict
    (l.[(server.StartChain.t), "PrevEpochLen"] ↦{dq} (v.(server.StartChain.PrevEpochLen')))
    (l.[(server.StartChain.t), "PrevEpochLen"] ↦{dq} (v.(server.StartChain.PrevEpochLen')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance StartChain_access_store_PrevEpochLen l (v : (server.StartChain.t)) PrevEpochLen' :
  AccessStrict
    (l.[(server.StartChain.t), "PrevEpochLen"] ↦ (v.(server.StartChain.PrevEpochLen')))
    (l.[(server.StartChain.t), "PrevEpochLen"] ↦ PrevEpochLen')
    (l ↦ v) (l ↦ (v <|(server.StartChain.PrevEpochLen') := PrevEpochLen'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance StartChain_access_load_PrevLink l (v : (server.StartChain.t)) dq :
  AccessStrict
    (l.[(server.StartChain.t), "PrevLink"] ↦{dq} (v.(server.StartChain.PrevLink')))
    (l.[(server.StartChain.t), "PrevLink"] ↦{dq} (v.(server.StartChain.PrevLink')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance StartChain_access_store_PrevLink l (v : (server.StartChain.t)) PrevLink' :
  AccessStrict
    (l.[(server.StartChain.t), "PrevLink"] ↦ (v.(server.StartChain.PrevLink')))
    (l.[(server.StartChain.t), "PrevLink"] ↦ PrevLink')
    (l ↦ v) (l ↦ (v <|(server.StartChain.PrevLink') := PrevLink'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance StartChain_access_load_ChainProof l (v : (server.StartChain.t)) dq :
  AccessStrict
    (l.[(server.StartChain.t), "ChainProof"] ↦{dq} (v.(server.StartChain.ChainProof')))
    (l.[(server.StartChain.t), "ChainProof"] ↦{dq} (v.(server.StartChain.ChainProof')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance StartChain_access_store_ChainProof l (v : (server.StartChain.t)) ChainProof' :
  AccessStrict
    (l.[(server.StartChain.t), "ChainProof"] ↦ (v.(server.StartChain.ChainProof')))
    (l.[(server.StartChain.t), "ChainProof"] ↦ ChainProof')
    (l ↦ v) (l ↦ (v <|(server.StartChain.ChainProof') := ChainProof'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance StartChain_access_load_LinkSig l (v : (server.StartChain.t)) dq :
  AccessStrict
    (l.[(server.StartChain.t), "LinkSig"] ↦{dq} (v.(server.StartChain.LinkSig')))
    (l.[(server.StartChain.t), "LinkSig"] ↦{dq} (v.(server.StartChain.LinkSig')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance StartChain_access_store_LinkSig l (v : (server.StartChain.t)) LinkSig' :
  AccessStrict
    (l.[(server.StartChain.t), "LinkSig"] ↦ (v.(server.StartChain.LinkSig')))
    (l.[(server.StartChain.t), "LinkSig"] ↦ LinkSig')
    (l ↦ v) (l ↦ (v <|(server.StartChain.LinkSig') := LinkSig'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End StartChain.

Module StartVrf.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : server.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance StartVrf_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (server.StartVrf.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "VrfPk" ∷ l.[(server.StartVrf.t), "VrfPk"] ↦{dq} v.(server.StartVrf.VrfPk') ∗
      "VrfSig" ∷ l.[(server.StartVrf.t), "VrfSig"] ↦{dq} v.(server.StartVrf.VrfSig') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance StartVrf_into_val_typed
   :
  IntoValTypedUnderlying (server.StartVrf.t) (server.StartVrfⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance StartVrf_access_load_VrfPk l (v : (server.StartVrf.t)) dq :
  AccessStrict
    (l.[(server.StartVrf.t), "VrfPk"] ↦{dq} (v.(server.StartVrf.VrfPk')))
    (l.[(server.StartVrf.t), "VrfPk"] ↦{dq} (v.(server.StartVrf.VrfPk')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance StartVrf_access_store_VrfPk l (v : (server.StartVrf.t)) VrfPk' :
  AccessStrict
    (l.[(server.StartVrf.t), "VrfPk"] ↦ (v.(server.StartVrf.VrfPk')))
    (l.[(server.StartVrf.t), "VrfPk"] ↦ VrfPk')
    (l ↦ v) (l ↦ (v <|(server.StartVrf.VrfPk') := VrfPk'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance StartVrf_access_load_VrfSig l (v : (server.StartVrf.t)) dq :
  AccessStrict
    (l.[(server.StartVrf.t), "VrfSig"] ↦{dq} (v.(server.StartVrf.VrfSig')))
    (l.[(server.StartVrf.t), "VrfSig"] ↦{dq} (v.(server.StartVrf.VrfSig')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance StartVrf_access_store_VrfSig l (v : (server.StartVrf.t)) VrfSig' :
  AccessStrict
    (l.[(server.StartVrf.t), "VrfSig"] ↦ (v.(server.StartVrf.VrfSig')))
    (l.[(server.StartVrf.t), "VrfSig"] ↦ VrfSig')
    (l ↦ v) (l ↦ (v <|(server.StartVrf.VrfSig') := VrfSig'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End StartVrf.

Module StartReply.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : server.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance StartReply_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (server.StartReply.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "Chain" ∷ l.[(server.StartReply.t), "Chain"] ↦{dq} v.(server.StartReply.Chain') ∗
      "Vrf" ∷ l.[(server.StartReply.t), "Vrf"] ↦{dq} v.(server.StartReply.Vrf') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance StartReply_into_val_typed
   :
  IntoValTypedUnderlying (server.StartReply.t) (server.StartReplyⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance StartReply_access_load_Chain l (v : (server.StartReply.t)) dq :
  AccessStrict
    (l.[(server.StartReply.t), "Chain"] ↦{dq} (v.(server.StartReply.Chain')))
    (l.[(server.StartReply.t), "Chain"] ↦{dq} (v.(server.StartReply.Chain')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance StartReply_access_store_Chain l (v : (server.StartReply.t)) Chain' :
  AccessStrict
    (l.[(server.StartReply.t), "Chain"] ↦ (v.(server.StartReply.Chain')))
    (l.[(server.StartReply.t), "Chain"] ↦ Chain')
    (l ↦ v) (l ↦ (v <|(server.StartReply.Chain') := Chain'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance StartReply_access_load_Vrf l (v : (server.StartReply.t)) dq :
  AccessStrict
    (l.[(server.StartReply.t), "Vrf"] ↦{dq} (v.(server.StartReply.Vrf')))
    (l.[(server.StartReply.t), "Vrf"] ↦{dq} (v.(server.StartReply.Vrf')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance StartReply_access_store_Vrf l (v : (server.StartReply.t)) Vrf' :
  AccessStrict
    (l.[(server.StartReply.t), "Vrf"] ↦ (v.(server.StartReply.Vrf')))
    (l.[(server.StartReply.t), "Vrf"] ↦ Vrf')
    (l ↦ v) (l ↦ (v <|(server.StartReply.Vrf') := Vrf'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End StartReply.

Module PutArg.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : server.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance PutArg_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (server.PutArg.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "Uid" ∷ l.[(server.PutArg.t), "Uid"] ↦{dq} v.(server.PutArg.Uid') ∗
      "Pk" ∷ l.[(server.PutArg.t), "Pk"] ↦{dq} v.(server.PutArg.Pk') ∗
      "Ver" ∷ l.[(server.PutArg.t), "Ver"] ↦{dq} v.(server.PutArg.Ver') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance PutArg_into_val_typed
   :
  IntoValTypedUnderlying (server.PutArg.t) (server.PutArgⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance PutArg_access_load_Uid l (v : (server.PutArg.t)) dq :
  AccessStrict
    (l.[(server.PutArg.t), "Uid"] ↦{dq} (v.(server.PutArg.Uid')))
    (l.[(server.PutArg.t), "Uid"] ↦{dq} (v.(server.PutArg.Uid')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance PutArg_access_store_Uid l (v : (server.PutArg.t)) Uid' :
  AccessStrict
    (l.[(server.PutArg.t), "Uid"] ↦ (v.(server.PutArg.Uid')))
    (l.[(server.PutArg.t), "Uid"] ↦ Uid')
    (l ↦ v) (l ↦ (v <|(server.PutArg.Uid') := Uid'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance PutArg_access_load_Pk l (v : (server.PutArg.t)) dq :
  AccessStrict
    (l.[(server.PutArg.t), "Pk"] ↦{dq} (v.(server.PutArg.Pk')))
    (l.[(server.PutArg.t), "Pk"] ↦{dq} (v.(server.PutArg.Pk')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance PutArg_access_store_Pk l (v : (server.PutArg.t)) Pk' :
  AccessStrict
    (l.[(server.PutArg.t), "Pk"] ↦ (v.(server.PutArg.Pk')))
    (l.[(server.PutArg.t), "Pk"] ↦ Pk')
    (l ↦ v) (l ↦ (v <|(server.PutArg.Pk') := Pk'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance PutArg_access_load_Ver l (v : (server.PutArg.t)) dq :
  AccessStrict
    (l.[(server.PutArg.t), "Ver"] ↦{dq} (v.(server.PutArg.Ver')))
    (l.[(server.PutArg.t), "Ver"] ↦{dq} (v.(server.PutArg.Ver')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance PutArg_access_store_Ver l (v : (server.PutArg.t)) Ver' :
  AccessStrict
    (l.[(server.PutArg.t), "Ver"] ↦ (v.(server.PutArg.Ver')))
    (l.[(server.PutArg.t), "Ver"] ↦ Ver')
    (l ↦ v) (l ↦ (v <|(server.PutArg.Ver') := Ver'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End PutArg.

Module HistoryArg.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : server.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance HistoryArg_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (server.HistoryArg.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "Uid" ∷ l.[(server.HistoryArg.t), "Uid"] ↦{dq} v.(server.HistoryArg.Uid') ∗
      "PrevEpoch" ∷ l.[(server.HistoryArg.t), "PrevEpoch"] ↦{dq} v.(server.HistoryArg.PrevEpoch') ∗
      "PrevVerLen" ∷ l.[(server.HistoryArg.t), "PrevVerLen"] ↦{dq} v.(server.HistoryArg.PrevVerLen') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance HistoryArg_into_val_typed
   :
  IntoValTypedUnderlying (server.HistoryArg.t) (server.HistoryArgⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance HistoryArg_access_load_Uid l (v : (server.HistoryArg.t)) dq :
  AccessStrict
    (l.[(server.HistoryArg.t), "Uid"] ↦{dq} (v.(server.HistoryArg.Uid')))
    (l.[(server.HistoryArg.t), "Uid"] ↦{dq} (v.(server.HistoryArg.Uid')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance HistoryArg_access_store_Uid l (v : (server.HistoryArg.t)) Uid' :
  AccessStrict
    (l.[(server.HistoryArg.t), "Uid"] ↦ (v.(server.HistoryArg.Uid')))
    (l.[(server.HistoryArg.t), "Uid"] ↦ Uid')
    (l ↦ v) (l ↦ (v <|(server.HistoryArg.Uid') := Uid'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance HistoryArg_access_load_PrevEpoch l (v : (server.HistoryArg.t)) dq :
  AccessStrict
    (l.[(server.HistoryArg.t), "PrevEpoch"] ↦{dq} (v.(server.HistoryArg.PrevEpoch')))
    (l.[(server.HistoryArg.t), "PrevEpoch"] ↦{dq} (v.(server.HistoryArg.PrevEpoch')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance HistoryArg_access_store_PrevEpoch l (v : (server.HistoryArg.t)) PrevEpoch' :
  AccessStrict
    (l.[(server.HistoryArg.t), "PrevEpoch"] ↦ (v.(server.HistoryArg.PrevEpoch')))
    (l.[(server.HistoryArg.t), "PrevEpoch"] ↦ PrevEpoch')
    (l ↦ v) (l ↦ (v <|(server.HistoryArg.PrevEpoch') := PrevEpoch'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance HistoryArg_access_load_PrevVerLen l (v : (server.HistoryArg.t)) dq :
  AccessStrict
    (l.[(server.HistoryArg.t), "PrevVerLen"] ↦{dq} (v.(server.HistoryArg.PrevVerLen')))
    (l.[(server.HistoryArg.t), "PrevVerLen"] ↦{dq} (v.(server.HistoryArg.PrevVerLen')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance HistoryArg_access_store_PrevVerLen l (v : (server.HistoryArg.t)) PrevVerLen' :
  AccessStrict
    (l.[(server.HistoryArg.t), "PrevVerLen"] ↦ (v.(server.HistoryArg.PrevVerLen')))
    (l.[(server.HistoryArg.t), "PrevVerLen"] ↦ PrevVerLen')
    (l ↦ v) (l ↦ (v <|(server.HistoryArg.PrevVerLen') := PrevVerLen'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End HistoryArg.

Module HistoryReply.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : server.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance HistoryReply_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (server.HistoryReply.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "ChainProof" ∷ l.[(server.HistoryReply.t), "ChainProof"] ↦{dq} v.(server.HistoryReply.ChainProof') ∗
      "LinkSig" ∷ l.[(server.HistoryReply.t), "LinkSig"] ↦{dq} v.(server.HistoryReply.LinkSig') ∗
      "Hist" ∷ l.[(server.HistoryReply.t), "Hist"] ↦{dq} v.(server.HistoryReply.Hist') ∗
      "Bound" ∷ l.[(server.HistoryReply.t), "Bound"] ↦{dq} v.(server.HistoryReply.Bound') ∗
      "Err" ∷ l.[(server.HistoryReply.t), "Err"] ↦{dq} v.(server.HistoryReply.Err') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance HistoryReply_into_val_typed
   :
  IntoValTypedUnderlying (server.HistoryReply.t) (server.HistoryReplyⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance HistoryReply_access_load_ChainProof l (v : (server.HistoryReply.t)) dq :
  AccessStrict
    (l.[(server.HistoryReply.t), "ChainProof"] ↦{dq} (v.(server.HistoryReply.ChainProof')))
    (l.[(server.HistoryReply.t), "ChainProof"] ↦{dq} (v.(server.HistoryReply.ChainProof')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance HistoryReply_access_store_ChainProof l (v : (server.HistoryReply.t)) ChainProof' :
  AccessStrict
    (l.[(server.HistoryReply.t), "ChainProof"] ↦ (v.(server.HistoryReply.ChainProof')))
    (l.[(server.HistoryReply.t), "ChainProof"] ↦ ChainProof')
    (l ↦ v) (l ↦ (v <|(server.HistoryReply.ChainProof') := ChainProof'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance HistoryReply_access_load_LinkSig l (v : (server.HistoryReply.t)) dq :
  AccessStrict
    (l.[(server.HistoryReply.t), "LinkSig"] ↦{dq} (v.(server.HistoryReply.LinkSig')))
    (l.[(server.HistoryReply.t), "LinkSig"] ↦{dq} (v.(server.HistoryReply.LinkSig')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance HistoryReply_access_store_LinkSig l (v : (server.HistoryReply.t)) LinkSig' :
  AccessStrict
    (l.[(server.HistoryReply.t), "LinkSig"] ↦ (v.(server.HistoryReply.LinkSig')))
    (l.[(server.HistoryReply.t), "LinkSig"] ↦ LinkSig')
    (l ↦ v) (l ↦ (v <|(server.HistoryReply.LinkSig') := LinkSig'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance HistoryReply_access_load_Hist l (v : (server.HistoryReply.t)) dq :
  AccessStrict
    (l.[(server.HistoryReply.t), "Hist"] ↦{dq} (v.(server.HistoryReply.Hist')))
    (l.[(server.HistoryReply.t), "Hist"] ↦{dq} (v.(server.HistoryReply.Hist')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance HistoryReply_access_store_Hist l (v : (server.HistoryReply.t)) Hist' :
  AccessStrict
    (l.[(server.HistoryReply.t), "Hist"] ↦ (v.(server.HistoryReply.Hist')))
    (l.[(server.HistoryReply.t), "Hist"] ↦ Hist')
    (l ↦ v) (l ↦ (v <|(server.HistoryReply.Hist') := Hist'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance HistoryReply_access_load_Bound l (v : (server.HistoryReply.t)) dq :
  AccessStrict
    (l.[(server.HistoryReply.t), "Bound"] ↦{dq} (v.(server.HistoryReply.Bound')))
    (l.[(server.HistoryReply.t), "Bound"] ↦{dq} (v.(server.HistoryReply.Bound')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance HistoryReply_access_store_Bound l (v : (server.HistoryReply.t)) Bound' :
  AccessStrict
    (l.[(server.HistoryReply.t), "Bound"] ↦ (v.(server.HistoryReply.Bound')))
    (l.[(server.HistoryReply.t), "Bound"] ↦ Bound')
    (l ↦ v) (l ↦ (v <|(server.HistoryReply.Bound') := Bound'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance HistoryReply_access_load_Err l (v : (server.HistoryReply.t)) dq :
  AccessStrict
    (l.[(server.HistoryReply.t), "Err"] ↦{dq} (v.(server.HistoryReply.Err')))
    (l.[(server.HistoryReply.t), "Err"] ↦{dq} (v.(server.HistoryReply.Err')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance HistoryReply_access_store_Err l (v : (server.HistoryReply.t)) Err' :
  AccessStrict
    (l.[(server.HistoryReply.t), "Err"] ↦ (v.(server.HistoryReply.Err')))
    (l.[(server.HistoryReply.t), "Err"] ↦ Err')
    (l ↦ v) (l ↦ (v <|(server.HistoryReply.Err') := Err'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End HistoryReply.

Module AuditArg.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : server.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance AuditArg_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (server.AuditArg.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "PrevEpoch" ∷ l.[(server.AuditArg.t), "PrevEpoch"] ↦{dq} v.(server.AuditArg.PrevEpoch') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance AuditArg_into_val_typed
   :
  IntoValTypedUnderlying (server.AuditArg.t) (server.AuditArgⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance AuditArg_access_load_PrevEpoch l (v : (server.AuditArg.t)) dq :
  AccessStrict
    (l.[(server.AuditArg.t), "PrevEpoch"] ↦{dq} (v.(server.AuditArg.PrevEpoch')))
    (l.[(server.AuditArg.t), "PrevEpoch"] ↦{dq} (v.(server.AuditArg.PrevEpoch')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance AuditArg_access_store_PrevEpoch l (v : (server.AuditArg.t)) PrevEpoch' :
  AccessStrict
    (l.[(server.AuditArg.t), "PrevEpoch"] ↦ (v.(server.AuditArg.PrevEpoch')))
    (l.[(server.AuditArg.t), "PrevEpoch"] ↦ PrevEpoch')
    (l ↦ v) (l ↦ (v <|(server.AuditArg.PrevEpoch') := PrevEpoch'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End AuditArg.

Module AuditReply.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : server.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance AuditReply_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (server.AuditReply.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "P" ∷ l.[(server.AuditReply.t), "P"] ↦{dq} v.(server.AuditReply.P') ∗
      "Err" ∷ l.[(server.AuditReply.t), "Err"] ↦{dq} v.(server.AuditReply.Err') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance AuditReply_into_val_typed
   :
  IntoValTypedUnderlying (server.AuditReply.t) (server.AuditReplyⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance AuditReply_access_load_P l (v : (server.AuditReply.t)) dq :
  AccessStrict
    (l.[(server.AuditReply.t), "P"] ↦{dq} (v.(server.AuditReply.P')))
    (l.[(server.AuditReply.t), "P"] ↦{dq} (v.(server.AuditReply.P')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance AuditReply_access_store_P l (v : (server.AuditReply.t)) P' :
  AccessStrict
    (l.[(server.AuditReply.t), "P"] ↦ (v.(server.AuditReply.P')))
    (l.[(server.AuditReply.t), "P"] ↦ P')
    (l ↦ v) (l ↦ (v <|(server.AuditReply.P') := P'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance AuditReply_access_load_Err l (v : (server.AuditReply.t)) dq :
  AccessStrict
    (l.[(server.AuditReply.t), "Err"] ↦{dq} (v.(server.AuditReply.Err')))
    (l.[(server.AuditReply.t), "Err"] ↦{dq} (v.(server.AuditReply.Err')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance AuditReply_access_store_Err l (v : (server.AuditReply.t)) Err' :
  AccessStrict
    (l.[(server.AuditReply.t), "Err"] ↦ (v.(server.AuditReply.Err')))
    (l.[(server.AuditReply.t), "Err"] ↦ Err')
    (l ↦ v) (l ↦ (v <|(server.AuditReply.Err') := Err'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End AuditReply.

Module Server.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : server.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance Server_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (server.Server.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "mu" ∷ l.[(server.Server.t), "mu"] ↦{dq} v.(server.Server.mu') ∗
      "secs" ∷ l.[(server.Server.t), "secs"] ↦{dq} v.(server.Server.secs') ∗
      "keys" ∷ l.[(server.Server.t), "keys"] ↦{dq} v.(server.Server.keys') ∗
      "hist" ∷ l.[(server.Server.t), "hist"] ↦{dq} v.(server.Server.hist') ∗
      "workQ" ∷ l.[(server.Server.t), "workQ"] ↦{dq} v.(server.Server.workQ') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance Server_into_val_typed
   :
  IntoValTypedUnderlying (server.Server.t) (server.Serverⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance Server_access_load_mu l (v : (server.Server.t)) dq :
  AccessStrict
    (l.[(server.Server.t), "mu"] ↦{dq} (v.(server.Server.mu')))
    (l.[(server.Server.t), "mu"] ↦{dq} (v.(server.Server.mu')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Server_access_store_mu l (v : (server.Server.t)) mu' :
  AccessStrict
    (l.[(server.Server.t), "mu"] ↦ (v.(server.Server.mu')))
    (l.[(server.Server.t), "mu"] ↦ mu')
    (l ↦ v) (l ↦ (v <|(server.Server.mu') := mu'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Server_access_load_secs l (v : (server.Server.t)) dq :
  AccessStrict
    (l.[(server.Server.t), "secs"] ↦{dq} (v.(server.Server.secs')))
    (l.[(server.Server.t), "secs"] ↦{dq} (v.(server.Server.secs')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Server_access_store_secs l (v : (server.Server.t)) secs' :
  AccessStrict
    (l.[(server.Server.t), "secs"] ↦ (v.(server.Server.secs')))
    (l.[(server.Server.t), "secs"] ↦ secs')
    (l ↦ v) (l ↦ (v <|(server.Server.secs') := secs'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Server_access_load_keys l (v : (server.Server.t)) dq :
  AccessStrict
    (l.[(server.Server.t), "keys"] ↦{dq} (v.(server.Server.keys')))
    (l.[(server.Server.t), "keys"] ↦{dq} (v.(server.Server.keys')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Server_access_store_keys l (v : (server.Server.t)) keys' :
  AccessStrict
    (l.[(server.Server.t), "keys"] ↦ (v.(server.Server.keys')))
    (l.[(server.Server.t), "keys"] ↦ keys')
    (l ↦ v) (l ↦ (v <|(server.Server.keys') := keys'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Server_access_load_hist l (v : (server.Server.t)) dq :
  AccessStrict
    (l.[(server.Server.t), "hist"] ↦{dq} (v.(server.Server.hist')))
    (l.[(server.Server.t), "hist"] ↦{dq} (v.(server.Server.hist')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Server_access_store_hist l (v : (server.Server.t)) hist' :
  AccessStrict
    (l.[(server.Server.t), "hist"] ↦ (v.(server.Server.hist')))
    (l.[(server.Server.t), "hist"] ↦ hist')
    (l ↦ v) (l ↦ (v <|(server.Server.hist') := hist'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Server_access_load_workQ l (v : (server.Server.t)) dq :
  AccessStrict
    (l.[(server.Server.t), "workQ"] ↦{dq} (v.(server.Server.workQ')))
    (l.[(server.Server.t), "workQ"] ↦{dq} (v.(server.Server.workQ')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Server_access_store_workQ l (v : (server.Server.t)) workQ' :
  AccessStrict
    (l.[(server.Server.t), "workQ"] ↦ (v.(server.Server.workQ')))
    (l.[(server.Server.t), "workQ"] ↦ workQ')
    (l ↦ v) (l ↦ (v <|(server.Server.workQ') := workQ'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End Server.

Module secrets.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : server.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance secrets_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (server.secrets.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "sig" ∷ l.[(server.secrets.t), "sig"] ↦{dq} v.(server.secrets.sig') ∗
      "vrf" ∷ l.[(server.secrets.t), "vrf"] ↦{dq} v.(server.secrets.vrf') ∗
      "commit" ∷ l.[(server.secrets.t), "commit"] ↦{dq} v.(server.secrets.commit') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance secrets_into_val_typed
   :
  IntoValTypedUnderlying (server.secrets.t) (server.secretsⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance secrets_access_load_sig l (v : (server.secrets.t)) dq :
  AccessStrict
    (l.[(server.secrets.t), "sig"] ↦{dq} (v.(server.secrets.sig')))
    (l.[(server.secrets.t), "sig"] ↦{dq} (v.(server.secrets.sig')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance secrets_access_store_sig l (v : (server.secrets.t)) sig' :
  AccessStrict
    (l.[(server.secrets.t), "sig"] ↦ (v.(server.secrets.sig')))
    (l.[(server.secrets.t), "sig"] ↦ sig')
    (l ↦ v) (l ↦ (v <|(server.secrets.sig') := sig'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance secrets_access_load_vrf l (v : (server.secrets.t)) dq :
  AccessStrict
    (l.[(server.secrets.t), "vrf"] ↦{dq} (v.(server.secrets.vrf')))
    (l.[(server.secrets.t), "vrf"] ↦{dq} (v.(server.secrets.vrf')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance secrets_access_store_vrf l (v : (server.secrets.t)) vrf' :
  AccessStrict
    (l.[(server.secrets.t), "vrf"] ↦ (v.(server.secrets.vrf')))
    (l.[(server.secrets.t), "vrf"] ↦ vrf')
    (l ↦ v) (l ↦ (v <|(server.secrets.vrf') := vrf'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance secrets_access_load_commit l (v : (server.secrets.t)) dq :
  AccessStrict
    (l.[(server.secrets.t), "commit"] ↦{dq} (v.(server.secrets.commit')))
    (l.[(server.secrets.t), "commit"] ↦{dq} (v.(server.secrets.commit')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance secrets_access_store_commit l (v : (server.secrets.t)) commit' :
  AccessStrict
    (l.[(server.secrets.t), "commit"] ↦ (v.(server.secrets.commit')))
    (l.[(server.secrets.t), "commit"] ↦ commit')
    (l ↦ v) (l ↦ (v <|(server.secrets.commit') := commit'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End secrets.

Module keyStore.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : server.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance keyStore_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (server.keyStore.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "hidden" ∷ l.[(server.keyStore.t), "hidden"] ↦{dq} v.(server.keyStore.hidden') ∗
      "plain" ∷ l.[(server.keyStore.t), "plain"] ↦{dq} v.(server.keyStore.plain') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance keyStore_into_val_typed
   :
  IntoValTypedUnderlying (server.keyStore.t) (server.keyStoreⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance keyStore_access_load_hidden l (v : (server.keyStore.t)) dq :
  AccessStrict
    (l.[(server.keyStore.t), "hidden"] ↦{dq} (v.(server.keyStore.hidden')))
    (l.[(server.keyStore.t), "hidden"] ↦{dq} (v.(server.keyStore.hidden')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance keyStore_access_store_hidden l (v : (server.keyStore.t)) hidden' :
  AccessStrict
    (l.[(server.keyStore.t), "hidden"] ↦ (v.(server.keyStore.hidden')))
    (l.[(server.keyStore.t), "hidden"] ↦ hidden')
    (l ↦ v) (l ↦ (v <|(server.keyStore.hidden') := hidden'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance keyStore_access_load_plain l (v : (server.keyStore.t)) dq :
  AccessStrict
    (l.[(server.keyStore.t), "plain"] ↦{dq} (v.(server.keyStore.plain')))
    (l.[(server.keyStore.t), "plain"] ↦{dq} (v.(server.keyStore.plain')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance keyStore_access_store_plain l (v : (server.keyStore.t)) plain' :
  AccessStrict
    (l.[(server.keyStore.t), "plain"] ↦ (v.(server.keyStore.plain')))
    (l.[(server.keyStore.t), "plain"] ↦ plain')
    (l ↦ v) (l ↦ (v <|(server.keyStore.plain') := plain'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End keyStore.

Module history.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : server.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance history_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (server.history.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "chain" ∷ l.[(server.history.t), "chain"] ↦{dq} v.(server.history.chain') ∗
      "audits" ∷ l.[(server.history.t), "audits"] ↦{dq} v.(server.history.audits') ∗
      "vrfPkSig" ∷ l.[(server.history.t), "vrfPkSig"] ↦{dq} v.(server.history.vrfPkSig') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance history_into_val_typed
   :
  IntoValTypedUnderlying (server.history.t) (server.historyⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance history_access_load_chain l (v : (server.history.t)) dq :
  AccessStrict
    (l.[(server.history.t), "chain"] ↦{dq} (v.(server.history.chain')))
    (l.[(server.history.t), "chain"] ↦{dq} (v.(server.history.chain')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance history_access_store_chain l (v : (server.history.t)) chain' :
  AccessStrict
    (l.[(server.history.t), "chain"] ↦ (v.(server.history.chain')))
    (l.[(server.history.t), "chain"] ↦ chain')
    (l ↦ v) (l ↦ (v <|(server.history.chain') := chain'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance history_access_load_audits l (v : (server.history.t)) dq :
  AccessStrict
    (l.[(server.history.t), "audits"] ↦{dq} (v.(server.history.audits')))
    (l.[(server.history.t), "audits"] ↦{dq} (v.(server.history.audits')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance history_access_store_audits l (v : (server.history.t)) audits' :
  AccessStrict
    (l.[(server.history.t), "audits"] ↦ (v.(server.history.audits')))
    (l.[(server.history.t), "audits"] ↦ audits')
    (l ↦ v) (l ↦ (v <|(server.history.audits') := audits'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance history_access_load_vrfPkSig l (v : (server.history.t)) dq :
  AccessStrict
    (l.[(server.history.t), "vrfPkSig"] ↦{dq} (v.(server.history.vrfPkSig')))
    (l.[(server.history.t), "vrfPkSig"] ↦{dq} (v.(server.history.vrfPkSig')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance history_access_store_vrfPkSig l (v : (server.history.t)) vrfPkSig' :
  AccessStrict
    (l.[(server.history.t), "vrfPkSig"] ↦ (v.(server.history.vrfPkSig')))
    (l.[(server.history.t), "vrfPkSig"] ↦ vrfPkSig')
    (l ↦ v) (l ↦ (v <|(server.history.vrfPkSig') := vrfPkSig'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End history.

Module Work.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : server.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance Work_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (server.Work.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "Uid" ∷ l.[(server.Work.t), "Uid"] ↦{dq} v.(server.Work.Uid') ∗
      "Pk" ∷ l.[(server.Work.t), "Pk"] ↦{dq} v.(server.Work.Pk') ∗
      "Ver" ∷ l.[(server.Work.t), "Ver"] ↦{dq} v.(server.Work.Ver') ∗
      "Err" ∷ l.[(server.Work.t), "Err"] ↦{dq} v.(server.Work.Err') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance Work_into_val_typed
   :
  IntoValTypedUnderlying (server.Work.t) (server.Workⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance Work_access_load_Uid l (v : (server.Work.t)) dq :
  AccessStrict
    (l.[(server.Work.t), "Uid"] ↦{dq} (v.(server.Work.Uid')))
    (l.[(server.Work.t), "Uid"] ↦{dq} (v.(server.Work.Uid')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Work_access_store_Uid l (v : (server.Work.t)) Uid' :
  AccessStrict
    (l.[(server.Work.t), "Uid"] ↦ (v.(server.Work.Uid')))
    (l.[(server.Work.t), "Uid"] ↦ Uid')
    (l ↦ v) (l ↦ (v <|(server.Work.Uid') := Uid'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Work_access_load_Pk l (v : (server.Work.t)) dq :
  AccessStrict
    (l.[(server.Work.t), "Pk"] ↦{dq} (v.(server.Work.Pk')))
    (l.[(server.Work.t), "Pk"] ↦{dq} (v.(server.Work.Pk')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Work_access_store_Pk l (v : (server.Work.t)) Pk' :
  AccessStrict
    (l.[(server.Work.t), "Pk"] ↦ (v.(server.Work.Pk')))
    (l.[(server.Work.t), "Pk"] ↦ Pk')
    (l ↦ v) (l ↦ (v <|(server.Work.Pk') := Pk'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Work_access_load_Ver l (v : (server.Work.t)) dq :
  AccessStrict
    (l.[(server.Work.t), "Ver"] ↦{dq} (v.(server.Work.Ver')))
    (l.[(server.Work.t), "Ver"] ↦{dq} (v.(server.Work.Ver')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Work_access_store_Ver l (v : (server.Work.t)) Ver' :
  AccessStrict
    (l.[(server.Work.t), "Ver"] ↦ (v.(server.Work.Ver')))
    (l.[(server.Work.t), "Ver"] ↦ Ver')
    (l ↦ v) (l ↦ (v <|(server.Work.Ver') := Ver'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Work_access_load_Err l (v : (server.Work.t)) dq :
  AccessStrict
    (l.[(server.Work.t), "Err"] ↦{dq} (v.(server.Work.Err')))
    (l.[(server.Work.t), "Err"] ↦{dq} (v.(server.Work.Err')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Work_access_store_Err l (v : (server.Work.t)) Err' :
  AccessStrict
    (l.[(server.Work.t), "Err"] ↦ (v.(server.Work.Err')))
    (l.[(server.Work.t), "Err"] ↦ Err')
    (l ↦ v) (l ↦ (v <|(server.Work.Err') := Err'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End Work.

Module mapEntry.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : server.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance mapEntry_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (server.mapEntry.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "label" ∷ l.[(server.mapEntry.t), "label"] ↦{dq} v.(server.mapEntry.label') ∗
      "val" ∷ l.[(server.mapEntry.t), "val"] ↦{dq} v.(server.mapEntry.val') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance mapEntry_into_val_typed
   :
  IntoValTypedUnderlying (server.mapEntry.t) (server.mapEntryⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance mapEntry_access_load_label l (v : (server.mapEntry.t)) dq :
  AccessStrict
    (l.[(server.mapEntry.t), "label"] ↦{dq} (v.(server.mapEntry.label')))
    (l.[(server.mapEntry.t), "label"] ↦{dq} (v.(server.mapEntry.label')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance mapEntry_access_store_label l (v : (server.mapEntry.t)) label' :
  AccessStrict
    (l.[(server.mapEntry.t), "label"] ↦ (v.(server.mapEntry.label')))
    (l.[(server.mapEntry.t), "label"] ↦ label')
    (l ↦ v) (l ↦ (v <|(server.mapEntry.label') := label'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance mapEntry_access_load_val l (v : (server.mapEntry.t)) dq :
  AccessStrict
    (l.[(server.mapEntry.t), "val"] ↦{dq} (v.(server.mapEntry.val')))
    (l.[(server.mapEntry.t), "val"] ↦{dq} (v.(server.mapEntry.val')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance mapEntry_access_store_val l (v : (server.mapEntry.t)) val' :
  AccessStrict
    (l.[(server.mapEntry.t), "val"] ↦ (v.(server.mapEntry.val')))
    (l.[(server.mapEntry.t), "val"] ↦ val')
    (l ↦ v) (l ↦ (v <|(server.mapEntry.val') := val'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End mapEntry.

End server.
