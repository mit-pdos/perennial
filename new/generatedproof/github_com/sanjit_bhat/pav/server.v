(* autogenerated by goose proofgen; do not modify *)
Require Export New.proof.proof_prelude.
Require Export New.generatedproof.github_com.sanjit_bhat.pav.advrpc.
Require Export New.generatedproof.github_com.sanjit_bhat.pav.ktcore.
Require Export New.generatedproof.github_com.sanjit_bhat.pav.safemarshal.
Require Export New.generatedproof.github_com.tchajed.marshal.
Require Export New.generatedproof.sync.
Require Export New.generatedproof.github_com.goose_lang.std.
Require Export New.generatedproof.github_com.sanjit_bhat.pav.cryptoffi.
Require Export New.generatedproof.github_com.sanjit_bhat.pav.hashchain.
Require Export New.generatedproof.github_com.sanjit_bhat.pav.merkle.
Require Export New.golang.theory.

Require Export New.code.github_com.sanjit_bhat.pav.server.

Set Default Proof Using "Type".

Module server.

(* type server.StartReply *)
Module StartReply.
Section def.
Context `{ffi_syntax}.
Record t := mk {
  StartEpochLen' : w64;
  StartLink' : slice.t;
  ChainProof' : slice.t;
  LinkSig' : slice.t;
  VrfPk' : slice.t;
  VrfSig' : slice.t;
}.
End def.
End StartReply.

Section instances.
Context `{ffi_syntax}.

Global Instance settable_StartReply : Settable StartReply.t :=
  settable! StartReply.mk < StartReply.StartEpochLen'; StartReply.StartLink'; StartReply.ChainProof'; StartReply.LinkSig'; StartReply.VrfPk'; StartReply.VrfSig' >.
Global Instance into_val_StartReply : IntoVal StartReply.t :=
  {| to_val_def v :=
    struct.val_aux server.StartReply [
    "StartEpochLen" ::= #(StartReply.StartEpochLen' v);
    "StartLink" ::= #(StartReply.StartLink' v);
    "ChainProof" ::= #(StartReply.ChainProof' v);
    "LinkSig" ::= #(StartReply.LinkSig' v);
    "VrfPk" ::= #(StartReply.VrfPk' v);
    "VrfSig" ::= #(StartReply.VrfSig' v)
    ]%struct
  |}.

Global Program Instance into_val_typed_StartReply : IntoValTyped StartReply.t server.StartReply :=
{|
  default_val := StartReply.mk (default_val _) (default_val _) (default_val _) (default_val _) (default_val _) (default_val _);
|}.
Next Obligation. solve_to_val_type. Qed.
Next Obligation. solve_zero_val. Qed.
Next Obligation. solve_to_val_inj. Qed.
Final Obligation. solve_decision. Qed.

Global Instance into_val_struct_field_StartReply_StartEpochLen : IntoValStructField "StartEpochLen" server.StartReply StartReply.StartEpochLen'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_StartReply_StartLink : IntoValStructField "StartLink" server.StartReply StartReply.StartLink'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_StartReply_ChainProof : IntoValStructField "ChainProof" server.StartReply StartReply.ChainProof'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_StartReply_LinkSig : IntoValStructField "LinkSig" server.StartReply StartReply.LinkSig'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_StartReply_VrfPk : IntoValStructField "VrfPk" server.StartReply StartReply.VrfPk'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_StartReply_VrfSig : IntoValStructField "VrfSig" server.StartReply StartReply.VrfSig'.
Proof. solve_into_val_struct_field. Qed.


Context `{!ffi_model, !ffi_semantics _ _, !ffi_interp _, !heapGS Σ}.
Global Instance wp_struct_make_StartReply StartEpochLen' StartLink' ChainProof' LinkSig' VrfPk' VrfSig':
  PureWp True
    (struct.make #server.StartReply (alist_val [
      "StartEpochLen" ::= #StartEpochLen';
      "StartLink" ::= #StartLink';
      "ChainProof" ::= #ChainProof';
      "LinkSig" ::= #LinkSig';
      "VrfPk" ::= #VrfPk';
      "VrfSig" ::= #VrfSig'
    ]))%struct
    #(StartReply.mk StartEpochLen' StartLink' ChainProof' LinkSig' VrfPk' VrfSig').
Proof. solve_struct_make_pure_wp. Qed.


Global Instance StartReply_struct_fields_split dq l (v : StartReply.t) :
  StructFieldsSplit dq l v (
    "HStartEpochLen" ∷ l ↦s[server.StartReply :: "StartEpochLen"]{dq} v.(StartReply.StartEpochLen') ∗
    "HStartLink" ∷ l ↦s[server.StartReply :: "StartLink"]{dq} v.(StartReply.StartLink') ∗
    "HChainProof" ∷ l ↦s[server.StartReply :: "ChainProof"]{dq} v.(StartReply.ChainProof') ∗
    "HLinkSig" ∷ l ↦s[server.StartReply :: "LinkSig"]{dq} v.(StartReply.LinkSig') ∗
    "HVrfPk" ∷ l ↦s[server.StartReply :: "VrfPk"]{dq} v.(StartReply.VrfPk') ∗
    "HVrfSig" ∷ l ↦s[server.StartReply :: "VrfSig"]{dq} v.(StartReply.VrfSig')
  ).
Proof.
  rewrite /named.
  apply struct_fields_split_intro.
  unfold_typed_pointsto; split_pointsto_app.

  rewrite -!/(typed_pointsto_def _ _ _) -!typed_pointsto_unseal.
  simpl_one_flatten_struct (# (StartReply.StartEpochLen' v)) server.StartReply "StartEpochLen"%go.
  simpl_one_flatten_struct (# (StartReply.StartLink' v)) server.StartReply "StartLink"%go.
  simpl_one_flatten_struct (# (StartReply.ChainProof' v)) server.StartReply "ChainProof"%go.
  simpl_one_flatten_struct (# (StartReply.LinkSig' v)) server.StartReply "LinkSig"%go.
  simpl_one_flatten_struct (# (StartReply.VrfPk' v)) server.StartReply "VrfPk"%go.

  solve_field_ref_f.
Qed.

End instances.

(* type server.PutArg *)
Module PutArg.
Section def.
Context `{ffi_syntax}.
Record t := mk {
  Uid' : w64;
  Pk' : slice.t;
  Ver' : w64;
}.
End def.
End PutArg.

Section instances.
Context `{ffi_syntax}.

Global Instance settable_PutArg : Settable PutArg.t :=
  settable! PutArg.mk < PutArg.Uid'; PutArg.Pk'; PutArg.Ver' >.
Global Instance into_val_PutArg : IntoVal PutArg.t :=
  {| to_val_def v :=
    struct.val_aux server.PutArg [
    "Uid" ::= #(PutArg.Uid' v);
    "Pk" ::= #(PutArg.Pk' v);
    "Ver" ::= #(PutArg.Ver' v)
    ]%struct
  |}.

Global Program Instance into_val_typed_PutArg : IntoValTyped PutArg.t server.PutArg :=
{|
  default_val := PutArg.mk (default_val _) (default_val _) (default_val _);
|}.
Next Obligation. solve_to_val_type. Qed.
Next Obligation. solve_zero_val. Qed.
Next Obligation. solve_to_val_inj. Qed.
Final Obligation. solve_decision. Qed.

Global Instance into_val_struct_field_PutArg_Uid : IntoValStructField "Uid" server.PutArg PutArg.Uid'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_PutArg_Pk : IntoValStructField "Pk" server.PutArg PutArg.Pk'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_PutArg_Ver : IntoValStructField "Ver" server.PutArg PutArg.Ver'.
Proof. solve_into_val_struct_field. Qed.


Context `{!ffi_model, !ffi_semantics _ _, !ffi_interp _, !heapGS Σ}.
Global Instance wp_struct_make_PutArg Uid' Pk' Ver':
  PureWp True
    (struct.make #server.PutArg (alist_val [
      "Uid" ::= #Uid';
      "Pk" ::= #Pk';
      "Ver" ::= #Ver'
    ]))%struct
    #(PutArg.mk Uid' Pk' Ver').
Proof. solve_struct_make_pure_wp. Qed.


Global Instance PutArg_struct_fields_split dq l (v : PutArg.t) :
  StructFieldsSplit dq l v (
    "HUid" ∷ l ↦s[server.PutArg :: "Uid"]{dq} v.(PutArg.Uid') ∗
    "HPk" ∷ l ↦s[server.PutArg :: "Pk"]{dq} v.(PutArg.Pk') ∗
    "HVer" ∷ l ↦s[server.PutArg :: "Ver"]{dq} v.(PutArg.Ver')
  ).
Proof.
  rewrite /named.
  apply struct_fields_split_intro.
  unfold_typed_pointsto; split_pointsto_app.

  rewrite -!/(typed_pointsto_def _ _ _) -!typed_pointsto_unseal.
  simpl_one_flatten_struct (# (PutArg.Uid' v)) server.PutArg "Uid"%go.
  simpl_one_flatten_struct (# (PutArg.Pk' v)) server.PutArg "Pk"%go.

  solve_field_ref_f.
Qed.

End instances.

(* type server.HistoryArg *)
Module HistoryArg.
Section def.
Context `{ffi_syntax}.
Record t := mk {
  Uid' : w64;
  PrevEpoch' : w64;
  PrevVerLen' : w64;
}.
End def.
End HistoryArg.

Section instances.
Context `{ffi_syntax}.

Global Instance settable_HistoryArg : Settable HistoryArg.t :=
  settable! HistoryArg.mk < HistoryArg.Uid'; HistoryArg.PrevEpoch'; HistoryArg.PrevVerLen' >.
Global Instance into_val_HistoryArg : IntoVal HistoryArg.t :=
  {| to_val_def v :=
    struct.val_aux server.HistoryArg [
    "Uid" ::= #(HistoryArg.Uid' v);
    "PrevEpoch" ::= #(HistoryArg.PrevEpoch' v);
    "PrevVerLen" ::= #(HistoryArg.PrevVerLen' v)
    ]%struct
  |}.

Global Program Instance into_val_typed_HistoryArg : IntoValTyped HistoryArg.t server.HistoryArg :=
{|
  default_val := HistoryArg.mk (default_val _) (default_val _) (default_val _);
|}.
Next Obligation. solve_to_val_type. Qed.
Next Obligation. solve_zero_val. Qed.
Next Obligation. solve_to_val_inj. Qed.
Final Obligation. solve_decision. Qed.

Global Instance into_val_struct_field_HistoryArg_Uid : IntoValStructField "Uid" server.HistoryArg HistoryArg.Uid'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_HistoryArg_PrevEpoch : IntoValStructField "PrevEpoch" server.HistoryArg HistoryArg.PrevEpoch'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_HistoryArg_PrevVerLen : IntoValStructField "PrevVerLen" server.HistoryArg HistoryArg.PrevVerLen'.
Proof. solve_into_val_struct_field. Qed.


Context `{!ffi_model, !ffi_semantics _ _, !ffi_interp _, !heapGS Σ}.
Global Instance wp_struct_make_HistoryArg Uid' PrevEpoch' PrevVerLen':
  PureWp True
    (struct.make #server.HistoryArg (alist_val [
      "Uid" ::= #Uid';
      "PrevEpoch" ::= #PrevEpoch';
      "PrevVerLen" ::= #PrevVerLen'
    ]))%struct
    #(HistoryArg.mk Uid' PrevEpoch' PrevVerLen').
Proof. solve_struct_make_pure_wp. Qed.


Global Instance HistoryArg_struct_fields_split dq l (v : HistoryArg.t) :
  StructFieldsSplit dq l v (
    "HUid" ∷ l ↦s[server.HistoryArg :: "Uid"]{dq} v.(HistoryArg.Uid') ∗
    "HPrevEpoch" ∷ l ↦s[server.HistoryArg :: "PrevEpoch"]{dq} v.(HistoryArg.PrevEpoch') ∗
    "HPrevVerLen" ∷ l ↦s[server.HistoryArg :: "PrevVerLen"]{dq} v.(HistoryArg.PrevVerLen')
  ).
Proof.
  rewrite /named.
  apply struct_fields_split_intro.
  unfold_typed_pointsto; split_pointsto_app.

  rewrite -!/(typed_pointsto_def _ _ _) -!typed_pointsto_unseal.
  simpl_one_flatten_struct (# (HistoryArg.Uid' v)) server.HistoryArg "Uid"%go.
  simpl_one_flatten_struct (# (HistoryArg.PrevEpoch' v)) server.HistoryArg "PrevEpoch"%go.

  solve_field_ref_f.
Qed.

End instances.

(* type server.HistoryReply *)
Module HistoryReply.
Section def.
Context `{ffi_syntax}.
Record t := mk {
  ChainProof' : slice.t;
  LinkSig' : slice.t;
  Hist' : slice.t;
  Bound' : loc;
  Err' : ktcore.Blame.t;
}.
End def.
End HistoryReply.

Section instances.
Context `{ffi_syntax}.

Global Instance settable_HistoryReply : Settable HistoryReply.t :=
  settable! HistoryReply.mk < HistoryReply.ChainProof'; HistoryReply.LinkSig'; HistoryReply.Hist'; HistoryReply.Bound'; HistoryReply.Err' >.
Global Instance into_val_HistoryReply : IntoVal HistoryReply.t :=
  {| to_val_def v :=
    struct.val_aux server.HistoryReply [
    "ChainProof" ::= #(HistoryReply.ChainProof' v);
    "LinkSig" ::= #(HistoryReply.LinkSig' v);
    "Hist" ::= #(HistoryReply.Hist' v);
    "Bound" ::= #(HistoryReply.Bound' v);
    "Err" ::= #(HistoryReply.Err' v)
    ]%struct
  |}.

Global Program Instance into_val_typed_HistoryReply : IntoValTyped HistoryReply.t server.HistoryReply :=
{|
  default_val := HistoryReply.mk (default_val _) (default_val _) (default_val _) (default_val _) (default_val _);
|}.
Next Obligation. solve_to_val_type. Qed.
Next Obligation. solve_zero_val. Qed.
Next Obligation. solve_to_val_inj. Qed.
Final Obligation. solve_decision. Qed.

Global Instance into_val_struct_field_HistoryReply_ChainProof : IntoValStructField "ChainProof" server.HistoryReply HistoryReply.ChainProof'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_HistoryReply_LinkSig : IntoValStructField "LinkSig" server.HistoryReply HistoryReply.LinkSig'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_HistoryReply_Hist : IntoValStructField "Hist" server.HistoryReply HistoryReply.Hist'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_HistoryReply_Bound : IntoValStructField "Bound" server.HistoryReply HistoryReply.Bound'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_HistoryReply_Err : IntoValStructField "Err" server.HistoryReply HistoryReply.Err'.
Proof. solve_into_val_struct_field. Qed.


Context `{!ffi_model, !ffi_semantics _ _, !ffi_interp _, !heapGS Σ}.
Global Instance wp_struct_make_HistoryReply ChainProof' LinkSig' Hist' Bound' Err':
  PureWp True
    (struct.make #server.HistoryReply (alist_val [
      "ChainProof" ::= #ChainProof';
      "LinkSig" ::= #LinkSig';
      "Hist" ::= #Hist';
      "Bound" ::= #Bound';
      "Err" ::= #Err'
    ]))%struct
    #(HistoryReply.mk ChainProof' LinkSig' Hist' Bound' Err').
Proof. solve_struct_make_pure_wp. Qed.


Global Instance HistoryReply_struct_fields_split dq l (v : HistoryReply.t) :
  StructFieldsSplit dq l v (
    "HChainProof" ∷ l ↦s[server.HistoryReply :: "ChainProof"]{dq} v.(HistoryReply.ChainProof') ∗
    "HLinkSig" ∷ l ↦s[server.HistoryReply :: "LinkSig"]{dq} v.(HistoryReply.LinkSig') ∗
    "HHist" ∷ l ↦s[server.HistoryReply :: "Hist"]{dq} v.(HistoryReply.Hist') ∗
    "HBound" ∷ l ↦s[server.HistoryReply :: "Bound"]{dq} v.(HistoryReply.Bound') ∗
    "HErr" ∷ l ↦s[server.HistoryReply :: "Err"]{dq} v.(HistoryReply.Err')
  ).
Proof.
  rewrite /named.
  apply struct_fields_split_intro.
  unfold_typed_pointsto; split_pointsto_app.

  rewrite -!/(typed_pointsto_def _ _ _) -!typed_pointsto_unseal.
  simpl_one_flatten_struct (# (HistoryReply.ChainProof' v)) server.HistoryReply "ChainProof"%go.
  simpl_one_flatten_struct (# (HistoryReply.LinkSig' v)) server.HistoryReply "LinkSig"%go.
  simpl_one_flatten_struct (# (HistoryReply.Hist' v)) server.HistoryReply "Hist"%go.
  simpl_one_flatten_struct (# (HistoryReply.Bound' v)) server.HistoryReply "Bound"%go.

  solve_field_ref_f.
Qed.

End instances.

(* type server.AuditArg *)
Module AuditArg.
Section def.
Context `{ffi_syntax}.
Record t := mk {
  PrevEpochLen' : w64;
}.
End def.
End AuditArg.

Section instances.
Context `{ffi_syntax}.

Global Instance settable_AuditArg : Settable AuditArg.t :=
  settable! AuditArg.mk < AuditArg.PrevEpochLen' >.
Global Instance into_val_AuditArg : IntoVal AuditArg.t :=
  {| to_val_def v :=
    struct.val_aux server.AuditArg [
    "PrevEpochLen" ::= #(AuditArg.PrevEpochLen' v)
    ]%struct
  |}.

Global Program Instance into_val_typed_AuditArg : IntoValTyped AuditArg.t server.AuditArg :=
{|
  default_val := AuditArg.mk (default_val _);
|}.
Next Obligation. solve_to_val_type. Qed.
Next Obligation. solve_zero_val. Qed.
Next Obligation. solve_to_val_inj. Qed.
Final Obligation. solve_decision. Qed.

Global Instance into_val_struct_field_AuditArg_PrevEpochLen : IntoValStructField "PrevEpochLen" server.AuditArg AuditArg.PrevEpochLen'.
Proof. solve_into_val_struct_field. Qed.


Context `{!ffi_model, !ffi_semantics _ _, !ffi_interp _, !heapGS Σ}.
Global Instance wp_struct_make_AuditArg PrevEpochLen':
  PureWp True
    (struct.make #server.AuditArg (alist_val [
      "PrevEpochLen" ::= #PrevEpochLen'
    ]))%struct
    #(AuditArg.mk PrevEpochLen').
Proof. solve_struct_make_pure_wp. Qed.


Global Instance AuditArg_struct_fields_split dq l (v : AuditArg.t) :
  StructFieldsSplit dq l v (
    "HPrevEpochLen" ∷ l ↦s[server.AuditArg :: "PrevEpochLen"]{dq} v.(AuditArg.PrevEpochLen')
  ).
Proof.
  rewrite /named.
  apply struct_fields_split_intro.
  unfold_typed_pointsto; split_pointsto_app.

  rewrite -!/(typed_pointsto_def _ _ _) -!typed_pointsto_unseal.

  solve_field_ref_f.
Qed.

End instances.

(* type server.AuditReply *)
Module AuditReply.
Section def.
Context `{ffi_syntax}.
Record t := mk {
  P' : slice.t;
  Err' : ktcore.Blame.t;
}.
End def.
End AuditReply.

Section instances.
Context `{ffi_syntax}.

Global Instance settable_AuditReply : Settable AuditReply.t :=
  settable! AuditReply.mk < AuditReply.P'; AuditReply.Err' >.
Global Instance into_val_AuditReply : IntoVal AuditReply.t :=
  {| to_val_def v :=
    struct.val_aux server.AuditReply [
    "P" ::= #(AuditReply.P' v);
    "Err" ::= #(AuditReply.Err' v)
    ]%struct
  |}.

Global Program Instance into_val_typed_AuditReply : IntoValTyped AuditReply.t server.AuditReply :=
{|
  default_val := AuditReply.mk (default_val _) (default_val _);
|}.
Next Obligation. solve_to_val_type. Qed.
Next Obligation. solve_zero_val. Qed.
Next Obligation. solve_to_val_inj. Qed.
Final Obligation. solve_decision. Qed.

Global Instance into_val_struct_field_AuditReply_P : IntoValStructField "P" server.AuditReply AuditReply.P'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_AuditReply_Err : IntoValStructField "Err" server.AuditReply AuditReply.Err'.
Proof. solve_into_val_struct_field. Qed.


Context `{!ffi_model, !ffi_semantics _ _, !ffi_interp _, !heapGS Σ}.
Global Instance wp_struct_make_AuditReply P' Err':
  PureWp True
    (struct.make #server.AuditReply (alist_val [
      "P" ::= #P';
      "Err" ::= #Err'
    ]))%struct
    #(AuditReply.mk P' Err').
Proof. solve_struct_make_pure_wp. Qed.


Global Instance AuditReply_struct_fields_split dq l (v : AuditReply.t) :
  StructFieldsSplit dq l v (
    "HP" ∷ l ↦s[server.AuditReply :: "P"]{dq} v.(AuditReply.P') ∗
    "HErr" ∷ l ↦s[server.AuditReply :: "Err"]{dq} v.(AuditReply.Err')
  ).
Proof.
  rewrite /named.
  apply struct_fields_split_intro.
  unfold_typed_pointsto; split_pointsto_app.

  rewrite -!/(typed_pointsto_def _ _ _) -!typed_pointsto_unseal.
  simpl_one_flatten_struct (# (AuditReply.P' v)) server.AuditReply "P"%go.

  solve_field_ref_f.
Qed.

End instances.

(* type server.Server *)
Module Server.
Section def.
Context `{ffi_syntax}.
Record t := mk {
  mu' : loc;
  secs' : loc;
  keys' : loc;
  hist' : loc;
  workQ' : loc;
}.
End def.
End Server.

Section instances.
Context `{ffi_syntax}.

Global Instance settable_Server : Settable Server.t :=
  settable! Server.mk < Server.mu'; Server.secs'; Server.keys'; Server.hist'; Server.workQ' >.
Global Instance into_val_Server : IntoVal Server.t :=
  {| to_val_def v :=
    struct.val_aux server.Server [
    "mu" ::= #(Server.mu' v);
    "secs" ::= #(Server.secs' v);
    "keys" ::= #(Server.keys' v);
    "hist" ::= #(Server.hist' v);
    "workQ" ::= #(Server.workQ' v)
    ]%struct
  |}.

Global Program Instance into_val_typed_Server : IntoValTyped Server.t server.Server :=
{|
  default_val := Server.mk (default_val _) (default_val _) (default_val _) (default_val _) (default_val _);
|}.
Next Obligation. solve_to_val_type. Qed.
Next Obligation. solve_zero_val. Qed.
Next Obligation. solve_to_val_inj. Qed.
Final Obligation. solve_decision. Qed.

Global Instance into_val_struct_field_Server_mu : IntoValStructField "mu" server.Server Server.mu'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_Server_secs : IntoValStructField "secs" server.Server Server.secs'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_Server_keys : IntoValStructField "keys" server.Server Server.keys'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_Server_hist : IntoValStructField "hist" server.Server Server.hist'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_Server_workQ : IntoValStructField "workQ" server.Server Server.workQ'.
Proof. solve_into_val_struct_field. Qed.


Context `{!ffi_model, !ffi_semantics _ _, !ffi_interp _, !heapGS Σ}.
Global Instance wp_struct_make_Server mu' secs' keys' hist' workQ':
  PureWp True
    (struct.make #server.Server (alist_val [
      "mu" ::= #mu';
      "secs" ::= #secs';
      "keys" ::= #keys';
      "hist" ::= #hist';
      "workQ" ::= #workQ'
    ]))%struct
    #(Server.mk mu' secs' keys' hist' workQ').
Proof. solve_struct_make_pure_wp. Qed.


Global Instance Server_struct_fields_split dq l (v : Server.t) :
  StructFieldsSplit dq l v (
    "Hmu" ∷ l ↦s[server.Server :: "mu"]{dq} v.(Server.mu') ∗
    "Hsecs" ∷ l ↦s[server.Server :: "secs"]{dq} v.(Server.secs') ∗
    "Hkeys" ∷ l ↦s[server.Server :: "keys"]{dq} v.(Server.keys') ∗
    "Hhist" ∷ l ↦s[server.Server :: "hist"]{dq} v.(Server.hist') ∗
    "HworkQ" ∷ l ↦s[server.Server :: "workQ"]{dq} v.(Server.workQ')
  ).
Proof.
  rewrite /named.
  apply struct_fields_split_intro.
  unfold_typed_pointsto; split_pointsto_app.

  rewrite -!/(typed_pointsto_def _ _ _) -!typed_pointsto_unseal.
  simpl_one_flatten_struct (# (Server.mu' v)) server.Server "mu"%go.
  simpl_one_flatten_struct (# (Server.secs' v)) server.Server "secs"%go.
  simpl_one_flatten_struct (# (Server.keys' v)) server.Server "keys"%go.
  simpl_one_flatten_struct (# (Server.hist' v)) server.Server "hist"%go.

  solve_field_ref_f.
Qed.

End instances.

(* type server.secrets *)
Module secrets.
Section def.
Context `{ffi_syntax}.
Record t := mk {
  sig' : loc;
  vrf' : loc;
  commit' : slice.t;
}.
End def.
End secrets.

Section instances.
Context `{ffi_syntax}.

Global Instance settable_secrets : Settable secrets.t :=
  settable! secrets.mk < secrets.sig'; secrets.vrf'; secrets.commit' >.
Global Instance into_val_secrets : IntoVal secrets.t :=
  {| to_val_def v :=
    struct.val_aux server.secrets [
    "sig" ::= #(secrets.sig' v);
    "vrf" ::= #(secrets.vrf' v);
    "commit" ::= #(secrets.commit' v)
    ]%struct
  |}.

Global Program Instance into_val_typed_secrets : IntoValTyped secrets.t server.secrets :=
{|
  default_val := secrets.mk (default_val _) (default_val _) (default_val _);
|}.
Next Obligation. solve_to_val_type. Qed.
Next Obligation. solve_zero_val. Qed.
Next Obligation. solve_to_val_inj. Qed.
Final Obligation. solve_decision. Qed.

Global Instance into_val_struct_field_secrets_sig : IntoValStructField "sig" server.secrets secrets.sig'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_secrets_vrf : IntoValStructField "vrf" server.secrets secrets.vrf'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_secrets_commit : IntoValStructField "commit" server.secrets secrets.commit'.
Proof. solve_into_val_struct_field. Qed.


Context `{!ffi_model, !ffi_semantics _ _, !ffi_interp _, !heapGS Σ}.
Global Instance wp_struct_make_secrets sig' vrf' commit':
  PureWp True
    (struct.make #server.secrets (alist_val [
      "sig" ::= #sig';
      "vrf" ::= #vrf';
      "commit" ::= #commit'
    ]))%struct
    #(secrets.mk sig' vrf' commit').
Proof. solve_struct_make_pure_wp. Qed.


Global Instance secrets_struct_fields_split dq l (v : secrets.t) :
  StructFieldsSplit dq l v (
    "Hsig" ∷ l ↦s[server.secrets :: "sig"]{dq} v.(secrets.sig') ∗
    "Hvrf" ∷ l ↦s[server.secrets :: "vrf"]{dq} v.(secrets.vrf') ∗
    "Hcommit" ∷ l ↦s[server.secrets :: "commit"]{dq} v.(secrets.commit')
  ).
Proof.
  rewrite /named.
  apply struct_fields_split_intro.
  unfold_typed_pointsto; split_pointsto_app.

  rewrite -!/(typed_pointsto_def _ _ _) -!typed_pointsto_unseal.
  simpl_one_flatten_struct (# (secrets.sig' v)) server.secrets "sig"%go.
  simpl_one_flatten_struct (# (secrets.vrf' v)) server.secrets "vrf"%go.

  solve_field_ref_f.
Qed.

End instances.

(* type server.keyStore *)
Module keyStore.
Section def.
Context `{ffi_syntax}.
Record t := mk {
  hidden' : loc;
  plain' : loc;
}.
End def.
End keyStore.

Section instances.
Context `{ffi_syntax}.

Global Instance settable_keyStore : Settable keyStore.t :=
  settable! keyStore.mk < keyStore.hidden'; keyStore.plain' >.
Global Instance into_val_keyStore : IntoVal keyStore.t :=
  {| to_val_def v :=
    struct.val_aux server.keyStore [
    "hidden" ::= #(keyStore.hidden' v);
    "plain" ::= #(keyStore.plain' v)
    ]%struct
  |}.

Global Program Instance into_val_typed_keyStore : IntoValTyped keyStore.t server.keyStore :=
{|
  default_val := keyStore.mk (default_val _) (default_val _);
|}.
Next Obligation. solve_to_val_type. Qed.
Next Obligation. solve_zero_val. Qed.
Next Obligation. solve_to_val_inj. Qed.
Final Obligation. solve_decision. Qed.

Global Instance into_val_struct_field_keyStore_hidden : IntoValStructField "hidden" server.keyStore keyStore.hidden'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_keyStore_plain : IntoValStructField "plain" server.keyStore keyStore.plain'.
Proof. solve_into_val_struct_field. Qed.


Context `{!ffi_model, !ffi_semantics _ _, !ffi_interp _, !heapGS Σ}.
Global Instance wp_struct_make_keyStore hidden' plain':
  PureWp True
    (struct.make #server.keyStore (alist_val [
      "hidden" ::= #hidden';
      "plain" ::= #plain'
    ]))%struct
    #(keyStore.mk hidden' plain').
Proof. solve_struct_make_pure_wp. Qed.


Global Instance keyStore_struct_fields_split dq l (v : keyStore.t) :
  StructFieldsSplit dq l v (
    "Hhidden" ∷ l ↦s[server.keyStore :: "hidden"]{dq} v.(keyStore.hidden') ∗
    "Hplain" ∷ l ↦s[server.keyStore :: "plain"]{dq} v.(keyStore.plain')
  ).
Proof.
  rewrite /named.
  apply struct_fields_split_intro.
  unfold_typed_pointsto; split_pointsto_app.

  rewrite -!/(typed_pointsto_def _ _ _) -!typed_pointsto_unseal.
  simpl_one_flatten_struct (# (keyStore.hidden' v)) server.keyStore "hidden"%go.

  solve_field_ref_f.
Qed.

End instances.

(* type server.history *)
Module history.
Section def.
Context `{ffi_syntax}.
Record t := mk {
  chain' : loc;
  audits' : slice.t;
  vrfPkSig' : slice.t;
}.
End def.
End history.

Section instances.
Context `{ffi_syntax}.

Global Instance settable_history : Settable history.t :=
  settable! history.mk < history.chain'; history.audits'; history.vrfPkSig' >.
Global Instance into_val_history : IntoVal history.t :=
  {| to_val_def v :=
    struct.val_aux server.history [
    "chain" ::= #(history.chain' v);
    "audits" ::= #(history.audits' v);
    "vrfPkSig" ::= #(history.vrfPkSig' v)
    ]%struct
  |}.

Global Program Instance into_val_typed_history : IntoValTyped history.t server.history :=
{|
  default_val := history.mk (default_val _) (default_val _) (default_val _);
|}.
Next Obligation. solve_to_val_type. Qed.
Next Obligation. solve_zero_val. Qed.
Next Obligation. solve_to_val_inj. Qed.
Final Obligation. solve_decision. Qed.

Global Instance into_val_struct_field_history_chain : IntoValStructField "chain" server.history history.chain'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_history_audits : IntoValStructField "audits" server.history history.audits'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_history_vrfPkSig : IntoValStructField "vrfPkSig" server.history history.vrfPkSig'.
Proof. solve_into_val_struct_field. Qed.


Context `{!ffi_model, !ffi_semantics _ _, !ffi_interp _, !heapGS Σ}.
Global Instance wp_struct_make_history chain' audits' vrfPkSig':
  PureWp True
    (struct.make #server.history (alist_val [
      "chain" ::= #chain';
      "audits" ::= #audits';
      "vrfPkSig" ::= #vrfPkSig'
    ]))%struct
    #(history.mk chain' audits' vrfPkSig').
Proof. solve_struct_make_pure_wp. Qed.


Global Instance history_struct_fields_split dq l (v : history.t) :
  StructFieldsSplit dq l v (
    "Hchain" ∷ l ↦s[server.history :: "chain"]{dq} v.(history.chain') ∗
    "Haudits" ∷ l ↦s[server.history :: "audits"]{dq} v.(history.audits') ∗
    "HvrfPkSig" ∷ l ↦s[server.history :: "vrfPkSig"]{dq} v.(history.vrfPkSig')
  ).
Proof.
  rewrite /named.
  apply struct_fields_split_intro.
  unfold_typed_pointsto; split_pointsto_app.

  rewrite -!/(typed_pointsto_def _ _ _) -!typed_pointsto_unseal.
  simpl_one_flatten_struct (# (history.chain' v)) server.history "chain"%go.
  simpl_one_flatten_struct (# (history.audits' v)) server.history "audits"%go.

  solve_field_ref_f.
Qed.

End instances.

(* type server.WQReq *)
Module WQReq.
Section def.
Context `{ffi_syntax}.
Record t := mk {
  Uid' : w64;
  Pk' : slice.t;
  Ver' : w64;
}.
End def.
End WQReq.

Section instances.
Context `{ffi_syntax}.

Global Instance settable_WQReq : Settable WQReq.t :=
  settable! WQReq.mk < WQReq.Uid'; WQReq.Pk'; WQReq.Ver' >.
Global Instance into_val_WQReq : IntoVal WQReq.t :=
  {| to_val_def v :=
    struct.val_aux server.WQReq [
    "Uid" ::= #(WQReq.Uid' v);
    "Pk" ::= #(WQReq.Pk' v);
    "Ver" ::= #(WQReq.Ver' v)
    ]%struct
  |}.

Global Program Instance into_val_typed_WQReq : IntoValTyped WQReq.t server.WQReq :=
{|
  default_val := WQReq.mk (default_val _) (default_val _) (default_val _);
|}.
Next Obligation. solve_to_val_type. Qed.
Next Obligation. solve_zero_val. Qed.
Next Obligation. solve_to_val_inj. Qed.
Final Obligation. solve_decision. Qed.

Global Instance into_val_struct_field_WQReq_Uid : IntoValStructField "Uid" server.WQReq WQReq.Uid'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_WQReq_Pk : IntoValStructField "Pk" server.WQReq WQReq.Pk'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_WQReq_Ver : IntoValStructField "Ver" server.WQReq WQReq.Ver'.
Proof. solve_into_val_struct_field. Qed.


Context `{!ffi_model, !ffi_semantics _ _, !ffi_interp _, !heapGS Σ}.
Global Instance wp_struct_make_WQReq Uid' Pk' Ver':
  PureWp True
    (struct.make #server.WQReq (alist_val [
      "Uid" ::= #Uid';
      "Pk" ::= #Pk';
      "Ver" ::= #Ver'
    ]))%struct
    #(WQReq.mk Uid' Pk' Ver').
Proof. solve_struct_make_pure_wp. Qed.


Global Instance WQReq_struct_fields_split dq l (v : WQReq.t) :
  StructFieldsSplit dq l v (
    "HUid" ∷ l ↦s[server.WQReq :: "Uid"]{dq} v.(WQReq.Uid') ∗
    "HPk" ∷ l ↦s[server.WQReq :: "Pk"]{dq} v.(WQReq.Pk') ∗
    "HVer" ∷ l ↦s[server.WQReq :: "Ver"]{dq} v.(WQReq.Ver')
  ).
Proof.
  rewrite /named.
  apply struct_fields_split_intro.
  unfold_typed_pointsto; split_pointsto_app.

  rewrite -!/(typed_pointsto_def _ _ _) -!typed_pointsto_unseal.
  simpl_one_flatten_struct (# (WQReq.Uid' v)) server.WQReq "Uid"%go.
  simpl_one_flatten_struct (# (WQReq.Pk' v)) server.WQReq "Pk"%go.

  solve_field_ref_f.
Qed.

End instances.

(* type server.WQResp *)
Module WQResp.
Section def.
Context `{ffi_syntax}.
Record t := mk {
  Err' : bool;
}.
End def.
End WQResp.

Section instances.
Context `{ffi_syntax}.

Global Instance settable_WQResp : Settable WQResp.t :=
  settable! WQResp.mk < WQResp.Err' >.
Global Instance into_val_WQResp : IntoVal WQResp.t :=
  {| to_val_def v :=
    struct.val_aux server.WQResp [
    "Err" ::= #(WQResp.Err' v)
    ]%struct
  |}.

Global Program Instance into_val_typed_WQResp : IntoValTyped WQResp.t server.WQResp :=
{|
  default_val := WQResp.mk (default_val _);
|}.
Next Obligation. solve_to_val_type. Qed.
Next Obligation. solve_zero_val. Qed.
Next Obligation. solve_to_val_inj. Qed.
Final Obligation. solve_decision. Qed.

Global Instance into_val_struct_field_WQResp_Err : IntoValStructField "Err" server.WQResp WQResp.Err'.
Proof. solve_into_val_struct_field. Qed.


Context `{!ffi_model, !ffi_semantics _ _, !ffi_interp _, !heapGS Σ}.
Global Instance wp_struct_make_WQResp Err':
  PureWp True
    (struct.make #server.WQResp (alist_val [
      "Err" ::= #Err'
    ]))%struct
    #(WQResp.mk Err').
Proof. solve_struct_make_pure_wp. Qed.


Global Instance WQResp_struct_fields_split dq l (v : WQResp.t) :
  StructFieldsSplit dq l v (
    "HErr" ∷ l ↦s[server.WQResp :: "Err"]{dq} v.(WQResp.Err')
  ).
Proof.
  rewrite /named.
  apply struct_fields_split_intro.
  unfold_typed_pointsto; split_pointsto_app.

  rewrite -!/(typed_pointsto_def _ _ _) -!typed_pointsto_unseal.

  solve_field_ref_f.
Qed.

End instances.

(* type server.mapEntry *)
Module mapEntry.
Section def.
Context `{ffi_syntax}.
Record t := mk {
  label' : slice.t;
  val' : slice.t;
}.
End def.
End mapEntry.

Section instances.
Context `{ffi_syntax}.

Global Instance settable_mapEntry : Settable mapEntry.t :=
  settable! mapEntry.mk < mapEntry.label'; mapEntry.val' >.
Global Instance into_val_mapEntry : IntoVal mapEntry.t :=
  {| to_val_def v :=
    struct.val_aux server.mapEntry [
    "label" ::= #(mapEntry.label' v);
    "val" ::= #(mapEntry.val' v)
    ]%struct
  |}.

Global Program Instance into_val_typed_mapEntry : IntoValTyped mapEntry.t server.mapEntry :=
{|
  default_val := mapEntry.mk (default_val _) (default_val _);
|}.
Next Obligation. solve_to_val_type. Qed.
Next Obligation. solve_zero_val. Qed.
Next Obligation. solve_to_val_inj. Qed.
Final Obligation. solve_decision. Qed.

Global Instance into_val_struct_field_mapEntry_label : IntoValStructField "label" server.mapEntry mapEntry.label'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_mapEntry_val : IntoValStructField "val" server.mapEntry mapEntry.val'.
Proof. solve_into_val_struct_field. Qed.


Context `{!ffi_model, !ffi_semantics _ _, !ffi_interp _, !heapGS Σ}.
Global Instance wp_struct_make_mapEntry label' val':
  PureWp True
    (struct.make #server.mapEntry (alist_val [
      "label" ::= #label';
      "val" ::= #val'
    ]))%struct
    #(mapEntry.mk label' val').
Proof. solve_struct_make_pure_wp. Qed.


Global Instance mapEntry_struct_fields_split dq l (v : mapEntry.t) :
  StructFieldsSplit dq l v (
    "Hlabel" ∷ l ↦s[server.mapEntry :: "label"]{dq} v.(mapEntry.label') ∗
    "Hval" ∷ l ↦s[server.mapEntry :: "val"]{dq} v.(mapEntry.val')
  ).
Proof.
  rewrite /named.
  apply struct_fields_split_intro.
  unfold_typed_pointsto; split_pointsto_app.

  rewrite -!/(typed_pointsto_def _ _ _) -!typed_pointsto_unseal.
  simpl_one_flatten_struct (# (mapEntry.label' v)) server.mapEntry "label"%go.

  solve_field_ref_f.
Qed.

End instances.

(* type server.Work *)
Module Work.
Section def.
Context `{ffi_syntax}.
Record t := mk {
  mu' : loc;
  cond' : loc;
  done' : bool;
  Req' : loc;
  Resp' : loc;
}.
End def.
End Work.

Section instances.
Context `{ffi_syntax}.

Global Instance settable_Work : Settable Work.t :=
  settable! Work.mk < Work.mu'; Work.cond'; Work.done'; Work.Req'; Work.Resp' >.
Global Instance into_val_Work : IntoVal Work.t :=
  {| to_val_def v :=
    struct.val_aux server.Work [
    "mu" ::= #(Work.mu' v);
    "cond" ::= #(Work.cond' v);
    "done" ::= #(Work.done' v);
    "Req" ::= #(Work.Req' v);
    "Resp" ::= #(Work.Resp' v)
    ]%struct
  |}.

Global Program Instance into_val_typed_Work : IntoValTyped Work.t server.Work :=
{|
  default_val := Work.mk (default_val _) (default_val _) (default_val _) (default_val _) (default_val _);
|}.
Next Obligation. solve_to_val_type. Qed.
Next Obligation. solve_zero_val. Qed.
Next Obligation. solve_to_val_inj. Qed.
Final Obligation. solve_decision. Qed.

Global Instance into_val_struct_field_Work_mu : IntoValStructField "mu" server.Work Work.mu'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_Work_cond : IntoValStructField "cond" server.Work Work.cond'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_Work_done : IntoValStructField "done" server.Work Work.done'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_Work_Req : IntoValStructField "Req" server.Work Work.Req'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_Work_Resp : IntoValStructField "Resp" server.Work Work.Resp'.
Proof. solve_into_val_struct_field. Qed.


Context `{!ffi_model, !ffi_semantics _ _, !ffi_interp _, !heapGS Σ}.
Global Instance wp_struct_make_Work mu' cond' done' Req' Resp':
  PureWp True
    (struct.make #server.Work (alist_val [
      "mu" ::= #mu';
      "cond" ::= #cond';
      "done" ::= #done';
      "Req" ::= #Req';
      "Resp" ::= #Resp'
    ]))%struct
    #(Work.mk mu' cond' done' Req' Resp').
Proof. solve_struct_make_pure_wp. Qed.


Global Instance Work_struct_fields_split dq l (v : Work.t) :
  StructFieldsSplit dq l v (
    "Hmu" ∷ l ↦s[server.Work :: "mu"]{dq} v.(Work.mu') ∗
    "Hcond" ∷ l ↦s[server.Work :: "cond"]{dq} v.(Work.cond') ∗
    "Hdone" ∷ l ↦s[server.Work :: "done"]{dq} v.(Work.done') ∗
    "HReq" ∷ l ↦s[server.Work :: "Req"]{dq} v.(Work.Req') ∗
    "HResp" ∷ l ↦s[server.Work :: "Resp"]{dq} v.(Work.Resp')
  ).
Proof.
  rewrite /named.
  apply struct_fields_split_intro.
  unfold_typed_pointsto; split_pointsto_app.

  rewrite -!/(typed_pointsto_def _ _ _) -!typed_pointsto_unseal.
  simpl_one_flatten_struct (# (Work.mu' v)) server.Work "mu"%go.
  simpl_one_flatten_struct (# (Work.cond' v)) server.Work "cond"%go.
  simpl_one_flatten_struct (# (Work.done' v)) server.Work "done"%go.
  simpl_one_flatten_struct (# (Work.Req' v)) server.Work "Req"%go.

  solve_field_ref_f.
Qed.

End instances.

(* type server.WorkQ *)
Module WorkQ.
Section def.
Context `{ffi_syntax}.
Record t := mk {
  mu' : loc;
  work' : slice.t;
  cond' : loc;
}.
End def.
End WorkQ.

Section instances.
Context `{ffi_syntax}.

Global Instance settable_WorkQ : Settable WorkQ.t :=
  settable! WorkQ.mk < WorkQ.mu'; WorkQ.work'; WorkQ.cond' >.
Global Instance into_val_WorkQ : IntoVal WorkQ.t :=
  {| to_val_def v :=
    struct.val_aux server.WorkQ [
    "mu" ::= #(WorkQ.mu' v);
    "work" ::= #(WorkQ.work' v);
    "cond" ::= #(WorkQ.cond' v)
    ]%struct
  |}.

Global Program Instance into_val_typed_WorkQ : IntoValTyped WorkQ.t server.WorkQ :=
{|
  default_val := WorkQ.mk (default_val _) (default_val _) (default_val _);
|}.
Next Obligation. solve_to_val_type. Qed.
Next Obligation. solve_zero_val. Qed.
Next Obligation. solve_to_val_inj. Qed.
Final Obligation. solve_decision. Qed.

Global Instance into_val_struct_field_WorkQ_mu : IntoValStructField "mu" server.WorkQ WorkQ.mu'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_WorkQ_work : IntoValStructField "work" server.WorkQ WorkQ.work'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_WorkQ_cond : IntoValStructField "cond" server.WorkQ WorkQ.cond'.
Proof. solve_into_val_struct_field. Qed.


Context `{!ffi_model, !ffi_semantics _ _, !ffi_interp _, !heapGS Σ}.
Global Instance wp_struct_make_WorkQ mu' work' cond':
  PureWp True
    (struct.make #server.WorkQ (alist_val [
      "mu" ::= #mu';
      "work" ::= #work';
      "cond" ::= #cond'
    ]))%struct
    #(WorkQ.mk mu' work' cond').
Proof. solve_struct_make_pure_wp. Qed.


Global Instance WorkQ_struct_fields_split dq l (v : WorkQ.t) :
  StructFieldsSplit dq l v (
    "Hmu" ∷ l ↦s[server.WorkQ :: "mu"]{dq} v.(WorkQ.mu') ∗
    "Hwork" ∷ l ↦s[server.WorkQ :: "work"]{dq} v.(WorkQ.work') ∗
    "Hcond" ∷ l ↦s[server.WorkQ :: "cond"]{dq} v.(WorkQ.cond')
  ).
Proof.
  rewrite /named.
  apply struct_fields_split_intro.
  unfold_typed_pointsto; split_pointsto_app.

  rewrite -!/(typed_pointsto_def _ _ _) -!typed_pointsto_unseal.
  simpl_one_flatten_struct (# (WorkQ.mu' v)) server.WorkQ "mu"%go.
  simpl_one_flatten_struct (# (WorkQ.work' v)) server.WorkQ "work"%go.

  solve_field_ref_f.
Qed.

End instances.

Section names.

Class GlobalAddrs :=
{
}.

Context `{!GlobalAddrs}.
Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context `{!goGlobalsGS Σ}.

Definition var_addrs : list (go_string * loc) := [
  ].

Global Instance is_pkg_defined_instance : IsPkgDefined server :=
{|
  is_pkg_defined := is_global_definitions server var_addrs;
|}.

Definition own_allocated : iProp Σ :=
True.

Global Instance wp_func_call_NewRpcServer :
  WpFuncCall server "NewRpcServer" _ (is_pkg_defined server) :=
  ltac:(apply wp_func_call'; reflexivity).

Global Instance wp_func_call_CallStart :
  WpFuncCall server "CallStart" _ (is_pkg_defined server) :=
  ltac:(apply wp_func_call'; reflexivity).

Global Instance wp_func_call_CallPut :
  WpFuncCall server "CallPut" _ (is_pkg_defined server) :=
  ltac:(apply wp_func_call'; reflexivity).

Global Instance wp_func_call_CallHistory :
  WpFuncCall server "CallHistory" _ (is_pkg_defined server) :=
  ltac:(apply wp_func_call'; reflexivity).

Global Instance wp_func_call_CallAudit :
  WpFuncCall server "CallAudit" _ (is_pkg_defined server) :=
  ltac:(apply wp_func_call'; reflexivity).

Global Instance wp_func_call_StartReplyEncode :
  WpFuncCall server "StartReplyEncode" _ (is_pkg_defined server) :=
  ltac:(apply wp_func_call'; reflexivity).

Global Instance wp_func_call_StartReplyDecode :
  WpFuncCall server "StartReplyDecode" _ (is_pkg_defined server) :=
  ltac:(apply wp_func_call'; reflexivity).

Global Instance wp_func_call_PutArgEncode :
  WpFuncCall server "PutArgEncode" _ (is_pkg_defined server) :=
  ltac:(apply wp_func_call'; reflexivity).

Global Instance wp_func_call_PutArgDecode :
  WpFuncCall server "PutArgDecode" _ (is_pkg_defined server) :=
  ltac:(apply wp_func_call'; reflexivity).

Global Instance wp_func_call_HistoryArgEncode :
  WpFuncCall server "HistoryArgEncode" _ (is_pkg_defined server) :=
  ltac:(apply wp_func_call'; reflexivity).

Global Instance wp_func_call_HistoryArgDecode :
  WpFuncCall server "HistoryArgDecode" _ (is_pkg_defined server) :=
  ltac:(apply wp_func_call'; reflexivity).

Global Instance wp_func_call_HistoryReplyEncode :
  WpFuncCall server "HistoryReplyEncode" _ (is_pkg_defined server) :=
  ltac:(apply wp_func_call'; reflexivity).

Global Instance wp_func_call_HistoryReplyDecode :
  WpFuncCall server "HistoryReplyDecode" _ (is_pkg_defined server) :=
  ltac:(apply wp_func_call'; reflexivity).

Global Instance wp_func_call_AuditArgEncode :
  WpFuncCall server "AuditArgEncode" _ (is_pkg_defined server) :=
  ltac:(apply wp_func_call'; reflexivity).

Global Instance wp_func_call_AuditArgDecode :
  WpFuncCall server "AuditArgDecode" _ (is_pkg_defined server) :=
  ltac:(apply wp_func_call'; reflexivity).

Global Instance wp_func_call_AuditReplyEncode :
  WpFuncCall server "AuditReplyEncode" _ (is_pkg_defined server) :=
  ltac:(apply wp_func_call'; reflexivity).

Global Instance wp_func_call_AuditReplyDecode :
  WpFuncCall server "AuditReplyDecode" _ (is_pkg_defined server) :=
  ltac:(apply wp_func_call'; reflexivity).

Global Instance wp_func_call_New :
  WpFuncCall server "New" _ (is_pkg_defined server) :=
  ltac:(apply wp_func_call'; reflexivity).

Global Instance wp_func_call_NewWork :
  WpFuncCall server "NewWork" _ (is_pkg_defined server) :=
  ltac:(apply wp_func_call'; reflexivity).

Global Instance wp_func_call_NewWorkQ :
  WpFuncCall server "NewWorkQ" _ (is_pkg_defined server) :=
  ltac:(apply wp_func_call'; reflexivity).

Global Instance wp_method_call_Server'ptr_Audit :
  WpMethodCall server "Server'ptr" "Audit" _ (is_pkg_defined server) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_Server'ptr_History :
  WpMethodCall server "Server'ptr" "History" _ (is_pkg_defined server) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_Server'ptr_Put :
  WpMethodCall server "Server'ptr" "Put" _ (is_pkg_defined server) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_Server'ptr_Start :
  WpMethodCall server "Server'ptr" "Start" _ (is_pkg_defined server) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_Server'ptr_Worker :
  WpMethodCall server "Server'ptr" "Worker" _ (is_pkg_defined server) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_Server'ptr_addEntries :
  WpMethodCall server "Server'ptr" "addEntries" _ (is_pkg_defined server) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_Server'ptr_checkRequests :
  WpMethodCall server "Server'ptr" "checkRequests" _ (is_pkg_defined server) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_Server'ptr_getBound :
  WpMethodCall server "Server'ptr" "getBound" _ (is_pkg_defined server) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_Server'ptr_getHist :
  WpMethodCall server "Server'ptr" "getHist" _ (is_pkg_defined server) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_Server'ptr_makeEntries :
  WpMethodCall server "Server'ptr" "makeEntries" _ (is_pkg_defined server) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_Server'ptr_makeEntry :
  WpMethodCall server "Server'ptr" "makeEntry" _ (is_pkg_defined server) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_Work'ptr_Finish :
  WpMethodCall server "Work'ptr" "Finish" _ (is_pkg_defined server) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_WorkQ'ptr_Do :
  WpMethodCall server "WorkQ'ptr" "Do" _ (is_pkg_defined server) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_WorkQ'ptr_DoBatch :
  WpMethodCall server "WorkQ'ptr" "DoBatch" _ (is_pkg_defined server) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_WorkQ'ptr_Get :
  WpMethodCall server "WorkQ'ptr" "Get" _ (is_pkg_defined server) :=
  ltac:(apply wp_method_call'; reflexivity).

End names.
End server.
