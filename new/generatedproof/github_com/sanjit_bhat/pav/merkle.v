(* autogenerated by goose proofgen; do not modify *)
Require Export New.proof.proof_prelude.
Require Export New.generatedproof.bytes.
Require Export New.generatedproof.github_com.goose_lang.primitive.
Require Export New.generatedproof.github_com.goose_lang.std.
Require Export New.generatedproof.github_com.sanjit_bhat.pav.cryptoffi.
Require Export New.generatedproof.github_com.sanjit_bhat.pav.cryptoutil.
Require Export New.generatedproof.github_com.tchajed.marshal.
Require Export New.generatedproof.github_com.sanjit_bhat.pav.safemarshal.
Require Export New.golang.theory.

Require Export New.code.github_com.sanjit_bhat.pav.merkle.

Set Default Proof Using "Type".

Module merkle.

(* type merkle.Map *)
Module Map.
Section def.
Context `{ffi_syntax}.
Record t := mk {
  root' : loc;
}.
End def.
End Map.

Section instances.
Context `{ffi_syntax}.
#[local] Transparent merkle.Map.
#[local] Typeclasses Transparent merkle.Map.

Global Instance Map_wf : struct.Wf merkle.Map.
Proof. apply _. Qed.

Global Instance settable_Map : Settable Map.t :=
  settable! Map.mk < Map.root' >.
Global Instance into_val_Map : IntoVal Map.t :=
  {| to_val_def v :=
    struct.val_aux merkle.Map [
    "root" ::= #(Map.root' v)
    ]%struct
  |}.

Global Program Instance into_val_typed_Map : IntoValTyped Map.t merkle.Map :=
{|
  default_val := Map.mk (default_val _);
|}.
Next Obligation. solve_to_val_type. Qed.
Next Obligation. solve_zero_val. Qed.
Next Obligation. solve_to_val_inj. Qed.
Final Obligation. solve_decision. Qed.

Global Instance into_val_struct_field_Map_root : IntoValStructField "root" merkle.Map Map.root'.
Proof. solve_into_val_struct_field. Qed.


Context `{!ffi_model, !ffi_semantics _ _, !ffi_interp _, !heapGS Σ}.
Global Instance wp_struct_make_Map root':
  PureWp True
    (struct.make #merkle.Map (alist_val [
      "root" ::= #root'
    ]))%struct
    #(Map.mk root').
Proof. solve_struct_make_pure_wp. Qed.


Global Instance Map_struct_fields_split dq l (v : Map.t) :
  StructFieldsSplit dq l v (
    "Hroot" ∷ l ↦s[merkle.Map :: "root"]{dq} v.(Map.root')
  ).
Proof.
  rewrite /named.
  apply struct_fields_split_intro.
  unfold_typed_pointsto; split_pointsto_app.

  rewrite -!/(typed_pointsto_def _ _ _) -!typed_pointsto_unseal.

  solve_field_ref_f.
Qed.

End instances.

(* type merkle.node *)
Module node.
Section def.
Context `{ffi_syntax}.
Record t := mk {
  nodeTy' : w8;
  hash' : slice.t;
  child0' : loc;
  child1' : loc;
  label' : slice.t;
  val' : slice.t;
}.
End def.
End node.

Section instances.
Context `{ffi_syntax}.
#[local] Transparent merkle.node.
#[local] Typeclasses Transparent merkle.node.

Global Instance node_wf : struct.Wf merkle.node.
Proof. apply _. Qed.

Global Instance settable_node : Settable node.t :=
  settable! node.mk < node.nodeTy'; node.hash'; node.child0'; node.child1'; node.label'; node.val' >.
Global Instance into_val_node : IntoVal node.t :=
  {| to_val_def v :=
    struct.val_aux merkle.node [
    "nodeTy" ::= #(node.nodeTy' v);
    "hash" ::= #(node.hash' v);
    "child0" ::= #(node.child0' v);
    "child1" ::= #(node.child1' v);
    "label" ::= #(node.label' v);
    "val" ::= #(node.val' v)
    ]%struct
  |}.

Global Program Instance into_val_typed_node : IntoValTyped node.t merkle.node :=
{|
  default_val := node.mk (default_val _) (default_val _) (default_val _) (default_val _) (default_val _) (default_val _);
|}.
Next Obligation. solve_to_val_type. Qed.
Next Obligation. solve_zero_val. Qed.
Next Obligation. solve_to_val_inj. Qed.
Final Obligation. solve_decision. Qed.

Global Instance into_val_struct_field_node_nodeTy : IntoValStructField "nodeTy" merkle.node node.nodeTy'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_node_hash : IntoValStructField "hash" merkle.node node.hash'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_node_child0 : IntoValStructField "child0" merkle.node node.child0'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_node_child1 : IntoValStructField "child1" merkle.node node.child1'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_node_label : IntoValStructField "label" merkle.node node.label'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_node_val : IntoValStructField "val" merkle.node node.val'.
Proof. solve_into_val_struct_field. Qed.


Context `{!ffi_model, !ffi_semantics _ _, !ffi_interp _, !heapGS Σ}.
Global Instance wp_struct_make_node nodeTy' hash' child0' child1' label' val':
  PureWp True
    (struct.make #merkle.node (alist_val [
      "nodeTy" ::= #nodeTy';
      "hash" ::= #hash';
      "child0" ::= #child0';
      "child1" ::= #child1';
      "label" ::= #label';
      "val" ::= #val'
    ]))%struct
    #(node.mk nodeTy' hash' child0' child1' label' val').
Proof. solve_struct_make_pure_wp. Qed.


Global Instance node_struct_fields_split dq l (v : node.t) :
  StructFieldsSplit dq l v (
    "HnodeTy" ∷ l ↦s[merkle.node :: "nodeTy"]{dq} v.(node.nodeTy') ∗
    "Hhash" ∷ l ↦s[merkle.node :: "hash"]{dq} v.(node.hash') ∗
    "Hchild0" ∷ l ↦s[merkle.node :: "child0"]{dq} v.(node.child0') ∗
    "Hchild1" ∷ l ↦s[merkle.node :: "child1"]{dq} v.(node.child1') ∗
    "Hlabel" ∷ l ↦s[merkle.node :: "label"]{dq} v.(node.label') ∗
    "Hval" ∷ l ↦s[merkle.node :: "val"]{dq} v.(node.val')
  ).
Proof.
  rewrite /named.
  apply struct_fields_split_intro.
  unfold_typed_pointsto; split_pointsto_app.

  rewrite -!/(typed_pointsto_def _ _ _) -!typed_pointsto_unseal.
  simpl_one_flatten_struct (# (node.nodeTy' v)) (merkle.node) "nodeTy"%go.
  simpl_one_flatten_struct (# (node.hash' v)) (merkle.node) "hash"%go.
  simpl_one_flatten_struct (# (node.child0' v)) (merkle.node) "child0"%go.
  simpl_one_flatten_struct (# (node.child1' v)) (merkle.node) "child1"%go.
  simpl_one_flatten_struct (# (node.label' v)) (merkle.node) "label"%go.

  solve_field_ref_f.
Qed.

End instances.

(* type merkle.Proof *)
Module Proof.
Section def.
Context `{ffi_syntax}.
Record t := mk {
  Siblings' : slice.t;
  IsOtherLeaf' : bool;
  LeafLabel' : slice.t;
  LeafVal' : slice.t;
}.
End def.
End Proof.

Section instances.
Context `{ffi_syntax}.
#[local] Transparent merkle.Proof.
#[local] Typeclasses Transparent merkle.Proof.

Global Instance Proof_wf : struct.Wf merkle.Proof.
Proof. apply _. Qed.

Global Instance settable_Proof : Settable Proof.t :=
  settable! Proof.mk < Proof.Siblings'; Proof.IsOtherLeaf'; Proof.LeafLabel'; Proof.LeafVal' >.
Global Instance into_val_Proof : IntoVal Proof.t :=
  {| to_val_def v :=
    struct.val_aux merkle.Proof [
    "Siblings" ::= #(Proof.Siblings' v);
    "IsOtherLeaf" ::= #(Proof.IsOtherLeaf' v);
    "LeafLabel" ::= #(Proof.LeafLabel' v);
    "LeafVal" ::= #(Proof.LeafVal' v)
    ]%struct
  |}.

Global Program Instance into_val_typed_Proof : IntoValTyped Proof.t merkle.Proof :=
{|
  default_val := Proof.mk (default_val _) (default_val _) (default_val _) (default_val _);
|}.
Next Obligation. solve_to_val_type. Qed.
Next Obligation. solve_zero_val. Qed.
Next Obligation. solve_to_val_inj. Qed.
Final Obligation. solve_decision. Qed.

Global Instance into_val_struct_field_Proof_Siblings : IntoValStructField "Siblings" merkle.Proof Proof.Siblings'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_Proof_IsOtherLeaf : IntoValStructField "IsOtherLeaf" merkle.Proof Proof.IsOtherLeaf'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_Proof_LeafLabel : IntoValStructField "LeafLabel" merkle.Proof Proof.LeafLabel'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_Proof_LeafVal : IntoValStructField "LeafVal" merkle.Proof Proof.LeafVal'.
Proof. solve_into_val_struct_field. Qed.


Context `{!ffi_model, !ffi_semantics _ _, !ffi_interp _, !heapGS Σ}.
Global Instance wp_struct_make_Proof Siblings' IsOtherLeaf' LeafLabel' LeafVal':
  PureWp True
    (struct.make #merkle.Proof (alist_val [
      "Siblings" ::= #Siblings';
      "IsOtherLeaf" ::= #IsOtherLeaf';
      "LeafLabel" ::= #LeafLabel';
      "LeafVal" ::= #LeafVal'
    ]))%struct
    #(Proof.mk Siblings' IsOtherLeaf' LeafLabel' LeafVal').
Proof. solve_struct_make_pure_wp. Qed.


Global Instance Proof_struct_fields_split dq l (v : Proof.t) :
  StructFieldsSplit dq l v (
    "HSiblings" ∷ l ↦s[merkle.Proof :: "Siblings"]{dq} v.(Proof.Siblings') ∗
    "HIsOtherLeaf" ∷ l ↦s[merkle.Proof :: "IsOtherLeaf"]{dq} v.(Proof.IsOtherLeaf') ∗
    "HLeafLabel" ∷ l ↦s[merkle.Proof :: "LeafLabel"]{dq} v.(Proof.LeafLabel') ∗
    "HLeafVal" ∷ l ↦s[merkle.Proof :: "LeafVal"]{dq} v.(Proof.LeafVal')
  ).
Proof.
  rewrite /named.
  apply struct_fields_split_intro.
  unfold_typed_pointsto; split_pointsto_app.

  rewrite -!/(typed_pointsto_def _ _ _) -!typed_pointsto_unseal.
  simpl_one_flatten_struct (# (Proof.Siblings' v)) (merkle.Proof) "Siblings"%go.
  simpl_one_flatten_struct (# (Proof.IsOtherLeaf' v)) (merkle.Proof) "IsOtherLeaf"%go.
  simpl_one_flatten_struct (# (Proof.LeafLabel' v)) (merkle.Proof) "LeafLabel"%go.

  solve_field_ref_f.
Qed.

End instances.

Section names.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context `{!globalsGS Σ}.
Context {go_ctx : GoContext}.
#[local] Transparent is_pkg_defined is_pkg_defined_pure.

Global Instance is_pkg_defined_pure_merkle : IsPkgDefinedPure merkle :=
  {|
    is_pkg_defined_pure_def go_ctx :=
      is_pkg_defined_pure_single merkle ∧
      is_pkg_defined_pure code.bytes.bytes ∧
      is_pkg_defined_pure code.github_com.goose_lang.primitive.primitive ∧
      is_pkg_defined_pure code.github_com.goose_lang.std.std ∧
      is_pkg_defined_pure code.github_com.sanjit_bhat.pav.cryptoffi.cryptoffi ∧
      is_pkg_defined_pure code.github_com.sanjit_bhat.pav.cryptoutil.cryptoutil ∧
      is_pkg_defined_pure code.github_com.tchajed.marshal.marshal ∧
      is_pkg_defined_pure code.github_com.sanjit_bhat.pav.safemarshal.safemarshal;
  |}.

#[local] Transparent is_pkg_defined_single is_pkg_defined_pure_single.
Global Program Instance is_pkg_defined_merkle : IsPkgDefined merkle :=
  {|
    is_pkg_defined_def go_ctx :=
      (is_pkg_defined_single merkle ∗
       is_pkg_defined code.bytes.bytes ∗
       is_pkg_defined code.github_com.goose_lang.primitive.primitive ∗
       is_pkg_defined code.github_com.goose_lang.std.std ∗
       is_pkg_defined code.github_com.sanjit_bhat.pav.cryptoffi.cryptoffi ∗
       is_pkg_defined code.github_com.sanjit_bhat.pav.cryptoutil.cryptoutil ∗
       is_pkg_defined code.github_com.tchajed.marshal.marshal ∗
       is_pkg_defined code.github_com.sanjit_bhat.pav.safemarshal.safemarshal)%I
  |}.
Final Obligation. iIntros. iFrame "#%". Qed.
#[local] Opaque is_pkg_defined_single is_pkg_defined_pure_single.

Global Instance wp_func_call_put :
  WpFuncCall merkle.put _ (is_pkg_defined merkle) :=
  ltac:(solve_wp_func_call).

Global Instance wp_func_call_getProofCap :
  WpFuncCall merkle.getProofCap _ (is_pkg_defined merkle) :=
  ltac:(solve_wp_func_call).

Global Instance wp_func_call_VerifyMemb :
  WpFuncCall merkle.VerifyMemb _ (is_pkg_defined merkle) :=
  ltac:(solve_wp_func_call).

Global Instance wp_func_call_VerifyNonMemb :
  WpFuncCall merkle.VerifyNonMemb _ (is_pkg_defined merkle) :=
  ltac:(solve_wp_func_call).

Global Instance wp_func_call_VerifyUpdate :
  WpFuncCall merkle.VerifyUpdate _ (is_pkg_defined merkle) :=
  ltac:(solve_wp_func_call).

Global Instance wp_func_call_proofToTree :
  WpFuncCall merkle.proofToTree _ (is_pkg_defined merkle) :=
  ltac:(solve_wp_func_call).

Global Instance wp_func_call_newShell :
  WpFuncCall merkle.newShell _ (is_pkg_defined merkle) :=
  ltac:(solve_wp_func_call).

Global Instance wp_func_call_compEmptyHash :
  WpFuncCall merkle.compEmptyHash _ (is_pkg_defined merkle) :=
  ltac:(solve_wp_func_call).

Global Instance wp_func_call_compLeafHash :
  WpFuncCall merkle.compLeafHash _ (is_pkg_defined merkle) :=
  ltac:(solve_wp_func_call).

Global Instance wp_func_call_compInnerHash :
  WpFuncCall merkle.compInnerHash _ (is_pkg_defined merkle) :=
  ltac:(solve_wp_func_call).

Global Instance wp_func_call_getBit :
  WpFuncCall merkle.getBit _ (is_pkg_defined merkle) :=
  ltac:(solve_wp_func_call).

Global Instance wp_func_call_ProofEncode :
  WpFuncCall merkle.ProofEncode _ (is_pkg_defined merkle) :=
  ltac:(solve_wp_func_call).

Global Instance wp_func_call_ProofDecode :
  WpFuncCall merkle.ProofDecode _ (is_pkg_defined merkle) :=
  ltac:(solve_wp_func_call).

Global Instance wp_method_call_Map'ptr_Hash :
  WpMethodCall (ptrT.id merkle.Map.id) "Hash" _ (is_pkg_defined merkle) :=
  ltac:(solve_wp_method_call).

Global Instance wp_method_call_Map'ptr_Prove :
  WpMethodCall (ptrT.id merkle.Map.id) "Prove" _ (is_pkg_defined merkle) :=
  ltac:(solve_wp_method_call).

Global Instance wp_method_call_Map'ptr_Put :
  WpMethodCall (ptrT.id merkle.Map.id) "Put" _ (is_pkg_defined merkle) :=
  ltac:(solve_wp_method_call).

Global Instance wp_method_call_node'ptr_find :
  WpMethodCall (ptrT.id merkle.node.id) "find" _ (is_pkg_defined merkle) :=
  ltac:(solve_wp_method_call).

Global Instance wp_method_call_node'ptr_getChild :
  WpMethodCall (ptrT.id merkle.node.id) "getChild" _ (is_pkg_defined merkle) :=
  ltac:(solve_wp_method_call).

Global Instance wp_method_call_node'ptr_getHash :
  WpMethodCall (ptrT.id merkle.node.id) "getHash" _ (is_pkg_defined merkle) :=
  ltac:(solve_wp_method_call).

Global Instance wp_method_call_node'ptr_prove :
  WpMethodCall (ptrT.id merkle.node.id) "prove" _ (is_pkg_defined merkle) :=
  ltac:(solve_wp_method_call).

End names.
End merkle.
