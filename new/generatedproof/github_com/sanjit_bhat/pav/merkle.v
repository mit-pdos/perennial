(* autogenerated by goose proofgen; do not modify *)
Require Export New.proof.proof_prelude.
Require Export New.generatedproof.bytes.
Require Export New.generatedproof.github_com.goose_lang.primitive.
Require Export New.generatedproof.github_com.goose_lang.std.
Require Export New.generatedproof.github_com.sanjit_bhat.pav.cryptoffi.
Require Export New.generatedproof.github_com.sanjit_bhat.pav.cryptoutil.
Require Export New.generatedproof.github_com.sanjit_bhat.pav.safemarshal.
Require Export New.generatedproof.github_com.tchajed.marshal.
Require Export New.golang.theory.
Require Export New.code.github_com.sanjit_bhat.pav.merkle.

Set Default Proof Using "Type".

Module merkle.
Module Map.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : merkle.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance Map_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (merkle.Map.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "root" ∷ l.[(merkle.Map.t), "root"] ↦{dq} v.(merkle.Map.root') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance Map_into_val_typed
   :
  IntoValTypedUnderlying (merkle.Map.t) (merkle.Mapⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance Map_access_load_root l (v : (merkle.Map.t)) dq :
  AccessStrict
    (l.[(merkle.Map.t), "root"] ↦{dq} (v.(merkle.Map.root')))
    (l.[(merkle.Map.t), "root"] ↦{dq} (v.(merkle.Map.root')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Map_access_store_root l (v : (merkle.Map.t)) root' :
  AccessStrict
    (l.[(merkle.Map.t), "root"] ↦ (v.(merkle.Map.root')))
    (l.[(merkle.Map.t), "root"] ↦ root')
    (l ↦ v) (l ↦ (v <|(merkle.Map.root') := root'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End Map.

Module node.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : merkle.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance node_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (merkle.node.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "nodeTy" ∷ l.[(merkle.node.t), "nodeTy"] ↦{dq} v.(merkle.node.nodeTy') ∗
      "hash" ∷ l.[(merkle.node.t), "hash"] ↦{dq} v.(merkle.node.hash') ∗
      "child0" ∷ l.[(merkle.node.t), "child0"] ↦{dq} v.(merkle.node.child0') ∗
      "child1" ∷ l.[(merkle.node.t), "child1"] ↦{dq} v.(merkle.node.child1') ∗
      "label" ∷ l.[(merkle.node.t), "label"] ↦{dq} v.(merkle.node.label') ∗
      "val" ∷ l.[(merkle.node.t), "val"] ↦{dq} v.(merkle.node.val') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance node_into_val_typed
   :
  IntoValTypedUnderlying (merkle.node.t) (merkle.nodeⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance node_access_load_nodeTy l (v : (merkle.node.t)) dq :
  AccessStrict
    (l.[(merkle.node.t), "nodeTy"] ↦{dq} (v.(merkle.node.nodeTy')))
    (l.[(merkle.node.t), "nodeTy"] ↦{dq} (v.(merkle.node.nodeTy')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance node_access_store_nodeTy l (v : (merkle.node.t)) nodeTy' :
  AccessStrict
    (l.[(merkle.node.t), "nodeTy"] ↦ (v.(merkle.node.nodeTy')))
    (l.[(merkle.node.t), "nodeTy"] ↦ nodeTy')
    (l ↦ v) (l ↦ (v <|(merkle.node.nodeTy') := nodeTy'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance node_access_load_hash l (v : (merkle.node.t)) dq :
  AccessStrict
    (l.[(merkle.node.t), "hash"] ↦{dq} (v.(merkle.node.hash')))
    (l.[(merkle.node.t), "hash"] ↦{dq} (v.(merkle.node.hash')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance node_access_store_hash l (v : (merkle.node.t)) hash' :
  AccessStrict
    (l.[(merkle.node.t), "hash"] ↦ (v.(merkle.node.hash')))
    (l.[(merkle.node.t), "hash"] ↦ hash')
    (l ↦ v) (l ↦ (v <|(merkle.node.hash') := hash'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance node_access_load_child0 l (v : (merkle.node.t)) dq :
  AccessStrict
    (l.[(merkle.node.t), "child0"] ↦{dq} (v.(merkle.node.child0')))
    (l.[(merkle.node.t), "child0"] ↦{dq} (v.(merkle.node.child0')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance node_access_store_child0 l (v : (merkle.node.t)) child0' :
  AccessStrict
    (l.[(merkle.node.t), "child0"] ↦ (v.(merkle.node.child0')))
    (l.[(merkle.node.t), "child0"] ↦ child0')
    (l ↦ v) (l ↦ (v <|(merkle.node.child0') := child0'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance node_access_load_child1 l (v : (merkle.node.t)) dq :
  AccessStrict
    (l.[(merkle.node.t), "child1"] ↦{dq} (v.(merkle.node.child1')))
    (l.[(merkle.node.t), "child1"] ↦{dq} (v.(merkle.node.child1')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance node_access_store_child1 l (v : (merkle.node.t)) child1' :
  AccessStrict
    (l.[(merkle.node.t), "child1"] ↦ (v.(merkle.node.child1')))
    (l.[(merkle.node.t), "child1"] ↦ child1')
    (l ↦ v) (l ↦ (v <|(merkle.node.child1') := child1'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance node_access_load_label l (v : (merkle.node.t)) dq :
  AccessStrict
    (l.[(merkle.node.t), "label"] ↦{dq} (v.(merkle.node.label')))
    (l.[(merkle.node.t), "label"] ↦{dq} (v.(merkle.node.label')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance node_access_store_label l (v : (merkle.node.t)) label' :
  AccessStrict
    (l.[(merkle.node.t), "label"] ↦ (v.(merkle.node.label')))
    (l.[(merkle.node.t), "label"] ↦ label')
    (l ↦ v) (l ↦ (v <|(merkle.node.label') := label'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance node_access_load_val l (v : (merkle.node.t)) dq :
  AccessStrict
    (l.[(merkle.node.t), "val"] ↦{dq} (v.(merkle.node.val')))
    (l.[(merkle.node.t), "val"] ↦{dq} (v.(merkle.node.val')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance node_access_store_val l (v : (merkle.node.t)) val' :
  AccessStrict
    (l.[(merkle.node.t), "val"] ↦ (v.(merkle.node.val')))
    (l.[(merkle.node.t), "val"] ↦ val')
    (l ↦ v) (l ↦ (v <|(merkle.node.val') := val'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End node.

Module Proof.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : merkle.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance Proof_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (merkle.Proof.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "Siblings" ∷ l.[(merkle.Proof.t), "Siblings"] ↦{dq} v.(merkle.Proof.Siblings') ∗
      "IsOtherLeaf" ∷ l.[(merkle.Proof.t), "IsOtherLeaf"] ↦{dq} v.(merkle.Proof.IsOtherLeaf') ∗
      "LeafLabel" ∷ l.[(merkle.Proof.t), "LeafLabel"] ↦{dq} v.(merkle.Proof.LeafLabel') ∗
      "LeafVal" ∷ l.[(merkle.Proof.t), "LeafVal"] ↦{dq} v.(merkle.Proof.LeafVal') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance Proof_into_val_typed
   :
  IntoValTypedUnderlying (merkle.Proof.t) (merkle.Proofⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance Proof_access_load_Siblings l (v : (merkle.Proof.t)) dq :
  AccessStrict
    (l.[(merkle.Proof.t), "Siblings"] ↦{dq} (v.(merkle.Proof.Siblings')))
    (l.[(merkle.Proof.t), "Siblings"] ↦{dq} (v.(merkle.Proof.Siblings')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Proof_access_store_Siblings l (v : (merkle.Proof.t)) Siblings' :
  AccessStrict
    (l.[(merkle.Proof.t), "Siblings"] ↦ (v.(merkle.Proof.Siblings')))
    (l.[(merkle.Proof.t), "Siblings"] ↦ Siblings')
    (l ↦ v) (l ↦ (v <|(merkle.Proof.Siblings') := Siblings'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Proof_access_load_IsOtherLeaf l (v : (merkle.Proof.t)) dq :
  AccessStrict
    (l.[(merkle.Proof.t), "IsOtherLeaf"] ↦{dq} (v.(merkle.Proof.IsOtherLeaf')))
    (l.[(merkle.Proof.t), "IsOtherLeaf"] ↦{dq} (v.(merkle.Proof.IsOtherLeaf')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Proof_access_store_IsOtherLeaf l (v : (merkle.Proof.t)) IsOtherLeaf' :
  AccessStrict
    (l.[(merkle.Proof.t), "IsOtherLeaf"] ↦ (v.(merkle.Proof.IsOtherLeaf')))
    (l.[(merkle.Proof.t), "IsOtherLeaf"] ↦ IsOtherLeaf')
    (l ↦ v) (l ↦ (v <|(merkle.Proof.IsOtherLeaf') := IsOtherLeaf'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Proof_access_load_LeafLabel l (v : (merkle.Proof.t)) dq :
  AccessStrict
    (l.[(merkle.Proof.t), "LeafLabel"] ↦{dq} (v.(merkle.Proof.LeafLabel')))
    (l.[(merkle.Proof.t), "LeafLabel"] ↦{dq} (v.(merkle.Proof.LeafLabel')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Proof_access_store_LeafLabel l (v : (merkle.Proof.t)) LeafLabel' :
  AccessStrict
    (l.[(merkle.Proof.t), "LeafLabel"] ↦ (v.(merkle.Proof.LeafLabel')))
    (l.[(merkle.Proof.t), "LeafLabel"] ↦ LeafLabel')
    (l ↦ v) (l ↦ (v <|(merkle.Proof.LeafLabel') := LeafLabel'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Proof_access_load_LeafVal l (v : (merkle.Proof.t)) dq :
  AccessStrict
    (l.[(merkle.Proof.t), "LeafVal"] ↦{dq} (v.(merkle.Proof.LeafVal')))
    (l.[(merkle.Proof.t), "LeafVal"] ↦{dq} (v.(merkle.Proof.LeafVal')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Proof_access_store_LeafVal l (v : (merkle.Proof.t)) LeafVal' :
  AccessStrict
    (l.[(merkle.Proof.t), "LeafVal"] ↦ (v.(merkle.Proof.LeafVal')))
    (l.[(merkle.Proof.t), "LeafVal"] ↦ LeafVal')
    (l ↦ v) (l ↦ (v <|(merkle.Proof.LeafVal') := LeafVal'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End Proof.

End merkle.
