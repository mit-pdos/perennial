(* autogenerated by goose proofgen; do not modify *)
Require Export New.proof.proof_prelude.
Require Export New.generatedproof.bytes.
Require Export New.generatedproof.github_com.goose_lang.std.
Require Export New.generatedproof.github_com.sanjit_bhat.pav.advrpc.
Require Export New.generatedproof.github_com.sanjit_bhat.pav.auditor.
Require Export New.generatedproof.github_com.sanjit_bhat.pav.cryptoffi.
Require Export New.generatedproof.github_com.sanjit_bhat.pav.hashchain.
Require Export New.generatedproof.github_com.sanjit_bhat.pav.ktcore.
Require Export New.generatedproof.github_com.sanjit_bhat.pav.merkle.
Require Export New.generatedproof.github_com.sanjit_bhat.pav.server.
Require Export New.golang.theory.

Require Export New.code.github_com.sanjit_bhat.pav.client.

Set Default Proof Using "Type".

Module client.

(* type client.Client *)
Module Client.
Section def.
Context `{ffi_syntax}.
Record t := mk {
  uid' : w64;
  pend' : loc;
  last' : loc;
  serv' : loc;
}.
End def.
End Client.

Section instances.
Context `{ffi_syntax}.

Global Instance settable_Client : Settable Client.t :=
  settable! Client.mk < Client.uid'; Client.pend'; Client.last'; Client.serv' >.
Global Instance into_val_Client : IntoVal Client.t :=
  {| to_val_def v :=
    struct.val_aux client.Client [
    "uid" ::= #(Client.uid' v);
    "pend" ::= #(Client.pend' v);
    "last" ::= #(Client.last' v);
    "serv" ::= #(Client.serv' v)
    ]%struct
  |}.

Global Program Instance into_val_typed_Client : IntoValTyped Client.t client.Client :=
{|
  default_val := Client.mk (default_val _) (default_val _) (default_val _) (default_val _);
|}.
Next Obligation. solve_to_val_type. Qed.
Next Obligation. solve_zero_val. Qed.
Next Obligation. solve_to_val_inj. Qed.
Final Obligation. solve_decision. Qed.

Global Instance into_val_struct_field_Client_uid : IntoValStructField "uid" client.Client Client.uid'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_Client_pend : IntoValStructField "pend" client.Client Client.pend'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_Client_last : IntoValStructField "last" client.Client Client.last'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_Client_serv : IntoValStructField "serv" client.Client Client.serv'.
Proof. solve_into_val_struct_field. Qed.


Context `{!ffi_model, !ffi_semantics _ _, !ffi_interp _, !heapGS Σ}.
Global Instance wp_struct_make_Client uid' pend' last' serv':
  PureWp True
    (struct.make #client.Client (alist_val [
      "uid" ::= #uid';
      "pend" ::= #pend';
      "last" ::= #last';
      "serv" ::= #serv'
    ]))%struct
    #(Client.mk uid' pend' last' serv').
Proof. solve_struct_make_pure_wp. Qed.


Global Instance Client_struct_fields_split dq l (v : Client.t) :
  StructFieldsSplit dq l v (
    "Huid" ∷ l ↦s[client.Client :: "uid"]{dq} v.(Client.uid') ∗
    "Hpend" ∷ l ↦s[client.Client :: "pend"]{dq} v.(Client.pend') ∗
    "Hlast" ∷ l ↦s[client.Client :: "last"]{dq} v.(Client.last') ∗
    "Hserv" ∷ l ↦s[client.Client :: "serv"]{dq} v.(Client.serv')
  ).
Proof.
  rewrite /named.
  apply struct_fields_split_intro.
  unfold_typed_pointsto; split_pointsto_app.

  rewrite -!/(typed_pointsto_def _ _ _) -!typed_pointsto_unseal.
  simpl_one_flatten_struct (# (Client.uid' v)) client.Client "uid"%go.
  simpl_one_flatten_struct (# (Client.pend' v)) client.Client "pend"%go.
  simpl_one_flatten_struct (# (Client.last' v)) client.Client "last"%go.

  solve_field_ref_f.
Qed.

End instances.

(* type client.pending *)
Module pending.
Section def.
Context `{ffi_syntax}.
Record t := mk {
  nextVer' : w64;
  isPending' : bool;
  pk' : slice.t;
}.
End def.
End pending.

Section instances.
Context `{ffi_syntax}.

Global Instance settable_pending : Settable pending.t :=
  settable! pending.mk < pending.nextVer'; pending.isPending'; pending.pk' >.
Global Instance into_val_pending : IntoVal pending.t :=
  {| to_val_def v :=
    struct.val_aux client.pending [
    "nextVer" ::= #(pending.nextVer' v);
    "isPending" ::= #(pending.isPending' v);
    "pk" ::= #(pending.pk' v)
    ]%struct
  |}.

Global Program Instance into_val_typed_pending : IntoValTyped pending.t client.pending :=
{|
  default_val := pending.mk (default_val _) (default_val _) (default_val _);
|}.
Next Obligation. solve_to_val_type. Qed.
Next Obligation. solve_zero_val. Qed.
Next Obligation. solve_to_val_inj. Qed.
Final Obligation. solve_decision. Qed.

Global Instance into_val_struct_field_pending_nextVer : IntoValStructField "nextVer" client.pending pending.nextVer'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_pending_isPending : IntoValStructField "isPending" client.pending pending.isPending'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_pending_pk : IntoValStructField "pk" client.pending pending.pk'.
Proof. solve_into_val_struct_field. Qed.


Context `{!ffi_model, !ffi_semantics _ _, !ffi_interp _, !heapGS Σ}.
Global Instance wp_struct_make_pending nextVer' isPending' pk':
  PureWp True
    (struct.make #client.pending (alist_val [
      "nextVer" ::= #nextVer';
      "isPending" ::= #isPending';
      "pk" ::= #pk'
    ]))%struct
    #(pending.mk nextVer' isPending' pk').
Proof. solve_struct_make_pure_wp. Qed.


Global Instance pending_struct_fields_split dq l (v : pending.t) :
  StructFieldsSplit dq l v (
    "HnextVer" ∷ l ↦s[client.pending :: "nextVer"]{dq} v.(pending.nextVer') ∗
    "HisPending" ∷ l ↦s[client.pending :: "isPending"]{dq} v.(pending.isPending') ∗
    "Hpk" ∷ l ↦s[client.pending :: "pk"]{dq} v.(pending.pk')
  ).
Proof.
  rewrite /named.
  apply struct_fields_split_intro.
  unfold_typed_pointsto; split_pointsto_app.

  rewrite -!/(typed_pointsto_def _ _ _) -!typed_pointsto_unseal.
  simpl_one_flatten_struct (# (pending.nextVer' v)) client.pending "nextVer"%go.
  simpl_one_flatten_struct (# (pending.isPending' v)) client.pending "isPending"%go.

  solve_field_ref_f.
Qed.

End instances.

(* type client.epoch *)
Module epoch.
Section def.
Context `{ffi_syntax}.
Record t := mk {
  epoch' : w64;
  dig' : slice.t;
  link' : slice.t;
  sig' : slice.t;
}.
End def.
End epoch.

Section instances.
Context `{ffi_syntax}.

Global Instance settable_epoch : Settable epoch.t :=
  settable! epoch.mk < epoch.epoch'; epoch.dig'; epoch.link'; epoch.sig' >.
Global Instance into_val_epoch : IntoVal epoch.t :=
  {| to_val_def v :=
    struct.val_aux client.epoch [
    "epoch" ::= #(epoch.epoch' v);
    "dig" ::= #(epoch.dig' v);
    "link" ::= #(epoch.link' v);
    "sig" ::= #(epoch.sig' v)
    ]%struct
  |}.

Global Program Instance into_val_typed_epoch : IntoValTyped epoch.t client.epoch :=
{|
  default_val := epoch.mk (default_val _) (default_val _) (default_val _) (default_val _);
|}.
Next Obligation. solve_to_val_type. Qed.
Next Obligation. solve_zero_val. Qed.
Next Obligation. solve_to_val_inj. Qed.
Final Obligation. solve_decision. Qed.

Global Instance into_val_struct_field_epoch_epoch : IntoValStructField "epoch" client.epoch epoch.epoch'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_epoch_dig : IntoValStructField "dig" client.epoch epoch.dig'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_epoch_link : IntoValStructField "link" client.epoch epoch.link'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_epoch_sig : IntoValStructField "sig" client.epoch epoch.sig'.
Proof. solve_into_val_struct_field. Qed.


Context `{!ffi_model, !ffi_semantics _ _, !ffi_interp _, !heapGS Σ}.
Global Instance wp_struct_make_epoch epoch' dig' link' sig':
  PureWp True
    (struct.make #client.epoch (alist_val [
      "epoch" ::= #epoch';
      "dig" ::= #dig';
      "link" ::= #link';
      "sig" ::= #sig'
    ]))%struct
    #(epoch.mk epoch' dig' link' sig').
Proof. solve_struct_make_pure_wp. Qed.


Global Instance epoch_struct_fields_split dq l (v : epoch.t) :
  StructFieldsSplit dq l v (
    "Hepoch" ∷ l ↦s[client.epoch :: "epoch"]{dq} v.(epoch.epoch') ∗
    "Hdig" ∷ l ↦s[client.epoch :: "dig"]{dq} v.(epoch.dig') ∗
    "Hlink" ∷ l ↦s[client.epoch :: "link"]{dq} v.(epoch.link') ∗
    "Hsig" ∷ l ↦s[client.epoch :: "sig"]{dq} v.(epoch.sig')
  ).
Proof.
  rewrite /named.
  apply struct_fields_split_intro.
  unfold_typed_pointsto; split_pointsto_app.

  rewrite -!/(typed_pointsto_def _ _ _) -!typed_pointsto_unseal.
  simpl_one_flatten_struct (# (epoch.epoch' v)) client.epoch "epoch"%go.
  simpl_one_flatten_struct (# (epoch.dig' v)) client.epoch "dig"%go.
  simpl_one_flatten_struct (# (epoch.link' v)) client.epoch "link"%go.

  solve_field_ref_f.
Qed.

End instances.

(* type client.serv *)
Module serv.
Section def.
Context `{ffi_syntax}.
Record t := mk {
  cli' : loc;
  sigPk' : cryptoffi.SigPublicKey.t;
  vrfPk' : loc;
  vrfSig' : slice.t;
}.
End def.
End serv.

Section instances.
Context `{ffi_syntax}.

Global Instance settable_serv : Settable serv.t :=
  settable! serv.mk < serv.cli'; serv.sigPk'; serv.vrfPk'; serv.vrfSig' >.
Global Instance into_val_serv : IntoVal serv.t :=
  {| to_val_def v :=
    struct.val_aux client.serv [
    "cli" ::= #(serv.cli' v);
    "sigPk" ::= #(serv.sigPk' v);
    "vrfPk" ::= #(serv.vrfPk' v);
    "vrfSig" ::= #(serv.vrfSig' v)
    ]%struct
  |}.

Global Program Instance into_val_typed_serv : IntoValTyped serv.t client.serv :=
{|
  default_val := serv.mk (default_val _) (default_val _) (default_val _) (default_val _);
|}.
Next Obligation. solve_to_val_type. Qed.
Next Obligation. solve_zero_val. Qed.
Next Obligation. solve_to_val_inj. Qed.
Final Obligation. solve_decision. Qed.

Global Instance into_val_struct_field_serv_cli : IntoValStructField "cli" client.serv serv.cli'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_serv_sigPk : IntoValStructField "sigPk" client.serv serv.sigPk'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_serv_vrfPk : IntoValStructField "vrfPk" client.serv serv.vrfPk'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_serv_vrfSig : IntoValStructField "vrfSig" client.serv serv.vrfSig'.
Proof. solve_into_val_struct_field. Qed.


Context `{!ffi_model, !ffi_semantics _ _, !ffi_interp _, !heapGS Σ}.
Global Instance wp_struct_make_serv cli' sigPk' vrfPk' vrfSig':
  PureWp True
    (struct.make #client.serv (alist_val [
      "cli" ::= #cli';
      "sigPk" ::= #sigPk';
      "vrfPk" ::= #vrfPk';
      "vrfSig" ::= #vrfSig'
    ]))%struct
    #(serv.mk cli' sigPk' vrfPk' vrfSig').
Proof. solve_struct_make_pure_wp. Qed.


Global Instance serv_struct_fields_split dq l (v : serv.t) :
  StructFieldsSplit dq l v (
    "Hcli" ∷ l ↦s[client.serv :: "cli"]{dq} v.(serv.cli') ∗
    "HsigPk" ∷ l ↦s[client.serv :: "sigPk"]{dq} v.(serv.sigPk') ∗
    "HvrfPk" ∷ l ↦s[client.serv :: "vrfPk"]{dq} v.(serv.vrfPk') ∗
    "HvrfSig" ∷ l ↦s[client.serv :: "vrfSig"]{dq} v.(serv.vrfSig')
  ).
Proof.
  rewrite /named.
  apply struct_fields_split_intro.
  unfold_typed_pointsto; split_pointsto_app.

  rewrite -!/(typed_pointsto_def _ _ _) -!typed_pointsto_unseal.
  simpl_one_flatten_struct (# (serv.cli' v)) client.serv "cli"%go.
  simpl_one_flatten_struct (# (serv.sigPk' v)) client.serv "sigPk"%go.
  simpl_one_flatten_struct (# (serv.vrfPk' v)) client.serv "vrfPk"%go.

  solve_field_ref_f.
Qed.

End instances.

(* type client.Evid *)
Module Evid.
Section def.
Context `{ffi_syntax}.
Record t := mk {
  vrf' : loc;
  link' : loc;
}.
End def.
End Evid.

Section instances.
Context `{ffi_syntax}.

Global Instance settable_Evid : Settable Evid.t :=
  settable! Evid.mk < Evid.vrf'; Evid.link' >.
Global Instance into_val_Evid : IntoVal Evid.t :=
  {| to_val_def v :=
    struct.val_aux client.Evid [
    "vrf" ::= #(Evid.vrf' v);
    "link" ::= #(Evid.link' v)
    ]%struct
  |}.

Global Program Instance into_val_typed_Evid : IntoValTyped Evid.t client.Evid :=
{|
  default_val := Evid.mk (default_val _) (default_val _);
|}.
Next Obligation. solve_to_val_type. Qed.
Next Obligation. solve_zero_val. Qed.
Next Obligation. solve_to_val_inj. Qed.
Final Obligation. solve_decision. Qed.

Global Instance into_val_struct_field_Evid_vrf : IntoValStructField "vrf" client.Evid Evid.vrf'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_Evid_link : IntoValStructField "link" client.Evid Evid.link'.
Proof. solve_into_val_struct_field. Qed.


Context `{!ffi_model, !ffi_semantics _ _, !ffi_interp _, !heapGS Σ}.
Global Instance wp_struct_make_Evid vrf' link':
  PureWp True
    (struct.make #client.Evid (alist_val [
      "vrf" ::= #vrf';
      "link" ::= #link'
    ]))%struct
    #(Evid.mk vrf' link').
Proof. solve_struct_make_pure_wp. Qed.


Global Instance Evid_struct_fields_split dq l (v : Evid.t) :
  StructFieldsSplit dq l v (
    "Hvrf" ∷ l ↦s[client.Evid :: "vrf"]{dq} v.(Evid.vrf') ∗
    "Hlink" ∷ l ↦s[client.Evid :: "link"]{dq} v.(Evid.link')
  ).
Proof.
  rewrite /named.
  apply struct_fields_split_intro.
  unfold_typed_pointsto; split_pointsto_app.

  rewrite -!/(typed_pointsto_def _ _ _) -!typed_pointsto_unseal.
  simpl_one_flatten_struct (# (Evid.vrf' v)) client.Evid "vrf"%go.

  solve_field_ref_f.
Qed.

End instances.

(* type client.evidVrf *)
Module evidVrf.
Section def.
Context `{ffi_syntax}.
Record t := mk {
  vrfPk0' : slice.t;
  sig0' : slice.t;
  vrfPk1' : slice.t;
  sig1' : slice.t;
}.
End def.
End evidVrf.

Section instances.
Context `{ffi_syntax}.

Global Instance settable_evidVrf : Settable evidVrf.t :=
  settable! evidVrf.mk < evidVrf.vrfPk0'; evidVrf.sig0'; evidVrf.vrfPk1'; evidVrf.sig1' >.
Global Instance into_val_evidVrf : IntoVal evidVrf.t :=
  {| to_val_def v :=
    struct.val_aux client.evidVrf [
    "vrfPk0" ::= #(evidVrf.vrfPk0' v);
    "sig0" ::= #(evidVrf.sig0' v);
    "vrfPk1" ::= #(evidVrf.vrfPk1' v);
    "sig1" ::= #(evidVrf.sig1' v)
    ]%struct
  |}.

Global Program Instance into_val_typed_evidVrf : IntoValTyped evidVrf.t client.evidVrf :=
{|
  default_val := evidVrf.mk (default_val _) (default_val _) (default_val _) (default_val _);
|}.
Next Obligation. solve_to_val_type. Qed.
Next Obligation. solve_zero_val. Qed.
Next Obligation. solve_to_val_inj. Qed.
Final Obligation. solve_decision. Qed.

Global Instance into_val_struct_field_evidVrf_vrfPk0 : IntoValStructField "vrfPk0" client.evidVrf evidVrf.vrfPk0'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_evidVrf_sig0 : IntoValStructField "sig0" client.evidVrf evidVrf.sig0'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_evidVrf_vrfPk1 : IntoValStructField "vrfPk1" client.evidVrf evidVrf.vrfPk1'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_evidVrf_sig1 : IntoValStructField "sig1" client.evidVrf evidVrf.sig1'.
Proof. solve_into_val_struct_field. Qed.


Context `{!ffi_model, !ffi_semantics _ _, !ffi_interp _, !heapGS Σ}.
Global Instance wp_struct_make_evidVrf vrfPk0' sig0' vrfPk1' sig1':
  PureWp True
    (struct.make #client.evidVrf (alist_val [
      "vrfPk0" ::= #vrfPk0';
      "sig0" ::= #sig0';
      "vrfPk1" ::= #vrfPk1';
      "sig1" ::= #sig1'
    ]))%struct
    #(evidVrf.mk vrfPk0' sig0' vrfPk1' sig1').
Proof. solve_struct_make_pure_wp. Qed.


Global Instance evidVrf_struct_fields_split dq l (v : evidVrf.t) :
  StructFieldsSplit dq l v (
    "HvrfPk0" ∷ l ↦s[client.evidVrf :: "vrfPk0"]{dq} v.(evidVrf.vrfPk0') ∗
    "Hsig0" ∷ l ↦s[client.evidVrf :: "sig0"]{dq} v.(evidVrf.sig0') ∗
    "HvrfPk1" ∷ l ↦s[client.evidVrf :: "vrfPk1"]{dq} v.(evidVrf.vrfPk1') ∗
    "Hsig1" ∷ l ↦s[client.evidVrf :: "sig1"]{dq} v.(evidVrf.sig1')
  ).
Proof.
  rewrite /named.
  apply struct_fields_split_intro.
  unfold_typed_pointsto; split_pointsto_app.

  rewrite -!/(typed_pointsto_def _ _ _) -!typed_pointsto_unseal.
  simpl_one_flatten_struct (# (evidVrf.vrfPk0' v)) client.evidVrf "vrfPk0"%go.
  simpl_one_flatten_struct (# (evidVrf.sig0' v)) client.evidVrf "sig0"%go.
  simpl_one_flatten_struct (# (evidVrf.vrfPk1' v)) client.evidVrf "vrfPk1"%go.

  solve_field_ref_f.
Qed.

End instances.

(* type client.evidLink *)
Module evidLink.
Section def.
Context `{ffi_syntax}.
Record t := mk {
  epoch' : w64;
  link0' : slice.t;
  sig0' : slice.t;
  link1' : slice.t;
  sig1' : slice.t;
}.
End def.
End evidLink.

Section instances.
Context `{ffi_syntax}.

Global Instance settable_evidLink : Settable evidLink.t :=
  settable! evidLink.mk < evidLink.epoch'; evidLink.link0'; evidLink.sig0'; evidLink.link1'; evidLink.sig1' >.
Global Instance into_val_evidLink : IntoVal evidLink.t :=
  {| to_val_def v :=
    struct.val_aux client.evidLink [
    "epoch" ::= #(evidLink.epoch' v);
    "link0" ::= #(evidLink.link0' v);
    "sig0" ::= #(evidLink.sig0' v);
    "link1" ::= #(evidLink.link1' v);
    "sig1" ::= #(evidLink.sig1' v)
    ]%struct
  |}.

Global Program Instance into_val_typed_evidLink : IntoValTyped evidLink.t client.evidLink :=
{|
  default_val := evidLink.mk (default_val _) (default_val _) (default_val _) (default_val _) (default_val _);
|}.
Next Obligation. solve_to_val_type. Qed.
Next Obligation. solve_zero_val. Qed.
Next Obligation. solve_to_val_inj. Qed.
Final Obligation. solve_decision. Qed.

Global Instance into_val_struct_field_evidLink_epoch : IntoValStructField "epoch" client.evidLink evidLink.epoch'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_evidLink_link0 : IntoValStructField "link0" client.evidLink evidLink.link0'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_evidLink_sig0 : IntoValStructField "sig0" client.evidLink evidLink.sig0'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_evidLink_link1 : IntoValStructField "link1" client.evidLink evidLink.link1'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_evidLink_sig1 : IntoValStructField "sig1" client.evidLink evidLink.sig1'.
Proof. solve_into_val_struct_field. Qed.


Context `{!ffi_model, !ffi_semantics _ _, !ffi_interp _, !heapGS Σ}.
Global Instance wp_struct_make_evidLink epoch' link0' sig0' link1' sig1':
  PureWp True
    (struct.make #client.evidLink (alist_val [
      "epoch" ::= #epoch';
      "link0" ::= #link0';
      "sig0" ::= #sig0';
      "link1" ::= #link1';
      "sig1" ::= #sig1'
    ]))%struct
    #(evidLink.mk epoch' link0' sig0' link1' sig1').
Proof. solve_struct_make_pure_wp. Qed.


Global Instance evidLink_struct_fields_split dq l (v : evidLink.t) :
  StructFieldsSplit dq l v (
    "Hepoch" ∷ l ↦s[client.evidLink :: "epoch"]{dq} v.(evidLink.epoch') ∗
    "Hlink0" ∷ l ↦s[client.evidLink :: "link0"]{dq} v.(evidLink.link0') ∗
    "Hsig0" ∷ l ↦s[client.evidLink :: "sig0"]{dq} v.(evidLink.sig0') ∗
    "Hlink1" ∷ l ↦s[client.evidLink :: "link1"]{dq} v.(evidLink.link1') ∗
    "Hsig1" ∷ l ↦s[client.evidLink :: "sig1"]{dq} v.(evidLink.sig1')
  ).
Proof.
  rewrite /named.
  apply struct_fields_split_intro.
  unfold_typed_pointsto; split_pointsto_app.

  rewrite -!/(typed_pointsto_def _ _ _) -!typed_pointsto_unseal.
  simpl_one_flatten_struct (# (evidLink.epoch' v)) client.evidLink "epoch"%go.
  simpl_one_flatten_struct (# (evidLink.link0' v)) client.evidLink "link0"%go.
  simpl_one_flatten_struct (# (evidLink.sig0' v)) client.evidLink "sig0"%go.
  simpl_one_flatten_struct (# (evidLink.link1' v)) client.evidLink "link1"%go.

  solve_field_ref_f.
Qed.

End instances.

Section names.

Class GlobalAddrs :=
{
}.

Context `{!GlobalAddrs}.
Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context `{!goGlobalsGS Σ}.

Definition var_addrs : list (go_string * loc) := [
  ].

Global Instance is_pkg_defined_instance : IsPkgDefined client :=
{|
  is_pkg_defined := is_global_definitions client var_addrs;
|}.

Definition own_allocated : iProp Σ :=
True.

Global Instance wp_func_call_New :
  WpFuncCall client "New" _ (is_pkg_defined client) :=
  ltac:(apply wp_func_call'; reflexivity).

Global Instance wp_func_call_CheckMemb :
  WpFuncCall client "CheckMemb" _ (is_pkg_defined client) :=
  ltac:(apply wp_func_call'; reflexivity).

Global Instance wp_func_call_CheckHist :
  WpFuncCall client "CheckHist" _ (is_pkg_defined client) :=
  ltac:(apply wp_func_call'; reflexivity).

Global Instance wp_func_call_CheckNonMemb :
  WpFuncCall client "CheckNonMemb" _ (is_pkg_defined client) :=
  ltac:(apply wp_func_call'; reflexivity).

Global Instance wp_method_call_Client'ptr_Audit :
  WpMethodCall client "Client'ptr" "Audit" _ (is_pkg_defined client) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_Client'ptr_Get :
  WpMethodCall client "Client'ptr" "Get" _ (is_pkg_defined client) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_Client'ptr_Put :
  WpMethodCall client "Client'ptr" "Put" _ (is_pkg_defined client) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_Client'ptr_SelfMon :
  WpMethodCall client "Client'ptr" "SelfMon" _ (is_pkg_defined client) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_Client'ptr_getChainExt :
  WpMethodCall client "Client'ptr" "getChainExt" _ (is_pkg_defined client) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_Evid'ptr_Check :
  WpMethodCall client "Evid'ptr" "Check" _ (is_pkg_defined client) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_evidVrf'ptr_Check :
  WpMethodCall client "evidVrf'ptr" "Check" _ (is_pkg_defined client) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_evidLink'ptr_Check :
  WpMethodCall client "evidLink'ptr" "Check" _ (is_pkg_defined client) :=
  ltac:(apply wp_method_call'; reflexivity).

End names.
End client.
