(* autogenerated by goose proofgen; do not modify *)
Require Export New.proof.proof_prelude.
Require Export New.generatedproof.bytes.
Require Export New.generatedproof.github_com.goose_lang.std.
Require Export New.generatedproof.github_com.sanjit_bhat.pav.advrpc.
Require Export New.generatedproof.github_com.sanjit_bhat.pav.auditor.
Require Export New.generatedproof.github_com.sanjit_bhat.pav.cryptoffi.
Require Export New.generatedproof.github_com.sanjit_bhat.pav.hashchain.
Require Export New.generatedproof.github_com.sanjit_bhat.pav.ktcore.
Require Export New.generatedproof.github_com.sanjit_bhat.pav.merkle.
Require Export New.generatedproof.github_com.sanjit_bhat.pav.server.
Require Export New.golang.theory.

Require Export New.code.github_com.sanjit_bhat.pav.client.

Set Default Proof Using "Type".

Module client.

(* type client.Client *)
Module Client.
Section def.
Context `{ffi_syntax}.

Record t := mk {
  uid' : w64;
  pend' : loc;
  last' : loc;
  serv' : loc;
}.
End def.
End Client.

Section instances.
Context `{ffi_syntax}.
#[local] Transparent client.Client.
#[local] Typeclasses Transparent client.Client.

Global Instance Client_wf : struct.Wf client.Client.
Proof. apply _. Qed.

Global Instance settable_Client : Settable Client.t :=
  settable! Client.mk < Client.uid'; Client.pend'; Client.last'; Client.serv' >.
Global Instance into_val_Client : IntoVal Client.t :=
  {| to_val_def v :=
    struct.val_aux client.Client [
    "uid" ::= #(Client.uid' v);
    "pend" ::= #(Client.pend' v);
    "last" ::= #(Client.last' v);
    "serv" ::= #(Client.serv' v)
    ]%struct
  |}.

Global Program Instance into_val_typed_Client : IntoValTyped Client.t client.Client :=
{|
  default_val := Client.mk (default_val _) (default_val _) (default_val _) (default_val _);
|}.
Next Obligation. solve_to_val_type. Qed.
Next Obligation. solve_zero_val. Qed.
Next Obligation. solve_to_val_inj. Qed.
Final Obligation. solve_decision. Qed.

Global Instance into_val_struct_field_Client_uid : IntoValStructField "uid" client.Client Client.uid'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_Client_pend : IntoValStructField "pend" client.Client Client.pend'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_Client_last : IntoValStructField "last" client.Client Client.last'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_Client_serv : IntoValStructField "serv" client.Client Client.serv'.
Proof. solve_into_val_struct_field. Qed.


Context `{!ffi_model, !ffi_semantics _ _, !ffi_interp _, !heapGS Σ}.


Global Instance Client_struct_fields_split dq l (v : Client.t) :
  StructFieldsSplit dq l v (
    "Huid" ∷ l ↦s[client.Client :: "uid"]{dq} v.(Client.uid') ∗
    "Hpend" ∷ l ↦s[client.Client :: "pend"]{dq} v.(Client.pend') ∗
    "Hlast" ∷ l ↦s[client.Client :: "last"]{dq} v.(Client.last') ∗
    "Hserv" ∷ l ↦s[client.Client :: "serv"]{dq} v.(Client.serv')
  ).
Proof.
  rewrite /named.
  apply struct_fields_split_intro.
  unfold_typed_pointsto; split_pointsto_app.

  rewrite -!/(typed_pointsto_def _ _ _) -!typed_pointsto_unseal.
  simpl_one_flatten_struct (# (Client.uid' v)) (client.Client) "uid"%go.
  simpl_one_flatten_struct (# (Client.pend' v)) (client.Client) "pend"%go.
  simpl_one_flatten_struct (# (Client.last' v)) (client.Client) "last"%go.

  solve_field_ref_f.
Qed.

End instances.

(* type client.pending *)
Module pending.
Section def.
Context `{ffi_syntax}.

Record t := mk {
  nextVer' : w64;
  isPending' : bool;
  pk' : slice.t;
}.
End def.
End pending.

Section instances.
Context `{ffi_syntax}.
#[local] Transparent client.pending.
#[local] Typeclasses Transparent client.pending.

Global Instance pending_wf : struct.Wf client.pending.
Proof. apply _. Qed.

Global Instance settable_pending : Settable pending.t :=
  settable! pending.mk < pending.nextVer'; pending.isPending'; pending.pk' >.
Global Instance into_val_pending : IntoVal pending.t :=
  {| to_val_def v :=
    struct.val_aux client.pending [
    "nextVer" ::= #(pending.nextVer' v);
    "isPending" ::= #(pending.isPending' v);
    "pk" ::= #(pending.pk' v)
    ]%struct
  |}.

Global Program Instance into_val_typed_pending : IntoValTyped pending.t client.pending :=
{|
  default_val := pending.mk (default_val _) (default_val _) (default_val _);
|}.
Next Obligation. solve_to_val_type. Qed.
Next Obligation. solve_zero_val. Qed.
Next Obligation. solve_to_val_inj. Qed.
Final Obligation. solve_decision. Qed.

Global Instance into_val_struct_field_pending_nextVer : IntoValStructField "nextVer" client.pending pending.nextVer'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_pending_isPending : IntoValStructField "isPending" client.pending pending.isPending'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_pending_pk : IntoValStructField "pk" client.pending pending.pk'.
Proof. solve_into_val_struct_field. Qed.


Context `{!ffi_model, !ffi_semantics _ _, !ffi_interp _, !heapGS Σ}.


Global Instance pending_struct_fields_split dq l (v : pending.t) :
  StructFieldsSplit dq l v (
    "HnextVer" ∷ l ↦s[client.pending :: "nextVer"]{dq} v.(pending.nextVer') ∗
    "HisPending" ∷ l ↦s[client.pending :: "isPending"]{dq} v.(pending.isPending') ∗
    "Hpk" ∷ l ↦s[client.pending :: "pk"]{dq} v.(pending.pk')
  ).
Proof.
  rewrite /named.
  apply struct_fields_split_intro.
  unfold_typed_pointsto; split_pointsto_app.

  rewrite -!/(typed_pointsto_def _ _ _) -!typed_pointsto_unseal.
  simpl_one_flatten_struct (# (pending.nextVer' v)) (client.pending) "nextVer"%go.
  simpl_one_flatten_struct (# (pending.isPending' v)) (client.pending) "isPending"%go.

  solve_field_ref_f.
Qed.

End instances.

(* type client.epoch *)
Module epoch.
Section def.
Context `{ffi_syntax}.

Record t := mk {
  epoch' : w64;
  dig' : slice.t;
  link' : slice.t;
  sig' : slice.t;
}.
End def.
End epoch.

Section instances.
Context `{ffi_syntax}.
#[local] Transparent client.epoch.
#[local] Typeclasses Transparent client.epoch.

Global Instance epoch_wf : struct.Wf client.epoch.
Proof. apply _. Qed.

Global Instance settable_epoch : Settable epoch.t :=
  settable! epoch.mk < epoch.epoch'; epoch.dig'; epoch.link'; epoch.sig' >.
Global Instance into_val_epoch : IntoVal epoch.t :=
  {| to_val_def v :=
    struct.val_aux client.epoch [
    "epoch" ::= #(epoch.epoch' v);
    "dig" ::= #(epoch.dig' v);
    "link" ::= #(epoch.link' v);
    "sig" ::= #(epoch.sig' v)
    ]%struct
  |}.

Global Program Instance into_val_typed_epoch : IntoValTyped epoch.t client.epoch :=
{|
  default_val := epoch.mk (default_val _) (default_val _) (default_val _) (default_val _);
|}.
Next Obligation. solve_to_val_type. Qed.
Next Obligation. solve_zero_val. Qed.
Next Obligation. solve_to_val_inj. Qed.
Final Obligation. solve_decision. Qed.

Global Instance into_val_struct_field_epoch_epoch : IntoValStructField "epoch" client.epoch epoch.epoch'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_epoch_dig : IntoValStructField "dig" client.epoch epoch.dig'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_epoch_link : IntoValStructField "link" client.epoch epoch.link'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_epoch_sig : IntoValStructField "sig" client.epoch epoch.sig'.
Proof. solve_into_val_struct_field. Qed.


Context `{!ffi_model, !ffi_semantics _ _, !ffi_interp _, !heapGS Σ}.


Global Instance epoch_struct_fields_split dq l (v : epoch.t) :
  StructFieldsSplit dq l v (
    "Hepoch" ∷ l ↦s[client.epoch :: "epoch"]{dq} v.(epoch.epoch') ∗
    "Hdig" ∷ l ↦s[client.epoch :: "dig"]{dq} v.(epoch.dig') ∗
    "Hlink" ∷ l ↦s[client.epoch :: "link"]{dq} v.(epoch.link') ∗
    "Hsig" ∷ l ↦s[client.epoch :: "sig"]{dq} v.(epoch.sig')
  ).
Proof.
  rewrite /named.
  apply struct_fields_split_intro.
  unfold_typed_pointsto; split_pointsto_app.

  rewrite -!/(typed_pointsto_def _ _ _) -!typed_pointsto_unseal.
  simpl_one_flatten_struct (# (epoch.epoch' v)) (client.epoch) "epoch"%go.
  simpl_one_flatten_struct (# (epoch.dig' v)) (client.epoch) "dig"%go.
  simpl_one_flatten_struct (# (epoch.link' v)) (client.epoch) "link"%go.

  solve_field_ref_f.
Qed.

End instances.

(* type client.serv *)
Module serv.
Section def.
Context `{ffi_syntax}.

Record t := mk {
  cli' : loc;
  sigPk' : cryptoffi.SigPublicKey.t;
  vrfPk' : loc;
  vrfSig' : slice.t;
}.
End def.
End serv.

Section instances.
Context `{ffi_syntax}.
#[local] Transparent client.serv.
#[local] Typeclasses Transparent client.serv.

Global Instance serv_wf : struct.Wf client.serv.
Proof. apply _. Qed.

Global Instance settable_serv : Settable serv.t :=
  settable! serv.mk < serv.cli'; serv.sigPk'; serv.vrfPk'; serv.vrfSig' >.
Global Instance into_val_serv : IntoVal serv.t :=
  {| to_val_def v :=
    struct.val_aux client.serv [
    "cli" ::= #(serv.cli' v);
    "sigPk" ::= #(serv.sigPk' v);
    "vrfPk" ::= #(serv.vrfPk' v);
    "vrfSig" ::= #(serv.vrfSig' v)
    ]%struct
  |}.

Global Program Instance into_val_typed_serv : IntoValTyped serv.t client.serv :=
{|
  default_val := serv.mk (default_val _) (default_val _) (default_val _) (default_val _);
|}.
Next Obligation. solve_to_val_type. Qed.
Next Obligation. solve_zero_val. Qed.
Next Obligation. solve_to_val_inj. Qed.
Final Obligation. solve_decision. Qed.

Global Instance into_val_struct_field_serv_cli : IntoValStructField "cli" client.serv serv.cli'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_serv_sigPk : IntoValStructField "sigPk" client.serv serv.sigPk'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_serv_vrfPk : IntoValStructField "vrfPk" client.serv serv.vrfPk'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_serv_vrfSig : IntoValStructField "vrfSig" client.serv serv.vrfSig'.
Proof. solve_into_val_struct_field. Qed.


Context `{!ffi_model, !ffi_semantics _ _, !ffi_interp _, !heapGS Σ}.


Global Instance serv_struct_fields_split dq l (v : serv.t) :
  StructFieldsSplit dq l v (
    "Hcli" ∷ l ↦s[client.serv :: "cli"]{dq} v.(serv.cli') ∗
    "HsigPk" ∷ l ↦s[client.serv :: "sigPk"]{dq} v.(serv.sigPk') ∗
    "HvrfPk" ∷ l ↦s[client.serv :: "vrfPk"]{dq} v.(serv.vrfPk') ∗
    "HvrfSig" ∷ l ↦s[client.serv :: "vrfSig"]{dq} v.(serv.vrfSig')
  ).
Proof.
  rewrite /named.
  apply struct_fields_split_intro.
  unfold_typed_pointsto; split_pointsto_app.

  rewrite -!/(typed_pointsto_def _ _ _) -!typed_pointsto_unseal.
  simpl_one_flatten_struct (# (serv.cli' v)) (client.serv) "cli"%go.
  simpl_one_flatten_struct (# (serv.sigPk' v)) (client.serv) "sigPk"%go.
  simpl_one_flatten_struct (# (serv.vrfPk' v)) (client.serv) "vrfPk"%go.

  solve_field_ref_f.
Qed.

End instances.

(* type client.Evid *)
Module Evid.
Section def.
Context `{ffi_syntax}.

Record t := mk {
  vrf' : loc;
  link' : loc;
}.
End def.
End Evid.

Section instances.
Context `{ffi_syntax}.
#[local] Transparent client.Evid.
#[local] Typeclasses Transparent client.Evid.

Global Instance Evid_wf : struct.Wf client.Evid.
Proof. apply _. Qed.

Global Instance settable_Evid : Settable Evid.t :=
  settable! Evid.mk < Evid.vrf'; Evid.link' >.
Global Instance into_val_Evid : IntoVal Evid.t :=
  {| to_val_def v :=
    struct.val_aux client.Evid [
    "vrf" ::= #(Evid.vrf' v);
    "link" ::= #(Evid.link' v)
    ]%struct
  |}.

Global Program Instance into_val_typed_Evid : IntoValTyped Evid.t client.Evid :=
{|
  default_val := Evid.mk (default_val _) (default_val _);
|}.
Next Obligation. solve_to_val_type. Qed.
Next Obligation. solve_zero_val. Qed.
Next Obligation. solve_to_val_inj. Qed.
Final Obligation. solve_decision. Qed.

Global Instance into_val_struct_field_Evid_vrf : IntoValStructField "vrf" client.Evid Evid.vrf'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_Evid_link : IntoValStructField "link" client.Evid Evid.link'.
Proof. solve_into_val_struct_field. Qed.


Context `{!ffi_model, !ffi_semantics _ _, !ffi_interp _, !heapGS Σ}.


Global Instance Evid_struct_fields_split dq l (v : Evid.t) :
  StructFieldsSplit dq l v (
    "Hvrf" ∷ l ↦s[client.Evid :: "vrf"]{dq} v.(Evid.vrf') ∗
    "Hlink" ∷ l ↦s[client.Evid :: "link"]{dq} v.(Evid.link')
  ).
Proof.
  rewrite /named.
  apply struct_fields_split_intro.
  unfold_typed_pointsto; split_pointsto_app.

  rewrite -!/(typed_pointsto_def _ _ _) -!typed_pointsto_unseal.
  simpl_one_flatten_struct (# (Evid.vrf' v)) (client.Evid) "vrf"%go.

  solve_field_ref_f.
Qed.

End instances.

(* type client.evidVrf *)
Module evidVrf.
Section def.
Context `{ffi_syntax}.

Record t := mk {
  vrfPk0' : slice.t;
  sig0' : slice.t;
  vrfPk1' : slice.t;
  sig1' : slice.t;
}.
End def.
End evidVrf.

Section instances.
Context `{ffi_syntax}.
#[local] Transparent client.evidVrf.
#[local] Typeclasses Transparent client.evidVrf.

Global Instance evidVrf_wf : struct.Wf client.evidVrf.
Proof. apply _. Qed.

Global Instance settable_evidVrf : Settable evidVrf.t :=
  settable! evidVrf.mk < evidVrf.vrfPk0'; evidVrf.sig0'; evidVrf.vrfPk1'; evidVrf.sig1' >.
Global Instance into_val_evidVrf : IntoVal evidVrf.t :=
  {| to_val_def v :=
    struct.val_aux client.evidVrf [
    "vrfPk0" ::= #(evidVrf.vrfPk0' v);
    "sig0" ::= #(evidVrf.sig0' v);
    "vrfPk1" ::= #(evidVrf.vrfPk1' v);
    "sig1" ::= #(evidVrf.sig1' v)
    ]%struct
  |}.

Global Program Instance into_val_typed_evidVrf : IntoValTyped evidVrf.t client.evidVrf :=
{|
  default_val := evidVrf.mk (default_val _) (default_val _) (default_val _) (default_val _);
|}.
Next Obligation. solve_to_val_type. Qed.
Next Obligation. solve_zero_val. Qed.
Next Obligation. solve_to_val_inj. Qed.
Final Obligation. solve_decision. Qed.

Global Instance into_val_struct_field_evidVrf_vrfPk0 : IntoValStructField "vrfPk0" client.evidVrf evidVrf.vrfPk0'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_evidVrf_sig0 : IntoValStructField "sig0" client.evidVrf evidVrf.sig0'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_evidVrf_vrfPk1 : IntoValStructField "vrfPk1" client.evidVrf evidVrf.vrfPk1'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_evidVrf_sig1 : IntoValStructField "sig1" client.evidVrf evidVrf.sig1'.
Proof. solve_into_val_struct_field. Qed.


Context `{!ffi_model, !ffi_semantics _ _, !ffi_interp _, !heapGS Σ}.


Global Instance evidVrf_struct_fields_split dq l (v : evidVrf.t) :
  StructFieldsSplit dq l v (
    "HvrfPk0" ∷ l ↦s[client.evidVrf :: "vrfPk0"]{dq} v.(evidVrf.vrfPk0') ∗
    "Hsig0" ∷ l ↦s[client.evidVrf :: "sig0"]{dq} v.(evidVrf.sig0') ∗
    "HvrfPk1" ∷ l ↦s[client.evidVrf :: "vrfPk1"]{dq} v.(evidVrf.vrfPk1') ∗
    "Hsig1" ∷ l ↦s[client.evidVrf :: "sig1"]{dq} v.(evidVrf.sig1')
  ).
Proof.
  rewrite /named.
  apply struct_fields_split_intro.
  unfold_typed_pointsto; split_pointsto_app.

  rewrite -!/(typed_pointsto_def _ _ _) -!typed_pointsto_unseal.
  simpl_one_flatten_struct (# (evidVrf.vrfPk0' v)) (client.evidVrf) "vrfPk0"%go.
  simpl_one_flatten_struct (# (evidVrf.sig0' v)) (client.evidVrf) "sig0"%go.
  simpl_one_flatten_struct (# (evidVrf.vrfPk1' v)) (client.evidVrf) "vrfPk1"%go.

  solve_field_ref_f.
Qed.

End instances.

(* type client.evidLink *)
Module evidLink.
Section def.
Context `{ffi_syntax}.

Record t := mk {
  epoch' : w64;
  link0' : slice.t;
  sig0' : slice.t;
  link1' : slice.t;
  sig1' : slice.t;
}.
End def.
End evidLink.

Section instances.
Context `{ffi_syntax}.
#[local] Transparent client.evidLink.
#[local] Typeclasses Transparent client.evidLink.

Global Instance evidLink_wf : struct.Wf client.evidLink.
Proof. apply _. Qed.

Global Instance settable_evidLink : Settable evidLink.t :=
  settable! evidLink.mk < evidLink.epoch'; evidLink.link0'; evidLink.sig0'; evidLink.link1'; evidLink.sig1' >.
Global Instance into_val_evidLink : IntoVal evidLink.t :=
  {| to_val_def v :=
    struct.val_aux client.evidLink [
    "epoch" ::= #(evidLink.epoch' v);
    "link0" ::= #(evidLink.link0' v);
    "sig0" ::= #(evidLink.sig0' v);
    "link1" ::= #(evidLink.link1' v);
    "sig1" ::= #(evidLink.sig1' v)
    ]%struct
  |}.

Global Program Instance into_val_typed_evidLink : IntoValTyped evidLink.t client.evidLink :=
{|
  default_val := evidLink.mk (default_val _) (default_val _) (default_val _) (default_val _) (default_val _);
|}.
Next Obligation. solve_to_val_type. Qed.
Next Obligation. solve_zero_val. Qed.
Next Obligation. solve_to_val_inj. Qed.
Final Obligation. solve_decision. Qed.

Global Instance into_val_struct_field_evidLink_epoch : IntoValStructField "epoch" client.evidLink evidLink.epoch'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_evidLink_link0 : IntoValStructField "link0" client.evidLink evidLink.link0'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_evidLink_sig0 : IntoValStructField "sig0" client.evidLink evidLink.sig0'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_evidLink_link1 : IntoValStructField "link1" client.evidLink evidLink.link1'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_evidLink_sig1 : IntoValStructField "sig1" client.evidLink evidLink.sig1'.
Proof. solve_into_val_struct_field. Qed.


Context `{!ffi_model, !ffi_semantics _ _, !ffi_interp _, !heapGS Σ}.


Global Instance evidLink_struct_fields_split dq l (v : evidLink.t) :
  StructFieldsSplit dq l v (
    "Hepoch" ∷ l ↦s[client.evidLink :: "epoch"]{dq} v.(evidLink.epoch') ∗
    "Hlink0" ∷ l ↦s[client.evidLink :: "link0"]{dq} v.(evidLink.link0') ∗
    "Hsig0" ∷ l ↦s[client.evidLink :: "sig0"]{dq} v.(evidLink.sig0') ∗
    "Hlink1" ∷ l ↦s[client.evidLink :: "link1"]{dq} v.(evidLink.link1') ∗
    "Hsig1" ∷ l ↦s[client.evidLink :: "sig1"]{dq} v.(evidLink.sig1')
  ).
Proof.
  rewrite /named.
  apply struct_fields_split_intro.
  unfold_typed_pointsto; split_pointsto_app.

  rewrite -!/(typed_pointsto_def _ _ _) -!typed_pointsto_unseal.
  simpl_one_flatten_struct (# (evidLink.epoch' v)) (client.evidLink) "epoch"%go.
  simpl_one_flatten_struct (# (evidLink.link0' v)) (client.evidLink) "link0"%go.
  simpl_one_flatten_struct (# (evidLink.sig0' v)) (client.evidLink) "sig0"%go.
  simpl_one_flatten_struct (# (evidLink.link1' v)) (client.evidLink) "link1"%go.

  solve_field_ref_f.
Qed.

End instances.

Section names.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context `{!globalsGS Σ}.
Context {go_ctx : GoContext}.
#[local] Transparent is_pkg_defined is_pkg_defined_pure.

Global Instance is_pkg_defined_pure_client : IsPkgDefinedPure client :=
  {|
    is_pkg_defined_pure_def go_ctx :=
      is_pkg_defined_pure_single client ∧
      is_pkg_defined_pure code.bytes.bytes ∧
      is_pkg_defined_pure code.github_com.goose_lang.std.std ∧
      is_pkg_defined_pure code.github_com.sanjit_bhat.pav.advrpc.advrpc ∧
      is_pkg_defined_pure code.github_com.sanjit_bhat.pav.auditor.auditor ∧
      is_pkg_defined_pure code.github_com.sanjit_bhat.pav.cryptoffi.cryptoffi ∧
      is_pkg_defined_pure code.github_com.sanjit_bhat.pav.hashchain.hashchain ∧
      is_pkg_defined_pure code.github_com.sanjit_bhat.pav.ktcore.ktcore ∧
      is_pkg_defined_pure code.github_com.sanjit_bhat.pav.merkle.merkle ∧
      is_pkg_defined_pure code.github_com.sanjit_bhat.pav.server.server;
  |}.

#[local] Transparent is_pkg_defined_single is_pkg_defined_pure_single.
Global Program Instance is_pkg_defined_client : IsPkgDefined client :=
  {|
    is_pkg_defined_def go_ctx :=
      (is_pkg_defined_single client ∗
       is_pkg_defined code.bytes.bytes ∗
       is_pkg_defined code.github_com.goose_lang.std.std ∗
       is_pkg_defined code.github_com.sanjit_bhat.pav.advrpc.advrpc ∗
       is_pkg_defined code.github_com.sanjit_bhat.pav.auditor.auditor ∗
       is_pkg_defined code.github_com.sanjit_bhat.pav.cryptoffi.cryptoffi ∗
       is_pkg_defined code.github_com.sanjit_bhat.pav.hashchain.hashchain ∗
       is_pkg_defined code.github_com.sanjit_bhat.pav.ktcore.ktcore ∗
       is_pkg_defined code.github_com.sanjit_bhat.pav.merkle.merkle ∗
       is_pkg_defined code.github_com.sanjit_bhat.pav.server.server)%I
  |}.
Final Obligation. iIntros. iFrame "#%". Qed.
#[local] Opaque is_pkg_defined_single is_pkg_defined_pure_single.

Global Instance wp_func_call_New :
  WpFuncCall client.New _ (is_pkg_defined client) :=
  ltac:(solve_wp_func_call).

Global Instance wp_func_call_CheckMemb :
  WpFuncCall client.CheckMemb _ (is_pkg_defined client) :=
  ltac:(solve_wp_func_call).

Global Instance wp_func_call_CheckHist :
  WpFuncCall client.CheckHist _ (is_pkg_defined client) :=
  ltac:(solve_wp_func_call).

Global Instance wp_func_call_CheckNonMemb :
  WpFuncCall client.CheckNonMemb _ (is_pkg_defined client) :=
  ltac:(solve_wp_func_call).

Global Instance wp_method_call_Client'ptr_Audit :
  WpMethodCall (ptrT.id client.Client.id) "Audit" _ (is_pkg_defined client) :=
  ltac:(solve_wp_method_call).

Global Instance wp_method_call_Client'ptr_Get :
  WpMethodCall (ptrT.id client.Client.id) "Get" _ (is_pkg_defined client) :=
  ltac:(solve_wp_method_call).

Global Instance wp_method_call_Client'ptr_Put :
  WpMethodCall (ptrT.id client.Client.id) "Put" _ (is_pkg_defined client) :=
  ltac:(solve_wp_method_call).

Global Instance wp_method_call_Client'ptr_SelfMon :
  WpMethodCall (ptrT.id client.Client.id) "SelfMon" _ (is_pkg_defined client) :=
  ltac:(solve_wp_method_call).

Global Instance wp_method_call_Client'ptr_getChainExt :
  WpMethodCall (ptrT.id client.Client.id) "getChainExt" _ (is_pkg_defined client) :=
  ltac:(solve_wp_method_call).

Global Instance wp_method_call_Evid'ptr_Check :
  WpMethodCall (ptrT.id client.Evid.id) "Check" _ (is_pkg_defined client) :=
  ltac:(solve_wp_method_call).

Global Instance wp_method_call_evidVrf'ptr_Check :
  WpMethodCall (ptrT.id client.evidVrf.id) "Check" _ (is_pkg_defined client) :=
  ltac:(solve_wp_method_call).

Global Instance wp_method_call_evidLink'ptr_Check :
  WpMethodCall (ptrT.id client.evidLink.id) "Check" _ (is_pkg_defined client) :=
  ltac:(solve_wp_method_call).

End names.
End client.
