(* autogenerated by goose proofgen; do not modify *)
Require Export New.proof.proof_prelude.
Require Export New.generatedproof.bytes.
Require Export New.generatedproof.github_com.goose_lang.std.
Require Export New.generatedproof.github_com.sanjit_bhat.pav.advrpc.
Require Export New.generatedproof.github_com.sanjit_bhat.pav.auditor.
Require Export New.generatedproof.github_com.sanjit_bhat.pav.cryptoffi.
Require Export New.generatedproof.github_com.sanjit_bhat.pav.hashchain.
Require Export New.generatedproof.github_com.sanjit_bhat.pav.ktcore.
Require Export New.generatedproof.github_com.sanjit_bhat.pav.merkle.
Require Export New.generatedproof.github_com.sanjit_bhat.pav.server.
Require Export New.golang.theory.
Require Export New.code.github_com.sanjit_bhat.pav.client.

Set Default Proof Using "Type".

Module client.
Module Client.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : client.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance Client_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (client.Client.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "uid" ∷ l.[(client.Client.t), "uid"] ↦{dq} v.(client.Client.uid') ∗
      "pend" ∷ l.[(client.Client.t), "pend"] ↦{dq} v.(client.Client.pend') ∗
      "last" ∷ l.[(client.Client.t), "last"] ↦{dq} v.(client.Client.last') ∗
      "serv" ∷ l.[(client.Client.t), "serv"] ↦{dq} v.(client.Client.serv') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance Client_into_val_typed
   :
  IntoValTypedUnderlying (client.Client.t) (client.Clientⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance Client_access_load_uid l (v : (client.Client.t)) dq :
  AccessStrict
    (l.[(client.Client.t), "uid"] ↦{dq} (v.(client.Client.uid')))
    (l.[(client.Client.t), "uid"] ↦{dq} (v.(client.Client.uid')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Client_access_store_uid l (v : (client.Client.t)) uid' :
  AccessStrict
    (l.[(client.Client.t), "uid"] ↦ (v.(client.Client.uid')))
    (l.[(client.Client.t), "uid"] ↦ uid')
    (l ↦ v) (l ↦ (v <|(client.Client.uid') := uid'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Client_access_load_pend l (v : (client.Client.t)) dq :
  AccessStrict
    (l.[(client.Client.t), "pend"] ↦{dq} (v.(client.Client.pend')))
    (l.[(client.Client.t), "pend"] ↦{dq} (v.(client.Client.pend')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Client_access_store_pend l (v : (client.Client.t)) pend' :
  AccessStrict
    (l.[(client.Client.t), "pend"] ↦ (v.(client.Client.pend')))
    (l.[(client.Client.t), "pend"] ↦ pend')
    (l ↦ v) (l ↦ (v <|(client.Client.pend') := pend'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Client_access_load_last l (v : (client.Client.t)) dq :
  AccessStrict
    (l.[(client.Client.t), "last"] ↦{dq} (v.(client.Client.last')))
    (l.[(client.Client.t), "last"] ↦{dq} (v.(client.Client.last')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Client_access_store_last l (v : (client.Client.t)) last' :
  AccessStrict
    (l.[(client.Client.t), "last"] ↦ (v.(client.Client.last')))
    (l.[(client.Client.t), "last"] ↦ last')
    (l ↦ v) (l ↦ (v <|(client.Client.last') := last'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Client_access_load_serv l (v : (client.Client.t)) dq :
  AccessStrict
    (l.[(client.Client.t), "serv"] ↦{dq} (v.(client.Client.serv')))
    (l.[(client.Client.t), "serv"] ↦{dq} (v.(client.Client.serv')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Client_access_store_serv l (v : (client.Client.t)) serv' :
  AccessStrict
    (l.[(client.Client.t), "serv"] ↦ (v.(client.Client.serv')))
    (l.[(client.Client.t), "serv"] ↦ serv')
    (l ↦ v) (l ↦ (v <|(client.Client.serv') := serv'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End Client.

Module nextVer.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : client.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance nextVer_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (client.nextVer.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "ver" ∷ l.[(client.nextVer.t), "ver"] ↦{dq} v.(client.nextVer.ver') ∗
      "isPending" ∷ l.[(client.nextVer.t), "isPending"] ↦{dq} v.(client.nextVer.isPending') ∗
      "pendingPk" ∷ l.[(client.nextVer.t), "pendingPk"] ↦{dq} v.(client.nextVer.pendingPk') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance nextVer_into_val_typed
   :
  IntoValTypedUnderlying (client.nextVer.t) (client.nextVerⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance nextVer_access_load_ver l (v : (client.nextVer.t)) dq :
  AccessStrict
    (l.[(client.nextVer.t), "ver"] ↦{dq} (v.(client.nextVer.ver')))
    (l.[(client.nextVer.t), "ver"] ↦{dq} (v.(client.nextVer.ver')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance nextVer_access_store_ver l (v : (client.nextVer.t)) ver' :
  AccessStrict
    (l.[(client.nextVer.t), "ver"] ↦ (v.(client.nextVer.ver')))
    (l.[(client.nextVer.t), "ver"] ↦ ver')
    (l ↦ v) (l ↦ (v <|(client.nextVer.ver') := ver'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance nextVer_access_load_isPending l (v : (client.nextVer.t)) dq :
  AccessStrict
    (l.[(client.nextVer.t), "isPending"] ↦{dq} (v.(client.nextVer.isPending')))
    (l.[(client.nextVer.t), "isPending"] ↦{dq} (v.(client.nextVer.isPending')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance nextVer_access_store_isPending l (v : (client.nextVer.t)) isPending' :
  AccessStrict
    (l.[(client.nextVer.t), "isPending"] ↦ (v.(client.nextVer.isPending')))
    (l.[(client.nextVer.t), "isPending"] ↦ isPending')
    (l ↦ v) (l ↦ (v <|(client.nextVer.isPending') := isPending'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance nextVer_access_load_pendingPk l (v : (client.nextVer.t)) dq :
  AccessStrict
    (l.[(client.nextVer.t), "pendingPk"] ↦{dq} (v.(client.nextVer.pendingPk')))
    (l.[(client.nextVer.t), "pendingPk"] ↦{dq} (v.(client.nextVer.pendingPk')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance nextVer_access_store_pendingPk l (v : (client.nextVer.t)) pendingPk' :
  AccessStrict
    (l.[(client.nextVer.t), "pendingPk"] ↦ (v.(client.nextVer.pendingPk')))
    (l.[(client.nextVer.t), "pendingPk"] ↦ pendingPk')
    (l ↦ v) (l ↦ (v <|(client.nextVer.pendingPk') := pendingPk'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End nextVer.

Module epoch.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : client.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance epoch_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (client.epoch.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "epoch" ∷ l.[(client.epoch.t), "epoch"] ↦{dq} v.(client.epoch.epoch') ∗
      "dig" ∷ l.[(client.epoch.t), "dig"] ↦{dq} v.(client.epoch.dig') ∗
      "link" ∷ l.[(client.epoch.t), "link"] ↦{dq} v.(client.epoch.link') ∗
      "sig" ∷ l.[(client.epoch.t), "sig"] ↦{dq} v.(client.epoch.sig') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance epoch_into_val_typed
   :
  IntoValTypedUnderlying (client.epoch.t) (client.epochⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance epoch_access_load_epoch l (v : (client.epoch.t)) dq :
  AccessStrict
    (l.[(client.epoch.t), "epoch"] ↦{dq} (v.(client.epoch.epoch')))
    (l.[(client.epoch.t), "epoch"] ↦{dq} (v.(client.epoch.epoch')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance epoch_access_store_epoch l (v : (client.epoch.t)) epoch' :
  AccessStrict
    (l.[(client.epoch.t), "epoch"] ↦ (v.(client.epoch.epoch')))
    (l.[(client.epoch.t), "epoch"] ↦ epoch')
    (l ↦ v) (l ↦ (v <|(client.epoch.epoch') := epoch'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance epoch_access_load_dig l (v : (client.epoch.t)) dq :
  AccessStrict
    (l.[(client.epoch.t), "dig"] ↦{dq} (v.(client.epoch.dig')))
    (l.[(client.epoch.t), "dig"] ↦{dq} (v.(client.epoch.dig')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance epoch_access_store_dig l (v : (client.epoch.t)) dig' :
  AccessStrict
    (l.[(client.epoch.t), "dig"] ↦ (v.(client.epoch.dig')))
    (l.[(client.epoch.t), "dig"] ↦ dig')
    (l ↦ v) (l ↦ (v <|(client.epoch.dig') := dig'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance epoch_access_load_link l (v : (client.epoch.t)) dq :
  AccessStrict
    (l.[(client.epoch.t), "link"] ↦{dq} (v.(client.epoch.link')))
    (l.[(client.epoch.t), "link"] ↦{dq} (v.(client.epoch.link')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance epoch_access_store_link l (v : (client.epoch.t)) link' :
  AccessStrict
    (l.[(client.epoch.t), "link"] ↦ (v.(client.epoch.link')))
    (l.[(client.epoch.t), "link"] ↦ link')
    (l ↦ v) (l ↦ (v <|(client.epoch.link') := link'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance epoch_access_load_sig l (v : (client.epoch.t)) dq :
  AccessStrict
    (l.[(client.epoch.t), "sig"] ↦{dq} (v.(client.epoch.sig')))
    (l.[(client.epoch.t), "sig"] ↦{dq} (v.(client.epoch.sig')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance epoch_access_store_sig l (v : (client.epoch.t)) sig' :
  AccessStrict
    (l.[(client.epoch.t), "sig"] ↦ (v.(client.epoch.sig')))
    (l.[(client.epoch.t), "sig"] ↦ sig')
    (l ↦ v) (l ↦ (v <|(client.epoch.sig') := sig'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End epoch.

Module serv.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : client.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance serv_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (client.serv.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "cli" ∷ l.[(client.serv.t), "cli"] ↦{dq} v.(client.serv.cli') ∗
      "sigPk" ∷ l.[(client.serv.t), "sigPk"] ↦{dq} v.(client.serv.sigPk') ∗
      "vrfPk" ∷ l.[(client.serv.t), "vrfPk"] ↦{dq} v.(client.serv.vrfPk') ∗
      "vrfSig" ∷ l.[(client.serv.t), "vrfSig"] ↦{dq} v.(client.serv.vrfSig') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance serv_into_val_typed
   :
  IntoValTypedUnderlying (client.serv.t) (client.servⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance serv_access_load_cli l (v : (client.serv.t)) dq :
  AccessStrict
    (l.[(client.serv.t), "cli"] ↦{dq} (v.(client.serv.cli')))
    (l.[(client.serv.t), "cli"] ↦{dq} (v.(client.serv.cli')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance serv_access_store_cli l (v : (client.serv.t)) cli' :
  AccessStrict
    (l.[(client.serv.t), "cli"] ↦ (v.(client.serv.cli')))
    (l.[(client.serv.t), "cli"] ↦ cli')
    (l ↦ v) (l ↦ (v <|(client.serv.cli') := cli'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance serv_access_load_sigPk l (v : (client.serv.t)) dq :
  AccessStrict
    (l.[(client.serv.t), "sigPk"] ↦{dq} (v.(client.serv.sigPk')))
    (l.[(client.serv.t), "sigPk"] ↦{dq} (v.(client.serv.sigPk')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance serv_access_store_sigPk l (v : (client.serv.t)) sigPk' :
  AccessStrict
    (l.[(client.serv.t), "sigPk"] ↦ (v.(client.serv.sigPk')))
    (l.[(client.serv.t), "sigPk"] ↦ sigPk')
    (l ↦ v) (l ↦ (v <|(client.serv.sigPk') := sigPk'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance serv_access_load_vrfPk l (v : (client.serv.t)) dq :
  AccessStrict
    (l.[(client.serv.t), "vrfPk"] ↦{dq} (v.(client.serv.vrfPk')))
    (l.[(client.serv.t), "vrfPk"] ↦{dq} (v.(client.serv.vrfPk')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance serv_access_store_vrfPk l (v : (client.serv.t)) vrfPk' :
  AccessStrict
    (l.[(client.serv.t), "vrfPk"] ↦ (v.(client.serv.vrfPk')))
    (l.[(client.serv.t), "vrfPk"] ↦ vrfPk')
    (l ↦ v) (l ↦ (v <|(client.serv.vrfPk') := vrfPk'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance serv_access_load_vrfSig l (v : (client.serv.t)) dq :
  AccessStrict
    (l.[(client.serv.t), "vrfSig"] ↦{dq} (v.(client.serv.vrfSig')))
    (l.[(client.serv.t), "vrfSig"] ↦{dq} (v.(client.serv.vrfSig')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance serv_access_store_vrfSig l (v : (client.serv.t)) vrfSig' :
  AccessStrict
    (l.[(client.serv.t), "vrfSig"] ↦ (v.(client.serv.vrfSig')))
    (l.[(client.serv.t), "vrfSig"] ↦ vrfSig')
    (l ↦ v) (l ↦ (v <|(client.serv.vrfSig') := vrfSig'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End serv.

End client.
