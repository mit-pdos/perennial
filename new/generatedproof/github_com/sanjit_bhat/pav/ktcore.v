(* autogenerated by goose proofgen; do not modify *)
Require Export New.proof.proof_prelude.
Require Export New.generatedproof.bytes.
Require Export New.generatedproof.github_com.sanjit_bhat.pav.cryptoffi.
Require Export New.generatedproof.github_com.sanjit_bhat.pav.cryptoutil.
Require Export New.generatedproof.github_com.sanjit_bhat.pav.safemarshal.
Require Export New.generatedproof.github_com.tchajed.marshal.
Require Export New.golang.theory.
Require Export New.code.github_com.sanjit_bhat.pav.ktcore.

Set Default Proof Using "Type".

Module ktcore.
Module Evid.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : ktcore.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance Evid_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (ktcore.Evid.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "Vrf" ∷ l.[(ktcore.Evid.t), "Vrf"] ↦{dq} v.(ktcore.Evid.Vrf') ∗
      "Link" ∷ l.[(ktcore.Evid.t), "Link"] ↦{dq} v.(ktcore.Evid.Link') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance Evid_into_val_typed
   :
  IntoValTypedUnderlying (ktcore.Evid.t) (ktcore.Evidⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance Evid_access_load_Vrf l (v : (ktcore.Evid.t)) dq :
  AccessStrict
    (l.[(ktcore.Evid.t), "Vrf"] ↦{dq} (v.(ktcore.Evid.Vrf')))
    (l.[(ktcore.Evid.t), "Vrf"] ↦{dq} (v.(ktcore.Evid.Vrf')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Evid_access_store_Vrf l (v : (ktcore.Evid.t)) Vrf' :
  AccessStrict
    (l.[(ktcore.Evid.t), "Vrf"] ↦ (v.(ktcore.Evid.Vrf')))
    (l.[(ktcore.Evid.t), "Vrf"] ↦ Vrf')
    (l ↦ v) (l ↦ (v <|(ktcore.Evid.Vrf') := Vrf'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Evid_access_load_Link l (v : (ktcore.Evid.t)) dq :
  AccessStrict
    (l.[(ktcore.Evid.t), "Link"] ↦{dq} (v.(ktcore.Evid.Link')))
    (l.[(ktcore.Evid.t), "Link"] ↦{dq} (v.(ktcore.Evid.Link')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Evid_access_store_Link l (v : (ktcore.Evid.t)) Link' :
  AccessStrict
    (l.[(ktcore.Evid.t), "Link"] ↦ (v.(ktcore.Evid.Link')))
    (l.[(ktcore.Evid.t), "Link"] ↦ Link')
    (l ↦ v) (l ↦ (v <|(ktcore.Evid.Link') := Link'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End Evid.

Module EvidVrf.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : ktcore.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance EvidVrf_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (ktcore.EvidVrf.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "VrfPk0" ∷ l.[(ktcore.EvidVrf.t), "VrfPk0"] ↦{dq} v.(ktcore.EvidVrf.VrfPk0') ∗
      "Sig0" ∷ l.[(ktcore.EvidVrf.t), "Sig0"] ↦{dq} v.(ktcore.EvidVrf.Sig0') ∗
      "VrfPk1" ∷ l.[(ktcore.EvidVrf.t), "VrfPk1"] ↦{dq} v.(ktcore.EvidVrf.VrfPk1') ∗
      "Sig1" ∷ l.[(ktcore.EvidVrf.t), "Sig1"] ↦{dq} v.(ktcore.EvidVrf.Sig1') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance EvidVrf_into_val_typed
   :
  IntoValTypedUnderlying (ktcore.EvidVrf.t) (ktcore.EvidVrfⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance EvidVrf_access_load_VrfPk0 l (v : (ktcore.EvidVrf.t)) dq :
  AccessStrict
    (l.[(ktcore.EvidVrf.t), "VrfPk0"] ↦{dq} (v.(ktcore.EvidVrf.VrfPk0')))
    (l.[(ktcore.EvidVrf.t), "VrfPk0"] ↦{dq} (v.(ktcore.EvidVrf.VrfPk0')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance EvidVrf_access_store_VrfPk0 l (v : (ktcore.EvidVrf.t)) VrfPk0' :
  AccessStrict
    (l.[(ktcore.EvidVrf.t), "VrfPk0"] ↦ (v.(ktcore.EvidVrf.VrfPk0')))
    (l.[(ktcore.EvidVrf.t), "VrfPk0"] ↦ VrfPk0')
    (l ↦ v) (l ↦ (v <|(ktcore.EvidVrf.VrfPk0') := VrfPk0'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance EvidVrf_access_load_Sig0 l (v : (ktcore.EvidVrf.t)) dq :
  AccessStrict
    (l.[(ktcore.EvidVrf.t), "Sig0"] ↦{dq} (v.(ktcore.EvidVrf.Sig0')))
    (l.[(ktcore.EvidVrf.t), "Sig0"] ↦{dq} (v.(ktcore.EvidVrf.Sig0')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance EvidVrf_access_store_Sig0 l (v : (ktcore.EvidVrf.t)) Sig0' :
  AccessStrict
    (l.[(ktcore.EvidVrf.t), "Sig0"] ↦ (v.(ktcore.EvidVrf.Sig0')))
    (l.[(ktcore.EvidVrf.t), "Sig0"] ↦ Sig0')
    (l ↦ v) (l ↦ (v <|(ktcore.EvidVrf.Sig0') := Sig0'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance EvidVrf_access_load_VrfPk1 l (v : (ktcore.EvidVrf.t)) dq :
  AccessStrict
    (l.[(ktcore.EvidVrf.t), "VrfPk1"] ↦{dq} (v.(ktcore.EvidVrf.VrfPk1')))
    (l.[(ktcore.EvidVrf.t), "VrfPk1"] ↦{dq} (v.(ktcore.EvidVrf.VrfPk1')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance EvidVrf_access_store_VrfPk1 l (v : (ktcore.EvidVrf.t)) VrfPk1' :
  AccessStrict
    (l.[(ktcore.EvidVrf.t), "VrfPk1"] ↦ (v.(ktcore.EvidVrf.VrfPk1')))
    (l.[(ktcore.EvidVrf.t), "VrfPk1"] ↦ VrfPk1')
    (l ↦ v) (l ↦ (v <|(ktcore.EvidVrf.VrfPk1') := VrfPk1'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance EvidVrf_access_load_Sig1 l (v : (ktcore.EvidVrf.t)) dq :
  AccessStrict
    (l.[(ktcore.EvidVrf.t), "Sig1"] ↦{dq} (v.(ktcore.EvidVrf.Sig1')))
    (l.[(ktcore.EvidVrf.t), "Sig1"] ↦{dq} (v.(ktcore.EvidVrf.Sig1')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance EvidVrf_access_store_Sig1 l (v : (ktcore.EvidVrf.t)) Sig1' :
  AccessStrict
    (l.[(ktcore.EvidVrf.t), "Sig1"] ↦ (v.(ktcore.EvidVrf.Sig1')))
    (l.[(ktcore.EvidVrf.t), "Sig1"] ↦ Sig1')
    (l ↦ v) (l ↦ (v <|(ktcore.EvidVrf.Sig1') := Sig1'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End EvidVrf.

Module EvidLink.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : ktcore.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance EvidLink_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (ktcore.EvidLink.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "Epoch" ∷ l.[(ktcore.EvidLink.t), "Epoch"] ↦{dq} v.(ktcore.EvidLink.Epoch') ∗
      "Link0" ∷ l.[(ktcore.EvidLink.t), "Link0"] ↦{dq} v.(ktcore.EvidLink.Link0') ∗
      "Sig0" ∷ l.[(ktcore.EvidLink.t), "Sig0"] ↦{dq} v.(ktcore.EvidLink.Sig0') ∗
      "Link1" ∷ l.[(ktcore.EvidLink.t), "Link1"] ↦{dq} v.(ktcore.EvidLink.Link1') ∗
      "Sig1" ∷ l.[(ktcore.EvidLink.t), "Sig1"] ↦{dq} v.(ktcore.EvidLink.Sig1') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance EvidLink_into_val_typed
   :
  IntoValTypedUnderlying (ktcore.EvidLink.t) (ktcore.EvidLinkⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance EvidLink_access_load_Epoch l (v : (ktcore.EvidLink.t)) dq :
  AccessStrict
    (l.[(ktcore.EvidLink.t), "Epoch"] ↦{dq} (v.(ktcore.EvidLink.Epoch')))
    (l.[(ktcore.EvidLink.t), "Epoch"] ↦{dq} (v.(ktcore.EvidLink.Epoch')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance EvidLink_access_store_Epoch l (v : (ktcore.EvidLink.t)) Epoch' :
  AccessStrict
    (l.[(ktcore.EvidLink.t), "Epoch"] ↦ (v.(ktcore.EvidLink.Epoch')))
    (l.[(ktcore.EvidLink.t), "Epoch"] ↦ Epoch')
    (l ↦ v) (l ↦ (v <|(ktcore.EvidLink.Epoch') := Epoch'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance EvidLink_access_load_Link0 l (v : (ktcore.EvidLink.t)) dq :
  AccessStrict
    (l.[(ktcore.EvidLink.t), "Link0"] ↦{dq} (v.(ktcore.EvidLink.Link0')))
    (l.[(ktcore.EvidLink.t), "Link0"] ↦{dq} (v.(ktcore.EvidLink.Link0')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance EvidLink_access_store_Link0 l (v : (ktcore.EvidLink.t)) Link0' :
  AccessStrict
    (l.[(ktcore.EvidLink.t), "Link0"] ↦ (v.(ktcore.EvidLink.Link0')))
    (l.[(ktcore.EvidLink.t), "Link0"] ↦ Link0')
    (l ↦ v) (l ↦ (v <|(ktcore.EvidLink.Link0') := Link0'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance EvidLink_access_load_Sig0 l (v : (ktcore.EvidLink.t)) dq :
  AccessStrict
    (l.[(ktcore.EvidLink.t), "Sig0"] ↦{dq} (v.(ktcore.EvidLink.Sig0')))
    (l.[(ktcore.EvidLink.t), "Sig0"] ↦{dq} (v.(ktcore.EvidLink.Sig0')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance EvidLink_access_store_Sig0 l (v : (ktcore.EvidLink.t)) Sig0' :
  AccessStrict
    (l.[(ktcore.EvidLink.t), "Sig0"] ↦ (v.(ktcore.EvidLink.Sig0')))
    (l.[(ktcore.EvidLink.t), "Sig0"] ↦ Sig0')
    (l ↦ v) (l ↦ (v <|(ktcore.EvidLink.Sig0') := Sig0'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance EvidLink_access_load_Link1 l (v : (ktcore.EvidLink.t)) dq :
  AccessStrict
    (l.[(ktcore.EvidLink.t), "Link1"] ↦{dq} (v.(ktcore.EvidLink.Link1')))
    (l.[(ktcore.EvidLink.t), "Link1"] ↦{dq} (v.(ktcore.EvidLink.Link1')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance EvidLink_access_store_Link1 l (v : (ktcore.EvidLink.t)) Link1' :
  AccessStrict
    (l.[(ktcore.EvidLink.t), "Link1"] ↦ (v.(ktcore.EvidLink.Link1')))
    (l.[(ktcore.EvidLink.t), "Link1"] ↦ Link1')
    (l ↦ v) (l ↦ (v <|(ktcore.EvidLink.Link1') := Link1'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance EvidLink_access_load_Sig1 l (v : (ktcore.EvidLink.t)) dq :
  AccessStrict
    (l.[(ktcore.EvidLink.t), "Sig1"] ↦{dq} (v.(ktcore.EvidLink.Sig1')))
    (l.[(ktcore.EvidLink.t), "Sig1"] ↦{dq} (v.(ktcore.EvidLink.Sig1')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance EvidLink_access_store_Sig1 l (v : (ktcore.EvidLink.t)) Sig1' :
  AccessStrict
    (l.[(ktcore.EvidLink.t), "Sig1"] ↦ (v.(ktcore.EvidLink.Sig1')))
    (l.[(ktcore.EvidLink.t), "Sig1"] ↦ Sig1')
    (l ↦ v) (l ↦ (v <|(ktcore.EvidLink.Sig1') := Sig1'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End EvidLink.

Module VrfSig.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : ktcore.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance VrfSig_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (ktcore.VrfSig.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "SigTag" ∷ l.[(ktcore.VrfSig.t), "SigTag"] ↦{dq} v.(ktcore.VrfSig.SigTag') ∗
      "VrfPk" ∷ l.[(ktcore.VrfSig.t), "VrfPk"] ↦{dq} v.(ktcore.VrfSig.VrfPk') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance VrfSig_into_val_typed
   :
  IntoValTypedUnderlying (ktcore.VrfSig.t) (ktcore.VrfSigⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance VrfSig_access_load_SigTag l (v : (ktcore.VrfSig.t)) dq :
  AccessStrict
    (l.[(ktcore.VrfSig.t), "SigTag"] ↦{dq} (v.(ktcore.VrfSig.SigTag')))
    (l.[(ktcore.VrfSig.t), "SigTag"] ↦{dq} (v.(ktcore.VrfSig.SigTag')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance VrfSig_access_store_SigTag l (v : (ktcore.VrfSig.t)) SigTag' :
  AccessStrict
    (l.[(ktcore.VrfSig.t), "SigTag"] ↦ (v.(ktcore.VrfSig.SigTag')))
    (l.[(ktcore.VrfSig.t), "SigTag"] ↦ SigTag')
    (l ↦ v) (l ↦ (v <|(ktcore.VrfSig.SigTag') := SigTag'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance VrfSig_access_load_VrfPk l (v : (ktcore.VrfSig.t)) dq :
  AccessStrict
    (l.[(ktcore.VrfSig.t), "VrfPk"] ↦{dq} (v.(ktcore.VrfSig.VrfPk')))
    (l.[(ktcore.VrfSig.t), "VrfPk"] ↦{dq} (v.(ktcore.VrfSig.VrfPk')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance VrfSig_access_store_VrfPk l (v : (ktcore.VrfSig.t)) VrfPk' :
  AccessStrict
    (l.[(ktcore.VrfSig.t), "VrfPk"] ↦ (v.(ktcore.VrfSig.VrfPk')))
    (l.[(ktcore.VrfSig.t), "VrfPk"] ↦ VrfPk')
    (l ↦ v) (l ↦ (v <|(ktcore.VrfSig.VrfPk') := VrfPk'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End VrfSig.

Module LinkSig.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : ktcore.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance LinkSig_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (ktcore.LinkSig.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "SigTag" ∷ l.[(ktcore.LinkSig.t), "SigTag"] ↦{dq} v.(ktcore.LinkSig.SigTag') ∗
      "Epoch" ∷ l.[(ktcore.LinkSig.t), "Epoch"] ↦{dq} v.(ktcore.LinkSig.Epoch') ∗
      "Link" ∷ l.[(ktcore.LinkSig.t), "Link"] ↦{dq} v.(ktcore.LinkSig.Link') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance LinkSig_into_val_typed
   :
  IntoValTypedUnderlying (ktcore.LinkSig.t) (ktcore.LinkSigⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance LinkSig_access_load_SigTag l (v : (ktcore.LinkSig.t)) dq :
  AccessStrict
    (l.[(ktcore.LinkSig.t), "SigTag"] ↦{dq} (v.(ktcore.LinkSig.SigTag')))
    (l.[(ktcore.LinkSig.t), "SigTag"] ↦{dq} (v.(ktcore.LinkSig.SigTag')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance LinkSig_access_store_SigTag l (v : (ktcore.LinkSig.t)) SigTag' :
  AccessStrict
    (l.[(ktcore.LinkSig.t), "SigTag"] ↦ (v.(ktcore.LinkSig.SigTag')))
    (l.[(ktcore.LinkSig.t), "SigTag"] ↦ SigTag')
    (l ↦ v) (l ↦ (v <|(ktcore.LinkSig.SigTag') := SigTag'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance LinkSig_access_load_Epoch l (v : (ktcore.LinkSig.t)) dq :
  AccessStrict
    (l.[(ktcore.LinkSig.t), "Epoch"] ↦{dq} (v.(ktcore.LinkSig.Epoch')))
    (l.[(ktcore.LinkSig.t), "Epoch"] ↦{dq} (v.(ktcore.LinkSig.Epoch')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance LinkSig_access_store_Epoch l (v : (ktcore.LinkSig.t)) Epoch' :
  AccessStrict
    (l.[(ktcore.LinkSig.t), "Epoch"] ↦ (v.(ktcore.LinkSig.Epoch')))
    (l.[(ktcore.LinkSig.t), "Epoch"] ↦ Epoch')
    (l ↦ v) (l ↦ (v <|(ktcore.LinkSig.Epoch') := Epoch'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance LinkSig_access_load_Link l (v : (ktcore.LinkSig.t)) dq :
  AccessStrict
    (l.[(ktcore.LinkSig.t), "Link"] ↦{dq} (v.(ktcore.LinkSig.Link')))
    (l.[(ktcore.LinkSig.t), "Link"] ↦{dq} (v.(ktcore.LinkSig.Link')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance LinkSig_access_store_Link l (v : (ktcore.LinkSig.t)) Link' :
  AccessStrict
    (l.[(ktcore.LinkSig.t), "Link"] ↦ (v.(ktcore.LinkSig.Link')))
    (l.[(ktcore.LinkSig.t), "Link"] ↦ Link')
    (l ↦ v) (l ↦ (v <|(ktcore.LinkSig.Link') := Link'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End LinkSig.

Module MapLabel.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : ktcore.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance MapLabel_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (ktcore.MapLabel.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "Uid" ∷ l.[(ktcore.MapLabel.t), "Uid"] ↦{dq} v.(ktcore.MapLabel.Uid') ∗
      "Ver" ∷ l.[(ktcore.MapLabel.t), "Ver"] ↦{dq} v.(ktcore.MapLabel.Ver') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance MapLabel_into_val_typed
   :
  IntoValTypedUnderlying (ktcore.MapLabel.t) (ktcore.MapLabelⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance MapLabel_access_load_Uid l (v : (ktcore.MapLabel.t)) dq :
  AccessStrict
    (l.[(ktcore.MapLabel.t), "Uid"] ↦{dq} (v.(ktcore.MapLabel.Uid')))
    (l.[(ktcore.MapLabel.t), "Uid"] ↦{dq} (v.(ktcore.MapLabel.Uid')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance MapLabel_access_store_Uid l (v : (ktcore.MapLabel.t)) Uid' :
  AccessStrict
    (l.[(ktcore.MapLabel.t), "Uid"] ↦ (v.(ktcore.MapLabel.Uid')))
    (l.[(ktcore.MapLabel.t), "Uid"] ↦ Uid')
    (l ↦ v) (l ↦ (v <|(ktcore.MapLabel.Uid') := Uid'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance MapLabel_access_load_Ver l (v : (ktcore.MapLabel.t)) dq :
  AccessStrict
    (l.[(ktcore.MapLabel.t), "Ver"] ↦{dq} (v.(ktcore.MapLabel.Ver')))
    (l.[(ktcore.MapLabel.t), "Ver"] ↦{dq} (v.(ktcore.MapLabel.Ver')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance MapLabel_access_store_Ver l (v : (ktcore.MapLabel.t)) Ver' :
  AccessStrict
    (l.[(ktcore.MapLabel.t), "Ver"] ↦ (v.(ktcore.MapLabel.Ver')))
    (l.[(ktcore.MapLabel.t), "Ver"] ↦ Ver')
    (l ↦ v) (l ↦ (v <|(ktcore.MapLabel.Ver') := Ver'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End MapLabel.

Module CommitOpen.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : ktcore.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance CommitOpen_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (ktcore.CommitOpen.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "Val" ∷ l.[(ktcore.CommitOpen.t), "Val"] ↦{dq} v.(ktcore.CommitOpen.Val') ∗
      "Rand" ∷ l.[(ktcore.CommitOpen.t), "Rand"] ↦{dq} v.(ktcore.CommitOpen.Rand') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance CommitOpen_into_val_typed
   :
  IntoValTypedUnderlying (ktcore.CommitOpen.t) (ktcore.CommitOpenⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance CommitOpen_access_load_Val l (v : (ktcore.CommitOpen.t)) dq :
  AccessStrict
    (l.[(ktcore.CommitOpen.t), "Val"] ↦{dq} (v.(ktcore.CommitOpen.Val')))
    (l.[(ktcore.CommitOpen.t), "Val"] ↦{dq} (v.(ktcore.CommitOpen.Val')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance CommitOpen_access_store_Val l (v : (ktcore.CommitOpen.t)) Val' :
  AccessStrict
    (l.[(ktcore.CommitOpen.t), "Val"] ↦ (v.(ktcore.CommitOpen.Val')))
    (l.[(ktcore.CommitOpen.t), "Val"] ↦ Val')
    (l ↦ v) (l ↦ (v <|(ktcore.CommitOpen.Val') := Val'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance CommitOpen_access_load_Rand l (v : (ktcore.CommitOpen.t)) dq :
  AccessStrict
    (l.[(ktcore.CommitOpen.t), "Rand"] ↦{dq} (v.(ktcore.CommitOpen.Rand')))
    (l.[(ktcore.CommitOpen.t), "Rand"] ↦{dq} (v.(ktcore.CommitOpen.Rand')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance CommitOpen_access_store_Rand l (v : (ktcore.CommitOpen.t)) Rand' :
  AccessStrict
    (l.[(ktcore.CommitOpen.t), "Rand"] ↦ (v.(ktcore.CommitOpen.Rand')))
    (l.[(ktcore.CommitOpen.t), "Rand"] ↦ Rand')
    (l ↦ v) (l ↦ (v <|(ktcore.CommitOpen.Rand') := Rand'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End CommitOpen.

Module Memb.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : ktcore.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance Memb_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (ktcore.Memb.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "LabelProof" ∷ l.[(ktcore.Memb.t), "LabelProof"] ↦{dq} v.(ktcore.Memb.LabelProof') ∗
      "PkOpen" ∷ l.[(ktcore.Memb.t), "PkOpen"] ↦{dq} v.(ktcore.Memb.PkOpen') ∗
      "MerkleProof" ∷ l.[(ktcore.Memb.t), "MerkleProof"] ↦{dq} v.(ktcore.Memb.MerkleProof') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance Memb_into_val_typed
   :
  IntoValTypedUnderlying (ktcore.Memb.t) (ktcore.Membⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance Memb_access_load_LabelProof l (v : (ktcore.Memb.t)) dq :
  AccessStrict
    (l.[(ktcore.Memb.t), "LabelProof"] ↦{dq} (v.(ktcore.Memb.LabelProof')))
    (l.[(ktcore.Memb.t), "LabelProof"] ↦{dq} (v.(ktcore.Memb.LabelProof')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Memb_access_store_LabelProof l (v : (ktcore.Memb.t)) LabelProof' :
  AccessStrict
    (l.[(ktcore.Memb.t), "LabelProof"] ↦ (v.(ktcore.Memb.LabelProof')))
    (l.[(ktcore.Memb.t), "LabelProof"] ↦ LabelProof')
    (l ↦ v) (l ↦ (v <|(ktcore.Memb.LabelProof') := LabelProof'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Memb_access_load_PkOpen l (v : (ktcore.Memb.t)) dq :
  AccessStrict
    (l.[(ktcore.Memb.t), "PkOpen"] ↦{dq} (v.(ktcore.Memb.PkOpen')))
    (l.[(ktcore.Memb.t), "PkOpen"] ↦{dq} (v.(ktcore.Memb.PkOpen')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Memb_access_store_PkOpen l (v : (ktcore.Memb.t)) PkOpen' :
  AccessStrict
    (l.[(ktcore.Memb.t), "PkOpen"] ↦ (v.(ktcore.Memb.PkOpen')))
    (l.[(ktcore.Memb.t), "PkOpen"] ↦ PkOpen')
    (l ↦ v) (l ↦ (v <|(ktcore.Memb.PkOpen') := PkOpen'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Memb_access_load_MerkleProof l (v : (ktcore.Memb.t)) dq :
  AccessStrict
    (l.[(ktcore.Memb.t), "MerkleProof"] ↦{dq} (v.(ktcore.Memb.MerkleProof')))
    (l.[(ktcore.Memb.t), "MerkleProof"] ↦{dq} (v.(ktcore.Memb.MerkleProof')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Memb_access_store_MerkleProof l (v : (ktcore.Memb.t)) MerkleProof' :
  AccessStrict
    (l.[(ktcore.Memb.t), "MerkleProof"] ↦ (v.(ktcore.Memb.MerkleProof')))
    (l.[(ktcore.Memb.t), "MerkleProof"] ↦ MerkleProof')
    (l ↦ v) (l ↦ (v <|(ktcore.Memb.MerkleProof') := MerkleProof'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End Memb.

Module NonMemb.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : ktcore.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance NonMemb_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (ktcore.NonMemb.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "LabelProof" ∷ l.[(ktcore.NonMemb.t), "LabelProof"] ↦{dq} v.(ktcore.NonMemb.LabelProof') ∗
      "MerkleProof" ∷ l.[(ktcore.NonMemb.t), "MerkleProof"] ↦{dq} v.(ktcore.NonMemb.MerkleProof') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance NonMemb_into_val_typed
   :
  IntoValTypedUnderlying (ktcore.NonMemb.t) (ktcore.NonMembⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance NonMemb_access_load_LabelProof l (v : (ktcore.NonMemb.t)) dq :
  AccessStrict
    (l.[(ktcore.NonMemb.t), "LabelProof"] ↦{dq} (v.(ktcore.NonMemb.LabelProof')))
    (l.[(ktcore.NonMemb.t), "LabelProof"] ↦{dq} (v.(ktcore.NonMemb.LabelProof')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance NonMemb_access_store_LabelProof l (v : (ktcore.NonMemb.t)) LabelProof' :
  AccessStrict
    (l.[(ktcore.NonMemb.t), "LabelProof"] ↦ (v.(ktcore.NonMemb.LabelProof')))
    (l.[(ktcore.NonMemb.t), "LabelProof"] ↦ LabelProof')
    (l ↦ v) (l ↦ (v <|(ktcore.NonMemb.LabelProof') := LabelProof'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance NonMemb_access_load_MerkleProof l (v : (ktcore.NonMemb.t)) dq :
  AccessStrict
    (l.[(ktcore.NonMemb.t), "MerkleProof"] ↦{dq} (v.(ktcore.NonMemb.MerkleProof')))
    (l.[(ktcore.NonMemb.t), "MerkleProof"] ↦{dq} (v.(ktcore.NonMemb.MerkleProof')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance NonMemb_access_store_MerkleProof l (v : (ktcore.NonMemb.t)) MerkleProof' :
  AccessStrict
    (l.[(ktcore.NonMemb.t), "MerkleProof"] ↦ (v.(ktcore.NonMemb.MerkleProof')))
    (l.[(ktcore.NonMemb.t), "MerkleProof"] ↦ MerkleProof')
    (l ↦ v) (l ↦ (v <|(ktcore.NonMemb.MerkleProof') := MerkleProof'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End NonMemb.

Module AuditProof.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : ktcore.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance AuditProof_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (ktcore.AuditProof.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "Updates" ∷ l.[(ktcore.AuditProof.t), "Updates"] ↦{dq} v.(ktcore.AuditProof.Updates') ∗
      "LinkSig" ∷ l.[(ktcore.AuditProof.t), "LinkSig"] ↦{dq} v.(ktcore.AuditProof.LinkSig') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance AuditProof_into_val_typed
   :
  IntoValTypedUnderlying (ktcore.AuditProof.t) (ktcore.AuditProofⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance AuditProof_access_load_Updates l (v : (ktcore.AuditProof.t)) dq :
  AccessStrict
    (l.[(ktcore.AuditProof.t), "Updates"] ↦{dq} (v.(ktcore.AuditProof.Updates')))
    (l.[(ktcore.AuditProof.t), "Updates"] ↦{dq} (v.(ktcore.AuditProof.Updates')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance AuditProof_access_store_Updates l (v : (ktcore.AuditProof.t)) Updates' :
  AccessStrict
    (l.[(ktcore.AuditProof.t), "Updates"] ↦ (v.(ktcore.AuditProof.Updates')))
    (l.[(ktcore.AuditProof.t), "Updates"] ↦ Updates')
    (l ↦ v) (l ↦ (v <|(ktcore.AuditProof.Updates') := Updates'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance AuditProof_access_load_LinkSig l (v : (ktcore.AuditProof.t)) dq :
  AccessStrict
    (l.[(ktcore.AuditProof.t), "LinkSig"] ↦{dq} (v.(ktcore.AuditProof.LinkSig')))
    (l.[(ktcore.AuditProof.t), "LinkSig"] ↦{dq} (v.(ktcore.AuditProof.LinkSig')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance AuditProof_access_store_LinkSig l (v : (ktcore.AuditProof.t)) LinkSig' :
  AccessStrict
    (l.[(ktcore.AuditProof.t), "LinkSig"] ↦ (v.(ktcore.AuditProof.LinkSig')))
    (l.[(ktcore.AuditProof.t), "LinkSig"] ↦ LinkSig')
    (l ↦ v) (l ↦ (v <|(ktcore.AuditProof.LinkSig') := LinkSig'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End AuditProof.

Module UpdateProof.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : ktcore.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance UpdateProof_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (ktcore.UpdateProof.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "MapLabel" ∷ l.[(ktcore.UpdateProof.t), "MapLabel"] ↦{dq} v.(ktcore.UpdateProof.MapLabel') ∗
      "MapVal" ∷ l.[(ktcore.UpdateProof.t), "MapVal"] ↦{dq} v.(ktcore.UpdateProof.MapVal') ∗
      "NonMembProof" ∷ l.[(ktcore.UpdateProof.t), "NonMembProof"] ↦{dq} v.(ktcore.UpdateProof.NonMembProof') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance UpdateProof_into_val_typed
   :
  IntoValTypedUnderlying (ktcore.UpdateProof.t) (ktcore.UpdateProofⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance UpdateProof_access_load_MapLabel l (v : (ktcore.UpdateProof.t)) dq :
  AccessStrict
    (l.[(ktcore.UpdateProof.t), "MapLabel"] ↦{dq} (v.(ktcore.UpdateProof.MapLabel')))
    (l.[(ktcore.UpdateProof.t), "MapLabel"] ↦{dq} (v.(ktcore.UpdateProof.MapLabel')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance UpdateProof_access_store_MapLabel l (v : (ktcore.UpdateProof.t)) MapLabel' :
  AccessStrict
    (l.[(ktcore.UpdateProof.t), "MapLabel"] ↦ (v.(ktcore.UpdateProof.MapLabel')))
    (l.[(ktcore.UpdateProof.t), "MapLabel"] ↦ MapLabel')
    (l ↦ v) (l ↦ (v <|(ktcore.UpdateProof.MapLabel') := MapLabel'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance UpdateProof_access_load_MapVal l (v : (ktcore.UpdateProof.t)) dq :
  AccessStrict
    (l.[(ktcore.UpdateProof.t), "MapVal"] ↦{dq} (v.(ktcore.UpdateProof.MapVal')))
    (l.[(ktcore.UpdateProof.t), "MapVal"] ↦{dq} (v.(ktcore.UpdateProof.MapVal')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance UpdateProof_access_store_MapVal l (v : (ktcore.UpdateProof.t)) MapVal' :
  AccessStrict
    (l.[(ktcore.UpdateProof.t), "MapVal"] ↦ (v.(ktcore.UpdateProof.MapVal')))
    (l.[(ktcore.UpdateProof.t), "MapVal"] ↦ MapVal')
    (l ↦ v) (l ↦ (v <|(ktcore.UpdateProof.MapVal') := MapVal'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance UpdateProof_access_load_NonMembProof l (v : (ktcore.UpdateProof.t)) dq :
  AccessStrict
    (l.[(ktcore.UpdateProof.t), "NonMembProof"] ↦{dq} (v.(ktcore.UpdateProof.NonMembProof')))
    (l.[(ktcore.UpdateProof.t), "NonMembProof"] ↦{dq} (v.(ktcore.UpdateProof.NonMembProof')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance UpdateProof_access_store_NonMembProof l (v : (ktcore.UpdateProof.t)) NonMembProof' :
  AccessStrict
    (l.[(ktcore.UpdateProof.t), "NonMembProof"] ↦ (v.(ktcore.UpdateProof.NonMembProof')))
    (l.[(ktcore.UpdateProof.t), "NonMembProof"] ↦ NonMembProof')
    (l ↦ v) (l ↦ (v <|(ktcore.UpdateProof.NonMembProof') := NonMembProof'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End UpdateProof.

End ktcore.
