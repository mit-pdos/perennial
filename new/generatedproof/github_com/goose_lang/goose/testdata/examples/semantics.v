(* autogenerated by goose proofgen; do not modify *)
Require Export New.proof.disk_prelude.
Require Export New.generatedproof.encoding.binary.
Require Export New.generatedproof.github_com.goose_lang.primitive.
Require Export New.generatedproof.github_com.goose_lang.primitive.disk.
Require Export New.generatedproof.sync.
Require Export New.golang.theory.
Require Export New.code.github_com.goose_lang.goose.testdata.examples.semantics.

Set Default Proof Using "Type".

Module semantics.
Module unit.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : semantics.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance unit_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (semantics.unit.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance unit_into_val_typed
   :
  IntoValTypedUnderlying (semantics.unit.t) (semantics.unitⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.

End def.
End unit.

Module Editor.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : semantics.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance Editor_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (semantics.Editor.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "s" ∷ l.[(semantics.Editor.t), "s"] ↦{dq} v.(semantics.Editor.s') ∗
      "next_val" ∷ l.[(semantics.Editor.t), "next_val"] ↦{dq} v.(semantics.Editor.next_val') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance Editor_into_val_typed
   :
  IntoValTypedUnderlying (semantics.Editor.t) (semantics.Editorⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance Editor_access_load_s l (v : (semantics.Editor.t)) dq :
  AccessStrict
    (l.[(semantics.Editor.t), "s"] ↦{dq} (v.(semantics.Editor.s')))
    (l.[(semantics.Editor.t), "s"] ↦{dq} (v.(semantics.Editor.s')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Editor_access_store_s l (v : (semantics.Editor.t)) s' :
  AccessStrict
    (l.[(semantics.Editor.t), "s"] ↦ (v.(semantics.Editor.s')))
    (l.[(semantics.Editor.t), "s"] ↦ s')
    (l ↦ v) (l ↦ (v <|(semantics.Editor.s') := s'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Editor_access_load_next_val l (v : (semantics.Editor.t)) dq :
  AccessStrict
    (l.[(semantics.Editor.t), "next_val"] ↦{dq} (v.(semantics.Editor.next_val')))
    (l.[(semantics.Editor.t), "next_val"] ↦{dq} (v.(semantics.Editor.next_val')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Editor_access_store_next_val l (v : (semantics.Editor.t)) next_val' :
  AccessStrict
    (l.[(semantics.Editor.t), "next_val"] ↦ (v.(semantics.Editor.next_val')))
    (l.[(semantics.Editor.t), "next_val"] ↦ next_val')
    (l ↦ v) (l ↦ (v <|(semantics.Editor.next_val') := next_val'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End Editor.

Module Pair.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : semantics.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance Pair_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (semantics.Pair.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "x" ∷ l.[(semantics.Pair.t), "x"] ↦{dq} v.(semantics.Pair.x') ∗
      "y" ∷ l.[(semantics.Pair.t), "y"] ↦{dq} v.(semantics.Pair.y') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance Pair_into_val_typed
   :
  IntoValTypedUnderlying (semantics.Pair.t) (semantics.Pairⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance Pair_access_load_x l (v : (semantics.Pair.t)) dq :
  AccessStrict
    (l.[(semantics.Pair.t), "x"] ↦{dq} (v.(semantics.Pair.x')))
    (l.[(semantics.Pair.t), "x"] ↦{dq} (v.(semantics.Pair.x')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Pair_access_store_x l (v : (semantics.Pair.t)) x' :
  AccessStrict
    (l.[(semantics.Pair.t), "x"] ↦ (v.(semantics.Pair.x')))
    (l.[(semantics.Pair.t), "x"] ↦ x')
    (l ↦ v) (l ↦ (v <|(semantics.Pair.x') := x'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Pair_access_load_y l (v : (semantics.Pair.t)) dq :
  AccessStrict
    (l.[(semantics.Pair.t), "y"] ↦{dq} (v.(semantics.Pair.y')))
    (l.[(semantics.Pair.t), "y"] ↦{dq} (v.(semantics.Pair.y')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Pair_access_store_y l (v : (semantics.Pair.t)) y' :
  AccessStrict
    (l.[(semantics.Pair.t), "y"] ↦ (v.(semantics.Pair.y')))
    (l.[(semantics.Pair.t), "y"] ↦ y')
    (l ↦ v) (l ↦ (v <|(semantics.Pair.y') := y'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End Pair.

Module SquareStruct.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : semantics.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance SquareStruct_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (semantics.SquareStruct.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "Side" ∷ l.[(semantics.SquareStruct.t), "Side"] ↦{dq} v.(semantics.SquareStruct.Side') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance SquareStruct_into_val_typed
   :
  IntoValTypedUnderlying (semantics.SquareStruct.t) (semantics.SquareStructⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance SquareStruct_access_load_Side l (v : (semantics.SquareStruct.t)) dq :
  AccessStrict
    (l.[(semantics.SquareStruct.t), "Side"] ↦{dq} (v.(semantics.SquareStruct.Side')))
    (l.[(semantics.SquareStruct.t), "Side"] ↦{dq} (v.(semantics.SquareStruct.Side')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance SquareStruct_access_store_Side l (v : (semantics.SquareStruct.t)) Side' :
  AccessStrict
    (l.[(semantics.SquareStruct.t), "Side"] ↦ (v.(semantics.SquareStruct.Side')))
    (l.[(semantics.SquareStruct.t), "Side"] ↦ Side')
    (l ↦ v) (l ↦ (v <|(semantics.SquareStruct.Side') := Side'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End SquareStruct.

Module NumStruct.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : semantics.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance NumStruct_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (semantics.NumStruct.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "Value" ∷ l.[(semantics.NumStruct.t), "Value"] ↦{dq} v.(semantics.NumStruct.Value') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance NumStruct_into_val_typed
   :
  IntoValTypedUnderlying (semantics.NumStruct.t) (semantics.NumStructⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance NumStruct_access_load_Value l (v : (semantics.NumStruct.t)) dq :
  AccessStrict
    (l.[(semantics.NumStruct.t), "Value"] ↦{dq} (v.(semantics.NumStruct.Value')))
    (l.[(semantics.NumStruct.t), "Value"] ↦{dq} (v.(semantics.NumStruct.Value')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance NumStruct_access_store_Value l (v : (semantics.NumStruct.t)) Value' :
  AccessStrict
    (l.[(semantics.NumStruct.t), "Value"] ↦ (v.(semantics.NumStruct.Value')))
    (l.[(semantics.NumStruct.t), "Value"] ↦ Value')
    (l ↦ v) (l ↦ (v <|(semantics.NumStruct.Value') := Value'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End NumStruct.

Module shapeStruct.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : semantics.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance shapeStruct_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (semantics.shapeStruct.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "Shape" ∷ l.[(semantics.shapeStruct.t), "Shape"] ↦{dq} v.(semantics.shapeStruct.Shape') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance shapeStruct_into_val_typed
   :
  IntoValTypedUnderlying (semantics.shapeStruct.t) (semantics.shapeStructⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance shapeStruct_access_load_Shape l (v : (semantics.shapeStruct.t)) dq :
  AccessStrict
    (l.[(semantics.shapeStruct.t), "Shape"] ↦{dq} (v.(semantics.shapeStruct.Shape')))
    (l.[(semantics.shapeStruct.t), "Shape"] ↦{dq} (v.(semantics.shapeStruct.Shape')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance shapeStruct_access_store_Shape l (v : (semantics.shapeStruct.t)) Shape' :
  AccessStrict
    (l.[(semantics.shapeStruct.t), "Shape"] ↦ (v.(semantics.shapeStruct.Shape')))
    (l.[(semantics.shapeStruct.t), "Shape"] ↦ Shape')
    (l ↦ v) (l ↦ (v <|(semantics.shapeStruct.Shape') := Shape'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End shapeStruct.

Module polygonStruct.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : semantics.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance polygonStruct_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (semantics.polygonStruct.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "Shape" ∷ l.[(semantics.polygonStruct.t), "Shape"] ↦{dq} v.(semantics.polygonStruct.Shape') ∗
      "Sides" ∷ l.[(semantics.polygonStruct.t), "Sides"] ↦{dq} v.(semantics.polygonStruct.Sides') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance polygonStruct_into_val_typed
   :
  IntoValTypedUnderlying (semantics.polygonStruct.t) (semantics.polygonStructⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance polygonStruct_access_load_Shape l (v : (semantics.polygonStruct.t)) dq :
  AccessStrict
    (l.[(semantics.polygonStruct.t), "Shape"] ↦{dq} (v.(semantics.polygonStruct.Shape')))
    (l.[(semantics.polygonStruct.t), "Shape"] ↦{dq} (v.(semantics.polygonStruct.Shape')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance polygonStruct_access_store_Shape l (v : (semantics.polygonStruct.t)) Shape' :
  AccessStrict
    (l.[(semantics.polygonStruct.t), "Shape"] ↦ (v.(semantics.polygonStruct.Shape')))
    (l.[(semantics.polygonStruct.t), "Shape"] ↦ Shape')
    (l ↦ v) (l ↦ (v <|(semantics.polygonStruct.Shape') := Shape'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance polygonStruct_access_load_Sides l (v : (semantics.polygonStruct.t)) dq :
  AccessStrict
    (l.[(semantics.polygonStruct.t), "Sides"] ↦{dq} (v.(semantics.polygonStruct.Sides')))
    (l.[(semantics.polygonStruct.t), "Sides"] ↦{dq} (v.(semantics.polygonStruct.Sides')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance polygonStruct_access_store_Sides l (v : (semantics.polygonStruct.t)) Sides' :
  AccessStrict
    (l.[(semantics.polygonStruct.t), "Sides"] ↦ (v.(semantics.polygonStruct.Sides')))
    (l.[(semantics.polygonStruct.t), "Sides"] ↦ Sides')
    (l ↦ v) (l ↦ (v <|(semantics.polygonStruct.Sides') := Sides'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End polygonStruct.

Module PaperStruct.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : semantics.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance PaperStruct_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (semantics.PaperStruct.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "Title" ∷ l.[(semantics.PaperStruct.t), "Title"] ↦{dq} v.(semantics.PaperStruct.Title') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance PaperStruct_into_val_typed
   :
  IntoValTypedUnderlying (semantics.PaperStruct.t) (semantics.PaperStructⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance PaperStruct_access_load_Title l (v : (semantics.PaperStruct.t)) dq :
  AccessStrict
    (l.[(semantics.PaperStruct.t), "Title"] ↦{dq} (v.(semantics.PaperStruct.Title')))
    (l.[(semantics.PaperStruct.t), "Title"] ↦{dq} (v.(semantics.PaperStruct.Title')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance PaperStruct_access_store_Title l (v : (semantics.PaperStruct.t)) Title' :
  AccessStrict
    (l.[(semantics.PaperStruct.t), "Title"] ↦ (v.(semantics.PaperStruct.Title')))
    (l.[(semantics.PaperStruct.t), "Title"] ↦ Title')
    (l ↦ v) (l ↦ (v <|(semantics.PaperStruct.Title') := Title'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End PaperStruct.

Module Lily.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : semantics.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance Lily_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (semantics.Lily.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance Lily_into_val_typed
   :
  IntoValTypedUnderlying (semantics.Lily.t) (semantics.Lilyⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.

End def.
End Lily.

Module Rose.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : semantics.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance Rose_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (semantics.Rose.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance Rose_into_val_typed
   :
  IntoValTypedUnderlying (semantics.Rose.t) (semantics.Roseⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.

End def.
End Rose.

Module Daisy.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : semantics.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance Daisy_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (semantics.Daisy.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance Daisy_into_val_typed
   :
  IntoValTypedUnderlying (semantics.Daisy.t) (semantics.Daisyⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.

End def.
End Daisy.

Module LoopStruct.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : semantics.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance LoopStruct_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (semantics.LoopStruct.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "loopNext" ∷ l.[(semantics.LoopStruct.t), "loopNext"] ↦{dq} v.(semantics.LoopStruct.loopNext') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance LoopStruct_into_val_typed
   :
  IntoValTypedUnderlying (semantics.LoopStruct.t) (semantics.LoopStructⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance LoopStruct_access_load_loopNext l (v : (semantics.LoopStruct.t)) dq :
  AccessStrict
    (l.[(semantics.LoopStruct.t), "loopNext"] ↦{dq} (v.(semantics.LoopStruct.loopNext')))
    (l.[(semantics.LoopStruct.t), "loopNext"] ↦{dq} (v.(semantics.LoopStruct.loopNext')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance LoopStruct_access_store_loopNext l (v : (semantics.LoopStruct.t)) loopNext' :
  AccessStrict
    (l.[(semantics.LoopStruct.t), "loopNext"] ↦ (v.(semantics.LoopStruct.loopNext')))
    (l.[(semantics.LoopStruct.t), "loopNext"] ↦ loopNext')
    (l ↦ v) (l ↦ (v <|(semantics.LoopStruct.loopNext') := loopNext'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End LoopStruct.

Module BoolTest.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : semantics.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance BoolTest_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (semantics.BoolTest.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "t" ∷ l.[(semantics.BoolTest.t), "t"] ↦{dq} v.(semantics.BoolTest.t') ∗
      "f" ∷ l.[(semantics.BoolTest.t), "f"] ↦{dq} v.(semantics.BoolTest.f') ∗
      "tc" ∷ l.[(semantics.BoolTest.t), "tc"] ↦{dq} v.(semantics.BoolTest.tc') ∗
      "fc" ∷ l.[(semantics.BoolTest.t), "fc"] ↦{dq} v.(semantics.BoolTest.fc') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance BoolTest_into_val_typed
   :
  IntoValTypedUnderlying (semantics.BoolTest.t) (semantics.BoolTestⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance BoolTest_access_load_t l (v : (semantics.BoolTest.t)) dq :
  AccessStrict
    (l.[(semantics.BoolTest.t), "t"] ↦{dq} (v.(semantics.BoolTest.t')))
    (l.[(semantics.BoolTest.t), "t"] ↦{dq} (v.(semantics.BoolTest.t')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance BoolTest_access_store_t l (v : (semantics.BoolTest.t)) t' :
  AccessStrict
    (l.[(semantics.BoolTest.t), "t"] ↦ (v.(semantics.BoolTest.t')))
    (l.[(semantics.BoolTest.t), "t"] ↦ t')
    (l ↦ v) (l ↦ (v <|(semantics.BoolTest.t') := t'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance BoolTest_access_load_f l (v : (semantics.BoolTest.t)) dq :
  AccessStrict
    (l.[(semantics.BoolTest.t), "f"] ↦{dq} (v.(semantics.BoolTest.f')))
    (l.[(semantics.BoolTest.t), "f"] ↦{dq} (v.(semantics.BoolTest.f')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance BoolTest_access_store_f l (v : (semantics.BoolTest.t)) f' :
  AccessStrict
    (l.[(semantics.BoolTest.t), "f"] ↦ (v.(semantics.BoolTest.f')))
    (l.[(semantics.BoolTest.t), "f"] ↦ f')
    (l ↦ v) (l ↦ (v <|(semantics.BoolTest.f') := f'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance BoolTest_access_load_tc l (v : (semantics.BoolTest.t)) dq :
  AccessStrict
    (l.[(semantics.BoolTest.t), "tc"] ↦{dq} (v.(semantics.BoolTest.tc')))
    (l.[(semantics.BoolTest.t), "tc"] ↦{dq} (v.(semantics.BoolTest.tc')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance BoolTest_access_store_tc l (v : (semantics.BoolTest.t)) tc' :
  AccessStrict
    (l.[(semantics.BoolTest.t), "tc"] ↦ (v.(semantics.BoolTest.tc')))
    (l.[(semantics.BoolTest.t), "tc"] ↦ tc')
    (l ↦ v) (l ↦ (v <|(semantics.BoolTest.tc') := tc'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance BoolTest_access_load_fc l (v : (semantics.BoolTest.t)) dq :
  AccessStrict
    (l.[(semantics.BoolTest.t), "fc"] ↦{dq} (v.(semantics.BoolTest.fc')))
    (l.[(semantics.BoolTest.t), "fc"] ↦{dq} (v.(semantics.BoolTest.fc')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance BoolTest_access_store_fc l (v : (semantics.BoolTest.t)) fc' :
  AccessStrict
    (l.[(semantics.BoolTest.t), "fc"] ↦ (v.(semantics.BoolTest.fc')))
    (l.[(semantics.BoolTest.t), "fc"] ↦ fc')
    (l ↦ v) (l ↦ (v <|(semantics.BoolTest.fc') := fc'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End BoolTest.

Module ArrayEditor.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : semantics.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance ArrayEditor_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (semantics.ArrayEditor.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "s" ∷ l.[(semantics.ArrayEditor.t), "s"] ↦{dq} v.(semantics.ArrayEditor.s') ∗
      "next_val" ∷ l.[(semantics.ArrayEditor.t), "next_val"] ↦{dq} v.(semantics.ArrayEditor.next_val') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance ArrayEditor_into_val_typed
   :
  IntoValTypedUnderlying (semantics.ArrayEditor.t) (semantics.ArrayEditorⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance ArrayEditor_access_load_s l (v : (semantics.ArrayEditor.t)) dq :
  AccessStrict
    (l.[(semantics.ArrayEditor.t), "s"] ↦{dq} (v.(semantics.ArrayEditor.s')))
    (l.[(semantics.ArrayEditor.t), "s"] ↦{dq} (v.(semantics.ArrayEditor.s')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance ArrayEditor_access_store_s l (v : (semantics.ArrayEditor.t)) s' :
  AccessStrict
    (l.[(semantics.ArrayEditor.t), "s"] ↦ (v.(semantics.ArrayEditor.s')))
    (l.[(semantics.ArrayEditor.t), "s"] ↦ s')
    (l ↦ v) (l ↦ (v <|(semantics.ArrayEditor.s') := s'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance ArrayEditor_access_load_next_val l (v : (semantics.ArrayEditor.t)) dq :
  AccessStrict
    (l.[(semantics.ArrayEditor.t), "next_val"] ↦{dq} (v.(semantics.ArrayEditor.next_val')))
    (l.[(semantics.ArrayEditor.t), "next_val"] ↦{dq} (v.(semantics.ArrayEditor.next_val')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance ArrayEditor_access_store_next_val l (v : (semantics.ArrayEditor.t)) next_val' :
  AccessStrict
    (l.[(semantics.ArrayEditor.t), "next_val"] ↦ (v.(semantics.ArrayEditor.next_val')))
    (l.[(semantics.ArrayEditor.t), "next_val"] ↦ next_val')
    (l ↦ v) (l ↦ (v <|(semantics.ArrayEditor.next_val') := next_val'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End ArrayEditor.

Module Bar.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : semantics.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance Bar_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (semantics.Bar.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "a" ∷ l.[(semantics.Bar.t), "a"] ↦{dq} v.(semantics.Bar.a') ∗
      "b" ∷ l.[(semantics.Bar.t), "b"] ↦{dq} v.(semantics.Bar.b') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance Bar_into_val_typed
   :
  IntoValTypedUnderlying (semantics.Bar.t) (semantics.Barⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance Bar_access_load_a l (v : (semantics.Bar.t)) dq :
  AccessStrict
    (l.[(semantics.Bar.t), "a"] ↦{dq} (v.(semantics.Bar.a')))
    (l.[(semantics.Bar.t), "a"] ↦{dq} (v.(semantics.Bar.a')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Bar_access_store_a l (v : (semantics.Bar.t)) a' :
  AccessStrict
    (l.[(semantics.Bar.t), "a"] ↦ (v.(semantics.Bar.a')))
    (l.[(semantics.Bar.t), "a"] ↦ a')
    (l ↦ v) (l ↦ (v <|(semantics.Bar.a') := a'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Bar_access_load_b l (v : (semantics.Bar.t)) dq :
  AccessStrict
    (l.[(semantics.Bar.t), "b"] ↦{dq} (v.(semantics.Bar.b')))
    (l.[(semantics.Bar.t), "b"] ↦{dq} (v.(semantics.Bar.b')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Bar_access_store_b l (v : (semantics.Bar.t)) b' :
  AccessStrict
    (l.[(semantics.Bar.t), "b"] ↦ (v.(semantics.Bar.b')))
    (l.[(semantics.Bar.t), "b"] ↦ b')
    (l ↦ v) (l ↦ (v <|(semantics.Bar.b') := b'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End Bar.

Module Foo.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : semantics.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance Foo_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (semantics.Foo.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "bar" ∷ l.[(semantics.Foo.t), "bar"] ↦{dq} v.(semantics.Foo.bar') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance Foo_into_val_typed
   :
  IntoValTypedUnderlying (semantics.Foo.t) (semantics.Fooⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance Foo_access_load_bar l (v : (semantics.Foo.t)) dq :
  AccessStrict
    (l.[(semantics.Foo.t), "bar"] ↦{dq} (v.(semantics.Foo.bar')))
    (l.[(semantics.Foo.t), "bar"] ↦{dq} (v.(semantics.Foo.bar')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Foo_access_store_bar l (v : (semantics.Foo.t)) bar' :
  AccessStrict
    (l.[(semantics.Foo.t), "bar"] ↦ (v.(semantics.Foo.bar')))
    (l.[(semantics.Foo.t), "bar"] ↦ bar')
    (l ↦ v) (l ↦ (v <|(semantics.Foo.bar') := bar'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End Foo.

Module TwoInts.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : semantics.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance TwoInts_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (semantics.TwoInts.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "x" ∷ l.[(semantics.TwoInts.t), "x"] ↦{dq} v.(semantics.TwoInts.x') ∗
      "y" ∷ l.[(semantics.TwoInts.t), "y"] ↦{dq} v.(semantics.TwoInts.y') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance TwoInts_into_val_typed
   :
  IntoValTypedUnderlying (semantics.TwoInts.t) (semantics.TwoIntsⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance TwoInts_access_load_x l (v : (semantics.TwoInts.t)) dq :
  AccessStrict
    (l.[(semantics.TwoInts.t), "x"] ↦{dq} (v.(semantics.TwoInts.x')))
    (l.[(semantics.TwoInts.t), "x"] ↦{dq} (v.(semantics.TwoInts.x')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance TwoInts_access_store_x l (v : (semantics.TwoInts.t)) x' :
  AccessStrict
    (l.[(semantics.TwoInts.t), "x"] ↦ (v.(semantics.TwoInts.x')))
    (l.[(semantics.TwoInts.t), "x"] ↦ x')
    (l ↦ v) (l ↦ (v <|(semantics.TwoInts.x') := x'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance TwoInts_access_load_y l (v : (semantics.TwoInts.t)) dq :
  AccessStrict
    (l.[(semantics.TwoInts.t), "y"] ↦{dq} (v.(semantics.TwoInts.y')))
    (l.[(semantics.TwoInts.t), "y"] ↦{dq} (v.(semantics.TwoInts.y')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance TwoInts_access_store_y l (v : (semantics.TwoInts.t)) y' :
  AccessStrict
    (l.[(semantics.TwoInts.t), "y"] ↦ (v.(semantics.TwoInts.y')))
    (l.[(semantics.TwoInts.t), "y"] ↦ y')
    (l ↦ v) (l ↦ (v <|(semantics.TwoInts.y') := y'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End TwoInts.

Module S.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : semantics.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance S_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (semantics.S.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "a" ∷ l.[(semantics.S.t), "a"] ↦{dq} v.(semantics.S.a') ∗
      "b" ∷ l.[(semantics.S.t), "b"] ↦{dq} v.(semantics.S.b') ∗
      "c" ∷ l.[(semantics.S.t), "c"] ↦{dq} v.(semantics.S.c') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance S_into_val_typed
   :
  IntoValTypedUnderlying (semantics.S.t) (semantics.Sⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance S_access_load_a l (v : (semantics.S.t)) dq :
  AccessStrict
    (l.[(semantics.S.t), "a"] ↦{dq} (v.(semantics.S.a')))
    (l.[(semantics.S.t), "a"] ↦{dq} (v.(semantics.S.a')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance S_access_store_a l (v : (semantics.S.t)) a' :
  AccessStrict
    (l.[(semantics.S.t), "a"] ↦ (v.(semantics.S.a')))
    (l.[(semantics.S.t), "a"] ↦ a')
    (l ↦ v) (l ↦ (v <|(semantics.S.a') := a'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance S_access_load_b l (v : (semantics.S.t)) dq :
  AccessStrict
    (l.[(semantics.S.t), "b"] ↦{dq} (v.(semantics.S.b')))
    (l.[(semantics.S.t), "b"] ↦{dq} (v.(semantics.S.b')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance S_access_store_b l (v : (semantics.S.t)) b' :
  AccessStrict
    (l.[(semantics.S.t), "b"] ↦ (v.(semantics.S.b')))
    (l.[(semantics.S.t), "b"] ↦ b')
    (l ↦ v) (l ↦ (v <|(semantics.S.b') := b'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance S_access_load_c l (v : (semantics.S.t)) dq :
  AccessStrict
    (l.[(semantics.S.t), "c"] ↦{dq} (v.(semantics.S.c')))
    (l.[(semantics.S.t), "c"] ↦{dq} (v.(semantics.S.c')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance S_access_store_c l (v : (semantics.S.t)) c' :
  AccessStrict
    (l.[(semantics.S.t), "c"] ↦ (v.(semantics.S.c')))
    (l.[(semantics.S.t), "c"] ↦ c')
    (l ↦ v) (l ↦ (v <|(semantics.S.c') := c'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End S.

Module StructWrap.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : semantics.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance StructWrap_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (semantics.StructWrap.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "i" ∷ l.[(semantics.StructWrap.t), "i"] ↦{dq} v.(semantics.StructWrap.i') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance StructWrap_into_val_typed
   :
  IntoValTypedUnderlying (semantics.StructWrap.t) (semantics.StructWrapⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance StructWrap_access_load_i l (v : (semantics.StructWrap.t)) dq :
  AccessStrict
    (l.[(semantics.StructWrap.t), "i"] ↦{dq} (v.(semantics.StructWrap.i')))
    (l.[(semantics.StructWrap.t), "i"] ↦{dq} (v.(semantics.StructWrap.i')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance StructWrap_access_store_i l (v : (semantics.StructWrap.t)) i' :
  AccessStrict
    (l.[(semantics.StructWrap.t), "i"] ↦ (v.(semantics.StructWrap.i')))
    (l.[(semantics.StructWrap.t), "i"] ↦ i')
    (l ↦ v) (l ↦ (v <|(semantics.StructWrap.i') := i'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End StructWrap.

Module StructWithFunc.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : semantics.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance StructWithFunc_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (semantics.StructWithFunc.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "fn" ∷ l.[(semantics.StructWithFunc.t), "fn"] ↦{dq} v.(semantics.StructWithFunc.fn') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance StructWithFunc_into_val_typed
   :
  IntoValTypedUnderlying (semantics.StructWithFunc.t) (semantics.StructWithFuncⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance StructWithFunc_access_load_fn l (v : (semantics.StructWithFunc.t)) dq :
  AccessStrict
    (l.[(semantics.StructWithFunc.t), "fn"] ↦{dq} (v.(semantics.StructWithFunc.fn')))
    (l.[(semantics.StructWithFunc.t), "fn"] ↦{dq} (v.(semantics.StructWithFunc.fn')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance StructWithFunc_access_store_fn l (v : (semantics.StructWithFunc.t)) fn' :
  AccessStrict
    (l.[(semantics.StructWithFunc.t), "fn"] ↦ (v.(semantics.StructWithFunc.fn')))
    (l.[(semantics.StructWithFunc.t), "fn"] ↦ fn')
    (l ↦ v) (l ↦ (v <|(semantics.StructWithFunc.fn') := fn'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End StructWithFunc.

Module switchConcrete.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : semantics.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance switchConcrete_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (semantics.switchConcrete.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance switchConcrete_into_val_typed
   :
  IntoValTypedUnderlying (semantics.switchConcrete.t) (semantics.switchConcreteⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.

End def.
End switchConcrete.

Module List.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : semantics.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance List_typed_pointsto `{!TypedPointsto (Σ:=Σ) T'}  :
  TypedPointsto (Σ:=Σ) (semantics.List.t T') :=
  {|
    typed_pointsto_def l v dq :=
      (
      "X" ∷ l.[(semantics.List.t T'), "X"] ↦{dq} v.(semantics.List.X') ∗
      "Next" ∷ l.[(semantics.List.t T'), "Next"] ↦{dq} v.(semantics.List.Next') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance List_into_val_typed
  `{!ZeroVal T'} `{!TypedPointsto (Σ:=Σ) T'} `{!IntoValTyped T' T}  :
  IntoValTypedUnderlying (semantics.List.t T') (semantics.Listⁱᵐᵖˡ T).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance List_access_load_X `{!TypedPointsto (Σ:=Σ) T'} l (v : (semantics.List.t T')) dq :
  AccessStrict
    (l.[(semantics.List.t T'), "X"] ↦{dq} (v.(semantics.List.X')))
    (l.[(semantics.List.t T'), "X"] ↦{dq} (v.(semantics.List.X')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance List_access_store_X `{!TypedPointsto (Σ:=Σ) T'} l (v : (semantics.List.t T')) X' :
  AccessStrict
    (l.[(semantics.List.t T'), "X"] ↦ (v.(semantics.List.X')))
    (l.[(semantics.List.t T'), "X"] ↦ X')
    (l ↦ v) (l ↦ (v <|(semantics.List.X') := X'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance List_access_load_Next `{!TypedPointsto (Σ:=Σ) T'} l (v : (semantics.List.t T')) dq :
  AccessStrict
    (l.[(semantics.List.t T'), "Next"] ↦{dq} (v.(semantics.List.Next')))
    (l.[(semantics.List.t T'), "Next"] ↦{dq} (v.(semantics.List.Next')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance List_access_store_Next `{!TypedPointsto (Σ:=Σ) T'} l (v : (semantics.List.t T')) Next' :
  AccessStrict
    (l.[(semantics.List.t T'), "Next"] ↦ (v.(semantics.List.Next')))
    (l.[(semantics.List.t T'), "Next"] ↦ Next')
    (l ↦ v) (l ↦ (v <|(semantics.List.Next') := Next'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End List.

Module Log.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : semantics.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance Log_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (semantics.Log.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "d" ∷ l.[(semantics.Log.t), "d"] ↦{dq} v.(semantics.Log.d') ∗
      "l" ∷ l.[(semantics.Log.t), "l"] ↦{dq} v.(semantics.Log.l') ∗
      "cache" ∷ l.[(semantics.Log.t), "cache"] ↦{dq} v.(semantics.Log.cache') ∗
      "length" ∷ l.[(semantics.Log.t), "length"] ↦{dq} v.(semantics.Log.length') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance Log_into_val_typed
   :
  IntoValTypedUnderlying (semantics.Log.t) (semantics.Logⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance Log_access_load_d l (v : (semantics.Log.t)) dq :
  AccessStrict
    (l.[(semantics.Log.t), "d"] ↦{dq} (v.(semantics.Log.d')))
    (l.[(semantics.Log.t), "d"] ↦{dq} (v.(semantics.Log.d')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Log_access_store_d l (v : (semantics.Log.t)) d' :
  AccessStrict
    (l.[(semantics.Log.t), "d"] ↦ (v.(semantics.Log.d')))
    (l.[(semantics.Log.t), "d"] ↦ d')
    (l ↦ v) (l ↦ (v <|(semantics.Log.d') := d'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Log_access_load_l l (v : (semantics.Log.t)) dq :
  AccessStrict
    (l.[(semantics.Log.t), "l"] ↦{dq} (v.(semantics.Log.l')))
    (l.[(semantics.Log.t), "l"] ↦{dq} (v.(semantics.Log.l')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Log_access_store_l l (v : (semantics.Log.t)) l' :
  AccessStrict
    (l.[(semantics.Log.t), "l"] ↦ (v.(semantics.Log.l')))
    (l.[(semantics.Log.t), "l"] ↦ l')
    (l ↦ v) (l ↦ (v <|(semantics.Log.l') := l'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Log_access_load_cache l (v : (semantics.Log.t)) dq :
  AccessStrict
    (l.[(semantics.Log.t), "cache"] ↦{dq} (v.(semantics.Log.cache')))
    (l.[(semantics.Log.t), "cache"] ↦{dq} (v.(semantics.Log.cache')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Log_access_store_cache l (v : (semantics.Log.t)) cache' :
  AccessStrict
    (l.[(semantics.Log.t), "cache"] ↦ (v.(semantics.Log.cache')))
    (l.[(semantics.Log.t), "cache"] ↦ cache')
    (l ↦ v) (l ↦ (v <|(semantics.Log.cache') := cache'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Log_access_load_length l (v : (semantics.Log.t)) dq :
  AccessStrict
    (l.[(semantics.Log.t), "length"] ↦{dq} (v.(semantics.Log.length')))
    (l.[(semantics.Log.t), "length"] ↦{dq} (v.(semantics.Log.length')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Log_access_store_length l (v : (semantics.Log.t)) length' :
  AccessStrict
    (l.[(semantics.Log.t), "length"] ↦ (v.(semantics.Log.length')))
    (l.[(semantics.Log.t), "length"] ↦ length')
    (l ↦ v) (l ↦ (v <|(semantics.Log.length') := length'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End Log.

End semantics.
