(* autogenerated by goose proofgen; do not modify *)
Require Export New.proof.disk_prelude.
Require Export New.generatedproof.github_com.goose_lang.primitive.
Require Export New.generatedproof.github_com.goose_lang.primitive.disk.
Require Export New.generatedproof.sync.
Require Export New.golang.theory.
Require Export New.code.github_com.goose_lang.goose.testdata.examples.semantics.

Set Default Proof Using "Type".

Module semantics.
Module unit.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : semantics.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance unit_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (semantics.unit.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance unit_into_val_typed
   :
  IntoValTyped (semantics.unit.t) (semantics.unit).
Proof. solve_into_val_typed_struct. Qed.

End def.
End unit.

Module Enc.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : semantics.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance Enc_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (semantics.Enc.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "p" ∷ l.[(semantics.Enc.t), "p"] ↦{dq} v.(semantics.Enc.p') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance Enc_into_val_typed
   :
  IntoValTyped (semantics.Enc.t) (semantics.Enc).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance Enc_access_load_p l (v : (semantics.Enc.t)) dq :
  AccessStrict
    (l.[(semantics.Enc.t), "p"] ↦{dq} (v.(semantics.Enc.p')))
    (l.[(semantics.Enc.t), "p"] ↦{dq} (v.(semantics.Enc.p')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Enc_access_store_p l (v : (semantics.Enc.t)) p' :
  AccessStrict
    (l.[(semantics.Enc.t), "p"] ↦ (v.(semantics.Enc.p')))
    (l.[(semantics.Enc.t), "p"] ↦ p')
    (l ↦ v) (l ↦ (v <|(semantics.Enc.p') := p'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End Enc.

Module Dec.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : semantics.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance Dec_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (semantics.Dec.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "p" ∷ l.[(semantics.Dec.t), "p"] ↦{dq} v.(semantics.Dec.p') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance Dec_into_val_typed
   :
  IntoValTyped (semantics.Dec.t) (semantics.Dec).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance Dec_access_load_p l (v : (semantics.Dec.t)) dq :
  AccessStrict
    (l.[(semantics.Dec.t), "p"] ↦{dq} (v.(semantics.Dec.p')))
    (l.[(semantics.Dec.t), "p"] ↦{dq} (v.(semantics.Dec.p')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Dec_access_store_p l (v : (semantics.Dec.t)) p' :
  AccessStrict
    (l.[(semantics.Dec.t), "p"] ↦ (v.(semantics.Dec.p')))
    (l.[(semantics.Dec.t), "p"] ↦ p')
    (l ↦ v) (l ↦ (v <|(semantics.Dec.p') := p'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End Dec.

Module Editor.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : semantics.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance Editor_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (semantics.Editor.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "s" ∷ l.[(semantics.Editor.t), "s"] ↦{dq} v.(semantics.Editor.s') ∗
      "next_val" ∷ l.[(semantics.Editor.t), "next_val"] ↦{dq} v.(semantics.Editor.next_val') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance Editor_into_val_typed
   :
  IntoValTyped (semantics.Editor.t) (semantics.Editor).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance Editor_access_load_s l (v : (semantics.Editor.t)) dq :
  AccessStrict
    (l.[(semantics.Editor.t), "s"] ↦{dq} (v.(semantics.Editor.s')))
    (l.[(semantics.Editor.t), "s"] ↦{dq} (v.(semantics.Editor.s')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Editor_access_store_s l (v : (semantics.Editor.t)) s' :
  AccessStrict
    (l.[(semantics.Editor.t), "s"] ↦ (v.(semantics.Editor.s')))
    (l.[(semantics.Editor.t), "s"] ↦ s')
    (l ↦ v) (l ↦ (v <|(semantics.Editor.s') := s'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Editor_access_load_next_val l (v : (semantics.Editor.t)) dq :
  AccessStrict
    (l.[(semantics.Editor.t), "next_val"] ↦{dq} (v.(semantics.Editor.next_val')))
    (l.[(semantics.Editor.t), "next_val"] ↦{dq} (v.(semantics.Editor.next_val')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Editor_access_store_next_val l (v : (semantics.Editor.t)) next_val' :
  AccessStrict
    (l.[(semantics.Editor.t), "next_val"] ↦ (v.(semantics.Editor.next_val')))
    (l.[(semantics.Editor.t), "next_val"] ↦ next_val')
    (l ↦ v) (l ↦ (v <|(semantics.Editor.next_val') := next_val'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End Editor.

Module Pair.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : semantics.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance Pair_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (semantics.Pair.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "x" ∷ l.[(semantics.Pair.t), "x"] ↦{dq} v.(semantics.Pair.x') ∗
      "y" ∷ l.[(semantics.Pair.t), "y"] ↦{dq} v.(semantics.Pair.y') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance Pair_into_val_typed
   :
  IntoValTyped (semantics.Pair.t) (semantics.Pair).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance Pair_access_load_x l (v : (semantics.Pair.t)) dq :
  AccessStrict
    (l.[(semantics.Pair.t), "x"] ↦{dq} (v.(semantics.Pair.x')))
    (l.[(semantics.Pair.t), "x"] ↦{dq} (v.(semantics.Pair.x')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Pair_access_store_x l (v : (semantics.Pair.t)) x' :
  AccessStrict
    (l.[(semantics.Pair.t), "x"] ↦ (v.(semantics.Pair.x')))
    (l.[(semantics.Pair.t), "x"] ↦ x')
    (l ↦ v) (l ↦ (v <|(semantics.Pair.x') := x'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Pair_access_load_y l (v : (semantics.Pair.t)) dq :
  AccessStrict
    (l.[(semantics.Pair.t), "y"] ↦{dq} (v.(semantics.Pair.y')))
    (l.[(semantics.Pair.t), "y"] ↦{dq} (v.(semantics.Pair.y')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Pair_access_store_y l (v : (semantics.Pair.t)) y' :
  AccessStrict
    (l.[(semantics.Pair.t), "y"] ↦ (v.(semantics.Pair.y')))
    (l.[(semantics.Pair.t), "y"] ↦ y')
    (l ↦ v) (l ↦ (v <|(semantics.Pair.y') := y'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End Pair.

Module SquareStruct.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : semantics.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance SquareStruct_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (semantics.SquareStruct.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "Side" ∷ l.[(semantics.SquareStruct.t), "Side"] ↦{dq} v.(semantics.SquareStruct.Side') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance SquareStruct_into_val_typed
   :
  IntoValTyped (semantics.SquareStruct.t) (semantics.SquareStruct).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance SquareStruct_access_load_Side l (v : (semantics.SquareStruct.t)) dq :
  AccessStrict
    (l.[(semantics.SquareStruct.t), "Side"] ↦{dq} (v.(semantics.SquareStruct.Side')))
    (l.[(semantics.SquareStruct.t), "Side"] ↦{dq} (v.(semantics.SquareStruct.Side')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance SquareStruct_access_store_Side l (v : (semantics.SquareStruct.t)) Side' :
  AccessStrict
    (l.[(semantics.SquareStruct.t), "Side"] ↦ (v.(semantics.SquareStruct.Side')))
    (l.[(semantics.SquareStruct.t), "Side"] ↦ Side')
    (l ↦ v) (l ↦ (v <|(semantics.SquareStruct.Side') := Side'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End SquareStruct.

Module LoopStruct.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : semantics.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance LoopStruct_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (semantics.LoopStruct.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "loopNext" ∷ l.[(semantics.LoopStruct.t), "loopNext"] ↦{dq} v.(semantics.LoopStruct.loopNext') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance LoopStruct_into_val_typed
   :
  IntoValTyped (semantics.LoopStruct.t) (semantics.LoopStruct).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance LoopStruct_access_load_loopNext l (v : (semantics.LoopStruct.t)) dq :
  AccessStrict
    (l.[(semantics.LoopStruct.t), "loopNext"] ↦{dq} (v.(semantics.LoopStruct.loopNext')))
    (l.[(semantics.LoopStruct.t), "loopNext"] ↦{dq} (v.(semantics.LoopStruct.loopNext')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance LoopStruct_access_store_loopNext l (v : (semantics.LoopStruct.t)) loopNext' :
  AccessStrict
    (l.[(semantics.LoopStruct.t), "loopNext"] ↦ (v.(semantics.LoopStruct.loopNext')))
    (l.[(semantics.LoopStruct.t), "loopNext"] ↦ loopNext')
    (l ↦ v) (l ↦ (v <|(semantics.LoopStruct.loopNext') := loopNext'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End LoopStruct.

Module BoolTest.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : semantics.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance BoolTest_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (semantics.BoolTest.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "t" ∷ l.[(semantics.BoolTest.t), "t"] ↦{dq} v.(semantics.BoolTest.t') ∗
      "f" ∷ l.[(semantics.BoolTest.t), "f"] ↦{dq} v.(semantics.BoolTest.f') ∗
      "tc" ∷ l.[(semantics.BoolTest.t), "tc"] ↦{dq} v.(semantics.BoolTest.tc') ∗
      "fc" ∷ l.[(semantics.BoolTest.t), "fc"] ↦{dq} v.(semantics.BoolTest.fc') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance BoolTest_into_val_typed
   :
  IntoValTyped (semantics.BoolTest.t) (semantics.BoolTest).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance BoolTest_access_load_t l (v : (semantics.BoolTest.t)) dq :
  AccessStrict
    (l.[(semantics.BoolTest.t), "t"] ↦{dq} (v.(semantics.BoolTest.t')))
    (l.[(semantics.BoolTest.t), "t"] ↦{dq} (v.(semantics.BoolTest.t')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance BoolTest_access_store_t l (v : (semantics.BoolTest.t)) t' :
  AccessStrict
    (l.[(semantics.BoolTest.t), "t"] ↦ (v.(semantics.BoolTest.t')))
    (l.[(semantics.BoolTest.t), "t"] ↦ t')
    (l ↦ v) (l ↦ (v <|(semantics.BoolTest.t') := t'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance BoolTest_access_load_f l (v : (semantics.BoolTest.t)) dq :
  AccessStrict
    (l.[(semantics.BoolTest.t), "f"] ↦{dq} (v.(semantics.BoolTest.f')))
    (l.[(semantics.BoolTest.t), "f"] ↦{dq} (v.(semantics.BoolTest.f')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance BoolTest_access_store_f l (v : (semantics.BoolTest.t)) f' :
  AccessStrict
    (l.[(semantics.BoolTest.t), "f"] ↦ (v.(semantics.BoolTest.f')))
    (l.[(semantics.BoolTest.t), "f"] ↦ f')
    (l ↦ v) (l ↦ (v <|(semantics.BoolTest.f') := f'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance BoolTest_access_load_tc l (v : (semantics.BoolTest.t)) dq :
  AccessStrict
    (l.[(semantics.BoolTest.t), "tc"] ↦{dq} (v.(semantics.BoolTest.tc')))
    (l.[(semantics.BoolTest.t), "tc"] ↦{dq} (v.(semantics.BoolTest.tc')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance BoolTest_access_store_tc l (v : (semantics.BoolTest.t)) tc' :
  AccessStrict
    (l.[(semantics.BoolTest.t), "tc"] ↦ (v.(semantics.BoolTest.tc')))
    (l.[(semantics.BoolTest.t), "tc"] ↦ tc')
    (l ↦ v) (l ↦ (v <|(semantics.BoolTest.tc') := tc'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance BoolTest_access_load_fc l (v : (semantics.BoolTest.t)) dq :
  AccessStrict
    (l.[(semantics.BoolTest.t), "fc"] ↦{dq} (v.(semantics.BoolTest.fc')))
    (l.[(semantics.BoolTest.t), "fc"] ↦{dq} (v.(semantics.BoolTest.fc')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance BoolTest_access_store_fc l (v : (semantics.BoolTest.t)) fc' :
  AccessStrict
    (l.[(semantics.BoolTest.t), "fc"] ↦ (v.(semantics.BoolTest.fc')))
    (l.[(semantics.BoolTest.t), "fc"] ↦ fc')
    (l ↦ v) (l ↦ (v <|(semantics.BoolTest.fc') := fc'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End BoolTest.

Module ArrayEditor.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : semantics.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance ArrayEditor_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (semantics.ArrayEditor.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "s" ∷ l.[(semantics.ArrayEditor.t), "s"] ↦{dq} v.(semantics.ArrayEditor.s') ∗
      "next_val" ∷ l.[(semantics.ArrayEditor.t), "next_val"] ↦{dq} v.(semantics.ArrayEditor.next_val') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance ArrayEditor_into_val_typed
   :
  IntoValTyped (semantics.ArrayEditor.t) (semantics.ArrayEditor).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance ArrayEditor_access_load_s l (v : (semantics.ArrayEditor.t)) dq :
  AccessStrict
    (l.[(semantics.ArrayEditor.t), "s"] ↦{dq} (v.(semantics.ArrayEditor.s')))
    (l.[(semantics.ArrayEditor.t), "s"] ↦{dq} (v.(semantics.ArrayEditor.s')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance ArrayEditor_access_store_s l (v : (semantics.ArrayEditor.t)) s' :
  AccessStrict
    (l.[(semantics.ArrayEditor.t), "s"] ↦ (v.(semantics.ArrayEditor.s')))
    (l.[(semantics.ArrayEditor.t), "s"] ↦ s')
    (l ↦ v) (l ↦ (v <|(semantics.ArrayEditor.s') := s'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance ArrayEditor_access_load_next_val l (v : (semantics.ArrayEditor.t)) dq :
  AccessStrict
    (l.[(semantics.ArrayEditor.t), "next_val"] ↦{dq} (v.(semantics.ArrayEditor.next_val')))
    (l.[(semantics.ArrayEditor.t), "next_val"] ↦{dq} (v.(semantics.ArrayEditor.next_val')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance ArrayEditor_access_store_next_val l (v : (semantics.ArrayEditor.t)) next_val' :
  AccessStrict
    (l.[(semantics.ArrayEditor.t), "next_val"] ↦ (v.(semantics.ArrayEditor.next_val')))
    (l.[(semantics.ArrayEditor.t), "next_val"] ↦ next_val')
    (l ↦ v) (l ↦ (v <|(semantics.ArrayEditor.next_val') := next_val'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End ArrayEditor.

Module Bar.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : semantics.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance Bar_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (semantics.Bar.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "a" ∷ l.[(semantics.Bar.t), "a"] ↦{dq} v.(semantics.Bar.a') ∗
      "b" ∷ l.[(semantics.Bar.t), "b"] ↦{dq} v.(semantics.Bar.b') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance Bar_into_val_typed
   :
  IntoValTyped (semantics.Bar.t) (semantics.Bar).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance Bar_access_load_a l (v : (semantics.Bar.t)) dq :
  AccessStrict
    (l.[(semantics.Bar.t), "a"] ↦{dq} (v.(semantics.Bar.a')))
    (l.[(semantics.Bar.t), "a"] ↦{dq} (v.(semantics.Bar.a')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Bar_access_store_a l (v : (semantics.Bar.t)) a' :
  AccessStrict
    (l.[(semantics.Bar.t), "a"] ↦ (v.(semantics.Bar.a')))
    (l.[(semantics.Bar.t), "a"] ↦ a')
    (l ↦ v) (l ↦ (v <|(semantics.Bar.a') := a'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Bar_access_load_b l (v : (semantics.Bar.t)) dq :
  AccessStrict
    (l.[(semantics.Bar.t), "b"] ↦{dq} (v.(semantics.Bar.b')))
    (l.[(semantics.Bar.t), "b"] ↦{dq} (v.(semantics.Bar.b')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Bar_access_store_b l (v : (semantics.Bar.t)) b' :
  AccessStrict
    (l.[(semantics.Bar.t), "b"] ↦ (v.(semantics.Bar.b')))
    (l.[(semantics.Bar.t), "b"] ↦ b')
    (l ↦ v) (l ↦ (v <|(semantics.Bar.b') := b'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End Bar.

Module Foo.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : semantics.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance Foo_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (semantics.Foo.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "bar" ∷ l.[(semantics.Foo.t), "bar"] ↦{dq} v.(semantics.Foo.bar') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance Foo_into_val_typed
   :
  IntoValTyped (semantics.Foo.t) (semantics.Foo).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance Foo_access_load_bar l (v : (semantics.Foo.t)) dq :
  AccessStrict
    (l.[(semantics.Foo.t), "bar"] ↦{dq} (v.(semantics.Foo.bar')))
    (l.[(semantics.Foo.t), "bar"] ↦{dq} (v.(semantics.Foo.bar')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Foo_access_store_bar l (v : (semantics.Foo.t)) bar' :
  AccessStrict
    (l.[(semantics.Foo.t), "bar"] ↦ (v.(semantics.Foo.bar')))
    (l.[(semantics.Foo.t), "bar"] ↦ bar')
    (l ↦ v) (l ↦ (v <|(semantics.Foo.bar') := bar'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End Foo.

Module TwoInts.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : semantics.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance TwoInts_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (semantics.TwoInts.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "x" ∷ l.[(semantics.TwoInts.t), "x"] ↦{dq} v.(semantics.TwoInts.x') ∗
      "y" ∷ l.[(semantics.TwoInts.t), "y"] ↦{dq} v.(semantics.TwoInts.y') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance TwoInts_into_val_typed
   :
  IntoValTyped (semantics.TwoInts.t) (semantics.TwoInts).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance TwoInts_access_load_x l (v : (semantics.TwoInts.t)) dq :
  AccessStrict
    (l.[(semantics.TwoInts.t), "x"] ↦{dq} (v.(semantics.TwoInts.x')))
    (l.[(semantics.TwoInts.t), "x"] ↦{dq} (v.(semantics.TwoInts.x')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance TwoInts_access_store_x l (v : (semantics.TwoInts.t)) x' :
  AccessStrict
    (l.[(semantics.TwoInts.t), "x"] ↦ (v.(semantics.TwoInts.x')))
    (l.[(semantics.TwoInts.t), "x"] ↦ x')
    (l ↦ v) (l ↦ (v <|(semantics.TwoInts.x') := x'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance TwoInts_access_load_y l (v : (semantics.TwoInts.t)) dq :
  AccessStrict
    (l.[(semantics.TwoInts.t), "y"] ↦{dq} (v.(semantics.TwoInts.y')))
    (l.[(semantics.TwoInts.t), "y"] ↦{dq} (v.(semantics.TwoInts.y')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance TwoInts_access_store_y l (v : (semantics.TwoInts.t)) y' :
  AccessStrict
    (l.[(semantics.TwoInts.t), "y"] ↦ (v.(semantics.TwoInts.y')))
    (l.[(semantics.TwoInts.t), "y"] ↦ y')
    (l ↦ v) (l ↦ (v <|(semantics.TwoInts.y') := y'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End TwoInts.

Module S.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : semantics.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance S_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (semantics.S.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "a" ∷ l.[(semantics.S.t), "a"] ↦{dq} v.(semantics.S.a') ∗
      "b" ∷ l.[(semantics.S.t), "b"] ↦{dq} v.(semantics.S.b') ∗
      "c" ∷ l.[(semantics.S.t), "c"] ↦{dq} v.(semantics.S.c') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance S_into_val_typed
   :
  IntoValTyped (semantics.S.t) (semantics.S).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance S_access_load_a l (v : (semantics.S.t)) dq :
  AccessStrict
    (l.[(semantics.S.t), "a"] ↦{dq} (v.(semantics.S.a')))
    (l.[(semantics.S.t), "a"] ↦{dq} (v.(semantics.S.a')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance S_access_store_a l (v : (semantics.S.t)) a' :
  AccessStrict
    (l.[(semantics.S.t), "a"] ↦ (v.(semantics.S.a')))
    (l.[(semantics.S.t), "a"] ↦ a')
    (l ↦ v) (l ↦ (v <|(semantics.S.a') := a'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance S_access_load_b l (v : (semantics.S.t)) dq :
  AccessStrict
    (l.[(semantics.S.t), "b"] ↦{dq} (v.(semantics.S.b')))
    (l.[(semantics.S.t), "b"] ↦{dq} (v.(semantics.S.b')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance S_access_store_b l (v : (semantics.S.t)) b' :
  AccessStrict
    (l.[(semantics.S.t), "b"] ↦ (v.(semantics.S.b')))
    (l.[(semantics.S.t), "b"] ↦ b')
    (l ↦ v) (l ↦ (v <|(semantics.S.b') := b'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance S_access_load_c l (v : (semantics.S.t)) dq :
  AccessStrict
    (l.[(semantics.S.t), "c"] ↦{dq} (v.(semantics.S.c')))
    (l.[(semantics.S.t), "c"] ↦{dq} (v.(semantics.S.c')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance S_access_store_c l (v : (semantics.S.t)) c' :
  AccessStrict
    (l.[(semantics.S.t), "c"] ↦ (v.(semantics.S.c')))
    (l.[(semantics.S.t), "c"] ↦ c')
    (l ↦ v) (l ↦ (v <|(semantics.S.c') := c'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End S.

Module StructWrap.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : semantics.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance StructWrap_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (semantics.StructWrap.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "i" ∷ l.[(semantics.StructWrap.t), "i"] ↦{dq} v.(semantics.StructWrap.i') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance StructWrap_into_val_typed
   :
  IntoValTyped (semantics.StructWrap.t) (semantics.StructWrap).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance StructWrap_access_load_i l (v : (semantics.StructWrap.t)) dq :
  AccessStrict
    (l.[(semantics.StructWrap.t), "i"] ↦{dq} (v.(semantics.StructWrap.i')))
    (l.[(semantics.StructWrap.t), "i"] ↦{dq} (v.(semantics.StructWrap.i')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance StructWrap_access_store_i l (v : (semantics.StructWrap.t)) i' :
  AccessStrict
    (l.[(semantics.StructWrap.t), "i"] ↦ (v.(semantics.StructWrap.i')))
    (l.[(semantics.StructWrap.t), "i"] ↦ i')
    (l ↦ v) (l ↦ (v <|(semantics.StructWrap.i') := i'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End StructWrap.

Module StructWithFunc.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : semantics.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance StructWithFunc_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (semantics.StructWithFunc.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "fn" ∷ l.[(semantics.StructWithFunc.t), "fn"] ↦{dq} v.(semantics.StructWithFunc.fn') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance StructWithFunc_into_val_typed
   :
  IntoValTyped (semantics.StructWithFunc.t) (semantics.StructWithFunc).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance StructWithFunc_access_load_fn l (v : (semantics.StructWithFunc.t)) dq :
  AccessStrict
    (l.[(semantics.StructWithFunc.t), "fn"] ↦{dq} (v.(semantics.StructWithFunc.fn')))
    (l.[(semantics.StructWithFunc.t), "fn"] ↦{dq} (v.(semantics.StructWithFunc.fn')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance StructWithFunc_access_store_fn l (v : (semantics.StructWithFunc.t)) fn' :
  AccessStrict
    (l.[(semantics.StructWithFunc.t), "fn"] ↦ (v.(semantics.StructWithFunc.fn')))
    (l.[(semantics.StructWithFunc.t), "fn"] ↦ fn')
    (l ↦ v) (l ↦ (v <|(semantics.StructWithFunc.fn') := fn'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End StructWithFunc.

Module switchConcrete.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : semantics.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance switchConcrete_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (semantics.switchConcrete.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance switchConcrete_into_val_typed
   :
  IntoValTyped (semantics.switchConcrete.t) (semantics.switchConcrete).
Proof. solve_into_val_typed_struct. Qed.

End def.
End switchConcrete.

Module Log.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : semantics.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance Log_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (semantics.Log.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "d" ∷ l.[(semantics.Log.t), "d"] ↦{dq} v.(semantics.Log.d') ∗
      "l" ∷ l.[(semantics.Log.t), "l"] ↦{dq} v.(semantics.Log.l') ∗
      "cache" ∷ l.[(semantics.Log.t), "cache"] ↦{dq} v.(semantics.Log.cache') ∗
      "length" ∷ l.[(semantics.Log.t), "length"] ↦{dq} v.(semantics.Log.length') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance Log_into_val_typed
   :
  IntoValTyped (semantics.Log.t) (semantics.Log).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance Log_access_load_d l (v : (semantics.Log.t)) dq :
  AccessStrict
    (l.[(semantics.Log.t), "d"] ↦{dq} (v.(semantics.Log.d')))
    (l.[(semantics.Log.t), "d"] ↦{dq} (v.(semantics.Log.d')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Log_access_store_d l (v : (semantics.Log.t)) d' :
  AccessStrict
    (l.[(semantics.Log.t), "d"] ↦ (v.(semantics.Log.d')))
    (l.[(semantics.Log.t), "d"] ↦ d')
    (l ↦ v) (l ↦ (v <|(semantics.Log.d') := d'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Log_access_load_l l (v : (semantics.Log.t)) dq :
  AccessStrict
    (l.[(semantics.Log.t), "l"] ↦{dq} (v.(semantics.Log.l')))
    (l.[(semantics.Log.t), "l"] ↦{dq} (v.(semantics.Log.l')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Log_access_store_l l (v : (semantics.Log.t)) l' :
  AccessStrict
    (l.[(semantics.Log.t), "l"] ↦ (v.(semantics.Log.l')))
    (l.[(semantics.Log.t), "l"] ↦ l')
    (l ↦ v) (l ↦ (v <|(semantics.Log.l') := l'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Log_access_load_cache l (v : (semantics.Log.t)) dq :
  AccessStrict
    (l.[(semantics.Log.t), "cache"] ↦{dq} (v.(semantics.Log.cache')))
    (l.[(semantics.Log.t), "cache"] ↦{dq} (v.(semantics.Log.cache')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Log_access_store_cache l (v : (semantics.Log.t)) cache' :
  AccessStrict
    (l.[(semantics.Log.t), "cache"] ↦ (v.(semantics.Log.cache')))
    (l.[(semantics.Log.t), "cache"] ↦ cache')
    (l ↦ v) (l ↦ (v <|(semantics.Log.cache') := cache'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Log_access_load_length l (v : (semantics.Log.t)) dq :
  AccessStrict
    (l.[(semantics.Log.t), "length"] ↦{dq} (v.(semantics.Log.length')))
    (l.[(semantics.Log.t), "length"] ↦{dq} (v.(semantics.Log.length')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Log_access_store_length l (v : (semantics.Log.t)) length' :
  AccessStrict
    (l.[(semantics.Log.t), "length"] ↦ (v.(semantics.Log.length')))
    (l.[(semantics.Log.t), "length"] ↦ length')
    (l ↦ v) (l ↦ (v <|(semantics.Log.length') := length'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End Log.

End semantics.
