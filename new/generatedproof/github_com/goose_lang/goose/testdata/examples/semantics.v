(* autogenerated by goose proofgen; do not modify *)
Require Export New.proof.disk_prelude.
Require Export New.generatedproof.github_com.goose_lang.primitive.
Require Export New.generatedproof.github_com.goose_lang.primitive.disk.
Require Export New.generatedproof.sync.
Require Export New.golang.theory.
Require Export New.code.github_com.goose_lang.goose.testdata.examples.semantics.

Set Default Proof Using "Type".

Module semantics.
Module unit.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : semantics.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance unit_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (semantics.unit.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance unit_into_val_typed
   :
  IntoValTyped (semantics.unit.t) (semantics.unit).
Proof. solve_into_val_typed_struct. Qed.

End def.
End unit.

Module Enc.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : semantics.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance Enc_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (semantics.Enc.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "p" ∷ l.[(semantics.Enc.t), "p"] ↦{dq} v.(semantics.Enc.p') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance Enc_into_val_typed
   :
  IntoValTyped (semantics.Enc.t) (semantics.Enc).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance Enc_access_p l (v : (semantics.Enc.t)) dq :
  PointsToAccess
    (l.[(semantics.Enc.t), "p"]) (v.(semantics.Enc.p')) dq
    (l ↦{dq} v) (λ p', l ↦{dq} (v <|(semantics.Enc.p') := p'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End Enc.

Module Dec.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : semantics.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance Dec_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (semantics.Dec.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "p" ∷ l.[(semantics.Dec.t), "p"] ↦{dq} v.(semantics.Dec.p') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance Dec_into_val_typed
   :
  IntoValTyped (semantics.Dec.t) (semantics.Dec).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance Dec_access_p l (v : (semantics.Dec.t)) dq :
  PointsToAccess
    (l.[(semantics.Dec.t), "p"]) (v.(semantics.Dec.p')) dq
    (l ↦{dq} v) (λ p', l ↦{dq} (v <|(semantics.Dec.p') := p'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End Dec.

Module Editor.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : semantics.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance Editor_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (semantics.Editor.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "s" ∷ l.[(semantics.Editor.t), "s"] ↦{dq} v.(semantics.Editor.s') ∗
      "next_val" ∷ l.[(semantics.Editor.t), "next_val"] ↦{dq} v.(semantics.Editor.next_val') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance Editor_into_val_typed
   :
  IntoValTyped (semantics.Editor.t) (semantics.Editor).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance Editor_access_s l (v : (semantics.Editor.t)) dq :
  PointsToAccess
    (l.[(semantics.Editor.t), "s"]) (v.(semantics.Editor.s')) dq
    (l ↦{dq} v) (λ s', l ↦{dq} (v <|(semantics.Editor.s') := s'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Editor_access_next_val l (v : (semantics.Editor.t)) dq :
  PointsToAccess
    (l.[(semantics.Editor.t), "next_val"]) (v.(semantics.Editor.next_val')) dq
    (l ↦{dq} v) (λ next_val', l ↦{dq} (v <|(semantics.Editor.next_val') := next_val'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End Editor.

Module Pair.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : semantics.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance Pair_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (semantics.Pair.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "x" ∷ l.[(semantics.Pair.t), "x"] ↦{dq} v.(semantics.Pair.x') ∗
      "y" ∷ l.[(semantics.Pair.t), "y"] ↦{dq} v.(semantics.Pair.y') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance Pair_into_val_typed
   :
  IntoValTyped (semantics.Pair.t) (semantics.Pair).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance Pair_access_x l (v : (semantics.Pair.t)) dq :
  PointsToAccess
    (l.[(semantics.Pair.t), "x"]) (v.(semantics.Pair.x')) dq
    (l ↦{dq} v) (λ x', l ↦{dq} (v <|(semantics.Pair.x') := x'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Pair_access_y l (v : (semantics.Pair.t)) dq :
  PointsToAccess
    (l.[(semantics.Pair.t), "y"]) (v.(semantics.Pair.y')) dq
    (l ↦{dq} v) (λ y', l ↦{dq} (v <|(semantics.Pair.y') := y'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End Pair.

Module SquareStruct.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : semantics.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance SquareStruct_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (semantics.SquareStruct.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "Side" ∷ l.[(semantics.SquareStruct.t), "Side"] ↦{dq} v.(semantics.SquareStruct.Side') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance SquareStruct_into_val_typed
   :
  IntoValTyped (semantics.SquareStruct.t) (semantics.SquareStruct).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance SquareStruct_access_Side l (v : (semantics.SquareStruct.t)) dq :
  PointsToAccess
    (l.[(semantics.SquareStruct.t), "Side"]) (v.(semantics.SquareStruct.Side')) dq
    (l ↦{dq} v) (λ Side', l ↦{dq} (v <|(semantics.SquareStruct.Side') := Side'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End SquareStruct.

Module LoopStruct.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : semantics.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance LoopStruct_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (semantics.LoopStruct.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "loopNext" ∷ l.[(semantics.LoopStruct.t), "loopNext"] ↦{dq} v.(semantics.LoopStruct.loopNext') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance LoopStruct_into_val_typed
   :
  IntoValTyped (semantics.LoopStruct.t) (semantics.LoopStruct).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance LoopStruct_access_loopNext l (v : (semantics.LoopStruct.t)) dq :
  PointsToAccess
    (l.[(semantics.LoopStruct.t), "loopNext"]) (v.(semantics.LoopStruct.loopNext')) dq
    (l ↦{dq} v) (λ loopNext', l ↦{dq} (v <|(semantics.LoopStruct.loopNext') := loopNext'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End LoopStruct.

Module BoolTest.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : semantics.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance BoolTest_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (semantics.BoolTest.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "t" ∷ l.[(semantics.BoolTest.t), "t"] ↦{dq} v.(semantics.BoolTest.t') ∗
      "f" ∷ l.[(semantics.BoolTest.t), "f"] ↦{dq} v.(semantics.BoolTest.f') ∗
      "tc" ∷ l.[(semantics.BoolTest.t), "tc"] ↦{dq} v.(semantics.BoolTest.tc') ∗
      "fc" ∷ l.[(semantics.BoolTest.t), "fc"] ↦{dq} v.(semantics.BoolTest.fc') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance BoolTest_into_val_typed
   :
  IntoValTyped (semantics.BoolTest.t) (semantics.BoolTest).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance BoolTest_access_t l (v : (semantics.BoolTest.t)) dq :
  PointsToAccess
    (l.[(semantics.BoolTest.t), "t"]) (v.(semantics.BoolTest.t')) dq
    (l ↦{dq} v) (λ t', l ↦{dq} (v <|(semantics.BoolTest.t') := t'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance BoolTest_access_f l (v : (semantics.BoolTest.t)) dq :
  PointsToAccess
    (l.[(semantics.BoolTest.t), "f"]) (v.(semantics.BoolTest.f')) dq
    (l ↦{dq} v) (λ f', l ↦{dq} (v <|(semantics.BoolTest.f') := f'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance BoolTest_access_tc l (v : (semantics.BoolTest.t)) dq :
  PointsToAccess
    (l.[(semantics.BoolTest.t), "tc"]) (v.(semantics.BoolTest.tc')) dq
    (l ↦{dq} v) (λ tc', l ↦{dq} (v <|(semantics.BoolTest.tc') := tc'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance BoolTest_access_fc l (v : (semantics.BoolTest.t)) dq :
  PointsToAccess
    (l.[(semantics.BoolTest.t), "fc"]) (v.(semantics.BoolTest.fc')) dq
    (l ↦{dq} v) (λ fc', l ↦{dq} (v <|(semantics.BoolTest.fc') := fc'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End BoolTest.

Module ArrayEditor.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : semantics.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance ArrayEditor_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (semantics.ArrayEditor.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "s" ∷ l.[(semantics.ArrayEditor.t), "s"] ↦{dq} v.(semantics.ArrayEditor.s') ∗
      "next_val" ∷ l.[(semantics.ArrayEditor.t), "next_val"] ↦{dq} v.(semantics.ArrayEditor.next_val') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance ArrayEditor_into_val_typed
   :
  IntoValTyped (semantics.ArrayEditor.t) (semantics.ArrayEditor).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance ArrayEditor_access_s l (v : (semantics.ArrayEditor.t)) dq :
  PointsToAccess
    (l.[(semantics.ArrayEditor.t), "s"]) (v.(semantics.ArrayEditor.s')) dq
    (l ↦{dq} v) (λ s', l ↦{dq} (v <|(semantics.ArrayEditor.s') := s'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance ArrayEditor_access_next_val l (v : (semantics.ArrayEditor.t)) dq :
  PointsToAccess
    (l.[(semantics.ArrayEditor.t), "next_val"]) (v.(semantics.ArrayEditor.next_val')) dq
    (l ↦{dq} v) (λ next_val', l ↦{dq} (v <|(semantics.ArrayEditor.next_val') := next_val'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End ArrayEditor.

Module Bar.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : semantics.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance Bar_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (semantics.Bar.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "a" ∷ l.[(semantics.Bar.t), "a"] ↦{dq} v.(semantics.Bar.a') ∗
      "b" ∷ l.[(semantics.Bar.t), "b"] ↦{dq} v.(semantics.Bar.b') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance Bar_into_val_typed
   :
  IntoValTyped (semantics.Bar.t) (semantics.Bar).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance Bar_access_a l (v : (semantics.Bar.t)) dq :
  PointsToAccess
    (l.[(semantics.Bar.t), "a"]) (v.(semantics.Bar.a')) dq
    (l ↦{dq} v) (λ a', l ↦{dq} (v <|(semantics.Bar.a') := a'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Bar_access_b l (v : (semantics.Bar.t)) dq :
  PointsToAccess
    (l.[(semantics.Bar.t), "b"]) (v.(semantics.Bar.b')) dq
    (l ↦{dq} v) (λ b', l ↦{dq} (v <|(semantics.Bar.b') := b'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End Bar.

Module Foo.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : semantics.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance Foo_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (semantics.Foo.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "bar" ∷ l.[(semantics.Foo.t), "bar"] ↦{dq} v.(semantics.Foo.bar') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance Foo_into_val_typed
   :
  IntoValTyped (semantics.Foo.t) (semantics.Foo).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance Foo_access_bar l (v : (semantics.Foo.t)) dq :
  PointsToAccess
    (l.[(semantics.Foo.t), "bar"]) (v.(semantics.Foo.bar')) dq
    (l ↦{dq} v) (λ bar', l ↦{dq} (v <|(semantics.Foo.bar') := bar'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End Foo.

Module TwoInts.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : semantics.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance TwoInts_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (semantics.TwoInts.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "x" ∷ l.[(semantics.TwoInts.t), "x"] ↦{dq} v.(semantics.TwoInts.x') ∗
      "y" ∷ l.[(semantics.TwoInts.t), "y"] ↦{dq} v.(semantics.TwoInts.y') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance TwoInts_into_val_typed
   :
  IntoValTyped (semantics.TwoInts.t) (semantics.TwoInts).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance TwoInts_access_x l (v : (semantics.TwoInts.t)) dq :
  PointsToAccess
    (l.[(semantics.TwoInts.t), "x"]) (v.(semantics.TwoInts.x')) dq
    (l ↦{dq} v) (λ x', l ↦{dq} (v <|(semantics.TwoInts.x') := x'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance TwoInts_access_y l (v : (semantics.TwoInts.t)) dq :
  PointsToAccess
    (l.[(semantics.TwoInts.t), "y"]) (v.(semantics.TwoInts.y')) dq
    (l ↦{dq} v) (λ y', l ↦{dq} (v <|(semantics.TwoInts.y') := y'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End TwoInts.

Module S.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : semantics.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance S_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (semantics.S.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "a" ∷ l.[(semantics.S.t), "a"] ↦{dq} v.(semantics.S.a') ∗
      "b" ∷ l.[(semantics.S.t), "b"] ↦{dq} v.(semantics.S.b') ∗
      "c" ∷ l.[(semantics.S.t), "c"] ↦{dq} v.(semantics.S.c') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance S_into_val_typed
   :
  IntoValTyped (semantics.S.t) (semantics.S).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance S_access_a l (v : (semantics.S.t)) dq :
  PointsToAccess
    (l.[(semantics.S.t), "a"]) (v.(semantics.S.a')) dq
    (l ↦{dq} v) (λ a', l ↦{dq} (v <|(semantics.S.a') := a'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance S_access_b l (v : (semantics.S.t)) dq :
  PointsToAccess
    (l.[(semantics.S.t), "b"]) (v.(semantics.S.b')) dq
    (l ↦{dq} v) (λ b', l ↦{dq} (v <|(semantics.S.b') := b'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance S_access_c l (v : (semantics.S.t)) dq :
  PointsToAccess
    (l.[(semantics.S.t), "c"]) (v.(semantics.S.c')) dq
    (l ↦{dq} v) (λ c', l ↦{dq} (v <|(semantics.S.c') := c'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End S.

Module StructWrap.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : semantics.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance StructWrap_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (semantics.StructWrap.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "i" ∷ l.[(semantics.StructWrap.t), "i"] ↦{dq} v.(semantics.StructWrap.i') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance StructWrap_into_val_typed
   :
  IntoValTyped (semantics.StructWrap.t) (semantics.StructWrap).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance StructWrap_access_i l (v : (semantics.StructWrap.t)) dq :
  PointsToAccess
    (l.[(semantics.StructWrap.t), "i"]) (v.(semantics.StructWrap.i')) dq
    (l ↦{dq} v) (λ i', l ↦{dq} (v <|(semantics.StructWrap.i') := i'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End StructWrap.

Module StructWithFunc.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : semantics.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance StructWithFunc_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (semantics.StructWithFunc.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "fn" ∷ l.[(semantics.StructWithFunc.t), "fn"] ↦{dq} v.(semantics.StructWithFunc.fn') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance StructWithFunc_into_val_typed
   :
  IntoValTyped (semantics.StructWithFunc.t) (semantics.StructWithFunc).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance StructWithFunc_access_fn l (v : (semantics.StructWithFunc.t)) dq :
  PointsToAccess
    (l.[(semantics.StructWithFunc.t), "fn"]) (v.(semantics.StructWithFunc.fn')) dq
    (l ↦{dq} v) (λ fn', l ↦{dq} (v <|(semantics.StructWithFunc.fn') := fn'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End StructWithFunc.

Module switchConcrete.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : semantics.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance switchConcrete_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (semantics.switchConcrete.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance switchConcrete_into_val_typed
   :
  IntoValTyped (semantics.switchConcrete.t) (semantics.switchConcrete).
Proof. solve_into_val_typed_struct. Qed.

End def.
End switchConcrete.

Module Log.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : semantics.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance Log_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (semantics.Log.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "d" ∷ l.[(semantics.Log.t), "d"] ↦{dq} v.(semantics.Log.d') ∗
      "l" ∷ l.[(semantics.Log.t), "l"] ↦{dq} v.(semantics.Log.l') ∗
      "cache" ∷ l.[(semantics.Log.t), "cache"] ↦{dq} v.(semantics.Log.cache') ∗
      "length" ∷ l.[(semantics.Log.t), "length"] ↦{dq} v.(semantics.Log.length') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance Log_into_val_typed
   :
  IntoValTyped (semantics.Log.t) (semantics.Log).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance Log_access_d l (v : (semantics.Log.t)) dq :
  PointsToAccess
    (l.[(semantics.Log.t), "d"]) (v.(semantics.Log.d')) dq
    (l ↦{dq} v) (λ d', l ↦{dq} (v <|(semantics.Log.d') := d'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Log_access_l l (v : (semantics.Log.t)) dq :
  PointsToAccess
    (l.[(semantics.Log.t), "l"]) (v.(semantics.Log.l')) dq
    (l ↦{dq} v) (λ l', l ↦{dq} (v <|(semantics.Log.l') := l'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Log_access_cache l (v : (semantics.Log.t)) dq :
  PointsToAccess
    (l.[(semantics.Log.t), "cache"]) (v.(semantics.Log.cache')) dq
    (l ↦{dq} v) (λ cache', l ↦{dq} (v <|(semantics.Log.cache') := cache'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Log_access_length l (v : (semantics.Log.t)) dq :
  PointsToAccess
    (l.[(semantics.Log.t), "length"]) (v.(semantics.Log.length')) dq
    (l ↦{dq} v) (λ length', l ↦{dq} (v <|(semantics.Log.length') := length'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End Log.

End semantics.
