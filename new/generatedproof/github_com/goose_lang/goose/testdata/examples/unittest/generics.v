(* autogenerated by goose proofgen; do not modify *)
Require Export New.proof.proof_prelude.
Require Export New.generatedproof.github_com.goose_lang.goose.testdata.examples.unittest.generics.helpers.
Require Export New.golang.theory.
Require Export New.code.github_com.goose_lang.goose.testdata.examples.unittest.generics.

Set Default Proof Using "Type".

Module generics.
Module Box.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : generics.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance Box_typed_pointsto `{!TypedPointsto (Σ:=Σ) T'}  :
  TypedPointsto (Σ:=Σ) (generics.Box.t T') :=
  {|
    typed_pointsto_def l v dq :=
      (
      "Value" ∷ l.[(generics.Box.t T'), "Value"] ↦{dq} v.(generics.Box.Value') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance Box_into_val_typed
  `{!ZeroVal T'} `{!TypedPointsto (Σ:=Σ) T'} `{!IntoValTyped T' T} `{!go.TypeRepr T T'}  :
  IntoValTyped (generics.Box.t T') (generics.Box T).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance Box_access_Value`{!TypedPointsto (Σ:=Σ) T'}  l (v : (generics.Box.t T')) dq :
  PointsToAccess
    (l.[(generics.Box.t T'), "Value"]) (v.(generics.Box.Value')) dq
    (l ↦{dq} v) (λ Value', l ↦{dq} (v <|(generics.Box.Value') := Value'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End Box.

Module Container.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : generics.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance Container_typed_pointsto `{!TypedPointsto (Σ:=Σ) T'}  :
  TypedPointsto (Σ:=Σ) (generics.Container.t T') :=
  {|
    typed_pointsto_def l v dq :=
      (
      "X" ∷ l.[(generics.Container.t T'), "X"] ↦{dq} v.(generics.Container.X') ∗
      "Y" ∷ l.[(generics.Container.t T'), "Y"] ↦{dq} v.(generics.Container.Y') ∗
      "Z" ∷ l.[(generics.Container.t T'), "Z"] ↦{dq} v.(generics.Container.Z') ∗
      "W" ∷ l.[(generics.Container.t T'), "W"] ↦{dq} v.(generics.Container.W') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance Container_into_val_typed
  `{!ZeroVal T'} `{!TypedPointsto (Σ:=Σ) T'} `{!IntoValTyped T' T} `{!go.TypeRepr T T'}  :
  IntoValTyped (generics.Container.t T') (generics.Container T).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance Container_access_X`{!TypedPointsto (Σ:=Σ) T'}  l (v : (generics.Container.t T')) dq :
  PointsToAccess
    (l.[(generics.Container.t T'), "X"]) (v.(generics.Container.X')) dq
    (l ↦{dq} v) (λ X', l ↦{dq} (v <|(generics.Container.X') := X'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Container_access_Y`{!TypedPointsto (Σ:=Σ) T'}  l (v : (generics.Container.t T')) dq :
  PointsToAccess
    (l.[(generics.Container.t T'), "Y"]) (v.(generics.Container.Y')) dq
    (l ↦{dq} v) (λ Y', l ↦{dq} (v <|(generics.Container.Y') := Y'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Container_access_Z`{!TypedPointsto (Σ:=Σ) T'}  l (v : (generics.Container.t T')) dq :
  PointsToAccess
    (l.[(generics.Container.t T'), "Z"]) (v.(generics.Container.Z')) dq
    (l ↦{dq} v) (λ Z', l ↦{dq} (v <|(generics.Container.Z') := Z'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Container_access_W`{!TypedPointsto (Σ:=Σ) T'}  l (v : (generics.Container.t T')) dq :
  PointsToAccess
    (l.[(generics.Container.t T'), "W"]) (v.(generics.Container.W')) dq
    (l ↦{dq} v) (λ W', l ↦{dq} (v <|(generics.Container.W') := W'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End Container.

Module UseContainer.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : generics.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance UseContainer_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (generics.UseContainer.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "X" ∷ l.[(generics.UseContainer.t), "X"] ↦{dq} v.(generics.UseContainer.X') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance UseContainer_into_val_typed
   :
  IntoValTyped (generics.UseContainer.t) (generics.UseContainer).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance UseContainer_access_X l (v : (generics.UseContainer.t)) dq :
  PointsToAccess
    (l.[(generics.UseContainer.t), "X"]) (v.(generics.UseContainer.X')) dq
    (l ↦{dq} v) (λ X', l ↦{dq} (v <|(generics.UseContainer.X') := X'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End UseContainer.

Module OnlyIndirect.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : generics.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance OnlyIndirect_typed_pointsto `{!TypedPointsto (Σ:=Σ) T'}  :
  TypedPointsto (Σ:=Σ) (generics.OnlyIndirect.t T') :=
  {|
    typed_pointsto_def l v dq :=
      (
      "X" ∷ l.[(generics.OnlyIndirect.t T'), "X"] ↦{dq} v.(generics.OnlyIndirect.X') ∗
      "Y" ∷ l.[(generics.OnlyIndirect.t T'), "Y"] ↦{dq} v.(generics.OnlyIndirect.Y') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance OnlyIndirect_into_val_typed
  `{!ZeroVal T'} `{!TypedPointsto (Σ:=Σ) T'} `{!IntoValTyped T' T} `{!go.TypeRepr T T'}  :
  IntoValTyped (generics.OnlyIndirect.t T') (generics.OnlyIndirect T).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance OnlyIndirect_access_X`{!TypedPointsto (Σ:=Σ) T'}  l (v : (generics.OnlyIndirect.t T')) dq :
  PointsToAccess
    (l.[(generics.OnlyIndirect.t T'), "X"]) (v.(generics.OnlyIndirect.X')) dq
    (l ↦{dq} v) (λ X', l ↦{dq} (v <|(generics.OnlyIndirect.X') := X'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance OnlyIndirect_access_Y`{!TypedPointsto (Σ:=Σ) T'}  l (v : (generics.OnlyIndirect.t T')) dq :
  PointsToAccess
    (l.[(generics.OnlyIndirect.t T'), "Y"]) (v.(generics.OnlyIndirect.Y')) dq
    (l ↦{dq} v) (λ Y', l ↦{dq} (v <|(generics.OnlyIndirect.Y') := Y'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End OnlyIndirect.

Module MultiParam.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : generics.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance MultiParam_typed_pointsto `{!TypedPointsto (Σ:=Σ) A'} `{!TypedPointsto (Σ:=Σ) B'}  :
  TypedPointsto (Σ:=Σ) (generics.MultiParam.t A' B') :=
  {|
    typed_pointsto_def l v dq :=
      (
      "Y" ∷ l.[(generics.MultiParam.t A' B'), "Y"] ↦{dq} v.(generics.MultiParam.Y') ∗
      "X" ∷ l.[(generics.MultiParam.t A' B'), "X"] ↦{dq} v.(generics.MultiParam.X') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance MultiParam_into_val_typed
  `{!ZeroVal A'} `{!TypedPointsto (Σ:=Σ) A'} `{!IntoValTyped A' A} `{!go.TypeRepr A A'} `{!ZeroVal B'} `{!TypedPointsto (Σ:=Σ) B'} `{!IntoValTyped B' B} `{!go.TypeRepr B B'}  :
  IntoValTyped (generics.MultiParam.t A' B') (generics.MultiParam A B).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance MultiParam_access_Y`{!TypedPointsto (Σ:=Σ) A'} `{!TypedPointsto (Σ:=Σ) B'}  l (v : (generics.MultiParam.t A' B')) dq :
  PointsToAccess
    (l.[(generics.MultiParam.t A' B'), "Y"]) (v.(generics.MultiParam.Y')) dq
    (l ↦{dq} v) (λ Y', l ↦{dq} (v <|(generics.MultiParam.Y') := Y'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance MultiParam_access_X`{!TypedPointsto (Σ:=Σ) A'} `{!TypedPointsto (Σ:=Σ) B'}  l (v : (generics.MultiParam.t A' B')) dq :
  PointsToAccess
    (l.[(generics.MultiParam.t A' B'), "X"]) (v.(generics.MultiParam.X')) dq
    (l ↦{dq} v) (λ X', l ↦{dq} (v <|(generics.MultiParam.X') := X'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End MultiParam.

End generics.
