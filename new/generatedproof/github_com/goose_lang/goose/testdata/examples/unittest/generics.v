(* autogenerated by goose proofgen; do not modify *)
Require Export New.proof.proof_prelude.
Require Export New.generatedproof.github_com.goose_lang.goose.testdata.examples.unittest.generics.helpers.
Require Export New.golang.theory.
Require Export New.code.github_com.goose_lang.goose.testdata.examples.unittest.generics.

Set Default Proof Using "Type".

Module generics.
Module Box.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : generics.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance Box_typed_pointsto `{!TypedPointsto (Σ:=Σ) T'}  :
  TypedPointsto (Σ:=Σ) (generics.Box.t T') :=
  {|
    typed_pointsto_def l v dq :=
      (
      "Value" ∷ l.[(generics.Box.t T'), "Value"] ↦{dq} v.(generics.Box.Value') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance Box_into_val_typed
  `{!ZeroVal T'} `{!TypedPointsto (Σ:=Σ) T'} `{!IntoValTyped T' T} `{!go.TypeRepr T T'}  :
  IntoValTypedUnderlying (generics.Box.t T') (generics.Boxⁱᵐᵖˡ T).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance Box_access_load_Value `{!TypedPointsto (Σ:=Σ) T'} l (v : (generics.Box.t T')) dq :
  AccessStrict
    (l.[(generics.Box.t T'), "Value"] ↦{dq} (v.(generics.Box.Value')))
    (l.[(generics.Box.t T'), "Value"] ↦{dq} (v.(generics.Box.Value')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Box_access_store_Value `{!TypedPointsto (Σ:=Σ) T'} l (v : (generics.Box.t T')) Value' :
  AccessStrict
    (l.[(generics.Box.t T'), "Value"] ↦ (v.(generics.Box.Value')))
    (l.[(generics.Box.t T'), "Value"] ↦ Value')
    (l ↦ v) (l ↦ (v <|(generics.Box.Value') := Value'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End Box.

Module Container.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : generics.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance Container_typed_pointsto `{!TypedPointsto (Σ:=Σ) T'}  :
  TypedPointsto (Σ:=Σ) (generics.Container.t T') :=
  {|
    typed_pointsto_def l v dq :=
      (
      "X" ∷ l.[(generics.Container.t T'), "X"] ↦{dq} v.(generics.Container.X') ∗
      "Y" ∷ l.[(generics.Container.t T'), "Y"] ↦{dq} v.(generics.Container.Y') ∗
      "Z" ∷ l.[(generics.Container.t T'), "Z"] ↦{dq} v.(generics.Container.Z') ∗
      "W" ∷ l.[(generics.Container.t T'), "W"] ↦{dq} v.(generics.Container.W') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance Container_into_val_typed
  `{!ZeroVal T'} `{!TypedPointsto (Σ:=Σ) T'} `{!IntoValTyped T' T} `{!go.TypeRepr T T'}  :
  IntoValTypedUnderlying (generics.Container.t T') (generics.Containerⁱᵐᵖˡ T).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance Container_access_load_X `{!TypedPointsto (Σ:=Σ) T'} l (v : (generics.Container.t T')) dq :
  AccessStrict
    (l.[(generics.Container.t T'), "X"] ↦{dq} (v.(generics.Container.X')))
    (l.[(generics.Container.t T'), "X"] ↦{dq} (v.(generics.Container.X')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Container_access_store_X `{!TypedPointsto (Σ:=Σ) T'} l (v : (generics.Container.t T')) X' :
  AccessStrict
    (l.[(generics.Container.t T'), "X"] ↦ (v.(generics.Container.X')))
    (l.[(generics.Container.t T'), "X"] ↦ X')
    (l ↦ v) (l ↦ (v <|(generics.Container.X') := X'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Container_access_load_Y `{!TypedPointsto (Σ:=Σ) T'} l (v : (generics.Container.t T')) dq :
  AccessStrict
    (l.[(generics.Container.t T'), "Y"] ↦{dq} (v.(generics.Container.Y')))
    (l.[(generics.Container.t T'), "Y"] ↦{dq} (v.(generics.Container.Y')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Container_access_store_Y `{!TypedPointsto (Σ:=Σ) T'} l (v : (generics.Container.t T')) Y' :
  AccessStrict
    (l.[(generics.Container.t T'), "Y"] ↦ (v.(generics.Container.Y')))
    (l.[(generics.Container.t T'), "Y"] ↦ Y')
    (l ↦ v) (l ↦ (v <|(generics.Container.Y') := Y'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Container_access_load_Z `{!TypedPointsto (Σ:=Σ) T'} l (v : (generics.Container.t T')) dq :
  AccessStrict
    (l.[(generics.Container.t T'), "Z"] ↦{dq} (v.(generics.Container.Z')))
    (l.[(generics.Container.t T'), "Z"] ↦{dq} (v.(generics.Container.Z')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Container_access_store_Z `{!TypedPointsto (Σ:=Σ) T'} l (v : (generics.Container.t T')) Z' :
  AccessStrict
    (l.[(generics.Container.t T'), "Z"] ↦ (v.(generics.Container.Z')))
    (l.[(generics.Container.t T'), "Z"] ↦ Z')
    (l ↦ v) (l ↦ (v <|(generics.Container.Z') := Z'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Container_access_load_W `{!TypedPointsto (Σ:=Σ) T'} l (v : (generics.Container.t T')) dq :
  AccessStrict
    (l.[(generics.Container.t T'), "W"] ↦{dq} (v.(generics.Container.W')))
    (l.[(generics.Container.t T'), "W"] ↦{dq} (v.(generics.Container.W')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Container_access_store_W `{!TypedPointsto (Σ:=Σ) T'} l (v : (generics.Container.t T')) W' :
  AccessStrict
    (l.[(generics.Container.t T'), "W"] ↦ (v.(generics.Container.W')))
    (l.[(generics.Container.t T'), "W"] ↦ W')
    (l ↦ v) (l ↦ (v <|(generics.Container.W') := W'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End Container.

Module UseContainer.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : generics.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance UseContainer_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (generics.UseContainer.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "X" ∷ l.[(generics.UseContainer.t), "X"] ↦{dq} v.(generics.UseContainer.X') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance UseContainer_into_val_typed
   :
  IntoValTypedUnderlying (generics.UseContainer.t) (generics.UseContainerⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance UseContainer_access_load_X l (v : (generics.UseContainer.t)) dq :
  AccessStrict
    (l.[(generics.UseContainer.t), "X"] ↦{dq} (v.(generics.UseContainer.X')))
    (l.[(generics.UseContainer.t), "X"] ↦{dq} (v.(generics.UseContainer.X')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance UseContainer_access_store_X l (v : (generics.UseContainer.t)) X' :
  AccessStrict
    (l.[(generics.UseContainer.t), "X"] ↦ (v.(generics.UseContainer.X')))
    (l.[(generics.UseContainer.t), "X"] ↦ X')
    (l ↦ v) (l ↦ (v <|(generics.UseContainer.X') := X'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End UseContainer.

Module OnlyIndirect.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : generics.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance OnlyIndirect_typed_pointsto `{!TypedPointsto (Σ:=Σ) T'}  :
  TypedPointsto (Σ:=Σ) (generics.OnlyIndirect.t T') :=
  {|
    typed_pointsto_def l v dq :=
      (
      "X" ∷ l.[(generics.OnlyIndirect.t T'), "X"] ↦{dq} v.(generics.OnlyIndirect.X') ∗
      "Y" ∷ l.[(generics.OnlyIndirect.t T'), "Y"] ↦{dq} v.(generics.OnlyIndirect.Y') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance OnlyIndirect_into_val_typed
  `{!ZeroVal T'} `{!TypedPointsto (Σ:=Σ) T'} `{!IntoValTyped T' T} `{!go.TypeRepr T T'}  :
  IntoValTypedUnderlying (generics.OnlyIndirect.t T') (generics.OnlyIndirectⁱᵐᵖˡ T).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance OnlyIndirect_access_load_X `{!TypedPointsto (Σ:=Σ) T'} l (v : (generics.OnlyIndirect.t T')) dq :
  AccessStrict
    (l.[(generics.OnlyIndirect.t T'), "X"] ↦{dq} (v.(generics.OnlyIndirect.X')))
    (l.[(generics.OnlyIndirect.t T'), "X"] ↦{dq} (v.(generics.OnlyIndirect.X')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance OnlyIndirect_access_store_X `{!TypedPointsto (Σ:=Σ) T'} l (v : (generics.OnlyIndirect.t T')) X' :
  AccessStrict
    (l.[(generics.OnlyIndirect.t T'), "X"] ↦ (v.(generics.OnlyIndirect.X')))
    (l.[(generics.OnlyIndirect.t T'), "X"] ↦ X')
    (l ↦ v) (l ↦ (v <|(generics.OnlyIndirect.X') := X'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance OnlyIndirect_access_load_Y `{!TypedPointsto (Σ:=Σ) T'} l (v : (generics.OnlyIndirect.t T')) dq :
  AccessStrict
    (l.[(generics.OnlyIndirect.t T'), "Y"] ↦{dq} (v.(generics.OnlyIndirect.Y')))
    (l.[(generics.OnlyIndirect.t T'), "Y"] ↦{dq} (v.(generics.OnlyIndirect.Y')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance OnlyIndirect_access_store_Y `{!TypedPointsto (Σ:=Σ) T'} l (v : (generics.OnlyIndirect.t T')) Y' :
  AccessStrict
    (l.[(generics.OnlyIndirect.t T'), "Y"] ↦ (v.(generics.OnlyIndirect.Y')))
    (l.[(generics.OnlyIndirect.t T'), "Y"] ↦ Y')
    (l ↦ v) (l ↦ (v <|(generics.OnlyIndirect.Y') := Y'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End OnlyIndirect.

Module MultiParam.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : generics.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance MultiParam_typed_pointsto `{!TypedPointsto (Σ:=Σ) A'} `{!TypedPointsto (Σ:=Σ) B'}  :
  TypedPointsto (Σ:=Σ) (generics.MultiParam.t A' B') :=
  {|
    typed_pointsto_def l v dq :=
      (
      "Y" ∷ l.[(generics.MultiParam.t A' B'), "Y"] ↦{dq} v.(generics.MultiParam.Y') ∗
      "X" ∷ l.[(generics.MultiParam.t A' B'), "X"] ↦{dq} v.(generics.MultiParam.X') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance MultiParam_into_val_typed
  `{!ZeroVal A'} `{!TypedPointsto (Σ:=Σ) A'} `{!IntoValTyped A' A} `{!go.TypeRepr A A'} `{!ZeroVal B'} `{!TypedPointsto (Σ:=Σ) B'} `{!IntoValTyped B' B} `{!go.TypeRepr B B'}  :
  IntoValTypedUnderlying (generics.MultiParam.t A' B') (generics.MultiParamⁱᵐᵖˡ A B).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance MultiParam_access_load_Y `{!TypedPointsto (Σ:=Σ) A'} `{!TypedPointsto (Σ:=Σ) B'} l (v : (generics.MultiParam.t A' B')) dq :
  AccessStrict
    (l.[(generics.MultiParam.t A' B'), "Y"] ↦{dq} (v.(generics.MultiParam.Y')))
    (l.[(generics.MultiParam.t A' B'), "Y"] ↦{dq} (v.(generics.MultiParam.Y')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance MultiParam_access_store_Y `{!TypedPointsto (Σ:=Σ) A'} `{!TypedPointsto (Σ:=Σ) B'} l (v : (generics.MultiParam.t A' B')) Y' :
  AccessStrict
    (l.[(generics.MultiParam.t A' B'), "Y"] ↦ (v.(generics.MultiParam.Y')))
    (l.[(generics.MultiParam.t A' B'), "Y"] ↦ Y')
    (l ↦ v) (l ↦ (v <|(generics.MultiParam.Y') := Y'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance MultiParam_access_load_X `{!TypedPointsto (Σ:=Σ) A'} `{!TypedPointsto (Σ:=Σ) B'} l (v : (generics.MultiParam.t A' B')) dq :
  AccessStrict
    (l.[(generics.MultiParam.t A' B'), "X"] ↦{dq} (v.(generics.MultiParam.X')))
    (l.[(generics.MultiParam.t A' B'), "X"] ↦{dq} (v.(generics.MultiParam.X')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance MultiParam_access_store_X `{!TypedPointsto (Σ:=Σ) A'} `{!TypedPointsto (Σ:=Σ) B'} l (v : (generics.MultiParam.t A' B')) X' :
  AccessStrict
    (l.[(generics.MultiParam.t A' B'), "X"] ↦ (v.(generics.MultiParam.X')))
    (l.[(generics.MultiParam.t A' B'), "X"] ↦ X')
    (l ↦ v) (l ↦ (v <|(generics.MultiParam.X') := X'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End MultiParam.

End generics.
