(* autogenerated by goose proofgen; do not modify *)
Require Export New.proof.disk_prelude.
Require Export New.generatedproof.fmt.
Require Export New.generatedproof.github_com.goose_lang.primitive.
Require Export New.generatedproof.github_com.goose_lang.primitive.disk.
Require Export New.generatedproof.github_com.goose_lang.std.
Require Export New.generatedproof.log.
Require Export New.generatedproof.sync.
Require Export New.golang.theory.
Require Export New.code.github_com.goose_lang.goose.testdata.examples.unittest.

Set Default Proof Using "Type".

Module unittest.
Module importantStruct.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : unittest.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance importantStruct_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (unittest.importantStruct.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance importantStruct_into_val_typed
   :
  IntoValTyped (unittest.importantStruct.t) (unittest.importantStruct).
Proof. solve_into_val_typed_struct. Qed.

End def.
End importantStruct.

Module diskWrapper.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : unittest.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance diskWrapper_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (unittest.diskWrapper.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "d" ∷ l.[(unittest.diskWrapper.t), "d"] ↦{dq} v.(unittest.diskWrapper.d') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance diskWrapper_into_val_typed
   :
  IntoValTyped (unittest.diskWrapper.t) (unittest.diskWrapper).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance diskWrapper_access_d l (v : (unittest.diskWrapper.t)) dq :
  PointsToAccess
    (l.[(unittest.diskWrapper.t), "d"]) (v.(unittest.diskWrapper.d')) dq
    (l ↦{dq} v) (λ d', l ↦{dq} (v <|(unittest.diskWrapper.d') := d'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End diskWrapper.

Module embedA.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : unittest.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance embedA_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (unittest.embedA.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "a" ∷ l.[(unittest.embedA.t), "a"] ↦{dq} v.(unittest.embedA.a') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance embedA_into_val_typed
   :
  IntoValTyped (unittest.embedA.t) (unittest.embedA).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance embedA_access_a l (v : (unittest.embedA.t)) dq :
  PointsToAccess
    (l.[(unittest.embedA.t), "a"]) (v.(unittest.embedA.a')) dq
    (l ↦{dq} v) (λ a', l ↦{dq} (v <|(unittest.embedA.a') := a'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End embedA.

Module embedB.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : unittest.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance embedB_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (unittest.embedB.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "embedA" ∷ l.[(unittest.embedB.t), "embedA"] ↦{dq} v.(unittest.embedB.embedA') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance embedB_into_val_typed
   :
  IntoValTyped (unittest.embedB.t) (unittest.embedB).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance embedB_access_embedA l (v : (unittest.embedB.t)) dq :
  PointsToAccess
    (l.[(unittest.embedB.t), "embedA"]) (v.(unittest.embedB.embedA')) dq
    (l ↦{dq} v) (λ embedA', l ↦{dq} (v <|(unittest.embedB.embedA') := embedA'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End embedB.

Module embedC.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : unittest.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance embedC_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (unittest.embedC.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "embedB" ∷ l.[(unittest.embedC.t), "embedB"] ↦{dq} v.(unittest.embedC.embedB') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance embedC_into_val_typed
   :
  IntoValTyped (unittest.embedC.t) (unittest.embedC).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance embedC_access_embedB l (v : (unittest.embedC.t)) dq :
  PointsToAccess
    (l.[(unittest.embedC.t), "embedB"]) (v.(unittest.embedC.embedB')) dq
    (l ↦{dq} v) (λ embedB', l ↦{dq} (v <|(unittest.embedC.embedB') := embedB'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End embedC.

Module embedD.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : unittest.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance embedD_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (unittest.embedD.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "embedC" ∷ l.[(unittest.embedD.t), "embedC"] ↦{dq} v.(unittest.embedD.embedC') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance embedD_into_val_typed
   :
  IntoValTyped (unittest.embedD.t) (unittest.embedD).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance embedD_access_embedC l (v : (unittest.embedD.t)) dq :
  PointsToAccess
    (l.[(unittest.embedD.t), "embedC"]) (v.(unittest.embedD.embedC')) dq
    (l ↦{dq} v) (λ embedC', l ↦{dq} (v <|(unittest.embedD.embedC') := embedC'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End embedD.

Module Enc.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : unittest.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance Enc_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (unittest.Enc.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "p" ∷ l.[(unittest.Enc.t), "p"] ↦{dq} v.(unittest.Enc.p') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance Enc_into_val_typed
   :
  IntoValTyped (unittest.Enc.t) (unittest.Enc).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance Enc_access_p l (v : (unittest.Enc.t)) dq :
  PointsToAccess
    (l.[(unittest.Enc.t), "p"]) (v.(unittest.Enc.p')) dq
    (l ↦{dq} v) (λ p', l ↦{dq} (v <|(unittest.Enc.p') := p'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End Enc.

Module Dec.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : unittest.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance Dec_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (unittest.Dec.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "p" ∷ l.[(unittest.Dec.t), "p"] ↦{dq} v.(unittest.Dec.p') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance Dec_into_val_typed
   :
  IntoValTyped (unittest.Dec.t) (unittest.Dec).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance Dec_access_p l (v : (unittest.Dec.t)) dq :
  PointsToAccess
    (l.[(unittest.Dec.t), "p"]) (v.(unittest.Dec.p')) dq
    (l ↦{dq} v) (λ p', l ↦{dq} (v <|(unittest.Dec.p') := p'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End Dec.

Module concreteFooer.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : unittest.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance concreteFooer_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (unittest.concreteFooer.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "a" ∷ l.[(unittest.concreteFooer.t), "a"] ↦{dq} v.(unittest.concreteFooer.a') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance concreteFooer_into_val_typed
   :
  IntoValTyped (unittest.concreteFooer.t) (unittest.concreteFooer).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance concreteFooer_access_a l (v : (unittest.concreteFooer.t)) dq :
  PointsToAccess
    (l.[(unittest.concreteFooer.t), "a"]) (v.(unittest.concreteFooer.a')) dq
    (l ↦{dq} v) (λ a', l ↦{dq} (v <|(unittest.concreteFooer.a') := a'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End concreteFooer.

Module FooerUser.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : unittest.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance FooerUser_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (unittest.FooerUser.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "f" ∷ l.[(unittest.FooerUser.t), "f"] ↦{dq} v.(unittest.FooerUser.f') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance FooerUser_into_val_typed
   :
  IntoValTyped (unittest.FooerUser.t) (unittest.FooerUser).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance FooerUser_access_f l (v : (unittest.FooerUser.t)) dq :
  PointsToAccess
    (l.[(unittest.FooerUser.t), "f"]) (v.(unittest.FooerUser.f')) dq
    (l ↦{dq} v) (λ f', l ↦{dq} (v <|(unittest.FooerUser.f') := f'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End FooerUser.

Module B.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : unittest.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance B_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (unittest.B.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "a" ∷ l.[(unittest.B.t), "a"] ↦{dq} v.(unittest.B.a') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance B_into_val_typed
   :
  IntoValTyped (unittest.B.t) (unittest.B).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance B_access_a l (v : (unittest.B.t)) dq :
  PointsToAccess
    (l.[(unittest.B.t), "a"]) (v.(unittest.B.a')) dq
    (l ↦{dq} v) (λ a', l ↦{dq} (v <|(unittest.B.a') := a'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End B.

Module concrete1.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : unittest.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance concrete1_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (unittest.concrete1.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance concrete1_into_val_typed
   :
  IntoValTyped (unittest.concrete1.t) (unittest.concrete1).
Proof. solve_into_val_typed_struct. Qed.

End def.
End concrete1.

Module allTheLiterals.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : unittest.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance allTheLiterals_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (unittest.allTheLiterals.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "int" ∷ l.[(unittest.allTheLiterals.t), "int"] ↦{dq} v.(unittest.allTheLiterals.int') ∗
      "s" ∷ l.[(unittest.allTheLiterals.t), "s"] ↦{dq} v.(unittest.allTheLiterals.s') ∗
      "b" ∷ l.[(unittest.allTheLiterals.t), "b"] ↦{dq} v.(unittest.allTheLiterals.b') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance allTheLiterals_into_val_typed
   :
  IntoValTyped (unittest.allTheLiterals.t) (unittest.allTheLiterals).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance allTheLiterals_access_int l (v : (unittest.allTheLiterals.t)) dq :
  PointsToAccess
    (l.[(unittest.allTheLiterals.t), "int"]) (v.(unittest.allTheLiterals.int')) dq
    (l ↦{dq} v) (λ int', l ↦{dq} (v <|(unittest.allTheLiterals.int') := int'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance allTheLiterals_access_s l (v : (unittest.allTheLiterals.t)) dq :
  PointsToAccess
    (l.[(unittest.allTheLiterals.t), "s"]) (v.(unittest.allTheLiterals.s')) dq
    (l ↦{dq} v) (λ s', l ↦{dq} (v <|(unittest.allTheLiterals.s') := s'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance allTheLiterals_access_b l (v : (unittest.allTheLiterals.t)) dq :
  PointsToAccess
    (l.[(unittest.allTheLiterals.t), "b"]) (v.(unittest.allTheLiterals.b')) dq
    (l ↦{dq} v) (λ b', l ↦{dq} (v <|(unittest.allTheLiterals.b') := b'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End allTheLiterals.

Module hasCondVar.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : unittest.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance hasCondVar_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (unittest.hasCondVar.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "cond" ∷ l.[(unittest.hasCondVar.t), "cond"] ↦{dq} v.(unittest.hasCondVar.cond') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance hasCondVar_into_val_typed
   :
  IntoValTyped (unittest.hasCondVar.t) (unittest.hasCondVar).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance hasCondVar_access_cond l (v : (unittest.hasCondVar.t)) dq :
  PointsToAccess
    (l.[(unittest.hasCondVar.t), "cond"]) (v.(unittest.hasCondVar.cond')) dq
    (l ↦{dq} v) (λ cond', l ↦{dq} (v <|(unittest.hasCondVar.cond') := cond'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End hasCondVar.

Module mapElem.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : unittest.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance mapElem_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (unittest.mapElem.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "a" ∷ l.[(unittest.mapElem.t), "a"] ↦{dq} v.(unittest.mapElem.a') ∗
      "b" ∷ l.[(unittest.mapElem.t), "b"] ↦{dq} v.(unittest.mapElem.b') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance mapElem_into_val_typed
   :
  IntoValTyped (unittest.mapElem.t) (unittest.mapElem).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance mapElem_access_a l (v : (unittest.mapElem.t)) dq :
  PointsToAccess
    (l.[(unittest.mapElem.t), "a"]) (v.(unittest.mapElem.a')) dq
    (l ↦{dq} v) (λ a', l ↦{dq} (v <|(unittest.mapElem.a') := a'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance mapElem_access_b l (v : (unittest.mapElem.t)) dq :
  PointsToAccess
    (l.[(unittest.mapElem.t), "b"]) (v.(unittest.mapElem.b')) dq
    (l ↦{dq} v) (λ b', l ↦{dq} (v <|(unittest.mapElem.b') := b'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End mapElem.

Module containsPointer.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : unittest.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance containsPointer_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (unittest.containsPointer.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "s" ∷ l.[(unittest.containsPointer.t), "s"] ↦{dq} v.(unittest.containsPointer.s') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance containsPointer_into_val_typed
   :
  IntoValTyped (unittest.containsPointer.t) (unittest.containsPointer).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance containsPointer_access_s l (v : (unittest.containsPointer.t)) dq :
  PointsToAccess
    (l.[(unittest.containsPointer.t), "s"]) (v.(unittest.containsPointer.s')) dq
    (l ↦{dq} v) (λ s', l ↦{dq} (v <|(unittest.containsPointer.s') := s'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End containsPointer.

Module wrapExternalStruct.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : unittest.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance wrapExternalStruct_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (unittest.wrapExternalStruct.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "j" ∷ l.[(unittest.wrapExternalStruct.t), "j"] ↦{dq} v.(unittest.wrapExternalStruct.j') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance wrapExternalStruct_into_val_typed
   :
  IntoValTyped (unittest.wrapExternalStruct.t) (unittest.wrapExternalStruct).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance wrapExternalStruct_access_j l (v : (unittest.wrapExternalStruct.t)) dq :
  PointsToAccess
    (l.[(unittest.wrapExternalStruct.t), "j"]) (v.(unittest.wrapExternalStruct.j')) dq
    (l ↦{dq} v) (λ j', l ↦{dq} (v <|(unittest.wrapExternalStruct.j') := j'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End wrapExternalStruct.

Module typing.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : unittest.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance typing_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (unittest.typing.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "proph" ∷ l.[(unittest.typing.t), "proph"] ↦{dq} v.(unittest.typing.proph') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance typing_into_val_typed
   :
  IntoValTyped (unittest.typing.t) (unittest.typing).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance typing_access_proph l (v : (unittest.typing.t)) dq :
  PointsToAccess
    (l.[(unittest.typing.t), "proph"]) (v.(unittest.typing.proph')) dq
    (l ↦{dq} v) (λ proph', l ↦{dq} (v <|(unittest.typing.proph') := proph'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End typing.

Module composite.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : unittest.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance composite_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (unittest.composite.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "a" ∷ l.[(unittest.composite.t), "a"] ↦{dq} v.(unittest.composite.a') ∗
      "b" ∷ l.[(unittest.composite.t), "b"] ↦{dq} v.(unittest.composite.b') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance composite_into_val_typed
   :
  IntoValTyped (unittest.composite.t) (unittest.composite).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance composite_access_a l (v : (unittest.composite.t)) dq :
  PointsToAccess
    (l.[(unittest.composite.t), "a"]) (v.(unittest.composite.a')) dq
    (l ↦{dq} v) (λ a', l ↦{dq} (v <|(unittest.composite.a') := a'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance composite_access_b l (v : (unittest.composite.t)) dq :
  PointsToAccess
    (l.[(unittest.composite.t), "b"]) (v.(unittest.composite.b')) dq
    (l ↦{dq} v) (λ b', l ↦{dq} (v <|(unittest.composite.b') := b'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End composite.

Module R.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : unittest.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance R_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (unittest.R.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance R_into_val_typed
   :
  IntoValTyped (unittest.R.t) (unittest.R).
Proof. solve_into_val_typed_struct. Qed.

End def.
End R.

Module Other.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : unittest.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance Other_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (unittest.Other.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "RecursiveEmbedded" ∷ l.[(unittest.Other.t), "RecursiveEmbedded"] ↦{dq} v.(unittest.Other.RecursiveEmbedded') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance Other_into_val_typed
   :
  IntoValTyped (unittest.Other.t) (unittest.Other).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance Other_access_RecursiveEmbedded l (v : (unittest.Other.t)) dq :
  PointsToAccess
    (l.[(unittest.Other.t), "RecursiveEmbedded"]) (v.(unittest.Other.RecursiveEmbedded')) dq
    (l ↦{dq} v) (λ RecursiveEmbedded', l ↦{dq} (v <|(unittest.Other.RecursiveEmbedded') := RecursiveEmbedded'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End Other.

Module RecursiveEmbedded.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : unittest.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance RecursiveEmbedded_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (unittest.RecursiveEmbedded.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "Other" ∷ l.[(unittest.RecursiveEmbedded.t), "Other"] ↦{dq} v.(unittest.RecursiveEmbedded.Other') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance RecursiveEmbedded_into_val_typed
   :
  IntoValTyped (unittest.RecursiveEmbedded.t) (unittest.RecursiveEmbedded).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance RecursiveEmbedded_access_Other l (v : (unittest.RecursiveEmbedded.t)) dq :
  PointsToAccess
    (l.[(unittest.RecursiveEmbedded.t), "Other"]) (v.(unittest.RecursiveEmbedded.Other')) dq
    (l ↦{dq} v) (λ Other', l ↦{dq} (v <|(unittest.RecursiveEmbedded.Other') := Other'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End RecursiveEmbedded.

Module Block.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : unittest.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance Block_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (unittest.Block.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "Value" ∷ l.[(unittest.Block.t), "Value"] ↦{dq} v.(unittest.Block.Value') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance Block_into_val_typed
   :
  IntoValTyped (unittest.Block.t) (unittest.Block).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance Block_access_Value l (v : (unittest.Block.t)) dq :
  PointsToAccess
    (l.[(unittest.Block.t), "Value"]) (v.(unittest.Block.Value')) dq
    (l ↦{dq} v) (λ Value', l ↦{dq} (v <|(unittest.Block.Value') := Value'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End Block.

Module thing.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : unittest.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance thing_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (unittest.thing.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "x" ∷ l.[(unittest.thing.t), "x"] ↦{dq} v.(unittest.thing.x') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance thing_into_val_typed
   :
  IntoValTyped (unittest.thing.t) (unittest.thing).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance thing_access_x l (v : (unittest.thing.t)) dq :
  PointsToAccess
    (l.[(unittest.thing.t), "x"]) (v.(unittest.thing.x')) dq
    (l ↦{dq} v) (λ x', l ↦{dq} (v <|(unittest.thing.x') := x'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End thing.

Module sliceOfThings.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : unittest.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance sliceOfThings_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (unittest.sliceOfThings.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "things" ∷ l.[(unittest.sliceOfThings.t), "things"] ↦{dq} v.(unittest.sliceOfThings.things') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance sliceOfThings_into_val_typed
   :
  IntoValTyped (unittest.sliceOfThings.t) (unittest.sliceOfThings).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance sliceOfThings_access_things l (v : (unittest.sliceOfThings.t)) dq :
  PointsToAccess
    (l.[(unittest.sliceOfThings.t), "things"]) (v.(unittest.sliceOfThings.things')) dq
    (l ↦{dq} v) (λ things', l ↦{dq} (v <|(unittest.sliceOfThings.things') := things'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End sliceOfThings.

Module Point.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : unittest.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance Point_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (unittest.Point.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "x" ∷ l.[(unittest.Point.t), "x"] ↦{dq} v.(unittest.Point.x') ∗
      "y" ∷ l.[(unittest.Point.t), "y"] ↦{dq} v.(unittest.Point.y') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance Point_into_val_typed
   :
  IntoValTyped (unittest.Point.t) (unittest.Point).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance Point_access_x l (v : (unittest.Point.t)) dq :
  PointsToAccess
    (l.[(unittest.Point.t), "x"]) (v.(unittest.Point.x')) dq
    (l ↦{dq} v) (λ x', l ↦{dq} (v <|(unittest.Point.x') := x'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Point_access_y l (v : (unittest.Point.t)) dq :
  PointsToAccess
    (l.[(unittest.Point.t), "y"]) (v.(unittest.Point.y')) dq
    (l ↦{dq} v) (λ y', l ↦{dq} (v <|(unittest.Point.y') := y'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End Point.

Module TwoInts.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : unittest.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance TwoInts_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (unittest.TwoInts.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "x" ∷ l.[(unittest.TwoInts.t), "x"] ↦{dq} v.(unittest.TwoInts.x') ∗
      "y" ∷ l.[(unittest.TwoInts.t), "y"] ↦{dq} v.(unittest.TwoInts.y') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance TwoInts_into_val_typed
   :
  IntoValTyped (unittest.TwoInts.t) (unittest.TwoInts).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance TwoInts_access_x l (v : (unittest.TwoInts.t)) dq :
  PointsToAccess
    (l.[(unittest.TwoInts.t), "x"]) (v.(unittest.TwoInts.x')) dq
    (l ↦{dq} v) (λ x', l ↦{dq} (v <|(unittest.TwoInts.x') := x'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance TwoInts_access_y l (v : (unittest.TwoInts.t)) dq :
  PointsToAccess
    (l.[(unittest.TwoInts.t), "y"]) (v.(unittest.TwoInts.y')) dq
    (l ↦{dq} v) (λ y', l ↦{dq} (v <|(unittest.TwoInts.y') := y'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End TwoInts.

Module S.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : unittest.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance S_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (unittest.S.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "a" ∷ l.[(unittest.S.t), "a"] ↦{dq} v.(unittest.S.a') ∗
      "b" ∷ l.[(unittest.S.t), "b"] ↦{dq} v.(unittest.S.b') ∗
      "c" ∷ l.[(unittest.S.t), "c"] ↦{dq} v.(unittest.S.c') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance S_into_val_typed
   :
  IntoValTyped (unittest.S.t) (unittest.S).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance S_access_a l (v : (unittest.S.t)) dq :
  PointsToAccess
    (l.[(unittest.S.t), "a"]) (v.(unittest.S.a')) dq
    (l ↦{dq} v) (λ a', l ↦{dq} (v <|(unittest.S.a') := a'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance S_access_b l (v : (unittest.S.t)) dq :
  PointsToAccess
    (l.[(unittest.S.t), "b"]) (v.(unittest.S.b')) dq
    (l ↦{dq} v) (λ b', l ↦{dq} (v <|(unittest.S.b') := b'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance S_access_c l (v : (unittest.S.t)) dq :
  PointsToAccess
    (l.[(unittest.S.t), "c"]) (v.(unittest.S.c')) dq
    (l ↦{dq} v) (λ c', l ↦{dq} (v <|(unittest.S.c') := c'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End S.

Module A.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : unittest.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance A_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (unittest.A.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance A_into_val_typed
   :
  IntoValTyped (unittest.A.t) (unittest.A).
Proof. solve_into_val_typed_struct. Qed.

End def.
End A.

End unittest.
