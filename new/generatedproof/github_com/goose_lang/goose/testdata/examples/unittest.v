(* autogenerated by goose proofgen; do not modify *)
Require Export New.proof.disk_prelude.
Require Export New.generatedproof.fmt.
Require Export New.generatedproof.github_com.goose_lang.primitive.
Require Export New.generatedproof.github_com.goose_lang.primitive.disk.
Require Export New.generatedproof.github_com.goose_lang.std.
Require Export New.generatedproof.log.
Require Export New.generatedproof.sync.
Require Export New.golang.theory.
Require Export New.code.github_com.goose_lang.goose.testdata.examples.unittest.

Set Default Proof Using "Type".

Module unittest.
Module importantStruct.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : unittest.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance importantStruct_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (unittest.importantStruct.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance importantStruct_into_val_typed
   :
  IntoValTyped (unittest.importantStruct.t) (unittest.importantStruct).
Proof. solve_into_val_typed_struct. Qed.

End def.
End importantStruct.

Module withInterface.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : unittest.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance withInterface_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (unittest.withInterface.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "a" ∷ l.[(unittest.withInterface.t), "a"] ↦{dq} v.(unittest.withInterface.a') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance withInterface_into_val_typed
   :
  IntoValTyped (unittest.withInterface.t) (unittest.withInterface).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance withInterface_access_load_a l (v : (unittest.withInterface.t)) dq :
  AccessStrict
    (l.[(unittest.withInterface.t), "a"] ↦{dq} (v.(unittest.withInterface.a')))
    (l.[(unittest.withInterface.t), "a"] ↦{dq} (v.(unittest.withInterface.a')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance withInterface_access_store_a l (v : (unittest.withInterface.t)) a' :
  AccessStrict
    (l.[(unittest.withInterface.t), "a"] ↦ (v.(unittest.withInterface.a')))
    (l.[(unittest.withInterface.t), "a"] ↦ a')
    (l ↦ v) (l ↦ (v <|(unittest.withInterface.a') := a'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End withInterface.

Module diskWrapper.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : unittest.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance diskWrapper_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (unittest.diskWrapper.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "d" ∷ l.[(unittest.diskWrapper.t), "d"] ↦{dq} v.(unittest.diskWrapper.d') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance diskWrapper_into_val_typed
   :
  IntoValTyped (unittest.diskWrapper.t) (unittest.diskWrapper).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance diskWrapper_access_load_d l (v : (unittest.diskWrapper.t)) dq :
  AccessStrict
    (l.[(unittest.diskWrapper.t), "d"] ↦{dq} (v.(unittest.diskWrapper.d')))
    (l.[(unittest.diskWrapper.t), "d"] ↦{dq} (v.(unittest.diskWrapper.d')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance diskWrapper_access_store_d l (v : (unittest.diskWrapper.t)) d' :
  AccessStrict
    (l.[(unittest.diskWrapper.t), "d"] ↦ (v.(unittest.diskWrapper.d')))
    (l.[(unittest.diskWrapper.t), "d"] ↦ d')
    (l ↦ v) (l ↦ (v <|(unittest.diskWrapper.d') := d'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End diskWrapper.

Module embedA.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : unittest.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance embedA_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (unittest.embedA.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "a" ∷ l.[(unittest.embedA.t), "a"] ↦{dq} v.(unittest.embedA.a') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance embedA_into_val_typed
   :
  IntoValTyped (unittest.embedA.t) (unittest.embedA).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance embedA_access_load_a l (v : (unittest.embedA.t)) dq :
  AccessStrict
    (l.[(unittest.embedA.t), "a"] ↦{dq} (v.(unittest.embedA.a')))
    (l.[(unittest.embedA.t), "a"] ↦{dq} (v.(unittest.embedA.a')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance embedA_access_store_a l (v : (unittest.embedA.t)) a' :
  AccessStrict
    (l.[(unittest.embedA.t), "a"] ↦ (v.(unittest.embedA.a')))
    (l.[(unittest.embedA.t), "a"] ↦ a')
    (l ↦ v) (l ↦ (v <|(unittest.embedA.a') := a'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End embedA.

Module embedB.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : unittest.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance embedB_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (unittest.embedB.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "embedA" ∷ l.[(unittest.embedB.t), "embedA"] ↦{dq} v.(unittest.embedB.embedA') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance embedB_into_val_typed
   :
  IntoValTyped (unittest.embedB.t) (unittest.embedB).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance embedB_access_load_embedA l (v : (unittest.embedB.t)) dq :
  AccessStrict
    (l.[(unittest.embedB.t), "embedA"] ↦{dq} (v.(unittest.embedB.embedA')))
    (l.[(unittest.embedB.t), "embedA"] ↦{dq} (v.(unittest.embedB.embedA')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance embedB_access_store_embedA l (v : (unittest.embedB.t)) embedA' :
  AccessStrict
    (l.[(unittest.embedB.t), "embedA"] ↦ (v.(unittest.embedB.embedA')))
    (l.[(unittest.embedB.t), "embedA"] ↦ embedA')
    (l ↦ v) (l ↦ (v <|(unittest.embedB.embedA') := embedA'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End embedB.

Module embedC.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : unittest.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance embedC_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (unittest.embedC.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "embedB" ∷ l.[(unittest.embedC.t), "embedB"] ↦{dq} v.(unittest.embedC.embedB') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance embedC_into_val_typed
   :
  IntoValTyped (unittest.embedC.t) (unittest.embedC).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance embedC_access_load_embedB l (v : (unittest.embedC.t)) dq :
  AccessStrict
    (l.[(unittest.embedC.t), "embedB"] ↦{dq} (v.(unittest.embedC.embedB')))
    (l.[(unittest.embedC.t), "embedB"] ↦{dq} (v.(unittest.embedC.embedB')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance embedC_access_store_embedB l (v : (unittest.embedC.t)) embedB' :
  AccessStrict
    (l.[(unittest.embedC.t), "embedB"] ↦ (v.(unittest.embedC.embedB')))
    (l.[(unittest.embedC.t), "embedB"] ↦ embedB')
    (l ↦ v) (l ↦ (v <|(unittest.embedC.embedB') := embedB'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End embedC.

Module embedD.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : unittest.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance embedD_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (unittest.embedD.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "embedC" ∷ l.[(unittest.embedD.t), "embedC"] ↦{dq} v.(unittest.embedD.embedC') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance embedD_into_val_typed
   :
  IntoValTyped (unittest.embedD.t) (unittest.embedD).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance embedD_access_load_embedC l (v : (unittest.embedD.t)) dq :
  AccessStrict
    (l.[(unittest.embedD.t), "embedC"] ↦{dq} (v.(unittest.embedD.embedC')))
    (l.[(unittest.embedD.t), "embedC"] ↦{dq} (v.(unittest.embedD.embedC')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance embedD_access_store_embedC l (v : (unittest.embedD.t)) embedC' :
  AccessStrict
    (l.[(unittest.embedD.t), "embedC"] ↦ (v.(unittest.embedD.embedC')))
    (l.[(unittest.embedD.t), "embedC"] ↦ embedC')
    (l ↦ v) (l ↦ (v <|(unittest.embedD.embedC') := embedC'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End embedD.

Module Enc.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : unittest.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance Enc_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (unittest.Enc.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "p" ∷ l.[(unittest.Enc.t), "p"] ↦{dq} v.(unittest.Enc.p') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance Enc_into_val_typed
   :
  IntoValTyped (unittest.Enc.t) (unittest.Enc).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance Enc_access_load_p l (v : (unittest.Enc.t)) dq :
  AccessStrict
    (l.[(unittest.Enc.t), "p"] ↦{dq} (v.(unittest.Enc.p')))
    (l.[(unittest.Enc.t), "p"] ↦{dq} (v.(unittest.Enc.p')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Enc_access_store_p l (v : (unittest.Enc.t)) p' :
  AccessStrict
    (l.[(unittest.Enc.t), "p"] ↦ (v.(unittest.Enc.p')))
    (l.[(unittest.Enc.t), "p"] ↦ p')
    (l ↦ v) (l ↦ (v <|(unittest.Enc.p') := p'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End Enc.

Module Dec.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : unittest.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance Dec_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (unittest.Dec.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "p" ∷ l.[(unittest.Dec.t), "p"] ↦{dq} v.(unittest.Dec.p') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance Dec_into_val_typed
   :
  IntoValTyped (unittest.Dec.t) (unittest.Dec).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance Dec_access_load_p l (v : (unittest.Dec.t)) dq :
  AccessStrict
    (l.[(unittest.Dec.t), "p"] ↦{dq} (v.(unittest.Dec.p')))
    (l.[(unittest.Dec.t), "p"] ↦{dq} (v.(unittest.Dec.p')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Dec_access_store_p l (v : (unittest.Dec.t)) p' :
  AccessStrict
    (l.[(unittest.Dec.t), "p"] ↦ (v.(unittest.Dec.p')))
    (l.[(unittest.Dec.t), "p"] ↦ p')
    (l ↦ v) (l ↦ (v <|(unittest.Dec.p') := p'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End Dec.

Module concreteFooer.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : unittest.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance concreteFooer_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (unittest.concreteFooer.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "a" ∷ l.[(unittest.concreteFooer.t), "a"] ↦{dq} v.(unittest.concreteFooer.a') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance concreteFooer_into_val_typed
   :
  IntoValTyped (unittest.concreteFooer.t) (unittest.concreteFooer).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance concreteFooer_access_load_a l (v : (unittest.concreteFooer.t)) dq :
  AccessStrict
    (l.[(unittest.concreteFooer.t), "a"] ↦{dq} (v.(unittest.concreteFooer.a')))
    (l.[(unittest.concreteFooer.t), "a"] ↦{dq} (v.(unittest.concreteFooer.a')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance concreteFooer_access_store_a l (v : (unittest.concreteFooer.t)) a' :
  AccessStrict
    (l.[(unittest.concreteFooer.t), "a"] ↦ (v.(unittest.concreteFooer.a')))
    (l.[(unittest.concreteFooer.t), "a"] ↦ a')
    (l ↦ v) (l ↦ (v <|(unittest.concreteFooer.a') := a'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End concreteFooer.

Module FooerUser.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : unittest.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance FooerUser_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (unittest.FooerUser.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "f" ∷ l.[(unittest.FooerUser.t), "f"] ↦{dq} v.(unittest.FooerUser.f') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance FooerUser_into_val_typed
   :
  IntoValTyped (unittest.FooerUser.t) (unittest.FooerUser).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance FooerUser_access_load_f l (v : (unittest.FooerUser.t)) dq :
  AccessStrict
    (l.[(unittest.FooerUser.t), "f"] ↦{dq} (v.(unittest.FooerUser.f')))
    (l.[(unittest.FooerUser.t), "f"] ↦{dq} (v.(unittest.FooerUser.f')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance FooerUser_access_store_f l (v : (unittest.FooerUser.t)) f' :
  AccessStrict
    (l.[(unittest.FooerUser.t), "f"] ↦ (v.(unittest.FooerUser.f')))
    (l.[(unittest.FooerUser.t), "f"] ↦ f')
    (l ↦ v) (l ↦ (v <|(unittest.FooerUser.f') := f'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End FooerUser.

Module B.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : unittest.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance B_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (unittest.B.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "a" ∷ l.[(unittest.B.t), "a"] ↦{dq} v.(unittest.B.a') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance B_into_val_typed
   :
  IntoValTyped (unittest.B.t) (unittest.B).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance B_access_load_a l (v : (unittest.B.t)) dq :
  AccessStrict
    (l.[(unittest.B.t), "a"] ↦{dq} (v.(unittest.B.a')))
    (l.[(unittest.B.t), "a"] ↦{dq} (v.(unittest.B.a')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance B_access_store_a l (v : (unittest.B.t)) a' :
  AccessStrict
    (l.[(unittest.B.t), "a"] ↦ (v.(unittest.B.a')))
    (l.[(unittest.B.t), "a"] ↦ a')
    (l ↦ v) (l ↦ (v <|(unittest.B.a') := a'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End B.

Module concrete1.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : unittest.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance concrete1_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (unittest.concrete1.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance concrete1_into_val_typed
   :
  IntoValTyped (unittest.concrete1.t) (unittest.concrete1).
Proof. solve_into_val_typed_struct. Qed.

End def.
End concrete1.

Module allTheLiterals.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : unittest.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance allTheLiterals_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (unittest.allTheLiterals.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "int" ∷ l.[(unittest.allTheLiterals.t), "int"] ↦{dq} v.(unittest.allTheLiterals.int') ∗
      "s" ∷ l.[(unittest.allTheLiterals.t), "s"] ↦{dq} v.(unittest.allTheLiterals.s') ∗
      "b" ∷ l.[(unittest.allTheLiterals.t), "b"] ↦{dq} v.(unittest.allTheLiterals.b') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance allTheLiterals_into_val_typed
   :
  IntoValTyped (unittest.allTheLiterals.t) (unittest.allTheLiterals).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance allTheLiterals_access_load_int l (v : (unittest.allTheLiterals.t)) dq :
  AccessStrict
    (l.[(unittest.allTheLiterals.t), "int"] ↦{dq} (v.(unittest.allTheLiterals.int')))
    (l.[(unittest.allTheLiterals.t), "int"] ↦{dq} (v.(unittest.allTheLiterals.int')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance allTheLiterals_access_store_int l (v : (unittest.allTheLiterals.t)) int' :
  AccessStrict
    (l.[(unittest.allTheLiterals.t), "int"] ↦ (v.(unittest.allTheLiterals.int')))
    (l.[(unittest.allTheLiterals.t), "int"] ↦ int')
    (l ↦ v) (l ↦ (v <|(unittest.allTheLiterals.int') := int'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance allTheLiterals_access_load_s l (v : (unittest.allTheLiterals.t)) dq :
  AccessStrict
    (l.[(unittest.allTheLiterals.t), "s"] ↦{dq} (v.(unittest.allTheLiterals.s')))
    (l.[(unittest.allTheLiterals.t), "s"] ↦{dq} (v.(unittest.allTheLiterals.s')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance allTheLiterals_access_store_s l (v : (unittest.allTheLiterals.t)) s' :
  AccessStrict
    (l.[(unittest.allTheLiterals.t), "s"] ↦ (v.(unittest.allTheLiterals.s')))
    (l.[(unittest.allTheLiterals.t), "s"] ↦ s')
    (l ↦ v) (l ↦ (v <|(unittest.allTheLiterals.s') := s'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance allTheLiterals_access_load_b l (v : (unittest.allTheLiterals.t)) dq :
  AccessStrict
    (l.[(unittest.allTheLiterals.t), "b"] ↦{dq} (v.(unittest.allTheLiterals.b')))
    (l.[(unittest.allTheLiterals.t), "b"] ↦{dq} (v.(unittest.allTheLiterals.b')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance allTheLiterals_access_store_b l (v : (unittest.allTheLiterals.t)) b' :
  AccessStrict
    (l.[(unittest.allTheLiterals.t), "b"] ↦ (v.(unittest.allTheLiterals.b')))
    (l.[(unittest.allTheLiterals.t), "b"] ↦ b')
    (l ↦ v) (l ↦ (v <|(unittest.allTheLiterals.b') := b'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End allTheLiterals.

Module hasCondVar.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : unittest.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance hasCondVar_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (unittest.hasCondVar.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "cond" ∷ l.[(unittest.hasCondVar.t), "cond"] ↦{dq} v.(unittest.hasCondVar.cond') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance hasCondVar_into_val_typed
   :
  IntoValTyped (unittest.hasCondVar.t) (unittest.hasCondVar).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance hasCondVar_access_load_cond l (v : (unittest.hasCondVar.t)) dq :
  AccessStrict
    (l.[(unittest.hasCondVar.t), "cond"] ↦{dq} (v.(unittest.hasCondVar.cond')))
    (l.[(unittest.hasCondVar.t), "cond"] ↦{dq} (v.(unittest.hasCondVar.cond')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance hasCondVar_access_store_cond l (v : (unittest.hasCondVar.t)) cond' :
  AccessStrict
    (l.[(unittest.hasCondVar.t), "cond"] ↦ (v.(unittest.hasCondVar.cond')))
    (l.[(unittest.hasCondVar.t), "cond"] ↦ cond')
    (l ↦ v) (l ↦ (v <|(unittest.hasCondVar.cond') := cond'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End hasCondVar.

Module mapElem.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : unittest.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance mapElem_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (unittest.mapElem.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "a" ∷ l.[(unittest.mapElem.t), "a"] ↦{dq} v.(unittest.mapElem.a') ∗
      "b" ∷ l.[(unittest.mapElem.t), "b"] ↦{dq} v.(unittest.mapElem.b') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance mapElem_into_val_typed
   :
  IntoValTyped (unittest.mapElem.t) (unittest.mapElem).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance mapElem_access_load_a l (v : (unittest.mapElem.t)) dq :
  AccessStrict
    (l.[(unittest.mapElem.t), "a"] ↦{dq} (v.(unittest.mapElem.a')))
    (l.[(unittest.mapElem.t), "a"] ↦{dq} (v.(unittest.mapElem.a')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance mapElem_access_store_a l (v : (unittest.mapElem.t)) a' :
  AccessStrict
    (l.[(unittest.mapElem.t), "a"] ↦ (v.(unittest.mapElem.a')))
    (l.[(unittest.mapElem.t), "a"] ↦ a')
    (l ↦ v) (l ↦ (v <|(unittest.mapElem.a') := a'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance mapElem_access_load_b l (v : (unittest.mapElem.t)) dq :
  AccessStrict
    (l.[(unittest.mapElem.t), "b"] ↦{dq} (v.(unittest.mapElem.b')))
    (l.[(unittest.mapElem.t), "b"] ↦{dq} (v.(unittest.mapElem.b')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance mapElem_access_store_b l (v : (unittest.mapElem.t)) b' :
  AccessStrict
    (l.[(unittest.mapElem.t), "b"] ↦ (v.(unittest.mapElem.b')))
    (l.[(unittest.mapElem.t), "b"] ↦ b')
    (l ↦ v) (l ↦ (v <|(unittest.mapElem.b') := b'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End mapElem.

Module containsPointer.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : unittest.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance containsPointer_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (unittest.containsPointer.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "s" ∷ l.[(unittest.containsPointer.t), "s"] ↦{dq} v.(unittest.containsPointer.s') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance containsPointer_into_val_typed
   :
  IntoValTyped (unittest.containsPointer.t) (unittest.containsPointer).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance containsPointer_access_load_s l (v : (unittest.containsPointer.t)) dq :
  AccessStrict
    (l.[(unittest.containsPointer.t), "s"] ↦{dq} (v.(unittest.containsPointer.s')))
    (l.[(unittest.containsPointer.t), "s"] ↦{dq} (v.(unittest.containsPointer.s')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance containsPointer_access_store_s l (v : (unittest.containsPointer.t)) s' :
  AccessStrict
    (l.[(unittest.containsPointer.t), "s"] ↦ (v.(unittest.containsPointer.s')))
    (l.[(unittest.containsPointer.t), "s"] ↦ s')
    (l ↦ v) (l ↦ (v <|(unittest.containsPointer.s') := s'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End containsPointer.

Module wrapExternalStruct.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : unittest.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance wrapExternalStruct_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (unittest.wrapExternalStruct.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "j" ∷ l.[(unittest.wrapExternalStruct.t), "j"] ↦{dq} v.(unittest.wrapExternalStruct.j') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance wrapExternalStruct_into_val_typed
   :
  IntoValTyped (unittest.wrapExternalStruct.t) (unittest.wrapExternalStruct).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance wrapExternalStruct_access_load_j l (v : (unittest.wrapExternalStruct.t)) dq :
  AccessStrict
    (l.[(unittest.wrapExternalStruct.t), "j"] ↦{dq} (v.(unittest.wrapExternalStruct.j')))
    (l.[(unittest.wrapExternalStruct.t), "j"] ↦{dq} (v.(unittest.wrapExternalStruct.j')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance wrapExternalStruct_access_store_j l (v : (unittest.wrapExternalStruct.t)) j' :
  AccessStrict
    (l.[(unittest.wrapExternalStruct.t), "j"] ↦ (v.(unittest.wrapExternalStruct.j')))
    (l.[(unittest.wrapExternalStruct.t), "j"] ↦ j')
    (l ↦ v) (l ↦ (v <|(unittest.wrapExternalStruct.j') := j'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End wrapExternalStruct.

Module typing.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : unittest.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance typing_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (unittest.typing.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "proph" ∷ l.[(unittest.typing.t), "proph"] ↦{dq} v.(unittest.typing.proph') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance typing_into_val_typed
   :
  IntoValTyped (unittest.typing.t) (unittest.typing).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance typing_access_load_proph l (v : (unittest.typing.t)) dq :
  AccessStrict
    (l.[(unittest.typing.t), "proph"] ↦{dq} (v.(unittest.typing.proph')))
    (l.[(unittest.typing.t), "proph"] ↦{dq} (v.(unittest.typing.proph')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance typing_access_store_proph l (v : (unittest.typing.t)) proph' :
  AccessStrict
    (l.[(unittest.typing.t), "proph"] ↦ (v.(unittest.typing.proph')))
    (l.[(unittest.typing.t), "proph"] ↦ proph')
    (l ↦ v) (l ↦ (v <|(unittest.typing.proph') := proph'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End typing.

Module composite.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : unittest.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance composite_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (unittest.composite.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "a" ∷ l.[(unittest.composite.t), "a"] ↦{dq} v.(unittest.composite.a') ∗
      "b" ∷ l.[(unittest.composite.t), "b"] ↦{dq} v.(unittest.composite.b') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance composite_into_val_typed
   :
  IntoValTyped (unittest.composite.t) (unittest.composite).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance composite_access_load_a l (v : (unittest.composite.t)) dq :
  AccessStrict
    (l.[(unittest.composite.t), "a"] ↦{dq} (v.(unittest.composite.a')))
    (l.[(unittest.composite.t), "a"] ↦{dq} (v.(unittest.composite.a')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance composite_access_store_a l (v : (unittest.composite.t)) a' :
  AccessStrict
    (l.[(unittest.composite.t), "a"] ↦ (v.(unittest.composite.a')))
    (l.[(unittest.composite.t), "a"] ↦ a')
    (l ↦ v) (l ↦ (v <|(unittest.composite.a') := a'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance composite_access_load_b l (v : (unittest.composite.t)) dq :
  AccessStrict
    (l.[(unittest.composite.t), "b"] ↦{dq} (v.(unittest.composite.b')))
    (l.[(unittest.composite.t), "b"] ↦{dq} (v.(unittest.composite.b')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance composite_access_store_b l (v : (unittest.composite.t)) b' :
  AccessStrict
    (l.[(unittest.composite.t), "b"] ↦ (v.(unittest.composite.b')))
    (l.[(unittest.composite.t), "b"] ↦ b')
    (l ↦ v) (l ↦ (v <|(unittest.composite.b') := b'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End composite.

Module R.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : unittest.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance R_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (unittest.R.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance R_into_val_typed
   :
  IntoValTyped (unittest.R.t) (unittest.R).
Proof. solve_into_val_typed_struct. Qed.

End def.
End R.

Module Other.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : unittest.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance Other_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (unittest.Other.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "RecursiveEmbedded" ∷ l.[(unittest.Other.t), "RecursiveEmbedded"] ↦{dq} v.(unittest.Other.RecursiveEmbedded') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance Other_into_val_typed
   :
  IntoValTyped (unittest.Other.t) (unittest.Other).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance Other_access_load_RecursiveEmbedded l (v : (unittest.Other.t)) dq :
  AccessStrict
    (l.[(unittest.Other.t), "RecursiveEmbedded"] ↦{dq} (v.(unittest.Other.RecursiveEmbedded')))
    (l.[(unittest.Other.t), "RecursiveEmbedded"] ↦{dq} (v.(unittest.Other.RecursiveEmbedded')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Other_access_store_RecursiveEmbedded l (v : (unittest.Other.t)) RecursiveEmbedded' :
  AccessStrict
    (l.[(unittest.Other.t), "RecursiveEmbedded"] ↦ (v.(unittest.Other.RecursiveEmbedded')))
    (l.[(unittest.Other.t), "RecursiveEmbedded"] ↦ RecursiveEmbedded')
    (l ↦ v) (l ↦ (v <|(unittest.Other.RecursiveEmbedded') := RecursiveEmbedded'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End Other.

Module RecursiveEmbedded.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : unittest.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance RecursiveEmbedded_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (unittest.RecursiveEmbedded.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "Other" ∷ l.[(unittest.RecursiveEmbedded.t), "Other"] ↦{dq} v.(unittest.RecursiveEmbedded.Other') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance RecursiveEmbedded_into_val_typed
   :
  IntoValTyped (unittest.RecursiveEmbedded.t) (unittest.RecursiveEmbedded).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance RecursiveEmbedded_access_load_Other l (v : (unittest.RecursiveEmbedded.t)) dq :
  AccessStrict
    (l.[(unittest.RecursiveEmbedded.t), "Other"] ↦{dq} (v.(unittest.RecursiveEmbedded.Other')))
    (l.[(unittest.RecursiveEmbedded.t), "Other"] ↦{dq} (v.(unittest.RecursiveEmbedded.Other')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance RecursiveEmbedded_access_store_Other l (v : (unittest.RecursiveEmbedded.t)) Other' :
  AccessStrict
    (l.[(unittest.RecursiveEmbedded.t), "Other"] ↦ (v.(unittest.RecursiveEmbedded.Other')))
    (l.[(unittest.RecursiveEmbedded.t), "Other"] ↦ Other')
    (l ↦ v) (l ↦ (v <|(unittest.RecursiveEmbedded.Other') := Other'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End RecursiveEmbedded.

Module Block.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : unittest.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance Block_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (unittest.Block.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "Value" ∷ l.[(unittest.Block.t), "Value"] ↦{dq} v.(unittest.Block.Value') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance Block_into_val_typed
   :
  IntoValTyped (unittest.Block.t) (unittest.Block).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance Block_access_load_Value l (v : (unittest.Block.t)) dq :
  AccessStrict
    (l.[(unittest.Block.t), "Value"] ↦{dq} (v.(unittest.Block.Value')))
    (l.[(unittest.Block.t), "Value"] ↦{dq} (v.(unittest.Block.Value')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Block_access_store_Value l (v : (unittest.Block.t)) Value' :
  AccessStrict
    (l.[(unittest.Block.t), "Value"] ↦ (v.(unittest.Block.Value')))
    (l.[(unittest.Block.t), "Value"] ↦ Value')
    (l ↦ v) (l ↦ (v <|(unittest.Block.Value') := Value'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End Block.

Module thing.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : unittest.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance thing_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (unittest.thing.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "x" ∷ l.[(unittest.thing.t), "x"] ↦{dq} v.(unittest.thing.x') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance thing_into_val_typed
   :
  IntoValTyped (unittest.thing.t) (unittest.thing).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance thing_access_load_x l (v : (unittest.thing.t)) dq :
  AccessStrict
    (l.[(unittest.thing.t), "x"] ↦{dq} (v.(unittest.thing.x')))
    (l.[(unittest.thing.t), "x"] ↦{dq} (v.(unittest.thing.x')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance thing_access_store_x l (v : (unittest.thing.t)) x' :
  AccessStrict
    (l.[(unittest.thing.t), "x"] ↦ (v.(unittest.thing.x')))
    (l.[(unittest.thing.t), "x"] ↦ x')
    (l ↦ v) (l ↦ (v <|(unittest.thing.x') := x'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End thing.

Module sliceOfThings.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : unittest.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance sliceOfThings_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (unittest.sliceOfThings.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "things" ∷ l.[(unittest.sliceOfThings.t), "things"] ↦{dq} v.(unittest.sliceOfThings.things') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance sliceOfThings_into_val_typed
   :
  IntoValTyped (unittest.sliceOfThings.t) (unittest.sliceOfThings).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance sliceOfThings_access_load_things l (v : (unittest.sliceOfThings.t)) dq :
  AccessStrict
    (l.[(unittest.sliceOfThings.t), "things"] ↦{dq} (v.(unittest.sliceOfThings.things')))
    (l.[(unittest.sliceOfThings.t), "things"] ↦{dq} (v.(unittest.sliceOfThings.things')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance sliceOfThings_access_store_things l (v : (unittest.sliceOfThings.t)) things' :
  AccessStrict
    (l.[(unittest.sliceOfThings.t), "things"] ↦ (v.(unittest.sliceOfThings.things')))
    (l.[(unittest.sliceOfThings.t), "things"] ↦ things')
    (l ↦ v) (l ↦ (v <|(unittest.sliceOfThings.things') := things'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End sliceOfThings.

Module Point.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : unittest.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance Point_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (unittest.Point.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "x" ∷ l.[(unittest.Point.t), "x"] ↦{dq} v.(unittest.Point.x') ∗
      "y" ∷ l.[(unittest.Point.t), "y"] ↦{dq} v.(unittest.Point.y') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance Point_into_val_typed
   :
  IntoValTyped (unittest.Point.t) (unittest.Point).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance Point_access_load_x l (v : (unittest.Point.t)) dq :
  AccessStrict
    (l.[(unittest.Point.t), "x"] ↦{dq} (v.(unittest.Point.x')))
    (l.[(unittest.Point.t), "x"] ↦{dq} (v.(unittest.Point.x')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Point_access_store_x l (v : (unittest.Point.t)) x' :
  AccessStrict
    (l.[(unittest.Point.t), "x"] ↦ (v.(unittest.Point.x')))
    (l.[(unittest.Point.t), "x"] ↦ x')
    (l ↦ v) (l ↦ (v <|(unittest.Point.x') := x'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Point_access_load_y l (v : (unittest.Point.t)) dq :
  AccessStrict
    (l.[(unittest.Point.t), "y"] ↦{dq} (v.(unittest.Point.y')))
    (l.[(unittest.Point.t), "y"] ↦{dq} (v.(unittest.Point.y')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Point_access_store_y l (v : (unittest.Point.t)) y' :
  AccessStrict
    (l.[(unittest.Point.t), "y"] ↦ (v.(unittest.Point.y')))
    (l.[(unittest.Point.t), "y"] ↦ y')
    (l ↦ v) (l ↦ (v <|(unittest.Point.y') := y'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End Point.

Module TwoInts.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : unittest.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance TwoInts_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (unittest.TwoInts.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "x" ∷ l.[(unittest.TwoInts.t), "x"] ↦{dq} v.(unittest.TwoInts.x') ∗
      "y" ∷ l.[(unittest.TwoInts.t), "y"] ↦{dq} v.(unittest.TwoInts.y') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance TwoInts_into_val_typed
   :
  IntoValTyped (unittest.TwoInts.t) (unittest.TwoInts).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance TwoInts_access_load_x l (v : (unittest.TwoInts.t)) dq :
  AccessStrict
    (l.[(unittest.TwoInts.t), "x"] ↦{dq} (v.(unittest.TwoInts.x')))
    (l.[(unittest.TwoInts.t), "x"] ↦{dq} (v.(unittest.TwoInts.x')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance TwoInts_access_store_x l (v : (unittest.TwoInts.t)) x' :
  AccessStrict
    (l.[(unittest.TwoInts.t), "x"] ↦ (v.(unittest.TwoInts.x')))
    (l.[(unittest.TwoInts.t), "x"] ↦ x')
    (l ↦ v) (l ↦ (v <|(unittest.TwoInts.x') := x'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance TwoInts_access_load_y l (v : (unittest.TwoInts.t)) dq :
  AccessStrict
    (l.[(unittest.TwoInts.t), "y"] ↦{dq} (v.(unittest.TwoInts.y')))
    (l.[(unittest.TwoInts.t), "y"] ↦{dq} (v.(unittest.TwoInts.y')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance TwoInts_access_store_y l (v : (unittest.TwoInts.t)) y' :
  AccessStrict
    (l.[(unittest.TwoInts.t), "y"] ↦ (v.(unittest.TwoInts.y')))
    (l.[(unittest.TwoInts.t), "y"] ↦ y')
    (l ↦ v) (l ↦ (v <|(unittest.TwoInts.y') := y'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End TwoInts.

Module S.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : unittest.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance S_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (unittest.S.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "a" ∷ l.[(unittest.S.t), "a"] ↦{dq} v.(unittest.S.a') ∗
      "b" ∷ l.[(unittest.S.t), "b"] ↦{dq} v.(unittest.S.b') ∗
      "c" ∷ l.[(unittest.S.t), "c"] ↦{dq} v.(unittest.S.c') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance S_into_val_typed
   :
  IntoValTyped (unittest.S.t) (unittest.S).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance S_access_load_a l (v : (unittest.S.t)) dq :
  AccessStrict
    (l.[(unittest.S.t), "a"] ↦{dq} (v.(unittest.S.a')))
    (l.[(unittest.S.t), "a"] ↦{dq} (v.(unittest.S.a')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance S_access_store_a l (v : (unittest.S.t)) a' :
  AccessStrict
    (l.[(unittest.S.t), "a"] ↦ (v.(unittest.S.a')))
    (l.[(unittest.S.t), "a"] ↦ a')
    (l ↦ v) (l ↦ (v <|(unittest.S.a') := a'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance S_access_load_b l (v : (unittest.S.t)) dq :
  AccessStrict
    (l.[(unittest.S.t), "b"] ↦{dq} (v.(unittest.S.b')))
    (l.[(unittest.S.t), "b"] ↦{dq} (v.(unittest.S.b')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance S_access_store_b l (v : (unittest.S.t)) b' :
  AccessStrict
    (l.[(unittest.S.t), "b"] ↦ (v.(unittest.S.b')))
    (l.[(unittest.S.t), "b"] ↦ b')
    (l ↦ v) (l ↦ (v <|(unittest.S.b') := b'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance S_access_load_c l (v : (unittest.S.t)) dq :
  AccessStrict
    (l.[(unittest.S.t), "c"] ↦{dq} (v.(unittest.S.c')))
    (l.[(unittest.S.t), "c"] ↦{dq} (v.(unittest.S.c')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance S_access_store_c l (v : (unittest.S.t)) c' :
  AccessStrict
    (l.[(unittest.S.t), "c"] ↦ (v.(unittest.S.c')))
    (l.[(unittest.S.t), "c"] ↦ c')
    (l ↦ v) (l ↦ (v <|(unittest.S.c') := c'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End S.

Module A.
Section def.

Context `{!heapGS Σ}.
Context {sem : go.Semantics}.
Context {package_sem' : unittest.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance A_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (unittest.A.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance A_into_val_typed
   :
  IntoValTyped (unittest.A.t) (unittest.A).
Proof. solve_into_val_typed_struct. Qed.

End def.
End A.

End unittest.
