(* autogenerated by goose proofgen; do not modify *)
Require Export New.proof.proof_prelude.
Require Export New.generatedproof.github_com.goose_lang.primitive.
Require Export New.golang.theory.pre.
Require Export New.code.github_com.goose_lang.goose.model.channel.

Set Default Proof Using "Type".

Module channel.
Module Channel.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem_fn : GoSemanticsFunctions} {pre_sem : go.PreSemantics}.
Context {package_sem' : channel.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance Channel_typed_pointsto `{!TypedPointsto (Σ:=Σ) T'}  :
  TypedPointsto (Σ:=Σ) (channel.Channel.t T') :=
  {|
    typed_pointsto_def l v dq :=
      (
      "cap" ∷ l.[(channel.Channel.t T'), "cap"] ↦{dq} v.(channel.Channel.cap') ∗
      "mu" ∷ l.[(channel.Channel.t T'), "mu"] ↦{dq} v.(channel.Channel.mu') ∗
      "state" ∷ l.[(channel.Channel.t T'), "state"] ↦{dq} v.(channel.Channel.state') ∗
      "buffer" ∷ l.[(channel.Channel.t T'), "buffer"] ↦{dq} v.(channel.Channel.buffer') ∗
      "v" ∷ l.[(channel.Channel.t T'), "v"] ↦{dq} v.(channel.Channel.v') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance Channel_into_val_typed
  `{!ZeroVal T'} `{!TypedPointsto (Σ:=Σ) T'} `{!IntoValTyped T' T} `{!go.TypeRepr T T'}  :
  IntoValTypedUnderlying (channel.Channel.t T') (channel.Channelⁱᵐᵖˡ T).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance Channel_access_load_cap `{!TypedPointsto (Σ:=Σ) T'} l (v : (channel.Channel.t T')) dq :
  AccessStrict
    (l.[(channel.Channel.t T'), "cap"] ↦{dq} (v.(channel.Channel.cap')))
    (l.[(channel.Channel.t T'), "cap"] ↦{dq} (v.(channel.Channel.cap')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Channel_access_store_cap `{!TypedPointsto (Σ:=Σ) T'} l (v : (channel.Channel.t T')) cap' :
  AccessStrict
    (l.[(channel.Channel.t T'), "cap"] ↦ (v.(channel.Channel.cap')))
    (l.[(channel.Channel.t T'), "cap"] ↦ cap')
    (l ↦ v) (l ↦ (v <|(channel.Channel.cap') := cap'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Channel_access_load_mu `{!TypedPointsto (Σ:=Σ) T'} l (v : (channel.Channel.t T')) dq :
  AccessStrict
    (l.[(channel.Channel.t T'), "mu"] ↦{dq} (v.(channel.Channel.mu')))
    (l.[(channel.Channel.t T'), "mu"] ↦{dq} (v.(channel.Channel.mu')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Channel_access_store_mu `{!TypedPointsto (Σ:=Σ) T'} l (v : (channel.Channel.t T')) mu' :
  AccessStrict
    (l.[(channel.Channel.t T'), "mu"] ↦ (v.(channel.Channel.mu')))
    (l.[(channel.Channel.t T'), "mu"] ↦ mu')
    (l ↦ v) (l ↦ (v <|(channel.Channel.mu') := mu'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Channel_access_load_state `{!TypedPointsto (Σ:=Σ) T'} l (v : (channel.Channel.t T')) dq :
  AccessStrict
    (l.[(channel.Channel.t T'), "state"] ↦{dq} (v.(channel.Channel.state')))
    (l.[(channel.Channel.t T'), "state"] ↦{dq} (v.(channel.Channel.state')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Channel_access_store_state `{!TypedPointsto (Σ:=Σ) T'} l (v : (channel.Channel.t T')) state' :
  AccessStrict
    (l.[(channel.Channel.t T'), "state"] ↦ (v.(channel.Channel.state')))
    (l.[(channel.Channel.t T'), "state"] ↦ state')
    (l ↦ v) (l ↦ (v <|(channel.Channel.state') := state'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Channel_access_load_buffer `{!TypedPointsto (Σ:=Σ) T'} l (v : (channel.Channel.t T')) dq :
  AccessStrict
    (l.[(channel.Channel.t T'), "buffer"] ↦{dq} (v.(channel.Channel.buffer')))
    (l.[(channel.Channel.t T'), "buffer"] ↦{dq} (v.(channel.Channel.buffer')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Channel_access_store_buffer `{!TypedPointsto (Σ:=Σ) T'} l (v : (channel.Channel.t T')) buffer' :
  AccessStrict
    (l.[(channel.Channel.t T'), "buffer"] ↦ (v.(channel.Channel.buffer')))
    (l.[(channel.Channel.t T'), "buffer"] ↦ buffer')
    (l ↦ v) (l ↦ (v <|(channel.Channel.buffer') := buffer'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Channel_access_load_v `{!TypedPointsto (Σ:=Σ) T'} l (v : (channel.Channel.t T')) dq :
  AccessStrict
    (l.[(channel.Channel.t T'), "v"] ↦{dq} (v.(channel.Channel.v')))
    (l.[(channel.Channel.t T'), "v"] ↦{dq} (v.(channel.Channel.v')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Channel_access_store_v `{!TypedPointsto (Σ:=Σ) T'} l (v : (channel.Channel.t T')) v' :
  AccessStrict
    (l.[(channel.Channel.t T'), "v"] ↦ (v.(channel.Channel.v')))
    (l.[(channel.Channel.t T'), "v"] ↦ v')
    (l ↦ v) (l ↦ (v <|(channel.Channel.v') := v'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End Channel.

End channel.
