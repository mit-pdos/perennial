(* autogenerated by goose proofgen; do not modify *)
Require Export New.proof.proof_prelude.
Require Export New.generatedproof.github_com.goose_lang.primitive.
Require Export New.golang.theory.pre.
Require Export New.code.github_com.goose_lang.goose.model.channel.

Set Default Proof Using "Type".

Module channel.
Module Channel.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem_fn : GoSemanticsFunctions} {pre_sem : go.PreSemantics}.
Context {package_sem' : channel.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance Channel_typed_pointsto `{!TypedPointsto (Σ:=Σ) T'}  :
  TypedPointsto (Σ:=Σ) (channel.Channel.t T') :=
  {|
    typed_pointsto_def l v dq :=
      (
      "cap" ∷ l.[(channel.Channel.t T'), "cap"] ↦{dq} v.(channel.Channel.cap') ∗
      "mu" ∷ l.[(channel.Channel.t T'), "mu"] ↦{dq} v.(channel.Channel.mu') ∗
      "state" ∷ l.[(channel.Channel.t T'), "state"] ↦{dq} v.(channel.Channel.state') ∗
      "buffer" ∷ l.[(channel.Channel.t T'), "buffer"] ↦{dq} v.(channel.Channel.buffer') ∗
      "v" ∷ l.[(channel.Channel.t T'), "v"] ↦{dq} v.(channel.Channel.v') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance Channel_into_val_typed
  `{!ZeroVal T'} `{!TypedPointsto (Σ:=Σ) T'} `{!IntoValTyped T' T} `{!go.TypeRepr T T'}  :
  IntoValTyped (channel.Channel.t T') (channel.Channel T).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance Channel_access_cap`{!TypedPointsto (Σ:=Σ) T'}  l (v : (channel.Channel.t T')) dq :
  PointsToAccess
    (l.[(channel.Channel.t T'), "cap"]) (v.(channel.Channel.cap')) dq
    (l ↦{dq} v) (λ cap', l ↦{dq} (v <|(channel.Channel.cap') := cap'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Channel_access_mu`{!TypedPointsto (Σ:=Σ) T'}  l (v : (channel.Channel.t T')) dq :
  PointsToAccess
    (l.[(channel.Channel.t T'), "mu"]) (v.(channel.Channel.mu')) dq
    (l ↦{dq} v) (λ mu', l ↦{dq} (v <|(channel.Channel.mu') := mu'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Channel_access_state`{!TypedPointsto (Σ:=Σ) T'}  l (v : (channel.Channel.t T')) dq :
  PointsToAccess
    (l.[(channel.Channel.t T'), "state"]) (v.(channel.Channel.state')) dq
    (l ↦{dq} v) (λ state', l ↦{dq} (v <|(channel.Channel.state') := state'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Channel_access_buffer`{!TypedPointsto (Σ:=Σ) T'}  l (v : (channel.Channel.t T')) dq :
  PointsToAccess
    (l.[(channel.Channel.t T'), "buffer"]) (v.(channel.Channel.buffer')) dq
    (l ↦{dq} v) (λ buffer', l ↦{dq} (v <|(channel.Channel.buffer') := buffer'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Channel_access_v`{!TypedPointsto (Σ:=Σ) T'}  l (v : (channel.Channel.t T')) dq :
  PointsToAccess
    (l.[(channel.Channel.t T'), "v"]) (v.(channel.Channel.v')) dq
    (l ↦{dq} v) (λ v', l ↦{dq} (v <|(channel.Channel.v') := v'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End Channel.

End channel.
