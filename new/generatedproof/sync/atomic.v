(* autogenerated by goose proofgen; do not modify *)
Require Export New.proof.proof_prelude.
Require Export New.manualproof.sync.atomic.
Require Export New.golang.theory.
Require Export New.code.sync.atomic.

Set Default Proof Using "Type".

Module atomic.
Module noCopy.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : atomic.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance noCopy_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (atomic.noCopy.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance noCopy_into_val_typed
   :
  IntoValTyped (atomic.noCopy.t) (atomic.noCopy).
Proof. solve_into_val_typed_struct. Qed.

End def.
End noCopy.

Module Bool.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : atomic.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance Bool_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (atomic.Bool.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "_0" ∷ l.[(atomic.Bool.t), "_0"] ↦{dq} v.(atomic.Bool._0') ∗
      "v" ∷ l.[(atomic.Bool.t), "v"] ↦{dq} v.(atomic.Bool.v') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance Bool_into_val_typed
   :
  IntoValTyped (atomic.Bool.t) (atomic.Bool).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance Bool_access__0 l (v : (atomic.Bool.t)) dq :
  PointsToAccess
    (l.[(atomic.Bool.t), "_0"]) (v.(atomic.Bool._0')) dq
    (l ↦{dq} v) (λ _0', l ↦{dq} (v <|(atomic.Bool._0') := _0'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Bool_access_v l (v : (atomic.Bool.t)) dq :
  PointsToAccess
    (l.[(atomic.Bool.t), "v"]) (v.(atomic.Bool.v')) dq
    (l ↦{dq} v) (λ v', l ↦{dq} (v <|(atomic.Bool.v') := v'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End Bool.

Module Pointer.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : atomic.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance Pointer_typed_pointsto `{!TypedPointsto (Σ:=Σ) T'}  :
  TypedPointsto (Σ:=Σ) (atomic.Pointer.t T') :=
  {|
    typed_pointsto_def l v dq :=
      (
      "_0" ∷ l.[(atomic.Pointer.t T'), "_0"] ↦{dq} v.(atomic.Pointer._0') ∗
      "_1" ∷ l.[(atomic.Pointer.t T'), "_1"] ↦{dq} v.(atomic.Pointer._1') ∗
      "v" ∷ l.[(atomic.Pointer.t T'), "v"] ↦{dq} v.(atomic.Pointer.v') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance Pointer_into_val_typed
  `{!ZeroVal T'} `{!TypedPointsto (Σ:=Σ) T'} `{!IntoValTyped T' T} `{!go.TypeRepr T T'}  :
  IntoValTyped (atomic.Pointer.t T') (atomic.Pointer T).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance Pointer_access__0 `{!TypedPointsto (Σ:=Σ) T'} l (v : (atomic.Pointer.t T')) dq :
  PointsToAccess
    (l.[(atomic.Pointer.t T'), "_0"]) (v.(atomic.Pointer._0')) dq
    (l ↦{dq} v) (λ _0', l ↦{dq} (v <|(atomic.Pointer._0') := _0'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Pointer_access__1 `{!TypedPointsto (Σ:=Σ) T'} l (v : (atomic.Pointer.t T')) dq :
  PointsToAccess
    (l.[(atomic.Pointer.t T'), "_1"]) (v.(atomic.Pointer._1')) dq
    (l ↦{dq} v) (λ _1', l ↦{dq} (v <|(atomic.Pointer._1') := _1'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Pointer_access_v `{!TypedPointsto (Σ:=Σ) T'} l (v : (atomic.Pointer.t T')) dq :
  PointsToAccess
    (l.[(atomic.Pointer.t T'), "v"]) (v.(atomic.Pointer.v')) dq
    (l ↦{dq} v) (λ v', l ↦{dq} (v <|(atomic.Pointer.v') := v'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End Pointer.

Module Int32.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : atomic.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance Int32_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (atomic.Int32.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "_0" ∷ l.[(atomic.Int32.t), "_0"] ↦{dq} v.(atomic.Int32._0') ∗
      "v" ∷ l.[(atomic.Int32.t), "v"] ↦{dq} v.(atomic.Int32.v') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance Int32_into_val_typed
   :
  IntoValTyped (atomic.Int32.t) (atomic.Int32).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance Int32_access__0 l (v : (atomic.Int32.t)) dq :
  PointsToAccess
    (l.[(atomic.Int32.t), "_0"]) (v.(atomic.Int32._0')) dq
    (l ↦{dq} v) (λ _0', l ↦{dq} (v <|(atomic.Int32._0') := _0'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Int32_access_v l (v : (atomic.Int32.t)) dq :
  PointsToAccess
    (l.[(atomic.Int32.t), "v"]) (v.(atomic.Int32.v')) dq
    (l ↦{dq} v) (λ v', l ↦{dq} (v <|(atomic.Int32.v') := v'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End Int32.

Module align64.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : atomic.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance align64_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (atomic.align64.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance align64_into_val_typed
   :
  IntoValTyped (atomic.align64.t) (atomic.align64).
Proof. solve_into_val_typed_struct. Qed.

End def.
End align64.

Module Int64.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : atomic.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance Int64_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (atomic.Int64.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "_0" ∷ l.[(atomic.Int64.t), "_0"] ↦{dq} v.(atomic.Int64._0') ∗
      "_1" ∷ l.[(atomic.Int64.t), "_1"] ↦{dq} v.(atomic.Int64._1') ∗
      "v" ∷ l.[(atomic.Int64.t), "v"] ↦{dq} v.(atomic.Int64.v') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance Int64_into_val_typed
   :
  IntoValTyped (atomic.Int64.t) (atomic.Int64).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance Int64_access__0 l (v : (atomic.Int64.t)) dq :
  PointsToAccess
    (l.[(atomic.Int64.t), "_0"]) (v.(atomic.Int64._0')) dq
    (l ↦{dq} v) (λ _0', l ↦{dq} (v <|(atomic.Int64._0') := _0'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Int64_access__1 l (v : (atomic.Int64.t)) dq :
  PointsToAccess
    (l.[(atomic.Int64.t), "_1"]) (v.(atomic.Int64._1')) dq
    (l ↦{dq} v) (λ _1', l ↦{dq} (v <|(atomic.Int64._1') := _1'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Int64_access_v l (v : (atomic.Int64.t)) dq :
  PointsToAccess
    (l.[(atomic.Int64.t), "v"]) (v.(atomic.Int64.v')) dq
    (l ↦{dq} v) (λ v', l ↦{dq} (v <|(atomic.Int64.v') := v'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End Int64.

Module Uint32.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : atomic.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance Uint32_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (atomic.Uint32.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "_0" ∷ l.[(atomic.Uint32.t), "_0"] ↦{dq} v.(atomic.Uint32._0') ∗
      "v" ∷ l.[(atomic.Uint32.t), "v"] ↦{dq} v.(atomic.Uint32.v') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance Uint32_into_val_typed
   :
  IntoValTyped (atomic.Uint32.t) (atomic.Uint32).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance Uint32_access__0 l (v : (atomic.Uint32.t)) dq :
  PointsToAccess
    (l.[(atomic.Uint32.t), "_0"]) (v.(atomic.Uint32._0')) dq
    (l ↦{dq} v) (λ _0', l ↦{dq} (v <|(atomic.Uint32._0') := _0'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Uint32_access_v l (v : (atomic.Uint32.t)) dq :
  PointsToAccess
    (l.[(atomic.Uint32.t), "v"]) (v.(atomic.Uint32.v')) dq
    (l ↦{dq} v) (λ v', l ↦{dq} (v <|(atomic.Uint32.v') := v'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End Uint32.

Module Uint64.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : atomic.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance Uint64_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (atomic.Uint64.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "_0" ∷ l.[(atomic.Uint64.t), "_0"] ↦{dq} v.(atomic.Uint64._0') ∗
      "_1" ∷ l.[(atomic.Uint64.t), "_1"] ↦{dq} v.(atomic.Uint64._1') ∗
      "v" ∷ l.[(atomic.Uint64.t), "v"] ↦{dq} v.(atomic.Uint64.v') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance Uint64_into_val_typed
   :
  IntoValTyped (atomic.Uint64.t) (atomic.Uint64).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance Uint64_access__0 l (v : (atomic.Uint64.t)) dq :
  PointsToAccess
    (l.[(atomic.Uint64.t), "_0"]) (v.(atomic.Uint64._0')) dq
    (l ↦{dq} v) (λ _0', l ↦{dq} (v <|(atomic.Uint64._0') := _0'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Uint64_access__1 l (v : (atomic.Uint64.t)) dq :
  PointsToAccess
    (l.[(atomic.Uint64.t), "_1"]) (v.(atomic.Uint64._1')) dq
    (l ↦{dq} v) (λ _1', l ↦{dq} (v <|(atomic.Uint64._1') := _1'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Uint64_access_v l (v : (atomic.Uint64.t)) dq :
  PointsToAccess
    (l.[(atomic.Uint64.t), "v"]) (v.(atomic.Uint64.v')) dq
    (l ↦{dq} v) (λ v', l ↦{dq} (v <|(atomic.Uint64.v') := v'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End Uint64.

Module Uintptr.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : atomic.Assumptions}.

Local Set Default Proof Using "All".

#[global] Instance Uintptr_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (atomic.Uintptr.t). Admitted.

#[global] Instance Uintptr_into_val_typed
   :
  IntoValTyped (atomic.Uintptr.t) (atomic.Uintptr).
Proof. Admitted.

End def.
End Uintptr.

Module Value.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : atomic.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance Value_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (atomic.Value.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "v" ∷ l.[(atomic.Value.t), "v"] ↦{dq} v.(atomic.Value.v') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance Value_into_val_typed
   :
  IntoValTyped (atomic.Value.t) (atomic.Value).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance Value_access_v l (v : (atomic.Value.t)) dq :
  PointsToAccess
    (l.[(atomic.Value.t), "v"]) (v.(atomic.Value.v')) dq
    (l ↦{dq} v) (λ v', l ↦{dq} (v <|(atomic.Value.v') := v'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End Value.

Module efaceWords.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : atomic.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance efaceWords_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (atomic.efaceWords.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "typ" ∷ l.[(atomic.efaceWords.t), "typ"] ↦{dq} v.(atomic.efaceWords.typ') ∗
      "data" ∷ l.[(atomic.efaceWords.t), "data"] ↦{dq} v.(atomic.efaceWords.data') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance efaceWords_into_val_typed
   :
  IntoValTyped (atomic.efaceWords.t) (atomic.efaceWords).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance efaceWords_access_typ l (v : (atomic.efaceWords.t)) dq :
  PointsToAccess
    (l.[(atomic.efaceWords.t), "typ"]) (v.(atomic.efaceWords.typ')) dq
    (l ↦{dq} v) (λ typ', l ↦{dq} (v <|(atomic.efaceWords.typ') := typ'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance efaceWords_access_data l (v : (atomic.efaceWords.t)) dq :
  PointsToAccess
    (l.[(atomic.efaceWords.t), "data"]) (v.(atomic.efaceWords.data')) dq
    (l ↦{dq} v) (λ data', l ↦{dq} (v <|(atomic.efaceWords.data') := data'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End efaceWords.

End atomic.
