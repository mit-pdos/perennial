(* autogenerated by goose proofgen; do not modify *)
Require Export New.proof.proof_prelude.
Require Export New.generatedproof.errors.
Require Export New.generatedproof.sync.
Require Export New.generatedproof.sync.atomic.
Require Export New.generatedproof.time.
Require Export New.golang.theory.
Require Export New.code.context.

Set Default Proof Using "Type".

Module context.
Module deadlineExceededError.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : context.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance deadlineExceededError_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (context.deadlineExceededError.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance deadlineExceededError_into_val_typed
   :
  IntoValTypedUnderlying (context.deadlineExceededError.t) (context.deadlineExceededErrorⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.

End def.
End deadlineExceededError.

Module emptyCtx.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : context.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance emptyCtx_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (context.emptyCtx.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance emptyCtx_into_val_typed
   :
  IntoValTypedUnderlying (context.emptyCtx.t) (context.emptyCtxⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.

End def.
End emptyCtx.

Module backgroundCtx.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : context.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance backgroundCtx_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (context.backgroundCtx.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "emptyCtx" ∷ l.[(context.backgroundCtx.t), "emptyCtx"] ↦{dq} v.(context.backgroundCtx.emptyCtx') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance backgroundCtx_into_val_typed
   :
  IntoValTypedUnderlying (context.backgroundCtx.t) (context.backgroundCtxⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance backgroundCtx_access_load_emptyCtx l (v : (context.backgroundCtx.t)) dq :
  AccessStrict
    (l.[(context.backgroundCtx.t), "emptyCtx"] ↦{dq} (v.(context.backgroundCtx.emptyCtx')))
    (l.[(context.backgroundCtx.t), "emptyCtx"] ↦{dq} (v.(context.backgroundCtx.emptyCtx')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance backgroundCtx_access_store_emptyCtx l (v : (context.backgroundCtx.t)) emptyCtx' :
  AccessStrict
    (l.[(context.backgroundCtx.t), "emptyCtx"] ↦ (v.(context.backgroundCtx.emptyCtx')))
    (l.[(context.backgroundCtx.t), "emptyCtx"] ↦ emptyCtx')
    (l ↦ v) (l ↦ (v <|(context.backgroundCtx.emptyCtx') := emptyCtx'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End backgroundCtx.

Module todoCtx.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : context.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance todoCtx_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (context.todoCtx.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "emptyCtx" ∷ l.[(context.todoCtx.t), "emptyCtx"] ↦{dq} v.(context.todoCtx.emptyCtx') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance todoCtx_into_val_typed
   :
  IntoValTypedUnderlying (context.todoCtx.t) (context.todoCtxⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance todoCtx_access_load_emptyCtx l (v : (context.todoCtx.t)) dq :
  AccessStrict
    (l.[(context.todoCtx.t), "emptyCtx"] ↦{dq} (v.(context.todoCtx.emptyCtx')))
    (l.[(context.todoCtx.t), "emptyCtx"] ↦{dq} (v.(context.todoCtx.emptyCtx')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance todoCtx_access_store_emptyCtx l (v : (context.todoCtx.t)) emptyCtx' :
  AccessStrict
    (l.[(context.todoCtx.t), "emptyCtx"] ↦ (v.(context.todoCtx.emptyCtx')))
    (l.[(context.todoCtx.t), "emptyCtx"] ↦ emptyCtx')
    (l ↦ v) (l ↦ (v <|(context.todoCtx.emptyCtx') := emptyCtx'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End todoCtx.

Module cancelCtx.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : context.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance cancelCtx_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (context.cancelCtx.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "Context" ∷ l.[(context.cancelCtx.t), "Context"] ↦{dq} v.(context.cancelCtx.Context') ∗
      "mu" ∷ l.[(context.cancelCtx.t), "mu"] ↦{dq} v.(context.cancelCtx.mu') ∗
      "done" ∷ l.[(context.cancelCtx.t), "done"] ↦{dq} v.(context.cancelCtx.done') ∗
      "children" ∷ l.[(context.cancelCtx.t), "children"] ↦{dq} v.(context.cancelCtx.children') ∗
      "err" ∷ l.[(context.cancelCtx.t), "err"] ↦{dq} v.(context.cancelCtx.err') ∗
      "cause" ∷ l.[(context.cancelCtx.t), "cause"] ↦{dq} v.(context.cancelCtx.cause') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance cancelCtx_into_val_typed
   :
  IntoValTypedUnderlying (context.cancelCtx.t) (context.cancelCtxⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance cancelCtx_access_load_Context l (v : (context.cancelCtx.t)) dq :
  AccessStrict
    (l.[(context.cancelCtx.t), "Context"] ↦{dq} (v.(context.cancelCtx.Context')))
    (l.[(context.cancelCtx.t), "Context"] ↦{dq} (v.(context.cancelCtx.Context')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance cancelCtx_access_store_Context l (v : (context.cancelCtx.t)) Context' :
  AccessStrict
    (l.[(context.cancelCtx.t), "Context"] ↦ (v.(context.cancelCtx.Context')))
    (l.[(context.cancelCtx.t), "Context"] ↦ Context')
    (l ↦ v) (l ↦ (v <|(context.cancelCtx.Context') := Context'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance cancelCtx_access_load_mu l (v : (context.cancelCtx.t)) dq :
  AccessStrict
    (l.[(context.cancelCtx.t), "mu"] ↦{dq} (v.(context.cancelCtx.mu')))
    (l.[(context.cancelCtx.t), "mu"] ↦{dq} (v.(context.cancelCtx.mu')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance cancelCtx_access_store_mu l (v : (context.cancelCtx.t)) mu' :
  AccessStrict
    (l.[(context.cancelCtx.t), "mu"] ↦ (v.(context.cancelCtx.mu')))
    (l.[(context.cancelCtx.t), "mu"] ↦ mu')
    (l ↦ v) (l ↦ (v <|(context.cancelCtx.mu') := mu'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance cancelCtx_access_load_done l (v : (context.cancelCtx.t)) dq :
  AccessStrict
    (l.[(context.cancelCtx.t), "done"] ↦{dq} (v.(context.cancelCtx.done')))
    (l.[(context.cancelCtx.t), "done"] ↦{dq} (v.(context.cancelCtx.done')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance cancelCtx_access_store_done l (v : (context.cancelCtx.t)) done' :
  AccessStrict
    (l.[(context.cancelCtx.t), "done"] ↦ (v.(context.cancelCtx.done')))
    (l.[(context.cancelCtx.t), "done"] ↦ done')
    (l ↦ v) (l ↦ (v <|(context.cancelCtx.done') := done'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance cancelCtx_access_load_children l (v : (context.cancelCtx.t)) dq :
  AccessStrict
    (l.[(context.cancelCtx.t), "children"] ↦{dq} (v.(context.cancelCtx.children')))
    (l.[(context.cancelCtx.t), "children"] ↦{dq} (v.(context.cancelCtx.children')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance cancelCtx_access_store_children l (v : (context.cancelCtx.t)) children' :
  AccessStrict
    (l.[(context.cancelCtx.t), "children"] ↦ (v.(context.cancelCtx.children')))
    (l.[(context.cancelCtx.t), "children"] ↦ children')
    (l ↦ v) (l ↦ (v <|(context.cancelCtx.children') := children'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance cancelCtx_access_load_err l (v : (context.cancelCtx.t)) dq :
  AccessStrict
    (l.[(context.cancelCtx.t), "err"] ↦{dq} (v.(context.cancelCtx.err')))
    (l.[(context.cancelCtx.t), "err"] ↦{dq} (v.(context.cancelCtx.err')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance cancelCtx_access_store_err l (v : (context.cancelCtx.t)) err' :
  AccessStrict
    (l.[(context.cancelCtx.t), "err"] ↦ (v.(context.cancelCtx.err')))
    (l.[(context.cancelCtx.t), "err"] ↦ err')
    (l ↦ v) (l ↦ (v <|(context.cancelCtx.err') := err'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance cancelCtx_access_load_cause l (v : (context.cancelCtx.t)) dq :
  AccessStrict
    (l.[(context.cancelCtx.t), "cause"] ↦{dq} (v.(context.cancelCtx.cause')))
    (l.[(context.cancelCtx.t), "cause"] ↦{dq} (v.(context.cancelCtx.cause')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance cancelCtx_access_store_cause l (v : (context.cancelCtx.t)) cause' :
  AccessStrict
    (l.[(context.cancelCtx.t), "cause"] ↦ (v.(context.cancelCtx.cause')))
    (l.[(context.cancelCtx.t), "cause"] ↦ cause')
    (l ↦ v) (l ↦ (v <|(context.cancelCtx.cause') := cause'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End cancelCtx.

Module afterFuncCtx.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : context.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance afterFuncCtx_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (context.afterFuncCtx.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "cancelCtx" ∷ l.[(context.afterFuncCtx.t), "cancelCtx"] ↦{dq} v.(context.afterFuncCtx.cancelCtx') ∗
      "once" ∷ l.[(context.afterFuncCtx.t), "once"] ↦{dq} v.(context.afterFuncCtx.once') ∗
      "f" ∷ l.[(context.afterFuncCtx.t), "f"] ↦{dq} v.(context.afterFuncCtx.f') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance afterFuncCtx_into_val_typed
   :
  IntoValTypedUnderlying (context.afterFuncCtx.t) (context.afterFuncCtxⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance afterFuncCtx_access_load_cancelCtx l (v : (context.afterFuncCtx.t)) dq :
  AccessStrict
    (l.[(context.afterFuncCtx.t), "cancelCtx"] ↦{dq} (v.(context.afterFuncCtx.cancelCtx')))
    (l.[(context.afterFuncCtx.t), "cancelCtx"] ↦{dq} (v.(context.afterFuncCtx.cancelCtx')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance afterFuncCtx_access_store_cancelCtx l (v : (context.afterFuncCtx.t)) cancelCtx' :
  AccessStrict
    (l.[(context.afterFuncCtx.t), "cancelCtx"] ↦ (v.(context.afterFuncCtx.cancelCtx')))
    (l.[(context.afterFuncCtx.t), "cancelCtx"] ↦ cancelCtx')
    (l ↦ v) (l ↦ (v <|(context.afterFuncCtx.cancelCtx') := cancelCtx'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance afterFuncCtx_access_load_once l (v : (context.afterFuncCtx.t)) dq :
  AccessStrict
    (l.[(context.afterFuncCtx.t), "once"] ↦{dq} (v.(context.afterFuncCtx.once')))
    (l.[(context.afterFuncCtx.t), "once"] ↦{dq} (v.(context.afterFuncCtx.once')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance afterFuncCtx_access_store_once l (v : (context.afterFuncCtx.t)) once' :
  AccessStrict
    (l.[(context.afterFuncCtx.t), "once"] ↦ (v.(context.afterFuncCtx.once')))
    (l.[(context.afterFuncCtx.t), "once"] ↦ once')
    (l ↦ v) (l ↦ (v <|(context.afterFuncCtx.once') := once'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance afterFuncCtx_access_load_f l (v : (context.afterFuncCtx.t)) dq :
  AccessStrict
    (l.[(context.afterFuncCtx.t), "f"] ↦{dq} (v.(context.afterFuncCtx.f')))
    (l.[(context.afterFuncCtx.t), "f"] ↦{dq} (v.(context.afterFuncCtx.f')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance afterFuncCtx_access_store_f l (v : (context.afterFuncCtx.t)) f' :
  AccessStrict
    (l.[(context.afterFuncCtx.t), "f"] ↦ (v.(context.afterFuncCtx.f')))
    (l.[(context.afterFuncCtx.t), "f"] ↦ f')
    (l ↦ v) (l ↦ (v <|(context.afterFuncCtx.f') := f'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End afterFuncCtx.

Module stopCtx.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : context.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance stopCtx_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (context.stopCtx.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "Context" ∷ l.[(context.stopCtx.t), "Context"] ↦{dq} v.(context.stopCtx.Context') ∗
      "stop" ∷ l.[(context.stopCtx.t), "stop"] ↦{dq} v.(context.stopCtx.stop') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance stopCtx_into_val_typed
   :
  IntoValTypedUnderlying (context.stopCtx.t) (context.stopCtxⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance stopCtx_access_load_Context l (v : (context.stopCtx.t)) dq :
  AccessStrict
    (l.[(context.stopCtx.t), "Context"] ↦{dq} (v.(context.stopCtx.Context')))
    (l.[(context.stopCtx.t), "Context"] ↦{dq} (v.(context.stopCtx.Context')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance stopCtx_access_store_Context l (v : (context.stopCtx.t)) Context' :
  AccessStrict
    (l.[(context.stopCtx.t), "Context"] ↦ (v.(context.stopCtx.Context')))
    (l.[(context.stopCtx.t), "Context"] ↦ Context')
    (l ↦ v) (l ↦ (v <|(context.stopCtx.Context') := Context'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance stopCtx_access_load_stop l (v : (context.stopCtx.t)) dq :
  AccessStrict
    (l.[(context.stopCtx.t), "stop"] ↦{dq} (v.(context.stopCtx.stop')))
    (l.[(context.stopCtx.t), "stop"] ↦{dq} (v.(context.stopCtx.stop')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance stopCtx_access_store_stop l (v : (context.stopCtx.t)) stop' :
  AccessStrict
    (l.[(context.stopCtx.t), "stop"] ↦ (v.(context.stopCtx.stop')))
    (l.[(context.stopCtx.t), "stop"] ↦ stop')
    (l ↦ v) (l ↦ (v <|(context.stopCtx.stop') := stop'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End stopCtx.

Module withoutCancelCtx.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : context.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance withoutCancelCtx_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (context.withoutCancelCtx.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "c" ∷ l.[(context.withoutCancelCtx.t), "c"] ↦{dq} v.(context.withoutCancelCtx.c') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance withoutCancelCtx_into_val_typed
   :
  IntoValTypedUnderlying (context.withoutCancelCtx.t) (context.withoutCancelCtxⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance withoutCancelCtx_access_load_c l (v : (context.withoutCancelCtx.t)) dq :
  AccessStrict
    (l.[(context.withoutCancelCtx.t), "c"] ↦{dq} (v.(context.withoutCancelCtx.c')))
    (l.[(context.withoutCancelCtx.t), "c"] ↦{dq} (v.(context.withoutCancelCtx.c')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance withoutCancelCtx_access_store_c l (v : (context.withoutCancelCtx.t)) c' :
  AccessStrict
    (l.[(context.withoutCancelCtx.t), "c"] ↦ (v.(context.withoutCancelCtx.c')))
    (l.[(context.withoutCancelCtx.t), "c"] ↦ c')
    (l ↦ v) (l ↦ (v <|(context.withoutCancelCtx.c') := c'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End withoutCancelCtx.

Module timerCtx.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : context.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance timerCtx_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (context.timerCtx.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "cancelCtx" ∷ l.[(context.timerCtx.t), "cancelCtx"] ↦{dq} v.(context.timerCtx.cancelCtx') ∗
      "timer" ∷ l.[(context.timerCtx.t), "timer"] ↦{dq} v.(context.timerCtx.timer') ∗
      "deadline" ∷ l.[(context.timerCtx.t), "deadline"] ↦{dq} v.(context.timerCtx.deadline') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance timerCtx_into_val_typed
   :
  IntoValTypedUnderlying (context.timerCtx.t) (context.timerCtxⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance timerCtx_access_load_cancelCtx l (v : (context.timerCtx.t)) dq :
  AccessStrict
    (l.[(context.timerCtx.t), "cancelCtx"] ↦{dq} (v.(context.timerCtx.cancelCtx')))
    (l.[(context.timerCtx.t), "cancelCtx"] ↦{dq} (v.(context.timerCtx.cancelCtx')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance timerCtx_access_store_cancelCtx l (v : (context.timerCtx.t)) cancelCtx' :
  AccessStrict
    (l.[(context.timerCtx.t), "cancelCtx"] ↦ (v.(context.timerCtx.cancelCtx')))
    (l.[(context.timerCtx.t), "cancelCtx"] ↦ cancelCtx')
    (l ↦ v) (l ↦ (v <|(context.timerCtx.cancelCtx') := cancelCtx'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance timerCtx_access_load_timer l (v : (context.timerCtx.t)) dq :
  AccessStrict
    (l.[(context.timerCtx.t), "timer"] ↦{dq} (v.(context.timerCtx.timer')))
    (l.[(context.timerCtx.t), "timer"] ↦{dq} (v.(context.timerCtx.timer')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance timerCtx_access_store_timer l (v : (context.timerCtx.t)) timer' :
  AccessStrict
    (l.[(context.timerCtx.t), "timer"] ↦ (v.(context.timerCtx.timer')))
    (l.[(context.timerCtx.t), "timer"] ↦ timer')
    (l ↦ v) (l ↦ (v <|(context.timerCtx.timer') := timer'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance timerCtx_access_load_deadline l (v : (context.timerCtx.t)) dq :
  AccessStrict
    (l.[(context.timerCtx.t), "deadline"] ↦{dq} (v.(context.timerCtx.deadline')))
    (l.[(context.timerCtx.t), "deadline"] ↦{dq} (v.(context.timerCtx.deadline')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance timerCtx_access_store_deadline l (v : (context.timerCtx.t)) deadline' :
  AccessStrict
    (l.[(context.timerCtx.t), "deadline"] ↦ (v.(context.timerCtx.deadline')))
    (l.[(context.timerCtx.t), "deadline"] ↦ deadline')
    (l ↦ v) (l ↦ (v <|(context.timerCtx.deadline') := deadline'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End timerCtx.

Module valueCtx.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : context.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance valueCtx_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (context.valueCtx.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "Context" ∷ l.[(context.valueCtx.t), "Context"] ↦{dq} v.(context.valueCtx.Context') ∗
      "key" ∷ l.[(context.valueCtx.t), "key"] ↦{dq} v.(context.valueCtx.key') ∗
      "val" ∷ l.[(context.valueCtx.t), "val"] ↦{dq} v.(context.valueCtx.val') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance valueCtx_into_val_typed
   :
  IntoValTypedUnderlying (context.valueCtx.t) (context.valueCtxⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance valueCtx_access_load_Context l (v : (context.valueCtx.t)) dq :
  AccessStrict
    (l.[(context.valueCtx.t), "Context"] ↦{dq} (v.(context.valueCtx.Context')))
    (l.[(context.valueCtx.t), "Context"] ↦{dq} (v.(context.valueCtx.Context')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance valueCtx_access_store_Context l (v : (context.valueCtx.t)) Context' :
  AccessStrict
    (l.[(context.valueCtx.t), "Context"] ↦ (v.(context.valueCtx.Context')))
    (l.[(context.valueCtx.t), "Context"] ↦ Context')
    (l ↦ v) (l ↦ (v <|(context.valueCtx.Context') := Context'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance valueCtx_access_load_key l (v : (context.valueCtx.t)) dq :
  AccessStrict
    (l.[(context.valueCtx.t), "key"] ↦{dq} (v.(context.valueCtx.key')))
    (l.[(context.valueCtx.t), "key"] ↦{dq} (v.(context.valueCtx.key')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance valueCtx_access_store_key l (v : (context.valueCtx.t)) key' :
  AccessStrict
    (l.[(context.valueCtx.t), "key"] ↦ (v.(context.valueCtx.key')))
    (l.[(context.valueCtx.t), "key"] ↦ key')
    (l ↦ v) (l ↦ (v <|(context.valueCtx.key') := key'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance valueCtx_access_load_val l (v : (context.valueCtx.t)) dq :
  AccessStrict
    (l.[(context.valueCtx.t), "val"] ↦{dq} (v.(context.valueCtx.val')))
    (l.[(context.valueCtx.t), "val"] ↦{dq} (v.(context.valueCtx.val')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance valueCtx_access_store_val l (v : (context.valueCtx.t)) val' :
  AccessStrict
    (l.[(context.valueCtx.t), "val"] ↦ (v.(context.valueCtx.val')))
    (l.[(context.valueCtx.t), "val"] ↦ val')
    (l ↦ v) (l ↦ (v <|(context.valueCtx.val') := val'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End valueCtx.

End context.
