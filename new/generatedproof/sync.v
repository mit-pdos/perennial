(* autogenerated by goose proofgen; do not modify *)
Require Export New.proof.proof_prelude.
Require Export New.manualproof.sync.
Require Export New.generatedproof.internal.race.
Require Export New.generatedproof.internal.synctest.
Require Export New.generatedproof.sync.atomic.
Require Export New.golang.theory.
Require Export New.code.sync.

Set Default Proof Using "Type".

Module sync.
Module noCopy.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : sync.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance noCopy_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (sync.noCopy.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance noCopy_into_val_typed
   :
  IntoValTyped (sync.noCopy.t) (sync.noCopy).
Proof. solve_into_val_typed_struct. Qed.

End def.
End noCopy.

Module notifyList.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : sync.Assumptions}.

Local Set Default Proof Using "All".

#[global] Instance notifyList_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (sync.notifyList.t). Admitted.

#[global] Instance notifyList_into_val_typed
   :
  IntoValTyped (sync.notifyList.t) (sync.notifyList).
Proof. Admitted.

End def.
End notifyList.

Module copyChecker.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : sync.Assumptions}.

Local Set Default Proof Using "All".

#[global] Instance copyChecker_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (sync.copyChecker.t). Admitted.

#[global] Instance copyChecker_into_val_typed
   :
  IntoValTyped (sync.copyChecker.t) (sync.copyChecker).
Proof. Admitted.

End def.
End copyChecker.

Module Cond.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : sync.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance Cond_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (sync.Cond.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "noCopy" ∷ l.[(sync.Cond.t), "noCopy"] ↦{dq} v.(sync.Cond.noCopy') ∗
      "L" ∷ l.[(sync.Cond.t), "L"] ↦{dq} v.(sync.Cond.L') ∗
      "notify" ∷ l.[(sync.Cond.t), "notify"] ↦{dq} v.(sync.Cond.notify') ∗
      "checker" ∷ l.[(sync.Cond.t), "checker"] ↦{dq} v.(sync.Cond.checker') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance Cond_into_val_typed
   :
  IntoValTyped (sync.Cond.t) (sync.Cond).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance Cond_access_noCopy l (v : (sync.Cond.t)) dq :
  PointsToAccess
    (l.[(sync.Cond.t), "noCopy"]) (v.(sync.Cond.noCopy')) dq
    (l ↦{dq} v) (λ noCopy', l ↦{dq} (v <|(sync.Cond.noCopy') := noCopy'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Cond_access_L l (v : (sync.Cond.t)) dq :
  PointsToAccess
    (l.[(sync.Cond.t), "L"]) (v.(sync.Cond.L')) dq
    (l ↦{dq} v) (λ L', l ↦{dq} (v <|(sync.Cond.L') := L'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Cond_access_notify l (v : (sync.Cond.t)) dq :
  PointsToAccess
    (l.[(sync.Cond.t), "notify"]) (v.(sync.Cond.notify')) dq
    (l ↦{dq} v) (λ notify', l ↦{dq} (v <|(sync.Cond.notify') := notify'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Cond_access_checker l (v : (sync.Cond.t)) dq :
  PointsToAccess
    (l.[(sync.Cond.t), "checker"]) (v.(sync.Cond.checker')) dq
    (l ↦{dq} v) (λ checker', l ↦{dq} (v <|(sync.Cond.checker') := checker'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End Cond.

Module Map.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : sync.Assumptions}.

Local Set Default Proof Using "All".

#[global] Instance Map_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (sync.Map.t). Admitted.

#[global] Instance Map_into_val_typed
   :
  IntoValTyped (sync.Map.t) (sync.Map).
Proof. Admitted.

End def.
End Map.

Module readOnly.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : sync.Assumptions}.

Local Set Default Proof Using "All".

#[global] Instance readOnly_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (sync.readOnly.t). Admitted.

#[global] Instance readOnly_into_val_typed
   :
  IntoValTyped (sync.readOnly.t) (sync.readOnly).
Proof. Admitted.

End def.
End readOnly.

Module entry.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : sync.Assumptions}.

Local Set Default Proof Using "All".

#[global] Instance entry_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (sync.entry.t). Admitted.

#[global] Instance entry_into_val_typed
   :
  IntoValTyped (sync.entry.t) (sync.entry).
Proof. Admitted.

End def.
End entry.

Module Once.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : sync.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance Once_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (sync.Once.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "_0" ∷ l.[(sync.Once.t), "_0"] ↦{dq} v.(sync.Once._0') ∗
      "done" ∷ l.[(sync.Once.t), "done"] ↦{dq} v.(sync.Once.done') ∗
      "m" ∷ l.[(sync.Once.t), "m"] ↦{dq} v.(sync.Once.m') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance Once_into_val_typed
   :
  IntoValTyped (sync.Once.t) (sync.Once).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance Once_access__0 l (v : (sync.Once.t)) dq :
  PointsToAccess
    (l.[(sync.Once.t), "_0"]) (v.(sync.Once._0')) dq
    (l ↦{dq} v) (λ _0', l ↦{dq} (v <|(sync.Once._0') := _0'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Once_access_done l (v : (sync.Once.t)) dq :
  PointsToAccess
    (l.[(sync.Once.t), "done"]) (v.(sync.Once.done')) dq
    (l ↦{dq} v) (λ done', l ↦{dq} (v <|(sync.Once.done') := done'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Once_access_m l (v : (sync.Once.t)) dq :
  PointsToAccess
    (l.[(sync.Once.t), "m"]) (v.(sync.Once.m')) dq
    (l ↦{dq} v) (λ m', l ↦{dq} (v <|(sync.Once.m') := m'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End Once.

Module Pool.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : sync.Assumptions}.

Local Set Default Proof Using "All".

#[global] Instance Pool_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (sync.Pool.t). Admitted.

#[global] Instance Pool_into_val_typed
   :
  IntoValTyped (sync.Pool.t) (sync.Pool).
Proof. Admitted.

End def.
End Pool.

Module poolLocalInternal.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : sync.Assumptions}.

Local Set Default Proof Using "All".

#[global] Instance poolLocalInternal_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (sync.poolLocalInternal.t). Admitted.

#[global] Instance poolLocalInternal_into_val_typed
   :
  IntoValTyped (sync.poolLocalInternal.t) (sync.poolLocalInternal).
Proof. Admitted.

End def.
End poolLocalInternal.

Module poolLocal.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : sync.Assumptions}.

Local Set Default Proof Using "All".

#[global] Instance poolLocal_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (sync.poolLocal.t). Admitted.

#[global] Instance poolLocal_into_val_typed
   :
  IntoValTyped (sync.poolLocal.t) (sync.poolLocal).
Proof. Admitted.

End def.
End poolLocal.

Module poolDequeue.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : sync.Assumptions}.

Local Set Default Proof Using "All".

#[global] Instance poolDequeue_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (sync.poolDequeue.t). Admitted.

#[global] Instance poolDequeue_into_val_typed
   :
  IntoValTyped (sync.poolDequeue.t) (sync.poolDequeue).
Proof. Admitted.

End def.
End poolDequeue.

Module eface.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : sync.Assumptions}.

Local Set Default Proof Using "All".

#[global] Instance eface_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (sync.eface.t). Admitted.

#[global] Instance eface_into_val_typed
   :
  IntoValTyped (sync.eface.t) (sync.eface).
Proof. Admitted.

End def.
End eface.

Module dequeueNil.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : sync.Assumptions}.

Local Set Default Proof Using "All".

#[global] Instance dequeueNil_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (sync.dequeueNil.t). Admitted.

#[global] Instance dequeueNil_into_val_typed
   :
  IntoValTyped (sync.dequeueNil.t) (sync.dequeueNil).
Proof. Admitted.

End def.
End dequeueNil.

Module poolChain.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : sync.Assumptions}.

Local Set Default Proof Using "All".

#[global] Instance poolChain_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (sync.poolChain.t). Admitted.

#[global] Instance poolChain_into_val_typed
   :
  IntoValTyped (sync.poolChain.t) (sync.poolChain).
Proof. Admitted.

End def.
End poolChain.

Module poolChainElt.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : sync.Assumptions}.

Local Set Default Proof Using "All".

#[global] Instance poolChainElt_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (sync.poolChainElt.t). Admitted.

#[global] Instance poolChainElt_into_val_typed
   :
  IntoValTyped (sync.poolChainElt.t) (sync.poolChainElt).
Proof. Admitted.

End def.
End poolChainElt.

Module RWMutex.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : sync.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance RWMutex_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (sync.RWMutex.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "w" ∷ l.[(sync.RWMutex.t), "w"] ↦{dq} v.(sync.RWMutex.w') ∗
      "writerSem" ∷ l.[(sync.RWMutex.t), "writerSem"] ↦{dq} v.(sync.RWMutex.writerSem') ∗
      "readerSem" ∷ l.[(sync.RWMutex.t), "readerSem"] ↦{dq} v.(sync.RWMutex.readerSem') ∗
      "readerCount" ∷ l.[(sync.RWMutex.t), "readerCount"] ↦{dq} v.(sync.RWMutex.readerCount') ∗
      "readerWait" ∷ l.[(sync.RWMutex.t), "readerWait"] ↦{dq} v.(sync.RWMutex.readerWait') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance RWMutex_into_val_typed
   :
  IntoValTyped (sync.RWMutex.t) (sync.RWMutex).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance RWMutex_access_w l (v : (sync.RWMutex.t)) dq :
  PointsToAccess
    (l.[(sync.RWMutex.t), "w"]) (v.(sync.RWMutex.w')) dq
    (l ↦{dq} v) (λ w', l ↦{dq} (v <|(sync.RWMutex.w') := w'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance RWMutex_access_writerSem l (v : (sync.RWMutex.t)) dq :
  PointsToAccess
    (l.[(sync.RWMutex.t), "writerSem"]) (v.(sync.RWMutex.writerSem')) dq
    (l ↦{dq} v) (λ writerSem', l ↦{dq} (v <|(sync.RWMutex.writerSem') := writerSem'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance RWMutex_access_readerSem l (v : (sync.RWMutex.t)) dq :
  PointsToAccess
    (l.[(sync.RWMutex.t), "readerSem"]) (v.(sync.RWMutex.readerSem')) dq
    (l ↦{dq} v) (λ readerSem', l ↦{dq} (v <|(sync.RWMutex.readerSem') := readerSem'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance RWMutex_access_readerCount l (v : (sync.RWMutex.t)) dq :
  PointsToAccess
    (l.[(sync.RWMutex.t), "readerCount"]) (v.(sync.RWMutex.readerCount')) dq
    (l ↦{dq} v) (λ readerCount', l ↦{dq} (v <|(sync.RWMutex.readerCount') := readerCount'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance RWMutex_access_readerWait l (v : (sync.RWMutex.t)) dq :
  PointsToAccess
    (l.[(sync.RWMutex.t), "readerWait"]) (v.(sync.RWMutex.readerWait')) dq
    (l ↦{dq} v) (λ readerWait', l ↦{dq} (v <|(sync.RWMutex.readerWait') := readerWait'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End RWMutex.

Module WaitGroup.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : sync.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance WaitGroup_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (sync.WaitGroup.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "noCopy" ∷ l.[(sync.WaitGroup.t), "noCopy"] ↦{dq} v.(sync.WaitGroup.noCopy') ∗
      "state" ∷ l.[(sync.WaitGroup.t), "state"] ↦{dq} v.(sync.WaitGroup.state') ∗
      "sema" ∷ l.[(sync.WaitGroup.t), "sema"] ↦{dq} v.(sync.WaitGroup.sema') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance WaitGroup_into_val_typed
   :
  IntoValTyped (sync.WaitGroup.t) (sync.WaitGroup).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance WaitGroup_access_noCopy l (v : (sync.WaitGroup.t)) dq :
  PointsToAccess
    (l.[(sync.WaitGroup.t), "noCopy"]) (v.(sync.WaitGroup.noCopy')) dq
    (l ↦{dq} v) (λ noCopy', l ↦{dq} (v <|(sync.WaitGroup.noCopy') := noCopy'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance WaitGroup_access_state l (v : (sync.WaitGroup.t)) dq :
  PointsToAccess
    (l.[(sync.WaitGroup.t), "state"]) (v.(sync.WaitGroup.state')) dq
    (l ↦{dq} v) (λ state', l ↦{dq} (v <|(sync.WaitGroup.state') := state'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance WaitGroup_access_sema l (v : (sync.WaitGroup.t)) dq :
  PointsToAccess
    (l.[(sync.WaitGroup.t), "sema"]) (v.(sync.WaitGroup.sema')) dq
    (l ↦{dq} v) (λ sema', l ↦{dq} (v <|(sync.WaitGroup.sema') := sema'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End WaitGroup.

End sync.
