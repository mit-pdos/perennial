(* autogenerated by goose proofgen; do not modify *)
Require Export New.proof.proof_prelude.
Require Export New.manualproof.sync.
Require Export New.generatedproof.internal.race.
Require Export New.generatedproof.internal.synctest.
Require Export New.generatedproof.sync.atomic.
Require Export New.golang.theory.
Require Export New.code.sync.

Set Default Proof Using "Type".

Module sync.
Module noCopy.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : sync.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance noCopy_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (sync.noCopy.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance noCopy_into_val_typed
   :
  IntoValTyped (sync.noCopy.t) (sync.noCopy).
Proof. solve_into_val_typed_struct. Qed.

End def.
End noCopy.

Module notifyList.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : sync.Assumptions}.

Local Set Default Proof Using "All".

#[global] Instance notifyList_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (sync.notifyList.t). Admitted.

#[global] Instance notifyList_into_val_typed
   :
  IntoValTyped (sync.notifyList.t) (sync.notifyList).
Proof. Admitted.

End def.
End notifyList.

Module copyChecker.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : sync.Assumptions}.

Local Set Default Proof Using "All".

#[global] Instance copyChecker_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (sync.copyChecker.t). Admitted.

#[global] Instance copyChecker_into_val_typed
   :
  IntoValTyped (sync.copyChecker.t) (sync.copyChecker).
Proof. Admitted.

End def.
End copyChecker.

Module Cond.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : sync.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance Cond_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (sync.Cond.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "noCopy" ∷ l.[(sync.Cond.t), "noCopy"] ↦{dq} v.(sync.Cond.noCopy') ∗
      "L" ∷ l.[(sync.Cond.t), "L"] ↦{dq} v.(sync.Cond.L') ∗
      "notify" ∷ l.[(sync.Cond.t), "notify"] ↦{dq} v.(sync.Cond.notify') ∗
      "checker" ∷ l.[(sync.Cond.t), "checker"] ↦{dq} v.(sync.Cond.checker') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance Cond_into_val_typed
   :
  IntoValTyped (sync.Cond.t) (sync.Cond).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance Cond_access_load_noCopy l (v : (sync.Cond.t)) dq :
  AccessStrict
    (l.[(sync.Cond.t), "noCopy"] ↦{dq} (v.(sync.Cond.noCopy')))
    (l.[(sync.Cond.t), "noCopy"] ↦{dq} (v.(sync.Cond.noCopy')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Cond_access_store_noCopy l (v : (sync.Cond.t)) noCopy' :
  AccessStrict
    (l.[(sync.Cond.t), "noCopy"] ↦ (v.(sync.Cond.noCopy')))
    (l.[(sync.Cond.t), "noCopy"] ↦ noCopy')
    (l ↦ v) (l ↦ (v <|(sync.Cond.noCopy') := noCopy'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Cond_access_load_L l (v : (sync.Cond.t)) dq :
  AccessStrict
    (l.[(sync.Cond.t), "L"] ↦{dq} (v.(sync.Cond.L')))
    (l.[(sync.Cond.t), "L"] ↦{dq} (v.(sync.Cond.L')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Cond_access_store_L l (v : (sync.Cond.t)) L' :
  AccessStrict
    (l.[(sync.Cond.t), "L"] ↦ (v.(sync.Cond.L')))
    (l.[(sync.Cond.t), "L"] ↦ L')
    (l ↦ v) (l ↦ (v <|(sync.Cond.L') := L'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Cond_access_load_notify l (v : (sync.Cond.t)) dq :
  AccessStrict
    (l.[(sync.Cond.t), "notify"] ↦{dq} (v.(sync.Cond.notify')))
    (l.[(sync.Cond.t), "notify"] ↦{dq} (v.(sync.Cond.notify')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Cond_access_store_notify l (v : (sync.Cond.t)) notify' :
  AccessStrict
    (l.[(sync.Cond.t), "notify"] ↦ (v.(sync.Cond.notify')))
    (l.[(sync.Cond.t), "notify"] ↦ notify')
    (l ↦ v) (l ↦ (v <|(sync.Cond.notify') := notify'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Cond_access_load_checker l (v : (sync.Cond.t)) dq :
  AccessStrict
    (l.[(sync.Cond.t), "checker"] ↦{dq} (v.(sync.Cond.checker')))
    (l.[(sync.Cond.t), "checker"] ↦{dq} (v.(sync.Cond.checker')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Cond_access_store_checker l (v : (sync.Cond.t)) checker' :
  AccessStrict
    (l.[(sync.Cond.t), "checker"] ↦ (v.(sync.Cond.checker')))
    (l.[(sync.Cond.t), "checker"] ↦ checker')
    (l ↦ v) (l ↦ (v <|(sync.Cond.checker') := checker'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End Cond.

Module Map.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : sync.Assumptions}.

Local Set Default Proof Using "All".

#[global] Instance Map_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (sync.Map.t). Admitted.

#[global] Instance Map_into_val_typed
   :
  IntoValTyped (sync.Map.t) (sync.Map).
Proof. Admitted.

End def.
End Map.

Module readOnly.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : sync.Assumptions}.

Local Set Default Proof Using "All".

#[global] Instance readOnly_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (sync.readOnly.t). Admitted.

#[global] Instance readOnly_into_val_typed
   :
  IntoValTyped (sync.readOnly.t) (sync.readOnly).
Proof. Admitted.

End def.
End readOnly.

Module entry.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : sync.Assumptions}.

Local Set Default Proof Using "All".

#[global] Instance entry_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (sync.entry.t). Admitted.

#[global] Instance entry_into_val_typed
   :
  IntoValTyped (sync.entry.t) (sync.entry).
Proof. Admitted.

End def.
End entry.

Module Once.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : sync.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance Once_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (sync.Once.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "_0" ∷ l.[(sync.Once.t), "_0"] ↦{dq} v.(sync.Once._0') ∗
      "done" ∷ l.[(sync.Once.t), "done"] ↦{dq} v.(sync.Once.done') ∗
      "m" ∷ l.[(sync.Once.t), "m"] ↦{dq} v.(sync.Once.m') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance Once_into_val_typed
   :
  IntoValTyped (sync.Once.t) (sync.Once).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance Once_access_load__0 l (v : (sync.Once.t)) dq :
  AccessStrict
    (l.[(sync.Once.t), "_0"] ↦{dq} (v.(sync.Once._0')))
    (l.[(sync.Once.t), "_0"] ↦{dq} (v.(sync.Once._0')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Once_access_store__0 l (v : (sync.Once.t)) _0' :
  AccessStrict
    (l.[(sync.Once.t), "_0"] ↦ (v.(sync.Once._0')))
    (l.[(sync.Once.t), "_0"] ↦ _0')
    (l ↦ v) (l ↦ (v <|(sync.Once._0') := _0'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Once_access_load_done l (v : (sync.Once.t)) dq :
  AccessStrict
    (l.[(sync.Once.t), "done"] ↦{dq} (v.(sync.Once.done')))
    (l.[(sync.Once.t), "done"] ↦{dq} (v.(sync.Once.done')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Once_access_store_done l (v : (sync.Once.t)) done' :
  AccessStrict
    (l.[(sync.Once.t), "done"] ↦ (v.(sync.Once.done')))
    (l.[(sync.Once.t), "done"] ↦ done')
    (l ↦ v) (l ↦ (v <|(sync.Once.done') := done'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Once_access_load_m l (v : (sync.Once.t)) dq :
  AccessStrict
    (l.[(sync.Once.t), "m"] ↦{dq} (v.(sync.Once.m')))
    (l.[(sync.Once.t), "m"] ↦{dq} (v.(sync.Once.m')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Once_access_store_m l (v : (sync.Once.t)) m' :
  AccessStrict
    (l.[(sync.Once.t), "m"] ↦ (v.(sync.Once.m')))
    (l.[(sync.Once.t), "m"] ↦ m')
    (l ↦ v) (l ↦ (v <|(sync.Once.m') := m'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End Once.

Module Pool.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : sync.Assumptions}.

Local Set Default Proof Using "All".

#[global] Instance Pool_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (sync.Pool.t). Admitted.

#[global] Instance Pool_into_val_typed
   :
  IntoValTyped (sync.Pool.t) (sync.Pool).
Proof. Admitted.

End def.
End Pool.

Module poolLocalInternal.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : sync.Assumptions}.

Local Set Default Proof Using "All".

#[global] Instance poolLocalInternal_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (sync.poolLocalInternal.t). Admitted.

#[global] Instance poolLocalInternal_into_val_typed
   :
  IntoValTyped (sync.poolLocalInternal.t) (sync.poolLocalInternal).
Proof. Admitted.

End def.
End poolLocalInternal.

Module poolLocal.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : sync.Assumptions}.

Local Set Default Proof Using "All".

#[global] Instance poolLocal_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (sync.poolLocal.t). Admitted.

#[global] Instance poolLocal_into_val_typed
   :
  IntoValTyped (sync.poolLocal.t) (sync.poolLocal).
Proof. Admitted.

End def.
End poolLocal.

Module poolDequeue.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : sync.Assumptions}.

Local Set Default Proof Using "All".

#[global] Instance poolDequeue_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (sync.poolDequeue.t). Admitted.

#[global] Instance poolDequeue_into_val_typed
   :
  IntoValTyped (sync.poolDequeue.t) (sync.poolDequeue).
Proof. Admitted.

End def.
End poolDequeue.

Module eface.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : sync.Assumptions}.

Local Set Default Proof Using "All".

#[global] Instance eface_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (sync.eface.t). Admitted.

#[global] Instance eface_into_val_typed
   :
  IntoValTyped (sync.eface.t) (sync.eface).
Proof. Admitted.

End def.
End eface.

Module dequeueNil.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : sync.Assumptions}.

Local Set Default Proof Using "All".

#[global] Instance dequeueNil_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (sync.dequeueNil.t). Admitted.

#[global] Instance dequeueNil_into_val_typed
   :
  IntoValTyped (sync.dequeueNil.t) (sync.dequeueNil).
Proof. Admitted.

End def.
End dequeueNil.

Module poolChain.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : sync.Assumptions}.

Local Set Default Proof Using "All".

#[global] Instance poolChain_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (sync.poolChain.t). Admitted.

#[global] Instance poolChain_into_val_typed
   :
  IntoValTyped (sync.poolChain.t) (sync.poolChain).
Proof. Admitted.

End def.
End poolChain.

Module poolChainElt.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : sync.Assumptions}.

Local Set Default Proof Using "All".

#[global] Instance poolChainElt_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (sync.poolChainElt.t). Admitted.

#[global] Instance poolChainElt_into_val_typed
   :
  IntoValTyped (sync.poolChainElt.t) (sync.poolChainElt).
Proof. Admitted.

End def.
End poolChainElt.

Module RWMutex.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : sync.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance RWMutex_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (sync.RWMutex.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "w" ∷ l.[(sync.RWMutex.t), "w"] ↦{dq} v.(sync.RWMutex.w') ∗
      "writerSem" ∷ l.[(sync.RWMutex.t), "writerSem"] ↦{dq} v.(sync.RWMutex.writerSem') ∗
      "readerSem" ∷ l.[(sync.RWMutex.t), "readerSem"] ↦{dq} v.(sync.RWMutex.readerSem') ∗
      "readerCount" ∷ l.[(sync.RWMutex.t), "readerCount"] ↦{dq} v.(sync.RWMutex.readerCount') ∗
      "readerWait" ∷ l.[(sync.RWMutex.t), "readerWait"] ↦{dq} v.(sync.RWMutex.readerWait') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance RWMutex_into_val_typed
   :
  IntoValTyped (sync.RWMutex.t) (sync.RWMutex).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance RWMutex_access_load_w l (v : (sync.RWMutex.t)) dq :
  AccessStrict
    (l.[(sync.RWMutex.t), "w"] ↦{dq} (v.(sync.RWMutex.w')))
    (l.[(sync.RWMutex.t), "w"] ↦{dq} (v.(sync.RWMutex.w')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance RWMutex_access_store_w l (v : (sync.RWMutex.t)) w' :
  AccessStrict
    (l.[(sync.RWMutex.t), "w"] ↦ (v.(sync.RWMutex.w')))
    (l.[(sync.RWMutex.t), "w"] ↦ w')
    (l ↦ v) (l ↦ (v <|(sync.RWMutex.w') := w'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance RWMutex_access_load_writerSem l (v : (sync.RWMutex.t)) dq :
  AccessStrict
    (l.[(sync.RWMutex.t), "writerSem"] ↦{dq} (v.(sync.RWMutex.writerSem')))
    (l.[(sync.RWMutex.t), "writerSem"] ↦{dq} (v.(sync.RWMutex.writerSem')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance RWMutex_access_store_writerSem l (v : (sync.RWMutex.t)) writerSem' :
  AccessStrict
    (l.[(sync.RWMutex.t), "writerSem"] ↦ (v.(sync.RWMutex.writerSem')))
    (l.[(sync.RWMutex.t), "writerSem"] ↦ writerSem')
    (l ↦ v) (l ↦ (v <|(sync.RWMutex.writerSem') := writerSem'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance RWMutex_access_load_readerSem l (v : (sync.RWMutex.t)) dq :
  AccessStrict
    (l.[(sync.RWMutex.t), "readerSem"] ↦{dq} (v.(sync.RWMutex.readerSem')))
    (l.[(sync.RWMutex.t), "readerSem"] ↦{dq} (v.(sync.RWMutex.readerSem')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance RWMutex_access_store_readerSem l (v : (sync.RWMutex.t)) readerSem' :
  AccessStrict
    (l.[(sync.RWMutex.t), "readerSem"] ↦ (v.(sync.RWMutex.readerSem')))
    (l.[(sync.RWMutex.t), "readerSem"] ↦ readerSem')
    (l ↦ v) (l ↦ (v <|(sync.RWMutex.readerSem') := readerSem'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance RWMutex_access_load_readerCount l (v : (sync.RWMutex.t)) dq :
  AccessStrict
    (l.[(sync.RWMutex.t), "readerCount"] ↦{dq} (v.(sync.RWMutex.readerCount')))
    (l.[(sync.RWMutex.t), "readerCount"] ↦{dq} (v.(sync.RWMutex.readerCount')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance RWMutex_access_store_readerCount l (v : (sync.RWMutex.t)) readerCount' :
  AccessStrict
    (l.[(sync.RWMutex.t), "readerCount"] ↦ (v.(sync.RWMutex.readerCount')))
    (l.[(sync.RWMutex.t), "readerCount"] ↦ readerCount')
    (l ↦ v) (l ↦ (v <|(sync.RWMutex.readerCount') := readerCount'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance RWMutex_access_load_readerWait l (v : (sync.RWMutex.t)) dq :
  AccessStrict
    (l.[(sync.RWMutex.t), "readerWait"] ↦{dq} (v.(sync.RWMutex.readerWait')))
    (l.[(sync.RWMutex.t), "readerWait"] ↦{dq} (v.(sync.RWMutex.readerWait')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance RWMutex_access_store_readerWait l (v : (sync.RWMutex.t)) readerWait' :
  AccessStrict
    (l.[(sync.RWMutex.t), "readerWait"] ↦ (v.(sync.RWMutex.readerWait')))
    (l.[(sync.RWMutex.t), "readerWait"] ↦ readerWait')
    (l ↦ v) (l ↦ (v <|(sync.RWMutex.readerWait') := readerWait'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End RWMutex.

Module WaitGroup.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : sync.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance WaitGroup_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (sync.WaitGroup.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "noCopy" ∷ l.[(sync.WaitGroup.t), "noCopy"] ↦{dq} v.(sync.WaitGroup.noCopy') ∗
      "state" ∷ l.[(sync.WaitGroup.t), "state"] ↦{dq} v.(sync.WaitGroup.state') ∗
      "sema" ∷ l.[(sync.WaitGroup.t), "sema"] ↦{dq} v.(sync.WaitGroup.sema') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance WaitGroup_into_val_typed
   :
  IntoValTyped (sync.WaitGroup.t) (sync.WaitGroup).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance WaitGroup_access_load_noCopy l (v : (sync.WaitGroup.t)) dq :
  AccessStrict
    (l.[(sync.WaitGroup.t), "noCopy"] ↦{dq} (v.(sync.WaitGroup.noCopy')))
    (l.[(sync.WaitGroup.t), "noCopy"] ↦{dq} (v.(sync.WaitGroup.noCopy')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance WaitGroup_access_store_noCopy l (v : (sync.WaitGroup.t)) noCopy' :
  AccessStrict
    (l.[(sync.WaitGroup.t), "noCopy"] ↦ (v.(sync.WaitGroup.noCopy')))
    (l.[(sync.WaitGroup.t), "noCopy"] ↦ noCopy')
    (l ↦ v) (l ↦ (v <|(sync.WaitGroup.noCopy') := noCopy'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance WaitGroup_access_load_state l (v : (sync.WaitGroup.t)) dq :
  AccessStrict
    (l.[(sync.WaitGroup.t), "state"] ↦{dq} (v.(sync.WaitGroup.state')))
    (l.[(sync.WaitGroup.t), "state"] ↦{dq} (v.(sync.WaitGroup.state')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance WaitGroup_access_store_state l (v : (sync.WaitGroup.t)) state' :
  AccessStrict
    (l.[(sync.WaitGroup.t), "state"] ↦ (v.(sync.WaitGroup.state')))
    (l.[(sync.WaitGroup.t), "state"] ↦ state')
    (l ↦ v) (l ↦ (v <|(sync.WaitGroup.state') := state'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance WaitGroup_access_load_sema l (v : (sync.WaitGroup.t)) dq :
  AccessStrict
    (l.[(sync.WaitGroup.t), "sema"] ↦{dq} (v.(sync.WaitGroup.sema')))
    (l.[(sync.WaitGroup.t), "sema"] ↦{dq} (v.(sync.WaitGroup.sema')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance WaitGroup_access_store_sema l (v : (sync.WaitGroup.t)) sema' :
  AccessStrict
    (l.[(sync.WaitGroup.t), "sema"] ↦ (v.(sync.WaitGroup.sema')))
    (l.[(sync.WaitGroup.t), "sema"] ↦ sema')
    (l ↦ v) (l ↦ (v <|(sync.WaitGroup.sema') := sema'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End WaitGroup.

End sync.
