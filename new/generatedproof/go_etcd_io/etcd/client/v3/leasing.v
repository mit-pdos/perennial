(* autogenerated by goose proofgen; do not modify *)
Require Export New.proof.proof_prelude.
Require Export New.generatedproof.bytes.
Require Export New.generatedproof.context.
Require Export New.generatedproof.errors.
Require Export New.generatedproof.go_etcd_io.etcd.api.v3.etcdserverpb.
Require Export New.generatedproof.go_etcd_io.etcd.api.v3.mvccpb.
Require Export New.generatedproof.go_etcd_io.etcd.api.v3.v3rpc.rpctypes.
Require Export New.generatedproof.go_etcd_io.etcd.client.v3.
Require Export New.generatedproof.go_etcd_io.etcd.client.v3.concurrency.
Require Export New.generatedproof.google_golang_org.grpc.codes.
Require Export New.generatedproof.google_golang_org.grpc.status.
Require Export New.generatedproof.strings.
Require Export New.generatedproof.sync.
Require Export New.generatedproof.time.
Require Export New.golang.theory.
Require Export New.code.go_etcd_io.etcd.client.v3.leasing.

Set Default Proof Using "Type".

Module leasing.
Module leaseCache.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : leasing.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance leaseCache_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (leasing.leaseCache.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "mu" ∷ l.[(leasing.leaseCache.t), "mu"] ↦{dq} v.(leasing.leaseCache.mu') ∗
      "entries" ∷ l.[(leasing.leaseCache.t), "entries"] ↦{dq} v.(leasing.leaseCache.entries') ∗
      "revokes" ∷ l.[(leasing.leaseCache.t), "revokes"] ↦{dq} v.(leasing.leaseCache.revokes') ∗
      "header" ∷ l.[(leasing.leaseCache.t), "header"] ↦{dq} v.(leasing.leaseCache.header') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance leaseCache_into_val_typed
   :
  IntoValTypedUnderlying (leasing.leaseCache.t) (leasing.leaseCacheⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance leaseCache_access_load_mu l (v : (leasing.leaseCache.t)) dq :
  AccessStrict
    (l.[(leasing.leaseCache.t), "mu"] ↦{dq} (v.(leasing.leaseCache.mu')))
    (l.[(leasing.leaseCache.t), "mu"] ↦{dq} (v.(leasing.leaseCache.mu')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance leaseCache_access_store_mu l (v : (leasing.leaseCache.t)) mu' :
  AccessStrict
    (l.[(leasing.leaseCache.t), "mu"] ↦ (v.(leasing.leaseCache.mu')))
    (l.[(leasing.leaseCache.t), "mu"] ↦ mu')
    (l ↦ v) (l ↦ (v <|(leasing.leaseCache.mu') := mu'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance leaseCache_access_load_entries l (v : (leasing.leaseCache.t)) dq :
  AccessStrict
    (l.[(leasing.leaseCache.t), "entries"] ↦{dq} (v.(leasing.leaseCache.entries')))
    (l.[(leasing.leaseCache.t), "entries"] ↦{dq} (v.(leasing.leaseCache.entries')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance leaseCache_access_store_entries l (v : (leasing.leaseCache.t)) entries' :
  AccessStrict
    (l.[(leasing.leaseCache.t), "entries"] ↦ (v.(leasing.leaseCache.entries')))
    (l.[(leasing.leaseCache.t), "entries"] ↦ entries')
    (l ↦ v) (l ↦ (v <|(leasing.leaseCache.entries') := entries'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance leaseCache_access_load_revokes l (v : (leasing.leaseCache.t)) dq :
  AccessStrict
    (l.[(leasing.leaseCache.t), "revokes"] ↦{dq} (v.(leasing.leaseCache.revokes')))
    (l.[(leasing.leaseCache.t), "revokes"] ↦{dq} (v.(leasing.leaseCache.revokes')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance leaseCache_access_store_revokes l (v : (leasing.leaseCache.t)) revokes' :
  AccessStrict
    (l.[(leasing.leaseCache.t), "revokes"] ↦ (v.(leasing.leaseCache.revokes')))
    (l.[(leasing.leaseCache.t), "revokes"] ↦ revokes')
    (l ↦ v) (l ↦ (v <|(leasing.leaseCache.revokes') := revokes'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance leaseCache_access_load_header l (v : (leasing.leaseCache.t)) dq :
  AccessStrict
    (l.[(leasing.leaseCache.t), "header"] ↦{dq} (v.(leasing.leaseCache.header')))
    (l.[(leasing.leaseCache.t), "header"] ↦{dq} (v.(leasing.leaseCache.header')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance leaseCache_access_store_header l (v : (leasing.leaseCache.t)) header' :
  AccessStrict
    (l.[(leasing.leaseCache.t), "header"] ↦ (v.(leasing.leaseCache.header')))
    (l.[(leasing.leaseCache.t), "header"] ↦ header')
    (l ↦ v) (l ↦ (v <|(leasing.leaseCache.header') := header'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End leaseCache.

Module leaseKey.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : leasing.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance leaseKey_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (leasing.leaseKey.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "response" ∷ l.[(leasing.leaseKey.t), "response"] ↦{dq} v.(leasing.leaseKey.response') ∗
      "rev" ∷ l.[(leasing.leaseKey.t), "rev"] ↦{dq} v.(leasing.leaseKey.rev') ∗
      "waitc" ∷ l.[(leasing.leaseKey.t), "waitc"] ↦{dq} v.(leasing.leaseKey.waitc') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance leaseKey_into_val_typed
   :
  IntoValTypedUnderlying (leasing.leaseKey.t) (leasing.leaseKeyⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance leaseKey_access_load_response l (v : (leasing.leaseKey.t)) dq :
  AccessStrict
    (l.[(leasing.leaseKey.t), "response"] ↦{dq} (v.(leasing.leaseKey.response')))
    (l.[(leasing.leaseKey.t), "response"] ↦{dq} (v.(leasing.leaseKey.response')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance leaseKey_access_store_response l (v : (leasing.leaseKey.t)) response' :
  AccessStrict
    (l.[(leasing.leaseKey.t), "response"] ↦ (v.(leasing.leaseKey.response')))
    (l.[(leasing.leaseKey.t), "response"] ↦ response')
    (l ↦ v) (l ↦ (v <|(leasing.leaseKey.response') := response'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance leaseKey_access_load_rev l (v : (leasing.leaseKey.t)) dq :
  AccessStrict
    (l.[(leasing.leaseKey.t), "rev"] ↦{dq} (v.(leasing.leaseKey.rev')))
    (l.[(leasing.leaseKey.t), "rev"] ↦{dq} (v.(leasing.leaseKey.rev')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance leaseKey_access_store_rev l (v : (leasing.leaseKey.t)) rev' :
  AccessStrict
    (l.[(leasing.leaseKey.t), "rev"] ↦ (v.(leasing.leaseKey.rev')))
    (l.[(leasing.leaseKey.t), "rev"] ↦ rev')
    (l ↦ v) (l ↦ (v <|(leasing.leaseKey.rev') := rev'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance leaseKey_access_load_waitc l (v : (leasing.leaseKey.t)) dq :
  AccessStrict
    (l.[(leasing.leaseKey.t), "waitc"] ↦{dq} (v.(leasing.leaseKey.waitc')))
    (l.[(leasing.leaseKey.t), "waitc"] ↦{dq} (v.(leasing.leaseKey.waitc')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance leaseKey_access_store_waitc l (v : (leasing.leaseKey.t)) waitc' :
  AccessStrict
    (l.[(leasing.leaseKey.t), "waitc"] ↦ (v.(leasing.leaseKey.waitc')))
    (l.[(leasing.leaseKey.t), "waitc"] ↦ waitc')
    (l ↦ v) (l ↦ (v <|(leasing.leaseKey.waitc') := waitc'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End leaseKey.

Module leasingKV.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : leasing.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance leasingKV_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (leasing.leasingKV.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "cl" ∷ l.[(leasing.leasingKV.t), "cl"] ↦{dq} v.(leasing.leasingKV.cl') ∗
      "kv" ∷ l.[(leasing.leasingKV.t), "kv"] ↦{dq} v.(leasing.leasingKV.kv') ∗
      "pfx" ∷ l.[(leasing.leasingKV.t), "pfx"] ↦{dq} v.(leasing.leasingKV.pfx') ∗
      "leases" ∷ l.[(leasing.leasingKV.t), "leases"] ↦{dq} v.(leasing.leasingKV.leases') ∗
      "ctx" ∷ l.[(leasing.leasingKV.t), "ctx"] ↦{dq} v.(leasing.leasingKV.ctx') ∗
      "cancel" ∷ l.[(leasing.leasingKV.t), "cancel"] ↦{dq} v.(leasing.leasingKV.cancel') ∗
      "wg" ∷ l.[(leasing.leasingKV.t), "wg"] ↦{dq} v.(leasing.leasingKV.wg') ∗
      "sessionOpts" ∷ l.[(leasing.leasingKV.t), "sessionOpts"] ↦{dq} v.(leasing.leasingKV.sessionOpts') ∗
      "session" ∷ l.[(leasing.leasingKV.t), "session"] ↦{dq} v.(leasing.leasingKV.session') ∗
      "sessionc" ∷ l.[(leasing.leasingKV.t), "sessionc"] ↦{dq} v.(leasing.leasingKV.sessionc') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance leasingKV_into_val_typed
   :
  IntoValTypedUnderlying (leasing.leasingKV.t) (leasing.leasingKVⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance leasingKV_access_load_cl l (v : (leasing.leasingKV.t)) dq :
  AccessStrict
    (l.[(leasing.leasingKV.t), "cl"] ↦{dq} (v.(leasing.leasingKV.cl')))
    (l.[(leasing.leasingKV.t), "cl"] ↦{dq} (v.(leasing.leasingKV.cl')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance leasingKV_access_store_cl l (v : (leasing.leasingKV.t)) cl' :
  AccessStrict
    (l.[(leasing.leasingKV.t), "cl"] ↦ (v.(leasing.leasingKV.cl')))
    (l.[(leasing.leasingKV.t), "cl"] ↦ cl')
    (l ↦ v) (l ↦ (v <|(leasing.leasingKV.cl') := cl'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance leasingKV_access_load_kv l (v : (leasing.leasingKV.t)) dq :
  AccessStrict
    (l.[(leasing.leasingKV.t), "kv"] ↦{dq} (v.(leasing.leasingKV.kv')))
    (l.[(leasing.leasingKV.t), "kv"] ↦{dq} (v.(leasing.leasingKV.kv')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance leasingKV_access_store_kv l (v : (leasing.leasingKV.t)) kv' :
  AccessStrict
    (l.[(leasing.leasingKV.t), "kv"] ↦ (v.(leasing.leasingKV.kv')))
    (l.[(leasing.leasingKV.t), "kv"] ↦ kv')
    (l ↦ v) (l ↦ (v <|(leasing.leasingKV.kv') := kv'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance leasingKV_access_load_pfx l (v : (leasing.leasingKV.t)) dq :
  AccessStrict
    (l.[(leasing.leasingKV.t), "pfx"] ↦{dq} (v.(leasing.leasingKV.pfx')))
    (l.[(leasing.leasingKV.t), "pfx"] ↦{dq} (v.(leasing.leasingKV.pfx')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance leasingKV_access_store_pfx l (v : (leasing.leasingKV.t)) pfx' :
  AccessStrict
    (l.[(leasing.leasingKV.t), "pfx"] ↦ (v.(leasing.leasingKV.pfx')))
    (l.[(leasing.leasingKV.t), "pfx"] ↦ pfx')
    (l ↦ v) (l ↦ (v <|(leasing.leasingKV.pfx') := pfx'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance leasingKV_access_load_leases l (v : (leasing.leasingKV.t)) dq :
  AccessStrict
    (l.[(leasing.leasingKV.t), "leases"] ↦{dq} (v.(leasing.leasingKV.leases')))
    (l.[(leasing.leasingKV.t), "leases"] ↦{dq} (v.(leasing.leasingKV.leases')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance leasingKV_access_store_leases l (v : (leasing.leasingKV.t)) leases' :
  AccessStrict
    (l.[(leasing.leasingKV.t), "leases"] ↦ (v.(leasing.leasingKV.leases')))
    (l.[(leasing.leasingKV.t), "leases"] ↦ leases')
    (l ↦ v) (l ↦ (v <|(leasing.leasingKV.leases') := leases'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance leasingKV_access_load_ctx l (v : (leasing.leasingKV.t)) dq :
  AccessStrict
    (l.[(leasing.leasingKV.t), "ctx"] ↦{dq} (v.(leasing.leasingKV.ctx')))
    (l.[(leasing.leasingKV.t), "ctx"] ↦{dq} (v.(leasing.leasingKV.ctx')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance leasingKV_access_store_ctx l (v : (leasing.leasingKV.t)) ctx' :
  AccessStrict
    (l.[(leasing.leasingKV.t), "ctx"] ↦ (v.(leasing.leasingKV.ctx')))
    (l.[(leasing.leasingKV.t), "ctx"] ↦ ctx')
    (l ↦ v) (l ↦ (v <|(leasing.leasingKV.ctx') := ctx'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance leasingKV_access_load_cancel l (v : (leasing.leasingKV.t)) dq :
  AccessStrict
    (l.[(leasing.leasingKV.t), "cancel"] ↦{dq} (v.(leasing.leasingKV.cancel')))
    (l.[(leasing.leasingKV.t), "cancel"] ↦{dq} (v.(leasing.leasingKV.cancel')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance leasingKV_access_store_cancel l (v : (leasing.leasingKV.t)) cancel' :
  AccessStrict
    (l.[(leasing.leasingKV.t), "cancel"] ↦ (v.(leasing.leasingKV.cancel')))
    (l.[(leasing.leasingKV.t), "cancel"] ↦ cancel')
    (l ↦ v) (l ↦ (v <|(leasing.leasingKV.cancel') := cancel'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance leasingKV_access_load_wg l (v : (leasing.leasingKV.t)) dq :
  AccessStrict
    (l.[(leasing.leasingKV.t), "wg"] ↦{dq} (v.(leasing.leasingKV.wg')))
    (l.[(leasing.leasingKV.t), "wg"] ↦{dq} (v.(leasing.leasingKV.wg')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance leasingKV_access_store_wg l (v : (leasing.leasingKV.t)) wg' :
  AccessStrict
    (l.[(leasing.leasingKV.t), "wg"] ↦ (v.(leasing.leasingKV.wg')))
    (l.[(leasing.leasingKV.t), "wg"] ↦ wg')
    (l ↦ v) (l ↦ (v <|(leasing.leasingKV.wg') := wg'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance leasingKV_access_load_sessionOpts l (v : (leasing.leasingKV.t)) dq :
  AccessStrict
    (l.[(leasing.leasingKV.t), "sessionOpts"] ↦{dq} (v.(leasing.leasingKV.sessionOpts')))
    (l.[(leasing.leasingKV.t), "sessionOpts"] ↦{dq} (v.(leasing.leasingKV.sessionOpts')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance leasingKV_access_store_sessionOpts l (v : (leasing.leasingKV.t)) sessionOpts' :
  AccessStrict
    (l.[(leasing.leasingKV.t), "sessionOpts"] ↦ (v.(leasing.leasingKV.sessionOpts')))
    (l.[(leasing.leasingKV.t), "sessionOpts"] ↦ sessionOpts')
    (l ↦ v) (l ↦ (v <|(leasing.leasingKV.sessionOpts') := sessionOpts'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance leasingKV_access_load_session l (v : (leasing.leasingKV.t)) dq :
  AccessStrict
    (l.[(leasing.leasingKV.t), "session"] ↦{dq} (v.(leasing.leasingKV.session')))
    (l.[(leasing.leasingKV.t), "session"] ↦{dq} (v.(leasing.leasingKV.session')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance leasingKV_access_store_session l (v : (leasing.leasingKV.t)) session' :
  AccessStrict
    (l.[(leasing.leasingKV.t), "session"] ↦ (v.(leasing.leasingKV.session')))
    (l.[(leasing.leasingKV.t), "session"] ↦ session')
    (l ↦ v) (l ↦ (v <|(leasing.leasingKV.session') := session'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance leasingKV_access_load_sessionc l (v : (leasing.leasingKV.t)) dq :
  AccessStrict
    (l.[(leasing.leasingKV.t), "sessionc"] ↦{dq} (v.(leasing.leasingKV.sessionc')))
    (l.[(leasing.leasingKV.t), "sessionc"] ↦{dq} (v.(leasing.leasingKV.sessionc')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance leasingKV_access_store_sessionc l (v : (leasing.leasingKV.t)) sessionc' :
  AccessStrict
    (l.[(leasing.leasingKV.t), "sessionc"] ↦ (v.(leasing.leasingKV.sessionc')))
    (l.[(leasing.leasingKV.t), "sessionc"] ↦ sessionc')
    (l ↦ v) (l ↦ (v <|(leasing.leasingKV.sessionc') := sessionc'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End leasingKV.

Module txnLeasing.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : leasing.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance txnLeasing_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (leasing.txnLeasing.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "Txn" ∷ l.[(leasing.txnLeasing.t), "Txn"] ↦{dq} v.(leasing.txnLeasing.Txn') ∗
      "lkv" ∷ l.[(leasing.txnLeasing.t), "lkv"] ↦{dq} v.(leasing.txnLeasing.lkv') ∗
      "ctx" ∷ l.[(leasing.txnLeasing.t), "ctx"] ↦{dq} v.(leasing.txnLeasing.ctx') ∗
      "cs" ∷ l.[(leasing.txnLeasing.t), "cs"] ↦{dq} v.(leasing.txnLeasing.cs') ∗
      "opst" ∷ l.[(leasing.txnLeasing.t), "opst"] ↦{dq} v.(leasing.txnLeasing.opst') ∗
      "opse" ∷ l.[(leasing.txnLeasing.t), "opse"] ↦{dq} v.(leasing.txnLeasing.opse') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance txnLeasing_into_val_typed
   :
  IntoValTypedUnderlying (leasing.txnLeasing.t) (leasing.txnLeasingⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance txnLeasing_access_load_Txn l (v : (leasing.txnLeasing.t)) dq :
  AccessStrict
    (l.[(leasing.txnLeasing.t), "Txn"] ↦{dq} (v.(leasing.txnLeasing.Txn')))
    (l.[(leasing.txnLeasing.t), "Txn"] ↦{dq} (v.(leasing.txnLeasing.Txn')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance txnLeasing_access_store_Txn l (v : (leasing.txnLeasing.t)) Txn' :
  AccessStrict
    (l.[(leasing.txnLeasing.t), "Txn"] ↦ (v.(leasing.txnLeasing.Txn')))
    (l.[(leasing.txnLeasing.t), "Txn"] ↦ Txn')
    (l ↦ v) (l ↦ (v <|(leasing.txnLeasing.Txn') := Txn'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance txnLeasing_access_load_lkv l (v : (leasing.txnLeasing.t)) dq :
  AccessStrict
    (l.[(leasing.txnLeasing.t), "lkv"] ↦{dq} (v.(leasing.txnLeasing.lkv')))
    (l.[(leasing.txnLeasing.t), "lkv"] ↦{dq} (v.(leasing.txnLeasing.lkv')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance txnLeasing_access_store_lkv l (v : (leasing.txnLeasing.t)) lkv' :
  AccessStrict
    (l.[(leasing.txnLeasing.t), "lkv"] ↦ (v.(leasing.txnLeasing.lkv')))
    (l.[(leasing.txnLeasing.t), "lkv"] ↦ lkv')
    (l ↦ v) (l ↦ (v <|(leasing.txnLeasing.lkv') := lkv'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance txnLeasing_access_load_ctx l (v : (leasing.txnLeasing.t)) dq :
  AccessStrict
    (l.[(leasing.txnLeasing.t), "ctx"] ↦{dq} (v.(leasing.txnLeasing.ctx')))
    (l.[(leasing.txnLeasing.t), "ctx"] ↦{dq} (v.(leasing.txnLeasing.ctx')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance txnLeasing_access_store_ctx l (v : (leasing.txnLeasing.t)) ctx' :
  AccessStrict
    (l.[(leasing.txnLeasing.t), "ctx"] ↦ (v.(leasing.txnLeasing.ctx')))
    (l.[(leasing.txnLeasing.t), "ctx"] ↦ ctx')
    (l ↦ v) (l ↦ (v <|(leasing.txnLeasing.ctx') := ctx'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance txnLeasing_access_load_cs l (v : (leasing.txnLeasing.t)) dq :
  AccessStrict
    (l.[(leasing.txnLeasing.t), "cs"] ↦{dq} (v.(leasing.txnLeasing.cs')))
    (l.[(leasing.txnLeasing.t), "cs"] ↦{dq} (v.(leasing.txnLeasing.cs')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance txnLeasing_access_store_cs l (v : (leasing.txnLeasing.t)) cs' :
  AccessStrict
    (l.[(leasing.txnLeasing.t), "cs"] ↦ (v.(leasing.txnLeasing.cs')))
    (l.[(leasing.txnLeasing.t), "cs"] ↦ cs')
    (l ↦ v) (l ↦ (v <|(leasing.txnLeasing.cs') := cs'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance txnLeasing_access_load_opst l (v : (leasing.txnLeasing.t)) dq :
  AccessStrict
    (l.[(leasing.txnLeasing.t), "opst"] ↦{dq} (v.(leasing.txnLeasing.opst')))
    (l.[(leasing.txnLeasing.t), "opst"] ↦{dq} (v.(leasing.txnLeasing.opst')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance txnLeasing_access_store_opst l (v : (leasing.txnLeasing.t)) opst' :
  AccessStrict
    (l.[(leasing.txnLeasing.t), "opst"] ↦ (v.(leasing.txnLeasing.opst')))
    (l.[(leasing.txnLeasing.t), "opst"] ↦ opst')
    (l ↦ v) (l ↦ (v <|(leasing.txnLeasing.opst') := opst'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance txnLeasing_access_load_opse l (v : (leasing.txnLeasing.t)) dq :
  AccessStrict
    (l.[(leasing.txnLeasing.t), "opse"] ↦{dq} (v.(leasing.txnLeasing.opse')))
    (l.[(leasing.txnLeasing.t), "opse"] ↦{dq} (v.(leasing.txnLeasing.opse')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance txnLeasing_access_store_opse l (v : (leasing.txnLeasing.t)) opse' :
  AccessStrict
    (l.[(leasing.txnLeasing.t), "opse"] ↦ (v.(leasing.txnLeasing.opse')))
    (l.[(leasing.txnLeasing.t), "opse"] ↦ opse')
    (l ↦ v) (l ↦ (v <|(leasing.txnLeasing.opse') := opse'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End txnLeasing.

End leasing.
