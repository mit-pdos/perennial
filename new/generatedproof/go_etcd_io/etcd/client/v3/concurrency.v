(* autogenerated by goose proofgen; do not modify *)
Require Export New.proof.proof_prelude.
Require Export New.generatedproof.context.
Require Export New.generatedproof.errors.
Require Export New.generatedproof.fmt.
Require Export New.generatedproof.go_etcd_io.etcd.api.v3.etcdserverpb.
Require Export New.generatedproof.go_etcd_io.etcd.api.v3.mvccpb.
Require Export New.generatedproof.go_etcd_io.etcd.client.v3.
Require Export New.generatedproof.strings.
Require Export New.generatedproof.sync.
Require Export New.generatedproof.time.
Require Export New.generatedproof.go_uber_org.zap.
Require Export New.generatedproof.math.
Require Export New.golang.theory.

Require Export New.code.go_etcd_io.etcd.client.v3.concurrency.

Set Default Proof Using "Type".

Module concurrency.

(* type concurrency.Election *)
Module Election.
Section def.
Context `{ffi_syntax}.
Record t := mk {
  session' : loc;
  keyPrefix' : go_string;
  leaderKey' : go_string;
  leaderRev' : w64;
  leaderSession' : loc;
  hdr' : loc;
}.
End def.
End Election.

Section instances.
Context `{ffi_syntax}.

Global Instance settable_Election : Settable Election.t :=
  settable! Election.mk < Election.session'; Election.keyPrefix'; Election.leaderKey'; Election.leaderRev'; Election.leaderSession'; Election.hdr' >.
Global Instance into_val_Election : IntoVal Election.t :=
  {| to_val_def v :=
    struct.val_aux concurrency.Election [
    "session" ::= #(Election.session' v);
    "keyPrefix" ::= #(Election.keyPrefix' v);
    "leaderKey" ::= #(Election.leaderKey' v);
    "leaderRev" ::= #(Election.leaderRev' v);
    "leaderSession" ::= #(Election.leaderSession' v);
    "hdr" ::= #(Election.hdr' v)
    ]%struct
  |}.

Global Program Instance into_val_typed_Election : IntoValTyped Election.t concurrency.Election :=
{|
  default_val := Election.mk (default_val _) (default_val _) (default_val _) (default_val _) (default_val _) (default_val _);
|}.
Next Obligation. solve_to_val_type. Qed.
Next Obligation. solve_zero_val. Qed.
Next Obligation. solve_to_val_inj. Qed.
Final Obligation. solve_decision. Qed.

Global Instance into_val_struct_field_Election_session : IntoValStructField "session" concurrency.Election Election.session'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_Election_keyPrefix : IntoValStructField "keyPrefix" concurrency.Election Election.keyPrefix'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_Election_leaderKey : IntoValStructField "leaderKey" concurrency.Election Election.leaderKey'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_Election_leaderRev : IntoValStructField "leaderRev" concurrency.Election Election.leaderRev'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_Election_leaderSession : IntoValStructField "leaderSession" concurrency.Election Election.leaderSession'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_Election_hdr : IntoValStructField "hdr" concurrency.Election Election.hdr'.
Proof. solve_into_val_struct_field. Qed.


Context `{!ffi_model, !ffi_semantics _ _, !ffi_interp _, !heapGS Σ}.
Global Instance wp_struct_make_Election session' keyPrefix' leaderKey' leaderRev' leaderSession' hdr':
  PureWp True
    (struct.make #concurrency.Election (alist_val [
      "session" ::= #session';
      "keyPrefix" ::= #keyPrefix';
      "leaderKey" ::= #leaderKey';
      "leaderRev" ::= #leaderRev';
      "leaderSession" ::= #leaderSession';
      "hdr" ::= #hdr'
    ]))%struct
    #(Election.mk session' keyPrefix' leaderKey' leaderRev' leaderSession' hdr').
Proof. solve_struct_make_pure_wp. Qed.


Global Instance Election_struct_fields_split dq l (v : Election.t) :
  StructFieldsSplit dq l v (
    "Hsession" ∷ l ↦s[concurrency.Election :: "session"]{dq} v.(Election.session') ∗
    "HkeyPrefix" ∷ l ↦s[concurrency.Election :: "keyPrefix"]{dq} v.(Election.keyPrefix') ∗
    "HleaderKey" ∷ l ↦s[concurrency.Election :: "leaderKey"]{dq} v.(Election.leaderKey') ∗
    "HleaderRev" ∷ l ↦s[concurrency.Election :: "leaderRev"]{dq} v.(Election.leaderRev') ∗
    "HleaderSession" ∷ l ↦s[concurrency.Election :: "leaderSession"]{dq} v.(Election.leaderSession') ∗
    "Hhdr" ∷ l ↦s[concurrency.Election :: "hdr"]{dq} v.(Election.hdr')
  ).
Proof.
  rewrite /named.
  apply struct_fields_split_intro.
  unfold_typed_pointsto; split_pointsto_app.

  rewrite -!/(typed_pointsto_def _ _ _) -!typed_pointsto_unseal.
  simpl_one_flatten_struct (# (Election.session' v)) concurrency.Election "session"%go.
  simpl_one_flatten_struct (# (Election.keyPrefix' v)) concurrency.Election "keyPrefix"%go.
  simpl_one_flatten_struct (# (Election.leaderKey' v)) concurrency.Election "leaderKey"%go.
  simpl_one_flatten_struct (# (Election.leaderRev' v)) concurrency.Election "leaderRev"%go.
  simpl_one_flatten_struct (# (Election.leaderSession' v)) concurrency.Election "leaderSession"%go.

  solve_field_ref_f.
Qed.

End instances.

(* type concurrency.Mutex *)
Module Mutex.
Section def.
Context `{ffi_syntax}.
Record t := mk {
  s' : loc;
  pfx' : go_string;
  myKey' : go_string;
  myRev' : w64;
  hdr' : loc;
}.
End def.
End Mutex.

Section instances.
Context `{ffi_syntax}.

Global Instance settable_Mutex : Settable Mutex.t :=
  settable! Mutex.mk < Mutex.s'; Mutex.pfx'; Mutex.myKey'; Mutex.myRev'; Mutex.hdr' >.
Global Instance into_val_Mutex : IntoVal Mutex.t :=
  {| to_val_def v :=
    struct.val_aux concurrency.Mutex [
    "s" ::= #(Mutex.s' v);
    "pfx" ::= #(Mutex.pfx' v);
    "myKey" ::= #(Mutex.myKey' v);
    "myRev" ::= #(Mutex.myRev' v);
    "hdr" ::= #(Mutex.hdr' v)
    ]%struct
  |}.

Global Program Instance into_val_typed_Mutex : IntoValTyped Mutex.t concurrency.Mutex :=
{|
  default_val := Mutex.mk (default_val _) (default_val _) (default_val _) (default_val _) (default_val _);
|}.
Next Obligation. solve_to_val_type. Qed.
Next Obligation. solve_zero_val. Qed.
Next Obligation. solve_to_val_inj. Qed.
Final Obligation. solve_decision. Qed.

Global Instance into_val_struct_field_Mutex_s : IntoValStructField "s" concurrency.Mutex Mutex.s'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_Mutex_pfx : IntoValStructField "pfx" concurrency.Mutex Mutex.pfx'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_Mutex_myKey : IntoValStructField "myKey" concurrency.Mutex Mutex.myKey'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_Mutex_myRev : IntoValStructField "myRev" concurrency.Mutex Mutex.myRev'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_Mutex_hdr : IntoValStructField "hdr" concurrency.Mutex Mutex.hdr'.
Proof. solve_into_val_struct_field. Qed.


Context `{!ffi_model, !ffi_semantics _ _, !ffi_interp _, !heapGS Σ}.
Global Instance wp_struct_make_Mutex s' pfx' myKey' myRev' hdr':
  PureWp True
    (struct.make #concurrency.Mutex (alist_val [
      "s" ::= #s';
      "pfx" ::= #pfx';
      "myKey" ::= #myKey';
      "myRev" ::= #myRev';
      "hdr" ::= #hdr'
    ]))%struct
    #(Mutex.mk s' pfx' myKey' myRev' hdr').
Proof. solve_struct_make_pure_wp. Qed.


Global Instance Mutex_struct_fields_split dq l (v : Mutex.t) :
  StructFieldsSplit dq l v (
    "Hs" ∷ l ↦s[concurrency.Mutex :: "s"]{dq} v.(Mutex.s') ∗
    "Hpfx" ∷ l ↦s[concurrency.Mutex :: "pfx"]{dq} v.(Mutex.pfx') ∗
    "HmyKey" ∷ l ↦s[concurrency.Mutex :: "myKey"]{dq} v.(Mutex.myKey') ∗
    "HmyRev" ∷ l ↦s[concurrency.Mutex :: "myRev"]{dq} v.(Mutex.myRev') ∗
    "Hhdr" ∷ l ↦s[concurrency.Mutex :: "hdr"]{dq} v.(Mutex.hdr')
  ).
Proof.
  rewrite /named.
  apply struct_fields_split_intro.
  unfold_typed_pointsto; split_pointsto_app.

  rewrite -!/(typed_pointsto_def _ _ _) -!typed_pointsto_unseal.
  simpl_one_flatten_struct (# (Mutex.s' v)) concurrency.Mutex "s"%go.
  simpl_one_flatten_struct (# (Mutex.pfx' v)) concurrency.Mutex "pfx"%go.
  simpl_one_flatten_struct (# (Mutex.myKey' v)) concurrency.Mutex "myKey"%go.
  simpl_one_flatten_struct (# (Mutex.myRev' v)) concurrency.Mutex "myRev"%go.

  solve_field_ref_f.
Qed.

End instances.

(* type concurrency.lockerMutex *)
Module lockerMutex.
Section def.
Context `{ffi_syntax}.
Record t := mk {
  Mutex' : loc;
}.
End def.
End lockerMutex.

Section instances.
Context `{ffi_syntax}.

Global Instance settable_lockerMutex : Settable lockerMutex.t :=
  settable! lockerMutex.mk < lockerMutex.Mutex' >.
Global Instance into_val_lockerMutex : IntoVal lockerMutex.t :=
  {| to_val_def v :=
    struct.val_aux concurrency.lockerMutex [
    "Mutex" ::= #(lockerMutex.Mutex' v)
    ]%struct
  |}.

Global Program Instance into_val_typed_lockerMutex : IntoValTyped lockerMutex.t concurrency.lockerMutex :=
{|
  default_val := lockerMutex.mk (default_val _);
|}.
Next Obligation. solve_to_val_type. Qed.
Next Obligation. solve_zero_val. Qed.
Next Obligation. solve_to_val_inj. Qed.
Final Obligation. solve_decision. Qed.

Global Instance into_val_struct_field_lockerMutex_Mutex : IntoValStructField "Mutex" concurrency.lockerMutex lockerMutex.Mutex'.
Proof. solve_into_val_struct_field. Qed.


Context `{!ffi_model, !ffi_semantics _ _, !ffi_interp _, !heapGS Σ}.
Global Instance wp_struct_make_lockerMutex Mutex':
  PureWp True
    (struct.make #concurrency.lockerMutex (alist_val [
      "Mutex" ::= #Mutex'
    ]))%struct
    #(lockerMutex.mk Mutex').
Proof. solve_struct_make_pure_wp. Qed.


Global Instance lockerMutex_struct_fields_split dq l (v : lockerMutex.t) :
  StructFieldsSplit dq l v (
    "HMutex" ∷ l ↦s[concurrency.lockerMutex :: "Mutex"]{dq} v.(lockerMutex.Mutex')
  ).
Proof.
  rewrite /named.
  apply struct_fields_split_intro.
  unfold_typed_pointsto; split_pointsto_app.

  rewrite -!/(typed_pointsto_def _ _ _) -!typed_pointsto_unseal.

  solve_field_ref_f.
Qed.

End instances.

(* type concurrency.Session *)
Module Session.
Section def.
Context `{ffi_syntax}.
Record t := mk {
  client' : loc;
  opts' : loc;
  id' : clientv3.LeaseID.t;
  ctx' : context.Context.t;
  cancel' : context.CancelFunc.t;
  donec' : loc;
}.
End def.
End Session.

Section instances.
Context `{ffi_syntax}.

Global Instance settable_Session : Settable Session.t :=
  settable! Session.mk < Session.client'; Session.opts'; Session.id'; Session.ctx'; Session.cancel'; Session.donec' >.
Global Instance into_val_Session : IntoVal Session.t :=
  {| to_val_def v :=
    struct.val_aux concurrency.Session [
    "client" ::= #(Session.client' v);
    "opts" ::= #(Session.opts' v);
    "id" ::= #(Session.id' v);
    "ctx" ::= #(Session.ctx' v);
    "cancel" ::= #(Session.cancel' v);
    "donec" ::= #(Session.donec' v)
    ]%struct
  |}.

Global Program Instance into_val_typed_Session : IntoValTyped Session.t concurrency.Session :=
{|
  default_val := Session.mk (default_val _) (default_val _) (default_val _) (default_val _) (default_val _) (default_val _);
|}.
Next Obligation. solve_to_val_type. Qed.
Next Obligation. solve_zero_val. Qed.
Next Obligation. solve_to_val_inj. Qed.
Final Obligation. solve_decision. Qed.

Global Instance into_val_struct_field_Session_client : IntoValStructField "client" concurrency.Session Session.client'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_Session_opts : IntoValStructField "opts" concurrency.Session Session.opts'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_Session_id : IntoValStructField "id" concurrency.Session Session.id'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_Session_ctx : IntoValStructField "ctx" concurrency.Session Session.ctx'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_Session_cancel : IntoValStructField "cancel" concurrency.Session Session.cancel'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_Session_donec : IntoValStructField "donec" concurrency.Session Session.donec'.
Proof. solve_into_val_struct_field. Qed.


Context `{!ffi_model, !ffi_semantics _ _, !ffi_interp _, !heapGS Σ}.
Global Instance wp_struct_make_Session client' opts' id' ctx' cancel' donec':
  PureWp True
    (struct.make #concurrency.Session (alist_val [
      "client" ::= #client';
      "opts" ::= #opts';
      "id" ::= #id';
      "ctx" ::= #ctx';
      "cancel" ::= #cancel';
      "donec" ::= #donec'
    ]))%struct
    #(Session.mk client' opts' id' ctx' cancel' donec').
Proof. solve_struct_make_pure_wp. Qed.


Global Instance Session_struct_fields_split dq l (v : Session.t) :
  StructFieldsSplit dq l v (
    "Hclient" ∷ l ↦s[concurrency.Session :: "client"]{dq} v.(Session.client') ∗
    "Hopts" ∷ l ↦s[concurrency.Session :: "opts"]{dq} v.(Session.opts') ∗
    "Hid" ∷ l ↦s[concurrency.Session :: "id"]{dq} v.(Session.id') ∗
    "Hctx" ∷ l ↦s[concurrency.Session :: "ctx"]{dq} v.(Session.ctx') ∗
    "Hcancel" ∷ l ↦s[concurrency.Session :: "cancel"]{dq} v.(Session.cancel') ∗
    "Hdonec" ∷ l ↦s[concurrency.Session :: "donec"]{dq} v.(Session.donec')
  ).
Proof.
  rewrite /named.
  apply struct_fields_split_intro.
  unfold_typed_pointsto; split_pointsto_app.

  rewrite -!/(typed_pointsto_def _ _ _) -!typed_pointsto_unseal.
  simpl_one_flatten_struct (# (Session.client' v)) concurrency.Session "client"%go.
  simpl_one_flatten_struct (# (Session.opts' v)) concurrency.Session "opts"%go.
  simpl_one_flatten_struct (# (Session.id' v)) concurrency.Session "id"%go.
  simpl_one_flatten_struct (# (Session.ctx' v)) concurrency.Session "ctx"%go.
  simpl_one_flatten_struct (# (Session.cancel' v)) concurrency.Session "cancel"%go.

  solve_field_ref_f.
Qed.

End instances.

(* type concurrency.sessionOptions *)
Module sessionOptions.
Section def.
Context `{ffi_syntax}.
Record t := mk {
  ttl' : w64;
  leaseID' : clientv3.LeaseID.t;
  ctx' : context.Context.t;
}.
End def.
End sessionOptions.

Section instances.
Context `{ffi_syntax}.

Global Instance settable_sessionOptions : Settable sessionOptions.t :=
  settable! sessionOptions.mk < sessionOptions.ttl'; sessionOptions.leaseID'; sessionOptions.ctx' >.
Global Instance into_val_sessionOptions : IntoVal sessionOptions.t :=
  {| to_val_def v :=
    struct.val_aux concurrency.sessionOptions [
    "ttl" ::= #(sessionOptions.ttl' v);
    "leaseID" ::= #(sessionOptions.leaseID' v);
    "ctx" ::= #(sessionOptions.ctx' v)
    ]%struct
  |}.

Global Program Instance into_val_typed_sessionOptions : IntoValTyped sessionOptions.t concurrency.sessionOptions :=
{|
  default_val := sessionOptions.mk (default_val _) (default_val _) (default_val _);
|}.
Next Obligation. solve_to_val_type. Qed.
Next Obligation. solve_zero_val. Qed.
Next Obligation. solve_to_val_inj. Qed.
Final Obligation. solve_decision. Qed.

Global Instance into_val_struct_field_sessionOptions_ttl : IntoValStructField "ttl" concurrency.sessionOptions sessionOptions.ttl'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_sessionOptions_leaseID : IntoValStructField "leaseID" concurrency.sessionOptions sessionOptions.leaseID'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_sessionOptions_ctx : IntoValStructField "ctx" concurrency.sessionOptions sessionOptions.ctx'.
Proof. solve_into_val_struct_field. Qed.


Context `{!ffi_model, !ffi_semantics _ _, !ffi_interp _, !heapGS Σ}.
Global Instance wp_struct_make_sessionOptions ttl' leaseID' ctx':
  PureWp True
    (struct.make #concurrency.sessionOptions (alist_val [
      "ttl" ::= #ttl';
      "leaseID" ::= #leaseID';
      "ctx" ::= #ctx'
    ]))%struct
    #(sessionOptions.mk ttl' leaseID' ctx').
Proof. solve_struct_make_pure_wp. Qed.


Global Instance sessionOptions_struct_fields_split dq l (v : sessionOptions.t) :
  StructFieldsSplit dq l v (
    "Httl" ∷ l ↦s[concurrency.sessionOptions :: "ttl"]{dq} v.(sessionOptions.ttl') ∗
    "HleaseID" ∷ l ↦s[concurrency.sessionOptions :: "leaseID"]{dq} v.(sessionOptions.leaseID') ∗
    "Hctx" ∷ l ↦s[concurrency.sessionOptions :: "ctx"]{dq} v.(sessionOptions.ctx')
  ).
Proof.
  rewrite /named.
  apply struct_fields_split_intro.
  unfold_typed_pointsto; split_pointsto_app.

  rewrite -!/(typed_pointsto_def _ _ _) -!typed_pointsto_unseal.
  simpl_one_flatten_struct (# (sessionOptions.ttl' v)) concurrency.sessionOptions "ttl"%go.
  simpl_one_flatten_struct (# (sessionOptions.leaseID' v)) concurrency.sessionOptions "leaseID"%go.

  solve_field_ref_f.
Qed.

End instances.

(* type concurrency.SessionOption *)
Module SessionOption.
Section def.
Context `{ffi_syntax}.
Definition t := func.t.
End def.
End SessionOption.

(* type concurrency.STM *)
Module STM.
Section def.
Context `{ffi_syntax}.
Definition t := interface.t.
End def.
End STM.

(* type concurrency.Isolation *)
Module Isolation.
Section def.
Context `{ffi_syntax}.
Definition t := w64.
End def.
End Isolation.

(* type concurrency.stmError *)
Module stmError.
Section def.
Context `{ffi_syntax}.
Record t := mk {
  err' : error.t;
}.
End def.
End stmError.

Section instances.
Context `{ffi_syntax}.

Global Instance settable_stmError : Settable stmError.t :=
  settable! stmError.mk < stmError.err' >.
Global Instance into_val_stmError : IntoVal stmError.t :=
  {| to_val_def v :=
    struct.val_aux concurrency.stmError [
    "err" ::= #(stmError.err' v)
    ]%struct
  |}.

Global Program Instance into_val_typed_stmError : IntoValTyped stmError.t concurrency.stmError :=
{|
  default_val := stmError.mk (default_val _);
|}.
Next Obligation. solve_to_val_type. Qed.
Next Obligation. solve_zero_val. Qed.
Next Obligation. solve_to_val_inj. Qed.
Final Obligation. solve_decision. Qed.

Global Instance into_val_struct_field_stmError_err : IntoValStructField "err" concurrency.stmError stmError.err'.
Proof. solve_into_val_struct_field. Qed.


Context `{!ffi_model, !ffi_semantics _ _, !ffi_interp _, !heapGS Σ}.
Global Instance wp_struct_make_stmError err':
  PureWp True
    (struct.make #concurrency.stmError (alist_val [
      "err" ::= #err'
    ]))%struct
    #(stmError.mk err').
Proof. solve_struct_make_pure_wp. Qed.


Global Instance stmError_struct_fields_split dq l (v : stmError.t) :
  StructFieldsSplit dq l v (
    "Herr" ∷ l ↦s[concurrency.stmError :: "err"]{dq} v.(stmError.err')
  ).
Proof.
  rewrite /named.
  apply struct_fields_split_intro.
  unfold_typed_pointsto; split_pointsto_app.

  rewrite -!/(typed_pointsto_def _ _ _) -!typed_pointsto_unseal.

  solve_field_ref_f.
Qed.

End instances.

(* type concurrency.stmOptions *)
Module stmOptions.
Section def.
Context `{ffi_syntax}.
Record t := mk {
  iso' : Isolation.t;
  ctx' : context.Context.t;
  prefetch' : slice.t;
}.
End def.
End stmOptions.

Section instances.
Context `{ffi_syntax}.

Global Instance settable_stmOptions : Settable stmOptions.t :=
  settable! stmOptions.mk < stmOptions.iso'; stmOptions.ctx'; stmOptions.prefetch' >.
Global Instance into_val_stmOptions : IntoVal stmOptions.t :=
  {| to_val_def v :=
    struct.val_aux concurrency.stmOptions [
    "iso" ::= #(stmOptions.iso' v);
    "ctx" ::= #(stmOptions.ctx' v);
    "prefetch" ::= #(stmOptions.prefetch' v)
    ]%struct
  |}.

Global Program Instance into_val_typed_stmOptions : IntoValTyped stmOptions.t concurrency.stmOptions :=
{|
  default_val := stmOptions.mk (default_val _) (default_val _) (default_val _);
|}.
Next Obligation. solve_to_val_type. Qed.
Next Obligation. solve_zero_val. Qed.
Next Obligation. solve_to_val_inj. Qed.
Final Obligation. solve_decision. Qed.

Global Instance into_val_struct_field_stmOptions_iso : IntoValStructField "iso" concurrency.stmOptions stmOptions.iso'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_stmOptions_ctx : IntoValStructField "ctx" concurrency.stmOptions stmOptions.ctx'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_stmOptions_prefetch : IntoValStructField "prefetch" concurrency.stmOptions stmOptions.prefetch'.
Proof. solve_into_val_struct_field. Qed.


Context `{!ffi_model, !ffi_semantics _ _, !ffi_interp _, !heapGS Σ}.
Global Instance wp_struct_make_stmOptions iso' ctx' prefetch':
  PureWp True
    (struct.make #concurrency.stmOptions (alist_val [
      "iso" ::= #iso';
      "ctx" ::= #ctx';
      "prefetch" ::= #prefetch'
    ]))%struct
    #(stmOptions.mk iso' ctx' prefetch').
Proof. solve_struct_make_pure_wp. Qed.


Global Instance stmOptions_struct_fields_split dq l (v : stmOptions.t) :
  StructFieldsSplit dq l v (
    "Hiso" ∷ l ↦s[concurrency.stmOptions :: "iso"]{dq} v.(stmOptions.iso') ∗
    "Hctx" ∷ l ↦s[concurrency.stmOptions :: "ctx"]{dq} v.(stmOptions.ctx') ∗
    "Hprefetch" ∷ l ↦s[concurrency.stmOptions :: "prefetch"]{dq} v.(stmOptions.prefetch')
  ).
Proof.
  rewrite /named.
  apply struct_fields_split_intro.
  unfold_typed_pointsto; split_pointsto_app.

  rewrite -!/(typed_pointsto_def _ _ _) -!typed_pointsto_unseal.
  simpl_one_flatten_struct (# (stmOptions.iso' v)) concurrency.stmOptions "iso"%go.
  simpl_one_flatten_struct (# (stmOptions.ctx' v)) concurrency.stmOptions "ctx"%go.

  solve_field_ref_f.
Qed.

End instances.

(* type concurrency.stmOption *)
Module stmOption.
Section def.
Context `{ffi_syntax}.
Definition t := func.t.
End def.
End stmOption.

(* type concurrency.stmResponse *)
Module stmResponse.
Section def.
Context `{ffi_syntax}.
Record t := mk {
  resp' : loc;
  err' : error.t;
}.
End def.
End stmResponse.

Section instances.
Context `{ffi_syntax}.

Global Instance settable_stmResponse : Settable stmResponse.t :=
  settable! stmResponse.mk < stmResponse.resp'; stmResponse.err' >.
Global Instance into_val_stmResponse : IntoVal stmResponse.t :=
  {| to_val_def v :=
    struct.val_aux concurrency.stmResponse [
    "resp" ::= #(stmResponse.resp' v);
    "err" ::= #(stmResponse.err' v)
    ]%struct
  |}.

Global Program Instance into_val_typed_stmResponse : IntoValTyped stmResponse.t concurrency.stmResponse :=
{|
  default_val := stmResponse.mk (default_val _) (default_val _);
|}.
Next Obligation. solve_to_val_type. Qed.
Next Obligation. solve_zero_val. Qed.
Next Obligation. solve_to_val_inj. Qed.
Final Obligation. solve_decision. Qed.

Global Instance into_val_struct_field_stmResponse_resp : IntoValStructField "resp" concurrency.stmResponse stmResponse.resp'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_stmResponse_err : IntoValStructField "err" concurrency.stmResponse stmResponse.err'.
Proof. solve_into_val_struct_field. Qed.


Context `{!ffi_model, !ffi_semantics _ _, !ffi_interp _, !heapGS Σ}.
Global Instance wp_struct_make_stmResponse resp' err':
  PureWp True
    (struct.make #concurrency.stmResponse (alist_val [
      "resp" ::= #resp';
      "err" ::= #err'
    ]))%struct
    #(stmResponse.mk resp' err').
Proof. solve_struct_make_pure_wp. Qed.


Global Instance stmResponse_struct_fields_split dq l (v : stmResponse.t) :
  StructFieldsSplit dq l v (
    "Hresp" ∷ l ↦s[concurrency.stmResponse :: "resp"]{dq} v.(stmResponse.resp') ∗
    "Herr" ∷ l ↦s[concurrency.stmResponse :: "err"]{dq} v.(stmResponse.err')
  ).
Proof.
  rewrite /named.
  apply struct_fields_split_intro.
  unfold_typed_pointsto; split_pointsto_app.

  rewrite -!/(typed_pointsto_def _ _ _) -!typed_pointsto_unseal.
  simpl_one_flatten_struct (# (stmResponse.resp' v)) concurrency.stmResponse "resp"%go.

  solve_field_ref_f.
Qed.

End instances.

(* type concurrency.readSet *)
Module readSet.
Section def.
Context `{ffi_syntax}.
Definition t := loc.
End def.
End readSet.

(* type concurrency.writeSet *)
Module writeSet.
Section def.
Context `{ffi_syntax}.
Definition t := loc.
End def.
End writeSet.

(* type concurrency.stm *)
Module stm.
Section def.
Context `{ffi_syntax}.
Record t := mk {
  client' : loc;
  ctx' : context.Context.t;
  rset' : readSet.t;
  wset' : writeSet.t;
  getOpts' : slice.t;
  conflicts' : func.t;
}.
End def.
End stm.

Section instances.
Context `{ffi_syntax}.

Global Instance settable_stm : Settable stm.t :=
  settable! stm.mk < stm.client'; stm.ctx'; stm.rset'; stm.wset'; stm.getOpts'; stm.conflicts' >.
Global Instance into_val_stm : IntoVal stm.t :=
  {| to_val_def v :=
    struct.val_aux concurrency.stm [
    "client" ::= #(stm.client' v);
    "ctx" ::= #(stm.ctx' v);
    "rset" ::= #(stm.rset' v);
    "wset" ::= #(stm.wset' v);
    "getOpts" ::= #(stm.getOpts' v);
    "conflicts" ::= #(stm.conflicts' v)
    ]%struct
  |}.

Global Program Instance into_val_typed_stm : IntoValTyped stm.t concurrency.stm :=
{|
  default_val := stm.mk (default_val _) (default_val _) (default_val _) (default_val _) (default_val _) (default_val _);
|}.
Next Obligation. solve_to_val_type. Qed.
Next Obligation. solve_zero_val. Qed.
Next Obligation. solve_to_val_inj. Qed.
Final Obligation. solve_decision. Qed.

Global Instance into_val_struct_field_stm_client : IntoValStructField "client" concurrency.stm stm.client'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_stm_ctx : IntoValStructField "ctx" concurrency.stm stm.ctx'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_stm_rset : IntoValStructField "rset" concurrency.stm stm.rset'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_stm_wset : IntoValStructField "wset" concurrency.stm stm.wset'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_stm_getOpts : IntoValStructField "getOpts" concurrency.stm stm.getOpts'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_stm_conflicts : IntoValStructField "conflicts" concurrency.stm stm.conflicts'.
Proof. solve_into_val_struct_field. Qed.


Context `{!ffi_model, !ffi_semantics _ _, !ffi_interp _, !heapGS Σ}.
Global Instance wp_struct_make_stm client' ctx' rset' wset' getOpts' conflicts':
  PureWp True
    (struct.make #concurrency.stm (alist_val [
      "client" ::= #client';
      "ctx" ::= #ctx';
      "rset" ::= #rset';
      "wset" ::= #wset';
      "getOpts" ::= #getOpts';
      "conflicts" ::= #conflicts'
    ]))%struct
    #(stm.mk client' ctx' rset' wset' getOpts' conflicts').
Proof. solve_struct_make_pure_wp. Qed.


Global Instance stm_struct_fields_split dq l (v : stm.t) :
  StructFieldsSplit dq l v (
    "Hclient" ∷ l ↦s[concurrency.stm :: "client"]{dq} v.(stm.client') ∗
    "Hctx" ∷ l ↦s[concurrency.stm :: "ctx"]{dq} v.(stm.ctx') ∗
    "Hrset" ∷ l ↦s[concurrency.stm :: "rset"]{dq} v.(stm.rset') ∗
    "Hwset" ∷ l ↦s[concurrency.stm :: "wset"]{dq} v.(stm.wset') ∗
    "HgetOpts" ∷ l ↦s[concurrency.stm :: "getOpts"]{dq} v.(stm.getOpts') ∗
    "Hconflicts" ∷ l ↦s[concurrency.stm :: "conflicts"]{dq} v.(stm.conflicts')
  ).
Proof.
  rewrite /named.
  apply struct_fields_split_intro.
  unfold_typed_pointsto; split_pointsto_app.

  rewrite -!/(typed_pointsto_def _ _ _) -!typed_pointsto_unseal.
  simpl_one_flatten_struct (# (stm.client' v)) concurrency.stm "client"%go.
  simpl_one_flatten_struct (# (stm.ctx' v)) concurrency.stm "ctx"%go.
  simpl_one_flatten_struct (# (stm.rset' v)) concurrency.stm "rset"%go.
  simpl_one_flatten_struct (# (stm.wset' v)) concurrency.stm "wset"%go.
  simpl_one_flatten_struct (# (stm.getOpts' v)) concurrency.stm "getOpts"%go.

  solve_field_ref_f.
Qed.

End instances.

(* type concurrency.stmPut *)
Module stmPut.
Section def.
Context `{ffi_syntax}.
Record t := mk {
  val' : go_string;
  op' : clientv3.Op.t;
}.
End def.
End stmPut.

Section instances.
Context `{ffi_syntax}.

Global Instance settable_stmPut : Settable stmPut.t :=
  settable! stmPut.mk < stmPut.val'; stmPut.op' >.
Global Instance into_val_stmPut : IntoVal stmPut.t :=
  {| to_val_def v :=
    struct.val_aux concurrency.stmPut [
    "val" ::= #(stmPut.val' v);
    "op" ::= #(stmPut.op' v)
    ]%struct
  |}.

Global Program Instance into_val_typed_stmPut : IntoValTyped stmPut.t concurrency.stmPut :=
{|
  default_val := stmPut.mk (default_val _) (default_val _);
|}.
Next Obligation. solve_to_val_type. Qed.
Next Obligation. solve_zero_val. Qed.
Next Obligation. solve_to_val_inj. Qed.
Final Obligation. solve_decision. Qed.

Global Instance into_val_struct_field_stmPut_val : IntoValStructField "val" concurrency.stmPut stmPut.val'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_stmPut_op : IntoValStructField "op" concurrency.stmPut stmPut.op'.
Proof. solve_into_val_struct_field. Qed.


Context `{!ffi_model, !ffi_semantics _ _, !ffi_interp _, !heapGS Σ}.
Global Instance wp_struct_make_stmPut val' op':
  PureWp True
    (struct.make #concurrency.stmPut (alist_val [
      "val" ::= #val';
      "op" ::= #op'
    ]))%struct
    #(stmPut.mk val' op').
Proof. solve_struct_make_pure_wp. Qed.


Global Instance stmPut_struct_fields_split dq l (v : stmPut.t) :
  StructFieldsSplit dq l v (
    "Hval" ∷ l ↦s[concurrency.stmPut :: "val"]{dq} v.(stmPut.val') ∗
    "Hop" ∷ l ↦s[concurrency.stmPut :: "op"]{dq} v.(stmPut.op')
  ).
Proof.
  rewrite /named.
  apply struct_fields_split_intro.
  unfold_typed_pointsto; split_pointsto_app.

  rewrite -!/(typed_pointsto_def _ _ _) -!typed_pointsto_unseal.
  simpl_one_flatten_struct (# (stmPut.val' v)) concurrency.stmPut "val"%go.

  solve_field_ref_f.
Qed.

End instances.

(* type concurrency.stmSerializable *)
Module stmSerializable.
Section def.
Context `{ffi_syntax}.
Record t := mk {
  stm' : stm.t;
  prefetch' : loc;
}.
End def.
End stmSerializable.

Section instances.
Context `{ffi_syntax}.

Global Instance settable_stmSerializable : Settable stmSerializable.t :=
  settable! stmSerializable.mk < stmSerializable.stm'; stmSerializable.prefetch' >.
Global Instance into_val_stmSerializable : IntoVal stmSerializable.t :=
  {| to_val_def v :=
    struct.val_aux concurrency.stmSerializable [
    "stm" ::= #(stmSerializable.stm' v);
    "prefetch" ::= #(stmSerializable.prefetch' v)
    ]%struct
  |}.

Global Program Instance into_val_typed_stmSerializable : IntoValTyped stmSerializable.t concurrency.stmSerializable :=
{|
  default_val := stmSerializable.mk (default_val _) (default_val _);
|}.
Next Obligation. solve_to_val_type. Qed.
Next Obligation. solve_zero_val. Qed.
Next Obligation. solve_to_val_inj. Qed.
Final Obligation. solve_decision. Qed.

Global Instance into_val_struct_field_stmSerializable_stm : IntoValStructField "stm" concurrency.stmSerializable stmSerializable.stm'.
Proof. solve_into_val_struct_field. Qed.

Global Instance into_val_struct_field_stmSerializable_prefetch : IntoValStructField "prefetch" concurrency.stmSerializable stmSerializable.prefetch'.
Proof. solve_into_val_struct_field. Qed.


Context `{!ffi_model, !ffi_semantics _ _, !ffi_interp _, !heapGS Σ}.
Global Instance wp_struct_make_stmSerializable stm' prefetch':
  PureWp True
    (struct.make #concurrency.stmSerializable (alist_val [
      "stm" ::= #stm';
      "prefetch" ::= #prefetch'
    ]))%struct
    #(stmSerializable.mk stm' prefetch').
Proof. solve_struct_make_pure_wp. Qed.


Global Instance stmSerializable_struct_fields_split dq l (v : stmSerializable.t) :
  StructFieldsSplit dq l v (
    "Hstm" ∷ l ↦s[concurrency.stmSerializable :: "stm"]{dq} v.(stmSerializable.stm') ∗
    "Hprefetch" ∷ l ↦s[concurrency.stmSerializable :: "prefetch"]{dq} v.(stmSerializable.prefetch')
  ).
Proof.
  rewrite /named.
  apply struct_fields_split_intro.
  unfold_typed_pointsto; split_pointsto_app.

  rewrite -!/(typed_pointsto_def _ _ _) -!typed_pointsto_unseal.
  simpl_one_flatten_struct (# (stmSerializable.stm' v)) concurrency.stmSerializable "stm"%go.

  solve_field_ref_f.
Qed.

End instances.

Section names.

Class GlobalAddrs :=
{
  ErrElectionNotLeader : loc;
  ErrElectionNoLeader : loc;
  ErrLocked : loc;
  ErrSessionExpired : loc;
  ErrLockReleased : loc;
}.

Context `{!GlobalAddrs}.
Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context `{!goGlobalsGS Σ}.

Definition var_addrs : list (go_string * loc) := [
    ("ErrElectionNotLeader"%go, ErrElectionNotLeader);
    ("ErrElectionNoLeader"%go, ErrElectionNoLeader);
    ("ErrLocked"%go, ErrLocked);
    ("ErrSessionExpired"%go, ErrSessionExpired);
    ("ErrLockReleased"%go, ErrLockReleased)
  ].

Global Instance is_pkg_defined_instance : IsPkgDefined concurrency :=
{|
  is_pkg_defined := is_global_definitions concurrency var_addrs;
|}.

Definition own_allocated : iProp Σ :=
  "HErrElectionNotLeader" ∷ ErrElectionNotLeader ↦ (default_val error.t) ∗
  "HErrElectionNoLeader" ∷ ErrElectionNoLeader ↦ (default_val error.t) ∗
  "HErrLocked" ∷ ErrLocked ↦ (default_val error.t) ∗
  "HErrSessionExpired" ∷ ErrSessionExpired ↦ (default_val error.t) ∗
  "HErrLockReleased" ∷ ErrLockReleased ↦ (default_val error.t).

Global Instance wp_globals_get_ErrElectionNotLeader : 
  WpGlobalsGet concurrency "ErrElectionNotLeader" ErrElectionNotLeader (is_pkg_defined concurrency).
Proof. apply wp_globals_get'. reflexivity. Qed.

Global Instance wp_globals_get_ErrElectionNoLeader : 
  WpGlobalsGet concurrency "ErrElectionNoLeader" ErrElectionNoLeader (is_pkg_defined concurrency).
Proof. apply wp_globals_get'. reflexivity. Qed.

Global Instance wp_globals_get_ErrLocked : 
  WpGlobalsGet concurrency "ErrLocked" ErrLocked (is_pkg_defined concurrency).
Proof. apply wp_globals_get'. reflexivity. Qed.

Global Instance wp_globals_get_ErrSessionExpired : 
  WpGlobalsGet concurrency "ErrSessionExpired" ErrSessionExpired (is_pkg_defined concurrency).
Proof. apply wp_globals_get'. reflexivity. Qed.

Global Instance wp_globals_get_ErrLockReleased : 
  WpGlobalsGet concurrency "ErrLockReleased" ErrLockReleased (is_pkg_defined concurrency).
Proof. apply wp_globals_get'. reflexivity. Qed.

Global Instance wp_func_call_NewElection :
  WpFuncCall concurrency "NewElection" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_func_call'; reflexivity).

Global Instance wp_func_call_ResumeElection :
  WpFuncCall concurrency "ResumeElection" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_func_call'; reflexivity).

Global Instance wp_func_call_waitDelete :
  WpFuncCall concurrency "waitDelete" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_func_call'; reflexivity).

Global Instance wp_func_call_waitDeletes :
  WpFuncCall concurrency "waitDeletes" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_func_call'; reflexivity).

Global Instance wp_func_call_NewMutex :
  WpFuncCall concurrency "NewMutex" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_func_call'; reflexivity).

Global Instance wp_func_call_NewLocker :
  WpFuncCall concurrency "NewLocker" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_func_call'; reflexivity).

Global Instance wp_func_call_NewSession :
  WpFuncCall concurrency "NewSession" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_func_call'; reflexivity).

Global Instance wp_func_call_WithTTL :
  WpFuncCall concurrency "WithTTL" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_func_call'; reflexivity).

Global Instance wp_func_call_WithLease :
  WpFuncCall concurrency "WithLease" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_func_call'; reflexivity).

Global Instance wp_func_call_WithContext :
  WpFuncCall concurrency "WithContext" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_func_call'; reflexivity).

Global Instance wp_func_call_WithIsolation :
  WpFuncCall concurrency "WithIsolation" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_func_call'; reflexivity).

Global Instance wp_func_call_WithAbortContext :
  WpFuncCall concurrency "WithAbortContext" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_func_call'; reflexivity).

Global Instance wp_func_call_WithPrefetch :
  WpFuncCall concurrency "WithPrefetch" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_func_call'; reflexivity).

Global Instance wp_func_call_NewSTM :
  WpFuncCall concurrency "NewSTM" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_func_call'; reflexivity).

Global Instance wp_func_call_mkSTM :
  WpFuncCall concurrency "mkSTM" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_func_call'; reflexivity).

Global Instance wp_func_call_runSTM :
  WpFuncCall concurrency "runSTM" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_func_call'; reflexivity).

Global Instance wp_func_call_isKeyCurrent :
  WpFuncCall concurrency "isKeyCurrent" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_func_call'; reflexivity).

Global Instance wp_func_call_respToValue :
  WpFuncCall concurrency "respToValue" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_func_call'; reflexivity).

Global Instance wp_func_call_NewSTMRepeatable :
  WpFuncCall concurrency "NewSTMRepeatable" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_func_call'; reflexivity).

Global Instance wp_func_call_NewSTMSerializable :
  WpFuncCall concurrency "NewSTMSerializable" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_func_call'; reflexivity).

Global Instance wp_func_call_NewSTMReadCommitted :
  WpFuncCall concurrency "NewSTMReadCommitted" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_func_call'; reflexivity).

Global Instance wp_method_call_Election'ptr_Campaign :
  WpMethodCall concurrency "Election'ptr" "Campaign" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_Election'ptr_Header :
  WpMethodCall concurrency "Election'ptr" "Header" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_Election'ptr_Key :
  WpMethodCall concurrency "Election'ptr" "Key" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_Election'ptr_Leader :
  WpMethodCall concurrency "Election'ptr" "Leader" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_Election'ptr_Observe :
  WpMethodCall concurrency "Election'ptr" "Observe" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_Election'ptr_Proclaim :
  WpMethodCall concurrency "Election'ptr" "Proclaim" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_Election'ptr_Resign :
  WpMethodCall concurrency "Election'ptr" "Resign" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_Election'ptr_Rev :
  WpMethodCall concurrency "Election'ptr" "Rev" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_Election'ptr_observe :
  WpMethodCall concurrency "Election'ptr" "observe" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_Mutex'ptr_Header :
  WpMethodCall concurrency "Mutex'ptr" "Header" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_Mutex'ptr_IsOwner :
  WpMethodCall concurrency "Mutex'ptr" "IsOwner" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_Mutex'ptr_Key :
  WpMethodCall concurrency "Mutex'ptr" "Key" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_Mutex'ptr_Lock :
  WpMethodCall concurrency "Mutex'ptr" "Lock" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_Mutex'ptr_TryLock :
  WpMethodCall concurrency "Mutex'ptr" "TryLock" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_Mutex'ptr_Unlock :
  WpMethodCall concurrency "Mutex'ptr" "Unlock" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_Mutex'ptr_tryAcquire :
  WpMethodCall concurrency "Mutex'ptr" "tryAcquire" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_lockerMutex_Header :
  WpMethodCall concurrency "lockerMutex" "Header" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_lockerMutex_IsOwner :
  WpMethodCall concurrency "lockerMutex" "IsOwner" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_lockerMutex_Key :
  WpMethodCall concurrency "lockerMutex" "Key" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_lockerMutex_TryLock :
  WpMethodCall concurrency "lockerMutex" "TryLock" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_lockerMutex_tryAcquire :
  WpMethodCall concurrency "lockerMutex" "tryAcquire" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_lockerMutex'ptr_Header :
  WpMethodCall concurrency "lockerMutex'ptr" "Header" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_lockerMutex'ptr_IsOwner :
  WpMethodCall concurrency "lockerMutex'ptr" "IsOwner" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_lockerMutex'ptr_Key :
  WpMethodCall concurrency "lockerMutex'ptr" "Key" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_lockerMutex'ptr_Lock :
  WpMethodCall concurrency "lockerMutex'ptr" "Lock" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_lockerMutex'ptr_TryLock :
  WpMethodCall concurrency "lockerMutex'ptr" "TryLock" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_lockerMutex'ptr_Unlock :
  WpMethodCall concurrency "lockerMutex'ptr" "Unlock" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_lockerMutex'ptr_tryAcquire :
  WpMethodCall concurrency "lockerMutex'ptr" "tryAcquire" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_Session'ptr_Client :
  WpMethodCall concurrency "Session'ptr" "Client" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_Session'ptr_Close :
  WpMethodCall concurrency "Session'ptr" "Close" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_Session'ptr_Ctx :
  WpMethodCall concurrency "Session'ptr" "Ctx" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_Session'ptr_Done :
  WpMethodCall concurrency "Session'ptr" "Done" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_Session'ptr_Lease :
  WpMethodCall concurrency "Session'ptr" "Lease" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_Session'ptr_Orphan :
  WpMethodCall concurrency "Session'ptr" "Orphan" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_stm'ptr_Del :
  WpMethodCall concurrency "stm'ptr" "Del" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_stm'ptr_Get :
  WpMethodCall concurrency "stm'ptr" "Get" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_stm'ptr_Put :
  WpMethodCall concurrency "stm'ptr" "Put" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_stm'ptr_Rev :
  WpMethodCall concurrency "stm'ptr" "Rev" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_stm'ptr_commit :
  WpMethodCall concurrency "stm'ptr" "commit" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_stm'ptr_fetch :
  WpMethodCall concurrency "stm'ptr" "fetch" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_stm'ptr_reset :
  WpMethodCall concurrency "stm'ptr" "reset" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_readSet_add :
  WpMethodCall concurrency "readSet" "add" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_readSet_cmps :
  WpMethodCall concurrency "readSet" "cmps" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_readSet_first :
  WpMethodCall concurrency "readSet" "first" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_readSet'ptr_add :
  WpMethodCall concurrency "readSet'ptr" "add" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_readSet'ptr_cmps :
  WpMethodCall concurrency "readSet'ptr" "cmps" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_readSet'ptr_first :
  WpMethodCall concurrency "readSet'ptr" "first" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_writeSet_cmps :
  WpMethodCall concurrency "writeSet" "cmps" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_writeSet_get :
  WpMethodCall concurrency "writeSet" "get" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_writeSet_puts :
  WpMethodCall concurrency "writeSet" "puts" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_writeSet'ptr_cmps :
  WpMethodCall concurrency "writeSet'ptr" "cmps" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_writeSet'ptr_get :
  WpMethodCall concurrency "writeSet'ptr" "get" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_writeSet'ptr_puts :
  WpMethodCall concurrency "writeSet'ptr" "puts" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_stmSerializable'ptr_Del :
  WpMethodCall concurrency "stmSerializable'ptr" "Del" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_stmSerializable'ptr_Get :
  WpMethodCall concurrency "stmSerializable'ptr" "Get" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_stmSerializable'ptr_Put :
  WpMethodCall concurrency "stmSerializable'ptr" "Put" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_stmSerializable'ptr_Rev :
  WpMethodCall concurrency "stmSerializable'ptr" "Rev" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_stmSerializable'ptr_commit :
  WpMethodCall concurrency "stmSerializable'ptr" "commit" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_stmSerializable'ptr_fetch :
  WpMethodCall concurrency "stmSerializable'ptr" "fetch" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_stmSerializable'ptr_gets :
  WpMethodCall concurrency "stmSerializable'ptr" "gets" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_method_call'; reflexivity).

Global Instance wp_method_call_stmSerializable'ptr_reset :
  WpMethodCall concurrency "stmSerializable'ptr" "reset" _ (is_pkg_defined concurrency) :=
  ltac:(apply wp_method_call'; reflexivity).

End names.
End concurrency.
