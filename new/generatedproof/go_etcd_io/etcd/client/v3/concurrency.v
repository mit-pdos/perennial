(* autogenerated by goose proofgen; do not modify *)
Require Export New.proof.proof_prelude.
Require Export New.generatedproof.context.
Require Export New.generatedproof.errors.
Require Export New.generatedproof.fmt.
Require Export New.generatedproof.go_etcd_io.etcd.api.v3.etcdserverpb.
Require Export New.generatedproof.go_etcd_io.etcd.api.v3.mvccpb.
Require Export New.generatedproof.go_etcd_io.etcd.client.v3.
Require Export New.generatedproof.go_uber_org.zap.
Require Export New.generatedproof.math.
Require Export New.generatedproof.strings.
Require Export New.generatedproof.sync.
Require Export New.generatedproof.time.
Require Export New.golang.theory.
Require Export New.code.go_etcd_io.etcd.client.v3.concurrency.

Set Default Proof Using "Type".

Module concurrency.
Module Election.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : concurrency.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance Election_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (concurrency.Election.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "session" ∷ l.[(concurrency.Election.t), "session"] ↦{dq} v.(concurrency.Election.session') ∗
      "keyPrefix" ∷ l.[(concurrency.Election.t), "keyPrefix"] ↦{dq} v.(concurrency.Election.keyPrefix') ∗
      "leaderKey" ∷ l.[(concurrency.Election.t), "leaderKey"] ↦{dq} v.(concurrency.Election.leaderKey') ∗
      "leaderRev" ∷ l.[(concurrency.Election.t), "leaderRev"] ↦{dq} v.(concurrency.Election.leaderRev') ∗
      "leaderSession" ∷ l.[(concurrency.Election.t), "leaderSession"] ↦{dq} v.(concurrency.Election.leaderSession') ∗
      "hdr" ∷ l.[(concurrency.Election.t), "hdr"] ↦{dq} v.(concurrency.Election.hdr') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance Election_into_val_typed
   :
  IntoValTypedUnderlying (concurrency.Election.t) (concurrency.Electionⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance Election_access_load_session l (v : (concurrency.Election.t)) dq :
  AccessStrict
    (l.[(concurrency.Election.t), "session"] ↦{dq} (v.(concurrency.Election.session')))
    (l.[(concurrency.Election.t), "session"] ↦{dq} (v.(concurrency.Election.session')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Election_access_store_session l (v : (concurrency.Election.t)) session' :
  AccessStrict
    (l.[(concurrency.Election.t), "session"] ↦ (v.(concurrency.Election.session')))
    (l.[(concurrency.Election.t), "session"] ↦ session')
    (l ↦ v) (l ↦ (v <|(concurrency.Election.session') := session'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Election_access_load_keyPrefix l (v : (concurrency.Election.t)) dq :
  AccessStrict
    (l.[(concurrency.Election.t), "keyPrefix"] ↦{dq} (v.(concurrency.Election.keyPrefix')))
    (l.[(concurrency.Election.t), "keyPrefix"] ↦{dq} (v.(concurrency.Election.keyPrefix')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Election_access_store_keyPrefix l (v : (concurrency.Election.t)) keyPrefix' :
  AccessStrict
    (l.[(concurrency.Election.t), "keyPrefix"] ↦ (v.(concurrency.Election.keyPrefix')))
    (l.[(concurrency.Election.t), "keyPrefix"] ↦ keyPrefix')
    (l ↦ v) (l ↦ (v <|(concurrency.Election.keyPrefix') := keyPrefix'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Election_access_load_leaderKey l (v : (concurrency.Election.t)) dq :
  AccessStrict
    (l.[(concurrency.Election.t), "leaderKey"] ↦{dq} (v.(concurrency.Election.leaderKey')))
    (l.[(concurrency.Election.t), "leaderKey"] ↦{dq} (v.(concurrency.Election.leaderKey')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Election_access_store_leaderKey l (v : (concurrency.Election.t)) leaderKey' :
  AccessStrict
    (l.[(concurrency.Election.t), "leaderKey"] ↦ (v.(concurrency.Election.leaderKey')))
    (l.[(concurrency.Election.t), "leaderKey"] ↦ leaderKey')
    (l ↦ v) (l ↦ (v <|(concurrency.Election.leaderKey') := leaderKey'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Election_access_load_leaderRev l (v : (concurrency.Election.t)) dq :
  AccessStrict
    (l.[(concurrency.Election.t), "leaderRev"] ↦{dq} (v.(concurrency.Election.leaderRev')))
    (l.[(concurrency.Election.t), "leaderRev"] ↦{dq} (v.(concurrency.Election.leaderRev')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Election_access_store_leaderRev l (v : (concurrency.Election.t)) leaderRev' :
  AccessStrict
    (l.[(concurrency.Election.t), "leaderRev"] ↦ (v.(concurrency.Election.leaderRev')))
    (l.[(concurrency.Election.t), "leaderRev"] ↦ leaderRev')
    (l ↦ v) (l ↦ (v <|(concurrency.Election.leaderRev') := leaderRev'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Election_access_load_leaderSession l (v : (concurrency.Election.t)) dq :
  AccessStrict
    (l.[(concurrency.Election.t), "leaderSession"] ↦{dq} (v.(concurrency.Election.leaderSession')))
    (l.[(concurrency.Election.t), "leaderSession"] ↦{dq} (v.(concurrency.Election.leaderSession')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Election_access_store_leaderSession l (v : (concurrency.Election.t)) leaderSession' :
  AccessStrict
    (l.[(concurrency.Election.t), "leaderSession"] ↦ (v.(concurrency.Election.leaderSession')))
    (l.[(concurrency.Election.t), "leaderSession"] ↦ leaderSession')
    (l ↦ v) (l ↦ (v <|(concurrency.Election.leaderSession') := leaderSession'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Election_access_load_hdr l (v : (concurrency.Election.t)) dq :
  AccessStrict
    (l.[(concurrency.Election.t), "hdr"] ↦{dq} (v.(concurrency.Election.hdr')))
    (l.[(concurrency.Election.t), "hdr"] ↦{dq} (v.(concurrency.Election.hdr')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Election_access_store_hdr l (v : (concurrency.Election.t)) hdr' :
  AccessStrict
    (l.[(concurrency.Election.t), "hdr"] ↦ (v.(concurrency.Election.hdr')))
    (l.[(concurrency.Election.t), "hdr"] ↦ hdr')
    (l ↦ v) (l ↦ (v <|(concurrency.Election.hdr') := hdr'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End Election.

Module Mutex.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : concurrency.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance Mutex_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (concurrency.Mutex.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "s" ∷ l.[(concurrency.Mutex.t), "s"] ↦{dq} v.(concurrency.Mutex.s') ∗
      "pfx" ∷ l.[(concurrency.Mutex.t), "pfx"] ↦{dq} v.(concurrency.Mutex.pfx') ∗
      "myKey" ∷ l.[(concurrency.Mutex.t), "myKey"] ↦{dq} v.(concurrency.Mutex.myKey') ∗
      "myRev" ∷ l.[(concurrency.Mutex.t), "myRev"] ↦{dq} v.(concurrency.Mutex.myRev') ∗
      "hdr" ∷ l.[(concurrency.Mutex.t), "hdr"] ↦{dq} v.(concurrency.Mutex.hdr') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance Mutex_into_val_typed
   :
  IntoValTypedUnderlying (concurrency.Mutex.t) (concurrency.Mutexⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance Mutex_access_load_s l (v : (concurrency.Mutex.t)) dq :
  AccessStrict
    (l.[(concurrency.Mutex.t), "s"] ↦{dq} (v.(concurrency.Mutex.s')))
    (l.[(concurrency.Mutex.t), "s"] ↦{dq} (v.(concurrency.Mutex.s')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Mutex_access_store_s l (v : (concurrency.Mutex.t)) s' :
  AccessStrict
    (l.[(concurrency.Mutex.t), "s"] ↦ (v.(concurrency.Mutex.s')))
    (l.[(concurrency.Mutex.t), "s"] ↦ s')
    (l ↦ v) (l ↦ (v <|(concurrency.Mutex.s') := s'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Mutex_access_load_pfx l (v : (concurrency.Mutex.t)) dq :
  AccessStrict
    (l.[(concurrency.Mutex.t), "pfx"] ↦{dq} (v.(concurrency.Mutex.pfx')))
    (l.[(concurrency.Mutex.t), "pfx"] ↦{dq} (v.(concurrency.Mutex.pfx')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Mutex_access_store_pfx l (v : (concurrency.Mutex.t)) pfx' :
  AccessStrict
    (l.[(concurrency.Mutex.t), "pfx"] ↦ (v.(concurrency.Mutex.pfx')))
    (l.[(concurrency.Mutex.t), "pfx"] ↦ pfx')
    (l ↦ v) (l ↦ (v <|(concurrency.Mutex.pfx') := pfx'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Mutex_access_load_myKey l (v : (concurrency.Mutex.t)) dq :
  AccessStrict
    (l.[(concurrency.Mutex.t), "myKey"] ↦{dq} (v.(concurrency.Mutex.myKey')))
    (l.[(concurrency.Mutex.t), "myKey"] ↦{dq} (v.(concurrency.Mutex.myKey')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Mutex_access_store_myKey l (v : (concurrency.Mutex.t)) myKey' :
  AccessStrict
    (l.[(concurrency.Mutex.t), "myKey"] ↦ (v.(concurrency.Mutex.myKey')))
    (l.[(concurrency.Mutex.t), "myKey"] ↦ myKey')
    (l ↦ v) (l ↦ (v <|(concurrency.Mutex.myKey') := myKey'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Mutex_access_load_myRev l (v : (concurrency.Mutex.t)) dq :
  AccessStrict
    (l.[(concurrency.Mutex.t), "myRev"] ↦{dq} (v.(concurrency.Mutex.myRev')))
    (l.[(concurrency.Mutex.t), "myRev"] ↦{dq} (v.(concurrency.Mutex.myRev')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Mutex_access_store_myRev l (v : (concurrency.Mutex.t)) myRev' :
  AccessStrict
    (l.[(concurrency.Mutex.t), "myRev"] ↦ (v.(concurrency.Mutex.myRev')))
    (l.[(concurrency.Mutex.t), "myRev"] ↦ myRev')
    (l ↦ v) (l ↦ (v <|(concurrency.Mutex.myRev') := myRev'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Mutex_access_load_hdr l (v : (concurrency.Mutex.t)) dq :
  AccessStrict
    (l.[(concurrency.Mutex.t), "hdr"] ↦{dq} (v.(concurrency.Mutex.hdr')))
    (l.[(concurrency.Mutex.t), "hdr"] ↦{dq} (v.(concurrency.Mutex.hdr')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Mutex_access_store_hdr l (v : (concurrency.Mutex.t)) hdr' :
  AccessStrict
    (l.[(concurrency.Mutex.t), "hdr"] ↦ (v.(concurrency.Mutex.hdr')))
    (l.[(concurrency.Mutex.t), "hdr"] ↦ hdr')
    (l ↦ v) (l ↦ (v <|(concurrency.Mutex.hdr') := hdr'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End Mutex.

Module lockerMutex.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : concurrency.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance lockerMutex_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (concurrency.lockerMutex.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "Mutex" ∷ l.[(concurrency.lockerMutex.t), "Mutex"] ↦{dq} v.(concurrency.lockerMutex.Mutex') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance lockerMutex_into_val_typed
   :
  IntoValTypedUnderlying (concurrency.lockerMutex.t) (concurrency.lockerMutexⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance lockerMutex_access_load_Mutex l (v : (concurrency.lockerMutex.t)) dq :
  AccessStrict
    (l.[(concurrency.lockerMutex.t), "Mutex"] ↦{dq} (v.(concurrency.lockerMutex.Mutex')))
    (l.[(concurrency.lockerMutex.t), "Mutex"] ↦{dq} (v.(concurrency.lockerMutex.Mutex')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance lockerMutex_access_store_Mutex l (v : (concurrency.lockerMutex.t)) Mutex' :
  AccessStrict
    (l.[(concurrency.lockerMutex.t), "Mutex"] ↦ (v.(concurrency.lockerMutex.Mutex')))
    (l.[(concurrency.lockerMutex.t), "Mutex"] ↦ Mutex')
    (l ↦ v) (l ↦ (v <|(concurrency.lockerMutex.Mutex') := Mutex'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End lockerMutex.

Module Session.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : concurrency.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance Session_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (concurrency.Session.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "client" ∷ l.[(concurrency.Session.t), "client"] ↦{dq} v.(concurrency.Session.client') ∗
      "opts" ∷ l.[(concurrency.Session.t), "opts"] ↦{dq} v.(concurrency.Session.opts') ∗
      "id" ∷ l.[(concurrency.Session.t), "id"] ↦{dq} v.(concurrency.Session.id') ∗
      "ctx" ∷ l.[(concurrency.Session.t), "ctx"] ↦{dq} v.(concurrency.Session.ctx') ∗
      "cancel" ∷ l.[(concurrency.Session.t), "cancel"] ↦{dq} v.(concurrency.Session.cancel') ∗
      "donec" ∷ l.[(concurrency.Session.t), "donec"] ↦{dq} v.(concurrency.Session.donec') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance Session_into_val_typed
   :
  IntoValTypedUnderlying (concurrency.Session.t) (concurrency.Sessionⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance Session_access_load_client l (v : (concurrency.Session.t)) dq :
  AccessStrict
    (l.[(concurrency.Session.t), "client"] ↦{dq} (v.(concurrency.Session.client')))
    (l.[(concurrency.Session.t), "client"] ↦{dq} (v.(concurrency.Session.client')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Session_access_store_client l (v : (concurrency.Session.t)) client' :
  AccessStrict
    (l.[(concurrency.Session.t), "client"] ↦ (v.(concurrency.Session.client')))
    (l.[(concurrency.Session.t), "client"] ↦ client')
    (l ↦ v) (l ↦ (v <|(concurrency.Session.client') := client'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Session_access_load_opts l (v : (concurrency.Session.t)) dq :
  AccessStrict
    (l.[(concurrency.Session.t), "opts"] ↦{dq} (v.(concurrency.Session.opts')))
    (l.[(concurrency.Session.t), "opts"] ↦{dq} (v.(concurrency.Session.opts')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Session_access_store_opts l (v : (concurrency.Session.t)) opts' :
  AccessStrict
    (l.[(concurrency.Session.t), "opts"] ↦ (v.(concurrency.Session.opts')))
    (l.[(concurrency.Session.t), "opts"] ↦ opts')
    (l ↦ v) (l ↦ (v <|(concurrency.Session.opts') := opts'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Session_access_load_id l (v : (concurrency.Session.t)) dq :
  AccessStrict
    (l.[(concurrency.Session.t), "id"] ↦{dq} (v.(concurrency.Session.id')))
    (l.[(concurrency.Session.t), "id"] ↦{dq} (v.(concurrency.Session.id')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Session_access_store_id l (v : (concurrency.Session.t)) id' :
  AccessStrict
    (l.[(concurrency.Session.t), "id"] ↦ (v.(concurrency.Session.id')))
    (l.[(concurrency.Session.t), "id"] ↦ id')
    (l ↦ v) (l ↦ (v <|(concurrency.Session.id') := id'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Session_access_load_ctx l (v : (concurrency.Session.t)) dq :
  AccessStrict
    (l.[(concurrency.Session.t), "ctx"] ↦{dq} (v.(concurrency.Session.ctx')))
    (l.[(concurrency.Session.t), "ctx"] ↦{dq} (v.(concurrency.Session.ctx')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Session_access_store_ctx l (v : (concurrency.Session.t)) ctx' :
  AccessStrict
    (l.[(concurrency.Session.t), "ctx"] ↦ (v.(concurrency.Session.ctx')))
    (l.[(concurrency.Session.t), "ctx"] ↦ ctx')
    (l ↦ v) (l ↦ (v <|(concurrency.Session.ctx') := ctx'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Session_access_load_cancel l (v : (concurrency.Session.t)) dq :
  AccessStrict
    (l.[(concurrency.Session.t), "cancel"] ↦{dq} (v.(concurrency.Session.cancel')))
    (l.[(concurrency.Session.t), "cancel"] ↦{dq} (v.(concurrency.Session.cancel')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Session_access_store_cancel l (v : (concurrency.Session.t)) cancel' :
  AccessStrict
    (l.[(concurrency.Session.t), "cancel"] ↦ (v.(concurrency.Session.cancel')))
    (l.[(concurrency.Session.t), "cancel"] ↦ cancel')
    (l ↦ v) (l ↦ (v <|(concurrency.Session.cancel') := cancel'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance Session_access_load_donec l (v : (concurrency.Session.t)) dq :
  AccessStrict
    (l.[(concurrency.Session.t), "donec"] ↦{dq} (v.(concurrency.Session.donec')))
    (l.[(concurrency.Session.t), "donec"] ↦{dq} (v.(concurrency.Session.donec')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance Session_access_store_donec l (v : (concurrency.Session.t)) donec' :
  AccessStrict
    (l.[(concurrency.Session.t), "donec"] ↦ (v.(concurrency.Session.donec')))
    (l.[(concurrency.Session.t), "donec"] ↦ donec')
    (l ↦ v) (l ↦ (v <|(concurrency.Session.donec') := donec'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End Session.

Module sessionOptions.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : concurrency.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance sessionOptions_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (concurrency.sessionOptions.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "ttl" ∷ l.[(concurrency.sessionOptions.t), "ttl"] ↦{dq} v.(concurrency.sessionOptions.ttl') ∗
      "leaseID" ∷ l.[(concurrency.sessionOptions.t), "leaseID"] ↦{dq} v.(concurrency.sessionOptions.leaseID') ∗
      "ctx" ∷ l.[(concurrency.sessionOptions.t), "ctx"] ↦{dq} v.(concurrency.sessionOptions.ctx') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance sessionOptions_into_val_typed
   :
  IntoValTypedUnderlying (concurrency.sessionOptions.t) (concurrency.sessionOptionsⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance sessionOptions_access_load_ttl l (v : (concurrency.sessionOptions.t)) dq :
  AccessStrict
    (l.[(concurrency.sessionOptions.t), "ttl"] ↦{dq} (v.(concurrency.sessionOptions.ttl')))
    (l.[(concurrency.sessionOptions.t), "ttl"] ↦{dq} (v.(concurrency.sessionOptions.ttl')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance sessionOptions_access_store_ttl l (v : (concurrency.sessionOptions.t)) ttl' :
  AccessStrict
    (l.[(concurrency.sessionOptions.t), "ttl"] ↦ (v.(concurrency.sessionOptions.ttl')))
    (l.[(concurrency.sessionOptions.t), "ttl"] ↦ ttl')
    (l ↦ v) (l ↦ (v <|(concurrency.sessionOptions.ttl') := ttl'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance sessionOptions_access_load_leaseID l (v : (concurrency.sessionOptions.t)) dq :
  AccessStrict
    (l.[(concurrency.sessionOptions.t), "leaseID"] ↦{dq} (v.(concurrency.sessionOptions.leaseID')))
    (l.[(concurrency.sessionOptions.t), "leaseID"] ↦{dq} (v.(concurrency.sessionOptions.leaseID')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance sessionOptions_access_store_leaseID l (v : (concurrency.sessionOptions.t)) leaseID' :
  AccessStrict
    (l.[(concurrency.sessionOptions.t), "leaseID"] ↦ (v.(concurrency.sessionOptions.leaseID')))
    (l.[(concurrency.sessionOptions.t), "leaseID"] ↦ leaseID')
    (l ↦ v) (l ↦ (v <|(concurrency.sessionOptions.leaseID') := leaseID'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance sessionOptions_access_load_ctx l (v : (concurrency.sessionOptions.t)) dq :
  AccessStrict
    (l.[(concurrency.sessionOptions.t), "ctx"] ↦{dq} (v.(concurrency.sessionOptions.ctx')))
    (l.[(concurrency.sessionOptions.t), "ctx"] ↦{dq} (v.(concurrency.sessionOptions.ctx')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance sessionOptions_access_store_ctx l (v : (concurrency.sessionOptions.t)) ctx' :
  AccessStrict
    (l.[(concurrency.sessionOptions.t), "ctx"] ↦ (v.(concurrency.sessionOptions.ctx')))
    (l.[(concurrency.sessionOptions.t), "ctx"] ↦ ctx')
    (l ↦ v) (l ↦ (v <|(concurrency.sessionOptions.ctx') := ctx'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End sessionOptions.

Module stmError.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : concurrency.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance stmError_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (concurrency.stmError.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "err" ∷ l.[(concurrency.stmError.t), "err"] ↦{dq} v.(concurrency.stmError.err') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance stmError_into_val_typed
   :
  IntoValTypedUnderlying (concurrency.stmError.t) (concurrency.stmErrorⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance stmError_access_load_err l (v : (concurrency.stmError.t)) dq :
  AccessStrict
    (l.[(concurrency.stmError.t), "err"] ↦{dq} (v.(concurrency.stmError.err')))
    (l.[(concurrency.stmError.t), "err"] ↦{dq} (v.(concurrency.stmError.err')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance stmError_access_store_err l (v : (concurrency.stmError.t)) err' :
  AccessStrict
    (l.[(concurrency.stmError.t), "err"] ↦ (v.(concurrency.stmError.err')))
    (l.[(concurrency.stmError.t), "err"] ↦ err')
    (l ↦ v) (l ↦ (v <|(concurrency.stmError.err') := err'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End stmError.

Module stmOptions.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : concurrency.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance stmOptions_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (concurrency.stmOptions.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "iso" ∷ l.[(concurrency.stmOptions.t), "iso"] ↦{dq} v.(concurrency.stmOptions.iso') ∗
      "ctx" ∷ l.[(concurrency.stmOptions.t), "ctx"] ↦{dq} v.(concurrency.stmOptions.ctx') ∗
      "prefetch" ∷ l.[(concurrency.stmOptions.t), "prefetch"] ↦{dq} v.(concurrency.stmOptions.prefetch') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance stmOptions_into_val_typed
   :
  IntoValTypedUnderlying (concurrency.stmOptions.t) (concurrency.stmOptionsⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance stmOptions_access_load_iso l (v : (concurrency.stmOptions.t)) dq :
  AccessStrict
    (l.[(concurrency.stmOptions.t), "iso"] ↦{dq} (v.(concurrency.stmOptions.iso')))
    (l.[(concurrency.stmOptions.t), "iso"] ↦{dq} (v.(concurrency.stmOptions.iso')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance stmOptions_access_store_iso l (v : (concurrency.stmOptions.t)) iso' :
  AccessStrict
    (l.[(concurrency.stmOptions.t), "iso"] ↦ (v.(concurrency.stmOptions.iso')))
    (l.[(concurrency.stmOptions.t), "iso"] ↦ iso')
    (l ↦ v) (l ↦ (v <|(concurrency.stmOptions.iso') := iso'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance stmOptions_access_load_ctx l (v : (concurrency.stmOptions.t)) dq :
  AccessStrict
    (l.[(concurrency.stmOptions.t), "ctx"] ↦{dq} (v.(concurrency.stmOptions.ctx')))
    (l.[(concurrency.stmOptions.t), "ctx"] ↦{dq} (v.(concurrency.stmOptions.ctx')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance stmOptions_access_store_ctx l (v : (concurrency.stmOptions.t)) ctx' :
  AccessStrict
    (l.[(concurrency.stmOptions.t), "ctx"] ↦ (v.(concurrency.stmOptions.ctx')))
    (l.[(concurrency.stmOptions.t), "ctx"] ↦ ctx')
    (l ↦ v) (l ↦ (v <|(concurrency.stmOptions.ctx') := ctx'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance stmOptions_access_load_prefetch l (v : (concurrency.stmOptions.t)) dq :
  AccessStrict
    (l.[(concurrency.stmOptions.t), "prefetch"] ↦{dq} (v.(concurrency.stmOptions.prefetch')))
    (l.[(concurrency.stmOptions.t), "prefetch"] ↦{dq} (v.(concurrency.stmOptions.prefetch')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance stmOptions_access_store_prefetch l (v : (concurrency.stmOptions.t)) prefetch' :
  AccessStrict
    (l.[(concurrency.stmOptions.t), "prefetch"] ↦ (v.(concurrency.stmOptions.prefetch')))
    (l.[(concurrency.stmOptions.t), "prefetch"] ↦ prefetch')
    (l ↦ v) (l ↦ (v <|(concurrency.stmOptions.prefetch') := prefetch'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End stmOptions.

Module stmResponse.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : concurrency.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance stmResponse_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (concurrency.stmResponse.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "resp" ∷ l.[(concurrency.stmResponse.t), "resp"] ↦{dq} v.(concurrency.stmResponse.resp') ∗
      "err" ∷ l.[(concurrency.stmResponse.t), "err"] ↦{dq} v.(concurrency.stmResponse.err') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance stmResponse_into_val_typed
   :
  IntoValTypedUnderlying (concurrency.stmResponse.t) (concurrency.stmResponseⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance stmResponse_access_load_resp l (v : (concurrency.stmResponse.t)) dq :
  AccessStrict
    (l.[(concurrency.stmResponse.t), "resp"] ↦{dq} (v.(concurrency.stmResponse.resp')))
    (l.[(concurrency.stmResponse.t), "resp"] ↦{dq} (v.(concurrency.stmResponse.resp')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance stmResponse_access_store_resp l (v : (concurrency.stmResponse.t)) resp' :
  AccessStrict
    (l.[(concurrency.stmResponse.t), "resp"] ↦ (v.(concurrency.stmResponse.resp')))
    (l.[(concurrency.stmResponse.t), "resp"] ↦ resp')
    (l ↦ v) (l ↦ (v <|(concurrency.stmResponse.resp') := resp'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance stmResponse_access_load_err l (v : (concurrency.stmResponse.t)) dq :
  AccessStrict
    (l.[(concurrency.stmResponse.t), "err"] ↦{dq} (v.(concurrency.stmResponse.err')))
    (l.[(concurrency.stmResponse.t), "err"] ↦{dq} (v.(concurrency.stmResponse.err')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance stmResponse_access_store_err l (v : (concurrency.stmResponse.t)) err' :
  AccessStrict
    (l.[(concurrency.stmResponse.t), "err"] ↦ (v.(concurrency.stmResponse.err')))
    (l.[(concurrency.stmResponse.t), "err"] ↦ err')
    (l ↦ v) (l ↦ (v <|(concurrency.stmResponse.err') := err'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End stmResponse.

Module stm.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : concurrency.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance stm_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (concurrency.stm.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "client" ∷ l.[(concurrency.stm.t), "client"] ↦{dq} v.(concurrency.stm.client') ∗
      "ctx" ∷ l.[(concurrency.stm.t), "ctx"] ↦{dq} v.(concurrency.stm.ctx') ∗
      "rset" ∷ l.[(concurrency.stm.t), "rset"] ↦{dq} v.(concurrency.stm.rset') ∗
      "wset" ∷ l.[(concurrency.stm.t), "wset"] ↦{dq} v.(concurrency.stm.wset') ∗
      "getOpts" ∷ l.[(concurrency.stm.t), "getOpts"] ↦{dq} v.(concurrency.stm.getOpts') ∗
      "conflicts" ∷ l.[(concurrency.stm.t), "conflicts"] ↦{dq} v.(concurrency.stm.conflicts') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance stm_into_val_typed
   :
  IntoValTypedUnderlying (concurrency.stm.t) (concurrency.stmⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance stm_access_load_client l (v : (concurrency.stm.t)) dq :
  AccessStrict
    (l.[(concurrency.stm.t), "client"] ↦{dq} (v.(concurrency.stm.client')))
    (l.[(concurrency.stm.t), "client"] ↦{dq} (v.(concurrency.stm.client')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance stm_access_store_client l (v : (concurrency.stm.t)) client' :
  AccessStrict
    (l.[(concurrency.stm.t), "client"] ↦ (v.(concurrency.stm.client')))
    (l.[(concurrency.stm.t), "client"] ↦ client')
    (l ↦ v) (l ↦ (v <|(concurrency.stm.client') := client'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance stm_access_load_ctx l (v : (concurrency.stm.t)) dq :
  AccessStrict
    (l.[(concurrency.stm.t), "ctx"] ↦{dq} (v.(concurrency.stm.ctx')))
    (l.[(concurrency.stm.t), "ctx"] ↦{dq} (v.(concurrency.stm.ctx')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance stm_access_store_ctx l (v : (concurrency.stm.t)) ctx' :
  AccessStrict
    (l.[(concurrency.stm.t), "ctx"] ↦ (v.(concurrency.stm.ctx')))
    (l.[(concurrency.stm.t), "ctx"] ↦ ctx')
    (l ↦ v) (l ↦ (v <|(concurrency.stm.ctx') := ctx'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance stm_access_load_rset l (v : (concurrency.stm.t)) dq :
  AccessStrict
    (l.[(concurrency.stm.t), "rset"] ↦{dq} (v.(concurrency.stm.rset')))
    (l.[(concurrency.stm.t), "rset"] ↦{dq} (v.(concurrency.stm.rset')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance stm_access_store_rset l (v : (concurrency.stm.t)) rset' :
  AccessStrict
    (l.[(concurrency.stm.t), "rset"] ↦ (v.(concurrency.stm.rset')))
    (l.[(concurrency.stm.t), "rset"] ↦ rset')
    (l ↦ v) (l ↦ (v <|(concurrency.stm.rset') := rset'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance stm_access_load_wset l (v : (concurrency.stm.t)) dq :
  AccessStrict
    (l.[(concurrency.stm.t), "wset"] ↦{dq} (v.(concurrency.stm.wset')))
    (l.[(concurrency.stm.t), "wset"] ↦{dq} (v.(concurrency.stm.wset')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance stm_access_store_wset l (v : (concurrency.stm.t)) wset' :
  AccessStrict
    (l.[(concurrency.stm.t), "wset"] ↦ (v.(concurrency.stm.wset')))
    (l.[(concurrency.stm.t), "wset"] ↦ wset')
    (l ↦ v) (l ↦ (v <|(concurrency.stm.wset') := wset'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance stm_access_load_getOpts l (v : (concurrency.stm.t)) dq :
  AccessStrict
    (l.[(concurrency.stm.t), "getOpts"] ↦{dq} (v.(concurrency.stm.getOpts')))
    (l.[(concurrency.stm.t), "getOpts"] ↦{dq} (v.(concurrency.stm.getOpts')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance stm_access_store_getOpts l (v : (concurrency.stm.t)) getOpts' :
  AccessStrict
    (l.[(concurrency.stm.t), "getOpts"] ↦ (v.(concurrency.stm.getOpts')))
    (l.[(concurrency.stm.t), "getOpts"] ↦ getOpts')
    (l ↦ v) (l ↦ (v <|(concurrency.stm.getOpts') := getOpts'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance stm_access_load_conflicts l (v : (concurrency.stm.t)) dq :
  AccessStrict
    (l.[(concurrency.stm.t), "conflicts"] ↦{dq} (v.(concurrency.stm.conflicts')))
    (l.[(concurrency.stm.t), "conflicts"] ↦{dq} (v.(concurrency.stm.conflicts')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance stm_access_store_conflicts l (v : (concurrency.stm.t)) conflicts' :
  AccessStrict
    (l.[(concurrency.stm.t), "conflicts"] ↦ (v.(concurrency.stm.conflicts')))
    (l.[(concurrency.stm.t), "conflicts"] ↦ conflicts')
    (l ↦ v) (l ↦ (v <|(concurrency.stm.conflicts') := conflicts'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End stm.

Module stmPut.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : concurrency.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance stmPut_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (concurrency.stmPut.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "val" ∷ l.[(concurrency.stmPut.t), "val"] ↦{dq} v.(concurrency.stmPut.val') ∗
      "op" ∷ l.[(concurrency.stmPut.t), "op"] ↦{dq} v.(concurrency.stmPut.op') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance stmPut_into_val_typed
   :
  IntoValTypedUnderlying (concurrency.stmPut.t) (concurrency.stmPutⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance stmPut_access_load_val l (v : (concurrency.stmPut.t)) dq :
  AccessStrict
    (l.[(concurrency.stmPut.t), "val"] ↦{dq} (v.(concurrency.stmPut.val')))
    (l.[(concurrency.stmPut.t), "val"] ↦{dq} (v.(concurrency.stmPut.val')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance stmPut_access_store_val l (v : (concurrency.stmPut.t)) val' :
  AccessStrict
    (l.[(concurrency.stmPut.t), "val"] ↦ (v.(concurrency.stmPut.val')))
    (l.[(concurrency.stmPut.t), "val"] ↦ val')
    (l ↦ v) (l ↦ (v <|(concurrency.stmPut.val') := val'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance stmPut_access_load_op l (v : (concurrency.stmPut.t)) dq :
  AccessStrict
    (l.[(concurrency.stmPut.t), "op"] ↦{dq} (v.(concurrency.stmPut.op')))
    (l.[(concurrency.stmPut.t), "op"] ↦{dq} (v.(concurrency.stmPut.op')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance stmPut_access_store_op l (v : (concurrency.stmPut.t)) op' :
  AccessStrict
    (l.[(concurrency.stmPut.t), "op"] ↦ (v.(concurrency.stmPut.op')))
    (l.[(concurrency.stmPut.t), "op"] ↦ op')
    (l ↦ v) (l ↦ (v <|(concurrency.stmPut.op') := op'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End stmPut.

Module stmSerializable.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : concurrency.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance stmSerializable_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (concurrency.stmSerializable.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "stm" ∷ l.[(concurrency.stmSerializable.t), "stm"] ↦{dq} v.(concurrency.stmSerializable.stm') ∗
      "prefetch" ∷ l.[(concurrency.stmSerializable.t), "prefetch"] ↦{dq} v.(concurrency.stmSerializable.prefetch') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance stmSerializable_into_val_typed
   :
  IntoValTypedUnderlying (concurrency.stmSerializable.t) (concurrency.stmSerializableⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance stmSerializable_access_load_stm l (v : (concurrency.stmSerializable.t)) dq :
  AccessStrict
    (l.[(concurrency.stmSerializable.t), "stm"] ↦{dq} (v.(concurrency.stmSerializable.stm')))
    (l.[(concurrency.stmSerializable.t), "stm"] ↦{dq} (v.(concurrency.stmSerializable.stm')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance stmSerializable_access_store_stm l (v : (concurrency.stmSerializable.t)) stm' :
  AccessStrict
    (l.[(concurrency.stmSerializable.t), "stm"] ↦ (v.(concurrency.stmSerializable.stm')))
    (l.[(concurrency.stmSerializable.t), "stm"] ↦ stm')
    (l ↦ v) (l ↦ (v <|(concurrency.stmSerializable.stm') := stm'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance stmSerializable_access_load_prefetch l (v : (concurrency.stmSerializable.t)) dq :
  AccessStrict
    (l.[(concurrency.stmSerializable.t), "prefetch"] ↦{dq} (v.(concurrency.stmSerializable.prefetch')))
    (l.[(concurrency.stmSerializable.t), "prefetch"] ↦{dq} (v.(concurrency.stmSerializable.prefetch')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance stmSerializable_access_store_prefetch l (v : (concurrency.stmSerializable.t)) prefetch' :
  AccessStrict
    (l.[(concurrency.stmSerializable.t), "prefetch"] ↦ (v.(concurrency.stmSerializable.prefetch')))
    (l.[(concurrency.stmSerializable.t), "prefetch"] ↦ prefetch')
    (l ↦ v) (l ↦ (v <|(concurrency.stmSerializable.prefetch') := prefetch'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End stmSerializable.

End concurrency.
