(* autogenerated by goose proofgen; do not modify *)
Require Export New.proof.proof_prelude.
Require Export New.generatedproof.go_etcd_io.etcd.server.v3.storage.backend.
Require Export New.generatedproof.go_etcd_io.etcd.server.v3.storage.schema.
Require Export New.generatedproof.sync.
Require Export New.generatedproof.sync.atomic.
Require Export New.golang.theory.
Require Export New.code.go_etcd_io.etcd.server.v3.etcdserver.cindex.

Set Default Proof Using "Type".

Module cindex.
Module consistentIndex.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : cindex.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance consistentIndex_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (cindex.consistentIndex.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "consistentIndex" ∷ l.[(cindex.consistentIndex.t), "consistentIndex"] ↦{dq} v.(cindex.consistentIndex.consistentIndex') ∗
      "term" ∷ l.[(cindex.consistentIndex.t), "term"] ↦{dq} v.(cindex.consistentIndex.term') ∗
      "applyingIndex" ∷ l.[(cindex.consistentIndex.t), "applyingIndex"] ↦{dq} v.(cindex.consistentIndex.applyingIndex') ∗
      "applyingTerm" ∷ l.[(cindex.consistentIndex.t), "applyingTerm"] ↦{dq} v.(cindex.consistentIndex.applyingTerm') ∗
      "be" ∷ l.[(cindex.consistentIndex.t), "be"] ↦{dq} v.(cindex.consistentIndex.be') ∗
      "mutex" ∷ l.[(cindex.consistentIndex.t), "mutex"] ↦{dq} v.(cindex.consistentIndex.mutex') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance consistentIndex_into_val_typed
   :
  IntoValTypedUnderlying (cindex.consistentIndex.t) (cindex.consistentIndexⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance consistentIndex_access_load_consistentIndex l (v : (cindex.consistentIndex.t)) dq :
  AccessStrict
    (l.[(cindex.consistentIndex.t), "consistentIndex"] ↦{dq} (v.(cindex.consistentIndex.consistentIndex')))
    (l.[(cindex.consistentIndex.t), "consistentIndex"] ↦{dq} (v.(cindex.consistentIndex.consistentIndex')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance consistentIndex_access_store_consistentIndex l (v : (cindex.consistentIndex.t)) consistentIndex' :
  AccessStrict
    (l.[(cindex.consistentIndex.t), "consistentIndex"] ↦ (v.(cindex.consistentIndex.consistentIndex')))
    (l.[(cindex.consistentIndex.t), "consistentIndex"] ↦ consistentIndex')
    (l ↦ v) (l ↦ (v <|(cindex.consistentIndex.consistentIndex') := consistentIndex'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance consistentIndex_access_load_term l (v : (cindex.consistentIndex.t)) dq :
  AccessStrict
    (l.[(cindex.consistentIndex.t), "term"] ↦{dq} (v.(cindex.consistentIndex.term')))
    (l.[(cindex.consistentIndex.t), "term"] ↦{dq} (v.(cindex.consistentIndex.term')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance consistentIndex_access_store_term l (v : (cindex.consistentIndex.t)) term' :
  AccessStrict
    (l.[(cindex.consistentIndex.t), "term"] ↦ (v.(cindex.consistentIndex.term')))
    (l.[(cindex.consistentIndex.t), "term"] ↦ term')
    (l ↦ v) (l ↦ (v <|(cindex.consistentIndex.term') := term'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance consistentIndex_access_load_applyingIndex l (v : (cindex.consistentIndex.t)) dq :
  AccessStrict
    (l.[(cindex.consistentIndex.t), "applyingIndex"] ↦{dq} (v.(cindex.consistentIndex.applyingIndex')))
    (l.[(cindex.consistentIndex.t), "applyingIndex"] ↦{dq} (v.(cindex.consistentIndex.applyingIndex')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance consistentIndex_access_store_applyingIndex l (v : (cindex.consistentIndex.t)) applyingIndex' :
  AccessStrict
    (l.[(cindex.consistentIndex.t), "applyingIndex"] ↦ (v.(cindex.consistentIndex.applyingIndex')))
    (l.[(cindex.consistentIndex.t), "applyingIndex"] ↦ applyingIndex')
    (l ↦ v) (l ↦ (v <|(cindex.consistentIndex.applyingIndex') := applyingIndex'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance consistentIndex_access_load_applyingTerm l (v : (cindex.consistentIndex.t)) dq :
  AccessStrict
    (l.[(cindex.consistentIndex.t), "applyingTerm"] ↦{dq} (v.(cindex.consistentIndex.applyingTerm')))
    (l.[(cindex.consistentIndex.t), "applyingTerm"] ↦{dq} (v.(cindex.consistentIndex.applyingTerm')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance consistentIndex_access_store_applyingTerm l (v : (cindex.consistentIndex.t)) applyingTerm' :
  AccessStrict
    (l.[(cindex.consistentIndex.t), "applyingTerm"] ↦ (v.(cindex.consistentIndex.applyingTerm')))
    (l.[(cindex.consistentIndex.t), "applyingTerm"] ↦ applyingTerm')
    (l ↦ v) (l ↦ (v <|(cindex.consistentIndex.applyingTerm') := applyingTerm'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance consistentIndex_access_load_be l (v : (cindex.consistentIndex.t)) dq :
  AccessStrict
    (l.[(cindex.consistentIndex.t), "be"] ↦{dq} (v.(cindex.consistentIndex.be')))
    (l.[(cindex.consistentIndex.t), "be"] ↦{dq} (v.(cindex.consistentIndex.be')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance consistentIndex_access_store_be l (v : (cindex.consistentIndex.t)) be' :
  AccessStrict
    (l.[(cindex.consistentIndex.t), "be"] ↦ (v.(cindex.consistentIndex.be')))
    (l.[(cindex.consistentIndex.t), "be"] ↦ be')
    (l ↦ v) (l ↦ (v <|(cindex.consistentIndex.be') := be'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance consistentIndex_access_load_mutex l (v : (cindex.consistentIndex.t)) dq :
  AccessStrict
    (l.[(cindex.consistentIndex.t), "mutex"] ↦{dq} (v.(cindex.consistentIndex.mutex')))
    (l.[(cindex.consistentIndex.t), "mutex"] ↦{dq} (v.(cindex.consistentIndex.mutex')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance consistentIndex_access_store_mutex l (v : (cindex.consistentIndex.t)) mutex' :
  AccessStrict
    (l.[(cindex.consistentIndex.t), "mutex"] ↦ (v.(cindex.consistentIndex.mutex')))
    (l.[(cindex.consistentIndex.t), "mutex"] ↦ mutex')
    (l ↦ v) (l ↦ (v <|(cindex.consistentIndex.mutex') := mutex'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End consistentIndex.

Module fakeConsistentIndex.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : cindex.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance fakeConsistentIndex_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (cindex.fakeConsistentIndex.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "index" ∷ l.[(cindex.fakeConsistentIndex.t), "index"] ↦{dq} v.(cindex.fakeConsistentIndex.index') ∗
      "term" ∷ l.[(cindex.fakeConsistentIndex.t), "term"] ↦{dq} v.(cindex.fakeConsistentIndex.term') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance fakeConsistentIndex_into_val_typed
   :
  IntoValTypedUnderlying (cindex.fakeConsistentIndex.t) (cindex.fakeConsistentIndexⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance fakeConsistentIndex_access_load_index l (v : (cindex.fakeConsistentIndex.t)) dq :
  AccessStrict
    (l.[(cindex.fakeConsistentIndex.t), "index"] ↦{dq} (v.(cindex.fakeConsistentIndex.index')))
    (l.[(cindex.fakeConsistentIndex.t), "index"] ↦{dq} (v.(cindex.fakeConsistentIndex.index')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance fakeConsistentIndex_access_store_index l (v : (cindex.fakeConsistentIndex.t)) index' :
  AccessStrict
    (l.[(cindex.fakeConsistentIndex.t), "index"] ↦ (v.(cindex.fakeConsistentIndex.index')))
    (l.[(cindex.fakeConsistentIndex.t), "index"] ↦ index')
    (l ↦ v) (l ↦ (v <|(cindex.fakeConsistentIndex.index') := index'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance fakeConsistentIndex_access_load_term l (v : (cindex.fakeConsistentIndex.t)) dq :
  AccessStrict
    (l.[(cindex.fakeConsistentIndex.t), "term"] ↦{dq} (v.(cindex.fakeConsistentIndex.term')))
    (l.[(cindex.fakeConsistentIndex.t), "term"] ↦{dq} (v.(cindex.fakeConsistentIndex.term')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance fakeConsistentIndex_access_store_term l (v : (cindex.fakeConsistentIndex.t)) term' :
  AccessStrict
    (l.[(cindex.fakeConsistentIndex.t), "term"] ↦ (v.(cindex.fakeConsistentIndex.term')))
    (l.[(cindex.fakeConsistentIndex.t), "term"] ↦ term')
    (l ↦ v) (l ↦ (v <|(cindex.fakeConsistentIndex.term') := term'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End fakeConsistentIndex.

End cindex.
