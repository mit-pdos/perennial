(* autogenerated by goose proofgen; do not modify *)
Require Export New.proof.proof_prelude.
Require Export New.generatedproof.log.
Require Export New.generatedproof.sync.
Require Export New.golang.theory.
Require Export New.code.go_etcd_io.etcd.pkg.v3.wait.

Set Default Proof Using "Type".

Module wait.
Module list'.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : wait.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance list'_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (wait.list'.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "e" ∷ l.[(wait.list'.t), "e"] ↦{dq} v.(wait.list'.e') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance list'_into_val_typed
   :
  IntoValTypedUnderlying (wait.list'.t) (wait.list'ⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance list'_access_load_e l (v : (wait.list'.t)) dq :
  AccessStrict
    (l.[(wait.list'.t), "e"] ↦{dq} (v.(wait.list'.e')))
    (l.[(wait.list'.t), "e"] ↦{dq} (v.(wait.list'.e')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance list'_access_store_e l (v : (wait.list'.t)) e' :
  AccessStrict
    (l.[(wait.list'.t), "e"] ↦ (v.(wait.list'.e')))
    (l.[(wait.list'.t), "e"] ↦ e')
    (l ↦ v) (l ↦ (v <|(wait.list'.e') := e'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End list'.

Module listElement.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : wait.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance listElement_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (wait.listElement.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "l" ∷ l.[(wait.listElement.t), "l"] ↦{dq} v.(wait.listElement.l') ∗
      "m" ∷ l.[(wait.listElement.t), "m"] ↦{dq} v.(wait.listElement.m') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance listElement_into_val_typed
   :
  IntoValTypedUnderlying (wait.listElement.t) (wait.listElementⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance listElement_access_load_l l (v : (wait.listElement.t)) dq :
  AccessStrict
    (l.[(wait.listElement.t), "l"] ↦{dq} (v.(wait.listElement.l')))
    (l.[(wait.listElement.t), "l"] ↦{dq} (v.(wait.listElement.l')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance listElement_access_store_l l (v : (wait.listElement.t)) l' :
  AccessStrict
    (l.[(wait.listElement.t), "l"] ↦ (v.(wait.listElement.l')))
    (l.[(wait.listElement.t), "l"] ↦ l')
    (l ↦ v) (l ↦ (v <|(wait.listElement.l') := l'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance listElement_access_load_m l (v : (wait.listElement.t)) dq :
  AccessStrict
    (l.[(wait.listElement.t), "m"] ↦{dq} (v.(wait.listElement.m')))
    (l.[(wait.listElement.t), "m"] ↦{dq} (v.(wait.listElement.m')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance listElement_access_store_m l (v : (wait.listElement.t)) m' :
  AccessStrict
    (l.[(wait.listElement.t), "m"] ↦ (v.(wait.listElement.m')))
    (l.[(wait.listElement.t), "m"] ↦ m')
    (l ↦ v) (l ↦ (v <|(wait.listElement.m') := m'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End listElement.

Module waitWithResponse.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : wait.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance waitWithResponse_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (wait.waitWithResponse.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "ch" ∷ l.[(wait.waitWithResponse.t), "ch"] ↦{dq} v.(wait.waitWithResponse.ch') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance waitWithResponse_into_val_typed
   :
  IntoValTypedUnderlying (wait.waitWithResponse.t) (wait.waitWithResponseⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance waitWithResponse_access_load_ch l (v : (wait.waitWithResponse.t)) dq :
  AccessStrict
    (l.[(wait.waitWithResponse.t), "ch"] ↦{dq} (v.(wait.waitWithResponse.ch')))
    (l.[(wait.waitWithResponse.t), "ch"] ↦{dq} (v.(wait.waitWithResponse.ch')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance waitWithResponse_access_store_ch l (v : (wait.waitWithResponse.t)) ch' :
  AccessStrict
    (l.[(wait.waitWithResponse.t), "ch"] ↦ (v.(wait.waitWithResponse.ch')))
    (l.[(wait.waitWithResponse.t), "ch"] ↦ ch')
    (l ↦ v) (l ↦ (v <|(wait.waitWithResponse.ch') := ch'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End waitWithResponse.

Module timeList.
Section def.

Context `{hG: heapGS Σ, !ffi_semantics _ _}.
Context {sem : go.Semantics}.
Context {package_sem' : wait.Assumptions}.

Local Set Default Proof Using "All".

#[global]Program Instance timeList_typed_pointsto  :
  TypedPointsto (Σ:=Σ) (wait.timeList.t) :=
  {|
    typed_pointsto_def l v dq :=
      (
      "l" ∷ l.[(wait.timeList.t), "l"] ↦{dq} v.(wait.timeList.l') ∗
      "lastTriggerDeadline" ∷ l.[(wait.timeList.t), "lastTriggerDeadline"] ↦{dq} v.(wait.timeList.lastTriggerDeadline') ∗
      "m" ∷ l.[(wait.timeList.t), "m"] ↦{dq} v.(wait.timeList.m') ∗
      "_" ∷ True
      )%I
  |}.
Final Obligation. solve_typed_pointsto_agree. Qed.

#[global] Instance timeList_into_val_typed
   :
  IntoValTypedUnderlying (wait.timeList.t) (wait.timeListⁱᵐᵖˡ).
Proof. solve_into_val_typed_struct. Qed.
#[global] Instance timeList_access_load_l l (v : (wait.timeList.t)) dq :
  AccessStrict
    (l.[(wait.timeList.t), "l"] ↦{dq} (v.(wait.timeList.l')))
    (l.[(wait.timeList.t), "l"] ↦{dq} (v.(wait.timeList.l')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance timeList_access_store_l l (v : (wait.timeList.t)) l' :
  AccessStrict
    (l.[(wait.timeList.t), "l"] ↦ (v.(wait.timeList.l')))
    (l.[(wait.timeList.t), "l"] ↦ l')
    (l ↦ v) (l ↦ (v <|(wait.timeList.l') := l'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance timeList_access_load_lastTriggerDeadline l (v : (wait.timeList.t)) dq :
  AccessStrict
    (l.[(wait.timeList.t), "lastTriggerDeadline"] ↦{dq} (v.(wait.timeList.lastTriggerDeadline')))
    (l.[(wait.timeList.t), "lastTriggerDeadline"] ↦{dq} (v.(wait.timeList.lastTriggerDeadline')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance timeList_access_store_lastTriggerDeadline l (v : (wait.timeList.t)) lastTriggerDeadline' :
  AccessStrict
    (l.[(wait.timeList.t), "lastTriggerDeadline"] ↦ (v.(wait.timeList.lastTriggerDeadline')))
    (l.[(wait.timeList.t), "lastTriggerDeadline"] ↦ lastTriggerDeadline')
    (l ↦ v) (l ↦ (v <|(wait.timeList.lastTriggerDeadline') := lastTriggerDeadline'|>))%I.
Proof. solve_pointsto_access_struct. Qed.
#[global] Instance timeList_access_load_m l (v : (wait.timeList.t)) dq :
  AccessStrict
    (l.[(wait.timeList.t), "m"] ↦{dq} (v.(wait.timeList.m')))
    (l.[(wait.timeList.t), "m"] ↦{dq} (v.(wait.timeList.m')))
    (l ↦{dq} v) (l ↦{dq} v)%I.
Proof. solve_pointsto_access_struct. Qed.

#[global] Instance timeList_access_store_m l (v : (wait.timeList.t)) m' :
  AccessStrict
    (l.[(wait.timeList.t), "m"] ↦ (v.(wait.timeList.m')))
    (l.[(wait.timeList.t), "m"] ↦ m')
    (l ↦ v) (l ↦ (v <|(wait.timeList.m') := m'|>))%I.
Proof. solve_pointsto_access_struct. Qed.

End def.
End timeList.

End wait.
