From New.proof Require Export proof_prelude.
From New.golang Require Export defn.spinlock.

From New.proof Require Export tok_set.

From New.experiments Require Export glob.
From Perennial Require Export base.

#[local] Transparent spinlock.trylock spinlock.lock spinlock.unlock.

Section proof.
Context `{heapGS Σ, !ffi_semantics _ _}.
Context `{!globalsGS Σ} {go_ctx : GoContext}.

(** This means [m] is a valid mutex with invariant [R]. *)
Definition is_spinlock (m: loc) (R : iProp Σ) : iProp Σ :=
  "#Hinv" ∷ inv nroot (
        ∃ b : bool,
          (m ↦{# 1/4} b) ∗
          if b then True else m ↦{# 3/4} b ∗ R
        ) ∗
  "_" ∷ True.
#[global] Opaque is_spinlock.
#[local] Transparent is_spinlock.

(** This resource denotes ownership of the fact that the spinlock is currently
    locked. *)
Definition own_spinlock (m: loc) : iProp Σ := m ↦{# 3/4} true.
#[global] Opaque own_spinlock.
#[local] Transparent own_spinlock.

Lemma own_spinlock_exclusive (m : loc) : own_spinlock m -∗ own_spinlock m -∗ False.
Proof.
  iIntros "H1 H2".
  iCombine "H1 H2" gives %[Hbad _].
  exfalso.
  rewrite go_type_size_unseal in Hbad. naive_solver.
  (* FIXME: don't want to unseal go_type_size_unseal *)
Qed.

Global Instance is_spinlock_ne m : NonExpansive (is_spinlock m).
Proof. solve_proper. Qed.

(** The main proofs. *)
Global Instance is_spinlock_persistent m R : Persistent (is_spinlock m R).
Proof. apply _. Qed.
Global Instance locked_timeless m : Timeless (own_spinlock m).
Proof. apply _. Qed.

Theorem init_spinlock R E m : m ↦ false -∗ ▷ R ={E}=∗ is_spinlock m R.
Proof.
  iIntros "Hl HR".
  simpl.
  iNamed "Hl".
  simpl.
  iFrame "#".
  iMod (inv_alloc nroot _ (_) with "[Hl HR]") as "#?".
  2:{ by iFrame "#". }
  { iIntros "!>". iExists false. iFrame.
    iEval (rewrite -Qp.quarter_three_quarter) in "Hl".
    iDestruct "Hl" as "[$$]".
  }
Qed.

Lemma wp_spinlock_trylock m R :
  {{{ is_spinlock m R }}}
    spinlock.trylock #m
  {{{ (locked : bool), RET #locked; if locked then own_spinlock m ∗ R else True }}}.
Proof.
  (* NOTE(llm): Entire proof generated by cursor/claude-3.5-sonnet with no
     interactive feedback. Seems to have copied the Lock() proof, except for
     dropping iLöb! *)
  wp_start as "H". iNamed "H".
  wp_call.
  wp_bind (CmpXchg _ _ _).
  iInv nroot as ([]) "[Hl HR]".
  - wp_bind (CmpXchg _ _ _).
    iApply (wp_typed_cmpxchg_fail (V:=bool) with "[$]").
    { done. }
    { naive_solver. }
    iNext.
    iIntros "Hl".
    iModIntro. iSplitL "Hl"; first (iNext; iExists true; eauto).
    wp_auto.
    by iApply "HΦ".
  - iDestruct "HR" as "[Hl2 HR]".
    iCombine "Hl Hl2" as "Hl".
    rewrite Qp.quarter_three_quarter.
    wp_bind (CmpXchg _ _ _).
    iApply (wp_typed_cmpxchg_suc (V:=bool) with "[$]").
    { constructor. }
    { done. }
    iNext. iIntros "Hl".
    iModIntro.
    iEval (rewrite -Qp.quarter_three_quarter) in "Hl".
    iDestruct "Hl" as "[Hl1 Hl2]".
    iSplitL "Hl1"; first (iNext; iExists true; eauto).
    rewrite /locked. wp_auto.
    iApply "HΦ".
    eauto with iFrame.
Qed.

Lemma wp_spinlock_lock m R :
  {{{ is_spinlock m R }}}
    spinlock.lock #m
  {{{ RET #(); own_spinlock m ∗ R }}}.
Proof.
  iLöb as "IH".
  wp_start as "H". wp_call. iNamed "H".
  wp_bind (CmpXchg _ _ _).
  iInv nroot as ([]) "[Hl HR]".
  - wp_bind (CmpXchg _ _ _).
    iApply (wp_typed_cmpxchg_fail (V:=bool) with "[$]").
    { done. }
    { naive_solver. }
    iNext.
    iIntros "Hl".
    iModIntro. iSplitL "Hl"; first (iNext; iExists true; eauto).
    wp_auto.
    wp_apply "IH"; [iFrame "#" | iFrame].
  - iDestruct "HR" as "[Hl2 HR]".
    iCombine "Hl Hl2" as "Hl".
    rewrite Qp.quarter_three_quarter.
    wp_bind (CmpXchg _ _ _).
    iApply (wp_typed_cmpxchg_suc (V:=bool) with "[$]").
    { constructor. }
    { done. }
    iNext. iIntros "Hl".
    iModIntro.
    iEval (rewrite -Qp.quarter_three_quarter) in "Hl".
    iDestruct "Hl" as "[Hl1 Hl2]".
    iSplitL "Hl1"; first (iNext; iExists true; eauto).
    rewrite /locked. wp_auto.
    iApply "HΦ".
    eauto with iFrame.
Qed.

Lemma wp_spinlock_unlock m R :
  {{{ is_spinlock m R ∗ own_spinlock m ∗ ▷ R }}}
    spinlock.unlock #m
  {{{ RET #(); True }}}.
Proof.
  wp_start as "(#His & Hlocked & HR)". wp_call.
  iNamed "His".
  wp_bind (CmpXchg _ _ _).
  iInv nroot as (b) "[>Hl _]".

  unfold own_spinlock.
  iCombine "Hl Hlocked" gives %[_ [=]]. subst.
  iCombine "Hl Hlocked" as "Hl".
  rewrite Qp.quarter_three_quarter.
  iApply (wp_typed_cmpxchg_suc (V:=bool) with "[$]").
  { econstructor. }
  { econstructor. }
  iIntros "!# Hl".
  iModIntro.
  iSplitR "HΦ"; last by wp_auto; iApply "HΦ".
  iEval (rewrite -Qp.quarter_three_quarter) in "Hl".
  iDestruct "Hl" as "[Hl1 Hl2]".
  iNext. iExists false. iFrame.
Qed.

End proof.
