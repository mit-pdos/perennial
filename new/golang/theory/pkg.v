From New.golang.defn Require Import pkg.
From New.golang.theory Require Import exception assume.
From Perennial Require Import base.
Import Ltac2. Import Printf.
Set Default Proof Mode "Classic".

Set Default Proof Using "Type".

Section init_defns.
Context `{ffi_sem: ffi_semantics} `{!ffi_interp ffi} `{!heapGS Σ} {go_ctx : GoContext}.

Definition is_init (σ : lang.state) : Prop :=
  σ.(go_state).(package_state) = ∅.

(** [own_initializing] denotes permission to run [package.init]. This is
    exclusive because go packages are initialized sequentially, in a single
    thread. The [get_is_pkg_init] mapping contains the agreed-upon post-init
    predicate for every package. Making sure that [get_is_pkg_init] has the
    appropriate user-defined predicates is facilitated by [GetIsPkgInitWf]
    below. *)
Definition own_initializing (get_is_pkg_init : go_string → iProp Σ) : iProp Σ :=
  ∃ package_inited,
    "Hg" ∷ own_go_state package_inited ∗
    (* NOTE: could own an auth that has precisely the "started" keys, and
           the exclusive pointstos can be given to program proofs to help escrow
           resources into initialization. *)
    "#Hinit" ∷ □([∗ map] pkg_name ↦ (inited : bool) ∈ package_inited,
                   if inited then get_is_pkg_init pkg_name else True).
#[global] Opaque own_initializing.
#[local] Transparent own_initializing.

Lemma go_init get_is_pkg_init σ :
  is_init σ →
  own_go_state σ.(go_state).(package_state) ={⊤}=∗
  own_initializing get_is_pkg_init.
Proof.
  intros ->. iIntros "$". iModIntro. iModIntro. by iApply big_sepM_empty.
Qed.

End init_defns.

Section package_init_and_defined.
Context `{ffi_sem: ffi_semantics} `{!ffi_interp ffi} `{!heapGS Σ} {go_ctx : GoContext}.

(** [IsPkgInit] connects pkg names (really the full package path) to their
    post-initialization predicate. There should only be one instance for each
    package name (i.e. each package is meant to have a canonical init
    predicate).

    This also contains the init predicate of all of the dependencies; it is a
    separate field so that the user-specified part can be extracted with lemmas. *)
Class IsPkgInit (pkg_name : go_string) :=
  {
    is_pkg_init_deps : iProp Σ; (* autogenerated; includes [is_pkg_defined] *)
    is_pkg_init_def : iProp Σ; (* user-specified *)
  }.

#[global] Arguments is_pkg_init_deps (pkg_name) {_}.
#[global] Arguments is_pkg_init_def (pkg_name) {_}.

(** [is_pkg_init] asserts the predicate specified in the [IsPkgInit] instance. *)
Definition is_pkg_init (pkg_name : go_string) `{!IsPkgInit pkg_name} : iProp Σ :=
  "#Hdeps" ∷ □ is_pkg_init_deps pkg_name ∗
  "#Hinit" ∷ □ is_pkg_init_def pkg_name.
#[global] Opaque is_pkg_init.
#[local] Transparent is_pkg_init.
#[global] Instance is_pkg_init_pers (pkg_name : go_string) `{!IsPkgInit pkg_name} :
  Persistent (is_pkg_init pkg_name).
Proof. apply _. Qed.

Lemma is_pkg_init_unfold (pkg_name : go_string) `{!IsPkgInit pkg_name} :
  is_pkg_init pkg_name =
  ("#Hdeps" ∷ □ is_pkg_init_deps pkg_name ∗
  "#Hinit" ∷ □ is_pkg_init_def pkg_name)%I.
Proof. done. Qed.

(* access user-defined init predicate. *)
Lemma is_pkg_init_access (pkg_name : go_string) `{!IsPkgInit pkg_name} :
  is_pkg_init pkg_name -∗
  is_pkg_init_def pkg_name.
Proof. iNamed 1. done. Qed.

Lemma is_pkg_init_unfold_deps (pkg_name : go_string) `{!IsPkgInit pkg_name} :
  is_pkg_init pkg_name -∗
  is_pkg_init_deps pkg_name.
Proof. iNamed 1. done. Qed.

(** Maps [pkg_name] to a pure predicate that constrains [get_is_pkg_init] to
    have all of the init predicates for [pkg_name] and its transitive
    dependencies. *)
Class GetIsPkgInitWf (pkg_name : go_string) {PROP} :=
  {
    get_is_pkg_init_prop_def (get_is_pkg_init : go_string → PROP) : Prop
  }.
Notation get_is_pkg_init_prop := get_is_pkg_init_prop_def.
Global Arguments get_is_pkg_init_prop (pkg_name) {_} {_} (get_is_pkg_init).

End package_init_and_defined.

#[global] Hint Mode IsPkgInit - + : typeclass_instances.
#[global] Hint Mode GetIsPkgInitWf + - : typeclass_instances.

Notation get_is_pkg_init_prop := get_is_pkg_init_prop_def.

Ltac2 fail m := Control.throw (Tactic_failure (Some m)).

Local Ltac2 build_pkg_init_deps name :=
  Control.refine
    (fun () =>
       let deps := Std.eval_hnf constr:(pkg_imported_pkgs $name) in
       let rec build_iprop deps :=
         lazy_match! deps with
         | cons ?pkg ?deps =>
             let rest := build_iprop deps in
             constr:((is_pkg_init $pkg ∗ $rest)%I)
         | nil => constr:(True%I)
         | _ =>
             Message.print (Message.of_constr deps);
             fail (fprintf "build_pkg_init_deps: unable to match deps list")
         end in
       build_iprop deps
    ).

Local Ltac2 build_is_pkg_init (is_pkg_init_def : preterm) :=
  Control.refine
    (fun () =>
       lazy_match! goal with
       | [ |- IsPkgInit ?pkg_name ] =>
           constr:(Build_IsPkgInit $pkg_name ltac2:(build_pkg_init_deps pkg_name) $preterm:is_pkg_init_def)
       | [ |- ?x ] => fail (fprintf "build_pkg_init: goal is [%t] instead of [IsPkgInit]" x)
       end
    ).
Reserved Notation "'define_is_pkg_init' is_pkg_init" (at level 100).
Notation "'define_is_pkg_init' is_pkg_init" :=
  (ltac2:(build_is_pkg_init is_pkg_init)) (only parsing, is_pkg_init in scope bi_scope).

Ltac2 build_get_is_pkg_init_wf () :=
  Control.refine
    (fun () =>
       lazy_match! goal with
       | [ |- @GetIsPkgInitWf ?name ?prop] =>
           let deps := Std.eval_hnf constr:(pkg_imported_pkgs $name) in
           let p :=
             constr:(λ (get_is_pkg_init : go_string → $prop),
                       (&get_is_pkg_init $name = is_pkg_init $name) ∧
                       ltac2:(Control.refine
                                (fun () =>
                                   let rec build deps :=
                                     lazy_match! deps with
                                     | cons ?pkg ?deps =>
                                         let rest := build deps in
                                         constr:(get_is_pkg_init_prop $pkg &get_is_pkg_init ∧ $rest)
                                     | nil => constr:(True)
                                     | _ =>
                                         Message.print (Message.of_constr deps);
                                         fail (fprintf "build_get_is_pkg_init_wf: unable to match deps list")
                                     end in
                                   build deps
                                )
                    )) in
           constr:(Build_GetIsPkgInitWf $name $prop $p)
       | [ |- _ ] => fail (fprintf "build_get_is_pkg_init_wf: goal is not (GetIsPkgInitWf _)")
       end
    ).

Notation "'build_get_is_pkg_init_wf'" := (ltac2:(build_get_is_pkg_init_wf ())) (only parsing).

#[global]
Notation "@! func" :=
  #(functions func []) (at level 1, no associativity, format "@! func") : expr_scope.

#[global]
Notation "rcvr @ type @ method" :=
  #(methods type method #rcvr)
    (at level 1, type at next level, no associativity) : expr_scope.

  | |- WpFuncCall _ _ (is_pkg_defined ?pkg_name) =>
      apply (wp_func_call' (pkg_name:=pkg_name)); [reflexivity| iIntros "H"; try iDestruct "H" as "[H _]"; iFrame "H"]
  | _ => fail "solve_wp_func_call: not a WpFuncCall goal"
  end.
  | |- WpMethodCall _ _ _ (is_pkg_defined ?pkg_name) =>
      apply (wp_method_call' (pkg_name:=pkg_name)); [reflexivity | iIntros "H"; try iDestruct "H" as "[H _]"; iFrame "H"]
  | _ => fail "solve_wp_method_call: not a WpMethodCall goal"
  end.
(* FIXME: better implementation using PkgInfo to direct the search. Could try lithium even. *)
(* solve a goal which is just [is_pkg_init] or [is_pkg_defined] *)
Ltac solve_pkg_init :=
  unfold named;
  lazymatch goal with
  | |- environments.envs_entails ?env (is_pkg_init _) => idtac
  | _ => fail "not a is_pkg_init goal"
  end;
  try iAssumption;
  iClear "∗";
  iEval (rewrite ?is_pkg_init_unfold; simpl is_pkg_init_deps; unfold named) in "#";
  repeat
    lazymatch goal with
    | |- environments.envs_entails ?env _ =>
        lazymatch env with
        | context[environments.Esnoc _ ?i (_ ∗ _)%I] =>
            iDestruct i as "[? ?]"
        | context[environments.Esnoc _ ?i (□ _)%I] =>
            iDestruct i as "#?"
        end
    end;
  solve [ iFrame "#" ].

(* Attempt to solve [is_pkg_init] at the front of the goal.

NOTE: The automation here is limited to match what we expect in goals and to make the
implementation simple. It is possible that the shape of expected goals changes,
for example to have multiple [is_pkg_init] conjuncts, in which case this
automation will need improvement.
*)
Ltac iPkgInit :=
  progress (
      try solve_pkg_init;
      repeat (iSplitR; [ solve_pkg_init | ])
    ).

Section package_init.
Context `{ffi_sem: ffi_semantics} `{!ffi_interp ffi} `{!heapGS Σ}.
Context `{!goGlobalsGS Σ}.
Context `{!GoContext}.

#[local] Transparent own_initializing.
Lemma wp_package_init (pkg_name : go_string) `{!PkgInfo pkg_name} (init_func : val) get_is_pkg_init is_pkg_init :
  ∀ Φ,
  get_is_pkg_init pkg_name = is_pkg_init →
  (own_initializing get_is_pkg_init ∗ (own_initializing get_is_pkg_init -∗ WP init_func #() {{ _, □ is_pkg_init ∗ own_initializing get_is_pkg_init }})) -∗
  (own_initializing get_is_pkg_init ∗ is_pkg_init -∗ Φ #()) -∗
  WP package.init pkg_name init_func {{ Φ }}.
Proof.
  intros ? Heq. subst. iIntros "(Hown & Hpre) HΦ". rewrite package.init_unseal.
  wp_call. iNamed "Hown". wp_apply (wp_PackageInitCheck with "[$]").
  iIntros "Hg".
  destruct (default) eqn:Hstatus.
 - wp_pures. iApply "HΦ".
   iFrame "∗#". destruct lookup eqn:Hlookup in Hstatus; last by exfalso.
   iDestruct (big_sepM_lookup with "Hinit") as "H"; first done.
   simpl in *. subst. iFrame "#".
 - wp_pures.
   wp_apply (wp_PackageInitStart with "[$]"). iIntros "Hg". wp_pures.
   iSpecialize ("Hpre" with "[Hg]").
   { iFrame "∗#". iDestruct (big_sepM_insert_2 with "[] Hinit") as "$". done. }
   wp_apply (wp_wand with "Hpre").
   iIntros "* [#? Hown]". wp_pures. iClear "Hinit". iNamed "Hown".
   wp_apply (wp_PackageInitFinish with "[$]"). iIntros "Hg".
   iApply "HΦ". iFrame "∗#".
   iDestruct (big_sepM_insert_2 with "[] Hinit") as "$".
   iFrame "#".
Qed.

End package_init.
