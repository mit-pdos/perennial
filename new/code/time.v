(* autogenerated from time *)

From New.golang Require Import defn.
Require Export New.trusted_code.time.
Import time.
Definition time : go_string := "time".

Module time.

Axiom Layout : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go_string.

Axiom ANSIC : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go_string.

Axiom UnixDate : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go_string.

Axiom RubyDate : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go_string.

Axiom RFC822 : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go_string.

Axiom RFC822Z : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go_string.

Axiom RFC850 : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go_string.

Axiom RFC1123 : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go_string.

Axiom RFC1123Z : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go_string.

Axiom RFC3339 : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go_string.

Axiom RFC3339Nano : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go_string.

Axiom Kitchen : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go_string.

Axiom Stamp : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go_string.

Axiom StampMilli : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go_string.

Axiom StampMicro : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go_string.

Axiom StampNano : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go_string.

Axiom DateTime : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go_string.

Axiom DateOnly : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go_string.

Axiom TimeOnly : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go_string.

Axiom stdLongMonth : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, Z.

Axiom stdMonth : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, Z.

Axiom stdNumMonth : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, Z.

Axiom stdZeroMonth : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, Z.

Axiom stdLongWeekDay : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, Z.

Axiom stdWeekDay : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, Z.

Axiom stdDay : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, Z.

Axiom stdUnderDay : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, Z.

Axiom stdZeroDay : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, Z.

Axiom stdUnderYearDay : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, Z.

Axiom stdZeroYearDay : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, Z.

Axiom stdHour : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, Z.

Axiom stdHour12 : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, Z.

Axiom stdZeroHour12 : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, Z.

Axiom stdMinute : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, Z.

Axiom stdZeroMinute : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, Z.

Axiom stdSecond : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, Z.

Axiom stdZeroSecond : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, Z.

Axiom stdLongYear : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, Z.

Axiom stdYear : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, Z.

Axiom stdPM : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, Z.

Axiom stdpm : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, Z.

Axiom stdTZ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, Z.

Axiom stdISO8601TZ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, Z.

Axiom stdISO8601SecondsTZ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, Z.

Axiom stdISO8601ShortTZ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, Z.

Axiom stdISO8601ColonTZ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, Z.

Axiom stdISO8601ColonSecondsTZ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, Z.

Axiom stdNumTZ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, Z.

Axiom stdNumSecondsTz : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, Z.

Axiom stdNumShortTZ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, Z.

Axiom stdNumColonTZ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, Z.

Axiom stdNumColonSecondsTZ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, Z.

Axiom stdFracSecond0 : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, Z.

Axiom stdFracSecond9 : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, Z.

Axiom stdNeedDate : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, Z.

Axiom stdNeedYday : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, Z.

Axiom stdNeedClock : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, Z.

Axiom stdArgShift : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, Z.

Axiom stdSeparatorShift : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, Z.

Axiom stdMask : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, Z.

Definition std0x {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.std0x"%go.

Axiom std0x'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition startsWithLowerCase {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.startsWithLowerCase"%go.

Definition nextStdChunk {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.nextStdChunk"%go.

Definition longDayNames {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.longDayNames"%go.

Axiom longDayNames'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition shortDayNames {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.shortDayNames"%go.

Axiom shortDayNames'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition shortMonthNames {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.shortMonthNames"%go.

Axiom shortMonthNames'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition longMonthNames {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.longMonthNames"%go.

Axiom longMonthNames'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition match' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.match"%go.

Definition lookup' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.lookup"%go.

Definition appendInt {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.appendInt"%go.

Definition errAtoi {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.errAtoi"%go.

Axiom errAtoi'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition atoi {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.atoi"%go.

Definition stdFracSecond {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.stdFracSecond"%go.

Definition digitsLen {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.digitsLen"%go.

Definition separator {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.separator"%go.

Definition appendNano {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.appendNano"%go.

Definition errBad {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.errBad"%go.

Axiom errBad'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom ParseErrorⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Definition newParseError {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.newParseError"%go.

Axiom lowerhex : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go_string.

Axiom runeSelf : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, Z.

Axiom runeError : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, Z.

Definition quote {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.quote"%go.

Definition isDigit {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.isDigit"%go.

Definition getnum {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.getnum"%go.

Definition getnum3 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.getnum3"%go.

Definition cutspace {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.cutspace"%go.

Definition skip {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.skip"%go.

Definition Parse {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.Parse"%go.

Definition ParseInLocation {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.ParseInLocation"%go.

Definition parse {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.parse"%go.

Definition parseTimeZone {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.parseTimeZone"%go.

Definition parseGMT {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.parseGMT"%go.

Definition parseSignedOffset {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.parseSignedOffset"%go.

Definition commaOrPeriod {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.commaOrPeriod"%go.

Definition parseNanoseconds {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.parseNanoseconds"%go.

Definition errLeadingInt {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.errLeadingInt"%go.

Axiom errLeadingInt'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition leadingInt {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.leadingInt"%go.

Definition leadingFraction {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.leadingFraction"%go.

Definition unitMap {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.unitMap"%go.

Axiom unitMap'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition ParseDuration {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.ParseDuration"%go.

Definition parseRFC3339 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.parseRFC3339"%go.

Definition parseStrictRFC3339 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.parseStrictRFC3339"%go.

Definition Sleep {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.Sleep"%go.

Definition asynctimerchan {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.asynctimerchan"%go.

Axiom asynctimerchan'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition syncTimer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.syncTimer"%go.

Definition when {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.when"%go.

Definition newTimer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.newTimer"%go.

Definition stopTimer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.stopTimer"%go.

Definition resetTimer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.resetTimer"%go.

Definition Time : go.type := go.Named "time.Time"%go [].

Definition Timerⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "C"%go (go.ChannelType go.recvonly Time));
  (go.FieldDecl "initTimer"%go go.bool)
].

Definition Timer : go.type := go.Named "time.Timer"%go [].

Module Timer.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  C : loc;
  initTimer : bool;
}.
#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _)|}.
End def.

#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End Timer.

Class Timer_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Timer_zero_val  :: go.TypeRepr Timer Timer.t;
  #[global] Timer_underlying :: go.Underlying (Timer) (Timerⁱᵐᵖˡ);
  #[global] Timer_get_C (x : Timer.t) :: go.IsGoStepPureDet (StructFieldGet (Timer) "C") #x #x.(Timer.C);
  #[global] Timer_set_C (x : Timer.t) y :: go.IsGoStepPureDet (StructFieldSet (Timer) "C") (#x, #y) #(x <|Timer.C := y|>);
  #[global] Timer_get_initTimer (x : Timer.t) :: go.IsGoStepPureDet (StructFieldGet (Timer) "initTimer") #x #x.(Timer.initTimer);
  #[global] Timer_set_initTimer (x : Timer.t) y :: go.IsGoStepPureDet (StructFieldSet (Timer) "initTimer") (#x, #y) #(x <|Timer.initTimer := y|>);
}.

Definition NewTimer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.NewTimer"%go.

Definition sendTime {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.sendTime"%go.

Definition After {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.After"%go.

Definition AfterFunc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.AfterFunc"%go.

Definition goFunc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.goFunc"%go.

Definition interrupt {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.interrupt"%go.

Definition open {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.open"%go.

Definition read {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.read"%go.

Definition closefd {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.closefd"%go.

Definition preadn {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.preadn"%go.

Axiom Tickerⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Definition NewTicker {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.NewTicker"%go.

Definition Tick {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.Tick"%go.

(* UnixNano returns t as a Unix time, the number of nanoseconds elapsed
   since January 1, 1970 UTC. The result is undefined if the Unix time
   in nanoseconds cannot be represented by an int64 (a date before the year
   1678 or after 2262). Note that this means the result of calling UnixNano
   on the zero Time is undefined. The result does not depend on the
   location associated with t.

   go: time.go:1456:15 *)
Definition Time__UnixNanoⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "t" <>,
    exception_do (let: "t" := (GoAlloc Time "t") in
    return: ((((MethodResolve (go.PointerType Time) "unixSec"%go #() "t") #()) *⟨go.int64⟩ #(W64 1000000000)) +⟨go.int64⟩ (s_to_w64 ((MethodResolve (go.PointerType Time) "nsec"%go #() "t") #())))).

Definition nsecMask {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Z := 1073741823.

(* nsec returns the time's nanoseconds.

   go: time.go:176:16 *)
Definition Time__nsecⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "t" <>,
    exception_do (let: "t" := (GoAlloc (go.PointerType Time) "t") in
    return: (u_to_w32 ((![go.uint64] (StructFieldRef Time "wall"%go (![go.PointerType Time] "t"))) &⟨go.uint64⟩ #(W64 nsecMask)))).

Definition hasMonotonic {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Z := 9223372036854775808.

Definition wallToInternal {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 59453308800).

(* sec returns the time's seconds since Jan 1 year 1.

   go: time.go:181:16 *)
Definition Time__secⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "t" <>,
    exception_do (let: "t" := (GoAlloc (go.PointerType Time) "t") in
    (if: ((![go.uint64] (StructFieldRef Time "wall"%go (![go.PointerType Time] "t"))) &⟨go.uint64⟩ #(W64 hasMonotonic)) ≠⟨go.uint64⟩ #(W64 0)
    then return: (wallToInternal +⟨go.int64⟩ (u_to_w64 (((![go.uint64] (StructFieldRef Time "wall"%go (![go.PointerType Time] "t"))) ≪⟨go.uint64⟩ #(W64 1)) ≫⟨go.uint64⟩ #(W64 31))))
    else do:  #());;;
    return: (![go.int64] (StructFieldRef Time "ext"%go (![go.PointerType Time] "t")))).

Definition internalToUnix {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 (-62135596800)).

(* unixSec returns the time's seconds since Jan 1 1970 (Unix time).

   go: time.go:189:16 *)
Definition Time__unixSecⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "t" <>,
    exception_do (let: "t" := (GoAlloc (go.PointerType Time) "t") in
    return: (((MethodResolve (go.PointerType Time) "sec"%go #() (![go.PointerType Time] "t")) #()) +⟨go.int64⟩ internalToUnix)).

Definition Timeⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "wall"%go go.uint64);
  (go.FieldDecl "ext"%go go.int64);
  (go.FieldDecl "loc"%go (go.PointerType Location))
].

Module Time.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  wall : w64;
  ext : w64;
  loc : loc;
}.
#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _)|}.
End def.

#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End Time.

Class Time_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Time_zero_val  :: go.TypeRepr Time Time.t;
  #[global] Time_underlying :: go.Underlying (Time) (Timeⁱᵐᵖˡ);
  #[global] Time_get_wall (x : Time.t) :: go.IsGoStepPureDet (StructFieldGet (Time) "wall") #x #x.(Time.wall);
  #[global] Time_set_wall (x : Time.t) y :: go.IsGoStepPureDet (StructFieldSet (Time) "wall") (#x, #y) #(x <|Time.wall := y|>);
  #[global] Time_get_ext (x : Time.t) :: go.IsGoStepPureDet (StructFieldGet (Time) "ext") #x #x.(Time.ext);
  #[global] Time_set_ext (x : Time.t) y :: go.IsGoStepPureDet (StructFieldSet (Time) "ext") (#x, #y) #(x <|Time.ext := y|>);
  #[global] Time_get_loc (x : Time.t) :: go.IsGoStepPureDet (StructFieldGet (Time) "loc") #x #x.(Time.loc);
  #[global] Time_set_loc (x : Time.t) y :: go.IsGoStepPureDet (StructFieldSet (Time) "loc") (#x, #y) #(x <|Time.loc := y|>);
  #[global] Time'ptr_UnixNano_unfold :: MethodUnfold (Time) "UnixNano" (Time__UnixNanoⁱᵐᵖˡ);
  #[global] Time'ptr_UnixNano_unfold :: MethodUnfold (go.PointerType (Time)) "UnixNano" (λ: "$r", MethodResolve (Time) UnixNano #() (![(Time)] "$r");
  #[global] Time'ptr_nsec_unfold :: MethodUnfold (go.PointerType (Time)) "nsec" (Time__nsecⁱᵐᵖˡ);
  #[global] Time'ptr_sec_unfold :: MethodUnfold (go.PointerType (Time)) "sec" (Time__secⁱᵐᵖˡ);
  #[global] Time'ptr_unixSec_unfold :: MethodUnfold (go.PointerType (Time)) "unixSec" (Time__unixSecⁱᵐᵖˡ);
}.

Axiom maxWall : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom minWall : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom nsecShift : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, Z.

Axiom Monthⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom January : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom February : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom March : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom April : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom May : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom June : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom July : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom August : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom September : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom October : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom November : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom December : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom Weekdayⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom Sunday : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom Monday : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom Tuesday : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom Wednesday : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom Thursday : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom Friday : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom Saturday : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom secondsPerMinute : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, Z.

Axiom secondsPerHour : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, Z.

Axiom secondsPerDay : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, Z.

Axiom secondsPerWeek : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, Z.

Axiom daysPer400Years : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, Z.

Axiom marchThruDecember : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, Z.

Axiom absoluteYears : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, Z.

Axiom internalYear : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, Z.

Axiom absoluteToInternal : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom internalToAbsolute : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom unixToInternal : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom absoluteToUnix : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom unixToAbsolute : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom absSecondsⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom absDaysⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom absCenturyⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom absCyearⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom absYdayⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom absMonthⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom absLeapⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom absJanFebⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Definition dateToAbsDays {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.dateToAbsDays"%go.

Definition Durationⁱᵐᵖˡ : go.type := go.int64.

Definition Duration : go.type := go.Named "time.Duration"%go [].

Module Duration.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t  : Type := w64.
End def.
End Duration.

Class Duration_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Duration_zero_val  :: go.TypeRepr Duration Duration.t;
  #[global] Duration_underlying :: go.Underlying (Duration) (Durationⁱᵐᵖˡ);
}.

Axiom minDuration : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom maxDuration : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition Nanosecond {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 1).

Definition Microsecond {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 1000).

Definition Millisecond {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 1000000).

Definition Second {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 1000000000).

Axiom Minute : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom Hour : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition fmtFrac {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.fmtFrac"%go.

Definition fmtInt {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.fmtInt"%go.

Definition lessThanHalf {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.lessThanHalf"%go.

Definition subMono {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.subMono"%go.

Definition Since {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.Since"%go.

Definition Until {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.Until"%go.

Definition daysBefore {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.daysBefore"%go.

Definition daysIn {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.daysIn"%go.

Definition now {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.now"%go.

Definition runtimeNow {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.runtimeNow"%go.

Definition runtimeNano {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.runtimeNano"%go.

Definition runtimeIsBubbled {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.runtimeIsBubbled"%go.

Definition startNano {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.startNano"%go.

Axiom startNano'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition Now {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.Now"%go.

Definition unixTime {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.unixTime"%go.

Axiom timeBinaryVersionV1 : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom timeBinaryVersionV2 : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition Unix {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.Unix"%go.

Definition UnixMilli {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.UnixMilli"%go.

Definition UnixMicro {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.UnixMicro"%go.

Definition isLeap {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.isLeap"%go.

Definition norm {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.norm"%go.

Definition Date {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.Date"%go.

Definition div {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.div"%go.

Definition legacyTimeTimeAbs {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.legacyTimeTimeAbs"%go.

Definition legacyAbsClock {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.legacyAbsClock"%go.

Definition legacyAbsDate {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.legacyAbsDate"%go.

Axiom Locationⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom zoneⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom zoneTransⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom alpha : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, Z.

Axiom omega : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, Z.

Definition UTC {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.UTC"%go.

Axiom UTC'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition utcLoc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.utcLoc"%go.

Axiom utcLoc'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition Local {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.Local"%go.

Axiom Local'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition localLoc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.localLoc"%go.

Definition localOnce {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.localOnce"%go.

Definition unnamedFixedZones {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.unnamedFixedZones"%go.

Definition unnamedFixedZonesOnce {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.unnamedFixedZonesOnce"%go.

Definition FixedZone {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.FixedZone"%go.

Definition fixedZone {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.fixedZone"%go.

Definition tzset {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.tzset"%go.

Definition tzsetName {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.tzsetName"%go.

Definition tzsetOffset {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.tzsetOffset"%go.

Axiom ruleKindⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom ruleJulian : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom ruleDOY : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom ruleMonthWeekDay : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom ruleⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Definition tzsetRule {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.tzsetRule"%go.

Definition tzsetNum {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.tzsetNum"%go.

Definition tzruleTime {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.tzruleTime"%go.

Definition errLocation {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.errLocation"%go.

Axiom errLocation'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition zoneinfo {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.zoneinfo"%go.

Definition zoneinfoOnce {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.zoneinfoOnce"%go.

Definition LoadLocation {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.LoadLocation"%go.

Definition containsDotDot {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.containsDotDot"%go.

Definition gorootZoneSource {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.gorootZoneSource"%go.

Definition registerLoadFromEmbeddedTZData {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.registerLoadFromEmbeddedTZData"%go.

Definition loadFromEmbeddedTZData {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.loadFromEmbeddedTZData"%go.

Axiom maxFileSize : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, Z.

Axiom fileSizeErrorⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom seekStart : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, Z.

Axiom seekCurrent : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, Z.

Axiom seekEnd : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, Z.

Axiom dataIOⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Definition byteString {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.byteString"%go.

Definition errBadData {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.errBadData"%go.

Axiom errBadData'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition LoadLocationFromTZData {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.LoadLocationFromTZData"%go.

Definition findZone {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.findZone"%go.

Definition loadTzinfoFromDirOrZip {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.loadTzinfoFromDirOrZip"%go.

Definition get4 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.get4"%go.

Definition get2 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.get2"%go.

Definition loadTzinfoFromZip {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.loadTzinfoFromZip"%go.

Definition loadTzinfoFromTzdata {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.loadTzinfoFromTzdata"%go.

Definition loadTzinfo {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.loadTzinfo"%go.

Definition loadLocation {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.loadLocation"%go.

Definition readFile {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.readFile"%go.

Definition platformZoneSources {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.platformZoneSources"%go.

Axiom platformZoneSources'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition initLocal {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.initLocal"%go.

#[global] Instance info' : PkgInfo time.time := 
{|
  pkg_imported_pkgs := []
|}.

Axiom _'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init time.time (λ: <>,
      exception_do (do:  (std0x'init #());;;
      do:  (longDayNames'init #());;;
      do:  (shortDayNames'init #());;;
      do:  (shortMonthNames'init #());;;
      do:  (longMonthNames'init #());;;
      do:  (errAtoi'init #());;;
      do:  (errBad'init #());;;
      do:  (errLeadingInt'init #());;;
      do:  (unitMap'init #());;;
      do:  (asynctimerchan'init #());;;
      do:  (startNano'init #());;;
      do:  (utcLoc'init #());;;
      do:  (UTC'init #());;;
      do:  (Local'init #());;;
      do:  (errLocation'init #());;;
      do:  (errBadData'init #());;;
      do:  (platformZoneSources'init #()))
      ).

Class Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Timer_instance :: Timer_Assumptions;
  #[global] Time_instance :: Time_Assumptions;
  #[global] Duration_instance :: Duration_Assumptions;
  #[global] Sleep_unfold :: FuncUnfold Sleep [] (Sleepⁱᵐᵖˡ);
  #[global] syncTimer_unfold :: FuncUnfold syncTimer [] (syncTimerⁱᵐᵖˡ);
  #[global] newTimer_unfold :: FuncUnfold newTimer [] (newTimerⁱᵐᵖˡ);
  #[global] After_unfold :: FuncUnfold After [] (Afterⁱᵐᵖˡ);
  #[global] runtimeNano_unfold :: FuncUnfold runtimeNano [] (runtimeNanoⁱᵐᵖˡ);
}.
End time.
