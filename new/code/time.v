(* autogenerated from time *)
From New.golang Require Import defn.
Require Export New.trusted_code.time.
Import time.
Module pkg_id.
Definition time : go_string := "time".

End pkg_id.
Export pkg_id.
Module time.

Definition ParseError {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "time.ParseError"%go [].

Definition Timer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "time.Timer"%go [].

Definition Ticker {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "time.Ticker"%go [].

Definition Time {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "time.Time"%go [].

Definition Month {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "time.Month"%go [].

Definition Weekday {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "time.Weekday"%go [].

Definition absSeconds {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "time.absSeconds"%go [].

Definition absDays {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "time.absDays"%go [].

Definition absCentury {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "time.absCentury"%go [].

Definition absCyear {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "time.absCyear"%go [].

Definition absYday {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "time.absYday"%go [].

Definition absMonth {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "time.absMonth"%go [].

Definition absLeap {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "time.absLeap"%go [].

Definition absJanFeb {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "time.absJanFeb"%go [].

Definition Duration {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "time.Duration"%go [].

Definition Location {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "time.Location"%go [].

Definition zone {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "time.zone"%go [].

Definition zoneTrans {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "time.zoneTrans"%go [].

Definition ruleKind {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "time.ruleKind"%go [].

Definition rule {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "time.rule"%go [].

Definition fileSizeError {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "time.fileSizeError"%go [].

Definition dataIO {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "time.dataIO"%go [].

Axiom Layout : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom ANSIC : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom UnixDate : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom RubyDate : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom RFC822 : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom RFC822Z : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom RFC850 : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom RFC1123 : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom RFC1123Z : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom RFC3339 : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom RFC3339Nano : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom Kitchen : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom Stamp : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom StampMilli : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom StampMicro : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom StampNano : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom DateTime : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom DateOnly : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom TimeOnly : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom stdLongMonth : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom stdMonth : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom stdNumMonth : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom stdZeroMonth : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom stdLongWeekDay : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom stdWeekDay : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom stdDay : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom stdUnderDay : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom stdZeroDay : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom stdUnderYearDay : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom stdZeroYearDay : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom stdHour : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom stdHour12 : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom stdZeroHour12 : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom stdMinute : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom stdZeroMinute : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom stdSecond : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom stdZeroSecond : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom stdLongYear : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom stdYear : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom stdPM : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom stdpm : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom stdTZ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom stdISO8601TZ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom stdISO8601SecondsTZ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom stdISO8601ShortTZ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom stdISO8601ColonTZ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom stdISO8601ColonSecondsTZ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom stdNumTZ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom stdNumSecondsTz : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom stdNumShortTZ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom stdNumColonTZ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom stdNumColonSecondsTZ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom stdFracSecond0 : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom stdFracSecond9 : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom stdNeedDate : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom stdNeedYday : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom stdNeedClock : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom stdArgShift : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom stdSeparatorShift : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom stdMask : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom lowerhex : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom runeSelf : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom runeError : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition hasMonotonic {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #9223372036854775808.

Axiom maxWall : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom minWall : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition nsecMask {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #1073741823.

Axiom nsecShift : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom January : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom February : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom March : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom April : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom May : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom June : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom July : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom August : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom September : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom October : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom November : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom December : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom Sunday : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom Monday : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom Tuesday : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom Wednesday : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom Thursday : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom Friday : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom Saturday : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom secondsPerMinute : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom secondsPerHour : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom secondsPerDay : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom secondsPerWeek : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom daysPer400Years : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom marchThruDecember : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom absoluteYears : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom internalYear : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom absoluteToInternal : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom internalToAbsolute : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom unixToInternal : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition internalToUnix {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 (-62135596800)).

Axiom absoluteToUnix : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom unixToAbsolute : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition wallToInternal {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 59453308800).

Axiom minDuration : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom maxDuration : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition Nanosecond {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 1).

Definition Microsecond {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 1000).

Definition Millisecond {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 1000000).

Definition Second {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 1000000000).

Axiom Minute : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom Hour : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom timeBinaryVersionV1 : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom timeBinaryVersionV2 : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom alpha : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom omega : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom ruleJulian : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom ruleDOY : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom ruleMonthWeekDay : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom maxFileSize : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom seekStart : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom seekCurrent : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom seekEnd : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition std0x {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.std0x"%go.

Axiom std0x'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition longDayNames {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.longDayNames"%go.

Axiom longDayNames'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition shortDayNames {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.shortDayNames"%go.

Axiom shortDayNames'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition shortMonthNames {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.shortMonthNames"%go.

Axiom shortMonthNames'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition longMonthNames {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.longMonthNames"%go.

Axiom longMonthNames'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition errAtoi {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.errAtoi"%go.

Axiom errAtoi'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition errBad {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.errBad"%go.

Axiom errBad'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition errLeadingInt {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.errLeadingInt"%go.

Axiom errLeadingInt'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition unitMap {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.unitMap"%go.

Axiom unitMap'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition asynctimerchan {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.asynctimerchan"%go.

Axiom asynctimerchan'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition startNano {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.startNano"%go.

Axiom startNano'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition UTC {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.UTC"%go.

Axiom UTC'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition utcLoc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.utcLoc"%go.

Axiom utcLoc'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition Local {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.Local"%go.

Axiom Local'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition localLoc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.localLoc"%go.

Definition localOnce {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.localOnce"%go.

Definition unnamedFixedZones {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.unnamedFixedZones"%go.

Definition unnamedFixedZonesOnce {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.unnamedFixedZonesOnce"%go.

Definition errLocation {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.errLocation"%go.

Axiom errLocation'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition zoneinfo {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.zoneinfo"%go.

Definition zoneinfoOnce {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.zoneinfoOnce"%go.

Definition loadFromEmbeddedTZData {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.loadFromEmbeddedTZData"%go.

Definition errBadData {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.errBadData"%go.

Axiom errBadData'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition loadTzinfoFromTzdata {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.loadTzinfoFromTzdata"%go.

Definition platformZoneSources {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.platformZoneSources"%go.

Axiom platformZoneSources'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition startsWithLowerCase {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.startsWithLowerCase"%go.

Definition nextStdChunk {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.nextStdChunk"%go.

Definition match' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.match"%go.

Definition lookup' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.lookup"%go.

Definition appendInt {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.appendInt"%go.

Definition atoi {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.atoi"%go.

Definition stdFracSecond {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.stdFracSecond"%go.

Definition digitsLen {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.digitsLen"%go.

Definition separator {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.separator"%go.

Definition appendNano {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.appendNano"%go.

Definition newParseError {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.newParseError"%go.

Definition quote {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.quote"%go.

Definition isDigit {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.isDigit"%go.

Definition getnum {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.getnum"%go.

Definition getnum3 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.getnum3"%go.

Definition cutspace {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.cutspace"%go.

Definition skip {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.skip"%go.

Definition Parse {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.Parse"%go.

Definition ParseInLocation {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.ParseInLocation"%go.

Definition parse {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.parse"%go.

Definition parseTimeZone {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.parseTimeZone"%go.

Definition parseGMT {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.parseGMT"%go.

Definition parseSignedOffset {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.parseSignedOffset"%go.

Definition commaOrPeriod {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.commaOrPeriod"%go.

Definition parseNanoseconds {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.parseNanoseconds"%go.

Definition leadingInt {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.leadingInt"%go.

Definition leadingFraction {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.leadingFraction"%go.

Definition ParseDuration {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.ParseDuration"%go.

Definition parseRFC3339 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.parseRFC3339"%go.

Definition parseStrictRFC3339 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.parseStrictRFC3339"%go.

Definition Sleep {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.Sleep"%go.

Definition syncTimer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.syncTimer"%go.

Definition when {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.when"%go.

Definition newTimer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.newTimer"%go.

Definition stopTimer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.stopTimer"%go.

Definition resetTimer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.resetTimer"%go.

Definition NewTimer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.NewTimer"%go.

Definition sendTime {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.sendTime"%go.

Definition After {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.After"%go.

Definition AfterFunc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.AfterFunc"%go.

Definition goFunc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.goFunc"%go.

Definition interrupt {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.interrupt"%go.

Definition open {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.open"%go.

Definition read {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.read"%go.

Definition closefd {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.closefd"%go.

Definition preadn {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.preadn"%go.

Definition NewTicker {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.NewTicker"%go.

Definition Tick {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.Tick"%go.

Definition dateToAbsDays {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.dateToAbsDays"%go.

Definition fmtFrac {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.fmtFrac"%go.

Definition fmtInt {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.fmtInt"%go.

Definition lessThanHalf {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.lessThanHalf"%go.

Definition subMono {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.subMono"%go.

Definition Since {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.Since"%go.

Definition Until {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.Until"%go.

Definition daysBefore {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.daysBefore"%go.

Definition daysIn {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.daysIn"%go.

Definition now {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.now"%go.

Definition runtimeNow {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.runtimeNow"%go.

Definition runtimeNano {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.runtimeNano"%go.

Definition runtimeIsBubbled {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.runtimeIsBubbled"%go.

Definition Now {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.Now"%go.

Definition unixTime {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.unixTime"%go.

Definition Unix {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.Unix"%go.

Definition UnixMilli {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.UnixMilli"%go.

Definition UnixMicro {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.UnixMicro"%go.

Definition isLeap {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.isLeap"%go.

Definition norm {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.norm"%go.

Definition Date {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.Date"%go.

Definition div {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.div"%go.

Definition legacyTimeTimeAbs {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.legacyTimeTimeAbs"%go.

Definition legacyAbsClock {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.legacyAbsClock"%go.

Definition legacyAbsDate {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.legacyAbsDate"%go.

Definition FixedZone {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.FixedZone"%go.

Definition fixedZone {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.fixedZone"%go.

Definition tzset {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.tzset"%go.

Definition tzsetName {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.tzsetName"%go.

Definition tzsetOffset {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.tzsetOffset"%go.

Definition tzsetRule {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.tzsetRule"%go.

Definition tzsetNum {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.tzsetNum"%go.

Definition tzruleTime {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.tzruleTime"%go.

Definition LoadLocation {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.LoadLocation"%go.

Definition containsDotDot {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.containsDotDot"%go.

Definition gorootZoneSource {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.gorootZoneSource"%go.

Definition registerLoadFromEmbeddedTZData {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.registerLoadFromEmbeddedTZData"%go.

Definition byteString {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.byteString"%go.

Definition LoadLocationFromTZData {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.LoadLocationFromTZData"%go.

Definition findZone {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.findZone"%go.

Definition loadTzinfoFromDirOrZip {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.loadTzinfoFromDirOrZip"%go.

Definition get4 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.get4"%go.

Definition get2 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.get2"%go.

Definition loadTzinfoFromZip {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.loadTzinfoFromZip"%go.

Definition loadTzinfo {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.loadTzinfo"%go.

Definition loadLocation {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.loadLocation"%go.

Definition readFile {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.readFile"%go.

Definition initLocal {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "time.initLocal"%go.

(* nsec returns the time's nanoseconds.

   go: time.go:176:16 *)
Definition Time__nsecⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "t" <>,
    exception_do (let: "t" := (GoAlloc (go.PointerType Time) "t") in
    return: (Convert go.uint64 go.int32 ((![go.uint64] (StructFieldRef Time "wall"%go (![go.PointerType Time] "t"))) &⟨go.uint64⟩ (Convert go.untyped_int go.uint64 nsecMask)))).

(* sec returns the time's seconds since Jan 1 year 1.

   go: time.go:181:16 *)
Definition Time__secⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "t" <>,
    exception_do (let: "t" := (GoAlloc (go.PointerType Time) "t") in
    (if: Convert go.untyped_bool go.bool (((![go.uint64] (StructFieldRef Time "wall"%go (![go.PointerType Time] "t"))) &⟨go.uint64⟩ (Convert go.untyped_int go.uint64 hasMonotonic)) ≠⟨go.uint64⟩ #(W64 0))
    then return: (wallToInternal +⟨go.int64⟩ (Convert go.uint64 go.int64 (((![go.uint64] (StructFieldRef Time "wall"%go (![go.PointerType Time] "t"))) <<⟨go.uint64⟩ (Convert go.untyped_int go.uint64 #1)) >>⟨go.uint64⟩ (Convert go.untyped_int go.uint64 #31))))
    else do:  #());;;
    return: (![go.int64] (StructFieldRef Time "ext"%go (![go.PointerType Time] "t")))).

(* unixSec returns the time's seconds since Jan 1 1970 (Unix time).

   go: time.go:189:16 *)
Definition Time__unixSecⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "t" <>,
    exception_do (let: "t" := (GoAlloc (go.PointerType Time) "t") in
    return: (((MethodResolve (go.PointerType Time) "sec"%go #() (![go.PointerType Time] "t")) #()) +⟨go.int64⟩ internalToUnix)).

(* UnixNano returns t as a Unix time, the number of nanoseconds elapsed
   since January 1, 1970 UTC. The result is undefined if the Unix time
   in nanoseconds cannot be represented by an int64 (a date before the year
   1678 or after 2262). Note that this means the result of calling UnixNano
   on the zero Time is undefined. The result does not depend on the
   location associated with t.

   go: time.go:1456:15 *)
Definition Time__UnixNanoⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "t" <>,
    exception_do (let: "t" := (GoAlloc Time "t") in
    return: ((((MethodResolve (go.PointerType Time) "unixSec"%go #() "t") #()) *⟨go.int64⟩ #(W64 1000000000)) +⟨go.int64⟩ (Convert go.int32 go.int64 ((MethodResolve (go.PointerType Time) "nsec"%go #() "t") #())))).

#[global] Instance info' : PkgInfo pkg_id.time :=
{|
  pkg_imported_pkgs := []
|}.

Axiom _'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init pkg_id.time (λ: <>,
      exception_do (do:  (std0x'init #());;;
      do:  (longDayNames'init #());;;
      do:  (shortDayNames'init #());;;
      do:  (shortMonthNames'init #());;;
      do:  (longMonthNames'init #());;;
      do:  (errAtoi'init #());;;
      do:  (errBad'init #());;;
      do:  (errLeadingInt'init #());;;
      do:  (unitMap'init #());;;
      do:  (asynctimerchan'init #());;;
      do:  (startNano'init #());;;
      do:  (utcLoc'init #());;;
      do:  (UTC'init #());;;
      do:  (Local'init #());;;
      do:  (errLocation'init #());;;
      do:  (errBadData'init #());;;
      do:  (platformZoneSources'init #()))
      ).

Module ParseError.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End ParseError.

Class ParseError_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] ParseError_type_repr  :: go.TypeRepr ParseError ParseError.t;
}.

Module Time.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  wall' : w64;
  ext' : w64;
  loc' : loc;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End Time.

Definition Timeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType [
  (go.FieldDecl "wall"%go go.uint64);
  (go.FieldDecl "ext"%go go.int64);
  (go.FieldDecl "loc"%go (go.PointerType Location))
].

Class Time_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Time_type_repr  :: go.TypeRepr Time Time.t;
  #[global] Time_underlying :: go.Underlying (Time) (Timeⁱᵐᵖˡ);
  #[global] Time_get_wall (x : Time.t) :: go.IsGoStepPureDet (StructFieldGet (Time) "wall") #x #x.(Time.wall');
  #[global] Time_set_wall (x : Time.t) y :: go.IsGoStepPureDet (StructFieldSet (Time) "wall") (#x, #y) #(x <|Time.wall' := y|>);
  #[global] Time_get_ext (x : Time.t) :: go.IsGoStepPureDet (StructFieldGet (Time) "ext") #x #x.(Time.ext');
  #[global] Time_set_ext (x : Time.t) y :: go.IsGoStepPureDet (StructFieldSet (Time) "ext") (#x, #y) #(x <|Time.ext' := y|>);
  #[global] Time_get_loc (x : Time.t) :: go.IsGoStepPureDet (StructFieldGet (Time) "loc") #x #x.(Time.loc');
  #[global] Time_set_loc (x : Time.t) y :: go.IsGoStepPureDet (StructFieldSet (Time) "loc") (#x, #y) #(x <|Time.loc' := y|>);
  #[global] Time_UnixNano_unfold :: MethodUnfold (Time) "UnixNano" (Time__UnixNanoⁱᵐᵖˡ);
  #[global] Time'ptr_UnixNano_unfold :: MethodUnfold (go.PointerType (Time)) "UnixNano" (λ: "$r", MethodResolve (Time) "UnixNano" #() (![(Time)] "$r"));
  #[global] Time'ptr_nsec_unfold :: MethodUnfold (go.PointerType (Time)) "nsec" (Time__nsecⁱᵐᵖˡ);
  #[global] Time'ptr_sec_unfold :: MethodUnfold (go.PointerType (Time)) "sec" (Time__secⁱᵐᵖˡ);
  #[global] Time'ptr_unixSec_unfold :: MethodUnfold (go.PointerType (Time)) "unixSec" (Time__unixSecⁱᵐᵖˡ);
}.

Module Timer.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  C' : loc;
  initTimer' : bool;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End Timer.

Definition Timerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType [
  (go.FieldDecl "C"%go (go.ChannelType go.recvonly Time));
  (go.FieldDecl "initTimer"%go go.bool)
].

Class Timer_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Timer_type_repr  :: go.TypeRepr Timer Timer.t;
  #[global] Timer_underlying :: go.Underlying (Timer) (Timerⁱᵐᵖˡ);
  #[global] Timer_get_C (x : Timer.t) :: go.IsGoStepPureDet (StructFieldGet (Timer) "C") #x #x.(Timer.C');
  #[global] Timer_set_C (x : Timer.t) y :: go.IsGoStepPureDet (StructFieldSet (Timer) "C") (#x, #y) #(x <|Timer.C' := y|>);
  #[global] Timer_get_initTimer (x : Timer.t) :: go.IsGoStepPureDet (StructFieldGet (Timer) "initTimer") #x #x.(Timer.initTimer');
  #[global] Timer_set_initTimer (x : Timer.t) y :: go.IsGoStepPureDet (StructFieldSet (Timer) "initTimer") (#x, #y) #(x <|Timer.initTimer' := y|>);
}.

Module Ticker.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End Ticker.

Class Ticker_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Ticker_type_repr  :: go.TypeRepr Ticker Ticker.t;
}.

Module Month.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End Month.

Class Month_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Month_type_repr  :: go.TypeRepr Month Month.t;
}.

Module Weekday.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End Weekday.

Class Weekday_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Weekday_type_repr  :: go.TypeRepr Weekday Weekday.t;
}.

Module absSeconds.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End absSeconds.

Class absSeconds_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] absSeconds_type_repr  :: go.TypeRepr absSeconds absSeconds.t;
}.

Module absDays.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End absDays.

Class absDays_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] absDays_type_repr  :: go.TypeRepr absDays absDays.t;
}.

Module absCentury.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End absCentury.

Class absCentury_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] absCentury_type_repr  :: go.TypeRepr absCentury absCentury.t;
}.

Module absCyear.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End absCyear.

Class absCyear_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] absCyear_type_repr  :: go.TypeRepr absCyear absCyear.t;
}.

Module absYday.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End absYday.

Class absYday_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] absYday_type_repr  :: go.TypeRepr absYday absYday.t;
}.

Module absMonth.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End absMonth.

Class absMonth_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] absMonth_type_repr  :: go.TypeRepr absMonth absMonth.t;
}.

Module absLeap.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End absLeap.

Class absLeap_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] absLeap_type_repr  :: go.TypeRepr absLeap absLeap.t;
}.

Module absJanFeb.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End absJanFeb.

Class absJanFeb_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] absJanFeb_type_repr  :: go.TypeRepr absJanFeb absJanFeb.t;
}.

Module Duration.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := w64.
End def.
End Duration.

Definition Durationⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.int64.

Class Duration_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Duration_type_repr  :: go.TypeRepr Duration Duration.t;
  #[global] Duration_underlying :: go.Underlying (Duration) (Durationⁱᵐᵖˡ);
}.

Module Location.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End Location.

Class Location_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Location_type_repr  :: go.TypeRepr Location Location.t;
}.

Module zone.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End zone.

Class zone_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] zone_type_repr  :: go.TypeRepr zone zone.t;
}.

Module zoneTrans.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End zoneTrans.

Class zoneTrans_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] zoneTrans_type_repr  :: go.TypeRepr zoneTrans zoneTrans.t;
}.

Module ruleKind.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End ruleKind.

Class ruleKind_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] ruleKind_type_repr  :: go.TypeRepr ruleKind ruleKind.t;
}.

Module rule.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End rule.

Class rule_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] rule_type_repr  :: go.TypeRepr rule rule.t;
}.

Module fileSizeError.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End fileSizeError.

Class fileSizeError_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] fileSizeError_type_repr  :: go.TypeRepr fileSizeError fileSizeError.t;
}.

Module dataIO.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End dataIO.

Class dataIO_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] dataIO_type_repr  :: go.TypeRepr dataIO dataIO.t;
}.

Class Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] ParseError_instance :: ParseError_Assumptions;
  #[global] Timer_instance :: Timer_Assumptions;
  #[global] Ticker_instance :: Ticker_Assumptions;
  #[global] Time_instance :: Time_Assumptions;
  #[global] Month_instance :: Month_Assumptions;
  #[global] Weekday_instance :: Weekday_Assumptions;
  #[global] absSeconds_instance :: absSeconds_Assumptions;
  #[global] absDays_instance :: absDays_Assumptions;
  #[global] absCentury_instance :: absCentury_Assumptions;
  #[global] absCyear_instance :: absCyear_Assumptions;
  #[global] absYday_instance :: absYday_Assumptions;
  #[global] absMonth_instance :: absMonth_Assumptions;
  #[global] absLeap_instance :: absLeap_Assumptions;
  #[global] absJanFeb_instance :: absJanFeb_Assumptions;
  #[global] Duration_instance :: Duration_Assumptions;
  #[global] Location_instance :: Location_Assumptions;
  #[global] zone_instance :: zone_Assumptions;
  #[global] zoneTrans_instance :: zoneTrans_Assumptions;
  #[global] ruleKind_instance :: ruleKind_Assumptions;
  #[global] rule_instance :: rule_Assumptions;
  #[global] fileSizeError_instance :: fileSizeError_Assumptions;
  #[global] dataIO_instance :: dataIO_Assumptions;
  #[global] Sleep_unfold :: FuncUnfold Sleep [] (Sleepⁱᵐᵖˡ);
  #[global] syncTimer_unfold :: FuncUnfold syncTimer [] (syncTimerⁱᵐᵖˡ);
  #[global] newTimer_unfold :: FuncUnfold newTimer [] (newTimerⁱᵐᵖˡ);
  #[global] After_unfold :: FuncUnfold After [] (Afterⁱᵐᵖˡ);
  #[global] runtimeNano_unfold :: FuncUnfold runtimeNano [] (runtimeNanoⁱᵐᵖˡ);
}.
End time.
