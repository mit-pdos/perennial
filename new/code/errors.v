(* autogenerated from errors *)
From New.golang Require Import defn.
Module pkg_id.
Definition errors : go_string := "errors".

End pkg_id.
Export pkg_id.
Module errors.

Definition errorString {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "errors.errorString"%go [].

Definition joinError {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "errors.joinError"%go [].

Axiom joinErrorⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Definition ErrUnsupported {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "errors.ErrUnsupported"%go.

Axiom ErrUnsupported'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition errorType {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "errors.errorType"%go.

Axiom errorType'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition New {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "errors.New"%go.

Definition Join {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "errors.Join"%go.

Definition Unwrap {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "errors.Unwrap"%go.

Definition Is {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "errors.Is"%go.

Definition is' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "errors.is"%go.

Definition As {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "errors.As"%go.

Definition as' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "errors.as"%go.

(* New returns an error that formats as the given text.
   Each call to New returns a distinct error value even if the text is identical.

   go: errors.go:64:6 *)
Definition Newⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "text",
    exception_do (let: "text" := (GoAlloc go.string "text") in
    return: (Convert (go.PointerType errorString) go.error (GoAlloc errorString (CompositeLiteral errorString (LiteralValue [KeyedElement None (ElementExpression go.string (![go.string] "text"))]))))).

(* go: errors.go:73:23 *)
Definition errorString__Errorⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "e" <>,
    exception_do (let: "e" := (GoAlloc (go.PointerType errorString) "e") in
    return: (![go.string] (StructFieldRef errorString "s"%go (![go.PointerType errorString] "e")))).

(* Unwrap returns the result of calling the Unwrap method on err, if err's
   type contains an Unwrap method returning error.
   Otherwise, Unwrap returns nil.

   Unwrap only calls a method of the form "Unwrap() error".
   In particular Unwrap does not unwrap errors returned by [Join].

   go: wrap.go:17:6 *)
Definition Unwrapⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "err",
    exception_do (let: "err" := (GoAlloc go.error "err") in
    let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "u" := (GoAlloc (go.InterfaceType [go.MethodElem "Unwrap"%go (go.Signature [] false [go.error])]) (GoZeroVal (go.InterfaceType [go.MethodElem "Unwrap"%go (go.Signature [] false [go.error])]) #())) in
    let: ("$ret0", "$ret1") := (TypeAssert2 (go.InterfaceType [go.MethodElem "Unwrap"%go (go.Signature [] false [go.error])]) (![go.error] "err")) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("u" <-[go.InterfaceType [go.MethodElem "Unwrap"%go (go.Signature [] false [go.error])]] "$r0");;;
    do:  ("ok" <-[go.bool] "$r1");;;
    (if: (⟨go.bool⟩! (![go.bool] "ok"))
    then return: (Convert go.untyped_nil go.error UntypedNil)
    else do:  #());;;
    return: ((MethodResolve (go.InterfaceType [go.MethodElem "Unwrap"%go (go.Signature [] false [go.error])]) "Unwrap"%go (![go.InterfaceType [go.MethodElem "Unwrap"%go (go.Signature [] false [go.error])]] "u")) #())).

#[global] Instance info' : PkgInfo pkg_id.errors :=
{|
  pkg_imported_pkgs := []
|}.

Axiom _'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init pkg_id.errors (λ: <>,
      exception_do (do:  (ErrUnsupported'init #());;;
      do:  (errorType'init #()))
      ).

Module errorString.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  s' : go_string;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End errorString.

Definition errorString'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "s"%go go.string)
].
Program Definition errorString'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (errorString'fds_unsealed).
Global Instance equals_unfold_errorString {ext : ffi_syntax} {go_gctx : GoGlobalContext} : errorString'fds =→ errorString'fds_unsealed.
Proof. rewrite /errorString'fds seal_eq //. Qed.

Definition errorStringⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (errorString'fds).

Class errorString_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] errorString_type_repr  :: go.TypeReprUnderlying errorStringⁱᵐᵖˡ errorString.t;
  #[global] errorString_underlying :: (errorString) <u (errorStringⁱᵐᵖˡ);
  #[global] errorString_get_s (x : errorString.t) :: ⟦StructFieldGet (errorStringⁱᵐᵖˡ) "s", #x⟧ ⤳[under] #x.(errorString.s');
  #[global] errorString_set_s (x : errorString.t) y :: ⟦StructFieldSet (errorStringⁱᵐᵖˡ) "s", (#x, #y)⟧ ⤳[under] #(x <|errorString.s' := y|>);
  #[global] errorString'ptr_Error_unfold :: MethodUnfold (go.PointerType (errorString)) "Error" (errorString__Errorⁱᵐᵖˡ);
}.

Module joinError.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End joinError.

Class joinError_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] joinError_type_repr  :: go.TypeReprUnderlying joinErrorⁱᵐᵖˡ joinError.t;
  #[global] joinError_underlying :: (joinError) <u (joinErrorⁱᵐᵖˡ);
  #[global] joinErrorⁱᵐᵖˡ_underlying :: (joinErrorⁱᵐᵖˡ) ↓u (joinErrorⁱᵐᵖˡ);
}.

Class Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] errorString_instance :: errorString_Assumptions;
  #[global] joinError_instance :: joinError_Assumptions;
  #[global] New_unfold :: FuncUnfold New [] (Newⁱᵐᵖˡ);
  #[global] Unwrap_unfold :: FuncUnfold Unwrap [] (Unwrapⁱᵐᵖˡ);
}.
End errors.
