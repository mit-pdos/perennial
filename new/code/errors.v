(* autogenerated from errors *)
From New.golang Require Import defn.
Module pkg_id.
Definition errors : go_string := "errors".

End pkg_id.
Export pkg_id.
Module errors.

Definition errorString {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "errors.errorString"%go [].

#[global] Opaque errorString.

Definition joinError {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "errors.joinError"%go [].

#[global] Opaque joinError.

Axiom joinErrorⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Definition ErrUnsupported {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "errors.ErrUnsupported"%go.

Axiom ErrUnsupported'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition errorType {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "errors.errorType"%go.

Axiom errorType'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition New {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "errors.New"%go.

Definition Join {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "errors.Join"%go.

Definition Unwrap {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "errors.Unwrap"%go.

Definition Is {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "errors.Is"%go.

Definition is' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "errors.is"%go.

Definition As {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "errors.As"%go.

Definition as' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "errors.as"%go.

Definition AsType {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "errors.AsType"%go.

Definition asType {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "errors.asType"%go.

(* New returns an error that formats as the given text.
   Each call to New returns a distinct error value even if the text is identical.

   go: errors.go:64:6 *)
Definition Newⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "text",
    exception_do (let: "text" := (GoAlloc go.string "text") in
    return: (Convert (go.PointerType errorString) go.error (GoAlloc errorString (let: "$v0" := (![go.string] "text") in
     CompositeLiteral errorString (LiteralValue [KeyedElement None (ElementExpression go.string "$v0")]))))).

(* go: errors.go:73:23 *)
Definition errorString__Errorⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "e" <>,
    exception_do (let: "e" := (GoAlloc (go.PointerType errorString) "e") in
    return: (![go.string] (StructFieldRef errorString "s"%go (![go.PointerType errorString] "e")))).

(* Unwrap returns the result of calling the Unwrap method on err, if err's
   type contains an Unwrap method returning error.
   Otherwise, Unwrap returns nil.

   Unwrap only calls a method of the form "Unwrap() error".
   In particular Unwrap does not unwrap errors returned by [Join].

   go: wrap.go:17:6 *)
Definition Unwrapⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "err",
    exception_do (let: "err" := (GoAlloc go.error "err") in
    let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "u" := (GoAlloc (go.InterfaceType [go.MethodElem "Unwrap"%go (go.Signature [] false [go.error])]) (GoZeroVal (go.InterfaceType [go.MethodElem "Unwrap"%go (go.Signature [] false [go.error])]) #())) in
    let: ("$ret0", "$ret1") := (TypeAssert2 (go.InterfaceType [go.MethodElem "Unwrap"%go (go.Signature [] false [go.error])]) (![go.error] "err")) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("u" <-[go.InterfaceType [go.MethodElem "Unwrap"%go (go.Signature [] false [go.error])]] "$r0");;;
    do:  ("ok" <-[go.bool] "$r1");;;
    (if: (⟨go.bool⟩! (![go.bool] "ok"))
    then return: (Convert go.untyped_nil go.error UntypedNil)
    else do:  #());;;
    return: ((MethodResolve (go.InterfaceType [go.MethodElem "Unwrap"%go (go.Signature [] false [go.error])]) "Unwrap"%go (![go.InterfaceType [go.MethodElem "Unwrap"%go (go.Signature [] false [go.error])]] "u")) #())).

(* AsType finds the first error in err's tree that matches the type E, and
   if one is found, returns that error value and true. Otherwise, it
   returns the zero value of E and false.

   The tree consists of err itself, followed by the errors obtained by
   repeatedly calling its Unwrap() error or Unwrap() []error method. When
   err wraps multiple errors, AsType examines err followed by a
   depth-first traversal of its children.

   An error err matches the type E if the type assertion err.(E) holds,
   or if the error has a method As(any) bool such that err.As(target)
   returns true when target is a non-nil *E. In the latter case, the As
   method is responsible for setting target.

   go: wrap.go:167:6 *)
Definition AsTypeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} (E : go.type) : val :=
  λ: "err",
    exception_do (let: "err" := (GoAlloc go.error "err") in
    (if: Convert go.untyped_bool go.bool ((![go.error] "err") =⟨go.error⟩ (Convert go.untyped_nil go.error UntypedNil))
    then
      let: "zero" := (GoAlloc E (GoZeroVal E #())) in
      return: (![E] "zero", #false)
    else do:  #());;;
    let: "pe" := (GoAlloc (go.PointerType E) (GoZeroVal (go.PointerType E) #())) in
    let: ("$ret0", "$ret1") := ((let: "$a0" := (![go.error] "err") in
    let: "$a1" := "pe" in
    (FuncResolve asType [E] #()) "$a0" "$a1")) in
    return: ("$ret0", "$ret1")).

(* go: wrap.go:176:6 *)
Definition asTypeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} (E : go.type) : val :=
  λ: "err" "ppe",
    exception_do (let: <> := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: <> := (GoAlloc E (GoZeroVal E #())) in
    let: "ppe" := (GoAlloc (go.PointerType (go.PointerType E)) "ppe") in
    let: "err" := (GoAlloc go.error "err") in
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
      let: "e" := (GoAlloc E (GoZeroVal E #())) in
      let: ("$ret0", "$ret1") := (TypeAssert2 E (![go.error] "err")) in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("e" <-[E] "$r0");;;
      do:  ("ok" <-[go.bool] "$r1");;;
      (if: ![go.bool] "ok"
      then return: (![E] "e", #true)
      else do:  #()));;;
      (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
      let: "x" := (GoAlloc (go.InterfaceType [go.MethodElem "As"%go (go.Signature [go.any] false [go.bool])]) (GoZeroVal (go.InterfaceType [go.MethodElem "As"%go (go.Signature [go.any] false [go.bool])]) #())) in
      let: ("$ret0", "$ret1") := (TypeAssert2 (go.InterfaceType [go.MethodElem "As"%go (go.Signature [go.any] false [go.bool])]) (![go.error] "err")) in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("x" <-[go.InterfaceType [go.MethodElem "As"%go (go.Signature [go.any] false [go.bool])]] "$r0");;;
      do:  ("ok" <-[go.bool] "$r1");;;
      (if: ![go.bool] "ok"
      then
        (if: Convert go.untyped_bool go.bool ((![go.PointerType E] (![go.PointerType (go.PointerType E)] "ppe")) =⟨go.PointerType E⟩ (Convert go.untyped_nil (go.PointerType E) UntypedNil))
        then
          let: "$r0" := (GoAlloc E (GoZeroVal E #())) in
          do:  ((![go.PointerType (go.PointerType E)] "ppe") <-[go.PointerType E] "$r0")
        else do:  #());;;
        (if: let: "$a0" := (Convert (go.PointerType E) go.any (![go.PointerType E] (![go.PointerType (go.PointerType E)] "ppe"))) in
        (MethodResolve (go.InterfaceType [go.MethodElem "As"%go (go.Signature [go.any] false [go.bool])]) "As"%go (![go.InterfaceType [go.MethodElem "As"%go (go.Signature [go.any] false [go.bool])]] "x")) "$a0"
        then return: (![E] (![go.PointerType E] (![go.PointerType (go.PointerType E)] "ppe")), #true)
        else do:  #())
      else do:  #()));;;
      let: "$y" := (![go.error] "err") in
      let: ("$x", "$ok") := (TypeAssert2 (go.InterfaceType [go.MethodElem "Unwrap"%go (go.Signature [] false [go.error])]) "$y") in
      (if: "$ok"
      then
        let: "x" := (GoAlloc (go.InterfaceType [go.MethodElem "Unwrap"%go (go.Signature [] false [go.error])]) "$x") in
        let: "$r0" := ((MethodResolve (go.InterfaceType [go.MethodElem "Unwrap"%go (go.Signature [] false [go.error])]) "Unwrap"%go (![go.InterfaceType [go.MethodElem "Unwrap"%go (go.Signature [] false [go.error])]] "x")) #()) in
        do:  ("err" <-[go.error] "$r0");;;
        (if: Convert go.untyped_bool go.bool ((![go.error] "err") =⟨go.error⟩ (Convert go.untyped_nil go.error UntypedNil))
        then return: (![E] "_", ![go.bool] "_")
        else do:  #())
      else
        let: ("$x", "$ok") := (TypeAssert2 (go.InterfaceType [go.MethodElem "Unwrap"%go (go.Signature [] false [go.SliceType go.error])]) "$y") in
        (if: "$ok"
        then
          let: "x" := (GoAlloc (go.InterfaceType [go.MethodElem "Unwrap"%go (go.Signature [] false [go.SliceType go.error])]) "$x") in
          let: "$range" := ((MethodResolve (go.InterfaceType [go.MethodElem "Unwrap"%go (go.Signature [] false [go.SliceType go.error])]) "Unwrap"%go (![go.InterfaceType [go.MethodElem "Unwrap"%go (go.Signature [] false [go.SliceType go.error])]] "x")) #()) in
          (let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
          slice.for_range go.error "$range" (λ: "$key" "$value",
            do:  ("err" <-[go.error] "$value");;;
            do:  "$key";;;
            (if: Convert go.untyped_bool go.bool ((![go.error] "err") =⟨go.error⟩ (Convert go.untyped_nil go.error UntypedNil))
            then continue: #()
            else do:  #());;;
            (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
            let: "x" := (GoAlloc E (GoZeroVal E #())) in
            let: ("$ret0", "$ret1") := (let: "$a0" := (![go.error] "err") in
            let: "$a1" := (![go.PointerType (go.PointerType E)] "ppe") in
            (FuncResolve asType [E] #()) "$a0" "$a1") in
            let: "$r0" := "$ret0" in
            let: "$r1" := "$ret1" in
            do:  ("x" <-[E] "$r0");;;
            do:  ("ok" <-[go.bool] "$r1");;;
            (if: ![go.bool] "ok"
            then return: (![E] "x", #true)
            else do:  #()))));;;
          return: (![E] "_", ![go.bool] "_")
        else return: (![E] "_", ![go.bool] "_"))))).

#[global] Instance info' : PkgInfo pkg_id.errors :=
{|
  pkg_imported_pkgs := []
|}.

Axiom _'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init pkg_id.errors (λ: <>,
      exception_do (do:  (ErrUnsupported'init #());;;
      do:  (errorType'init #()))
      ).

Module errorString.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  s' : go_string;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End errorString.

Definition errorString'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "s"%go go.string)
].
Program Definition errorString'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (errorString'fds_unsealed).
Global Instance equals_unfold_errorString {ext : ffi_syntax} {go_gctx : GoGlobalContext} : errorString'fds =→ errorString'fds_unsealed.
Proof. rewrite /errorString'fds seal_eq //. Qed.

Definition errorStringⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (errorString'fds).

Class errorString_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] errorString_type_repr  :: go.TypeReprUnderlying errorStringⁱᵐᵖˡ errorString.t;
  #[global] errorString_underlying :: (errorString) <u (errorStringⁱᵐᵖˡ);
  #[global] errorString_get_s (x : errorString.t) :: ⟦StructFieldGet (errorStringⁱᵐᵖˡ) "s", #x⟧ ⤳[under] #x.(errorString.s');
  #[global] errorString_set_s (x : errorString.t) y :: ⟦StructFieldSet (errorStringⁱᵐᵖˡ) "s", (#x, #y)⟧ ⤳[under] #(x <|errorString.s' := y|>);
  #[global] errorString'ptr_Error_unfold :: MethodUnfold (go.PointerType (errorString)) "Error" (errorString__Errorⁱᵐᵖˡ);
}.

Module joinError.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End joinError.

Class joinError_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] joinError_type_repr  :: go.TypeReprUnderlying joinErrorⁱᵐᵖˡ joinError.t;
  #[global] joinError_underlying :: (joinError) <u (joinErrorⁱᵐᵖˡ);
  #[global] joinErrorⁱᵐᵖˡ_underlying :: (joinErrorⁱᵐᵖˡ) ↓u (joinErrorⁱᵐᵖˡ);
}.

Class Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] errorString_instance :: errorString_Assumptions;
  #[global] joinError_instance :: joinError_Assumptions;
  #[global] New_unfold :: FuncUnfold New [] (Newⁱᵐᵖˡ);
  #[global] Unwrap_unfold :: FuncUnfold Unwrap [] (Unwrapⁱᵐᵖˡ);
  #[global] AsType_unfold E :: FuncUnfold AsType [E] (AsTypeⁱᵐᵖˡ E);
  #[global] asType_unfold E :: FuncUnfold asType [E] (asTypeⁱᵐᵖˡ E);
}.
End errors.
