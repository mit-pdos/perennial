(* autogenerated from context *)
Require Export New.code.errors.
Require Export New.code.sync.
Require Export New.code.sync.atomic.
Require Export New.code.time.
From New.golang Require Import defn.
Module pkg_id.
Definition context : go_string := "context".

End pkg_id.
Export pkg_id.
Module context.

Definition Context {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "context.Context"%go [].

Definition deadlineExceededError {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "context.deadlineExceededError"%go [].

Definition emptyCtx {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "context.emptyCtx"%go [].

Definition backgroundCtx {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "context.backgroundCtx"%go [].

Definition todoCtx {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "context.todoCtx"%go [].

Definition CancelFunc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "context.CancelFunc"%go [].

Definition CancelCauseFunc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "context.CancelCauseFunc"%go [].

Definition afterFuncer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "context.afterFuncer"%go [].

Definition afterFuncCtx {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "context.afterFuncCtx"%go [].

Definition stopCtx {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "context.stopCtx"%go [].

Definition canceler {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "context.canceler"%go [].

Definition cancelCtx {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "context.cancelCtx"%go [].

Definition stringer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "context.stringer"%go [].

Definition withoutCancelCtx {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "context.withoutCancelCtx"%go [].

Definition timerCtx {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "context.timerCtx"%go [].

Definition valueCtx {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "context.valueCtx"%go [].

Definition Canceled {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "context.Canceled"%go.

Definition DeadlineExceeded {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "context.DeadlineExceeded"%go.

Definition goroutines {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "context.goroutines"%go.

Definition cancelCtxKey {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "context.cancelCtxKey"%go.

Definition closedchan {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "context.closedchan"%go.

Definition Background {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "context.Background"%go.

Definition TODO {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "context.TODO"%go.

Definition WithCancel {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "context.WithCancel"%go.

Definition WithCancelCause {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "context.WithCancelCause"%go.

Definition withCancel {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "context.withCancel"%go.

Definition Cause {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "context.Cause"%go.

Definition AfterFunc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "context.AfterFunc"%go.

Definition parentCancelCtx {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "context.parentCancelCtx"%go.

Definition removeChild {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "context.removeChild"%go.

Definition contextName {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "context.contextName"%go.

Definition WithoutCancel {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "context.WithoutCancel"%go.

Definition WithDeadline {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "context.WithDeadline"%go.

Definition WithDeadlineCause {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "context.WithDeadlineCause"%go.

Definition WithTimeout {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "context.WithTimeout"%go.

Definition WithTimeoutCause {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "context.WithTimeoutCause"%go.

Definition WithValue {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "context.WithValue"%go.

Definition stringify {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "context.stringify"%go.

Definition value {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "context.value"%go.

(* go: context.go:175:30 *)
Definition deadlineExceededError__Errorⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <> <>,
    exception_do (return: (#"context deadline exceeded"%go)).

(* go: context.go:176:30 *)
Definition deadlineExceededError__Timeoutⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <> <>,
    exception_do (return: (#true)).

(* go: context.go:177:30 *)
Definition deadlineExceededError__Temporaryⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <> <>,
    exception_do (return: (#true)).

(* go: context.go:183:17 *)
Definition emptyCtx__Deadlineⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <> <>,
    exception_do (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "deadline" := (GoAlloc time.Time (GoZeroVal time.Time #())) in
    return: (![time.Time] "deadline", ![go.bool] "ok")).

(* go: context.go:187:17 *)
Definition emptyCtx__Doneⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <> <>,
    exception_do (return: (Convert go.untyped_nil (go.ChannelType go.recvonly (go.StructType [

     ])) UntypedNil)).

(* go: context.go:191:17 *)
Definition emptyCtx__Errⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <> <>,
    exception_do (return: (Convert go.untyped_nil go.error UntypedNil)).

(* go: context.go:195:17 *)
Definition emptyCtx__Valueⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <> "key",
    exception_do (let: "key" := (GoAlloc go.any "key") in
    return: (Convert go.untyped_nil go.any UntypedNil)).

(* go: context.go:201:22 *)
Definition backgroundCtx__Stringⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <> <>,
    exception_do (return: (#"context.Background"%go)).

(* go: context.go:207:16 *)
Definition todoCtx__Stringⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <> <>,
    exception_do (return: (#"context.TODO"%go)).

(* Background returns a non-nil, empty [Context]. It is never canceled, has no
   values, and has no deadline. It is typically used by the main function,
   initialization, and tests, and as the top-level Context for incoming
   requests.

   go: context.go:215:6 *)
Definition Backgroundⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (Convert backgroundCtx Context (CompositeLiteral backgroundCtx (LiteralValue [])))).

(* TODO returns a non-nil, empty [Context]. Code should use context.TODO when
   it's unclear which Context to use or it is not yet available (because the
   surrounding function has not yet been extended to accept a Context
   parameter).

   go: context.go:223:6 *)
Definition TODOⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (Convert todoCtx Context (CompositeLiteral todoCtx (LiteralValue [])))).

(* WithCancel returns a derived context that points to the parent context
   but has a new Done channel. The returned context's Done channel is closed
   when the returned cancel function is called or when the parent context's
   Done channel is closed, whichever happens first.

   Canceling this context releases resources associated with it, so code should
   call cancel as soon as the operations running in this [Context] complete.

   go: context.go:240:6 *)
Definition WithCancelⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "parent",
    exception_do (let: "cancel" := (GoAlloc CancelFunc (GoZeroVal CancelFunc #())) in
    let: "ctx" := (GoAlloc Context (GoZeroVal Context #())) in
    let: "parent" := (GoAlloc Context "parent") in
    let: "c" := (GoAlloc (go.PointerType cancelCtx) (GoZeroVal (go.PointerType cancelCtx) #())) in
    let: "$r0" := (let: "$a0" := (![Context] "parent") in
    (FuncResolve withCancel [] #()) "$a0") in
    do:  ("c" <-[go.PointerType cancelCtx] "$r0");;;
    return: (Convert (go.PointerType cancelCtx) Context (![go.PointerType cancelCtx] "c"), (λ: <>,
       exception_do (do:  (let: "$a0" := #true in
       let: "$a1" := (![go.error] (GlobalVarAddr Canceled #())) in
       let: "$a2" := (Convert go.untyped_nil go.error UntypedNil) in
       (MethodResolve (go.PointerType cancelCtx) "cancel"%go (![go.PointerType cancelCtx] "c")) "$a0" "$a1" "$a2");;;
       return: #())
       ))).

(* WithCancelCause behaves like [WithCancel] but returns a [CancelCauseFunc] instead of a [CancelFunc].
   Calling cancel with a non-nil error (the "cause") records that error in ctx;
   it can then be retrieved using Cause(ctx).
   Calling cancel with nil sets the cause to Canceled.

   Example use:

   	ctx, cancel := context.WithCancelCause(parent)
   	cancel(myError)
   	ctx.Err() // returns context.Canceled
   	context.Cause(ctx) // returns myError

   go: context.go:268:6 *)
Definition WithCancelCauseⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "parent",
    exception_do (let: "cancel" := (GoAlloc CancelCauseFunc (GoZeroVal CancelCauseFunc #())) in
    let: "ctx" := (GoAlloc Context (GoZeroVal Context #())) in
    let: "parent" := (GoAlloc Context "parent") in
    let: "c" := (GoAlloc (go.PointerType cancelCtx) (GoZeroVal (go.PointerType cancelCtx) #())) in
    let: "$r0" := (let: "$a0" := (![Context] "parent") in
    (FuncResolve withCancel [] #()) "$a0") in
    do:  ("c" <-[go.PointerType cancelCtx] "$r0");;;
    return: (Convert (go.PointerType cancelCtx) Context (![go.PointerType cancelCtx] "c"), (λ: "cause",
       exception_do (let: "cause" := (GoAlloc go.error "cause") in
       do:  (let: "$a0" := #true in
       let: "$a1" := (![go.error] (GlobalVarAddr Canceled #())) in
       let: "$a2" := (![go.error] "cause") in
       (MethodResolve (go.PointerType cancelCtx) "cancel"%go (![go.PointerType cancelCtx] "c")) "$a0" "$a1" "$a2");;;
       return: #())
       ))).

(* go: context.go:273:6 *)
Definition withCancelⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "parent",
    exception_do (let: "parent" := (GoAlloc Context "parent") in
    (if: Convert go.untyped_bool go.bool ((![Context] "parent") =⟨Context⟩ (Convert go.untyped_nil Context UntypedNil))
    then
      do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"cannot create context from nil parent"%go) in
      (FuncResolve go.panic [] #()) "$a0")
    else do:  #());;;
    let: "c" := (GoAlloc (go.PointerType cancelCtx) (GoZeroVal (go.PointerType cancelCtx) #())) in
    let: "$r0" := (GoAlloc cancelCtx (CompositeLiteral cancelCtx (LiteralValue []))) in
    do:  ("c" <-[go.PointerType cancelCtx] "$r0");;;
    do:  (let: "$a0" := (![Context] "parent") in
    let: "$a1" := (Convert (go.PointerType cancelCtx) canceler (![go.PointerType cancelCtx] "c")) in
    (MethodResolve (go.PointerType cancelCtx) "propagateCancel"%go (![go.PointerType cancelCtx] "c")) "$a0" "$a1");;;
    return: (![go.PointerType cancelCtx] "c")).

(* Cause returns a non-nil error explaining why c was canceled.
   The first cancellation of c or one of its parents sets the cause.
   If that cancellation happened via a call to CancelCauseFunc(err),
   then [Cause] returns err.
   Otherwise Cause(c) returns the same value as c.Err().
   Cause returns nil if c has not been canceled yet.

   go: context.go:288:6 *)
Definition Causeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "c",
    exception_do (let: "c" := (GoAlloc Context "c") in
    (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "cc" := (GoAlloc (go.PointerType cancelCtx) (GoZeroVal (go.PointerType cancelCtx) #())) in
    let: ("$ret0", "$ret1") := (TypeAssert2 (go.PointerType cancelCtx) (let: "$a0" := (Convert (go.PointerType go.int) go.any (GlobalVarAddr cancelCtxKey #())) in
    (MethodResolve Context "Value"%go (![Context] "c")) "$a0")) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("cc" <-[go.PointerType cancelCtx] "$r0");;;
    do:  ("ok" <-[go.bool] "$r1");;;
    (if: ![go.bool] "ok"
    then
      do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (StructFieldRef cancelCtx "mu"%go (![go.PointerType cancelCtx] "cc"))) #());;;
      let: "cause" := (GoAlloc go.error (GoZeroVal go.error #())) in
      let: "$r0" := (![go.error] (StructFieldRef cancelCtx "cause"%go (![go.PointerType cancelCtx] "cc"))) in
      do:  ("cause" <-[go.error] "$r0");;;
      do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (StructFieldRef cancelCtx "mu"%go (![go.PointerType cancelCtx] "cc"))) #());;;
      (if: Convert go.untyped_bool go.bool ((![go.error] "cause") ≠⟨go.error⟩ (Convert go.untyped_nil go.error UntypedNil))
      then return: (![go.error] "cause")
      else do:  #())
    else do:  #()));;;
    return: ((MethodResolve Context "Err"%go (![Context] "c")) #())).

(* AfterFunc arranges to call f in its own goroutine after ctx is canceled.
   If ctx is already canceled, AfterFunc calls f immediately in its own goroutine.

   Multiple calls to AfterFunc on a context operate independently;
   one does not replace another.

   Calling the returned stop function stops the association of ctx with f.
   It returns true if the call stopped f from being run.
   If stop returns false,
   either the context is canceled and f has been started in its own goroutine;
   or f was already stopped.
   The stop function does not wait for f to complete before returning.
   If the caller needs to know whether f is completed,
   it must coordinate with f explicitly.

   If ctx has a "AfterFunc(func()) func() bool" method,
   AfterFunc will use it to schedule the call.

   go: context.go:325:6 *)
Definition AfterFuncⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "ctx" "f",
    exception_do (let: "stop" := (GoAlloc (go.FunctionType (go.Signature [] false [go.bool])) (GoZeroVal (go.FunctionType (go.Signature [] false [go.bool])) #())) in
    let: "f" := (GoAlloc (go.FunctionType (go.Signature [] false [])) "f") in
    let: "ctx" := (GoAlloc Context "ctx") in
    let: "a" := (GoAlloc (go.PointerType afterFuncCtx) (GoZeroVal (go.PointerType afterFuncCtx) #())) in
    let: "$r0" := (GoAlloc afterFuncCtx (let: "$v0" := (![go.FunctionType (go.Signature [] false [])] "f") in
    CompositeLiteral afterFuncCtx (LiteralValue [KeyedElement (Some (KeyField "f"%go)) (ElementExpression (go.FunctionType (go.Signature [] false [])) "$v0")]))) in
    do:  ("a" <-[go.PointerType afterFuncCtx] "$r0");;;
    do:  (let: "$a0" := (![Context] "ctx") in
    let: "$a1" := (Convert (go.PointerType afterFuncCtx) canceler (![go.PointerType afterFuncCtx] "a")) in
    (MethodResolve (go.PointerType cancelCtx) "propagateCancel"%go (StructFieldRef afterFuncCtx "cancelCtx"%go (![go.PointerType afterFuncCtx] "a"))) "$a0" "$a1");;;
    return: ((λ: <>,
       exception_do (let: "stopped" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
       let: "$r0" := #false in
       do:  ("stopped" <-[go.bool] "$r0");;;
       do:  (let: "$a0" := (λ: <>,
         exception_do (let: "$r0" := #true in
         do:  ("stopped" <-[go.bool] "$r0");;;
         return: #())
         ) in
       (MethodResolve (go.PointerType sync.Once) "Do"%go (StructFieldRef afterFuncCtx "once"%go (![go.PointerType afterFuncCtx] "a"))) "$a0");;;
       (if: ![go.bool] "stopped"
       then
         do:  (let: "$a0" := #true in
         let: "$a1" := (![go.error] (GlobalVarAddr Canceled #())) in
         let: "$a2" := (Convert go.untyped_nil go.error UntypedNil) in
         (MethodResolve (go.PointerType afterFuncCtx) "cancel"%go (![go.PointerType afterFuncCtx] "a")) "$a0" "$a1" "$a2")
       else do:  #());;;
       return: (![go.bool] "stopped"))
       ))).

(* go: context.go:352:24 *)
Definition afterFuncCtx__cancelⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "a" "removeFromParent" "err" "cause",
    exception_do (let: "a" := (GoAlloc (go.PointerType afterFuncCtx) "a") in
    let: "cause" := (GoAlloc go.error "cause") in
    let: "err" := (GoAlloc go.error "err") in
    let: "removeFromParent" := (GoAlloc go.bool "removeFromParent") in
    do:  (let: "$a0" := #false in
    let: "$a1" := (![go.error] "err") in
    let: "$a2" := (![go.error] "cause") in
    (MethodResolve (go.PointerType cancelCtx) "cancel"%go (StructFieldRef afterFuncCtx "cancelCtx"%go (![go.PointerType afterFuncCtx] "a"))) "$a0" "$a1" "$a2");;;
    (if: ![go.bool] "removeFromParent"
    then
      do:  (let: "$a0" := (![Context] (StructFieldRef cancelCtx "Context"%go (StructFieldRef afterFuncCtx "cancelCtx"%go (![go.PointerType afterFuncCtx] "a")))) in
      let: "$a1" := (Convert (go.PointerType afterFuncCtx) canceler (![go.PointerType afterFuncCtx] "a")) in
      (FuncResolve removeChild [] #()) "$a0" "$a1")
    else do:  #());;;
    do:  (let: "$a0" := (λ: <>,
      exception_do (let: "$go" := (![go.FunctionType (go.Signature [] false [])] (StructFieldRef afterFuncCtx "f"%go (![go.PointerType afterFuncCtx] "a"))) in
      do:  (Fork ("$go" #()));;;
      return: #())
      ) in
    (MethodResolve (go.PointerType sync.Once) "Do"%go (StructFieldRef afterFuncCtx "once"%go (![go.PointerType afterFuncCtx] "a"))) "$a0");;;
    return: #()).

(* parentCancelCtx returns the underlying *cancelCtx for parent.
   It does this by looking up parent.Value(&cancelCtxKey) to find
   the innermost enclosing *cancelCtx and then checking whether
   parent.Done() matches that *cancelCtx. (If not, the *cancelCtx
   has been wrapped in a custom implementation providing a
   different done channel, in which case we should not bypass it.)

   go: context.go:382:6 *)
Definition parentCancelCtxⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "parent",
    exception_do (let: "parent" := (GoAlloc Context "parent") in
    let: "done" := (GoAlloc (go.ChannelType go.recvonly (go.StructType [

    ])) (GoZeroVal (go.ChannelType go.recvonly (go.StructType [

    ])) #())) in
    let: "$r0" := ((MethodResolve Context "Done"%go (![Context] "parent")) #()) in
    do:  ("done" <-[go.ChannelType go.recvonly (go.StructType [

    ])] "$r0");;;
    (if: Convert go.untyped_bool go.bool (((![go.ChannelType go.recvonly (go.StructType [

    ])] "done") =⟨go.ChannelType go.recvonly (go.StructType [

    ])⟩ (Convert (go.ChannelType go.sendrecv (go.StructType [

    ])) (go.ChannelType go.recvonly (go.StructType [

    ])) (![go.ChannelType go.sendrecv (go.StructType [

    ])] (GlobalVarAddr closedchan #())))) || ((![go.ChannelType go.recvonly (go.StructType [

    ])] "done") =⟨go.ChannelType go.recvonly (go.StructType [

    ])⟩ (Convert go.untyped_nil (go.ChannelType go.recvonly (go.StructType [

    ])) UntypedNil)))
    then return: (Convert go.untyped_nil (go.PointerType cancelCtx) UntypedNil, #false)
    else do:  #());;;
    let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "p" := (GoAlloc (go.PointerType cancelCtx) (GoZeroVal (go.PointerType cancelCtx) #())) in
    let: ("$ret0", "$ret1") := (TypeAssert2 (go.PointerType cancelCtx) (let: "$a0" := (Convert (go.PointerType go.int) go.any (GlobalVarAddr cancelCtxKey #())) in
    (MethodResolve Context "Value"%go (![Context] "parent")) "$a0")) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("p" <-[go.PointerType cancelCtx] "$r0");;;
    do:  ("ok" <-[go.bool] "$r1");;;
    (if: (⟨go.bool⟩! (![go.bool] "ok"))
    then return: (Convert go.untyped_nil (go.PointerType cancelCtx) UntypedNil, #false)
    else do:  #());;;
    let: "pdone" := (GoAlloc (go.ChannelType go.sendrecv (go.StructType [

    ])) (GoZeroVal (go.ChannelType go.sendrecv (go.StructType [

    ])) #())) in
    let: ("$ret0", "$ret1") := (TypeAssert2 (go.ChannelType go.sendrecv (go.StructType [

    ])) ((MethodResolve (go.PointerType atomic.Value) "Load"%go (StructFieldRef cancelCtx "done"%go (![go.PointerType cancelCtx] "p"))) #())) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("pdone" <-[go.ChannelType go.sendrecv (go.StructType [

    ])] "$r0");;;
    do:  "$r1";;;
    (if: Convert go.untyped_bool go.bool ((Convert (go.ChannelType go.sendrecv (go.StructType [

    ])) (go.ChannelType go.recvonly (go.StructType [

    ])) (![go.ChannelType go.sendrecv (go.StructType [

    ])] "pdone")) ≠⟨go.ChannelType go.recvonly (go.StructType [

    ])⟩ (![go.ChannelType go.recvonly (go.StructType [

    ])] "done"))
    then return: (Convert go.untyped_nil (go.PointerType cancelCtx) UntypedNil, #false)
    else do:  #());;;
    return: (![go.PointerType cancelCtx] "p", #true)).

(* removeChild removes a context from its parent.

   go: context.go:399:6 *)
Definition removeChildⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "parent" "child",
    exception_do (let: "child" := (GoAlloc canceler "child") in
    let: "parent" := (GoAlloc Context "parent") in
    (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "s" := (GoAlloc stopCtx (GoZeroVal stopCtx #())) in
    let: ("$ret0", "$ret1") := (TypeAssert2 stopCtx (![Context] "parent")) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("s" <-[stopCtx] "$r0");;;
    do:  ("ok" <-[go.bool] "$r1");;;
    (if: ![go.bool] "ok"
    then
      do:  ((![go.FunctionType (go.Signature [] false [go.bool])] (StructFieldRef stopCtx "stop"%go "s")) #());;;
      return: (#())
    else do:  #()));;;
    let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "p" := (GoAlloc (go.PointerType cancelCtx) (GoZeroVal (go.PointerType cancelCtx) #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![Context] "parent") in
    (FuncResolve parentCancelCtx [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("p" <-[go.PointerType cancelCtx] "$r0");;;
    do:  ("ok" <-[go.bool] "$r1");;;
    (if: (⟨go.bool⟩! (![go.bool] "ok"))
    then return: (#())
    else do:  #());;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (StructFieldRef cancelCtx "mu"%go (![go.PointerType cancelCtx] "p"))) #());;;
    (if: Convert go.untyped_bool go.bool ((![go.MapType canceler (go.StructType [

    ])] (StructFieldRef cancelCtx "children"%go (![go.PointerType cancelCtx] "p"))) ≠⟨go.MapType canceler (go.StructType [

    ])⟩ (Convert go.untyped_nil (go.MapType canceler (go.StructType [

    ])) UntypedNil))
    then
      do:  (let: "$a0" := (![go.MapType canceler (go.StructType [

      ])] (StructFieldRef cancelCtx "children"%go (![go.PointerType cancelCtx] "p"))) in
      let: "$a1" := (![canceler] "child") in
      (FuncResolve go.delete [go.MapType canceler (go.StructType [

       ])] #()) "$a0" "$a1")
    else do:  #());;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (StructFieldRef cancelCtx "mu"%go (![go.PointerType cancelCtx] "p"))) #());;;
    return: #()).

(* go: context.go:441:21 *)
Definition cancelCtx__Valueⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "c" "key",
    exception_do (let: "c" := (GoAlloc (go.PointerType cancelCtx) "c") in
    let: "key" := (GoAlloc go.any "key") in
    (if: Convert go.untyped_bool go.bool ((![go.any] "key") =⟨go.any⟩ (Convert (go.PointerType go.int) go.any (GlobalVarAddr cancelCtxKey #())))
    then return: (Convert (go.PointerType cancelCtx) go.any (![go.PointerType cancelCtx] "c"))
    else do:  #());;;
    return: (let: "$a0" := (![Context] (StructFieldRef cancelCtx "Context"%go (![go.PointerType cancelCtx] "c"))) in
     let: "$a1" := (![go.any] "key") in
     (FuncResolve value [] #()) "$a0" "$a1")).

(* go: context.go:448:21 *)
Definition cancelCtx__Doneⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "c" <>,
    with_defer: (let: "c" := (GoAlloc (go.PointerType cancelCtx) "c") in
    let: "d" := (GoAlloc go.any (GoZeroVal go.any #())) in
    let: "$r0" := ((MethodResolve (go.PointerType atomic.Value) "Load"%go (StructFieldRef cancelCtx "done"%go (![go.PointerType cancelCtx] "c"))) #()) in
    do:  ("d" <-[go.any] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.any] "d") ≠⟨go.any⟩ (Convert go.untyped_nil go.any UntypedNil))
    then
      return: (Convert (go.ChannelType go.sendrecv (go.StructType [

       ])) (go.ChannelType go.recvonly (go.StructType [

       ])) (TypeAssert (go.ChannelType go.sendrecv (go.StructType [

       ])) (![go.any] "d")))
    else do:  #());;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (StructFieldRef cancelCtx "mu"%go (![go.PointerType cancelCtx] "c"))) #());;;
    do:  (let: "$f" := (MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (StructFieldRef cancelCtx "mu"%go (![go.PointerType cancelCtx] "c"))) in
    "$defer" <-[deferType] (let: "$oldf" := (![deferType] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    let: "$r0" := ((MethodResolve (go.PointerType atomic.Value) "Load"%go (StructFieldRef cancelCtx "done"%go (![go.PointerType cancelCtx] "c"))) #()) in
    do:  ("d" <-[go.any] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.any] "d") =⟨go.any⟩ (Convert go.untyped_nil go.any UntypedNil))
    then
      let: "$r0" := (Convert (go.ChannelType go.sendrecv (go.StructType [

      ])) go.any ((FuncResolve go.make1 [go.ChannelType go.sendrecv (go.StructType [

       ])] #()) #())) in
      do:  ("d" <-[go.any] "$r0");;;
      do:  (let: "$a0" := (![go.any] "d") in
      (MethodResolve (go.PointerType atomic.Value) "Store"%go (StructFieldRef cancelCtx "done"%go (![go.PointerType cancelCtx] "c"))) "$a0")
    else do:  #());;;
    return: (Convert (go.ChannelType go.sendrecv (go.StructType [

     ])) (go.ChannelType go.recvonly (go.StructType [

     ])) (TypeAssert (go.ChannelType go.sendrecv (go.StructType [

     ])) (![go.any] "d")))).

(* go: context.go:463:21 *)
Definition cancelCtx__Errⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "c" <>,
    exception_do (let: "c" := (GoAlloc (go.PointerType cancelCtx) "c") in
    (let: "err" := (GoAlloc go.any (GoZeroVal go.any #())) in
    let: "$r0" := ((MethodResolve (go.PointerType atomic.Value) "Load"%go (StructFieldRef cancelCtx "err"%go (![go.PointerType cancelCtx] "c"))) #()) in
    do:  ("err" <-[go.any] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.any] "err") ≠⟨go.any⟩ (Convert go.untyped_nil go.any UntypedNil))
    then
      do:  (Fst (chan.receive (go.StructType [

      ]) ((MethodResolve (go.PointerType cancelCtx) "Done"%go (![go.PointerType cancelCtx] "c")) #())));;;
      return: (TypeAssert go.error (![go.any] "err"))
    else do:  #()));;;
    return: (Convert go.untyped_nil go.error UntypedNil)).

(* propagateCancel arranges for child to be canceled when parent is.
   It sets the parent context of cancelCtx.

   go: context.go:475:21 *)
Definition cancelCtx__propagateCancelⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "c" "parent" "child",
    exception_do (let: "c" := (GoAlloc (go.PointerType cancelCtx) "c") in
    let: "child" := (GoAlloc canceler "child") in
    let: "parent" := (GoAlloc Context "parent") in
    let: "$r0" := (![Context] "parent") in
    do:  ((StructFieldRef cancelCtx "Context"%go (![go.PointerType cancelCtx] "c")) <-[Context] "$r0");;;
    let: "done" := (GoAlloc (go.ChannelType go.recvonly (go.StructType [

    ])) (GoZeroVal (go.ChannelType go.recvonly (go.StructType [

    ])) #())) in
    let: "$r0" := ((MethodResolve Context "Done"%go (![Context] "parent")) #()) in
    do:  ("done" <-[go.ChannelType go.recvonly (go.StructType [

    ])] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.ChannelType go.recvonly (go.StructType [

    ])] "done") =⟨go.ChannelType go.recvonly (go.StructType [

    ])⟩ (Convert go.untyped_nil (go.ChannelType go.recvonly (go.StructType [

    ])) UntypedNil))
    then return: (#())
    else do:  #());;;
    let: "$ch0" := (![go.ChannelType go.recvonly (go.StructType [

    ])] "done") in
    SelectStmt (SelectStmtClauses (Some (do:  #())) [(CommClause (RecvCase (go.StructType [

    ]) "$ch0") (do:  (let: "$a0" := #false in
    let: "$a1" := ((MethodResolve Context "Err"%go (![Context] "parent")) #()) in
    let: "$a2" := (let: "$a0" := (![Context] "parent") in
    (FuncResolve Cause [] #()) "$a0") in
    (MethodResolve canceler "cancel"%go (![canceler] "child")) "$a0" "$a1" "$a2");;;
    return: (#())))]);;;
    (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "p" := (GoAlloc (go.PointerType cancelCtx) (GoZeroVal (go.PointerType cancelCtx) #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![Context] "parent") in
    (FuncResolve parentCancelCtx [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("p" <-[go.PointerType cancelCtx] "$r0");;;
    do:  ("ok" <-[go.bool] "$r1");;;
    (if: ![go.bool] "ok"
    then
      do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (StructFieldRef cancelCtx "mu"%go (![go.PointerType cancelCtx] "p"))) #());;;
      (let: "err" := (GoAlloc go.any (GoZeroVal go.any #())) in
      let: "$r0" := ((MethodResolve (go.PointerType atomic.Value) "Load"%go (StructFieldRef cancelCtx "err"%go (![go.PointerType cancelCtx] "p"))) #()) in
      do:  ("err" <-[go.any] "$r0");;;
      (if: Convert go.untyped_bool go.bool ((![go.any] "err") ≠⟨go.any⟩ (Convert go.untyped_nil go.any UntypedNil))
      then
        do:  (let: "$a0" := #false in
        let: "$a1" := (TypeAssert go.error (![go.any] "err")) in
        let: "$a2" := (![go.error] (StructFieldRef cancelCtx "cause"%go (![go.PointerType cancelCtx] "p"))) in
        (MethodResolve canceler "cancel"%go (![canceler] "child")) "$a0" "$a1" "$a2")
      else
        (if: Convert go.untyped_bool go.bool ((![go.MapType canceler (go.StructType [

        ])] (StructFieldRef cancelCtx "children"%go (![go.PointerType cancelCtx] "p"))) =⟨go.MapType canceler (go.StructType [

        ])⟩ (Convert go.untyped_nil (go.MapType canceler (go.StructType [

        ])) UntypedNil))
        then
          let: "$r0" := ((FuncResolve go.make1 [go.MapType canceler (go.StructType [

           ])] #()) #()) in
          do:  ((StructFieldRef cancelCtx "children"%go (![go.PointerType cancelCtx] "p")) <-[go.MapType canceler (go.StructType [

          ])] "$r0")
        else do:  #());;;
        let: "$r0" := (CompositeLiteral (go.StructType [

        ]) (LiteralValue [])) in
        do:  (map.insert canceler (![go.MapType canceler (go.StructType [

        ])] (StructFieldRef cancelCtx "children"%go (![go.PointerType cancelCtx] "p"))) (![canceler] "child") "$r0")));;;
      do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (StructFieldRef cancelCtx "mu"%go (![go.PointerType cancelCtx] "p"))) #());;;
      return: (#())
    else do:  #()));;;
    (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "a" := (GoAlloc afterFuncer (GoZeroVal afterFuncer #())) in
    let: ("$ret0", "$ret1") := (TypeAssert2 afterFuncer (![Context] "parent")) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("a" <-[afterFuncer] "$r0");;;
    do:  ("ok" <-[go.bool] "$r1");;;
    (if: ![go.bool] "ok"
    then
      do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (StructFieldRef cancelCtx "mu"%go (![go.PointerType cancelCtx] "c"))) #());;;
      let: "stop" := (GoAlloc (go.FunctionType (go.Signature [] false [go.bool])) (GoZeroVal (go.FunctionType (go.Signature [] false [go.bool])) #())) in
      let: "$r0" := (let: "$a0" := (λ: <>,
        exception_do (do:  (let: "$a0" := #false in
        let: "$a1" := ((MethodResolve Context "Err"%go (![Context] "parent")) #()) in
        let: "$a2" := (let: "$a0" := (![Context] "parent") in
        (FuncResolve Cause [] #()) "$a0") in
        (MethodResolve canceler "cancel"%go (![canceler] "child")) "$a0" "$a1" "$a2");;;
        return: #())
        ) in
      (MethodResolve afterFuncer "AfterFunc"%go (![afterFuncer] "a")) "$a0") in
      do:  ("stop" <-[go.FunctionType (go.Signature [] false [go.bool])] "$r0");;;
      let: "$r0" := (Convert stopCtx Context (let: "$v0" := (![Context] "parent") in
      let: "$v1" := (![go.FunctionType (go.Signature [] false [go.bool])] "stop") in
      CompositeLiteral stopCtx (LiteralValue [KeyedElement (Some (KeyField "Context"%go)) (ElementExpression Context "$v0"); KeyedElement (Some (KeyField "stop"%go)) (ElementExpression (go.FunctionType (go.Signature [] false [go.bool])) "$v1")]))) in
      do:  ((StructFieldRef cancelCtx "Context"%go (![go.PointerType cancelCtx] "c")) <-[Context] "$r0");;;
      do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (StructFieldRef cancelCtx "mu"%go (![go.PointerType cancelCtx] "c"))) #());;;
      return: (#())
    else do:  #()));;;
    do:  (let: "$a0" := #(W32 1) in
    (MethodResolve (go.PointerType atomic.Int32) "Add"%go (GlobalVarAddr goroutines #())) "$a0");;;
    let: "$go" := (λ: <>,
      exception_do (let: "$ch0" := ((MethodResolve Context "Done"%go (![Context] "parent")) #()) in
      let: "$ch1" := ((MethodResolve canceler "Done"%go (![canceler] "child")) #()) in
      SelectStmt (SelectStmtClauses None [(CommClause (RecvCase (go.StructType [

      ]) "$ch0") (do:  (let: "$a0" := #false in
      let: "$a1" := ((MethodResolve Context "Err"%go (![Context] "parent")) #()) in
      let: "$a2" := (let: "$a0" := (![Context] "parent") in
      (FuncResolve Cause [] #()) "$a0") in
      (MethodResolve canceler "cancel"%go (![canceler] "child")) "$a0" "$a1" "$a2"))); (CommClause (RecvCase (go.StructType [

      ]) "$ch1") (do:  #()))]);;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    return: #()).

(* go: context.go:542:21 *)
Definition cancelCtx__Stringⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "c" <>,
    exception_do (let: "c" := (GoAlloc (go.PointerType cancelCtx) "c") in
    return: ((let: "$a0" := (![Context] (StructFieldRef cancelCtx "Context"%go (![go.PointerType cancelCtx] "c"))) in
     (FuncResolve contextName [] #()) "$a0") +⟨go.string⟩ #".WithCancel"%go)).

(* cancel closes c.done, cancels each of c's children, and, if
   removeFromParent is true, removes c from its parent's children.
   cancel sets c.cause to cause if this is the first time c is canceled.

   go: context.go:549:21 *)
Definition cancelCtx__cancelⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "c" "removeFromParent" "err" "cause",
    exception_do (let: "c" := (GoAlloc (go.PointerType cancelCtx) "c") in
    let: "cause" := (GoAlloc go.error "cause") in
    let: "err" := (GoAlloc go.error "err") in
    let: "removeFromParent" := (GoAlloc go.bool "removeFromParent") in
    (if: Convert go.untyped_bool go.bool ((![go.error] "err") =⟨go.error⟩ (Convert go.untyped_nil go.error UntypedNil))
    then
      do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"context: internal error: missing cancel error"%go) in
      (FuncResolve go.panic [] #()) "$a0")
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool ((![go.error] "cause") =⟨go.error⟩ (Convert go.untyped_nil go.error UntypedNil))
    then
      let: "$r0" := (![go.error] "err") in
      do:  ("cause" <-[go.error] "$r0")
    else do:  #());;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (StructFieldRef cancelCtx "mu"%go (![go.PointerType cancelCtx] "c"))) #());;;
    (if: Convert go.untyped_bool go.bool (((MethodResolve (go.PointerType atomic.Value) "Load"%go (StructFieldRef cancelCtx "err"%go (![go.PointerType cancelCtx] "c"))) #()) ≠⟨go.any⟩ (Convert go.untyped_nil go.any UntypedNil))
    then
      do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (StructFieldRef cancelCtx "mu"%go (![go.PointerType cancelCtx] "c"))) #());;;
      return: (#())
    else do:  #());;;
    do:  (let: "$a0" := (Convert go.error go.any (![go.error] "err")) in
    (MethodResolve (go.PointerType atomic.Value) "Store"%go (StructFieldRef cancelCtx "err"%go (![go.PointerType cancelCtx] "c"))) "$a0");;;
    let: "$r0" := (![go.error] "cause") in
    do:  ((StructFieldRef cancelCtx "cause"%go (![go.PointerType cancelCtx] "c")) <-[go.error] "$r0");;;
    let: "d" := (GoAlloc (go.ChannelType go.sendrecv (go.StructType [

    ])) (GoZeroVal (go.ChannelType go.sendrecv (go.StructType [

    ])) #())) in
    let: ("$ret0", "$ret1") := (TypeAssert2 (go.ChannelType go.sendrecv (go.StructType [

    ])) ((MethodResolve (go.PointerType atomic.Value) "Load"%go (StructFieldRef cancelCtx "done"%go (![go.PointerType cancelCtx] "c"))) #())) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("d" <-[go.ChannelType go.sendrecv (go.StructType [

    ])] "$r0");;;
    do:  "$r1";;;
    (if: Convert go.untyped_bool go.bool ((![go.ChannelType go.sendrecv (go.StructType [

    ])] "d") =⟨go.ChannelType go.sendrecv (go.StructType [

    ])⟩ (Convert go.untyped_nil (go.ChannelType go.sendrecv (go.StructType [

    ])) UntypedNil))
    then
      do:  (let: "$a0" := (Convert (go.ChannelType go.sendrecv (go.StructType [

      ])) go.any (![go.ChannelType go.sendrecv (go.StructType [

      ])] (GlobalVarAddr closedchan #()))) in
      (MethodResolve (go.PointerType atomic.Value) "Store"%go (StructFieldRef cancelCtx "done"%go (![go.PointerType cancelCtx] "c"))) "$a0")
    else
      do:  (let: "$a0" := (![go.ChannelType go.sendrecv (go.StructType [

      ])] "d") in
      (FuncResolve go.close [go.ChannelType go.sendrecv (go.StructType [

       ])] #()) "$a0"));;;
    let: "$range" := (![go.MapType canceler (go.StructType [

    ])] (StructFieldRef cancelCtx "children"%go (![go.PointerType cancelCtx] "c"))) in
    (let: "child" := (GoAlloc canceler (GoZeroVal canceler #())) in
    map.for_range canceler (go.StructType [

    ]) "$range" (λ: "$key" "value",
      do:  ("child" <-[canceler] "$key");;;
      do:  (let: "$a0" := #false in
      let: "$a1" := (![go.error] "err") in
      let: "$a2" := (![go.error] "cause") in
      (MethodResolve canceler "cancel"%go (![canceler] "child")) "$a0" "$a1" "$a2")));;;
    let: "$r0" := (Convert go.untyped_nil (go.MapType canceler (go.StructType [

    ])) UntypedNil) in
    do:  ((StructFieldRef cancelCtx "children"%go (![go.PointerType cancelCtx] "c")) <-[go.MapType canceler (go.StructType [

    ])] "$r0");;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (StructFieldRef cancelCtx "mu"%go (![go.PointerType cancelCtx] "c"))) #());;;
    (if: ![go.bool] "removeFromParent"
    then
      do:  (let: "$a0" := (![Context] (StructFieldRef cancelCtx "Context"%go (![go.PointerType cancelCtx] "c"))) in
      let: "$a1" := (Convert (go.PointerType cancelCtx) canceler (![go.PointerType cancelCtx] "c")) in
      (FuncResolve removeChild [] #()) "$a0" "$a1")
    else do:  #());;;
    return: #()).

(* WithoutCancel returns a derived context that points to the parent context
   and is not canceled when parent is canceled.
   The returned context returns no Deadline or Err, and its Done channel is nil.
   Calling [Cause] on the returned context returns nil.

   go: context.go:585:6 *)
Definition WithoutCancelⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "parent",
    exception_do (let: "parent" := (GoAlloc Context "parent") in
    (if: Convert go.untyped_bool go.bool ((![Context] "parent") =⟨Context⟩ (Convert go.untyped_nil Context UntypedNil))
    then
      do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"cannot create context from nil parent"%go) in
      (FuncResolve go.panic [] #()) "$a0")
    else do:  #());;;
    return: (Convert withoutCancelCtx Context (let: "$v0" := (![Context] "parent") in
     CompositeLiteral withoutCancelCtx (LiteralValue [KeyedElement None (ElementExpression Context "$v0")])))).

(* go: context.go:596:25 *)
Definition withoutCancelCtx__Deadlineⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <> <>,
    exception_do (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "deadline" := (GoAlloc time.Time (GoZeroVal time.Time #())) in
    return: (![time.Time] "deadline", ![go.bool] "ok")).

(* go: context.go:600:25 *)
Definition withoutCancelCtx__Doneⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <> <>,
    exception_do (return: (Convert go.untyped_nil (go.ChannelType go.recvonly (go.StructType [

     ])) UntypedNil)).

(* go: context.go:604:25 *)
Definition withoutCancelCtx__Errⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <> <>,
    exception_do (return: (Convert go.untyped_nil go.error UntypedNil)).

(* go: context.go:608:27 *)
Definition withoutCancelCtx__Valueⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "c" "key",
    exception_do (let: "c" := (GoAlloc withoutCancelCtx "c") in
    let: "key" := (GoAlloc go.any "key") in
    return: (let: "$a0" := (Convert withoutCancelCtx Context (![withoutCancelCtx] "c")) in
     let: "$a1" := (![go.any] "key") in
     (FuncResolve value [] #()) "$a0" "$a1")).

(* go: context.go:612:27 *)
Definition withoutCancelCtx__Stringⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "c" <>,
    exception_do (let: "c" := (GoAlloc withoutCancelCtx "c") in
    return: ((let: "$a0" := (![Context] (StructFieldRef withoutCancelCtx "c"%go "c")) in
     (FuncResolve contextName [] #()) "$a0") +⟨go.string⟩ #".WithoutCancel"%go)).

(* WithDeadline returns a derived context that points to the parent context
   but has the deadline adjusted to be no later than d. If the parent's
   deadline is already earlier than d, WithDeadline(parent, d) is semantically
   equivalent to parent. The returned [Context.Done] channel is closed when
   the deadline expires, when the returned cancel function is called,
   or when the parent context's Done channel is closed, whichever happens first.

   Canceling this context releases resources associated with it, so code should
   call cancel as soon as the operations running in this [Context] complete.

   go: context.go:625:6 *)
Definition WithDeadlineⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "parent" "d",
    exception_do (let: "d" := (GoAlloc time.Time "d") in
    let: "parent" := (GoAlloc Context "parent") in
    let: ("$ret0", "$ret1") := ((let: "$a0" := (![Context] "parent") in
    let: "$a1" := (![time.Time] "d") in
    let: "$a2" := (Convert go.untyped_nil go.error UntypedNil) in
    (FuncResolve WithDeadlineCause [] #()) "$a0" "$a1" "$a2")) in
    return: ("$ret0", "$ret1")).

(* WithDeadlineCause behaves like [WithDeadline] but also sets the cause of the
   returned Context when the deadline is exceeded. The returned [CancelFunc] does
   not set the cause.

   go: context.go:632:6 *)
Definition WithDeadlineCauseⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "parent" "d" "cause",
    with_defer: (let: "cause" := (GoAlloc go.error "cause") in
    let: "d" := (GoAlloc time.Time "d") in
    let: "parent" := (GoAlloc Context "parent") in
    (if: Convert go.untyped_bool go.bool ((![Context] "parent") =⟨Context⟩ (Convert go.untyped_nil Context UntypedNil))
    then
      do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"cannot create context from nil parent"%go) in
      (FuncResolve go.panic [] #()) "$a0")
    else do:  #());;;
    (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "cur" := (GoAlloc time.Time (GoZeroVal time.Time #())) in
    let: ("$ret0", "$ret1") := ((MethodResolve Context "Deadline"%go (![Context] "parent")) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("cur" <-[time.Time] "$r0");;;
    do:  ("ok" <-[go.bool] "$r1");;;
    (if: (![go.bool] "ok") && (let: "$a0" := (![time.Time] "d") in
    (MethodResolve (go.PointerType time.Time) "Before"%go "cur") "$a0")
    then
      let: ("$ret0", "$ret1") := ((let: "$a0" := (![Context] "parent") in
      (FuncResolve WithCancel [] #()) "$a0")) in
      return: ("$ret0", "$ret1")
    else do:  #()));;;
    let: "c" := (GoAlloc (go.PointerType timerCtx) (GoZeroVal (go.PointerType timerCtx) #())) in
    let: "$r0" := (GoAlloc timerCtx (let: "$v0" := (![time.Time] "d") in
    CompositeLiteral timerCtx (LiteralValue [KeyedElement (Some (KeyField "deadline"%go)) (ElementExpression time.Time "$v0")]))) in
    do:  ("c" <-[go.PointerType timerCtx] "$r0");;;
    do:  (let: "$a0" := (![Context] "parent") in
    let: "$a1" := (Convert (go.PointerType timerCtx) canceler (![go.PointerType timerCtx] "c")) in
    (MethodResolve (go.PointerType cancelCtx) "propagateCancel"%go (StructFieldRef timerCtx "cancelCtx"%go (![go.PointerType timerCtx] "c"))) "$a0" "$a1");;;
    let: "dur" := (GoAlloc time.Duration (GoZeroVal time.Duration #())) in
    let: "$r0" := (let: "$a0" := (![time.Time] "d") in
    (FuncResolve time.Until [] #()) "$a0") in
    do:  ("dur" <-[time.Duration] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![time.Duration] "dur") ≤⟨time.Duration⟩ #(W64 0))
    then
      do:  (let: "$a0" := #true in
      let: "$a1" := (![go.error] (GlobalVarAddr DeadlineExceeded #())) in
      let: "$a2" := (![go.error] "cause") in
      (MethodResolve (go.PointerType timerCtx) "cancel"%go (![go.PointerType timerCtx] "c")) "$a0" "$a1" "$a2");;;
      return: (Convert (go.PointerType timerCtx) Context (![go.PointerType timerCtx] "c"), (λ: <>,
         exception_do (do:  (let: "$a0" := #false in
         let: "$a1" := (![go.error] (GlobalVarAddr Canceled #())) in
         let: "$a2" := (Convert go.untyped_nil go.error UntypedNil) in
         (MethodResolve (go.PointerType timerCtx) "cancel"%go (![go.PointerType timerCtx] "c")) "$a0" "$a1" "$a2");;;
         return: #())
         ))
    else do:  #());;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (StructFieldRef cancelCtx "mu"%go (StructFieldRef timerCtx "cancelCtx"%go (![go.PointerType timerCtx] "c")))) #());;;
    do:  (let: "$f" := (MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (StructFieldRef cancelCtx "mu"%go (StructFieldRef timerCtx "cancelCtx"%go (![go.PointerType timerCtx] "c")))) in
    "$defer" <-[deferType] (let: "$oldf" := (![deferType] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    (if: Convert go.untyped_bool go.bool (((MethodResolve (go.PointerType atomic.Value) "Load"%go (StructFieldRef cancelCtx "err"%go (StructFieldRef timerCtx "cancelCtx"%go (![go.PointerType timerCtx] "c")))) #()) =⟨go.any⟩ (Convert go.untyped_nil go.any UntypedNil))
    then
      let: "$r0" := (let: "$a0" := (![time.Duration] "dur") in
      let: "$a1" := (λ: <>,
        exception_do (do:  (let: "$a0" := #true in
        let: "$a1" := (![go.error] (GlobalVarAddr DeadlineExceeded #())) in
        let: "$a2" := (![go.error] "cause") in
        (MethodResolve (go.PointerType timerCtx) "cancel"%go (![go.PointerType timerCtx] "c")) "$a0" "$a1" "$a2");;;
        return: #())
        ) in
      (FuncResolve time.AfterFunc [] #()) "$a0" "$a1") in
      do:  ((StructFieldRef timerCtx "timer"%go (![go.PointerType timerCtx] "c")) <-[go.PointerType time.Timer] "$r0")
    else do:  #());;;
    return: (Convert (go.PointerType timerCtx) Context (![go.PointerType timerCtx] "c"), (λ: <>,
       exception_do (do:  (let: "$a0" := #true in
       let: "$a1" := (![go.error] (GlobalVarAddr Canceled #())) in
       let: "$a2" := (Convert go.untyped_nil go.error UntypedNil) in
       (MethodResolve (go.PointerType timerCtx) "cancel"%go (![go.PointerType timerCtx] "c")) "$a0" "$a1" "$a2");;;
       return: #())
       ))).

(* go: context.go:669:20 *)
Definition timerCtx__Deadlineⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "c" <>,
    exception_do (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "deadline" := (GoAlloc time.Time (GoZeroVal time.Time #())) in
    let: "c" := (GoAlloc (go.PointerType timerCtx) "c") in
    return: (![time.Time] (StructFieldRef timerCtx "deadline"%go (![go.PointerType timerCtx] "c")), #true)).

(* go: context.go:673:20 *)
Definition timerCtx__Stringⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "c" <>,
    exception_do (let: "c" := (GoAlloc (go.PointerType timerCtx) "c") in
    return: ((((((let: "$a0" := (![Context] (StructFieldRef cancelCtx "Context"%go (StructFieldRef timerCtx "cancelCtx"%go (![go.PointerType timerCtx] "c")))) in
     (FuncResolve contextName [] #()) "$a0") +⟨go.string⟩ #".WithDeadline("%go) +⟨go.string⟩ ((MethodResolve (go.PointerType time.Time) "String"%go (StructFieldRef timerCtx "deadline"%go (![go.PointerType timerCtx] "c"))) #())) +⟨go.string⟩ #" ["%go) +⟨go.string⟩ ((MethodResolve time.Duration "String"%go (let: "$a0" := (![time.Time] (StructFieldRef timerCtx "deadline"%go (![go.PointerType timerCtx] "c"))) in
     (FuncResolve time.Until [] #()) "$a0")) #())) +⟨go.string⟩ #"])"%go)).

(* go: context.go:679:20 *)
Definition timerCtx__cancelⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "c" "removeFromParent" "err" "cause",
    exception_do (let: "c" := (GoAlloc (go.PointerType timerCtx) "c") in
    let: "cause" := (GoAlloc go.error "cause") in
    let: "err" := (GoAlloc go.error "err") in
    let: "removeFromParent" := (GoAlloc go.bool "removeFromParent") in
    do:  (let: "$a0" := #false in
    let: "$a1" := (![go.error] "err") in
    let: "$a2" := (![go.error] "cause") in
    (MethodResolve (go.PointerType cancelCtx) "cancel"%go (StructFieldRef timerCtx "cancelCtx"%go (![go.PointerType timerCtx] "c"))) "$a0" "$a1" "$a2");;;
    (if: ![go.bool] "removeFromParent"
    then
      do:  (let: "$a0" := (![Context] (StructFieldRef cancelCtx "Context"%go (StructFieldRef timerCtx "cancelCtx"%go (![go.PointerType timerCtx] "c")))) in
      let: "$a1" := (Convert (go.PointerType timerCtx) canceler (![go.PointerType timerCtx] "c")) in
      (FuncResolve removeChild [] #()) "$a0" "$a1")
    else do:  #());;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (StructFieldRef cancelCtx "mu"%go (StructFieldRef timerCtx "cancelCtx"%go (![go.PointerType timerCtx] "c")))) #());;;
    (if: Convert go.untyped_bool go.bool ((![go.PointerType time.Timer] (StructFieldRef timerCtx "timer"%go (![go.PointerType timerCtx] "c"))) ≠⟨go.PointerType time.Timer⟩ (Convert go.untyped_nil (go.PointerType time.Timer) UntypedNil))
    then
      do:  ((MethodResolve (go.PointerType time.Timer) "Stop"%go (![go.PointerType time.Timer] (StructFieldRef timerCtx "timer"%go (![go.PointerType timerCtx] "c")))) #());;;
      let: "$r0" := (Convert go.untyped_nil (go.PointerType time.Timer) UntypedNil) in
      do:  ((StructFieldRef timerCtx "timer"%go (![go.PointerType timerCtx] "c")) <-[go.PointerType time.Timer] "$r0")
    else do:  #());;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (StructFieldRef cancelCtx "mu"%go (StructFieldRef timerCtx "cancelCtx"%go (![go.PointerType timerCtx] "c")))) #());;;
    return: #()).

(* WithTimeout returns WithDeadline(parent, time.Now().Add(timeout)).

   Canceling this context releases resources associated with it, so code should
   call cancel as soon as the operations running in this [Context] complete:

   	func slowOperationWithTimeout(ctx context.Context) (Result, error) {
   		ctx, cancel := context.WithTimeout(ctx, 100*time.Millisecond)
   		defer cancel()  // releases resources if slowOperation completes before timeout elapses
   		return slowOperation(ctx)
   	}

   go: context.go:703:6 *)
Definition WithTimeoutⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "parent" "timeout",
    exception_do (let: "timeout" := (GoAlloc time.Duration "timeout") in
    let: "parent" := (GoAlloc Context "parent") in
    let: ("$ret0", "$ret1") := ((let: "$a0" := (![Context] "parent") in
    let: "$a1" := (let: "$a0" := (![time.Duration] "timeout") in
    (MethodResolve time.Time "Add"%go ((FuncResolve time.Now [] #()) #())) "$a0") in
    (FuncResolve WithDeadline [] #()) "$a0" "$a1")) in
    return: ("$ret0", "$ret1")).

(* WithTimeoutCause behaves like [WithTimeout] but also sets the cause of the
   returned Context when the timeout expires. The returned [CancelFunc] does
   not set the cause.

   go: context.go:710:6 *)
Definition WithTimeoutCauseⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "parent" "timeout" "cause",
    exception_do (let: "cause" := (GoAlloc go.error "cause") in
    let: "timeout" := (GoAlloc time.Duration "timeout") in
    let: "parent" := (GoAlloc Context "parent") in
    let: ("$ret0", "$ret1") := ((let: "$a0" := (![Context] "parent") in
    let: "$a1" := (let: "$a0" := (![time.Duration] "timeout") in
    (MethodResolve time.Time "Add"%go ((FuncResolve time.Now [] #()) #())) "$a0") in
    let: "$a2" := (![go.error] "cause") in
    (FuncResolve WithDeadlineCause [] #()) "$a0" "$a1" "$a2")) in
    return: ("$ret0", "$ret1")).

(* go: context.go:762:20 *)
Definition valueCtx__Stringⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "c" <>,
    exception_do (let: "c" := (GoAlloc (go.PointerType valueCtx) "c") in
    return: ((((((let: "$a0" := (![Context] (StructFieldRef valueCtx "Context"%go (![go.PointerType valueCtx] "c"))) in
     (FuncResolve contextName [] #()) "$a0") +⟨go.string⟩ #".WithValue("%go) +⟨go.string⟩ (let: "$a0" := (![go.any] (StructFieldRef valueCtx "key"%go (![go.PointerType valueCtx] "c"))) in
     (FuncResolve stringify [] #()) "$a0")) +⟨go.string⟩ #", "%go) +⟨go.string⟩ (let: "$a0" := (![go.any] (StructFieldRef valueCtx "val"%go (![go.PointerType valueCtx] "c"))) in
     (FuncResolve stringify [] #()) "$a0")) +⟨go.string⟩ #")"%go)).

(* go: context.go:768:20 *)
Definition valueCtx__Valueⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "c" "key",
    exception_do (let: "c" := (GoAlloc (go.PointerType valueCtx) "c") in
    let: "key" := (GoAlloc go.any "key") in
    (if: Convert go.untyped_bool go.bool ((![go.any] (StructFieldRef valueCtx "key"%go (![go.PointerType valueCtx] "c"))) =⟨go.any⟩ (![go.any] "key"))
    then return: (![go.any] (StructFieldRef valueCtx "val"%go (![go.PointerType valueCtx] "c")))
    else do:  #());;;
    return: (let: "$a0" := (![Context] (StructFieldRef valueCtx "Context"%go (![go.PointerType valueCtx] "c"))) in
     let: "$a1" := (![go.any] "key") in
     (FuncResolve value [] #()) "$a0" "$a1")).

(* go: context.go:775:6 *)
Definition valueⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "c" "key",
    exception_do (let: "key" := (GoAlloc go.any "key") in
    let: "c" := (GoAlloc Context "c") in
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "$y" := (![Context] "c") in
      let: ("$x", "$ok") := (TypeAssert2 (go.PointerType valueCtx) "$y") in
      (if: "$ok"
      then
        let: "ctx" := (GoAlloc (go.PointerType valueCtx) "$x") in
        (if: Convert go.untyped_bool go.bool ((![go.any] "key") =⟨go.any⟩ (![go.any] (StructFieldRef valueCtx "key"%go (![go.PointerType valueCtx] "ctx"))))
        then return: (![go.any] (StructFieldRef valueCtx "val"%go (![go.PointerType valueCtx] "ctx")))
        else do:  #());;;
        let: "$r0" := (![Context] (StructFieldRef valueCtx "Context"%go (![go.PointerType valueCtx] "ctx"))) in
        do:  ("c" <-[Context] "$r0")
      else
        let: ("$x", "$ok") := (TypeAssert2 (go.PointerType cancelCtx) "$y") in
        (if: "$ok"
        then
          let: "ctx" := (GoAlloc (go.PointerType cancelCtx) "$x") in
          (if: Convert go.untyped_bool go.bool ((![go.any] "key") =⟨go.any⟩ (Convert (go.PointerType go.int) go.any (GlobalVarAddr cancelCtxKey #())))
          then return: (Convert Context go.any (![Context] "c"))
          else do:  #());;;
          let: "$r0" := (![Context] (StructFieldRef cancelCtx "Context"%go (![go.PointerType cancelCtx] "ctx"))) in
          do:  ("c" <-[Context] "$r0")
        else
          let: ("$x", "$ok") := (TypeAssert2 withoutCancelCtx "$y") in
          (if: "$ok"
          then
            let: "ctx" := (GoAlloc withoutCancelCtx "$x") in
            (if: Convert go.untyped_bool go.bool ((![go.any] "key") =⟨go.any⟩ (Convert (go.PointerType go.int) go.any (GlobalVarAddr cancelCtxKey #())))
            then return: (Convert go.untyped_nil go.any UntypedNil)
            else do:  #());;;
            let: "$r0" := (![Context] (StructFieldRef withoutCancelCtx "c"%go "ctx")) in
            do:  ("c" <-[Context] "$r0")
          else
            let: ("$x", "$ok") := (TypeAssert2 (go.PointerType timerCtx) "$y") in
            (if: "$ok"
            then
              let: "ctx" := (GoAlloc (go.PointerType timerCtx) "$x") in
              (if: Convert go.untyped_bool go.bool ((![go.any] "key") =⟨go.any⟩ (Convert (go.PointerType go.int) go.any (GlobalVarAddr cancelCtxKey #())))
              then return: (Convert (go.PointerType cancelCtx) go.any (StructFieldRef timerCtx "cancelCtx"%go (![go.PointerType timerCtx] "ctx")))
              else do:  #());;;
              let: "$r0" := (![Context] (StructFieldRef cancelCtx "Context"%go (StructFieldRef timerCtx "cancelCtx"%go (![go.PointerType timerCtx] "ctx")))) in
              do:  ("c" <-[Context] "$r0")
            else
              let: "$ok" := ((Snd (TypeAssert2 backgroundCtx "$y")) || (Snd (TypeAssert2 backgroundCtx "$y"))) in
              let: "$x" := "$y" in
              (if: "$ok"
              then
                let: "ctx" := (GoAlloc Context "$x") in
                return: (Convert go.untyped_nil go.any UntypedNil)
              else
                return: (let: "$a0" := (![go.any] "key") in
                 (MethodResolve Context "Value"%go (![Context] "c")) "$a0")))))))).

#[global] Instance info' : PkgInfo pkg_id.context :=
{|
  pkg_imported_pkgs := [code.errors.pkg_id.errors; code.sync.pkg_id.sync; code.sync.atomic.pkg_id.atomic; code.time.pkg_id.time]
|}.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init pkg_id.context (λ: <>,
      exception_do (do:  (go.GlobalAlloc closedchan (go.ChannelType go.sendrecv (go.StructType [

      ])) #());;;
      do:  (go.GlobalAlloc cancelCtxKey go.int #());;;
      do:  (go.GlobalAlloc goroutines atomic.Int32 #());;;
      do:  (go.GlobalAlloc DeadlineExceeded go.error #());;;
      do:  (go.GlobalAlloc Canceled go.error #());;;
      do:  (time.initialize' #());;;
      do:  (atomic.initialize' #());;;
      do:  (sync.initialize' #());;;
      do:  (errors.initialize' #());;;
      let: "$r0" := (let: "$a0" := #"context canceled"%go in
      (FuncResolve errors.New [] #()) "$a0") in
      do:  ((GlobalVarAddr Canceled #()) <-[go.error] "$r0");;;
      let: "$r0" := (Convert deadlineExceededError go.error (CompositeLiteral deadlineExceededError (LiteralValue []))) in
      do:  ((GlobalVarAddr DeadlineExceeded #()) <-[go.error] "$r0");;;
      let: "$r0" := ((FuncResolve go.make1 [go.ChannelType go.sendrecv (go.StructType [

       ])] #()) #()) in
      do:  ((GlobalVarAddr closedchan #()) <-[go.ChannelType go.sendrecv (go.StructType [

      ])] "$r0");;;
      do:  ((λ: <>,
        exception_do (do:  (let: "$a0" := (![go.ChannelType go.sendrecv (go.StructType [

        ])] (GlobalVarAddr closedchan #())) in
        (FuncResolve go.close [go.ChannelType go.sendrecv (go.StructType [

         ])] #()) "$a0");;;
        return: #())
        ) #()))
      ).

Module Context.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := interface.t.
End def.
End Context.

Definition Contextⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.InterfaceType [go.MethodElem "Deadline"%go (go.Signature [] false [time.Time; go.bool]); go.MethodElem "Done"%go (go.Signature [] false [go.ChannelType go.recvonly (go.StructType [

  ])]); go.MethodElem "Err"%go (go.Signature [] false [go.error]); go.MethodElem "Value"%go (go.Signature [go.any] false [go.any])].

Class Context_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Context_underlying :: (Context) <u (Contextⁱᵐᵖˡ);
}.

Module deadlineExceededError.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End deadlineExceededError.

Definition deadlineExceededError'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [

].
Program Definition deadlineExceededError'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (deadlineExceededError'fds_unsealed).
Global Instance equals_unfold_deadlineExceededError {ext : ffi_syntax} {go_gctx : GoGlobalContext} : deadlineExceededError'fds =→ deadlineExceededError'fds_unsealed.
Proof. rewrite /deadlineExceededError'fds seal_eq //. Qed.

Definition deadlineExceededErrorⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (deadlineExceededError'fds).

Class deadlineExceededError_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] deadlineExceededError_type_repr  :: go.TypeReprUnderlying deadlineExceededErrorⁱᵐᵖˡ deadlineExceededError.t;
  #[global] deadlineExceededError_underlying :: (deadlineExceededError) <u (deadlineExceededErrorⁱᵐᵖˡ);
  #[global] deadlineExceededError_Error_unfold :: MethodUnfold (deadlineExceededError) "Error" (deadlineExceededError__Errorⁱᵐᵖˡ);
  #[global] deadlineExceededError_Temporary_unfold :: MethodUnfold (deadlineExceededError) "Temporary" (deadlineExceededError__Temporaryⁱᵐᵖˡ);
  #[global] deadlineExceededError_Timeout_unfold :: MethodUnfold (deadlineExceededError) "Timeout" (deadlineExceededError__Timeoutⁱᵐᵖˡ);
  #[global] deadlineExceededError'ptr_Error_unfold :: MethodUnfold (go.PointerType (deadlineExceededError)) "Error" (λ: "$r", MethodResolve (deadlineExceededError) "Error" (![(deadlineExceededError)] "$r"));
  #[global] deadlineExceededError'ptr_Temporary_unfold :: MethodUnfold (go.PointerType (deadlineExceededError)) "Temporary" (λ: "$r", MethodResolve (deadlineExceededError) "Temporary" (![(deadlineExceededError)] "$r"));
  #[global] deadlineExceededError'ptr_Timeout_unfold :: MethodUnfold (go.PointerType (deadlineExceededError)) "Timeout" (λ: "$r", MethodResolve (deadlineExceededError) "Timeout" (![(deadlineExceededError)] "$r"));
}.

Module emptyCtx.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End emptyCtx.

Definition emptyCtx'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [

].
Program Definition emptyCtx'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (emptyCtx'fds_unsealed).
Global Instance equals_unfold_emptyCtx {ext : ffi_syntax} {go_gctx : GoGlobalContext} : emptyCtx'fds =→ emptyCtx'fds_unsealed.
Proof. rewrite /emptyCtx'fds seal_eq //. Qed.

Definition emptyCtxⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (emptyCtx'fds).

Class emptyCtx_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] emptyCtx_type_repr  :: go.TypeReprUnderlying emptyCtxⁱᵐᵖˡ emptyCtx.t;
  #[global] emptyCtx_underlying :: (emptyCtx) <u (emptyCtxⁱᵐᵖˡ);
  #[global] emptyCtx_Deadline_unfold :: MethodUnfold (emptyCtx) "Deadline" (emptyCtx__Deadlineⁱᵐᵖˡ);
  #[global] emptyCtx_Done_unfold :: MethodUnfold (emptyCtx) "Done" (emptyCtx__Doneⁱᵐᵖˡ);
  #[global] emptyCtx_Err_unfold :: MethodUnfold (emptyCtx) "Err" (emptyCtx__Errⁱᵐᵖˡ);
  #[global] emptyCtx_Value_unfold :: MethodUnfold (emptyCtx) "Value" (emptyCtx__Valueⁱᵐᵖˡ);
  #[global] emptyCtx'ptr_Deadline_unfold :: MethodUnfold (go.PointerType (emptyCtx)) "Deadline" (λ: "$r", MethodResolve (emptyCtx) "Deadline" (![(emptyCtx)] "$r"));
  #[global] emptyCtx'ptr_Done_unfold :: MethodUnfold (go.PointerType (emptyCtx)) "Done" (λ: "$r", MethodResolve (emptyCtx) "Done" (![(emptyCtx)] "$r"));
  #[global] emptyCtx'ptr_Err_unfold :: MethodUnfold (go.PointerType (emptyCtx)) "Err" (λ: "$r", MethodResolve (emptyCtx) "Err" (![(emptyCtx)] "$r"));
  #[global] emptyCtx'ptr_Value_unfold :: MethodUnfold (go.PointerType (emptyCtx)) "Value" (λ: "$r", MethodResolve (emptyCtx) "Value" (![(emptyCtx)] "$r"));
}.

Module backgroundCtx.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  emptyCtx' : context.emptyCtx.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End backgroundCtx.

Definition backgroundCtx'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.EmbeddedField "emptyCtx"%go emptyCtx)
].
Program Definition backgroundCtx'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (backgroundCtx'fds_unsealed).
Global Instance equals_unfold_backgroundCtx {ext : ffi_syntax} {go_gctx : GoGlobalContext} : backgroundCtx'fds =→ backgroundCtx'fds_unsealed.
Proof. rewrite /backgroundCtx'fds seal_eq //. Qed.

Definition backgroundCtxⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (backgroundCtx'fds).

Class backgroundCtx_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] backgroundCtx_type_repr  :: go.TypeReprUnderlying backgroundCtxⁱᵐᵖˡ backgroundCtx.t;
  #[global] backgroundCtx_underlying :: (backgroundCtx) <u (backgroundCtxⁱᵐᵖˡ);
  #[global] backgroundCtx_get_emptyCtx (x : backgroundCtx.t) :: ⟦StructFieldGet (backgroundCtxⁱᵐᵖˡ) "emptyCtx", #x⟧ ⤳[under] #x.(backgroundCtx.emptyCtx');
  #[global] backgroundCtx_set_emptyCtx (x : backgroundCtx.t) y :: ⟦StructFieldSet (backgroundCtxⁱᵐᵖˡ) "emptyCtx", (#x, #y)⟧ ⤳[under] #(x <|backgroundCtx.emptyCtx' := y|>);
  #[global] backgroundCtx_Deadline_unfold :: MethodUnfold (backgroundCtx) "Deadline" (λ: "$r", MethodResolve emptyCtx "Deadline" (StructFieldGet (backgroundCtx) "emptyCtx" "$r" ))%V;
  #[global] backgroundCtx_Done_unfold :: MethodUnfold (backgroundCtx) "Done" (λ: "$r", MethodResolve emptyCtx "Done" (StructFieldGet (backgroundCtx) "emptyCtx" "$r" ))%V;
  #[global] backgroundCtx_Err_unfold :: MethodUnfold (backgroundCtx) "Err" (λ: "$r", MethodResolve emptyCtx "Err" (StructFieldGet (backgroundCtx) "emptyCtx" "$r" ))%V;
  #[global] backgroundCtx_String_unfold :: MethodUnfold (backgroundCtx) "String" (backgroundCtx__Stringⁱᵐᵖˡ);
  #[global] backgroundCtx_Value_unfold :: MethodUnfold (backgroundCtx) "Value" (λ: "$r", MethodResolve emptyCtx "Value" (StructFieldGet (backgroundCtx) "emptyCtx" "$r" ))%V;
  #[global] backgroundCtx'ptr_Deadline_unfold :: MethodUnfold (go.PointerType (backgroundCtx)) "Deadline" (λ: "$r", MethodResolve (go.PointerType emptyCtx) "Deadline" (StructFieldRef backgroundCtx "emptyCtx"%go "$r"));
  #[global] backgroundCtx'ptr_Done_unfold :: MethodUnfold (go.PointerType (backgroundCtx)) "Done" (λ: "$r", MethodResolve (go.PointerType emptyCtx) "Done" (StructFieldRef backgroundCtx "emptyCtx"%go "$r"));
  #[global] backgroundCtx'ptr_Err_unfold :: MethodUnfold (go.PointerType (backgroundCtx)) "Err" (λ: "$r", MethodResolve (go.PointerType emptyCtx) "Err" (StructFieldRef backgroundCtx "emptyCtx"%go "$r"));
  #[global] backgroundCtx'ptr_String_unfold :: MethodUnfold (go.PointerType (backgroundCtx)) "String" (λ: "$r", MethodResolve (backgroundCtx) "String" (![(backgroundCtx)] "$r"));
  #[global] backgroundCtx'ptr_Value_unfold :: MethodUnfold (go.PointerType (backgroundCtx)) "Value" (λ: "$r", MethodResolve (go.PointerType emptyCtx) "Value" (StructFieldRef backgroundCtx "emptyCtx"%go "$r"));
}.

Module todoCtx.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  emptyCtx' : context.emptyCtx.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End todoCtx.

Definition todoCtx'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.EmbeddedField "emptyCtx"%go emptyCtx)
].
Program Definition todoCtx'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (todoCtx'fds_unsealed).
Global Instance equals_unfold_todoCtx {ext : ffi_syntax} {go_gctx : GoGlobalContext} : todoCtx'fds =→ todoCtx'fds_unsealed.
Proof. rewrite /todoCtx'fds seal_eq //. Qed.

Definition todoCtxⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (todoCtx'fds).

Class todoCtx_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] todoCtx_type_repr  :: go.TypeReprUnderlying todoCtxⁱᵐᵖˡ todoCtx.t;
  #[global] todoCtx_underlying :: (todoCtx) <u (todoCtxⁱᵐᵖˡ);
  #[global] todoCtx_get_emptyCtx (x : todoCtx.t) :: ⟦StructFieldGet (todoCtxⁱᵐᵖˡ) "emptyCtx", #x⟧ ⤳[under] #x.(todoCtx.emptyCtx');
  #[global] todoCtx_set_emptyCtx (x : todoCtx.t) y :: ⟦StructFieldSet (todoCtxⁱᵐᵖˡ) "emptyCtx", (#x, #y)⟧ ⤳[under] #(x <|todoCtx.emptyCtx' := y|>);
  #[global] todoCtx_Deadline_unfold :: MethodUnfold (todoCtx) "Deadline" (λ: "$r", MethodResolve emptyCtx "Deadline" (StructFieldGet (todoCtx) "emptyCtx" "$r" ))%V;
  #[global] todoCtx_Done_unfold :: MethodUnfold (todoCtx) "Done" (λ: "$r", MethodResolve emptyCtx "Done" (StructFieldGet (todoCtx) "emptyCtx" "$r" ))%V;
  #[global] todoCtx_Err_unfold :: MethodUnfold (todoCtx) "Err" (λ: "$r", MethodResolve emptyCtx "Err" (StructFieldGet (todoCtx) "emptyCtx" "$r" ))%V;
  #[global] todoCtx_String_unfold :: MethodUnfold (todoCtx) "String" (todoCtx__Stringⁱᵐᵖˡ);
  #[global] todoCtx_Value_unfold :: MethodUnfold (todoCtx) "Value" (λ: "$r", MethodResolve emptyCtx "Value" (StructFieldGet (todoCtx) "emptyCtx" "$r" ))%V;
  #[global] todoCtx'ptr_Deadline_unfold :: MethodUnfold (go.PointerType (todoCtx)) "Deadline" (λ: "$r", MethodResolve (go.PointerType emptyCtx) "Deadline" (StructFieldRef todoCtx "emptyCtx"%go "$r"));
  #[global] todoCtx'ptr_Done_unfold :: MethodUnfold (go.PointerType (todoCtx)) "Done" (λ: "$r", MethodResolve (go.PointerType emptyCtx) "Done" (StructFieldRef todoCtx "emptyCtx"%go "$r"));
  #[global] todoCtx'ptr_Err_unfold :: MethodUnfold (go.PointerType (todoCtx)) "Err" (λ: "$r", MethodResolve (go.PointerType emptyCtx) "Err" (StructFieldRef todoCtx "emptyCtx"%go "$r"));
  #[global] todoCtx'ptr_String_unfold :: MethodUnfold (go.PointerType (todoCtx)) "String" (λ: "$r", MethodResolve (todoCtx) "String" (![(todoCtx)] "$r"));
  #[global] todoCtx'ptr_Value_unfold :: MethodUnfold (go.PointerType (todoCtx)) "Value" (λ: "$r", MethodResolve (go.PointerType emptyCtx) "Value" (StructFieldRef todoCtx "emptyCtx"%go "$r"));
}.

Module CancelFunc.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := func.t.
End def.
End CancelFunc.

Definition CancelFuncⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.FunctionType (go.Signature [] false []).

Class CancelFunc_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] CancelFunc_underlying :: (CancelFunc) <u (CancelFuncⁱᵐᵖˡ);
}.

Module CancelCauseFunc.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := func.t.
End def.
End CancelCauseFunc.

Definition CancelCauseFuncⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.FunctionType (go.Signature [go.error] false []).

Class CancelCauseFunc_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] CancelCauseFunc_underlying :: (CancelCauseFunc) <u (CancelCauseFuncⁱᵐᵖˡ);
}.

Module afterFuncer.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := interface.t.
End def.
End afterFuncer.

Definition afterFuncerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.InterfaceType [go.MethodElem "AfterFunc"%go (go.Signature [go.FunctionType (go.Signature [] false [])] false [go.FunctionType (go.Signature [] false [go.bool])])].

Class afterFuncer_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] afterFuncer_underlying :: (afterFuncer) <u (afterFuncerⁱᵐᵖˡ);
}.

Module cancelCtx.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  Context' : context.Context.t;
  mu' : sync.Mutex.t;
  done' : atomic.Value.t;
  children' : map.t;
  err' : atomic.Value.t;
  cause' : error.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End cancelCtx.

Definition cancelCtx'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.EmbeddedField "Context"%go Context);
  (go.FieldDecl "mu"%go sync.Mutex);
  (go.FieldDecl "done"%go atomic.Value);
  (go.FieldDecl "children"%go (go.MapType canceler (go.StructType [

  ])));
  (go.FieldDecl "err"%go atomic.Value);
  (go.FieldDecl "cause"%go go.error)
].
Program Definition cancelCtx'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (cancelCtx'fds_unsealed).
Global Instance equals_unfold_cancelCtx {ext : ffi_syntax} {go_gctx : GoGlobalContext} : cancelCtx'fds =→ cancelCtx'fds_unsealed.
Proof. rewrite /cancelCtx'fds seal_eq //. Qed.

Definition cancelCtxⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (cancelCtx'fds).

Class cancelCtx_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] cancelCtx_type_repr  :: go.TypeReprUnderlying cancelCtxⁱᵐᵖˡ cancelCtx.t;
  #[global] cancelCtx_underlying :: (cancelCtx) <u (cancelCtxⁱᵐᵖˡ);
  #[global] cancelCtx_get_Context (x : cancelCtx.t) :: ⟦StructFieldGet (cancelCtxⁱᵐᵖˡ) "Context", #x⟧ ⤳[under] #x.(cancelCtx.Context');
  #[global] cancelCtx_set_Context (x : cancelCtx.t) y :: ⟦StructFieldSet (cancelCtxⁱᵐᵖˡ) "Context", (#x, #y)⟧ ⤳[under] #(x <|cancelCtx.Context' := y|>);
  #[global] cancelCtx_get_mu (x : cancelCtx.t) :: ⟦StructFieldGet (cancelCtxⁱᵐᵖˡ) "mu", #x⟧ ⤳[under] #x.(cancelCtx.mu');
  #[global] cancelCtx_set_mu (x : cancelCtx.t) y :: ⟦StructFieldSet (cancelCtxⁱᵐᵖˡ) "mu", (#x, #y)⟧ ⤳[under] #(x <|cancelCtx.mu' := y|>);
  #[global] cancelCtx_get_done (x : cancelCtx.t) :: ⟦StructFieldGet (cancelCtxⁱᵐᵖˡ) "done", #x⟧ ⤳[under] #x.(cancelCtx.done');
  #[global] cancelCtx_set_done (x : cancelCtx.t) y :: ⟦StructFieldSet (cancelCtxⁱᵐᵖˡ) "done", (#x, #y)⟧ ⤳[under] #(x <|cancelCtx.done' := y|>);
  #[global] cancelCtx_get_children (x : cancelCtx.t) :: ⟦StructFieldGet (cancelCtxⁱᵐᵖˡ) "children", #x⟧ ⤳[under] #x.(cancelCtx.children');
  #[global] cancelCtx_set_children (x : cancelCtx.t) y :: ⟦StructFieldSet (cancelCtxⁱᵐᵖˡ) "children", (#x, #y)⟧ ⤳[under] #(x <|cancelCtx.children' := y|>);
  #[global] cancelCtx_get_err (x : cancelCtx.t) :: ⟦StructFieldGet (cancelCtxⁱᵐᵖˡ) "err", #x⟧ ⤳[under] #x.(cancelCtx.err');
  #[global] cancelCtx_set_err (x : cancelCtx.t) y :: ⟦StructFieldSet (cancelCtxⁱᵐᵖˡ) "err", (#x, #y)⟧ ⤳[under] #(x <|cancelCtx.err' := y|>);
  #[global] cancelCtx_get_cause (x : cancelCtx.t) :: ⟦StructFieldGet (cancelCtxⁱᵐᵖˡ) "cause", #x⟧ ⤳[under] #x.(cancelCtx.cause');
  #[global] cancelCtx_set_cause (x : cancelCtx.t) y :: ⟦StructFieldSet (cancelCtxⁱᵐᵖˡ) "cause", (#x, #y)⟧ ⤳[under] #(x <|cancelCtx.cause' := y|>);
  #[global] cancelCtx_Deadline_unfold :: MethodUnfold (cancelCtx) "Deadline" (λ: "$r", MethodResolve Context "Deadline" (StructFieldGet (cancelCtx) "Context" "$r" ))%V;
  #[global] cancelCtx'ptr_Deadline_unfold :: MethodUnfold (go.PointerType (cancelCtx)) "Deadline" (λ: "$r", MethodResolve (go.PointerType Context) "Deadline" (StructFieldRef cancelCtx "Context"%go "$r"));
  #[global] cancelCtx'ptr_Done_unfold :: MethodUnfold (go.PointerType (cancelCtx)) "Done" (cancelCtx__Doneⁱᵐᵖˡ);
  #[global] cancelCtx'ptr_Err_unfold :: MethodUnfold (go.PointerType (cancelCtx)) "Err" (cancelCtx__Errⁱᵐᵖˡ);
  #[global] cancelCtx'ptr_String_unfold :: MethodUnfold (go.PointerType (cancelCtx)) "String" (cancelCtx__Stringⁱᵐᵖˡ);
  #[global] cancelCtx'ptr_Value_unfold :: MethodUnfold (go.PointerType (cancelCtx)) "Value" (cancelCtx__Valueⁱᵐᵖˡ);
  #[global] cancelCtx'ptr_cancel_unfold :: MethodUnfold (go.PointerType (cancelCtx)) "cancel" (cancelCtx__cancelⁱᵐᵖˡ);
  #[global] cancelCtx'ptr_propagateCancel_unfold :: MethodUnfold (go.PointerType (cancelCtx)) "propagateCancel" (cancelCtx__propagateCancelⁱᵐᵖˡ);
}.

Module afterFuncCtx.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  cancelCtx' : context.cancelCtx.t;
  once' : sync.Once.t;
  f' : func.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End afterFuncCtx.

Definition afterFuncCtx'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.EmbeddedField "cancelCtx"%go cancelCtx);
  (go.FieldDecl "once"%go sync.Once);
  (go.FieldDecl "f"%go (go.FunctionType (go.Signature [] false [])))
].
Program Definition afterFuncCtx'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (afterFuncCtx'fds_unsealed).
Global Instance equals_unfold_afterFuncCtx {ext : ffi_syntax} {go_gctx : GoGlobalContext} : afterFuncCtx'fds =→ afterFuncCtx'fds_unsealed.
Proof. rewrite /afterFuncCtx'fds seal_eq //. Qed.

Definition afterFuncCtxⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (afterFuncCtx'fds).

Class afterFuncCtx_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] afterFuncCtx_type_repr  :: go.TypeReprUnderlying afterFuncCtxⁱᵐᵖˡ afterFuncCtx.t;
  #[global] afterFuncCtx_underlying :: (afterFuncCtx) <u (afterFuncCtxⁱᵐᵖˡ);
  #[global] afterFuncCtx_get_cancelCtx (x : afterFuncCtx.t) :: ⟦StructFieldGet (afterFuncCtxⁱᵐᵖˡ) "cancelCtx", #x⟧ ⤳[under] #x.(afterFuncCtx.cancelCtx');
  #[global] afterFuncCtx_set_cancelCtx (x : afterFuncCtx.t) y :: ⟦StructFieldSet (afterFuncCtxⁱᵐᵖˡ) "cancelCtx", (#x, #y)⟧ ⤳[under] #(x <|afterFuncCtx.cancelCtx' := y|>);
  #[global] afterFuncCtx_get_once (x : afterFuncCtx.t) :: ⟦StructFieldGet (afterFuncCtxⁱᵐᵖˡ) "once", #x⟧ ⤳[under] #x.(afterFuncCtx.once');
  #[global] afterFuncCtx_set_once (x : afterFuncCtx.t) y :: ⟦StructFieldSet (afterFuncCtxⁱᵐᵖˡ) "once", (#x, #y)⟧ ⤳[under] #(x <|afterFuncCtx.once' := y|>);
  #[global] afterFuncCtx_get_f (x : afterFuncCtx.t) :: ⟦StructFieldGet (afterFuncCtxⁱᵐᵖˡ) "f", #x⟧ ⤳[under] #x.(afterFuncCtx.f');
  #[global] afterFuncCtx_set_f (x : afterFuncCtx.t) y :: ⟦StructFieldSet (afterFuncCtxⁱᵐᵖˡ) "f", (#x, #y)⟧ ⤳[under] #(x <|afterFuncCtx.f' := y|>);
  #[global] afterFuncCtx_Deadline_unfold :: MethodUnfold (afterFuncCtx) "Deadline" (λ: "$r", MethodResolve cancelCtx "Deadline" (StructFieldGet (afterFuncCtx) "cancelCtx" "$r" ))%V;
  #[global] afterFuncCtx'ptr_Deadline_unfold :: MethodUnfold (go.PointerType (afterFuncCtx)) "Deadline" (λ: "$r", MethodResolve (go.PointerType cancelCtx) "Deadline" (StructFieldRef afterFuncCtx "cancelCtx"%go "$r"));
  #[global] afterFuncCtx'ptr_Done_unfold :: MethodUnfold (go.PointerType (afterFuncCtx)) "Done" (λ: "$r", MethodResolve (go.PointerType cancelCtx) "Done" (StructFieldRef afterFuncCtx "cancelCtx"%go "$r"));
  #[global] afterFuncCtx'ptr_Err_unfold :: MethodUnfold (go.PointerType (afterFuncCtx)) "Err" (λ: "$r", MethodResolve (go.PointerType cancelCtx) "Err" (StructFieldRef afterFuncCtx "cancelCtx"%go "$r"));
  #[global] afterFuncCtx'ptr_String_unfold :: MethodUnfold (go.PointerType (afterFuncCtx)) "String" (λ: "$r", MethodResolve (go.PointerType cancelCtx) "String" (StructFieldRef afterFuncCtx "cancelCtx"%go "$r"));
  #[global] afterFuncCtx'ptr_Value_unfold :: MethodUnfold (go.PointerType (afterFuncCtx)) "Value" (λ: "$r", MethodResolve (go.PointerType cancelCtx) "Value" (StructFieldRef afterFuncCtx "cancelCtx"%go "$r"));
  #[global] afterFuncCtx'ptr_cancel_unfold :: MethodUnfold (go.PointerType (afterFuncCtx)) "cancel" (afterFuncCtx__cancelⁱᵐᵖˡ);
  #[global] afterFuncCtx'ptr_propagateCancel_unfold :: MethodUnfold (go.PointerType (afterFuncCtx)) "propagateCancel" (λ: "$r", MethodResolve (go.PointerType cancelCtx) "propagateCancel" (StructFieldRef afterFuncCtx "cancelCtx"%go "$r"));
}.

Module stopCtx.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  Context' : context.Context.t;
  stop' : func.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End stopCtx.

Definition stopCtx'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.EmbeddedField "Context"%go Context);
  (go.FieldDecl "stop"%go (go.FunctionType (go.Signature [] false [go.bool])))
].
Program Definition stopCtx'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (stopCtx'fds_unsealed).
Global Instance equals_unfold_stopCtx {ext : ffi_syntax} {go_gctx : GoGlobalContext} : stopCtx'fds =→ stopCtx'fds_unsealed.
Proof. rewrite /stopCtx'fds seal_eq //. Qed.

Definition stopCtxⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (stopCtx'fds).

Class stopCtx_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] stopCtx_type_repr  :: go.TypeReprUnderlying stopCtxⁱᵐᵖˡ stopCtx.t;
  #[global] stopCtx_underlying :: (stopCtx) <u (stopCtxⁱᵐᵖˡ);
  #[global] stopCtx_get_Context (x : stopCtx.t) :: ⟦StructFieldGet (stopCtxⁱᵐᵖˡ) "Context", #x⟧ ⤳[under] #x.(stopCtx.Context');
  #[global] stopCtx_set_Context (x : stopCtx.t) y :: ⟦StructFieldSet (stopCtxⁱᵐᵖˡ) "Context", (#x, #y)⟧ ⤳[under] #(x <|stopCtx.Context' := y|>);
  #[global] stopCtx_get_stop (x : stopCtx.t) :: ⟦StructFieldGet (stopCtxⁱᵐᵖˡ) "stop", #x⟧ ⤳[under] #x.(stopCtx.stop');
  #[global] stopCtx_set_stop (x : stopCtx.t) y :: ⟦StructFieldSet (stopCtxⁱᵐᵖˡ) "stop", (#x, #y)⟧ ⤳[under] #(x <|stopCtx.stop' := y|>);
  #[global] stopCtx_Deadline_unfold :: MethodUnfold (stopCtx) "Deadline" (λ: "$r", MethodResolve Context "Deadline" (StructFieldGet (stopCtx) "Context" "$r" ))%V;
  #[global] stopCtx_Done_unfold :: MethodUnfold (stopCtx) "Done" (λ: "$r", MethodResolve Context "Done" (StructFieldGet (stopCtx) "Context" "$r" ))%V;
  #[global] stopCtx_Err_unfold :: MethodUnfold (stopCtx) "Err" (λ: "$r", MethodResolve Context "Err" (StructFieldGet (stopCtx) "Context" "$r" ))%V;
  #[global] stopCtx_Value_unfold :: MethodUnfold (stopCtx) "Value" (λ: "$r", MethodResolve Context "Value" (StructFieldGet (stopCtx) "Context" "$r" ))%V;
  #[global] stopCtx'ptr_Deadline_unfold :: MethodUnfold (go.PointerType (stopCtx)) "Deadline" (λ: "$r", MethodResolve (go.PointerType Context) "Deadline" (StructFieldRef stopCtx "Context"%go "$r"));
  #[global] stopCtx'ptr_Done_unfold :: MethodUnfold (go.PointerType (stopCtx)) "Done" (λ: "$r", MethodResolve (go.PointerType Context) "Done" (StructFieldRef stopCtx "Context"%go "$r"));
  #[global] stopCtx'ptr_Err_unfold :: MethodUnfold (go.PointerType (stopCtx)) "Err" (λ: "$r", MethodResolve (go.PointerType Context) "Err" (StructFieldRef stopCtx "Context"%go "$r"));
  #[global] stopCtx'ptr_Value_unfold :: MethodUnfold (go.PointerType (stopCtx)) "Value" (λ: "$r", MethodResolve (go.PointerType Context) "Value" (StructFieldRef stopCtx "Context"%go "$r"));
}.

Module canceler.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := interface.t.
End def.
End canceler.

Definition cancelerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.InterfaceType [go.MethodElem "Done"%go (go.Signature [] false [go.ChannelType go.recvonly (go.StructType [

  ])]); go.MethodElem "cancel"%go (go.Signature [go.bool; go.error; go.error] false [])].

Class canceler_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] canceler_underlying :: (canceler) <u (cancelerⁱᵐᵖˡ);
}.

Module stringer.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := interface.t.
End def.
End stringer.

Definition stringerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.InterfaceType [go.MethodElem "String"%go (go.Signature [] false [go.string])].

Class stringer_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] stringer_underlying :: (stringer) <u (stringerⁱᵐᵖˡ);
}.

Module withoutCancelCtx.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  c' : context.Context.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End withoutCancelCtx.

Definition withoutCancelCtx'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "c"%go Context)
].
Program Definition withoutCancelCtx'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (withoutCancelCtx'fds_unsealed).
Global Instance equals_unfold_withoutCancelCtx {ext : ffi_syntax} {go_gctx : GoGlobalContext} : withoutCancelCtx'fds =→ withoutCancelCtx'fds_unsealed.
Proof. rewrite /withoutCancelCtx'fds seal_eq //. Qed.

Definition withoutCancelCtxⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (withoutCancelCtx'fds).

Class withoutCancelCtx_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] withoutCancelCtx_type_repr  :: go.TypeReprUnderlying withoutCancelCtxⁱᵐᵖˡ withoutCancelCtx.t;
  #[global] withoutCancelCtx_underlying :: (withoutCancelCtx) <u (withoutCancelCtxⁱᵐᵖˡ);
  #[global] withoutCancelCtx_get_c (x : withoutCancelCtx.t) :: ⟦StructFieldGet (withoutCancelCtxⁱᵐᵖˡ) "c", #x⟧ ⤳[under] #x.(withoutCancelCtx.c');
  #[global] withoutCancelCtx_set_c (x : withoutCancelCtx.t) y :: ⟦StructFieldSet (withoutCancelCtxⁱᵐᵖˡ) "c", (#x, #y)⟧ ⤳[under] #(x <|withoutCancelCtx.c' := y|>);
  #[global] withoutCancelCtx_Deadline_unfold :: MethodUnfold (withoutCancelCtx) "Deadline" (withoutCancelCtx__Deadlineⁱᵐᵖˡ);
  #[global] withoutCancelCtx_Done_unfold :: MethodUnfold (withoutCancelCtx) "Done" (withoutCancelCtx__Doneⁱᵐᵖˡ);
  #[global] withoutCancelCtx_Err_unfold :: MethodUnfold (withoutCancelCtx) "Err" (withoutCancelCtx__Errⁱᵐᵖˡ);
  #[global] withoutCancelCtx_String_unfold :: MethodUnfold (withoutCancelCtx) "String" (withoutCancelCtx__Stringⁱᵐᵖˡ);
  #[global] withoutCancelCtx_Value_unfold :: MethodUnfold (withoutCancelCtx) "Value" (withoutCancelCtx__Valueⁱᵐᵖˡ);
  #[global] withoutCancelCtx'ptr_Deadline_unfold :: MethodUnfold (go.PointerType (withoutCancelCtx)) "Deadline" (λ: "$r", MethodResolve (withoutCancelCtx) "Deadline" (![(withoutCancelCtx)] "$r"));
  #[global] withoutCancelCtx'ptr_Done_unfold :: MethodUnfold (go.PointerType (withoutCancelCtx)) "Done" (λ: "$r", MethodResolve (withoutCancelCtx) "Done" (![(withoutCancelCtx)] "$r"));
  #[global] withoutCancelCtx'ptr_Err_unfold :: MethodUnfold (go.PointerType (withoutCancelCtx)) "Err" (λ: "$r", MethodResolve (withoutCancelCtx) "Err" (![(withoutCancelCtx)] "$r"));
  #[global] withoutCancelCtx'ptr_String_unfold :: MethodUnfold (go.PointerType (withoutCancelCtx)) "String" (λ: "$r", MethodResolve (withoutCancelCtx) "String" (![(withoutCancelCtx)] "$r"));
  #[global] withoutCancelCtx'ptr_Value_unfold :: MethodUnfold (go.PointerType (withoutCancelCtx)) "Value" (λ: "$r", MethodResolve (withoutCancelCtx) "Value" (![(withoutCancelCtx)] "$r"));
}.

Module timerCtx.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  cancelCtx' : context.cancelCtx.t;
  timer' : loc;
  deadline' : time.Time.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End timerCtx.

Definition timerCtx'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.EmbeddedField "cancelCtx"%go cancelCtx);
  (go.FieldDecl "timer"%go (go.PointerType time.Timer));
  (go.FieldDecl "deadline"%go time.Time)
].
Program Definition timerCtx'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (timerCtx'fds_unsealed).
Global Instance equals_unfold_timerCtx {ext : ffi_syntax} {go_gctx : GoGlobalContext} : timerCtx'fds =→ timerCtx'fds_unsealed.
Proof. rewrite /timerCtx'fds seal_eq //. Qed.

Definition timerCtxⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (timerCtx'fds).

Class timerCtx_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] timerCtx_type_repr  :: go.TypeReprUnderlying timerCtxⁱᵐᵖˡ timerCtx.t;
  #[global] timerCtx_underlying :: (timerCtx) <u (timerCtxⁱᵐᵖˡ);
  #[global] timerCtx_get_cancelCtx (x : timerCtx.t) :: ⟦StructFieldGet (timerCtxⁱᵐᵖˡ) "cancelCtx", #x⟧ ⤳[under] #x.(timerCtx.cancelCtx');
  #[global] timerCtx_set_cancelCtx (x : timerCtx.t) y :: ⟦StructFieldSet (timerCtxⁱᵐᵖˡ) "cancelCtx", (#x, #y)⟧ ⤳[under] #(x <|timerCtx.cancelCtx' := y|>);
  #[global] timerCtx_get_timer (x : timerCtx.t) :: ⟦StructFieldGet (timerCtxⁱᵐᵖˡ) "timer", #x⟧ ⤳[under] #x.(timerCtx.timer');
  #[global] timerCtx_set_timer (x : timerCtx.t) y :: ⟦StructFieldSet (timerCtxⁱᵐᵖˡ) "timer", (#x, #y)⟧ ⤳[under] #(x <|timerCtx.timer' := y|>);
  #[global] timerCtx_get_deadline (x : timerCtx.t) :: ⟦StructFieldGet (timerCtxⁱᵐᵖˡ) "deadline", #x⟧ ⤳[under] #x.(timerCtx.deadline');
  #[global] timerCtx_set_deadline (x : timerCtx.t) y :: ⟦StructFieldSet (timerCtxⁱᵐᵖˡ) "deadline", (#x, #y)⟧ ⤳[under] #(x <|timerCtx.deadline' := y|>);
  #[global] timerCtx'ptr_Deadline_unfold :: MethodUnfold (go.PointerType (timerCtx)) "Deadline" (timerCtx__Deadlineⁱᵐᵖˡ);
  #[global] timerCtx'ptr_Done_unfold :: MethodUnfold (go.PointerType (timerCtx)) "Done" (λ: "$r", MethodResolve (go.PointerType cancelCtx) "Done" (StructFieldRef timerCtx "cancelCtx"%go "$r"));
  #[global] timerCtx'ptr_Err_unfold :: MethodUnfold (go.PointerType (timerCtx)) "Err" (λ: "$r", MethodResolve (go.PointerType cancelCtx) "Err" (StructFieldRef timerCtx "cancelCtx"%go "$r"));
  #[global] timerCtx'ptr_String_unfold :: MethodUnfold (go.PointerType (timerCtx)) "String" (timerCtx__Stringⁱᵐᵖˡ);
  #[global] timerCtx'ptr_Value_unfold :: MethodUnfold (go.PointerType (timerCtx)) "Value" (λ: "$r", MethodResolve (go.PointerType cancelCtx) "Value" (StructFieldRef timerCtx "cancelCtx"%go "$r"));
  #[global] timerCtx'ptr_cancel_unfold :: MethodUnfold (go.PointerType (timerCtx)) "cancel" (timerCtx__cancelⁱᵐᵖˡ);
  #[global] timerCtx'ptr_propagateCancel_unfold :: MethodUnfold (go.PointerType (timerCtx)) "propagateCancel" (λ: "$r", MethodResolve (go.PointerType cancelCtx) "propagateCancel" (StructFieldRef timerCtx "cancelCtx"%go "$r"));
}.

Module valueCtx.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  Context' : context.Context.t;
  key' : interface.t;
  val' : interface.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End valueCtx.

Definition valueCtx'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.EmbeddedField "Context"%go Context);
  (go.FieldDecl "key"%go go.any);
  (go.FieldDecl "val"%go go.any)
].
Program Definition valueCtx'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (valueCtx'fds_unsealed).
Global Instance equals_unfold_valueCtx {ext : ffi_syntax} {go_gctx : GoGlobalContext} : valueCtx'fds =→ valueCtx'fds_unsealed.
Proof. rewrite /valueCtx'fds seal_eq //. Qed.

Definition valueCtxⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (valueCtx'fds).

Class valueCtx_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] valueCtx_type_repr  :: go.TypeReprUnderlying valueCtxⁱᵐᵖˡ valueCtx.t;
  #[global] valueCtx_underlying :: (valueCtx) <u (valueCtxⁱᵐᵖˡ);
  #[global] valueCtx_get_Context (x : valueCtx.t) :: ⟦StructFieldGet (valueCtxⁱᵐᵖˡ) "Context", #x⟧ ⤳[under] #x.(valueCtx.Context');
  #[global] valueCtx_set_Context (x : valueCtx.t) y :: ⟦StructFieldSet (valueCtxⁱᵐᵖˡ) "Context", (#x, #y)⟧ ⤳[under] #(x <|valueCtx.Context' := y|>);
  #[global] valueCtx_get_key (x : valueCtx.t) :: ⟦StructFieldGet (valueCtxⁱᵐᵖˡ) "key", #x⟧ ⤳[under] #x.(valueCtx.key');
  #[global] valueCtx_set_key (x : valueCtx.t) y :: ⟦StructFieldSet (valueCtxⁱᵐᵖˡ) "key", (#x, #y)⟧ ⤳[under] #(x <|valueCtx.key' := y|>);
  #[global] valueCtx_get_val (x : valueCtx.t) :: ⟦StructFieldGet (valueCtxⁱᵐᵖˡ) "val", #x⟧ ⤳[under] #x.(valueCtx.val');
  #[global] valueCtx_set_val (x : valueCtx.t) y :: ⟦StructFieldSet (valueCtxⁱᵐᵖˡ) "val", (#x, #y)⟧ ⤳[under] #(x <|valueCtx.val' := y|>);
  #[global] valueCtx_Deadline_unfold :: MethodUnfold (valueCtx) "Deadline" (λ: "$r", MethodResolve Context "Deadline" (StructFieldGet (valueCtx) "Context" "$r" ))%V;
  #[global] valueCtx_Done_unfold :: MethodUnfold (valueCtx) "Done" (λ: "$r", MethodResolve Context "Done" (StructFieldGet (valueCtx) "Context" "$r" ))%V;
  #[global] valueCtx_Err_unfold :: MethodUnfold (valueCtx) "Err" (λ: "$r", MethodResolve Context "Err" (StructFieldGet (valueCtx) "Context" "$r" ))%V;
  #[global] valueCtx'ptr_Deadline_unfold :: MethodUnfold (go.PointerType (valueCtx)) "Deadline" (λ: "$r", MethodResolve (go.PointerType Context) "Deadline" (StructFieldRef valueCtx "Context"%go "$r"));
  #[global] valueCtx'ptr_Done_unfold :: MethodUnfold (go.PointerType (valueCtx)) "Done" (λ: "$r", MethodResolve (go.PointerType Context) "Done" (StructFieldRef valueCtx "Context"%go "$r"));
  #[global] valueCtx'ptr_Err_unfold :: MethodUnfold (go.PointerType (valueCtx)) "Err" (λ: "$r", MethodResolve (go.PointerType Context) "Err" (StructFieldRef valueCtx "Context"%go "$r"));
  #[global] valueCtx'ptr_String_unfold :: MethodUnfold (go.PointerType (valueCtx)) "String" (valueCtx__Stringⁱᵐᵖˡ);
  #[global] valueCtx'ptr_Value_unfold :: MethodUnfold (go.PointerType (valueCtx)) "Value" (valueCtx__Valueⁱᵐᵖˡ);
}.

Class Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Context_instance :: Context_Assumptions;
  #[global] deadlineExceededError_instance :: deadlineExceededError_Assumptions;
  #[global] emptyCtx_instance :: emptyCtx_Assumptions;
  #[global] backgroundCtx_instance :: backgroundCtx_Assumptions;
  #[global] todoCtx_instance :: todoCtx_Assumptions;
  #[global] CancelFunc_instance :: CancelFunc_Assumptions;
  #[global] CancelCauseFunc_instance :: CancelCauseFunc_Assumptions;
  #[global] afterFuncer_instance :: afterFuncer_Assumptions;
  #[global] afterFuncCtx_instance :: afterFuncCtx_Assumptions;
  #[global] stopCtx_instance :: stopCtx_Assumptions;
  #[global] canceler_instance :: canceler_Assumptions;
  #[global] cancelCtx_instance :: cancelCtx_Assumptions;
  #[global] stringer_instance :: stringer_Assumptions;
  #[global] withoutCancelCtx_instance :: withoutCancelCtx_Assumptions;
  #[global] timerCtx_instance :: timerCtx_Assumptions;
  #[global] valueCtx_instance :: valueCtx_Assumptions;
  #[global] Background_unfold :: FuncUnfold Background [] (Backgroundⁱᵐᵖˡ);
  #[global] TODO_unfold :: FuncUnfold TODO [] (TODOⁱᵐᵖˡ);
  #[global] WithCancel_unfold :: FuncUnfold WithCancel [] (WithCancelⁱᵐᵖˡ);
  #[global] WithCancelCause_unfold :: FuncUnfold WithCancelCause [] (WithCancelCauseⁱᵐᵖˡ);
  #[global] withCancel_unfold :: FuncUnfold withCancel [] (withCancelⁱᵐᵖˡ);
  #[global] Cause_unfold :: FuncUnfold Cause [] (Causeⁱᵐᵖˡ);
  #[global] AfterFunc_unfold :: FuncUnfold AfterFunc [] (AfterFuncⁱᵐᵖˡ);
  #[global] parentCancelCtx_unfold :: FuncUnfold parentCancelCtx [] (parentCancelCtxⁱᵐᵖˡ);
  #[global] removeChild_unfold :: FuncUnfold removeChild [] (removeChildⁱᵐᵖˡ);
  #[global] WithoutCancel_unfold :: FuncUnfold WithoutCancel [] (WithoutCancelⁱᵐᵖˡ);
  #[global] WithDeadline_unfold :: FuncUnfold WithDeadline [] (WithDeadlineⁱᵐᵖˡ);
  #[global] WithDeadlineCause_unfold :: FuncUnfold WithDeadlineCause [] (WithDeadlineCauseⁱᵐᵖˡ);
  #[global] WithTimeout_unfold :: FuncUnfold WithTimeout [] (WithTimeoutⁱᵐᵖˡ);
  #[global] WithTimeoutCause_unfold :: FuncUnfold WithTimeoutCause [] (WithTimeoutCauseⁱᵐᵖˡ);
  #[global] value_unfold :: FuncUnfold value [] (valueⁱᵐᵖˡ);
  #[global] import_errors_Assumption :: errors.Assumptions;
  #[global] import_sync_Assumption :: sync.Assumptions;
  #[global] import_atomic_Assumption :: atomic.Assumptions;
  #[global] import_time_Assumption :: time.Assumptions;
}.
End context.
