(* autogenerated from context *)
Require Export New.code.errors.
Require Export New.code.internal.reflectlite.
Require Export New.code.sync.
Require Export New.code.sync.atomic.
Require Export New.code.time.

From New.golang Require Import defn.
Definition context : go_string := "context".

Module context.

Module Context. Definition id : go_string := "context.Context"%go. End Context.
Module deadlineExceededError. Definition id : go_string := "context.deadlineExceededError"%go. End deadlineExceededError.
Module emptyCtx. Definition id : go_string := "context.emptyCtx"%go. End emptyCtx.
Module backgroundCtx. Definition id : go_string := "context.backgroundCtx"%go. End backgroundCtx.
Module todoCtx. Definition id : go_string := "context.todoCtx"%go. End todoCtx.
Module CancelFunc. Definition id : go_string := "context.CancelFunc"%go. End CancelFunc.
Module cancelCtx. Definition id : go_string := "context.cancelCtx"%go. End cancelCtx.
Module CancelCauseFunc. Definition id : go_string := "context.CancelCauseFunc"%go. End CancelCauseFunc.
Module afterFuncCtx. Definition id : go_string := "context.afterFuncCtx"%go. End afterFuncCtx.
Module afterFuncer. Definition id : go_string := "context.afterFuncer"%go. End afterFuncer.
Module stopCtx. Definition id : go_string := "context.stopCtx"%go. End stopCtx.
Module canceler. Definition id : go_string := "context.canceler"%go. End canceler.
Module stringer. Definition id : go_string := "context.stringer"%go. End stringer.
Module withoutCancelCtx. Definition id : go_string := "context.withoutCancelCtx"%go. End withoutCancelCtx.
Module timerCtx. Definition id : go_string := "context.timerCtx"%go. End timerCtx.
Module valueCtx. Definition id : go_string := "context.valueCtx"%go. End valueCtx.

Section code.
Context `{ffi_syntax}.


Definition Context : go_type := interfaceT.
#[global] Typeclasses Opaque Context.
#[global] Opaque Context.

Definition Canceled : go_string := "context.Canceled"%go.

Definition DeadlineExceeded : go_string := "context.DeadlineExceeded"%go.

Definition deadlineExceededError : go_type := structT [
].
#[global] Typeclasses Opaque deadlineExceededError.
#[global] Opaque deadlineExceededError.

(* go: context.go:175:30 *)
Definition deadlineExceededError__Errorⁱᵐᵖˡ : val :=
  λ: <> <>,
    exception_do (return: (#"context deadline exceeded"%go)).

(* go: context.go:176:30 *)
Definition deadlineExceededError__Timeoutⁱᵐᵖˡ : val :=
  λ: <> <>,
    exception_do (return: (#true)).

(* go: context.go:177:30 *)
Definition deadlineExceededError__Temporaryⁱᵐᵖˡ : val :=
  λ: <> <>,
    exception_do (return: (#true)).

Definition emptyCtx : go_type := structT [
].
#[global] Typeclasses Opaque emptyCtx.
#[global] Opaque emptyCtx.

(* go: context.go:183:17 *)
Definition emptyCtx__Deadlineⁱᵐᵖˡ : val :=
  λ: <> <>,
    exception_do (let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "deadline" := (mem.alloc (type.zero_val #time.Time)) in
    return: (![#time.Time] "deadline", ![#boolT] "ok")).

(* go: context.go:187:17 *)
Definition emptyCtx__Doneⁱᵐᵖˡ : val :=
  λ: <> <>,
    exception_do (return: (#null)).

(* go: context.go:191:17 *)
Definition emptyCtx__Errⁱᵐᵖˡ : val :=
  λ: <> <>,
    exception_do (return: (#interface.nil)).

(* go: context.go:195:17 *)
Definition emptyCtx__Valueⁱᵐᵖˡ : val :=
  λ: <> "key",
    exception_do (let: "key" := (mem.alloc "key") in
    return: (#interface.nil)).

Definition backgroundCtx : go_type := structT [
  "emptyCtx" :: emptyCtx
].
#[global] Typeclasses Opaque backgroundCtx.
#[global] Opaque backgroundCtx.

(* go: context.go:201:22 *)
Definition backgroundCtx__Stringⁱᵐᵖˡ : val :=
  λ: <> <>,
    exception_do (return: (#"context.Background"%go)).

Definition todoCtx : go_type := structT [
  "emptyCtx" :: emptyCtx
].
#[global] Typeclasses Opaque todoCtx.
#[global] Opaque todoCtx.

(* go: context.go:207:16 *)
Definition todoCtx__Stringⁱᵐᵖˡ : val :=
  λ: <> <>,
    exception_do (return: (#"context.TODO"%go)).

Definition Background : go_string := "context.Background"%go.

(* Background returns a non-nil, empty [Context]. It is never canceled, has no
   values, and has no deadline. It is typically used by the main function,
   initialization, and tests, and as the top-level Context for incoming
   requests.

   go: context.go:215:6 *)
Definition Backgroundⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (interface.make #backgroundCtx.id (struct.make #backgroundCtx [{
       "emptyCtx" ::= type.zero_val #emptyCtx
     }]))).

Definition TODO : go_string := "context.TODO"%go.

(* TODO returns a non-nil, empty [Context]. Code should use context.TODO when
   it's unclear which Context to use or it is not yet available (because the
   surrounding function has not yet been extended to accept a Context
   parameter).

   go: context.go:223:6 *)
Definition TODOⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (interface.make #todoCtx.id (struct.make #todoCtx [{
       "emptyCtx" ::= type.zero_val #emptyCtx
     }]))).

Definition CancelFunc : go_type := funcT.
#[global] Typeclasses Opaque CancelFunc.
#[global] Opaque CancelFunc.

Definition WithCancel : go_string := "context.WithCancel"%go.

Definition withCancel : go_string := "context.withCancel"%go.

(* WithCancel returns a derived context that points to the parent context
   but has a new Done channel. The returned context's Done channel is closed
   when the returned cancel function is called or when the parent context's
   Done channel is closed, whichever happens first.

   Canceling this context releases resources associated with it, so code should
   call cancel as soon as the operations running in this [Context] complete.

   go: context.go:240:6 *)
Definition WithCancelⁱᵐᵖˡ : val :=
  λ: "parent",
    exception_do (let: "cancel" := (mem.alloc (type.zero_val #CancelFunc)) in
    let: "ctx" := (mem.alloc (type.zero_val #Context)) in
    let: "parent" := (mem.alloc "parent") in
    let: "c" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := (![#Context] "parent") in
    (func_call #withCancel) "$a0") in
    do:  ("c" <-[#ptrT] "$r0");;;
    return: (interface.make #(ptrT.id cancelCtx.id) (![#ptrT] "c"), (λ: <>,
       exception_do (do:  (let: "$a0" := #true in
       let: "$a1" := (![#error] (globals.get #Canceled)) in
       let: "$a2" := #interface.nil in
       (method_call #(ptrT.id cancelCtx.id) #"cancel"%go (![#ptrT] "c")) "$a0" "$a1" "$a2");;;
       return: #())
       ))).

Definition CancelCauseFunc : go_type := funcT.
#[global] Typeclasses Opaque CancelCauseFunc.
#[global] Opaque CancelCauseFunc.

Definition WithCancelCause : go_string := "context.WithCancelCause"%go.

(* WithCancelCause behaves like [WithCancel] but returns a [CancelCauseFunc] instead of a [CancelFunc].
   Calling cancel with a non-nil error (the "cause") records that error in ctx;
   it can then be retrieved using Cause(ctx).
   Calling cancel with nil sets the cause to Canceled.

   Example use:

   	ctx, cancel := context.WithCancelCause(parent)
   	cancel(myError)
   	ctx.Err() // returns context.Canceled
   	context.Cause(ctx) // returns myError

   go: context.go:268:6 *)
Definition WithCancelCauseⁱᵐᵖˡ : val :=
  λ: "parent",
    exception_do (let: "cancel" := (mem.alloc (type.zero_val #CancelCauseFunc)) in
    let: "ctx" := (mem.alloc (type.zero_val #Context)) in
    let: "parent" := (mem.alloc "parent") in
    let: "c" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := (![#Context] "parent") in
    (func_call #withCancel) "$a0") in
    do:  ("c" <-[#ptrT] "$r0");;;
    return: (interface.make #(ptrT.id cancelCtx.id) (![#ptrT] "c"), (λ: "cause",
       exception_do (let: "cause" := (mem.alloc "cause") in
       do:  (let: "$a0" := #true in
       let: "$a1" := (![#error] (globals.get #Canceled)) in
       let: "$a2" := (![#error] "cause") in
       (method_call #(ptrT.id cancelCtx.id) #"cancel"%go (![#ptrT] "c")) "$a0" "$a1" "$a2");;;
       return: #())
       ))).

Definition canceler : go_type := interfaceT.
#[global] Typeclasses Opaque canceler.
#[global] Opaque canceler.

Definition cancelCtx : go_type := structT [
  "Context" :: Context;
  "mu" :: sync.Mutex;
  "done" :: atomic.Value;
  "children" :: mapT canceler (structT [
  ]);
  "err" :: error;
  "cause" :: error
].
#[global] Typeclasses Opaque cancelCtx.
#[global] Opaque cancelCtx.

(* go: context.go:273:6 *)
Definition withCancelⁱᵐᵖˡ : val :=
  λ: "parent",
    exception_do (let: "parent" := (mem.alloc "parent") in
    (if: interface.eq (![#Context] "parent") #interface.nil
    then
      do:  (let: "$a0" := (interface.make #stringT.id #"cannot create context from nil parent"%go) in
      Panic "$a0")
    else do:  #());;;
    let: "c" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (struct.make #cancelCtx [{
      "Context" ::= type.zero_val #Context;
      "mu" ::= type.zero_val #sync.Mutex;
      "done" ::= type.zero_val #atomic.Value;
      "children" ::= type.zero_val (type.mapT #canceler (type.structT [
      ]));
      "err" ::= type.zero_val #error;
      "cause" ::= type.zero_val #error
    }])) in
    do:  ("c" <-[#ptrT] "$r0");;;
    do:  (let: "$a0" := (![#Context] "parent") in
    let: "$a1" := (interface.make #(ptrT.id cancelCtx.id) (![#ptrT] "c")) in
    (method_call #(ptrT.id cancelCtx.id) #"propagateCancel"%go (![#ptrT] "c")) "$a0" "$a1");;;
    return: (![#ptrT] "c")).

Definition Cause : go_string := "context.Cause"%go.

Definition cancelCtxKey : go_string := "context.cancelCtxKey"%go.

(* Cause returns a non-nil error explaining why c was canceled.
   The first cancellation of c or one of its parents sets the cause.
   If that cancellation happened via a call to CancelCauseFunc(err),
   then [Cause] returns err.
   Otherwise Cause(c) returns the same value as c.Err().
   Cause returns nil if c has not been canceled yet.

   go: context.go:288:6 *)
Definition Causeⁱᵐᵖˡ : val :=
  λ: "c",
    with_defer: (let: "c" := (mem.alloc "c") in
    (let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "cc" := (mem.alloc (type.zero_val #ptrT)) in
    let: ("$ret0", "$ret1") := (interface.checked_type_assert #ptrT (let: "$a0" := (interface.make #(ptrT.id intT.id) (globals.get #cancelCtxKey)) in
    (interface.get #"Value"%go (![#Context] "c")) "$a0") #(ptrT.id cancelCtx.id)) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("cc" <-[#ptrT] "$r0");;;
    do:  ("ok" <-[#boolT] "$r1");;;
    (if: ![#boolT] "ok"
    then
      do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (struct.field_ref #cancelCtx #"mu"%go (![#ptrT] "cc"))) #());;;
      do:  (let: "$f" := (method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (struct.field_ref #cancelCtx #"mu"%go (![#ptrT] "cc"))) in
      "$defer" <-[#funcT] (let: "$oldf" := (![#funcT] "$defer") in
      (λ: <>,
        "$f" #();;
        "$oldf" #()
        )));;;
      return: (![#error] (struct.field_ref #cancelCtx #"cause"%go (![#ptrT] "cc")))
    else do:  #()));;;
    return: ((interface.get #"Err"%go (![#Context] "c")) #())).

Definition AfterFunc : go_string := "context.AfterFunc"%go.

Definition afterFuncCtx : go_type := structT [
  "cancelCtx" :: cancelCtx;
  "once" :: sync.Once;
  "f" :: funcT
].
#[global] Typeclasses Opaque afterFuncCtx.
#[global] Opaque afterFuncCtx.

(* AfterFunc arranges to call f in its own goroutine after ctx is canceled.
   If ctx is already canceled, AfterFunc calls f immediately in its own goroutine.

   Multiple calls to AfterFunc on a context operate independently;
   one does not replace another.

   Calling the returned stop function stops the association of ctx with f.
   It returns true if the call stopped f from being run.
   If stop returns false,
   either the context is canceled and f has been started in its own goroutine;
   or f was already stopped.
   The stop function does not wait for f to complete before returning.
   If the caller needs to know whether f is completed,
   it must coordinate with f explicitly.

   If ctx has a "AfterFunc(func()) func() bool" method,
   AfterFunc will use it to schedule the call.

   go: context.go:319:6 *)
Definition AfterFuncⁱᵐᵖˡ : val :=
  λ: "ctx" "f",
    exception_do (let: "stop" := (mem.alloc (type.zero_val #funcT)) in
    let: "f" := (mem.alloc "f") in
    let: "ctx" := (mem.alloc "ctx") in
    let: "a" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (let: "$f" := (![#funcT] "f") in
    struct.make #afterFuncCtx [{
      "cancelCtx" ::= type.zero_val #cancelCtx;
      "once" ::= type.zero_val #sync.Once;
      "f" ::= "$f"
    }])) in
    do:  ("a" <-[#ptrT] "$r0");;;
    do:  (let: "$a0" := (![#Context] "ctx") in
    let: "$a1" := (interface.make #(ptrT.id afterFuncCtx.id) (![#ptrT] "a")) in
    (method_call #(ptrT.id cancelCtx.id) #"propagateCancel"%go (struct.field_ref #afterFuncCtx #"cancelCtx"%go (![#ptrT] "a"))) "$a0" "$a1");;;
    return: ((λ: <>,
       exception_do (let: "stopped" := (mem.alloc (type.zero_val #boolT)) in
       let: "$r0" := #false in
       do:  ("stopped" <-[#boolT] "$r0");;;
       do:  (let: "$a0" := (λ: <>,
         exception_do (let: "$r0" := #true in
         do:  ("stopped" <-[#boolT] "$r0");;;
         return: #())
         ) in
       (method_call #(ptrT.id sync.Once.id) #"Do"%go (struct.field_ref #afterFuncCtx #"once"%go (![#ptrT] "a"))) "$a0");;;
       (if: ![#boolT] "stopped"
       then
         do:  (let: "$a0" := #true in
         let: "$a1" := (![#error] (globals.get #Canceled)) in
         let: "$a2" := #interface.nil in
         (method_call #(ptrT.id afterFuncCtx.id) #"cancel"%go (![#ptrT] "a")) "$a0" "$a1" "$a2")
       else do:  #());;;
       return: (![#boolT] "stopped"))
       ))).

Definition afterFuncer : go_type := interfaceT.
#[global] Typeclasses Opaque afterFuncer.
#[global] Opaque afterFuncer.

Definition removeChild : go_string := "context.removeChild"%go.

(* go: context.go:346:24 *)
Definition afterFuncCtx__cancelⁱᵐᵖˡ : val :=
  λ: "a" "removeFromParent" "err" "cause",
    exception_do (let: "a" := (mem.alloc "a") in
    let: "cause" := (mem.alloc "cause") in
    let: "err" := (mem.alloc "err") in
    let: "removeFromParent" := (mem.alloc "removeFromParent") in
    do:  (let: "$a0" := #false in
    let: "$a1" := (![#error] "err") in
    let: "$a2" := (![#error] "cause") in
    (method_call #(ptrT.id cancelCtx.id) #"cancel"%go (struct.field_ref #afterFuncCtx #"cancelCtx"%go (![#ptrT] "a"))) "$a0" "$a1" "$a2");;;
    (if: ![#boolT] "removeFromParent"
    then
      do:  (let: "$a0" := (![#Context] (struct.field_ref #cancelCtx #"Context"%go (struct.field_ref #afterFuncCtx #"cancelCtx"%go (![#ptrT] "a")))) in
      let: "$a1" := (interface.make #(ptrT.id afterFuncCtx.id) (![#ptrT] "a")) in
      (func_call #removeChild) "$a0" "$a1")
    else do:  #());;;
    do:  (let: "$a0" := (λ: <>,
      exception_do (let: "$go" := (![#funcT] (struct.field_ref #afterFuncCtx #"f"%go (![#ptrT] "a"))) in
      do:  (Fork ("$go" #()));;;
      return: #())
      ) in
    (method_call #(ptrT.id sync.Once.id) #"Do"%go (struct.field_ref #afterFuncCtx #"once"%go (![#ptrT] "a"))) "$a0");;;
    return: #()).

Definition stopCtx : go_type := structT [
  "Context" :: Context;
  "stop" :: funcT
].
#[global] Typeclasses Opaque stopCtx.
#[global] Opaque stopCtx.

Definition goroutines : go_string := "context.goroutines"%go.

Definition parentCancelCtx : go_string := "context.parentCancelCtx"%go.

Definition closedchan : go_string := "context.closedchan"%go.

(* parentCancelCtx returns the underlying *cancelCtx for parent.
   It does this by looking up parent.Value(&cancelCtxKey) to find
   the innermost enclosing *cancelCtx and then checking whether
   parent.Done() matches that *cancelCtx. (If not, the *cancelCtx
   has been wrapped in a custom implementation providing a
   different done channel, in which case we should not bypass it.)

   go: context.go:376:6 *)
Definition parentCancelCtxⁱᵐᵖˡ : val :=
  λ: "parent",
    exception_do (let: "parent" := (mem.alloc "parent") in
    let: "done" := (mem.alloc (type.zero_val (type.chanT (type.structT [
    ])))) in
    let: "$r0" := ((interface.get #"Done"%go (![#Context] "parent")) #()) in
    do:  ("done" <-[type.chanT (type.structT [
    ])] "$r0");;;
    (if: ((![type.chanT (type.structT [
    ])] "done") = (![type.chanT (type.structT [
    ])] (globals.get #closedchan))) || ((![type.chanT (type.structT [
    ])] "done") = #null)
    then return: (#null, #false)
    else do:  #());;;
    let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "p" := (mem.alloc (type.zero_val #ptrT)) in
    let: ("$ret0", "$ret1") := (interface.checked_type_assert #ptrT (let: "$a0" := (interface.make #(ptrT.id intT.id) (globals.get #cancelCtxKey)) in
    (interface.get #"Value"%go (![#Context] "parent")) "$a0") #(ptrT.id cancelCtx.id)) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("p" <-[#ptrT] "$r0");;;
    do:  ("ok" <-[#boolT] "$r1");;;
    (if: (~ (![#boolT] "ok"))
    then return: (#null, #false)
    else do:  #());;;
    let: "pdone" := (mem.alloc (type.zero_val (type.chanT (type.structT [
    ])))) in
    let: ("$ret0", "$ret1") := (interface.checked_type_assert (type.chanT (type.structT [
    ])) ((method_call #(ptrT.id atomic.Value.id) #"Load"%go (struct.field_ref #cancelCtx #"done"%go (![#ptrT] "p"))) #()) #(chanT.id (structT.id []))) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("pdone" <-[type.chanT (type.structT [
    ])] "$r0");;;
    do:  "$r1";;;
    (if: (![type.chanT (type.structT [
    ])] "pdone") ≠ (![type.chanT (type.structT [
    ])] "done")
    then return: (#null, #false)
    else do:  #());;;
    return: (![#ptrT] "p", #true)).

(* removeChild removes a context from its parent.

   go: context.go:393:6 *)
Definition removeChildⁱᵐᵖˡ : val :=
  λ: "parent" "child",
    exception_do (let: "child" := (mem.alloc "child") in
    let: "parent" := (mem.alloc "parent") in
    (let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "s" := (mem.alloc (type.zero_val #stopCtx)) in
    let: ("$ret0", "$ret1") := (interface.checked_type_assert #stopCtx (![#Context] "parent") #stopCtx.id) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("s" <-[#stopCtx] "$r0");;;
    do:  ("ok" <-[#boolT] "$r1");;;
    (if: ![#boolT] "ok"
    then
      do:  ((![#funcT] (struct.field_ref #stopCtx #"stop"%go "s")) #());;;
      return: (#())
    else do:  #()));;;
    let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "p" := (mem.alloc (type.zero_val #ptrT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#Context] "parent") in
    (func_call #parentCancelCtx) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("p" <-[#ptrT] "$r0");;;
    do:  ("ok" <-[#boolT] "$r1");;;
    (if: (~ (![#boolT] "ok"))
    then return: (#())
    else do:  #());;;
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (struct.field_ref #cancelCtx #"mu"%go (![#ptrT] "p"))) #());;;
    (if: (![type.mapT #canceler (type.structT [
    ])] (struct.field_ref #cancelCtx #"children"%go (![#ptrT] "p"))) ≠ #null
    then
      do:  (let: "$a0" := (![type.mapT #canceler (type.structT [
      ])] (struct.field_ref #cancelCtx #"children"%go (![#ptrT] "p"))) in
      let: "$a1" := (![#canceler] "child") in
      map.delete "$a0" "$a1")
    else do:  #());;;
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (struct.field_ref #cancelCtx #"mu"%go (![#ptrT] "p"))) #());;;
    return: #()).

Definition value : go_string := "context.value"%go.

(* go: context.go:435:21 *)
Definition cancelCtx__Valueⁱᵐᵖˡ : val :=
  λ: "c" "key",
    exception_do (let: "c" := (mem.alloc "c") in
    let: "key" := (mem.alloc "key") in
    (if: interface.eq (![#interfaceT] "key") (interface.make #(ptrT.id intT.id) (globals.get #cancelCtxKey))
    then return: (interface.make #(ptrT.id cancelCtx.id) (![#ptrT] "c"))
    else do:  #());;;
    return: (let: "$a0" := (![#Context] (struct.field_ref #cancelCtx #"Context"%go (![#ptrT] "c"))) in
     let: "$a1" := (![#interfaceT] "key") in
     (func_call #value) "$a0" "$a1")).

(* go: context.go:442:21 *)
Definition cancelCtx__Doneⁱᵐᵖˡ : val :=
  λ: "c" <>,
    with_defer: (let: "c" := (mem.alloc "c") in
    let: "d" := (mem.alloc (type.zero_val #interfaceT)) in
    let: "$r0" := ((method_call #(ptrT.id atomic.Value.id) #"Load"%go (struct.field_ref #cancelCtx #"done"%go (![#ptrT] "c"))) #()) in
    do:  ("d" <-[#interfaceT] "$r0");;;
    (if: (~ (interface.eq (![#interfaceT] "d") #interface.nil))
    then return: (interface.type_assert (![#interfaceT] "d") #(chanT.id (structT.id [])))
    else do:  #());;;
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (struct.field_ref #cancelCtx #"mu"%go (![#ptrT] "c"))) #());;;
    do:  (let: "$f" := (method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (struct.field_ref #cancelCtx #"mu"%go (![#ptrT] "c"))) in
    "$defer" <-[#funcT] (let: "$oldf" := (![#funcT] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    let: "$r0" := ((method_call #(ptrT.id atomic.Value.id) #"Load"%go (struct.field_ref #cancelCtx #"done"%go (![#ptrT] "c"))) #()) in
    do:  ("d" <-[#interfaceT] "$r0");;;
    (if: interface.eq (![#interfaceT] "d") #interface.nil
    then
      let: "$r0" := (interface.make #(chanT.id (structT.id [])) (chan.make (type.structT [
      ]) #(W64 0))) in
      do:  ("d" <-[#interfaceT] "$r0");;;
      do:  (let: "$a0" := (![#interfaceT] "d") in
      (method_call #(ptrT.id atomic.Value.id) #"Store"%go (struct.field_ref #cancelCtx #"done"%go (![#ptrT] "c"))) "$a0")
    else do:  #());;;
    return: (interface.type_assert (![#interfaceT] "d") #(chanT.id (structT.id [])))).

(* go: context.go:457:21 *)
Definition cancelCtx__Errⁱᵐᵖˡ : val :=
  λ: "c" <>,
    exception_do (let: "c" := (mem.alloc "c") in
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (struct.field_ref #cancelCtx #"mu"%go (![#ptrT] "c"))) #());;;
    let: "err" := (mem.alloc (type.zero_val #error)) in
    let: "$r0" := (![#error] (struct.field_ref #cancelCtx #"err"%go (![#ptrT] "c"))) in
    do:  ("err" <-[#error] "$r0");;;
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (struct.field_ref #cancelCtx #"mu"%go (![#ptrT] "c"))) #());;;
    return: (![#error] "err")).

(* propagateCancel arranges for child to be canceled when parent is.
   It sets the parent context of cancelCtx.

   go: context.go:466:21 *)
Definition cancelCtx__propagateCancelⁱᵐᵖˡ : val :=
  λ: "c" "parent" "child",
    exception_do (let: "c" := (mem.alloc "c") in
    let: "child" := (mem.alloc "child") in
    let: "parent" := (mem.alloc "parent") in
    let: "$r0" := (![#Context] "parent") in
    do:  ((struct.field_ref #cancelCtx #"Context"%go (![#ptrT] "c")) <-[#Context] "$r0");;;
    let: "done" := (mem.alloc (type.zero_val (type.chanT (type.structT [
    ])))) in
    let: "$r0" := ((interface.get #"Done"%go (![#Context] "parent")) #()) in
    do:  ("done" <-[type.chanT (type.structT [
    ])] "$r0");;;
    (if: (![type.chanT (type.structT [
    ])] "done") = #null
    then return: (#())
    else do:  #());;;
    chan.select_nonblocking [chan.select_receive (type.structT [
     ]) (![type.chanT (type.structT [
     ])] "done") (λ: "$recvVal",
       do:  (let: "$a0" := #false in
       let: "$a1" := ((interface.get #"Err"%go (![#Context] "parent")) #()) in
       let: "$a2" := (let: "$a0" := (![#Context] "parent") in
       (func_call #Cause) "$a0") in
       (interface.get #"cancel"%go (![#canceler] "child")) "$a0" "$a1" "$a2");;;
       return: (#())
       )] (λ: <>,
      do:  #()
      );;;
    (let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "p" := (mem.alloc (type.zero_val #ptrT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#Context] "parent") in
    (func_call #parentCancelCtx) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("p" <-[#ptrT] "$r0");;;
    do:  ("ok" <-[#boolT] "$r1");;;
    (if: ![#boolT] "ok"
    then
      do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (struct.field_ref #cancelCtx #"mu"%go (![#ptrT] "p"))) #());;;
      (if: (~ (interface.eq (![#error] (struct.field_ref #cancelCtx #"err"%go (![#ptrT] "p"))) #interface.nil))
      then
        do:  (let: "$a0" := #false in
        let: "$a1" := (![#error] (struct.field_ref #cancelCtx #"err"%go (![#ptrT] "p"))) in
        let: "$a2" := (![#error] (struct.field_ref #cancelCtx #"cause"%go (![#ptrT] "p"))) in
        (interface.get #"cancel"%go (![#canceler] "child")) "$a0" "$a1" "$a2")
      else
        (if: (![type.mapT #canceler (type.structT [
        ])] (struct.field_ref #cancelCtx #"children"%go (![#ptrT] "p"))) = #null
        then
          let: "$r0" := (map.make #canceler (type.structT [
          ])) in
          do:  ((struct.field_ref #cancelCtx #"children"%go (![#ptrT] "p")) <-[type.mapT #canceler (type.structT [
          ])] "$r0")
        else do:  #());;;
        let: "$r0" := (struct.make (type.structT [
        ]) [{
        }]) in
        do:  (map.insert (![type.mapT #canceler (type.structT [
        ])] (struct.field_ref #cancelCtx #"children"%go (![#ptrT] "p"))) (![#canceler] "child") "$r0"));;;
      do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (struct.field_ref #cancelCtx #"mu"%go (![#ptrT] "p"))) #());;;
      return: (#())
    else do:  #()));;;
    (let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "a" := (mem.alloc (type.zero_val #afterFuncer)) in
    let: ("$ret0", "$ret1") := (interface.checked_type_assert #afterFuncer (![#Context] "parent") #afterFuncer.id) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("a" <-[#afterFuncer] "$r0");;;
    do:  ("ok" <-[#boolT] "$r1");;;
    (if: ![#boolT] "ok"
    then
      do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (struct.field_ref #cancelCtx #"mu"%go (![#ptrT] "c"))) #());;;
      let: "stop" := (mem.alloc (type.zero_val #funcT)) in
      let: "$r0" := (let: "$a0" := (λ: <>,
        exception_do (do:  (let: "$a0" := #false in
        let: "$a1" := ((interface.get #"Err"%go (![#Context] "parent")) #()) in
        let: "$a2" := (let: "$a0" := (![#Context] "parent") in
        (func_call #Cause) "$a0") in
        (interface.get #"cancel"%go (![#canceler] "child")) "$a0" "$a1" "$a2");;;
        return: #())
        ) in
      (interface.get #"AfterFunc"%go (![#afterFuncer] "a")) "$a0") in
      do:  ("stop" <-[#funcT] "$r0");;;
      let: "$r0" := (interface.make #stopCtx.id (let: "$Context" := (![#Context] "parent") in
      let: "$stop" := (![#funcT] "stop") in
      struct.make #stopCtx [{
        "Context" ::= "$Context";
        "stop" ::= "$stop"
      }])) in
      do:  ((struct.field_ref #cancelCtx #"Context"%go (![#ptrT] "c")) <-[#Context] "$r0");;;
      do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (struct.field_ref #cancelCtx #"mu"%go (![#ptrT] "c"))) #());;;
      return: (#())
    else do:  #()));;;
    do:  (let: "$a0" := #(W32 1) in
    (method_call #(ptrT.id atomic.Int32.id) #"Add"%go (globals.get #goroutines)) "$a0");;;
    let: "$go" := (λ: <>,
      exception_do (chan.select_blocking [chan.select_receive (type.structT [
       ]) ((interface.get #"Done"%go (![#Context] "parent")) #()) (λ: "$recvVal",
         do:  (let: "$a0" := #false in
         let: "$a1" := ((interface.get #"Err"%go (![#Context] "parent")) #()) in
         let: "$a2" := (let: "$a0" := (![#Context] "parent") in
         (func_call #Cause) "$a0") in
         (interface.get #"cancel"%go (![#canceler] "child")) "$a0" "$a1" "$a2")
         ); chan.select_receive (type.structT [
       ]) ((interface.get #"Done"%go (![#canceler] "child")) #()) (λ: "$recvVal",
         do:  #()
         )];;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    return: #()).

Definition stringer : go_type := interfaceT.
#[global] Typeclasses Opaque stringer.
#[global] Opaque stringer.

Definition contextName : go_string := "context.contextName"%go.

(* go: context.go:526:6 *)
Definition contextNameⁱᵐᵖˡ : val :=
  λ: "c",
    exception_do (let: "c" := (mem.alloc "c") in
    (let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "s" := (mem.alloc (type.zero_val #stringer)) in
    let: ("$ret0", "$ret1") := (interface.checked_type_assert #stringer (![#Context] "c") #stringer.id) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("s" <-[#stringer] "$r0");;;
    do:  ("ok" <-[#boolT] "$r1");;;
    (if: ![#boolT] "ok"
    then return: ((interface.get #"String"%go (![#stringer] "s")) #())
    else do:  #()));;;
    return: ((interface.get #"String"%go (let: "$a0" := (![#Context] "c") in
     (func_call #reflectlite.TypeOf) "$a0")) #())).

(* go: context.go:533:21 *)
Definition cancelCtx__Stringⁱᵐᵖˡ : val :=
  λ: "c" <>,
    exception_do (let: "c" := (mem.alloc "c") in
    return: ((let: "$a0" := (![#Context] (struct.field_ref #cancelCtx #"Context"%go (![#ptrT] "c"))) in
     (func_call #contextName) "$a0") + #".WithCancel"%go)).

(* cancel closes c.done, cancels each of c's children, and, if
   removeFromParent is true, removes c from its parent's children.
   cancel sets c.cause to cause if this is the first time c is canceled.

   go: context.go:540:21 *)
Definition cancelCtx__cancelⁱᵐᵖˡ : val :=
  λ: "c" "removeFromParent" "err" "cause",
    exception_do (let: "c" := (mem.alloc "c") in
    let: "cause" := (mem.alloc "cause") in
    let: "err" := (mem.alloc "err") in
    let: "removeFromParent" := (mem.alloc "removeFromParent") in
    (if: interface.eq (![#error] "err") #interface.nil
    then
      do:  (let: "$a0" := (interface.make #stringT.id #"context: internal error: missing cancel error"%go) in
      Panic "$a0")
    else do:  #());;;
    (if: interface.eq (![#error] "cause") #interface.nil
    then
      let: "$r0" := (![#error] "err") in
      do:  ("cause" <-[#error] "$r0")
    else do:  #());;;
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (struct.field_ref #cancelCtx #"mu"%go (![#ptrT] "c"))) #());;;
    (if: (~ (interface.eq (![#error] (struct.field_ref #cancelCtx #"err"%go (![#ptrT] "c"))) #interface.nil))
    then
      do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (struct.field_ref #cancelCtx #"mu"%go (![#ptrT] "c"))) #());;;
      return: (#())
    else do:  #());;;
    let: "$r0" := (![#error] "err") in
    do:  ((struct.field_ref #cancelCtx #"err"%go (![#ptrT] "c")) <-[#error] "$r0");;;
    let: "$r0" := (![#error] "cause") in
    do:  ((struct.field_ref #cancelCtx #"cause"%go (![#ptrT] "c")) <-[#error] "$r0");;;
    let: "d" := (mem.alloc (type.zero_val (type.chanT (type.structT [
    ])))) in
    let: ("$ret0", "$ret1") := (interface.checked_type_assert (type.chanT (type.structT [
    ])) ((method_call #(ptrT.id atomic.Value.id) #"Load"%go (struct.field_ref #cancelCtx #"done"%go (![#ptrT] "c"))) #()) #(chanT.id (structT.id []))) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("d" <-[type.chanT (type.structT [
    ])] "$r0");;;
    do:  "$r1";;;
    (if: (![type.chanT (type.structT [
    ])] "d") = #null
    then
      do:  (let: "$a0" := (interface.make #(chanT.id (structT.id [])) (![type.chanT (type.structT [
      ])] (globals.get #closedchan))) in
      (method_call #(ptrT.id atomic.Value.id) #"Store"%go (struct.field_ref #cancelCtx #"done"%go (![#ptrT] "c"))) "$a0")
    else
      do:  (let: "$a0" := (![type.chanT (type.structT [
      ])] "d") in
      chan.close "$a0"));;;
    let: "$range" := (![type.mapT #canceler (type.structT [
    ])] (struct.field_ref #cancelCtx #"children"%go (![#ptrT] "c"))) in
    (let: "child" := (mem.alloc (type.zero_val #canceler)) in
    map.for_range "$range" (λ: "$key" "value",
      do:  ("child" <-[#canceler] "$key");;;
      do:  (let: "$a0" := #false in
      let: "$a1" := (![#error] "err") in
      let: "$a2" := (![#error] "cause") in
      (interface.get #"cancel"%go (![#canceler] "child")) "$a0" "$a1" "$a2")));;;
    let: "$r0" := #null in
    do:  ((struct.field_ref #cancelCtx #"children"%go (![#ptrT] "c")) <-[type.mapT #canceler (type.structT [
    ])] "$r0");;;
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (struct.field_ref #cancelCtx #"mu"%go (![#ptrT] "c"))) #());;;
    (if: ![#boolT] "removeFromParent"
    then
      do:  (let: "$a0" := (![#Context] (struct.field_ref #cancelCtx #"Context"%go (![#ptrT] "c"))) in
      let: "$a1" := (interface.make #(ptrT.id cancelCtx.id) (![#ptrT] "c")) in
      (func_call #removeChild) "$a0" "$a1")
    else do:  #());;;
    return: #()).

Definition WithoutCancel : go_string := "context.WithoutCancel"%go.

Definition withoutCancelCtx : go_type := structT [
  "c" :: Context
].
#[global] Typeclasses Opaque withoutCancelCtx.
#[global] Opaque withoutCancelCtx.

(* WithoutCancel returns a derived context that points to the parent context
   and is not canceled when parent is canceled.
   The returned context returns no Deadline or Err, and its Done channel is nil.
   Calling [Cause] on the returned context returns nil.

   go: context.go:576:6 *)
Definition WithoutCancelⁱᵐᵖˡ : val :=
  λ: "parent",
    exception_do (let: "parent" := (mem.alloc "parent") in
    (if: interface.eq (![#Context] "parent") #interface.nil
    then
      do:  (let: "$a0" := (interface.make #stringT.id #"cannot create context from nil parent"%go) in
      Panic "$a0")
    else do:  #());;;
    return: (interface.make #withoutCancelCtx.id (struct.make #withoutCancelCtx [{
       "c" ::= ![#Context] "parent"
     }]))).

(* go: context.go:587:25 *)
Definition withoutCancelCtx__Deadlineⁱᵐᵖˡ : val :=
  λ: <> <>,
    exception_do (let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "deadline" := (mem.alloc (type.zero_val #time.Time)) in
    return: (![#time.Time] "deadline", ![#boolT] "ok")).

(* go: context.go:591:25 *)
Definition withoutCancelCtx__Doneⁱᵐᵖˡ : val :=
  λ: <> <>,
    exception_do (return: (#null)).

(* go: context.go:595:25 *)
Definition withoutCancelCtx__Errⁱᵐᵖˡ : val :=
  λ: <> <>,
    exception_do (return: (#interface.nil)).

(* go: context.go:599:27 *)
Definition withoutCancelCtx__Valueⁱᵐᵖˡ : val :=
  λ: "c" "key",
    exception_do (let: "c" := (mem.alloc "c") in
    let: "key" := (mem.alloc "key") in
    return: (let: "$a0" := (interface.make #withoutCancelCtx.id (![#withoutCancelCtx] "c")) in
     let: "$a1" := (![#interfaceT] "key") in
     (func_call #value) "$a0" "$a1")).

(* go: context.go:603:27 *)
Definition withoutCancelCtx__Stringⁱᵐᵖˡ : val :=
  λ: "c" <>,
    exception_do (let: "c" := (mem.alloc "c") in
    return: ((let: "$a0" := (![#Context] (struct.field_ref #withoutCancelCtx #"c"%go "c")) in
     (func_call #contextName) "$a0") + #".WithoutCancel"%go)).

Definition WithDeadline : go_string := "context.WithDeadline"%go.

Definition WithDeadlineCause : go_string := "context.WithDeadlineCause"%go.

(* WithDeadline returns a derived context that points to the parent context
   but has the deadline adjusted to be no later than d. If the parent's
   deadline is already earlier than d, WithDeadline(parent, d) is semantically
   equivalent to parent. The returned [Context.Done] channel is closed when
   the deadline expires, when the returned cancel function is called,
   or when the parent context's Done channel is closed, whichever happens first.

   Canceling this context releases resources associated with it, so code should
   call cancel as soon as the operations running in this [Context] complete.

   go: context.go:616:6 *)
Definition WithDeadlineⁱᵐᵖˡ : val :=
  λ: "parent" "d",
    exception_do (let: "d" := (mem.alloc "d") in
    let: "parent" := (mem.alloc "parent") in
    let: ("$ret0", "$ret1") := ((let: "$a0" := (![#Context] "parent") in
    let: "$a1" := (![#time.Time] "d") in
    let: "$a2" := #interface.nil in
    (func_call #WithDeadlineCause) "$a0" "$a1" "$a2")) in
    return: ("$ret0", "$ret1")).

Definition timerCtx : go_type := structT [
  "cancelCtx" :: cancelCtx;
  "timer" :: ptrT;
  "deadline" :: time.Time
].
#[global] Typeclasses Opaque timerCtx.
#[global] Opaque timerCtx.

(* WithDeadlineCause behaves like [WithDeadline] but also sets the cause of the
   returned Context when the deadline is exceeded. The returned [CancelFunc] does
   not set the cause.

   go: context.go:623:6 *)
Definition WithDeadlineCauseⁱᵐᵖˡ : val :=
  λ: "parent" "d" "cause",
    with_defer: (let: "cause" := (mem.alloc "cause") in
    let: "d" := (mem.alloc "d") in
    let: "parent" := (mem.alloc "parent") in
    (if: interface.eq (![#Context] "parent") #interface.nil
    then
      do:  (let: "$a0" := (interface.make #stringT.id #"cannot create context from nil parent"%go) in
      Panic "$a0")
    else do:  #());;;
    (let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "cur" := (mem.alloc (type.zero_val #time.Time)) in
    let: ("$ret0", "$ret1") := ((interface.get #"Deadline"%go (![#Context] "parent")) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("cur" <-[#time.Time] "$r0");;;
    do:  ("ok" <-[#boolT] "$r1");;;
    (if: (![#boolT] "ok") && (let: "$a0" := (![#time.Time] "d") in
    (method_call #time.Time.id #"Before"%go (![#time.Time] "cur")) "$a0")
    then
      let: ("$ret0", "$ret1") := ((let: "$a0" := (![#Context] "parent") in
      (func_call #WithCancel) "$a0")) in
      return: ("$ret0", "$ret1")
    else do:  #()));;;
    let: "c" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (let: "$deadline" := (![#time.Time] "d") in
    struct.make #timerCtx [{
      "cancelCtx" ::= type.zero_val #cancelCtx;
      "timer" ::= type.zero_val #ptrT;
      "deadline" ::= "$deadline"
    }])) in
    do:  ("c" <-[#ptrT] "$r0");;;
    do:  (let: "$a0" := (![#Context] "parent") in
    let: "$a1" := (interface.make #(ptrT.id timerCtx.id) (![#ptrT] "c")) in
    (method_call #(ptrT.id cancelCtx.id) #"propagateCancel"%go (struct.field_ref #timerCtx #"cancelCtx"%go (![#ptrT] "c"))) "$a0" "$a1");;;
    let: "dur" := (mem.alloc (type.zero_val #time.Duration)) in
    let: "$r0" := (let: "$a0" := (![#time.Time] "d") in
    (func_call #time.Until) "$a0") in
    do:  ("dur" <-[#time.Duration] "$r0");;;
    (if: int_leq (![#time.Duration] "dur") #(W64 0)
    then
      do:  (let: "$a0" := #true in
      let: "$a1" := (![#error] (globals.get #DeadlineExceeded)) in
      let: "$a2" := (![#error] "cause") in
      (method_call #(ptrT.id timerCtx.id) #"cancel"%go (![#ptrT] "c")) "$a0" "$a1" "$a2");;;
      return: (interface.make #(ptrT.id timerCtx.id) (![#ptrT] "c"), (λ: <>,
         exception_do (do:  (let: "$a0" := #false in
         let: "$a1" := (![#error] (globals.get #Canceled)) in
         let: "$a2" := #interface.nil in
         (method_call #(ptrT.id timerCtx.id) #"cancel"%go (![#ptrT] "c")) "$a0" "$a1" "$a2");;;
         return: #())
         ))
    else do:  #());;;
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (struct.field_ref #cancelCtx #"mu"%go (struct.field_ref #timerCtx #"cancelCtx"%go (![#ptrT] "c")))) #());;;
    do:  (let: "$f" := (method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (struct.field_ref #cancelCtx #"mu"%go (struct.field_ref #timerCtx #"cancelCtx"%go (![#ptrT] "c")))) in
    "$defer" <-[#funcT] (let: "$oldf" := (![#funcT] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    (if: interface.eq (![#error] (struct.field_ref #cancelCtx #"err"%go (struct.field_ref #timerCtx #"cancelCtx"%go (![#ptrT] "c")))) #interface.nil
    then
      let: "$r0" := (let: "$a0" := (![#time.Duration] "dur") in
      let: "$a1" := (λ: <>,
        exception_do (do:  (let: "$a0" := #true in
        let: "$a1" := (![#error] (globals.get #DeadlineExceeded)) in
        let: "$a2" := (![#error] "cause") in
        (method_call #(ptrT.id timerCtx.id) #"cancel"%go (![#ptrT] "c")) "$a0" "$a1" "$a2");;;
        return: #())
        ) in
      (func_call #time.AfterFunc) "$a0" "$a1") in
      do:  ((struct.field_ref #timerCtx #"timer"%go (![#ptrT] "c")) <-[#ptrT] "$r0")
    else do:  #());;;
    return: (interface.make #(ptrT.id timerCtx.id) (![#ptrT] "c"), (λ: <>,
       exception_do (do:  (let: "$a0" := #true in
       let: "$a1" := (![#error] (globals.get #Canceled)) in
       let: "$a2" := #interface.nil in
       (method_call #(ptrT.id timerCtx.id) #"cancel"%go (![#ptrT] "c")) "$a0" "$a1" "$a2");;;
       return: #())
       ))).

(* go: context.go:660:20 *)
Definition timerCtx__Deadlineⁱᵐᵖˡ : val :=
  λ: "c" <>,
    exception_do (let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "deadline" := (mem.alloc (type.zero_val #time.Time)) in
    let: "c" := (mem.alloc "c") in
    return: (![#time.Time] (struct.field_ref #timerCtx #"deadline"%go (![#ptrT] "c")), #true)).

(* go: context.go:664:20 *)
Definition timerCtx__Stringⁱᵐᵖˡ : val :=
  λ: "c" <>,
    exception_do (let: "c" := (mem.alloc "c") in
    return: ((((((let: "$a0" := (![#Context] (struct.field_ref #cancelCtx #"Context"%go (struct.field_ref #timerCtx #"cancelCtx"%go (![#ptrT] "c")))) in
     (func_call #contextName) "$a0") + #".WithDeadline("%go) + ((method_call #time.Time.id #"String"%go (![#time.Time] (struct.field_ref #timerCtx #"deadline"%go (![#ptrT] "c")))) #())) + #" ["%go) + ((method_call #time.Duration.id #"String"%go (let: "$a0" := (![#time.Time] (struct.field_ref #timerCtx #"deadline"%go (![#ptrT] "c"))) in
     (func_call #time.Until) "$a0")) #())) + #"])"%go)).

(* go: context.go:670:20 *)
Definition timerCtx__cancelⁱᵐᵖˡ : val :=
  λ: "c" "removeFromParent" "err" "cause",
    exception_do (let: "c" := (mem.alloc "c") in
    let: "cause" := (mem.alloc "cause") in
    let: "err" := (mem.alloc "err") in
    let: "removeFromParent" := (mem.alloc "removeFromParent") in
    do:  (let: "$a0" := #false in
    let: "$a1" := (![#error] "err") in
    let: "$a2" := (![#error] "cause") in
    (method_call #(ptrT.id cancelCtx.id) #"cancel"%go (struct.field_ref #timerCtx #"cancelCtx"%go (![#ptrT] "c"))) "$a0" "$a1" "$a2");;;
    (if: ![#boolT] "removeFromParent"
    then
      do:  (let: "$a0" := (![#Context] (struct.field_ref #cancelCtx #"Context"%go (struct.field_ref #timerCtx #"cancelCtx"%go (![#ptrT] "c")))) in
      let: "$a1" := (interface.make #(ptrT.id timerCtx.id) (![#ptrT] "c")) in
      (func_call #removeChild) "$a0" "$a1")
    else do:  #());;;
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (struct.field_ref #cancelCtx #"mu"%go (struct.field_ref #timerCtx #"cancelCtx"%go (![#ptrT] "c")))) #());;;
    (if: (![#ptrT] (struct.field_ref #timerCtx #"timer"%go (![#ptrT] "c"))) ≠ #null
    then
      do:  ((method_call #(ptrT.id time.Timer.id) #"Stop"%go (![#ptrT] (struct.field_ref #timerCtx #"timer"%go (![#ptrT] "c")))) #());;;
      let: "$r0" := #null in
      do:  ((struct.field_ref #timerCtx #"timer"%go (![#ptrT] "c")) <-[#ptrT] "$r0")
    else do:  #());;;
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (struct.field_ref #cancelCtx #"mu"%go (struct.field_ref #timerCtx #"cancelCtx"%go (![#ptrT] "c")))) #());;;
    return: #()).

Definition WithTimeout : go_string := "context.WithTimeout"%go.

(* WithTimeout returns WithDeadline(parent, time.Now().Add(timeout)).

   Canceling this context releases resources associated with it, so code should
   call cancel as soon as the operations running in this [Context] complete:

   	func slowOperationWithTimeout(ctx context.Context) (Result, error) {
   		ctx, cancel := context.WithTimeout(ctx, 100*time.Millisecond)
   		defer cancel()  // releases resources if slowOperation completes before timeout elapses
   		return slowOperation(ctx)
   	}

   go: context.go:694:6 *)
Definition WithTimeoutⁱᵐᵖˡ : val :=
  λ: "parent" "timeout",
    exception_do (let: "timeout" := (mem.alloc "timeout") in
    let: "parent" := (mem.alloc "parent") in
    let: ("$ret0", "$ret1") := ((let: "$a0" := (![#Context] "parent") in
    let: "$a1" := (let: "$a0" := (![#time.Duration] "timeout") in
    (method_call #time.Time.id #"Add"%go ((func_call #time.Now) #())) "$a0") in
    (func_call #WithDeadline) "$a0" "$a1")) in
    return: ("$ret0", "$ret1")).

Definition WithTimeoutCause : go_string := "context.WithTimeoutCause"%go.

(* WithTimeoutCause behaves like [WithTimeout] but also sets the cause of the
   returned Context when the timeout expires. The returned [CancelFunc] does
   not set the cause.

   go: context.go:701:6 *)
Definition WithTimeoutCauseⁱᵐᵖˡ : val :=
  λ: "parent" "timeout" "cause",
    exception_do (let: "cause" := (mem.alloc "cause") in
    let: "timeout" := (mem.alloc "timeout") in
    let: "parent" := (mem.alloc "parent") in
    let: ("$ret0", "$ret1") := ((let: "$a0" := (![#Context] "parent") in
    let: "$a1" := (let: "$a0" := (![#time.Duration] "timeout") in
    (method_call #time.Time.id #"Add"%go ((func_call #time.Now) #())) "$a0") in
    let: "$a2" := (![#error] "cause") in
    (func_call #WithDeadlineCause) "$a0" "$a1" "$a2")) in
    return: ("$ret0", "$ret1")).

Definition WithValue : go_string := "context.WithValue"%go.

Definition valueCtx : go_type := structT [
  "Context" :: Context;
  "key" :: interfaceT;
  "val" :: interfaceT
].
#[global] Typeclasses Opaque valueCtx.
#[global] Opaque valueCtx.

(* WithValue returns a derived context that points to the parent Context.
   In the derived context, the value associated with key is val.

   Use context Values only for request-scoped data that transits processes and
   APIs, not for passing optional parameters to functions.

   The provided key must be comparable and should not be of type
   string or any other built-in type to avoid collisions between
   packages using context. Users of WithValue should define their own
   types for keys. To avoid allocating when assigning to an
   interface{}, context keys often have concrete type
   struct{}. Alternatively, exported context key variables' static
   type should be a pointer or interface.

   go: context.go:718:6 *)
Definition WithValueⁱᵐᵖˡ : val :=
  λ: "parent" "key" "val",
    exception_do (let: "val" := (mem.alloc "val") in
    let: "key" := (mem.alloc "key") in
    let: "parent" := (mem.alloc "parent") in
    (if: interface.eq (![#Context] "parent") #interface.nil
    then
      do:  (let: "$a0" := (interface.make #stringT.id #"cannot create context from nil parent"%go) in
      Panic "$a0")
    else do:  #());;;
    (if: interface.eq (![#interfaceT] "key") #interface.nil
    then
      do:  (let: "$a0" := (interface.make #stringT.id #"nil key"%go) in
      Panic "$a0")
    else do:  #());;;
    (if: (~ ((interface.get #"Comparable"%go (let: "$a0" := (![#interfaceT] "key") in
    (func_call #reflectlite.TypeOf) "$a0")) #()))
    then
      do:  (let: "$a0" := (interface.make #stringT.id #"key is not comparable"%go) in
      Panic "$a0")
    else do:  #());;;
    return: (interface.make #(ptrT.id valueCtx.id) (mem.alloc (struct.make #valueCtx [{
       "Context" ::= ![#Context] "parent";
       "key" ::= ![#interfaceT] "key";
       "val" ::= ![#interfaceT] "val"
     }])))).

Definition stringify : go_string := "context.stringify"%go.

(* stringify tries a bit to stringify v, without using fmt, since we don't
   want context depending on the unicode tables. This is only used by
   *valueCtx.String().

   go: context.go:741:6 *)
Definition stringifyⁱᵐᵖˡ : val :=
  λ: "v",
    exception_do (let: "v" := (mem.alloc "v") in
    let: "$y" := (![#interfaceT] "v") in
    let: ("$x", "$ok") := (interface.checked_type_assert #stringer "$y" #stringer.id) in
    (if: "$ok"
    then
      let: "s" := (mem.alloc "$x") in
      return: ((interface.get #"String"%go (![#stringer] "s")) #())
    else
      let: ("$x", "$ok") := (interface.checked_type_assert #stringT "$y" #stringT.id) in
      (if: "$ok"
      then
        let: "s" := (mem.alloc "$x") in
        return: (![#stringT] "s")
      else
        let: "$ok" := (interface.eq "$y" #interface.nil) in
        let: "$x" := "$y" in
        (if: "$ok"
        then
          let: "s" := (mem.alloc "$x") in
          return: (#"<nil>"%go)
        else do:  #())));;;
    return: ((interface.get #"String"%go (let: "$a0" := (![#interfaceT] "v") in
     (func_call #reflectlite.TypeOf) "$a0")) #())).

(* go: context.go:753:20 *)
Definition valueCtx__Stringⁱᵐᵖˡ : val :=
  λ: "c" <>,
    exception_do (let: "c" := (mem.alloc "c") in
    return: ((((((let: "$a0" := (![#Context] (struct.field_ref #valueCtx #"Context"%go (![#ptrT] "c"))) in
     (func_call #contextName) "$a0") + #".WithValue("%go) + (let: "$a0" := (![#interfaceT] (struct.field_ref #valueCtx #"key"%go (![#ptrT] "c"))) in
     (func_call #stringify) "$a0")) + #", "%go) + (let: "$a0" := (![#interfaceT] (struct.field_ref #valueCtx #"val"%go (![#ptrT] "c"))) in
     (func_call #stringify) "$a0")) + #")"%go)).

(* go: context.go:759:20 *)
Definition valueCtx__Valueⁱᵐᵖˡ : val :=
  λ: "c" "key",
    exception_do (let: "c" := (mem.alloc "c") in
    let: "key" := (mem.alloc "key") in
    (if: interface.eq (![#interfaceT] (struct.field_ref #valueCtx #"key"%go (![#ptrT] "c"))) (![#interfaceT] "key")
    then return: (![#interfaceT] (struct.field_ref #valueCtx #"val"%go (![#ptrT] "c")))
    else do:  #());;;
    return: (let: "$a0" := (![#Context] (struct.field_ref #valueCtx #"Context"%go (![#ptrT] "c"))) in
     let: "$a1" := (![#interfaceT] "key") in
     (func_call #value) "$a0" "$a1")).

(* go: context.go:766:6 *)
Definition valueⁱᵐᵖˡ : val :=
  λ: "c" "key",
    exception_do (let: "key" := (mem.alloc "key") in
    let: "c" := (mem.alloc "c") in
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "$y" := (![#Context] "c") in
      let: ("$x", "$ok") := (interface.checked_type_assert #ptrT "$y" #(ptrT.id valueCtx.id)) in
      (if: "$ok"
      then
        let: "ctx" := (mem.alloc "$x") in
        (if: interface.eq (![#interfaceT] "key") (![#interfaceT] (struct.field_ref #valueCtx #"key"%go (![#ptrT] "ctx")))
        then return: (![#interfaceT] (struct.field_ref #valueCtx #"val"%go (![#ptrT] "ctx")))
        else do:  #());;;
        let: "$r0" := (![#Context] (struct.field_ref #valueCtx #"Context"%go (![#ptrT] "ctx"))) in
        do:  ("c" <-[#Context] "$r0")
      else
        let: ("$x", "$ok") := (interface.checked_type_assert #ptrT "$y" #(ptrT.id cancelCtx.id)) in
        (if: "$ok"
        then
          let: "ctx" := (mem.alloc "$x") in
          (if: interface.eq (![#interfaceT] "key") (interface.make #(ptrT.id intT.id) (globals.get #cancelCtxKey))
          then return: (![#Context] "c")
          else do:  #());;;
          let: "$r0" := (![#Context] (struct.field_ref #cancelCtx #"Context"%go (![#ptrT] "ctx"))) in
          do:  ("c" <-[#Context] "$r0")
        else
          let: ("$x", "$ok") := (interface.checked_type_assert #withoutCancelCtx "$y" #withoutCancelCtx.id) in
          (if: "$ok"
          then
            let: "ctx" := (mem.alloc "$x") in
            (if: interface.eq (![#interfaceT] "key") (interface.make #(ptrT.id intT.id) (globals.get #cancelCtxKey))
            then return: (#interface.nil)
            else do:  #());;;
            let: "$r0" := (![#Context] (struct.field_ref #withoutCancelCtx #"c"%go "ctx")) in
            do:  ("c" <-[#Context] "$r0")
          else
            let: ("$x", "$ok") := (interface.checked_type_assert #ptrT "$y" #(ptrT.id timerCtx.id)) in
            (if: "$ok"
            then
              let: "ctx" := (mem.alloc "$x") in
              (if: interface.eq (![#interfaceT] "key") (interface.make #(ptrT.id intT.id) (globals.get #cancelCtxKey))
              then return: (interface.make #(ptrT.id cancelCtx.id) (struct.field_ref #timerCtx #"cancelCtx"%go (![#ptrT] "ctx")))
              else do:  #());;;
              let: "$r0" := (![#Context] (struct.field_ref #cancelCtx #"Context"%go (struct.field_ref #timerCtx #"cancelCtx"%go (![#ptrT] "ctx")))) in
              do:  ("c" <-[#Context] "$r0")
            else
              let: "$ok" := ((Snd (interface.checked_type_assert #backgroundCtx "$y" #backgroundCtx.id)) || (Snd (interface.checked_type_assert #backgroundCtx "$y" #backgroundCtx.id))) in
              let: "$x" := "$y" in
              (if: "$ok"
              then
                let: "ctx" := (mem.alloc "$x") in
                return: (#interface.nil)
              else
                return: (let: "$a0" := (![#interfaceT] "key") in
                 (interface.get #"Value"%go (![#Context] "c")) "$a0")))))))).

Definition vars' : list (go_string * go_type) := [(Canceled, error); (DeadlineExceeded, error); (goroutines, atomic.Int32); (cancelCtxKey, intT); (closedchan, chanT (structT [
             ]))].

Definition functions' : list (go_string * val) := [(Background, Backgroundⁱᵐᵖˡ); (TODO, TODOⁱᵐᵖˡ); (WithCancel, WithCancelⁱᵐᵖˡ); (WithCancelCause, WithCancelCauseⁱᵐᵖˡ); (withCancel, withCancelⁱᵐᵖˡ); (Cause, Causeⁱᵐᵖˡ); (AfterFunc, AfterFuncⁱᵐᵖˡ); (parentCancelCtx, parentCancelCtxⁱᵐᵖˡ); (removeChild, removeChildⁱᵐᵖˡ); (contextName, contextNameⁱᵐᵖˡ); (WithoutCancel, WithoutCancelⁱᵐᵖˡ); (WithDeadline, WithDeadlineⁱᵐᵖˡ); (WithDeadlineCause, WithDeadlineCauseⁱᵐᵖˡ); (WithTimeout, WithTimeoutⁱᵐᵖˡ); (WithTimeoutCause, WithTimeoutCauseⁱᵐᵖˡ); (WithValue, WithValueⁱᵐᵖˡ); (stringify, stringifyⁱᵐᵖˡ); (value, valueⁱᵐᵖˡ)].

Definition msets' : list (go_string * (list (go_string * val))) := [(deadlineExceededError.id, [("Error"%go, deadlineExceededError__Errorⁱᵐᵖˡ); ("Temporary"%go, deadlineExceededError__Temporaryⁱᵐᵖˡ); ("Timeout"%go, deadlineExceededError__Timeoutⁱᵐᵖˡ)]); (ptrT.id deadlineExceededError.id, [("Error"%go, (λ: "$r",
                 method_call #deadlineExceededError.id #"Error"%go (![#deadlineExceededError] "$r")
                 )%V); ("Temporary"%go, (λ: "$r",
                 method_call #deadlineExceededError.id #"Temporary"%go (![#deadlineExceededError] "$r")
                 )%V); ("Timeout"%go, (λ: "$r",
                 method_call #deadlineExceededError.id #"Timeout"%go (![#deadlineExceededError] "$r")
                 )%V)]); (emptyCtx.id, [("Deadline"%go, emptyCtx__Deadlineⁱᵐᵖˡ); ("Done"%go, emptyCtx__Doneⁱᵐᵖˡ); ("Err"%go, emptyCtx__Errⁱᵐᵖˡ); ("Value"%go, emptyCtx__Valueⁱᵐᵖˡ)]); (ptrT.id emptyCtx.id, [("Deadline"%go, (λ: "$r",
                 method_call #emptyCtx.id #"Deadline"%go (![#emptyCtx] "$r")
                 )%V); ("Done"%go, (λ: "$r",
                 method_call #emptyCtx.id #"Done"%go (![#emptyCtx] "$r")
                 )%V); ("Err"%go, (λ: "$r",
                 method_call #emptyCtx.id #"Err"%go (![#emptyCtx] "$r")
                 )%V); ("Value"%go, (λ: "$r",
                 method_call #emptyCtx.id #"Value"%go (![#emptyCtx] "$r")
                 )%V)]); (backgroundCtx.id, [("Deadline"%go, (λ: "$r",
                 method_call #emptyCtx.id #"Deadline"%go (struct.field_get #backgroundCtx #"emptyCtx"%go "$r")
                 )%V); ("Done"%go, (λ: "$r",
                 method_call #emptyCtx.id #"Done"%go (struct.field_get #backgroundCtx #"emptyCtx"%go "$r")
                 )%V); ("Err"%go, (λ: "$r",
                 method_call #emptyCtx.id #"Err"%go (struct.field_get #backgroundCtx #"emptyCtx"%go "$r")
                 )%V); ("String"%go, backgroundCtx__Stringⁱᵐᵖˡ); ("Value"%go, (λ: "$r",
                 method_call #emptyCtx.id #"Value"%go (struct.field_get #backgroundCtx #"emptyCtx"%go "$r")
                 )%V)]); (ptrT.id backgroundCtx.id, [("Deadline"%go, (λ: "$r",
                 method_call #(ptrT.id emptyCtx.id) #"Deadline"%go (struct.field_ref #backgroundCtx #"emptyCtx"%go "$r")
                 )%V); ("Done"%go, (λ: "$r",
                 method_call #(ptrT.id emptyCtx.id) #"Done"%go (struct.field_ref #backgroundCtx #"emptyCtx"%go "$r")
                 )%V); ("Err"%go, (λ: "$r",
                 method_call #(ptrT.id emptyCtx.id) #"Err"%go (struct.field_ref #backgroundCtx #"emptyCtx"%go "$r")
                 )%V); ("String"%go, (λ: "$r",
                 method_call #backgroundCtx.id #"String"%go (![#backgroundCtx] "$r")
                 )%V); ("Value"%go, (λ: "$r",
                 method_call #(ptrT.id emptyCtx.id) #"Value"%go (struct.field_ref #backgroundCtx #"emptyCtx"%go "$r")
                 )%V)]); (todoCtx.id, [("Deadline"%go, (λ: "$r",
                 method_call #emptyCtx.id #"Deadline"%go (struct.field_get #todoCtx #"emptyCtx"%go "$r")
                 )%V); ("Done"%go, (λ: "$r",
                 method_call #emptyCtx.id #"Done"%go (struct.field_get #todoCtx #"emptyCtx"%go "$r")
                 )%V); ("Err"%go, (λ: "$r",
                 method_call #emptyCtx.id #"Err"%go (struct.field_get #todoCtx #"emptyCtx"%go "$r")
                 )%V); ("String"%go, todoCtx__Stringⁱᵐᵖˡ); ("Value"%go, (λ: "$r",
                 method_call #emptyCtx.id #"Value"%go (struct.field_get #todoCtx #"emptyCtx"%go "$r")
                 )%V)]); (ptrT.id todoCtx.id, [("Deadline"%go, (λ: "$r",
                 method_call #(ptrT.id emptyCtx.id) #"Deadline"%go (struct.field_ref #todoCtx #"emptyCtx"%go "$r")
                 )%V); ("Done"%go, (λ: "$r",
                 method_call #(ptrT.id emptyCtx.id) #"Done"%go (struct.field_ref #todoCtx #"emptyCtx"%go "$r")
                 )%V); ("Err"%go, (λ: "$r",
                 method_call #(ptrT.id emptyCtx.id) #"Err"%go (struct.field_ref #todoCtx #"emptyCtx"%go "$r")
                 )%V); ("String"%go, (λ: "$r",
                 method_call #todoCtx.id #"String"%go (![#todoCtx] "$r")
                 )%V); ("Value"%go, (λ: "$r",
                 method_call #(ptrT.id emptyCtx.id) #"Value"%go (struct.field_ref #todoCtx #"emptyCtx"%go "$r")
                 )%V)]); (CancelFunc.id, []); (ptrT.id CancelFunc.id, []); (CancelCauseFunc.id, []); (ptrT.id CancelCauseFunc.id, []); (afterFuncCtx.id, [("Deadline"%go, (λ: "$r",
                 method_call #cancelCtx.id #"Deadline"%go (struct.field_get #afterFuncCtx #"cancelCtx"%go "$r")
                 )%V)]); (ptrT.id afterFuncCtx.id, [("Deadline"%go, (λ: "$r",
                 method_call #(ptrT.id cancelCtx.id) #"Deadline"%go (struct.field_ref #afterFuncCtx #"cancelCtx"%go "$r")
                 )%V); ("Done"%go, (λ: "$r",
                 method_call #(ptrT.id cancelCtx.id) #"Done"%go (struct.field_ref #afterFuncCtx #"cancelCtx"%go "$r")
                 )%V); ("Err"%go, (λ: "$r",
                 method_call #(ptrT.id cancelCtx.id) #"Err"%go (struct.field_ref #afterFuncCtx #"cancelCtx"%go "$r")
                 )%V); ("String"%go, (λ: "$r",
                 method_call #(ptrT.id cancelCtx.id) #"String"%go (struct.field_ref #afterFuncCtx #"cancelCtx"%go "$r")
                 )%V); ("Value"%go, (λ: "$r",
                 method_call #(ptrT.id cancelCtx.id) #"Value"%go (struct.field_ref #afterFuncCtx #"cancelCtx"%go "$r")
                 )%V); ("cancel"%go, afterFuncCtx__cancelⁱᵐᵖˡ); ("propagateCancel"%go, (λ: "$r",
                 method_call #(ptrT.id cancelCtx.id) #"propagateCancel"%go (struct.field_ref #afterFuncCtx #"cancelCtx"%go "$r")
                 )%V)]); (stopCtx.id, [("Deadline"%go, (λ: "$r",
                 method_call #Context.id #"Deadline"%go (struct.field_get #stopCtx #"Context"%go "$r")
                 )%V); ("Done"%go, (λ: "$r",
                 method_call #Context.id #"Done"%go (struct.field_get #stopCtx #"Context"%go "$r")
                 )%V); ("Err"%go, (λ: "$r",
                 method_call #Context.id #"Err"%go (struct.field_get #stopCtx #"Context"%go "$r")
                 )%V); ("Value"%go, (λ: "$r",
                 method_call #Context.id #"Value"%go (struct.field_get #stopCtx #"Context"%go "$r")
                 )%V)]); (ptrT.id stopCtx.id, [("Deadline"%go, (λ: "$r",
                 method_call #(ptrT.id Context.id) #"Deadline"%go (struct.field_ref #stopCtx #"Context"%go "$r")
                 )%V); ("Done"%go, (λ: "$r",
                 method_call #(ptrT.id Context.id) #"Done"%go (struct.field_ref #stopCtx #"Context"%go "$r")
                 )%V); ("Err"%go, (λ: "$r",
                 method_call #(ptrT.id Context.id) #"Err"%go (struct.field_ref #stopCtx #"Context"%go "$r")
                 )%V); ("Value"%go, (λ: "$r",
                 method_call #(ptrT.id Context.id) #"Value"%go (struct.field_ref #stopCtx #"Context"%go "$r")
                 )%V)]); (cancelCtx.id, [("Deadline"%go, (λ: "$r",
                 method_call #Context.id #"Deadline"%go (struct.field_get #cancelCtx #"Context"%go "$r")
                 )%V)]); (ptrT.id cancelCtx.id, [("Deadline"%go, (λ: "$r",
                 method_call #(ptrT.id Context.id) #"Deadline"%go (struct.field_ref #cancelCtx #"Context"%go "$r")
                 )%V); ("Done"%go, cancelCtx__Doneⁱᵐᵖˡ); ("Err"%go, cancelCtx__Errⁱᵐᵖˡ); ("String"%go, cancelCtx__Stringⁱᵐᵖˡ); ("Value"%go, cancelCtx__Valueⁱᵐᵖˡ); ("cancel"%go, cancelCtx__cancelⁱᵐᵖˡ); ("propagateCancel"%go, cancelCtx__propagateCancelⁱᵐᵖˡ)]); (withoutCancelCtx.id, [("Deadline"%go, withoutCancelCtx__Deadlineⁱᵐᵖˡ); ("Done"%go, withoutCancelCtx__Doneⁱᵐᵖˡ); ("Err"%go, withoutCancelCtx__Errⁱᵐᵖˡ); ("String"%go, withoutCancelCtx__Stringⁱᵐᵖˡ); ("Value"%go, withoutCancelCtx__Valueⁱᵐᵖˡ)]); (ptrT.id withoutCancelCtx.id, [("Deadline"%go, (λ: "$r",
                 method_call #withoutCancelCtx.id #"Deadline"%go (![#withoutCancelCtx] "$r")
                 )%V); ("Done"%go, (λ: "$r",
                 method_call #withoutCancelCtx.id #"Done"%go (![#withoutCancelCtx] "$r")
                 )%V); ("Err"%go, (λ: "$r",
                 method_call #withoutCancelCtx.id #"Err"%go (![#withoutCancelCtx] "$r")
                 )%V); ("String"%go, (λ: "$r",
                 method_call #withoutCancelCtx.id #"String"%go (![#withoutCancelCtx] "$r")
                 )%V); ("Value"%go, (λ: "$r",
                 method_call #withoutCancelCtx.id #"Value"%go (![#withoutCancelCtx] "$r")
                 )%V)]); (timerCtx.id, []); (ptrT.id timerCtx.id, [("Deadline"%go, timerCtx__Deadlineⁱᵐᵖˡ); ("Done"%go, (λ: "$r",
                 method_call #(ptrT.id cancelCtx.id) #"Done"%go (struct.field_ref #timerCtx #"cancelCtx"%go "$r")
                 )%V); ("Err"%go, (λ: "$r",
                 method_call #(ptrT.id cancelCtx.id) #"Err"%go (struct.field_ref #timerCtx #"cancelCtx"%go "$r")
                 )%V); ("String"%go, timerCtx__Stringⁱᵐᵖˡ); ("Value"%go, (λ: "$r",
                 method_call #(ptrT.id cancelCtx.id) #"Value"%go (struct.field_ref #timerCtx #"cancelCtx"%go "$r")
                 )%V); ("cancel"%go, timerCtx__cancelⁱᵐᵖˡ); ("propagateCancel"%go, (λ: "$r",
                 method_call #(ptrT.id cancelCtx.id) #"propagateCancel"%go (struct.field_ref #timerCtx #"cancelCtx"%go "$r")
                 )%V)]); (valueCtx.id, [("Deadline"%go, (λ: "$r",
                 method_call #Context.id #"Deadline"%go (struct.field_get #valueCtx #"Context"%go "$r")
                 )%V); ("Done"%go, (λ: "$r",
                 method_call #Context.id #"Done"%go (struct.field_get #valueCtx #"Context"%go "$r")
                 )%V); ("Err"%go, (λ: "$r",
                 method_call #Context.id #"Err"%go (struct.field_get #valueCtx #"Context"%go "$r")
                 )%V)]); (ptrT.id valueCtx.id, [("Deadline"%go, (λ: "$r",
                 method_call #(ptrT.id Context.id) #"Deadline"%go (struct.field_ref #valueCtx #"Context"%go "$r")
                 )%V); ("Done"%go, (λ: "$r",
                 method_call #(ptrT.id Context.id) #"Done"%go (struct.field_ref #valueCtx #"Context"%go "$r")
                 )%V); ("Err"%go, (λ: "$r",
                 method_call #(ptrT.id Context.id) #"Err"%go (struct.field_ref #valueCtx #"Context"%go "$r")
                 )%V); ("String"%go, valueCtx__Stringⁱᵐᵖˡ); ("Value"%go, valueCtx__Valueⁱᵐᵖˡ)])].

#[global] Instance info' : PkgInfo context.context :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [code.errors.errors; code.internal.reflectlite.reflectlite; code.sync.sync; code.sync.atomic.atomic; code.time.time];
  |}.

Definition initialize' : val :=
  λ: <>,
    package.init #context.context (λ: <>,
      exception_do (do:  (time.initialize' #());;;
      do:  (atomic.initialize' #());;;
      do:  (sync.initialize' #());;;
      do:  (reflectlite.initialize' #());;;
      do:  (errors.initialize' #());;;
      do:  (package.alloc context.context #());;;
      let: "$r0" := (let: "$a0" := #"context canceled"%go in
      (func_call #errors.New) "$a0") in
      do:  ((globals.get #Canceled) <-[#error] "$r0");;;
      let: "$r0" := (interface.make #deadlineExceededError.id (struct.make #deadlineExceededError [{
      }])) in
      do:  ((globals.get #DeadlineExceeded) <-[#error] "$r0");;;
      let: "$r0" := (chan.make (type.structT [
      ]) #(W64 0)) in
      do:  ((globals.get #closedchan) <-[type.chanT (type.structT [
      ])] "$r0");;;
      do:  ((λ: <>,
        exception_do (do:  (let: "$a0" := (![type.chanT (type.structT [
        ])] (globals.get #closedchan)) in
        chan.close "$a0");;;
        return: #())
        ) #()))
      ).

End code.
End context.
