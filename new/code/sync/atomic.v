(* autogenerated from sync/atomic *)

From New.golang Require Import defn.
Require Export New.trusted_code.sync.atomic.
Import atomic.
Definition atomic : go_string := "sync/atomic".

Module atomic.

Section code.
Context `{ffi_syntax}.


Definition SwapInt32 : go_string := "sync/atomic.SwapInt32"%go.

Definition SwapUint32 : go_string := "sync/atomic.SwapUint32"%go.

Definition SwapUintptr : go_string := "sync/atomic.SwapUintptr"%go.

Definition SwapPointer : go_string := "sync/atomic.SwapPointer"%go.

Definition CompareAndSwapInt32 : go_string := "sync/atomic.CompareAndSwapInt32"%go.

Definition CompareAndSwapUint32 : go_string := "sync/atomic.CompareAndSwapUint32"%go.

Definition CompareAndSwapUintptr : go_string := "sync/atomic.CompareAndSwapUintptr"%go.

Definition CompareAndSwapPointer : go_string := "sync/atomic.CompareAndSwapPointer"%go.

Definition AddInt32 : go_string := "sync/atomic.AddInt32"%go.

Definition AddUint32 : go_string := "sync/atomic.AddUint32"%go.

Definition AddUintptr : go_string := "sync/atomic.AddUintptr"%go.

Definition AndInt32 : go_string := "sync/atomic.AndInt32"%go.

Definition AndUint32 : go_string := "sync/atomic.AndUint32"%go.

Definition AndUintptr : go_string := "sync/atomic.AndUintptr"%go.

Definition OrInt32 : go_string := "sync/atomic.OrInt32"%go.

Definition OrUint32 : go_string := "sync/atomic.OrUint32"%go.

Definition OrUintptr : go_string := "sync/atomic.OrUintptr"%go.

Definition LoadInt32 : go_string := "sync/atomic.LoadInt32"%go.

Definition LoadUint32 : go_string := "sync/atomic.LoadUint32"%go.

Definition LoadUintptr : go_string := "sync/atomic.LoadUintptr"%go.

Definition LoadPointer : go_string := "sync/atomic.LoadPointer"%go.

Definition StoreInt32 : go_string := "sync/atomic.StoreInt32"%go.

Definition StoreUint32 : go_string := "sync/atomic.StoreUint32"%go.

Definition StoreUintptr : go_string := "sync/atomic.StoreUintptr"%go.

Definition StorePointer : go_string := "sync/atomic.StorePointer"%go.

Definition SwapInt64 : go_string := "sync/atomic.SwapInt64"%go.

Definition SwapUint64 : go_string := "sync/atomic.SwapUint64"%go.

Definition CompareAndSwapInt64 : go_string := "sync/atomic.CompareAndSwapInt64"%go.

Definition CompareAndSwapUint64 : go_string := "sync/atomic.CompareAndSwapUint64"%go.

Definition AddInt64 : go_string := "sync/atomic.AddInt64"%go.

Definition AddUint64 : go_string := "sync/atomic.AddUint64"%go.

Definition AndInt64 : go_string := "sync/atomic.AndInt64"%go.

Definition AndUint64 : go_string := "sync/atomic.AndUint64"%go.

Definition OrInt64 : go_string := "sync/atomic.OrInt64"%go.

Definition OrUint64 : go_string := "sync/atomic.OrUint64"%go.

Definition LoadInt64 : go_string := "sync/atomic.LoadInt64"%go.

Definition LoadUint64 : go_string := "sync/atomic.LoadUint64"%go.

Definition StoreInt64 : go_string := "sync/atomic.StoreInt64"%go.

Definition StoreUint64 : go_string := "sync/atomic.StoreUint64"%go.

Definition noCopy : go.type := go.Named "sync/atomic.noCopy"%go [].

Definition Boolⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "_0"%go noCopy);
  (go.FieldDecl "v"%go go.uint32)
].

Definition Bool : go.type := go.Named "sync/atomic.Bool"%go [].

(* Load atomically loads and returns the value stored in x.

   go: type.go:19:16 *)
Definition Bool__Loadⁱᵐᵖˡ : val :=
  λ: "x" <>,
    exception_do (let: "x" := (go.AllocValue (go.PointerType Bool) "x") in
    return: ((let: "$a0" := (StructFieldRef Bool "v"%go (![go.PointerType Bool] "x")) in
     (FuncResolve LoadUint32 [] #()) "$a0") ≠⟨go.uint32⟩ #(W32 0))).

Definition b32 : go_string := "sync/atomic.b32"%go.

(* Store atomically stores val into x.

   go: type.go:22:16 *)
Definition Bool__Storeⁱᵐᵖˡ : val :=
  λ: "x" "val",
    exception_do (let: "x" := (go.AllocValue (go.PointerType Bool) "x") in
    let: "val" := (go.AllocValue go.bool "val") in
    do:  (let: "$a0" := (StructFieldRef Bool "v"%go (![go.PointerType Bool] "x")) in
    let: "$a1" := (let: "$a0" := (![go.bool] "val") in
    (FuncResolve b32 [] #()) "$a0") in
    (FuncResolve StoreUint32 [] #()) "$a0" "$a1");;;
    return: #()).

(* Swap atomically stores new into x and returns the previous value.

   go: type.go:25:16 *)
Definition Bool__Swapⁱᵐᵖˡ : val :=
  λ: "x" "new",
    exception_do (let: "old" := (GoAlloc go.bool #()) in
    let: "x" := (go.AllocValue (go.PointerType Bool) "x") in
    let: "new" := (go.AllocValue go.bool "new") in
    return: ((let: "$a0" := (StructFieldRef Bool "v"%go (![go.PointerType Bool] "x")) in
     let: "$a1" := (let: "$a0" := (![go.bool] "new") in
     (FuncResolve b32 [] #()) "$a0") in
     (FuncResolve SwapUint32 [] #()) "$a0" "$a1") ≠⟨go.uint32⟩ #(W32 0))).

(* CompareAndSwap executes the compare-and-swap operation for the boolean value x.

   go: type.go:28:16 *)
Definition Bool__CompareAndSwapⁱᵐᵖˡ : val :=
  λ: "x" "old" "new",
    exception_do (let: "swapped" := (GoAlloc go.bool #()) in
    let: "x" := (go.AllocValue (go.PointerType Bool) "x") in
    let: "new" := (go.AllocValue go.bool "new") in
    let: "old" := (go.AllocValue go.bool "old") in
    return: (let: "$a0" := (StructFieldRef Bool "v"%go (![go.PointerType Bool] "x")) in
     let: "$a1" := (let: "$a0" := (![go.bool] "old") in
     (FuncResolve b32 [] #()) "$a0") in
     let: "$a2" := (let: "$a0" := (![go.bool] "new") in
     (FuncResolve b32 [] #()) "$a0") in
     (FuncResolve CompareAndSwapUint32 [] #()) "$a0" "$a1" "$a2")).

(* b32 returns a uint32 0 or 1 representing b.

   go: type.go:33:6 *)
Definition b32ⁱᵐᵖˡ : val :=
  λ: "b",
    exception_do (let: "b" := (go.AllocValue go.bool "b") in
    (if: ![go.bool] "b"
    then return: (#(W32 1))
    else do:  #());;;
    return: (#(W32 0))).

Definition Pointerⁱᵐᵖˡ(T : go.type)  : go.type := go.StructType [
  (go.FieldDecl "_0"%go (go.ArrayType 0 (go.PointerType T)));
  (go.FieldDecl "_1"%go noCopy);
  (go.FieldDecl "v"%go unsafe.Pointer)
].

Definition Int32ⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "_0"%go noCopy);
  (go.FieldDecl "v"%go go.int32)
].

Definition Int32 : go.type := go.Named "sync/atomic.Int32"%go [].

(* Load atomically loads and returns the value stored in x.

   go: type.go:80:17 *)
Definition Int32__Loadⁱᵐᵖˡ : val :=
  λ: "x" <>,
    exception_do (let: "x" := (go.AllocValue (go.PointerType Int32) "x") in
    return: (let: "$a0" := (StructFieldRef Int32 "v"%go (![go.PointerType Int32] "x")) in
     (FuncResolve LoadInt32 [] #()) "$a0")).

(* Store atomically stores val into x.

   go: type.go:83:17 *)
Definition Int32__Storeⁱᵐᵖˡ : val :=
  λ: "x" "val",
    exception_do (let: "x" := (go.AllocValue (go.PointerType Int32) "x") in
    let: "val" := (go.AllocValue go.int32 "val") in
    do:  (let: "$a0" := (StructFieldRef Int32 "v"%go (![go.PointerType Int32] "x")) in
    let: "$a1" := (![go.int32] "val") in
    (FuncResolve StoreInt32 [] #()) "$a0" "$a1");;;
    return: #()).

(* Swap atomically stores new into x and returns the previous value.

   go: type.go:86:17 *)
Definition Int32__Swapⁱᵐᵖˡ : val :=
  λ: "x" "new",
    exception_do (let: "old" := (GoAlloc go.int32 #()) in
    let: "x" := (go.AllocValue (go.PointerType Int32) "x") in
    let: "new" := (go.AllocValue go.int32 "new") in
    return: (let: "$a0" := (StructFieldRef Int32 "v"%go (![go.PointerType Int32] "x")) in
     let: "$a1" := (![go.int32] "new") in
     (FuncResolve SwapInt32 [] #()) "$a0" "$a1")).

(* CompareAndSwap executes the compare-and-swap operation for x.

   go: type.go:89:17 *)
Definition Int32__CompareAndSwapⁱᵐᵖˡ : val :=
  λ: "x" "old" "new",
    exception_do (let: "swapped" := (GoAlloc go.bool #()) in
    let: "x" := (go.AllocValue (go.PointerType Int32) "x") in
    let: "new" := (go.AllocValue go.int32 "new") in
    let: "old" := (go.AllocValue go.int32 "old") in
    return: (let: "$a0" := (StructFieldRef Int32 "v"%go (![go.PointerType Int32] "x")) in
     let: "$a1" := (![go.int32] "old") in
     let: "$a2" := (![go.int32] "new") in
     (FuncResolve CompareAndSwapInt32 [] #()) "$a0" "$a1" "$a2")).

(* Add atomically adds delta to x and returns the new value.

   go: type.go:94:17 *)
Definition Int32__Addⁱᵐᵖˡ : val :=
  λ: "x" "delta",
    exception_do (let: "new" := (GoAlloc go.int32 #()) in
    let: "x" := (go.AllocValue (go.PointerType Int32) "x") in
    let: "delta" := (go.AllocValue go.int32 "delta") in
    return: (let: "$a0" := (StructFieldRef Int32 "v"%go (![go.PointerType Int32] "x")) in
     let: "$a1" := (![go.int32] "delta") in
     (FuncResolve AddInt32 [] #()) "$a0" "$a1")).

(* And atomically performs a bitwise AND operation on x using the bitmask
   provided as mask and returns the old value.

   go: type.go:98:17 *)
Definition Int32__Andⁱᵐᵖˡ : val :=
  λ: "x" "mask",
    exception_do (let: "old" := (GoAlloc go.int32 #()) in
    let: "x" := (go.AllocValue (go.PointerType Int32) "x") in
    let: "mask" := (go.AllocValue go.int32 "mask") in
    return: (let: "$a0" := (StructFieldRef Int32 "v"%go (![go.PointerType Int32] "x")) in
     let: "$a1" := (![go.int32] "mask") in
     (FuncResolve AndInt32 [] #()) "$a0" "$a1")).

(* Or atomically performs a bitwise OR operation on x using the bitmask
   provided as mask and returns the old value.

   go: type.go:102:17 *)
Definition Int32__Orⁱᵐᵖˡ : val :=
  λ: "x" "mask",
    exception_do (let: "old" := (GoAlloc go.int32 #()) in
    let: "x" := (go.AllocValue (go.PointerType Int32) "x") in
    let: "mask" := (go.AllocValue go.int32 "mask") in
    return: (let: "$a0" := (StructFieldRef Int32 "v"%go (![go.PointerType Int32] "x")) in
     let: "$a1" := (![go.int32] "mask") in
     (FuncResolve OrInt32 [] #()) "$a0" "$a1")).

Definition align64 : go.type := go.Named "sync/atomic.align64"%go [].

Definition Int64ⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "_0"%go noCopy);
  (go.FieldDecl "_1"%go align64);
  (go.FieldDecl "v"%go go.int64)
].

Definition Int64 : go.type := go.Named "sync/atomic.Int64"%go [].

(* Load atomically loads and returns the value stored in x.

   go: type.go:114:17 *)
Definition Int64__Loadⁱᵐᵖˡ : val :=
  λ: "x" <>,
    exception_do (let: "x" := (go.AllocValue (go.PointerType Int64) "x") in
    return: (let: "$a0" := (StructFieldRef Int64 "v"%go (![go.PointerType Int64] "x")) in
     (FuncResolve LoadInt64 [] #()) "$a0")).

(* Store atomically stores val into x.

   go: type.go:117:17 *)
Definition Int64__Storeⁱᵐᵖˡ : val :=
  λ: "x" "val",
    exception_do (let: "x" := (go.AllocValue (go.PointerType Int64) "x") in
    let: "val" := (go.AllocValue go.int64 "val") in
    do:  (let: "$a0" := (StructFieldRef Int64 "v"%go (![go.PointerType Int64] "x")) in
    let: "$a1" := (![go.int64] "val") in
    (FuncResolve StoreInt64 [] #()) "$a0" "$a1");;;
    return: #()).

(* Swap atomically stores new into x and returns the previous value.

   go: type.go:120:17 *)
Definition Int64__Swapⁱᵐᵖˡ : val :=
  λ: "x" "new",
    exception_do (let: "old" := (GoAlloc go.int64 #()) in
    let: "x" := (go.AllocValue (go.PointerType Int64) "x") in
    let: "new" := (go.AllocValue go.int64 "new") in
    return: (let: "$a0" := (StructFieldRef Int64 "v"%go (![go.PointerType Int64] "x")) in
     let: "$a1" := (![go.int64] "new") in
     (FuncResolve SwapInt64 [] #()) "$a0" "$a1")).

(* CompareAndSwap executes the compare-and-swap operation for x.

   go: type.go:123:17 *)
Definition Int64__CompareAndSwapⁱᵐᵖˡ : val :=
  λ: "x" "old" "new",
    exception_do (let: "swapped" := (GoAlloc go.bool #()) in
    let: "x" := (go.AllocValue (go.PointerType Int64) "x") in
    let: "new" := (go.AllocValue go.int64 "new") in
    let: "old" := (go.AllocValue go.int64 "old") in
    return: (let: "$a0" := (StructFieldRef Int64 "v"%go (![go.PointerType Int64] "x")) in
     let: "$a1" := (![go.int64] "old") in
     let: "$a2" := (![go.int64] "new") in
     (FuncResolve CompareAndSwapInt64 [] #()) "$a0" "$a1" "$a2")).

(* Add atomically adds delta to x and returns the new value.

   go: type.go:128:17 *)
Definition Int64__Addⁱᵐᵖˡ : val :=
  λ: "x" "delta",
    exception_do (let: "new" := (GoAlloc go.int64 #()) in
    let: "x" := (go.AllocValue (go.PointerType Int64) "x") in
    let: "delta" := (go.AllocValue go.int64 "delta") in
    return: (let: "$a0" := (StructFieldRef Int64 "v"%go (![go.PointerType Int64] "x")) in
     let: "$a1" := (![go.int64] "delta") in
     (FuncResolve AddInt64 [] #()) "$a0" "$a1")).

(* And atomically performs a bitwise AND operation on x using the bitmask
   provided as mask and returns the old value.

   go: type.go:132:17 *)
Definition Int64__Andⁱᵐᵖˡ : val :=
  λ: "x" "mask",
    exception_do (let: "old" := (GoAlloc go.int64 #()) in
    let: "x" := (go.AllocValue (go.PointerType Int64) "x") in
    let: "mask" := (go.AllocValue go.int64 "mask") in
    return: (let: "$a0" := (StructFieldRef Int64 "v"%go (![go.PointerType Int64] "x")) in
     let: "$a1" := (![go.int64] "mask") in
     (FuncResolve AndInt64 [] #()) "$a0" "$a1")).

(* Or atomically performs a bitwise OR operation on x using the bitmask
   provided as mask and returns the old value.

   go: type.go:136:17 *)
Definition Int64__Orⁱᵐᵖˡ : val :=
  λ: "x" "mask",
    exception_do (let: "old" := (GoAlloc go.int64 #()) in
    let: "x" := (go.AllocValue (go.PointerType Int64) "x") in
    let: "mask" := (go.AllocValue go.int64 "mask") in
    return: (let: "$a0" := (StructFieldRef Int64 "v"%go (![go.PointerType Int64] "x")) in
     let: "$a1" := (![go.int64] "mask") in
     (FuncResolve OrInt64 [] #()) "$a0" "$a1")).

Definition Uint32ⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "_0"%go noCopy);
  (go.FieldDecl "v"%go go.uint32)
].

Definition Uint32 : go.type := go.Named "sync/atomic.Uint32"%go [].

(* Load atomically loads and returns the value stored in x.

   go: type.go:147:18 *)
Definition Uint32__Loadⁱᵐᵖˡ : val :=
  λ: "x" <>,
    exception_do (let: "x" := (go.AllocValue (go.PointerType Uint32) "x") in
    return: (let: "$a0" := (StructFieldRef Uint32 "v"%go (![go.PointerType Uint32] "x")) in
     (FuncResolve LoadUint32 [] #()) "$a0")).

(* Store atomically stores val into x.

   go: type.go:150:18 *)
Definition Uint32__Storeⁱᵐᵖˡ : val :=
  λ: "x" "val",
    exception_do (let: "x" := (go.AllocValue (go.PointerType Uint32) "x") in
    let: "val" := (go.AllocValue go.uint32 "val") in
    do:  (let: "$a0" := (StructFieldRef Uint32 "v"%go (![go.PointerType Uint32] "x")) in
    let: "$a1" := (![go.uint32] "val") in
    (FuncResolve StoreUint32 [] #()) "$a0" "$a1");;;
    return: #()).

(* Swap atomically stores new into x and returns the previous value.

   go: type.go:153:18 *)
Definition Uint32__Swapⁱᵐᵖˡ : val :=
  λ: "x" "new",
    exception_do (let: "old" := (GoAlloc go.uint32 #()) in
    let: "x" := (go.AllocValue (go.PointerType Uint32) "x") in
    let: "new" := (go.AllocValue go.uint32 "new") in
    return: (let: "$a0" := (StructFieldRef Uint32 "v"%go (![go.PointerType Uint32] "x")) in
     let: "$a1" := (![go.uint32] "new") in
     (FuncResolve SwapUint32 [] #()) "$a0" "$a1")).

(* CompareAndSwap executes the compare-and-swap operation for x.

   go: type.go:156:18 *)
Definition Uint32__CompareAndSwapⁱᵐᵖˡ : val :=
  λ: "x" "old" "new",
    exception_do (let: "swapped" := (GoAlloc go.bool #()) in
    let: "x" := (go.AllocValue (go.PointerType Uint32) "x") in
    let: "new" := (go.AllocValue go.uint32 "new") in
    let: "old" := (go.AllocValue go.uint32 "old") in
    return: (let: "$a0" := (StructFieldRef Uint32 "v"%go (![go.PointerType Uint32] "x")) in
     let: "$a1" := (![go.uint32] "old") in
     let: "$a2" := (![go.uint32] "new") in
     (FuncResolve CompareAndSwapUint32 [] #()) "$a0" "$a1" "$a2")).

(* Add atomically adds delta to x and returns the new value.

   go: type.go:161:18 *)
Definition Uint32__Addⁱᵐᵖˡ : val :=
  λ: "x" "delta",
    exception_do (let: "new" := (GoAlloc go.uint32 #()) in
    let: "x" := (go.AllocValue (go.PointerType Uint32) "x") in
    let: "delta" := (go.AllocValue go.uint32 "delta") in
    return: (let: "$a0" := (StructFieldRef Uint32 "v"%go (![go.PointerType Uint32] "x")) in
     let: "$a1" := (![go.uint32] "delta") in
     (FuncResolve AddUint32 [] #()) "$a0" "$a1")).

(* And atomically performs a bitwise AND operation on x using the bitmask
   provided as mask and returns the old value.

   go: type.go:165:18 *)
Definition Uint32__Andⁱᵐᵖˡ : val :=
  λ: "x" "mask",
    exception_do (let: "old" := (GoAlloc go.uint32 #()) in
    let: "x" := (go.AllocValue (go.PointerType Uint32) "x") in
    let: "mask" := (go.AllocValue go.uint32 "mask") in
    return: (let: "$a0" := (StructFieldRef Uint32 "v"%go (![go.PointerType Uint32] "x")) in
     let: "$a1" := (![go.uint32] "mask") in
     (FuncResolve AndUint32 [] #()) "$a0" "$a1")).

(* Or atomically performs a bitwise OR operation on x using the bitmask
   provided as mask and returns the old value.

   go: type.go:169:18 *)
Definition Uint32__Orⁱᵐᵖˡ : val :=
  λ: "x" "mask",
    exception_do (let: "old" := (GoAlloc go.uint32 #()) in
    let: "x" := (go.AllocValue (go.PointerType Uint32) "x") in
    let: "mask" := (go.AllocValue go.uint32 "mask") in
    return: (let: "$a0" := (StructFieldRef Uint32 "v"%go (![go.PointerType Uint32] "x")) in
     let: "$a1" := (![go.uint32] "mask") in
     (FuncResolve OrUint32 [] #()) "$a0" "$a1")).

Definition Uint64ⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "_0"%go noCopy);
  (go.FieldDecl "_1"%go align64);
  (go.FieldDecl "v"%go go.uint64)
].

Definition Uint64 : go.type := go.Named "sync/atomic.Uint64"%go [].

(* Load atomically loads and returns the value stored in x.

   go: type.go:181:18 *)
Definition Uint64__Loadⁱᵐᵖˡ : val :=
  λ: "x" <>,
    exception_do (let: "x" := (go.AllocValue (go.PointerType Uint64) "x") in
    return: (let: "$a0" := (StructFieldRef Uint64 "v"%go (![go.PointerType Uint64] "x")) in
     (FuncResolve LoadUint64 [] #()) "$a0")).

(* Store atomically stores val into x.

   go: type.go:184:18 *)
Definition Uint64__Storeⁱᵐᵖˡ : val :=
  λ: "x" "val",
    exception_do (let: "x" := (go.AllocValue (go.PointerType Uint64) "x") in
    let: "val" := (go.AllocValue go.uint64 "val") in
    do:  (let: "$a0" := (StructFieldRef Uint64 "v"%go (![go.PointerType Uint64] "x")) in
    let: "$a1" := (![go.uint64] "val") in
    (FuncResolve StoreUint64 [] #()) "$a0" "$a1");;;
    return: #()).

(* Swap atomically stores new into x and returns the previous value.

   go: type.go:187:18 *)
Definition Uint64__Swapⁱᵐᵖˡ : val :=
  λ: "x" "new",
    exception_do (let: "old" := (GoAlloc go.uint64 #()) in
    let: "x" := (go.AllocValue (go.PointerType Uint64) "x") in
    let: "new" := (go.AllocValue go.uint64 "new") in
    return: (let: "$a0" := (StructFieldRef Uint64 "v"%go (![go.PointerType Uint64] "x")) in
     let: "$a1" := (![go.uint64] "new") in
     (FuncResolve SwapUint64 [] #()) "$a0" "$a1")).

(* CompareAndSwap executes the compare-and-swap operation for x.

   go: type.go:190:18 *)
Definition Uint64__CompareAndSwapⁱᵐᵖˡ : val :=
  λ: "x" "old" "new",
    exception_do (let: "swapped" := (GoAlloc go.bool #()) in
    let: "x" := (go.AllocValue (go.PointerType Uint64) "x") in
    let: "new" := (go.AllocValue go.uint64 "new") in
    let: "old" := (go.AllocValue go.uint64 "old") in
    return: (let: "$a0" := (StructFieldRef Uint64 "v"%go (![go.PointerType Uint64] "x")) in
     let: "$a1" := (![go.uint64] "old") in
     let: "$a2" := (![go.uint64] "new") in
     (FuncResolve CompareAndSwapUint64 [] #()) "$a0" "$a1" "$a2")).

(* Add atomically adds delta to x and returns the new value.

   go: type.go:195:18 *)
Definition Uint64__Addⁱᵐᵖˡ : val :=
  λ: "x" "delta",
    exception_do (let: "new" := (GoAlloc go.uint64 #()) in
    let: "x" := (go.AllocValue (go.PointerType Uint64) "x") in
    let: "delta" := (go.AllocValue go.uint64 "delta") in
    return: (let: "$a0" := (StructFieldRef Uint64 "v"%go (![go.PointerType Uint64] "x")) in
     let: "$a1" := (![go.uint64] "delta") in
     (FuncResolve AddUint64 [] #()) "$a0" "$a1")).

(* And atomically performs a bitwise AND operation on x using the bitmask
   provided as mask and returns the old value.

   go: type.go:199:18 *)
Definition Uint64__Andⁱᵐᵖˡ : val :=
  λ: "x" "mask",
    exception_do (let: "old" := (GoAlloc go.uint64 #()) in
    let: "x" := (go.AllocValue (go.PointerType Uint64) "x") in
    let: "mask" := (go.AllocValue go.uint64 "mask") in
    return: (let: "$a0" := (StructFieldRef Uint64 "v"%go (![go.PointerType Uint64] "x")) in
     let: "$a1" := (![go.uint64] "mask") in
     (FuncResolve AndUint64 [] #()) "$a0" "$a1")).

(* Or atomically performs a bitwise OR operation on x using the bitmask
   provided as mask and returns the old value.

   go: type.go:203:18 *)
Definition Uint64__Orⁱᵐᵖˡ : val :=
  λ: "x" "mask",
    exception_do (let: "old" := (GoAlloc go.uint64 #()) in
    let: "x" := (go.AllocValue (go.PointerType Uint64) "x") in
    let: "mask" := (go.AllocValue go.uint64 "mask") in
    return: (let: "$a0" := (StructFieldRef Uint64 "v"%go (![go.PointerType Uint64] "x")) in
     let: "$a1" := (![go.uint64] "mask") in
     (FuncResolve OrUint64 [] #()) "$a0" "$a1")).

Axiom Uintptrⁱᵐᵖˡ : go.type.

Definition noCopyⁱᵐᵖˡ : go.type := go.StructType [
].

Definition align64ⁱᵐᵖˡ : go.type := go.StructType [
].

Definition Valueⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "v"%go (go.InterfaceType []))
].

Definition efaceWordsⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "typ"%go unsafe.Pointer);
  (go.FieldDecl "data"%go unsafe.Pointer)
].

Definition efaceWords : go.type := go.Named "sync/atomic.efaceWords"%go [].

Definition firstStoreInProgress : go_string := "sync/atomic.firstStoreInProgress"%go.

Definition Value : go.type := go.Named "sync/atomic.Value"%go [].

(* Load returns the value set by the most recent Store.
   It returns nil if there has been no call to Store for this Value.

   go: value.go:28:17 *)
Definition Value__Loadⁱᵐᵖˡ : val :=
  λ: "v" <>,
    exception_do (let: "val" := (GoAlloc (go.InterfaceType []) #()) in
    let: "v" := (go.AllocValue (go.PointerType Value) "v") in
    let: "vp" := (GoAlloc (go.PointerType efaceWords) #()) in
    let: "$r0" := (![go.PointerType Value] "v") in
    do:  ("vp" <-[go.PointerType efaceWords] "$r0");;;
    let: "typ" := (GoAlloc unsafe.Pointer #()) in
    let: "$r0" := (let: "$a0" := (StructFieldRef efaceWords "typ"%go (![go.PointerType efaceWords] "vp")) in
    (FuncResolve LoadPointer [] #()) "$a0") in
    do:  ("typ" <-[unsafe.Pointer] "$r0");;;
    (if: ((![unsafe.Pointer] "typ") =⟨unsafe.Pointer⟩ #null) || ((![unsafe.Pointer] "typ") =⟨unsafe.Pointer⟩ (GlobalVarAddr firstStoreInProgress #()))
    then return: (#interface.nil)
    else do:  #());;;
    let: "data" := (GoAlloc unsafe.Pointer #()) in
    let: "$r0" := (let: "$a0" := (StructFieldRef efaceWords "data"%go (![go.PointerType efaceWords] "vp")) in
    (FuncResolve LoadPointer [] #()) "$a0") in
    do:  ("data" <-[unsafe.Pointer] "$r0");;;
    let: "vlp" := (GoAlloc (go.PointerType efaceWords) #()) in
    let: "$r0" := "val" in
    do:  ("vlp" <-[go.PointerType efaceWords] "$r0");;;
    let: "$r0" := (![unsafe.Pointer] "typ") in
    do:  ((StructFieldRef efaceWords "typ"%go (![go.PointerType efaceWords] "vlp")) <-[unsafe.Pointer] "$r0");;;
    let: "$r0" := (![unsafe.Pointer] "data") in
    do:  ((StructFieldRef efaceWords "data"%go (![go.PointerType efaceWords] "vlp")) <-[unsafe.Pointer] "$r0");;;
    return: (![go.InterfaceType []] "val")).

Definition runtime_procUnpin : go_string := "sync/atomic.runtime_procUnpin"%go.

Definition runtime_procPin : go_string := "sync/atomic.runtime_procPin"%go.

(* Store sets the value of the [Value] v to val.
   All calls to Store for a given Value must use values of the same concrete type.
   Store of an inconsistent type panics, as does Store(nil).

   go: value.go:47:17 *)
Definition Value__Storeⁱᵐᵖˡ : val :=
  λ: "v" "val",
    exception_do (let: "v" := (go.AllocValue (go.PointerType Value) "v") in
    let: "val" := (go.AllocValue (go.InterfaceType []) "val") in
    (if: (![go.InterfaceType []] "val") =⟨go.InterfaceType []⟩ #interface.nil
    then
      do:  (let: "$a0" := (InterfaceMake go.string #"sync/atomic: store of nil value into Value"%go) in
      (FuncResolve go.panic [] #()) "$a0")
    else do:  #());;;
    let: "vp" := (GoAlloc (go.PointerType efaceWords) #()) in
    let: "$r0" := (![go.PointerType Value] "v") in
    do:  ("vp" <-[go.PointerType efaceWords] "$r0");;;
    let: "vlp" := (GoAlloc (go.PointerType efaceWords) #()) in
    let: "$r0" := "val" in
    do:  ("vlp" <-[go.PointerType efaceWords] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "typ" := (GoAlloc unsafe.Pointer #()) in
      let: "$r0" := (let: "$a0" := (StructFieldRef efaceWords "typ"%go (![go.PointerType efaceWords] "vp")) in
      (FuncResolve LoadPointer [] #()) "$a0") in
      do:  ("typ" <-[unsafe.Pointer] "$r0");;;
      (if: (![unsafe.Pointer] "typ") =⟨unsafe.Pointer⟩ #null
      then
        do:  ((FuncResolve runtime_procPin [] #()) #());;;
        (if: (~ (let: "$a0" := (StructFieldRef efaceWords "typ"%go (![go.PointerType efaceWords] "vp")) in
        let: "$a1" := #null in
        let: "$a2" := (GlobalVarAddr firstStoreInProgress #()) in
        (FuncResolve CompareAndSwapPointer [] #()) "$a0" "$a1" "$a2"))
        then
          do:  ((FuncResolve runtime_procUnpin [] #()) #());;;
          continue: #()
        else do:  #());;;
        do:  (let: "$a0" := (StructFieldRef efaceWords "data"%go (![go.PointerType efaceWords] "vp")) in
        let: "$a1" := (![unsafe.Pointer] (StructFieldRef efaceWords "data"%go (![go.PointerType efaceWords] "vlp"))) in
        (FuncResolve StorePointer [] #()) "$a0" "$a1");;;
        do:  (let: "$a0" := (StructFieldRef efaceWords "typ"%go (![go.PointerType efaceWords] "vp")) in
        let: "$a1" := (![unsafe.Pointer] (StructFieldRef efaceWords "typ"%go (![go.PointerType efaceWords] "vlp"))) in
        (FuncResolve StorePointer [] #()) "$a0" "$a1");;;
        do:  ((FuncResolve runtime_procUnpin [] #()) #());;;
        return: (#())
      else do:  #());;;
      (if: (![unsafe.Pointer] "typ") =⟨unsafe.Pointer⟩ (GlobalVarAddr firstStoreInProgress #())
      then continue: #()
      else do:  #());;;
      (if: (![unsafe.Pointer] "typ") ≠⟨unsafe.Pointer⟩ (![unsafe.Pointer] (StructFieldRef efaceWords "typ"%go (![go.PointerType efaceWords] "vlp")))
      then
        do:  (let: "$a0" := (InterfaceMake go.string #"sync/atomic: store of inconsistently typed value into Value"%go) in
        (FuncResolve go.panic [] #()) "$a0")
      else do:  #());;;
      do:  (let: "$a0" := (StructFieldRef efaceWords "data"%go (![go.PointerType efaceWords] "vp")) in
      let: "$a1" := (![unsafe.Pointer] (StructFieldRef efaceWords "data"%go (![go.PointerType efaceWords] "vlp"))) in
      (FuncResolve StorePointer [] #()) "$a0" "$a1");;;
      return: (#()));;;
    return: #()).

(* Swap stores new into Value and returns the previous value. It returns nil if
   the Value is empty.

   All calls to Swap for a given Value must use values of the same concrete
   type. Swap of an inconsistent type panics, as does Swap(nil).

   go: value.go:90:17 *)
Definition Value__Swapⁱᵐᵖˡ : val :=
  λ: "v" "new",
    exception_do (let: "old" := (GoAlloc (go.InterfaceType []) #()) in
    let: "v" := (go.AllocValue (go.PointerType Value) "v") in
    let: "new" := (go.AllocValue (go.InterfaceType []) "new") in
    (if: (![go.InterfaceType []] "new") =⟨go.InterfaceType []⟩ #interface.nil
    then
      do:  (let: "$a0" := (InterfaceMake go.string #"sync/atomic: swap of nil value into Value"%go) in
      (FuncResolve go.panic [] #()) "$a0")
    else do:  #());;;
    let: "vp" := (GoAlloc (go.PointerType efaceWords) #()) in
    let: "$r0" := (![go.PointerType Value] "v") in
    do:  ("vp" <-[go.PointerType efaceWords] "$r0");;;
    let: "np" := (GoAlloc (go.PointerType efaceWords) #()) in
    let: "$r0" := "new" in
    do:  ("np" <-[go.PointerType efaceWords] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "typ" := (GoAlloc unsafe.Pointer #()) in
      let: "$r0" := (let: "$a0" := (StructFieldRef efaceWords "typ"%go (![go.PointerType efaceWords] "vp")) in
      (FuncResolve LoadPointer [] #()) "$a0") in
      do:  ("typ" <-[unsafe.Pointer] "$r0");;;
      (if: (![unsafe.Pointer] "typ") =⟨unsafe.Pointer⟩ #null
      then
        do:  ((FuncResolve runtime_procPin [] #()) #());;;
        (if: (~ (let: "$a0" := (StructFieldRef efaceWords "typ"%go (![go.PointerType efaceWords] "vp")) in
        let: "$a1" := #null in
        let: "$a2" := (GlobalVarAddr firstStoreInProgress #()) in
        (FuncResolve CompareAndSwapPointer [] #()) "$a0" "$a1" "$a2"))
        then
          do:  ((FuncResolve runtime_procUnpin [] #()) #());;;
          continue: #()
        else do:  #());;;
        do:  (let: "$a0" := (StructFieldRef efaceWords "data"%go (![go.PointerType efaceWords] "vp")) in
        let: "$a1" := (![unsafe.Pointer] (StructFieldRef efaceWords "data"%go (![go.PointerType efaceWords] "np"))) in
        (FuncResolve StorePointer [] #()) "$a0" "$a1");;;
        do:  (let: "$a0" := (StructFieldRef efaceWords "typ"%go (![go.PointerType efaceWords] "vp")) in
        let: "$a1" := (![unsafe.Pointer] (StructFieldRef efaceWords "typ"%go (![go.PointerType efaceWords] "np"))) in
        (FuncResolve StorePointer [] #()) "$a0" "$a1");;;
        do:  ((FuncResolve runtime_procUnpin [] #()) #());;;
        return: (#interface.nil)
      else do:  #());;;
      (if: (![unsafe.Pointer] "typ") =⟨unsafe.Pointer⟩ (GlobalVarAddr firstStoreInProgress #())
      then continue: #()
      else do:  #());;;
      (if: (![unsafe.Pointer] "typ") ≠⟨unsafe.Pointer⟩ (![unsafe.Pointer] (StructFieldRef efaceWords "typ"%go (![go.PointerType efaceWords] "np")))
      then
        do:  (let: "$a0" := (InterfaceMake go.string #"sync/atomic: swap of inconsistently typed value into Value"%go) in
        (FuncResolve go.panic [] #()) "$a0")
      else do:  #());;;
      let: "op" := (GoAlloc (go.PointerType efaceWords) #()) in
      let: "$r0" := "old" in
      do:  ("op" <-[go.PointerType efaceWords] "$r0");;;
      let: "$r0" := (![unsafe.Pointer] (StructFieldRef efaceWords "typ"%go (![go.PointerType efaceWords] "np"))) in
      let: "$r1" := (let: "$a0" := (StructFieldRef efaceWords "data"%go (![go.PointerType efaceWords] "vp")) in
      let: "$a1" := (![unsafe.Pointer] (StructFieldRef efaceWords "data"%go (![go.PointerType efaceWords] "np"))) in
      (FuncResolve SwapPointer [] #()) "$a0" "$a1") in
      do:  ((StructFieldRef efaceWords "typ"%go (![go.PointerType efaceWords] "op")) <-[unsafe.Pointer] "$r0");;;
      do:  ((StructFieldRef efaceWords "data"%go (![go.PointerType efaceWords] "op")) <-[unsafe.Pointer] "$r1");;;
      return: (![go.InterfaceType []] "old"))).

(* CompareAndSwap executes the compare-and-swap operation for the [Value].

   All calls to CompareAndSwap for a given Value must use values of the same
   concrete type. CompareAndSwap of an inconsistent type panics, as does
   CompareAndSwap(old, nil).

   go: value.go:135:17 *)
Definition Value__CompareAndSwapⁱᵐᵖˡ : val :=
  λ: "v" "old" "new",
    exception_do (let: "swapped" := (GoAlloc go.bool #()) in
    let: "v" := (go.AllocValue (go.PointerType Value) "v") in
    let: "new" := (go.AllocValue (go.InterfaceType []) "new") in
    let: "old" := (go.AllocValue (go.InterfaceType []) "old") in
    (if: (![go.InterfaceType []] "new") =⟨go.InterfaceType []⟩ #interface.nil
    then
      do:  (let: "$a0" := (InterfaceMake go.string #"sync/atomic: compare and swap of nil value into Value"%go) in
      (FuncResolve go.panic [] #()) "$a0")
    else do:  #());;;
    let: "vp" := (GoAlloc (go.PointerType efaceWords) #()) in
    let: "$r0" := (![go.PointerType Value] "v") in
    do:  ("vp" <-[go.PointerType efaceWords] "$r0");;;
    let: "np" := (GoAlloc (go.PointerType efaceWords) #()) in
    let: "$r0" := "new" in
    do:  ("np" <-[go.PointerType efaceWords] "$r0");;;
    let: "op" := (GoAlloc (go.PointerType efaceWords) #()) in
    let: "$r0" := "old" in
    do:  ("op" <-[go.PointerType efaceWords] "$r0");;;
    (if: ((![unsafe.Pointer] (StructFieldRef efaceWords "typ"%go (![go.PointerType efaceWords] "op"))) ≠⟨unsafe.Pointer⟩ #null) && ((![unsafe.Pointer] (StructFieldRef efaceWords "typ"%go (![go.PointerType efaceWords] "np"))) ≠⟨unsafe.Pointer⟩ (![unsafe.Pointer] (StructFieldRef efaceWords "typ"%go (![go.PointerType efaceWords] "op"))))
    then
      do:  (let: "$a0" := (InterfaceMake go.string #"sync/atomic: compare and swap of inconsistently typed values"%go) in
      (FuncResolve go.panic [] #()) "$a0")
    else do:  #());;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "typ" := (GoAlloc unsafe.Pointer #()) in
      let: "$r0" := (let: "$a0" := (StructFieldRef efaceWords "typ"%go (![go.PointerType efaceWords] "vp")) in
      (FuncResolve LoadPointer [] #()) "$a0") in
      do:  ("typ" <-[unsafe.Pointer] "$r0");;;
      (if: (![unsafe.Pointer] "typ") =⟨unsafe.Pointer⟩ #null
      then
        (if: (![go.InterfaceType []] "old") ≠⟨go.InterfaceType []⟩ #interface.nil
        then return: (#false)
        else do:  #());;;
        do:  ((FuncResolve runtime_procPin [] #()) #());;;
        (if: (~ (let: "$a0" := (StructFieldRef efaceWords "typ"%go (![go.PointerType efaceWords] "vp")) in
        let: "$a1" := #null in
        let: "$a2" := (GlobalVarAddr firstStoreInProgress #()) in
        (FuncResolve CompareAndSwapPointer [] #()) "$a0" "$a1" "$a2"))
        then
          do:  ((FuncResolve runtime_procUnpin [] #()) #());;;
          continue: #()
        else do:  #());;;
        do:  (let: "$a0" := (StructFieldRef efaceWords "data"%go (![go.PointerType efaceWords] "vp")) in
        let: "$a1" := (![unsafe.Pointer] (StructFieldRef efaceWords "data"%go (![go.PointerType efaceWords] "np"))) in
        (FuncResolve StorePointer [] #()) "$a0" "$a1");;;
        do:  (let: "$a0" := (StructFieldRef efaceWords "typ"%go (![go.PointerType efaceWords] "vp")) in
        let: "$a1" := (![unsafe.Pointer] (StructFieldRef efaceWords "typ"%go (![go.PointerType efaceWords] "np"))) in
        (FuncResolve StorePointer [] #()) "$a0" "$a1");;;
        do:  ((FuncResolve runtime_procUnpin [] #()) #());;;
        return: (#true)
      else do:  #());;;
      (if: (![unsafe.Pointer] "typ") =⟨unsafe.Pointer⟩ (GlobalVarAddr firstStoreInProgress #())
      then continue: #()
      else do:  #());;;
      (if: (![unsafe.Pointer] "typ") ≠⟨unsafe.Pointer⟩ (![unsafe.Pointer] (StructFieldRef efaceWords "typ"%go (![go.PointerType efaceWords] "np")))
      then
        do:  (let: "$a0" := (InterfaceMake go.string #"sync/atomic: compare and swap of inconsistently typed value into Value"%go) in
        (FuncResolve go.panic [] #()) "$a0")
      else do:  #());;;
      let: "data" := (GoAlloc unsafe.Pointer #()) in
      let: "$r0" := (let: "$a0" := (StructFieldRef efaceWords "data"%go (![go.PointerType efaceWords] "vp")) in
      (FuncResolve LoadPointer [] #()) "$a0") in
      do:  ("data" <-[unsafe.Pointer] "$r0");;;
      let: "i" := (GoAlloc (go.InterfaceType []) #()) in
      let: "$r0" := (![unsafe.Pointer] "typ") in
      do:  ((StructFieldRef efaceWords "typ"%go "i") <-[unsafe.Pointer] "$r0");;;
      let: "$r0" := (![unsafe.Pointer] "data") in
      do:  ((StructFieldRef efaceWords "data"%go "i") <-[unsafe.Pointer] "$r0");;;
      (if: (![go.InterfaceType []] "i") ≠⟨go.InterfaceType []⟩ (![go.InterfaceType []] "old")
      then return: (#false)
      else do:  #());;;
      return: (let: "$a0" := (StructFieldRef efaceWords "data"%go (![go.PointerType efaceWords] "vp")) in
       let: "$a1" := (![unsafe.Pointer] "data") in
       let: "$a2" := (![unsafe.Pointer] (StructFieldRef efaceWords "data"%go (![go.PointerType efaceWords] "np"))) in
       (FuncResolve CompareAndSwapPointer [] #()) "$a0" "$a1" "$a2"))).

Definition Pointer(T : go.type)  : go.type := go.Named "sync/atomic.Pointer"%go [T].

Definition Uintptr : go.type := go.Named "sync/atomic.Uintptr"%go [].

Axiom SwapInt32ⁱᵐᵖˡ : val.

Axiom SwapUint32ⁱᵐᵖˡ : val.

Axiom SwapUintptrⁱᵐᵖˡ : val.

Axiom SwapPointerⁱᵐᵖˡ : val.

Axiom CompareAndSwapUintptrⁱᵐᵖˡ : val.

Axiom CompareAndSwapPointerⁱᵐᵖˡ : val.

Axiom AddUintptrⁱᵐᵖˡ : val.

Axiom AndInt32ⁱᵐᵖˡ : val.

Axiom AndUint32ⁱᵐᵖˡ : val.

Axiom AndUintptrⁱᵐᵖˡ : val.

Axiom OrInt32ⁱᵐᵖˡ : val.

Axiom OrUint32ⁱᵐᵖˡ : val.

Axiom OrUintptrⁱᵐᵖˡ : val.

Axiom LoadUintptrⁱᵐᵖˡ : val.

Axiom LoadPointerⁱᵐᵖˡ : val.

Axiom StoreUintptrⁱᵐᵖˡ : val.

Axiom StorePointerⁱᵐᵖˡ : val.

Axiom SwapInt64ⁱᵐᵖˡ : val.

Axiom SwapUint64ⁱᵐᵖˡ : val.

Axiom AndInt64ⁱᵐᵖˡ : val.

Axiom AndUint64ⁱᵐᵖˡ : val.

Axiom OrInt64ⁱᵐᵖˡ : val.

Axiom OrUint64ⁱᵐᵖˡ : val.

Axiom runtime_procPinⁱᵐᵖˡ : val.

Axiom runtime_procUnpinⁱᵐᵖˡ : val.

Definition functions' : list (go_string * val) := [(SwapInt32, SwapInt32ⁱᵐᵖˡ); (SwapUint32, SwapUint32ⁱᵐᵖˡ); (SwapUintptr, SwapUintptrⁱᵐᵖˡ); (SwapPointer, SwapPointerⁱᵐᵖˡ); (CompareAndSwapInt32, CompareAndSwapInt32ⁱᵐᵖˡ); (CompareAndSwapUint32, CompareAndSwapUint32ⁱᵐᵖˡ); (CompareAndSwapUintptr, CompareAndSwapUintptrⁱᵐᵖˡ); (CompareAndSwapPointer, CompareAndSwapPointerⁱᵐᵖˡ); (AddInt32, AddInt32ⁱᵐᵖˡ); (AddUint32, AddUint32ⁱᵐᵖˡ); (AddUintptr, AddUintptrⁱᵐᵖˡ); (AndInt32, AndInt32ⁱᵐᵖˡ); (AndUint32, AndUint32ⁱᵐᵖˡ); (AndUintptr, AndUintptrⁱᵐᵖˡ); (OrInt32, OrInt32ⁱᵐᵖˡ); (OrUint32, OrUint32ⁱᵐᵖˡ); (OrUintptr, OrUintptrⁱᵐᵖˡ); (LoadInt32, LoadInt32ⁱᵐᵖˡ); (LoadUint32, LoadUint32ⁱᵐᵖˡ); (LoadUintptr, LoadUintptrⁱᵐᵖˡ); (LoadPointer, LoadPointerⁱᵐᵖˡ); (StoreInt32, StoreInt32ⁱᵐᵖˡ); (StoreUint32, StoreUint32ⁱᵐᵖˡ); (StoreUintptr, StoreUintptrⁱᵐᵖˡ); (StorePointer, StorePointerⁱᵐᵖˡ); (SwapInt64, SwapInt64ⁱᵐᵖˡ); (SwapUint64, SwapUint64ⁱᵐᵖˡ); (CompareAndSwapInt64, CompareAndSwapInt64ⁱᵐᵖˡ); (CompareAndSwapUint64, CompareAndSwapUint64ⁱᵐᵖˡ); (AddInt64, AddInt64ⁱᵐᵖˡ); (AddUint64, AddUint64ⁱᵐᵖˡ); (AndInt64, AndInt64ⁱᵐᵖˡ); (AndUint64, AndUint64ⁱᵐᵖˡ); (OrInt64, OrInt64ⁱᵐᵖˡ); (OrUint64, OrUint64ⁱᵐᵖˡ); (LoadInt64, LoadInt64ⁱᵐᵖˡ); (LoadUint64, LoadUint64ⁱᵐᵖˡ); (StoreInt64, StoreInt64ⁱᵐᵖˡ); (StoreUint64, StoreUint64ⁱᵐᵖˡ); (b32, b32ⁱᵐᵖˡ); (runtime_procPin, runtime_procPinⁱᵐᵖˡ); (runtime_procUnpin, runtime_procUnpinⁱᵐᵖˡ)].

#[global] Instance info' : PkgInfo atomic.atomic :=
  {|
    pkg_imported_pkgs := [];
  |}.

Definition initialize' : val :=
  λ: <>,
    package.init atomic.atomic (λ: <>,
      exception_do (let: "$r0" := (go.AllocValue (Pointer go.int) (CompositeLiteral (Pointer go.int) (
        let: "$$vs" := go.StructElementListNil #() in 
        let: "$$vs" := go.ElementListApp "$$vs" (go.ZeroVal (go.ArrayType 0 (go.PointerType go.int)) #()) in
        let: "$$vs" := go.ElementListApp "$$vs" (go.ZeroVal noCopy #()) in
        let: "$$vs" := go.ElementListApp "$$vs" (go.ZeroVal unsafe.Pointer #()) in
        "$$vs"
      ))) in
      do:  #())
      ).

End code.
End atomic.
