(* autogenerated from sync/atomic *)

From New.golang Require Import defn.core.
From New.golang.defn Require Export slice array map string interface defer builtin.
Require Export New.trusted_code.sync.atomic.
Import atomic.
Definition atomic : go_string := "sync/atomic".

Module atomic.

Module Bool. Definition id : go_string := "sync/atomic.Bool"%go. End Bool.
Module Pointer. Definition id : go_string := "sync/atomic.Pointer"%go. End Pointer.
Module Int32. Definition id : go_string := "sync/atomic.Int32"%go. End Int32.
Module Int64. Definition id : go_string := "sync/atomic.Int64"%go. End Int64.
Module Uint32. Definition id : go_string := "sync/atomic.Uint32"%go. End Uint32.
Module Uint64. Definition id : go_string := "sync/atomic.Uint64"%go. End Uint64.
Module Uintptr. Definition id : go_string := "sync/atomic.Uintptr"%go. End Uintptr.
Module noCopy. Definition id : go_string := "sync/atomic.noCopy"%go. End noCopy.
Module align64. Definition id : go_string := "sync/atomic.align64"%go. End align64.
Module Value. Definition id : go_string := "sync/atomic.Value"%go. End Value.
Module efaceWords. Definition id : go_string := "sync/atomic.efaceWords"%go. End efaceWords.

Section code.
Context `{ffi_syntax}.


Definition SwapInt32 : go_string := "sync/atomic.SwapInt32"%go.

Definition SwapUint32 : go_string := "sync/atomic.SwapUint32"%go.

Definition SwapUintptr : go_string := "sync/atomic.SwapUintptr"%go.

Definition SwapPointer : go_string := "sync/atomic.SwapPointer"%go.

Definition CompareAndSwapInt32 : go_string := "sync/atomic.CompareAndSwapInt32"%go.

Definition CompareAndSwapUint32 : go_string := "sync/atomic.CompareAndSwapUint32"%go.

Definition CompareAndSwapUintptr : go_string := "sync/atomic.CompareAndSwapUintptr"%go.

Definition CompareAndSwapPointer : go_string := "sync/atomic.CompareAndSwapPointer"%go.

Definition AddInt32 : go_string := "sync/atomic.AddInt32"%go.

Definition AddUint32 : go_string := "sync/atomic.AddUint32"%go.

Definition AddUintptr : go_string := "sync/atomic.AddUintptr"%go.

Definition AndInt32 : go_string := "sync/atomic.AndInt32"%go.

Definition AndUint32 : go_string := "sync/atomic.AndUint32"%go.

Definition AndUintptr : go_string := "sync/atomic.AndUintptr"%go.

Definition OrInt32 : go_string := "sync/atomic.OrInt32"%go.

Definition OrUint32 : go_string := "sync/atomic.OrUint32"%go.

Definition OrUintptr : go_string := "sync/atomic.OrUintptr"%go.

Definition LoadInt32 : go_string := "sync/atomic.LoadInt32"%go.

Definition LoadUint32 : go_string := "sync/atomic.LoadUint32"%go.

Definition LoadUintptr : go_string := "sync/atomic.LoadUintptr"%go.

Definition LoadPointer : go_string := "sync/atomic.LoadPointer"%go.

Definition StoreInt32 : go_string := "sync/atomic.StoreInt32"%go.

Definition StoreUint32 : go_string := "sync/atomic.StoreUint32"%go.

Definition StoreUintptr : go_string := "sync/atomic.StoreUintptr"%go.

Definition StorePointer : go_string := "sync/atomic.StorePointer"%go.

Definition SwapInt64 : go_string := "sync/atomic.SwapInt64"%go.

Definition SwapUint64 : go_string := "sync/atomic.SwapUint64"%go.

Definition CompareAndSwapInt64 : go_string := "sync/atomic.CompareAndSwapInt64"%go.

Definition CompareAndSwapUint64 : go_string := "sync/atomic.CompareAndSwapUint64"%go.

Definition AddInt64 : go_string := "sync/atomic.AddInt64"%go.

Definition AddUint64 : go_string := "sync/atomic.AddUint64"%go.

Definition AndInt64 : go_string := "sync/atomic.AndInt64"%go.

Definition AndUint64 : go_string := "sync/atomic.AndUint64"%go.

Definition OrInt64 : go_string := "sync/atomic.OrInt64"%go.

Definition OrUint64 : go_string := "sync/atomic.OrUint64"%go.

Definition LoadInt64 : go_string := "sync/atomic.LoadInt64"%go.

Definition LoadUint64 : go_string := "sync/atomic.LoadUint64"%go.

Definition StoreInt64 : go_string := "sync/atomic.StoreInt64"%go.

Definition StoreUint64 : go_string := "sync/atomic.StoreUint64"%go.

Definition Bool : go_type := structT [
  "_0" :: noCopy;
  "v" :: uint32T
].
#[global] Typeclasses Opaque Bool.
#[global] Opaque Bool.

(* Load atomically loads and returns the value stored in x.

   go: type.go:17:16 *)
Definition Bool__Loadⁱᵐᵖˡ : val :=
  λ: "x" <>,
    exception_do (let: "x" := (mem.alloc "x") in
    return: ((let: "$a0" := (struct.field_ref #Bool #"v"%go (![#ptrT] "x")) in
     (func_call #LoadUint32) "$a0") ≠ #(W32 0))).

Definition b32 : go_string := "sync/atomic.b32"%go.

(* Store atomically stores val into x.

   go: type.go:20:16 *)
Definition Bool__Storeⁱᵐᵖˡ : val :=
  λ: "x" "val",
    exception_do (let: "x" := (mem.alloc "x") in
    let: "val" := (mem.alloc "val") in
    do:  (let: "$a0" := (struct.field_ref #Bool #"v"%go (![#ptrT] "x")) in
    let: "$a1" := (let: "$a0" := (![#boolT] "val") in
    (func_call #b32) "$a0") in
    (func_call #StoreUint32) "$a0" "$a1");;;
    return: #()).

(* Swap atomically stores new into x and returns the previous value.

   go: type.go:23:16 *)
Definition Bool__Swapⁱᵐᵖˡ : val :=
  λ: "x" "new",
    exception_do (let: "old" := (mem.alloc (type.zero_val #boolT)) in
    let: "x" := (mem.alloc "x") in
    let: "new" := (mem.alloc "new") in
    return: ((let: "$a0" := (struct.field_ref #Bool #"v"%go (![#ptrT] "x")) in
     let: "$a1" := (let: "$a0" := (![#boolT] "new") in
     (func_call #b32) "$a0") in
     (func_call #SwapUint32) "$a0" "$a1") ≠ #(W32 0))).

(* CompareAndSwap executes the compare-and-swap operation for the boolean value x.

   go: type.go:26:16 *)
Definition Bool__CompareAndSwapⁱᵐᵖˡ : val :=
  λ: "x" "old" "new",
    exception_do (let: "swapped" := (mem.alloc (type.zero_val #boolT)) in
    let: "x" := (mem.alloc "x") in
    let: "new" := (mem.alloc "new") in
    let: "old" := (mem.alloc "old") in
    return: (let: "$a0" := (struct.field_ref #Bool #"v"%go (![#ptrT] "x")) in
     let: "$a1" := (let: "$a0" := (![#boolT] "old") in
     (func_call #b32) "$a0") in
     let: "$a2" := (let: "$a0" := (![#boolT] "new") in
     (func_call #b32) "$a0") in
     (func_call #CompareAndSwapUint32) "$a0" "$a1" "$a2")).

(* b32 returns a uint32 0 or 1 representing b.

   go: type.go:31:6 *)
Definition b32ⁱᵐᵖˡ : val :=
  λ: "b",
    exception_do (let: "b" := (mem.alloc "b") in
    (if: ![#boolT] "b"
    then return: (#(W32 1))
    else do:  #());;;
    return: (#(W32 0))).

Definition Int32 : go_type := structT [
  "_0" :: noCopy;
  "v" :: int32T
].
#[global] Typeclasses Opaque Int32.
#[global] Opaque Int32.

(* Load atomically loads and returns the value stored in x.

   go: type.go:74:17 *)
Definition Int32__Loadⁱᵐᵖˡ : val :=
  λ: "x" <>,
    exception_do (let: "x" := (mem.alloc "x") in
    return: (let: "$a0" := (struct.field_ref #Int32 #"v"%go (![#ptrT] "x")) in
     (func_call #LoadInt32) "$a0")).

(* Store atomically stores val into x.

   go: type.go:77:17 *)
Definition Int32__Storeⁱᵐᵖˡ : val :=
  λ: "x" "val",
    exception_do (let: "x" := (mem.alloc "x") in
    let: "val" := (mem.alloc "val") in
    do:  (let: "$a0" := (struct.field_ref #Int32 #"v"%go (![#ptrT] "x")) in
    let: "$a1" := (![#int32T] "val") in
    (func_call #StoreInt32) "$a0" "$a1");;;
    return: #()).

(* Swap atomically stores new into x and returns the previous value.

   go: type.go:80:17 *)
Definition Int32__Swapⁱᵐᵖˡ : val :=
  λ: "x" "new",
    exception_do (let: "old" := (mem.alloc (type.zero_val #int32T)) in
    let: "x" := (mem.alloc "x") in
    let: "new" := (mem.alloc "new") in
    return: (let: "$a0" := (struct.field_ref #Int32 #"v"%go (![#ptrT] "x")) in
     let: "$a1" := (![#int32T] "new") in
     (func_call #SwapInt32) "$a0" "$a1")).

(* CompareAndSwap executes the compare-and-swap operation for x.

   go: type.go:83:17 *)
Definition Int32__CompareAndSwapⁱᵐᵖˡ : val :=
  λ: "x" "old" "new",
    exception_do (let: "swapped" := (mem.alloc (type.zero_val #boolT)) in
    let: "x" := (mem.alloc "x") in
    let: "new" := (mem.alloc "new") in
    let: "old" := (mem.alloc "old") in
    return: (let: "$a0" := (struct.field_ref #Int32 #"v"%go (![#ptrT] "x")) in
     let: "$a1" := (![#int32T] "old") in
     let: "$a2" := (![#int32T] "new") in
     (func_call #CompareAndSwapInt32) "$a0" "$a1" "$a2")).

(* Add atomically adds delta to x and returns the new value.

   go: type.go:88:17 *)
Definition Int32__Addⁱᵐᵖˡ : val :=
  λ: "x" "delta",
    exception_do (let: "new" := (mem.alloc (type.zero_val #int32T)) in
    let: "x" := (mem.alloc "x") in
    let: "delta" := (mem.alloc "delta") in
    return: (let: "$a0" := (struct.field_ref #Int32 #"v"%go (![#ptrT] "x")) in
     let: "$a1" := (![#int32T] "delta") in
     (func_call #AddInt32) "$a0" "$a1")).

(* And atomically performs a bitwise AND operation on x using the bitmask
   provided as mask and returns the old value.

   go: type.go:92:17 *)
Definition Int32__Andⁱᵐᵖˡ : val :=
  λ: "x" "mask",
    exception_do (let: "old" := (mem.alloc (type.zero_val #int32T)) in
    let: "x" := (mem.alloc "x") in
    let: "mask" := (mem.alloc "mask") in
    return: (let: "$a0" := (struct.field_ref #Int32 #"v"%go (![#ptrT] "x")) in
     let: "$a1" := (![#int32T] "mask") in
     (func_call #AndInt32) "$a0" "$a1")).

(* Or atomically performs a bitwise OR operation on x using the bitmask
   provided as mask and returns the old value.

   go: type.go:96:17 *)
Definition Int32__Orⁱᵐᵖˡ : val :=
  λ: "x" "mask",
    exception_do (let: "old" := (mem.alloc (type.zero_val #int32T)) in
    let: "x" := (mem.alloc "x") in
    let: "mask" := (mem.alloc "mask") in
    return: (let: "$a0" := (struct.field_ref #Int32 #"v"%go (![#ptrT] "x")) in
     let: "$a1" := (![#int32T] "mask") in
     (func_call #OrInt32) "$a0" "$a1")).

Definition align64 : go_type := structT [
].
#[global] Typeclasses Opaque align64.
#[global] Opaque align64.

Definition Int64 : go_type := structT [
  "_0" :: noCopy;
  "_1" :: align64;
  "v" :: int64T
].
#[global] Typeclasses Opaque Int64.
#[global] Opaque Int64.

(* Load atomically loads and returns the value stored in x.

   go: type.go:106:17 *)
Definition Int64__Loadⁱᵐᵖˡ : val :=
  λ: "x" <>,
    exception_do (let: "x" := (mem.alloc "x") in
    return: (let: "$a0" := (struct.field_ref #Int64 #"v"%go (![#ptrT] "x")) in
     (func_call #LoadInt64) "$a0")).

(* Store atomically stores val into x.

   go: type.go:109:17 *)
Definition Int64__Storeⁱᵐᵖˡ : val :=
  λ: "x" "val",
    exception_do (let: "x" := (mem.alloc "x") in
    let: "val" := (mem.alloc "val") in
    do:  (let: "$a0" := (struct.field_ref #Int64 #"v"%go (![#ptrT] "x")) in
    let: "$a1" := (![#int64T] "val") in
    (func_call #StoreInt64) "$a0" "$a1");;;
    return: #()).

(* Swap atomically stores new into x and returns the previous value.

   go: type.go:112:17 *)
Definition Int64__Swapⁱᵐᵖˡ : val :=
  λ: "x" "new",
    exception_do (let: "old" := (mem.alloc (type.zero_val #int64T)) in
    let: "x" := (mem.alloc "x") in
    let: "new" := (mem.alloc "new") in
    return: (let: "$a0" := (struct.field_ref #Int64 #"v"%go (![#ptrT] "x")) in
     let: "$a1" := (![#int64T] "new") in
     (func_call #SwapInt64) "$a0" "$a1")).

(* CompareAndSwap executes the compare-and-swap operation for x.

   go: type.go:115:17 *)
Definition Int64__CompareAndSwapⁱᵐᵖˡ : val :=
  λ: "x" "old" "new",
    exception_do (let: "swapped" := (mem.alloc (type.zero_val #boolT)) in
    let: "x" := (mem.alloc "x") in
    let: "new" := (mem.alloc "new") in
    let: "old" := (mem.alloc "old") in
    return: (let: "$a0" := (struct.field_ref #Int64 #"v"%go (![#ptrT] "x")) in
     let: "$a1" := (![#int64T] "old") in
     let: "$a2" := (![#int64T] "new") in
     (func_call #CompareAndSwapInt64) "$a0" "$a1" "$a2")).

(* Add atomically adds delta to x and returns the new value.

   go: type.go:120:17 *)
Definition Int64__Addⁱᵐᵖˡ : val :=
  λ: "x" "delta",
    exception_do (let: "new" := (mem.alloc (type.zero_val #int64T)) in
    let: "x" := (mem.alloc "x") in
    let: "delta" := (mem.alloc "delta") in
    return: (let: "$a0" := (struct.field_ref #Int64 #"v"%go (![#ptrT] "x")) in
     let: "$a1" := (![#int64T] "delta") in
     (func_call #AddInt64) "$a0" "$a1")).

(* And atomically performs a bitwise AND operation on x using the bitmask
   provided as mask and returns the old value.

   go: type.go:124:17 *)
Definition Int64__Andⁱᵐᵖˡ : val :=
  λ: "x" "mask",
    exception_do (let: "old" := (mem.alloc (type.zero_val #int64T)) in
    let: "x" := (mem.alloc "x") in
    let: "mask" := (mem.alloc "mask") in
    return: (let: "$a0" := (struct.field_ref #Int64 #"v"%go (![#ptrT] "x")) in
     let: "$a1" := (![#int64T] "mask") in
     (func_call #AndInt64) "$a0" "$a1")).

(* Or atomically performs a bitwise OR operation on x using the bitmask
   provided as mask and returns the old value.

   go: type.go:128:17 *)
Definition Int64__Orⁱᵐᵖˡ : val :=
  λ: "x" "mask",
    exception_do (let: "old" := (mem.alloc (type.zero_val #int64T)) in
    let: "x" := (mem.alloc "x") in
    let: "mask" := (mem.alloc "mask") in
    return: (let: "$a0" := (struct.field_ref #Int64 #"v"%go (![#ptrT] "x")) in
     let: "$a1" := (![#int64T] "mask") in
     (func_call #OrInt64) "$a0" "$a1")).

Definition Uint32 : go_type := structT [
  "_0" :: noCopy;
  "v" :: uint32T
].
#[global] Typeclasses Opaque Uint32.
#[global] Opaque Uint32.

(* Load atomically loads and returns the value stored in x.

   go: type.go:137:18 *)
Definition Uint32__Loadⁱᵐᵖˡ : val :=
  λ: "x" <>,
    exception_do (let: "x" := (mem.alloc "x") in
    return: (let: "$a0" := (struct.field_ref #Uint32 #"v"%go (![#ptrT] "x")) in
     (func_call #LoadUint32) "$a0")).

(* Store atomically stores val into x.

   go: type.go:140:18 *)
Definition Uint32__Storeⁱᵐᵖˡ : val :=
  λ: "x" "val",
    exception_do (let: "x" := (mem.alloc "x") in
    let: "val" := (mem.alloc "val") in
    do:  (let: "$a0" := (struct.field_ref #Uint32 #"v"%go (![#ptrT] "x")) in
    let: "$a1" := (![#uint32T] "val") in
    (func_call #StoreUint32) "$a0" "$a1");;;
    return: #()).

(* Swap atomically stores new into x and returns the previous value.

   go: type.go:143:18 *)
Definition Uint32__Swapⁱᵐᵖˡ : val :=
  λ: "x" "new",
    exception_do (let: "old" := (mem.alloc (type.zero_val #uint32T)) in
    let: "x" := (mem.alloc "x") in
    let: "new" := (mem.alloc "new") in
    return: (let: "$a0" := (struct.field_ref #Uint32 #"v"%go (![#ptrT] "x")) in
     let: "$a1" := (![#uint32T] "new") in
     (func_call #SwapUint32) "$a0" "$a1")).

(* CompareAndSwap executes the compare-and-swap operation for x.

   go: type.go:146:18 *)
Definition Uint32__CompareAndSwapⁱᵐᵖˡ : val :=
  λ: "x" "old" "new",
    exception_do (let: "swapped" := (mem.alloc (type.zero_val #boolT)) in
    let: "x" := (mem.alloc "x") in
    let: "new" := (mem.alloc "new") in
    let: "old" := (mem.alloc "old") in
    return: (let: "$a0" := (struct.field_ref #Uint32 #"v"%go (![#ptrT] "x")) in
     let: "$a1" := (![#uint32T] "old") in
     let: "$a2" := (![#uint32T] "new") in
     (func_call #CompareAndSwapUint32) "$a0" "$a1" "$a2")).

(* Add atomically adds delta to x and returns the new value.

   go: type.go:151:18 *)
Definition Uint32__Addⁱᵐᵖˡ : val :=
  λ: "x" "delta",
    exception_do (let: "new" := (mem.alloc (type.zero_val #uint32T)) in
    let: "x" := (mem.alloc "x") in
    let: "delta" := (mem.alloc "delta") in
    return: (let: "$a0" := (struct.field_ref #Uint32 #"v"%go (![#ptrT] "x")) in
     let: "$a1" := (![#uint32T] "delta") in
     (func_call #AddUint32) "$a0" "$a1")).

(* And atomically performs a bitwise AND operation on x using the bitmask
   provided as mask and returns the old value.

   go: type.go:155:18 *)
Definition Uint32__Andⁱᵐᵖˡ : val :=
  λ: "x" "mask",
    exception_do (let: "old" := (mem.alloc (type.zero_val #uint32T)) in
    let: "x" := (mem.alloc "x") in
    let: "mask" := (mem.alloc "mask") in
    return: (let: "$a0" := (struct.field_ref #Uint32 #"v"%go (![#ptrT] "x")) in
     let: "$a1" := (![#uint32T] "mask") in
     (func_call #AndUint32) "$a0" "$a1")).

(* Or atomically performs a bitwise OR operation on x using the bitmask
   provided as mask and returns the old value.

   go: type.go:159:18 *)
Definition Uint32__Orⁱᵐᵖˡ : val :=
  λ: "x" "mask",
    exception_do (let: "old" := (mem.alloc (type.zero_val #uint32T)) in
    let: "x" := (mem.alloc "x") in
    let: "mask" := (mem.alloc "mask") in
    return: (let: "$a0" := (struct.field_ref #Uint32 #"v"%go (![#ptrT] "x")) in
     let: "$a1" := (![#uint32T] "mask") in
     (func_call #OrUint32) "$a0" "$a1")).

Definition Uint64 : go_type := structT [
  "_0" :: noCopy;
  "_1" :: align64;
  "v" :: uint64T
].
#[global] Typeclasses Opaque Uint64.
#[global] Opaque Uint64.

(* Load atomically loads and returns the value stored in x.

   go: type.go:169:18 *)
Definition Uint64__Loadⁱᵐᵖˡ : val :=
  λ: "x" <>,
    exception_do (let: "x" := (mem.alloc "x") in
    return: (let: "$a0" := (struct.field_ref #Uint64 #"v"%go (![#ptrT] "x")) in
     (func_call #LoadUint64) "$a0")).

(* Store atomically stores val into x.

   go: type.go:172:18 *)
Definition Uint64__Storeⁱᵐᵖˡ : val :=
  λ: "x" "val",
    exception_do (let: "x" := (mem.alloc "x") in
    let: "val" := (mem.alloc "val") in
    do:  (let: "$a0" := (struct.field_ref #Uint64 #"v"%go (![#ptrT] "x")) in
    let: "$a1" := (![#uint64T] "val") in
    (func_call #StoreUint64) "$a0" "$a1");;;
    return: #()).

(* Swap atomically stores new into x and returns the previous value.

   go: type.go:175:18 *)
Definition Uint64__Swapⁱᵐᵖˡ : val :=
  λ: "x" "new",
    exception_do (let: "old" := (mem.alloc (type.zero_val #uint64T)) in
    let: "x" := (mem.alloc "x") in
    let: "new" := (mem.alloc "new") in
    return: (let: "$a0" := (struct.field_ref #Uint64 #"v"%go (![#ptrT] "x")) in
     let: "$a1" := (![#uint64T] "new") in
     (func_call #SwapUint64) "$a0" "$a1")).

(* CompareAndSwap executes the compare-and-swap operation for x.

   go: type.go:178:18 *)
Definition Uint64__CompareAndSwapⁱᵐᵖˡ : val :=
  λ: "x" "old" "new",
    exception_do (let: "swapped" := (mem.alloc (type.zero_val #boolT)) in
    let: "x" := (mem.alloc "x") in
    let: "new" := (mem.alloc "new") in
    let: "old" := (mem.alloc "old") in
    return: (let: "$a0" := (struct.field_ref #Uint64 #"v"%go (![#ptrT] "x")) in
     let: "$a1" := (![#uint64T] "old") in
     let: "$a2" := (![#uint64T] "new") in
     (func_call #CompareAndSwapUint64) "$a0" "$a1" "$a2")).

(* Add atomically adds delta to x and returns the new value.

   go: type.go:183:18 *)
Definition Uint64__Addⁱᵐᵖˡ : val :=
  λ: "x" "delta",
    exception_do (let: "new" := (mem.alloc (type.zero_val #uint64T)) in
    let: "x" := (mem.alloc "x") in
    let: "delta" := (mem.alloc "delta") in
    return: (let: "$a0" := (struct.field_ref #Uint64 #"v"%go (![#ptrT] "x")) in
     let: "$a1" := (![#uint64T] "delta") in
     (func_call #AddUint64) "$a0" "$a1")).

(* And atomically performs a bitwise AND operation on x using the bitmask
   provided as mask and returns the old value.

   go: type.go:187:18 *)
Definition Uint64__Andⁱᵐᵖˡ : val :=
  λ: "x" "mask",
    exception_do (let: "old" := (mem.alloc (type.zero_val #uint64T)) in
    let: "x" := (mem.alloc "x") in
    let: "mask" := (mem.alloc "mask") in
    return: (let: "$a0" := (struct.field_ref #Uint64 #"v"%go (![#ptrT] "x")) in
     let: "$a1" := (![#uint64T] "mask") in
     (func_call #AndUint64) "$a0" "$a1")).

(* Or atomically performs a bitwise OR operation on x using the bitmask
   provided as mask and returns the old value.

   go: type.go:191:18 *)
Definition Uint64__Orⁱᵐᵖˡ : val :=
  λ: "x" "mask",
    exception_do (let: "old" := (mem.alloc (type.zero_val #uint64T)) in
    let: "x" := (mem.alloc "x") in
    let: "mask" := (mem.alloc "mask") in
    return: (let: "$a0" := (struct.field_ref #Uint64 #"v"%go (![#ptrT] "x")) in
     let: "$a1" := (![#uint64T] "mask") in
     (func_call #OrUint64) "$a0" "$a1")).

Axiom Uintptr : go_type.

Definition Value : go_type := structT [
  "v" :: interfaceT
].
#[global] Typeclasses Opaque Value.
#[global] Opaque Value.

Definition efaceWords : go_type := structT [
  "typ" :: ptrT;
  "data" :: ptrT
].
#[global] Typeclasses Opaque efaceWords.
#[global] Opaque efaceWords.

Definition firstStoreInProgress : go_string := "sync/atomic.firstStoreInProgress"%go.

(* Load returns the value set by the most recent Store.
   It returns nil if there has been no call to Store for this Value.

   go: value.go:28:17 *)
Definition Value__Loadⁱᵐᵖˡ : val :=
  λ: "v" <>,
    exception_do (let: "val" := (mem.alloc (type.zero_val #interfaceT)) in
    let: "v" := (mem.alloc "v") in
    let: "vp" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (![#ptrT] "v") in
    do:  ("vp" <-[#ptrT] "$r0");;;
    let: "typ" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := (struct.field_ref #efaceWords #"typ"%go (![#ptrT] "vp")) in
    (func_call #LoadPointer) "$a0") in
    do:  ("typ" <-[#ptrT] "$r0");;;
    (if: ((![#ptrT] "typ") = #null) || ((![#ptrT] "typ") = (globals.get #firstStoreInProgress))
    then return: (#interface.nil)
    else do:  #());;;
    let: "data" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := (struct.field_ref #efaceWords #"data"%go (![#ptrT] "vp")) in
    (func_call #LoadPointer) "$a0") in
    do:  ("data" <-[#ptrT] "$r0");;;
    let: "vlp" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := "val" in
    do:  ("vlp" <-[#ptrT] "$r0");;;
    let: "$r0" := (![#ptrT] "typ") in
    do:  ((struct.field_ref #efaceWords #"typ"%go (![#ptrT] "vlp")) <-[#ptrT] "$r0");;;
    let: "$r0" := (![#ptrT] "data") in
    do:  ((struct.field_ref #efaceWords #"data"%go (![#ptrT] "vlp")) <-[#ptrT] "$r0");;;
    return: (![#interfaceT] "val")).

Definition runtime_procUnpin : go_string := "sync/atomic.runtime_procUnpin"%go.

Definition runtime_procPin : go_string := "sync/atomic.runtime_procPin"%go.

(* Store sets the value of the [Value] v to val.
   All calls to Store for a given Value must use values of the same concrete type.
   Store of an inconsistent type panics, as does Store(nil).

   go: value.go:47:17 *)
Definition Value__Storeⁱᵐᵖˡ : val :=
  λ: "v" "val",
    exception_do (let: "v" := (mem.alloc "v") in
    let: "val" := (mem.alloc "val") in
    (if: interface.eq (![#interfaceT] "val") #interface.nil
    then
      do:  (let: "$a0" := (interface.make #stringT.id #"sync/atomic: store of nil value into Value"%go) in
      Panic "$a0")
    else do:  #());;;
    let: "vp" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (![#ptrT] "v") in
    do:  ("vp" <-[#ptrT] "$r0");;;
    let: "vlp" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := "val" in
    do:  ("vlp" <-[#ptrT] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "typ" := (mem.alloc (type.zero_val #ptrT)) in
      let: "$r0" := (let: "$a0" := (struct.field_ref #efaceWords #"typ"%go (![#ptrT] "vp")) in
      (func_call #LoadPointer) "$a0") in
      do:  ("typ" <-[#ptrT] "$r0");;;
      (if: (![#ptrT] "typ") = #null
      then
        do:  ((func_call #runtime_procPin) #());;;
        (if: (~ (let: "$a0" := (struct.field_ref #efaceWords #"typ"%go (![#ptrT] "vp")) in
        let: "$a1" := #null in
        let: "$a2" := (globals.get #firstStoreInProgress) in
        (func_call #CompareAndSwapPointer) "$a0" "$a1" "$a2"))
        then
          do:  ((func_call #runtime_procUnpin) #());;;
          continue: #()
        else do:  #());;;
        do:  (let: "$a0" := (struct.field_ref #efaceWords #"data"%go (![#ptrT] "vp")) in
        let: "$a1" := (![#ptrT] (struct.field_ref #efaceWords #"data"%go (![#ptrT] "vlp"))) in
        (func_call #StorePointer) "$a0" "$a1");;;
        do:  (let: "$a0" := (struct.field_ref #efaceWords #"typ"%go (![#ptrT] "vp")) in
        let: "$a1" := (![#ptrT] (struct.field_ref #efaceWords #"typ"%go (![#ptrT] "vlp"))) in
        (func_call #StorePointer) "$a0" "$a1");;;
        do:  ((func_call #runtime_procUnpin) #());;;
        return: (#())
      else do:  #());;;
      (if: (![#ptrT] "typ") = (globals.get #firstStoreInProgress)
      then continue: #()
      else do:  #());;;
      (if: (![#ptrT] "typ") ≠ (![#ptrT] (struct.field_ref #efaceWords #"typ"%go (![#ptrT] "vlp")))
      then
        do:  (let: "$a0" := (interface.make #stringT.id #"sync/atomic: store of inconsistently typed value into Value"%go) in
        Panic "$a0")
      else do:  #());;;
      do:  (let: "$a0" := (struct.field_ref #efaceWords #"data"%go (![#ptrT] "vp")) in
      let: "$a1" := (![#ptrT] (struct.field_ref #efaceWords #"data"%go (![#ptrT] "vlp"))) in
      (func_call #StorePointer) "$a0" "$a1");;;
      return: (#()));;;
    return: #()).

(* Swap stores new into Value and returns the previous value. It returns nil if
   the Value is empty.

   All calls to Swap for a given Value must use values of the same concrete
   type. Swap of an inconsistent type panics, as does Swap(nil).

   go: value.go:90:17 *)
Definition Value__Swapⁱᵐᵖˡ : val :=
  λ: "v" "new",
    exception_do (let: "old" := (mem.alloc (type.zero_val #interfaceT)) in
    let: "v" := (mem.alloc "v") in
    let: "new" := (mem.alloc "new") in
    (if: interface.eq (![#interfaceT] "new") #interface.nil
    then
      do:  (let: "$a0" := (interface.make #stringT.id #"sync/atomic: swap of nil value into Value"%go) in
      Panic "$a0")
    else do:  #());;;
    let: "vp" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (![#ptrT] "v") in
    do:  ("vp" <-[#ptrT] "$r0");;;
    let: "np" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := "new" in
    do:  ("np" <-[#ptrT] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "typ" := (mem.alloc (type.zero_val #ptrT)) in
      let: "$r0" := (let: "$a0" := (struct.field_ref #efaceWords #"typ"%go (![#ptrT] "vp")) in
      (func_call #LoadPointer) "$a0") in
      do:  ("typ" <-[#ptrT] "$r0");;;
      (if: (![#ptrT] "typ") = #null
      then
        do:  ((func_call #runtime_procPin) #());;;
        (if: (~ (let: "$a0" := (struct.field_ref #efaceWords #"typ"%go (![#ptrT] "vp")) in
        let: "$a1" := #null in
        let: "$a2" := (globals.get #firstStoreInProgress) in
        (func_call #CompareAndSwapPointer) "$a0" "$a1" "$a2"))
        then
          do:  ((func_call #runtime_procUnpin) #());;;
          continue: #()
        else do:  #());;;
        do:  (let: "$a0" := (struct.field_ref #efaceWords #"data"%go (![#ptrT] "vp")) in
        let: "$a1" := (![#ptrT] (struct.field_ref #efaceWords #"data"%go (![#ptrT] "np"))) in
        (func_call #StorePointer) "$a0" "$a1");;;
        do:  (let: "$a0" := (struct.field_ref #efaceWords #"typ"%go (![#ptrT] "vp")) in
        let: "$a1" := (![#ptrT] (struct.field_ref #efaceWords #"typ"%go (![#ptrT] "np"))) in
        (func_call #StorePointer) "$a0" "$a1");;;
        do:  ((func_call #runtime_procUnpin) #());;;
        return: (#interface.nil)
      else do:  #());;;
      (if: (![#ptrT] "typ") = (globals.get #firstStoreInProgress)
      then continue: #()
      else do:  #());;;
      (if: (![#ptrT] "typ") ≠ (![#ptrT] (struct.field_ref #efaceWords #"typ"%go (![#ptrT] "np")))
      then
        do:  (let: "$a0" := (interface.make #stringT.id #"sync/atomic: swap of inconsistently typed value into Value"%go) in
        Panic "$a0")
      else do:  #());;;
      let: "op" := (mem.alloc (type.zero_val #ptrT)) in
      let: "$r0" := "old" in
      do:  ("op" <-[#ptrT] "$r0");;;
      let: "$r0" := (![#ptrT] (struct.field_ref #efaceWords #"typ"%go (![#ptrT] "np"))) in
      let: "$r1" := (let: "$a0" := (struct.field_ref #efaceWords #"data"%go (![#ptrT] "vp")) in
      let: "$a1" := (![#ptrT] (struct.field_ref #efaceWords #"data"%go (![#ptrT] "np"))) in
      (func_call #SwapPointer) "$a0" "$a1") in
      do:  ((struct.field_ref #efaceWords #"typ"%go (![#ptrT] "op")) <-[#ptrT] "$r0");;;
      do:  ((struct.field_ref #efaceWords #"data"%go (![#ptrT] "op")) <-[#ptrT] "$r1");;;
      return: (![#interfaceT] "old"))).

(* CompareAndSwap executes the compare-and-swap operation for the [Value].

   All calls to CompareAndSwap for a given Value must use values of the same
   concrete type. CompareAndSwap of an inconsistent type panics, as does
   CompareAndSwap(old, nil).

   go: value.go:135:17 *)
Definition Value__CompareAndSwapⁱᵐᵖˡ : val :=
  λ: "v" "old" "new",
    exception_do (let: "swapped" := (mem.alloc (type.zero_val #boolT)) in
    let: "v" := (mem.alloc "v") in
    let: "new" := (mem.alloc "new") in
    let: "old" := (mem.alloc "old") in
    (if: interface.eq (![#interfaceT] "new") #interface.nil
    then
      do:  (let: "$a0" := (interface.make #stringT.id #"sync/atomic: compare and swap of nil value into Value"%go) in
      Panic "$a0")
    else do:  #());;;
    let: "vp" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (![#ptrT] "v") in
    do:  ("vp" <-[#ptrT] "$r0");;;
    let: "np" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := "new" in
    do:  ("np" <-[#ptrT] "$r0");;;
    let: "op" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := "old" in
    do:  ("op" <-[#ptrT] "$r0");;;
    (if: ((![#ptrT] (struct.field_ref #efaceWords #"typ"%go (![#ptrT] "op"))) ≠ #null) && ((![#ptrT] (struct.field_ref #efaceWords #"typ"%go (![#ptrT] "np"))) ≠ (![#ptrT] (struct.field_ref #efaceWords #"typ"%go (![#ptrT] "op"))))
    then
      do:  (let: "$a0" := (interface.make #stringT.id #"sync/atomic: compare and swap of inconsistently typed values"%go) in
      Panic "$a0")
    else do:  #());;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "typ" := (mem.alloc (type.zero_val #ptrT)) in
      let: "$r0" := (let: "$a0" := (struct.field_ref #efaceWords #"typ"%go (![#ptrT] "vp")) in
      (func_call #LoadPointer) "$a0") in
      do:  ("typ" <-[#ptrT] "$r0");;;
      (if: (![#ptrT] "typ") = #null
      then
        (if: (~ (interface.eq (![#interfaceT] "old") #interface.nil))
        then return: (#false)
        else do:  #());;;
        do:  ((func_call #runtime_procPin) #());;;
        (if: (~ (let: "$a0" := (struct.field_ref #efaceWords #"typ"%go (![#ptrT] "vp")) in
        let: "$a1" := #null in
        let: "$a2" := (globals.get #firstStoreInProgress) in
        (func_call #CompareAndSwapPointer) "$a0" "$a1" "$a2"))
        then
          do:  ((func_call #runtime_procUnpin) #());;;
          continue: #()
        else do:  #());;;
        do:  (let: "$a0" := (struct.field_ref #efaceWords #"data"%go (![#ptrT] "vp")) in
        let: "$a1" := (![#ptrT] (struct.field_ref #efaceWords #"data"%go (![#ptrT] "np"))) in
        (func_call #StorePointer) "$a0" "$a1");;;
        do:  (let: "$a0" := (struct.field_ref #efaceWords #"typ"%go (![#ptrT] "vp")) in
        let: "$a1" := (![#ptrT] (struct.field_ref #efaceWords #"typ"%go (![#ptrT] "np"))) in
        (func_call #StorePointer) "$a0" "$a1");;;
        do:  ((func_call #runtime_procUnpin) #());;;
        return: (#true)
      else do:  #());;;
      (if: (![#ptrT] "typ") = (globals.get #firstStoreInProgress)
      then continue: #()
      else do:  #());;;
      (if: (![#ptrT] "typ") ≠ (![#ptrT] (struct.field_ref #efaceWords #"typ"%go (![#ptrT] "np")))
      then
        do:  (let: "$a0" := (interface.make #stringT.id #"sync/atomic: compare and swap of inconsistently typed value into Value"%go) in
        Panic "$a0")
      else do:  #());;;
      let: "data" := (mem.alloc (type.zero_val #ptrT)) in
      let: "$r0" := (let: "$a0" := (struct.field_ref #efaceWords #"data"%go (![#ptrT] "vp")) in
      (func_call #LoadPointer) "$a0") in
      do:  ("data" <-[#ptrT] "$r0");;;
      let: "i" := (mem.alloc (type.zero_val #interfaceT)) in
      let: "$r0" := (![#ptrT] "typ") in
      do:  ((struct.field_ref #efaceWords #"typ"%go "i") <-[#ptrT] "$r0");;;
      let: "$r0" := (![#ptrT] "data") in
      do:  ((struct.field_ref #efaceWords #"data"%go "i") <-[#ptrT] "$r0");;;
      (if: (~ (interface.eq (![#interfaceT] "i") (![#interfaceT] "old")))
      then return: (#false)
      else do:  #());;;
      return: (let: "$a0" := (struct.field_ref #efaceWords #"data"%go (![#ptrT] "vp")) in
       let: "$a1" := (![#ptrT] "data") in
       let: "$a2" := (![#ptrT] (struct.field_ref #efaceWords #"data"%go (![#ptrT] "np"))) in
       (func_call #CompareAndSwapPointer) "$a0" "$a1" "$a2"))).

Definition vars' : list (go_string * go_type) := [].

Axiom SwapUintptrⁱᵐᵖˡ : val.

Axiom SwapPointerⁱᵐᵖˡ : val.

Axiom CompareAndSwapUintptrⁱᵐᵖˡ : val.

Axiom CompareAndSwapPointerⁱᵐᵖˡ : val.

Axiom AddUintptrⁱᵐᵖˡ : val.

Axiom AndInt32ⁱᵐᵖˡ : val.

Axiom AndUint32ⁱᵐᵖˡ : val.

Axiom AndUintptrⁱᵐᵖˡ : val.

Axiom OrInt32ⁱᵐᵖˡ : val.

Axiom OrUint32ⁱᵐᵖˡ : val.

Axiom OrUintptrⁱᵐᵖˡ : val.

Axiom LoadUintptrⁱᵐᵖˡ : val.

Axiom LoadPointerⁱᵐᵖˡ : val.

Axiom StoreUintptrⁱᵐᵖˡ : val.

Axiom StorePointerⁱᵐᵖˡ : val.

Axiom AndInt64ⁱᵐᵖˡ : val.

Axiom AndUint64ⁱᵐᵖˡ : val.

Axiom OrInt64ⁱᵐᵖˡ : val.

Axiom OrUint64ⁱᵐᵖˡ : val.

Axiom runtime_procPinⁱᵐᵖˡ : val.

Axiom runtime_procUnpinⁱᵐᵖˡ : val.

Definition functions' : list (go_string * val) := [(SwapInt32, SwapInt32ⁱᵐᵖˡ); (SwapUint32, SwapUint32ⁱᵐᵖˡ); (SwapUintptr, SwapUintptrⁱᵐᵖˡ); (SwapPointer, SwapPointerⁱᵐᵖˡ); (CompareAndSwapInt32, CompareAndSwapInt32ⁱᵐᵖˡ); (CompareAndSwapUint32, CompareAndSwapUint32ⁱᵐᵖˡ); (CompareAndSwapUintptr, CompareAndSwapUintptrⁱᵐᵖˡ); (CompareAndSwapPointer, CompareAndSwapPointerⁱᵐᵖˡ); (AddInt32, AddInt32ⁱᵐᵖˡ); (AddUint32, AddUint32ⁱᵐᵖˡ); (AddUintptr, AddUintptrⁱᵐᵖˡ); (AndInt32, AndInt32ⁱᵐᵖˡ); (AndUint32, AndUint32ⁱᵐᵖˡ); (AndUintptr, AndUintptrⁱᵐᵖˡ); (OrInt32, OrInt32ⁱᵐᵖˡ); (OrUint32, OrUint32ⁱᵐᵖˡ); (OrUintptr, OrUintptrⁱᵐᵖˡ); (LoadInt32, LoadInt32ⁱᵐᵖˡ); (LoadUint32, LoadUint32ⁱᵐᵖˡ); (LoadUintptr, LoadUintptrⁱᵐᵖˡ); (LoadPointer, LoadPointerⁱᵐᵖˡ); (StoreInt32, StoreInt32ⁱᵐᵖˡ); (StoreUint32, StoreUint32ⁱᵐᵖˡ); (StoreUintptr, StoreUintptrⁱᵐᵖˡ); (StorePointer, StorePointerⁱᵐᵖˡ); (SwapInt64, SwapInt64ⁱᵐᵖˡ); (SwapUint64, SwapUint64ⁱᵐᵖˡ); (CompareAndSwapInt64, CompareAndSwapInt64ⁱᵐᵖˡ); (CompareAndSwapUint64, CompareAndSwapUint64ⁱᵐᵖˡ); (AddInt64, AddInt64ⁱᵐᵖˡ); (AddUint64, AddUint64ⁱᵐᵖˡ); (AndInt64, AndInt64ⁱᵐᵖˡ); (AndUint64, AndUint64ⁱᵐᵖˡ); (OrInt64, OrInt64ⁱᵐᵖˡ); (OrUint64, OrUint64ⁱᵐᵖˡ); (LoadInt64, LoadInt64ⁱᵐᵖˡ); (LoadUint64, LoadUint64ⁱᵐᵖˡ); (StoreInt64, StoreInt64ⁱᵐᵖˡ); (StoreUint64, StoreUint64ⁱᵐᵖˡ); (b32, b32ⁱᵐᵖˡ); (runtime_procPin, runtime_procPinⁱᵐᵖˡ); (runtime_procUnpin, runtime_procUnpinⁱᵐᵖˡ)].

Axiom Uintptr__Addⁱᵐᵖˡ : val.

Axiom Uintptr__Andⁱᵐᵖˡ : val.

Axiom Uintptr__CompareAndSwapⁱᵐᵖˡ : val.

Axiom Uintptr__Loadⁱᵐᵖˡ : val.

Axiom Uintptr__Orⁱᵐᵖˡ : val.

Axiom Uintptr__Storeⁱᵐᵖˡ : val.

Axiom Uintptr__Swapⁱᵐᵖˡ : val.

Axiom noCopy__Lockⁱᵐᵖˡ : val.

Axiom noCopy__Unlockⁱᵐᵖˡ : val.

Definition msets' : list (go_string * (list (go_string * val))) := [(Bool.id, []); (ptrT.id Bool.id, [("CompareAndSwap"%go, Bool__CompareAndSwapⁱᵐᵖˡ); ("Load"%go, Bool__Loadⁱᵐᵖˡ); ("Store"%go, Bool__Storeⁱᵐᵖˡ); ("Swap"%go, Bool__Swapⁱᵐᵖˡ)]); (Pointer.id, []); (ptrT.id Pointer.id, [("CompareAndSwap"%go, Pointer__CompareAndSwapⁱᵐᵖˡ); ("Load"%go, Pointer__Loadⁱᵐᵖˡ); ("Store"%go, Pointer__Storeⁱᵐᵖˡ); ("Swap"%go, Pointer__Swapⁱᵐᵖˡ)]); (Int32.id, []); (ptrT.id Int32.id, [("Add"%go, Int32__Addⁱᵐᵖˡ); ("And"%go, Int32__Andⁱᵐᵖˡ); ("CompareAndSwap"%go, Int32__CompareAndSwapⁱᵐᵖˡ); ("Load"%go, Int32__Loadⁱᵐᵖˡ); ("Or"%go, Int32__Orⁱᵐᵖˡ); ("Store"%go, Int32__Storeⁱᵐᵖˡ); ("Swap"%go, Int32__Swapⁱᵐᵖˡ)]); (Int64.id, []); (ptrT.id Int64.id, [("Add"%go, Int64__Addⁱᵐᵖˡ); ("And"%go, Int64__Andⁱᵐᵖˡ); ("CompareAndSwap"%go, Int64__CompareAndSwapⁱᵐᵖˡ); ("Load"%go, Int64__Loadⁱᵐᵖˡ); ("Or"%go, Int64__Orⁱᵐᵖˡ); ("Store"%go, Int64__Storeⁱᵐᵖˡ); ("Swap"%go, Int64__Swapⁱᵐᵖˡ)]); (Uint32.id, []); (ptrT.id Uint32.id, [("Add"%go, Uint32__Addⁱᵐᵖˡ); ("And"%go, Uint32__Andⁱᵐᵖˡ); ("CompareAndSwap"%go, Uint32__CompareAndSwapⁱᵐᵖˡ); ("Load"%go, Uint32__Loadⁱᵐᵖˡ); ("Or"%go, Uint32__Orⁱᵐᵖˡ); ("Store"%go, Uint32__Storeⁱᵐᵖˡ); ("Swap"%go, Uint32__Swapⁱᵐᵖˡ)]); (Uint64.id, []); (ptrT.id Uint64.id, [("Add"%go, Uint64__Addⁱᵐᵖˡ); ("And"%go, Uint64__Andⁱᵐᵖˡ); ("CompareAndSwap"%go, Uint64__CompareAndSwapⁱᵐᵖˡ); ("Load"%go, Uint64__Loadⁱᵐᵖˡ); ("Or"%go, Uint64__Orⁱᵐᵖˡ); ("Store"%go, Uint64__Storeⁱᵐᵖˡ); ("Swap"%go, Uint64__Swapⁱᵐᵖˡ)]); (Uintptr.id, []); (ptrT.id Uintptr.id, [("Add"%go, Uintptr__Addⁱᵐᵖˡ); ("And"%go, Uintptr__Andⁱᵐᵖˡ); ("CompareAndSwap"%go, Uintptr__CompareAndSwapⁱᵐᵖˡ); ("Load"%go, Uintptr__Loadⁱᵐᵖˡ); ("Or"%go, Uintptr__Orⁱᵐᵖˡ); ("Store"%go, Uintptr__Storeⁱᵐᵖˡ); ("Swap"%go, Uintptr__Swapⁱᵐᵖˡ)]); (noCopy.id, []); (ptrT.id noCopy.id, [("Lock"%go, noCopy__Lockⁱᵐᵖˡ); ("Unlock"%go, noCopy__Unlockⁱᵐᵖˡ)]); (align64.id, []); (ptrT.id align64.id, []); (Value.id, []); (ptrT.id Value.id, [("CompareAndSwap"%go, Value__CompareAndSwapⁱᵐᵖˡ); ("Load"%go, Value__Loadⁱᵐᵖˡ); ("Store"%go, Value__Storeⁱᵐᵖˡ); ("Swap"%go, Value__Swapⁱᵐᵖˡ)]); (efaceWords.id, []); (ptrT.id efaceWords.id, [])].

#[global] Instance info' : PkgInfo atomic.atomic :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [];
  |}.

Definition initialize' : val :=
  λ: <>,
    package.init #atomic.atomic (λ: <>,
      exception_do (do:  (package.alloc atomic.atomic #());;;
      let: "$r0" := (mem.alloc (struct.make (Pointer #intT) [{
        "_0" ::= type.zero_val (type.arrayT #(W64 0) #ptrT);
        "_1" ::= type.zero_val #noCopy;
        "v" ::= type.zero_val #ptrT
      }])) in
      do:  #())
      ).

End code.
End atomic.
