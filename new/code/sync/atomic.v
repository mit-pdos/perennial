(* autogenerated from sync/atomic *)
From New.golang Require Import defn.
Require Export New.trusted_code.sync.atomic.
Import atomic.
Module pkg_id.
Definition atomic : go_string := "sync/atomic".

End pkg_id.
Export pkg_id.
Module atomic.

Definition Bool {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "sync/atomic.Bool"%go [].

Definition Pointer {ext : ffi_syntax} {go_gctx : GoGlobalContext} (T : go.type) : go.type := go.Named "sync/atomic.Pointer"%go [T].

Definition Int32 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "sync/atomic.Int32"%go [].

Definition Int64 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "sync/atomic.Int64"%go [].

Definition Uint32 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "sync/atomic.Uint32"%go [].

Definition Uint64 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "sync/atomic.Uint64"%go [].

Definition Uintptr {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "sync/atomic.Uintptr"%go [].

Definition noCopy {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "sync/atomic.noCopy"%go [].

Definition align64 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "sync/atomic.align64"%go [].

Definition Value {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "sync/atomic.Value"%go [].

Definition efaceWords {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "sync/atomic.efaceWords"%go [].

Axiom Uintptrⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Definition firstStoreInProgress {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync/atomic.firstStoreInProgress"%go.

Definition SwapInt32 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync/atomic.SwapInt32"%go.

Definition SwapUint32 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync/atomic.SwapUint32"%go.

Definition SwapUintptr {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync/atomic.SwapUintptr"%go.

Definition SwapPointer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync/atomic.SwapPointer"%go.

Definition CompareAndSwapInt32 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync/atomic.CompareAndSwapInt32"%go.

Definition CompareAndSwapUint32 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync/atomic.CompareAndSwapUint32"%go.

Definition CompareAndSwapUintptr {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync/atomic.CompareAndSwapUintptr"%go.

Definition CompareAndSwapPointer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync/atomic.CompareAndSwapPointer"%go.

Definition AddInt32 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync/atomic.AddInt32"%go.

Definition AddUint32 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync/atomic.AddUint32"%go.

Definition AddUintptr {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync/atomic.AddUintptr"%go.

Definition AndInt32 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync/atomic.AndInt32"%go.

Definition AndUint32 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync/atomic.AndUint32"%go.

Definition AndUintptr {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync/atomic.AndUintptr"%go.

Definition OrInt32 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync/atomic.OrInt32"%go.

Definition OrUint32 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync/atomic.OrUint32"%go.

Definition OrUintptr {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync/atomic.OrUintptr"%go.

Definition LoadInt32 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync/atomic.LoadInt32"%go.

Definition LoadUint32 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync/atomic.LoadUint32"%go.

Definition LoadUintptr {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync/atomic.LoadUintptr"%go.

Definition LoadPointer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync/atomic.LoadPointer"%go.

Definition StoreInt32 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync/atomic.StoreInt32"%go.

Definition StoreUint32 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync/atomic.StoreUint32"%go.

Definition StoreUintptr {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync/atomic.StoreUintptr"%go.

Definition StorePointer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync/atomic.StorePointer"%go.

Definition SwapInt64 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync/atomic.SwapInt64"%go.

Definition SwapUint64 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync/atomic.SwapUint64"%go.

Definition CompareAndSwapInt64 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync/atomic.CompareAndSwapInt64"%go.

Definition CompareAndSwapUint64 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync/atomic.CompareAndSwapUint64"%go.

Definition AddInt64 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync/atomic.AddInt64"%go.

Definition AddUint64 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync/atomic.AddUint64"%go.

Definition AndInt64 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync/atomic.AndInt64"%go.

Definition AndUint64 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync/atomic.AndUint64"%go.

Definition OrInt64 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync/atomic.OrInt64"%go.

Definition OrUint64 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync/atomic.OrUint64"%go.

Definition LoadInt64 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync/atomic.LoadInt64"%go.

Definition LoadUint64 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync/atomic.LoadUint64"%go.

Definition StoreInt64 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync/atomic.StoreInt64"%go.

Definition StoreUint64 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync/atomic.StoreUint64"%go.

Definition b32 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync/atomic.b32"%go.

Definition runtime_procPin {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync/atomic.runtime_procPin"%go.

Definition runtime_procUnpin {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync/atomic.runtime_procUnpin"%go.

(* Load atomically loads and returns the value stored in x.

   go: type.go:19:16 *)
Definition Bool__Loadⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x" <>,
    exception_do (let: "x" := (GoAlloc (go.PointerType Bool) "x") in
    return: ((let: "$a0" := (StructFieldRef Bool "v"%go (![go.PointerType Bool] "x")) in
     (FuncResolve LoadUint32 [] #()) "$a0") ≠⟨go.uint32⟩ #(W32 0))).

(* Store atomically stores val into x.

   go: type.go:22:16 *)
Definition Bool__Storeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x" "val",
    exception_do (let: "x" := (GoAlloc (go.PointerType Bool) "x") in
    let: "val" := (GoAlloc go.bool "val") in
    do:  (let: "$a0" := (StructFieldRef Bool "v"%go (![go.PointerType Bool] "x")) in
    let: "$a1" := (let: "$a0" := (![go.bool] "val") in
    (FuncResolve b32 [] #()) "$a0") in
    (FuncResolve StoreUint32 [] #()) "$a0" "$a1");;;
    return: #()).

(* Swap atomically stores new into x and returns the previous value.

   go: type.go:25:16 *)
Definition Bool__Swapⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x" "new",
    exception_do (let: "old" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "x" := (GoAlloc (go.PointerType Bool) "x") in
    let: "new" := (GoAlloc go.bool "new") in
    return: ((let: "$a0" := (StructFieldRef Bool "v"%go (![go.PointerType Bool] "x")) in
     let: "$a1" := (let: "$a0" := (![go.bool] "new") in
     (FuncResolve b32 [] #()) "$a0") in
     (FuncResolve SwapUint32 [] #()) "$a0" "$a1") ≠⟨go.uint32⟩ #(W32 0))).

(* CompareAndSwap executes the compare-and-swap operation for the boolean value x.

   go: type.go:28:16 *)
Definition Bool__CompareAndSwapⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x" "old" "new",
    exception_do (let: "swapped" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "x" := (GoAlloc (go.PointerType Bool) "x") in
    let: "new" := (GoAlloc go.bool "new") in
    let: "old" := (GoAlloc go.bool "old") in
    return: (let: "$a0" := (StructFieldRef Bool "v"%go (![go.PointerType Bool] "x")) in
     let: "$a1" := (let: "$a0" := (![go.bool] "old") in
     (FuncResolve b32 [] #()) "$a0") in
     let: "$a2" := (let: "$a0" := (![go.bool] "new") in
     (FuncResolve b32 [] #()) "$a0") in
     (FuncResolve CompareAndSwapUint32 [] #()) "$a0" "$a1" "$a2")).

(* b32 returns a uint32 0 or 1 representing b.

   go: type.go:33:6 *)
Definition b32ⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "b",
    exception_do (let: "b" := (GoAlloc go.bool "b") in
    (if: ![go.bool] "b"
    then return: (#(W32 1))
    else do:  #());;;
    return: (#(W32 0))).

(* Load atomically loads and returns the value stored in x.

   go: type.go:58:22 *)
Definition Pointer__Loadⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} (T : go.type) : val :=
  λ: "x" <>,
    exception_do (let: "x" := (GoAlloc (go.PointerType (Pointer T)) "x") in
    return: (Convert unsafe.Pointer (go.PointerType T) (let: "$a0" := (StructFieldRef (Pointer T) "v"%go (![go.PointerType (Pointer T)] "x")) in
     (FuncResolve LoadPointer [] #()) "$a0"))).

(* Store atomically stores val into x.

   go: type.go:61:22 *)
Definition Pointer__Storeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} (T : go.type) : val :=
  λ: "x" "val",
    exception_do (let: "x" := (GoAlloc (go.PointerType (Pointer T)) "x") in
    let: "val" := (GoAlloc (go.PointerType T) "val") in
    do:  (let: "$a0" := (StructFieldRef (Pointer T) "v"%go (![go.PointerType (Pointer T)] "x")) in
    let: "$a1" := (Convert (go.PointerType T) unsafe.Pointer (![go.PointerType T] "val")) in
    (FuncResolve StorePointer [] #()) "$a0" "$a1");;;
    return: #()).

(* Swap atomically stores new into x and returns the previous value.

   go: type.go:64:22 *)
Definition Pointer__Swapⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} (T : go.type) : val :=
  λ: "x" "new",
    exception_do (let: "old" := (GoAlloc (go.PointerType T) (GoZeroVal (go.PointerType T) #())) in
    let: "x" := (GoAlloc (go.PointerType (Pointer T)) "x") in
    let: "new" := (GoAlloc (go.PointerType T) "new") in
    return: (Convert unsafe.Pointer (go.PointerType T) (let: "$a0" := (StructFieldRef (Pointer T) "v"%go (![go.PointerType (Pointer T)] "x")) in
     let: "$a1" := (Convert (go.PointerType T) unsafe.Pointer (![go.PointerType T] "new")) in
     (FuncResolve SwapPointer [] #()) "$a0" "$a1"))).

(* CompareAndSwap executes the compare-and-swap operation for x.

   go: type.go:67:22 *)
Definition Pointer__CompareAndSwapⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} (T : go.type) : val :=
  λ: "x" "old" "new",
    exception_do (let: "swapped" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "x" := (GoAlloc (go.PointerType (Pointer T)) "x") in
    let: "new" := (GoAlloc (go.PointerType T) "new") in
    let: "old" := (GoAlloc (go.PointerType T) "old") in
    return: (let: "$a0" := (StructFieldRef (Pointer T) "v"%go (![go.PointerType (Pointer T)] "x")) in
     let: "$a1" := (Convert (go.PointerType T) unsafe.Pointer (![go.PointerType T] "old")) in
     let: "$a2" := (Convert (go.PointerType T) unsafe.Pointer (![go.PointerType T] "new")) in
     (FuncResolve CompareAndSwapPointer [] #()) "$a0" "$a1" "$a2")).

(* Load atomically loads and returns the value stored in x.

   go: type.go:80:17 *)
Definition Int32__Loadⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x" <>,
    exception_do (let: "x" := (GoAlloc (go.PointerType Int32) "x") in
    return: (let: "$a0" := (StructFieldRef Int32 "v"%go (![go.PointerType Int32] "x")) in
     (FuncResolve LoadInt32 [] #()) "$a0")).

(* Store atomically stores val into x.

   go: type.go:83:17 *)
Definition Int32__Storeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x" "val",
    exception_do (let: "x" := (GoAlloc (go.PointerType Int32) "x") in
    let: "val" := (GoAlloc go.int32 "val") in
    do:  (let: "$a0" := (StructFieldRef Int32 "v"%go (![go.PointerType Int32] "x")) in
    let: "$a1" := (![go.int32] "val") in
    (FuncResolve StoreInt32 [] #()) "$a0" "$a1");;;
    return: #()).

(* Swap atomically stores new into x and returns the previous value.

   go: type.go:86:17 *)
Definition Int32__Swapⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x" "new",
    exception_do (let: "old" := (GoAlloc go.int32 (GoZeroVal go.int32 #())) in
    let: "x" := (GoAlloc (go.PointerType Int32) "x") in
    let: "new" := (GoAlloc go.int32 "new") in
    return: (let: "$a0" := (StructFieldRef Int32 "v"%go (![go.PointerType Int32] "x")) in
     let: "$a1" := (![go.int32] "new") in
     (FuncResolve SwapInt32 [] #()) "$a0" "$a1")).

(* CompareAndSwap executes the compare-and-swap operation for x.

   go: type.go:89:17 *)
Definition Int32__CompareAndSwapⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x" "old" "new",
    exception_do (let: "swapped" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "x" := (GoAlloc (go.PointerType Int32) "x") in
    let: "new" := (GoAlloc go.int32 "new") in
    let: "old" := (GoAlloc go.int32 "old") in
    return: (let: "$a0" := (StructFieldRef Int32 "v"%go (![go.PointerType Int32] "x")) in
     let: "$a1" := (![go.int32] "old") in
     let: "$a2" := (![go.int32] "new") in
     (FuncResolve CompareAndSwapInt32 [] #()) "$a0" "$a1" "$a2")).

(* Add atomically adds delta to x and returns the new value.

   go: type.go:94:17 *)
Definition Int32__Addⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x" "delta",
    exception_do (let: "new" := (GoAlloc go.int32 (GoZeroVal go.int32 #())) in
    let: "x" := (GoAlloc (go.PointerType Int32) "x") in
    let: "delta" := (GoAlloc go.int32 "delta") in
    return: (let: "$a0" := (StructFieldRef Int32 "v"%go (![go.PointerType Int32] "x")) in
     let: "$a1" := (![go.int32] "delta") in
     (FuncResolve AddInt32 [] #()) "$a0" "$a1")).

(* And atomically performs a bitwise AND operation on x using the bitmask
   provided as mask and returns the old value.

   go: type.go:98:17 *)
Definition Int32__Andⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x" "mask",
    exception_do (let: "old" := (GoAlloc go.int32 (GoZeroVal go.int32 #())) in
    let: "x" := (GoAlloc (go.PointerType Int32) "x") in
    let: "mask" := (GoAlloc go.int32 "mask") in
    return: (let: "$a0" := (StructFieldRef Int32 "v"%go (![go.PointerType Int32] "x")) in
     let: "$a1" := (![go.int32] "mask") in
     (FuncResolve AndInt32 [] #()) "$a0" "$a1")).

(* Or atomically performs a bitwise OR operation on x using the bitmask
   provided as mask and returns the old value.

   go: type.go:102:17 *)
Definition Int32__Orⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x" "mask",
    exception_do (let: "old" := (GoAlloc go.int32 (GoZeroVal go.int32 #())) in
    let: "x" := (GoAlloc (go.PointerType Int32) "x") in
    let: "mask" := (GoAlloc go.int32 "mask") in
    return: (let: "$a0" := (StructFieldRef Int32 "v"%go (![go.PointerType Int32] "x")) in
     let: "$a1" := (![go.int32] "mask") in
     (FuncResolve OrInt32 [] #()) "$a0" "$a1")).

(* Load atomically loads and returns the value stored in x.

   go: type.go:114:17 *)
Definition Int64__Loadⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x" <>,
    exception_do (let: "x" := (GoAlloc (go.PointerType Int64) "x") in
    return: (let: "$a0" := (StructFieldRef Int64 "v"%go (![go.PointerType Int64] "x")) in
     (FuncResolve LoadInt64 [] #()) "$a0")).

(* Store atomically stores val into x.

   go: type.go:117:17 *)
Definition Int64__Storeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x" "val",
    exception_do (let: "x" := (GoAlloc (go.PointerType Int64) "x") in
    let: "val" := (GoAlloc go.int64 "val") in
    do:  (let: "$a0" := (StructFieldRef Int64 "v"%go (![go.PointerType Int64] "x")) in
    let: "$a1" := (![go.int64] "val") in
    (FuncResolve StoreInt64 [] #()) "$a0" "$a1");;;
    return: #()).

(* Swap atomically stores new into x and returns the previous value.

   go: type.go:120:17 *)
Definition Int64__Swapⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x" "new",
    exception_do (let: "old" := (GoAlloc go.int64 (GoZeroVal go.int64 #())) in
    let: "x" := (GoAlloc (go.PointerType Int64) "x") in
    let: "new" := (GoAlloc go.int64 "new") in
    return: (let: "$a0" := (StructFieldRef Int64 "v"%go (![go.PointerType Int64] "x")) in
     let: "$a1" := (![go.int64] "new") in
     (FuncResolve SwapInt64 [] #()) "$a0" "$a1")).

(* CompareAndSwap executes the compare-and-swap operation for x.

   go: type.go:123:17 *)
Definition Int64__CompareAndSwapⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x" "old" "new",
    exception_do (let: "swapped" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "x" := (GoAlloc (go.PointerType Int64) "x") in
    let: "new" := (GoAlloc go.int64 "new") in
    let: "old" := (GoAlloc go.int64 "old") in
    return: (let: "$a0" := (StructFieldRef Int64 "v"%go (![go.PointerType Int64] "x")) in
     let: "$a1" := (![go.int64] "old") in
     let: "$a2" := (![go.int64] "new") in
     (FuncResolve CompareAndSwapInt64 [] #()) "$a0" "$a1" "$a2")).

(* Add atomically adds delta to x and returns the new value.

   go: type.go:128:17 *)
Definition Int64__Addⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x" "delta",
    exception_do (let: "new" := (GoAlloc go.int64 (GoZeroVal go.int64 #())) in
    let: "x" := (GoAlloc (go.PointerType Int64) "x") in
    let: "delta" := (GoAlloc go.int64 "delta") in
    return: (let: "$a0" := (StructFieldRef Int64 "v"%go (![go.PointerType Int64] "x")) in
     let: "$a1" := (![go.int64] "delta") in
     (FuncResolve AddInt64 [] #()) "$a0" "$a1")).

(* And atomically performs a bitwise AND operation on x using the bitmask
   provided as mask and returns the old value.

   go: type.go:132:17 *)
Definition Int64__Andⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x" "mask",
    exception_do (let: "old" := (GoAlloc go.int64 (GoZeroVal go.int64 #())) in
    let: "x" := (GoAlloc (go.PointerType Int64) "x") in
    let: "mask" := (GoAlloc go.int64 "mask") in
    return: (let: "$a0" := (StructFieldRef Int64 "v"%go (![go.PointerType Int64] "x")) in
     let: "$a1" := (![go.int64] "mask") in
     (FuncResolve AndInt64 [] #()) "$a0" "$a1")).

(* Or atomically performs a bitwise OR operation on x using the bitmask
   provided as mask and returns the old value.

   go: type.go:136:17 *)
Definition Int64__Orⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x" "mask",
    exception_do (let: "old" := (GoAlloc go.int64 (GoZeroVal go.int64 #())) in
    let: "x" := (GoAlloc (go.PointerType Int64) "x") in
    let: "mask" := (GoAlloc go.int64 "mask") in
    return: (let: "$a0" := (StructFieldRef Int64 "v"%go (![go.PointerType Int64] "x")) in
     let: "$a1" := (![go.int64] "mask") in
     (FuncResolve OrInt64 [] #()) "$a0" "$a1")).

(* Load atomically loads and returns the value stored in x.

   go: type.go:147:18 *)
Definition Uint32__Loadⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x" <>,
    exception_do (let: "x" := (GoAlloc (go.PointerType Uint32) "x") in
    return: (let: "$a0" := (StructFieldRef Uint32 "v"%go (![go.PointerType Uint32] "x")) in
     (FuncResolve LoadUint32 [] #()) "$a0")).

(* Store atomically stores val into x.

   go: type.go:150:18 *)
Definition Uint32__Storeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x" "val",
    exception_do (let: "x" := (GoAlloc (go.PointerType Uint32) "x") in
    let: "val" := (GoAlloc go.uint32 "val") in
    do:  (let: "$a0" := (StructFieldRef Uint32 "v"%go (![go.PointerType Uint32] "x")) in
    let: "$a1" := (![go.uint32] "val") in
    (FuncResolve StoreUint32 [] #()) "$a0" "$a1");;;
    return: #()).

(* Swap atomically stores new into x and returns the previous value.

   go: type.go:153:18 *)
Definition Uint32__Swapⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x" "new",
    exception_do (let: "old" := (GoAlloc go.uint32 (GoZeroVal go.uint32 #())) in
    let: "x" := (GoAlloc (go.PointerType Uint32) "x") in
    let: "new" := (GoAlloc go.uint32 "new") in
    return: (let: "$a0" := (StructFieldRef Uint32 "v"%go (![go.PointerType Uint32] "x")) in
     let: "$a1" := (![go.uint32] "new") in
     (FuncResolve SwapUint32 [] #()) "$a0" "$a1")).

(* CompareAndSwap executes the compare-and-swap operation for x.

   go: type.go:156:18 *)
Definition Uint32__CompareAndSwapⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x" "old" "new",
    exception_do (let: "swapped" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "x" := (GoAlloc (go.PointerType Uint32) "x") in
    let: "new" := (GoAlloc go.uint32 "new") in
    let: "old" := (GoAlloc go.uint32 "old") in
    return: (let: "$a0" := (StructFieldRef Uint32 "v"%go (![go.PointerType Uint32] "x")) in
     let: "$a1" := (![go.uint32] "old") in
     let: "$a2" := (![go.uint32] "new") in
     (FuncResolve CompareAndSwapUint32 [] #()) "$a0" "$a1" "$a2")).

(* Add atomically adds delta to x and returns the new value.

   go: type.go:161:18 *)
Definition Uint32__Addⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x" "delta",
    exception_do (let: "new" := (GoAlloc go.uint32 (GoZeroVal go.uint32 #())) in
    let: "x" := (GoAlloc (go.PointerType Uint32) "x") in
    let: "delta" := (GoAlloc go.uint32 "delta") in
    return: (let: "$a0" := (StructFieldRef Uint32 "v"%go (![go.PointerType Uint32] "x")) in
     let: "$a1" := (![go.uint32] "delta") in
     (FuncResolve AddUint32 [] #()) "$a0" "$a1")).

(* And atomically performs a bitwise AND operation on x using the bitmask
   provided as mask and returns the old value.

   go: type.go:165:18 *)
Definition Uint32__Andⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x" "mask",
    exception_do (let: "old" := (GoAlloc go.uint32 (GoZeroVal go.uint32 #())) in
    let: "x" := (GoAlloc (go.PointerType Uint32) "x") in
    let: "mask" := (GoAlloc go.uint32 "mask") in
    return: (let: "$a0" := (StructFieldRef Uint32 "v"%go (![go.PointerType Uint32] "x")) in
     let: "$a1" := (![go.uint32] "mask") in
     (FuncResolve AndUint32 [] #()) "$a0" "$a1")).

(* Or atomically performs a bitwise OR operation on x using the bitmask
   provided as mask and returns the old value.

   go: type.go:169:18 *)
Definition Uint32__Orⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x" "mask",
    exception_do (let: "old" := (GoAlloc go.uint32 (GoZeroVal go.uint32 #())) in
    let: "x" := (GoAlloc (go.PointerType Uint32) "x") in
    let: "mask" := (GoAlloc go.uint32 "mask") in
    return: (let: "$a0" := (StructFieldRef Uint32 "v"%go (![go.PointerType Uint32] "x")) in
     let: "$a1" := (![go.uint32] "mask") in
     (FuncResolve OrUint32 [] #()) "$a0" "$a1")).

(* Load atomically loads and returns the value stored in x.

   go: type.go:181:18 *)
Definition Uint64__Loadⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x" <>,
    exception_do (let: "x" := (GoAlloc (go.PointerType Uint64) "x") in
    return: (let: "$a0" := (StructFieldRef Uint64 "v"%go (![go.PointerType Uint64] "x")) in
     (FuncResolve LoadUint64 [] #()) "$a0")).

(* Store atomically stores val into x.

   go: type.go:184:18 *)
Definition Uint64__Storeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x" "val",
    exception_do (let: "x" := (GoAlloc (go.PointerType Uint64) "x") in
    let: "val" := (GoAlloc go.uint64 "val") in
    do:  (let: "$a0" := (StructFieldRef Uint64 "v"%go (![go.PointerType Uint64] "x")) in
    let: "$a1" := (![go.uint64] "val") in
    (FuncResolve StoreUint64 [] #()) "$a0" "$a1");;;
    return: #()).

(* Swap atomically stores new into x and returns the previous value.

   go: type.go:187:18 *)
Definition Uint64__Swapⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x" "new",
    exception_do (let: "old" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "x" := (GoAlloc (go.PointerType Uint64) "x") in
    let: "new" := (GoAlloc go.uint64 "new") in
    return: (let: "$a0" := (StructFieldRef Uint64 "v"%go (![go.PointerType Uint64] "x")) in
     let: "$a1" := (![go.uint64] "new") in
     (FuncResolve SwapUint64 [] #()) "$a0" "$a1")).

(* CompareAndSwap executes the compare-and-swap operation for x.

   go: type.go:190:18 *)
Definition Uint64__CompareAndSwapⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x" "old" "new",
    exception_do (let: "swapped" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "x" := (GoAlloc (go.PointerType Uint64) "x") in
    let: "new" := (GoAlloc go.uint64 "new") in
    let: "old" := (GoAlloc go.uint64 "old") in
    return: (let: "$a0" := (StructFieldRef Uint64 "v"%go (![go.PointerType Uint64] "x")) in
     let: "$a1" := (![go.uint64] "old") in
     let: "$a2" := (![go.uint64] "new") in
     (FuncResolve CompareAndSwapUint64 [] #()) "$a0" "$a1" "$a2")).

(* Add atomically adds delta to x and returns the new value.

   go: type.go:195:18 *)
Definition Uint64__Addⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x" "delta",
    exception_do (let: "new" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "x" := (GoAlloc (go.PointerType Uint64) "x") in
    let: "delta" := (GoAlloc go.uint64 "delta") in
    return: (let: "$a0" := (StructFieldRef Uint64 "v"%go (![go.PointerType Uint64] "x")) in
     let: "$a1" := (![go.uint64] "delta") in
     (FuncResolve AddUint64 [] #()) "$a0" "$a1")).

(* And atomically performs a bitwise AND operation on x using the bitmask
   provided as mask and returns the old value.

   go: type.go:199:18 *)
Definition Uint64__Andⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x" "mask",
    exception_do (let: "old" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "x" := (GoAlloc (go.PointerType Uint64) "x") in
    let: "mask" := (GoAlloc go.uint64 "mask") in
    return: (let: "$a0" := (StructFieldRef Uint64 "v"%go (![go.PointerType Uint64] "x")) in
     let: "$a1" := (![go.uint64] "mask") in
     (FuncResolve AndUint64 [] #()) "$a0" "$a1")).

(* Or atomically performs a bitwise OR operation on x using the bitmask
   provided as mask and returns the old value.

   go: type.go:203:18 *)
Definition Uint64__Orⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x" "mask",
    exception_do (let: "old" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "x" := (GoAlloc (go.PointerType Uint64) "x") in
    let: "mask" := (GoAlloc go.uint64 "mask") in
    return: (let: "$a0" := (StructFieldRef Uint64 "v"%go (![go.PointerType Uint64] "x")) in
     let: "$a1" := (![go.uint64] "mask") in
     (FuncResolve OrUint64 [] #()) "$a0" "$a1")).

(* Load returns the value set by the most recent Store.
   It returns nil if there has been no call to Store for this Value.

   go: value.go:28:17 *)
Definition Value__Loadⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "v" <>,
    exception_do (let: "val" := (GoAlloc go.any (GoZeroVal go.any #())) in
    let: "v" := (GoAlloc (go.PointerType Value) "v") in
    let: "vp" := (GoAlloc (go.PointerType efaceWords) (GoZeroVal (go.PointerType efaceWords) #())) in
    let: "$r0" := (Convert unsafe.Pointer (go.PointerType efaceWords) (Convert (go.PointerType Value) unsafe.Pointer (![go.PointerType Value] "v"))) in
    do:  ("vp" <-[go.PointerType efaceWords] "$r0");;;
    let: "typ" := (GoAlloc unsafe.Pointer (GoZeroVal unsafe.Pointer #())) in
    let: "$r0" := (let: "$a0" := (StructFieldRef efaceWords "typ"%go (![go.PointerType efaceWords] "vp")) in
    (FuncResolve LoadPointer [] #()) "$a0") in
    do:  ("typ" <-[unsafe.Pointer] "$r0");;;
    (if: Convert go.untyped_bool go.bool (((![unsafe.Pointer] "typ") =⟨unsafe.Pointer⟩ (Convert go.untyped_nil unsafe.Pointer UntypedNil)) || ((![unsafe.Pointer] "typ") =⟨unsafe.Pointer⟩ (Convert (go.PointerType go.byte) unsafe.Pointer (GlobalVarAddr firstStoreInProgress #()))))
    then return: (Convert go.untyped_nil go.any UntypedNil)
    else do:  #());;;
    let: "data" := (GoAlloc unsafe.Pointer (GoZeroVal unsafe.Pointer #())) in
    let: "$r0" := (let: "$a0" := (StructFieldRef efaceWords "data"%go (![go.PointerType efaceWords] "vp")) in
    (FuncResolve LoadPointer [] #()) "$a0") in
    do:  ("data" <-[unsafe.Pointer] "$r0");;;
    let: "vlp" := (GoAlloc (go.PointerType efaceWords) (GoZeroVal (go.PointerType efaceWords) #())) in
    let: "$r0" := (Convert unsafe.Pointer (go.PointerType efaceWords) (Convert (go.PointerType go.any) unsafe.Pointer "val")) in
    do:  ("vlp" <-[go.PointerType efaceWords] "$r0");;;
    let: "$r0" := (![unsafe.Pointer] "typ") in
    do:  ((StructFieldRef efaceWords "typ"%go (![go.PointerType efaceWords] "vlp")) <-[unsafe.Pointer] "$r0");;;
    let: "$r0" := (![unsafe.Pointer] "data") in
    do:  ((StructFieldRef efaceWords "data"%go (![go.PointerType efaceWords] "vlp")) <-[unsafe.Pointer] "$r0");;;
    return: (![go.any] "val")).

(* Store sets the value of the [Value] v to val.
   All calls to Store for a given Value must use values of the same concrete type.
   Store of an inconsistent type panics, as does Store(nil).

   go: value.go:47:17 *)
Definition Value__Storeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "v" "val",
    exception_do (let: "v" := (GoAlloc (go.PointerType Value) "v") in
    let: "val" := (GoAlloc go.any "val") in
    (if: Convert go.untyped_bool go.bool ((![go.any] "val") =⟨go.InterfaceType []⟩ (Convert go.untyped_nil (go.InterfaceType []) UntypedNil))
    then
      do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"sync/atomic: store of nil value into Value"%go) in
      (FuncResolve go.panic [] #()) "$a0")
    else do:  #());;;
    let: "vp" := (GoAlloc (go.PointerType efaceWords) (GoZeroVal (go.PointerType efaceWords) #())) in
    let: "$r0" := (Convert unsafe.Pointer (go.PointerType efaceWords) (Convert (go.PointerType Value) unsafe.Pointer (![go.PointerType Value] "v"))) in
    do:  ("vp" <-[go.PointerType efaceWords] "$r0");;;
    let: "vlp" := (GoAlloc (go.PointerType efaceWords) (GoZeroVal (go.PointerType efaceWords) #())) in
    let: "$r0" := (Convert unsafe.Pointer (go.PointerType efaceWords) (Convert (go.PointerType go.any) unsafe.Pointer "val")) in
    do:  ("vlp" <-[go.PointerType efaceWords] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "typ" := (GoAlloc unsafe.Pointer (GoZeroVal unsafe.Pointer #())) in
      let: "$r0" := (let: "$a0" := (StructFieldRef efaceWords "typ"%go (![go.PointerType efaceWords] "vp")) in
      (FuncResolve LoadPointer [] #()) "$a0") in
      do:  ("typ" <-[unsafe.Pointer] "$r0");;;
      (if: Convert go.untyped_bool go.bool ((![unsafe.Pointer] "typ") =⟨unsafe.Pointer⟩ (Convert go.untyped_nil unsafe.Pointer UntypedNil))
      then
        do:  ((FuncResolve runtime_procPin [] #()) #());;;
        (if: (⟨go.bool⟩! (let: "$a0" := (StructFieldRef efaceWords "typ"%go (![go.PointerType efaceWords] "vp")) in
        let: "$a1" := (Convert go.untyped_nil unsafe.Pointer UntypedNil) in
        let: "$a2" := (Convert (go.PointerType go.byte) unsafe.Pointer (GlobalVarAddr firstStoreInProgress #())) in
        (FuncResolve CompareAndSwapPointer [] #()) "$a0" "$a1" "$a2"))
        then
          do:  ((FuncResolve runtime_procUnpin [] #()) #());;;
          continue: #()
        else do:  #());;;
        do:  (let: "$a0" := (StructFieldRef efaceWords "data"%go (![go.PointerType efaceWords] "vp")) in
        let: "$a1" := (![unsafe.Pointer] (StructFieldRef efaceWords "data"%go (![go.PointerType efaceWords] "vlp"))) in
        (FuncResolve StorePointer [] #()) "$a0" "$a1");;;
        do:  (let: "$a0" := (StructFieldRef efaceWords "typ"%go (![go.PointerType efaceWords] "vp")) in
        let: "$a1" := (![unsafe.Pointer] (StructFieldRef efaceWords "typ"%go (![go.PointerType efaceWords] "vlp"))) in
        (FuncResolve StorePointer [] #()) "$a0" "$a1");;;
        do:  ((FuncResolve runtime_procUnpin [] #()) #());;;
        return: (#())
      else do:  #());;;
      (if: Convert go.untyped_bool go.bool ((![unsafe.Pointer] "typ") =⟨unsafe.Pointer⟩ (Convert (go.PointerType go.byte) unsafe.Pointer (GlobalVarAddr firstStoreInProgress #())))
      then continue: #()
      else do:  #());;;
      (if: Convert go.untyped_bool go.bool ((![unsafe.Pointer] "typ") ≠⟨unsafe.Pointer⟩ (![unsafe.Pointer] (StructFieldRef efaceWords "typ"%go (![go.PointerType efaceWords] "vlp"))))
      then
        do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"sync/atomic: store of inconsistently typed value into Value"%go) in
        (FuncResolve go.panic [] #()) "$a0")
      else do:  #());;;
      do:  (let: "$a0" := (StructFieldRef efaceWords "data"%go (![go.PointerType efaceWords] "vp")) in
      let: "$a1" := (![unsafe.Pointer] (StructFieldRef efaceWords "data"%go (![go.PointerType efaceWords] "vlp"))) in
      (FuncResolve StorePointer [] #()) "$a0" "$a1");;;
      return: (#()));;;
    return: #()).

(* Swap stores new into Value and returns the previous value. It returns nil if
   the Value is empty.

   All calls to Swap for a given Value must use values of the same concrete
   type. Swap of an inconsistent type panics, as does Swap(nil).

   go: value.go:90:17 *)
Definition Value__Swapⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "v" "new",
    exception_do (let: "old" := (GoAlloc go.any (GoZeroVal go.any #())) in
    let: "v" := (GoAlloc (go.PointerType Value) "v") in
    let: "new" := (GoAlloc go.any "new") in
    (if: Convert go.untyped_bool go.bool ((![go.any] "new") =⟨go.InterfaceType []⟩ (Convert go.untyped_nil (go.InterfaceType []) UntypedNil))
    then
      do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"sync/atomic: swap of nil value into Value"%go) in
      (FuncResolve go.panic [] #()) "$a0")
    else do:  #());;;
    let: "vp" := (GoAlloc (go.PointerType efaceWords) (GoZeroVal (go.PointerType efaceWords) #())) in
    let: "$r0" := (Convert unsafe.Pointer (go.PointerType efaceWords) (Convert (go.PointerType Value) unsafe.Pointer (![go.PointerType Value] "v"))) in
    do:  ("vp" <-[go.PointerType efaceWords] "$r0");;;
    let: "np" := (GoAlloc (go.PointerType efaceWords) (GoZeroVal (go.PointerType efaceWords) #())) in
    let: "$r0" := (Convert unsafe.Pointer (go.PointerType efaceWords) (Convert (go.PointerType go.any) unsafe.Pointer "new")) in
    do:  ("np" <-[go.PointerType efaceWords] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "typ" := (GoAlloc unsafe.Pointer (GoZeroVal unsafe.Pointer #())) in
      let: "$r0" := (let: "$a0" := (StructFieldRef efaceWords "typ"%go (![go.PointerType efaceWords] "vp")) in
      (FuncResolve LoadPointer [] #()) "$a0") in
      do:  ("typ" <-[unsafe.Pointer] "$r0");;;
      (if: Convert go.untyped_bool go.bool ((![unsafe.Pointer] "typ") =⟨unsafe.Pointer⟩ (Convert go.untyped_nil unsafe.Pointer UntypedNil))
      then
        do:  ((FuncResolve runtime_procPin [] #()) #());;;
        (if: (⟨go.bool⟩! (let: "$a0" := (StructFieldRef efaceWords "typ"%go (![go.PointerType efaceWords] "vp")) in
        let: "$a1" := (Convert go.untyped_nil unsafe.Pointer UntypedNil) in
        let: "$a2" := (Convert (go.PointerType go.byte) unsafe.Pointer (GlobalVarAddr firstStoreInProgress #())) in
        (FuncResolve CompareAndSwapPointer [] #()) "$a0" "$a1" "$a2"))
        then
          do:  ((FuncResolve runtime_procUnpin [] #()) #());;;
          continue: #()
        else do:  #());;;
        do:  (let: "$a0" := (StructFieldRef efaceWords "data"%go (![go.PointerType efaceWords] "vp")) in
        let: "$a1" := (![unsafe.Pointer] (StructFieldRef efaceWords "data"%go (![go.PointerType efaceWords] "np"))) in
        (FuncResolve StorePointer [] #()) "$a0" "$a1");;;
        do:  (let: "$a0" := (StructFieldRef efaceWords "typ"%go (![go.PointerType efaceWords] "vp")) in
        let: "$a1" := (![unsafe.Pointer] (StructFieldRef efaceWords "typ"%go (![go.PointerType efaceWords] "np"))) in
        (FuncResolve StorePointer [] #()) "$a0" "$a1");;;
        do:  ((FuncResolve runtime_procUnpin [] #()) #());;;
        return: (Convert go.untyped_nil go.any UntypedNil)
      else do:  #());;;
      (if: Convert go.untyped_bool go.bool ((![unsafe.Pointer] "typ") =⟨unsafe.Pointer⟩ (Convert (go.PointerType go.byte) unsafe.Pointer (GlobalVarAddr firstStoreInProgress #())))
      then continue: #()
      else do:  #());;;
      (if: Convert go.untyped_bool go.bool ((![unsafe.Pointer] "typ") ≠⟨unsafe.Pointer⟩ (![unsafe.Pointer] (StructFieldRef efaceWords "typ"%go (![go.PointerType efaceWords] "np"))))
      then
        do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"sync/atomic: swap of inconsistently typed value into Value"%go) in
        (FuncResolve go.panic [] #()) "$a0")
      else do:  #());;;
      let: "op" := (GoAlloc (go.PointerType efaceWords) (GoZeroVal (go.PointerType efaceWords) #())) in
      let: "$r0" := (Convert unsafe.Pointer (go.PointerType efaceWords) (Convert (go.PointerType go.any) unsafe.Pointer "old")) in
      do:  ("op" <-[go.PointerType efaceWords] "$r0");;;
      let: "$r0" := (![unsafe.Pointer] (StructFieldRef efaceWords "typ"%go (![go.PointerType efaceWords] "np"))) in
      let: "$r1" := (let: "$a0" := (StructFieldRef efaceWords "data"%go (![go.PointerType efaceWords] "vp")) in
      let: "$a1" := (![unsafe.Pointer] (StructFieldRef efaceWords "data"%go (![go.PointerType efaceWords] "np"))) in
      (FuncResolve SwapPointer [] #()) "$a0" "$a1") in
      do:  ((StructFieldRef efaceWords "typ"%go (![go.PointerType efaceWords] "op")) <-[unsafe.Pointer] "$r0");;;
      do:  ((StructFieldRef efaceWords "data"%go (![go.PointerType efaceWords] "op")) <-[unsafe.Pointer] "$r1");;;
      return: (![go.any] "old"))).

(* CompareAndSwap executes the compare-and-swap operation for the [Value].

   All calls to CompareAndSwap for a given Value must use values of the same
   concrete type. CompareAndSwap of an inconsistent type panics, as does
   CompareAndSwap(old, nil).

   go: value.go:135:17 *)
Definition Value__CompareAndSwapⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "v" "old" "new",
    exception_do (let: "swapped" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "v" := (GoAlloc (go.PointerType Value) "v") in
    let: "new" := (GoAlloc go.any "new") in
    let: "old" := (GoAlloc go.any "old") in
    (if: Convert go.untyped_bool go.bool ((![go.any] "new") =⟨go.InterfaceType []⟩ (Convert go.untyped_nil (go.InterfaceType []) UntypedNil))
    then
      do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"sync/atomic: compare and swap of nil value into Value"%go) in
      (FuncResolve go.panic [] #()) "$a0")
    else do:  #());;;
    let: "vp" := (GoAlloc (go.PointerType efaceWords) (GoZeroVal (go.PointerType efaceWords) #())) in
    let: "$r0" := (Convert unsafe.Pointer (go.PointerType efaceWords) (Convert (go.PointerType Value) unsafe.Pointer (![go.PointerType Value] "v"))) in
    do:  ("vp" <-[go.PointerType efaceWords] "$r0");;;
    let: "np" := (GoAlloc (go.PointerType efaceWords) (GoZeroVal (go.PointerType efaceWords) #())) in
    let: "$r0" := (Convert unsafe.Pointer (go.PointerType efaceWords) (Convert (go.PointerType go.any) unsafe.Pointer "new")) in
    do:  ("np" <-[go.PointerType efaceWords] "$r0");;;
    let: "op" := (GoAlloc (go.PointerType efaceWords) (GoZeroVal (go.PointerType efaceWords) #())) in
    let: "$r0" := (Convert unsafe.Pointer (go.PointerType efaceWords) (Convert (go.PointerType go.any) unsafe.Pointer "old")) in
    do:  ("op" <-[go.PointerType efaceWords] "$r0");;;
    (if: Convert go.untyped_bool go.bool (((![unsafe.Pointer] (StructFieldRef efaceWords "typ"%go (![go.PointerType efaceWords] "op"))) ≠⟨unsafe.Pointer⟩ (Convert go.untyped_nil unsafe.Pointer UntypedNil)) && ((![unsafe.Pointer] (StructFieldRef efaceWords "typ"%go (![go.PointerType efaceWords] "np"))) ≠⟨unsafe.Pointer⟩ (![unsafe.Pointer] (StructFieldRef efaceWords "typ"%go (![go.PointerType efaceWords] "op")))))
    then
      do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"sync/atomic: compare and swap of inconsistently typed values"%go) in
      (FuncResolve go.panic [] #()) "$a0")
    else do:  #());;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "typ" := (GoAlloc unsafe.Pointer (GoZeroVal unsafe.Pointer #())) in
      let: "$r0" := (let: "$a0" := (StructFieldRef efaceWords "typ"%go (![go.PointerType efaceWords] "vp")) in
      (FuncResolve LoadPointer [] #()) "$a0") in
      do:  ("typ" <-[unsafe.Pointer] "$r0");;;
      (if: Convert go.untyped_bool go.bool ((![unsafe.Pointer] "typ") =⟨unsafe.Pointer⟩ (Convert go.untyped_nil unsafe.Pointer UntypedNil))
      then
        (if: Convert go.untyped_bool go.bool ((![go.any] "old") ≠⟨go.InterfaceType []⟩ (Convert go.untyped_nil (go.InterfaceType []) UntypedNil))
        then return: (#false)
        else do:  #());;;
        do:  ((FuncResolve runtime_procPin [] #()) #());;;
        (if: (⟨go.bool⟩! (let: "$a0" := (StructFieldRef efaceWords "typ"%go (![go.PointerType efaceWords] "vp")) in
        let: "$a1" := (Convert go.untyped_nil unsafe.Pointer UntypedNil) in
        let: "$a2" := (Convert (go.PointerType go.byte) unsafe.Pointer (GlobalVarAddr firstStoreInProgress #())) in
        (FuncResolve CompareAndSwapPointer [] #()) "$a0" "$a1" "$a2"))
        then
          do:  ((FuncResolve runtime_procUnpin [] #()) #());;;
          continue: #()
        else do:  #());;;
        do:  (let: "$a0" := (StructFieldRef efaceWords "data"%go (![go.PointerType efaceWords] "vp")) in
        let: "$a1" := (![unsafe.Pointer] (StructFieldRef efaceWords "data"%go (![go.PointerType efaceWords] "np"))) in
        (FuncResolve StorePointer [] #()) "$a0" "$a1");;;
        do:  (let: "$a0" := (StructFieldRef efaceWords "typ"%go (![go.PointerType efaceWords] "vp")) in
        let: "$a1" := (![unsafe.Pointer] (StructFieldRef efaceWords "typ"%go (![go.PointerType efaceWords] "np"))) in
        (FuncResolve StorePointer [] #()) "$a0" "$a1");;;
        do:  ((FuncResolve runtime_procUnpin [] #()) #());;;
        return: (#true)
      else do:  #());;;
      (if: Convert go.untyped_bool go.bool ((![unsafe.Pointer] "typ") =⟨unsafe.Pointer⟩ (Convert (go.PointerType go.byte) unsafe.Pointer (GlobalVarAddr firstStoreInProgress #())))
      then continue: #()
      else do:  #());;;
      (if: Convert go.untyped_bool go.bool ((![unsafe.Pointer] "typ") ≠⟨unsafe.Pointer⟩ (![unsafe.Pointer] (StructFieldRef efaceWords "typ"%go (![go.PointerType efaceWords] "np"))))
      then
        do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"sync/atomic: compare and swap of inconsistently typed value into Value"%go) in
        (FuncResolve go.panic [] #()) "$a0")
      else do:  #());;;
      let: "data" := (GoAlloc unsafe.Pointer (GoZeroVal unsafe.Pointer #())) in
      let: "$r0" := (let: "$a0" := (StructFieldRef efaceWords "data"%go (![go.PointerType efaceWords] "vp")) in
      (FuncResolve LoadPointer [] #()) "$a0") in
      do:  ("data" <-[unsafe.Pointer] "$r0");;;
      let: "i" := (GoAlloc go.any (GoZeroVal go.any #())) in
      let: "$r0" := (![unsafe.Pointer] "typ") in
      do:  ((StructFieldRef efaceWords "typ"%go (Convert unsafe.Pointer (go.PointerType efaceWords) (Convert (go.PointerType go.any) unsafe.Pointer "i"))) <-[unsafe.Pointer] "$r0");;;
      let: "$r0" := (![unsafe.Pointer] "data") in
      do:  ((StructFieldRef efaceWords "data"%go (Convert unsafe.Pointer (go.PointerType efaceWords) (Convert (go.PointerType go.any) unsafe.Pointer "i"))) <-[unsafe.Pointer] "$r0");;;
      (if: Convert go.untyped_bool go.bool ((![go.any] "i") ≠⟨go.InterfaceType []⟩ (![go.any] "old"))
      then return: (#false)
      else do:  #());;;
      return: (let: "$a0" := (StructFieldRef efaceWords "data"%go (![go.PointerType efaceWords] "vp")) in
       let: "$a1" := (![unsafe.Pointer] "data") in
       let: "$a2" := (![unsafe.Pointer] (StructFieldRef efaceWords "data"%go (![go.PointerType efaceWords] "np"))) in
       (FuncResolve CompareAndSwapPointer [] #()) "$a0" "$a1" "$a2"))).

#[global] Instance info' : PkgInfo pkg_id.atomic :=
{|
  pkg_imported_pkgs := []
|}.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init pkg_id.atomic (λ: <>,
      exception_do (let: "$r0" := (GoAlloc (Pointer go.int) (CompositeLiteral (Pointer go.int) (LiteralValue []))) in
      do:  #())
      ).

Module noCopy.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End noCopy.

Definition noCopy'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [

].
Program Definition noCopy'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (noCopy'fds_unsealed).
Global Instance equals_unfold_noCopy {ext : ffi_syntax} {go_gctx : GoGlobalContext} : noCopy'fds =→ noCopy'fds_unsealed.
Proof. rewrite /noCopy'fds seal_eq //. Qed.

Definition noCopyⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (noCopy'fds).

Class noCopy_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] noCopy_type_repr  :: go.TypeReprUnderlying noCopyⁱᵐᵖˡ noCopy.t;
  #[global] noCopy_underlying :: (noCopy) <u (noCopyⁱᵐᵖˡ);
}.

Module Bool.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  _0' : atomic.noCopy.t;
  v' : w32;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End Bool.

Definition Bool'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "_0"%go noCopy);
  (go.FieldDecl "v"%go go.uint32)
].
Program Definition Bool'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (Bool'fds_unsealed).
Global Instance equals_unfold_Bool {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Bool'fds =→ Bool'fds_unsealed.
Proof. rewrite /Bool'fds seal_eq //. Qed.

Definition Boolⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (Bool'fds).

Class Bool_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Bool_type_repr  :: go.TypeReprUnderlying Boolⁱᵐᵖˡ Bool.t;
  #[global] Bool_underlying :: (Bool) <u (Boolⁱᵐᵖˡ);
  #[global] Bool_get__0 (x : Bool.t) :: ⟦StructFieldGet (Boolⁱᵐᵖˡ) "_0", #x⟧ ⤳[under] #x.(Bool._0');
  #[global] Bool_set__0 (x : Bool.t) y :: ⟦StructFieldSet (Boolⁱᵐᵖˡ) "_0", (#x, #y)⟧ ⤳[under] #(x <|Bool._0' := y|>);
  #[global] Bool_get_v (x : Bool.t) :: ⟦StructFieldGet (Boolⁱᵐᵖˡ) "v", #x⟧ ⤳[under] #x.(Bool.v');
  #[global] Bool_set_v (x : Bool.t) y :: ⟦StructFieldSet (Boolⁱᵐᵖˡ) "v", (#x, #y)⟧ ⤳[under] #(x <|Bool.v' := y|>);
  #[global] Bool'ptr_CompareAndSwap_unfold :: MethodUnfold (go.PointerType (Bool)) "CompareAndSwap" (Bool__CompareAndSwapⁱᵐᵖˡ);
  #[global] Bool'ptr_Load_unfold :: MethodUnfold (go.PointerType (Bool)) "Load" (Bool__Loadⁱᵐᵖˡ);
  #[global] Bool'ptr_Store_unfold :: MethodUnfold (go.PointerType (Bool)) "Store" (Bool__Storeⁱᵐᵖˡ);
  #[global] Bool'ptr_Swap_unfold :: MethodUnfold (go.PointerType (Bool)) "Swap" (Bool__Swapⁱᵐᵖˡ);
}.

Module Pointer.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t {T : Type} :=
mk {
  _0' : (array.t loc 0);
  _1' : atomic.noCopy.t;
  v' : loc;
}.

#[global] Instance zero_val `{!ZeroVal T} : ZeroVal t := {| zero_val := mk T (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End Pointer.

Definition Pointer'fds_unsealed (T : go.type) {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "_0"%go (go.ArrayType 0 (go.PointerType T)));
  (go.FieldDecl "_1"%go noCopy);
  (go.FieldDecl "v"%go unsafe.Pointer)
].
Program Definition Pointer'fds (T : go.type) {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (Pointer'fds_unsealed T).
Global Instance equals_unfold_Pointer T {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Pointer'fds T =→ Pointer'fds_unsealed T.
Proof. rewrite /Pointer'fds seal_eq //. Qed.

Definition Pointerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} (T : go.type) : go.type := go.StructType (Pointer'fds T).

Class Pointer_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Pointer_type_repr T T' `{!ZeroVal T'} `{!TypeRepr T T'} :: go.TypeReprUnderlying (Pointerⁱᵐᵖˡ T) (Pointer.t T');
  #[global] Pointer_underlying T :: (Pointer T) <u (Pointerⁱᵐᵖˡ T);
  #[global] Pointer_get__0 T T' (x : Pointer.t T') :: ⟦StructFieldGet (Pointerⁱᵐᵖˡ T) "_0", #x⟧ ⤳[under] #x.(Pointer._0');
  #[global] Pointer_set__0 T T' (x : Pointer.t T') y :: ⟦StructFieldSet (Pointerⁱᵐᵖˡ T) "_0", (#x, #y)⟧ ⤳[under] #(x <|Pointer._0' := y|>);
  #[global] Pointer_get__1 T T' (x : Pointer.t T') :: ⟦StructFieldGet (Pointerⁱᵐᵖˡ T) "_1", #x⟧ ⤳[under] #x.(Pointer._1');
  #[global] Pointer_set__1 T T' (x : Pointer.t T') y :: ⟦StructFieldSet (Pointerⁱᵐᵖˡ T) "_1", (#x, #y)⟧ ⤳[under] #(x <|Pointer._1' := y|>);
  #[global] Pointer_get_v T T' (x : Pointer.t T') :: ⟦StructFieldGet (Pointerⁱᵐᵖˡ T) "v", #x⟧ ⤳[under] #x.(Pointer.v');
  #[global] Pointer_set_v T T' (x : Pointer.t T') y :: ⟦StructFieldSet (Pointerⁱᵐᵖˡ T) "v", (#x, #y)⟧ ⤳[under] #(x <|Pointer.v' := y|>);
  #[global] Pointer'ptr_CompareAndSwap_unfold T :: MethodUnfold (go.PointerType (Pointer T)) "CompareAndSwap" (Pointer__CompareAndSwapⁱᵐᵖˡ T);
  #[global] Pointer'ptr_Load_unfold T :: MethodUnfold (go.PointerType (Pointer T)) "Load" (Pointer__Loadⁱᵐᵖˡ T);
  #[global] Pointer'ptr_Store_unfold T :: MethodUnfold (go.PointerType (Pointer T)) "Store" (Pointer__Storeⁱᵐᵖˡ T);
  #[global] Pointer'ptr_Swap_unfold T :: MethodUnfold (go.PointerType (Pointer T)) "Swap" (Pointer__Swapⁱᵐᵖˡ T);
}.

Module Int32.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  _0' : atomic.noCopy.t;
  v' : w32;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End Int32.

Definition Int32'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "_0"%go noCopy);
  (go.FieldDecl "v"%go go.int32)
].
Program Definition Int32'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (Int32'fds_unsealed).
Global Instance equals_unfold_Int32 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Int32'fds =→ Int32'fds_unsealed.
Proof. rewrite /Int32'fds seal_eq //. Qed.

Definition Int32ⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (Int32'fds).

Class Int32_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Int32_type_repr  :: go.TypeReprUnderlying Int32ⁱᵐᵖˡ Int32.t;
  #[global] Int32_underlying :: (Int32) <u (Int32ⁱᵐᵖˡ);
  #[global] Int32_get__0 (x : Int32.t) :: ⟦StructFieldGet (Int32ⁱᵐᵖˡ) "_0", #x⟧ ⤳[under] #x.(Int32._0');
  #[global] Int32_set__0 (x : Int32.t) y :: ⟦StructFieldSet (Int32ⁱᵐᵖˡ) "_0", (#x, #y)⟧ ⤳[under] #(x <|Int32._0' := y|>);
  #[global] Int32_get_v (x : Int32.t) :: ⟦StructFieldGet (Int32ⁱᵐᵖˡ) "v", #x⟧ ⤳[under] #x.(Int32.v');
  #[global] Int32_set_v (x : Int32.t) y :: ⟦StructFieldSet (Int32ⁱᵐᵖˡ) "v", (#x, #y)⟧ ⤳[under] #(x <|Int32.v' := y|>);
  #[global] Int32'ptr_Add_unfold :: MethodUnfold (go.PointerType (Int32)) "Add" (Int32__Addⁱᵐᵖˡ);
  #[global] Int32'ptr_And_unfold :: MethodUnfold (go.PointerType (Int32)) "And" (Int32__Andⁱᵐᵖˡ);
  #[global] Int32'ptr_CompareAndSwap_unfold :: MethodUnfold (go.PointerType (Int32)) "CompareAndSwap" (Int32__CompareAndSwapⁱᵐᵖˡ);
  #[global] Int32'ptr_Load_unfold :: MethodUnfold (go.PointerType (Int32)) "Load" (Int32__Loadⁱᵐᵖˡ);
  #[global] Int32'ptr_Or_unfold :: MethodUnfold (go.PointerType (Int32)) "Or" (Int32__Orⁱᵐᵖˡ);
  #[global] Int32'ptr_Store_unfold :: MethodUnfold (go.PointerType (Int32)) "Store" (Int32__Storeⁱᵐᵖˡ);
  #[global] Int32'ptr_Swap_unfold :: MethodUnfold (go.PointerType (Int32)) "Swap" (Int32__Swapⁱᵐᵖˡ);
}.

Module align64.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End align64.

Definition align64'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [

].
Program Definition align64'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (align64'fds_unsealed).
Global Instance equals_unfold_align64 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : align64'fds =→ align64'fds_unsealed.
Proof. rewrite /align64'fds seal_eq //. Qed.

Definition align64ⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (align64'fds).

Class align64_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] align64_type_repr  :: go.TypeReprUnderlying align64ⁱᵐᵖˡ align64.t;
  #[global] align64_underlying :: (align64) <u (align64ⁱᵐᵖˡ);
}.

Module Int64.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  _0' : atomic.noCopy.t;
  _1' : atomic.align64.t;
  v' : w64;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End Int64.

Definition Int64'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "_0"%go noCopy);
  (go.FieldDecl "_1"%go align64);
  (go.FieldDecl "v"%go go.int64)
].
Program Definition Int64'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (Int64'fds_unsealed).
Global Instance equals_unfold_Int64 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Int64'fds =→ Int64'fds_unsealed.
Proof. rewrite /Int64'fds seal_eq //. Qed.

Definition Int64ⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (Int64'fds).

Class Int64_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Int64_type_repr  :: go.TypeReprUnderlying Int64ⁱᵐᵖˡ Int64.t;
  #[global] Int64_underlying :: (Int64) <u (Int64ⁱᵐᵖˡ);
  #[global] Int64_get__0 (x : Int64.t) :: ⟦StructFieldGet (Int64ⁱᵐᵖˡ) "_0", #x⟧ ⤳[under] #x.(Int64._0');
  #[global] Int64_set__0 (x : Int64.t) y :: ⟦StructFieldSet (Int64ⁱᵐᵖˡ) "_0", (#x, #y)⟧ ⤳[under] #(x <|Int64._0' := y|>);
  #[global] Int64_get__1 (x : Int64.t) :: ⟦StructFieldGet (Int64ⁱᵐᵖˡ) "_1", #x⟧ ⤳[under] #x.(Int64._1');
  #[global] Int64_set__1 (x : Int64.t) y :: ⟦StructFieldSet (Int64ⁱᵐᵖˡ) "_1", (#x, #y)⟧ ⤳[under] #(x <|Int64._1' := y|>);
  #[global] Int64_get_v (x : Int64.t) :: ⟦StructFieldGet (Int64ⁱᵐᵖˡ) "v", #x⟧ ⤳[under] #x.(Int64.v');
  #[global] Int64_set_v (x : Int64.t) y :: ⟦StructFieldSet (Int64ⁱᵐᵖˡ) "v", (#x, #y)⟧ ⤳[under] #(x <|Int64.v' := y|>);
  #[global] Int64'ptr_Add_unfold :: MethodUnfold (go.PointerType (Int64)) "Add" (Int64__Addⁱᵐᵖˡ);
  #[global] Int64'ptr_And_unfold :: MethodUnfold (go.PointerType (Int64)) "And" (Int64__Andⁱᵐᵖˡ);
  #[global] Int64'ptr_CompareAndSwap_unfold :: MethodUnfold (go.PointerType (Int64)) "CompareAndSwap" (Int64__CompareAndSwapⁱᵐᵖˡ);
  #[global] Int64'ptr_Load_unfold :: MethodUnfold (go.PointerType (Int64)) "Load" (Int64__Loadⁱᵐᵖˡ);
  #[global] Int64'ptr_Or_unfold :: MethodUnfold (go.PointerType (Int64)) "Or" (Int64__Orⁱᵐᵖˡ);
  #[global] Int64'ptr_Store_unfold :: MethodUnfold (go.PointerType (Int64)) "Store" (Int64__Storeⁱᵐᵖˡ);
  #[global] Int64'ptr_Swap_unfold :: MethodUnfold (go.PointerType (Int64)) "Swap" (Int64__Swapⁱᵐᵖˡ);
}.

Module Uint32.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  _0' : atomic.noCopy.t;
  v' : w32;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End Uint32.

Definition Uint32'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "_0"%go noCopy);
  (go.FieldDecl "v"%go go.uint32)
].
Program Definition Uint32'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (Uint32'fds_unsealed).
Global Instance equals_unfold_Uint32 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Uint32'fds =→ Uint32'fds_unsealed.
Proof. rewrite /Uint32'fds seal_eq //. Qed.

Definition Uint32ⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (Uint32'fds).

Class Uint32_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Uint32_type_repr  :: go.TypeReprUnderlying Uint32ⁱᵐᵖˡ Uint32.t;
  #[global] Uint32_underlying :: (Uint32) <u (Uint32ⁱᵐᵖˡ);
  #[global] Uint32_get__0 (x : Uint32.t) :: ⟦StructFieldGet (Uint32ⁱᵐᵖˡ) "_0", #x⟧ ⤳[under] #x.(Uint32._0');
  #[global] Uint32_set__0 (x : Uint32.t) y :: ⟦StructFieldSet (Uint32ⁱᵐᵖˡ) "_0", (#x, #y)⟧ ⤳[under] #(x <|Uint32._0' := y|>);
  #[global] Uint32_get_v (x : Uint32.t) :: ⟦StructFieldGet (Uint32ⁱᵐᵖˡ) "v", #x⟧ ⤳[under] #x.(Uint32.v');
  #[global] Uint32_set_v (x : Uint32.t) y :: ⟦StructFieldSet (Uint32ⁱᵐᵖˡ) "v", (#x, #y)⟧ ⤳[under] #(x <|Uint32.v' := y|>);
  #[global] Uint32'ptr_Add_unfold :: MethodUnfold (go.PointerType (Uint32)) "Add" (Uint32__Addⁱᵐᵖˡ);
  #[global] Uint32'ptr_And_unfold :: MethodUnfold (go.PointerType (Uint32)) "And" (Uint32__Andⁱᵐᵖˡ);
  #[global] Uint32'ptr_CompareAndSwap_unfold :: MethodUnfold (go.PointerType (Uint32)) "CompareAndSwap" (Uint32__CompareAndSwapⁱᵐᵖˡ);
  #[global] Uint32'ptr_Load_unfold :: MethodUnfold (go.PointerType (Uint32)) "Load" (Uint32__Loadⁱᵐᵖˡ);
  #[global] Uint32'ptr_Or_unfold :: MethodUnfold (go.PointerType (Uint32)) "Or" (Uint32__Orⁱᵐᵖˡ);
  #[global] Uint32'ptr_Store_unfold :: MethodUnfold (go.PointerType (Uint32)) "Store" (Uint32__Storeⁱᵐᵖˡ);
  #[global] Uint32'ptr_Swap_unfold :: MethodUnfold (go.PointerType (Uint32)) "Swap" (Uint32__Swapⁱᵐᵖˡ);
}.

Module Uint64.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  _0' : atomic.noCopy.t;
  _1' : atomic.align64.t;
  v' : w64;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End Uint64.

Definition Uint64'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "_0"%go noCopy);
  (go.FieldDecl "_1"%go align64);
  (go.FieldDecl "v"%go go.uint64)
].
Program Definition Uint64'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (Uint64'fds_unsealed).
Global Instance equals_unfold_Uint64 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Uint64'fds =→ Uint64'fds_unsealed.
Proof. rewrite /Uint64'fds seal_eq //. Qed.

Definition Uint64ⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (Uint64'fds).

Class Uint64_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Uint64_type_repr  :: go.TypeReprUnderlying Uint64ⁱᵐᵖˡ Uint64.t;
  #[global] Uint64_underlying :: (Uint64) <u (Uint64ⁱᵐᵖˡ);
  #[global] Uint64_get__0 (x : Uint64.t) :: ⟦StructFieldGet (Uint64ⁱᵐᵖˡ) "_0", #x⟧ ⤳[under] #x.(Uint64._0');
  #[global] Uint64_set__0 (x : Uint64.t) y :: ⟦StructFieldSet (Uint64ⁱᵐᵖˡ) "_0", (#x, #y)⟧ ⤳[under] #(x <|Uint64._0' := y|>);
  #[global] Uint64_get__1 (x : Uint64.t) :: ⟦StructFieldGet (Uint64ⁱᵐᵖˡ) "_1", #x⟧ ⤳[under] #x.(Uint64._1');
  #[global] Uint64_set__1 (x : Uint64.t) y :: ⟦StructFieldSet (Uint64ⁱᵐᵖˡ) "_1", (#x, #y)⟧ ⤳[under] #(x <|Uint64._1' := y|>);
  #[global] Uint64_get_v (x : Uint64.t) :: ⟦StructFieldGet (Uint64ⁱᵐᵖˡ) "v", #x⟧ ⤳[under] #x.(Uint64.v');
  #[global] Uint64_set_v (x : Uint64.t) y :: ⟦StructFieldSet (Uint64ⁱᵐᵖˡ) "v", (#x, #y)⟧ ⤳[under] #(x <|Uint64.v' := y|>);
  #[global] Uint64'ptr_Add_unfold :: MethodUnfold (go.PointerType (Uint64)) "Add" (Uint64__Addⁱᵐᵖˡ);
  #[global] Uint64'ptr_And_unfold :: MethodUnfold (go.PointerType (Uint64)) "And" (Uint64__Andⁱᵐᵖˡ);
  #[global] Uint64'ptr_CompareAndSwap_unfold :: MethodUnfold (go.PointerType (Uint64)) "CompareAndSwap" (Uint64__CompareAndSwapⁱᵐᵖˡ);
  #[global] Uint64'ptr_Load_unfold :: MethodUnfold (go.PointerType (Uint64)) "Load" (Uint64__Loadⁱᵐᵖˡ);
  #[global] Uint64'ptr_Or_unfold :: MethodUnfold (go.PointerType (Uint64)) "Or" (Uint64__Orⁱᵐᵖˡ);
  #[global] Uint64'ptr_Store_unfold :: MethodUnfold (go.PointerType (Uint64)) "Store" (Uint64__Storeⁱᵐᵖˡ);
  #[global] Uint64'ptr_Swap_unfold :: MethodUnfold (go.PointerType (Uint64)) "Swap" (Uint64__Swapⁱᵐᵖˡ);
}.

Module Uintptr.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End Uintptr.

Class Uintptr_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Uintptr_type_repr  :: go.TypeReprUnderlying Uintptrⁱᵐᵖˡ Uintptr.t;
  #[global] Uintptr_underlying :: (Uintptr) <u (Uintptrⁱᵐᵖˡ);
  #[global] Uintptrⁱᵐᵖˡ_underlying :: (Uintptrⁱᵐᵖˡ) ↓u (Uintptrⁱᵐᵖˡ);
}.

Module Value.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  v' : interface.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End Value.

Definition Value'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "v"%go go.any)
].
Program Definition Value'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (Value'fds_unsealed).
Global Instance equals_unfold_Value {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Value'fds =→ Value'fds_unsealed.
Proof. rewrite /Value'fds seal_eq //. Qed.

Definition Valueⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (Value'fds).

Class Value_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Value_type_repr  :: go.TypeReprUnderlying Valueⁱᵐᵖˡ Value.t;
  #[global] Value_underlying :: (Value) <u (Valueⁱᵐᵖˡ);
  #[global] Value_get_v (x : Value.t) :: ⟦StructFieldGet (Valueⁱᵐᵖˡ) "v", #x⟧ ⤳[under] #x.(Value.v');
  #[global] Value_set_v (x : Value.t) y :: ⟦StructFieldSet (Valueⁱᵐᵖˡ) "v", (#x, #y)⟧ ⤳[under] #(x <|Value.v' := y|>);
  #[global] Value'ptr_CompareAndSwap_unfold :: MethodUnfold (go.PointerType (Value)) "CompareAndSwap" (Value__CompareAndSwapⁱᵐᵖˡ);
  #[global] Value'ptr_Load_unfold :: MethodUnfold (go.PointerType (Value)) "Load" (Value__Loadⁱᵐᵖˡ);
  #[global] Value'ptr_Store_unfold :: MethodUnfold (go.PointerType (Value)) "Store" (Value__Storeⁱᵐᵖˡ);
  #[global] Value'ptr_Swap_unfold :: MethodUnfold (go.PointerType (Value)) "Swap" (Value__Swapⁱᵐᵖˡ);
}.

Module efaceWords.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  typ' : loc;
  data' : loc;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End efaceWords.

Definition efaceWords'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "typ"%go unsafe.Pointer);
  (go.FieldDecl "data"%go unsafe.Pointer)
].
Program Definition efaceWords'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (efaceWords'fds_unsealed).
Global Instance equals_unfold_efaceWords {ext : ffi_syntax} {go_gctx : GoGlobalContext} : efaceWords'fds =→ efaceWords'fds_unsealed.
Proof. rewrite /efaceWords'fds seal_eq //. Qed.

Definition efaceWordsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (efaceWords'fds).

Class efaceWords_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] efaceWords_type_repr  :: go.TypeReprUnderlying efaceWordsⁱᵐᵖˡ efaceWords.t;
  #[global] efaceWords_underlying :: (efaceWords) <u (efaceWordsⁱᵐᵖˡ);
  #[global] efaceWords_get_typ (x : efaceWords.t) :: ⟦StructFieldGet (efaceWordsⁱᵐᵖˡ) "typ", #x⟧ ⤳[under] #x.(efaceWords.typ');
  #[global] efaceWords_set_typ (x : efaceWords.t) y :: ⟦StructFieldSet (efaceWordsⁱᵐᵖˡ) "typ", (#x, #y)⟧ ⤳[under] #(x <|efaceWords.typ' := y|>);
  #[global] efaceWords_get_data (x : efaceWords.t) :: ⟦StructFieldGet (efaceWordsⁱᵐᵖˡ) "data", #x⟧ ⤳[under] #x.(efaceWords.data');
  #[global] efaceWords_set_data (x : efaceWords.t) y :: ⟦StructFieldSet (efaceWordsⁱᵐᵖˡ) "data", (#x, #y)⟧ ⤳[under] #(x <|efaceWords.data' := y|>);
}.

Class Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Bool_instance :: Bool_Assumptions;
  #[global] Pointer_instance :: Pointer_Assumptions;
  #[global] Int32_instance :: Int32_Assumptions;
  #[global] Int64_instance :: Int64_Assumptions;
  #[global] Uint32_instance :: Uint32_Assumptions;
  #[global] Uint64_instance :: Uint64_Assumptions;
  #[global] Uintptr_instance :: Uintptr_Assumptions;
  #[global] noCopy_instance :: noCopy_Assumptions;
  #[global] align64_instance :: align64_Assumptions;
  #[global] Value_instance :: Value_Assumptions;
  #[global] efaceWords_instance :: efaceWords_Assumptions;
  #[global] SwapInt32_unfold :: FuncUnfold SwapInt32 [] (SwapInt32ⁱᵐᵖˡ);
  #[global] SwapUint32_unfold :: FuncUnfold SwapUint32 [] (SwapUint32ⁱᵐᵖˡ);
  #[global] SwapPointer_unfold :: FuncUnfold SwapPointer [] (SwapPointerⁱᵐᵖˡ);
  #[global] CompareAndSwapInt32_unfold :: FuncUnfold CompareAndSwapInt32 [] (CompareAndSwapInt32ⁱᵐᵖˡ);
  #[global] CompareAndSwapUint32_unfold :: FuncUnfold CompareAndSwapUint32 [] (CompareAndSwapUint32ⁱᵐᵖˡ);
  #[global] CompareAndSwapPointer_unfold :: FuncUnfold CompareAndSwapPointer [] (CompareAndSwapPointerⁱᵐᵖˡ);
  #[global] AddInt32_unfold :: FuncUnfold AddInt32 [] (AddInt32ⁱᵐᵖˡ);
  #[global] AddUint32_unfold :: FuncUnfold AddUint32 [] (AddUint32ⁱᵐᵖˡ);
  #[global] LoadInt32_unfold :: FuncUnfold LoadInt32 [] (LoadInt32ⁱᵐᵖˡ);
  #[global] LoadUint32_unfold :: FuncUnfold LoadUint32 [] (LoadUint32ⁱᵐᵖˡ);
  #[global] LoadPointer_unfold :: FuncUnfold LoadPointer [] (LoadPointerⁱᵐᵖˡ);
  #[global] StoreInt32_unfold :: FuncUnfold StoreInt32 [] (StoreInt32ⁱᵐᵖˡ);
  #[global] StoreUint32_unfold :: FuncUnfold StoreUint32 [] (StoreUint32ⁱᵐᵖˡ);
  #[global] StorePointer_unfold :: FuncUnfold StorePointer [] (StorePointerⁱᵐᵖˡ);
  #[global] SwapInt64_unfold :: FuncUnfold SwapInt64 [] (SwapInt64ⁱᵐᵖˡ);
  #[global] SwapUint64_unfold :: FuncUnfold SwapUint64 [] (SwapUint64ⁱᵐᵖˡ);
  #[global] CompareAndSwapInt64_unfold :: FuncUnfold CompareAndSwapInt64 [] (CompareAndSwapInt64ⁱᵐᵖˡ);
  #[global] CompareAndSwapUint64_unfold :: FuncUnfold CompareAndSwapUint64 [] (CompareAndSwapUint64ⁱᵐᵖˡ);
  #[global] AddInt64_unfold :: FuncUnfold AddInt64 [] (AddInt64ⁱᵐᵖˡ);
  #[global] AddUint64_unfold :: FuncUnfold AddUint64 [] (AddUint64ⁱᵐᵖˡ);
  #[global] LoadInt64_unfold :: FuncUnfold LoadInt64 [] (LoadInt64ⁱᵐᵖˡ);
  #[global] LoadUint64_unfold :: FuncUnfold LoadUint64 [] (LoadUint64ⁱᵐᵖˡ);
  #[global] StoreInt64_unfold :: FuncUnfold StoreInt64 [] (StoreInt64ⁱᵐᵖˡ);
  #[global] StoreUint64_unfold :: FuncUnfold StoreUint64 [] (StoreUint64ⁱᵐᵖˡ);
  #[global] b32_unfold :: FuncUnfold b32 [] (b32ⁱᵐᵖˡ);
}.
End atomic.
