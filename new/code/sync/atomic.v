(* autogenerated from sync/atomic *)
From New.golang Require Import defn.

Require Export New.trusted_code.sync.atomic.
Import atomic.
Definition atomic : go_string := "sync/atomic".

Module atomic.
Section code.
Context `{ffi_syntax}.


Definition SwapInt32 : go_string := "sync/atomic.SwapInt32"%go.

Definition SwapUint32 : go_string := "sync/atomic.SwapUint32"%go.

Definition SwapUintptr : go_string := "sync/atomic.SwapUintptr"%go.

Definition SwapPointer : go_string := "sync/atomic.SwapPointer"%go.

Definition CompareAndSwapInt32 : go_string := "sync/atomic.CompareAndSwapInt32"%go.

Definition CompareAndSwapUint32 : go_string := "sync/atomic.CompareAndSwapUint32"%go.

Definition CompareAndSwapUintptr : go_string := "sync/atomic.CompareAndSwapUintptr"%go.

Definition CompareAndSwapPointer : go_string := "sync/atomic.CompareAndSwapPointer"%go.

Definition AddInt32 : go_string := "sync/atomic.AddInt32"%go.

Definition AddUint32 : go_string := "sync/atomic.AddUint32"%go.

Definition AddUintptr : go_string := "sync/atomic.AddUintptr"%go.

Definition AndInt32 : go_string := "sync/atomic.AndInt32"%go.

Definition AndUint32 : go_string := "sync/atomic.AndUint32"%go.

Definition AndUintptr : go_string := "sync/atomic.AndUintptr"%go.

Definition OrInt32 : go_string := "sync/atomic.OrInt32"%go.

Definition OrUint32 : go_string := "sync/atomic.OrUint32"%go.

Definition OrUintptr : go_string := "sync/atomic.OrUintptr"%go.

Definition LoadInt32 : go_string := "sync/atomic.LoadInt32"%go.

Definition LoadUint32 : go_string := "sync/atomic.LoadUint32"%go.

Definition LoadUintptr : go_string := "sync/atomic.LoadUintptr"%go.

Definition LoadPointer : go_string := "sync/atomic.LoadPointer"%go.

Definition StoreInt32 : go_string := "sync/atomic.StoreInt32"%go.

Definition StoreUint32 : go_string := "sync/atomic.StoreUint32"%go.

Definition StoreUintptr : go_string := "sync/atomic.StoreUintptr"%go.

Definition StorePointer : go_string := "sync/atomic.StorePointer"%go.

Definition SwapInt64 : go_string := "sync/atomic.SwapInt64"%go.

Definition SwapUint64 : go_string := "sync/atomic.SwapUint64"%go.

Definition CompareAndSwapInt64 : go_string := "sync/atomic.CompareAndSwapInt64"%go.

Definition CompareAndSwapUint64 : go_string := "sync/atomic.CompareAndSwapUint64"%go.

Definition AddInt64 : go_string := "sync/atomic.AddInt64"%go.

Definition AddUint64 : go_string := "sync/atomic.AddUint64"%go.

Definition AndInt64 : go_string := "sync/atomic.AndInt64"%go.

Definition AndUint64 : go_string := "sync/atomic.AndUint64"%go.

Definition OrInt64 : go_string := "sync/atomic.OrInt64"%go.

Definition OrUint64 : go_string := "sync/atomic.OrUint64"%go.

Definition LoadInt64 : go_string := "sync/atomic.LoadInt64"%go.

Definition LoadUint64 : go_string := "sync/atomic.LoadUint64"%go.

Definition StoreInt64 : go_string := "sync/atomic.StoreInt64"%go.

Definition StoreUint64 : go_string := "sync/atomic.StoreUint64"%go.

Definition b32 : go_string := "sync/atomic.b32"%go.

Definition Int32ⁱᵈ : go_string := "sync/atomic.Int32"%go.

Definition noCopy : go_type := structT [
].

Definition Int32 : go_type := structT [
  "_0" :: noCopy;
  "v" :: int32T
].

(* Load atomically loads and returns the value stored in x.

   go: type.go:74:17 *)
Definition Int32__Loadⁱᵐᵖˡ : val :=
  λ: "x" <>,
    exception_do (let: "x" := (mem.alloc "x") in
    return: (let: "$a0" := (struct.field_ref #Int32 #"v"%go (![#ptrT] "x")) in
     (func_call #LoadInt32) "$a0")).

(* Store atomically stores val into x.

   go: type.go:77:17 *)
Definition Int32__Storeⁱᵐᵖˡ : val :=
  λ: "x" "val",
    exception_do (let: "x" := (mem.alloc "x") in
    let: "val" := (mem.alloc "val") in
    do:  (let: "$a0" := (struct.field_ref #Int32 #"v"%go (![#ptrT] "x")) in
    let: "$a1" := (![#int32T] "val") in
    (func_call #StoreInt32) "$a0" "$a1");;;
    return: #()).

(* CompareAndSwap executes the compare-and-swap operation for x.

   go: type.go:83:17 *)
Definition Int32__CompareAndSwapⁱᵐᵖˡ : val :=
  λ: "x" "old" "new",
    exception_do (let: "swapped" := (mem.alloc (type.zero_val #boolT)) in
    let: "x" := (mem.alloc "x") in
    let: "new" := (mem.alloc "new") in
    let: "old" := (mem.alloc "old") in
    return: (let: "$a0" := (struct.field_ref #Int32 #"v"%go (![#ptrT] "x")) in
     let: "$a1" := (![#int32T] "old") in
     let: "$a2" := (![#int32T] "new") in
     (func_call #CompareAndSwapInt32) "$a0" "$a1" "$a2")).

(* Add atomically adds delta to x and returns the new value.

   go: type.go:88:17 *)
Definition Int32__Addⁱᵐᵖˡ : val :=
  λ: "x" "delta",
    exception_do (let: "new" := (mem.alloc (type.zero_val #int32T)) in
    let: "x" := (mem.alloc "x") in
    let: "delta" := (mem.alloc "delta") in
    return: (let: "$a0" := (struct.field_ref #Int32 #"v"%go (![#ptrT] "x")) in
     let: "$a1" := (![#int32T] "delta") in
     (func_call #AddInt32) "$a0" "$a1")).

Definition Uint64ⁱᵈ : go_string := "sync/atomic.Uint64"%go.

Definition align64 : go_type := structT [
].

Definition Uint64 : go_type := structT [
  "_0" :: noCopy;
  "_1" :: align64;
  "v" :: uint64T
].

(* Load atomically loads and returns the value stored in x.

   go: type.go:169:18 *)
Definition Uint64__Loadⁱᵐᵖˡ : val :=
  λ: "x" <>,
    exception_do (let: "x" := (mem.alloc "x") in
    return: (let: "$a0" := (struct.field_ref #Uint64 #"v"%go (![#ptrT] "x")) in
     (func_call #LoadUint64) "$a0")).

(* Store atomically stores val into x.

   go: type.go:172:18 *)
Definition Uint64__Storeⁱᵐᵖˡ : val :=
  λ: "x" "val",
    exception_do (let: "x" := (mem.alloc "x") in
    let: "val" := (mem.alloc "val") in
    do:  (let: "$a0" := (struct.field_ref #Uint64 #"v"%go (![#ptrT] "x")) in
    let: "$a1" := (![#uint64T] "val") in
    (func_call #StoreUint64) "$a0" "$a1");;;
    return: #()).

(* CompareAndSwap executes the compare-and-swap operation for x.

   go: type.go:178:18 *)
Definition Uint64__CompareAndSwapⁱᵐᵖˡ : val :=
  λ: "x" "old" "new",
    exception_do (let: "swapped" := (mem.alloc (type.zero_val #boolT)) in
    let: "x" := (mem.alloc "x") in
    let: "new" := (mem.alloc "new") in
    let: "old" := (mem.alloc "old") in
    return: (let: "$a0" := (struct.field_ref #Uint64 #"v"%go (![#ptrT] "x")) in
     let: "$a1" := (![#uint64T] "old") in
     let: "$a2" := (![#uint64T] "new") in
     (func_call #CompareAndSwapUint64) "$a0" "$a1" "$a2")).

(* Add atomically adds delta to x and returns the new value.

   go: type.go:183:18 *)
Definition Uint64__Addⁱᵐᵖˡ : val :=
  λ: "x" "delta",
    exception_do (let: "new" := (mem.alloc (type.zero_val #uint64T)) in
    let: "x" := (mem.alloc "x") in
    let: "delta" := (mem.alloc "delta") in
    return: (let: "$a0" := (struct.field_ref #Uint64 #"v"%go (![#ptrT] "x")) in
     let: "$a1" := (![#uint64T] "delta") in
     (func_call #AddUint64) "$a0" "$a1")).

Definition noCopyⁱᵈ : go_string := "sync/atomic.noCopy"%go.

Definition align64ⁱᵈ : go_string := "sync/atomic.align64"%go.

Definition firstStoreInProgress : go_string := "sync/atomic.firstStoreInProgress"%go.

Definition runtime_procPin : go_string := "sync/atomic.runtime_procPin"%go.

Definition runtime_procUnpin : go_string := "sync/atomic.runtime_procUnpin"%go.

Definition vars' : list (go_string * go_type) := [].

Definition functions' : list (go_string * val) := [(CompareAndSwapInt32, CompareAndSwapInt32ⁱᵐᵖˡ); (AddInt32, AddInt32ⁱᵐᵖˡ); (LoadInt32, LoadInt32ⁱᵐᵖˡ); (StoreInt32, StoreInt32ⁱᵐᵖˡ); (CompareAndSwapUint64, CompareAndSwapUint64ⁱᵐᵖˡ); (AddUint64, AddUint64ⁱᵐᵖˡ); (LoadUint64, LoadUint64ⁱᵐᵖˡ); (StoreUint64, StoreUint64ⁱᵐᵖˡ)].

Definition msets' : list (go_string * (list (go_string * val))) := [(Int32ⁱᵈ, []); (ptrTⁱᵈ Int32ⁱᵈ, [("Add"%go, Int32__Addⁱᵐᵖˡ); ("CompareAndSwap"%go, Int32__CompareAndSwapⁱᵐᵖˡ); ("Load"%go, Int32__Loadⁱᵐᵖˡ); ("Store"%go, Int32__Storeⁱᵐᵖˡ)]); (Uint64ⁱᵈ, []); (ptrTⁱᵈ Uint64ⁱᵈ, [("Add"%go, Uint64__Addⁱᵐᵖˡ); ("CompareAndSwap"%go, Uint64__CompareAndSwapⁱᵐᵖˡ); ("Load"%go, Uint64__Loadⁱᵐᵖˡ); ("Store"%go, Uint64__Storeⁱᵐᵖˡ)]); (noCopyⁱᵈ, []); (ptrTⁱᵈ noCopyⁱᵈ, []); (align64ⁱᵈ, []); (ptrTⁱᵈ align64ⁱᵈ, [])].

#[global] Instance info' : PkgInfo atomic.atomic :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [];
  |}.

Axiom _'init : val.

Definition initialize' : val :=
  λ: <>,
    package.init #atomic.atomic (λ: <>,
      exception_do (do:  (package.alloc atomic.atomic #());;;
      do:  (_'init #()))
      ).

End code.
End atomic.
