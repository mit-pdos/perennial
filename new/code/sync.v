(* autogenerated from sync *)
From New.golang Require Import defn.
Require Export New.code.internal.race.
Require Export New.code.sync.atomic.

Require Export New.trusted_code.sync.
Import sync.
Definition sync : go_string := "sync".

Module sync.
Section code.
Context `{ffi_syntax}.


Definition Condⁱᵈ : go_string := "sync.Cond"%go.

Definition NewCond : go_string := "sync.NewCond"%go.

Definition noCopyⁱᵈ : go_string := "sync.noCopy"%go.

Definition noCopy : go_type := structT [
].

Definition Mutexⁱᵈ : go_string := "sync.Mutex"%go.

Definition OnceFunc : go_string := "sync.OnceFunc"%go.

Definition OnceValue : go_string := "sync.OnceValue"%go.

Definition OnceValues : go_string := "sync.OnceValues"%go.

Definition runtime_randn : go_string := "sync.runtime_randn"%go.

Definition poolRaceHash : go_string := "sync.poolRaceHash"%go.

Definition poolRaceAddr : go_string := "sync.poolRaceAddr"%go.

Definition poolCleanup : go_string := "sync.poolCleanup"%go.

Definition allPoolsMu : go_string := "sync.allPoolsMu"%go.

Definition allPools : go_string := "sync.allPools"%go.

Definition oldPools : go_string := "sync.oldPools"%go.

Definition init : go_string := "sync.init"%go.

Definition indexLocal : go_string := "sync.indexLocal"%go.

Definition runtime_registerPoolCleanup : go_string := "sync.runtime_registerPoolCleanup"%go.

Definition runtime_procPin : go_string := "sync.runtime_procPin"%go.

Definition runtime_procUnpin : go_string := "sync.runtime_procUnpin"%go.

Definition runtime_LoadAcquintptr : go_string := "sync.runtime_LoadAcquintptr"%go.

Definition runtime_StoreReluintptr : go_string := "sync.runtime_StoreReluintptr"%go.

Definition runtime_Semacquire : go_string := "sync.runtime_Semacquire"%go.

Definition runtime_SemacquireWaitGroup : go_string := "sync.runtime_SemacquireWaitGroup"%go.

Definition runtime_SemacquireRWMutexR : go_string := "sync.runtime_SemacquireRWMutexR"%go.

Definition runtime_SemacquireRWMutex : go_string := "sync.runtime_SemacquireRWMutex"%go.

Definition runtime_Semrelease : go_string := "sync.runtime_Semrelease"%go.

Definition runtime_notifyListAdd : go_string := "sync.runtime_notifyListAdd"%go.

Definition runtime_notifyListWait : go_string := "sync.runtime_notifyListWait"%go.

Definition runtime_notifyListNotifyAll : go_string := "sync.runtime_notifyListNotifyAll"%go.

Definition runtime_notifyListNotifyOne : go_string := "sync.runtime_notifyListNotifyOne"%go.

Definition runtime_notifyListCheck : go_string := "sync.runtime_notifyListCheck"%go.

Definition throw : go_string := "sync.throw"%go.

Definition fatal : go_string := "sync.fatal"%go.

Definition RWMutexⁱᵈ : go_string := "sync.RWMutex"%go.

Definition RWMutex : go_type := structT [
  "w" :: Mutex;
  "writerSem" :: uint32T;
  "readerSem" :: uint32T;
  "readerCount" :: atomic.Int32;
  "readerWait" :: atomic.Int32
].

Definition rwmutexMaxReaders : Z := 1073741824.

(* RLock locks rw for reading.

   It should not be used for recursive read locking; a blocked Lock
   call excludes new readers from acquiring the lock. See the
   documentation on the [RWMutex] type.

   go: rwmutex.go:67:20 *)
Definition RWMutex__RLockⁱᵐᵖˡ : val :=
  λ: "rw" <>,
    exception_do (let: "rw" := (mem.alloc "rw") in
    (if: race.Enabled
    then
      do:  (let: "$a0" := (struct.field_ref #RWMutex #"w"%go (![#ptrT] "rw")) in
      (func_call #race.Read) "$a0");;;
      do:  ((func_call #race.Disable) #())
    else do:  #());;;
    (if: int_lt (let: "$a0" := #(W32 1) in
    (method_call #atomic.Int32ⁱᵈ #"Add"%go (struct.field_ref #RWMutex #"readerCount"%go (![#ptrT] "rw"))) "$a0") #(W32 0)
    then
      do:  (let: "$a0" := (struct.field_ref #RWMutex #"readerSem"%go (![#ptrT] "rw")) in
      let: "$a1" := #false in
      let: "$a2" := #(W64 0) in
      (func_call #runtime_SemacquireRWMutexR) "$a0" "$a1" "$a2")
    else do:  #());;;
    (if: race.Enabled
    then
      do:  ((func_call #race.Enable) #());;;
      do:  (let: "$a0" := (struct.field_ref #RWMutex #"readerSem"%go (![#ptrT] "rw")) in
      (func_call #race.Acquire) "$a0")
    else do:  #());;;
    return: #()).

(* TryRLock tries to lock rw for reading and reports whether it succeeded.

   Note that while correct uses of TryRLock do exist, they are rare,
   and use of TryRLock is often a sign of a deeper problem
   in a particular use of mutexes.

   go: rwmutex.go:87:20 *)
Definition RWMutex__TryRLockⁱᵐᵖˡ : val :=
  λ: "rw" <>,
    exception_do (let: "rw" := (mem.alloc "rw") in
    (if: race.Enabled
    then
      do:  (let: "$a0" := (struct.field_ref #RWMutex #"w"%go (![#ptrT] "rw")) in
      (func_call #race.Read) "$a0");;;
      do:  ((func_call #race.Disable) #())
    else do:  #());;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "c" := (mem.alloc (type.zero_val #int32T)) in
      let: "$r0" := ((method_call #atomic.Int32ⁱᵈ #"Load"%go (struct.field_ref #RWMutex #"readerCount"%go (![#ptrT] "rw"))) #()) in
      do:  ("c" <-[#int32T] "$r0");;;
      (if: int_lt (![#int32T] "c") #(W32 0)
      then
        (if: race.Enabled
        then do:  ((func_call #race.Enable) #())
        else do:  #());;;
        return: (#false)
      else do:  #());;;
      (if: let: "$a0" := (![#int32T] "c") in
      let: "$a1" := ((![#int32T] "c") + #(W32 1)) in
      (method_call #atomic.Int32ⁱᵈ #"CompareAndSwap"%go (struct.field_ref #RWMutex #"readerCount"%go (![#ptrT] "rw"))) "$a0" "$a1"
      then
        (if: race.Enabled
        then
          do:  ((func_call #race.Enable) #());;;
          do:  (let: "$a0" := (struct.field_ref #RWMutex #"readerSem"%go (![#ptrT] "rw")) in
          (func_call #race.Acquire) "$a0")
        else do:  #());;;
        return: (#true)
      else do:  #()))).

(* RUnlock undoes a single [RWMutex.RLock] call;
   it does not affect other simultaneous readers.
   It is a run-time error if rw is not locked for reading
   on entry to RUnlock.

   go: rwmutex.go:114:20 *)
Definition RWMutex__RUnlockⁱᵐᵖˡ : val :=
  λ: "rw" <>,
    exception_do (let: "rw" := (mem.alloc "rw") in
    (if: race.Enabled
    then
      do:  (let: "$a0" := (struct.field_ref #RWMutex #"w"%go (![#ptrT] "rw")) in
      (func_call #race.Read) "$a0");;;
      do:  (let: "$a0" := (struct.field_ref #RWMutex #"writerSem"%go (![#ptrT] "rw")) in
      (func_call #race.ReleaseMerge) "$a0");;;
      do:  ((func_call #race.Disable) #())
    else do:  #());;;
    (let: "r" := (mem.alloc (type.zero_val #int32T)) in
    let: "$r0" := (let: "$a0" := #(W32 (- 1)) in
    (method_call #atomic.Int32ⁱᵈ #"Add"%go (struct.field_ref #RWMutex #"readerCount"%go (![#ptrT] "rw"))) "$a0") in
    do:  ("r" <-[#int32T] "$r0");;;
    (if: int_lt (![#int32T] "r") #(W32 0)
    then
      do:  (let: "$a0" := (![#int32T] "r") in
      (method_call #(ptrTⁱᵈ RWMutexⁱᵈ) #"rUnlockSlow"%go (![#ptrT] "rw")) "$a0")
    else do:  #()));;;
    (if: race.Enabled
    then do:  ((func_call #race.Enable) #())
    else do:  #());;;
    return: #()).

(* go: rwmutex.go:129:20 *)
Definition RWMutex__rUnlockSlowⁱᵐᵖˡ : val :=
  λ: "rw" "r",
    exception_do (let: "rw" := (mem.alloc "rw") in
    let: "r" := (mem.alloc "r") in
    (if: (((![#int32T] "r") + #(W32 1)) = #(W32 0)) || (((![#int32T] "r") + #(W32 1)) = #(W32 (- rwmutexMaxReaders)))
    then
      do:  ((func_call #race.Enable) #());;;
      do:  (let: "$a0" := #"sync: RUnlock of unlocked RWMutex"%go in
      (func_call #fatal) "$a0")
    else do:  #());;;
    (if: (let: "$a0" := #(W32 (- 1)) in
    (method_call #atomic.Int32ⁱᵈ #"Add"%go (struct.field_ref #RWMutex #"readerWait"%go (![#ptrT] "rw"))) "$a0") = #(W32 0)
    then
      do:  (let: "$a0" := (struct.field_ref #RWMutex #"writerSem"%go (![#ptrT] "rw")) in
      let: "$a1" := #false in
      let: "$a2" := #(W64 1) in
      (func_call #runtime_Semrelease) "$a0" "$a1" "$a2")
    else do:  #());;;
    return: #()).

(* Lock locks rw for writing.
   If the lock is already locked for reading or writing,
   Lock blocks until the lock is available.

   go: rwmutex.go:144:20 *)
Definition RWMutex__Lockⁱᵐᵖˡ : val :=
  λ: "rw" <>,
    exception_do (let: "rw" := (mem.alloc "rw") in
    (if: race.Enabled
    then
      do:  (let: "$a0" := (struct.field_ref #RWMutex #"w"%go (![#ptrT] "rw")) in
      (func_call #race.Read) "$a0");;;
      do:  ((func_call #race.Disable) #())
    else do:  #());;;
    do:  ((method_call #Mutexⁱᵈ #"Lock"%go (struct.field_ref #RWMutex #"w"%go (![#ptrT] "rw"))) #());;;
    let: "r" := (mem.alloc (type.zero_val #int32T)) in
    let: "$r0" := ((let: "$a0" := #(W32 (- rwmutexMaxReaders)) in
    (method_call #atomic.Int32ⁱᵈ #"Add"%go (struct.field_ref #RWMutex #"readerCount"%go (![#ptrT] "rw"))) "$a0") + #(W32 rwmutexMaxReaders)) in
    do:  ("r" <-[#int32T] "$r0");;;
    (if: ((![#int32T] "r") ≠ #(W32 0)) && ((let: "$a0" := (![#int32T] "r") in
    (method_call #atomic.Int32ⁱᵈ #"Add"%go (struct.field_ref #RWMutex #"readerWait"%go (![#ptrT] "rw"))) "$a0") ≠ #(W32 0))
    then
      do:  (let: "$a0" := (struct.field_ref #RWMutex #"writerSem"%go (![#ptrT] "rw")) in
      let: "$a1" := #false in
      let: "$a2" := #(W64 0) in
      (func_call #runtime_SemacquireRWMutex) "$a0" "$a1" "$a2")
    else do:  #());;;
    (if: race.Enabled
    then
      do:  ((func_call #race.Enable) #());;;
      do:  (let: "$a0" := (struct.field_ref #RWMutex #"readerSem"%go (![#ptrT] "rw")) in
      (func_call #race.Acquire) "$a0");;;
      do:  (let: "$a0" := (struct.field_ref #RWMutex #"writerSem"%go (![#ptrT] "rw")) in
      (func_call #race.Acquire) "$a0")
    else do:  #());;;
    return: #()).

(* TryLock tries to lock rw for writing and reports whether it succeeded.

   Note that while correct uses of TryLock do exist, they are rare,
   and use of TryLock is often a sign of a deeper problem
   in a particular use of mutexes.

   go: rwmutex.go:169:20 *)
Definition RWMutex__TryLockⁱᵐᵖˡ : val :=
  λ: "rw" <>,
    exception_do (let: "rw" := (mem.alloc "rw") in
    (if: race.Enabled
    then
      do:  (let: "$a0" := (struct.field_ref #RWMutex #"w"%go (![#ptrT] "rw")) in
      (func_call #race.Read) "$a0");;;
      do:  ((func_call #race.Disable) #())
    else do:  #());;;
    (if: (~ ((method_call #Mutexⁱᵈ #"TryLock"%go (struct.field_ref #RWMutex #"w"%go (![#ptrT] "rw"))) #()))
    then
      (if: race.Enabled
      then do:  ((func_call #race.Enable) #())
      else do:  #());;;
      return: (#false)
    else do:  #());;;
    (if: (~ (let: "$a0" := #(W32 0) in
    let: "$a1" := #(W32 (- rwmutexMaxReaders)) in
    (method_call #atomic.Int32ⁱᵈ #"CompareAndSwap"%go (struct.field_ref #RWMutex #"readerCount"%go (![#ptrT] "rw"))) "$a0" "$a1"))
    then
      do:  ((method_call #Mutexⁱᵈ #"Unlock"%go (struct.field_ref #RWMutex #"w"%go (![#ptrT] "rw"))) #());;;
      (if: race.Enabled
      then do:  ((func_call #race.Enable) #())
      else do:  #());;;
      return: (#false)
    else do:  #());;;
    (if: race.Enabled
    then
      do:  ((func_call #race.Enable) #());;;
      do:  (let: "$a0" := (struct.field_ref #RWMutex #"readerSem"%go (![#ptrT] "rw")) in
      (func_call #race.Acquire) "$a0");;;
      do:  (let: "$a0" := (struct.field_ref #RWMutex #"writerSem"%go (![#ptrT] "rw")) in
      (func_call #race.Acquire) "$a0")
    else do:  #());;;
    return: (#true)).

(* Unlock unlocks rw for writing. It is a run-time error if rw is
   not locked for writing on entry to Unlock.

   As with Mutexes, a locked [RWMutex] is not associated with a particular
   goroutine. One goroutine may [RWMutex.RLock] ([RWMutex.Lock]) a RWMutex and then
   arrange for another goroutine to [RWMutex.RUnlock] ([RWMutex.Unlock]) it.

   go: rwmutex.go:201:20 *)
Definition RWMutex__Unlockⁱᵐᵖˡ : val :=
  λ: "rw" <>,
    exception_do (let: "rw" := (mem.alloc "rw") in
    (if: race.Enabled
    then
      do:  (let: "$a0" := (struct.field_ref #RWMutex #"w"%go (![#ptrT] "rw")) in
      (func_call #race.Read) "$a0");;;
      do:  (let: "$a0" := (struct.field_ref #RWMutex #"readerSem"%go (![#ptrT] "rw")) in
      (func_call #race.Release) "$a0");;;
      do:  ((func_call #race.Disable) #())
    else do:  #());;;
    let: "r" := (mem.alloc (type.zero_val #int32T)) in
    let: "$r0" := (let: "$a0" := #(W32 rwmutexMaxReaders) in
    (method_call #atomic.Int32ⁱᵈ #"Add"%go (struct.field_ref #RWMutex #"readerCount"%go (![#ptrT] "rw"))) "$a0") in
    do:  ("r" <-[#int32T] "$r0");;;
    (if: int_geq (![#int32T] "r") #(W32 rwmutexMaxReaders)
    then
      do:  ((func_call #race.Enable) #());;;
      do:  (let: "$a0" := #"sync: Unlock of unlocked RWMutex"%go in
      (func_call #fatal) "$a0")
    else do:  #());;;
    (let: "i" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[#intT] "$r0");;;
    (for: (λ: <>, int_lt (![#intT] "i") (s_to_w64 (![#int32T] "r"))); (λ: <>, do:  ("i" <-[#intT] ((![#intT] "i") + #(W64 1)))) := λ: <>,
      do:  (let: "$a0" := (struct.field_ref #RWMutex #"readerSem"%go (![#ptrT] "rw")) in
      let: "$a1" := #false in
      let: "$a2" := #(W64 0) in
      (func_call #runtime_Semrelease) "$a0" "$a1" "$a2")));;;
    do:  ((method_call #Mutexⁱᵈ #"Unlock"%go (struct.field_ref #RWMutex #"w"%go (![#ptrT] "rw"))) #());;;
    (if: race.Enabled
    then do:  ((func_call #race.Enable) #())
    else do:  #());;;
    return: #()).

Definition syscall_hasWaitingReaders : go_string := "sync.syscall_hasWaitingReaders"%go.

Definition rlockerⁱᵈ : go_string := "sync.rlocker"%go.

(* RLocker returns a [Locker] interface that implements
   the [Locker.Lock] and [Locker.Unlock] methods by calling rw.RLock and rw.RUnlock.

   go: rwmutex.go:240:20 *)
Definition RWMutex__RLockerⁱᵐᵖˡ : val :=
  λ: "rw" <>,
    exception_do (let: "rw" := (mem.alloc "rw") in
    return: (interface.make #(ptrTⁱᵈ rlockerⁱᵈ) (![#ptrT] "rw"))).

Definition rlocker : go_type := RWMutex.

Definition WaitGroupⁱᵈ : go_string := "sync.WaitGroup"%go.

Definition WaitGroup : go_type := structT [
  "noCopy" :: noCopy;
  "state" :: atomic.Uint64;
  "sema" :: uint32T
].

(* Add adds delta, which may be negative, to the [WaitGroup] counter.
   If the counter becomes zero, all goroutines blocked on [WaitGroup.Wait] are released.
   If the counter goes negative, Add panics.

   Note that calls with a positive delta that occur when the counter is zero
   must happen before a Wait. Calls with a negative delta, or calls with a
   positive delta that start when the counter is greater than zero, may happen
   at any time.
   Typically this means the calls to Add should execute before the statement
   creating the goroutine or other event to be waited for.
   If a WaitGroup is reused to wait for several independent sets of events,
   new Add calls must happen after all previous Wait calls have returned.
   See the WaitGroup example.

   go: waitgroup.go:45:22 *)
Definition WaitGroup__Addⁱᵐᵖˡ : val :=
  λ: "wg" "delta",
    with_defer: (let: "wg" := (mem.alloc "wg") in
    let: "delta" := (mem.alloc "delta") in
    (if: race.Enabled
    then
      (if: int_lt (![#intT] "delta") #(W64 0)
      then
        do:  (let: "$a0" := (![#ptrT] "wg") in
        (func_call #race.ReleaseMerge) "$a0")
      else do:  #());;;
      do:  ((func_call #race.Disable) #());;;
      do:  (let: "$f" := (func_call #race.Enable) in
      "$defer" <-[#funcT] (let: "$oldf" := (![#funcT] "$defer") in
      (λ: <>,
        "$f" #();;
        "$oldf" #()
        )))
    else do:  #());;;
    let: "state" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (let: "$a0" := ((s_to_w64 (![#intT] "delta")) ≪ #(W64 32)) in
    (method_call #atomic.Uint64ⁱᵈ #"Add"%go (struct.field_ref #WaitGroup #"state"%go (![#ptrT] "wg"))) "$a0") in
    do:  ("state" <-[#uint64T] "$r0");;;
    let: "v" := (mem.alloc (type.zero_val #int32T)) in
    let: "$r0" := (u_to_w32 ((![#uint64T] "state") ≫ #(W64 32))) in
    do:  ("v" <-[#int32T] "$r0");;;
    let: "w" := (mem.alloc (type.zero_val #uint32T)) in
    let: "$r0" := (u_to_w32 (![#uint64T] "state")) in
    do:  ("w" <-[#uint32T] "$r0");;;
    (if: (race.Enabled && (int_gt (![#intT] "delta") #(W64 0))) && ((![#int32T] "v") = (s_to_w32 (![#intT] "delta")))
    then
      do:  (let: "$a0" := (struct.field_ref #WaitGroup #"sema"%go (![#ptrT] "wg")) in
      (func_call #race.Read) "$a0")
    else do:  #());;;
    (if: int_lt (![#int32T] "v") #(W32 0)
    then
      do:  (let: "$a0" := (interface.make #stringTⁱᵈ #"sync: negative WaitGroup counter"%go) in
      Panic "$a0")
    else do:  #());;;
    (if: (((![#uint32T] "w") ≠ #(W32 0)) && (int_gt (![#intT] "delta") #(W64 0))) && ((![#int32T] "v") = (s_to_w32 (![#intT] "delta")))
    then
      do:  (let: "$a0" := (interface.make #stringTⁱᵈ #"sync: WaitGroup misuse: Add called concurrently with Wait"%go) in
      Panic "$a0")
    else do:  #());;;
    (if: (int_gt (![#int32T] "v") #(W32 0)) || ((![#uint32T] "w") = #(W32 0))
    then return: (#())
    else do:  #());;;
    (if: ((method_call #atomic.Uint64ⁱᵈ #"Load"%go (struct.field_ref #WaitGroup #"state"%go (![#ptrT] "wg"))) #()) ≠ (![#uint64T] "state")
    then
      do:  (let: "$a0" := (interface.make #stringTⁱᵈ #"sync: WaitGroup misuse: Add called concurrently with Wait"%go) in
      Panic "$a0")
    else do:  #());;;
    do:  (let: "$a0" := #(W64 0) in
    (method_call #atomic.Uint64ⁱᵈ #"Store"%go (struct.field_ref #WaitGroup #"state"%go (![#ptrT] "wg"))) "$a0");;;
    (for: (λ: <>, (![#uint32T] "w") ≠ #(W32 0)); (λ: <>, do:  ("w" <-[#uint32T] ((![#uint32T] "w") - #(W32 1)))) := λ: <>,
      do:  (let: "$a0" := (struct.field_ref #WaitGroup #"sema"%go (![#ptrT] "wg")) in
      let: "$a1" := #false in
      let: "$a2" := #(W64 0) in
      (func_call #runtime_Semrelease) "$a0" "$a1" "$a2"));;;
    return: #()).

(* Done decrements the [WaitGroup] counter by one.

   go: waitgroup.go:88:22 *)
Definition WaitGroup__Doneⁱᵐᵖˡ : val :=
  λ: "wg" <>,
    exception_do (let: "wg" := (mem.alloc "wg") in
    do:  (let: "$a0" := #(W64 (- 1)) in
    (method_call #(ptrTⁱᵈ WaitGroupⁱᵈ) #"Add"%go (![#ptrT] "wg")) "$a0");;;
    return: #()).

(* Wait blocks until the [WaitGroup] counter is zero.

   go: waitgroup.go:93:22 *)
Definition WaitGroup__Waitⁱᵐᵖˡ : val :=
  λ: "wg" <>,
    exception_do (let: "wg" := (mem.alloc "wg") in
    (if: race.Enabled
    then do:  ((func_call #race.Disable) #())
    else do:  #());;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "state" := (mem.alloc (type.zero_val #uint64T)) in
      let: "$r0" := ((method_call #atomic.Uint64ⁱᵈ #"Load"%go (struct.field_ref #WaitGroup #"state"%go (![#ptrT] "wg"))) #()) in
      do:  ("state" <-[#uint64T] "$r0");;;
      let: "v" := (mem.alloc (type.zero_val #int32T)) in
      let: "$r0" := (u_to_w32 ((![#uint64T] "state") ≫ #(W64 32))) in
      do:  ("v" <-[#int32T] "$r0");;;
      let: "w" := (mem.alloc (type.zero_val #uint32T)) in
      let: "$r0" := (u_to_w32 (![#uint64T] "state")) in
      do:  ("w" <-[#uint32T] "$r0");;;
      (if: (![#int32T] "v") = #(W32 0)
      then
        (if: race.Enabled
        then
          do:  ((func_call #race.Enable) #());;;
          do:  (let: "$a0" := (![#ptrT] "wg") in
          (func_call #race.Acquire) "$a0")
        else do:  #());;;
        return: (#())
      else do:  #());;;
      (if: let: "$a0" := (![#uint64T] "state") in
      let: "$a1" := ((![#uint64T] "state") + #(W64 1)) in
      (method_call #atomic.Uint64ⁱᵈ #"CompareAndSwap"%go (struct.field_ref #WaitGroup #"state"%go (![#ptrT] "wg"))) "$a0" "$a1"
      then
        (if: race.Enabled && ((![#uint32T] "w") = #(W32 0))
        then
          do:  (let: "$a0" := (struct.field_ref #WaitGroup #"sema"%go (![#ptrT] "wg")) in
          (func_call #race.Write) "$a0")
        else do:  #());;;
        do:  (let: "$a0" := (struct.field_ref #WaitGroup #"sema"%go (![#ptrT] "wg")) in
        (func_call #runtime_SemacquireWaitGroup) "$a0");;;
        (if: ((method_call #atomic.Uint64ⁱᵈ #"Load"%go (struct.field_ref #WaitGroup #"state"%go (![#ptrT] "wg"))) #()) ≠ #(W64 0)
        then
          do:  (let: "$a0" := (interface.make #stringTⁱᵈ #"sync: WaitGroup is reused before previous Wait has returned"%go) in
          Panic "$a0")
        else do:  #());;;
        (if: race.Enabled
        then
          do:  ((func_call #race.Enable) #());;;
          do:  (let: "$a0" := (![#ptrT] "wg") in
          (func_call #race.Acquire) "$a0")
        else do:  #());;;
        return: (#())
      else do:  #()));;;
    return: #()).

Definition vars' : list (go_string * go_type) := [].

Definition functions' : list (go_string * val) := [(NewCond, NewCondⁱᵐᵖˡ); (runtime_Semacquire, runtime_Semacquireⁱᵐᵖˡ); (runtime_SemacquireWaitGroup, runtime_SemacquireWaitGroupⁱᵐᵖˡ); (runtime_SemacquireRWMutexR, runtime_SemacquireRWMutexRⁱᵐᵖˡ); (runtime_SemacquireRWMutex, runtime_SemacquireRWMutexⁱᵐᵖˡ); (runtime_Semrelease, runtime_Semreleaseⁱᵐᵖˡ)].

Definition msets' : list (go_string * (list (go_string * val))) := [("Cond"%go, []); ("Cond'ptr"%go, [("Broadcast"%go, Cond__Broadcastⁱᵐᵖˡ); ("Signal"%go, Cond__Signalⁱᵐᵖˡ); ("Wait"%go, Cond__Waitⁱᵐᵖˡ)]); ("noCopy"%go, []); ("noCopy'ptr"%go, []); ("Mutex"%go, []); ("Mutex'ptr"%go, [("Lock"%go, Mutex__Lockⁱᵐᵖˡ); ("TryLock"%go, Mutex__TryLockⁱᵐᵖˡ); ("Unlock"%go, Mutex__Unlockⁱᵐᵖˡ)]); ("RWMutex"%go, []); ("RWMutex'ptr"%go, [("Lock"%go, RWMutex__Lockⁱᵐᵖˡ); ("RLock"%go, RWMutex__RLockⁱᵐᵖˡ); ("RLocker"%go, RWMutex__RLockerⁱᵐᵖˡ); ("RUnlock"%go, RWMutex__RUnlockⁱᵐᵖˡ); ("TryLock"%go, RWMutex__TryLockⁱᵐᵖˡ); ("TryRLock"%go, RWMutex__TryRLockⁱᵐᵖˡ); ("Unlock"%go, RWMutex__Unlockⁱᵐᵖˡ); ("rUnlockSlow"%go, RWMutex__rUnlockSlowⁱᵐᵖˡ)]); ("rlocker"%go, []); ("rlocker'ptr"%go, []); ("WaitGroup"%go, []); ("WaitGroup'ptr"%go, [("Add"%go, WaitGroup__Addⁱᵐᵖˡ); ("Done"%go, WaitGroup__Doneⁱᵐᵖˡ); ("Wait"%go, WaitGroup__Waitⁱᵐᵖˡ)])].

#[global] Instance info' : PkgInfo sync.sync :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [atomic.atomic; race.race];
  |}.

Axiom _'init : val.

Definition initialize' : val :=
  λ: <>,
    package.init #sync.sync (λ: <>,
      exception_do (do:  (race.initialize' #());;;
      do:  (atomic.initialize' #());;;
      do:  (package.alloc sync.sync #()))
      ).

End code.
End sync.
