(* autogenerated from sync *)
From New.golang Require Import defn.
Require Export New.code.internal.race.
Require Export New.code.sync.atomic.

Require Export New.trusted_code.sync.
Import sync.
Definition sync : go_string := "sync".

Module sync.
Section code.
Context `{ffi_syntax}.


Definition noCopy : go_type := structT [
].

Axiom RWMutex : go_type.

Definition WaitGroup : go_type := structT [
  "noCopy" :: noCopy;
  "state" :: atomic.Uint64;
  "sema" :: uint32T
].

(* Add adds delta, which may be negative, to the [WaitGroup] counter.
   If the counter becomes zero, all goroutines blocked on [WaitGroup.Wait] are released.
   If the counter goes negative, Add panics.

   Note that calls with a positive delta that occur when the counter is zero
   must happen before a Wait. Calls with a negative delta, or calls with a
   positive delta that start when the counter is greater than zero, may happen
   at any time.
   Typically this means the calls to Add should execute before the statement
   creating the goroutine or other event to be waited for.
   If a WaitGroup is reused to wait for several independent sets of events,
   new Add calls must happen after all previous Wait calls have returned.
   See the WaitGroup example.

   go: waitgroup.go:45:22 *)
Definition WaitGroup__Add : val :=
  rec: "WaitGroup__Add" "wg" "delta" :=
    with_defer: (let: "wg" := (ref_ty ptrT "wg") in
    let: "delta" := (ref_ty intT "delta") in
    (if: race.Enabled
    then
      (if: int_lt (![intT] "delta") #(W64 0)
      then
        do:  (let: "$a0" := (![ptrT] "wg") in
        (func_call #race #"ReleaseMerge"%go) "$a0")
      else do:  #());;;
      do:  ((func_call #race #"Disable"%go) #());;;
      do:  (let: "$f" := (func_call #race #"Enable"%go) in
      "$defer" <-[funcT] (let: "$oldf" := (![funcT] "$defer") in
      (λ: <>,
        "$f" #();;
        "$oldf" #()
        )))
    else do:  #());;;
    let: "state" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (let: "$a0" := ((![intT] "delta") ≪ #(W64 32)) in
    (method_call #atomic #"Uint64'ptr" #"Add" (struct.field_ref WaitGroup "state" (![ptrT] "wg"))) "$a0") in
    do:  ("state" <-[uint64T] "$r0");;;
    let: "v" := (ref_ty int32T (zero_val int32T)) in
    let: "$r0" := (to_u32 ((![uint64T] "state") ≫ #(W64 32))) in
    do:  ("v" <-[int32T] "$r0");;;
    let: "w" := (ref_ty uint32T (zero_val uint32T)) in
    let: "$r0" := (to_u32 (![uint64T] "state")) in
    do:  ("w" <-[uint32T] "$r0");;;
    (if: (race.Enabled && (int_gt (![intT] "delta") #(W64 0))) && ((![int32T] "v") = (to_u32 (![intT] "delta")))
    then
      do:  (let: "$a0" := (struct.field_ref WaitGroup "sema" (![ptrT] "wg")) in
      (func_call #race #"Read"%go) "$a0")
    else do:  #());;;
    (if: int_lt (![int32T] "v") #(W32 0)
    then
      do:  (let: "$a0" := (interface.make #""%go #"string"%go #"sync: negative WaitGroup counter"%go) in
      Panic "$a0")
    else do:  #());;;
    (if: (((![uint32T] "w") ≠ #(W32 0)) && (int_gt (![intT] "delta") #(W64 0))) && ((![int32T] "v") = (to_u32 (![intT] "delta")))
    then
      do:  (let: "$a0" := (interface.make #""%go #"string"%go #"sync: WaitGroup misuse: Add called concurrently with Wait"%go) in
      Panic "$a0")
    else do:  #());;;
    (if: (int_gt (![int32T] "v") #(W32 0)) || ((![uint32T] "w") = #(W32 0))
    then return: (#())
    else do:  #());;;
    (if: ((method_call #atomic #"Uint64'ptr" #"Load" (struct.field_ref WaitGroup "state" (![ptrT] "wg"))) #()) ≠ (![uint64T] "state")
    then
      do:  (let: "$a0" := (interface.make #""%go #"string"%go #"sync: WaitGroup misuse: Add called concurrently with Wait"%go) in
      Panic "$a0")
    else do:  #());;;
    do:  (let: "$a0" := #(W64 0) in
    (method_call #atomic #"Uint64'ptr" #"Store" (struct.field_ref WaitGroup "state" (![ptrT] "wg"))) "$a0");;;
    (for: (λ: <>, (![uint32T] "w") ≠ #(W32 0)); (λ: <>, do:  ("w" <-[uint32T] ((![uint32T] "w") - #(W32 1)))) := λ: <>,
      do:  (let: "$a0" := (struct.field_ref WaitGroup "sema" (![ptrT] "wg")) in
      let: "$a1" := #false in
      let: "$a2" := #(W64 0) in
      (func_call #sync.sync #"runtime_Semrelease"%go) "$a0" "$a1" "$a2"))).

(* Done decrements the [WaitGroup] counter by one.

   go: waitgroup.go:88:22 *)
Definition WaitGroup__Done : val :=
  rec: "WaitGroup__Done" "wg" <> :=
    exception_do (let: "wg" := (ref_ty ptrT "wg") in
    do:  (let: "$a0" := #(W64 (- 1)) in
    (method_call #sync.sync #"WaitGroup'ptr" #"Add" (![ptrT] "wg")) "$a0")).

(* Wait blocks until the [WaitGroup] counter is zero.

   go: waitgroup.go:93:22 *)
Definition WaitGroup__Wait : val :=
  rec: "WaitGroup__Wait" "wg" <> :=
    exception_do (let: "wg" := (ref_ty ptrT "wg") in
    (if: race.Enabled
    then do:  ((func_call #race #"Disable"%go) #())
    else do:  #());;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "state" := (ref_ty uint64T (zero_val uint64T)) in
      let: "$r0" := ((method_call #atomic #"Uint64'ptr" #"Load" (struct.field_ref WaitGroup "state" (![ptrT] "wg"))) #()) in
      do:  ("state" <-[uint64T] "$r0");;;
      let: "v" := (ref_ty int32T (zero_val int32T)) in
      let: "$r0" := (to_u32 ((![uint64T] "state") ≫ #(W64 32))) in
      do:  ("v" <-[int32T] "$r0");;;
      let: "w" := (ref_ty uint32T (zero_val uint32T)) in
      let: "$r0" := (to_u32 (![uint64T] "state")) in
      do:  ("w" <-[uint32T] "$r0");;;
      (if: (![int32T] "v") = #(W32 0)
      then
        (if: race.Enabled
        then
          do:  ((func_call #race #"Enable"%go) #());;;
          do:  (let: "$a0" := (![ptrT] "wg") in
          (func_call #race #"Acquire"%go) "$a0")
        else do:  #());;;
        return: (#())
      else do:  #());;;
      (if: let: "$a0" := (![uint64T] "state") in
      let: "$a1" := ((![uint64T] "state") + #(W64 1)) in
      (method_call #atomic #"Uint64'ptr" #"CompareAndSwap" (struct.field_ref WaitGroup "state" (![ptrT] "wg"))) "$a0" "$a1"
      then
        (if: race.Enabled && ((![uint32T] "w") = #(W32 0))
        then
          do:  (let: "$a0" := (struct.field_ref WaitGroup "sema" (![ptrT] "wg")) in
          (func_call #race #"Write"%go) "$a0")
        else do:  #());;;
        do:  (let: "$a0" := (struct.field_ref WaitGroup "sema" (![ptrT] "wg")) in
        (func_call #sync.sync #"runtime_SemacquireWaitGroup"%go) "$a0");;;
        (if: ((method_call #atomic #"Uint64'ptr" #"Load" (struct.field_ref WaitGroup "state" (![ptrT] "wg"))) #()) ≠ #(W64 0)
        then
          do:  (let: "$a0" := (interface.make #""%go #"string"%go #"sync: WaitGroup is reused before previous Wait has returned"%go) in
          Panic "$a0")
        else do:  #());;;
        (if: race.Enabled
        then
          do:  ((func_call #race #"Enable"%go) #());;;
          do:  (let: "$a0" := (![ptrT] "wg") in
          (func_call #race #"Acquire"%go) "$a0")
        else do:  #());;;
        return: (#())
      else do:  #()))).

Definition vars' : list (go_string * go_type) := [].

Definition functions' : list (go_string * val) := [("NewCond"%go, NewCond); ("runtime_Semacquire"%go, runtime_Semacquire); ("runtime_SemacquireWaitGroup"%go, runtime_SemacquireWaitGroup); ("runtime_Semrelease"%go, runtime_Semrelease)].

Definition msets' : list (go_string * (list (go_string * val))) := [("Cond"%go, []); ("Cond'ptr"%go, [("Broadcast"%go, Cond__Broadcast); ("Signal"%go, Cond__Signal); ("Wait"%go, Cond__Wait)]); ("noCopy"%go, []); ("noCopy'ptr"%go, []); ("Mutex"%go, []); ("Mutex'ptr"%go, [("Lock"%go, Mutex__Lock); ("Unlock"%go, Mutex__Unlock)]); ("WaitGroup"%go, []); ("WaitGroup'ptr"%go, [("Add"%go, WaitGroup__Add); ("Done"%go, WaitGroup__Done); ("Wait"%go, WaitGroup__Wait)])].

#[global] Instance info' : PkgInfo sync.sync :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [atomic; race];
  |}.

Axiom _'init : val.

Definition initialize' : val :=
  rec: "initialize'" <> :=
    globals.package_init sync.sync (λ: <>,
      exception_do (do:  race.initialize';;;
      do:  atomic.initialize')
      ).

End code.
End sync.
