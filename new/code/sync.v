(* autogenerated from sync *)
Require Export New.code.internal.race.
Require Export New.code.internal.synctest.
Require Export New.code.sync.atomic.

From New.golang Require Import defn.
Require Export New.trusted_code.sync.
Import sync.
Definition sync : go_string := "sync".

Module sync.

Definition noCopy : go.type := go.Named "sync.noCopy"%go [].

Definition Locker : go.type := go.Named "sync.Locker"%go [].

Definition runtime_notifyListNotifyAll {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync.runtime_notifyListNotifyAll"%go.

Definition Cond : go.type := go.Named "sync.Cond"%go [].

(* Broadcast wakes all goroutines waiting on c.

   It is allowed but not required for the caller to hold c.L
   during the call.

   go: cond.go:91:16 *)
Definition Cond__Broadcastⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "c" <>,
    exception_do (let: "c" := (GoAlloc (go.PointerType Cond) "c") in
    do:  ((MethodResolve (go.PointerType copyChecker) "check"%go #() (StructFieldRef Cond "checker"%go (![go.PointerType Cond] "c"))) #());;;
    do:  (let: "$a0" := (StructFieldRef Cond "notify"%go (![go.PointerType Cond] "c")) in
    (FuncResolve runtime_notifyListNotifyAll [] #()) "$a0");;;
    return: #()).

Definition runtime_notifyListNotifyOne {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync.runtime_notifyListNotifyOne"%go.

(* Signal wakes one goroutine waiting on c, if there is any.

   It is allowed but not required for the caller to hold c.L
   during the call.

   Signal() does not affect goroutine scheduling priority; if other goroutines
   are attempting to lock c.L, they may be awoken before a "waiting" goroutine.

   go: cond.go:82:16 *)
Definition Cond__Signalⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "c" <>,
    exception_do (let: "c" := (GoAlloc (go.PointerType Cond) "c") in
    do:  ((MethodResolve (go.PointerType copyChecker) "check"%go #() (StructFieldRef Cond "checker"%go (![go.PointerType Cond] "c"))) #());;;
    do:  (let: "$a0" := (StructFieldRef Cond "notify"%go (![go.PointerType Cond] "c")) in
    (FuncResolve runtime_notifyListNotifyOne [] #()) "$a0");;;
    return: #()).

Definition runtime_notifyListWait {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync.runtime_notifyListWait"%go.

Definition runtime_notifyListAdd {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync.runtime_notifyListAdd"%go.

(* Wait atomically unlocks c.L and suspends execution
   of the calling goroutine. After later resuming execution,
   Wait locks c.L before returning. Unlike in other systems,
   Wait cannot return unless awoken by [Cond.Broadcast] or [Cond.Signal].

   Because c.L is not locked while Wait is waiting, the caller
   typically cannot assume that the condition is true when
   Wait returns. Instead, the caller should Wait in a loop:

   	c.L.Lock()
   	for !condition() {
   	    c.Wait()
   	}
   	... make use of condition ...
   	c.L.Unlock()

   go: cond.go:67:16 *)
Definition Cond__Waitⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "c" <>,
    exception_do (let: "c" := (GoAlloc (go.PointerType Cond) "c") in
    do:  ((MethodResolve (go.PointerType copyChecker) "check"%go #() (StructFieldRef Cond "checker"%go (![go.PointerType Cond] "c"))) #());;;
    let: "t" := (GoAlloc go.uint32 (GoZeroVal go.uint32 #())) in
    let: "$r0" := (let: "$a0" := (StructFieldRef Cond "notify"%go (![go.PointerType Cond] "c")) in
    (FuncResolve runtime_notifyListAdd [] #()) "$a0") in
    do:  ("t" <-[go.uint32] "$r0");;;
    do:  ((MethodResolve Locker "Unlock"%go #() (![Locker] (StructFieldRef Cond "L"%go (![go.PointerType Cond] "c")))) #());;;
    do:  (let: "$a0" := (StructFieldRef Cond "notify"%go (![go.PointerType Cond] "c")) in
    let: "$a1" := (![go.uint32] "t") in
    (FuncResolve runtime_notifyListWait [] #()) "$a0" "$a1");;;
    do:  ((MethodResolve Locker "Lock"%go #() (![Locker] (StructFieldRef Cond "L"%go (![go.PointerType Cond] "c")))) #());;;
    return: #()).

Definition Condⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "noCopy"%go noCopy);
  (go.FieldDecl "L"%go Locker);
  (go.FieldDecl "notify"%go notifyList);
  (go.FieldDecl "checker"%go copyChecker)
].

Module Cond.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  noCopy : sync.noCopy.t;
  L : sync.Locker.t;
  notify : sync.notifyList.t;
  checker : sync.copyChecker.t;
}.
#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _) (zero_val _)|}.
End def.

#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End Cond.

Class Cond_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Cond_zero_val  :: go.TypeRepr Cond Cond.t;
  #[global] Cond_underlying :: go.Underlying (Cond) (Condⁱᵐᵖˡ);
  #[global] Cond_get_noCopy (x : Cond.t) :: go.IsGoStepPureDet (StructFieldGet (Cond) "noCopy") #x #x.(Cond.noCopy);
  #[global] Cond_set_noCopy (x : Cond.t) y :: go.IsGoStepPureDet (StructFieldSet (Cond) "noCopy") (#x, #y) #(x <|Cond.noCopy := y|>);
  #[global] Cond_get_L (x : Cond.t) :: go.IsGoStepPureDet (StructFieldGet (Cond) "L") #x #x.(Cond.L);
  #[global] Cond_set_L (x : Cond.t) y :: go.IsGoStepPureDet (StructFieldSet (Cond) "L") (#x, #y) #(x <|Cond.L := y|>);
  #[global] Cond_get_notify (x : Cond.t) :: go.IsGoStepPureDet (StructFieldGet (Cond) "notify") #x #x.(Cond.notify);
  #[global] Cond_set_notify (x : Cond.t) y :: go.IsGoStepPureDet (StructFieldSet (Cond) "notify") (#x, #y) #(x <|Cond.notify := y|>);
  #[global] Cond_get_checker (x : Cond.t) :: go.IsGoStepPureDet (StructFieldGet (Cond) "checker") #x #x.(Cond.checker);
  #[global] Cond_set_checker (x : Cond.t) y :: go.IsGoStepPureDet (StructFieldSet (Cond) "checker") (#x, #y) #(x <|Cond.checker := y|>);
  #[global] Cond'ptr_Broadcast_unfold :: MethodUnfold (go.PointerType (Cond)) "Broadcast" (Cond__Broadcastⁱᵐᵖˡ);
  #[global] Cond'ptr_Signal_unfold :: MethodUnfold (go.PointerType (Cond)) "Signal" (Cond__Signalⁱᵐᵖˡ);
  #[global] Cond'ptr_Wait_unfold :: MethodUnfold (go.PointerType (Cond)) "Wait" (Cond__Waitⁱᵐᵖˡ);
}.

Definition NewCond {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync.NewCond"%go.

(* NewCond returns a new Cond with Locker l.

   go: cond.go:48:6 *)
Definition NewCondⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l",
    exception_do (let: "l" := (GoAlloc Locker "l") in
    return: (GoAlloc Cond (CompositeLiteral Cond (LiteralValue [KeyedElement (Some (KeyField "L"%go)) (ElementExpression (![Locker] "l"))])))).

Axiom copyCheckerⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Definition noCopyⁱᵐᵖˡ : go.type := go.StructType [
].

Module noCopy.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
}.
#[global] Instance zero_val : ZeroVal t := {| zero_val := mk|}.
End def.

#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End noCopy.

Class noCopy_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] noCopy_zero_val  :: go.TypeRepr noCopy noCopy.t;
  #[global] noCopy_underlying :: go.Underlying (noCopy) (noCopyⁱᵐᵖˡ);
}.

Axiom Mapⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom readOnlyⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Definition expunged {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync.expunged"%go.

Axiom entryⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Definition newEntry {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync.newEntry"%go.

Class Mutex_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Mutex_zero_val  :: go.TypeRepr Mutex Mutex.t;
  #[global] Mutex_underlying :: go.Underlying (Mutex) (Mutexⁱᵐᵖˡ);
  #[global] Mutex'ptr_Lock_unfold :: MethodUnfold (go.PointerType (Mutex)) "Lock" (Mutex__Lockⁱᵐᵖˡ);
  #[global] Mutex'ptr_TryLock_unfold :: MethodUnfold (go.PointerType (Mutex)) "TryLock" (Mutex__TryLockⁱᵐᵖˡ);
  #[global] Mutex'ptr_Unlock_unfold :: MethodUnfold (go.PointerType (Mutex)) "Unlock" (Mutex__Unlockⁱᵐᵖˡ);
}.

Definition Lockerⁱᵐᵖˡ : go.type := go.InterfaceType [go.MethodElem #"Lock"%go (go.Signature [] false []); go.MethodElem #"Unlock"%go (go.Signature [] false [])].

Module Locker.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t  : Type := interface.t.
End def.
End Locker.

Class Locker_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Locker_zero_val  :: go.TypeRepr Locker Locker.t;
  #[global] Locker_underlying :: go.Underlying (Locker) (Lockerⁱᵐᵖˡ);
}.

Definition Once : go.type := go.Named "sync.Once"%go [].

(* Do calls the function f if and only if Do is being called for the
   first time for this instance of [Once]. In other words, given

   	var once Once

   if once.Do(f) is called multiple times, only the first call will invoke f,
   even if f has a different value in each invocation. A new instance of
   Once is required for each function to execute.

   Do is intended for initialization that must be run exactly once. Since f
   is niladic, it may be necessary to use a function literal to capture the
   arguments to a function to be invoked by Do:

   	config.once.Do(func() { config.init(filename) })

   Because no call to Do returns until the one call to f returns, if f causes
   Do to be called, it will deadlock.

   If f panics, Do considers it to have returned; future calls of Do return
   without calling f.

   go: once.go:52:16 *)
Definition Once__Doⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "o" "f",
    exception_do (let: "o" := (GoAlloc (go.PointerType Once) "o") in
    let: "f" := (GoAlloc (go.FunctionType (go.Signature [] false [])) "f") in
    (if: (~ ((MethodResolve (go.PointerType atomic.Bool) "Load"%go #() (StructFieldRef Once "done"%go (![go.PointerType Once] "o"))) #()))
    then
      do:  (let: "$a0" := (![go.FunctionType (go.Signature [] false [])] "f") in
      (MethodResolve (go.PointerType Once) "doSlow"%go #() (![go.PointerType Once] "o")) "$a0")
    else do:  #());;;
    return: #()).

(* go: once.go:73:16 *)
Definition Once__doSlowⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "o" "f",
    with_defer: (let: "o" := (GoAlloc (go.PointerType Once) "o") in
    let: "f" := (GoAlloc (go.FunctionType (go.Signature [] false [])) "f") in
    do:  ((MethodResolve (go.PointerType Mutex) "Lock"%go #() (StructFieldRef Once "m"%go (![go.PointerType Once] "o"))) #());;;
    do:  (let: "$f" := (MethodResolve (go.PointerType Mutex) "Unlock"%go #() (StructFieldRef Once "m"%go (![go.PointerType Once] "o"))) in
    "$defer" <-[deferType] (let: "$oldf" := (![deferType] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    (if: (~ ((MethodResolve (go.PointerType atomic.Bool) "Load"%go #() (StructFieldRef Once "done"%go (![go.PointerType Once] "o"))) #()))
    then
      do:  (let: "$a0" := #true in
      let: "$f" := (MethodResolve (go.PointerType atomic.Bool) "Store"%go #() (StructFieldRef Once "done"%go (![go.PointerType Once] "o"))) in
      "$defer" <-[deferType] (let: "$oldf" := (![deferType] "$defer") in
      (λ: <>,
        "$f" "$a0";;
        "$oldf" #()
        )));;;
      do:  ((![go.FunctionType (go.Signature [] false [])] "f") #())
    else do:  #());;;
    return: #()).

Definition Onceⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "_0"%go noCopy);
  (go.FieldDecl "done"%go atomic.Bool);
  (go.FieldDecl "m"%go Mutex)
].

Module Once.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  _ : sync.noCopy.t;
  done : atomic.Bool.t;
  m : sync.Mutex.t;
}.
#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _)|}.
End def.

#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End Once.

Class Once_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Once_zero_val  :: go.TypeRepr Once Once.t;
  #[global] Once_underlying :: go.Underlying (Once) (Onceⁱᵐᵖˡ);
  #[global] Once_get__ (x : Once.t) :: go.IsGoStepPureDet (StructFieldGet (Once) "_") #x #x.(Once._);
  #[global] Once_set__ (x : Once.t) y :: go.IsGoStepPureDet (StructFieldSet (Once) "_") (#x, #y) #(x <|Once._ := y|>);
  #[global] Once_get_done (x : Once.t) :: go.IsGoStepPureDet (StructFieldGet (Once) "done") #x #x.(Once.done);
  #[global] Once_set_done (x : Once.t) y :: go.IsGoStepPureDet (StructFieldSet (Once) "done") (#x, #y) #(x <|Once.done := y|>);
  #[global] Once_get_m (x : Once.t) :: go.IsGoStepPureDet (StructFieldGet (Once) "m") #x #x.(Once.m);
  #[global] Once_set_m (x : Once.t) y :: go.IsGoStepPureDet (StructFieldSet (Once) "m") (#x, #y) #(x <|Once.m := y|>);
  #[global] Once'ptr_Do_unfold :: MethodUnfold (go.PointerType (Once)) "Do" (Once__Doⁱᵐᵖˡ);
  #[global] Once'ptr_doSlow_unfold :: MethodUnfold (go.PointerType (Once)) "doSlow" (Once__doSlowⁱᵐᵖˡ);
}.

Definition OnceFunc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync.OnceFunc"%go.

Definition OnceValue {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync.OnceValue"%go.

Definition OnceValues {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync.OnceValues"%go.

Axiom Poolⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom poolLocalInternalⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom poolLocalⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Definition runtime_randn {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync.runtime_randn"%go.

Definition poolRaceHash {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync.poolRaceHash"%go.

Definition poolRaceAddr {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync.poolRaceAddr"%go.

Definition poolCleanup {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync.poolCleanup"%go.

Definition allPoolsMu {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync.allPoolsMu"%go.

Definition allPools {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync.allPools"%go.

Definition oldPools {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync.oldPools"%go.

Definition init {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync.init"%go.

Definition indexLocal {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync.indexLocal"%go.

Definition runtime_registerPoolCleanup {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync.runtime_registerPoolCleanup"%go.

Definition runtime_procPin {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync.runtime_procPin"%go.

Definition runtime_procUnpin {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync.runtime_procUnpin"%go.

Definition runtime_LoadAcquintptr {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync.runtime_LoadAcquintptr"%go.

Definition runtime_StoreReluintptr {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync.runtime_StoreReluintptr"%go.

Axiom poolDequeueⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom efaceⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom dequeueBits : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, Z.

Axiom dequeueLimit : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, Z.

Axiom dequeueNilⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom poolChainⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom poolChainEltⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Definition runtime_Semacquire {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync.runtime_Semacquire"%go.

Definition runtime_SemacquireWaitGroup {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync.runtime_SemacquireWaitGroup"%go.

Definition runtime_SemacquireRWMutexR {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync.runtime_SemacquireRWMutexR"%go.

Definition runtime_SemacquireRWMutex {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync.runtime_SemacquireRWMutex"%go.

Definition runtime_Semrelease {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync.runtime_Semrelease"%go.

Definition runtime_notifyListCheck {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync.runtime_notifyListCheck"%go.

Definition throw {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync.throw"%go.

Definition fatal {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync.fatal"%go.

Axiom notifyListⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Definition RWMutex : go.type := go.Named "sync.RWMutex"%go [].

Definition rwmutexMaxReaders {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Z := 1073741824.

(* Lock locks rw for writing.
   If the lock is already locked for reading or writing,
   Lock blocks until the lock is available.

   go: rwmutex.go:144:20 *)
Definition RWMutex__Lockⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "rw" <>,
    exception_do (let: "rw" := (GoAlloc (go.PointerType RWMutex) "rw") in
    (if: race.Enabled
    then
      do:  (let: "$a0" := (StructFieldRef RWMutex "w"%go (![go.PointerType RWMutex] "rw")) in
      (FuncResolve race.Read [] #()) "$a0");;;
      do:  ((FuncResolve race.Disable [] #()) #())
    else do:  #());;;
    do:  ((MethodResolve (go.PointerType Mutex) "Lock"%go #() (StructFieldRef RWMutex "w"%go (![go.PointerType RWMutex] "rw"))) #());;;
    let: "r" := (GoAlloc go.int32 (GoZeroVal go.int32 #())) in
    let: "$r0" := ((let: "$a0" := #(W32 (- rwmutexMaxReaders)) in
    (MethodResolve (go.PointerType atomic.Int32) "Add"%go #() (StructFieldRef RWMutex "readerCount"%go (![go.PointerType RWMutex] "rw"))) "$a0") +⟨go.int32⟩ #(W32 rwmutexMaxReaders)) in
    do:  ("r" <-[go.int32] "$r0");;;
    (if: ((![go.int32] "r") ≠⟨go.int32⟩ #(W32 0)) && ((let: "$a0" := (![go.int32] "r") in
    (MethodResolve (go.PointerType atomic.Int32) "Add"%go #() (StructFieldRef RWMutex "readerWait"%go (![go.PointerType RWMutex] "rw"))) "$a0") ≠⟨go.int32⟩ #(W32 0))
    then
      do:  (let: "$a0" := (StructFieldRef RWMutex "writerSem"%go (![go.PointerType RWMutex] "rw")) in
      let: "$a1" := #false in
      let: "$a2" := #(W64 0) in
      (FuncResolve runtime_SemacquireRWMutex [] #()) "$a0" "$a1" "$a2")
    else do:  #());;;
    (if: race.Enabled
    then
      do:  ((FuncResolve race.Enable [] #()) #());;;
      do:  (let: "$a0" := (StructFieldRef RWMutex "readerSem"%go (![go.PointerType RWMutex] "rw")) in
      (FuncResolve race.Acquire [] #()) "$a0");;;
      do:  (let: "$a0" := (StructFieldRef RWMutex "writerSem"%go (![go.PointerType RWMutex] "rw")) in
      (FuncResolve race.Acquire [] #()) "$a0")
    else do:  #());;;
    return: #()).

(* RLock locks rw for reading.

   It should not be used for recursive read locking; a blocked Lock
   call excludes new readers from acquiring the lock. See the
   documentation on the [RWMutex] type.

   go: rwmutex.go:67:20 *)
Definition RWMutex__RLockⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "rw" <>,
    exception_do (let: "rw" := (GoAlloc (go.PointerType RWMutex) "rw") in
    (if: race.Enabled
    then
      do:  (let: "$a0" := (StructFieldRef RWMutex "w"%go (![go.PointerType RWMutex] "rw")) in
      (FuncResolve race.Read [] #()) "$a0");;;
      do:  ((FuncResolve race.Disable [] #()) #())
    else do:  #());;;
    (if: (let: "$a0" := #(W32 1) in
    (MethodResolve (go.PointerType atomic.Int32) "Add"%go #() (StructFieldRef RWMutex "readerCount"%go (![go.PointerType RWMutex] "rw"))) "$a0") <⟨go.int32⟩ #(W32 0)
    then
      do:  (let: "$a0" := (StructFieldRef RWMutex "readerSem"%go (![go.PointerType RWMutex] "rw")) in
      let: "$a1" := #false in
      let: "$a2" := #(W64 0) in
      (FuncResolve runtime_SemacquireRWMutexR [] #()) "$a0" "$a1" "$a2")
    else do:  #());;;
    (if: race.Enabled
    then
      do:  ((FuncResolve race.Enable [] #()) #());;;
      do:  (let: "$a0" := (StructFieldRef RWMutex "readerSem"%go (![go.PointerType RWMutex] "rw")) in
      (FuncResolve race.Acquire [] #()) "$a0")
    else do:  #());;;
    return: #()).

Definition rlocker : go.type := go.Named "sync.rlocker"%go [].

(* RLocker returns a [Locker] interface that implements
   the [Locker.Lock] and [Locker.Unlock] methods by calling rw.RLock and rw.RUnlock.

   go: rwmutex.go:240:20 *)
Definition RWMutex__RLockerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "rw" <>,
    exception_do (let: "rw" := (GoAlloc (go.PointerType RWMutex) "rw") in
    return: (InterfaceMake (go.PointerType rlocker) (![go.PointerType RWMutex] "rw"))).

(* RUnlock undoes a single [RWMutex.RLock] call;
   it does not affect other simultaneous readers.
   It is a run-time error if rw is not locked for reading
   on entry to RUnlock.

   go: rwmutex.go:114:20 *)
Definition RWMutex__RUnlockⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "rw" <>,
    exception_do (let: "rw" := (GoAlloc (go.PointerType RWMutex) "rw") in
    (if: race.Enabled
    then
      do:  (let: "$a0" := (StructFieldRef RWMutex "w"%go (![go.PointerType RWMutex] "rw")) in
      (FuncResolve race.Read [] #()) "$a0");;;
      do:  (let: "$a0" := (StructFieldRef RWMutex "writerSem"%go (![go.PointerType RWMutex] "rw")) in
      (FuncResolve race.ReleaseMerge [] #()) "$a0");;;
      do:  ((FuncResolve race.Disable [] #()) #())
    else do:  #());;;
    (let: "r" := (GoAlloc go.int32 (GoZeroVal go.int32 #())) in
    let: "$r0" := (let: "$a0" := #(W32 (- 1)) in
    (MethodResolve (go.PointerType atomic.Int32) "Add"%go #() (StructFieldRef RWMutex "readerCount"%go (![go.PointerType RWMutex] "rw"))) "$a0") in
    do:  ("r" <-[go.int32] "$r0");;;
    (if: (![go.int32] "r") <⟨go.int32⟩ #(W32 0)
    then
      do:  (let: "$a0" := (![go.int32] "r") in
      (MethodResolve (go.PointerType RWMutex) "rUnlockSlow"%go #() (![go.PointerType RWMutex] "rw")) "$a0")
    else do:  #()));;;
    (if: race.Enabled
    then do:  ((FuncResolve race.Enable [] #()) #())
    else do:  #());;;
    return: #()).

(* TryLock tries to lock rw for writing and reports whether it succeeded.

   Note that while correct uses of TryLock do exist, they are rare,
   and use of TryLock is often a sign of a deeper problem
   in a particular use of mutexes.

   go: rwmutex.go:169:20 *)
Definition RWMutex__TryLockⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "rw" <>,
    exception_do (let: "rw" := (GoAlloc (go.PointerType RWMutex) "rw") in
    (if: race.Enabled
    then
      do:  (let: "$a0" := (StructFieldRef RWMutex "w"%go (![go.PointerType RWMutex] "rw")) in
      (FuncResolve race.Read [] #()) "$a0");;;
      do:  ((FuncResolve race.Disable [] #()) #())
    else do:  #());;;
    (if: (~ ((MethodResolve (go.PointerType Mutex) "TryLock"%go #() (StructFieldRef RWMutex "w"%go (![go.PointerType RWMutex] "rw"))) #()))
    then
      (if: race.Enabled
      then do:  ((FuncResolve race.Enable [] #()) #())
      else do:  #());;;
      return: (#false)
    else do:  #());;;
    (if: (~ (let: "$a0" := #(W32 0) in
    let: "$a1" := #(W32 (- rwmutexMaxReaders)) in
    (MethodResolve (go.PointerType atomic.Int32) "CompareAndSwap"%go #() (StructFieldRef RWMutex "readerCount"%go (![go.PointerType RWMutex] "rw"))) "$a0" "$a1"))
    then
      do:  ((MethodResolve (go.PointerType Mutex) "Unlock"%go #() (StructFieldRef RWMutex "w"%go (![go.PointerType RWMutex] "rw"))) #());;;
      (if: race.Enabled
      then do:  ((FuncResolve race.Enable [] #()) #())
      else do:  #());;;
      return: (#false)
    else do:  #());;;
    (if: race.Enabled
    then
      do:  ((FuncResolve race.Enable [] #()) #());;;
      do:  (let: "$a0" := (StructFieldRef RWMutex "readerSem"%go (![go.PointerType RWMutex] "rw")) in
      (FuncResolve race.Acquire [] #()) "$a0");;;
      do:  (let: "$a0" := (StructFieldRef RWMutex "writerSem"%go (![go.PointerType RWMutex] "rw")) in
      (FuncResolve race.Acquire [] #()) "$a0")
    else do:  #());;;
    return: (#true)).

(* TryRLock tries to lock rw for reading and reports whether it succeeded.

   Note that while correct uses of TryRLock do exist, they are rare,
   and use of TryRLock is often a sign of a deeper problem
   in a particular use of mutexes.

   go: rwmutex.go:87:20 *)
Definition RWMutex__TryRLockⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "rw" <>,
    exception_do (let: "rw" := (GoAlloc (go.PointerType RWMutex) "rw") in
    (if: race.Enabled
    then
      do:  (let: "$a0" := (StructFieldRef RWMutex "w"%go (![go.PointerType RWMutex] "rw")) in
      (FuncResolve race.Read [] #()) "$a0");;;
      do:  ((FuncResolve race.Disable [] #()) #())
    else do:  #());;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "c" := (GoAlloc go.int32 (GoZeroVal go.int32 #())) in
      let: "$r0" := ((MethodResolve (go.PointerType atomic.Int32) "Load"%go #() (StructFieldRef RWMutex "readerCount"%go (![go.PointerType RWMutex] "rw"))) #()) in
      do:  ("c" <-[go.int32] "$r0");;;
      (if: (![go.int32] "c") <⟨go.int32⟩ #(W32 0)
      then
        (if: race.Enabled
        then do:  ((FuncResolve race.Enable [] #()) #())
        else do:  #());;;
        return: (#false)
      else do:  #());;;
      (if: let: "$a0" := (![go.int32] "c") in
      let: "$a1" := ((![go.int32] "c") +⟨go.int32⟩ #(W32 1)) in
      (MethodResolve (go.PointerType atomic.Int32) "CompareAndSwap"%go #() (StructFieldRef RWMutex "readerCount"%go (![go.PointerType RWMutex] "rw"))) "$a0" "$a1"
      then
        (if: race.Enabled
        then
          do:  ((FuncResolve race.Enable [] #()) #());;;
          do:  (let: "$a0" := (StructFieldRef RWMutex "readerSem"%go (![go.PointerType RWMutex] "rw")) in
          (FuncResolve race.Acquire [] #()) "$a0")
        else do:  #());;;
        return: (#true)
      else do:  #()))).

(* Unlock unlocks rw for writing. It is a run-time error if rw is
   not locked for writing on entry to Unlock.

   As with Mutexes, a locked [RWMutex] is not associated with a particular
   goroutine. One goroutine may [RWMutex.RLock] ([RWMutex.Lock]) a RWMutex and then
   arrange for another goroutine to [RWMutex.RUnlock] ([RWMutex.Unlock]) it.

   go: rwmutex.go:201:20 *)
Definition RWMutex__Unlockⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "rw" <>,
    exception_do (let: "rw" := (GoAlloc (go.PointerType RWMutex) "rw") in
    (if: race.Enabled
    then
      do:  (let: "$a0" := (StructFieldRef RWMutex "w"%go (![go.PointerType RWMutex] "rw")) in
      (FuncResolve race.Read [] #()) "$a0");;;
      do:  (let: "$a0" := (StructFieldRef RWMutex "readerSem"%go (![go.PointerType RWMutex] "rw")) in
      (FuncResolve race.Release [] #()) "$a0");;;
      do:  ((FuncResolve race.Disable [] #()) #())
    else do:  #());;;
    let: "r" := (GoAlloc go.int32 (GoZeroVal go.int32 #())) in
    let: "$r0" := (let: "$a0" := #(W32 rwmutexMaxReaders) in
    (MethodResolve (go.PointerType atomic.Int32) "Add"%go #() (StructFieldRef RWMutex "readerCount"%go (![go.PointerType RWMutex] "rw"))) "$a0") in
    do:  ("r" <-[go.int32] "$r0");;;
    (if: (![go.int32] "r") ≥⟨go.int32⟩ #(W32 rwmutexMaxReaders)
    then
      do:  ((FuncResolve race.Enable [] #()) #());;;
      do:  (let: "$a0" := #"sync: Unlock of unlocked RWMutex"%go in
      (FuncResolve fatal [] #()) "$a0")
    else do:  #());;;
    (let: "i" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.int] "$r0");;;
    (for: (λ: <>, (![go.int] "i") <⟨go.int⟩ (s_to_w64 (![go.int32] "r"))); (λ: <>, do:  ("i" <-[go.int] ((![go.int] "i") +⟨go.int⟩ #(W64 1)))) := λ: <>,
      do:  (let: "$a0" := (StructFieldRef RWMutex "readerSem"%go (![go.PointerType RWMutex] "rw")) in
      let: "$a1" := #false in
      let: "$a2" := #(W64 0) in
      (FuncResolve runtime_Semrelease [] #()) "$a0" "$a1" "$a2")));;;
    do:  ((MethodResolve (go.PointerType Mutex) "Unlock"%go #() (StructFieldRef RWMutex "w"%go (![go.PointerType RWMutex] "rw"))) #());;;
    (if: race.Enabled
    then do:  ((FuncResolve race.Enable [] #()) #())
    else do:  #());;;
    return: #()).

(* go: rwmutex.go:129:20 *)
Definition RWMutex__rUnlockSlowⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "rw" "r",
    exception_do (let: "rw" := (GoAlloc (go.PointerType RWMutex) "rw") in
    let: "r" := (GoAlloc go.int32 "r") in
    (if: (((![go.int32] "r") +⟨go.int32⟩ #(W32 1)) =⟨go.int32⟩ #(W32 0)) || (((![go.int32] "r") +⟨go.int32⟩ #(W32 1)) =⟨go.int32⟩ #(W32 (- rwmutexMaxReaders)))
    then
      do:  ((FuncResolve race.Enable [] #()) #());;;
      do:  (let: "$a0" := #"sync: RUnlock of unlocked RWMutex"%go in
      (FuncResolve fatal [] #()) "$a0")
    else do:  #());;;
    (if: (let: "$a0" := #(W32 (- 1)) in
    (MethodResolve (go.PointerType atomic.Int32) "Add"%go #() (StructFieldRef RWMutex "readerWait"%go (![go.PointerType RWMutex] "rw"))) "$a0") =⟨go.int32⟩ #(W32 0)
    then
      do:  (let: "$a0" := (StructFieldRef RWMutex "writerSem"%go (![go.PointerType RWMutex] "rw")) in
      let: "$a1" := #false in
      let: "$a2" := #(W64 1) in
      (FuncResolve runtime_Semrelease [] #()) "$a0" "$a1" "$a2")
    else do:  #());;;
    return: #()).

Definition RWMutexⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "w"%go Mutex);
  (go.FieldDecl "writerSem"%go go.uint32);
  (go.FieldDecl "readerSem"%go go.uint32);
  (go.FieldDecl "readerCount"%go atomic.Int32);
  (go.FieldDecl "readerWait"%go atomic.Int32)
].

Module RWMutex.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  w : sync.Mutex.t;
  writerSem : w32;
  readerSem : w32;
  readerCount : atomic.Int32.t;
  readerWait : atomic.Int32.t;
}.
#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _)|}.
End def.

#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End RWMutex.

Class RWMutex_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] RWMutex_zero_val  :: go.TypeRepr RWMutex RWMutex.t;
  #[global] RWMutex_underlying :: go.Underlying (RWMutex) (RWMutexⁱᵐᵖˡ);
  #[global] RWMutex_get_w (x : RWMutex.t) :: go.IsGoStepPureDet (StructFieldGet (RWMutex) "w") #x #x.(RWMutex.w);
  #[global] RWMutex_set_w (x : RWMutex.t) y :: go.IsGoStepPureDet (StructFieldSet (RWMutex) "w") (#x, #y) #(x <|RWMutex.w := y|>);
  #[global] RWMutex_get_writerSem (x : RWMutex.t) :: go.IsGoStepPureDet (StructFieldGet (RWMutex) "writerSem") #x #x.(RWMutex.writerSem);
  #[global] RWMutex_set_writerSem (x : RWMutex.t) y :: go.IsGoStepPureDet (StructFieldSet (RWMutex) "writerSem") (#x, #y) #(x <|RWMutex.writerSem := y|>);
  #[global] RWMutex_get_readerSem (x : RWMutex.t) :: go.IsGoStepPureDet (StructFieldGet (RWMutex) "readerSem") #x #x.(RWMutex.readerSem);
  #[global] RWMutex_set_readerSem (x : RWMutex.t) y :: go.IsGoStepPureDet (StructFieldSet (RWMutex) "readerSem") (#x, #y) #(x <|RWMutex.readerSem := y|>);
  #[global] RWMutex_get_readerCount (x : RWMutex.t) :: go.IsGoStepPureDet (StructFieldGet (RWMutex) "readerCount") #x #x.(RWMutex.readerCount);
  #[global] RWMutex_set_readerCount (x : RWMutex.t) y :: go.IsGoStepPureDet (StructFieldSet (RWMutex) "readerCount") (#x, #y) #(x <|RWMutex.readerCount := y|>);
  #[global] RWMutex_get_readerWait (x : RWMutex.t) :: go.IsGoStepPureDet (StructFieldGet (RWMutex) "readerWait") #x #x.(RWMutex.readerWait);
  #[global] RWMutex_set_readerWait (x : RWMutex.t) y :: go.IsGoStepPureDet (StructFieldSet (RWMutex) "readerWait") (#x, #y) #(x <|RWMutex.readerWait := y|>);
  #[global] RWMutex'ptr_Lock_unfold :: MethodUnfold (go.PointerType (RWMutex)) "Lock" (RWMutex__Lockⁱᵐᵖˡ);
  #[global] RWMutex'ptr_RLock_unfold :: MethodUnfold (go.PointerType (RWMutex)) "RLock" (RWMutex__RLockⁱᵐᵖˡ);
  #[global] RWMutex'ptr_RLocker_unfold :: MethodUnfold (go.PointerType (RWMutex)) "RLocker" (RWMutex__RLockerⁱᵐᵖˡ);
  #[global] RWMutex'ptr_RUnlock_unfold :: MethodUnfold (go.PointerType (RWMutex)) "RUnlock" (RWMutex__RUnlockⁱᵐᵖˡ);
  #[global] RWMutex'ptr_TryLock_unfold :: MethodUnfold (go.PointerType (RWMutex)) "TryLock" (RWMutex__TryLockⁱᵐᵖˡ);
  #[global] RWMutex'ptr_TryRLock_unfold :: MethodUnfold (go.PointerType (RWMutex)) "TryRLock" (RWMutex__TryRLockⁱᵐᵖˡ);
  #[global] RWMutex'ptr_Unlock_unfold :: MethodUnfold (go.PointerType (RWMutex)) "Unlock" (RWMutex__Unlockⁱᵐᵖˡ);
  #[global] RWMutex'ptr_rUnlockSlow_unfold :: MethodUnfold (go.PointerType (RWMutex)) "rUnlockSlow" (RWMutex__rUnlockSlowⁱᵐᵖˡ);
}.

Definition syscall_hasWaitingReaders {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync.syscall_hasWaitingReaders"%go.

Definition rlockerⁱᵐᵖˡ : go.type := RWMutex.

Module rlocker.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t  : Type := sync.RWMutex.t.
End def.
End rlocker.

Class rlocker_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] rlocker_zero_val  :: go.TypeRepr rlocker rlocker.t;
  #[global] rlocker_underlying :: go.Underlying (rlocker) (rlockerⁱᵐᵖˡ);
  #[global] rlocker_get_w (x : rlocker.t) :: go.IsGoStepPureDet (StructFieldGet (rlocker) "w") #x #x.(rlocker.w);
  #[global] rlocker_set_w (x : rlocker.t) y :: go.IsGoStepPureDet (StructFieldSet (rlocker) "w") (#x, #y) #(x <|rlocker.w := y|>);
  #[global] rlocker_get_writerSem (x : rlocker.t) :: go.IsGoStepPureDet (StructFieldGet (rlocker) "writerSem") #x #x.(rlocker.writerSem);
  #[global] rlocker_set_writerSem (x : rlocker.t) y :: go.IsGoStepPureDet (StructFieldSet (rlocker) "writerSem") (#x, #y) #(x <|rlocker.writerSem := y|>);
  #[global] rlocker_get_readerSem (x : rlocker.t) :: go.IsGoStepPureDet (StructFieldGet (rlocker) "readerSem") #x #x.(rlocker.readerSem);
  #[global] rlocker_set_readerSem (x : rlocker.t) y :: go.IsGoStepPureDet (StructFieldSet (rlocker) "readerSem") (#x, #y) #(x <|rlocker.readerSem := y|>);
  #[global] rlocker_get_readerCount (x : rlocker.t) :: go.IsGoStepPureDet (StructFieldGet (rlocker) "readerCount") #x #x.(rlocker.readerCount);
  #[global] rlocker_set_readerCount (x : rlocker.t) y :: go.IsGoStepPureDet (StructFieldSet (rlocker) "readerCount") (#x, #y) #(x <|rlocker.readerCount := y|>);
  #[global] rlocker_get_readerWait (x : rlocker.t) :: go.IsGoStepPureDet (StructFieldGet (rlocker) "readerWait") #x #x.(rlocker.readerWait);
  #[global] rlocker_set_readerWait (x : rlocker.t) y :: go.IsGoStepPureDet (StructFieldSet (rlocker) "readerWait") (#x, #y) #(x <|rlocker.readerWait := y|>);
}.

Definition WaitGroup : go.type := go.Named "sync.WaitGroup"%go [].

Definition waitGroupBubbleFlag {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Z := 2147483648.

(* Add adds delta, which may be negative, to the [WaitGroup] task counter.
   If the counter becomes zero, all goroutines blocked on [WaitGroup.Wait] are released.
   If the counter goes negative, Add panics.

   Callers should prefer [WaitGroup.Go].

   Note that calls with a positive delta that occur when the counter is zero
   must happen before a Wait. Calls with a negative delta, or calls with a
   positive delta that start when the counter is greater than zero, may happen
   at any time.
   Typically this means the calls to Add should execute before the statement
   creating the goroutine or other event to be waited for.
   If a WaitGroup is reused to wait for several independent sets of events,
   new Add calls must happen after all previous Wait calls have returned.
   See the WaitGroup example.

   go: waitgroup.go:77:22 *)
Definition WaitGroup__Addⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "wg" "delta",
    with_defer: (let: "wg" := (GoAlloc (go.PointerType WaitGroup) "wg") in
    let: "delta" := (GoAlloc go.int "delta") in
    (if: race.Enabled
    then
      (if: (![go.int] "delta") <⟨go.int⟩ #(W64 0)
      then
        do:  (let: "$a0" := (![go.PointerType WaitGroup] "wg") in
        (FuncResolve race.ReleaseMerge [] #()) "$a0")
      else do:  #());;;
      do:  ((FuncResolve race.Disable [] #()) #());;;
      do:  (let: "$f" := (FuncResolve race.Enable [] #()) in
      "$defer" <-[deferType] (let: "$oldf" := (![deferType] "$defer") in
      (λ: <>,
        "$f" #();;
        "$oldf" #()
        )))
    else do:  #());;;
    let: "bubbled" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #false in
    do:  ("bubbled" <-[go.bool] "$r0");;;
    (if: (FuncResolve synctest.IsInBubble [] #()) #()
    then
      let: "$sw" := (let: "$a0" := (![go.PointerType WaitGroup] "wg") in
      (FuncResolve synctest.Associate [WaitGroup] #()) "$a0") in
      (if: "$sw" =⟨synctest.Association⟩ synctest.Unbubbled
      then do:  #()
      else
        (if: "$sw" =⟨synctest.Association⟩ synctest.OtherBubble
        then
          do:  (let: "$a0" := #"sync: WaitGroup.Add called from multiple synctest bubbles"%go in
          (FuncResolve fatal [] #()) "$a0")
        else
          (if: "$sw" =⟨synctest.Association⟩ synctest.CurrentBubble
          then
            let: "$r0" := #true in
            do:  ("bubbled" <-[go.bool] "$r0");;;
            let: "state" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
            let: "$r0" := (let: "$a0" := #(W64 waitGroupBubbleFlag) in
            (MethodResolve (go.PointerType atomic.Uint64) "Or"%go #() (StructFieldRef WaitGroup "state"%go (![go.PointerType WaitGroup] "wg"))) "$a0") in
            do:  ("state" <-[go.uint64] "$r0");;;
            (if: ((![go.uint64] "state") ≠⟨go.uint64⟩ #(W64 0)) && (((![go.uint64] "state") &⟨go.uint64⟩ #(W64 waitGroupBubbleFlag)) =⟨go.uint64⟩ #(W64 0))
            then
              do:  (let: "$a0" := #"sync: WaitGroup.Add called from inside and outside synctest bubble"%go in
              (FuncResolve fatal [] #()) "$a0")
            else do:  #())
          else do:  #())))
    else do:  #());;;
    let: "state" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (let: "$a0" := ((s_to_w64 (![go.int] "delta")) ≪⟨go.uint64⟩ #(W64 32)) in
    (MethodResolve (go.PointerType atomic.Uint64) "Add"%go #() (StructFieldRef WaitGroup "state"%go (![go.PointerType WaitGroup] "wg"))) "$a0") in
    do:  ("state" <-[go.uint64] "$r0");;;
    (if: (((![go.uint64] "state") &⟨go.uint64⟩ #(W64 waitGroupBubbleFlag)) ≠⟨go.uint64⟩ #(W64 0)) && (~ (![go.bool] "bubbled"))
    then
      do:  (let: "$a0" := #"sync: WaitGroup.Add called from inside and outside synctest bubble"%go in
      (FuncResolve fatal [] #()) "$a0")
    else do:  #());;;
    let: "v" := (GoAlloc go.int32 (GoZeroVal go.int32 #())) in
    let: "$r0" := (u_to_w32 ((![go.uint64] "state") ≫⟨go.uint64⟩ #(W64 32))) in
    do:  ("v" <-[go.int32] "$r0");;;
    let: "w" := (GoAlloc go.uint32 (GoZeroVal go.uint32 #())) in
    let: "$r0" := (u_to_w32 ((![go.uint64] "state") &⟨go.uint64⟩ #(W64 2147483647))) in
    do:  ("w" <-[go.uint32] "$r0");;;
    (if: (race.Enabled && ((![go.int] "delta") >⟨go.int⟩ #(W64 0))) && ((![go.int32] "v") =⟨go.int32⟩ (s_to_w32 (![go.int] "delta")))
    then
      do:  (let: "$a0" := (StructFieldRef WaitGroup "sema"%go (![go.PointerType WaitGroup] "wg")) in
      (FuncResolve race.Read [] #()) "$a0")
    else do:  #());;;
    (if: (![go.int32] "v") <⟨go.int32⟩ #(W32 0)
    then
      do:  (let: "$a0" := (InterfaceMake go.string #"sync: negative WaitGroup counter"%go) in
      (FuncResolve go.panic [] #()) "$a0")
    else do:  #());;;
    (if: (((![go.uint32] "w") ≠⟨go.uint32⟩ #(W32 0)) && ((![go.int] "delta") >⟨go.int⟩ #(W64 0))) && ((![go.int32] "v") =⟨go.int32⟩ (s_to_w32 (![go.int] "delta")))
    then
      do:  (let: "$a0" := (InterfaceMake go.string #"sync: WaitGroup misuse: Add called concurrently with Wait"%go) in
      (FuncResolve go.panic [] #()) "$a0")
    else do:  #());;;
    (if: ((![go.int32] "v") >⟨go.int32⟩ #(W32 0)) || ((![go.uint32] "w") =⟨go.uint32⟩ #(W32 0))
    then return: (#())
    else do:  #());;;
    (if: ((MethodResolve (go.PointerType atomic.Uint64) "Load"%go #() (StructFieldRef WaitGroup "state"%go (![go.PointerType WaitGroup] "wg"))) #()) ≠⟨go.uint64⟩ (![go.uint64] "state")
    then
      do:  (let: "$a0" := (InterfaceMake go.string #"sync: WaitGroup misuse: Add called concurrently with Wait"%go) in
      (FuncResolve go.panic [] #()) "$a0")
    else do:  #());;;
    do:  (let: "$a0" := #(W64 0) in
    (MethodResolve (go.PointerType atomic.Uint64) "Store"%go #() (StructFieldRef WaitGroup "state"%go (![go.PointerType WaitGroup] "wg"))) "$a0");;;
    (if: ![go.bool] "bubbled"
    then
      do:  (let: "$a0" := (![go.PointerType WaitGroup] "wg") in
      (FuncResolve synctest.Disassociate [WaitGroup] #()) "$a0")
    else do:  #());;;
    (for: (λ: <>, (![go.uint32] "w") ≠⟨go.uint32⟩ #(W32 0)); (λ: <>, do:  ("w" <-[go.uint32] ((![go.uint32] "w") -⟨go.uint32⟩ #(W32 1)))) := λ: <>,
      do:  (let: "$a0" := (StructFieldRef WaitGroup "sema"%go (![go.PointerType WaitGroup] "wg")) in
      let: "$a1" := #false in
      let: "$a2" := #(W64 0) in
      (FuncResolve runtime_Semrelease [] #()) "$a0" "$a1" "$a2"));;;
    return: #()).

(* Done decrements the [WaitGroup] task counter by one.
   It is equivalent to Add(-1).

   Callers should prefer [WaitGroup.Go].

   In the terminology of [the Go memory model], a call to Done
   "synchronizes before" the return of any Wait call that it unblocks.

   [the Go memory model]: https://go.dev/ref/mem

   go: waitgroup.go:155:22 *)
Definition WaitGroup__Doneⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "wg" <>,
    exception_do (let: "wg" := (GoAlloc (go.PointerType WaitGroup) "wg") in
    do:  (let: "$a0" := #(W64 (- 1)) in
    (MethodResolve (go.PointerType WaitGroup) "Add"%go #() (![go.PointerType WaitGroup] "wg")) "$a0");;;
    return: #()).

(* Go calls f in a new goroutine and adds that task to the [WaitGroup].
   When f returns, the task is removed from the WaitGroup.

   The function f must not panic.

   If the WaitGroup is empty, Go must happen before a [WaitGroup.Wait].
   Typically, this simply means Go is called to start tasks before Wait is called.
   If the WaitGroup is not empty, Go may happen at any time.
   This means a goroutine started by Go may itself call Go.
   If a WaitGroup is reused to wait for several independent sets of tasks,
   new Go calls must happen after all previous Wait calls have returned.

   In the terminology of [the Go memory model], the return from f
   "synchronizes before" the return of any Wait call that it unblocks.

   [the Go memory model]: https://go.dev/ref/mem

   go: waitgroup.go:235:22 *)
Definition WaitGroup__Goⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "wg" "f",
    exception_do (let: "wg" := (GoAlloc (go.PointerType WaitGroup) "wg") in
    let: "f" := (GoAlloc (go.FunctionType (go.Signature [] false [])) "f") in
    do:  (let: "$a0" := #(W64 1) in
    (MethodResolve (go.PointerType WaitGroup) "Add"%go #() (![go.PointerType WaitGroup] "wg")) "$a0");;;
    let: "$go" := (λ: <>,
      with_defer: (do:  (let: "$f" := (MethodResolve (go.PointerType WaitGroup) "Done"%go #() (![go.PointerType WaitGroup] "wg")) in
      "$defer" <-[deferType] (let: "$oldf" := (![deferType] "$defer") in
      (λ: <>,
        "$f" #();;
        "$oldf" #()
        )));;;
      do:  ((![go.FunctionType (go.Signature [] false [])] "f") #());;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    return: #()).

(* Wait blocks until the [WaitGroup] task counter is zero.

   go: waitgroup.go:160:22 *)
Definition WaitGroup__Waitⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "wg" <>,
    exception_do (let: "wg" := (GoAlloc (go.PointerType WaitGroup) "wg") in
    (if: race.Enabled
    then do:  ((FuncResolve race.Disable [] #()) #())
    else do:  #());;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "state" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: "$r0" := ((MethodResolve (go.PointerType atomic.Uint64) "Load"%go #() (StructFieldRef WaitGroup "state"%go (![go.PointerType WaitGroup] "wg"))) #()) in
      do:  ("state" <-[go.uint64] "$r0");;;
      let: "v" := (GoAlloc go.int32 (GoZeroVal go.int32 #())) in
      let: "$r0" := (u_to_w32 ((![go.uint64] "state") ≫⟨go.uint64⟩ #(W64 32))) in
      do:  ("v" <-[go.int32] "$r0");;;
      let: "w" := (GoAlloc go.uint32 (GoZeroVal go.uint32 #())) in
      let: "$r0" := (u_to_w32 ((![go.uint64] "state") &⟨go.uint64⟩ #(W64 2147483647))) in
      do:  ("w" <-[go.uint32] "$r0");;;
      (if: (![go.int32] "v") =⟨go.int32⟩ #(W32 0)
      then
        (if: race.Enabled
        then
          do:  ((FuncResolve race.Enable [] #()) #());;;
          do:  (let: "$a0" := (![go.PointerType WaitGroup] "wg") in
          (FuncResolve race.Acquire [] #()) "$a0")
        else do:  #());;;
        (if: (((![go.uint32] "w") =⟨go.uint32⟩ #(W32 0)) && (((![go.uint64] "state") &⟨go.uint64⟩ #(W64 waitGroupBubbleFlag)) ≠⟨go.uint64⟩ #(W64 0))) && (let: "$a0" := (![go.PointerType WaitGroup] "wg") in
        (FuncResolve synctest.IsAssociated [WaitGroup] #()) "$a0")
        then
          (if: let: "$a0" := (![go.uint64] "state") in
          let: "$a1" := #(W64 0) in
          (MethodResolve (go.PointerType atomic.Uint64) "CompareAndSwap"%go #() (StructFieldRef WaitGroup "state"%go (![go.PointerType WaitGroup] "wg"))) "$a0" "$a1"
          then
            do:  (let: "$a0" := (![go.PointerType WaitGroup] "wg") in
            (FuncResolve synctest.Disassociate [WaitGroup] #()) "$a0")
          else do:  #())
        else do:  #());;;
        return: (#())
      else do:  #());;;
      (if: let: "$a0" := (![go.uint64] "state") in
      let: "$a1" := ((![go.uint64] "state") +⟨go.uint64⟩ #(W64 1)) in
      (MethodResolve (go.PointerType atomic.Uint64) "CompareAndSwap"%go #() (StructFieldRef WaitGroup "state"%go (![go.PointerType WaitGroup] "wg"))) "$a0" "$a1"
      then
        (if: race.Enabled && ((![go.uint32] "w") =⟨go.uint32⟩ #(W32 0))
        then
          do:  (let: "$a0" := (StructFieldRef WaitGroup "sema"%go (![go.PointerType WaitGroup] "wg")) in
          (FuncResolve race.Write [] #()) "$a0")
        else do:  #());;;
        let: "synctestDurable" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
        let: "$r0" := #false in
        do:  ("synctestDurable" <-[go.bool] "$r0");;;
        (if: (((![go.uint64] "state") &⟨go.uint64⟩ #(W64 waitGroupBubbleFlag)) ≠⟨go.uint64⟩ #(W64 0)) && ((FuncResolve synctest.IsInBubble [] #()) #())
        then
          (if: race.Enabled
          then do:  ((FuncResolve race.Enable [] #()) #())
          else do:  #());;;
          (if: let: "$a0" := (![go.PointerType WaitGroup] "wg") in
          (FuncResolve synctest.IsAssociated [WaitGroup] #()) "$a0"
          then
            let: "$r0" := #true in
            do:  ("synctestDurable" <-[go.bool] "$r0")
          else do:  #());;;
          (if: race.Enabled
          then do:  ((FuncResolve race.Disable [] #()) #())
          else do:  #())
        else do:  #());;;
        do:  (let: "$a0" := (StructFieldRef WaitGroup "sema"%go (![go.PointerType WaitGroup] "wg")) in
        let: "$a1" := (![go.bool] "synctestDurable") in
        (FuncResolve runtime_SemacquireWaitGroup [] #()) "$a0" "$a1");;;
        (if: ((MethodResolve (go.PointerType atomic.Uint64) "Load"%go #() (StructFieldRef WaitGroup "state"%go (![go.PointerType WaitGroup] "wg"))) #()) ≠⟨go.uint64⟩ #(W64 0)
        then
          do:  (let: "$a0" := (InterfaceMake go.string #"sync: WaitGroup is reused before previous Wait has returned"%go) in
          (FuncResolve go.panic [] #()) "$a0")
        else do:  #());;;
        (if: race.Enabled
        then
          do:  ((FuncResolve race.Enable [] #()) #());;;
          do:  (let: "$a0" := (![go.PointerType WaitGroup] "wg") in
          (FuncResolve race.Acquire [] #()) "$a0")
        else do:  #());;;
        return: (#())
      else do:  #()));;;
    return: #()).

Definition WaitGroupⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "noCopy"%go noCopy);
  (go.FieldDecl "state"%go atomic.Uint64);
  (go.FieldDecl "sema"%go go.uint32)
].

Module WaitGroup.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  noCopy : sync.noCopy.t;
  state : atomic.Uint64.t;
  sema : w32;
}.
#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _)|}.
End def.

#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End WaitGroup.

Class WaitGroup_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] WaitGroup_zero_val  :: go.TypeRepr WaitGroup WaitGroup.t;
  #[global] WaitGroup_underlying :: go.Underlying (WaitGroup) (WaitGroupⁱᵐᵖˡ);
  #[global] WaitGroup_get_noCopy (x : WaitGroup.t) :: go.IsGoStepPureDet (StructFieldGet (WaitGroup) "noCopy") #x #x.(WaitGroup.noCopy);
  #[global] WaitGroup_set_noCopy (x : WaitGroup.t) y :: go.IsGoStepPureDet (StructFieldSet (WaitGroup) "noCopy") (#x, #y) #(x <|WaitGroup.noCopy := y|>);
  #[global] WaitGroup_get_state (x : WaitGroup.t) :: go.IsGoStepPureDet (StructFieldGet (WaitGroup) "state") #x #x.(WaitGroup.state);
  #[global] WaitGroup_set_state (x : WaitGroup.t) y :: go.IsGoStepPureDet (StructFieldSet (WaitGroup) "state") (#x, #y) #(x <|WaitGroup.state := y|>);
  #[global] WaitGroup_get_sema (x : WaitGroup.t) :: go.IsGoStepPureDet (StructFieldGet (WaitGroup) "sema") #x #x.(WaitGroup.sema);
  #[global] WaitGroup_set_sema (x : WaitGroup.t) y :: go.IsGoStepPureDet (StructFieldSet (WaitGroup) "sema") (#x, #y) #(x <|WaitGroup.sema := y|>);
  #[global] WaitGroup'ptr_Add_unfold :: MethodUnfold (go.PointerType (WaitGroup)) "Add" (WaitGroup__Addⁱᵐᵖˡ);
  #[global] WaitGroup'ptr_Done_unfold :: MethodUnfold (go.PointerType (WaitGroup)) "Done" (WaitGroup__Doneⁱᵐᵖˡ);
  #[global] WaitGroup'ptr_Go_unfold :: MethodUnfold (go.PointerType (WaitGroup)) "Go" (WaitGroup__Goⁱᵐᵖˡ);
  #[global] WaitGroup'ptr_Wait_unfold :: MethodUnfold (go.PointerType (WaitGroup)) "Wait" (WaitGroup__Waitⁱᵐᵖˡ);
}.

#[global] Instance info' : PkgInfo sync.sync := 
{|
  pkg_imported_pkgs := [code.sync.atomic.atomic; code.internal.race.race; code.internal.synctest.synctest]
|}.

Axiom _'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init sync.sync (λ: <>,
      exception_do (do:  (GoGlobalAlloc expunged (go.PointerType (go.InterfaceType [])));;;
      do:  (synctest.initialize' #());;;
      do:  (race.initialize' #());;;
      do:  (atomic.initialize' #());;;
      let: "$r0" := (GoAlloc (go.InterfaceType []) (GoZeroVal (go.InterfaceType []) #())) in
      do:  ((GloblalVarAddr #expunged) <-[go.PointerType (go.InterfaceType [])] "$r0"))
      ).

Class Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Cond_instance :: Cond_Assumptions;
  #[global] noCopy_instance :: noCopy_Assumptions;
  #[global] Mutex_instance :: Mutex_Assumptions;
  #[global] Locker_instance :: Locker_Assumptions;
  #[global] Once_instance :: Once_Assumptions;
  #[global] RWMutex_instance :: RWMutex_Assumptions;
  #[global] rlocker_instance :: rlocker_Assumptions;
  #[global] WaitGroup_instance :: WaitGroup_Assumptions;
  #[global] NewCond_unfold :: FuncUnfold NewCond [] (NewCondⁱᵐᵖˡ);
  #[global] runtime_Semacquire_unfold :: FuncUnfold runtime_Semacquire [] (runtime_Semacquireⁱᵐᵖˡ);
  #[global] runtime_SemacquireWaitGroup_unfold :: FuncUnfold runtime_SemacquireWaitGroup [] (runtime_SemacquireWaitGroupⁱᵐᵖˡ);
  #[global] runtime_SemacquireRWMutexR_unfold :: FuncUnfold runtime_SemacquireRWMutexR [] (runtime_SemacquireRWMutexRⁱᵐᵖˡ);
  #[global] runtime_SemacquireRWMutex_unfold :: FuncUnfold runtime_SemacquireRWMutex [] (runtime_SemacquireRWMutexⁱᵐᵖˡ);
  #[global] runtime_Semrelease_unfold :: FuncUnfold runtime_Semrelease [] (runtime_Semreleaseⁱᵐᵖˡ);
  #[global] runtime_notifyListAdd_unfold :: FuncUnfold runtime_notifyListAdd [] (runtime_notifyListAddⁱᵐᵖˡ);
  #[global] runtime_notifyListWait_unfold :: FuncUnfold runtime_notifyListWait [] (runtime_notifyListWaitⁱᵐᵖˡ);
  #[global] runtime_notifyListNotifyAll_unfold :: FuncUnfold runtime_notifyListNotifyAll [] (runtime_notifyListNotifyAllⁱᵐᵖˡ);
  #[global] runtime_notifyListNotifyOne_unfold :: FuncUnfold runtime_notifyListNotifyOne [] (runtime_notifyListNotifyOneⁱᵐᵖˡ);
  #[global] runtime_notifyListCheck_unfold :: FuncUnfold runtime_notifyListCheck [] (runtime_notifyListCheckⁱᵐᵖˡ);
}.
End sync.
