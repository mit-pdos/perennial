(* autogenerated from sync *)
From New.golang Require Import defn.
Require Export New.code.internal.race.
Require Export New.code.sync.atomic.

Require Export New.trusted_code.sync.
Import sync.
Definition sync : go_string := "sync".

Module sync.
Section code.
Context `{ffi_syntax}.


Definition noCopy : go_type := structT [
].

Definition RWMutex : go_type := structT [
  "w" :: Mutex;
  "writerSem" :: uint32T;
  "readerSem" :: uint32T;
  "readerCount" :: atomic.Int32;
  "readerWait" :: atomic.Int32
].

Definition rwmutexMaxReaders : Z := 1073741824.

(* RLock locks rw for reading.

   It should not be used for recursive read locking; a blocked Lock
   call excludes new readers from acquiring the lock. See the
   documentation on the [RWMutex] type.

   go: rwmutex.go:67:20 *)
Definition RWMutex__RLock : val :=
  rec: "RWMutex__RLock" "rw" <> :=
    exception_do (let: "rw" := (mem.alloc "rw") in
    (if: race.Enabled
    then
      do:  (let: "$a0" := (struct.field_ref #RWMutex #"w"%go (![#ptrT] "rw")) in
      (func_call #race.race #"Read"%go) "$a0");;;
      do:  ((func_call #race.race #"Disable"%go) #())
    else do:  #());;;
    (if: int_lt (let: "$a0" := #(W32 1) in
    (method_call #atomic #"Int32'ptr" #"Add" (struct.field_ref #RWMutex #"readerCount"%go (![#ptrT] "rw"))) "$a0") #(W32 0)
    then
      do:  (let: "$a0" := (struct.field_ref #RWMutex #"readerSem"%go (![#ptrT] "rw")) in
      let: "$a1" := #false in
      let: "$a2" := #(W64 0) in
      (func_call #sync.sync #"runtime_SemacquireRWMutexR"%go) "$a0" "$a1" "$a2")
    else do:  #());;;
    (if: race.Enabled
    then
      do:  ((func_call #race.race #"Enable"%go) #());;;
      do:  (let: "$a0" := (struct.field_ref #RWMutex #"readerSem"%go (![#ptrT] "rw")) in
      (func_call #race.race #"Acquire"%go) "$a0")
    else do:  #())).

(* TryRLock tries to lock rw for reading and reports whether it succeeded.

   Note that while correct uses of TryRLock do exist, they are rare,
   and use of TryRLock is often a sign of a deeper problem
   in a particular use of mutexes.

   go: rwmutex.go:87:20 *)
Definition RWMutex__TryRLock : val :=
  rec: "RWMutex__TryRLock" "rw" <> :=
    exception_do (let: "rw" := (mem.alloc "rw") in
    (if: race.Enabled
    then
      do:  (let: "$a0" := (struct.field_ref #RWMutex #"w"%go (![#ptrT] "rw")) in
      (func_call #race.race #"Read"%go) "$a0");;;
      do:  ((func_call #race.race #"Disable"%go) #())
    else do:  #());;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "c" := (mem.alloc (type.zero_val #int32T)) in
      let: "$r0" := ((method_call #atomic #"Int32'ptr" #"Load" (struct.field_ref #RWMutex #"readerCount"%go (![#ptrT] "rw"))) #()) in
      do:  ("c" <-[#int32T] "$r0");;;
      (if: int_lt (![#int32T] "c") #(W32 0)
      then
        (if: race.Enabled
        then do:  ((func_call #race.race #"Enable"%go) #())
        else do:  #());;;
        return: (#false)
      else do:  #());;;
      (if: let: "$a0" := (![#int32T] "c") in
      let: "$a1" := ((![#int32T] "c") + #(W32 1)) in
      (method_call #atomic #"Int32'ptr" #"CompareAndSwap" (struct.field_ref #RWMutex #"readerCount"%go (![#ptrT] "rw"))) "$a0" "$a1"
      then
        (if: race.Enabled
        then
          do:  ((func_call #race.race #"Enable"%go) #());;;
          do:  (let: "$a0" := (struct.field_ref #RWMutex #"readerSem"%go (![#ptrT] "rw")) in
          (func_call #race.race #"Acquire"%go) "$a0")
        else do:  #());;;
        return: (#true)
      else do:  #()))).

(* RUnlock undoes a single [RWMutex.RLock] call;
   it does not affect other simultaneous readers.
   It is a run-time error if rw is not locked for reading
   on entry to RUnlock.

   go: rwmutex.go:114:20 *)
Definition RWMutex__RUnlock : val :=
  rec: "RWMutex__RUnlock" "rw" <> :=
    exception_do (let: "rw" := (mem.alloc "rw") in
    (if: race.Enabled
    then
      do:  (let: "$a0" := (struct.field_ref #RWMutex #"w"%go (![#ptrT] "rw")) in
      (func_call #race.race #"Read"%go) "$a0");;;
      do:  (let: "$a0" := (struct.field_ref #RWMutex #"writerSem"%go (![#ptrT] "rw")) in
      (func_call #race.race #"ReleaseMerge"%go) "$a0");;;
      do:  ((func_call #race.race #"Disable"%go) #())
    else do:  #());;;
    (let: "r" := (mem.alloc (type.zero_val #int32T)) in
    let: "$r0" := (let: "$a0" := #(W32 (- 1)) in
    (method_call #atomic #"Int32'ptr" #"Add" (struct.field_ref #RWMutex #"readerCount"%go (![#ptrT] "rw"))) "$a0") in
    do:  ("r" <-[#int32T] "$r0");;;
    (if: int_lt (![#int32T] "r") #(W32 0)
    then
      do:  (let: "$a0" := (![#int32T] "r") in
      (method_call #sync.sync #"RWMutex'ptr" #"rUnlockSlow" (![#ptrT] "rw")) "$a0")
    else do:  #()));;;
    (if: race.Enabled
    then do:  ((func_call #race.race #"Enable"%go) #())
    else do:  #())).

(* go: rwmutex.go:129:20 *)
Definition RWMutex__rUnlockSlow : val :=
  rec: "RWMutex__rUnlockSlow" "rw" "r" :=
    exception_do (let: "rw" := (mem.alloc "rw") in
    let: "r" := (mem.alloc "r") in
    (if: (((![#int32T] "r") + #(W32 1)) = #(W32 0)) || (((![#int32T] "r") + #(W32 1)) = #(W32 (- rwmutexMaxReaders)))
    then
      do:  ((func_call #race.race #"Enable"%go) #());;;
      do:  (let: "$a0" := #"sync: RUnlock of unlocked RWMutex"%go in
      (func_call #sync.sync #"fatal"%go) "$a0")
    else do:  #());;;
    (if: (let: "$a0" := #(W32 (- 1)) in
    (method_call #atomic #"Int32'ptr" #"Add" (struct.field_ref #RWMutex #"readerWait"%go (![#ptrT] "rw"))) "$a0") = #(W32 0)
    then
      do:  (let: "$a0" := (struct.field_ref #RWMutex #"writerSem"%go (![#ptrT] "rw")) in
      let: "$a1" := #false in
      let: "$a2" := #(W64 1) in
      (func_call #sync.sync #"runtime_Semrelease"%go) "$a0" "$a1" "$a2")
    else do:  #())).

(* Lock locks rw for writing.
   If the lock is already locked for reading or writing,
   Lock blocks until the lock is available.

   go: rwmutex.go:144:20 *)
Definition RWMutex__Lock : val :=
  rec: "RWMutex__Lock" "rw" <> :=
    exception_do (let: "rw" := (mem.alloc "rw") in
    (if: race.Enabled
    then
      do:  (let: "$a0" := (struct.field_ref #RWMutex #"w"%go (![#ptrT] "rw")) in
      (func_call #race.race #"Read"%go) "$a0");;;
      do:  ((func_call #race.race #"Disable"%go) #())
    else do:  #());;;
    do:  ((method_call #sync.sync #"Mutex'ptr" #"Lock" (struct.field_ref #RWMutex #"w"%go (![#ptrT] "rw"))) #());;;
    let: "r" := (mem.alloc (type.zero_val #int32T)) in
    let: "$r0" := ((let: "$a0" := #(W32 (- rwmutexMaxReaders)) in
    (method_call #atomic #"Int32'ptr" #"Add" (struct.field_ref #RWMutex #"readerCount"%go (![#ptrT] "rw"))) "$a0") + #(W32 rwmutexMaxReaders)) in
    do:  ("r" <-[#int32T] "$r0");;;
    (if: ((![#int32T] "r") ≠ #(W32 0)) && ((let: "$a0" := (![#int32T] "r") in
    (method_call #atomic #"Int32'ptr" #"Add" (struct.field_ref #RWMutex #"readerWait"%go (![#ptrT] "rw"))) "$a0") ≠ #(W32 0))
    then
      do:  (let: "$a0" := (struct.field_ref #RWMutex #"writerSem"%go (![#ptrT] "rw")) in
      let: "$a1" := #false in
      let: "$a2" := #(W64 0) in
      (func_call #sync.sync #"runtime_SemacquireRWMutex"%go) "$a0" "$a1" "$a2")
    else do:  #());;;
    (if: race.Enabled
    then
      do:  ((func_call #race.race #"Enable"%go) #());;;
      do:  (let: "$a0" := (struct.field_ref #RWMutex #"readerSem"%go (![#ptrT] "rw")) in
      (func_call #race.race #"Acquire"%go) "$a0");;;
      do:  (let: "$a0" := (struct.field_ref #RWMutex #"writerSem"%go (![#ptrT] "rw")) in
      (func_call #race.race #"Acquire"%go) "$a0")
    else do:  #())).

(* TryLock tries to lock rw for writing and reports whether it succeeded.

   Note that while correct uses of TryLock do exist, they are rare,
   and use of TryLock is often a sign of a deeper problem
   in a particular use of mutexes.

   go: rwmutex.go:169:20 *)
Definition RWMutex__TryLock : val :=
  rec: "RWMutex__TryLock" "rw" <> :=
    exception_do (let: "rw" := (mem.alloc "rw") in
    (if: race.Enabled
    then
      do:  (let: "$a0" := (struct.field_ref #RWMutex #"w"%go (![#ptrT] "rw")) in
      (func_call #race.race #"Read"%go) "$a0");;;
      do:  ((func_call #race.race #"Disable"%go) #())
    else do:  #());;;
    (if: (~ ((method_call #sync.sync #"Mutex'ptr" #"TryLock" (struct.field_ref #RWMutex #"w"%go (![#ptrT] "rw"))) #()))
    then
      (if: race.Enabled
      then do:  ((func_call #race.race #"Enable"%go) #())
      else do:  #());;;
      return: (#false)
    else do:  #());;;
    (if: (~ (let: "$a0" := #(W32 0) in
    let: "$a1" := #(W32 (- rwmutexMaxReaders)) in
    (method_call #atomic #"Int32'ptr" #"CompareAndSwap" (struct.field_ref #RWMutex #"readerCount"%go (![#ptrT] "rw"))) "$a0" "$a1"))
    then
      do:  ((method_call #sync.sync #"Mutex'ptr" #"Unlock" (struct.field_ref #RWMutex #"w"%go (![#ptrT] "rw"))) #());;;
      (if: race.Enabled
      then do:  ((func_call #race.race #"Enable"%go) #())
      else do:  #());;;
      return: (#false)
    else do:  #());;;
    (if: race.Enabled
    then
      do:  ((func_call #race.race #"Enable"%go) #());;;
      do:  (let: "$a0" := (struct.field_ref #RWMutex #"readerSem"%go (![#ptrT] "rw")) in
      (func_call #race.race #"Acquire"%go) "$a0");;;
      do:  (let: "$a0" := (struct.field_ref #RWMutex #"writerSem"%go (![#ptrT] "rw")) in
      (func_call #race.race #"Acquire"%go) "$a0")
    else do:  #());;;
    return: (#true)).

(* Unlock unlocks rw for writing. It is a run-time error if rw is
   not locked for writing on entry to Unlock.

   As with Mutexes, a locked [RWMutex] is not associated with a particular
   goroutine. One goroutine may [RWMutex.RLock] ([RWMutex.Lock]) a RWMutex and then
   arrange for another goroutine to [RWMutex.RUnlock] ([RWMutex.Unlock]) it.

   go: rwmutex.go:201:20 *)
Definition RWMutex__Unlock : val :=
  rec: "RWMutex__Unlock" "rw" <> :=
    exception_do (let: "rw" := (mem.alloc "rw") in
    (if: race.Enabled
    then
      do:  (let: "$a0" := (struct.field_ref #RWMutex #"w"%go (![#ptrT] "rw")) in
      (func_call #race.race #"Read"%go) "$a0");;;
      do:  (let: "$a0" := (struct.field_ref #RWMutex #"readerSem"%go (![#ptrT] "rw")) in
      (func_call #race.race #"Release"%go) "$a0");;;
      do:  ((func_call #race.race #"Disable"%go) #())
    else do:  #());;;
    let: "r" := (mem.alloc (type.zero_val #int32T)) in
    let: "$r0" := (let: "$a0" := #(W32 rwmutexMaxReaders) in
    (method_call #atomic #"Int32'ptr" #"Add" (struct.field_ref #RWMutex #"readerCount"%go (![#ptrT] "rw"))) "$a0") in
    do:  ("r" <-[#int32T] "$r0");;;
    (if: int_geq (![#int32T] "r") #(W32 rwmutexMaxReaders)
    then
      do:  ((func_call #race.race #"Enable"%go) #());;;
      do:  (let: "$a0" := #"sync: Unlock of unlocked RWMutex"%go in
      (func_call #sync.sync #"fatal"%go) "$a0")
    else do:  #());;;
    (let: "i" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[#intT] "$r0");;;
    (for: (λ: <>, int_lt (![#intT] "i") (s_to_w64 (![#int32T] "r"))); (λ: <>, do:  ("i" <-[#intT] ((![#intT] "i") + #(W64 1)))) := λ: <>,
      do:  (let: "$a0" := (struct.field_ref #RWMutex #"readerSem"%go (![#ptrT] "rw")) in
      let: "$a1" := #false in
      let: "$a2" := #(W64 0) in
      (func_call #sync.sync #"runtime_Semrelease"%go) "$a0" "$a1" "$a2")));;;
    do:  ((method_call #sync.sync #"Mutex'ptr" #"Unlock" (struct.field_ref #RWMutex #"w"%go (![#ptrT] "rw"))) #());;;
    (if: race.Enabled
    then do:  ((func_call #race.race #"Enable"%go) #())
    else do:  #())).

(* RLocker returns a [Locker] interface that implements
   the [Locker.Lock] and [Locker.Unlock] methods by calling rw.RLock and rw.RUnlock.

   go: rwmutex.go:240:20 *)
Definition RWMutex__RLocker : val :=
  rec: "RWMutex__RLocker" "rw" <> :=
    exception_do (let: "rw" := (mem.alloc "rw") in
    return: (interface.make #sync.sync #"rlocker'ptr" (![#ptrT] "rw"))).

Definition WaitGroup : go_type := structT [
  "noCopy" :: noCopy;
  "state" :: atomic.Uint64;
  "sema" :: uint32T
].

(* Add adds delta, which may be negative, to the [WaitGroup] counter.
   If the counter becomes zero, all goroutines blocked on [WaitGroup.Wait] are released.
   If the counter goes negative, Add panics.

   Note that calls with a positive delta that occur when the counter is zero
   must happen before a Wait. Calls with a negative delta, or calls with a
   positive delta that start when the counter is greater than zero, may happen
   at any time.
   Typically this means the calls to Add should execute before the statement
   creating the goroutine or other event to be waited for.
   If a WaitGroup is reused to wait for several independent sets of events,
   new Add calls must happen after all previous Wait calls have returned.
   See the WaitGroup example.

   go: waitgroup.go:45:22 *)
Definition WaitGroup__Add : val :=
  rec: "WaitGroup__Add" "wg" "delta" :=
    with_defer: (let: "wg" := (mem.alloc "wg") in
    let: "delta" := (mem.alloc "delta") in
    (if: race.Enabled
    then
      (if: int_lt (![#intT] "delta") #(W64 0)
      then
        do:  (let: "$a0" := (![#ptrT] "wg") in
        (func_call #race.race #"ReleaseMerge"%go) "$a0")
      else do:  #());;;
      do:  ((func_call #race.race #"Disable"%go) #());;;
      do:  (let: "$f" := (func_call #race.race #"Enable"%go) in
      "$defer" <-[#funcT] (let: "$oldf" := (![#funcT] "$defer") in
      (λ: <>,
        "$f" #();;
        "$oldf" #()
        )))
    else do:  #());;;
    let: "state" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (let: "$a0" := ((s_to_w64 (![#intT] "delta")) ≪ #(W64 32)) in
    (method_call #atomic #"Uint64'ptr" #"Add" (struct.field_ref #WaitGroup #"state"%go (![#ptrT] "wg"))) "$a0") in
    do:  ("state" <-[#uint64T] "$r0");;;
    let: "v" := (mem.alloc (type.zero_val #int32T)) in
    let: "$r0" := (u_to_w32 ((![#uint64T] "state") ≫ #(W64 32))) in
    do:  ("v" <-[#int32T] "$r0");;;
    let: "w" := (mem.alloc (type.zero_val #uint32T)) in
    let: "$r0" := (u_to_w32 (![#uint64T] "state")) in
    do:  ("w" <-[#uint32T] "$r0");;;
    (if: (race.Enabled && (int_gt (![#intT] "delta") #(W64 0))) && ((![#int32T] "v") = (s_to_w32 (![#intT] "delta")))
    then
      do:  (let: "$a0" := (struct.field_ref #WaitGroup #"sema"%go (![#ptrT] "wg")) in
      (func_call #race.race #"Read"%go) "$a0")
    else do:  #());;;
    (if: int_lt (![#int32T] "v") #(W32 0)
    then
      do:  (let: "$a0" := (interface.make #""%go #"string"%go #"sync: negative WaitGroup counter"%go) in
      Panic "$a0")
    else do:  #());;;
    (if: (((![#uint32T] "w") ≠ #(W32 0)) && (int_gt (![#intT] "delta") #(W64 0))) && ((![#int32T] "v") = (s_to_w32 (![#intT] "delta")))
    then
      do:  (let: "$a0" := (interface.make #""%go #"string"%go #"sync: WaitGroup misuse: Add called concurrently with Wait"%go) in
      Panic "$a0")
    else do:  #());;;
    (if: (int_gt (![#int32T] "v") #(W32 0)) || ((![#uint32T] "w") = #(W32 0))
    then return: (#())
    else do:  #());;;
    (if: ((method_call #atomic #"Uint64'ptr" #"Load" (struct.field_ref #WaitGroup #"state"%go (![#ptrT] "wg"))) #()) ≠ (![#uint64T] "state")
    then
      do:  (let: "$a0" := (interface.make #""%go #"string"%go #"sync: WaitGroup misuse: Add called concurrently with Wait"%go) in
      Panic "$a0")
    else do:  #());;;
    do:  (let: "$a0" := #(W64 0) in
    (method_call #atomic #"Uint64'ptr" #"Store" (struct.field_ref #WaitGroup #"state"%go (![#ptrT] "wg"))) "$a0");;;
    (for: (λ: <>, (![#uint32T] "w") ≠ #(W32 0)); (λ: <>, do:  ("w" <-[#uint32T] ((![#uint32T] "w") - #(W32 1)))) := λ: <>,
      do:  (let: "$a0" := (struct.field_ref #WaitGroup #"sema"%go (![#ptrT] "wg")) in
      let: "$a1" := #false in
      let: "$a2" := #(W64 0) in
      (func_call #sync.sync #"runtime_Semrelease"%go) "$a0" "$a1" "$a2"))).

(* Done decrements the [WaitGroup] counter by one.

   go: waitgroup.go:88:22 *)
Definition WaitGroup__Done : val :=
  rec: "WaitGroup__Done" "wg" <> :=
    exception_do (let: "wg" := (mem.alloc "wg") in
    do:  (let: "$a0" := #(W64 (- 1)) in
    (method_call #sync.sync #"WaitGroup'ptr" #"Add" (![#ptrT] "wg")) "$a0")).

(* Wait blocks until the [WaitGroup] counter is zero.

   go: waitgroup.go:93:22 *)
Definition WaitGroup__Wait : val :=
  rec: "WaitGroup__Wait" "wg" <> :=
    exception_do (let: "wg" := (mem.alloc "wg") in
    (if: race.Enabled
    then do:  ((func_call #race.race #"Disable"%go) #())
    else do:  #());;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "state" := (mem.alloc (type.zero_val #uint64T)) in
      let: "$r0" := ((method_call #atomic #"Uint64'ptr" #"Load" (struct.field_ref #WaitGroup #"state"%go (![#ptrT] "wg"))) #()) in
      do:  ("state" <-[#uint64T] "$r0");;;
      let: "v" := (mem.alloc (type.zero_val #int32T)) in
      let: "$r0" := (u_to_w32 ((![#uint64T] "state") ≫ #(W64 32))) in
      do:  ("v" <-[#int32T] "$r0");;;
      let: "w" := (mem.alloc (type.zero_val #uint32T)) in
      let: "$r0" := (u_to_w32 (![#uint64T] "state")) in
      do:  ("w" <-[#uint32T] "$r0");;;
      (if: (![#int32T] "v") = #(W32 0)
      then
        (if: race.Enabled
        then
          do:  ((func_call #race.race #"Enable"%go) #());;;
          do:  (let: "$a0" := (![#ptrT] "wg") in
          (func_call #race.race #"Acquire"%go) "$a0")
        else do:  #());;;
        return: (#())
      else do:  #());;;
      (if: let: "$a0" := (![#uint64T] "state") in
      let: "$a1" := ((![#uint64T] "state") + #(W64 1)) in
      (method_call #atomic #"Uint64'ptr" #"CompareAndSwap" (struct.field_ref #WaitGroup #"state"%go (![#ptrT] "wg"))) "$a0" "$a1"
      then
        (if: race.Enabled && ((![#uint32T] "w") = #(W32 0))
        then
          do:  (let: "$a0" := (struct.field_ref #WaitGroup #"sema"%go (![#ptrT] "wg")) in
          (func_call #race.race #"Write"%go) "$a0")
        else do:  #());;;
        do:  (let: "$a0" := (struct.field_ref #WaitGroup #"sema"%go (![#ptrT] "wg")) in
        (func_call #sync.sync #"runtime_SemacquireWaitGroup"%go) "$a0");;;
        (if: ((method_call #atomic #"Uint64'ptr" #"Load" (struct.field_ref #WaitGroup #"state"%go (![#ptrT] "wg"))) #()) ≠ #(W64 0)
        then
          do:  (let: "$a0" := (interface.make #""%go #"string"%go #"sync: WaitGroup is reused before previous Wait has returned"%go) in
          Panic "$a0")
        else do:  #());;;
        (if: race.Enabled
        then
          do:  ((func_call #race.race #"Enable"%go) #());;;
          do:  (let: "$a0" := (![#ptrT] "wg") in
          (func_call #race.race #"Acquire"%go) "$a0")
        else do:  #());;;
        return: (#())
      else do:  #()))).

Definition vars' : list (go_string * go_type) := [].

Definition functions' : list (go_string * val) := [("NewCond"%go, NewCond); ("runtime_Semacquire"%go, runtime_Semacquire); ("runtime_SemacquireWaitGroup"%go, runtime_SemacquireWaitGroup); ("runtime_SemacquireRWMutexR"%go, runtime_SemacquireRWMutexR); ("runtime_SemacquireRWMutex"%go, runtime_SemacquireRWMutex); ("runtime_Semrelease"%go, runtime_Semrelease)].

Definition msets' : list (go_string * (list (go_string * val))) := [("Cond"%go, []); ("Cond'ptr"%go, [("Broadcast"%go, Cond__Broadcast); ("Signal"%go, Cond__Signal); ("Wait"%go, Cond__Wait)]); ("noCopy"%go, []); ("noCopy'ptr"%go, []); ("Mutex"%go, []); ("Mutex'ptr"%go, [("Lock"%go, Mutex__Lock); ("TryLock"%go, Mutex__TryLock); ("Unlock"%go, Mutex__Unlock)]); ("RWMutex"%go, []); ("RWMutex'ptr"%go, [("Lock"%go, RWMutex__Lock); ("RLock"%go, RWMutex__RLock); ("RLocker"%go, RWMutex__RLocker); ("RUnlock"%go, RWMutex__RUnlock); ("TryLock"%go, RWMutex__TryLock); ("TryRLock"%go, RWMutex__TryRLock); ("Unlock"%go, RWMutex__Unlock); ("rUnlockSlow"%go, RWMutex__rUnlockSlow)]); ("WaitGroup"%go, []); ("WaitGroup'ptr"%go, [("Add"%go, WaitGroup__Add); ("Done"%go, WaitGroup__Done); ("Wait"%go, WaitGroup__Wait)])].

#[global] Instance info' : PkgInfo sync.sync :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [atomic.atomic; race.race];
  |}.

Axiom _'init : val.

Definition initialize' : val :=
  rec: "initialize'" <> :=
    globals.package_init sync.sync (λ: <>,
      exception_do (do:  race.initialize';;;
      do:  atomic.initialize')
      ).

End code.
End sync.
