(* autogenerated from sync *)
Require Export New.code.sync.atomic.
Require Export New.code.internal.race.
Require Export New.code.internal.synctest.
From New.golang Require Import defn.
Require Export New.trusted_code.sync.
Import sync.
Module pkg_id.
Definition sync : go_string := "sync".

End pkg_id.
Export pkg_id.
Module sync.

Definition Cond {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "sync.Cond"%go [].

#[global] Opaque Cond.

Definition copyChecker {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "sync.copyChecker"%go [].

#[global] Opaque copyChecker.

Definition noCopy {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "sync.noCopy"%go [].

#[global] Opaque noCopy.

Definition Map {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "sync.Map"%go [].

#[global] Opaque Map.

Definition Mutex {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "sync.Mutex"%go [].

#[global] Opaque Mutex.

Definition Locker {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "sync.Locker"%go [].

#[global] Opaque Locker.

Definition Once {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "sync.Once"%go [].

#[global] Opaque Once.

Definition Pool {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "sync.Pool"%go [].

#[global] Opaque Pool.

Definition poolLocalInternal {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "sync.poolLocalInternal"%go [].

#[global] Opaque poolLocalInternal.

Definition poolLocal {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "sync.poolLocal"%go [].

#[global] Opaque poolLocal.

Definition poolDequeue {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "sync.poolDequeue"%go [].

#[global] Opaque poolDequeue.

Definition eface {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "sync.eface"%go [].

#[global] Opaque eface.

Definition dequeueNil {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "sync.dequeueNil"%go [].

#[global] Opaque dequeueNil.

Definition poolChain {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "sync.poolChain"%go [].

#[global] Opaque poolChain.

Definition poolChainElt {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "sync.poolChainElt"%go [].

#[global] Opaque poolChainElt.

Definition notifyList {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "sync.notifyList"%go [].

#[global] Opaque notifyList.

Definition RWMutex {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "sync.RWMutex"%go [].

#[global] Opaque RWMutex.

Definition rlocker {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "sync.rlocker"%go [].

#[global] Opaque rlocker.

Definition WaitGroup {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "sync.WaitGroup"%go [].

#[global] Opaque WaitGroup.

Axiom copyCheckerⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom Mapⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom Poolⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom poolLocalInternalⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom poolLocalⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom poolDequeueⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom efaceⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom dequeueNilⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom poolChainⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom poolChainEltⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom notifyListⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom dequeueBits : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom dequeueLimit : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition rwmutexMaxReaders {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #1073741824.

Definition waitGroupBubbleFlag {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #2147483648.

Definition poolRaceHash {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync.poolRaceHash"%go.

Definition allPoolsMu {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync.allPoolsMu"%go.

Definition allPools {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync.allPools"%go.

Definition oldPools {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync.oldPools"%go.

Definition NewCond {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync.NewCond"%go.

Definition OnceFunc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync.OnceFunc"%go.

Definition OnceValue {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync.OnceValue"%go.

Definition OnceValues {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync.OnceValues"%go.

Definition runtime_randn {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync.runtime_randn"%go.

Definition poolRaceAddr {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync.poolRaceAddr"%go.

Definition poolCleanup {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync.poolCleanup"%go.

Definition indexLocal {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync.indexLocal"%go.

Definition runtime_registerPoolCleanup {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync.runtime_registerPoolCleanup"%go.

Definition runtime_procPin {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync.runtime_procPin"%go.

Definition runtime_procUnpin {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync.runtime_procUnpin"%go.

Definition runtime_LoadAcquintptr {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync.runtime_LoadAcquintptr"%go.

Definition runtime_StoreReluintptr {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync.runtime_StoreReluintptr"%go.

Definition runtime_Semacquire {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync.runtime_Semacquire"%go.

Definition runtime_SemacquireWaitGroup {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync.runtime_SemacquireWaitGroup"%go.

Definition runtime_SemacquireRWMutexR {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync.runtime_SemacquireRWMutexR"%go.

Definition runtime_SemacquireRWMutex {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync.runtime_SemacquireRWMutex"%go.

Definition runtime_Semrelease {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync.runtime_Semrelease"%go.

Definition runtime_notifyListAdd {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync.runtime_notifyListAdd"%go.

Definition runtime_notifyListWait {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync.runtime_notifyListWait"%go.

Definition runtime_notifyListNotifyAll {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync.runtime_notifyListNotifyAll"%go.

Definition runtime_notifyListNotifyOne {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync.runtime_notifyListNotifyOne"%go.

Definition runtime_notifyListCheck {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync.runtime_notifyListCheck"%go.

Definition throw {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync.throw"%go.

Definition fatal {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync.fatal"%go.

Definition syscall_hasWaitingReaders {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sync.syscall_hasWaitingReaders"%go.

(* NewCond returns a new Cond with Locker l.

   go: cond.go:48:6 *)
Definition NewCondⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l",
    exception_do (let: "l" := (GoAlloc Locker "l") in
    return: (GoAlloc Cond (let: "$v0" := (![Locker] "l") in
     CompositeLiteral Cond (LiteralValue [KeyedElement (Some (KeyField "L"%go)) (ElementExpression Locker "$v0")])))).

(* Wait atomically unlocks c.L and suspends execution
   of the calling goroutine. After later resuming execution,
   Wait locks c.L before returning. Unlike in other systems,
   Wait cannot return unless awoken by [Cond.Broadcast] or [Cond.Signal].

   Because c.L is not locked while Wait is waiting, the caller
   typically cannot assume that the condition is true when
   Wait returns. Instead, the caller should Wait in a loop:

   	c.L.Lock()
   	for !condition() {
   	    c.Wait()
   	}
   	... make use of condition ...
   	c.L.Unlock()

   go: cond.go:67:16 *)
Definition Cond__Waitⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "c" <>,
    exception_do (let: "c" := (GoAlloc (go.PointerType Cond) "c") in
    do:  ((MethodResolve (go.PointerType copyChecker) "check"%go (StructFieldRef Cond "checker"%go (![go.PointerType Cond] "c"))) #());;;
    let: "t" := (GoAlloc go.uint32 (GoZeroVal go.uint32 #())) in
    let: "$r0" := (let: "$a0" := (StructFieldRef Cond "notify"%go (![go.PointerType Cond] "c")) in
    (FuncResolve runtime_notifyListAdd [] #()) "$a0") in
    do:  ("t" <-[go.uint32] "$r0");;;
    do:  ((MethodResolve Locker "Unlock"%go (![Locker] (StructFieldRef Cond "L"%go (![go.PointerType Cond] "c")))) #());;;
    do:  (let: "$a0" := (StructFieldRef Cond "notify"%go (![go.PointerType Cond] "c")) in
    let: "$a1" := (![go.uint32] "t") in
    (FuncResolve runtime_notifyListWait [] #()) "$a0" "$a1");;;
    do:  ((MethodResolve Locker "Lock"%go (![Locker] (StructFieldRef Cond "L"%go (![go.PointerType Cond] "c")))) #());;;
    return: #()).

(* Signal wakes one goroutine waiting on c, if there is any.

   It is allowed but not required for the caller to hold c.L
   during the call.

   Signal() does not affect goroutine scheduling priority; if other goroutines
   are attempting to lock c.L, they may be awoken before a "waiting" goroutine.

   go: cond.go:82:16 *)
Definition Cond__Signalⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "c" <>,
    exception_do (let: "c" := (GoAlloc (go.PointerType Cond) "c") in
    do:  ((MethodResolve (go.PointerType copyChecker) "check"%go (StructFieldRef Cond "checker"%go (![go.PointerType Cond] "c"))) #());;;
    do:  (let: "$a0" := (StructFieldRef Cond "notify"%go (![go.PointerType Cond] "c")) in
    (FuncResolve runtime_notifyListNotifyOne [] #()) "$a0");;;
    return: #()).

(* Broadcast wakes all goroutines waiting on c.

   It is allowed but not required for the caller to hold c.L
   during the call.

   go: cond.go:91:16 *)
Definition Cond__Broadcastⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "c" <>,
    exception_do (let: "c" := (GoAlloc (go.PointerType Cond) "c") in
    do:  ((MethodResolve (go.PointerType copyChecker) "check"%go (StructFieldRef Cond "checker"%go (![go.PointerType Cond] "c"))) #());;;
    do:  (let: "$a0" := (StructFieldRef Cond "notify"%go (![go.PointerType Cond] "c")) in
    (FuncResolve runtime_notifyListNotifyAll [] #()) "$a0");;;
    return: #()).

(* Do calls the function f if and only if Do is being called for the
   first time for this instance of [Once]. In other words, given

   	var once Once

   if once.Do(f) is called multiple times, only the first call will invoke f,
   even if f has a different value in each invocation. A new instance of
   Once is required for each function to execute.

   Do is intended for initialization that must be run exactly once. Since f
   is niladic, it may be necessary to use a function literal to capture the
   arguments to a function to be invoked by Do:

   	config.once.Do(func() { config.init(filename) })

   Because no call to Do returns until the one call to f returns, if f causes
   Do to be called, it will deadlock.

   If f panics, Do considers it to have returned; future calls of Do return
   without calling f.

   go: once.go:52:16 *)
Definition Once__Doⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "o" "f",
    exception_do (let: "o" := (GoAlloc (go.PointerType Once) "o") in
    let: "f" := (GoAlloc (go.FunctionType (go.Signature [] false [])) "f") in
    (if: (⟨go.bool⟩! ((MethodResolve (go.PointerType atomic.Bool) "Load"%go (StructFieldRef Once "done"%go (![go.PointerType Once] "o"))) #()))
    then
      do:  (let: "$a0" := (![go.FunctionType (go.Signature [] false [])] "f") in
      (MethodResolve (go.PointerType Once) "doSlow"%go (![go.PointerType Once] "o")) "$a0")
    else do:  #());;;
    return: #()).

(* go: once.go:73:16 *)
Definition Once__doSlowⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "o" "f",
    with_defer: (let: "o" := (GoAlloc (go.PointerType Once) "o") in
    let: "f" := (GoAlloc (go.FunctionType (go.Signature [] false [])) "f") in
    do:  ((MethodResolve (go.PointerType Mutex) "Lock"%go (StructFieldRef Once "m"%go (![go.PointerType Once] "o"))) #());;;
    do:  (let: "$f" := (MethodResolve (go.PointerType Mutex) "Unlock"%go (StructFieldRef Once "m"%go (![go.PointerType Once] "o"))) in
    "$defer" <-[deferType] (let: "$oldf" := (![deferType] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    (if: (⟨go.bool⟩! ((MethodResolve (go.PointerType atomic.Bool) "Load"%go (StructFieldRef Once "done"%go (![go.PointerType Once] "o"))) #()))
    then
      do:  (let: "$a0" := #true in
      let: "$f" := (MethodResolve (go.PointerType atomic.Bool) "Store"%go (StructFieldRef Once "done"%go (![go.PointerType Once] "o"))) in
      "$defer" <-[deferType] (let: "$oldf" := (![deferType] "$defer") in
      (λ: <>,
        "$f" "$a0";;
        "$oldf" #()
        )));;;
      do:  ((![go.FunctionType (go.Signature [] false [])] "f") #())
    else do:  #());;;
    return: #()).

(* RLock locks rw for reading.

   It should not be used for recursive read locking; a blocked Lock
   call excludes new readers from acquiring the lock. See the
   documentation on the [RWMutex] type.

   go: rwmutex.go:67:20 *)
Definition RWMutex__RLockⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "rw" <>,
    exception_do (let: "rw" := (GoAlloc (go.PointerType RWMutex) "rw") in
    (if: Convert go.untyped_bool go.bool race.Enabled
    then
      do:  (let: "$a0" := (Convert (go.PointerType Mutex) unsafe.Pointer (StructFieldRef RWMutex "w"%go (![go.PointerType RWMutex] "rw"))) in
      (FuncResolve race.Read [] #()) "$a0");;;
      do:  ((FuncResolve race.Disable [] #()) #())
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool ((let: "$a0" := #(W32 1) in
    (MethodResolve (go.PointerType atomic.Int32) "Add"%go (StructFieldRef RWMutex "readerCount"%go (![go.PointerType RWMutex] "rw"))) "$a0") <⟨go.int32⟩ #(W32 0))
    then
      do:  (let: "$a0" := (StructFieldRef RWMutex "readerSem"%go (![go.PointerType RWMutex] "rw")) in
      let: "$a1" := #false in
      let: "$a2" := #(W64 0) in
      (FuncResolve runtime_SemacquireRWMutexR [] #()) "$a0" "$a1" "$a2")
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool race.Enabled
    then
      do:  ((FuncResolve race.Enable [] #()) #());;;
      do:  (let: "$a0" := (Convert (go.PointerType go.uint32) unsafe.Pointer (StructFieldRef RWMutex "readerSem"%go (![go.PointerType RWMutex] "rw"))) in
      (FuncResolve race.Acquire [] #()) "$a0")
    else do:  #());;;
    return: #()).

(* TryRLock tries to lock rw for reading and reports whether it succeeded.

   Note that while correct uses of TryRLock do exist, they are rare,
   and use of TryRLock is often a sign of a deeper problem
   in a particular use of mutexes.

   go: rwmutex.go:87:20 *)
Definition RWMutex__TryRLockⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "rw" <>,
    exception_do (let: "rw" := (GoAlloc (go.PointerType RWMutex) "rw") in
    (if: Convert go.untyped_bool go.bool race.Enabled
    then
      do:  (let: "$a0" := (Convert (go.PointerType Mutex) unsafe.Pointer (StructFieldRef RWMutex "w"%go (![go.PointerType RWMutex] "rw"))) in
      (FuncResolve race.Read [] #()) "$a0");;;
      do:  ((FuncResolve race.Disable [] #()) #())
    else do:  #());;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "c" := (GoAlloc go.int32 (GoZeroVal go.int32 #())) in
      let: "$r0" := ((MethodResolve (go.PointerType atomic.Int32) "Load"%go (StructFieldRef RWMutex "readerCount"%go (![go.PointerType RWMutex] "rw"))) #()) in
      do:  ("c" <-[go.int32] "$r0");;;
      (if: Convert go.untyped_bool go.bool ((![go.int32] "c") <⟨go.int32⟩ #(W32 0))
      then
        (if: Convert go.untyped_bool go.bool race.Enabled
        then do:  ((FuncResolve race.Enable [] #()) #())
        else do:  #());;;
        return: (#false)
      else do:  #());;;
      (if: let: "$a0" := (![go.int32] "c") in
      let: "$a1" := ((![go.int32] "c") +⟨go.int32⟩ #(W32 1)) in
      (MethodResolve (go.PointerType atomic.Int32) "CompareAndSwap"%go (StructFieldRef RWMutex "readerCount"%go (![go.PointerType RWMutex] "rw"))) "$a0" "$a1"
      then
        (if: Convert go.untyped_bool go.bool race.Enabled
        then
          do:  ((FuncResolve race.Enable [] #()) #());;;
          do:  (let: "$a0" := (Convert (go.PointerType go.uint32) unsafe.Pointer (StructFieldRef RWMutex "readerSem"%go (![go.PointerType RWMutex] "rw"))) in
          (FuncResolve race.Acquire [] #()) "$a0")
        else do:  #());;;
        return: (#true)
      else do:  #()))).

(* RUnlock undoes a single [RWMutex.RLock] call;
   it does not affect other simultaneous readers.
   It is a run-time error if rw is not locked for reading
   on entry to RUnlock.

   go: rwmutex.go:114:20 *)
Definition RWMutex__RUnlockⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "rw" <>,
    exception_do (let: "rw" := (GoAlloc (go.PointerType RWMutex) "rw") in
    (if: Convert go.untyped_bool go.bool race.Enabled
    then
      do:  (let: "$a0" := (Convert (go.PointerType Mutex) unsafe.Pointer (StructFieldRef RWMutex "w"%go (![go.PointerType RWMutex] "rw"))) in
      (FuncResolve race.Read [] #()) "$a0");;;
      do:  (let: "$a0" := (Convert (go.PointerType go.uint32) unsafe.Pointer (StructFieldRef RWMutex "writerSem"%go (![go.PointerType RWMutex] "rw"))) in
      (FuncResolve race.ReleaseMerge [] #()) "$a0");;;
      do:  ((FuncResolve race.Disable [] #()) #())
    else do:  #());;;
    (let: "r" := (GoAlloc go.int32 (GoZeroVal go.int32 #())) in
    let: "$r0" := (let: "$a0" := (Convert go.untyped_int go.int32 (⟨go.untyped_int⟩- #1)) in
    (MethodResolve (go.PointerType atomic.Int32) "Add"%go (StructFieldRef RWMutex "readerCount"%go (![go.PointerType RWMutex] "rw"))) "$a0") in
    do:  ("r" <-[go.int32] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.int32] "r") <⟨go.int32⟩ #(W32 0))
    then
      do:  (let: "$a0" := (![go.int32] "r") in
      (MethodResolve (go.PointerType RWMutex) "rUnlockSlow"%go (![go.PointerType RWMutex] "rw")) "$a0")
    else do:  #()));;;
    (if: Convert go.untyped_bool go.bool race.Enabled
    then do:  ((FuncResolve race.Enable [] #()) #())
    else do:  #());;;
    return: #()).

(* go: rwmutex.go:129:20 *)
Definition RWMutex__rUnlockSlowⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "rw" "r",
    exception_do (let: "rw" := (GoAlloc (go.PointerType RWMutex) "rw") in
    let: "r" := (GoAlloc go.int32 "r") in
    (if: Convert go.untyped_bool go.bool ((((![go.int32] "r") +⟨go.int32⟩ #(W32 1)) =⟨go.int32⟩ #(W32 0)) || (((![go.int32] "r") +⟨go.int32⟩ #(W32 1)) =⟨go.int32⟩ (Convert go.untyped_int go.int32 (⟨go.untyped_int⟩- rwmutexMaxReaders))))
    then
      do:  ((FuncResolve race.Enable [] #()) #());;;
      do:  (let: "$a0" := #"sync: RUnlock of unlocked RWMutex"%go in
      (FuncResolve fatal [] #()) "$a0")
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool ((let: "$a0" := (Convert go.untyped_int go.int32 (⟨go.untyped_int⟩- #1)) in
    (MethodResolve (go.PointerType atomic.Int32) "Add"%go (StructFieldRef RWMutex "readerWait"%go (![go.PointerType RWMutex] "rw"))) "$a0") =⟨go.int32⟩ #(W32 0))
    then
      do:  (let: "$a0" := (StructFieldRef RWMutex "writerSem"%go (![go.PointerType RWMutex] "rw")) in
      let: "$a1" := #false in
      let: "$a2" := #(W64 1) in
      (FuncResolve runtime_Semrelease [] #()) "$a0" "$a1" "$a2")
    else do:  #());;;
    return: #()).

(* Lock locks rw for writing.
   If the lock is already locked for reading or writing,
   Lock blocks until the lock is available.

   go: rwmutex.go:144:20 *)
Definition RWMutex__Lockⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "rw" <>,
    exception_do (let: "rw" := (GoAlloc (go.PointerType RWMutex) "rw") in
    (if: Convert go.untyped_bool go.bool race.Enabled
    then
      do:  (let: "$a0" := (Convert (go.PointerType Mutex) unsafe.Pointer (StructFieldRef RWMutex "w"%go (![go.PointerType RWMutex] "rw"))) in
      (FuncResolve race.Read [] #()) "$a0");;;
      do:  ((FuncResolve race.Disable [] #()) #())
    else do:  #());;;
    do:  ((MethodResolve (go.PointerType Mutex) "Lock"%go (StructFieldRef RWMutex "w"%go (![go.PointerType RWMutex] "rw"))) #());;;
    let: "r" := (GoAlloc go.int32 (GoZeroVal go.int32 #())) in
    let: "$r0" := ((let: "$a0" := (Convert go.untyped_int go.int32 (⟨go.untyped_int⟩- rwmutexMaxReaders)) in
    (MethodResolve (go.PointerType atomic.Int32) "Add"%go (StructFieldRef RWMutex "readerCount"%go (![go.PointerType RWMutex] "rw"))) "$a0") +⟨go.int32⟩ (Convert go.untyped_int go.int32 rwmutexMaxReaders)) in
    do:  ("r" <-[go.int32] "$r0");;;
    (if: Convert go.untyped_bool go.bool (((![go.int32] "r") ≠⟨go.int32⟩ #(W32 0)) && ((let: "$a0" := (![go.int32] "r") in
    (MethodResolve (go.PointerType atomic.Int32) "Add"%go (StructFieldRef RWMutex "readerWait"%go (![go.PointerType RWMutex] "rw"))) "$a0") ≠⟨go.int32⟩ #(W32 0)))
    then
      do:  (let: "$a0" := (StructFieldRef RWMutex "writerSem"%go (![go.PointerType RWMutex] "rw")) in
      let: "$a1" := #false in
      let: "$a2" := #(W64 0) in
      (FuncResolve runtime_SemacquireRWMutex [] #()) "$a0" "$a1" "$a2")
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool race.Enabled
    then
      do:  ((FuncResolve race.Enable [] #()) #());;;
      do:  (let: "$a0" := (Convert (go.PointerType go.uint32) unsafe.Pointer (StructFieldRef RWMutex "readerSem"%go (![go.PointerType RWMutex] "rw"))) in
      (FuncResolve race.Acquire [] #()) "$a0");;;
      do:  (let: "$a0" := (Convert (go.PointerType go.uint32) unsafe.Pointer (StructFieldRef RWMutex "writerSem"%go (![go.PointerType RWMutex] "rw"))) in
      (FuncResolve race.Acquire [] #()) "$a0")
    else do:  #());;;
    return: #()).

(* TryLock tries to lock rw for writing and reports whether it succeeded.

   Note that while correct uses of TryLock do exist, they are rare,
   and use of TryLock is often a sign of a deeper problem
   in a particular use of mutexes.

   go: rwmutex.go:169:20 *)
Definition RWMutex__TryLockⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "rw" <>,
    exception_do (let: "rw" := (GoAlloc (go.PointerType RWMutex) "rw") in
    (if: Convert go.untyped_bool go.bool race.Enabled
    then
      do:  (let: "$a0" := (Convert (go.PointerType Mutex) unsafe.Pointer (StructFieldRef RWMutex "w"%go (![go.PointerType RWMutex] "rw"))) in
      (FuncResolve race.Read [] #()) "$a0");;;
      do:  ((FuncResolve race.Disable [] #()) #())
    else do:  #());;;
    (if: (⟨go.bool⟩! ((MethodResolve (go.PointerType Mutex) "TryLock"%go (StructFieldRef RWMutex "w"%go (![go.PointerType RWMutex] "rw"))) #()))
    then
      (if: Convert go.untyped_bool go.bool race.Enabled
      then do:  ((FuncResolve race.Enable [] #()) #())
      else do:  #());;;
      return: (#false)
    else do:  #());;;
    (if: (⟨go.bool⟩! (let: "$a0" := #(W32 0) in
    let: "$a1" := (Convert go.untyped_int go.int32 (⟨go.untyped_int⟩- rwmutexMaxReaders)) in
    (MethodResolve (go.PointerType atomic.Int32) "CompareAndSwap"%go (StructFieldRef RWMutex "readerCount"%go (![go.PointerType RWMutex] "rw"))) "$a0" "$a1"))
    then
      do:  ((MethodResolve (go.PointerType Mutex) "Unlock"%go (StructFieldRef RWMutex "w"%go (![go.PointerType RWMutex] "rw"))) #());;;
      (if: Convert go.untyped_bool go.bool race.Enabled
      then do:  ((FuncResolve race.Enable [] #()) #())
      else do:  #());;;
      return: (#false)
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool race.Enabled
    then
      do:  ((FuncResolve race.Enable [] #()) #());;;
      do:  (let: "$a0" := (Convert (go.PointerType go.uint32) unsafe.Pointer (StructFieldRef RWMutex "readerSem"%go (![go.PointerType RWMutex] "rw"))) in
      (FuncResolve race.Acquire [] #()) "$a0");;;
      do:  (let: "$a0" := (Convert (go.PointerType go.uint32) unsafe.Pointer (StructFieldRef RWMutex "writerSem"%go (![go.PointerType RWMutex] "rw"))) in
      (FuncResolve race.Acquire [] #()) "$a0")
    else do:  #());;;
    return: (#true)).

(* Unlock unlocks rw for writing. It is a run-time error if rw is
   not locked for writing on entry to Unlock.

   As with Mutexes, a locked [RWMutex] is not associated with a particular
   goroutine. One goroutine may [RWMutex.RLock] ([RWMutex.Lock]) a RWMutex and then
   arrange for another goroutine to [RWMutex.RUnlock] ([RWMutex.Unlock]) it.

   go: rwmutex.go:201:20 *)
Definition RWMutex__Unlockⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "rw" <>,
    exception_do (let: "rw" := (GoAlloc (go.PointerType RWMutex) "rw") in
    (if: Convert go.untyped_bool go.bool race.Enabled
    then
      do:  (let: "$a0" := (Convert (go.PointerType Mutex) unsafe.Pointer (StructFieldRef RWMutex "w"%go (![go.PointerType RWMutex] "rw"))) in
      (FuncResolve race.Read [] #()) "$a0");;;
      do:  (let: "$a0" := (Convert (go.PointerType go.uint32) unsafe.Pointer (StructFieldRef RWMutex "readerSem"%go (![go.PointerType RWMutex] "rw"))) in
      (FuncResolve race.Release [] #()) "$a0");;;
      do:  ((FuncResolve race.Disable [] #()) #())
    else do:  #());;;
    let: "r" := (GoAlloc go.int32 (GoZeroVal go.int32 #())) in
    let: "$r0" := (let: "$a0" := (Convert go.untyped_int go.int32 rwmutexMaxReaders) in
    (MethodResolve (go.PointerType atomic.Int32) "Add"%go (StructFieldRef RWMutex "readerCount"%go (![go.PointerType RWMutex] "rw"))) "$a0") in
    do:  ("r" <-[go.int32] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.int32] "r") ≥⟨go.int32⟩ (Convert go.untyped_int go.int32 rwmutexMaxReaders))
    then
      do:  ((FuncResolve race.Enable [] #()) #());;;
      do:  (let: "$a0" := #"sync: Unlock of unlocked RWMutex"%go in
      (FuncResolve fatal [] #()) "$a0")
    else do:  #());;;
    (let: "i" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.int] "$r0");;;
    (for: (λ: <>, (![go.int] "i") <⟨go.int⟩ (Convert go.int32 go.int (![go.int32] "r"))); (λ: <>, do:  ("i" <-[go.int] ((![go.int] "i") +⟨go.int⟩ #(W64 1)))) := λ: <>,
      do:  (let: "$a0" := (StructFieldRef RWMutex "readerSem"%go (![go.PointerType RWMutex] "rw")) in
      let: "$a1" := #false in
      let: "$a2" := #(W64 0) in
      (FuncResolve runtime_Semrelease [] #()) "$a0" "$a1" "$a2")));;;
    do:  ((MethodResolve (go.PointerType Mutex) "Unlock"%go (StructFieldRef RWMutex "w"%go (![go.PointerType RWMutex] "rw"))) #());;;
    (if: Convert go.untyped_bool go.bool race.Enabled
    then do:  ((FuncResolve race.Enable [] #()) #())
    else do:  #());;;
    return: #()).

(* RLocker returns a [Locker] interface that implements
   the [Locker.Lock] and [Locker.Unlock] methods by calling rw.RLock and rw.RUnlock.

   go: rwmutex.go:240:20 *)
Definition RWMutex__RLockerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "rw" <>,
    exception_do (let: "rw" := (GoAlloc (go.PointerType RWMutex) "rw") in
    return: (Convert (go.PointerType rlocker) Locker (Convert (go.PointerType RWMutex) (go.PointerType rlocker) (![go.PointerType RWMutex] "rw")))).

(* Add adds delta, which may be negative, to the [WaitGroup] task counter.
   If the counter becomes zero, all goroutines blocked on [WaitGroup.Wait] are released.
   If the counter goes negative, Add panics.

   Callers should prefer [WaitGroup.Go].

   Note that calls with a positive delta that occur when the counter is zero
   must happen before a Wait. Calls with a negative delta, or calls with a
   positive delta that start when the counter is greater than zero, may happen
   at any time.
   Typically this means the calls to Add should execute before the statement
   creating the goroutine or other event to be waited for.
   If a WaitGroup is reused to wait for several independent sets of events,
   new Add calls must happen after all previous Wait calls have returned.
   See the WaitGroup example.

   go: waitgroup.go:77:22 *)
Definition WaitGroup__Addⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "wg" "delta",
    with_defer: (let: "wg" := (GoAlloc (go.PointerType WaitGroup) "wg") in
    let: "delta" := (GoAlloc go.int "delta") in
    (if: Convert go.untyped_bool go.bool race.Enabled
    then
      (if: Convert go.untyped_bool go.bool ((![go.int] "delta") <⟨go.int⟩ #(W64 0))
      then
        do:  (let: "$a0" := (Convert (go.PointerType WaitGroup) unsafe.Pointer (![go.PointerType WaitGroup] "wg")) in
        (FuncResolve race.ReleaseMerge [] #()) "$a0")
      else do:  #());;;
      do:  ((FuncResolve race.Disable [] #()) #());;;
      do:  (let: "$f" := (FuncResolve race.Enable [] #()) in
      "$defer" <-[deferType] (let: "$oldf" := (![deferType] "$defer") in
      (λ: <>,
        "$f" #();;
        "$oldf" #()
        )))
    else do:  #());;;
    let: "bubbled" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #false in
    do:  ("bubbled" <-[go.bool] "$r0");;;
    (if: (FuncResolve synctest.IsInBubble [] #()) #()
    then
      let: "$sw" := (let: "$a0" := (![go.PointerType WaitGroup] "wg") in
      (FuncResolve synctest.Associate [WaitGroup] #()) "$a0") in
      (if: "$sw" =⟨synctest.Association⟩ synctest.Unbubbled
      then do:  #()
      else
        (if: "$sw" =⟨synctest.Association⟩ synctest.OtherBubble
        then
          do:  (let: "$a0" := #"sync: WaitGroup.Add called from multiple synctest bubbles"%go in
          (FuncResolve fatal [] #()) "$a0")
        else
          (if: "$sw" =⟨synctest.Association⟩ synctest.CurrentBubble
          then
            let: "$r0" := #true in
            do:  ("bubbled" <-[go.bool] "$r0");;;
            let: "state" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
            let: "$r0" := (let: "$a0" := (Convert go.untyped_int go.uint64 waitGroupBubbleFlag) in
            (MethodResolve (go.PointerType atomic.Uint64) "Or"%go (StructFieldRef WaitGroup "state"%go (![go.PointerType WaitGroup] "wg"))) "$a0") in
            do:  ("state" <-[go.uint64] "$r0");;;
            (if: Convert go.untyped_bool go.bool (((![go.uint64] "state") ≠⟨go.uint64⟩ #(W64 0)) && (((![go.uint64] "state") &⟨go.uint64⟩ (Convert go.untyped_int go.uint64 waitGroupBubbleFlag)) =⟨go.uint64⟩ #(W64 0)))
            then
              do:  (let: "$a0" := #"sync: WaitGroup.Add called from inside and outside synctest bubble"%go in
              (FuncResolve fatal [] #()) "$a0")
            else do:  #())
          else do:  #())))
    else do:  #());;;
    let: "state" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (let: "$a0" := ((Convert go.int go.uint64 (![go.int] "delta")) <<⟨go.uint64⟩ (Convert go.untyped_int go.uint64 #32)) in
    (MethodResolve (go.PointerType atomic.Uint64) "Add"%go (StructFieldRef WaitGroup "state"%go (![go.PointerType WaitGroup] "wg"))) "$a0") in
    do:  ("state" <-[go.uint64] "$r0");;;
    (if: (((![go.uint64] "state") &⟨go.uint64⟩ (Convert go.untyped_int go.uint64 waitGroupBubbleFlag)) ≠⟨go.uint64⟩ #(W64 0)) && (⟨go.bool⟩! (![go.bool] "bubbled"))
    then
      do:  (let: "$a0" := #"sync: WaitGroup.Add called from inside and outside synctest bubble"%go in
      (FuncResolve fatal [] #()) "$a0")
    else do:  #());;;
    let: "v" := (GoAlloc go.int32 (GoZeroVal go.int32 #())) in
    let: "$r0" := (Convert go.uint64 go.int32 ((![go.uint64] "state") >>⟨go.uint64⟩ (Convert go.untyped_int go.uint64 #32))) in
    do:  ("v" <-[go.int32] "$r0");;;
    let: "w" := (GoAlloc go.uint32 (GoZeroVal go.uint32 #())) in
    let: "$r0" := (Convert go.uint64 go.uint32 ((![go.uint64] "state") &⟨go.uint64⟩ #(W64 2147483647))) in
    do:  ("w" <-[go.uint32] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((race.Enabled && ((![go.int] "delta") >⟨go.int⟩ #(W64 0))) && ((![go.int32] "v") =⟨go.int32⟩ (Convert go.int go.int32 (![go.int] "delta"))))
    then
      do:  (let: "$a0" := (Convert (go.PointerType go.uint32) unsafe.Pointer (StructFieldRef WaitGroup "sema"%go (![go.PointerType WaitGroup] "wg"))) in
      (FuncResolve race.Read [] #()) "$a0")
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool ((![go.int32] "v") <⟨go.int32⟩ #(W32 0))
    then
      do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"sync: negative WaitGroup counter"%go) in
      (FuncResolve go.panic [] #()) "$a0")
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool ((((![go.uint32] "w") ≠⟨go.uint32⟩ #(W32 0)) && ((![go.int] "delta") >⟨go.int⟩ #(W64 0))) && ((![go.int32] "v") =⟨go.int32⟩ (Convert go.int go.int32 (![go.int] "delta"))))
    then
      do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"sync: WaitGroup misuse: Add called concurrently with Wait"%go) in
      (FuncResolve go.panic [] #()) "$a0")
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool (((![go.int32] "v") >⟨go.int32⟩ #(W32 0)) || ((![go.uint32] "w") =⟨go.uint32⟩ #(W32 0)))
    then return: (#())
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool (((MethodResolve (go.PointerType atomic.Uint64) "Load"%go (StructFieldRef WaitGroup "state"%go (![go.PointerType WaitGroup] "wg"))) #()) ≠⟨go.uint64⟩ (![go.uint64] "state"))
    then
      do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"sync: WaitGroup misuse: Add called concurrently with Wait"%go) in
      (FuncResolve go.panic [] #()) "$a0")
    else do:  #());;;
    do:  (let: "$a0" := #(W64 0) in
    (MethodResolve (go.PointerType atomic.Uint64) "Store"%go (StructFieldRef WaitGroup "state"%go (![go.PointerType WaitGroup] "wg"))) "$a0");;;
    (if: ![go.bool] "bubbled"
    then
      do:  (let: "$a0" := (![go.PointerType WaitGroup] "wg") in
      (FuncResolve synctest.Disassociate [WaitGroup] #()) "$a0")
    else do:  #());;;
    (for: (λ: <>, (![go.uint32] "w") ≠⟨go.uint32⟩ #(W32 0)); (λ: <>, do:  ("w" <-[go.uint32] ((![go.uint32] "w") -⟨go.uint32⟩ #(W32 1)))) := λ: <>,
      do:  (let: "$a0" := (StructFieldRef WaitGroup "sema"%go (![go.PointerType WaitGroup] "wg")) in
      let: "$a1" := #false in
      let: "$a2" := #(W64 0) in
      (FuncResolve runtime_Semrelease [] #()) "$a0" "$a1" "$a2"));;;
    return: #()).

(* Done decrements the [WaitGroup] task counter by one.
   It is equivalent to Add(-1).

   Callers should prefer [WaitGroup.Go].

   In the terminology of [the Go memory model], a call to Done
   "synchronizes before" the return of any Wait call that it unblocks.

   [the Go memory model]: https://go.dev/ref/mem

   go: waitgroup.go:155:22 *)
Definition WaitGroup__Doneⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "wg" <>,
    exception_do (let: "wg" := (GoAlloc (go.PointerType WaitGroup) "wg") in
    do:  (let: "$a0" := (Convert go.untyped_int go.int (⟨go.untyped_int⟩- #1)) in
    (MethodResolve (go.PointerType WaitGroup) "Add"%go (![go.PointerType WaitGroup] "wg")) "$a0");;;
    return: #()).

(* Wait blocks until the [WaitGroup] task counter is zero.

   go: waitgroup.go:160:22 *)
Definition WaitGroup__Waitⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "wg" <>,
    exception_do (let: "wg" := (GoAlloc (go.PointerType WaitGroup) "wg") in
    (if: Convert go.untyped_bool go.bool race.Enabled
    then do:  ((FuncResolve race.Disable [] #()) #())
    else do:  #());;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "state" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: "$r0" := ((MethodResolve (go.PointerType atomic.Uint64) "Load"%go (StructFieldRef WaitGroup "state"%go (![go.PointerType WaitGroup] "wg"))) #()) in
      do:  ("state" <-[go.uint64] "$r0");;;
      let: "v" := (GoAlloc go.int32 (GoZeroVal go.int32 #())) in
      let: "$r0" := (Convert go.uint64 go.int32 ((![go.uint64] "state") >>⟨go.uint64⟩ (Convert go.untyped_int go.uint64 #32))) in
      do:  ("v" <-[go.int32] "$r0");;;
      let: "w" := (GoAlloc go.uint32 (GoZeroVal go.uint32 #())) in
      let: "$r0" := (Convert go.uint64 go.uint32 ((![go.uint64] "state") &⟨go.uint64⟩ #(W64 2147483647))) in
      do:  ("w" <-[go.uint32] "$r0");;;
      (if: Convert go.untyped_bool go.bool ((![go.int32] "v") =⟨go.int32⟩ #(W32 0))
      then
        (if: Convert go.untyped_bool go.bool race.Enabled
        then
          do:  ((FuncResolve race.Enable [] #()) #());;;
          do:  (let: "$a0" := (Convert (go.PointerType WaitGroup) unsafe.Pointer (![go.PointerType WaitGroup] "wg")) in
          (FuncResolve race.Acquire [] #()) "$a0")
        else do:  #());;;
        (if: (((![go.uint32] "w") =⟨go.uint32⟩ #(W32 0)) && (((![go.uint64] "state") &⟨go.uint64⟩ (Convert go.untyped_int go.uint64 waitGroupBubbleFlag)) ≠⟨go.uint64⟩ #(W64 0))) && (let: "$a0" := (![go.PointerType WaitGroup] "wg") in
        (FuncResolve synctest.IsAssociated [WaitGroup] #()) "$a0")
        then
          (if: let: "$a0" := (![go.uint64] "state") in
          let: "$a1" := #(W64 0) in
          (MethodResolve (go.PointerType atomic.Uint64) "CompareAndSwap"%go (StructFieldRef WaitGroup "state"%go (![go.PointerType WaitGroup] "wg"))) "$a0" "$a1"
          then
            do:  (let: "$a0" := (![go.PointerType WaitGroup] "wg") in
            (FuncResolve synctest.Disassociate [WaitGroup] #()) "$a0")
          else do:  #())
        else do:  #());;;
        return: (#())
      else do:  #());;;
      (if: let: "$a0" := (![go.uint64] "state") in
      let: "$a1" := ((![go.uint64] "state") +⟨go.uint64⟩ #(W64 1)) in
      (MethodResolve (go.PointerType atomic.Uint64) "CompareAndSwap"%go (StructFieldRef WaitGroup "state"%go (![go.PointerType WaitGroup] "wg"))) "$a0" "$a1"
      then
        (if: Convert go.untyped_bool go.bool (race.Enabled && ((![go.uint32] "w") =⟨go.uint32⟩ #(W32 0)))
        then
          do:  (let: "$a0" := (Convert (go.PointerType go.uint32) unsafe.Pointer (StructFieldRef WaitGroup "sema"%go (![go.PointerType WaitGroup] "wg"))) in
          (FuncResolve race.Write [] #()) "$a0")
        else do:  #());;;
        let: "synctestDurable" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
        let: "$r0" := #false in
        do:  ("synctestDurable" <-[go.bool] "$r0");;;
        (if: (((![go.uint64] "state") &⟨go.uint64⟩ (Convert go.untyped_int go.uint64 waitGroupBubbleFlag)) ≠⟨go.uint64⟩ #(W64 0)) && ((FuncResolve synctest.IsInBubble [] #()) #())
        then
          (if: Convert go.untyped_bool go.bool race.Enabled
          then do:  ((FuncResolve race.Enable [] #()) #())
          else do:  #());;;
          (if: let: "$a0" := (![go.PointerType WaitGroup] "wg") in
          (FuncResolve synctest.IsAssociated [WaitGroup] #()) "$a0"
          then
            let: "$r0" := #true in
            do:  ("synctestDurable" <-[go.bool] "$r0")
          else do:  #());;;
          (if: Convert go.untyped_bool go.bool race.Enabled
          then do:  ((FuncResolve race.Disable [] #()) #())
          else do:  #())
        else do:  #());;;
        do:  (let: "$a0" := (StructFieldRef WaitGroup "sema"%go (![go.PointerType WaitGroup] "wg")) in
        let: "$a1" := (![go.bool] "synctestDurable") in
        (FuncResolve runtime_SemacquireWaitGroup [] #()) "$a0" "$a1");;;
        let: "isReset" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
        let: "$r0" := (((MethodResolve (go.PointerType atomic.Uint64) "Load"%go (StructFieldRef WaitGroup "state"%go (![go.PointerType WaitGroup] "wg"))) #()) ≠⟨go.uint64⟩ #(W64 0)) in
        do:  ("isReset" <-[go.bool] "$r0");;;
        (if: Convert go.untyped_bool go.bool race.Enabled
        then
          do:  ((FuncResolve race.Enable [] #()) #());;;
          do:  (let: "$a0" := (Convert (go.PointerType WaitGroup) unsafe.Pointer (![go.PointerType WaitGroup] "wg")) in
          (FuncResolve race.Acquire [] #()) "$a0")
        else do:  #());;;
        (if: ![go.bool] "isReset"
        then
          do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"sync: WaitGroup is reused before previous Wait has returned"%go) in
          (FuncResolve go.panic [] #()) "$a0")
        else do:  #());;;
        return: (#())
      else do:  #()));;;
    return: #()).

(* Go calls f in a new goroutine and adds that task to the [WaitGroup].
   When f returns, the task is removed from the WaitGroup.

   The function f must not panic.

   If the WaitGroup is empty, Go must happen before a [WaitGroup.Wait].
   Typically, this simply means Go is called to start tasks before Wait is called.
   If the WaitGroup is not empty, Go may happen at any time.
   This means a goroutine started by Go may itself call Go.
   If a WaitGroup is reused to wait for several independent sets of tasks,
   new Go calls must happen after all previous Wait calls have returned.

   In the terminology of [the Go memory model], the return from f
   "synchronizes before" the return of any Wait call that it unblocks.

   [the Go memory model]: https://go.dev/ref/mem

   go: waitgroup.go:236:22 *)
Definition WaitGroup__Goⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "wg" "f",
    exception_do (let: "wg" := (GoAlloc (go.PointerType WaitGroup) "wg") in
    let: "f" := (GoAlloc (go.FunctionType (go.Signature [] false [])) "f") in
    do:  (let: "$a0" := #(W64 1) in
    (MethodResolve (go.PointerType WaitGroup) "Add"%go (![go.PointerType WaitGroup] "wg")) "$a0");;;
    let: "$go" := (λ: <>,
      with_defer: (do:  (let: "$f" := (λ: <>,
        exception_do ((let: "x" := (GoAlloc (go.InterfaceType []) (GoZeroVal (go.InterfaceType []) #())) in
        let: "$r0" := ((FuncResolve go.recover [] #()) #()) in
        do:  ("x" <-[go.InterfaceType []] "$r0");;;
        (if: Convert go.untyped_bool go.bool ((![go.InterfaceType []] "x") ≠⟨go.InterfaceType []⟩ (Convert go.untyped_nil (go.InterfaceType []) UntypedNil))
        then
          do:  (let: "$a0" := (![go.InterfaceType []] "x") in
          (FuncResolve go.panic [] #()) "$a0")
        else do:  #()));;;
        do:  ((MethodResolve (go.PointerType WaitGroup) "Done"%go (![go.PointerType WaitGroup] "wg")) #());;;
        return: #())
        ) in
      "$defer" <-[deferType] (let: "$oldf" := (![deferType] "$defer") in
      (λ: <>,
        "$f" #();;
        "$oldf" #()
        )));;;
      do:  ((![go.FunctionType (go.Signature [] false [])] "f") #());;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    return: #()).

#[global] Instance info' : PkgInfo pkg_id.sync :=
{|
  pkg_imported_pkgs := [code.sync.atomic.pkg_id.atomic; code.internal.race.pkg_id.race; code.internal.synctest.pkg_id.synctest]
|}.

Axiom _'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init pkg_id.sync (λ: <>,
      exception_do (do:  (synctest.initialize' #());;;
      do:  (race.initialize' #());;;
      do:  (atomic.initialize' #()))
      ).

Module noCopy.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End noCopy.

Definition noCopy'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [

].
Program Definition noCopy'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (noCopy'fds_unsealed).
Global Instance equals_unfold_noCopy {ext : ffi_syntax} {go_gctx : GoGlobalContext} : noCopy'fds =→ noCopy'fds_unsealed.
Proof. rewrite /noCopy'fds seal_eq //. Qed.

Definition noCopyⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (noCopy'fds).

Class noCopy_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] noCopy_type_repr  :: go.TypeReprUnderlying noCopyⁱᵐᵖˡ noCopy.t;
  #[global] noCopy_underlying :: (noCopy) <u (noCopyⁱᵐᵖˡ);
}.

Module Locker.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := interface.t.
End def.
End Locker.

Definition Lockerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.InterfaceType [go.MethodElem "Lock"%go (go.Signature [] false []); go.MethodElem "Unlock"%go (go.Signature [] false [])].

Class Locker_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Locker_underlying :: (Locker) <u (Lockerⁱᵐᵖˡ);
}.

Module notifyList.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End notifyList.

Class notifyList_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] notifyList_type_repr  :: go.TypeReprUnderlying notifyListⁱᵐᵖˡ notifyList.t;
  #[global] notifyList_underlying :: (notifyList) <u (notifyListⁱᵐᵖˡ);
  #[global] notifyListⁱᵐᵖˡ_underlying :: (notifyListⁱᵐᵖˡ) ↓u (notifyListⁱᵐᵖˡ);
}.

Module copyChecker.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End copyChecker.

Class copyChecker_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] copyChecker_type_repr  :: go.TypeReprUnderlying copyCheckerⁱᵐᵖˡ copyChecker.t;
  #[global] copyChecker_underlying :: (copyChecker) <u (copyCheckerⁱᵐᵖˡ);
  #[global] copyCheckerⁱᵐᵖˡ_underlying :: (copyCheckerⁱᵐᵖˡ) ↓u (copyCheckerⁱᵐᵖˡ);
}.

Module Cond.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  noCopy' : sync.noCopy.t;
  L' : sync.Locker.t;
  notify' : sync.notifyList.t;
  checker' : sync.copyChecker.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End Cond.

Definition Cond'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "noCopy"%go noCopy);
  (go.FieldDecl "L"%go Locker);
  (go.FieldDecl "notify"%go notifyList);
  (go.FieldDecl "checker"%go copyChecker)
].
Program Definition Cond'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (Cond'fds_unsealed).
Global Instance equals_unfold_Cond {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Cond'fds =→ Cond'fds_unsealed.
Proof. rewrite /Cond'fds seal_eq //. Qed.

Definition Condⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (Cond'fds).

Class Cond_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Cond_type_repr  :: go.TypeReprUnderlying Condⁱᵐᵖˡ Cond.t;
  #[global] Cond_underlying :: (Cond) <u (Condⁱᵐᵖˡ);
  #[global] Cond_get_noCopy (x : Cond.t) :: ⟦StructFieldGet (Condⁱᵐᵖˡ) "noCopy", #x⟧ ⤳[under] #x.(Cond.noCopy');
  #[global] Cond_set_noCopy (x : Cond.t) y :: ⟦StructFieldSet (Condⁱᵐᵖˡ) "noCopy", (#x, #y)⟧ ⤳[under] #(x <|Cond.noCopy' := y|>);
  #[global] Cond_get_L (x : Cond.t) :: ⟦StructFieldGet (Condⁱᵐᵖˡ) "L", #x⟧ ⤳[under] #x.(Cond.L');
  #[global] Cond_set_L (x : Cond.t) y :: ⟦StructFieldSet (Condⁱᵐᵖˡ) "L", (#x, #y)⟧ ⤳[under] #(x <|Cond.L' := y|>);
  #[global] Cond_get_notify (x : Cond.t) :: ⟦StructFieldGet (Condⁱᵐᵖˡ) "notify", #x⟧ ⤳[under] #x.(Cond.notify');
  #[global] Cond_set_notify (x : Cond.t) y :: ⟦StructFieldSet (Condⁱᵐᵖˡ) "notify", (#x, #y)⟧ ⤳[under] #(x <|Cond.notify' := y|>);
  #[global] Cond_get_checker (x : Cond.t) :: ⟦StructFieldGet (Condⁱᵐᵖˡ) "checker", #x⟧ ⤳[under] #x.(Cond.checker');
  #[global] Cond_set_checker (x : Cond.t) y :: ⟦StructFieldSet (Condⁱᵐᵖˡ) "checker", (#x, #y)⟧ ⤳[under] #(x <|Cond.checker' := y|>);
  #[global] Cond'ptr_Broadcast_unfold :: MethodUnfold (go.PointerType (Cond)) "Broadcast" (Cond__Broadcastⁱᵐᵖˡ);
  #[global] Cond'ptr_Signal_unfold :: MethodUnfold (go.PointerType (Cond)) "Signal" (Cond__Signalⁱᵐᵖˡ);
  #[global] Cond'ptr_Wait_unfold :: MethodUnfold (go.PointerType (Cond)) "Wait" (Cond__Waitⁱᵐᵖˡ);
}.

Module Map.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End Map.

Class Map_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Map_type_repr  :: go.TypeReprUnderlying Mapⁱᵐᵖˡ Map.t;
  #[global] Map_underlying :: (Map) <u (Mapⁱᵐᵖˡ);
  #[global] Mapⁱᵐᵖˡ_underlying :: (Mapⁱᵐᵖˡ) ↓u (Mapⁱᵐᵖˡ);
}.

Class Mutex_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Mutex_type_repr  :: go.TypeReprUnderlying Mutexⁱᵐᵖˡ Mutex.t;
  #[global] Mutex_underlying :: (Mutex) <u (Mutexⁱᵐᵖˡ);
  #[global] Mutex'ptr_Lock_unfold :: MethodUnfold (go.PointerType (Mutex)) "Lock" (Mutex__Lockⁱᵐᵖˡ);
  #[global] Mutex'ptr_TryLock_unfold :: MethodUnfold (go.PointerType (Mutex)) "TryLock" (Mutex__TryLockⁱᵐᵖˡ);
  #[global] Mutex'ptr_Unlock_unfold :: MethodUnfold (go.PointerType (Mutex)) "Unlock" (Mutex__Unlockⁱᵐᵖˡ);
}.

Module Once.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  _0' : sync.noCopy.t;
  done' : atomic.Bool.t;
  m' : sync.Mutex.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End Once.

Definition Once'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "_0"%go noCopy);
  (go.FieldDecl "done"%go atomic.Bool);
  (go.FieldDecl "m"%go Mutex)
].
Program Definition Once'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (Once'fds_unsealed).
Global Instance equals_unfold_Once {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Once'fds =→ Once'fds_unsealed.
Proof. rewrite /Once'fds seal_eq //. Qed.

Definition Onceⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (Once'fds).

Class Once_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Once_type_repr  :: go.TypeReprUnderlying Onceⁱᵐᵖˡ Once.t;
  #[global] Once_underlying :: (Once) <u (Onceⁱᵐᵖˡ);
  #[global] Once_get__0 (x : Once.t) :: ⟦StructFieldGet (Onceⁱᵐᵖˡ) "_0", #x⟧ ⤳[under] #x.(Once._0');
  #[global] Once_set__0 (x : Once.t) y :: ⟦StructFieldSet (Onceⁱᵐᵖˡ) "_0", (#x, #y)⟧ ⤳[under] #(x <|Once._0' := y|>);
  #[global] Once_get_done (x : Once.t) :: ⟦StructFieldGet (Onceⁱᵐᵖˡ) "done", #x⟧ ⤳[under] #x.(Once.done');
  #[global] Once_set_done (x : Once.t) y :: ⟦StructFieldSet (Onceⁱᵐᵖˡ) "done", (#x, #y)⟧ ⤳[under] #(x <|Once.done' := y|>);
  #[global] Once_get_m (x : Once.t) :: ⟦StructFieldGet (Onceⁱᵐᵖˡ) "m", #x⟧ ⤳[under] #x.(Once.m');
  #[global] Once_set_m (x : Once.t) y :: ⟦StructFieldSet (Onceⁱᵐᵖˡ) "m", (#x, #y)⟧ ⤳[under] #(x <|Once.m' := y|>);
  #[global] Once'ptr_Do_unfold :: MethodUnfold (go.PointerType (Once)) "Do" (Once__Doⁱᵐᵖˡ);
  #[global] Once'ptr_doSlow_unfold :: MethodUnfold (go.PointerType (Once)) "doSlow" (Once__doSlowⁱᵐᵖˡ);
}.

Module Pool.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End Pool.

Class Pool_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Pool_type_repr  :: go.TypeReprUnderlying Poolⁱᵐᵖˡ Pool.t;
  #[global] Pool_underlying :: (Pool) <u (Poolⁱᵐᵖˡ);
  #[global] Poolⁱᵐᵖˡ_underlying :: (Poolⁱᵐᵖˡ) ↓u (Poolⁱᵐᵖˡ);
}.

Module poolLocalInternal.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End poolLocalInternal.

Class poolLocalInternal_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] poolLocalInternal_type_repr  :: go.TypeReprUnderlying poolLocalInternalⁱᵐᵖˡ poolLocalInternal.t;
  #[global] poolLocalInternal_underlying :: (poolLocalInternal) <u (poolLocalInternalⁱᵐᵖˡ);
  #[global] poolLocalInternalⁱᵐᵖˡ_underlying :: (poolLocalInternalⁱᵐᵖˡ) ↓u (poolLocalInternalⁱᵐᵖˡ);
}.

Module poolLocal.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End poolLocal.

Class poolLocal_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] poolLocal_type_repr  :: go.TypeReprUnderlying poolLocalⁱᵐᵖˡ poolLocal.t;
  #[global] poolLocal_underlying :: (poolLocal) <u (poolLocalⁱᵐᵖˡ);
  #[global] poolLocalⁱᵐᵖˡ_underlying :: (poolLocalⁱᵐᵖˡ) ↓u (poolLocalⁱᵐᵖˡ);
}.

Module poolDequeue.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End poolDequeue.

Class poolDequeue_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] poolDequeue_type_repr  :: go.TypeReprUnderlying poolDequeueⁱᵐᵖˡ poolDequeue.t;
  #[global] poolDequeue_underlying :: (poolDequeue) <u (poolDequeueⁱᵐᵖˡ);
  #[global] poolDequeueⁱᵐᵖˡ_underlying :: (poolDequeueⁱᵐᵖˡ) ↓u (poolDequeueⁱᵐᵖˡ);
}.

Module eface.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End eface.

Class eface_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] eface_type_repr  :: go.TypeReprUnderlying efaceⁱᵐᵖˡ eface.t;
  #[global] eface_underlying :: (eface) <u (efaceⁱᵐᵖˡ);
  #[global] efaceⁱᵐᵖˡ_underlying :: (efaceⁱᵐᵖˡ) ↓u (efaceⁱᵐᵖˡ);
}.

Module dequeueNil.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End dequeueNil.

Class dequeueNil_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] dequeueNil_type_repr  :: go.TypeReprUnderlying dequeueNilⁱᵐᵖˡ dequeueNil.t;
  #[global] dequeueNil_underlying :: (dequeueNil) <u (dequeueNilⁱᵐᵖˡ);
  #[global] dequeueNilⁱᵐᵖˡ_underlying :: (dequeueNilⁱᵐᵖˡ) ↓u (dequeueNilⁱᵐᵖˡ);
}.

Module poolChain.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End poolChain.

Class poolChain_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] poolChain_type_repr  :: go.TypeReprUnderlying poolChainⁱᵐᵖˡ poolChain.t;
  #[global] poolChain_underlying :: (poolChain) <u (poolChainⁱᵐᵖˡ);
  #[global] poolChainⁱᵐᵖˡ_underlying :: (poolChainⁱᵐᵖˡ) ↓u (poolChainⁱᵐᵖˡ);
}.

Module poolChainElt.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End poolChainElt.

Class poolChainElt_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] poolChainElt_type_repr  :: go.TypeReprUnderlying poolChainEltⁱᵐᵖˡ poolChainElt.t;
  #[global] poolChainElt_underlying :: (poolChainElt) <u (poolChainEltⁱᵐᵖˡ);
  #[global] poolChainEltⁱᵐᵖˡ_underlying :: (poolChainEltⁱᵐᵖˡ) ↓u (poolChainEltⁱᵐᵖˡ);
}.

Module RWMutex.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  w' : sync.Mutex.t;
  writerSem' : w32;
  readerSem' : w32;
  readerCount' : atomic.Int32.t;
  readerWait' : atomic.Int32.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End RWMutex.

Definition RWMutex'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "w"%go Mutex);
  (go.FieldDecl "writerSem"%go go.uint32);
  (go.FieldDecl "readerSem"%go go.uint32);
  (go.FieldDecl "readerCount"%go atomic.Int32);
  (go.FieldDecl "readerWait"%go atomic.Int32)
].
Program Definition RWMutex'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (RWMutex'fds_unsealed).
Global Instance equals_unfold_RWMutex {ext : ffi_syntax} {go_gctx : GoGlobalContext} : RWMutex'fds =→ RWMutex'fds_unsealed.
Proof. rewrite /RWMutex'fds seal_eq //. Qed.

Definition RWMutexⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (RWMutex'fds).

Class RWMutex_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] RWMutex_type_repr  :: go.TypeReprUnderlying RWMutexⁱᵐᵖˡ RWMutex.t;
  #[global] RWMutex_underlying :: (RWMutex) <u (RWMutexⁱᵐᵖˡ);
  #[global] RWMutex_get_w (x : RWMutex.t) :: ⟦StructFieldGet (RWMutexⁱᵐᵖˡ) "w", #x⟧ ⤳[under] #x.(RWMutex.w');
  #[global] RWMutex_set_w (x : RWMutex.t) y :: ⟦StructFieldSet (RWMutexⁱᵐᵖˡ) "w", (#x, #y)⟧ ⤳[under] #(x <|RWMutex.w' := y|>);
  #[global] RWMutex_get_writerSem (x : RWMutex.t) :: ⟦StructFieldGet (RWMutexⁱᵐᵖˡ) "writerSem", #x⟧ ⤳[under] #x.(RWMutex.writerSem');
  #[global] RWMutex_set_writerSem (x : RWMutex.t) y :: ⟦StructFieldSet (RWMutexⁱᵐᵖˡ) "writerSem", (#x, #y)⟧ ⤳[under] #(x <|RWMutex.writerSem' := y|>);
  #[global] RWMutex_get_readerSem (x : RWMutex.t) :: ⟦StructFieldGet (RWMutexⁱᵐᵖˡ) "readerSem", #x⟧ ⤳[under] #x.(RWMutex.readerSem');
  #[global] RWMutex_set_readerSem (x : RWMutex.t) y :: ⟦StructFieldSet (RWMutexⁱᵐᵖˡ) "readerSem", (#x, #y)⟧ ⤳[under] #(x <|RWMutex.readerSem' := y|>);
  #[global] RWMutex_get_readerCount (x : RWMutex.t) :: ⟦StructFieldGet (RWMutexⁱᵐᵖˡ) "readerCount", #x⟧ ⤳[under] #x.(RWMutex.readerCount');
  #[global] RWMutex_set_readerCount (x : RWMutex.t) y :: ⟦StructFieldSet (RWMutexⁱᵐᵖˡ) "readerCount", (#x, #y)⟧ ⤳[under] #(x <|RWMutex.readerCount' := y|>);
  #[global] RWMutex_get_readerWait (x : RWMutex.t) :: ⟦StructFieldGet (RWMutexⁱᵐᵖˡ) "readerWait", #x⟧ ⤳[under] #x.(RWMutex.readerWait');
  #[global] RWMutex_set_readerWait (x : RWMutex.t) y :: ⟦StructFieldSet (RWMutexⁱᵐᵖˡ) "readerWait", (#x, #y)⟧ ⤳[under] #(x <|RWMutex.readerWait' := y|>);
  #[global] RWMutex'ptr_Lock_unfold :: MethodUnfold (go.PointerType (RWMutex)) "Lock" (RWMutex__Lockⁱᵐᵖˡ);
  #[global] RWMutex'ptr_RLock_unfold :: MethodUnfold (go.PointerType (RWMutex)) "RLock" (RWMutex__RLockⁱᵐᵖˡ);
  #[global] RWMutex'ptr_RLocker_unfold :: MethodUnfold (go.PointerType (RWMutex)) "RLocker" (RWMutex__RLockerⁱᵐᵖˡ);
  #[global] RWMutex'ptr_RUnlock_unfold :: MethodUnfold (go.PointerType (RWMutex)) "RUnlock" (RWMutex__RUnlockⁱᵐᵖˡ);
  #[global] RWMutex'ptr_TryLock_unfold :: MethodUnfold (go.PointerType (RWMutex)) "TryLock" (RWMutex__TryLockⁱᵐᵖˡ);
  #[global] RWMutex'ptr_TryRLock_unfold :: MethodUnfold (go.PointerType (RWMutex)) "TryRLock" (RWMutex__TryRLockⁱᵐᵖˡ);
  #[global] RWMutex'ptr_Unlock_unfold :: MethodUnfold (go.PointerType (RWMutex)) "Unlock" (RWMutex__Unlockⁱᵐᵖˡ);
  #[global] RWMutex'ptr_rUnlockSlow_unfold :: MethodUnfold (go.PointerType (RWMutex)) "rUnlockSlow" (RWMutex__rUnlockSlowⁱᵐᵖˡ);
}.

Module rlocker.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := sync.RWMutex.t.
End def.
End rlocker.

Definition rlockerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := RWMutex.

Class rlocker_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] rlocker_underlying :: (rlocker) <u (rlockerⁱᵐᵖˡ);
}.

Module WaitGroup.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  noCopy' : sync.noCopy.t;
  state' : atomic.Uint64.t;
  sema' : w32;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End WaitGroup.

Definition WaitGroup'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "noCopy"%go noCopy);
  (go.FieldDecl "state"%go atomic.Uint64);
  (go.FieldDecl "sema"%go go.uint32)
].
Program Definition WaitGroup'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (WaitGroup'fds_unsealed).
Global Instance equals_unfold_WaitGroup {ext : ffi_syntax} {go_gctx : GoGlobalContext} : WaitGroup'fds =→ WaitGroup'fds_unsealed.
Proof. rewrite /WaitGroup'fds seal_eq //. Qed.

Definition WaitGroupⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (WaitGroup'fds).

Class WaitGroup_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] WaitGroup_type_repr  :: go.TypeReprUnderlying WaitGroupⁱᵐᵖˡ WaitGroup.t;
  #[global] WaitGroup_underlying :: (WaitGroup) <u (WaitGroupⁱᵐᵖˡ);
  #[global] WaitGroup_get_noCopy (x : WaitGroup.t) :: ⟦StructFieldGet (WaitGroupⁱᵐᵖˡ) "noCopy", #x⟧ ⤳[under] #x.(WaitGroup.noCopy');
  #[global] WaitGroup_set_noCopy (x : WaitGroup.t) y :: ⟦StructFieldSet (WaitGroupⁱᵐᵖˡ) "noCopy", (#x, #y)⟧ ⤳[under] #(x <|WaitGroup.noCopy' := y|>);
  #[global] WaitGroup_get_state (x : WaitGroup.t) :: ⟦StructFieldGet (WaitGroupⁱᵐᵖˡ) "state", #x⟧ ⤳[under] #x.(WaitGroup.state');
  #[global] WaitGroup_set_state (x : WaitGroup.t) y :: ⟦StructFieldSet (WaitGroupⁱᵐᵖˡ) "state", (#x, #y)⟧ ⤳[under] #(x <|WaitGroup.state' := y|>);
  #[global] WaitGroup_get_sema (x : WaitGroup.t) :: ⟦StructFieldGet (WaitGroupⁱᵐᵖˡ) "sema", #x⟧ ⤳[under] #x.(WaitGroup.sema');
  #[global] WaitGroup_set_sema (x : WaitGroup.t) y :: ⟦StructFieldSet (WaitGroupⁱᵐᵖˡ) "sema", (#x, #y)⟧ ⤳[under] #(x <|WaitGroup.sema' := y|>);
  #[global] WaitGroup'ptr_Add_unfold :: MethodUnfold (go.PointerType (WaitGroup)) "Add" (WaitGroup__Addⁱᵐᵖˡ);
  #[global] WaitGroup'ptr_Done_unfold :: MethodUnfold (go.PointerType (WaitGroup)) "Done" (WaitGroup__Doneⁱᵐᵖˡ);
  #[global] WaitGroup'ptr_Go_unfold :: MethodUnfold (go.PointerType (WaitGroup)) "Go" (WaitGroup__Goⁱᵐᵖˡ);
  #[global] WaitGroup'ptr_Wait_unfold :: MethodUnfold (go.PointerType (WaitGroup)) "Wait" (WaitGroup__Waitⁱᵐᵖˡ);
}.

Class Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Cond_instance :: Cond_Assumptions;
  #[global] copyChecker_instance :: copyChecker_Assumptions;
  #[global] noCopy_instance :: noCopy_Assumptions;
  #[global] Map_instance :: Map_Assumptions;
  #[global] Mutex_instance :: Mutex_Assumptions;
  #[global] Locker_instance :: Locker_Assumptions;
  #[global] Once_instance :: Once_Assumptions;
  #[global] Pool_instance :: Pool_Assumptions;
  #[global] poolLocalInternal_instance :: poolLocalInternal_Assumptions;
  #[global] poolLocal_instance :: poolLocal_Assumptions;
  #[global] poolDequeue_instance :: poolDequeue_Assumptions;
  #[global] eface_instance :: eface_Assumptions;
  #[global] dequeueNil_instance :: dequeueNil_Assumptions;
  #[global] poolChain_instance :: poolChain_Assumptions;
  #[global] poolChainElt_instance :: poolChainElt_Assumptions;
  #[global] notifyList_instance :: notifyList_Assumptions;
  #[global] RWMutex_instance :: RWMutex_Assumptions;
  #[global] rlocker_instance :: rlocker_Assumptions;
  #[global] WaitGroup_instance :: WaitGroup_Assumptions;
  #[global] NewCond_unfold :: FuncUnfold NewCond [] (NewCondⁱᵐᵖˡ);
  #[global] runtime_Semacquire_unfold :: FuncUnfold runtime_Semacquire [] (runtime_Semacquireⁱᵐᵖˡ);
  #[global] runtime_SemacquireWaitGroup_unfold :: FuncUnfold runtime_SemacquireWaitGroup [] (runtime_SemacquireWaitGroupⁱᵐᵖˡ);
  #[global] runtime_SemacquireRWMutexR_unfold :: FuncUnfold runtime_SemacquireRWMutexR [] (runtime_SemacquireRWMutexRⁱᵐᵖˡ);
  #[global] runtime_SemacquireRWMutex_unfold :: FuncUnfold runtime_SemacquireRWMutex [] (runtime_SemacquireRWMutexⁱᵐᵖˡ);
  #[global] runtime_Semrelease_unfold :: FuncUnfold runtime_Semrelease [] (runtime_Semreleaseⁱᵐᵖˡ);
  #[global] runtime_notifyListAdd_unfold :: FuncUnfold runtime_notifyListAdd [] (runtime_notifyListAddⁱᵐᵖˡ);
  #[global] runtime_notifyListWait_unfold :: FuncUnfold runtime_notifyListWait [] (runtime_notifyListWaitⁱᵐᵖˡ);
  #[global] runtime_notifyListNotifyAll_unfold :: FuncUnfold runtime_notifyListNotifyAll [] (runtime_notifyListNotifyAllⁱᵐᵖˡ);
  #[global] runtime_notifyListNotifyOne_unfold :: FuncUnfold runtime_notifyListNotifyOne [] (runtime_notifyListNotifyOneⁱᵐᵖˡ);
  #[global] runtime_notifyListCheck_unfold :: FuncUnfold runtime_notifyListCheck [] (runtime_notifyListCheckⁱᵐᵖˡ);
  #[global] import_atomic_Assumption :: atomic.Assumptions;
  #[global] import_race_Assumption :: race.Assumptions;
  #[global] import_synctest_Assumption :: synctest.Assumptions;
}.
End sync.
