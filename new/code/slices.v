(* autogenerated from slices *)

From New.golang Require Import defn.
Definition slices : go_string := "slices".

Module slices.

Module sortedHint. Definition id : go_string := "slices.sortedHint"%go. End sortedHint.
Module xorshift. Definition id : go_string := "slices.xorshift"%go. End xorshift.

Section code.
Context `{ffi_syntax}.


Definition All : go_string := "slices.All"%go.

Definition Backward : go_string := "slices.Backward"%go.

Definition Values : go_string := "slices.Values"%go.

Definition AppendSeq : go_string := "slices.AppendSeq"%go.

Definition Collect : go_string := "slices.Collect"%go.

Definition Sorted : go_string := "slices.Sorted"%go.

Definition SortedFunc : go_string := "slices.SortedFunc"%go.

Definition SortedStableFunc : go_string := "slices.SortedStableFunc"%go.

Definition Chunk : go_string := "slices.Chunk"%go.

Definition Equal : go_string := "slices.Equal"%go.

Definition EqualFunc : go_string := "slices.EqualFunc"%go.

Definition Compare : go_string := "slices.Compare"%go.

Definition CompareFunc : go_string := "slices.CompareFunc"%go.

Definition Index : go_string := "slices.Index"%go.

Definition IndexFunc : go_string := "slices.IndexFunc"%go.

Definition Contains : go_string := "slices.Contains"%go.

Definition ContainsFunc : go_string := "slices.ContainsFunc"%go.

Definition Insert : go_string := "slices.Insert"%go.

Definition Delete : go_string := "slices.Delete"%go.

Definition DeleteFunc : go_string := "slices.DeleteFunc"%go.

Definition Replace : go_string := "slices.Replace"%go.

Definition Clone : go_string := "slices.Clone"%go.

Definition Compact : go_string := "slices.Compact"%go.

Definition CompactFunc : go_string := "slices.CompactFunc"%go.

Definition Grow : go_string := "slices.Grow"%go.

Definition Clip : go_string := "slices.Clip"%go.

Definition rotateLeft : go_string := "slices.rotateLeft"%go.

Definition rotateRight : go_string := "slices.rotateRight"%go.

Definition overlaps : go_string := "slices.overlaps"%go.

Definition startIdx : go_string := "slices.startIdx"%go.

Definition Reverse : go_string := "slices.Reverse"%go.

Definition Concat : go_string := "slices.Concat"%go.

Definition Repeat : go_string := "slices.Repeat"%go.

Definition Sort : go_string := "slices.Sort"%go.

Definition SortFunc : go_string := "slices.SortFunc"%go.

Definition SortStableFunc : go_string := "slices.SortStableFunc"%go.

Definition IsSorted : go_string := "slices.IsSorted"%go.

Definition IsSortedFunc : go_string := "slices.IsSortedFunc"%go.

Definition Min : go_string := "slices.Min"%go.

Definition MinFunc : go_string := "slices.MinFunc"%go.

Definition Max : go_string := "slices.Max"%go.

Definition MaxFunc : go_string := "slices.MaxFunc"%go.

Definition BinarySearch : go_string := "slices.BinarySearch"%go.

Definition BinarySearchFunc : go_string := "slices.BinarySearchFunc"%go.

Axiom sortedHint : go_type.

Axiom unknownHint : val.

Axiom increasingHint : val.

Axiom decreasingHint : val.

Definition xorshift : go_type := uint64T.
#[global] Typeclasses Opaque xorshift.
#[global] Opaque xorshift.

(* go: sort.go:181:20 *)
Definition xorshift__Nextⁱᵐᵖˡ : val :=
  λ: "r" <>,
    exception_do (let: "r" := (mem.alloc "r") in
    do:  ((![#ptrT] "r") <-[#xorshift] ((![#xorshift] (![#ptrT] "r")) `xor` ((![#xorshift] (![#ptrT] "r")) ≪ #(W64 13))));;;
    do:  ((![#ptrT] "r") <-[#xorshift] ((![#xorshift] (![#ptrT] "r")) `xor` ((![#xorshift] (![#ptrT] "r")) ≫ #(W64 7))));;;
    do:  ((![#ptrT] "r") <-[#xorshift] ((![#xorshift] (![#ptrT] "r")) `xor` ((![#xorshift] (![#ptrT] "r")) ≪ #(W64 17))));;;
    return: (![#xorshift] (![#ptrT] "r"))).

Definition nextPowerOfTwo : go_string := "slices.nextPowerOfTwo"%go.

Definition isNaN : go_string := "slices.isNaN"%go.

Definition insertionSortCmpFunc : go_string := "slices.insertionSortCmpFunc"%go.

(* insertionSortCmpFunc sorts data[a:b] using insertion sort.

   go: zsortanyfunc.go:10:6 *)
Definition insertionSortCmpFuncⁱᵐᵖˡ : val :=
  λ: "E" "data" "a" "b" "cmp",
    exception_do (let: "cmp" := (mem.alloc "cmp") in
    let: "b" := (mem.alloc "b") in
    let: "a" := (mem.alloc "a") in
    let: "data" := (mem.alloc "data") in
    (let: "i" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := ((![#intT] "a") + #(W64 1)) in
    do:  ("i" <-[#intT] "$r0");;;
    (for: (λ: <>, int_lt (![#intT] "i") (![#intT] "b")); (λ: <>, do:  ("i" <-[#intT] ((![#intT] "i") + #(W64 1)))) := λ: <>,
      (let: "j" := (mem.alloc (type.zero_val #intT)) in
      let: "$r0" := (![#intT] "i") in
      do:  ("j" <-[#intT] "$r0");;;
      (for: (λ: <>, (int_gt (![#intT] "j") (![#intT] "a")) && (int_lt (let: "$a0" := (!["E"] (slice.elem_ref "E" (![#sliceT] "data") (![#intT] "j"))) in
      let: "$a1" := (!["E"] (slice.elem_ref "E" (![#sliceT] "data") ((![#intT] "j") - #(W64 1)))) in
      (![#funcT] "cmp") "$a0" "$a1") #(W64 0))); (λ: <>, do:  ("j" <-[#intT] ((![#intT] "j") - #(W64 1)))) := λ: <>,
        let: "$r0" := (!["E"] (slice.elem_ref "E" (![#sliceT] "data") ((![#intT] "j") - #(W64 1)))) in
        let: "$r1" := (!["E"] (slice.elem_ref "E" (![#sliceT] "data") (![#intT] "j"))) in
        do:  ((slice.elem_ref "E" (![#sliceT] "data") (![#intT] "j")) <-["E"] "$r0");;;
        do:  ((slice.elem_ref "E" (![#sliceT] "data") ((![#intT] "j") - #(W64 1))) <-["E"] "$r1")))));;;
    return: #()).

Definition siftDownCmpFunc : go_string := "slices.siftDownCmpFunc"%go.

(* siftDownCmpFunc implements the heap property on data[lo:hi].
   first is an offset into the array where the root of the heap lies.

   go: zsortanyfunc.go:20:6 *)
Definition siftDownCmpFuncⁱᵐᵖˡ : val :=
  λ: "E" "data" "lo" "hi" "first" "cmp",
    exception_do (let: "cmp" := (mem.alloc "cmp") in
    let: "first" := (mem.alloc "first") in
    let: "hi" := (mem.alloc "hi") in
    let: "lo" := (mem.alloc "lo") in
    let: "data" := (mem.alloc "data") in
    let: "root" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := (![#intT] "lo") in
    do:  ("root" <-[#intT] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "child" := (mem.alloc (type.zero_val #intT)) in
      let: "$r0" := ((#(W64 2) * (![#intT] "root")) + #(W64 1)) in
      do:  ("child" <-[#intT] "$r0");;;
      (if: int_geq (![#intT] "child") (![#intT] "hi")
      then break: #()
      else do:  #());;;
      (if: (int_lt ((![#intT] "child") + #(W64 1)) (![#intT] "hi")) && (int_lt (let: "$a0" := (!["E"] (slice.elem_ref "E" (![#sliceT] "data") ((![#intT] "first") + (![#intT] "child")))) in
      let: "$a1" := (!["E"] (slice.elem_ref "E" (![#sliceT] "data") (((![#intT] "first") + (![#intT] "child")) + #(W64 1)))) in
      (![#funcT] "cmp") "$a0" "$a1") #(W64 0))
      then do:  ("child" <-[#intT] ((![#intT] "child") + #(W64 1)))
      else do:  #());;;
      (if: (~ (int_lt (let: "$a0" := (!["E"] (slice.elem_ref "E" (![#sliceT] "data") ((![#intT] "first") + (![#intT] "root")))) in
      let: "$a1" := (!["E"] (slice.elem_ref "E" (![#sliceT] "data") ((![#intT] "first") + (![#intT] "child")))) in
      (![#funcT] "cmp") "$a0" "$a1") #(W64 0)))
      then return: (#())
      else do:  #());;;
      let: "$r0" := (!["E"] (slice.elem_ref "E" (![#sliceT] "data") ((![#intT] "first") + (![#intT] "child")))) in
      let: "$r1" := (!["E"] (slice.elem_ref "E" (![#sliceT] "data") ((![#intT] "first") + (![#intT] "root")))) in
      do:  ((slice.elem_ref "E" (![#sliceT] "data") ((![#intT] "first") + (![#intT] "root"))) <-["E"] "$r0");;;
      do:  ((slice.elem_ref "E" (![#sliceT] "data") ((![#intT] "first") + (![#intT] "child"))) <-["E"] "$r1");;;
      let: "$r0" := (![#intT] "child") in
      do:  ("root" <-[#intT] "$r0"));;;
    return: #()).

Definition heapSortCmpFunc : go_string := "slices.heapSortCmpFunc"%go.

(* go: zsortanyfunc.go:38:6 *)
Definition heapSortCmpFuncⁱᵐᵖˡ : val :=
  λ: "E" "data" "a" "b" "cmp",
    exception_do (let: "cmp" := (mem.alloc "cmp") in
    let: "b" := (mem.alloc "b") in
    let: "a" := (mem.alloc "a") in
    let: "data" := (mem.alloc "data") in
    let: "first" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := (![#intT] "a") in
    do:  ("first" <-[#intT] "$r0");;;
    let: "lo" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := #(W64 0) in
    do:  ("lo" <-[#intT] "$r0");;;
    let: "hi" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := ((![#intT] "b") - (![#intT] "a")) in
    do:  ("hi" <-[#intT] "$r0");;;
    (let: "i" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := (((![#intT] "hi") - #(W64 1)) `quots` #(W64 2)) in
    do:  ("i" <-[#intT] "$r0");;;
    (for: (λ: <>, int_geq (![#intT] "i") #(W64 0)); (λ: <>, do:  ("i" <-[#intT] ((![#intT] "i") - #(W64 1)))) := λ: <>,
      do:  (let: "$a0" := (![#sliceT] "data") in
      let: "$a1" := (![#intT] "i") in
      let: "$a2" := (![#intT] "hi") in
      let: "$a3" := (![#intT] "first") in
      let: "$a4" := (![#funcT] "cmp") in
      ((func_call #siftDownCmpFunc) "E") "$a0" "$a1" "$a2" "$a3" "$a4")));;;
    (let: "i" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := ((![#intT] "hi") - #(W64 1)) in
    do:  ("i" <-[#intT] "$r0");;;
    (for: (λ: <>, int_geq (![#intT] "i") #(W64 0)); (λ: <>, do:  ("i" <-[#intT] ((![#intT] "i") - #(W64 1)))) := λ: <>,
      let: "$r0" := (!["E"] (slice.elem_ref "E" (![#sliceT] "data") ((![#intT] "first") + (![#intT] "i")))) in
      let: "$r1" := (!["E"] (slice.elem_ref "E" (![#sliceT] "data") (![#intT] "first"))) in
      do:  ((slice.elem_ref "E" (![#sliceT] "data") (![#intT] "first")) <-["E"] "$r0");;;
      do:  ((slice.elem_ref "E" (![#sliceT] "data") ((![#intT] "first") + (![#intT] "i"))) <-["E"] "$r1");;;
      do:  (let: "$a0" := (![#sliceT] "data") in
      let: "$a1" := (![#intT] "lo") in
      let: "$a2" := (![#intT] "i") in
      let: "$a3" := (![#intT] "first") in
      let: "$a4" := (![#funcT] "cmp") in
      ((func_call #siftDownCmpFunc) "E") "$a0" "$a1" "$a2" "$a3" "$a4")));;;
    return: #()).

Definition pdqsortCmpFunc : go_string := "slices.pdqsortCmpFunc"%go.

Definition partitionCmpFunc : go_string := "slices.partitionCmpFunc"%go.

Definition partitionEqualCmpFunc : go_string := "slices.partitionEqualCmpFunc"%go.

Definition partialInsertionSortCmpFunc : go_string := "slices.partialInsertionSortCmpFunc"%go.

Definition reverseRangeCmpFunc : go_string := "slices.reverseRangeCmpFunc"%go.

Definition choosePivotCmpFunc : go_string := "slices.choosePivotCmpFunc"%go.

Definition breakPatternsCmpFunc : go_string := "slices.breakPatternsCmpFunc"%go.

(* pdqsortCmpFunc sorts data[a:b].
   The algorithm based on pattern-defeating quicksort(pdqsort), but without the optimizations from BlockQuicksort.
   pdqsort paper: https://arxiv.org/pdf/2106.05123.pdf
   C++ implementation: https://github.com/orlp/pdqsort
   Rust implementation: https://docs.rs/pdqsort/latest/pdqsort/
   limit is the number of allowed bad (very unbalanced) pivots before falling back to heapsort.

   go: zsortanyfunc.go:61:6 *)
Definition pdqsortCmpFuncⁱᵐᵖˡ : val :=
  λ: "E" "data" "a" "b" "limit" "cmp",
    exception_do (let: "cmp" := (mem.alloc "cmp") in
    let: "limit" := (mem.alloc "limit") in
    let: "b" := (mem.alloc "b") in
    let: "a" := (mem.alloc "a") in
    let: "data" := (mem.alloc "data") in
    let maxInsertion := 12 in
    let: "wasPartitioned" := (mem.alloc (type.zero_val #boolT)) in
    let: "$r0" := #true in
    do:  ("wasPartitioned" <-[#boolT] "$r0");;;
    let: "wasBalanced" := (mem.alloc (type.zero_val #boolT)) in
    let: "$r0" := #true in
    do:  ("wasBalanced" <-[#boolT] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "length" := (mem.alloc (type.zero_val #intT)) in
      let: "$r0" := ((![#intT] "b") - (![#intT] "a")) in
      do:  ("length" <-[#intT] "$r0");;;
      (if: int_leq (![#intT] "length") #(W64 maxInsertion)
      then
        do:  (let: "$a0" := (![#sliceT] "data") in
        let: "$a1" := (![#intT] "a") in
        let: "$a2" := (![#intT] "b") in
        let: "$a3" := (![#funcT] "cmp") in
        ((func_call #insertionSortCmpFunc) "E") "$a0" "$a1" "$a2" "$a3");;;
        return: (#())
      else do:  #());;;
      (if: (![#intT] "limit") = #(W64 0)
      then
        do:  (let: "$a0" := (![#sliceT] "data") in
        let: "$a1" := (![#intT] "a") in
        let: "$a2" := (![#intT] "b") in
        let: "$a3" := (![#funcT] "cmp") in
        ((func_call #heapSortCmpFunc) "E") "$a0" "$a1" "$a2" "$a3");;;
        return: (#())
      else do:  #());;;
      (if: (~ (![#boolT] "wasBalanced"))
      then
        do:  (let: "$a0" := (![#sliceT] "data") in
        let: "$a1" := (![#intT] "a") in
        let: "$a2" := (![#intT] "b") in
        let: "$a3" := (![#funcT] "cmp") in
        ((func_call #breakPatternsCmpFunc) "E") "$a0" "$a1" "$a2" "$a3");;;
        do:  ("limit" <-[#intT] ((![#intT] "limit") - #(W64 1)))
      else do:  #());;;
      let: "hint" := (mem.alloc (type.zero_val #sortedHint)) in
      let: "pivot" := (mem.alloc (type.zero_val #intT)) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "data") in
      let: "$a1" := (![#intT] "a") in
      let: "$a2" := (![#intT] "b") in
      let: "$a3" := (![#funcT] "cmp") in
      ((func_call #choosePivotCmpFunc) "E") "$a0" "$a1" "$a2" "$a3") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("pivot" <-[#intT] "$r0");;;
      do:  ("hint" <-[#sortedHint] "$r1");;;
      (if: (![#sortedHint] "hint") = decreasingHint
      then
        do:  (let: "$a0" := (![#sliceT] "data") in
        let: "$a1" := (![#intT] "a") in
        let: "$a2" := (![#intT] "b") in
        let: "$a3" := (![#funcT] "cmp") in
        ((func_call #reverseRangeCmpFunc) "E") "$a0" "$a1" "$a2" "$a3");;;
        let: "$r0" := (((![#intT] "b") - #(W64 1)) - ((![#intT] "pivot") - (![#intT] "a"))) in
        do:  ("pivot" <-[#intT] "$r0");;;
        let: "$r0" := increasingHint in
        do:  ("hint" <-[#sortedHint] "$r0")
      else do:  #());;;
      (if: ((![#boolT] "wasBalanced") && (![#boolT] "wasPartitioned")) && ((![#sortedHint] "hint") = increasingHint)
      then
        (if: let: "$a0" := (![#sliceT] "data") in
        let: "$a1" := (![#intT] "a") in
        let: "$a2" := (![#intT] "b") in
        let: "$a3" := (![#funcT] "cmp") in
        ((func_call #partialInsertionSortCmpFunc) "E") "$a0" "$a1" "$a2" "$a3"
        then return: (#())
        else do:  #())
      else do:  #());;;
      (if: (int_gt (![#intT] "a") #(W64 0)) && (~ (int_lt (let: "$a0" := (!["E"] (slice.elem_ref "E" (![#sliceT] "data") ((![#intT] "a") - #(W64 1)))) in
      let: "$a1" := (!["E"] (slice.elem_ref "E" (![#sliceT] "data") (![#intT] "pivot"))) in
      (![#funcT] "cmp") "$a0" "$a1") #(W64 0)))
      then
        let: "mid" := (mem.alloc (type.zero_val #intT)) in
        let: "$r0" := (let: "$a0" := (![#sliceT] "data") in
        let: "$a1" := (![#intT] "a") in
        let: "$a2" := (![#intT] "b") in
        let: "$a3" := (![#intT] "pivot") in
        let: "$a4" := (![#funcT] "cmp") in
        ((func_call #partitionEqualCmpFunc) "E") "$a0" "$a1" "$a2" "$a3" "$a4") in
        do:  ("mid" <-[#intT] "$r0");;;
        let: "$r0" := (![#intT] "mid") in
        do:  ("a" <-[#intT] "$r0");;;
        continue: #()
      else do:  #());;;
      let: "alreadyPartitioned" := (mem.alloc (type.zero_val #boolT)) in
      let: "mid" := (mem.alloc (type.zero_val #intT)) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "data") in
      let: "$a1" := (![#intT] "a") in
      let: "$a2" := (![#intT] "b") in
      let: "$a3" := (![#intT] "pivot") in
      let: "$a4" := (![#funcT] "cmp") in
      ((func_call #partitionCmpFunc) "E") "$a0" "$a1" "$a2" "$a3" "$a4") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("mid" <-[#intT] "$r0");;;
      do:  ("alreadyPartitioned" <-[#boolT] "$r1");;;
      let: "$r0" := (![#boolT] "alreadyPartitioned") in
      do:  ("wasPartitioned" <-[#boolT] "$r0");;;
      let: "rightLen" := (mem.alloc (type.zero_val #intT)) in
      let: "leftLen" := (mem.alloc (type.zero_val #intT)) in
      let: "$r0" := ((![#intT] "mid") - (![#intT] "a")) in
      let: "$r1" := ((![#intT] "b") - (![#intT] "mid")) in
      do:  ("leftLen" <-[#intT] "$r0");;;
      do:  ("rightLen" <-[#intT] "$r1");;;
      let: "balanceThreshold" := (mem.alloc (type.zero_val #intT)) in
      let: "$r0" := ((![#intT] "length") `quots` #(W64 8)) in
      do:  ("balanceThreshold" <-[#intT] "$r0");;;
      (if: int_lt (![#intT] "leftLen") (![#intT] "rightLen")
      then
        let: "$r0" := (int_geq (![#intT] "leftLen") (![#intT] "balanceThreshold")) in
        do:  ("wasBalanced" <-[#boolT] "$r0");;;
        do:  (let: "$a0" := (![#sliceT] "data") in
        let: "$a1" := (![#intT] "a") in
        let: "$a2" := (![#intT] "mid") in
        let: "$a3" := (![#intT] "limit") in
        let: "$a4" := (![#funcT] "cmp") in
        ((func_call #pdqsortCmpFunc) "E") "$a0" "$a1" "$a2" "$a3" "$a4");;;
        let: "$r0" := ((![#intT] "mid") + #(W64 1)) in
        do:  ("a" <-[#intT] "$r0")
      else
        let: "$r0" := (int_geq (![#intT] "rightLen") (![#intT] "balanceThreshold")) in
        do:  ("wasBalanced" <-[#boolT] "$r0");;;
        do:  (let: "$a0" := (![#sliceT] "data") in
        let: "$a1" := ((![#intT] "mid") + #(W64 1)) in
        let: "$a2" := (![#intT] "b") in
        let: "$a3" := (![#intT] "limit") in
        let: "$a4" := (![#funcT] "cmp") in
        ((func_call #pdqsortCmpFunc) "E") "$a0" "$a1" "$a2" "$a3" "$a4");;;
        let: "$r0" := (![#intT] "mid") in
        do:  ("b" <-[#intT] "$r0")));;;
    return: #()).

(* partitionCmpFunc does one quicksort partition.
   Let p = data[pivot]
   Moves elements in data[a:b] around, so that data[i]<p and data[j]>=p for i<newpivot and j>newpivot.
   On return, data[newpivot] = p

   go: zsortanyfunc.go:135:6 *)
Definition partitionCmpFuncⁱᵐᵖˡ : val :=
  λ: "E" "data" "a" "b" "pivot" "cmp",
    exception_do (let: "alreadyPartitioned" := (mem.alloc (type.zero_val #boolT)) in
    let: "newpivot" := (mem.alloc (type.zero_val #intT)) in
    let: "cmp" := (mem.alloc "cmp") in
    let: "pivot" := (mem.alloc "pivot") in
    let: "b" := (mem.alloc "b") in
    let: "a" := (mem.alloc "a") in
    let: "data" := (mem.alloc "data") in
    let: "$r0" := (!["E"] (slice.elem_ref "E" (![#sliceT] "data") (![#intT] "pivot"))) in
    let: "$r1" := (!["E"] (slice.elem_ref "E" (![#sliceT] "data") (![#intT] "a"))) in
    do:  ((slice.elem_ref "E" (![#sliceT] "data") (![#intT] "a")) <-["E"] "$r0");;;
    do:  ((slice.elem_ref "E" (![#sliceT] "data") (![#intT] "pivot")) <-["E"] "$r1");;;
    let: "j" := (mem.alloc (type.zero_val #intT)) in
    let: "i" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := ((![#intT] "a") + #(W64 1)) in
    let: "$r1" := ((![#intT] "b") - #(W64 1)) in
    do:  ("i" <-[#intT] "$r0");;;
    do:  ("j" <-[#intT] "$r1");;;
    (for: (λ: <>, (int_leq (![#intT] "i") (![#intT] "j")) && (int_lt (let: "$a0" := (!["E"] (slice.elem_ref "E" (![#sliceT] "data") (![#intT] "i"))) in
    let: "$a1" := (!["E"] (slice.elem_ref "E" (![#sliceT] "data") (![#intT] "a"))) in
    (![#funcT] "cmp") "$a0" "$a1") #(W64 0))); (λ: <>, #()) := λ: <>,
      do:  ("i" <-[#intT] ((![#intT] "i") + #(W64 1))));;;
    (for: (λ: <>, (int_leq (![#intT] "i") (![#intT] "j")) && (~ (int_lt (let: "$a0" := (!["E"] (slice.elem_ref "E" (![#sliceT] "data") (![#intT] "j"))) in
    let: "$a1" := (!["E"] (slice.elem_ref "E" (![#sliceT] "data") (![#intT] "a"))) in
    (![#funcT] "cmp") "$a0" "$a1") #(W64 0)))); (λ: <>, #()) := λ: <>,
      do:  ("j" <-[#intT] ((![#intT] "j") - #(W64 1))));;;
    (if: int_gt (![#intT] "i") (![#intT] "j")
    then
      let: "$r0" := (!["E"] (slice.elem_ref "E" (![#sliceT] "data") (![#intT] "a"))) in
      let: "$r1" := (!["E"] (slice.elem_ref "E" (![#sliceT] "data") (![#intT] "j"))) in
      do:  ((slice.elem_ref "E" (![#sliceT] "data") (![#intT] "j")) <-["E"] "$r0");;;
      do:  ((slice.elem_ref "E" (![#sliceT] "data") (![#intT] "a")) <-["E"] "$r1");;;
      return: (![#intT] "j", #true)
    else do:  #());;;
    let: "$r0" := (!["E"] (slice.elem_ref "E" (![#sliceT] "data") (![#intT] "j"))) in
    let: "$r1" := (!["E"] (slice.elem_ref "E" (![#sliceT] "data") (![#intT] "i"))) in
    do:  ((slice.elem_ref "E" (![#sliceT] "data") (![#intT] "i")) <-["E"] "$r0");;;
    do:  ((slice.elem_ref "E" (![#sliceT] "data") (![#intT] "j")) <-["E"] "$r1");;;
    do:  ("i" <-[#intT] ((![#intT] "i") + #(W64 1)));;;
    do:  ("j" <-[#intT] ((![#intT] "j") - #(W64 1)));;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (for: (λ: <>, (int_leq (![#intT] "i") (![#intT] "j")) && (int_lt (let: "$a0" := (!["E"] (slice.elem_ref "E" (![#sliceT] "data") (![#intT] "i"))) in
      let: "$a1" := (!["E"] (slice.elem_ref "E" (![#sliceT] "data") (![#intT] "a"))) in
      (![#funcT] "cmp") "$a0" "$a1") #(W64 0))); (λ: <>, #()) := λ: <>,
        do:  ("i" <-[#intT] ((![#intT] "i") + #(W64 1))));;;
      (for: (λ: <>, (int_leq (![#intT] "i") (![#intT] "j")) && (~ (int_lt (let: "$a0" := (!["E"] (slice.elem_ref "E" (![#sliceT] "data") (![#intT] "j"))) in
      let: "$a1" := (!["E"] (slice.elem_ref "E" (![#sliceT] "data") (![#intT] "a"))) in
      (![#funcT] "cmp") "$a0" "$a1") #(W64 0)))); (λ: <>, #()) := λ: <>,
        do:  ("j" <-[#intT] ((![#intT] "j") - #(W64 1))));;;
      (if: int_gt (![#intT] "i") (![#intT] "j")
      then break: #()
      else do:  #());;;
      let: "$r0" := (!["E"] (slice.elem_ref "E" (![#sliceT] "data") (![#intT] "j"))) in
      let: "$r1" := (!["E"] (slice.elem_ref "E" (![#sliceT] "data") (![#intT] "i"))) in
      do:  ((slice.elem_ref "E" (![#sliceT] "data") (![#intT] "i")) <-["E"] "$r0");;;
      do:  ((slice.elem_ref "E" (![#sliceT] "data") (![#intT] "j")) <-["E"] "$r1");;;
      do:  ("i" <-[#intT] ((![#intT] "i") + #(W64 1)));;;
      do:  ("j" <-[#intT] ((![#intT] "j") - #(W64 1))));;;
    let: "$r0" := (!["E"] (slice.elem_ref "E" (![#sliceT] "data") (![#intT] "a"))) in
    let: "$r1" := (!["E"] (slice.elem_ref "E" (![#sliceT] "data") (![#intT] "j"))) in
    do:  ((slice.elem_ref "E" (![#sliceT] "data") (![#intT] "j")) <-["E"] "$r0");;;
    do:  ((slice.elem_ref "E" (![#sliceT] "data") (![#intT] "a")) <-["E"] "$r1");;;
    return: (![#intT] "j", #false)).

(* partitionEqualCmpFunc partitions data[a:b] into elements equal to data[pivot] followed by elements greater than data[pivot].
   It assumed that data[a:b] does not contain elements smaller than the data[pivot].

   go: zsortanyfunc.go:173:6 *)
Definition partitionEqualCmpFuncⁱᵐᵖˡ : val :=
  λ: "E" "data" "a" "b" "pivot" "cmp",
    exception_do (let: "newpivot" := (mem.alloc (type.zero_val #intT)) in
    let: "cmp" := (mem.alloc "cmp") in
    let: "pivot" := (mem.alloc "pivot") in
    let: "b" := (mem.alloc "b") in
    let: "a" := (mem.alloc "a") in
    let: "data" := (mem.alloc "data") in
    let: "$r0" := (!["E"] (slice.elem_ref "E" (![#sliceT] "data") (![#intT] "pivot"))) in
    let: "$r1" := (!["E"] (slice.elem_ref "E" (![#sliceT] "data") (![#intT] "a"))) in
    do:  ((slice.elem_ref "E" (![#sliceT] "data") (![#intT] "a")) <-["E"] "$r0");;;
    do:  ((slice.elem_ref "E" (![#sliceT] "data") (![#intT] "pivot")) <-["E"] "$r1");;;
    let: "j" := (mem.alloc (type.zero_val #intT)) in
    let: "i" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := ((![#intT] "a") + #(W64 1)) in
    let: "$r1" := ((![#intT] "b") - #(W64 1)) in
    do:  ("i" <-[#intT] "$r0");;;
    do:  ("j" <-[#intT] "$r1");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (for: (λ: <>, (int_leq (![#intT] "i") (![#intT] "j")) && (~ (int_lt (let: "$a0" := (!["E"] (slice.elem_ref "E" (![#sliceT] "data") (![#intT] "a"))) in
      let: "$a1" := (!["E"] (slice.elem_ref "E" (![#sliceT] "data") (![#intT] "i"))) in
      (![#funcT] "cmp") "$a0" "$a1") #(W64 0)))); (λ: <>, #()) := λ: <>,
        do:  ("i" <-[#intT] ((![#intT] "i") + #(W64 1))));;;
      (for: (λ: <>, (int_leq (![#intT] "i") (![#intT] "j")) && (int_lt (let: "$a0" := (!["E"] (slice.elem_ref "E" (![#sliceT] "data") (![#intT] "a"))) in
      let: "$a1" := (!["E"] (slice.elem_ref "E" (![#sliceT] "data") (![#intT] "j"))) in
      (![#funcT] "cmp") "$a0" "$a1") #(W64 0))); (λ: <>, #()) := λ: <>,
        do:  ("j" <-[#intT] ((![#intT] "j") - #(W64 1))));;;
      (if: int_gt (![#intT] "i") (![#intT] "j")
      then break: #()
      else do:  #());;;
      let: "$r0" := (!["E"] (slice.elem_ref "E" (![#sliceT] "data") (![#intT] "j"))) in
      let: "$r1" := (!["E"] (slice.elem_ref "E" (![#sliceT] "data") (![#intT] "i"))) in
      do:  ((slice.elem_ref "E" (![#sliceT] "data") (![#intT] "i")) <-["E"] "$r0");;;
      do:  ((slice.elem_ref "E" (![#sliceT] "data") (![#intT] "j")) <-["E"] "$r1");;;
      do:  ("i" <-[#intT] ((![#intT] "i") + #(W64 1)));;;
      do:  ("j" <-[#intT] ((![#intT] "j") - #(W64 1))));;;
    return: (![#intT] "i")).

(* partialInsertionSortCmpFunc partially sorts a slice, returns true if the slice is sorted at the end.

   go: zsortanyfunc.go:195:6 *)
Definition partialInsertionSortCmpFuncⁱᵐᵖˡ : val :=
  λ: "E" "data" "a" "b" "cmp",
    exception_do (let: "cmp" := (mem.alloc "cmp") in
    let: "b" := (mem.alloc "b") in
    let: "a" := (mem.alloc "a") in
    let: "data" := (mem.alloc "data") in
    let maxSteps := 5 in
    let shortestShifting := 50 in
    let: "i" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := ((![#intT] "a") + #(W64 1)) in
    do:  ("i" <-[#intT] "$r0");;;
    (let: "j" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := #(W64 0) in
    do:  ("j" <-[#intT] "$r0");;;
    (for: (λ: <>, int_lt (![#intT] "j") #(W64 maxSteps)); (λ: <>, do:  ("j" <-[#intT] ((![#intT] "j") + #(W64 1)))) := λ: <>,
      (for: (λ: <>, (int_lt (![#intT] "i") (![#intT] "b")) && (~ (int_lt (let: "$a0" := (!["E"] (slice.elem_ref "E" (![#sliceT] "data") (![#intT] "i"))) in
      let: "$a1" := (!["E"] (slice.elem_ref "E" (![#sliceT] "data") ((![#intT] "i") - #(W64 1)))) in
      (![#funcT] "cmp") "$a0" "$a1") #(W64 0)))); (λ: <>, #()) := λ: <>,
        do:  ("i" <-[#intT] ((![#intT] "i") + #(W64 1))));;;
      (if: (![#intT] "i") = (![#intT] "b")
      then return: (#true)
      else do:  #());;;
      (if: int_lt ((![#intT] "b") - (![#intT] "a")) #(W64 shortestShifting)
      then return: (#false)
      else do:  #());;;
      let: "$r0" := (!["E"] (slice.elem_ref "E" (![#sliceT] "data") ((![#intT] "i") - #(W64 1)))) in
      let: "$r1" := (!["E"] (slice.elem_ref "E" (![#sliceT] "data") (![#intT] "i"))) in
      do:  ((slice.elem_ref "E" (![#sliceT] "data") (![#intT] "i")) <-["E"] "$r0");;;
      do:  ((slice.elem_ref "E" (![#sliceT] "data") ((![#intT] "i") - #(W64 1))) <-["E"] "$r1");;;
      (if: int_geq ((![#intT] "i") - (![#intT] "a")) #(W64 2)
      then
        (let: "j" := (mem.alloc (type.zero_val #intT)) in
        let: "$r0" := ((![#intT] "i") - #(W64 1)) in
        do:  ("j" <-[#intT] "$r0");;;
        (for: (λ: <>, int_geq (![#intT] "j") #(W64 1)); (λ: <>, do:  ("j" <-[#intT] ((![#intT] "j") - #(W64 1)))) := λ: <>,
          (if: (~ (int_lt (let: "$a0" := (!["E"] (slice.elem_ref "E" (![#sliceT] "data") (![#intT] "j"))) in
          let: "$a1" := (!["E"] (slice.elem_ref "E" (![#sliceT] "data") ((![#intT] "j") - #(W64 1)))) in
          (![#funcT] "cmp") "$a0" "$a1") #(W64 0)))
          then break: #()
          else do:  #());;;
          let: "$r0" := (!["E"] (slice.elem_ref "E" (![#sliceT] "data") ((![#intT] "j") - #(W64 1)))) in
          let: "$r1" := (!["E"] (slice.elem_ref "E" (![#sliceT] "data") (![#intT] "j"))) in
          do:  ((slice.elem_ref "E" (![#sliceT] "data") (![#intT] "j")) <-["E"] "$r0");;;
          do:  ((slice.elem_ref "E" (![#sliceT] "data") ((![#intT] "j") - #(W64 1))) <-["E"] "$r1")))
      else do:  #());;;
      (if: int_geq ((![#intT] "b") - (![#intT] "i")) #(W64 2)
      then
        (let: "j" := (mem.alloc (type.zero_val #intT)) in
        let: "$r0" := ((![#intT] "i") + #(W64 1)) in
        do:  ("j" <-[#intT] "$r0");;;
        (for: (λ: <>, int_lt (![#intT] "j") (![#intT] "b")); (λ: <>, do:  ("j" <-[#intT] ((![#intT] "j") + #(W64 1)))) := λ: <>,
          (if: (~ (int_lt (let: "$a0" := (!["E"] (slice.elem_ref "E" (![#sliceT] "data") (![#intT] "j"))) in
          let: "$a1" := (!["E"] (slice.elem_ref "E" (![#sliceT] "data") ((![#intT] "j") - #(W64 1)))) in
          (![#funcT] "cmp") "$a0" "$a1") #(W64 0)))
          then break: #()
          else do:  #());;;
          let: "$r0" := (!["E"] (slice.elem_ref "E" (![#sliceT] "data") ((![#intT] "j") - #(W64 1)))) in
          let: "$r1" := (!["E"] (slice.elem_ref "E" (![#sliceT] "data") (![#intT] "j"))) in
          do:  ((slice.elem_ref "E" (![#sliceT] "data") (![#intT] "j")) <-["E"] "$r0");;;
          do:  ((slice.elem_ref "E" (![#sliceT] "data") ((![#intT] "j") - #(W64 1))) <-["E"] "$r1")))
      else do:  #())));;;
    return: (#false)).

(* breakPatternsCmpFunc scatters some elements around in an attempt to break some patterns
   that might cause imbalanced partitions in quicksort.

   go: zsortanyfunc.go:240:6 *)
Definition breakPatternsCmpFuncⁱᵐᵖˡ : val :=
  λ: "E" "data" "a" "b" "cmp",
    exception_do (let: "cmp" := (mem.alloc "cmp") in
    let: "b" := (mem.alloc "b") in
    let: "a" := (mem.alloc "a") in
    let: "data" := (mem.alloc "data") in
    let: "length" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := ((![#intT] "b") - (![#intT] "a")) in
    do:  ("length" <-[#intT] "$r0");;;
    (if: int_geq (![#intT] "length") #(W64 8)
    then
      let: "random" := (mem.alloc (type.zero_val #xorshift)) in
      let: "$r0" := (s_to_w64 (![#intT] "length")) in
      do:  ("random" <-[#xorshift] "$r0");;;
      let: "modulus" := (mem.alloc (type.zero_val #uintT)) in
      let: "$r0" := (let: "$a0" := (![#intT] "length") in
      (func_call #nextPowerOfTwo) "$a0") in
      do:  ("modulus" <-[#uintT] "$r0");;;
      (let: "idx" := (mem.alloc (type.zero_val #intT)) in
      let: "$r0" := (((![#intT] "a") + (((![#intT] "length") `quots` #(W64 4)) * #(W64 2))) - #(W64 1)) in
      do:  ("idx" <-[#intT] "$r0");;;
      (for: (λ: <>, int_leq (![#intT] "idx") (((![#intT] "a") + (((![#intT] "length") `quots` #(W64 4)) * #(W64 2))) + #(W64 1))); (λ: <>, do:  ("idx" <-[#intT] ((![#intT] "idx") + #(W64 1)))) := λ: <>,
        let: "other" := (mem.alloc (type.zero_val #intT)) in
        let: "$r0" := (u_to_w64 ((u_to_w64 ((method_call #(ptrT.id xorshift.id) #"Next"%go "random") #())) `and` ((![#uintT] "modulus") - #(W64 1)))) in
        do:  ("other" <-[#intT] "$r0");;;
        (if: int_geq (![#intT] "other") (![#intT] "length")
        then do:  ("other" <-[#intT] ((![#intT] "other") - (![#intT] "length")))
        else do:  #());;;
        let: "$r0" := (!["E"] (slice.elem_ref "E" (![#sliceT] "data") ((![#intT] "a") + (![#intT] "other")))) in
        let: "$r1" := (!["E"] (slice.elem_ref "E" (![#sliceT] "data") (![#intT] "idx"))) in
        do:  ((slice.elem_ref "E" (![#sliceT] "data") (![#intT] "idx")) <-["E"] "$r0");;;
        do:  ((slice.elem_ref "E" (![#sliceT] "data") ((![#intT] "a") + (![#intT] "other"))) <-["E"] "$r1")))
    else do:  #());;;
    return: #()).

Definition medianCmpFunc : go_string := "slices.medianCmpFunc"%go.

Definition medianAdjacentCmpFunc : go_string := "slices.medianAdjacentCmpFunc"%go.

(* choosePivotCmpFunc chooses a pivot in data[a:b].

   [0,8): chooses a static pivot.
   [8,shortestNinther): uses the simple median-of-three method.
   [shortestNinther,∞): uses the Tukey ninther method.

   go: zsortanyfunc.go:261:6 *)
Definition choosePivotCmpFuncⁱᵐᵖˡ : val :=
  λ: "E" "data" "a" "b" "cmp",
    exception_do (let: "hint" := (mem.alloc (type.zero_val #sortedHint)) in
    let: "pivot" := (mem.alloc (type.zero_val #intT)) in
    let: "cmp" := (mem.alloc "cmp") in
    let: "b" := (mem.alloc "b") in
    let: "a" := (mem.alloc "a") in
    let: "data" := (mem.alloc "data") in
    let shortestNinther := 50 in
    let maxSwaps := 12 in
    let: "l" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := ((![#intT] "b") - (![#intT] "a")) in
    do:  ("l" <-[#intT] "$r0");;;
    let: "k" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := ((![#intT] "a") + (((![#intT] "l") `quots` #(W64 4)) * #(W64 3))) in
    do:  ("k" <-[#intT] "$r0");;;
    let: "j" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := ((![#intT] "a") + (((![#intT] "l") `quots` #(W64 4)) * #(W64 2))) in
    do:  ("j" <-[#intT] "$r0");;;
    let: "i" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := ((![#intT] "a") + (((![#intT] "l") `quots` #(W64 4)) * #(W64 1))) in
    do:  ("i" <-[#intT] "$r0");;;
    let: "swaps" := (mem.alloc (type.zero_val #intT)) in
    (if: int_geq (![#intT] "l") #(W64 8)
    then
      (if: int_geq (![#intT] "l") #(W64 shortestNinther)
      then
        let: "$r0" := (let: "$a0" := (![#sliceT] "data") in
        let: "$a1" := (![#intT] "i") in
        let: "$a2" := "swaps" in
        let: "$a3" := (![#funcT] "cmp") in
        ((func_call #medianAdjacentCmpFunc) "E") "$a0" "$a1" "$a2" "$a3") in
        do:  ("i" <-[#intT] "$r0");;;
        let: "$r0" := (let: "$a0" := (![#sliceT] "data") in
        let: "$a1" := (![#intT] "j") in
        let: "$a2" := "swaps" in
        let: "$a3" := (![#funcT] "cmp") in
        ((func_call #medianAdjacentCmpFunc) "E") "$a0" "$a1" "$a2" "$a3") in
        do:  ("j" <-[#intT] "$r0");;;
        let: "$r0" := (let: "$a0" := (![#sliceT] "data") in
        let: "$a1" := (![#intT] "k") in
        let: "$a2" := "swaps" in
        let: "$a3" := (![#funcT] "cmp") in
        ((func_call #medianAdjacentCmpFunc) "E") "$a0" "$a1" "$a2" "$a3") in
        do:  ("k" <-[#intT] "$r0")
      else do:  #());;;
      let: "$r0" := (let: "$a0" := (![#sliceT] "data") in
      let: "$a1" := (![#intT] "i") in
      let: "$a2" := (![#intT] "j") in
      let: "$a3" := (![#intT] "k") in
      let: "$a4" := "swaps" in
      let: "$a5" := (![#funcT] "cmp") in
      ((func_call #medianCmpFunc) "E") "$a0" "$a1" "$a2" "$a3" "$a4" "$a5") in
      do:  ("j" <-[#intT] "$r0")
    else do:  #());;;
    let: "$sw" := (![#intT] "swaps") in
    (if: "$sw" = #(W64 0)
    then return: (![#intT] "j", increasingHint)
    else
      (if: "$sw" = #(W64 maxSwaps)
      then return: (![#intT] "j", decreasingHint)
      else return: (![#intT] "j", unknownHint)))).

Definition order2CmpFunc : go_string := "slices.order2CmpFunc"%go.

(* order2CmpFunc returns x,y where data[x] <= data[y], where x,y=a,b or x,y=b,a.

   go: zsortanyfunc.go:298:6 *)
Definition order2CmpFuncⁱᵐᵖˡ : val :=
  λ: "E" "data" "a" "b" "swaps" "cmp",
    exception_do (let: "cmp" := (mem.alloc "cmp") in
    let: "swaps" := (mem.alloc "swaps") in
    let: "b" := (mem.alloc "b") in
    let: "a" := (mem.alloc "a") in
    let: "data" := (mem.alloc "data") in
    (if: int_lt (let: "$a0" := (!["E"] (slice.elem_ref "E" (![#sliceT] "data") (![#intT] "b"))) in
    let: "$a1" := (!["E"] (slice.elem_ref "E" (![#sliceT] "data") (![#intT] "a"))) in
    (![#funcT] "cmp") "$a0" "$a1") #(W64 0)
    then
      do:  ((![#ptrT] "swaps") <-[#intT] ((![#intT] (![#ptrT] "swaps")) + #(W64 1)));;;
      return: (![#intT] "b", ![#intT] "a")
    else do:  #());;;
    return: (![#intT] "a", ![#intT] "b")).

(* medianCmpFunc returns x where data[x] is the median of data[a],data[b],data[c], where x is a, b, or c.

   go: zsortanyfunc.go:307:6 *)
Definition medianCmpFuncⁱᵐᵖˡ : val :=
  λ: "E" "data" "a" "b" "c" "swaps" "cmp",
    exception_do (let: "cmp" := (mem.alloc "cmp") in
    let: "swaps" := (mem.alloc "swaps") in
    let: "c" := (mem.alloc "c") in
    let: "b" := (mem.alloc "b") in
    let: "a" := (mem.alloc "a") in
    let: "data" := (mem.alloc "data") in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "data") in
    let: "$a1" := (![#intT] "a") in
    let: "$a2" := (![#intT] "b") in
    let: "$a3" := (![#ptrT] "swaps") in
    let: "$a4" := (![#funcT] "cmp") in
    ((func_call #order2CmpFunc) "E") "$a0" "$a1" "$a2" "$a3" "$a4") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("a" <-[#intT] "$r0");;;
    do:  ("b" <-[#intT] "$r1");;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "data") in
    let: "$a1" := (![#intT] "b") in
    let: "$a2" := (![#intT] "c") in
    let: "$a3" := (![#ptrT] "swaps") in
    let: "$a4" := (![#funcT] "cmp") in
    ((func_call #order2CmpFunc) "E") "$a0" "$a1" "$a2" "$a3" "$a4") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("b" <-[#intT] "$r0");;;
    do:  ("c" <-[#intT] "$r1");;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "data") in
    let: "$a1" := (![#intT] "a") in
    let: "$a2" := (![#intT] "b") in
    let: "$a3" := (![#ptrT] "swaps") in
    let: "$a4" := (![#funcT] "cmp") in
    ((func_call #order2CmpFunc) "E") "$a0" "$a1" "$a2" "$a3" "$a4") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("a" <-[#intT] "$r0");;;
    do:  ("b" <-[#intT] "$r1");;;
    return: (![#intT] "b")).

(* medianAdjacentCmpFunc finds the median of data[a - 1], data[a], data[a + 1] and stores the index into a.

   go: zsortanyfunc.go:315:6 *)
Definition medianAdjacentCmpFuncⁱᵐᵖˡ : val :=
  λ: "E" "data" "a" "swaps" "cmp",
    exception_do (let: "cmp" := (mem.alloc "cmp") in
    let: "swaps" := (mem.alloc "swaps") in
    let: "a" := (mem.alloc "a") in
    let: "data" := (mem.alloc "data") in
    return: (let: "$a0" := (![#sliceT] "data") in
     let: "$a1" := ((![#intT] "a") - #(W64 1)) in
     let: "$a2" := (![#intT] "a") in
     let: "$a3" := ((![#intT] "a") + #(W64 1)) in
     let: "$a4" := (![#ptrT] "swaps") in
     let: "$a5" := (![#funcT] "cmp") in
     ((func_call #medianCmpFunc) "E") "$a0" "$a1" "$a2" "$a3" "$a4" "$a5")).

(* go: zsortanyfunc.go:319:6 *)
Definition reverseRangeCmpFuncⁱᵐᵖˡ : val :=
  λ: "E" "data" "a" "b" "cmp",
    exception_do (let: "cmp" := (mem.alloc "cmp") in
    let: "b" := (mem.alloc "b") in
    let: "a" := (mem.alloc "a") in
    let: "data" := (mem.alloc "data") in
    let: "i" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := (![#intT] "a") in
    do:  ("i" <-[#intT] "$r0");;;
    let: "j" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := ((![#intT] "b") - #(W64 1)) in
    do:  ("j" <-[#intT] "$r0");;;
    (for: (λ: <>, int_lt (![#intT] "i") (![#intT] "j")); (λ: <>, #()) := λ: <>,
      let: "$r0" := (!["E"] (slice.elem_ref "E" (![#sliceT] "data") (![#intT] "j"))) in
      let: "$r1" := (!["E"] (slice.elem_ref "E" (![#sliceT] "data") (![#intT] "i"))) in
      do:  ((slice.elem_ref "E" (![#sliceT] "data") (![#intT] "i")) <-["E"] "$r0");;;
      do:  ((slice.elem_ref "E" (![#sliceT] "data") (![#intT] "j")) <-["E"] "$r1");;;
      do:  ("i" <-[#intT] ((![#intT] "i") + #(W64 1)));;;
      do:  ("j" <-[#intT] ((![#intT] "j") - #(W64 1))));;;
    return: #()).

Definition swapRangeCmpFunc : go_string := "slices.swapRangeCmpFunc"%go.

(* go: zsortanyfunc.go:329:6 *)
Definition swapRangeCmpFuncⁱᵐᵖˡ : val :=
  λ: "E" "data" "a" "b" "n" "cmp",
    exception_do (let: "cmp" := (mem.alloc "cmp") in
    let: "n" := (mem.alloc "n") in
    let: "b" := (mem.alloc "b") in
    let: "a" := (mem.alloc "a") in
    let: "data" := (mem.alloc "data") in
    (let: "i" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[#intT] "$r0");;;
    (for: (λ: <>, int_lt (![#intT] "i") (![#intT] "n")); (λ: <>, do:  ("i" <-[#intT] ((![#intT] "i") + #(W64 1)))) := λ: <>,
      let: "$r0" := (!["E"] (slice.elem_ref "E" (![#sliceT] "data") ((![#intT] "b") + (![#intT] "i")))) in
      let: "$r1" := (!["E"] (slice.elem_ref "E" (![#sliceT] "data") ((![#intT] "a") + (![#intT] "i")))) in
      do:  ((slice.elem_ref "E" (![#sliceT] "data") ((![#intT] "a") + (![#intT] "i"))) <-["E"] "$r0");;;
      do:  ((slice.elem_ref "E" (![#sliceT] "data") ((![#intT] "b") + (![#intT] "i"))) <-["E"] "$r1")));;;
    return: #()).

Definition stableCmpFunc : go_string := "slices.stableCmpFunc"%go.

Definition symMergeCmpFunc : go_string := "slices.symMergeCmpFunc"%go.

(* go: zsortanyfunc.go:335:6 *)
Definition stableCmpFuncⁱᵐᵖˡ : val :=
  λ: "E" "data" "n" "cmp",
    exception_do (let: "cmp" := (mem.alloc "cmp") in
    let: "n" := (mem.alloc "n") in
    let: "data" := (mem.alloc "data") in
    let: "blockSize" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := #(W64 20) in
    do:  ("blockSize" <-[#intT] "$r0");;;
    let: "b" := (mem.alloc (type.zero_val #intT)) in
    let: "a" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := #(W64 0) in
    let: "$r1" := (![#intT] "blockSize") in
    do:  ("a" <-[#intT] "$r0");;;
    do:  ("b" <-[#intT] "$r1");;;
    (for: (λ: <>, int_leq (![#intT] "b") (![#intT] "n")); (λ: <>, #()) := λ: <>,
      do:  (let: "$a0" := (![#sliceT] "data") in
      let: "$a1" := (![#intT] "a") in
      let: "$a2" := (![#intT] "b") in
      let: "$a3" := (![#funcT] "cmp") in
      ((func_call #insertionSortCmpFunc) "E") "$a0" "$a1" "$a2" "$a3");;;
      let: "$r0" := (![#intT] "b") in
      do:  ("a" <-[#intT] "$r0");;;
      do:  ("b" <-[#intT] ((![#intT] "b") + (![#intT] "blockSize"))));;;
    do:  (let: "$a0" := (![#sliceT] "data") in
    let: "$a1" := (![#intT] "a") in
    let: "$a2" := (![#intT] "n") in
    let: "$a3" := (![#funcT] "cmp") in
    ((func_call #insertionSortCmpFunc) "E") "$a0" "$a1" "$a2" "$a3");;;
    (for: (λ: <>, int_lt (![#intT] "blockSize") (![#intT] "n")); (λ: <>, #()) := λ: <>,
      let: "$r0" := #(W64 0) in
      let: "$r1" := (#(W64 2) * (![#intT] "blockSize")) in
      do:  ("a" <-[#intT] "$r0");;;
      do:  ("b" <-[#intT] "$r1");;;
      (for: (λ: <>, int_leq (![#intT] "b") (![#intT] "n")); (λ: <>, #()) := λ: <>,
        do:  (let: "$a0" := (![#sliceT] "data") in
        let: "$a1" := (![#intT] "a") in
        let: "$a2" := ((![#intT] "a") + (![#intT] "blockSize")) in
        let: "$a3" := (![#intT] "b") in
        let: "$a4" := (![#funcT] "cmp") in
        ((func_call #symMergeCmpFunc) "E") "$a0" "$a1" "$a2" "$a3" "$a4");;;
        let: "$r0" := (![#intT] "b") in
        do:  ("a" <-[#intT] "$r0");;;
        do:  ("b" <-[#intT] ((![#intT] "b") + (#(W64 2) * (![#intT] "blockSize")))));;;
      (let: "m" := (mem.alloc (type.zero_val #intT)) in
      let: "$r0" := ((![#intT] "a") + (![#intT] "blockSize")) in
      do:  ("m" <-[#intT] "$r0");;;
      (if: int_lt (![#intT] "m") (![#intT] "n")
      then
        do:  (let: "$a0" := (![#sliceT] "data") in
        let: "$a1" := (![#intT] "a") in
        let: "$a2" := (![#intT] "m") in
        let: "$a3" := (![#intT] "n") in
        let: "$a4" := (![#funcT] "cmp") in
        ((func_call #symMergeCmpFunc) "E") "$a0" "$a1" "$a2" "$a3" "$a4")
      else do:  #()));;;
      do:  ("blockSize" <-[#intT] ((![#intT] "blockSize") * #(W64 2))));;;
    return: #()).

Definition rotateCmpFunc : go_string := "slices.rotateCmpFunc"%go.

(* symMergeCmpFunc merges the two sorted subsequences data[a:m] and data[m:b] using
   the SymMerge algorithm from Pok-Son Kim and Arne Kutzner, "Stable Minimum
   Storage Merging by Symmetric Comparisons", in Susanne Albers and Tomasz
   Radzik, editors, Algorithms - ESA 2004, volume 3221 of Lecture Notes in
   Computer Science, pages 714-723. Springer, 2004.

   Let M = m-a and N = b-n. Wolog M < N.
   The recursion depth is bound by ceil(log(N+M)).
   The algorithm needs O(M*log(N/M + 1)) calls to data.Less.
   The algorithm needs O((M+N)*log(M)) calls to data.Swap.

   The paper gives O((M+N)*log(M)) as the number of assignments assuming a
   rotation algorithm which uses O(M+N+gcd(M+N)) assignments. The argumentation
   in the paper carries through for Swap operations, especially as the block
   swapping rotate uses only O(M+N) Swaps.

   symMerge assumes non-degenerate arguments: a < m && m < b.
   Having the caller check this condition eliminates many leaf recursion calls,
   which improves performance.

   go: zsortanyfunc.go:378:6 *)
Definition symMergeCmpFuncⁱᵐᵖˡ : val :=
  λ: "E" "data" "a" "m" "b" "cmp",
    exception_do (let: "cmp" := (mem.alloc "cmp") in
    let: "b" := (mem.alloc "b") in
    let: "m" := (mem.alloc "m") in
    let: "a" := (mem.alloc "a") in
    let: "data" := (mem.alloc "data") in
    (if: ((![#intT] "m") - (![#intT] "a")) = #(W64 1)
    then
      let: "i" := (mem.alloc (type.zero_val #intT)) in
      let: "$r0" := (![#intT] "m") in
      do:  ("i" <-[#intT] "$r0");;;
      let: "j" := (mem.alloc (type.zero_val #intT)) in
      let: "$r0" := (![#intT] "b") in
      do:  ("j" <-[#intT] "$r0");;;
      (for: (λ: <>, int_lt (![#intT] "i") (![#intT] "j")); (λ: <>, #()) := λ: <>,
        let: "h" := (mem.alloc (type.zero_val #intT)) in
        let: "$r0" := (u_to_w64 ((s_to_w64 ((![#intT] "i") + (![#intT] "j"))) ≫ #(W64 1))) in
        do:  ("h" <-[#intT] "$r0");;;
        (if: int_lt (let: "$a0" := (!["E"] (slice.elem_ref "E" (![#sliceT] "data") (![#intT] "h"))) in
        let: "$a1" := (!["E"] (slice.elem_ref "E" (![#sliceT] "data") (![#intT] "a"))) in
        (![#funcT] "cmp") "$a0" "$a1") #(W64 0)
        then
          let: "$r0" := ((![#intT] "h") + #(W64 1)) in
          do:  ("i" <-[#intT] "$r0")
        else
          let: "$r0" := (![#intT] "h") in
          do:  ("j" <-[#intT] "$r0")));;;
      (let: "k" := (mem.alloc (type.zero_val #intT)) in
      let: "$r0" := (![#intT] "a") in
      do:  ("k" <-[#intT] "$r0");;;
      (for: (λ: <>, int_lt (![#intT] "k") ((![#intT] "i") - #(W64 1))); (λ: <>, do:  ("k" <-[#intT] ((![#intT] "k") + #(W64 1)))) := λ: <>,
        let: "$r0" := (!["E"] (slice.elem_ref "E" (![#sliceT] "data") ((![#intT] "k") + #(W64 1)))) in
        let: "$r1" := (!["E"] (slice.elem_ref "E" (![#sliceT] "data") (![#intT] "k"))) in
        do:  ((slice.elem_ref "E" (![#sliceT] "data") (![#intT] "k")) <-["E"] "$r0");;;
        do:  ((slice.elem_ref "E" (![#sliceT] "data") ((![#intT] "k") + #(W64 1))) <-["E"] "$r1")));;;
      return: (#())
    else do:  #());;;
    (if: ((![#intT] "b") - (![#intT] "m")) = #(W64 1)
    then
      let: "i" := (mem.alloc (type.zero_val #intT)) in
      let: "$r0" := (![#intT] "a") in
      do:  ("i" <-[#intT] "$r0");;;
      let: "j" := (mem.alloc (type.zero_val #intT)) in
      let: "$r0" := (![#intT] "m") in
      do:  ("j" <-[#intT] "$r0");;;
      (for: (λ: <>, int_lt (![#intT] "i") (![#intT] "j")); (λ: <>, #()) := λ: <>,
        let: "h" := (mem.alloc (type.zero_val #intT)) in
        let: "$r0" := (u_to_w64 ((s_to_w64 ((![#intT] "i") + (![#intT] "j"))) ≫ #(W64 1))) in
        do:  ("h" <-[#intT] "$r0");;;
        (if: (~ (int_lt (let: "$a0" := (!["E"] (slice.elem_ref "E" (![#sliceT] "data") (![#intT] "m"))) in
        let: "$a1" := (!["E"] (slice.elem_ref "E" (![#sliceT] "data") (![#intT] "h"))) in
        (![#funcT] "cmp") "$a0" "$a1") #(W64 0)))
        then
          let: "$r0" := ((![#intT] "h") + #(W64 1)) in
          do:  ("i" <-[#intT] "$r0")
        else
          let: "$r0" := (![#intT] "h") in
          do:  ("j" <-[#intT] "$r0")));;;
      (let: "k" := (mem.alloc (type.zero_val #intT)) in
      let: "$r0" := (![#intT] "m") in
      do:  ("k" <-[#intT] "$r0");;;
      (for: (λ: <>, int_gt (![#intT] "k") (![#intT] "i")); (λ: <>, do:  ("k" <-[#intT] ((![#intT] "k") - #(W64 1)))) := λ: <>,
        let: "$r0" := (!["E"] (slice.elem_ref "E" (![#sliceT] "data") ((![#intT] "k") - #(W64 1)))) in
        let: "$r1" := (!["E"] (slice.elem_ref "E" (![#sliceT] "data") (![#intT] "k"))) in
        do:  ((slice.elem_ref "E" (![#sliceT] "data") (![#intT] "k")) <-["E"] "$r0");;;
        do:  ((slice.elem_ref "E" (![#sliceT] "data") ((![#intT] "k") - #(W64 1))) <-["E"] "$r1")));;;
      return: (#())
    else do:  #());;;
    let: "mid" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := (u_to_w64 ((s_to_w64 ((![#intT] "a") + (![#intT] "b"))) ≫ #(W64 1))) in
    do:  ("mid" <-[#intT] "$r0");;;
    let: "n" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := ((![#intT] "mid") + (![#intT] "m")) in
    do:  ("n" <-[#intT] "$r0");;;
    let: "r" := (mem.alloc (type.zero_val #intT)) in
    let: "start" := (mem.alloc (type.zero_val #intT)) in
    (if: int_gt (![#intT] "m") (![#intT] "mid")
    then
      let: "$r0" := ((![#intT] "n") - (![#intT] "b")) in
      do:  ("start" <-[#intT] "$r0");;;
      let: "$r0" := (![#intT] "mid") in
      do:  ("r" <-[#intT] "$r0")
    else
      let: "$r0" := (![#intT] "a") in
      do:  ("start" <-[#intT] "$r0");;;
      let: "$r0" := (![#intT] "m") in
      do:  ("r" <-[#intT] "$r0"));;;
    let: "p" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := ((![#intT] "n") - #(W64 1)) in
    do:  ("p" <-[#intT] "$r0");;;
    (for: (λ: <>, int_lt (![#intT] "start") (![#intT] "r")); (λ: <>, #()) := λ: <>,
      let: "c" := (mem.alloc (type.zero_val #intT)) in
      let: "$r0" := (u_to_w64 ((s_to_w64 ((![#intT] "start") + (![#intT] "r"))) ≫ #(W64 1))) in
      do:  ("c" <-[#intT] "$r0");;;
      (if: (~ (int_lt (let: "$a0" := (!["E"] (slice.elem_ref "E" (![#sliceT] "data") ((![#intT] "p") - (![#intT] "c")))) in
      let: "$a1" := (!["E"] (slice.elem_ref "E" (![#sliceT] "data") (![#intT] "c"))) in
      (![#funcT] "cmp") "$a0" "$a1") #(W64 0)))
      then
        let: "$r0" := ((![#intT] "c") + #(W64 1)) in
        do:  ("start" <-[#intT] "$r0")
      else
        let: "$r0" := (![#intT] "c") in
        do:  ("r" <-[#intT] "$r0")));;;
    let: "end" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := ((![#intT] "n") - (![#intT] "start")) in
    do:  ("end" <-[#intT] "$r0");;;
    (if: (int_lt (![#intT] "start") (![#intT] "m")) && (int_lt (![#intT] "m") (![#intT] "end"))
    then
      do:  (let: "$a0" := (![#sliceT] "data") in
      let: "$a1" := (![#intT] "start") in
      let: "$a2" := (![#intT] "m") in
      let: "$a3" := (![#intT] "end") in
      let: "$a4" := (![#funcT] "cmp") in
      ((func_call #rotateCmpFunc) "E") "$a0" "$a1" "$a2" "$a3" "$a4")
    else do:  #());;;
    (if: (int_lt (![#intT] "a") (![#intT] "start")) && (int_lt (![#intT] "start") (![#intT] "mid"))
    then
      do:  (let: "$a0" := (![#sliceT] "data") in
      let: "$a1" := (![#intT] "a") in
      let: "$a2" := (![#intT] "start") in
      let: "$a3" := (![#intT] "mid") in
      let: "$a4" := (![#funcT] "cmp") in
      ((func_call #symMergeCmpFunc) "E") "$a0" "$a1" "$a2" "$a3" "$a4")
    else do:  #());;;
    (if: (int_lt (![#intT] "mid") (![#intT] "end")) && (int_lt (![#intT] "end") (![#intT] "b"))
    then
      do:  (let: "$a0" := (![#sliceT] "data") in
      let: "$a1" := (![#intT] "mid") in
      let: "$a2" := (![#intT] "end") in
      let: "$a3" := (![#intT] "b") in
      let: "$a4" := (![#funcT] "cmp") in
      ((func_call #symMergeCmpFunc) "E") "$a0" "$a1" "$a2" "$a3" "$a4")
    else do:  #());;;
    return: #()).

(* rotateCmpFunc rotates two consecutive blocks u = data[a:m] and v = data[m:b] in data:
   Data of the form 'x u v y' is changed to 'x v u y'.
   rotate performs at most b-a many calls to data.Swap,
   and it assumes non-degenerate arguments: a < m && m < b.

   go: zsortanyfunc.go:464:6 *)
Definition rotateCmpFuncⁱᵐᵖˡ : val :=
  λ: "E" "data" "a" "m" "b" "cmp",
    exception_do (let: "cmp" := (mem.alloc "cmp") in
    let: "b" := (mem.alloc "b") in
    let: "m" := (mem.alloc "m") in
    let: "a" := (mem.alloc "a") in
    let: "data" := (mem.alloc "data") in
    let: "i" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := ((![#intT] "m") - (![#intT] "a")) in
    do:  ("i" <-[#intT] "$r0");;;
    let: "j" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := ((![#intT] "b") - (![#intT] "m")) in
    do:  ("j" <-[#intT] "$r0");;;
    (for: (λ: <>, (![#intT] "i") ≠ (![#intT] "j")); (λ: <>, #()) := λ: <>,
      (if: int_gt (![#intT] "i") (![#intT] "j")
      then
        do:  (let: "$a0" := (![#sliceT] "data") in
        let: "$a1" := ((![#intT] "m") - (![#intT] "i")) in
        let: "$a2" := (![#intT] "m") in
        let: "$a3" := (![#intT] "j") in
        let: "$a4" := (![#funcT] "cmp") in
        ((func_call #swapRangeCmpFunc) "E") "$a0" "$a1" "$a2" "$a3" "$a4");;;
        do:  ("i" <-[#intT] ((![#intT] "i") - (![#intT] "j")))
      else
        do:  (let: "$a0" := (![#sliceT] "data") in
        let: "$a1" := ((![#intT] "m") - (![#intT] "i")) in
        let: "$a2" := (((![#intT] "m") + (![#intT] "j")) - (![#intT] "i")) in
        let: "$a3" := (![#intT] "i") in
        let: "$a4" := (![#funcT] "cmp") in
        ((func_call #swapRangeCmpFunc) "E") "$a0" "$a1" "$a2" "$a3" "$a4");;;
        do:  ("j" <-[#intT] ((![#intT] "j") - (![#intT] "i")))));;;
    do:  (let: "$a0" := (![#sliceT] "data") in
    let: "$a1" := ((![#intT] "m") - (![#intT] "i")) in
    let: "$a2" := (![#intT] "m") in
    let: "$a3" := (![#intT] "i") in
    let: "$a4" := (![#funcT] "cmp") in
    ((func_call #swapRangeCmpFunc) "E") "$a0" "$a1" "$a2" "$a3" "$a4");;;
    return: #()).

Definition insertionSortOrdered : go_string := "slices.insertionSortOrdered"%go.

Definition siftDownOrdered : go_string := "slices.siftDownOrdered"%go.

Definition heapSortOrdered : go_string := "slices.heapSortOrdered"%go.

Definition pdqsortOrdered : go_string := "slices.pdqsortOrdered"%go.

Definition partitionOrdered : go_string := "slices.partitionOrdered"%go.

Definition partitionEqualOrdered : go_string := "slices.partitionEqualOrdered"%go.

Definition partialInsertionSortOrdered : go_string := "slices.partialInsertionSortOrdered"%go.

Definition breakPatternsOrdered : go_string := "slices.breakPatternsOrdered"%go.

Definition choosePivotOrdered : go_string := "slices.choosePivotOrdered"%go.

Definition order2Ordered : go_string := "slices.order2Ordered"%go.

Definition medianOrdered : go_string := "slices.medianOrdered"%go.

Definition medianAdjacentOrdered : go_string := "slices.medianAdjacentOrdered"%go.

Definition reverseRangeOrdered : go_string := "slices.reverseRangeOrdered"%go.

Definition swapRangeOrdered : go_string := "slices.swapRangeOrdered"%go.

Definition stableOrdered : go_string := "slices.stableOrdered"%go.

Definition symMergeOrdered : go_string := "slices.symMergeOrdered"%go.

Definition rotateOrdered : go_string := "slices.rotateOrdered"%go.

Definition vars' : list (go_string * go_type) := [].

Axiom Allⁱᵐᵖˡ : val.

Axiom Backwardⁱᵐᵖˡ : val.

Axiom Valuesⁱᵐᵖˡ : val.

Axiom AppendSeqⁱᵐᵖˡ : val.

Axiom Collectⁱᵐᵖˡ : val.

Axiom Sortedⁱᵐᵖˡ : val.

Axiom SortedFuncⁱᵐᵖˡ : val.

Axiom SortedStableFuncⁱᵐᵖˡ : val.

Axiom Chunkⁱᵐᵖˡ : val.

Axiom Equalⁱᵐᵖˡ : val.

Axiom EqualFuncⁱᵐᵖˡ : val.

Axiom Compareⁱᵐᵖˡ : val.

Axiom CompareFuncⁱᵐᵖˡ : val.

Axiom Indexⁱᵐᵖˡ : val.

Axiom IndexFuncⁱᵐᵖˡ : val.

Axiom Containsⁱᵐᵖˡ : val.

Axiom ContainsFuncⁱᵐᵖˡ : val.

Axiom Insertⁱᵐᵖˡ : val.

Axiom Deleteⁱᵐᵖˡ : val.

Axiom DeleteFuncⁱᵐᵖˡ : val.

Axiom Replaceⁱᵐᵖˡ : val.

Axiom Cloneⁱᵐᵖˡ : val.

Axiom Compactⁱᵐᵖˡ : val.

Axiom CompactFuncⁱᵐᵖˡ : val.

Axiom Growⁱᵐᵖˡ : val.

Axiom Clipⁱᵐᵖˡ : val.

Axiom rotateLeftⁱᵐᵖˡ : val.

Axiom rotateRightⁱᵐᵖˡ : val.

Axiom overlapsⁱᵐᵖˡ : val.

Axiom startIdxⁱᵐᵖˡ : val.

Axiom Reverseⁱᵐᵖˡ : val.

Axiom Concatⁱᵐᵖˡ : val.

Axiom Repeatⁱᵐᵖˡ : val.

Axiom Sortⁱᵐᵖˡ : val.

Axiom SortFuncⁱᵐᵖˡ : val.

Axiom SortStableFuncⁱᵐᵖˡ : val.

Axiom IsSortedⁱᵐᵖˡ : val.

Axiom IsSortedFuncⁱᵐᵖˡ : val.

Axiom Minⁱᵐᵖˡ : val.

Axiom MinFuncⁱᵐᵖˡ : val.

Axiom Maxⁱᵐᵖˡ : val.

Axiom MaxFuncⁱᵐᵖˡ : val.

Axiom BinarySearchⁱᵐᵖˡ : val.

Axiom BinarySearchFuncⁱᵐᵖˡ : val.

Axiom nextPowerOfTwoⁱᵐᵖˡ : val.

Axiom isNaNⁱᵐᵖˡ : val.

Axiom insertionSortOrderedⁱᵐᵖˡ : val.

Axiom siftDownOrderedⁱᵐᵖˡ : val.

Axiom heapSortOrderedⁱᵐᵖˡ : val.

Axiom pdqsortOrderedⁱᵐᵖˡ : val.

Axiom partitionOrderedⁱᵐᵖˡ : val.

Axiom partitionEqualOrderedⁱᵐᵖˡ : val.

Axiom partialInsertionSortOrderedⁱᵐᵖˡ : val.

Axiom breakPatternsOrderedⁱᵐᵖˡ : val.

Axiom choosePivotOrderedⁱᵐᵖˡ : val.

Axiom order2Orderedⁱᵐᵖˡ : val.

Axiom medianOrderedⁱᵐᵖˡ : val.

Axiom medianAdjacentOrderedⁱᵐᵖˡ : val.

Axiom reverseRangeOrderedⁱᵐᵖˡ : val.

Axiom swapRangeOrderedⁱᵐᵖˡ : val.

Axiom stableOrderedⁱᵐᵖˡ : val.

Axiom symMergeOrderedⁱᵐᵖˡ : val.

Axiom rotateOrderedⁱᵐᵖˡ : val.

Definition functions' : list (go_string * val) := [(All, Allⁱᵐᵖˡ); (Backward, Backwardⁱᵐᵖˡ); (Values, Valuesⁱᵐᵖˡ); (AppendSeq, AppendSeqⁱᵐᵖˡ); (Collect, Collectⁱᵐᵖˡ); (Sorted, Sortedⁱᵐᵖˡ); (SortedFunc, SortedFuncⁱᵐᵖˡ); (SortedStableFunc, SortedStableFuncⁱᵐᵖˡ); (Chunk, Chunkⁱᵐᵖˡ); (Equal, Equalⁱᵐᵖˡ); (EqualFunc, EqualFuncⁱᵐᵖˡ); (Compare, Compareⁱᵐᵖˡ); (CompareFunc, CompareFuncⁱᵐᵖˡ); (Index, Indexⁱᵐᵖˡ); (IndexFunc, IndexFuncⁱᵐᵖˡ); (Contains, Containsⁱᵐᵖˡ); (ContainsFunc, ContainsFuncⁱᵐᵖˡ); (Insert, Insertⁱᵐᵖˡ); (Delete, Deleteⁱᵐᵖˡ); (DeleteFunc, DeleteFuncⁱᵐᵖˡ); (Replace, Replaceⁱᵐᵖˡ); (Clone, Cloneⁱᵐᵖˡ); (Compact, Compactⁱᵐᵖˡ); (CompactFunc, CompactFuncⁱᵐᵖˡ); (Grow, Growⁱᵐᵖˡ); (Clip, Clipⁱᵐᵖˡ); (rotateLeft, rotateLeftⁱᵐᵖˡ); (rotateRight, rotateRightⁱᵐᵖˡ); (overlaps, overlapsⁱᵐᵖˡ); (startIdx, startIdxⁱᵐᵖˡ); (Reverse, Reverseⁱᵐᵖˡ); (Concat, Concatⁱᵐᵖˡ); (Repeat, Repeatⁱᵐᵖˡ); (Sort, Sortⁱᵐᵖˡ); (SortFunc, SortFuncⁱᵐᵖˡ); (SortStableFunc, SortStableFuncⁱᵐᵖˡ); (IsSorted, IsSortedⁱᵐᵖˡ); (IsSortedFunc, IsSortedFuncⁱᵐᵖˡ); (Min, Minⁱᵐᵖˡ); (MinFunc, MinFuncⁱᵐᵖˡ); (Max, Maxⁱᵐᵖˡ); (MaxFunc, MaxFuncⁱᵐᵖˡ); (BinarySearch, BinarySearchⁱᵐᵖˡ); (BinarySearchFunc, BinarySearchFuncⁱᵐᵖˡ); (nextPowerOfTwo, nextPowerOfTwoⁱᵐᵖˡ); (isNaN, isNaNⁱᵐᵖˡ); (insertionSortCmpFunc, insertionSortCmpFuncⁱᵐᵖˡ); (siftDownCmpFunc, siftDownCmpFuncⁱᵐᵖˡ); (heapSortCmpFunc, heapSortCmpFuncⁱᵐᵖˡ); (pdqsortCmpFunc, pdqsortCmpFuncⁱᵐᵖˡ); (partitionCmpFunc, partitionCmpFuncⁱᵐᵖˡ); (partitionEqualCmpFunc, partitionEqualCmpFuncⁱᵐᵖˡ); (partialInsertionSortCmpFunc, partialInsertionSortCmpFuncⁱᵐᵖˡ); (breakPatternsCmpFunc, breakPatternsCmpFuncⁱᵐᵖˡ); (choosePivotCmpFunc, choosePivotCmpFuncⁱᵐᵖˡ); (order2CmpFunc, order2CmpFuncⁱᵐᵖˡ); (medianCmpFunc, medianCmpFuncⁱᵐᵖˡ); (medianAdjacentCmpFunc, medianAdjacentCmpFuncⁱᵐᵖˡ); (reverseRangeCmpFunc, reverseRangeCmpFuncⁱᵐᵖˡ); (swapRangeCmpFunc, swapRangeCmpFuncⁱᵐᵖˡ); (stableCmpFunc, stableCmpFuncⁱᵐᵖˡ); (symMergeCmpFunc, symMergeCmpFuncⁱᵐᵖˡ); (rotateCmpFunc, rotateCmpFuncⁱᵐᵖˡ); (insertionSortOrdered, insertionSortOrderedⁱᵐᵖˡ); (siftDownOrdered, siftDownOrderedⁱᵐᵖˡ); (heapSortOrdered, heapSortOrderedⁱᵐᵖˡ); (pdqsortOrdered, pdqsortOrderedⁱᵐᵖˡ); (partitionOrdered, partitionOrderedⁱᵐᵖˡ); (partitionEqualOrdered, partitionEqualOrderedⁱᵐᵖˡ); (partialInsertionSortOrdered, partialInsertionSortOrderedⁱᵐᵖˡ); (breakPatternsOrdered, breakPatternsOrderedⁱᵐᵖˡ); (choosePivotOrdered, choosePivotOrderedⁱᵐᵖˡ); (order2Ordered, order2Orderedⁱᵐᵖˡ); (medianOrdered, medianOrderedⁱᵐᵖˡ); (medianAdjacentOrdered, medianAdjacentOrderedⁱᵐᵖˡ); (reverseRangeOrdered, reverseRangeOrderedⁱᵐᵖˡ); (swapRangeOrdered, swapRangeOrderedⁱᵐᵖˡ); (stableOrdered, stableOrderedⁱᵐᵖˡ); (symMergeOrdered, symMergeOrderedⁱᵐᵖˡ); (rotateOrdered, rotateOrderedⁱᵐᵖˡ)].

Definition msets' : list (go_string * (list (go_string * val))) := [(sortedHint.id, []); (ptrT.id sortedHint.id, []); (xorshift.id, []); (ptrT.id xorshift.id, [("Next"%go, xorshift__Nextⁱᵐᵖˡ)])].

#[global] Instance info' : PkgInfo slices.slices :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [];
  |}.

Axiom _'init : val.

Definition initialize' : val :=
  λ: <>,
    package.init #slices.slices (λ: <>,
      exception_do (do:  (package.alloc slices.slices #()))
      ).

End code.
End slices.
