(* autogenerated from slices *)
From New.golang Require Import defn.
Module pkg_id.
Definition slices : go_string := "slices".

End pkg_id.
Export pkg_id.
Module slices.

Definition sortedHint {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "slices.sortedHint"%go [].

Definition xorshift {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "slices.xorshift"%go [].

Axiom unknownHint : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom increasingHint : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom decreasingHint : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition All {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.All"%go.

Definition Backward {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.Backward"%go.

Definition Values {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.Values"%go.

Definition AppendSeq {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.AppendSeq"%go.

Definition Collect {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.Collect"%go.

Definition Sorted {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.Sorted"%go.

Definition SortedFunc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.SortedFunc"%go.

Definition SortedStableFunc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.SortedStableFunc"%go.

Definition Chunk {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.Chunk"%go.

Definition Equal {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.Equal"%go.

Definition EqualFunc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.EqualFunc"%go.

Definition Compare {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.Compare"%go.

Definition CompareFunc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.CompareFunc"%go.

Definition Index {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.Index"%go.

Definition IndexFunc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.IndexFunc"%go.

Definition Contains {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.Contains"%go.

Definition ContainsFunc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.ContainsFunc"%go.

Definition Insert {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.Insert"%go.

Definition Delete {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.Delete"%go.

Definition DeleteFunc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.DeleteFunc"%go.

Definition Replace {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.Replace"%go.

Definition Clone {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.Clone"%go.

Definition Compact {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.Compact"%go.

Definition CompactFunc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.CompactFunc"%go.

Definition Grow {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.Grow"%go.

Definition Clip {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.Clip"%go.

Definition rotateLeft {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.rotateLeft"%go.

Definition rotateRight {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.rotateRight"%go.

Definition overlaps {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.overlaps"%go.

Definition startIdx {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.startIdx"%go.

Definition Reverse {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.Reverse"%go.

Definition Concat {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.Concat"%go.

Definition Repeat {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.Repeat"%go.

Definition Sort {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.Sort"%go.

Definition SortFunc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.SortFunc"%go.

Definition SortStableFunc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.SortStableFunc"%go.

Definition IsSorted {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.IsSorted"%go.

Definition IsSortedFunc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.IsSortedFunc"%go.

Definition Min {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.Min"%go.

Definition MinFunc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.MinFunc"%go.

Definition Max {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.Max"%go.

Definition MaxFunc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.MaxFunc"%go.

Definition BinarySearch {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.BinarySearch"%go.

Definition BinarySearchFunc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.BinarySearchFunc"%go.

Definition nextPowerOfTwo {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.nextPowerOfTwo"%go.

Definition isNaN {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.isNaN"%go.

Definition insertionSortCmpFunc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.insertionSortCmpFunc"%go.

Definition siftDownCmpFunc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.siftDownCmpFunc"%go.

Definition heapSortCmpFunc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.heapSortCmpFunc"%go.

Definition pdqsortCmpFunc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.pdqsortCmpFunc"%go.

Definition partitionCmpFunc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.partitionCmpFunc"%go.

Definition partitionEqualCmpFunc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.partitionEqualCmpFunc"%go.

Definition partialInsertionSortCmpFunc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.partialInsertionSortCmpFunc"%go.

Definition breakPatternsCmpFunc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.breakPatternsCmpFunc"%go.

Definition choosePivotCmpFunc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.choosePivotCmpFunc"%go.

Definition order2CmpFunc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.order2CmpFunc"%go.

Definition medianCmpFunc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.medianCmpFunc"%go.

Definition medianAdjacentCmpFunc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.medianAdjacentCmpFunc"%go.

Definition reverseRangeCmpFunc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.reverseRangeCmpFunc"%go.

Definition swapRangeCmpFunc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.swapRangeCmpFunc"%go.

Definition stableCmpFunc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.stableCmpFunc"%go.

Definition symMergeCmpFunc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.symMergeCmpFunc"%go.

Definition rotateCmpFunc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.rotateCmpFunc"%go.

Definition insertionSortOrdered {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.insertionSortOrdered"%go.

Definition siftDownOrdered {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.siftDownOrdered"%go.

Definition heapSortOrdered {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.heapSortOrdered"%go.

Definition pdqsortOrdered {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.pdqsortOrdered"%go.

Definition partitionOrdered {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.partitionOrdered"%go.

Definition partitionEqualOrdered {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.partitionEqualOrdered"%go.

Definition partialInsertionSortOrdered {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.partialInsertionSortOrdered"%go.

Definition breakPatternsOrdered {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.breakPatternsOrdered"%go.

Definition choosePivotOrdered {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.choosePivotOrdered"%go.

Definition order2Ordered {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.order2Ordered"%go.

Definition medianOrdered {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.medianOrdered"%go.

Definition medianAdjacentOrdered {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.medianAdjacentOrdered"%go.

Definition reverseRangeOrdered {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.reverseRangeOrdered"%go.

Definition swapRangeOrdered {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.swapRangeOrdered"%go.

Definition stableOrdered {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.stableOrdered"%go.

Definition symMergeOrdered {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.symMergeOrdered"%go.

Definition rotateOrdered {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "slices.rotateOrdered"%go.

(* go: sort.go:181:20 *)
Definition xorshift__Nextⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "r" <>,
    exception_do (let: "r" := (GoAlloc (go.PointerType xorshift) "r") in
    do:  ((![go.PointerType xorshift] "r") <-[xorshift] ((![xorshift] (![go.PointerType xorshift] "r")) ^⟨go.uint64⟩ ((![xorshift] (![go.PointerType xorshift] "r")) <<⟨xorshift⟩ #(W64 13))));;;
    do:  ((![go.PointerType xorshift] "r") <-[xorshift] ((![xorshift] (![go.PointerType xorshift] "r")) ^⟨go.uint64⟩ ((![xorshift] (![go.PointerType xorshift] "r")) >>⟨xorshift⟩ #(W64 7))));;;
    do:  ((![go.PointerType xorshift] "r") <-[xorshift] ((![xorshift] (![go.PointerType xorshift] "r")) ^⟨go.uint64⟩ ((![xorshift] (![go.PointerType xorshift] "r")) <<⟨xorshift⟩ #(W64 17))));;;
    return: (![xorshift] (![go.PointerType xorshift] "r"))).

(* insertionSortCmpFunc sorts data[a:b] using insertion sort.

   go: zsortanyfunc.go:10:6 *)
Definition insertionSortCmpFuncⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} (E : go.type) : val :=
  λ: "data" "a" "b" "cmp",
    exception_do (let: "cmp" := (GoAlloc (go.FunctionType (go.Signature [E; E] false [go.int])) "cmp") in
    let: "b" := (GoAlloc go.int "b") in
    let: "a" := (GoAlloc go.int "a") in
    let: "data" := (GoAlloc (go.SliceType E) "data") in
    (let: "i" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := ((![go.int] "a") +⟨go.int⟩ #(W64 1)) in
    do:  ("i" <-[go.int] "$r0");;;
    (for: (λ: <>, (![go.int] "i") <⟨go.int⟩ (![go.int] "b")); (λ: <>, do:  ("i" <-[go.int] ((![go.int] "i") +⟨go.int⟩ #(W64 1)))) := λ: <>,
      (let: "j" := (GoAlloc go.int (GoZeroVal go.int #())) in
      let: "$r0" := (![go.int] "i") in
      do:  ("j" <-[go.int] "$r0");;;
      (for: (λ: <>, ((![go.int] "j") >⟨go.int⟩ (![go.int] "a")) && ((let: "$a0" := (![E] (IndexRef (go.SliceType E) (![go.SliceType E] "data", ![go.int] "j"))) in
      let: "$a1" := (![E] (IndexRef (go.SliceType E) (![go.SliceType E] "data", (![go.int] "j") -⟨go.int⟩ #(W64 1)))) in
      (![go.FunctionType (go.Signature [E; E] false [go.int])] "cmp") "$a0" "$a1") <⟨go.int⟩ #(W64 0))); (λ: <>, do:  ("j" <-[go.int] ((![go.int] "j") -⟨go.int⟩ #(W64 1)))) := λ: <>,
        let: "$r0" := (![E] (IndexRef (go.SliceType E) (![go.SliceType E] "data", (![go.int] "j") -⟨go.int⟩ #(W64 1)))) in
        let: "$r1" := (![E] (IndexRef (go.SliceType E) (![go.SliceType E] "data", ![go.int] "j"))) in
        do:  ((IndexRef (go.SliceType E) (![go.SliceType E] "data", ![go.int] "j")) <-[E] "$r0");;;
        do:  ((IndexRef (go.SliceType E) (![go.SliceType E] "data", (![go.int] "j") -⟨go.int⟩ #(W64 1))) <-[E] "$r1")))));;;
    return: #()).

(* siftDownCmpFunc implements the heap property on data[lo:hi].
   first is an offset into the array where the root of the heap lies.

   go: zsortanyfunc.go:20:6 *)
Definition siftDownCmpFuncⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} (E : go.type) : val :=
  λ: "data" "lo" "hi" "first" "cmp",
    exception_do (let: "cmp" := (GoAlloc (go.FunctionType (go.Signature [E; E] false [go.int])) "cmp") in
    let: "first" := (GoAlloc go.int "first") in
    let: "hi" := (GoAlloc go.int "hi") in
    let: "lo" := (GoAlloc go.int "lo") in
    let: "data" := (GoAlloc (go.SliceType E) "data") in
    let: "root" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := (![go.int] "lo") in
    do:  ("root" <-[go.int] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "child" := (GoAlloc go.int (GoZeroVal go.int #())) in
      let: "$r0" := ((#(W64 2) *⟨go.int⟩ (![go.int] "root")) +⟨go.int⟩ #(W64 1)) in
      do:  ("child" <-[go.int] "$r0");;;
      (if: (![go.int] "child") ≥⟨go.int⟩ (![go.int] "hi")
      then break: #()
      else do:  #());;;
      (if: (((![go.int] "child") +⟨go.int⟩ #(W64 1)) <⟨go.int⟩ (![go.int] "hi")) && ((let: "$a0" := (![E] (IndexRef (go.SliceType E) (![go.SliceType E] "data", (![go.int] "first") +⟨go.int⟩ (![go.int] "child")))) in
      let: "$a1" := (![E] (IndexRef (go.SliceType E) (![go.SliceType E] "data", ((![go.int] "first") +⟨go.int⟩ (![go.int] "child")) +⟨go.int⟩ #(W64 1)))) in
      (![go.FunctionType (go.Signature [E; E] false [go.int])] "cmp") "$a0" "$a1") <⟨go.int⟩ #(W64 0))
      then do:  ("child" <-[go.int] ((![go.int] "child") +⟨go.int⟩ #(W64 1)))
      else do:  #());;;
      (if: (~ ((let: "$a0" := (![E] (IndexRef (go.SliceType E) (![go.SliceType E] "data", (![go.int] "first") +⟨go.int⟩ (![go.int] "root")))) in
      let: "$a1" := (![E] (IndexRef (go.SliceType E) (![go.SliceType E] "data", (![go.int] "first") +⟨go.int⟩ (![go.int] "child")))) in
      (![go.FunctionType (go.Signature [E; E] false [go.int])] "cmp") "$a0" "$a1") <⟨go.int⟩ #(W64 0)))
      then return: (#())
      else do:  #());;;
      let: "$r0" := (![E] (IndexRef (go.SliceType E) (![go.SliceType E] "data", (![go.int] "first") +⟨go.int⟩ (![go.int] "child")))) in
      let: "$r1" := (![E] (IndexRef (go.SliceType E) (![go.SliceType E] "data", (![go.int] "first") +⟨go.int⟩ (![go.int] "root")))) in
      do:  ((IndexRef (go.SliceType E) (![go.SliceType E] "data", (![go.int] "first") +⟨go.int⟩ (![go.int] "root"))) <-[E] "$r0");;;
      do:  ((IndexRef (go.SliceType E) (![go.SliceType E] "data", (![go.int] "first") +⟨go.int⟩ (![go.int] "child"))) <-[E] "$r1");;;
      let: "$r0" := (![go.int] "child") in
      do:  ("root" <-[go.int] "$r0"));;;
    return: #()).

(* go: zsortanyfunc.go:38:6 *)
Definition heapSortCmpFuncⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} (E : go.type) : val :=
  λ: "data" "a" "b" "cmp",
    exception_do (let: "cmp" := (GoAlloc (go.FunctionType (go.Signature [E; E] false [go.int])) "cmp") in
    let: "b" := (GoAlloc go.int "b") in
    let: "a" := (GoAlloc go.int "a") in
    let: "data" := (GoAlloc (go.SliceType E) "data") in
    let: "first" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := (![go.int] "a") in
    do:  ("first" <-[go.int] "$r0");;;
    let: "lo" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := #(W64 0) in
    do:  ("lo" <-[go.int] "$r0");;;
    let: "hi" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := ((![go.int] "b") -⟨go.int⟩ (![go.int] "a")) in
    do:  ("hi" <-[go.int] "$r0");;;
    (let: "i" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := (((![go.int] "hi") -⟨go.int⟩ #(W64 1)) /⟨go.int⟩ #(W64 2)) in
    do:  ("i" <-[go.int] "$r0");;;
    (for: (λ: <>, (![go.int] "i") ≥⟨go.int⟩ #(W64 0)); (λ: <>, do:  ("i" <-[go.int] ((![go.int] "i") -⟨go.int⟩ #(W64 1)))) := λ: <>,
      do:  (let: "$a0" := (![go.SliceType E] "data") in
      let: "$a1" := (![go.int] "i") in
      let: "$a2" := (![go.int] "hi") in
      let: "$a3" := (![go.int] "first") in
      let: "$a4" := (![go.FunctionType (go.Signature [E; E] false [go.int])] "cmp") in
      (FuncResolve siftDownCmpFunc [E] #()) "$a0" "$a1" "$a2" "$a3" "$a4")));;;
    (let: "i" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := ((![go.int] "hi") -⟨go.int⟩ #(W64 1)) in
    do:  ("i" <-[go.int] "$r0");;;
    (for: (λ: <>, (![go.int] "i") ≥⟨go.int⟩ #(W64 0)); (λ: <>, do:  ("i" <-[go.int] ((![go.int] "i") -⟨go.int⟩ #(W64 1)))) := λ: <>,
      let: "$r0" := (![E] (IndexRef (go.SliceType E) (![go.SliceType E] "data", (![go.int] "first") +⟨go.int⟩ (![go.int] "i")))) in
      let: "$r1" := (![E] (IndexRef (go.SliceType E) (![go.SliceType E] "data", ![go.int] "first"))) in
      do:  ((IndexRef (go.SliceType E) (![go.SliceType E] "data", ![go.int] "first")) <-[E] "$r0");;;
      do:  ((IndexRef (go.SliceType E) (![go.SliceType E] "data", (![go.int] "first") +⟨go.int⟩ (![go.int] "i"))) <-[E] "$r1");;;
      do:  (let: "$a0" := (![go.SliceType E] "data") in
      let: "$a1" := (![go.int] "lo") in
      let: "$a2" := (![go.int] "i") in
      let: "$a3" := (![go.int] "first") in
      let: "$a4" := (![go.FunctionType (go.Signature [E; E] false [go.int])] "cmp") in
      (FuncResolve siftDownCmpFunc [E] #()) "$a0" "$a1" "$a2" "$a3" "$a4")));;;
    return: #()).

(* pdqsortCmpFunc sorts data[a:b].
   The algorithm based on pattern-defeating quicksort(pdqsort), but without the optimizations from BlockQuicksort.
   pdqsort paper: https://arxiv.org/pdf/2106.05123.pdf
   C++ implementation: https://github.com/orlp/pdqsort
   Rust implementation: https://docs.rs/pdqsort/latest/pdqsort/
   limit is the number of allowed bad (very unbalanced) pivots before falling back to heapsort.

   go: zsortanyfunc.go:61:6 *)
Definition pdqsortCmpFuncⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} (E : go.type) : val :=
  λ: "data" "a" "b" "limit" "cmp",
    exception_do (let: "cmp" := (GoAlloc (go.FunctionType (go.Signature [E; E] false [go.int])) "cmp") in
    let: "limit" := (GoAlloc go.int "limit") in
    let: "b" := (GoAlloc go.int "b") in
    let: "a" := (GoAlloc go.int "a") in
    let: "data" := (GoAlloc (go.SliceType E) "data") in
    let maxInsertion := 12 in
    let: "wasPartitioned" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #true in
    do:  ("wasPartitioned" <-[go.bool] "$r0");;;
    let: "wasBalanced" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #true in
    do:  ("wasBalanced" <-[go.bool] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "length" := (GoAlloc go.int (GoZeroVal go.int #())) in
      let: "$r0" := ((![go.int] "b") -⟨go.int⟩ (![go.int] "a")) in
      do:  ("length" <-[go.int] "$r0");;;
      (if: (![go.int] "length") ≤⟨go.int⟩ #(W64 maxInsertion)
      then
        do:  (let: "$a0" := (![go.SliceType E] "data") in
        let: "$a1" := (![go.int] "a") in
        let: "$a2" := (![go.int] "b") in
        let: "$a3" := (![go.FunctionType (go.Signature [E; E] false [go.int])] "cmp") in
        (FuncResolve insertionSortCmpFunc [E] #()) "$a0" "$a1" "$a2" "$a3");;;
        return: (#())
      else do:  #());;;
      (if: (![go.int] "limit") =⟨go.int⟩ #(W64 0)
      then
        do:  (let: "$a0" := (![go.SliceType E] "data") in
        let: "$a1" := (![go.int] "a") in
        let: "$a2" := (![go.int] "b") in
        let: "$a3" := (![go.FunctionType (go.Signature [E; E] false [go.int])] "cmp") in
        (FuncResolve heapSortCmpFunc [E] #()) "$a0" "$a1" "$a2" "$a3");;;
        return: (#())
      else do:  #());;;
      (if: (~ (![go.bool] "wasBalanced"))
      then
        do:  (let: "$a0" := (![go.SliceType E] "data") in
        let: "$a1" := (![go.int] "a") in
        let: "$a2" := (![go.int] "b") in
        let: "$a3" := (![go.FunctionType (go.Signature [E; E] false [go.int])] "cmp") in
        (FuncResolve breakPatternsCmpFunc [E] #()) "$a0" "$a1" "$a2" "$a3");;;
        do:  ("limit" <-[go.int] ((![go.int] "limit") -⟨go.int⟩ #(W64 1)))
      else do:  #());;;
      let: "hint" := (GoAlloc sortedHint (GoZeroVal sortedHint #())) in
      let: "pivot" := (GoAlloc go.int (GoZeroVal go.int #())) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType E] "data") in
      let: "$a1" := (![go.int] "a") in
      let: "$a2" := (![go.int] "b") in
      let: "$a3" := (![go.FunctionType (go.Signature [E; E] false [go.int])] "cmp") in
      (FuncResolve choosePivotCmpFunc [E] #()) "$a0" "$a1" "$a2" "$a3") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("pivot" <-[go.int] "$r0");;;
      do:  ("hint" <-[sortedHint] "$r1");;;
      (if: (![sortedHint] "hint") =⟨go.int⟩ decreasingHint
      then
        do:  (let: "$a0" := (![go.SliceType E] "data") in
        let: "$a1" := (![go.int] "a") in
        let: "$a2" := (![go.int] "b") in
        let: "$a3" := (![go.FunctionType (go.Signature [E; E] false [go.int])] "cmp") in
        (FuncResolve reverseRangeCmpFunc [E] #()) "$a0" "$a1" "$a2" "$a3");;;
        let: "$r0" := (((![go.int] "b") -⟨go.int⟩ #(W64 1)) -⟨go.int⟩ ((![go.int] "pivot") -⟨go.int⟩ (![go.int] "a"))) in
        do:  ("pivot" <-[go.int] "$r0");;;
        let: "$r0" := increasingHint in
        do:  ("hint" <-[sortedHint] "$r0")
      else do:  #());;;
      (if: ((![go.bool] "wasBalanced") && (![go.bool] "wasPartitioned")) && ((![sortedHint] "hint") =⟨go.int⟩ increasingHint)
      then
        (if: let: "$a0" := (![go.SliceType E] "data") in
        let: "$a1" := (![go.int] "a") in
        let: "$a2" := (![go.int] "b") in
        let: "$a3" := (![go.FunctionType (go.Signature [E; E] false [go.int])] "cmp") in
        (FuncResolve partialInsertionSortCmpFunc [E] #()) "$a0" "$a1" "$a2" "$a3"
        then return: (#())
        else do:  #())
      else do:  #());;;
      (if: ((![go.int] "a") >⟨go.int⟩ #(W64 0)) && (~ ((let: "$a0" := (![E] (IndexRef (go.SliceType E) (![go.SliceType E] "data", (![go.int] "a") -⟨go.int⟩ #(W64 1)))) in
      let: "$a1" := (![E] (IndexRef (go.SliceType E) (![go.SliceType E] "data", ![go.int] "pivot"))) in
      (![go.FunctionType (go.Signature [E; E] false [go.int])] "cmp") "$a0" "$a1") <⟨go.int⟩ #(W64 0)))
      then
        let: "mid" := (GoAlloc go.int (GoZeroVal go.int #())) in
        let: "$r0" := (let: "$a0" := (![go.SliceType E] "data") in
        let: "$a1" := (![go.int] "a") in
        let: "$a2" := (![go.int] "b") in
        let: "$a3" := (![go.int] "pivot") in
        let: "$a4" := (![go.FunctionType (go.Signature [E; E] false [go.int])] "cmp") in
        (FuncResolve partitionEqualCmpFunc [E] #()) "$a0" "$a1" "$a2" "$a3" "$a4") in
        do:  ("mid" <-[go.int] "$r0");;;
        let: "$r0" := (![go.int] "mid") in
        do:  ("a" <-[go.int] "$r0");;;
        continue: #()
      else do:  #());;;
      let: "alreadyPartitioned" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
      let: "mid" := (GoAlloc go.int (GoZeroVal go.int #())) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType E] "data") in
      let: "$a1" := (![go.int] "a") in
      let: "$a2" := (![go.int] "b") in
      let: "$a3" := (![go.int] "pivot") in
      let: "$a4" := (![go.FunctionType (go.Signature [E; E] false [go.int])] "cmp") in
      (FuncResolve partitionCmpFunc [E] #()) "$a0" "$a1" "$a2" "$a3" "$a4") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("mid" <-[go.int] "$r0");;;
      do:  ("alreadyPartitioned" <-[go.bool] "$r1");;;
      let: "$r0" := (![go.bool] "alreadyPartitioned") in
      do:  ("wasPartitioned" <-[go.bool] "$r0");;;
      let: "rightLen" := (GoAlloc go.int (GoZeroVal go.int #())) in
      let: "leftLen" := (GoAlloc go.int (GoZeroVal go.int #())) in
      let: "$r0" := ((![go.int] "mid") -⟨go.int⟩ (![go.int] "a")) in
      let: "$r1" := ((![go.int] "b") -⟨go.int⟩ (![go.int] "mid")) in
      do:  ("leftLen" <-[go.int] "$r0");;;
      do:  ("rightLen" <-[go.int] "$r1");;;
      let: "balanceThreshold" := (GoAlloc go.int (GoZeroVal go.int #())) in
      let: "$r0" := ((![go.int] "length") /⟨go.int⟩ #(W64 8)) in
      do:  ("balanceThreshold" <-[go.int] "$r0");;;
      (if: (![go.int] "leftLen") <⟨go.int⟩ (![go.int] "rightLen")
      then
        let: "$r0" := ((![go.int] "leftLen") ≥⟨go.int⟩ (![go.int] "balanceThreshold")) in
        do:  ("wasBalanced" <-[go.bool] "$r0");;;
        do:  (let: "$a0" := (![go.SliceType E] "data") in
        let: "$a1" := (![go.int] "a") in
        let: "$a2" := (![go.int] "mid") in
        let: "$a3" := (![go.int] "limit") in
        let: "$a4" := (![go.FunctionType (go.Signature [E; E] false [go.int])] "cmp") in
        (FuncResolve pdqsortCmpFunc [E] #()) "$a0" "$a1" "$a2" "$a3" "$a4");;;
        let: "$r0" := ((![go.int] "mid") +⟨go.int⟩ #(W64 1)) in
        do:  ("a" <-[go.int] "$r0")
      else
        let: "$r0" := ((![go.int] "rightLen") ≥⟨go.int⟩ (![go.int] "balanceThreshold")) in
        do:  ("wasBalanced" <-[go.bool] "$r0");;;
        do:  (let: "$a0" := (![go.SliceType E] "data") in
        let: "$a1" := ((![go.int] "mid") +⟨go.int⟩ #(W64 1)) in
        let: "$a2" := (![go.int] "b") in
        let: "$a3" := (![go.int] "limit") in
        let: "$a4" := (![go.FunctionType (go.Signature [E; E] false [go.int])] "cmp") in
        (FuncResolve pdqsortCmpFunc [E] #()) "$a0" "$a1" "$a2" "$a3" "$a4");;;
        let: "$r0" := (![go.int] "mid") in
        do:  ("b" <-[go.int] "$r0")));;;
    return: #()).

(* partitionCmpFunc does one quicksort partition.
   Let p = data[pivot]
   Moves elements in data[a:b] around, so that data[i]<p and data[j]>=p for i<newpivot and j>newpivot.
   On return, data[newpivot] = p

   go: zsortanyfunc.go:135:6 *)
Definition partitionCmpFuncⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} (E : go.type) : val :=
  λ: "data" "a" "b" "pivot" "cmp",
    exception_do (let: "alreadyPartitioned" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "newpivot" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "cmp" := (GoAlloc (go.FunctionType (go.Signature [E; E] false [go.int])) "cmp") in
    let: "pivot" := (GoAlloc go.int "pivot") in
    let: "b" := (GoAlloc go.int "b") in
    let: "a" := (GoAlloc go.int "a") in
    let: "data" := (GoAlloc (go.SliceType E) "data") in
    let: "$r0" := (![E] (IndexRef (go.SliceType E) (![go.SliceType E] "data", ![go.int] "pivot"))) in
    let: "$r1" := (![E] (IndexRef (go.SliceType E) (![go.SliceType E] "data", ![go.int] "a"))) in
    do:  ((IndexRef (go.SliceType E) (![go.SliceType E] "data", ![go.int] "a")) <-[E] "$r0");;;
    do:  ((IndexRef (go.SliceType E) (![go.SliceType E] "data", ![go.int] "pivot")) <-[E] "$r1");;;
    let: "j" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "i" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := ((![go.int] "a") +⟨go.int⟩ #(W64 1)) in
    let: "$r1" := ((![go.int] "b") -⟨go.int⟩ #(W64 1)) in
    do:  ("i" <-[go.int] "$r0");;;
    do:  ("j" <-[go.int] "$r1");;;
    (for: (λ: <>, ((![go.int] "i") ≤⟨go.int⟩ (![go.int] "j")) && ((let: "$a0" := (![E] (IndexRef (go.SliceType E) (![go.SliceType E] "data", ![go.int] "i"))) in
    let: "$a1" := (![E] (IndexRef (go.SliceType E) (![go.SliceType E] "data", ![go.int] "a"))) in
    (![go.FunctionType (go.Signature [E; E] false [go.int])] "cmp") "$a0" "$a1") <⟨go.int⟩ #(W64 0))); (λ: <>, #()) := λ: <>,
      do:  ("i" <-[go.int] ((![go.int] "i") +⟨go.int⟩ #(W64 1))));;;
    (for: (λ: <>, ((![go.int] "i") ≤⟨go.int⟩ (![go.int] "j")) && (~ ((let: "$a0" := (![E] (IndexRef (go.SliceType E) (![go.SliceType E] "data", ![go.int] "j"))) in
    let: "$a1" := (![E] (IndexRef (go.SliceType E) (![go.SliceType E] "data", ![go.int] "a"))) in
    (![go.FunctionType (go.Signature [E; E] false [go.int])] "cmp") "$a0" "$a1") <⟨go.int⟩ #(W64 0)))); (λ: <>, #()) := λ: <>,
      do:  ("j" <-[go.int] ((![go.int] "j") -⟨go.int⟩ #(W64 1))));;;
    (if: (![go.int] "i") >⟨go.int⟩ (![go.int] "j")
    then
      let: "$r0" := (![E] (IndexRef (go.SliceType E) (![go.SliceType E] "data", ![go.int] "a"))) in
      let: "$r1" := (![E] (IndexRef (go.SliceType E) (![go.SliceType E] "data", ![go.int] "j"))) in
      do:  ((IndexRef (go.SliceType E) (![go.SliceType E] "data", ![go.int] "j")) <-[E] "$r0");;;
      do:  ((IndexRef (go.SliceType E) (![go.SliceType E] "data", ![go.int] "a")) <-[E] "$r1");;;
      return: (![go.int] "j", #true)
    else do:  #());;;
    let: "$r0" := (![E] (IndexRef (go.SliceType E) (![go.SliceType E] "data", ![go.int] "j"))) in
    let: "$r1" := (![E] (IndexRef (go.SliceType E) (![go.SliceType E] "data", ![go.int] "i"))) in
    do:  ((IndexRef (go.SliceType E) (![go.SliceType E] "data", ![go.int] "i")) <-[E] "$r0");;;
    do:  ((IndexRef (go.SliceType E) (![go.SliceType E] "data", ![go.int] "j")) <-[E] "$r1");;;
    do:  ("i" <-[go.int] ((![go.int] "i") +⟨go.int⟩ #(W64 1)));;;
    do:  ("j" <-[go.int] ((![go.int] "j") -⟨go.int⟩ #(W64 1)));;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (for: (λ: <>, ((![go.int] "i") ≤⟨go.int⟩ (![go.int] "j")) && ((let: "$a0" := (![E] (IndexRef (go.SliceType E) (![go.SliceType E] "data", ![go.int] "i"))) in
      let: "$a1" := (![E] (IndexRef (go.SliceType E) (![go.SliceType E] "data", ![go.int] "a"))) in
      (![go.FunctionType (go.Signature [E; E] false [go.int])] "cmp") "$a0" "$a1") <⟨go.int⟩ #(W64 0))); (λ: <>, #()) := λ: <>,
        do:  ("i" <-[go.int] ((![go.int] "i") +⟨go.int⟩ #(W64 1))));;;
      (for: (λ: <>, ((![go.int] "i") ≤⟨go.int⟩ (![go.int] "j")) && (~ ((let: "$a0" := (![E] (IndexRef (go.SliceType E) (![go.SliceType E] "data", ![go.int] "j"))) in
      let: "$a1" := (![E] (IndexRef (go.SliceType E) (![go.SliceType E] "data", ![go.int] "a"))) in
      (![go.FunctionType (go.Signature [E; E] false [go.int])] "cmp") "$a0" "$a1") <⟨go.int⟩ #(W64 0)))); (λ: <>, #()) := λ: <>,
        do:  ("j" <-[go.int] ((![go.int] "j") -⟨go.int⟩ #(W64 1))));;;
      (if: (![go.int] "i") >⟨go.int⟩ (![go.int] "j")
      then break: #()
      else do:  #());;;
      let: "$r0" := (![E] (IndexRef (go.SliceType E) (![go.SliceType E] "data", ![go.int] "j"))) in
      let: "$r1" := (![E] (IndexRef (go.SliceType E) (![go.SliceType E] "data", ![go.int] "i"))) in
      do:  ((IndexRef (go.SliceType E) (![go.SliceType E] "data", ![go.int] "i")) <-[E] "$r0");;;
      do:  ((IndexRef (go.SliceType E) (![go.SliceType E] "data", ![go.int] "j")) <-[E] "$r1");;;
      do:  ("i" <-[go.int] ((![go.int] "i") +⟨go.int⟩ #(W64 1)));;;
      do:  ("j" <-[go.int] ((![go.int] "j") -⟨go.int⟩ #(W64 1))));;;
    let: "$r0" := (![E] (IndexRef (go.SliceType E) (![go.SliceType E] "data", ![go.int] "a"))) in
    let: "$r1" := (![E] (IndexRef (go.SliceType E) (![go.SliceType E] "data", ![go.int] "j"))) in
    do:  ((IndexRef (go.SliceType E) (![go.SliceType E] "data", ![go.int] "j")) <-[E] "$r0");;;
    do:  ((IndexRef (go.SliceType E) (![go.SliceType E] "data", ![go.int] "a")) <-[E] "$r1");;;
    return: (![go.int] "j", #false)).

(* partitionEqualCmpFunc partitions data[a:b] into elements equal to data[pivot] followed by elements greater than data[pivot].
   It assumed that data[a:b] does not contain elements smaller than the data[pivot].

   go: zsortanyfunc.go:173:6 *)
Definition partitionEqualCmpFuncⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} (E : go.type) : val :=
  λ: "data" "a" "b" "pivot" "cmp",
    exception_do (let: "newpivot" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "cmp" := (GoAlloc (go.FunctionType (go.Signature [E; E] false [go.int])) "cmp") in
    let: "pivot" := (GoAlloc go.int "pivot") in
    let: "b" := (GoAlloc go.int "b") in
    let: "a" := (GoAlloc go.int "a") in
    let: "data" := (GoAlloc (go.SliceType E) "data") in
    let: "$r0" := (![E] (IndexRef (go.SliceType E) (![go.SliceType E] "data", ![go.int] "pivot"))) in
    let: "$r1" := (![E] (IndexRef (go.SliceType E) (![go.SliceType E] "data", ![go.int] "a"))) in
    do:  ((IndexRef (go.SliceType E) (![go.SliceType E] "data", ![go.int] "a")) <-[E] "$r0");;;
    do:  ((IndexRef (go.SliceType E) (![go.SliceType E] "data", ![go.int] "pivot")) <-[E] "$r1");;;
    let: "j" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "i" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := ((![go.int] "a") +⟨go.int⟩ #(W64 1)) in
    let: "$r1" := ((![go.int] "b") -⟨go.int⟩ #(W64 1)) in
    do:  ("i" <-[go.int] "$r0");;;
    do:  ("j" <-[go.int] "$r1");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (for: (λ: <>, ((![go.int] "i") ≤⟨go.int⟩ (![go.int] "j")) && (~ ((let: "$a0" := (![E] (IndexRef (go.SliceType E) (![go.SliceType E] "data", ![go.int] "a"))) in
      let: "$a1" := (![E] (IndexRef (go.SliceType E) (![go.SliceType E] "data", ![go.int] "i"))) in
      (![go.FunctionType (go.Signature [E; E] false [go.int])] "cmp") "$a0" "$a1") <⟨go.int⟩ #(W64 0)))); (λ: <>, #()) := λ: <>,
        do:  ("i" <-[go.int] ((![go.int] "i") +⟨go.int⟩ #(W64 1))));;;
      (for: (λ: <>, ((![go.int] "i") ≤⟨go.int⟩ (![go.int] "j")) && ((let: "$a0" := (![E] (IndexRef (go.SliceType E) (![go.SliceType E] "data", ![go.int] "a"))) in
      let: "$a1" := (![E] (IndexRef (go.SliceType E) (![go.SliceType E] "data", ![go.int] "j"))) in
      (![go.FunctionType (go.Signature [E; E] false [go.int])] "cmp") "$a0" "$a1") <⟨go.int⟩ #(W64 0))); (λ: <>, #()) := λ: <>,
        do:  ("j" <-[go.int] ((![go.int] "j") -⟨go.int⟩ #(W64 1))));;;
      (if: (![go.int] "i") >⟨go.int⟩ (![go.int] "j")
      then break: #()
      else do:  #());;;
      let: "$r0" := (![E] (IndexRef (go.SliceType E) (![go.SliceType E] "data", ![go.int] "j"))) in
      let: "$r1" := (![E] (IndexRef (go.SliceType E) (![go.SliceType E] "data", ![go.int] "i"))) in
      do:  ((IndexRef (go.SliceType E) (![go.SliceType E] "data", ![go.int] "i")) <-[E] "$r0");;;
      do:  ((IndexRef (go.SliceType E) (![go.SliceType E] "data", ![go.int] "j")) <-[E] "$r1");;;
      do:  ("i" <-[go.int] ((![go.int] "i") +⟨go.int⟩ #(W64 1)));;;
      do:  ("j" <-[go.int] ((![go.int] "j") -⟨go.int⟩ #(W64 1))));;;
    return: (![go.int] "i")).

(* partialInsertionSortCmpFunc partially sorts a slice, returns true if the slice is sorted at the end.

   go: zsortanyfunc.go:195:6 *)
Definition partialInsertionSortCmpFuncⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} (E : go.type) : val :=
  λ: "data" "a" "b" "cmp",
    exception_do (let: "cmp" := (GoAlloc (go.FunctionType (go.Signature [E; E] false [go.int])) "cmp") in
    let: "b" := (GoAlloc go.int "b") in
    let: "a" := (GoAlloc go.int "a") in
    let: "data" := (GoAlloc (go.SliceType E) "data") in
    let maxSteps := 5 in
    let shortestShifting := 50 in
    let: "i" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := ((![go.int] "a") +⟨go.int⟩ #(W64 1)) in
    do:  ("i" <-[go.int] "$r0");;;
    (let: "j" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := #(W64 0) in
    do:  ("j" <-[go.int] "$r0");;;
    (for: (λ: <>, (![go.int] "j") <⟨go.int⟩ #(W64 maxSteps)); (λ: <>, do:  ("j" <-[go.int] ((![go.int] "j") +⟨go.int⟩ #(W64 1)))) := λ: <>,
      (for: (λ: <>, ((![go.int] "i") <⟨go.int⟩ (![go.int] "b")) && (~ ((let: "$a0" := (![E] (IndexRef (go.SliceType E) (![go.SliceType E] "data", ![go.int] "i"))) in
      let: "$a1" := (![E] (IndexRef (go.SliceType E) (![go.SliceType E] "data", (![go.int] "i") -⟨go.int⟩ #(W64 1)))) in
      (![go.FunctionType (go.Signature [E; E] false [go.int])] "cmp") "$a0" "$a1") <⟨go.int⟩ #(W64 0)))); (λ: <>, #()) := λ: <>,
        do:  ("i" <-[go.int] ((![go.int] "i") +⟨go.int⟩ #(W64 1))));;;
      (if: (![go.int] "i") =⟨go.int⟩ (![go.int] "b")
      then return: (#true)
      else do:  #());;;
      (if: ((![go.int] "b") -⟨go.int⟩ (![go.int] "a")) <⟨go.int⟩ #(W64 shortestShifting)
      then return: (#false)
      else do:  #());;;
      let: "$r0" := (![E] (IndexRef (go.SliceType E) (![go.SliceType E] "data", (![go.int] "i") -⟨go.int⟩ #(W64 1)))) in
      let: "$r1" := (![E] (IndexRef (go.SliceType E) (![go.SliceType E] "data", ![go.int] "i"))) in
      do:  ((IndexRef (go.SliceType E) (![go.SliceType E] "data", ![go.int] "i")) <-[E] "$r0");;;
      do:  ((IndexRef (go.SliceType E) (![go.SliceType E] "data", (![go.int] "i") -⟨go.int⟩ #(W64 1))) <-[E] "$r1");;;
      (if: ((![go.int] "i") -⟨go.int⟩ (![go.int] "a")) ≥⟨go.int⟩ #(W64 2)
      then
        (let: "j" := (GoAlloc go.int (GoZeroVal go.int #())) in
        let: "$r0" := ((![go.int] "i") -⟨go.int⟩ #(W64 1)) in
        do:  ("j" <-[go.int] "$r0");;;
        (for: (λ: <>, (![go.int] "j") ≥⟨go.int⟩ #(W64 1)); (λ: <>, do:  ("j" <-[go.int] ((![go.int] "j") -⟨go.int⟩ #(W64 1)))) := λ: <>,
          (if: (~ ((let: "$a0" := (![E] (IndexRef (go.SliceType E) (![go.SliceType E] "data", ![go.int] "j"))) in
          let: "$a1" := (![E] (IndexRef (go.SliceType E) (![go.SliceType E] "data", (![go.int] "j") -⟨go.int⟩ #(W64 1)))) in
          (![go.FunctionType (go.Signature [E; E] false [go.int])] "cmp") "$a0" "$a1") <⟨go.int⟩ #(W64 0)))
          then break: #()
          else do:  #());;;
          let: "$r0" := (![E] (IndexRef (go.SliceType E) (![go.SliceType E] "data", (![go.int] "j") -⟨go.int⟩ #(W64 1)))) in
          let: "$r1" := (![E] (IndexRef (go.SliceType E) (![go.SliceType E] "data", ![go.int] "j"))) in
          do:  ((IndexRef (go.SliceType E) (![go.SliceType E] "data", ![go.int] "j")) <-[E] "$r0");;;
          do:  ((IndexRef (go.SliceType E) (![go.SliceType E] "data", (![go.int] "j") -⟨go.int⟩ #(W64 1))) <-[E] "$r1")))
      else do:  #());;;
      (if: ((![go.int] "b") -⟨go.int⟩ (![go.int] "i")) ≥⟨go.int⟩ #(W64 2)
      then
        (let: "j" := (GoAlloc go.int (GoZeroVal go.int #())) in
        let: "$r0" := ((![go.int] "i") +⟨go.int⟩ #(W64 1)) in
        do:  ("j" <-[go.int] "$r0");;;
        (for: (λ: <>, (![go.int] "j") <⟨go.int⟩ (![go.int] "b")); (λ: <>, do:  ("j" <-[go.int] ((![go.int] "j") +⟨go.int⟩ #(W64 1)))) := λ: <>,
          (if: (~ ((let: "$a0" := (![E] (IndexRef (go.SliceType E) (![go.SliceType E] "data", ![go.int] "j"))) in
          let: "$a1" := (![E] (IndexRef (go.SliceType E) (![go.SliceType E] "data", (![go.int] "j") -⟨go.int⟩ #(W64 1)))) in
          (![go.FunctionType (go.Signature [E; E] false [go.int])] "cmp") "$a0" "$a1") <⟨go.int⟩ #(W64 0)))
          then break: #()
          else do:  #());;;
          let: "$r0" := (![E] (IndexRef (go.SliceType E) (![go.SliceType E] "data", (![go.int] "j") -⟨go.int⟩ #(W64 1)))) in
          let: "$r1" := (![E] (IndexRef (go.SliceType E) (![go.SliceType E] "data", ![go.int] "j"))) in
          do:  ((IndexRef (go.SliceType E) (![go.SliceType E] "data", ![go.int] "j")) <-[E] "$r0");;;
          do:  ((IndexRef (go.SliceType E) (![go.SliceType E] "data", (![go.int] "j") -⟨go.int⟩ #(W64 1))) <-[E] "$r1")))
      else do:  #())));;;
    return: (#false)).

(* breakPatternsCmpFunc scatters some elements around in an attempt to break some patterns
   that might cause imbalanced partitions in quicksort.

   go: zsortanyfunc.go:240:6 *)
Definition breakPatternsCmpFuncⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} (E : go.type) : val :=
  λ: "data" "a" "b" "cmp",
    exception_do (let: "cmp" := (GoAlloc (go.FunctionType (go.Signature [E; E] false [go.int])) "cmp") in
    let: "b" := (GoAlloc go.int "b") in
    let: "a" := (GoAlloc go.int "a") in
    let: "data" := (GoAlloc (go.SliceType E) "data") in
    let: "length" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := ((![go.int] "b") -⟨go.int⟩ (![go.int] "a")) in
    do:  ("length" <-[go.int] "$r0");;;
    (if: (![go.int] "length") ≥⟨go.int⟩ #(W64 8)
    then
      let: "random" := (GoAlloc xorshift (GoZeroVal xorshift #())) in
      let: "$r0" := (s_to_w64 (![go.int] "length")) in
      do:  ("random" <-[xorshift] "$r0");;;
      let: "modulus" := (GoAlloc go.uint (GoZeroVal go.uint #())) in
      let: "$r0" := (let: "$a0" := (![go.int] "length") in
      (FuncResolve nextPowerOfTwo [] #()) "$a0") in
      do:  ("modulus" <-[go.uint] "$r0");;;
      (let: "idx" := (GoAlloc go.int (GoZeroVal go.int #())) in
      let: "$r0" := (((![go.int] "a") +⟨go.int⟩ (((![go.int] "length") /⟨go.int⟩ #(W64 4)) *⟨go.int⟩ #(W64 2))) -⟨go.int⟩ #(W64 1)) in
      do:  ("idx" <-[go.int] "$r0");;;
      (for: (λ: <>, (![go.int] "idx") ≤⟨go.int⟩ (((![go.int] "a") +⟨go.int⟩ (((![go.int] "length") /⟨go.int⟩ #(W64 4)) *⟨go.int⟩ #(W64 2))) +⟨go.int⟩ #(W64 1))); (λ: <>, do:  ("idx" <-[go.int] ((![go.int] "idx") +⟨go.int⟩ #(W64 1)))) := λ: <>,
        let: "other" := (GoAlloc go.int (GoZeroVal go.int #())) in
        let: "$r0" := (u_to_w64 ((u_to_w64 ((MethodResolve (go.PointerType xorshift) "Next"%go #() "random") #())) &⟨go.uint⟩ ((![go.uint] "modulus") -⟨go.uint⟩ #(W64 1)))) in
        do:  ("other" <-[go.int] "$r0");;;
        (if: (![go.int] "other") ≥⟨go.int⟩ (![go.int] "length")
        then do:  ("other" <-[go.int] ((![go.int] "other") -⟨go.int⟩ (![go.int] "length")))
        else do:  #());;;
        let: "$r0" := (![E] (IndexRef (go.SliceType E) (![go.SliceType E] "data", (![go.int] "a") +⟨go.int⟩ (![go.int] "other")))) in
        let: "$r1" := (![E] (IndexRef (go.SliceType E) (![go.SliceType E] "data", ![go.int] "idx"))) in
        do:  ((IndexRef (go.SliceType E) (![go.SliceType E] "data", ![go.int] "idx")) <-[E] "$r0");;;
        do:  ((IndexRef (go.SliceType E) (![go.SliceType E] "data", (![go.int] "a") +⟨go.int⟩ (![go.int] "other"))) <-[E] "$r1")))
    else do:  #());;;
    return: #()).

(* choosePivotCmpFunc chooses a pivot in data[a:b].

   [0,8): chooses a static pivot.
   [8,shortestNinther): uses the simple median-of-three method.
   [shortestNinther,∞): uses the Tukey ninther method.

   go: zsortanyfunc.go:261:6 *)
Definition choosePivotCmpFuncⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} (E : go.type) : val :=
  λ: "data" "a" "b" "cmp",
    exception_do (let: "hint" := (GoAlloc sortedHint (GoZeroVal sortedHint #())) in
    let: "pivot" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "cmp" := (GoAlloc (go.FunctionType (go.Signature [E; E] false [go.int])) "cmp") in
    let: "b" := (GoAlloc go.int "b") in
    let: "a" := (GoAlloc go.int "a") in
    let: "data" := (GoAlloc (go.SliceType E) "data") in
    let shortestNinther := 50 in
    let maxSwaps := 12 in
    let: "l" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := ((![go.int] "b") -⟨go.int⟩ (![go.int] "a")) in
    do:  ("l" <-[go.int] "$r0");;;
    let: "k" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := ((![go.int] "a") +⟨go.int⟩ (((![go.int] "l") /⟨go.int⟩ #(W64 4)) *⟨go.int⟩ #(W64 3))) in
    do:  ("k" <-[go.int] "$r0");;;
    let: "j" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := ((![go.int] "a") +⟨go.int⟩ (((![go.int] "l") /⟨go.int⟩ #(W64 4)) *⟨go.int⟩ #(W64 2))) in
    do:  ("j" <-[go.int] "$r0");;;
    let: "i" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := ((![go.int] "a") +⟨go.int⟩ (((![go.int] "l") /⟨go.int⟩ #(W64 4)) *⟨go.int⟩ #(W64 1))) in
    do:  ("i" <-[go.int] "$r0");;;
    let: "swaps" := (GoAlloc go.int (GoZeroVal go.int #())) in
    (if: (![go.int] "l") ≥⟨go.int⟩ #(W64 8)
    then
      (if: (![go.int] "l") ≥⟨go.int⟩ #(W64 shortestNinther)
      then
        let: "$r0" := (let: "$a0" := (![go.SliceType E] "data") in
        let: "$a1" := (![go.int] "i") in
        let: "$a2" := "swaps" in
        let: "$a3" := (![go.FunctionType (go.Signature [E; E] false [go.int])] "cmp") in
        (FuncResolve medianAdjacentCmpFunc [E] #()) "$a0" "$a1" "$a2" "$a3") in
        do:  ("i" <-[go.int] "$r0");;;
        let: "$r0" := (let: "$a0" := (![go.SliceType E] "data") in
        let: "$a1" := (![go.int] "j") in
        let: "$a2" := "swaps" in
        let: "$a3" := (![go.FunctionType (go.Signature [E; E] false [go.int])] "cmp") in
        (FuncResolve medianAdjacentCmpFunc [E] #()) "$a0" "$a1" "$a2" "$a3") in
        do:  ("j" <-[go.int] "$r0");;;
        let: "$r0" := (let: "$a0" := (![go.SliceType E] "data") in
        let: "$a1" := (![go.int] "k") in
        let: "$a2" := "swaps" in
        let: "$a3" := (![go.FunctionType (go.Signature [E; E] false [go.int])] "cmp") in
        (FuncResolve medianAdjacentCmpFunc [E] #()) "$a0" "$a1" "$a2" "$a3") in
        do:  ("k" <-[go.int] "$r0")
      else do:  #());;;
      let: "$r0" := (let: "$a0" := (![go.SliceType E] "data") in
      let: "$a1" := (![go.int] "i") in
      let: "$a2" := (![go.int] "j") in
      let: "$a3" := (![go.int] "k") in
      let: "$a4" := "swaps" in
      let: "$a5" := (![go.FunctionType (go.Signature [E; E] false [go.int])] "cmp") in
      (FuncResolve medianCmpFunc [E] #()) "$a0" "$a1" "$a2" "$a3" "$a4" "$a5") in
      do:  ("j" <-[go.int] "$r0")
    else do:  #());;;
    let: "$sw" := (![go.int] "swaps") in
    (if: "$sw" =⟨go.int⟩ #(W64 0)
    then return: (![go.int] "j", increasingHint)
    else
      (if: "$sw" =⟨go.int⟩ #(W64 maxSwaps)
      then return: (![go.int] "j", decreasingHint)
      else return: (![go.int] "j", unknownHint)))).

(* order2CmpFunc returns x,y where data[x] <= data[y], where x,y=a,b or x,y=b,a.

   go: zsortanyfunc.go:298:6 *)
Definition order2CmpFuncⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} (E : go.type) : val :=
  λ: "data" "a" "b" "swaps" "cmp",
    exception_do (let: "cmp" := (GoAlloc (go.FunctionType (go.Signature [E; E] false [go.int])) "cmp") in
    let: "swaps" := (GoAlloc (go.PointerType go.int) "swaps") in
    let: "b" := (GoAlloc go.int "b") in
    let: "a" := (GoAlloc go.int "a") in
    let: "data" := (GoAlloc (go.SliceType E) "data") in
    (if: (let: "$a0" := (![E] (IndexRef (go.SliceType E) (![go.SliceType E] "data", ![go.int] "b"))) in
    let: "$a1" := (![E] (IndexRef (go.SliceType E) (![go.SliceType E] "data", ![go.int] "a"))) in
    (![go.FunctionType (go.Signature [E; E] false [go.int])] "cmp") "$a0" "$a1") <⟨go.int⟩ #(W64 0)
    then
      do:  ((![go.PointerType go.int] "swaps") <-[go.int] ((![go.int] (![go.PointerType go.int] "swaps")) +⟨go.int⟩ #(W64 1)));;;
      return: (![go.int] "b", ![go.int] "a")
    else do:  #());;;
    return: (![go.int] "a", ![go.int] "b")).

(* medianCmpFunc returns x where data[x] is the median of data[a],data[b],data[c], where x is a, b, or c.

   go: zsortanyfunc.go:307:6 *)
Definition medianCmpFuncⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} (E : go.type) : val :=
  λ: "data" "a" "b" "c" "swaps" "cmp",
    exception_do (let: "cmp" := (GoAlloc (go.FunctionType (go.Signature [E; E] false [go.int])) "cmp") in
    let: "swaps" := (GoAlloc (go.PointerType go.int) "swaps") in
    let: "c" := (GoAlloc go.int "c") in
    let: "b" := (GoAlloc go.int "b") in
    let: "a" := (GoAlloc go.int "a") in
    let: "data" := (GoAlloc (go.SliceType E) "data") in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType E] "data") in
    let: "$a1" := (![go.int] "a") in
    let: "$a2" := (![go.int] "b") in
    let: "$a3" := (![go.PointerType go.int] "swaps") in
    let: "$a4" := (![go.FunctionType (go.Signature [E; E] false [go.int])] "cmp") in
    (FuncResolve order2CmpFunc [E] #()) "$a0" "$a1" "$a2" "$a3" "$a4") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("a" <-[go.int] "$r0");;;
    do:  ("b" <-[go.int] "$r1");;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType E] "data") in
    let: "$a1" := (![go.int] "b") in
    let: "$a2" := (![go.int] "c") in
    let: "$a3" := (![go.PointerType go.int] "swaps") in
    let: "$a4" := (![go.FunctionType (go.Signature [E; E] false [go.int])] "cmp") in
    (FuncResolve order2CmpFunc [E] #()) "$a0" "$a1" "$a2" "$a3" "$a4") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("b" <-[go.int] "$r0");;;
    do:  ("c" <-[go.int] "$r1");;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType E] "data") in
    let: "$a1" := (![go.int] "a") in
    let: "$a2" := (![go.int] "b") in
    let: "$a3" := (![go.PointerType go.int] "swaps") in
    let: "$a4" := (![go.FunctionType (go.Signature [E; E] false [go.int])] "cmp") in
    (FuncResolve order2CmpFunc [E] #()) "$a0" "$a1" "$a2" "$a3" "$a4") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("a" <-[go.int] "$r0");;;
    do:  ("b" <-[go.int] "$r1");;;
    return: (![go.int] "b")).

(* medianAdjacentCmpFunc finds the median of data[a - 1], data[a], data[a + 1] and stores the index into a.

   go: zsortanyfunc.go:315:6 *)
Definition medianAdjacentCmpFuncⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} (E : go.type) : val :=
  λ: "data" "a" "swaps" "cmp",
    exception_do (let: "cmp" := (GoAlloc (go.FunctionType (go.Signature [E; E] false [go.int])) "cmp") in
    let: "swaps" := (GoAlloc (go.PointerType go.int) "swaps") in
    let: "a" := (GoAlloc go.int "a") in
    let: "data" := (GoAlloc (go.SliceType E) "data") in
    return: (let: "$a0" := (![go.SliceType E] "data") in
     let: "$a1" := ((![go.int] "a") -⟨go.int⟩ #(W64 1)) in
     let: "$a2" := (![go.int] "a") in
     let: "$a3" := ((![go.int] "a") +⟨go.int⟩ #(W64 1)) in
     let: "$a4" := (![go.PointerType go.int] "swaps") in
     let: "$a5" := (![go.FunctionType (go.Signature [E; E] false [go.int])] "cmp") in
     (FuncResolve medianCmpFunc [E] #()) "$a0" "$a1" "$a2" "$a3" "$a4" "$a5")).

(* go: zsortanyfunc.go:319:6 *)
Definition reverseRangeCmpFuncⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} (E : go.type) : val :=
  λ: "data" "a" "b" "cmp",
    exception_do (let: "cmp" := (GoAlloc (go.FunctionType (go.Signature [E; E] false [go.int])) "cmp") in
    let: "b" := (GoAlloc go.int "b") in
    let: "a" := (GoAlloc go.int "a") in
    let: "data" := (GoAlloc (go.SliceType E) "data") in
    let: "i" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := (![go.int] "a") in
    do:  ("i" <-[go.int] "$r0");;;
    let: "j" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := ((![go.int] "b") -⟨go.int⟩ #(W64 1)) in
    do:  ("j" <-[go.int] "$r0");;;
    (for: (λ: <>, (![go.int] "i") <⟨go.int⟩ (![go.int] "j")); (λ: <>, #()) := λ: <>,
      let: "$r0" := (![E] (IndexRef (go.SliceType E) (![go.SliceType E] "data", ![go.int] "j"))) in
      let: "$r1" := (![E] (IndexRef (go.SliceType E) (![go.SliceType E] "data", ![go.int] "i"))) in
      do:  ((IndexRef (go.SliceType E) (![go.SliceType E] "data", ![go.int] "i")) <-[E] "$r0");;;
      do:  ((IndexRef (go.SliceType E) (![go.SliceType E] "data", ![go.int] "j")) <-[E] "$r1");;;
      do:  ("i" <-[go.int] ((![go.int] "i") +⟨go.int⟩ #(W64 1)));;;
      do:  ("j" <-[go.int] ((![go.int] "j") -⟨go.int⟩ #(W64 1))));;;
    return: #()).

(* go: zsortanyfunc.go:329:6 *)
Definition swapRangeCmpFuncⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} (E : go.type) : val :=
  λ: "data" "a" "b" "n" "cmp",
    exception_do (let: "cmp" := (GoAlloc (go.FunctionType (go.Signature [E; E] false [go.int])) "cmp") in
    let: "n" := (GoAlloc go.int "n") in
    let: "b" := (GoAlloc go.int "b") in
    let: "a" := (GoAlloc go.int "a") in
    let: "data" := (GoAlloc (go.SliceType E) "data") in
    (let: "i" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.int] "$r0");;;
    (for: (λ: <>, (![go.int] "i") <⟨go.int⟩ (![go.int] "n")); (λ: <>, do:  ("i" <-[go.int] ((![go.int] "i") +⟨go.int⟩ #(W64 1)))) := λ: <>,
      let: "$r0" := (![E] (IndexRef (go.SliceType E) (![go.SliceType E] "data", (![go.int] "b") +⟨go.int⟩ (![go.int] "i")))) in
      let: "$r1" := (![E] (IndexRef (go.SliceType E) (![go.SliceType E] "data", (![go.int] "a") +⟨go.int⟩ (![go.int] "i")))) in
      do:  ((IndexRef (go.SliceType E) (![go.SliceType E] "data", (![go.int] "a") +⟨go.int⟩ (![go.int] "i"))) <-[E] "$r0");;;
      do:  ((IndexRef (go.SliceType E) (![go.SliceType E] "data", (![go.int] "b") +⟨go.int⟩ (![go.int] "i"))) <-[E] "$r1")));;;
    return: #()).

(* go: zsortanyfunc.go:335:6 *)
Definition stableCmpFuncⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} (E : go.type) : val :=
  λ: "data" "n" "cmp",
    exception_do (let: "cmp" := (GoAlloc (go.FunctionType (go.Signature [E; E] false [go.int])) "cmp") in
    let: "n" := (GoAlloc go.int "n") in
    let: "data" := (GoAlloc (go.SliceType E) "data") in
    let: "blockSize" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := #(W64 20) in
    do:  ("blockSize" <-[go.int] "$r0");;;
    let: "b" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "a" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := #(W64 0) in
    let: "$r1" := (![go.int] "blockSize") in
    do:  ("a" <-[go.int] "$r0");;;
    do:  ("b" <-[go.int] "$r1");;;
    (for: (λ: <>, (![go.int] "b") ≤⟨go.int⟩ (![go.int] "n")); (λ: <>, #()) := λ: <>,
      do:  (let: "$a0" := (![go.SliceType E] "data") in
      let: "$a1" := (![go.int] "a") in
      let: "$a2" := (![go.int] "b") in
      let: "$a3" := (![go.FunctionType (go.Signature [E; E] false [go.int])] "cmp") in
      (FuncResolve insertionSortCmpFunc [E] #()) "$a0" "$a1" "$a2" "$a3");;;
      let: "$r0" := (![go.int] "b") in
      do:  ("a" <-[go.int] "$r0");;;
      do:  ("b" <-[go.int] ((![go.int] "b") +⟨go.int⟩ (![go.int] "blockSize"))));;;
    do:  (let: "$a0" := (![go.SliceType E] "data") in
    let: "$a1" := (![go.int] "a") in
    let: "$a2" := (![go.int] "n") in
    let: "$a3" := (![go.FunctionType (go.Signature [E; E] false [go.int])] "cmp") in
    (FuncResolve insertionSortCmpFunc [E] #()) "$a0" "$a1" "$a2" "$a3");;;
    (for: (λ: <>, (![go.int] "blockSize") <⟨go.int⟩ (![go.int] "n")); (λ: <>, #()) := λ: <>,
      let: "$r0" := #(W64 0) in
      let: "$r1" := (#(W64 2) *⟨go.int⟩ (![go.int] "blockSize")) in
      do:  ("a" <-[go.int] "$r0");;;
      do:  ("b" <-[go.int] "$r1");;;
      (for: (λ: <>, (![go.int] "b") ≤⟨go.int⟩ (![go.int] "n")); (λ: <>, #()) := λ: <>,
        do:  (let: "$a0" := (![go.SliceType E] "data") in
        let: "$a1" := (![go.int] "a") in
        let: "$a2" := ((![go.int] "a") +⟨go.int⟩ (![go.int] "blockSize")) in
        let: "$a3" := (![go.int] "b") in
        let: "$a4" := (![go.FunctionType (go.Signature [E; E] false [go.int])] "cmp") in
        (FuncResolve symMergeCmpFunc [E] #()) "$a0" "$a1" "$a2" "$a3" "$a4");;;
        let: "$r0" := (![go.int] "b") in
        do:  ("a" <-[go.int] "$r0");;;
        do:  ("b" <-[go.int] ((![go.int] "b") +⟨go.int⟩ (#(W64 2) *⟨go.int⟩ (![go.int] "blockSize")))));;;
      (let: "m" := (GoAlloc go.int (GoZeroVal go.int #())) in
      let: "$r0" := ((![go.int] "a") +⟨go.int⟩ (![go.int] "blockSize")) in
      do:  ("m" <-[go.int] "$r0");;;
      (if: (![go.int] "m") <⟨go.int⟩ (![go.int] "n")
      then
        do:  (let: "$a0" := (![go.SliceType E] "data") in
        let: "$a1" := (![go.int] "a") in
        let: "$a2" := (![go.int] "m") in
        let: "$a3" := (![go.int] "n") in
        let: "$a4" := (![go.FunctionType (go.Signature [E; E] false [go.int])] "cmp") in
        (FuncResolve symMergeCmpFunc [E] #()) "$a0" "$a1" "$a2" "$a3" "$a4")
      else do:  #()));;;
      do:  ("blockSize" <-[go.int] ((![go.int] "blockSize") *⟨go.int⟩ #(W64 2))));;;
    return: #()).

(* symMergeCmpFunc merges the two sorted subsequences data[a:m] and data[m:b] using
   the SymMerge algorithm from Pok-Son Kim and Arne Kutzner, "Stable Minimum
   Storage Merging by Symmetric Comparisons", in Susanne Albers and Tomasz
   Radzik, editors, Algorithms - ESA 2004, volume 3221 of Lecture Notes in
   Computer Science, pages 714-723. Springer, 2004.

   Let M = m-a and N = b-n. Wolog M < N.
   The recursion depth is bound by ceil(log(N+M)).
   The algorithm needs O(M*log(N/M + 1)) calls to data.Less.
   The algorithm needs O((M+N)*log(M)) calls to data.Swap.

   The paper gives O((M+N)*log(M)) as the number of assignments assuming a
   rotation algorithm which uses O(M+N+gcd(M+N)) assignments. The argumentation
   in the paper carries through for Swap operations, especially as the block
   swapping rotate uses only O(M+N) Swaps.

   symMerge assumes non-degenerate arguments: a < m && m < b.
   Having the caller check this condition eliminates many leaf recursion calls,
   which improves performance.

   go: zsortanyfunc.go:378:6 *)
Definition symMergeCmpFuncⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} (E : go.type) : val :=
  λ: "data" "a" "m" "b" "cmp",
    exception_do (let: "cmp" := (GoAlloc (go.FunctionType (go.Signature [E; E] false [go.int])) "cmp") in
    let: "b" := (GoAlloc go.int "b") in
    let: "m" := (GoAlloc go.int "m") in
    let: "a" := (GoAlloc go.int "a") in
    let: "data" := (GoAlloc (go.SliceType E) "data") in
    (if: ((![go.int] "m") -⟨go.int⟩ (![go.int] "a")) =⟨go.int⟩ #(W64 1)
    then
      let: "i" := (GoAlloc go.int (GoZeroVal go.int #())) in
      let: "$r0" := (![go.int] "m") in
      do:  ("i" <-[go.int] "$r0");;;
      let: "j" := (GoAlloc go.int (GoZeroVal go.int #())) in
      let: "$r0" := (![go.int] "b") in
      do:  ("j" <-[go.int] "$r0");;;
      (for: (λ: <>, (![go.int] "i") <⟨go.int⟩ (![go.int] "j")); (λ: <>, #()) := λ: <>,
        let: "h" := (GoAlloc go.int (GoZeroVal go.int #())) in
        let: "$r0" := (u_to_w64 ((s_to_w64 ((![go.int] "i") +⟨go.int⟩ (![go.int] "j"))) >>⟨go.uint⟩ #(W64 1))) in
        do:  ("h" <-[go.int] "$r0");;;
        (if: (let: "$a0" := (![E] (IndexRef (go.SliceType E) (![go.SliceType E] "data", ![go.int] "h"))) in
        let: "$a1" := (![E] (IndexRef (go.SliceType E) (![go.SliceType E] "data", ![go.int] "a"))) in
        (![go.FunctionType (go.Signature [E; E] false [go.int])] "cmp") "$a0" "$a1") <⟨go.int⟩ #(W64 0)
        then
          let: "$r0" := ((![go.int] "h") +⟨go.int⟩ #(W64 1)) in
          do:  ("i" <-[go.int] "$r0")
        else
          let: "$r0" := (![go.int] "h") in
          do:  ("j" <-[go.int] "$r0")));;;
      (let: "k" := (GoAlloc go.int (GoZeroVal go.int #())) in
      let: "$r0" := (![go.int] "a") in
      do:  ("k" <-[go.int] "$r0");;;
      (for: (λ: <>, (![go.int] "k") <⟨go.int⟩ ((![go.int] "i") -⟨go.int⟩ #(W64 1))); (λ: <>, do:  ("k" <-[go.int] ((![go.int] "k") +⟨go.int⟩ #(W64 1)))) := λ: <>,
        let: "$r0" := (![E] (IndexRef (go.SliceType E) (![go.SliceType E] "data", (![go.int] "k") +⟨go.int⟩ #(W64 1)))) in
        let: "$r1" := (![E] (IndexRef (go.SliceType E) (![go.SliceType E] "data", ![go.int] "k"))) in
        do:  ((IndexRef (go.SliceType E) (![go.SliceType E] "data", ![go.int] "k")) <-[E] "$r0");;;
        do:  ((IndexRef (go.SliceType E) (![go.SliceType E] "data", (![go.int] "k") +⟨go.int⟩ #(W64 1))) <-[E] "$r1")));;;
      return: (#())
    else do:  #());;;
    (if: ((![go.int] "b") -⟨go.int⟩ (![go.int] "m")) =⟨go.int⟩ #(W64 1)
    then
      let: "i" := (GoAlloc go.int (GoZeroVal go.int #())) in
      let: "$r0" := (![go.int] "a") in
      do:  ("i" <-[go.int] "$r0");;;
      let: "j" := (GoAlloc go.int (GoZeroVal go.int #())) in
      let: "$r0" := (![go.int] "m") in
      do:  ("j" <-[go.int] "$r0");;;
      (for: (λ: <>, (![go.int] "i") <⟨go.int⟩ (![go.int] "j")); (λ: <>, #()) := λ: <>,
        let: "h" := (GoAlloc go.int (GoZeroVal go.int #())) in
        let: "$r0" := (u_to_w64 ((s_to_w64 ((![go.int] "i") +⟨go.int⟩ (![go.int] "j"))) >>⟨go.uint⟩ #(W64 1))) in
        do:  ("h" <-[go.int] "$r0");;;
        (if: (~ ((let: "$a0" := (![E] (IndexRef (go.SliceType E) (![go.SliceType E] "data", ![go.int] "m"))) in
        let: "$a1" := (![E] (IndexRef (go.SliceType E) (![go.SliceType E] "data", ![go.int] "h"))) in
        (![go.FunctionType (go.Signature [E; E] false [go.int])] "cmp") "$a0" "$a1") <⟨go.int⟩ #(W64 0)))
        then
          let: "$r0" := ((![go.int] "h") +⟨go.int⟩ #(W64 1)) in
          do:  ("i" <-[go.int] "$r0")
        else
          let: "$r0" := (![go.int] "h") in
          do:  ("j" <-[go.int] "$r0")));;;
      (let: "k" := (GoAlloc go.int (GoZeroVal go.int #())) in
      let: "$r0" := (![go.int] "m") in
      do:  ("k" <-[go.int] "$r0");;;
      (for: (λ: <>, (![go.int] "k") >⟨go.int⟩ (![go.int] "i")); (λ: <>, do:  ("k" <-[go.int] ((![go.int] "k") -⟨go.int⟩ #(W64 1)))) := λ: <>,
        let: "$r0" := (![E] (IndexRef (go.SliceType E) (![go.SliceType E] "data", (![go.int] "k") -⟨go.int⟩ #(W64 1)))) in
        let: "$r1" := (![E] (IndexRef (go.SliceType E) (![go.SliceType E] "data", ![go.int] "k"))) in
        do:  ((IndexRef (go.SliceType E) (![go.SliceType E] "data", ![go.int] "k")) <-[E] "$r0");;;
        do:  ((IndexRef (go.SliceType E) (![go.SliceType E] "data", (![go.int] "k") -⟨go.int⟩ #(W64 1))) <-[E] "$r1")));;;
      return: (#())
    else do:  #());;;
    let: "mid" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := (u_to_w64 ((s_to_w64 ((![go.int] "a") +⟨go.int⟩ (![go.int] "b"))) >>⟨go.uint⟩ #(W64 1))) in
    do:  ("mid" <-[go.int] "$r0");;;
    let: "n" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := ((![go.int] "mid") +⟨go.int⟩ (![go.int] "m")) in
    do:  ("n" <-[go.int] "$r0");;;
    let: "r" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "start" := (GoAlloc go.int (GoZeroVal go.int #())) in
    (if: (![go.int] "m") >⟨go.int⟩ (![go.int] "mid")
    then
      let: "$r0" := ((![go.int] "n") -⟨go.int⟩ (![go.int] "b")) in
      do:  ("start" <-[go.int] "$r0");;;
      let: "$r0" := (![go.int] "mid") in
      do:  ("r" <-[go.int] "$r0")
    else
      let: "$r0" := (![go.int] "a") in
      do:  ("start" <-[go.int] "$r0");;;
      let: "$r0" := (![go.int] "m") in
      do:  ("r" <-[go.int] "$r0"));;;
    let: "p" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := ((![go.int] "n") -⟨go.int⟩ #(W64 1)) in
    do:  ("p" <-[go.int] "$r0");;;
    (for: (λ: <>, (![go.int] "start") <⟨go.int⟩ (![go.int] "r")); (λ: <>, #()) := λ: <>,
      let: "c" := (GoAlloc go.int (GoZeroVal go.int #())) in
      let: "$r0" := (u_to_w64 ((s_to_w64 ((![go.int] "start") +⟨go.int⟩ (![go.int] "r"))) >>⟨go.uint⟩ #(W64 1))) in
      do:  ("c" <-[go.int] "$r0");;;
      (if: (~ ((let: "$a0" := (![E] (IndexRef (go.SliceType E) (![go.SliceType E] "data", (![go.int] "p") -⟨go.int⟩ (![go.int] "c")))) in
      let: "$a1" := (![E] (IndexRef (go.SliceType E) (![go.SliceType E] "data", ![go.int] "c"))) in
      (![go.FunctionType (go.Signature [E; E] false [go.int])] "cmp") "$a0" "$a1") <⟨go.int⟩ #(W64 0)))
      then
        let: "$r0" := ((![go.int] "c") +⟨go.int⟩ #(W64 1)) in
        do:  ("start" <-[go.int] "$r0")
      else
        let: "$r0" := (![go.int] "c") in
        do:  ("r" <-[go.int] "$r0")));;;
    let: "end" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := ((![go.int] "n") -⟨go.int⟩ (![go.int] "start")) in
    do:  ("end" <-[go.int] "$r0");;;
    (if: ((![go.int] "start") <⟨go.int⟩ (![go.int] "m")) && ((![go.int] "m") <⟨go.int⟩ (![go.int] "end"))
    then
      do:  (let: "$a0" := (![go.SliceType E] "data") in
      let: "$a1" := (![go.int] "start") in
      let: "$a2" := (![go.int] "m") in
      let: "$a3" := (![go.int] "end") in
      let: "$a4" := (![go.FunctionType (go.Signature [E; E] false [go.int])] "cmp") in
      (FuncResolve rotateCmpFunc [E] #()) "$a0" "$a1" "$a2" "$a3" "$a4")
    else do:  #());;;
    (if: ((![go.int] "a") <⟨go.int⟩ (![go.int] "start")) && ((![go.int] "start") <⟨go.int⟩ (![go.int] "mid"))
    then
      do:  (let: "$a0" := (![go.SliceType E] "data") in
      let: "$a1" := (![go.int] "a") in
      let: "$a2" := (![go.int] "start") in
      let: "$a3" := (![go.int] "mid") in
      let: "$a4" := (![go.FunctionType (go.Signature [E; E] false [go.int])] "cmp") in
      (FuncResolve symMergeCmpFunc [E] #()) "$a0" "$a1" "$a2" "$a3" "$a4")
    else do:  #());;;
    (if: ((![go.int] "mid") <⟨go.int⟩ (![go.int] "end")) && ((![go.int] "end") <⟨go.int⟩ (![go.int] "b"))
    then
      do:  (let: "$a0" := (![go.SliceType E] "data") in
      let: "$a1" := (![go.int] "mid") in
      let: "$a2" := (![go.int] "end") in
      let: "$a3" := (![go.int] "b") in
      let: "$a4" := (![go.FunctionType (go.Signature [E; E] false [go.int])] "cmp") in
      (FuncResolve symMergeCmpFunc [E] #()) "$a0" "$a1" "$a2" "$a3" "$a4")
    else do:  #());;;
    return: #()).

(* rotateCmpFunc rotates two consecutive blocks u = data[a:m] and v = data[m:b] in data:
   Data of the form 'x u v y' is changed to 'x v u y'.
   rotate performs at most b-a many calls to data.Swap,
   and it assumes non-degenerate arguments: a < m && m < b.

   go: zsortanyfunc.go:464:6 *)
Definition rotateCmpFuncⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} (E : go.type) : val :=
  λ: "data" "a" "m" "b" "cmp",
    exception_do (let: "cmp" := (GoAlloc (go.FunctionType (go.Signature [E; E] false [go.int])) "cmp") in
    let: "b" := (GoAlloc go.int "b") in
    let: "m" := (GoAlloc go.int "m") in
    let: "a" := (GoAlloc go.int "a") in
    let: "data" := (GoAlloc (go.SliceType E) "data") in
    let: "i" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := ((![go.int] "m") -⟨go.int⟩ (![go.int] "a")) in
    do:  ("i" <-[go.int] "$r0");;;
    let: "j" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := ((![go.int] "b") -⟨go.int⟩ (![go.int] "m")) in
    do:  ("j" <-[go.int] "$r0");;;
    (for: (λ: <>, (![go.int] "i") ≠⟨go.int⟩ (![go.int] "j")); (λ: <>, #()) := λ: <>,
      (if: (![go.int] "i") >⟨go.int⟩ (![go.int] "j")
      then
        do:  (let: "$a0" := (![go.SliceType E] "data") in
        let: "$a1" := ((![go.int] "m") -⟨go.int⟩ (![go.int] "i")) in
        let: "$a2" := (![go.int] "m") in
        let: "$a3" := (![go.int] "j") in
        let: "$a4" := (![go.FunctionType (go.Signature [E; E] false [go.int])] "cmp") in
        (FuncResolve swapRangeCmpFunc [E] #()) "$a0" "$a1" "$a2" "$a3" "$a4");;;
        do:  ("i" <-[go.int] ((![go.int] "i") -⟨go.int⟩ (![go.int] "j")))
      else
        do:  (let: "$a0" := (![go.SliceType E] "data") in
        let: "$a1" := ((![go.int] "m") -⟨go.int⟩ (![go.int] "i")) in
        let: "$a2" := (((![go.int] "m") +⟨go.int⟩ (![go.int] "j")) -⟨go.int⟩ (![go.int] "i")) in
        let: "$a3" := (![go.int] "i") in
        let: "$a4" := (![go.FunctionType (go.Signature [E; E] false [go.int])] "cmp") in
        (FuncResolve swapRangeCmpFunc [E] #()) "$a0" "$a1" "$a2" "$a3" "$a4");;;
        do:  ("j" <-[go.int] ((![go.int] "j") -⟨go.int⟩ (![go.int] "i")))));;;
    do:  (let: "$a0" := (![go.SliceType E] "data") in
    let: "$a1" := ((![go.int] "m") -⟨go.int⟩ (![go.int] "i")) in
    let: "$a2" := (![go.int] "m") in
    let: "$a3" := (![go.int] "i") in
    let: "$a4" := (![go.FunctionType (go.Signature [E; E] false [go.int])] "cmp") in
    (FuncResolve swapRangeCmpFunc [E] #()) "$a0" "$a1" "$a2" "$a3" "$a4");;;
    return: #()).

#[global] Instance info' : PkgInfo pkg_id.slices :=
{|
  pkg_imported_pkgs := []
|}.

Axiom _'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init pkg_id.slices (λ: <>,
      exception_do (do:  #())
      ).

Module sortedHint.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End sortedHint.

Class sortedHint_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] sortedHint_type_repr  :: go.TypeRepr sortedHint sortedHint.t;
}.

Module xorshift.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := w64.
End def.
End xorshift.

Definition xorshiftⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.uint64.

Class xorshift_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] xorshift_type_repr  :: go.TypeRepr xorshift xorshift.t;
  #[global] xorshift_underlying :: go.Underlying (xorshift) (xorshiftⁱᵐᵖˡ);
  #[global] xorshift'ptr_Next_unfold :: MethodUnfold (go.PointerType (xorshift)) "Next" (xorshift__Nextⁱᵐᵖˡ);
}.

Class Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] sortedHint_instance :: sortedHint_Assumptions;
  #[global] xorshift_instance :: xorshift_Assumptions;
  #[global] insertionSortCmpFunc_unfold E :: FuncUnfold insertionSortCmpFunc [E] (insertionSortCmpFuncⁱᵐᵖˡ E);
  #[global] siftDownCmpFunc_unfold E :: FuncUnfold siftDownCmpFunc [E] (siftDownCmpFuncⁱᵐᵖˡ E);
  #[global] heapSortCmpFunc_unfold E :: FuncUnfold heapSortCmpFunc [E] (heapSortCmpFuncⁱᵐᵖˡ E);
  #[global] pdqsortCmpFunc_unfold E :: FuncUnfold pdqsortCmpFunc [E] (pdqsortCmpFuncⁱᵐᵖˡ E);
  #[global] partitionCmpFunc_unfold E :: FuncUnfold partitionCmpFunc [E] (partitionCmpFuncⁱᵐᵖˡ E);
  #[global] partitionEqualCmpFunc_unfold E :: FuncUnfold partitionEqualCmpFunc [E] (partitionEqualCmpFuncⁱᵐᵖˡ E);
  #[global] partialInsertionSortCmpFunc_unfold E :: FuncUnfold partialInsertionSortCmpFunc [E] (partialInsertionSortCmpFuncⁱᵐᵖˡ E);
  #[global] breakPatternsCmpFunc_unfold E :: FuncUnfold breakPatternsCmpFunc [E] (breakPatternsCmpFuncⁱᵐᵖˡ E);
  #[global] choosePivotCmpFunc_unfold E :: FuncUnfold choosePivotCmpFunc [E] (choosePivotCmpFuncⁱᵐᵖˡ E);
  #[global] order2CmpFunc_unfold E :: FuncUnfold order2CmpFunc [E] (order2CmpFuncⁱᵐᵖˡ E);
  #[global] medianCmpFunc_unfold E :: FuncUnfold medianCmpFunc [E] (medianCmpFuncⁱᵐᵖˡ E);
  #[global] medianAdjacentCmpFunc_unfold E :: FuncUnfold medianAdjacentCmpFunc [E] (medianAdjacentCmpFuncⁱᵐᵖˡ E);
  #[global] reverseRangeCmpFunc_unfold E :: FuncUnfold reverseRangeCmpFunc [E] (reverseRangeCmpFuncⁱᵐᵖˡ E);
  #[global] swapRangeCmpFunc_unfold E :: FuncUnfold swapRangeCmpFunc [E] (swapRangeCmpFuncⁱᵐᵖˡ E);
  #[global] stableCmpFunc_unfold E :: FuncUnfold stableCmpFunc [E] (stableCmpFuncⁱᵐᵖˡ E);
  #[global] symMergeCmpFunc_unfold E :: FuncUnfold symMergeCmpFunc [E] (symMergeCmpFuncⁱᵐᵖˡ E);
  #[global] rotateCmpFunc_unfold E :: FuncUnfold rotateCmpFunc [E] (rotateCmpFuncⁱᵐᵖˡ E);
}.
End slices.
