(* autogenerated from io *)
Require Export New.code.errors.
Require Export New.code.sync.
From New.golang Require Import defn.
Module pkg_id.
Definition io : go_string := "io".

End pkg_id.
Export pkg_id.
Module io.

Definition Reader {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "io.Reader"%go [].

Definition Writer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "io.Writer"%go [].

Definition Closer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "io.Closer"%go [].

Definition Seeker {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "io.Seeker"%go [].

Definition ReadWriter {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "io.ReadWriter"%go [].

Definition ReadCloser {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "io.ReadCloser"%go [].

Definition WriteCloser {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "io.WriteCloser"%go [].

Definition ReadWriteCloser {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "io.ReadWriteCloser"%go [].

Definition ReadSeeker {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "io.ReadSeeker"%go [].

Definition ReadSeekCloser {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "io.ReadSeekCloser"%go [].

Definition WriteSeeker {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "io.WriteSeeker"%go [].

Definition ReadWriteSeeker {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "io.ReadWriteSeeker"%go [].

Definition ReaderFrom {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "io.ReaderFrom"%go [].

Definition WriterTo {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "io.WriterTo"%go [].

Definition ReaderAt {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "io.ReaderAt"%go [].

Definition WriterAt {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "io.WriterAt"%go [].

Definition ByteReader {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "io.ByteReader"%go [].

Definition ByteScanner {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "io.ByteScanner"%go [].

Definition ByteWriter {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "io.ByteWriter"%go [].

Definition RuneReader {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "io.RuneReader"%go [].

Definition RuneScanner {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "io.RuneScanner"%go [].

Definition StringWriter {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "io.StringWriter"%go [].

Definition LimitedReader {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "io.LimitedReader"%go [].

Definition SectionReader {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "io.SectionReader"%go [].

Definition OffsetWriter {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "io.OffsetWriter"%go [].

Definition teeReader {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "io.teeReader"%go [].

Definition discard {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "io.discard"%go [].

Definition nopCloser {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "io.nopCloser"%go [].

Definition nopCloserWriterTo {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "io.nopCloserWriterTo"%go [].

Definition eofReader {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "io.eofReader"%go [].

Definition multiReader {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "io.multiReader"%go [].

Definition multiWriter {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "io.multiWriter"%go [].

Definition onceError {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "io.onceError"%go [].

Definition pipe {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "io.pipe"%go [].

Definition PipeReader {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "io.PipeReader"%go [].

Definition PipeWriter {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "io.PipeWriter"%go [].

Axiom Closerⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom Seekerⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom ReadWriterⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom ReadCloserⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom WriteCloserⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom ReadWriteCloserⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom ReadSeekerⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom ReadSeekCloserⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom WriteSeekerⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom ReadWriteSeekerⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom ReaderAtⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom WriterAtⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom ByteReaderⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom ByteScannerⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom ByteWriterⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom RuneReaderⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom RuneScannerⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom LimitedReaderⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom SectionReaderⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom OffsetWriterⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom teeReaderⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom nopCloserⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom nopCloserWriterToⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom eofReaderⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom onceErrorⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom pipeⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom PipeReaderⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom PipeWriterⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom SeekStart : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom SeekCurrent : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom SeekEnd : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition ErrShortWrite {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "io.ErrShortWrite"%go.

Definition errInvalidWrite {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "io.errInvalidWrite"%go.

Definition ErrShortBuffer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "io.ErrShortBuffer"%go.

Definition EOF {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "io.EOF"%go.

Definition ErrUnexpectedEOF {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "io.ErrUnexpectedEOF"%go.

Definition ErrNoProgress {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "io.ErrNoProgress"%go.

Definition errWhence {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "io.errWhence"%go.

Definition errOffset {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "io.errOffset"%go.

Definition Discard {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "io.Discard"%go.

Definition blackHolePool {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "io.blackHolePool"%go.

Axiom blackHolePool'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition ErrClosedPipe {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "io.ErrClosedPipe"%go.

Definition WriteString {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "io.WriteString"%go.

Definition ReadAtLeast {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "io.ReadAtLeast"%go.

Definition ReadFull {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "io.ReadFull"%go.

Definition CopyN {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "io.CopyN"%go.

Definition Copy {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "io.Copy"%go.

Definition CopyBuffer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "io.CopyBuffer"%go.

Definition copyBuffer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "io.copyBuffer"%go.

Definition LimitReader {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "io.LimitReader"%go.

Definition NewSectionReader {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "io.NewSectionReader"%go.

Definition NewOffsetWriter {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "io.NewOffsetWriter"%go.

Definition TeeReader {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "io.TeeReader"%go.

Definition NopCloser {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "io.NopCloser"%go.

Definition ReadAll {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "io.ReadAll"%go.

Definition MultiReader {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "io.MultiReader"%go.

Definition MultiWriter {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "io.MultiWriter"%go.

Definition Pipe {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "io.Pipe"%go.

#[global] Instance info' : PkgInfo pkg_id.io :=
{|
  pkg_imported_pkgs := [code.errors.pkg_id.errors; code.sync.pkg_id.sync]
|}.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init pkg_id.io (λ: <>,
      exception_do (do:  (go.GlobalAlloc ErrClosedPipe go.error #());;;
      do:  (go.GlobalAlloc Discard Writer #());;;
      do:  (go.GlobalAlloc errOffset go.error #());;;
      do:  (go.GlobalAlloc errWhence go.error #());;;
      do:  (go.GlobalAlloc ErrNoProgress go.error #());;;
      do:  (go.GlobalAlloc ErrUnexpectedEOF go.error #());;;
      do:  (go.GlobalAlloc EOF go.error #());;;
      do:  (go.GlobalAlloc ErrShortBuffer go.error #());;;
      do:  (go.GlobalAlloc errInvalidWrite go.error #());;;
      do:  (go.GlobalAlloc ErrShortWrite go.error #());;;
      do:  (sync.initialize' #());;;
      do:  (errors.initialize' #());;;
      let: "$r0" := (let: "$a0" := #"short write"%go in
      (FuncResolve errors.New [] #()) "$a0") in
      do:  ((GlobalVarAddr ErrShortWrite #()) <-[go.error] "$r0");;;
      let: "$r0" := (let: "$a0" := #"invalid write result"%go in
      (FuncResolve errors.New [] #()) "$a0") in
      do:  ((GlobalVarAddr errInvalidWrite #()) <-[go.error] "$r0");;;
      let: "$r0" := (let: "$a0" := #"short buffer"%go in
      (FuncResolve errors.New [] #()) "$a0") in
      do:  ((GlobalVarAddr ErrShortBuffer #()) <-[go.error] "$r0");;;
      let: "$r0" := (let: "$a0" := #"EOF"%go in
      (FuncResolve errors.New [] #()) "$a0") in
      do:  ((GlobalVarAddr EOF #()) <-[go.error] "$r0");;;
      let: "$r0" := (let: "$a0" := #"unexpected EOF"%go in
      (FuncResolve errors.New [] #()) "$a0") in
      do:  ((GlobalVarAddr ErrUnexpectedEOF #()) <-[go.error] "$r0");;;
      let: "$r0" := (let: "$a0" := #"multiple Read calls return no data or error"%go in
      (FuncResolve errors.New [] #()) "$a0") in
      do:  ((GlobalVarAddr ErrNoProgress #()) <-[go.error] "$r0");;;
      let: "$r0" := (let: "$a0" := #"Seek: invalid whence"%go in
      (FuncResolve errors.New [] #()) "$a0") in
      do:  ((GlobalVarAddr errWhence #()) <-[go.error] "$r0");;;
      let: "$r0" := (let: "$a0" := #"Seek: invalid offset"%go in
      (FuncResolve errors.New [] #()) "$a0") in
      do:  ((GlobalVarAddr errOffset #()) <-[go.error] "$r0");;;
      let: "$r0" := (Convert discard Writer (CompositeLiteral discard (LiteralValue []))) in
      do:  ((GlobalVarAddr Discard #()) <-[Writer] "$r0");;;
      let: "$r0" := (Convert discard ReaderFrom (CompositeLiteral discard (LiteralValue []))) in
      do:  (blackHolePool'init #());;;
      let: "$r0" := (Convert (go.PointerType multiReader) WriterTo (Convert go.untyped_nil (go.PointerType multiReader) UntypedNil)) in
      let: "$r0" := (Convert (go.PointerType multiWriter) StringWriter (Convert go.untyped_nil (go.PointerType multiWriter) UntypedNil)) in
      let: "$r0" := (let: "$a0" := #"io: read/write on closed pipe"%go in
      (FuncResolve errors.New [] #()) "$a0") in
      do:  ((GlobalVarAddr ErrClosedPipe #()) <-[go.error] "$r0"))
      ).

Module Reader.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := interface.t.
End def.
End Reader.

Definition Readerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.InterfaceType [go.MethodElem "Read"%go (go.Signature [go.SliceType go.byte] false [go.int; go.error])].

Class Reader_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Reader_underlying :: (Reader) <u (Readerⁱᵐᵖˡ);
}.

Module Writer.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := interface.t.
End def.
End Writer.

Definition Writerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.InterfaceType [go.MethodElem "Write"%go (go.Signature [go.SliceType go.byte] false [go.int; go.error])].

Class Writer_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Writer_underlying :: (Writer) <u (Writerⁱᵐᵖˡ);
}.

Module Closer.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End Closer.

Class Closer_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Closer_type_repr  :: go.TypeReprUnderlying Closerⁱᵐᵖˡ Closer.t;
  #[global] Closer_underlying :: (Closer) <u (Closerⁱᵐᵖˡ);
  #[global] Closerⁱᵐᵖˡ_underlying :: (Closerⁱᵐᵖˡ) ↓u (Closerⁱᵐᵖˡ);
}.

Module Seeker.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End Seeker.

Class Seeker_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Seeker_type_repr  :: go.TypeReprUnderlying Seekerⁱᵐᵖˡ Seeker.t;
  #[global] Seeker_underlying :: (Seeker) <u (Seekerⁱᵐᵖˡ);
  #[global] Seekerⁱᵐᵖˡ_underlying :: (Seekerⁱᵐᵖˡ) ↓u (Seekerⁱᵐᵖˡ);
}.

Module ReadWriter.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End ReadWriter.

Class ReadWriter_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] ReadWriter_type_repr  :: go.TypeReprUnderlying ReadWriterⁱᵐᵖˡ ReadWriter.t;
  #[global] ReadWriter_underlying :: (ReadWriter) <u (ReadWriterⁱᵐᵖˡ);
  #[global] ReadWriterⁱᵐᵖˡ_underlying :: (ReadWriterⁱᵐᵖˡ) ↓u (ReadWriterⁱᵐᵖˡ);
}.

Module ReadCloser.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End ReadCloser.

Class ReadCloser_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] ReadCloser_type_repr  :: go.TypeReprUnderlying ReadCloserⁱᵐᵖˡ ReadCloser.t;
  #[global] ReadCloser_underlying :: (ReadCloser) <u (ReadCloserⁱᵐᵖˡ);
  #[global] ReadCloserⁱᵐᵖˡ_underlying :: (ReadCloserⁱᵐᵖˡ) ↓u (ReadCloserⁱᵐᵖˡ);
}.

Module WriteCloser.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End WriteCloser.

Class WriteCloser_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] WriteCloser_type_repr  :: go.TypeReprUnderlying WriteCloserⁱᵐᵖˡ WriteCloser.t;
  #[global] WriteCloser_underlying :: (WriteCloser) <u (WriteCloserⁱᵐᵖˡ);
  #[global] WriteCloserⁱᵐᵖˡ_underlying :: (WriteCloserⁱᵐᵖˡ) ↓u (WriteCloserⁱᵐᵖˡ);
}.

Module ReadWriteCloser.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End ReadWriteCloser.

Class ReadWriteCloser_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] ReadWriteCloser_type_repr  :: go.TypeReprUnderlying ReadWriteCloserⁱᵐᵖˡ ReadWriteCloser.t;
  #[global] ReadWriteCloser_underlying :: (ReadWriteCloser) <u (ReadWriteCloserⁱᵐᵖˡ);
  #[global] ReadWriteCloserⁱᵐᵖˡ_underlying :: (ReadWriteCloserⁱᵐᵖˡ) ↓u (ReadWriteCloserⁱᵐᵖˡ);
}.

Module ReadSeeker.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End ReadSeeker.

Class ReadSeeker_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] ReadSeeker_type_repr  :: go.TypeReprUnderlying ReadSeekerⁱᵐᵖˡ ReadSeeker.t;
  #[global] ReadSeeker_underlying :: (ReadSeeker) <u (ReadSeekerⁱᵐᵖˡ);
  #[global] ReadSeekerⁱᵐᵖˡ_underlying :: (ReadSeekerⁱᵐᵖˡ) ↓u (ReadSeekerⁱᵐᵖˡ);
}.

Module ReadSeekCloser.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End ReadSeekCloser.

Class ReadSeekCloser_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] ReadSeekCloser_type_repr  :: go.TypeReprUnderlying ReadSeekCloserⁱᵐᵖˡ ReadSeekCloser.t;
  #[global] ReadSeekCloser_underlying :: (ReadSeekCloser) <u (ReadSeekCloserⁱᵐᵖˡ);
  #[global] ReadSeekCloserⁱᵐᵖˡ_underlying :: (ReadSeekCloserⁱᵐᵖˡ) ↓u (ReadSeekCloserⁱᵐᵖˡ);
}.

Module WriteSeeker.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End WriteSeeker.

Class WriteSeeker_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] WriteSeeker_type_repr  :: go.TypeReprUnderlying WriteSeekerⁱᵐᵖˡ WriteSeeker.t;
  #[global] WriteSeeker_underlying :: (WriteSeeker) <u (WriteSeekerⁱᵐᵖˡ);
  #[global] WriteSeekerⁱᵐᵖˡ_underlying :: (WriteSeekerⁱᵐᵖˡ) ↓u (WriteSeekerⁱᵐᵖˡ);
}.

Module ReadWriteSeeker.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End ReadWriteSeeker.

Class ReadWriteSeeker_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] ReadWriteSeeker_type_repr  :: go.TypeReprUnderlying ReadWriteSeekerⁱᵐᵖˡ ReadWriteSeeker.t;
  #[global] ReadWriteSeeker_underlying :: (ReadWriteSeeker) <u (ReadWriteSeekerⁱᵐᵖˡ);
  #[global] ReadWriteSeekerⁱᵐᵖˡ_underlying :: (ReadWriteSeekerⁱᵐᵖˡ) ↓u (ReadWriteSeekerⁱᵐᵖˡ);
}.

Module ReaderFrom.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := interface.t.
End def.
End ReaderFrom.

Definition ReaderFromⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.InterfaceType [go.MethodElem "ReadFrom"%go (go.Signature [Reader] false [go.int64; go.error])].

Class ReaderFrom_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] ReaderFrom_underlying :: (ReaderFrom) <u (ReaderFromⁱᵐᵖˡ);
}.

Module WriterTo.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := interface.t.
End def.
End WriterTo.

Definition WriterToⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.InterfaceType [go.MethodElem "WriteTo"%go (go.Signature [Writer] false [go.int64; go.error])].

Class WriterTo_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] WriterTo_underlying :: (WriterTo) <u (WriterToⁱᵐᵖˡ);
}.

Module ReaderAt.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End ReaderAt.

Class ReaderAt_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] ReaderAt_type_repr  :: go.TypeReprUnderlying ReaderAtⁱᵐᵖˡ ReaderAt.t;
  #[global] ReaderAt_underlying :: (ReaderAt) <u (ReaderAtⁱᵐᵖˡ);
  #[global] ReaderAtⁱᵐᵖˡ_underlying :: (ReaderAtⁱᵐᵖˡ) ↓u (ReaderAtⁱᵐᵖˡ);
}.

Module WriterAt.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End WriterAt.

Class WriterAt_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] WriterAt_type_repr  :: go.TypeReprUnderlying WriterAtⁱᵐᵖˡ WriterAt.t;
  #[global] WriterAt_underlying :: (WriterAt) <u (WriterAtⁱᵐᵖˡ);
  #[global] WriterAtⁱᵐᵖˡ_underlying :: (WriterAtⁱᵐᵖˡ) ↓u (WriterAtⁱᵐᵖˡ);
}.

Module ByteReader.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End ByteReader.

Class ByteReader_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] ByteReader_type_repr  :: go.TypeReprUnderlying ByteReaderⁱᵐᵖˡ ByteReader.t;
  #[global] ByteReader_underlying :: (ByteReader) <u (ByteReaderⁱᵐᵖˡ);
  #[global] ByteReaderⁱᵐᵖˡ_underlying :: (ByteReaderⁱᵐᵖˡ) ↓u (ByteReaderⁱᵐᵖˡ);
}.

Module ByteScanner.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End ByteScanner.

Class ByteScanner_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] ByteScanner_type_repr  :: go.TypeReprUnderlying ByteScannerⁱᵐᵖˡ ByteScanner.t;
  #[global] ByteScanner_underlying :: (ByteScanner) <u (ByteScannerⁱᵐᵖˡ);
  #[global] ByteScannerⁱᵐᵖˡ_underlying :: (ByteScannerⁱᵐᵖˡ) ↓u (ByteScannerⁱᵐᵖˡ);
}.

Module ByteWriter.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End ByteWriter.

Class ByteWriter_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] ByteWriter_type_repr  :: go.TypeReprUnderlying ByteWriterⁱᵐᵖˡ ByteWriter.t;
  #[global] ByteWriter_underlying :: (ByteWriter) <u (ByteWriterⁱᵐᵖˡ);
  #[global] ByteWriterⁱᵐᵖˡ_underlying :: (ByteWriterⁱᵐᵖˡ) ↓u (ByteWriterⁱᵐᵖˡ);
}.

Module RuneReader.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End RuneReader.

Class RuneReader_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] RuneReader_type_repr  :: go.TypeReprUnderlying RuneReaderⁱᵐᵖˡ RuneReader.t;
  #[global] RuneReader_underlying :: (RuneReader) <u (RuneReaderⁱᵐᵖˡ);
  #[global] RuneReaderⁱᵐᵖˡ_underlying :: (RuneReaderⁱᵐᵖˡ) ↓u (RuneReaderⁱᵐᵖˡ);
}.

Module RuneScanner.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End RuneScanner.

Class RuneScanner_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] RuneScanner_type_repr  :: go.TypeReprUnderlying RuneScannerⁱᵐᵖˡ RuneScanner.t;
  #[global] RuneScanner_underlying :: (RuneScanner) <u (RuneScannerⁱᵐᵖˡ);
  #[global] RuneScannerⁱᵐᵖˡ_underlying :: (RuneScannerⁱᵐᵖˡ) ↓u (RuneScannerⁱᵐᵖˡ);
}.

Module StringWriter.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := interface.t.
End def.
End StringWriter.

Definition StringWriterⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.InterfaceType [go.MethodElem "WriteString"%go (go.Signature [go.string] false [go.int; go.error])].

Class StringWriter_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] StringWriter_underlying :: (StringWriter) <u (StringWriterⁱᵐᵖˡ);
}.

Module LimitedReader.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End LimitedReader.

Class LimitedReader_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] LimitedReader_type_repr  :: go.TypeReprUnderlying LimitedReaderⁱᵐᵖˡ LimitedReader.t;
  #[global] LimitedReader_underlying :: (LimitedReader) <u (LimitedReaderⁱᵐᵖˡ);
  #[global] LimitedReaderⁱᵐᵖˡ_underlying :: (LimitedReaderⁱᵐᵖˡ) ↓u (LimitedReaderⁱᵐᵖˡ);
}.

Module SectionReader.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End SectionReader.

Class SectionReader_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] SectionReader_type_repr  :: go.TypeReprUnderlying SectionReaderⁱᵐᵖˡ SectionReader.t;
  #[global] SectionReader_underlying :: (SectionReader) <u (SectionReaderⁱᵐᵖˡ);
  #[global] SectionReaderⁱᵐᵖˡ_underlying :: (SectionReaderⁱᵐᵖˡ) ↓u (SectionReaderⁱᵐᵖˡ);
}.

Module OffsetWriter.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End OffsetWriter.

Class OffsetWriter_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] OffsetWriter_type_repr  :: go.TypeReprUnderlying OffsetWriterⁱᵐᵖˡ OffsetWriter.t;
  #[global] OffsetWriter_underlying :: (OffsetWriter) <u (OffsetWriterⁱᵐᵖˡ);
  #[global] OffsetWriterⁱᵐᵖˡ_underlying :: (OffsetWriterⁱᵐᵖˡ) ↓u (OffsetWriterⁱᵐᵖˡ);
}.

Module teeReader.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End teeReader.

Class teeReader_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] teeReader_type_repr  :: go.TypeReprUnderlying teeReaderⁱᵐᵖˡ teeReader.t;
  #[global] teeReader_underlying :: (teeReader) <u (teeReaderⁱᵐᵖˡ);
  #[global] teeReaderⁱᵐᵖˡ_underlying :: (teeReaderⁱᵐᵖˡ) ↓u (teeReaderⁱᵐᵖˡ);
}.

Module discard.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End discard.

Definition discard'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [

].
Program Definition discard'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (discard'fds_unsealed).
Global Instance equals_unfold_discard {ext : ffi_syntax} {go_gctx : GoGlobalContext} : discard'fds =→ discard'fds_unsealed.
Proof. rewrite /discard'fds seal_eq //. Qed.

Definition discardⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (discard'fds).

Class discard_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] discard_type_repr  :: go.TypeReprUnderlying discardⁱᵐᵖˡ discard.t;
  #[global] discard_underlying :: (discard) <u (discardⁱᵐᵖˡ);
}.

Module nopCloser.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End nopCloser.

Class nopCloser_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] nopCloser_type_repr  :: go.TypeReprUnderlying nopCloserⁱᵐᵖˡ nopCloser.t;
  #[global] nopCloser_underlying :: (nopCloser) <u (nopCloserⁱᵐᵖˡ);
  #[global] nopCloserⁱᵐᵖˡ_underlying :: (nopCloserⁱᵐᵖˡ) ↓u (nopCloserⁱᵐᵖˡ);
}.

Module nopCloserWriterTo.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End nopCloserWriterTo.

Class nopCloserWriterTo_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] nopCloserWriterTo_type_repr  :: go.TypeReprUnderlying nopCloserWriterToⁱᵐᵖˡ nopCloserWriterTo.t;
  #[global] nopCloserWriterTo_underlying :: (nopCloserWriterTo) <u (nopCloserWriterToⁱᵐᵖˡ);
  #[global] nopCloserWriterToⁱᵐᵖˡ_underlying :: (nopCloserWriterToⁱᵐᵖˡ) ↓u (nopCloserWriterToⁱᵐᵖˡ);
}.

Module eofReader.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End eofReader.

Class eofReader_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] eofReader_type_repr  :: go.TypeReprUnderlying eofReaderⁱᵐᵖˡ eofReader.t;
  #[global] eofReader_underlying :: (eofReader) <u (eofReaderⁱᵐᵖˡ);
  #[global] eofReaderⁱᵐᵖˡ_underlying :: (eofReaderⁱᵐᵖˡ) ↓u (eofReaderⁱᵐᵖˡ);
}.

Module multiReader.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  readers' : slice.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End multiReader.

Definition multiReader'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "readers"%go (go.SliceType Reader))
].
Program Definition multiReader'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (multiReader'fds_unsealed).
Global Instance equals_unfold_multiReader {ext : ffi_syntax} {go_gctx : GoGlobalContext} : multiReader'fds =→ multiReader'fds_unsealed.
Proof. rewrite /multiReader'fds seal_eq //. Qed.

Definition multiReaderⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (multiReader'fds).

Class multiReader_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] multiReader_type_repr  :: go.TypeReprUnderlying multiReaderⁱᵐᵖˡ multiReader.t;
  #[global] multiReader_underlying :: (multiReader) <u (multiReaderⁱᵐᵖˡ);
  #[global] multiReader_get_readers (x : multiReader.t) :: ⟦StructFieldGet (multiReaderⁱᵐᵖˡ) "readers", #x⟧ ⤳[under] #x.(multiReader.readers');
  #[global] multiReader_set_readers (x : multiReader.t) y :: ⟦StructFieldSet (multiReaderⁱᵐᵖˡ) "readers", (#x, #y)⟧ ⤳[under] #(x <|multiReader.readers' := y|>);
}.

Module multiWriter.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  writers' : slice.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End multiWriter.

Definition multiWriter'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "writers"%go (go.SliceType Writer))
].
Program Definition multiWriter'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (multiWriter'fds_unsealed).
Global Instance equals_unfold_multiWriter {ext : ffi_syntax} {go_gctx : GoGlobalContext} : multiWriter'fds =→ multiWriter'fds_unsealed.
Proof. rewrite /multiWriter'fds seal_eq //. Qed.

Definition multiWriterⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (multiWriter'fds).

Class multiWriter_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] multiWriter_type_repr  :: go.TypeReprUnderlying multiWriterⁱᵐᵖˡ multiWriter.t;
  #[global] multiWriter_underlying :: (multiWriter) <u (multiWriterⁱᵐᵖˡ);
  #[global] multiWriter_get_writers (x : multiWriter.t) :: ⟦StructFieldGet (multiWriterⁱᵐᵖˡ) "writers", #x⟧ ⤳[under] #x.(multiWriter.writers');
  #[global] multiWriter_set_writers (x : multiWriter.t) y :: ⟦StructFieldSet (multiWriterⁱᵐᵖˡ) "writers", (#x, #y)⟧ ⤳[under] #(x <|multiWriter.writers' := y|>);
}.

Module onceError.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End onceError.

Class onceError_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] onceError_type_repr  :: go.TypeReprUnderlying onceErrorⁱᵐᵖˡ onceError.t;
  #[global] onceError_underlying :: (onceError) <u (onceErrorⁱᵐᵖˡ);
  #[global] onceErrorⁱᵐᵖˡ_underlying :: (onceErrorⁱᵐᵖˡ) ↓u (onceErrorⁱᵐᵖˡ);
}.

Module pipe.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End pipe.

Class pipe_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] pipe_type_repr  :: go.TypeReprUnderlying pipeⁱᵐᵖˡ pipe.t;
  #[global] pipe_underlying :: (pipe) <u (pipeⁱᵐᵖˡ);
  #[global] pipeⁱᵐᵖˡ_underlying :: (pipeⁱᵐᵖˡ) ↓u (pipeⁱᵐᵖˡ);
}.

Module PipeReader.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End PipeReader.

Class PipeReader_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] PipeReader_type_repr  :: go.TypeReprUnderlying PipeReaderⁱᵐᵖˡ PipeReader.t;
  #[global] PipeReader_underlying :: (PipeReader) <u (PipeReaderⁱᵐᵖˡ);
  #[global] PipeReaderⁱᵐᵖˡ_underlying :: (PipeReaderⁱᵐᵖˡ) ↓u (PipeReaderⁱᵐᵖˡ);
}.

Module PipeWriter.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End PipeWriter.

Class PipeWriter_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] PipeWriter_type_repr  :: go.TypeReprUnderlying PipeWriterⁱᵐᵖˡ PipeWriter.t;
  #[global] PipeWriter_underlying :: (PipeWriter) <u (PipeWriterⁱᵐᵖˡ);
  #[global] PipeWriterⁱᵐᵖˡ_underlying :: (PipeWriterⁱᵐᵖˡ) ↓u (PipeWriterⁱᵐᵖˡ);
}.

Class Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Reader_instance :: Reader_Assumptions;
  #[global] Writer_instance :: Writer_Assumptions;
  #[global] Closer_instance :: Closer_Assumptions;
  #[global] Seeker_instance :: Seeker_Assumptions;
  #[global] ReadWriter_instance :: ReadWriter_Assumptions;
  #[global] ReadCloser_instance :: ReadCloser_Assumptions;
  #[global] WriteCloser_instance :: WriteCloser_Assumptions;
  #[global] ReadWriteCloser_instance :: ReadWriteCloser_Assumptions;
  #[global] ReadSeeker_instance :: ReadSeeker_Assumptions;
  #[global] ReadSeekCloser_instance :: ReadSeekCloser_Assumptions;
  #[global] WriteSeeker_instance :: WriteSeeker_Assumptions;
  #[global] ReadWriteSeeker_instance :: ReadWriteSeeker_Assumptions;
  #[global] ReaderFrom_instance :: ReaderFrom_Assumptions;
  #[global] WriterTo_instance :: WriterTo_Assumptions;
  #[global] ReaderAt_instance :: ReaderAt_Assumptions;
  #[global] WriterAt_instance :: WriterAt_Assumptions;
  #[global] ByteReader_instance :: ByteReader_Assumptions;
  #[global] ByteScanner_instance :: ByteScanner_Assumptions;
  #[global] ByteWriter_instance :: ByteWriter_Assumptions;
  #[global] RuneReader_instance :: RuneReader_Assumptions;
  #[global] RuneScanner_instance :: RuneScanner_Assumptions;
  #[global] StringWriter_instance :: StringWriter_Assumptions;
  #[global] LimitedReader_instance :: LimitedReader_Assumptions;
  #[global] SectionReader_instance :: SectionReader_Assumptions;
  #[global] OffsetWriter_instance :: OffsetWriter_Assumptions;
  #[global] teeReader_instance :: teeReader_Assumptions;
  #[global] discard_instance :: discard_Assumptions;
  #[global] nopCloser_instance :: nopCloser_Assumptions;
  #[global] nopCloserWriterTo_instance :: nopCloserWriterTo_Assumptions;
  #[global] eofReader_instance :: eofReader_Assumptions;
  #[global] multiReader_instance :: multiReader_Assumptions;
  #[global] multiWriter_instance :: multiWriter_Assumptions;
  #[global] onceError_instance :: onceError_Assumptions;
  #[global] pipe_instance :: pipe_Assumptions;
  #[global] PipeReader_instance :: PipeReader_Assumptions;
  #[global] PipeWriter_instance :: PipeWriter_Assumptions;
  #[global] import_errors_Assumption :: errors.Assumptions;
  #[global] import_sync_Assumption :: sync.Assumptions;
}.
End io.
