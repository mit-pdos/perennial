(* autogenerated from sort *)

From New.golang Require Import defn.
Definition sort : go_string := "sort".

Module sort.

Definition Search {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sort.Search"%go.

(* Search uses binary search to find and return the smallest index i
   in [0, n) at which f(i) is true, assuming that on the range [0, n),
   f(i) == true implies f(i+1) == true. That is, Search requires that
   f is false for some (possibly empty) prefix of the input range [0, n)
   and then true for the (possibly empty) remainder; Search returns
   the first true index. If there is no such index, Search returns n.
   (Note that the "not found" return value is not -1 as in, for instance,
   strings.Index.)
   Search calls f(i) only for i in the range [0, n).

   A common use of Search is to find the index i for a value x in
   a sorted, indexable data structure such as an array or slice.
   In this case, the argument f, typically a closure, captures the value
   to be searched for, and how the data structure is indexed and
   ordered.

   For instance, given a slice data sorted in ascending order,
   the call Search(len(data), func(i int) bool { return data[i] >= 23 })
   returns the smallest index i such that data[i] >= 23. If the caller
   wants to find whether 23 is in the slice, it must test data[i] == 23
   separately.

   Searching data sorted in descending order would use the <=
   operator instead of the >= operator.

   To complete the example above, the following code tries to find the value
   x in an integer slice data sorted in ascending order:

   	x := 23
   	i := sort.Search(len(data), func(i int) bool { return data[i] >= x })
   	if i < len(data) && data[i] == x {
   		// x is present at data[i]
   	} else {
   		// x is not present in data,
   		// but i is the index where it would be inserted.
   	}

   As a more whimsical example, this program guesses your number:

   	func GuessingGame() {
   		var s string
   		fmt.Printf("Pick an integer from 0 to 100.\n")
   		answer := sort.Search(100, func(i int) bool {
   			fmt.Printf("Is your number <= %d? ", i)
   			fmt.Scanf("%s", &s)
   			return s != "" && s[0] == 'y'
   		})
   		fmt.Printf("Your number is %d.\n", answer)
   	}

   go: search.go:58:6 *)
Definition Searchⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "n" "f",
    exception_do (let: "f" := (GoAlloc (go.FunctionType (go.Signature [go.int] false [go.bool])) "f") in
    let: "n" := (GoAlloc go.int "n") in
    let: "j" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "i" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := #(W64 0) in
    let: "$r1" := (![go.int] "n") in
    do:  ("i" <-[go.int] "$r0");;;
    do:  ("j" <-[go.int] "$r1");;;
    (for: (λ: <>, (![go.int] "i") <⟨go.int⟩ (![go.int] "j")); (λ: <>, #()) := λ: <>,
      let: "h" := (GoAlloc go.int (GoZeroVal go.int #())) in
      let: "$r0" := (u_to_w64 ((s_to_w64 ((![go.int] "i") +⟨go.int⟩ (![go.int] "j"))) ≫⟨go.uint⟩ #(W64 1))) in
      do:  ("h" <-[go.int] "$r0");;;
      (if: (~ (let: "$a0" := (![go.int] "h") in
      (![go.FunctionType (go.Signature [go.int] false [go.bool])] "f") "$a0"))
      then
        let: "$r0" := ((![go.int] "h") +⟨go.int⟩ #(W64 1)) in
        do:  ("i" <-[go.int] "$r0")
      else
        let: "$r0" := (![go.int] "h") in
        do:  ("j" <-[go.int] "$r0")));;;
    return: (![go.int] "i")).

Definition Find {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sort.Find"%go.

(* Find uses binary search to find and return the smallest index i in [0, n)
   at which cmp(i) <= 0. If there is no such index i, Find returns i = n.
   The found result is true if i < n and cmp(i) == 0.
   Find calls cmp(i) only for i in the range [0, n).

   To permit binary search, Find requires that cmp(i) > 0 for a leading
   prefix of the range, cmp(i) == 0 in the middle, and cmp(i) < 0 for
   the final suffix of the range. (Each subrange could be empty.)
   The usual way to establish this condition is to interpret cmp(i)
   as a comparison of a desired target value t against entry i in an
   underlying indexed data structure x, returning <0, 0, and >0
   when t < x[i], t == x[i], and t > x[i], respectively.

   For example, to look for a particular string in a sorted, random-access
   list of strings:

   	i, found := sort.Find(x.Len(), func(i int) int {
   	    return strings.Compare(target, x.At(i))
   	})
   	if found {
   	    fmt.Printf("found %s at entry %d\n", target, i)
   	} else {
   	    fmt.Printf("%s not found, would insert at %d", target, i)
   	}

   go: search.go:99:6 *)
Definition Findⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "n" "cmp",
    exception_do (let: "found" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "i" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "cmp" := (GoAlloc (go.FunctionType (go.Signature [go.int] false [go.int])) "cmp") in
    let: "n" := (GoAlloc go.int "n") in
    let: "j" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := #(W64 0) in
    let: "$r1" := (![go.int] "n") in
    do:  ("i" <-[go.int] "$r0");;;
    do:  ("j" <-[go.int] "$r1");;;
    (for: (λ: <>, (![go.int] "i") <⟨go.int⟩ (![go.int] "j")); (λ: <>, #()) := λ: <>,
      let: "h" := (GoAlloc go.int (GoZeroVal go.int #())) in
      let: "$r0" := (u_to_w64 ((s_to_w64 ((![go.int] "i") +⟨go.int⟩ (![go.int] "j"))) ≫⟨go.uint⟩ #(W64 1))) in
      do:  ("h" <-[go.int] "$r0");;;
      (if: (let: "$a0" := (![go.int] "h") in
      (![go.FunctionType (go.Signature [go.int] false [go.int])] "cmp") "$a0") >⟨go.int⟩ #(W64 0)
      then
        let: "$r0" := ((![go.int] "h") +⟨go.int⟩ #(W64 1)) in
        do:  ("i" <-[go.int] "$r0")
      else
        let: "$r0" := (![go.int] "h") in
        do:  ("j" <-[go.int] "$r0")));;;
    return: (![go.int] "i", ((![go.int] "i") <⟨go.int⟩ (![go.int] "n")) && ((let: "$a0" := (![go.int] "i") in
     (![go.FunctionType (go.Signature [go.int] false [go.int])] "cmp") "$a0") =⟨go.int⟩ #(W64 0)))).

Definition SearchInts {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sort.SearchInts"%go.

(* SearchInts searches for x in a sorted slice of ints and returns the index
   as specified by [Search]. The return value is the index to insert x if x is
   not present (it could be len(a)).
   The slice must be sorted in ascending order.

   go: search.go:123:6 *)
Definition SearchIntsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "a" "x",
    exception_do (let: "x" := (GoAlloc go.int "x") in
    let: "a" := (GoAlloc (go.SliceType go.int) "a") in
    return: (let: "$a0" := (let: "$a0" := (![go.SliceType go.int] "a") in
     (FuncResolve go.len [go.SliceType go.int] #()) "$a0") in
     let: "$a1" := (λ: "i",
       exception_do (let: "i" := (GoAlloc go.int "i") in
       return: ((![go.int] (IndexRef (go.SliceType go.int) (![go.SliceType go.int] "a", ![go.int] "i"))) ≥⟨go.int⟩ (![go.int] "x")))
       ) in
     (FuncResolve Search [] #()) "$a0" "$a1")).

Definition SearchFloat64s {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sort.SearchFloat64s"%go.

Definition SearchStrings {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sort.SearchStrings"%go.

Definition Slice {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sort.Slice"%go.

Definition SliceStable {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sort.SliceStable"%go.

Definition SliceIsSorted {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sort.SliceIsSorted"%go.

Axiom Interfaceⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Definition Sort {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sort.Sort"%go.

Definition sortedHintⁱᵐᵖˡ : go.type := go.int.

Definition sortedHint : go.type := go.Named "sort.sortedHint"%go [].

Module sortedHint.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t  : Type := w64.
End def.
End sortedHint.

Class sortedHint_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] sortedHint_type_repr  :: go.TypeRepr sortedHint sortedHint.t;
  #[global] sortedHint_underlying :: go.Underlying (sortedHint) (sortedHintⁱᵐᵖˡ);
}.

Definition unknownHint {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 0).

Definition increasingHint {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 1).

Definition decreasingHint {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 2).

Definition xorshift : go.type := go.Named "sort.xorshift"%go [].

(* go: sort.go:70:20 *)
Definition xorshift__Nextⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "r" <>,
    exception_do (let: "r" := (GoAlloc (go.PointerType xorshift) "r") in
    do:  ((![go.PointerType xorshift] "r") <-[xorshift] ((![xorshift] (![go.PointerType xorshift] "r")) ^⟨go.uint64⟩ ((![xorshift] (![go.PointerType xorshift] "r")) ≪⟨xorshift⟩ #(W64 13))));;;
    do:  ((![go.PointerType xorshift] "r") <-[xorshift] ((![xorshift] (![go.PointerType xorshift] "r")) ^⟨go.uint64⟩ ((![xorshift] (![go.PointerType xorshift] "r")) ≫⟨xorshift⟩ #(W64 7))));;;
    do:  ((![go.PointerType xorshift] "r") <-[xorshift] ((![xorshift] (![go.PointerType xorshift] "r")) ^⟨go.uint64⟩ ((![xorshift] (![go.PointerType xorshift] "r")) ≪⟨xorshift⟩ #(W64 17))));;;
    return: (![xorshift] (![go.PointerType xorshift] "r"))).

Definition xorshiftⁱᵐᵖˡ : go.type := go.uint64.

Module xorshift.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t  : Type := w64.
End def.
End xorshift.

Class xorshift_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] xorshift_type_repr  :: go.TypeRepr xorshift xorshift.t;
  #[global] xorshift_underlying :: go.Underlying (xorshift) (xorshiftⁱᵐᵖˡ);
  #[global] xorshift'ptr_Next_unfold :: MethodUnfold (go.PointerType (xorshift)) "Next" (xorshift__Nextⁱᵐᵖˡ);
}.

Definition nextPowerOfTwo {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sort.nextPowerOfTwo"%go.

Axiom lessSwapⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom reverseⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Definition Reverse {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sort.Reverse"%go.

Definition IsSorted {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sort.IsSorted"%go.

Axiom IntSliceⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom Float64Sliceⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Definition isNaN {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sort.isNaN"%go.

Axiom StringSliceⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Definition Ints {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sort.Ints"%go.

Definition Float64s {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sort.Float64s"%go.

Definition Strings {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sort.Strings"%go.

Definition IntsAreSorted {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sort.IntsAreSorted"%go.

Definition Float64sAreSorted {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sort.Float64sAreSorted"%go.

Definition StringsAreSorted {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sort.StringsAreSorted"%go.

Definition Stable {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sort.Stable"%go.

Definition insertionSort_func {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sort.insertionSort_func"%go.

Definition siftDown_func {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sort.siftDown_func"%go.

Definition heapSort_func {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sort.heapSort_func"%go.

Definition pdqsort_func {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sort.pdqsort_func"%go.

Definition partition_func {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sort.partition_func"%go.

Definition partitionEqual_func {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sort.partitionEqual_func"%go.

Definition partialInsertionSort_func {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sort.partialInsertionSort_func"%go.

Definition breakPatterns_func {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sort.breakPatterns_func"%go.

Definition choosePivot_func {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sort.choosePivot_func"%go.

Definition order2_func {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sort.order2_func"%go.

Definition median_func {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sort.median_func"%go.

Definition medianAdjacent_func {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sort.medianAdjacent_func"%go.

Definition reverseRange_func {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sort.reverseRange_func"%go.

Definition swapRange_func {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sort.swapRange_func"%go.

Definition stable_func {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sort.stable_func"%go.

Definition symMerge_func {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sort.symMerge_func"%go.

Definition rotate_func {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sort.rotate_func"%go.

Definition insertionSort {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sort.insertionSort"%go.

Definition siftDown {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sort.siftDown"%go.

Definition heapSort {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sort.heapSort"%go.

Definition pdqsort {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sort.pdqsort"%go.

Definition partition {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sort.partition"%go.

Definition partitionEqual {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sort.partitionEqual"%go.

Definition partialInsertionSort {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sort.partialInsertionSort"%go.

Definition breakPatterns {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sort.breakPatterns"%go.

Definition choosePivot {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sort.choosePivot"%go.

Definition order2 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sort.order2"%go.

Definition median {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sort.median"%go.

Definition medianAdjacent {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sort.medianAdjacent"%go.

Definition reverseRange {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sort.reverseRange"%go.

Definition swapRange {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sort.swapRange"%go.

Definition stable {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sort.stable"%go.

Definition symMerge {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sort.symMerge"%go.

Definition rotate {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "sort.rotate"%go.

#[global] Instance info' : PkgInfo sort.sort := 
{|
  pkg_imported_pkgs := []
|}.

Axiom _'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init sort.sort (λ: <>,
      exception_do (do:  #())
      ).

Class Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] sortedHint_instance :: sortedHint_Assumptions;
  #[global] xorshift_instance :: xorshift_Assumptions;
  #[global] Search_unfold :: FuncUnfold Search [] (Searchⁱᵐᵖˡ);
  #[global] Find_unfold :: FuncUnfold Find [] (Findⁱᵐᵖˡ);
  #[global] SearchInts_unfold :: FuncUnfold SearchInts [] (SearchIntsⁱᵐᵖˡ);
}.
End sort.
