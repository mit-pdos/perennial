(* autogenerated from sort *)

From New.golang Require Import defn.
Definition sort : go_string := "sort".

Module sort.

Module Interface. Definition id : go_string := "sort.Interface"%go. End Interface.
Module sortedHint. Definition id : go_string := "sort.sortedHint"%go. End sortedHint.
Module xorshift. Definition id : go_string := "sort.xorshift"%go. End xorshift.
Module lessSwap. Definition id : go_string := "sort.lessSwap"%go. End lessSwap.
Module reverse. Definition id : go_string := "sort.reverse"%go. End reverse.
Module IntSlice. Definition id : go_string := "sort.IntSlice"%go. End IntSlice.
Module Float64Slice. Definition id : go_string := "sort.Float64Slice"%go. End Float64Slice.
Module StringSlice. Definition id : go_string := "sort.StringSlice"%go. End StringSlice.

Section code.
Context `{ffi_syntax}.


Definition Search : go_string := "sort.Search"%go.

Definition Find : go_string := "sort.Find"%go.

(* Find uses binary search to find and return the smallest index i in [0, n)
   at which cmp(i) <= 0. If there is no such index i, Find returns i = n.
   The found result is true if i < n and cmp(i) == 0.
   Find calls cmp(i) only for i in the range [0, n).

   To permit binary search, Find requires that cmp(i) > 0 for a leading
   prefix of the range, cmp(i) == 0 in the middle, and cmp(i) < 0 for
   the final suffix of the range. (Each subrange could be empty.)
   The usual way to establish this condition is to interpret cmp(i)
   as a comparison of a desired target value t against entry i in an
   underlying indexed data structure x, returning <0, 0, and >0
   when t < x[i], t == x[i], and t > x[i], respectively.

   For example, to look for a particular string in a sorted, random-access
   list of strings:

   	i, found := sort.Find(x.Len(), func(i int) int {
   	    return strings.Compare(target, x.At(i))
   	})
   	if found {
   	    fmt.Printf("found %s at entry %d\n", target, i)
   	} else {
   	    fmt.Printf("%s not found, would insert at %d", target, i)
   	}

   go: search.go:99:6 *)
Definition Findⁱᵐᵖˡ : val :=
  λ: "n" "cmp",
    exception_do (let: "found" := (mem.alloc (type.zero_val #boolT)) in
    let: "i" := (mem.alloc (type.zero_val #intT)) in
    let: "cmp" := (mem.alloc "cmp") in
    let: "n" := (mem.alloc "n") in
    let: "j" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := #(W64 0) in
    let: "$r1" := (![#intT] "n") in
    do:  ("i" <-[#intT] "$r0");;;
    do:  ("j" <-[#intT] "$r1");;;
    (for: (λ: <>, int_lt (![#intT] "i") (![#intT] "j")); (λ: <>, #()) := λ: <>,
      let: "h" := (mem.alloc (type.zero_val #intT)) in
      let: "$r0" := (u_to_w64 ((s_to_w64 ((![#intT] "i") + (![#intT] "j"))) ≫ #(W64 1))) in
      do:  ("h" <-[#intT] "$r0");;;
      (if: int_gt (let: "$a0" := (![#intT] "h") in
      (![#funcT] "cmp") "$a0") #(W64 0)
      then
        let: "$r0" := ((![#intT] "h") + #(W64 1)) in
        do:  ("i" <-[#intT] "$r0")
      else
        let: "$r0" := (![#intT] "h") in
        do:  ("j" <-[#intT] "$r0")));;;
    return: (![#intT] "i", (int_lt (![#intT] "i") (![#intT] "n")) && ((let: "$a0" := (![#intT] "i") in
     (![#funcT] "cmp") "$a0") = #(W64 0)))).

Definition SearchInts : go_string := "sort.SearchInts"%go.

Definition SearchFloat64s : go_string := "sort.SearchFloat64s"%go.

Definition SearchStrings : go_string := "sort.SearchStrings"%go.

Definition Slice : go_string := "sort.Slice"%go.

Definition SliceStable : go_string := "sort.SliceStable"%go.

Definition SliceIsSorted : go_string := "sort.SliceIsSorted"%go.

Axiom Interface : go_type.

Definition Sort : go_string := "sort.Sort"%go.

Axiom sortedHint : go_type.

Axiom unknownHint : val.

Axiom increasingHint : val.

Axiom decreasingHint : val.

Axiom xorshift : go_type.

Definition nextPowerOfTwo : go_string := "sort.nextPowerOfTwo"%go.

Axiom lessSwap : go_type.

Axiom reverse : go_type.

Definition Reverse : go_string := "sort.Reverse"%go.

Definition IsSorted : go_string := "sort.IsSorted"%go.

Axiom IntSlice : go_type.

Axiom Float64Slice : go_type.

Definition isNaN : go_string := "sort.isNaN"%go.

Axiom StringSlice : go_type.

Definition Ints : go_string := "sort.Ints"%go.

Definition Float64s : go_string := "sort.Float64s"%go.

Definition Strings : go_string := "sort.Strings"%go.

Definition IntsAreSorted : go_string := "sort.IntsAreSorted"%go.

Definition Float64sAreSorted : go_string := "sort.Float64sAreSorted"%go.

Definition StringsAreSorted : go_string := "sort.StringsAreSorted"%go.

Definition Stable : go_string := "sort.Stable"%go.

Definition insertionSort_func : go_string := "sort.insertionSort_func"%go.

Definition siftDown_func : go_string := "sort.siftDown_func"%go.

Definition heapSort_func : go_string := "sort.heapSort_func"%go.

Definition pdqsort_func : go_string := "sort.pdqsort_func"%go.

Definition partition_func : go_string := "sort.partition_func"%go.

Definition partitionEqual_func : go_string := "sort.partitionEqual_func"%go.

Definition partialInsertionSort_func : go_string := "sort.partialInsertionSort_func"%go.

Definition breakPatterns_func : go_string := "sort.breakPatterns_func"%go.

Definition choosePivot_func : go_string := "sort.choosePivot_func"%go.

Definition order2_func : go_string := "sort.order2_func"%go.

Definition median_func : go_string := "sort.median_func"%go.

Definition medianAdjacent_func : go_string := "sort.medianAdjacent_func"%go.

Definition reverseRange_func : go_string := "sort.reverseRange_func"%go.

Definition swapRange_func : go_string := "sort.swapRange_func"%go.

Definition stable_func : go_string := "sort.stable_func"%go.

Definition symMerge_func : go_string := "sort.symMerge_func"%go.

Definition rotate_func : go_string := "sort.rotate_func"%go.

Definition insertionSort : go_string := "sort.insertionSort"%go.

Definition siftDown : go_string := "sort.siftDown"%go.

Definition heapSort : go_string := "sort.heapSort"%go.

Definition pdqsort : go_string := "sort.pdqsort"%go.

Definition partition : go_string := "sort.partition"%go.

Definition partitionEqual : go_string := "sort.partitionEqual"%go.

Definition partialInsertionSort : go_string := "sort.partialInsertionSort"%go.

Definition breakPatterns : go_string := "sort.breakPatterns"%go.

Definition choosePivot : go_string := "sort.choosePivot"%go.

Definition order2 : go_string := "sort.order2"%go.

Definition median : go_string := "sort.median"%go.

Definition medianAdjacent : go_string := "sort.medianAdjacent"%go.

Definition reverseRange : go_string := "sort.reverseRange"%go.

Definition swapRange : go_string := "sort.swapRange"%go.

Definition stable : go_string := "sort.stable"%go.

Definition symMerge : go_string := "sort.symMerge"%go.

Definition rotate : go_string := "sort.rotate"%go.

Definition vars' : list (go_string * go_type) := [].

Axiom Searchⁱᵐᵖˡ : val.

Axiom SearchIntsⁱᵐᵖˡ : val.

Axiom SearchFloat64sⁱᵐᵖˡ : val.

Axiom SearchStringsⁱᵐᵖˡ : val.

Axiom Sliceⁱᵐᵖˡ : val.

Axiom SliceStableⁱᵐᵖˡ : val.

Axiom SliceIsSortedⁱᵐᵖˡ : val.

Axiom Sortⁱᵐᵖˡ : val.

Axiom nextPowerOfTwoⁱᵐᵖˡ : val.

Axiom Reverseⁱᵐᵖˡ : val.

Axiom IsSortedⁱᵐᵖˡ : val.

Axiom isNaNⁱᵐᵖˡ : val.

Axiom Intsⁱᵐᵖˡ : val.

Axiom Float64sⁱᵐᵖˡ : val.

Axiom Stringsⁱᵐᵖˡ : val.

Axiom IntsAreSortedⁱᵐᵖˡ : val.

Axiom Float64sAreSortedⁱᵐᵖˡ : val.

Axiom StringsAreSortedⁱᵐᵖˡ : val.

Axiom Stableⁱᵐᵖˡ : val.

Axiom insertionSort_funcⁱᵐᵖˡ : val.

Axiom siftDown_funcⁱᵐᵖˡ : val.

Axiom heapSort_funcⁱᵐᵖˡ : val.

Axiom pdqsort_funcⁱᵐᵖˡ : val.

Axiom partition_funcⁱᵐᵖˡ : val.

Axiom partitionEqual_funcⁱᵐᵖˡ : val.

Axiom partialInsertionSort_funcⁱᵐᵖˡ : val.

Axiom breakPatterns_funcⁱᵐᵖˡ : val.

Axiom choosePivot_funcⁱᵐᵖˡ : val.

Axiom order2_funcⁱᵐᵖˡ : val.

Axiom median_funcⁱᵐᵖˡ : val.

Axiom medianAdjacent_funcⁱᵐᵖˡ : val.

Axiom reverseRange_funcⁱᵐᵖˡ : val.

Axiom swapRange_funcⁱᵐᵖˡ : val.

Axiom stable_funcⁱᵐᵖˡ : val.

Axiom symMerge_funcⁱᵐᵖˡ : val.

Axiom rotate_funcⁱᵐᵖˡ : val.

Axiom insertionSortⁱᵐᵖˡ : val.

Axiom siftDownⁱᵐᵖˡ : val.

Axiom heapSortⁱᵐᵖˡ : val.

Axiom pdqsortⁱᵐᵖˡ : val.

Axiom partitionⁱᵐᵖˡ : val.

Axiom partitionEqualⁱᵐᵖˡ : val.

Axiom partialInsertionSortⁱᵐᵖˡ : val.

Axiom breakPatternsⁱᵐᵖˡ : val.

Axiom choosePivotⁱᵐᵖˡ : val.

Axiom order2ⁱᵐᵖˡ : val.

Axiom medianⁱᵐᵖˡ : val.

Axiom medianAdjacentⁱᵐᵖˡ : val.

Axiom reverseRangeⁱᵐᵖˡ : val.

Axiom swapRangeⁱᵐᵖˡ : val.

Axiom stableⁱᵐᵖˡ : val.

Axiom symMergeⁱᵐᵖˡ : val.

Axiom rotateⁱᵐᵖˡ : val.

Definition functions' : list (go_string * val) := [(Search, Searchⁱᵐᵖˡ); (Find, Findⁱᵐᵖˡ); (SearchInts, SearchIntsⁱᵐᵖˡ); (SearchFloat64s, SearchFloat64sⁱᵐᵖˡ); (SearchStrings, SearchStringsⁱᵐᵖˡ); (Slice, Sliceⁱᵐᵖˡ); (SliceStable, SliceStableⁱᵐᵖˡ); (SliceIsSorted, SliceIsSortedⁱᵐᵖˡ); (Sort, Sortⁱᵐᵖˡ); (nextPowerOfTwo, nextPowerOfTwoⁱᵐᵖˡ); (Reverse, Reverseⁱᵐᵖˡ); (IsSorted, IsSortedⁱᵐᵖˡ); (isNaN, isNaNⁱᵐᵖˡ); (Ints, Intsⁱᵐᵖˡ); (Float64s, Float64sⁱᵐᵖˡ); (Strings, Stringsⁱᵐᵖˡ); (IntsAreSorted, IntsAreSortedⁱᵐᵖˡ); (Float64sAreSorted, Float64sAreSortedⁱᵐᵖˡ); (StringsAreSorted, StringsAreSortedⁱᵐᵖˡ); (Stable, Stableⁱᵐᵖˡ); (insertionSort_func, insertionSort_funcⁱᵐᵖˡ); (siftDown_func, siftDown_funcⁱᵐᵖˡ); (heapSort_func, heapSort_funcⁱᵐᵖˡ); (pdqsort_func, pdqsort_funcⁱᵐᵖˡ); (partition_func, partition_funcⁱᵐᵖˡ); (partitionEqual_func, partitionEqual_funcⁱᵐᵖˡ); (partialInsertionSort_func, partialInsertionSort_funcⁱᵐᵖˡ); (breakPatterns_func, breakPatterns_funcⁱᵐᵖˡ); (choosePivot_func, choosePivot_funcⁱᵐᵖˡ); (order2_func, order2_funcⁱᵐᵖˡ); (median_func, median_funcⁱᵐᵖˡ); (medianAdjacent_func, medianAdjacent_funcⁱᵐᵖˡ); (reverseRange_func, reverseRange_funcⁱᵐᵖˡ); (swapRange_func, swapRange_funcⁱᵐᵖˡ); (stable_func, stable_funcⁱᵐᵖˡ); (symMerge_func, symMerge_funcⁱᵐᵖˡ); (rotate_func, rotate_funcⁱᵐᵖˡ); (insertionSort, insertionSortⁱᵐᵖˡ); (siftDown, siftDownⁱᵐᵖˡ); (heapSort, heapSortⁱᵐᵖˡ); (pdqsort, pdqsortⁱᵐᵖˡ); (partition, partitionⁱᵐᵖˡ); (partitionEqual, partitionEqualⁱᵐᵖˡ); (partialInsertionSort, partialInsertionSortⁱᵐᵖˡ); (breakPatterns, breakPatternsⁱᵐᵖˡ); (choosePivot, choosePivotⁱᵐᵖˡ); (order2, order2ⁱᵐᵖˡ); (median, medianⁱᵐᵖˡ); (medianAdjacent, medianAdjacentⁱᵐᵖˡ); (reverseRange, reverseRangeⁱᵐᵖˡ); (swapRange, swapRangeⁱᵐᵖˡ); (stable, stableⁱᵐᵖˡ); (symMerge, symMergeⁱᵐᵖˡ); (rotate, rotateⁱᵐᵖˡ)].

Axiom xorshift__Nextⁱᵐᵖˡ : val.

Axiom reverse__Lenⁱᵐᵖˡ : val.

Axiom reverse__Lessⁱᵐᵖˡ : val.

Axiom reverse__Swapⁱᵐᵖˡ : val.

Axiom IntSlice__Lenⁱᵐᵖˡ : val.

Axiom IntSlice__Lessⁱᵐᵖˡ : val.

Axiom IntSlice__Searchⁱᵐᵖˡ : val.

Axiom IntSlice__Sortⁱᵐᵖˡ : val.

Axiom IntSlice__Swapⁱᵐᵖˡ : val.

Axiom Float64Slice__Lenⁱᵐᵖˡ : val.

Axiom Float64Slice__Lessⁱᵐᵖˡ : val.

Axiom Float64Slice__Searchⁱᵐᵖˡ : val.

Axiom Float64Slice__Sortⁱᵐᵖˡ : val.

Axiom Float64Slice__Swapⁱᵐᵖˡ : val.

Axiom StringSlice__Lenⁱᵐᵖˡ : val.

Axiom StringSlice__Lessⁱᵐᵖˡ : val.

Axiom StringSlice__Searchⁱᵐᵖˡ : val.

Axiom StringSlice__Sortⁱᵐᵖˡ : val.

Axiom StringSlice__Swapⁱᵐᵖˡ : val.

Definition msets' : list (go_string * (list (go_string * val))) := [(sortedHint.id, []); (ptrT.id sortedHint.id, []); (xorshift.id, []); (ptrT.id xorshift.id, [("Next"%go, xorshift__Nextⁱᵐᵖˡ)]); (lessSwap.id, []); (ptrT.id lessSwap.id, []); (reverse.id, [("Len"%go, reverse__Lenⁱᵐᵖˡ); ("Less"%go, reverse__Lessⁱᵐᵖˡ); ("Swap"%go, reverse__Swapⁱᵐᵖˡ)]); (ptrT.id reverse.id, [("Len"%go, reverse__Lenⁱᵐᵖˡ); ("Less"%go, reverse__Lessⁱᵐᵖˡ); ("Swap"%go, reverse__Swapⁱᵐᵖˡ)]); (IntSlice.id, [("Len"%go, IntSlice__Lenⁱᵐᵖˡ); ("Less"%go, IntSlice__Lessⁱᵐᵖˡ); ("Search"%go, IntSlice__Searchⁱᵐᵖˡ); ("Sort"%go, IntSlice__Sortⁱᵐᵖˡ); ("Swap"%go, IntSlice__Swapⁱᵐᵖˡ)]); (ptrT.id IntSlice.id, [("Len"%go, IntSlice__Lenⁱᵐᵖˡ); ("Less"%go, IntSlice__Lessⁱᵐᵖˡ); ("Search"%go, IntSlice__Searchⁱᵐᵖˡ); ("Sort"%go, IntSlice__Sortⁱᵐᵖˡ); ("Swap"%go, IntSlice__Swapⁱᵐᵖˡ)]); (Float64Slice.id, [("Len"%go, Float64Slice__Lenⁱᵐᵖˡ); ("Less"%go, Float64Slice__Lessⁱᵐᵖˡ); ("Search"%go, Float64Slice__Searchⁱᵐᵖˡ); ("Sort"%go, Float64Slice__Sortⁱᵐᵖˡ); ("Swap"%go, Float64Slice__Swapⁱᵐᵖˡ)]); (ptrT.id Float64Slice.id, [("Len"%go, Float64Slice__Lenⁱᵐᵖˡ); ("Less"%go, Float64Slice__Lessⁱᵐᵖˡ); ("Search"%go, Float64Slice__Searchⁱᵐᵖˡ); ("Sort"%go, Float64Slice__Sortⁱᵐᵖˡ); ("Swap"%go, Float64Slice__Swapⁱᵐᵖˡ)]); (StringSlice.id, [("Len"%go, StringSlice__Lenⁱᵐᵖˡ); ("Less"%go, StringSlice__Lessⁱᵐᵖˡ); ("Search"%go, StringSlice__Searchⁱᵐᵖˡ); ("Sort"%go, StringSlice__Sortⁱᵐᵖˡ); ("Swap"%go, StringSlice__Swapⁱᵐᵖˡ)]); (ptrT.id StringSlice.id, [("Len"%go, StringSlice__Lenⁱᵐᵖˡ); ("Less"%go, StringSlice__Lessⁱᵐᵖˡ); ("Search"%go, StringSlice__Searchⁱᵐᵖˡ); ("Sort"%go, StringSlice__Sortⁱᵐᵖˡ); ("Swap"%go, StringSlice__Swapⁱᵐᵖˡ)])].

#[global] Instance info' : PkgInfo sort.sort :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [];
  |}.

Axiom _'init : val.

Definition initialize' : val :=
  λ: <>,
    package.init #sort.sort (λ: <>,
      exception_do (do:  (package.alloc sort.sort #()))
      ).

End code.
End sort.
