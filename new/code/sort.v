(* autogenerated from sort *)

From New.golang Require Import defn.
Definition sort : go_string := "sort".

Module sort.

Module Interface. Definition id : go_string := "sort.Interface"%go. End Interface.
Module sortedHint. Definition id : go_string := "sort.sortedHint"%go. End sortedHint.
Module xorshift. Definition id : go_string := "sort.xorshift"%go. End xorshift.
Module lessSwap. Definition id : go_string := "sort.lessSwap"%go. End lessSwap.
Module reverse. Definition id : go_string := "sort.reverse"%go. End reverse.
Module IntSlice. Definition id : go_string := "sort.IntSlice"%go. End IntSlice.
Module Float64Slice. Definition id : go_string := "sort.Float64Slice"%go. End Float64Slice.
Module StringSlice. Definition id : go_string := "sort.StringSlice"%go. End StringSlice.

Section code.
Context `{ffi_syntax}.


Definition Search : go_string := "sort.Search"%go.

(* Search uses binary search to find and return the smallest index i
   in [0, n) at which f(i) is true, assuming that on the range [0, n),
   f(i) == true implies f(i+1) == true. That is, Search requires that
   f is false for some (possibly empty) prefix of the input range [0, n)
   and then true for the (possibly empty) remainder; Search returns
   the first true index. If there is no such index, Search returns n.
   (Note that the "not found" return value is not -1 as in, for instance,
   strings.Index.)
   Search calls f(i) only for i in the range [0, n).

   A common use of Search is to find the index i for a value x in
   a sorted, indexable data structure such as an array or slice.
   In this case, the argument f, typically a closure, captures the value
   to be searched for, and how the data structure is indexed and
   ordered.

   For instance, given a slice data sorted in ascending order,
   the call Search(len(data), func(i int) bool { return data[i] >= 23 })
   returns the smallest index i such that data[i] >= 23. If the caller
   wants to find whether 23 is in the slice, it must test data[i] == 23
   separately.

   Searching data sorted in descending order would use the <=
   operator instead of the >= operator.

   To complete the example above, the following code tries to find the value
   x in an integer slice data sorted in ascending order:

   	x := 23
   	i := sort.Search(len(data), func(i int) bool { return data[i] >= x })
   	if i < len(data) && data[i] == x {
   		// x is present at data[i]
   	} else {
   		// x is not present in data,
   		// but i is the index where it would be inserted.
   	}

   As a more whimsical example, this program guesses your number:

   	func GuessingGame() {
   		var s string
   		fmt.Printf("Pick an integer from 0 to 100.\n")
   		answer := sort.Search(100, func(i int) bool {
   			fmt.Printf("Is your number <= %d? ", i)
   			fmt.Scanf("%s", &s)
   			return s != "" && s[0] == 'y'
   		})
   		fmt.Printf("Your number is %d.\n", answer)
   	}

   go: search.go:58:6 *)
Definition Searchⁱᵐᵖˡ : val :=
  λ: "n" "f",
    exception_do (let: "f" := (mem.alloc "f") in
    let: "n" := (mem.alloc "n") in
    let: "j" := (mem.alloc (type.zero_val #intT)) in
    let: "i" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := #(W64 0) in
    let: "$r1" := (![#intT] "n") in
    do:  ("i" <-[#intT] "$r0");;;
    do:  ("j" <-[#intT] "$r1");;;
    (for: (λ: <>, int_lt (![#intT] "i") (![#intT] "j")); (λ: <>, #()) := λ: <>,
      let: "h" := (mem.alloc (type.zero_val #intT)) in
      let: "$r0" := (u_to_w64 ((s_to_w64 ((![#intT] "i") + (![#intT] "j"))) ≫ #(W64 1))) in
      do:  ("h" <-[#intT] "$r0");;;
      (if: (~ (let: "$a0" := (![#intT] "h") in
      (![#funcT] "f") "$a0"))
      then
        let: "$r0" := ((![#intT] "h") + #(W64 1)) in
        do:  ("i" <-[#intT] "$r0")
      else
        let: "$r0" := (![#intT] "h") in
        do:  ("j" <-[#intT] "$r0")));;;
    return: (![#intT] "i")).

Definition Find : go_string := "sort.Find"%go.

(* Find uses binary search to find and return the smallest index i in [0, n)
   at which cmp(i) <= 0. If there is no such index i, Find returns i = n.
   The found result is true if i < n and cmp(i) == 0.
   Find calls cmp(i) only for i in the range [0, n).

   To permit binary search, Find requires that cmp(i) > 0 for a leading
   prefix of the range, cmp(i) == 0 in the middle, and cmp(i) < 0 for
   the final suffix of the range. (Each subrange could be empty.)
   The usual way to establish this condition is to interpret cmp(i)
   as a comparison of a desired target value t against entry i in an
   underlying indexed data structure x, returning <0, 0, and >0
   when t < x[i], t == x[i], and t > x[i], respectively.

   For example, to look for a particular string in a sorted, random-access
   list of strings:

   	i, found := sort.Find(x.Len(), func(i int) int {
   	    return strings.Compare(target, x.At(i))
   	})
   	if found {
   	    fmt.Printf("found %s at entry %d\n", target, i)
   	} else {
   	    fmt.Printf("%s not found, would insert at %d", target, i)
   	}

   go: search.go:99:6 *)
Definition Findⁱᵐᵖˡ : val :=
  λ: "n" "cmp",
    exception_do (let: "found" := (mem.alloc (type.zero_val #boolT)) in
    let: "i" := (mem.alloc (type.zero_val #intT)) in
    let: "cmp" := (mem.alloc "cmp") in
    let: "n" := (mem.alloc "n") in
    let: "j" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := #(W64 0) in
    let: "$r1" := (![#intT] "n") in
    do:  ("i" <-[#intT] "$r0");;;
    do:  ("j" <-[#intT] "$r1");;;
    (for: (λ: <>, int_lt (![#intT] "i") (![#intT] "j")); (λ: <>, #()) := λ: <>,
      let: "h" := (mem.alloc (type.zero_val #intT)) in
      let: "$r0" := (u_to_w64 ((s_to_w64 ((![#intT] "i") + (![#intT] "j"))) ≫ #(W64 1))) in
      do:  ("h" <-[#intT] "$r0");;;
      (if: int_gt (let: "$a0" := (![#intT] "h") in
      (![#funcT] "cmp") "$a0") #(W64 0)
      then
        let: "$r0" := ((![#intT] "h") + #(W64 1)) in
        do:  ("i" <-[#intT] "$r0")
      else
        let: "$r0" := (![#intT] "h") in
        do:  ("j" <-[#intT] "$r0")));;;
    return: (![#intT] "i", (int_lt (![#intT] "i") (![#intT] "n")) && ((let: "$a0" := (![#intT] "i") in
     (![#funcT] "cmp") "$a0") = #(W64 0)))).

Definition SearchInts : go_string := "sort.SearchInts"%go.

(* SearchInts searches for x in a sorted slice of ints and returns the index
   as specified by [Search]. The return value is the index to insert x if x is
   not present (it could be len(a)).
   The slice must be sorted in ascending order.

   go: search.go:123:6 *)
Definition SearchIntsⁱᵐᵖˡ : val :=
  λ: "a" "x",
    exception_do (let: "x" := (mem.alloc "x") in
    let: "a" := (mem.alloc "a") in
    return: (let: "$a0" := (let: "$a0" := (![#sliceT] "a") in
     slice.len "$a0") in
     let: "$a1" := (λ: "i",
       exception_do (let: "i" := (mem.alloc "i") in
       return: (int_geq (![#intT] (slice.elem_ref #intT (![#sliceT] "a") (![#intT] "i"))) (![#intT] "x")))
       ) in
     (func_call #Search) "$a0" "$a1")).

Definition SearchFloat64s : go_string := "sort.SearchFloat64s"%go.

Definition SearchStrings : go_string := "sort.SearchStrings"%go.

Definition Slice : go_string := "sort.Slice"%go.

Definition SliceStable : go_string := "sort.SliceStable"%go.

Definition SliceIsSorted : go_string := "sort.SliceIsSorted"%go.

Axiom Interface : go_type.

Definition Sort : go_string := "sort.Sort"%go.

Definition sortedHint : go_type := intT.
#[global] Typeclasses Opaque sortedHint.
#[global] Opaque sortedHint.

Definition unknownHint : val := #(W64 0).

Definition increasingHint : val := #(W64 1).

Definition decreasingHint : val := #(W64 2).

Definition xorshift : go_type := uint64T.
#[global] Typeclasses Opaque xorshift.
#[global] Opaque xorshift.

Definition nextPowerOfTwo : go_string := "sort.nextPowerOfTwo"%go.

Axiom lessSwap : go_type.

Axiom reverse : go_type.

Definition Reverse : go_string := "sort.Reverse"%go.

Definition IsSorted : go_string := "sort.IsSorted"%go.

Axiom IntSlice : go_type.

Axiom Float64Slice : go_type.

Definition isNaN : go_string := "sort.isNaN"%go.

Axiom StringSlice : go_type.

Definition Ints : go_string := "sort.Ints"%go.

Definition Float64s : go_string := "sort.Float64s"%go.

Definition Strings : go_string := "sort.Strings"%go.

Definition IntsAreSorted : go_string := "sort.IntsAreSorted"%go.

Definition Float64sAreSorted : go_string := "sort.Float64sAreSorted"%go.

Definition StringsAreSorted : go_string := "sort.StringsAreSorted"%go.

Definition Stable : go_string := "sort.Stable"%go.

Definition insertionSort_func : go_string := "sort.insertionSort_func"%go.

Definition siftDown_func : go_string := "sort.siftDown_func"%go.

Definition heapSort_func : go_string := "sort.heapSort_func"%go.

Definition pdqsort_func : go_string := "sort.pdqsort_func"%go.

Definition partition_func : go_string := "sort.partition_func"%go.

Definition partitionEqual_func : go_string := "sort.partitionEqual_func"%go.

Definition partialInsertionSort_func : go_string := "sort.partialInsertionSort_func"%go.

Definition breakPatterns_func : go_string := "sort.breakPatterns_func"%go.

Definition choosePivot_func : go_string := "sort.choosePivot_func"%go.

Definition order2_func : go_string := "sort.order2_func"%go.

Definition median_func : go_string := "sort.median_func"%go.

Definition medianAdjacent_func : go_string := "sort.medianAdjacent_func"%go.

Definition reverseRange_func : go_string := "sort.reverseRange_func"%go.

Definition swapRange_func : go_string := "sort.swapRange_func"%go.

Definition stable_func : go_string := "sort.stable_func"%go.

Definition symMerge_func : go_string := "sort.symMerge_func"%go.

Definition rotate_func : go_string := "sort.rotate_func"%go.

Definition insertionSort : go_string := "sort.insertionSort"%go.

Definition siftDown : go_string := "sort.siftDown"%go.

Definition heapSort : go_string := "sort.heapSort"%go.

Definition pdqsort : go_string := "sort.pdqsort"%go.

Definition partition : go_string := "sort.partition"%go.

Definition partitionEqual : go_string := "sort.partitionEqual"%go.

Definition partialInsertionSort : go_string := "sort.partialInsertionSort"%go.

Definition breakPatterns : go_string := "sort.breakPatterns"%go.

Definition choosePivot : go_string := "sort.choosePivot"%go.

Definition order2 : go_string := "sort.order2"%go.

Definition median : go_string := "sort.median"%go.

Definition medianAdjacent : go_string := "sort.medianAdjacent"%go.

Definition reverseRange : go_string := "sort.reverseRange"%go.

Definition swapRange : go_string := "sort.swapRange"%go.

Definition stable : go_string := "sort.stable"%go.

Definition symMerge : go_string := "sort.symMerge"%go.

Definition rotate : go_string := "sort.rotate"%go.

Definition vars' : list (go_string * go_type) := [].

Axiom SearchFloat64sⁱᵐᵖˡ : val.

Axiom SearchStringsⁱᵐᵖˡ : val.

Axiom Sliceⁱᵐᵖˡ : val.

Axiom SliceStableⁱᵐᵖˡ : val.

Axiom SliceIsSortedⁱᵐᵖˡ : val.

Axiom Sortⁱᵐᵖˡ : val.

Axiom nextPowerOfTwoⁱᵐᵖˡ : val.

Axiom Reverseⁱᵐᵖˡ : val.

Axiom IsSortedⁱᵐᵖˡ : val.

Axiom isNaNⁱᵐᵖˡ : val.

Axiom Intsⁱᵐᵖˡ : val.

Axiom Float64sⁱᵐᵖˡ : val.

Axiom Stringsⁱᵐᵖˡ : val.

Axiom IntsAreSortedⁱᵐᵖˡ : val.

Axiom Float64sAreSortedⁱᵐᵖˡ : val.

Axiom StringsAreSortedⁱᵐᵖˡ : val.

Axiom Stableⁱᵐᵖˡ : val.

Axiom insertionSort_funcⁱᵐᵖˡ : val.

Axiom siftDown_funcⁱᵐᵖˡ : val.

Axiom heapSort_funcⁱᵐᵖˡ : val.

Axiom pdqsort_funcⁱᵐᵖˡ : val.

Axiom partition_funcⁱᵐᵖˡ : val.

Axiom partitionEqual_funcⁱᵐᵖˡ : val.

Axiom partialInsertionSort_funcⁱᵐᵖˡ : val.

Axiom breakPatterns_funcⁱᵐᵖˡ : val.

Axiom choosePivot_funcⁱᵐᵖˡ : val.

Axiom order2_funcⁱᵐᵖˡ : val.

Axiom median_funcⁱᵐᵖˡ : val.

Axiom medianAdjacent_funcⁱᵐᵖˡ : val.

Axiom reverseRange_funcⁱᵐᵖˡ : val.

Axiom swapRange_funcⁱᵐᵖˡ : val.

Axiom stable_funcⁱᵐᵖˡ : val.

Axiom symMerge_funcⁱᵐᵖˡ : val.

Axiom rotate_funcⁱᵐᵖˡ : val.

Axiom insertionSortⁱᵐᵖˡ : val.

Axiom siftDownⁱᵐᵖˡ : val.

Axiom heapSortⁱᵐᵖˡ : val.

Axiom pdqsortⁱᵐᵖˡ : val.

Axiom partitionⁱᵐᵖˡ : val.

Axiom partitionEqualⁱᵐᵖˡ : val.

Axiom partialInsertionSortⁱᵐᵖˡ : val.

Axiom breakPatternsⁱᵐᵖˡ : val.

Axiom choosePivotⁱᵐᵖˡ : val.

Axiom order2ⁱᵐᵖˡ : val.

Axiom medianⁱᵐᵖˡ : val.

Axiom medianAdjacentⁱᵐᵖˡ : val.

Axiom reverseRangeⁱᵐᵖˡ : val.

Axiom swapRangeⁱᵐᵖˡ : val.

Axiom stableⁱᵐᵖˡ : val.

Axiom symMergeⁱᵐᵖˡ : val.

Axiom rotateⁱᵐᵖˡ : val.

Definition functions' : list (go_string * val) := [(Search, Searchⁱᵐᵖˡ); (Find, Findⁱᵐᵖˡ); (SearchInts, SearchIntsⁱᵐᵖˡ); (SearchFloat64s, SearchFloat64sⁱᵐᵖˡ); (SearchStrings, SearchStringsⁱᵐᵖˡ); (Slice, Sliceⁱᵐᵖˡ); (SliceStable, SliceStableⁱᵐᵖˡ); (SliceIsSorted, SliceIsSortedⁱᵐᵖˡ); (Sort, Sortⁱᵐᵖˡ); (nextPowerOfTwo, nextPowerOfTwoⁱᵐᵖˡ); (Reverse, Reverseⁱᵐᵖˡ); (IsSorted, IsSortedⁱᵐᵖˡ); (isNaN, isNaNⁱᵐᵖˡ); (Ints, Intsⁱᵐᵖˡ); (Float64s, Float64sⁱᵐᵖˡ); (Strings, Stringsⁱᵐᵖˡ); (IntsAreSorted, IntsAreSortedⁱᵐᵖˡ); (Float64sAreSorted, Float64sAreSortedⁱᵐᵖˡ); (StringsAreSorted, StringsAreSortedⁱᵐᵖˡ); (Stable, Stableⁱᵐᵖˡ); (insertionSort_func, insertionSort_funcⁱᵐᵖˡ); (siftDown_func, siftDown_funcⁱᵐᵖˡ); (heapSort_func, heapSort_funcⁱᵐᵖˡ); (pdqsort_func, pdqsort_funcⁱᵐᵖˡ); (partition_func, partition_funcⁱᵐᵖˡ); (partitionEqual_func, partitionEqual_funcⁱᵐᵖˡ); (partialInsertionSort_func, partialInsertionSort_funcⁱᵐᵖˡ); (breakPatterns_func, breakPatterns_funcⁱᵐᵖˡ); (choosePivot_func, choosePivot_funcⁱᵐᵖˡ); (order2_func, order2_funcⁱᵐᵖˡ); (median_func, median_funcⁱᵐᵖˡ); (medianAdjacent_func, medianAdjacent_funcⁱᵐᵖˡ); (reverseRange_func, reverseRange_funcⁱᵐᵖˡ); (swapRange_func, swapRange_funcⁱᵐᵖˡ); (stable_func, stable_funcⁱᵐᵖˡ); (symMerge_func, symMerge_funcⁱᵐᵖˡ); (rotate_func, rotate_funcⁱᵐᵖˡ); (insertionSort, insertionSortⁱᵐᵖˡ); (siftDown, siftDownⁱᵐᵖˡ); (heapSort, heapSortⁱᵐᵖˡ); (pdqsort, pdqsortⁱᵐᵖˡ); (partition, partitionⁱᵐᵖˡ); (partitionEqual, partitionEqualⁱᵐᵖˡ); (partialInsertionSort, partialInsertionSortⁱᵐᵖˡ); (breakPatterns, breakPatternsⁱᵐᵖˡ); (choosePivot, choosePivotⁱᵐᵖˡ); (order2, order2ⁱᵐᵖˡ); (median, medianⁱᵐᵖˡ); (medianAdjacent, medianAdjacentⁱᵐᵖˡ); (reverseRange, reverseRangeⁱᵐᵖˡ); (swapRange, swapRangeⁱᵐᵖˡ); (stable, stableⁱᵐᵖˡ); (symMerge, symMergeⁱᵐᵖˡ); (rotate, rotateⁱᵐᵖˡ)].

Axiom xorshift__Nextⁱᵐᵖˡ : val.

Axiom reverse__Lenⁱᵐᵖˡ : val.

Axiom reverse__Lessⁱᵐᵖˡ : val.

Axiom reverse__Swapⁱᵐᵖˡ : val.

Axiom IntSlice__Lenⁱᵐᵖˡ : val.

Axiom IntSlice__Lessⁱᵐᵖˡ : val.

Axiom IntSlice__Searchⁱᵐᵖˡ : val.

Axiom IntSlice__Sortⁱᵐᵖˡ : val.

Axiom IntSlice__Swapⁱᵐᵖˡ : val.

Axiom Float64Slice__Lenⁱᵐᵖˡ : val.

Axiom Float64Slice__Lessⁱᵐᵖˡ : val.

Axiom Float64Slice__Searchⁱᵐᵖˡ : val.

Axiom Float64Slice__Sortⁱᵐᵖˡ : val.

Axiom Float64Slice__Swapⁱᵐᵖˡ : val.

Axiom StringSlice__Lenⁱᵐᵖˡ : val.

Axiom StringSlice__Lessⁱᵐᵖˡ : val.

Axiom StringSlice__Searchⁱᵐᵖˡ : val.

Axiom StringSlice__Sortⁱᵐᵖˡ : val.

Axiom StringSlice__Swapⁱᵐᵖˡ : val.

Definition msets' : list (go_string * (list (go_string * val))) := [(sortedHint.id, []); (ptrT.id sortedHint.id, []); (xorshift.id, []); (ptrT.id xorshift.id, [("Next"%go, xorshift__Nextⁱᵐᵖˡ)]); (lessSwap.id, []); (ptrT.id lessSwap.id, []); (reverse.id, [("Len"%go, reverse__Lenⁱᵐᵖˡ); ("Less"%go, reverse__Lessⁱᵐᵖˡ); ("Swap"%go, reverse__Swapⁱᵐᵖˡ)]); (ptrT.id reverse.id, [("Len"%go, reverse__Lenⁱᵐᵖˡ); ("Less"%go, reverse__Lessⁱᵐᵖˡ); ("Swap"%go, reverse__Swapⁱᵐᵖˡ)]); (IntSlice.id, [("Len"%go, IntSlice__Lenⁱᵐᵖˡ); ("Less"%go, IntSlice__Lessⁱᵐᵖˡ); ("Search"%go, IntSlice__Searchⁱᵐᵖˡ); ("Sort"%go, IntSlice__Sortⁱᵐᵖˡ); ("Swap"%go, IntSlice__Swapⁱᵐᵖˡ)]); (ptrT.id IntSlice.id, [("Len"%go, IntSlice__Lenⁱᵐᵖˡ); ("Less"%go, IntSlice__Lessⁱᵐᵖˡ); ("Search"%go, IntSlice__Searchⁱᵐᵖˡ); ("Sort"%go, IntSlice__Sortⁱᵐᵖˡ); ("Swap"%go, IntSlice__Swapⁱᵐᵖˡ)]); (Float64Slice.id, [("Len"%go, Float64Slice__Lenⁱᵐᵖˡ); ("Less"%go, Float64Slice__Lessⁱᵐᵖˡ); ("Search"%go, Float64Slice__Searchⁱᵐᵖˡ); ("Sort"%go, Float64Slice__Sortⁱᵐᵖˡ); ("Swap"%go, Float64Slice__Swapⁱᵐᵖˡ)]); (ptrT.id Float64Slice.id, [("Len"%go, Float64Slice__Lenⁱᵐᵖˡ); ("Less"%go, Float64Slice__Lessⁱᵐᵖˡ); ("Search"%go, Float64Slice__Searchⁱᵐᵖˡ); ("Sort"%go, Float64Slice__Sortⁱᵐᵖˡ); ("Swap"%go, Float64Slice__Swapⁱᵐᵖˡ)]); (StringSlice.id, [("Len"%go, StringSlice__Lenⁱᵐᵖˡ); ("Less"%go, StringSlice__Lessⁱᵐᵖˡ); ("Search"%go, StringSlice__Searchⁱᵐᵖˡ); ("Sort"%go, StringSlice__Sortⁱᵐᵖˡ); ("Swap"%go, StringSlice__Swapⁱᵐᵖˡ)]); (ptrT.id StringSlice.id, [("Len"%go, StringSlice__Lenⁱᵐᵖˡ); ("Less"%go, StringSlice__Lessⁱᵐᵖˡ); ("Search"%go, StringSlice__Searchⁱᵐᵖˡ); ("Sort"%go, StringSlice__Sortⁱᵐᵖˡ); ("Swap"%go, StringSlice__Swapⁱᵐᵖˡ)])].

#[global] Instance info' : PkgInfo sort.sort :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [];
  |}.

Axiom _'init : val.

Definition initialize' : val :=
  λ: <>,
    package.init #sort.sort (λ: <>,
      exception_do (do:  (package.alloc sort.sort #()))
      ).

End code.
End sort.
