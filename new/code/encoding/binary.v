(* autogenerated from encoding/binary *)
Require Export New.code.errors.
Require Export New.code.io.
Require Export New.code.math.
Require Export New.code.slices.
Require Export New.code.sync.
From New.golang Require Import defn.
Module pkg_id.
Definition binary : go_string := "encoding/binary".

End pkg_id.
Export pkg_id.
Module binary.

Definition ByteOrder {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "encoding/binary.ByteOrder"%go [].

Definition AppendByteOrder {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "encoding/binary.AppendByteOrder"%go [].

Definition littleEndian {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "encoding/binary.littleEndian"%go [].

Definition bigEndian {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "encoding/binary.bigEndian"%go [].

Definition coder {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "encoding/binary.coder"%go [].

Definition decoder {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "encoding/binary.decoder"%go [].

Definition encoder {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "encoding/binary.encoder"%go [].

Definition nativeEndian {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "encoding/binary.nativeEndian"%go [].

Axiom ByteOrderⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom AppendByteOrderⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom bigEndianⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom coderⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom decoderⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom encoderⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom nativeEndianⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom MaxVarintLen16 : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom MaxVarintLen32 : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom MaxVarintLen64 : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition errBufferTooSmall {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "encoding/binary.errBufferTooSmall"%go.

Axiom errBufferTooSmall'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition LittleEndian {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "encoding/binary.LittleEndian"%go.

Definition BigEndian {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "encoding/binary.BigEndian"%go.

Definition structSize {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "encoding/binary.structSize"%go.

Definition NativeEndian {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "encoding/binary.NativeEndian"%go.

Definition errOverflow {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "encoding/binary.errOverflow"%go.

Axiom errOverflow'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition Read {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "encoding/binary.Read"%go.

Definition Decode {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "encoding/binary.Decode"%go.

Definition decodeFast {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "encoding/binary.decodeFast"%go.

Definition Write {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "encoding/binary.Write"%go.

Definition Encode {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "encoding/binary.Encode"%go.

Definition Append {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "encoding/binary.Append"%go.

Definition encodeFast {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "encoding/binary.encodeFast"%go.

Definition Size {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "encoding/binary.Size"%go.

Definition dataSize {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "encoding/binary.dataSize"%go.

Definition sizeof {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "encoding/binary.sizeof"%go.

Definition intDataSize {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "encoding/binary.intDataSize"%go.

Definition ensure {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "encoding/binary.ensure"%go.

Definition AppendUvarint {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "encoding/binary.AppendUvarint"%go.

Definition PutUvarint {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "encoding/binary.PutUvarint"%go.

Definition Uvarint {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "encoding/binary.Uvarint"%go.

Definition AppendVarint {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "encoding/binary.AppendVarint"%go.

Definition PutVarint {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "encoding/binary.PutVarint"%go.

Definition Varint {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "encoding/binary.Varint"%go.

Definition ReadUvarint {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "encoding/binary.ReadUvarint"%go.

Definition ReadVarint {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "encoding/binary.ReadVarint"%go.

(* Uint16 returns the uint16 representation of b[0:2].

   go: binary.go:69:21 *)
Definition littleEndian__Uint16ⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <> "b",
    exception_do (let: "b" := (GoAlloc (go.SliceType go.byte) "b") in
    let: "$r0" := (![go.byte] (IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "b", #(W64 1)))) in
    do:  "$r0";;;
    return: ((Convert go.byte go.uint16 (![go.byte] (IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "b", #(W64 0))))) |⟨go.uint16⟩ ((Convert go.byte go.uint16 (![go.byte] (IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "b", #(W64 1))))) <<⟨go.uint16⟩ (Convert go.untyped_int go.uint16 #8)))).

(* PutUint16 stores v into b[0:2].

   go: binary.go:75:21 *)
Definition littleEndian__PutUint16ⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <> "b" "v",
    exception_do (let: "v" := (GoAlloc go.uint16 "v") in
    let: "b" := (GoAlloc (go.SliceType go.byte) "b") in
    let: "$r0" := (![go.byte] (IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "b", #(W64 1)))) in
    do:  "$r0";;;
    let: "$r0" := (Convert go.uint16 go.byte (![go.uint16] "v")) in
    do:  ((IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "b", #(W64 0))) <-[go.byte] "$r0");;;
    let: "$r0" := (Convert go.uint16 go.byte ((![go.uint16] "v") >>⟨go.uint16⟩ (Convert go.untyped_int go.uint16 #8))) in
    do:  ((IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "b", #(W64 1))) <-[go.byte] "$r0");;;
    return: #()).

(* AppendUint16 appends the bytes of v to b and returns the appended slice.

   go: binary.go:82:21 *)
Definition littleEndian__AppendUint16ⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <> "b" "v",
    exception_do (let: "v" := (GoAlloc go.uint16 "v") in
    let: "b" := (GoAlloc (go.SliceType go.byte) "b") in
    return: (let: "$a0" := (![go.SliceType go.byte] "b") in
     let: "$a1" := ((let: "$sl0" := (Convert go.uint16 go.byte (![go.uint16] "v")) in
     let: "$sl1" := (Convert go.uint16 go.byte ((![go.uint16] "v") >>⟨go.uint16⟩ (Convert go.untyped_int go.uint16 #8))) in
     CompositeLiteral (go.SliceType go.byte) (LiteralValue [KeyedElement None (ElementExpression go.byte "$sl0"); KeyedElement None (ElementExpression go.byte "$sl1")]))) in
     (FuncResolve go.append [go.SliceType go.byte] #()) "$a0" "$a1")).

(* Uint32 returns the uint32 representation of b[0:4].

   go: binary.go:90:21 *)
Definition littleEndian__Uint32ⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <> "b",
    exception_do (let: "b" := (GoAlloc (go.SliceType go.byte) "b") in
    let: "$r0" := (![go.byte] (IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "b", #(W64 3)))) in
    do:  "$r0";;;
    return: ((((Convert go.byte go.uint32 (![go.byte] (IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "b", #(W64 0))))) |⟨go.uint32⟩ ((Convert go.byte go.uint32 (![go.byte] (IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "b", #(W64 1))))) <<⟨go.uint32⟩ (Convert go.untyped_int go.uint32 #8))) |⟨go.uint32⟩ ((Convert go.byte go.uint32 (![go.byte] (IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "b", #(W64 2))))) <<⟨go.uint32⟩ (Convert go.untyped_int go.uint32 #16))) |⟨go.uint32⟩ ((Convert go.byte go.uint32 (![go.byte] (IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "b", #(W64 3))))) <<⟨go.uint32⟩ (Convert go.untyped_int go.uint32 #24)))).

(* PutUint32 stores v into b[0:4].

   go: binary.go:96:21 *)
Definition littleEndian__PutUint32ⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <> "b" "v",
    exception_do (let: "v" := (GoAlloc go.uint32 "v") in
    let: "b" := (GoAlloc (go.SliceType go.byte) "b") in
    let: "$r0" := (![go.byte] (IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "b", #(W64 3)))) in
    do:  "$r0";;;
    let: "$r0" := (Convert go.uint32 go.byte (![go.uint32] "v")) in
    do:  ((IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "b", #(W64 0))) <-[go.byte] "$r0");;;
    let: "$r0" := (Convert go.uint32 go.byte ((![go.uint32] "v") >>⟨go.uint32⟩ (Convert go.untyped_int go.uint32 #8))) in
    do:  ((IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "b", #(W64 1))) <-[go.byte] "$r0");;;
    let: "$r0" := (Convert go.uint32 go.byte ((![go.uint32] "v") >>⟨go.uint32⟩ (Convert go.untyped_int go.uint32 #16))) in
    do:  ((IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "b", #(W64 2))) <-[go.byte] "$r0");;;
    let: "$r0" := (Convert go.uint32 go.byte ((![go.uint32] "v") >>⟨go.uint32⟩ (Convert go.untyped_int go.uint32 #24))) in
    do:  ((IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "b", #(W64 3))) <-[go.byte] "$r0");;;
    return: #()).

(* AppendUint32 appends the bytes of v to b and returns the appended slice.

   go: binary.go:105:21 *)
Definition littleEndian__AppendUint32ⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <> "b" "v",
    exception_do (let: "v" := (GoAlloc go.uint32 "v") in
    let: "b" := (GoAlloc (go.SliceType go.byte) "b") in
    return: (let: "$a0" := (![go.SliceType go.byte] "b") in
     let: "$a1" := ((let: "$sl0" := (Convert go.uint32 go.byte (![go.uint32] "v")) in
     let: "$sl1" := (Convert go.uint32 go.byte ((![go.uint32] "v") >>⟨go.uint32⟩ (Convert go.untyped_int go.uint32 #8))) in
     let: "$sl2" := (Convert go.uint32 go.byte ((![go.uint32] "v") >>⟨go.uint32⟩ (Convert go.untyped_int go.uint32 #16))) in
     let: "$sl3" := (Convert go.uint32 go.byte ((![go.uint32] "v") >>⟨go.uint32⟩ (Convert go.untyped_int go.uint32 #24))) in
     CompositeLiteral (go.SliceType go.byte) (LiteralValue [KeyedElement None (ElementExpression go.byte "$sl0"); KeyedElement None (ElementExpression go.byte "$sl1"); KeyedElement None (ElementExpression go.byte "$sl2"); KeyedElement None (ElementExpression go.byte "$sl3")]))) in
     (FuncResolve go.append [go.SliceType go.byte] #()) "$a0" "$a1")).

(* Uint64 returns the uint64 representation of b[0:8].

   go: binary.go:115:21 *)
Definition littleEndian__Uint64ⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <> "b",
    exception_do (let: "b" := (GoAlloc (go.SliceType go.byte) "b") in
    let: "$r0" := (![go.byte] (IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "b", #(W64 7)))) in
    do:  "$r0";;;
    return: ((((((((Convert go.byte go.uint64 (![go.byte] (IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "b", #(W64 0))))) |⟨go.uint64⟩ ((Convert go.byte go.uint64 (![go.byte] (IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "b", #(W64 1))))) <<⟨go.uint64⟩ (Convert go.untyped_int go.uint64 #8))) |⟨go.uint64⟩ ((Convert go.byte go.uint64 (![go.byte] (IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "b", #(W64 2))))) <<⟨go.uint64⟩ (Convert go.untyped_int go.uint64 #16))) |⟨go.uint64⟩ ((Convert go.byte go.uint64 (![go.byte] (IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "b", #(W64 3))))) <<⟨go.uint64⟩ (Convert go.untyped_int go.uint64 #24))) |⟨go.uint64⟩ ((Convert go.byte go.uint64 (![go.byte] (IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "b", #(W64 4))))) <<⟨go.uint64⟩ (Convert go.untyped_int go.uint64 #32))) |⟨go.uint64⟩ ((Convert go.byte go.uint64 (![go.byte] (IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "b", #(W64 5))))) <<⟨go.uint64⟩ (Convert go.untyped_int go.uint64 #40))) |⟨go.uint64⟩ ((Convert go.byte go.uint64 (![go.byte] (IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "b", #(W64 6))))) <<⟨go.uint64⟩ (Convert go.untyped_int go.uint64 #48))) |⟨go.uint64⟩ ((Convert go.byte go.uint64 (![go.byte] (IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "b", #(W64 7))))) <<⟨go.uint64⟩ (Convert go.untyped_int go.uint64 #56)))).

(* PutUint64 stores v into b[0:8].

   go: binary.go:122:21 *)
Definition littleEndian__PutUint64ⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <> "b" "v",
    exception_do (let: "v" := (GoAlloc go.uint64 "v") in
    let: "b" := (GoAlloc (go.SliceType go.byte) "b") in
    let: "$r0" := (![go.byte] (IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "b", #(W64 7)))) in
    do:  "$r0";;;
    let: "$r0" := (Convert go.uint64 go.byte (![go.uint64] "v")) in
    do:  ((IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "b", #(W64 0))) <-[go.byte] "$r0");;;
    let: "$r0" := (Convert go.uint64 go.byte ((![go.uint64] "v") >>⟨go.uint64⟩ (Convert go.untyped_int go.uint64 #8))) in
    do:  ((IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "b", #(W64 1))) <-[go.byte] "$r0");;;
    let: "$r0" := (Convert go.uint64 go.byte ((![go.uint64] "v") >>⟨go.uint64⟩ (Convert go.untyped_int go.uint64 #16))) in
    do:  ((IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "b", #(W64 2))) <-[go.byte] "$r0");;;
    let: "$r0" := (Convert go.uint64 go.byte ((![go.uint64] "v") >>⟨go.uint64⟩ (Convert go.untyped_int go.uint64 #24))) in
    do:  ((IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "b", #(W64 3))) <-[go.byte] "$r0");;;
    let: "$r0" := (Convert go.uint64 go.byte ((![go.uint64] "v") >>⟨go.uint64⟩ (Convert go.untyped_int go.uint64 #32))) in
    do:  ((IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "b", #(W64 4))) <-[go.byte] "$r0");;;
    let: "$r0" := (Convert go.uint64 go.byte ((![go.uint64] "v") >>⟨go.uint64⟩ (Convert go.untyped_int go.uint64 #40))) in
    do:  ((IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "b", #(W64 5))) <-[go.byte] "$r0");;;
    let: "$r0" := (Convert go.uint64 go.byte ((![go.uint64] "v") >>⟨go.uint64⟩ (Convert go.untyped_int go.uint64 #48))) in
    do:  ((IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "b", #(W64 6))) <-[go.byte] "$r0");;;
    let: "$r0" := (Convert go.uint64 go.byte ((![go.uint64] "v") >>⟨go.uint64⟩ (Convert go.untyped_int go.uint64 #56))) in
    do:  ((IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "b", #(W64 7))) <-[go.byte] "$r0");;;
    return: #()).

(* AppendUint64 appends the bytes of v to b and returns the appended slice.

   go: binary.go:135:21 *)
Definition littleEndian__AppendUint64ⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <> "b" "v",
    exception_do (let: "v" := (GoAlloc go.uint64 "v") in
    let: "b" := (GoAlloc (go.SliceType go.byte) "b") in
    return: (let: "$a0" := (![go.SliceType go.byte] "b") in
     let: "$a1" := ((let: "$sl0" := (Convert go.uint64 go.byte (![go.uint64] "v")) in
     let: "$sl1" := (Convert go.uint64 go.byte ((![go.uint64] "v") >>⟨go.uint64⟩ (Convert go.untyped_int go.uint64 #8))) in
     let: "$sl2" := (Convert go.uint64 go.byte ((![go.uint64] "v") >>⟨go.uint64⟩ (Convert go.untyped_int go.uint64 #16))) in
     let: "$sl3" := (Convert go.uint64 go.byte ((![go.uint64] "v") >>⟨go.uint64⟩ (Convert go.untyped_int go.uint64 #24))) in
     let: "$sl4" := (Convert go.uint64 go.byte ((![go.uint64] "v") >>⟨go.uint64⟩ (Convert go.untyped_int go.uint64 #32))) in
     let: "$sl5" := (Convert go.uint64 go.byte ((![go.uint64] "v") >>⟨go.uint64⟩ (Convert go.untyped_int go.uint64 #40))) in
     let: "$sl6" := (Convert go.uint64 go.byte ((![go.uint64] "v") >>⟨go.uint64⟩ (Convert go.untyped_int go.uint64 #48))) in
     let: "$sl7" := (Convert go.uint64 go.byte ((![go.uint64] "v") >>⟨go.uint64⟩ (Convert go.untyped_int go.uint64 #56))) in
     CompositeLiteral (go.SliceType go.byte) (LiteralValue [KeyedElement None (ElementExpression go.byte "$sl0"); KeyedElement None (ElementExpression go.byte "$sl1"); KeyedElement None (ElementExpression go.byte "$sl2"); KeyedElement None (ElementExpression go.byte "$sl3"); KeyedElement None (ElementExpression go.byte "$sl4"); KeyedElement None (ElementExpression go.byte "$sl5"); KeyedElement None (ElementExpression go.byte "$sl6"); KeyedElement None (ElementExpression go.byte "$sl7")]))) in
     (FuncResolve go.append [go.SliceType go.byte] #()) "$a0" "$a1")).

(* go: binary.go:148:21 *)
Definition littleEndian__Stringⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <> <>,
    exception_do (return: (#"LittleEndian"%go)).

(* go: binary.go:150:21 *)
Definition littleEndian__GoStringⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <> <>,
    exception_do (return: (#"binary.LittleEndian"%go)).

#[global] Instance info' : PkgInfo pkg_id.binary :=
{|
  pkg_imported_pkgs := [code.errors.pkg_id.errors; code.io.pkg_id.io; code.math.pkg_id.math; code.slices.pkg_id.slices; code.sync.pkg_id.sync]
|}.

Axiom _'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init pkg_id.binary (λ: <>,
      exception_do (do:  (go.GlobalAlloc LittleEndian littleEndian #());;;
      do:  (sync.initialize' #());;;
      do:  (slices.initialize' #());;;
      do:  (math.initialize' #());;;
      do:  (io.initialize' #());;;
      do:  (errors.initialize' #());;;
      do:  (errBufferTooSmall'init #());;;
      do:  (errOverflow'init #()))
      ).

Module ByteOrder.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End ByteOrder.

Class ByteOrder_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] ByteOrder_type_repr  :: go.TypeReprUnderlying ByteOrderⁱᵐᵖˡ ByteOrder.t;
  #[global] ByteOrder_underlying :: (ByteOrder) <u (ByteOrderⁱᵐᵖˡ);
  #[global] ByteOrderⁱᵐᵖˡ_underlying :: (ByteOrderⁱᵐᵖˡ) ↓u (ByteOrderⁱᵐᵖˡ);
}.

Module AppendByteOrder.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End AppendByteOrder.

Class AppendByteOrder_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] AppendByteOrder_type_repr  :: go.TypeReprUnderlying AppendByteOrderⁱᵐᵖˡ AppendByteOrder.t;
  #[global] AppendByteOrder_underlying :: (AppendByteOrder) <u (AppendByteOrderⁱᵐᵖˡ);
  #[global] AppendByteOrderⁱᵐᵖˡ_underlying :: (AppendByteOrderⁱᵐᵖˡ) ↓u (AppendByteOrderⁱᵐᵖˡ);
}.

Module littleEndian.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End littleEndian.

Definition littleEndian'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [

].
Program Definition littleEndian'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (littleEndian'fds_unsealed).
Global Instance equals_unfold_littleEndian {ext : ffi_syntax} {go_gctx : GoGlobalContext} : littleEndian'fds =→ littleEndian'fds_unsealed.
Proof. rewrite /littleEndian'fds seal_eq //. Qed.

Definition littleEndianⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (littleEndian'fds).

Class littleEndian_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] littleEndian_type_repr  :: go.TypeReprUnderlying littleEndianⁱᵐᵖˡ littleEndian.t;
  #[global] littleEndian_underlying :: (littleEndian) <u (littleEndianⁱᵐᵖˡ);
  #[global] littleEndian_AppendUint16_unfold :: MethodUnfold (littleEndian) "AppendUint16" (littleEndian__AppendUint16ⁱᵐᵖˡ);
  #[global] littleEndian_AppendUint32_unfold :: MethodUnfold (littleEndian) "AppendUint32" (littleEndian__AppendUint32ⁱᵐᵖˡ);
  #[global] littleEndian_AppendUint64_unfold :: MethodUnfold (littleEndian) "AppendUint64" (littleEndian__AppendUint64ⁱᵐᵖˡ);
  #[global] littleEndian_GoString_unfold :: MethodUnfold (littleEndian) "GoString" (littleEndian__GoStringⁱᵐᵖˡ);
  #[global] littleEndian_PutUint16_unfold :: MethodUnfold (littleEndian) "PutUint16" (littleEndian__PutUint16ⁱᵐᵖˡ);
  #[global] littleEndian_PutUint32_unfold :: MethodUnfold (littleEndian) "PutUint32" (littleEndian__PutUint32ⁱᵐᵖˡ);
  #[global] littleEndian_PutUint64_unfold :: MethodUnfold (littleEndian) "PutUint64" (littleEndian__PutUint64ⁱᵐᵖˡ);
  #[global] littleEndian_String_unfold :: MethodUnfold (littleEndian) "String" (littleEndian__Stringⁱᵐᵖˡ);
  #[global] littleEndian_Uint16_unfold :: MethodUnfold (littleEndian) "Uint16" (littleEndian__Uint16ⁱᵐᵖˡ);
  #[global] littleEndian_Uint32_unfold :: MethodUnfold (littleEndian) "Uint32" (littleEndian__Uint32ⁱᵐᵖˡ);
  #[global] littleEndian_Uint64_unfold :: MethodUnfold (littleEndian) "Uint64" (littleEndian__Uint64ⁱᵐᵖˡ);
  #[global] littleEndian'ptr_AppendUint16_unfold :: MethodUnfold (go.PointerType (littleEndian)) "AppendUint16" (λ: "$r", MethodResolve (littleEndian) "AppendUint16" (![(littleEndian)] "$r"));
  #[global] littleEndian'ptr_AppendUint32_unfold :: MethodUnfold (go.PointerType (littleEndian)) "AppendUint32" (λ: "$r", MethodResolve (littleEndian) "AppendUint32" (![(littleEndian)] "$r"));
  #[global] littleEndian'ptr_AppendUint64_unfold :: MethodUnfold (go.PointerType (littleEndian)) "AppendUint64" (λ: "$r", MethodResolve (littleEndian) "AppendUint64" (![(littleEndian)] "$r"));
  #[global] littleEndian'ptr_GoString_unfold :: MethodUnfold (go.PointerType (littleEndian)) "GoString" (λ: "$r", MethodResolve (littleEndian) "GoString" (![(littleEndian)] "$r"));
  #[global] littleEndian'ptr_PutUint16_unfold :: MethodUnfold (go.PointerType (littleEndian)) "PutUint16" (λ: "$r", MethodResolve (littleEndian) "PutUint16" (![(littleEndian)] "$r"));
  #[global] littleEndian'ptr_PutUint32_unfold :: MethodUnfold (go.PointerType (littleEndian)) "PutUint32" (λ: "$r", MethodResolve (littleEndian) "PutUint32" (![(littleEndian)] "$r"));
  #[global] littleEndian'ptr_PutUint64_unfold :: MethodUnfold (go.PointerType (littleEndian)) "PutUint64" (λ: "$r", MethodResolve (littleEndian) "PutUint64" (![(littleEndian)] "$r"));
  #[global] littleEndian'ptr_String_unfold :: MethodUnfold (go.PointerType (littleEndian)) "String" (λ: "$r", MethodResolve (littleEndian) "String" (![(littleEndian)] "$r"));
  #[global] littleEndian'ptr_Uint16_unfold :: MethodUnfold (go.PointerType (littleEndian)) "Uint16" (λ: "$r", MethodResolve (littleEndian) "Uint16" (![(littleEndian)] "$r"));
  #[global] littleEndian'ptr_Uint32_unfold :: MethodUnfold (go.PointerType (littleEndian)) "Uint32" (λ: "$r", MethodResolve (littleEndian) "Uint32" (![(littleEndian)] "$r"));
  #[global] littleEndian'ptr_Uint64_unfold :: MethodUnfold (go.PointerType (littleEndian)) "Uint64" (λ: "$r", MethodResolve (littleEndian) "Uint64" (![(littleEndian)] "$r"));
}.

Module bigEndian.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End bigEndian.

Class bigEndian_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] bigEndian_type_repr  :: go.TypeReprUnderlying bigEndianⁱᵐᵖˡ bigEndian.t;
  #[global] bigEndian_underlying :: (bigEndian) <u (bigEndianⁱᵐᵖˡ);
  #[global] bigEndianⁱᵐᵖˡ_underlying :: (bigEndianⁱᵐᵖˡ) ↓u (bigEndianⁱᵐᵖˡ);
}.

Module coder.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End coder.

Class coder_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] coder_type_repr  :: go.TypeReprUnderlying coderⁱᵐᵖˡ coder.t;
  #[global] coder_underlying :: (coder) <u (coderⁱᵐᵖˡ);
  #[global] coderⁱᵐᵖˡ_underlying :: (coderⁱᵐᵖˡ) ↓u (coderⁱᵐᵖˡ);
}.

Module decoder.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End decoder.

Class decoder_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] decoder_type_repr  :: go.TypeReprUnderlying decoderⁱᵐᵖˡ decoder.t;
  #[global] decoder_underlying :: (decoder) <u (decoderⁱᵐᵖˡ);
  #[global] decoderⁱᵐᵖˡ_underlying :: (decoderⁱᵐᵖˡ) ↓u (decoderⁱᵐᵖˡ);
}.

Module encoder.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End encoder.

Class encoder_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] encoder_type_repr  :: go.TypeReprUnderlying encoderⁱᵐᵖˡ encoder.t;
  #[global] encoder_underlying :: (encoder) <u (encoderⁱᵐᵖˡ);
  #[global] encoderⁱᵐᵖˡ_underlying :: (encoderⁱᵐᵖˡ) ↓u (encoderⁱᵐᵖˡ);
}.

Module nativeEndian.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End nativeEndian.

Class nativeEndian_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] nativeEndian_type_repr  :: go.TypeReprUnderlying nativeEndianⁱᵐᵖˡ nativeEndian.t;
  #[global] nativeEndian_underlying :: (nativeEndian) <u (nativeEndianⁱᵐᵖˡ);
  #[global] nativeEndianⁱᵐᵖˡ_underlying :: (nativeEndianⁱᵐᵖˡ) ↓u (nativeEndianⁱᵐᵖˡ);
}.

Class Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] ByteOrder_instance :: ByteOrder_Assumptions;
  #[global] AppendByteOrder_instance :: AppendByteOrder_Assumptions;
  #[global] littleEndian_instance :: littleEndian_Assumptions;
  #[global] bigEndian_instance :: bigEndian_Assumptions;
  #[global] coder_instance :: coder_Assumptions;
  #[global] decoder_instance :: decoder_Assumptions;
  #[global] encoder_instance :: encoder_Assumptions;
  #[global] nativeEndian_instance :: nativeEndian_Assumptions;
  #[global] import_errors_Assumption :: errors.Assumptions;
  #[global] import_io_Assumption :: io.Assumptions;
  #[global] import_math_Assumption :: math.Assumptions;
  #[global] import_slices_Assumption :: slices.Assumptions;
  #[global] import_sync_Assumption :: sync.Assumptions;
}.
End binary.
