(* autogenerated from github.com/goose-lang/goose/testdata/examples/channel *)
Require Export New.code.github_com.goose_lang.goose.model.channel.
Require Export New.code.strings.

From New.golang Require Import defn.
Definition chan_spec_raw_examples : go_string := "github.com/goose-lang/goose/testdata/examples/channel".

Module chan_spec_raw_examples.

Section code.
Context `{ffi_syntax}.


Definition SendMessage : go_string := "github.com/goose-lang/goose/testdata/examples/channel.SendMessage"%go.

(* Example 1: Simple goroutine sending a string, check basic message passing without
   synchronization

   go: examples.go:14:6 *)
Definition SendMessageⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "messageChan" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := #(W64 0) in
    (func_call #channel.NewChannelRef #stringT) "$a0") in
    do:  ("messageChan" <-[#ptrT] "$r0");;;
    let: "$go" := (λ: <>,
      exception_do (do:  (let: "$a0" := #"hello world"%go in
      (method_call #(ptrT.id channel.Channel.id) #"Send"%go (![#ptrT] "messageChan") #stringT) "$a0");;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    let: "message" := (mem.alloc (type.zero_val #stringT)) in
    let: "$r0" := ((method_call #(ptrT.id channel.Channel.id) #"ReceiveDiscardOk"%go (![#ptrT] "messageChan") #stringT) #()) in
    do:  ("message" <-[#stringT] "$r0");;;
    (if: (![#stringT] "message") ≠ #"hello world"%go
    then
      do:  (let: "$a0" := (interface.make #stringT.id #"Did not receive expected message"%go) in
      Panic "$a0")
    else do:  #());;;
    return: #()).

Definition JoinWithReceive : go_string := "github.com/goose-lang/goose/testdata/examples/channel.JoinWithReceive"%go.

(* Example 2: Join goroutine with receive on unbuffered channel

   go: examples.go:33:6 *)
Definition JoinWithReceiveⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "message" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #stringT)) in
    do:  ("message" <-[#ptrT] "$r0");;;
    let: "done" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := #(W64 0) in
    (func_call #channel.NewChannelRef #uint64T) "$a0") in
    do:  ("done" <-[#ptrT] "$r0");;;
    let: "$go" := (λ: <>,
      exception_do (let: "$r0" := #"hello world"%go in
      do:  ((![#ptrT] "message") <-[#stringT] "$r0");;;
      do:  (let: "$a0" := #(W64 0) in
      (method_call #(ptrT.id channel.Channel.id) #"Send"%go (![#ptrT] "done") #uint64T) "$a0");;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    do:  ((method_call #(ptrT.id channel.Channel.id) #"ReceiveDiscardOk"%go (![#ptrT] "done") #uint64T) #());;;
    (if: (![#stringT] (![#ptrT] "message")) ≠ #"hello world"%go
    then
      do:  (let: "$a0" := (interface.make #stringT.id #"Message was not set correctly"%go) in
      Panic "$a0")
    else do:  #());;;
    return: #()).

Definition JoinWithSend : go_string := "github.com/goose-lang/goose/testdata/examples/channel.JoinWithSend"%go.

(* Example 3: Join goroutine with send on unbuffered channel

   go: examples.go:59:6 *)
Definition JoinWithSendⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "message" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #stringT)) in
    do:  ("message" <-[#ptrT] "$r0");;;
    let: "done" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := #(W64 0) in
    (func_call #channel.NewChannelRef #uint64T) "$a0") in
    do:  ("done" <-[#ptrT] "$r0");;;
    let: "$go" := (λ: <>,
      exception_do (let: "$r0" := #"hello world"%go in
      do:  ((![#ptrT] "message") <-[#stringT] "$r0");;;
      do:  ((method_call #(ptrT.id channel.Channel.id) #"ReceiveDiscardOk"%go (![#ptrT] "done") #uint64T) #());;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    do:  (let: "$a0" := #(W64 0) in
    (method_call #(ptrT.id channel.Channel.id) #"Send"%go (![#ptrT] "done") #uint64T) "$a0");;;
    (if: (![#stringT] (![#ptrT] "message")) ≠ #"hello world"%go
    then
      do:  (let: "$a0" := (interface.make #stringT.id #"Message was not set correctly"%go) in
      Panic "$a0")
    else do:  #());;;
    return: #()).

Definition BroadcastNotification : go_string := "github.com/goose-lang/goose/testdata/examples/channel.BroadcastNotification"%go.

(* Example 4: Broadcast notification with close. This is testing a case where
   we transfer disjoint ownership to different threads in a single broadcast

   go: examples.go:86:6 *)
Definition BroadcastNotificationⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "notifyCh" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := #(W64 0) in
    (func_call #channel.NewChannelRef #uint64T) "$a0") in
    do:  ("notifyCh" <-[#ptrT] "$r0");;;
    let: "done1" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := #(W64 0) in
    (func_call #channel.NewChannelRef #uint64T) "$a0") in
    do:  ("done1" <-[#ptrT] "$r0");;;
    let: "done2" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := #(W64 0) in
    (func_call #channel.NewChannelRef #uint64T) "$a0") in
    do:  ("done2" <-[#ptrT] "$r0");;;
    let: "done3" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := #(W64 0) in
    (func_call #channel.NewChannelRef #uint64T) "$a0") in
    do:  ("done3" <-[#ptrT] "$r0");;;
    let: "results" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "results") in
    let: "$a1" := ((let: "$sl0" := #""%go in
    slice.literal #stringT ["$sl0"])) in
    (slice.append #stringT) "$a0" "$a1") in
    do:  ("results" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "results") in
    let: "$a1" := ((let: "$sl0" := #""%go in
    slice.literal #stringT ["$sl0"])) in
    (slice.append #stringT) "$a0" "$a1") in
    do:  ("results" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "results") in
    let: "$a1" := ((let: "$sl0" := #""%go in
    slice.literal #stringT ["$sl0"])) in
    (slice.append #stringT) "$a0" "$a1") in
    do:  ("results" <-[#sliceT] "$r0");;;
    let: "$go" := (λ: <>,
      exception_do (let: "ok" := (mem.alloc (type.zero_val #boolT)) in
      let: ("$ret0", "$ret1") := ((method_call #(ptrT.id channel.Channel.id) #"Receive"%go (![#ptrT] "notifyCh") #uint64T) #()) in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  "$r0";;;
      do:  ("ok" <-[#boolT] "$r1");;;
      (if: (~ (![#boolT] "ok"))
      then
        (if: (![#stringT] (slice.elem_ref #stringT (![#sliceT] "results") #(W64 0))) ≠ #"thread1"%go
        then
          do:  (let: "$a0" := (interface.make #stringT.id #"Thread 1 received incorrect value"%go) in
          Panic "$a0")
        else do:  #());;;
        do:  (let: "$a0" := #(W64 0) in
        (method_call #(ptrT.id channel.Channel.id) #"Send"%go (![#ptrT] "done1") #uint64T) "$a0")
      else do:  #());;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    let: "$go" := (λ: <>,
      exception_do (let: "ok" := (mem.alloc (type.zero_val #boolT)) in
      let: ("$ret0", "$ret1") := ((method_call #(ptrT.id channel.Channel.id) #"Receive"%go (![#ptrT] "notifyCh") #uint64T) #()) in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  "$r0";;;
      do:  ("ok" <-[#boolT] "$r1");;;
      (if: (~ (![#boolT] "ok"))
      then
        (if: (![#stringT] (slice.elem_ref #stringT (![#sliceT] "results") #(W64 1))) ≠ #"thread2"%go
        then
          do:  (let: "$a0" := (interface.make #stringT.id #"Thread 2 received incorrect value"%go) in
          Panic "$a0")
        else do:  #());;;
        do:  (let: "$a0" := #(W64 0) in
        (method_call #(ptrT.id channel.Channel.id) #"Send"%go (![#ptrT] "done2") #uint64T) "$a0")
      else do:  #());;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    let: "$go" := (λ: <>,
      exception_do (let: "ok" := (mem.alloc (type.zero_val #boolT)) in
      let: ("$ret0", "$ret1") := ((method_call #(ptrT.id channel.Channel.id) #"Receive"%go (![#ptrT] "notifyCh") #uint64T) #()) in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  "$r0";;;
      do:  ("ok" <-[#boolT] "$r1");;;
      (if: (~ (![#boolT] "ok"))
      then
        (if: (![#stringT] (slice.elem_ref #stringT (![#sliceT] "results") #(W64 2))) ≠ #"thread3"%go
        then
          do:  (let: "$a0" := (interface.make #stringT.id #"Thread 3 received incorrect value"%go) in
          Panic "$a0")
        else do:  #());;;
        do:  (let: "$a0" := #(W64 0) in
        (method_call #(ptrT.id channel.Channel.id) #"Send"%go (![#ptrT] "done3") #uint64T) "$a0")
      else do:  #());;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    let: "$r0" := #"thread1"%go in
    do:  ((slice.elem_ref #stringT (![#sliceT] "results") #(W64 0)) <-[#stringT] "$r0");;;
    let: "$r0" := #"thread2"%go in
    do:  ((slice.elem_ref #stringT (![#sliceT] "results") #(W64 1)) <-[#stringT] "$r0");;;
    let: "$r0" := #"thread3"%go in
    do:  ((slice.elem_ref #stringT (![#sliceT] "results") #(W64 2)) <-[#stringT] "$r0");;;
    do:  ((method_call #(ptrT.id channel.Channel.id) #"Close"%go (![#ptrT] "notifyCh") #uint64T) #());;;
    do:  ((method_call #(ptrT.id channel.Channel.id) #"ReceiveDiscardOk"%go (![#ptrT] "done1") #uint64T) #());;;
    do:  ((method_call #(ptrT.id channel.Channel.id) #"ReceiveDiscardOk"%go (![#ptrT] "done2") #uint64T) #());;;
    do:  ((method_call #(ptrT.id channel.Channel.id) #"ReceiveDiscardOk"%go (![#ptrT] "done3") #uint64T) #());;;
    return: #()).

Definition CoordinatedChannelClose : go_string := "github.com/goose-lang/goose/testdata/examples/channel.CoordinatedChannelClose"%go.

(* Example 5: Join sending goroutine before closing a buffered channel.
   This should demonstrate the spec's ability to prevent closing on a channel
   without joining all the senders.

   go: examples.go:153:6 *)
Definition CoordinatedChannelCloseⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "bufCh" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := #(W64 2) in
    (func_call #channel.NewChannelRef #uint64T) "$a0") in
    do:  ("bufCh" <-[#ptrT] "$r0");;;
    let: "syncCh" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := #(W64 0) in
    (func_call #channel.NewChannelRef #uint64T) "$a0") in
    do:  ("syncCh" <-[#ptrT] "$r0");;;
    let: "$go" := (λ: <>,
      exception_do (do:  (let: "$a0" := #(W64 42) in
      (method_call #(ptrT.id channel.Channel.id) #"Send"%go (![#ptrT] "bufCh") #uint64T) "$a0");;;
      do:  (let: "$a0" := #(W64 0) in
      (method_call #(ptrT.id channel.Channel.id) #"Send"%go (![#ptrT] "syncCh") #uint64T) "$a0");;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    do:  (let: "$a0" := #(W64 84) in
    (method_call #(ptrT.id channel.Channel.id) #"Send"%go (![#ptrT] "bufCh") #uint64T) "$a0");;;
    do:  ((method_call #(ptrT.id channel.Channel.id) #"ReceiveDiscardOk"%go (![#ptrT] "syncCh") #uint64T) #());;;
    do:  ((method_call #(ptrT.id channel.Channel.id) #"Close"%go (![#ptrT] "bufCh") #uint64T) #());;;
    let: "ok1" := (mem.alloc (type.zero_val #boolT)) in
    let: "val1" := (mem.alloc (type.zero_val #uint64T)) in
    let: ("$ret0", "$ret1") := ((method_call #(ptrT.id channel.Channel.id) #"Receive"%go (![#ptrT] "bufCh") #uint64T) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("val1" <-[#uint64T] "$r0");;;
    do:  ("ok1" <-[#boolT] "$r1");;;
    let: "ok2" := (mem.alloc (type.zero_val #boolT)) in
    let: "val2" := (mem.alloc (type.zero_val #uint64T)) in
    let: ("$ret0", "$ret1") := ((method_call #(ptrT.id channel.Channel.id) #"Receive"%go (![#ptrT] "bufCh") #uint64T) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("val2" <-[#uint64T] "$r0");;;
    do:  ("ok2" <-[#boolT] "$r1");;;
    (if: (~ (![#boolT] "ok1")) || (~ (![#boolT] "ok2"))
    then
      do:  (let: "$a0" := (interface.make #stringT.id #"Channel shouldn't be empty yet"%go) in
      Panic "$a0")
    else do:  #());;;
    (if: (~ ((((![#uint64T] "val1") = #(W64 42)) && ((![#uint64T] "val2") = #(W64 84))) || (((![#uint64T] "val1") = #(W64 84)) && ((![#uint64T] "val2") = #(W64 42)))))
    then
      do:  (let: "$a0" := (interface.make #stringT.id #"Did not receive both expected values"%go) in
      Panic "$a0")
    else do:  #());;;
    return: #()).

Definition DoubleValues : go_string := "github.com/goose-lang/goose/testdata/examples/channel.DoubleValues"%go.

(* Example 6: A basic pipeline that just passes pointers
   to a single worker who doubles the value of what they
   point to.

   go: examples.go:193:6 *)
Definition DoubleValuesⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "val1" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 5) in
    do:  ("val1" <-[#uint64T] "$r0");;;
    let: "val2" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 10) in
    do:  ("val2" <-[#uint64T] "$r0");;;
    let: "val3" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 15) in
    do:  ("val3" <-[#uint64T] "$r0");;;
    let: "values" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "values") in
    let: "$a1" := ((let: "$sl0" := "val1" in
    slice.literal #ptrT ["$sl0"])) in
    (slice.append #ptrT) "$a0" "$a1") in
    do:  ("values" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "values") in
    let: "$a1" := ((let: "$sl0" := "val2" in
    slice.literal #ptrT ["$sl0"])) in
    (slice.append #ptrT) "$a0" "$a1") in
    do:  ("values" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "values") in
    let: "$a1" := ((let: "$sl0" := "val3" in
    slice.literal #ptrT ["$sl0"])) in
    (slice.append #ptrT) "$a0" "$a1") in
    do:  ("values" <-[#sliceT] "$r0");;;
    let: "ch" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := #(W64 0) in
    (func_call #channel.NewChannelRef #ptrT) "$a0") in
    do:  ("ch" <-[#ptrT] "$r0");;;
    let: "done" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := #(W64 0) in
    (func_call #channel.NewChannelRef #uint64T) "$a0") in
    do:  ("done" <-[#ptrT] "$r0");;;
    let: "$go" := (λ: <>,
      exception_do ((for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
        let: "ok" := (mem.alloc (type.zero_val #boolT)) in
        let: "ptr" := (mem.alloc (type.zero_val #ptrT)) in
        let: ("$ret0", "$ret1") := ((method_call #(ptrT.id channel.Channel.id) #"Receive"%go (![#ptrT] "ch") #ptrT) #()) in
        let: "$r0" := "$ret0" in
        let: "$r1" := "$ret1" in
        do:  ("ptr" <-[#ptrT] "$r0");;;
        do:  ("ok" <-[#boolT] "$r1");;;
        (if: (~ (![#boolT] "ok"))
        then break: #()
        else do:  #());;;
        let: "$r0" := ((![#uint64T] (![#ptrT] "ptr")) * #(W64 2)) in
        do:  ((![#ptrT] "ptr") <-[#uint64T] "$r0"));;;
      do:  ((method_call #(ptrT.id channel.Channel.id) #"Close"%go (![#ptrT] "done") #uint64T) #());;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    do:  (let: "$a0" := (![#ptrT] (slice.elem_ref #ptrT (![#sliceT] "values") #(W64 0))) in
    (method_call #(ptrT.id channel.Channel.id) #"Send"%go (![#ptrT] "ch") #ptrT) "$a0");;;
    do:  (let: "$a0" := (![#ptrT] (slice.elem_ref #ptrT (![#sliceT] "values") #(W64 1))) in
    (method_call #(ptrT.id channel.Channel.id) #"Send"%go (![#ptrT] "ch") #ptrT) "$a0");;;
    do:  (let: "$a0" := (![#ptrT] (slice.elem_ref #ptrT (![#sliceT] "values") #(W64 2))) in
    (method_call #(ptrT.id channel.Channel.id) #"Send"%go (![#ptrT] "ch") #ptrT) "$a0");;;
    do:  ((method_call #(ptrT.id channel.Channel.id) #"Close"%go (![#ptrT] "ch") #ptrT) #());;;
    do:  ((method_call #(ptrT.id channel.Channel.id) #"Receive"%go (![#ptrT] "done") #uint64T) #());;;
    (if: (~ ((((![#uint64T] "val1") = #(W64 10)) && ((![#uint64T] "val2") = #(W64 20))) && ((![#uint64T] "val3") = #(W64 30))))
    then
      do:  (let: "$a0" := (interface.make #stringT.id #"Values were not doubled correctly"%go) in
      Panic "$a0")
    else do:  #());;;
    return: #()).

Definition CapPipeline : go_string := "github.com/goose-lang/goose/testdata/examples/channel.CapPipeline"%go.

Definition consumer : go_string := "github.com/goose-lang/goose/testdata/examples/channel.consumer"%go.

Definition producer : go_string := "github.com/goose-lang/goose/testdata/examples/channel.producer"%go.

(* Equivalent runtime channel code:

   		func CapPipeline() string {
   		    // Input data
   		    input := []string{"hello", ",", " ", "world", "!"}

   		    // The pipe for the producer to send to the consumer.
   		    // Buffer size does not matter for correctness.
   		    data := make(chan string, 2)

   		    // Unbuffered channel to signal completion
   		    join := make(chan struct{})
   		    output := ""

   		    // Start goroutines
   		    go producer(input, data)
   		    go consumer(&output, data, join)

   		    // Wait for pipeline to be processed
   		    <-join
   	     	if output != "HELLO, WORLD!" {
   				panic("test failed, plus you can't verify this!")
   			}
   		}

   go: examples.go:259:6 *)
Definition CapPipelineⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "input" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := ((let: "$sl0" := #"hello"%go in
    let: "$sl1" := #","%go in
    let: "$sl2" := #" "%go in
    let: "$sl3" := #"world"%go in
    let: "$sl4" := #"!"%go in
    slice.literal #stringT ["$sl0"; "$sl1"; "$sl2"; "$sl3"; "$sl4"])) in
    do:  ("input" <-[#sliceT] "$r0");;;
    let: "data" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := #(W64 2) in
    (func_call #channel.NewChannelRef #stringT) "$a0") in
    do:  ("data" <-[#ptrT] "$r0");;;
    let: "join" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := #(W64 0) in
    (func_call #channel.NewChannelRef (type.structT [
    ])) "$a0") in
    do:  ("join" <-[#ptrT] "$r0");;;
    let: "output" := (mem.alloc (type.zero_val #stringT)) in
    let: "$r0" := #""%go in
    do:  ("output" <-[#stringT] "$r0");;;
    let: "$a0" := (![#sliceT] "input") in
    let: "$a1" := (![#ptrT] "data") in
    let: "$go" := (func_call #producer) in
    do:  (Fork ("$go" "a0" "a1"));;;
    let: "$a0" := "output" in
    let: "$a1" := (![#ptrT] "data") in
    let: "$a2" := (![#ptrT] "join") in
    let: "$go" := (func_call #consumer) in
    do:  (Fork ("$go" "a0" "a1" "a2"));;;
    do:  ((method_call #(ptrT.id channel.Channel.id) #"ReceiveDiscardOk"%go (![#ptrT] "join") (type.structT [
    ])) #());;;
    (if: (![#stringT] "output") ≠ #"HELLO, WORLD!"%go
    then
      do:  (let: "$a0" := (interface.make #stringT.id #"test failed, plus you can't verify this!"%go) in
      Panic "$a0")
    else do:  #());;;
    return: #()).

(* Equivalent runtime channel Go code:

   	func producer(input []string, data chan<- string) {
   	    // Send each item
   	    for _, item := range input {
   	        data <- item
   	    }
   	    // Signal producer we’ve sent everything
   	    close(data)
   	}

   go: examples.go:292:6 *)
Definition producerⁱᵐᵖˡ : val :=
  λ: "input" "data",
    exception_do (let: "data" := (mem.alloc "data") in
    let: "input" := (mem.alloc "input") in
    let: "$range" := (![#sliceT] "input") in
    (let: "item" := (mem.alloc (type.zero_val #stringT)) in
    slice.for_range #stringT "$range" (λ: "$key" "$value",
      do:  ("item" <-[#stringT] "$value");;;
      do:  "$key";;;
      do:  (let: "$a0" := (![#stringT] "item") in
      (method_call #(ptrT.id channel.Channel.id) #"Send"%go (![#ptrT] "data") #stringT) "$a0")));;;
    do:  ((method_call #(ptrT.id channel.Channel.id) #"Close"%go (![#ptrT] "data") #stringT) #());;;
    return: #()).

(* Equivalent runtime channel Go code:

   	func consumer(output *string, data <-chan string, join chan<- struct{}) {
   	    // Keep receiving until channel is closed
   	    for item := range data {
   	        *output += strings.ToUpper(item)
   	    }

   	    // Tell main we’re done
   	    join <- struct{}{}
   	}

   go: examples.go:312:6 *)
Definition consumerⁱᵐᵖˡ : val :=
  λ: "output" "data" "join",
    exception_do (let: "join" := (mem.alloc "join") in
    let: "data" := (mem.alloc "data") in
    let: "output" := (mem.alloc "output") in
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "ok" := (mem.alloc (type.zero_val #boolT)) in
      let: "item" := (mem.alloc (type.zero_val #stringT)) in
      let: ("$ret0", "$ret1") := ((method_call #(ptrT.id channel.Channel.id) #"Receive"%go (![#ptrT] "data") #stringT) #()) in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("item" <-[#stringT] "$r0");;;
      do:  ("ok" <-[#boolT] "$r1");;;
      (if: (~ (![#boolT] "ok"))
      then break: #()
      else do:  #());;;
      do:  ((![#ptrT] "output") <-[#stringT] ((![#stringT] (![#ptrT] "output")) + (let: "$a0" := (![#stringT] "item") in
      (func_call #strings.ToUpper) "$a0"))));;;
    do:  (let: "$a0" := (struct.make (type.structT [
    ]) [{
    }]) in
    (method_call #(ptrT.id channel.Channel.id) #"Send"%go (![#ptrT] "join") (type.structT [
    ])) "$a0");;;
    return: #()).

Definition SelectRace : go_string := "github.com/goose-lang/goose/testdata/examples/channel.SelectRace"%go.

(* Equivalent Go code:

   	func SelectRace() {
   	    alice := make(chan string, 1)
   	    bob := make(chan string, 1)
   	    result := ""

   	    // 2 goroutines race to write result and notify main that they won.
   	    // The loser's message will be ignored.
   	    go func() { alice <- "Alice wins" }()
   	    go func() { bob <- "Bob wins" }()

   	    select {
   	    case msg := <-alice:
   	        result = msg
   	    case msg := <-bob:
   	        result = msg
   	    }

   	    if !(result == "Alice wins" || result == "Bob wins") {
   	        panic("test failed, plus you can't verify this!")
   	    }
   	}

   go: examples.go:349:6 *)
Definition SelectRaceⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "alice" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := #(W64 1) in
    (func_call #channel.NewChannelRef #stringT) "$a0") in
    do:  ("alice" <-[#ptrT] "$r0");;;
    let: "bob" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := #(W64 1) in
    (func_call #channel.NewChannelRef #stringT) "$a0") in
    do:  ("bob" <-[#ptrT] "$r0");;;
    let: "result" := (mem.alloc (type.zero_val #stringT)) in
    let: "$r0" := #""%go in
    do:  ("result" <-[#stringT] "$r0");;;
    let: "$go" := (λ: <>,
      exception_do (do:  (let: "$a0" := #"Alice wins"%go in
      (method_call #(ptrT.id channel.Channel.id) #"Send"%go (![#ptrT] "alice") #stringT) "$a0");;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    let: "$go" := (λ: <>,
      exception_do (do:  (let: "$a0" := #"Bob wins"%go in
      (method_call #(ptrT.id channel.Channel.id) #"Send"%go (![#ptrT] "bob") #stringT) "$a0");;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    let: "alice_case" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := (![#ptrT] "alice") in
    (func_call #channel.NewRecvCase #stringT) "$a0") in
    do:  ("alice_case" <-[#ptrT] "$r0");;;
    let: "bob_case" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := (![#ptrT] "bob") in
    (func_call #channel.NewRecvCase #stringT) "$a0") in
    do:  ("bob_case" <-[#ptrT] "$r0");;;
    let: "winner" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (let: "$a0" := (![#ptrT] "alice_case") in
    let: "$a1" := (![#ptrT] "bob_case") in
    let: "$a2" := #true in
    (func_call #channel.Select2 #stringT #stringT) "$a0" "$a1" "$a2") in
    do:  ("winner" <-[#uint64T] "$r0");;;
    let: "$sw" := (![#uint64T] "winner") in
    (if: "$sw" = #(W64 0)
    then
      let: "$r0" := (![#stringT] (struct.field_ref (channel.SelectCase #stringT) #"Value"%go (![#ptrT] "alice_case"))) in
      do:  ("result" <-[#stringT] "$r0")
    else
      (if: "$sw" = #(W64 1)
      then
        let: "$r0" := (![#stringT] (struct.field_ref (channel.SelectCase #stringT) #"Value"%go (![#ptrT] "bob_case"))) in
        do:  ("result" <-[#stringT] "$r0")
      else do:  #()));;;
    (if: (~ (((![#stringT] "result") = #"Alice wins"%go) || ((![#stringT] "result") = #"Bob wins"%go)))
    then
      do:  (let: "$a0" := (interface.make #stringT.id #"test failed, plus you can't verify this!"%go) in
      Panic "$a0")
    else do:  #());;;
    return: #()).

Definition load : go_string := "github.com/goose-lang/goose/testdata/examples/channel.load"%go.

(* load writes the next letter into the buffer.

   go: examples.go:378:6 *)
Definition loadⁱᵐᵖˡ : val :=
  λ: "b" "letter",
    exception_do (let: "letter" := (mem.alloc "letter") in
    let: "b" := (mem.alloc "b") in
    let: "$r0" := (string.to_bytes (![#stringT] "letter")) in
    do:  ((![#ptrT] "b") <-[#sliceT] "$r0");;;
    return: #()).

Definition process : go_string := "github.com/goose-lang/goose/testdata/examples/channel.process"%go.

(* process consumes the buffer and appends it to the output.

   go: examples.go:383:6 *)
Definition processⁱᵐᵖˡ : val :=
  λ: "b" "output",
    exception_do (let: "output" := (mem.alloc "output") in
    let: "b" := (mem.alloc "b") in
    do:  ((![#ptrT] "output") <-[#stringT] ((![#stringT] (![#ptrT] "output")) + (let: "$a0" := (string.from_bytes (![#sliceT] (![#ptrT] "b"))) in
    (func_call #strings.ToUpper) "$a0")));;;
    return: #()).

Definition client : go_string := "github.com/goose-lang/goose/testdata/examples/channel.client"%go.

(* Equivalent Go runtime channel code:

   	func client(input []string, freeList chan []byte, serverChan chan []byte) {
   		for _, letter := range input {
   			var b []byte

   			// Non-blocking receive from freeList.
   			select {
   			case b = <-freeList:
   				// Reuse buffer from pool.
   			default:
   				// Allocate a new minimal buffer.
   				b = []byte{0}
   			}

   			load(&b, letter) // Put one letter into the buffer.
   			serverChan <- b  // Blocking send to server.
   		}

   		// Signal no more work.
   		close(serverChan)
   	}

   go: examples.go:409:6 *)
Definition clientⁱᵐᵖˡ : val :=
  λ: "input" "freeList" "serverChan",
    exception_do (let: "serverChan" := (mem.alloc "serverChan") in
    let: "freeList" := (mem.alloc "freeList") in
    let: "input" := (mem.alloc "input") in
    let: "$range" := (![#sliceT] "input") in
    (let: "letter" := (mem.alloc (type.zero_val #stringT)) in
    slice.for_range #stringT "$range" (λ: "$key" "$value",
      do:  ("letter" <-[#stringT] "$value");;;
      do:  "$key";;;
      let: "b" := (mem.alloc (type.zero_val #sliceT)) in
      let: "rc" := (mem.alloc (type.zero_val #ptrT)) in
      let: "$r0" := (let: "$a0" := (![#ptrT] "freeList") in
      (func_call #channel.NewRecvCase #sliceT) "$a0") in
      do:  ("rc" <-[#ptrT] "$r0");;;
      (if: let: "$a0" := (![#ptrT] "rc") in
      let: "$a1" := #false in
      (func_call #channel.Select1 #sliceT) "$a0" "$a1"
      then
        let: "$r0" := (![#sliceT] (struct.field_ref (channel.SelectCase #sliceT) #"Value"%go (![#ptrT] "rc"))) in
        do:  ("b" <-[#sliceT] "$r0")
      else
        let: "$r0" := ((let: "$sl0" := #(W8 0) in
        slice.literal #byteT ["$sl0"])) in
        do:  ("b" <-[#sliceT] "$r0"));;;
      do:  (let: "$a0" := "b" in
      let: "$a1" := (![#stringT] "letter") in
      (func_call #load) "$a0" "$a1");;;
      do:  (let: "$a0" := (![#sliceT] "b") in
      (method_call #(ptrT.id channel.Channel.id) #"Send"%go (![#ptrT] "serverChan") #sliceT) "$a0")));;;
    do:  ((method_call #(ptrT.id channel.Channel.id) #"Close"%go (![#ptrT] "serverChan") #sliceT) #());;;
    return: #()).

Definition server : go_string := "github.com/goose-lang/goose/testdata/examples/channel.server"%go.

(* Equivalent Go runtime code:

   	func server(output *string, freeList chan []byte, serverChan chan []byte, done chan struct{}) {
   		for {
   			// Blocking receive from serverChan.
   			b, ok := <-serverChan
   			if !ok {
   				// Channel closed and drained.
   				done <- struct{}{}
   				return
   			}

   			process(&b, output)

   			// Non-blocking return of buffer to freeList; drop if pool full.
   			select {
   			case freeList <- b:
   				// Returned to pool.
   			default:
   				// Pool full; drop buffer.
   			}
   		}
   	}

   go: examples.go:451:6 *)
Definition serverⁱᵐᵖˡ : val :=
  λ: "output" "freeList" "serverChan" "join",
    exception_do (let: "join" := (mem.alloc "join") in
    let: "serverChan" := (mem.alloc "serverChan") in
    let: "freeList" := (mem.alloc "freeList") in
    let: "output" := (mem.alloc "output") in
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "ok" := (mem.alloc (type.zero_val #boolT)) in
      let: "b" := (mem.alloc (type.zero_val #sliceT)) in
      let: ("$ret0", "$ret1") := ((method_call #(ptrT.id channel.Channel.id) #"Receive"%go (![#ptrT] "serverChan") #sliceT) #()) in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("b" <-[#sliceT] "$r0");;;
      do:  ("ok" <-[#boolT] "$r1");;;
      (if: (~ (![#boolT] "ok"))
      then
        do:  (let: "$a0" := (struct.make (type.structT [
        ]) [{
        }]) in
        (method_call #(ptrT.id channel.Channel.id) #"Send"%go (![#ptrT] "join") (type.structT [
        ])) "$a0");;;
        return: (#())
      else do:  #());;;
      do:  (let: "$a0" := "b" in
      let: "$a1" := (![#ptrT] "output") in
      (func_call #process) "$a0" "$a1");;;
      let: "sc" := (mem.alloc (type.zero_val #ptrT)) in
      let: "$r0" := (let: "$a0" := (![#ptrT] "freeList") in
      let: "$a1" := (![#sliceT] "b") in
      (func_call #channel.NewSendCase #sliceT) "$a0" "$a1") in
      do:  ("sc" <-[#ptrT] "$r0");;;
      do:  (let: "$a0" := (![#ptrT] "sc") in
      let: "$a1" := #false in
      (func_call #channel.Select1 #sliceT) "$a0" "$a1"));;;
    return: #()).

Definition LeakyBufferPipeline : go_string := "github.com/goose-lang/goose/testdata/examples/channel.LeakyBufferPipeline"%go.

(* Equivalent Go runtime code:

   	func LeakyBufferPipeline() {
   		freeList := make(chan []byte, 5) // buffer pool
   		serverChan := make(chan []byte, 0)
   		done := make(chan struct{}, 0)

   		output := ""

   		go server(&output, freeList, serverChan, done)
   		client([]string{"h", "e", "l", "l", "o", ",", " ", "w", "o", "r", "l", "d"}, freeList, serverChan)
   		<-done

   		// At this point, server finished because client closed serverChan.
   		if output != "HELLO, WORLD" {
   			panic("unexpected pipeline output: " + output)
   		}
   	}

   go: examples.go:491:6 *)
Definition LeakyBufferPipelineⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "freeList" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := #(W64 0) in
    (func_call #channel.NewChannelRef #sliceT) "$a0") in
    do:  ("freeList" <-[#ptrT] "$r0");;;
    let: "serverChan" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := #(W64 0) in
    (func_call #channel.NewChannelRef #sliceT) "$a0") in
    do:  ("serverChan" <-[#ptrT] "$r0");;;
    let: "join" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := #(W64 0) in
    (func_call #channel.NewChannelRef (type.structT [
    ])) "$a0") in
    do:  ("join" <-[#ptrT] "$r0");;;
    let: "output" := (mem.alloc (type.zero_val #stringT)) in
    let: "$r0" := #""%go in
    do:  ("output" <-[#stringT] "$r0");;;
    let: "$a0" := "output" in
    let: "$a1" := (![#ptrT] "freeList") in
    let: "$a2" := (![#ptrT] "serverChan") in
    let: "$a3" := (![#ptrT] "join") in
    let: "$go" := (func_call #server) in
    do:  (Fork ("$go" "a0" "a1" "a2" "a3"));;;
    do:  (let: "$a0" := ((let: "$sl0" := #"h"%go in
    let: "$sl1" := #"e"%go in
    let: "$sl2" := #"l"%go in
    let: "$sl3" := #"l"%go in
    let: "$sl4" := #"o"%go in
    let: "$sl5" := #","%go in
    let: "$sl6" := #" "%go in
    let: "$sl7" := #"w"%go in
    let: "$sl8" := #"o"%go in
    let: "$sl9" := #"r"%go in
    let: "$sl10" := #"l"%go in
    let: "$sl11" := #"d"%go in
    slice.literal #stringT ["$sl0"; "$sl1"; "$sl2"; "$sl3"; "$sl4"; "$sl5"; "$sl6"; "$sl7"; "$sl8"; "$sl9"; "$sl10"; "$sl11"])) in
    let: "$a1" := (![#ptrT] "freeList") in
    let: "$a2" := (![#ptrT] "serverChan") in
    (func_call #client) "$a0" "$a1" "$a2");;;
    do:  ((method_call #(ptrT.id channel.Channel.id) #"Receive"%go (![#ptrT] "join") (type.structT [
    ])) #());;;
    (if: (![#stringT] "output") ≠ #"HELLO, WORLD"%go
    then
      do:  (let: "$a0" := (interface.make #stringT.id (#"unexpected pipeline output: "%go + (![#stringT] "output"))) in
      Panic "$a0")
    else do:  #());;;
    return: #()).

Definition vars' : list (go_string * go_type) := [].

Definition functions' : list (go_string * val) := [(SendMessage, SendMessageⁱᵐᵖˡ); (JoinWithReceive, JoinWithReceiveⁱᵐᵖˡ); (JoinWithSend, JoinWithSendⁱᵐᵖˡ); (BroadcastNotification, BroadcastNotificationⁱᵐᵖˡ); (CoordinatedChannelClose, CoordinatedChannelCloseⁱᵐᵖˡ); (DoubleValues, DoubleValuesⁱᵐᵖˡ); (CapPipeline, CapPipelineⁱᵐᵖˡ); (producer, producerⁱᵐᵖˡ); (consumer, consumerⁱᵐᵖˡ); (SelectRace, SelectRaceⁱᵐᵖˡ); (load, loadⁱᵐᵖˡ); (process, processⁱᵐᵖˡ); (client, clientⁱᵐᵖˡ); (server, serverⁱᵐᵖˡ); (LeakyBufferPipeline, LeakyBufferPipelineⁱᵐᵖˡ)].

Definition msets' : list (go_string * (list (go_string * val))) := [].

#[global] Instance info' : PkgInfo channel.chan_spec_raw_examples :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [strings.strings; github_com.goose_lang.goose.model.channel.channel];
  |}.

Definition initialize' : val :=
  λ: <>,
    package.init #channel.chan_spec_raw_examples (λ: <>,
      exception_do (do:  (channel.initialize' #());;;
      do:  (strings.initialize' #());;;
      do:  (package.alloc channel.chan_spec_raw_examples #()))
      ).

End code.
End chan_spec_raw_examples.
