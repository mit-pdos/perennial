(* autogenerated from github.com/goose-lang/goose/testdata/examples/channel *)
Require Export New.code.strings.
Require Export New.code.sync.
Require Export New.code.time.

From New.golang Require Import defn.
Definition chan_spec_raw_examples : go_string := "github.com/goose-lang/goose/testdata/examples/channel".

Module chan_spec_raw_examples.

Section code.
Context `{ffi_syntax}.


Definition sys_hello_world : go_string := "github.com/goose-lang/goose/testdata/examples/channel.sys_hello_world"%go.

(* Fake syscall for demonstration.

   go: examples.go:9:6 *)
Definition sys_hello_worldⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (#"Hello, World!"%go)).

Definition HelloWorldAsync : go_string := "github.com/goose-lang/goose/testdata/examples/channel.HelloWorldAsync"%go.

(* go: examples.go:13:6 *)
Definition HelloWorldAsyncⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ch" := (mem.alloc (type.zero_val (type.chanT #stringT))) in
    let: "$r0" := (chan.make #stringT #(W64 1)) in
    do:  ("ch" <-[type.chanT #stringT] "$r0");;;
    let: "$go" := (λ: <>,
      exception_do (do:  (let: "$chan" := (![type.chanT #stringT] "ch") in
      let: "$v" := ((func_call #sys_hello_world) #()) in
      chan.send #stringT "$chan" "$v");;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    return: (![type.chanT #stringT] "ch")).

Definition HelloWorldSync : go_string := "github.com/goose-lang/goose/testdata/examples/channel.HelloWorldSync"%go.

(* go: examples.go:21:6 *)
Definition HelloWorldSyncⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (Fst (chan.receive #stringT ((func_call #HelloWorldAsync) #())))).

Definition HelloWorldCancellable : go_string := "github.com/goose-lang/goose/testdata/examples/channel.HelloWorldCancellable"%go.

(* Simulates the error/done channel components of Context

   go: examples.go:26:6 *)
Definition HelloWorldCancellableⁱᵐᵖˡ : val :=
  λ: "done" "err",
    exception_do (let: "err" := (mem.alloc "err") in
    let: "done" := (mem.alloc "done") in
    let: "future" := (mem.alloc (type.zero_val (type.chanT #stringT))) in
    let: "$r0" := ((func_call #HelloWorldAsync) #()) in
    do:  ("future" <-[type.chanT #stringT] "$r0");;;
    chan.select_blocking [chan.select_receive #stringT (![type.chanT #stringT] "future") (λ: "$recvVal",
       let: "resolved" := (mem.alloc (type.zero_val #stringT)) in
       let: "$r0" := (Fst "$recvVal") in
       do:  ("resolved" <-[#stringT] "$r0");;;
       return: (![#stringT] "resolved")
       ); chan.select_receive (type.structT [
     ]) (![type.chanT (type.structT [
     ])] "done") (λ: "$recvVal",
       return: (![#stringT] (![#ptrT] "err"))
       )]).

Definition HelloWorldWithTimeout : go_string := "github.com/goose-lang/goose/testdata/examples/channel.HelloWorldWithTimeout"%go.

(* Uses cancellation as a timeout mechanism.

   go: examples.go:37:6 *)
Definition HelloWorldWithTimeoutⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "done" := (mem.alloc (type.zero_val (type.chanT (type.structT [
    ])))) in
    let: "$r0" := (chan.make (type.structT [
    ]) #(W64 0)) in
    do:  ("done" <-[type.chanT (type.structT [
    ])] "$r0");;;
    let: "errMsg" := (mem.alloc (type.zero_val #stringT)) in
    let: "$r0" := #""%go in
    do:  ("errMsg" <-[#stringT] "$r0");;;
    let: "$go" := (λ: <>,
      exception_do (do:  (let: "$a0" := (#(W64 10) * time.Millisecond) in
      (func_call #time.Sleep) "$a0");;;
      let: "$r0" := #"operation timed out"%go in
      do:  ("errMsg" <-[#stringT] "$r0");;;
      do:  (let: "$a0" := (![type.chanT (type.structT [
      ])] "done") in
      (chan.close (type.structT [
      ])) "$a0");;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    return: (let: "$a0" := (![type.chanT (type.structT [
     ])] "done") in
     let: "$a1" := "errMsg" in
     (func_call #HelloWorldCancellable) "$a0" "$a1")).

Definition DSPExample : go_string := "github.com/goose-lang/goose/testdata/examples/channel.DSPExample"%go.

(* prog3 from Actris 2.0 intro: https://arxiv.org/pdf/2010.15030

   go: examples.go:52:6 *)
Definition DSPExampleⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "c" := (mem.alloc (type.zero_val (type.chanT #interfaceT))) in
    let: "$r0" := (chan.make #interfaceT #(W64 0)) in
    do:  ("c" <-[type.chanT #interfaceT] "$r0");;;
    let: "signal" := (mem.alloc (type.zero_val (type.chanT #interfaceT))) in
    let: "$r0" := (chan.make #interfaceT #(W64 0)) in
    do:  ("signal" <-[type.chanT #interfaceT] "$r0");;;
    let: "$go" := (λ: <>,
      exception_do (let: "ptr" := (mem.alloc (type.zero_val #ptrT)) in
      let: "$r0" := (interface.type_assert (Fst (chan.receive #interfaceT (![type.chanT #interfaceT] "c"))) #(ptrT.id intT.id)) in
      do:  ("ptr" <-[#ptrT] "$r0");;;
      let: "$r0" := ((![#intT] (![#ptrT] "ptr")) + #(W64 2)) in
      do:  ((![#ptrT] "ptr") <-[#intT] "$r0");;;
      do:  (let: "$chan" := (![type.chanT #interfaceT] "signal") in
      let: "$v" := (interface.make #(structT.id []) (struct.make (type.structT [
      ]) [{
      }])) in
      chan.send #interfaceT "$chan" "$v");;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    let: "val" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := #(W64 40) in
    do:  ("val" <-[#intT] "$r0");;;
    let: "ptr" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := "val" in
    do:  ("ptr" <-[#ptrT] "$r0");;;
    do:  (let: "$chan" := (![type.chanT #interfaceT] "c") in
    let: "$v" := (interface.make #(ptrT.id intT.id) (![#ptrT] "ptr")) in
    chan.send #interfaceT "$chan" "$v");;;
    do:  (Fst (chan.receive #interfaceT (![type.chanT #interfaceT] "signal")));;;
    return: (![#intT] (![#ptrT] "ptr"))).

Definition fibonacci : go_string := "github.com/goose-lang/goose/testdata/examples/channel.fibonacci"%go.

(* https://go.dev/tour/concurrency/4

   go: examples.go:70:6 *)
Definition fibonacciⁱᵐᵖˡ : val :=
  λ: "n" "c",
    exception_do (let: "c" := (mem.alloc "c") in
    let: "n" := (mem.alloc "n") in
    let: "y" := (mem.alloc (type.zero_val #intT)) in
    let: "x" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := #(W64 0) in
    let: "$r1" := #(W64 1) in
    do:  ("x" <-[#intT] "$r0");;;
    do:  ("y" <-[#intT] "$r1");;;
    (let: "i" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[#intT] "$r0");;;
    (for: (λ: <>, int_lt (![#intT] "i") (![#intT] "n")); (λ: <>, do:  ("i" <-[#intT] ((![#intT] "i") + #(W64 1)))) := λ: <>,
      do:  (let: "$chan" := (![type.chanT #intT] "c") in
      let: "$v" := (![#intT] "x") in
      chan.send #intT "$chan" "$v");;;
      let: "$r0" := (![#intT] "y") in
      let: "$r1" := ((![#intT] "x") + (![#intT] "y")) in
      do:  ("x" <-[#intT] "$r0");;;
      do:  ("y" <-[#intT] "$r1")));;;
    do:  (let: "$a0" := (![type.chanT #intT] "c") in
    (chan.close #intT) "$a0");;;
    return: #()).

Definition fib_consumer : go_string := "github.com/goose-lang/goose/testdata/examples/channel.fib_consumer"%go.

(* go: examples.go:79:6 *)
Definition fib_consumerⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "c" := (mem.alloc (type.zero_val (type.chanT #intT))) in
    let: "$r0" := (chan.make #intT #(W64 10)) in
    do:  ("c" <-[type.chanT #intT] "$r0");;;
    let: "$a0" := (let: "$a0" := (![type.chanT #intT] "c") in
    (chan.cap #intT) "$a0") in
    let: "$a1" := (![type.chanT #intT] "c") in
    let: "$go" := (func_call #fibonacci) in
    do:  (Fork ("$go" "$a0" "$a1"));;;
    let: "results" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := #slice.nil in
    do:  ("results" <-[#sliceT] "$r0");;;
    let: "$range" := (![type.chanT #intT] "c") in
    (let: "i" := (mem.alloc (type.zero_val #intT)) in
    chan.for_range #intT "$range" (λ: "$key",
      do:  ("i" <-[#intT] "$key");;;
      let: "$r0" := (let: "$a0" := (![#sliceT] "results") in
      let: "$a1" := ((let: "$sl0" := (![#intT] "i") in
      slice.literal #intT ["$sl0"])) in
      (slice.append #intT) "$a0" "$a1") in
      do:  ("results" <-[#sliceT] "$r0")));;;
    return: (![#sliceT] "results")).

Definition select_nb_no_panic : go_string := "github.com/goose-lang/goose/testdata/examples/channel.select_nb_no_panic"%go.

(* Show that it isn't possible to have 2 nonblocking ops that match.

   go: examples.go:91:6 *)
Definition select_nb_no_panicⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ch" := (mem.alloc (type.zero_val (type.chanT (type.structT [
    ])))) in
    let: "$r0" := (chan.make (type.structT [
    ]) #(W64 0)) in
    do:  ("ch" <-[type.chanT (type.structT [
    ])] "$r0");;;
    let: "$go" := (λ: <>,
      exception_do (chan.select_nonblocking [chan.select_receive (type.structT [
       ]) (![type.chanT (type.structT [
       ])] "ch") (λ: "$recvVal",
         do:  (let: "$a0" := (interface.make #stringT.id #"bad"%go) in
         Panic "$a0")
         )] (λ: <>,
        do:  #()
        );;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    chan.select_nonblocking [chan.select_send (type.structT [
     ]) (![type.chanT (type.structT [
     ])] "ch") (struct.make (type.structT [
     ]) [{
     }]) (λ: <>,
       do:  (let: "$a0" := (interface.make #stringT.id #"bad"%go) in
       Panic "$a0")
       )] (λ: <>,
      do:  #()
      );;;
    return: #()).

Definition select_ready_case_no_panic : go_string := "github.com/goose-lang/goose/testdata/examples/channel.select_ready_case_no_panic"%go.

(* Show that a guaranteed to be ready case makes default impossible

   go: examples.go:109:6 *)
Definition select_ready_case_no_panicⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ch" := (mem.alloc (type.zero_val (type.chanT (type.structT [
    ])))) in
    let: "$r0" := (chan.make (type.structT [
    ]) #(W64 0)) in
    do:  ("ch" <-[type.chanT (type.structT [
    ])] "$r0");;;
    do:  (let: "$a0" := (![type.chanT (type.structT [
    ])] "ch") in
    (chan.close (type.structT [
    ])) "$a0");;;
    chan.select_nonblocking [chan.select_receive (type.structT [
     ]) (![type.chanT (type.structT [
     ])] "ch") (λ: "$recvVal",
       do:  #()
       )] (λ: <>,
      do:  (let: "$a0" := (interface.make #stringT.id #"Shouldn't be possible!"%go) in
      Panic "$a0")
      );;;
    return: #()).

Definition TestHelloWorldSync : go_string := "github.com/goose-lang/goose/testdata/examples/channel.TestHelloWorldSync"%go.

(* Various tests that should panic when failing, which also means verifying { True } e { True } is
   sufficient since panic can't be verified.

   go: examples.go:123:6 *)
Definition TestHelloWorldSyncⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "result" := (mem.alloc (type.zero_val #stringT)) in
    let: "$r0" := ((func_call #HelloWorldSync) #()) in
    do:  ("result" <-[#stringT] "$r0");;;
    (if: (![#stringT] "result") ≠ #"Hello, World!"%go
    then
      do:  (let: "$a0" := (interface.make #stringT.id #"incorrect output"%go) in
      Panic "$a0")
    else do:  #());;;
    return: #()).

Definition TestHelloWorldWithTimeout : go_string := "github.com/goose-lang/goose/testdata/examples/channel.TestHelloWorldWithTimeout"%go.

(* go: examples.go:130:6 *)
Definition TestHelloWorldWithTimeoutⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "result" := (mem.alloc (type.zero_val #stringT)) in
    let: "$r0" := ((func_call #HelloWorldWithTimeout) #()) in
    do:  ("result" <-[#stringT] "$r0");;;
    (if: ((![#stringT] "result") ≠ #"operation timed out"%go) && ((![#stringT] "result") ≠ #"Hello, World!"%go)
    then
      do:  (let: "$a0" := (interface.make #stringT.id #"incorrect output"%go) in
      Panic "$a0")
    else do:  #());;;
    return: #()).

Definition TestDSPExample : go_string := "github.com/goose-lang/goose/testdata/examples/channel.TestDSPExample"%go.

(* go: examples.go:137:6 *)
Definition TestDSPExampleⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "result" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := ((func_call #DSPExample) #()) in
    do:  ("result" <-[#intT] "$r0");;;
    (if: (![#intT] "result") ≠ #(W64 42)
    then
      do:  (let: "$a0" := (interface.make #stringT.id #"incorrect output"%go) in
      Panic "$a0")
    else do:  #());;;
    return: #()).

Definition TestFibConsumer : go_string := "github.com/goose-lang/goose/testdata/examples/channel.TestFibConsumer"%go.

(* go: examples.go:144:6 *)
Definition TestFibConsumerⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "result" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := ((func_call #fib_consumer) #()) in
    do:  ("result" <-[#sliceT] "$r0");;;
    let: "expected" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := ((let: "$sl0" := #(W64 0) in
    let: "$sl1" := #(W64 1) in
    let: "$sl2" := #(W64 1) in
    let: "$sl3" := #(W64 2) in
    let: "$sl4" := #(W64 3) in
    let: "$sl5" := #(W64 5) in
    let: "$sl6" := #(W64 8) in
    let: "$sl7" := #(W64 13) in
    let: "$sl8" := #(W64 21) in
    let: "$sl9" := #(W64 34) in
    slice.literal #intT ["$sl0"; "$sl1"; "$sl2"; "$sl3"; "$sl4"; "$sl5"; "$sl6"; "$sl7"; "$sl8"; "$sl9"])) in
    do:  ("expected" <-[#sliceT] "$r0");;;
    (if: (let: "$a0" := (![#sliceT] "result") in
    slice.len "$a0") ≠ (let: "$a0" := (![#sliceT] "expected") in
    slice.len "$a0")
    then
      do:  (let: "$a0" := (interface.make #stringT.id #"incorrect output"%go) in
      Panic "$a0")
    else do:  #());;;
    let: "$range" := (![#sliceT] "expected") in
    (let: "i" := (mem.alloc (type.zero_val #intT)) in
    slice.for_range #intT "$range" (λ: "$key" "$value",
      do:  ("i" <-[#intT] "$key");;;
      (if: (![#intT] (slice.elem_ref #intT (![#sliceT] "result") (![#intT] "i"))) ≠ (![#intT] (slice.elem_ref #intT (![#sliceT] "expected") (![#intT] "i")))
      then
        do:  (let: "$a0" := (interface.make #stringT.id #"incorrect output"%go) in
        Panic "$a0")
      else do:  #())));;;
    return: #()).

Definition TestSelectNbNoPanic : go_string := "github.com/goose-lang/goose/testdata/examples/channel.TestSelectNbNoPanic"%go.

(* go: examples.go:159:6 *)
Definition TestSelectNbNoPanicⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "iterations" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := #(W64 10000) in
    do:  ("iterations" <-[#intT] "$r0");;;
    (let: "i" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[#intT] "$r0");;;
    (for: (λ: <>, int_lt (![#intT] "i") (![#intT] "iterations")); (λ: <>, do:  ("i" <-[#intT] ((![#intT] "i") + #(W64 1)))) := λ: <>,
      do:  ((func_call #select_nb_no_panic) #());;;
      do:  (let: "$a0" := (#(W64 1) * time.Microsecond) in
      (func_call #time.Sleep) "$a0")));;;
    return: #()).

Definition TestSelectReadyCaseNoPanic : go_string := "github.com/goose-lang/goose/testdata/examples/channel.TestSelectReadyCaseNoPanic"%go.

(* go: examples.go:168:6 *)
Definition TestSelectReadyCaseNoPanicⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "iterations" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := #(W64 10000) in
    do:  ("iterations" <-[#intT] "$r0");;;
    (let: "i" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[#intT] "$r0");;;
    (for: (λ: <>, int_lt (![#intT] "i") (![#intT] "iterations")); (λ: <>, do:  ("i" <-[#intT] ((![#intT] "i") + #(W64 1)))) := λ: <>,
      do:  ((func_call #select_ready_case_no_panic) #())));;;
    return: #()).

Definition load : go_string := "github.com/goose-lang/goose/testdata/examples/channel.load"%go.

(* load writes the next letter into the buffer.

   go: examples.go:179:6 *)
Definition loadⁱᵐᵖˡ : val :=
  λ: "b" "letter",
    exception_do (let: "letter" := (mem.alloc "letter") in
    let: "b" := (mem.alloc "b") in
    let: "$r0" := (string.to_bytes (![#stringT] "letter")) in
    do:  ((![#ptrT] "b") <-[#sliceT] "$r0");;;
    return: #()).

Definition process : go_string := "github.com/goose-lang/goose/testdata/examples/channel.process"%go.

(* process consumes the buffer and appends it to the output.

   go: examples.go:184:6 *)
Definition processⁱᵐᵖˡ : val :=
  λ: "b" "output",
    exception_do (let: "output" := (mem.alloc "output") in
    let: "b" := (mem.alloc "b") in
    do:  ((![#ptrT] "output") <-[#stringT] ((![#stringT] (![#ptrT] "output")) + (let: "$a0" := (string.from_bytes (![#sliceT] (![#ptrT] "b"))) in
    (func_call #strings.ToUpper) "$a0")));;;
    return: #()).

Definition client : go_string := "github.com/goose-lang/goose/testdata/examples/channel.client"%go.

(* go: examples.go:188:6 *)
Definition clientⁱᵐᵖˡ : val :=
  λ: "input" "freeList" "serverChan",
    exception_do (let: "serverChan" := (mem.alloc "serverChan") in
    let: "freeList" := (mem.alloc "freeList") in
    let: "input" := (mem.alloc "input") in
    let: "$range" := (![#sliceT] "input") in
    (let: "letter" := (mem.alloc (type.zero_val #stringT)) in
    slice.for_range #stringT "$range" (λ: "$key" "$value",
      do:  ("letter" <-[#stringT] "$value");;;
      do:  "$key";;;
      let: "b" := (mem.alloc (type.zero_val #sliceT)) in
      chan.select_nonblocking [chan.select_receive #sliceT (![type.chanT #sliceT] "freeList") (λ: "$recvVal",
         let: "$r0" := (Fst "$recvVal") in
         do:  ("b" <-[#sliceT] "$r0");;;
         do:  #()
         )] (λ: <>,
        let: "$r0" := ((let: "$sl0" := #(W8 0) in
        slice.literal #byteT ["$sl0"])) in
        do:  ("b" <-[#sliceT] "$r0")
        );;;
      do:  (let: "$a0" := "b" in
      let: "$a1" := (![#stringT] "letter") in
      (func_call #load) "$a0" "$a1");;;
      do:  (let: "$chan" := (![type.chanT #sliceT] "serverChan") in
      let: "$v" := (![#sliceT] "b") in
      chan.send #sliceT "$chan" "$v")));;;
    do:  (let: "$a0" := (![type.chanT #sliceT] "serverChan") in
    (chan.close #sliceT) "$a0");;;
    return: #()).

Definition server : go_string := "github.com/goose-lang/goose/testdata/examples/channel.server"%go.

(* go: examples.go:209:6 *)
Definition serverⁱᵐᵖˡ : val :=
  λ: "output" "freeList" "serverChan" "done",
    exception_do (let: "done" := (mem.alloc "done") in
    let: "serverChan" := (mem.alloc "serverChan") in
    let: "freeList" := (mem.alloc "freeList") in
    let: "output" := (mem.alloc "output") in
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "ok" := (mem.alloc (type.zero_val #boolT)) in
      let: "b" := (mem.alloc (type.zero_val #sliceT)) in
      let: ("$ret0", "$ret1") := (chan.receive #sliceT (![type.chanT #sliceT] "serverChan")) in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("b" <-[#sliceT] "$r0");;;
      do:  ("ok" <-[#boolT] "$r1");;;
      (if: (~ (![#boolT] "ok"))
      then
        do:  (let: "$chan" := (![type.chanT (type.structT [
        ])] "done") in
        let: "$v" := (struct.make (type.structT [
        ]) [{
        }]) in
        chan.send (type.structT [
        ]) "$chan" "$v");;;
        return: (#())
      else do:  #());;;
      do:  (let: "$a0" := "b" in
      let: "$a1" := (![#ptrT] "output") in
      (func_call #process) "$a0" "$a1");;;
      chan.select_nonblocking [chan.select_send #sliceT (![type.chanT #sliceT] "freeList") (![#sliceT] "b") (λ: <>,
         do:  #()
         )] (λ: <>,
        do:  #()
        ));;;
    return: #()).

Definition LeakyBufferPipeline : go_string := "github.com/goose-lang/goose/testdata/examples/channel.LeakyBufferPipeline"%go.

(* go: examples.go:231:6 *)
Definition LeakyBufferPipelineⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "freeList" := (mem.alloc (type.zero_val (type.chanT #sliceT))) in
    let: "$r0" := (chan.make #sliceT #(W64 5)) in
    do:  ("freeList" <-[type.chanT #sliceT] "$r0");;;
    let: "serverChan" := (mem.alloc (type.zero_val (type.chanT #sliceT))) in
    let: "$r0" := (chan.make #sliceT #(W64 0)) in
    do:  ("serverChan" <-[type.chanT #sliceT] "$r0");;;
    let: "done" := (mem.alloc (type.zero_val (type.chanT (type.structT [
    ])))) in
    let: "$r0" := (chan.make (type.structT [
    ]) #(W64 0)) in
    do:  ("done" <-[type.chanT (type.structT [
    ])] "$r0");;;
    let: "output" := (mem.alloc (type.zero_val #stringT)) in
    let: "$r0" := #""%go in
    do:  ("output" <-[#stringT] "$r0");;;
    let: "$a0" := "output" in
    let: "$a1" := (![type.chanT #sliceT] "freeList") in
    let: "$a2" := (![type.chanT #sliceT] "serverChan") in
    let: "$a3" := (![type.chanT (type.structT [
    ])] "done") in
    let: "$go" := (func_call #server) in
    do:  (Fork ("$go" "$a0" "$a1" "$a2" "$a3"));;;
    do:  (let: "$a0" := ((let: "$sl0" := #"h"%go in
    let: "$sl1" := #"e"%go in
    let: "$sl2" := #"l"%go in
    let: "$sl3" := #"l"%go in
    let: "$sl4" := #"o"%go in
    let: "$sl5" := #","%go in
    let: "$sl6" := #" "%go in
    let: "$sl7" := #"w"%go in
    let: "$sl8" := #"o"%go in
    let: "$sl9" := #"r"%go in
    let: "$sl10" := #"l"%go in
    let: "$sl11" := #"d"%go in
    slice.literal #stringT ["$sl0"; "$sl1"; "$sl2"; "$sl3"; "$sl4"; "$sl5"; "$sl6"; "$sl7"; "$sl8"; "$sl9"; "$sl10"; "$sl11"])) in
    let: "$a1" := (![type.chanT #sliceT] "freeList") in
    let: "$a2" := (![type.chanT #sliceT] "serverChan") in
    (func_call #client) "$a0" "$a1" "$a2");;;
    do:  (Fst (chan.receive (type.structT [
    ]) (![type.chanT (type.structT [
    ])] "done")));;;
    (if: (![#stringT] "output") ≠ #"HELLO, WORLD"%go
    then
      do:  (let: "$a0" := (interface.make #stringT.id #"incorrect output"%go) in
      Panic "$a0")
    else do:  #());;;
    return: #()).

Definition worker : go_string := "github.com/goose-lang/goose/testdata/examples/channel.worker"%go.

(* go: parallel_search_replace.go:13:6 *)
Definition workerⁱᵐᵖˡ : val :=
  λ: "c" "wg" "x" "y",
    exception_do (let: "y" := (mem.alloc "y") in
    let: "x" := (mem.alloc "x") in
    let: "wg" := (mem.alloc "wg") in
    let: "c" := (mem.alloc "c") in
    (let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "s" := (mem.alloc (type.zero_val #sliceT)) in
    let: ("$ret0", "$ret1") := (chan.receive #sliceT (![type.chanT #sliceT] "c")) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("s" <-[#sliceT] "$r0");;;
    do:  ("ok" <-[#boolT] "$r1");;;
    (for: (λ: <>, ![#boolT] "ok"); (λ: <>, let: ("$ret0", "$ret1") := (chan.receive #sliceT (![type.chanT #sliceT] "c")) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("s" <-[#sliceT] "$r0");;;
    do:  ("ok" <-[#boolT] "$r1")) := λ: <>,
      (let: "i" := (mem.alloc (type.zero_val #intT)) in
      let: "$r0" := #(W64 0) in
      do:  ("i" <-[#intT] "$r0");;;
      (for: (λ: <>, (![#intT] "i") ≠ (let: "$a0" := (![#sliceT] "s") in
      slice.len "$a0")); (λ: <>, do:  ("i" <-[#intT] ((![#intT] "i") + #(W64 1)))) := λ: <>,
        (if: (![#intT] (slice.elem_ref #intT (![#sliceT] "s") (![#intT] "i"))) = (![#intT] "x")
        then
          let: "$r0" := (![#intT] "y") in
          do:  ((slice.elem_ref #intT (![#sliceT] "s") (![#intT] "i")) <-[#intT] "$r0")
        else do:  #())));;;
      do:  ((method_call #(ptrT.id sync.WaitGroup.id) #"Done"%go (![#ptrT] "wg")) #())));;;
    return: #()).

Definition SearchReplace : go_string := "github.com/goose-lang/goose/testdata/examples/channel.SearchReplace"%go.

(* go: parallel_search_replace.go:24:6 *)
Definition SearchReplaceⁱᵐᵖˡ : val :=
  λ: "s" "x" "y",
    exception_do (let: "y" := (mem.alloc "y") in
    let: "x" := (mem.alloc "x") in
    let: "s" := (mem.alloc "s") in
    (if: (let: "$a0" := (![#sliceT] "s") in
    slice.len "$a0") = #(W64 0)
    then return: (#())
    else do:  #());;;
    let: "workers" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := #(W64 8) in
    do:  ("workers" <-[#intT] "$r0");;;
    let: "workRange" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := #(W64 1000) in
    do:  ("workRange" <-[#intT] "$r0");;;
    let: "c" := (mem.alloc (type.zero_val (type.chanT #sliceT))) in
    let: "$r0" := (chan.make #sliceT #(W64 4)) in
    do:  ("c" <-[type.chanT #sliceT] "$r0");;;
    let: "wg" := (mem.alloc (type.zero_val #sync.WaitGroup)) in
    (let: "i" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[#intT] "$r0");;;
    (for: (λ: <>, (![#intT] "i") ≠ (![#intT] "workers")); (λ: <>, do:  ("i" <-[#intT] ((![#intT] "i") + #(W64 1)))) := λ: <>,
      let: "$a0" := (![type.chanT #sliceT] "c") in
      let: "$a1" := "wg" in
      let: "$a2" := (![#intT] "x") in
      let: "$a3" := (![#intT] "y") in
      let: "$go" := (func_call #worker) in
      do:  (Fork ("$go" "$a0" "$a1" "$a2" "$a3"))));;;
    (let: "offset" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := #(W64 0) in
    do:  ("offset" <-[#intT] "$r0");;;
    (for: (λ: <>, (![#intT] "offset") ≠ (let: "$a0" := (![#sliceT] "s") in
    slice.len "$a0")); (λ: <>, #()) := λ: <>,
      let: "nextOffset" := (mem.alloc (type.zero_val #intT)) in
      let: "$r0" := ((![#intT] "offset") + (![#intT] "workRange")) in
      do:  ("nextOffset" <-[#intT] "$r0");;;
      (if: int_gt (![#intT] "nextOffset") (let: "$a0" := (![#sliceT] "s") in
      slice.len "$a0")
      then
        let: "$r0" := (let: "$a0" := (![#sliceT] "s") in
        slice.len "$a0") in
        do:  ("nextOffset" <-[#intT] "$r0")
      else do:  #());;;
      let: "section" := (mem.alloc (type.zero_val #sliceT)) in
      let: "$r0" := (let: "$s" := (![#sliceT] "s") in
      slice.slice #intT "$s" (![#intT] "offset") (![#intT] "nextOffset")) in
      do:  ("section" <-[#sliceT] "$r0");;;
      do:  (let: "$a0" := #(W64 1) in
      (method_call #(ptrT.id sync.WaitGroup.id) #"Add"%go "wg") "$a0");;;
      do:  (let: "$chan" := (![type.chanT #sliceT] "c") in
      let: "$v" := (![#sliceT] "section") in
      chan.send #sliceT "$chan" "$v");;;
      let: "$r0" := (![#intT] "nextOffset") in
      do:  ("offset" <-[#intT] "$r0")));;;
    do:  ((method_call #(ptrT.id sync.WaitGroup.id) #"Wait"%go "wg") #());;;
    return: #()).

Definition vars' : list (go_string * go_type) := [].

Definition functions' : list (go_string * val) := [(sys_hello_world, sys_hello_worldⁱᵐᵖˡ); (HelloWorldAsync, HelloWorldAsyncⁱᵐᵖˡ); (HelloWorldSync, HelloWorldSyncⁱᵐᵖˡ); (HelloWorldCancellable, HelloWorldCancellableⁱᵐᵖˡ); (HelloWorldWithTimeout, HelloWorldWithTimeoutⁱᵐᵖˡ); (DSPExample, DSPExampleⁱᵐᵖˡ); (fibonacci, fibonacciⁱᵐᵖˡ); (fib_consumer, fib_consumerⁱᵐᵖˡ); (select_nb_no_panic, select_nb_no_panicⁱᵐᵖˡ); (select_ready_case_no_panic, select_ready_case_no_panicⁱᵐᵖˡ); (TestHelloWorldSync, TestHelloWorldSyncⁱᵐᵖˡ); (TestHelloWorldWithTimeout, TestHelloWorldWithTimeoutⁱᵐᵖˡ); (TestDSPExample, TestDSPExampleⁱᵐᵖˡ); (TestFibConsumer, TestFibConsumerⁱᵐᵖˡ); (TestSelectNbNoPanic, TestSelectNbNoPanicⁱᵐᵖˡ); (TestSelectReadyCaseNoPanic, TestSelectReadyCaseNoPanicⁱᵐᵖˡ); (load, loadⁱᵐᵖˡ); (process, processⁱᵐᵖˡ); (client, clientⁱᵐᵖˡ); (server, serverⁱᵐᵖˡ); (LeakyBufferPipeline, LeakyBufferPipelineⁱᵐᵖˡ); (worker, workerⁱᵐᵖˡ); (SearchReplace, SearchReplaceⁱᵐᵖˡ)].

Definition msets' : list (go_string * (list (go_string * val))) := [].

#[global] Instance info' : PkgInfo channel.chan_spec_raw_examples :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [code.strings.strings; code.time.time; code.sync.sync];
  |}.

Definition initialize' : val :=
  λ: <>,
    package.init #channel.chan_spec_raw_examples (λ: <>,
      exception_do (do:  (sync.initialize' #());;;
      do:  (time.initialize' #());;;
      do:  (strings.initialize' #());;;
      do:  (package.alloc channel.chan_spec_raw_examples #()))
      ).

End code.
End chan_spec_raw_examples.
