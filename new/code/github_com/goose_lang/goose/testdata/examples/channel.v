(* autogenerated from github.com/goose-lang/goose/testdata/examples/channel *)
Require Export New.code.strings.
Require Export New.code.sync.
Require Export New.code.time.

From New.golang Require Import defn.
Definition chan_spec_raw_examples : go_string := "github.com/goose-lang/goose/testdata/examples/channel".

Module chan_spec_raw_examples.

Section code.
Context `{ffi_syntax}.


Definition LockedStackⁱᵐᵖˡ  : go.type := go.StructType [
  (go.FieldDecl "mu"%go sync.Mutex);
  (go.FieldDecl "stack"%go go.SliceType go.string)
].

Definition NewLockedStack : go_string := "github.com/goose-lang/goose/testdata/examples/channel.NewLockedStack"%go.

(* go: elimination_stack.go:14:6 *)
Definition NewLockedStackⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (GoAllocValue LockedStack (let: "$stack" := (slice.make2 go.string #(W64 0)) in
     struct.make LockedStack [{
       "mu" ::= GoZeroVal sync.Mutex #();
       "stack" ::= "$stack"
     }]))).

(* go: elimination_stack.go:18:23 *)
Definition LockedStack__Pushⁱᵐᵖˡ : val :=
  λ: "s" "value",
    exception_do (let: "s" := (GoAllocValue (go.PointerType LockedStack) "s") in
    let: "value" := (GoAllocValue go.string "value") in
    do:  ((MethodResolve (go.PointerType sync.Mutex) Lock #() (struct.field_ref LockedStack #"mu"%go (![go.PointerType LockedStack] "s"))) #());;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.string] (struct.field_ref LockedStack #"stack"%go (![go.PointerType LockedStack] "s"))) in
    let: "$a1" := ((let: "$sl0" := (![go.string] "value") in
    slice.literal go.string ["$sl0"])) in
    (slice.append go.string) "$a0" "$a1") in
    do:  ((struct.field_ref LockedStack #"stack"%go (![go.PointerType LockedStack] "s")) <-[go.SliceType go.string] "$r0");;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) Unlock #() (struct.field_ref LockedStack #"mu"%go (![go.PointerType LockedStack] "s"))) #());;;
    return: #()).

(* go: elimination_stack.go:24:23 *)
Definition LockedStack__Popⁱᵐᵖˡ : val :=
  λ: "s" <>,
    exception_do (let: "s" := (GoAllocValue (go.PointerType LockedStack) "s") in
    do:  ((MethodResolve (go.PointerType sync.Mutex) Lock #() (struct.field_ref LockedStack #"mu"%go (![go.PointerType LockedStack] "s"))) #());;;
    (if: (let: "$a0" := (![go.SliceType go.string] (struct.field_ref LockedStack #"stack"%go (![go.PointerType LockedStack] "s"))) in
    slice.len "$a0") = #(W64 0)
    then
      do:  ((MethodResolve (go.PointerType sync.Mutex) Unlock #() (struct.field_ref LockedStack #"mu"%go (![go.PointerType LockedStack] "s"))) #());;;
      return: (#""%go, #false)
    else do:  #());;;
    let: "last" := (GoAlloc go.int #()) in
    let: "$r0" := ((let: "$a0" := (![go.SliceType go.string] (struct.field_ref LockedStack #"stack"%go (![go.PointerType LockedStack] "s"))) in
    slice.len "$a0") - #(W64 1)) in
    do:  ("last" <-[go.int] "$r0");;;
    let: "v" := (GoAlloc go.string #()) in
    let: "$r0" := (![go.string] (slice.elem_ref go.string (![go.SliceType go.string] (struct.field_ref LockedStack #"stack"%go (![go.PointerType LockedStack] "s"))) (![go.int] "last"))) in
    do:  ("v" <-[go.string] "$r0");;;
    let: "$r0" := (let: "$s" := (![go.SliceType go.string] (struct.field_ref LockedStack #"stack"%go (![go.PointerType LockedStack] "s"))) in
    slice.slice go.string "$s" #(W64 0) (![go.int] "last")) in
    do:  ((struct.field_ref LockedStack #"stack"%go (![go.PointerType LockedStack] "s")) <-[go.SliceType go.string] "$r0");;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) Unlock #() (struct.field_ref LockedStack #"mu"%go (![go.PointerType LockedStack] "s"))) #());;;
    return: (![go.string] "v", #true)).

Definition timeout : val := #(W64 10000).

Definition EliminationStackⁱᵐᵖˡ  : go.type := go.StructType [
  (go.FieldDecl "base"%go go.PointerType LockedStack);
  (go.FieldDecl "exchanger"%go go.ChannelType go.sendrecv go.string)
].

Definition NewEliminationStack : go_string := "github.com/goose-lang/goose/testdata/examples/channel.NewEliminationStack"%go.

(* NewEliminationStack constructs a new elimination stack
   using a fresh LockedStack and a small default timeout.

   go: elimination_stack.go:47:6 *)
Definition NewEliminationStackⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (GoAllocValue EliminationStack (let: "$base" := ((FuncResolve NewLockedStack #()) #()) in
     let: "$exchanger" := (chan.make go.string #(W64 0)) in
     struct.make EliminationStack [{
       "base" ::= "$base";
       "exchanger" ::= "$exchanger"
     }]))).

(* Push first tries one-shot elimination; on timeout, falls back to the locked stack.

   go: elimination_stack.go:55:28 *)
Definition EliminationStack__Pushⁱᵐᵖˡ : val :=
  λ: "s" "value",
    exception_do (let: "s" := (GoAllocValue (go.PointerType EliminationStack) "s") in
    let: "value" := (GoAllocValue go.string "value") in
    chan.select_blocking [chan.select_send go.string (![go.ChannelType go.sendrecv go.string] (struct.field_ref EliminationStack #"exchanger"%go (![go.PointerType EliminationStack] "s"))) (![go.string] "value") (λ: <>,
       return: (#())
       ); chan.select_receive time.Time (let: "$a0" := timeout in
     (FuncResolve time.After #()) "$a0") (λ: "$recvVal",
       do:  #()
       )];;;
    do:  (let: "$a0" := (![go.string] "value") in
    (MethodResolve (go.PointerType LockedStack) Push #() (![go.PointerType LockedStack] (struct.field_ref EliminationStack #"base"%go (![go.PointerType EliminationStack] "s")))) "$a0");;;
    return: #()).

(* Pop first tries one-shot elimination; on timeout, falls back to the locked stack.

   go: elimination_stack.go:67:28 *)
Definition EliminationStack__Popⁱᵐᵖˡ : val :=
  λ: "s" <>,
    exception_do (let: "s" := (GoAllocValue (go.PointerType EliminationStack) "s") in
    chan.select_blocking [chan.select_receive go.string (![go.ChannelType go.sendrecv go.string] (struct.field_ref EliminationStack #"exchanger"%go (![go.PointerType EliminationStack] "s"))) (λ: "$recvVal",
       let: "v" := (GoAlloc go.string #()) in
       let: "$r0" := (Fst "$recvVal") in
       do:  ("v" <-[go.string] "$r0");;;
       return: (![go.string] "v", #true)
       ); chan.select_receive time.Time (let: "$a0" := timeout in
     (FuncResolve time.After #()) "$a0") (λ: "$recvVal",
       do:  #()
       )];;;
    let: ("$ret0", "$ret1") := (((MethodResolve (go.PointerType LockedStack) Pop #() (![go.PointerType LockedStack] (struct.field_ref EliminationStack #"base"%go (![go.PointerType EliminationStack] "s")))) #())) in
    return: ("$ret0", "$ret1")).

Definition sys_hello_world : go_string := "github.com/goose-lang/goose/testdata/examples/channel.sys_hello_world"%go.

(* Fake syscall for demonstration.

   go: examples.go:8:6 *)
Definition sys_hello_worldⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (#"Hello, World!"%go)).

Definition HelloWorldAsync : go_string := "github.com/goose-lang/goose/testdata/examples/channel.HelloWorldAsync"%go.

(* go: examples.go:12:6 *)
Definition HelloWorldAsyncⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ch" := (GoAlloc (go.ChannelType go.sendrecv go.string) #()) in
    let: "$r0" := (chan.make go.string #(W64 1)) in
    do:  ("ch" <-[go.ChannelType go.sendrecv go.string] "$r0");;;
    let: "$go" := (λ: <>,
      exception_do (do:  (let: "$chan" := (![go.ChannelType go.sendrecv go.string] "ch") in
      let: "$v" := ((FuncResolve sys_hello_world #()) #()) in
      chan.send go.string "$chan" "$v");;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    return: (![go.ChannelType go.sendrecv go.string] "ch")).

Definition HelloWorldSync : go_string := "github.com/goose-lang/goose/testdata/examples/channel.HelloWorldSync"%go.

(* go: examples.go:20:6 *)
Definition HelloWorldSyncⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (Fst (chan.receive go.string ((FuncResolve HelloWorldAsync #()) #())))).

Definition HelloWorldCancellable : go_string := "github.com/goose-lang/goose/testdata/examples/channel.HelloWorldCancellable"%go.

(* Simulates the error/done channel components of Context

   go: examples.go:25:6 *)
Definition HelloWorldCancellableⁱᵐᵖˡ : val :=
  λ: "done" "err",
    exception_do (let: "err" := (GoAllocValue (go.PointerType go.string) "err") in
    let: "done" := (GoAllocValue (go.ChannelType go.sendrecv (go.StructType [
    ])) "done") in
    let: "future" := (GoAlloc (go.ChannelType go.sendrecv go.string) #()) in
    let: "$r0" := ((FuncResolve HelloWorldAsync #()) #()) in
    do:  ("future" <-[go.ChannelType go.sendrecv go.string] "$r0");;;
    chan.select_blocking [chan.select_receive go.string (![go.ChannelType go.sendrecv go.string] "future") (λ: "$recvVal",
       let: "resolved" := (GoAlloc go.string #()) in
       let: "$r0" := (Fst "$recvVal") in
       do:  ("resolved" <-[go.string] "$r0");;;
       return: (![go.string] "resolved")
       ); chan.select_receive (go.StructType [
     ]) (![go.ChannelType go.sendrecv (go.StructType [
     ])] "done") (λ: "$recvVal",
       return: (![go.string] (![go.PointerType go.string] "err"))
       )]).

Definition HelloWorldWithTimeout : go_string := "github.com/goose-lang/goose/testdata/examples/channel.HelloWorldWithTimeout"%go.

(* Uses cancellation as a timeout mechanism.

   go: examples.go:36:6 *)
Definition HelloWorldWithTimeoutⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "done" := (GoAlloc (go.ChannelType go.sendrecv (go.StructType [
    ])) #()) in
    let: "$r0" := (chan.make (go.StructType [
    ]) #(W64 0)) in
    do:  ("done" <-[go.ChannelType go.sendrecv (go.StructType [
    ])] "$r0");;;
    let: "errMsg" := (GoAlloc go.string #()) in
    let: "$r0" := #""%go in
    do:  ("errMsg" <-[go.string] "$r0");;;
    let: "$go" := (λ: <>,
      exception_do (do:  (let: "$a0" := (#(W64 10) * time.Millisecond) in
      (FuncResolve time.Sleep #()) "$a0");;;
      let: "$r0" := #"operation timed out"%go in
      do:  ("errMsg" <-[go.string] "$r0");;;
      do:  (let: "$a0" := (![go.ChannelType go.sendrecv (go.StructType [
      ])] "done") in
      (chan.close (go.StructType [
      ])) "$a0");;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    return: (let: "$a0" := (![go.ChannelType go.sendrecv (go.StructType [
     ])] "done") in
     let: "$a1" := "errMsg" in
     (FuncResolve HelloWorldCancellable #()) "$a0" "$a1")).

Definition DSPExample : go_string := "github.com/goose-lang/goose/testdata/examples/channel.DSPExample"%go.

(* prog3 from Actris 2.0 intro: https://arxiv.org/pdf/2010.15030

   go: examples.go:51:6 *)
Definition DSPExampleⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "c" := (GoAlloc (go.ChannelType go.sendrecv (go.InterfaceType [])) #()) in
    let: "$r0" := (chan.make (go.InterfaceType []) #(W64 0)) in
    do:  ("c" <-[go.ChannelType go.sendrecv (go.InterfaceType [])] "$r0");;;
    let: "signal" := (GoAlloc (go.ChannelType go.sendrecv (go.InterfaceType [])) #()) in
    let: "$r0" := (chan.make (go.InterfaceType []) #(W64 0)) in
    do:  ("signal" <-[go.ChannelType go.sendrecv (go.InterfaceType [])] "$r0");;;
    let: "$go" := (λ: <>,
      exception_do (let: "ptr" := (GoAlloc (go.PointerType go.int) #()) in
      let: "$r0" := (TypeAssert (go.PointerType go.int) (Fst (chan.receive (go.InterfaceType []) (![go.ChannelType go.sendrecv (go.InterfaceType [])] "c")))) in
      do:  ("ptr" <-[go.PointerType go.int] "$r0");;;
      let: "$r0" := ((![go.int] (![go.PointerType go.int] "ptr")) + #(W64 2)) in
      do:  ((![go.PointerType go.int] "ptr") <-[go.int] "$r0");;;
      do:  (let: "$chan" := (![go.ChannelType go.sendrecv (go.InterfaceType [])] "signal") in
      let: "$v" := (InterfaceMake (go.StructType [
      ]) (struct.make (go.StructType [
      ]) [{
      }])) in
      chan.send (go.InterfaceType []) "$chan" "$v");;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    let: "val" := (GoAlloc go.int #()) in
    let: "$r0" := #(W64 40) in
    do:  ("val" <-[go.int] "$r0");;;
    let: "ptr" := (GoAlloc (go.PointerType go.int) #()) in
    let: "$r0" := "val" in
    do:  ("ptr" <-[go.PointerType go.int] "$r0");;;
    do:  (let: "$chan" := (![go.ChannelType go.sendrecv (go.InterfaceType [])] "c") in
    let: "$v" := (InterfaceMake (go.PointerType go.int) (![go.PointerType go.int] "ptr")) in
    chan.send (go.InterfaceType []) "$chan" "$v");;;
    do:  (Fst (chan.receive (go.InterfaceType []) (![go.ChannelType go.sendrecv (go.InterfaceType [])] "signal")));;;
    return: (![go.int] (![go.PointerType go.int] "ptr"))).

Definition fibonacci : go_string := "github.com/goose-lang/goose/testdata/examples/channel.fibonacci"%go.

(* https://go.dev/tour/concurrency/4

   go: examples.go:69:6 *)
Definition fibonacciⁱᵐᵖˡ : val :=
  λ: "n" "c",
    exception_do (let: "c" := (GoAllocValue (go.ChannelType go.sendrecv go.int) "c") in
    let: "n" := (GoAllocValue go.int "n") in
    let: "y" := (GoAlloc go.int #()) in
    let: "x" := (GoAlloc go.int #()) in
    let: "$r0" := #(W64 0) in
    let: "$r1" := #(W64 1) in
    do:  ("x" <-[go.int] "$r0");;;
    do:  ("y" <-[go.int] "$r1");;;
    (let: "i" := (GoAlloc go.int #()) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.int] "$r0");;;
    (for: (λ: <>, int_lt (![go.int] "i") (![go.int] "n")); (λ: <>, do:  ("i" <-[go.int] ((![go.int] "i") + #(W64 1)))) := λ: <>,
      do:  (let: "$chan" := (![go.ChannelType go.sendrecv go.int] "c") in
      let: "$v" := (![go.int] "x") in
      chan.send go.int "$chan" "$v");;;
      let: "$r0" := (![go.int] "y") in
      let: "$r1" := ((![go.int] "x") + (![go.int] "y")) in
      do:  ("x" <-[go.int] "$r0");;;
      do:  ("y" <-[go.int] "$r1")));;;
    do:  (let: "$a0" := (![go.ChannelType go.sendrecv go.int] "c") in
    (chan.close go.int) "$a0");;;
    return: #()).

Definition fib_consumer : go_string := "github.com/goose-lang/goose/testdata/examples/channel.fib_consumer"%go.

(* go: examples.go:78:6 *)
Definition fib_consumerⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "c" := (GoAlloc (go.ChannelType go.sendrecv go.int) #()) in
    let: "$r0" := (chan.make go.int #(W64 10)) in
    do:  ("c" <-[go.ChannelType go.sendrecv go.int] "$r0");;;
    let: "$a0" := (let: "$a0" := (![go.ChannelType go.sendrecv go.int] "c") in
    (chan.cap go.int) "$a0") in
    let: "$a1" := (![go.ChannelType go.sendrecv go.int] "c") in
    let: "$go" := (FuncResolve fibonacci #()) in
    do:  (Fork ("$go" "$a0" "$a1"));;;
    let: "results" := (GoAlloc (go.SliceType go.int) #()) in
    let: "$r0" := #slice.nil in
    do:  ("results" <-[go.SliceType go.int] "$r0");;;
    let: "$range" := (![go.ChannelType go.sendrecv go.int] "c") in
    (let: "i" := (GoAlloc go.int #()) in
    chan.for_range go.int "$range" (λ: "$key",
      do:  ("i" <-[go.int] "$key");;;
      let: "$r0" := (let: "$a0" := (![go.SliceType go.int] "results") in
      let: "$a1" := ((let: "$sl0" := (![go.int] "i") in
      slice.literal go.int ["$sl0"])) in
      (slice.append go.int) "$a0" "$a1") in
      do:  ("results" <-[go.SliceType go.int] "$r0")));;;
    return: (![go.SliceType go.int] "results")).

Definition simple_join : go_string := "github.com/goose-lang/goose/testdata/examples/channel.simple_join"%go.

(* go: examples.go:89:6 *)
Definition simple_joinⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ch" := (GoAlloc (go.ChannelType go.sendrecv (go.StructType [
    ])) #()) in
    let: "$r0" := (chan.make (go.StructType [
    ]) #(W64 1)) in
    do:  ("ch" <-[go.ChannelType go.sendrecv (go.StructType [
    ])] "$r0");;;
    let: "message" := (GoAlloc go.string #()) in
    let: "$go" := (λ: <>,
      exception_do (let: "$r0" := #"Hello, World!"%go in
      do:  ("message" <-[go.string] "$r0");;;
      do:  (let: "$chan" := (![go.ChannelType go.sendrecv (go.StructType [
      ])] "ch") in
      let: "$v" := (struct.make (go.StructType [
      ]) [{
      }]) in
      chan.send (go.StructType [
      ]) "$chan" "$v");;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    do:  (Fst (chan.receive (go.StructType [
    ]) (![go.ChannelType go.sendrecv (go.StructType [
    ])] "ch")));;;
    return: (![go.string] "message")).

Definition simple_multi_join : go_string := "github.com/goose-lang/goose/testdata/examples/channel.simple_multi_join"%go.

(* go: examples.go:102:6 *)
Definition simple_multi_joinⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ch" := (GoAlloc (go.ChannelType go.sendrecv (go.StructType [
    ])) #()) in
    let: "$r0" := (chan.make (go.StructType [
    ]) #(W64 2)) in
    do:  ("ch" <-[go.ChannelType go.sendrecv (go.StructType [
    ])] "$r0");;;
    let: "world" := (GoAlloc go.string #()) in
    let: "hello" := (GoAlloc go.string #()) in
    let: "$go" := (λ: <>,
      exception_do (let: "$r0" := #"Hello"%go in
      do:  ("hello" <-[go.string] "$r0");;;
      do:  (let: "$chan" := (![go.ChannelType go.sendrecv (go.StructType [
      ])] "ch") in
      let: "$v" := (struct.make (go.StructType [
      ]) [{
      }]) in
      chan.send (go.StructType [
      ]) "$chan" "$v");;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    let: "$go" := (λ: <>,
      exception_do (let: "$r0" := #"World"%go in
      do:  ("world" <-[go.string] "$r0");;;
      do:  (let: "$chan" := (![go.ChannelType go.sendrecv (go.StructType [
      ])] "ch") in
      let: "$v" := (struct.make (go.StructType [
      ]) [{
      }]) in
      chan.send (go.StructType [
      ]) "$chan" "$v");;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    do:  (Fst (chan.receive (go.StructType [
    ]) (![go.ChannelType go.sendrecv (go.StructType [
    ])] "ch")));;;
    do:  (Fst (chan.receive (go.StructType [
    ]) (![go.ChannelType go.sendrecv (go.StructType [
    ])] "ch")));;;
    return: (((![go.string] "hello") + #" "%go) + (![go.string] "world"))).

Definition select_nb_no_panic : go_string := "github.com/goose-lang/goose/testdata/examples/channel.select_nb_no_panic"%go.

(* Show that it isn't possible to have 2 nonblocking ops that match.

   go: examples.go:121:6 *)
Definition select_nb_no_panicⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ch" := (GoAlloc (go.ChannelType go.sendrecv (go.StructType [
    ])) #()) in
    let: "$r0" := (chan.make (go.StructType [
    ]) #(W64 0)) in
    do:  ("ch" <-[go.ChannelType go.sendrecv (go.StructType [
    ])] "$r0");;;
    let: "$go" := (λ: <>,
      exception_do (chan.select_nonblocking [chan.select_receive (go.StructType [
       ]) (![go.ChannelType go.sendrecv (go.StructType [
       ])] "ch") (λ: "$recvVal",
         do:  (let: "$a0" := (InterfaceMake go.string #"bad"%go) in
         Panic "$a0")
         )] (λ: <>,
        do:  #()
        );;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    chan.select_nonblocking [chan.select_send (go.StructType [
     ]) (![go.ChannelType go.sendrecv (go.StructType [
     ])] "ch") (struct.make (go.StructType [
     ]) [{
     }]) (λ: <>,
       do:  (let: "$a0" := (InterfaceMake go.string #"bad"%go) in
       Panic "$a0")
       )] (λ: <>,
      do:  #()
      );;;
    return: #()).

Definition select_no_double_close : go_string := "github.com/goose-lang/goose/testdata/examples/channel.select_no_double_close"%go.

(* go: examples.go:138:6 *)
Definition select_no_double_closeⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc (go.ChannelType go.sendrecv go.int) #()) in
    let: "$r0" := (chan.make go.int #(W64 0)) in
    do:  ("x" <-[go.ChannelType go.sendrecv go.int] "$r0");;;
    do:  (let: "$a0" := (![go.ChannelType go.sendrecv go.int] "x") in
    (chan.close go.int) "$a0");;;
    chan.select_nonblocking [chan.select_receive go.int (![go.ChannelType go.sendrecv go.int] "x") (λ: "$recvVal",
       do:  #()
       )] (λ: <>,
      do:  (let: "$a0" := (![go.ChannelType go.sendrecv go.int] "x") in
      (chan.close go.int) "$a0")
      );;;
    return: #()).

Definition exchangePointer : go_string := "github.com/goose-lang/goose/testdata/examples/channel.exchangePointer"%go.

(* go: examples.go:148:6 *)
Definition exchangePointerⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.int #()) in
    let: "$r0" := #(W64 0) in
    do:  ("x" <-[go.int] "$r0");;;
    let: "y" := (GoAlloc go.int #()) in
    let: "$r0" := #(W64 0) in
    do:  ("y" <-[go.int] "$r0");;;
    let: "ch" := (GoAlloc (go.ChannelType go.sendrecv (go.StructType [
    ])) #()) in
    let: "$r0" := (chan.make (go.StructType [
    ]) #(W64 0)) in
    do:  ("ch" <-[go.ChannelType go.sendrecv (go.StructType [
    ])] "$r0");;;
    let: "$go" := (λ: <>,
      exception_do (let: "$r0" := #(W64 1) in
      do:  ("x" <-[go.int] "$r0");;;
      do:  (let: "$chan" := (![go.ChannelType go.sendrecv (go.StructType [
      ])] "ch") in
      let: "$v" := (struct.make (go.StructType [
      ]) [{
      }]) in
      chan.send (go.StructType [
      ]) "$chan" "$v");;;
      (if: (![go.int] "y") ≠ #(W64 2)
      then
        do:  (let: "$a0" := (InterfaceMake go.string #"bad"%go) in
        Panic "$a0")
      else do:  #());;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    let: "$r0" := #(W64 2) in
    do:  ("y" <-[go.int] "$r0");;;
    do:  (Fst (chan.receive (go.StructType [
    ]) (![go.ChannelType go.sendrecv (go.StructType [
    ])] "ch")));;;
    (if: (![go.int] "x") ≠ #(W64 1)
    then
      do:  (let: "$a0" := (InterfaceMake go.string #"bad"%go) in
      Panic "$a0")
    else do:  #());;;
    return: #()).

Definition select_ready_case_no_panic : go_string := "github.com/goose-lang/goose/testdata/examples/channel.select_ready_case_no_panic"%go.

(* Show that a guaranteed to be ready case makes default impossible

   go: examples_unverified.go:6:6 *)
Definition select_ready_case_no_panicⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ch" := (GoAlloc (go.ChannelType go.sendrecv (go.StructType [
    ])) #()) in
    let: "$r0" := (chan.make (go.StructType [
    ]) #(W64 0)) in
    do:  ("ch" <-[go.ChannelType go.sendrecv (go.StructType [
    ])] "$r0");;;
    do:  (let: "$a0" := (![go.ChannelType go.sendrecv (go.StructType [
    ])] "ch") in
    (chan.close (go.StructType [
    ])) "$a0");;;
    chan.select_nonblocking [chan.select_receive (go.StructType [
     ]) (![go.ChannelType go.sendrecv (go.StructType [
     ])] "ch") (λ: "$recvVal",
       do:  #()
       )] (λ: <>,
      do:  (let: "$a0" := (InterfaceMake go.string #"Shouldn't be possible!"%go) in
      Panic "$a0")
      );;;
    return: #()).

Definition TestHelloWorldSync : go_string := "github.com/goose-lang/goose/testdata/examples/channel.TestHelloWorldSync"%go.

(* Various tests that should panic when failing, which also means verifying { True } e { True } is
   sufficient since panic can't be verified.

   go: examples_unverified.go:20:6 *)
Definition TestHelloWorldSyncⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "result" := (GoAlloc go.string #()) in
    let: "$r0" := ((FuncResolve HelloWorldSync #()) #()) in
    do:  ("result" <-[go.string] "$r0");;;
    (if: (![go.string] "result") ≠ #"Hello, World!"%go
    then
      do:  (let: "$a0" := (InterfaceMake go.string #"incorrect output"%go) in
      Panic "$a0")
    else do:  #());;;
    return: #()).

Definition TestHelloWorldWithTimeout : go_string := "github.com/goose-lang/goose/testdata/examples/channel.TestHelloWorldWithTimeout"%go.

(* go: examples_unverified.go:27:6 *)
Definition TestHelloWorldWithTimeoutⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "result" := (GoAlloc go.string #()) in
    let: "$r0" := ((FuncResolve HelloWorldWithTimeout #()) #()) in
    do:  ("result" <-[go.string] "$r0");;;
    (if: ((![go.string] "result") ≠ #"operation timed out"%go) && ((![go.string] "result") ≠ #"Hello, World!"%go)
    then
      do:  (let: "$a0" := (InterfaceMake go.string #"incorrect output"%go) in
      Panic "$a0")
    else do:  #());;;
    return: #()).

Definition TestDSPExample : go_string := "github.com/goose-lang/goose/testdata/examples/channel.TestDSPExample"%go.

(* go: examples_unverified.go:34:6 *)
Definition TestDSPExampleⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "result" := (GoAlloc go.int #()) in
    let: "$r0" := ((FuncResolve DSPExample #()) #()) in
    do:  ("result" <-[go.int] "$r0");;;
    (if: (![go.int] "result") ≠ #(W64 42)
    then
      do:  (let: "$a0" := (InterfaceMake go.string #"incorrect output"%go) in
      Panic "$a0")
    else do:  #());;;
    return: #()).

Definition TestFibConsumer : go_string := "github.com/goose-lang/goose/testdata/examples/channel.TestFibConsumer"%go.

(* go: examples_unverified.go:41:6 *)
Definition TestFibConsumerⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "result" := (GoAlloc (go.SliceType go.int) #()) in
    let: "$r0" := ((FuncResolve fib_consumer #()) #()) in
    do:  ("result" <-[go.SliceType go.int] "$r0");;;
    let: "expected" := (GoAlloc (go.SliceType go.int) #()) in
    let: "$r0" := ((let: "$sl0" := #(W64 0) in
    let: "$sl1" := #(W64 1) in
    let: "$sl2" := #(W64 1) in
    let: "$sl3" := #(W64 2) in
    let: "$sl4" := #(W64 3) in
    let: "$sl5" := #(W64 5) in
    let: "$sl6" := #(W64 8) in
    let: "$sl7" := #(W64 13) in
    let: "$sl8" := #(W64 21) in
    let: "$sl9" := #(W64 34) in
    slice.literal go.int ["$sl0"; "$sl1"; "$sl2"; "$sl3"; "$sl4"; "$sl5"; "$sl6"; "$sl7"; "$sl8"; "$sl9"])) in
    do:  ("expected" <-[go.SliceType go.int] "$r0");;;
    (if: (let: "$a0" := (![go.SliceType go.int] "result") in
    slice.len "$a0") ≠ (let: "$a0" := (![go.SliceType go.int] "expected") in
    slice.len "$a0")
    then
      do:  (let: "$a0" := (InterfaceMake go.string #"incorrect output"%go) in
      Panic "$a0")
    else do:  #());;;
    let: "$range" := (![go.SliceType go.int] "expected") in
    (let: "i" := (GoAlloc go.int #()) in
    slice.for_range go.int "$range" (λ: "$key" "$value",
      do:  ("i" <-[go.int] "$key");;;
      (if: (![go.int] (slice.elem_ref go.int (![go.SliceType go.int] "result") (![go.int] "i"))) ≠ (![go.int] (slice.elem_ref go.int (![go.SliceType go.int] "expected") (![go.int] "i")))
      then
        do:  (let: "$a0" := (InterfaceMake go.string #"incorrect output"%go) in
        Panic "$a0")
      else do:  #())));;;
    return: #()).

Definition TestSelectNbNoPanic : go_string := "github.com/goose-lang/goose/testdata/examples/channel.TestSelectNbNoPanic"%go.

(* go: examples_unverified.go:56:6 *)
Definition TestSelectNbNoPanicⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "iterations" := (GoAlloc go.int #()) in
    let: "$r0" := #(W64 10000) in
    do:  ("iterations" <-[go.int] "$r0");;;
    (let: "i" := (GoAlloc go.int #()) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.int] "$r0");;;
    (for: (λ: <>, int_lt (![go.int] "i") (![go.int] "iterations")); (λ: <>, do:  ("i" <-[go.int] ((![go.int] "i") + #(W64 1)))) := λ: <>,
      do:  ((FuncResolve select_nb_no_panic #()) #());;;
      do:  (let: "$a0" := (#(W64 1) * time.Microsecond) in
      (FuncResolve time.Sleep #()) "$a0")));;;
    return: #()).

Definition TestSelectReadyCaseNoPanic : go_string := "github.com/goose-lang/goose/testdata/examples/channel.TestSelectReadyCaseNoPanic"%go.

(* go: examples_unverified.go:65:6 *)
Definition TestSelectReadyCaseNoPanicⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "iterations" := (GoAlloc go.int #()) in
    let: "$r0" := #(W64 10000) in
    do:  ("iterations" <-[go.int] "$r0");;;
    (let: "i" := (GoAlloc go.int #()) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.int] "$r0");;;
    (for: (λ: <>, int_lt (![go.int] "i") (![go.int] "iterations")); (λ: <>, do:  ("i" <-[go.int] ((![go.int] "i") + #(W64 1)))) := λ: <>,
      do:  ((FuncResolve select_ready_case_no_panic #()) #())));;;
    return: #()).

Definition requestⁱᵐᵖˡ  : go.type := go.StructType [
  (go.FieldDecl "f"%go go.FunctionType (go.Signature [] #false [go.string]));
  (go.FieldDecl "result"%go go.ChannelType go.sendrecv go.string)
].

Definition mkRequest : go_string := "github.com/goose-lang/goose/testdata/examples/channel.mkRequest"%go.

(* go: higher_order.go:8:6 *)
Definition mkRequestⁱᵐᵖˡ : val :=
  λ: "f",
    exception_do (let: "f" := (GoAllocValue (go.FunctionType (go.Signature [] #false [go.string])) "f") in
    return: (let: "$f" := (![go.FunctionType (go.Signature [] #false [go.string])] "f") in
     let: "$result" := (chan.make go.string #(W64 1)) in
     struct.make request [{
       "f" ::= "$f";
       "result" ::= "$result"
     }])).

Definition ho_worker : go_string := "github.com/goose-lang/goose/testdata/examples/channel.ho_worker"%go.

(* go: higher_order.go:12:6 *)
Definition ho_workerⁱᵐᵖˡ : val :=
  λ: "c",
    exception_do (let: "c" := (GoAllocValue (go.ChannelType go.sendrecv request) "c") in
    let: "$range" := (![go.ChannelType go.sendrecv request] "c") in
    (let: "r" := (GoAlloc request #()) in
    chan.for_range request "$range" (λ: "$key",
      do:  ("r" <-[request] "$key");;;
      do:  (let: "$chan" := (![go.ChannelType go.sendrecv go.string] (struct.field_ref request #"result"%go "r")) in
      let: "$v" := ((![go.FunctionType (go.Signature [] #false [go.string])] (struct.field_ref request #"f"%go "r")) #()) in
      chan.send go.string "$chan" "$v")));;;
    return: #()).

Definition HigherOrderExample : go_string := "github.com/goose-lang/goose/testdata/examples/channel.HigherOrderExample"%go.

(* go: higher_order.go:18:6 *)
Definition HigherOrderExampleⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "c" := (GoAlloc (go.ChannelType go.sendrecv request) #()) in
    let: "$r0" := (chan.make request #(W64 0)) in
    do:  ("c" <-[go.ChannelType go.sendrecv request] "$r0");;;
    let: "$a0" := (![go.ChannelType go.sendrecv request] "c") in
    let: "$go" := (FuncResolve ho_worker #()) in
    do:  (Fork ("$go" "$a0"));;;
    let: "$a0" := (![go.ChannelType go.sendrecv request] "c") in
    let: "$go" := (FuncResolve ho_worker #()) in
    do:  (Fork ("$go" "$a0"));;;
    let: "r1" := (GoAlloc request #()) in
    let: "$r0" := (let: "$a0" := (λ: <>,
      exception_do (return: (#("hello"%go ++ " world"%go)))
      ) in
    (FuncResolve mkRequest #()) "$a0") in
    do:  ("r1" <-[request] "$r0");;;
    let: "r2" := (GoAlloc request #()) in
    let: "$r0" := (let: "$a0" := (λ: <>,
      exception_do (return: (#"HELLO"%go))
      ) in
    (FuncResolve mkRequest #()) "$a0") in
    do:  ("r2" <-[request] "$r0");;;
    let: "r3" := (GoAlloc request #()) in
    let: "$r0" := (let: "$a0" := (λ: <>,
      exception_do (return: (#(("w"%go ++ "o"%go) ++ "rld"%go)))
      ) in
    (FuncResolve mkRequest #()) "$a0") in
    do:  ("r3" <-[request] "$r0");;;
    do:  (let: "$chan" := (![go.ChannelType go.sendrecv request] "c") in
    let: "$v" := (![request] "r1") in
    chan.send request "$chan" "$v");;;
    do:  (let: "$chan" := (![go.ChannelType go.sendrecv request] "c") in
    let: "$v" := (![request] "r2") in
    chan.send request "$chan" "$v");;;
    do:  (let: "$chan" := (![go.ChannelType go.sendrecv request] "c") in
    let: "$v" := (![request] "r3") in
    chan.send request "$chan" "$v");;;
    let: "responses" := (GoAlloc (go.SliceType go.string) #()) in
    let: "$r0" := ((let: "$sl0" := (Fst (chan.receive go.string (![go.ChannelType go.sendrecv go.string] (struct.field_ref request #"result"%go "r1")))) in
    let: "$sl1" := (Fst (chan.receive go.string (![go.ChannelType go.sendrecv go.string] (struct.field_ref request #"result"%go "r2")))) in
    let: "$sl2" := (Fst (chan.receive go.string (![go.ChannelType go.sendrecv go.string] (struct.field_ref request #"result"%go "r3")))) in
    slice.literal go.string ["$sl0"; "$sl1"; "$sl2"])) in
    do:  ("responses" <-[go.SliceType go.string] "$r0");;;
    return: (![go.SliceType go.string] "responses")).

Definition load : go_string := "github.com/goose-lang/goose/testdata/examples/channel.load"%go.

(* load writes the next letter into the buffer.

   go: leaky_buffer.go:9:6 *)
Definition loadⁱᵐᵖˡ : val :=
  λ: "b" "letter",
    exception_do (let: "letter" := (GoAllocValue go.string "letter") in
    let: "b" := (GoAllocValue (go.PointerType (go.SliceType go.byte)) "b") in
    let: "$r0" := (string.to_bytes (![go.string] "letter")) in
    do:  ((![go.PointerType (go.SliceType go.byte)] "b") <-[go.SliceType go.byte] "$r0");;;
    return: #()).

Definition process : go_string := "github.com/goose-lang/goose/testdata/examples/channel.process"%go.

(* process consumes the buffer and appends it to the output.

   go: leaky_buffer.go:14:6 *)
Definition processⁱᵐᵖˡ : val :=
  λ: "b" "output",
    exception_do (let: "output" := (GoAllocValue (go.PointerType go.string) "output") in
    let: "b" := (GoAllocValue (go.PointerType (go.SliceType go.byte)) "b") in
    do:  ((![go.PointerType go.string] "output") <-[go.string] ((![go.string] (![go.PointerType go.string] "output")) + (let: "$a0" := (string.from_bytes (![go.SliceType go.byte] (![go.PointerType (go.SliceType go.byte)] "b"))) in
    (FuncResolve strings.ToUpper #()) "$a0")));;;
    return: #()).

Definition client : go_string := "github.com/goose-lang/goose/testdata/examples/channel.client"%go.

(* go: leaky_buffer.go:18:6 *)
Definition clientⁱᵐᵖˡ : val :=
  λ: "input" "freeList" "serverChan",
    exception_do (let: "serverChan" := (GoAllocValue (go.ChannelType go.sendrecv (go.SliceType go.byte)) "serverChan") in
    let: "freeList" := (GoAllocValue (go.ChannelType go.sendrecv (go.SliceType go.byte)) "freeList") in
    let: "input" := (GoAllocValue (go.SliceType go.string) "input") in
    let: "$range" := (![go.SliceType go.string] "input") in
    (let: "letter" := (GoAlloc go.string #()) in
    slice.for_range go.string "$range" (λ: "$key" "$value",
      do:  ("letter" <-[go.string] "$value");;;
      do:  "$key";;;
      let: "b" := (GoAlloc (go.SliceType go.byte) #()) in
      chan.select_nonblocking [chan.select_receive (go.SliceType go.byte) (![go.ChannelType go.sendrecv (go.SliceType go.byte)] "freeList") (λ: "$recvVal",
         let: "$r0" := (Fst "$recvVal") in
         do:  ("b" <-[go.SliceType go.byte] "$r0");;;
         do:  #()
         )] (λ: <>,
        let: "$r0" := ((let: "$sl0" := #(W8 0) in
        slice.literal go.byte ["$sl0"])) in
        do:  ("b" <-[go.SliceType go.byte] "$r0")
        );;;
      do:  (let: "$a0" := "b" in
      let: "$a1" := (![go.string] "letter") in
      (FuncResolve load #()) "$a0" "$a1");;;
      do:  (let: "$chan" := (![go.ChannelType go.sendrecv (go.SliceType go.byte)] "serverChan") in
      let: "$v" := (![go.SliceType go.byte] "b") in
      chan.send (go.SliceType go.byte) "$chan" "$v")));;;
    do:  (let: "$a0" := (![go.ChannelType go.sendrecv (go.SliceType go.byte)] "serverChan") in
    (chan.close (go.SliceType go.byte)) "$a0");;;
    return: #()).

Definition server : go_string := "github.com/goose-lang/goose/testdata/examples/channel.server"%go.

(* go: leaky_buffer.go:39:6 *)
Definition serverⁱᵐᵖˡ : val :=
  λ: "output" "freeList" "serverChan" "done",
    exception_do (let: "done" := (GoAllocValue (go.ChannelType go.sendrecv (go.StructType [
    ])) "done") in
    let: "serverChan" := (GoAllocValue (go.ChannelType go.sendrecv (go.SliceType go.byte)) "serverChan") in
    let: "freeList" := (GoAllocValue (go.ChannelType go.sendrecv (go.SliceType go.byte)) "freeList") in
    let: "output" := (GoAllocValue (go.PointerType go.string) "output") in
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "ok" := (GoAlloc go.bool #()) in
      let: "b" := (GoAlloc (go.SliceType go.byte) #()) in
      let: ("$ret0", "$ret1") := (chan.receive (go.SliceType go.byte) (![go.ChannelType go.sendrecv (go.SliceType go.byte)] "serverChan")) in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("b" <-[go.SliceType go.byte] "$r0");;;
      do:  ("ok" <-[go.bool] "$r1");;;
      (if: (~ (![go.bool] "ok"))
      then
        do:  (let: "$chan" := (![go.ChannelType go.sendrecv (go.StructType [
        ])] "done") in
        let: "$v" := (struct.make (go.StructType [
        ]) [{
        }]) in
        chan.send (go.StructType [
        ]) "$chan" "$v");;;
        return: (#())
      else do:  #());;;
      do:  (let: "$a0" := "b" in
      let: "$a1" := (![go.PointerType go.string] "output") in
      (FuncResolve process #()) "$a0" "$a1");;;
      chan.select_nonblocking [chan.select_send (go.SliceType go.byte) (![go.ChannelType go.sendrecv (go.SliceType go.byte)] "freeList") (![go.SliceType go.byte] "b") (λ: <>,
         do:  #()
         )] (λ: <>,
        do:  #()
        ));;;
    return: #()).

Definition LeakyBufferPipeline : go_string := "github.com/goose-lang/goose/testdata/examples/channel.LeakyBufferPipeline"%go.

(* go: leaky_buffer.go:61:6 *)
Definition LeakyBufferPipelineⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "freeList" := (GoAlloc (go.ChannelType go.sendrecv (go.SliceType go.byte)) #()) in
    let: "$r0" := (chan.make (go.SliceType go.byte) #(W64 5)) in
    do:  ("freeList" <-[go.ChannelType go.sendrecv (go.SliceType go.byte)] "$r0");;;
    let: "serverChan" := (GoAlloc (go.ChannelType go.sendrecv (go.SliceType go.byte)) #()) in
    let: "$r0" := (chan.make (go.SliceType go.byte) #(W64 0)) in
    do:  ("serverChan" <-[go.ChannelType go.sendrecv (go.SliceType go.byte)] "$r0");;;
    let: "done" := (GoAlloc (go.ChannelType go.sendrecv (go.StructType [
    ])) #()) in
    let: "$r0" := (chan.make (go.StructType [
    ]) #(W64 0)) in
    do:  ("done" <-[go.ChannelType go.sendrecv (go.StructType [
    ])] "$r0");;;
    let: "output" := (GoAlloc go.string #()) in
    let: "$r0" := #""%go in
    do:  ("output" <-[go.string] "$r0");;;
    let: "$a0" := "output" in
    let: "$a1" := (![go.ChannelType go.sendrecv (go.SliceType go.byte)] "freeList") in
    let: "$a2" := (![go.ChannelType go.sendrecv (go.SliceType go.byte)] "serverChan") in
    let: "$a3" := (![go.ChannelType go.sendrecv (go.StructType [
    ])] "done") in
    let: "$go" := (FuncResolve server #()) in
    do:  (Fork ("$go" "$a0" "$a1" "$a2" "$a3"));;;
    do:  (let: "$a0" := ((let: "$sl0" := #"h"%go in
    let: "$sl1" := #"e"%go in
    let: "$sl2" := #"l"%go in
    let: "$sl3" := #"l"%go in
    let: "$sl4" := #"o"%go in
    let: "$sl5" := #","%go in
    let: "$sl6" := #" "%go in
    let: "$sl7" := #"w"%go in
    let: "$sl8" := #"o"%go in
    let: "$sl9" := #"r"%go in
    let: "$sl10" := #"l"%go in
    let: "$sl11" := #"d"%go in
    slice.literal go.string ["$sl0"; "$sl1"; "$sl2"; "$sl3"; "$sl4"; "$sl5"; "$sl6"; "$sl7"; "$sl8"; "$sl9"; "$sl10"; "$sl11"])) in
    let: "$a1" := (![go.ChannelType go.sendrecv (go.SliceType go.byte)] "freeList") in
    let: "$a2" := (![go.ChannelType go.sendrecv (go.SliceType go.byte)] "serverChan") in
    (FuncResolve client #()) "$a0" "$a1" "$a2");;;
    do:  (Fst (chan.receive (go.StructType [
    ]) (![go.ChannelType go.sendrecv (go.StructType [
    ])] "done")));;;
    (if: (![go.string] "output") ≠ #"HELLO, WORLD"%go
    then
      do:  (let: "$a0" := (InterfaceMake go.string #"incorrect output"%go) in
      Panic "$a0")
    else do:  #());;;
    return: #()).

Definition streamⁱᵐᵖˡ  : go.type := go.StructType [
  (go.FieldDecl "req"%go go.ChannelType go.sendrecv go.string);
  (go.FieldDecl "res"%go go.ChannelType go.sendrecv go.string)
].

Definition streamoldⁱᵐᵖˡ  : go.type := go.StructType [
  (go.FieldDecl "req"%go go.ChannelType go.sendrecv go.string);
  (go.FieldDecl "res"%go go.ChannelType go.sendrecv go.string);
  (go.FieldDecl "f"%go go.FunctionType (go.Signature [go.string] #false [go.string]))
].

Definition mkStream : go_string := "github.com/goose-lang/goose/testdata/examples/channel.mkStream"%go.

(* go: muxer.go:14:6 *)
Definition mkStreamⁱᵐᵖˡ : val :=
  λ: "f",
    exception_do (let: "f" := (GoAllocValue (go.FunctionType (go.Signature [go.string] #false [go.string])) "f") in
    return: (struct.make streamold [{
       "req" ::= chan.make go.string #(W64 0);
       "res" ::= chan.make go.string #(W64 0);
       "f" ::= ![go.FunctionType (go.Signature [go.string] #false [go.string])] "f"
     }])).

Definition Async : go_string := "github.com/goose-lang/goose/testdata/examples/channel.Async"%go.

(* go: muxer.go:18:6 *)
Definition Asyncⁱᵐᵖˡ : val :=
  λ: "f",
    exception_do (let: "f" := (GoAllocValue (go.FunctionType (go.Signature [] #false [go.string])) "f") in
    let: "ch" := (GoAlloc (go.ChannelType go.sendrecv go.string) #()) in
    let: "$r0" := (chan.make go.string #(W64 1)) in
    do:  ("ch" <-[go.ChannelType go.sendrecv go.string] "$r0");;;
    let: "$go" := (λ: <>,
      exception_do (do:  (let: "$chan" := (![go.ChannelType go.sendrecv go.string] "ch") in
      let: "$v" := ((![go.FunctionType (go.Signature [] #false [go.string])] "f") #()) in
      chan.send go.string "$chan" "$v");;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    return: (![go.ChannelType go.sendrecv go.string] "ch")).

Definition Serve : go_string := "github.com/goose-lang/goose/testdata/examples/channel.Serve"%go.

(* go: muxer.go:26:6 *)
Definition Serveⁱᵐᵖˡ : val :=
  λ: "f",
    exception_do (let: "f" := (GoAllocValue (go.FunctionType (go.Signature [go.string] #false [go.string])) "f") in
    let: "s" := (GoAlloc stream #()) in
    let: "$r0" := (let: "$req" := (chan.make go.string #(W64 0)) in
    let: "$res" := (chan.make go.string #(W64 0)) in
    struct.make stream [{
      "req" ::= "$req";
      "res" ::= "$res"
    }]) in
    do:  ("s" <-[stream] "$r0");;;
    let: "$go" := (λ: <>,
      exception_do ((for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
        do:  (let: "$chan" := (![go.ChannelType go.sendrecv go.string] (struct.field_ref stream #"res"%go "s")) in
        let: "$v" := (let: "$a0" := (Fst (chan.receive go.string (![go.ChannelType go.sendrecv go.string] (struct.field_ref stream #"req"%go "s")))) in
        (![go.FunctionType (go.Signature [go.string] #false [go.string])] "f") "$a0") in
        chan.send go.string "$chan" "$v"));;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    return: (![stream] "s")).

Definition appWrld : go_string := "github.com/goose-lang/goose/testdata/examples/channel.appWrld"%go.

(* go: muxer.go:39:6 *)
Definition appWrldⁱᵐᵖˡ : val :=
  λ: "s",
    exception_do (let: "s" := (GoAllocValue go.string "s") in
    return: ((![go.string] "s") + #", World!"%go)).

Definition Client : go_string := "github.com/goose-lang/goose/testdata/examples/channel.Client"%go.

(* go: muxer.go:43:6 *)
Definition Clientⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "hw" := (GoAlloc stream #()) in
    let: "$r0" := (let: "$a0" := (FuncResolve appWrld #()) in
    (FuncResolve Serve #()) "$a0") in
    do:  ("hw" <-[stream] "$r0");;;
    do:  (let: "$chan" := (![go.ChannelType go.sendrecv go.string] (struct.field_ref stream #"req"%go "hw")) in
    let: "$v" := #"Hello"%go in
    chan.send go.string "$chan" "$v");;;
    return: (Fst (chan.receive go.string (![go.ChannelType go.sendrecv go.string] (struct.field_ref stream #"res"%go "hw"))))).

Definition MapServer : go_string := "github.com/goose-lang/goose/testdata/examples/channel.MapServer"%go.

(* go: muxer.go:49:6 *)
Definition MapServerⁱᵐᵖˡ : val :=
  λ: "s",
    exception_do (let: "s" := (GoAllocValue streamold "s") in
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "in" := (GoAlloc go.string #()) in
      let: "$r0" := (Fst (chan.receive go.string (![go.ChannelType go.sendrecv go.string] (struct.field_ref streamold #"req"%go "s")))) in
      do:  ("in" <-[go.string] "$r0");;;
      do:  (let: "$chan" := (![go.ChannelType go.sendrecv go.string] (struct.field_ref streamold #"res"%go "s")) in
      let: "$v" := (let: "$a0" := (![go.string] "in") in
      (![go.FunctionType (go.Signature [go.string] #false [go.string])] (struct.field_ref streamold #"f"%go "s")) "$a0") in
      chan.send go.string "$chan" "$v"));;;
    return: #()).

Definition ClientOld : go_string := "github.com/goose-lang/goose/testdata/examples/channel.ClientOld"%go.

(* go: muxer.go:56:6 *)
Definition ClientOldⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "comma" := (GoAlloc streamold #()) in
    let: "$r0" := (let: "$a0" := (λ: "s",
      exception_do (let: "s" := (GoAllocValue go.string "s") in
      return: ((![go.string] "s") + #","%go))
      ) in
    (FuncResolve mkStream #()) "$a0") in
    do:  ("comma" <-[streamold] "$r0");;;
    let: "exclaim" := (GoAlloc streamold #()) in
    let: "$r0" := (let: "$a0" := (λ: "s",
      exception_do (let: "s" := (GoAllocValue go.string "s") in
      return: ((![go.string] "s") + #"!"%go))
      ) in
    (FuncResolve mkStream #()) "$a0") in
    do:  ("exclaim" <-[streamold] "$r0");;;
    let: "$a0" := (![streamold] "comma") in
    let: "$go" := (FuncResolve MapServer #()) in
    do:  (Fork ("$go" "$a0"));;;
    let: "$a0" := (![streamold] "exclaim") in
    let: "$go" := (FuncResolve MapServer #()) in
    do:  (Fork ("$go" "$a0"));;;
    do:  (let: "$chan" := (![go.ChannelType go.sendrecv go.string] (struct.field_ref streamold #"req"%go "comma")) in
    let: "$v" := #"Hello"%go in
    chan.send go.string "$chan" "$v");;;
    do:  (let: "$chan" := (![go.ChannelType go.sendrecv go.string] (struct.field_ref streamold #"req"%go "exclaim")) in
    let: "$v" := #"World"%go in
    chan.send go.string "$chan" "$v");;;
    return: (((Fst (chan.receive go.string (![go.ChannelType go.sendrecv go.string] (struct.field_ref streamold #"res"%go "comma")))) + #" "%go) + (Fst (chan.receive go.string (![go.ChannelType go.sendrecv go.string] (struct.field_ref streamold #"res"%go "exclaim")))))).

Definition Muxer : go_string := "github.com/goose-lang/goose/testdata/examples/channel.Muxer"%go.

(* go: muxer.go:71:6 *)
Definition Muxerⁱᵐᵖˡ : val :=
  λ: "c",
    exception_do (let: "c" := (GoAllocValue (go.ChannelType go.sendrecv streamold) "c") in
    let: "$range" := (![go.ChannelType go.sendrecv streamold] "c") in
    (let: "s" := (GoAlloc streamold #()) in
    chan.for_range streamold "$range" (λ: "$key",
      do:  ("s" <-[streamold] "$key");;;
      let: "$a0" := (![streamold] "s") in
      let: "$go" := (FuncResolve MapServer #()) in
      do:  (Fork ("$go" "$a0"))));;;
    return: #()).

Definition makeGreeting : go_string := "github.com/goose-lang/goose/testdata/examples/channel.makeGreeting"%go.

(* go: muxer.go:77:6 *)
Definition makeGreetingⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "mux" := (GoAlloc (go.ChannelType go.sendrecv streamold) #()) in
    let: "$r0" := (chan.make streamold #(W64 2)) in
    do:  ("mux" <-[go.ChannelType go.sendrecv streamold] "$r0");;;
    let: "$a0" := (![go.ChannelType go.sendrecv streamold] "mux") in
    let: "$go" := (FuncResolve Muxer #()) in
    do:  (Fork ("$go" "$a0"));;;
    let: "comma" := (GoAlloc streamold #()) in
    let: "$r0" := (let: "$a0" := (λ: "s",
      exception_do (let: "s" := (GoAllocValue go.string "s") in
      return: ((![go.string] "s") + #","%go))
      ) in
    (FuncResolve mkStream #()) "$a0") in
    do:  ("comma" <-[streamold] "$r0");;;
    let: "exclaim" := (GoAlloc streamold #()) in
    let: "$r0" := (let: "$a0" := (λ: "s",
      exception_do (let: "s" := (GoAllocValue go.string "s") in
      return: ((![go.string] "s") + #"!"%go))
      ) in
    (FuncResolve mkStream #()) "$a0") in
    do:  ("exclaim" <-[streamold] "$r0");;;
    do:  (let: "$chan" := (![go.ChannelType go.sendrecv streamold] "mux") in
    let: "$v" := (![streamold] "comma") in
    chan.send streamold "$chan" "$v");;;
    do:  (let: "$chan" := (![go.ChannelType go.sendrecv streamold] "mux") in
    let: "$v" := (![streamold] "exclaim") in
    chan.send streamold "$chan" "$v");;;
    do:  (let: "$chan" := (![go.ChannelType go.sendrecv go.string] (struct.field_ref streamold #"req"%go "comma")) in
    let: "$v" := #"Hello"%go in
    chan.send go.string "$chan" "$v");;;
    do:  (let: "$chan" := (![go.ChannelType go.sendrecv go.string] (struct.field_ref streamold #"req"%go "exclaim")) in
    let: "$v" := #"World"%go in
    chan.send go.string "$chan" "$v");;;
    return: (((Fst (chan.receive go.string (![go.ChannelType go.sendrecv go.string] (struct.field_ref streamold #"res"%go "comma")))) + #" "%go) + (Fst (chan.receive go.string (![go.ChannelType go.sendrecv go.string] (struct.field_ref streamold #"res"%go "exclaim")))))).

Definition CancellableMapServer : go_string := "github.com/goose-lang/goose/testdata/examples/channel.CancellableMapServer"%go.

(* go: muxer_unverified.go:3:6 *)
Definition CancellableMapServerⁱᵐᵖˡ : val :=
  λ: "s" "done",
    exception_do (let: "done" := (GoAllocValue (go.ChannelType go.sendrecv (go.StructType [
    ])) "done") in
    let: "s" := (GoAllocValue streamold "s") in
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      chan.select_blocking [chan.select_receive go.string (![go.ChannelType go.sendrecv go.string] (struct.field_ref streamold #"req"%go "s")) (λ: "$recvVal",
         let: "ok" := (GoAlloc go.bool #()) in
         let: "in" := (GoAlloc go.string #()) in
         let: ("$ret0", "$ret1") := "$recvVal" in
         let: "$r0" := "$ret0" in
         let: "$r1" := "$ret1" in
         do:  ("in" <-[go.string] "$r0");;;
         do:  ("ok" <-[go.bool] "$r1");;;
         (if: (~ (![go.bool] "ok"))
         then return: (#())
         else do:  #());;;
         do:  (let: "$chan" := (![go.ChannelType go.sendrecv go.string] (struct.field_ref streamold #"res"%go "s")) in
         let: "$v" := (let: "$a0" := (![go.string] "in") in
         (![go.FunctionType (go.Signature [go.string] #false [go.string])] (struct.field_ref streamold #"f"%go "s")) "$a0") in
         chan.send go.string "$chan" "$v")
         ); chan.select_receive (go.StructType [
       ]) (![go.ChannelType go.sendrecv (go.StructType [
       ])] "done") (λ: "$recvVal",
         return: (#())
         )]);;;
    return: #()).

Definition CancellableMuxer : go_string := "github.com/goose-lang/goose/testdata/examples/channel.CancellableMuxer"%go.

(* 4. CancellableMuxer - muxer with cancellation

   go: muxer_unverified.go:18:6 *)
Definition CancellableMuxerⁱᵐᵖˡ : val :=
  λ: "c" "done" "errMsg",
    exception_do (let: "errMsg" := (GoAllocValue (go.PointerType go.string) "errMsg") in
    let: "done" := (GoAllocValue (go.ChannelType go.sendrecv (go.StructType [
    ])) "done") in
    let: "c" := (GoAllocValue (go.ChannelType go.sendrecv streamold) "c") in
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      chan.select_blocking [chan.select_receive streamold (![go.ChannelType go.sendrecv streamold] "c") (λ: "$recvVal",
         let: "ok" := (GoAlloc go.bool #()) in
         let: "s" := (GoAlloc streamold #()) in
         let: ("$ret0", "$ret1") := "$recvVal" in
         let: "$r0" := "$ret0" in
         let: "$r1" := "$ret1" in
         do:  ("s" <-[streamold] "$r0");;;
         do:  ("ok" <-[go.bool] "$r1");;;
         (if: (~ (![go.bool] "ok"))
         then return: (#"serviced all requests"%go)
         else do:  #());;;
         let: "$a0" := (![streamold] "s") in
         let: "$a1" := (![go.ChannelType go.sendrecv (go.StructType [
         ])] "done") in
         let: "$go" := (FuncResolve CancellableMapServer #()) in
         do:  (Fork ("$go" "$a0" "$a1"))
         ); chan.select_receive (go.StructType [
       ]) (![go.ChannelType go.sendrecv (go.StructType [
       ])] "done") (λ: "$recvVal",
         return: (![go.string] (![go.PointerType go.string] "errMsg"))
         )])).

Definition worker : go_string := "github.com/goose-lang/goose/testdata/examples/channel.worker"%go.

(* go: parallel_search_replace.go:13:6 *)
Definition workerⁱᵐᵖˡ : val :=
  λ: "c" "wg" "x" "y",
    exception_do (let: "y" := (GoAllocValue go.int "y") in
    let: "x" := (GoAllocValue go.int "x") in
    let: "wg" := (GoAllocValue (go.PointerType sync.WaitGroup) "wg") in
    let: "c" := (GoAllocValue (go.ChannelType go.recvonly (go.SliceType go.int)) "c") in
    (let: "ok" := (GoAlloc go.bool #()) in
    let: "s" := (GoAlloc (go.SliceType go.int) #()) in
    let: ("$ret0", "$ret1") := (chan.receive (go.SliceType go.int) (![go.ChannelType go.recvonly (go.SliceType go.int)] "c")) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("s" <-[go.SliceType go.int] "$r0");;;
    do:  ("ok" <-[go.bool] "$r1");;;
    (for: (λ: <>, ![go.bool] "ok"); (λ: <>, let: ("$ret0", "$ret1") := (chan.receive (go.SliceType go.int) (![go.ChannelType go.recvonly (go.SliceType go.int)] "c")) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("s" <-[go.SliceType go.int] "$r0");;;
    do:  ("ok" <-[go.bool] "$r1")) := λ: <>,
      (let: "i" := (GoAlloc go.int #()) in
      let: "$r0" := #(W64 0) in
      do:  ("i" <-[go.int] "$r0");;;
      (for: (λ: <>, (![go.int] "i") ≠ (let: "$a0" := (![go.SliceType go.int] "s") in
      slice.len "$a0")); (λ: <>, do:  ("i" <-[go.int] ((![go.int] "i") + #(W64 1)))) := λ: <>,
        (if: (![go.int] (slice.elem_ref go.int (![go.SliceType go.int] "s") (![go.int] "i"))) = (![go.int] "x")
        then
          let: "$r0" := (![go.int] "y") in
          do:  ((slice.elem_ref go.int (![go.SliceType go.int] "s") (![go.int] "i")) <-[go.int] "$r0")
        else do:  #())));;;
      do:  ((MethodResolve (go.PointerType sync.WaitGroup) Done #() (![go.PointerType sync.WaitGroup] "wg")) #())));;;
    return: #()).

Definition SearchReplace : go_string := "github.com/goose-lang/goose/testdata/examples/channel.SearchReplace"%go.

(* go: parallel_search_replace.go:24:6 *)
Definition SearchReplaceⁱᵐᵖˡ : val :=
  λ: "s" "x" "y",
    exception_do (let: "y" := (GoAllocValue go.int "y") in
    let: "x" := (GoAllocValue go.int "x") in
    let: "s" := (GoAllocValue (go.SliceType go.int) "s") in
    (if: (let: "$a0" := (![go.SliceType go.int] "s") in
    slice.len "$a0") = #(W64 0)
    then return: (#())
    else do:  #());;;
    let: "workers" := (GoAlloc go.int #()) in
    let: "$r0" := #(W64 8) in
    do:  ("workers" <-[go.int] "$r0");;;
    let: "workRange" := (GoAlloc go.int #()) in
    let: "$r0" := #(W64 1000) in
    do:  ("workRange" <-[go.int] "$r0");;;
    let: "c" := (GoAlloc (go.ChannelType go.sendrecv (go.SliceType go.int)) #()) in
    let: "$r0" := (chan.make (go.SliceType go.int) #(W64 4)) in
    do:  ("c" <-[go.ChannelType go.sendrecv (go.SliceType go.int)] "$r0");;;
    let: "wg" := (GoAlloc sync.WaitGroup #()) in
    (let: "i" := (GoAlloc go.int #()) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.int] "$r0");;;
    (for: (λ: <>, (![go.int] "i") ≠ (![go.int] "workers")); (λ: <>, do:  ("i" <-[go.int] ((![go.int] "i") + #(W64 1)))) := λ: <>,
      let: "$a0" := (![go.ChannelType go.sendrecv (go.SliceType go.int)] "c") in
      let: "$a1" := "wg" in
      let: "$a2" := (![go.int] "x") in
      let: "$a3" := (![go.int] "y") in
      let: "$go" := (FuncResolve worker #()) in
      do:  (Fork ("$go" "$a0" "$a1" "$a2" "$a3"))));;;
    (let: "offset" := (GoAlloc go.int #()) in
    let: "$r0" := #(W64 0) in
    do:  ("offset" <-[go.int] "$r0");;;
    (for: (λ: <>, (![go.int] "offset") ≠ (let: "$a0" := (![go.SliceType go.int] "s") in
    slice.len "$a0")); (λ: <>, #()) := λ: <>,
      let: "nextOffset" := (GoAlloc go.int #()) in
      let: "$r0" := ((![go.int] "offset") + (![go.int] "workRange")) in
      do:  ("nextOffset" <-[go.int] "$r0");;;
      (if: int_gt (![go.int] "nextOffset") (let: "$a0" := (![go.SliceType go.int] "s") in
      slice.len "$a0")
      then
        let: "$r0" := (let: "$a0" := (![go.SliceType go.int] "s") in
        slice.len "$a0") in
        do:  ("nextOffset" <-[go.int] "$r0")
      else do:  #());;;
      let: "section" := (GoAlloc (go.SliceType go.int) #()) in
      let: "$r0" := (let: "$s" := (![go.SliceType go.int] "s") in
      slice.slice go.int "$s" (![go.int] "offset") (![go.int] "nextOffset")) in
      do:  ("section" <-[go.SliceType go.int] "$r0");;;
      do:  (let: "$a0" := #(W64 1) in
      (MethodResolve (go.PointerType sync.WaitGroup) Add #() "wg") "$a0");;;
      do:  (let: "$chan" := (![go.ChannelType go.sendrecv (go.SliceType go.int)] "c") in
      let: "$v" := (![go.SliceType go.int] "section") in
      chan.send (go.SliceType go.int) "$chan" "$v");;;
      let: "$r0" := (![go.int] "nextOffset") in
      do:  ("offset" <-[go.int] "$r0")));;;
    do:  ((MethodResolve (go.PointerType sync.WaitGroup) Wait #() "wg") #());;;
    return: #()).

Definition vars' : list (go_string * go.type) := [].

Definition functions' : list (go_string * val) := [(NewLockedStack, NewLockedStackⁱᵐᵖˡ); (NewEliminationStack, NewEliminationStackⁱᵐᵖˡ); (sys_hello_world, sys_hello_worldⁱᵐᵖˡ); (HelloWorldAsync, HelloWorldAsyncⁱᵐᵖˡ); (HelloWorldSync, HelloWorldSyncⁱᵐᵖˡ); (HelloWorldCancellable, HelloWorldCancellableⁱᵐᵖˡ); (HelloWorldWithTimeout, HelloWorldWithTimeoutⁱᵐᵖˡ); (DSPExample, DSPExampleⁱᵐᵖˡ); (fibonacci, fibonacciⁱᵐᵖˡ); (fib_consumer, fib_consumerⁱᵐᵖˡ); (simple_join, simple_joinⁱᵐᵖˡ); (simple_multi_join, simple_multi_joinⁱᵐᵖˡ); (select_nb_no_panic, select_nb_no_panicⁱᵐᵖˡ); (select_no_double_close, select_no_double_closeⁱᵐᵖˡ); (exchangePointer, exchangePointerⁱᵐᵖˡ); (select_ready_case_no_panic, select_ready_case_no_panicⁱᵐᵖˡ); (TestHelloWorldSync, TestHelloWorldSyncⁱᵐᵖˡ); (TestHelloWorldWithTimeout, TestHelloWorldWithTimeoutⁱᵐᵖˡ); (TestDSPExample, TestDSPExampleⁱᵐᵖˡ); (TestFibConsumer, TestFibConsumerⁱᵐᵖˡ); (TestSelectNbNoPanic, TestSelectNbNoPanicⁱᵐᵖˡ); (TestSelectReadyCaseNoPanic, TestSelectReadyCaseNoPanicⁱᵐᵖˡ); (mkRequest, mkRequestⁱᵐᵖˡ); (ho_worker, ho_workerⁱᵐᵖˡ); (HigherOrderExample, HigherOrderExampleⁱᵐᵖˡ); (load, loadⁱᵐᵖˡ); (process, processⁱᵐᵖˡ); (client, clientⁱᵐᵖˡ); (server, serverⁱᵐᵖˡ); (LeakyBufferPipeline, LeakyBufferPipelineⁱᵐᵖˡ); (mkStream, mkStreamⁱᵐᵖˡ); (Async, Asyncⁱᵐᵖˡ); (Serve, Serveⁱᵐᵖˡ); (appWrld, appWrldⁱᵐᵖˡ); (Client, Clientⁱᵐᵖˡ); (MapServer, MapServerⁱᵐᵖˡ); (ClientOld, ClientOldⁱᵐᵖˡ); (Muxer, Muxerⁱᵐᵖˡ); (makeGreeting, makeGreetingⁱᵐᵖˡ); (CancellableMapServer, CancellableMapServerⁱᵐᵖˡ); (CancellableMuxer, CancellableMuxerⁱᵐᵖˡ); (worker, workerⁱᵐᵖˡ); (SearchReplace, SearchReplaceⁱᵐᵖˡ)].

Definition msets' : list (go_string * (list (go_string * val))) := [(LockedStack, []); (go.PointerType LockedStack, [("Pop"%go, LockedStack__Popⁱᵐᵖˡ); ("Push"%go, LockedStack__Pushⁱᵐᵖˡ)]); (EliminationStack, []); (go.PointerType EliminationStack, [("Pop"%go, EliminationStack__Popⁱᵐᵖˡ); ("Push"%go, EliminationStack__Pushⁱᵐᵖˡ)]); (request, []); (go.PointerType request, []); (stream, []); (go.PointerType stream, []); (streamold, []); (go.PointerType streamold, [])].

#[global] Instance info' : PkgInfo channel.chan_spec_raw_examples :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [code.sync.sync; code.time.time; code.strings.strings];
  |}.

Definition initialize' : val :=
  λ: <>,
    package.init #channel.chan_spec_raw_examples (λ: <>,
      exception_do (do:  (strings.initialize' #());;;
      do:  (time.initialize' #());;;
      do:  (sync.initialize' #());;;
      do:  (package.alloc channel.chan_spec_raw_examples #()))
      ).

End code.
End chan_spec_raw_examples.
