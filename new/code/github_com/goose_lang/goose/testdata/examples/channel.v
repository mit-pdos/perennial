(* autogenerated from github.com/goose-lang/goose/testdata/examples/channel *)
Require Export New.code.strings.
Require Export New.code.sync.
Require Export New.code.time.

From New.golang Require Import defn.
Definition chan_spec_raw_examples : go_string := "github.com/goose-lang/goose/testdata/examples/channel".

Module chan_spec_raw_examples.

Module LockedStack. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/channel.LockedStack"%go. End LockedStack.
Module EliminationStack. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/channel.EliminationStack"%go. End EliminationStack.
Module request. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/channel.request"%go. End request.
Module stream. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/channel.stream"%go. End stream.

Section code.
Context `{ffi_syntax}.


Definition LockedStack : go_type := structT [
  "mu" :: sync.Mutex;
  "stack" :: sliceT
].
#[global] Typeclasses Opaque LockedStack.
#[global] Opaque LockedStack.

Definition NewLockedStack : go_string := "github.com/goose-lang/goose/testdata/examples/channel.NewLockedStack"%go.

(* go: elimination_stack.go:14:6 *)
Definition NewLockedStackⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (mem.alloc (let: "$stack" := (slice.make2 #stringT #(W64 0)) in
     struct.make #LockedStack [{
       "mu" ::= type.zero_val #sync.Mutex;
       "stack" ::= "$stack"
     }]))).

(* go: elimination_stack.go:18:23 *)
Definition LockedStack__Pushⁱᵐᵖˡ : val :=
  λ: "s" "value",
    exception_do (let: "s" := (mem.alloc "s") in
    let: "value" := (mem.alloc "value") in
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (struct.field_ref #LockedStack #"mu"%go (![#ptrT] "s"))) #());;;
    let: "$r0" := (let: "$a0" := (![#sliceT] (struct.field_ref #LockedStack #"stack"%go (![#ptrT] "s"))) in
    let: "$a1" := ((let: "$sl0" := (![#stringT] "value") in
    slice.literal #stringT ["$sl0"])) in
    (slice.append #stringT) "$a0" "$a1") in
    do:  ((struct.field_ref #LockedStack #"stack"%go (![#ptrT] "s")) <-[#sliceT] "$r0");;;
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (struct.field_ref #LockedStack #"mu"%go (![#ptrT] "s"))) #());;;
    return: #()).

(* go: elimination_stack.go:24:23 *)
Definition LockedStack__Popⁱᵐᵖˡ : val :=
  λ: "s" <>,
    exception_do (let: "s" := (mem.alloc "s") in
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (struct.field_ref #LockedStack #"mu"%go (![#ptrT] "s"))) #());;;
    (if: (let: "$a0" := (![#sliceT] (struct.field_ref #LockedStack #"stack"%go (![#ptrT] "s"))) in
    slice.len "$a0") = #(W64 0)
    then
      do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (struct.field_ref #LockedStack #"mu"%go (![#ptrT] "s"))) #());;;
      return: (#""%go, #false)
    else do:  #());;;
    let: "last" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := ((let: "$a0" := (![#sliceT] (struct.field_ref #LockedStack #"stack"%go (![#ptrT] "s"))) in
    slice.len "$a0") - #(W64 1)) in
    do:  ("last" <-[#intT] "$r0");;;
    let: "v" := (mem.alloc (type.zero_val #stringT)) in
    let: "$r0" := (![#stringT] (slice.elem_ref #stringT (![#sliceT] (struct.field_ref #LockedStack #"stack"%go (![#ptrT] "s"))) (![#intT] "last"))) in
    do:  ("v" <-[#stringT] "$r0");;;
    let: "$r0" := (let: "$s" := (![#sliceT] (struct.field_ref #LockedStack #"stack"%go (![#ptrT] "s"))) in
    slice.slice #stringT "$s" #(W64 0) (![#intT] "last")) in
    do:  ((struct.field_ref #LockedStack #"stack"%go (![#ptrT] "s")) <-[#sliceT] "$r0");;;
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (struct.field_ref #LockedStack #"mu"%go (![#ptrT] "s"))) #());;;
    return: (![#stringT] "v", #true)).

Definition after : go_string := "github.com/goose-lang/goose/testdata/examples/channel.after"%go.

(* after returns a channel that closes after d (emulates time.After).

   go: elimination_stack.go:38:6 *)
Definition afterⁱᵐᵖˡ : val :=
  λ: "d",
    exception_do (let: "d" := (mem.alloc "d") in
    let: "ch" := (mem.alloc (type.zero_val (type.chanT (type.structT [
    ])))) in
    let: "$r0" := (chan.make (type.structT [
    ]) #(W64 0)) in
    do:  ("ch" <-[type.chanT (type.structT [
    ])] "$r0");;;
    let: "$go" := (λ: <>,
      exception_do (do:  (let: "$a0" := (![#time.Duration] "d") in
      (func_call #time.Sleep) "$a0");;;
      do:  (let: "$a0" := (![type.chanT (type.structT [
      ])] "ch") in
      (chan.close (type.structT [
      ])) "$a0");;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    return: (![type.chanT (type.structT [
     ])] "ch")).

Definition EliminationStack : go_type := structT [
  "base" :: ptrT;
  "exchanger" :: chanT stringT;
  "timeout" :: time.Duration
].
#[global] Typeclasses Opaque EliminationStack.
#[global] Opaque EliminationStack.

Definition NewEliminationStack : go_string := "github.com/goose-lang/goose/testdata/examples/channel.NewEliminationStack"%go.

(* NewEliminationStack constructs a new elimination stack
   using a fresh LockedStack and a small default timeout.

   go: elimination_stack.go:56:6 *)
Definition NewEliminationStackⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (mem.alloc (let: "$base" := ((func_call #NewLockedStack) #()) in
     let: "$exchanger" := (chan.make #stringT #(W64 0)) in
     let: "$timeout" := (#(W64 10) * time.Microsecond) in
     struct.make #EliminationStack [{
       "base" ::= "$base";
       "exchanger" ::= "$exchanger";
       "timeout" ::= "$timeout"
     }]))).

(* Push first tries one-shot elimination; on timeout, falls back to the locked stack.

   go: elimination_stack.go:65:28 *)
Definition EliminationStack__Pushⁱᵐᵖˡ : val :=
  λ: "s" "value",
    exception_do (let: "s" := (mem.alloc "s") in
    let: "value" := (mem.alloc "value") in
    let: "t" := (mem.alloc (type.zero_val (type.chanT (type.structT [
    ])))) in
    let: "$r0" := (let: "$a0" := (![#time.Duration] (struct.field_ref #EliminationStack #"timeout"%go (![#ptrT] "s"))) in
    (func_call #after) "$a0") in
    do:  ("t" <-[type.chanT (type.structT [
    ])] "$r0");;;
    chan.select_blocking [chan.select_send #stringT (![type.chanT #stringT] (struct.field_ref #EliminationStack #"exchanger"%go (![#ptrT] "s"))) (![#stringT] "value") (λ: <>,
       return: (#())
       ); chan.select_receive (type.structT [
     ]) (![type.chanT (type.structT [
     ])] "t") (λ: "$recvVal",
       do:  #()
       )];;;
    do:  (let: "$a0" := (![#stringT] "value") in
    (method_call #(ptrT.id LockedStack.id) #"Push"%go (![#ptrT] (struct.field_ref #EliminationStack #"base"%go (![#ptrT] "s")))) "$a0");;;
    return: #()).

(* Pop first tries one-shot elimination; on timeout, falls back to the locked stack.

   go: elimination_stack.go:78:28 *)
Definition EliminationStack__Popⁱᵐᵖˡ : val :=
  λ: "s" <>,
    exception_do (let: "s" := (mem.alloc "s") in
    let: "t" := (mem.alloc (type.zero_val (type.chanT (type.structT [
    ])))) in
    let: "$r0" := (let: "$a0" := (![#time.Duration] (struct.field_ref #EliminationStack #"timeout"%go (![#ptrT] "s"))) in
    (func_call #after) "$a0") in
    do:  ("t" <-[type.chanT (type.structT [
    ])] "$r0");;;
    chan.select_blocking [chan.select_receive #stringT (![type.chanT #stringT] (struct.field_ref #EliminationStack #"exchanger"%go (![#ptrT] "s"))) (λ: "$recvVal",
       let: "v" := (mem.alloc (type.zero_val #stringT)) in
       let: "$r0" := (Fst "$recvVal") in
       do:  ("v" <-[#stringT] "$r0");;;
       return: (![#stringT] "v", #true)
       ); chan.select_receive (type.structT [
     ]) (![type.chanT (type.structT [
     ])] "t") (λ: "$recvVal",
       do:  #()
       )];;;
    let: ("$ret0", "$ret1") := (((method_call #(ptrT.id LockedStack.id) #"Pop"%go (![#ptrT] (struct.field_ref #EliminationStack #"base"%go (![#ptrT] "s")))) #())) in
    return: ("$ret0", "$ret1")).

Definition sys_hello_world : go_string := "github.com/goose-lang/goose/testdata/examples/channel.sys_hello_world"%go.

(* Fake syscall for demonstration.

   go: examples.go:9:6 *)
Definition sys_hello_worldⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (#"Hello, World!"%go)).

Definition HelloWorldAsync : go_string := "github.com/goose-lang/goose/testdata/examples/channel.HelloWorldAsync"%go.

(* go: examples.go:13:6 *)
Definition HelloWorldAsyncⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ch" := (mem.alloc (type.zero_val (type.chanT #stringT))) in
    let: "$r0" := (chan.make #stringT #(W64 1)) in
    do:  ("ch" <-[type.chanT #stringT] "$r0");;;
    let: "$go" := (λ: <>,
      exception_do (do:  (let: "$chan" := (![type.chanT #stringT] "ch") in
      let: "$v" := ((func_call #sys_hello_world) #()) in
      chan.send #stringT "$chan" "$v");;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    return: (![type.chanT #stringT] "ch")).

Definition HelloWorldSync : go_string := "github.com/goose-lang/goose/testdata/examples/channel.HelloWorldSync"%go.

(* go: examples.go:21:6 *)
Definition HelloWorldSyncⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (Fst (chan.receive #stringT ((func_call #HelloWorldAsync) #())))).

Definition HelloWorldCancellable : go_string := "github.com/goose-lang/goose/testdata/examples/channel.HelloWorldCancellable"%go.

(* Simulates the error/done channel components of Context

   go: examples.go:26:6 *)
Definition HelloWorldCancellableⁱᵐᵖˡ : val :=
  λ: "done" "err",
    exception_do (let: "err" := (mem.alloc "err") in
    let: "done" := (mem.alloc "done") in
    let: "future" := (mem.alloc (type.zero_val (type.chanT #stringT))) in
    let: "$r0" := ((func_call #HelloWorldAsync) #()) in
    do:  ("future" <-[type.chanT #stringT] "$r0");;;
    chan.select_blocking [chan.select_receive #stringT (![type.chanT #stringT] "future") (λ: "$recvVal",
       let: "resolved" := (mem.alloc (type.zero_val #stringT)) in
       let: "$r0" := (Fst "$recvVal") in
       do:  ("resolved" <-[#stringT] "$r0");;;
       return: (![#stringT] "resolved")
       ); chan.select_receive (type.structT [
     ]) (![type.chanT (type.structT [
     ])] "done") (λ: "$recvVal",
       return: (![#stringT] (![#ptrT] "err"))
       )]).

Definition HelloWorldWithTimeout : go_string := "github.com/goose-lang/goose/testdata/examples/channel.HelloWorldWithTimeout"%go.

(* Uses cancellation as a timeout mechanism.

   go: examples.go:37:6 *)
Definition HelloWorldWithTimeoutⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "done" := (mem.alloc (type.zero_val (type.chanT (type.structT [
    ])))) in
    let: "$r0" := (chan.make (type.structT [
    ]) #(W64 0)) in
    do:  ("done" <-[type.chanT (type.structT [
    ])] "$r0");;;
    let: "errMsg" := (mem.alloc (type.zero_val #stringT)) in
    let: "$r0" := #""%go in
    do:  ("errMsg" <-[#stringT] "$r0");;;
    let: "$go" := (λ: <>,
      exception_do (do:  (let: "$a0" := (#(W64 10) * time.Millisecond) in
      (func_call #time.Sleep) "$a0");;;
      let: "$r0" := #"operation timed out"%go in
      do:  ("errMsg" <-[#stringT] "$r0");;;
      do:  (let: "$a0" := (![type.chanT (type.structT [
      ])] "done") in
      (chan.close (type.structT [
      ])) "$a0");;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    return: (let: "$a0" := (![type.chanT (type.structT [
     ])] "done") in
     let: "$a1" := "errMsg" in
     (func_call #HelloWorldCancellable) "$a0" "$a1")).

Definition DSPExample : go_string := "github.com/goose-lang/goose/testdata/examples/channel.DSPExample"%go.

(* prog3 from Actris 2.0 intro: https://arxiv.org/pdf/2010.15030

   go: examples.go:52:6 *)
Definition DSPExampleⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "c" := (mem.alloc (type.zero_val (type.chanT #interfaceT))) in
    let: "$r0" := (chan.make #interfaceT #(W64 0)) in
    do:  ("c" <-[type.chanT #interfaceT] "$r0");;;
    let: "signal" := (mem.alloc (type.zero_val (type.chanT #interfaceT))) in
    let: "$r0" := (chan.make #interfaceT #(W64 0)) in
    do:  ("signal" <-[type.chanT #interfaceT] "$r0");;;
    let: "$go" := (λ: <>,
      exception_do (let: "ptr" := (mem.alloc (type.zero_val #ptrT)) in
      let: "$r0" := (interface.type_assert (Fst (chan.receive #interfaceT (![type.chanT #interfaceT] "c"))) #(ptrT.id intT.id)) in
      do:  ("ptr" <-[#ptrT] "$r0");;;
      let: "$r0" := ((![#intT] (![#ptrT] "ptr")) + #(W64 2)) in
      do:  ((![#ptrT] "ptr") <-[#intT] "$r0");;;
      do:  (let: "$chan" := (![type.chanT #interfaceT] "signal") in
      let: "$v" := (interface.make #(structT.id []) (struct.make (type.structT [
      ]) [{
      }])) in
      chan.send #interfaceT "$chan" "$v");;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    let: "val" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := #(W64 40) in
    do:  ("val" <-[#intT] "$r0");;;
    let: "ptr" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := "val" in
    do:  ("ptr" <-[#ptrT] "$r0");;;
    do:  (let: "$chan" := (![type.chanT #interfaceT] "c") in
    let: "$v" := (interface.make #(ptrT.id intT.id) (![#ptrT] "ptr")) in
    chan.send #interfaceT "$chan" "$v");;;
    do:  (Fst (chan.receive #interfaceT (![type.chanT #interfaceT] "signal")));;;
    return: (![#intT] (![#ptrT] "ptr"))).

Definition fibonacci : go_string := "github.com/goose-lang/goose/testdata/examples/channel.fibonacci"%go.

(* https://go.dev/tour/concurrency/4

   go: examples.go:70:6 *)
Definition fibonacciⁱᵐᵖˡ : val :=
  λ: "n" "c",
    exception_do (let: "c" := (mem.alloc "c") in
    let: "n" := (mem.alloc "n") in
    let: "y" := (mem.alloc (type.zero_val #intT)) in
    let: "x" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := #(W64 0) in
    let: "$r1" := #(W64 1) in
    do:  ("x" <-[#intT] "$r0");;;
    do:  ("y" <-[#intT] "$r1");;;
    (let: "i" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[#intT] "$r0");;;
    (for: (λ: <>, int_lt (![#intT] "i") (![#intT] "n")); (λ: <>, do:  ("i" <-[#intT] ((![#intT] "i") + #(W64 1)))) := λ: <>,
      do:  (let: "$chan" := (![type.chanT #intT] "c") in
      let: "$v" := (![#intT] "x") in
      chan.send #intT "$chan" "$v");;;
      let: "$r0" := (![#intT] "y") in
      let: "$r1" := ((![#intT] "x") + (![#intT] "y")) in
      do:  ("x" <-[#intT] "$r0");;;
      do:  ("y" <-[#intT] "$r1")));;;
    do:  (let: "$a0" := (![type.chanT #intT] "c") in
    (chan.close #intT) "$a0");;;
    return: #()).

Definition fib_consumer : go_string := "github.com/goose-lang/goose/testdata/examples/channel.fib_consumer"%go.

(* go: examples.go:79:6 *)
Definition fib_consumerⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "c" := (mem.alloc (type.zero_val (type.chanT #intT))) in
    let: "$r0" := (chan.make #intT #(W64 10)) in
    do:  ("c" <-[type.chanT #intT] "$r0");;;
    let: "$a0" := (let: "$a0" := (![type.chanT #intT] "c") in
    (chan.cap #intT) "$a0") in
    let: "$a1" := (![type.chanT #intT] "c") in
    let: "$go" := (func_call #fibonacci) in
    do:  (Fork ("$go" "$a0" "$a1"));;;
    let: "results" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := #slice.nil in
    do:  ("results" <-[#sliceT] "$r0");;;
    let: "$range" := (![type.chanT #intT] "c") in
    (let: "i" := (mem.alloc (type.zero_val #intT)) in
    chan.for_range #intT "$range" (λ: "$key",
      do:  ("i" <-[#intT] "$key");;;
      let: "$r0" := (let: "$a0" := (![#sliceT] "results") in
      let: "$a1" := ((let: "$sl0" := (![#intT] "i") in
      slice.literal #intT ["$sl0"])) in
      (slice.append #intT) "$a0" "$a1") in
      do:  ("results" <-[#sliceT] "$r0")));;;
    return: (![#sliceT] "results")).

Definition simple_join : go_string := "github.com/goose-lang/goose/testdata/examples/channel.simple_join"%go.

(* go: examples.go:90:6 *)
Definition simple_joinⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ch" := (mem.alloc (type.zero_val (type.chanT (type.structT [
    ])))) in
    let: "$r0" := (chan.make (type.structT [
    ]) #(W64 1)) in
    do:  ("ch" <-[type.chanT (type.structT [
    ])] "$r0");;;
    let: "message" := (mem.alloc (type.zero_val #stringT)) in
    let: "$go" := (λ: <>,
      exception_do (let: "$r0" := #"Hello, World!"%go in
      do:  ("message" <-[#stringT] "$r0");;;
      do:  (let: "$chan" := (![type.chanT (type.structT [
      ])] "ch") in
      let: "$v" := (struct.make (type.structT [
      ]) [{
      }]) in
      chan.send (type.structT [
      ]) "$chan" "$v");;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    do:  (Fst (chan.receive (type.structT [
    ]) (![type.chanT (type.structT [
    ])] "ch")));;;
    return: (![#stringT] "message")).

Definition simple_multi_join : go_string := "github.com/goose-lang/goose/testdata/examples/channel.simple_multi_join"%go.

(* go: examples.go:103:6 *)
Definition simple_multi_joinⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ch" := (mem.alloc (type.zero_val (type.chanT (type.structT [
    ])))) in
    let: "$r0" := (chan.make (type.structT [
    ]) #(W64 2)) in
    do:  ("ch" <-[type.chanT (type.structT [
    ])] "$r0");;;
    let: "world" := (mem.alloc (type.zero_val #stringT)) in
    let: "hello" := (mem.alloc (type.zero_val #stringT)) in
    let: "$go" := (λ: <>,
      exception_do (let: "$r0" := #"Hello"%go in
      do:  ("hello" <-[#stringT] "$r0");;;
      do:  (let: "$chan" := (![type.chanT (type.structT [
      ])] "ch") in
      let: "$v" := (struct.make (type.structT [
      ]) [{
      }]) in
      chan.send (type.structT [
      ]) "$chan" "$v");;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    let: "$go" := (λ: <>,
      exception_do (let: "$r0" := #"World"%go in
      do:  ("world" <-[#stringT] "$r0");;;
      do:  (let: "$chan" := (![type.chanT (type.structT [
      ])] "ch") in
      let: "$v" := (struct.make (type.structT [
      ]) [{
      }]) in
      chan.send (type.structT [
      ]) "$chan" "$v");;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    do:  (Fst (chan.receive (type.structT [
    ]) (![type.chanT (type.structT [
    ])] "ch")));;;
    do:  (Fst (chan.receive (type.structT [
    ]) (![type.chanT (type.structT [
    ])] "ch")));;;
    return: (((![#stringT] "hello") + #" "%go) + (![#stringT] "world"))).

Definition select_nb_no_panic : go_string := "github.com/goose-lang/goose/testdata/examples/channel.select_nb_no_panic"%go.

(* Show that it isn't possible to have 2 nonblocking ops that match.

   go: examples.go:122:6 *)
Definition select_nb_no_panicⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ch" := (mem.alloc (type.zero_val (type.chanT (type.structT [
    ])))) in
    let: "$r0" := (chan.make (type.structT [
    ]) #(W64 0)) in
    do:  ("ch" <-[type.chanT (type.structT [
    ])] "$r0");;;
    let: "$go" := (λ: <>,
      exception_do (chan.select_nonblocking [chan.select_receive (type.structT [
       ]) (![type.chanT (type.structT [
       ])] "ch") (λ: "$recvVal",
         do:  (let: "$a0" := (interface.make #stringT.id #"bad"%go) in
         Panic "$a0")
         )] (λ: <>,
        do:  #()
        );;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    chan.select_nonblocking [chan.select_send (type.structT [
     ]) (![type.chanT (type.structT [
     ])] "ch") (struct.make (type.structT [
     ]) [{
     }]) (λ: <>,
       do:  (let: "$a0" := (interface.make #stringT.id #"bad"%go) in
       Panic "$a0")
       )] (λ: <>,
      do:  #()
      );;;
    return: #()).

Definition select_no_double_close : go_string := "github.com/goose-lang/goose/testdata/examples/channel.select_no_double_close"%go.

(* go: examples.go:139:6 *)
Definition select_no_double_closeⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (mem.alloc (type.zero_val (type.chanT #intT))) in
    let: "$r0" := (chan.make #intT #(W64 0)) in
    do:  ("x" <-[type.chanT #intT] "$r0");;;
    do:  (let: "$a0" := (![type.chanT #intT] "x") in
    (chan.close #intT) "$a0");;;
    chan.select_nonblocking [chan.select_receive #intT (![type.chanT #intT] "x") (λ: "$recvVal",
       do:  #()
       )] (λ: <>,
      do:  (let: "$a0" := (![type.chanT #intT] "x") in
      (chan.close #intT) "$a0")
      );;;
    return: #()).

Definition select_ready_case_no_panic : go_string := "github.com/goose-lang/goose/testdata/examples/channel.select_ready_case_no_panic"%go.

(* Show that a guaranteed to be ready case makes default impossible

   go: examples.go:150:6 *)
Definition select_ready_case_no_panicⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ch" := (mem.alloc (type.zero_val (type.chanT (type.structT [
    ])))) in
    let: "$r0" := (chan.make (type.structT [
    ]) #(W64 0)) in
    do:  ("ch" <-[type.chanT (type.structT [
    ])] "$r0");;;
    do:  (let: "$a0" := (![type.chanT (type.structT [
    ])] "ch") in
    (chan.close (type.structT [
    ])) "$a0");;;
    chan.select_nonblocking [chan.select_receive (type.structT [
     ]) (![type.chanT (type.structT [
     ])] "ch") (λ: "$recvVal",
       do:  #()
       )] (λ: <>,
      do:  (let: "$a0" := (interface.make #stringT.id #"Shouldn't be possible!"%go) in
      Panic "$a0")
      );;;
    return: #()).

Definition TestHelloWorldSync : go_string := "github.com/goose-lang/goose/testdata/examples/channel.TestHelloWorldSync"%go.

(* Various tests that should panic when failing, which also means verifying { True } e { True } is
   sufficient since panic can't be verified.

   go: examples.go:164:6 *)
Definition TestHelloWorldSyncⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "result" := (mem.alloc (type.zero_val #stringT)) in
    let: "$r0" := ((func_call #HelloWorldSync) #()) in
    do:  ("result" <-[#stringT] "$r0");;;
    (if: (![#stringT] "result") ≠ #"Hello, World!"%go
    then
      do:  (let: "$a0" := (interface.make #stringT.id #"incorrect output"%go) in
      Panic "$a0")
    else do:  #());;;
    return: #()).

Definition TestHelloWorldWithTimeout : go_string := "github.com/goose-lang/goose/testdata/examples/channel.TestHelloWorldWithTimeout"%go.

(* go: examples.go:171:6 *)
Definition TestHelloWorldWithTimeoutⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "result" := (mem.alloc (type.zero_val #stringT)) in
    let: "$r0" := ((func_call #HelloWorldWithTimeout) #()) in
    do:  ("result" <-[#stringT] "$r0");;;
    (if: ((![#stringT] "result") ≠ #"operation timed out"%go) && ((![#stringT] "result") ≠ #"Hello, World!"%go)
    then
      do:  (let: "$a0" := (interface.make #stringT.id #"incorrect output"%go) in
      Panic "$a0")
    else do:  #());;;
    return: #()).

Definition TestDSPExample : go_string := "github.com/goose-lang/goose/testdata/examples/channel.TestDSPExample"%go.

(* go: examples.go:178:6 *)
Definition TestDSPExampleⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "result" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := ((func_call #DSPExample) #()) in
    do:  ("result" <-[#intT] "$r0");;;
    (if: (![#intT] "result") ≠ #(W64 42)
    then
      do:  (let: "$a0" := (interface.make #stringT.id #"incorrect output"%go) in
      Panic "$a0")
    else do:  #());;;
    return: #()).

Definition TestFibConsumer : go_string := "github.com/goose-lang/goose/testdata/examples/channel.TestFibConsumer"%go.

(* go: examples.go:185:6 *)
Definition TestFibConsumerⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "result" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := ((func_call #fib_consumer) #()) in
    do:  ("result" <-[#sliceT] "$r0");;;
    let: "expected" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := ((let: "$sl0" := #(W64 0) in
    let: "$sl1" := #(W64 1) in
    let: "$sl2" := #(W64 1) in
    let: "$sl3" := #(W64 2) in
    let: "$sl4" := #(W64 3) in
    let: "$sl5" := #(W64 5) in
    let: "$sl6" := #(W64 8) in
    let: "$sl7" := #(W64 13) in
    let: "$sl8" := #(W64 21) in
    let: "$sl9" := #(W64 34) in
    slice.literal #intT ["$sl0"; "$sl1"; "$sl2"; "$sl3"; "$sl4"; "$sl5"; "$sl6"; "$sl7"; "$sl8"; "$sl9"])) in
    do:  ("expected" <-[#sliceT] "$r0");;;
    (if: (let: "$a0" := (![#sliceT] "result") in
    slice.len "$a0") ≠ (let: "$a0" := (![#sliceT] "expected") in
    slice.len "$a0")
    then
      do:  (let: "$a0" := (interface.make #stringT.id #"incorrect output"%go) in
      Panic "$a0")
    else do:  #());;;
    let: "$range" := (![#sliceT] "expected") in
    (let: "i" := (mem.alloc (type.zero_val #intT)) in
    slice.for_range #intT "$range" (λ: "$key" "$value",
      do:  ("i" <-[#intT] "$key");;;
      (if: (![#intT] (slice.elem_ref #intT (![#sliceT] "result") (![#intT] "i"))) ≠ (![#intT] (slice.elem_ref #intT (![#sliceT] "expected") (![#intT] "i")))
      then
        do:  (let: "$a0" := (interface.make #stringT.id #"incorrect output"%go) in
        Panic "$a0")
      else do:  #())));;;
    return: #()).

Definition TestSelectNbNoPanic : go_string := "github.com/goose-lang/goose/testdata/examples/channel.TestSelectNbNoPanic"%go.

(* go: examples.go:200:6 *)
Definition TestSelectNbNoPanicⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "iterations" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := #(W64 10000) in
    do:  ("iterations" <-[#intT] "$r0");;;
    (let: "i" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[#intT] "$r0");;;
    (for: (λ: <>, int_lt (![#intT] "i") (![#intT] "iterations")); (λ: <>, do:  ("i" <-[#intT] ((![#intT] "i") + #(W64 1)))) := λ: <>,
      do:  ((func_call #select_nb_no_panic) #());;;
      do:  (let: "$a0" := (#(W64 1) * time.Microsecond) in
      (func_call #time.Sleep) "$a0")));;;
    return: #()).

Definition TestSelectReadyCaseNoPanic : go_string := "github.com/goose-lang/goose/testdata/examples/channel.TestSelectReadyCaseNoPanic"%go.

(* go: examples.go:209:6 *)
Definition TestSelectReadyCaseNoPanicⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "iterations" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := #(W64 10000) in
    do:  ("iterations" <-[#intT] "$r0");;;
    (let: "i" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[#intT] "$r0");;;
    (for: (λ: <>, int_lt (![#intT] "i") (![#intT] "iterations")); (λ: <>, do:  ("i" <-[#intT] ((![#intT] "i") + #(W64 1)))) := λ: <>,
      do:  ((func_call #select_ready_case_no_panic) #())));;;
    return: #()).

Definition load : go_string := "github.com/goose-lang/goose/testdata/examples/channel.load"%go.

(* load writes the next letter into the buffer.

   go: examples.go:220:6 *)
Definition loadⁱᵐᵖˡ : val :=
  λ: "b" "letter",
    exception_do (let: "letter" := (mem.alloc "letter") in
    let: "b" := (mem.alloc "b") in
    let: "$r0" := (string.to_bytes (![#stringT] "letter")) in
    do:  ((![#ptrT] "b") <-[#sliceT] "$r0");;;
    return: #()).

Definition process : go_string := "github.com/goose-lang/goose/testdata/examples/channel.process"%go.

(* process consumes the buffer and appends it to the output.

   go: examples.go:225:6 *)
Definition processⁱᵐᵖˡ : val :=
  λ: "b" "output",
    exception_do (let: "output" := (mem.alloc "output") in
    let: "b" := (mem.alloc "b") in
    do:  ((![#ptrT] "output") <-[#stringT] ((![#stringT] (![#ptrT] "output")) + (let: "$a0" := (string.from_bytes (![#sliceT] (![#ptrT] "b"))) in
    (func_call #strings.ToUpper) "$a0")));;;
    return: #()).

Definition client : go_string := "github.com/goose-lang/goose/testdata/examples/channel.client"%go.

(* go: examples.go:229:6 *)
Definition clientⁱᵐᵖˡ : val :=
  λ: "input" "freeList" "serverChan",
    exception_do (let: "serverChan" := (mem.alloc "serverChan") in
    let: "freeList" := (mem.alloc "freeList") in
    let: "input" := (mem.alloc "input") in
    let: "$range" := (![#sliceT] "input") in
    (let: "letter" := (mem.alloc (type.zero_val #stringT)) in
    slice.for_range #stringT "$range" (λ: "$key" "$value",
      do:  ("letter" <-[#stringT] "$value");;;
      do:  "$key";;;
      let: "b" := (mem.alloc (type.zero_val #sliceT)) in
      chan.select_nonblocking [chan.select_receive #sliceT (![type.chanT #sliceT] "freeList") (λ: "$recvVal",
         let: "$r0" := (Fst "$recvVal") in
         do:  ("b" <-[#sliceT] "$r0");;;
         do:  #()
         )] (λ: <>,
        let: "$r0" := ((let: "$sl0" := #(W8 0) in
        slice.literal #byteT ["$sl0"])) in
        do:  ("b" <-[#sliceT] "$r0")
        );;;
      do:  (let: "$a0" := "b" in
      let: "$a1" := (![#stringT] "letter") in
      (func_call #load) "$a0" "$a1");;;
      do:  (let: "$chan" := (![type.chanT #sliceT] "serverChan") in
      let: "$v" := (![#sliceT] "b") in
      chan.send #sliceT "$chan" "$v")));;;
    do:  (let: "$a0" := (![type.chanT #sliceT] "serverChan") in
    (chan.close #sliceT) "$a0");;;
    return: #()).

Definition server : go_string := "github.com/goose-lang/goose/testdata/examples/channel.server"%go.

(* go: examples.go:250:6 *)
Definition serverⁱᵐᵖˡ : val :=
  λ: "output" "freeList" "serverChan" "done",
    exception_do (let: "done" := (mem.alloc "done") in
    let: "serverChan" := (mem.alloc "serverChan") in
    let: "freeList" := (mem.alloc "freeList") in
    let: "output" := (mem.alloc "output") in
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "ok" := (mem.alloc (type.zero_val #boolT)) in
      let: "b" := (mem.alloc (type.zero_val #sliceT)) in
      let: ("$ret0", "$ret1") := (chan.receive #sliceT (![type.chanT #sliceT] "serverChan")) in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("b" <-[#sliceT] "$r0");;;
      do:  ("ok" <-[#boolT] "$r1");;;
      (if: (~ (![#boolT] "ok"))
      then
        do:  (let: "$chan" := (![type.chanT (type.structT [
        ])] "done") in
        let: "$v" := (struct.make (type.structT [
        ]) [{
        }]) in
        chan.send (type.structT [
        ]) "$chan" "$v");;;
        return: (#())
      else do:  #());;;
      do:  (let: "$a0" := "b" in
      let: "$a1" := (![#ptrT] "output") in
      (func_call #process) "$a0" "$a1");;;
      chan.select_nonblocking [chan.select_send #sliceT (![type.chanT #sliceT] "freeList") (![#sliceT] "b") (λ: <>,
         do:  #()
         )] (λ: <>,
        do:  #()
        ));;;
    return: #()).

Definition LeakyBufferPipeline : go_string := "github.com/goose-lang/goose/testdata/examples/channel.LeakyBufferPipeline"%go.

(* go: examples.go:272:6 *)
Definition LeakyBufferPipelineⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "freeList" := (mem.alloc (type.zero_val (type.chanT #sliceT))) in
    let: "$r0" := (chan.make #sliceT #(W64 5)) in
    do:  ("freeList" <-[type.chanT #sliceT] "$r0");;;
    let: "serverChan" := (mem.alloc (type.zero_val (type.chanT #sliceT))) in
    let: "$r0" := (chan.make #sliceT #(W64 0)) in
    do:  ("serverChan" <-[type.chanT #sliceT] "$r0");;;
    let: "done" := (mem.alloc (type.zero_val (type.chanT (type.structT [
    ])))) in
    let: "$r0" := (chan.make (type.structT [
    ]) #(W64 0)) in
    do:  ("done" <-[type.chanT (type.structT [
    ])] "$r0");;;
    let: "output" := (mem.alloc (type.zero_val #stringT)) in
    let: "$r0" := #""%go in
    do:  ("output" <-[#stringT] "$r0");;;
    let: "$a0" := "output" in
    let: "$a1" := (![type.chanT #sliceT] "freeList") in
    let: "$a2" := (![type.chanT #sliceT] "serverChan") in
    let: "$a3" := (![type.chanT (type.structT [
    ])] "done") in
    let: "$go" := (func_call #server) in
    do:  (Fork ("$go" "$a0" "$a1" "$a2" "$a3"));;;
    do:  (let: "$a0" := ((let: "$sl0" := #"h"%go in
    let: "$sl1" := #"e"%go in
    let: "$sl2" := #"l"%go in
    let: "$sl3" := #"l"%go in
    let: "$sl4" := #"o"%go in
    let: "$sl5" := #","%go in
    let: "$sl6" := #" "%go in
    let: "$sl7" := #"w"%go in
    let: "$sl8" := #"o"%go in
    let: "$sl9" := #"r"%go in
    let: "$sl10" := #"l"%go in
    let: "$sl11" := #"d"%go in
    slice.literal #stringT ["$sl0"; "$sl1"; "$sl2"; "$sl3"; "$sl4"; "$sl5"; "$sl6"; "$sl7"; "$sl8"; "$sl9"; "$sl10"; "$sl11"])) in
    let: "$a1" := (![type.chanT #sliceT] "freeList") in
    let: "$a2" := (![type.chanT #sliceT] "serverChan") in
    (func_call #client) "$a0" "$a1" "$a2");;;
    do:  (Fst (chan.receive (type.structT [
    ]) (![type.chanT (type.structT [
    ])] "done")));;;
    (if: (![#stringT] "output") ≠ #"HELLO, WORLD"%go
    then
      do:  (let: "$a0" := (interface.make #stringT.id #"incorrect output"%go) in
      Panic "$a0")
    else do:  #());;;
    return: #()).

Definition request : go_type := structT [
  "f" :: funcT;
  "result" :: chanT stringT
].
#[global] Typeclasses Opaque request.
#[global] Opaque request.

Definition mkRequest : go_string := "github.com/goose-lang/goose/testdata/examples/channel.mkRequest"%go.

(* go: higher_order.go:8:6 *)
Definition mkRequestⁱᵐᵖˡ : val :=
  λ: "f",
    exception_do (let: "f" := (mem.alloc "f") in
    return: (let: "$f" := (![#funcT] "f") in
     let: "$result" := (chan.make #stringT #(W64 1)) in
     struct.make #request [{
       "f" ::= "$f";
       "result" ::= "$result"
     }])).

Definition ho_worker : go_string := "github.com/goose-lang/goose/testdata/examples/channel.ho_worker"%go.

(* go: higher_order.go:12:6 *)
Definition ho_workerⁱᵐᵖˡ : val :=
  λ: "c",
    exception_do (let: "c" := (mem.alloc "c") in
    let: "$range" := (![type.chanT #request] "c") in
    (let: "r" := (mem.alloc (type.zero_val #request)) in
    chan.for_range #request "$range" (λ: "$key",
      do:  ("r" <-[#request] "$key");;;
      do:  (let: "$chan" := (![type.chanT #stringT] (struct.field_ref #request #"result"%go "r")) in
      let: "$v" := ((![#funcT] (struct.field_ref #request #"f"%go "r")) #()) in
      chan.send #stringT "$chan" "$v")));;;
    return: #()).

Definition HigherOrderExample : go_string := "github.com/goose-lang/goose/testdata/examples/channel.HigherOrderExample"%go.

(* go: higher_order.go:18:6 *)
Definition HigherOrderExampleⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "c" := (mem.alloc (type.zero_val (type.chanT #request))) in
    let: "$r0" := (chan.make #request #(W64 0)) in
    do:  ("c" <-[type.chanT #request] "$r0");;;
    let: "$a0" := (![type.chanT #request] "c") in
    let: "$go" := (func_call #ho_worker) in
    do:  (Fork ("$go" "$a0"));;;
    let: "$a0" := (![type.chanT #request] "c") in
    let: "$go" := (func_call #ho_worker) in
    do:  (Fork ("$go" "$a0"));;;
    let: "r1" := (mem.alloc (type.zero_val #request)) in
    let: "$r0" := (let: "$a0" := (λ: <>,
      exception_do (return: (#("hello"%go ++ " world"%go)))
      ) in
    (func_call #mkRequest) "$a0") in
    do:  ("r1" <-[#request] "$r0");;;
    let: "r2" := (mem.alloc (type.zero_val #request)) in
    let: "$r0" := (let: "$a0" := (λ: <>,
      exception_do (return: (#"HELLO"%go))
      ) in
    (func_call #mkRequest) "$a0") in
    do:  ("r2" <-[#request] "$r0");;;
    let: "r3" := (mem.alloc (type.zero_val #request)) in
    let: "$r0" := (let: "$a0" := (λ: <>,
      exception_do (return: (#(("w"%go ++ "o"%go) ++ "rld"%go)))
      ) in
    (func_call #mkRequest) "$a0") in
    do:  ("r3" <-[#request] "$r0");;;
    do:  (let: "$chan" := (![type.chanT #request] "c") in
    let: "$v" := (![#request] "r1") in
    chan.send #request "$chan" "$v");;;
    do:  (let: "$chan" := (![type.chanT #request] "c") in
    let: "$v" := (![#request] "r2") in
    chan.send #request "$chan" "$v");;;
    do:  (let: "$chan" := (![type.chanT #request] "c") in
    let: "$v" := (![#request] "r3") in
    chan.send #request "$chan" "$v");;;
    let: "responses" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := ((let: "$sl0" := (Fst (chan.receive #stringT (![type.chanT #stringT] (struct.field_ref #request #"result"%go "r1")))) in
    let: "$sl1" := (Fst (chan.receive #stringT (![type.chanT #stringT] (struct.field_ref #request #"result"%go "r2")))) in
    let: "$sl2" := (Fst (chan.receive #stringT (![type.chanT #stringT] (struct.field_ref #request #"result"%go "r3")))) in
    slice.literal #stringT ["$sl0"; "$sl1"; "$sl2"])) in
    do:  ("responses" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "responses")).

Definition stream : go_type := structT [
  "req" :: chanT stringT;
  "res" :: chanT stringT;
  "f" :: funcT
].
#[global] Typeclasses Opaque stream.
#[global] Opaque stream.

Definition mkStream : go_string := "github.com/goose-lang/goose/testdata/examples/channel.mkStream"%go.

(* go: muxer.go:9:6 *)
Definition mkStreamⁱᵐᵖˡ : val :=
  λ: "f",
    exception_do (let: "f" := (mem.alloc "f") in
    return: (struct.make #stream [{
       "req" ::= chan.make #stringT #(W64 0);
       "res" ::= chan.make #stringT #(W64 0);
       "f" ::= ![#funcT] "f"
     }])).

Definition Async : go_string := "github.com/goose-lang/goose/testdata/examples/channel.Async"%go.

(* go: muxer.go:13:6 *)
Definition Asyncⁱᵐᵖˡ : val :=
  λ: "f",
    exception_do (let: "f" := (mem.alloc "f") in
    let: "ch" := (mem.alloc (type.zero_val (type.chanT #stringT))) in
    let: "$r0" := (chan.make #stringT #(W64 1)) in
    do:  ("ch" <-[type.chanT #stringT] "$r0");;;
    let: "$go" := (λ: <>,
      exception_do (do:  (let: "$chan" := (![type.chanT #stringT] "ch") in
      let: "$v" := ((![#funcT] "f") #()) in
      chan.send #stringT "$chan" "$v");;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    return: (![type.chanT #stringT] "ch")).

Definition MapServer : go_string := "github.com/goose-lang/goose/testdata/examples/channel.MapServer"%go.

(* go: muxer.go:21:6 *)
Definition MapServerⁱᵐᵖˡ : val :=
  λ: "s",
    exception_do (let: "s" := (mem.alloc "s") in
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "in" := (mem.alloc (type.zero_val #stringT)) in
      let: "$r0" := (Fst (chan.receive #stringT (![type.chanT #stringT] (struct.field_ref #stream #"req"%go "s")))) in
      do:  ("in" <-[#stringT] "$r0");;;
      do:  (let: "$chan" := (![type.chanT #stringT] (struct.field_ref #stream #"res"%go "s")) in
      let: "$v" := (let: "$a0" := (![#stringT] "in") in
      (![#funcT] (struct.field_ref #stream #"f"%go "s")) "$a0") in
      chan.send #stringT "$chan" "$v"));;;
    return: #()).

Definition Client : go_string := "github.com/goose-lang/goose/testdata/examples/channel.Client"%go.

(* go: muxer.go:28:6 *)
Definition Clientⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "comma" := (mem.alloc (type.zero_val #stream)) in
    let: "$r0" := (let: "$a0" := (λ: "s",
      exception_do (let: "s" := (mem.alloc "s") in
      return: ((![#stringT] "s") + #","%go))
      ) in
    (func_call #mkStream) "$a0") in
    do:  ("comma" <-[#stream] "$r0");;;
    let: "exclaim" := (mem.alloc (type.zero_val #stream)) in
    let: "$r0" := (let: "$a0" := (λ: "s",
      exception_do (let: "s" := (mem.alloc "s") in
      return: ((![#stringT] "s") + #"!"%go))
      ) in
    (func_call #mkStream) "$a0") in
    do:  ("exclaim" <-[#stream] "$r0");;;
    let: "$a0" := (![#stream] "comma") in
    let: "$go" := (func_call #MapServer) in
    do:  (Fork ("$go" "$a0"));;;
    let: "$a0" := (![#stream] "exclaim") in
    let: "$go" := (func_call #MapServer) in
    do:  (Fork ("$go" "$a0"));;;
    do:  (let: "$chan" := (![type.chanT #stringT] (struct.field_ref #stream #"req"%go "comma")) in
    let: "$v" := #"Hello"%go in
    chan.send #stringT "$chan" "$v");;;
    do:  (let: "$chan" := (![type.chanT #stringT] (struct.field_ref #stream #"req"%go "exclaim")) in
    let: "$v" := #"World"%go in
    chan.send #stringT "$chan" "$v");;;
    return: (((Fst (chan.receive #stringT (![type.chanT #stringT] (struct.field_ref #stream #"res"%go "comma")))) + #" "%go) + (Fst (chan.receive #stringT (![type.chanT #stringT] (struct.field_ref #stream #"res"%go "exclaim")))))).

Definition Muxer : go_string := "github.com/goose-lang/goose/testdata/examples/channel.Muxer"%go.

(* go: muxer.go:43:6 *)
Definition Muxerⁱᵐᵖˡ : val :=
  λ: "c",
    exception_do (let: "c" := (mem.alloc "c") in
    let: "$range" := (![type.chanT #stream] "c") in
    (let: "s" := (mem.alloc (type.zero_val #stream)) in
    chan.for_range #stream "$range" (λ: "$key",
      do:  ("s" <-[#stream] "$key");;;
      let: "$a0" := (![#stream] "s") in
      let: "$go" := (func_call #MapServer) in
      do:  (Fork ("$go" "$a0"))));;;
    return: #()).

Definition CancellableMapServer : go_string := "github.com/goose-lang/goose/testdata/examples/channel.CancellableMapServer"%go.

(* go: muxer.go:49:6 *)
Definition CancellableMapServerⁱᵐᵖˡ : val :=
  λ: "s" "done",
    exception_do (let: "done" := (mem.alloc "done") in
    let: "s" := (mem.alloc "s") in
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      chan.select_blocking [chan.select_receive #stringT (![type.chanT #stringT] (struct.field_ref #stream #"req"%go "s")) (λ: "$recvVal",
         let: "ok" := (mem.alloc (type.zero_val #boolT)) in
         let: "in" := (mem.alloc (type.zero_val #stringT)) in
         let: ("$ret0", "$ret1") := "$recvVal" in
         let: "$r0" := "$ret0" in
         let: "$r1" := "$ret1" in
         do:  ("in" <-[#stringT] "$r0");;;
         do:  ("ok" <-[#boolT] "$r1");;;
         (if: (~ (![#boolT] "ok"))
         then return: (#())
         else do:  #());;;
         do:  (let: "$chan" := (![type.chanT #stringT] (struct.field_ref #stream #"res"%go "s")) in
         let: "$v" := (let: "$a0" := (![#stringT] "in") in
         (![#funcT] (struct.field_ref #stream #"f"%go "s")) "$a0") in
         chan.send #stringT "$chan" "$v")
         ); chan.select_receive (type.structT [
       ]) (![type.chanT (type.structT [
       ])] "done") (λ: "$recvVal",
         return: (#())
         )]);;;
    return: #()).

Definition CancellableMuxer : go_string := "github.com/goose-lang/goose/testdata/examples/channel.CancellableMuxer"%go.

(* 4. CancellableMuxer - muxer with cancellation

   go: muxer.go:64:6 *)
Definition CancellableMuxerⁱᵐᵖˡ : val :=
  λ: "c" "done" "errMsg",
    exception_do (let: "errMsg" := (mem.alloc "errMsg") in
    let: "done" := (mem.alloc "done") in
    let: "c" := (mem.alloc "c") in
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      chan.select_blocking [chan.select_receive #stream (![type.chanT #stream] "c") (λ: "$recvVal",
         let: "ok" := (mem.alloc (type.zero_val #boolT)) in
         let: "s" := (mem.alloc (type.zero_val #stream)) in
         let: ("$ret0", "$ret1") := "$recvVal" in
         let: "$r0" := "$ret0" in
         let: "$r1" := "$ret1" in
         do:  ("s" <-[#stream] "$r0");;;
         do:  ("ok" <-[#boolT] "$r1");;;
         (if: (~ (![#boolT] "ok"))
         then return: (#"serviced all requests"%go)
         else do:  #());;;
         let: "$a0" := (![#stream] "s") in
         let: "$a1" := (![type.chanT (type.structT [
         ])] "done") in
         let: "$go" := (func_call #CancellableMapServer) in
         do:  (Fork ("$go" "$a0" "$a1"))
         ); chan.select_receive (type.structT [
       ]) (![type.chanT (type.structT [
       ])] "done") (λ: "$recvVal",
         return: (![#stringT] (![#ptrT] "errMsg"))
         )])).

Definition makeGreeting : go_string := "github.com/goose-lang/goose/testdata/examples/channel.makeGreeting"%go.

(* go: muxer.go:78:6 *)
Definition makeGreetingⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "mux" := (mem.alloc (type.zero_val (type.chanT #stream))) in
    let: "$r0" := (chan.make #stream #(W64 2)) in
    do:  ("mux" <-[type.chanT #stream] "$r0");;;
    let: "$a0" := (![type.chanT #stream] "mux") in
    let: "$go" := (func_call #Muxer) in
    do:  (Fork ("$go" "$a0"));;;
    let: "comma" := (mem.alloc (type.zero_val #stream)) in
    let: "$r0" := (let: "$a0" := (λ: "s",
      exception_do (let: "s" := (mem.alloc "s") in
      return: ((![#stringT] "s") + #","%go))
      ) in
    (func_call #mkStream) "$a0") in
    do:  ("comma" <-[#stream] "$r0");;;
    let: "exclaim" := (mem.alloc (type.zero_val #stream)) in
    let: "$r0" := (let: "$a0" := (λ: "s",
      exception_do (let: "s" := (mem.alloc "s") in
      return: ((![#stringT] "s") + #"!"%go))
      ) in
    (func_call #mkStream) "$a0") in
    do:  ("exclaim" <-[#stream] "$r0");;;
    do:  (let: "$chan" := (![type.chanT #stream] "mux") in
    let: "$v" := (![#stream] "comma") in
    chan.send #stream "$chan" "$v");;;
    do:  (let: "$chan" := (![type.chanT #stream] "mux") in
    let: "$v" := (![#stream] "exclaim") in
    chan.send #stream "$chan" "$v");;;
    do:  (let: "$chan" := (![type.chanT #stringT] (struct.field_ref #stream #"req"%go "comma")) in
    let: "$v" := #"Hello"%go in
    chan.send #stringT "$chan" "$v");;;
    do:  (let: "$chan" := (![type.chanT #stringT] (struct.field_ref #stream #"req"%go "exclaim")) in
    let: "$v" := #"World"%go in
    chan.send #stringT "$chan" "$v");;;
    return: (((Fst (chan.receive #stringT (![type.chanT #stringT] (struct.field_ref #stream #"res"%go "comma")))) + #" "%go) + (Fst (chan.receive #stringT (![type.chanT #stringT] (struct.field_ref #stream #"res"%go "exclaim")))))).

Definition worker : go_string := "github.com/goose-lang/goose/testdata/examples/channel.worker"%go.

(* go: parallel_search_replace.go:13:6 *)
Definition workerⁱᵐᵖˡ : val :=
  λ: "c" "wg" "x" "y",
    exception_do (let: "y" := (mem.alloc "y") in
    let: "x" := (mem.alloc "x") in
    let: "wg" := (mem.alloc "wg") in
    let: "c" := (mem.alloc "c") in
    (let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "s" := (mem.alloc (type.zero_val #sliceT)) in
    let: ("$ret0", "$ret1") := (chan.receive #sliceT (![type.chanT #sliceT] "c")) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("s" <-[#sliceT] "$r0");;;
    do:  ("ok" <-[#boolT] "$r1");;;
    (for: (λ: <>, ![#boolT] "ok"); (λ: <>, let: ("$ret0", "$ret1") := (chan.receive #sliceT (![type.chanT #sliceT] "c")) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("s" <-[#sliceT] "$r0");;;
    do:  ("ok" <-[#boolT] "$r1")) := λ: <>,
      (let: "i" := (mem.alloc (type.zero_val #intT)) in
      let: "$r0" := #(W64 0) in
      do:  ("i" <-[#intT] "$r0");;;
      (for: (λ: <>, (![#intT] "i") ≠ (let: "$a0" := (![#sliceT] "s") in
      slice.len "$a0")); (λ: <>, do:  ("i" <-[#intT] ((![#intT] "i") + #(W64 1)))) := λ: <>,
        (if: (![#intT] (slice.elem_ref #intT (![#sliceT] "s") (![#intT] "i"))) = (![#intT] "x")
        then
          let: "$r0" := (![#intT] "y") in
          do:  ((slice.elem_ref #intT (![#sliceT] "s") (![#intT] "i")) <-[#intT] "$r0")
        else do:  #())));;;
      do:  ((method_call #(ptrT.id sync.WaitGroup.id) #"Done"%go (![#ptrT] "wg")) #())));;;
    return: #()).

Definition SearchReplace : go_string := "github.com/goose-lang/goose/testdata/examples/channel.SearchReplace"%go.

(* go: parallel_search_replace.go:24:6 *)
Definition SearchReplaceⁱᵐᵖˡ : val :=
  λ: "s" "x" "y",
    exception_do (let: "y" := (mem.alloc "y") in
    let: "x" := (mem.alloc "x") in
    let: "s" := (mem.alloc "s") in
    (if: (let: "$a0" := (![#sliceT] "s") in
    slice.len "$a0") = #(W64 0)
    then return: (#())
    else do:  #());;;
    let: "workers" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := #(W64 8) in
    do:  ("workers" <-[#intT] "$r0");;;
    let: "workRange" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := #(W64 1000) in
    do:  ("workRange" <-[#intT] "$r0");;;
    let: "c" := (mem.alloc (type.zero_val (type.chanT #sliceT))) in
    let: "$r0" := (chan.make #sliceT #(W64 4)) in
    do:  ("c" <-[type.chanT #sliceT] "$r0");;;
    let: "wg" := (mem.alloc (type.zero_val #sync.WaitGroup)) in
    (let: "i" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[#intT] "$r0");;;
    (for: (λ: <>, (![#intT] "i") ≠ (![#intT] "workers")); (λ: <>, do:  ("i" <-[#intT] ((![#intT] "i") + #(W64 1)))) := λ: <>,
      let: "$a0" := (![type.chanT #sliceT] "c") in
      let: "$a1" := "wg" in
      let: "$a2" := (![#intT] "x") in
      let: "$a3" := (![#intT] "y") in
      let: "$go" := (func_call #worker) in
      do:  (Fork ("$go" "$a0" "$a1" "$a2" "$a3"))));;;
    (let: "offset" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := #(W64 0) in
    do:  ("offset" <-[#intT] "$r0");;;
    (for: (λ: <>, (![#intT] "offset") ≠ (let: "$a0" := (![#sliceT] "s") in
    slice.len "$a0")); (λ: <>, #()) := λ: <>,
      let: "nextOffset" := (mem.alloc (type.zero_val #intT)) in
      let: "$r0" := ((![#intT] "offset") + (![#intT] "workRange")) in
      do:  ("nextOffset" <-[#intT] "$r0");;;
      (if: int_gt (![#intT] "nextOffset") (let: "$a0" := (![#sliceT] "s") in
      slice.len "$a0")
      then
        let: "$r0" := (let: "$a0" := (![#sliceT] "s") in
        slice.len "$a0") in
        do:  ("nextOffset" <-[#intT] "$r0")
      else do:  #());;;
      let: "section" := (mem.alloc (type.zero_val #sliceT)) in
      let: "$r0" := (let: "$s" := (![#sliceT] "s") in
      slice.slice #intT "$s" (![#intT] "offset") (![#intT] "nextOffset")) in
      do:  ("section" <-[#sliceT] "$r0");;;
      do:  (let: "$a0" := #(W64 1) in
      (method_call #(ptrT.id sync.WaitGroup.id) #"Add"%go "wg") "$a0");;;
      do:  (let: "$chan" := (![type.chanT #sliceT] "c") in
      let: "$v" := (![#sliceT] "section") in
      chan.send #sliceT "$chan" "$v");;;
      let: "$r0" := (![#intT] "nextOffset") in
      do:  ("offset" <-[#intT] "$r0")));;;
    do:  ((method_call #(ptrT.id sync.WaitGroup.id) #"Wait"%go "wg") #());;;
    return: #()).

Definition vars' : list (go_string * go_type) := [].

Definition functions' : list (go_string * val) := [(NewLockedStack, NewLockedStackⁱᵐᵖˡ); (after, afterⁱᵐᵖˡ); (NewEliminationStack, NewEliminationStackⁱᵐᵖˡ); (sys_hello_world, sys_hello_worldⁱᵐᵖˡ); (HelloWorldAsync, HelloWorldAsyncⁱᵐᵖˡ); (HelloWorldSync, HelloWorldSyncⁱᵐᵖˡ); (HelloWorldCancellable, HelloWorldCancellableⁱᵐᵖˡ); (HelloWorldWithTimeout, HelloWorldWithTimeoutⁱᵐᵖˡ); (DSPExample, DSPExampleⁱᵐᵖˡ); (fibonacci, fibonacciⁱᵐᵖˡ); (fib_consumer, fib_consumerⁱᵐᵖˡ); (simple_join, simple_joinⁱᵐᵖˡ); (simple_multi_join, simple_multi_joinⁱᵐᵖˡ); (select_nb_no_panic, select_nb_no_panicⁱᵐᵖˡ); (select_no_double_close, select_no_double_closeⁱᵐᵖˡ); (select_ready_case_no_panic, select_ready_case_no_panicⁱᵐᵖˡ); (TestHelloWorldSync, TestHelloWorldSyncⁱᵐᵖˡ); (TestHelloWorldWithTimeout, TestHelloWorldWithTimeoutⁱᵐᵖˡ); (TestDSPExample, TestDSPExampleⁱᵐᵖˡ); (TestFibConsumer, TestFibConsumerⁱᵐᵖˡ); (TestSelectNbNoPanic, TestSelectNbNoPanicⁱᵐᵖˡ); (TestSelectReadyCaseNoPanic, TestSelectReadyCaseNoPanicⁱᵐᵖˡ); (load, loadⁱᵐᵖˡ); (process, processⁱᵐᵖˡ); (client, clientⁱᵐᵖˡ); (server, serverⁱᵐᵖˡ); (LeakyBufferPipeline, LeakyBufferPipelineⁱᵐᵖˡ); (mkRequest, mkRequestⁱᵐᵖˡ); (ho_worker, ho_workerⁱᵐᵖˡ); (HigherOrderExample, HigherOrderExampleⁱᵐᵖˡ); (mkStream, mkStreamⁱᵐᵖˡ); (Async, Asyncⁱᵐᵖˡ); (MapServer, MapServerⁱᵐᵖˡ); (Client, Clientⁱᵐᵖˡ); (Muxer, Muxerⁱᵐᵖˡ); (CancellableMapServer, CancellableMapServerⁱᵐᵖˡ); (CancellableMuxer, CancellableMuxerⁱᵐᵖˡ); (makeGreeting, makeGreetingⁱᵐᵖˡ); (worker, workerⁱᵐᵖˡ); (SearchReplace, SearchReplaceⁱᵐᵖˡ)].

Definition msets' : list (go_string * (list (go_string * val))) := [(LockedStack.id, []); (ptrT.id LockedStack.id, [("Pop"%go, LockedStack__Popⁱᵐᵖˡ); ("Push"%go, LockedStack__Pushⁱᵐᵖˡ)]); (EliminationStack.id, []); (ptrT.id EliminationStack.id, [("Pop"%go, EliminationStack__Popⁱᵐᵖˡ); ("Push"%go, EliminationStack__Pushⁱᵐᵖˡ)]); (request.id, []); (ptrT.id request.id, []); (stream.id, []); (ptrT.id stream.id, [])].

#[global] Instance info' : PkgInfo channel.chan_spec_raw_examples :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [code.sync.sync; code.time.time; code.strings.strings];
  |}.

Definition initialize' : val :=
  λ: <>,
    package.init #channel.chan_spec_raw_examples (λ: <>,
      exception_do (do:  (strings.initialize' #());;;
      do:  (time.initialize' #());;;
      do:  (sync.initialize' #());;;
      do:  (package.alloc channel.chan_spec_raw_examples #()))
      ).

End code.
End chan_spec_raw_examples.
