(* autogenerated from github.com/goose-lang/goose/testdata/examples/channel *)
Require Export New.code.strings.
Require Export New.code.sync.
Require Export New.code.time.

From New.golang Require Import defn.
Definition chan_spec_raw_examples : go_string := "github.com/goose-lang/goose/testdata/examples/channel".

Module chan_spec_raw_examples.

Definition LockedStack : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/channel.LockedStack"%go [].

(* go: elimination_stack.go:24:23 *)
Definition LockedStack__Popⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" <>,
    exception_do (let: "s" := (GoAlloc (go.PointerType LockedStack) "s") in
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go #() (StructFieldRef LockedStack "mu"%go (![go.PointerType LockedStack] "s"))) #());;;
    (if: (let: "$a0" := (![go.SliceType go.string] (StructFieldRef LockedStack "stack"%go (![go.PointerType LockedStack] "s"))) in
    (FuncResolve go.len [go.SliceType go.string] #()) "$a0") =⟨go.int⟩ #(W64 0)
    then
      do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go #() (StructFieldRef LockedStack "mu"%go (![go.PointerType LockedStack] "s"))) #());;;
      return: (#""%go, #false)
    else do:  #());;;
    let: "last" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := ((let: "$a0" := (![go.SliceType go.string] (StructFieldRef LockedStack "stack"%go (![go.PointerType LockedStack] "s"))) in
    (FuncResolve go.len [go.SliceType go.string] #()) "$a0") -⟨go.int⟩ #(W64 1)) in
    do:  ("last" <-[go.int] "$r0");;;
    let: "v" := (GoAlloc go.string (GoZeroVal go.string #())) in
    let: "$r0" := (![go.string] (IndexRef (go.SliceType go.string) (![go.SliceType go.string] (StructFieldRef LockedStack "stack"%go (![go.PointerType LockedStack] "s")), ![go.int] "last"))) in
    do:  ("v" <-[go.string] "$r0");;;
    let: "$r0" := (let: "$s" := (![go.SliceType go.string] (StructFieldRef LockedStack "stack"%go (![go.PointerType LockedStack] "s"))) in
    Slice (go.SliceType go.string) ("$s", #(W64 0), ![go.int] "last")) in
    do:  ((StructFieldRef LockedStack "stack"%go (![go.PointerType LockedStack] "s")) <-[go.SliceType go.string] "$r0");;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go #() (StructFieldRef LockedStack "mu"%go (![go.PointerType LockedStack] "s"))) #());;;
    return: (![go.string] "v", #true)).

(* go: elimination_stack.go:18:23 *)
Definition LockedStack__Pushⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" "value",
    exception_do (let: "s" := (GoAlloc (go.PointerType LockedStack) "s") in
    let: "value" := (GoAlloc go.string "value") in
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go #() (StructFieldRef LockedStack "mu"%go (![go.PointerType LockedStack] "s"))) #());;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.string] (StructFieldRef LockedStack "stack"%go (![go.PointerType LockedStack] "s"))) in
    let: "$a1" := ((let: "$sl0" := (![go.string] "value") in
    CompositeLiteral go.string (LiteralValue [KeyedElement None (ElementExpression "$sl0")]))) in
    (FuncResolve go.append [go.SliceType go.string] #()) "$a0" "$a1") in
    do:  ((StructFieldRef LockedStack "stack"%go (![go.PointerType LockedStack] "s")) <-[go.SliceType go.string] "$r0");;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go #() (StructFieldRef LockedStack "mu"%go (![go.PointerType LockedStack] "s"))) #());;;
    return: #()).

Definition LockedStackⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "mu"%go sync.Mutex);
  (go.FieldDecl "stack"%go (go.SliceType go.string))
].

Module LockedStack.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  mu : sync.Mutex.t;
  stack : slice.t;
}.
#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _)|}.
End def.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.

End LockedStack.

Class LockedStack_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] LockedStack_zero_val  :: go.GoZeroValEq LockedStack LockedStack.t;
  #[global] LockedStack_underlying  :: go.Underlying (LockedStack ) (LockedStackⁱᵐᵖˡ );
  #[global] LockedStack'ptr_Pop_unfold :: MethodUnfold (go.PointerType (LockedStack)) "Pop" (LockedStack__Popⁱᵐᵖˡ);
  #[global] LockedStack'ptr_Push_unfold :: MethodUnfold (go.PointerType (LockedStack)) "Push" (LockedStack__Pushⁱᵐᵖˡ);
}.

Definition NewLockedStack {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.NewLockedStack"%go.

(* go: elimination_stack.go:14:6 *)
Definition NewLockedStackⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (GoAlloc LockedStack (CompositeLiteral LockedStack (LiteralValue [KeyedElement (Some (KeyField "stack"%go)) (ElementExpression ((FuncResolve go.make2 [go.SliceType go.string] #()) #(W64 0)))])))).

Definition timeout {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 10000).

Definition EliminationStack : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/channel.EliminationStack"%go [].

(* Pop first tries one-shot elimination; on timeout, falls back to the locked stack.

   go: elimination_stack.go:67:28 *)
Definition EliminationStack__Popⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" <>,
    exception_do (let: "s" := (GoAlloc (go.PointerType EliminationStack) "s") in
    chan.select_blocking [chan.select_receive go.string (![go.ChannelType go.sendrecv go.string] (StructFieldRef EliminationStack "exchanger"%go (![go.PointerType EliminationStack] "s"))) (λ: "$recvVal",
       let: "v" := (GoAlloc go.string (GoZeroVal go.string #())) in
       let: "$r0" := (Fst "$recvVal") in
       do:  ("v" <-[go.string] "$r0");;;
       return: (![go.string] "v", #true)
       ); chan.select_receive time.Time (let: "$a0" := timeout in
     (FuncResolve time.After [] #()) "$a0") (λ: "$recvVal",
       do:  #()
       )];;;
    let: ("$ret0", "$ret1") := (((MethodResolve (go.PointerType LockedStack) "Pop"%go #() (![go.PointerType LockedStack] (StructFieldRef EliminationStack "base"%go (![go.PointerType EliminationStack] "s")))) #())) in
    return: ("$ret0", "$ret1")).

(* Push first tries one-shot elimination; on timeout, falls back to the locked stack.

   go: elimination_stack.go:55:28 *)
Definition EliminationStack__Pushⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" "value",
    exception_do (let: "s" := (GoAlloc (go.PointerType EliminationStack) "s") in
    let: "value" := (GoAlloc go.string "value") in
    chan.select_blocking [chan.select_send go.string (![go.ChannelType go.sendrecv go.string] (StructFieldRef EliminationStack "exchanger"%go (![go.PointerType EliminationStack] "s"))) (![go.string] "value") (λ: <>,
       return: (#())
       ); chan.select_receive time.Time (let: "$a0" := timeout in
     (FuncResolve time.After [] #()) "$a0") (λ: "$recvVal",
       do:  #()
       )];;;
    do:  (let: "$a0" := (![go.string] "value") in
    (MethodResolve (go.PointerType LockedStack) "Push"%go #() (![go.PointerType LockedStack] (StructFieldRef EliminationStack "base"%go (![go.PointerType EliminationStack] "s")))) "$a0");;;
    return: #()).

Definition EliminationStackⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "base"%go (go.PointerType LockedStack));
  (go.FieldDecl "exchanger"%go (go.ChannelType go.sendrecv go.string))
].

Module EliminationStack.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  base : loc;
  exchanger : loc;
}.
#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _)|}.
End def.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.

End EliminationStack.

Class EliminationStack_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] EliminationStack_zero_val  :: go.GoZeroValEq EliminationStack EliminationStack.t;
  #[global] EliminationStack_underlying  :: go.Underlying (EliminationStack ) (EliminationStackⁱᵐᵖˡ );
  #[global] EliminationStack'ptr_Pop_unfold :: MethodUnfold (go.PointerType (EliminationStack)) "Pop" (EliminationStack__Popⁱᵐᵖˡ);
  #[global] EliminationStack'ptr_Push_unfold :: MethodUnfold (go.PointerType (EliminationStack)) "Push" (EliminationStack__Pushⁱᵐᵖˡ);
}.

Definition NewEliminationStack {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.NewEliminationStack"%go.

(* NewEliminationStack constructs a new elimination stack
   using a fresh LockedStack and a small default timeout.

   go: elimination_stack.go:47:6 *)
Definition NewEliminationStackⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (GoAlloc EliminationStack (CompositeLiteral EliminationStack (LiteralValue [KeyedElement (Some (KeyField "base"%go)) (ElementExpression ((FuncResolve NewLockedStack [] #()) #())); KeyedElement (Some (KeyField "exchanger"%go)) (ElementExpression ((FuncResolve go.make1 [go.ChannelType go.sendrecv go.string] #()) #()))])))).

Definition sys_hello_world {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.sys_hello_world"%go.

(* Fake syscall for demonstration.

   go: examples.go:8:6 *)
Definition sys_hello_worldⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (#"Hello, World!"%go)).

Definition HelloWorldAsync {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.HelloWorldAsync"%go.

(* go: examples.go:12:6 *)
Definition HelloWorldAsyncⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "ch" := (GoAlloc (go.ChannelType go.sendrecv go.string) (GoZeroVal (go.ChannelType go.sendrecv go.string) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.ChannelType go.sendrecv go.string] #()) #(W64 1)) in
    do:  ("ch" <-[go.ChannelType go.sendrecv go.string] "$r0");;;
    let: "$go" := (λ: <>,
      exception_do (do:  (let: "$chan" := (![go.ChannelType go.sendrecv go.string] "ch") in
      let: "$v" := ((FuncResolve sys_hello_world [] #()) #()) in
      chan.send go.string "$chan" "$v");;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    return: (![go.ChannelType go.sendrecv go.string] "ch")).

Definition HelloWorldSync {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.HelloWorldSync"%go.

(* go: examples.go:20:6 *)
Definition HelloWorldSyncⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (Fst (chan.receive go.string ((FuncResolve HelloWorldAsync [] #()) #())))).

Definition HelloWorldCancellable {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.HelloWorldCancellable"%go.

(* Simulates the error/done channel components of Context

   go: examples.go:25:6 *)
Definition HelloWorldCancellableⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "done" "err",
    exception_do (let: "err" := (GoAlloc (go.PointerType go.string) "err") in
    let: "done" := (GoAlloc (go.ChannelType go.sendrecv (go.StructType [
    ])) "done") in
    let: "future" := (GoAlloc (go.ChannelType go.sendrecv go.string) (GoZeroVal (go.ChannelType go.sendrecv go.string) #())) in
    let: "$r0" := ((FuncResolve HelloWorldAsync [] #()) #()) in
    do:  ("future" <-[go.ChannelType go.sendrecv go.string] "$r0");;;
    chan.select_blocking [chan.select_receive go.string (![go.ChannelType go.sendrecv go.string] "future") (λ: "$recvVal",
       let: "resolved" := (GoAlloc go.string (GoZeroVal go.string #())) in
       let: "$r0" := (Fst "$recvVal") in
       do:  ("resolved" <-[go.string] "$r0");;;
       return: (![go.string] "resolved")
       ); chan.select_receive (go.StructType [
     ]) (![go.ChannelType go.sendrecv (go.StructType [
     ])] "done") (λ: "$recvVal",
       return: (![go.string] (![go.PointerType go.string] "err"))
       )]).

Definition HelloWorldWithTimeout {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.HelloWorldWithTimeout"%go.

(* Uses cancellation as a timeout mechanism.

   go: examples.go:36:6 *)
Definition HelloWorldWithTimeoutⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "done" := (GoAlloc (go.ChannelType go.sendrecv (go.StructType [
    ])) (GoZeroVal (go.ChannelType go.sendrecv (go.StructType [
    ])) #())) in
    let: "$r0" := ((FuncResolve go.make1 [go.ChannelType go.sendrecv (go.StructType [
     ])] #()) #()) in
    do:  ("done" <-[go.ChannelType go.sendrecv (go.StructType [
    ])] "$r0");;;
    let: "errMsg" := (GoAlloc go.string (GoZeroVal go.string #())) in
    let: "$r0" := #""%go in
    do:  ("errMsg" <-[go.string] "$r0");;;
    let: "$go" := (λ: <>,
      exception_do (do:  (let: "$a0" := (#(W64 10) *⟨go.int64⟩ time.Millisecond) in
      (FuncResolve time.Sleep [] #()) "$a0");;;
      let: "$r0" := #"operation timed out"%go in
      do:  ("errMsg" <-[go.string] "$r0");;;
      do:  (let: "$a0" := (![go.ChannelType go.sendrecv (go.StructType [
      ])] "done") in
      (FuncResolve go.close [go.ChannelType go.sendrecv (go.StructType [
       ])] #()) "$a0");;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    return: (let: "$a0" := (![go.ChannelType go.sendrecv (go.StructType [
     ])] "done") in
     let: "$a1" := "errMsg" in
     (FuncResolve HelloWorldCancellable [] #()) "$a0" "$a1")).

Definition DSPExample {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.DSPExample"%go.

(* prog3 from Actris 2.0 intro: https://arxiv.org/pdf/2010.15030

   go: examples.go:51:6 *)
Definition DSPExampleⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "c" := (GoAlloc (go.ChannelType go.sendrecv (go.InterfaceType [])) (GoZeroVal (go.ChannelType go.sendrecv (go.InterfaceType [])) #())) in
    let: "$r0" := ((FuncResolve go.make1 [go.ChannelType go.sendrecv (go.InterfaceType [])] #()) #()) in
    do:  ("c" <-[go.ChannelType go.sendrecv (go.InterfaceType [])] "$r0");;;
    let: "signal" := (GoAlloc (go.ChannelType go.sendrecv (go.InterfaceType [])) (GoZeroVal (go.ChannelType go.sendrecv (go.InterfaceType [])) #())) in
    let: "$r0" := ((FuncResolve go.make1 [go.ChannelType go.sendrecv (go.InterfaceType [])] #()) #()) in
    do:  ("signal" <-[go.ChannelType go.sendrecv (go.InterfaceType [])] "$r0");;;
    let: "$go" := (λ: <>,
      exception_do (let: "ptr" := (GoAlloc (go.PointerType go.int) (GoZeroVal (go.PointerType go.int) #())) in
      let: "$r0" := (TypeAssert (go.PointerType go.int) (Fst (chan.receive (go.InterfaceType []) (![go.ChannelType go.sendrecv (go.InterfaceType [])] "c")))) in
      do:  ("ptr" <-[go.PointerType go.int] "$r0");;;
      let: "$r0" := ((![go.int] (![go.PointerType go.int] "ptr")) +⟨go.int⟩ #(W64 2)) in
      do:  ((![go.PointerType go.int] "ptr") <-[go.int] "$r0");;;
      do:  (let: "$chan" := (![go.ChannelType go.sendrecv (go.InterfaceType [])] "signal") in
      let: "$v" := (InterfaceMake (go.StructType [
      ]) (CompositeLiteral (go.StructType [
      ]) (LiteralValue []))) in
      chan.send (go.InterfaceType []) "$chan" "$v");;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    let: "val" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := #(W64 40) in
    do:  ("val" <-[go.int] "$r0");;;
    let: "ptr" := (GoAlloc (go.PointerType go.int) (GoZeroVal (go.PointerType go.int) #())) in
    let: "$r0" := "val" in
    do:  ("ptr" <-[go.PointerType go.int] "$r0");;;
    do:  (let: "$chan" := (![go.ChannelType go.sendrecv (go.InterfaceType [])] "c") in
    let: "$v" := (InterfaceMake (go.PointerType go.int) (![go.PointerType go.int] "ptr")) in
    chan.send (go.InterfaceType []) "$chan" "$v");;;
    do:  (Fst (chan.receive (go.InterfaceType []) (![go.ChannelType go.sendrecv (go.InterfaceType [])] "signal")));;;
    return: (![go.int] (![go.PointerType go.int] "ptr"))).

Definition fibonacci {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.fibonacci"%go.

(* https://go.dev/tour/concurrency/4

   go: examples.go:69:6 *)
Definition fibonacciⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "n" "c",
    exception_do (let: "c" := (GoAlloc (go.ChannelType go.sendrecv go.int) "c") in
    let: "n" := (GoAlloc go.int "n") in
    let: "y" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "x" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := #(W64 0) in
    let: "$r1" := #(W64 1) in
    do:  ("x" <-[go.int] "$r0");;;
    do:  ("y" <-[go.int] "$r1");;;
    (let: "i" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.int] "$r0");;;
    (for: (λ: <>, (![go.int] "i") <⟨go.int⟩ (![go.int] "n")); (λ: <>, do:  ("i" <-[go.int] ((![go.int] "i") +⟨go.int⟩ #(W64 1)))) := λ: <>,
      do:  (let: "$chan" := (![go.ChannelType go.sendrecv go.int] "c") in
      let: "$v" := (![go.int] "x") in
      chan.send go.int "$chan" "$v");;;
      let: "$r0" := (![go.int] "y") in
      let: "$r1" := ((![go.int] "x") +⟨go.int⟩ (![go.int] "y")) in
      do:  ("x" <-[go.int] "$r0");;;
      do:  ("y" <-[go.int] "$r1")));;;
    do:  (let: "$a0" := (![go.ChannelType go.sendrecv go.int] "c") in
    (FuncResolve go.close [go.ChannelType go.sendrecv go.int] #()) "$a0");;;
    return: #()).

Definition fib_consumer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.fib_consumer"%go.

(* go: examples.go:78:6 *)
Definition fib_consumerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "c" := (GoAlloc (go.ChannelType go.sendrecv go.int) (GoZeroVal (go.ChannelType go.sendrecv go.int) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.ChannelType go.sendrecv go.int] #()) #(W64 10)) in
    do:  ("c" <-[go.ChannelType go.sendrecv go.int] "$r0");;;
    let: "$a0" := (let: "$a0" := (![go.ChannelType go.sendrecv go.int] "c") in
    (FuncResolve go.cap [go.ChannelType go.sendrecv go.int] #()) "$a0") in
    let: "$a1" := (![go.ChannelType go.sendrecv go.int] "c") in
    let: "$go" := (FuncResolve fibonacci [] #()) in
    do:  (Fork ("$go" "$a0" "$a1"));;;
    let: "results" := (GoAlloc (go.SliceType go.int) (GoZeroVal (go.SliceType go.int) #())) in
    let: "$r0" := (CompositeLiteral (go.SliceType go.int) (LiteralValue [])) in
    do:  ("results" <-[go.SliceType go.int] "$r0");;;
    let: "$range" := (![go.ChannelType go.sendrecv go.int] "c") in
    (let: "i" := (GoAlloc go.int (GoZeroVal go.int #())) in
    chan.for_range go.int "$range" (λ: "$key",
      do:  ("i" <-[go.int] "$key");;;
      let: "$r0" := (let: "$a0" := (![go.SliceType go.int] "results") in
      let: "$a1" := ((let: "$sl0" := (![go.int] "i") in
      CompositeLiteral go.int (LiteralValue [KeyedElement None (ElementExpression "$sl0")]))) in
      (FuncResolve go.append [go.SliceType go.int] #()) "$a0" "$a1") in
      do:  ("results" <-[go.SliceType go.int] "$r0")));;;
    return: (![go.SliceType go.int] "results")).

Definition simple_join {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.simple_join"%go.

(* go: examples.go:89:6 *)
Definition simple_joinⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "ch" := (GoAlloc (go.ChannelType go.sendrecv (go.StructType [
    ])) (GoZeroVal (go.ChannelType go.sendrecv (go.StructType [
    ])) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.ChannelType go.sendrecv (go.StructType [
     ])] #()) #(W64 1)) in
    do:  ("ch" <-[go.ChannelType go.sendrecv (go.StructType [
    ])] "$r0");;;
    let: "message" := (GoAlloc go.string (GoZeroVal go.string #())) in
    let: "$go" := (λ: <>,
      exception_do (let: "$r0" := #"Hello, World!"%go in
      do:  ("message" <-[go.string] "$r0");;;
      do:  (let: "$chan" := (![go.ChannelType go.sendrecv (go.StructType [
      ])] "ch") in
      let: "$v" := (CompositeLiteral (go.StructType [
      ]) (LiteralValue [])) in
      chan.send (go.StructType [
      ]) "$chan" "$v");;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    do:  (Fst (chan.receive (go.StructType [
    ]) (![go.ChannelType go.sendrecv (go.StructType [
    ])] "ch")));;;
    return: (![go.string] "message")).

Definition simple_multi_join {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.simple_multi_join"%go.

(* go: examples.go:102:6 *)
Definition simple_multi_joinⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "ch" := (GoAlloc (go.ChannelType go.sendrecv (go.StructType [
    ])) (GoZeroVal (go.ChannelType go.sendrecv (go.StructType [
    ])) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.ChannelType go.sendrecv (go.StructType [
     ])] #()) #(W64 2)) in
    do:  ("ch" <-[go.ChannelType go.sendrecv (go.StructType [
    ])] "$r0");;;
    let: "world" := (GoAlloc go.string (GoZeroVal go.string #())) in
    let: "hello" := (GoAlloc go.string (GoZeroVal go.string #())) in
    let: "$go" := (λ: <>,
      exception_do (let: "$r0" := #"Hello"%go in
      do:  ("hello" <-[go.string] "$r0");;;
      do:  (let: "$chan" := (![go.ChannelType go.sendrecv (go.StructType [
      ])] "ch") in
      let: "$v" := (CompositeLiteral (go.StructType [
      ]) (LiteralValue [])) in
      chan.send (go.StructType [
      ]) "$chan" "$v");;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    let: "$go" := (λ: <>,
      exception_do (let: "$r0" := #"World"%go in
      do:  ("world" <-[go.string] "$r0");;;
      do:  (let: "$chan" := (![go.ChannelType go.sendrecv (go.StructType [
      ])] "ch") in
      let: "$v" := (CompositeLiteral (go.StructType [
      ]) (LiteralValue [])) in
      chan.send (go.StructType [
      ]) "$chan" "$v");;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    do:  (Fst (chan.receive (go.StructType [
    ]) (![go.ChannelType go.sendrecv (go.StructType [
    ])] "ch")));;;
    do:  (Fst (chan.receive (go.StructType [
    ]) (![go.ChannelType go.sendrecv (go.StructType [
    ])] "ch")));;;
    return: (((![go.string] "hello") +⟨go.string⟩ #" "%go) +⟨go.string⟩ (![go.string] "world"))).

Definition select_nb_no_panic {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.select_nb_no_panic"%go.

(* Show that it isn't possible to have 2 nonblocking ops that match.

   go: examples.go:121:6 *)
Definition select_nb_no_panicⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "ch" := (GoAlloc (go.ChannelType go.sendrecv (go.StructType [
    ])) (GoZeroVal (go.ChannelType go.sendrecv (go.StructType [
    ])) #())) in
    let: "$r0" := ((FuncResolve go.make1 [go.ChannelType go.sendrecv (go.StructType [
     ])] #()) #()) in
    do:  ("ch" <-[go.ChannelType go.sendrecv (go.StructType [
    ])] "$r0");;;
    let: "$go" := (λ: <>,
      exception_do (chan.select_nonblocking [chan.select_receive (go.StructType [
       ]) (![go.ChannelType go.sendrecv (go.StructType [
       ])] "ch") (λ: "$recvVal",
         do:  (let: "$a0" := (InterfaceMake go.string #"bad"%go) in
         (FuncResolve go.panic [] #()) "$a0")
         )] (λ: <>,
        do:  #()
        );;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    chan.select_nonblocking [chan.select_send (go.StructType [
     ]) (![go.ChannelType go.sendrecv (go.StructType [
     ])] "ch") (CompositeLiteral (go.StructType [
     ]) (LiteralValue [])) (λ: <>,
       do:  (let: "$a0" := (InterfaceMake go.string #"bad"%go) in
       (FuncResolve go.panic [] #()) "$a0")
       )] (λ: <>,
      do:  #()
      );;;
    return: #()).

Definition select_no_double_close {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.select_no_double_close"%go.

(* go: examples.go:138:6 *)
Definition select_no_double_closeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc (go.ChannelType go.sendrecv go.int) (GoZeroVal (go.ChannelType go.sendrecv go.int) #())) in
    let: "$r0" := ((FuncResolve go.make1 [go.ChannelType go.sendrecv go.int] #()) #()) in
    do:  ("x" <-[go.ChannelType go.sendrecv go.int] "$r0");;;
    do:  (let: "$a0" := (![go.ChannelType go.sendrecv go.int] "x") in
    (FuncResolve go.close [go.ChannelType go.sendrecv go.int] #()) "$a0");;;
    chan.select_nonblocking [chan.select_receive go.int (![go.ChannelType go.sendrecv go.int] "x") (λ: "$recvVal",
       do:  #()
       )] (λ: <>,
      do:  (let: "$a0" := (![go.ChannelType go.sendrecv go.int] "x") in
      (FuncResolve go.close [go.ChannelType go.sendrecv go.int] #()) "$a0")
      );;;
    return: #()).

Definition exchangePointer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.exchangePointer"%go.

(* go: examples.go:148:6 *)
Definition exchangePointerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := #(W64 0) in
    do:  ("x" <-[go.int] "$r0");;;
    let: "y" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := #(W64 0) in
    do:  ("y" <-[go.int] "$r0");;;
    let: "ch" := (GoAlloc (go.ChannelType go.sendrecv (go.StructType [
    ])) (GoZeroVal (go.ChannelType go.sendrecv (go.StructType [
    ])) #())) in
    let: "$r0" := ((FuncResolve go.make1 [go.ChannelType go.sendrecv (go.StructType [
     ])] #()) #()) in
    do:  ("ch" <-[go.ChannelType go.sendrecv (go.StructType [
    ])] "$r0");;;
    let: "$go" := (λ: <>,
      exception_do (let: "$r0" := #(W64 1) in
      do:  ("x" <-[go.int] "$r0");;;
      do:  (let: "$chan" := (![go.ChannelType go.sendrecv (go.StructType [
      ])] "ch") in
      let: "$v" := (CompositeLiteral (go.StructType [
      ]) (LiteralValue [])) in
      chan.send (go.StructType [
      ]) "$chan" "$v");;;
      (if: (![go.int] "y") ≠⟨go.int⟩ #(W64 2)
      then
        do:  (let: "$a0" := (InterfaceMake go.string #"bad"%go) in
        (FuncResolve go.panic [] #()) "$a0")
      else do:  #());;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    let: "$r0" := #(W64 2) in
    do:  ("y" <-[go.int] "$r0");;;
    do:  (Fst (chan.receive (go.StructType [
    ]) (![go.ChannelType go.sendrecv (go.StructType [
    ])] "ch")));;;
    (if: (![go.int] "x") ≠⟨go.int⟩ #(W64 1)
    then
      do:  (let: "$a0" := (InterfaceMake go.string #"bad"%go) in
      (FuncResolve go.panic [] #()) "$a0")
    else do:  #());;;
    return: #()).

Definition select_ready_case_no_panic {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.select_ready_case_no_panic"%go.

(* Show that a guaranteed to be ready case makes default impossible

   go: examples_unverified.go:6:6 *)
Definition select_ready_case_no_panicⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "ch" := (GoAlloc (go.ChannelType go.sendrecv (go.StructType [
    ])) (GoZeroVal (go.ChannelType go.sendrecv (go.StructType [
    ])) #())) in
    let: "$r0" := ((FuncResolve go.make1 [go.ChannelType go.sendrecv (go.StructType [
     ])] #()) #()) in
    do:  ("ch" <-[go.ChannelType go.sendrecv (go.StructType [
    ])] "$r0");;;
    do:  (let: "$a0" := (![go.ChannelType go.sendrecv (go.StructType [
    ])] "ch") in
    (FuncResolve go.close [go.ChannelType go.sendrecv (go.StructType [
     ])] #()) "$a0");;;
    chan.select_nonblocking [chan.select_receive (go.StructType [
     ]) (![go.ChannelType go.sendrecv (go.StructType [
     ])] "ch") (λ: "$recvVal",
       do:  #()
       )] (λ: <>,
      do:  (let: "$a0" := (InterfaceMake go.string #"Shouldn't be possible!"%go) in
      (FuncResolve go.panic [] #()) "$a0")
      );;;
    return: #()).

Definition TestHelloWorldSync {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.TestHelloWorldSync"%go.

(* Various tests that should panic when failing, which also means verifying { True } e { True } is
   sufficient since panic can't be verified.

   go: examples_unverified.go:20:6 *)
Definition TestHelloWorldSyncⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "result" := (GoAlloc go.string (GoZeroVal go.string #())) in
    let: "$r0" := ((FuncResolve HelloWorldSync [] #()) #()) in
    do:  ("result" <-[go.string] "$r0");;;
    (if: (![go.string] "result") ≠⟨go.string⟩ #"Hello, World!"%go
    then
      do:  (let: "$a0" := (InterfaceMake go.string #"incorrect output"%go) in
      (FuncResolve go.panic [] #()) "$a0")
    else do:  #());;;
    return: #()).

Definition TestHelloWorldWithTimeout {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.TestHelloWorldWithTimeout"%go.

(* go: examples_unverified.go:27:6 *)
Definition TestHelloWorldWithTimeoutⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "result" := (GoAlloc go.string (GoZeroVal go.string #())) in
    let: "$r0" := ((FuncResolve HelloWorldWithTimeout [] #()) #()) in
    do:  ("result" <-[go.string] "$r0");;;
    (if: ((![go.string] "result") ≠⟨go.string⟩ #"operation timed out"%go) && ((![go.string] "result") ≠⟨go.string⟩ #"Hello, World!"%go)
    then
      do:  (let: "$a0" := (InterfaceMake go.string #"incorrect output"%go) in
      (FuncResolve go.panic [] #()) "$a0")
    else do:  #());;;
    return: #()).

Definition TestDSPExample {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.TestDSPExample"%go.

(* go: examples_unverified.go:34:6 *)
Definition TestDSPExampleⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "result" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := ((FuncResolve DSPExample [] #()) #()) in
    do:  ("result" <-[go.int] "$r0");;;
    (if: (![go.int] "result") ≠⟨go.int⟩ #(W64 42)
    then
      do:  (let: "$a0" := (InterfaceMake go.string #"incorrect output"%go) in
      (FuncResolve go.panic [] #()) "$a0")
    else do:  #());;;
    return: #()).

Definition TestFibConsumer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.TestFibConsumer"%go.

(* go: examples_unverified.go:41:6 *)
Definition TestFibConsumerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "result" := (GoAlloc (go.SliceType go.int) (GoZeroVal (go.SliceType go.int) #())) in
    let: "$r0" := ((FuncResolve fib_consumer [] #()) #()) in
    do:  ("result" <-[go.SliceType go.int] "$r0");;;
    let: "expected" := (GoAlloc (go.SliceType go.int) (GoZeroVal (go.SliceType go.int) #())) in
    let: "$r0" := (CompositeLiteral (go.SliceType go.int) (LiteralValue [KeyedElement None (ElementExpression #(W64 0)); KeyedElement None (ElementExpression #(W64 1)); KeyedElement None (ElementExpression #(W64 1)); KeyedElement None (ElementExpression #(W64 2)); KeyedElement None (ElementExpression #(W64 3)); KeyedElement None (ElementExpression #(W64 5)); KeyedElement None (ElementExpression #(W64 8)); KeyedElement None (ElementExpression #(W64 13)); KeyedElement None (ElementExpression #(W64 21)); KeyedElement None (ElementExpression #(W64 34))])) in
    do:  ("expected" <-[go.SliceType go.int] "$r0");;;
    (if: (let: "$a0" := (![go.SliceType go.int] "result") in
    (FuncResolve go.len [go.SliceType go.int] #()) "$a0") ≠⟨go.int⟩ (let: "$a0" := (![go.SliceType go.int] "expected") in
    (FuncResolve go.len [go.SliceType go.int] #()) "$a0")
    then
      do:  (let: "$a0" := (InterfaceMake go.string #"incorrect output"%go) in
      (FuncResolve go.panic [] #()) "$a0")
    else do:  #());;;
    let: "$range" := (![go.SliceType go.int] "expected") in
    (let: "i" := (GoAlloc go.int (GoZeroVal go.int #())) in
    slice.for_range go.int "$range" (λ: "$key" "$value",
      do:  ("i" <-[go.int] "$key");;;
      (if: (![go.int] (IndexRef (go.SliceType go.int) (![go.SliceType go.int] "result", ![go.int] "i"))) ≠⟨go.int⟩ (![go.int] (IndexRef (go.SliceType go.int) (![go.SliceType go.int] "expected", ![go.int] "i")))
      then
        do:  (let: "$a0" := (InterfaceMake go.string #"incorrect output"%go) in
        (FuncResolve go.panic [] #()) "$a0")
      else do:  #())));;;
    return: #()).

Definition TestSelectNbNoPanic {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.TestSelectNbNoPanic"%go.

(* go: examples_unverified.go:56:6 *)
Definition TestSelectNbNoPanicⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "iterations" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := #(W64 10000) in
    do:  ("iterations" <-[go.int] "$r0");;;
    (let: "i" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.int] "$r0");;;
    (for: (λ: <>, (![go.int] "i") <⟨go.int⟩ (![go.int] "iterations")); (λ: <>, do:  ("i" <-[go.int] ((![go.int] "i") +⟨go.int⟩ #(W64 1)))) := λ: <>,
      do:  ((FuncResolve select_nb_no_panic [] #()) #());;;
      do:  (let: "$a0" := (#(W64 1) *⟨go.int64⟩ time.Microsecond) in
      (FuncResolve time.Sleep [] #()) "$a0")));;;
    return: #()).

Definition TestSelectReadyCaseNoPanic {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.TestSelectReadyCaseNoPanic"%go.

(* go: examples_unverified.go:65:6 *)
Definition TestSelectReadyCaseNoPanicⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "iterations" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := #(W64 10000) in
    do:  ("iterations" <-[go.int] "$r0");;;
    (let: "i" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.int] "$r0");;;
    (for: (λ: <>, (![go.int] "i") <⟨go.int⟩ (![go.int] "iterations")); (λ: <>, do:  ("i" <-[go.int] ((![go.int] "i") +⟨go.int⟩ #(W64 1)))) := λ: <>,
      do:  ((FuncResolve select_ready_case_no_panic [] #()) #())));;;
    return: #()).

Definition requestⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "f"%go (go.FunctionType (go.Signature [] false [go.string])));
  (go.FieldDecl "result"%go (go.ChannelType go.sendrecv go.string))
].

Definition request : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/channel.request"%go [].

Module request.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  f : func.t;
  result : loc;
}.
#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _)|}.
End def.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.

End request.

Class request_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] request_zero_val  :: go.GoZeroValEq request request.t;
  #[global] request_underlying  :: go.Underlying (request ) (requestⁱᵐᵖˡ );
}.

Definition mkRequest {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.mkRequest"%go.

(* go: higher_order.go:8:6 *)
Definition mkRequestⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "f",
    exception_do (let: "f" := (GoAlloc (go.FunctionType (go.Signature [] false [go.string])) "f") in
    return: (CompositeLiteral request (LiteralValue [KeyedElement (Some (KeyField "f"%go)) (ElementExpression (![go.FunctionType (go.Signature [] false [go.string])] "f")); KeyedElement (Some (KeyField "result"%go)) (ElementExpression ((FuncResolve go.make2 [go.ChannelType go.sendrecv go.string] #()) #(W64 1)))]))).

Definition ho_worker {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.ho_worker"%go.

(* go: higher_order.go:12:6 *)
Definition ho_workerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "c",
    exception_do (let: "c" := (GoAlloc (go.ChannelType go.sendrecv request) "c") in
    let: "$range" := (![go.ChannelType go.sendrecv request] "c") in
    (let: "r" := (GoAlloc request (GoZeroVal request #())) in
    chan.for_range request "$range" (λ: "$key",
      do:  ("r" <-[request] "$key");;;
      do:  (let: "$chan" := (![go.ChannelType go.sendrecv go.string] (StructFieldRef request "result"%go "r")) in
      let: "$v" := ((![go.FunctionType (go.Signature [] false [go.string])] (StructFieldRef request "f"%go "r")) #()) in
      chan.send go.string "$chan" "$v")));;;
    return: #()).

Definition HigherOrderExample {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.HigherOrderExample"%go.

(* go: higher_order.go:18:6 *)
Definition HigherOrderExampleⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "c" := (GoAlloc (go.ChannelType go.sendrecv request) (GoZeroVal (go.ChannelType go.sendrecv request) #())) in
    let: "$r0" := ((FuncResolve go.make1 [go.ChannelType go.sendrecv request] #()) #()) in
    do:  ("c" <-[go.ChannelType go.sendrecv request] "$r0");;;
    let: "$a0" := (![go.ChannelType go.sendrecv request] "c") in
    let: "$go" := (FuncResolve ho_worker [] #()) in
    do:  (Fork ("$go" "$a0"));;;
    let: "$a0" := (![go.ChannelType go.sendrecv request] "c") in
    let: "$go" := (FuncResolve ho_worker [] #()) in
    do:  (Fork ("$go" "$a0"));;;
    let: "r1" := (GoAlloc request (GoZeroVal request #())) in
    let: "$r0" := (let: "$a0" := (λ: <>,
      exception_do (return: (#"hello world"%go))
      ) in
    (FuncResolve mkRequest [] #()) "$a0") in
    do:  ("r1" <-[request] "$r0");;;
    let: "r2" := (GoAlloc request (GoZeroVal request #())) in
    let: "$r0" := (let: "$a0" := (λ: <>,
      exception_do (return: (#"HELLO"%go))
      ) in
    (FuncResolve mkRequest [] #()) "$a0") in
    do:  ("r2" <-[request] "$r0");;;
    let: "r3" := (GoAlloc request (GoZeroVal request #())) in
    let: "$r0" := (let: "$a0" := (λ: <>,
      exception_do (return: (#"world"%go))
      ) in
    (FuncResolve mkRequest [] #()) "$a0") in
    do:  ("r3" <-[request] "$r0");;;
    do:  (let: "$chan" := (![go.ChannelType go.sendrecv request] "c") in
    let: "$v" := (![request] "r1") in
    chan.send request "$chan" "$v");;;
    do:  (let: "$chan" := (![go.ChannelType go.sendrecv request] "c") in
    let: "$v" := (![request] "r2") in
    chan.send request "$chan" "$v");;;
    do:  (let: "$chan" := (![go.ChannelType go.sendrecv request] "c") in
    let: "$v" := (![request] "r3") in
    chan.send request "$chan" "$v");;;
    let: "responses" := (GoAlloc (go.SliceType go.string) (GoZeroVal (go.SliceType go.string) #())) in
    let: "$r0" := (CompositeLiteral (go.SliceType go.string) (LiteralValue [KeyedElement None (ElementExpression (Fst (chan.receive go.string (![go.ChannelType go.sendrecv go.string] (StructFieldRef request "result"%go "r1"))))); KeyedElement None (ElementExpression (Fst (chan.receive go.string (![go.ChannelType go.sendrecv go.string] (StructFieldRef request "result"%go "r2"))))); KeyedElement None (ElementExpression (Fst (chan.receive go.string (![go.ChannelType go.sendrecv go.string] (StructFieldRef request "result"%go "r3")))))])) in
    do:  ("responses" <-[go.SliceType go.string] "$r0");;;
    return: (![go.SliceType go.string] "responses")).

Definition load {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.load"%go.

(* load writes the next letter into the buffer.

   go: leaky_buffer.go:9:6 *)
Definition loadⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "b" "letter",
    exception_do (let: "letter" := (GoAlloc go.string "letter") in
    let: "b" := (GoAlloc (go.PointerType (go.SliceType go.byte)) "b") in
    let: "$r0" := (string.to_bytes (![go.string] "letter")) in
    do:  ((![go.PointerType (go.SliceType go.byte)] "b") <-[go.SliceType go.byte] "$r0");;;
    return: #()).

Definition process {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.process"%go.

(* process consumes the buffer and appends it to the output.

   go: leaky_buffer.go:14:6 *)
Definition processⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "b" "output",
    exception_do (let: "output" := (GoAlloc (go.PointerType go.string) "output") in
    let: "b" := (GoAlloc (go.PointerType (go.SliceType go.byte)) "b") in
    do:  ((![go.PointerType go.string] "output") <-[go.string] ((![go.string] (![go.PointerType go.string] "output")) +⟨go.string⟩ (let: "$a0" := (string.from_bytes (![go.SliceType go.byte] (![go.PointerType (go.SliceType go.byte)] "b"))) in
    (FuncResolve strings.ToUpper [] #()) "$a0")));;;
    return: #()).

Definition client {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.client"%go.

(* go: leaky_buffer.go:18:6 *)
Definition clientⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "input" "freeList" "serverChan",
    exception_do (let: "serverChan" := (GoAlloc (go.ChannelType go.sendrecv (go.SliceType go.byte)) "serverChan") in
    let: "freeList" := (GoAlloc (go.ChannelType go.sendrecv (go.SliceType go.byte)) "freeList") in
    let: "input" := (GoAlloc (go.SliceType go.string) "input") in
    let: "$range" := (![go.SliceType go.string] "input") in
    (let: "letter" := (GoAlloc go.string (GoZeroVal go.string #())) in
    slice.for_range go.string "$range" (λ: "$key" "$value",
      do:  ("letter" <-[go.string] "$value");;;
      do:  "$key";;;
      let: "b" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
      chan.select_nonblocking [chan.select_receive (go.SliceType go.byte) (![go.ChannelType go.sendrecv (go.SliceType go.byte)] "freeList") (λ: "$recvVal",
         let: "$r0" := (Fst "$recvVal") in
         do:  ("b" <-[go.SliceType go.byte] "$r0");;;
         do:  #()
         )] (λ: <>,
        let: "$r0" := (CompositeLiteral (go.SliceType go.byte) (LiteralValue [KeyedElement None (ElementExpression #(W8 0))])) in
        do:  ("b" <-[go.SliceType go.byte] "$r0")
        );;;
      do:  (let: "$a0" := "b" in
      let: "$a1" := (![go.string] "letter") in
      (FuncResolve load [] #()) "$a0" "$a1");;;
      do:  (let: "$chan" := (![go.ChannelType go.sendrecv (go.SliceType go.byte)] "serverChan") in
      let: "$v" := (![go.SliceType go.byte] "b") in
      chan.send (go.SliceType go.byte) "$chan" "$v")));;;
    do:  (let: "$a0" := (![go.ChannelType go.sendrecv (go.SliceType go.byte)] "serverChan") in
    (FuncResolve go.close [go.ChannelType go.sendrecv (go.SliceType go.byte)] #()) "$a0");;;
    return: #()).

Definition server {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.server"%go.

(* go: leaky_buffer.go:39:6 *)
Definition serverⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "output" "freeList" "serverChan" "done",
    exception_do (let: "done" := (GoAlloc (go.ChannelType go.sendrecv (go.StructType [
    ])) "done") in
    let: "serverChan" := (GoAlloc (go.ChannelType go.sendrecv (go.SliceType go.byte)) "serverChan") in
    let: "freeList" := (GoAlloc (go.ChannelType go.sendrecv (go.SliceType go.byte)) "freeList") in
    let: "output" := (GoAlloc (go.PointerType go.string) "output") in
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
      let: "b" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
      let: ("$ret0", "$ret1") := (chan.receive (go.SliceType go.byte) (![go.ChannelType go.sendrecv (go.SliceType go.byte)] "serverChan")) in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("b" <-[go.SliceType go.byte] "$r0");;;
      do:  ("ok" <-[go.bool] "$r1");;;
      (if: (~ (![go.bool] "ok"))
      then
        do:  (let: "$chan" := (![go.ChannelType go.sendrecv (go.StructType [
        ])] "done") in
        let: "$v" := (CompositeLiteral (go.StructType [
        ]) (LiteralValue [])) in
        chan.send (go.StructType [
        ]) "$chan" "$v");;;
        return: (#())
      else do:  #());;;
      do:  (let: "$a0" := "b" in
      let: "$a1" := (![go.PointerType go.string] "output") in
      (FuncResolve process [] #()) "$a0" "$a1");;;
      chan.select_nonblocking [chan.select_send (go.SliceType go.byte) (![go.ChannelType go.sendrecv (go.SliceType go.byte)] "freeList") (![go.SliceType go.byte] "b") (λ: <>,
         do:  #()
         )] (λ: <>,
        do:  #()
        ));;;
    return: #()).

Definition LeakyBufferPipeline {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.LeakyBufferPipeline"%go.

(* go: leaky_buffer.go:61:6 *)
Definition LeakyBufferPipelineⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "freeList" := (GoAlloc (go.ChannelType go.sendrecv (go.SliceType go.byte)) (GoZeroVal (go.ChannelType go.sendrecv (go.SliceType go.byte)) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.ChannelType go.sendrecv (go.SliceType go.byte)] #()) #(W64 5)) in
    do:  ("freeList" <-[go.ChannelType go.sendrecv (go.SliceType go.byte)] "$r0");;;
    let: "serverChan" := (GoAlloc (go.ChannelType go.sendrecv (go.SliceType go.byte)) (GoZeroVal (go.ChannelType go.sendrecv (go.SliceType go.byte)) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.ChannelType go.sendrecv (go.SliceType go.byte)] #()) #(W64 0)) in
    do:  ("serverChan" <-[go.ChannelType go.sendrecv (go.SliceType go.byte)] "$r0");;;
    let: "done" := (GoAlloc (go.ChannelType go.sendrecv (go.StructType [
    ])) (GoZeroVal (go.ChannelType go.sendrecv (go.StructType [
    ])) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.ChannelType go.sendrecv (go.StructType [
     ])] #()) #(W64 0)) in
    do:  ("done" <-[go.ChannelType go.sendrecv (go.StructType [
    ])] "$r0");;;
    let: "output" := (GoAlloc go.string (GoZeroVal go.string #())) in
    let: "$r0" := #""%go in
    do:  ("output" <-[go.string] "$r0");;;
    let: "$a0" := "output" in
    let: "$a1" := (![go.ChannelType go.sendrecv (go.SliceType go.byte)] "freeList") in
    let: "$a2" := (![go.ChannelType go.sendrecv (go.SliceType go.byte)] "serverChan") in
    let: "$a3" := (![go.ChannelType go.sendrecv (go.StructType [
    ])] "done") in
    let: "$go" := (FuncResolve server [] #()) in
    do:  (Fork ("$go" "$a0" "$a1" "$a2" "$a3"));;;
    do:  (let: "$a0" := (CompositeLiteral (go.SliceType go.string) (LiteralValue [KeyedElement None (ElementExpression #"h"%go); KeyedElement None (ElementExpression #"e"%go); KeyedElement None (ElementExpression #"l"%go); KeyedElement None (ElementExpression #"l"%go); KeyedElement None (ElementExpression #"o"%go); KeyedElement None (ElementExpression #","%go); KeyedElement None (ElementExpression #" "%go); KeyedElement None (ElementExpression #"w"%go); KeyedElement None (ElementExpression #"o"%go); KeyedElement None (ElementExpression #"r"%go); KeyedElement None (ElementExpression #"l"%go); KeyedElement None (ElementExpression #"d"%go)])) in
    let: "$a1" := (![go.ChannelType go.sendrecv (go.SliceType go.byte)] "freeList") in
    let: "$a2" := (![go.ChannelType go.sendrecv (go.SliceType go.byte)] "serverChan") in
    (FuncResolve client [] #()) "$a0" "$a1" "$a2");;;
    do:  (Fst (chan.receive (go.StructType [
    ]) (![go.ChannelType go.sendrecv (go.StructType [
    ])] "done")));;;
    (if: (![go.string] "output") ≠⟨go.string⟩ #"HELLO, WORLD"%go
    then
      do:  (let: "$a0" := (InterfaceMake go.string #"incorrect output"%go) in
      (FuncResolve go.panic [] #()) "$a0")
    else do:  #());;;
    return: #()).

Definition streamⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "req"%go (go.ChannelType go.sendrecv go.string));
  (go.FieldDecl "res"%go (go.ChannelType go.sendrecv go.string))
].

Definition stream : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/channel.stream"%go [].

Module stream.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  req : loc;
  res : loc;
}.
#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _)|}.
End def.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.

End stream.

Class stream_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] stream_zero_val  :: go.GoZeroValEq stream stream.t;
  #[global] stream_underlying  :: go.Underlying (stream ) (streamⁱᵐᵖˡ );
}.

Definition streamoldⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "req"%go (go.ChannelType go.sendrecv go.string));
  (go.FieldDecl "res"%go (go.ChannelType go.sendrecv go.string));
  (go.FieldDecl "f"%go (go.FunctionType (go.Signature [go.string] false [go.string])))
].

Definition streamold : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/channel.streamold"%go [].

Module streamold.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  req : loc;
  res : loc;
  f : func.t;
}.
#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _)|}.
End def.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.

End streamold.

Class streamold_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] streamold_zero_val  :: go.GoZeroValEq streamold streamold.t;
  #[global] streamold_underlying  :: go.Underlying (streamold ) (streamoldⁱᵐᵖˡ );
}.

Definition mkStream {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.mkStream"%go.

(* go: muxer.go:14:6 *)
Definition mkStreamⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "f",
    exception_do (let: "f" := (GoAlloc (go.FunctionType (go.Signature [go.string] false [go.string])) "f") in
    return: (CompositeLiteral streamold (LiteralValue [KeyedElement None (ElementExpression ((FuncResolve go.make1 [go.ChannelType go.sendrecv go.string] #()) #())); KeyedElement None (ElementExpression ((FuncResolve go.make1 [go.ChannelType go.sendrecv go.string] #()) #())); KeyedElement None (ElementExpression (![go.FunctionType (go.Signature [go.string] false [go.string])] "f"))]))).

Definition Async {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.Async"%go.

(* go: muxer.go:18:6 *)
Definition Asyncⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "f",
    exception_do (let: "f" := (GoAlloc (go.FunctionType (go.Signature [] false [go.string])) "f") in
    let: "ch" := (GoAlloc (go.ChannelType go.sendrecv go.string) (GoZeroVal (go.ChannelType go.sendrecv go.string) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.ChannelType go.sendrecv go.string] #()) #(W64 1)) in
    do:  ("ch" <-[go.ChannelType go.sendrecv go.string] "$r0");;;
    let: "$go" := (λ: <>,
      exception_do (do:  (let: "$chan" := (![go.ChannelType go.sendrecv go.string] "ch") in
      let: "$v" := ((![go.FunctionType (go.Signature [] false [go.string])] "f") #()) in
      chan.send go.string "$chan" "$v");;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    return: (![go.ChannelType go.sendrecv go.string] "ch")).

Definition Serve {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.Serve"%go.

(* go: muxer.go:26:6 *)
Definition Serveⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "f",
    exception_do (let: "f" := (GoAlloc (go.FunctionType (go.Signature [go.string] false [go.string])) "f") in
    let: "s" := (GoAlloc stream (GoZeroVal stream #())) in
    let: "$r0" := (CompositeLiteral stream (LiteralValue [KeyedElement (Some (KeyField "req"%go)) (ElementExpression ((FuncResolve go.make1 [go.ChannelType go.sendrecv go.string] #()) #())); KeyedElement (Some (KeyField "res"%go)) (ElementExpression ((FuncResolve go.make1 [go.ChannelType go.sendrecv go.string] #()) #()))])) in
    do:  ("s" <-[stream] "$r0");;;
    let: "$go" := (λ: <>,
      exception_do ((for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
        do:  (let: "$chan" := (![go.ChannelType go.sendrecv go.string] (StructFieldRef stream "res"%go "s")) in
        let: "$v" := (let: "$a0" := (Fst (chan.receive go.string (![go.ChannelType go.sendrecv go.string] (StructFieldRef stream "req"%go "s")))) in
        (![go.FunctionType (go.Signature [go.string] false [go.string])] "f") "$a0") in
        chan.send go.string "$chan" "$v"));;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    return: (![stream] "s")).

Definition appWrld {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.appWrld"%go.

(* go: muxer.go:39:6 *)
Definition appWrldⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s",
    exception_do (let: "s" := (GoAlloc go.string "s") in
    return: ((![go.string] "s") +⟨go.string⟩ #", World!"%go)).

Definition Client {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.Client"%go.

(* go: muxer.go:43:6 *)
Definition Clientⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "hw" := (GoAlloc stream (GoZeroVal stream #())) in
    let: "$r0" := (let: "$a0" := (FuncResolve appWrld [] #()) in
    (FuncResolve Serve [] #()) "$a0") in
    do:  ("hw" <-[stream] "$r0");;;
    do:  (let: "$chan" := (![go.ChannelType go.sendrecv go.string] (StructFieldRef stream "req"%go "hw")) in
    let: "$v" := #"Hello"%go in
    chan.send go.string "$chan" "$v");;;
    return: (Fst (chan.receive go.string (![go.ChannelType go.sendrecv go.string] (StructFieldRef stream "res"%go "hw"))))).

Definition MapServer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.MapServer"%go.

(* go: muxer.go:49:6 *)
Definition MapServerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s",
    exception_do (let: "s" := (GoAlloc streamold "s") in
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "in" := (GoAlloc go.string (GoZeroVal go.string #())) in
      let: "$r0" := (Fst (chan.receive go.string (![go.ChannelType go.sendrecv go.string] (StructFieldRef streamold "req"%go "s")))) in
      do:  ("in" <-[go.string] "$r0");;;
      do:  (let: "$chan" := (![go.ChannelType go.sendrecv go.string] (StructFieldRef streamold "res"%go "s")) in
      let: "$v" := (let: "$a0" := (![go.string] "in") in
      (![go.FunctionType (go.Signature [go.string] false [go.string])] (StructFieldRef streamold "f"%go "s")) "$a0") in
      chan.send go.string "$chan" "$v"));;;
    return: #()).

Definition ClientOld {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.ClientOld"%go.

(* go: muxer.go:56:6 *)
Definition ClientOldⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "comma" := (GoAlloc streamold (GoZeroVal streamold #())) in
    let: "$r0" := (let: "$a0" := (λ: "s",
      exception_do (let: "s" := (GoAlloc go.string "s") in
      return: ((![go.string] "s") +⟨go.string⟩ #","%go))
      ) in
    (FuncResolve mkStream [] #()) "$a0") in
    do:  ("comma" <-[streamold] "$r0");;;
    let: "exclaim" := (GoAlloc streamold (GoZeroVal streamold #())) in
    let: "$r0" := (let: "$a0" := (λ: "s",
      exception_do (let: "s" := (GoAlloc go.string "s") in
      return: ((![go.string] "s") +⟨go.string⟩ #"!"%go))
      ) in
    (FuncResolve mkStream [] #()) "$a0") in
    do:  ("exclaim" <-[streamold] "$r0");;;
    let: "$a0" := (![streamold] "comma") in
    let: "$go" := (FuncResolve MapServer [] #()) in
    do:  (Fork ("$go" "$a0"));;;
    let: "$a0" := (![streamold] "exclaim") in
    let: "$go" := (FuncResolve MapServer [] #()) in
    do:  (Fork ("$go" "$a0"));;;
    do:  (let: "$chan" := (![go.ChannelType go.sendrecv go.string] (StructFieldRef streamold "req"%go "comma")) in
    let: "$v" := #"Hello"%go in
    chan.send go.string "$chan" "$v");;;
    do:  (let: "$chan" := (![go.ChannelType go.sendrecv go.string] (StructFieldRef streamold "req"%go "exclaim")) in
    let: "$v" := #"World"%go in
    chan.send go.string "$chan" "$v");;;
    return: (((Fst (chan.receive go.string (![go.ChannelType go.sendrecv go.string] (StructFieldRef streamold "res"%go "comma")))) +⟨go.string⟩ #" "%go) +⟨go.string⟩ (Fst (chan.receive go.string (![go.ChannelType go.sendrecv go.string] (StructFieldRef streamold "res"%go "exclaim")))))).

Definition Muxer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.Muxer"%go.

(* go: muxer.go:71:6 *)
Definition Muxerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "c",
    exception_do (let: "c" := (GoAlloc (go.ChannelType go.sendrecv streamold) "c") in
    let: "$range" := (![go.ChannelType go.sendrecv streamold] "c") in
    (let: "s" := (GoAlloc streamold (GoZeroVal streamold #())) in
    chan.for_range streamold "$range" (λ: "$key",
      do:  ("s" <-[streamold] "$key");;;
      let: "$a0" := (![streamold] "s") in
      let: "$go" := (FuncResolve MapServer [] #()) in
      do:  (Fork ("$go" "$a0"))));;;
    return: #()).

Definition makeGreeting {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.makeGreeting"%go.

(* go: muxer.go:77:6 *)
Definition makeGreetingⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "mux" := (GoAlloc (go.ChannelType go.sendrecv streamold) (GoZeroVal (go.ChannelType go.sendrecv streamold) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.ChannelType go.sendrecv streamold] #()) #(W64 2)) in
    do:  ("mux" <-[go.ChannelType go.sendrecv streamold] "$r0");;;
    let: "$a0" := (![go.ChannelType go.sendrecv streamold] "mux") in
    let: "$go" := (FuncResolve Muxer [] #()) in
    do:  (Fork ("$go" "$a0"));;;
    let: "comma" := (GoAlloc streamold (GoZeroVal streamold #())) in
    let: "$r0" := (let: "$a0" := (λ: "s",
      exception_do (let: "s" := (GoAlloc go.string "s") in
      return: ((![go.string] "s") +⟨go.string⟩ #","%go))
      ) in
    (FuncResolve mkStream [] #()) "$a0") in
    do:  ("comma" <-[streamold] "$r0");;;
    let: "exclaim" := (GoAlloc streamold (GoZeroVal streamold #())) in
    let: "$r0" := (let: "$a0" := (λ: "s",
      exception_do (let: "s" := (GoAlloc go.string "s") in
      return: ((![go.string] "s") +⟨go.string⟩ #"!"%go))
      ) in
    (FuncResolve mkStream [] #()) "$a0") in
    do:  ("exclaim" <-[streamold] "$r0");;;
    do:  (let: "$chan" := (![go.ChannelType go.sendrecv streamold] "mux") in
    let: "$v" := (![streamold] "comma") in
    chan.send streamold "$chan" "$v");;;
    do:  (let: "$chan" := (![go.ChannelType go.sendrecv streamold] "mux") in
    let: "$v" := (![streamold] "exclaim") in
    chan.send streamold "$chan" "$v");;;
    do:  (let: "$chan" := (![go.ChannelType go.sendrecv go.string] (StructFieldRef streamold "req"%go "comma")) in
    let: "$v" := #"Hello"%go in
    chan.send go.string "$chan" "$v");;;
    do:  (let: "$chan" := (![go.ChannelType go.sendrecv go.string] (StructFieldRef streamold "req"%go "exclaim")) in
    let: "$v" := #"World"%go in
    chan.send go.string "$chan" "$v");;;
    return: (((Fst (chan.receive go.string (![go.ChannelType go.sendrecv go.string] (StructFieldRef streamold "res"%go "comma")))) +⟨go.string⟩ #" "%go) +⟨go.string⟩ (Fst (chan.receive go.string (![go.ChannelType go.sendrecv go.string] (StructFieldRef streamold "res"%go "exclaim")))))).

Definition CancellableMapServer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.CancellableMapServer"%go.

(* go: muxer_unverified.go:3:6 *)
Definition CancellableMapServerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" "done",
    exception_do (let: "done" := (GoAlloc (go.ChannelType go.sendrecv (go.StructType [
    ])) "done") in
    let: "s" := (GoAlloc streamold "s") in
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      chan.select_blocking [chan.select_receive go.string (![go.ChannelType go.sendrecv go.string] (StructFieldRef streamold "req"%go "s")) (λ: "$recvVal",
         let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
         let: "in" := (GoAlloc go.string (GoZeroVal go.string #())) in
         let: ("$ret0", "$ret1") := "$recvVal" in
         let: "$r0" := "$ret0" in
         let: "$r1" := "$ret1" in
         do:  ("in" <-[go.string] "$r0");;;
         do:  ("ok" <-[go.bool] "$r1");;;
         (if: (~ (![go.bool] "ok"))
         then return: (#())
         else do:  #());;;
         do:  (let: "$chan" := (![go.ChannelType go.sendrecv go.string] (StructFieldRef streamold "res"%go "s")) in
         let: "$v" := (let: "$a0" := (![go.string] "in") in
         (![go.FunctionType (go.Signature [go.string] false [go.string])] (StructFieldRef streamold "f"%go "s")) "$a0") in
         chan.send go.string "$chan" "$v")
         ); chan.select_receive (go.StructType [
       ]) (![go.ChannelType go.sendrecv (go.StructType [
       ])] "done") (λ: "$recvVal",
         return: (#())
         )]);;;
    return: #()).

Definition CancellableMuxer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.CancellableMuxer"%go.

(* 4. CancellableMuxer - muxer with cancellation

   go: muxer_unverified.go:18:6 *)
Definition CancellableMuxerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "c" "done" "errMsg",
    exception_do (let: "errMsg" := (GoAlloc (go.PointerType go.string) "errMsg") in
    let: "done" := (GoAlloc (go.ChannelType go.sendrecv (go.StructType [
    ])) "done") in
    let: "c" := (GoAlloc (go.ChannelType go.sendrecv streamold) "c") in
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      chan.select_blocking [chan.select_receive streamold (![go.ChannelType go.sendrecv streamold] "c") (λ: "$recvVal",
         let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
         let: "s" := (GoAlloc streamold (GoZeroVal streamold #())) in
         let: ("$ret0", "$ret1") := "$recvVal" in
         let: "$r0" := "$ret0" in
         let: "$r1" := "$ret1" in
         do:  ("s" <-[streamold] "$r0");;;
         do:  ("ok" <-[go.bool] "$r1");;;
         (if: (~ (![go.bool] "ok"))
         then return: (#"serviced all requests"%go)
         else do:  #());;;
         let: "$a0" := (![streamold] "s") in
         let: "$a1" := (![go.ChannelType go.sendrecv (go.StructType [
         ])] "done") in
         let: "$go" := (FuncResolve CancellableMapServer [] #()) in
         do:  (Fork ("$go" "$a0" "$a1"))
         ); chan.select_receive (go.StructType [
       ]) (![go.ChannelType go.sendrecv (go.StructType [
       ])] "done") (λ: "$recvVal",
         return: (![go.string] (![go.PointerType go.string] "errMsg"))
         )])).

Definition worker {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.worker"%go.

(* go: parallel_search_replace.go:13:6 *)
Definition workerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "c" "wg" "x" "y",
    exception_do (let: "y" := (GoAlloc go.int "y") in
    let: "x" := (GoAlloc go.int "x") in
    let: "wg" := (GoAlloc (go.PointerType sync.WaitGroup) "wg") in
    let: "c" := (GoAlloc (go.ChannelType go.recvonly (go.SliceType go.int)) "c") in
    (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "s" := (GoAlloc (go.SliceType go.int) (GoZeroVal (go.SliceType go.int) #())) in
    let: ("$ret0", "$ret1") := (chan.receive (go.SliceType go.int) (![go.ChannelType go.recvonly (go.SliceType go.int)] "c")) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("s" <-[go.SliceType go.int] "$r0");;;
    do:  ("ok" <-[go.bool] "$r1");;;
    (for: (λ: <>, ![go.bool] "ok"); (λ: <>, let: ("$ret0", "$ret1") := (chan.receive (go.SliceType go.int) (![go.ChannelType go.recvonly (go.SliceType go.int)] "c")) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("s" <-[go.SliceType go.int] "$r0");;;
    do:  ("ok" <-[go.bool] "$r1")) := λ: <>,
      (let: "i" := (GoAlloc go.int (GoZeroVal go.int #())) in
      let: "$r0" := #(W64 0) in
      do:  ("i" <-[go.int] "$r0");;;
      (for: (λ: <>, (![go.int] "i") ≠⟨go.int⟩ (let: "$a0" := (![go.SliceType go.int] "s") in
      (FuncResolve go.len [go.SliceType go.int] #()) "$a0")); (λ: <>, do:  ("i" <-[go.int] ((![go.int] "i") +⟨go.int⟩ #(W64 1)))) := λ: <>,
        (if: (![go.int] (IndexRef (go.SliceType go.int) (![go.SliceType go.int] "s", ![go.int] "i"))) =⟨go.int⟩ (![go.int] "x")
        then
          let: "$r0" := (![go.int] "y") in
          do:  ((IndexRef (go.SliceType go.int) (![go.SliceType go.int] "s", ![go.int] "i")) <-[go.int] "$r0")
        else do:  #())));;;
      do:  ((MethodResolve (go.PointerType sync.WaitGroup) "Done"%go #() (![go.PointerType sync.WaitGroup] "wg")) #())));;;
    return: #()).

Definition SearchReplace {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.SearchReplace"%go.

(* go: parallel_search_replace.go:24:6 *)
Definition SearchReplaceⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" "x" "y",
    exception_do (let: "y" := (GoAlloc go.int "y") in
    let: "x" := (GoAlloc go.int "x") in
    let: "s" := (GoAlloc (go.SliceType go.int) "s") in
    (if: (let: "$a0" := (![go.SliceType go.int] "s") in
    (FuncResolve go.len [go.SliceType go.int] #()) "$a0") =⟨go.int⟩ #(W64 0)
    then return: (#())
    else do:  #());;;
    let: "workers" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := #(W64 8) in
    do:  ("workers" <-[go.int] "$r0");;;
    let: "workRange" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := #(W64 1000) in
    do:  ("workRange" <-[go.int] "$r0");;;
    let: "c" := (GoAlloc (go.ChannelType go.sendrecv (go.SliceType go.int)) (GoZeroVal (go.ChannelType go.sendrecv (go.SliceType go.int)) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.ChannelType go.sendrecv (go.SliceType go.int)] #()) #(W64 4)) in
    do:  ("c" <-[go.ChannelType go.sendrecv (go.SliceType go.int)] "$r0");;;
    let: "wg" := (GoAlloc sync.WaitGroup (GoZeroVal sync.WaitGroup #())) in
    (let: "i" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.int] "$r0");;;
    (for: (λ: <>, (![go.int] "i") ≠⟨go.int⟩ (![go.int] "workers")); (λ: <>, do:  ("i" <-[go.int] ((![go.int] "i") +⟨go.int⟩ #(W64 1)))) := λ: <>,
      let: "$a0" := (![go.ChannelType go.sendrecv (go.SliceType go.int)] "c") in
      let: "$a1" := "wg" in
      let: "$a2" := (![go.int] "x") in
      let: "$a3" := (![go.int] "y") in
      let: "$go" := (FuncResolve worker [] #()) in
      do:  (Fork ("$go" "$a0" "$a1" "$a2" "$a3"))));;;
    (let: "offset" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := #(W64 0) in
    do:  ("offset" <-[go.int] "$r0");;;
    (for: (λ: <>, (![go.int] "offset") ≠⟨go.int⟩ (let: "$a0" := (![go.SliceType go.int] "s") in
    (FuncResolve go.len [go.SliceType go.int] #()) "$a0")); (λ: <>, #()) := λ: <>,
      let: "nextOffset" := (GoAlloc go.int (GoZeroVal go.int #())) in
      let: "$r0" := ((![go.int] "offset") +⟨go.int⟩ (![go.int] "workRange")) in
      do:  ("nextOffset" <-[go.int] "$r0");;;
      (if: (![go.int] "nextOffset") >⟨go.int⟩ (let: "$a0" := (![go.SliceType go.int] "s") in
      (FuncResolve go.len [go.SliceType go.int] #()) "$a0")
      then
        let: "$r0" := (let: "$a0" := (![go.SliceType go.int] "s") in
        (FuncResolve go.len [go.SliceType go.int] #()) "$a0") in
        do:  ("nextOffset" <-[go.int] "$r0")
      else do:  #());;;
      let: "section" := (GoAlloc (go.SliceType go.int) (GoZeroVal (go.SliceType go.int) #())) in
      let: "$r0" := (let: "$s" := (![go.SliceType go.int] "s") in
      Slice (go.SliceType go.int) ("$s", ![go.int] "offset", ![go.int] "nextOffset")) in
      do:  ("section" <-[go.SliceType go.int] "$r0");;;
      do:  (let: "$a0" := #(W64 1) in
      (MethodResolve (go.PointerType sync.WaitGroup) "Add"%go #() "wg") "$a0");;;
      do:  (let: "$chan" := (![go.ChannelType go.sendrecv (go.SliceType go.int)] "c") in
      let: "$v" := (![go.SliceType go.int] "section") in
      chan.send (go.SliceType go.int) "$chan" "$v");;;
      let: "$r0" := (![go.int] "nextOffset") in
      do:  ("offset" <-[go.int] "$r0")));;;
    do:  ((MethodResolve (go.PointerType sync.WaitGroup) "Wait"%go #() "wg") #());;;
    return: #()).

#[global] Instance info' : PkgInfo channel.chan_spec_raw_examples := 
{|
  pkg_imported_pkgs := [code.sync.sync; code.time.time; code.strings.strings]
|}.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init channel.chan_spec_raw_examples (λ: <>,
      exception_do (do:  (strings.initialize' #());;;
      do:  (time.initialize' #());;;
      do:  (sync.initialize' #()))
      ).

Class Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] LockedStack_instance :: LockedStack_Assumptions;
  #[global] EliminationStack_instance :: EliminationStack_Assumptions;
  #[global] request_instance :: request_Assumptions;
  #[global] stream_instance :: stream_Assumptions;
  #[global] streamold_instance :: streamold_Assumptions;
  #[global] NewLockedStack_unfold :: FuncUnfold NewLockedStack [] (NewLockedStackⁱᵐᵖˡ);
  #[global] NewEliminationStack_unfold :: FuncUnfold NewEliminationStack [] (NewEliminationStackⁱᵐᵖˡ);
  #[global] sys_hello_world_unfold :: FuncUnfold sys_hello_world [] (sys_hello_worldⁱᵐᵖˡ);
  #[global] HelloWorldAsync_unfold :: FuncUnfold HelloWorldAsync [] (HelloWorldAsyncⁱᵐᵖˡ);
  #[global] HelloWorldSync_unfold :: FuncUnfold HelloWorldSync [] (HelloWorldSyncⁱᵐᵖˡ);
  #[global] HelloWorldCancellable_unfold :: FuncUnfold HelloWorldCancellable [] (HelloWorldCancellableⁱᵐᵖˡ);
  #[global] HelloWorldWithTimeout_unfold :: FuncUnfold HelloWorldWithTimeout [] (HelloWorldWithTimeoutⁱᵐᵖˡ);
  #[global] DSPExample_unfold :: FuncUnfold DSPExample [] (DSPExampleⁱᵐᵖˡ);
  #[global] fibonacci_unfold :: FuncUnfold fibonacci [] (fibonacciⁱᵐᵖˡ);
  #[global] fib_consumer_unfold :: FuncUnfold fib_consumer [] (fib_consumerⁱᵐᵖˡ);
  #[global] simple_join_unfold :: FuncUnfold simple_join [] (simple_joinⁱᵐᵖˡ);
  #[global] simple_multi_join_unfold :: FuncUnfold simple_multi_join [] (simple_multi_joinⁱᵐᵖˡ);
  #[global] select_nb_no_panic_unfold :: FuncUnfold select_nb_no_panic [] (select_nb_no_panicⁱᵐᵖˡ);
  #[global] select_no_double_close_unfold :: FuncUnfold select_no_double_close [] (select_no_double_closeⁱᵐᵖˡ);
  #[global] exchangePointer_unfold :: FuncUnfold exchangePointer [] (exchangePointerⁱᵐᵖˡ);
  #[global] select_ready_case_no_panic_unfold :: FuncUnfold select_ready_case_no_panic [] (select_ready_case_no_panicⁱᵐᵖˡ);
  #[global] TestHelloWorldSync_unfold :: FuncUnfold TestHelloWorldSync [] (TestHelloWorldSyncⁱᵐᵖˡ);
  #[global] TestHelloWorldWithTimeout_unfold :: FuncUnfold TestHelloWorldWithTimeout [] (TestHelloWorldWithTimeoutⁱᵐᵖˡ);
  #[global] TestDSPExample_unfold :: FuncUnfold TestDSPExample [] (TestDSPExampleⁱᵐᵖˡ);
  #[global] TestFibConsumer_unfold :: FuncUnfold TestFibConsumer [] (TestFibConsumerⁱᵐᵖˡ);
  #[global] TestSelectNbNoPanic_unfold :: FuncUnfold TestSelectNbNoPanic [] (TestSelectNbNoPanicⁱᵐᵖˡ);
  #[global] TestSelectReadyCaseNoPanic_unfold :: FuncUnfold TestSelectReadyCaseNoPanic [] (TestSelectReadyCaseNoPanicⁱᵐᵖˡ);
  #[global] mkRequest_unfold :: FuncUnfold mkRequest [] (mkRequestⁱᵐᵖˡ);
  #[global] ho_worker_unfold :: FuncUnfold ho_worker [] (ho_workerⁱᵐᵖˡ);
  #[global] HigherOrderExample_unfold :: FuncUnfold HigherOrderExample [] (HigherOrderExampleⁱᵐᵖˡ);
  #[global] load_unfold :: FuncUnfold load [] (loadⁱᵐᵖˡ);
  #[global] process_unfold :: FuncUnfold process [] (processⁱᵐᵖˡ);
  #[global] client_unfold :: FuncUnfold client [] (clientⁱᵐᵖˡ);
  #[global] server_unfold :: FuncUnfold server [] (serverⁱᵐᵖˡ);
  #[global] LeakyBufferPipeline_unfold :: FuncUnfold LeakyBufferPipeline [] (LeakyBufferPipelineⁱᵐᵖˡ);
  #[global] mkStream_unfold :: FuncUnfold mkStream [] (mkStreamⁱᵐᵖˡ);
  #[global] Async_unfold :: FuncUnfold Async [] (Asyncⁱᵐᵖˡ);
  #[global] Serve_unfold :: FuncUnfold Serve [] (Serveⁱᵐᵖˡ);
  #[global] appWrld_unfold :: FuncUnfold appWrld [] (appWrldⁱᵐᵖˡ);
  #[global] Client_unfold :: FuncUnfold Client [] (Clientⁱᵐᵖˡ);
  #[global] MapServer_unfold :: FuncUnfold MapServer [] (MapServerⁱᵐᵖˡ);
  #[global] ClientOld_unfold :: FuncUnfold ClientOld [] (ClientOldⁱᵐᵖˡ);
  #[global] Muxer_unfold :: FuncUnfold Muxer [] (Muxerⁱᵐᵖˡ);
  #[global] makeGreeting_unfold :: FuncUnfold makeGreeting [] (makeGreetingⁱᵐᵖˡ);
  #[global] CancellableMapServer_unfold :: FuncUnfold CancellableMapServer [] (CancellableMapServerⁱᵐᵖˡ);
  #[global] CancellableMuxer_unfold :: FuncUnfold CancellableMuxer [] (CancellableMuxerⁱᵐᵖˡ);
  #[global] worker_unfold :: FuncUnfold worker [] (workerⁱᵐᵖˡ);
  #[global] SearchReplace_unfold :: FuncUnfold SearchReplace [] (SearchReplaceⁱᵐᵖˡ);
}.
End chan_spec_raw_examples.
