(* autogenerated from github.com/goose-lang/goose/testdata/examples/channel *)
Require Export New.code.sync.
Require Export New.code.time.
Require Export New.code.strings.
From New.golang Require Import defn.
Module pkg_id.
Definition chan_spec_raw_examples : go_string := "github.com/goose-lang/goose/testdata/examples/channel".

End pkg_id.
Export pkg_id.
Module chan_spec_raw_examples.

Definition LockedStack {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/channel.LockedStack"%go [].

Definition EliminationStack {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/channel.EliminationStack"%go [].

Definition request {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/channel.request"%go [].

Definition stream {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/channel.stream"%go [].

Definition streamold {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/channel.streamold"%go [].

Definition timeout {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 10000).

Definition NewLockedStack {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.NewLockedStack"%go.

Definition NewEliminationStack {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.NewEliminationStack"%go.

Definition sys_hello_world {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.sys_hello_world"%go.

Definition HelloWorldAsync {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.HelloWorldAsync"%go.

Definition HelloWorldSync {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.HelloWorldSync"%go.

Definition HelloWorldCancellable {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.HelloWorldCancellable"%go.

Definition HelloWorldWithTimeout {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.HelloWorldWithTimeout"%go.

Definition DSPExample {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.DSPExample"%go.

Definition fibonacci {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.fibonacci"%go.

Definition fib_consumer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.fib_consumer"%go.

Definition simple_join {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.simple_join"%go.

Definition simple_multi_join {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.simple_multi_join"%go.

Definition select_nb_no_panic {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.select_nb_no_panic"%go.

Definition select_no_double_close {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.select_no_double_close"%go.

Definition exchangePointer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.exchangePointer"%go.

Definition BroadcastExample {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.BroadcastExample"%go.

Definition Web {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.Web"%go.

Definition Image {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.Image"%go.

Definition Video {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.Video"%go.

Definition Google {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.Google"%go.

Definition select_ready_case_no_panic {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.select_ready_case_no_panic"%go.

Definition TestHelloWorldSync {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.TestHelloWorldSync"%go.

Definition TestHelloWorldWithTimeout {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.TestHelloWorldWithTimeout"%go.

Definition TestDSPExample {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.TestDSPExample"%go.

Definition TestFibConsumer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.TestFibConsumer"%go.

Definition TestSelectNbNoPanic {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.TestSelectNbNoPanic"%go.

Definition TestSelectReadyCaseNoPanic {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.TestSelectReadyCaseNoPanic"%go.

Definition mkRequest {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.mkRequest"%go.

Definition ho_worker {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.ho_worker"%go.

Definition HigherOrderExample {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.HigherOrderExample"%go.

Definition load {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.load"%go.

Definition process {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.process"%go.

Definition client {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.client"%go.

Definition server {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.server"%go.

Definition LeakyBufferPipeline {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.LeakyBufferPipeline"%go.

Definition mkStream {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.mkStream"%go.

Definition Async {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.Async"%go.

Definition Serve {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.Serve"%go.

Definition appWrld {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.appWrld"%go.

Definition Client {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.Client"%go.

Definition MapServer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.MapServer"%go.

Definition ClientOld {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.ClientOld"%go.

Definition Muxer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.Muxer"%go.

Definition makeGreeting {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.makeGreeting"%go.

Definition CancellableMapServer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.CancellableMapServer"%go.

Definition CancellableMuxer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.CancellableMuxer"%go.

Definition worker {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.worker"%go.

Definition SearchReplace {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/channel.SearchReplace"%go.

(* go: elimination_stack.go:14:6 *)
Definition NewLockedStackⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (GoAlloc LockedStack (let: "$v0" := ((FuncResolve go.make2 [go.SliceType go.string] #()) #(W64 0)) in
     CompositeLiteral LockedStack (LiteralValue [KeyedElement (Some (KeyField "stack"%go)) (ElementExpression (go.SliceType go.string) "$v0")])))).

(* go: elimination_stack.go:18:23 *)
Definition LockedStack__Pushⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" "value",
    exception_do (let: "s" := (GoAlloc (go.PointerType LockedStack) "s") in
    let: "value" := (GoAlloc go.string "value") in
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (StructFieldRef LockedStack "mu"%go (![go.PointerType LockedStack] "s"))) #());;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.string] (StructFieldRef LockedStack "stack"%go (![go.PointerType LockedStack] "s"))) in
    let: "$a1" := ((let: "$sl0" := (![go.string] "value") in
    CompositeLiteral (go.SliceType go.string) (LiteralValue [KeyedElement None (ElementExpression go.string "$sl0")]))) in
    (FuncResolve go.append [go.SliceType go.string] #()) "$a0" "$a1") in
    do:  ((StructFieldRef LockedStack "stack"%go (![go.PointerType LockedStack] "s")) <-[go.SliceType go.string] "$r0");;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (StructFieldRef LockedStack "mu"%go (![go.PointerType LockedStack] "s"))) #());;;
    return: #()).

(* go: elimination_stack.go:24:23 *)
Definition LockedStack__Popⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" <>,
    exception_do (let: "s" := (GoAlloc (go.PointerType LockedStack) "s") in
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (StructFieldRef LockedStack "mu"%go (![go.PointerType LockedStack] "s"))) #());;;
    (if: Convert go.untyped_bool go.bool ((let: "$a0" := (![go.SliceType go.string] (StructFieldRef LockedStack "stack"%go (![go.PointerType LockedStack] "s"))) in
    (FuncResolve go.len [go.SliceType go.string] #()) "$a0") =⟨go.int⟩ #(W64 0))
    then
      do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (StructFieldRef LockedStack "mu"%go (![go.PointerType LockedStack] "s"))) #());;;
      return: (#""%go, #false)
    else do:  #());;;
    let: "last" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := ((let: "$a0" := (![go.SliceType go.string] (StructFieldRef LockedStack "stack"%go (![go.PointerType LockedStack] "s"))) in
    (FuncResolve go.len [go.SliceType go.string] #()) "$a0") -⟨go.int⟩ #(W64 1)) in
    do:  ("last" <-[go.int] "$r0");;;
    let: "v" := (GoAlloc go.string (GoZeroVal go.string #())) in
    let: "$r0" := (![go.string] (IndexRef (go.SliceType go.string) (![go.SliceType go.string] (StructFieldRef LockedStack "stack"%go (![go.PointerType LockedStack] "s")), ![go.int] "last"))) in
    do:  ("v" <-[go.string] "$r0");;;
    let: "$r0" := (let: "$s" := (![go.SliceType go.string] (StructFieldRef LockedStack "stack"%go (![go.PointerType LockedStack] "s"))) in
    Slice (go.SliceType go.string) ("$s", #(W64 0), ![go.int] "last")) in
    do:  ((StructFieldRef LockedStack "stack"%go (![go.PointerType LockedStack] "s")) <-[go.SliceType go.string] "$r0");;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (StructFieldRef LockedStack "mu"%go (![go.PointerType LockedStack] "s"))) #());;;
    return: (![go.string] "v", #true)).

(* NewEliminationStack constructs a new elimination stack
   using a fresh LockedStack and a small default timeout.

   go: elimination_stack.go:47:6 *)
Definition NewEliminationStackⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (GoAlloc EliminationStack (let: "$v0" := ((FuncResolve NewLockedStack [] #()) #()) in
     let: "$v1" := ((FuncResolve go.make1 [go.ChannelType go.sendrecv go.string] #()) #()) in
     CompositeLiteral EliminationStack (LiteralValue [KeyedElement (Some (KeyField "base"%go)) (ElementExpression (go.PointerType LockedStack) "$v0"); KeyedElement (Some (KeyField "exchanger"%go)) (ElementExpression (go.ChannelType go.sendrecv go.string) "$v1")])))).

(* Push first tries one-shot elimination; on timeout, falls back to the locked stack.

   go: elimination_stack.go:55:28 *)
Definition EliminationStack__Pushⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" "value",
    exception_do (let: "s" := (GoAlloc (go.PointerType EliminationStack) "s") in
    let: "value" := (GoAlloc go.string "value") in
    let: "$v0" := (![go.string] "value") in
    let: "$ch0" := (![go.ChannelType go.sendrecv go.string] (StructFieldRef EliminationStack "exchanger"%go (![go.PointerType EliminationStack] "s"))) in
    let: "$ch1" := (let: "$a0" := timeout in
    (FuncResolve time.After [] #()) "$a0") in
    SelectStmt (SelectStmtClauses None [(CommClause (SendCase go.string "$ch0" "$v0") (return: (#()))); (CommClause (RecvCase time.Time "$ch1") (do:  #()))]);;;
    do:  (let: "$a0" := (![go.string] "value") in
    (MethodResolve (go.PointerType LockedStack) "Push"%go (![go.PointerType LockedStack] (StructFieldRef EliminationStack "base"%go (![go.PointerType EliminationStack] "s")))) "$a0");;;
    return: #()).

(* Pop first tries one-shot elimination; on timeout, falls back to the locked stack.

   go: elimination_stack.go:67:28 *)
Definition EliminationStack__Popⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" <>,
    exception_do (let: "s" := (GoAlloc (go.PointerType EliminationStack) "s") in
    let: "$ch0" := (![go.ChannelType go.sendrecv go.string] (StructFieldRef EliminationStack "exchanger"%go (![go.PointerType EliminationStack] "s"))) in
    let: "$ch1" := (let: "$a0" := timeout in
    (FuncResolve time.After [] #()) "$a0") in
    SelectStmt (SelectStmtClauses None [(CommClause (RecvCase go.string "$ch0") (let: "v" := (GoAlloc go.string (GoZeroVal go.string #())) in
    let: "$r0" := (Fst "$recvVal") in
    do:  ("v" <-[go.string] "$r0");;;
    return: (![go.string] "v", #true))); (CommClause (RecvCase time.Time "$ch1") (do:  #()))]);;;
    let: ("$ret0", "$ret1") := (((MethodResolve (go.PointerType LockedStack) "Pop"%go (![go.PointerType LockedStack] (StructFieldRef EliminationStack "base"%go (![go.PointerType EliminationStack] "s")))) #())) in
    return: ("$ret0", "$ret1")).

(* Fake syscall for demonstration.

   go: examples.go:8:6 *)
Definition sys_hello_worldⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (#"Hello, World!"%go)).

(* go: examples.go:12:6 *)
Definition HelloWorldAsyncⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "ch" := (GoAlloc (go.ChannelType go.sendrecv go.string) (GoZeroVal (go.ChannelType go.sendrecv go.string) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.ChannelType go.sendrecv go.string] #()) #(W64 1)) in
    do:  ("ch" <-[go.ChannelType go.sendrecv go.string] "$r0");;;
    let: "$go" := (λ: <>,
      exception_do (do:  (let: "$chan" := (![go.ChannelType go.sendrecv go.string] "ch") in
      let: "$v" := ((FuncResolve sys_hello_world [] #()) #()) in
      chan.send go.string "$chan" "$v");;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    return: (![go.ChannelType go.sendrecv go.string] "ch")).

(* go: examples.go:20:6 *)
Definition HelloWorldSyncⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (Fst (chan.receive go.string ((FuncResolve HelloWorldAsync [] #()) #())))).

(* Simulates the error/done channel components of Context

   go: examples.go:25:6 *)
Definition HelloWorldCancellableⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "done" "err",
    exception_do (let: "err" := (GoAlloc (go.PointerType go.string) "err") in
    let: "done" := (GoAlloc (go.ChannelType go.sendrecv (go.StructType [

    ])) "done") in
    let: "future" := (GoAlloc (go.ChannelType go.sendrecv go.string) (GoZeroVal (go.ChannelType go.sendrecv go.string) #())) in
    let: "$r0" := ((FuncResolve HelloWorldAsync [] #()) #()) in
    do:  ("future" <-[go.ChannelType go.sendrecv go.string] "$r0");;;
    let: "$ch0" := (![go.ChannelType go.sendrecv go.string] "future") in
    let: "$ch1" := (![go.ChannelType go.sendrecv (go.StructType [

    ])] "done") in
    SelectStmt (SelectStmtClauses None [(CommClause (RecvCase go.string "$ch0") (let: "resolved" := (GoAlloc go.string (GoZeroVal go.string #())) in
    let: "$r0" := (Fst "$recvVal") in
    do:  ("resolved" <-[go.string] "$r0");;;
    return: (![go.string] "resolved"))); (CommClause (RecvCase (go.StructType [

    ]) "$ch1") (return: (![go.string] (![go.PointerType go.string] "err"))))])).

(* Uses cancellation as a timeout mechanism.

   go: examples.go:36:6 *)
Definition HelloWorldWithTimeoutⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "done" := (GoAlloc (go.ChannelType go.sendrecv (go.StructType [

    ])) (GoZeroVal (go.ChannelType go.sendrecv (go.StructType [

    ])) #())) in
    let: "$r0" := ((FuncResolve go.make1 [go.ChannelType go.sendrecv (go.StructType [

     ])] #()) #()) in
    do:  ("done" <-[go.ChannelType go.sendrecv (go.StructType [

    ])] "$r0");;;
    let: "errMsg" := (GoAlloc go.string (GoZeroVal go.string #())) in
    let: "$r0" := #""%go in
    do:  ("errMsg" <-[go.string] "$r0");;;
    let: "$go" := (λ: <>,
      exception_do (do:  (let: "$a0" := (#(W64 10) *⟨time.Duration⟩ time.Millisecond) in
      (FuncResolve time.Sleep [] #()) "$a0");;;
      let: "$r0" := #"operation timed out"%go in
      do:  ("errMsg" <-[go.string] "$r0");;;
      do:  (let: "$a0" := (![go.ChannelType go.sendrecv (go.StructType [

      ])] "done") in
      (FuncResolve go.close [go.ChannelType go.sendrecv (go.StructType [

       ])] #()) "$a0");;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    return: (let: "$a0" := (![go.ChannelType go.sendrecv (go.StructType [

     ])] "done") in
     let: "$a1" := "errMsg" in
     (FuncResolve HelloWorldCancellable [] #()) "$a0" "$a1")).

(* prog3 from Actris 2.0 intro: https://arxiv.org/pdf/2010.15030

   go: examples.go:51:6 *)
Definition DSPExampleⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "c" := (GoAlloc (go.ChannelType go.sendrecv go.any) (GoZeroVal (go.ChannelType go.sendrecv go.any) #())) in
    let: "$r0" := ((FuncResolve go.make1 [go.ChannelType go.sendrecv go.any] #()) #()) in
    do:  ("c" <-[go.ChannelType go.sendrecv go.any] "$r0");;;
    let: "signal" := (GoAlloc (go.ChannelType go.sendrecv go.any) (GoZeroVal (go.ChannelType go.sendrecv go.any) #())) in
    let: "$r0" := ((FuncResolve go.make1 [go.ChannelType go.sendrecv go.any] #()) #()) in
    do:  ("signal" <-[go.ChannelType go.sendrecv go.any] "$r0");;;
    let: "$go" := (λ: <>,
      exception_do (let: "ptr" := (GoAlloc (go.PointerType go.int) (GoZeroVal (go.PointerType go.int) #())) in
      let: "$r0" := (TypeAssert (go.PointerType go.int) (Fst (chan.receive go.any (![go.ChannelType go.sendrecv go.any] "c")))) in
      do:  ("ptr" <-[go.PointerType go.int] "$r0");;;
      let: "$r0" := ((![go.int] (![go.PointerType go.int] "ptr")) +⟨go.int⟩ #(W64 2)) in
      do:  ((![go.PointerType go.int] "ptr") <-[go.int] "$r0");;;
      do:  (let: "$chan" := (![go.ChannelType go.sendrecv go.any] "signal") in
      let: "$v" := (Convert (go.StructType [

      ]) go.any (CompositeLiteral (go.StructType [

      ]) (LiteralValue []))) in
      chan.send go.any "$chan" "$v");;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    let: "val" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := #(W64 40) in
    do:  ("val" <-[go.int] "$r0");;;
    let: "ptr" := (GoAlloc (go.PointerType go.int) (GoZeroVal (go.PointerType go.int) #())) in
    let: "$r0" := "val" in
    do:  ("ptr" <-[go.PointerType go.int] "$r0");;;
    do:  (let: "$chan" := (![go.ChannelType go.sendrecv go.any] "c") in
    let: "$v" := (Convert (go.PointerType go.int) go.any (![go.PointerType go.int] "ptr")) in
    chan.send go.any "$chan" "$v");;;
    do:  (Fst (chan.receive go.any (![go.ChannelType go.sendrecv go.any] "signal")));;;
    return: (![go.int] (![go.PointerType go.int] "ptr"))).

(* https://go.dev/tour/concurrency/4

   go: examples.go:69:6 *)
Definition fibonacciⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "n" "c",
    exception_do (let: "c" := (GoAlloc (go.ChannelType go.sendrecv go.int) "c") in
    let: "n" := (GoAlloc go.int "n") in
    let: "y" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "x" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := #(W64 0) in
    let: "$r1" := #(W64 1) in
    do:  ("x" <-[go.int] "$r0");;;
    do:  ("y" <-[go.int] "$r1");;;
    (let: "i" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.int] "$r0");;;
    (for: (λ: <>, (![go.int] "i") <⟨go.int⟩ (![go.int] "n")); (λ: <>, do:  ("i" <-[go.int] ((![go.int] "i") +⟨go.int⟩ #(W64 1)))) := λ: <>,
      do:  (let: "$chan" := (![go.ChannelType go.sendrecv go.int] "c") in
      let: "$v" := (![go.int] "x") in
      chan.send go.int "$chan" "$v");;;
      let: "$r0" := (![go.int] "y") in
      let: "$r1" := ((![go.int] "x") +⟨go.int⟩ (![go.int] "y")) in
      do:  ("x" <-[go.int] "$r0");;;
      do:  ("y" <-[go.int] "$r1")));;;
    do:  (let: "$a0" := (![go.ChannelType go.sendrecv go.int] "c") in
    (FuncResolve go.close [go.ChannelType go.sendrecv go.int] #()) "$a0");;;
    return: #()).

(* go: examples.go:78:6 *)
Definition fib_consumerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "c" := (GoAlloc (go.ChannelType go.sendrecv go.int) (GoZeroVal (go.ChannelType go.sendrecv go.int) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.ChannelType go.sendrecv go.int] #()) #(W64 10)) in
    do:  ("c" <-[go.ChannelType go.sendrecv go.int] "$r0");;;
    let: "$a0" := (let: "$a0" := (![go.ChannelType go.sendrecv go.int] "c") in
    (FuncResolve go.cap [go.ChannelType go.sendrecv go.int] #()) "$a0") in
    let: "$a1" := (![go.ChannelType go.sendrecv go.int] "c") in
    let: "$go" := (FuncResolve fibonacci [] #()) in
    do:  (Fork ("$go" "$a0" "$a1"));;;
    let: "results" := (GoAlloc (go.SliceType go.int) (GoZeroVal (go.SliceType go.int) #())) in
    let: "$r0" := (CompositeLiteral (go.SliceType go.int) (LiteralValue [])) in
    do:  ("results" <-[go.SliceType go.int] "$r0");;;
    let: "$range" := (![go.ChannelType go.sendrecv go.int] "c") in
    (let: "i" := (GoAlloc go.int (GoZeroVal go.int #())) in
    chan.for_range go.int "$range" (λ: "$key",
      do:  ("i" <-[go.int] "$key");;;
      let: "$r0" := (let: "$a0" := (![go.SliceType go.int] "results") in
      let: "$a1" := ((let: "$sl0" := (![go.int] "i") in
      CompositeLiteral (go.SliceType go.int) (LiteralValue [KeyedElement None (ElementExpression go.int "$sl0")]))) in
      (FuncResolve go.append [go.SliceType go.int] #()) "$a0" "$a1") in
      do:  ("results" <-[go.SliceType go.int] "$r0")));;;
    return: (![go.SliceType go.int] "results")).

(* go: examples.go:89:6 *)
Definition simple_joinⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "ch" := (GoAlloc (go.ChannelType go.sendrecv (go.StructType [

    ])) (GoZeroVal (go.ChannelType go.sendrecv (go.StructType [

    ])) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.ChannelType go.sendrecv (go.StructType [

     ])] #()) #(W64 1)) in
    do:  ("ch" <-[go.ChannelType go.sendrecv (go.StructType [

    ])] "$r0");;;
    let: "message" := (GoAlloc go.string (GoZeroVal go.string #())) in
    let: "$go" := (λ: <>,
      exception_do (let: "$r0" := #"Hello, World!"%go in
      do:  ("message" <-[go.string] "$r0");;;
      do:  (let: "$chan" := (![go.ChannelType go.sendrecv (go.StructType [

      ])] "ch") in
      let: "$v" := (CompositeLiteral (go.StructType [

      ]) (LiteralValue [])) in
      chan.send (go.StructType [

      ]) "$chan" "$v");;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    do:  (Fst (chan.receive (go.StructType [

    ]) (![go.ChannelType go.sendrecv (go.StructType [

    ])] "ch")));;;
    return: (![go.string] "message")).

(* go: examples.go:102:6 *)
Definition simple_multi_joinⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "ch" := (GoAlloc (go.ChannelType go.sendrecv (go.StructType [

    ])) (GoZeroVal (go.ChannelType go.sendrecv (go.StructType [

    ])) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.ChannelType go.sendrecv (go.StructType [

     ])] #()) #(W64 2)) in
    do:  ("ch" <-[go.ChannelType go.sendrecv (go.StructType [

    ])] "$r0");;;
    let: "world" := (GoAlloc go.string (GoZeroVal go.string #())) in
    let: "hello" := (GoAlloc go.string (GoZeroVal go.string #())) in
    let: "$go" := (λ: <>,
      exception_do (let: "$r0" := #"Hello"%go in
      do:  ("hello" <-[go.string] "$r0");;;
      do:  (let: "$chan" := (![go.ChannelType go.sendrecv (go.StructType [

      ])] "ch") in
      let: "$v" := (CompositeLiteral (go.StructType [

      ]) (LiteralValue [])) in
      chan.send (go.StructType [

      ]) "$chan" "$v");;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    let: "$go" := (λ: <>,
      exception_do (let: "$r0" := #"World"%go in
      do:  ("world" <-[go.string] "$r0");;;
      do:  (let: "$chan" := (![go.ChannelType go.sendrecv (go.StructType [

      ])] "ch") in
      let: "$v" := (CompositeLiteral (go.StructType [

      ]) (LiteralValue [])) in
      chan.send (go.StructType [

      ]) "$chan" "$v");;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    do:  (Fst (chan.receive (go.StructType [

    ]) (![go.ChannelType go.sendrecv (go.StructType [

    ])] "ch")));;;
    do:  (Fst (chan.receive (go.StructType [

    ]) (![go.ChannelType go.sendrecv (go.StructType [

    ])] "ch")));;;
    return: (((![go.string] "hello") +⟨go.string⟩ #" "%go) +⟨go.string⟩ (![go.string] "world"))).

(* Show that it isn't possible to have 2 nonblocking ops that match.

   go: examples.go:121:6 *)
Definition select_nb_no_panicⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "ch" := (GoAlloc (go.ChannelType go.sendrecv (go.StructType [

    ])) (GoZeroVal (go.ChannelType go.sendrecv (go.StructType [

    ])) #())) in
    let: "$r0" := ((FuncResolve go.make1 [go.ChannelType go.sendrecv (go.StructType [

     ])] #()) #()) in
    do:  ("ch" <-[go.ChannelType go.sendrecv (go.StructType [

    ])] "$r0");;;
    let: "$go" := (λ: <>,
      exception_do (let: "$ch0" := (![go.ChannelType go.sendrecv (go.StructType [

      ])] "ch") in
      SelectStmt (SelectStmtClauses (Some (do:  #())) [(CommClause (RecvCase (go.StructType [

      ]) "$ch0") (do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"bad"%go) in
      (FuncResolve go.panic [] #()) "$a0")))]);;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    let: "$v0" := (CompositeLiteral (go.StructType [

    ]) (LiteralValue [])) in
    let: "$ch0" := (![go.ChannelType go.sendrecv (go.StructType [

    ])] "ch") in
    SelectStmt (SelectStmtClauses (Some (do:  #())) [(CommClause (SendCase (go.StructType [

    ]) "$ch0" "$v0") (do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"bad"%go) in
    (FuncResolve go.panic [] #()) "$a0")))]);;;
    return: #()).

(* go: examples.go:138:6 *)
Definition select_no_double_closeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc (go.ChannelType go.sendrecv go.int) (GoZeroVal (go.ChannelType go.sendrecv go.int) #())) in
    let: "$r0" := ((FuncResolve go.make1 [go.ChannelType go.sendrecv go.int] #()) #()) in
    do:  ("x" <-[go.ChannelType go.sendrecv go.int] "$r0");;;
    do:  (let: "$a0" := (![go.ChannelType go.sendrecv go.int] "x") in
    (FuncResolve go.close [go.ChannelType go.sendrecv go.int] #()) "$a0");;;
    let: "$ch0" := (![go.ChannelType go.sendrecv go.int] "x") in
    SelectStmt (SelectStmtClauses (Some (do:  (let: "$a0" := (![go.ChannelType go.sendrecv go.int] "x") in
    (FuncResolve go.close [go.ChannelType go.sendrecv go.int] #()) "$a0"))) [(CommClause (RecvCase go.int "$ch0") (do:  #()))]);;;
    return: #()).

(* go: examples.go:148:6 *)
Definition exchangePointerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := #(W64 0) in
    do:  ("x" <-[go.int] "$r0");;;
    let: "y" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := #(W64 0) in
    do:  ("y" <-[go.int] "$r0");;;
    let: "ch" := (GoAlloc (go.ChannelType go.sendrecv (go.StructType [

    ])) (GoZeroVal (go.ChannelType go.sendrecv (go.StructType [

    ])) #())) in
    let: "$r0" := ((FuncResolve go.make1 [go.ChannelType go.sendrecv (go.StructType [

     ])] #()) #()) in
    do:  ("ch" <-[go.ChannelType go.sendrecv (go.StructType [

    ])] "$r0");;;
    let: "$go" := (λ: <>,
      exception_do (let: "$r0" := #(W64 1) in
      do:  ("x" <-[go.int] "$r0");;;
      do:  (let: "$chan" := (![go.ChannelType go.sendrecv (go.StructType [

      ])] "ch") in
      let: "$v" := (CompositeLiteral (go.StructType [

      ]) (LiteralValue [])) in
      chan.send (go.StructType [

      ]) "$chan" "$v");;;
      (if: Convert go.untyped_bool go.bool ((![go.int] "y") ≠⟨go.int⟩ #(W64 2))
      then
        do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"bad"%go) in
        (FuncResolve go.panic [] #()) "$a0")
      else do:  #());;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    let: "$r0" := #(W64 2) in
    do:  ("y" <-[go.int] "$r0");;;
    do:  (Fst (chan.receive (go.StructType [

    ]) (![go.ChannelType go.sendrecv (go.StructType [

    ])] "ch")));;;
    (if: Convert go.untyped_bool go.bool ((![go.int] "x") ≠⟨go.int⟩ #(W64 1))
    then
      do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"bad"%go) in
      (FuncResolve go.panic [] #()) "$a0")
    else do:  #());;;
    return: #()).

(* go: examples.go:168:6 *)
Definition BroadcastExampleⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "done" := (GoAlloc (go.ChannelType go.sendrecv (go.StructType [

    ])) (GoZeroVal (go.ChannelType go.sendrecv (go.StructType [

    ])) #())) in
    let: "$r0" := ((FuncResolve go.make1 [go.ChannelType go.sendrecv (go.StructType [

     ])] #()) #()) in
    do:  ("done" <-[go.ChannelType go.sendrecv (go.StructType [

    ])] "$r0");;;
    let: "result1" := (GoAlloc (go.ChannelType go.sendrecv go.uint64) (GoZeroVal (go.ChannelType go.sendrecv go.uint64) #())) in
    let: "$r0" := ((FuncResolve go.make1 [go.ChannelType go.sendrecv go.uint64] #()) #()) in
    do:  ("result1" <-[go.ChannelType go.sendrecv go.uint64] "$r0");;;
    let: "result2" := (GoAlloc (go.ChannelType go.sendrecv go.uint64) (GoZeroVal (go.ChannelType go.sendrecv go.uint64) #())) in
    let: "$r0" := ((FuncResolve go.make1 [go.ChannelType go.sendrecv go.uint64] #()) #()) in
    do:  ("result2" <-[go.ChannelType go.sendrecv go.uint64] "$r0");;;
    let: "sharedValue" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$go" := (λ: <>,
      exception_do (do:  (Fst (chan.receive (go.StructType [

      ]) (![go.ChannelType go.sendrecv (go.StructType [

      ])] "done")));;;
      let: "val" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: "$r0" := (![go.uint64] "sharedValue") in
      do:  ("val" <-[go.uint64] "$r0");;;
      do:  (let: "$chan" := (![go.ChannelType go.sendrecv go.uint64] "result1") in
      let: "$v" := ((![go.uint64] "val") *⟨go.uint64⟩ #(W64 3)) in
      chan.send go.uint64 "$chan" "$v");;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    let: "$go" := (λ: <>,
      exception_do (do:  (Fst (chan.receive (go.StructType [

      ]) (![go.ChannelType go.sendrecv (go.StructType [

      ])] "done")));;;
      let: "val" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: "$r0" := (![go.uint64] "sharedValue") in
      do:  ("val" <-[go.uint64] "$r0");;;
      do:  (let: "$chan" := (![go.ChannelType go.sendrecv go.uint64] "result2") in
      let: "$v" := ((![go.uint64] "val") *⟨go.uint64⟩ #(W64 5)) in
      chan.send go.uint64 "$chan" "$v");;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    let: "$r0" := #(W64 2) in
    do:  ("sharedValue" <-[go.uint64] "$r0");;;
    do:  (let: "$a0" := (![go.ChannelType go.sendrecv (go.StructType [

    ])] "done") in
    (FuncResolve go.close [go.ChannelType go.sendrecv (go.StructType [

     ])] #()) "$a0");;;
    let: "r1" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (Fst (chan.receive go.uint64 (![go.ChannelType go.sendrecv go.uint64] "result1"))) in
    do:  ("r1" <-[go.uint64] "$r0");;;
    let: "r2" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (Fst (chan.receive go.uint64 (![go.ChannelType go.sendrecv go.uint64] "result2"))) in
    do:  ("r2" <-[go.uint64] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "r1") ≠⟨go.uint64⟩ #(W64 6))
    then
      do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"receiver 1 got wrong value"%go) in
      (FuncResolve go.panic [] #()) "$a0")
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "r2") ≠⟨go.uint64⟩ #(W64 10))
    then
      do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"receiver 2 got wrong value"%go) in
      (FuncResolve go.panic [] #()) "$a0")
    else do:  #());;;
    return: #()).

(* go: examples.go:204:6 *)
Definition Webⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "query",
    exception_do (let: "query" := (GoAlloc go.string "query") in
    return: ((![go.string] "query") +⟨go.string⟩ #".html"%go)).

(* go: examples.go:208:6 *)
Definition Imageⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "query",
    exception_do (let: "query" := (GoAlloc go.string "query") in
    return: ((![go.string] "query") +⟨go.string⟩ #".png"%go)).

(* go: examples.go:212:6 *)
Definition Videoⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "query",
    exception_do (let: "query" := (GoAlloc go.string "query") in
    return: ((![go.string] "query") +⟨go.string⟩ #".mp4"%go)).

(* https://go.dev/talks/2012/concurrency.slide#46

   go: examples.go:217:6 *)
Definition Googleⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "query",
    exception_do (let: "query" := (GoAlloc go.string "query") in
    let: "c" := (GoAlloc (go.ChannelType go.sendrecv go.string) (GoZeroVal (go.ChannelType go.sendrecv go.string) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.ChannelType go.sendrecv go.string] #()) #(W64 3)) in
    do:  ("c" <-[go.ChannelType go.sendrecv go.string] "$r0");;;
    let: "$go" := (λ: <>,
      exception_do (do:  (let: "$chan" := (![go.ChannelType go.sendrecv go.string] "c") in
      let: "$v" := (let: "$a0" := (![go.string] "query") in
      (FuncResolve Web [] #()) "$a0") in
      chan.send go.string "$chan" "$v");;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    let: "$go" := (λ: <>,
      exception_do (do:  (let: "$chan" := (![go.ChannelType go.sendrecv go.string] "c") in
      let: "$v" := (let: "$a0" := (![go.string] "query") in
      (FuncResolve Image [] #()) "$a0") in
      chan.send go.string "$chan" "$v");;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    let: "$go" := (λ: <>,
      exception_do (do:  (let: "$chan" := (![go.ChannelType go.sendrecv go.string] "c") in
      let: "$v" := (let: "$a0" := (![go.string] "query") in
      (FuncResolve Video [] #()) "$a0") in
      chan.send go.string "$chan" "$v");;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    let: "results" := (GoAlloc (go.SliceType go.string) (GoZeroVal (go.SliceType go.string) #())) in
    let: "$r0" := ((FuncResolve go.make3 [go.SliceType go.string] #()) #(W64 0) #(W64 3)) in
    do:  ("results" <-[go.SliceType go.string] "$r0");;;
    (let: "i" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.int] "$r0");;;
    (for: (λ: <>, (![go.int] "i") <⟨go.int⟩ #(W64 3)); (λ: <>, do:  ("i" <-[go.int] ((![go.int] "i") +⟨go.int⟩ #(W64 1)))) := λ: <>,
      let: "r" := (GoAlloc go.string (GoZeroVal go.string #())) in
      let: "$r0" := (Fst (chan.receive go.string (![go.ChannelType go.sendrecv go.string] "c"))) in
      do:  ("r" <-[go.string] "$r0");;;
      let: "$r0" := (let: "$a0" := (![go.SliceType go.string] "results") in
      let: "$a1" := ((let: "$sl0" := (![go.string] "r") in
      CompositeLiteral (go.SliceType go.string) (LiteralValue [KeyedElement None (ElementExpression go.string "$sl0")]))) in
      (FuncResolve go.append [go.SliceType go.string] #()) "$a0" "$a1") in
      do:  ("results" <-[go.SliceType go.string] "$r0")));;;
    return: (![go.SliceType go.string] "results")).

(* Show that a guaranteed to be ready case makes default impossible

   go: examples_unverified.go:6:6 *)
Definition select_ready_case_no_panicⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "ch" := (GoAlloc (go.ChannelType go.sendrecv (go.StructType [

    ])) (GoZeroVal (go.ChannelType go.sendrecv (go.StructType [

    ])) #())) in
    let: "$r0" := ((FuncResolve go.make1 [go.ChannelType go.sendrecv (go.StructType [

     ])] #()) #()) in
    do:  ("ch" <-[go.ChannelType go.sendrecv (go.StructType [

    ])] "$r0");;;
    do:  (let: "$a0" := (![go.ChannelType go.sendrecv (go.StructType [

    ])] "ch") in
    (FuncResolve go.close [go.ChannelType go.sendrecv (go.StructType [

     ])] #()) "$a0");;;
    let: "$ch0" := (![go.ChannelType go.sendrecv (go.StructType [

    ])] "ch") in
    SelectStmt (SelectStmtClauses (Some (do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"Shouldn't be possible!"%go) in
    (FuncResolve go.panic [] #()) "$a0"))) [(CommClause (RecvCase (go.StructType [

    ]) "$ch0") (do:  #()))]);;;
    return: #()).

(* Various tests that should panic when failing, which also means verifying { True } e { True } is
   sufficient since panic can't be verified.

   go: examples_unverified.go:20:6 *)
Definition TestHelloWorldSyncⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "result" := (GoAlloc go.string (GoZeroVal go.string #())) in
    let: "$r0" := ((FuncResolve HelloWorldSync [] #()) #()) in
    do:  ("result" <-[go.string] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.string] "result") ≠⟨go.string⟩ #"Hello, World!"%go)
    then
      do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"incorrect output"%go) in
      (FuncResolve go.panic [] #()) "$a0")
    else do:  #());;;
    return: #()).

(* go: examples_unverified.go:27:6 *)
Definition TestHelloWorldWithTimeoutⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "result" := (GoAlloc go.string (GoZeroVal go.string #())) in
    let: "$r0" := ((FuncResolve HelloWorldWithTimeout [] #()) #()) in
    do:  ("result" <-[go.string] "$r0");;;
    (if: Convert go.untyped_bool go.bool (((![go.string] "result") ≠⟨go.string⟩ #"operation timed out"%go) && ((![go.string] "result") ≠⟨go.string⟩ #"Hello, World!"%go))
    then
      do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"incorrect output"%go) in
      (FuncResolve go.panic [] #()) "$a0")
    else do:  #());;;
    return: #()).

(* go: examples_unverified.go:34:6 *)
Definition TestDSPExampleⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "result" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := ((FuncResolve DSPExample [] #()) #()) in
    do:  ("result" <-[go.int] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.int] "result") ≠⟨go.int⟩ #(W64 42))
    then
      do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"incorrect output"%go) in
      (FuncResolve go.panic [] #()) "$a0")
    else do:  #());;;
    return: #()).

(* go: examples_unverified.go:41:6 *)
Definition TestFibConsumerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "result" := (GoAlloc (go.SliceType go.int) (GoZeroVal (go.SliceType go.int) #())) in
    let: "$r0" := ((FuncResolve fib_consumer [] #()) #()) in
    do:  ("result" <-[go.SliceType go.int] "$r0");;;
    let: "expected" := (GoAlloc (go.SliceType go.int) (GoZeroVal (go.SliceType go.int) #())) in
    let: "$r0" := (let: "$v0" := #(W64 0) in
    let: "$v1" := #(W64 1) in
    let: "$v2" := #(W64 1) in
    let: "$v3" := #(W64 2) in
    let: "$v4" := #(W64 3) in
    let: "$v5" := #(W64 5) in
    let: "$v6" := #(W64 8) in
    let: "$v7" := #(W64 13) in
    let: "$v8" := #(W64 21) in
    let: "$v9" := #(W64 34) in
    CompositeLiteral (go.SliceType go.int) (LiteralValue [KeyedElement None (ElementExpression go.int "$v0"); KeyedElement None (ElementExpression go.int "$v1"); KeyedElement None (ElementExpression go.int "$v2"); KeyedElement None (ElementExpression go.int "$v3"); KeyedElement None (ElementExpression go.int "$v4"); KeyedElement None (ElementExpression go.int "$v5"); KeyedElement None (ElementExpression go.int "$v6"); KeyedElement None (ElementExpression go.int "$v7"); KeyedElement None (ElementExpression go.int "$v8"); KeyedElement None (ElementExpression go.int "$v9")])) in
    do:  ("expected" <-[go.SliceType go.int] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((let: "$a0" := (![go.SliceType go.int] "result") in
    (FuncResolve go.len [go.SliceType go.int] #()) "$a0") ≠⟨go.int⟩ (let: "$a0" := (![go.SliceType go.int] "expected") in
    (FuncResolve go.len [go.SliceType go.int] #()) "$a0"))
    then
      do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"incorrect output"%go) in
      (FuncResolve go.panic [] #()) "$a0")
    else do:  #());;;
    let: "$range" := (![go.SliceType go.int] "expected") in
    (let: "i" := (GoAlloc go.int (GoZeroVal go.int #())) in
    slice.for_range go.int "$range" (λ: "$key" "$value",
      do:  ("i" <-[go.int] "$key");;;
      (if: Convert go.untyped_bool go.bool ((![go.int] (IndexRef (go.SliceType go.int) (![go.SliceType go.int] "result", ![go.int] "i"))) ≠⟨go.int⟩ (![go.int] (IndexRef (go.SliceType go.int) (![go.SliceType go.int] "expected", ![go.int] "i"))))
      then
        do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"incorrect output"%go) in
        (FuncResolve go.panic [] #()) "$a0")
      else do:  #())));;;
    return: #()).

(* go: examples_unverified.go:56:6 *)
Definition TestSelectNbNoPanicⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "iterations" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := #(W64 10000) in
    do:  ("iterations" <-[go.int] "$r0");;;
    (let: "i" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.int] "$r0");;;
    (for: (λ: <>, (![go.int] "i") <⟨go.int⟩ (![go.int] "iterations")); (λ: <>, do:  ("i" <-[go.int] ((![go.int] "i") +⟨go.int⟩ #(W64 1)))) := λ: <>,
      do:  ((FuncResolve select_nb_no_panic [] #()) #());;;
      do:  (let: "$a0" := (#(W64 1) *⟨time.Duration⟩ time.Microsecond) in
      (FuncResolve time.Sleep [] #()) "$a0")));;;
    return: #()).

(* go: examples_unverified.go:65:6 *)
Definition TestSelectReadyCaseNoPanicⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "iterations" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := #(W64 10000) in
    do:  ("iterations" <-[go.int] "$r0");;;
    (let: "i" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.int] "$r0");;;
    (for: (λ: <>, (![go.int] "i") <⟨go.int⟩ (![go.int] "iterations")); (λ: <>, do:  ("i" <-[go.int] ((![go.int] "i") +⟨go.int⟩ #(W64 1)))) := λ: <>,
      do:  ((FuncResolve select_ready_case_no_panic [] #()) #())));;;
    return: #()).

(* go: higher_order.go:8:6 *)
Definition mkRequestⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "f",
    exception_do (let: "f" := (GoAlloc (go.FunctionType (go.Signature [] false [go.string])) "f") in
    return: (let: "$v0" := (![go.FunctionType (go.Signature [] false [go.string])] "f") in
     let: "$v1" := ((FuncResolve go.make2 [go.ChannelType go.sendrecv go.string] #()) #(W64 1)) in
     CompositeLiteral request (LiteralValue [KeyedElement (Some (KeyField "f"%go)) (ElementExpression (go.FunctionType (go.Signature [] false [go.string])) "$v0"); KeyedElement (Some (KeyField "result"%go)) (ElementExpression (go.ChannelType go.sendrecv go.string) "$v1")]))).

(* go: higher_order.go:12:6 *)
Definition ho_workerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "c",
    exception_do (let: "c" := (GoAlloc (go.ChannelType go.sendrecv request) "c") in
    let: "$range" := (![go.ChannelType go.sendrecv request] "c") in
    (let: "r" := (GoAlloc request (GoZeroVal request #())) in
    chan.for_range request "$range" (λ: "$key",
      do:  ("r" <-[request] "$key");;;
      do:  (let: "$chan" := (![go.ChannelType go.sendrecv go.string] (StructFieldRef request "result"%go "r")) in
      let: "$v" := ((![go.FunctionType (go.Signature [] false [go.string])] (StructFieldRef request "f"%go "r")) #()) in
      chan.send go.string "$chan" "$v")));;;
    return: #()).

(* go: higher_order.go:18:6 *)
Definition HigherOrderExampleⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "c" := (GoAlloc (go.ChannelType go.sendrecv request) (GoZeroVal (go.ChannelType go.sendrecv request) #())) in
    let: "$r0" := ((FuncResolve go.make1 [go.ChannelType go.sendrecv request] #()) #()) in
    do:  ("c" <-[go.ChannelType go.sendrecv request] "$r0");;;
    let: "$a0" := (![go.ChannelType go.sendrecv request] "c") in
    let: "$go" := (FuncResolve ho_worker [] #()) in
    do:  (Fork ("$go" "$a0"));;;
    let: "$a0" := (![go.ChannelType go.sendrecv request] "c") in
    let: "$go" := (FuncResolve ho_worker [] #()) in
    do:  (Fork ("$go" "$a0"));;;
    let: "r1" := (GoAlloc request (GoZeroVal request #())) in
    let: "$r0" := (let: "$a0" := (λ: <>,
      exception_do (return: (#"hello world"%go))
      ) in
    (FuncResolve mkRequest [] #()) "$a0") in
    do:  ("r1" <-[request] "$r0");;;
    let: "r2" := (GoAlloc request (GoZeroVal request #())) in
    let: "$r0" := (let: "$a0" := (λ: <>,
      exception_do (return: (#"HELLO"%go))
      ) in
    (FuncResolve mkRequest [] #()) "$a0") in
    do:  ("r2" <-[request] "$r0");;;
    let: "r3" := (GoAlloc request (GoZeroVal request #())) in
    let: "$r0" := (let: "$a0" := (λ: <>,
      exception_do (return: (#"world"%go))
      ) in
    (FuncResolve mkRequest [] #()) "$a0") in
    do:  ("r3" <-[request] "$r0");;;
    do:  (let: "$chan" := (![go.ChannelType go.sendrecv request] "c") in
    let: "$v" := (![request] "r1") in
    chan.send request "$chan" "$v");;;
    do:  (let: "$chan" := (![go.ChannelType go.sendrecv request] "c") in
    let: "$v" := (![request] "r2") in
    chan.send request "$chan" "$v");;;
    do:  (let: "$chan" := (![go.ChannelType go.sendrecv request] "c") in
    let: "$v" := (![request] "r3") in
    chan.send request "$chan" "$v");;;
    let: "responses" := (GoAlloc (go.SliceType go.string) (GoZeroVal (go.SliceType go.string) #())) in
    let: "$r0" := (let: "$v0" := (Fst (chan.receive go.string (![go.ChannelType go.sendrecv go.string] (StructFieldRef request "result"%go "r1")))) in
    let: "$v1" := (Fst (chan.receive go.string (![go.ChannelType go.sendrecv go.string] (StructFieldRef request "result"%go "r2")))) in
    let: "$v2" := (Fst (chan.receive go.string (![go.ChannelType go.sendrecv go.string] (StructFieldRef request "result"%go "r3")))) in
    CompositeLiteral (go.SliceType go.string) (LiteralValue [KeyedElement None (ElementExpression go.string "$v0"); KeyedElement None (ElementExpression go.string "$v1"); KeyedElement None (ElementExpression go.string "$v2")])) in
    do:  ("responses" <-[go.SliceType go.string] "$r0");;;
    return: (![go.SliceType go.string] "responses")).

(* load writes the next letter into the buffer.

   go: leaky_buffer.go:9:6 *)
Definition loadⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "b" "letter",
    exception_do (let: "letter" := (GoAlloc go.string "letter") in
    let: "b" := (GoAlloc (go.PointerType (go.SliceType go.byte)) "b") in
    let: "$r0" := (Convert go.string (go.SliceType go.byte) (![go.string] "letter")) in
    do:  ((![go.PointerType (go.SliceType go.byte)] "b") <-[go.SliceType go.byte] "$r0");;;
    return: #()).

(* process consumes the buffer and appends it to the output.

   go: leaky_buffer.go:14:6 *)
Definition processⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "b" "output",
    exception_do (let: "output" := (GoAlloc (go.PointerType go.string) "output") in
    let: "b" := (GoAlloc (go.PointerType (go.SliceType go.byte)) "b") in
    do:  ((![go.PointerType go.string] "output") <-[go.string] ((![go.string] (![go.PointerType go.string] "output")) +⟨go.string⟩ (let: "$a0" := (Convert (go.SliceType go.byte) go.string (![go.SliceType go.byte] (![go.PointerType (go.SliceType go.byte)] "b"))) in
    (FuncResolve strings.ToUpper [] #()) "$a0")));;;
    return: #()).

(* go: leaky_buffer.go:18:6 *)
Definition clientⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "input" "freeList" "serverChan",
    exception_do (let: "serverChan" := (GoAlloc (go.ChannelType go.sendrecv (go.SliceType go.byte)) "serverChan") in
    let: "freeList" := (GoAlloc (go.ChannelType go.sendrecv (go.SliceType go.byte)) "freeList") in
    let: "input" := (GoAlloc (go.SliceType go.string) "input") in
    let: "$range" := (![go.SliceType go.string] "input") in
    (let: "letter" := (GoAlloc go.string (GoZeroVal go.string #())) in
    slice.for_range go.string "$range" (λ: "$key" "$value",
      do:  ("letter" <-[go.string] "$value");;;
      do:  "$key";;;
      let: "b" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
      let: "$ch0" := (![go.ChannelType go.sendrecv (go.SliceType go.byte)] "freeList") in
      SelectStmt (SelectStmtClauses (Some (let: "$r0" := (let: "$v0" := #(W8 0) in
      CompositeLiteral (go.SliceType go.byte) (LiteralValue [KeyedElement None (ElementExpression go.byte "$v0")])) in
      do:  ("b" <-[go.SliceType go.byte] "$r0"))) [(CommClause (RecvCase (go.SliceType go.byte) "$ch0") (let: "$r0" := (Fst "$recvVal") in
      do:  ("b" <-[go.SliceType go.byte] "$r0");;;
      do:  #()))]);;;
      do:  (let: "$a0" := "b" in
      let: "$a1" := (![go.string] "letter") in
      (FuncResolve load [] #()) "$a0" "$a1");;;
      do:  (let: "$chan" := (![go.ChannelType go.sendrecv (go.SliceType go.byte)] "serverChan") in
      let: "$v" := (![go.SliceType go.byte] "b") in
      chan.send (go.SliceType go.byte) "$chan" "$v")));;;
    do:  (let: "$a0" := (![go.ChannelType go.sendrecv (go.SliceType go.byte)] "serverChan") in
    (FuncResolve go.close [go.ChannelType go.sendrecv (go.SliceType go.byte)] #()) "$a0");;;
    return: #()).

(* go: leaky_buffer.go:39:6 *)
Definition serverⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "output" "freeList" "serverChan" "done",
    exception_do (let: "done" := (GoAlloc (go.ChannelType go.sendrecv (go.StructType [

    ])) "done") in
    let: "serverChan" := (GoAlloc (go.ChannelType go.sendrecv (go.SliceType go.byte)) "serverChan") in
    let: "freeList" := (GoAlloc (go.ChannelType go.sendrecv (go.SliceType go.byte)) "freeList") in
    let: "output" := (GoAlloc (go.PointerType go.string) "output") in
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
      let: "b" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
      let: ("$ret0", "$ret1") := (chan.receive (go.SliceType go.byte) (![go.ChannelType go.sendrecv (go.SliceType go.byte)] "serverChan")) in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("b" <-[go.SliceType go.byte] "$r0");;;
      do:  ("ok" <-[go.bool] "$r1");;;
      (if: (⟨go.bool⟩! (![go.bool] "ok"))
      then
        do:  (let: "$chan" := (![go.ChannelType go.sendrecv (go.StructType [

        ])] "done") in
        let: "$v" := (CompositeLiteral (go.StructType [

        ]) (LiteralValue [])) in
        chan.send (go.StructType [

        ]) "$chan" "$v");;;
        return: (#())
      else do:  #());;;
      do:  (let: "$a0" := "b" in
      let: "$a1" := (![go.PointerType go.string] "output") in
      (FuncResolve process [] #()) "$a0" "$a1");;;
      let: "$v0" := (![go.SliceType go.byte] "b") in
      let: "$ch0" := (![go.ChannelType go.sendrecv (go.SliceType go.byte)] "freeList") in
      SelectStmt (SelectStmtClauses (Some (do:  #())) [(CommClause (SendCase (go.SliceType go.byte) "$ch0" "$v0") (do:  #()))]));;;
    return: #()).

(* go: leaky_buffer.go:61:6 *)
Definition LeakyBufferPipelineⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "freeList" := (GoAlloc (go.ChannelType go.sendrecv (go.SliceType go.byte)) (GoZeroVal (go.ChannelType go.sendrecv (go.SliceType go.byte)) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.ChannelType go.sendrecv (go.SliceType go.byte)] #()) #(W64 5)) in
    do:  ("freeList" <-[go.ChannelType go.sendrecv (go.SliceType go.byte)] "$r0");;;
    let: "serverChan" := (GoAlloc (go.ChannelType go.sendrecv (go.SliceType go.byte)) (GoZeroVal (go.ChannelType go.sendrecv (go.SliceType go.byte)) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.ChannelType go.sendrecv (go.SliceType go.byte)] #()) #(W64 0)) in
    do:  ("serverChan" <-[go.ChannelType go.sendrecv (go.SliceType go.byte)] "$r0");;;
    let: "done" := (GoAlloc (go.ChannelType go.sendrecv (go.StructType [

    ])) (GoZeroVal (go.ChannelType go.sendrecv (go.StructType [

    ])) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.ChannelType go.sendrecv (go.StructType [

     ])] #()) #(W64 0)) in
    do:  ("done" <-[go.ChannelType go.sendrecv (go.StructType [

    ])] "$r0");;;
    let: "output" := (GoAlloc go.string (GoZeroVal go.string #())) in
    let: "$r0" := #""%go in
    do:  ("output" <-[go.string] "$r0");;;
    let: "$a0" := "output" in
    let: "$a1" := (![go.ChannelType go.sendrecv (go.SliceType go.byte)] "freeList") in
    let: "$a2" := (![go.ChannelType go.sendrecv (go.SliceType go.byte)] "serverChan") in
    let: "$a3" := (![go.ChannelType go.sendrecv (go.StructType [

    ])] "done") in
    let: "$go" := (FuncResolve server [] #()) in
    do:  (Fork ("$go" "$a0" "$a1" "$a2" "$a3"));;;
    do:  (let: "$a0" := (let: "$v0" := #"h"%go in
    let: "$v1" := #"e"%go in
    let: "$v2" := #"l"%go in
    let: "$v3" := #"l"%go in
    let: "$v4" := #"o"%go in
    let: "$v5" := #","%go in
    let: "$v6" := #" "%go in
    let: "$v7" := #"w"%go in
    let: "$v8" := #"o"%go in
    let: "$v9" := #"r"%go in
    let: "$v10" := #"l"%go in
    let: "$v11" := #"d"%go in
    CompositeLiteral (go.SliceType go.string) (LiteralValue [KeyedElement None (ElementExpression go.string "$v0"); KeyedElement None (ElementExpression go.string "$v1"); KeyedElement None (ElementExpression go.string "$v2"); KeyedElement None (ElementExpression go.string "$v3"); KeyedElement None (ElementExpression go.string "$v4"); KeyedElement None (ElementExpression go.string "$v5"); KeyedElement None (ElementExpression go.string "$v6"); KeyedElement None (ElementExpression go.string "$v7"); KeyedElement None (ElementExpression go.string "$v8"); KeyedElement None (ElementExpression go.string "$v9"); KeyedElement None (ElementExpression go.string "$v10"); KeyedElement None (ElementExpression go.string "$v11")])) in
    let: "$a1" := (![go.ChannelType go.sendrecv (go.SliceType go.byte)] "freeList") in
    let: "$a2" := (![go.ChannelType go.sendrecv (go.SliceType go.byte)] "serverChan") in
    (FuncResolve client [] #()) "$a0" "$a1" "$a2");;;
    do:  (Fst (chan.receive (go.StructType [

    ]) (![go.ChannelType go.sendrecv (go.StructType [

    ])] "done")));;;
    (if: Convert go.untyped_bool go.bool ((![go.string] "output") ≠⟨go.string⟩ #"HELLO, WORLD"%go)
    then
      do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"incorrect output"%go) in
      (FuncResolve go.panic [] #()) "$a0")
    else do:  #());;;
    return: #()).

(* go: muxer.go:14:6 *)
Definition mkStreamⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "f",
    exception_do (let: "f" := (GoAlloc (go.FunctionType (go.Signature [go.string] false [go.string])) "f") in
    return: (let: "$v0" := ((FuncResolve go.make1 [go.ChannelType go.sendrecv go.string] #()) #()) in
     let: "$v1" := ((FuncResolve go.make1 [go.ChannelType go.sendrecv go.string] #()) #()) in
     let: "$v2" := (![go.FunctionType (go.Signature [go.string] false [go.string])] "f") in
     CompositeLiteral streamold (LiteralValue [KeyedElement None (ElementExpression (go.ChannelType go.sendrecv go.string) "$v0"); KeyedElement None (ElementExpression (go.ChannelType go.sendrecv go.string) "$v1"); KeyedElement None (ElementExpression (go.FunctionType (go.Signature [go.string] false [go.string])) "$v2")]))).

(* go: muxer.go:18:6 *)
Definition Asyncⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "f",
    exception_do (let: "f" := (GoAlloc (go.FunctionType (go.Signature [] false [go.string])) "f") in
    let: "ch" := (GoAlloc (go.ChannelType go.sendrecv go.string) (GoZeroVal (go.ChannelType go.sendrecv go.string) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.ChannelType go.sendrecv go.string] #()) #(W64 1)) in
    do:  ("ch" <-[go.ChannelType go.sendrecv go.string] "$r0");;;
    let: "$go" := (λ: <>,
      exception_do (do:  (let: "$chan" := (![go.ChannelType go.sendrecv go.string] "ch") in
      let: "$v" := ((![go.FunctionType (go.Signature [] false [go.string])] "f") #()) in
      chan.send go.string "$chan" "$v");;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    return: (![go.ChannelType go.sendrecv go.string] "ch")).

(* go: muxer.go:26:6 *)
Definition Serveⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "f",
    exception_do (let: "f" := (GoAlloc (go.FunctionType (go.Signature [go.string] false [go.string])) "f") in
    let: "s" := (GoAlloc stream (GoZeroVal stream #())) in
    let: "$r0" := (let: "$v0" := ((FuncResolve go.make1 [go.ChannelType go.sendrecv go.string] #()) #()) in
    let: "$v1" := ((FuncResolve go.make1 [go.ChannelType go.sendrecv go.string] #()) #()) in
    CompositeLiteral stream (LiteralValue [KeyedElement (Some (KeyField "req"%go)) (ElementExpression (go.ChannelType go.sendrecv go.string) "$v0"); KeyedElement (Some (KeyField "res"%go)) (ElementExpression (go.ChannelType go.sendrecv go.string) "$v1")])) in
    do:  ("s" <-[stream] "$r0");;;
    let: "$go" := (λ: <>,
      exception_do ((for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
        do:  (let: "$chan" := (![go.ChannelType go.sendrecv go.string] (StructFieldRef stream "res"%go "s")) in
        let: "$v" := (let: "$a0" := (Fst (chan.receive go.string (![go.ChannelType go.sendrecv go.string] (StructFieldRef stream "req"%go "s")))) in
        (![go.FunctionType (go.Signature [go.string] false [go.string])] "f") "$a0") in
        chan.send go.string "$chan" "$v"));;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    return: (![stream] "s")).

(* go: muxer.go:39:6 *)
Definition appWrldⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s",
    exception_do (let: "s" := (GoAlloc go.string "s") in
    return: ((![go.string] "s") +⟨go.string⟩ #", World!"%go)).

(* go: muxer.go:43:6 *)
Definition Clientⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "hw" := (GoAlloc stream (GoZeroVal stream #())) in
    let: "$r0" := (let: "$a0" := (FuncResolve appWrld [] #()) in
    (FuncResolve Serve [] #()) "$a0") in
    do:  ("hw" <-[stream] "$r0");;;
    do:  (let: "$chan" := (![go.ChannelType go.sendrecv go.string] (StructFieldRef stream "req"%go "hw")) in
    let: "$v" := #"Hello"%go in
    chan.send go.string "$chan" "$v");;;
    return: (Fst (chan.receive go.string (![go.ChannelType go.sendrecv go.string] (StructFieldRef stream "res"%go "hw"))))).

(* go: muxer.go:49:6 *)
Definition MapServerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s",
    exception_do (let: "s" := (GoAlloc streamold "s") in
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "in" := (GoAlloc go.string (GoZeroVal go.string #())) in
      let: "$r0" := (Fst (chan.receive go.string (![go.ChannelType go.sendrecv go.string] (StructFieldRef streamold "req"%go "s")))) in
      do:  ("in" <-[go.string] "$r0");;;
      do:  (let: "$chan" := (![go.ChannelType go.sendrecv go.string] (StructFieldRef streamold "res"%go "s")) in
      let: "$v" := (let: "$a0" := (![go.string] "in") in
      (![go.FunctionType (go.Signature [go.string] false [go.string])] (StructFieldRef streamold "f"%go "s")) "$a0") in
      chan.send go.string "$chan" "$v"));;;
    return: #()).

(* go: muxer.go:56:6 *)
Definition ClientOldⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "comma" := (GoAlloc streamold (GoZeroVal streamold #())) in
    let: "$r0" := (let: "$a0" := (λ: "s",
      exception_do (let: "s" := (GoAlloc go.string "s") in
      return: ((![go.string] "s") +⟨go.string⟩ #","%go))
      ) in
    (FuncResolve mkStream [] #()) "$a0") in
    do:  ("comma" <-[streamold] "$r0");;;
    let: "exclaim" := (GoAlloc streamold (GoZeroVal streamold #())) in
    let: "$r0" := (let: "$a0" := (λ: "s",
      exception_do (let: "s" := (GoAlloc go.string "s") in
      return: ((![go.string] "s") +⟨go.string⟩ #"!"%go))
      ) in
    (FuncResolve mkStream [] #()) "$a0") in
    do:  ("exclaim" <-[streamold] "$r0");;;
    let: "$a0" := (![streamold] "comma") in
    let: "$go" := (FuncResolve MapServer [] #()) in
    do:  (Fork ("$go" "$a0"));;;
    let: "$a0" := (![streamold] "exclaim") in
    let: "$go" := (FuncResolve MapServer [] #()) in
    do:  (Fork ("$go" "$a0"));;;
    do:  (let: "$chan" := (![go.ChannelType go.sendrecv go.string] (StructFieldRef streamold "req"%go "comma")) in
    let: "$v" := #"Hello"%go in
    chan.send go.string "$chan" "$v");;;
    do:  (let: "$chan" := (![go.ChannelType go.sendrecv go.string] (StructFieldRef streamold "req"%go "exclaim")) in
    let: "$v" := #"World"%go in
    chan.send go.string "$chan" "$v");;;
    return: (((Fst (chan.receive go.string (![go.ChannelType go.sendrecv go.string] (StructFieldRef streamold "res"%go "comma")))) +⟨go.string⟩ #" "%go) +⟨go.string⟩ (Fst (chan.receive go.string (![go.ChannelType go.sendrecv go.string] (StructFieldRef streamold "res"%go "exclaim")))))).

(* go: muxer.go:71:6 *)
Definition Muxerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "c",
    exception_do (let: "c" := (GoAlloc (go.ChannelType go.sendrecv streamold) "c") in
    let: "$range" := (![go.ChannelType go.sendrecv streamold] "c") in
    (let: "s" := (GoAlloc streamold (GoZeroVal streamold #())) in
    chan.for_range streamold "$range" (λ: "$key",
      do:  ("s" <-[streamold] "$key");;;
      let: "$a0" := (![streamold] "s") in
      let: "$go" := (FuncResolve MapServer [] #()) in
      do:  (Fork ("$go" "$a0"))));;;
    return: #()).

(* go: muxer.go:77:6 *)
Definition makeGreetingⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "mux" := (GoAlloc (go.ChannelType go.sendrecv streamold) (GoZeroVal (go.ChannelType go.sendrecv streamold) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.ChannelType go.sendrecv streamold] #()) #(W64 2)) in
    do:  ("mux" <-[go.ChannelType go.sendrecv streamold] "$r0");;;
    let: "$a0" := (![go.ChannelType go.sendrecv streamold] "mux") in
    let: "$go" := (FuncResolve Muxer [] #()) in
    do:  (Fork ("$go" "$a0"));;;
    let: "comma" := (GoAlloc streamold (GoZeroVal streamold #())) in
    let: "$r0" := (let: "$a0" := (λ: "s",
      exception_do (let: "s" := (GoAlloc go.string "s") in
      return: ((![go.string] "s") +⟨go.string⟩ #","%go))
      ) in
    (FuncResolve mkStream [] #()) "$a0") in
    do:  ("comma" <-[streamold] "$r0");;;
    let: "exclaim" := (GoAlloc streamold (GoZeroVal streamold #())) in
    let: "$r0" := (let: "$a0" := (λ: "s",
      exception_do (let: "s" := (GoAlloc go.string "s") in
      return: ((![go.string] "s") +⟨go.string⟩ #"!"%go))
      ) in
    (FuncResolve mkStream [] #()) "$a0") in
    do:  ("exclaim" <-[streamold] "$r0");;;
    do:  (let: "$chan" := (![go.ChannelType go.sendrecv streamold] "mux") in
    let: "$v" := (![streamold] "comma") in
    chan.send streamold "$chan" "$v");;;
    do:  (let: "$chan" := (![go.ChannelType go.sendrecv streamold] "mux") in
    let: "$v" := (![streamold] "exclaim") in
    chan.send streamold "$chan" "$v");;;
    do:  (let: "$chan" := (![go.ChannelType go.sendrecv go.string] (StructFieldRef streamold "req"%go "comma")) in
    let: "$v" := #"Hello"%go in
    chan.send go.string "$chan" "$v");;;
    do:  (let: "$chan" := (![go.ChannelType go.sendrecv go.string] (StructFieldRef streamold "req"%go "exclaim")) in
    let: "$v" := #"World"%go in
    chan.send go.string "$chan" "$v");;;
    return: (((Fst (chan.receive go.string (![go.ChannelType go.sendrecv go.string] (StructFieldRef streamold "res"%go "comma")))) +⟨go.string⟩ #" "%go) +⟨go.string⟩ (Fst (chan.receive go.string (![go.ChannelType go.sendrecv go.string] (StructFieldRef streamold "res"%go "exclaim")))))).

(* go: muxer_unverified.go:3:6 *)
Definition CancellableMapServerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" "done",
    exception_do (let: "done" := (GoAlloc (go.ChannelType go.sendrecv (go.StructType [

    ])) "done") in
    let: "s" := (GoAlloc streamold "s") in
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "$ch0" := (![go.ChannelType go.sendrecv go.string] (StructFieldRef streamold "req"%go "s")) in
      let: "$ch1" := (![go.ChannelType go.sendrecv (go.StructType [

      ])] "done") in
      SelectStmt (SelectStmtClauses None [(CommClause (RecvCase go.string "$ch0") (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
      let: "in" := (GoAlloc go.string (GoZeroVal go.string #())) in
      let: ("$ret0", "$ret1") := "$recvVal" in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("in" <-[go.string] "$r0");;;
      do:  ("ok" <-[go.bool] "$r1");;;
      (if: (⟨go.bool⟩! (![go.bool] "ok"))
      then return: (#())
      else do:  #());;;
      do:  (let: "$chan" := (![go.ChannelType go.sendrecv go.string] (StructFieldRef streamold "res"%go "s")) in
      let: "$v" := (let: "$a0" := (![go.string] "in") in
      (![go.FunctionType (go.Signature [go.string] false [go.string])] (StructFieldRef streamold "f"%go "s")) "$a0") in
      chan.send go.string "$chan" "$v"))); (CommClause (RecvCase (go.StructType [

      ]) "$ch1") (return: (#())))]));;;
    return: #()).

(* 4. CancellableMuxer - muxer with cancellation

   go: muxer_unverified.go:18:6 *)
Definition CancellableMuxerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "c" "done" "errMsg",
    exception_do (let: "errMsg" := (GoAlloc (go.PointerType go.string) "errMsg") in
    let: "done" := (GoAlloc (go.ChannelType go.sendrecv (go.StructType [

    ])) "done") in
    let: "c" := (GoAlloc (go.ChannelType go.sendrecv streamold) "c") in
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "$ch0" := (![go.ChannelType go.sendrecv streamold] "c") in
      let: "$ch1" := (![go.ChannelType go.sendrecv (go.StructType [

      ])] "done") in
      SelectStmt (SelectStmtClauses None [(CommClause (RecvCase streamold "$ch0") (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
      let: "s" := (GoAlloc streamold (GoZeroVal streamold #())) in
      let: ("$ret0", "$ret1") := "$recvVal" in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("s" <-[streamold] "$r0");;;
      do:  ("ok" <-[go.bool] "$r1");;;
      (if: (⟨go.bool⟩! (![go.bool] "ok"))
      then return: (#"serviced all requests"%go)
      else do:  #());;;
      let: "$a0" := (![streamold] "s") in
      let: "$a1" := (![go.ChannelType go.sendrecv (go.StructType [

      ])] "done") in
      let: "$go" := (FuncResolve CancellableMapServer [] #()) in
      do:  (Fork ("$go" "$a0" "$a1")))); (CommClause (RecvCase (go.StructType [

      ]) "$ch1") (return: (![go.string] (![go.PointerType go.string] "errMsg"))))]))).

(* go: parallel_search_replace.go:13:6 *)
Definition workerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "c" "wg" "x" "y",
    exception_do (let: "y" := (GoAlloc go.int "y") in
    let: "x" := (GoAlloc go.int "x") in
    let: "wg" := (GoAlloc (go.PointerType sync.WaitGroup) "wg") in
    let: "c" := (GoAlloc (go.ChannelType go.recvonly (go.SliceType go.int)) "c") in
    (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "s" := (GoAlloc (go.SliceType go.int) (GoZeroVal (go.SliceType go.int) #())) in
    let: ("$ret0", "$ret1") := (chan.receive (go.SliceType go.int) (![go.ChannelType go.recvonly (go.SliceType go.int)] "c")) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("s" <-[go.SliceType go.int] "$r0");;;
    do:  ("ok" <-[go.bool] "$r1");;;
    (for: (λ: <>, ![go.bool] "ok"); (λ: <>, let: ("$ret0", "$ret1") := (chan.receive (go.SliceType go.int) (![go.ChannelType go.recvonly (go.SliceType go.int)] "c")) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("s" <-[go.SliceType go.int] "$r0");;;
    do:  ("ok" <-[go.bool] "$r1")) := λ: <>,
      (let: "i" := (GoAlloc go.int (GoZeroVal go.int #())) in
      let: "$r0" := #(W64 0) in
      do:  ("i" <-[go.int] "$r0");;;
      (for: (λ: <>, (![go.int] "i") ≠⟨go.int⟩ (let: "$a0" := (![go.SliceType go.int] "s") in
      (FuncResolve go.len [go.SliceType go.int] #()) "$a0")); (λ: <>, do:  ("i" <-[go.int] ((![go.int] "i") +⟨go.int⟩ #(W64 1)))) := λ: <>,
        (if: Convert go.untyped_bool go.bool ((![go.int] (IndexRef (go.SliceType go.int) (![go.SliceType go.int] "s", ![go.int] "i"))) =⟨go.int⟩ (![go.int] "x"))
        then
          let: "$r0" := (![go.int] "y") in
          do:  ((IndexRef (go.SliceType go.int) (![go.SliceType go.int] "s", ![go.int] "i")) <-[go.int] "$r0")
        else do:  #())));;;
      do:  ((MethodResolve (go.PointerType sync.WaitGroup) "Done"%go (![go.PointerType sync.WaitGroup] "wg")) #())));;;
    return: #()).

(* go: parallel_search_replace.go:24:6 *)
Definition SearchReplaceⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" "x" "y",
    exception_do (let: "y" := (GoAlloc go.int "y") in
    let: "x" := (GoAlloc go.int "x") in
    let: "s" := (GoAlloc (go.SliceType go.int) "s") in
    (if: Convert go.untyped_bool go.bool ((let: "$a0" := (![go.SliceType go.int] "s") in
    (FuncResolve go.len [go.SliceType go.int] #()) "$a0") =⟨go.int⟩ #(W64 0))
    then return: (#())
    else do:  #());;;
    let: "workers" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := #(W64 8) in
    do:  ("workers" <-[go.int] "$r0");;;
    let: "workRange" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := #(W64 1000) in
    do:  ("workRange" <-[go.int] "$r0");;;
    let: "c" := (GoAlloc (go.ChannelType go.sendrecv (go.SliceType go.int)) (GoZeroVal (go.ChannelType go.sendrecv (go.SliceType go.int)) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.ChannelType go.sendrecv (go.SliceType go.int)] #()) #(W64 4)) in
    do:  ("c" <-[go.ChannelType go.sendrecv (go.SliceType go.int)] "$r0");;;
    let: "wg" := (GoAlloc sync.WaitGroup (GoZeroVal sync.WaitGroup #())) in
    (let: "i" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.int] "$r0");;;
    (for: (λ: <>, (![go.int] "i") ≠⟨go.int⟩ (![go.int] "workers")); (λ: <>, do:  ("i" <-[go.int] ((![go.int] "i") +⟨go.int⟩ #(W64 1)))) := λ: <>,
      let: "$a0" := (Convert (go.ChannelType go.sendrecv (go.SliceType go.int)) (go.ChannelType go.recvonly (go.SliceType go.int)) (![go.ChannelType go.sendrecv (go.SliceType go.int)] "c")) in
      let: "$a1" := "wg" in
      let: "$a2" := (![go.int] "x") in
      let: "$a3" := (![go.int] "y") in
      let: "$go" := (FuncResolve worker [] #()) in
      do:  (Fork ("$go" "$a0" "$a1" "$a2" "$a3"))));;;
    (let: "offset" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := #(W64 0) in
    do:  ("offset" <-[go.int] "$r0");;;
    (for: (λ: <>, (![go.int] "offset") ≠⟨go.int⟩ (let: "$a0" := (![go.SliceType go.int] "s") in
    (FuncResolve go.len [go.SliceType go.int] #()) "$a0")); (λ: <>, #()) := λ: <>,
      let: "nextOffset" := (GoAlloc go.int (GoZeroVal go.int #())) in
      let: "$r0" := ((![go.int] "offset") +⟨go.int⟩ (![go.int] "workRange")) in
      do:  ("nextOffset" <-[go.int] "$r0");;;
      (if: Convert go.untyped_bool go.bool ((![go.int] "nextOffset") >⟨go.int⟩ (let: "$a0" := (![go.SliceType go.int] "s") in
      (FuncResolve go.len [go.SliceType go.int] #()) "$a0"))
      then
        let: "$r0" := (let: "$a0" := (![go.SliceType go.int] "s") in
        (FuncResolve go.len [go.SliceType go.int] #()) "$a0") in
        do:  ("nextOffset" <-[go.int] "$r0")
      else do:  #());;;
      let: "section" := (GoAlloc (go.SliceType go.int) (GoZeroVal (go.SliceType go.int) #())) in
      let: "$r0" := (let: "$s" := (![go.SliceType go.int] "s") in
      Slice (go.SliceType go.int) ("$s", ![go.int] "offset", ![go.int] "nextOffset")) in
      do:  ("section" <-[go.SliceType go.int] "$r0");;;
      do:  (let: "$a0" := #(W64 1) in
      (MethodResolve (go.PointerType sync.WaitGroup) "Add"%go "wg") "$a0");;;
      do:  (let: "$chan" := (![go.ChannelType go.sendrecv (go.SliceType go.int)] "c") in
      let: "$v" := (![go.SliceType go.int] "section") in
      chan.send (go.SliceType go.int) "$chan" "$v");;;
      let: "$r0" := (![go.int] "nextOffset") in
      do:  ("offset" <-[go.int] "$r0")));;;
    do:  ((MethodResolve (go.PointerType sync.WaitGroup) "Wait"%go "wg") #());;;
    return: #()).

#[global] Instance info' : PkgInfo pkg_id.chan_spec_raw_examples :=
{|
  pkg_imported_pkgs := [code.sync.pkg_id.sync; code.time.pkg_id.time; code.strings.pkg_id.strings]
|}.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init pkg_id.chan_spec_raw_examples (λ: <>,
      exception_do (do:  (strings.initialize' #());;;
      do:  (time.initialize' #());;;
      do:  (sync.initialize' #()))
      ).

Module LockedStack.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  mu' : sync.Mutex.t;
  stack' : slice.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End LockedStack.

Definition LockedStack'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "mu"%go sync.Mutex);
  (go.FieldDecl "stack"%go (go.SliceType go.string))
].
Program Definition LockedStack'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (LockedStack'fds_unsealed).
Global Instance equals_unfold_LockedStack {ext : ffi_syntax} {go_gctx : GoGlobalContext} : LockedStack'fds =→ LockedStack'fds_unsealed.
Proof. rewrite /LockedStack'fds seal_eq //. Qed.

Definition LockedStackⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (LockedStack'fds).

Class LockedStack_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] LockedStack_type_repr  :: go.TypeReprUnderlying LockedStackⁱᵐᵖˡ LockedStack.t;
  #[global] LockedStack_underlying :: (LockedStack) <u (LockedStackⁱᵐᵖˡ);
  #[global] LockedStack_get_mu (x : LockedStack.t) :: ⟦StructFieldGet (LockedStackⁱᵐᵖˡ) "mu", #x⟧ ⤳[under] #x.(LockedStack.mu');
  #[global] LockedStack_set_mu (x : LockedStack.t) y :: ⟦StructFieldSet (LockedStackⁱᵐᵖˡ) "mu", (#x, #y)⟧ ⤳[under] #(x <|LockedStack.mu' := y|>);
  #[global] LockedStack_get_stack (x : LockedStack.t) :: ⟦StructFieldGet (LockedStackⁱᵐᵖˡ) "stack", #x⟧ ⤳[under] #x.(LockedStack.stack');
  #[global] LockedStack_set_stack (x : LockedStack.t) y :: ⟦StructFieldSet (LockedStackⁱᵐᵖˡ) "stack", (#x, #y)⟧ ⤳[under] #(x <|LockedStack.stack' := y|>);
  #[global] LockedStack'ptr_Pop_unfold :: MethodUnfold (go.PointerType (LockedStack)) "Pop" (LockedStack__Popⁱᵐᵖˡ);
  #[global] LockedStack'ptr_Push_unfold :: MethodUnfold (go.PointerType (LockedStack)) "Push" (LockedStack__Pushⁱᵐᵖˡ);
}.

Module EliminationStack.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  base' : loc;
  exchanger' : chan.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End EliminationStack.

Definition EliminationStack'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "base"%go (go.PointerType LockedStack));
  (go.FieldDecl "exchanger"%go (go.ChannelType go.sendrecv go.string))
].
Program Definition EliminationStack'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (EliminationStack'fds_unsealed).
Global Instance equals_unfold_EliminationStack {ext : ffi_syntax} {go_gctx : GoGlobalContext} : EliminationStack'fds =→ EliminationStack'fds_unsealed.
Proof. rewrite /EliminationStack'fds seal_eq //. Qed.

Definition EliminationStackⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (EliminationStack'fds).

Class EliminationStack_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] EliminationStack_type_repr  :: go.TypeReprUnderlying EliminationStackⁱᵐᵖˡ EliminationStack.t;
  #[global] EliminationStack_underlying :: (EliminationStack) <u (EliminationStackⁱᵐᵖˡ);
  #[global] EliminationStack_get_base (x : EliminationStack.t) :: ⟦StructFieldGet (EliminationStackⁱᵐᵖˡ) "base", #x⟧ ⤳[under] #x.(EliminationStack.base');
  #[global] EliminationStack_set_base (x : EliminationStack.t) y :: ⟦StructFieldSet (EliminationStackⁱᵐᵖˡ) "base", (#x, #y)⟧ ⤳[under] #(x <|EliminationStack.base' := y|>);
  #[global] EliminationStack_get_exchanger (x : EliminationStack.t) :: ⟦StructFieldGet (EliminationStackⁱᵐᵖˡ) "exchanger", #x⟧ ⤳[under] #x.(EliminationStack.exchanger');
  #[global] EliminationStack_set_exchanger (x : EliminationStack.t) y :: ⟦StructFieldSet (EliminationStackⁱᵐᵖˡ) "exchanger", (#x, #y)⟧ ⤳[under] #(x <|EliminationStack.exchanger' := y|>);
  #[global] EliminationStack'ptr_Pop_unfold :: MethodUnfold (go.PointerType (EliminationStack)) "Pop" (EliminationStack__Popⁱᵐᵖˡ);
  #[global] EliminationStack'ptr_Push_unfold :: MethodUnfold (go.PointerType (EliminationStack)) "Push" (EliminationStack__Pushⁱᵐᵖˡ);
}.

Module request.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  f' : func.t;
  result' : chan.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End request.

Definition request'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "f"%go (go.FunctionType (go.Signature [] false [go.string])));
  (go.FieldDecl "result"%go (go.ChannelType go.sendrecv go.string))
].
Program Definition request'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (request'fds_unsealed).
Global Instance equals_unfold_request {ext : ffi_syntax} {go_gctx : GoGlobalContext} : request'fds =→ request'fds_unsealed.
Proof. rewrite /request'fds seal_eq //. Qed.

Definition requestⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (request'fds).

Class request_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] request_type_repr  :: go.TypeReprUnderlying requestⁱᵐᵖˡ request.t;
  #[global] request_underlying :: (request) <u (requestⁱᵐᵖˡ);
  #[global] request_get_f (x : request.t) :: ⟦StructFieldGet (requestⁱᵐᵖˡ) "f", #x⟧ ⤳[under] #x.(request.f');
  #[global] request_set_f (x : request.t) y :: ⟦StructFieldSet (requestⁱᵐᵖˡ) "f", (#x, #y)⟧ ⤳[under] #(x <|request.f' := y|>);
  #[global] request_get_result (x : request.t) :: ⟦StructFieldGet (requestⁱᵐᵖˡ) "result", #x⟧ ⤳[under] #x.(request.result');
  #[global] request_set_result (x : request.t) y :: ⟦StructFieldSet (requestⁱᵐᵖˡ) "result", (#x, #y)⟧ ⤳[under] #(x <|request.result' := y|>);
}.

Module stream.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  req' : chan.t;
  res' : chan.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End stream.

Definition stream'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "req"%go (go.ChannelType go.sendrecv go.string));
  (go.FieldDecl "res"%go (go.ChannelType go.sendrecv go.string))
].
Program Definition stream'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (stream'fds_unsealed).
Global Instance equals_unfold_stream {ext : ffi_syntax} {go_gctx : GoGlobalContext} : stream'fds =→ stream'fds_unsealed.
Proof. rewrite /stream'fds seal_eq //. Qed.

Definition streamⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (stream'fds).

Class stream_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] stream_type_repr  :: go.TypeReprUnderlying streamⁱᵐᵖˡ stream.t;
  #[global] stream_underlying :: (stream) <u (streamⁱᵐᵖˡ);
  #[global] stream_get_req (x : stream.t) :: ⟦StructFieldGet (streamⁱᵐᵖˡ) "req", #x⟧ ⤳[under] #x.(stream.req');
  #[global] stream_set_req (x : stream.t) y :: ⟦StructFieldSet (streamⁱᵐᵖˡ) "req", (#x, #y)⟧ ⤳[under] #(x <|stream.req' := y|>);
  #[global] stream_get_res (x : stream.t) :: ⟦StructFieldGet (streamⁱᵐᵖˡ) "res", #x⟧ ⤳[under] #x.(stream.res');
  #[global] stream_set_res (x : stream.t) y :: ⟦StructFieldSet (streamⁱᵐᵖˡ) "res", (#x, #y)⟧ ⤳[under] #(x <|stream.res' := y|>);
}.

Module streamold.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  req' : chan.t;
  res' : chan.t;
  f' : func.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End streamold.

Definition streamold'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "req"%go (go.ChannelType go.sendrecv go.string));
  (go.FieldDecl "res"%go (go.ChannelType go.sendrecv go.string));
  (go.FieldDecl "f"%go (go.FunctionType (go.Signature [go.string] false [go.string])))
].
Program Definition streamold'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (streamold'fds_unsealed).
Global Instance equals_unfold_streamold {ext : ffi_syntax} {go_gctx : GoGlobalContext} : streamold'fds =→ streamold'fds_unsealed.
Proof. rewrite /streamold'fds seal_eq //. Qed.

Definition streamoldⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (streamold'fds).

Class streamold_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] streamold_type_repr  :: go.TypeReprUnderlying streamoldⁱᵐᵖˡ streamold.t;
  #[global] streamold_underlying :: (streamold) <u (streamoldⁱᵐᵖˡ);
  #[global] streamold_get_req (x : streamold.t) :: ⟦StructFieldGet (streamoldⁱᵐᵖˡ) "req", #x⟧ ⤳[under] #x.(streamold.req');
  #[global] streamold_set_req (x : streamold.t) y :: ⟦StructFieldSet (streamoldⁱᵐᵖˡ) "req", (#x, #y)⟧ ⤳[under] #(x <|streamold.req' := y|>);
  #[global] streamold_get_res (x : streamold.t) :: ⟦StructFieldGet (streamoldⁱᵐᵖˡ) "res", #x⟧ ⤳[under] #x.(streamold.res');
  #[global] streamold_set_res (x : streamold.t) y :: ⟦StructFieldSet (streamoldⁱᵐᵖˡ) "res", (#x, #y)⟧ ⤳[under] #(x <|streamold.res' := y|>);
  #[global] streamold_get_f (x : streamold.t) :: ⟦StructFieldGet (streamoldⁱᵐᵖˡ) "f", #x⟧ ⤳[under] #x.(streamold.f');
  #[global] streamold_set_f (x : streamold.t) y :: ⟦StructFieldSet (streamoldⁱᵐᵖˡ) "f", (#x, #y)⟧ ⤳[under] #(x <|streamold.f' := y|>);
}.

Class Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] LockedStack_instance :: LockedStack_Assumptions;
  #[global] EliminationStack_instance :: EliminationStack_Assumptions;
  #[global] request_instance :: request_Assumptions;
  #[global] stream_instance :: stream_Assumptions;
  #[global] streamold_instance :: streamold_Assumptions;
  #[global] NewLockedStack_unfold :: FuncUnfold NewLockedStack [] (NewLockedStackⁱᵐᵖˡ);
  #[global] NewEliminationStack_unfold :: FuncUnfold NewEliminationStack [] (NewEliminationStackⁱᵐᵖˡ);
  #[global] sys_hello_world_unfold :: FuncUnfold sys_hello_world [] (sys_hello_worldⁱᵐᵖˡ);
  #[global] HelloWorldAsync_unfold :: FuncUnfold HelloWorldAsync [] (HelloWorldAsyncⁱᵐᵖˡ);
  #[global] HelloWorldSync_unfold :: FuncUnfold HelloWorldSync [] (HelloWorldSyncⁱᵐᵖˡ);
  #[global] HelloWorldCancellable_unfold :: FuncUnfold HelloWorldCancellable [] (HelloWorldCancellableⁱᵐᵖˡ);
  #[global] HelloWorldWithTimeout_unfold :: FuncUnfold HelloWorldWithTimeout [] (HelloWorldWithTimeoutⁱᵐᵖˡ);
  #[global] DSPExample_unfold :: FuncUnfold DSPExample [] (DSPExampleⁱᵐᵖˡ);
  #[global] fibonacci_unfold :: FuncUnfold fibonacci [] (fibonacciⁱᵐᵖˡ);
  #[global] fib_consumer_unfold :: FuncUnfold fib_consumer [] (fib_consumerⁱᵐᵖˡ);
  #[global] simple_join_unfold :: FuncUnfold simple_join [] (simple_joinⁱᵐᵖˡ);
  #[global] simple_multi_join_unfold :: FuncUnfold simple_multi_join [] (simple_multi_joinⁱᵐᵖˡ);
  #[global] select_nb_no_panic_unfold :: FuncUnfold select_nb_no_panic [] (select_nb_no_panicⁱᵐᵖˡ);
  #[global] select_no_double_close_unfold :: FuncUnfold select_no_double_close [] (select_no_double_closeⁱᵐᵖˡ);
  #[global] exchangePointer_unfold :: FuncUnfold exchangePointer [] (exchangePointerⁱᵐᵖˡ);
  #[global] BroadcastExample_unfold :: FuncUnfold BroadcastExample [] (BroadcastExampleⁱᵐᵖˡ);
  #[global] Web_unfold :: FuncUnfold Web [] (Webⁱᵐᵖˡ);
  #[global] Image_unfold :: FuncUnfold Image [] (Imageⁱᵐᵖˡ);
  #[global] Video_unfold :: FuncUnfold Video [] (Videoⁱᵐᵖˡ);
  #[global] Google_unfold :: FuncUnfold Google [] (Googleⁱᵐᵖˡ);
  #[global] select_ready_case_no_panic_unfold :: FuncUnfold select_ready_case_no_panic [] (select_ready_case_no_panicⁱᵐᵖˡ);
  #[global] TestHelloWorldSync_unfold :: FuncUnfold TestHelloWorldSync [] (TestHelloWorldSyncⁱᵐᵖˡ);
  #[global] TestHelloWorldWithTimeout_unfold :: FuncUnfold TestHelloWorldWithTimeout [] (TestHelloWorldWithTimeoutⁱᵐᵖˡ);
  #[global] TestDSPExample_unfold :: FuncUnfold TestDSPExample [] (TestDSPExampleⁱᵐᵖˡ);
  #[global] TestFibConsumer_unfold :: FuncUnfold TestFibConsumer [] (TestFibConsumerⁱᵐᵖˡ);
  #[global] TestSelectNbNoPanic_unfold :: FuncUnfold TestSelectNbNoPanic [] (TestSelectNbNoPanicⁱᵐᵖˡ);
  #[global] TestSelectReadyCaseNoPanic_unfold :: FuncUnfold TestSelectReadyCaseNoPanic [] (TestSelectReadyCaseNoPanicⁱᵐᵖˡ);
  #[global] mkRequest_unfold :: FuncUnfold mkRequest [] (mkRequestⁱᵐᵖˡ);
  #[global] ho_worker_unfold :: FuncUnfold ho_worker [] (ho_workerⁱᵐᵖˡ);
  #[global] HigherOrderExample_unfold :: FuncUnfold HigherOrderExample [] (HigherOrderExampleⁱᵐᵖˡ);
  #[global] load_unfold :: FuncUnfold load [] (loadⁱᵐᵖˡ);
  #[global] process_unfold :: FuncUnfold process [] (processⁱᵐᵖˡ);
  #[global] client_unfold :: FuncUnfold client [] (clientⁱᵐᵖˡ);
  #[global] server_unfold :: FuncUnfold server [] (serverⁱᵐᵖˡ);
  #[global] LeakyBufferPipeline_unfold :: FuncUnfold LeakyBufferPipeline [] (LeakyBufferPipelineⁱᵐᵖˡ);
  #[global] mkStream_unfold :: FuncUnfold mkStream [] (mkStreamⁱᵐᵖˡ);
  #[global] Async_unfold :: FuncUnfold Async [] (Asyncⁱᵐᵖˡ);
  #[global] Serve_unfold :: FuncUnfold Serve [] (Serveⁱᵐᵖˡ);
  #[global] appWrld_unfold :: FuncUnfold appWrld [] (appWrldⁱᵐᵖˡ);
  #[global] Client_unfold :: FuncUnfold Client [] (Clientⁱᵐᵖˡ);
  #[global] MapServer_unfold :: FuncUnfold MapServer [] (MapServerⁱᵐᵖˡ);
  #[global] ClientOld_unfold :: FuncUnfold ClientOld [] (ClientOldⁱᵐᵖˡ);
  #[global] Muxer_unfold :: FuncUnfold Muxer [] (Muxerⁱᵐᵖˡ);
  #[global] makeGreeting_unfold :: FuncUnfold makeGreeting [] (makeGreetingⁱᵐᵖˡ);
  #[global] CancellableMapServer_unfold :: FuncUnfold CancellableMapServer [] (CancellableMapServerⁱᵐᵖˡ);
  #[global] CancellableMuxer_unfold :: FuncUnfold CancellableMuxer [] (CancellableMuxerⁱᵐᵖˡ);
  #[global] worker_unfold :: FuncUnfold worker [] (workerⁱᵐᵖˡ);
  #[global] SearchReplace_unfold :: FuncUnfold SearchReplace [] (SearchReplaceⁱᵐᵖˡ);
  #[global] import_sync_Assumption :: sync.Assumptions;
  #[global] import_time_Assumption :: time.Assumptions;
  #[global] import_strings_Assumption :: strings.Assumptions;
}.
End chan_spec_raw_examples.
