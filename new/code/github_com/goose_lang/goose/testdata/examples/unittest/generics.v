(* autogenerated from github.com/goose-lang/goose/testdata/examples/unittest/generics *)
Require Export New.code.github_com.goose_lang.goose.testdata.examples.unittest.generics.helpers.
From New.golang Require Import defn.
Module pkg_id.
Definition generics : go_string := "github.com/goose-lang/goose/testdata/examples/unittest/generics".

End pkg_id.
Export pkg_id.
Module generics.

Definition Box {ext : ffi_syntax} {go_gctx : GoGlobalContext} (T : go.type) : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest/generics.Box"%go [T].

Definition Container {ext : ffi_syntax} {go_gctx : GoGlobalContext} (T : go.type) : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest/generics.Container"%go [T].

Definition UseContainer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest/generics.UseContainer"%go [].

Definition OnlyIndirect {ext : ffi_syntax} {go_gctx : GoGlobalContext} (T : go.type) : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest/generics.OnlyIndirect"%go [T].

Definition MultiParam {ext : ffi_syntax} {go_gctx : GoGlobalContext} (A : go.type) (B : go.type) : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest/generics.MultiParam"%go [A; B].

Definition UnderlyingSlice {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest/generics.UnderlyingSlice"%go.

Definition Clone {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest/generics.Clone"%go.

Definition BoxGet {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest/generics.BoxGet"%go.

Definition BoxGet2 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest/generics.BoxGet2"%go.

Definition makeGenericBox {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest/generics.makeGenericBox"%go.

Definition makeBox {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest/generics.makeBox"%go.

Definition useBoxGet {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest/generics.useBoxGet"%go.

Definition useContainer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest/generics.useContainer"%go.

Definition useMultiParam {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest/generics.useMultiParam"%go.

Definition swapMultiParam {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest/generics.swapMultiParam"%go.

Definition multiParamFunc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest/generics.multiParamFunc"%go.

Definition useMultiParamFunc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest/generics.useMultiParamFunc"%go.

Definition useAnyPointer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest/generics.useAnyPointer"%go.

(* go: constraints.go:3:6 *)
Definition UnderlyingSliceⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} (T : go.type) : val :=
  λ: "s",
    exception_do (let: "s" := (GoAlloc T "s") in
    return: (let: "$a0" := (![T] "s") in
     (FuncResolve go.len [T] #()) "$a0")).

(* Clone copies a generic slice.

   Slightly simplified from [slices.Clone].

   go: constraints.go:10:6 *)
Definition Cloneⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} (S E : go.type) : val :=
  λ: "s",
    exception_do (let: "s" := (GoAlloc S "s") in
    return: (let: "$a0" := (CompositeLiteral S (LiteralValue [])) in
     let: "$a1" := (Convert S (go.SliceType E) (![S] "s")) in
     (FuncResolve go.append [S] #()) "$a0" "$a1")).

(* BoxGet is a function getter (rather than a method)

   go: generics.go:13:6 *)
Definition BoxGetⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} (T : go.type) : val :=
  λ: "b",
    exception_do (let: "b" := (GoAlloc (Box T) "b") in
    return: (![T] (StructFieldRef (Box T) "Value"%go "b"))).

(* go: generics.go:17:6 *)
Definition BoxGet2ⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "b",
    exception_do (let: "b" := (GoAlloc (Box go.uint64) "b") in
    return: (![go.uint64] (StructFieldRef (Box go.uint64) "Value"%go "b"))).

(* go: generics.go:21:17 *)
Definition Box__Getⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} (T : go.type) : val :=
  λ: "b" <>,
    exception_do (let: "b" := (GoAlloc (Box T) "b") in
    return: (![T] (StructFieldRef (Box T) "Value"%go "b"))).

(* go: generics.go:25:6 *)
Definition makeGenericBoxⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} (T : go.type) : val :=
  λ: "value",
    exception_do (let: "value" := (GoAlloc T "value") in
    return: (CompositeLiteral (Box T) (LiteralValue [KeyedElement (Some (KeyField "Value"%go)) (ElementExpression T (![T] "value"))]))).

(* go: generics.go:29:6 *)
Definition makeBoxⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (CompositeLiteral (Box go.uint64) (LiteralValue [KeyedElement (Some (KeyField "Value"%go)) (ElementExpression go.uint64 #(W64 42))]))).

(* go: generics.go:34:6 *)
Definition useBoxGetⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc (Box go.uint64) (GoZeroVal (Box go.uint64) #())) in
    let: "$r0" := (let: "$a0" := #(W64 42) in
    (FuncResolve makeGenericBox [go.uint64] #()) "$a0") in
    do:  ("x" <-[Box go.uint64] "$r0");;;
    return: ((MethodResolve (Box go.uint64) "Get"%go (![Box go.uint64] "x")) #())).

(* go: generics.go:47:6 *)
Definition useContainerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "container" := (GoAlloc (Container go.uint64) (GoZeroVal (Container go.uint64) #())) in
    let: "$r0" := (CompositeLiteral (Container go.uint64) (LiteralValue [KeyedElement (Some (KeyField "X"%go)) (ElementExpression go.uint64 #(W64 1)); KeyedElement (Some (KeyField "Y"%go)) (ElementExpression (go.MapType go.int go.uint64) (CompositeLiteral (go.MapType go.int go.uint64) (LiteralValue [KeyedElement (Some (KeyExpression go.int #(W64 1))) (ElementExpression go.uint64 #(W64 2))]))); KeyedElement (Some (KeyField "Z"%go)) (ElementExpression (go.PointerType go.uint64) (GoAlloc go.uint64 (GoZeroVal go.uint64 #()))); KeyedElement (Some (KeyField "W"%go)) (ElementExpression go.uint64 #(W64 3))])) in
    do:  ("container" <-[Container go.uint64] "$r0");;;
    let: "$r0" := #(W64 2) in
    do:  ((StructFieldRef (Container go.uint64) "X"%go "container") <-[go.uint64] "$r0");;;
    let: "$r0" := #(W64 3) in
    do:  (map.insert go.int (![go.MapType go.int go.uint64] (StructFieldRef (Container go.uint64) "Y"%go "container")) #(W64 2) "$r0");;;
    let: "$r0" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    do:  ((StructFieldRef (Container go.uint64) "Z"%go "container") <-[go.PointerType go.uint64] "$r0");;;
    let: "$r0" := #(W64 4) in
    do:  ((StructFieldRef (Container go.uint64) "W"%go "container") <-[go.uint64] "$r0");;;
    return: #()).

(* go: generics.go:75:6 *)
Definition useMultiParamⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "mp" := (GoAlloc (MultiParam go.uint64 go.bool) (GoZeroVal (MultiParam go.uint64 go.bool) #())) in
    let: "$r0" := (CompositeLiteral (MultiParam go.uint64 go.bool) (LiteralValue [KeyedElement (Some (KeyField "Y"%go)) (ElementExpression go.bool #true); KeyedElement (Some (KeyField "X"%go)) (ElementExpression go.uint64 #(W64 1))])) in
    do:  ("mp" <-[MultiParam go.uint64 go.bool] "$r0");;;
    let: "$r0" := #(W64 2) in
    do:  ((StructFieldRef (MultiParam go.uint64 go.bool) "X"%go "mp") <-[go.uint64] "$r0");;;
    return: #()).

(* go: generics.go:80:6 *)
Definition swapMultiParamⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} (A : go.type) : val :=
  λ: "p",
    exception_do (let: "p" := (GoAlloc (go.PointerType (MultiParam A A)) "p") in
    let: "temp" := (GoAlloc A (GoZeroVal A #())) in
    let: "$r0" := (![A] (StructFieldRef (MultiParam A A) "X"%go (![go.PointerType (MultiParam A A)] "p"))) in
    do:  ("temp" <-[A] "$r0");;;
    let: "$r0" := (![A] (StructFieldRef (MultiParam A A) "Y"%go (![go.PointerType (MultiParam A A)] "p"))) in
    do:  ((StructFieldRef (MultiParam A A) "X"%go (![go.PointerType (MultiParam A A)] "p")) <-[A] "$r0");;;
    let: "$r0" := (![A] "temp") in
    do:  ((StructFieldRef (MultiParam A A) "Y"%go (![go.PointerType (MultiParam A A)] "p")) <-[A] "$r0");;;
    return: #()).

(* go: generics.go:86:6 *)
Definition multiParamFuncⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} (A B : go.type) : val :=
  λ: "x" "b",
    exception_do (let: "b" := (GoAlloc B "b") in
    let: "x" := (GoAlloc A "x") in
    return: (CompositeLiteral (go.SliceType B) (LiteralValue [KeyedElement None (ElementExpression B (![B] "b"))]))).

(* go: generics.go:90:6 *)
Definition useMultiParamFuncⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (do:  (let: "$a0" := #(W64 1) in
    let: "$a1" := #true in
    (FuncResolve multiParamFunc [go.uint64; go.bool] #()) "$a0" "$a1");;;
    return: (#());;;
    return: #()).

(* go: generics.go:96:6 *)
Definition useAnyPointerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    do:  (let: "$a0" := "x" in
    (FuncResolve helpers.AnyPointer [go.uint64] #()) "$a0");;;
    return: #()).

#[global] Instance info' : PkgInfo pkg_id.generics :=
{|
  pkg_imported_pkgs := [code.github_com.goose_lang.goose.testdata.examples.unittest.generics.helpers.pkg_id.helpers]
|}.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init pkg_id.generics (λ: <>,
      exception_do (do:  (helpers.initialize' #()))
      ).

Module Box.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t {T : Type} :=
mk {
  Value' : T;
}.

#[global] Instance zero_val `{!ZeroVal T} : ZeroVal t := {| zero_val := mk T (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End Box.

Definition Box'fds_unsealed (T : go.type) {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "Value"%go T)
].
Program Definition Box'fds (T : go.type) {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (Box'fds_unsealed T).
Global Instance equals_unfold_Box T {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Box'fds T =→ Box'fds_unsealed T.
Proof. rewrite /Box'fds seal_eq //. Qed.

Definition Boxⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} (T : go.type) : go.type := go.StructType (Box'fds T).

Class Box_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Box_type_repr T T' `{!ZeroVal T'} `{!TypeRepr T T'} :: go.TypeReprUnderlying (Boxⁱᵐᵖˡ T) (Box.t T');
  #[global] Box_underlying T :: (Box T) <u (Boxⁱᵐᵖˡ T);
  #[global] Box_get_Value T T' (x : Box.t T') :: ⟦StructFieldGet (Boxⁱᵐᵖˡ T) "Value", #x⟧ ⤳[under] #x.(Box.Value');
  #[global] Box_set_Value T T' (x : Box.t T') y :: ⟦StructFieldSet (Boxⁱᵐᵖˡ T) "Value", (#x, #y)⟧ ⤳[under] #(x <|Box.Value' := y|>);
  #[global] Box_Get_unfold T :: MethodUnfold (Box T) "Get" (Box__Getⁱᵐᵖˡ T);
  #[global] Box'ptr_Get_unfold T :: MethodUnfold (go.PointerType (Box T)) "Get" (λ: "$r", MethodResolve (Box T) "Get" (![(Box T)] "$r"));
}.

Module Container.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t {T : Type} :=
mk {
  X' : T;
  Y' : map.t;
  Z' : loc;
  W' : w64;
}.

#[global] Instance zero_val `{!ZeroVal T} : ZeroVal t := {| zero_val := mk T (zero_val _) (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End Container.

Definition Container'fds_unsealed (T : go.type) {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "X"%go T);
  (go.FieldDecl "Y"%go (go.MapType go.int T));
  (go.FieldDecl "Z"%go (go.PointerType T));
  (go.FieldDecl "W"%go go.uint64)
].
Program Definition Container'fds (T : go.type) {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (Container'fds_unsealed T).
Global Instance equals_unfold_Container T {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Container'fds T =→ Container'fds_unsealed T.
Proof. rewrite /Container'fds seal_eq //. Qed.

Definition Containerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} (T : go.type) : go.type := go.StructType (Container'fds T).

Class Container_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Container_type_repr T T' `{!ZeroVal T'} `{!TypeRepr T T'} :: go.TypeReprUnderlying (Containerⁱᵐᵖˡ T) (Container.t T');
  #[global] Container_underlying T :: (Container T) <u (Containerⁱᵐᵖˡ T);
  #[global] Container_get_X T T' (x : Container.t T') :: ⟦StructFieldGet (Containerⁱᵐᵖˡ T) "X", #x⟧ ⤳[under] #x.(Container.X');
  #[global] Container_set_X T T' (x : Container.t T') y :: ⟦StructFieldSet (Containerⁱᵐᵖˡ T) "X", (#x, #y)⟧ ⤳[under] #(x <|Container.X' := y|>);
  #[global] Container_get_Y T T' (x : Container.t T') :: ⟦StructFieldGet (Containerⁱᵐᵖˡ T) "Y", #x⟧ ⤳[under] #x.(Container.Y');
  #[global] Container_set_Y T T' (x : Container.t T') y :: ⟦StructFieldSet (Containerⁱᵐᵖˡ T) "Y", (#x, #y)⟧ ⤳[under] #(x <|Container.Y' := y|>);
  #[global] Container_get_Z T T' (x : Container.t T') :: ⟦StructFieldGet (Containerⁱᵐᵖˡ T) "Z", #x⟧ ⤳[under] #x.(Container.Z');
  #[global] Container_set_Z T T' (x : Container.t T') y :: ⟦StructFieldSet (Containerⁱᵐᵖˡ T) "Z", (#x, #y)⟧ ⤳[under] #(x <|Container.Z' := y|>);
  #[global] Container_get_W T T' (x : Container.t T') :: ⟦StructFieldGet (Containerⁱᵐᵖˡ T) "W", #x⟧ ⤳[under] #x.(Container.W');
  #[global] Container_set_W T T' (x : Container.t T') y :: ⟦StructFieldSet (Containerⁱᵐᵖˡ T) "W", (#x, #y)⟧ ⤳[under] #(x <|Container.W' := y|>);
}.

Module UseContainer.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  X' : (generics.Container.t w64);
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End UseContainer.

Definition UseContainer'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "X"%go (Container go.uint64))
].
Program Definition UseContainer'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (UseContainer'fds_unsealed).
Global Instance equals_unfold_UseContainer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : UseContainer'fds =→ UseContainer'fds_unsealed.
Proof. rewrite /UseContainer'fds seal_eq //. Qed.

Definition UseContainerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (UseContainer'fds).

Class UseContainer_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] UseContainer_type_repr  :: go.TypeReprUnderlying UseContainerⁱᵐᵖˡ UseContainer.t;
  #[global] UseContainer_underlying :: (UseContainer) <u (UseContainerⁱᵐᵖˡ);
  #[global] UseContainer_get_X (x : UseContainer.t) :: ⟦StructFieldGet (UseContainerⁱᵐᵖˡ) "X", #x⟧ ⤳[under] #x.(UseContainer.X');
  #[global] UseContainer_set_X (x : UseContainer.t) y :: ⟦StructFieldSet (UseContainerⁱᵐᵖˡ) "X", (#x, #y)⟧ ⤳[under] #(x <|UseContainer.X' := y|>);
}.

Module OnlyIndirect.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t {T : Type} :=
mk {
  X' : slice.t;
  Y' : loc;
}.

#[global] Instance zero_val `{!ZeroVal T} : ZeroVal t := {| zero_val := mk T (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End OnlyIndirect.

Definition OnlyIndirect'fds_unsealed (T : go.type) {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "X"%go (go.SliceType T));
  (go.FieldDecl "Y"%go (go.PointerType T))
].
Program Definition OnlyIndirect'fds (T : go.type) {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (OnlyIndirect'fds_unsealed T).
Global Instance equals_unfold_OnlyIndirect T {ext : ffi_syntax} {go_gctx : GoGlobalContext} : OnlyIndirect'fds T =→ OnlyIndirect'fds_unsealed T.
Proof. rewrite /OnlyIndirect'fds seal_eq //. Qed.

Definition OnlyIndirectⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} (T : go.type) : go.type := go.StructType (OnlyIndirect'fds T).

Class OnlyIndirect_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] OnlyIndirect_type_repr T T' `{!ZeroVal T'} `{!TypeRepr T T'} :: go.TypeReprUnderlying (OnlyIndirectⁱᵐᵖˡ T) (OnlyIndirect.t T');
  #[global] OnlyIndirect_underlying T :: (OnlyIndirect T) <u (OnlyIndirectⁱᵐᵖˡ T);
  #[global] OnlyIndirect_get_X T T' (x : OnlyIndirect.t T') :: ⟦StructFieldGet (OnlyIndirectⁱᵐᵖˡ T) "X", #x⟧ ⤳[under] #x.(OnlyIndirect.X');
  #[global] OnlyIndirect_set_X T T' (x : OnlyIndirect.t T') y :: ⟦StructFieldSet (OnlyIndirectⁱᵐᵖˡ T) "X", (#x, #y)⟧ ⤳[under] #(x <|OnlyIndirect.X' := y|>);
  #[global] OnlyIndirect_get_Y T T' (x : OnlyIndirect.t T') :: ⟦StructFieldGet (OnlyIndirectⁱᵐᵖˡ T) "Y", #x⟧ ⤳[under] #x.(OnlyIndirect.Y');
  #[global] OnlyIndirect_set_Y T T' (x : OnlyIndirect.t T') y :: ⟦StructFieldSet (OnlyIndirectⁱᵐᵖˡ T) "Y", (#x, #y)⟧ ⤳[under] #(x <|OnlyIndirect.Y' := y|>);
}.

Module MultiParam.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t {A B : Type} :=
mk {
  Y' : B;
  X' : A;
}.

#[global] Instance zero_val `{!ZeroVal A} `{!ZeroVal B} : ZeroVal t := {| zero_val := mk A B (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End MultiParam.

Definition MultiParam'fds_unsealed (A : go.type) (B : go.type) {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "Y"%go B);
  (go.FieldDecl "X"%go A)
].
Program Definition MultiParam'fds (A : go.type) (B : go.type) {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (MultiParam'fds_unsealed A B).
Global Instance equals_unfold_MultiParam A B {ext : ffi_syntax} {go_gctx : GoGlobalContext} : MultiParam'fds A B =→ MultiParam'fds_unsealed A B.
Proof. rewrite /MultiParam'fds seal_eq //. Qed.

Definition MultiParamⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} (A : go.type) (B : go.type) : go.type := go.StructType (MultiParam'fds A B).

Class MultiParam_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] MultiParam_type_repr A A' `{!ZeroVal A'} `{!TypeRepr A A'}B B' `{!ZeroVal B'} `{!TypeRepr B B'} :: go.TypeReprUnderlying (MultiParamⁱᵐᵖˡ A B) (MultiParam.t A' B');
  #[global] MultiParam_underlying A B :: (MultiParam A B) <u (MultiParamⁱᵐᵖˡ A B);
  #[global] MultiParam_get_Y A B A' B' (x : MultiParam.t A' B') :: ⟦StructFieldGet (MultiParamⁱᵐᵖˡ A B) "Y", #x⟧ ⤳[under] #x.(MultiParam.Y');
  #[global] MultiParam_set_Y A B A' B' (x : MultiParam.t A' B') y :: ⟦StructFieldSet (MultiParamⁱᵐᵖˡ A B) "Y", (#x, #y)⟧ ⤳[under] #(x <|MultiParam.Y' := y|>);
  #[global] MultiParam_get_X A B A' B' (x : MultiParam.t A' B') :: ⟦StructFieldGet (MultiParamⁱᵐᵖˡ A B) "X", #x⟧ ⤳[under] #x.(MultiParam.X');
  #[global] MultiParam_set_X A B A' B' (x : MultiParam.t A' B') y :: ⟦StructFieldSet (MultiParamⁱᵐᵖˡ A B) "X", (#x, #y)⟧ ⤳[under] #(x <|MultiParam.X' := y|>);
}.

Class Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Box_instance :: Box_Assumptions;
  #[global] Container_instance :: Container_Assumptions;
  #[global] UseContainer_instance :: UseContainer_Assumptions;
  #[global] OnlyIndirect_instance :: OnlyIndirect_Assumptions;
  #[global] MultiParam_instance :: MultiParam_Assumptions;
  #[global] UnderlyingSlice_unfold T :: FuncUnfold UnderlyingSlice [T] (UnderlyingSliceⁱᵐᵖˡ T);
  #[global] Clone_unfold S E :: FuncUnfold Clone [S; E] (Cloneⁱᵐᵖˡ S E);
  #[global] BoxGet_unfold T :: FuncUnfold BoxGet [T] (BoxGetⁱᵐᵖˡ T);
  #[global] BoxGet2_unfold :: FuncUnfold BoxGet2 [] (BoxGet2ⁱᵐᵖˡ);
  #[global] makeGenericBox_unfold T :: FuncUnfold makeGenericBox [T] (makeGenericBoxⁱᵐᵖˡ T);
  #[global] makeBox_unfold :: FuncUnfold makeBox [] (makeBoxⁱᵐᵖˡ);
  #[global] useBoxGet_unfold :: FuncUnfold useBoxGet [] (useBoxGetⁱᵐᵖˡ);
  #[global] useContainer_unfold :: FuncUnfold useContainer [] (useContainerⁱᵐᵖˡ);
  #[global] useMultiParam_unfold :: FuncUnfold useMultiParam [] (useMultiParamⁱᵐᵖˡ);
  #[global] swapMultiParam_unfold A :: FuncUnfold swapMultiParam [A] (swapMultiParamⁱᵐᵖˡ A);
  #[global] multiParamFunc_unfold A B :: FuncUnfold multiParamFunc [A; B] (multiParamFuncⁱᵐᵖˡ A B);
  #[global] useMultiParamFunc_unfold :: FuncUnfold useMultiParamFunc [] (useMultiParamFuncⁱᵐᵖˡ);
  #[global] useAnyPointer_unfold :: FuncUnfold useAnyPointer [] (useAnyPointerⁱᵐᵖˡ);
  #[global] import_helpers_Assumption :: helpers.Assumptions;
}.
End generics.
