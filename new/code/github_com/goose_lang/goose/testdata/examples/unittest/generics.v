(* autogenerated from github.com/goose-lang/goose/testdata/examples/unittest/generics *)
Require Export New.code.github_com.goose_lang.goose.testdata.examples.unittest.generics.helpers.
From New.golang Require Import defn.
Definition generics : go_string := "github.com/goose-lang/goose/testdata/examples/unittest/generics".

Module generics.

Definition Box {ext : ffi_syntax} {go_gctx : GoGlobalContext} (T : go.type) : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest/generics.Box"%go [T].

Definition Container {ext : ffi_syntax} {go_gctx : GoGlobalContext} (T : go.type) : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest/generics.Container"%go [T].

Definition UseContainer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest/generics.UseContainer"%go [].

Definition OnlyIndirect {ext : ffi_syntax} {go_gctx : GoGlobalContext} (T : go.type) : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest/generics.OnlyIndirect"%go [T].

Definition MultiParam {ext : ffi_syntax} {go_gctx : GoGlobalContext} (A : go.type) (B : go.type) : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest/generics.MultiParam"%go [A; B].

Definition UnderlyingSlice {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest/generics.UnderlyingSlice"%go.

Definition Clone {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest/generics.Clone"%go.

Definition BoxGet {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest/generics.BoxGet"%go.

Definition BoxGet2 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest/generics.BoxGet2"%go.

Definition makeGenericBox {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest/generics.makeGenericBox"%go.

Definition makeBox {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest/generics.makeBox"%go.

Definition useBoxGet {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest/generics.useBoxGet"%go.

Definition useContainer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest/generics.useContainer"%go.

Definition useMultiParam {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest/generics.useMultiParam"%go.

Definition swapMultiParam {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest/generics.swapMultiParam"%go.

Definition multiParamFunc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest/generics.multiParamFunc"%go.

Definition useMultiParamFunc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest/generics.useMultiParamFunc"%go.

Definition useAnyPointer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest/generics.useAnyPointer"%go.

(* go: constraints.go:3:6 *)
Definition UnderlyingSliceⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} (T : go.type) : val :=
  λ: "s",
    exception_do (let: "s" := (GoAlloc T "s") in
    return: (let: "$a0" := (![T] "s") in
     (FuncResolve go.len [T] #()) "$a0")).

(* Clone copies a generic slice.

   Slightly simplified from [slices.Clone].

   go: constraints.go:10:6 *)
Definition Cloneⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} (S E : go.type) : val :=
  λ: "s",
    exception_do (let: "s" := (GoAlloc S "s") in
    return: (let: "$a0" := (CompositeLiteral S (LiteralValue [])) in
     let: "$a1" := (![S] "s") in
     (FuncResolve go.append [S] #()) "$a0" "$a1")).

(* BoxGet is a function getter (rather than a method)

   go: generics.go:13:6 *)
Definition BoxGetⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} (T : go.type) : val :=
  λ: "b",
    exception_do (let: "b" := (GoAlloc (Box T) "b") in
    return: (![T] (StructFieldRef (Box T) "Value"%go "b"))).

(* go: generics.go:17:6 *)
Definition BoxGet2ⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "b",
    exception_do (let: "b" := (GoAlloc (Box go.uint64) "b") in
    return: (![go.uint64] (StructFieldRef (Box go.uint64) "Value"%go "b"))).

(* go: generics.go:21:17 *)
Definition Box__Getⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} (T : go.type) : val :=
  λ: "b" <>,
    exception_do (let: "b" := (GoAlloc (Box T) "b") in
    return: (![T] (StructFieldRef (Box T) "Value"%go "b"))).

(* go: generics.go:25:6 *)
Definition makeGenericBoxⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} (T : go.type) : val :=
  λ: "value",
    exception_do (let: "value" := (GoAlloc T "value") in
    return: (CompositeLiteral (Box T) (LiteralValue [KeyedElement (Some (KeyField "Value"%go)) (ElementExpression (![T] "value"))]))).

(* go: generics.go:29:6 *)
Definition makeBoxⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (CompositeLiteral (Box go.uint64) (LiteralValue [KeyedElement (Some (KeyField "Value"%go)) (ElementExpression #(W64 42))]))).

(* go: generics.go:34:6 *)
Definition useBoxGetⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc (Box go.uint64) (GoZeroVal (Box go.uint64) #())) in
    let: "$r0" := (let: "$a0" := #(W64 42) in
    (FuncResolve makeGenericBox [go.uint64] #()) "$a0") in
    do:  ("x" <-[Box go.uint64] "$r0");;;
    return: ((MethodResolve (Box go.uint64) "Get"%go #() (![Box go.uint64] "x")) #())).

(* go: generics.go:47:6 *)
Definition useContainerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "container" := (GoAlloc (Container go.uint64) (GoZeroVal (Container go.uint64) #())) in
    let: "$r0" := (CompositeLiteral (Container go.uint64) (LiteralValue [KeyedElement (Some (KeyField "X"%go)) (ElementExpression #(W64 1)); KeyedElement (Some (KeyField "Y"%go)) (ElementExpression (CompositeLiteral (go.MapType go.int go.uint64) (LiteralValue [KeyedElement (Some (KeyExpression #(W64 1))) (ElementExpression #(W64 2))]))); KeyedElement (Some (KeyField "Z"%go)) (ElementExpression (GoAlloc go.uint64 (GoZeroVal go.uint64 #()))); KeyedElement (Some (KeyField "W"%go)) (ElementExpression #(W64 3))])) in
    do:  ("container" <-[Container go.uint64] "$r0");;;
    let: "$r0" := #(W64 2) in
    do:  ((StructFieldRef (Container go.uint64) "X"%go "container") <-[go.uint64] "$r0");;;
    let: "$r0" := #(W64 3) in
    do:  (map.insert go.int (![go.MapType go.int go.uint64] (StructFieldRef (Container go.uint64) "Y"%go "container")) #(W64 2) "$r0");;;
    let: "$r0" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    do:  ((StructFieldRef (Container go.uint64) "Z"%go "container") <-[go.PointerType go.uint64] "$r0");;;
    let: "$r0" := #(W64 4) in
    do:  ((StructFieldRef (Container go.uint64) "W"%go "container") <-[go.uint64] "$r0");;;
    return: #()).

(* go: generics.go:75:6 *)
Definition useMultiParamⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "mp" := (GoAlloc (MultiParam go.uint64 go.bool) (GoZeroVal (MultiParam go.uint64 go.bool) #())) in
    let: "$r0" := (CompositeLiteral (MultiParam go.uint64 go.bool) (LiteralValue [KeyedElement (Some (KeyField "Y"%go)) (ElementExpression #true); KeyedElement (Some (KeyField "X"%go)) (ElementExpression #(W64 1))])) in
    do:  ("mp" <-[MultiParam go.uint64 go.bool] "$r0");;;
    let: "$r0" := #(W64 2) in
    do:  ((StructFieldRef (MultiParam go.uint64 go.bool) "X"%go "mp") <-[go.uint64] "$r0");;;
    return: #()).

(* go: generics.go:80:6 *)
Definition swapMultiParamⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} (A : go.type) : val :=
  λ: "p",
    exception_do (let: "p" := (GoAlloc (go.PointerType (MultiParam A A)) "p") in
    let: "temp" := (GoAlloc A (GoZeroVal A #())) in
    let: "$r0" := (![A] (StructFieldRef (MultiParam A A) "X"%go (![go.PointerType (MultiParam A A)] "p"))) in
    do:  ("temp" <-[A] "$r0");;;
    let: "$r0" := (![A] (StructFieldRef (MultiParam A A) "Y"%go (![go.PointerType (MultiParam A A)] "p"))) in
    do:  ((StructFieldRef (MultiParam A A) "X"%go (![go.PointerType (MultiParam A A)] "p")) <-[A] "$r0");;;
    let: "$r0" := (![A] "temp") in
    do:  ((StructFieldRef (MultiParam A A) "Y"%go (![go.PointerType (MultiParam A A)] "p")) <-[A] "$r0");;;
    return: #()).

(* go: generics.go:86:6 *)
Definition multiParamFuncⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} (A B : go.type) : val :=
  λ: "x" "b",
    exception_do (let: "b" := (GoAlloc B "b") in
    let: "x" := (GoAlloc A "x") in
    return: (CompositeLiteral (go.SliceType B) (LiteralValue [KeyedElement None (ElementExpression (![B] "b"))]))).

(* go: generics.go:90:6 *)
Definition useMultiParamFuncⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (do:  (let: "$a0" := #(W64 1) in
    let: "$a1" := #true in
    (FuncResolve multiParamFunc [go.uint64; go.bool] #()) "$a0" "$a1");;;
    return: (#());;;
    return: #()).

(* go: generics.go:96:6 *)
Definition useAnyPointerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    do:  (let: "$a0" := "x" in
    (FuncResolve helpers.AnyPointer [go.uint64] #()) "$a0");;;
    return: #()).

#[global] Instance info' : PkgInfo generics.generics := 
{|
  pkg_imported_pkgs := [code.github_com.goose_lang.goose.testdata.examples.unittest.generics.helpers.helpers]
|}.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init generics.generics (λ: <>,
      exception_do (do:  (helpers.initialize' #()))
      ).

Module Box.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t {T : Type} :=
mk {
  Value : T;
}.

#[global] Instance zero_val `{!ZeroVal T} : ZeroVal t := {| zero_val := mk T (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End Box.

Definition Boxⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} (T : go.type) : go.type := go.StructType [
  (go.FieldDecl "Value"%go T)
].

Class Box_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Box_type_repr T T' `{!ZeroVal T'} `{!go.TypeRepr T T'} :: go.TypeRepr (Box T) (Box.t T');
  #[global] Box_underlying T :: go.Underlying (Box T) (Boxⁱᵐᵖˡ T);
  #[global] Box_get_Value T T' (x : Box.t T') :: go.IsGoStepPureDet (StructFieldGet (Box T) "Value") #x #x.(Box.Value);
  #[global] Box_set_Value T T' (x : Box.t T') y :: go.IsGoStepPureDet (StructFieldSet (Box T) "Value") (#x, #y) #(x <|Box.Value := y|>);
  #[global] Box_Get_unfold T :: MethodUnfold (Box T) "Get" (Box__Getⁱᵐᵖˡ T);
  #[global] Box'ptr_Get_unfold T :: MethodUnfold (go.PointerType (Box T)) "Get" (λ: "$r", MethodResolve (Box T) "Get" #() (![(Box T)] "$r"));
}.

Module Container.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t {T : Type} :=
mk {
  X : T;
  Y : loc;
  Z : loc;
  W : w64;
}.

#[global] Instance zero_val `{!ZeroVal T} : ZeroVal t := {| zero_val := mk T (zero_val _) (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End Container.

Definition Containerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} (T : go.type) : go.type := go.StructType [
  (go.FieldDecl "X"%go T);
  (go.FieldDecl "Y"%go (go.MapType go.int T));
  (go.FieldDecl "Z"%go (go.PointerType T));
  (go.FieldDecl "W"%go go.uint64)
].

Class Container_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Container_type_repr T T' `{!ZeroVal T'} `{!go.TypeRepr T T'} :: go.TypeRepr (Container T) (Container.t T');
  #[global] Container_underlying T :: go.Underlying (Container T) (Containerⁱᵐᵖˡ T);
  #[global] Container_get_X T T' (x : Container.t T') :: go.IsGoStepPureDet (StructFieldGet (Container T) "X") #x #x.(Container.X);
  #[global] Container_set_X T T' (x : Container.t T') y :: go.IsGoStepPureDet (StructFieldSet (Container T) "X") (#x, #y) #(x <|Container.X := y|>);
  #[global] Container_get_Y T T' (x : Container.t T') :: go.IsGoStepPureDet (StructFieldGet (Container T) "Y") #x #x.(Container.Y);
  #[global] Container_set_Y T T' (x : Container.t T') y :: go.IsGoStepPureDet (StructFieldSet (Container T) "Y") (#x, #y) #(x <|Container.Y := y|>);
  #[global] Container_get_Z T T' (x : Container.t T') :: go.IsGoStepPureDet (StructFieldGet (Container T) "Z") #x #x.(Container.Z);
  #[global] Container_set_Z T T' (x : Container.t T') y :: go.IsGoStepPureDet (StructFieldSet (Container T) "Z") (#x, #y) #(x <|Container.Z := y|>);
  #[global] Container_get_W T T' (x : Container.t T') :: go.IsGoStepPureDet (StructFieldGet (Container T) "W") #x #x.(Container.W);
  #[global] Container_set_W T T' (x : Container.t T') y :: go.IsGoStepPureDet (StructFieldSet (Container T) "W") (#x, #y) #(x <|Container.W := y|>);
}.

Module UseContainer.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  X : (generics.Container.t w64);
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End UseContainer.

Definition UseContainerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType [
  (go.FieldDecl "X"%go (Container go.uint64))
].

Class UseContainer_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] UseContainer_type_repr  :: go.TypeRepr UseContainer UseContainer.t;
  #[global] UseContainer_underlying :: go.Underlying (UseContainer) (UseContainerⁱᵐᵖˡ);
  #[global] UseContainer_get_X (x : UseContainer.t) :: go.IsGoStepPureDet (StructFieldGet (UseContainer) "X") #x #x.(UseContainer.X);
  #[global] UseContainer_set_X (x : UseContainer.t) y :: go.IsGoStepPureDet (StructFieldSet (UseContainer) "X") (#x, #y) #(x <|UseContainer.X := y|>);
}.

Module OnlyIndirect.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t {T : Type} :=
mk {
  X : slice.t;
  Y : loc;
}.

#[global] Instance zero_val `{!ZeroVal T} : ZeroVal t := {| zero_val := mk T (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End OnlyIndirect.

Definition OnlyIndirectⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} (T : go.type) : go.type := go.StructType [
  (go.FieldDecl "X"%go (go.SliceType T));
  (go.FieldDecl "Y"%go (go.PointerType T))
].

Class OnlyIndirect_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] OnlyIndirect_type_repr T T' `{!ZeroVal T'} `{!go.TypeRepr T T'} :: go.TypeRepr (OnlyIndirect T) (OnlyIndirect.t T');
  #[global] OnlyIndirect_underlying T :: go.Underlying (OnlyIndirect T) (OnlyIndirectⁱᵐᵖˡ T);
  #[global] OnlyIndirect_get_X T T' (x : OnlyIndirect.t T') :: go.IsGoStepPureDet (StructFieldGet (OnlyIndirect T) "X") #x #x.(OnlyIndirect.X);
  #[global] OnlyIndirect_set_X T T' (x : OnlyIndirect.t T') y :: go.IsGoStepPureDet (StructFieldSet (OnlyIndirect T) "X") (#x, #y) #(x <|OnlyIndirect.X := y|>);
  #[global] OnlyIndirect_get_Y T T' (x : OnlyIndirect.t T') :: go.IsGoStepPureDet (StructFieldGet (OnlyIndirect T) "Y") #x #x.(OnlyIndirect.Y);
  #[global] OnlyIndirect_set_Y T T' (x : OnlyIndirect.t T') y :: go.IsGoStepPureDet (StructFieldSet (OnlyIndirect T) "Y") (#x, #y) #(x <|OnlyIndirect.Y := y|>);
}.

Module MultiParam.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t {A B : Type} :=
mk {
  Y : B;
  X : A;
}.

#[global] Instance zero_val `{!ZeroVal A} `{!ZeroVal B} : ZeroVal t := {| zero_val := mk A B (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End MultiParam.

Definition MultiParamⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} (A : go.type) (B : go.type) : go.type := go.StructType [
  (go.FieldDecl "Y"%go B);
  (go.FieldDecl "X"%go A)
].

Class MultiParam_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] MultiParam_type_repr A A' `{!ZeroVal A'} `{!go.TypeRepr A A'}B B' `{!ZeroVal B'} `{!go.TypeRepr B B'} :: go.TypeRepr (MultiParam A B) (MultiParam.t A' B');
  #[global] MultiParam_underlying A B :: go.Underlying (MultiParam A B) (MultiParamⁱᵐᵖˡ A B);
  #[global] MultiParam_get_Y A B A' B' (x : MultiParam.t A' B') :: go.IsGoStepPureDet (StructFieldGet (MultiParam A B) "Y") #x #x.(MultiParam.Y);
  #[global] MultiParam_set_Y A B A' B' (x : MultiParam.t A' B') y :: go.IsGoStepPureDet (StructFieldSet (MultiParam A B) "Y") (#x, #y) #(x <|MultiParam.Y := y|>);
  #[global] MultiParam_get_X A B A' B' (x : MultiParam.t A' B') :: go.IsGoStepPureDet (StructFieldGet (MultiParam A B) "X") #x #x.(MultiParam.X);
  #[global] MultiParam_set_X A B A' B' (x : MultiParam.t A' B') y :: go.IsGoStepPureDet (StructFieldSet (MultiParam A B) "X") (#x, #y) #(x <|MultiParam.X := y|>);
}.

Class Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Box_instance :: Box_Assumptions;
  #[global] Container_instance :: Container_Assumptions;
  #[global] UseContainer_instance :: UseContainer_Assumptions;
  #[global] OnlyIndirect_instance :: OnlyIndirect_Assumptions;
  #[global] MultiParam_instance :: MultiParam_Assumptions;
  #[global] UnderlyingSlice_unfold T :: FuncUnfold UnderlyingSlice [T] (UnderlyingSliceⁱᵐᵖˡ T);
  #[global] Clone_unfold S E :: FuncUnfold Clone [S; E] (Cloneⁱᵐᵖˡ S E);
  #[global] BoxGet_unfold T :: FuncUnfold BoxGet [T] (BoxGetⁱᵐᵖˡ T);
  #[global] BoxGet2_unfold :: FuncUnfold BoxGet2 [] (BoxGet2ⁱᵐᵖˡ);
  #[global] makeGenericBox_unfold T :: FuncUnfold makeGenericBox [T] (makeGenericBoxⁱᵐᵖˡ T);
  #[global] makeBox_unfold :: FuncUnfold makeBox [] (makeBoxⁱᵐᵖˡ);
  #[global] useBoxGet_unfold :: FuncUnfold useBoxGet [] (useBoxGetⁱᵐᵖˡ);
  #[global] useContainer_unfold :: FuncUnfold useContainer [] (useContainerⁱᵐᵖˡ);
  #[global] useMultiParam_unfold :: FuncUnfold useMultiParam [] (useMultiParamⁱᵐᵖˡ);
  #[global] swapMultiParam_unfold A :: FuncUnfold swapMultiParam [A] (swapMultiParamⁱᵐᵖˡ A);
  #[global] multiParamFunc_unfold A B :: FuncUnfold multiParamFunc [A; B] (multiParamFuncⁱᵐᵖˡ A B);
  #[global] useMultiParamFunc_unfold :: FuncUnfold useMultiParamFunc [] (useMultiParamFuncⁱᵐᵖˡ);
  #[global] useAnyPointer_unfold :: FuncUnfold useAnyPointer [] (useAnyPointerⁱᵐᵖˡ);
  #[global] import_helpers_Assumption :: helpers.Assumptions;
}.
End generics.
