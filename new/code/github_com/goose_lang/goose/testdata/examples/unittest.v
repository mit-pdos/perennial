(* autogenerated from github.com/goose-lang/goose/testdata/examples/unittest *)
Require Export New.code.fmt.
Require Export New.code.github_com.goose_lang.primitive.
Require Export New.code.github_com.goose_lang.primitive.disk.
Require Export New.code.github_com.goose_lang.std.
Require Export New.code.log.
Require Export New.code.sync.

From New.golang Require Import defn.
From New Require Import disk_prelude.
Definition unittest : go_string := "github.com/goose-lang/goose/testdata/examples/unittest".

Module unittest.

Definition Fooⁱᵐᵖˡ : go.type := go.ArrayType 10 go.uint64.

Definition Foo : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.Foo"%go [].

Module Foo.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t  : Type := (vec w64 (uint.nat (W64 10))).
End def.
End Foo.

Class Foo_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Foo_zero_val  :: go.GoZeroValEq Foo Foo.t;
}.

Definition takesArray {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.takesArray"%go.

(* go: array.go:5:6 *)
Definition takesArrayⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x",
    exception_do (let: "x" := (GoAlloc (go.ArrayType 13 go.string) "x") in
    return: (![go.string] (IndexRef (go.ArrayType 13 go.string) (![go.ArrayType 13 go.string] "x", #(W64 3))))).

Definition takesPtr {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.takesPtr"%go.

(* go: array.go:9:6 *)
Definition takesPtrⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x",
    exception_do (let: "x" := (GoAlloc (go.PointerType go.string) "x") in
    do:  ((![go.PointerType go.string] "x") <-[go.string] ((![go.string] (![go.PointerType go.string] "x")) +⟨go.string⟩ #"bar"%go));;;
    return: #()).

Definition usesArrayElemRef {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.usesArrayElemRef"%go.

(* go: array.go:13:6 *)
Definition usesArrayElemRefⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc (go.ArrayType 2 go.string) (GoZeroVal (go.ArrayType 2 go.string) #())) in
    let: "$r0" := (CompositeLiteral (go.ArrayType 2 go.string) (LiteralValue [KeyedElement None (ElementExpression #"a"%go); KeyedElement None (ElementExpression #"b"%go)])) in
    do:  ("x" <-[go.ArrayType 2 go.string] "$r0");;;
    let: "$r0" := #"c"%go in
    do:  ((IndexRef (go.ArrayType 2 go.string) (![go.ArrayType 2 go.string] "x", #(W64 1))) <-[go.string] "$r0");;;
    do:  (let: "$a0" := (IndexRef go.string (![go.ArrayType 2 go.string] "x", #(W64 1))) in
    (FuncResolve takesPtr [] #()) "$a0");;;
    return: #()).

Definition sum {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.sum"%go.

(* go: array.go:22:6 *)
Definition sumⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x",
    exception_do (let: "x" := (GoAlloc (go.ArrayType 100 go.uint64) "x") in
    let: "sum" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("sum" <-[go.uint64] "$r0");;;
    (let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, (![go.uint64] "i") <⟨go.uint64⟩ (s_to_w64 (array.len (go.ArrayType 100 go.uint64)))); (λ: <>, do:  ("i" <-[go.uint64] ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 1)))) := λ: <>,
      do:  ("sum" <-[go.uint64] ((![go.uint64] "sum") +⟨go.uint64⟩ (![go.uint64] (IndexRef (go.ArrayType 100 go.uint64) (![go.ArrayType 100 go.uint64] "x", ![go.uint64] "i")))))));;;
    do:  ("sum" <-[go.uint64] ((![go.uint64] "sum") +⟨go.uint64⟩ (s_to_w64 (array.cap (go.ArrayType 100 go.uint64)))));;;
    return: (![go.uint64] "sum")).

Definition arrayToSlice {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.arrayToSlice"%go.

(* go: array.go:31:6 *)
Definition arrayToSliceⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc (go.ArrayType 2 go.string) (GoZeroVal (go.ArrayType 2 go.string) #())) in
    let: "$r0" := (CompositeLiteral (go.ArrayType 2 go.string) (LiteralValue [KeyedElement None (ElementExpression #"a"%go); KeyedElement None (ElementExpression #"b"%go)])) in
    do:  ("x" <-[go.ArrayType 2 go.string] "$r0");;;
    return: (let: "$s" := (![go.ArrayType 2 go.string] "x") in
     Slice (go.ArrayType 2 go.string) ("$s", #(W64 0), FuncResolve go.len [go.ArrayType 2 go.string] #() (![go.ArrayType 2 go.string] "x")))).

Definition arrayA {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Z := 0.

Definition arrayB {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Z := 10.

Definition arrayLiteralKeyed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.arrayLiteralKeyed"%go.

(* go: array.go:44:6 *)
Definition arrayLiteralKeyedⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc (go.ArrayType 13 go.string) (GoZeroVal (go.ArrayType 13 go.string) #())) in
    let: "$r0" := (CompositeLiteral (go.ArrayType 13 go.string) (LiteralValue [KeyedElement (Some (KeyExpression #(W64 arrayB))) (ElementExpression #"B"%go); KeyedElement None (ElementExpression #"1"%go); KeyedElement None (ElementExpression #"2"%go); KeyedElement (Some (KeyExpression #(W64 arrayA))) (ElementExpression #"A"%go); KeyedElement None (ElementExpression #"3"%go)])) in
    do:  ("x" <-[go.ArrayType 13 go.string] "$r0");;;
    return: (![go.string] (IndexRef (go.ArrayType 13 go.string) (![go.ArrayType 13 go.string] "x", #(W64 0))))).

Definition chanBasic {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.chanBasic"%go.

(* go: chan.go:5:6 *)
Definition chanBasicⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc (go.ChannelType go.sendrecv go.string) (GoZeroVal (go.ChannelType go.sendrecv go.string) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.ChannelType go.sendrecv go.string] #()) #(W64 10)) in
    do:  ("x" <-[go.ChannelType go.sendrecv go.string] "$r0");;;
    let: "$r0" := ((FuncResolve go.make1 [go.ChannelType go.sendrecv go.string] #()) #()) in
    do:  ("x" <-[go.ChannelType go.sendrecv go.string] "$r0");;;
    let: "$go" := (λ: <>,
      exception_do (do:  (let: "$chan" := (![go.ChannelType go.sendrecv go.string] "x") in
      let: "$v" := #"Foo"%go in
      chan.send go.string "$chan" "$v");;;
      do:  (let: "$chan" := (![go.ChannelType go.sendrecv go.string] "x") in
      let: "$v" := #"Foo"%go in
      chan.send go.string "$chan" "$v");;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "y" := (GoAlloc go.string (GoZeroVal go.string #())) in
    let: ("$ret0", "$ret1") := (chan.receive go.string (![go.ChannelType go.sendrecv go.string] "x")) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("y" <-[go.string] "$r0");;;
    do:  ("ok" <-[go.bool] "$r1");;;
    let: "$r0" := (Fst (chan.receive go.string (![go.ChannelType go.sendrecv go.string] "x"))) in
    do:  ("y" <-[go.string] "$r0");;;
    (if: ![go.bool] "ok"
    then
      let: "$r0" := ((![go.string] "y") +⟨go.string⟩ #" "%go) in
      do:  ("y" <-[go.string] "$r0")
    else do:  #());;;
    return: #()).

Definition f {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.f"%go.

(* go: chan.go:20:6 *)
Definition fⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (#(W64 0))).

Definition chanSelect {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.chanSelect"%go.

(* modified version of example from https://go.dev/ref/spec#Select_statements

   go: chan.go:25:6 *)
Definition chanSelectⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "a" := (GoAlloc (go.SliceType go.int) (GoZeroVal (go.SliceType go.int) #())) in
    let: "c4" := (GoAlloc (go.ChannelType go.sendrecv go.int) (GoZeroVal (go.ChannelType go.sendrecv go.int) #())) in
    let: "c3" := (GoAlloc (go.ChannelType go.sendrecv go.int) (GoZeroVal (go.ChannelType go.sendrecv go.int) #())) in
    let: "c2" := (GoAlloc (go.ChannelType go.sendrecv go.int) (GoZeroVal (go.ChannelType go.sendrecv go.int) #())) in
    let: "c1" := (GoAlloc (go.ChannelType go.sendrecv go.int) (GoZeroVal (go.ChannelType go.sendrecv go.int) #())) in
    let: "c" := (GoAlloc (go.ChannelType go.sendrecv go.int) (GoZeroVal (go.ChannelType go.sendrecv go.int) #())) in
    let: "i2" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "i1" := (GoAlloc go.int (GoZeroVal go.int #())) in
    chan.select_nonblocking [chan.select_receive go.int (![go.ChannelType go.sendrecv go.int] "c3") (λ: "$recvVal",
       do:  #()
       ); chan.select_receive go.int (![go.ChannelType go.sendrecv go.int] "c1") (λ: "$recvVal",
       let: "$r0" := (Fst "$recvVal") in
       do:  ("i1" <-[go.int] "$r0");;;
       do:  (let: "$a0" := ((let: "$sl0" := (InterfaceMake go.string #"received "%go) in
       let: "$sl1" := (InterfaceMake go.int (![go.int] "i1")) in
       let: "$sl2" := (InterfaceMake go.string #" from c1
       "%go) in
       CompositeLiteral (go.InterfaceType []) (LiteralValue [KeyedElement None (ElementExpression "$sl0"); KeyedElement None (ElementExpression "$sl1"); KeyedElement None (ElementExpression "$sl2")]))) in
       (FuncResolve fmt.Print [] #()) "$a0")
       ); chan.select_send go.int (![go.ChannelType go.sendrecv go.int] "c2") (![go.int] "i2") (λ: <>,
       do:  (let: "$a0" := ((let: "$sl0" := (InterfaceMake go.string #"sent "%go) in
       let: "$sl1" := (InterfaceMake go.int (![go.int] "i2")) in
       let: "$sl2" := (InterfaceMake go.string #" to c2
       "%go) in
       CompositeLiteral (go.InterfaceType []) (LiteralValue [KeyedElement None (ElementExpression "$sl0"); KeyedElement None (ElementExpression "$sl1"); KeyedElement None (ElementExpression "$sl2")]))) in
       (FuncResolve fmt.Print [] #()) "$a0")
       ); chan.select_receive go.int (![go.ChannelType go.sendrecv go.int] "c3") (λ: "$recvVal",
       let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
       let: "i3" := (GoAlloc go.int (GoZeroVal go.int #())) in
       let: ("$ret0", "$ret1") := "$recvVal" in
       let: "$r0" := "$ret0" in
       let: "$r1" := "$ret1" in
       do:  ("i3" <-[go.int] "$r0");;;
       do:  ("ok" <-[go.bool] "$r1");;;
       (if: ![go.bool] "ok"
       then
         do:  (let: "$a0" := ((let: "$sl0" := (InterfaceMake go.string #"received "%go) in
         let: "$sl1" := (InterfaceMake go.int (![go.int] "i3")) in
         let: "$sl2" := (InterfaceMake go.string #" from c3
         "%go) in
         CompositeLiteral (go.InterfaceType []) (LiteralValue [KeyedElement None (ElementExpression "$sl0"); KeyedElement None (ElementExpression "$sl1"); KeyedElement None (ElementExpression "$sl2")]))) in
         (FuncResolve fmt.Print [] #()) "$a0")
       else
         do:  (let: "$a0" := ((let: "$sl0" := (InterfaceMake go.string #"c3 is closed
         "%go) in
         CompositeLiteral (go.InterfaceType []) (LiteralValue [KeyedElement None (ElementExpression "$sl0")]))) in
         (FuncResolve fmt.Print [] #()) "$a0"))
       ); chan.select_receive go.int (![go.ChannelType go.sendrecv go.int] "c4") (λ: "$recvVal",
       let: "$r0" := (Fst "$recvVal") in
       do:  ((IndexRef (go.SliceType go.int) (![go.SliceType go.int] "a", (FuncResolve f [] #()) #())) <-[go.int] "$r0");;;
       do:  #()
       )] (λ: <>,
      do:  (let: "$a0" := ((let: "$sl0" := (InterfaceMake go.string #"no communication
      "%go) in
      CompositeLiteral (go.InterfaceType []) (LiteralValue [KeyedElement None (ElementExpression "$sl0")]))) in
      (FuncResolve fmt.Print [] #()) "$a0")
      );;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      chan.select_blocking [chan.select_send go.int (![go.ChannelType go.sendrecv go.int] "c") #(W64 0) (λ: <>,
         do:  #()
         ); chan.select_send go.int (![go.ChannelType go.sendrecv go.int] "c") #(W64 1) (λ: <>,
         do:  #()
         )]);;;
    chan.select_blocking [];;;
    return: #()).

Definition chanDirectional {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.chanDirectional"%go.

(* go: chan.go:59:6 *)
Definition chanDirectionalⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc (go.ChannelType go.recvonly go.uint64) (GoZeroVal (go.ChannelType go.recvonly go.uint64) #())) in
    let: "y" := (GoAlloc (go.ChannelType go.sendonly go.string) (GoZeroVal (go.ChannelType go.sendonly go.string) #())) in
    do:  (Fst (chan.receive go.uint64 (![go.ChannelType go.recvonly go.uint64] "x")));;;
    do:  (let: "$chan" := (![go.ChannelType go.sendonly go.string] "y") in
    let: "$v" := #""%go in
    chan.send go.string "$chan" "$v");;;
    return: #()).

Definition chanRange {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.chanRange"%go.

(* go: chan.go:66:6 *)
Definition chanRangeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc (go.ChannelType go.sendrecv go.uint64) (GoZeroVal (go.ChannelType go.sendrecv go.uint64) #())) in
    let: "$range" := (![go.ChannelType go.sendrecv go.uint64] "x") in
    (let: "y" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    chan.for_range go.uint64 "$range" (λ: "$key",
      do:  ("y" <-[go.uint64] "$key");;;
      do:  (let: "$a0" := ((let: "$sl0" := (InterfaceMake go.uint64 (![go.uint64] "y")) in
      CompositeLiteral (go.InterfaceType []) (LiteralValue [KeyedElement None (ElementExpression "$sl0")]))) in
      (FuncResolve fmt.Print [] #()) "$a0")));;;
    let: "$range" := (![go.ChannelType go.sendrecv go.uint64] "x") in
    (let: "x" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    chan.for_range go.uint64 "$range" (λ: "$key",
      do:  ("x" <-[go.uint64] "$key");;;
      do:  (let: "$a0" := ((let: "$sl0" := (InterfaceMake go.uint64 (![go.uint64] "x")) in
      CompositeLiteral (go.InterfaceType []) (LiteralValue [KeyedElement None (ElementExpression "$sl0")]))) in
      (FuncResolve fmt.Print [] #()) "$a0")));;;
    let: "$range" := (![go.ChannelType go.sendrecv go.uint64] "x") in
    chan.for_range go.uint64 "$range" (λ: "$key",
      do:  #());;;
    return: #()).

Definition importantStructⁱᵐᵖˡ : go.type := go.StructType [
].

Definition importantStruct : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.importantStruct"%go [].

Module importantStruct.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
}.
#[global] Instance zero_val : ZeroVal t := {| zero_val := mk|}.
End def.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.

End importantStruct.

Class importantStruct_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] importantStruct_zero_val  :: go.GoZeroValEq importantStruct importantStruct.t;
}.

Definition doSubtleThings {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.doSubtleThings"%go.

(* doSubtleThings does a number of subtle things:

   (actually, it does nothing)

   go: comments.go:12:6 *)
Definition doSubtleThingsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (do:  #()).

Definition hasStartComment {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.hasStartComment"%go.

(* This comment starts a Coq comment ( *

   go: comments.go:15:6 *)
Definition hasStartCommentⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (do:  #()).

Definition hasEndComment {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.hasEndComment"%go.

(* This comment * ) ends a Coq comment

   go: comments.go:18:6 *)
Definition hasEndCommentⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (do:  #()).

Definition condvarWrapping {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.condvarWrapping"%go.

(* go: condvar.go:5:6 *)
Definition condvarWrappingⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "mu" := (GoAlloc (go.PointerType sync.Mutex) (GoZeroVal (go.PointerType sync.Mutex) #())) in
    let: "$r0" := (GoAlloc sync.Mutex (GoZeroVal sync.Mutex #())) in
    do:  ("mu" <-[go.PointerType sync.Mutex] "$r0");;;
    let: "cond1" := (GoAlloc (go.PointerType sync.Cond) (GoZeroVal (go.PointerType sync.Cond) #())) in
    let: "$r0" := (let: "$a0" := (InterfaceMake (go.PointerType sync.Mutex) (![go.PointerType sync.Mutex] "mu")) in
    (FuncResolve sync.NewCond [] #()) "$a0") in
    do:  ("cond1" <-[go.PointerType sync.Cond] "$r0");;;
    let: "$r0" := (GoAlloc sync.Mutex (GoZeroVal sync.Mutex #())) in
    do:  ("mu" <-[go.PointerType sync.Mutex] "$r0");;;
    do:  ((MethodResolve (go.PointerType sync.Cond) "Wait"%go #() (![go.PointerType sync.Cond] "cond1")) #());;;
    return: #()).

Definition GlobalConstant {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #"foo"%go.

(* an untyped string *)
Definition UntypedStringConstant {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "bar"%go.

Definition UntypedInt {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Z := 13.

Definition OtherUntypedInt {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Z := 26.

Definition TypedInt {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 32).

Definition ConstWithArith {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 100).

Definition TypedInt32 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W32 3).

Definition DivisionInConst {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 511).

(* 517 *)
Definition ModInConst {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 517).

(* 5 *)
Definition ModInConstParens {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 5).

Definition SignedIntegerExample {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 (-37)).

Definition First {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Z := 0.

Definition Second {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Z := 1.

Definition Third {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Z := 2.

Definition ComplicatedFirst {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 3).

Definition ComplicatedSecond {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 5).

Definition ComplicatedThird {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 7).

Definition useUntypedInt {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.useUntypedInt"%go.

(* go: const.go:37:6 *)
Definition useUntypedIntⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (#(W64 UntypedInt) +⟨go.uint64⟩ TypedInt)).

Definition useUntypedString {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.useUntypedString"%go.

(* go: const.go:41:6 *)
Definition useUntypedStringⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (#UntypedStringConstant)).

Definition conditionalReturn {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.conditionalReturn"%go.

(* go: control_flow.go:3:6 *)
Definition conditionalReturnⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x",
    exception_do (let: "x" := (GoAlloc go.bool "x") in
    (if: ![go.bool] "x"
    then return: (#(W64 0))
    else do:  #());;;
    return: (#(W64 1))).

Definition alwaysReturn {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.alwaysReturn"%go.

(* go: control_flow.go:10:6 *)
Definition alwaysReturnⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x",
    exception_do (let: "x" := (GoAlloc go.bool "x") in
    (if: ![go.bool] "x"
    then return: (#(W64 0))
    else return: (#(W64 1)))).

Definition alwaysReturnInNestedBranches {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.alwaysReturnInNestedBranches"%go.

(* go: control_flow.go:18:6 *)
Definition alwaysReturnInNestedBranchesⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x",
    exception_do (let: "x" := (GoAlloc go.bool "x") in
    (if: (~ (![go.bool] "x"))
    then
      (if: ![go.bool] "x"
      then return: (#(W64 0))
      else return: (#(W64 1)))
    else do:  #());;;
    let: "y" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 14) in
    do:  ("y" <-[go.uint64] "$r0");;;
    return: (![go.uint64] "y")).

Definition earlyReturn {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.earlyReturn"%go.

(* go: control_flow.go:32:6 *)
Definition earlyReturnⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x",
    exception_do (let: "x" := (GoAlloc go.bool "x") in
    (if: ![go.bool] "x"
    then return: (#())
    else do:  #());;;
    return: #()).

Definition conditionalAssign {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.conditionalAssign"%go.

(* go: control_flow.go:38:6 *)
Definition conditionalAssignⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x",
    exception_do (let: "x" := (GoAlloc go.bool "x") in
    let: "y" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    (if: ![go.bool] "x"
    then
      let: "$r0" := #(W64 1) in
      do:  ("y" <-[go.uint64] "$r0")
    else
      let: "$r0" := #(W64 2) in
      do:  ("y" <-[go.uint64] "$r0"));;;
    do:  ("y" <-[go.uint64] ((![go.uint64] "y") +⟨go.uint64⟩ #(W64 1)));;;
    return: (![go.uint64] "y")).

Definition elseIf {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.elseIf"%go.

(* go: control_flow.go:49:6 *)
Definition elseIfⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x" "y",
    exception_do (let: "y" := (GoAlloc go.bool "y") in
    let: "x" := (GoAlloc go.bool "x") in
    (if: ![go.bool] "x"
    then return: (#(W64 0))
    else
      (if: ![go.bool] "y"
      then return: (#(W64 1))
      else return: (#(W64 2))))).

Definition ifStmtInitialization {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.ifStmtInitialization"%go.

(* go: control_flow.go:59:6 *)
Definition ifStmtInitializationⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x",
    exception_do (let: "x" := (GoAlloc go.uint64 "x") in
    let: "f" := (GoAlloc (go.FunctionType (go.Signature [] false [go.uint64])) (GoZeroVal (go.FunctionType (go.Signature [] false [go.uint64])) #())) in
    let: "$r0" := (λ: <>,
      exception_do (return: (![go.uint64] "x"))
      ) in
    do:  ("f" <-[go.FunctionType (go.Signature [] false [go.uint64])] "$r0");;;
    (do:  ((![go.FunctionType (go.Signature [] false [go.uint64])] "f") #());;;
    (if: (![go.uint64] "x") =⟨go.uint64⟩ #(W64 2)
    then do:  #()
    else
      (let: "z" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: "$r0" := (![go.uint64] "x") in
      do:  ("z" <-[go.uint64] "$r0");;;
      (if: (![go.uint64] "z") =⟨go.uint64⟩ #(W64 1)
      then do:  #()
      else
        (let: "y" := (GoAlloc go.int (GoZeroVal go.int #())) in
        let: "$r0" := #(W64 94) in
        do:  ("y" <-[go.int] "$r0");;;
        (if: (![go.int] "y") =⟨go.int⟩ #(W64 30)
        then do:  #()
        else
          (let: "$r0" := #(W64 10) in
          do:  ("z" <-[go.uint64] "$r0");;;
          (if: (![go.uint64] "x") =⟨go.uint64⟩ #(W64 30)
          then do:  #()
          else do:  #()))))))));;;
    (let: "y" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 10) in
    do:  ("y" <-[go.uint64] "$r0");;;
    (if: (![go.uint64] "x") =⟨go.uint64⟩ #(W64 0)
    then return: (![go.uint64] "y")
    else return: ((![go.uint64] "y") -⟨go.uint64⟩ #(W64 1))))).

Definition stringWrapperⁱᵐᵖˡ : go.type := go.string.

Definition stringWrapper : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.stringWrapper"%go [].

Module stringWrapper.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t  : Type := go_string.
End def.
End stringWrapper.

Class stringWrapper_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] stringWrapper_zero_val  :: go.GoZeroValEq stringWrapper stringWrapper.t;
}.

Definition typedLiteral {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.typedLiteral"%go.

(* go: conversions.go:5:6 *)
Definition typedLiteralⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (#(W64 3))).

Definition literalCast {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.literalCast"%go.

(* go: conversions.go:9:6 *)
Definition literalCastⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 2) in
    do:  ("x" <-[go.uint64] "$r0");;;
    return: ((![go.uint64] "x") +⟨go.uint64⟩ #(W64 2))).

Definition castInt {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.castInt"%go.

(* go: conversions.go:15:6 *)
Definition castIntⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "p",
    exception_do (let: "p" := (GoAlloc (go.SliceType go.byte) "p") in
    return: (s_to_w64 (let: "$a0" := (![go.SliceType go.byte] "p") in
     (FuncResolve go.len [go.SliceType go.byte] #()) "$a0"))).

Definition stringToByteSlice {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.stringToByteSlice"%go.

(* go: conversions.go:19:6 *)
Definition stringToByteSliceⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s",
    exception_do (let: "s" := (GoAlloc go.string "s") in
    let: "p" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (string.to_bytes (![go.string] "s")) in
    do:  ("p" <-[go.SliceType go.byte] "$r0");;;
    return: (![go.SliceType go.byte] "p")).

Definition byteSliceToString {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.byteSliceToString"%go.

(* go: conversions.go:25:6 *)
Definition byteSliceToStringⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "p",
    exception_do (let: "p" := (GoAlloc (go.SliceType go.byte) "p") in
    let: "s" := (GoAlloc go.string (GoZeroVal go.string #())) in
    let: "$r0" := (string.from_bytes (![go.SliceType go.byte] "p")) in
    do:  ("s" <-[go.string] "$r0");;;
    return: (![go.string] "s")).

Definition stringToStringWrapper {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.stringToStringWrapper"%go.

(* go: conversions.go:31:6 *)
Definition stringToStringWrapperⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s",
    exception_do (let: "s" := (GoAlloc go.string "s") in
    return: (![go.string] "s")).

Definition stringWrapperToString {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.stringWrapperToString"%go.

(* go: conversions.go:35:6 *)
Definition stringWrapperToStringⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s",
    exception_do (let: "s" := (GoAlloc stringWrapper "s") in
    return: (![stringWrapper] "s")).

Definition Uint32ⁱᵐᵖˡ : go.type := go.uint32.

Definition Uint32 : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.Uint32"%go [].

Module Uint32.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t  : Type := w32.
End def.
End Uint32.

Class Uint32_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Uint32_zero_val  :: go.GoZeroValEq Uint32 Uint32.t;
}.

Definition testU32NewtypeLen {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.testU32NewtypeLen"%go.

(* go: conversions.go:41:6 *)
Definition testU32NewtypeLenⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "s" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 20)) in
    do:  ("s" <-[go.SliceType go.byte] "$r0");;;
    return: ((s_to_w32 (let: "$a0" := (![go.SliceType go.byte] "s") in
     (FuncResolve go.len [go.SliceType go.byte] #()) "$a0")) =⟨go.uint32⟩ #(W32 20))).

Definition numWrapper : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.numWrapper"%go [].

(* go: conversions.go:48:22 *)
Definition numWrapper__incⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "n" <>,
    exception_do (let: "n" := (GoAlloc (go.PointerType numWrapper) "n") in
    do:  ((![go.PointerType numWrapper] "n") <-[numWrapper] ((![numWrapper] (![go.PointerType numWrapper] "n")) +⟨numWrapper⟩ #(W64 1)));;;
    return: #()).

Definition numWrapperⁱᵐᵖˡ : go.type := go.int.

Module numWrapper.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t  : Type := w64.
End def.
End numWrapper.

Class numWrapper_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] numWrapper_zero_val  :: go.GoZeroValEq numWrapper numWrapper.t;
  #[global] numWrapper'ptr_inc_unfold :: MethodUnfold (go.PointerType (numWrapper)) "inc" (numWrapper__incⁱᵐᵖˡ);
}.

Definition testNumWrapper {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.testNumWrapper"%go.

(* go: conversions.go:52:6 *)
Definition testNumWrapperⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "n" := (GoAlloc numWrapper (GoZeroVal numWrapper #())) in
    let: "$r0" := #(W64 0) in
    do:  ("n" <-[numWrapper] "$r0");;;
    do:  ((MethodResolve (go.PointerType numWrapper) "inc"%go #() "n") #());;;
    return: #()).

Definition testCopySimple {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.testCopySimple"%go.

(* go: copy.go:3:6 *)
Definition testCopySimpleⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 10)) in
    do:  ("x" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := #(W8 1) in
    do:  ((IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "x", #(W64 3))) <-[go.byte] "$r0");;;
    let: "y" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 10)) in
    do:  ("y" <-[go.SliceType go.byte] "$r0");;;
    do:  (let: "$a0" := (![go.SliceType go.byte] "y") in
    let: "$a1" := (![go.SliceType go.byte] "x") in
    (FuncResolve go.copy [go.SliceType go.byte] #()) "$a0" "$a1");;;
    return: ((![go.byte] (IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "y", #(W64 3)))) =⟨go.byte⟩ #(W8 1))).

Definition testCopyDifferentLengths {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.testCopyDifferentLengths"%go.

(* go: copy.go:11:6 *)
Definition testCopyDifferentLengthsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 15)) in
    do:  ("x" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := #(W8 1) in
    do:  ((IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "x", #(W64 3))) <-[go.byte] "$r0");;;
    let: "$r0" := #(W8 2) in
    do:  ((IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "x", #(W64 12))) <-[go.byte] "$r0");;;
    let: "y" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 10)) in
    do:  ("y" <-[go.SliceType go.byte] "$r0");;;
    let: "n" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (s_to_w64 (let: "$a0" := (![go.SliceType go.byte] "y") in
    let: "$a1" := (![go.SliceType go.byte] "x") in
    (FuncResolve go.copy [go.SliceType go.byte] #()) "$a0" "$a1")) in
    do:  ("n" <-[go.uint64] "$r0");;;
    return: (((![go.uint64] "n") =⟨go.uint64⟩ #(W64 10)) && ((![go.byte] (IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "y", #(W64 3)))) =⟨go.byte⟩ #(W8 1)))).

Definition atomicCreateStub {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.atomicCreateStub"%go.

(* go: data_structures.go:7:6 *)
Definition atomicCreateStubⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "dir" "fname" "data",
    exception_do (let: "data" := (GoAlloc (go.SliceType go.byte) "data") in
    let: "fname" := (GoAlloc go.string "fname") in
    let: "dir" := (GoAlloc go.string "dir") in
    do:  #()).

Definition useSlice {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.useSlice"%go.

(* go: data_structures.go:9:6 *)
Definition useSliceⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "s" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 1)) in
    do:  ("s" <-[go.SliceType go.byte] "$r0");;;
    let: "s1" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "s") in
    let: "$a1" := (![go.SliceType go.byte] "s") in
    (FuncResolve go.append [go.SliceType go.byte] #()) "$a0" "$a1") in
    do:  ("s1" <-[go.SliceType go.byte] "$r0");;;
    do:  (let: "$a0" := #"dir"%go in
    let: "$a1" := #"file"%go in
    let: "$a2" := (![go.SliceType go.byte] "s1") in
    (FuncResolve atomicCreateStub [] #()) "$a0" "$a1" "$a2");;;
    return: #()).

Definition useSliceIndexing {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.useSliceIndexing"%go.

(* go: data_structures.go:15:6 *)
Definition useSliceIndexingⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "s" := (GoAlloc (go.SliceType go.uint64) (GoZeroVal (go.SliceType go.uint64) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType go.uint64] #()) #(W64 2)) in
    do:  ("s" <-[go.SliceType go.uint64] "$r0");;;
    let: "$r0" := #(W64 2) in
    do:  ((IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "s", #(W64 1))) <-[go.uint64] "$r0");;;
    let: "x" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (![go.uint64] (IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "s", #(W64 0)))) in
    do:  ("x" <-[go.uint64] "$r0");;;
    return: (![go.uint64] "x")).

Definition useMap {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.useMap"%go.

(* go: data_structures.go:22:6 *)
Definition useMapⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "m" := (GoAlloc (go.MapType go.uint64 (go.SliceType go.byte)) (GoZeroVal (go.MapType go.uint64 (go.SliceType go.byte)) #())) in
    let: "$r0" := ((FuncResolve go.make1 [go.MapType go.uint64 (go.SliceType go.byte)] #()) #()) in
    do:  ("m" <-[go.MapType go.uint64 (go.SliceType go.byte)] "$r0");;;
    let: "$r0" := #slice.nil in
    do:  (map.insert (![go.MapType go.uint64 (go.SliceType go.byte)] "m") #(W64 1) "$r0");;;
    let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "x" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: ("$ret0", "$ret1") := (map.get (![go.MapType go.uint64 (go.SliceType go.byte)] "m") #(W64 2)) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("x" <-[go.SliceType go.byte] "$r0");;;
    do:  ("ok" <-[go.bool] "$r1");;;
    (if: ![go.bool] "ok"
    then return: (#())
    else do:  #());;;
    let: "$r0" := (![go.SliceType go.byte] "x") in
    do:  (map.insert (![go.MapType go.uint64 (go.SliceType go.byte)] "m") #(W64 3) "$r0");;;
    return: #()).

Definition usePtr {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.usePtr"%go.

(* go: data_structures.go:32:6 *)
Definition usePtrⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "p" := (GoAlloc (go.PointerType go.uint64) (GoZeroVal (go.PointerType go.uint64) #())) in
    let: "$r0" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    do:  ("p" <-[go.PointerType go.uint64] "$r0");;;
    let: "$r0" := #(W64 1) in
    do:  ((![go.PointerType go.uint64] "p") <-[go.uint64] "$r0");;;
    let: "x" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (![go.uint64] (![go.PointerType go.uint64] "p")) in
    do:  ("x" <-[go.uint64] "$r0");;;
    let: "$r0" := (![go.uint64] "x") in
    do:  ((![go.PointerType go.uint64] "p") <-[go.uint64] "$r0");;;
    return: #()).

Definition iterMapKeysAndValues {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.iterMapKeysAndValues"%go.

(* go: data_structures.go:39:6 *)
Definition iterMapKeysAndValuesⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "m",
    exception_do (let: "m" := (GoAlloc (go.MapType go.uint64 go.uint64) "m") in
    let: "sumPtr" := (GoAlloc (go.PointerType go.uint64) (GoZeroVal (go.PointerType go.uint64) #())) in
    let: "$r0" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    do:  ("sumPtr" <-[go.PointerType go.uint64] "$r0");;;
    let: "$range" := (![go.MapType go.uint64 go.uint64] "m") in
    (let: "v" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "k" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    map.for_range "$range" (λ: "$key" "value",
      do:  ("v" <-[go.uint64] "$value");;;
      do:  ("k" <-[go.uint64] "$key");;;
      let: "sum" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: "$r0" := (![go.uint64] (![go.PointerType go.uint64] "sumPtr")) in
      do:  ("sum" <-[go.uint64] "$r0");;;
      let: "$r0" := (((![go.uint64] "sum") +⟨go.uint64⟩ (![go.uint64] "k")) +⟨go.uint64⟩ (![go.uint64] "v")) in
      do:  ((![go.PointerType go.uint64] "sumPtr") <-[go.uint64] "$r0")));;;
    let: "sum" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (![go.uint64] (![go.PointerType go.uint64] "sumPtr")) in
    do:  ("sum" <-[go.uint64] "$r0");;;
    return: (![go.uint64] "sum")).

Definition iterMapKeys {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.iterMapKeys"%go.

(* go: data_structures.go:49:6 *)
Definition iterMapKeysⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "m",
    exception_do (let: "m" := (GoAlloc (go.MapType go.uint64 go.uint64) "m") in
    let: "keysSlice" := (GoAlloc (go.SliceType go.uint64) (GoZeroVal (go.SliceType go.uint64) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType go.uint64] #()) #(W64 0)) in
    do:  ("keysSlice" <-[go.SliceType go.uint64] "$r0");;;
    let: "keysRef" := (GoAlloc (go.PointerType (go.SliceType go.uint64)) (GoZeroVal (go.PointerType (go.SliceType go.uint64)) #())) in
    let: "$r0" := (GoAlloc (go.SliceType go.uint64) (GoZeroVal (go.SliceType go.uint64) #())) in
    do:  ("keysRef" <-[go.PointerType (go.SliceType go.uint64)] "$r0");;;
    let: "$r0" := (![go.SliceType go.uint64] "keysSlice") in
    do:  ((![go.PointerType (go.SliceType go.uint64)] "keysRef") <-[go.SliceType go.uint64] "$r0");;;
    let: "$range" := (![go.MapType go.uint64 go.uint64] "m") in
    (let: "k" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    map.for_range "$range" (λ: "$key" "value",
      do:  ("k" <-[go.uint64] "$key");;;
      let: "keys" := (GoAlloc (go.SliceType go.uint64) (GoZeroVal (go.SliceType go.uint64) #())) in
      let: "$r0" := (![go.SliceType go.uint64] (![go.PointerType (go.SliceType go.uint64)] "keysRef")) in
      do:  ("keys" <-[go.SliceType go.uint64] "$r0");;;
      let: "newKeys" := (GoAlloc (go.SliceType go.uint64) (GoZeroVal (go.SliceType go.uint64) #())) in
      let: "$r0" := (let: "$a0" := (![go.SliceType go.uint64] "keys") in
      let: "$a1" := ((let: "$sl0" := (![go.uint64] "k") in
      CompositeLiteral go.uint64 (LiteralValue [KeyedElement None (ElementExpression "$sl0")]))) in
      (FuncResolve go.append [go.SliceType go.uint64] #()) "$a0" "$a1") in
      do:  ("newKeys" <-[go.SliceType go.uint64] "$r0");;;
      let: "$r0" := (![go.SliceType go.uint64] "newKeys") in
      do:  ((![go.PointerType (go.SliceType go.uint64)] "keysRef") <-[go.SliceType go.uint64] "$r0")));;;
    let: "keys" := (GoAlloc (go.SliceType go.uint64) (GoZeroVal (go.SliceType go.uint64) #())) in
    let: "$r0" := (![go.SliceType go.uint64] (![go.PointerType (go.SliceType go.uint64)] "keysRef")) in
    do:  ("keys" <-[go.SliceType go.uint64] "$r0");;;
    return: (![go.SliceType go.uint64] "keys")).

Definition getRandom {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.getRandom"%go.

(* go: data_structures.go:62:6 *)
Definition getRandomⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "r" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := ((FuncResolve primitive.RandomUint64 [] #()) #()) in
    do:  ("r" <-[go.uint64] "$r0");;;
    return: (![go.uint64] "r")).

Definition diskWrapperⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "d"%go disk.Disk)
].

Definition diskWrapper : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.diskWrapper"%go [].

Module diskWrapper.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  d : disk.Disk.t;
}.
#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
End def.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.

End diskWrapper.

Class diskWrapper_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] diskWrapper_zero_val  :: go.GoZeroValEq diskWrapper diskWrapper.t;
}.

Definition diskArgument {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.diskArgument"%go.

(* go: disk.go:9:6 *)
Definition diskArgumentⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "d",
    exception_do (let: "d" := (GoAlloc disk.Disk "d") in
    let: "b" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (let: "$a0" := #(W64 0) in
    (MethodResolve disk.Disk "Read"%go #() (![disk.Disk] "d")) "$a0") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    do:  (let: "$a0" := #(W64 1) in
    let: "$a1" := (![go.SliceType go.byte] "b") in
    (MethodResolve disk.Disk "Write"%go #() (![disk.Disk] "d")) "$a0" "$a1");;;
    return: #()).

Definition embedA : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.embedA"%go [].

(* go: embedded.go:19:17 *)
Definition embedA__Fooⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "a" <>,
    exception_do (let: "a" := (GoAlloc embedA "a") in
    return: (#(W64 0))).

(* go: embedded.go:27:18 *)
Definition embedA__Barⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "a" <>,
    exception_do (let: "a" := (GoAlloc (go.PointerType embedA) "a") in
    return: (#(W64 13))).

Definition embedAⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "a"%go go.uint64)
].

Module embedA.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  a : w64;
}.
#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
End def.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.

End embedA.

Class embedA_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] embedA_zero_val  :: go.GoZeroValEq embedA embedA.t;
  #[global] embedA'ptr_Foo_unfold :: MethodUnfold (embedA) "Foo" (embedA__Fooⁱᵐᵖˡ);
  #[global] embedA'ptr_Bar_unfold :: MethodUnfold (go.PointerType (embedA)) "Bar" (embedA__Barⁱᵐᵖˡ);
  #[global] embedA'ptr_Foo_unfold :: MethodUnfold (go.PointerType (embedA)) "Foo" (λ: "$r", MethodResolve (embedA) Foo #() (![(embedA)] "$r");
}.

Definition embedB : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.embedB"%go [].

(* go: embedded.go:23:17 *)
Definition embedB__Fooⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "a" <>,
    exception_do (let: "a" := (GoAlloc embedB "a") in
    return: (#(W64 10))).

(* go: embedded.go:31:18 *)
Definition embedB__Carⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "a" <>,
    exception_do (let: "a" := (GoAlloc (go.PointerType embedB) "a") in
    return: (#(W64 14))).

Definition embedBⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "embedA"%go embedA)
].

Module embedB.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  embedA : unittest.embedA.t;
}.
#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
End def.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.

End embedB.

Class embedB_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] embedB_zero_val  :: go.GoZeroValEq embedB embedB.t;
  #[global] embedB'ptr_Foo_unfold :: MethodUnfold (embedB) "Foo" (embedB__Fooⁱᵐᵖˡ);
  #[global] embedB'ptr_Bar_unfold :: MethodUnfold (go.PointerType (embedB)) "Bar" (λ: "$r", MethodResolve (go.PointerType embedA) Bar #() (StructFieldRef embedB #"embedA"%go "$r"));
  #[global] embedB'ptr_Car_unfold :: MethodUnfold (go.PointerType (embedB)) "Car" (embedB__Carⁱᵐᵖˡ);
  #[global] embedB'ptr_Foo_unfold :: MethodUnfold (go.PointerType (embedB)) "Foo" (λ: "$r", MethodResolve (embedB) Foo #() (![(embedB)] "$r");
}.

Definition embedC : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.embedC"%go [].

Definition embedCⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "embedB"%go (go.PointerType embedB))
].

Module embedC.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  embedB : loc;
}.
#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
End def.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.

End embedC.

Class embedC_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] embedC_zero_val  :: go.GoZeroValEq embedC embedC.t;
  #[global] embedC'ptr_Bar_unfold :: MethodUnfold (embedC) "Bar" (λ: "$r", MethodResolve (go.PointerType embedB) Bar #() (StructFieldGet (embedC) "embedB" "$r" ))%V;
  #[global] embedC'ptr_Car_unfold :: MethodUnfold (embedC) "Car" (λ: "$r", MethodResolve (go.PointerType embedB) Car #() (StructFieldGet (embedC) "embedB" "$r" ))%V;
  #[global] embedC'ptr_Foo_unfold :: MethodUnfold (embedC) "Foo" (λ: "$r", MethodResolve (go.PointerType embedB) Foo #() (StructFieldGet (embedC) "embedB" "$r" ))%V;
  #[global] embedC'ptr_Bar_unfold :: MethodUnfold (go.PointerType (embedC)) "Bar" (λ: "$r", MethodResolve (go.PointerType embedB) Bar #() (![go.PointerType embedB] (StructFieldRef embedC #"embedB"%go "$r")));
  #[global] embedC'ptr_Car_unfold :: MethodUnfold (go.PointerType (embedC)) "Car" (λ: "$r", MethodResolve (go.PointerType embedB) Car #() (![go.PointerType embedB] (StructFieldRef embedC #"embedB"%go "$r")));
  #[global] embedC'ptr_Foo_unfold :: MethodUnfold (go.PointerType (embedC)) "Foo" (λ: "$r", MethodResolve (go.PointerType embedB) Foo #() (![go.PointerType embedB] (StructFieldRef embedC #"embedB"%go "$r")));
}.

Definition embedD : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.embedD"%go [].

Definition embedDⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "embedC"%go embedC)
].

Module embedD.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  embedC : unittest.embedC.t;
}.
#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
End def.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.

End embedD.

Class embedD_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] embedD_zero_val  :: go.GoZeroValEq embedD embedD.t;
  #[global] embedD'ptr_Bar_unfold :: MethodUnfold (embedD) "Bar" (λ: "$r", MethodResolve embedC Bar #() (StructFieldGet (embedD) "embedC" "$r" ))%V;
  #[global] embedD'ptr_Car_unfold :: MethodUnfold (embedD) "Car" (λ: "$r", MethodResolve embedC Car #() (StructFieldGet (embedD) "embedC" "$r" ))%V;
  #[global] embedD'ptr_Foo_unfold :: MethodUnfold (embedD) "Foo" (λ: "$r", MethodResolve embedC Foo #() (StructFieldGet (embedD) "embedC" "$r" ))%V;
  #[global] embedD'ptr_Bar_unfold :: MethodUnfold (go.PointerType (embedD)) "Bar" (λ: "$r", MethodResolve (go.PointerType embedC) Bar #() (StructFieldRef embedD #"embedC"%go "$r"));
  #[global] embedD'ptr_Car_unfold :: MethodUnfold (go.PointerType (embedD)) "Car" (λ: "$r", MethodResolve (go.PointerType embedC) Car #() (StructFieldRef embedD #"embedC"%go "$r"));
  #[global] embedD'ptr_Foo_unfold :: MethodUnfold (go.PointerType (embedD)) "Foo" (λ: "$r", MethodResolve (go.PointerType embedC) Foo #() (StructFieldRef embedD #"embedC"%go "$r"));
}.

Definition returnEmbedVal {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.returnEmbedVal"%go.

(* go: embedded.go:35:6 *)
Definition returnEmbedValⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (CompositeLiteral embedB (LiteralValue []))).

Definition returnEmbedValWithPointer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.returnEmbedValWithPointer"%go.

(* go: embedded.go:39:6 *)
Definition returnEmbedValWithPointerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (CompositeLiteral embedD (LiteralValue []))).

Definition useEmbeddedField {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.useEmbeddedField"%go.

(* go: embedded.go:43:6 *)
Definition useEmbeddedFieldⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "d",
    exception_do (let: "d" := (GoAlloc embedD "d") in
    let: "x" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (![go.uint64] (StructFieldRef embedA "a"%go (StructFieldRef embedB "embedA"%go (![go.PointerType embedB] (StructFieldRef embedC "embedB"%go (StructFieldRef embedD "embedC"%go "d")))))) in
    do:  ("x" <-[go.uint64] "$r0");;;
    let: "$r0" := (![go.uint64] (StructFieldRef embedA "a"%go (StructFieldRef embedB "embedA"%go (![go.PointerType embedB] (StructFieldRef embedC "embedB"%go (StructFieldRef embedD "embedC"%go "d")))))) in
    do:  ("x" <-[go.uint64] "$r0");;;
    let: "$r0" := #(W64 10) in
    do:  ((StructFieldRef embedA "a"%go (StructFieldRef embedB "embedA"%go (![go.PointerType embedB] (StructFieldRef embedC "embedB"%go (StructFieldRef embedD "embedC"%go "d"))))) <-[go.uint64] "$r0");;;
    let: "y" := (GoAlloc (go.PointerType embedD) (GoZeroVal (go.PointerType embedD) #())) in
    let: "$r0" := (GoAlloc embedD (CompositeLiteral embedD (LiteralValue []))) in
    do:  ("y" <-[go.PointerType embedD] "$r0");;;
    let: "$r0" := #(W64 11) in
    do:  ((StructFieldRef embedA "a"%go (StructFieldRef embedB "embedA"%go (![go.PointerType embedB] (StructFieldRef embedC "embedB"%go (StructFieldRef embedD "embedC"%go (![go.PointerType embedD] "y")))))) <-[go.uint64] "$r0");;;
    return: (![go.uint64] "x")).

Definition useEmbeddedValField {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.useEmbeddedValField"%go.

(* go: embedded.go:54:6 *)
Definition useEmbeddedValFieldⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (StructFieldGet embedA "a" (StructFieldGet embedB "embedA" ((FuncResolve returnEmbedVal [] #()) #()))) in
    do:  ("x" <-[go.uint64] "$r0");;;
    let: "$r0" := (![go.uint64] (StructFieldRef embedA "a"%go (StructFieldRef embedB "embedA"%go (StructFieldGet embedC "embedB" (StructFieldGet embedD "embedC" ((FuncResolve returnEmbedValWithPointer [] #()) #())))))) in
    do:  ("x" <-[go.uint64] "$r0");;;
    return: (![go.uint64] "x")).

Definition useEmbeddedMethod {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.useEmbeddedMethod"%go.

(* go: embedded.go:60:6 *)
Definition useEmbeddedMethodⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "d",
    exception_do (let: "d" := (GoAlloc embedD "d") in
    return: (((MethodResolve embedD "Foo"%go #() (![embedD] "d")) #()) =⟨go.uint64⟩ ((MethodResolve embedA "Foo"%go #() (![embedA] (StructFieldRef embedB "embedA"%go (![go.PointerType embedB] (StructFieldRef embedC "embedB"%go (StructFieldRef embedD "embedC"%go "d")))))) #()))).

Definition useEmbeddedMethod2 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.useEmbeddedMethod2"%go.

(* go: embedded.go:64:6 *)
Definition useEmbeddedMethod2ⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "d",
    exception_do (let: "d" := (GoAlloc embedD "d") in
    do:  ((MethodResolve embedD "Car"%go #() (![embedD] "d")) #());;;
    return: (((MethodResolve embedD "Bar"%go #() (![embedD] "d")) #()) =⟨go.uint64⟩ ((MethodResolve (go.PointerType embedB) "Bar"%go #() (![go.PointerType embedB] (StructFieldRef embedC "embedB"%go (StructFieldRef embedD "embedC"%go "d")))) #()))).

Definition empty {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.empty"%go.

(* go: empty_functions.go:3:6 *)
Definition emptyⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (do:  #()).

Definition emptyReturn {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.emptyReturn"%go.

(* go: empty_functions.go:5:6 *)
Definition emptyReturnⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (#());;;
    return: #()).

Definition unnamedParams {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.unnamedParams"%go.

(* go: empty_functions.go:9:6 *)
Definition unnamedParamsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (do:  #()).

Definition anonymousParam {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.anonymousParam"%go.

(* go: empty_functions.go:11:6 *)
Definition anonymousParamⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (do:  #()).

Definition Enc : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.Enc"%go [].

(* go: encoding.go:19:15 *)
Definition Enc__UInt32ⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "e" "x",
    exception_do (let: "e" := (GoAlloc (go.PointerType Enc) "e") in
    let: "x" := (GoAlloc go.uint32 "x") in
    do:  (let: "$a0" := (let: "$a0" := #(W64 4) in
    (MethodResolve (go.PointerType Enc) "consume"%go #() (![go.PointerType Enc] "e")) "$a0") in
    let: "$a1" := (![go.uint32] "x") in
    (FuncResolve primitive.UInt32Put [] #()) "$a0" "$a1");;;
    return: #()).

(* go: encoding.go:15:15 *)
Definition Enc__UInt64ⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "e" "x",
    exception_do (let: "e" := (GoAlloc (go.PointerType Enc) "e") in
    let: "x" := (GoAlloc go.uint64 "x") in
    do:  (let: "$a0" := (let: "$a0" := #(W64 8) in
    (MethodResolve (go.PointerType Enc) "consume"%go #() (![go.PointerType Enc] "e")) "$a0") in
    let: "$a1" := (![go.uint64] "x") in
    (FuncResolve primitive.UInt64Put [] #()) "$a0" "$a1");;;
    return: #()).

(* go: encoding.go:9:15 *)
Definition Enc__consumeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "e" "n",
    exception_do (let: "e" := (GoAlloc (go.PointerType Enc) "e") in
    let: "n" := (GoAlloc go.uint64 "n") in
    let: "b" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (let: "$s" := (![go.SliceType go.byte] (StructFieldRef Enc "p"%go (![go.PointerType Enc] "e"))) in
    Slice (go.SliceType go.byte) ("$s", #(W64 0), ![go.uint64] "n")) in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$s" := (![go.SliceType go.byte] (StructFieldRef Enc "p"%go (![go.PointerType Enc] "e"))) in
    Slice (go.SliceType go.byte) ("$s", ![go.uint64] "n", FuncResolve go.len [go.SliceType go.byte] #() (![go.SliceType go.byte] (StructFieldRef Enc "p"%go (![go.PointerType Enc] "e"))))) in
    do:  ((StructFieldRef Enc "p"%go (![go.PointerType Enc] "e")) <-[go.SliceType go.byte] "$r0");;;
    return: (![go.SliceType go.byte] "b")).

Definition Encⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "p"%go (go.SliceType go.byte))
].

Module Enc.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  p : slice.t;
}.
#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
End def.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.

End Enc.

Class Enc_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Enc_zero_val  :: go.GoZeroValEq Enc Enc.t;
  #[global] Enc'ptr_UInt32_unfold :: MethodUnfold (go.PointerType (Enc)) "UInt32" (Enc__UInt32ⁱᵐᵖˡ);
  #[global] Enc'ptr_UInt64_unfold :: MethodUnfold (go.PointerType (Enc)) "UInt64" (Enc__UInt64ⁱᵐᵖˡ);
  #[global] Enc'ptr_consume_unfold :: MethodUnfold (go.PointerType (Enc)) "consume" (Enc__consumeⁱᵐᵖˡ);
}.

Definition Dec : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.Dec"%go [].

(* go: encoding.go:37:15 *)
Definition Dec__UInt32ⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "d" <>,
    exception_do (let: "d" := (GoAlloc (go.PointerType Dec) "d") in
    return: (let: "$a0" := (let: "$a0" := #(W64 4) in
     (MethodResolve (go.PointerType Dec) "consume"%go #() (![go.PointerType Dec] "d")) "$a0") in
     (FuncResolve primitive.UInt32Get [] #()) "$a0")).

(* go: encoding.go:33:15 *)
Definition Dec__UInt64ⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "d" <>,
    exception_do (let: "d" := (GoAlloc (go.PointerType Dec) "d") in
    return: (let: "$a0" := (let: "$a0" := #(W64 8) in
     (MethodResolve (go.PointerType Dec) "consume"%go #() (![go.PointerType Dec] "d")) "$a0") in
     (FuncResolve primitive.UInt64Get [] #()) "$a0")).

(* go: encoding.go:27:15 *)
Definition Dec__consumeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "d" "n",
    exception_do (let: "d" := (GoAlloc (go.PointerType Dec) "d") in
    let: "n" := (GoAlloc go.uint64 "n") in
    let: "b" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (let: "$s" := (![go.SliceType go.byte] (StructFieldRef Dec "p"%go (![go.PointerType Dec] "d"))) in
    Slice (go.SliceType go.byte) ("$s", #(W64 0), ![go.uint64] "n")) in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$s" := (![go.SliceType go.byte] (StructFieldRef Dec "p"%go (![go.PointerType Dec] "d"))) in
    Slice (go.SliceType go.byte) ("$s", ![go.uint64] "n", FuncResolve go.len [go.SliceType go.byte] #() (![go.SliceType go.byte] (StructFieldRef Dec "p"%go (![go.PointerType Dec] "d"))))) in
    do:  ((StructFieldRef Dec "p"%go (![go.PointerType Dec] "d")) <-[go.SliceType go.byte] "$r0");;;
    return: (![go.SliceType go.byte] "b")).

Definition Decⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "p"%go (go.SliceType go.byte))
].

Module Dec.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  p : slice.t;
}.
#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
End def.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.

End Dec.

Class Dec_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Dec_zero_val  :: go.GoZeroValEq Dec Dec.t;
  #[global] Dec'ptr_UInt32_unfold :: MethodUnfold (go.PointerType (Dec)) "UInt32" (Dec__UInt32ⁱᵐᵖˡ);
  #[global] Dec'ptr_UInt64_unfold :: MethodUnfold (go.PointerType (Dec)) "UInt64" (Dec__UInt64ⁱᵐᵖˡ);
  #[global] Dec'ptr_consume_unfold :: MethodUnfold (go.PointerType (Dec)) "consume" (Dec__consumeⁱᵐᵖˡ);
}.

Definition Enum1ⁱᵐᵖˡ : go.type := go.uint64.

Definition Enum1 : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.Enum1"%go [].

Module Enum1.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t  : Type := w64.
End def.
End Enum1.

Class Enum1_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Enum1_zero_val  :: go.GoZeroValEq Enum1 Enum1.t;
}.

Definition Enum1A {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 0).

Definition Enum1B {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 1).

Definition Enum1C {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 2).

Definition Enum2ⁱᵐᵖˡ : go.type := go.int.

Definition Enum2 : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.Enum2"%go [].

Module Enum2.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t  : Type := w64.
End def.
End Enum2.

Class Enum2_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Enum2_zero_val  :: go.GoZeroValEq Enum2 Enum2.t;
}.

(* line comment 1 *)
Definition Enum2A {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 1).

(* line comment 2 *)
Definition Enum2B {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Z := 3.

Definition Enum2C {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Z := 4.

(* line comment 3 *)
Definition Enum2D {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 15).

Definition a {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := float_placeholder.

Definition b {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := float_placeholder.

Definition useFloat {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.useFloat"%go.

(* go: float.go:8:6 *)
Definition useFloatⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.float64 (GoZeroVal go.float64 #())) in
    let: "$r0" := (make_nondet float64T a) in
    do:  ("x" <-[go.float64] "$r0");;;
    let: "$r0" := (((![go.float64] "x") +⟨go.float64⟩ (make_nondet float64T a)) *⟨go.float64⟩ (make_nondet float64T float_placeholder)) in
    do:  ("x" <-[go.float64] "$r0");;;
    return: (![go.float64] "x")).

Definition compareIntFloat {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.compareIntFloat"%go.

(* go: float.go:14:6 *)
Definition compareIntFloatⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x",
    exception_do (let: "x" := (GoAlloc go.int "x") in
    return: ((![go.int] "x") <⟨go.int⟩ #(W64 1000000))).

Definition compareFloatInt {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.compareFloatInt"%go.

(* go: float.go:18:6 *)
Definition compareFloatIntⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x",
    exception_do (let: "x" := (GoAlloc go.int "x") in
    return: (#(W64 1000000) <⟨go.int⟩ (![go.int] "x"))).

Definition forRangeNoBinding {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.forRangeNoBinding"%go.

(* go: for_range.go:5:6 *)
Definition forRangeNoBindingⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x",
    exception_do (let: "x" := (GoAlloc (go.SliceType go.string) "x") in
    let: "$range" := (![go.SliceType go.string] "x") in
    slice.for_range go.string "$range" (λ: "$key" "$value",
      do:  (let: "$a0" := ((let: "$sl0" := (InterfaceMake (go.SliceType go.string) (![go.SliceType go.string] "x")) in
      CompositeLiteral (go.InterfaceType []) (LiteralValue [KeyedElement None (ElementExpression "$sl0")]))) in
      (FuncResolve fmt.Print [] #()) "$a0"));;;
    return: #()).

Definition forRangeOldVars {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.forRangeOldVars"%go.

(* go: for_range.go:11:6 *)
Definition forRangeOldVarsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x",
    exception_do (let: "x" := (GoAlloc (go.SliceType go.string) "x") in
    let: "y" := (GoAlloc go.string (GoZeroVal go.string #())) in
    let: "$r0" := #"ok"%go in
    do:  ("y" <-[go.string] "$r0");;;
    let: "$range" := (![go.SliceType go.string] "x") in
    slice.for_range go.string "$range" (λ: "$key" "$value",
      do:  ("y" <-[go.string] "$value");;;
      do:  "$key";;;
      do:  (let: "$a0" := ((let: "$sl0" := (InterfaceMake go.string (![go.string] "y")) in
      CompositeLiteral (go.InterfaceType []) (LiteralValue [KeyedElement None (ElementExpression "$sl0")]))) in
      (FuncResolve fmt.Print [] #()) "$a0"));;;
    return: #()).

Definition foo {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.foo"%go.

(* go: globals.go:3:6 *)
Definition fooⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (#(W64 10))).

Definition GlobalX {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.GlobalX"%go.

Definition globalY {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.globalY"%go.

Definition globalA {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.globalA"%go.

Definition globalB {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.globalB"%go.

Definition MaxRune {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Z := 1114111.

Definition runeWithType {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W32 97).

Definition IntWidth {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Z := 8.

Definition other {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.other"%go.

(* go: globals.go:18:6 *)
Definition otherⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "$r0" := #"ok"%go in
    do:  ((GlobalVarAddr globalY #()) <-[go.string] "$r0");;;
    return: #()).

Definition bar {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.bar"%go.

(* go: globals.go:22:6 *)
Definition barⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (do:  ((FuncResolve other [] #()) #());;;
    (if: ((![go.uint64] (GlobalVarAddr GlobalX #())) ≠⟨go.uint64⟩ #(W64 10)) || ((![go.string] (GlobalVarAddr globalY #())) ≠⟨go.string⟩ #"ok"%go)
    then
      do:  (let: "$a0" := (InterfaceMake go.string #"bad"%go) in
      (FuncResolve go.panic [] #()) "$a0")
    else do:  #());;;
    return: #()).

Definition useUntypedRune {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.useUntypedRune"%go.

(* go: globals.go:37:6 *)
Definition useUntypedRuneⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do ((if: runeWithType >⟨go.rune⟩ #(W32 MaxRune)
    then
      do:  (let: "$a0" := (InterfaceMake go.string #"invalid comparison"%go) in
      (FuncResolve go.panic [] #()) "$a0")
    else do:  #());;;
    return: #()).

Definition TakesFunctionType {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.TakesFunctionType"%go.

(* go: higher_order.go:3:6 *)
Definition TakesFunctionTypeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "f",
    exception_do (let: "f" := (GoAlloc (go.FunctionType (go.Signature [] false [])) "f") in
    do:  ((![go.FunctionType (go.Signature [] false [])] "f") #());;;
    return: #()).

Definition FuncVar {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.FuncVar"%go.

(* go: higher_order.go:7:6 *)
Definition FuncVarⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "f" := (GoAlloc (go.FunctionType (go.Signature [] false [])) (GoZeroVal (go.FunctionType (go.Signature [] false [])) #())) in
    let: "$r0" := (![go.FunctionType (go.Signature [] false [])] "f") in
    do:  "$r0";;;
    return: #()).

Definition Fooerⁱᵐᵖˡ : go.type := go.InterfaceType [go.MethodElem #"Foo"%go (go.Signature [] false [])].

Definition Fooer : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.Fooer"%go [].

Module Fooer.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t  : Type := interface.t.
End def.
End Fooer.

Class Fooer_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Fooer_zero_val  :: go.GoZeroValEq Fooer Fooer.t;
  #[global] Fooer'ptr_Foo_unfold :: MethodUnfold (Fooer) "Foo" (Fooer__Fooⁱᵐᵖˡ);
}.

Definition concreteFooer : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.concreteFooer"%go [].

(* go: interfaces.go:15:25 *)
Definition concreteFooer__Fooⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "f" <>,
    exception_do (let: "f" := (GoAlloc (go.PointerType concreteFooer) "f") in
    do:  #()).

Definition concreteFooerⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "a"%go go.uint64)
].

Module concreteFooer.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  a : w64;
}.
#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
End def.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.

End concreteFooer.

Class concreteFooer_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] concreteFooer_zero_val  :: go.GoZeroValEq concreteFooer concreteFooer.t;
  #[global] concreteFooer'ptr_Foo_unfold :: MethodUnfold (go.PointerType (concreteFooer)) "Foo" (concreteFooer__Fooⁱᵐᵖˡ);
}.

Definition FooerUserⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "f"%go Fooer)
].

Definition FooerUser : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.FooerUser"%go [].

Module FooerUser.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  f : unittest.Fooer.t;
}.
#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
End def.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.

End FooerUser.

Class FooerUser_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] FooerUser_zero_val  :: go.GoZeroValEq FooerUser FooerUser.t;
}.

Definition fooConsumer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.fooConsumer"%go.

(* go: interfaces.go:18:6 *)
Definition fooConsumerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "f",
    exception_do (let: "f" := (GoAlloc Fooer "f") in
    do:  ((MethodResolve Fooer "Foo"%go #() (![Fooer] "f")) #());;;
    return: #()).

Definition testAssignConcreteToInterface {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.testAssignConcreteToInterface"%go.

(* go: interfaces.go:22:6 *)
Definition testAssignConcreteToInterfaceⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x",
    exception_do (let: "x" := (GoAlloc (go.PointerType Fooer) "x") in
    let: "c" := (GoAlloc (go.PointerType concreteFooer) (GoZeroVal (go.PointerType concreteFooer) #())) in
    let: "$r0" := (GoAlloc concreteFooer (CompositeLiteral concreteFooer (LiteralValue []))) in
    do:  ("c" <-[go.PointerType concreteFooer] "$r0");;;
    let: "$r0" := (InterfaceMake (go.PointerType concreteFooer) (![go.PointerType concreteFooer] "c")) in
    do:  ((![go.PointerType Fooer] "x") <-[Fooer] "$r0");;;
    return: #()).

Definition testPassConcreteToInterfaceArg {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.testPassConcreteToInterfaceArg"%go.

(* go: interfaces.go:27:6 *)
Definition testPassConcreteToInterfaceArgⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "c" := (GoAlloc (go.PointerType concreteFooer) (GoZeroVal (go.PointerType concreteFooer) #())) in
    let: "$r0" := (GoAlloc concreteFooer (CompositeLiteral concreteFooer (LiteralValue []))) in
    do:  ("c" <-[go.PointerType concreteFooer] "$r0");;;
    do:  (let: "$a0" := (InterfaceMake (go.PointerType concreteFooer) (![go.PointerType concreteFooer] "c")) in
    (FuncResolve fooConsumer [] #()) "$a0");;;
    let: "f" := (GoAlloc Fooer (GoZeroVal Fooer #())) in
    let: "$r0" := (InterfaceMake (go.PointerType concreteFooer) (![go.PointerType concreteFooer] "c")) in
    do:  ("f" <-[Fooer] "$r0");;;
    do:  (let: "$a0" := (![Fooer] "f") in
    (FuncResolve fooConsumer [] #()) "$a0");;;
    do:  ((MethodResolve (go.PointerType concreteFooer) "Foo"%go #() (![go.PointerType concreteFooer] "c")) #());;;
    do:  ((MethodResolve Fooer "Foo"%go #() (![Fooer] "f")) #());;;
    return: #()).

Definition testPassConcreteToInterfaceArgSpecial {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.testPassConcreteToInterfaceArgSpecial"%go.

(* go: interfaces.go:37:6 *)
Definition testPassConcreteToInterfaceArgSpecialⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "c1" := (GoAlloc (go.PointerType concreteFooer) (GoZeroVal (go.PointerType concreteFooer) #())) in
    let: "$r0" := (GoAlloc concreteFooer (CompositeLiteral concreteFooer (LiteralValue []))) in
    do:  ("c1" <-[go.PointerType concreteFooer] "$r0");;;
    let: "c2" := (GoAlloc (go.PointerType concreteFooer) (GoZeroVal (go.PointerType concreteFooer) #())) in
    let: "$r0" := (GoAlloc concreteFooer (CompositeLiteral concreteFooer (LiteralValue []))) in
    do:  ("c2" <-[go.PointerType concreteFooer] "$r0");;;
    let: "l" := (GoAlloc (go.SliceType Fooer) (GoZeroVal (go.SliceType Fooer) #())) in
    let: "$r0" := (CompositeLiteral (go.SliceType Fooer) (LiteralValue [KeyedElement None (ElementExpression (![go.PointerType concreteFooer] "c1")); KeyedElement None (ElementExpression (![go.PointerType concreteFooer] "c2"))])) in
    do:  ("l" <-[go.SliceType Fooer] "$r0");;;
    let: "m" := (GoAlloc (go.MapType go.uint64 Fooer) (GoZeroVal (go.MapType go.uint64 Fooer) #())) in
    let: "$r0" := ((FuncResolve go.make1 [go.MapType go.uint64 Fooer] #()) #()) in
    do:  ("m" <-[go.MapType go.uint64 Fooer] "$r0");;;
    let: "$r0" := (InterfaceMake (go.PointerType concreteFooer) (![go.PointerType concreteFooer] "c1")) in
    do:  (map.insert (![go.MapType go.uint64 Fooer] "m") #(W64 10) "$r0");;;
    let: "f" := (GoAlloc FooerUser (GoZeroVal FooerUser #())) in
    let: "$r0" := (CompositeLiteral FooerUser (LiteralValue [KeyedElement None (ElementExpression (![go.PointerType concreteFooer] "c1"))])) in
    do:  ("f" <-[FooerUser] "$r0");;;
    return: (![go.SliceType Fooer] "l", ![go.MapType go.uint64 Fooer] "m", ![FooerUser] "f")).

Definition takesVarArgsInterface {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.takesVarArgsInterface"%go.

(* go: interfaces.go:51:6 *)
Definition takesVarArgsInterfaceⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "fs",
    exception_do (let: "fs" := (GoAlloc (go.SliceType Fooer) "fs") in
    do:  ((MethodResolve Fooer "Foo"%go #() (![Fooer] (IndexRef (go.SliceType Fooer) (![go.SliceType Fooer] "fs", #(W64 0))))) #());;;
    return: #()).

Definition test {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.test"%go.

(* go: interfaces.go:55:6 *)
Definition testⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (do:  (let: "$a0" := ((let: "$sl0" := (InterfaceMake (go.PointerType concreteFooer) (GoAlloc concreteFooer (CompositeLiteral concreteFooer (LiteralValue [])))) in
    let: "$sl1" := (InterfaceMake (go.PointerType concreteFooer) (GoAlloc concreteFooer (CompositeLiteral concreteFooer (LiteralValue [])))) in
    CompositeLiteral Fooer (LiteralValue [KeyedElement None (ElementExpression "$sl0"); KeyedElement None (ElementExpression "$sl1")]))) in
    (FuncResolve takesVarArgsInterface [] #()) "$a0");;;
    return: #()).

Definition returnConcrete {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.returnConcrete"%go.

(* go: interfaces.go:59:6 *)
Definition returnConcreteⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (GoAlloc concreteFooer (CompositeLiteral concreteFooer (LiteralValue [])), #(W64 10))).

Definition testMultiReturn {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.testMultiReturn"%go.

(* converts an object into an interface in a multiple return destructuring statement.

   go: interfaces.go:64:6 *)
Definition testMultiReturnⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x",
    exception_do (let: "x" := (GoAlloc (go.PointerType Fooer) "x") in
    let: "y" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: ("$ret0", "$ret1") := ((FuncResolve returnConcrete [] #()) #()) in
    let: "$r0" := (InterfaceMake (go.PointerType concreteFooer) "$ret0") in
    let: "$r1" := "$ret1" in
    do:  ((![go.PointerType Fooer] "x") <-[Fooer] "$r0");;;
    do:  ("y" <-[go.uint64] "$r1");;;
    return: (![go.uint64] "y")).

Definition testReturnStatment {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.testReturnStatment"%go.

(* go: interfaces.go:70:6 *)
Definition testReturnStatmentⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "y" := (GoAlloc (go.PointerType concreteFooer) (GoZeroVal (go.PointerType concreteFooer) #())) in
    let: "$r0" := (GoAlloc concreteFooer (CompositeLiteral concreteFooer (LiteralValue []))) in
    do:  ("y" <-[go.PointerType concreteFooer] "$r0");;;
    return: (InterfaceMake (go.PointerType concreteFooer) (![go.PointerType concreteFooer] "y"))).

Definition testConversionInEq {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.testConversionInEq"%go.

(* go: interfaces.go:75:6 *)
Definition testConversionInEqⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "f",
    exception_do (let: "f" := (GoAlloc Fooer "f") in
    let: "c" := (GoAlloc (go.PointerType concreteFooer) (GoZeroVal (go.PointerType concreteFooer) #())) in
    let: "$r0" := (GoAlloc concreteFooer (CompositeLiteral concreteFooer (LiteralValue []))) in
    do:  ("c" <-[go.PointerType concreteFooer] "$r0");;;
    let: "$r0" := (InterfaceMake (go.PointerType concreteFooer) (![go.PointerType concreteFooer] "c")) in
    do:  ("f" <-[Fooer] "$r0");;;
    return: ((InterfaceMake (go.PointerType concreteFooer) (![go.PointerType concreteFooer] "c")) =⟨go.InterfaceType [go.MethodElem #"Foo"%go (go.Signature [] false [])]⟩ (![Fooer] "f"))).

Definition takeMultiple {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.takeMultiple"%go.

(* go: interfaces.go:82:6 *)
Definition takeMultipleⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "a" "f",
    exception_do (let: "f" := (GoAlloc (go.SliceType Fooer) "f") in
    let: "a" := (GoAlloc go.uint64 "a") in
    do:  #()).

Definition giveMultiple {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.giveMultiple"%go.

(* go: interfaces.go:85:6 *)
Definition giveMultipleⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (#(W64 0), InterfaceMake (go.PointerType concreteFooer) (GoAlloc concreteFooer (CompositeLiteral concreteFooer (LiteralValue []))), GoAlloc concreteFooer (CompositeLiteral concreteFooer (LiteralValue [])))).

Definition testConversionInMultipleReturnPassThrough {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.testConversionInMultipleReturnPassThrough"%go.

(* go: interfaces.go:89:6 *)
Definition testConversionInMultipleReturnPassThroughⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: (("$ret0", "$ret1"), "$ret2") := (((FuncResolve giveMultiple [] #()) #())) in
    return: ("$ret0", "$ret1", InterfaceMake (go.PointerType concreteFooer) "$ret2")).

Definition testConversionInMultiplePassThrough {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.testConversionInMultiplePassThrough"%go.

(* See "special case" in https://go.dev/ref/spec#Calls

   go: interfaces.go:94:6 *)
Definition testConversionInMultiplePassThroughⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (do:  (let: (("$ret0", "$ret1"), "$ret2") := (((FuncResolve giveMultiple [] #()) #())) in
    let: "$a0" := "$ret0" in
    let: "$a1" := ((let: "$sl0" := "$ret1" in
    let: "$sl1" := (InterfaceMake (go.PointerType concreteFooer) "$ret2") in
    CompositeLiteral Fooer (LiteralValue [KeyedElement None (ElementExpression "$sl0"); KeyedElement None (ElementExpression "$sl1")]))) in
    (FuncResolve takeMultiple [] #()) "$a0" "$a1");;;
    return: #()).

Definition PointerInterfaceⁱᵐᵖˡ : go.type := go.InterfaceType [go.MethodElem #"B"%go (go.Signature [] false []); go.MethodElem #"Foo"%go (go.Signature [] false [])].

Definition PointerInterface : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.PointerInterface"%go [].

Module PointerInterface.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t  : Type := interface.t.
End def.
End PointerInterface.

Class PointerInterface_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] PointerInterface_zero_val  :: go.GoZeroValEq PointerInterface PointerInterface.t;
  #[global] PointerInterface'ptr_B_unfold :: MethodUnfold (PointerInterface) "B" (PointerInterface__Bⁱᵐᵖˡ);
  #[global] PointerInterface'ptr_Foo_unfold :: MethodUnfold (PointerInterface) "Foo" (PointerInterface__Fooⁱᵐᵖˡ);
}.

Definition concrete1 : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.concrete1"%go [].

(* go: interfaces.go:106:20 *)
Definition concrete1__Fooⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "c" <>,
    exception_do (let: "c" := (GoAlloc concrete1 "c") in
    do:  #()).

(* go: interfaces.go:109:21 *)
Definition concrete1__Bⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "c" <>,
    exception_do (let: "c" := (GoAlloc (go.PointerType concrete1) "c") in
    do:  #()).

Definition concrete1ⁱᵐᵖˡ : go.type := go.StructType [
].

Module concrete1.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
}.
#[global] Instance zero_val : ZeroVal t := {| zero_val := mk|}.
End def.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.

End concrete1.

Class concrete1_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] concrete1_zero_val  :: go.GoZeroValEq concrete1 concrete1.t;
  #[global] concrete1'ptr_Foo_unfold :: MethodUnfold (concrete1) "Foo" (concrete1__Fooⁱᵐᵖˡ);
  #[global] concrete1'ptr_B_unfold :: MethodUnfold (go.PointerType (concrete1)) "B" (concrete1__Bⁱᵐᵖˡ);
  #[global] concrete1'ptr_Foo_unfold :: MethodUnfold (go.PointerType (concrete1)) "Foo" (λ: "$r", MethodResolve (concrete1) Foo #() (![(concrete1)] "$r");
}.

Definition testPtrMset {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.testPtrMset"%go.

(* go: interfaces.go:112:6 *)
Definition testPtrMsetⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "a" := (GoAlloc (go.PointerType concrete1) (GoZeroVal (go.PointerType concrete1) #())) in
    let: "$r0" := (GoAlloc concrete1 (CompositeLiteral concrete1 (LiteralValue []))) in
    do:  ("a" <-[go.PointerType concrete1] "$r0");;;
    let: "p" := (GoAlloc PointerInterface (GoZeroVal PointerInterface #())) in
    let: "$r0" := (InterfaceMake (go.PointerType concrete1) (![go.PointerType concrete1] "a")) in
    do:  ("p" <-[PointerInterface] "$r0");;;
    let: "f" := (GoAlloc Fooer (GoZeroVal Fooer #())) in
    let: "$r0" := (InterfaceMake concrete1 (![concrete1] (![go.PointerType concrete1] "a"))) in
    do:  ("f" <-[Fooer] "$r0");;;
    do:  ((MethodResolve PointerInterface "B"%go #() (![PointerInterface] "p")) #());;;
    do:  ((MethodResolve Fooer "Foo"%go #() (![Fooer] "f")) #());;;
    return: #()).

Definition pointerAny {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.pointerAny"%go.

(* go: interfaces.go:120:6 *)
Definition pointerAnyⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (GoAlloc (go.InterfaceType []) (GoZeroVal (go.InterfaceType []) #()))).

Definition useInts {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.useInts"%go.

(* go: ints.go:3:6 *)
Definition useIntsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x" "y",
    exception_do (let: "y" := (GoAlloc go.uint32 "y") in
    let: "x" := (GoAlloc go.uint64 "x") in
    let: "z" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (u_to_w64 (![go.uint32] "y")) in
    do:  ("z" <-[go.uint64] "$r0");;;
    let: "$r0" := ((![go.uint64] "z") +⟨go.uint64⟩ #(W64 1)) in
    do:  ("z" <-[go.uint64] "$r0");;;
    let: "y2" := (GoAlloc go.uint32 (GoZeroVal go.uint32 #())) in
    let: "$r0" := ((![go.uint32] "y") +⟨go.uint32⟩ #(W32 3)) in
    do:  ("y2" <-[go.uint32] "$r0");;;
    return: (![go.uint64] "z", ![go.uint32] "y2")).

Definition signedMidpoint {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.signedMidpoint"%go.

(* go: ints.go:12:6 *)
Definition signedMidpointⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x" "y",
    exception_do (let: "y" := (GoAlloc go.int "y") in
    let: "x" := (GoAlloc go.int "x") in
    return: (((![go.int] "x") +⟨go.int⟩ (![go.int] "y")) /⟨go.int⟩ #(W64 2))).

Definition my_u32ⁱᵐᵖˡ : go.type := go.uint32.

Definition my_u32 : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.my_u32"%go [].

Module my_u32.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t  : Type := w32.
End def.
End my_u32.

Class my_u32_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] my_u32_zero_val  :: go.GoZeroValEq my_u32 my_u32.t;
}.

Definition also_u32ⁱᵐᵖˡ : go.type := my_u32.

Definition also_u32 : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.also_u32"%go [].

Module also_u32.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t  : Type := unittest.my_u32.t.
End def.
End also_u32.

Class also_u32_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] also_u32_zero_val  :: go.GoZeroValEq also_u32 also_u32.t;
}.

Definition ConstWithAbbrevType {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W32 3).

Definition allTheLiteralsⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "int"%go go.uint64);
  (go.FieldDecl "s"%go go.string);
  (go.FieldDecl "b"%go go.bool)
].

Definition allTheLiterals : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.allTheLiterals"%go [].

Module allTheLiterals.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  int : w64;
  s : go_string;
  b : bool;
}.
#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _)|}.
End def.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.

End allTheLiterals.

Class allTheLiterals_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] allTheLiterals_zero_val  :: go.GoZeroValEq allTheLiterals allTheLiterals.t;
}.

Definition normalLiterals {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.normalLiterals"%go.

(* go: literals.go:9:6 *)
Definition normalLiteralsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (CompositeLiteral allTheLiterals (LiteralValue [KeyedElement (Some (KeyField "int"%go)) (ElementExpression #(W64 0)); KeyedElement (Some (KeyField "s"%go)) (ElementExpression #"foo"%go); KeyedElement (Some (KeyField "b"%go)) (ElementExpression #true)]))).

Definition outOfOrderLiteral {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.outOfOrderLiteral"%go.

(* go: literals.go:17:6 *)
Definition outOfOrderLiteralⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (CompositeLiteral allTheLiterals (LiteralValue [KeyedElement (Some (KeyField "b"%go)) (ElementExpression #true); KeyedElement (Some (KeyField "s"%go)) (ElementExpression #"foo"%go); KeyedElement (Some (KeyField "int"%go)) (ElementExpression #(W64 0))]))).

Definition specialLiterals {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.specialLiterals"%go.

(* go: literals.go:25:6 *)
Definition specialLiteralsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (CompositeLiteral allTheLiterals (LiteralValue [KeyedElement (Some (KeyField "int"%go)) (ElementExpression #(W64 4096)); KeyedElement (Some (KeyField "s"%go)) (ElementExpression #""%go); KeyedElement (Some (KeyField "b"%go)) (ElementExpression #false)]))).

Definition oddLiterals {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.oddLiterals"%go.

(* go: literals.go:33:6 *)
Definition oddLiteralsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (CompositeLiteral allTheLiterals (LiteralValue [KeyedElement (Some (KeyField "int"%go)) (ElementExpression #(W64 5)); KeyedElement (Some (KeyField "s"%go)) (ElementExpression #"backquote string"%go); KeyedElement (Some (KeyField "b"%go)) (ElementExpression #false)]))).

Definition unKeyedLiteral {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.unKeyedLiteral"%go.

(* go: literals.go:41:6 *)
Definition unKeyedLiteralⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (CompositeLiteral allTheLiterals (LiteralValue [KeyedElement None (ElementExpression #(W64 0)); KeyedElement None (ElementExpression #"a"%go); KeyedElement None (ElementExpression #false)]))).

Definition useLocks {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.useLocks"%go.

(* go: locks.go:5:6 *)
Definition useLocksⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "m" := (GoAlloc (go.PointerType sync.Mutex) (GoZeroVal (go.PointerType sync.Mutex) #())) in
    let: "$r0" := (GoAlloc sync.Mutex (GoZeroVal sync.Mutex #())) in
    do:  ("m" <-[go.PointerType sync.Mutex] "$r0");;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go #() (![go.PointerType sync.Mutex] "m")) #());;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go #() (![go.PointerType sync.Mutex] "m")) #());;;
    return: #()).

Definition useCondVar {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.useCondVar"%go.

(* go: locks.go:11:6 *)
Definition useCondVarⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "m" := (GoAlloc (go.PointerType sync.Mutex) (GoZeroVal (go.PointerType sync.Mutex) #())) in
    let: "$r0" := (GoAlloc sync.Mutex (GoZeroVal sync.Mutex #())) in
    do:  ("m" <-[go.PointerType sync.Mutex] "$r0");;;
    let: "c" := (GoAlloc (go.PointerType sync.Cond) (GoZeroVal (go.PointerType sync.Cond) #())) in
    let: "$r0" := (let: "$a0" := (InterfaceMake (go.PointerType sync.Mutex) (![go.PointerType sync.Mutex] "m")) in
    (FuncResolve sync.NewCond [] #()) "$a0") in
    do:  ("c" <-[go.PointerType sync.Cond] "$r0");;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go #() (![go.PointerType sync.Mutex] "m")) #());;;
    do:  ((MethodResolve (go.PointerType sync.Cond) "Signal"%go #() (![go.PointerType sync.Cond] "c")) #());;;
    do:  ((MethodResolve (go.PointerType sync.Cond) "Wait"%go #() (![go.PointerType sync.Cond] "c")) #());;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go #() (![go.PointerType sync.Mutex] "m")) #());;;
    return: #()).

Definition hasCondVarⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "cond"%go (go.PointerType sync.Cond))
].

Definition hasCondVar : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.hasCondVar"%go [].

Module hasCondVar.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  cond : loc;
}.
#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
End def.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.

End hasCondVar.

Class hasCondVar_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] hasCondVar_zero_val  :: go.GoZeroValEq hasCondVar hasCondVar.t;
}.

Definition ToBeDebugged {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.ToBeDebugged"%go.

(* go: log_debugging.go:5:6 *)
Definition ToBeDebuggedⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x",
    exception_do (let: "x" := (GoAlloc go.uint64 "x") in
    do:  (let: "$a0" := ((let: "$sl0" := (InterfaceMake go.string #"starting function"%go) in
    CompositeLiteral (go.InterfaceType []) (LiteralValue [KeyedElement None (ElementExpression "$sl0")]))) in
    (FuncResolve log.Println [] #()) "$a0");;;
    do:  (let: "$a0" := #"called with %d"%go in
    let: "$a1" := ((let: "$sl0" := (InterfaceMake go.uint64 (![go.uint64] "x")) in
    CompositeLiteral (go.InterfaceType []) (LiteralValue [KeyedElement None (ElementExpression "$sl0")]))) in
    (FuncResolve log.Printf [] #()) "$a0" "$a1");;;
    do:  (let: "$a0" := ((let: "$sl0" := (InterfaceMake go.string #"ending function"%go) in
    CompositeLiteral (go.InterfaceType []) (LiteralValue [KeyedElement None (ElementExpression "$sl0")]))) in
    (FuncResolve log.Println [] #()) "$a0");;;
    return: (![go.uint64] "x")).

Definition DoNothing {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.DoNothing"%go.

(* go: log_debugging.go:12:6 *)
Definition DoNothingⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (do:  (let: "$a0" := ((let: "$sl0" := (InterfaceMake go.string #"doing nothing"%go) in
    CompositeLiteral (go.InterfaceType []) (LiteralValue [KeyedElement None (ElementExpression "$sl0")]))) in
    (FuncResolve log.Println [] #()) "$a0");;;
    return: #()).

Definition DoSomething {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.DoSomething"%go.

(* DoSomething is an impure function

   go: loops.go:4:6 *)
Definition DoSomethingⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s",
    exception_do (let: "s" := (GoAlloc go.string "s") in
    do:  #()).

Definition standardForLoop {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.standardForLoop"%go.

(* go: loops.go:6:6 *)
Definition standardForLoopⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s",
    exception_do (let: "s" := (GoAlloc (go.SliceType go.uint64) "s") in
    let: "sumPtr" := (GoAlloc (go.PointerType go.uint64) (GoZeroVal (go.PointerType go.uint64) #())) in
    let: "$r0" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    do:  ("sumPtr" <-[go.PointerType go.uint64] "$r0");;;
    (let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (if: (![go.uint64] "i") <⟨go.uint64⟩ (s_to_w64 (let: "$a0" := (![go.SliceType go.uint64] "s") in
      (FuncResolve go.len [go.SliceType go.uint64] #()) "$a0"))
      then
        let: "sum" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
        let: "$r0" := (![go.uint64] (![go.PointerType go.uint64] "sumPtr")) in
        do:  ("sum" <-[go.uint64] "$r0");;;
        let: "x" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
        let: "$r0" := (![go.uint64] (IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "s", ![go.uint64] "i"))) in
        do:  ("x" <-[go.uint64] "$r0");;;
        let: "$r0" := ((![go.uint64] "sum") +⟨go.uint64⟩ (![go.uint64] "x")) in
        do:  ((![go.PointerType go.uint64] "sumPtr") <-[go.uint64] "$r0");;;
        let: "$r0" := ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 1)) in
        do:  ("i" <-[go.uint64] "$r0");;;
        continue: #()
      else do:  #());;;
      break: #()));;;
    let: "sum" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (![go.uint64] (![go.PointerType go.uint64] "sumPtr")) in
    do:  ("sum" <-[go.uint64] "$r0");;;
    return: (![go.uint64] "sum")).

Definition conditionalInLoop {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.conditionalInLoop"%go.

(* go: loops.go:25:6 *)
Definition conditionalInLoopⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do ((let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (if: (![go.uint64] "i") <⟨go.uint64⟩ #(W64 3)
      then
        do:  (let: "$a0" := #"i is small"%go in
        (FuncResolve DoSomething [] #()) "$a0")
      else do:  #());;;
      (if: (![go.uint64] "i") >⟨go.uint64⟩ #(W64 5)
      then break: #()
      else do:  #());;;
      let: "$r0" := ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 1)) in
      do:  ("i" <-[go.uint64] "$r0");;;
      continue: #()));;;
    return: #()).

Definition conditionalInLoopElse {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.conditionalInLoopElse"%go.

(* go: loops.go:38:6 *)
Definition conditionalInLoopElseⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do ((let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (if: (![go.uint64] "i") >⟨go.uint64⟩ #(W64 5)
      then break: #()
      else
        let: "$r0" := ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 1)) in
        do:  ("i" <-[go.uint64] "$r0");;;
        continue: #())));;;
    return: #()).

Definition nestedConditionalInLoopImplicitContinue {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.nestedConditionalInLoopImplicitContinue"%go.

(* go: loops.go:49:6 *)
Definition nestedConditionalInLoopImplicitContinueⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do ((let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (if: (![go.uint64] "i") >⟨go.uint64⟩ #(W64 5)
      then
        (if: (![go.uint64] "i") >⟨go.uint64⟩ #(W64 10)
        then break: #()
        else do:  #())
      else
        let: "$r0" := ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 1)) in
        do:  ("i" <-[go.uint64] "$r0");;;
        continue: #())));;;
    return: #()).

Definition ImplicitLoopContinue {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.ImplicitLoopContinue"%go.

(* go: loops.go:62:6 *)
Definition ImplicitLoopContinueⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do ((let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (if: (![go.uint64] "i") <⟨go.uint64⟩ #(W64 4)
      then
        let: "$r0" := #(W64 0) in
        do:  ("i" <-[go.uint64] "$r0")
      else do:  #())));;;
    return: #()).

Definition ImplicitLoopContinue2 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.ImplicitLoopContinue2"%go.

(* go: loops.go:70:6 *)
Definition ImplicitLoopContinue2ⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do ((let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (if: (![go.uint64] "i") <⟨go.uint64⟩ #(W64 4)
      then
        let: "$r0" := #(W64 0) in
        do:  ("i" <-[go.uint64] "$r0");;;
        continue: #()
      else do:  #())));;;
    return: #()).

Definition ImplicitLoopContinueAfterIfBreak {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.ImplicitLoopContinueAfterIfBreak"%go.

(* go: loops.go:79:6 *)
Definition ImplicitLoopContinueAfterIfBreakⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "i",
    exception_do (let: "i" := (GoAlloc go.uint64 "i") in
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (if: (![go.uint64] "i") >⟨go.uint64⟩ #(W64 0)
      then break: #()
      else do:  #()));;;
    return: #()).

Definition nestedLoops {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.nestedLoops"%go.

(* go: loops.go:87:6 *)
Definition nestedLoopsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do ((let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (let: "j" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: "$r0" := #(W64 0) in
      do:  ("j" <-[go.uint64] "$r0");;;
      (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
        (if: #true
        then break: #()
        else do:  #());;;
        let: "$r0" := ((![go.uint64] "j") +⟨go.uint64⟩ #(W64 1)) in
        do:  ("j" <-[go.uint64] "$r0");;;
        continue: #()));;;
      let: "$r0" := ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 1)) in
      do:  ("i" <-[go.uint64] "$r0");;;
      continue: #()));;;
    return: #()).

Definition nestedGoStyleLoops {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.nestedGoStyleLoops"%go.

(* go: loops.go:101:6 *)
Definition nestedGoStyleLoopsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do ((let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, (![go.uint64] "i") <⟨go.uint64⟩ #(W64 10)); (λ: <>, do:  ("i" <-[go.uint64] ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 1)))) := λ: <>,
      (let: "j" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: "$r0" := #(W64 0) in
      do:  ("j" <-[go.uint64] "$r0");;;
      (for: (λ: <>, (![go.uint64] "j") <⟨go.uint64⟩ (![go.uint64] "i")); (λ: <>, do:  ("j" <-[go.uint64] ((![go.uint64] "j") +⟨go.uint64⟩ #(W64 1)))) := λ: <>,
        (if: #true
        then break: #()
        else do:  #());;;
        continue: #()))));;;
    return: #()).

Definition sumSlice {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.sumSlice"%go.

(* go: loops.go:113:6 *)
Definition sumSliceⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "xs",
    exception_do (let: "xs" := (GoAlloc (go.SliceType go.uint64) "xs") in
    let: "sum" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$range" := (![go.SliceType go.uint64] "xs") in
    (let: "x" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    slice.for_range go.uint64 "$range" (λ: "$key" "$value",
      do:  ("x" <-[go.uint64] "$value");;;
      do:  "$key";;;
      do:  ("sum" <-[go.uint64] ((![go.uint64] "sum") +⟨go.uint64⟩ (![go.uint64] "x")))));;;
    return: (![go.uint64] "sum")).

Definition intSliceLoop {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.intSliceLoop"%go.

(* go: loops.go:121:6 *)
Definition intSliceLoopⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "xs",
    exception_do (let: "xs" := (GoAlloc (go.SliceType go.uint64) "xs") in
    let: "sum" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    (let: "i" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.int] "$r0");;;
    (for: (λ: <>, (![go.int] "i") <⟨go.int⟩ (let: "$a0" := (![go.SliceType go.uint64] "xs") in
    (FuncResolve go.len [go.SliceType go.uint64] #()) "$a0")); (λ: <>, do:  ("i" <-[go.int] ((![go.int] "i") +⟨go.int⟩ #(W64 1)))) := λ: <>,
      do:  ("sum" <-[go.uint64] ((![go.uint64] "sum") +⟨go.uint64⟩ (![go.uint64] (IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "xs", ![go.int] "i")))))));;;
    return: (![go.uint64] "sum")).

Definition breakFromLoop {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.breakFromLoop"%go.

(* go: loops.go:129:6 *)
Definition breakFromLoopⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do ((for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (if: #true
      then break: #()
      else do:  #());;;
      continue: #());;;
    return: #()).

Definition IterateMapKeys {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.IterateMapKeys"%go.

(* go: maps.go:3:6 *)
Definition IterateMapKeysⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "m" "sum",
    exception_do (let: "sum" := (GoAlloc (go.PointerType go.uint64) "sum") in
    let: "m" := (GoAlloc (go.MapType go.uint64 go.uint64) "m") in
    let: "$range" := (![go.MapType go.uint64 go.uint64] "m") in
    (let: "k" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    map.for_range "$range" (λ: "$key" "value",
      do:  ("k" <-[go.uint64] "$key");;;
      let: "oldSum" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: "$r0" := (![go.uint64] (![go.PointerType go.uint64] "sum")) in
      do:  ("oldSum" <-[go.uint64] "$r0");;;
      let: "$r0" := ((![go.uint64] "oldSum") +⟨go.uint64⟩ (![go.uint64] "k")) in
      do:  ((![go.PointerType go.uint64] "sum") <-[go.uint64] "$r0")));;;
    return: #()).

Definition MapSize {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.MapSize"%go.

(* go: maps.go:10:6 *)
Definition MapSizeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "m",
    exception_do (let: "m" := (GoAlloc (go.MapType go.uint64 go.bool) "m") in
    return: (s_to_w64 (let: "$a0" := (![go.MapType go.uint64 go.bool] "m") in
     (FuncResolve go.len [go.MapType go.uint64 go.bool] #()) "$a0"))).

Definition IntWrapperⁱᵐᵖˡ : go.type := go.uint64.

Definition IntWrapper : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.IntWrapper"%go [].

Module IntWrapper.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t  : Type := w64.
End def.
End IntWrapper.

Class IntWrapper_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] IntWrapper_zero_val  :: go.GoZeroValEq IntWrapper IntWrapper.t;
}.

Definition MapWrapperⁱᵐᵖˡ : go.type := go.MapType go.uint64 go.bool.

Definition MapWrapper : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.MapWrapper"%go [].

Module MapWrapper.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t  : Type := loc.
End def.
End MapWrapper.

Class MapWrapper_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] MapWrapper_zero_val  :: go.GoZeroValEq MapWrapper MapWrapper.t;
}.

Definition MapTypeAliases {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.MapTypeAliases"%go.

(* go: maps.go:18:6 *)
Definition MapTypeAliasesⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "m1" "m2",
    exception_do (let: "m2" := (GoAlloc MapWrapper "m2") in
    let: "m1" := (GoAlloc (go.MapType IntWrapper go.bool) "m1") in
    let: "$r0" := (Fst (map.get (![MapWrapper] "m2") #(W64 0))) in
    do:  (map.insert (![go.MapType IntWrapper go.bool] "m1") #(W64 4) "$r0");;;
    return: #()).

Definition StringMap {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.StringMap"%go.

(* go: maps.go:22:6 *)
Definition StringMapⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "m",
    exception_do (let: "m" := (GoAlloc (go.MapType go.string go.uint64) "m") in
    return: (Fst (map.get (![go.MapType go.string go.uint64] "m") #"foo"%go))).

Definition mapElemⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "a"%go go.uint64);
  (go.FieldDecl "b"%go go.uint64)
].

Definition mapElem : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.mapElem"%go [].

Module mapElem.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  a : w64;
  b : w64;
}.
#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _)|}.
End def.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.

End mapElem.

Class mapElem_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] mapElem_zero_val  :: go.GoZeroValEq mapElem mapElem.t;
}.

Definition mapUpdateField {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.mapUpdateField"%go.

(* go: maps.go:31:6 *)
Definition mapUpdateFieldⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc (go.MapType go.uint64 (go.PointerType mapElem)) (GoZeroVal (go.MapType go.uint64 (go.PointerType mapElem)) #())) in
    let: "$r0" := ((FuncResolve go.make1 [go.MapType go.uint64 (go.PointerType mapElem)] #()) #()) in
    do:  ("x" <-[go.MapType go.uint64 (go.PointerType mapElem)] "$r0");;;
    let: "$r0" := #(W64 10) in
    do:  ((StructFieldRef mapElem "a"%go (Fst (map.get (![go.MapType go.uint64 (go.PointerType mapElem)] "x") #(W64 0)))) <-[go.uint64] "$r0");;;
    return: #()).

Definition mapLiteral {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.mapLiteral"%go.

Definition mapLiteralWithConversion {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.mapLiteralWithConversion"%go.

Definition mapGetCall {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.mapGetCall"%go.

(* go: maps.go:44:6 *)
Definition mapGetCallⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "handlers" := (GoAlloc (go.MapType go.uint64 (go.FunctionType (go.Signature [] false []))) (GoZeroVal (go.MapType go.uint64 (go.FunctionType (go.Signature [] false []))) #())) in
    let: "$r0" := ((FuncResolve go.make1 [go.MapType go.uint64 (go.FunctionType (go.Signature [] false []))] #()) #()) in
    do:  ("handlers" <-[go.MapType go.uint64 (go.FunctionType (go.Signature [] false []))] "$r0");;;
    let: "$r0" := (λ: <>,
      exception_do (do:  #())
      ) in
    do:  (map.insert (![go.MapType go.uint64 (go.FunctionType (go.Signature [] false []))] "handlers") #(W64 0) "$r0");;;
    do:  ((Fst (map.get (![go.MapType go.uint64 (go.FunctionType (go.Signature [] false []))] "handlers") #(W64 0))) #());;;
    return: #()).

Definition mapLiteralTest {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.mapLiteralTest"%go.

(* go: maps.go:50:6 *)
Definition mapLiteralTestⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "ascii" := (GoAlloc (go.MapType go.string go.uint64) (GoZeroVal (go.MapType go.string go.uint64) #())) in
    let: "$r0" := (CompositeLiteral (go.MapType go.string go.uint64) (LiteralValue [KeyedElement (Some (KeyExpression #"a"%go)) (ElementExpression #(W64 97)); KeyedElement (Some (KeyExpression #"b"%go)) (ElementExpression #(W64 98)); KeyedElement (Some (KeyExpression #"c"%go)) (ElementExpression #(W64 99))])) in
    do:  ("ascii" <-[go.MapType go.string go.uint64] "$r0");;;
    return: (![go.MapType go.string go.uint64] "ascii")).

Definition mapClearTest {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.mapClearTest"%go.

(* go: maps.go:59:6 *)
Definition mapClearTestⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "m" := (GoAlloc (go.MapType go.int go.bool) (GoZeroVal (go.MapType go.int go.bool) #())) in
    let: "$r0" := ((FuncResolve go.make1 [go.MapType go.int go.bool] #()) #()) in
    do:  ("m" <-[go.MapType go.int go.bool] "$r0");;;
    let: "$r0" := #true in
    do:  (map.insert (![go.MapType go.int go.bool] "m") #(W64 1) "$r0");;;
    let: "$r0" := #false in
    do:  (map.insert (![go.MapType go.int go.bool] "m") #(W64 2) "$r0");;;
    let: "$r0" := #true in
    do:  (map.insert (![go.MapType go.int go.bool] "m") #(W64 7) "$r0");;;
    do:  (let: "$a0" := (![go.MapType go.int go.bool] "m") in
    (FuncResolve go.clear [go.MapType go.int go.bool] #()) "$a0");;;
    return: (let: "$a0" := (![go.MapType go.int go.bool] "m") in
     (FuncResolve go.len [go.MapType go.int go.bool] #()) "$a0")).

Definition returnTwo {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.returnTwo"%go.

(* go: multiple.go:3:6 *)
Definition returnTwoⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "p",
    exception_do (let: "p" := (GoAlloc (go.SliceType go.byte) "p") in
    return: (#(W64 0), #(W64 0))).

Definition returnTwoWrapper {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.returnTwoWrapper"%go.

(* go: multiple.go:7:6 *)
Definition returnTwoWrapperⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "data",
    exception_do (let: "data" := (GoAlloc (go.SliceType go.byte) "data") in
    let: "b" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "a" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] "data") in
    (FuncResolve returnTwo [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("a" <-[go.uint64] "$r0");;;
    do:  ("b" <-[go.uint64] "$r1");;;
    return: (![go.uint64] "a", ![go.uint64] "b")).

Definition multipleVar {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.multipleVar"%go.

(* go: multiple.go:12:6 *)
Definition multipleVarⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x" "y",
    exception_do (let: "y" := (GoAlloc go.uint64 "y") in
    let: "x" := (GoAlloc go.uint64 "x") in
    do:  #()).

Definition multiplePassThrough {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.multiplePassThrough"%go.

(* go: multiple.go:14:6 *)
Definition multiplePassThroughⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (do:  (let: ("$ret0", "$ret1") := ((let: "$a0" := #slice.nil in
    (FuncResolve returnTwoWrapper [] #()) "$a0")) in
    let: "$a0" := "$ret0" in
    let: "$a1" := "$ret1" in
    (FuncResolve multipleVar [] #()) "$a0" "$a1");;;
    return: #()).

Definition multipleReturnPassThrough {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.multipleReturnPassThrough"%go.

(* go: multiple.go:18:6 *)
Definition multipleReturnPassThroughⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: ("$ret0", "$ret1") := ((let: "$a0" := #slice.nil in
    (FuncResolve returnTwo [] #()) "$a0")) in
    return: ("$ret0", "$ret1")).

Definition AssignNilSlice {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.AssignNilSlice"%go.

(* go: nil.go:3:6 *)
Definition AssignNilSliceⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "s" := (GoAlloc (go.SliceType (go.SliceType go.byte)) (GoZeroVal (go.SliceType (go.SliceType go.byte)) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType (go.SliceType go.byte)] #()) #(W64 4)) in
    do:  ("s" <-[go.SliceType (go.SliceType go.byte)] "$r0");;;
    let: "$r0" := #slice.nil in
    do:  ((IndexRef (go.SliceType (go.SliceType go.byte)) (![go.SliceType (go.SliceType go.byte)] "s", #(W64 2))) <-[go.SliceType go.byte] "$r0");;;
    return: #()).

Definition AssignNilPointer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.AssignNilPointer"%go.

(* go: nil.go:8:6 *)
Definition AssignNilPointerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "s" := (GoAlloc (go.SliceType (go.PointerType go.uint64)) (GoZeroVal (go.SliceType (go.PointerType go.uint64)) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType (go.PointerType go.uint64)] #()) #(W64 4)) in
    do:  ("s" <-[go.SliceType (go.PointerType go.uint64)] "$r0");;;
    let: "$r0" := #null in
    do:  ((IndexRef (go.SliceType (go.PointerType go.uint64)) (![go.SliceType (go.PointerType go.uint64)] "s", #(W64 2))) <-[go.PointerType go.uint64] "$r0");;;
    return: #()).

Definition CompareSliceToNil {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.CompareSliceToNil"%go.

(* go: nil.go:13:6 *)
Definition CompareSliceToNilⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "s" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 0)) in
    do:  ("s" <-[go.SliceType go.byte] "$r0");;;
    return: ((![go.SliceType go.byte] "s") ≠⟨go.SliceType go.byte⟩ #slice.nil)).

Definition ComparePointerToNil {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.ComparePointerToNil"%go.

(* go: nil.go:18:6 *)
Definition ComparePointerToNilⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "s" := (GoAlloc (go.PointerType go.uint64) (GoZeroVal (go.PointerType go.uint64) #())) in
    let: "$r0" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    do:  ("s" <-[go.PointerType go.uint64] "$r0");;;
    return: ((![go.PointerType go.uint64] "s") ≠⟨go.PointerType go.uint64⟩ #null)).

Definition containsPointerⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "s"%go (go.PointerType go.uint64))
].

Definition containsPointer : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.containsPointer"%go [].

Module containsPointer.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  s : loc;
}.
#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
End def.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.

End containsPointer.

Class containsPointer_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] containsPointer_zero_val  :: go.GoZeroValEq containsPointer containsPointer.t;
}.

Definition useNilField {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.useNilField"%go.

(* go: nil.go:27:6 *)
Definition useNilFieldⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (GoAlloc containsPointer (CompositeLiteral containsPointer (LiteralValue [KeyedElement (Some (KeyField "s"%go)) (ElementExpression BUG: this should get overwritten by handleImplicitConversion)])))).

Definition LogicalOperators {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.LogicalOperators"%go.

(* go: operators.go:3:6 *)
Definition LogicalOperatorsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "b1" "b2",
    exception_do (let: "b2" := (GoAlloc go.bool "b2") in
    let: "b1" := (GoAlloc go.bool "b1") in
    return: (((![go.bool] "b1") && ((![go.bool] "b2") || (![go.bool] "b1"))) && (~ #false))).

Definition LogicalAndEqualityOperators {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.LogicalAndEqualityOperators"%go.

(* go: operators.go:7:6 *)
Definition LogicalAndEqualityOperatorsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "b1" "x",
    exception_do (let: "x" := (GoAlloc go.uint64 "x") in
    let: "b1" := (GoAlloc go.bool "b1") in
    return: (((![go.uint64] "x") =⟨go.uint64⟩ #(W64 3)) && ((![go.bool] "b1") =⟨go.bool⟩ #true))).

Definition ArithmeticShifts {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.ArithmeticShifts"%go.

(* go: operators.go:11:6 *)
Definition ArithmeticShiftsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x" "y",
    exception_do (let: "y" := (GoAlloc go.uint64 "y") in
    let: "x" := (GoAlloc go.uint32 "x") in
    return: (#(W64 0))).

Definition BitwiseOps {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.BitwiseOps"%go.

(* go: operators.go:16:6 *)
Definition BitwiseOpsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x" "y",
    exception_do (let: "y" := (GoAlloc go.uint64 "y") in
    let: "x" := (GoAlloc go.uint32 "x") in
    return: ((u_to_w64 (![go.uint32] "x")) |⟨go.uint64⟩ ((u_to_w64 (u_to_w32 (![go.uint64] "y"))) &⟨go.uint64⟩ #(W64 43)))).

Definition Comparison {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.Comparison"%go.

(* go: operators.go:20:6 *)
Definition Comparisonⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x" "y",
    exception_do (let: "y" := (GoAlloc go.uint64 "y") in
    let: "x" := (GoAlloc go.uint64 "x") in
    (if: (![go.uint64] "x") <⟨go.uint64⟩ (![go.uint64] "y")
    then return: (#true)
    else do:  #());;;
    (if: (![go.uint64] "x") =⟨go.uint64⟩ (![go.uint64] "y")
    then return: (#true)
    else do:  #());;;
    (if: (![go.uint64] "x") ≠⟨go.uint64⟩ (![go.uint64] "y")
    then return: (#true)
    else do:  #());;;
    (if: (![go.uint64] "x") >⟨go.uint64⟩ (![go.uint64] "y")
    then return: (#true)
    else do:  #());;;
    (if: ((![go.uint64] "x") +⟨go.uint64⟩ #(W64 1)) >⟨go.uint64⟩ ((![go.uint64] "y") -⟨go.uint64⟩ #(W64 2))
    then return: (#true)
    else do:  #());;;
    return: (#false)).

Definition AssignOps {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.AssignOps"%go.

(* go: operators.go:39:6 *)
Definition AssignOpsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    do:  ("x" <-[go.uint64] ((![go.uint64] "x") +⟨go.uint64⟩ #(W64 3)));;;
    do:  ("x" <-[go.uint64] ((![go.uint64] "x") -⟨go.uint64⟩ #(W64 3)));;;
    do:  ("x" <-[go.uint64] ((![go.uint64] "x") +⟨go.uint64⟩ #(W64 1)));;;
    do:  ("x" <-[go.uint64] ((![go.uint64] "x") -⟨go.uint64⟩ #(W64 1)));;;
    return: #()).

Definition BitwiseAndNot {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.BitwiseAndNot"%go.

(* go: operators.go:47:6 *)
Definition BitwiseAndNotⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x" "y",
    exception_do (let: "y" := (GoAlloc go.uint64 "y") in
    let: "x" := (GoAlloc go.uint32 "x") in
    let: "z" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := ((u_to_w64 (![go.uint32] "x")) &^⟨go.uint64⟩ (![go.uint64] "y")) in
    do:  ("z" <-[go.uint64] "$r0");;;
    do:  ("z" <-[go.uint64] ((![go.uint64] "z") &^⟨go.uint64⟩ #(W64 255)));;;
    return: (![go.uint64] "z")).

Definition Negative {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.Negative"%go.

(* go: operators.go:53:6 *)
Definition Negativeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.int64 (GoZeroVal go.int64 #())) in
    let: "$r0" := #(W64 (- 10)) in
    do:  ("x" <-[go.int64] "$r0");;;
    do:  ("x" <-[go.int64] ((![go.int64] "x") +⟨go.int64⟩ #(W64 3)));;;
    return: #()).

Definition wrapExternalStruct : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.wrapExternalStruct"%go [].

(* go: package.go:13:29 *)
Definition wrapExternalStruct__joinⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "w" <>,
    exception_do (let: "w" := (GoAlloc wrapExternalStruct "w") in
    do:  ((MethodResolve (go.PointerType std.JoinHandle) "Join"%go #() (![go.PointerType std.JoinHandle] (StructFieldRef wrapExternalStruct "j"%go "w"))) #());;;
    return: #()).

Definition wrapExternalStructⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "j"%go (go.PointerType std.JoinHandle))
].

Module wrapExternalStruct.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  j : loc;
}.
#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
End def.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.

End wrapExternalStruct.

Class wrapExternalStruct_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] wrapExternalStruct_zero_val  :: go.GoZeroValEq wrapExternalStruct wrapExternalStruct.t;
  #[global] wrapExternalStruct'ptr_join_unfold :: MethodUnfold (wrapExternalStruct) "join" (wrapExternalStruct__joinⁱᵐᵖˡ);
  #[global] wrapExternalStruct'ptr_join_unfold :: MethodUnfold (go.PointerType (wrapExternalStruct)) "join" (λ: "$r", MethodResolve (wrapExternalStruct) join #() (![(wrapExternalStruct)] "$r");
}.

Definition PanicAtTheDisco {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.PanicAtTheDisco"%go.

(* go: panic.go:3:6 *)
Definition PanicAtTheDiscoⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (do:  (let: "$a0" := (InterfaceMake go.string #"disco"%go) in
    (FuncResolve go.panic [] #()) "$a0");;;
    return: #()).

Definition Oracle {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.Oracle"%go.

(* go: proph.go:5:6 *)
Definition Oracleⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "p" := (GoAlloc (go.PointerType primitive.prophId) (GoZeroVal (go.PointerType primitive.prophId) #())) in
    let: "$r0" := ((FuncResolve primitive.NewProph [] #()) #()) in
    do:  ("p" <-[go.PointerType primitive.prophId] "$r0");;;
    let: "$r0" := (![go.PointerType primitive.prophId] "p") in
    do:  ("p" <-[go.PointerType primitive.prophId] "$r0");;;
    return: #()).

Definition typingⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "proph"%go (go.PointerType primitive.prophId))
].

Definition typing : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.typing"%go [].

Module typing.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  proph : loc;
}.
#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
End def.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.

End typing.

Class typing_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] typing_zero_val  :: go.GoZeroValEq typing typing.t;
}.

Definition compositeⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "a"%go go.uint64);
  (go.FieldDecl "b"%go go.uint64)
].

Definition composite : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.composite"%go [].

Module composite.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  a : w64;
  b : w64;
}.
#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _)|}.
End def.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.

End composite.

Class composite_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] composite_zero_val  :: go.GoZeroValEq composite composite.t;
}.

Definition ReassignVars {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.ReassignVars"%go.

(* go: reassign.go:8:6 *)
Definition ReassignVarsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "y" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("y" <-[go.uint64] "$r0");;;
    let: "$r0" := #(W64 3) in
    do:  ("x" <-[go.uint64] "$r0");;;
    let: "z" := (GoAlloc composite (GoZeroVal composite #())) in
    let: "$r0" := (CompositeLiteral composite (LiteralValue [KeyedElement (Some (KeyField "a"%go)) (ElementExpression (![go.uint64] "x")); KeyedElement (Some (KeyField "b"%go)) (ElementExpression (![go.uint64] "y"))])) in
    do:  ("z" <-[composite] "$r0");;;
    let: "$r0" := (CompositeLiteral composite (LiteralValue [KeyedElement (Some (KeyField "a"%go)) (ElementExpression (![go.uint64] "y")); KeyedElement (Some (KeyField "b"%go)) (ElementExpression (![go.uint64] "x"))])) in
    do:  ("z" <-[composite] "$r0");;;
    let: "$r0" := (![go.uint64] (StructFieldRef composite "a"%go "z")) in
    do:  ("x" <-[go.uint64] "$r0");;;
    return: #()).

Definition recur {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.recur"%go.

(* go: recursive.go:3:6 *)
Definition recurⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (do:  ((FuncResolve recur [] #()) #());;;
    return: #()).

Definition R : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.R"%go [].

(* go: recursive.go:10:13 *)
Definition R__recurMethodⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "r" <>,
    exception_do (let: "r" := (GoAlloc (go.PointerType R) "r") in
    do:  ((MethodResolve (go.PointerType R) "recurMethod"%go #() (![go.PointerType R] "r")) #());;;
    return: #()).

Definition Rⁱᵐᵖˡ : go.type := go.StructType [
].

Module R.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
}.
#[global] Instance zero_val : ZeroVal t := {| zero_val := mk|}.
End def.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.

End R.

Class R_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] R_zero_val  :: go.GoZeroValEq R R.t;
  #[global] R'ptr_recurMethod_unfold :: MethodUnfold (go.PointerType (R)) "recurMethod" (R__recurMethodⁱᵐᵖˡ);
}.

Definition RecursiveEmbedded : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.RecursiveEmbedded"%go [].

Definition Other : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.Other"%go [].

Definition Otherⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "RecursiveEmbedded"%go (go.PointerType RecursiveEmbedded))
].

Module Other.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  RecursiveEmbedded : loc;
}.
#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
End def.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.

End Other.

Class Other_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Other_zero_val  :: go.GoZeroValEq Other Other.t;
  #[global] Other'ptr_recurEmbeddedMethod_unfold :: MethodUnfold (Other) "recurEmbeddedMethod" (λ: "$r", MethodResolve (go.PointerType RecursiveEmbedded) recurEmbeddedMethod #() (StructFieldGet (Other) "RecursiveEmbedded" "$r" ))%V;
  #[global] Other'ptr_recurEmbeddedMethod_unfold :: MethodUnfold (go.PointerType (Other)) "recurEmbeddedMethod" (λ: "$r", MethodResolve (go.PointerType RecursiveEmbedded) recurEmbeddedMethod #() (![go.PointerType RecursiveEmbedded] (StructFieldRef Other #"RecursiveEmbedded"%go "$r")));
}.

(* go: recursive.go:22:29 *)
Definition RecursiveEmbedded__recurEmbeddedMethodⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "r" <>,
    exception_do (let: "r" := (GoAlloc (go.PointerType RecursiveEmbedded) "r") in
    do:  ((MethodResolve Other "recurEmbeddedMethod"%go #() (![Other] (StructFieldRef RecursiveEmbedded "Other"%go (![go.PointerType RecursiveEmbedded] "r")))) #());;;
    return: #()).

Definition RecursiveEmbeddedⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "Other"%go Other)
].

Module RecursiveEmbedded.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  Other : unittest.Other.t;
}.
#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
End def.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.

End RecursiveEmbedded.

Class RecursiveEmbedded_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] RecursiveEmbedded_zero_val  :: go.GoZeroValEq RecursiveEmbedded RecursiveEmbedded.t;
  #[global] RecursiveEmbedded'ptr_recurEmbeddedMethod_unfold :: MethodUnfold (go.PointerType (RecursiveEmbedded)) "recurEmbeddedMethod" (RecursiveEmbedded__recurEmbeddedMethodⁱᵐᵖˡ);
}.

Definition useRenamedImport {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.useRenamedImport"%go.

(* go: renamedImport.go:7:6 *)
Definition useRenamedImportⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (do:  (let: "$a0" := ((let: "$sl0" := (InterfaceMake go.string #"blah"%go) in
    CompositeLiteral (go.InterfaceType []) (LiteralValue [KeyedElement None (ElementExpression "$sl0")]))) in
    (FuncResolve fmt.Print [] #()) "$a0");;;
    return: #()).

Definition Blockⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "Value"%go go.uint64)
].

Definition Block : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.Block"%go [].

Module Block.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  Value : w64;
}.
#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
End def.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.

End Block.

Class Block_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Block_zero_val  :: go.GoZeroValEq Block Block.t;
}.

Definition Disk1 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 0).

Definition Disk2 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 0).

Definition DiskSize {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 1000).

Definition TwoDiskWrite {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.TwoDiskWrite"%go.

(* TwoDiskWrite is a dummy function to represent the base layer's disk write

   go: replicated_disk.go:12:6 *)
Definition TwoDiskWriteⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "diskId" "a" "v",
    exception_do (let: "v" := (GoAlloc Block "v") in
    let: "a" := (GoAlloc go.uint64 "a") in
    let: "diskId" := (GoAlloc go.uint64 "diskId") in
    return: (#true)).

Definition TwoDiskRead {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.TwoDiskRead"%go.

(* TwoDiskRead is a dummy function to represent the base layer's disk read

   go: replicated_disk.go:17:6 *)
Definition TwoDiskReadⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "diskId" "a",
    exception_do (let: "a" := (GoAlloc go.uint64 "a") in
    let: "diskId" := (GoAlloc go.uint64 "diskId") in
    return: (CompositeLiteral Block (LiteralValue [KeyedElement (Some (KeyField "Value"%go)) (ElementExpression #(W64 0))]), #true)).

Definition TwoDiskLock {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.TwoDiskLock"%go.

(* TwoDiskLock is a dummy function to represent locking an address in the
   base layer

   go: replicated_disk.go:23:6 *)
Definition TwoDiskLockⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "a",
    exception_do (let: "a" := (GoAlloc go.uint64 "a") in
    do:  #()).

Definition TwoDiskUnlock {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.TwoDiskUnlock"%go.

(* TwoDiskUnlock is a dummy function to represent unlocking an address in the
   base layer

   go: replicated_disk.go:27:6 *)
Definition TwoDiskUnlockⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "a",
    exception_do (let: "a" := (GoAlloc go.uint64 "a") in
    do:  #()).

Definition ReplicatedDiskRead {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.ReplicatedDiskRead"%go.

(* go: replicated_disk.go:29:6 *)
Definition ReplicatedDiskReadⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "a",
    exception_do (let: "a" := (GoAlloc go.uint64 "a") in
    do:  (let: "$a0" := (![go.uint64] "a") in
    (FuncResolve TwoDiskLock [] #()) "$a0");;;
    let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "v" := (GoAlloc Block (GoZeroVal Block #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := Disk1 in
    let: "$a1" := (![go.uint64] "a") in
    (FuncResolve TwoDiskRead [] #()) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("v" <-[Block] "$r0");;;
    do:  ("ok" <-[go.bool] "$r1");;;
    (if: ![go.bool] "ok"
    then
      do:  (let: "$a0" := (![go.uint64] "a") in
      (FuncResolve TwoDiskUnlock [] #()) "$a0");;;
      return: (![Block] "v")
    else do:  #());;;
    let: "v2" := (GoAlloc Block (GoZeroVal Block #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := Disk2 in
    let: "$a1" := (![go.uint64] "a") in
    (FuncResolve TwoDiskRead [] #()) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("v2" <-[Block] "$r0");;;
    do:  "$r1";;;
    do:  (let: "$a0" := (![go.uint64] "a") in
    (FuncResolve TwoDiskUnlock [] #()) "$a0");;;
    return: (![Block] "v2")).

Definition ReplicatedDiskWrite {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.ReplicatedDiskWrite"%go.

(* go: replicated_disk.go:42:6 *)
Definition ReplicatedDiskWriteⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "a" "v",
    exception_do (let: "v" := (GoAlloc Block "v") in
    let: "a" := (GoAlloc go.uint64 "a") in
    do:  (let: "$a0" := (![go.uint64] "a") in
    (FuncResolve TwoDiskLock [] #()) "$a0");;;
    do:  (let: "$a0" := Disk1 in
    let: "$a1" := (![go.uint64] "a") in
    let: "$a2" := (![Block] "v") in
    (FuncResolve TwoDiskWrite [] #()) "$a0" "$a1" "$a2");;;
    do:  (let: "$a0" := Disk2 in
    let: "$a1" := (![go.uint64] "a") in
    let: "$a2" := (![Block] "v") in
    (FuncResolve TwoDiskWrite [] #()) "$a0" "$a1" "$a2");;;
    do:  (let: "$a0" := (![go.uint64] "a") in
    (FuncResolve TwoDiskUnlock [] #()) "$a0");;;
    return: #()).

Definition ReplicatedDiskRecover {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.ReplicatedDiskRecover"%go.

(* go: replicated_disk.go:49:6 *)
Definition ReplicatedDiskRecoverⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do ((let: "a" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("a" <-[go.uint64] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (if: (![go.uint64] "a") >⟨go.uint64⟩ DiskSize
      then break: #()
      else do:  #());;;
      let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
      let: "v" := (GoAlloc Block (GoZeroVal Block #())) in
      let: ("$ret0", "$ret1") := (let: "$a0" := Disk1 in
      let: "$a1" := (![go.uint64] "a") in
      (FuncResolve TwoDiskRead [] #()) "$a0" "$a1") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("v" <-[Block] "$r0");;;
      do:  ("ok" <-[go.bool] "$r1");;;
      (if: ![go.bool] "ok"
      then
        do:  (let: "$a0" := Disk2 in
        let: "$a1" := (![go.uint64] "a") in
        let: "$a2" := (![Block] "v") in
        (FuncResolve TwoDiskWrite [] #()) "$a0" "$a1" "$a2")
      else do:  #());;;
      let: "$r0" := ((![go.uint64] "a") +⟨go.uint64⟩ #(W64 1)) in
      do:  ("a" <-[go.uint64] "$r0");;;
      continue: #()));;;
    return: #()).

Definition BasicNamedReturn {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.BasicNamedReturn"%go.

(* go: returns.go:3:6 *)
Definition BasicNamedReturnⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.string (GoZeroVal go.string #())) in
    return: (#"ok"%go)).

Definition NamedReturn {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.NamedReturn"%go.

(* go: returns.go:7:6 *)
Definition NamedReturnⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.string (GoZeroVal go.string #())) in
    let: "$r0" := ((![go.string] "x") +⟨go.string⟩ #"foo"%go) in
    do:  ("x" <-[go.string] "$r0");;;
    return: (![go.string] "x")).

Definition BasicNamedReturnMany {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.BasicNamedReturnMany"%go.

(* go: returns.go:12:6 *)
Definition BasicNamedReturnManyⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "y" := (GoAlloc go.string (GoZeroVal go.string #())) in
    let: "x" := (GoAlloc go.string (GoZeroVal go.string #())) in
    return: (#"ok"%go, #"blah"%go)).

Definition NamedReturnMany {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.NamedReturnMany"%go.

(* go: returns.go:16:6 *)
Definition NamedReturnManyⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "y" := (GoAlloc go.string (GoZeroVal go.string #())) in
    let: "x" := (GoAlloc go.string (GoZeroVal go.string #())) in
    let: "$r0" := #"returned"%go in
    do:  ("x" <-[go.string] "$r0");;;
    let: "$r0" := #"ok"%go in
    do:  ("y" <-[go.string] "$r0");;;
    return: (![go.string] "x", ![go.string] "y")).

Definition NamedReturnOverride {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.NamedReturnOverride"%go.

(* go: returns.go:22:6 *)
Definition NamedReturnOverrideⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "y" := (GoAlloc go.string (GoZeroVal go.string #())) in
    let: "x" := (GoAlloc go.string (GoZeroVal go.string #())) in
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "x" := (GoAlloc go.string (GoZeroVal go.string #())) in
      let: "$r0" := #"unused"%go in
      do:  ("x" <-[go.string] "$r0");;;
      do:  ("x" <-[go.string] ((![go.string] "x") +⟨go.string⟩ #"stillUnused"%go));;;
      let: "$r0" := #"ok"%go in
      do:  ("y" <-[go.string] "$r0");;;
      break: #());;;
    return: (![go.string] "x", ![go.string] "y")).

Definition VoidButEndsWithReturn {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.VoidButEndsWithReturn"%go.

(* go: returns.go:32:6 *)
Definition VoidButEndsWithReturnⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (do:  ((FuncResolve BasicNamedReturn [] #()) #());;;
    return: #()).

Definition VoidImplicitReturnInBranch {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.VoidImplicitReturnInBranch"%go.

(* go: returns.go:38:6 *)
Definition VoidImplicitReturnInBranchⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "b",
    exception_do (let: "b" := (GoAlloc go.bool "b") in
    (if: ![go.bool] "b"
    then return: (#())
    else do:  ((FuncResolve BasicNamedReturn [] #()) #()));;;
    return: #()).

Definition useRuneOps {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.useRuneOps"%go.

(* go: rune.go:3:6 *)
Definition useRuneOpsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "r",
    exception_do (let: "r" := (GoAlloc go.rune "r") in
    do:  ("r" <-[go.rune] ((![go.rune] "r") +⟨go.rune⟩ #(W32 1)));;;
    let: "$r0" := #(W32 97) in
    do:  ("r" <-[go.rune] "$r0");;;
    let: "$r0" := #(W32 47) in
    do:  ("r" <-[go.rune] "$r0");;;
    let: "x" := (GoAlloc go.int32 (GoZeroVal go.int32 #())) in
    let: "$r0" := #(W32 98) in
    do:  ("x" <-[go.int32] "$r0");;;
    let: "$r0" := (![go.int32] "x") in
    do:  ("r" <-[go.rune] "$r0");;;
    return: (![go.rune] "r")).

Definition SliceAliasⁱᵐᵖˡ : go.type := go.SliceType go.bool.

Definition SliceAlias : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.SliceAlias"%go [].

Module SliceAlias.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t  : Type := slice.t.
End def.
End SliceAlias.

Class SliceAlias_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] SliceAlias_zero_val  :: go.GoZeroValEq SliceAlias SliceAlias.t;
}.

Definition sliceOps {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.sliceOps"%go.

(* go: slices.go:5:6 *)
Definition sliceOpsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc (go.SliceType go.uint64) (GoZeroVal (go.SliceType go.uint64) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType go.uint64] #()) #(W64 10)) in
    do:  ("x" <-[go.SliceType go.uint64] "$r0");;;
    let: "v1" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (![go.uint64] (IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "x", #(W64 2)))) in
    do:  ("v1" <-[go.uint64] "$r0");;;
    let: "v2" := (GoAlloc (go.SliceType go.uint64) (GoZeroVal (go.SliceType go.uint64) #())) in
    let: "$r0" := (let: "$s" := (![go.SliceType go.uint64] "x") in
    Slice (go.SliceType go.uint64) ("$s", #(W64 2), #(W64 3))) in
    do:  ("v2" <-[go.SliceType go.uint64] "$r0");;;
    let: "v3" := (GoAlloc (go.SliceType go.uint64) (GoZeroVal (go.SliceType go.uint64) #())) in
    let: "$r0" := (let: "$s" := (![go.SliceType go.uint64] "x") in
    Slice (go.SliceType go.uint64) ("$s", #(W64 0), #(W64 3))) in
    do:  ("v3" <-[go.SliceType go.uint64] "$r0");;;
    let: "v4" := (GoAlloc (go.PointerType go.uint64) (GoZeroVal (go.PointerType go.uint64) #())) in
    let: "$r0" := (IndexRef go.uint64 (![go.SliceType go.uint64] "x", #(W64 2))) in
    do:  ("v4" <-[go.PointerType go.uint64] "$r0");;;
    return: ((((((![go.uint64] "v1") +⟨go.uint64⟩ (![go.uint64] (IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "v2", #(W64 0))))) +⟨go.uint64⟩ (![go.uint64] (IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "v3", #(W64 1))))) +⟨go.uint64⟩ (![go.uint64] (![go.PointerType go.uint64] "v4"))) +⟨go.uint64⟩ (s_to_w64 (let: "$a0" := (![go.SliceType go.uint64] "x") in
     (FuncResolve go.len [go.SliceType go.uint64] #()) "$a0"))) +⟨go.uint64⟩ (s_to_w64 (let: "$a0" := (![go.SliceType go.uint64] "x") in
     (FuncResolve go.cap [go.SliceType go.uint64] #()) "$a0")))).

Definition makeSingletonSlice {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.makeSingletonSlice"%go.

(* go: slices.go:14:6 *)
Definition makeSingletonSliceⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x",
    exception_do (let: "x" := (GoAlloc go.uint64 "x") in
    return: (CompositeLiteral (go.SliceType go.uint64) (LiteralValue [KeyedElement None (ElementExpression (![go.uint64] "x"))]))).

Definition thingⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "x"%go go.uint64)
].

Definition thing : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.thing"%go [].

Module thing.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  x : w64;
}.
#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
End def.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.

End thing.

Class thing_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] thing_zero_val  :: go.GoZeroValEq thing thing.t;
}.

Definition sliceOfThings : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.sliceOfThings"%go [].

(* go: slices.go:26:25 *)
Definition sliceOfThings__getThingRefⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "ts" "i",
    exception_do (let: "ts" := (GoAlloc sliceOfThings "ts") in
    let: "i" := (GoAlloc go.uint64 "i") in
    return: (IndexRef thing (![go.SliceType thing] (StructFieldRef sliceOfThings "things"%go "ts"), ![go.uint64] "i"))).

Definition sliceOfThingsⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "things"%go (go.SliceType thing))
].

Module sliceOfThings.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  things : slice.t;
}.
#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
End def.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.

End sliceOfThings.

Class sliceOfThings_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] sliceOfThings_zero_val  :: go.GoZeroValEq sliceOfThings sliceOfThings.t;
  #[global] sliceOfThings'ptr_getThingRef_unfold :: MethodUnfold (sliceOfThings) "getThingRef" (sliceOfThings__getThingRefⁱᵐᵖˡ);
  #[global] sliceOfThings'ptr_getThingRef_unfold :: MethodUnfold (go.PointerType (sliceOfThings)) "getThingRef" (λ: "$r", MethodResolve (sliceOfThings) getThingRef #() (![(sliceOfThings)] "$r");
}.

Definition makeAlias {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.makeAlias"%go.

(* go: slices.go:30:6 *)
Definition makeAliasⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: ((FuncResolve go.make2 [SliceAlias] #()) #(W64 10))).

Definition Skip {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.Skip"%go.

(* Skip is a placeholder for some impure code

   go: spawn.go:8:6 *)
Definition Skipⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (do:  #()).

Definition simpleSpawn {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.simpleSpawn"%go.

(* go: spawn.go:10:6 *)
Definition simpleSpawnⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "l" := (GoAlloc (go.PointerType sync.Mutex) (GoZeroVal (go.PointerType sync.Mutex) #())) in
    let: "$r0" := (GoAlloc sync.Mutex (GoZeroVal sync.Mutex #())) in
    do:  ("l" <-[go.PointerType sync.Mutex] "$r0");;;
    let: "v" := (GoAlloc (go.PointerType go.uint64) (GoZeroVal (go.PointerType go.uint64) #())) in
    let: "$r0" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    do:  ("v" <-[go.PointerType go.uint64] "$r0");;;
    let: "$go" := (λ: <>,
      exception_do (do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go #() (![go.PointerType sync.Mutex] "l")) #());;;
      let: "x" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: "$r0" := (![go.uint64] (![go.PointerType go.uint64] "v")) in
      do:  ("x" <-[go.uint64] "$r0");;;
      (if: (![go.uint64] "x") >⟨go.uint64⟩ #(W64 0)
      then do:  ((FuncResolve Skip [] #()) #())
      else do:  #());;;
      do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go #() (![go.PointerType sync.Mutex] "l")) #());;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go #() (![go.PointerType sync.Mutex] "l")) #());;;
    let: "$r0" := #(W64 1) in
    do:  ((![go.PointerType go.uint64] "v") <-[go.uint64] "$r0");;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go #() (![go.PointerType sync.Mutex] "l")) #());;;
    return: #()).

Definition threadCode {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.threadCode"%go.

(* go: spawn.go:26:6 *)
Definition threadCodeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "tid",
    exception_do (let: "tid" := (GoAlloc go.uint64 "tid") in
    do:  #()).

Definition loopSpawn {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.loopSpawn"%go.

(* go: spawn.go:28:6 *)
Definition loopSpawnⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do ((let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, (![go.uint64] "i") <⟨go.uint64⟩ #(W64 10)); (λ: <>, do:  ("i" <-[go.uint64] ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 1)))) := λ: <>,
      let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: "$r0" := (![go.uint64] "i") in
      do:  ("i" <-[go.uint64] "$r0");;;
      let: "$go" := (λ: <>,
        exception_do (do:  (let: "$a0" := (![go.uint64] "i") in
        (FuncResolve threadCode [] #()) "$a0");;;
        return: #())
        ) in
      do:  (Fork ("$go" #()))));;;
    (let: "dummy" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #true in
    do:  ("dummy" <-[go.bool] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "$r0" := (~ (![go.bool] "dummy")) in
      do:  ("dummy" <-[go.bool] "$r0");;;
      continue: #()));;;
    return: #()).

Definition stringAppend {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.stringAppend"%go.

(* go: strings.go:3:6 *)
Definition stringAppendⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s",
    exception_do (let: "s" := (GoAlloc go.string "s") in
    return: ((#"prefix "%go +⟨go.string⟩ (![go.string] "s")) +⟨go.string⟩ #" "%go)).

Definition stringLength {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.stringLength"%go.

(* go: strings.go:7:6 *)
Definition stringLengthⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s",
    exception_do (let: "s" := (GoAlloc go.string "s") in
    return: (s_to_w64 (let: "$a0" := (![go.string] "s") in
     (FuncResolve go.len [go.string] #()) "$a0"))).

Definition x {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.x"%go.

(* go: strings.go:11:6 *)
Definition xⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (do:  (let: "$a0" := #"ab"%go in
    (FuncResolve stringAppend [] #()) "$a0");;;
    return: #()).

Definition Point : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.Point"%go [].

(* go: struct_method.go:8:16 *)
Definition Point__Addⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "c" "z",
    exception_do (let: "c" := (GoAlloc Point "c") in
    let: "z" := (GoAlloc go.uint64 "z") in
    return: (((![go.uint64] (StructFieldRef Point "x"%go "c")) +⟨go.uint64⟩ (![go.uint64] (StructFieldRef Point "y"%go "c"))) +⟨go.uint64⟩ (![go.uint64] "z"))).

(* go: struct_method.go:12:16 *)
Definition Point__GetFieldⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "c" <>,
    exception_do (let: "c" := (GoAlloc Point "c") in
    let: "x" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (![go.uint64] (StructFieldRef Point "x"%go "c")) in
    do:  ("x" <-[go.uint64] "$r0");;;
    let: "y" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (![go.uint64] (StructFieldRef Point "y"%go "c")) in
    do:  ("y" <-[go.uint64] "$r0");;;
    return: ((![go.uint64] "x") +⟨go.uint64⟩ (![go.uint64] "y"))).

(* go: struct_method.go:29:14 *)
Definition Point__IgnoreReceiverⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <> <>,
    exception_do (return: (#"ok"%go)).

Definition Pointⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "x"%go go.uint64);
  (go.FieldDecl "y"%go go.uint64)
].

Module Point.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  x : w64;
  y : w64;
}.
#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _)|}.
End def.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.

End Point.

Class Point_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Point_zero_val  :: go.GoZeroValEq Point Point.t;
  #[global] Point'ptr_Add_unfold :: MethodUnfold (Point) "Add" (Point__Addⁱᵐᵖˡ);
  #[global] Point'ptr_GetField_unfold :: MethodUnfold (Point) "GetField" (Point__GetFieldⁱᵐᵖˡ);
  #[global] Point'ptr_IgnoreReceiver_unfold :: MethodUnfold (Point) "IgnoreReceiver" (Point__IgnoreReceiverⁱᵐᵖˡ);
  #[global] Point'ptr_Add_unfold :: MethodUnfold (go.PointerType (Point)) "Add" (λ: "$r", MethodResolve (Point) Add #() (![(Point)] "$r");
  #[global] Point'ptr_GetField_unfold :: MethodUnfold (go.PointerType (Point)) "GetField" (λ: "$r", MethodResolve (Point) GetField #() (![(Point)] "$r");
  #[global] Point'ptr_IgnoreReceiver_unfold :: MethodUnfold (go.PointerType (Point)) "IgnoreReceiver" (λ: "$r", MethodResolve (Point) IgnoreReceiver #() (![(Point)] "$r");
}.

Definition UseAdd {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.UseAdd"%go.

(* go: struct_method.go:18:6 *)
Definition UseAddⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "c" := (GoAlloc Point (GoZeroVal Point #())) in
    let: "$r0" := (CompositeLiteral Point (LiteralValue [KeyedElement (Some (KeyField "x"%go)) (ElementExpression #(W64 2)); KeyedElement (Some (KeyField "y"%go)) (ElementExpression #(W64 3))])) in
    do:  ("c" <-[Point] "$r0");;;
    let: "r" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (let: "$a0" := #(W64 4) in
    (MethodResolve Point "Add"%go #() (![Point] "c")) "$a0") in
    do:  ("r" <-[go.uint64] "$r0");;;
    return: (![go.uint64] "r")).

Definition UseAddWithLiteral {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.UseAddWithLiteral"%go.

(* go: struct_method.go:24:6 *)
Definition UseAddWithLiteralⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "r" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (let: "$a0" := #(W64 4) in
    (MethodResolve Point "Add"%go #() (CompositeLiteral Point (LiteralValue [KeyedElement (Some (KeyField "x"%go)) (ElementExpression #(W64 2)); KeyedElement (Some (KeyField "y"%go)) (ElementExpression #(W64 3))]))) "$a0") in
    do:  ("r" <-[go.uint64] "$r0");;;
    return: (![go.uint64] "r")).

Definition TwoIntsⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "x"%go go.uint64);
  (go.FieldDecl "y"%go go.uint64)
].

Definition TwoInts : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.TwoInts"%go [].

Module TwoInts.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  x : w64;
  y : w64;
}.
#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _)|}.
End def.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.

End TwoInts.

Class TwoInts_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] TwoInts_zero_val  :: go.GoZeroValEq TwoInts TwoInts.t;
}.

Definition S : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.S"%go [].

(* go: struct_pointers.go:30:12 *)
Definition S__readBValⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" <>,
    exception_do (let: "s" := (GoAlloc S "s") in
    return: (![TwoInts] (StructFieldRef S "b"%go "s"))).

(* go: struct_pointers.go:38:13 *)
Definition S__negateCⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" <>,
    exception_do (let: "s" := (GoAlloc (go.PointerType S) "s") in
    let: "$r0" := (~ (![go.bool] (StructFieldRef S "c"%go (![go.PointerType S] "s")))) in
    do:  ((StructFieldRef S "c"%go (![go.PointerType S] "s")) <-[go.bool] "$r0");;;
    return: #()).

(* go: struct_pointers.go:22:13 *)
Definition S__readAⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" <>,
    exception_do (let: "s" := (GoAlloc (go.PointerType S) "s") in
    return: (![go.uint64] (StructFieldRef S "a"%go (![go.PointerType S] "s")))).

(* go: struct_pointers.go:26:13 *)
Definition S__readBⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" <>,
    exception_do (let: "s" := (GoAlloc (go.PointerType S) "s") in
    return: (![TwoInts] (StructFieldRef S "b"%go (![go.PointerType S] "s")))).

(* go: struct_pointers.go:42:13 *)
Definition S__refCⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" <>,
    exception_do (let: "s" := (GoAlloc (go.PointerType S) "s") in
    return: (StructFieldRef S "c"%go (![go.PointerType S] "s"))).

(* go: struct_pointers.go:34:13 *)
Definition S__writeBⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" "two",
    exception_do (let: "s" := (GoAlloc (go.PointerType S) "s") in
    let: "two" := (GoAlloc TwoInts "two") in
    let: "$r0" := (![TwoInts] "two") in
    do:  ((StructFieldRef S "b"%go (![go.PointerType S] "s")) <-[TwoInts] "$r0");;;
    return: #()).

Definition Sⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "a"%go go.uint64);
  (go.FieldDecl "b"%go TwoInts);
  (go.FieldDecl "c"%go go.bool)
].

Module S.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  a : w64;
  b : unittest.TwoInts.t;
  c : bool;
}.
#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _)|}.
End def.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.

End S.

Class S_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] S_zero_val  :: go.GoZeroValEq S S.t;
  #[global] S'ptr_readBVal_unfold :: MethodUnfold (S) "readBVal" (S__readBValⁱᵐᵖˡ);
  #[global] S'ptr_negateC_unfold :: MethodUnfold (go.PointerType (S)) "negateC" (S__negateCⁱᵐᵖˡ);
  #[global] S'ptr_readA_unfold :: MethodUnfold (go.PointerType (S)) "readA" (S__readAⁱᵐᵖˡ);
  #[global] S'ptr_readB_unfold :: MethodUnfold (go.PointerType (S)) "readB" (S__readBⁱᵐᵖˡ);
  #[global] S'ptr_readBVal_unfold :: MethodUnfold (go.PointerType (S)) "readBVal" (λ: "$r", MethodResolve (S) readBVal #() (![(S)] "$r");
  #[global] S'ptr_refC_unfold :: MethodUnfold (go.PointerType (S)) "refC" (S__refCⁱᵐᵖˡ);
  #[global] S'ptr_writeB_unfold :: MethodUnfold (go.PointerType (S)) "writeB" (S__writeBⁱᵐᵖˡ);
}.

Definition NewS {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.NewS"%go.

(* go: struct_pointers.go:14:6 *)
Definition NewSⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (GoAlloc S (CompositeLiteral S (LiteralValue [KeyedElement (Some (KeyField "a"%go)) (ElementExpression #(W64 2)); KeyedElement (Some (KeyField "b"%go)) (CompositeLiteral TwoInts (LiteralValue [KeyedElement (Some (KeyField "x"%go)) (ElementExpression #(W64 1)); KeyedElement (Some (KeyField "y"%go)) (ElementExpression #(W64 2))])); KeyedElement (Some (KeyField "c"%go)) (ElementExpression #true)])))).

Definition localSRef {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.localSRef"%go.

(* go: struct_pointers.go:46:6 *)
Definition localSRefⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "s" := (GoAlloc S (GoZeroVal S #())) in
    return: (StructFieldRef S "b"%go "s")).

Definition setField {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.setField"%go.

(* go: struct_pointers.go:54:6 *)
Definition setFieldⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "s" := (GoAlloc S (GoZeroVal S #())) in
    let: "$r0" := #(W64 0) in
    do:  ((StructFieldRef S "a"%go "s") <-[go.uint64] "$r0");;;
    let: "$r0" := #true in
    do:  ((StructFieldRef S "c"%go "s") <-[go.bool] "$r0");;;
    return: (![S] "s")).

Definition testSwitchVal {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.testSwitchVal"%go.

(* go: switch.go:3:6 *)
Definition testSwitchValⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x",
    exception_do (let: "x" := (GoAlloc go.uint64 "x") in
    let: "$sw" := (![go.uint64] "x") in
    (if: "$sw" =⟨go.uint64⟩ #(W64 0)
    then return: (#true)
    else
      (if: "$sw" =⟨go.uint64⟩ #(W64 1)
      then return: (#false)
      else return: (#false)))).

Definition testSwitchMultiple {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.testSwitchMultiple"%go.

(* go: switch.go:14:6 *)
Definition testSwitchMultipleⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x",
    exception_do (let: "x" := (GoAlloc go.uint64 "x") in
    let: "$sw" := (![go.uint64] "x") in
    (if: ("$sw" =⟨go.uint64⟩ #(W64 1)) || ("$sw" =⟨go.uint64⟩ #(W64 10))
    then return: (#(W64 1))
    else
      (if: "$sw" =⟨go.uint64⟩ #(W64 0)
      then return: (#(W64 2))
      else do:  #()));;;
    return: (#(W64 3))).

Definition DoSomeLocking {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.DoSomeLocking"%go.

(* DoSomeLocking uses the entire lock API

   go: synchronization.go:6:6 *)
Definition DoSomeLockingⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l",
    exception_do (let: "l" := (GoAlloc (go.PointerType sync.Mutex) "l") in
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go #() (![go.PointerType sync.Mutex] "l")) #());;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go #() (![go.PointerType sync.Mutex] "l")) #());;;
    return: #()).

Definition makeLock {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.makeLock"%go.

(* go: synchronization.go:15:6 *)
Definition makeLockⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "l" := (GoAlloc (go.PointerType sync.Mutex) (GoZeroVal (go.PointerType sync.Mutex) #())) in
    let: "$r0" := (GoAlloc sync.Mutex (GoZeroVal sync.Mutex #())) in
    do:  ("l" <-[go.PointerType sync.Mutex] "$r0");;;
    do:  (let: "$a0" := (![go.PointerType sync.Mutex] "l") in
    (FuncResolve DoSomeLocking [] #()) "$a0");;;
    return: #()).

Definition sleep {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.sleep"%go.

(* go: time.go:5:6 *)
Definition sleepⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (do:  (let: "$a0" := #(W64 1000) in
    (FuncResolve primitive.Sleep [] #()) "$a0");;;
    return: #()).

Definition A : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.A"%go [].

Definition Bⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "a"%go (go.SliceType A))
].

Definition B : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.B"%go [].

Module B.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  a : slice.t;
}.
#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
End def.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.

End B.

Class B_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] B_zero_val  :: go.GoZeroValEq B B.t;
}.

Definition Aⁱᵐᵖˡ : go.type := go.StructType [
].

Module A.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
}.
#[global] Instance zero_val : ZeroVal t := {| zero_val := mk|}.
End def.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.

End A.

Class A_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] A_zero_val  :: go.GoZeroValEq A A.t;
}.

Definition mkInt {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.mkInt"%go.

(* go: trailing_call.go:3:6 *)
Definition mkIntⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (#(W64 42))).

Definition mkNothing {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.mkNothing"%go.

(* go: trailing_call.go:7:6 *)
Definition mkNothingⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (do:  ((FuncResolve mkInt [] #()) #());;;
    return: #()).

Definition my_u64 : go.type := go.uint64.

Definition Timestampⁱᵐᵖˡ : go.type := go.uint64.

Definition Timestamp : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.Timestamp"%go [].

Module Timestamp.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t  : Type := w64.
End def.
End Timestamp.

Class Timestamp_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Timestamp_zero_val  :: go.GoZeroValEq Timestamp Timestamp.t;
}.

Definition UseTypeAbbrevⁱᵐᵖˡ : go.type := go.uint64.

Definition UseTypeAbbrev : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.UseTypeAbbrev"%go [].

Module UseTypeAbbrev.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t  : Type := w64.
End def.
End UseTypeAbbrev.

Class UseTypeAbbrev_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] UseTypeAbbrev_zero_val  :: go.GoZeroValEq UseTypeAbbrev UseTypeAbbrev.t;
}.

Definition UseNamedTypeⁱᵐᵖˡ : go.type := Timestamp.

Definition UseNamedType : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.UseNamedType"%go [].

Module UseNamedType.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t  : Type := unittest.Timestamp.t.
End def.
End UseNamedType.

Class UseNamedType_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] UseNamedType_zero_val  :: go.GoZeroValEq UseNamedType UseNamedType.t;
}.

Definition convertToAlias {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.convertToAlias"%go.

(* go: type_alias.go:11:6 *)
Definition convertToAliasⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 2) in
    do:  ("x" <-[go.uint64] "$r0");;;
    return: (![go.uint64] "x")).

Definition typeAssertInt {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.typeAssertInt"%go.

(* go: type_switch.go:3:6 *)
Definition typeAssertIntⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x",
    exception_do (let: "x" := (GoAlloc (go.InterfaceType []) "x") in
    return: (TypeAssert go.int (![go.InterfaceType []] "x"))).

Definition wrapUnwrapInt {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.wrapUnwrapInt"%go.

(* go: type_switch.go:7:6 *)
Definition wrapUnwrapIntⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (let: "$a0" := (InterfaceMake go.int #(W64 1)) in
     (FuncResolve typeAssertInt [] #()) "$a0")).

Definition checkedTypeAssert {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.checkedTypeAssert"%go.

(* go: type_switch.go:11:6 *)
Definition checkedTypeAssertⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x",
    exception_do (let: "x" := (GoAlloc (go.InterfaceType []) "x") in
    (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "v" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: ("$ret0", "$ret1") := (TypeAssert2 go.uint64 (![go.InterfaceType []] "x")) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("v" <-[go.uint64] "$r0");;;
    do:  ("ok" <-[go.bool] "$r1");;;
    (if: ![go.bool] "ok"
    then return: (![go.uint64] "v")
    else do:  #()));;;
    return: (#(W64 3))).

Definition basicTypeSwitch {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.basicTypeSwitch"%go.

(* go: type_switch.go:18:6 *)
Definition basicTypeSwitchⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x",
    exception_do (let: "x" := (GoAlloc (go.InterfaceType []) "x") in
    let: "$y" := (![go.InterfaceType []] "x") in
    let: ("$x", "$ok") := (TypeAssert2 go.int "$y" #go.int) in
    (if: "$ok"
    then return: (#(W64 1))
    else
      let: ("$x", "$ok") := (TypeAssert2 go.string "$y" #go.string) in
      (if: "$ok"
      then return: (#(W64 2))
      else do:  #()));;;
    return: (#(W64 0))).

Definition fancyTypeSwitch {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.fancyTypeSwitch"%go.

(* go: type_switch.go:28:6 *)
Definition fancyTypeSwitchⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x",
    exception_do (let: "x" := (GoAlloc (go.InterfaceType []) "x") in
    let: "r" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$y" := (![go.InterfaceType []] "x") in
    (let: "z" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := #(W64 0) in
    do:  ("z" <-[go.int] "$r0");;;
    let: ("$x", "$ok") := (TypeAssert2 go.int "$y" #go.int) in
    (if: "$ok"
    then
      let: "y" := (GoAlloc go.int "$x") in
      return: (![go.int] "y")
    else
      let: ("$x", "$ok") := (TypeAssert2 go.string "$y" #go.string) in
      (if: "$ok"
      then
        let: "y" := (GoAlloc go.string "$x") in
        return: (#(W64 2))
      else
        let: "$ok" := ("$y" =⟨go.InterfaceType []⟩ #interface.nil) in
        let: "$x" := "$y" in
        (if: "$ok"
        then
          let: "y" := (GoAlloc go.untyped nil "$x") in
          return: (#(W64 4))
        else
          let: "$r0" := #(W64 3) in
          do:  ("z" <-[go.int] "$r0");;;
          let: "$r0" := (![go.int] "z") in
          do:  ("r" <-[go.int] "$r0")))));;;
    return: (![go.int] "r")).

Definition multiTypeSwitch {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.multiTypeSwitch"%go.

(* go: type_switch.go:44:6 *)
Definition multiTypeSwitchⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x",
    exception_do (let: "x" := (GoAlloc (go.InterfaceType []) "x") in
    let: "$y" := (![go.InterfaceType []] "x") in
    let: "$ok" := ((Snd (TypeAssert2 go.int "$y" #go.int)) || (Snd (TypeAssert2 go.int "$y" #go.int))) in
    let: "$x" := "$y" in
    (if: "$ok"
    then return: (#(W64 1))
    else do:  #());;;
    return: (#(W64 0))).

Definition variadicFunc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.variadicFunc"%go.

(* go: varargs.go:3:6 *)
Definition variadicFuncⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "a" "b" "cs",
    exception_do (let: "cs" := (GoAlloc (go.SliceType go.byte) "cs") in
    let: "b" := (GoAlloc go.string "b") in
    let: "a" := (GoAlloc go.uint64 "a") in
    do:  #()).

Definition testVariadicCall {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.testVariadicCall"%go.

(* go: varargs.go:6:6 *)
Definition testVariadicCallⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (do:  (let: "$a0" := #(W64 10) in
    let: "$a1" := #"abc"%go in
    let: "$a2" := ((let: "$sl0" := #(W8 0) in
    let: "$sl1" := #(W8 1) in
    let: "$sl2" := #(W8 2) in
    let: "$sl3" := #(W8 3) in
    CompositeLiteral go.byte (LiteralValue [KeyedElement None (ElementExpression "$sl0"); KeyedElement None (ElementExpression "$sl1"); KeyedElement None (ElementExpression "$sl2"); KeyedElement None (ElementExpression "$sl3")]))) in
    (FuncResolve variadicFunc [] #()) "$a0" "$a1" "$a2");;;
    do:  (let: "$a0" := #(W64 10) in
    let: "$a1" := #"abc"%go in
    let: "$a2" := #slice.nil in
    (FuncResolve variadicFunc [] #()) "$a0" "$a1" "$a2");;;
    let: "c" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    do:  (let: "$a0" := #(W64 10) in
    let: "$a1" := #"abc"%go in
    let: "$a2" := (![go.SliceType go.byte] "c") in
    (FuncResolve variadicFunc [] #()) "$a0" "$a1" "$a2");;;
    return: #()).

Definition returnMultiple {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.returnMultiple"%go.

(* go: varargs.go:13:6 *)
Definition returnMultipleⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (#(W64 0), #"xyz"%go, #(W8 0), #(W8 0))).

Definition testVariadicPassThrough {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.testVariadicPassThrough"%go.

(* go: varargs.go:17:6 *)
Definition testVariadicPassThroughⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (do:  (let: ((("$ret0", "$ret1"), "$ret2"), "$ret3") := (((FuncResolve returnMultiple [] #()) #())) in
    let: "$a0" := "$ret0" in
    let: "$a1" := "$ret1" in
    let: "$a2" := ((let: "$sl0" := "$ret2" in
    let: "$sl1" := "$ret3" in
    CompositeLiteral go.byte (LiteralValue [KeyedElement None (ElementExpression "$sl0"); KeyedElement None (ElementExpression "$sl1")]))) in
    (FuncResolve variadicFunc [] #()) "$a0" "$a1" "$a2");;;
    return: #()).

Definition LocalVars {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.LocalVars"%go.

(* go: vars.go:3:6 *)
Definition LocalVarsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "b" := (GoAlloc go.string (GoZeroVal go.string #())) in
    let: "a" := (GoAlloc go.int (GoZeroVal go.int #())) in
    do:  ("b" <-[go.string] ((![go.string] "b") +⟨go.string⟩ #"hello"%go));;;
    return: (![go.int] "a")).

Definition LocalConsts {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.LocalConsts"%go.

(* go: vars.go:12:6 *)
Definition LocalConstsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let c := 10 in
    let d := 15 in
    let e := 8 in
    do:  ("x" <-[go.int] ((![go.int] "x") +⟨go.int⟩ #(W64 c)));;;
    do:  ("x" <-[go.int] ((![go.int] "x") -⟨go.int⟩ #(W64 d)));;;
    return: (![go.int] "x")).

#[global] Instance info' : PkgInfo unittest.unittest := 
{|
  pkg_imported_pkgs := [code.fmt.fmt; code.sync.sync; code.github_com.goose_lang.primitive.primitive; code.github_com.goose_lang.primitive.disk.disk; code.log.log; code.github_com.goose_lang.std.std]
|}.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init unittest.unittest (λ: <>,
      exception_do (do:  (GoGlobalAlloc mapLiteralWithConversion (go.MapType (go.InterfaceType []) (go.InterfaceType [])));;;
      do:  (GoGlobalAlloc mapLiteral (go.MapType go.string go.uint64));;;
      do:  (GoGlobalAlloc globalB go.string);;;
      do:  (GoGlobalAlloc globalA go.string);;;
      do:  (GoGlobalAlloc globalY go.string);;;
      do:  (GoGlobalAlloc GlobalX go.uint64);;;
      do:  (std.initialize' #());;;
      do:  (log.initialize' #());;;
      do:  (disk.initialize' #());;;
      do:  (primitive.initialize' #());;;
      do:  (sync.initialize' #());;;
      do:  (fmt.initialize' #());;;
      let: "$r0" := ((FuncResolve foo [] #()) #()) in
      do:  ((GloblalVarAddr #GlobalX) <-[go.uint64] "$r0");;;
      let: "$r0" := #"a"%go in
      do:  ((GloblalVarAddr #globalA) <-[go.string] "$r0");;;
      let: "$r0" := #"b"%go in
      do:  ((GloblalVarAddr #globalB) <-[go.string] "$r0");;;
      let: "$r0" := ((FuncResolve foo [] #()) #()) in
      let: "$r0" := (CompositeLiteral (go.MapType go.string go.uint64) (LiteralValue [KeyedElement (Some (KeyExpression #"a"%go)) (ElementExpression #(W64 10))])) in
      do:  ((GloblalVarAddr #mapLiteral) <-[go.MapType go.string go.uint64] "$r0");;;
      let: "$r0" := (CompositeLiteral (go.MapType (go.InterfaceType []) (go.InterfaceType [])) (LiteralValue [KeyedElement (Some (KeyExpression #"a"%go)) (ElementExpression #(W64 10))])) in
      do:  ((GloblalVarAddr #mapLiteralWithConversion) <-[go.MapType (go.InterfaceType []) (go.InterfaceType [])] "$r0");;;
      do:  ((λ: <>,
        exception_do (let: "$r0" := (![go.uint64] (GlobalVarAddr GlobalX #())) in
        do:  ((GlobalVarAddr GlobalX #()) <-[go.uint64] "$r0");;;
        return: #())
        ) #());;;
      do:  ((λ: <>,
        exception_do (let: "$r0" := #""%go in
        do:  ((GlobalVarAddr globalY #()) <-[go.string] "$r0");;;
        return: #())
        ) #()))
      ).

Class Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Foo_instance :: Foo_Assumptions;
  #[global] importantStruct_instance :: importantStruct_Assumptions;
  #[global] stringWrapper_instance :: stringWrapper_Assumptions;
  #[global] Uint32_instance :: Uint32_Assumptions;
  #[global] numWrapper_instance :: numWrapper_Assumptions;
  #[global] diskWrapper_instance :: diskWrapper_Assumptions;
  #[global] embedA_instance :: embedA_Assumptions;
  #[global] embedB_instance :: embedB_Assumptions;
  #[global] embedC_instance :: embedC_Assumptions;
  #[global] embedD_instance :: embedD_Assumptions;
  #[global] Enc_instance :: Enc_Assumptions;
  #[global] Dec_instance :: Dec_Assumptions;
  #[global] Enum1_instance :: Enum1_Assumptions;
  #[global] Enum2_instance :: Enum2_Assumptions;
  #[global] Fooer_instance :: Fooer_Assumptions;
  #[global] concreteFooer_instance :: concreteFooer_Assumptions;
  #[global] FooerUser_instance :: FooerUser_Assumptions;
  #[global] PointerInterface_instance :: PointerInterface_Assumptions;
  #[global] concrete1_instance :: concrete1_Assumptions;
  #[global] my_u32_instance :: my_u32_Assumptions;
  #[global] also_u32_instance :: also_u32_Assumptions;
  #[global] allTheLiterals_instance :: allTheLiterals_Assumptions;
  #[global] hasCondVar_instance :: hasCondVar_Assumptions;
  #[global] IntWrapper_instance :: IntWrapper_Assumptions;
  #[global] MapWrapper_instance :: MapWrapper_Assumptions;
  #[global] mapElem_instance :: mapElem_Assumptions;
  #[global] containsPointer_instance :: containsPointer_Assumptions;
  #[global] wrapExternalStruct_instance :: wrapExternalStruct_Assumptions;
  #[global] typing_instance :: typing_Assumptions;
  #[global] composite_instance :: composite_Assumptions;
  #[global] R_instance :: R_Assumptions;
  #[global] Other_instance :: Other_Assumptions;
  #[global] RecursiveEmbedded_instance :: RecursiveEmbedded_Assumptions;
  #[global] Block_instance :: Block_Assumptions;
  #[global] SliceAlias_instance :: SliceAlias_Assumptions;
  #[global] thing_instance :: thing_Assumptions;
  #[global] sliceOfThings_instance :: sliceOfThings_Assumptions;
  #[global] Point_instance :: Point_Assumptions;
  #[global] TwoInts_instance :: TwoInts_Assumptions;
  #[global] S_instance :: S_Assumptions;
  #[global] B_instance :: B_Assumptions;
  #[global] A_instance :: A_Assumptions;
  #[global] Timestamp_instance :: Timestamp_Assumptions;
  #[global] UseTypeAbbrev_instance :: UseTypeAbbrev_Assumptions;
  #[global] UseNamedType_instance :: UseNamedType_Assumptions;
  #[global] takesArray_unfold :: FuncUnfold takesArray [] (takesArrayⁱᵐᵖˡ);
  #[global] takesPtr_unfold :: FuncUnfold takesPtr [] (takesPtrⁱᵐᵖˡ);
  #[global] usesArrayElemRef_unfold :: FuncUnfold usesArrayElemRef [] (usesArrayElemRefⁱᵐᵖˡ);
  #[global] sum_unfold :: FuncUnfold sum [] (sumⁱᵐᵖˡ);
  #[global] arrayToSlice_unfold :: FuncUnfold arrayToSlice [] (arrayToSliceⁱᵐᵖˡ);
  #[global] arrayLiteralKeyed_unfold :: FuncUnfold arrayLiteralKeyed [] (arrayLiteralKeyedⁱᵐᵖˡ);
  #[global] chanBasic_unfold :: FuncUnfold chanBasic [] (chanBasicⁱᵐᵖˡ);
  #[global] f_unfold :: FuncUnfold f [] (fⁱᵐᵖˡ);
  #[global] chanSelect_unfold :: FuncUnfold chanSelect [] (chanSelectⁱᵐᵖˡ);
  #[global] chanDirectional_unfold :: FuncUnfold chanDirectional [] (chanDirectionalⁱᵐᵖˡ);
  #[global] chanRange_unfold :: FuncUnfold chanRange [] (chanRangeⁱᵐᵖˡ);
  #[global] doSubtleThings_unfold :: FuncUnfold doSubtleThings [] (doSubtleThingsⁱᵐᵖˡ);
  #[global] hasStartComment_unfold :: FuncUnfold hasStartComment [] (hasStartCommentⁱᵐᵖˡ);
  #[global] hasEndComment_unfold :: FuncUnfold hasEndComment [] (hasEndCommentⁱᵐᵖˡ);
  #[global] condvarWrapping_unfold :: FuncUnfold condvarWrapping [] (condvarWrappingⁱᵐᵖˡ);
  #[global] useUntypedInt_unfold :: FuncUnfold useUntypedInt [] (useUntypedIntⁱᵐᵖˡ);
  #[global] useUntypedString_unfold :: FuncUnfold useUntypedString [] (useUntypedStringⁱᵐᵖˡ);
  #[global] conditionalReturn_unfold :: FuncUnfold conditionalReturn [] (conditionalReturnⁱᵐᵖˡ);
  #[global] alwaysReturn_unfold :: FuncUnfold alwaysReturn [] (alwaysReturnⁱᵐᵖˡ);
  #[global] alwaysReturnInNestedBranches_unfold :: FuncUnfold alwaysReturnInNestedBranches [] (alwaysReturnInNestedBranchesⁱᵐᵖˡ);
  #[global] earlyReturn_unfold :: FuncUnfold earlyReturn [] (earlyReturnⁱᵐᵖˡ);
  #[global] conditionalAssign_unfold :: FuncUnfold conditionalAssign [] (conditionalAssignⁱᵐᵖˡ);
  #[global] elseIf_unfold :: FuncUnfold elseIf [] (elseIfⁱᵐᵖˡ);
  #[global] ifStmtInitialization_unfold :: FuncUnfold ifStmtInitialization [] (ifStmtInitializationⁱᵐᵖˡ);
  #[global] typedLiteral_unfold :: FuncUnfold typedLiteral [] (typedLiteralⁱᵐᵖˡ);
  #[global] literalCast_unfold :: FuncUnfold literalCast [] (literalCastⁱᵐᵖˡ);
  #[global] castInt_unfold :: FuncUnfold castInt [] (castIntⁱᵐᵖˡ);
  #[global] stringToByteSlice_unfold :: FuncUnfold stringToByteSlice [] (stringToByteSliceⁱᵐᵖˡ);
  #[global] byteSliceToString_unfold :: FuncUnfold byteSliceToString [] (byteSliceToStringⁱᵐᵖˡ);
  #[global] stringToStringWrapper_unfold :: FuncUnfold stringToStringWrapper [] (stringToStringWrapperⁱᵐᵖˡ);
  #[global] stringWrapperToString_unfold :: FuncUnfold stringWrapperToString [] (stringWrapperToStringⁱᵐᵖˡ);
  #[global] testU32NewtypeLen_unfold :: FuncUnfold testU32NewtypeLen [] (testU32NewtypeLenⁱᵐᵖˡ);
  #[global] testNumWrapper_unfold :: FuncUnfold testNumWrapper [] (testNumWrapperⁱᵐᵖˡ);
  #[global] testCopySimple_unfold :: FuncUnfold testCopySimple [] (testCopySimpleⁱᵐᵖˡ);
  #[global] testCopyDifferentLengths_unfold :: FuncUnfold testCopyDifferentLengths [] (testCopyDifferentLengthsⁱᵐᵖˡ);
  #[global] atomicCreateStub_unfold :: FuncUnfold atomicCreateStub [] (atomicCreateStubⁱᵐᵖˡ);
  #[global] useSlice_unfold :: FuncUnfold useSlice [] (useSliceⁱᵐᵖˡ);
  #[global] useSliceIndexing_unfold :: FuncUnfold useSliceIndexing [] (useSliceIndexingⁱᵐᵖˡ);
  #[global] useMap_unfold :: FuncUnfold useMap [] (useMapⁱᵐᵖˡ);
  #[global] usePtr_unfold :: FuncUnfold usePtr [] (usePtrⁱᵐᵖˡ);
  #[global] iterMapKeysAndValues_unfold :: FuncUnfold iterMapKeysAndValues [] (iterMapKeysAndValuesⁱᵐᵖˡ);
  #[global] iterMapKeys_unfold :: FuncUnfold iterMapKeys [] (iterMapKeysⁱᵐᵖˡ);
  #[global] getRandom_unfold :: FuncUnfold getRandom [] (getRandomⁱᵐᵖˡ);
  #[global] diskArgument_unfold :: FuncUnfold diskArgument [] (diskArgumentⁱᵐᵖˡ);
  #[global] returnEmbedVal_unfold :: FuncUnfold returnEmbedVal [] (returnEmbedValⁱᵐᵖˡ);
  #[global] returnEmbedValWithPointer_unfold :: FuncUnfold returnEmbedValWithPointer [] (returnEmbedValWithPointerⁱᵐᵖˡ);
  #[global] useEmbeddedField_unfold :: FuncUnfold useEmbeddedField [] (useEmbeddedFieldⁱᵐᵖˡ);
  #[global] useEmbeddedValField_unfold :: FuncUnfold useEmbeddedValField [] (useEmbeddedValFieldⁱᵐᵖˡ);
  #[global] useEmbeddedMethod_unfold :: FuncUnfold useEmbeddedMethod [] (useEmbeddedMethodⁱᵐᵖˡ);
  #[global] useEmbeddedMethod2_unfold :: FuncUnfold useEmbeddedMethod2 [] (useEmbeddedMethod2ⁱᵐᵖˡ);
  #[global] empty_unfold :: FuncUnfold empty [] (emptyⁱᵐᵖˡ);
  #[global] emptyReturn_unfold :: FuncUnfold emptyReturn [] (emptyReturnⁱᵐᵖˡ);
  #[global] unnamedParams_unfold :: FuncUnfold unnamedParams [] (unnamedParamsⁱᵐᵖˡ);
  #[global] anonymousParam_unfold :: FuncUnfold anonymousParam [] (anonymousParamⁱᵐᵖˡ);
  #[global] useFloat_unfold :: FuncUnfold useFloat [] (useFloatⁱᵐᵖˡ);
  #[global] compareIntFloat_unfold :: FuncUnfold compareIntFloat [] (compareIntFloatⁱᵐᵖˡ);
  #[global] compareFloatInt_unfold :: FuncUnfold compareFloatInt [] (compareFloatIntⁱᵐᵖˡ);
  #[global] forRangeNoBinding_unfold :: FuncUnfold forRangeNoBinding [] (forRangeNoBindingⁱᵐᵖˡ);
  #[global] forRangeOldVars_unfold :: FuncUnfold forRangeOldVars [] (forRangeOldVarsⁱᵐᵖˡ);
  #[global] foo_unfold :: FuncUnfold foo [] (fooⁱᵐᵖˡ);
  #[global] other_unfold :: FuncUnfold other [] (otherⁱᵐᵖˡ);
  #[global] bar_unfold :: FuncUnfold bar [] (barⁱᵐᵖˡ);
  #[global] useUntypedRune_unfold :: FuncUnfold useUntypedRune [] (useUntypedRuneⁱᵐᵖˡ);
  #[global] TakesFunctionType_unfold :: FuncUnfold TakesFunctionType [] (TakesFunctionTypeⁱᵐᵖˡ);
  #[global] FuncVar_unfold :: FuncUnfold FuncVar [] (FuncVarⁱᵐᵖˡ);
  #[global] fooConsumer_unfold :: FuncUnfold fooConsumer [] (fooConsumerⁱᵐᵖˡ);
  #[global] testAssignConcreteToInterface_unfold :: FuncUnfold testAssignConcreteToInterface [] (testAssignConcreteToInterfaceⁱᵐᵖˡ);
  #[global] testPassConcreteToInterfaceArg_unfold :: FuncUnfold testPassConcreteToInterfaceArg [] (testPassConcreteToInterfaceArgⁱᵐᵖˡ);
  #[global] testPassConcreteToInterfaceArgSpecial_unfold :: FuncUnfold testPassConcreteToInterfaceArgSpecial [] (testPassConcreteToInterfaceArgSpecialⁱᵐᵖˡ);
  #[global] takesVarArgsInterface_unfold :: FuncUnfold takesVarArgsInterface [] (takesVarArgsInterfaceⁱᵐᵖˡ);
  #[global] test_unfold :: FuncUnfold test [] (testⁱᵐᵖˡ);
  #[global] returnConcrete_unfold :: FuncUnfold returnConcrete [] (returnConcreteⁱᵐᵖˡ);
  #[global] testMultiReturn_unfold :: FuncUnfold testMultiReturn [] (testMultiReturnⁱᵐᵖˡ);
  #[global] testReturnStatment_unfold :: FuncUnfold testReturnStatment [] (testReturnStatmentⁱᵐᵖˡ);
  #[global] testConversionInEq_unfold :: FuncUnfold testConversionInEq [] (testConversionInEqⁱᵐᵖˡ);
  #[global] takeMultiple_unfold :: FuncUnfold takeMultiple [] (takeMultipleⁱᵐᵖˡ);
  #[global] giveMultiple_unfold :: FuncUnfold giveMultiple [] (giveMultipleⁱᵐᵖˡ);
  #[global] testConversionInMultipleReturnPassThrough_unfold :: FuncUnfold testConversionInMultipleReturnPassThrough [] (testConversionInMultipleReturnPassThroughⁱᵐᵖˡ);
  #[global] testConversionInMultiplePassThrough_unfold :: FuncUnfold testConversionInMultiplePassThrough [] (testConversionInMultiplePassThroughⁱᵐᵖˡ);
  #[global] testPtrMset_unfold :: FuncUnfold testPtrMset [] (testPtrMsetⁱᵐᵖˡ);
  #[global] pointerAny_unfold :: FuncUnfold pointerAny [] (pointerAnyⁱᵐᵖˡ);
  #[global] useInts_unfold :: FuncUnfold useInts [] (useIntsⁱᵐᵖˡ);
  #[global] signedMidpoint_unfold :: FuncUnfold signedMidpoint [] (signedMidpointⁱᵐᵖˡ);
  #[global] normalLiterals_unfold :: FuncUnfold normalLiterals [] (normalLiteralsⁱᵐᵖˡ);
  #[global] outOfOrderLiteral_unfold :: FuncUnfold outOfOrderLiteral [] (outOfOrderLiteralⁱᵐᵖˡ);
  #[global] specialLiterals_unfold :: FuncUnfold specialLiterals [] (specialLiteralsⁱᵐᵖˡ);
  #[global] oddLiterals_unfold :: FuncUnfold oddLiterals [] (oddLiteralsⁱᵐᵖˡ);
  #[global] unKeyedLiteral_unfold :: FuncUnfold unKeyedLiteral [] (unKeyedLiteralⁱᵐᵖˡ);
  #[global] useLocks_unfold :: FuncUnfold useLocks [] (useLocksⁱᵐᵖˡ);
  #[global] useCondVar_unfold :: FuncUnfold useCondVar [] (useCondVarⁱᵐᵖˡ);
  #[global] ToBeDebugged_unfold :: FuncUnfold ToBeDebugged [] (ToBeDebuggedⁱᵐᵖˡ);
  #[global] DoNothing_unfold :: FuncUnfold DoNothing [] (DoNothingⁱᵐᵖˡ);
  #[global] DoSomething_unfold :: FuncUnfold DoSomething [] (DoSomethingⁱᵐᵖˡ);
  #[global] standardForLoop_unfold :: FuncUnfold standardForLoop [] (standardForLoopⁱᵐᵖˡ);
  #[global] conditionalInLoop_unfold :: FuncUnfold conditionalInLoop [] (conditionalInLoopⁱᵐᵖˡ);
  #[global] conditionalInLoopElse_unfold :: FuncUnfold conditionalInLoopElse [] (conditionalInLoopElseⁱᵐᵖˡ);
  #[global] nestedConditionalInLoopImplicitContinue_unfold :: FuncUnfold nestedConditionalInLoopImplicitContinue [] (nestedConditionalInLoopImplicitContinueⁱᵐᵖˡ);
  #[global] ImplicitLoopContinue_unfold :: FuncUnfold ImplicitLoopContinue [] (ImplicitLoopContinueⁱᵐᵖˡ);
  #[global] ImplicitLoopContinue2_unfold :: FuncUnfold ImplicitLoopContinue2 [] (ImplicitLoopContinue2ⁱᵐᵖˡ);
  #[global] ImplicitLoopContinueAfterIfBreak_unfold :: FuncUnfold ImplicitLoopContinueAfterIfBreak [] (ImplicitLoopContinueAfterIfBreakⁱᵐᵖˡ);
  #[global] nestedLoops_unfold :: FuncUnfold nestedLoops [] (nestedLoopsⁱᵐᵖˡ);
  #[global] nestedGoStyleLoops_unfold :: FuncUnfold nestedGoStyleLoops [] (nestedGoStyleLoopsⁱᵐᵖˡ);
  #[global] sumSlice_unfold :: FuncUnfold sumSlice [] (sumSliceⁱᵐᵖˡ);
  #[global] intSliceLoop_unfold :: FuncUnfold intSliceLoop [] (intSliceLoopⁱᵐᵖˡ);
  #[global] breakFromLoop_unfold :: FuncUnfold breakFromLoop [] (breakFromLoopⁱᵐᵖˡ);
  #[global] IterateMapKeys_unfold :: FuncUnfold IterateMapKeys [] (IterateMapKeysⁱᵐᵖˡ);
  #[global] MapSize_unfold :: FuncUnfold MapSize [] (MapSizeⁱᵐᵖˡ);
  #[global] MapTypeAliases_unfold :: FuncUnfold MapTypeAliases [] (MapTypeAliasesⁱᵐᵖˡ);
  #[global] StringMap_unfold :: FuncUnfold StringMap [] (StringMapⁱᵐᵖˡ);
  #[global] mapUpdateField_unfold :: FuncUnfold mapUpdateField [] (mapUpdateFieldⁱᵐᵖˡ);
  #[global] mapGetCall_unfold :: FuncUnfold mapGetCall [] (mapGetCallⁱᵐᵖˡ);
  #[global] mapLiteralTest_unfold :: FuncUnfold mapLiteralTest [] (mapLiteralTestⁱᵐᵖˡ);
  #[global] mapClearTest_unfold :: FuncUnfold mapClearTest [] (mapClearTestⁱᵐᵖˡ);
  #[global] returnTwo_unfold :: FuncUnfold returnTwo [] (returnTwoⁱᵐᵖˡ);
  #[global] returnTwoWrapper_unfold :: FuncUnfold returnTwoWrapper [] (returnTwoWrapperⁱᵐᵖˡ);
  #[global] multipleVar_unfold :: FuncUnfold multipleVar [] (multipleVarⁱᵐᵖˡ);
  #[global] multiplePassThrough_unfold :: FuncUnfold multiplePassThrough [] (multiplePassThroughⁱᵐᵖˡ);
  #[global] multipleReturnPassThrough_unfold :: FuncUnfold multipleReturnPassThrough [] (multipleReturnPassThroughⁱᵐᵖˡ);
  #[global] AssignNilSlice_unfold :: FuncUnfold AssignNilSlice [] (AssignNilSliceⁱᵐᵖˡ);
  #[global] AssignNilPointer_unfold :: FuncUnfold AssignNilPointer [] (AssignNilPointerⁱᵐᵖˡ);
  #[global] CompareSliceToNil_unfold :: FuncUnfold CompareSliceToNil [] (CompareSliceToNilⁱᵐᵖˡ);
  #[global] ComparePointerToNil_unfold :: FuncUnfold ComparePointerToNil [] (ComparePointerToNilⁱᵐᵖˡ);
  #[global] useNilField_unfold :: FuncUnfold useNilField [] (useNilFieldⁱᵐᵖˡ);
  #[global] LogicalOperators_unfold :: FuncUnfold LogicalOperators [] (LogicalOperatorsⁱᵐᵖˡ);
  #[global] LogicalAndEqualityOperators_unfold :: FuncUnfold LogicalAndEqualityOperators [] (LogicalAndEqualityOperatorsⁱᵐᵖˡ);
  #[global] ArithmeticShifts_unfold :: FuncUnfold ArithmeticShifts [] (ArithmeticShiftsⁱᵐᵖˡ);
  #[global] BitwiseOps_unfold :: FuncUnfold BitwiseOps [] (BitwiseOpsⁱᵐᵖˡ);
  #[global] Comparison_unfold :: FuncUnfold Comparison [] (Comparisonⁱᵐᵖˡ);
  #[global] AssignOps_unfold :: FuncUnfold AssignOps [] (AssignOpsⁱᵐᵖˡ);
  #[global] BitwiseAndNot_unfold :: FuncUnfold BitwiseAndNot [] (BitwiseAndNotⁱᵐᵖˡ);
  #[global] Negative_unfold :: FuncUnfold Negative [] (Negativeⁱᵐᵖˡ);
  #[global] PanicAtTheDisco_unfold :: FuncUnfold PanicAtTheDisco [] (PanicAtTheDiscoⁱᵐᵖˡ);
  #[global] Oracle_unfold :: FuncUnfold Oracle [] (Oracleⁱᵐᵖˡ);
  #[global] ReassignVars_unfold :: FuncUnfold ReassignVars [] (ReassignVarsⁱᵐᵖˡ);
  #[global] recur_unfold :: FuncUnfold recur [] (recurⁱᵐᵖˡ);
  #[global] useRenamedImport_unfold :: FuncUnfold useRenamedImport [] (useRenamedImportⁱᵐᵖˡ);
  #[global] TwoDiskWrite_unfold :: FuncUnfold TwoDiskWrite [] (TwoDiskWriteⁱᵐᵖˡ);
  #[global] TwoDiskRead_unfold :: FuncUnfold TwoDiskRead [] (TwoDiskReadⁱᵐᵖˡ);
  #[global] TwoDiskLock_unfold :: FuncUnfold TwoDiskLock [] (TwoDiskLockⁱᵐᵖˡ);
  #[global] TwoDiskUnlock_unfold :: FuncUnfold TwoDiskUnlock [] (TwoDiskUnlockⁱᵐᵖˡ);
  #[global] ReplicatedDiskRead_unfold :: FuncUnfold ReplicatedDiskRead [] (ReplicatedDiskReadⁱᵐᵖˡ);
  #[global] ReplicatedDiskWrite_unfold :: FuncUnfold ReplicatedDiskWrite [] (ReplicatedDiskWriteⁱᵐᵖˡ);
  #[global] ReplicatedDiskRecover_unfold :: FuncUnfold ReplicatedDiskRecover [] (ReplicatedDiskRecoverⁱᵐᵖˡ);
  #[global] BasicNamedReturn_unfold :: FuncUnfold BasicNamedReturn [] (BasicNamedReturnⁱᵐᵖˡ);
  #[global] NamedReturn_unfold :: FuncUnfold NamedReturn [] (NamedReturnⁱᵐᵖˡ);
  #[global] BasicNamedReturnMany_unfold :: FuncUnfold BasicNamedReturnMany [] (BasicNamedReturnManyⁱᵐᵖˡ);
  #[global] NamedReturnMany_unfold :: FuncUnfold NamedReturnMany [] (NamedReturnManyⁱᵐᵖˡ);
  #[global] NamedReturnOverride_unfold :: FuncUnfold NamedReturnOverride [] (NamedReturnOverrideⁱᵐᵖˡ);
  #[global] VoidButEndsWithReturn_unfold :: FuncUnfold VoidButEndsWithReturn [] (VoidButEndsWithReturnⁱᵐᵖˡ);
  #[global] VoidImplicitReturnInBranch_unfold :: FuncUnfold VoidImplicitReturnInBranch [] (VoidImplicitReturnInBranchⁱᵐᵖˡ);
  #[global] useRuneOps_unfold :: FuncUnfold useRuneOps [] (useRuneOpsⁱᵐᵖˡ);
  #[global] sliceOps_unfold :: FuncUnfold sliceOps [] (sliceOpsⁱᵐᵖˡ);
  #[global] makeSingletonSlice_unfold :: FuncUnfold makeSingletonSlice [] (makeSingletonSliceⁱᵐᵖˡ);
  #[global] makeAlias_unfold :: FuncUnfold makeAlias [] (makeAliasⁱᵐᵖˡ);
  #[global] Skip_unfold :: FuncUnfold Skip [] (Skipⁱᵐᵖˡ);
  #[global] simpleSpawn_unfold :: FuncUnfold simpleSpawn [] (simpleSpawnⁱᵐᵖˡ);
  #[global] threadCode_unfold :: FuncUnfold threadCode [] (threadCodeⁱᵐᵖˡ);
  #[global] loopSpawn_unfold :: FuncUnfold loopSpawn [] (loopSpawnⁱᵐᵖˡ);
  #[global] stringAppend_unfold :: FuncUnfold stringAppend [] (stringAppendⁱᵐᵖˡ);
  #[global] stringLength_unfold :: FuncUnfold stringLength [] (stringLengthⁱᵐᵖˡ);
  #[global] x_unfold :: FuncUnfold x [] (xⁱᵐᵖˡ);
  #[global] UseAdd_unfold :: FuncUnfold UseAdd [] (UseAddⁱᵐᵖˡ);
  #[global] UseAddWithLiteral_unfold :: FuncUnfold UseAddWithLiteral [] (UseAddWithLiteralⁱᵐᵖˡ);
  #[global] NewS_unfold :: FuncUnfold NewS [] (NewSⁱᵐᵖˡ);
  #[global] localSRef_unfold :: FuncUnfold localSRef [] (localSRefⁱᵐᵖˡ);
  #[global] setField_unfold :: FuncUnfold setField [] (setFieldⁱᵐᵖˡ);
  #[global] testSwitchVal_unfold :: FuncUnfold testSwitchVal [] (testSwitchValⁱᵐᵖˡ);
  #[global] testSwitchMultiple_unfold :: FuncUnfold testSwitchMultiple [] (testSwitchMultipleⁱᵐᵖˡ);
  #[global] DoSomeLocking_unfold :: FuncUnfold DoSomeLocking [] (DoSomeLockingⁱᵐᵖˡ);
  #[global] makeLock_unfold :: FuncUnfold makeLock [] (makeLockⁱᵐᵖˡ);
  #[global] sleep_unfold :: FuncUnfold sleep [] (sleepⁱᵐᵖˡ);
  #[global] mkInt_unfold :: FuncUnfold mkInt [] (mkIntⁱᵐᵖˡ);
  #[global] mkNothing_unfold :: FuncUnfold mkNothing [] (mkNothingⁱᵐᵖˡ);
  #[global] convertToAlias_unfold :: FuncUnfold convertToAlias [] (convertToAliasⁱᵐᵖˡ);
  #[global] typeAssertInt_unfold :: FuncUnfold typeAssertInt [] (typeAssertIntⁱᵐᵖˡ);
  #[global] wrapUnwrapInt_unfold :: FuncUnfold wrapUnwrapInt [] (wrapUnwrapIntⁱᵐᵖˡ);
  #[global] checkedTypeAssert_unfold :: FuncUnfold checkedTypeAssert [] (checkedTypeAssertⁱᵐᵖˡ);
  #[global] basicTypeSwitch_unfold :: FuncUnfold basicTypeSwitch [] (basicTypeSwitchⁱᵐᵖˡ);
  #[global] fancyTypeSwitch_unfold :: FuncUnfold fancyTypeSwitch [] (fancyTypeSwitchⁱᵐᵖˡ);
  #[global] multiTypeSwitch_unfold :: FuncUnfold multiTypeSwitch [] (multiTypeSwitchⁱᵐᵖˡ);
  #[global] variadicFunc_unfold :: FuncUnfold variadicFunc [] (variadicFuncⁱᵐᵖˡ);
  #[global] testVariadicCall_unfold :: FuncUnfold testVariadicCall [] (testVariadicCallⁱᵐᵖˡ);
  #[global] returnMultiple_unfold :: FuncUnfold returnMultiple [] (returnMultipleⁱᵐᵖˡ);
  #[global] testVariadicPassThrough_unfold :: FuncUnfold testVariadicPassThrough [] (testVariadicPassThroughⁱᵐᵖˡ);
  #[global] LocalVars_unfold :: FuncUnfold LocalVars [] (LocalVarsⁱᵐᵖˡ);
  #[global] LocalConsts_unfold :: FuncUnfold LocalConsts [] (LocalConstsⁱᵐᵖˡ);
}.
End unittest.
