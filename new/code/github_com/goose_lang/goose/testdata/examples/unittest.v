(* autogenerated from github.com/goose-lang/goose/testdata/examples/unittest *)
Require Export New.code.fmt.
Require Export New.code.sync.
Require Export New.code.github_com.goose_lang.primitive.
Require Export New.code.github_com.goose_lang.primitive.disk.
Require Export New.code.log.
Require Export New.code.github_com.goose_lang.std.
From New.golang Require Import defn.
From New Require Import disk_prelude.
Module pkg_id.
Definition unittest : go_string := "github.com/goose-lang/goose/testdata/examples/unittest".

End pkg_id.
Export pkg_id.
Module unittest.

Definition Foo {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.Foo"%go [].

Definition importantStruct {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.importantStruct"%go [].

Definition stringWrapper {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.stringWrapper"%go [].

Definition Uint32 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.Uint32"%go [].

Definition numWrapper {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.numWrapper"%go [].

Definition withInterface {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.withInterface"%go [].

Definition diskWrapper {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.diskWrapper"%go [].

Definition embedA {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.embedA"%go [].

Definition embedB {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.embedB"%go [].

Definition embedC {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.embedC"%go [].

Definition embedD {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.embedD"%go [].

Definition Enc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.Enc"%go [].

Definition Dec {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.Dec"%go [].

Definition Enum1 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.Enum1"%go [].

Definition Enum2 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.Enum2"%go [].

Definition Fooer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.Fooer"%go [].

Definition concreteFooer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.concreteFooer"%go [].

Definition FooerUser {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.FooerUser"%go [].

Definition PointerInterface {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.PointerInterface"%go [].

Definition concrete1 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.concrete1"%go [].

Definition my_u32 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.my_u32"%go [].

Definition also_u32 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.also_u32"%go [].

Definition allTheLiterals {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.allTheLiterals"%go [].

Definition hasCondVar {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.hasCondVar"%go [].

Definition IntWrapper {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.IntWrapper"%go [].

Definition MapWrapper {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.MapWrapper"%go [].

Definition mapElem {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.mapElem"%go [].

Definition containsPointer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.containsPointer"%go [].

Definition wrapExternalStruct {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.wrapExternalStruct"%go [].

Definition typing {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.typing"%go [].

Definition composite {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.composite"%go [].

Definition R {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.R"%go [].

Definition Other {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.Other"%go [].

Definition RecursiveEmbedded {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.RecursiveEmbedded"%go [].

Definition Block {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.Block"%go [].

Definition SliceAlias {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.SliceAlias"%go [].

Definition thing {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.thing"%go [].

Definition sliceOfThings {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.sliceOfThings"%go [].

Definition Point {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.Point"%go [].

Definition TwoInts {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.TwoInts"%go [].

Definition S {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.S"%go [].

Definition B {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.B"%go [].

Definition A {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.A"%go [].

Definition Timestamp {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.Timestamp"%go [].

Definition UseTypeAbbrev {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.UseTypeAbbrev"%go [].

Definition UseNamedType {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/unittest.UseNamedType"%go [].

Definition my_u64 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.uint64.

Definition arrayA {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #0.

Definition arrayB {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #10.

Definition GlobalConstant {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #"foo"%go.

(* an untyped string *)
Definition UntypedStringConstant {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #"bar"%go.

Definition UntypedInt {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #13.

Definition OtherUntypedInt {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #26.

Definition TypedInt {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 32).

Definition ConstWithArith {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 100).

Definition TypedInt32 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W32 3).

Definition DivisionInConst {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 511).

(* 517 *)
Definition ModInConst {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 517).

(* 5 *)
Definition ModInConstParens {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 5).

Definition SignedIntegerExample {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 (-37)).

Definition First {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #0.

Definition Second {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #1.

Definition Third {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #2.

Definition ComplicatedFirst {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 3).

Definition ComplicatedSecond {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 5).

Definition ComplicatedThird {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 7).

Definition Enum1A {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 0).

Definition Enum1B {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 1).

Definition Enum1C {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 2).

(* line comment 1 *)
Definition Enum2A {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 1).

(* line comment 2 *)
Definition Enum2B {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #3.

Definition Enum2C {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #4.

(* line comment 3 *)
Definition Enum2D {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 15).

Definition a {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 4607182418800017408).

Definition b {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 4696837146684686336).

Definition MaxRune {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #1114111.

Definition runeWithType {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W32 97).

Definition IntWidth {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #8.

Definition ConstWithAbbrevType {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W32 3).

Definition Disk1 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 0).

Definition Disk2 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 0).

Definition DiskSize {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 1000).

Definition GlobalX {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.GlobalX"%go.

Definition globalY {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.globalY"%go.

Definition globalA {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.globalA"%go.

Definition globalB {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.globalB"%go.

Definition mapLiteral {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.mapLiteral"%go.

Definition mapLiteralWithConversion {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.mapLiteralWithConversion"%go.

Definition takesArray {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.takesArray"%go.

Definition takesPtr {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.takesPtr"%go.

Definition usesArrayElemRef {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.usesArrayElemRef"%go.

Definition sum {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.sum"%go.

Definition arrayToSlice {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.arrayToSlice"%go.

Definition arrayLiteralKeyed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.arrayLiteralKeyed"%go.

Definition chanBasic {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.chanBasic"%go.

Definition f {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.f"%go.

Definition chanSelect {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.chanSelect"%go.

Definition chanDirectional {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.chanDirectional"%go.

Definition chanRange {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.chanRange"%go.

Definition doSubtleThings {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.doSubtleThings"%go.

Definition hasStartComment {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.hasStartComment"%go.

Definition hasEndComment {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.hasEndComment"%go.

Definition condvarWrapping {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.condvarWrapping"%go.

Definition useUntypedInt {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.useUntypedInt"%go.

Definition useUntypedString {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.useUntypedString"%go.

Definition conditionalReturn {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.conditionalReturn"%go.

Definition alwaysReturn {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.alwaysReturn"%go.

Definition alwaysReturnInNestedBranches {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.alwaysReturnInNestedBranches"%go.

Definition earlyReturn {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.earlyReturn"%go.

Definition conditionalAssign {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.conditionalAssign"%go.

Definition elseIf {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.elseIf"%go.

Definition ifStmtInitialization {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.ifStmtInitialization"%go.

Definition typedLiteral {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.typedLiteral"%go.

Definition literalCast {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.literalCast"%go.

Definition castInt {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.castInt"%go.

Definition stringToByteSlice {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.stringToByteSlice"%go.

Definition byteSliceToString {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.byteSliceToString"%go.

Definition stringToStringWrapper {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.stringToStringWrapper"%go.

Definition stringWrapperToString {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.stringWrapperToString"%go.

Definition testU32NewtypeLen {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.testU32NewtypeLen"%go.

Definition testNumWrapper {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.testNumWrapper"%go.

Definition testConversionLiteral {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.testConversionLiteral"%go.

Definition testCopySimple {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.testCopySimple"%go.

Definition testCopyDifferentLengths {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.testCopyDifferentLengths"%go.

Definition atomicCreateStub {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.atomicCreateStub"%go.

Definition useSlice {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.useSlice"%go.

Definition useSliceIndexing {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.useSliceIndexing"%go.

Definition useMap {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.useMap"%go.

Definition usePtr {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.usePtr"%go.

Definition iterMapKeysAndValues {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.iterMapKeysAndValues"%go.

Definition iterMapKeys {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.iterMapKeys"%go.

Definition getRandom {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.getRandom"%go.

Definition diskArgument {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.diskArgument"%go.

Definition returnEmbedVal {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.returnEmbedVal"%go.

Definition returnEmbedValWithPointer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.returnEmbedValWithPointer"%go.

Definition useEmbeddedField {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.useEmbeddedField"%go.

Definition useEmbeddedValField {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.useEmbeddedValField"%go.

Definition useEmbeddedMethod {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.useEmbeddedMethod"%go.

Definition useEmbeddedMethod2 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.useEmbeddedMethod2"%go.

Definition empty {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.empty"%go.

Definition emptyReturn {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.emptyReturn"%go.

Definition unnamedParams {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.unnamedParams"%go.

Definition anonymousParam {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.anonymousParam"%go.

Definition useFloat {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.useFloat"%go.

Definition compareIntFloat {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.compareIntFloat"%go.

Definition compareFloatInt {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.compareFloatInt"%go.

Definition forRangeNoBinding {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.forRangeNoBinding"%go.

Definition forRangeOldVars {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.forRangeOldVars"%go.

Definition maybeConvert {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.maybeConvert"%go.

Definition maybeConvertToInterface {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.maybeConvertToInterface"%go.

Definition maybeConvertToString {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.maybeConvertToString"%go.

Definition maybeConvertFromString {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.maybeConvertFromString"%go.

Definition assert {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.assert"%go.

Definition nilConvert {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.nilConvert"%go.

Definition genericConversions {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.genericConversions"%go.

Definition foo {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.foo"%go.

Definition other {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.other"%go.

Definition bar {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.bar"%go.

Definition useUntypedRune {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.useUntypedRune"%go.

Definition TakesFunctionType {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.TakesFunctionType"%go.

Definition FuncVar {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.FuncVar"%go.

Definition fooConsumer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.fooConsumer"%go.

Definition testAssignConcreteToInterface {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.testAssignConcreteToInterface"%go.

Definition testPassConcreteToInterfaceArg {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.testPassConcreteToInterfaceArg"%go.

Definition testPassConcreteToInterfaceArgSpecial {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.testPassConcreteToInterfaceArgSpecial"%go.

Definition takesVarArgsInterface {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.takesVarArgsInterface"%go.

Definition test {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.test"%go.

Definition returnConcrete {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.returnConcrete"%go.

Definition testMultiReturn {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.testMultiReturn"%go.

Definition testReturnStatment {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.testReturnStatment"%go.

Definition testConversionInEq {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.testConversionInEq"%go.

Definition takeMultiple {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.takeMultiple"%go.

Definition giveMultiple {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.giveMultiple"%go.

Definition testConversionInMultipleReturnPassThrough {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.testConversionInMultipleReturnPassThrough"%go.

Definition testConversionInMultiplePassThrough {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.testConversionInMultiplePassThrough"%go.

Definition testPtrMset {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.testPtrMset"%go.

Definition pointerAny {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.pointerAny"%go.

Definition useInts {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.useInts"%go.

Definition signedMidpoint {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.signedMidpoint"%go.

Definition normalLiterals {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.normalLiterals"%go.

Definition outOfOrderLiteral {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.outOfOrderLiteral"%go.

Definition specialLiterals {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.specialLiterals"%go.

Definition oddLiterals {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.oddLiterals"%go.

Definition unKeyedLiteral {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.unKeyedLiteral"%go.

Definition useLocks {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.useLocks"%go.

Definition useCondVar {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.useCondVar"%go.

Definition ToBeDebugged {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.ToBeDebugged"%go.

Definition DoNothing {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.DoNothing"%go.

Definition DoSomething {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.DoSomething"%go.

Definition standardForLoop {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.standardForLoop"%go.

Definition conditionalInLoop {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.conditionalInLoop"%go.

Definition conditionalInLoopElse {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.conditionalInLoopElse"%go.

Definition nestedConditionalInLoopImplicitContinue {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.nestedConditionalInLoopImplicitContinue"%go.

Definition ImplicitLoopContinue {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.ImplicitLoopContinue"%go.

Definition ImplicitLoopContinue2 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.ImplicitLoopContinue2"%go.

Definition ImplicitLoopContinueAfterIfBreak {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.ImplicitLoopContinueAfterIfBreak"%go.

Definition nestedLoops {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.nestedLoops"%go.

Definition nestedGoStyleLoops {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.nestedGoStyleLoops"%go.

Definition sumSlice {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.sumSlice"%go.

Definition intSliceLoop {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.intSliceLoop"%go.

Definition breakFromLoop {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.breakFromLoop"%go.

Definition IterateMapKeys {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.IterateMapKeys"%go.

Definition MapSize {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.MapSize"%go.

Definition MapTypeAliases {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.MapTypeAliases"%go.

Definition StringMap {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.StringMap"%go.

Definition mapUpdateField {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.mapUpdateField"%go.

Definition mapGetCall {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.mapGetCall"%go.

Definition mapLiteralTest {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.mapLiteralTest"%go.

Definition mapClearTest {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.mapClearTest"%go.

Definition mapLookupConversion {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.mapLookupConversion"%go.

Definition returnTwo {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.returnTwo"%go.

Definition returnTwoWrapper {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.returnTwoWrapper"%go.

Definition multipleVar {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.multipleVar"%go.

Definition multiplePassThrough {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.multiplePassThrough"%go.

Definition multipleReturnPassThrough {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.multipleReturnPassThrough"%go.

Definition AssignNilSlice {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.AssignNilSlice"%go.

Definition AssignNilPointer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.AssignNilPointer"%go.

Definition CompareSliceToNil {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.CompareSliceToNil"%go.

Definition ComparePointerToNil {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.ComparePointerToNil"%go.

Definition useNilField {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.useNilField"%go.

Definition LogicalOperators {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.LogicalOperators"%go.

Definition LogicalAndEqualityOperators {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.LogicalAndEqualityOperators"%go.

Definition ArithmeticShifts {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.ArithmeticShifts"%go.

Definition BitwiseOps {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.BitwiseOps"%go.

Definition Comparison {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.Comparison"%go.

Definition AssignOps {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.AssignOps"%go.

Definition BitwiseAndNot {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.BitwiseAndNot"%go.

Definition Negative {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.Negative"%go.

Definition PanicAtTheDisco {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.PanicAtTheDisco"%go.

Definition Oracle {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.Oracle"%go.

Definition ReassignVars {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.ReassignVars"%go.

Definition recur {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.recur"%go.

Definition useRenamedImport {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.useRenamedImport"%go.

Definition TwoDiskWrite {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.TwoDiskWrite"%go.

Definition TwoDiskRead {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.TwoDiskRead"%go.

Definition TwoDiskLock {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.TwoDiskLock"%go.

Definition TwoDiskUnlock {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.TwoDiskUnlock"%go.

Definition ReplicatedDiskRead {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.ReplicatedDiskRead"%go.

Definition ReplicatedDiskWrite {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.ReplicatedDiskWrite"%go.

Definition ReplicatedDiskRecover {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.ReplicatedDiskRecover"%go.

Definition BasicNamedReturn {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.BasicNamedReturn"%go.

Definition NamedReturn {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.NamedReturn"%go.

Definition BasicNamedReturnMany {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.BasicNamedReturnMany"%go.

Definition NamedReturnMany {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.NamedReturnMany"%go.

Definition NamedReturnOverride {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.NamedReturnOverride"%go.

Definition VoidButEndsWithReturn {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.VoidButEndsWithReturn"%go.

Definition VoidImplicitReturnInBranch {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.VoidImplicitReturnInBranch"%go.

Definition useRuneOps {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.useRuneOps"%go.

Definition sliceOps {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.sliceOps"%go.

Definition makeSingletonSlice {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.makeSingletonSlice"%go.

Definition makeAlias {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.makeAlias"%go.

Definition Skip {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.Skip"%go.

Definition simpleSpawn {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.simpleSpawn"%go.

Definition threadCode {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.threadCode"%go.

Definition loopSpawn {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.loopSpawn"%go.

Definition stringAppend {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.stringAppend"%go.

Definition stringLength {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.stringLength"%go.

Definition x {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.x"%go.

Definition UseAdd {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.UseAdd"%go.

Definition UseAddWithLiteral {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.UseAddWithLiteral"%go.

Definition NewS {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.NewS"%go.

Definition localSRef {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.localSRef"%go.

Definition setField {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.setField"%go.

Definition testSwitchVal {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.testSwitchVal"%go.

Definition testSwitchMultiple {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.testSwitchMultiple"%go.

Definition DoSomeLocking {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.DoSomeLocking"%go.

Definition makeLock {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.makeLock"%go.

Definition sleep {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.sleep"%go.

Definition mkInt {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.mkInt"%go.

Definition mkNothing {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.mkNothing"%go.

Definition convertToAlias {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.convertToAlias"%go.

Definition typeAssertInt {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.typeAssertInt"%go.

Definition wrapUnwrapInt {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.wrapUnwrapInt"%go.

Definition checkedTypeAssert {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.checkedTypeAssert"%go.

Definition basicTypeSwitch {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.basicTypeSwitch"%go.

Definition fancyTypeSwitch {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.fancyTypeSwitch"%go.

Definition multiTypeSwitch {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.multiTypeSwitch"%go.

Definition variadicFunc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.variadicFunc"%go.

Definition testVariadicCall {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.testVariadicCall"%go.

Definition returnMultiple {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.returnMultiple"%go.

Definition testVariadicPassThrough {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.testVariadicPassThrough"%go.

Definition LocalVars {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.LocalVars"%go.

Definition LocalConsts {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.LocalConsts"%go.

(* go: array.go:5:6 *)
Definition takesArrayⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x",
    exception_do (let: "x" := (GoAlloc (go.ArrayType 13 go.string) "x") in
    return: (![go.string] (IndexRef (go.ArrayType 13 go.string) (![go.ArrayType 13 go.string] "x", #(W64 3))))).

(* go: array.go:9:6 *)
Definition takesPtrⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x",
    exception_do (let: "x" := (GoAlloc (go.PointerType go.string) "x") in
    do:  ((![go.PointerType go.string] "x") <-[go.string] ((![go.string] (![go.PointerType go.string] "x")) +⟨go.string⟩ #"bar"%go));;;
    return: #()).

(* go: array.go:13:6 *)
Definition usesArrayElemRefⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc (go.ArrayType 2 go.string) (GoZeroVal (go.ArrayType 2 go.string) #())) in
    let: "$r0" := (CompositeLiteral (go.ArrayType 2 go.string) (LiteralValue [KeyedElement None (ElementExpression go.string #"a"%go); KeyedElement None (ElementExpression go.string #"b"%go)])) in
    do:  ("x" <-[go.ArrayType 2 go.string] "$r0");;;
    let: "$r0" := #"c"%go in
    do:  ((IndexRef (go.ArrayType 2 go.string) (![go.ArrayType 2 go.string] "x", #(W64 1))) <-[go.string] "$r0");;;
    do:  (let: "$a0" := (IndexRef go.string (![go.ArrayType 2 go.string] "x", #(W64 1))) in
    (FuncResolve takesPtr [] #()) "$a0");;;
    return: #()).

(* go: array.go:22:6 *)
Definition sumⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x",
    exception_do (let: "x" := (GoAlloc (go.ArrayType 100 go.uint64) "x") in
    let: "sum" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("sum" <-[go.uint64] "$r0");;;
    (let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, (![go.uint64] "i") <⟨go.uint64⟩ (Convert go.int go.uint64 (FuncResolve go.len [go.ArrayType 100 go.uint64] #()))); (λ: <>, do:  ("i" <-[go.uint64] ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 1)))) := λ: <>,
      do:  ("sum" <-[go.uint64] ((![go.uint64] "sum") +⟨go.uint64⟩ (![go.uint64] (IndexRef (go.ArrayType 100 go.uint64) (![go.ArrayType 100 go.uint64] "x", Convert go.uint64 go.int (![go.uint64] "i"))))))));;;
    do:  ("sum" <-[go.uint64] ((![go.uint64] "sum") +⟨go.uint64⟩ (Convert go.int go.uint64 (FuncResolve go.cap [go.ArrayType 100 go.uint64] #()))));;;
    return: (![go.uint64] "sum")).

(* go: array.go:31:6 *)
Definition arrayToSliceⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc (go.ArrayType 2 go.string) (GoZeroVal (go.ArrayType 2 go.string) #())) in
    let: "$r0" := (CompositeLiteral (go.ArrayType 2 go.string) (LiteralValue [KeyedElement None (ElementExpression go.string #"a"%go); KeyedElement None (ElementExpression go.string #"b"%go)])) in
    do:  ("x" <-[go.ArrayType 2 go.string] "$r0");;;
    return: (let: "$s" := (![go.ArrayType 2 go.string] "x") in
     Slice (go.ArrayType 2 go.string) ("$s", #(W64 0), FuncResolve go.len [go.ArrayType 2 go.string] #() (![go.ArrayType 2 go.string] "x")))).

(* go: array.go:44:6 *)
Definition arrayLiteralKeyedⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc (go.ArrayType 13 go.string) (GoZeroVal (go.ArrayType 13 go.string) #())) in
    let: "$r0" := (CompositeLiteral (go.ArrayType 13 go.string) (LiteralValue [KeyedElement (Some (KeyExpression go.int (Convert go.untyped_int go.int arrayB))) (ElementExpression go.string #"B"%go); KeyedElement None (ElementExpression go.string #"1"%go); KeyedElement None (ElementExpression go.string #"2"%go); KeyedElement (Some (KeyExpression go.int (Convert go.untyped_int go.int arrayA))) (ElementExpression go.string #"A"%go); KeyedElement None (ElementExpression go.string #"3"%go)])) in
    do:  ("x" <-[go.ArrayType 13 go.string] "$r0");;;
    return: (![go.string] (IndexRef (go.ArrayType 13 go.string) (![go.ArrayType 13 go.string] "x", #(W64 0))))).

(* go: chan.go:5:6 *)
Definition chanBasicⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc (go.ChannelType go.sendrecv go.string) (GoZeroVal (go.ChannelType go.sendrecv go.string) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.ChannelType go.sendrecv go.string] #()) #(W64 10)) in
    do:  ("x" <-[go.ChannelType go.sendrecv go.string] "$r0");;;
    let: "$r0" := ((FuncResolve go.make1 [go.ChannelType go.sendrecv go.string] #()) #()) in
    do:  ("x" <-[go.ChannelType go.sendrecv go.string] "$r0");;;
    let: "$go" := (λ: <>,
      exception_do (do:  (let: "$chan" := (![go.ChannelType go.sendrecv go.string] "x") in
      let: "$v" := #"Foo"%go in
      chan.send go.string "$chan" "$v");;;
      do:  (let: "$chan" := (![go.ChannelType go.sendrecv go.string] "x") in
      let: "$v" := #"Foo"%go in
      chan.send go.string "$chan" "$v");;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "y" := (GoAlloc go.string (GoZeroVal go.string #())) in
    let: ("$ret0", "$ret1") := (chan.receive go.string (![go.ChannelType go.sendrecv go.string] "x")) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("y" <-[go.string] "$r0");;;
    do:  ("ok" <-[go.bool] "$r1");;;
    let: "$r0" := (Fst (chan.receive go.string (![go.ChannelType go.sendrecv go.string] "x"))) in
    do:  ("y" <-[go.string] "$r0");;;
    (if: ![go.bool] "ok"
    then
      let: "$r0" := ((![go.string] "y") +⟨go.string⟩ #" "%go) in
      do:  ("y" <-[go.string] "$r0")
    else do:  #());;;
    return: #()).

(* go: chan.go:20:6 *)
Definition fⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (#(W64 0))).

(* modified version of example from https://go.dev/ref/spec#Select_statements

   go: chan.go:25:6 *)
Definition chanSelectⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "a" := (GoAlloc (go.SliceType go.int) (GoZeroVal (go.SliceType go.int) #())) in
    let: "c4" := (GoAlloc (go.ChannelType go.sendrecv go.int) (GoZeroVal (go.ChannelType go.sendrecv go.int) #())) in
    let: "c3" := (GoAlloc (go.ChannelType go.sendrecv go.int) (GoZeroVal (go.ChannelType go.sendrecv go.int) #())) in
    let: "c2" := (GoAlloc (go.ChannelType go.sendrecv go.int) (GoZeroVal (go.ChannelType go.sendrecv go.int) #())) in
    let: "c1" := (GoAlloc (go.ChannelType go.sendrecv go.int) (GoZeroVal (go.ChannelType go.sendrecv go.int) #())) in
    let: "c" := (GoAlloc (go.ChannelType go.sendrecv go.int) (GoZeroVal (go.ChannelType go.sendrecv go.int) #())) in
    let: "i2" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "i1" := (GoAlloc go.int (GoZeroVal go.int #())) in
    SelectStmt (SelectStmtClauses (Some (λ: <>,
      do:  (let: "$a0" := ((let: "$sl0" := (Convert go.string go.any #"no communication
      "%go) in
      CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0")]))) in
      (FuncResolve fmt.Print [] #()) "$a0")
      )) [(CommClause (RecvCase go.int (![go.ChannelType go.sendrecv go.int] "c3")) (λ: "$recvVal",
      do:  #()
      )); (CommClause (RecvCase go.int (![go.ChannelType go.sendrecv go.int] "c1")) (λ: "$recvVal",
      let: "$r0" := (Fst "$recvVal") in
      do:  ("i1" <-[go.int] "$r0");;;
      do:  (let: "$a0" := ((let: "$sl0" := (Convert go.string go.any #"received "%go) in
      let: "$sl1" := (Convert go.int go.any (![go.int] "i1")) in
      let: "$sl2" := (Convert go.string go.any #" from c1
      "%go) in
      CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0"); KeyedElement None (ElementExpression go.any "$sl1"); KeyedElement None (ElementExpression go.any "$sl2")]))) in
      (FuncResolve fmt.Print [] #()) "$a0")
      )); (CommClause (SendCase go.int (![go.ChannelType go.sendrecv go.int] "c2") (![go.int] "i2")) (λ: <>,
      do:  (let: "$a0" := ((let: "$sl0" := (Convert go.string go.any #"sent "%go) in
      let: "$sl1" := (Convert go.int go.any (![go.int] "i2")) in
      let: "$sl2" := (Convert go.string go.any #" to c2
      "%go) in
      CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0"); KeyedElement None (ElementExpression go.any "$sl1"); KeyedElement None (ElementExpression go.any "$sl2")]))) in
      (FuncResolve fmt.Print [] #()) "$a0")
      )); (CommClause (RecvCase go.int (![go.ChannelType go.sendrecv go.int] "c3")) (λ: "$recvVal",
      let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
      let: "i3" := (GoAlloc go.int (GoZeroVal go.int #())) in
      let: ("$ret0", "$ret1") := "$recvVal" in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("i3" <-[go.int] "$r0");;;
      do:  ("ok" <-[go.bool] "$r1");;;
      (if: ![go.bool] "ok"
      then
        do:  (let: "$a0" := ((let: "$sl0" := (Convert go.string go.any #"received "%go) in
        let: "$sl1" := (Convert go.int go.any (![go.int] "i3")) in
        let: "$sl2" := (Convert go.string go.any #" from c3
        "%go) in
        CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0"); KeyedElement None (ElementExpression go.any "$sl1"); KeyedElement None (ElementExpression go.any "$sl2")]))) in
        (FuncResolve fmt.Print [] #()) "$a0")
      else
        do:  (let: "$a0" := ((let: "$sl0" := (Convert go.string go.any #"c3 is closed
        "%go) in
        CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0")]))) in
        (FuncResolve fmt.Print [] #()) "$a0"))
      )); (CommClause (RecvCase go.int (![go.ChannelType go.sendrecv go.int] "c4")) (λ: "$recvVal",
      let: "$r0" := (Fst "$recvVal") in
      do:  ((IndexRef (go.SliceType go.int) (![go.SliceType go.int] "a", (FuncResolve f [] #()) #())) <-[go.int] "$r0");;;
      do:  #()
      ))]);;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      SelectStmt (SelectStmtClauses None [(CommClause (SendCase go.int (![go.ChannelType go.sendrecv go.int] "c") #(W64 0)) (λ: <>,
        do:  #()
        )); (CommClause (SendCase go.int (![go.ChannelType go.sendrecv go.int] "c") #(W64 1)) (λ: <>,
        do:  #()
        ))]));;;
    SelectStmt (SelectStmtClauses None []);;;
    return: #()).

(* go: chan.go:59:6 *)
Definition chanDirectionalⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc (go.ChannelType go.recvonly go.uint64) (GoZeroVal (go.ChannelType go.recvonly go.uint64) #())) in
    let: "y" := (GoAlloc (go.ChannelType go.sendonly go.string) (GoZeroVal (go.ChannelType go.sendonly go.string) #())) in
    do:  (Fst (chan.receive go.uint64 (![go.ChannelType go.recvonly go.uint64] "x")));;;
    do:  (let: "$chan" := (![go.ChannelType go.sendonly go.string] "y") in
    let: "$v" := #""%go in
    chan.send go.string "$chan" "$v");;;
    return: #()).

(* go: chan.go:66:6 *)
Definition chanRangeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc (go.ChannelType go.sendrecv go.uint64) (GoZeroVal (go.ChannelType go.sendrecv go.uint64) #())) in
    let: "$range" := (![go.ChannelType go.sendrecv go.uint64] "x") in
    (let: "y" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    chan.for_range go.uint64 "$range" (λ: "$key",
      do:  ("y" <-[go.uint64] "$key");;;
      do:  (let: "$a0" := ((let: "$sl0" := (Convert go.uint64 go.any (![go.uint64] "y")) in
      CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0")]))) in
      (FuncResolve fmt.Print [] #()) "$a0")));;;
    let: "$range" := (![go.ChannelType go.sendrecv go.uint64] "x") in
    (let: "x" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    chan.for_range go.uint64 "$range" (λ: "$key",
      do:  ("x" <-[go.uint64] "$key");;;
      do:  (let: "$a0" := ((let: "$sl0" := (Convert go.uint64 go.any (![go.uint64] "x")) in
      CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0")]))) in
      (FuncResolve fmt.Print [] #()) "$a0")));;;
    let: "$range" := (![go.ChannelType go.sendrecv go.uint64] "x") in
    chan.for_range go.uint64 "$range" (λ: "$key",
      do:  #());;;
    return: #()).

(* doSubtleThings does a number of subtle things:

   (actually, it does nothing)

   go: comments.go:12:6 *)
Definition doSubtleThingsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (do:  #()).

(* This comment starts a Coq comment ( *

   go: comments.go:15:6 *)
Definition hasStartCommentⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (do:  #()).

(* This comment * ) ends a Coq comment

   go: comments.go:18:6 *)
Definition hasEndCommentⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (do:  #()).

(* go: condvar.go:5:6 *)
Definition condvarWrappingⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "mu" := (GoAlloc (go.PointerType sync.Mutex) (GoZeroVal (go.PointerType sync.Mutex) #())) in
    let: "$r0" := (GoAlloc sync.Mutex (GoZeroVal sync.Mutex #())) in
    do:  ("mu" <-[go.PointerType sync.Mutex] "$r0");;;
    let: "cond1" := (GoAlloc (go.PointerType sync.Cond) (GoZeroVal (go.PointerType sync.Cond) #())) in
    let: "$r0" := (let: "$a0" := (Convert (go.PointerType sync.Mutex) sync.Locker (![go.PointerType sync.Mutex] "mu")) in
    (FuncResolve sync.NewCond [] #()) "$a0") in
    do:  ("cond1" <-[go.PointerType sync.Cond] "$r0");;;
    let: "$r0" := (GoAlloc sync.Mutex (GoZeroVal sync.Mutex #())) in
    do:  ("mu" <-[go.PointerType sync.Mutex] "$r0");;;
    do:  ((MethodResolve (go.PointerType sync.Cond) "Wait"%go (![go.PointerType sync.Cond] "cond1")) #());;;
    return: #()).

(* go: const.go:37:6 *)
Definition useUntypedIntⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: ((Convert go.untyped_int go.uint64 UntypedInt) +⟨go.uint64⟩ TypedInt)).

(* go: const.go:41:6 *)
Definition useUntypedStringⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (Convert go.untyped_string go.string UntypedStringConstant)).

(* go: control_flow.go:3:6 *)
Definition conditionalReturnⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x",
    exception_do (let: "x" := (GoAlloc go.bool "x") in
    (if: ![go.bool] "x"
    then return: (#(W64 0))
    else do:  #());;;
    return: (#(W64 1))).

(* go: control_flow.go:10:6 *)
Definition alwaysReturnⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x",
    exception_do (let: "x" := (GoAlloc go.bool "x") in
    (if: ![go.bool] "x"
    then return: (#(W64 0))
    else return: (#(W64 1)))).

(* go: control_flow.go:18:6 *)
Definition alwaysReturnInNestedBranchesⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x",
    exception_do (let: "x" := (GoAlloc go.bool "x") in
    (if: (~ (![go.bool] "x"))
    then
      (if: ![go.bool] "x"
      then return: (#(W64 0))
      else return: (#(W64 1)))
    else do:  #());;;
    let: "y" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 14) in
    do:  ("y" <-[go.uint64] "$r0");;;
    return: (![go.uint64] "y")).

(* go: control_flow.go:32:6 *)
Definition earlyReturnⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x",
    exception_do (let: "x" := (GoAlloc go.bool "x") in
    (if: ![go.bool] "x"
    then return: (#())
    else do:  #());;;
    return: #()).

(* go: control_flow.go:38:6 *)
Definition conditionalAssignⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x",
    exception_do (let: "x" := (GoAlloc go.bool "x") in
    let: "y" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    (if: ![go.bool] "x"
    then
      let: "$r0" := #(W64 1) in
      do:  ("y" <-[go.uint64] "$r0")
    else
      let: "$r0" := #(W64 2) in
      do:  ("y" <-[go.uint64] "$r0"));;;
    do:  ("y" <-[go.uint64] ((![go.uint64] "y") +⟨go.uint64⟩ #(W64 1)));;;
    return: (![go.uint64] "y")).

(* go: control_flow.go:49:6 *)
Definition elseIfⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x" "y",
    exception_do (let: "y" := (GoAlloc go.bool "y") in
    let: "x" := (GoAlloc go.bool "x") in
    (if: ![go.bool] "x"
    then return: (#(W64 0))
    else
      (if: ![go.bool] "y"
      then return: (#(W64 1))
      else return: (#(W64 2))))).

(* go: control_flow.go:59:6 *)
Definition ifStmtInitializationⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x",
    exception_do (let: "x" := (GoAlloc go.uint64 "x") in
    let: "f" := (GoAlloc (go.FunctionType (go.Signature [] false [go.uint64])) (GoZeroVal (go.FunctionType (go.Signature [] false [go.uint64])) #())) in
    let: "$r0" := (λ: <>,
      exception_do (return: (![go.uint64] "x"))
      ) in
    do:  ("f" <-[go.FunctionType (go.Signature [] false [go.uint64])] "$r0");;;
    (do:  ((![go.FunctionType (go.Signature [] false [go.uint64])] "f") #());;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "x") =⟨go.uint64⟩ #(W64 2))
    then do:  #()
    else
      (let: "z" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: "$r0" := (![go.uint64] "x") in
      do:  ("z" <-[go.uint64] "$r0");;;
      (if: Convert go.untyped_bool go.bool ((![go.uint64] "z") =⟨go.uint64⟩ #(W64 1))
      then do:  #()
      else
        (let: "y" := (GoAlloc go.int (GoZeroVal go.int #())) in
        let: "$r0" := #(W64 94) in
        do:  ("y" <-[go.int] "$r0");;;
        (if: Convert go.untyped_bool go.bool ((![go.int] "y") =⟨go.int⟩ #(W64 30))
        then do:  #()
        else
          (let: "$r0" := #(W64 10) in
          do:  ("z" <-[go.uint64] "$r0");;;
          (if: Convert go.untyped_bool go.bool ((![go.uint64] "x") =⟨go.uint64⟩ #(W64 30))
          then do:  #()
          else do:  #()))))))));;;
    (let: "y" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 10) in
    do:  ("y" <-[go.uint64] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "x") =⟨go.uint64⟩ #(W64 0))
    then return: (![go.uint64] "y")
    else return: ((![go.uint64] "y") -⟨go.uint64⟩ #(W64 1))))).

(* go: conversions.go:5:6 *)
Definition typedLiteralⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (#(W64 3))).

(* go: conversions.go:9:6 *)
Definition literalCastⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 2) in
    do:  ("x" <-[go.uint64] "$r0");;;
    return: ((![go.uint64] "x") +⟨go.uint64⟩ #(W64 2))).

(* go: conversions.go:15:6 *)
Definition castIntⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "p",
    exception_do (let: "p" := (GoAlloc (go.SliceType go.byte) "p") in
    return: (Convert go.int go.uint64 (let: "$a0" := (![go.SliceType go.byte] "p") in
     (FuncResolve go.len [go.SliceType go.byte] #()) "$a0"))).

(* go: conversions.go:19:6 *)
Definition stringToByteSliceⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s",
    exception_do (let: "s" := (GoAlloc go.string "s") in
    let: "p" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (Convert go.string (go.SliceType go.byte) (![go.string] "s")) in
    do:  ("p" <-[go.SliceType go.byte] "$r0");;;
    return: (![go.SliceType go.byte] "p")).

(* go: conversions.go:25:6 *)
Definition byteSliceToStringⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "p",
    exception_do (let: "p" := (GoAlloc (go.SliceType go.byte) "p") in
    let: "s" := (GoAlloc go.string (GoZeroVal go.string #())) in
    let: "$r0" := (Convert (go.SliceType go.byte) go.string (![go.SliceType go.byte] "p")) in
    do:  ("s" <-[go.string] "$r0");;;
    return: (![go.string] "s")).

(* go: conversions.go:31:6 *)
Definition stringToStringWrapperⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s",
    exception_do (let: "s" := (GoAlloc go.string "s") in
    return: (![go.string] "s")).

(* go: conversions.go:35:6 *)
Definition stringWrapperToStringⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s",
    exception_do (let: "s" := (GoAlloc stringWrapper "s") in
    return: (![stringWrapper] "s")).

(* go: conversions.go:41:6 *)
Definition testU32NewtypeLenⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "s" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 20)) in
    do:  ("s" <-[go.SliceType go.byte] "$r0");;;
    return: ((Convert go.int Uint32 (let: "$a0" := (![go.SliceType go.byte] "s") in
     (FuncResolve go.len [go.SliceType go.byte] #()) "$a0")) =⟨go.uint32⟩ #(W32 20))).

(* go: conversions.go:48:22 *)
Definition numWrapper__incⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "n" <>,
    exception_do (let: "n" := (GoAlloc (go.PointerType numWrapper) "n") in
    do:  ((![go.PointerType numWrapper] "n") <-[numWrapper] ((![numWrapper] (![go.PointerType numWrapper] "n")) +⟨numWrapper⟩ #(W64 1)));;;
    return: #()).

(* go: conversions.go:52:6 *)
Definition testNumWrapperⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "n" := (GoAlloc numWrapper (GoZeroVal numWrapper #())) in
    let: "$r0" := #(W64 0) in
    do:  ("n" <-[numWrapper] "$r0");;;
    do:  ((MethodResolve (go.PointerType numWrapper) "inc"%go "n") #());;;
    return: #()).

(* go: conversions.go:61:6 *)
Definition testConversionLiteralⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "s" := (GoAlloc withInterface (GoZeroVal withInterface #())) in
    let: "$r0" := (CompositeLiteral withInterface (LiteralValue [KeyedElement None (ElementExpression go.untyped_nil UntypedNil)])) in
    do:  ("s" <-[withInterface] "$r0");;;
    let: "$r0" := (CompositeLiteral withInterface (LiteralValue [KeyedElement (Some (KeyField "a"%go)) (ElementExpression go.untyped_nil UntypedNil)])) in
    do:  ("s" <-[withInterface] "$r0");;;
    let: "m" := (GoAlloc (go.MapType go.any go.any) (GoZeroVal (go.MapType go.any go.any) #())) in
    let: "$r0" := (CompositeLiteral (go.MapType go.any go.any) (LiteralValue [KeyedElement (Some (KeyExpression go.untyped_nil UntypedNil)) (ElementExpression go.untyped_nil UntypedNil)])) in
    do:  ("m" <-[go.MapType go.any go.any] "$r0");;;
    let: "$r0" := (Convert withInterface go.any (![withInterface] "s")) in
    do:  (map.insert go.any (![go.MapType go.any go.any] "m") (Convert go.untyped_nil go.any UntypedNil) "$r0");;;
    let: "$r0" := (Convert go.untyped_nil go.any UntypedNil) in
    do:  (map.insert go.any (![go.MapType go.any go.any] "m") (Convert withInterface go.any (![withInterface] "s")) "$r0");;;
    return: ((map.lookup1 go.any go.any (![go.MapType go.any go.any] "m") (map.lookup1 go.any go.any (![go.MapType go.any go.any] "m") (Convert withInterface go.any (![withInterface] "s")))) =⟨go.InterfaceType []⟩ (Convert withInterface (go.InterfaceType []) (![withInterface] "s")))).

(* go: copy.go:3:6 *)
Definition testCopySimpleⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 10)) in
    do:  ("x" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := #(W8 1) in
    do:  ((IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "x", #(W64 3))) <-[go.byte] "$r0");;;
    let: "y" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 10)) in
    do:  ("y" <-[go.SliceType go.byte] "$r0");;;
    do:  (let: "$a0" := (![go.SliceType go.byte] "y") in
    let: "$a1" := (![go.SliceType go.byte] "x") in
    (FuncResolve go.copy [go.SliceType go.byte] #()) "$a0" "$a1");;;
    return: ((![go.byte] (IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "y", #(W64 3)))) =⟨go.byte⟩ #(W8 1))).

(* go: copy.go:11:6 *)
Definition testCopyDifferentLengthsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 15)) in
    do:  ("x" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := #(W8 1) in
    do:  ((IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "x", #(W64 3))) <-[go.byte] "$r0");;;
    let: "$r0" := #(W8 2) in
    do:  ((IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "x", #(W64 12))) <-[go.byte] "$r0");;;
    let: "y" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 10)) in
    do:  ("y" <-[go.SliceType go.byte] "$r0");;;
    let: "n" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (Convert go.int go.uint64 (let: "$a0" := (![go.SliceType go.byte] "y") in
    let: "$a1" := (![go.SliceType go.byte] "x") in
    (FuncResolve go.copy [go.SliceType go.byte] #()) "$a0" "$a1")) in
    do:  ("n" <-[go.uint64] "$r0");;;
    return: (((![go.uint64] "n") =⟨go.uint64⟩ #(W64 10)) && ((![go.byte] (IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "y", #(W64 3)))) =⟨go.byte⟩ #(W8 1)))).

(* go: data_structures.go:7:6 *)
Definition atomicCreateStubⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "dir" "fname" "data",
    exception_do (let: "data" := (GoAlloc (go.SliceType go.byte) "data") in
    let: "fname" := (GoAlloc go.string "fname") in
    let: "dir" := (GoAlloc go.string "dir") in
    do:  #()).

(* go: data_structures.go:9:6 *)
Definition useSliceⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "s" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 1)) in
    do:  ("s" <-[go.SliceType go.byte] "$r0");;;
    let: "s1" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "s") in
    let: "$a1" := (![go.SliceType go.byte] "s") in
    (FuncResolve go.append [go.SliceType go.byte] #()) "$a0" "$a1") in
    do:  ("s1" <-[go.SliceType go.byte] "$r0");;;
    do:  (let: "$a0" := #"dir"%go in
    let: "$a1" := #"file"%go in
    let: "$a2" := (![go.SliceType go.byte] "s1") in
    (FuncResolve atomicCreateStub [] #()) "$a0" "$a1" "$a2");;;
    return: #()).

(* go: data_structures.go:15:6 *)
Definition useSliceIndexingⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "s" := (GoAlloc (go.SliceType go.uint64) (GoZeroVal (go.SliceType go.uint64) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType go.uint64] #()) #(W64 2)) in
    do:  ("s" <-[go.SliceType go.uint64] "$r0");;;
    let: "$r0" := #(W64 2) in
    do:  ((IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "s", #(W64 1))) <-[go.uint64] "$r0");;;
    let: "x" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (![go.uint64] (IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "s", #(W64 0)))) in
    do:  ("x" <-[go.uint64] "$r0");;;
    return: (![go.uint64] "x")).

(* go: data_structures.go:22:6 *)
Definition useMapⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "m" := (GoAlloc (go.MapType go.uint64 (go.SliceType go.byte)) (GoZeroVal (go.MapType go.uint64 (go.SliceType go.byte)) #())) in
    let: "$r0" := ((FuncResolve go.make1 [go.MapType go.uint64 (go.SliceType go.byte)] #()) #()) in
    do:  ("m" <-[go.MapType go.uint64 (go.SliceType go.byte)] "$r0");;;
    let: "$r0" := (Convert go.untyped_nil (go.SliceType go.byte) UntypedNil) in
    do:  (map.insert go.uint64 (![go.MapType go.uint64 (go.SliceType go.byte)] "m") #(W64 1) "$r0");;;
    let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "x" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: ("$ret0", "$ret1") := (map.lookup2 go.uint64 (go.SliceType go.byte) (![go.MapType go.uint64 (go.SliceType go.byte)] "m") #(W64 2)) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("x" <-[go.SliceType go.byte] "$r0");;;
    do:  ("ok" <-[go.bool] "$r1");;;
    (if: ![go.bool] "ok"
    then return: (#())
    else do:  #());;;
    let: "$r0" := (![go.SliceType go.byte] "x") in
    do:  (map.insert go.uint64 (![go.MapType go.uint64 (go.SliceType go.byte)] "m") #(W64 3) "$r0");;;
    return: #()).

(* go: data_structures.go:32:6 *)
Definition usePtrⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "p" := (GoAlloc (go.PointerType go.uint64) (GoZeroVal (go.PointerType go.uint64) #())) in
    let: "$r0" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    do:  ("p" <-[go.PointerType go.uint64] "$r0");;;
    let: "$r0" := #(W64 1) in
    do:  ((![go.PointerType go.uint64] "p") <-[go.uint64] "$r0");;;
    let: "x" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (![go.uint64] (![go.PointerType go.uint64] "p")) in
    do:  ("x" <-[go.uint64] "$r0");;;
    let: "$r0" := (![go.uint64] "x") in
    do:  ((![go.PointerType go.uint64] "p") <-[go.uint64] "$r0");;;
    return: #()).

(* go: data_structures.go:39:6 *)
Definition iterMapKeysAndValuesⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "m",
    exception_do (let: "m" := (GoAlloc (go.MapType go.uint64 go.uint64) "m") in
    let: "sumPtr" := (GoAlloc (go.PointerType go.uint64) (GoZeroVal (go.PointerType go.uint64) #())) in
    let: "$r0" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    do:  ("sumPtr" <-[go.PointerType go.uint64] "$r0");;;
    let: "$range" := (![go.MapType go.uint64 go.uint64] "m") in
    (let: "v" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "k" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    map.for_range go.uint64 go.uint64 "$range" (λ: "$key" "value",
      do:  ("v" <-[go.uint64] "$value");;;
      do:  ("k" <-[go.uint64] "$key");;;
      let: "sum" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: "$r0" := (![go.uint64] (![go.PointerType go.uint64] "sumPtr")) in
      do:  ("sum" <-[go.uint64] "$r0");;;
      let: "$r0" := (((![go.uint64] "sum") +⟨go.uint64⟩ (![go.uint64] "k")) +⟨go.uint64⟩ (![go.uint64] "v")) in
      do:  ((![go.PointerType go.uint64] "sumPtr") <-[go.uint64] "$r0")));;;
    let: "sum" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (![go.uint64] (![go.PointerType go.uint64] "sumPtr")) in
    do:  ("sum" <-[go.uint64] "$r0");;;
    return: (![go.uint64] "sum")).

(* go: data_structures.go:49:6 *)
Definition iterMapKeysⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "m",
    exception_do (let: "m" := (GoAlloc (go.MapType go.uint64 go.uint64) "m") in
    let: "keysSlice" := (GoAlloc (go.SliceType go.uint64) (GoZeroVal (go.SliceType go.uint64) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType go.uint64] #()) #(W64 0)) in
    do:  ("keysSlice" <-[go.SliceType go.uint64] "$r0");;;
    let: "keysRef" := (GoAlloc (go.PointerType (go.SliceType go.uint64)) (GoZeroVal (go.PointerType (go.SliceType go.uint64)) #())) in
    let: "$r0" := (GoAlloc (go.SliceType go.uint64) (GoZeroVal (go.SliceType go.uint64) #())) in
    do:  ("keysRef" <-[go.PointerType (go.SliceType go.uint64)] "$r0");;;
    let: "$r0" := (![go.SliceType go.uint64] "keysSlice") in
    do:  ((![go.PointerType (go.SliceType go.uint64)] "keysRef") <-[go.SliceType go.uint64] "$r0");;;
    let: "$range" := (![go.MapType go.uint64 go.uint64] "m") in
    (let: "k" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    map.for_range go.uint64 go.uint64 "$range" (λ: "$key" "value",
      do:  ("k" <-[go.uint64] "$key");;;
      let: "keys" := (GoAlloc (go.SliceType go.uint64) (GoZeroVal (go.SliceType go.uint64) #())) in
      let: "$r0" := (![go.SliceType go.uint64] (![go.PointerType (go.SliceType go.uint64)] "keysRef")) in
      do:  ("keys" <-[go.SliceType go.uint64] "$r0");;;
      let: "newKeys" := (GoAlloc (go.SliceType go.uint64) (GoZeroVal (go.SliceType go.uint64) #())) in
      let: "$r0" := (let: "$a0" := (![go.SliceType go.uint64] "keys") in
      let: "$a1" := ((let: "$sl0" := (![go.uint64] "k") in
      CompositeLiteral (go.SliceType go.uint64) (LiteralValue [KeyedElement None (ElementExpression go.uint64 "$sl0")]))) in
      (FuncResolve go.append [go.SliceType go.uint64] #()) "$a0" "$a1") in
      do:  ("newKeys" <-[go.SliceType go.uint64] "$r0");;;
      let: "$r0" := (![go.SliceType go.uint64] "newKeys") in
      do:  ((![go.PointerType (go.SliceType go.uint64)] "keysRef") <-[go.SliceType go.uint64] "$r0")));;;
    let: "keys" := (GoAlloc (go.SliceType go.uint64) (GoZeroVal (go.SliceType go.uint64) #())) in
    let: "$r0" := (![go.SliceType go.uint64] (![go.PointerType (go.SliceType go.uint64)] "keysRef")) in
    do:  ("keys" <-[go.SliceType go.uint64] "$r0");;;
    return: (![go.SliceType go.uint64] "keys")).

(* go: data_structures.go:62:6 *)
Definition getRandomⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "r" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := ((FuncResolve primitive.RandomUint64 [] #()) #()) in
    do:  ("r" <-[go.uint64] "$r0");;;
    return: (![go.uint64] "r")).

(* go: disk.go:9:6 *)
Definition diskArgumentⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "d",
    exception_do (let: "d" := (GoAlloc disk.Disk "d") in
    let: "b" := (GoAlloc disk.Block (GoZeroVal disk.Block #())) in
    let: "$r0" := (let: "$a0" := #(W64 0) in
    (MethodResolve disk.Disk "Read"%go (![disk.Disk] "d")) "$a0") in
    do:  ("b" <-[disk.Block] "$r0");;;
    do:  (let: "$a0" := #(W64 1) in
    let: "$a1" := (![disk.Block] "b") in
    (MethodResolve disk.Disk "Write"%go (![disk.Disk] "d")) "$a0" "$a1");;;
    return: #()).

(* go: embedded.go:19:17 *)
Definition embedA__Fooⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "a" <>,
    exception_do (let: "a" := (GoAlloc embedA "a") in
    return: (#"embedA.Foo()"%go)).

(* go: embedded.go:23:17 *)
Definition embedB__Fooⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "a" <>,
    exception_do (let: "a" := (GoAlloc embedB "a") in
    return: (#"embedB.Foo()"%go)).

(* go: embedded.go:27:18 *)
Definition embedA__Barⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "a" <>,
    exception_do (let: "a" := (GoAlloc (go.PointerType embedA) "a") in
    return: (#"*embedA.Bar()"%go)).

(* go: embedded.go:31:18 *)
Definition embedB__Carⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "a" <>,
    exception_do (let: "a" := (GoAlloc (go.PointerType embedB) "a") in
    return: (#"*embedB.Car()"%go)).

(* go: embedded.go:35:6 *)
Definition returnEmbedValⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (CompositeLiteral embedB (LiteralValue []))).

(* go: embedded.go:39:6 *)
Definition returnEmbedValWithPointerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (CompositeLiteral embedD (LiteralValue []))).

(* go: embedded.go:43:6 *)
Definition useEmbeddedFieldⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "d",
    exception_do (let: "d" := (GoAlloc embedD "d") in
    let: "x" := (GoAlloc go.string (GoZeroVal go.string #())) in
    let: "$r0" := (![go.string] (StructFieldRef embedA "a"%go (StructFieldRef embedB "embedA"%go (![go.PointerType embedB] (StructFieldRef embedC "embedB"%go (StructFieldRef embedD "embedC"%go "d")))))) in
    do:  ("x" <-[go.string] "$r0");;;
    let: "$r0" := (![go.string] (StructFieldRef embedA "a"%go (StructFieldRef embedB "embedA"%go (![go.PointerType embedB] (StructFieldRef embedC "embedB"%go (StructFieldRef embedD "embedC"%go "d")))))) in
    do:  ("x" <-[go.string] "$r0");;;
    let: "$r0" := #"a1"%go in
    do:  ((StructFieldRef embedA "a"%go (StructFieldRef embedB "embedA"%go (![go.PointerType embedB] (StructFieldRef embedC "embedB"%go (StructFieldRef embedD "embedC"%go "d"))))) <-[go.string] "$r0");;;
    let: "y" := (GoAlloc (go.PointerType embedD) (GoZeroVal (go.PointerType embedD) #())) in
    let: "$r0" := (GoAlloc embedD (CompositeLiteral embedD (LiteralValue []))) in
    do:  ("y" <-[go.PointerType embedD] "$r0");;;
    let: "$r0" := #"a2"%go in
    do:  ((StructFieldRef embedA "a"%go (StructFieldRef embedB "embedA"%go (![go.PointerType embedB] (StructFieldRef embedC "embedB"%go (StructFieldRef embedD "embedC"%go (![go.PointerType embedD] "y")))))) <-[go.string] "$r0");;;
    return: (![go.string] "x")).

(* go: embedded.go:54:6 *)
Definition useEmbeddedValFieldⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.string (GoZeroVal go.string #())) in
    let: "$r0" := (StructFieldGet embedA "a" (StructFieldGet embedB "embedA" ((FuncResolve returnEmbedVal [] #()) #()))) in
    do:  ("x" <-[go.string] "$r0");;;
    let: "$r0" := (![go.string] (StructFieldRef embedA "a"%go (StructFieldRef embedB "embedA"%go (StructFieldGet embedC "embedB" (StructFieldGet embedD "embedC" ((FuncResolve returnEmbedValWithPointer [] #()) #())))))) in
    do:  ("x" <-[go.string] "$r0");;;
    return: (![go.string] "x")).

(* go: embedded.go:60:6 *)
Definition useEmbeddedMethodⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "d",
    exception_do (let: "d" := (GoAlloc embedD "d") in
    return: (((MethodResolve embedD "Bar"%go (![embedD] "d")) #()) =⟨go.string⟩ ((MethodResolve (go.PointerType embedA) "Bar"%go (StructFieldRef embedB "embedA"%go (![go.PointerType embedB] (StructFieldRef embedC "embedB"%go (StructFieldRef embedD "embedC"%go "d"))))) #()))).

(* go: embedded.go:64:6 *)
Definition useEmbeddedMethod2ⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "d",
    exception_do (let: "d" := (GoAlloc embedD "d") in
    do:  ((MethodResolve embedD "Car"%go (![embedD] "d")) #());;;
    return: (((MethodResolve embedD "Foo"%go (![embedD] "d")) #()) =⟨go.string⟩ ((MethodResolve (go.PointerType embedB) "Foo"%go (![go.PointerType embedB] (StructFieldRef embedC "embedB"%go (StructFieldRef embedD "embedC"%go "d")))) #()))).

(* go: empty_functions.go:3:6 *)
Definition emptyⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (do:  #()).

(* go: empty_functions.go:5:6 *)
Definition emptyReturnⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (#());;;
    return: #()).

(* go: empty_functions.go:9:6 *)
Definition unnamedParamsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (do:  #()).

(* go: empty_functions.go:11:6 *)
Definition anonymousParamⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (do:  #()).

(* go: encoding.go:9:15 *)
Definition Enc__consumeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "e" "n",
    exception_do (let: "e" := (GoAlloc (go.PointerType Enc) "e") in
    let: "n" := (GoAlloc go.uint64 "n") in
    let: "b" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (let: "$s" := (![go.SliceType go.byte] (StructFieldRef Enc "p"%go (![go.PointerType Enc] "e"))) in
    Slice (go.SliceType go.byte) ("$s", #(W64 0), ![go.uint64] "n")) in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$s" := (![go.SliceType go.byte] (StructFieldRef Enc "p"%go (![go.PointerType Enc] "e"))) in
    Slice (go.SliceType go.byte) ("$s", ![go.uint64] "n", FuncResolve go.len [go.SliceType go.byte] #() (![go.SliceType go.byte] (StructFieldRef Enc "p"%go (![go.PointerType Enc] "e"))))) in
    do:  ((StructFieldRef Enc "p"%go (![go.PointerType Enc] "e")) <-[go.SliceType go.byte] "$r0");;;
    return: (![go.SliceType go.byte] "b")).

(* go: encoding.go:15:15 *)
Definition Enc__UInt64ⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "e" "x",
    exception_do (let: "e" := (GoAlloc (go.PointerType Enc) "e") in
    let: "x" := (GoAlloc go.uint64 "x") in
    do:  (let: "$a0" := (let: "$a0" := #(W64 8) in
    (MethodResolve (go.PointerType Enc) "consume"%go (![go.PointerType Enc] "e")) "$a0") in
    let: "$a1" := (![go.uint64] "x") in
    (FuncResolve primitive.UInt64Put [] #()) "$a0" "$a1");;;
    return: #()).

(* go: encoding.go:19:15 *)
Definition Enc__UInt32ⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "e" "x",
    exception_do (let: "e" := (GoAlloc (go.PointerType Enc) "e") in
    let: "x" := (GoAlloc go.uint32 "x") in
    do:  (let: "$a0" := (let: "$a0" := #(W64 4) in
    (MethodResolve (go.PointerType Enc) "consume"%go (![go.PointerType Enc] "e")) "$a0") in
    let: "$a1" := (![go.uint32] "x") in
    (FuncResolve primitive.UInt32Put [] #()) "$a0" "$a1");;;
    return: #()).

(* go: encoding.go:27:15 *)
Definition Dec__consumeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "d" "n",
    exception_do (let: "d" := (GoAlloc (go.PointerType Dec) "d") in
    let: "n" := (GoAlloc go.uint64 "n") in
    let: "b" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (let: "$s" := (![go.SliceType go.byte] (StructFieldRef Dec "p"%go (![go.PointerType Dec] "d"))) in
    Slice (go.SliceType go.byte) ("$s", #(W64 0), ![go.uint64] "n")) in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$s" := (![go.SliceType go.byte] (StructFieldRef Dec "p"%go (![go.PointerType Dec] "d"))) in
    Slice (go.SliceType go.byte) ("$s", ![go.uint64] "n", FuncResolve go.len [go.SliceType go.byte] #() (![go.SliceType go.byte] (StructFieldRef Dec "p"%go (![go.PointerType Dec] "d"))))) in
    do:  ((StructFieldRef Dec "p"%go (![go.PointerType Dec] "d")) <-[go.SliceType go.byte] "$r0");;;
    return: (![go.SliceType go.byte] "b")).

(* go: encoding.go:33:15 *)
Definition Dec__UInt64ⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "d" <>,
    exception_do (let: "d" := (GoAlloc (go.PointerType Dec) "d") in
    return: (let: "$a0" := (let: "$a0" := #(W64 8) in
     (MethodResolve (go.PointerType Dec) "consume"%go (![go.PointerType Dec] "d")) "$a0") in
     (FuncResolve primitive.UInt64Get [] #()) "$a0")).

(* go: encoding.go:37:15 *)
Definition Dec__UInt32ⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "d" <>,
    exception_do (let: "d" := (GoAlloc (go.PointerType Dec) "d") in
    return: (let: "$a0" := (let: "$a0" := #(W64 4) in
     (MethodResolve (go.PointerType Dec) "consume"%go (![go.PointerType Dec] "d")) "$a0") in
     (FuncResolve primitive.UInt32Get [] #()) "$a0")).

(* go: float.go:8:6 *)
Definition useFloatⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.float64 (GoZeroVal go.float64 #())) in
    let: "$r0" := (Convert go.untyped_float go.float64 a) in
    do:  ("x" <-[go.float64] "$r0");;;
    let: "$r0" := (((![go.float64] "x") +⟨go.float64⟩ (Convert go.untyped_float go.float64 a)) *⟨go.float64⟩ #(W64 4607182418800017408)) in
    do:  ("x" <-[go.float64] "$r0");;;
    return: (![go.float64] "x")).

(* go: float.go:14:6 *)
Definition compareIntFloatⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x",
    exception_do (let: "x" := (GoAlloc go.int "x") in
    return: ((![go.int] "x") <⟨go.int⟩ #(W64 1000000))).

(* go: float.go:18:6 *)
Definition compareFloatIntⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x",
    exception_do (let: "x" := (GoAlloc go.int "x") in
    return: (#(W64 1000000) <⟨go.int⟩ (![go.int] "x"))).

(* go: for_range.go:5:6 *)
Definition forRangeNoBindingⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x",
    exception_do (let: "x" := (GoAlloc (go.SliceType go.string) "x") in
    let: "$range" := (![go.SliceType go.string] "x") in
    slice.for_range go.string "$range" (λ: "$key" "$value",
      do:  (let: "$a0" := ((let: "$sl0" := (Convert (go.SliceType go.string) go.any (![go.SliceType go.string] "x")) in
      CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0")]))) in
      (FuncResolve fmt.Print [] #()) "$a0"));;;
    return: #()).

(* go: for_range.go:11:6 *)
Definition forRangeOldVarsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x",
    exception_do (let: "x" := (GoAlloc (go.SliceType go.string) "x") in
    let: "y" := (GoAlloc go.string (GoZeroVal go.string #())) in
    let: "$r0" := #"ok"%go in
    do:  ("y" <-[go.string] "$r0");;;
    let: "$range" := (![go.SliceType go.string] "x") in
    slice.for_range go.string "$range" (λ: "$key" "$value",
      do:  ("y" <-[go.string] "$value");;;
      do:  "$key";;;
      do:  (let: "$a0" := ((let: "$sl0" := (Convert go.string go.any (![go.string] "y")) in
      CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0")]))) in
      (FuncResolve fmt.Print [] #()) "$a0"));;;
    return: #()).

(* go: generic_conversion.go:3:6 *)
Definition maybeConvertⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} (A : go.type) : val :=
  λ: "a",
    exception_do (let: "a" := (GoAlloc A "a") in
    return: (Convert A go.uint32 (![A] "a"))).

(* go: generic_conversion.go:7:6 *)
Definition maybeConvertToInterfaceⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} (A : go.type) : val :=
  λ: "a",
    exception_do (let: "a" := (GoAlloc A "a") in
    return: (![A] "a")).

(* go: generic_conversion.go:11:6 *)
Definition maybeConvertToStringⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} (A : go.type) : val :=
  λ: "a",
    exception_do (let: "a" := (GoAlloc A "a") in
    return: (Convert A go.string (![A] "a"))).

(* go: generic_conversion.go:15:6 *)
Definition maybeConvertFromStringⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} (A : go.type) : val :=
  λ: "a",
    exception_do (let: "a" := (GoAlloc A "a") in
    return: (Convert A (go.SliceType go.byte) (![A] "a"))).

(* go: generic_conversion.go:19:6 *)
Definition assertⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "b" "s",
    exception_do (let: "s" := (GoAlloc go.string "s") in
    let: "b" := (GoAlloc go.bool "b") in
    (if: (~ (![go.bool] "b"))
    then
      do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) (![go.string] "s")) in
      (FuncResolve go.panic [] #()) "$a0")
    else do:  #());;;
    return: #()).

(* go: generic_conversion.go:25:6 *)
Definition nilConvertⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} (A : go.type) : val :=
  λ: <>,
    exception_do (return: (CompositeLiteral (go.SliceType A) (LiteralValue [KeyedElement None (ElementExpression go.untyped_nil UntypedNil)]))).

(* go: generic_conversion.go:29:6 *)
Definition genericConversionsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.int8 (GoZeroVal go.int8 #())) in
    let: "$r0" := (Convert go.untyped_int go.int8 (⟨go.untyped_int⟩- #1)) in
    do:  ("x" <-[go.int8] "$r0");;;
    do:  (let: "$a0" := (((let: "$a0" := (![go.int8] "x") in
    (FuncResolve maybeConvert [go.int8] #()) "$a0") =⟨go.uint32⟩ #(W32 4294967295)) && ((let: "$a0" := (Convert go.int8 go.uint8 (![go.int8] "x")) in
    (FuncResolve maybeConvert [go.uint8] #()) "$a0") =⟨go.uint32⟩ #(W32 255))) in
    let: "$a1" := #""%go in
    (FuncResolve assert [] #()) "$a0" "$a1");;;
    do:  (let: "$a0" := ((let: "$a0" := (let: "$a0" := #"ok"%go in
    (FuncResolve maybeConvertFromString [go.string] #()) "$a0") in
    (FuncResolve maybeConvertToString [go.SliceType go.byte] #()) "$a0") =⟨go.string⟩ #"ok"%go) in
    let: "$a1" := #""%go in
    (FuncResolve assert [] #()) "$a0" "$a1");;;
    do:  (let: "$a0" := ((let: "$a0" := #"ok"%go in
    (FuncResolve maybeConvertToInterface [go.string] #()) "$a0") =⟨go.InterfaceType []⟩ (Convert go.string (go.InterfaceType []) #"ok"%go)) in
    let: "$a1" := #""%go in
    (FuncResolve assert [] #()) "$a0" "$a1");;;
    do:  (let: "$a0" := ((TypeAssert go.string (let: "$a0" := (let: "$a0" := #"ok"%go in
    (FuncResolve maybeConvertToInterface [go.string] #()) "$a0") in
    (FuncResolve maybeConvertToInterface [go.any] #()) "$a0")) =⟨go.string⟩ #"ok"%go) in
    let: "$a1" := #""%go in
    (FuncResolve assert [] #()) "$a0" "$a1");;;
    do:  (let: "$a0" := ((IndexRef (go.SliceType go.int) (![go.SliceType go.int] (IndexRef (go.SliceType (go.SliceType go.int)) ((FuncResolve nilConvert [go.SliceType go.int] #()) #(), #(W64 0))), #(W64 0))) =⟨go.PointerType go.int⟩ (![go.PointerType go.int] (IndexRef (go.SliceType (go.PointerType go.int)) ((FuncResolve nilConvert [go.PointerType go.int] #()) #(), #(W64 0))))) in
    let: "$a1" := #""%go in
    (FuncResolve assert [] #()) "$a0" "$a1");;;
    return: #()).

(* go: globals.go:3:6 *)
Definition fooⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (#(W64 10))).

(* go: globals.go:18:6 *)
Definition otherⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "$r0" := #"ok"%go in
    do:  ((GlobalVarAddr globalY #()) <-[go.string] "$r0");;;
    return: #()).

(* go: globals.go:22:6 *)
Definition barⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (do:  ((FuncResolve other [] #()) #());;;
    (if: Convert go.untyped_bool go.bool (((![go.uint64] (GlobalVarAddr GlobalX #())) ≠⟨go.uint64⟩ #(W64 10)) || ((![go.string] (GlobalVarAddr globalY #())) ≠⟨go.string⟩ #"ok"%go))
    then
      do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"bad"%go) in
      (FuncResolve go.panic [] #()) "$a0")
    else do:  #());;;
    return: #()).

(* go: globals.go:37:6 *)
Definition useUntypedRuneⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do ((if: Convert go.untyped_bool go.bool (runeWithType >⟨go.rune⟩ (Convert go.untyped_rune go.rune MaxRune))
    then
      do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"invalid comparison"%go) in
      (FuncResolve go.panic [] #()) "$a0")
    else do:  #());;;
    return: #()).

(* go: higher_order.go:3:6 *)
Definition TakesFunctionTypeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "f",
    exception_do (let: "f" := (GoAlloc (go.FunctionType (go.Signature [] false [])) "f") in
    do:  ((![go.FunctionType (go.Signature [] false [])] "f") #());;;
    return: #()).

(* go: higher_order.go:7:6 *)
Definition FuncVarⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "f" := (GoAlloc (go.FunctionType (go.Signature [] false [])) (GoZeroVal (go.FunctionType (go.Signature [] false [])) #())) in
    let: "$r0" := (![go.FunctionType (go.Signature [] false [])] "f") in
    do:  "$r0";;;
    return: #()).

(* go: interfaces.go:15:25 *)
Definition concreteFooer__Fooⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "f" <>,
    exception_do (let: "f" := (GoAlloc (go.PointerType concreteFooer) "f") in
    do:  #()).

(* go: interfaces.go:18:6 *)
Definition fooConsumerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "f",
    exception_do (let: "f" := (GoAlloc Fooer "f") in
    do:  ((MethodResolve Fooer "Foo"%go (![Fooer] "f")) #());;;
    return: #()).

(* go: interfaces.go:22:6 *)
Definition testAssignConcreteToInterfaceⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x",
    exception_do (let: "x" := (GoAlloc (go.PointerType Fooer) "x") in
    let: "c" := (GoAlloc (go.PointerType concreteFooer) (GoZeroVal (go.PointerType concreteFooer) #())) in
    let: "$r0" := (GoAlloc concreteFooer (CompositeLiteral concreteFooer (LiteralValue []))) in
    do:  ("c" <-[go.PointerType concreteFooer] "$r0");;;
    let: "$r0" := (Convert (go.PointerType concreteFooer) Fooer (![go.PointerType concreteFooer] "c")) in
    do:  ((![go.PointerType Fooer] "x") <-[Fooer] "$r0");;;
    return: #()).

(* go: interfaces.go:27:6 *)
Definition testPassConcreteToInterfaceArgⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "c" := (GoAlloc (go.PointerType concreteFooer) (GoZeroVal (go.PointerType concreteFooer) #())) in
    let: "$r0" := (GoAlloc concreteFooer (CompositeLiteral concreteFooer (LiteralValue []))) in
    do:  ("c" <-[go.PointerType concreteFooer] "$r0");;;
    do:  (let: "$a0" := (Convert (go.PointerType concreteFooer) Fooer (![go.PointerType concreteFooer] "c")) in
    (FuncResolve fooConsumer [] #()) "$a0");;;
    let: "f" := (GoAlloc Fooer (GoZeroVal Fooer #())) in
    let: "$r0" := (Convert (go.PointerType concreteFooer) Fooer (![go.PointerType concreteFooer] "c")) in
    do:  ("f" <-[Fooer] "$r0");;;
    do:  (let: "$a0" := (![Fooer] "f") in
    (FuncResolve fooConsumer [] #()) "$a0");;;
    do:  ((MethodResolve (go.PointerType concreteFooer) "Foo"%go (![go.PointerType concreteFooer] "c")) #());;;
    do:  ((MethodResolve Fooer "Foo"%go (![Fooer] "f")) #());;;
    return: #()).

(* go: interfaces.go:37:6 *)
Definition testPassConcreteToInterfaceArgSpecialⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "c1" := (GoAlloc (go.PointerType concreteFooer) (GoZeroVal (go.PointerType concreteFooer) #())) in
    let: "$r0" := (GoAlloc concreteFooer (CompositeLiteral concreteFooer (LiteralValue []))) in
    do:  ("c1" <-[go.PointerType concreteFooer] "$r0");;;
    let: "c2" := (GoAlloc (go.PointerType concreteFooer) (GoZeroVal (go.PointerType concreteFooer) #())) in
    let: "$r0" := (GoAlloc concreteFooer (CompositeLiteral concreteFooer (LiteralValue []))) in
    do:  ("c2" <-[go.PointerType concreteFooer] "$r0");;;
    let: "l" := (GoAlloc (go.SliceType Fooer) (GoZeroVal (go.SliceType Fooer) #())) in
    let: "$r0" := (CompositeLiteral (go.SliceType Fooer) (LiteralValue [KeyedElement None (ElementExpression (go.PointerType concreteFooer) (![go.PointerType concreteFooer] "c1")); KeyedElement None (ElementExpression (go.PointerType concreteFooer) (![go.PointerType concreteFooer] "c2"))])) in
    do:  ("l" <-[go.SliceType Fooer] "$r0");;;
    let: "m" := (GoAlloc (go.MapType go.uint64 Fooer) (GoZeroVal (go.MapType go.uint64 Fooer) #())) in
    let: "$r0" := ((FuncResolve go.make1 [go.MapType go.uint64 Fooer] #()) #()) in
    do:  ("m" <-[go.MapType go.uint64 Fooer] "$r0");;;
    let: "$r0" := (Convert (go.PointerType concreteFooer) Fooer (![go.PointerType concreteFooer] "c1")) in
    do:  (map.insert go.uint64 (![go.MapType go.uint64 Fooer] "m") #(W64 10) "$r0");;;
    let: "f" := (GoAlloc FooerUser (GoZeroVal FooerUser #())) in
    let: "$r0" := (CompositeLiteral FooerUser (LiteralValue [KeyedElement None (ElementExpression (go.PointerType concreteFooer) (![go.PointerType concreteFooer] "c1"))])) in
    do:  ("f" <-[FooerUser] "$r0");;;
    return: (![go.SliceType Fooer] "l", ![go.MapType go.uint64 Fooer] "m", ![FooerUser] "f")).

(* go: interfaces.go:51:6 *)
Definition takesVarArgsInterfaceⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "fs",
    exception_do (let: "fs" := (GoAlloc (go.SliceType Fooer) "fs") in
    do:  ((MethodResolve Fooer "Foo"%go (![Fooer] (IndexRef (go.SliceType Fooer) (![go.SliceType Fooer] "fs", #(W64 0))))) #());;;
    return: #()).

(* go: interfaces.go:55:6 *)
Definition testⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (do:  (let: "$a0" := ((let: "$sl0" := (Convert (go.PointerType concreteFooer) Fooer (GoAlloc concreteFooer (CompositeLiteral concreteFooer (LiteralValue [])))) in
    let: "$sl1" := (Convert (go.PointerType concreteFooer) Fooer (GoAlloc concreteFooer (CompositeLiteral concreteFooer (LiteralValue [])))) in
    CompositeLiteral (go.SliceType Fooer) (LiteralValue [KeyedElement None (ElementExpression Fooer "$sl0"); KeyedElement None (ElementExpression Fooer "$sl1")]))) in
    (FuncResolve takesVarArgsInterface [] #()) "$a0");;;
    return: #()).

(* go: interfaces.go:59:6 *)
Definition returnConcreteⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (GoAlloc concreteFooer (CompositeLiteral concreteFooer (LiteralValue [])), #(W64 10))).

(* converts an object into an interface in a multiple return destructuring statement.

   go: interfaces.go:64:6 *)
Definition testMultiReturnⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x",
    exception_do (let: "x" := (GoAlloc (go.PointerType Fooer) "x") in
    let: "y" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: ("$ret0", "$ret1") := ((FuncResolve returnConcrete [] #()) #()) in
    let: "$r0" := (Convert (go.PointerType concreteFooer) Fooer "$ret0") in
    let: "$r1" := "$ret1" in
    do:  ((![go.PointerType Fooer] "x") <-[Fooer] "$r0");;;
    do:  ("y" <-[go.uint64] "$r1");;;
    return: (![go.uint64] "y")).

(* go: interfaces.go:70:6 *)
Definition testReturnStatmentⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "y" := (GoAlloc (go.PointerType concreteFooer) (GoZeroVal (go.PointerType concreteFooer) #())) in
    let: "$r0" := (GoAlloc concreteFooer (CompositeLiteral concreteFooer (LiteralValue []))) in
    do:  ("y" <-[go.PointerType concreteFooer] "$r0");;;
    return: (Convert (go.PointerType concreteFooer) Fooer (![go.PointerType concreteFooer] "y"))).

(* go: interfaces.go:75:6 *)
Definition testConversionInEqⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "f",
    exception_do (let: "f" := (GoAlloc Fooer "f") in
    let: "c" := (GoAlloc (go.PointerType concreteFooer) (GoZeroVal (go.PointerType concreteFooer) #())) in
    let: "$r0" := (GoAlloc concreteFooer (CompositeLiteral concreteFooer (LiteralValue []))) in
    do:  ("c" <-[go.PointerType concreteFooer] "$r0");;;
    let: "$r0" := (Convert (go.PointerType concreteFooer) Fooer (![go.PointerType concreteFooer] "c")) in
    do:  ("f" <-[Fooer] "$r0");;;
    return: ((Convert (go.PointerType concreteFooer) (go.InterfaceType [go.MethodElem "Foo"%go (go.Signature [] false [])]) (![go.PointerType concreteFooer] "c")) =⟨go.InterfaceType [go.MethodElem "Foo"%go (go.Signature [] false [])]⟩ (![Fooer] "f"))).

(* go: interfaces.go:82:6 *)
Definition takeMultipleⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "a" "f",
    exception_do (let: "f" := (GoAlloc (go.SliceType Fooer) "f") in
    let: "a" := (GoAlloc go.uint64 "a") in
    do:  #()).

(* go: interfaces.go:85:6 *)
Definition giveMultipleⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (#(W64 0), Convert (go.PointerType concreteFooer) Fooer (GoAlloc concreteFooer (CompositeLiteral concreteFooer (LiteralValue []))), GoAlloc concreteFooer (CompositeLiteral concreteFooer (LiteralValue [])))).

(* go: interfaces.go:89:6 *)
Definition testConversionInMultipleReturnPassThroughⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: (("$ret0", "$ret1"), "$ret2") := (((FuncResolve giveMultiple [] #()) #())) in
    return: ("$ret0", "$ret1", Convert (go.PointerType concreteFooer) Fooer "$ret2")).

(* See "special case" in https://go.dev/ref/spec#Calls

   go: interfaces.go:94:6 *)
Definition testConversionInMultiplePassThroughⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (do:  (let: (("$ret0", "$ret1"), "$ret2") := (((FuncResolve giveMultiple [] #()) #())) in
    let: "$a0" := "$ret0" in
    let: "$a1" := ((let: "$sl0" := "$ret1" in
    let: "$sl1" := (Convert (go.PointerType concreteFooer) Fooer "$ret2") in
    CompositeLiteral (go.SliceType Fooer) (LiteralValue [KeyedElement None (ElementExpression Fooer "$sl0"); KeyedElement None (ElementExpression Fooer "$sl1")]))) in
    (FuncResolve takeMultiple [] #()) "$a0" "$a1");;;
    return: #()).

(* go: interfaces.go:106:20 *)
Definition concrete1__Fooⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "c" <>,
    exception_do (let: "c" := (GoAlloc concrete1 "c") in
    do:  #()).

(* go: interfaces.go:109:21 *)
Definition concrete1__Bⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "c" <>,
    exception_do (let: "c" := (GoAlloc (go.PointerType concrete1) "c") in
    do:  #()).

(* go: interfaces.go:112:6 *)
Definition testPtrMsetⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "a" := (GoAlloc (go.PointerType concrete1) (GoZeroVal (go.PointerType concrete1) #())) in
    let: "$r0" := (GoAlloc concrete1 (CompositeLiteral concrete1 (LiteralValue []))) in
    do:  ("a" <-[go.PointerType concrete1] "$r0");;;
    let: "p" := (GoAlloc PointerInterface (GoZeroVal PointerInterface #())) in
    let: "$r0" := (Convert (go.PointerType concrete1) PointerInterface (![go.PointerType concrete1] "a")) in
    do:  ("p" <-[PointerInterface] "$r0");;;
    let: "f" := (GoAlloc Fooer (GoZeroVal Fooer #())) in
    let: "$r0" := (Convert concrete1 Fooer (![concrete1] (![go.PointerType concrete1] "a"))) in
    do:  ("f" <-[Fooer] "$r0");;;
    do:  ((MethodResolve PointerInterface "B"%go (![PointerInterface] "p")) #());;;
    do:  ((MethodResolve Fooer "Foo"%go (![Fooer] "f")) #());;;
    return: #()).

(* go: interfaces.go:120:6 *)
Definition pointerAnyⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (GoAlloc go.any (GoZeroVal go.any #()))).

(* go: ints.go:3:6 *)
Definition useIntsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x" "y",
    exception_do (let: "y" := (GoAlloc go.uint32 "y") in
    let: "x" := (GoAlloc go.uint64 "x") in
    let: "z" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (Convert go.uint32 go.uint64 (![go.uint32] "y")) in
    do:  ("z" <-[go.uint64] "$r0");;;
    let: "$r0" := ((![go.uint64] "z") +⟨go.uint64⟩ #(W64 1)) in
    do:  ("z" <-[go.uint64] "$r0");;;
    let: "y2" := (GoAlloc go.uint32 (GoZeroVal go.uint32 #())) in
    let: "$r0" := ((![go.uint32] "y") +⟨go.uint32⟩ #(W32 3)) in
    do:  ("y2" <-[go.uint32] "$r0");;;
    return: (![go.uint64] "z", ![go.uint32] "y2")).

(* go: ints.go:12:6 *)
Definition signedMidpointⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x" "y",
    exception_do (let: "y" := (GoAlloc go.int "y") in
    let: "x" := (GoAlloc go.int "x") in
    return: (((![go.int] "x") +⟨go.int⟩ (![go.int] "y")) /⟨go.int⟩ #(W64 2))).

(* go: literals.go:9:6 *)
Definition normalLiteralsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (CompositeLiteral allTheLiterals (LiteralValue [KeyedElement (Some (KeyField "int"%go)) (ElementExpression go.uint64 #(W64 0)); KeyedElement (Some (KeyField "s"%go)) (ElementExpression go.string #"foo"%go); KeyedElement (Some (KeyField "b"%go)) (ElementExpression go.bool #true)]))).

(* go: literals.go:17:6 *)
Definition outOfOrderLiteralⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (CompositeLiteral allTheLiterals (LiteralValue [KeyedElement (Some (KeyField "b"%go)) (ElementExpression go.bool #true); KeyedElement (Some (KeyField "s"%go)) (ElementExpression go.string #"foo"%go); KeyedElement (Some (KeyField "int"%go)) (ElementExpression go.uint64 #(W64 0))]))).

(* go: literals.go:25:6 *)
Definition specialLiteralsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (CompositeLiteral allTheLiterals (LiteralValue [KeyedElement (Some (KeyField "int"%go)) (ElementExpression go.uint64 #(W64 4096)); KeyedElement (Some (KeyField "s"%go)) (ElementExpression go.string #""%go); KeyedElement (Some (KeyField "b"%go)) (ElementExpression go.bool #false)]))).

(* go: literals.go:33:6 *)
Definition oddLiteralsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (CompositeLiteral allTheLiterals (LiteralValue [KeyedElement (Some (KeyField "int"%go)) (ElementExpression go.uint64 #(W64 5)); KeyedElement (Some (KeyField "s"%go)) (ElementExpression go.string #"backquote string"%go); KeyedElement (Some (KeyField "b"%go)) (ElementExpression go.bool #false)]))).

(* go: literals.go:41:6 *)
Definition unKeyedLiteralⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (CompositeLiteral allTheLiterals (LiteralValue [KeyedElement None (ElementExpression go.uint64 #(W64 0)); KeyedElement None (ElementExpression go.string #"a"%go); KeyedElement None (ElementExpression go.bool #false)]))).

(* go: locks.go:5:6 *)
Definition useLocksⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "m" := (GoAlloc (go.PointerType sync.Mutex) (GoZeroVal (go.PointerType sync.Mutex) #())) in
    let: "$r0" := (GoAlloc sync.Mutex (GoZeroVal sync.Mutex #())) in
    do:  ("m" <-[go.PointerType sync.Mutex] "$r0");;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] "m")) #());;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] "m")) #());;;
    return: #()).

(* go: locks.go:11:6 *)
Definition useCondVarⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "m" := (GoAlloc (go.PointerType sync.Mutex) (GoZeroVal (go.PointerType sync.Mutex) #())) in
    let: "$r0" := (GoAlloc sync.Mutex (GoZeroVal sync.Mutex #())) in
    do:  ("m" <-[go.PointerType sync.Mutex] "$r0");;;
    let: "c" := (GoAlloc (go.PointerType sync.Cond) (GoZeroVal (go.PointerType sync.Cond) #())) in
    let: "$r0" := (let: "$a0" := (Convert (go.PointerType sync.Mutex) sync.Locker (![go.PointerType sync.Mutex] "m")) in
    (FuncResolve sync.NewCond [] #()) "$a0") in
    do:  ("c" <-[go.PointerType sync.Cond] "$r0");;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] "m")) #());;;
    do:  ((MethodResolve (go.PointerType sync.Cond) "Signal"%go (![go.PointerType sync.Cond] "c")) #());;;
    do:  ((MethodResolve (go.PointerType sync.Cond) "Wait"%go (![go.PointerType sync.Cond] "c")) #());;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] "m")) #());;;
    return: #()).

(* go: log_debugging.go:5:6 *)
Definition ToBeDebuggedⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x",
    exception_do (let: "x" := (GoAlloc go.uint64 "x") in
    do:  (let: "$a0" := ((let: "$sl0" := (Convert go.string go.any #"starting function"%go) in
    CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0")]))) in
    (FuncResolve log.Println [] #()) "$a0");;;
    do:  (let: "$a0" := #"called with %d"%go in
    let: "$a1" := ((let: "$sl0" := (Convert go.uint64 go.any (![go.uint64] "x")) in
    CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0")]))) in
    (FuncResolve log.Printf [] #()) "$a0" "$a1");;;
    do:  (let: "$a0" := ((let: "$sl0" := (Convert go.string go.any #"ending function"%go) in
    CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0")]))) in
    (FuncResolve log.Println [] #()) "$a0");;;
    return: (![go.uint64] "x")).

(* go: log_debugging.go:12:6 *)
Definition DoNothingⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (do:  (let: "$a0" := ((let: "$sl0" := (Convert go.string go.any #"doing nothing"%go) in
    CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0")]))) in
    (FuncResolve log.Println [] #()) "$a0");;;
    return: #()).

(* DoSomething is an impure function

   go: loops.go:4:6 *)
Definition DoSomethingⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s",
    exception_do (let: "s" := (GoAlloc go.string "s") in
    do:  #()).

(* go: loops.go:6:6 *)
Definition standardForLoopⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s",
    exception_do (let: "s" := (GoAlloc (go.SliceType go.uint64) "s") in
    let: "sumPtr" := (GoAlloc (go.PointerType go.uint64) (GoZeroVal (go.PointerType go.uint64) #())) in
    let: "$r0" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    do:  ("sumPtr" <-[go.PointerType go.uint64] "$r0");;;
    (let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (if: Convert go.untyped_bool go.bool ((![go.uint64] "i") <⟨go.uint64⟩ (Convert go.int go.uint64 (let: "$a0" := (![go.SliceType go.uint64] "s") in
      (FuncResolve go.len [go.SliceType go.uint64] #()) "$a0")))
      then
        let: "sum" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
        let: "$r0" := (![go.uint64] (![go.PointerType go.uint64] "sumPtr")) in
        do:  ("sum" <-[go.uint64] "$r0");;;
        let: "x" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
        let: "$r0" := (![go.uint64] (IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "s", Convert go.uint64 go.int (![go.uint64] "i")))) in
        do:  ("x" <-[go.uint64] "$r0");;;
        let: "$r0" := ((![go.uint64] "sum") +⟨go.uint64⟩ (![go.uint64] "x")) in
        do:  ((![go.PointerType go.uint64] "sumPtr") <-[go.uint64] "$r0");;;
        let: "$r0" := ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 1)) in
        do:  ("i" <-[go.uint64] "$r0");;;
        continue: #()
      else do:  #());;;
      break: #()));;;
    let: "sum" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (![go.uint64] (![go.PointerType go.uint64] "sumPtr")) in
    do:  ("sum" <-[go.uint64] "$r0");;;
    return: (![go.uint64] "sum")).

(* go: loops.go:25:6 *)
Definition conditionalInLoopⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do ((let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (if: Convert go.untyped_bool go.bool ((![go.uint64] "i") <⟨go.uint64⟩ #(W64 3))
      then
        do:  (let: "$a0" := #"i is small"%go in
        (FuncResolve DoSomething [] #()) "$a0")
      else do:  #());;;
      (if: Convert go.untyped_bool go.bool ((![go.uint64] "i") >⟨go.uint64⟩ #(W64 5))
      then break: #()
      else do:  #());;;
      let: "$r0" := ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 1)) in
      do:  ("i" <-[go.uint64] "$r0");;;
      continue: #()));;;
    return: #()).

(* go: loops.go:38:6 *)
Definition conditionalInLoopElseⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do ((let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (if: Convert go.untyped_bool go.bool ((![go.uint64] "i") >⟨go.uint64⟩ #(W64 5))
      then break: #()
      else
        let: "$r0" := ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 1)) in
        do:  ("i" <-[go.uint64] "$r0");;;
        continue: #())));;;
    return: #()).

(* go: loops.go:49:6 *)
Definition nestedConditionalInLoopImplicitContinueⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do ((let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (if: Convert go.untyped_bool go.bool ((![go.uint64] "i") >⟨go.uint64⟩ #(W64 5))
      then
        (if: Convert go.untyped_bool go.bool ((![go.uint64] "i") >⟨go.uint64⟩ #(W64 10))
        then break: #()
        else do:  #())
      else
        let: "$r0" := ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 1)) in
        do:  ("i" <-[go.uint64] "$r0");;;
        continue: #())));;;
    return: #()).

(* go: loops.go:62:6 *)
Definition ImplicitLoopContinueⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do ((let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (if: Convert go.untyped_bool go.bool ((![go.uint64] "i") <⟨go.uint64⟩ #(W64 4))
      then
        let: "$r0" := #(W64 0) in
        do:  ("i" <-[go.uint64] "$r0")
      else do:  #())));;;
    return: #()).

(* go: loops.go:70:6 *)
Definition ImplicitLoopContinue2ⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do ((let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (if: Convert go.untyped_bool go.bool ((![go.uint64] "i") <⟨go.uint64⟩ #(W64 4))
      then
        let: "$r0" := #(W64 0) in
        do:  ("i" <-[go.uint64] "$r0");;;
        continue: #()
      else do:  #())));;;
    return: #()).

(* go: loops.go:79:6 *)
Definition ImplicitLoopContinueAfterIfBreakⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "i",
    exception_do (let: "i" := (GoAlloc go.uint64 "i") in
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (if: Convert go.untyped_bool go.bool ((![go.uint64] "i") >⟨go.uint64⟩ #(W64 0))
      then break: #()
      else do:  #()));;;
    return: #()).

(* go: loops.go:87:6 *)
Definition nestedLoopsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do ((let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (let: "j" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: "$r0" := #(W64 0) in
      do:  ("j" <-[go.uint64] "$r0");;;
      (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
        (if: Convert go.untyped_bool go.bool #true
        then break: #()
        else do:  #());;;
        let: "$r0" := ((![go.uint64] "j") +⟨go.uint64⟩ #(W64 1)) in
        do:  ("j" <-[go.uint64] "$r0");;;
        continue: #()));;;
      let: "$r0" := ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 1)) in
      do:  ("i" <-[go.uint64] "$r0");;;
      continue: #()));;;
    return: #()).

(* go: loops.go:101:6 *)
Definition nestedGoStyleLoopsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do ((let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, (![go.uint64] "i") <⟨go.uint64⟩ #(W64 10)); (λ: <>, do:  ("i" <-[go.uint64] ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 1)))) := λ: <>,
      (let: "j" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: "$r0" := #(W64 0) in
      do:  ("j" <-[go.uint64] "$r0");;;
      (for: (λ: <>, (![go.uint64] "j") <⟨go.uint64⟩ (![go.uint64] "i")); (λ: <>, do:  ("j" <-[go.uint64] ((![go.uint64] "j") +⟨go.uint64⟩ #(W64 1)))) := λ: <>,
        (if: Convert go.untyped_bool go.bool #true
        then break: #()
        else do:  #());;;
        continue: #()))));;;
    return: #()).

(* go: loops.go:113:6 *)
Definition sumSliceⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "xs",
    exception_do (let: "xs" := (GoAlloc (go.SliceType go.uint64) "xs") in
    let: "sum" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$range" := (![go.SliceType go.uint64] "xs") in
    (let: "x" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    slice.for_range go.uint64 "$range" (λ: "$key" "$value",
      do:  ("x" <-[go.uint64] "$value");;;
      do:  "$key";;;
      do:  ("sum" <-[go.uint64] ((![go.uint64] "sum") +⟨go.uint64⟩ (![go.uint64] "x")))));;;
    return: (![go.uint64] "sum")).

(* go: loops.go:121:6 *)
Definition intSliceLoopⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "xs",
    exception_do (let: "xs" := (GoAlloc (go.SliceType go.uint64) "xs") in
    let: "sum" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    (let: "i" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.int] "$r0");;;
    (for: (λ: <>, (![go.int] "i") <⟨go.int⟩ (let: "$a0" := (![go.SliceType go.uint64] "xs") in
    (FuncResolve go.len [go.SliceType go.uint64] #()) "$a0")); (λ: <>, do:  ("i" <-[go.int] ((![go.int] "i") +⟨go.int⟩ #(W64 1)))) := λ: <>,
      do:  ("sum" <-[go.uint64] ((![go.uint64] "sum") +⟨go.uint64⟩ (![go.uint64] (IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "xs", ![go.int] "i")))))));;;
    return: (![go.uint64] "sum")).

(* go: loops.go:129:6 *)
Definition breakFromLoopⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do ((for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (if: Convert go.untyped_bool go.bool #true
      then break: #()
      else do:  #());;;
      continue: #());;;
    return: #()).

(* go: maps.go:3:6 *)
Definition IterateMapKeysⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "m" "sum",
    exception_do (let: "sum" := (GoAlloc (go.PointerType go.uint64) "sum") in
    let: "m" := (GoAlloc (go.MapType go.uint64 go.uint64) "m") in
    let: "$range" := (![go.MapType go.uint64 go.uint64] "m") in
    (let: "k" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    map.for_range go.uint64 go.uint64 "$range" (λ: "$key" "value",
      do:  ("k" <-[go.uint64] "$key");;;
      let: "oldSum" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: "$r0" := (![go.uint64] (![go.PointerType go.uint64] "sum")) in
      do:  ("oldSum" <-[go.uint64] "$r0");;;
      let: "$r0" := ((![go.uint64] "oldSum") +⟨go.uint64⟩ (![go.uint64] "k")) in
      do:  ((![go.PointerType go.uint64] "sum") <-[go.uint64] "$r0")));;;
    return: #()).

(* go: maps.go:10:6 *)
Definition MapSizeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "m",
    exception_do (let: "m" := (GoAlloc (go.MapType go.uint64 go.bool) "m") in
    return: (Convert go.int go.uint64 (let: "$a0" := (![go.MapType go.uint64 go.bool] "m") in
     (FuncResolve go.len [go.MapType go.uint64 go.bool] #()) "$a0"))).

(* go: maps.go:18:6 *)
Definition MapTypeAliasesⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "m1" "m2",
    exception_do (let: "m2" := (GoAlloc MapWrapper "m2") in
    let: "m1" := (GoAlloc (go.MapType IntWrapper go.bool) "m1") in
    let: "$r0" := (map.lookup1 go.uint64 go.bool (![MapWrapper] "m2") #(W64 0)) in
    do:  (map.insert IntWrapper (![go.MapType IntWrapper go.bool] "m1") #(W64 4) "$r0");;;
    return: #()).

(* go: maps.go:22:6 *)
Definition StringMapⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "m",
    exception_do (let: "m" := (GoAlloc (go.MapType go.string go.uint64) "m") in
    return: (map.lookup1 go.string go.uint64 (![go.MapType go.string go.uint64] "m") #"foo"%go)).

(* go: maps.go:31:6 *)
Definition mapUpdateFieldⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc (go.MapType go.uint64 (go.PointerType mapElem)) (GoZeroVal (go.MapType go.uint64 (go.PointerType mapElem)) #())) in
    let: "$r0" := ((FuncResolve go.make1 [go.MapType go.uint64 (go.PointerType mapElem)] #()) #()) in
    do:  ("x" <-[go.MapType go.uint64 (go.PointerType mapElem)] "$r0");;;
    let: "$r0" := #(W64 10) in
    do:  ((StructFieldRef mapElem "a"%go (map.lookup1 go.uint64 (go.PointerType mapElem) (![go.MapType go.uint64 (go.PointerType mapElem)] "x") #(W64 0))) <-[go.uint64] "$r0");;;
    return: #()).

(* go: maps.go:44:6 *)
Definition mapGetCallⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "handlers" := (GoAlloc (go.MapType go.uint64 (go.FunctionType (go.Signature [] false []))) (GoZeroVal (go.MapType go.uint64 (go.FunctionType (go.Signature [] false []))) #())) in
    let: "$r0" := ((FuncResolve go.make1 [go.MapType go.uint64 (go.FunctionType (go.Signature [] false []))] #()) #()) in
    do:  ("handlers" <-[go.MapType go.uint64 (go.FunctionType (go.Signature [] false []))] "$r0");;;
    let: "$r0" := (λ: <>,
      exception_do (do:  #())
      ) in
    do:  (map.insert go.uint64 (![go.MapType go.uint64 (go.FunctionType (go.Signature [] false []))] "handlers") #(W64 0) "$r0");;;
    do:  ((map.lookup1 go.uint64 (go.FunctionType (go.Signature [] false [])) (![go.MapType go.uint64 (go.FunctionType (go.Signature [] false []))] "handlers") #(W64 0)) #());;;
    return: #()).

(* go: maps.go:50:6 *)
Definition mapLiteralTestⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "ascii" := (GoAlloc (go.MapType go.string go.uint64) (GoZeroVal (go.MapType go.string go.uint64) #())) in
    let: "$r0" := (CompositeLiteral (go.MapType go.string go.uint64) (LiteralValue [KeyedElement (Some (KeyExpression go.string #"a"%go)) (ElementExpression go.uint64 #(W64 97)); KeyedElement (Some (KeyExpression go.string #"b"%go)) (ElementExpression go.uint64 #(W64 98)); KeyedElement (Some (KeyExpression go.string #"c"%go)) (ElementExpression go.uint64 #(W64 99))])) in
    do:  ("ascii" <-[go.MapType go.string go.uint64] "$r0");;;
    return: (![go.MapType go.string go.uint64] "ascii")).

(* go: maps.go:59:6 *)
Definition mapClearTestⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "m" := (GoAlloc (go.MapType go.int go.bool) (GoZeroVal (go.MapType go.int go.bool) #())) in
    let: "$r0" := ((FuncResolve go.make1 [go.MapType go.int go.bool] #()) #()) in
    do:  ("m" <-[go.MapType go.int go.bool] "$r0");;;
    let: "$r0" := #true in
    do:  (map.insert go.int (![go.MapType go.int go.bool] "m") #(W64 1) "$r0");;;
    let: "$r0" := #false in
    do:  (map.insert go.int (![go.MapType go.int go.bool] "m") #(W64 2) "$r0");;;
    let: "$r0" := #true in
    do:  (map.insert go.int (![go.MapType go.int go.bool] "m") #(W64 7) "$r0");;;
    do:  (let: "$a0" := (![go.MapType go.int go.bool] "m") in
    (FuncResolve go.clear [go.MapType go.int go.bool] #()) "$a0");;;
    return: (let: "$a0" := (![go.MapType go.int go.bool] "m") in
     (FuncResolve go.len [go.MapType go.int go.bool] #()) "$a0")).

(* go: maps.go:68:6 *)
Definition mapLookupConversionⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "m" := (GoAlloc (go.MapType go.any go.bool) (GoZeroVal (go.MapType go.any go.bool) #())) in
    let: "$r0" := ((FuncResolve go.make1 [go.MapType go.any go.bool] #()) #()) in
    do:  ("m" <-[go.MapType go.any go.bool] "$r0");;;
    return: (map.lookup1 go.any go.bool (![go.MapType go.any go.bool] "m") (Convert go.string go.any #"ok"%go))).

(* go: multiple.go:3:6 *)
Definition returnTwoⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "p",
    exception_do (let: "p" := (GoAlloc (go.SliceType go.byte) "p") in
    return: (#(W64 0), #(W64 0))).

(* go: multiple.go:7:6 *)
Definition returnTwoWrapperⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "data",
    exception_do (let: "data" := (GoAlloc (go.SliceType go.byte) "data") in
    let: "b" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "a" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] "data") in
    (FuncResolve returnTwo [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("a" <-[go.uint64] "$r0");;;
    do:  ("b" <-[go.uint64] "$r1");;;
    return: (![go.uint64] "a", ![go.uint64] "b")).

(* go: multiple.go:12:6 *)
Definition multipleVarⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x" "y",
    exception_do (let: "y" := (GoAlloc go.uint64 "y") in
    let: "x" := (GoAlloc go.uint64 "x") in
    do:  #()).

(* go: multiple.go:14:6 *)
Definition multiplePassThroughⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (do:  (let: ("$ret0", "$ret1") := ((let: "$a0" := (Convert go.untyped_nil (go.SliceType go.byte) UntypedNil) in
    (FuncResolve returnTwoWrapper [] #()) "$a0")) in
    let: "$a0" := "$ret0" in
    let: "$a1" := "$ret1" in
    (FuncResolve multipleVar [] #()) "$a0" "$a1");;;
    return: #()).

(* go: multiple.go:18:6 *)
Definition multipleReturnPassThroughⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: ("$ret0", "$ret1") := ((let: "$a0" := (Convert go.untyped_nil (go.SliceType go.byte) UntypedNil) in
    (FuncResolve returnTwo [] #()) "$a0")) in
    return: ("$ret0", "$ret1")).

(* go: nil.go:3:6 *)
Definition AssignNilSliceⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "s" := (GoAlloc (go.SliceType (go.SliceType go.byte)) (GoZeroVal (go.SliceType (go.SliceType go.byte)) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType (go.SliceType go.byte)] #()) #(W64 4)) in
    do:  ("s" <-[go.SliceType (go.SliceType go.byte)] "$r0");;;
    let: "$r0" := (Convert go.untyped_nil (go.SliceType go.byte) UntypedNil) in
    do:  ((IndexRef (go.SliceType (go.SliceType go.byte)) (![go.SliceType (go.SliceType go.byte)] "s", #(W64 2))) <-[go.SliceType go.byte] "$r0");;;
    return: #()).

(* go: nil.go:8:6 *)
Definition AssignNilPointerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "s" := (GoAlloc (go.SliceType (go.PointerType go.uint64)) (GoZeroVal (go.SliceType (go.PointerType go.uint64)) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType (go.PointerType go.uint64)] #()) #(W64 4)) in
    do:  ("s" <-[go.SliceType (go.PointerType go.uint64)] "$r0");;;
    let: "$r0" := (Convert go.untyped_nil (go.PointerType go.uint64) UntypedNil) in
    do:  ((IndexRef (go.SliceType (go.PointerType go.uint64)) (![go.SliceType (go.PointerType go.uint64)] "s", #(W64 2))) <-[go.PointerType go.uint64] "$r0");;;
    return: #()).

(* go: nil.go:13:6 *)
Definition CompareSliceToNilⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "s" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 0)) in
    do:  ("s" <-[go.SliceType go.byte] "$r0");;;
    return: ((![go.SliceType go.byte] "s") ≠⟨go.SliceType go.byte⟩ (Convert go.untyped_nil (go.SliceType go.byte) UntypedNil))).

(* go: nil.go:18:6 *)
Definition ComparePointerToNilⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "s" := (GoAlloc (go.PointerType go.uint64) (GoZeroVal (go.PointerType go.uint64) #())) in
    let: "$r0" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    do:  ("s" <-[go.PointerType go.uint64] "$r0");;;
    return: ((![go.PointerType go.uint64] "s") ≠⟨go.PointerType go.uint64⟩ (Convert go.untyped_nil (go.PointerType go.uint64) UntypedNil))).

(* go: nil.go:27:6 *)
Definition useNilFieldⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (GoAlloc containsPointer (CompositeLiteral containsPointer (LiteralValue [KeyedElement (Some (KeyField "s"%go)) (ElementExpression go.untyped_nil UntypedNil)])))).

(* go: operators.go:3:6 *)
Definition LogicalOperatorsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "b1" "b2",
    exception_do (let: "b2" := (GoAlloc go.bool "b2") in
    let: "b1" := (GoAlloc go.bool "b1") in
    return: (((![go.bool] "b1") && ((![go.bool] "b2") || (![go.bool] "b1"))) && (~ #false))).

(* go: operators.go:7:6 *)
Definition LogicalAndEqualityOperatorsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "b1" "x",
    exception_do (let: "x" := (GoAlloc go.uint64 "x") in
    let: "b1" := (GoAlloc go.bool "b1") in
    return: (((![go.uint64] "x") =⟨go.uint64⟩ #(W64 3)) && ((![go.bool] "b1") =⟨go.bool⟩ #true))).

(* go: operators.go:11:6 *)
Definition ArithmeticShiftsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x" "y",
    exception_do (let: "y" := (GoAlloc go.uint64 "y") in
    let: "x" := (GoAlloc go.uint32 "x") in
    return: (#(W64 0))).

(* go: operators.go:16:6 *)
Definition BitwiseOpsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x" "y",
    exception_do (let: "y" := (GoAlloc go.uint64 "y") in
    let: "x" := (GoAlloc go.uint32 "x") in
    return: ((Convert go.uint32 go.uint64 (![go.uint32] "x")) |⟨go.uint64⟩ ((Convert go.uint32 go.uint64 (Convert go.uint64 go.uint32 (![go.uint64] "y"))) &⟨go.uint64⟩ #(W64 43)))).

(* go: operators.go:20:6 *)
Definition Comparisonⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x" "y",
    exception_do (let: "y" := (GoAlloc go.uint64 "y") in
    let: "x" := (GoAlloc go.uint64 "x") in
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "x") <⟨go.uint64⟩ (![go.uint64] "y"))
    then return: (#true)
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "x") =⟨go.uint64⟩ (![go.uint64] "y"))
    then return: (#true)
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "x") ≠⟨go.uint64⟩ (![go.uint64] "y"))
    then return: (#true)
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "x") >⟨go.uint64⟩ (![go.uint64] "y"))
    then return: (#true)
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool (((![go.uint64] "x") +⟨go.uint64⟩ #(W64 1)) >⟨go.uint64⟩ ((![go.uint64] "y") -⟨go.uint64⟩ #(W64 2)))
    then return: (#true)
    else do:  #());;;
    return: (#false)).

(* go: operators.go:39:6 *)
Definition AssignOpsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    do:  ("x" <-[go.uint64] ((![go.uint64] "x") +⟨go.uint64⟩ #(W64 3)));;;
    do:  ("x" <-[go.uint64] ((![go.uint64] "x") -⟨go.uint64⟩ #(W64 3)));;;
    do:  ("x" <-[go.uint64] ((![go.uint64] "x") +⟨go.uint64⟩ #(W64 1)));;;
    do:  ("x" <-[go.uint64] ((![go.uint64] "x") -⟨go.uint64⟩ #(W64 1)));;;
    return: #()).

(* go: operators.go:47:6 *)
Definition BitwiseAndNotⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x" "y",
    exception_do (let: "y" := (GoAlloc go.uint64 "y") in
    let: "x" := (GoAlloc go.uint32 "x") in
    let: "z" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := ((Convert go.uint32 go.uint64 (![go.uint32] "x")) &^⟨go.uint64⟩ (![go.uint64] "y")) in
    do:  ("z" <-[go.uint64] "$r0");;;
    do:  ("z" <-[go.uint64] ((![go.uint64] "z") &^⟨go.uint64⟩ #(W64 255)));;;
    return: (![go.uint64] "z")).

(* go: operators.go:53:6 *)
Definition Negativeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.int64 (GoZeroVal go.int64 #())) in
    let: "$r0" := (Convert go.untyped_int go.int64 (⟨go.untyped_int⟩- #10)) in
    do:  ("x" <-[go.int64] "$r0");;;
    do:  ("x" <-[go.int64] ((![go.int64] "x") +⟨go.int64⟩ #(W64 3)));;;
    return: #()).

(* go: package.go:13:29 *)
Definition wrapExternalStruct__joinⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "w" <>,
    exception_do (let: "w" := (GoAlloc wrapExternalStruct "w") in
    do:  ((MethodResolve (go.PointerType std.JoinHandle) "Join"%go (![go.PointerType std.JoinHandle] (StructFieldRef wrapExternalStruct "j"%go "w"))) #());;;
    return: #()).

(* go: panic.go:3:6 *)
Definition PanicAtTheDiscoⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"disco"%go) in
    (FuncResolve go.panic [] #()) "$a0");;;
    return: #()).

(* go: proph.go:5:6 *)
Definition Oracleⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "p" := (GoAlloc primitive.ProphId (GoZeroVal primitive.ProphId #())) in
    let: "$r0" := ((FuncResolve primitive.NewProph [] #()) #()) in
    do:  ("p" <-[primitive.ProphId] "$r0");;;
    let: "$r0" := (![primitive.ProphId] "p") in
    do:  ("p" <-[primitive.ProphId] "$r0");;;
    return: #()).

(* go: reassign.go:8:6 *)
Definition ReassignVarsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "y" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("y" <-[go.uint64] "$r0");;;
    let: "$r0" := #(W64 3) in
    do:  ("x" <-[go.uint64] "$r0");;;
    let: "z" := (GoAlloc composite (GoZeroVal composite #())) in
    let: "$r0" := (CompositeLiteral composite (LiteralValue [KeyedElement (Some (KeyField "a"%go)) (ElementExpression go.uint64 (![go.uint64] "x")); KeyedElement (Some (KeyField "b"%go)) (ElementExpression go.uint64 (![go.uint64] "y"))])) in
    do:  ("z" <-[composite] "$r0");;;
    let: "$r0" := (CompositeLiteral composite (LiteralValue [KeyedElement (Some (KeyField "a"%go)) (ElementExpression go.uint64 (![go.uint64] "y")); KeyedElement (Some (KeyField "b"%go)) (ElementExpression go.uint64 (![go.uint64] "x"))])) in
    do:  ("z" <-[composite] "$r0");;;
    let: "$r0" := (![go.uint64] (StructFieldRef composite "a"%go "z")) in
    do:  ("x" <-[go.uint64] "$r0");;;
    return: #()).

(* go: recursive.go:3:6 *)
Definition recurⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (do:  ((FuncResolve recur [] #()) #());;;
    return: #()).

(* go: recursive.go:10:13 *)
Definition R__recurMethodⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "r" <>,
    exception_do (let: "r" := (GoAlloc (go.PointerType R) "r") in
    do:  ((MethodResolve (go.PointerType R) "recurMethod"%go (![go.PointerType R] "r")) #());;;
    return: #()).

(* go: recursive.go:22:29 *)
Definition RecursiveEmbedded__recurEmbeddedMethodⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "r" <>,
    exception_do (let: "r" := (GoAlloc (go.PointerType RecursiveEmbedded) "r") in
    do:  ((MethodResolve Other "recurEmbeddedMethod"%go (![Other] (StructFieldRef RecursiveEmbedded "Other"%go (![go.PointerType RecursiveEmbedded] "r")))) #());;;
    return: #()).

(* go: renamedImport.go:7:6 *)
Definition useRenamedImportⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (do:  (let: "$a0" := ((let: "$sl0" := (Convert go.string go.any #"blah"%go) in
    CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0")]))) in
    (FuncResolve fmt.Print [] #()) "$a0");;;
    return: #()).

(* TwoDiskWrite is a dummy function to represent the base layer's disk write

   go: replicated_disk.go:12:6 *)
Definition TwoDiskWriteⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "diskId" "a" "v",
    exception_do (let: "v" := (GoAlloc Block "v") in
    let: "a" := (GoAlloc go.uint64 "a") in
    let: "diskId" := (GoAlloc go.uint64 "diskId") in
    return: (#true)).

(* TwoDiskRead is a dummy function to represent the base layer's disk read

   go: replicated_disk.go:17:6 *)
Definition TwoDiskReadⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "diskId" "a",
    exception_do (let: "a" := (GoAlloc go.uint64 "a") in
    let: "diskId" := (GoAlloc go.uint64 "diskId") in
    return: (CompositeLiteral Block (LiteralValue [KeyedElement (Some (KeyField "Value"%go)) (ElementExpression go.uint64 #(W64 0))]), #true)).

(* TwoDiskLock is a dummy function to represent locking an address in the
   base layer

   go: replicated_disk.go:23:6 *)
Definition TwoDiskLockⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "a",
    exception_do (let: "a" := (GoAlloc go.uint64 "a") in
    do:  #()).

(* TwoDiskUnlock is a dummy function to represent unlocking an address in the
   base layer

   go: replicated_disk.go:27:6 *)
Definition TwoDiskUnlockⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "a",
    exception_do (let: "a" := (GoAlloc go.uint64 "a") in
    do:  #()).

(* go: replicated_disk.go:29:6 *)
Definition ReplicatedDiskReadⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "a",
    exception_do (let: "a" := (GoAlloc go.uint64 "a") in
    do:  (let: "$a0" := (![go.uint64] "a") in
    (FuncResolve TwoDiskLock [] #()) "$a0");;;
    let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "v" := (GoAlloc Block (GoZeroVal Block #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := Disk1 in
    let: "$a1" := (![go.uint64] "a") in
    (FuncResolve TwoDiskRead [] #()) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("v" <-[Block] "$r0");;;
    do:  ("ok" <-[go.bool] "$r1");;;
    (if: ![go.bool] "ok"
    then
      do:  (let: "$a0" := (![go.uint64] "a") in
      (FuncResolve TwoDiskUnlock [] #()) "$a0");;;
      return: (![Block] "v")
    else do:  #());;;
    let: "v2" := (GoAlloc Block (GoZeroVal Block #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := Disk2 in
    let: "$a1" := (![go.uint64] "a") in
    (FuncResolve TwoDiskRead [] #()) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("v2" <-[Block] "$r0");;;
    do:  "$r1";;;
    do:  (let: "$a0" := (![go.uint64] "a") in
    (FuncResolve TwoDiskUnlock [] #()) "$a0");;;
    return: (![Block] "v2")).

(* go: replicated_disk.go:42:6 *)
Definition ReplicatedDiskWriteⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "a" "v",
    exception_do (let: "v" := (GoAlloc Block "v") in
    let: "a" := (GoAlloc go.uint64 "a") in
    do:  (let: "$a0" := (![go.uint64] "a") in
    (FuncResolve TwoDiskLock [] #()) "$a0");;;
    do:  (let: "$a0" := Disk1 in
    let: "$a1" := (![go.uint64] "a") in
    let: "$a2" := (![Block] "v") in
    (FuncResolve TwoDiskWrite [] #()) "$a0" "$a1" "$a2");;;
    do:  (let: "$a0" := Disk2 in
    let: "$a1" := (![go.uint64] "a") in
    let: "$a2" := (![Block] "v") in
    (FuncResolve TwoDiskWrite [] #()) "$a0" "$a1" "$a2");;;
    do:  (let: "$a0" := (![go.uint64] "a") in
    (FuncResolve TwoDiskUnlock [] #()) "$a0");;;
    return: #()).

(* go: replicated_disk.go:49:6 *)
Definition ReplicatedDiskRecoverⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do ((let: "a" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("a" <-[go.uint64] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (if: Convert go.untyped_bool go.bool ((![go.uint64] "a") >⟨go.uint64⟩ DiskSize)
      then break: #()
      else do:  #());;;
      let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
      let: "v" := (GoAlloc Block (GoZeroVal Block #())) in
      let: ("$ret0", "$ret1") := (let: "$a0" := Disk1 in
      let: "$a1" := (![go.uint64] "a") in
      (FuncResolve TwoDiskRead [] #()) "$a0" "$a1") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("v" <-[Block] "$r0");;;
      do:  ("ok" <-[go.bool] "$r1");;;
      (if: ![go.bool] "ok"
      then
        do:  (let: "$a0" := Disk2 in
        let: "$a1" := (![go.uint64] "a") in
        let: "$a2" := (![Block] "v") in
        (FuncResolve TwoDiskWrite [] #()) "$a0" "$a1" "$a2")
      else do:  #());;;
      let: "$r0" := ((![go.uint64] "a") +⟨go.uint64⟩ #(W64 1)) in
      do:  ("a" <-[go.uint64] "$r0");;;
      continue: #()));;;
    return: #()).

(* go: returns.go:3:6 *)
Definition BasicNamedReturnⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.string (GoZeroVal go.string #())) in
    return: (#"ok"%go)).

(* go: returns.go:7:6 *)
Definition NamedReturnⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.string (GoZeroVal go.string #())) in
    let: "$r0" := ((![go.string] "x") +⟨go.string⟩ #"foo"%go) in
    do:  ("x" <-[go.string] "$r0");;;
    return: (![go.string] "x")).

(* go: returns.go:12:6 *)
Definition BasicNamedReturnManyⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "y" := (GoAlloc go.string (GoZeroVal go.string #())) in
    let: "x" := (GoAlloc go.string (GoZeroVal go.string #())) in
    return: (#"ok"%go, #"blah"%go)).

(* go: returns.go:16:6 *)
Definition NamedReturnManyⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "y" := (GoAlloc go.string (GoZeroVal go.string #())) in
    let: "x" := (GoAlloc go.string (GoZeroVal go.string #())) in
    let: "$r0" := #"returned"%go in
    do:  ("x" <-[go.string] "$r0");;;
    let: "$r0" := #"ok"%go in
    do:  ("y" <-[go.string] "$r0");;;
    return: (![go.string] "x", ![go.string] "y")).

(* go: returns.go:22:6 *)
Definition NamedReturnOverrideⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "y" := (GoAlloc go.string (GoZeroVal go.string #())) in
    let: "x" := (GoAlloc go.string (GoZeroVal go.string #())) in
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "x" := (GoAlloc go.string (GoZeroVal go.string #())) in
      let: "$r0" := #"unused"%go in
      do:  ("x" <-[go.string] "$r0");;;
      do:  ("x" <-[go.string] ((![go.string] "x") +⟨go.string⟩ #"stillUnused"%go));;;
      let: "$r0" := #"ok"%go in
      do:  ("y" <-[go.string] "$r0");;;
      break: #());;;
    return: (![go.string] "x", ![go.string] "y")).

(* go: returns.go:32:6 *)
Definition VoidButEndsWithReturnⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (do:  ((FuncResolve BasicNamedReturn [] #()) #());;;
    return: #()).

(* go: returns.go:38:6 *)
Definition VoidImplicitReturnInBranchⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "b",
    exception_do (let: "b" := (GoAlloc go.bool "b") in
    (if: ![go.bool] "b"
    then return: (#())
    else do:  ((FuncResolve BasicNamedReturn [] #()) #()));;;
    return: #()).

(* go: rune.go:3:6 *)
Definition useRuneOpsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "r",
    exception_do (let: "r" := (GoAlloc go.rune "r") in
    do:  ("r" <-[go.rune] ((![go.rune] "r") +⟨go.rune⟩ #(W32 1)));;;
    let: "$r0" := #(W32 97) in
    do:  ("r" <-[go.rune] "$r0");;;
    let: "$r0" := #(W32 47) in
    do:  ("r" <-[go.rune] "$r0");;;
    let: "x" := (GoAlloc go.int32 (GoZeroVal go.int32 #())) in
    let: "$r0" := #(W32 98) in
    do:  ("x" <-[go.int32] "$r0");;;
    let: "$r0" := (![go.int32] "x") in
    do:  ("r" <-[go.rune] "$r0");;;
    return: (![go.rune] "r")).

(* go: slices.go:5:6 *)
Definition sliceOpsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc (go.SliceType go.uint64) (GoZeroVal (go.SliceType go.uint64) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType go.uint64] #()) #(W64 10)) in
    do:  ("x" <-[go.SliceType go.uint64] "$r0");;;
    let: "v1" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (![go.uint64] (IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "x", #(W64 2)))) in
    do:  ("v1" <-[go.uint64] "$r0");;;
    let: "v2" := (GoAlloc (go.SliceType go.uint64) (GoZeroVal (go.SliceType go.uint64) #())) in
    let: "$r0" := (let: "$s" := (![go.SliceType go.uint64] "x") in
    Slice (go.SliceType go.uint64) ("$s", #(W64 2), #(W64 3))) in
    do:  ("v2" <-[go.SliceType go.uint64] "$r0");;;
    let: "v3" := (GoAlloc (go.SliceType go.uint64) (GoZeroVal (go.SliceType go.uint64) #())) in
    let: "$r0" := (let: "$s" := (![go.SliceType go.uint64] "x") in
    Slice (go.SliceType go.uint64) ("$s", #(W64 0), #(W64 3))) in
    do:  ("v3" <-[go.SliceType go.uint64] "$r0");;;
    let: "v4" := (GoAlloc (go.PointerType go.uint64) (GoZeroVal (go.PointerType go.uint64) #())) in
    let: "$r0" := (IndexRef go.uint64 (![go.SliceType go.uint64] "x", #(W64 2))) in
    do:  ("v4" <-[go.PointerType go.uint64] "$r0");;;
    return: ((((((![go.uint64] "v1") +⟨go.uint64⟩ (![go.uint64] (IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "v2", #(W64 0))))) +⟨go.uint64⟩ (![go.uint64] (IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "v3", #(W64 1))))) +⟨go.uint64⟩ (![go.uint64] (![go.PointerType go.uint64] "v4"))) +⟨go.uint64⟩ (Convert go.int go.uint64 (let: "$a0" := (![go.SliceType go.uint64] "x") in
     (FuncResolve go.len [go.SliceType go.uint64] #()) "$a0"))) +⟨go.uint64⟩ (Convert go.int go.uint64 (let: "$a0" := (![go.SliceType go.uint64] "x") in
     (FuncResolve go.cap [go.SliceType go.uint64] #()) "$a0")))).

(* go: slices.go:14:6 *)
Definition makeSingletonSliceⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x",
    exception_do (let: "x" := (GoAlloc go.uint64 "x") in
    return: (CompositeLiteral (go.SliceType go.uint64) (LiteralValue [KeyedElement None (ElementExpression go.uint64 (![go.uint64] "x"))]))).

(* go: slices.go:26:25 *)
Definition sliceOfThings__getThingRefⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "ts" "i",
    exception_do (let: "ts" := (GoAlloc sliceOfThings "ts") in
    let: "i" := (GoAlloc go.uint64 "i") in
    return: (IndexRef thing (![go.SliceType thing] (StructFieldRef sliceOfThings "things"%go "ts"), ![go.uint64] "i"))).

(* go: slices.go:30:6 *)
Definition makeAliasⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: ((FuncResolve go.make2 [SliceAlias] #()) #(W64 10))).

(* Skip is a placeholder for some impure code

   go: spawn.go:8:6 *)
Definition Skipⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (do:  #()).

(* go: spawn.go:10:6 *)
Definition simpleSpawnⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "l" := (GoAlloc (go.PointerType sync.Mutex) (GoZeroVal (go.PointerType sync.Mutex) #())) in
    let: "$r0" := (GoAlloc sync.Mutex (GoZeroVal sync.Mutex #())) in
    do:  ("l" <-[go.PointerType sync.Mutex] "$r0");;;
    let: "v" := (GoAlloc (go.PointerType go.uint64) (GoZeroVal (go.PointerType go.uint64) #())) in
    let: "$r0" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    do:  ("v" <-[go.PointerType go.uint64] "$r0");;;
    let: "$go" := (λ: <>,
      exception_do (do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] "l")) #());;;
      let: "x" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: "$r0" := (![go.uint64] (![go.PointerType go.uint64] "v")) in
      do:  ("x" <-[go.uint64] "$r0");;;
      (if: Convert go.untyped_bool go.bool ((![go.uint64] "x") >⟨go.uint64⟩ #(W64 0))
      then do:  ((FuncResolve Skip [] #()) #())
      else do:  #());;;
      do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] "l")) #());;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] "l")) #());;;
    let: "$r0" := #(W64 1) in
    do:  ((![go.PointerType go.uint64] "v") <-[go.uint64] "$r0");;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] "l")) #());;;
    return: #()).

(* go: spawn.go:26:6 *)
Definition threadCodeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "tid",
    exception_do (let: "tid" := (GoAlloc go.uint64 "tid") in
    do:  #()).

(* go: spawn.go:28:6 *)
Definition loopSpawnⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do ((let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, (![go.uint64] "i") <⟨go.uint64⟩ #(W64 10)); (λ: <>, do:  ("i" <-[go.uint64] ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 1)))) := λ: <>,
      let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: "$r0" := (![go.uint64] "i") in
      do:  ("i" <-[go.uint64] "$r0");;;
      let: "$go" := (λ: <>,
        exception_do (do:  (let: "$a0" := (![go.uint64] "i") in
        (FuncResolve threadCode [] #()) "$a0");;;
        return: #())
        ) in
      do:  (Fork ("$go" #()))));;;
    (let: "dummy" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #true in
    do:  ("dummy" <-[go.bool] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "$r0" := (~ (![go.bool] "dummy")) in
      do:  ("dummy" <-[go.bool] "$r0");;;
      continue: #()));;;
    return: #()).

(* go: strings.go:3:6 *)
Definition stringAppendⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s",
    exception_do (let: "s" := (GoAlloc go.string "s") in
    return: ((#"prefix "%go +⟨go.string⟩ (![go.string] "s")) +⟨go.string⟩ #" "%go)).

(* go: strings.go:7:6 *)
Definition stringLengthⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s",
    exception_do (let: "s" := (GoAlloc go.string "s") in
    return: (Convert go.int go.uint64 (let: "$a0" := (![go.string] "s") in
     (FuncResolve go.len [go.string] #()) "$a0"))).

(* go: strings.go:11:6 *)
Definition xⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (do:  (let: "$a0" := #"ab"%go in
    (FuncResolve stringAppend [] #()) "$a0");;;
    return: #()).

(* go: struct_method.go:8:16 *)
Definition Point__Addⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "c" "z",
    exception_do (let: "c" := (GoAlloc Point "c") in
    let: "z" := (GoAlloc go.uint64 "z") in
    return: (((![go.uint64] (StructFieldRef Point "x"%go "c")) +⟨go.uint64⟩ (![go.uint64] (StructFieldRef Point "y"%go "c"))) +⟨go.uint64⟩ (![go.uint64] "z"))).

(* go: struct_method.go:12:16 *)
Definition Point__GetFieldⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "c" <>,
    exception_do (let: "c" := (GoAlloc Point "c") in
    let: "x" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (![go.uint64] (StructFieldRef Point "x"%go "c")) in
    do:  ("x" <-[go.uint64] "$r0");;;
    let: "y" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (![go.uint64] (StructFieldRef Point "y"%go "c")) in
    do:  ("y" <-[go.uint64] "$r0");;;
    return: ((![go.uint64] "x") +⟨go.uint64⟩ (![go.uint64] "y"))).

(* go: struct_method.go:18:6 *)
Definition UseAddⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "c" := (GoAlloc Point (GoZeroVal Point #())) in
    let: "$r0" := (CompositeLiteral Point (LiteralValue [KeyedElement (Some (KeyField "x"%go)) (ElementExpression go.uint64 #(W64 2)); KeyedElement (Some (KeyField "y"%go)) (ElementExpression go.uint64 #(W64 3))])) in
    do:  ("c" <-[Point] "$r0");;;
    let: "r" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (let: "$a0" := #(W64 4) in
    (MethodResolve Point "Add"%go (![Point] "c")) "$a0") in
    do:  ("r" <-[go.uint64] "$r0");;;
    return: (![go.uint64] "r")).

(* go: struct_method.go:24:6 *)
Definition UseAddWithLiteralⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "r" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (let: "$a0" := #(W64 4) in
    (MethodResolve Point "Add"%go (CompositeLiteral Point (LiteralValue [KeyedElement (Some (KeyField "x"%go)) (ElementExpression go.uint64 #(W64 2)); KeyedElement (Some (KeyField "y"%go)) (ElementExpression go.uint64 #(W64 3))]))) "$a0") in
    do:  ("r" <-[go.uint64] "$r0");;;
    return: (![go.uint64] "r")).

(* go: struct_method.go:29:14 *)
Definition Point__IgnoreReceiverⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <> <>,
    exception_do (return: (#"ok"%go)).

(* go: struct_pointers.go:14:6 *)
Definition NewSⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (GoAlloc S (CompositeLiteral S (LiteralValue [KeyedElement (Some (KeyField "a"%go)) (ElementExpression go.uint64 #(W64 2)); KeyedElement (Some (KeyField "b"%go)) (ElementExpression TwoInts (CompositeLiteral TwoInts (LiteralValue [KeyedElement (Some (KeyField "x"%go)) (ElementExpression go.uint64 #(W64 1)); KeyedElement (Some (KeyField "y"%go)) (ElementExpression go.uint64 #(W64 2))]))); KeyedElement (Some (KeyField "c"%go)) (ElementExpression go.bool #true)])))).

(* go: struct_pointers.go:22:13 *)
Definition S__readAⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" <>,
    exception_do (let: "s" := (GoAlloc (go.PointerType S) "s") in
    return: (![go.uint64] (StructFieldRef S "a"%go (![go.PointerType S] "s")))).

(* go: struct_pointers.go:26:13 *)
Definition S__readBⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" <>,
    exception_do (let: "s" := (GoAlloc (go.PointerType S) "s") in
    return: (![TwoInts] (StructFieldRef S "b"%go (![go.PointerType S] "s")))).

(* go: struct_pointers.go:30:12 *)
Definition S__readBValⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" <>,
    exception_do (let: "s" := (GoAlloc S "s") in
    return: (![TwoInts] (StructFieldRef S "b"%go "s"))).

(* go: struct_pointers.go:34:13 *)
Definition S__writeBⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" "two",
    exception_do (let: "s" := (GoAlloc (go.PointerType S) "s") in
    let: "two" := (GoAlloc TwoInts "two") in
    let: "$r0" := (![TwoInts] "two") in
    do:  ((StructFieldRef S "b"%go (![go.PointerType S] "s")) <-[TwoInts] "$r0");;;
    return: #()).

(* go: struct_pointers.go:38:13 *)
Definition S__negateCⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" <>,
    exception_do (let: "s" := (GoAlloc (go.PointerType S) "s") in
    let: "$r0" := (~ (![go.bool] (StructFieldRef S "c"%go (![go.PointerType S] "s")))) in
    do:  ((StructFieldRef S "c"%go (![go.PointerType S] "s")) <-[go.bool] "$r0");;;
    return: #()).

(* go: struct_pointers.go:42:13 *)
Definition S__refCⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" <>,
    exception_do (let: "s" := (GoAlloc (go.PointerType S) "s") in
    return: (StructFieldRef S "c"%go (![go.PointerType S] "s"))).

(* go: struct_pointers.go:46:6 *)
Definition localSRefⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "s" := (GoAlloc S (GoZeroVal S #())) in
    return: (StructFieldRef S "b"%go "s")).

(* go: struct_pointers.go:54:6 *)
Definition setFieldⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "s" := (GoAlloc S (GoZeroVal S #())) in
    let: "$r0" := #(W64 0) in
    do:  ((StructFieldRef S "a"%go "s") <-[go.uint64] "$r0");;;
    let: "$r0" := #true in
    do:  ((StructFieldRef S "c"%go "s") <-[go.bool] "$r0");;;
    return: (![S] "s")).

(* go: switch.go:3:6 *)
Definition testSwitchValⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x",
    exception_do (let: "x" := (GoAlloc go.uint64 "x") in
    let: "$sw" := (![go.uint64] "x") in
    (if: "$sw" =⟨go.uint64⟩ #(W64 0)
    then return: (#true)
    else
      (if: "$sw" =⟨go.uint64⟩ #(W64 1)
      then return: (#false)
      else return: (#false)))).

(* go: switch.go:14:6 *)
Definition testSwitchMultipleⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x",
    exception_do (let: "x" := (GoAlloc go.uint64 "x") in
    let: "$sw" := (![go.uint64] "x") in
    (if: ("$sw" =⟨go.uint64⟩ #(W64 1)) || ("$sw" =⟨go.uint64⟩ #(W64 10))
    then return: (#(W64 1))
    else
      (if: "$sw" =⟨go.uint64⟩ #(W64 0)
      then return: (#(W64 2))
      else do:  #()));;;
    return: (#(W64 3))).

(* DoSomeLocking uses the entire lock API

   go: synchronization.go:6:6 *)
Definition DoSomeLockingⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l",
    exception_do (let: "l" := (GoAlloc (go.PointerType sync.Mutex) "l") in
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] "l")) #());;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] "l")) #());;;
    return: #()).

(* go: synchronization.go:15:6 *)
Definition makeLockⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "l" := (GoAlloc (go.PointerType sync.Mutex) (GoZeroVal (go.PointerType sync.Mutex) #())) in
    let: "$r0" := (GoAlloc sync.Mutex (GoZeroVal sync.Mutex #())) in
    do:  ("l" <-[go.PointerType sync.Mutex] "$r0");;;
    do:  (let: "$a0" := (![go.PointerType sync.Mutex] "l") in
    (FuncResolve DoSomeLocking [] #()) "$a0");;;
    return: #()).

(* go: time.go:5:6 *)
Definition sleepⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (do:  (let: "$a0" := #(W64 1000) in
    (FuncResolve primitive.Sleep [] #()) "$a0");;;
    return: #()).

(* go: trailing_call.go:3:6 *)
Definition mkIntⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (#(W64 42))).

(* go: trailing_call.go:7:6 *)
Definition mkNothingⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (do:  ((FuncResolve mkInt [] #()) #());;;
    return: #()).

(* go: type_alias.go:11:6 *)
Definition convertToAliasⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 2) in
    do:  ("x" <-[go.uint64] "$r0");;;
    return: (![go.uint64] "x")).

(* go: type_switch.go:3:6 *)
Definition typeAssertIntⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x",
    exception_do (let: "x" := (GoAlloc go.any "x") in
    return: (TypeAssert go.int (![go.any] "x"))).

(* go: type_switch.go:7:6 *)
Definition wrapUnwrapIntⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (let: "$a0" := (Convert go.int go.any #(W64 1)) in
     (FuncResolve typeAssertInt [] #()) "$a0")).

(* go: type_switch.go:11:6 *)
Definition checkedTypeAssertⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x",
    exception_do (let: "x" := (GoAlloc go.any "x") in
    (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "v" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: ("$ret0", "$ret1") := (TypeAssert2 go.uint64 (![go.any] "x")) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("v" <-[go.uint64] "$r0");;;
    do:  ("ok" <-[go.bool] "$r1");;;
    (if: ![go.bool] "ok"
    then return: (![go.uint64] "v")
    else do:  #()));;;
    return: (#(W64 3))).

(* go: type_switch.go:18:6 *)
Definition basicTypeSwitchⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x",
    exception_do (let: "x" := (GoAlloc go.any "x") in
    let: "$y" := (![go.any] "x") in
    let: ("$x", "$ok") := (TypeAssert2 go.int "$y") in
    (if: "$ok"
    then return: (#(W64 1))
    else
      let: ("$x", "$ok") := (TypeAssert2 go.string "$y") in
      (if: "$ok"
      then return: (#(W64 2))
      else do:  #()));;;
    return: (#(W64 0))).

(* go: type_switch.go:28:6 *)
Definition fancyTypeSwitchⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x",
    exception_do (let: "x" := (GoAlloc go.any "x") in
    let: "r" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$y" := (![go.any] "x") in
    (let: "z" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := #(W64 0) in
    do:  ("z" <-[go.int] "$r0");;;
    let: ("$x", "$ok") := (TypeAssert2 go.int "$y") in
    (if: "$ok"
    then
      let: "y" := (GoAlloc go.int "$x") in
      return: (![go.int] "y")
    else
      let: ("$x", "$ok") := (TypeAssert2 go.string "$y") in
      (if: "$ok"
      then
        let: "y" := (GoAlloc go.string "$x") in
        return: (#(W64 2))
      else
        let: "$ok" := ("$y" =⟨go.any⟩ #interface.nil) in
        let: "$x" := "$y" in
        (if: "$ok"
        then
          let: "y" := (GoAlloc go.any "$x") in
          return: (#(W64 4))
        else
          let: "$r0" := #(W64 3) in
          do:  ("z" <-[go.int] "$r0");;;
          let: "$r0" := (![go.int] "z") in
          do:  ("r" <-[go.int] "$r0")))));;;
    return: (![go.int] "r")).

(* go: type_switch.go:44:6 *)
Definition multiTypeSwitchⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x",
    exception_do (let: "x" := (GoAlloc go.any "x") in
    let: "$y" := (![go.any] "x") in
    let: "$ok" := ((Snd (TypeAssert2 go.int "$y")) || (Snd (TypeAssert2 go.int "$y"))) in
    let: "$x" := "$y" in
    (if: "$ok"
    then return: (#(W64 1))
    else do:  #());;;
    return: (#(W64 0))).

(* go: varargs.go:3:6 *)
Definition variadicFuncⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "a" "b" "cs",
    exception_do (let: "cs" := (GoAlloc (go.SliceType go.byte) "cs") in
    let: "b" := (GoAlloc go.string "b") in
    let: "a" := (GoAlloc go.uint64 "a") in
    do:  #()).

(* go: varargs.go:6:6 *)
Definition testVariadicCallⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (do:  (let: "$a0" := #(W64 10) in
    let: "$a1" := #"abc"%go in
    let: "$a2" := ((let: "$sl0" := #(W8 0) in
    let: "$sl1" := #(W8 1) in
    let: "$sl2" := #(W8 2) in
    let: "$sl3" := #(W8 3) in
    CompositeLiteral (go.SliceType go.byte) (LiteralValue [KeyedElement None (ElementExpression go.byte "$sl0"); KeyedElement None (ElementExpression go.byte "$sl1"); KeyedElement None (ElementExpression go.byte "$sl2"); KeyedElement None (ElementExpression go.byte "$sl3")]))) in
    (FuncResolve variadicFunc [] #()) "$a0" "$a1" "$a2");;;
    do:  (let: "$a0" := #(W64 10) in
    let: "$a1" := #"abc"%go in
    let: "$a2" := #slice.nil in
    (FuncResolve variadicFunc [] #()) "$a0" "$a1" "$a2");;;
    let: "c" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    do:  (let: "$a0" := #(W64 10) in
    let: "$a1" := #"abc"%go in
    let: "$a2" := (![go.SliceType go.byte] "c") in
    (FuncResolve variadicFunc [] #()) "$a0" "$a1" "$a2");;;
    return: #()).

(* go: varargs.go:13:6 *)
Definition returnMultipleⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (#(W64 0), #"xyz"%go, #(W8 0), #(W8 0))).

(* go: varargs.go:17:6 *)
Definition testVariadicPassThroughⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (do:  (let: ((("$ret0", "$ret1"), "$ret2"), "$ret3") := (((FuncResolve returnMultiple [] #()) #())) in
    let: "$a0" := "$ret0" in
    let: "$a1" := "$ret1" in
    let: "$a2" := ((let: "$sl0" := "$ret2" in
    let: "$sl1" := "$ret3" in
    CompositeLiteral (go.SliceType go.byte) (LiteralValue [KeyedElement None (ElementExpression go.byte "$sl0"); KeyedElement None (ElementExpression go.byte "$sl1")]))) in
    (FuncResolve variadicFunc [] #()) "$a0" "$a1" "$a2");;;
    return: #()).

(* go: vars.go:3:6 *)
Definition LocalVarsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "b" := (GoAlloc go.string (GoZeroVal go.string #())) in
    let: "a" := (GoAlloc go.int (GoZeroVal go.int #())) in
    do:  ("b" <-[go.string] ((![go.string] "b") +⟨go.string⟩ #"hello"%go));;;
    return: (![go.int] "a")).

(* go: vars.go:12:6 *)
Definition LocalConstsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let c := #10 in
    let d := #15 in
    let e := #8 in
    do:  ("x" <-[go.int] ((![go.int] "x") +⟨go.int⟩ (Convert go.untyped_int go.int c)));;;
    do:  ("x" <-[go.int] ((![go.int] "x") -⟨go.int⟩ (Convert go.untyped_int go.int d)));;;
    return: (![go.int] "x")).

#[global] Instance info' : PkgInfo pkg_id.unittest :=
{|
  pkg_imported_pkgs := [code.fmt.pkg_id.fmt; code.sync.pkg_id.sync; code.github_com.goose_lang.primitive.pkg_id.primitive; code.github_com.goose_lang.primitive.disk.pkg_id.disk; code.log.pkg_id.log; code.github_com.goose_lang.std.pkg_id.std]
|}.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init pkg_id.unittest (λ: <>,
      exception_do (do:  (go.GlobalAlloc mapLiteralWithConversion (go.MapType go.any go.any) #());;;
      do:  (go.GlobalAlloc mapLiteral (go.MapType go.string go.uint64) #());;;
      do:  (go.GlobalAlloc globalB go.string #());;;
      do:  (go.GlobalAlloc globalA go.string #());;;
      do:  (go.GlobalAlloc globalY go.string #());;;
      do:  (go.GlobalAlloc GlobalX go.uint64 #());;;
      do:  (std.initialize' #());;;
      do:  (log.initialize' #());;;
      do:  (disk.initialize' #());;;
      do:  (primitive.initialize' #());;;
      do:  (sync.initialize' #());;;
      do:  (fmt.initialize' #());;;
      let: "$r0" := ((FuncResolve foo [] #()) #()) in
      do:  ((GlobalVarAddr GlobalX #()) <-[go.uint64] "$r0");;;
      let: "$r0" := #"a"%go in
      do:  ((GlobalVarAddr globalA #()) <-[go.string] "$r0");;;
      let: "$r0" := #"b"%go in
      do:  ((GlobalVarAddr globalB #()) <-[go.string] "$r0");;;
      let: "$r0" := ((FuncResolve foo [] #()) #()) in
      let: "$r0" := (CompositeLiteral (go.MapType go.string go.uint64) (LiteralValue [KeyedElement (Some (KeyExpression go.string #"a"%go)) (ElementExpression go.uint64 #(W64 10))])) in
      do:  ((GlobalVarAddr mapLiteral #()) <-[go.MapType go.string go.uint64] "$r0");;;
      let: "$r0" := (CompositeLiteral (go.MapType go.any go.any) (LiteralValue [KeyedElement (Some (KeyExpression go.string #"a"%go)) (ElementExpression go.int #(W64 10))])) in
      do:  ((GlobalVarAddr mapLiteralWithConversion #()) <-[go.MapType go.any go.any] "$r0");;;
      do:  ((λ: <>,
        exception_do (let: "$r0" := (![go.uint64] (GlobalVarAddr GlobalX #())) in
        do:  ((GlobalVarAddr GlobalX #()) <-[go.uint64] "$r0");;;
        return: #())
        ) #());;;
      do:  ((λ: <>,
        exception_do (let: "$r0" := #""%go in
        do:  ((GlobalVarAddr globalY #()) <-[go.string] "$r0");;;
        return: #())
        ) #()))
      ).

Module Foo.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := (array.t w64 10).
End def.
End Foo.

Definition Fooⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.ArrayType 10 go.uint64.

Class Foo_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Foo_underlying :: (Foo) <u (Fooⁱᵐᵖˡ);
}.

Module importantStruct.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End importantStruct.

Definition importantStruct'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [

].
Program Definition importantStruct'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (importantStruct'fds_unsealed).
Global Instance equals_unfold_importantStruct {ext : ffi_syntax} {go_gctx : GoGlobalContext} : importantStruct'fds =→ importantStruct'fds_unsealed.
Proof. rewrite /importantStruct'fds seal_eq //. Qed.

Definition importantStructⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (importantStruct'fds).

Class importantStruct_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] importantStruct_type_repr  :: go.TypeReprUnderlying importantStructⁱᵐᵖˡ importantStruct.t;
  #[global] importantStruct_underlying :: (importantStruct) <u (importantStructⁱᵐᵖˡ);
}.

Module stringWrapper.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := go_string.
End def.
End stringWrapper.

Definition stringWrapperⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.string.

Class stringWrapper_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] stringWrapper_underlying :: (stringWrapper) <u (stringWrapperⁱᵐᵖˡ);
}.

Module Uint32.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := w32.
End def.
End Uint32.

Definition Uint32ⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.uint32.

Class Uint32_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Uint32_underlying :: (Uint32) <u (Uint32ⁱᵐᵖˡ);
}.

Module numWrapper.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := w64.
End def.
End numWrapper.

Definition numWrapperⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.int.

Class numWrapper_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] numWrapper_underlying :: (numWrapper) <u (numWrapperⁱᵐᵖˡ);
  #[global] numWrapper'ptr_inc_unfold :: MethodUnfold (go.PointerType (numWrapper)) "inc" (numWrapper__incⁱᵐᵖˡ);
}.

Module withInterface.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  a' : interface.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End withInterface.

Definition withInterface'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "a"%go go.any)
].
Program Definition withInterface'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (withInterface'fds_unsealed).
Global Instance equals_unfold_withInterface {ext : ffi_syntax} {go_gctx : GoGlobalContext} : withInterface'fds =→ withInterface'fds_unsealed.
Proof. rewrite /withInterface'fds seal_eq //. Qed.

Definition withInterfaceⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (withInterface'fds).

Class withInterface_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] withInterface_type_repr  :: go.TypeReprUnderlying withInterfaceⁱᵐᵖˡ withInterface.t;
  #[global] withInterface_underlying :: (withInterface) <u (withInterfaceⁱᵐᵖˡ);
  #[global] withInterface_get_a (x : withInterface.t) :: ⟦StructFieldGet (withInterfaceⁱᵐᵖˡ) "a", #x⟧ ⤳[under] #x.(withInterface.a');
  #[global] withInterface_set_a (x : withInterface.t) y :: ⟦StructFieldSet (withInterfaceⁱᵐᵖˡ) "a", (#x, #y)⟧ ⤳[under] #(x <|withInterface.a' := y|>);
}.

Module diskWrapper.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  d' : disk.Disk.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End diskWrapper.

Definition diskWrapper'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "d"%go disk.Disk)
].
Program Definition diskWrapper'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (diskWrapper'fds_unsealed).
Global Instance equals_unfold_diskWrapper {ext : ffi_syntax} {go_gctx : GoGlobalContext} : diskWrapper'fds =→ diskWrapper'fds_unsealed.
Proof. rewrite /diskWrapper'fds seal_eq //. Qed.

Definition diskWrapperⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (diskWrapper'fds).

Class diskWrapper_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] diskWrapper_type_repr  :: go.TypeReprUnderlying diskWrapperⁱᵐᵖˡ diskWrapper.t;
  #[global] diskWrapper_underlying :: (diskWrapper) <u (diskWrapperⁱᵐᵖˡ);
  #[global] diskWrapper_get_d (x : diskWrapper.t) :: ⟦StructFieldGet (diskWrapperⁱᵐᵖˡ) "d", #x⟧ ⤳[under] #x.(diskWrapper.d');
  #[global] diskWrapper_set_d (x : diskWrapper.t) y :: ⟦StructFieldSet (diskWrapperⁱᵐᵖˡ) "d", (#x, #y)⟧ ⤳[under] #(x <|diskWrapper.d' := y|>);
}.

Module embedA.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  a' : go_string;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End embedA.

Definition embedA'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "a"%go go.string)
].
Program Definition embedA'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (embedA'fds_unsealed).
Global Instance equals_unfold_embedA {ext : ffi_syntax} {go_gctx : GoGlobalContext} : embedA'fds =→ embedA'fds_unsealed.
Proof. rewrite /embedA'fds seal_eq //. Qed.

Definition embedAⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (embedA'fds).

Class embedA_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] embedA_type_repr  :: go.TypeReprUnderlying embedAⁱᵐᵖˡ embedA.t;
  #[global] embedA_underlying :: (embedA) <u (embedAⁱᵐᵖˡ);
  #[global] embedA_get_a (x : embedA.t) :: ⟦StructFieldGet (embedAⁱᵐᵖˡ) "a", #x⟧ ⤳[under] #x.(embedA.a');
  #[global] embedA_set_a (x : embedA.t) y :: ⟦StructFieldSet (embedAⁱᵐᵖˡ) "a", (#x, #y)⟧ ⤳[under] #(x <|embedA.a' := y|>);
  #[global] embedA_Foo_unfold :: MethodUnfold (embedA) "Foo" (embedA__Fooⁱᵐᵖˡ);
  #[global] embedA'ptr_Bar_unfold :: MethodUnfold (go.PointerType (embedA)) "Bar" (embedA__Barⁱᵐᵖˡ);
  #[global] embedA'ptr_Foo_unfold :: MethodUnfold (go.PointerType (embedA)) "Foo" (λ: "$r", MethodResolve (embedA) "Foo" (![(embedA)] "$r"));
}.

Module embedB.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  embedA' : unittest.embedA.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End embedB.

Definition embedB'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.EmbeddedField "embedA"%go embedA)
].
Program Definition embedB'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (embedB'fds_unsealed).
Global Instance equals_unfold_embedB {ext : ffi_syntax} {go_gctx : GoGlobalContext} : embedB'fds =→ embedB'fds_unsealed.
Proof. rewrite /embedB'fds seal_eq //. Qed.

Definition embedBⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (embedB'fds).

Class embedB_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] embedB_type_repr  :: go.TypeReprUnderlying embedBⁱᵐᵖˡ embedB.t;
  #[global] embedB_underlying :: (embedB) <u (embedBⁱᵐᵖˡ);
  #[global] embedB_get_embedA (x : embedB.t) :: ⟦StructFieldGet (embedBⁱᵐᵖˡ) "embedA", #x⟧ ⤳[under] #x.(embedB.embedA');
  #[global] embedB_set_embedA (x : embedB.t) y :: ⟦StructFieldSet (embedBⁱᵐᵖˡ) "embedA", (#x, #y)⟧ ⤳[under] #(x <|embedB.embedA' := y|>);
  #[global] embedB_Foo_unfold :: MethodUnfold (embedB) "Foo" (embedB__Fooⁱᵐᵖˡ);
  #[global] embedB'ptr_Bar_unfold :: MethodUnfold (go.PointerType (embedB)) "Bar" (λ: "$r", MethodResolve (go.PointerType embedA) "Bar" (StructFieldRef embedB "embedA"%go "$r"));
  #[global] embedB'ptr_Car_unfold :: MethodUnfold (go.PointerType (embedB)) "Car" (embedB__Carⁱᵐᵖˡ);
  #[global] embedB'ptr_Foo_unfold :: MethodUnfold (go.PointerType (embedB)) "Foo" (λ: "$r", MethodResolve (embedB) "Foo" (![(embedB)] "$r"));
}.

Module embedC.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  embedB' : loc;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End embedC.

Definition embedC'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.EmbeddedField "embedB"%go (go.PointerType embedB))
].
Program Definition embedC'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (embedC'fds_unsealed).
Global Instance equals_unfold_embedC {ext : ffi_syntax} {go_gctx : GoGlobalContext} : embedC'fds =→ embedC'fds_unsealed.
Proof. rewrite /embedC'fds seal_eq //. Qed.

Definition embedCⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (embedC'fds).

Class embedC_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] embedC_type_repr  :: go.TypeReprUnderlying embedCⁱᵐᵖˡ embedC.t;
  #[global] embedC_underlying :: (embedC) <u (embedCⁱᵐᵖˡ);
  #[global] embedC_get_embedB (x : embedC.t) :: ⟦StructFieldGet (embedCⁱᵐᵖˡ) "embedB", #x⟧ ⤳[under] #x.(embedC.embedB');
  #[global] embedC_set_embedB (x : embedC.t) y :: ⟦StructFieldSet (embedCⁱᵐᵖˡ) "embedB", (#x, #y)⟧ ⤳[under] #(x <|embedC.embedB' := y|>);
  #[global] embedC_Bar_unfold :: MethodUnfold (embedC) "Bar" (λ: "$r", MethodResolve (go.PointerType embedB) "Bar" (StructFieldGet (embedC) "embedB" "$r" ))%V;
  #[global] embedC_Car_unfold :: MethodUnfold (embedC) "Car" (λ: "$r", MethodResolve (go.PointerType embedB) "Car" (StructFieldGet (embedC) "embedB" "$r" ))%V;
  #[global] embedC_Foo_unfold :: MethodUnfold (embedC) "Foo" (λ: "$r", MethodResolve (go.PointerType embedB) "Foo" (StructFieldGet (embedC) "embedB" "$r" ))%V;
  #[global] embedC'ptr_Bar_unfold :: MethodUnfold (go.PointerType (embedC)) "Bar" (λ: "$r", MethodResolve (go.PointerType embedB) "Bar" (![go.PointerType embedB] (StructFieldRef embedC "embedB"%go "$r")));
  #[global] embedC'ptr_Car_unfold :: MethodUnfold (go.PointerType (embedC)) "Car" (λ: "$r", MethodResolve (go.PointerType embedB) "Car" (![go.PointerType embedB] (StructFieldRef embedC "embedB"%go "$r")));
  #[global] embedC'ptr_Foo_unfold :: MethodUnfold (go.PointerType (embedC)) "Foo" (λ: "$r", MethodResolve (go.PointerType embedB) "Foo" (![go.PointerType embedB] (StructFieldRef embedC "embedB"%go "$r")));
}.

Module embedD.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  embedC' : unittest.embedC.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End embedD.

Definition embedD'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.EmbeddedField "embedC"%go embedC)
].
Program Definition embedD'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (embedD'fds_unsealed).
Global Instance equals_unfold_embedD {ext : ffi_syntax} {go_gctx : GoGlobalContext} : embedD'fds =→ embedD'fds_unsealed.
Proof. rewrite /embedD'fds seal_eq //. Qed.

Definition embedDⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (embedD'fds).

Class embedD_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] embedD_type_repr  :: go.TypeReprUnderlying embedDⁱᵐᵖˡ embedD.t;
  #[global] embedD_underlying :: (embedD) <u (embedDⁱᵐᵖˡ);
  #[global] embedD_get_embedC (x : embedD.t) :: ⟦StructFieldGet (embedDⁱᵐᵖˡ) "embedC", #x⟧ ⤳[under] #x.(embedD.embedC');
  #[global] embedD_set_embedC (x : embedD.t) y :: ⟦StructFieldSet (embedDⁱᵐᵖˡ) "embedC", (#x, #y)⟧ ⤳[under] #(x <|embedD.embedC' := y|>);
  #[global] embedD_Bar_unfold :: MethodUnfold (embedD) "Bar" (λ: "$r", MethodResolve embedC "Bar" (StructFieldGet (embedD) "embedC" "$r" ))%V;
  #[global] embedD_Car_unfold :: MethodUnfold (embedD) "Car" (λ: "$r", MethodResolve embedC "Car" (StructFieldGet (embedD) "embedC" "$r" ))%V;
  #[global] embedD_Foo_unfold :: MethodUnfold (embedD) "Foo" (λ: "$r", MethodResolve embedC "Foo" (StructFieldGet (embedD) "embedC" "$r" ))%V;
  #[global] embedD'ptr_Bar_unfold :: MethodUnfold (go.PointerType (embedD)) "Bar" (λ: "$r", MethodResolve (go.PointerType embedC) "Bar" (StructFieldRef embedD "embedC"%go "$r"));
  #[global] embedD'ptr_Car_unfold :: MethodUnfold (go.PointerType (embedD)) "Car" (λ: "$r", MethodResolve (go.PointerType embedC) "Car" (StructFieldRef embedD "embedC"%go "$r"));
  #[global] embedD'ptr_Foo_unfold :: MethodUnfold (go.PointerType (embedD)) "Foo" (λ: "$r", MethodResolve (go.PointerType embedC) "Foo" (StructFieldRef embedD "embedC"%go "$r"));
}.

Module Enc.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  p' : slice.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End Enc.

Definition Enc'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "p"%go (go.SliceType go.byte))
].
Program Definition Enc'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (Enc'fds_unsealed).
Global Instance equals_unfold_Enc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Enc'fds =→ Enc'fds_unsealed.
Proof. rewrite /Enc'fds seal_eq //. Qed.

Definition Encⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (Enc'fds).

Class Enc_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Enc_type_repr  :: go.TypeReprUnderlying Encⁱᵐᵖˡ Enc.t;
  #[global] Enc_underlying :: (Enc) <u (Encⁱᵐᵖˡ);
  #[global] Enc_get_p (x : Enc.t) :: ⟦StructFieldGet (Encⁱᵐᵖˡ) "p", #x⟧ ⤳[under] #x.(Enc.p');
  #[global] Enc_set_p (x : Enc.t) y :: ⟦StructFieldSet (Encⁱᵐᵖˡ) "p", (#x, #y)⟧ ⤳[under] #(x <|Enc.p' := y|>);
  #[global] Enc'ptr_UInt32_unfold :: MethodUnfold (go.PointerType (Enc)) "UInt32" (Enc__UInt32ⁱᵐᵖˡ);
  #[global] Enc'ptr_UInt64_unfold :: MethodUnfold (go.PointerType (Enc)) "UInt64" (Enc__UInt64ⁱᵐᵖˡ);
  #[global] Enc'ptr_consume_unfold :: MethodUnfold (go.PointerType (Enc)) "consume" (Enc__consumeⁱᵐᵖˡ);
}.

Module Dec.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  p' : slice.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End Dec.

Definition Dec'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "p"%go (go.SliceType go.byte))
].
Program Definition Dec'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (Dec'fds_unsealed).
Global Instance equals_unfold_Dec {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Dec'fds =→ Dec'fds_unsealed.
Proof. rewrite /Dec'fds seal_eq //. Qed.

Definition Decⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (Dec'fds).

Class Dec_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Dec_type_repr  :: go.TypeReprUnderlying Decⁱᵐᵖˡ Dec.t;
  #[global] Dec_underlying :: (Dec) <u (Decⁱᵐᵖˡ);
  #[global] Dec_get_p (x : Dec.t) :: ⟦StructFieldGet (Decⁱᵐᵖˡ) "p", #x⟧ ⤳[under] #x.(Dec.p');
  #[global] Dec_set_p (x : Dec.t) y :: ⟦StructFieldSet (Decⁱᵐᵖˡ) "p", (#x, #y)⟧ ⤳[under] #(x <|Dec.p' := y|>);
  #[global] Dec'ptr_UInt32_unfold :: MethodUnfold (go.PointerType (Dec)) "UInt32" (Dec__UInt32ⁱᵐᵖˡ);
  #[global] Dec'ptr_UInt64_unfold :: MethodUnfold (go.PointerType (Dec)) "UInt64" (Dec__UInt64ⁱᵐᵖˡ);
  #[global] Dec'ptr_consume_unfold :: MethodUnfold (go.PointerType (Dec)) "consume" (Dec__consumeⁱᵐᵖˡ);
}.

Module Enum1.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := w64.
End def.
End Enum1.

Definition Enum1ⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.uint64.

Class Enum1_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Enum1_underlying :: (Enum1) <u (Enum1ⁱᵐᵖˡ);
}.

Module Enum2.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := w64.
End def.
End Enum2.

Definition Enum2ⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.int.

Class Enum2_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Enum2_underlying :: (Enum2) <u (Enum2ⁱᵐᵖˡ);
}.

Module Fooer.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := interface.t.
End def.
End Fooer.

Definition Fooerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.InterfaceType [go.MethodElem "Foo"%go (go.Signature [] false [])].

Class Fooer_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Fooer_underlying :: (Fooer) <u (Fooerⁱᵐᵖˡ);
}.

Module concreteFooer.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  a' : w64;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End concreteFooer.

Definition concreteFooer'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "a"%go go.uint64)
].
Program Definition concreteFooer'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (concreteFooer'fds_unsealed).
Global Instance equals_unfold_concreteFooer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : concreteFooer'fds =→ concreteFooer'fds_unsealed.
Proof. rewrite /concreteFooer'fds seal_eq //. Qed.

Definition concreteFooerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (concreteFooer'fds).

Class concreteFooer_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] concreteFooer_type_repr  :: go.TypeReprUnderlying concreteFooerⁱᵐᵖˡ concreteFooer.t;
  #[global] concreteFooer_underlying :: (concreteFooer) <u (concreteFooerⁱᵐᵖˡ);
  #[global] concreteFooer_get_a (x : concreteFooer.t) :: ⟦StructFieldGet (concreteFooerⁱᵐᵖˡ) "a", #x⟧ ⤳[under] #x.(concreteFooer.a');
  #[global] concreteFooer_set_a (x : concreteFooer.t) y :: ⟦StructFieldSet (concreteFooerⁱᵐᵖˡ) "a", (#x, #y)⟧ ⤳[under] #(x <|concreteFooer.a' := y|>);
  #[global] concreteFooer'ptr_Foo_unfold :: MethodUnfold (go.PointerType (concreteFooer)) "Foo" (concreteFooer__Fooⁱᵐᵖˡ);
}.

Module FooerUser.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  f' : unittest.Fooer.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End FooerUser.

Definition FooerUser'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "f"%go Fooer)
].
Program Definition FooerUser'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (FooerUser'fds_unsealed).
Global Instance equals_unfold_FooerUser {ext : ffi_syntax} {go_gctx : GoGlobalContext} : FooerUser'fds =→ FooerUser'fds_unsealed.
Proof. rewrite /FooerUser'fds seal_eq //. Qed.

Definition FooerUserⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (FooerUser'fds).

Class FooerUser_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] FooerUser_type_repr  :: go.TypeReprUnderlying FooerUserⁱᵐᵖˡ FooerUser.t;
  #[global] FooerUser_underlying :: (FooerUser) <u (FooerUserⁱᵐᵖˡ);
  #[global] FooerUser_get_f (x : FooerUser.t) :: ⟦StructFieldGet (FooerUserⁱᵐᵖˡ) "f", #x⟧ ⤳[under] #x.(FooerUser.f');
  #[global] FooerUser_set_f (x : FooerUser.t) y :: ⟦StructFieldSet (FooerUserⁱᵐᵖˡ) "f", (#x, #y)⟧ ⤳[under] #(x <|FooerUser.f' := y|>);
}.

Module PointerInterface.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := interface.t.
End def.
End PointerInterface.

Definition PointerInterfaceⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.InterfaceType [go.MethodElem "B"%go (go.Signature [] false []); go.MethodElem "Foo"%go (go.Signature [] false [])].

Class PointerInterface_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] PointerInterface_underlying :: (PointerInterface) <u (PointerInterfaceⁱᵐᵖˡ);
}.

Module concrete1.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End concrete1.

Definition concrete1'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [

].
Program Definition concrete1'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (concrete1'fds_unsealed).
Global Instance equals_unfold_concrete1 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : concrete1'fds =→ concrete1'fds_unsealed.
Proof. rewrite /concrete1'fds seal_eq //. Qed.

Definition concrete1ⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (concrete1'fds).

Class concrete1_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] concrete1_type_repr  :: go.TypeReprUnderlying concrete1ⁱᵐᵖˡ concrete1.t;
  #[global] concrete1_underlying :: (concrete1) <u (concrete1ⁱᵐᵖˡ);
  #[global] concrete1_Foo_unfold :: MethodUnfold (concrete1) "Foo" (concrete1__Fooⁱᵐᵖˡ);
  #[global] concrete1'ptr_B_unfold :: MethodUnfold (go.PointerType (concrete1)) "B" (concrete1__Bⁱᵐᵖˡ);
  #[global] concrete1'ptr_Foo_unfold :: MethodUnfold (go.PointerType (concrete1)) "Foo" (λ: "$r", MethodResolve (concrete1) "Foo" (![(concrete1)] "$r"));
}.

Module my_u32.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := w32.
End def.
End my_u32.

Definition my_u32ⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.uint32.

Class my_u32_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] my_u32_underlying :: (my_u32) <u (my_u32ⁱᵐᵖˡ);
}.

Module also_u32.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := unittest.my_u32.t.
End def.
End also_u32.

Definition also_u32ⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := my_u32.

Class also_u32_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] also_u32_underlying :: (also_u32) <u (also_u32ⁱᵐᵖˡ);
}.

Module allTheLiterals.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  int' : w64;
  s' : go_string;
  b' : bool;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End allTheLiterals.

Definition allTheLiterals'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "int"%go go.uint64);
  (go.FieldDecl "s"%go go.string);
  (go.FieldDecl "b"%go go.bool)
].
Program Definition allTheLiterals'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (allTheLiterals'fds_unsealed).
Global Instance equals_unfold_allTheLiterals {ext : ffi_syntax} {go_gctx : GoGlobalContext} : allTheLiterals'fds =→ allTheLiterals'fds_unsealed.
Proof. rewrite /allTheLiterals'fds seal_eq //. Qed.

Definition allTheLiteralsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (allTheLiterals'fds).

Class allTheLiterals_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] allTheLiterals_type_repr  :: go.TypeReprUnderlying allTheLiteralsⁱᵐᵖˡ allTheLiterals.t;
  #[global] allTheLiterals_underlying :: (allTheLiterals) <u (allTheLiteralsⁱᵐᵖˡ);
  #[global] allTheLiterals_get_int (x : allTheLiterals.t) :: ⟦StructFieldGet (allTheLiteralsⁱᵐᵖˡ) "int", #x⟧ ⤳[under] #x.(allTheLiterals.int');
  #[global] allTheLiterals_set_int (x : allTheLiterals.t) y :: ⟦StructFieldSet (allTheLiteralsⁱᵐᵖˡ) "int", (#x, #y)⟧ ⤳[under] #(x <|allTheLiterals.int' := y|>);
  #[global] allTheLiterals_get_s (x : allTheLiterals.t) :: ⟦StructFieldGet (allTheLiteralsⁱᵐᵖˡ) "s", #x⟧ ⤳[under] #x.(allTheLiterals.s');
  #[global] allTheLiterals_set_s (x : allTheLiterals.t) y :: ⟦StructFieldSet (allTheLiteralsⁱᵐᵖˡ) "s", (#x, #y)⟧ ⤳[under] #(x <|allTheLiterals.s' := y|>);
  #[global] allTheLiterals_get_b (x : allTheLiterals.t) :: ⟦StructFieldGet (allTheLiteralsⁱᵐᵖˡ) "b", #x⟧ ⤳[under] #x.(allTheLiterals.b');
  #[global] allTheLiterals_set_b (x : allTheLiterals.t) y :: ⟦StructFieldSet (allTheLiteralsⁱᵐᵖˡ) "b", (#x, #y)⟧ ⤳[under] #(x <|allTheLiterals.b' := y|>);
}.

Module hasCondVar.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  cond' : loc;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End hasCondVar.

Definition hasCondVar'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "cond"%go (go.PointerType sync.Cond))
].
Program Definition hasCondVar'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (hasCondVar'fds_unsealed).
Global Instance equals_unfold_hasCondVar {ext : ffi_syntax} {go_gctx : GoGlobalContext} : hasCondVar'fds =→ hasCondVar'fds_unsealed.
Proof. rewrite /hasCondVar'fds seal_eq //. Qed.

Definition hasCondVarⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (hasCondVar'fds).

Class hasCondVar_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] hasCondVar_type_repr  :: go.TypeReprUnderlying hasCondVarⁱᵐᵖˡ hasCondVar.t;
  #[global] hasCondVar_underlying :: (hasCondVar) <u (hasCondVarⁱᵐᵖˡ);
  #[global] hasCondVar_get_cond (x : hasCondVar.t) :: ⟦StructFieldGet (hasCondVarⁱᵐᵖˡ) "cond", #x⟧ ⤳[under] #x.(hasCondVar.cond');
  #[global] hasCondVar_set_cond (x : hasCondVar.t) y :: ⟦StructFieldSet (hasCondVarⁱᵐᵖˡ) "cond", (#x, #y)⟧ ⤳[under] #(x <|hasCondVar.cond' := y|>);
}.

Module IntWrapper.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := w64.
End def.
End IntWrapper.

Definition IntWrapperⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.uint64.

Class IntWrapper_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] IntWrapper_underlying :: (IntWrapper) <u (IntWrapperⁱᵐᵖˡ);
}.

Module MapWrapper.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := loc.
End def.
End MapWrapper.

Definition MapWrapperⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.MapType go.uint64 go.bool.

Class MapWrapper_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] MapWrapper_underlying :: (MapWrapper) <u (MapWrapperⁱᵐᵖˡ);
}.

Module mapElem.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  a' : w64;
  b' : w64;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End mapElem.

Definition mapElem'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "a"%go go.uint64);
  (go.FieldDecl "b"%go go.uint64)
].
Program Definition mapElem'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (mapElem'fds_unsealed).
Global Instance equals_unfold_mapElem {ext : ffi_syntax} {go_gctx : GoGlobalContext} : mapElem'fds =→ mapElem'fds_unsealed.
Proof. rewrite /mapElem'fds seal_eq //. Qed.

Definition mapElemⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (mapElem'fds).

Class mapElem_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] mapElem_type_repr  :: go.TypeReprUnderlying mapElemⁱᵐᵖˡ mapElem.t;
  #[global] mapElem_underlying :: (mapElem) <u (mapElemⁱᵐᵖˡ);
  #[global] mapElem_get_a (x : mapElem.t) :: ⟦StructFieldGet (mapElemⁱᵐᵖˡ) "a", #x⟧ ⤳[under] #x.(mapElem.a');
  #[global] mapElem_set_a (x : mapElem.t) y :: ⟦StructFieldSet (mapElemⁱᵐᵖˡ) "a", (#x, #y)⟧ ⤳[under] #(x <|mapElem.a' := y|>);
  #[global] mapElem_get_b (x : mapElem.t) :: ⟦StructFieldGet (mapElemⁱᵐᵖˡ) "b", #x⟧ ⤳[under] #x.(mapElem.b');
  #[global] mapElem_set_b (x : mapElem.t) y :: ⟦StructFieldSet (mapElemⁱᵐᵖˡ) "b", (#x, #y)⟧ ⤳[under] #(x <|mapElem.b' := y|>);
}.

Module containsPointer.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  s' : loc;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End containsPointer.

Definition containsPointer'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "s"%go (go.PointerType go.uint64))
].
Program Definition containsPointer'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (containsPointer'fds_unsealed).
Global Instance equals_unfold_containsPointer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : containsPointer'fds =→ containsPointer'fds_unsealed.
Proof. rewrite /containsPointer'fds seal_eq //. Qed.

Definition containsPointerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (containsPointer'fds).

Class containsPointer_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] containsPointer_type_repr  :: go.TypeReprUnderlying containsPointerⁱᵐᵖˡ containsPointer.t;
  #[global] containsPointer_underlying :: (containsPointer) <u (containsPointerⁱᵐᵖˡ);
  #[global] containsPointer_get_s (x : containsPointer.t) :: ⟦StructFieldGet (containsPointerⁱᵐᵖˡ) "s", #x⟧ ⤳[under] #x.(containsPointer.s');
  #[global] containsPointer_set_s (x : containsPointer.t) y :: ⟦StructFieldSet (containsPointerⁱᵐᵖˡ) "s", (#x, #y)⟧ ⤳[under] #(x <|containsPointer.s' := y|>);
}.

Module wrapExternalStruct.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  j' : loc;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End wrapExternalStruct.

Definition wrapExternalStruct'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "j"%go (go.PointerType std.JoinHandle))
].
Program Definition wrapExternalStruct'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (wrapExternalStruct'fds_unsealed).
Global Instance equals_unfold_wrapExternalStruct {ext : ffi_syntax} {go_gctx : GoGlobalContext} : wrapExternalStruct'fds =→ wrapExternalStruct'fds_unsealed.
Proof. rewrite /wrapExternalStruct'fds seal_eq //. Qed.

Definition wrapExternalStructⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (wrapExternalStruct'fds).

Class wrapExternalStruct_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] wrapExternalStruct_type_repr  :: go.TypeReprUnderlying wrapExternalStructⁱᵐᵖˡ wrapExternalStruct.t;
  #[global] wrapExternalStruct_underlying :: (wrapExternalStruct) <u (wrapExternalStructⁱᵐᵖˡ);
  #[global] wrapExternalStruct_get_j (x : wrapExternalStruct.t) :: ⟦StructFieldGet (wrapExternalStructⁱᵐᵖˡ) "j", #x⟧ ⤳[under] #x.(wrapExternalStruct.j');
  #[global] wrapExternalStruct_set_j (x : wrapExternalStruct.t) y :: ⟦StructFieldSet (wrapExternalStructⁱᵐᵖˡ) "j", (#x, #y)⟧ ⤳[under] #(x <|wrapExternalStruct.j' := y|>);
  #[global] wrapExternalStruct_join_unfold :: MethodUnfold (wrapExternalStruct) "join" (wrapExternalStruct__joinⁱᵐᵖˡ);
  #[global] wrapExternalStruct'ptr_join_unfold :: MethodUnfold (go.PointerType (wrapExternalStruct)) "join" (λ: "$r", MethodResolve (wrapExternalStruct) "join" (![(wrapExternalStruct)] "$r"));
}.

Module typing.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  proph' : loc;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End typing.

Definition typing'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "proph"%go primitive.ProphId)
].
Program Definition typing'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (typing'fds_unsealed).
Global Instance equals_unfold_typing {ext : ffi_syntax} {go_gctx : GoGlobalContext} : typing'fds =→ typing'fds_unsealed.
Proof. rewrite /typing'fds seal_eq //. Qed.

Definition typingⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (typing'fds).

Class typing_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] typing_type_repr  :: go.TypeReprUnderlying typingⁱᵐᵖˡ typing.t;
  #[global] typing_underlying :: (typing) <u (typingⁱᵐᵖˡ);
  #[global] typing_get_proph (x : typing.t) :: ⟦StructFieldGet (typingⁱᵐᵖˡ) "proph", #x⟧ ⤳[under] #x.(typing.proph');
  #[global] typing_set_proph (x : typing.t) y :: ⟦StructFieldSet (typingⁱᵐᵖˡ) "proph", (#x, #y)⟧ ⤳[under] #(x <|typing.proph' := y|>);
}.

Module composite.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  a' : w64;
  b' : w64;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End composite.

Definition composite'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "a"%go go.uint64);
  (go.FieldDecl "b"%go go.uint64)
].
Program Definition composite'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (composite'fds_unsealed).
Global Instance equals_unfold_composite {ext : ffi_syntax} {go_gctx : GoGlobalContext} : composite'fds =→ composite'fds_unsealed.
Proof. rewrite /composite'fds seal_eq //. Qed.

Definition compositeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (composite'fds).

Class composite_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] composite_type_repr  :: go.TypeReprUnderlying compositeⁱᵐᵖˡ composite.t;
  #[global] composite_underlying :: (composite) <u (compositeⁱᵐᵖˡ);
  #[global] composite_get_a (x : composite.t) :: ⟦StructFieldGet (compositeⁱᵐᵖˡ) "a", #x⟧ ⤳[under] #x.(composite.a');
  #[global] composite_set_a (x : composite.t) y :: ⟦StructFieldSet (compositeⁱᵐᵖˡ) "a", (#x, #y)⟧ ⤳[under] #(x <|composite.a' := y|>);
  #[global] composite_get_b (x : composite.t) :: ⟦StructFieldGet (compositeⁱᵐᵖˡ) "b", #x⟧ ⤳[under] #x.(composite.b');
  #[global] composite_set_b (x : composite.t) y :: ⟦StructFieldSet (compositeⁱᵐᵖˡ) "b", (#x, #y)⟧ ⤳[under] #(x <|composite.b' := y|>);
}.

Module R.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End R.

Definition R'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [

].
Program Definition R'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (R'fds_unsealed).
Global Instance equals_unfold_R {ext : ffi_syntax} {go_gctx : GoGlobalContext} : R'fds =→ R'fds_unsealed.
Proof. rewrite /R'fds seal_eq //. Qed.

Definition Rⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (R'fds).

Class R_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] R_type_repr  :: go.TypeReprUnderlying Rⁱᵐᵖˡ R.t;
  #[global] R_underlying :: (R) <u (Rⁱᵐᵖˡ);
  #[global] R'ptr_recurMethod_unfold :: MethodUnfold (go.PointerType (R)) "recurMethod" (R__recurMethodⁱᵐᵖˡ);
}.

Module Other.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  RecursiveEmbedded' : loc;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End Other.

Definition Other'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.EmbeddedField "RecursiveEmbedded"%go (go.PointerType RecursiveEmbedded))
].
Program Definition Other'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (Other'fds_unsealed).
Global Instance equals_unfold_Other {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Other'fds =→ Other'fds_unsealed.
Proof. rewrite /Other'fds seal_eq //. Qed.

Definition Otherⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (Other'fds).

Class Other_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Other_type_repr  :: go.TypeReprUnderlying Otherⁱᵐᵖˡ Other.t;
  #[global] Other_underlying :: (Other) <u (Otherⁱᵐᵖˡ);
  #[global] Other_get_RecursiveEmbedded (x : Other.t) :: ⟦StructFieldGet (Otherⁱᵐᵖˡ) "RecursiveEmbedded", #x⟧ ⤳[under] #x.(Other.RecursiveEmbedded');
  #[global] Other_set_RecursiveEmbedded (x : Other.t) y :: ⟦StructFieldSet (Otherⁱᵐᵖˡ) "RecursiveEmbedded", (#x, #y)⟧ ⤳[under] #(x <|Other.RecursiveEmbedded' := y|>);
  #[global] Other_recurEmbeddedMethod_unfold :: MethodUnfold (Other) "recurEmbeddedMethod" (λ: "$r", MethodResolve (go.PointerType RecursiveEmbedded) "recurEmbeddedMethod" (StructFieldGet (Other) "RecursiveEmbedded" "$r" ))%V;
  #[global] Other'ptr_recurEmbeddedMethod_unfold :: MethodUnfold (go.PointerType (Other)) "recurEmbeddedMethod" (λ: "$r", MethodResolve (go.PointerType RecursiveEmbedded) "recurEmbeddedMethod" (![go.PointerType RecursiveEmbedded] (StructFieldRef Other "RecursiveEmbedded"%go "$r")));
}.

Module RecursiveEmbedded.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  Other' : unittest.Other.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End RecursiveEmbedded.

Definition RecursiveEmbedded'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.EmbeddedField "Other"%go Other)
].
Program Definition RecursiveEmbedded'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (RecursiveEmbedded'fds_unsealed).
Global Instance equals_unfold_RecursiveEmbedded {ext : ffi_syntax} {go_gctx : GoGlobalContext} : RecursiveEmbedded'fds =→ RecursiveEmbedded'fds_unsealed.
Proof. rewrite /RecursiveEmbedded'fds seal_eq //. Qed.

Definition RecursiveEmbeddedⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (RecursiveEmbedded'fds).

Class RecursiveEmbedded_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] RecursiveEmbedded_type_repr  :: go.TypeReprUnderlying RecursiveEmbeddedⁱᵐᵖˡ RecursiveEmbedded.t;
  #[global] RecursiveEmbedded_underlying :: (RecursiveEmbedded) <u (RecursiveEmbeddedⁱᵐᵖˡ);
  #[global] RecursiveEmbedded_get_Other (x : RecursiveEmbedded.t) :: ⟦StructFieldGet (RecursiveEmbeddedⁱᵐᵖˡ) "Other", #x⟧ ⤳[under] #x.(RecursiveEmbedded.Other');
  #[global] RecursiveEmbedded_set_Other (x : RecursiveEmbedded.t) y :: ⟦StructFieldSet (RecursiveEmbeddedⁱᵐᵖˡ) "Other", (#x, #y)⟧ ⤳[under] #(x <|RecursiveEmbedded.Other' := y|>);
  #[global] RecursiveEmbedded'ptr_recurEmbeddedMethod_unfold :: MethodUnfold (go.PointerType (RecursiveEmbedded)) "recurEmbeddedMethod" (RecursiveEmbedded__recurEmbeddedMethodⁱᵐᵖˡ);
}.

Module Block.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  Value' : w64;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End Block.

Definition Block'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "Value"%go go.uint64)
].
Program Definition Block'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (Block'fds_unsealed).
Global Instance equals_unfold_Block {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Block'fds =→ Block'fds_unsealed.
Proof. rewrite /Block'fds seal_eq //. Qed.

Definition Blockⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (Block'fds).

Class Block_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Block_type_repr  :: go.TypeReprUnderlying Blockⁱᵐᵖˡ Block.t;
  #[global] Block_underlying :: (Block) <u (Blockⁱᵐᵖˡ);
  #[global] Block_get_Value (x : Block.t) :: ⟦StructFieldGet (Blockⁱᵐᵖˡ) "Value", #x⟧ ⤳[under] #x.(Block.Value');
  #[global] Block_set_Value (x : Block.t) y :: ⟦StructFieldSet (Blockⁱᵐᵖˡ) "Value", (#x, #y)⟧ ⤳[under] #(x <|Block.Value' := y|>);
}.

Module SliceAlias.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := slice.t.
End def.
End SliceAlias.

Definition SliceAliasⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.SliceType go.bool.

Class SliceAlias_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] SliceAlias_underlying :: (SliceAlias) <u (SliceAliasⁱᵐᵖˡ);
}.

Module thing.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  x' : w64;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End thing.

Definition thing'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "x"%go go.uint64)
].
Program Definition thing'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (thing'fds_unsealed).
Global Instance equals_unfold_thing {ext : ffi_syntax} {go_gctx : GoGlobalContext} : thing'fds =→ thing'fds_unsealed.
Proof. rewrite /thing'fds seal_eq //. Qed.

Definition thingⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (thing'fds).

Class thing_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] thing_type_repr  :: go.TypeReprUnderlying thingⁱᵐᵖˡ thing.t;
  #[global] thing_underlying :: (thing) <u (thingⁱᵐᵖˡ);
  #[global] thing_get_x (x : thing.t) :: ⟦StructFieldGet (thingⁱᵐᵖˡ) "x", #x⟧ ⤳[under] #x.(thing.x');
  #[global] thing_set_x (x : thing.t) y :: ⟦StructFieldSet (thingⁱᵐᵖˡ) "x", (#x, #y)⟧ ⤳[under] #(x <|thing.x' := y|>);
}.

Module sliceOfThings.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  things' : slice.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End sliceOfThings.

Definition sliceOfThings'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "things"%go (go.SliceType thing))
].
Program Definition sliceOfThings'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (sliceOfThings'fds_unsealed).
Global Instance equals_unfold_sliceOfThings {ext : ffi_syntax} {go_gctx : GoGlobalContext} : sliceOfThings'fds =→ sliceOfThings'fds_unsealed.
Proof. rewrite /sliceOfThings'fds seal_eq //. Qed.

Definition sliceOfThingsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (sliceOfThings'fds).

Class sliceOfThings_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] sliceOfThings_type_repr  :: go.TypeReprUnderlying sliceOfThingsⁱᵐᵖˡ sliceOfThings.t;
  #[global] sliceOfThings_underlying :: (sliceOfThings) <u (sliceOfThingsⁱᵐᵖˡ);
  #[global] sliceOfThings_get_things (x : sliceOfThings.t) :: ⟦StructFieldGet (sliceOfThingsⁱᵐᵖˡ) "things", #x⟧ ⤳[under] #x.(sliceOfThings.things');
  #[global] sliceOfThings_set_things (x : sliceOfThings.t) y :: ⟦StructFieldSet (sliceOfThingsⁱᵐᵖˡ) "things", (#x, #y)⟧ ⤳[under] #(x <|sliceOfThings.things' := y|>);
  #[global] sliceOfThings_getThingRef_unfold :: MethodUnfold (sliceOfThings) "getThingRef" (sliceOfThings__getThingRefⁱᵐᵖˡ);
  #[global] sliceOfThings'ptr_getThingRef_unfold :: MethodUnfold (go.PointerType (sliceOfThings)) "getThingRef" (λ: "$r", MethodResolve (sliceOfThings) "getThingRef" (![(sliceOfThings)] "$r"));
}.

Module Point.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  x' : w64;
  y' : w64;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End Point.

Definition Point'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "x"%go go.uint64);
  (go.FieldDecl "y"%go go.uint64)
].
Program Definition Point'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (Point'fds_unsealed).
Global Instance equals_unfold_Point {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Point'fds =→ Point'fds_unsealed.
Proof. rewrite /Point'fds seal_eq //. Qed.

Definition Pointⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (Point'fds).

Class Point_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Point_type_repr  :: go.TypeReprUnderlying Pointⁱᵐᵖˡ Point.t;
  #[global] Point_underlying :: (Point) <u (Pointⁱᵐᵖˡ);
  #[global] Point_get_x (x : Point.t) :: ⟦StructFieldGet (Pointⁱᵐᵖˡ) "x", #x⟧ ⤳[under] #x.(Point.x');
  #[global] Point_set_x (x : Point.t) y :: ⟦StructFieldSet (Pointⁱᵐᵖˡ) "x", (#x, #y)⟧ ⤳[under] #(x <|Point.x' := y|>);
  #[global] Point_get_y (x : Point.t) :: ⟦StructFieldGet (Pointⁱᵐᵖˡ) "y", #x⟧ ⤳[under] #x.(Point.y');
  #[global] Point_set_y (x : Point.t) y :: ⟦StructFieldSet (Pointⁱᵐᵖˡ) "y", (#x, #y)⟧ ⤳[under] #(x <|Point.y' := y|>);
  #[global] Point_Add_unfold :: MethodUnfold (Point) "Add" (Point__Addⁱᵐᵖˡ);
  #[global] Point_GetField_unfold :: MethodUnfold (Point) "GetField" (Point__GetFieldⁱᵐᵖˡ);
  #[global] Point_IgnoreReceiver_unfold :: MethodUnfold (Point) "IgnoreReceiver" (Point__IgnoreReceiverⁱᵐᵖˡ);
  #[global] Point'ptr_Add_unfold :: MethodUnfold (go.PointerType (Point)) "Add" (λ: "$r", MethodResolve (Point) "Add" (![(Point)] "$r"));
  #[global] Point'ptr_GetField_unfold :: MethodUnfold (go.PointerType (Point)) "GetField" (λ: "$r", MethodResolve (Point) "GetField" (![(Point)] "$r"));
  #[global] Point'ptr_IgnoreReceiver_unfold :: MethodUnfold (go.PointerType (Point)) "IgnoreReceiver" (λ: "$r", MethodResolve (Point) "IgnoreReceiver" (![(Point)] "$r"));
}.

Module TwoInts.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  x' : w64;
  y' : w64;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End TwoInts.

Definition TwoInts'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "x"%go go.uint64);
  (go.FieldDecl "y"%go go.uint64)
].
Program Definition TwoInts'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (TwoInts'fds_unsealed).
Global Instance equals_unfold_TwoInts {ext : ffi_syntax} {go_gctx : GoGlobalContext} : TwoInts'fds =→ TwoInts'fds_unsealed.
Proof. rewrite /TwoInts'fds seal_eq //. Qed.

Definition TwoIntsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (TwoInts'fds).

Class TwoInts_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] TwoInts_type_repr  :: go.TypeReprUnderlying TwoIntsⁱᵐᵖˡ TwoInts.t;
  #[global] TwoInts_underlying :: (TwoInts) <u (TwoIntsⁱᵐᵖˡ);
  #[global] TwoInts_get_x (x : TwoInts.t) :: ⟦StructFieldGet (TwoIntsⁱᵐᵖˡ) "x", #x⟧ ⤳[under] #x.(TwoInts.x');
  #[global] TwoInts_set_x (x : TwoInts.t) y :: ⟦StructFieldSet (TwoIntsⁱᵐᵖˡ) "x", (#x, #y)⟧ ⤳[under] #(x <|TwoInts.x' := y|>);
  #[global] TwoInts_get_y (x : TwoInts.t) :: ⟦StructFieldGet (TwoIntsⁱᵐᵖˡ) "y", #x⟧ ⤳[under] #x.(TwoInts.y');
  #[global] TwoInts_set_y (x : TwoInts.t) y :: ⟦StructFieldSet (TwoIntsⁱᵐᵖˡ) "y", (#x, #y)⟧ ⤳[under] #(x <|TwoInts.y' := y|>);
}.

Module S.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  a' : w64;
  b' : unittest.TwoInts.t;
  c' : bool;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End S.

Definition S'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "a"%go go.uint64);
  (go.FieldDecl "b"%go TwoInts);
  (go.FieldDecl "c"%go go.bool)
].
Program Definition S'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (S'fds_unsealed).
Global Instance equals_unfold_S {ext : ffi_syntax} {go_gctx : GoGlobalContext} : S'fds =→ S'fds_unsealed.
Proof. rewrite /S'fds seal_eq //. Qed.

Definition Sⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (S'fds).

Class S_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] S_type_repr  :: go.TypeReprUnderlying Sⁱᵐᵖˡ S.t;
  #[global] S_underlying :: (S) <u (Sⁱᵐᵖˡ);
  #[global] S_get_a (x : S.t) :: ⟦StructFieldGet (Sⁱᵐᵖˡ) "a", #x⟧ ⤳[under] #x.(S.a');
  #[global] S_set_a (x : S.t) y :: ⟦StructFieldSet (Sⁱᵐᵖˡ) "a", (#x, #y)⟧ ⤳[under] #(x <|S.a' := y|>);
  #[global] S_get_b (x : S.t) :: ⟦StructFieldGet (Sⁱᵐᵖˡ) "b", #x⟧ ⤳[under] #x.(S.b');
  #[global] S_set_b (x : S.t) y :: ⟦StructFieldSet (Sⁱᵐᵖˡ) "b", (#x, #y)⟧ ⤳[under] #(x <|S.b' := y|>);
  #[global] S_get_c (x : S.t) :: ⟦StructFieldGet (Sⁱᵐᵖˡ) "c", #x⟧ ⤳[under] #x.(S.c');
  #[global] S_set_c (x : S.t) y :: ⟦StructFieldSet (Sⁱᵐᵖˡ) "c", (#x, #y)⟧ ⤳[under] #(x <|S.c' := y|>);
  #[global] S_readBVal_unfold :: MethodUnfold (S) "readBVal" (S__readBValⁱᵐᵖˡ);
  #[global] S'ptr_negateC_unfold :: MethodUnfold (go.PointerType (S)) "negateC" (S__negateCⁱᵐᵖˡ);
  #[global] S'ptr_readA_unfold :: MethodUnfold (go.PointerType (S)) "readA" (S__readAⁱᵐᵖˡ);
  #[global] S'ptr_readB_unfold :: MethodUnfold (go.PointerType (S)) "readB" (S__readBⁱᵐᵖˡ);
  #[global] S'ptr_readBVal_unfold :: MethodUnfold (go.PointerType (S)) "readBVal" (λ: "$r", MethodResolve (S) "readBVal" (![(S)] "$r"));
  #[global] S'ptr_refC_unfold :: MethodUnfold (go.PointerType (S)) "refC" (S__refCⁱᵐᵖˡ);
  #[global] S'ptr_writeB_unfold :: MethodUnfold (go.PointerType (S)) "writeB" (S__writeBⁱᵐᵖˡ);
}.

Module B.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  a' : slice.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End B.

Definition B'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "a"%go (go.SliceType A))
].
Program Definition B'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (B'fds_unsealed).
Global Instance equals_unfold_B {ext : ffi_syntax} {go_gctx : GoGlobalContext} : B'fds =→ B'fds_unsealed.
Proof. rewrite /B'fds seal_eq //. Qed.

Definition Bⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (B'fds).

Class B_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] B_type_repr  :: go.TypeReprUnderlying Bⁱᵐᵖˡ B.t;
  #[global] B_underlying :: (B) <u (Bⁱᵐᵖˡ);
  #[global] B_get_a (x : B.t) :: ⟦StructFieldGet (Bⁱᵐᵖˡ) "a", #x⟧ ⤳[under] #x.(B.a');
  #[global] B_set_a (x : B.t) y :: ⟦StructFieldSet (Bⁱᵐᵖˡ) "a", (#x, #y)⟧ ⤳[under] #(x <|B.a' := y|>);
}.

Module A.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End A.

Definition A'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [

].
Program Definition A'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (A'fds_unsealed).
Global Instance equals_unfold_A {ext : ffi_syntax} {go_gctx : GoGlobalContext} : A'fds =→ A'fds_unsealed.
Proof. rewrite /A'fds seal_eq //. Qed.

Definition Aⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (A'fds).

Class A_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] A_type_repr  :: go.TypeReprUnderlying Aⁱᵐᵖˡ A.t;
  #[global] A_underlying :: (A) <u (Aⁱᵐᵖˡ);
}.

Module Timestamp.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := w64.
End def.
End Timestamp.

Definition Timestampⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.uint64.

Class Timestamp_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Timestamp_underlying :: (Timestamp) <u (Timestampⁱᵐᵖˡ);
}.

Module UseTypeAbbrev.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := w64.
End def.
End UseTypeAbbrev.

Definition UseTypeAbbrevⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := my_u64.

Class UseTypeAbbrev_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] UseTypeAbbrev_underlying :: (UseTypeAbbrev) <u (UseTypeAbbrevⁱᵐᵖˡ);
}.

Module UseNamedType.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := unittest.Timestamp.t.
End def.
End UseNamedType.

Definition UseNamedTypeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := Timestamp.

Class UseNamedType_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] UseNamedType_underlying :: (UseNamedType) <u (UseNamedTypeⁱᵐᵖˡ);
}.

Class Assumptions `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Foo_instance :: Foo_Assumptions;
  #[global] importantStruct_instance :: importantStruct_Assumptions;
  #[global] stringWrapper_instance :: stringWrapper_Assumptions;
  #[global] Uint32_instance :: Uint32_Assumptions;
  #[global] numWrapper_instance :: numWrapper_Assumptions;
  #[global] withInterface_instance :: withInterface_Assumptions;
  #[global] diskWrapper_instance :: diskWrapper_Assumptions;
  #[global] embedA_instance :: embedA_Assumptions;
  #[global] embedB_instance :: embedB_Assumptions;
  #[global] embedC_instance :: embedC_Assumptions;
  #[global] embedD_instance :: embedD_Assumptions;
  #[global] Enc_instance :: Enc_Assumptions;
  #[global] Dec_instance :: Dec_Assumptions;
  #[global] Enum1_instance :: Enum1_Assumptions;
  #[global] Enum2_instance :: Enum2_Assumptions;
  #[global] Fooer_instance :: Fooer_Assumptions;
  #[global] concreteFooer_instance :: concreteFooer_Assumptions;
  #[global] FooerUser_instance :: FooerUser_Assumptions;
  #[global] PointerInterface_instance :: PointerInterface_Assumptions;
  #[global] concrete1_instance :: concrete1_Assumptions;
  #[global] my_u32_instance :: my_u32_Assumptions;
  #[global] also_u32_instance :: also_u32_Assumptions;
  #[global] allTheLiterals_instance :: allTheLiterals_Assumptions;
  #[global] hasCondVar_instance :: hasCondVar_Assumptions;
  #[global] IntWrapper_instance :: IntWrapper_Assumptions;
  #[global] MapWrapper_instance :: MapWrapper_Assumptions;
  #[global] mapElem_instance :: mapElem_Assumptions;
  #[global] containsPointer_instance :: containsPointer_Assumptions;
  #[global] wrapExternalStruct_instance :: wrapExternalStruct_Assumptions;
  #[global] typing_instance :: typing_Assumptions;
  #[global] composite_instance :: composite_Assumptions;
  #[global] R_instance :: R_Assumptions;
  #[global] Other_instance :: Other_Assumptions;
  #[global] RecursiveEmbedded_instance :: RecursiveEmbedded_Assumptions;
  #[global] Block_instance :: Block_Assumptions;
  #[global] SliceAlias_instance :: SliceAlias_Assumptions;
  #[global] thing_instance :: thing_Assumptions;
  #[global] sliceOfThings_instance :: sliceOfThings_Assumptions;
  #[global] Point_instance :: Point_Assumptions;
  #[global] TwoInts_instance :: TwoInts_Assumptions;
  #[global] S_instance :: S_Assumptions;
  #[global] B_instance :: B_Assumptions;
  #[global] A_instance :: A_Assumptions;
  #[global] Timestamp_instance :: Timestamp_Assumptions;
  #[global] UseTypeAbbrev_instance :: UseTypeAbbrev_Assumptions;
  #[global] UseNamedType_instance :: UseNamedType_Assumptions;
  #[global] takesArray_unfold :: FuncUnfold takesArray [] (takesArrayⁱᵐᵖˡ);
  #[global] takesPtr_unfold :: FuncUnfold takesPtr [] (takesPtrⁱᵐᵖˡ);
  #[global] usesArrayElemRef_unfold :: FuncUnfold usesArrayElemRef [] (usesArrayElemRefⁱᵐᵖˡ);
  #[global] sum_unfold :: FuncUnfold sum [] (sumⁱᵐᵖˡ);
  #[global] arrayToSlice_unfold :: FuncUnfold arrayToSlice [] (arrayToSliceⁱᵐᵖˡ);
  #[global] arrayLiteralKeyed_unfold :: FuncUnfold arrayLiteralKeyed [] (arrayLiteralKeyedⁱᵐᵖˡ);
  #[global] chanBasic_unfold :: FuncUnfold chanBasic [] (chanBasicⁱᵐᵖˡ);
  #[global] f_unfold :: FuncUnfold f [] (fⁱᵐᵖˡ);
  #[global] chanSelect_unfold :: FuncUnfold chanSelect [] (chanSelectⁱᵐᵖˡ);
  #[global] chanDirectional_unfold :: FuncUnfold chanDirectional [] (chanDirectionalⁱᵐᵖˡ);
  #[global] chanRange_unfold :: FuncUnfold chanRange [] (chanRangeⁱᵐᵖˡ);
  #[global] doSubtleThings_unfold :: FuncUnfold doSubtleThings [] (doSubtleThingsⁱᵐᵖˡ);
  #[global] hasStartComment_unfold :: FuncUnfold hasStartComment [] (hasStartCommentⁱᵐᵖˡ);
  #[global] hasEndComment_unfold :: FuncUnfold hasEndComment [] (hasEndCommentⁱᵐᵖˡ);
  #[global] condvarWrapping_unfold :: FuncUnfold condvarWrapping [] (condvarWrappingⁱᵐᵖˡ);
  #[global] useUntypedInt_unfold :: FuncUnfold useUntypedInt [] (useUntypedIntⁱᵐᵖˡ);
  #[global] useUntypedString_unfold :: FuncUnfold useUntypedString [] (useUntypedStringⁱᵐᵖˡ);
  #[global] conditionalReturn_unfold :: FuncUnfold conditionalReturn [] (conditionalReturnⁱᵐᵖˡ);
  #[global] alwaysReturn_unfold :: FuncUnfold alwaysReturn [] (alwaysReturnⁱᵐᵖˡ);
  #[global] alwaysReturnInNestedBranches_unfold :: FuncUnfold alwaysReturnInNestedBranches [] (alwaysReturnInNestedBranchesⁱᵐᵖˡ);
  #[global] earlyReturn_unfold :: FuncUnfold earlyReturn [] (earlyReturnⁱᵐᵖˡ);
  #[global] conditionalAssign_unfold :: FuncUnfold conditionalAssign [] (conditionalAssignⁱᵐᵖˡ);
  #[global] elseIf_unfold :: FuncUnfold elseIf [] (elseIfⁱᵐᵖˡ);
  #[global] ifStmtInitialization_unfold :: FuncUnfold ifStmtInitialization [] (ifStmtInitializationⁱᵐᵖˡ);
  #[global] typedLiteral_unfold :: FuncUnfold typedLiteral [] (typedLiteralⁱᵐᵖˡ);
  #[global] literalCast_unfold :: FuncUnfold literalCast [] (literalCastⁱᵐᵖˡ);
  #[global] castInt_unfold :: FuncUnfold castInt [] (castIntⁱᵐᵖˡ);
  #[global] stringToByteSlice_unfold :: FuncUnfold stringToByteSlice [] (stringToByteSliceⁱᵐᵖˡ);
  #[global] byteSliceToString_unfold :: FuncUnfold byteSliceToString [] (byteSliceToStringⁱᵐᵖˡ);
  #[global] stringToStringWrapper_unfold :: FuncUnfold stringToStringWrapper [] (stringToStringWrapperⁱᵐᵖˡ);
  #[global] stringWrapperToString_unfold :: FuncUnfold stringWrapperToString [] (stringWrapperToStringⁱᵐᵖˡ);
  #[global] testU32NewtypeLen_unfold :: FuncUnfold testU32NewtypeLen [] (testU32NewtypeLenⁱᵐᵖˡ);
  #[global] testNumWrapper_unfold :: FuncUnfold testNumWrapper [] (testNumWrapperⁱᵐᵖˡ);
  #[global] testConversionLiteral_unfold :: FuncUnfold testConversionLiteral [] (testConversionLiteralⁱᵐᵖˡ);
  #[global] testCopySimple_unfold :: FuncUnfold testCopySimple [] (testCopySimpleⁱᵐᵖˡ);
  #[global] testCopyDifferentLengths_unfold :: FuncUnfold testCopyDifferentLengths [] (testCopyDifferentLengthsⁱᵐᵖˡ);
  #[global] atomicCreateStub_unfold :: FuncUnfold atomicCreateStub [] (atomicCreateStubⁱᵐᵖˡ);
  #[global] useSlice_unfold :: FuncUnfold useSlice [] (useSliceⁱᵐᵖˡ);
  #[global] useSliceIndexing_unfold :: FuncUnfold useSliceIndexing [] (useSliceIndexingⁱᵐᵖˡ);
  #[global] useMap_unfold :: FuncUnfold useMap [] (useMapⁱᵐᵖˡ);
  #[global] usePtr_unfold :: FuncUnfold usePtr [] (usePtrⁱᵐᵖˡ);
  #[global] iterMapKeysAndValues_unfold :: FuncUnfold iterMapKeysAndValues [] (iterMapKeysAndValuesⁱᵐᵖˡ);
  #[global] iterMapKeys_unfold :: FuncUnfold iterMapKeys [] (iterMapKeysⁱᵐᵖˡ);
  #[global] getRandom_unfold :: FuncUnfold getRandom [] (getRandomⁱᵐᵖˡ);
  #[global] diskArgument_unfold :: FuncUnfold diskArgument [] (diskArgumentⁱᵐᵖˡ);
  #[global] returnEmbedVal_unfold :: FuncUnfold returnEmbedVal [] (returnEmbedValⁱᵐᵖˡ);
  #[global] returnEmbedValWithPointer_unfold :: FuncUnfold returnEmbedValWithPointer [] (returnEmbedValWithPointerⁱᵐᵖˡ);
  #[global] useEmbeddedField_unfold :: FuncUnfold useEmbeddedField [] (useEmbeddedFieldⁱᵐᵖˡ);
  #[global] useEmbeddedValField_unfold :: FuncUnfold useEmbeddedValField [] (useEmbeddedValFieldⁱᵐᵖˡ);
  #[global] useEmbeddedMethod_unfold :: FuncUnfold useEmbeddedMethod [] (useEmbeddedMethodⁱᵐᵖˡ);
  #[global] useEmbeddedMethod2_unfold :: FuncUnfold useEmbeddedMethod2 [] (useEmbeddedMethod2ⁱᵐᵖˡ);
  #[global] empty_unfold :: FuncUnfold empty [] (emptyⁱᵐᵖˡ);
  #[global] emptyReturn_unfold :: FuncUnfold emptyReturn [] (emptyReturnⁱᵐᵖˡ);
  #[global] unnamedParams_unfold :: FuncUnfold unnamedParams [] (unnamedParamsⁱᵐᵖˡ);
  #[global] anonymousParam_unfold :: FuncUnfold anonymousParam [] (anonymousParamⁱᵐᵖˡ);
  #[global] useFloat_unfold :: FuncUnfold useFloat [] (useFloatⁱᵐᵖˡ);
  #[global] compareIntFloat_unfold :: FuncUnfold compareIntFloat [] (compareIntFloatⁱᵐᵖˡ);
  #[global] compareFloatInt_unfold :: FuncUnfold compareFloatInt [] (compareFloatIntⁱᵐᵖˡ);
  #[global] forRangeNoBinding_unfold :: FuncUnfold forRangeNoBinding [] (forRangeNoBindingⁱᵐᵖˡ);
  #[global] forRangeOldVars_unfold :: FuncUnfold forRangeOldVars [] (forRangeOldVarsⁱᵐᵖˡ);
  #[global] maybeConvert_unfold A :: FuncUnfold maybeConvert [A] (maybeConvertⁱᵐᵖˡ A);
  #[global] maybeConvertToInterface_unfold A :: FuncUnfold maybeConvertToInterface [A] (maybeConvertToInterfaceⁱᵐᵖˡ A);
  #[global] maybeConvertToString_unfold A :: FuncUnfold maybeConvertToString [A] (maybeConvertToStringⁱᵐᵖˡ A);
  #[global] maybeConvertFromString_unfold A :: FuncUnfold maybeConvertFromString [A] (maybeConvertFromStringⁱᵐᵖˡ A);
  #[global] assert_unfold :: FuncUnfold assert [] (assertⁱᵐᵖˡ);
  #[global] nilConvert_unfold A :: FuncUnfold nilConvert [A] (nilConvertⁱᵐᵖˡ A);
  #[global] genericConversions_unfold :: FuncUnfold genericConversions [] (genericConversionsⁱᵐᵖˡ);
  #[global] foo_unfold :: FuncUnfold foo [] (fooⁱᵐᵖˡ);
  #[global] other_unfold :: FuncUnfold other [] (otherⁱᵐᵖˡ);
  #[global] bar_unfold :: FuncUnfold bar [] (barⁱᵐᵖˡ);
  #[global] useUntypedRune_unfold :: FuncUnfold useUntypedRune [] (useUntypedRuneⁱᵐᵖˡ);
  #[global] TakesFunctionType_unfold :: FuncUnfold TakesFunctionType [] (TakesFunctionTypeⁱᵐᵖˡ);
  #[global] FuncVar_unfold :: FuncUnfold FuncVar [] (FuncVarⁱᵐᵖˡ);
  #[global] fooConsumer_unfold :: FuncUnfold fooConsumer [] (fooConsumerⁱᵐᵖˡ);
  #[global] testAssignConcreteToInterface_unfold :: FuncUnfold testAssignConcreteToInterface [] (testAssignConcreteToInterfaceⁱᵐᵖˡ);
  #[global] testPassConcreteToInterfaceArg_unfold :: FuncUnfold testPassConcreteToInterfaceArg [] (testPassConcreteToInterfaceArgⁱᵐᵖˡ);
  #[global] testPassConcreteToInterfaceArgSpecial_unfold :: FuncUnfold testPassConcreteToInterfaceArgSpecial [] (testPassConcreteToInterfaceArgSpecialⁱᵐᵖˡ);
  #[global] takesVarArgsInterface_unfold :: FuncUnfold takesVarArgsInterface [] (takesVarArgsInterfaceⁱᵐᵖˡ);
  #[global] test_unfold :: FuncUnfold test [] (testⁱᵐᵖˡ);
  #[global] returnConcrete_unfold :: FuncUnfold returnConcrete [] (returnConcreteⁱᵐᵖˡ);
  #[global] testMultiReturn_unfold :: FuncUnfold testMultiReturn [] (testMultiReturnⁱᵐᵖˡ);
  #[global] testReturnStatment_unfold :: FuncUnfold testReturnStatment [] (testReturnStatmentⁱᵐᵖˡ);
  #[global] testConversionInEq_unfold :: FuncUnfold testConversionInEq [] (testConversionInEqⁱᵐᵖˡ);
  #[global] takeMultiple_unfold :: FuncUnfold takeMultiple [] (takeMultipleⁱᵐᵖˡ);
  #[global] giveMultiple_unfold :: FuncUnfold giveMultiple [] (giveMultipleⁱᵐᵖˡ);
  #[global] testConversionInMultipleReturnPassThrough_unfold :: FuncUnfold testConversionInMultipleReturnPassThrough [] (testConversionInMultipleReturnPassThroughⁱᵐᵖˡ);
  #[global] testConversionInMultiplePassThrough_unfold :: FuncUnfold testConversionInMultiplePassThrough [] (testConversionInMultiplePassThroughⁱᵐᵖˡ);
  #[global] testPtrMset_unfold :: FuncUnfold testPtrMset [] (testPtrMsetⁱᵐᵖˡ);
  #[global] pointerAny_unfold :: FuncUnfold pointerAny [] (pointerAnyⁱᵐᵖˡ);
  #[global] useInts_unfold :: FuncUnfold useInts [] (useIntsⁱᵐᵖˡ);
  #[global] signedMidpoint_unfold :: FuncUnfold signedMidpoint [] (signedMidpointⁱᵐᵖˡ);
  #[global] normalLiterals_unfold :: FuncUnfold normalLiterals [] (normalLiteralsⁱᵐᵖˡ);
  #[global] outOfOrderLiteral_unfold :: FuncUnfold outOfOrderLiteral [] (outOfOrderLiteralⁱᵐᵖˡ);
  #[global] specialLiterals_unfold :: FuncUnfold specialLiterals [] (specialLiteralsⁱᵐᵖˡ);
  #[global] oddLiterals_unfold :: FuncUnfold oddLiterals [] (oddLiteralsⁱᵐᵖˡ);
  #[global] unKeyedLiteral_unfold :: FuncUnfold unKeyedLiteral [] (unKeyedLiteralⁱᵐᵖˡ);
  #[global] useLocks_unfold :: FuncUnfold useLocks [] (useLocksⁱᵐᵖˡ);
  #[global] useCondVar_unfold :: FuncUnfold useCondVar [] (useCondVarⁱᵐᵖˡ);
  #[global] ToBeDebugged_unfold :: FuncUnfold ToBeDebugged [] (ToBeDebuggedⁱᵐᵖˡ);
  #[global] DoNothing_unfold :: FuncUnfold DoNothing [] (DoNothingⁱᵐᵖˡ);
  #[global] DoSomething_unfold :: FuncUnfold DoSomething [] (DoSomethingⁱᵐᵖˡ);
  #[global] standardForLoop_unfold :: FuncUnfold standardForLoop [] (standardForLoopⁱᵐᵖˡ);
  #[global] conditionalInLoop_unfold :: FuncUnfold conditionalInLoop [] (conditionalInLoopⁱᵐᵖˡ);
  #[global] conditionalInLoopElse_unfold :: FuncUnfold conditionalInLoopElse [] (conditionalInLoopElseⁱᵐᵖˡ);
  #[global] nestedConditionalInLoopImplicitContinue_unfold :: FuncUnfold nestedConditionalInLoopImplicitContinue [] (nestedConditionalInLoopImplicitContinueⁱᵐᵖˡ);
  #[global] ImplicitLoopContinue_unfold :: FuncUnfold ImplicitLoopContinue [] (ImplicitLoopContinueⁱᵐᵖˡ);
  #[global] ImplicitLoopContinue2_unfold :: FuncUnfold ImplicitLoopContinue2 [] (ImplicitLoopContinue2ⁱᵐᵖˡ);
  #[global] ImplicitLoopContinueAfterIfBreak_unfold :: FuncUnfold ImplicitLoopContinueAfterIfBreak [] (ImplicitLoopContinueAfterIfBreakⁱᵐᵖˡ);
  #[global] nestedLoops_unfold :: FuncUnfold nestedLoops [] (nestedLoopsⁱᵐᵖˡ);
  #[global] nestedGoStyleLoops_unfold :: FuncUnfold nestedGoStyleLoops [] (nestedGoStyleLoopsⁱᵐᵖˡ);
  #[global] sumSlice_unfold :: FuncUnfold sumSlice [] (sumSliceⁱᵐᵖˡ);
  #[global] intSliceLoop_unfold :: FuncUnfold intSliceLoop [] (intSliceLoopⁱᵐᵖˡ);
  #[global] breakFromLoop_unfold :: FuncUnfold breakFromLoop [] (breakFromLoopⁱᵐᵖˡ);
  #[global] IterateMapKeys_unfold :: FuncUnfold IterateMapKeys [] (IterateMapKeysⁱᵐᵖˡ);
  #[global] MapSize_unfold :: FuncUnfold MapSize [] (MapSizeⁱᵐᵖˡ);
  #[global] MapTypeAliases_unfold :: FuncUnfold MapTypeAliases [] (MapTypeAliasesⁱᵐᵖˡ);
  #[global] StringMap_unfold :: FuncUnfold StringMap [] (StringMapⁱᵐᵖˡ);
  #[global] mapUpdateField_unfold :: FuncUnfold mapUpdateField [] (mapUpdateFieldⁱᵐᵖˡ);
  #[global] mapGetCall_unfold :: FuncUnfold mapGetCall [] (mapGetCallⁱᵐᵖˡ);
  #[global] mapLiteralTest_unfold :: FuncUnfold mapLiteralTest [] (mapLiteralTestⁱᵐᵖˡ);
  #[global] mapClearTest_unfold :: FuncUnfold mapClearTest [] (mapClearTestⁱᵐᵖˡ);
  #[global] mapLookupConversion_unfold :: FuncUnfold mapLookupConversion [] (mapLookupConversionⁱᵐᵖˡ);
  #[global] returnTwo_unfold :: FuncUnfold returnTwo [] (returnTwoⁱᵐᵖˡ);
  #[global] returnTwoWrapper_unfold :: FuncUnfold returnTwoWrapper [] (returnTwoWrapperⁱᵐᵖˡ);
  #[global] multipleVar_unfold :: FuncUnfold multipleVar [] (multipleVarⁱᵐᵖˡ);
  #[global] multiplePassThrough_unfold :: FuncUnfold multiplePassThrough [] (multiplePassThroughⁱᵐᵖˡ);
  #[global] multipleReturnPassThrough_unfold :: FuncUnfold multipleReturnPassThrough [] (multipleReturnPassThroughⁱᵐᵖˡ);
  #[global] AssignNilSlice_unfold :: FuncUnfold AssignNilSlice [] (AssignNilSliceⁱᵐᵖˡ);
  #[global] AssignNilPointer_unfold :: FuncUnfold AssignNilPointer [] (AssignNilPointerⁱᵐᵖˡ);
  #[global] CompareSliceToNil_unfold :: FuncUnfold CompareSliceToNil [] (CompareSliceToNilⁱᵐᵖˡ);
  #[global] ComparePointerToNil_unfold :: FuncUnfold ComparePointerToNil [] (ComparePointerToNilⁱᵐᵖˡ);
  #[global] useNilField_unfold :: FuncUnfold useNilField [] (useNilFieldⁱᵐᵖˡ);
  #[global] LogicalOperators_unfold :: FuncUnfold LogicalOperators [] (LogicalOperatorsⁱᵐᵖˡ);
  #[global] LogicalAndEqualityOperators_unfold :: FuncUnfold LogicalAndEqualityOperators [] (LogicalAndEqualityOperatorsⁱᵐᵖˡ);
  #[global] ArithmeticShifts_unfold :: FuncUnfold ArithmeticShifts [] (ArithmeticShiftsⁱᵐᵖˡ);
  #[global] BitwiseOps_unfold :: FuncUnfold BitwiseOps [] (BitwiseOpsⁱᵐᵖˡ);
  #[global] Comparison_unfold :: FuncUnfold Comparison [] (Comparisonⁱᵐᵖˡ);
  #[global] AssignOps_unfold :: FuncUnfold AssignOps [] (AssignOpsⁱᵐᵖˡ);
  #[global] BitwiseAndNot_unfold :: FuncUnfold BitwiseAndNot [] (BitwiseAndNotⁱᵐᵖˡ);
  #[global] Negative_unfold :: FuncUnfold Negative [] (Negativeⁱᵐᵖˡ);
  #[global] PanicAtTheDisco_unfold :: FuncUnfold PanicAtTheDisco [] (PanicAtTheDiscoⁱᵐᵖˡ);
  #[global] Oracle_unfold :: FuncUnfold Oracle [] (Oracleⁱᵐᵖˡ);
  #[global] ReassignVars_unfold :: FuncUnfold ReassignVars [] (ReassignVarsⁱᵐᵖˡ);
  #[global] recur_unfold :: FuncUnfold recur [] (recurⁱᵐᵖˡ);
  #[global] useRenamedImport_unfold :: FuncUnfold useRenamedImport [] (useRenamedImportⁱᵐᵖˡ);
  #[global] TwoDiskWrite_unfold :: FuncUnfold TwoDiskWrite [] (TwoDiskWriteⁱᵐᵖˡ);
  #[global] TwoDiskRead_unfold :: FuncUnfold TwoDiskRead [] (TwoDiskReadⁱᵐᵖˡ);
  #[global] TwoDiskLock_unfold :: FuncUnfold TwoDiskLock [] (TwoDiskLockⁱᵐᵖˡ);
  #[global] TwoDiskUnlock_unfold :: FuncUnfold TwoDiskUnlock [] (TwoDiskUnlockⁱᵐᵖˡ);
  #[global] ReplicatedDiskRead_unfold :: FuncUnfold ReplicatedDiskRead [] (ReplicatedDiskReadⁱᵐᵖˡ);
  #[global] ReplicatedDiskWrite_unfold :: FuncUnfold ReplicatedDiskWrite [] (ReplicatedDiskWriteⁱᵐᵖˡ);
  #[global] ReplicatedDiskRecover_unfold :: FuncUnfold ReplicatedDiskRecover [] (ReplicatedDiskRecoverⁱᵐᵖˡ);
  #[global] BasicNamedReturn_unfold :: FuncUnfold BasicNamedReturn [] (BasicNamedReturnⁱᵐᵖˡ);
  #[global] NamedReturn_unfold :: FuncUnfold NamedReturn [] (NamedReturnⁱᵐᵖˡ);
  #[global] BasicNamedReturnMany_unfold :: FuncUnfold BasicNamedReturnMany [] (BasicNamedReturnManyⁱᵐᵖˡ);
  #[global] NamedReturnMany_unfold :: FuncUnfold NamedReturnMany [] (NamedReturnManyⁱᵐᵖˡ);
  #[global] NamedReturnOverride_unfold :: FuncUnfold NamedReturnOverride [] (NamedReturnOverrideⁱᵐᵖˡ);
  #[global] VoidButEndsWithReturn_unfold :: FuncUnfold VoidButEndsWithReturn [] (VoidButEndsWithReturnⁱᵐᵖˡ);
  #[global] VoidImplicitReturnInBranch_unfold :: FuncUnfold VoidImplicitReturnInBranch [] (VoidImplicitReturnInBranchⁱᵐᵖˡ);
  #[global] useRuneOps_unfold :: FuncUnfold useRuneOps [] (useRuneOpsⁱᵐᵖˡ);
  #[global] sliceOps_unfold :: FuncUnfold sliceOps [] (sliceOpsⁱᵐᵖˡ);
  #[global] makeSingletonSlice_unfold :: FuncUnfold makeSingletonSlice [] (makeSingletonSliceⁱᵐᵖˡ);
  #[global] makeAlias_unfold :: FuncUnfold makeAlias [] (makeAliasⁱᵐᵖˡ);
  #[global] Skip_unfold :: FuncUnfold Skip [] (Skipⁱᵐᵖˡ);
  #[global] simpleSpawn_unfold :: FuncUnfold simpleSpawn [] (simpleSpawnⁱᵐᵖˡ);
  #[global] threadCode_unfold :: FuncUnfold threadCode [] (threadCodeⁱᵐᵖˡ);
  #[global] loopSpawn_unfold :: FuncUnfold loopSpawn [] (loopSpawnⁱᵐᵖˡ);
  #[global] stringAppend_unfold :: FuncUnfold stringAppend [] (stringAppendⁱᵐᵖˡ);
  #[global] stringLength_unfold :: FuncUnfold stringLength [] (stringLengthⁱᵐᵖˡ);
  #[global] x_unfold :: FuncUnfold x [] (xⁱᵐᵖˡ);
  #[global] UseAdd_unfold :: FuncUnfold UseAdd [] (UseAddⁱᵐᵖˡ);
  #[global] UseAddWithLiteral_unfold :: FuncUnfold UseAddWithLiteral [] (UseAddWithLiteralⁱᵐᵖˡ);
  #[global] NewS_unfold :: FuncUnfold NewS [] (NewSⁱᵐᵖˡ);
  #[global] localSRef_unfold :: FuncUnfold localSRef [] (localSRefⁱᵐᵖˡ);
  #[global] setField_unfold :: FuncUnfold setField [] (setFieldⁱᵐᵖˡ);
  #[global] testSwitchVal_unfold :: FuncUnfold testSwitchVal [] (testSwitchValⁱᵐᵖˡ);
  #[global] testSwitchMultiple_unfold :: FuncUnfold testSwitchMultiple [] (testSwitchMultipleⁱᵐᵖˡ);
  #[global] DoSomeLocking_unfold :: FuncUnfold DoSomeLocking [] (DoSomeLockingⁱᵐᵖˡ);
  #[global] makeLock_unfold :: FuncUnfold makeLock [] (makeLockⁱᵐᵖˡ);
  #[global] sleep_unfold :: FuncUnfold sleep [] (sleepⁱᵐᵖˡ);
  #[global] mkInt_unfold :: FuncUnfold mkInt [] (mkIntⁱᵐᵖˡ);
  #[global] mkNothing_unfold :: FuncUnfold mkNothing [] (mkNothingⁱᵐᵖˡ);
  #[global] convertToAlias_unfold :: FuncUnfold convertToAlias [] (convertToAliasⁱᵐᵖˡ);
  #[global] typeAssertInt_unfold :: FuncUnfold typeAssertInt [] (typeAssertIntⁱᵐᵖˡ);
  #[global] wrapUnwrapInt_unfold :: FuncUnfold wrapUnwrapInt [] (wrapUnwrapIntⁱᵐᵖˡ);
  #[global] checkedTypeAssert_unfold :: FuncUnfold checkedTypeAssert [] (checkedTypeAssertⁱᵐᵖˡ);
  #[global] basicTypeSwitch_unfold :: FuncUnfold basicTypeSwitch [] (basicTypeSwitchⁱᵐᵖˡ);
  #[global] fancyTypeSwitch_unfold :: FuncUnfold fancyTypeSwitch [] (fancyTypeSwitchⁱᵐᵖˡ);
  #[global] multiTypeSwitch_unfold :: FuncUnfold multiTypeSwitch [] (multiTypeSwitchⁱᵐᵖˡ);
  #[global] variadicFunc_unfold :: FuncUnfold variadicFunc [] (variadicFuncⁱᵐᵖˡ);
  #[global] testVariadicCall_unfold :: FuncUnfold testVariadicCall [] (testVariadicCallⁱᵐᵖˡ);
  #[global] returnMultiple_unfold :: FuncUnfold returnMultiple [] (returnMultipleⁱᵐᵖˡ);
  #[global] testVariadicPassThrough_unfold :: FuncUnfold testVariadicPassThrough [] (testVariadicPassThroughⁱᵐᵖˡ);
  #[global] LocalVars_unfold :: FuncUnfold LocalVars [] (LocalVarsⁱᵐᵖˡ);
  #[global] LocalConsts_unfold :: FuncUnfold LocalConsts [] (LocalConstsⁱᵐᵖˡ);
  #[global] import_fmt_Assumption :: fmt.Assumptions;
  #[global] import_sync_Assumption :: sync.Assumptions;
  #[global] import_primitive_Assumption :: primitive.Assumptions;
  #[global] import_disk_Assumption :: disk.Assumptions;
  #[global] import_log_Assumption :: log.Assumptions;
  #[global] import_std_Assumption :: std.Assumptions;
}.
End unittest.
