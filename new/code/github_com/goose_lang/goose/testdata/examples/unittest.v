(* autogenerated from github.com/goose-lang/goose/testdata/examples/unittest *)
Require Export New.code.fmt.
Require Export New.code.github_com.goose_lang.primitive.
Require Export New.code.github_com.goose_lang.primitive.disk.
Require Export New.code.github_com.goose_lang.std.
Require Export New.code.log.
Require Export New.code.sync.

From New.golang Require Import defn.
Definition unittest : go_string := "github.com/goose-lang/goose/testdata/examples/unittest".

From New Require Import disk_prelude.
Module unittest.

Module Foo. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.Foo"%go. End Foo.
Module importantStruct. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.importantStruct"%go. End importantStruct.
Module stringWrapper. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.stringWrapper"%go. End stringWrapper.
Module Uint32. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.Uint32"%go. End Uint32.
Module diskWrapper. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.diskWrapper"%go. End diskWrapper.
Module embedA. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.embedA"%go. End embedA.
Module embedB. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.embedB"%go. End embedB.
Module embedC. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.embedC"%go. End embedC.
Module embedD. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.embedD"%go. End embedD.
Module Enc. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.Enc"%go. End Enc.
Module Dec. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.Dec"%go. End Dec.
Module Enum1. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.Enum1"%go. End Enum1.
Module Enum2. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.Enum2"%go. End Enum2.
Module Fooer. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.Fooer"%go. End Fooer.
Module concreteFooer. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.concreteFooer"%go. End concreteFooer.
Module FooerUser. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.FooerUser"%go. End FooerUser.
Module PointerInterface. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.PointerInterface"%go. End PointerInterface.
Module concrete1. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.concrete1"%go. End concrete1.
Module my_u32. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.my_u32"%go. End my_u32.
Module also_u32. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.also_u32"%go. End also_u32.
Module allTheLiterals. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.allTheLiterals"%go. End allTheLiterals.
Module hasCondVar. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.hasCondVar"%go. End hasCondVar.
Module IntWrapper. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.IntWrapper"%go. End IntWrapper.
Module MapWrapper. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.MapWrapper"%go. End MapWrapper.
Module mapElem. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.mapElem"%go. End mapElem.
Module containsPointer. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.containsPointer"%go. End containsPointer.
Module wrapExternalStruct. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.wrapExternalStruct"%go. End wrapExternalStruct.
Module typing. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.typing"%go. End typing.
Module composite. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.composite"%go. End composite.
Module R. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.R"%go. End R.
Module Other. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.Other"%go. End Other.
Module RecursiveEmbedded. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.RecursiveEmbedded"%go. End RecursiveEmbedded.
Module Block. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.Block"%go. End Block.
Module SliceAlias. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.SliceAlias"%go. End SliceAlias.
Module thing. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.thing"%go. End thing.
Module sliceOfThings. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.sliceOfThings"%go. End sliceOfThings.
Module Point. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.Point"%go. End Point.
Module TwoInts. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.TwoInts"%go. End TwoInts.
Module S. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.S"%go. End S.
Module B. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.B"%go. End B.
Module A. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.A"%go. End A.
Module my_u64. Definition id : go_string := uint64T.id. End my_u64.
Module Timestamp. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.Timestamp"%go. End Timestamp.
Module UseTypeAbbrev. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.UseTypeAbbrev"%go. End UseTypeAbbrev.
Module UseNamedType. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.UseNamedType"%go. End UseNamedType.

Section code.


Definition Foo : go_type := arrayT (W64 10) uint64T.
#[global] Typeclasses Opaque Foo.
#[global] Opaque Foo.

Definition takesArray : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.takesArray"%go.

(* go: array.go:5:6 *)
Definition takesArrayⁱᵐᵖˡ : val :=
  λ: "x",
    exception_do (let: "x" := (mem.alloc "x") in
    return: (![#stringT] (array.elem_ref #stringT (![type.arrayT #(W64 13) #stringT] "x") #(W64 3)))).

Definition takesPtr : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.takesPtr"%go.

(* go: array.go:9:6 *)
Definition takesPtrⁱᵐᵖˡ : val :=
  λ: "x",
    exception_do (let: "x" := (mem.alloc "x") in
    do:  ((![#ptrT] "x") <-[#stringT] ((![#stringT] (![#ptrT] "x")) + #"bar"%go));;;
    return: #()).

Definition usesArrayElemRef : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.usesArrayElemRef"%go.

(* go: array.go:13:6 *)
Definition usesArrayElemRefⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (mem.alloc (type.zero_val (type.arrayT #(W64 2) #stringT))) in
    let: "$r0" := ((let: "$ar0" := #"a"%go in
    let: "$ar1" := #"b"%go in
    array.literal ["$ar0"; "$ar1"])) in
    do:  ("x" <-[type.arrayT #(W64 2) #stringT] "$r0");;;
    let: "$r0" := #"c"%go in
    do:  ((array.elem_ref #stringT (![type.arrayT #(W64 2) #stringT] "x") #(W64 1)) <-[#stringT] "$r0");;;
    do:  (let: "$a0" := (array.elem_ref #stringT (![type.arrayT #(W64 2) #stringT] "x") #(W64 1)) in
    (func_call #takesPtr) "$a0");;;
    return: #()).

Definition sum : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.sum"%go.

(* go: array.go:22:6 *)
Definition sumⁱᵐᵖˡ : val :=
  λ: "x",
    exception_do (let: "x" := (mem.alloc "x") in
    let: "sum" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("sum" <-[#uint64T] "$r0");;;
    (let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (for: (λ: <>, (![#uint64T] "i") < (s_to_w64 (array.len (type.arrayT #(W64 100) #uint64T)))); (λ: <>, do:  ("i" <-[#uint64T] ((![#uint64T] "i") + #(W64 1)))) := λ: <>,
      do:  ("sum" <-[#uint64T] ((![#uint64T] "sum") + (![#uint64T] (array.elem_ref #uint64T (![type.arrayT #(W64 100) #uint64T] "x") (![#uint64T] "i")))))));;;
    do:  ("sum" <-[#uint64T] ((![#uint64T] "sum") + (s_to_w64 (array.cap (type.arrayT #(W64 100) #uint64T)))));;;
    return: (![#uint64T] "sum")).

Definition arrayToSlice : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.arrayToSlice"%go.

(* go: array.go:31:6 *)
Definition arrayToSliceⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (mem.alloc (type.zero_val (type.arrayT #(W64 2) #stringT))) in
    let: "$r0" := ((let: "$ar0" := #"a"%go in
    let: "$ar1" := #"b"%go in
    array.literal ["$ar0"; "$ar1"])) in
    do:  ("x" <-[type.arrayT #(W64 2) #stringT] "$r0");;;
    return: (let: "$a" := "x" in
     array.slice #stringT "$a" #(W64 0) (array.len #stringT))).

Definition arrayA : Z := 0.

Definition arrayB : Z := 10.

Definition arrayLiteralKeyed : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.arrayLiteralKeyed"%go.

(* go: array.go:44:6 *)
Definition arrayLiteralKeyedⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (mem.alloc (type.zero_val (type.arrayT #(W64 13) #stringT))) in
    let: "$r0" := ((let: "$ar0" := #"A"%go in
    let: "$ar1" := #"3"%go in
    let: "$ar2" := (type.zero_val #stringT) in
    let: "$ar3" := (type.zero_val #stringT) in
    let: "$ar4" := (type.zero_val #stringT) in
    let: "$ar5" := (type.zero_val #stringT) in
    let: "$ar6" := (type.zero_val #stringT) in
    let: "$ar7" := (type.zero_val #stringT) in
    let: "$ar8" := (type.zero_val #stringT) in
    let: "$ar9" := (type.zero_val #stringT) in
    let: "$ar10" := #"B"%go in
    let: "$ar11" := #"1"%go in
    let: "$ar12" := #"2"%go in
    array.literal ["$ar0"; "$ar1"; "$ar2"; "$ar3"; "$ar4"; "$ar5"; "$ar6"; "$ar7"; "$ar8"; "$ar9"; "$ar10"; "$ar11"; "$ar12"])) in
    do:  ("x" <-[type.arrayT #(W64 13) #stringT] "$r0");;;
    return: (![#stringT] (array.elem_ref #stringT (![type.arrayT #(W64 13) #stringT] "x") #(W64 0)))).

Definition chanBasic : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.chanBasic"%go.

(* go: chan.go:5:6 *)
Definition chanBasicⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (mem.alloc (type.zero_val (type.chanT #stringT))) in
    let: "$r0" := (chan.make #stringT #(W64 10)) in
    do:  ("x" <-[type.chanT #stringT] "$r0");;;
    let: "$r0" := (chan.make #stringT #(W64 0)) in
    do:  ("x" <-[type.chanT #stringT] "$r0");;;
    let: "$go" := (λ: <>,
      exception_do (do:  (let: "$chan" := (![type.chanT #stringT] "x") in
      let: "$v" := #"Foo"%go in
      chan.send #stringT "$chan" "$v");;;
      do:  (let: "$chan" := (![type.chanT #stringT] "x") in
      let: "$v" := #"Foo"%go in
      chan.send #stringT "$chan" "$v");;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "y" := (mem.alloc (type.zero_val #stringT)) in
    let: ("$ret0", "$ret1") := (chan.receive #stringT (![type.chanT #stringT] "x")) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("y" <-[#stringT] "$r0");;;
    do:  ("ok" <-[#boolT] "$r1");;;
    let: "$r0" := (Fst (chan.receive #stringT (![type.chanT #stringT] "x"))) in
    do:  ("y" <-[#stringT] "$r0");;;
    (if: ![#boolT] "ok"
    then
      let: "$r0" := ((![#stringT] "y") + #" "%go) in
      do:  ("y" <-[#stringT] "$r0")
    else do:  #());;;
    return: #()).

Definition f : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.f"%go.

(* go: chan.go:20:6 *)
Definition fⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (#(W64 0))).

Definition chanSelect : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.chanSelect"%go.

(* modified version of example from https://go.dev/ref/spec#Select_statements

   go: chan.go:25:6 *)
Definition chanSelectⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "a" := (mem.alloc (type.zero_val #sliceT)) in
    let: "c4" := (mem.alloc (type.zero_val (type.chanT #intT))) in
    let: "c3" := (mem.alloc (type.zero_val (type.chanT #intT))) in
    let: "c2" := (mem.alloc (type.zero_val (type.chanT #intT))) in
    let: "c1" := (mem.alloc (type.zero_val (type.chanT #intT))) in
    let: "c" := (mem.alloc (type.zero_val (type.chanT #intT))) in
    let: "i2" := (mem.alloc (type.zero_val #intT)) in
    let: "i1" := (mem.alloc (type.zero_val #intT)) in
    chan.select_nonblocking [chan.select_receive #intT (![type.chanT #intT] "c3") (λ: "$recvVal",
       do:  #()
       ); chan.select_receive #intT (![type.chanT #intT] "c1") (λ: "$recvVal",
       let: "$r0" := (Fst "$recvVal") in
       do:  ("i1" <-[#intT] "$r0");;;
       do:  (let: "$a0" := ((let: "$sl0" := (interface.make #stringT.id #"received "%go) in
       let: "$sl1" := (interface.make #intT.id (![#intT] "i1")) in
       let: "$sl2" := (interface.make #stringT.id #" from c1
       "%go) in
       slice.literal #interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
       (func_call #fmt.Print) "$a0")
       ); chan.select_send #intT (![type.chanT #intT] "c2") (![#intT] "i2") (λ: <>,
       do:  (let: "$a0" := ((let: "$sl0" := (interface.make #stringT.id #"sent "%go) in
       let: "$sl1" := (interface.make #intT.id (![#intT] "i2")) in
       let: "$sl2" := (interface.make #stringT.id #" to c2
       "%go) in
       slice.literal #interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
       (func_call #fmt.Print) "$a0")
       ); chan.select_receive #intT (![type.chanT #intT] "c3") (λ: "$recvVal",
       let: "ok" := (mem.alloc (type.zero_val #boolT)) in
       let: "i3" := (mem.alloc (type.zero_val #intT)) in
       let: ("$ret0", "$ret1") := "$recvVal" in
       let: "$r0" := "$ret0" in
       let: "$r1" := "$ret1" in
       do:  ("i3" <-[#intT] "$r0");;;
       do:  ("ok" <-[#boolT] "$r1");;;
       (if: ![#boolT] "ok"
       then
         do:  (let: "$a0" := ((let: "$sl0" := (interface.make #stringT.id #"received "%go) in
         let: "$sl1" := (interface.make #intT.id (![#intT] "i3")) in
         let: "$sl2" := (interface.make #stringT.id #" from c3
         "%go) in
         slice.literal #interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
         (func_call #fmt.Print) "$a0")
       else
         do:  (let: "$a0" := ((let: "$sl0" := (interface.make #stringT.id #"c3 is closed
         "%go) in
         slice.literal #interfaceT ["$sl0"])) in
         (func_call #fmt.Print) "$a0"))
       ); chan.select_receive #intT (![type.chanT #intT] "c4") (λ: "$recvVal",
       let: "$r0" := (Fst "$recvVal") in
       do:  ((slice.elem_ref #intT (![#sliceT] "a") ((func_call #f) #())) <-[#intT] "$r0");;;
       do:  #()
       )] (λ: <>,
      do:  (let: "$a0" := ((let: "$sl0" := (interface.make #stringT.id #"no communication
      "%go) in
      slice.literal #interfaceT ["$sl0"])) in
      (func_call #fmt.Print) "$a0")
      );;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      chan.select_blocking [chan.select_send #intT (![type.chanT #intT] "c") #(W64 0) (λ: <>,
         do:  #()
         ); chan.select_send #intT (![type.chanT #intT] "c") #(W64 1) (λ: <>,
         do:  #()
         )]);;;
    chan.select_blocking [];;;
    return: #()).

Definition chanDirectional : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.chanDirectional"%go.

(* go: chan.go:59:6 *)
Definition chanDirectionalⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (mem.alloc (type.zero_val (type.chanT #uint64T))) in
    let: "y" := (mem.alloc (type.zero_val (type.chanT #stringT))) in
    do:  (Fst (chan.receive #uint64T (![type.chanT #uint64T] "x")));;;
    do:  (let: "$chan" := (![type.chanT #stringT] "y") in
    let: "$v" := #""%go in
    chan.send #stringT "$chan" "$v");;;
    return: #()).

Definition chanRange : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.chanRange"%go.

(* go: chan.go:66:6 *)
Definition chanRangeⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (mem.alloc (type.zero_val (type.chanT #uint64T))) in
    let: "$range" := (![type.chanT #uint64T] "x") in
    (let: "y" := (mem.alloc (type.zero_val #uint64T)) in
    chan.for_range #uint64T "$range" (λ: "$key",
      do:  ("y" <-[#uint64T] "$key");;;
      do:  (let: "$a0" := ((let: "$sl0" := (interface.make #uint64T.id (![#uint64T] "y")) in
      slice.literal #interfaceT ["$sl0"])) in
      (func_call #fmt.Print) "$a0")));;;
    let: "$range" := (![type.chanT #uint64T] "x") in
    (let: "x" := (mem.alloc (type.zero_val #uint64T)) in
    chan.for_range #uint64T "$range" (λ: "$key",
      do:  ("x" <-[#uint64T] "$key");;;
      do:  (let: "$a0" := ((let: "$sl0" := (interface.make #uint64T.id (![#uint64T] "x")) in
      slice.literal #interfaceT ["$sl0"])) in
      (func_call #fmt.Print) "$a0")));;;
    let: "$range" := (![type.chanT #uint64T] "x") in
    chan.for_range #uint64T "$range" (λ: "$key",
      do:  #());;;
    return: #()).

Definition importantStruct : go_type := structT [
].
#[global] Typeclasses Opaque importantStruct.
#[global] Opaque importantStruct.

Definition doSubtleThings : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.doSubtleThings"%go.

(* doSubtleThings does a number of subtle things:

   (actually, it does nothing)

   go: comments.go:12:6 *)
Definition doSubtleThingsⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (do:  #()).

Definition hasStartComment : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.hasStartComment"%go.

(* This comment starts a Coq comment ( *

   go: comments.go:15:6 *)
Definition hasStartCommentⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (do:  #()).

Definition hasEndComment : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.hasEndComment"%go.

(* This comment * ) ends a Coq comment

   go: comments.go:18:6 *)
Definition hasEndCommentⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (do:  #()).

Definition condvarWrapping : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.condvarWrapping"%go.

(* go: condvar.go:5:6 *)
Definition condvarWrappingⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "mu" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #sync.Mutex)) in
    do:  ("mu" <-[#ptrT] "$r0");;;
    let: "cond1" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := (interface.make #(ptrT.id sync.Mutex.id) (![#ptrT] "mu")) in
    (func_call #sync.NewCond) "$a0") in
    do:  ("cond1" <-[#ptrT] "$r0");;;
    let: "$r0" := (mem.alloc (type.zero_val #sync.Mutex)) in
    do:  ("mu" <-[#ptrT] "$r0");;;
    do:  ((method_call #(ptrT.id sync.Cond.id) #"Wait"%go (![#ptrT] "cond1")) #());;;
    return: #()).

Definition GlobalConstant : val := #"foo"%go.

(* an untyped string *)
Definition UntypedStringConstant : go_string := "bar"%go.

Definition UntypedInt : Z := 13.

Definition OtherUntypedInt : Z := 26.

Definition TypedInt : val := #(W64 32).

Definition ConstWithArith : val := #(W64 100).

Definition TypedInt32 : val := #(W32 3).

Definition DivisionInConst : val := #(W64 511).

(* 517 *)
Definition ModInConst : val := #(W64 517).

(* 5 *)
Definition ModInConstParens : val := #(W64 5).

Definition SignedIntegerExample : val := #(W64 (-37)).

Definition First : Z := 0.

Definition Second : Z := 1.

Definition Third : Z := 2.

Definition ComplicatedFirst : val := #(W64 3).

Definition ComplicatedSecond : val := #(W64 5).

Definition ComplicatedThird : val := #(W64 7).

Definition useUntypedInt : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.useUntypedInt"%go.

(* go: const.go:37:6 *)
Definition useUntypedIntⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (#(W64 UntypedInt) + TypedInt)).

Definition useUntypedString : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.useUntypedString"%go.

(* go: const.go:41:6 *)
Definition useUntypedStringⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (#UntypedStringConstant)).

Definition conditionalReturn : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.conditionalReturn"%go.

(* go: control_flow.go:3:6 *)
Definition conditionalReturnⁱᵐᵖˡ : val :=
  λ: "x",
    exception_do (let: "x" := (mem.alloc "x") in
    (if: ![#boolT] "x"
    then return: (#(W64 0))
    else do:  #());;;
    return: (#(W64 1))).

Definition alwaysReturn : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.alwaysReturn"%go.

(* go: control_flow.go:10:6 *)
Definition alwaysReturnⁱᵐᵖˡ : val :=
  λ: "x",
    exception_do (let: "x" := (mem.alloc "x") in
    (if: ![#boolT] "x"
    then return: (#(W64 0))
    else return: (#(W64 1)))).

Definition alwaysReturnInNestedBranches : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.alwaysReturnInNestedBranches"%go.

(* go: control_flow.go:18:6 *)
Definition alwaysReturnInNestedBranchesⁱᵐᵖˡ : val :=
  λ: "x",
    exception_do (let: "x" := (mem.alloc "x") in
    (if: (~ (![#boolT] "x"))
    then
      (if: ![#boolT] "x"
      then return: (#(W64 0))
      else return: (#(W64 1)))
    else do:  #());;;
    let: "y" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 14) in
    do:  ("y" <-[#uint64T] "$r0");;;
    return: (![#uint64T] "y")).

Definition earlyReturn : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.earlyReturn"%go.

(* go: control_flow.go:32:6 *)
Definition earlyReturnⁱᵐᵖˡ : val :=
  λ: "x",
    exception_do (let: "x" := (mem.alloc "x") in
    (if: ![#boolT] "x"
    then return: (#())
    else do:  #());;;
    return: #()).

Definition conditionalAssign : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.conditionalAssign"%go.

(* go: control_flow.go:38:6 *)
Definition conditionalAssignⁱᵐᵖˡ : val :=
  λ: "x",
    exception_do (let: "x" := (mem.alloc "x") in
    let: "y" := (mem.alloc (type.zero_val #uint64T)) in
    (if: ![#boolT] "x"
    then
      let: "$r0" := #(W64 1) in
      do:  ("y" <-[#uint64T] "$r0")
    else
      let: "$r0" := #(W64 2) in
      do:  ("y" <-[#uint64T] "$r0"));;;
    do:  ("y" <-[#uint64T] ((![#uint64T] "y") + #(W64 1)));;;
    return: (![#uint64T] "y")).

Definition elseIf : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.elseIf"%go.

(* go: control_flow.go:49:6 *)
Definition elseIfⁱᵐᵖˡ : val :=
  λ: "x" "y",
    exception_do (let: "y" := (mem.alloc "y") in
    let: "x" := (mem.alloc "x") in
    (if: ![#boolT] "x"
    then return: (#(W64 0))
    else
      (if: ![#boolT] "y"
      then return: (#(W64 1))
      else return: (#(W64 2))))).

Definition ifStmtInitialization : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.ifStmtInitialization"%go.

(* go: control_flow.go:59:6 *)
Definition ifStmtInitializationⁱᵐᵖˡ : val :=
  λ: "x",
    exception_do (let: "x" := (mem.alloc "x") in
    let: "f" := (mem.alloc (type.zero_val #funcT)) in
    let: "$r0" := (λ: <>,
      exception_do (return: (![#uint64T] "x"))
      ) in
    do:  ("f" <-[#funcT] "$r0");;;
    (do:  ((![#funcT] "f") #());;;
    (if: (![#uint64T] "x") = #(W64 2)
    then do:  #()
    else
      (let: "z" := (mem.alloc (type.zero_val #uint64T)) in
      let: "$r0" := (![#uint64T] "x") in
      do:  ("z" <-[#uint64T] "$r0");;;
      (if: (![#uint64T] "z") = #(W64 1)
      then do:  #()
      else
        (let: "y" := (mem.alloc (type.zero_val #intT)) in
        let: "$r0" := #(W64 94) in
        do:  ("y" <-[#intT] "$r0");;;
        (if: (![#intT] "y") = #(W64 30)
        then do:  #()
        else
          (let: "$r0" := #(W64 10) in
          do:  ("z" <-[#uint64T] "$r0");;;
          (if: (![#uint64T] "x") = #(W64 30)
          then do:  #()
          else do:  #()))))))));;;
    (let: "y" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 10) in
    do:  ("y" <-[#uint64T] "$r0");;;
    (if: (![#uint64T] "x") = #(W64 0)
    then return: (![#uint64T] "y")
    else return: ((![#uint64T] "y") - #(W64 1))))).

Definition stringWrapper : go_type := stringT.
#[global] Typeclasses Opaque stringWrapper.
#[global] Opaque stringWrapper.

Definition typedLiteral : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.typedLiteral"%go.

(* go: conversions.go:5:6 *)
Definition typedLiteralⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (#(W64 3))).

Definition literalCast : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.literalCast"%go.

(* go: conversions.go:9:6 *)
Definition literalCastⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 2) in
    do:  ("x" <-[#uint64T] "$r0");;;
    return: ((![#uint64T] "x") + #(W64 2))).

Definition castInt : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.castInt"%go.

(* go: conversions.go:15:6 *)
Definition castIntⁱᵐᵖˡ : val :=
  λ: "p",
    exception_do (let: "p" := (mem.alloc "p") in
    return: (s_to_w64 (let: "$a0" := (![#sliceT] "p") in
     slice.len "$a0"))).

Definition stringToByteSlice : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.stringToByteSlice"%go.

(* go: conversions.go:19:6 *)
Definition stringToByteSliceⁱᵐᵖˡ : val :=
  λ: "s",
    exception_do (let: "s" := (mem.alloc "s") in
    let: "p" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (string.to_bytes (![#stringT] "s")) in
    do:  ("p" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "p")).

Definition byteSliceToString : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.byteSliceToString"%go.

(* go: conversions.go:25:6 *)
Definition byteSliceToStringⁱᵐᵖˡ : val :=
  λ: "p",
    exception_do (let: "p" := (mem.alloc "p") in
    let: "s" := (mem.alloc (type.zero_val #stringT)) in
    let: "$r0" := (string.from_bytes (![#sliceT] "p")) in
    do:  ("s" <-[#stringT] "$r0");;;
    return: (![#stringT] "s")).

Definition stringToStringWrapper : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.stringToStringWrapper"%go.

(* go: conversions.go:31:6 *)
Definition stringToStringWrapperⁱᵐᵖˡ : val :=
  λ: "s",
    exception_do (let: "s" := (mem.alloc "s") in
    return: (![#stringT] "s")).

Definition stringWrapperToString : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.stringWrapperToString"%go.

(* go: conversions.go:35:6 *)
Definition stringWrapperToStringⁱᵐᵖˡ : val :=
  λ: "s",
    exception_do (let: "s" := (mem.alloc "s") in
    return: (![#stringWrapper] "s")).

Definition Uint32 : go_type := uint32T.
#[global] Typeclasses Opaque Uint32.
#[global] Opaque Uint32.

Definition testU32NewtypeLen : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.testU32NewtypeLen"%go.

(* go: conversions.go:41:6 *)
Definition testU32NewtypeLenⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "s" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make2 #byteT #(W64 20)) in
    do:  ("s" <-[#sliceT] "$r0");;;
    return: ((s_to_w32 (let: "$a0" := (![#sliceT] "s") in
     slice.len "$a0")) = #(W32 20))).

Definition testCopySimple : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.testCopySimple"%go.

(* go: copy.go:3:6 *)
Definition testCopySimpleⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make2 #byteT #(W64 10)) in
    do:  ("x" <-[#sliceT] "$r0");;;
    let: "$r0" := #(W8 1) in
    do:  ((slice.elem_ref #byteT (![#sliceT] "x") #(W64 3)) <-[#byteT] "$r0");;;
    let: "y" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make2 #byteT #(W64 10)) in
    do:  ("y" <-[#sliceT] "$r0");;;
    do:  (let: "$a0" := (![#sliceT] "y") in
    let: "$a1" := (![#sliceT] "x") in
    (slice.copy #byteT) "$a0" "$a1");;;
    return: ((![#byteT] (slice.elem_ref #byteT (![#sliceT] "y") #(W64 3))) = #(W8 1))).

Definition testCopyDifferentLengths : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.testCopyDifferentLengths"%go.

(* go: copy.go:11:6 *)
Definition testCopyDifferentLengthsⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make2 #byteT #(W64 15)) in
    do:  ("x" <-[#sliceT] "$r0");;;
    let: "$r0" := #(W8 1) in
    do:  ((slice.elem_ref #byteT (![#sliceT] "x") #(W64 3)) <-[#byteT] "$r0");;;
    let: "$r0" := #(W8 2) in
    do:  ((slice.elem_ref #byteT (![#sliceT] "x") #(W64 12)) <-[#byteT] "$r0");;;
    let: "y" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make2 #byteT #(W64 10)) in
    do:  ("y" <-[#sliceT] "$r0");;;
    let: "n" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (s_to_w64 (let: "$a0" := (![#sliceT] "y") in
    let: "$a1" := (![#sliceT] "x") in
    (slice.copy #byteT) "$a0" "$a1")) in
    do:  ("n" <-[#uint64T] "$r0");;;
    return: (((![#uint64T] "n") = #(W64 10)) && ((![#byteT] (slice.elem_ref #byteT (![#sliceT] "y") #(W64 3))) = #(W8 1)))).

Definition atomicCreateStub : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.atomicCreateStub"%go.

(* go: data_structures.go:7:6 *)
Definition atomicCreateStubⁱᵐᵖˡ : val :=
  λ: "dir" "fname" "data",
    exception_do (let: "data" := (mem.alloc "data") in
    let: "fname" := (mem.alloc "fname") in
    let: "dir" := (mem.alloc "dir") in
    do:  #()).

Definition useSlice : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.useSlice"%go.

(* go: data_structures.go:9:6 *)
Definition useSliceⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "s" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make2 #byteT #(W64 1)) in
    do:  ("s" <-[#sliceT] "$r0");;;
    let: "s1" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "s") in
    let: "$a1" := (![#sliceT] "s") in
    (slice.append #byteT) "$a0" "$a1") in
    do:  ("s1" <-[#sliceT] "$r0");;;
    do:  (let: "$a0" := #"dir"%go in
    let: "$a1" := #"file"%go in
    let: "$a2" := (![#sliceT] "s1") in
    (func_call #atomicCreateStub) "$a0" "$a1" "$a2");;;
    return: #()).

Definition useSliceIndexing : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.useSliceIndexing"%go.

(* go: data_structures.go:15:6 *)
Definition useSliceIndexingⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "s" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make2 #uint64T #(W64 2)) in
    do:  ("s" <-[#sliceT] "$r0");;;
    let: "$r0" := #(W64 2) in
    do:  ((slice.elem_ref #uint64T (![#sliceT] "s") #(W64 1)) <-[#uint64T] "$r0");;;
    let: "x" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (![#uint64T] (slice.elem_ref #uint64T (![#sliceT] "s") #(W64 0))) in
    do:  ("x" <-[#uint64T] "$r0");;;
    return: (![#uint64T] "x")).

Definition useMap : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.useMap"%go.

(* go: data_structures.go:22:6 *)
Definition useMapⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "m" := (mem.alloc (type.zero_val (type.mapT #uint64T #sliceT))) in
    let: "$r0" := (map.make #uint64T #sliceT) in
    do:  ("m" <-[type.mapT #uint64T #sliceT] "$r0");;;
    let: "$r0" := #slice.nil in
    do:  (map.insert (![type.mapT #uint64T #sliceT] "m") #(W64 1) "$r0");;;
    let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "x" := (mem.alloc (type.zero_val #sliceT)) in
    let: ("$ret0", "$ret1") := (map.get (![type.mapT #uint64T #sliceT] "m") #(W64 2)) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("x" <-[#sliceT] "$r0");;;
    do:  ("ok" <-[#boolT] "$r1");;;
    (if: ![#boolT] "ok"
    then return: (#())
    else do:  #());;;
    let: "$r0" := (![#sliceT] "x") in
    do:  (map.insert (![type.mapT #uint64T #sliceT] "m") #(W64 3) "$r0");;;
    return: #()).

Definition usePtr : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.usePtr"%go.

(* go: data_structures.go:32:6 *)
Definition usePtrⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "p" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #uint64T)) in
    do:  ("p" <-[#ptrT] "$r0");;;
    let: "$r0" := #(W64 1) in
    do:  ((![#ptrT] "p") <-[#uint64T] "$r0");;;
    let: "x" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (![#uint64T] (![#ptrT] "p")) in
    do:  ("x" <-[#uint64T] "$r0");;;
    let: "$r0" := (![#uint64T] "x") in
    do:  ((![#ptrT] "p") <-[#uint64T] "$r0");;;
    return: #()).

Definition iterMapKeysAndValues : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.iterMapKeysAndValues"%go.

(* go: data_structures.go:39:6 *)
Definition iterMapKeysAndValuesⁱᵐᵖˡ : val :=
  λ: "m",
    exception_do (let: "m" := (mem.alloc "m") in
    let: "sumPtr" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #uint64T)) in
    do:  ("sumPtr" <-[#ptrT] "$r0");;;
    let: "$range" := (![type.mapT #uint64T #uint64T] "m") in
    (let: "v" := (mem.alloc (type.zero_val #uint64T)) in
    let: "k" := (mem.alloc (type.zero_val #uint64T)) in
    map.for_range "$range" (λ: "$key" "value",
      do:  ("v" <-[#uint64T] "$value");;;
      do:  ("k" <-[#uint64T] "$key");;;
      let: "sum" := (mem.alloc (type.zero_val #uint64T)) in
      let: "$r0" := (![#uint64T] (![#ptrT] "sumPtr")) in
      do:  ("sum" <-[#uint64T] "$r0");;;
      let: "$r0" := (((![#uint64T] "sum") + (![#uint64T] "k")) + (![#uint64T] "v")) in
      do:  ((![#ptrT] "sumPtr") <-[#uint64T] "$r0")));;;
    let: "sum" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (![#uint64T] (![#ptrT] "sumPtr")) in
    do:  ("sum" <-[#uint64T] "$r0");;;
    return: (![#uint64T] "sum")).

Definition iterMapKeys : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.iterMapKeys"%go.

(* go: data_structures.go:49:6 *)
Definition iterMapKeysⁱᵐᵖˡ : val :=
  λ: "m",
    exception_do (let: "m" := (mem.alloc "m") in
    let: "keysSlice" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make2 #uint64T #(W64 0)) in
    do:  ("keysSlice" <-[#sliceT] "$r0");;;
    let: "keysRef" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #sliceT)) in
    do:  ("keysRef" <-[#ptrT] "$r0");;;
    let: "$r0" := (![#sliceT] "keysSlice") in
    do:  ((![#ptrT] "keysRef") <-[#sliceT] "$r0");;;
    let: "$range" := (![type.mapT #uint64T #uint64T] "m") in
    (let: "k" := (mem.alloc (type.zero_val #uint64T)) in
    map.for_range "$range" (λ: "$key" "value",
      do:  ("k" <-[#uint64T] "$key");;;
      let: "keys" := (mem.alloc (type.zero_val #sliceT)) in
      let: "$r0" := (![#sliceT] (![#ptrT] "keysRef")) in
      do:  ("keys" <-[#sliceT] "$r0");;;
      let: "newKeys" := (mem.alloc (type.zero_val #sliceT)) in
      let: "$r0" := (let: "$a0" := (![#sliceT] "keys") in
      let: "$a1" := ((let: "$sl0" := (![#uint64T] "k") in
      slice.literal #uint64T ["$sl0"])) in
      (slice.append #uint64T) "$a0" "$a1") in
      do:  ("newKeys" <-[#sliceT] "$r0");;;
      let: "$r0" := (![#sliceT] "newKeys") in
      do:  ((![#ptrT] "keysRef") <-[#sliceT] "$r0")));;;
    let: "keys" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] (![#ptrT] "keysRef")) in
    do:  ("keys" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "keys")).

Definition getRandom : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.getRandom"%go.

(* go: data_structures.go:62:6 *)
Definition getRandomⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "r" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := ((func_call #primitive.RandomUint64) #()) in
    do:  ("r" <-[#uint64T] "$r0");;;
    return: (![#uint64T] "r")).

Definition diskWrapper : go_type := structT [
  "d" :: disk.Disk
].
#[global] Typeclasses Opaque diskWrapper.
#[global] Opaque diskWrapper.

Definition diskArgument : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.diskArgument"%go.

(* go: disk.go:9:6 *)
Definition diskArgumentⁱᵐᵖˡ : val :=
  λ: "d",
    exception_do (let: "d" := (mem.alloc "d") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := #(W64 0) in
    (interface.get #"Read"%go (![#disk.Disk] "d")) "$a0") in
    do:  ("b" <-[#sliceT] "$r0");;;
    do:  (let: "$a0" := #(W64 1) in
    let: "$a1" := (![#sliceT] "b") in
    (interface.get #"Write"%go (![#disk.Disk] "d")) "$a0" "$a1");;;
    return: #()).

Definition embedA : go_type := structT [
  "a" :: uint64T
].
#[global] Typeclasses Opaque embedA.
#[global] Opaque embedA.

Definition embedB : go_type := structT [
  "embedA" :: embedA
].
#[global] Typeclasses Opaque embedB.
#[global] Opaque embedB.

Definition embedC : go_type := structT [
  "embedB" :: ptrT
].
#[global] Typeclasses Opaque embedC.
#[global] Opaque embedC.

Definition embedD : go_type := structT [
  "embedC" :: embedC
].
#[global] Typeclasses Opaque embedD.
#[global] Opaque embedD.

(* go: embedded.go:19:17 *)
Definition embedA__Fooⁱᵐᵖˡ : val :=
  λ: "a" <>,
    exception_do (let: "a" := (mem.alloc "a") in
    return: (#(W64 0))).

(* go: embedded.go:23:17 *)
Definition embedB__Fooⁱᵐᵖˡ : val :=
  λ: "a" <>,
    exception_do (let: "a" := (mem.alloc "a") in
    return: (#(W64 10))).

(* go: embedded.go:27:18 *)
Definition embedA__Barⁱᵐᵖˡ : val :=
  λ: "a" <>,
    exception_do (let: "a" := (mem.alloc "a") in
    return: (#(W64 13))).

(* go: embedded.go:31:18 *)
Definition embedB__Carⁱᵐᵖˡ : val :=
  λ: "a" <>,
    exception_do (let: "a" := (mem.alloc "a") in
    return: (#(W64 14))).

Definition returnEmbedVal : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.returnEmbedVal"%go.

(* go: embedded.go:35:6 *)
Definition returnEmbedValⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (struct.make #embedB [{
       "embedA" ::= type.zero_val #embedA
     }])).

Definition returnEmbedValWithPointer : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.returnEmbedValWithPointer"%go.

(* go: embedded.go:39:6 *)
Definition returnEmbedValWithPointerⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (struct.make #embedD [{
       "embedC" ::= type.zero_val #embedC
     }])).

Definition useEmbeddedField : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.useEmbeddedField"%go.

(* go: embedded.go:43:6 *)
Definition useEmbeddedFieldⁱᵐᵖˡ : val :=
  λ: "d",
    exception_do (let: "d" := (mem.alloc "d") in
    let: "x" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (![#uint64T] (struct.field_ref #embedA #"a"%go (struct.field_ref #embedB #"embedA"%go (![#ptrT] (struct.field_ref #embedC #"embedB"%go (struct.field_ref #embedD #"embedC"%go "d")))))) in
    do:  ("x" <-[#uint64T] "$r0");;;
    let: "$r0" := (![#uint64T] (struct.field_ref #embedA #"a"%go (struct.field_ref #embedB #"embedA"%go (![#ptrT] (struct.field_ref #embedC #"embedB"%go (struct.field_ref #embedD #"embedC"%go "d")))))) in
    do:  ("x" <-[#uint64T] "$r0");;;
    let: "$r0" := #(W64 10) in
    do:  ((struct.field_ref #embedA #"a"%go (struct.field_ref #embedB #"embedA"%go (![#ptrT] (struct.field_ref #embedC #"embedB"%go (struct.field_ref #embedD #"embedC"%go "d"))))) <-[#uint64T] "$r0");;;
    let: "y" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (struct.make #embedD [{
      "embedC" ::= type.zero_val #embedC
    }])) in
    do:  ("y" <-[#ptrT] "$r0");;;
    let: "$r0" := #(W64 11) in
    do:  ((struct.field_ref #embedA #"a"%go (struct.field_ref #embedB #"embedA"%go (![#ptrT] (struct.field_ref #embedC #"embedB"%go (struct.field_ref #embedD #"embedC"%go (![#ptrT] "y")))))) <-[#uint64T] "$r0");;;
    return: (![#uint64T] "x")).

Definition useEmbeddedValField : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.useEmbeddedValField"%go.

(* go: embedded.go:54:6 *)
Definition useEmbeddedValFieldⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (struct.field_get #embedA "a" (struct.field_get #embedB "embedA" ((func_call #returnEmbedVal) #()))) in
    do:  ("x" <-[#uint64T] "$r0");;;
    let: "$r0" := (![#uint64T] (struct.field_ref #embedA #"a"%go (struct.field_ref #embedB #"embedA"%go (struct.field_get #embedC "embedB" (struct.field_get #embedD "embedC" ((func_call #returnEmbedValWithPointer) #())))))) in
    do:  ("x" <-[#uint64T] "$r0");;;
    return: (![#uint64T] "x")).

Definition useEmbeddedMethod : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.useEmbeddedMethod"%go.

(* go: embedded.go:60:6 *)
Definition useEmbeddedMethodⁱᵐᵖˡ : val :=
  λ: "d",
    exception_do (let: "d" := (mem.alloc "d") in
    return: (((method_call #embedD.id #"Foo"%go (![#embedD] "d")) #()) = ((method_call #embedA.id #"Foo"%go (![#embedA] (struct.field_ref #embedB #"embedA"%go (![#ptrT] (struct.field_ref #embedC #"embedB"%go (struct.field_ref #embedD #"embedC"%go "d")))))) #()))).

Definition useEmbeddedMethod2 : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.useEmbeddedMethod2"%go.

(* go: embedded.go:64:6 *)
Definition useEmbeddedMethod2ⁱᵐᵖˡ : val :=
  λ: "d",
    exception_do (let: "d" := (mem.alloc "d") in
    do:  ((method_call #embedD.id #"Car"%go (![#embedD] "d")) #());;;
    return: (((method_call #embedD.id #"Bar"%go (![#embedD] "d")) #()) = ((method_call #(ptrT.id embedB.id) #"Bar"%go (![#ptrT] (struct.field_ref #embedC #"embedB"%go (struct.field_ref #embedD #"embedC"%go "d")))) #()))).

Definition empty : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.empty"%go.

(* go: empty_functions.go:3:6 *)
Definition emptyⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (do:  #()).

Definition emptyReturn : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.emptyReturn"%go.

(* go: empty_functions.go:5:6 *)
Definition emptyReturnⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (#());;;
    return: #()).

Definition unnamedParams : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.unnamedParams"%go.

(* go: empty_functions.go:9:6 *)
Definition unnamedParamsⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (do:  #()).

Definition anonymousParam : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.anonymousParam"%go.

(* go: empty_functions.go:11:6 *)
Definition anonymousParamⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (do:  #()).

Definition Enc : go_type := structT [
  "p" :: sliceT
].
#[global] Typeclasses Opaque Enc.
#[global] Opaque Enc.

(* go: encoding.go:9:15 *)
Definition Enc__consumeⁱᵐᵖˡ : val :=
  λ: "e" "n",
    exception_do (let: "e" := (mem.alloc "e") in
    let: "n" := (mem.alloc "n") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$s" := (![#sliceT] (struct.field_ref #Enc #"p"%go (![#ptrT] "e"))) in
    slice.slice #byteT "$s" #(W64 0) (![#uint64T] "n")) in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$s" := (![#sliceT] (struct.field_ref #Enc #"p"%go (![#ptrT] "e"))) in
    slice.slice #byteT "$s" (![#uint64T] "n") (slice.len "$s")) in
    do:  ((struct.field_ref #Enc #"p"%go (![#ptrT] "e")) <-[#sliceT] "$r0");;;
    return: (![#sliceT] "b")).

(* go: encoding.go:15:15 *)
Definition Enc__UInt64ⁱᵐᵖˡ : val :=
  λ: "e" "x",
    exception_do (let: "e" := (mem.alloc "e") in
    let: "x" := (mem.alloc "x") in
    do:  (let: "$a0" := (let: "$a0" := #(W64 8) in
    (method_call #(ptrT.id Enc.id) #"consume"%go (![#ptrT] "e")) "$a0") in
    let: "$a1" := (![#uint64T] "x") in
    (func_call #primitive.UInt64Put) "$a0" "$a1");;;
    return: #()).

(* go: encoding.go:19:15 *)
Definition Enc__UInt32ⁱᵐᵖˡ : val :=
  λ: "e" "x",
    exception_do (let: "e" := (mem.alloc "e") in
    let: "x" := (mem.alloc "x") in
    do:  (let: "$a0" := (let: "$a0" := #(W64 4) in
    (method_call #(ptrT.id Enc.id) #"consume"%go (![#ptrT] "e")) "$a0") in
    let: "$a1" := (![#uint32T] "x") in
    (func_call #primitive.UInt32Put) "$a0" "$a1");;;
    return: #()).

Definition Dec : go_type := structT [
  "p" :: sliceT
].
#[global] Typeclasses Opaque Dec.
#[global] Opaque Dec.

(* go: encoding.go:27:15 *)
Definition Dec__consumeⁱᵐᵖˡ : val :=
  λ: "d" "n",
    exception_do (let: "d" := (mem.alloc "d") in
    let: "n" := (mem.alloc "n") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$s" := (![#sliceT] (struct.field_ref #Dec #"p"%go (![#ptrT] "d"))) in
    slice.slice #byteT "$s" #(W64 0) (![#uint64T] "n")) in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$s" := (![#sliceT] (struct.field_ref #Dec #"p"%go (![#ptrT] "d"))) in
    slice.slice #byteT "$s" (![#uint64T] "n") (slice.len "$s")) in
    do:  ((struct.field_ref #Dec #"p"%go (![#ptrT] "d")) <-[#sliceT] "$r0");;;
    return: (![#sliceT] "b")).

(* go: encoding.go:33:15 *)
Definition Dec__UInt64ⁱᵐᵖˡ : val :=
  λ: "d" <>,
    exception_do (let: "d" := (mem.alloc "d") in
    return: (let: "$a0" := (let: "$a0" := #(W64 8) in
     (method_call #(ptrT.id Dec.id) #"consume"%go (![#ptrT] "d")) "$a0") in
     (func_call #primitive.UInt64Get) "$a0")).

(* go: encoding.go:37:15 *)
Definition Dec__UInt32ⁱᵐᵖˡ : val :=
  λ: "d" <>,
    exception_do (let: "d" := (mem.alloc "d") in
    return: (let: "$a0" := (let: "$a0" := #(W64 4) in
     (method_call #(ptrT.id Dec.id) #"consume"%go (![#ptrT] "d")) "$a0") in
     (func_call #primitive.UInt32Get) "$a0")).

Definition Enum1 : go_type := uint64T.
#[global] Typeclasses Opaque Enum1.
#[global] Opaque Enum1.

Definition Enum1A : val := #(W64 0).

Definition Enum1B : val := #(W64 1).

Definition Enum1C : val := #(W64 2).

Definition Enum2 : go_type := intT.
#[global] Typeclasses Opaque Enum2.
#[global] Opaque Enum2.

(* line comment 1 *)
Definition Enum2A : val := #(W64 1).

(* line comment 2 *)
Definition Enum2B : Z := 3.

Definition Enum2C : Z := 4.

(* line comment 3 *)
Definition Enum2D : val := #(W64 15).

Definition a : val := float_placeholder.

Definition b : val := float_placeholder.

Definition useFloat : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.useFloat"%go.

(* go: float.go:8:6 *)
Definition useFloatⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (mem.alloc (type.zero_val #float64T)) in
    let: "$r0" := (make_nondet float64T a) in
    do:  ("x" <-[#float64T] "$r0");;;
    let: "$r0" := (make_nondet float64T (make_nondet float64T (![#float64T] "x", make_nondet float64T a), make_nondet float64T float_placeholder)) in
    do:  ("x" <-[#float64T] "$r0");;;
    return: (![#float64T] "x")).

Definition compareIntFloat : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.compareIntFloat"%go.

(* go: float.go:14:6 *)
Definition compareIntFloatⁱᵐᵖˡ : val :=
  λ: "x",
    exception_do (let: "x" := (mem.alloc "x") in
    return: (int_lt (![#intT] "x") #(W64 1000000))).

Definition compareFloatInt : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.compareFloatInt"%go.

(* go: float.go:18:6 *)
Definition compareFloatIntⁱᵐᵖˡ : val :=
  λ: "x",
    exception_do (let: "x" := (mem.alloc "x") in
    return: (int_lt #(W64 1000000) (![#intT] "x"))).

Definition forRangeNoBinding : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.forRangeNoBinding"%go.

(* go: for_range.go:5:6 *)
Definition forRangeNoBindingⁱᵐᵖˡ : val :=
  λ: "x",
    exception_do (let: "x" := (mem.alloc "x") in
    let: "$range" := (![#sliceT] "x") in
    slice.for_range #stringT "$range" (λ: "$key" "$value",
      do:  (let: "$a0" := ((let: "$sl0" := (interface.make #(sliceT.id stringT.id) (![#sliceT] "x")) in
      slice.literal #interfaceT ["$sl0"])) in
      (func_call #fmt.Print) "$a0"));;;
    return: #()).

Definition forRangeOldVars : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.forRangeOldVars"%go.

(* go: for_range.go:11:6 *)
Definition forRangeOldVarsⁱᵐᵖˡ : val :=
  λ: "x",
    exception_do (let: "x" := (mem.alloc "x") in
    let: "y" := (mem.alloc (type.zero_val #stringT)) in
    let: "$r0" := #"ok"%go in
    do:  ("y" <-[#stringT] "$r0");;;
    let: "$range" := (![#sliceT] "x") in
    slice.for_range #stringT "$range" (λ: "$key" "$value",
      do:  ("y" <-[#stringT] "$value");;;
      do:  "$key";;;
      do:  (let: "$a0" := ((let: "$sl0" := (interface.make #stringT.id (![#stringT] "y")) in
      slice.literal #interfaceT ["$sl0"])) in
      (func_call #fmt.Print) "$a0"));;;
    return: #()).

Definition foo : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.foo"%go.

(* go: globals.go:3:6 *)
Definition fooⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (#(W64 10))).

Definition GlobalX : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.GlobalX"%go.

Definition globalY : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.globalY"%go.

Definition globalA : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.globalA"%go.

Definition globalB : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.globalB"%go.

Definition other : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.other"%go.

(* go: globals.go:14:6 *)
Definition otherⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "$r0" := #"ok"%go in
    do:  ((globals.get #globalY) <-[#stringT] "$r0");;;
    return: #()).

Definition bar : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.bar"%go.

(* go: globals.go:18:6 *)
Definition barⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (do:  ((func_call #other) #());;;
    (if: ((![#uint64T] (globals.get #GlobalX)) ≠ #(W64 10)) || ((![#stringT] (globals.get #globalY)) ≠ #"ok"%go)
    then
      do:  (let: "$a0" := (interface.make #stringT.id #"bad"%go) in
      Panic "$a0")
    else do:  #());;;
    return: #()).

Definition TakesFunctionType : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.TakesFunctionType"%go.

(* go: higher_order.go:3:6 *)
Definition TakesFunctionTypeⁱᵐᵖˡ : val :=
  λ: "f",
    exception_do (let: "f" := (mem.alloc "f") in
    do:  ((![#funcT] "f") #());;;
    return: #()).

Definition FuncVar : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.FuncVar"%go.

(* go: higher_order.go:7:6 *)
Definition FuncVarⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "f" := (mem.alloc (type.zero_val #funcT)) in
    let: "$r0" := (![#funcT] "f") in
    do:  "$r0";;;
    return: #()).

Definition Fooer : go_type := interfaceT.
#[global] Typeclasses Opaque Fooer.
#[global] Opaque Fooer.

Definition concreteFooer : go_type := structT [
  "a" :: uint64T
].
#[global] Typeclasses Opaque concreteFooer.
#[global] Opaque concreteFooer.

Definition FooerUser : go_type := structT [
  "f" :: Fooer
].
#[global] Typeclasses Opaque FooerUser.
#[global] Opaque FooerUser.

(* go: interfaces.go:15:25 *)
Definition concreteFooer__Fooⁱᵐᵖˡ : val :=
  λ: "f" <>,
    exception_do (let: "f" := (mem.alloc "f") in
    do:  #()).

Definition fooConsumer : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.fooConsumer"%go.

(* go: interfaces.go:18:6 *)
Definition fooConsumerⁱᵐᵖˡ : val :=
  λ: "f",
    exception_do (let: "f" := (mem.alloc "f") in
    do:  ((interface.get #"Foo"%go (![#Fooer] "f")) #());;;
    return: #()).

Definition testAssignConcreteToInterface : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.testAssignConcreteToInterface"%go.

(* go: interfaces.go:22:6 *)
Definition testAssignConcreteToInterfaceⁱᵐᵖˡ : val :=
  λ: "x",
    exception_do (let: "x" := (mem.alloc "x") in
    let: "c" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (struct.make #concreteFooer [{
      "a" ::= type.zero_val #uint64T
    }])) in
    do:  ("c" <-[#ptrT] "$r0");;;
    let: "$r0" := (interface.make #(ptrT.id concreteFooer.id) (![#ptrT] "c")) in
    do:  ((![#ptrT] "x") <-[#Fooer] "$r0");;;
    return: #()).

Definition testPassConcreteToInterfaceArg : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.testPassConcreteToInterfaceArg"%go.

(* go: interfaces.go:27:6 *)
Definition testPassConcreteToInterfaceArgⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "c" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (struct.make #concreteFooer [{
      "a" ::= type.zero_val #uint64T
    }])) in
    do:  ("c" <-[#ptrT] "$r0");;;
    do:  (let: "$a0" := (interface.make #(ptrT.id concreteFooer.id) (![#ptrT] "c")) in
    (func_call #fooConsumer) "$a0");;;
    let: "f" := (mem.alloc (type.zero_val #Fooer)) in
    let: "$r0" := (interface.make #(ptrT.id concreteFooer.id) (![#ptrT] "c")) in
    do:  ("f" <-[#Fooer] "$r0");;;
    do:  (let: "$a0" := (![#Fooer] "f") in
    (func_call #fooConsumer) "$a0");;;
    do:  ((method_call #(ptrT.id concreteFooer.id) #"Foo"%go (![#ptrT] "c")) #());;;
    do:  ((interface.get #"Foo"%go (![#Fooer] "f")) #());;;
    return: #()).

Definition testPassConcreteToInterfaceArgSpecial : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.testPassConcreteToInterfaceArgSpecial"%go.

(* go: interfaces.go:37:6 *)
Definition testPassConcreteToInterfaceArgSpecialⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "c1" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (struct.make #concreteFooer [{
      "a" ::= type.zero_val #uint64T
    }])) in
    do:  ("c1" <-[#ptrT] "$r0");;;
    let: "c2" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (struct.make #concreteFooer [{
      "a" ::= type.zero_val #uint64T
    }])) in
    do:  ("c2" <-[#ptrT] "$r0");;;
    let: "l" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := ((let: "$sl0" := (interface.make #(ptrT.id concreteFooer.id) (![#ptrT] "c1")) in
    let: "$sl1" := (interface.make #(ptrT.id concreteFooer.id) (![#ptrT] "c2")) in
    slice.literal #Fooer ["$sl0"; "$sl1"])) in
    do:  ("l" <-[#sliceT] "$r0");;;
    let: "m" := (mem.alloc (type.zero_val (type.mapT #uint64T #Fooer))) in
    let: "$r0" := (map.make #uint64T #Fooer) in
    do:  ("m" <-[type.mapT #uint64T #Fooer] "$r0");;;
    let: "$r0" := (interface.make #(ptrT.id concreteFooer.id) (![#ptrT] "c1")) in
    do:  (map.insert (![type.mapT #uint64T #Fooer] "m") #(W64 10) "$r0");;;
    let: "f" := (mem.alloc (type.zero_val #FooerUser)) in
    let: "$r0" := (struct.make #FooerUser [{
      "f" ::= interface.make #(ptrT.id concreteFooer.id) (![#ptrT] "c1")
    }]) in
    do:  ("f" <-[#FooerUser] "$r0");;;
    return: (![#sliceT] "l", ![type.mapT #uint64T #Fooer] "m", ![#FooerUser] "f")).

Definition takesVarArgsInterface : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.takesVarArgsInterface"%go.

(* go: interfaces.go:51:6 *)
Definition takesVarArgsInterfaceⁱᵐᵖˡ : val :=
  λ: "fs",
    exception_do (let: "fs" := (mem.alloc "fs") in
    do:  ((interface.get #"Foo"%go (![#Fooer] (slice.elem_ref #Fooer (![#sliceT] "fs") #(W64 0)))) #());;;
    return: #()).

Definition test : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.test"%go.

(* go: interfaces.go:55:6 *)
Definition testⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (do:  (let: "$a0" := ((let: "$sl0" := (interface.make #(ptrT.id concreteFooer.id) (mem.alloc (struct.make #concreteFooer [{
      "a" ::= type.zero_val #uint64T
    }]))) in
    let: "$sl1" := (interface.make #(ptrT.id concreteFooer.id) (mem.alloc (struct.make #concreteFooer [{
      "a" ::= type.zero_val #uint64T
    }]))) in
    slice.literal #Fooer ["$sl0"; "$sl1"])) in
    (func_call #takesVarArgsInterface) "$a0");;;
    return: #()).

Definition returnConcrete : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.returnConcrete"%go.

(* go: interfaces.go:59:6 *)
Definition returnConcreteⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (mem.alloc (struct.make #concreteFooer [{
       "a" ::= type.zero_val #uint64T
     }]), #(W64 10))).

Definition testMultiReturn : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.testMultiReturn"%go.

(* converts an object into an interface in a multiple return destructuring statement.

   go: interfaces.go:64:6 *)
Definition testMultiReturnⁱᵐᵖˡ : val :=
  λ: "x",
    exception_do (let: "x" := (mem.alloc "x") in
    let: "y" := (mem.alloc (type.zero_val #uint64T)) in
    let: ("$ret0", "$ret1") := ((func_call #returnConcrete) #()) in
    let: "$r0" := (interface.make #(ptrT.id concreteFooer.id) "$ret0") in
    let: "$r1" := "$ret1" in
    do:  ((![#ptrT] "x") <-[#Fooer] "$r0");;;
    do:  ("y" <-[#uint64T] "$r1");;;
    return: (![#uint64T] "y")).

Definition testReturnStatment : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.testReturnStatment"%go.

(* go: interfaces.go:70:6 *)
Definition testReturnStatmentⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "y" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (struct.make #concreteFooer [{
      "a" ::= type.zero_val #uint64T
    }])) in
    do:  ("y" <-[#ptrT] "$r0");;;
    return: (interface.make #(ptrT.id concreteFooer.id) (![#ptrT] "y"))).

Definition testConversionInEq : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.testConversionInEq"%go.

(* go: interfaces.go:75:6 *)
Definition testConversionInEqⁱᵐᵖˡ : val :=
  λ: "f",
    exception_do (let: "f" := (mem.alloc "f") in
    let: "c" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (struct.make #concreteFooer [{
      "a" ::= type.zero_val #uint64T
    }])) in
    do:  ("c" <-[#ptrT] "$r0");;;
    let: "$r0" := (interface.make #(ptrT.id concreteFooer.id) (![#ptrT] "c")) in
    do:  ("f" <-[#Fooer] "$r0");;;
    return: (interface.eq (interface.make #(ptrT.id concreteFooer.id) (![#ptrT] "c")) (![#Fooer] "f"))).

Definition takeMultiple : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.takeMultiple"%go.

(* go: interfaces.go:82:6 *)
Definition takeMultipleⁱᵐᵖˡ : val :=
  λ: "a" "f",
    exception_do (let: "f" := (mem.alloc "f") in
    let: "a" := (mem.alloc "a") in
    do:  #()).

Definition giveMultiple : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.giveMultiple"%go.

(* go: interfaces.go:85:6 *)
Definition giveMultipleⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (#(W64 0), interface.make #(ptrT.id concreteFooer.id) (mem.alloc (struct.make #concreteFooer [{
       "a" ::= type.zero_val #uint64T
     }])), mem.alloc (struct.make #concreteFooer [{
       "a" ::= type.zero_val #uint64T
     }]))).

Definition testConversionInMultipleReturnPassThrough : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.testConversionInMultipleReturnPassThrough"%go.

(* go: interfaces.go:89:6 *)
Definition testConversionInMultipleReturnPassThroughⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: (("$ret0", "$ret1"), "$ret2") := (((func_call #giveMultiple) #())) in
    return: ("$ret0", "$ret1", interface.make #(ptrT.id concreteFooer.id) "$ret2")).

Definition testConversionInMultiplePassThrough : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.testConversionInMultiplePassThrough"%go.

(* See "special case" in https://go.dev/ref/spec#Calls

   go: interfaces.go:94:6 *)
Definition testConversionInMultiplePassThroughⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (do:  (let: (("$ret0", "$ret1"), "$ret2") := (((func_call #giveMultiple) #())) in
    let: "$a0" := "$ret0" in
    let: "$a1" := ((let: "$sl0" := "$ret1" in
    let: "$sl1" := (interface.make #(ptrT.id concreteFooer.id) "$ret2") in
    slice.literal #Fooer ["$sl0"; "$sl1"])) in
    (func_call #takeMultiple) "$a0" "$a1");;;
    return: #()).

Definition PointerInterface : go_type := interfaceT.
#[global] Typeclasses Opaque PointerInterface.
#[global] Opaque PointerInterface.

Definition concrete1 : go_type := structT [
].
#[global] Typeclasses Opaque concrete1.
#[global] Opaque concrete1.

(* go: interfaces.go:106:20 *)
Definition concrete1__Fooⁱᵐᵖˡ : val :=
  λ: "c" <>,
    exception_do (let: "c" := (mem.alloc "c") in
    do:  #()).

(* go: interfaces.go:109:21 *)
Definition concrete1__Bⁱᵐᵖˡ : val :=
  λ: "c" <>,
    exception_do (let: "c" := (mem.alloc "c") in
    do:  #()).

Definition testPtrMset : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.testPtrMset"%go.

(* go: interfaces.go:112:6 *)
Definition testPtrMsetⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "a" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (struct.make #concrete1 [{
    }])) in
    do:  ("a" <-[#ptrT] "$r0");;;
    let: "p" := (mem.alloc (type.zero_val #PointerInterface)) in
    let: "$r0" := (interface.make #(ptrT.id concrete1.id) (![#ptrT] "a")) in
    do:  ("p" <-[#PointerInterface] "$r0");;;
    let: "f" := (mem.alloc (type.zero_val #Fooer)) in
    let: "$r0" := (interface.make #concrete1.id (![#concrete1] (![#ptrT] "a"))) in
    do:  ("f" <-[#Fooer] "$r0");;;
    do:  ((interface.get #"B"%go (![#PointerInterface] "p")) #());;;
    do:  ((interface.get #"Foo"%go (![#Fooer] "f")) #());;;
    return: #()).

Definition useInts : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.useInts"%go.

(* go: ints.go:3:6 *)
Definition useIntsⁱᵐᵖˡ : val :=
  λ: "x" "y",
    exception_do (let: "y" := (mem.alloc "y") in
    let: "x" := (mem.alloc "x") in
    let: "z" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (u_to_w64 (![#uint32T] "y")) in
    do:  ("z" <-[#uint64T] "$r0");;;
    let: "$r0" := ((![#uint64T] "z") + #(W64 1)) in
    do:  ("z" <-[#uint64T] "$r0");;;
    let: "y2" := (mem.alloc (type.zero_val #uint32T)) in
    let: "$r0" := ((![#uint32T] "y") + #(W32 3)) in
    do:  ("y2" <-[#uint32T] "$r0");;;
    return: (![#uint64T] "z", ![#uint32T] "y2")).

Definition signedMidpoint : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.signedMidpoint"%go.

(* go: ints.go:12:6 *)
Definition signedMidpointⁱᵐᵖˡ : val :=
  λ: "x" "y",
    exception_do (let: "y" := (mem.alloc "y") in
    let: "x" := (mem.alloc "x") in
    return: (((![#intT] "x") + (![#intT] "y")) `quots` #(W64 2))).

Definition my_u32 : go_type := uint32T.
#[global] Typeclasses Opaque my_u32.
#[global] Opaque my_u32.

Definition also_u32 : go_type := my_u32.
#[global] Typeclasses Opaque also_u32.
#[global] Opaque also_u32.

Definition ConstWithAbbrevType : val := #(W32 3).

Definition allTheLiterals : go_type := structT [
  "int" :: uint64T;
  "s" :: stringT;
  "b" :: boolT
].
#[global] Typeclasses Opaque allTheLiterals.
#[global] Opaque allTheLiterals.

Definition normalLiterals : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.normalLiterals"%go.

(* go: literals.go:9:6 *)
Definition normalLiteralsⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (let: "$int" := #(W64 0) in
     let: "$s" := #"foo"%go in
     let: "$b" := #true in
     struct.make #allTheLiterals [{
       "int" ::= "$int";
       "s" ::= "$s";
       "b" ::= "$b"
     }])).

Definition outOfOrderLiteral : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.outOfOrderLiteral"%go.

(* go: literals.go:17:6 *)
Definition outOfOrderLiteralⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (let: "$b" := #true in
     let: "$s" := #"foo"%go in
     let: "$int" := #(W64 0) in
     struct.make #allTheLiterals [{
       "int" ::= "$int";
       "s" ::= "$s";
       "b" ::= "$b"
     }])).

Definition specialLiterals : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.specialLiterals"%go.

(* go: literals.go:25:6 *)
Definition specialLiteralsⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (let: "$int" := #(W64 4096) in
     let: "$s" := #""%go in
     let: "$b" := #false in
     struct.make #allTheLiterals [{
       "int" ::= "$int";
       "s" ::= "$s";
       "b" ::= "$b"
     }])).

Definition oddLiterals : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.oddLiterals"%go.

(* go: literals.go:33:6 *)
Definition oddLiteralsⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (let: "$int" := #(W64 5) in
     let: "$s" := #"backquote string"%go in
     let: "$b" := #false in
     struct.make #allTheLiterals [{
       "int" ::= "$int";
       "s" ::= "$s";
       "b" ::= "$b"
     }])).

Definition unKeyedLiteral : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.unKeyedLiteral"%go.

(* go: literals.go:41:6 *)
Definition unKeyedLiteralⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (struct.make #allTheLiterals [{
       "int" ::= #(W64 0);
       "s" ::= #"a"%go;
       "b" ::= #false
     }])).

Definition useLocks : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.useLocks"%go.

(* go: locks.go:5:6 *)
Definition useLocksⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "m" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #sync.Mutex)) in
    do:  ("m" <-[#ptrT] "$r0");;;
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] "m")) #());;;
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] "m")) #());;;
    return: #()).

Definition useCondVar : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.useCondVar"%go.

(* go: locks.go:11:6 *)
Definition useCondVarⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "m" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #sync.Mutex)) in
    do:  ("m" <-[#ptrT] "$r0");;;
    let: "c" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := (interface.make #(ptrT.id sync.Mutex.id) (![#ptrT] "m")) in
    (func_call #sync.NewCond) "$a0") in
    do:  ("c" <-[#ptrT] "$r0");;;
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] "m")) #());;;
    do:  ((method_call #(ptrT.id sync.Cond.id) #"Signal"%go (![#ptrT] "c")) #());;;
    do:  ((method_call #(ptrT.id sync.Cond.id) #"Wait"%go (![#ptrT] "c")) #());;;
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] "m")) #());;;
    return: #()).

Definition hasCondVar : go_type := structT [
  "cond" :: ptrT
].
#[global] Typeclasses Opaque hasCondVar.
#[global] Opaque hasCondVar.

Definition ToBeDebugged : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.ToBeDebugged"%go.

(* go: log_debugging.go:5:6 *)
Definition ToBeDebuggedⁱᵐᵖˡ : val :=
  λ: "x",
    exception_do (let: "x" := (mem.alloc "x") in
    do:  (let: "$a0" := ((let: "$sl0" := (interface.make #stringT.id #"starting function"%go) in
    slice.literal #interfaceT ["$sl0"])) in
    (func_call #log.Println) "$a0");;;
    do:  (let: "$a0" := #"called with %d"%go in
    let: "$a1" := ((let: "$sl0" := (interface.make #uint64T.id (![#uint64T] "x")) in
    slice.literal #interfaceT ["$sl0"])) in
    (func_call #log.Printf) "$a0" "$a1");;;
    do:  (let: "$a0" := ((let: "$sl0" := (interface.make #stringT.id #"ending function"%go) in
    slice.literal #interfaceT ["$sl0"])) in
    (func_call #log.Println) "$a0");;;
    return: (![#uint64T] "x")).

Definition DoNothing : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.DoNothing"%go.

(* go: log_debugging.go:12:6 *)
Definition DoNothingⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (do:  (let: "$a0" := ((let: "$sl0" := (interface.make #stringT.id #"doing nothing"%go) in
    slice.literal #interfaceT ["$sl0"])) in
    (func_call #log.Println) "$a0");;;
    return: #()).

Definition DoSomething : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.DoSomething"%go.

(* DoSomething is an impure function

   go: loops.go:4:6 *)
Definition DoSomethingⁱᵐᵖˡ : val :=
  λ: "s",
    exception_do (let: "s" := (mem.alloc "s") in
    do:  #()).

Definition standardForLoop : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.standardForLoop"%go.

(* go: loops.go:6:6 *)
Definition standardForLoopⁱᵐᵖˡ : val :=
  λ: "s",
    exception_do (let: "s" := (mem.alloc "s") in
    let: "sumPtr" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #uint64T)) in
    do:  ("sumPtr" <-[#ptrT] "$r0");;;
    (let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (if: (![#uint64T] "i") < (s_to_w64 (let: "$a0" := (![#sliceT] "s") in
      slice.len "$a0"))
      then
        let: "sum" := (mem.alloc (type.zero_val #uint64T)) in
        let: "$r0" := (![#uint64T] (![#ptrT] "sumPtr")) in
        do:  ("sum" <-[#uint64T] "$r0");;;
        let: "x" := (mem.alloc (type.zero_val #uint64T)) in
        let: "$r0" := (![#uint64T] (slice.elem_ref #uint64T (![#sliceT] "s") (![#uint64T] "i"))) in
        do:  ("x" <-[#uint64T] "$r0");;;
        let: "$r0" := ((![#uint64T] "sum") + (![#uint64T] "x")) in
        do:  ((![#ptrT] "sumPtr") <-[#uint64T] "$r0");;;
        let: "$r0" := ((![#uint64T] "i") + #(W64 1)) in
        do:  ("i" <-[#uint64T] "$r0");;;
        continue: #()
      else do:  #());;;
      break: #()));;;
    let: "sum" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (![#uint64T] (![#ptrT] "sumPtr")) in
    do:  ("sum" <-[#uint64T] "$r0");;;
    return: (![#uint64T] "sum")).

Definition conditionalInLoop : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.conditionalInLoop"%go.

(* go: loops.go:25:6 *)
Definition conditionalInLoopⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do ((let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (if: (![#uint64T] "i") < #(W64 3)
      then
        do:  (let: "$a0" := #"i is small"%go in
        (func_call #DoSomething) "$a0")
      else do:  #());;;
      (if: (![#uint64T] "i") > #(W64 5)
      then break: #()
      else do:  #());;;
      let: "$r0" := ((![#uint64T] "i") + #(W64 1)) in
      do:  ("i" <-[#uint64T] "$r0");;;
      continue: #()));;;
    return: #()).

Definition conditionalInLoopElse : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.conditionalInLoopElse"%go.

(* go: loops.go:38:6 *)
Definition conditionalInLoopElseⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do ((let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (if: (![#uint64T] "i") > #(W64 5)
      then break: #()
      else
        let: "$r0" := ((![#uint64T] "i") + #(W64 1)) in
        do:  ("i" <-[#uint64T] "$r0");;;
        continue: #())));;;
    return: #()).

Definition nestedConditionalInLoopImplicitContinue : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.nestedConditionalInLoopImplicitContinue"%go.

(* go: loops.go:49:6 *)
Definition nestedConditionalInLoopImplicitContinueⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do ((let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (if: (![#uint64T] "i") > #(W64 5)
      then
        (if: (![#uint64T] "i") > #(W64 10)
        then break: #()
        else do:  #())
      else
        let: "$r0" := ((![#uint64T] "i") + #(W64 1)) in
        do:  ("i" <-[#uint64T] "$r0");;;
        continue: #())));;;
    return: #()).

Definition ImplicitLoopContinue : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.ImplicitLoopContinue"%go.

(* go: loops.go:62:6 *)
Definition ImplicitLoopContinueⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do ((let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (if: (![#uint64T] "i") < #(W64 4)
      then
        let: "$r0" := #(W64 0) in
        do:  ("i" <-[#uint64T] "$r0")
      else do:  #())));;;
    return: #()).

Definition ImplicitLoopContinue2 : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.ImplicitLoopContinue2"%go.

(* go: loops.go:70:6 *)
Definition ImplicitLoopContinue2ⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do ((let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (if: (![#uint64T] "i") < #(W64 4)
      then
        let: "$r0" := #(W64 0) in
        do:  ("i" <-[#uint64T] "$r0");;;
        continue: #()
      else do:  #())));;;
    return: #()).

Definition ImplicitLoopContinueAfterIfBreak : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.ImplicitLoopContinueAfterIfBreak"%go.

(* go: loops.go:79:6 *)
Definition ImplicitLoopContinueAfterIfBreakⁱᵐᵖˡ : val :=
  λ: "i",
    exception_do (let: "i" := (mem.alloc "i") in
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (if: (![#uint64T] "i") > #(W64 0)
      then break: #()
      else do:  #()));;;
    return: #()).

Definition nestedLoops : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.nestedLoops"%go.

(* go: loops.go:87:6 *)
Definition nestedLoopsⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do ((let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (let: "j" := (mem.alloc (type.zero_val #uint64T)) in
      let: "$r0" := #(W64 0) in
      do:  ("j" <-[#uint64T] "$r0");;;
      (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
        (if: #true
        then break: #()
        else do:  #());;;
        let: "$r0" := ((![#uint64T] "j") + #(W64 1)) in
        do:  ("j" <-[#uint64T] "$r0");;;
        continue: #()));;;
      let: "$r0" := ((![#uint64T] "i") + #(W64 1)) in
      do:  ("i" <-[#uint64T] "$r0");;;
      continue: #()));;;
    return: #()).

Definition nestedGoStyleLoops : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.nestedGoStyleLoops"%go.

(* go: loops.go:101:6 *)
Definition nestedGoStyleLoopsⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do ((let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (for: (λ: <>, (![#uint64T] "i") < #(W64 10)); (λ: <>, do:  ("i" <-[#uint64T] ((![#uint64T] "i") + #(W64 1)))) := λ: <>,
      (let: "j" := (mem.alloc (type.zero_val #uint64T)) in
      let: "$r0" := #(W64 0) in
      do:  ("j" <-[#uint64T] "$r0");;;
      (for: (λ: <>, (![#uint64T] "j") < (![#uint64T] "i")); (λ: <>, do:  ("j" <-[#uint64T] ((![#uint64T] "j") + #(W64 1)))) := λ: <>,
        (if: #true
        then break: #()
        else do:  #());;;
        continue: #()))));;;
    return: #()).

Definition sumSlice : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.sumSlice"%go.

(* go: loops.go:113:6 *)
Definition sumSliceⁱᵐᵖˡ : val :=
  λ: "xs",
    exception_do (let: "xs" := (mem.alloc "xs") in
    let: "sum" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$range" := (![#sliceT] "xs") in
    (let: "x" := (mem.alloc (type.zero_val #uint64T)) in
    slice.for_range #uint64T "$range" (λ: "$key" "$value",
      do:  ("x" <-[#uint64T] "$value");;;
      do:  "$key";;;
      do:  ("sum" <-[#uint64T] ((![#uint64T] "sum") + (![#uint64T] "x")))));;;
    return: (![#uint64T] "sum")).

Definition intSliceLoop : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.intSliceLoop"%go.

(* go: loops.go:121:6 *)
Definition intSliceLoopⁱᵐᵖˡ : val :=
  λ: "xs",
    exception_do (let: "xs" := (mem.alloc "xs") in
    let: "sum" := (mem.alloc (type.zero_val #uint64T)) in
    (let: "i" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[#intT] "$r0");;;
    (for: (λ: <>, int_lt (![#intT] "i") (let: "$a0" := (![#sliceT] "xs") in
    slice.len "$a0")); (λ: <>, do:  ("i" <-[#intT] ((![#intT] "i") + #(W64 1)))) := λ: <>,
      do:  ("sum" <-[#uint64T] ((![#uint64T] "sum") + (![#uint64T] (slice.elem_ref #uint64T (![#sliceT] "xs") (![#intT] "i")))))));;;
    return: (![#uint64T] "sum")).

Definition breakFromLoop : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.breakFromLoop"%go.

(* go: loops.go:129:6 *)
Definition breakFromLoopⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do ((for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (if: #true
      then break: #()
      else do:  #());;;
      continue: #());;;
    return: #()).

Definition IterateMapKeys : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.IterateMapKeys"%go.

(* go: maps.go:3:6 *)
Definition IterateMapKeysⁱᵐᵖˡ : val :=
  λ: "m" "sum",
    exception_do (let: "sum" := (mem.alloc "sum") in
    let: "m" := (mem.alloc "m") in
    let: "$range" := (![type.mapT #uint64T #uint64T] "m") in
    (let: "k" := (mem.alloc (type.zero_val #uint64T)) in
    map.for_range "$range" (λ: "$key" "value",
      do:  ("k" <-[#uint64T] "$key");;;
      let: "oldSum" := (mem.alloc (type.zero_val #uint64T)) in
      let: "$r0" := (![#uint64T] (![#ptrT] "sum")) in
      do:  ("oldSum" <-[#uint64T] "$r0");;;
      let: "$r0" := ((![#uint64T] "oldSum") + (![#uint64T] "k")) in
      do:  ((![#ptrT] "sum") <-[#uint64T] "$r0")));;;
    return: #()).

Definition MapSize : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.MapSize"%go.

(* go: maps.go:10:6 *)
Definition MapSizeⁱᵐᵖˡ : val :=
  λ: "m",
    exception_do (let: "m" := (mem.alloc "m") in
    return: (s_to_w64 (let: "$a0" := (![type.mapT #uint64T #boolT] "m") in
     map.len "$a0"))).

Definition IntWrapper : go_type := uint64T.
#[global] Typeclasses Opaque IntWrapper.
#[global] Opaque IntWrapper.

Definition MapWrapper : go_type := mapT uint64T boolT.
#[global] Typeclasses Opaque MapWrapper.
#[global] Opaque MapWrapper.

Definition MapTypeAliases : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.MapTypeAliases"%go.

(* go: maps.go:18:6 *)
Definition MapTypeAliasesⁱᵐᵖˡ : val :=
  λ: "m1" "m2",
    exception_do (let: "m2" := (mem.alloc "m2") in
    let: "m1" := (mem.alloc "m1") in
    let: "$r0" := (Fst (map.get (![#MapWrapper] "m2") #(W64 0))) in
    do:  (map.insert (![type.mapT #IntWrapper #boolT] "m1") #(W64 4) "$r0");;;
    return: #()).

Definition StringMap : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.StringMap"%go.

(* go: maps.go:22:6 *)
Definition StringMapⁱᵐᵖˡ : val :=
  λ: "m",
    exception_do (let: "m" := (mem.alloc "m") in
    return: (Fst (map.get (![type.mapT #stringT #uint64T] "m") #"foo"%go))).

Definition mapElem : go_type := structT [
  "a" :: uint64T;
  "b" :: uint64T
].
#[global] Typeclasses Opaque mapElem.
#[global] Opaque mapElem.

Definition mapUpdateField : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.mapUpdateField"%go.

(* go: maps.go:31:6 *)
Definition mapUpdateFieldⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (mem.alloc (type.zero_val (type.mapT #uint64T #ptrT))) in
    let: "$r0" := (map.make #uint64T #ptrT) in
    do:  ("x" <-[type.mapT #uint64T #ptrT] "$r0");;;
    let: "$r0" := #(W64 10) in
    do:  ((struct.field_ref #mapElem #"a"%go (Fst (map.get (![type.mapT #uint64T #ptrT] "x") #(W64 0)))) <-[#uint64T] "$r0");;;
    return: #()).

Definition mapLiteral : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.mapLiteral"%go.

Definition mapLiteralWithConversion : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.mapLiteralWithConversion"%go.

Definition mapGetCall : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.mapGetCall"%go.

(* go: maps.go:44:6 *)
Definition mapGetCallⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "handlers" := (mem.alloc (type.zero_val (type.mapT #uint64T #funcT))) in
    let: "$r0" := (map.make #uint64T #funcT) in
    do:  ("handlers" <-[type.mapT #uint64T #funcT] "$r0");;;
    let: "$r0" := (λ: <>,
      exception_do (do:  #())
      ) in
    do:  (map.insert (![type.mapT #uint64T #funcT] "handlers") #(W64 0) "$r0");;;
    do:  ((Fst (map.get (![type.mapT #uint64T #funcT] "handlers") #(W64 0))) #());;;
    return: #()).

Definition mapLiteralTest : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.mapLiteralTest"%go.

(* go: maps.go:50:6 *)
Definition mapLiteralTestⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ascii" := (mem.alloc (type.zero_val (type.mapT #stringT #uint64T))) in
    let: "$r0" := ((let: "$v0" := #(W64 97) in
    let: "$k0" := #"a"%go in
    let: "$v1" := #(W64 98) in
    let: "$k1" := #"b"%go in
    let: "$v2" := #(W64 99) in
    let: "$k2" := #"c"%go in
    map.literal #stringT #uint64T [map.kv_entry "$k0" "$v0"; map.kv_entry "$k1" "$v1"; map.kv_entry "$k2" "$v2"])) in
    do:  ("ascii" <-[type.mapT #stringT #uint64T] "$r0");;;
    return: (![type.mapT #stringT #uint64T] "ascii")).

Definition returnTwo : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.returnTwo"%go.

(* go: multiple.go:3:6 *)
Definition returnTwoⁱᵐᵖˡ : val :=
  λ: "p",
    exception_do (let: "p" := (mem.alloc "p") in
    return: (#(W64 0), #(W64 0))).

Definition returnTwoWrapper : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.returnTwoWrapper"%go.

(* go: multiple.go:7:6 *)
Definition returnTwoWrapperⁱᵐᵖˡ : val :=
  λ: "data",
    exception_do (let: "data" := (mem.alloc "data") in
    let: "b" := (mem.alloc (type.zero_val #uint64T)) in
    let: "a" := (mem.alloc (type.zero_val #uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "data") in
    (func_call #returnTwo) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("a" <-[#uint64T] "$r0");;;
    do:  ("b" <-[#uint64T] "$r1");;;
    return: (![#uint64T] "a", ![#uint64T] "b")).

Definition multipleVar : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.multipleVar"%go.

(* go: multiple.go:12:6 *)
Definition multipleVarⁱᵐᵖˡ : val :=
  λ: "x" "y",
    exception_do (let: "y" := (mem.alloc "y") in
    let: "x" := (mem.alloc "x") in
    do:  #()).

Definition multiplePassThrough : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.multiplePassThrough"%go.

(* go: multiple.go:14:6 *)
Definition multiplePassThroughⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (do:  (let: ("$ret0", "$ret1") := ((let: "$a0" := #slice.nil in
    (func_call #returnTwoWrapper) "$a0")) in
    let: "$a0" := "$ret0" in
    let: "$a1" := "$ret1" in
    (func_call #multipleVar) "$a0" "$a1");;;
    return: #()).

Definition multipleReturnPassThrough : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.multipleReturnPassThrough"%go.

(* go: multiple.go:18:6 *)
Definition multipleReturnPassThroughⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: ("$ret0", "$ret1") := ((let: "$a0" := #slice.nil in
    (func_call #returnTwo) "$a0")) in
    return: ("$ret0", "$ret1")).

Definition AssignNilSlice : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.AssignNilSlice"%go.

(* go: nil.go:3:6 *)
Definition AssignNilSliceⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "s" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make2 #sliceT #(W64 4)) in
    do:  ("s" <-[#sliceT] "$r0");;;
    let: "$r0" := #slice.nil in
    do:  ((slice.elem_ref #sliceT (![#sliceT] "s") #(W64 2)) <-[#sliceT] "$r0");;;
    return: #()).

Definition AssignNilPointer : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.AssignNilPointer"%go.

(* go: nil.go:8:6 *)
Definition AssignNilPointerⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "s" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make2 #ptrT #(W64 4)) in
    do:  ("s" <-[#sliceT] "$r0");;;
    let: "$r0" := #null in
    do:  ((slice.elem_ref #ptrT (![#sliceT] "s") #(W64 2)) <-[#ptrT] "$r0");;;
    return: #()).

Definition CompareSliceToNil : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.CompareSliceToNil"%go.

(* go: nil.go:13:6 *)
Definition CompareSliceToNilⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "s" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make2 #byteT #(W64 0)) in
    do:  ("s" <-[#sliceT] "$r0");;;
    return: ((![#sliceT] "s") ≠ #slice.nil)).

Definition ComparePointerToNil : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.ComparePointerToNil"%go.

(* go: nil.go:18:6 *)
Definition ComparePointerToNilⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "s" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #uint64T)) in
    do:  ("s" <-[#ptrT] "$r0");;;
    return: ((![#ptrT] "s") ≠ #null)).

Definition containsPointer : go_type := structT [
  "s" :: ptrT
].
#[global] Typeclasses Opaque containsPointer.
#[global] Opaque containsPointer.

Definition useNilField : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.useNilField"%go.

(* go: nil.go:27:6 *)
Definition useNilFieldⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (mem.alloc (let: "$s" := #null in
     struct.make #containsPointer [{
       "s" ::= "$s"
     }]))).

Definition LogicalOperators : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.LogicalOperators"%go.

(* go: operators.go:3:6 *)
Definition LogicalOperatorsⁱᵐᵖˡ : val :=
  λ: "b1" "b2",
    exception_do (let: "b2" := (mem.alloc "b2") in
    let: "b1" := (mem.alloc "b1") in
    return: (((![#boolT] "b1") && ((![#boolT] "b2") || (![#boolT] "b1"))) && (~ #false))).

Definition LogicalAndEqualityOperators : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.LogicalAndEqualityOperators"%go.

(* go: operators.go:7:6 *)
Definition LogicalAndEqualityOperatorsⁱᵐᵖˡ : val :=
  λ: "b1" "x",
    exception_do (let: "x" := (mem.alloc "x") in
    let: "b1" := (mem.alloc "b1") in
    return: (((![#uint64T] "x") = #(W64 3)) && ((![#boolT] "b1") = #true))).

Definition ArithmeticShifts : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.ArithmeticShifts"%go.

(* go: operators.go:11:6 *)
Definition ArithmeticShiftsⁱᵐᵖˡ : val :=
  λ: "x" "y",
    exception_do (let: "y" := (mem.alloc "y") in
    let: "x" := (mem.alloc "x") in
    return: (#(W64 0))).

Definition BitwiseOps : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.BitwiseOps"%go.

(* go: operators.go:16:6 *)
Definition BitwiseOpsⁱᵐᵖˡ : val :=
  λ: "x" "y",
    exception_do (let: "y" := (mem.alloc "y") in
    let: "x" := (mem.alloc "x") in
    return: ((u_to_w64 (![#uint32T] "x")) `or` ((u_to_w64 (u_to_w32 (![#uint64T] "y"))) `and` #(W64 43)))).

Definition Comparison : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.Comparison"%go.

(* go: operators.go:20:6 *)
Definition Comparisonⁱᵐᵖˡ : val :=
  λ: "x" "y",
    exception_do (let: "y" := (mem.alloc "y") in
    let: "x" := (mem.alloc "x") in
    (if: (![#uint64T] "x") < (![#uint64T] "y")
    then return: (#true)
    else do:  #());;;
    (if: (![#uint64T] "x") = (![#uint64T] "y")
    then return: (#true)
    else do:  #());;;
    (if: (![#uint64T] "x") ≠ (![#uint64T] "y")
    then return: (#true)
    else do:  #());;;
    (if: (![#uint64T] "x") > (![#uint64T] "y")
    then return: (#true)
    else do:  #());;;
    (if: ((![#uint64T] "x") + #(W64 1)) > ((![#uint64T] "y") - #(W64 2))
    then return: (#true)
    else do:  #());;;
    return: (#false)).

Definition AssignOps : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.AssignOps"%go.

(* go: operators.go:39:6 *)
Definition AssignOpsⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (mem.alloc (type.zero_val #uint64T)) in
    do:  ("x" <-[#uint64T] ((![#uint64T] "x") + #(W64 3)));;;
    do:  ("x" <-[#uint64T] ((![#uint64T] "x") - #(W64 3)));;;
    do:  ("x" <-[#uint64T] ((![#uint64T] "x") + #(W64 1)));;;
    do:  ("x" <-[#uint64T] ((![#uint64T] "x") - #(W64 1)));;;
    return: #()).

Definition BitwiseAndNot : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.BitwiseAndNot"%go.

(* go: operators.go:47:6 *)
Definition BitwiseAndNotⁱᵐᵖˡ : val :=
  λ: "x" "y",
    exception_do (let: "y" := (mem.alloc "y") in
    let: "x" := (mem.alloc "x") in
    let: "z" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := ((u_to_w64 (![#uint32T] "x")) `and_not` (![#uint64T] "y")) in
    do:  ("z" <-[#uint64T] "$r0");;;
    do:  ("z" <-[#uint64T] ((![#uint64T] "z") `and_not` #(W64 255)));;;
    return: (![#uint64T] "z")).

Definition Negative : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.Negative"%go.

(* go: operators.go:53:6 *)
Definition Negativeⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (mem.alloc (type.zero_val #int64T)) in
    let: "$r0" := #(W64 (- 10)) in
    do:  ("x" <-[#int64T] "$r0");;;
    do:  ("x" <-[#int64T] ((![#int64T] "x") + #(W64 3)));;;
    return: #()).

Definition wrapExternalStruct : go_type := structT [
  "j" :: ptrT
].
#[global] Typeclasses Opaque wrapExternalStruct.
#[global] Opaque wrapExternalStruct.

(* go: package.go:13:29 *)
Definition wrapExternalStruct__joinⁱᵐᵖˡ : val :=
  λ: "w" <>,
    exception_do (let: "w" := (mem.alloc "w") in
    do:  ((method_call #(ptrT.id std.JoinHandle.id) #"Join"%go (![#ptrT] (struct.field_ref #wrapExternalStruct #"j"%go "w"))) #());;;
    return: #()).

Definition PanicAtTheDisco : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.PanicAtTheDisco"%go.

(* go: panic.go:3:6 *)
Definition PanicAtTheDiscoⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (do:  (let: "$a0" := (interface.make #stringT.id #"disco"%go) in
    Panic "$a0");;;
    return: #()).

Definition Oracle : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.Oracle"%go.

(* go: proph.go:5:6 *)
Definition Oracleⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "p" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := ((func_call #primitive.NewProph) #()) in
    do:  ("p" <-[#ptrT] "$r0");;;
    let: "$r0" := (![#ptrT] "p") in
    do:  ("p" <-[#ptrT] "$r0");;;
    return: #()).

Definition typing : go_type := structT [
  "proph" :: ptrT
].
#[global] Typeclasses Opaque typing.
#[global] Opaque typing.

Definition composite : go_type := structT [
  "a" :: uint64T;
  "b" :: uint64T
].
#[global] Typeclasses Opaque composite.
#[global] Opaque composite.

Definition ReassignVars : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.ReassignVars"%go.

(* go: reassign.go:8:6 *)
Definition ReassignVarsⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (mem.alloc (type.zero_val #uint64T)) in
    let: "y" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("y" <-[#uint64T] "$r0");;;
    let: "$r0" := #(W64 3) in
    do:  ("x" <-[#uint64T] "$r0");;;
    let: "z" := (mem.alloc (type.zero_val #composite)) in
    let: "$r0" := (let: "$a" := (![#uint64T] "x") in
    let: "$b" := (![#uint64T] "y") in
    struct.make #composite [{
      "a" ::= "$a";
      "b" ::= "$b"
    }]) in
    do:  ("z" <-[#composite] "$r0");;;
    let: "$r0" := (let: "$a" := (![#uint64T] "y") in
    let: "$b" := (![#uint64T] "x") in
    struct.make #composite [{
      "a" ::= "$a";
      "b" ::= "$b"
    }]) in
    do:  ("z" <-[#composite] "$r0");;;
    let: "$r0" := (![#uint64T] (struct.field_ref #composite #"a"%go "z")) in
    do:  ("x" <-[#uint64T] "$r0");;;
    return: #()).

Definition recur : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.recur"%go.

(* go: recursive.go:3:6 *)
Definition recurⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (do:  ((func_call #recur) #());;;
    return: #()).

Definition R : go_type := structT [
].
#[global] Typeclasses Opaque R.
#[global] Opaque R.

(* go: recursive.go:10:13 *)
Definition R__recurMethodⁱᵐᵖˡ : val :=
  λ: "r" <>,
    exception_do (let: "r" := (mem.alloc "r") in
    do:  ((method_call #(ptrT.id R.id) #"recurMethod"%go (![#ptrT] "r")) #());;;
    return: #()).

Definition Other : go_type := structT [
  "RecursiveEmbedded" :: ptrT
].
#[global] Typeclasses Opaque Other.
#[global] Opaque Other.

Definition RecursiveEmbedded : go_type := structT [
  "Other" :: Other
].
#[global] Typeclasses Opaque RecursiveEmbedded.
#[global] Opaque RecursiveEmbedded.

(* go: recursive.go:22:29 *)
Definition RecursiveEmbedded__recurEmbeddedMethodⁱᵐᵖˡ : val :=
  λ: "r" <>,
    exception_do (let: "r" := (mem.alloc "r") in
    do:  ((method_call #Other.id #"recurEmbeddedMethod"%go (![#Other] (struct.field_ref #RecursiveEmbedded #"Other"%go (![#ptrT] "r")))) #());;;
    return: #()).

Definition useRenamedImport : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.useRenamedImport"%go.

(* go: renamedImport.go:7:6 *)
Definition useRenamedImportⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (do:  (let: "$a0" := ((let: "$sl0" := (interface.make #stringT.id #"blah"%go) in
    slice.literal #interfaceT ["$sl0"])) in
    (func_call #fmt.Print) "$a0");;;
    return: #()).

Definition Block : go_type := structT [
  "Value" :: uint64T
].
#[global] Typeclasses Opaque Block.
#[global] Opaque Block.

Definition Disk1 : val := #(W64 0).

Definition Disk2 : val := #(W64 0).

Definition DiskSize : val := #(W64 1000).

Definition TwoDiskWrite : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.TwoDiskWrite"%go.

(* TwoDiskWrite is a dummy function to represent the base layer's disk write

   go: replicated_disk.go:12:6 *)
Definition TwoDiskWriteⁱᵐᵖˡ : val :=
  λ: "diskId" "a" "v",
    exception_do (let: "v" := (mem.alloc "v") in
    let: "a" := (mem.alloc "a") in
    let: "diskId" := (mem.alloc "diskId") in
    return: (#true)).

Definition TwoDiskRead : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.TwoDiskRead"%go.

(* TwoDiskRead is a dummy function to represent the base layer's disk read

   go: replicated_disk.go:17:6 *)
Definition TwoDiskReadⁱᵐᵖˡ : val :=
  λ: "diskId" "a",
    exception_do (let: "a" := (mem.alloc "a") in
    let: "diskId" := (mem.alloc "diskId") in
    return: (let: "$Value" := #(W64 0) in
     struct.make #Block [{
       "Value" ::= "$Value"
     }], #true)).

Definition TwoDiskLock : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.TwoDiskLock"%go.

(* TwoDiskLock is a dummy function to represent locking an address in the
   base layer

   go: replicated_disk.go:23:6 *)
Definition TwoDiskLockⁱᵐᵖˡ : val :=
  λ: "a",
    exception_do (let: "a" := (mem.alloc "a") in
    do:  #()).

Definition TwoDiskUnlock : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.TwoDiskUnlock"%go.

(* TwoDiskUnlock is a dummy function to represent unlocking an address in the
   base layer

   go: replicated_disk.go:27:6 *)
Definition TwoDiskUnlockⁱᵐᵖˡ : val :=
  λ: "a",
    exception_do (let: "a" := (mem.alloc "a") in
    do:  #()).

Definition ReplicatedDiskRead : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.ReplicatedDiskRead"%go.

(* go: replicated_disk.go:29:6 *)
Definition ReplicatedDiskReadⁱᵐᵖˡ : val :=
  λ: "a",
    exception_do (let: "a" := (mem.alloc "a") in
    do:  (let: "$a0" := (![#uint64T] "a") in
    (func_call #TwoDiskLock) "$a0");;;
    let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "v" := (mem.alloc (type.zero_val #Block)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := Disk1 in
    let: "$a1" := (![#uint64T] "a") in
    (func_call #TwoDiskRead) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("v" <-[#Block] "$r0");;;
    do:  ("ok" <-[#boolT] "$r1");;;
    (if: ![#boolT] "ok"
    then
      do:  (let: "$a0" := (![#uint64T] "a") in
      (func_call #TwoDiskUnlock) "$a0");;;
      return: (![#Block] "v")
    else do:  #());;;
    let: "v2" := (mem.alloc (type.zero_val #Block)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := Disk2 in
    let: "$a1" := (![#uint64T] "a") in
    (func_call #TwoDiskRead) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("v2" <-[#Block] "$r0");;;
    do:  "$r1";;;
    do:  (let: "$a0" := (![#uint64T] "a") in
    (func_call #TwoDiskUnlock) "$a0");;;
    return: (![#Block] "v2")).

Definition ReplicatedDiskWrite : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.ReplicatedDiskWrite"%go.

(* go: replicated_disk.go:42:6 *)
Definition ReplicatedDiskWriteⁱᵐᵖˡ : val :=
  λ: "a" "v",
    exception_do (let: "v" := (mem.alloc "v") in
    let: "a" := (mem.alloc "a") in
    do:  (let: "$a0" := (![#uint64T] "a") in
    (func_call #TwoDiskLock) "$a0");;;
    do:  (let: "$a0" := Disk1 in
    let: "$a1" := (![#uint64T] "a") in
    let: "$a2" := (![#Block] "v") in
    (func_call #TwoDiskWrite) "$a0" "$a1" "$a2");;;
    do:  (let: "$a0" := Disk2 in
    let: "$a1" := (![#uint64T] "a") in
    let: "$a2" := (![#Block] "v") in
    (func_call #TwoDiskWrite) "$a0" "$a1" "$a2");;;
    do:  (let: "$a0" := (![#uint64T] "a") in
    (func_call #TwoDiskUnlock) "$a0");;;
    return: #()).

Definition ReplicatedDiskRecover : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.ReplicatedDiskRecover"%go.

(* go: replicated_disk.go:49:6 *)
Definition ReplicatedDiskRecoverⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do ((let: "a" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("a" <-[#uint64T] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (if: (![#uint64T] "a") > DiskSize
      then break: #()
      else do:  #());;;
      let: "ok" := (mem.alloc (type.zero_val #boolT)) in
      let: "v" := (mem.alloc (type.zero_val #Block)) in
      let: ("$ret0", "$ret1") := (let: "$a0" := Disk1 in
      let: "$a1" := (![#uint64T] "a") in
      (func_call #TwoDiskRead) "$a0" "$a1") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("v" <-[#Block] "$r0");;;
      do:  ("ok" <-[#boolT] "$r1");;;
      (if: ![#boolT] "ok"
      then
        do:  (let: "$a0" := Disk2 in
        let: "$a1" := (![#uint64T] "a") in
        let: "$a2" := (![#Block] "v") in
        (func_call #TwoDiskWrite) "$a0" "$a1" "$a2")
      else do:  #());;;
      let: "$r0" := ((![#uint64T] "a") + #(W64 1)) in
      do:  ("a" <-[#uint64T] "$r0");;;
      continue: #()));;;
    return: #()).

Definition BasicNamedReturn : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.BasicNamedReturn"%go.

(* go: returns.go:3:6 *)
Definition BasicNamedReturnⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (mem.alloc (type.zero_val #stringT)) in
    return: (#"ok"%go)).

Definition NamedReturn : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.NamedReturn"%go.

(* go: returns.go:7:6 *)
Definition NamedReturnⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (mem.alloc (type.zero_val #stringT)) in
    let: "$r0" := ((![#stringT] "x") + #"foo"%go) in
    do:  ("x" <-[#stringT] "$r0");;;
    return: (![#stringT] "x")).

Definition BasicNamedReturnMany : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.BasicNamedReturnMany"%go.

(* go: returns.go:12:6 *)
Definition BasicNamedReturnManyⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "y" := (mem.alloc (type.zero_val #stringT)) in
    let: "x" := (mem.alloc (type.zero_val #stringT)) in
    return: (#"ok"%go, #"blah"%go)).

Definition NamedReturnMany : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.NamedReturnMany"%go.

(* go: returns.go:16:6 *)
Definition NamedReturnManyⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "y" := (mem.alloc (type.zero_val #stringT)) in
    let: "x" := (mem.alloc (type.zero_val #stringT)) in
    let: "$r0" := #"returned"%go in
    do:  ("x" <-[#stringT] "$r0");;;
    let: "$r0" := #"ok"%go in
    do:  ("y" <-[#stringT] "$r0");;;
    return: (![#stringT] "x", ![#stringT] "y")).

Definition NamedReturnOverride : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.NamedReturnOverride"%go.

(* go: returns.go:22:6 *)
Definition NamedReturnOverrideⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "y" := (mem.alloc (type.zero_val #stringT)) in
    let: "x" := (mem.alloc (type.zero_val #stringT)) in
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "x" := (mem.alloc (type.zero_val #stringT)) in
      let: "$r0" := #"unused"%go in
      do:  ("x" <-[#stringT] "$r0");;;
      do:  ("x" <-[#stringT] ((![#stringT] "x") + #"stillUnused"%go));;;
      let: "$r0" := #"ok"%go in
      do:  ("y" <-[#stringT] "$r0");;;
      break: #());;;
    return: (![#stringT] "x", ![#stringT] "y")).

Definition VoidButEndsWithReturn : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.VoidButEndsWithReturn"%go.

(* go: returns.go:32:6 *)
Definition VoidButEndsWithReturnⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (do:  ((func_call #BasicNamedReturn) #());;;
    return: #()).

Definition VoidImplicitReturnInBranch : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.VoidImplicitReturnInBranch"%go.

(* go: returns.go:38:6 *)
Definition VoidImplicitReturnInBranchⁱᵐᵖˡ : val :=
  λ: "b",
    exception_do (let: "b" := (mem.alloc "b") in
    (if: ![#boolT] "b"
    then return: (#())
    else do:  ((func_call #BasicNamedReturn) #()));;;
    return: #()).

Definition SliceAlias : go_type := sliceT.
#[global] Typeclasses Opaque SliceAlias.
#[global] Opaque SliceAlias.

Definition sliceOps : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.sliceOps"%go.

(* go: slices.go:5:6 *)
Definition sliceOpsⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make2 #uint64T #(W64 10)) in
    do:  ("x" <-[#sliceT] "$r0");;;
    let: "v1" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (![#uint64T] (slice.elem_ref #uint64T (![#sliceT] "x") #(W64 2))) in
    do:  ("v1" <-[#uint64T] "$r0");;;
    let: "v2" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$s" := (![#sliceT] "x") in
    slice.slice #uint64T "$s" #(W64 2) #(W64 3)) in
    do:  ("v2" <-[#sliceT] "$r0");;;
    let: "v3" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$s" := (![#sliceT] "x") in
    slice.slice #uint64T "$s" #(W64 0) #(W64 3)) in
    do:  ("v3" <-[#sliceT] "$r0");;;
    let: "v4" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (slice.elem_ref #uint64T (![#sliceT] "x") #(W64 2)) in
    do:  ("v4" <-[#ptrT] "$r0");;;
    return: ((((((![#uint64T] "v1") + (![#uint64T] (slice.elem_ref #uint64T (![#sliceT] "v2") #(W64 0)))) + (![#uint64T] (slice.elem_ref #uint64T (![#sliceT] "v3") #(W64 1)))) + (![#uint64T] (![#ptrT] "v4"))) + (s_to_w64 (let: "$a0" := (![#sliceT] "x") in
     slice.len "$a0"))) + (s_to_w64 (let: "$a0" := (![#sliceT] "x") in
     slice.cap "$a0")))).

Definition makeSingletonSlice : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.makeSingletonSlice"%go.

(* go: slices.go:14:6 *)
Definition makeSingletonSliceⁱᵐᵖˡ : val :=
  λ: "x",
    exception_do (let: "x" := (mem.alloc "x") in
    return: ((let: "$sl0" := (![#uint64T] "x") in
     slice.literal #uint64T ["$sl0"]))).

Definition thing : go_type := structT [
  "x" :: uint64T
].
#[global] Typeclasses Opaque thing.
#[global] Opaque thing.

Definition sliceOfThings : go_type := structT [
  "things" :: sliceT
].
#[global] Typeclasses Opaque sliceOfThings.
#[global] Opaque sliceOfThings.

(* go: slices.go:26:25 *)
Definition sliceOfThings__getThingRefⁱᵐᵖˡ : val :=
  λ: "ts" "i",
    exception_do (let: "ts" := (mem.alloc "ts") in
    let: "i" := (mem.alloc "i") in
    return: (slice.elem_ref #thing (![#sliceT] (struct.field_ref #sliceOfThings #"things"%go "ts")) (![#uint64T] "i"))).

Definition makeAlias : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.makeAlias"%go.

(* go: slices.go:30:6 *)
Definition makeAliasⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (slice.make2 #boolT #(W64 10))).

Definition Skip : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.Skip"%go.

(* Skip is a placeholder for some impure code

   go: spawn.go:8:6 *)
Definition Skipⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (do:  #()).

Definition simpleSpawn : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.simpleSpawn"%go.

(* go: spawn.go:10:6 *)
Definition simpleSpawnⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "l" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #sync.Mutex)) in
    do:  ("l" <-[#ptrT] "$r0");;;
    let: "v" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #uint64T)) in
    do:  ("v" <-[#ptrT] "$r0");;;
    let: "$go" := (λ: <>,
      exception_do (do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] "l")) #());;;
      let: "x" := (mem.alloc (type.zero_val #uint64T)) in
      let: "$r0" := (![#uint64T] (![#ptrT] "v")) in
      do:  ("x" <-[#uint64T] "$r0");;;
      (if: (![#uint64T] "x") > #(W64 0)
      then do:  ((func_call #Skip) #())
      else do:  #());;;
      do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] "l")) #());;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] "l")) #());;;
    let: "$r0" := #(W64 1) in
    do:  ((![#ptrT] "v") <-[#uint64T] "$r0");;;
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] "l")) #());;;
    return: #()).

Definition threadCode : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.threadCode"%go.

(* go: spawn.go:26:6 *)
Definition threadCodeⁱᵐᵖˡ : val :=
  λ: "tid",
    exception_do (let: "tid" := (mem.alloc "tid") in
    do:  #()).

Definition loopSpawn : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.loopSpawn"%go.

(* go: spawn.go:28:6 *)
Definition loopSpawnⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do ((let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (for: (λ: <>, (![#uint64T] "i") < #(W64 10)); (λ: <>, do:  ("i" <-[#uint64T] ((![#uint64T] "i") + #(W64 1)))) := λ: <>,
      let: "i" := (mem.alloc (type.zero_val #uint64T)) in
      let: "$r0" := (![#uint64T] "i") in
      do:  ("i" <-[#uint64T] "$r0");;;
      let: "$go" := (λ: <>,
        exception_do (do:  (let: "$a0" := (![#uint64T] "i") in
        (func_call #threadCode) "$a0");;;
        return: #())
        ) in
      do:  (Fork ("$go" #()))));;;
    (let: "dummy" := (mem.alloc (type.zero_val #boolT)) in
    let: "$r0" := #true in
    do:  ("dummy" <-[#boolT] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "$r0" := (~ (![#boolT] "dummy")) in
      do:  ("dummy" <-[#boolT] "$r0");;;
      continue: #()));;;
    return: #()).

Definition stringAppend : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.stringAppend"%go.

(* go: strings.go:3:6 *)
Definition stringAppendⁱᵐᵖˡ : val :=
  λ: "s",
    exception_do (let: "s" := (mem.alloc "s") in
    return: ((#"prefix "%go + (![#stringT] "s")) + #" "%go)).

Definition stringLength : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.stringLength"%go.

(* go: strings.go:7:6 *)
Definition stringLengthⁱᵐᵖˡ : val :=
  λ: "s",
    exception_do (let: "s" := (mem.alloc "s") in
    return: (s_to_w64 (let: "$a0" := (![#stringT] "s") in
     StringLength "$a0"))).

Definition x : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.x"%go.

(* go: strings.go:11:6 *)
Definition xⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (do:  (let: "$a0" := #("a"%go ++ "b"%go) in
    (func_call #stringAppend) "$a0");;;
    return: #()).

Definition Point : go_type := structT [
  "x" :: uint64T;
  "y" :: uint64T
].
#[global] Typeclasses Opaque Point.
#[global] Opaque Point.

(* go: struct_method.go:8:16 *)
Definition Point__Addⁱᵐᵖˡ : val :=
  λ: "c" "z",
    exception_do (let: "c" := (mem.alloc "c") in
    let: "z" := (mem.alloc "z") in
    return: (((![#uint64T] (struct.field_ref #Point #"x"%go "c")) + (![#uint64T] (struct.field_ref #Point #"y"%go "c"))) + (![#uint64T] "z"))).

(* go: struct_method.go:12:16 *)
Definition Point__GetFieldⁱᵐᵖˡ : val :=
  λ: "c" <>,
    exception_do (let: "c" := (mem.alloc "c") in
    let: "x" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (![#uint64T] (struct.field_ref #Point #"x"%go "c")) in
    do:  ("x" <-[#uint64T] "$r0");;;
    let: "y" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (![#uint64T] (struct.field_ref #Point #"y"%go "c")) in
    do:  ("y" <-[#uint64T] "$r0");;;
    return: ((![#uint64T] "x") + (![#uint64T] "y"))).

Definition UseAdd : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.UseAdd"%go.

(* go: struct_method.go:18:6 *)
Definition UseAddⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "c" := (mem.alloc (type.zero_val #Point)) in
    let: "$r0" := (let: "$x" := #(W64 2) in
    let: "$y" := #(W64 3) in
    struct.make #Point [{
      "x" ::= "$x";
      "y" ::= "$y"
    }]) in
    do:  ("c" <-[#Point] "$r0");;;
    let: "r" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (let: "$a0" := #(W64 4) in
    (method_call #Point.id #"Add"%go (![#Point] "c")) "$a0") in
    do:  ("r" <-[#uint64T] "$r0");;;
    return: (![#uint64T] "r")).

Definition UseAddWithLiteral : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.UseAddWithLiteral"%go.

(* go: struct_method.go:24:6 *)
Definition UseAddWithLiteralⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "r" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (let: "$a0" := #(W64 4) in
    (method_call #Point.id #"Add"%go (let: "$x" := #(W64 2) in
    let: "$y" := #(W64 3) in
    struct.make #Point [{
      "x" ::= "$x";
      "y" ::= "$y"
    }])) "$a0") in
    do:  ("r" <-[#uint64T] "$r0");;;
    return: (![#uint64T] "r")).

(* go: struct_method.go:29:14 *)
Definition Point__IgnoreReceiverⁱᵐᵖˡ : val :=
  λ: <> <>,
    exception_do (return: (#"ok"%go)).

Definition TwoInts : go_type := structT [
  "x" :: uint64T;
  "y" :: uint64T
].
#[global] Typeclasses Opaque TwoInts.
#[global] Opaque TwoInts.

Definition S : go_type := structT [
  "a" :: uint64T;
  "b" :: TwoInts;
  "c" :: boolT
].
#[global] Typeclasses Opaque S.
#[global] Opaque S.

Definition NewS : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.NewS"%go.

(* go: struct_pointers.go:14:6 *)
Definition NewSⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (mem.alloc (let: "$a" := #(W64 2) in
     let: "$b" := (let: "$x" := #(W64 1) in
     let: "$y" := #(W64 2) in
     struct.make #TwoInts [{
       "x" ::= "$x";
       "y" ::= "$y"
     }]) in
     let: "$c" := #true in
     struct.make #S [{
       "a" ::= "$a";
       "b" ::= "$b";
       "c" ::= "$c"
     }]))).

(* go: struct_pointers.go:22:13 *)
Definition S__readAⁱᵐᵖˡ : val :=
  λ: "s" <>,
    exception_do (let: "s" := (mem.alloc "s") in
    return: (![#uint64T] (struct.field_ref #S #"a"%go (![#ptrT] "s")))).

(* go: struct_pointers.go:26:13 *)
Definition S__readBⁱᵐᵖˡ : val :=
  λ: "s" <>,
    exception_do (let: "s" := (mem.alloc "s") in
    return: (![#TwoInts] (struct.field_ref #S #"b"%go (![#ptrT] "s")))).

(* go: struct_pointers.go:30:12 *)
Definition S__readBValⁱᵐᵖˡ : val :=
  λ: "s" <>,
    exception_do (let: "s" := (mem.alloc "s") in
    return: (![#TwoInts] (struct.field_ref #S #"b"%go "s"))).

(* go: struct_pointers.go:34:13 *)
Definition S__writeBⁱᵐᵖˡ : val :=
  λ: "s" "two",
    exception_do (let: "s" := (mem.alloc "s") in
    let: "two" := (mem.alloc "two") in
    let: "$r0" := (![#TwoInts] "two") in
    do:  ((struct.field_ref #S #"b"%go (![#ptrT] "s")) <-[#TwoInts] "$r0");;;
    return: #()).

(* go: struct_pointers.go:38:13 *)
Definition S__negateCⁱᵐᵖˡ : val :=
  λ: "s" <>,
    exception_do (let: "s" := (mem.alloc "s") in
    let: "$r0" := (~ (![#boolT] (struct.field_ref #S #"c"%go (![#ptrT] "s")))) in
    do:  ((struct.field_ref #S #"c"%go (![#ptrT] "s")) <-[#boolT] "$r0");;;
    return: #()).

(* go: struct_pointers.go:42:13 *)
Definition S__refCⁱᵐᵖˡ : val :=
  λ: "s" <>,
    exception_do (let: "s" := (mem.alloc "s") in
    return: (struct.field_ref #S #"c"%go (![#ptrT] "s"))).

Definition localSRef : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.localSRef"%go.

(* go: struct_pointers.go:46:6 *)
Definition localSRefⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "s" := (mem.alloc (type.zero_val #S)) in
    return: (struct.field_ref #S #"b"%go "s")).

Definition setField : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.setField"%go.

(* go: struct_pointers.go:54:6 *)
Definition setFieldⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "s" := (mem.alloc (type.zero_val #S)) in
    let: "$r0" := #(W64 0) in
    do:  ((struct.field_ref #S #"a"%go "s") <-[#uint64T] "$r0");;;
    let: "$r0" := #true in
    do:  ((struct.field_ref #S #"c"%go "s") <-[#boolT] "$r0");;;
    return: (![#S] "s")).

Definition testSwitchVal : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.testSwitchVal"%go.

(* go: switch.go:3:6 *)
Definition testSwitchValⁱᵐᵖˡ : val :=
  λ: "x",
    exception_do (let: "x" := (mem.alloc "x") in
    let: "$sw" := (![#uint64T] "x") in
    (if: "$sw" = #(W64 0)
    then return: (#true)
    else
      (if: "$sw" = #(W64 1)
      then return: (#false)
      else return: (#false)))).

Definition testSwitchMultiple : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.testSwitchMultiple"%go.

(* go: switch.go:14:6 *)
Definition testSwitchMultipleⁱᵐᵖˡ : val :=
  λ: "x",
    exception_do (let: "x" := (mem.alloc "x") in
    let: "$sw" := (![#uint64T] "x") in
    (if: ("$sw" = #(W64 1)) || ("$sw" = #(W64 10))
    then return: (#(W64 1))
    else
      (if: "$sw" = #(W64 0)
      then return: (#(W64 2))
      else do:  #()));;;
    return: (#(W64 3))).

Definition DoSomeLocking : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.DoSomeLocking"%go.

(* DoSomeLocking uses the entire lock API

   go: synchronization.go:6:6 *)
Definition DoSomeLockingⁱᵐᵖˡ : val :=
  λ: "l",
    exception_do (let: "l" := (mem.alloc "l") in
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] "l")) #());;;
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] "l")) #());;;
    return: #()).

Definition makeLock : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.makeLock"%go.

(* go: synchronization.go:15:6 *)
Definition makeLockⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "l" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #sync.Mutex)) in
    do:  ("l" <-[#ptrT] "$r0");;;
    do:  (let: "$a0" := (![#ptrT] "l") in
    (func_call #DoSomeLocking) "$a0");;;
    return: #()).

Definition sleep : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.sleep"%go.

(* go: time.go:5:6 *)
Definition sleepⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (do:  (let: "$a0" := #(W64 1000) in
    (func_call #primitive.Sleep) "$a0");;;
    return: #()).

Definition B : go_type := structT [
  "a" :: sliceT
].
#[global] Typeclasses Opaque B.
#[global] Opaque B.

Definition A : go_type := structT [
].
#[global] Typeclasses Opaque A.
#[global] Opaque A.

Definition mkInt : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.mkInt"%go.

(* go: trailing_call.go:3:6 *)
Definition mkIntⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (#(W64 42))).

Definition mkNothing : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.mkNothing"%go.

(* go: trailing_call.go:7:6 *)
Definition mkNothingⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (do:  ((func_call #mkInt) #());;;
    return: #()).

Definition my_u64 : go_type := uint64T.
#[global] Typeclasses Opaque my_u64.
#[global] Opaque my_u64.

Definition Timestamp : go_type := uint64T.
#[global] Typeclasses Opaque Timestamp.
#[global] Opaque Timestamp.

Definition UseTypeAbbrev : go_type := uint64T.
#[global] Typeclasses Opaque UseTypeAbbrev.
#[global] Opaque UseTypeAbbrev.

Definition UseNamedType : go_type := Timestamp.
#[global] Typeclasses Opaque UseNamedType.
#[global] Opaque UseNamedType.

Definition convertToAlias : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.convertToAlias"%go.

(* go: type_alias.go:11:6 *)
Definition convertToAliasⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 2) in
    do:  ("x" <-[#uint64T] "$r0");;;
    return: (![#uint64T] "x")).

Definition typeAssertInt : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.typeAssertInt"%go.

(* go: type_switch.go:3:6 *)
Definition typeAssertIntⁱᵐᵖˡ : val :=
  λ: "x",
    exception_do (let: "x" := (mem.alloc "x") in
    return: (interface.type_assert (![#interfaceT] "x") #intT.id)).

Definition wrapUnwrapInt : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.wrapUnwrapInt"%go.

(* go: type_switch.go:7:6 *)
Definition wrapUnwrapIntⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (let: "$a0" := (interface.make #intT.id #(W64 1)) in
     (func_call #typeAssertInt) "$a0")).

Definition checkedTypeAssert : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.checkedTypeAssert"%go.

(* go: type_switch.go:11:6 *)
Definition checkedTypeAssertⁱᵐᵖˡ : val :=
  λ: "x",
    exception_do (let: "x" := (mem.alloc "x") in
    (let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "v" := (mem.alloc (type.zero_val #uint64T)) in
    let: ("$ret0", "$ret1") := (interface.checked_type_assert #uint64T (![#interfaceT] "x") #uint64T.id) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("v" <-[#uint64T] "$r0");;;
    do:  ("ok" <-[#boolT] "$r1");;;
    (if: ![#boolT] "ok"
    then return: (![#uint64T] "v")
    else do:  #()));;;
    return: (#(W64 3))).

Definition basicTypeSwitch : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.basicTypeSwitch"%go.

(* go: type_switch.go:18:6 *)
Definition basicTypeSwitchⁱᵐᵖˡ : val :=
  λ: "x",
    exception_do (let: "x" := (mem.alloc "x") in
    let: "$y" := (![#interfaceT] "x") in
    let: ("$x", "$ok") := (interface.checked_type_assert #intT "$y" #intT.id) in
    (if: "$ok"
    then return: (#(W64 1))
    else
      let: ("$x", "$ok") := (interface.checked_type_assert #stringT "$y" #stringT.id) in
      (if: "$ok"
      then return: (#(W64 2))
      else do:  #()));;;
    return: (#(W64 0))).

Definition fancyTypeSwitch : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.fancyTypeSwitch"%go.

(* go: type_switch.go:28:6 *)
Definition fancyTypeSwitchⁱᵐᵖˡ : val :=
  λ: "x",
    exception_do (let: "x" := (mem.alloc "x") in
    let: "r" := (mem.alloc (type.zero_val #intT)) in
    let: "$y" := (![#interfaceT] "x") in
    (let: "z" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := #(W64 0) in
    do:  ("z" <-[#intT] "$r0");;;
    let: ("$x", "$ok") := (interface.checked_type_assert #intT "$y" #intT.id) in
    (if: "$ok"
    then
      let: "y" := (mem.alloc "$x") in
      return: (![#intT] "y")
    else
      let: ("$x", "$ok") := (interface.checked_type_assert #stringT "$y" #stringT.id) in
      (if: "$ok"
      then
        let: "y" := (mem.alloc "$x") in
        return: (#(W64 2))
      else
        let: "$ok" := (interface.eq "$y" #interface.nil) in
        let: "$x" := "$y" in
        (if: "$ok"
        then
          let: "y" := (mem.alloc "$x") in
          return: (#(W64 4))
        else
          let: "$r0" := #(W64 3) in
          do:  ("z" <-[#intT] "$r0");;;
          let: "$r0" := (![#intT] "z") in
          do:  ("r" <-[#intT] "$r0")))));;;
    return: (![#intT] "r")).

Definition multiTypeSwitch : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.multiTypeSwitch"%go.

(* go: type_switch.go:44:6 *)
Definition multiTypeSwitchⁱᵐᵖˡ : val :=
  λ: "x",
    exception_do (let: "x" := (mem.alloc "x") in
    let: "$y" := (![#interfaceT] "x") in
    let: "$ok" := ((Snd (interface.checked_type_assert #intT "$y" #intT.id)) || (Snd (interface.checked_type_assert #intT "$y" #intT.id))) in
    let: "$x" := "$y" in
    (if: "$ok"
    then return: (#(W64 1))
    else do:  #());;;
    return: (#(W64 0))).

Definition variadicFunc : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.variadicFunc"%go.

(* go: varargs.go:3:6 *)
Definition variadicFuncⁱᵐᵖˡ : val :=
  λ: "a" "b" "cs",
    exception_do (let: "cs" := (mem.alloc "cs") in
    let: "b" := (mem.alloc "b") in
    let: "a" := (mem.alloc "a") in
    do:  #()).

Definition testVariadicCall : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.testVariadicCall"%go.

(* go: varargs.go:6:6 *)
Definition testVariadicCallⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (do:  (let: "$a0" := #(W64 10) in
    let: "$a1" := #"abc"%go in
    let: "$a2" := ((let: "$sl0" := #(W8 0) in
    let: "$sl1" := #(W8 1) in
    let: "$sl2" := #(W8 2) in
    let: "$sl3" := #(W8 3) in
    slice.literal #byteT ["$sl0"; "$sl1"; "$sl2"; "$sl3"])) in
    (func_call #variadicFunc) "$a0" "$a1" "$a2");;;
    do:  (let: "$a0" := #(W64 10) in
    let: "$a1" := #"abc"%go in
    let: "$a2" := #slice.nil in
    (func_call #variadicFunc) "$a0" "$a1" "$a2");;;
    let: "c" := (mem.alloc (type.zero_val #sliceT)) in
    do:  (let: "$a0" := #(W64 10) in
    let: "$a1" := #"abc"%go in
    let: "$a2" := (![#sliceT] "c") in
    (func_call #variadicFunc) "$a0" "$a1" "$a2");;;
    return: #()).

Definition returnMultiple : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.returnMultiple"%go.

(* go: varargs.go:13:6 *)
Definition returnMultipleⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (#(W64 0), #"xyz"%go, #(W8 0), #(W8 0))).

Definition testVariadicPassThrough : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.testVariadicPassThrough"%go.

(* go: varargs.go:17:6 *)
Definition testVariadicPassThroughⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (do:  (let: ((("$ret0", "$ret1"), "$ret2"), "$ret3") := (((func_call #returnMultiple) #())) in
    let: "$a0" := "$ret0" in
    let: "$a1" := "$ret1" in
    let: "$a2" := ((let: "$sl0" := "$ret2" in
    let: "$sl1" := "$ret3" in
    slice.literal #byteT ["$sl0"; "$sl1"])) in
    (func_call #variadicFunc) "$a0" "$a1" "$a2");;;
    return: #()).

Definition LocalVars : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.LocalVars"%go.

(* go: vars.go:3:6 *)
Definition LocalVarsⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "b" := (mem.alloc (type.zero_val #stringT)) in
    let: "a" := (mem.alloc (type.zero_val #intT)) in
    do:  ("b" <-[#stringT] ((![#stringT] "b") + #"hello"%go));;;
    return: (![#intT] "a")).

Definition LocalConsts : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.LocalConsts"%go.

(* go: vars.go:12:6 *)
Definition LocalConstsⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (mem.alloc (type.zero_val #intT)) in
    let c := 10 in
    let d := 15 in
    let e := 8 in
    do:  ("x" <-[#intT] ((![#intT] "x") + #(W64 c)));;;
    do:  ("x" <-[#intT] ((![#intT] "x") - #(W64 d)));;;
    return: (![#intT] "x")).

Definition vars' : list (go_string * go_type) := [(GlobalX, uint64T); (globalY, stringT); (globalA, stringT); (globalB, stringT); (mapLiteral, mapT stringT uint64T); (mapLiteralWithConversion, mapT interfaceT interfaceT)].

Definition functions' : list (go_string * val) := [(takesArray, takesArrayⁱᵐᵖˡ); (takesPtr, takesPtrⁱᵐᵖˡ); (usesArrayElemRef, usesArrayElemRefⁱᵐᵖˡ); (sum, sumⁱᵐᵖˡ); (arrayToSlice, arrayToSliceⁱᵐᵖˡ); (arrayLiteralKeyed, arrayLiteralKeyedⁱᵐᵖˡ); (chanBasic, chanBasicⁱᵐᵖˡ); (f, fⁱᵐᵖˡ); (chanSelect, chanSelectⁱᵐᵖˡ); (chanDirectional, chanDirectionalⁱᵐᵖˡ); (chanRange, chanRangeⁱᵐᵖˡ); (doSubtleThings, doSubtleThingsⁱᵐᵖˡ); (hasStartComment, hasStartCommentⁱᵐᵖˡ); (hasEndComment, hasEndCommentⁱᵐᵖˡ); (condvarWrapping, condvarWrappingⁱᵐᵖˡ); (useUntypedInt, useUntypedIntⁱᵐᵖˡ); (useUntypedString, useUntypedStringⁱᵐᵖˡ); (conditionalReturn, conditionalReturnⁱᵐᵖˡ); (alwaysReturn, alwaysReturnⁱᵐᵖˡ); (alwaysReturnInNestedBranches, alwaysReturnInNestedBranchesⁱᵐᵖˡ); (earlyReturn, earlyReturnⁱᵐᵖˡ); (conditionalAssign, conditionalAssignⁱᵐᵖˡ); (elseIf, elseIfⁱᵐᵖˡ); (ifStmtInitialization, ifStmtInitializationⁱᵐᵖˡ); (typedLiteral, typedLiteralⁱᵐᵖˡ); (literalCast, literalCastⁱᵐᵖˡ); (castInt, castIntⁱᵐᵖˡ); (stringToByteSlice, stringToByteSliceⁱᵐᵖˡ); (byteSliceToString, byteSliceToStringⁱᵐᵖˡ); (stringToStringWrapper, stringToStringWrapperⁱᵐᵖˡ); (stringWrapperToString, stringWrapperToStringⁱᵐᵖˡ); (testU32NewtypeLen, testU32NewtypeLenⁱᵐᵖˡ); (testCopySimple, testCopySimpleⁱᵐᵖˡ); (testCopyDifferentLengths, testCopyDifferentLengthsⁱᵐᵖˡ); (atomicCreateStub, atomicCreateStubⁱᵐᵖˡ); (useSlice, useSliceⁱᵐᵖˡ); (useSliceIndexing, useSliceIndexingⁱᵐᵖˡ); (useMap, useMapⁱᵐᵖˡ); (usePtr, usePtrⁱᵐᵖˡ); (iterMapKeysAndValues, iterMapKeysAndValuesⁱᵐᵖˡ); (iterMapKeys, iterMapKeysⁱᵐᵖˡ); (getRandom, getRandomⁱᵐᵖˡ); (diskArgument, diskArgumentⁱᵐᵖˡ); (returnEmbedVal, returnEmbedValⁱᵐᵖˡ); (returnEmbedValWithPointer, returnEmbedValWithPointerⁱᵐᵖˡ); (useEmbeddedField, useEmbeddedFieldⁱᵐᵖˡ); (useEmbeddedValField, useEmbeddedValFieldⁱᵐᵖˡ); (useEmbeddedMethod, useEmbeddedMethodⁱᵐᵖˡ); (useEmbeddedMethod2, useEmbeddedMethod2ⁱᵐᵖˡ); (empty, emptyⁱᵐᵖˡ); (emptyReturn, emptyReturnⁱᵐᵖˡ); (unnamedParams, unnamedParamsⁱᵐᵖˡ); (anonymousParam, anonymousParamⁱᵐᵖˡ); (useFloat, useFloatⁱᵐᵖˡ); (compareIntFloat, compareIntFloatⁱᵐᵖˡ); (compareFloatInt, compareFloatIntⁱᵐᵖˡ); (forRangeNoBinding, forRangeNoBindingⁱᵐᵖˡ); (forRangeOldVars, forRangeOldVarsⁱᵐᵖˡ); (foo, fooⁱᵐᵖˡ); (other, otherⁱᵐᵖˡ); (bar, barⁱᵐᵖˡ); (TakesFunctionType, TakesFunctionTypeⁱᵐᵖˡ); (FuncVar, FuncVarⁱᵐᵖˡ); (fooConsumer, fooConsumerⁱᵐᵖˡ); (testAssignConcreteToInterface, testAssignConcreteToInterfaceⁱᵐᵖˡ); (testPassConcreteToInterfaceArg, testPassConcreteToInterfaceArgⁱᵐᵖˡ); (testPassConcreteToInterfaceArgSpecial, testPassConcreteToInterfaceArgSpecialⁱᵐᵖˡ); (takesVarArgsInterface, takesVarArgsInterfaceⁱᵐᵖˡ); (test, testⁱᵐᵖˡ); (returnConcrete, returnConcreteⁱᵐᵖˡ); (testMultiReturn, testMultiReturnⁱᵐᵖˡ); (testReturnStatment, testReturnStatmentⁱᵐᵖˡ); (testConversionInEq, testConversionInEqⁱᵐᵖˡ); (takeMultiple, takeMultipleⁱᵐᵖˡ); (giveMultiple, giveMultipleⁱᵐᵖˡ); (testConversionInMultipleReturnPassThrough, testConversionInMultipleReturnPassThroughⁱᵐᵖˡ); (testConversionInMultiplePassThrough, testConversionInMultiplePassThroughⁱᵐᵖˡ); (testPtrMset, testPtrMsetⁱᵐᵖˡ); (useInts, useIntsⁱᵐᵖˡ); (signedMidpoint, signedMidpointⁱᵐᵖˡ); (normalLiterals, normalLiteralsⁱᵐᵖˡ); (outOfOrderLiteral, outOfOrderLiteralⁱᵐᵖˡ); (specialLiterals, specialLiteralsⁱᵐᵖˡ); (oddLiterals, oddLiteralsⁱᵐᵖˡ); (unKeyedLiteral, unKeyedLiteralⁱᵐᵖˡ); (useLocks, useLocksⁱᵐᵖˡ); (useCondVar, useCondVarⁱᵐᵖˡ); (ToBeDebugged, ToBeDebuggedⁱᵐᵖˡ); (DoNothing, DoNothingⁱᵐᵖˡ); (DoSomething, DoSomethingⁱᵐᵖˡ); (standardForLoop, standardForLoopⁱᵐᵖˡ); (conditionalInLoop, conditionalInLoopⁱᵐᵖˡ); (conditionalInLoopElse, conditionalInLoopElseⁱᵐᵖˡ); (nestedConditionalInLoopImplicitContinue, nestedConditionalInLoopImplicitContinueⁱᵐᵖˡ); (ImplicitLoopContinue, ImplicitLoopContinueⁱᵐᵖˡ); (ImplicitLoopContinue2, ImplicitLoopContinue2ⁱᵐᵖˡ); (ImplicitLoopContinueAfterIfBreak, ImplicitLoopContinueAfterIfBreakⁱᵐᵖˡ); (nestedLoops, nestedLoopsⁱᵐᵖˡ); (nestedGoStyleLoops, nestedGoStyleLoopsⁱᵐᵖˡ); (sumSlice, sumSliceⁱᵐᵖˡ); (intSliceLoop, intSliceLoopⁱᵐᵖˡ); (breakFromLoop, breakFromLoopⁱᵐᵖˡ); (IterateMapKeys, IterateMapKeysⁱᵐᵖˡ); (MapSize, MapSizeⁱᵐᵖˡ); (MapTypeAliases, MapTypeAliasesⁱᵐᵖˡ); (StringMap, StringMapⁱᵐᵖˡ); (mapUpdateField, mapUpdateFieldⁱᵐᵖˡ); (mapGetCall, mapGetCallⁱᵐᵖˡ); (mapLiteralTest, mapLiteralTestⁱᵐᵖˡ); (returnTwo, returnTwoⁱᵐᵖˡ); (returnTwoWrapper, returnTwoWrapperⁱᵐᵖˡ); (multipleVar, multipleVarⁱᵐᵖˡ); (multiplePassThrough, multiplePassThroughⁱᵐᵖˡ); (multipleReturnPassThrough, multipleReturnPassThroughⁱᵐᵖˡ); (AssignNilSlice, AssignNilSliceⁱᵐᵖˡ); (AssignNilPointer, AssignNilPointerⁱᵐᵖˡ); (CompareSliceToNil, CompareSliceToNilⁱᵐᵖˡ); (ComparePointerToNil, ComparePointerToNilⁱᵐᵖˡ); (useNilField, useNilFieldⁱᵐᵖˡ); (LogicalOperators, LogicalOperatorsⁱᵐᵖˡ); (LogicalAndEqualityOperators, LogicalAndEqualityOperatorsⁱᵐᵖˡ); (ArithmeticShifts, ArithmeticShiftsⁱᵐᵖˡ); (BitwiseOps, BitwiseOpsⁱᵐᵖˡ); (Comparison, Comparisonⁱᵐᵖˡ); (AssignOps, AssignOpsⁱᵐᵖˡ); (BitwiseAndNot, BitwiseAndNotⁱᵐᵖˡ); (Negative, Negativeⁱᵐᵖˡ); (PanicAtTheDisco, PanicAtTheDiscoⁱᵐᵖˡ); (Oracle, Oracleⁱᵐᵖˡ); (ReassignVars, ReassignVarsⁱᵐᵖˡ); (recur, recurⁱᵐᵖˡ); (useRenamedImport, useRenamedImportⁱᵐᵖˡ); (TwoDiskWrite, TwoDiskWriteⁱᵐᵖˡ); (TwoDiskRead, TwoDiskReadⁱᵐᵖˡ); (TwoDiskLock, TwoDiskLockⁱᵐᵖˡ); (TwoDiskUnlock, TwoDiskUnlockⁱᵐᵖˡ); (ReplicatedDiskRead, ReplicatedDiskReadⁱᵐᵖˡ); (ReplicatedDiskWrite, ReplicatedDiskWriteⁱᵐᵖˡ); (ReplicatedDiskRecover, ReplicatedDiskRecoverⁱᵐᵖˡ); (BasicNamedReturn, BasicNamedReturnⁱᵐᵖˡ); (NamedReturn, NamedReturnⁱᵐᵖˡ); (BasicNamedReturnMany, BasicNamedReturnManyⁱᵐᵖˡ); (NamedReturnMany, NamedReturnManyⁱᵐᵖˡ); (NamedReturnOverride, NamedReturnOverrideⁱᵐᵖˡ); (VoidButEndsWithReturn, VoidButEndsWithReturnⁱᵐᵖˡ); (VoidImplicitReturnInBranch, VoidImplicitReturnInBranchⁱᵐᵖˡ); (sliceOps, sliceOpsⁱᵐᵖˡ); (makeSingletonSlice, makeSingletonSliceⁱᵐᵖˡ); (makeAlias, makeAliasⁱᵐᵖˡ); (Skip, Skipⁱᵐᵖˡ); (simpleSpawn, simpleSpawnⁱᵐᵖˡ); (threadCode, threadCodeⁱᵐᵖˡ); (loopSpawn, loopSpawnⁱᵐᵖˡ); (stringAppend, stringAppendⁱᵐᵖˡ); (stringLength, stringLengthⁱᵐᵖˡ); (x, xⁱᵐᵖˡ); (UseAdd, UseAddⁱᵐᵖˡ); (UseAddWithLiteral, UseAddWithLiteralⁱᵐᵖˡ); (NewS, NewSⁱᵐᵖˡ); (localSRef, localSRefⁱᵐᵖˡ); (setField, setFieldⁱᵐᵖˡ); (testSwitchVal, testSwitchValⁱᵐᵖˡ); (testSwitchMultiple, testSwitchMultipleⁱᵐᵖˡ); (DoSomeLocking, DoSomeLockingⁱᵐᵖˡ); (makeLock, makeLockⁱᵐᵖˡ); (sleep, sleepⁱᵐᵖˡ); (mkInt, mkIntⁱᵐᵖˡ); (mkNothing, mkNothingⁱᵐᵖˡ); (convertToAlias, convertToAliasⁱᵐᵖˡ); (typeAssertInt, typeAssertIntⁱᵐᵖˡ); (wrapUnwrapInt, wrapUnwrapIntⁱᵐᵖˡ); (checkedTypeAssert, checkedTypeAssertⁱᵐᵖˡ); (basicTypeSwitch, basicTypeSwitchⁱᵐᵖˡ); (fancyTypeSwitch, fancyTypeSwitchⁱᵐᵖˡ); (multiTypeSwitch, multiTypeSwitchⁱᵐᵖˡ); (variadicFunc, variadicFuncⁱᵐᵖˡ); (testVariadicCall, testVariadicCallⁱᵐᵖˡ); (returnMultiple, returnMultipleⁱᵐᵖˡ); (testVariadicPassThrough, testVariadicPassThroughⁱᵐᵖˡ); (LocalVars, LocalVarsⁱᵐᵖˡ); (LocalConsts, LocalConstsⁱᵐᵖˡ)].

Definition msets' : list (go_string * (list (go_string * val))) := [(Foo.id, []); (ptrT.id Foo.id, []); (importantStruct.id, []); (ptrT.id importantStruct.id, []); (stringWrapper.id, []); (ptrT.id stringWrapper.id, []); (Uint32.id, []); (ptrT.id Uint32.id, []); (diskWrapper.id, []); (ptrT.id diskWrapper.id, []); (embedA.id, [("Foo"%go, embedA__Fooⁱᵐᵖˡ)]); (ptrT.id embedA.id, [("Bar"%go, embedA__Barⁱᵐᵖˡ); ("Foo"%go, (λ: "$r",
                 method_call #embedA.id #"Foo"%go (![#embedA] "$r")
                 )%V)]); (embedB.id, [("Foo"%go, embedB__Fooⁱᵐᵖˡ)]); (ptrT.id embedB.id, [("Bar"%go, (λ: "$r",
                 method_call #(ptrT.id embedA.id) #"Bar"%go (struct.field_ref #embedB #"embedA"%go "$r")
                 )%V); ("Car"%go, embedB__Carⁱᵐᵖˡ); ("Foo"%go, (λ: "$r",
                 method_call #embedB.id #"Foo"%go (![#embedB] "$r")
                 )%V)]); (embedC.id, [("Bar"%go, (λ: "$r",
                 method_call #(ptrT.id embedB.id) #"Bar"%go (struct.field_get #embedC #"embedB"%go "$r")
                 )%V); ("Car"%go, (λ: "$r",
                 method_call #(ptrT.id embedB.id) #"Car"%go (struct.field_get #embedC #"embedB"%go "$r")
                 )%V); ("Foo"%go, (λ: "$r",
                 method_call #(ptrT.id embedB.id) #"Foo"%go (struct.field_get #embedC #"embedB"%go "$r")
                 )%V)]); (ptrT.id embedC.id, [("Bar"%go, (λ: "$r",
                 method_call #(ptrT.id embedB.id) #"Bar"%go (![#ptrT] (struct.field_ref #embedC #"embedB"%go "$r"))
                 )%V); ("Car"%go, (λ: "$r",
                 method_call #(ptrT.id embedB.id) #"Car"%go (![#ptrT] (struct.field_ref #embedC #"embedB"%go "$r"))
                 )%V); ("Foo"%go, (λ: "$r",
                 method_call #(ptrT.id embedB.id) #"Foo"%go (![#ptrT] (struct.field_ref #embedC #"embedB"%go "$r"))
                 )%V)]); (embedD.id, [("Bar"%go, (λ: "$r",
                 method_call #embedC.id #"Bar"%go (struct.field_get #embedD #"embedC"%go "$r")
                 )%V); ("Car"%go, (λ: "$r",
                 method_call #embedC.id #"Car"%go (struct.field_get #embedD #"embedC"%go "$r")
                 )%V); ("Foo"%go, (λ: "$r",
                 method_call #embedC.id #"Foo"%go (struct.field_get #embedD #"embedC"%go "$r")
                 )%V)]); (ptrT.id embedD.id, [("Bar"%go, (λ: "$r",
                 method_call #(ptrT.id embedC.id) #"Bar"%go (struct.field_ref #embedD #"embedC"%go "$r")
                 )%V); ("Car"%go, (λ: "$r",
                 method_call #(ptrT.id embedC.id) #"Car"%go (struct.field_ref #embedD #"embedC"%go "$r")
                 )%V); ("Foo"%go, (λ: "$r",
                 method_call #(ptrT.id embedC.id) #"Foo"%go (struct.field_ref #embedD #"embedC"%go "$r")
                 )%V)]); (Enc.id, []); (ptrT.id Enc.id, [("UInt32"%go, Enc__UInt32ⁱᵐᵖˡ); ("UInt64"%go, Enc__UInt64ⁱᵐᵖˡ); ("consume"%go, Enc__consumeⁱᵐᵖˡ)]); (Dec.id, []); (ptrT.id Dec.id, [("UInt32"%go, Dec__UInt32ⁱᵐᵖˡ); ("UInt64"%go, Dec__UInt64ⁱᵐᵖˡ); ("consume"%go, Dec__consumeⁱᵐᵖˡ)]); (Enum1.id, []); (ptrT.id Enum1.id, []); (Enum2.id, []); (ptrT.id Enum2.id, []); (concreteFooer.id, []); (ptrT.id concreteFooer.id, [("Foo"%go, concreteFooer__Fooⁱᵐᵖˡ)]); (FooerUser.id, []); (ptrT.id FooerUser.id, []); (concrete1.id, [("Foo"%go, concrete1__Fooⁱᵐᵖˡ)]); (ptrT.id concrete1.id, [("B"%go, concrete1__Bⁱᵐᵖˡ); ("Foo"%go, (λ: "$r",
                 method_call #concrete1.id #"Foo"%go (![#concrete1] "$r")
                 )%V)]); (my_u32.id, []); (ptrT.id my_u32.id, []); (also_u32.id, []); (ptrT.id also_u32.id, []); (allTheLiterals.id, []); (ptrT.id allTheLiterals.id, []); (hasCondVar.id, []); (ptrT.id hasCondVar.id, []); (IntWrapper.id, []); (ptrT.id IntWrapper.id, []); (MapWrapper.id, []); (ptrT.id MapWrapper.id, []); (mapElem.id, []); (ptrT.id mapElem.id, []); (containsPointer.id, []); (ptrT.id containsPointer.id, []); (wrapExternalStruct.id, [("join"%go, wrapExternalStruct__joinⁱᵐᵖˡ)]); (ptrT.id wrapExternalStruct.id, [("join"%go, (λ: "$r",
                 method_call #wrapExternalStruct.id #"join"%go (![#wrapExternalStruct] "$r")
                 )%V)]); (typing.id, []); (ptrT.id typing.id, []); (composite.id, []); (ptrT.id composite.id, []); (R.id, []); (ptrT.id R.id, [("recurMethod"%go, R__recurMethodⁱᵐᵖˡ)]); (Other.id, [("recurEmbeddedMethod"%go, (λ: "$r",
                 method_call #(ptrT.id RecursiveEmbedded.id) #"recurEmbeddedMethod"%go (struct.field_get #Other #"RecursiveEmbedded"%go "$r")
                 )%V)]); (ptrT.id Other.id, [("recurEmbeddedMethod"%go, (λ: "$r",
                 method_call #(ptrT.id RecursiveEmbedded.id) #"recurEmbeddedMethod"%go (![#ptrT] (struct.field_ref #Other #"RecursiveEmbedded"%go "$r"))
                 )%V)]); (RecursiveEmbedded.id, []); (ptrT.id RecursiveEmbedded.id, [("recurEmbeddedMethod"%go, RecursiveEmbedded__recurEmbeddedMethodⁱᵐᵖˡ)]); (Block.id, []); (ptrT.id Block.id, []); (SliceAlias.id, []); (ptrT.id SliceAlias.id, []); (thing.id, []); (ptrT.id thing.id, []); (sliceOfThings.id, [("getThingRef"%go, sliceOfThings__getThingRefⁱᵐᵖˡ)]); (ptrT.id sliceOfThings.id, [("getThingRef"%go, (λ: "$r",
                 method_call #sliceOfThings.id #"getThingRef"%go (![#sliceOfThings] "$r")
                 )%V)]); (Point.id, [("Add"%go, Point__Addⁱᵐᵖˡ); ("GetField"%go, Point__GetFieldⁱᵐᵖˡ); ("IgnoreReceiver"%go, Point__IgnoreReceiverⁱᵐᵖˡ)]); (ptrT.id Point.id, [("Add"%go, (λ: "$r",
                 method_call #Point.id #"Add"%go (![#Point] "$r")
                 )%V); ("GetField"%go, (λ: "$r",
                 method_call #Point.id #"GetField"%go (![#Point] "$r")
                 )%V); ("IgnoreReceiver"%go, (λ: "$r",
                 method_call #Point.id #"IgnoreReceiver"%go (![#Point] "$r")
                 )%V)]); (TwoInts.id, []); (ptrT.id TwoInts.id, []); (S.id, [("readBVal"%go, S__readBValⁱᵐᵖˡ)]); (ptrT.id S.id, [("negateC"%go, S__negateCⁱᵐᵖˡ); ("readA"%go, S__readAⁱᵐᵖˡ); ("readB"%go, S__readBⁱᵐᵖˡ); ("readBVal"%go, (λ: "$r",
                 method_call #S.id #"readBVal"%go (![#S] "$r")
                 )%V); ("refC"%go, S__refCⁱᵐᵖˡ); ("writeB"%go, S__writeBⁱᵐᵖˡ)]); (B.id, []); (ptrT.id B.id, []); (A.id, []); (ptrT.id A.id, []); (Timestamp.id, []); (ptrT.id Timestamp.id, []); (UseTypeAbbrev.id, []); (ptrT.id UseTypeAbbrev.id, []); (UseNamedType.id, []); (ptrT.id UseNamedType.id, [])].

#[global] Instance info' : PkgInfo unittest.unittest :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [code.fmt.fmt; code.sync.sync; code.github_com.goose_lang.primitive.primitive; code.github_com.goose_lang.primitive.disk.disk; code.log.log; code.github_com.goose_lang.std.std; code.fmt.fmt];
  |}.

Definition initialize' : val :=
  λ: <>,
    package.init #unittest.unittest (λ: <>,
      exception_do (do:  (fmt.initialize' #());;;
      do:  (std.initialize' #());;;
      do:  (log.initialize' #());;;
      do:  (disk.initialize' #());;;
      do:  (primitive.initialize' #());;;
      do:  (sync.initialize' #());;;
      do:  (fmt.initialize' #());;;
      do:  (package.alloc unittest.unittest #());;;
      let: "$r0" := ((func_call #foo) #()) in
      do:  ((globals.get #GlobalX) <-[#uint64T] "$r0");;;
      let: "$r0" := #"a"%go in
      do:  ((globals.get #globalA) <-[#stringT] "$r0");;;
      let: "$r0" := #"b"%go in
      do:  ((globals.get #globalB) <-[#stringT] "$r0");;;
      let: "$r0" := ((func_call #foo) #()) in
      let: "$r0" := ((let: "$v0" := #(W64 10) in
      let: "$k0" := #"a"%go in
      map.literal #stringT #uint64T [map.kv_entry "$k0" "$v0"])) in
      do:  ((globals.get #mapLiteral) <-[type.mapT #stringT #uint64T] "$r0");;;
      let: "$r0" := ((let: "$v0" := (interface.make #intT.id #(W64 10)) in
      let: "$k0" := (interface.make #stringT.id #"a"%go) in
      map.literal #interfaceT #interfaceT [map.kv_entry "$k0" "$v0"])) in
      do:  ((globals.get #mapLiteralWithConversion) <-[type.mapT #interfaceT #interfaceT] "$r0");;;
      do:  ((λ: <>,
        exception_do (let: "$r0" := (![#uint64T] (globals.get #GlobalX)) in
        do:  ((globals.get #GlobalX) <-[#uint64T] "$r0");;;
        return: #())
        ) #());;;
      do:  ((λ: <>,
        exception_do (let: "$r0" := #""%go in
        do:  ((globals.get #globalY) <-[#stringT] "$r0");;;
        return: #())
        ) #()))
      ).

End code.
End unittest.
