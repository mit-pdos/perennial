(* autogenerated from github.com/goose-lang/goose/testdata/examples/unittest *)
From New.golang Require Import defn.
From New.code Require fmt.
From New.code Require github_com.goose_lang.primitive.
From New.code Require github_com.goose_lang.primitive.disk.
From New.code Require github_com.tchajed.marshal.
From New.code Require log.
From New.code Require sync.

From New Require Import disk_prelude.

Definition Foo : go_type := arrayT 10 uint64T.

Definition Foo__mset : list (string * val) := [
].

Definition Foo__mset_ptr : list (string * val) := [
].

(* go: array.go:5:6 *)
Definition takesArray : val :=
  rec: "takesArray" "x" :=
    exception_do (let: "x" := (ref_ty (arrayT 13 stringT) "x") in
    return: (![stringT] (array.elem_ref stringT (![arrayT 13 stringT] "x") #(W64 3)))).

(* go: array.go:9:6 *)
Definition takesPtr : val :=
  rec: "takesPtr" "x" :=
    exception_do (let: "x" := (ref_ty ptrT "x") in
    do:  ((![ptrT] "x") <-[stringT] ((![stringT] (![ptrT] "x")) + #"bar"))).

(* go: array.go:13:6 *)
Definition usesArrayElemRef : val :=
  rec: "usesArrayElemRef" <> :=
    exception_do (let: "x" := (ref_ty (arrayT 2 stringT) (zero_val (arrayT 2 stringT))) in
    let: "$r0" := ((let: "$ar0" := #"a" in
    let: "$ar1" := #"b" in
    array.literal ["$ar0"; "$ar1"])) in
    do:  ("x" <-[arrayT 2 stringT] "$r0");;;
    let: "$r0" := #"c" in
    do:  ((array.elem_ref stringT (![arrayT 2 stringT] "x") #(W64 1)) <-[stringT] "$r0");;;
    do:  (let: "$a0" := (array.elem_ref stringT (![arrayT 2 stringT] "x") #(W64 1)) in
    takesPtr "$a0")).

(* go: array.go:22:6 *)
Definition sum : val :=
  rec: "sum" "x" :=
    exception_do (let: "x" := (ref_ty (arrayT 100 uint64T) "x") in
    let: "sum" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("sum" <-[uint64T] "$r0");;;
    (let: "i" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[uint64T] "$r0");;;
    (for: (λ: <>, (![uint64T] "i") < (array.len (arrayT 100 uint64T))); (λ: <>, do:  ("i" <-[uint64T] ((![uint64T] "i") + #(W64 1)))) := λ: <>,
      do:  ("sum" <-[uint64T] ((![uint64T] "sum") + (![uint64T] (array.elem_ref uint64T (![arrayT 100 uint64T] "x") (![uint64T] "i")))))));;;
    do:  ("sum" <-[uint64T] ((![uint64T] "sum") + (array.cap (arrayT 100 uint64T))));;;
    return: (![uint64T] "sum")).

(* go: array.go:31:6 *)
Definition arrayToSlice : val :=
  rec: "arrayToSlice" <> :=
    exception_do (let: "x" := (ref_ty (arrayT 2 stringT) (zero_val (arrayT 2 stringT))) in
    let: "$r0" := ((let: "$ar0" := #"a" in
    let: "$ar1" := #"b" in
    array.literal ["$ar0"; "$ar1"])) in
    do:  ("x" <-[arrayT 2 stringT] "$r0");;;
    return: (let: "$a" := "x" in
     array.slice "$a" #(W64 0) (array.len (arrayT 2 stringT)))).

(* go: chan.go:5:6 *)
Definition chanBasic : val :=
  rec: "chanBasic" <> :=
    exception_do (let: "x" := (ref_ty (chanT stringT) (zero_val (chanT stringT))) in
    let: "$r0" := (chan.make stringT #()) in
    do:  ("x" <-[chanT stringT] "$r0");;;
    let: "$go" := (λ: <>,
      exception_do (do:  (let: "$chan" := (![chanT stringT] "x") in
      let: "$v" := #"Foo" in
      chan.send "$chan" "$v");;;
      do:  (let: "$chan" := (![chanT stringT] "x") in
      let: "$v" := #"Foo" in
      chan.send "$chan" "$v"))
      ) in
    do:  (Fork ("$go" #()));;;
    let: "ok" := (ref_ty boolT (zero_val boolT)) in
    let: "y" := (ref_ty stringT (zero_val stringT)) in
    let: ("$ret0", "$ret1") := (chan.receive (![chanT stringT] "x")) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("y" <-[stringT] "$r0");;;
    do:  ("ok" <-[boolT] "$r1");;;
    let: "$r0" := (Fst (chan.receive (![chanT stringT] "x"))) in
    do:  ("y" <-[stringT] "$r0");;;
    (if: ![boolT] "ok"
    then
      let: "$r0" := ((![stringT] "y") + #" ") in
      do:  ("y" <-[stringT] "$r0")
    else do:  #())).

(* go: chan.go:19:6 *)
Definition f : val :=
  rec: "f" <> :=
    exception_do (return: (#(W64 0))).

(* modified version of example from https://go.dev/ref/spec#Select_statements

   go: chan.go:24:6 *)
Definition chanSelect : val :=
  rec: "chanSelect" <> :=
    exception_do (let: "a" := (ref_ty sliceT (zero_val sliceT)) in
    let: "c4" := (ref_ty (chanT intT) (zero_val (chanT intT))) in
    let: "c3" := (ref_ty (chanT intT) (zero_val (chanT intT))) in
    let: "c2" := (ref_ty (chanT intT) (zero_val (chanT intT))) in
    let: "c1" := (ref_ty (chanT intT) (zero_val (chanT intT))) in
    let: "c" := (ref_ty (chanT intT) (zero_val (chanT intT))) in
    let: "i2" := (ref_ty intT (zero_val intT)) in
    let: "i1" := (ref_ty intT (zero_val intT)) in
    do:  (chan.select [("$sendVal0", "$sendChan0", (λ: <>,
        do:  (let: "$a0" := ((let: "$sl0" := (interface.make string__mset #"sent ") in
        let: "$sl1" := (interface.make int__mset (![intT] "i2")) in
        let: "$sl2" := (interface.make string__mset #" to c2
        ") in
        slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
        fmt.Print "$a0")
        ))] [("$recvChan0", (λ: "$recvVal",
        do:  #()
        )); ("$recvChan1", (λ: "$recvVal",
        let: "$r0" := (Fst "$recvVal") in
        do:  ("i1" <-[intT] "$r0");;;
        do:  (let: "$a0" := ((let: "$sl0" := (interface.make string__mset #"received ") in
        let: "$sl1" := (interface.make int__mset (![intT] "i1")) in
        let: "$sl2" := (interface.make string__mset #" from c1
        ") in
        slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
        fmt.Print "$a0")
        )); ("$recvChan2", (λ: "$recvVal",
        let: "ok" := (ref_ty boolT (zero_val boolT)) in
        let: "i3" := (ref_ty intT (zero_val intT)) in
        let: ("$ret0", "$ret1") := "$recvVal" in
        let: "$r0" := "$ret0" in
        let: "$r1" := "$ret1" in
        do:  ("i3" <-[intT] "$r0");;;
        do:  ("ok" <-[boolT] "$r1");;;
        (if: ![boolT] "ok"
        then
          do:  (let: "$a0" := ((let: "$sl0" := (interface.make string__mset #"received ") in
          let: "$sl1" := (interface.make int__mset (![intT] "i3")) in
          let: "$sl2" := (interface.make string__mset #" from c3
          ") in
          slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
          fmt.Print "$a0")
        else
          do:  (let: "$a0" := ((let: "$sl0" := (interface.make string__mset #"c3 is closed
          ") in
          slice.literal interfaceT ["$sl0"])) in
          fmt.Print "$a0"))
        )); ("$recvChan3", (λ: "$recvVal",
        let: "$r0" := (Fst "$recvVal") in
        do:  ((slice.elem_ref intT (![sliceT] "a") (f #())) <-[intT] "$r0");;;
        do:  #()
        ))] (InjR (λ: <>,
      do:  (let: "$a0" := ((let: "$sl0" := (interface.make string__mset #"no communication
      ") in
      slice.literal interfaceT ["$sl0"])) in
      fmt.Print "$a0")
      )));;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      do:  (chan.select [("$sendVal0", "$sendChan0", (λ: <>,
          do:  #()
          )); ("$sendVal1", "$sendChan1", (λ: <>,
          do:  #()
          ))] [] (InjLV #())));;;
    do:  (chan.select [] [] (InjLV #()))).

(* go: chan.go:58:6 *)
Definition chanDirectional : val :=
  rec: "chanDirectional" <> :=
    exception_do (let: "x" := (ref_ty (chanT uint64T) (zero_val (chanT uint64T))) in
    let: "y" := (ref_ty (chanT stringT) (zero_val (chanT stringT))) in
    do:  (Fst (chan.receive (![chanT uint64T] "x")));;;
    do:  (let: "$chan" := (![chanT stringT] "y") in
    let: "$v" := #"" in
    chan.send "$chan" "$v")).

Definition importantStruct : go_type := structT [
].

Definition importantStruct__mset : list (string * val) := [
].

Definition importantStruct__mset_ptr : list (string * val) := [
].

(* doSubtleThings does a number of subtle things:

   (actually, it does nothing)

   go: comments.go:12:6 *)
Definition doSubtleThings : val :=
  rec: "doSubtleThings" <> :=
    exception_do (do:  #()).

(* This comment starts a Coq comment ( *

   go: comments.go:15:6 *)
Definition hasStartComment : val :=
  rec: "hasStartComment" <> :=
    exception_do (do:  #()).

(* This comment * ) ends a Coq comment

   go: comments.go:18:6 *)
Definition hasEndComment : val :=
  rec: "hasEndComment" <> :=
    exception_do (do:  #()).

(* go: condvar.go:5:6 *)
Definition condvarWrapping : val :=
  rec: "condvarWrapping" <> :=
    exception_do (let: "mu" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty sync.Mutex (zero_val sync.Mutex)) in
    do:  ("mu" <-[ptrT] "$r0");;;
    let: "cond1" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (let: "$a0" := (interface.make sync.Mutex__mset_ptr (![ptrT] "mu")) in
    sync.NewCond "$a0") in
    do:  ("cond1" <-[ptrT] "$r0");;;
    let: "$r0" := (ref_ty sync.Mutex (zero_val sync.Mutex)) in
    do:  ("mu" <-[ptrT] "$r0");;;
    do:  ((sync.Cond__Wait (![ptrT] "cond1")) #())).

Definition GlobalConstant : expr := #"foo".

(* an untyped string *)
Definition UntypedStringConstant : string := "bar".

Definition UntypedInt : Z := 13.

Definition OtherUntypedInt : Z := UntypedInt + UntypedInt.

Definition TypedInt : expr := #(W64 32).

Definition ConstWithArith : expr := #(W64 4) + (#(W64 3) * TypedInt).

Definition TypedInt32 : expr := #(W32 3).

Definition DivisionInConst : expr := #(W64 ((4096 - 8) `quot` 8)).

(* 517 *)
Definition ModInConst : expr := #(W64 (513 + (12 `rem` 8))).

(* 5 *)
Definition ModInConstParens : expr := #(W64 ((513 + 12) `rem` 8)).

Definition First : Z := 0.

Definition Second : Z := 1.

Definition Third : Z := 2.

Definition ComplicatedFirst : expr := #(W64 ((2 * 0) + 3)).

Definition ComplicatedSecond : expr := #(W64 5).

Definition ComplicatedThird : expr := #(W64 7).

(* go: const.go:35:6 *)
Definition useUntypedInt : val :=
  rec: "useUntypedInt" <> :=
    exception_do (return: (#(W64 UntypedInt) + TypedInt)).

(* go: const.go:39:6 *)
Definition useUntypedString : val :=
  rec: "useUntypedString" <> :=
    exception_do (return: (#UntypedStringConstant)).

(* go: control_flow.go:3:6 *)
Definition conditionalReturn : val :=
  rec: "conditionalReturn" "x" :=
    exception_do (let: "x" := (ref_ty boolT "x") in
    (if: ![boolT] "x"
    then return: (#(W64 0))
    else do:  #());;;
    return: (#(W64 1))).

(* go: control_flow.go:10:6 *)
Definition alwaysReturn : val :=
  rec: "alwaysReturn" "x" :=
    exception_do (let: "x" := (ref_ty boolT "x") in
    (if: ![boolT] "x"
    then return: (#(W64 0))
    else return: (#(W64 1)))).

(* go: control_flow.go:18:6 *)
Definition alwaysReturnInNestedBranches : val :=
  rec: "alwaysReturnInNestedBranches" "x" :=
    exception_do (let: "x" := (ref_ty boolT "x") in
    (if: (~ (![boolT] "x"))
    then
      (if: ![boolT] "x"
      then return: (#(W64 0))
      else return: (#(W64 1)))
    else do:  #());;;
    let: "y" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := #(W64 14) in
    do:  ("y" <-[uint64T] "$r0");;;
    return: (![uint64T] "y")).

(* go: control_flow.go:32:6 *)
Definition earlyReturn : val :=
  rec: "earlyReturn" "x" :=
    exception_do (let: "x" := (ref_ty boolT "x") in
    (if: ![boolT] "x"
    then return: (#())
    else do:  #())).

(* go: control_flow.go:38:6 *)
Definition conditionalAssign : val :=
  rec: "conditionalAssign" "x" :=
    exception_do (let: "x" := (ref_ty boolT "x") in
    let: "y" := (ref_ty uint64T (zero_val uint64T)) in
    (if: ![boolT] "x"
    then
      let: "$r0" := #(W64 1) in
      do:  ("y" <-[uint64T] "$r0")
    else
      let: "$r0" := #(W64 2) in
      do:  ("y" <-[uint64T] "$r0"));;;
    do:  ("y" <-[uint64T] ((![uint64T] "y") + #(W64 1)));;;
    return: (![uint64T] "y")).

(* go: control_flow.go:49:6 *)
Definition elseIf : val :=
  rec: "elseIf" "x" "y" :=
    exception_do (let: "y" := (ref_ty boolT "y") in
    let: "x" := (ref_ty boolT "x") in
    (if: ![boolT] "x"
    then return: (#(W64 0))
    else
      (if: ![boolT] "y"
      then return: (#(W64 1))
      else return: (#(W64 2))))).

(* go: control_flow.go:59:6 *)
Definition ifStmtInitialization : val :=
  rec: "ifStmtInitialization" "x" :=
    exception_do (let: "x" := (ref_ty uint64T "x") in
    let: "f" := (ref_ty funcT (zero_val funcT)) in
    let: "$r0" := (λ: <>,
      exception_do (return: (![uint64T] "x"))
      ) in
    do:  ("f" <-[funcT] "$r0");;;
    (do:  ((![funcT] "f") #());;;
    (if: (![uint64T] "x") = #(W64 2)
    then do:  #()
    else
      (let: "z" := (ref_ty uint64T (zero_val uint64T)) in
      let: "$r0" := (![uint64T] "x") in
      do:  ("z" <-[uint64T] "$r0");;;
      (if: (![uint64T] "z") = #(W64 1)
      then do:  #()
      else
        (let: "y" := (ref_ty intT (zero_val intT)) in
        let: "$r0" := #(W64 94) in
        do:  ("y" <-[intT] "$r0");;;
        (if: (![intT] "y") = #(W64 30)
        then do:  #()
        else
          (let: "$r0" := #(W64 10) in
          do:  ("z" <-[uint64T] "$r0");;;
          (if: (![uint64T] "x") = #(W64 30)
          then do:  #()
          else do:  #()))))))));;;
    (let: "y" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := #(W64 10) in
    do:  ("y" <-[uint64T] "$r0");;;
    (if: (![uint64T] "x") = #(W64 0)
    then return: (![uint64T] "y")
    else return: ((![uint64T] "y") - #(W64 1))))).

Definition stringWrapper : go_type := stringT.

Definition stringWrapper__mset : list (string * val) := [
].

Definition stringWrapper__mset_ptr : list (string * val) := [
].

(* go: conversions.go:5:6 *)
Definition typedLiteral : val :=
  rec: "typedLiteral" <> :=
    exception_do (return: (#(W64 3))).

(* go: conversions.go:9:6 *)
Definition literalCast : val :=
  rec: "literalCast" <> :=
    exception_do (let: "x" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := #(W64 2) in
    do:  ("x" <-[uint64T] "$r0");;;
    return: ((![uint64T] "x") + #(W64 2))).

(* go: conversions.go:15:6 *)
Definition castInt : val :=
  rec: "castInt" "p" :=
    exception_do (let: "p" := (ref_ty sliceT "p") in
    return: (let: "$a0" := (![sliceT] "p") in
     slice.len "$a0")).

(* go: conversions.go:19:6 *)
Definition stringToByteSlice : val :=
  rec: "stringToByteSlice" "s" :=
    exception_do (let: "s" := (ref_ty stringT "s") in
    let: "p" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (string.to_bytes (![stringT] "s")) in
    do:  ("p" <-[sliceT] "$r0");;;
    return: (![sliceT] "p")).

(* go: conversions.go:25:6 *)
Definition byteSliceToString : val :=
  rec: "byteSliceToString" "p" :=
    exception_do (let: "p" := (ref_ty sliceT "p") in
    let: "s" := (ref_ty stringT (zero_val stringT)) in
    let: "$r0" := (string.from_bytes (![sliceT] "p")) in
    do:  ("s" <-[stringT] "$r0");;;
    return: (![stringT] "s")).

(* go: conversions.go:31:6 *)
Definition stringToStringWrapper : val :=
  rec: "stringToStringWrapper" "s" :=
    exception_do (let: "s" := (ref_ty stringT "s") in
    return: (![stringT] "s")).

(* go: conversions.go:35:6 *)
Definition stringWrapperToString : val :=
  rec: "stringWrapperToString" "s" :=
    exception_do (let: "s" := (ref_ty stringWrapper "s") in
    return: (![stringWrapper] "s")).

(* go: copy.go:3:6 *)
Definition testCopySimple : val :=
  rec: "testCopySimple" <> :=
    exception_do (let: "x" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (slice.make2 byteT #(W64 10)) in
    do:  ("x" <-[sliceT] "$r0");;;
    let: "$r0" := #(W8 1) in
    do:  ((slice.elem_ref byteT (![sliceT] "x") #(W64 3)) <-[byteT] "$r0");;;
    let: "y" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (slice.make2 byteT #(W64 10)) in
    do:  ("y" <-[sliceT] "$r0");;;
    do:  (let: "$a0" := (![sliceT] "y") in
    let: "$a1" := (![sliceT] "x") in
    (slice.copy byteT) "$a0" "$a1");;;
    return: ((![byteT] (slice.elem_ref byteT (![sliceT] "y") #(W64 3))) = #(W8 1))).

(* go: copy.go:11:6 *)
Definition testCopyDifferentLengths : val :=
  rec: "testCopyDifferentLengths" <> :=
    exception_do (let: "x" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (slice.make2 byteT #(W64 15)) in
    do:  ("x" <-[sliceT] "$r0");;;
    let: "$r0" := #(W8 1) in
    do:  ((slice.elem_ref byteT (![sliceT] "x") #(W64 3)) <-[byteT] "$r0");;;
    let: "$r0" := #(W8 2) in
    do:  ((slice.elem_ref byteT (![sliceT] "x") #(W64 12)) <-[byteT] "$r0");;;
    let: "y" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (slice.make2 byteT #(W64 10)) in
    do:  ("y" <-[sliceT] "$r0");;;
    let: "n" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (let: "$a0" := (![sliceT] "y") in
    let: "$a1" := (![sliceT] "x") in
    (slice.copy byteT) "$a0" "$a1") in
    do:  ("n" <-[uint64T] "$r0");;;
    return: (((![uint64T] "n") = #(W64 10)) && ((![byteT] (slice.elem_ref byteT (![sliceT] "y") #(W64 3))) = #(W8 1)))).

(* go: data_structures.go:7:6 *)
Definition atomicCreateStub : val :=
  rec: "atomicCreateStub" "dir" "fname" "data" :=
    exception_do (let: "data" := (ref_ty sliceT "data") in
    let: "fname" := (ref_ty stringT "fname") in
    let: "dir" := (ref_ty stringT "dir") in
    do:  #()).

(* go: data_structures.go:9:6 *)
Definition useSlice : val :=
  rec: "useSlice" <> :=
    exception_do (let: "s" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (slice.make2 byteT #(W64 1)) in
    do:  ("s" <-[sliceT] "$r0");;;
    let: "s1" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (let: "$a0" := (![sliceT] "s") in
    let: "$a1" := (![sliceT] "s") in
    (slice.append sliceT) "$a0" "$a1") in
    do:  ("s1" <-[sliceT] "$r0");;;
    do:  (let: "$a0" := #"dir" in
    let: "$a1" := #"file" in
    let: "$a2" := (![sliceT] "s1") in
    atomicCreateStub "$a0" "$a1" "$a2")).

(* go: data_structures.go:15:6 *)
Definition useSliceIndexing : val :=
  rec: "useSliceIndexing" <> :=
    exception_do (let: "s" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (slice.make2 uint64T #(W64 2)) in
    do:  ("s" <-[sliceT] "$r0");;;
    let: "$r0" := #(W64 2) in
    do:  ((slice.elem_ref uint64T (![sliceT] "s") #(W64 1)) <-[uint64T] "$r0");;;
    let: "x" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (![uint64T] (slice.elem_ref uint64T (![sliceT] "s") #(W64 0))) in
    do:  ("x" <-[uint64T] "$r0");;;
    return: (![uint64T] "x")).

(* go: data_structures.go:22:6 *)
Definition useMap : val :=
  rec: "useMap" <> :=
    exception_do (let: "m" := (ref_ty (mapT uint64T sliceT) (zero_val (mapT uint64T sliceT))) in
    let: "$r0" := (map.make uint64T sliceT #()) in
    do:  ("m" <-[mapT uint64T sliceT] "$r0");;;
    let: "$r0" := #slice.nil in
    do:  (map.insert (![mapT uint64T sliceT] "m") #(W64 1) "$r0");;;
    let: "ok" := (ref_ty boolT (zero_val boolT)) in
    let: "x" := (ref_ty sliceT (zero_val sliceT)) in
    let: ("$ret0", "$ret1") := (map.get (![mapT uint64T sliceT] "m") #(W64 2)) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("x" <-[sliceT] "$r0");;;
    do:  ("ok" <-[boolT] "$r1");;;
    (if: ![boolT] "ok"
    then return: (#())
    else do:  #());;;
    let: "$r0" := (![sliceT] "x") in
    do:  (map.insert (![mapT uint64T sliceT] "m") #(W64 3) "$r0")).

(* go: data_structures.go:32:6 *)
Definition usePtr : val :=
  rec: "usePtr" <> :=
    exception_do (let: "p" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty uint64T (zero_val uint64T)) in
    do:  ("p" <-[ptrT] "$r0");;;
    let: "$r0" := #(W64 1) in
    do:  ((![ptrT] "p") <-[uint64T] "$r0");;;
    let: "x" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (![uint64T] (![ptrT] "p")) in
    do:  ("x" <-[uint64T] "$r0");;;
    let: "$r0" := (![uint64T] "x") in
    do:  ((![ptrT] "p") <-[uint64T] "$r0")).

(* go: data_structures.go:39:6 *)
Definition iterMapKeysAndValues : val :=
  rec: "iterMapKeysAndValues" "m" :=
    exception_do (let: "m" := (ref_ty (mapT uint64T uint64T) "m") in
    let: "sumPtr" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty uint64T (zero_val uint64T)) in
    do:  ("sumPtr" <-[ptrT] "$r0");;;
    do:  (map.for_range (![mapT uint64T uint64T] "m") (λ: "k" "v",
      let: "sum" := (ref_ty uint64T (zero_val uint64T)) in
      let: "$r0" := (![uint64T] (![ptrT] "sumPtr")) in
      do:  ("sum" <-[uint64T] "$r0");;;
      let: "$r0" := (((![uint64T] "sum") + (![uint64T] "k")) + (![uint64T] "v")) in
      do:  ((![ptrT] "sumPtr") <-[uint64T] "$r0")));;;
    let: "sum" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (![uint64T] (![ptrT] "sumPtr")) in
    do:  ("sum" <-[uint64T] "$r0");;;
    return: (![uint64T] "sum")).

(* go: data_structures.go:49:6 *)
Definition iterMapKeys : val :=
  rec: "iterMapKeys" "m" :=
    exception_do (let: "m" := (ref_ty (mapT uint64T uint64T) "m") in
    let: "keysSlice" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (slice.make2 uint64T #(W64 0)) in
    do:  ("keysSlice" <-[sliceT] "$r0");;;
    let: "keysRef" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty sliceT (zero_val sliceT)) in
    do:  ("keysRef" <-[ptrT] "$r0");;;
    let: "$r0" := (![sliceT] "keysSlice") in
    do:  ((![ptrT] "keysRef") <-[sliceT] "$r0");;;
    do:  (map.for_range (![mapT uint64T uint64T] "m") (λ: "k" <>,
      let: "keys" := (ref_ty sliceT (zero_val sliceT)) in
      let: "$r0" := (![sliceT] (![ptrT] "keysRef")) in
      do:  ("keys" <-[sliceT] "$r0");;;
      let: "newKeys" := (ref_ty sliceT (zero_val sliceT)) in
      let: "$r0" := (let: "$a0" := (![sliceT] "keys") in
      let: "$a1" := ((let: "$sl0" := (![uint64T] "k") in
      slice.literal uint64T ["$sl0"])) in
      (slice.append sliceT) "$a0" "$a1") in
      do:  ("newKeys" <-[sliceT] "$r0");;;
      let: "$r0" := (![sliceT] "newKeys") in
      do:  ((![ptrT] "keysRef") <-[sliceT] "$r0")));;;
    let: "keys" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (![sliceT] (![ptrT] "keysRef")) in
    do:  ("keys" <-[sliceT] "$r0");;;
    return: (![sliceT] "keys")).

(* go: data_structures.go:62:6 *)
Definition getRandom : val :=
  rec: "getRandom" <> :=
    exception_do (let: "r" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (primitive.RandomUint64 #()) in
    do:  ("r" <-[uint64T] "$r0");;;
    return: (![uint64T] "r")).

Definition diskWrapper : go_type := structT [
  "d" :: disk.Disk
].

Definition diskWrapper__mset : list (string * val) := [
].

Definition diskWrapper__mset_ptr : list (string * val) := [
].

(* go: disk.go:9:6 *)
Definition diskArgument : val :=
  rec: "diskArgument" "d" :=
    exception_do (let: "d" := (ref_ty disk.Disk "d") in
    let: "b" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (let: "$a0" := #(W64 0) in
    (interface.get "Read" (![disk.Disk] "d")) "$a0") in
    do:  ("b" <-[sliceT] "$r0");;;
    do:  (let: "$a0" := #(W64 1) in
    let: "$a1" := (![sliceT] "b") in
    (interface.get "Write" (![disk.Disk] "d")) "$a0" "$a1")).

Definition embedA : go_type := structT [
  "a" :: uint64T
].

(* go: embedded.go:19:17 *)
Definition embedA__Foo : val :=
  rec: "embedA__Foo" "a" <> :=
    exception_do (let: "a" := (ref_ty embedA "a") in
    return: (#(W64 0))).

Definition embedA__mset : list (string * val) := [
  ("Foo", embedA__Foo%V)
].

(* go: embedded.go:27:18 *)
Definition embedA__Bar : val :=
  rec: "embedA__Bar" "a" <> :=
    exception_do (let: "a" := (ref_ty ptrT "a") in
    return: (#(W64 13))).

Definition embedA__mset_ptr : list (string * val) := [
  ("Bar", embedA__Bar%V);
  ("Foo", (λ: "$recvAddr",
    embedA__Foo (![embedA] "$recvAddr")
    )%V)
].

Definition embedB : go_type := structT [
  "embedA" :: embedA
].

(* go: embedded.go:23:17 *)
Definition embedB__Foo : val :=
  rec: "embedB__Foo" "a" <> :=
    exception_do (let: "a" := (ref_ty embedB "a") in
    return: (#(W64 10))).

Definition embedB__mset : list (string * val) := [
  ("Foo", embedB__Foo%V)
].

(* go: embedded.go:31:18 *)
Definition embedB__Car : val :=
  rec: "embedB__Car" "a" <> :=
    exception_do (let: "a" := (ref_ty ptrT "a") in
    return: (#(W64 14))).

Definition embedB__mset_ptr : list (string * val) := [
  ("Bar", (λ: "$recvAddr",
    embedA__Bar (struct.field_ref embedB "embedA" "$recvAddr")
    )%V);
  ("Car", embedB__Car%V);
  ("Foo", (λ: "$recvAddr",
    embedB__Foo (![embedB] "$recvAddr")
    )%V)
].

Definition embedC : go_type := structT [
  "embedB" :: ptrT
].

Definition embedC__mset : list (string * val) := [
  ("Bar", (λ: "$recv",
    embedA__Bar (struct.field_ref embedB "embedA" (struct.field_get embedC "embedB" "$recv"))
    )%V);
  ("Car", (λ: "$recv",
    embedB__Car (struct.field_get embedC "embedB" "$recv")
    )%V);
  ("Foo", (λ: "$recv",
    embedB__Foo (![embedB] (struct.field_get embedC "embedB" "$recv"))
    )%V)
].

Definition embedC__mset_ptr : list (string * val) := [
  ("Bar", (λ: "$recvAddr",
    embedA__Bar (struct.field_ref embedB "embedA" (![ptrT] (struct.field_ref embedC "embedB" "$recvAddr")))
    )%V);
  ("Car", (λ: "$recvAddr",
    embedB__Car (![ptrT] (struct.field_ref embedC "embedB" "$recvAddr"))
    )%V);
  ("Foo", (λ: "$recvAddr",
    embedB__Foo (![embedB] (![ptrT] (struct.field_ref embedC "embedB" "$recvAddr")))
    )%V)
].

Definition embedD : go_type := structT [
  "embedC" :: embedC
].

Definition embedD__mset : list (string * val) := [
  ("Bar", (λ: "$recv",
    embedA__Bar (struct.field_ref embedB "embedA" (struct.field_get embedC "embedB" (struct.field_get embedD "embedC" "$recv")))
    )%V);
  ("Car", (λ: "$recv",
    embedB__Car (struct.field_get embedC "embedB" (struct.field_get embedD "embedC" "$recv"))
    )%V);
  ("Foo", (λ: "$recv",
    embedB__Foo (![embedB] (struct.field_get embedC "embedB" (struct.field_get embedD "embedC" "$recv")))
    )%V)
].

Definition embedD__mset_ptr : list (string * val) := [
  ("Bar", (λ: "$recvAddr",
    embedA__Bar (struct.field_ref embedB "embedA" (![ptrT] (struct.field_ref embedC "embedB" (struct.field_ref embedD "embedC" "$recvAddr"))))
    )%V);
  ("Car", (λ: "$recvAddr",
    embedB__Car (![ptrT] (struct.field_ref embedC "embedB" (struct.field_ref embedD "embedC" "$recvAddr")))
    )%V);
  ("Foo", (λ: "$recvAddr",
    embedB__Foo (![embedB] (![ptrT] (struct.field_ref embedC "embedB" (struct.field_ref embedD "embedC" "$recvAddr"))))
    )%V)
].

(* go: embedded.go:35:6 *)
Definition returnEmbedVal : val :=
  rec: "returnEmbedVal" <> :=
    exception_do (return: (struct.make embedB [{
     }])).

(* go: embedded.go:39:6 *)
Definition returnEmbedValWithPointer : val :=
  rec: "returnEmbedValWithPointer" <> :=
    exception_do (return: (struct.make embedD [{
     }])).

(* go: embedded.go:43:6 *)
Definition useEmbeddedField : val :=
  rec: "useEmbeddedField" "d" :=
    exception_do (let: "d" := (ref_ty embedD "d") in
    let: "x" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (![uint64T] (struct.field_ref embedA "a" (struct.field_ref embedB "embedA" (![ptrT] (struct.field_ref embedC "embedB" (struct.field_ref embedD "embedC" "d")))))) in
    do:  ("x" <-[uint64T] "$r0");;;
    let: "$r0" := (![uint64T] (struct.field_ref embedA "a" (struct.field_ref embedB "embedA" (![ptrT] (struct.field_ref embedC "embedB" (struct.field_ref embedD "embedC" "d")))))) in
    do:  ("x" <-[uint64T] "$r0");;;
    let: "$r0" := #(W64 10) in
    do:  ((struct.field_ref embedA "a" (struct.field_ref embedB "embedA" (![ptrT] (struct.field_ref embedC "embedB" (struct.field_ref embedD "embedC" "d"))))) <-[uint64T] "$r0");;;
    let: "y" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty embedD (struct.make embedD [{
    }])) in
    do:  ("y" <-[ptrT] "$r0");;;
    let: "$r0" := #(W64 11) in
    do:  ((struct.field_ref embedA "a" (struct.field_ref embedB "embedA" (![ptrT] (struct.field_ref embedC "embedB" (struct.field_ref embedD "embedC" (![ptrT] "y")))))) <-[uint64T] "$r0");;;
    return: (![uint64T] "x")).

(* go: embedded.go:54:6 *)
Definition useEmbeddedValField : val :=
  rec: "useEmbeddedValField" <> :=
    exception_do (let: "x" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (struct.field_get embedA "a" (struct.field_get embedB "embedA" (returnEmbedVal #()))) in
    do:  ("x" <-[uint64T] "$r0");;;
    let: "$r0" := (![uint64T] (struct.field_ref embedA "a" (struct.field_ref embedB "embedA" (struct.field_get embedC "embedB" (struct.field_get embedD "embedC" (returnEmbedValWithPointer #())))))) in
    do:  ("x" <-[uint64T] "$r0");;;
    return: (![uint64T] "x")).

(* go: embedded.go:60:6 *)
Definition useEmbeddedMethod : val :=
  rec: "useEmbeddedMethod" "d" :=
    exception_do (let: "d" := (ref_ty embedD "d") in
    return: (((embedB__Foo (![embedB] (![ptrT] (struct.field_ref embedC "embedB" (struct.field_ref embedD "embedC" "d"))))) #()) = ((embedA__Foo (![embedA] (struct.field_ref embedB "embedA" (![ptrT] (struct.field_ref embedC "embedB" (struct.field_ref embedD "embedC" "d")))))) #()))).

(* go: embedded.go:64:6 *)
Definition useEmbeddedMethod2 : val :=
  rec: "useEmbeddedMethod2" "d" :=
    exception_do (let: "d" := (ref_ty embedD "d") in
    do:  ((embedB__Car (![ptrT] (struct.field_ref embedC "embedB" (struct.field_ref embedD "embedC" "d")))) #());;;
    return: (((embedA__Bar (struct.field_ref embedB "embedA" (![ptrT] (struct.field_ref embedC "embedB" (struct.field_ref embedD "embedC" "d"))))) #()) = ((embedA__Bar (struct.field_ref embedB "embedA" (![ptrT] (struct.field_ref embedC "embedB" (struct.field_ref embedD "embedC" "d"))))) #()))).

(* go: empty_functions.go:3:6 *)
Definition empty : val :=
  rec: "empty" <> :=
    exception_do (do:  #()).

(* go: empty_functions.go:5:6 *)
Definition emptyReturn : val :=
  rec: "emptyReturn" <> :=
    exception_do (return: (#())).

Definition Enc : go_type := structT [
  "p" :: sliceT
].

Definition Enc__mset : list (string * val) := [
].

(* go: encoding.go:9:15 *)
Definition Enc__consume : val :=
  rec: "Enc__consume" "e" "n" :=
    exception_do (let: "e" := (ref_ty ptrT "e") in
    let: "n" := (ref_ty uint64T "n") in
    let: "b" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (let: "$s" := (![sliceT] (struct.field_ref Enc "p" (![ptrT] "e"))) in
    slice.slice byteT "$s" #(W64 0) (![uint64T] "n")) in
    do:  ("b" <-[sliceT] "$r0");;;
    let: "$r0" := (let: "$s" := (![sliceT] (struct.field_ref Enc "p" (![ptrT] "e"))) in
    slice.slice byteT "$s" (![uint64T] "n") (slice.len "$s")) in
    do:  ((struct.field_ref Enc "p" (![ptrT] "e")) <-[sliceT] "$r0");;;
    return: (![sliceT] "b")).

(* go: encoding.go:19:15 *)
Definition Enc__UInt32 : val :=
  rec: "Enc__UInt32" "e" "x" :=
    exception_do (let: "e" := (ref_ty ptrT "e") in
    let: "x" := (ref_ty uint32T "x") in
    do:  (let: "$a0" := (let: "$a0" := #(W64 4) in
    (Enc__consume (![ptrT] "e")) "$a0") in
    let: "$a1" := (![uint32T] "x") in
    primitive.UInt32Put "$a0" "$a1")).

(* go: encoding.go:15:15 *)
Definition Enc__UInt64 : val :=
  rec: "Enc__UInt64" "e" "x" :=
    exception_do (let: "e" := (ref_ty ptrT "e") in
    let: "x" := (ref_ty uint64T "x") in
    do:  (let: "$a0" := (let: "$a0" := #(W64 8) in
    (Enc__consume (![ptrT] "e")) "$a0") in
    let: "$a1" := (![uint64T] "x") in
    primitive.UInt64Put "$a0" "$a1")).

Definition Enc__mset_ptr : list (string * val) := [
  ("UInt32", Enc__UInt32%V);
  ("UInt64", Enc__UInt64%V);
  ("consume", Enc__consume%V)
].

Definition Dec : go_type := structT [
  "p" :: sliceT
].

Definition Dec__mset : list (string * val) := [
].

(* go: encoding.go:27:15 *)
Definition Dec__consume : val :=
  rec: "Dec__consume" "d" "n" :=
    exception_do (let: "d" := (ref_ty ptrT "d") in
    let: "n" := (ref_ty uint64T "n") in
    let: "b" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (let: "$s" := (![sliceT] (struct.field_ref Dec "p" (![ptrT] "d"))) in
    slice.slice byteT "$s" #(W64 0) (![uint64T] "n")) in
    do:  ("b" <-[sliceT] "$r0");;;
    let: "$r0" := (let: "$s" := (![sliceT] (struct.field_ref Dec "p" (![ptrT] "d"))) in
    slice.slice byteT "$s" (![uint64T] "n") (slice.len "$s")) in
    do:  ((struct.field_ref Dec "p" (![ptrT] "d")) <-[sliceT] "$r0");;;
    return: (![sliceT] "b")).

(* go: encoding.go:37:15 *)
Definition Dec__UInt32 : val :=
  rec: "Dec__UInt32" "d" <> :=
    exception_do (let: "d" := (ref_ty ptrT "d") in
    return: (let: "$a0" := (let: "$a0" := #(W64 4) in
     (Dec__consume (![ptrT] "d")) "$a0") in
     primitive.UInt32Get "$a0")).

(* go: encoding.go:33:15 *)
Definition Dec__UInt64 : val :=
  rec: "Dec__UInt64" "d" <> :=
    exception_do (let: "d" := (ref_ty ptrT "d") in
    return: (let: "$a0" := (let: "$a0" := #(W64 8) in
     (Dec__consume (![ptrT] "d")) "$a0") in
     primitive.UInt64Get "$a0")).

Definition Dec__mset_ptr : list (string * val) := [
  ("UInt32", Dec__UInt32%V);
  ("UInt64", Dec__UInt64%V);
  ("consume", Dec__consume%V)
].

(* go: higher_order.go:3:6 *)
Definition TakesFunctionType : val :=
  rec: "TakesFunctionType" "f" :=
    exception_do (let: "f" := (ref_ty funcT "f") in
    do:  ((![funcT] "f") #())).

Definition Fooer : go_type := interfaceT.

Definition concreteFooer : go_type := structT [
  "a" :: uint64T
].

Definition concreteFooer__mset : list (string * val) := [
].

(* go: interfaces.go:15:25 *)
Definition concreteFooer__Foo : val :=
  rec: "concreteFooer__Foo" "f" <> :=
    exception_do (let: "f" := (ref_ty ptrT "f") in
    do:  #()).

Definition concreteFooer__mset_ptr : list (string * val) := [
  ("Foo", concreteFooer__Foo%V)
].

Definition FooerUser : go_type := structT [
  "f" :: Fooer
].

Definition FooerUser__mset : list (string * val) := [
].

Definition FooerUser__mset_ptr : list (string * val) := [
].

(* go: interfaces.go:18:6 *)
Definition fooConsumer : val :=
  rec: "fooConsumer" "f" :=
    exception_do (let: "f" := (ref_ty Fooer "f") in
    do:  ((interface.get "Foo" (![Fooer] "f")) #())).

(* go: interfaces.go:22:6 *)
Definition testAssignConcreteToInterface : val :=
  rec: "testAssignConcreteToInterface" "x" :=
    exception_do (let: "x" := (ref_ty ptrT "x") in
    let: "c" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty concreteFooer (struct.make concreteFooer [{
    }])) in
    do:  ("c" <-[ptrT] "$r0");;;
    let: "$r0" := (interface.make concreteFooer__mset_ptr (![ptrT] "c")) in
    do:  ((![ptrT] "x") <-[Fooer] "$r0")).

(* go: interfaces.go:27:6 *)
Definition testPassConcreteToInterfaceArg : val :=
  rec: "testPassConcreteToInterfaceArg" <> :=
    exception_do (let: "c" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty concreteFooer (struct.make concreteFooer [{
    }])) in
    do:  ("c" <-[ptrT] "$r0");;;
    do:  (let: "$a0" := (interface.make concreteFooer__mset_ptr (![ptrT] "c")) in
    fooConsumer "$a0");;;
    let: "f" := (ref_ty Fooer (zero_val Fooer)) in
    let: "$r0" := (interface.make concreteFooer__mset_ptr (![ptrT] "c")) in
    do:  ("f" <-[Fooer] "$r0");;;
    do:  (let: "$a0" := (![Fooer] "f") in
    fooConsumer "$a0");;;
    do:  ((concreteFooer__Foo (![ptrT] "c")) #());;;
    do:  ((interface.get "Foo" (![Fooer] "f")) #())).

(* go: interfaces.go:37:6 *)
Definition testPassConcreteToInterfaceArgSpecial : val :=
  rec: "testPassConcreteToInterfaceArgSpecial" <> :=
    exception_do (let: "c1" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty concreteFooer (struct.make concreteFooer [{
    }])) in
    do:  ("c1" <-[ptrT] "$r0");;;
    let: "c2" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty concreteFooer (struct.make concreteFooer [{
    }])) in
    do:  ("c2" <-[ptrT] "$r0");;;
    let: "l" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := ((let: "$sl0" := (interface.make concreteFooer__mset_ptr (![ptrT] "c1")) in
    let: "$sl1" := (interface.make concreteFooer__mset_ptr (![ptrT] "c2")) in
    slice.literal Fooer ["$sl0"; "$sl1"])) in
    do:  ("l" <-[sliceT] "$r0");;;
    let: "m" := (ref_ty (mapT uint64T Fooer) (zero_val (mapT uint64T Fooer))) in
    let: "$r0" := (map.make uint64T Fooer #()) in
    do:  ("m" <-[mapT uint64T Fooer] "$r0");;;
    let: "$r0" := (interface.make concreteFooer__mset_ptr (![ptrT] "c1")) in
    do:  (map.insert (![mapT uint64T Fooer] "m") #(W64 10) "$r0");;;
    let: "f" := (ref_ty FooerUser (zero_val FooerUser)) in
    let: "$r0" := (struct.make FooerUser [{
      "f" ::= interface.make concreteFooer__mset_ptr (![ptrT] "c1")
    }]) in
    do:  ("f" <-[FooerUser] "$r0");;;
    return: (![sliceT] "l", ![mapT uint64T Fooer] "m", ![FooerUser] "f")).

(* go: interfaces.go:51:6 *)
Definition takesVarArgsInterface : val :=
  rec: "takesVarArgsInterface" "fs" :=
    exception_do (let: "fs" := (ref_ty sliceT "fs") in
    do:  ((interface.get "Foo" (![Fooer] (slice.elem_ref Fooer (![sliceT] "fs") #(W64 0)))) #())).

(* go: interfaces.go:55:6 *)
Definition test : val :=
  rec: "test" <> :=
    exception_do (do:  (let: "$a0" := ((let: "$sl0" := (interface.make concreteFooer__mset_ptr (ref_ty concreteFooer (struct.make concreteFooer [{
    }]))) in
    let: "$sl1" := (interface.make concreteFooer__mset_ptr (ref_ty concreteFooer (struct.make concreteFooer [{
    }]))) in
    slice.literal Fooer ["$sl0"; "$sl1"])) in
    takesVarArgsInterface "$a0")).

(* go: interfaces.go:59:6 *)
Definition returnConcrete : val :=
  rec: "returnConcrete" <> :=
    exception_do (return: (ref_ty concreteFooer (struct.make concreteFooer [{
     }]), #(W64 10))).

(* converts an object into an interface in a multiple return destructuring statement.

   go: interfaces.go:64:6 *)
Definition testMultiReturn : val :=
  rec: "testMultiReturn" "x" :=
    exception_do (let: "x" := (ref_ty ptrT "x") in
    let: "y" := (ref_ty uint64T (zero_val uint64T)) in
    let: ("$ret0", "$ret1") := (returnConcrete #()) in
    let: "$r0" := (interface.make concreteFooer__mset_ptr "$ret0") in
    let: "$r1" := "$ret1" in
    do:  ((![ptrT] "x") <-[Fooer] "$r0");;;
    do:  ("y" <-[uint64T] "$r1");;;
    return: (![uint64T] "y")).

(* go: interfaces.go:70:6 *)
Definition testReturnStatment : val :=
  rec: "testReturnStatment" <> :=
    exception_do (let: "y" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty concreteFooer (struct.make concreteFooer [{
    }])) in
    do:  ("y" <-[ptrT] "$r0");;;
    return: (interface.make concreteFooer__mset_ptr (![ptrT] "y"))).

(* go: interfaces.go:75:6 *)
Definition testConversionInEq : val :=
  rec: "testConversionInEq" "f" :=
    exception_do (let: "f" := (ref_ty Fooer "f") in
    let: "c" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty concreteFooer (struct.make concreteFooer [{
    }])) in
    do:  ("c" <-[ptrT] "$r0");;;
    let: "$r0" := (interface.make concreteFooer__mset_ptr (![ptrT] "c")) in
    do:  ("f" <-[Fooer] "$r0");;;
    return: ((interface.make concreteFooer__mset_ptr (![ptrT] "c")) = (![Fooer] "f"))).

(* go: interfaces.go:82:6 *)
Definition takeMultiple : val :=
  rec: "takeMultiple" "a" "f" :=
    exception_do (let: "f" := (ref_ty sliceT "f") in
    let: "a" := (ref_ty uint64T "a") in
    do:  #()).

(* go: interfaces.go:85:6 *)
Definition giveMultiple : val :=
  rec: "giveMultiple" <> :=
    exception_do (return: (#(W64 0), interface.make concreteFooer__mset_ptr (ref_ty concreteFooer (struct.make concreteFooer [{
     }])), ref_ty concreteFooer (struct.make concreteFooer [{
     }]))).

(* go: interfaces.go:89:6 *)
Definition testConversionInMultipleReturnPassThrough : val :=
  rec: "testConversionInMultipleReturnPassThrough" <> :=
    exception_do (let: (("$ret0", "$ret1"), "$ret2") := ((giveMultiple #())) in
    return: ("$ret0", "$ret1", interface.make concreteFooer__mset_ptr "$ret2")).

(* See "special case" in https://go.dev/ref/spec#Calls

   go: interfaces.go:94:6 *)
Definition testConversionInMultiplePassThrough : val :=
  rec: "testConversionInMultiplePassThrough" <> :=
    exception_do (do:  (let: (("$ret0", "$ret1"), "$ret2") := ((giveMultiple #())) in
    let: "$a0" := "$ret0" in
    let: "$a1" := ((let: "$sl0" := "$ret1" in
    let: "$sl1" := (interface.make concreteFooer__mset_ptr "$ret2") in
    slice.literal Fooer ["$sl0"; "$sl1"])) in
    takeMultiple "$a0" "$a1")).

Definition PointerInterface : go_type := interfaceT.

Definition concrete1 : go_type := structT [
].

(* go: interfaces.go:106:20 *)
Definition concrete1__Foo : val :=
  rec: "concrete1__Foo" "c" <> :=
    exception_do (let: "c" := (ref_ty concrete1 "c") in
    do:  #()).

Definition concrete1__mset : list (string * val) := [
  ("Foo", concrete1__Foo%V)
].

(* go: interfaces.go:109:21 *)
Definition concrete1__B : val :=
  rec: "concrete1__B" "c" <> :=
    exception_do (let: "c" := (ref_ty ptrT "c") in
    do:  #()).

Definition concrete1__mset_ptr : list (string * val) := [
  ("B", concrete1__B%V);
  ("Foo", (λ: "$recvAddr",
    concrete1__Foo (![concrete1] "$recvAddr")
    )%V)
].

(* go: interfaces.go:112:6 *)
Definition testPtrMset : val :=
  rec: "testPtrMset" <> :=
    exception_do (let: "a" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty concrete1 (struct.make concrete1 [{
    }])) in
    do:  ("a" <-[ptrT] "$r0");;;
    let: "p" := (ref_ty PointerInterface (zero_val PointerInterface)) in
    let: "$r0" := (interface.make concrete1__mset_ptr (![ptrT] "a")) in
    do:  ("p" <-[PointerInterface] "$r0");;;
    let: "f" := (ref_ty Fooer (zero_val Fooer)) in
    let: "$r0" := (interface.make concrete1__mset (![concrete1] (![ptrT] "a"))) in
    do:  ("f" <-[Fooer] "$r0");;;
    do:  ((interface.get "B" (![PointerInterface] "p")) #());;;
    do:  ((interface.get "Foo" (![Fooer] "f")) #())).

(* go: ints.go:3:6 *)
Definition useInts : val :=
  rec: "useInts" "x" "y" :=
    exception_do (let: "y" := (ref_ty uint32T "y") in
    let: "x" := (ref_ty uint64T "x") in
    let: "z" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (to_u64 (![uint32T] "y")) in
    do:  ("z" <-[uint64T] "$r0");;;
    let: "$r0" := ((![uint64T] "z") + #(W64 1)) in
    do:  ("z" <-[uint64T] "$r0");;;
    let: "y2" := (ref_ty uint32T (zero_val uint32T)) in
    let: "$r0" := ((![uint32T] "y") + #(W32 3)) in
    do:  ("y2" <-[uint32T] "$r0");;;
    return: (![uint64T] "z", ![uint32T] "y2")).

Definition my_u32 : go_type := uint32T.

Definition my_u32__mset : list (string * val) := [
].

Definition my_u32__mset_ptr : list (string * val) := [
].

Definition also_u32 : go_type := my_u32.

Definition also_u32__mset : list (string * val) := [
].

Definition also_u32__mset_ptr : list (string * val) := [
].

Definition ConstWithAbbrevType : expr := #(W32 3).

Definition allTheLiterals : go_type := structT [
  "int" :: uint64T;
  "s" :: stringT;
  "b" :: boolT
].

Definition allTheLiterals__mset : list (string * val) := [
].

Definition allTheLiterals__mset_ptr : list (string * val) := [
].

(* go: literals.go:9:6 *)
Definition normalLiterals : val :=
  rec: "normalLiterals" <> :=
    exception_do (return: (struct.make allTheLiterals [{
       "int" ::= #(W64 0);
       "s" ::= #"foo";
       "b" ::= #true
     }])).

(* go: literals.go:17:6 *)
Definition specialLiterals : val :=
  rec: "specialLiterals" <> :=
    exception_do (return: (struct.make allTheLiterals [{
       "int" ::= #(W64 4096);
       "s" ::= #"";
       "b" ::= #false
     }])).

(* go: literals.go:25:6 *)
Definition oddLiterals : val :=
  rec: "oddLiterals" <> :=
    exception_do (return: (struct.make allTheLiterals [{
       "int" ::= #(W64 5);
       "s" ::= #"backquote string";
       "b" ::= #false
     }])).

(* go: literals.go:33:6 *)
Definition unKeyedLiteral : val :=
  rec: "unKeyedLiteral" <> :=
    exception_do (return: (struct.make allTheLiterals [{
       "int" ::= #(W64 0);
       "s" ::= #"a";
       "b" ::= #false
     }])).

(* go: locks.go:5:6 *)
Definition useLocks : val :=
  rec: "useLocks" <> :=
    exception_do (let: "m" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty sync.Mutex (zero_val sync.Mutex)) in
    do:  ("m" <-[ptrT] "$r0");;;
    do:  ((sync.Mutex__Lock (![ptrT] "m")) #());;;
    do:  ((sync.Mutex__Unlock (![ptrT] "m")) #())).

(* go: locks.go:11:6 *)
Definition useCondVar : val :=
  rec: "useCondVar" <> :=
    exception_do (let: "m" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty sync.Mutex (zero_val sync.Mutex)) in
    do:  ("m" <-[ptrT] "$r0");;;
    let: "c" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (let: "$a0" := (interface.make sync.Mutex__mset_ptr (![ptrT] "m")) in
    sync.NewCond "$a0") in
    do:  ("c" <-[ptrT] "$r0");;;
    do:  ((sync.Mutex__Lock (![ptrT] "m")) #());;;
    do:  ((sync.Cond__Signal (![ptrT] "c")) #());;;
    do:  ((sync.Cond__Wait (![ptrT] "c")) #());;;
    do:  ((sync.Mutex__Unlock (![ptrT] "m")) #())).

Definition hasCondVar : go_type := structT [
  "cond" :: ptrT
].

Definition hasCondVar__mset : list (string * val) := [
].

Definition hasCondVar__mset_ptr : list (string * val) := [
].

(* go: log_debugging.go:5:6 *)
Definition ToBeDebugged : val :=
  rec: "ToBeDebugged" "x" :=
    exception_do (let: "x" := (ref_ty uint64T "x") in
    do:  (let: "$a0" := ((let: "$sl0" := (interface.make string__mset #"starting function") in
    slice.literal interfaceT ["$sl0"])) in
    log.Println "$a0");;;
    do:  (let: "$a0" := #"called with %d" in
    let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] "x")) in
    slice.literal interfaceT ["$sl0"])) in
    log.Printf "$a0" "$a1");;;
    do:  (let: "$a0" := ((let: "$sl0" := (interface.make string__mset #"ending function") in
    slice.literal interfaceT ["$sl0"])) in
    log.Println "$a0");;;
    return: (![uint64T] "x")).

(* go: log_debugging.go:12:6 *)
Definition DoNothing : val :=
  rec: "DoNothing" <> :=
    exception_do (do:  (let: "$a0" := ((let: "$sl0" := (interface.make string__mset #"doing nothing") in
    slice.literal interfaceT ["$sl0"])) in
    log.Println "$a0")).

(* DoSomething is an impure function

   go: loops.go:4:6 *)
Definition DoSomething : val :=
  rec: "DoSomething" "s" :=
    exception_do (let: "s" := (ref_ty stringT "s") in
    do:  #()).

(* go: loops.go:6:6 *)
Definition standardForLoop : val :=
  rec: "standardForLoop" "s" :=
    exception_do (let: "s" := (ref_ty sliceT "s") in
    let: "sumPtr" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty uint64T (zero_val uint64T)) in
    do:  ("sumPtr" <-[ptrT] "$r0");;;
    (let: "i" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[uint64T] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      (if: (![uint64T] "i") < (let: "$a0" := (![sliceT] "s") in
      slice.len "$a0")
      then
        let: "sum" := (ref_ty uint64T (zero_val uint64T)) in
        let: "$r0" := (![uint64T] (![ptrT] "sumPtr")) in
        do:  ("sum" <-[uint64T] "$r0");;;
        let: "x" := (ref_ty uint64T (zero_val uint64T)) in
        let: "$r0" := (![uint64T] (slice.elem_ref uint64T (![sliceT] "s") (![uint64T] "i"))) in
        do:  ("x" <-[uint64T] "$r0");;;
        let: "$r0" := ((![uint64T] "sum") + (![uint64T] "x")) in
        do:  ((![ptrT] "sumPtr") <-[uint64T] "$r0");;;
        let: "$r0" := ((![uint64T] "i") + #(W64 1)) in
        do:  ("i" <-[uint64T] "$r0");;;
        continue: #()
      else do:  #());;;
      break: #()));;;
    let: "sum" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (![uint64T] (![ptrT] "sumPtr")) in
    do:  ("sum" <-[uint64T] "$r0");;;
    return: (![uint64T] "sum")).

(* go: loops.go:25:6 *)
Definition conditionalInLoop : val :=
  rec: "conditionalInLoop" <> :=
    exception_do ((let: "i" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[uint64T] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      (if: (![uint64T] "i") < #(W64 3)
      then
        do:  (let: "$a0" := #"i is small" in
        DoSomething "$a0")
      else do:  #());;;
      (if: (![uint64T] "i") > #(W64 5)
      then break: #()
      else do:  #());;;
      let: "$r0" := ((![uint64T] "i") + #(W64 1)) in
      do:  ("i" <-[uint64T] "$r0");;;
      continue: #()))).

(* go: loops.go:38:6 *)
Definition conditionalInLoopElse : val :=
  rec: "conditionalInLoopElse" <> :=
    exception_do ((let: "i" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[uint64T] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      (if: (![uint64T] "i") > #(W64 5)
      then break: #()
      else
        let: "$r0" := ((![uint64T] "i") + #(W64 1)) in
        do:  ("i" <-[uint64T] "$r0");;;
        continue: #())))).

(* go: loops.go:49:6 *)
Definition nestedConditionalInLoopImplicitContinue : val :=
  rec: "nestedConditionalInLoopImplicitContinue" <> :=
    exception_do ((let: "i" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[uint64T] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      (if: (![uint64T] "i") > #(W64 5)
      then
        (if: (![uint64T] "i") > #(W64 10)
        then break: #()
        else do:  #())
      else
        let: "$r0" := ((![uint64T] "i") + #(W64 1)) in
        do:  ("i" <-[uint64T] "$r0");;;
        continue: #())))).

(* go: loops.go:62:6 *)
Definition ImplicitLoopContinue : val :=
  rec: "ImplicitLoopContinue" <> :=
    exception_do ((let: "i" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[uint64T] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      (if: (![uint64T] "i") < #(W64 4)
      then
        let: "$r0" := #(W64 0) in
        do:  ("i" <-[uint64T] "$r0")
      else do:  #())))).

(* go: loops.go:70:6 *)
Definition ImplicitLoopContinue2 : val :=
  rec: "ImplicitLoopContinue2" <> :=
    exception_do ((let: "i" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[uint64T] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      (if: (![uint64T] "i") < #(W64 4)
      then
        let: "$r0" := #(W64 0) in
        do:  ("i" <-[uint64T] "$r0");;;
        continue: #()
      else do:  #())))).

(* go: loops.go:79:6 *)
Definition ImplicitLoopContinueAfterIfBreak : val :=
  rec: "ImplicitLoopContinueAfterIfBreak" "i" :=
    exception_do (let: "i" := (ref_ty uint64T "i") in
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      (if: (![uint64T] "i") > #(W64 0)
      then break: #()
      else do:  #()))).

(* go: loops.go:87:6 *)
Definition nestedLoops : val :=
  rec: "nestedLoops" <> :=
    exception_do ((let: "i" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[uint64T] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      (let: "j" := (ref_ty uint64T (zero_val uint64T)) in
      let: "$r0" := #(W64 0) in
      do:  ("j" <-[uint64T] "$r0");;;
      (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
        (if: #true
        then break: #()
        else do:  #());;;
        let: "$r0" := ((![uint64T] "j") + #(W64 1)) in
        do:  ("j" <-[uint64T] "$r0");;;
        continue: #()));;;
      let: "$r0" := ((![uint64T] "i") + #(W64 1)) in
      do:  ("i" <-[uint64T] "$r0");;;
      continue: #()))).

(* go: loops.go:101:6 *)
Definition nestedGoStyleLoops : val :=
  rec: "nestedGoStyleLoops" <> :=
    exception_do ((let: "i" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[uint64T] "$r0");;;
    (for: (λ: <>, (![uint64T] "i") < #(W64 10)); (λ: <>, do:  ("i" <-[uint64T] ((![uint64T] "i") + #(W64 1)))) := λ: <>,
      (let: "j" := (ref_ty uint64T (zero_val uint64T)) in
      let: "$r0" := #(W64 0) in
      do:  ("j" <-[uint64T] "$r0");;;
      (for: (λ: <>, (![uint64T] "j") < (![uint64T] "i")); (λ: <>, do:  ("j" <-[uint64T] ((![uint64T] "j") + #(W64 1)))) := λ: <>,
        (if: #true
        then break: #()
        else do:  #());;;
        continue: #()))))).

(* go: loops.go:113:6 *)
Definition sumSlice : val :=
  rec: "sumSlice" "xs" :=
    exception_do (let: "xs" := (ref_ty sliceT "xs") in
    let: "sum" := (ref_ty uint64T (zero_val uint64T)) in
    do:  (let: "$range" := (![sliceT] "xs") in
    slice.for_range uint64T "$range" (λ: <> "x",
      let: "x" := ref_ty uint64T "x" in
      do:  ("sum" <-[uint64T] ((![uint64T] "sum") + (![uint64T] "x")))));;;
    return: (![uint64T] "sum")).

(* go: loops.go:121:6 *)
Definition breakFromLoop : val :=
  rec: "breakFromLoop" <> :=
    exception_do ((for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      (if: #true
      then break: #()
      else do:  #());;;
      continue: #())).

(* go: maps.go:5:6 *)
Definition clearMap : val :=
  rec: "clearMap" "m" :=
    exception_do (let: "m" := (ref_ty (mapT uint64T uint64T) "m") in
    do:  #()).

(* go: maps.go:9:6 *)
Definition IterateMapKeys : val :=
  rec: "IterateMapKeys" "m" "sum" :=
    exception_do (let: "sum" := (ref_ty ptrT "sum") in
    let: "m" := (ref_ty (mapT uint64T uint64T) "m") in
    do:  (map.for_range (![mapT uint64T uint64T] "m") (λ: "k" <>,
      let: "oldSum" := (ref_ty uint64T (zero_val uint64T)) in
      let: "$r0" := (![uint64T] (![ptrT] "sum")) in
      do:  ("oldSum" <-[uint64T] "$r0");;;
      let: "$r0" := ((![uint64T] "oldSum") + (![uint64T] "k")) in
      do:  ((![ptrT] "sum") <-[uint64T] "$r0")))).

(* go: maps.go:16:6 *)
Definition MapSize : val :=
  rec: "MapSize" "m" :=
    exception_do (let: "m" := (ref_ty (mapT uint64T boolT) "m") in
    return: (let: "$a0" := (![mapT uint64T boolT] "m") in
     map.len "$a0")).

Definition IntWrapper : go_type := uint64T.

Definition IntWrapper__mset : list (string * val) := [
].

Definition IntWrapper__mset_ptr : list (string * val) := [
].

Definition MapWrapper : go_type := mapT uint64T boolT.

Definition MapWrapper__mset : list (string * val) := [
].

Definition MapWrapper__mset_ptr : list (string * val) := [
].

(* go: maps.go:24:6 *)
Definition MapTypeAliases : val :=
  rec: "MapTypeAliases" "m1" "m2" :=
    exception_do (let: "m2" := (ref_ty MapWrapper "m2") in
    let: "m1" := (ref_ty (mapT IntWrapper boolT) "m1") in
    let: "$r0" := (Fst (map.get (![MapWrapper] "m2") #(W64 0))) in
    do:  (map.insert (![mapT IntWrapper boolT] "m1") #(W64 4) "$r0")).

(* go: maps.go:28:6 *)
Definition StringMap : val :=
  rec: "StringMap" "m" :=
    exception_do (let: "m" := (ref_ty (mapT stringT uint64T) "m") in
    return: (Fst (map.get (![mapT stringT uint64T] "m") #"foo"))).

Definition mapElem : go_type := structT [
  "a" :: uint64T;
  "b" :: uint64T
].

Definition mapElem__mset : list (string * val) := [
].

Definition mapElem__mset_ptr : list (string * val) := [
].

(* go: maps.go:37:6 *)
Definition mapUpdateField : val :=
  rec: "mapUpdateField" <> :=
    exception_do (let: "x" := (ref_ty (mapT uint64T ptrT) (zero_val (mapT uint64T ptrT))) in
    let: "$r0" := (map.make uint64T ptrT #()) in
    do:  ("x" <-[mapT uint64T ptrT] "$r0");;;
    let: "$r0" := #(W64 10) in
    do:  ((struct.field_ref mapElem "a" (Fst (map.get (![mapT uint64T ptrT] "x") #(W64 0)))) <-[uint64T] "$r0")).

(* go: multiple.go:3:6 *)
Definition returnTwo : val :=
  rec: "returnTwo" "p" :=
    exception_do (let: "p" := (ref_ty sliceT "p") in
    return: (#(W64 0), #(W64 0))).

(* go: multiple.go:7:6 *)
Definition returnTwoWrapper : val :=
  rec: "returnTwoWrapper" "data" :=
    exception_do (let: "data" := (ref_ty sliceT "data") in
    let: "b" := (ref_ty uint64T (zero_val uint64T)) in
    let: "a" := (ref_ty uint64T (zero_val uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![sliceT] "data") in
    returnTwo "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("a" <-[uint64T] "$r0");;;
    do:  ("b" <-[uint64T] "$r1");;;
    return: (![uint64T] "a", ![uint64T] "b")).

(* go: multiple.go:12:6 *)
Definition multipleVar : val :=
  rec: "multipleVar" "x" "y" :=
    exception_do (let: "y" := (ref_ty uint64T "y") in
    let: "x" := (ref_ty uint64T "x") in
    do:  #()).

(* go: multiple.go:14:6 *)
Definition multiplePassThrough : val :=
  rec: "multiplePassThrough" <> :=
    exception_do (do:  (let: ("$ret0", "$ret1") := ((let: "$a0" := #slice.nil in
    returnTwoWrapper "$a0")) in
    let: "$a0" := "$ret0" in
    let: "$a1" := "$ret1" in
    multipleVar "$a0" "$a1")).

(* go: multiple.go:18:6 *)
Definition multipleReturnPassThrough : val :=
  rec: "multipleReturnPassThrough" <> :=
    exception_do (let: ("$ret0", "$ret1") := ((let: "$a0" := #slice.nil in
    returnTwo "$a0")) in
    return: ("$ret0", "$ret1")).

(* go: nil.go:3:6 *)
Definition AssignNilSlice : val :=
  rec: "AssignNilSlice" <> :=
    exception_do (let: "s" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (slice.make2 sliceT #(W64 4)) in
    do:  ("s" <-[sliceT] "$r0");;;
    let: "$r0" := #slice.nil in
    do:  ((slice.elem_ref sliceT (![sliceT] "s") #(W64 2)) <-[sliceT] "$r0")).

(* go: nil.go:8:6 *)
Definition AssignNilPointer : val :=
  rec: "AssignNilPointer" <> :=
    exception_do (let: "s" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (slice.make2 ptrT #(W64 4)) in
    do:  ("s" <-[sliceT] "$r0");;;
    let: "$r0" := #null in
    do:  ((slice.elem_ref ptrT (![sliceT] "s") #(W64 2)) <-[ptrT] "$r0")).

(* go: nil.go:13:6 *)
Definition CompareSliceToNil : val :=
  rec: "CompareSliceToNil" <> :=
    exception_do (let: "s" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (slice.make2 byteT #(W64 0)) in
    do:  ("s" <-[sliceT] "$r0");;;
    return: ((![sliceT] "s") ≠ #slice.nil)).

(* go: nil.go:18:6 *)
Definition ComparePointerToNil : val :=
  rec: "ComparePointerToNil" <> :=
    exception_do (let: "s" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty uint64T (zero_val uint64T)) in
    do:  ("s" <-[ptrT] "$r0");;;
    return: ((![ptrT] "s") ≠ #null)).

(* go: operators.go:3:6 *)
Definition LogicalOperators : val :=
  rec: "LogicalOperators" "b1" "b2" :=
    exception_do (let: "b2" := (ref_ty boolT "b2") in
    let: "b1" := (ref_ty boolT "b1") in
    return: (((![boolT] "b1") && ((![boolT] "b2") || (![boolT] "b1"))) && (~ #false))).

(* go: operators.go:7:6 *)
Definition LogicalAndEqualityOperators : val :=
  rec: "LogicalAndEqualityOperators" "b1" "x" :=
    exception_do (let: "x" := (ref_ty uint64T "x") in
    let: "b1" := (ref_ty boolT "b1") in
    return: (((![uint64T] "x") = #(W64 3)) && ((![boolT] "b1") = #true))).

(* go: operators.go:11:6 *)
Definition ArithmeticShifts : val :=
  rec: "ArithmeticShifts" "x" "y" :=
    exception_do (let: "y" := (ref_ty uint64T "y") in
    let: "x" := (ref_ty uint32T "x") in
    return: (#(W64 0))).

(* go: operators.go:16:6 *)
Definition BitwiseOps : val :=
  rec: "BitwiseOps" "x" "y" :=
    exception_do (let: "y" := (ref_ty uint64T "y") in
    let: "x" := (ref_ty uint32T "x") in
    return: ((to_u64 (![uint32T] "x")) `or` ((to_u64 (to_u32 (![uint64T] "y"))) `and` #(W64 43)))).

(* go: operators.go:20:6 *)
Definition Comparison : val :=
  rec: "Comparison" "x" "y" :=
    exception_do (let: "y" := (ref_ty uint64T "y") in
    let: "x" := (ref_ty uint64T "x") in
    (if: (![uint64T] "x") < (![uint64T] "y")
    then return: (#true)
    else do:  #());;;
    (if: (![uint64T] "x") = (![uint64T] "y")
    then return: (#true)
    else do:  #());;;
    (if: (![uint64T] "x") ≠ (![uint64T] "y")
    then return: (#true)
    else do:  #());;;
    (if: (![uint64T] "x") > (![uint64T] "y")
    then return: (#true)
    else do:  #());;;
    (if: ((![uint64T] "x") + #(W64 1)) > ((![uint64T] "y") - #(W64 2))
    then return: (#true)
    else do:  #());;;
    return: (#false)).

(* go: operators.go:39:6 *)
Definition AssignOps : val :=
  rec: "AssignOps" <> :=
    exception_do (let: "x" := (ref_ty uint64T (zero_val uint64T)) in
    do:  ("x" <-[uint64T] ((![uint64T] "x") + #(W64 3)));;;
    do:  ("x" <-[uint64T] ((![uint64T] "x") - #(W64 3)));;;
    do:  ("x" <-[uint64T] ((![uint64T] "x") + #(W64 1)));;;
    do:  ("x" <-[uint64T] ((![uint64T] "x") - #(W64 1)))).

Definition wrapExternalStruct : go_type := structT [
  "e" :: marshal.Enc;
  "d" :: marshal.Dec
].

(* go: package.go:14:29 *)
Definition wrapExternalStruct__moveUint64 : val :=
  rec: "wrapExternalStruct__moveUint64" "w" <> :=
    exception_do (let: "w" := (ref_ty wrapExternalStruct "w") in
    do:  (let: "$a0" := ((marshal.Dec__GetInt (![marshal.Dec] (struct.field_ref wrapExternalStruct "d" "w"))) #()) in
    (marshal.Enc__PutInt (![marshal.Enc] (struct.field_ref wrapExternalStruct "e" "w"))) "$a0")).

Definition wrapExternalStruct__mset : list (string * val) := [
  ("moveUint64", wrapExternalStruct__moveUint64%V)
].

Definition wrapExternalStruct__mset_ptr : list (string * val) := [
  ("moveUint64", (λ: "$recvAddr",
    wrapExternalStruct__moveUint64 (![wrapExternalStruct] "$recvAddr")
    )%V)
].

(* go: panic.go:3:6 *)
Definition PanicAtTheDisco : val :=
  rec: "PanicAtTheDisco" <> :=
    exception_do (do:  (let: "$a0" := (interface.make string__mset #"disco") in
    Panic "$a0")).

(* go: proph.go:5:6 *)
Definition Oracle : val :=
  rec: "Oracle" <> :=
    exception_do (let: "p" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (primitive.NewProph #()) in
    do:  ("p" <-[ptrT] "$r0");;;
    let: "$r0" := (![ptrT] "p") in
    do:  ("p" <-[ptrT] "$r0")).

Definition typing : go_type := structT [
  "proph" :: ptrT
].

Definition typing__mset : list (string * val) := [
].

Definition typing__mset_ptr : list (string * val) := [
].

Definition composite : go_type := structT [
  "a" :: uint64T;
  "b" :: uint64T
].

Definition composite__mset : list (string * val) := [
].

Definition composite__mset_ptr : list (string * val) := [
].

(* go: reassign.go:8:6 *)
Definition ReassignVars : val :=
  rec: "ReassignVars" <> :=
    exception_do (let: "x" := (ref_ty uint64T (zero_val uint64T)) in
    let: "y" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("y" <-[uint64T] "$r0");;;
    let: "$r0" := #(W64 3) in
    do:  ("x" <-[uint64T] "$r0");;;
    let: "z" := (ref_ty composite (zero_val composite)) in
    let: "$r0" := (struct.make composite [{
      "a" ::= ![uint64T] "x";
      "b" ::= ![uint64T] "y"
    }]) in
    do:  ("z" <-[composite] "$r0");;;
    let: "$r0" := (struct.make composite [{
      "a" ::= ![uint64T] "y";
      "b" ::= ![uint64T] "x"
    }]) in
    do:  ("z" <-[composite] "$r0");;;
    let: "$r0" := (![uint64T] (struct.field_ref composite "a" "z")) in
    do:  ("x" <-[uint64T] "$r0")).

(* go: recursive.go:3:6 *)
Definition recur : val :=
  rec: "recur" <> :=
    exception_do (do:  ("recur" #())).

Definition R : go_type := structT [
].

Definition R__mset : list (string * val) := [
].

(* go: recursive.go:10:13 *)
Definition R__recurMethod : val :=
  rec: "R__recurMethod" "r" <> :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    do:  (("R__recurMethod" (![ptrT] "r")) #())).

Definition R__mset_ptr : list (string * val) := [
  ("recurMethod", R__recurMethod%V)
].

Definition Other : go_type := structT [
  "RecursiveEmbedded" :: ptrT
].

Definition Other__mset : list (string * val) := [
].

Definition Other__mset_ptr : list (string * val) := [
].

Definition RecursiveEmbedded : go_type := structT [
  "Other" :: Other
].

Definition RecursiveEmbedded__mset : list (string * val) := [
].

(* go: recursive.go:22:29 *)
Definition RecursiveEmbedded__recurEmbeddedMethod : val :=
  rec: "RecursiveEmbedded__recurEmbeddedMethod" "r" <> :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    do:  (("RecursiveEmbedded__recurEmbeddedMethod" (![ptrT] (struct.field_ref Other "RecursiveEmbedded" (struct.field_ref RecursiveEmbedded "Other" (![ptrT] "r"))))) #())).

Definition RecursiveEmbedded__mset_ptr : list (string * val) := [
  ("recurEmbeddedMethod", RecursiveEmbedded__recurEmbeddedMethod%V)
].

Definition Block : go_type := structT [
  "Value" :: uint64T
].

Definition Block__mset : list (string * val) := [
].

Definition Block__mset_ptr : list (string * val) := [
].

Definition Disk1 : expr := #(W64 0).

Definition Disk2 : expr := #(W64 0).

Definition DiskSize : expr := #(W64 1000).

(* TwoDiskWrite is a dummy function to represent the base layer's disk write

   go: replicated_disk.go:12:6 *)
Definition TwoDiskWrite : val :=
  rec: "TwoDiskWrite" "diskId" "a" "v" :=
    exception_do (let: "v" := (ref_ty Block "v") in
    let: "a" := (ref_ty uint64T "a") in
    let: "diskId" := (ref_ty uint64T "diskId") in
    return: (#true)).

(* TwoDiskRead is a dummy function to represent the base layer's disk read

   go: replicated_disk.go:17:6 *)
Definition TwoDiskRead : val :=
  rec: "TwoDiskRead" "diskId" "a" :=
    exception_do (let: "a" := (ref_ty uint64T "a") in
    let: "diskId" := (ref_ty uint64T "diskId") in
    return: (struct.make Block [{
       "Value" ::= #(W64 0)
     }], #true)).

(* TwoDiskLock is a dummy function to represent locking an address in the
   base layer

   go: replicated_disk.go:23:6 *)
Definition TwoDiskLock : val :=
  rec: "TwoDiskLock" "a" :=
    exception_do (let: "a" := (ref_ty uint64T "a") in
    do:  #()).

(* TwoDiskUnlock is a dummy function to represent unlocking an address in the
   base layer

   go: replicated_disk.go:27:6 *)
Definition TwoDiskUnlock : val :=
  rec: "TwoDiskUnlock" "a" :=
    exception_do (let: "a" := (ref_ty uint64T "a") in
    do:  #()).

(* go: replicated_disk.go:29:6 *)
Definition ReplicatedDiskRead : val :=
  rec: "ReplicatedDiskRead" "a" :=
    exception_do (let: "a" := (ref_ty uint64T "a") in
    do:  (let: "$a0" := (![uint64T] "a") in
    TwoDiskLock "$a0");;;
    let: "ok" := (ref_ty boolT (zero_val boolT)) in
    let: "v" := (ref_ty Block (zero_val Block)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := Disk1 in
    let: "$a1" := (![uint64T] "a") in
    TwoDiskRead "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("v" <-[Block] "$r0");;;
    do:  ("ok" <-[boolT] "$r1");;;
    (if: ![boolT] "ok"
    then
      do:  (let: "$a0" := (![uint64T] "a") in
      TwoDiskUnlock "$a0");;;
      return: (![Block] "v")
    else do:  #());;;
    let: "v2" := (ref_ty Block (zero_val Block)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := Disk2 in
    let: "$a1" := (![uint64T] "a") in
    TwoDiskRead "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("v2" <-[Block] "$r0");;;
    do:  "$r1";;;
    do:  (let: "$a0" := (![uint64T] "a") in
    TwoDiskUnlock "$a0");;;
    return: (![Block] "v2")).

(* go: replicated_disk.go:42:6 *)
Definition ReplicatedDiskWrite : val :=
  rec: "ReplicatedDiskWrite" "a" "v" :=
    exception_do (let: "v" := (ref_ty Block "v") in
    let: "a" := (ref_ty uint64T "a") in
    do:  (let: "$a0" := (![uint64T] "a") in
    TwoDiskLock "$a0");;;
    do:  (let: "$a0" := Disk1 in
    let: "$a1" := (![uint64T] "a") in
    let: "$a2" := (![Block] "v") in
    TwoDiskWrite "$a0" "$a1" "$a2");;;
    do:  (let: "$a0" := Disk2 in
    let: "$a1" := (![uint64T] "a") in
    let: "$a2" := (![Block] "v") in
    TwoDiskWrite "$a0" "$a1" "$a2");;;
    do:  (let: "$a0" := (![uint64T] "a") in
    TwoDiskUnlock "$a0")).

(* go: replicated_disk.go:49:6 *)
Definition ReplicatedDiskRecover : val :=
  rec: "ReplicatedDiskRecover" <> :=
    exception_do ((let: "a" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("a" <-[uint64T] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      (if: (![uint64T] "a") > DiskSize
      then break: #()
      else do:  #());;;
      let: "ok" := (ref_ty boolT (zero_val boolT)) in
      let: "v" := (ref_ty Block (zero_val Block)) in
      let: ("$ret0", "$ret1") := (let: "$a0" := Disk1 in
      let: "$a1" := (![uint64T] "a") in
      TwoDiskRead "$a0" "$a1") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("v" <-[Block] "$r0");;;
      do:  ("ok" <-[boolT] "$r1");;;
      (if: ![boolT] "ok"
      then
        do:  (let: "$a0" := Disk2 in
        let: "$a1" := (![uint64T] "a") in
        let: "$a2" := (![Block] "v") in
        TwoDiskWrite "$a0" "$a1" "$a2")
      else do:  #());;;
      let: "$r0" := ((![uint64T] "a") + #(W64 1)) in
      do:  ("a" <-[uint64T] "$r0");;;
      continue: #()))).

Definition SliceAlias : go_type := sliceT.

Definition SliceAlias__mset : list (string * val) := [
].

Definition SliceAlias__mset_ptr : list (string * val) := [
].

(* go: slices.go:5:6 *)
Definition sliceOps : val :=
  rec: "sliceOps" <> :=
    exception_do (let: "x" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (slice.make2 uint64T #(W64 10)) in
    do:  ("x" <-[sliceT] "$r0");;;
    let: "v1" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (![uint64T] (slice.elem_ref uint64T (![sliceT] "x") #(W64 2))) in
    do:  ("v1" <-[uint64T] "$r0");;;
    let: "v2" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (let: "$s" := (![sliceT] "x") in
    slice.slice uint64T "$s" #(W64 2) #(W64 3)) in
    do:  ("v2" <-[sliceT] "$r0");;;
    let: "v3" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (let: "$s" := (![sliceT] "x") in
    slice.slice uint64T "$s" #(W64 0) #(W64 3)) in
    do:  ("v3" <-[sliceT] "$r0");;;
    let: "v4" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (slice.elem_ref uint64T (![sliceT] "x") #(W64 2)) in
    do:  ("v4" <-[ptrT] "$r0");;;
    return: ((((((![uint64T] "v1") + (![uint64T] (slice.elem_ref uint64T (![sliceT] "v2") #(W64 0)))) + (![uint64T] (slice.elem_ref uint64T (![sliceT] "v3") #(W64 1)))) + (![uint64T] (![ptrT] "v4"))) + (let: "$a0" := (![sliceT] "x") in
     slice.len "$a0")) + (let: "$a0" := (![sliceT] "x") in
     slice.cap "$a0"))).

(* go: slices.go:14:6 *)
Definition makeSingletonSlice : val :=
  rec: "makeSingletonSlice" "x" :=
    exception_do (let: "x" := (ref_ty uint64T "x") in
    return: ((let: "$sl0" := (![uint64T] "x") in
     slice.literal uint64T ["$sl0"]))).

Definition thing : go_type := structT [
  "x" :: uint64T
].

Definition thing__mset : list (string * val) := [
].

Definition thing__mset_ptr : list (string * val) := [
].

Definition sliceOfThings : go_type := structT [
  "things" :: sliceT
].

(* go: slices.go:26:25 *)
Definition sliceOfThings__getThingRef : val :=
  rec: "sliceOfThings__getThingRef" "ts" "i" :=
    exception_do (let: "ts" := (ref_ty sliceOfThings "ts") in
    let: "i" := (ref_ty uint64T "i") in
    return: (slice.elem_ref thing (![sliceT] (struct.field_ref sliceOfThings "things" "ts")) (![uint64T] "i"))).

Definition sliceOfThings__mset : list (string * val) := [
  ("getThingRef", sliceOfThings__getThingRef%V)
].

Definition sliceOfThings__mset_ptr : list (string * val) := [
  ("getThingRef", (λ: "$recvAddr",
    sliceOfThings__getThingRef (![sliceOfThings] "$recvAddr")
    )%V)
].

(* go: slices.go:30:6 *)
Definition makeAlias : val :=
  rec: "makeAlias" <> :=
    exception_do (return: (slice.make2 boolT #(W64 10))).

(* Skip is a placeholder for some impure code

   go: spawn.go:8:6 *)
Definition Skip : val :=
  rec: "Skip" <> :=
    exception_do (do:  #()).

(* go: spawn.go:10:6 *)
Definition simpleSpawn : val :=
  rec: "simpleSpawn" <> :=
    exception_do (let: "l" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty sync.Mutex (zero_val sync.Mutex)) in
    do:  ("l" <-[ptrT] "$r0");;;
    let: "v" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty uint64T (zero_val uint64T)) in
    do:  ("v" <-[ptrT] "$r0");;;
    let: "$go" := (λ: <>,
      exception_do (do:  ((sync.Mutex__Lock (![ptrT] "l")) #());;;
      let: "x" := (ref_ty uint64T (zero_val uint64T)) in
      let: "$r0" := (![uint64T] (![ptrT] "v")) in
      do:  ("x" <-[uint64T] "$r0");;;
      (if: (![uint64T] "x") > #(W64 0)
      then do:  (Skip #())
      else do:  #());;;
      do:  ((sync.Mutex__Unlock (![ptrT] "l")) #()))
      ) in
    do:  (Fork ("$go" #()));;;
    do:  ((sync.Mutex__Lock (![ptrT] "l")) #());;;
    let: "$r0" := #(W64 1) in
    do:  ((![ptrT] "v") <-[uint64T] "$r0");;;
    do:  ((sync.Mutex__Unlock (![ptrT] "l")) #())).

(* go: spawn.go:26:6 *)
Definition threadCode : val :=
  rec: "threadCode" "tid" :=
    exception_do (let: "tid" := (ref_ty uint64T "tid") in
    do:  #()).

(* go: spawn.go:28:6 *)
Definition loopSpawn : val :=
  rec: "loopSpawn" <> :=
    exception_do ((let: "i" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[uint64T] "$r0");;;
    (for: (λ: <>, (![uint64T] "i") < #(W64 10)); (λ: <>, do:  ("i" <-[uint64T] ((![uint64T] "i") + #(W64 1)))) := λ: <>,
      let: "i" := (ref_ty uint64T (zero_val uint64T)) in
      let: "$r0" := (![uint64T] "i") in
      do:  ("i" <-[uint64T] "$r0");;;
      let: "$go" := (λ: <>,
        exception_do (do:  (let: "$a0" := (![uint64T] "i") in
        threadCode "$a0"))
        ) in
      do:  (Fork ("$go" #()))));;;
    (let: "dummy" := (ref_ty boolT (zero_val boolT)) in
    let: "$r0" := #true in
    do:  ("dummy" <-[boolT] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "$r0" := (~ (![boolT] "dummy")) in
      do:  ("dummy" <-[boolT] "$r0");;;
      continue: #()))).

(* go: strings.go:3:6 *)
Definition stringAppend : val :=
  rec: "stringAppend" "s" :=
    exception_do (let: "s" := (ref_ty stringT "s") in
    return: ((#"prefix " + (![stringT] "s")) + #" ")).

(* go: strings.go:7:6 *)
Definition stringLength : val :=
  rec: "stringLength" "s" :=
    exception_do (let: "s" := (ref_ty stringT "s") in
    return: (let: "$a0" := (![stringT] "s") in
     StringLength "$a0")).

Definition Point : go_type := structT [
  "x" :: uint64T;
  "y" :: uint64T
].

(* go: struct_method.go:8:16 *)
Definition Point__Add : val :=
  rec: "Point__Add" "c" "z" :=
    exception_do (let: "c" := (ref_ty Point "c") in
    let: "z" := (ref_ty uint64T "z") in
    return: (((![uint64T] (struct.field_ref Point "x" "c")) + (![uint64T] (struct.field_ref Point "y" "c"))) + (![uint64T] "z"))).

(* go: struct_method.go:12:16 *)
Definition Point__GetField : val :=
  rec: "Point__GetField" "c" <> :=
    exception_do (let: "c" := (ref_ty Point "c") in
    let: "x" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (![uint64T] (struct.field_ref Point "x" "c")) in
    do:  ("x" <-[uint64T] "$r0");;;
    let: "y" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (![uint64T] (struct.field_ref Point "y" "c")) in
    do:  ("y" <-[uint64T] "$r0");;;
    return: ((![uint64T] "x") + (![uint64T] "y"))).

Definition Point__mset : list (string * val) := [
  ("Add", Point__Add%V);
  ("GetField", Point__GetField%V)
].

Definition Point__mset_ptr : list (string * val) := [
  ("Add", (λ: "$recvAddr",
    Point__Add (![Point] "$recvAddr")
    )%V);
  ("GetField", (λ: "$recvAddr",
    Point__GetField (![Point] "$recvAddr")
    )%V)
].

(* go: struct_method.go:18:6 *)
Definition UseAdd : val :=
  rec: "UseAdd" <> :=
    exception_do (let: "c" := (ref_ty Point (zero_val Point)) in
    let: "$r0" := (struct.make Point [{
      "x" ::= #(W64 2);
      "y" ::= #(W64 3)
    }]) in
    do:  ("c" <-[Point] "$r0");;;
    let: "r" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (let: "$a0" := #(W64 4) in
    (Point__Add (![Point] "c")) "$a0") in
    do:  ("r" <-[uint64T] "$r0");;;
    return: (![uint64T] "r")).

(* go: struct_method.go:24:6 *)
Definition UseAddWithLiteral : val :=
  rec: "UseAddWithLiteral" <> :=
    exception_do (let: "r" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (let: "$a0" := #(W64 4) in
    (Point__Add (struct.make Point [{
      "x" ::= #(W64 2);
      "y" ::= #(W64 3)
    }])) "$a0") in
    do:  ("r" <-[uint64T] "$r0");;;
    return: (![uint64T] "r")).

Definition TwoInts : go_type := structT [
  "x" :: uint64T;
  "y" :: uint64T
].

Definition TwoInts__mset : list (string * val) := [
].

Definition TwoInts__mset_ptr : list (string * val) := [
].

Definition S : go_type := structT [
  "a" :: uint64T;
  "b" :: TwoInts;
  "c" :: boolT
].

(* go: struct_pointers.go:30:12 *)
Definition S__readBVal : val :=
  rec: "S__readBVal" "s" <> :=
    exception_do (let: "s" := (ref_ty S "s") in
    return: (![TwoInts] (struct.field_ref S "b" "s"))).

Definition S__mset : list (string * val) := [
  ("readBVal", S__readBVal%V)
].

(* go: struct_pointers.go:38:13 *)
Definition S__negateC : val :=
  rec: "S__negateC" "s" <> :=
    exception_do (let: "s" := (ref_ty ptrT "s") in
    let: "$r0" := (~ (![boolT] (struct.field_ref S "c" (![ptrT] "s")))) in
    do:  ((struct.field_ref S "c" (![ptrT] "s")) <-[boolT] "$r0")).

(* go: struct_pointers.go:22:13 *)
Definition S__readA : val :=
  rec: "S__readA" "s" <> :=
    exception_do (let: "s" := (ref_ty ptrT "s") in
    return: (![uint64T] (struct.field_ref S "a" (![ptrT] "s")))).

(* go: struct_pointers.go:26:13 *)
Definition S__readB : val :=
  rec: "S__readB" "s" <> :=
    exception_do (let: "s" := (ref_ty ptrT "s") in
    return: (![TwoInts] (struct.field_ref S "b" (![ptrT] "s")))).

(* go: struct_pointers.go:42:13 *)
Definition S__refC : val :=
  rec: "S__refC" "s" <> :=
    exception_do (let: "s" := (ref_ty ptrT "s") in
    return: (struct.field_ref S "c" (![ptrT] "s"))).

(* go: struct_pointers.go:34:13 *)
Definition S__writeB : val :=
  rec: "S__writeB" "s" "two" :=
    exception_do (let: "s" := (ref_ty ptrT "s") in
    let: "two" := (ref_ty TwoInts "two") in
    let: "$r0" := (![TwoInts] "two") in
    do:  ((struct.field_ref S "b" (![ptrT] "s")) <-[TwoInts] "$r0")).

Definition S__mset_ptr : list (string * val) := [
  ("negateC", S__negateC%V);
  ("readA", S__readA%V);
  ("readB", S__readB%V);
  ("readBVal", (λ: "$recvAddr",
    S__readBVal (![S] "$recvAddr")
    )%V);
  ("refC", S__refC%V);
  ("writeB", S__writeB%V)
].

(* go: struct_pointers.go:14:6 *)
Definition NewS : val :=
  rec: "NewS" <> :=
    exception_do (return: (ref_ty S (struct.make S [{
       "a" ::= #(W64 2);
       "b" ::= struct.make TwoInts [{
         "x" ::= #(W64 1);
         "y" ::= #(W64 2)
       }];
       "c" ::= #true
     }]))).

(* go: struct_pointers.go:46:6 *)
Definition localSRef : val :=
  rec: "localSRef" <> :=
    exception_do (let: "s" := (ref_ty S (zero_val S)) in
    return: (struct.field_ref S "b" "s")).

(* go: struct_pointers.go:54:6 *)
Definition setField : val :=
  rec: "setField" <> :=
    exception_do (let: "s" := (ref_ty S (zero_val S)) in
    let: "$r0" := #(W64 0) in
    do:  ((struct.field_ref S "a" "s") <-[uint64T] "$r0");;;
    let: "$r0" := #true in
    do:  ((struct.field_ref S "c" "s") <-[boolT] "$r0");;;
    return: (![S] "s")).

(* DoSomeLocking uses the entire lock API

   go: synchronization.go:6:6 *)
Definition DoSomeLocking : val :=
  rec: "DoSomeLocking" "l" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    do:  ((sync.Mutex__Lock (![ptrT] "l")) #());;;
    do:  ((sync.Mutex__Unlock (![ptrT] "l")) #())).

(* go: synchronization.go:15:6 *)
Definition makeLock : val :=
  rec: "makeLock" <> :=
    exception_do (let: "l" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty sync.Mutex (zero_val sync.Mutex)) in
    do:  ("l" <-[ptrT] "$r0");;;
    do:  (let: "$a0" := (![ptrT] "l") in
    DoSomeLocking "$a0")).

(* go: time.go:5:6 *)
Definition sleep : val :=
  rec: "sleep" <> :=
    exception_do (do:  (let: "$a0" := #(W64 1000) in
    primitive.Sleep "$a0")).

Definition A : go_type := structT [
].

Definition B : go_type := structT [
  "a" :: sliceT
].

Definition B__mset : list (string * val) := [
].

Definition B__mset_ptr : list (string * val) := [
].

Definition A__mset : list (string * val) := [
].

Definition A__mset_ptr : list (string * val) := [
].

(* go: trailing_call.go:3:6 *)
Definition mkInt : val :=
  rec: "mkInt" <> :=
    exception_do (return: (#(W64 42))).

(* go: trailing_call.go:7:6 *)
Definition mkNothing : val :=
  rec: "mkNothing" <> :=
    exception_do (do:  (mkInt #())).

Definition my_u64 : go_type := uint64T.

Definition Timestamp : go_type := uint64T.

Definition Timestamp__mset : list (string * val) := [
].

Definition Timestamp__mset_ptr : list (string * val) := [
].

Definition UseTypeAbbrev : go_type := uint64T.

Definition UseTypeAbbrev__mset : list (string * val) := [
].

Definition UseTypeAbbrev__mset_ptr : list (string * val) := [
].

Definition UseNamedType : go_type := Timestamp.

Definition UseNamedType__mset : list (string * val) := [
].

Definition UseNamedType__mset_ptr : list (string * val) := [
].

(* go: type_alias.go:11:6 *)
Definition convertToAlias : val :=
  rec: "convertToAlias" <> :=
    exception_do (let: "x" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := #(W64 2) in
    do:  ("x" <-[uint64T] "$r0");;;
    return: (![uint64T] "x")).

(* go: varargs.go:3:6 *)
Definition variadicFunc : val :=
  rec: "variadicFunc" "a" "b" "cs" :=
    exception_do (let: "cs" := (ref_ty sliceT "cs") in
    let: "b" := (ref_ty stringT "b") in
    let: "a" := (ref_ty uint64T "a") in
    do:  #()).

(* go: varargs.go:6:6 *)
Definition testVariadicCall : val :=
  rec: "testVariadicCall" <> :=
    exception_do (do:  (let: "$a0" := #(W64 10) in
    let: "$a1" := #"abc" in
    let: "$a2" := ((let: "$sl0" := #(W8 0) in
    let: "$sl1" := #(W8 1) in
    let: "$sl2" := #(W8 2) in
    let: "$sl3" := #(W8 3) in
    slice.literal byteT ["$sl0"; "$sl1"; "$sl2"; "$sl3"])) in
    variadicFunc "$a0" "$a1" "$a2");;;
    do:  (let: "$a0" := #(W64 10) in
    let: "$a1" := #"abc" in
    let: "$a2" := #slice.nil in
    variadicFunc "$a0" "$a1" "$a2");;;
    let: "c" := (ref_ty sliceT (zero_val sliceT)) in
    do:  (let: "$a0" := #(W64 10) in
    let: "$a1" := #"abc" in
    let: "$a2" := (![sliceT] "c") in
    variadicFunc "$a0" "$a1" "$a2")).

(* go: varargs.go:13:6 *)
Definition returnMultiple : val :=
  rec: "returnMultiple" <> :=
    exception_do (return: (#(W64 0), #"xyz", #(W8 0), #(W8 0))).

(* go: varargs.go:17:6 *)
Definition testVariadicPassThrough : val :=
  rec: "testVariadicPassThrough" <> :=
    exception_do (do:  (let: ((("$ret0", "$ret1"), "$ret2"), "$ret3") := ((returnMultiple #())) in
    let: "$a0" := "$ret0" in
    let: "$a1" := "$ret1" in
    let: "$a2" := ((let: "$sl0" := "$ret2" in
    let: "$sl1" := "$ret3" in
    slice.literal byteT ["$sl0"; "$sl1"])) in
    variadicFunc "$a0" "$a1" "$a2")).
