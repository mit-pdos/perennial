(* autogenerated from github.com/goose-lang/goose/testdata/examples/unittest *)
Require Export New.code.fmt.
Require Export New.code.github_com.goose_lang.primitive.
Require Export New.code.github_com.goose_lang.primitive.disk.
Require Export New.code.github_com.goose_lang.std.
Require Export New.code.log.
Require Export New.code.sync.

From New.golang Require Import defn.
Definition unittest : go_string := "github.com/goose-lang/goose/testdata/examples/unittest".

From New Require Import disk_prelude.
Module unittest.

<<<<<<< HEAD
=======
Module Foo. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.Foo"%go. End Foo.
Module importantStruct. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.importantStruct"%go. End importantStruct.
Module stringWrapper. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.stringWrapper"%go. End stringWrapper.
Module Uint32. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.Uint32"%go. End Uint32.
Module numWrapper. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.numWrapper"%go. End numWrapper.
Module diskWrapper. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.diskWrapper"%go. End diskWrapper.
Module embedA. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.embedA"%go. End embedA.
Module embedB. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.embedB"%go. End embedB.
Module embedC. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.embedC"%go. End embedC.
Module embedD. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.embedD"%go. End embedD.
Module Enc. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.Enc"%go. End Enc.
Module Dec. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.Dec"%go. End Dec.
Module Enum1. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.Enum1"%go. End Enum1.
Module Enum2. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.Enum2"%go. End Enum2.
Module Fooer. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.Fooer"%go. End Fooer.
Module concreteFooer. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.concreteFooer"%go. End concreteFooer.
Module FooerUser. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.FooerUser"%go. End FooerUser.
Module PointerInterface. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.PointerInterface"%go. End PointerInterface.
Module concrete1. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.concrete1"%go. End concrete1.
Module my_u32. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.my_u32"%go. End my_u32.
Module also_u32. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.also_u32"%go. End also_u32.
Module allTheLiterals. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.allTheLiterals"%go. End allTheLiterals.
Module hasCondVar. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.hasCondVar"%go. End hasCondVar.
Module IntWrapper. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.IntWrapper"%go. End IntWrapper.
Module MapWrapper. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.MapWrapper"%go. End MapWrapper.
Module mapElem. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.mapElem"%go. End mapElem.
Module containsPointer. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.containsPointer"%go. End containsPointer.
Module wrapExternalStruct. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.wrapExternalStruct"%go. End wrapExternalStruct.
Module typing. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.typing"%go. End typing.
Module composite. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.composite"%go. End composite.
Module R. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.R"%go. End R.
Module Other. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.Other"%go. End Other.
Module RecursiveEmbedded. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.RecursiveEmbedded"%go. End RecursiveEmbedded.
Module Block. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.Block"%go. End Block.
Module SliceAlias. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.SliceAlias"%go. End SliceAlias.
Module thing. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.thing"%go. End thing.
Module sliceOfThings. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.sliceOfThings"%go. End sliceOfThings.
Module Point. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.Point"%go. End Point.
Module TwoInts. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.TwoInts"%go. End TwoInts.
Module S. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.S"%go. End S.
Module B. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.B"%go. End B.
Module A. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.A"%go. End A.
Module my_u64. Definition id : go_string := uint64T.id. End my_u64.
Module Timestamp. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.Timestamp"%go. End Timestamp.
Module UseTypeAbbrev. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.UseTypeAbbrev"%go. End UseTypeAbbrev.
Module UseNamedType. Definition id : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.UseNamedType"%go. End UseNamedType.

>>>>>>> master
Section code.


Definition Fooⁱᵐᵖˡ  : go.type := go.ArrayType 10 go.uint64.

Definition takesArray : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.takesArray"%go.

(* go: array.go:5:6 *)
Definition takesArrayⁱᵐᵖˡ : val :=
  λ: "x",
    exception_do (let: "x" := (GoAllocValue (go.ArrayType 13 go.string) "x") in
    return: (![go.string] (array.elem_ref go.string (![go.ArrayType 13 go.string] "x") #(W64 3)))).

Definition takesPtr : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.takesPtr"%go.

(* go: array.go:9:6 *)
Definition takesPtrⁱᵐᵖˡ : val :=
  λ: "x",
    exception_do (let: "x" := (GoAllocValue (go.PointerType go.string) "x") in
    do:  ((![go.PointerType go.string] "x") <-[go.string] ((![go.string] (![go.PointerType go.string] "x")) + #"bar"%go));;;
    return: #()).

Definition usesArrayElemRef : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.usesArrayElemRef"%go.

(* go: array.go:13:6 *)
Definition usesArrayElemRefⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc (go.ArrayType 2 go.string) #()) in
    let: "$r0" := ((let: "$ar0" := #"a"%go in
    let: "$ar1" := #"b"%go in
    array.literal ["$ar0"; "$ar1"])) in
    do:  ("x" <-[go.ArrayType 2 go.string] "$r0");;;
    let: "$r0" := #"c"%go in
    do:  ((array.elem_ref go.string (![go.ArrayType 2 go.string] "x") #(W64 1)) <-[go.string] "$r0");;;
    do:  (let: "$a0" := (array.elem_ref go.string (![go.ArrayType 2 go.string] "x") #(W64 1)) in
    (FuncResolve takesPtr #()) "$a0");;;
    return: #()).

Definition sum : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.sum"%go.

(* go: array.go:22:6 *)
Definition sumⁱᵐᵖˡ : val :=
  λ: "x",
    exception_do (let: "x" := (GoAllocValue (go.ArrayType 100 go.uint64) "x") in
    let: "sum" := (GoAlloc go.uint64 #()) in
    let: "$r0" := #(W64 0) in
    do:  ("sum" <-[go.uint64] "$r0");;;
    (let: "i" := (GoAlloc go.uint64 #()) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, (![go.uint64] "i") < (s_to_w64 (array.len (go.ArrayType 100 go.uint64)))); (λ: <>, do:  ("i" <-[go.uint64] ((![go.uint64] "i") + #(W64 1)))) := λ: <>,
      do:  ("sum" <-[go.uint64] ((![go.uint64] "sum") + (![go.uint64] (array.elem_ref go.uint64 (![go.ArrayType 100 go.uint64] "x") (![go.uint64] "i")))))));;;
    do:  ("sum" <-[go.uint64] ((![go.uint64] "sum") + (s_to_w64 (array.cap (go.ArrayType 100 go.uint64)))));;;
    return: (![go.uint64] "sum")).

Definition arrayToSlice : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.arrayToSlice"%go.

(* go: array.go:31:6 *)
Definition arrayToSliceⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc (go.ArrayType 2 go.string) #()) in
    let: "$r0" := ((let: "$ar0" := #"a"%go in
    let: "$ar1" := #"b"%go in
    array.literal ["$ar0"; "$ar1"])) in
    do:  ("x" <-[go.ArrayType 2 go.string] "$r0");;;
    return: (let: "$a" := "x" in
     array.slice go.string "$a" #(W64 0) (array.len go.string))).

Definition arrayA : Z := 0.

Definition arrayB : Z := 10.

Definition arrayLiteralKeyed : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.arrayLiteralKeyed"%go.

(* go: array.go:44:6 *)
Definition arrayLiteralKeyedⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc (go.ArrayType 13 go.string) #()) in
    let: "$r0" := ((let: "$ar0" := #"A"%go in
    let: "$ar1" := #"3"%go in
    let: "$ar2" := (GoZeroVal go.string #()) in
    let: "$ar3" := (GoZeroVal go.string #()) in
    let: "$ar4" := (GoZeroVal go.string #()) in
    let: "$ar5" := (GoZeroVal go.string #()) in
    let: "$ar6" := (GoZeroVal go.string #()) in
    let: "$ar7" := (GoZeroVal go.string #()) in
    let: "$ar8" := (GoZeroVal go.string #()) in
    let: "$ar9" := (GoZeroVal go.string #()) in
    let: "$ar10" := #"B"%go in
    let: "$ar11" := #"1"%go in
    let: "$ar12" := #"2"%go in
    array.literal ["$ar0"; "$ar1"; "$ar2"; "$ar3"; "$ar4"; "$ar5"; "$ar6"; "$ar7"; "$ar8"; "$ar9"; "$ar10"; "$ar11"; "$ar12"])) in
    do:  ("x" <-[go.ArrayType 13 go.string] "$r0");;;
    return: (![go.string] (array.elem_ref go.string (![go.ArrayType 13 go.string] "x") #(W64 0)))).

Definition chanBasic : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.chanBasic"%go.

(* go: chan.go:5:6 *)
Definition chanBasicⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc (go.ChannelType go.sendrecv go.string) #()) in
    let: "$r0" := (chan.make go.string #(W64 10)) in
    do:  ("x" <-[go.ChannelType go.sendrecv go.string] "$r0");;;
    let: "$r0" := (chan.make go.string #(W64 0)) in
    do:  ("x" <-[go.ChannelType go.sendrecv go.string] "$r0");;;
    let: "$go" := (λ: <>,
      exception_do (do:  (let: "$chan" := (![go.ChannelType go.sendrecv go.string] "x") in
      let: "$v" := #"Foo"%go in
      chan.send go.string "$chan" "$v");;;
      do:  (let: "$chan" := (![go.ChannelType go.sendrecv go.string] "x") in
      let: "$v" := #"Foo"%go in
      chan.send go.string "$chan" "$v");;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    let: "ok" := (GoAlloc go.bool #()) in
    let: "y" := (GoAlloc go.string #()) in
    let: ("$ret0", "$ret1") := (chan.receive go.string (![go.ChannelType go.sendrecv go.string] "x")) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("y" <-[go.string] "$r0");;;
    do:  ("ok" <-[go.bool] "$r1");;;
    let: "$r0" := (Fst (chan.receive go.string (![go.ChannelType go.sendrecv go.string] "x"))) in
    do:  ("y" <-[go.string] "$r0");;;
    (if: ![go.bool] "ok"
    then
      let: "$r0" := ((![go.string] "y") + #" "%go) in
      do:  ("y" <-[go.string] "$r0")
    else do:  #());;;
    return: #()).

Definition f : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.f"%go.

(* go: chan.go:20:6 *)
Definition fⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (#(W64 0))).

Definition chanSelect : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.chanSelect"%go.

(* modified version of example from https://go.dev/ref/spec#Select_statements

   go: chan.go:25:6 *)
Definition chanSelectⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "a" := (GoAlloc (go.SliceType go.int) #()) in
    let: "c4" := (GoAlloc (go.ChannelType go.sendrecv go.int) #()) in
    let: "c3" := (GoAlloc (go.ChannelType go.sendrecv go.int) #()) in
    let: "c2" := (GoAlloc (go.ChannelType go.sendrecv go.int) #()) in
    let: "c1" := (GoAlloc (go.ChannelType go.sendrecv go.int) #()) in
    let: "c" := (GoAlloc (go.ChannelType go.sendrecv go.int) #()) in
    let: "i2" := (GoAlloc go.int #()) in
    let: "i1" := (GoAlloc go.int #()) in
    chan.select_nonblocking [chan.select_receive go.int (![go.ChannelType go.sendrecv go.int] "c3") (λ: "$recvVal",
       do:  #()
       ); chan.select_receive go.int (![go.ChannelType go.sendrecv go.int] "c1") (λ: "$recvVal",
       let: "$r0" := (Fst "$recvVal") in
       do:  ("i1" <-[go.int] "$r0");;;
       do:  (let: "$a0" := ((let: "$sl0" := (InterfaceMake go.string #"received "%go) in
       let: "$sl1" := (InterfaceMake go.int (![go.int] "i1")) in
       let: "$sl2" := (InterfaceMake go.string #" from c1
       "%go) in
       slice.literal (go.InterfaceType []) ["$sl0"; "$sl1"; "$sl2"])) in
       (FuncResolve fmt.Print #()) "$a0")
       ); chan.select_send go.int (![go.ChannelType go.sendrecv go.int] "c2") (![go.int] "i2") (λ: <>,
       do:  (let: "$a0" := ((let: "$sl0" := (InterfaceMake go.string #"sent "%go) in
       let: "$sl1" := (InterfaceMake go.int (![go.int] "i2")) in
       let: "$sl2" := (InterfaceMake go.string #" to c2
       "%go) in
       slice.literal (go.InterfaceType []) ["$sl0"; "$sl1"; "$sl2"])) in
       (FuncResolve fmt.Print #()) "$a0")
       ); chan.select_receive go.int (![go.ChannelType go.sendrecv go.int] "c3") (λ: "$recvVal",
       let: "ok" := (GoAlloc go.bool #()) in
       let: "i3" := (GoAlloc go.int #()) in
       let: ("$ret0", "$ret1") := "$recvVal" in
       let: "$r0" := "$ret0" in
       let: "$r1" := "$ret1" in
       do:  ("i3" <-[go.int] "$r0");;;
       do:  ("ok" <-[go.bool] "$r1");;;
       (if: ![go.bool] "ok"
       then
         do:  (let: "$a0" := ((let: "$sl0" := (InterfaceMake go.string #"received "%go) in
         let: "$sl1" := (InterfaceMake go.int (![go.int] "i3")) in
         let: "$sl2" := (InterfaceMake go.string #" from c3
         "%go) in
         slice.literal (go.InterfaceType []) ["$sl0"; "$sl1"; "$sl2"])) in
         (FuncResolve fmt.Print #()) "$a0")
       else
         do:  (let: "$a0" := ((let: "$sl0" := (InterfaceMake go.string #"c3 is closed
         "%go) in
         slice.literal (go.InterfaceType []) ["$sl0"])) in
         (FuncResolve fmt.Print #()) "$a0"))
       ); chan.select_receive go.int (![go.ChannelType go.sendrecv go.int] "c4") (λ: "$recvVal",
       let: "$r0" := (Fst "$recvVal") in
       do:  ((slice.elem_ref go.int (![go.SliceType go.int] "a") ((FuncResolve f #()) #())) <-[go.int] "$r0");;;
       do:  #()
       )] (λ: <>,
      do:  (let: "$a0" := ((let: "$sl0" := (InterfaceMake go.string #"no communication
      "%go) in
      slice.literal (go.InterfaceType []) ["$sl0"])) in
      (FuncResolve fmt.Print #()) "$a0")
      );;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      chan.select_blocking [chan.select_send go.int (![go.ChannelType go.sendrecv go.int] "c") #(W64 0) (λ: <>,
         do:  #()
         ); chan.select_send go.int (![go.ChannelType go.sendrecv go.int] "c") #(W64 1) (λ: <>,
         do:  #()
         )]);;;
    chan.select_blocking [];;;
    return: #()).

Definition chanDirectional : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.chanDirectional"%go.

(* go: chan.go:59:6 *)
Definition chanDirectionalⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc (go.ChannelType go.recvonly go.uint64) #()) in
    let: "y" := (GoAlloc (go.ChannelType go.sendonly go.string) #()) in
    do:  (Fst (chan.receive go.uint64 (![go.ChannelType go.recvonly go.uint64] "x")));;;
    do:  (let: "$chan" := (![go.ChannelType go.sendonly go.string] "y") in
    let: "$v" := #""%go in
    chan.send go.string "$chan" "$v");;;
    return: #()).

Definition chanRange : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.chanRange"%go.

(* go: chan.go:66:6 *)
Definition chanRangeⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc (go.ChannelType go.sendrecv go.uint64) #()) in
    let: "$range" := (![go.ChannelType go.sendrecv go.uint64] "x") in
    (let: "y" := (GoAlloc go.uint64 #()) in
    chan.for_range go.uint64 "$range" (λ: "$key",
      do:  ("y" <-[go.uint64] "$key");;;
      do:  (let: "$a0" := ((let: "$sl0" := (InterfaceMake go.uint64 (![go.uint64] "y")) in
      slice.literal (go.InterfaceType []) ["$sl0"])) in
      (FuncResolve fmt.Print #()) "$a0")));;;
    let: "$range" := (![go.ChannelType go.sendrecv go.uint64] "x") in
    (let: "x" := (GoAlloc go.uint64 #()) in
    chan.for_range go.uint64 "$range" (λ: "$key",
      do:  ("x" <-[go.uint64] "$key");;;
      do:  (let: "$a0" := ((let: "$sl0" := (InterfaceMake go.uint64 (![go.uint64] "x")) in
      slice.literal (go.InterfaceType []) ["$sl0"])) in
      (FuncResolve fmt.Print #()) "$a0")));;;
    let: "$range" := (![go.ChannelType go.sendrecv go.uint64] "x") in
    chan.for_range go.uint64 "$range" (λ: "$key",
      do:  #());;;
    return: #()).

Definition importantStructⁱᵐᵖˡ  : go.type := go.StructType [
].

Definition doSubtleThings : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.doSubtleThings"%go.

(* doSubtleThings does a number of subtle things:

   (actually, it does nothing)

   go: comments.go:12:6 *)
Definition doSubtleThingsⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (do:  #()).

Definition hasStartComment : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.hasStartComment"%go.

(* This comment starts a Coq comment ( *

   go: comments.go:15:6 *)
Definition hasStartCommentⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (do:  #()).

Definition hasEndComment : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.hasEndComment"%go.

(* This comment * ) ends a Coq comment

   go: comments.go:18:6 *)
Definition hasEndCommentⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (do:  #()).

Definition condvarWrapping : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.condvarWrapping"%go.

(* go: condvar.go:5:6 *)
Definition condvarWrappingⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "mu" := (GoAlloc (go.PointerType sync.Mutex) #()) in
    let: "$r0" := (GoAlloc sync.Mutex #()) in
    do:  ("mu" <-[go.PointerType sync.Mutex] "$r0");;;
    let: "cond1" := (GoAlloc (go.PointerType sync.Cond) #()) in
    let: "$r0" := (let: "$a0" := (InterfaceMake (go.PointerType sync.Mutex) (![go.PointerType sync.Mutex] "mu")) in
    (FuncResolve sync.NewCond #()) "$a0") in
    do:  ("cond1" <-[go.PointerType sync.Cond] "$r0");;;
    let: "$r0" := (GoAlloc sync.Mutex #()) in
    do:  ("mu" <-[go.PointerType sync.Mutex] "$r0");;;
    do:  ((MethodResolve (go.PointerType sync.Cond) Wait #() (![go.PointerType sync.Cond] "cond1")) #());;;
    return: #()).

Definition GlobalConstant : val := #"foo"%go.

(* an untyped string *)
Definition UntypedStringConstant : go_string := "bar"%go.

Definition UntypedInt : Z := 13.

Definition OtherUntypedInt : Z := 26.

Definition TypedInt : val := #(W64 32).

Definition ConstWithArith : val := #(W64 100).

Definition TypedInt32 : val := #(W32 3).

Definition DivisionInConst : val := #(W64 511).

(* 517 *)
Definition ModInConst : val := #(W64 517).

(* 5 *)
Definition ModInConstParens : val := #(W64 5).

Definition SignedIntegerExample : val := #(W64 (-37)).

Definition First : Z := 0.

Definition Second : Z := 1.

Definition Third : Z := 2.

Definition ComplicatedFirst : val := #(W64 3).

Definition ComplicatedSecond : val := #(W64 5).

Definition ComplicatedThird : val := #(W64 7).

Definition useUntypedInt : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.useUntypedInt"%go.

(* go: const.go:37:6 *)
Definition useUntypedIntⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (#(W64 UntypedInt) + TypedInt)).

Definition useUntypedString : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.useUntypedString"%go.

(* go: const.go:41:6 *)
Definition useUntypedStringⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (#UntypedStringConstant)).

Definition conditionalReturn : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.conditionalReturn"%go.

(* go: control_flow.go:3:6 *)
Definition conditionalReturnⁱᵐᵖˡ : val :=
  λ: "x",
    exception_do (let: "x" := (GoAllocValue go.bool "x") in
    (if: ![go.bool] "x"
    then return: (#(W64 0))
    else do:  #());;;
    return: (#(W64 1))).

Definition alwaysReturn : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.alwaysReturn"%go.

(* go: control_flow.go:10:6 *)
Definition alwaysReturnⁱᵐᵖˡ : val :=
  λ: "x",
    exception_do (let: "x" := (GoAllocValue go.bool "x") in
    (if: ![go.bool] "x"
    then return: (#(W64 0))
    else return: (#(W64 1)))).

Definition alwaysReturnInNestedBranches : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.alwaysReturnInNestedBranches"%go.

(* go: control_flow.go:18:6 *)
Definition alwaysReturnInNestedBranchesⁱᵐᵖˡ : val :=
  λ: "x",
    exception_do (let: "x" := (GoAllocValue go.bool "x") in
    (if: (~ (![go.bool] "x"))
    then
      (if: ![go.bool] "x"
      then return: (#(W64 0))
      else return: (#(W64 1)))
    else do:  #());;;
    let: "y" := (GoAlloc go.uint64 #()) in
    let: "$r0" := #(W64 14) in
    do:  ("y" <-[go.uint64] "$r0");;;
    return: (![go.uint64] "y")).

Definition earlyReturn : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.earlyReturn"%go.

(* go: control_flow.go:32:6 *)
Definition earlyReturnⁱᵐᵖˡ : val :=
  λ: "x",
    exception_do (let: "x" := (GoAllocValue go.bool "x") in
    (if: ![go.bool] "x"
    then return: (#())
    else do:  #());;;
    return: #()).

Definition conditionalAssign : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.conditionalAssign"%go.

(* go: control_flow.go:38:6 *)
Definition conditionalAssignⁱᵐᵖˡ : val :=
  λ: "x",
    exception_do (let: "x" := (GoAllocValue go.bool "x") in
    let: "y" := (GoAlloc go.uint64 #()) in
    (if: ![go.bool] "x"
    then
      let: "$r0" := #(W64 1) in
      do:  ("y" <-[go.uint64] "$r0")
    else
      let: "$r0" := #(W64 2) in
      do:  ("y" <-[go.uint64] "$r0"));;;
    do:  ("y" <-[go.uint64] ((![go.uint64] "y") + #(W64 1)));;;
    return: (![go.uint64] "y")).

Definition elseIf : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.elseIf"%go.

(* go: control_flow.go:49:6 *)
Definition elseIfⁱᵐᵖˡ : val :=
  λ: "x" "y",
    exception_do (let: "y" := (GoAllocValue go.bool "y") in
    let: "x" := (GoAllocValue go.bool "x") in
    (if: ![go.bool] "x"
    then return: (#(W64 0))
    else
      (if: ![go.bool] "y"
      then return: (#(W64 1))
      else return: (#(W64 2))))).

Definition ifStmtInitialization : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.ifStmtInitialization"%go.

(* go: control_flow.go:59:6 *)
Definition ifStmtInitializationⁱᵐᵖˡ : val :=
  λ: "x",
    exception_do (let: "x" := (GoAllocValue go.uint64 "x") in
    let: "f" := (GoAlloc (go.FunctionType (go.Signature [] #false [go.uint64])) #()) in
    let: "$r0" := (λ: <>,
      exception_do (return: (![go.uint64] "x"))
      ) in
    do:  ("f" <-[go.FunctionType (go.Signature [] #false [go.uint64])] "$r0");;;
    (do:  ((![go.FunctionType (go.Signature [] #false [go.uint64])] "f") #());;;
    (if: (![go.uint64] "x") = #(W64 2)
    then do:  #()
    else
      (let: "z" := (GoAlloc go.uint64 #()) in
      let: "$r0" := (![go.uint64] "x") in
      do:  ("z" <-[go.uint64] "$r0");;;
      (if: (![go.uint64] "z") = #(W64 1)
      then do:  #()
      else
        (let: "y" := (GoAlloc go.int #()) in
        let: "$r0" := #(W64 94) in
        do:  ("y" <-[go.int] "$r0");;;
        (if: (![go.int] "y") = #(W64 30)
        then do:  #()
        else
          (let: "$r0" := #(W64 10) in
          do:  ("z" <-[go.uint64] "$r0");;;
          (if: (![go.uint64] "x") = #(W64 30)
          then do:  #()
          else do:  #()))))))));;;
    (let: "y" := (GoAlloc go.uint64 #()) in
    let: "$r0" := #(W64 10) in
    do:  ("y" <-[go.uint64] "$r0");;;
    (if: (![go.uint64] "x") = #(W64 0)
    then return: (![go.uint64] "y")
    else return: ((![go.uint64] "y") - #(W64 1))))).

Definition stringWrapperⁱᵐᵖˡ  : go.type := go.string.

Definition typedLiteral : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.typedLiteral"%go.

(* go: conversions.go:5:6 *)
Definition typedLiteralⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (#(W64 3))).

Definition literalCast : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.literalCast"%go.

(* go: conversions.go:9:6 *)
Definition literalCastⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.uint64 #()) in
    let: "$r0" := #(W64 2) in
    do:  ("x" <-[go.uint64] "$r0");;;
    return: ((![go.uint64] "x") + #(W64 2))).

Definition castInt : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.castInt"%go.

(* go: conversions.go:15:6 *)
Definition castIntⁱᵐᵖˡ : val :=
  λ: "p",
    exception_do (let: "p" := (GoAllocValue (go.SliceType go.byte) "p") in
    return: (s_to_w64 (let: "$a0" := (![go.SliceType go.byte] "p") in
     slice.len "$a0"))).

Definition stringToByteSlice : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.stringToByteSlice"%go.

(* go: conversions.go:19:6 *)
Definition stringToByteSliceⁱᵐᵖˡ : val :=
  λ: "s",
    exception_do (let: "s" := (GoAllocValue go.string "s") in
    let: "p" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := (string.to_bytes (![go.string] "s")) in
    do:  ("p" <-[go.SliceType go.byte] "$r0");;;
    return: (![go.SliceType go.byte] "p")).

Definition byteSliceToString : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.byteSliceToString"%go.

(* go: conversions.go:25:6 *)
Definition byteSliceToStringⁱᵐᵖˡ : val :=
  λ: "p",
    exception_do (let: "p" := (GoAllocValue (go.SliceType go.byte) "p") in
    let: "s" := (GoAlloc go.string #()) in
    let: "$r0" := (string.from_bytes (![go.SliceType go.byte] "p")) in
    do:  ("s" <-[go.string] "$r0");;;
    return: (![go.string] "s")).

Definition stringToStringWrapper : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.stringToStringWrapper"%go.

(* go: conversions.go:31:6 *)
Definition stringToStringWrapperⁱᵐᵖˡ : val :=
  λ: "s",
    exception_do (let: "s" := (GoAllocValue go.string "s") in
    return: (![go.string] "s")).

Definition stringWrapperToString : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.stringWrapperToString"%go.

(* go: conversions.go:35:6 *)
Definition stringWrapperToStringⁱᵐᵖˡ : val :=
  λ: "s",
    exception_do (let: "s" := (GoAllocValue stringWrapper "s") in
    return: (![stringWrapper] "s")).

Definition Uint32ⁱᵐᵖˡ  : go.type := go.uint32.

Definition testU32NewtypeLen : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.testU32NewtypeLen"%go.

(* go: conversions.go:41:6 *)
Definition testU32NewtypeLenⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "s" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := (slice.make2 go.byte #(W64 20)) in
    do:  ("s" <-[go.SliceType go.byte] "$r0");;;
    return: ((s_to_w32 (let: "$a0" := (![go.SliceType go.byte] "s") in
     slice.len "$a0")) = #(W32 20))).

Definition numWrapper : go_type := intT.
#[global] Typeclasses Opaque numWrapper.
#[global] Opaque numWrapper.

(* go: conversions.go:48:22 *)
Definition numWrapper__incⁱᵐᵖˡ : val :=
  λ: "n" <>,
    exception_do (let: "n" := (mem.alloc "n") in
    do:  ((![#ptrT] "n") <-[#numWrapper] ((![#numWrapper] (![#ptrT] "n")) + #(W64 1)));;;
    return: #()).

Definition testNumWrapper : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.testNumWrapper"%go.

(* go: conversions.go:52:6 *)
Definition testNumWrapperⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "n" := (mem.alloc (type.zero_val #numWrapper)) in
    let: "$r0" := #(W64 0) in
    do:  ("n" <-[#numWrapper] "$r0");;;
    do:  ((method_call #(ptrT.id numWrapper.id) #"inc"%go "n") #());;;
    return: #()).

Definition testCopySimple : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.testCopySimple"%go.

(* go: copy.go:3:6 *)
Definition testCopySimpleⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := (slice.make2 go.byte #(W64 10)) in
    do:  ("x" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := #(W8 1) in
    do:  ((slice.elem_ref go.byte (![go.SliceType go.byte] "x") #(W64 3)) <-[go.byte] "$r0");;;
    let: "y" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := (slice.make2 go.byte #(W64 10)) in
    do:  ("y" <-[go.SliceType go.byte] "$r0");;;
    do:  (let: "$a0" := (![go.SliceType go.byte] "y") in
    let: "$a1" := (![go.SliceType go.byte] "x") in
    (slice.copy go.byte) "$a0" "$a1");;;
    return: ((![go.byte] (slice.elem_ref go.byte (![go.SliceType go.byte] "y") #(W64 3))) = #(W8 1))).

Definition testCopyDifferentLengths : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.testCopyDifferentLengths"%go.

(* go: copy.go:11:6 *)
Definition testCopyDifferentLengthsⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := (slice.make2 go.byte #(W64 15)) in
    do:  ("x" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := #(W8 1) in
    do:  ((slice.elem_ref go.byte (![go.SliceType go.byte] "x") #(W64 3)) <-[go.byte] "$r0");;;
    let: "$r0" := #(W8 2) in
    do:  ((slice.elem_ref go.byte (![go.SliceType go.byte] "x") #(W64 12)) <-[go.byte] "$r0");;;
    let: "y" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := (slice.make2 go.byte #(W64 10)) in
    do:  ("y" <-[go.SliceType go.byte] "$r0");;;
    let: "n" := (GoAlloc go.uint64 #()) in
    let: "$r0" := (s_to_w64 (let: "$a0" := (![go.SliceType go.byte] "y") in
    let: "$a1" := (![go.SliceType go.byte] "x") in
    (slice.copy go.byte) "$a0" "$a1")) in
    do:  ("n" <-[go.uint64] "$r0");;;
    return: (((![go.uint64] "n") = #(W64 10)) && ((![go.byte] (slice.elem_ref go.byte (![go.SliceType go.byte] "y") #(W64 3))) = #(W8 1)))).

Definition atomicCreateStub : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.atomicCreateStub"%go.

(* go: data_structures.go:7:6 *)
Definition atomicCreateStubⁱᵐᵖˡ : val :=
  λ: "dir" "fname" "data",
    exception_do (let: "data" := (GoAllocValue (go.SliceType go.byte) "data") in
    let: "fname" := (GoAllocValue go.string "fname") in
    let: "dir" := (GoAllocValue go.string "dir") in
    do:  #()).

Definition useSlice : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.useSlice"%go.

(* go: data_structures.go:9:6 *)
Definition useSliceⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "s" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := (slice.make2 go.byte #(W64 1)) in
    do:  ("s" <-[go.SliceType go.byte] "$r0");;;
    let: "s1" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "s") in
    let: "$a1" := (![go.SliceType go.byte] "s") in
    (slice.append go.byte) "$a0" "$a1") in
    do:  ("s1" <-[go.SliceType go.byte] "$r0");;;
    do:  (let: "$a0" := #"dir"%go in
    let: "$a1" := #"file"%go in
    let: "$a2" := (![go.SliceType go.byte] "s1") in
    (FuncResolve atomicCreateStub #()) "$a0" "$a1" "$a2");;;
    return: #()).

Definition useSliceIndexing : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.useSliceIndexing"%go.

(* go: data_structures.go:15:6 *)
Definition useSliceIndexingⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "s" := (GoAlloc (go.SliceType go.uint64) #()) in
    let: "$r0" := (slice.make2 go.uint64 #(W64 2)) in
    do:  ("s" <-[go.SliceType go.uint64] "$r0");;;
    let: "$r0" := #(W64 2) in
    do:  ((slice.elem_ref go.uint64 (![go.SliceType go.uint64] "s") #(W64 1)) <-[go.uint64] "$r0");;;
    let: "x" := (GoAlloc go.uint64 #()) in
    let: "$r0" := (![go.uint64] (slice.elem_ref go.uint64 (![go.SliceType go.uint64] "s") #(W64 0))) in
    do:  ("x" <-[go.uint64] "$r0");;;
    return: (![go.uint64] "x")).

Definition useMap : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.useMap"%go.

(* go: data_structures.go:22:6 *)
Definition useMapⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "m" := (GoAlloc (go.MapType go.uint64 (go.SliceType go.byte)) #()) in
    let: "$r0" := (map.make go.uint64 (go.SliceType go.byte)) in
    do:  ("m" <-[go.MapType go.uint64 (go.SliceType go.byte)] "$r0");;;
    let: "$r0" := #slice.nil in
    do:  (map.insert (![go.MapType go.uint64 (go.SliceType go.byte)] "m") #(W64 1) "$r0");;;
    let: "ok" := (GoAlloc go.bool #()) in
    let: "x" := (GoAlloc (go.SliceType go.byte) #()) in
    let: ("$ret0", "$ret1") := (map.get (![go.MapType go.uint64 (go.SliceType go.byte)] "m") #(W64 2)) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("x" <-[go.SliceType go.byte] "$r0");;;
    do:  ("ok" <-[go.bool] "$r1");;;
    (if: ![go.bool] "ok"
    then return: (#())
    else do:  #());;;
    let: "$r0" := (![go.SliceType go.byte] "x") in
    do:  (map.insert (![go.MapType go.uint64 (go.SliceType go.byte)] "m") #(W64 3) "$r0");;;
    return: #()).

Definition usePtr : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.usePtr"%go.

(* go: data_structures.go:32:6 *)
Definition usePtrⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "p" := (GoAlloc (go.PointerType go.uint64) #()) in
    let: "$r0" := (GoAlloc go.uint64 #()) in
    do:  ("p" <-[go.PointerType go.uint64] "$r0");;;
    let: "$r0" := #(W64 1) in
    do:  ((![go.PointerType go.uint64] "p") <-[go.uint64] "$r0");;;
    let: "x" := (GoAlloc go.uint64 #()) in
    let: "$r0" := (![go.uint64] (![go.PointerType go.uint64] "p")) in
    do:  ("x" <-[go.uint64] "$r0");;;
    let: "$r0" := (![go.uint64] "x") in
    do:  ((![go.PointerType go.uint64] "p") <-[go.uint64] "$r0");;;
    return: #()).

Definition iterMapKeysAndValues : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.iterMapKeysAndValues"%go.

(* go: data_structures.go:39:6 *)
Definition iterMapKeysAndValuesⁱᵐᵖˡ : val :=
  λ: "m",
    exception_do (let: "m" := (GoAllocValue (go.MapType go.uint64 go.uint64) "m") in
    let: "sumPtr" := (GoAlloc (go.PointerType go.uint64) #()) in
    let: "$r0" := (GoAlloc go.uint64 #()) in
    do:  ("sumPtr" <-[go.PointerType go.uint64] "$r0");;;
    let: "$range" := (![go.MapType go.uint64 go.uint64] "m") in
    (let: "v" := (GoAlloc go.uint64 #()) in
    let: "k" := (GoAlloc go.uint64 #()) in
    map.for_range "$range" (λ: "$key" "value",
      do:  ("v" <-[go.uint64] "$value");;;
      do:  ("k" <-[go.uint64] "$key");;;
      let: "sum" := (GoAlloc go.uint64 #()) in
      let: "$r0" := (![go.uint64] (![go.PointerType go.uint64] "sumPtr")) in
      do:  ("sum" <-[go.uint64] "$r0");;;
      let: "$r0" := (((![go.uint64] "sum") + (![go.uint64] "k")) + (![go.uint64] "v")) in
      do:  ((![go.PointerType go.uint64] "sumPtr") <-[go.uint64] "$r0")));;;
    let: "sum" := (GoAlloc go.uint64 #()) in
    let: "$r0" := (![go.uint64] (![go.PointerType go.uint64] "sumPtr")) in
    do:  ("sum" <-[go.uint64] "$r0");;;
    return: (![go.uint64] "sum")).

Definition iterMapKeys : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.iterMapKeys"%go.

(* go: data_structures.go:49:6 *)
Definition iterMapKeysⁱᵐᵖˡ : val :=
  λ: "m",
    exception_do (let: "m" := (GoAllocValue (go.MapType go.uint64 go.uint64) "m") in
    let: "keysSlice" := (GoAlloc (go.SliceType go.uint64) #()) in
    let: "$r0" := (slice.make2 go.uint64 #(W64 0)) in
    do:  ("keysSlice" <-[go.SliceType go.uint64] "$r0");;;
    let: "keysRef" := (GoAlloc (go.PointerType (go.SliceType go.uint64)) #()) in
    let: "$r0" := (GoAlloc (go.SliceType go.uint64) #()) in
    do:  ("keysRef" <-[go.PointerType (go.SliceType go.uint64)] "$r0");;;
    let: "$r0" := (![go.SliceType go.uint64] "keysSlice") in
    do:  ((![go.PointerType (go.SliceType go.uint64)] "keysRef") <-[go.SliceType go.uint64] "$r0");;;
    let: "$range" := (![go.MapType go.uint64 go.uint64] "m") in
    (let: "k" := (GoAlloc go.uint64 #()) in
    map.for_range "$range" (λ: "$key" "value",
      do:  ("k" <-[go.uint64] "$key");;;
      let: "keys" := (GoAlloc (go.SliceType go.uint64) #()) in
      let: "$r0" := (![go.SliceType go.uint64] (![go.PointerType (go.SliceType go.uint64)] "keysRef")) in
      do:  ("keys" <-[go.SliceType go.uint64] "$r0");;;
      let: "newKeys" := (GoAlloc (go.SliceType go.uint64) #()) in
      let: "$r0" := (let: "$a0" := (![go.SliceType go.uint64] "keys") in
      let: "$a1" := ((let: "$sl0" := (![go.uint64] "k") in
      slice.literal go.uint64 ["$sl0"])) in
      (slice.append go.uint64) "$a0" "$a1") in
      do:  ("newKeys" <-[go.SliceType go.uint64] "$r0");;;
      let: "$r0" := (![go.SliceType go.uint64] "newKeys") in
      do:  ((![go.PointerType (go.SliceType go.uint64)] "keysRef") <-[go.SliceType go.uint64] "$r0")));;;
    let: "keys" := (GoAlloc (go.SliceType go.uint64) #()) in
    let: "$r0" := (![go.SliceType go.uint64] (![go.PointerType (go.SliceType go.uint64)] "keysRef")) in
    do:  ("keys" <-[go.SliceType go.uint64] "$r0");;;
    return: (![go.SliceType go.uint64] "keys")).

Definition getRandom : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.getRandom"%go.

(* go: data_structures.go:62:6 *)
Definition getRandomⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "r" := (GoAlloc go.uint64 #()) in
    let: "$r0" := ((FuncResolve primitive.RandomUint64 #()) #()) in
    do:  ("r" <-[go.uint64] "$r0");;;
    return: (![go.uint64] "r")).

Definition diskWrapperⁱᵐᵖˡ  : go.type := go.StructType [
  (go.FieldDecl "d"%go disk.Disk)
].

Definition diskArgument : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.diskArgument"%go.

(* go: disk.go:9:6 *)
Definition diskArgumentⁱᵐᵖˡ : val :=
  λ: "d",
    exception_do (let: "d" := (GoAllocValue disk.Disk "d") in
    let: "b" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := (let: "$a0" := #(W64 0) in
    (interface.get #"Read"%go (![disk.Disk] "d")) "$a0") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    do:  (let: "$a0" := #(W64 1) in
    let: "$a1" := (![go.SliceType go.byte] "b") in
    (interface.get #"Write"%go (![disk.Disk] "d")) "$a0" "$a1");;;
    return: #()).

Definition embedAⁱᵐᵖˡ  : go.type := go.StructType [
  (go.FieldDecl "a"%go go.uint64)
].

Definition embedBⁱᵐᵖˡ  : go.type := go.StructType [
  (go.FieldDecl "embedA"%go embedA)
].

Definition embedCⁱᵐᵖˡ  : go.type := go.StructType [
  (go.FieldDecl "embedB"%go go.PointerType embedB)
].

Definition embedDⁱᵐᵖˡ  : go.type := go.StructType [
  (go.FieldDecl "embedC"%go embedC)
].

(* go: embedded.go:19:17 *)
Definition embedA__Fooⁱᵐᵖˡ : val :=
  λ: "a" <>,
    exception_do (let: "a" := (GoAllocValue embedA "a") in
    return: (#(W64 0))).

(* go: embedded.go:23:17 *)
Definition embedB__Fooⁱᵐᵖˡ : val :=
  λ: "a" <>,
    exception_do (let: "a" := (GoAllocValue embedB "a") in
    return: (#(W64 10))).

(* go: embedded.go:27:18 *)
Definition embedA__Barⁱᵐᵖˡ : val :=
  λ: "a" <>,
    exception_do (let: "a" := (GoAllocValue (go.PointerType embedA) "a") in
    return: (#(W64 13))).

(* go: embedded.go:31:18 *)
Definition embedB__Carⁱᵐᵖˡ : val :=
  λ: "a" <>,
    exception_do (let: "a" := (GoAllocValue (go.PointerType embedB) "a") in
    return: (#(W64 14))).

Definition returnEmbedVal : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.returnEmbedVal"%go.

(* go: embedded.go:35:6 *)
Definition returnEmbedValⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (struct.make embedB [{
       "embedA" ::= GoZeroVal embedA #()
     }])).

Definition returnEmbedValWithPointer : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.returnEmbedValWithPointer"%go.

(* go: embedded.go:39:6 *)
Definition returnEmbedValWithPointerⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (struct.make embedD [{
       "embedC" ::= GoZeroVal embedC #()
     }])).

Definition useEmbeddedField : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.useEmbeddedField"%go.

(* go: embedded.go:43:6 *)
Definition useEmbeddedFieldⁱᵐᵖˡ : val :=
  λ: "d",
    exception_do (let: "d" := (GoAllocValue embedD "d") in
    let: "x" := (GoAlloc go.uint64 #()) in
    let: "$r0" := (![go.uint64] (struct.field_ref embedA #"a"%go (struct.field_ref embedB #"embedA"%go (![go.PointerType embedB] (struct.field_ref embedC #"embedB"%go (struct.field_ref embedD #"embedC"%go "d")))))) in
    do:  ("x" <-[go.uint64] "$r0");;;
    let: "$r0" := (![go.uint64] (struct.field_ref embedA #"a"%go (struct.field_ref embedB #"embedA"%go (![go.PointerType embedB] (struct.field_ref embedC #"embedB"%go (struct.field_ref embedD #"embedC"%go "d")))))) in
    do:  ("x" <-[go.uint64] "$r0");;;
    let: "$r0" := #(W64 10) in
    do:  ((struct.field_ref embedA #"a"%go (struct.field_ref embedB #"embedA"%go (![go.PointerType embedB] (struct.field_ref embedC #"embedB"%go (struct.field_ref embedD #"embedC"%go "d"))))) <-[go.uint64] "$r0");;;
    let: "y" := (GoAlloc (go.PointerType embedD) #()) in
    let: "$r0" := (GoAllocValue embedD (struct.make embedD [{
      "embedC" ::= GoZeroVal embedC #()
    }])) in
    do:  ("y" <-[go.PointerType embedD] "$r0");;;
    let: "$r0" := #(W64 11) in
    do:  ((struct.field_ref embedA #"a"%go (struct.field_ref embedB #"embedA"%go (![go.PointerType embedB] (struct.field_ref embedC #"embedB"%go (struct.field_ref embedD #"embedC"%go (![go.PointerType embedD] "y")))))) <-[go.uint64] "$r0");;;
    return: (![go.uint64] "x")).

Definition useEmbeddedValField : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.useEmbeddedValField"%go.

(* go: embedded.go:54:6 *)
Definition useEmbeddedValFieldⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.uint64 #()) in
    let: "$r0" := (struct.field_get embedA "a" (struct.field_get embedB "embedA" ((FuncResolve returnEmbedVal #()) #()))) in
    do:  ("x" <-[go.uint64] "$r0");;;
    let: "$r0" := (![go.uint64] (struct.field_ref embedA #"a"%go (struct.field_ref embedB #"embedA"%go (struct.field_get embedC "embedB" (struct.field_get embedD "embedC" ((FuncResolve returnEmbedValWithPointer #()) #())))))) in
    do:  ("x" <-[go.uint64] "$r0");;;
    return: (![go.uint64] "x")).

Definition useEmbeddedMethod : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.useEmbeddedMethod"%go.

(* go: embedded.go:60:6 *)
Definition useEmbeddedMethodⁱᵐᵖˡ : val :=
  λ: "d",
    exception_do (let: "d" := (GoAllocValue embedD "d") in
    return: (((MethodResolve embedD Foo #() (![embedD] "d")) #()) = ((MethodResolve embedA Foo #() (![embedA] (struct.field_ref embedB #"embedA"%go (![go.PointerType embedB] (struct.field_ref embedC #"embedB"%go (struct.field_ref embedD #"embedC"%go "d")))))) #()))).

Definition useEmbeddedMethod2 : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.useEmbeddedMethod2"%go.

(* go: embedded.go:64:6 *)
Definition useEmbeddedMethod2ⁱᵐᵖˡ : val :=
  λ: "d",
    exception_do (let: "d" := (GoAllocValue embedD "d") in
    do:  ((MethodResolve embedD Car #() (![embedD] "d")) #());;;
    return: (((MethodResolve embedD Bar #() (![embedD] "d")) #()) = ((MethodResolve (go.PointerType embedB) Bar #() (![go.PointerType embedB] (struct.field_ref embedC #"embedB"%go (struct.field_ref embedD #"embedC"%go "d")))) #()))).

Definition empty : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.empty"%go.

(* go: empty_functions.go:3:6 *)
Definition emptyⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (do:  #()).

Definition emptyReturn : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.emptyReturn"%go.

(* go: empty_functions.go:5:6 *)
Definition emptyReturnⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (#());;;
    return: #()).

Definition unnamedParams : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.unnamedParams"%go.

(* go: empty_functions.go:9:6 *)
Definition unnamedParamsⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (do:  #()).

Definition anonymousParam : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.anonymousParam"%go.

(* go: empty_functions.go:11:6 *)
Definition anonymousParamⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (do:  #()).

Definition Encⁱᵐᵖˡ  : go.type := go.StructType [
  (go.FieldDecl "p"%go go.SliceType go.byte)
].

(* go: encoding.go:9:15 *)
Definition Enc__consumeⁱᵐᵖˡ : val :=
  λ: "e" "n",
    exception_do (let: "e" := (GoAllocValue (go.PointerType Enc) "e") in
    let: "n" := (GoAllocValue go.uint64 "n") in
    let: "b" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := (let: "$s" := (![go.SliceType go.byte] (struct.field_ref Enc #"p"%go (![go.PointerType Enc] "e"))) in
    slice.slice go.byte "$s" #(W64 0) (![go.uint64] "n")) in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$s" := (![go.SliceType go.byte] (struct.field_ref Enc #"p"%go (![go.PointerType Enc] "e"))) in
    slice.slice go.byte "$s" (![go.uint64] "n") (slice.len "$s")) in
    do:  ((struct.field_ref Enc #"p"%go (![go.PointerType Enc] "e")) <-[go.SliceType go.byte] "$r0");;;
    return: (![go.SliceType go.byte] "b")).

(* go: encoding.go:15:15 *)
Definition Enc__UInt64ⁱᵐᵖˡ : val :=
  λ: "e" "x",
    exception_do (let: "e" := (GoAllocValue (go.PointerType Enc) "e") in
    let: "x" := (GoAllocValue go.uint64 "x") in
    do:  (let: "$a0" := (let: "$a0" := #(W64 8) in
    (MethodResolve (go.PointerType Enc) consume #() (![go.PointerType Enc] "e")) "$a0") in
    let: "$a1" := (![go.uint64] "x") in
    (FuncResolve primitive.UInt64Put #()) "$a0" "$a1");;;
    return: #()).

(* go: encoding.go:19:15 *)
Definition Enc__UInt32ⁱᵐᵖˡ : val :=
  λ: "e" "x",
    exception_do (let: "e" := (GoAllocValue (go.PointerType Enc) "e") in
    let: "x" := (GoAllocValue go.uint32 "x") in
    do:  (let: "$a0" := (let: "$a0" := #(W64 4) in
    (MethodResolve (go.PointerType Enc) consume #() (![go.PointerType Enc] "e")) "$a0") in
    let: "$a1" := (![go.uint32] "x") in
    (FuncResolve primitive.UInt32Put #()) "$a0" "$a1");;;
    return: #()).

Definition Decⁱᵐᵖˡ  : go.type := go.StructType [
  (go.FieldDecl "p"%go go.SliceType go.byte)
].

(* go: encoding.go:27:15 *)
Definition Dec__consumeⁱᵐᵖˡ : val :=
  λ: "d" "n",
    exception_do (let: "d" := (GoAllocValue (go.PointerType Dec) "d") in
    let: "n" := (GoAllocValue go.uint64 "n") in
    let: "b" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := (let: "$s" := (![go.SliceType go.byte] (struct.field_ref Dec #"p"%go (![go.PointerType Dec] "d"))) in
    slice.slice go.byte "$s" #(W64 0) (![go.uint64] "n")) in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$s" := (![go.SliceType go.byte] (struct.field_ref Dec #"p"%go (![go.PointerType Dec] "d"))) in
    slice.slice go.byte "$s" (![go.uint64] "n") (slice.len "$s")) in
    do:  ((struct.field_ref Dec #"p"%go (![go.PointerType Dec] "d")) <-[go.SliceType go.byte] "$r0");;;
    return: (![go.SliceType go.byte] "b")).

(* go: encoding.go:33:15 *)
Definition Dec__UInt64ⁱᵐᵖˡ : val :=
  λ: "d" <>,
    exception_do (let: "d" := (GoAllocValue (go.PointerType Dec) "d") in
    return: (let: "$a0" := (let: "$a0" := #(W64 8) in
     (MethodResolve (go.PointerType Dec) consume #() (![go.PointerType Dec] "d")) "$a0") in
     (FuncResolve primitive.UInt64Get #()) "$a0")).

(* go: encoding.go:37:15 *)
Definition Dec__UInt32ⁱᵐᵖˡ : val :=
  λ: "d" <>,
    exception_do (let: "d" := (GoAllocValue (go.PointerType Dec) "d") in
    return: (let: "$a0" := (let: "$a0" := #(W64 4) in
     (MethodResolve (go.PointerType Dec) consume #() (![go.PointerType Dec] "d")) "$a0") in
     (FuncResolve primitive.UInt32Get #()) "$a0")).

Definition Enum1ⁱᵐᵖˡ  : go.type := go.uint64.

Definition Enum1A : val := #(W64 0).

Definition Enum1B : val := #(W64 1).

Definition Enum1C : val := #(W64 2).

Definition Enum2ⁱᵐᵖˡ  : go.type := go.int.

(* line comment 1 *)
Definition Enum2A : val := #(W64 1).

(* line comment 2 *)
Definition Enum2B : Z := 3.

Definition Enum2C : Z := 4.

(* line comment 3 *)
Definition Enum2D : val := #(W64 15).

Definition a : val := float_placeholder.

Definition b : val := float_placeholder.

Definition useFloat : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.useFloat"%go.

(* go: float.go:8:6 *)
Definition useFloatⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.float64 #()) in
    let: "$r0" := (make_nondet float64T a) in
    do:  ("x" <-[go.float64] "$r0");;;
    let: "$r0" := (make_nondet float64T (make_nondet float64T (![go.float64] "x", make_nondet float64T a), make_nondet float64T float_placeholder)) in
    do:  ("x" <-[go.float64] "$r0");;;
    return: (![go.float64] "x")).

Definition compareIntFloat : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.compareIntFloat"%go.

(* go: float.go:14:6 *)
Definition compareIntFloatⁱᵐᵖˡ : val :=
  λ: "x",
    exception_do (let: "x" := (GoAllocValue go.int "x") in
    return: (int_lt (![go.int] "x") #(W64 1000000))).

Definition compareFloatInt : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.compareFloatInt"%go.

(* go: float.go:18:6 *)
Definition compareFloatIntⁱᵐᵖˡ : val :=
  λ: "x",
    exception_do (let: "x" := (GoAllocValue go.int "x") in
    return: (int_lt #(W64 1000000) (![go.int] "x"))).

Definition forRangeNoBinding : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.forRangeNoBinding"%go.

(* go: for_range.go:5:6 *)
Definition forRangeNoBindingⁱᵐᵖˡ : val :=
  λ: "x",
    exception_do (let: "x" := (GoAllocValue (go.SliceType go.string) "x") in
    let: "$range" := (![go.SliceType go.string] "x") in
    slice.for_range go.string "$range" (λ: "$key" "$value",
      do:  (let: "$a0" := ((let: "$sl0" := (InterfaceMake (go.SliceType go.string) (![go.SliceType go.string] "x")) in
      slice.literal (go.InterfaceType []) ["$sl0"])) in
      (FuncResolve fmt.Print #()) "$a0"));;;
    return: #()).

Definition forRangeOldVars : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.forRangeOldVars"%go.

(* go: for_range.go:11:6 *)
Definition forRangeOldVarsⁱᵐᵖˡ : val :=
  λ: "x",
    exception_do (let: "x" := (GoAllocValue (go.SliceType go.string) "x") in
    let: "y" := (GoAlloc go.string #()) in
    let: "$r0" := #"ok"%go in
    do:  ("y" <-[go.string] "$r0");;;
    let: "$range" := (![go.SliceType go.string] "x") in
    slice.for_range go.string "$range" (λ: "$key" "$value",
      do:  ("y" <-[go.string] "$value");;;
      do:  "$key";;;
      do:  (let: "$a0" := ((let: "$sl0" := (InterfaceMake go.string (![go.string] "y")) in
      slice.literal (go.InterfaceType []) ["$sl0"])) in
      (FuncResolve fmt.Print #()) "$a0"));;;
    return: #()).

Definition foo : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.foo"%go.

(* go: globals.go:3:6 *)
Definition fooⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (#(W64 10))).

Definition GlobalX : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.GlobalX"%go.

Definition globalY : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.globalY"%go.

Definition globalA : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.globalA"%go.

Definition globalB : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.globalB"%go.

Definition MaxRune : Z := 1114111.

Definition runeWithType : val := #(W32 97).

Definition IntWidth : Z := 8.

Definition other : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.other"%go.

(* go: globals.go:18:6 *)
Definition otherⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "$r0" := #"ok"%go in
    do:  ((globals.get #globalY) <-[go.string] "$r0");;;
    return: #()).

Definition bar : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.bar"%go.

(* go: globals.go:22:6 *)
Definition barⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (do:  ((FuncResolve other #()) #());;;
    (if: ((![go.uint64] (globals.get #GlobalX)) ≠ #(W64 10)) || ((![go.string] (globals.get #globalY)) ≠ #"ok"%go)
    then
      do:  (let: "$a0" := (InterfaceMake go.string #"bad"%go) in
      Panic "$a0")
    else do:  #());;;
    return: #()).

Definition useUntypedRune : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.useUntypedRune"%go.

(* go: globals.go:37:6 *)
Definition useUntypedRuneⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do ((if: int_gt runeWithType #(W32 MaxRune)
    then
      do:  (let: "$a0" := (interface.make #stringT.id #"invalid comparison"%go) in
      Panic "$a0")
    else do:  #());;;
    return: #()).

Definition TakesFunctionType : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.TakesFunctionType"%go.

(* go: higher_order.go:3:6 *)
Definition TakesFunctionTypeⁱᵐᵖˡ : val :=
  λ: "f",
    exception_do (let: "f" := (GoAllocValue (go.FunctionType (go.Signature [] #false [])) "f") in
    do:  ((![go.FunctionType (go.Signature [] #false [])] "f") #());;;
    return: #()).

Definition FuncVar : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.FuncVar"%go.

(* go: higher_order.go:7:6 *)
Definition FuncVarⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "f" := (GoAlloc (go.FunctionType (go.Signature [] #false [])) #()) in
    let: "$r0" := (![go.FunctionType (go.Signature [] #false [])] "f") in
    do:  "$r0";;;
    return: #()).

Definition Fooerⁱᵐᵖˡ  : go.type := go.InterfaceType [go.MethodElem #"Foo"%go (go.Signature [] #false [])].

Definition concreteFooerⁱᵐᵖˡ  : go.type := go.StructType [
  (go.FieldDecl "a"%go go.uint64)
].

Definition FooerUserⁱᵐᵖˡ  : go.type := go.StructType [
  (go.FieldDecl "f"%go Fooer)
].

(* go: interfaces.go:15:25 *)
Definition concreteFooer__Fooⁱᵐᵖˡ : val :=
  λ: "f" <>,
    exception_do (let: "f" := (GoAllocValue (go.PointerType concreteFooer) "f") in
    do:  #()).

Definition fooConsumer : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.fooConsumer"%go.

(* go: interfaces.go:18:6 *)
Definition fooConsumerⁱᵐᵖˡ : val :=
  λ: "f",
    exception_do (let: "f" := (GoAllocValue Fooer "f") in
    do:  ((interface.get #"Foo"%go (![Fooer] "f")) #());;;
    return: #()).

Definition testAssignConcreteToInterface : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.testAssignConcreteToInterface"%go.

(* go: interfaces.go:22:6 *)
Definition testAssignConcreteToInterfaceⁱᵐᵖˡ : val :=
  λ: "x",
    exception_do (let: "x" := (GoAllocValue (go.PointerType Fooer) "x") in
    let: "c" := (GoAlloc (go.PointerType concreteFooer) #()) in
    let: "$r0" := (GoAllocValue concreteFooer (struct.make concreteFooer [{
      "a" ::= GoZeroVal go.uint64 #()
    }])) in
    do:  ("c" <-[go.PointerType concreteFooer] "$r0");;;
    let: "$r0" := (InterfaceMake (go.PointerType concreteFooer) (![go.PointerType concreteFooer] "c")) in
    do:  ((![go.PointerType Fooer] "x") <-[Fooer] "$r0");;;
    return: #()).

Definition testPassConcreteToInterfaceArg : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.testPassConcreteToInterfaceArg"%go.

(* go: interfaces.go:27:6 *)
Definition testPassConcreteToInterfaceArgⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "c" := (GoAlloc (go.PointerType concreteFooer) #()) in
    let: "$r0" := (GoAllocValue concreteFooer (struct.make concreteFooer [{
      "a" ::= GoZeroVal go.uint64 #()
    }])) in
    do:  ("c" <-[go.PointerType concreteFooer] "$r0");;;
    do:  (let: "$a0" := (InterfaceMake (go.PointerType concreteFooer) (![go.PointerType concreteFooer] "c")) in
    (FuncResolve fooConsumer #()) "$a0");;;
    let: "f" := (GoAlloc Fooer #()) in
    let: "$r0" := (InterfaceMake (go.PointerType concreteFooer) (![go.PointerType concreteFooer] "c")) in
    do:  ("f" <-[Fooer] "$r0");;;
    do:  (let: "$a0" := (![Fooer] "f") in
    (FuncResolve fooConsumer #()) "$a0");;;
    do:  ((MethodResolve (go.PointerType concreteFooer) Foo #() (![go.PointerType concreteFooer] "c")) #());;;
    do:  ((interface.get #"Foo"%go (![Fooer] "f")) #());;;
    return: #()).

Definition testPassConcreteToInterfaceArgSpecial : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.testPassConcreteToInterfaceArgSpecial"%go.

(* go: interfaces.go:37:6 *)
Definition testPassConcreteToInterfaceArgSpecialⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "c1" := (GoAlloc (go.PointerType concreteFooer) #()) in
    let: "$r0" := (GoAllocValue concreteFooer (struct.make concreteFooer [{
      "a" ::= GoZeroVal go.uint64 #()
    }])) in
    do:  ("c1" <-[go.PointerType concreteFooer] "$r0");;;
    let: "c2" := (GoAlloc (go.PointerType concreteFooer) #()) in
    let: "$r0" := (GoAllocValue concreteFooer (struct.make concreteFooer [{
      "a" ::= GoZeroVal go.uint64 #()
    }])) in
    do:  ("c2" <-[go.PointerType concreteFooer] "$r0");;;
    let: "l" := (GoAlloc (go.SliceType Fooer) #()) in
    let: "$r0" := ((let: "$sl0" := (InterfaceMake (go.PointerType concreteFooer) (![go.PointerType concreteFooer] "c1")) in
    let: "$sl1" := (InterfaceMake (go.PointerType concreteFooer) (![go.PointerType concreteFooer] "c2")) in
    slice.literal Fooer ["$sl0"; "$sl1"])) in
    do:  ("l" <-[go.SliceType Fooer] "$r0");;;
    let: "m" := (GoAlloc (go.MapType go.uint64 Fooer) #()) in
    let: "$r0" := (map.make go.uint64 Fooer) in
    do:  ("m" <-[go.MapType go.uint64 Fooer] "$r0");;;
    let: "$r0" := (InterfaceMake (go.PointerType concreteFooer) (![go.PointerType concreteFooer] "c1")) in
    do:  (map.insert (![go.MapType go.uint64 Fooer] "m") #(W64 10) "$r0");;;
    let: "f" := (GoAlloc FooerUser #()) in
    let: "$r0" := (struct.make FooerUser [{
      "f" ::= InterfaceMake (go.PointerType concreteFooer) (![go.PointerType concreteFooer] "c1")
    }]) in
    do:  ("f" <-[FooerUser] "$r0");;;
    return: (![go.SliceType Fooer] "l", ![go.MapType go.uint64 Fooer] "m", ![FooerUser] "f")).

Definition takesVarArgsInterface : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.takesVarArgsInterface"%go.

(* go: interfaces.go:51:6 *)
Definition takesVarArgsInterfaceⁱᵐᵖˡ : val :=
  λ: "fs",
    exception_do (let: "fs" := (GoAllocValue (go.SliceType Fooer) "fs") in
    do:  ((interface.get #"Foo"%go (![Fooer] (slice.elem_ref Fooer (![go.SliceType Fooer] "fs") #(W64 0)))) #());;;
    return: #()).

Definition test : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.test"%go.

(* go: interfaces.go:55:6 *)
Definition testⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (do:  (let: "$a0" := ((let: "$sl0" := (InterfaceMake (go.PointerType concreteFooer) (GoAllocValue concreteFooer (struct.make concreteFooer [{
      "a" ::= GoZeroVal go.uint64 #()
    }]))) in
    let: "$sl1" := (InterfaceMake (go.PointerType concreteFooer) (GoAllocValue concreteFooer (struct.make concreteFooer [{
      "a" ::= GoZeroVal go.uint64 #()
    }]))) in
    slice.literal Fooer ["$sl0"; "$sl1"])) in
    (FuncResolve takesVarArgsInterface #()) "$a0");;;
    return: #()).

Definition returnConcrete : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.returnConcrete"%go.

(* go: interfaces.go:59:6 *)
Definition returnConcreteⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (GoAllocValue concreteFooer (struct.make concreteFooer [{
       "a" ::= GoZeroVal go.uint64 #()
     }]), #(W64 10))).

Definition testMultiReturn : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.testMultiReturn"%go.

(* converts an object into an interface in a multiple return destructuring statement.

   go: interfaces.go:64:6 *)
Definition testMultiReturnⁱᵐᵖˡ : val :=
  λ: "x",
    exception_do (let: "x" := (GoAllocValue (go.PointerType Fooer) "x") in
    let: "y" := (GoAlloc go.uint64 #()) in
    let: ("$ret0", "$ret1") := ((FuncResolve returnConcrete #()) #()) in
    let: "$r0" := (InterfaceMake (go.PointerType concreteFooer) "$ret0") in
    let: "$r1" := "$ret1" in
    do:  ((![go.PointerType Fooer] "x") <-[Fooer] "$r0");;;
    do:  ("y" <-[go.uint64] "$r1");;;
    return: (![go.uint64] "y")).

Definition testReturnStatment : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.testReturnStatment"%go.

(* go: interfaces.go:70:6 *)
Definition testReturnStatmentⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "y" := (GoAlloc (go.PointerType concreteFooer) #()) in
    let: "$r0" := (GoAllocValue concreteFooer (struct.make concreteFooer [{
      "a" ::= GoZeroVal go.uint64 #()
    }])) in
    do:  ("y" <-[go.PointerType concreteFooer] "$r0");;;
    return: (InterfaceMake (go.PointerType concreteFooer) (![go.PointerType concreteFooer] "y"))).

Definition testConversionInEq : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.testConversionInEq"%go.

(* go: interfaces.go:75:6 *)
Definition testConversionInEqⁱᵐᵖˡ : val :=
  λ: "f",
    exception_do (let: "f" := (GoAllocValue Fooer "f") in
    let: "c" := (GoAlloc (go.PointerType concreteFooer) #()) in
    let: "$r0" := (GoAllocValue concreteFooer (struct.make concreteFooer [{
      "a" ::= GoZeroVal go.uint64 #()
    }])) in
    do:  ("c" <-[go.PointerType concreteFooer] "$r0");;;
    let: "$r0" := (InterfaceMake (go.PointerType concreteFooer) (![go.PointerType concreteFooer] "c")) in
    do:  ("f" <-[Fooer] "$r0");;;
    return: (interface.eq (InterfaceMake (go.PointerType concreteFooer) (![go.PointerType concreteFooer] "c")) (![Fooer] "f"))).

Definition takeMultiple : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.takeMultiple"%go.

(* go: interfaces.go:82:6 *)
Definition takeMultipleⁱᵐᵖˡ : val :=
  λ: "a" "f",
    exception_do (let: "f" := (GoAllocValue (go.SliceType Fooer) "f") in
    let: "a" := (GoAllocValue go.uint64 "a") in
    do:  #()).

Definition giveMultiple : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.giveMultiple"%go.

(* go: interfaces.go:85:6 *)
Definition giveMultipleⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (#(W64 0), InterfaceMake (go.PointerType concreteFooer) (GoAllocValue concreteFooer (struct.make concreteFooer [{
       "a" ::= GoZeroVal go.uint64 #()
     }])), GoAllocValue concreteFooer (struct.make concreteFooer [{
       "a" ::= GoZeroVal go.uint64 #()
     }]))).

Definition testConversionInMultipleReturnPassThrough : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.testConversionInMultipleReturnPassThrough"%go.

(* go: interfaces.go:89:6 *)
Definition testConversionInMultipleReturnPassThroughⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: (("$ret0", "$ret1"), "$ret2") := (((FuncResolve giveMultiple #()) #())) in
    return: ("$ret0", "$ret1", InterfaceMake (go.PointerType concreteFooer) "$ret2")).

Definition testConversionInMultiplePassThrough : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.testConversionInMultiplePassThrough"%go.

(* See "special case" in https://go.dev/ref/spec#Calls

   go: interfaces.go:94:6 *)
Definition testConversionInMultiplePassThroughⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (do:  (let: (("$ret0", "$ret1"), "$ret2") := (((FuncResolve giveMultiple #()) #())) in
    let: "$a0" := "$ret0" in
    let: "$a1" := ((let: "$sl0" := "$ret1" in
    let: "$sl1" := (InterfaceMake (go.PointerType concreteFooer) "$ret2") in
    slice.literal Fooer ["$sl0"; "$sl1"])) in
    (FuncResolve takeMultiple #()) "$a0" "$a1");;;
    return: #()).

Definition PointerInterfaceⁱᵐᵖˡ  : go.type := go.InterfaceType [go.MethodElem #"B"%go (go.Signature [] #false []); go.MethodElem #"Foo"%go (go.Signature [] #false [])].

Definition concrete1ⁱᵐᵖˡ  : go.type := go.StructType [
].

(* go: interfaces.go:106:20 *)
Definition concrete1__Fooⁱᵐᵖˡ : val :=
  λ: "c" <>,
    exception_do (let: "c" := (GoAllocValue concrete1 "c") in
    do:  #()).

(* go: interfaces.go:109:21 *)
Definition concrete1__Bⁱᵐᵖˡ : val :=
  λ: "c" <>,
    exception_do (let: "c" := (GoAllocValue (go.PointerType concrete1) "c") in
    do:  #()).

Definition testPtrMset : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.testPtrMset"%go.

(* go: interfaces.go:112:6 *)
Definition testPtrMsetⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "a" := (GoAlloc (go.PointerType concrete1) #()) in
    let: "$r0" := (GoAllocValue concrete1 (struct.make concrete1 [{
    }])) in
    do:  ("a" <-[go.PointerType concrete1] "$r0");;;
    let: "p" := (GoAlloc PointerInterface #()) in
    let: "$r0" := (InterfaceMake (go.PointerType concrete1) (![go.PointerType concrete1] "a")) in
    do:  ("p" <-[PointerInterface] "$r0");;;
    let: "f" := (GoAlloc Fooer #()) in
    let: "$r0" := (InterfaceMake concrete1 (![concrete1] (![go.PointerType concrete1] "a"))) in
    do:  ("f" <-[Fooer] "$r0");;;
    do:  ((interface.get #"B"%go (![PointerInterface] "p")) #());;;
    do:  ((interface.get #"Foo"%go (![Fooer] "f")) #());;;
    return: #()).

Definition pointerAny : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.pointerAny"%go.

(* go: interfaces.go:120:6 *)
Definition pointerAnyⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (mem.alloc (type.zero_val #interfaceT))).

Definition useInts : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.useInts"%go.

(* go: ints.go:3:6 *)
Definition useIntsⁱᵐᵖˡ : val :=
  λ: "x" "y",
    exception_do (let: "y" := (GoAllocValue go.uint32 "y") in
    let: "x" := (GoAllocValue go.uint64 "x") in
    let: "z" := (GoAlloc go.uint64 #()) in
    let: "$r0" := (u_to_w64 (![go.uint32] "y")) in
    do:  ("z" <-[go.uint64] "$r0");;;
    let: "$r0" := ((![go.uint64] "z") + #(W64 1)) in
    do:  ("z" <-[go.uint64] "$r0");;;
    let: "y2" := (GoAlloc go.uint32 #()) in
    let: "$r0" := ((![go.uint32] "y") + #(W32 3)) in
    do:  ("y2" <-[go.uint32] "$r0");;;
    return: (![go.uint64] "z", ![go.uint32] "y2")).

Definition signedMidpoint : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.signedMidpoint"%go.

(* go: ints.go:12:6 *)
Definition signedMidpointⁱᵐᵖˡ : val :=
  λ: "x" "y",
    exception_do (let: "y" := (GoAllocValue go.int "y") in
    let: "x" := (GoAllocValue go.int "x") in
    return: (((![go.int] "x") + (![go.int] "y")) `quots` #(W64 2))).

Definition my_u32ⁱᵐᵖˡ  : go.type := go.uint32.

Definition also_u32ⁱᵐᵖˡ  : go.type := my_u32.

Definition ConstWithAbbrevType : val := #(W32 3).

Definition allTheLiteralsⁱᵐᵖˡ  : go.type := go.StructType [
  (go.FieldDecl "int"%go go.uint64);
  (go.FieldDecl "s"%go go.string);
  (go.FieldDecl "b"%go go.bool)
].

Definition normalLiterals : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.normalLiterals"%go.

(* go: literals.go:9:6 *)
Definition normalLiteralsⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (let: "$int" := #(W64 0) in
     let: "$s" := #"foo"%go in
     let: "$b" := #true in
     struct.make allTheLiterals [{
       "int" ::= "$int";
       "s" ::= "$s";
       "b" ::= "$b"
     }])).

Definition outOfOrderLiteral : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.outOfOrderLiteral"%go.

(* go: literals.go:17:6 *)
Definition outOfOrderLiteralⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (let: "$b" := #true in
     let: "$s" := #"foo"%go in
     let: "$int" := #(W64 0) in
     struct.make allTheLiterals [{
       "int" ::= "$int";
       "s" ::= "$s";
       "b" ::= "$b"
     }])).

Definition specialLiterals : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.specialLiterals"%go.

(* go: literals.go:25:6 *)
Definition specialLiteralsⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (let: "$int" := #(W64 4096) in
     let: "$s" := #""%go in
     let: "$b" := #false in
     struct.make allTheLiterals [{
       "int" ::= "$int";
       "s" ::= "$s";
       "b" ::= "$b"
     }])).

Definition oddLiterals : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.oddLiterals"%go.

(* go: literals.go:33:6 *)
Definition oddLiteralsⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (let: "$int" := #(W64 5) in
     let: "$s" := #"backquote string"%go in
     let: "$b" := #false in
     struct.make allTheLiterals [{
       "int" ::= "$int";
       "s" ::= "$s";
       "b" ::= "$b"
     }])).

Definition unKeyedLiteral : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.unKeyedLiteral"%go.

(* go: literals.go:41:6 *)
Definition unKeyedLiteralⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (struct.make allTheLiterals [{
       "int" ::= #(W64 0);
       "s" ::= #"a"%go;
       "b" ::= #false
     }])).

Definition useLocks : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.useLocks"%go.

(* go: locks.go:5:6 *)
Definition useLocksⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "m" := (GoAlloc (go.PointerType sync.Mutex) #()) in
    let: "$r0" := (GoAlloc sync.Mutex #()) in
    do:  ("m" <-[go.PointerType sync.Mutex] "$r0");;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) Lock #() (![go.PointerType sync.Mutex] "m")) #());;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) Unlock #() (![go.PointerType sync.Mutex] "m")) #());;;
    return: #()).

Definition useCondVar : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.useCondVar"%go.

(* go: locks.go:11:6 *)
Definition useCondVarⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "m" := (GoAlloc (go.PointerType sync.Mutex) #()) in
    let: "$r0" := (GoAlloc sync.Mutex #()) in
    do:  ("m" <-[go.PointerType sync.Mutex] "$r0");;;
    let: "c" := (GoAlloc (go.PointerType sync.Cond) #()) in
    let: "$r0" := (let: "$a0" := (InterfaceMake (go.PointerType sync.Mutex) (![go.PointerType sync.Mutex] "m")) in
    (FuncResolve sync.NewCond #()) "$a0") in
    do:  ("c" <-[go.PointerType sync.Cond] "$r0");;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) Lock #() (![go.PointerType sync.Mutex] "m")) #());;;
    do:  ((MethodResolve (go.PointerType sync.Cond) Signal #() (![go.PointerType sync.Cond] "c")) #());;;
    do:  ((MethodResolve (go.PointerType sync.Cond) Wait #() (![go.PointerType sync.Cond] "c")) #());;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) Unlock #() (![go.PointerType sync.Mutex] "m")) #());;;
    return: #()).

Definition hasCondVarⁱᵐᵖˡ  : go.type := go.StructType [
  (go.FieldDecl "cond"%go go.PointerType sync.Cond)
].

Definition ToBeDebugged : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.ToBeDebugged"%go.

(* go: log_debugging.go:5:6 *)
Definition ToBeDebuggedⁱᵐᵖˡ : val :=
  λ: "x",
    exception_do (let: "x" := (GoAllocValue go.uint64 "x") in
    do:  (let: "$a0" := ((let: "$sl0" := (InterfaceMake go.string #"starting function"%go) in
    slice.literal (go.InterfaceType []) ["$sl0"])) in
    (FuncResolve log.Println #()) "$a0");;;
    do:  (let: "$a0" := #"called with %d"%go in
    let: "$a1" := ((let: "$sl0" := (InterfaceMake go.uint64 (![go.uint64] "x")) in
    slice.literal (go.InterfaceType []) ["$sl0"])) in
    (FuncResolve log.Printf #()) "$a0" "$a1");;;
    do:  (let: "$a0" := ((let: "$sl0" := (InterfaceMake go.string #"ending function"%go) in
    slice.literal (go.InterfaceType []) ["$sl0"])) in
    (FuncResolve log.Println #()) "$a0");;;
    return: (![go.uint64] "x")).

Definition DoNothing : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.DoNothing"%go.

(* go: log_debugging.go:12:6 *)
Definition DoNothingⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (do:  (let: "$a0" := ((let: "$sl0" := (InterfaceMake go.string #"doing nothing"%go) in
    slice.literal (go.InterfaceType []) ["$sl0"])) in
    (FuncResolve log.Println #()) "$a0");;;
    return: #()).

Definition DoSomething : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.DoSomething"%go.

(* DoSomething is an impure function

   go: loops.go:4:6 *)
Definition DoSomethingⁱᵐᵖˡ : val :=
  λ: "s",
    exception_do (let: "s" := (GoAllocValue go.string "s") in
    do:  #()).

Definition standardForLoop : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.standardForLoop"%go.

(* go: loops.go:6:6 *)
Definition standardForLoopⁱᵐᵖˡ : val :=
  λ: "s",
    exception_do (let: "s" := (GoAllocValue (go.SliceType go.uint64) "s") in
    let: "sumPtr" := (GoAlloc (go.PointerType go.uint64) #()) in
    let: "$r0" := (GoAlloc go.uint64 #()) in
    do:  ("sumPtr" <-[go.PointerType go.uint64] "$r0");;;
    (let: "i" := (GoAlloc go.uint64 #()) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (if: (![go.uint64] "i") < (s_to_w64 (let: "$a0" := (![go.SliceType go.uint64] "s") in
      slice.len "$a0"))
      then
        let: "sum" := (GoAlloc go.uint64 #()) in
        let: "$r0" := (![go.uint64] (![go.PointerType go.uint64] "sumPtr")) in
        do:  ("sum" <-[go.uint64] "$r0");;;
        let: "x" := (GoAlloc go.uint64 #()) in
        let: "$r0" := (![go.uint64] (slice.elem_ref go.uint64 (![go.SliceType go.uint64] "s") (![go.uint64] "i"))) in
        do:  ("x" <-[go.uint64] "$r0");;;
        let: "$r0" := ((![go.uint64] "sum") + (![go.uint64] "x")) in
        do:  ((![go.PointerType go.uint64] "sumPtr") <-[go.uint64] "$r0");;;
        let: "$r0" := ((![go.uint64] "i") + #(W64 1)) in
        do:  ("i" <-[go.uint64] "$r0");;;
        continue: #()
      else do:  #());;;
      break: #()));;;
    let: "sum" := (GoAlloc go.uint64 #()) in
    let: "$r0" := (![go.uint64] (![go.PointerType go.uint64] "sumPtr")) in
    do:  ("sum" <-[go.uint64] "$r0");;;
    return: (![go.uint64] "sum")).

Definition conditionalInLoop : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.conditionalInLoop"%go.

(* go: loops.go:25:6 *)
Definition conditionalInLoopⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do ((let: "i" := (GoAlloc go.uint64 #()) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (if: (![go.uint64] "i") < #(W64 3)
      then
        do:  (let: "$a0" := #"i is small"%go in
        (FuncResolve DoSomething #()) "$a0")
      else do:  #());;;
      (if: (![go.uint64] "i") > #(W64 5)
      then break: #()
      else do:  #());;;
      let: "$r0" := ((![go.uint64] "i") + #(W64 1)) in
      do:  ("i" <-[go.uint64] "$r0");;;
      continue: #()));;;
    return: #()).

Definition conditionalInLoopElse : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.conditionalInLoopElse"%go.

(* go: loops.go:38:6 *)
Definition conditionalInLoopElseⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do ((let: "i" := (GoAlloc go.uint64 #()) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (if: (![go.uint64] "i") > #(W64 5)
      then break: #()
      else
        let: "$r0" := ((![go.uint64] "i") + #(W64 1)) in
        do:  ("i" <-[go.uint64] "$r0");;;
        continue: #())));;;
    return: #()).

Definition nestedConditionalInLoopImplicitContinue : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.nestedConditionalInLoopImplicitContinue"%go.

(* go: loops.go:49:6 *)
Definition nestedConditionalInLoopImplicitContinueⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do ((let: "i" := (GoAlloc go.uint64 #()) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (if: (![go.uint64] "i") > #(W64 5)
      then
        (if: (![go.uint64] "i") > #(W64 10)
        then break: #()
        else do:  #())
      else
        let: "$r0" := ((![go.uint64] "i") + #(W64 1)) in
        do:  ("i" <-[go.uint64] "$r0");;;
        continue: #())));;;
    return: #()).

Definition ImplicitLoopContinue : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.ImplicitLoopContinue"%go.

(* go: loops.go:62:6 *)
Definition ImplicitLoopContinueⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do ((let: "i" := (GoAlloc go.uint64 #()) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (if: (![go.uint64] "i") < #(W64 4)
      then
        let: "$r0" := #(W64 0) in
        do:  ("i" <-[go.uint64] "$r0")
      else do:  #())));;;
    return: #()).

Definition ImplicitLoopContinue2 : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.ImplicitLoopContinue2"%go.

(* go: loops.go:70:6 *)
Definition ImplicitLoopContinue2ⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do ((let: "i" := (GoAlloc go.uint64 #()) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (if: (![go.uint64] "i") < #(W64 4)
      then
        let: "$r0" := #(W64 0) in
        do:  ("i" <-[go.uint64] "$r0");;;
        continue: #()
      else do:  #())));;;
    return: #()).

Definition ImplicitLoopContinueAfterIfBreak : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.ImplicitLoopContinueAfterIfBreak"%go.

(* go: loops.go:79:6 *)
Definition ImplicitLoopContinueAfterIfBreakⁱᵐᵖˡ : val :=
  λ: "i",
    exception_do (let: "i" := (GoAllocValue go.uint64 "i") in
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (if: (![go.uint64] "i") > #(W64 0)
      then break: #()
      else do:  #()));;;
    return: #()).

Definition nestedLoops : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.nestedLoops"%go.

(* go: loops.go:87:6 *)
Definition nestedLoopsⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do ((let: "i" := (GoAlloc go.uint64 #()) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (let: "j" := (GoAlloc go.uint64 #()) in
      let: "$r0" := #(W64 0) in
      do:  ("j" <-[go.uint64] "$r0");;;
      (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
        (if: #true
        then break: #()
        else do:  #());;;
        let: "$r0" := ((![go.uint64] "j") + #(W64 1)) in
        do:  ("j" <-[go.uint64] "$r0");;;
        continue: #()));;;
      let: "$r0" := ((![go.uint64] "i") + #(W64 1)) in
      do:  ("i" <-[go.uint64] "$r0");;;
      continue: #()));;;
    return: #()).

Definition nestedGoStyleLoops : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.nestedGoStyleLoops"%go.

(* go: loops.go:101:6 *)
Definition nestedGoStyleLoopsⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do ((let: "i" := (GoAlloc go.uint64 #()) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, (![go.uint64] "i") < #(W64 10)); (λ: <>, do:  ("i" <-[go.uint64] ((![go.uint64] "i") + #(W64 1)))) := λ: <>,
      (let: "j" := (GoAlloc go.uint64 #()) in
      let: "$r0" := #(W64 0) in
      do:  ("j" <-[go.uint64] "$r0");;;
      (for: (λ: <>, (![go.uint64] "j") < (![go.uint64] "i")); (λ: <>, do:  ("j" <-[go.uint64] ((![go.uint64] "j") + #(W64 1)))) := λ: <>,
        (if: #true
        then break: #()
        else do:  #());;;
        continue: #()))));;;
    return: #()).

Definition sumSlice : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.sumSlice"%go.

(* go: loops.go:113:6 *)
Definition sumSliceⁱᵐᵖˡ : val :=
  λ: "xs",
    exception_do (let: "xs" := (GoAllocValue (go.SliceType go.uint64) "xs") in
    let: "sum" := (GoAlloc go.uint64 #()) in
    let: "$range" := (![go.SliceType go.uint64] "xs") in
    (let: "x" := (GoAlloc go.uint64 #()) in
    slice.for_range go.uint64 "$range" (λ: "$key" "$value",
      do:  ("x" <-[go.uint64] "$value");;;
      do:  "$key";;;
      do:  ("sum" <-[go.uint64] ((![go.uint64] "sum") + (![go.uint64] "x")))));;;
    return: (![go.uint64] "sum")).

Definition intSliceLoop : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.intSliceLoop"%go.

(* go: loops.go:121:6 *)
Definition intSliceLoopⁱᵐᵖˡ : val :=
  λ: "xs",
    exception_do (let: "xs" := (GoAllocValue (go.SliceType go.uint64) "xs") in
    let: "sum" := (GoAlloc go.uint64 #()) in
    (let: "i" := (GoAlloc go.int #()) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.int] "$r0");;;
    (for: (λ: <>, int_lt (![go.int] "i") (let: "$a0" := (![go.SliceType go.uint64] "xs") in
    slice.len "$a0")); (λ: <>, do:  ("i" <-[go.int] ((![go.int] "i") + #(W64 1)))) := λ: <>,
      do:  ("sum" <-[go.uint64] ((![go.uint64] "sum") + (![go.uint64] (slice.elem_ref go.uint64 (![go.SliceType go.uint64] "xs") (![go.int] "i")))))));;;
    return: (![go.uint64] "sum")).

Definition breakFromLoop : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.breakFromLoop"%go.

(* go: loops.go:129:6 *)
Definition breakFromLoopⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do ((for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (if: #true
      then break: #()
      else do:  #());;;
      continue: #());;;
    return: #()).

Definition IterateMapKeys : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.IterateMapKeys"%go.

(* go: maps.go:3:6 *)
Definition IterateMapKeysⁱᵐᵖˡ : val :=
  λ: "m" "sum",
    exception_do (let: "sum" := (GoAllocValue (go.PointerType go.uint64) "sum") in
    let: "m" := (GoAllocValue (go.MapType go.uint64 go.uint64) "m") in
    let: "$range" := (![go.MapType go.uint64 go.uint64] "m") in
    (let: "k" := (GoAlloc go.uint64 #()) in
    map.for_range "$range" (λ: "$key" "value",
      do:  ("k" <-[go.uint64] "$key");;;
      let: "oldSum" := (GoAlloc go.uint64 #()) in
      let: "$r0" := (![go.uint64] (![go.PointerType go.uint64] "sum")) in
      do:  ("oldSum" <-[go.uint64] "$r0");;;
      let: "$r0" := ((![go.uint64] "oldSum") + (![go.uint64] "k")) in
      do:  ((![go.PointerType go.uint64] "sum") <-[go.uint64] "$r0")));;;
    return: #()).

Definition MapSize : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.MapSize"%go.

(* go: maps.go:10:6 *)
Definition MapSizeⁱᵐᵖˡ : val :=
  λ: "m",
    exception_do (let: "m" := (GoAllocValue (go.MapType go.uint64 go.bool) "m") in
    return: (s_to_w64 (let: "$a0" := (![go.MapType go.uint64 go.bool] "m") in
     map.len "$a0"))).

Definition IntWrapperⁱᵐᵖˡ  : go.type := go.uint64.

Definition MapWrapperⁱᵐᵖˡ  : go.type := go.MapType go.uint64 go.bool.

Definition MapTypeAliases : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.MapTypeAliases"%go.

(* go: maps.go:18:6 *)
Definition MapTypeAliasesⁱᵐᵖˡ : val :=
  λ: "m1" "m2",
    exception_do (let: "m2" := (GoAllocValue MapWrapper "m2") in
    let: "m1" := (GoAllocValue (go.MapType IntWrapper go.bool) "m1") in
    let: "$r0" := (Fst (map.get (![MapWrapper] "m2") #(W64 0))) in
    do:  (map.insert (![go.MapType IntWrapper go.bool] "m1") #(W64 4) "$r0");;;
    return: #()).

Definition StringMap : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.StringMap"%go.

(* go: maps.go:22:6 *)
Definition StringMapⁱᵐᵖˡ : val :=
  λ: "m",
    exception_do (let: "m" := (GoAllocValue (go.MapType go.string go.uint64) "m") in
    return: (Fst (map.get (![go.MapType go.string go.uint64] "m") #"foo"%go))).

Definition mapElemⁱᵐᵖˡ  : go.type := go.StructType [
  (go.FieldDecl "a"%go go.uint64);
  (go.FieldDecl "b"%go go.uint64)
].

Definition mapUpdateField : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.mapUpdateField"%go.

(* go: maps.go:31:6 *)
Definition mapUpdateFieldⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc (go.MapType go.uint64 (go.PointerType mapElem)) #()) in
    let: "$r0" := (map.make go.uint64 (go.PointerType mapElem)) in
    do:  ("x" <-[go.MapType go.uint64 (go.PointerType mapElem)] "$r0");;;
    let: "$r0" := #(W64 10) in
    do:  ((struct.field_ref mapElem #"a"%go (Fst (map.get (![go.MapType go.uint64 (go.PointerType mapElem)] "x") #(W64 0)))) <-[go.uint64] "$r0");;;
    return: #()).

Definition mapLiteral : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.mapLiteral"%go.

Definition mapLiteralWithConversion : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.mapLiteralWithConversion"%go.

Definition mapGetCall : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.mapGetCall"%go.

(* go: maps.go:44:6 *)
Definition mapGetCallⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "handlers" := (GoAlloc (go.MapType go.uint64 (go.FunctionType (go.Signature [] #false []))) #()) in
    let: "$r0" := (map.make go.uint64 (go.FunctionType (go.Signature [] #false []))) in
    do:  ("handlers" <-[go.MapType go.uint64 (go.FunctionType (go.Signature [] #false []))] "$r0");;;
    let: "$r0" := (λ: <>,
      exception_do (do:  #())
      ) in
    do:  (map.insert (![go.MapType go.uint64 (go.FunctionType (go.Signature [] #false []))] "handlers") #(W64 0) "$r0");;;
    do:  ((Fst (map.get (![go.MapType go.uint64 (go.FunctionType (go.Signature [] #false []))] "handlers") #(W64 0))) #());;;
    return: #()).

Definition mapLiteralTest : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.mapLiteralTest"%go.

(* go: maps.go:50:6 *)
Definition mapLiteralTestⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ascii" := (GoAlloc (go.MapType go.string go.uint64) #()) in
    let: "$r0" := ((let: "$v0" := #(W64 97) in
    let: "$k0" := #"a"%go in
    let: "$v1" := #(W64 98) in
    let: "$k1" := #"b"%go in
    let: "$v2" := #(W64 99) in
    let: "$k2" := #"c"%go in
    map.literal go.string go.uint64 [map.kv_entry "$k0" "$v0"; map.kv_entry "$k1" "$v1"; map.kv_entry "$k2" "$v2"])) in
    do:  ("ascii" <-[go.MapType go.string go.uint64] "$r0");;;
    return: (![go.MapType go.string go.uint64] "ascii")).

Definition mapClearTest : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.mapClearTest"%go.

(* go: maps.go:59:6 *)
Definition mapClearTestⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "m" := (mem.alloc (type.zero_val (type.mapT #intT #boolT))) in
    let: "$r0" := (map.make #intT #boolT) in
    do:  ("m" <-[type.mapT #intT #boolT] "$r0");;;
    let: "$r0" := #true in
    do:  (map.insert (![type.mapT #intT #boolT] "m") #(W64 1) "$r0");;;
    let: "$r0" := #false in
    do:  (map.insert (![type.mapT #intT #boolT] "m") #(W64 2) "$r0");;;
    let: "$r0" := #true in
    do:  (map.insert (![type.mapT #intT #boolT] "m") #(W64 7) "$r0");;;
    do:  (let: "$a0" := (![type.mapT #intT #boolT] "m") in
    map.clear "$a0");;;
    return: (let: "$a0" := (![type.mapT #intT #boolT] "m") in
     map.len "$a0")).

Definition returnTwo : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.returnTwo"%go.

(* go: multiple.go:3:6 *)
Definition returnTwoⁱᵐᵖˡ : val :=
  λ: "p",
    exception_do (let: "p" := (GoAllocValue (go.SliceType go.byte) "p") in
    return: (#(W64 0), #(W64 0))).

Definition returnTwoWrapper : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.returnTwoWrapper"%go.

(* go: multiple.go:7:6 *)
Definition returnTwoWrapperⁱᵐᵖˡ : val :=
  λ: "data",
    exception_do (let: "data" := (GoAllocValue (go.SliceType go.byte) "data") in
    let: "b" := (GoAlloc go.uint64 #()) in
    let: "a" := (GoAlloc go.uint64 #()) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] "data") in
    (FuncResolve returnTwo #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("a" <-[go.uint64] "$r0");;;
    do:  ("b" <-[go.uint64] "$r1");;;
    return: (![go.uint64] "a", ![go.uint64] "b")).

Definition multipleVar : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.multipleVar"%go.

(* go: multiple.go:12:6 *)
Definition multipleVarⁱᵐᵖˡ : val :=
  λ: "x" "y",
    exception_do (let: "y" := (GoAllocValue go.uint64 "y") in
    let: "x" := (GoAllocValue go.uint64 "x") in
    do:  #()).

Definition multiplePassThrough : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.multiplePassThrough"%go.

(* go: multiple.go:14:6 *)
Definition multiplePassThroughⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (do:  (let: ("$ret0", "$ret1") := ((let: "$a0" := #slice.nil in
    (FuncResolve returnTwoWrapper #()) "$a0")) in
    let: "$a0" := "$ret0" in
    let: "$a1" := "$ret1" in
    (FuncResolve multipleVar #()) "$a0" "$a1");;;
    return: #()).

Definition multipleReturnPassThrough : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.multipleReturnPassThrough"%go.

(* go: multiple.go:18:6 *)
Definition multipleReturnPassThroughⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: ("$ret0", "$ret1") := ((let: "$a0" := #slice.nil in
    (FuncResolve returnTwo #()) "$a0")) in
    return: ("$ret0", "$ret1")).

Definition AssignNilSlice : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.AssignNilSlice"%go.

(* go: nil.go:3:6 *)
Definition AssignNilSliceⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "s" := (GoAlloc (go.SliceType (go.SliceType go.byte)) #()) in
    let: "$r0" := (slice.make2 (go.SliceType go.byte) #(W64 4)) in
    do:  ("s" <-[go.SliceType (go.SliceType go.byte)] "$r0");;;
    let: "$r0" := #slice.nil in
    do:  ((slice.elem_ref (go.SliceType go.byte) (![go.SliceType (go.SliceType go.byte)] "s") #(W64 2)) <-[go.SliceType go.byte] "$r0");;;
    return: #()).

Definition AssignNilPointer : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.AssignNilPointer"%go.

(* go: nil.go:8:6 *)
Definition AssignNilPointerⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "s" := (GoAlloc (go.SliceType (go.PointerType go.uint64)) #()) in
    let: "$r0" := (slice.make2 (go.PointerType go.uint64) #(W64 4)) in
    do:  ("s" <-[go.SliceType (go.PointerType go.uint64)] "$r0");;;
    let: "$r0" := #null in
    do:  ((slice.elem_ref (go.PointerType go.uint64) (![go.SliceType (go.PointerType go.uint64)] "s") #(W64 2)) <-[go.PointerType go.uint64] "$r0");;;
    return: #()).

Definition CompareSliceToNil : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.CompareSliceToNil"%go.

(* go: nil.go:13:6 *)
Definition CompareSliceToNilⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "s" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := (slice.make2 go.byte #(W64 0)) in
    do:  ("s" <-[go.SliceType go.byte] "$r0");;;
    return: ((![go.SliceType go.byte] "s") ≠ #slice.nil)).

Definition ComparePointerToNil : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.ComparePointerToNil"%go.

(* go: nil.go:18:6 *)
Definition ComparePointerToNilⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "s" := (GoAlloc (go.PointerType go.uint64) #()) in
    let: "$r0" := (GoAlloc go.uint64 #()) in
    do:  ("s" <-[go.PointerType go.uint64] "$r0");;;
    return: ((![go.PointerType go.uint64] "s") ≠ #null)).

Definition containsPointerⁱᵐᵖˡ  : go.type := go.StructType [
  (go.FieldDecl "s"%go go.PointerType go.uint64)
].

Definition useNilField : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.useNilField"%go.

(* go: nil.go:27:6 *)
Definition useNilFieldⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (GoAllocValue containsPointer (let: "$s" := #null in
     struct.make containsPointer [{
       "s" ::= "$s"
     }]))).

Definition LogicalOperators : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.LogicalOperators"%go.

(* go: operators.go:3:6 *)
Definition LogicalOperatorsⁱᵐᵖˡ : val :=
  λ: "b1" "b2",
    exception_do (let: "b2" := (GoAllocValue go.bool "b2") in
    let: "b1" := (GoAllocValue go.bool "b1") in
    return: (((![go.bool] "b1") && ((![go.bool] "b2") || (![go.bool] "b1"))) && (~ #false))).

Definition LogicalAndEqualityOperators : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.LogicalAndEqualityOperators"%go.

(* go: operators.go:7:6 *)
Definition LogicalAndEqualityOperatorsⁱᵐᵖˡ : val :=
  λ: "b1" "x",
    exception_do (let: "x" := (GoAllocValue go.uint64 "x") in
    let: "b1" := (GoAllocValue go.bool "b1") in
    return: (((![go.uint64] "x") = #(W64 3)) && ((![go.bool] "b1") = #true))).

Definition ArithmeticShifts : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.ArithmeticShifts"%go.

(* go: operators.go:11:6 *)
Definition ArithmeticShiftsⁱᵐᵖˡ : val :=
  λ: "x" "y",
    exception_do (let: "y" := (GoAllocValue go.uint64 "y") in
    let: "x" := (GoAllocValue go.uint32 "x") in
    return: (#(W64 0))).

Definition BitwiseOps : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.BitwiseOps"%go.

(* go: operators.go:16:6 *)
Definition BitwiseOpsⁱᵐᵖˡ : val :=
  λ: "x" "y",
    exception_do (let: "y" := (GoAllocValue go.uint64 "y") in
    let: "x" := (GoAllocValue go.uint32 "x") in
    return: ((u_to_w64 (![go.uint32] "x")) `or` ((u_to_w64 (u_to_w32 (![go.uint64] "y"))) `and` #(W64 43)))).

Definition Comparison : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.Comparison"%go.

(* go: operators.go:20:6 *)
Definition Comparisonⁱᵐᵖˡ : val :=
  λ: "x" "y",
    exception_do (let: "y" := (GoAllocValue go.uint64 "y") in
    let: "x" := (GoAllocValue go.uint64 "x") in
    (if: (![go.uint64] "x") < (![go.uint64] "y")
    then return: (#true)
    else do:  #());;;
    (if: (![go.uint64] "x") = (![go.uint64] "y")
    then return: (#true)
    else do:  #());;;
    (if: (![go.uint64] "x") ≠ (![go.uint64] "y")
    then return: (#true)
    else do:  #());;;
    (if: (![go.uint64] "x") > (![go.uint64] "y")
    then return: (#true)
    else do:  #());;;
    (if: ((![go.uint64] "x") + #(W64 1)) > ((![go.uint64] "y") - #(W64 2))
    then return: (#true)
    else do:  #());;;
    return: (#false)).

Definition AssignOps : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.AssignOps"%go.

(* go: operators.go:39:6 *)
Definition AssignOpsⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.uint64 #()) in
    do:  ("x" <-[go.uint64] ((![go.uint64] "x") + #(W64 3)));;;
    do:  ("x" <-[go.uint64] ((![go.uint64] "x") - #(W64 3)));;;
    do:  ("x" <-[go.uint64] ((![go.uint64] "x") + #(W64 1)));;;
    do:  ("x" <-[go.uint64] ((![go.uint64] "x") - #(W64 1)));;;
    return: #()).

Definition BitwiseAndNot : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.BitwiseAndNot"%go.

(* go: operators.go:47:6 *)
Definition BitwiseAndNotⁱᵐᵖˡ : val :=
  λ: "x" "y",
    exception_do (let: "y" := (GoAllocValue go.uint64 "y") in
    let: "x" := (GoAllocValue go.uint32 "x") in
    let: "z" := (GoAlloc go.uint64 #()) in
    let: "$r0" := ((u_to_w64 (![go.uint32] "x")) `and_not` (![go.uint64] "y")) in
    do:  ("z" <-[go.uint64] "$r0");;;
    do:  ("z" <-[go.uint64] ((![go.uint64] "z") `and_not` #(W64 255)));;;
    return: (![go.uint64] "z")).

Definition Negative : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.Negative"%go.

(* go: operators.go:53:6 *)
Definition Negativeⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.int64 #()) in
    let: "$r0" := #(W64 (- 10)) in
    do:  ("x" <-[go.int64] "$r0");;;
    do:  ("x" <-[go.int64] ((![go.int64] "x") + #(W64 3)));;;
    return: #()).

Definition wrapExternalStructⁱᵐᵖˡ  : go.type := go.StructType [
  (go.FieldDecl "j"%go go.PointerType std.JoinHandle)
].

(* go: package.go:13:29 *)
Definition wrapExternalStruct__joinⁱᵐᵖˡ : val :=
  λ: "w" <>,
    exception_do (let: "w" := (GoAllocValue wrapExternalStruct "w") in
    do:  ((MethodResolve (go.PointerType std.JoinHandle) Join #() (![go.PointerType std.JoinHandle] (struct.field_ref wrapExternalStruct #"j"%go "w"))) #());;;
    return: #()).

Definition PanicAtTheDisco : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.PanicAtTheDisco"%go.

(* go: panic.go:3:6 *)
Definition PanicAtTheDiscoⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (do:  (let: "$a0" := (InterfaceMake go.string #"disco"%go) in
    Panic "$a0");;;
    return: #()).

Definition Oracle : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.Oracle"%go.

(* go: proph.go:5:6 *)
Definition Oracleⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "p" := (GoAlloc (go.PointerType primitive.prophId) #()) in
    let: "$r0" := ((FuncResolve primitive.NewProph #()) #()) in
    do:  ("p" <-[go.PointerType primitive.prophId] "$r0");;;
    let: "$r0" := (![go.PointerType primitive.prophId] "p") in
    do:  ("p" <-[go.PointerType primitive.prophId] "$r0");;;
    return: #()).

Definition typingⁱᵐᵖˡ  : go.type := go.StructType [
  (go.FieldDecl "proph"%go go.PointerType primitive.prophId)
].

Definition compositeⁱᵐᵖˡ  : go.type := go.StructType [
  (go.FieldDecl "a"%go go.uint64);
  (go.FieldDecl "b"%go go.uint64)
].

Definition ReassignVars : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.ReassignVars"%go.

(* go: reassign.go:8:6 *)
Definition ReassignVarsⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.uint64 #()) in
    let: "y" := (GoAlloc go.uint64 #()) in
    let: "$r0" := #(W64 0) in
    do:  ("y" <-[go.uint64] "$r0");;;
    let: "$r0" := #(W64 3) in
    do:  ("x" <-[go.uint64] "$r0");;;
    let: "z" := (GoAlloc composite #()) in
    let: "$r0" := (let: "$a" := (![go.uint64] "x") in
    let: "$b" := (![go.uint64] "y") in
    struct.make composite [{
      "a" ::= "$a";
      "b" ::= "$b"
    }]) in
    do:  ("z" <-[composite] "$r0");;;
    let: "$r0" := (let: "$a" := (![go.uint64] "y") in
    let: "$b" := (![go.uint64] "x") in
    struct.make composite [{
      "a" ::= "$a";
      "b" ::= "$b"
    }]) in
    do:  ("z" <-[composite] "$r0");;;
    let: "$r0" := (![go.uint64] (struct.field_ref composite #"a"%go "z")) in
    do:  ("x" <-[go.uint64] "$r0");;;
    return: #()).

Definition recur : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.recur"%go.

(* go: recursive.go:3:6 *)
Definition recurⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (do:  ((FuncResolve recur #()) #());;;
    return: #()).

Definition Rⁱᵐᵖˡ  : go.type := go.StructType [
].

(* go: recursive.go:10:13 *)
Definition R__recurMethodⁱᵐᵖˡ : val :=
  λ: "r" <>,
    exception_do (let: "r" := (GoAllocValue (go.PointerType R) "r") in
    do:  ((MethodResolve (go.PointerType R) recurMethod #() (![go.PointerType R] "r")) #());;;
    return: #()).

Definition Otherⁱᵐᵖˡ  : go.type := go.StructType [
  (go.FieldDecl "RecursiveEmbedded"%go go.PointerType RecursiveEmbedded)
].

Definition RecursiveEmbeddedⁱᵐᵖˡ  : go.type := go.StructType [
  (go.FieldDecl "Other"%go Other)
].

(* go: recursive.go:22:29 *)
Definition RecursiveEmbedded__recurEmbeddedMethodⁱᵐᵖˡ : val :=
  λ: "r" <>,
    exception_do (let: "r" := (GoAllocValue (go.PointerType RecursiveEmbedded) "r") in
    do:  ((MethodResolve Other recurEmbeddedMethod #() (![Other] (struct.field_ref RecursiveEmbedded #"Other"%go (![go.PointerType RecursiveEmbedded] "r")))) #());;;
    return: #()).

Definition useRenamedImport : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.useRenamedImport"%go.

(* go: renamedImport.go:7:6 *)
Definition useRenamedImportⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (do:  (let: "$a0" := ((let: "$sl0" := (InterfaceMake go.string #"blah"%go) in
    slice.literal (go.InterfaceType []) ["$sl0"])) in
    (FuncResolve fmt.Print #()) "$a0");;;
    return: #()).

Definition Blockⁱᵐᵖˡ  : go.type := go.StructType [
  (go.FieldDecl "Value"%go go.uint64)
].

Definition Disk1 : val := #(W64 0).

Definition Disk2 : val := #(W64 0).

Definition DiskSize : val := #(W64 1000).

Definition TwoDiskWrite : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.TwoDiskWrite"%go.

(* TwoDiskWrite is a dummy function to represent the base layer's disk write

   go: replicated_disk.go:12:6 *)
Definition TwoDiskWriteⁱᵐᵖˡ : val :=
  λ: "diskId" "a" "v",
    exception_do (let: "v" := (GoAllocValue Block "v") in
    let: "a" := (GoAllocValue go.uint64 "a") in
    let: "diskId" := (GoAllocValue go.uint64 "diskId") in
    return: (#true)).

Definition TwoDiskRead : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.TwoDiskRead"%go.

(* TwoDiskRead is a dummy function to represent the base layer's disk read

   go: replicated_disk.go:17:6 *)
Definition TwoDiskReadⁱᵐᵖˡ : val :=
  λ: "diskId" "a",
    exception_do (let: "a" := (GoAllocValue go.uint64 "a") in
    let: "diskId" := (GoAllocValue go.uint64 "diskId") in
    return: (let: "$Value" := #(W64 0) in
     struct.make Block [{
       "Value" ::= "$Value"
     }], #true)).

Definition TwoDiskLock : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.TwoDiskLock"%go.

(* TwoDiskLock is a dummy function to represent locking an address in the
   base layer

   go: replicated_disk.go:23:6 *)
Definition TwoDiskLockⁱᵐᵖˡ : val :=
  λ: "a",
    exception_do (let: "a" := (GoAllocValue go.uint64 "a") in
    do:  #()).

Definition TwoDiskUnlock : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.TwoDiskUnlock"%go.

(* TwoDiskUnlock is a dummy function to represent unlocking an address in the
   base layer

   go: replicated_disk.go:27:6 *)
Definition TwoDiskUnlockⁱᵐᵖˡ : val :=
  λ: "a",
    exception_do (let: "a" := (GoAllocValue go.uint64 "a") in
    do:  #()).

Definition ReplicatedDiskRead : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.ReplicatedDiskRead"%go.

(* go: replicated_disk.go:29:6 *)
Definition ReplicatedDiskReadⁱᵐᵖˡ : val :=
  λ: "a",
    exception_do (let: "a" := (GoAllocValue go.uint64 "a") in
    do:  (let: "$a0" := (![go.uint64] "a") in
    (FuncResolve TwoDiskLock #()) "$a0");;;
    let: "ok" := (GoAlloc go.bool #()) in
    let: "v" := (GoAlloc Block #()) in
    let: ("$ret0", "$ret1") := (let: "$a0" := Disk1 in
    let: "$a1" := (![go.uint64] "a") in
    (FuncResolve TwoDiskRead #()) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("v" <-[Block] "$r0");;;
    do:  ("ok" <-[go.bool] "$r1");;;
    (if: ![go.bool] "ok"
    then
      do:  (let: "$a0" := (![go.uint64] "a") in
      (FuncResolve TwoDiskUnlock #()) "$a0");;;
      return: (![Block] "v")
    else do:  #());;;
    let: "v2" := (GoAlloc Block #()) in
    let: ("$ret0", "$ret1") := (let: "$a0" := Disk2 in
    let: "$a1" := (![go.uint64] "a") in
    (FuncResolve TwoDiskRead #()) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("v2" <-[Block] "$r0");;;
    do:  "$r1";;;
    do:  (let: "$a0" := (![go.uint64] "a") in
    (FuncResolve TwoDiskUnlock #()) "$a0");;;
    return: (![Block] "v2")).

Definition ReplicatedDiskWrite : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.ReplicatedDiskWrite"%go.

(* go: replicated_disk.go:42:6 *)
Definition ReplicatedDiskWriteⁱᵐᵖˡ : val :=
  λ: "a" "v",
    exception_do (let: "v" := (GoAllocValue Block "v") in
    let: "a" := (GoAllocValue go.uint64 "a") in
    do:  (let: "$a0" := (![go.uint64] "a") in
    (FuncResolve TwoDiskLock #()) "$a0");;;
    do:  (let: "$a0" := Disk1 in
    let: "$a1" := (![go.uint64] "a") in
    let: "$a2" := (![Block] "v") in
    (FuncResolve TwoDiskWrite #()) "$a0" "$a1" "$a2");;;
    do:  (let: "$a0" := Disk2 in
    let: "$a1" := (![go.uint64] "a") in
    let: "$a2" := (![Block] "v") in
    (FuncResolve TwoDiskWrite #()) "$a0" "$a1" "$a2");;;
    do:  (let: "$a0" := (![go.uint64] "a") in
    (FuncResolve TwoDiskUnlock #()) "$a0");;;
    return: #()).

Definition ReplicatedDiskRecover : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.ReplicatedDiskRecover"%go.

(* go: replicated_disk.go:49:6 *)
Definition ReplicatedDiskRecoverⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do ((let: "a" := (GoAlloc go.uint64 #()) in
    let: "$r0" := #(W64 0) in
    do:  ("a" <-[go.uint64] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (if: (![go.uint64] "a") > DiskSize
      then break: #()
      else do:  #());;;
      let: "ok" := (GoAlloc go.bool #()) in
      let: "v" := (GoAlloc Block #()) in
      let: ("$ret0", "$ret1") := (let: "$a0" := Disk1 in
      let: "$a1" := (![go.uint64] "a") in
      (FuncResolve TwoDiskRead #()) "$a0" "$a1") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("v" <-[Block] "$r0");;;
      do:  ("ok" <-[go.bool] "$r1");;;
      (if: ![go.bool] "ok"
      then
        do:  (let: "$a0" := Disk2 in
        let: "$a1" := (![go.uint64] "a") in
        let: "$a2" := (![Block] "v") in
        (FuncResolve TwoDiskWrite #()) "$a0" "$a1" "$a2")
      else do:  #());;;
      let: "$r0" := ((![go.uint64] "a") + #(W64 1)) in
      do:  ("a" <-[go.uint64] "$r0");;;
      continue: #()));;;
    return: #()).

Definition BasicNamedReturn : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.BasicNamedReturn"%go.

(* go: returns.go:3:6 *)
Definition BasicNamedReturnⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.string #()) in
    return: (#"ok"%go)).

Definition NamedReturn : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.NamedReturn"%go.

(* go: returns.go:7:6 *)
Definition NamedReturnⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.string #()) in
    let: "$r0" := ((![go.string] "x") + #"foo"%go) in
    do:  ("x" <-[go.string] "$r0");;;
    return: (![go.string] "x")).

Definition BasicNamedReturnMany : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.BasicNamedReturnMany"%go.

(* go: returns.go:12:6 *)
Definition BasicNamedReturnManyⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "y" := (GoAlloc go.string #()) in
    let: "x" := (GoAlloc go.string #()) in
    return: (#"ok"%go, #"blah"%go)).

Definition NamedReturnMany : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.NamedReturnMany"%go.

(* go: returns.go:16:6 *)
Definition NamedReturnManyⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "y" := (GoAlloc go.string #()) in
    let: "x" := (GoAlloc go.string #()) in
    let: "$r0" := #"returned"%go in
    do:  ("x" <-[go.string] "$r0");;;
    let: "$r0" := #"ok"%go in
    do:  ("y" <-[go.string] "$r0");;;
    return: (![go.string] "x", ![go.string] "y")).

Definition NamedReturnOverride : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.NamedReturnOverride"%go.

(* go: returns.go:22:6 *)
Definition NamedReturnOverrideⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "y" := (GoAlloc go.string #()) in
    let: "x" := (GoAlloc go.string #()) in
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "x" := (GoAlloc go.string #()) in
      let: "$r0" := #"unused"%go in
      do:  ("x" <-[go.string] "$r0");;;
      do:  ("x" <-[go.string] ((![go.string] "x") + #"stillUnused"%go));;;
      let: "$r0" := #"ok"%go in
      do:  ("y" <-[go.string] "$r0");;;
      break: #());;;
    return: (![go.string] "x", ![go.string] "y")).

Definition VoidButEndsWithReturn : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.VoidButEndsWithReturn"%go.

(* go: returns.go:32:6 *)
Definition VoidButEndsWithReturnⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (do:  ((FuncResolve BasicNamedReturn #()) #());;;
    return: #()).

Definition VoidImplicitReturnInBranch : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.VoidImplicitReturnInBranch"%go.

(* go: returns.go:38:6 *)
Definition VoidImplicitReturnInBranchⁱᵐᵖˡ : val :=
  λ: "b",
    exception_do (let: "b" := (GoAllocValue go.bool "b") in
    (if: ![go.bool] "b"
    then return: (#())
    else do:  ((FuncResolve BasicNamedReturn #()) #()));;;
    return: #()).

<<<<<<< HEAD
Definition SliceAliasⁱᵐᵖˡ  : go.type := go.SliceType go.bool.
=======
Definition useRuneOps : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.useRuneOps"%go.

(* go: rune.go:3:6 *)
Definition useRuneOpsⁱᵐᵖˡ : val :=
  λ: "r",
    exception_do (let: "r" := (mem.alloc "r") in
    do:  ("r" <-[#runeT] ((![#runeT] "r") + #(W32 1)));;;
    let: "$r0" := #(W32 97) in
    do:  ("r" <-[#runeT] "$r0");;;
    let: "$r0" := #(W32 47) in
    do:  ("r" <-[#runeT] "$r0");;;
    let: "x" := (mem.alloc (type.zero_val #int32T)) in
    let: "$r0" := #(W32 98) in
    do:  ("x" <-[#int32T] "$r0");;;
    let: "$r0" := (![#int32T] "x") in
    do:  ("r" <-[#runeT] "$r0");;;
    return: (![#runeT] "r")).

Definition SliceAlias : go_type := sliceT.
#[global] Typeclasses Opaque SliceAlias.
#[global] Opaque SliceAlias.
>>>>>>> master

Definition sliceOps : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.sliceOps"%go.

(* go: slices.go:5:6 *)
Definition sliceOpsⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc (go.SliceType go.uint64) #()) in
    let: "$r0" := (slice.make2 go.uint64 #(W64 10)) in
    do:  ("x" <-[go.SliceType go.uint64] "$r0");;;
    let: "v1" := (GoAlloc go.uint64 #()) in
    let: "$r0" := (![go.uint64] (slice.elem_ref go.uint64 (![go.SliceType go.uint64] "x") #(W64 2))) in
    do:  ("v1" <-[go.uint64] "$r0");;;
    let: "v2" := (GoAlloc (go.SliceType go.uint64) #()) in
    let: "$r0" := (let: "$s" := (![go.SliceType go.uint64] "x") in
    slice.slice go.uint64 "$s" #(W64 2) #(W64 3)) in
    do:  ("v2" <-[go.SliceType go.uint64] "$r0");;;
    let: "v3" := (GoAlloc (go.SliceType go.uint64) #()) in
    let: "$r0" := (let: "$s" := (![go.SliceType go.uint64] "x") in
    slice.slice go.uint64 "$s" #(W64 0) #(W64 3)) in
    do:  ("v3" <-[go.SliceType go.uint64] "$r0");;;
    let: "v4" := (GoAlloc (go.PointerType go.uint64) #()) in
    let: "$r0" := (slice.elem_ref go.uint64 (![go.SliceType go.uint64] "x") #(W64 2)) in
    do:  ("v4" <-[go.PointerType go.uint64] "$r0");;;
    return: ((((((![go.uint64] "v1") + (![go.uint64] (slice.elem_ref go.uint64 (![go.SliceType go.uint64] "v2") #(W64 0)))) + (![go.uint64] (slice.elem_ref go.uint64 (![go.SliceType go.uint64] "v3") #(W64 1)))) + (![go.uint64] (![go.PointerType go.uint64] "v4"))) + (s_to_w64 (let: "$a0" := (![go.SliceType go.uint64] "x") in
     slice.len "$a0"))) + (s_to_w64 (let: "$a0" := (![go.SliceType go.uint64] "x") in
     slice.cap "$a0")))).

Definition makeSingletonSlice : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.makeSingletonSlice"%go.

(* go: slices.go:14:6 *)
Definition makeSingletonSliceⁱᵐᵖˡ : val :=
  λ: "x",
    exception_do (let: "x" := (GoAllocValue go.uint64 "x") in
    return: ((let: "$sl0" := (![go.uint64] "x") in
     slice.literal go.uint64 ["$sl0"]))).

Definition thingⁱᵐᵖˡ  : go.type := go.StructType [
  (go.FieldDecl "x"%go go.uint64)
].

Definition sliceOfThingsⁱᵐᵖˡ  : go.type := go.StructType [
  (go.FieldDecl "things"%go go.SliceType thing)
].

(* go: slices.go:26:25 *)
Definition sliceOfThings__getThingRefⁱᵐᵖˡ : val :=
  λ: "ts" "i",
    exception_do (let: "ts" := (GoAllocValue sliceOfThings "ts") in
    let: "i" := (GoAllocValue go.uint64 "i") in
    return: (slice.elem_ref thing (![go.SliceType thing] (struct.field_ref sliceOfThings #"things"%go "ts")) (![go.uint64] "i"))).

Definition makeAlias : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.makeAlias"%go.

(* go: slices.go:30:6 *)
Definition makeAliasⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (slice.make2 go.bool #(W64 10))).

Definition Skip : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.Skip"%go.

(* Skip is a placeholder for some impure code

   go: spawn.go:8:6 *)
Definition Skipⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (do:  #()).

Definition simpleSpawn : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.simpleSpawn"%go.

(* go: spawn.go:10:6 *)
Definition simpleSpawnⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "l" := (GoAlloc (go.PointerType sync.Mutex) #()) in
    let: "$r0" := (GoAlloc sync.Mutex #()) in
    do:  ("l" <-[go.PointerType sync.Mutex] "$r0");;;
    let: "v" := (GoAlloc (go.PointerType go.uint64) #()) in
    let: "$r0" := (GoAlloc go.uint64 #()) in
    do:  ("v" <-[go.PointerType go.uint64] "$r0");;;
    let: "$go" := (λ: <>,
      exception_do (do:  ((MethodResolve (go.PointerType sync.Mutex) Lock #() (![go.PointerType sync.Mutex] "l")) #());;;
      let: "x" := (GoAlloc go.uint64 #()) in
      let: "$r0" := (![go.uint64] (![go.PointerType go.uint64] "v")) in
      do:  ("x" <-[go.uint64] "$r0");;;
      (if: (![go.uint64] "x") > #(W64 0)
      then do:  ((FuncResolve Skip #()) #())
      else do:  #());;;
      do:  ((MethodResolve (go.PointerType sync.Mutex) Unlock #() (![go.PointerType sync.Mutex] "l")) #());;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) Lock #() (![go.PointerType sync.Mutex] "l")) #());;;
    let: "$r0" := #(W64 1) in
    do:  ((![go.PointerType go.uint64] "v") <-[go.uint64] "$r0");;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) Unlock #() (![go.PointerType sync.Mutex] "l")) #());;;
    return: #()).

Definition threadCode : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.threadCode"%go.

(* go: spawn.go:26:6 *)
Definition threadCodeⁱᵐᵖˡ : val :=
  λ: "tid",
    exception_do (let: "tid" := (GoAllocValue go.uint64 "tid") in
    do:  #()).

Definition loopSpawn : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.loopSpawn"%go.

(* go: spawn.go:28:6 *)
Definition loopSpawnⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do ((let: "i" := (GoAlloc go.uint64 #()) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, (![go.uint64] "i") < #(W64 10)); (λ: <>, do:  ("i" <-[go.uint64] ((![go.uint64] "i") + #(W64 1)))) := λ: <>,
      let: "i" := (GoAlloc go.uint64 #()) in
      let: "$r0" := (![go.uint64] "i") in
      do:  ("i" <-[go.uint64] "$r0");;;
      let: "$go" := (λ: <>,
        exception_do (do:  (let: "$a0" := (![go.uint64] "i") in
        (FuncResolve threadCode #()) "$a0");;;
        return: #())
        ) in
      do:  (Fork ("$go" #()))));;;
    (let: "dummy" := (GoAlloc go.bool #()) in
    let: "$r0" := #true in
    do:  ("dummy" <-[go.bool] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "$r0" := (~ (![go.bool] "dummy")) in
      do:  ("dummy" <-[go.bool] "$r0");;;
      continue: #()));;;
    return: #()).

Definition stringAppend : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.stringAppend"%go.

(* go: strings.go:3:6 *)
Definition stringAppendⁱᵐᵖˡ : val :=
  λ: "s",
    exception_do (let: "s" := (GoAllocValue go.string "s") in
    return: ((#"prefix "%go + (![go.string] "s")) + #" "%go)).

Definition stringLength : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.stringLength"%go.

(* go: strings.go:7:6 *)
Definition stringLengthⁱᵐᵖˡ : val :=
  λ: "s",
    exception_do (let: "s" := (GoAllocValue go.string "s") in
    return: (s_to_w64 (let: "$a0" := (![go.string] "s") in
     StringLength "$a0"))).

Definition x : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.x"%go.

(* go: strings.go:11:6 *)
Definition xⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (do:  (let: "$a0" := #("a"%go ++ "b"%go) in
    (FuncResolve stringAppend #()) "$a0");;;
    return: #()).

Definition Pointⁱᵐᵖˡ  : go.type := go.StructType [
  (go.FieldDecl "x"%go go.uint64);
  (go.FieldDecl "y"%go go.uint64)
].

(* go: struct_method.go:8:16 *)
Definition Point__Addⁱᵐᵖˡ : val :=
  λ: "c" "z",
    exception_do (let: "c" := (GoAllocValue Point "c") in
    let: "z" := (GoAllocValue go.uint64 "z") in
    return: (((![go.uint64] (struct.field_ref Point #"x"%go "c")) + (![go.uint64] (struct.field_ref Point #"y"%go "c"))) + (![go.uint64] "z"))).

(* go: struct_method.go:12:16 *)
Definition Point__GetFieldⁱᵐᵖˡ : val :=
  λ: "c" <>,
    exception_do (let: "c" := (GoAllocValue Point "c") in
    let: "x" := (GoAlloc go.uint64 #()) in
    let: "$r0" := (![go.uint64] (struct.field_ref Point #"x"%go "c")) in
    do:  ("x" <-[go.uint64] "$r0");;;
    let: "y" := (GoAlloc go.uint64 #()) in
    let: "$r0" := (![go.uint64] (struct.field_ref Point #"y"%go "c")) in
    do:  ("y" <-[go.uint64] "$r0");;;
    return: ((![go.uint64] "x") + (![go.uint64] "y"))).

Definition UseAdd : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.UseAdd"%go.

(* go: struct_method.go:18:6 *)
Definition UseAddⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "c" := (GoAlloc Point #()) in
    let: "$r0" := (let: "$x" := #(W64 2) in
    let: "$y" := #(W64 3) in
    struct.make Point [{
      "x" ::= "$x";
      "y" ::= "$y"
    }]) in
    do:  ("c" <-[Point] "$r0");;;
    let: "r" := (GoAlloc go.uint64 #()) in
    let: "$r0" := (let: "$a0" := #(W64 4) in
    (MethodResolve Point Add #() (![Point] "c")) "$a0") in
    do:  ("r" <-[go.uint64] "$r0");;;
    return: (![go.uint64] "r")).

Definition UseAddWithLiteral : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.UseAddWithLiteral"%go.

(* go: struct_method.go:24:6 *)
Definition UseAddWithLiteralⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "r" := (GoAlloc go.uint64 #()) in
    let: "$r0" := (let: "$a0" := #(W64 4) in
    (MethodResolve Point Add #() (let: "$x" := #(W64 2) in
    let: "$y" := #(W64 3) in
    struct.make Point [{
      "x" ::= "$x";
      "y" ::= "$y"
    }])) "$a0") in
    do:  ("r" <-[go.uint64] "$r0");;;
    return: (![go.uint64] "r")).

(* go: struct_method.go:29:14 *)
Definition Point__IgnoreReceiverⁱᵐᵖˡ : val :=
  λ: <> <>,
    exception_do (return: (#"ok"%go)).

Definition TwoIntsⁱᵐᵖˡ  : go.type := go.StructType [
  (go.FieldDecl "x"%go go.uint64);
  (go.FieldDecl "y"%go go.uint64)
].

Definition Sⁱᵐᵖˡ  : go.type := go.StructType [
  (go.FieldDecl "a"%go go.uint64);
  (go.FieldDecl "b"%go TwoInts);
  (go.FieldDecl "c"%go go.bool)
].

Definition NewS : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.NewS"%go.

(* go: struct_pointers.go:14:6 *)
Definition NewSⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (GoAllocValue S (let: "$a" := #(W64 2) in
     let: "$b" := (let: "$x" := #(W64 1) in
     let: "$y" := #(W64 2) in
     struct.make TwoInts [{
       "x" ::= "$x";
       "y" ::= "$y"
     }]) in
     let: "$c" := #true in
     struct.make S [{
       "a" ::= "$a";
       "b" ::= "$b";
       "c" ::= "$c"
     }]))).

(* go: struct_pointers.go:22:13 *)
Definition S__readAⁱᵐᵖˡ : val :=
  λ: "s" <>,
    exception_do (let: "s" := (GoAllocValue (go.PointerType S) "s") in
    return: (![go.uint64] (struct.field_ref S #"a"%go (![go.PointerType S] "s")))).

(* go: struct_pointers.go:26:13 *)
Definition S__readBⁱᵐᵖˡ : val :=
  λ: "s" <>,
    exception_do (let: "s" := (GoAllocValue (go.PointerType S) "s") in
    return: (![TwoInts] (struct.field_ref S #"b"%go (![go.PointerType S] "s")))).

(* go: struct_pointers.go:30:12 *)
Definition S__readBValⁱᵐᵖˡ : val :=
  λ: "s" <>,
    exception_do (let: "s" := (GoAllocValue S "s") in
    return: (![TwoInts] (struct.field_ref S #"b"%go "s"))).

(* go: struct_pointers.go:34:13 *)
Definition S__writeBⁱᵐᵖˡ : val :=
  λ: "s" "two",
    exception_do (let: "s" := (GoAllocValue (go.PointerType S) "s") in
    let: "two" := (GoAllocValue TwoInts "two") in
    let: "$r0" := (![TwoInts] "two") in
    do:  ((struct.field_ref S #"b"%go (![go.PointerType S] "s")) <-[TwoInts] "$r0");;;
    return: #()).

(* go: struct_pointers.go:38:13 *)
Definition S__negateCⁱᵐᵖˡ : val :=
  λ: "s" <>,
    exception_do (let: "s" := (GoAllocValue (go.PointerType S) "s") in
    let: "$r0" := (~ (![go.bool] (struct.field_ref S #"c"%go (![go.PointerType S] "s")))) in
    do:  ((struct.field_ref S #"c"%go (![go.PointerType S] "s")) <-[go.bool] "$r0");;;
    return: #()).

(* go: struct_pointers.go:42:13 *)
Definition S__refCⁱᵐᵖˡ : val :=
  λ: "s" <>,
    exception_do (let: "s" := (GoAllocValue (go.PointerType S) "s") in
    return: (struct.field_ref S #"c"%go (![go.PointerType S] "s"))).

Definition localSRef : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.localSRef"%go.

(* go: struct_pointers.go:46:6 *)
Definition localSRefⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "s" := (GoAlloc S #()) in
    return: (struct.field_ref S #"b"%go "s")).

Definition setField : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.setField"%go.

(* go: struct_pointers.go:54:6 *)
Definition setFieldⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "s" := (GoAlloc S #()) in
    let: "$r0" := #(W64 0) in
    do:  ((struct.field_ref S #"a"%go "s") <-[go.uint64] "$r0");;;
    let: "$r0" := #true in
    do:  ((struct.field_ref S #"c"%go "s") <-[go.bool] "$r0");;;
    return: (![S] "s")).

Definition testSwitchVal : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.testSwitchVal"%go.

(* go: switch.go:3:6 *)
Definition testSwitchValⁱᵐᵖˡ : val :=
  λ: "x",
    exception_do (let: "x" := (GoAllocValue go.uint64 "x") in
    let: "$sw" := (![go.uint64] "x") in
    (if: "$sw" = #(W64 0)
    then return: (#true)
    else
      (if: "$sw" = #(W64 1)
      then return: (#false)
      else return: (#false)))).

Definition testSwitchMultiple : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.testSwitchMultiple"%go.

(* go: switch.go:14:6 *)
Definition testSwitchMultipleⁱᵐᵖˡ : val :=
  λ: "x",
    exception_do (let: "x" := (GoAllocValue go.uint64 "x") in
    let: "$sw" := (![go.uint64] "x") in
    (if: ("$sw" = #(W64 1)) || ("$sw" = #(W64 10))
    then return: (#(W64 1))
    else
      (if: "$sw" = #(W64 0)
      then return: (#(W64 2))
      else do:  #()));;;
    return: (#(W64 3))).

Definition DoSomeLocking : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.DoSomeLocking"%go.

(* DoSomeLocking uses the entire lock API

   go: synchronization.go:6:6 *)
Definition DoSomeLockingⁱᵐᵖˡ : val :=
  λ: "l",
    exception_do (let: "l" := (GoAllocValue (go.PointerType sync.Mutex) "l") in
    do:  ((MethodResolve (go.PointerType sync.Mutex) Lock #() (![go.PointerType sync.Mutex] "l")) #());;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) Unlock #() (![go.PointerType sync.Mutex] "l")) #());;;
    return: #()).

Definition makeLock : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.makeLock"%go.

(* go: synchronization.go:15:6 *)
Definition makeLockⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "l" := (GoAlloc (go.PointerType sync.Mutex) #()) in
    let: "$r0" := (GoAlloc sync.Mutex #()) in
    do:  ("l" <-[go.PointerType sync.Mutex] "$r0");;;
    do:  (let: "$a0" := (![go.PointerType sync.Mutex] "l") in
    (FuncResolve DoSomeLocking #()) "$a0");;;
    return: #()).

Definition sleep : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.sleep"%go.

(* go: time.go:5:6 *)
Definition sleepⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (do:  (let: "$a0" := #(W64 1000) in
    (FuncResolve primitive.Sleep #()) "$a0");;;
    return: #()).

Definition Bⁱᵐᵖˡ  : go.type := go.StructType [
  (go.FieldDecl "a"%go go.SliceType A)
].

Definition Aⁱᵐᵖˡ  : go.type := go.StructType [
].

Definition mkInt : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.mkInt"%go.

(* go: trailing_call.go:3:6 *)
Definition mkIntⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (#(W64 42))).

Definition mkNothing : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.mkNothing"%go.

(* go: trailing_call.go:7:6 *)
Definition mkNothingⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (do:  ((FuncResolve mkInt #()) #());;;
    return: #()).

Definition my_u64  : go.type := go.uint64.

Definition Timestampⁱᵐᵖˡ  : go.type := go.uint64.

Definition UseTypeAbbrevⁱᵐᵖˡ  : go.type := go.uint64.

Definition UseNamedTypeⁱᵐᵖˡ  : go.type := Timestamp.

Definition convertToAlias : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.convertToAlias"%go.

(* go: type_alias.go:11:6 *)
Definition convertToAliasⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.uint64 #()) in
    let: "$r0" := #(W64 2) in
    do:  ("x" <-[go.uint64] "$r0");;;
    return: (![go.uint64] "x")).

Definition typeAssertInt : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.typeAssertInt"%go.

(* go: type_switch.go:3:6 *)
Definition typeAssertIntⁱᵐᵖˡ : val :=
  λ: "x",
    exception_do (let: "x" := (GoAllocValue (go.InterfaceType []) "x") in
    return: (TypeAssert go.int (![go.InterfaceType []] "x"))).

Definition wrapUnwrapInt : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.wrapUnwrapInt"%go.

(* go: type_switch.go:7:6 *)
Definition wrapUnwrapIntⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (let: "$a0" := (InterfaceMake go.int #(W64 1)) in
     (FuncResolve typeAssertInt #()) "$a0")).

Definition checkedTypeAssert : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.checkedTypeAssert"%go.

(* go: type_switch.go:11:6 *)
Definition checkedTypeAssertⁱᵐᵖˡ : val :=
  λ: "x",
    exception_do (let: "x" := (GoAllocValue (go.InterfaceType []) "x") in
    (let: "ok" := (GoAlloc go.bool #()) in
    let: "v" := (GoAlloc go.uint64 #()) in
    let: ("$ret0", "$ret1") := (TypeAssert2 go.uint64 (![go.InterfaceType []] "x")) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("v" <-[go.uint64] "$r0");;;
    do:  ("ok" <-[go.bool] "$r1");;;
    (if: ![go.bool] "ok"
    then return: (![go.uint64] "v")
    else do:  #()));;;
    return: (#(W64 3))).

Definition basicTypeSwitch : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.basicTypeSwitch"%go.

(* go: type_switch.go:18:6 *)
Definition basicTypeSwitchⁱᵐᵖˡ : val :=
  λ: "x",
    exception_do (let: "x" := (GoAllocValue (go.InterfaceType []) "x") in
    let: "$y" := (![go.InterfaceType []] "x") in
    let: ("$x", "$ok") := (TypeAssert2 go.int "$y" #go.int) in
    (if: "$ok"
    then return: (#(W64 1))
    else
      let: ("$x", "$ok") := (TypeAssert2 go.string "$y" #go.string) in
      (if: "$ok"
      then return: (#(W64 2))
      else do:  #()));;;
    return: (#(W64 0))).

Definition fancyTypeSwitch : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.fancyTypeSwitch"%go.

(* go: type_switch.go:28:6 *)
Definition fancyTypeSwitchⁱᵐᵖˡ : val :=
  λ: "x",
    exception_do (let: "x" := (GoAllocValue (go.InterfaceType []) "x") in
    let: "r" := (GoAlloc go.int #()) in
    let: "$y" := (![go.InterfaceType []] "x") in
    (let: "z" := (GoAlloc go.int #()) in
    let: "$r0" := #(W64 0) in
    do:  ("z" <-[go.int] "$r0");;;
    let: ("$x", "$ok") := (TypeAssert2 go.int "$y" #go.int) in
    (if: "$ok"
    then
      let: "y" := (GoAllocValue go.int "$x") in
      return: (![go.int] "y")
    else
      let: ("$x", "$ok") := (TypeAssert2 go.string "$y" #go.string) in
      (if: "$ok"
      then
        let: "y" := (GoAllocValue go.string "$x") in
        return: (#(W64 2))
      else
        let: "$ok" := ("$y" = #interface.nil) in
        let: "$x" := "$y" in
        (if: "$ok"
        then
          let: "y" := (GoAllocValue go.untyped nil "$x") in
          return: (#(W64 4))
        else
          let: "$r0" := #(W64 3) in
          do:  ("z" <-[go.int] "$r0");;;
          let: "$r0" := (![go.int] "z") in
          do:  ("r" <-[go.int] "$r0")))));;;
    return: (![go.int] "r")).

Definition multiTypeSwitch : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.multiTypeSwitch"%go.

(* go: type_switch.go:44:6 *)
Definition multiTypeSwitchⁱᵐᵖˡ : val :=
  λ: "x",
    exception_do (let: "x" := (GoAllocValue (go.InterfaceType []) "x") in
    let: "$y" := (![go.InterfaceType []] "x") in
    let: "$ok" := ((Snd (TypeAssert2 go.int "$y" #go.int)) || (Snd (TypeAssert2 go.int "$y" #go.int))) in
    let: "$x" := "$y" in
    (if: "$ok"
    then return: (#(W64 1))
    else do:  #());;;
    return: (#(W64 0))).

Definition variadicFunc : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.variadicFunc"%go.

(* go: varargs.go:3:6 *)
Definition variadicFuncⁱᵐᵖˡ : val :=
  λ: "a" "b" "cs",
    exception_do (let: "cs" := (GoAllocValue (go.SliceType go.byte) "cs") in
    let: "b" := (GoAllocValue go.string "b") in
    let: "a" := (GoAllocValue go.uint64 "a") in
    do:  #()).

Definition testVariadicCall : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.testVariadicCall"%go.

(* go: varargs.go:6:6 *)
Definition testVariadicCallⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (do:  (let: "$a0" := #(W64 10) in
    let: "$a1" := #"abc"%go in
    let: "$a2" := ((let: "$sl0" := #(W8 0) in
    let: "$sl1" := #(W8 1) in
    let: "$sl2" := #(W8 2) in
    let: "$sl3" := #(W8 3) in
    slice.literal go.byte ["$sl0"; "$sl1"; "$sl2"; "$sl3"])) in
    (FuncResolve variadicFunc #()) "$a0" "$a1" "$a2");;;
    do:  (let: "$a0" := #(W64 10) in
    let: "$a1" := #"abc"%go in
    let: "$a2" := #slice.nil in
    (FuncResolve variadicFunc #()) "$a0" "$a1" "$a2");;;
    let: "c" := (GoAlloc (go.SliceType go.byte) #()) in
    do:  (let: "$a0" := #(W64 10) in
    let: "$a1" := #"abc"%go in
    let: "$a2" := (![go.SliceType go.byte] "c") in
    (FuncResolve variadicFunc #()) "$a0" "$a1" "$a2");;;
    return: #()).

Definition returnMultiple : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.returnMultiple"%go.

(* go: varargs.go:13:6 *)
Definition returnMultipleⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (#(W64 0), #"xyz"%go, #(W8 0), #(W8 0))).

Definition testVariadicPassThrough : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.testVariadicPassThrough"%go.

(* go: varargs.go:17:6 *)
Definition testVariadicPassThroughⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (do:  (let: ((("$ret0", "$ret1"), "$ret2"), "$ret3") := (((FuncResolve returnMultiple #()) #())) in
    let: "$a0" := "$ret0" in
    let: "$a1" := "$ret1" in
    let: "$a2" := ((let: "$sl0" := "$ret2" in
    let: "$sl1" := "$ret3" in
    slice.literal go.byte ["$sl0"; "$sl1"])) in
    (FuncResolve variadicFunc #()) "$a0" "$a1" "$a2");;;
    return: #()).

Definition LocalVars : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.LocalVars"%go.

(* go: vars.go:3:6 *)
Definition LocalVarsⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "b" := (GoAlloc go.string #()) in
    let: "a" := (GoAlloc go.int #()) in
    do:  ("b" <-[go.string] ((![go.string] "b") + #"hello"%go));;;
    return: (![go.int] "a")).

Definition LocalConsts : go_string := "github.com/goose-lang/goose/testdata/examples/unittest.LocalConsts"%go.

(* go: vars.go:12:6 *)
Definition LocalConstsⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.int #()) in
    let c := 10 in
    let d := 15 in
    let e := 8 in
    do:  ("x" <-[go.int] ((![go.int] "x") + #(W64 c)));;;
    do:  ("x" <-[go.int] ((![go.int] "x") - #(W64 d)));;;
    return: (![go.int] "x")).

Definition vars' : list (go_string * go.type) := [(GlobalX, go.uint64); (globalY, go.string); (globalA, go.string); (globalB, go.string); (mapLiteral, go.MapType go.string go.uint64); (mapLiteralWithConversion, go.MapType (go.InterfaceType []) (go.InterfaceType []))].

Definition functions' : list (go_string * val) := [(takesArray, takesArrayⁱᵐᵖˡ); (takesPtr, takesPtrⁱᵐᵖˡ); (usesArrayElemRef, usesArrayElemRefⁱᵐᵖˡ); (sum, sumⁱᵐᵖˡ); (arrayToSlice, arrayToSliceⁱᵐᵖˡ); (arrayLiteralKeyed, arrayLiteralKeyedⁱᵐᵖˡ); (chanBasic, chanBasicⁱᵐᵖˡ); (f, fⁱᵐᵖˡ); (chanSelect, chanSelectⁱᵐᵖˡ); (chanDirectional, chanDirectionalⁱᵐᵖˡ); (chanRange, chanRangeⁱᵐᵖˡ); (doSubtleThings, doSubtleThingsⁱᵐᵖˡ); (hasStartComment, hasStartCommentⁱᵐᵖˡ); (hasEndComment, hasEndCommentⁱᵐᵖˡ); (condvarWrapping, condvarWrappingⁱᵐᵖˡ); (useUntypedInt, useUntypedIntⁱᵐᵖˡ); (useUntypedString, useUntypedStringⁱᵐᵖˡ); (conditionalReturn, conditionalReturnⁱᵐᵖˡ); (alwaysReturn, alwaysReturnⁱᵐᵖˡ); (alwaysReturnInNestedBranches, alwaysReturnInNestedBranchesⁱᵐᵖˡ); (earlyReturn, earlyReturnⁱᵐᵖˡ); (conditionalAssign, conditionalAssignⁱᵐᵖˡ); (elseIf, elseIfⁱᵐᵖˡ); (ifStmtInitialization, ifStmtInitializationⁱᵐᵖˡ); (typedLiteral, typedLiteralⁱᵐᵖˡ); (literalCast, literalCastⁱᵐᵖˡ); (castInt, castIntⁱᵐᵖˡ); (stringToByteSlice, stringToByteSliceⁱᵐᵖˡ); (byteSliceToString, byteSliceToStringⁱᵐᵖˡ); (stringToStringWrapper, stringToStringWrapperⁱᵐᵖˡ); (stringWrapperToString, stringWrapperToStringⁱᵐᵖˡ); (testU32NewtypeLen, testU32NewtypeLenⁱᵐᵖˡ); (testNumWrapper, testNumWrapperⁱᵐᵖˡ); (testCopySimple, testCopySimpleⁱᵐᵖˡ); (testCopyDifferentLengths, testCopyDifferentLengthsⁱᵐᵖˡ); (atomicCreateStub, atomicCreateStubⁱᵐᵖˡ); (useSlice, useSliceⁱᵐᵖˡ); (useSliceIndexing, useSliceIndexingⁱᵐᵖˡ); (useMap, useMapⁱᵐᵖˡ); (usePtr, usePtrⁱᵐᵖˡ); (iterMapKeysAndValues, iterMapKeysAndValuesⁱᵐᵖˡ); (iterMapKeys, iterMapKeysⁱᵐᵖˡ); (getRandom, getRandomⁱᵐᵖˡ); (diskArgument, diskArgumentⁱᵐᵖˡ); (returnEmbedVal, returnEmbedValⁱᵐᵖˡ); (returnEmbedValWithPointer, returnEmbedValWithPointerⁱᵐᵖˡ); (useEmbeddedField, useEmbeddedFieldⁱᵐᵖˡ); (useEmbeddedValField, useEmbeddedValFieldⁱᵐᵖˡ); (useEmbeddedMethod, useEmbeddedMethodⁱᵐᵖˡ); (useEmbeddedMethod2, useEmbeddedMethod2ⁱᵐᵖˡ); (empty, emptyⁱᵐᵖˡ); (emptyReturn, emptyReturnⁱᵐᵖˡ); (unnamedParams, unnamedParamsⁱᵐᵖˡ); (anonymousParam, anonymousParamⁱᵐᵖˡ); (useFloat, useFloatⁱᵐᵖˡ); (compareIntFloat, compareIntFloatⁱᵐᵖˡ); (compareFloatInt, compareFloatIntⁱᵐᵖˡ); (forRangeNoBinding, forRangeNoBindingⁱᵐᵖˡ); (forRangeOldVars, forRangeOldVarsⁱᵐᵖˡ); (foo, fooⁱᵐᵖˡ); (other, otherⁱᵐᵖˡ); (bar, barⁱᵐᵖˡ); (useUntypedRune, useUntypedRuneⁱᵐᵖˡ); (TakesFunctionType, TakesFunctionTypeⁱᵐᵖˡ); (FuncVar, FuncVarⁱᵐᵖˡ); (fooConsumer, fooConsumerⁱᵐᵖˡ); (testAssignConcreteToInterface, testAssignConcreteToInterfaceⁱᵐᵖˡ); (testPassConcreteToInterfaceArg, testPassConcreteToInterfaceArgⁱᵐᵖˡ); (testPassConcreteToInterfaceArgSpecial, testPassConcreteToInterfaceArgSpecialⁱᵐᵖˡ); (takesVarArgsInterface, takesVarArgsInterfaceⁱᵐᵖˡ); (test, testⁱᵐᵖˡ); (returnConcrete, returnConcreteⁱᵐᵖˡ); (testMultiReturn, testMultiReturnⁱᵐᵖˡ); (testReturnStatment, testReturnStatmentⁱᵐᵖˡ); (testConversionInEq, testConversionInEqⁱᵐᵖˡ); (takeMultiple, takeMultipleⁱᵐᵖˡ); (giveMultiple, giveMultipleⁱᵐᵖˡ); (testConversionInMultipleReturnPassThrough, testConversionInMultipleReturnPassThroughⁱᵐᵖˡ); (testConversionInMultiplePassThrough, testConversionInMultiplePassThroughⁱᵐᵖˡ); (testPtrMset, testPtrMsetⁱᵐᵖˡ); (pointerAny, pointerAnyⁱᵐᵖˡ); (useInts, useIntsⁱᵐᵖˡ); (signedMidpoint, signedMidpointⁱᵐᵖˡ); (normalLiterals, normalLiteralsⁱᵐᵖˡ); (outOfOrderLiteral, outOfOrderLiteralⁱᵐᵖˡ); (specialLiterals, specialLiteralsⁱᵐᵖˡ); (oddLiterals, oddLiteralsⁱᵐᵖˡ); (unKeyedLiteral, unKeyedLiteralⁱᵐᵖˡ); (useLocks, useLocksⁱᵐᵖˡ); (useCondVar, useCondVarⁱᵐᵖˡ); (ToBeDebugged, ToBeDebuggedⁱᵐᵖˡ); (DoNothing, DoNothingⁱᵐᵖˡ); (DoSomething, DoSomethingⁱᵐᵖˡ); (standardForLoop, standardForLoopⁱᵐᵖˡ); (conditionalInLoop, conditionalInLoopⁱᵐᵖˡ); (conditionalInLoopElse, conditionalInLoopElseⁱᵐᵖˡ); (nestedConditionalInLoopImplicitContinue, nestedConditionalInLoopImplicitContinueⁱᵐᵖˡ); (ImplicitLoopContinue, ImplicitLoopContinueⁱᵐᵖˡ); (ImplicitLoopContinue2, ImplicitLoopContinue2ⁱᵐᵖˡ); (ImplicitLoopContinueAfterIfBreak, ImplicitLoopContinueAfterIfBreakⁱᵐᵖˡ); (nestedLoops, nestedLoopsⁱᵐᵖˡ); (nestedGoStyleLoops, nestedGoStyleLoopsⁱᵐᵖˡ); (sumSlice, sumSliceⁱᵐᵖˡ); (intSliceLoop, intSliceLoopⁱᵐᵖˡ); (breakFromLoop, breakFromLoopⁱᵐᵖˡ); (IterateMapKeys, IterateMapKeysⁱᵐᵖˡ); (MapSize, MapSizeⁱᵐᵖˡ); (MapTypeAliases, MapTypeAliasesⁱᵐᵖˡ); (StringMap, StringMapⁱᵐᵖˡ); (mapUpdateField, mapUpdateFieldⁱᵐᵖˡ); (mapGetCall, mapGetCallⁱᵐᵖˡ); (mapLiteralTest, mapLiteralTestⁱᵐᵖˡ); (mapClearTest, mapClearTestⁱᵐᵖˡ); (returnTwo, returnTwoⁱᵐᵖˡ); (returnTwoWrapper, returnTwoWrapperⁱᵐᵖˡ); (multipleVar, multipleVarⁱᵐᵖˡ); (multiplePassThrough, multiplePassThroughⁱᵐᵖˡ); (multipleReturnPassThrough, multipleReturnPassThroughⁱᵐᵖˡ); (AssignNilSlice, AssignNilSliceⁱᵐᵖˡ); (AssignNilPointer, AssignNilPointerⁱᵐᵖˡ); (CompareSliceToNil, CompareSliceToNilⁱᵐᵖˡ); (ComparePointerToNil, ComparePointerToNilⁱᵐᵖˡ); (useNilField, useNilFieldⁱᵐᵖˡ); (LogicalOperators, LogicalOperatorsⁱᵐᵖˡ); (LogicalAndEqualityOperators, LogicalAndEqualityOperatorsⁱᵐᵖˡ); (ArithmeticShifts, ArithmeticShiftsⁱᵐᵖˡ); (BitwiseOps, BitwiseOpsⁱᵐᵖˡ); (Comparison, Comparisonⁱᵐᵖˡ); (AssignOps, AssignOpsⁱᵐᵖˡ); (BitwiseAndNot, BitwiseAndNotⁱᵐᵖˡ); (Negative, Negativeⁱᵐᵖˡ); (PanicAtTheDisco, PanicAtTheDiscoⁱᵐᵖˡ); (Oracle, Oracleⁱᵐᵖˡ); (ReassignVars, ReassignVarsⁱᵐᵖˡ); (recur, recurⁱᵐᵖˡ); (useRenamedImport, useRenamedImportⁱᵐᵖˡ); (TwoDiskWrite, TwoDiskWriteⁱᵐᵖˡ); (TwoDiskRead, TwoDiskReadⁱᵐᵖˡ); (TwoDiskLock, TwoDiskLockⁱᵐᵖˡ); (TwoDiskUnlock, TwoDiskUnlockⁱᵐᵖˡ); (ReplicatedDiskRead, ReplicatedDiskReadⁱᵐᵖˡ); (ReplicatedDiskWrite, ReplicatedDiskWriteⁱᵐᵖˡ); (ReplicatedDiskRecover, ReplicatedDiskRecoverⁱᵐᵖˡ); (BasicNamedReturn, BasicNamedReturnⁱᵐᵖˡ); (NamedReturn, NamedReturnⁱᵐᵖˡ); (BasicNamedReturnMany, BasicNamedReturnManyⁱᵐᵖˡ); (NamedReturnMany, NamedReturnManyⁱᵐᵖˡ); (NamedReturnOverride, NamedReturnOverrideⁱᵐᵖˡ); (VoidButEndsWithReturn, VoidButEndsWithReturnⁱᵐᵖˡ); (VoidImplicitReturnInBranch, VoidImplicitReturnInBranchⁱᵐᵖˡ); (useRuneOps, useRuneOpsⁱᵐᵖˡ); (sliceOps, sliceOpsⁱᵐᵖˡ); (makeSingletonSlice, makeSingletonSliceⁱᵐᵖˡ); (makeAlias, makeAliasⁱᵐᵖˡ); (Skip, Skipⁱᵐᵖˡ); (simpleSpawn, simpleSpawnⁱᵐᵖˡ); (threadCode, threadCodeⁱᵐᵖˡ); (loopSpawn, loopSpawnⁱᵐᵖˡ); (stringAppend, stringAppendⁱᵐᵖˡ); (stringLength, stringLengthⁱᵐᵖˡ); (x, xⁱᵐᵖˡ); (UseAdd, UseAddⁱᵐᵖˡ); (UseAddWithLiteral, UseAddWithLiteralⁱᵐᵖˡ); (NewS, NewSⁱᵐᵖˡ); (localSRef, localSRefⁱᵐᵖˡ); (setField, setFieldⁱᵐᵖˡ); (testSwitchVal, testSwitchValⁱᵐᵖˡ); (testSwitchMultiple, testSwitchMultipleⁱᵐᵖˡ); (DoSomeLocking, DoSomeLockingⁱᵐᵖˡ); (makeLock, makeLockⁱᵐᵖˡ); (sleep, sleepⁱᵐᵖˡ); (mkInt, mkIntⁱᵐᵖˡ); (mkNothing, mkNothingⁱᵐᵖˡ); (convertToAlias, convertToAliasⁱᵐᵖˡ); (typeAssertInt, typeAssertIntⁱᵐᵖˡ); (wrapUnwrapInt, wrapUnwrapIntⁱᵐᵖˡ); (checkedTypeAssert, checkedTypeAssertⁱᵐᵖˡ); (basicTypeSwitch, basicTypeSwitchⁱᵐᵖˡ); (fancyTypeSwitch, fancyTypeSwitchⁱᵐᵖˡ); (multiTypeSwitch, multiTypeSwitchⁱᵐᵖˡ); (variadicFunc, variadicFuncⁱᵐᵖˡ); (testVariadicCall, testVariadicCallⁱᵐᵖˡ); (returnMultiple, returnMultipleⁱᵐᵖˡ); (testVariadicPassThrough, testVariadicPassThroughⁱᵐᵖˡ); (LocalVars, LocalVarsⁱᵐᵖˡ); (LocalConsts, LocalConstsⁱᵐᵖˡ)].

<<<<<<< HEAD
Definition msets' : list (go_string * (list (go_string * val))) := [(Foo, []); (go.PointerType Foo, []); (importantStruct, []); (go.PointerType importantStruct, []); (stringWrapper, []); (go.PointerType stringWrapper, []); (Uint32, []); (go.PointerType Uint32, []); (diskWrapper, []); (go.PointerType diskWrapper, []); (embedA, [("Foo"%go, embedA__Fooⁱᵐᵖˡ)]); (go.PointerType embedA, [("Bar"%go, embedA__Barⁱᵐᵖˡ); ("Foo"%go, (λ: "$r",
                 MethodResolve embedA Foo #() (![embedA] "$r")
                 )%V)]); (embedB, [("Foo"%go, embedB__Fooⁱᵐᵖˡ)]); (go.PointerType embedB, [("Bar"%go, (λ: "$r",
                 MethodResolve (go.PointerType embedA) Bar #() (struct.field_ref embedB #"embedA"%go "$r")
=======
Definition msets' : list (go_string * (list (go_string * val))) := [(Foo.id, []); (ptrT.id Foo.id, []); (importantStruct.id, []); (ptrT.id importantStruct.id, []); (stringWrapper.id, []); (ptrT.id stringWrapper.id, []); (Uint32.id, []); (ptrT.id Uint32.id, []); (numWrapper.id, []); (ptrT.id numWrapper.id, [("inc"%go, numWrapper__incⁱᵐᵖˡ)]); (diskWrapper.id, []); (ptrT.id diskWrapper.id, []); (embedA.id, [("Foo"%go, embedA__Fooⁱᵐᵖˡ)]); (ptrT.id embedA.id, [("Bar"%go, embedA__Barⁱᵐᵖˡ); ("Foo"%go, (λ: "$r",
                 method_call #embedA.id #"Foo"%go (![#embedA] "$r")
                 )%V)]); (embedB.id, [("Foo"%go, embedB__Fooⁱᵐᵖˡ)]); (ptrT.id embedB.id, [("Bar"%go, (λ: "$r",
                 method_call #(ptrT.id embedA.id) #"Bar"%go (struct.field_ref #embedB #"embedA"%go "$r")
>>>>>>> master
                 )%V); ("Car"%go, embedB__Carⁱᵐᵖˡ); ("Foo"%go, (λ: "$r",
                 MethodResolve embedB Foo #() (![embedB] "$r")
                 )%V)]); (embedC, [("Bar"%go, (λ: "$r",
                 MethodResolve (go.PointerType embedB) Bar #() (struct.field_get embedC #"embedB"%go "$r")
                 )%V); ("Car"%go, (λ: "$r",
                 MethodResolve (go.PointerType embedB) Car #() (struct.field_get embedC #"embedB"%go "$r")
                 )%V); ("Foo"%go, (λ: "$r",
                 MethodResolve (go.PointerType embedB) Foo #() (struct.field_get embedC #"embedB"%go "$r")
                 )%V)]); (go.PointerType embedC, [("Bar"%go, (λ: "$r",
                 MethodResolve (go.PointerType embedB) Bar #() (![go.PointerType embedB] (struct.field_ref embedC #"embedB"%go "$r"))
                 )%V); ("Car"%go, (λ: "$r",
                 MethodResolve (go.PointerType embedB) Car #() (![go.PointerType embedB] (struct.field_ref embedC #"embedB"%go "$r"))
                 )%V); ("Foo"%go, (λ: "$r",
                 MethodResolve (go.PointerType embedB) Foo #() (![go.PointerType embedB] (struct.field_ref embedC #"embedB"%go "$r"))
                 )%V)]); (embedD, [("Bar"%go, (λ: "$r",
                 MethodResolve embedC Bar #() (struct.field_get embedD #"embedC"%go "$r")
                 )%V); ("Car"%go, (λ: "$r",
                 MethodResolve embedC Car #() (struct.field_get embedD #"embedC"%go "$r")
                 )%V); ("Foo"%go, (λ: "$r",
                 MethodResolve embedC Foo #() (struct.field_get embedD #"embedC"%go "$r")
                 )%V)]); (go.PointerType embedD, [("Bar"%go, (λ: "$r",
                 MethodResolve (go.PointerType embedC) Bar #() (struct.field_ref embedD #"embedC"%go "$r")
                 )%V); ("Car"%go, (λ: "$r",
                 MethodResolve (go.PointerType embedC) Car #() (struct.field_ref embedD #"embedC"%go "$r")
                 )%V); ("Foo"%go, (λ: "$r",
                 MethodResolve (go.PointerType embedC) Foo #() (struct.field_ref embedD #"embedC"%go "$r")
                 )%V)]); (Enc, []); (go.PointerType Enc, [("UInt32"%go, Enc__UInt32ⁱᵐᵖˡ); ("UInt64"%go, Enc__UInt64ⁱᵐᵖˡ); ("consume"%go, Enc__consumeⁱᵐᵖˡ)]); (Dec, []); (go.PointerType Dec, [("UInt32"%go, Dec__UInt32ⁱᵐᵖˡ); ("UInt64"%go, Dec__UInt64ⁱᵐᵖˡ); ("consume"%go, Dec__consumeⁱᵐᵖˡ)]); (Enum1, []); (go.PointerType Enum1, []); (Enum2, []); (go.PointerType Enum2, []); (concreteFooer, []); (go.PointerType concreteFooer, [("Foo"%go, concreteFooer__Fooⁱᵐᵖˡ)]); (FooerUser, []); (go.PointerType FooerUser, []); (concrete1, [("Foo"%go, concrete1__Fooⁱᵐᵖˡ)]); (go.PointerType concrete1, [("B"%go, concrete1__Bⁱᵐᵖˡ); ("Foo"%go, (λ: "$r",
                 MethodResolve concrete1 Foo #() (![concrete1] "$r")
                 )%V)]); (my_u32, []); (go.PointerType my_u32, []); (also_u32, []); (go.PointerType also_u32, []); (allTheLiterals, []); (go.PointerType allTheLiterals, []); (hasCondVar, []); (go.PointerType hasCondVar, []); (IntWrapper, []); (go.PointerType IntWrapper, []); (MapWrapper, []); (go.PointerType MapWrapper, []); (mapElem, []); (go.PointerType mapElem, []); (containsPointer, []); (go.PointerType containsPointer, []); (wrapExternalStruct, [("join"%go, wrapExternalStruct__joinⁱᵐᵖˡ)]); (go.PointerType wrapExternalStruct, [("join"%go, (λ: "$r",
                 MethodResolve wrapExternalStruct join #() (![wrapExternalStruct] "$r")
                 )%V)]); (typing, []); (go.PointerType typing, []); (composite, []); (go.PointerType composite, []); (R, []); (go.PointerType R, [("recurMethod"%go, R__recurMethodⁱᵐᵖˡ)]); (Other, [("recurEmbeddedMethod"%go, (λ: "$r",
                 MethodResolve (go.PointerType RecursiveEmbedded) recurEmbeddedMethod #() (struct.field_get Other #"RecursiveEmbedded"%go "$r")
                 )%V)]); (go.PointerType Other, [("recurEmbeddedMethod"%go, (λ: "$r",
                 MethodResolve (go.PointerType RecursiveEmbedded) recurEmbeddedMethod #() (![go.PointerType RecursiveEmbedded] (struct.field_ref Other #"RecursiveEmbedded"%go "$r"))
                 )%V)]); (RecursiveEmbedded, []); (go.PointerType RecursiveEmbedded, [("recurEmbeddedMethod"%go, RecursiveEmbedded__recurEmbeddedMethodⁱᵐᵖˡ)]); (Block, []); (go.PointerType Block, []); (SliceAlias, []); (go.PointerType SliceAlias, []); (thing, []); (go.PointerType thing, []); (sliceOfThings, [("getThingRef"%go, sliceOfThings__getThingRefⁱᵐᵖˡ)]); (go.PointerType sliceOfThings, [("getThingRef"%go, (λ: "$r",
                 MethodResolve sliceOfThings getThingRef #() (![sliceOfThings] "$r")
                 )%V)]); (Point, [("Add"%go, Point__Addⁱᵐᵖˡ); ("GetField"%go, Point__GetFieldⁱᵐᵖˡ); ("IgnoreReceiver"%go, Point__IgnoreReceiverⁱᵐᵖˡ)]); (go.PointerType Point, [("Add"%go, (λ: "$r",
                 MethodResolve Point Add #() (![Point] "$r")
                 )%V); ("GetField"%go, (λ: "$r",
                 MethodResolve Point GetField #() (![Point] "$r")
                 )%V); ("IgnoreReceiver"%go, (λ: "$r",
                 MethodResolve Point IgnoreReceiver #() (![Point] "$r")
                 )%V)]); (TwoInts, []); (go.PointerType TwoInts, []); (S, [("readBVal"%go, S__readBValⁱᵐᵖˡ)]); (go.PointerType S, [("negateC"%go, S__negateCⁱᵐᵖˡ); ("readA"%go, S__readAⁱᵐᵖˡ); ("readB"%go, S__readBⁱᵐᵖˡ); ("readBVal"%go, (λ: "$r",
                 MethodResolve S readBVal #() (![S] "$r")
                 )%V); ("refC"%go, S__refCⁱᵐᵖˡ); ("writeB"%go, S__writeBⁱᵐᵖˡ)]); (B, []); (go.PointerType B, []); (A, []); (go.PointerType A, []); (Timestamp, []); (go.PointerType Timestamp, []); (UseTypeAbbrev, []); (go.PointerType UseTypeAbbrev, []); (UseNamedType, []); (go.PointerType UseNamedType, [])].

#[global] Instance info' : PkgInfo unittest.unittest :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [code.fmt.fmt; code.sync.sync; code.github_com.goose_lang.primitive.primitive; code.github_com.goose_lang.primitive.disk.disk; code.log.log; code.github_com.goose_lang.std.std; code.fmt.fmt];
  |}.

Definition initialize' : val :=
  λ: <>,
    package.init #unittest.unittest (λ: <>,
      exception_do (do:  (fmt.initialize' #());;;
      do:  (std.initialize' #());;;
      do:  (log.initialize' #());;;
      do:  (disk.initialize' #());;;
      do:  (primitive.initialize' #());;;
      do:  (sync.initialize' #());;;
      do:  (fmt.initialize' #());;;
      do:  (package.alloc unittest.unittest #());;;
      let: "$r0" := ((FuncResolve foo #()) #()) in
      do:  ((globals.get #GlobalX) <-[go.uint64] "$r0");;;
      let: "$r0" := #"a"%go in
      do:  ((globals.get #globalA) <-[go.string] "$r0");;;
      let: "$r0" := #"b"%go in
      do:  ((globals.get #globalB) <-[go.string] "$r0");;;
      let: "$r0" := ((FuncResolve foo #()) #()) in
      let: "$r0" := ((let: "$v0" := #(W64 10) in
      let: "$k0" := #"a"%go in
      map.literal go.string go.uint64 [map.kv_entry "$k0" "$v0"])) in
      do:  ((globals.get #mapLiteral) <-[go.MapType go.string go.uint64] "$r0");;;
      let: "$r0" := ((let: "$v0" := (InterfaceMake go.int #(W64 10)) in
      let: "$k0" := (InterfaceMake go.string #"a"%go) in
      map.literal (go.InterfaceType []) (go.InterfaceType []) [map.kv_entry "$k0" "$v0"])) in
      do:  ((globals.get #mapLiteralWithConversion) <-[go.MapType (go.InterfaceType []) (go.InterfaceType [])] "$r0");;;
      do:  ((λ: <>,
        exception_do (let: "$r0" := (![go.uint64] (globals.get #GlobalX)) in
        do:  ((globals.get #GlobalX) <-[go.uint64] "$r0");;;
        return: #())
        ) #());;;
      do:  ((λ: <>,
        exception_do (let: "$r0" := #""%go in
        do:  ((globals.get #globalY) <-[go.string] "$r0");;;
        return: #())
        ) #()))
      ).

End code.
End unittest.
