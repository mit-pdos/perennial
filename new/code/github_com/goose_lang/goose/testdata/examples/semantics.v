(* autogenerated from github.com/goose-lang/goose/testdata/examples/semantics *)
Require Export New.code.github_com.goose_lang.primitive.
Require Export New.code.github_com.goose_lang.primitive.disk.
Require Export New.code.sync.

From New.golang Require Import defn.
Definition semantics : go_string := "github.com/goose-lang/goose/testdata/examples/semantics".

From New Require Import disk_prelude.
Module semantics.

Section code.


Definition unitⁱᵐᵖˡ : go.type := go.StructType [
].

Definition findKey : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.findKey"%go.

Definition unit : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/semantics.unit"%go [].

(* go: allocator.go:7:6 *)
Definition findKeyⁱᵐᵖˡ : val :=
  λ: "m",
    exception_do (let: "m" := (GoAlloc (go.MapType go.uint64 unit) "m") in
    let: "found" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("found" <-[go.uint64] "$r0");;;
    let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #false in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$range" := (![go.MapType go.uint64 unit] "m") in
    (let: "k" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    map.for_range "$range" (λ: "$key" "value",
      do:  ("k" <-[go.uint64] "$key");;;
      (if: (~ (![go.bool] "ok"))
      then
        let: "$r0" := (![go.uint64] "k") in
        do:  ("found" <-[go.uint64] "$r0");;;
        let: "$r0" := #true in
        do:  ("ok" <-[go.bool] "$r0")
      else do:  #())));;;
    return: (![go.uint64] "found", ![go.bool] "ok")).

Definition allocate : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.allocate"%go.

(* go: allocator.go:20:6 *)
Definition allocateⁱᵐᵖˡ : val :=
  λ: "m",
    exception_do (let: "m" := (GoAlloc (go.MapType go.uint64 unit) "m") in
    let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "k" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.MapType go.uint64 unit] "m") in
    (FuncResolve findKey [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("k" <-[go.uint64] "$r0");;;
    do:  ("ok" <-[go.bool] "$r1");;;
    do:  (let: "$a0" := (![go.MapType go.uint64 unit] "m") in
    let: "$a1" := (![go.uint64] "k") in
    (FuncResolve go.delete [go.MapType go.uint64 unit] #()) "$a0" "$a1");;;
    return: (![go.uint64] "k", ![go.bool] "ok")).

Definition freeRange : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.freeRange"%go.

(* go: allocator.go:26:6 *)
Definition freeRangeⁱᵐᵖˡ : val :=
  λ: "sz",
    exception_do (let: "sz" := (GoAlloc go.uint64 "sz") in
    let: "m" := (GoAlloc (go.MapType go.uint64 unit) (GoZeroVal (go.MapType go.uint64 unit) #())) in
    let: "$r0" := ((FuncResolve go.make1 [go.MapType go.uint64 unit] #()) #()) in
    do:  ("m" <-[go.MapType go.uint64 unit] "$r0");;;
    (let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, (![go.uint64] "i") <⟨go.uint64⟩ (![go.uint64] "sz")); (λ: <>, do:  ("i" <-[go.uint64] ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 1)))) := λ: <>,
      let: "$r0" := (CompositeLiteral unit (LiteralValue [])) in
      do:  (map.insert (![go.MapType go.uint64 unit] "m") (![go.uint64] "i") "$r0")));;;
    return: (![go.MapType go.uint64 unit] "m")).

Definition testAllocateDistinct : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testAllocateDistinct"%go.

(* go: allocator.go:34:6 *)
Definition testAllocateDistinctⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "free" := (GoAlloc (go.MapType go.uint64 unit) (GoZeroVal (go.MapType go.uint64 unit) #())) in
    let: "$r0" := (let: "$a0" := #(W64 4) in
    (FuncResolve freeRange [] #()) "$a0") in
    do:  ("free" <-[go.MapType go.uint64 unit] "$r0");;;
    let: "a1" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.MapType go.uint64 unit] "free") in
    (FuncResolve allocate [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("a1" <-[go.uint64] "$r0");;;
    do:  "$r1";;;
    let: "a2" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.MapType go.uint64 unit] "free") in
    (FuncResolve allocate [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("a2" <-[go.uint64] "$r0");;;
    do:  "$r1";;;
    return: ((![go.uint64] "a1") ≠⟨go.uint64⟩ (![go.uint64] "a2"))).

Definition testAllocateFull : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testAllocateFull"%go.

(* go: allocator.go:41:6 *)
Definition testAllocateFullⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "free" := (GoAlloc (go.MapType go.uint64 unit) (GoZeroVal (go.MapType go.uint64 unit) #())) in
    let: "$r0" := (let: "$a0" := #(W64 2) in
    (FuncResolve freeRange [] #()) "$a0") in
    do:  ("free" <-[go.MapType go.uint64 unit] "$r0");;;
    let: "ok1" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.MapType go.uint64 unit] "free") in
    (FuncResolve allocate [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  "$r0";;;
    do:  ("ok1" <-[go.bool] "$r1");;;
    let: "ok2" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.MapType go.uint64 unit] "free") in
    (FuncResolve allocate [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  "$r0";;;
    do:  ("ok2" <-[go.bool] "$r1");;;
    let: "ok3" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.MapType go.uint64 unit] "free") in
    (FuncResolve allocate [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  "$r0";;;
    do:  ("ok3" <-[go.bool] "$r1");;;
    return: (((![go.bool] "ok1") && (![go.bool] "ok2")) && (~ (![go.bool] "ok3")))).

Definition testExplicitBlockStmt : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testExplicitBlockStmt"%go.

(* go: block.go:3:6 *)
Definition testExplicitBlockStmtⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := #(W64 10) in
    do:  ("x" <-[go.int] "$r0");;;
    let: "x" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := #(W64 11) in
    do:  ("x" <-[go.int] "$r0");;;
    do:  ("x" <-[go.int] ((![go.int] "x") +⟨go.int⟩ #(W64 1)));;;
    return: ((![go.int] "x") =⟨go.int⟩ #(W64 10))).

Definition testMinUint64 : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testMinUint64"%go.

(* go: builtin.go:3:6 *)
Definition testMinUint64ⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 10) in
    do:  ("x" <-[go.uint64] "$r0");;;
    return: ((let: "$a0" := (![go.uint64] "x") in
     let: "$a1" := #(W64 1) in
     (FuncResolve go.min [go.uint64; go.uint64] #()) "$a0" "$a1") =⟨go.uint64⟩ #(W64 1))).

Definition testMaxUint64 : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testMaxUint64"%go.

(* go: builtin.go:8:6 *)
Definition testMaxUint64ⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 10) in
    do:  ("x" <-[go.uint64] "$r0");;;
    return: ((let: "$a0" := (![go.uint64] "x") in
     let: "$a1" := #(W64 1) in
     (FuncResolve go.max [go.uint64; go.uint64] #()) "$a0" "$a1") =⟨go.uint64⟩ #(W64 10))).

Definition AdderType : go.type := go.FunctionType (go.Signature [go.uint64] false [go.uint64]).

Definition MultipleArgsType : go.type := go.FunctionType (go.Signature [go.uint64; go.bool] false [go.uint64]).

Definition adder : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.adder"%go.

(* go: closures.go:6:6 *)
Definition adderⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "sum" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("sum" <-[go.uint64] "$r0");;;
    return: ((λ: "x",
       exception_do (let: "x" := (GoAlloc go.uint64 "x") in
       do:  ("sum" <-[go.uint64] ((![go.uint64] "sum") +⟨go.uint64⟩ (![go.uint64] "x")));;;
       return: (![go.uint64] "sum"))
       ))).

Definition testClosureBasic : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testClosureBasic"%go.

(* go: closures.go:14:6 *)
Definition testClosureBasicⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "pos" := (GoAlloc (go.FunctionType (go.Signature [go.uint64] false [go.uint64])) (GoZeroVal (go.FunctionType (go.Signature [go.uint64] false [go.uint64])) #())) in
    let: "$r0" := ((FuncResolve adder [] #()) #()) in
    do:  ("pos" <-[go.FunctionType (go.Signature [go.uint64] false [go.uint64])] "$r0");;;
    let: "doub" := (GoAlloc (go.FunctionType (go.Signature [go.uint64] false [go.uint64])) (GoZeroVal (go.FunctionType (go.Signature [go.uint64] false [go.uint64])) #())) in
    let: "$r0" := ((FuncResolve adder [] #()) #()) in
    do:  ("doub" <-[go.FunctionType (go.Signature [go.uint64] false [go.uint64])] "$r0");;;
    (let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, (![go.uint64] "i") <⟨go.uint64⟩ #(W64 10)); (λ: <>, do:  ("i" <-[go.uint64] ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 1)))) := λ: <>,
      do:  (let: "$a0" := (![go.uint64] "i") in
      (![go.FunctionType (go.Signature [go.uint64] false [go.uint64])] "pos") "$a0");;;
      do:  (let: "$a0" := (#(W64 2) *⟨go.uint64⟩ (![go.uint64] "i")) in
      (![go.FunctionType (go.Signature [go.uint64] false [go.uint64])] "doub") "$a0")));;;
    (if: ((let: "$a0" := #(W64 0) in
    (![go.FunctionType (go.Signature [go.uint64] false [go.uint64])] "pos") "$a0") =⟨go.uint64⟩ #(W64 45)) && ((let: "$a0" := #(W64 0) in
    (![go.FunctionType (go.Signature [go.uint64] false [go.uint64])] "doub") "$a0") =⟨go.uint64⟩ #(W64 90))
    then return: (#true)
    else do:  #());;;
    return: (#false)).

Definition testCompareAll : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testCompareAll"%go.

(* go: comparisons.go:3:6 *)
Definition testCompareAllⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "nok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #false in
    do:  ("nok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && #true) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && #false) in
    do:  ("nok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && #true) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && #true) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && #false) in
    do:  ("nok" <-[go.bool] "$r0");;;
    (if: ![go.bool] "nok"
    then return: (#false)
    else do:  #());;;
    return: (![go.bool] "ok")).

Definition testCompareGT : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testCompareGT"%go.

(* go: comparisons.go:20:6 *)
Definition testCompareGTⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 4) in
    do:  ("x" <-[go.uint64] "$r0");;;
    let: "y" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 5) in
    do:  ("y" <-[go.uint64] "$r0");;;
    let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] "y") >⟨go.uint64⟩ #(W64 4))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] "y") >⟨go.uint64⟩ (![go.uint64] "x"))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    return: (![go.bool] "ok")).

Definition testCompareGE : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testCompareGE"%go.

(* go: comparisons.go:31:6 *)
Definition testCompareGEⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 4) in
    do:  ("x" <-[go.uint64] "$r0");;;
    let: "y" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 5) in
    do:  ("y" <-[go.uint64] "$r0");;;
    let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] "y") ≥⟨go.uint64⟩ #(W64 4))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] "y") ≥⟨go.uint64⟩ #(W64 5))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] "y") ≥⟨go.uint64⟩ (![go.uint64] "x"))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    (if: (![go.uint64] "y") >⟨go.uint64⟩ #(W64 5)
    then return: (#false)
    else do:  #());;;
    return: (![go.bool] "ok")).

Definition testCompareLT : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testCompareLT"%go.

(* go: comparisons.go:47:6 *)
Definition testCompareLTⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 4) in
    do:  ("x" <-[go.uint64] "$r0");;;
    let: "y" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 5) in
    do:  ("y" <-[go.uint64] "$r0");;;
    let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] "y") <⟨go.uint64⟩ #(W64 6))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] "x") <⟨go.uint64⟩ (![go.uint64] "y"))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    return: (![go.bool] "ok")).

Definition testCompareLE : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testCompareLE"%go.

(* go: comparisons.go:58:6 *)
Definition testCompareLEⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 4) in
    do:  ("x" <-[go.uint64] "$r0");;;
    let: "y" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 5) in
    do:  ("y" <-[go.uint64] "$r0");;;
    let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] "y") ≤⟨go.uint64⟩ #(W64 6))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] "y") ≤⟨go.uint64⟩ #(W64 5))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] "x") ≤⟨go.uint64⟩ (![go.uint64] "y"))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    (if: (![go.uint64] "y") <⟨go.uint64⟩ #(W64 5)
    then return: (#false)
    else do:  #());;;
    return: (![go.bool] "ok")).

Definition literalCast : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.literalCast"%go.

(* go: conversions.go:5:6 *)
Definition literalCastⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 2) in
    do:  ("x" <-[go.uint64] "$r0");;;
    return: ((![go.uint64] "x") +⟨go.uint64⟩ #(W64 2))).

Definition stringToByteSlice : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.stringToByteSlice"%go.

(* go: conversions.go:11:6 *)
Definition stringToByteSliceⁱᵐᵖˡ : val :=
  λ: "s",
    exception_do (let: "s" := (GoAlloc go.string "s") in
    let: "p" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (string.to_bytes (![go.string] "s")) in
    do:  ("p" <-[go.SliceType go.byte] "$r0");;;
    return: (![go.SliceType go.byte] "p")).

Definition byteSliceToString : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.byteSliceToString"%go.

(* go: conversions.go:17:6 *)
Definition byteSliceToStringⁱᵐᵖˡ : val :=
  λ: "p",
    exception_do (let: "p" := (GoAlloc (go.SliceType go.byte) "p") in
    return: (string.from_bytes (![go.SliceType go.byte] "p"))).

Definition testByteSliceToString : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testByteSliceToString"%go.

(* tests

   go: conversions.go:23:6 *)
Definition testByteSliceToStringⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 3)) in
    do:  ("x" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := #(W8 65) in
    do:  ((IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "x", #(W64 0))) <-[go.byte] "$r0");;;
    let: "$r0" := #(W8 66) in
    do:  ((IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "x", #(W64 1))) <-[go.byte] "$r0");;;
    let: "$r0" := #(W8 67) in
    do:  ((IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "x", #(W64 2))) <-[go.byte] "$r0");;;
    return: ((let: "$a0" := (![go.SliceType go.byte] "x") in
     (FuncResolve byteSliceToString [] #()) "$a0") =⟨go.string⟩ #"ABC"%go)).

Definition testCopySimple : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testCopySimple"%go.

(* go: copy.go:3:6 *)
Definition testCopySimpleⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 10)) in
    do:  ("x" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := #(W8 1) in
    do:  ((IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "x", #(W64 3))) <-[go.byte] "$r0");;;
    let: "y" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 10)) in
    do:  ("y" <-[go.SliceType go.byte] "$r0");;;
    do:  (let: "$a0" := (![go.SliceType go.byte] "y") in
    let: "$a1" := (![go.SliceType go.byte] "x") in
    (FuncResolve go.copy [go.SliceType go.byte] #()) "$a0" "$a1");;;
    return: ((![go.byte] (IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "y", #(W64 3)))) =⟨go.byte⟩ #(W8 1))).

Definition testCopyShorterDst : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testCopyShorterDst"%go.

(* go: copy.go:11:6 *)
Definition testCopyShorterDstⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 15)) in
    do:  ("x" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := #(W8 1) in
    do:  ((IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "x", #(W64 3))) <-[go.byte] "$r0");;;
    let: "$r0" := #(W8 2) in
    do:  ((IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "x", #(W64 12))) <-[go.byte] "$r0");;;
    let: "y" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 10)) in
    do:  ("y" <-[go.SliceType go.byte] "$r0");;;
    let: "n" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (s_to_w64 (let: "$a0" := (![go.SliceType go.byte] "y") in
    let: "$a1" := (![go.SliceType go.byte] "x") in
    (FuncResolve go.copy [go.SliceType go.byte] #()) "$a0" "$a1")) in
    do:  ("n" <-[go.uint64] "$r0");;;
    return: (((![go.uint64] "n") =⟨go.uint64⟩ #(W64 10)) && ((![go.byte] (IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "y", #(W64 3)))) =⟨go.byte⟩ #(W8 1)))).

Definition testCopyShorterSrc : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testCopyShorterSrc"%go.

(* go: copy.go:20:6 *)
Definition testCopyShorterSrcⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 10)) in
    do:  ("x" <-[go.SliceType go.byte] "$r0");;;
    let: "y" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 15)) in
    do:  ("y" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := #(W8 1) in
    do:  ((IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "x", #(W64 3))) <-[go.byte] "$r0");;;
    let: "$r0" := #(W8 2) in
    do:  ((IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "y", #(W64 12))) <-[go.byte] "$r0");;;
    let: "n" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (s_to_w64 (let: "$a0" := (![go.SliceType go.byte] "y") in
    let: "$a1" := (![go.SliceType go.byte] "x") in
    (FuncResolve go.copy [go.SliceType go.byte] #()) "$a0" "$a1")) in
    do:  ("n" <-[go.uint64] "$r0");;;
    return: ((((![go.uint64] "n") =⟨go.uint64⟩ #(W64 10)) && ((![go.byte] (IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "y", #(W64 3)))) =⟨go.byte⟩ #(W8 1))) && ((![go.byte] (IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "y", #(W64 12)))) =⟨go.byte⟩ #(W8 2)))).

Definition deferSimple : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.deferSimple"%go.

(* go: defer.go:3:6 *)
Definition deferSimpleⁱᵐᵖˡ : val :=
  λ: <>,
    with_defer: (let: "x" := (GoAlloc (go.PointerType go.uint64) (GoZeroVal (go.PointerType go.uint64) #())) in
    let: "$r0" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    do:  ("x" <-[go.PointerType go.uint64] "$r0");;;
    (let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, (![go.uint64] "i") <⟨go.uint64⟩ #(W64 10)); (λ: <>, do:  ("i" <-[go.uint64] ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 1)))) := λ: <>,
      do:  (let: "$f" := (λ: <>,
        exception_do (do:  ((![go.PointerType go.uint64] "x") <-[go.uint64] ((![go.uint64] (![go.PointerType go.uint64] "x")) +⟨go.uint64⟩ #(W64 1)));;;
        return: #())
        ) in
      "$defer" <-[deferType] (let: "$oldf" := (![deferType] "$defer") in
      (λ: <>,
        "$f" #();;
        "$oldf" #()
        )))));;;
    return: (![go.PointerType go.uint64] "x")).

Definition testDefer : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testDefer"%go.

(* go: defer.go:13:6 *)
Definition testDeferⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: ((![go.uint64] ((FuncResolve deferSimple [] #()) #())) =⟨go.uint64⟩ #(W64 10))).

Definition testDeferFuncLit : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testDeferFuncLit"%go.

(* go: defer.go:17:6 *)
Definition testDeferFuncLitⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := #(W64 10) in
    do:  ("x" <-[go.int] "$r0");;;
    let: "f" := (GoAlloc (go.FunctionType (go.Signature [] false [])) (GoZeroVal (go.FunctionType (go.Signature [] false [])) #())) in
    let: "$r0" := (λ: <>,
      with_defer: (do:  (let: "$f" := (λ: <>,
        exception_do (do:  ("x" <-[go.int] ((![go.int] "x") +⟨go.int⟩ #(W64 1)));;;
        return: #())
        ) in
      "$defer" <-[deferType] (let: "$oldf" := (![deferType] "$defer") in
      (λ: <>,
        "$f" #();;
        "$oldf" #()
        )));;;
      return: #())
      ) in
    do:  ("f" <-[go.FunctionType (go.Signature [] false [])] "$r0");;;
    do:  ((![go.FunctionType (go.Signature [] false [])] "f") #());;;
    return: ((![go.int] "x") =⟨go.int⟩ #(W64 11))).

Definition Encⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "p"%go (go.SliceType go.byte))
].

Definition Enc : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/semantics.Enc"%go [].

(* go: encoding.go:10:15 *)
Definition Enc__consumeⁱᵐᵖˡ : val :=
  λ: "e" "n",
    exception_do (let: "e" := (GoAlloc (go.PointerType Enc) "e") in
    let: "n" := (GoAlloc go.uint64 "n") in
    let: "b" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (let: "$s" := (![go.SliceType go.byte] (StructFieldRef Enc "p"%go (![go.PointerType Enc] "e"))) in
    Slice (go.SliceType go.byte) ("$s", #(W64 0), ![go.uint64] "n")) in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$s" := (![go.SliceType go.byte] (StructFieldRef Enc "p"%go (![go.PointerType Enc] "e"))) in
    Slice (go.SliceType go.byte) ("$s", ![go.uint64] "n", FuncResolve go.len [go.SliceType go.byte] #() (![go.SliceType go.byte] (StructFieldRef Enc "p"%go (![go.PointerType Enc] "e"))))) in
    do:  ((StructFieldRef Enc "p"%go (![go.PointerType Enc] "e")) <-[go.SliceType go.byte] "$r0");;;
    return: (![go.SliceType go.byte] "b")).

Definition Decⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "p"%go (go.SliceType go.byte))
].

Definition Dec : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/semantics.Dec"%go [].

(* go: encoding.go:20:15 *)
Definition Dec__consumeⁱᵐᵖˡ : val :=
  λ: "d" "n",
    exception_do (let: "d" := (GoAlloc (go.PointerType Dec) "d") in
    let: "n" := (GoAlloc go.uint64 "n") in
    let: "b" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (let: "$s" := (![go.SliceType go.byte] (StructFieldRef Dec "p"%go (![go.PointerType Dec] "d"))) in
    Slice (go.SliceType go.byte) ("$s", #(W64 0), ![go.uint64] "n")) in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$s" := (![go.SliceType go.byte] (StructFieldRef Dec "p"%go (![go.PointerType Dec] "d"))) in
    Slice (go.SliceType go.byte) ("$s", ![go.uint64] "n", FuncResolve go.len [go.SliceType go.byte] #() (![go.SliceType go.byte] (StructFieldRef Dec "p"%go (![go.PointerType Dec] "d"))))) in
    do:  ((StructFieldRef Dec "p"%go (![go.PointerType Dec] "d")) <-[go.SliceType go.byte] "$r0");;;
    return: (![go.SliceType go.byte] "b")).

Definition roundtripEncDec32 : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.roundtripEncDec32"%go.

(* go: encoding.go:26:6 *)
Definition roundtripEncDec32ⁱᵐᵖˡ : val :=
  λ: "x",
    exception_do (let: "x" := (GoAlloc go.uint32 "x") in
    let: "r" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 4)) in
    do:  ("r" <-[go.SliceType go.byte] "$r0");;;
    let: "e" := (GoAlloc (go.PointerType Enc) (GoZeroVal (go.PointerType Enc) #())) in
    let: "$r0" := (GoAlloc Enc (CompositeLiteral Enc (LiteralValue [KeyedElement (Some (KeyField "p"%go)) (ElementExpression (![go.SliceType go.byte] "r"))]))) in
    do:  ("e" <-[go.PointerType Enc] "$r0");;;
    let: "d" := (GoAlloc (go.PointerType Dec) (GoZeroVal (go.PointerType Dec) #())) in
    let: "$r0" := (GoAlloc Dec (CompositeLiteral Dec (LiteralValue [KeyedElement (Some (KeyField "p"%go)) (ElementExpression (![go.SliceType go.byte] "r"))]))) in
    do:  ("d" <-[go.PointerType Dec] "$r0");;;
    do:  (let: "$a0" := (let: "$a0" := #(W64 4) in
    (MethodResolve (go.PointerType Enc) "consume"%go #() (![go.PointerType Enc] "e")) "$a0") in
    let: "$a1" := (![go.uint32] "x") in
    (FuncResolve primitive.UInt32Put [] #()) "$a0" "$a1");;;
    return: (let: "$a0" := (let: "$a0" := #(W64 4) in
     (MethodResolve (go.PointerType Dec) "consume"%go #() (![go.PointerType Dec] "d")) "$a0") in
     (FuncResolve primitive.UInt32Get [] #()) "$a0")).

Definition roundtripEncDec64 : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.roundtripEncDec64"%go.

(* go: encoding.go:34:6 *)
Definition roundtripEncDec64ⁱᵐᵖˡ : val :=
  λ: "x",
    exception_do (let: "x" := (GoAlloc go.uint64 "x") in
    let: "r" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 8)) in
    do:  ("r" <-[go.SliceType go.byte] "$r0");;;
    let: "e" := (GoAlloc (go.PointerType Enc) (GoZeroVal (go.PointerType Enc) #())) in
    let: "$r0" := (GoAlloc Enc (CompositeLiteral Enc (LiteralValue [KeyedElement (Some (KeyField "p"%go)) (ElementExpression (![go.SliceType go.byte] "r"))]))) in
    do:  ("e" <-[go.PointerType Enc] "$r0");;;
    let: "d" := (GoAlloc (go.PointerType Dec) (GoZeroVal (go.PointerType Dec) #())) in
    let: "$r0" := (GoAlloc Dec (CompositeLiteral Dec (LiteralValue [KeyedElement (Some (KeyField "p"%go)) (ElementExpression (![go.SliceType go.byte] "r"))]))) in
    do:  ("d" <-[go.PointerType Dec] "$r0");;;
    do:  (let: "$a0" := (let: "$a0" := #(W64 8) in
    (MethodResolve (go.PointerType Enc) "consume"%go #() (![go.PointerType Enc] "e")) "$a0") in
    let: "$a1" := (![go.uint64] "x") in
    (FuncResolve primitive.UInt64Put [] #()) "$a0" "$a1");;;
    return: (let: "$a0" := (let: "$a0" := #(W64 8) in
     (MethodResolve (go.PointerType Dec) "consume"%go #() (![go.PointerType Dec] "d")) "$a0") in
     (FuncResolve primitive.UInt64Get [] #()) "$a0")).

Definition testEncDec32Simple : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testEncDec32Simple"%go.

(* tests

   go: encoding.go:43:6 *)
Definition testEncDec32Simpleⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W32 0) in
    (FuncResolve roundtripEncDec32 [] #()) "$a0") =⟨go.uint32⟩ #(W32 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W32 1) in
    (FuncResolve roundtripEncDec32 [] #()) "$a0") =⟨go.uint32⟩ #(W32 1))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W32 1231234) in
    (FuncResolve roundtripEncDec32 [] #()) "$a0") =⟨go.uint32⟩ #(W32 1231234))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    return: (![go.bool] "ok")).

Definition failing_testEncDec32 : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.failing_testEncDec32"%go.

(* go: encoding.go:51:6 *)
Definition failing_testEncDec32ⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W32 3434807466) in
    (FuncResolve roundtripEncDec32 [] #()) "$a0") =⟨go.uint32⟩ #(W32 3434807466))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W32 1048576) in
    (FuncResolve roundtripEncDec32 [] #()) "$a0") =⟨go.uint32⟩ #(W32 1048576))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W32 262144) in
    (FuncResolve roundtripEncDec32 [] #()) "$a0") =⟨go.uint32⟩ #(W32 262144))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W32 1024) in
    (FuncResolve roundtripEncDec32 [] #()) "$a0") =⟨go.uint32⟩ #(W32 1024))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W32 1) in
    (FuncResolve roundtripEncDec32 [] #()) "$a0") =⟨go.uint32⟩ #(W32 1))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W32 4294967295) in
    (FuncResolve roundtripEncDec32 [] #()) "$a0") =⟨go.uint32⟩ #(W32 4294967295))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    return: (![go.bool] "ok")).

Definition testEncDec64Simple : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testEncDec64Simple"%go.

(* go: encoding.go:62:6 *)
Definition testEncDec64Simpleⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W64 0) in
    (FuncResolve roundtripEncDec64 [] #()) "$a0") =⟨go.uint64⟩ #(W64 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W64 1) in
    (FuncResolve roundtripEncDec64 [] #()) "$a0") =⟨go.uint64⟩ #(W64 1))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W64 1231234) in
    (FuncResolve roundtripEncDec64 [] #()) "$a0") =⟨go.uint64⟩ #(W64 1231234))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    return: (![go.bool] "ok")).

Definition testEncDec64 : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testEncDec64"%go.

(* go: encoding.go:70:6 *)
Definition testEncDec64ⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W64 62206846038638762) in
    (FuncResolve roundtripEncDec64 [] #()) "$a0") =⟨go.uint64⟩ #(W64 62206846038638762))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W64 9223372036854775808) in
    (FuncResolve roundtripEncDec64 [] #()) "$a0") =⟨go.uint64⟩ #(W64 9223372036854775808))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W64 140737488355328) in
    (FuncResolve roundtripEncDec64 [] #()) "$a0") =⟨go.uint64⟩ #(W64 140737488355328))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W64 1048576) in
    (FuncResolve roundtripEncDec64 [] #()) "$a0") =⟨go.uint64⟩ #(W64 1048576))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W64 262144) in
    (FuncResolve roundtripEncDec64 [] #()) "$a0") =⟨go.uint64⟩ #(W64 262144))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W64 1024) in
    (FuncResolve roundtripEncDec64 [] #()) "$a0") =⟨go.uint64⟩ #(W64 1024))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W64 1) in
    (FuncResolve roundtripEncDec64 [] #()) "$a0") =⟨go.uint64⟩ #(W64 1))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W64 18446744073709551615) in
    (FuncResolve roundtripEncDec64 [] #()) "$a0") =⟨go.uint64⟩ #(W64 18446744073709551615))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    return: (![go.bool] "ok")).

Definition FirstClassFunction : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.FirstClassFunction"%go.

(* go: first_class_function.go:3:6 *)
Definition FirstClassFunctionⁱᵐᵖˡ : val :=
  λ: "a",
    exception_do (let: "a" := (GoAlloc go.uint64 "a") in
    return: ((![go.uint64] "a") +⟨go.uint64⟩ #(W64 10))).

Definition ApplyF : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.ApplyF"%go.

(* go: first_class_function.go:7:6 *)
Definition ApplyFⁱᵐᵖˡ : val :=
  λ: "a" "f",
    exception_do (let: "f" := (GoAlloc (go.FunctionType (go.Signature [go.uint64] false [go.uint64])) "f") in
    let: "a" := (GoAlloc go.uint64 "a") in
    return: (let: "$a0" := (![go.uint64] "a") in
     (![go.FunctionType (go.Signature [go.uint64] false [go.uint64])] "f") "$a0")).

Definition testFirstClassFunction : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testFirstClassFunction"%go.

(* go: first_class_function.go:11:6 *)
Definition testFirstClassFunctionⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: ((let: "$a0" := #(W64 1) in
     let: "$a1" := (FuncResolve FirstClassFunction [] #()) in
     (FuncResolve ApplyF [] #()) "$a0" "$a1") =⟨go.uint64⟩ #(W64 11))).

Definition Editorⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "s"%go (go.SliceType go.uint64));
  (go.FieldDecl "next_val"%go go.uint64)
].

Definition Editor : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/semantics.Editor"%go [].

(* advances the array editor, and returns the value it wrote, storing
   "next" in next_val

   go: function_ordering.go:11:18 *)
Definition Editor__AdvanceReturnⁱᵐᵖˡ : val :=
  λ: "e" "next",
    exception_do (let: "e" := (GoAlloc (go.PointerType Editor) "e") in
    let: "next" := (GoAlloc go.uint64 "next") in
    let: "tmp" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (![go.uint64] (StructFieldRef Editor "next_val"%go (![go.PointerType Editor] "e"))) in
    do:  ("tmp" <-[go.uint64] "$r0");;;
    let: "$r0" := (![go.uint64] "tmp") in
    do:  ((IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] (StructFieldRef Editor "s"%go (![go.PointerType Editor] "e")), #(W64 0))) <-[go.uint64] "$r0");;;
    let: "$r0" := (![go.uint64] "next") in
    do:  ((StructFieldRef Editor "next_val"%go (![go.PointerType Editor] "e")) <-[go.uint64] "$r0");;;
    let: "$r0" := (let: "$s" := (![go.SliceType go.uint64] (StructFieldRef Editor "s"%go (![go.PointerType Editor] "e"))) in
    Slice (go.SliceType go.uint64) ("$s", #(W64 1), FuncResolve go.len [go.SliceType go.uint64] #() (![go.SliceType go.uint64] (StructFieldRef Editor "s"%go (![go.PointerType Editor] "e"))))) in
    do:  ((StructFieldRef Editor "s"%go (![go.PointerType Editor] "e")) <-[go.SliceType go.uint64] "$r0");;;
    return: (![go.uint64] "tmp")).

Definition addFour64 : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.addFour64"%go.

(* we call this function with side-effectful function calls as arguments,
   its implementation is unimportant

   go: function_ordering.go:21:6 *)
Definition addFour64ⁱᵐᵖˡ : val :=
  λ: "a" "b" "c" "d",
    exception_do (let: "d" := (GoAlloc go.uint64 "d") in
    let: "c" := (GoAlloc go.uint64 "c") in
    let: "b" := (GoAlloc go.uint64 "b") in
    let: "a" := (GoAlloc go.uint64 "a") in
    return: ((((![go.uint64] "a") +⟨go.uint64⟩ (![go.uint64] "b")) +⟨go.uint64⟩ (![go.uint64] "c")) +⟨go.uint64⟩ (![go.uint64] "d"))).

Definition Pairⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "x"%go go.uint64);
  (go.FieldDecl "y"%go go.uint64)
].

Definition failing_testFunctionOrdering : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.failing_testFunctionOrdering"%go.

Definition Pair : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/semantics.Pair"%go [].

(* tests

   go: function_ordering.go:31:6 *)
Definition failing_testFunctionOrderingⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "arr" := (GoAlloc (go.SliceType go.uint64) (GoZeroVal (go.SliceType go.uint64) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType go.uint64] #()) #(W64 5)) in
    do:  ("arr" <-[go.SliceType go.uint64] "$r0");;;
    let: "e1" := (GoAlloc Editor (GoZeroVal Editor #())) in
    let: "$r0" := (CompositeLiteral Editor (LiteralValue [KeyedElement (Some (KeyField "s"%go)) (ElementExpression (let: "$s" := (![go.SliceType go.uint64] "arr") in
     Slice (go.SliceType go.uint64) ("$s", #(W64 0), FuncResolve go.len [go.SliceType go.uint64] #() (![go.SliceType go.uint64] "arr")))); KeyedElement (Some (KeyField "next_val"%go)) (ElementExpression #(W64 1))])) in
    do:  ("e1" <-[Editor] "$r0");;;
    let: "e2" := (GoAlloc Editor (GoZeroVal Editor #())) in
    let: "$r0" := (CompositeLiteral Editor (LiteralValue [KeyedElement (Some (KeyField "s"%go)) (ElementExpression (let: "$s" := (![go.SliceType go.uint64] "arr") in
     Slice (go.SliceType go.uint64) ("$s", #(W64 0), FuncResolve go.len [go.SliceType go.uint64] #() (![go.SliceType go.uint64] "arr")))); KeyedElement (Some (KeyField "next_val"%go)) (ElementExpression #(W64 101))])) in
    do:  ("e2" <-[Editor] "$r0");;;
    (if: ((let: "$a0" := #(W64 2) in
    (MethodResolve (go.PointerType Editor) "AdvanceReturn"%go #() "e1") "$a0") +⟨go.uint64⟩ (let: "$a0" := #(W64 102) in
    (MethodResolve (go.PointerType Editor) "AdvanceReturn"%go #() "e2") "$a0")) ≠⟨go.uint64⟩ #(W64 102)
    then return: (#false)
    else do:  #());;;
    (if: (![go.uint64] (IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "arr", #(W64 0)))) ≠⟨go.uint64⟩ #(W64 101)
    then return: (#false)
    else do:  #());;;
    (if: (let: "$a0" := (let: "$a0" := #(W64 3) in
    (MethodResolve (go.PointerType Editor) "AdvanceReturn"%go #() "e1") "$a0") in
    let: "$a1" := (let: "$a0" := #(W64 103) in
    (MethodResolve (go.PointerType Editor) "AdvanceReturn"%go #() "e2") "$a0") in
    let: "$a2" := (let: "$a0" := #(W64 104) in
    (MethodResolve (go.PointerType Editor) "AdvanceReturn"%go #() "e2") "$a0") in
    let: "$a3" := (let: "$a0" := #(W64 4) in
    (MethodResolve (go.PointerType Editor) "AdvanceReturn"%go #() "e1") "$a0") in
    (FuncResolve addFour64 [] #()) "$a0" "$a1" "$a2" "$a3") ≠⟨go.uint64⟩ #(W64 210)
    then return: (#false)
    else do:  #());;;
    (if: (![go.uint64] (IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "arr", #(W64 1)))) ≠⟨go.uint64⟩ #(W64 102)
    then return: (#false)
    else do:  #());;;
    (if: (![go.uint64] (IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "arr", #(W64 2)))) ≠⟨go.uint64⟩ #(W64 3)
    then return: (#false)
    else do:  #());;;
    let: "p" := (GoAlloc Pair (GoZeroVal Pair #())) in
    let: "$r0" := (CompositeLiteral Pair (LiteralValue [KeyedElement (Some (KeyField "x"%go)) (ElementExpression (let: "$a0" := #(W64 5) in
     (MethodResolve (go.PointerType Editor) "AdvanceReturn"%go #() "e1") "$a0")); KeyedElement (Some (KeyField "y"%go)) (ElementExpression (let: "$a0" := #(W64 105) in
     (MethodResolve (go.PointerType Editor) "AdvanceReturn"%go #() "e2") "$a0"))])) in
    do:  ("p" <-[Pair] "$r0");;;
    (if: (![go.uint64] (IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "arr", #(W64 3)))) ≠⟨go.uint64⟩ #(W64 104)
    then return: (#false)
    else do:  #());;;
    let: "q" := (GoAlloc Pair (GoZeroVal Pair #())) in
    let: "$r0" := (CompositeLiteral Pair (LiteralValue [KeyedElement (Some (KeyField "y"%go)) (ElementExpression (let: "$a0" := #(W64 6) in
     (MethodResolve (go.PointerType Editor) "AdvanceReturn"%go #() "e1") "$a0")); KeyedElement (Some (KeyField "x"%go)) (ElementExpression (let: "$a0" := #(W64 106) in
     (MethodResolve (go.PointerType Editor) "AdvanceReturn"%go #() "e2") "$a0"))])) in
    do:  ("q" <-[Pair] "$r0");;;
    (if: (![go.uint64] (IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "arr", #(W64 4)))) ≠⟨go.uint64⟩ #(W64 105)
    then return: (#false)
    else do:  #());;;
    return: (((![go.uint64] (StructFieldRef Pair "x"%go "p")) +⟨go.uint64⟩ (![go.uint64] (StructFieldRef Pair "x"%go "q"))) =⟨go.uint64⟩ #(W64 109))).

Definition storeAndReturn : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.storeAndReturn"%go.

(* go: function_ordering.go:74:6 *)
Definition storeAndReturnⁱᵐᵖˡ : val :=
  λ: "x" "v",
    exception_do (let: "v" := (GoAlloc go.uint64 "v") in
    let: "x" := (GoAlloc (go.PointerType go.uint64) "x") in
    let: "$r0" := (![go.uint64] "v") in
    do:  ((![go.PointerType go.uint64] "x") <-[go.uint64] "$r0");;;
    return: (![go.uint64] "v")).

Definition failing_testArgumentOrder : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.failing_testArgumentOrder"%go.

(* Goose has a right-to-left evaluation order for function arguments,
   which is incorrect.

   go: function_ordering.go:81:6 *)
Definition failing_testArgumentOrderⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("x" <-[go.uint64] "$r0");;;
    do:  (let: "$a0" := (let: "$a0" := "x" in
    let: "$a1" := #(W64 1) in
    (FuncResolve storeAndReturn [] #()) "$a0" "$a1") in
    let: "$a1" := (let: "$a0" := "x" in
    let: "$a1" := #(W64 2) in
    (FuncResolve storeAndReturn [] #()) "$a0" "$a1") in
    let: "$a2" := (let: "$a0" := "x" in
    let: "$a1" := #(W64 3) in
    (FuncResolve storeAndReturn [] #()) "$a0" "$a1") in
    let: "$a3" := (let: "$a0" := "x" in
    let: "$a1" := #(W64 4) in
    (FuncResolve storeAndReturn [] #()) "$a0" "$a1") in
    (FuncResolve addFour64 [] #()) "$a0" "$a1" "$a2" "$a3");;;
    let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := ((![go.uint64] "x") =⟨go.uint64⟩ #(W64 4)) in
    do:  ("ok" <-[go.bool] "$r0");;;
    return: (![go.bool] "ok")).

Definition testU64ToU32 : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testU64ToU32"%go.

(* go: int_conversions.go:3:6 *)
Definition testU64ToU32ⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "x" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 1230) in
    do:  ("x" <-[go.uint64] "$r0");;;
    let: "y" := (GoAlloc go.uint32 (GoZeroVal go.uint32 #())) in
    let: "$r0" := #(W32 1230) in
    do:  ("y" <-[go.uint32] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((u_to_w32 (![go.uint64] "x")) =⟨go.uint32⟩ (![go.uint32] "y"))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((u_to_w64 (![go.uint32] "y")) =⟨go.uint64⟩ (![go.uint64] "x"))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    return: (![go.bool] "ok")).

Definition testU32Len : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testU32Len"%go.

(* go: int_conversions.go:12:6 *)
Definition testU32Lenⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "s" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 100)) in
    do:  ("s" <-[go.SliceType go.byte] "$r0");;;
    return: ((s_to_w32 (let: "$a0" := (![go.SliceType go.byte] "s") in
     (FuncResolve go.len [go.SliceType go.byte] #()) "$a0")) =⟨go.uint32⟩ #(W32 100))).

Definition Uint32ⁱᵐᵖˡ : go.type := go.uint32.

Definition failing_testU32NewtypeLen : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.failing_testU32NewtypeLen"%go.

(* https://github.com/goose-lang/goose/issues/14

   go: int_conversions.go:20:6 *)
Definition failing_testU32NewtypeLenⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "s" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 20)) in
    do:  ("s" <-[go.SliceType go.byte] "$r0");;;
    return: ((s_to_w32 (let: "$a0" := (![go.SliceType go.byte] "s") in
     (FuncResolve go.len [go.SliceType go.byte] #()) "$a0")) =⟨go.uint32⟩ #(W32 20))).

Definition geometryInterfaceⁱᵐᵖˡ : go.type := go.InterfaceType [go.MethodElem #"Square"%go (go.Signature [] false [go.uint64]); go.MethodElem #"Volume"%go (go.Signature [] false [go.uint64])].

Definition measureArea : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.measureArea"%go.

Definition geometryInterface : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/semantics.geometryInterface"%go [].

(* go: interfaces.go:12:6 *)
Definition measureAreaⁱᵐᵖˡ : val :=
  λ: "t",
    exception_do (let: "t" := (GoAlloc geometryInterface "t") in
    return: ((MethodResolve geometryInterface "Square"%go #() (![geometryInterface] "t")) #())).

Definition measureVolumePlusNM : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.measureVolumePlusNM"%go.

(* go: interfaces.go:16:6 *)
Definition measureVolumePlusNMⁱᵐᵖˡ : val :=
  λ: "t" "n" "m",
    exception_do (let: "m" := (GoAlloc go.uint64 "m") in
    let: "n" := (GoAlloc go.uint64 "n") in
    let: "t" := (GoAlloc geometryInterface "t") in
    return: ((((MethodResolve geometryInterface "Volume"%go #() (![geometryInterface] "t")) #()) +⟨go.uint64⟩ (![go.uint64] "n")) +⟨go.uint64⟩ (![go.uint64] "m"))).

Definition measureVolume : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.measureVolume"%go.

(* go: interfaces.go:20:6 *)
Definition measureVolumeⁱᵐᵖˡ : val :=
  λ: "t",
    exception_do (let: "t" := (GoAlloc geometryInterface "t") in
    return: ((MethodResolve geometryInterface "Volume"%go #() (![geometryInterface] "t")) #())).

Definition SquareStructⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "Side"%go go.uint64)
].

Definition SquareStruct : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/semantics.SquareStruct"%go [].

(* go: interfaces.go:28:23 *)
Definition SquareStruct__Squareⁱᵐᵖˡ : val :=
  λ: "t" <>,
    exception_do (let: "t" := (GoAlloc SquareStruct "t") in
    return: ((![go.uint64] (StructFieldRef SquareStruct "Side"%go "t")) *⟨go.uint64⟩ (![go.uint64] (StructFieldRef SquareStruct "Side"%go "t")))).

(* go: interfaces.go:32:23 *)
Definition SquareStruct__Volumeⁱᵐᵖˡ : val :=
  λ: "t" <>,
    exception_do (let: "t" := (GoAlloc SquareStruct "t") in
    return: (((![go.uint64] (StructFieldRef SquareStruct "Side"%go "t")) *⟨go.uint64⟩ (![go.uint64] (StructFieldRef SquareStruct "Side"%go "t"))) *⟨go.uint64⟩ (![go.uint64] (StructFieldRef SquareStruct "Side"%go "t")))).

Definition testBasicInterface : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testBasicInterface"%go.

(* go: interfaces.go:40:6 *)
Definition testBasicInterfaceⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "s" := (GoAlloc SquareStruct (GoZeroVal SquareStruct #())) in
    let: "$r0" := (CompositeLiteral SquareStruct (LiteralValue [KeyedElement (Some (KeyField "Side"%go)) (ElementExpression #(W64 2))])) in
    do:  ("s" <-[SquareStruct] "$r0");;;
    return: ((let: "$a0" := (InterfaceMake SquareStruct (![SquareStruct] "s")) in
     (FuncResolve measureArea [] #()) "$a0") =⟨go.uint64⟩ #(W64 4))).

Definition testAssignInterface : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testAssignInterface"%go.

(* go: interfaces.go:47:6 *)
Definition testAssignInterfaceⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "s" := (GoAlloc SquareStruct (GoZeroVal SquareStruct #())) in
    let: "$r0" := (CompositeLiteral SquareStruct (LiteralValue [KeyedElement (Some (KeyField "Side"%go)) (ElementExpression #(W64 3))])) in
    do:  ("s" <-[SquareStruct] "$r0");;;
    let: "area" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (let: "$a0" := (InterfaceMake SquareStruct (![SquareStruct] "s")) in
    (FuncResolve measureArea [] #()) "$a0") in
    do:  ("area" <-[go.uint64] "$r0");;;
    return: ((![go.uint64] "area") =⟨go.uint64⟩ #(W64 9))).

Definition testMultipleInterface : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testMultipleInterface"%go.

(* go: interfaces.go:55:6 *)
Definition testMultipleInterfaceⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "s" := (GoAlloc SquareStruct (GoZeroVal SquareStruct #())) in
    let: "$r0" := (CompositeLiteral SquareStruct (LiteralValue [KeyedElement (Some (KeyField "Side"%go)) (ElementExpression #(W64 3))])) in
    do:  ("s" <-[SquareStruct] "$r0");;;
    let: "square1" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (let: "$a0" := (InterfaceMake SquareStruct (![SquareStruct] "s")) in
    (FuncResolve measureArea [] #()) "$a0") in
    do:  ("square1" <-[go.uint64] "$r0");;;
    let: "square2" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (let: "$a0" := (InterfaceMake SquareStruct (![SquareStruct] "s")) in
    (FuncResolve measureArea [] #()) "$a0") in
    do:  ("square2" <-[go.uint64] "$r0");;;
    return: ((![go.uint64] "square1") =⟨go.uint64⟩ (![go.uint64] "square2"))).

Definition testBinaryExprInterface : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testBinaryExprInterface"%go.

(* go: interfaces.go:64:6 *)
Definition testBinaryExprInterfaceⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "s" := (GoAlloc SquareStruct (GoZeroVal SquareStruct #())) in
    let: "$r0" := (CompositeLiteral SquareStruct (LiteralValue [KeyedElement (Some (KeyField "Side"%go)) (ElementExpression #(W64 3))])) in
    do:  ("s" <-[SquareStruct] "$r0");;;
    let: "square1" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (let: "$a0" := (InterfaceMake SquareStruct (![SquareStruct] "s")) in
    (FuncResolve measureArea [] #()) "$a0") in
    do:  ("square1" <-[go.uint64] "$r0");;;
    let: "square2" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (let: "$a0" := (InterfaceMake SquareStruct (![SquareStruct] "s")) in
    (FuncResolve measureVolume [] #()) "$a0") in
    do:  ("square2" <-[go.uint64] "$r0");;;
    return: (((![go.uint64] "square1") =⟨go.uint64⟩ (let: "$a0" := (InterfaceMake SquareStruct (![SquareStruct] "s")) in
     (FuncResolve measureArea [] #()) "$a0")) && ((![go.uint64] "square2") =⟨go.uint64⟩ (let: "$a0" := (InterfaceMake SquareStruct (![SquareStruct] "s")) in
     (FuncResolve measureVolume [] #()) "$a0")))).

Definition testIfStmtInterface : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testIfStmtInterface"%go.

(* go: interfaces.go:73:6 *)
Definition testIfStmtInterfaceⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "s" := (GoAlloc SquareStruct (GoZeroVal SquareStruct #())) in
    let: "$r0" := (CompositeLiteral SquareStruct (LiteralValue [KeyedElement (Some (KeyField "Side"%go)) (ElementExpression #(W64 3))])) in
    do:  ("s" <-[SquareStruct] "$r0");;;
    (if: (let: "$a0" := (InterfaceMake SquareStruct (![SquareStruct] "s")) in
    (FuncResolve measureArea [] #()) "$a0") =⟨go.uint64⟩ #(W64 9)
    then return: (#true)
    else do:  #());;;
    return: (#false)).

Definition testsUseLocks : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testsUseLocks"%go.

(* We can't interpret multithreaded code, so this just checks that
   locks are correctly interpreted

   go: lock.go:7:6 *)
Definition testsUseLocksⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "m" := (GoAlloc (go.PointerType sync.Mutex) (GoZeroVal (go.PointerType sync.Mutex) #())) in
    let: "$r0" := (GoAlloc sync.Mutex (GoZeroVal sync.Mutex #())) in
    do:  ("m" <-[go.PointerType sync.Mutex] "$r0");;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go #() (![go.PointerType sync.Mutex] "m")) #());;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go #() (![go.PointerType sync.Mutex] "m")) #());;;
    return: (#true)).

Definition standardForLoop : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.standardForLoop"%go.

(* helpers

   go: loops.go:4:6 *)
Definition standardForLoopⁱᵐᵖˡ : val :=
  λ: "s",
    exception_do (let: "s" := (GoAlloc (go.SliceType go.uint64) "s") in
    let: "sumPtr" := (GoAlloc (go.PointerType go.uint64) (GoZeroVal (go.PointerType go.uint64) #())) in
    let: "$r0" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    do:  ("sumPtr" <-[go.PointerType go.uint64] "$r0");;;
    (let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (if: (![go.uint64] "i") <⟨go.uint64⟩ (s_to_w64 (let: "$a0" := (![go.SliceType go.uint64] "s") in
      (FuncResolve go.len [go.SliceType go.uint64] #()) "$a0"))
      then
        let: "sum" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
        let: "$r0" := (![go.uint64] (![go.PointerType go.uint64] "sumPtr")) in
        do:  ("sum" <-[go.uint64] "$r0");;;
        let: "x" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
        let: "$r0" := (![go.uint64] (IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "s", ![go.uint64] "i"))) in
        do:  ("x" <-[go.uint64] "$r0");;;
        let: "$r0" := ((![go.uint64] "sum") +⟨go.uint64⟩ (![go.uint64] "x")) in
        do:  ((![go.PointerType go.uint64] "sumPtr") <-[go.uint64] "$r0");;;
        let: "$r0" := ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 1)) in
        do:  ("i" <-[go.uint64] "$r0");;;
        continue: #()
      else do:  #());;;
      break: #()));;;
    let: "sum" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (![go.uint64] (![go.PointerType go.uint64] "sumPtr")) in
    do:  ("sum" <-[go.uint64] "$r0");;;
    return: (![go.uint64] "sum")).

Definition LoopStructⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "loopNext"%go (go.PointerType go.uint64))
].

Definition LoopStruct : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/semantics.LoopStruct"%go [].

(* go: loops.go:28:22 *)
Definition LoopStruct__forLoopWaitⁱᵐᵖˡ : val :=
  λ: "ls" "i",
    exception_do (let: "ls" := (GoAlloc LoopStruct "ls") in
    let: "i" := (GoAlloc go.uint64 "i") in
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "nxt" := (GoAlloc (go.PointerType go.uint64) (GoZeroVal (go.PointerType go.uint64) #())) in
      let: "$r0" := (![go.PointerType go.uint64] (StructFieldRef LoopStruct "loopNext"%go "ls")) in
      do:  ("nxt" <-[go.PointerType go.uint64] "$r0");;;
      (if: (![go.uint64] "i") <⟨go.uint64⟩ (![go.uint64] (![go.PointerType go.uint64] "nxt"))
      then break: #()
      else do:  #());;;
      let: "$r0" := ((![go.uint64] (![go.PointerType go.uint64] (StructFieldRef LoopStruct "loopNext"%go "ls"))) +⟨go.uint64⟩ #(W64 1)) in
      do:  ((![go.PointerType go.uint64] (StructFieldRef LoopStruct "loopNext"%go "ls")) <-[go.uint64] "$r0");;;
      continue: #());;;
    return: #()).

Definition testStandardForLoop : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testStandardForLoop"%go.

(* tests

   go: loops.go:40:6 *)
Definition testStandardForLoopⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "arr" := (GoAlloc (go.SliceType go.uint64) (GoZeroVal (go.SliceType go.uint64) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType go.uint64] #()) #(W64 4)) in
    do:  ("arr" <-[go.SliceType go.uint64] "$r0");;;
    do:  ((IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "arr", #(W64 0))) <-[go.uint64] ((![go.uint64] (IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "arr", #(W64 0)))) +⟨go.uint64⟩ #(W64 1)));;;
    do:  ((IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "arr", #(W64 1))) <-[go.uint64] ((![go.uint64] (IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "arr", #(W64 1)))) +⟨go.uint64⟩ #(W64 3)));;;
    do:  ((IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "arr", #(W64 2))) <-[go.uint64] ((![go.uint64] (IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "arr", #(W64 2)))) +⟨go.uint64⟩ #(W64 5)));;;
    do:  ((IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "arr", #(W64 3))) <-[go.uint64] ((![go.uint64] (IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "arr", #(W64 3)))) +⟨go.uint64⟩ #(W64 7)));;;
    return: ((let: "$a0" := (![go.SliceType go.uint64] "arr") in
     (FuncResolve standardForLoop [] #()) "$a0") =⟨go.uint64⟩ #(W64 16))).

Definition testForLoopWait : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testForLoopWait"%go.

(* go: loops.go:49:6 *)
Definition testForLoopWaitⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ls" := (GoAlloc LoopStruct (GoZeroVal LoopStruct #())) in
    let: "$r0" := (CompositeLiteral LoopStruct (LiteralValue [KeyedElement (Some (KeyField "loopNext"%go)) (ElementExpression (GoAlloc go.uint64 (GoZeroVal go.uint64 #())))])) in
    do:  ("ls" <-[LoopStruct] "$r0");;;
    do:  (let: "$a0" := #(W64 3) in
    (MethodResolve LoopStruct "forLoopWait"%go #() (![LoopStruct] "ls")) "$a0");;;
    return: ((![go.uint64] (![go.PointerType go.uint64] (StructFieldRef LoopStruct "loopNext"%go "ls"))) =⟨go.uint64⟩ #(W64 4))).

Definition testBreakFromLoopWithContinue : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testBreakFromLoopWithContinue"%go.

(* go: loops.go:59:6 *)
Definition testBreakFromLoopWithContinueⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (if: #true
      then
        let: "$r0" := ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 1)) in
        do:  ("i" <-[go.uint64] "$r0");;;
        break: #()
      else do:  #());;;
      continue: #());;;
    return: ((![go.uint64] "i") =⟨go.uint64⟩ #(W64 1))).

Definition testBreakFromLoopNoContinue : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testBreakFromLoopNoContinue"%go.

(* go: loops.go:71:6 *)
Definition testBreakFromLoopNoContinueⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, (![go.uint64] "i") <⟨go.uint64⟩ #(W64 3)); (λ: <>, #()) := λ: <>,
      (if: #true
      then
        let: "$r0" := ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 1)) in
        do:  ("i" <-[go.uint64] "$r0");;;
        break: #()
      else do:  #());;;
      let: "$r0" := ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 2)) in
      do:  ("i" <-[go.uint64] "$r0"));;;
    return: ((![go.uint64] "i") =⟨go.uint64⟩ #(W64 1))).

Definition testBreakFromLoopNoContinueDouble : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testBreakFromLoopNoContinueDouble"%go.

(* go: loops.go:83:6 *)
Definition testBreakFromLoopNoContinueDoubleⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, (![go.uint64] "i") <⟨go.uint64⟩ #(W64 3)); (λ: <>, #()) := λ: <>,
      (if: (![go.uint64] "i") =⟨go.uint64⟩ #(W64 1)
      then
        let: "$r0" := ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 1)) in
        do:  ("i" <-[go.uint64] "$r0");;;
        break: #()
      else do:  #());;;
      let: "$r0" := ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 2)) in
      do:  ("i" <-[go.uint64] "$r0");;;
      let: "$r0" := ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 2)) in
      do:  ("i" <-[go.uint64] "$r0"));;;
    return: ((![go.uint64] "i") =⟨go.uint64⟩ #(W64 4))).

Definition testBreakFromLoopForOnly : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testBreakFromLoopForOnly"%go.

(* go: loops.go:96:6 *)
Definition testBreakFromLoopForOnlyⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, (![go.uint64] "i") <⟨go.uint64⟩ #(W64 3)); (λ: <>, #()) := λ: <>,
      let: "$r0" := ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 2)) in
      do:  ("i" <-[go.uint64] "$r0"));;;
    return: ((![go.uint64] "i") =⟨go.uint64⟩ #(W64 4))).

Definition testBreakFromLoopAssignAndContinue : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testBreakFromLoopAssignAndContinue"%go.

(* go: loops.go:104:6 *)
Definition testBreakFromLoopAssignAndContinueⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, (![go.uint64] "i") <⟨go.uint64⟩ #(W64 3)); (λ: <>, #()) := λ: <>,
      (if: #true
      then
        let: "$r0" := ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 1)) in
        do:  ("i" <-[go.uint64] "$r0");;;
        break: #()
      else do:  #());;;
      let: "$r0" := ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 2)) in
      do:  ("i" <-[go.uint64] "$r0");;;
      continue: #());;;
    return: ((![go.uint64] "i") =⟨go.uint64⟩ #(W64 1))).

Definition testNestedLoops : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testNestedLoops"%go.

(* go: loops.go:117:6 *)
Definition testNestedLoopsⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok1" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #false in
    do:  ("ok1" <-[go.bool] "$r0");;;
    let: "ok2" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #false in
    do:  ("ok2" <-[go.bool] "$r0");;;
    (let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (let: "j" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: "$r0" := #(W64 0) in
      do:  ("j" <-[go.uint64] "$r0");;;
      (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
        (if: (![go.uint64] "j") >⟨go.uint64⟩ #(W64 5)
        then break: #()
        else do:  #());;;
        let: "$r0" := ((![go.uint64] "j") +⟨go.uint64⟩ #(W64 1)) in
        do:  ("j" <-[go.uint64] "$r0");;;
        let: "$r0" := ((![go.uint64] "j") =⟨go.uint64⟩ #(W64 6)) in
        do:  ("ok1" <-[go.bool] "$r0");;;
        continue: #()));;;
      let: "$r0" := ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 1)) in
      do:  ("i" <-[go.uint64] "$r0");;;
      let: "$r0" := ((![go.uint64] "i") =⟨go.uint64⟩ #(W64 1)) in
      do:  ("ok2" <-[go.bool] "$r0");;;
      break: #()));;;
    return: ((![go.bool] "ok1") && (![go.bool] "ok2"))).

Definition testNestedGoStyleLoops : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testNestedGoStyleLoops"%go.

(* go: loops.go:136:6 *)
Definition testNestedGoStyleLoopsⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #false in
    do:  ("ok" <-[go.bool] "$r0");;;
    (let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, (![go.uint64] "i") <⟨go.uint64⟩ #(W64 10)); (λ: <>, do:  ("i" <-[go.uint64] ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 1)))) := λ: <>,
      (let: "j" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: "$r0" := #(W64 0) in
      do:  ("j" <-[go.uint64] "$r0");;;
      (for: (λ: <>, (![go.uint64] "j") <⟨go.uint64⟩ (![go.uint64] "i")); (λ: <>, do:  ("j" <-[go.uint64] ((![go.uint64] "j") +⟨go.uint64⟩ #(W64 1)))) := λ: <>,
        (if: #true
        then break: #()
        else do:  #());;;
        continue: #()));;;
      let: "$r0" := ((![go.uint64] "i") =⟨go.uint64⟩ #(W64 9)) in
      do:  ("ok" <-[go.bool] "$r0")));;;
    return: (![go.bool] "ok")).

Definition testNestedGoStyleLoopsNoComparison : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testNestedGoStyleLoopsNoComparison"%go.

(* go: loops.go:150:6 *)
Definition testNestedGoStyleLoopsNoComparisonⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #false in
    do:  ("ok" <-[go.bool] "$r0");;;
    (let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, (![go.uint64] "i") <⟨go.uint64⟩ #(W64 10)); (λ: <>, do:  ("i" <-[go.uint64] ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 1)))) := λ: <>,
      (let: "j" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: "$r0" := #(W64 0) in
      do:  ("j" <-[go.uint64] "$r0");;;
      (for: (λ: <>, (![go.uint64] "j") <⟨go.uint64⟩ (![go.uint64] "i")); (λ: <>, do:  ("j" <-[go.uint64] ((![go.uint64] "j") +⟨go.uint64⟩ #(W64 1)))) := λ: <>,
        (if: #true
        then break: #()
        else do:  #());;;
        continue: #()));;;
      let: "$r0" := ((![go.uint64] "i") =⟨go.uint64⟩ #(W64 9)) in
      do:  ("ok" <-[go.bool] "$r0")));;;
    return: (![go.bool] "ok")).

Definition IterateMapKeys : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.IterateMapKeys"%go.

(* go: maps.go:3:6 *)
Definition IterateMapKeysⁱᵐᵖˡ : val :=
  λ: "m",
    exception_do (let: "m" := (GoAlloc (go.MapType go.uint64 go.uint64) "m") in
    let: "sum" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$range" := (![go.MapType go.uint64 go.uint64] "m") in
    (let: "k" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    map.for_range "$range" (λ: "$key" "value",
      do:  ("k" <-[go.uint64] "$key");;;
      let: "$r0" := ((![go.uint64] "sum") +⟨go.uint64⟩ (![go.uint64] "k")) in
      do:  ("sum" <-[go.uint64] "$r0")));;;
    return: (![go.uint64] "sum")).

Definition IterateMapValues : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.IterateMapValues"%go.

(* go: maps.go:11:6 *)
Definition IterateMapValuesⁱᵐᵖˡ : val :=
  λ: "m",
    exception_do (let: "m" := (GoAlloc (go.MapType go.uint64 go.uint64) "m") in
    let: "sum" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$range" := (![go.MapType go.uint64 go.uint64] "m") in
    (let: "v" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    map.for_range "$range" (λ: "$key" "value",
      do:  ("v" <-[go.uint64] "$value");;;
      do:  "$key";;;
      let: "$r0" := ((![go.uint64] "sum") +⟨go.uint64⟩ (![go.uint64] "v")) in
      do:  ("sum" <-[go.uint64] "$r0")));;;
    return: (![go.uint64] "sum")).

Definition testIterateMap : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testIterateMap"%go.

(* go: maps.go:19:6 *)
Definition testIterateMapⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "m" := (GoAlloc (go.MapType go.uint64 go.uint64) (GoZeroVal (go.MapType go.uint64 go.uint64) #())) in
    let: "$r0" := ((FuncResolve go.make1 [go.MapType go.uint64 go.uint64] #()) #()) in
    do:  ("m" <-[go.MapType go.uint64 go.uint64] "$r0");;;
    let: "$r0" := #(W64 1) in
    do:  (map.insert (![go.MapType go.uint64 go.uint64] "m") #(W64 0) "$r0");;;
    let: "$r0" := #(W64 2) in
    do:  (map.insert (![go.MapType go.uint64 go.uint64] "m") #(W64 1) "$r0");;;
    let: "$r0" := #(W64 4) in
    do:  (map.insert (![go.MapType go.uint64 go.uint64] "m") #(W64 3) "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := (![go.MapType go.uint64 go.uint64] "m") in
    (FuncResolve IterateMapKeys [] #()) "$a0") =⟨go.uint64⟩ #(W64 4))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := (![go.MapType go.uint64 go.uint64] "m") in
    (FuncResolve IterateMapValues [] #()) "$a0") =⟨go.uint64⟩ #(W64 7))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    return: (![go.bool] "ok")).

Definition testMapSize : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testMapSize"%go.

(* go: maps.go:37:6 *)
Definition testMapSizeⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "m" := (GoAlloc (go.MapType go.uint64 go.uint64) (GoZeroVal (go.MapType go.uint64 go.uint64) #())) in
    let: "$r0" := ((FuncResolve go.make1 [go.MapType go.uint64 go.uint64] #()) #()) in
    do:  ("m" <-[go.MapType go.uint64 go.uint64] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((s_to_w64 (let: "$a0" := (![go.MapType go.uint64 go.uint64] "m") in
    (FuncResolve go.len [go.MapType go.uint64 go.uint64] #()) "$a0")) =⟨go.uint64⟩ #(W64 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := #(W64 1) in
    do:  (map.insert (![go.MapType go.uint64 go.uint64] "m") #(W64 0) "$r0");;;
    let: "$r0" := #(W64 2) in
    do:  (map.insert (![go.MapType go.uint64 go.uint64] "m") #(W64 1) "$r0");;;
    let: "$r0" := #(W64 4) in
    do:  (map.insert (![go.MapType go.uint64 go.uint64] "m") #(W64 3) "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((s_to_w64 (let: "$a0" := (![go.MapType go.uint64 go.uint64] "m") in
    (FuncResolve go.len [go.MapType go.uint64 go.uint64] #()) "$a0")) =⟨go.uint64⟩ #(W64 3))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    return: (![go.bool] "ok")).

Definition multReturnTwo : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.multReturnTwo"%go.

(* go: multiple_assign.go:3:6 *)
Definition multReturnTwoⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (#(W64 2), #(W64 3))).

Definition testAssignTwo : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testAssignTwo"%go.

(* go: multiple_assign.go:7:6 *)
Definition testAssignTwoⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 10) in
    do:  ("x" <-[go.uint64] "$r0");;;
    let: "y" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 15) in
    do:  ("y" <-[go.uint64] "$r0");;;
    let: ("$ret0", "$ret1") := ((FuncResolve multReturnTwo [] #()) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("x" <-[go.uint64] "$r0");;;
    do:  ("y" <-[go.uint64] "$r1");;;
    return: (((![go.uint64] "x") =⟨go.uint64⟩ #(W64 2)) && ((![go.uint64] "y") =⟨go.uint64⟩ #(W64 3)))).

Definition multReturnThree : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.multReturnThree"%go.

(* go: multiple_assign.go:14:6 *)
Definition multReturnThreeⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (#(W64 2), #true, #(W32 1))).

Definition testAssignThree : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testAssignThree"%go.

(* go: multiple_assign.go:18:6 *)
Definition testAssignThreeⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 10) in
    do:  ("x" <-[go.uint64] "$r0");;;
    let: "y" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #false in
    do:  ("y" <-[go.bool] "$r0");;;
    let: "z" := (GoAlloc go.uint32 (GoZeroVal go.uint32 #())) in
    let: "$r0" := #(W32 15) in
    do:  ("z" <-[go.uint32] "$r0");;;
    let: (("$ret0", "$ret1"), "$ret2") := ((FuncResolve multReturnThree [] #()) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("x" <-[go.uint64] "$r0");;;
    do:  ("y" <-[go.bool] "$r1");;;
    do:  ("z" <-[go.uint32] "$r2");;;
    return: ((((![go.uint64] "x") =⟨go.uint64⟩ #(W64 2)) && ((![go.bool] "y") =⟨go.bool⟩ #true)) && ((![go.uint32] "z") =⟨go.uint32⟩ #(W32 1)))).

Definition testMultipleAssignToMap : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testMultipleAssignToMap"%go.

(* go: multiple_assign.go:26:6 *)
Definition testMultipleAssignToMapⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 10) in
    do:  ("x" <-[go.uint64] "$r0");;;
    let: "m" := (GoAlloc (go.MapType go.uint64 go.uint64) (GoZeroVal (go.MapType go.uint64 go.uint64) #())) in
    let: "$r0" := ((FuncResolve go.make1 [go.MapType go.uint64 go.uint64] #()) #()) in
    do:  ("m" <-[go.MapType go.uint64 go.uint64] "$r0");;;
    let: ("$ret0", "$ret1") := ((FuncResolve multReturnTwo [] #()) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("x" <-[go.uint64] "$r0");;;
    do:  (map.insert (![go.MapType go.uint64 go.uint64] "m") #(W64 0) "$r1");;;
    return: (((![go.uint64] "x") =⟨go.uint64⟩ #(W64 2)) && ((Fst (map.get (![go.MapType go.uint64 go.uint64] "m") #(W64 0))) =⟨go.uint64⟩ #(W64 3)))).

Definition returnTwo : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.returnTwo"%go.

(* go: multiple_return.go:3:6 *)
Definition returnTwoⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (#(W64 2), #(W64 3))).

Definition testReturnTwo : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testReturnTwo"%go.

(* go: multiple_return.go:7:6 *)
Definition testReturnTwoⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "y" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "x" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: ("$ret0", "$ret1") := ((FuncResolve returnTwo [] #()) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("x" <-[go.uint64] "$r0");;;
    do:  ("y" <-[go.uint64] "$r1");;;
    return: (((![go.uint64] "x") =⟨go.uint64⟩ #(W64 2)) && ((![go.uint64] "y") =⟨go.uint64⟩ #(W64 3)))).

Definition testAnonymousBinding : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testAnonymousBinding"%go.

(* go: multiple_return.go:12:6 *)
Definition testAnonymousBindingⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "y" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: ("$ret0", "$ret1") := ((FuncResolve returnTwo [] #()) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  "$r0";;;
    do:  ("y" <-[go.uint64] "$r1");;;
    return: ((![go.uint64] "y") =⟨go.uint64⟩ #(W64 3))).

Definition returnThree : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.returnThree"%go.

(* go: multiple_return.go:17:6 *)
Definition returnThreeⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (#(W64 2), #true, #(W32 1))).

Definition testReturnThree : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testReturnThree"%go.

(* go: multiple_return.go:21:6 *)
Definition testReturnThreeⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "z" := (GoAlloc go.uint32 (GoZeroVal go.uint32 #())) in
    let: "y" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "x" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: (("$ret0", "$ret1"), "$ret2") := ((FuncResolve returnThree [] #()) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("x" <-[go.uint64] "$r0");;;
    do:  ("y" <-[go.bool] "$r1");;;
    do:  ("z" <-[go.uint32] "$r2");;;
    return: ((((![go.uint64] "x") =⟨go.uint64⟩ #(W64 2)) && ((![go.bool] "y") =⟨go.bool⟩ #true)) && ((![go.uint32] "z") =⟨go.uint32⟩ #(W32 1)))).

Definition returnFour : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.returnFour"%go.

(* go: multiple_return.go:26:6 *)
Definition returnFourⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (#(W64 2), #true, #(W32 1), #(W64 7))).

Definition testReturnFour : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testReturnFour"%go.

(* go: multiple_return.go:30:6 *)
Definition testReturnFourⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "w" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "z" := (GoAlloc go.uint32 (GoZeroVal go.uint32 #())) in
    let: "y" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "x" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: ((("$ret0", "$ret1"), "$ret2"), "$ret3") := ((FuncResolve returnFour [] #()) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    let: "$r3" := "$ret3" in
    do:  ("x" <-[go.uint64] "$r0");;;
    do:  ("y" <-[go.bool] "$r1");;;
    do:  ("z" <-[go.uint32] "$r2");;;
    do:  ("w" <-[go.uint64] "$r3");;;
    return: (((((![go.uint64] "x") =⟨go.uint64⟩ #(W64 2)) && ((![go.bool] "y") =⟨go.bool⟩ #true)) && ((![go.uint32] "z") =⟨go.uint32⟩ #(W32 1))) && ((![go.uint64] "w") =⟨go.uint64⟩ #(W64 7)))).

Definition failing_testCompareSliceToNil : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.failing_testCompareSliceToNil"%go.

(* go: nil.go:3:6 *)
Definition failing_testCompareSliceToNilⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "s" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 0)) in
    do:  ("s" <-[go.SliceType go.byte] "$r0");;;
    return: ((![go.SliceType go.byte] "s") ≠⟨go.SliceType go.byte⟩ #slice.nil)).

Definition testComparePointerToNil : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testComparePointerToNil"%go.

(* go: nil.go:8:6 *)
Definition testComparePointerToNilⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "s" := (GoAlloc (go.PointerType go.uint64) (GoZeroVal (go.PointerType go.uint64) #())) in
    let: "$r0" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    do:  ("s" <-[go.PointerType go.uint64] "$r0");;;
    return: ((![go.PointerType go.uint64] "s") ≠⟨go.PointerType go.uint64⟩ #null)).

Definition testCompareNilToNil : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testCompareNilToNil"%go.

(* go: nil.go:13:6 *)
Definition testCompareNilToNilⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "s" := (GoAlloc (go.PointerType (go.PointerType go.uint64)) (GoZeroVal (go.PointerType (go.PointerType go.uint64)) #())) in
    let: "$r0" := (GoAlloc (go.PointerType go.uint64) (GoZeroVal (go.PointerType go.uint64) #())) in
    do:  ("s" <-[go.PointerType (go.PointerType go.uint64)] "$r0");;;
    return: ((![go.PointerType go.uint64] (![go.PointerType (go.PointerType go.uint64)] "s")) =⟨go.PointerType go.uint64⟩ #null)).

Definition testComparePointerWrappedToNil : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testComparePointerWrappedToNil"%go.

(* go: nil.go:18:6 *)
Definition testComparePointerWrappedToNilⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "s" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 1)) in
    do:  ("s" <-[go.SliceType go.byte] "$r0");;;
    return: ((![go.SliceType go.byte] "s") ≠⟨go.SliceType go.byte⟩ #slice.nil)).

Definition testComparePointerWrappedDefaultToNil : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testComparePointerWrappedDefaultToNil"%go.

(* go: nil.go:24:6 *)
Definition testComparePointerWrappedDefaultToNilⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "s" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    return: ((![go.SliceType go.byte] "s") =⟨go.SliceType go.byte⟩ #slice.nil)).

Definition reverseAssignOps64 : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.reverseAssignOps64"%go.

(* helpers

   go: operations.go:4:6 *)
Definition reverseAssignOps64ⁱᵐᵖˡ : val :=
  λ: "x",
    exception_do (let: "x" := (GoAlloc go.uint64 "x") in
    let: "y" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    do:  ("y" <-[go.uint64] ((![go.uint64] "y") +⟨go.uint64⟩ (![go.uint64] "x")));;;
    do:  ("y" <-[go.uint64] ((![go.uint64] "y") -⟨go.uint64⟩ (![go.uint64] "x")));;;
    do:  ("y" <-[go.uint64] ((![go.uint64] "y") +⟨go.uint64⟩ #(W64 1)));;;
    do:  ("y" <-[go.uint64] ((![go.uint64] "y") -⟨go.uint64⟩ #(W64 1)));;;
    return: (![go.uint64] "y")).

Definition reverseAssignOps32 : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.reverseAssignOps32"%go.

(* go: operations.go:13:6 *)
Definition reverseAssignOps32ⁱᵐᵖˡ : val :=
  λ: "x",
    exception_do (let: "x" := (GoAlloc go.uint32 "x") in
    let: "y" := (GoAlloc go.uint32 (GoZeroVal go.uint32 #())) in
    do:  ("y" <-[go.uint32] ((![go.uint32] "y") +⟨go.uint32⟩ (![go.uint32] "x")));;;
    do:  ("y" <-[go.uint32] ((![go.uint32] "y") -⟨go.uint32⟩ (![go.uint32] "x")));;;
    do:  ("y" <-[go.uint32] ((![go.uint32] "y") +⟨go.uint32⟩ #(W32 1)));;;
    do:  ("y" <-[go.uint32] ((![go.uint32] "y") -⟨go.uint32⟩ #(W32 1)));;;
    return: (![go.uint32] "y")).

Definition add64Equals : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.add64Equals"%go.

(* go: operations.go:22:6 *)
Definition add64Equalsⁱᵐᵖˡ : val :=
  λ: "x" "y" "z",
    exception_do (let: "z" := (GoAlloc go.uint64 "z") in
    let: "y" := (GoAlloc go.uint64 "y") in
    let: "x" := (GoAlloc go.uint64 "x") in
    return: (((![go.uint64] "x") +⟨go.uint64⟩ (![go.uint64] "y")) =⟨go.uint64⟩ (![go.uint64] "z"))).

Definition sub64Equals : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.sub64Equals"%go.

(* go: operations.go:26:6 *)
Definition sub64Equalsⁱᵐᵖˡ : val :=
  λ: "x" "y" "z",
    exception_do (let: "z" := (GoAlloc go.uint64 "z") in
    let: "y" := (GoAlloc go.uint64 "y") in
    let: "x" := (GoAlloc go.uint64 "x") in
    return: (((![go.uint64] "x") -⟨go.uint64⟩ (![go.uint64] "y")) =⟨go.uint64⟩ (![go.uint64] "z"))).

Definition testReverseAssignOps64 : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testReverseAssignOps64"%go.

(* tests

   go: operations.go:31:6 *)
Definition testReverseAssignOps64ⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W64 0) in
    (FuncResolve reverseAssignOps64 [] #()) "$a0") =⟨go.uint64⟩ #(W64 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W64 1) in
    (FuncResolve reverseAssignOps64 [] #()) "$a0") =⟨go.uint64⟩ #(W64 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W64 1231234) in
    (FuncResolve reverseAssignOps64 [] #()) "$a0") =⟨go.uint64⟩ #(W64 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W64 62206846038638762) in
    (FuncResolve reverseAssignOps64 [] #()) "$a0") =⟨go.uint64⟩ #(W64 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W64 9223372036854775808) in
    (FuncResolve reverseAssignOps64 [] #()) "$a0") =⟨go.uint64⟩ #(W64 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W64 140737488355328) in
    (FuncResolve reverseAssignOps64 [] #()) "$a0") =⟨go.uint64⟩ #(W64 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W64 1048576) in
    (FuncResolve reverseAssignOps64 [] #()) "$a0") =⟨go.uint64⟩ #(W64 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W64 262144) in
    (FuncResolve reverseAssignOps64 [] #()) "$a0") =⟨go.uint64⟩ #(W64 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W64 1024) in
    (FuncResolve reverseAssignOps64 [] #()) "$a0") =⟨go.uint64⟩ #(W64 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W64 1) in
    (FuncResolve reverseAssignOps64 [] #()) "$a0") =⟨go.uint64⟩ #(W64 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W64 18446744073709551615) in
    (FuncResolve reverseAssignOps64 [] #()) "$a0") =⟨go.uint64⟩ #(W64 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    return: (![go.bool] "ok")).

Definition failing_testReverseAssignOps32 : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.failing_testReverseAssignOps32"%go.

(* go: operations.go:47:6 *)
Definition failing_testReverseAssignOps32ⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W32 0) in
    (FuncResolve reverseAssignOps32 [] #()) "$a0") =⟨go.uint32⟩ #(W32 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W32 1) in
    (FuncResolve reverseAssignOps32 [] #()) "$a0") =⟨go.uint32⟩ #(W32 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W32 1231234) in
    (FuncResolve reverseAssignOps32 [] #()) "$a0") =⟨go.uint32⟩ #(W32 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W32 3434807466) in
    (FuncResolve reverseAssignOps32 [] #()) "$a0") =⟨go.uint32⟩ #(W32 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W32 1048576) in
    (FuncResolve reverseAssignOps32 [] #()) "$a0") =⟨go.uint32⟩ #(W32 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W32 262144) in
    (FuncResolve reverseAssignOps32 [] #()) "$a0") =⟨go.uint32⟩ #(W32 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W32 1024) in
    (FuncResolve reverseAssignOps32 [] #()) "$a0") =⟨go.uint32⟩ #(W32 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W32 1) in
    (FuncResolve reverseAssignOps32 [] #()) "$a0") =⟨go.uint32⟩ #(W32 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W32 4294967295) in
    (FuncResolve reverseAssignOps32 [] #()) "$a0") =⟨go.uint32⟩ #(W32 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    return: (![go.bool] "ok")).

Definition testAdd64Equals : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testAdd64Equals"%go.

(* go: operations.go:61:6 *)
Definition testAdd64Equalsⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && (let: "$a0" := #(W64 2) in
    let: "$a1" := #(W64 3) in
    let: "$a2" := #(W64 5) in
    (FuncResolve add64Equals [] #()) "$a0" "$a1" "$a2")) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && (let: "$a0" := #(W64 18446744073709551615) in
    let: "$a1" := #(W64 1) in
    let: "$a2" := #(W64 0) in
    (FuncResolve add64Equals [] #()) "$a0" "$a1" "$a2")) in
    do:  ("ok" <-[go.bool] "$r0");;;
    return: (![go.bool] "ok")).

Definition testSub64Equals : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testSub64Equals"%go.

(* go: operations.go:68:6 *)
Definition testSub64Equalsⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && (let: "$a0" := #(W64 2) in
    let: "$a1" := #(W64 1) in
    let: "$a2" := #(W64 1) in
    (FuncResolve sub64Equals [] #()) "$a0" "$a1" "$a2")) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && (let: "$a0" := #(W64 18446744073709551615) in
    let: "$a1" := #(W64 9223372036854775808) in
    let: "$a2" := #(W64 9223372036854775807) in
    (FuncResolve sub64Equals [] #()) "$a0" "$a1" "$a2")) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && (let: "$a0" := #(W64 2) in
    let: "$a1" := #(W64 8) in
    let: "$a2" := #(W64 18446744073709551610) in
    (FuncResolve sub64Equals [] #()) "$a0" "$a1" "$a2")) in
    do:  ("ok" <-[go.bool] "$r0");;;
    return: (![go.bool] "ok")).

Definition testDivisionPrecedence : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testDivisionPrecedence"%go.

(* go: operations.go:76:6 *)
Definition testDivisionPrecedenceⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "blockSize" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 4096) in
    do:  ("blockSize" <-[go.uint64] "$r0");;;
    let: "hdrmeta" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 8) in
    do:  ("hdrmeta" <-[go.uint64] "$r0");;;
    let: "hdraddrs" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (((![go.uint64] "blockSize") -⟨go.uint64⟩ (![go.uint64] "hdrmeta")) /⟨go.uint64⟩ #(W64 8)) in
    do:  ("hdraddrs" <-[go.uint64] "$r0");;;
    return: ((![go.uint64] "hdraddrs") =⟨go.uint64⟩ #(W64 511))).

Definition testModPrecedence : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testModPrecedence"%go.

(* go: operations.go:83:6 *)
Definition testModPrecedenceⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x1" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := #(W64 517) in
    do:  ("x1" <-[go.int] "$r0");;;
    let: "x2" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := #(W64 5) in
    do:  ("x2" <-[go.int] "$r0");;;
    return: (((![go.int] "x1") =⟨go.int⟩ #(W64 517)) && ((![go.int] "x2") =⟨go.int⟩ #(W64 5)))).

Definition testBitwiseOpsPrecedence : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testBitwiseOpsPrecedence"%go.

(* go: operations.go:89:6 *)
Definition testBitwiseOpsPrecedenceⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && #true) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && #true) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && #true) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && #true) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && #true) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && #true) in
    do:  ("ok" <-[go.bool] "$r0");;;
    return: (![go.bool] "ok")).

Definition testArithmeticShifts : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testArithmeticShifts"%go.

(* go: operations.go:102:6 *)
Definition testArithmeticShiftsⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && #true) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && #true) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && #true) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && #true) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && #true) in
    do:  ("ok" <-[go.bool] "$r0");;;
    return: (![go.bool] "ok")).

Definition testBitAddAnd : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testBitAddAnd"%go.

(* go: operations.go:114:6 *)
Definition testBitAddAndⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "tid" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 17) in
    do:  ("tid" <-[go.uint64] "$r0");;;
    let: "n" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 16) in
    do:  ("n" <-[go.uint64] "$r0");;;
    return: ((((![go.uint64] "tid") +⟨go.uint64⟩ (![go.uint64] "n")) &⟨go.uint64⟩ (~ ((![go.uint64] "n") -⟨go.uint64⟩ #(W64 1)))) =⟨go.uint64⟩ #(W64 32))).

Definition testManyParentheses : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testManyParentheses"%go.

(* go: operations.go:120:6 *)
Definition testManyParenthesesⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (#true)).

Definition testPlusTimes : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testPlusTimes"%go.

(* go: operations.go:124:6 *)
Definition testPlusTimesⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (#true)).

Definition testOrCompareSimple : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testOrCompareSimple"%go.

(* go: precedence.go:3:6 *)
Definition testOrCompareSimpleⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do ((if: #false || #true
    then return: (#true)
    else do:  #());;;
    return: (#false)).

Definition testOrCompare : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testOrCompare"%go.

(* go: precedence.go:10:6 *)
Definition testOrCompareⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    (if: (~ (#false || #true))
    then
      let: "$r0" := #false in
      do:  ("ok" <-[go.bool] "$r0")
    else do:  #());;;
    (if: #false || #false
    then
      let: "$r0" := #false in
      do:  ("ok" <-[go.bool] "$r0")
    else do:  #());;;
    return: (![go.bool] "ok")).

Definition testAndCompare : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testAndCompare"%go.

(* go: precedence.go:22:6 *)
Definition testAndCompareⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    (if: #false && #true
    then
      let: "$r0" := #false in
      do:  ("ok" <-[go.bool] "$r0")
    else do:  #());;;
    (if: #true || #true
    then do:  #()
    else
      let: "$r0" := #false in
      do:  ("ok" <-[go.bool] "$r0"));;;
    return: (![go.bool] "ok")).

Definition testShiftMod : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testShiftMod"%go.

(* go: precedence.go:34:6 *)
Definition testShiftModⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (#true)).

Definition testLinearize : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testLinearize"%go.

(* go: prims.go:9:6 *)
Definition testLinearizeⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "m" := (GoAlloc (go.PointerType sync.Mutex) (GoZeroVal (go.PointerType sync.Mutex) #())) in
    let: "$r0" := (GoAlloc sync.Mutex (GoZeroVal sync.Mutex #())) in
    do:  ("m" <-[go.PointerType sync.Mutex] "$r0");;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go #() (![go.PointerType sync.Mutex] "m")) #());;;
    do:  ((FuncResolve primitive.Linearize [] #()) #());;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go #() (![go.PointerType sync.Mutex] "m")) #());;;
    return: (#true)).

Definition BoolTestⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "t"%go go.bool);
  (go.FieldDecl "f"%go go.bool);
  (go.FieldDecl "tc"%go go.uint64);
  (go.FieldDecl "fc"%go go.uint64)
].

Definition CheckTrue : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.CheckTrue"%go.

Definition BoolTest : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/semantics.BoolTest"%go [].

(* go: shortcircuiting.go:11:6 *)
Definition CheckTrueⁱᵐᵖˡ : val :=
  λ: "b",
    exception_do (let: "b" := (GoAlloc (go.PointerType BoolTest) "b") in
    do:  ((StructFieldRef BoolTest "tc"%go (![go.PointerType BoolTest] "b")) <-[go.uint64] ((![go.uint64] (StructFieldRef BoolTest "tc"%go (![go.PointerType BoolTest] "b"))) +⟨go.uint64⟩ #(W64 1)));;;
    return: (![go.bool] (StructFieldRef BoolTest "t"%go (![go.PointerType BoolTest] "b")))).

Definition CheckFalse : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.CheckFalse"%go.

(* go: shortcircuiting.go:16:6 *)
Definition CheckFalseⁱᵐᵖˡ : val :=
  λ: "b",
    exception_do (let: "b" := (GoAlloc (go.PointerType BoolTest) "b") in
    do:  ((StructFieldRef BoolTest "fc"%go (![go.PointerType BoolTest] "b")) <-[go.uint64] ((![go.uint64] (StructFieldRef BoolTest "fc"%go (![go.PointerType BoolTest] "b"))) +⟨go.uint64⟩ #(W64 1)));;;
    return: (![go.bool] (StructFieldRef BoolTest "f"%go (![go.PointerType BoolTest] "b")))).

Definition testShortcircuitAndTF : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testShortcircuitAndTF"%go.

(* tests

   go: shortcircuiting.go:22:6 *)
Definition testShortcircuitAndTFⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "b" := (GoAlloc (go.PointerType BoolTest) (GoZeroVal (go.PointerType BoolTest) #())) in
    let: "$r0" := (GoAlloc BoolTest (CompositeLiteral BoolTest (LiteralValue [KeyedElement (Some (KeyField "t"%go)) (ElementExpression #true); KeyedElement (Some (KeyField "f"%go)) (ElementExpression #false); KeyedElement (Some (KeyField "tc"%go)) (ElementExpression #(W64 0)); KeyedElement (Some (KeyField "fc"%go)) (ElementExpression #(W64 0))]))) in
    do:  ("b" <-[go.PointerType BoolTest] "$r0");;;
    (if: (let: "$a0" := (![go.PointerType BoolTest] "b") in
    (FuncResolve CheckTrue [] #()) "$a0") && (let: "$a0" := (![go.PointerType BoolTest] "b") in
    (FuncResolve CheckFalse [] #()) "$a0")
    then return: (#false)
    else do:  #());;;
    return: (((![go.uint64] (StructFieldRef BoolTest "tc"%go (![go.PointerType BoolTest] "b"))) =⟨go.uint64⟩ #(W64 1)) && ((![go.uint64] (StructFieldRef BoolTest "fc"%go (![go.PointerType BoolTest] "b"))) =⟨go.uint64⟩ #(W64 1)))).

Definition testShortcircuitAndFT : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testShortcircuitAndFT"%go.

(* go: shortcircuiting.go:31:6 *)
Definition testShortcircuitAndFTⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "b" := (GoAlloc (go.PointerType BoolTest) (GoZeroVal (go.PointerType BoolTest) #())) in
    let: "$r0" := (GoAlloc BoolTest (CompositeLiteral BoolTest (LiteralValue [KeyedElement (Some (KeyField "t"%go)) (ElementExpression #true); KeyedElement (Some (KeyField "f"%go)) (ElementExpression #false); KeyedElement (Some (KeyField "tc"%go)) (ElementExpression #(W64 0)); KeyedElement (Some (KeyField "fc"%go)) (ElementExpression #(W64 0))]))) in
    do:  ("b" <-[go.PointerType BoolTest] "$r0");;;
    (if: (let: "$a0" := (![go.PointerType BoolTest] "b") in
    (FuncResolve CheckFalse [] #()) "$a0") && (let: "$a0" := (![go.PointerType BoolTest] "b") in
    (FuncResolve CheckTrue [] #()) "$a0")
    then return: (#false)
    else do:  #());;;
    return: (((![go.uint64] (StructFieldRef BoolTest "tc"%go (![go.PointerType BoolTest] "b"))) =⟨go.uint64⟩ #(W64 0)) && ((![go.uint64] (StructFieldRef BoolTest "fc"%go (![go.PointerType BoolTest] "b"))) =⟨go.uint64⟩ #(W64 1)))).

Definition testShortcircuitOrTF : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testShortcircuitOrTF"%go.

(* go: shortcircuiting.go:40:6 *)
Definition testShortcircuitOrTFⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "b" := (GoAlloc (go.PointerType BoolTest) (GoZeroVal (go.PointerType BoolTest) #())) in
    let: "$r0" := (GoAlloc BoolTest (CompositeLiteral BoolTest (LiteralValue [KeyedElement (Some (KeyField "t"%go)) (ElementExpression #true); KeyedElement (Some (KeyField "f"%go)) (ElementExpression #false); KeyedElement (Some (KeyField "tc"%go)) (ElementExpression #(W64 0)); KeyedElement (Some (KeyField "fc"%go)) (ElementExpression #(W64 0))]))) in
    do:  ("b" <-[go.PointerType BoolTest] "$r0");;;
    (if: (let: "$a0" := (![go.PointerType BoolTest] "b") in
    (FuncResolve CheckTrue [] #()) "$a0") || (let: "$a0" := (![go.PointerType BoolTest] "b") in
    (FuncResolve CheckFalse [] #()) "$a0")
    then return: (((![go.uint64] (StructFieldRef BoolTest "tc"%go (![go.PointerType BoolTest] "b"))) =⟨go.uint64⟩ #(W64 1)) && ((![go.uint64] (StructFieldRef BoolTest "fc"%go (![go.PointerType BoolTest] "b"))) =⟨go.uint64⟩ #(W64 0)))
    else do:  #());;;
    return: (#false)).

Definition testShortcircuitOrFT : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testShortcircuitOrFT"%go.

(* go: shortcircuiting.go:48:6 *)
Definition testShortcircuitOrFTⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "b" := (GoAlloc (go.PointerType BoolTest) (GoZeroVal (go.PointerType BoolTest) #())) in
    let: "$r0" := (GoAlloc BoolTest (CompositeLiteral BoolTest (LiteralValue [KeyedElement (Some (KeyField "t"%go)) (ElementExpression #true); KeyedElement (Some (KeyField "f"%go)) (ElementExpression #false); KeyedElement (Some (KeyField "tc"%go)) (ElementExpression #(W64 0)); KeyedElement (Some (KeyField "fc"%go)) (ElementExpression #(W64 0))]))) in
    do:  ("b" <-[go.PointerType BoolTest] "$r0");;;
    (if: (let: "$a0" := (![go.PointerType BoolTest] "b") in
    (FuncResolve CheckFalse [] #()) "$a0") || (let: "$a0" := (![go.PointerType BoolTest] "b") in
    (FuncResolve CheckTrue [] #()) "$a0")
    then return: (((![go.uint64] (StructFieldRef BoolTest "tc"%go (![go.PointerType BoolTest] "b"))) =⟨go.uint64⟩ #(W64 1)) && ((![go.uint64] (StructFieldRef BoolTest "fc"%go (![go.PointerType BoolTest] "b"))) =⟨go.uint64⟩ #(W64 1)))
    else do:  #());;;
    return: (#false)).

Definition ArrayEditorⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "s"%go (go.SliceType go.uint64));
  (go.FieldDecl "next_val"%go go.uint64)
].

Definition ArrayEditor : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/semantics.ArrayEditor"%go [].

(* go: slices.go:9:24 *)
Definition ArrayEditor__Advanceⁱᵐᵖˡ : val :=
  λ: "ae" "arr" "next",
    exception_do (let: "ae" := (GoAlloc (go.PointerType ArrayEditor) "ae") in
    let: "next" := (GoAlloc go.uint64 "next") in
    let: "arr" := (GoAlloc (go.SliceType go.uint64) "arr") in
    do:  ((IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "arr", #(W64 0))) <-[go.uint64] ((![go.uint64] (IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "arr", #(W64 0)))) +⟨go.uint64⟩ #(W64 1)));;;
    let: "$r0" := (![go.uint64] (StructFieldRef ArrayEditor "next_val"%go (![go.PointerType ArrayEditor] "ae"))) in
    do:  ((IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] (StructFieldRef ArrayEditor "s"%go (![go.PointerType ArrayEditor] "ae")), #(W64 0))) <-[go.uint64] "$r0");;;
    let: "$r0" := (![go.uint64] "next") in
    do:  ((StructFieldRef ArrayEditor "next_val"%go (![go.PointerType ArrayEditor] "ae")) <-[go.uint64] "$r0");;;
    let: "$r0" := (let: "$s" := (![go.SliceType go.uint64] (StructFieldRef ArrayEditor "s"%go (![go.PointerType ArrayEditor] "ae"))) in
    Slice (go.SliceType go.uint64) ("$s", #(W64 1), FuncResolve go.len [go.SliceType go.uint64] #() (![go.SliceType go.uint64] (StructFieldRef ArrayEditor "s"%go (![go.PointerType ArrayEditor] "ae"))))) in
    do:  ((StructFieldRef ArrayEditor "s"%go (![go.PointerType ArrayEditor] "ae")) <-[go.SliceType go.uint64] "$r0");;;
    return: #()).

Definition testSliceOps : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testSliceOps"%go.

(* tests

   go: slices.go:17:6 *)
Definition testSliceOpsⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc (go.SliceType go.uint64) (GoZeroVal (go.SliceType go.uint64) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType go.uint64] #()) #(W64 10)) in
    do:  ("x" <-[go.SliceType go.uint64] "$r0");;;
    let: "$r0" := #(W64 5) in
    do:  ((IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "x", #(W64 1))) <-[go.uint64] "$r0");;;
    let: "$r0" := #(W64 10) in
    do:  ((IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "x", #(W64 2))) <-[go.uint64] "$r0");;;
    let: "$r0" := #(W64 15) in
    do:  ((IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "x", #(W64 3))) <-[go.uint64] "$r0");;;
    let: "$r0" := #(W64 20) in
    do:  ((IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "x", #(W64 4))) <-[go.uint64] "$r0");;;
    let: "v1" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (![go.uint64] (IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "x", #(W64 2)))) in
    do:  ("v1" <-[go.uint64] "$r0");;;
    let: "v2" := (GoAlloc (go.SliceType go.uint64) (GoZeroVal (go.SliceType go.uint64) #())) in
    let: "$r0" := (let: "$s" := (![go.SliceType go.uint64] "x") in
    Slice (go.SliceType go.uint64) ("$s", #(W64 2), #(W64 3))) in
    do:  ("v2" <-[go.SliceType go.uint64] "$r0");;;
    let: "v3" := (GoAlloc (go.SliceType go.uint64) (GoZeroVal (go.SliceType go.uint64) #())) in
    let: "$r0" := (let: "$s" := (![go.SliceType go.uint64] "x") in
    Slice (go.SliceType go.uint64) ("$s", #(W64 0), #(W64 3))) in
    do:  ("v3" <-[go.SliceType go.uint64] "$r0");;;
    let: "v4" := (GoAlloc (go.PointerType go.uint64) (GoZeroVal (go.PointerType go.uint64) #())) in
    let: "$r0" := (IndexRef go.uint64 (![go.SliceType go.uint64] "x", #(W64 2))) in
    do:  ("v4" <-[go.PointerType go.uint64] "$r0");;;
    let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] "v1") =⟨go.uint64⟩ #(W64 10))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] (IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "v2", #(W64 0)))) =⟨go.uint64⟩ #(W64 10))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := (![go.SliceType go.uint64] "v2") in
    (FuncResolve go.len [go.SliceType go.uint64] #()) "$a0") =⟨go.int⟩ #(W64 1))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] (IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "v3", #(W64 1)))) =⟨go.uint64⟩ #(W64 5))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] (IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "v3", #(W64 2)))) =⟨go.uint64⟩ #(W64 10))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := (![go.SliceType go.uint64] "v3") in
    (FuncResolve go.len [go.SliceType go.uint64] #()) "$a0") =⟨go.int⟩ #(W64 3))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] (![go.PointerType go.uint64] "v4")) =⟨go.uint64⟩ #(W64 10))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    return: (![go.bool] "ok")).

Definition testSliceCapacityOps : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testSliceCapacityOps"%go.

(* go: slices.go:40:6 *)
Definition testSliceCapacityOpsⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc (go.SliceType go.uint64) (GoZeroVal (go.SliceType go.uint64) #())) in
    let: "$r0" := ((FuncResolve go.make3 [go.SliceType go.uint64] #()) #(W64 0) #(W64 10)) in
    do:  ("x" <-[go.SliceType go.uint64] "$r0");;;
    let: "sub1" := (GoAlloc (go.SliceType go.uint64) (GoZeroVal (go.SliceType go.uint64) #())) in
    let: "$r0" := (let: "$s" := (![go.SliceType go.uint64] "x") in
    Slice (go.SliceType go.uint64) ("$s", #(W64 0), #(W64 6))) in
    do:  ("sub1" <-[go.SliceType go.uint64] "$r0");;;
    let: "$r0" := #(W64 1) in
    do:  ((IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "sub1", #(W64 0))) <-[go.uint64] "$r0");;;
    let: "sub2" := (GoAlloc (go.SliceType go.uint64) (GoZeroVal (go.SliceType go.uint64) #())) in
    let: "$r0" := (let: "$s" := (![go.SliceType go.uint64] "x") in
    Slice (go.SliceType go.uint64) ("$s", #(W64 2), #(W64 4))) in
    do:  ("sub2" <-[go.SliceType go.uint64] "$r0");;;
    let: "$r0" := #(W64 2) in
    do:  ((IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "sub2", #(W64 0))) <-[go.uint64] "$r0");;;
    let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := (![go.SliceType go.uint64] "sub1") in
    (FuncResolve go.len [go.SliceType go.uint64] #()) "$a0") =⟨go.int⟩ #(W64 6))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := (![go.SliceType go.uint64] "sub1") in
    (FuncResolve go.cap [go.SliceType go.uint64] #()) "$a0") =⟨go.int⟩ #(W64 10))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] (IndexRef (go.SliceType go.uint64) (let: "$s" := (![go.SliceType go.uint64] "x") in
     Slice (go.SliceType go.uint64) ("$s", #(W64 0), #(W64 10)), #(W64 0)))) =⟨go.uint64⟩ #(W64 1))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := (![go.SliceType go.uint64] "sub2") in
    (FuncResolve go.len [go.SliceType go.uint64] #()) "$a0") =⟨go.int⟩ #(W64 2))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := (![go.SliceType go.uint64] "sub2") in
    (FuncResolve go.cap [go.SliceType go.uint64] #()) "$a0") =⟨go.int⟩ #(W64 8))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] (IndexRef (go.SliceType go.uint64) (let: "$s" := (![go.SliceType go.uint64] "x") in
     Slice (go.SliceType go.uint64) ("$s", #(W64 0), #(W64 10)), #(W64 2)))) =⟨go.uint64⟩ #(W64 2))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    return: (![go.bool] "ok")).

Definition testOverwriteArray : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testOverwriteArray"%go.

(* go: slices.go:59:6 *)
Definition testOverwriteArrayⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "arr" := (GoAlloc (go.SliceType go.uint64) (GoZeroVal (go.SliceType go.uint64) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType go.uint64] #()) #(W64 4)) in
    do:  ("arr" <-[go.SliceType go.uint64] "$r0");;;
    let: "ae1" := (GoAlloc (go.PointerType ArrayEditor) (GoZeroVal (go.PointerType ArrayEditor) #())) in
    let: "$r0" := (GoAlloc ArrayEditor (CompositeLiteral ArrayEditor (LiteralValue [KeyedElement (Some (KeyField "s"%go)) (ElementExpression (let: "$s" := (![go.SliceType go.uint64] "arr") in
     Slice (go.SliceType go.uint64) ("$s", #(W64 0), FuncResolve go.len [go.SliceType go.uint64] #() (![go.SliceType go.uint64] "arr")))); KeyedElement (Some (KeyField "next_val"%go)) (ElementExpression #(W64 1))]))) in
    do:  ("ae1" <-[go.PointerType ArrayEditor] "$r0");;;
    let: "ae2" := (GoAlloc (go.PointerType ArrayEditor) (GoZeroVal (go.PointerType ArrayEditor) #())) in
    let: "$r0" := (GoAlloc ArrayEditor (CompositeLiteral ArrayEditor (LiteralValue [KeyedElement (Some (KeyField "s"%go)) (ElementExpression (let: "$s" := (![go.SliceType go.uint64] "arr") in
     Slice (go.SliceType go.uint64) ("$s", #(W64 1), FuncResolve go.len [go.SliceType go.uint64] #() (![go.SliceType go.uint64] "arr")))); KeyedElement (Some (KeyField "next_val"%go)) (ElementExpression #(W64 102))]))) in
    do:  ("ae2" <-[go.PointerType ArrayEditor] "$r0");;;
    do:  (let: "$a0" := (![go.SliceType go.uint64] "arr") in
    let: "$a1" := #(W64 103) in
    (MethodResolve (go.PointerType ArrayEditor) "Advance"%go #() (![go.PointerType ArrayEditor] "ae2")) "$a0" "$a1");;;
    do:  (let: "$a0" := (![go.SliceType go.uint64] "arr") in
    let: "$a1" := #(W64 104) in
    (MethodResolve (go.PointerType ArrayEditor) "Advance"%go #() (![go.PointerType ArrayEditor] "ae2")) "$a0" "$a1");;;
    do:  (let: "$a0" := (![go.SliceType go.uint64] "arr") in
    let: "$a1" := #(W64 105) in
    (MethodResolve (go.PointerType ArrayEditor) "Advance"%go #() (![go.PointerType ArrayEditor] "ae2")) "$a0" "$a1");;;
    do:  (let: "$a0" := (![go.SliceType go.uint64] "arr") in
    let: "$a1" := #(W64 2) in
    (MethodResolve (go.PointerType ArrayEditor) "Advance"%go #() (![go.PointerType ArrayEditor] "ae1")) "$a0" "$a1");;;
    do:  (let: "$a0" := (![go.SliceType go.uint64] "arr") in
    let: "$a1" := #(W64 3) in
    (MethodResolve (go.PointerType ArrayEditor) "Advance"%go #() (![go.PointerType ArrayEditor] "ae1")) "$a0" "$a1");;;
    do:  (let: "$a0" := (![go.SliceType go.uint64] "arr") in
    let: "$a1" := #(W64 4) in
    (MethodResolve (go.PointerType ArrayEditor) "Advance"%go #() (![go.PointerType ArrayEditor] "ae1")) "$a0" "$a1");;;
    do:  (let: "$a0" := (![go.SliceType go.uint64] "arr") in
    let: "$a1" := #(W64 5) in
    (MethodResolve (go.PointerType ArrayEditor) "Advance"%go #() (![go.PointerType ArrayEditor] "ae1")) "$a0" "$a1");;;
    (if: ((((![go.uint64] (IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "arr", #(W64 0)))) +⟨go.uint64⟩ (![go.uint64] (IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "arr", #(W64 1))))) +⟨go.uint64⟩ (![go.uint64] (IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "arr", #(W64 2))))) +⟨go.uint64⟩ (![go.uint64] (IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "arr", #(W64 3))))) ≥⟨go.uint64⟩ #(W64 100)
    then return: (#false)
    else do:  #());;;
    return: (((![go.uint64] (IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "arr", #(W64 3)))) =⟨go.uint64⟩ #(W64 4)) && ((![go.uint64] (IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "arr", #(W64 0)))) =⟨go.uint64⟩ #(W64 4)))).

Definition testSliceLiteral : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testSliceLiteral"%go.

(* go: slices.go:80:6 *)
Definition testSliceLiteralⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "bytes" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (CompositeLiteral (go.SliceType go.byte) (LiteralValue [KeyedElement None (ElementExpression #(W8 1)); KeyedElement None (ElementExpression #(W8 2))])) in
    do:  ("bytes" <-[go.SliceType go.byte] "$r0");;;
    let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.byte] (IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "bytes", #(W64 0)))) =⟨go.byte⟩ #(W8 1))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "ints" := (GoAlloc (go.SliceType go.uint64) (GoZeroVal (go.SliceType go.uint64) #())) in
    let: "$r0" := (CompositeLiteral (go.SliceType go.uint64) (LiteralValue [KeyedElement None (ElementExpression #(W64 1)); KeyedElement None (ElementExpression #(W64 2)); KeyedElement None (ElementExpression #(W64 3))])) in
    do:  ("ints" <-[go.SliceType go.uint64] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] (IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "ints", #(W64 1)))) =⟨go.uint64⟩ #(W64 2))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    return: (![go.bool] "ok")).

Definition testSliceAppend : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testSliceAppend"%go.

(* go: slices.go:89:6 *)
Definition testSliceAppendⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "bytes" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 0)) in
    do:  ("bytes" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "bytes") in
    let: "$a1" := ((let: "$sl0" := #(W8 1) in
    CompositeLiteral go.byte (LiteralValue [KeyedElement None (ElementExpression "$sl0")]))) in
    (FuncResolve go.append [go.SliceType go.byte] #()) "$a0" "$a1") in
    do:  ("bytes" <-[go.SliceType go.byte] "$r0");;;
    let: "newBytes" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (CompositeLiteral (go.SliceType go.byte) (LiteralValue [KeyedElement None (ElementExpression #(W8 2)); KeyedElement None (ElementExpression #(W8 3))])) in
    do:  ("newBytes" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "bytes") in
    let: "$a1" := (![go.SliceType go.byte] "newBytes") in
    (FuncResolve go.append [go.SliceType go.byte] #()) "$a0" "$a1") in
    do:  ("bytes" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((s_to_w64 (let: "$a0" := (![go.SliceType go.byte] "bytes") in
    (FuncResolve go.len [go.SliceType go.byte] #()) "$a0")) =⟨go.uint64⟩ #(W64 3))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.byte] (IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "bytes", #(W64 2)))) =⟨go.byte⟩ #(W8 3))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    return: (![go.bool] "ok")).

Definition Barⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "a"%go go.uint64);
  (go.FieldDecl "b"%go go.uint64)
].

Definition Bar : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/semantics.Bar"%go [].

Definition Fooⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "bar"%go Bar)
].

(* go: struct_pointers.go:14:17 *)
Definition Bar__mutateⁱᵐᵖˡ : val :=
  λ: "bar" <>,
    exception_do (let: "bar" := (GoAlloc (go.PointerType Bar) "bar") in
    let: "$r0" := #(W64 2) in
    do:  ((StructFieldRef Bar "a"%go (![go.PointerType Bar] "bar")) <-[go.uint64] "$r0");;;
    let: "$r0" := #(W64 3) in
    do:  ((StructFieldRef Bar "b"%go (![go.PointerType Bar] "bar")) <-[go.uint64] "$r0");;;
    return: #()).

Definition Foo : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/semantics.Foo"%go [].

(* go: struct_pointers.go:19:17 *)
Definition Foo__mutateBarⁱᵐᵖˡ : val :=
  λ: "foo" <>,
    exception_do (let: "foo" := (GoAlloc (go.PointerType Foo) "foo") in
    do:  ((MethodResolve (go.PointerType Bar) "mutate"%go #() (StructFieldRef Foo "bar"%go (![go.PointerType Foo] "foo"))) #());;;
    return: #()).

Definition testFooBarMutation : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testFooBarMutation"%go.

(* go: struct_pointers.go:23:6 *)
Definition testFooBarMutationⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc Foo (GoZeroVal Foo #())) in
    let: "$r0" := (CompositeLiteral Foo (LiteralValue [KeyedElement (Some (KeyField "bar"%go)) (CompositeLiteral Bar (LiteralValue [KeyedElement (Some (KeyField "a"%go)) (ElementExpression #(W64 0)); KeyedElement (Some (KeyField "b"%go)) (ElementExpression #(W64 0))]))])) in
    do:  ("x" <-[Foo] "$r0");;;
    do:  ((MethodResolve (go.PointerType Foo) "mutateBar"%go #() "x") #());;;
    return: ((![go.uint64] (StructFieldRef Bar "a"%go (StructFieldRef Foo "bar"%go "x"))) =⟨go.uint64⟩ #(W64 2))).

Definition TwoIntsⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "x"%go go.uint64);
  (go.FieldDecl "y"%go go.uint64)
].

Definition TwoInts : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/semantics.TwoInts"%go [].

Definition Sⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "a"%go go.uint64);
  (go.FieldDecl "b"%go TwoInts);
  (go.FieldDecl "c"%go go.bool)
].

Definition NewS : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.NewS"%go.

Definition S : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/semantics.S"%go [].

(* go: structs.go:14:6 *)
Definition NewSⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (GoAlloc S (CompositeLiteral S (LiteralValue [KeyedElement (Some (KeyField "a"%go)) (ElementExpression #(W64 2)); KeyedElement (Some (KeyField "b"%go)) (CompositeLiteral TwoInts (LiteralValue [KeyedElement (Some (KeyField "x"%go)) (ElementExpression #(W64 1)); KeyedElement (Some (KeyField "y"%go)) (ElementExpression #(W64 2))])); KeyedElement (Some (KeyField "c"%go)) (ElementExpression #true)])))).

(* go: structs.go:22:13 *)
Definition S__readAⁱᵐᵖˡ : val :=
  λ: "s" <>,
    exception_do (let: "s" := (GoAlloc (go.PointerType S) "s") in
    return: (![go.uint64] (StructFieldRef S "a"%go (![go.PointerType S] "s")))).

(* go: structs.go:26:13 *)
Definition S__readBⁱᵐᵖˡ : val :=
  λ: "s" <>,
    exception_do (let: "s" := (GoAlloc (go.PointerType S) "s") in
    return: (![TwoInts] (StructFieldRef S "b"%go (![go.PointerType S] "s")))).

(* go: structs.go:30:12 *)
Definition S__readBValⁱᵐᵖˡ : val :=
  λ: "s" <>,
    exception_do (let: "s" := (GoAlloc S "s") in
    return: (![TwoInts] (StructFieldRef S "b"%go "s"))).

(* go: structs.go:34:13 *)
Definition S__updateBValXⁱᵐᵖˡ : val :=
  λ: "s" "i",
    exception_do (let: "s" := (GoAlloc (go.PointerType S) "s") in
    let: "i" := (GoAlloc go.uint64 "i") in
    let: "$r0" := (![go.uint64] "i") in
    do:  ((StructFieldRef TwoInts "x"%go (StructFieldRef S "b"%go (![go.PointerType S] "s"))) <-[go.uint64] "$r0");;;
    return: #()).

(* go: structs.go:38:13 *)
Definition S__negateCⁱᵐᵖˡ : val :=
  λ: "s" <>,
    exception_do (let: "s" := (GoAlloc (go.PointerType S) "s") in
    let: "$r0" := (~ (![go.bool] (StructFieldRef S "c"%go (![go.PointerType S] "s")))) in
    do:  ((StructFieldRef S "c"%go (![go.PointerType S] "s")) <-[go.bool] "$r0");;;
    return: #()).

Definition testStructUpdates : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testStructUpdates"%go.

(* go: structs.go:42:6 *)
Definition testStructUpdatesⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "ns" := (GoAlloc (go.PointerType S) (GoZeroVal (go.PointerType S) #())) in
    let: "$r0" := ((FuncResolve NewS [] #()) #()) in
    do:  ("ns" <-[go.PointerType S] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && (((MethodResolve (go.PointerType S) "readA"%go #() (![go.PointerType S] "ns")) #()) =⟨go.uint64⟩ #(W64 2))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "b1" := (GoAlloc TwoInts (GoZeroVal TwoInts #())) in
    let: "$r0" := ((MethodResolve (go.PointerType S) "readB"%go #() (![go.PointerType S] "ns")) #()) in
    do:  ("b1" <-[TwoInts] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] (StructFieldRef TwoInts "x"%go "b1")) =⟨go.uint64⟩ #(W64 1))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    do:  ((MethodResolve (go.PointerType S) "negateC"%go #() (![go.PointerType S] "ns")) #());;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.bool] (StructFieldRef S "c"%go (![go.PointerType S] "ns"))) =⟨go.bool⟩ #false)) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := #(W64 3) in
    do:  ((StructFieldRef TwoInts "x"%go "b1") <-[go.uint64] "$r0");;;
    let: "b2" := (GoAlloc TwoInts (GoZeroVal TwoInts #())) in
    let: "$r0" := ((MethodResolve (go.PointerType S) "readB"%go #() (![go.PointerType S] "ns")) #()) in
    do:  ("b2" <-[TwoInts] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] (StructFieldRef TwoInts "x"%go "b2")) =⟨go.uint64⟩ #(W64 1))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "b3" := (GoAlloc (go.PointerType TwoInts) (GoZeroVal (go.PointerType TwoInts) #())) in
    let: "$r0" := (StructFieldRef S "b"%go (![go.PointerType S] "ns")) in
    do:  ("b3" <-[go.PointerType TwoInts] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] (StructFieldRef TwoInts "x"%go (![go.PointerType TwoInts] "b3"))) =⟨go.uint64⟩ #(W64 1))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    do:  (let: "$a0" := #(W64 4) in
    (MethodResolve (go.PointerType S) "updateBValX"%go #() (![go.PointerType S] "ns")) "$a0");;;
    let: "$r0" := ((![go.bool] "ok") && ((StructFieldGet TwoInts "x" ((MethodResolve (go.PointerType S) "readBVal"%go #() (![go.PointerType S] "ns")) #())) =⟨go.uint64⟩ #(W64 4))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    return: (![go.bool] "ok")).

Definition testNestedStructUpdates : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testNestedStructUpdates"%go.

(* go: structs.go:65:6 *)
Definition testNestedStructUpdatesⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "ns" := (GoAlloc (go.PointerType S) (GoZeroVal (go.PointerType S) #())) in
    let: "$r0" := ((FuncResolve NewS [] #()) #()) in
    do:  ("ns" <-[go.PointerType S] "$r0");;;
    let: "$r0" := #(W64 5) in
    do:  ((StructFieldRef TwoInts "x"%go (StructFieldRef S "b"%go (![go.PointerType S] "ns"))) <-[go.uint64] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] (StructFieldRef TwoInts "x"%go (StructFieldRef S "b"%go (![go.PointerType S] "ns")))) =⟨go.uint64⟩ #(W64 5))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((FuncResolve NewS [] #()) #()) in
    do:  ("ns" <-[go.PointerType S] "$r0");;;
    let: "p" := (GoAlloc (go.PointerType TwoInts) (GoZeroVal (go.PointerType TwoInts) #())) in
    let: "$r0" := (StructFieldRef S "b"%go (![go.PointerType S] "ns")) in
    do:  ("p" <-[go.PointerType TwoInts] "$r0");;;
    let: "$r0" := #(W64 5) in
    do:  ((StructFieldRef TwoInts "x"%go (![go.PointerType TwoInts] "p")) <-[go.uint64] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] (StructFieldRef TwoInts "x"%go (StructFieldRef S "b"%go (![go.PointerType S] "ns")))) =⟨go.uint64⟩ #(W64 5))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((FuncResolve NewS [] #()) #()) in
    do:  ("ns" <-[go.PointerType S] "$r0");;;
    let: "$r0" := (StructFieldRef S "b"%go (![go.PointerType S] "ns")) in
    do:  ("p" <-[go.PointerType TwoInts] "$r0");;;
    let: "$r0" := #(W64 5) in
    do:  ((StructFieldRef TwoInts "x"%go (StructFieldRef S "b"%go (![go.PointerType S] "ns"))) <-[go.uint64] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] (StructFieldRef TwoInts "x"%go (![go.PointerType TwoInts] "p"))) =⟨go.uint64⟩ #(W64 5))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((FuncResolve NewS [] #()) #()) in
    do:  ("ns" <-[go.PointerType S] "$r0");;;
    let: "$r0" := (StructFieldRef S "b"%go (![go.PointerType S] "ns")) in
    do:  ("p" <-[go.PointerType TwoInts] "$r0");;;
    let: "$r0" := #(W64 5) in
    do:  ((StructFieldRef TwoInts "x"%go (StructFieldRef S "b"%go (![go.PointerType S] "ns"))) <-[go.uint64] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] (StructFieldRef TwoInts "x"%go (![go.PointerType TwoInts] "p"))) =⟨go.uint64⟩ #(W64 5))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    return: (![go.bool] "ok")).

Definition testStructConstructions : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testStructConstructions"%go.

(* go: structs.go:90:6 *)
Definition testStructConstructionsⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "p1" := (GoAlloc (go.PointerType TwoInts) (GoZeroVal (go.PointerType TwoInts) #())) in
    let: "p2" := (GoAlloc TwoInts (GoZeroVal TwoInts #())) in
    let: "p3" := (GoAlloc TwoInts (GoZeroVal TwoInts #())) in
    let: "$r0" := (CompositeLiteral TwoInts (LiteralValue [KeyedElement (Some (KeyField "y"%go)) (ElementExpression #(W64 0)); KeyedElement (Some (KeyField "x"%go)) (ElementExpression #(W64 0))])) in
    do:  ("p3" <-[TwoInts] "$r0");;;
    let: "p4" := (GoAlloc TwoInts (GoZeroVal TwoInts #())) in
    let: "$r0" := (CompositeLiteral TwoInts (LiteralValue [KeyedElement (Some (KeyField "x"%go)) (ElementExpression #(W64 0)); KeyedElement (Some (KeyField "y"%go)) (ElementExpression #(W64 0))])) in
    do:  ("p4" <-[TwoInts] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.PointerType TwoInts] "p1") =⟨go.PointerType TwoInts⟩ #null)) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := (GoAlloc TwoInts (GoZeroVal TwoInts #())) in
    do:  ("p1" <-[go.PointerType TwoInts] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![TwoInts] "p2") =⟨go.StructType [
      (go.FieldDecl "x"%go go.uint64);
      (go.FieldDecl "y"%go go.uint64)
    ]⟩ (![TwoInts] "p3"))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![TwoInts] "p3") =⟨go.StructType [
      (go.FieldDecl "x"%go go.uint64);
      (go.FieldDecl "y"%go go.uint64)
    ]⟩ (![TwoInts] "p4"))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![TwoInts] "p4") =⟨go.StructType [
      (go.FieldDecl "x"%go go.uint64);
      (go.FieldDecl "y"%go go.uint64)
    ]⟩ (![TwoInts] (![go.PointerType TwoInts] "p1")))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ("p4" ≠⟨go.PointerType TwoInts⟩ (![go.PointerType TwoInts] "p1"))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    return: (![go.bool] "ok")).

Definition testIncompleteStruct : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testIncompleteStruct"%go.

(* go: structs.go:109:6 *)
Definition testIncompleteStructⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "p1" := (GoAlloc TwoInts (GoZeroVal TwoInts #())) in
    let: "$r0" := (CompositeLiteral TwoInts (LiteralValue [KeyedElement (Some (KeyField "x"%go)) (ElementExpression #(W64 0))])) in
    do:  ("p1" <-[TwoInts] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] (StructFieldRef TwoInts "y"%go "p1")) =⟨go.uint64⟩ #(W64 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "p2" := (GoAlloc S (GoZeroVal S #())) in
    let: "$r0" := (CompositeLiteral S (LiteralValue [KeyedElement (Some (KeyField "a"%go)) (ElementExpression #(W64 2))])) in
    do:  ("p2" <-[S] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] (StructFieldRef TwoInts "x"%go (StructFieldRef S "b"%go "p2"))) =⟨go.uint64⟩ #(W64 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.bool] (StructFieldRef S "c"%go "p2")) =⟨go.bool⟩ #false)) in
    do:  ("ok" <-[go.bool] "$r0");;;
    return: (![go.bool] "ok")).

Definition StructWrapⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "i"%go go.uint64)
].

Definition testStoreInStructVar : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testStoreInStructVar"%go.

Definition StructWrap : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/semantics.StructWrap"%go [].

(* go: structs.go:126:6 *)
Definition testStoreInStructVarⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "p" := (GoAlloc StructWrap (GoZeroVal StructWrap #())) in
    let: "$r0" := (CompositeLiteral StructWrap (LiteralValue [KeyedElement (Some (KeyField "i"%go)) (ElementExpression #(W64 0))])) in
    do:  ("p" <-[StructWrap] "$r0");;;
    let: "$r0" := #(W64 5) in
    do:  ((StructFieldRef StructWrap "i"%go "p") <-[go.uint64] "$r0");;;
    return: ((![go.uint64] (StructFieldRef StructWrap "i"%go "p")) =⟨go.uint64⟩ #(W64 5))).

Definition testStoreInStructPointerVar : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testStoreInStructPointerVar"%go.

(* go: structs.go:132:6 *)
Definition testStoreInStructPointerVarⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "p" := (GoAlloc (go.PointerType StructWrap) (GoZeroVal (go.PointerType StructWrap) #())) in
    let: "$r0" := (GoAlloc StructWrap (GoZeroVal StructWrap #())) in
    do:  ("p" <-[go.PointerType StructWrap] "$r0");;;
    let: "$r0" := #(W64 5) in
    do:  ((StructFieldRef StructWrap "i"%go (![go.PointerType StructWrap] "p")) <-[go.uint64] "$r0");;;
    return: ((![go.uint64] (StructFieldRef StructWrap "i"%go (![go.PointerType StructWrap] "p"))) =⟨go.uint64⟩ #(W64 5))).

Definition testStoreComposite : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testStoreComposite"%go.

(* go: structs.go:138:6 *)
Definition testStoreCompositeⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "p" := (GoAlloc (go.PointerType TwoInts) (GoZeroVal (go.PointerType TwoInts) #())) in
    let: "$r0" := (GoAlloc TwoInts (GoZeroVal TwoInts #())) in
    do:  ("p" <-[go.PointerType TwoInts] "$r0");;;
    let: "$r0" := (CompositeLiteral TwoInts (LiteralValue [KeyedElement (Some (KeyField "x"%go)) (ElementExpression #(W64 3)); KeyedElement (Some (KeyField "y"%go)) (ElementExpression #(W64 4))])) in
    do:  ((![go.PointerType TwoInts] "p") <-[TwoInts] "$r0");;;
    return: ((![go.uint64] (StructFieldRef TwoInts "y"%go (![go.PointerType TwoInts] "p"))) =⟨go.uint64⟩ #(W64 4))).

Definition testStoreSlice : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testStoreSlice"%go.

(* go: structs.go:144:6 *)
Definition testStoreSliceⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "p" := (GoAlloc (go.PointerType (go.SliceType go.uint64)) (GoZeroVal (go.PointerType (go.SliceType go.uint64)) #())) in
    let: "$r0" := (GoAlloc (go.SliceType go.uint64) (GoZeroVal (go.SliceType go.uint64) #())) in
    do:  ("p" <-[go.PointerType (go.SliceType go.uint64)] "$r0");;;
    let: "s" := (GoAlloc (go.SliceType go.uint64) (GoZeroVal (go.SliceType go.uint64) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType go.uint64] #()) #(W64 3)) in
    do:  ("s" <-[go.SliceType go.uint64] "$r0");;;
    let: "$r0" := (![go.SliceType go.uint64] "s") in
    do:  ((![go.PointerType (go.SliceType go.uint64)] "p") <-[go.SliceType go.uint64] "$r0");;;
    return: ((s_to_w64 (let: "$a0" := (![go.SliceType go.uint64] (![go.PointerType (go.SliceType go.uint64)] "p")) in
     (FuncResolve go.len [go.SliceType go.uint64] #()) "$a0")) =⟨go.uint64⟩ #(W64 3))).

Definition StructWithFuncⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "fn"%go (go.FunctionType (go.Signature [go.uint64] false [go.uint64])))
].

Definition testStructFieldFunc : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testStructFieldFunc"%go.

Definition StructWithFunc : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/semantics.StructWithFunc"%go [].

(* go: structs.go:155:6 *)
Definition testStructFieldFuncⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "a" := (GoAlloc (go.PointerType StructWithFunc) (GoZeroVal (go.PointerType StructWithFunc) #())) in
    let: "$r0" := (GoAlloc StructWithFunc (GoZeroVal StructWithFunc #())) in
    do:  ("a" <-[go.PointerType StructWithFunc] "$r0");;;
    let: "$r0" := (λ: "arg",
      exception_do (let: "arg" := (GoAlloc go.uint64 "arg") in
      return: ((![go.uint64] "arg") *⟨go.uint64⟩ #(W64 2)))
      ) in
    do:  ((StructFieldRef StructWithFunc "fn"%go (![go.PointerType StructWithFunc] "a")) <-[go.FunctionType (go.Signature [go.uint64] false [go.uint64])] "$r0");;;
    return: ((let: "$a0" := #(W64 10) in
     (![go.FunctionType (go.Signature [go.uint64] false [go.uint64])] (StructFieldRef StructWithFunc "fn"%go (![go.PointerType StructWithFunc] "a"))) "$a0") =⟨go.uint64⟩ #(W64 20))).

Definition testSwitchVal : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testSwitchVal"%go.

(* go: switch.go:3:6 *)
Definition testSwitchValⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("x" <-[go.uint64] "$r0");;;
    let: "$sw" := (![go.uint64] "x") in
    (if: "$sw" =⟨go.uint64⟩ #(W64 0)
    then return: (#true)
    else
      (if: "$sw" =⟨go.uint64⟩ #(W64 1)
      then return: (#false)
      else return: (#false)))).

Definition testSwitchMultiple : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testSwitchMultiple"%go.

(* go: switch.go:15:6 *)
Definition testSwitchMultipleⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("x" <-[go.uint64] "$r0");;;
    let: "$sw" := (![go.uint64] "x") in
    (if: ("$sw" =⟨go.uint64⟩ #(W64 1)) || ("$sw" =⟨go.uint64⟩ #(W64 10))
    then return: (#false)
    else
      (if: "$sw" =⟨go.uint64⟩ #(W64 0)
      then return: (#true)
      else do:  #()));;;
    return: (#false)).

Definition testSwitchDefaultTrue : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testSwitchDefaultTrue"%go.

(* go: switch.go:26:6 *)
Definition testSwitchDefaultTrueⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 1) in
    do:  ("x" <-[go.uint64] "$r0");;;
    let: "$sw" := #true in
    (if: "$sw" =⟨go.bool⟩ #false
    then return: (#false)
    else
      (if: "$sw" =⟨go.bool⟩ ((![go.uint64] "x") =⟨go.uint64⟩ #(W64 2))
      then return: (#false)
      else return: (#true)))).

Definition switchConcreteⁱᵐᵖˡ : go.type := go.StructType [
].

Definition switchInterfaceⁱᵐᵖˡ : go.type := go.InterfaceType [go.MethodElem #"marker"%go (go.Signature [] false [])].

Definition switchConcrete : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/semantics.switchConcrete"%go [].

(* go: switch.go:45:26 *)
Definition switchConcrete__markerⁱᵐᵖˡ : val :=
  λ: "c" <>,
    exception_do (let: "c" := (GoAlloc (go.PointerType switchConcrete) "c") in
    do:  #()).

Definition testSwitchConversion : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testSwitchConversion"%go.

Definition switchInterface : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/semantics.switchInterface"%go [].

(* go: switch.go:48:6 *)
Definition testSwitchConversionⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "v" := (GoAlloc (go.PointerType switchConcrete) (GoZeroVal (go.PointerType switchConcrete) #())) in
    let: "$r0" := (GoAlloc switchConcrete (CompositeLiteral switchConcrete (LiteralValue []))) in
    do:  ("v" <-[go.PointerType switchConcrete] "$r0");;;
    let: "x" := (GoAlloc switchInterface (GoZeroVal switchInterface #())) in
    let: "$r0" := (InterfaceMake (go.PointerType switchConcrete) (![go.PointerType switchConcrete] "v")) in
    do:  ("x" <-[switchInterface] "$r0");;;
    let: "$sw" := (![switchInterface] "x") in
    (if: "$sw" =⟨switchInterface⟩ (InterfaceMake (go.PointerType switchConcrete) (![go.PointerType switchConcrete] "v"))
    then do:  #()
    else return: (#false));;;
    let: "$sw" := (![go.PointerType switchConcrete] "v") in
    (if: (InterfaceMake (go.PointerType switchConcrete) "$sw") =⟨switchInterface⟩ (![switchInterface] "x")
    then do:  #()
    else return: (#false));;;
    return: (#true)).

Definition testPointerAssignment : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testPointerAssignment"%go.

(* go: vars.go:3:6 *)
Definition testPointerAssignmentⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #true in
    do:  ("x" <-[go.bool] "$r0");;;
    return: (![go.bool] "x")).

Definition testAddressOfLocal : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testAddressOfLocal"%go.

(* go: vars.go:9:6 *)
Definition testAddressOfLocalⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #false in
    do:  ("x" <-[go.bool] "$r0");;;
    let: "xptr" := (GoAlloc (go.PointerType go.bool) (GoZeroVal (go.PointerType go.bool) #())) in
    let: "$r0" := "x" in
    do:  ("xptr" <-[go.PointerType go.bool] "$r0");;;
    let: "$r0" := #true in
    do:  ((![go.PointerType go.bool] "xptr") <-[go.bool] "$r0");;;
    return: ((![go.bool] "x") && (![go.bool] (![go.PointerType go.bool] "xptr")))).

Definition testAnonymousAssign : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testAnonymousAssign"%go.

(* go: vars.go:16:6 *)
Definition testAnonymousAssignⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "$r0" := (#(W64 1) +⟨go.uint64⟩ #(W64 2)) in
    do:  "$r0";;;
    return: (#true)).

(* 10 is completely arbitrary *)
Definition MaxTxnWrites : val := #(W64 10).

Definition logLength : val := #(W64 21).

Definition Logⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "d"%go disk.Disk);
  (go.FieldDecl "l"%go (go.PointerType sync.Mutex));
  (go.FieldDecl "cache"%go (go.MapType go.uint64 (go.SliceType go.byte)));
  (go.FieldDecl "length"%go (go.PointerType go.uint64))
].

Definition intToBlock : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.intToBlock"%go.

(* go: wal.go:25:6 *)
Definition intToBlockⁱᵐᵖˡ : val :=
  λ: "a",
    exception_do (let: "a" := (GoAlloc go.uint64 "a") in
    let: "b" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) disk.BlockSize) in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    do:  (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (![go.uint64] "a") in
    (FuncResolve primitive.UInt64Put [] #()) "$a0" "$a1");;;
    return: (![go.SliceType go.byte] "b")).

Definition blockToInt : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.blockToInt"%go.

(* go: wal.go:31:6 *)
Definition blockToIntⁱᵐᵖˡ : val :=
  λ: "v",
    exception_do (let: "v" := (GoAlloc (go.SliceType go.byte) "v") in
    let: "a" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "v") in
    (FuncResolve primitive.UInt64Get [] #()) "$a0") in
    do:  ("a" <-[go.uint64] "$r0");;;
    return: (![go.uint64] "a")).

Definition New : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.New"%go.

Definition Log : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/semantics.Log"%go [].

(* New initializes a fresh log

   go: wal.go:37:6 *)
Definition Newⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "d" := (GoAlloc disk.Disk (GoZeroVal disk.Disk #())) in
    let: "$r0" := ((FuncResolve disk.Get [] #()) #()) in
    do:  ("d" <-[disk.Disk] "$r0");;;
    let: "diskSize" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := ((MethodResolve disk.Disk "Size"%go #() (![disk.Disk] "d")) #()) in
    do:  ("diskSize" <-[go.uint64] "$r0");;;
    (if: (![go.uint64] "diskSize") ≤⟨go.uint64⟩ logLength
    then
      do:  (let: "$a0" := (InterfaceMake go.string #"disk is too small to host log"%go) in
      (FuncResolve go.panic [] #()) "$a0")
    else do:  #());;;
    let: "cache" := (GoAlloc (go.MapType go.uint64 (go.SliceType go.byte)) (GoZeroVal (go.MapType go.uint64 (go.SliceType go.byte)) #())) in
    let: "$r0" := ((FuncResolve go.make1 [go.MapType go.uint64 (go.SliceType go.byte)] #()) #()) in
    do:  ("cache" <-[go.MapType go.uint64 (go.SliceType go.byte)] "$r0");;;
    let: "header" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (let: "$a0" := #(W64 0) in
    (FuncResolve intToBlock [] #()) "$a0") in
    do:  ("header" <-[go.SliceType go.byte] "$r0");;;
    do:  (let: "$a0" := #(W64 0) in
    let: "$a1" := (![go.SliceType go.byte] "header") in
    (MethodResolve disk.Disk "Write"%go #() (![disk.Disk] "d")) "$a0" "$a1");;;
    let: "lengthPtr" := (GoAlloc (go.PointerType go.uint64) (GoZeroVal (go.PointerType go.uint64) #())) in
    let: "$r0" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    do:  ("lengthPtr" <-[go.PointerType go.uint64] "$r0");;;
    let: "$r0" := #(W64 0) in
    do:  ((![go.PointerType go.uint64] "lengthPtr") <-[go.uint64] "$r0");;;
    let: "l" := (GoAlloc (go.PointerType sync.Mutex) (GoZeroVal (go.PointerType sync.Mutex) #())) in
    let: "$r0" := (GoAlloc sync.Mutex (GoZeroVal sync.Mutex #())) in
    do:  ("l" <-[go.PointerType sync.Mutex] "$r0");;;
    return: (CompositeLiteral Log (LiteralValue [KeyedElement (Some (KeyField "d"%go)) (ElementExpression (![disk.Disk] "d")); KeyedElement (Some (KeyField "cache"%go)) (ElementExpression (![go.MapType go.uint64 (go.SliceType go.byte)] "cache")); KeyedElement (Some (KeyField "length"%go)) (ElementExpression (![go.PointerType go.uint64] "lengthPtr")); KeyedElement (Some (KeyField "l"%go)) (ElementExpression (![go.PointerType sync.Mutex] "l"))]))).

(* go: wal.go:52:14 *)
Definition Log__lockⁱᵐᵖˡ : val :=
  λ: "l" <>,
    exception_do (let: "l" := (GoAlloc Log "l") in
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go #() (![go.PointerType sync.Mutex] (StructFieldRef Log "l"%go "l"))) #());;;
    return: #()).

(* go: wal.go:56:14 *)
Definition Log__unlockⁱᵐᵖˡ : val :=
  λ: "l" <>,
    exception_do (let: "l" := (GoAlloc Log "l") in
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go #() (![go.PointerType sync.Mutex] (StructFieldRef Log "l"%go "l"))) #());;;
    return: #()).

(* BeginTxn allocates space for a new transaction in the log.

   Returns true if the allocation succeeded.

   go: wal.go:63:14 *)
Definition Log__BeginTxnⁱᵐᵖˡ : val :=
  λ: "l" <>,
    exception_do (let: "l" := (GoAlloc Log "l") in
    do:  ((MethodResolve Log "lock"%go #() (![Log] "l")) #());;;
    let: "length" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (![go.uint64] (![go.PointerType go.uint64] (StructFieldRef Log "length"%go "l"))) in
    do:  ("length" <-[go.uint64] "$r0");;;
    (if: (![go.uint64] "length") =⟨go.uint64⟩ #(W64 0)
    then
      do:  ((MethodResolve Log "unlock"%go #() (![Log] "l")) #());;;
      return: (#true)
    else do:  #());;;
    do:  ((MethodResolve Log "unlock"%go #() (![Log] "l")) #());;;
    return: (#false)).

(* Read from the logical disk.

   Reads must go through the log to return committed but un-applied writes.

   go: wal.go:77:14 *)
Definition Log__Readⁱᵐᵖˡ : val :=
  λ: "l" "a",
    exception_do (let: "l" := (GoAlloc Log "l") in
    let: "a" := (GoAlloc go.uint64 "a") in
    do:  ((MethodResolve Log "lock"%go #() (![Log] "l")) #());;;
    let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "v" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: ("$ret0", "$ret1") := (map.get (![go.MapType go.uint64 (go.SliceType go.byte)] (StructFieldRef Log "cache"%go "l")) (![go.uint64] "a")) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("v" <-[go.SliceType go.byte] "$r0");;;
    do:  ("ok" <-[go.bool] "$r1");;;
    (if: ![go.bool] "ok"
    then
      do:  ((MethodResolve Log "unlock"%go #() (![Log] "l")) #());;;
      return: (![go.SliceType go.byte] "v")
    else do:  #());;;
    do:  ((MethodResolve Log "unlock"%go #() (![Log] "l")) #());;;
    let: "dv" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (let: "$a0" := (logLength +⟨go.uint64⟩ (![go.uint64] "a")) in
    (MethodResolve disk.Disk "Read"%go #() (![disk.Disk] (StructFieldRef Log "d"%go "l"))) "$a0") in
    do:  ("dv" <-[go.SliceType go.byte] "$r0");;;
    return: (![go.SliceType go.byte] "dv")).

(* go: wal.go:90:14 *)
Definition Log__Sizeⁱᵐᵖˡ : val :=
  λ: "l" <>,
    exception_do (let: "l" := (GoAlloc Log "l") in
    let: "sz" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := ((MethodResolve disk.Disk "Size"%go #() (![disk.Disk] (StructFieldRef Log "d"%go "l"))) #()) in
    do:  ("sz" <-[go.uint64] "$r0");;;
    return: ((![go.uint64] "sz") -⟨go.uint64⟩ logLength)).

(* Write to the disk through the log.

   go: wal.go:97:14 *)
Definition Log__Writeⁱᵐᵖˡ : val :=
  λ: "l" "a" "v",
    exception_do (let: "l" := (GoAlloc Log "l") in
    let: "v" := (GoAlloc (go.SliceType go.byte) "v") in
    let: "a" := (GoAlloc go.uint64 "a") in
    do:  ((MethodResolve Log "lock"%go #() (![Log] "l")) #());;;
    let: "length" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (![go.uint64] (![go.PointerType go.uint64] (StructFieldRef Log "length"%go "l"))) in
    do:  ("length" <-[go.uint64] "$r0");;;
    (if: (![go.uint64] "length") ≥⟨go.uint64⟩ MaxTxnWrites
    then
      do:  (let: "$a0" := (InterfaceMake go.string #"transaction is at capacity"%go) in
      (FuncResolve go.panic [] #()) "$a0")
    else do:  #());;;
    let: "aBlock" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (let: "$a0" := (![go.uint64] "a") in
    (FuncResolve intToBlock [] #()) "$a0") in
    do:  ("aBlock" <-[go.SliceType go.byte] "$r0");;;
    let: "nextAddr" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (#(W64 1) +⟨go.uint64⟩ (#(W64 2) *⟨go.uint64⟩ (![go.uint64] "length"))) in
    do:  ("nextAddr" <-[go.uint64] "$r0");;;
    do:  (let: "$a0" := (![go.uint64] "nextAddr") in
    let: "$a1" := (![go.SliceType go.byte] "aBlock") in
    (MethodResolve disk.Disk "Write"%go #() (![disk.Disk] (StructFieldRef Log "d"%go "l"))) "$a0" "$a1");;;
    do:  (let: "$a0" := ((![go.uint64] "nextAddr") +⟨go.uint64⟩ #(W64 1)) in
    let: "$a1" := (![go.SliceType go.byte] "v") in
    (MethodResolve disk.Disk "Write"%go #() (![disk.Disk] (StructFieldRef Log "d"%go "l"))) "$a0" "$a1");;;
    let: "$r0" := (![go.SliceType go.byte] "v") in
    do:  (map.insert (![go.MapType go.uint64 (go.SliceType go.byte)] (StructFieldRef Log "cache"%go "l")) (![go.uint64] "a") "$r0");;;
    let: "$r0" := ((![go.uint64] "length") +⟨go.uint64⟩ #(W64 1)) in
    do:  ((![go.PointerType go.uint64] (StructFieldRef Log "length"%go "l")) <-[go.uint64] "$r0");;;
    do:  ((MethodResolve Log "unlock"%go #() (![Log] "l")) #());;;
    return: #()).

(* Commit the current transaction.

   go: wal.go:113:14 *)
Definition Log__Commitⁱᵐᵖˡ : val :=
  λ: "l" <>,
    exception_do (let: "l" := (GoAlloc Log "l") in
    do:  ((MethodResolve Log "lock"%go #() (![Log] "l")) #());;;
    let: "length" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (![go.uint64] (![go.PointerType go.uint64] (StructFieldRef Log "length"%go "l"))) in
    do:  ("length" <-[go.uint64] "$r0");;;
    do:  ((MethodResolve Log "unlock"%go #() (![Log] "l")) #());;;
    let: "header" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (let: "$a0" := (![go.uint64] "length") in
    (FuncResolve intToBlock [] #()) "$a0") in
    do:  ("header" <-[go.SliceType go.byte] "$r0");;;
    do:  (let: "$a0" := #(W64 0) in
    let: "$a1" := (![go.SliceType go.byte] "header") in
    (MethodResolve disk.Disk "Write"%go #() (![disk.Disk] (StructFieldRef Log "d"%go "l"))) "$a0" "$a1");;;
    return: #()).

Definition getLogEntry : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.getLogEntry"%go.

(* go: wal.go:122:6 *)
Definition getLogEntryⁱᵐᵖˡ : val :=
  λ: "d" "logOffset",
    exception_do (let: "logOffset" := (GoAlloc go.uint64 "logOffset") in
    let: "d" := (GoAlloc disk.Disk "d") in
    let: "diskAddr" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (#(W64 1) +⟨go.uint64⟩ (#(W64 2) *⟨go.uint64⟩ (![go.uint64] "logOffset"))) in
    do:  ("diskAddr" <-[go.uint64] "$r0");;;
    let: "aBlock" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (let: "$a0" := (![go.uint64] "diskAddr") in
    (MethodResolve disk.Disk "Read"%go #() (![disk.Disk] "d")) "$a0") in
    do:  ("aBlock" <-[go.SliceType go.byte] "$r0");;;
    let: "a" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "aBlock") in
    (FuncResolve blockToInt [] #()) "$a0") in
    do:  ("a" <-[go.uint64] "$r0");;;
    let: "v" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (let: "$a0" := ((![go.uint64] "diskAddr") +⟨go.uint64⟩ #(W64 1)) in
    (MethodResolve disk.Disk "Read"%go #() (![disk.Disk] "d")) "$a0") in
    do:  ("v" <-[go.SliceType go.byte] "$r0");;;
    return: (![go.uint64] "a", ![go.SliceType go.byte] "v")).

Definition applyLog : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.applyLog"%go.

(* applyLog assumes we are running sequentially

   go: wal.go:131:6 *)
Definition applyLogⁱᵐᵖˡ : val :=
  λ: "d" "length",
    exception_do (let: "length" := (GoAlloc go.uint64 "length") in
    let: "d" := (GoAlloc disk.Disk "d") in
    (let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (if: (![go.uint64] "i") <⟨go.uint64⟩ (![go.uint64] "length")
      then
        let: "v" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
        let: "a" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
        let: ("$ret0", "$ret1") := (let: "$a0" := (![disk.Disk] "d") in
        let: "$a1" := (![go.uint64] "i") in
        (FuncResolve getLogEntry [] #()) "$a0" "$a1") in
        let: "$r0" := "$ret0" in
        let: "$r1" := "$ret1" in
        do:  ("a" <-[go.uint64] "$r0");;;
        do:  ("v" <-[go.SliceType go.byte] "$r1");;;
        do:  (let: "$a0" := (logLength +⟨go.uint64⟩ (![go.uint64] "a")) in
        let: "$a1" := (![go.SliceType go.byte] "v") in
        (MethodResolve disk.Disk "Write"%go #() (![disk.Disk] "d")) "$a0" "$a1");;;
        let: "$r0" := ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 1)) in
        do:  ("i" <-[go.uint64] "$r0");;;
        continue: #()
      else do:  #());;;
      break: #()));;;
    return: #()).

Definition clearLog : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.clearLog"%go.

(* go: wal.go:142:6 *)
Definition clearLogⁱᵐᵖˡ : val :=
  λ: "d",
    exception_do (let: "d" := (GoAlloc disk.Disk "d") in
    let: "header" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (let: "$a0" := #(W64 0) in
    (FuncResolve intToBlock [] #()) "$a0") in
    do:  ("header" <-[go.SliceType go.byte] "$r0");;;
    do:  (let: "$a0" := #(W64 0) in
    let: "$a1" := (![go.SliceType go.byte] "header") in
    (MethodResolve disk.Disk "Write"%go #() (![disk.Disk] "d")) "$a0" "$a1");;;
    return: #()).

(* Apply all the committed transactions.

   Frees all the space in the log.

   go: wal.go:150:14 *)
Definition Log__Applyⁱᵐᵖˡ : val :=
  λ: "l" <>,
    exception_do (let: "l" := (GoAlloc Log "l") in
    do:  ((MethodResolve Log "lock"%go #() (![Log] "l")) #());;;
    let: "length" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (![go.uint64] (![go.PointerType go.uint64] (StructFieldRef Log "length"%go "l"))) in
    do:  ("length" <-[go.uint64] "$r0");;;
    do:  (let: "$a0" := (![disk.Disk] (StructFieldRef Log "d"%go "l")) in
    let: "$a1" := (![go.uint64] "length") in
    (FuncResolve applyLog [] #()) "$a0" "$a1");;;
    do:  (let: "$a0" := (![disk.Disk] (StructFieldRef Log "d"%go "l")) in
    (FuncResolve clearLog [] #()) "$a0");;;
    let: "$r0" := #(W64 0) in
    do:  ((![go.PointerType go.uint64] (StructFieldRef Log "length"%go "l")) <-[go.uint64] "$r0");;;
    do:  ((MethodResolve Log "unlock"%go #() (![Log] "l")) #());;;
    return: #()).

Definition Open : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.Open"%go.

(* Open recovers the log following a crash or shutdown

   go: wal.go:163:6 *)
Definition Openⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "d" := (GoAlloc disk.Disk (GoZeroVal disk.Disk #())) in
    let: "$r0" := ((FuncResolve disk.Get [] #()) #()) in
    do:  ("d" <-[disk.Disk] "$r0");;;
    let: "header" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (let: "$a0" := #(W64 0) in
    (MethodResolve disk.Disk "Read"%go #() (![disk.Disk] "d")) "$a0") in
    do:  ("header" <-[go.SliceType go.byte] "$r0");;;
    let: "length" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "header") in
    (FuncResolve blockToInt [] #()) "$a0") in
    do:  ("length" <-[go.uint64] "$r0");;;
    do:  (let: "$a0" := (![disk.Disk] "d") in
    let: "$a1" := (![go.uint64] "length") in
    (FuncResolve applyLog [] #()) "$a0" "$a1");;;
    do:  (let: "$a0" := (![disk.Disk] "d") in
    (FuncResolve clearLog [] #()) "$a0");;;
    let: "cache" := (GoAlloc (go.MapType go.uint64 (go.SliceType go.byte)) (GoZeroVal (go.MapType go.uint64 (go.SliceType go.byte)) #())) in
    let: "$r0" := ((FuncResolve go.make1 [go.MapType go.uint64 (go.SliceType go.byte)] #()) #()) in
    do:  ("cache" <-[go.MapType go.uint64 (go.SliceType go.byte)] "$r0");;;
    let: "lengthPtr" := (GoAlloc (go.PointerType go.uint64) (GoZeroVal (go.PointerType go.uint64) #())) in
    let: "$r0" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    do:  ("lengthPtr" <-[go.PointerType go.uint64] "$r0");;;
    let: "$r0" := #(W64 0) in
    do:  ((![go.PointerType go.uint64] "lengthPtr") <-[go.uint64] "$r0");;;
    let: "l" := (GoAlloc (go.PointerType sync.Mutex) (GoZeroVal (go.PointerType sync.Mutex) #())) in
    let: "$r0" := (GoAlloc sync.Mutex (GoZeroVal sync.Mutex #())) in
    do:  ("l" <-[go.PointerType sync.Mutex] "$r0");;;
    return: (CompositeLiteral Log (LiteralValue [KeyedElement (Some (KeyField "d"%go)) (ElementExpression (![disk.Disk] "d")); KeyedElement (Some (KeyField "cache"%go)) (ElementExpression (![go.MapType go.uint64 (go.SliceType go.byte)] "cache")); KeyedElement (Some (KeyField "length"%go)) (ElementExpression (![go.PointerType go.uint64] "lengthPtr")); KeyedElement (Some (KeyField "l"%go)) (ElementExpression (![go.PointerType sync.Mutex] "l"))]))).

Definition disabled_testWal : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.disabled_testWal"%go.

(* disabled since performance is quite poor

   go: wal.go:178:6 *)
Definition disabled_testWalⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "lg" := (GoAlloc Log (GoZeroVal Log #())) in
    let: "$r0" := ((FuncResolve New [] #()) #()) in
    do:  ("lg" <-[Log] "$r0");;;
    (if: (MethodResolve Log "BeginTxn"%go #() (![Log] "lg")) #()
    then
      do:  (let: "$a0" := #(W64 2) in
      let: "$a1" := (let: "$a0" := #(W64 11) in
      (FuncResolve intToBlock [] #()) "$a0") in
      (MethodResolve Log "Write"%go #() (![Log] "lg")) "$a0" "$a1")
    else do:  #());;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := (let: "$a0" := #(W64 2) in
    (MethodResolve Log "Read"%go #() (![Log] "lg")) "$a0") in
    (FuncResolve blockToInt [] #()) "$a0") =⟨go.uint64⟩ #(W64 11))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := (let: "$a0" := #(W64 0) in
    (MethodResolve disk.Disk "Read"%go #() (![disk.Disk] (StructFieldRef Log "d"%go "lg"))) "$a0") in
    (FuncResolve blockToInt [] #()) "$a0") =⟨go.uint64⟩ #(W64 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    do:  ((MethodResolve Log "Commit"%go #() (![Log] "lg")) #());;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := (let: "$a0" := #(W64 0) in
    (MethodResolve disk.Disk "Read"%go #() (![disk.Disk] (StructFieldRef Log "d"%go "lg"))) "$a0") in
    (FuncResolve blockToInt [] #()) "$a0") =⟨go.uint64⟩ #(W64 1))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    do:  ((MethodResolve Log "Apply"%go #() (![Log] "lg")) #());;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] (![go.PointerType go.uint64] (StructFieldRef Log "length"%go "lg"))) =⟨go.uint64⟩ #(W64 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    return: (![go.bool] "ok")).

Definition Uint32 : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/semantics.Uint32"%go [].

#[global] Instance info' : PkgInfo semantics.semantics :=
  {|
    pkg_imported_pkgs := [code.github_com.goose_lang.primitive.primitive; code.sync.sync; code.github_com.goose_lang.primitive.disk.disk];
  |}.

Definition initialize' : val :=
  λ: <>,
    package.init semantics.semantics (λ: <>,
      exception_do (do:  (disk.initialize' #());;;
      do:  (sync.initialize' #());;;
      do:  (primitive.initialize' #()))
      ).

Class unit_Assumptions `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
}.

Class Enc_Assumptions `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Enc'ptr_consume_unfold :: MethodUnfold (go.PointerType (Enc)) "consume" (Enc__consumeⁱᵐᵖˡ);
}.

Class Dec_Assumptions `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Dec'ptr_consume_unfold :: MethodUnfold (go.PointerType (Dec)) "consume" (Dec__consumeⁱᵐᵖˡ);
}.

Class Editor_Assumptions `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Editor'ptr_AdvanceReturn_unfold :: MethodUnfold (go.PointerType (Editor)) "AdvanceReturn" (Editor__AdvanceReturnⁱᵐᵖˡ);
}.

Class Pair_Assumptions `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
}.

Class Uint32_Assumptions `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
}.

Class geometryInterface_Assumptions `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] geometryInterface'ptr_Square_unfold :: MethodUnfold (geometryInterface) "Square" (geometryInterface__Squareⁱᵐᵖˡ);
  #[global] geometryInterface'ptr_Volume_unfold :: MethodUnfold (geometryInterface) "Volume" (geometryInterface__Volumeⁱᵐᵖˡ);
}.

Class SquareStruct_Assumptions `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] SquareStruct'ptr_Square_unfold :: MethodUnfold (SquareStruct) "Square" (SquareStruct__Squareⁱᵐᵖˡ);
  #[global] SquareStruct'ptr_Volume_unfold :: MethodUnfold (SquareStruct) "Volume" (SquareStruct__Volumeⁱᵐᵖˡ);
  #[global] SquareStruct'ptr_Square_unfold :: MethodUnfold (go.PointerType (SquareStruct)) "Square" (λ: "$r", MethodResolve (SquareStruct) Square #() (![(SquareStruct)] "$r");
  #[global] SquareStruct'ptr_Volume_unfold :: MethodUnfold (go.PointerType (SquareStruct)) "Volume" (λ: "$r", MethodResolve (SquareStruct) Volume #() (![(SquareStruct)] "$r");
}.

Class LoopStruct_Assumptions `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] LoopStruct'ptr_forLoopWait_unfold :: MethodUnfold (LoopStruct) "forLoopWait" (LoopStruct__forLoopWaitⁱᵐᵖˡ);
  #[global] LoopStruct'ptr_forLoopWait_unfold :: MethodUnfold (go.PointerType (LoopStruct)) "forLoopWait" (λ: "$r", MethodResolve (LoopStruct) forLoopWait #() (![(LoopStruct)] "$r");
}.

Class BoolTest_Assumptions `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
}.

Class ArrayEditor_Assumptions `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] ArrayEditor'ptr_Advance_unfold :: MethodUnfold (go.PointerType (ArrayEditor)) "Advance" (ArrayEditor__Advanceⁱᵐᵖˡ);
}.

Class Bar_Assumptions `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Bar'ptr_mutate_unfold :: MethodUnfold (go.PointerType (Bar)) "mutate" (Bar__mutateⁱᵐᵖˡ);
}.

Class Foo_Assumptions `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Foo'ptr_mutateBar_unfold :: MethodUnfold (go.PointerType (Foo)) "mutateBar" (Foo__mutateBarⁱᵐᵖˡ);
}.

Class TwoInts_Assumptions `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
}.

Class S_Assumptions `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] S'ptr_readBVal_unfold :: MethodUnfold (S) "readBVal" (S__readBValⁱᵐᵖˡ);
  #[global] S'ptr_negateC_unfold :: MethodUnfold (go.PointerType (S)) "negateC" (S__negateCⁱᵐᵖˡ);
  #[global] S'ptr_readA_unfold :: MethodUnfold (go.PointerType (S)) "readA" (S__readAⁱᵐᵖˡ);
  #[global] S'ptr_readB_unfold :: MethodUnfold (go.PointerType (S)) "readB" (S__readBⁱᵐᵖˡ);
  #[global] S'ptr_readBVal_unfold :: MethodUnfold (go.PointerType (S)) "readBVal" (λ: "$r", MethodResolve (S) readBVal #() (![(S)] "$r");
  #[global] S'ptr_updateBValX_unfold :: MethodUnfold (go.PointerType (S)) "updateBValX" (S__updateBValXⁱᵐᵖˡ);
}.

Class StructWrap_Assumptions `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
}.

Class StructWithFunc_Assumptions `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
}.

Class switchConcrete_Assumptions `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] switchConcrete'ptr_marker_unfold :: MethodUnfold (go.PointerType (switchConcrete)) "marker" (switchConcrete__markerⁱᵐᵖˡ);
}.

Class switchInterface_Assumptions `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] switchInterface'ptr_marker_unfold :: MethodUnfold (switchInterface) "marker" (switchInterface__markerⁱᵐᵖˡ);
}.

Class Log_Assumptions `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Log'ptr_Apply_unfold :: MethodUnfold (Log) "Apply" (Log__Applyⁱᵐᵖˡ);
  #[global] Log'ptr_BeginTxn_unfold :: MethodUnfold (Log) "BeginTxn" (Log__BeginTxnⁱᵐᵖˡ);
  #[global] Log'ptr_Commit_unfold :: MethodUnfold (Log) "Commit" (Log__Commitⁱᵐᵖˡ);
  #[global] Log'ptr_Read_unfold :: MethodUnfold (Log) "Read" (Log__Readⁱᵐᵖˡ);
  #[global] Log'ptr_Size_unfold :: MethodUnfold (Log) "Size" (Log__Sizeⁱᵐᵖˡ);
  #[global] Log'ptr_Write_unfold :: MethodUnfold (Log) "Write" (Log__Writeⁱᵐᵖˡ);
  #[global] Log'ptr_lock_unfold :: MethodUnfold (Log) "lock" (Log__lockⁱᵐᵖˡ);
  #[global] Log'ptr_unlock_unfold :: MethodUnfold (Log) "unlock" (Log__unlockⁱᵐᵖˡ);
  #[global] Log'ptr_Apply_unfold :: MethodUnfold (go.PointerType (Log)) "Apply" (λ: "$r", MethodResolve (Log) Apply #() (![(Log)] "$r");
  #[global] Log'ptr_BeginTxn_unfold :: MethodUnfold (go.PointerType (Log)) "BeginTxn" (λ: "$r", MethodResolve (Log) BeginTxn #() (![(Log)] "$r");
  #[global] Log'ptr_Commit_unfold :: MethodUnfold (go.PointerType (Log)) "Commit" (λ: "$r", MethodResolve (Log) Commit #() (![(Log)] "$r");
  #[global] Log'ptr_Read_unfold :: MethodUnfold (go.PointerType (Log)) "Read" (λ: "$r", MethodResolve (Log) Read #() (![(Log)] "$r");
  #[global] Log'ptr_Size_unfold :: MethodUnfold (go.PointerType (Log)) "Size" (λ: "$r", MethodResolve (Log) Size #() (![(Log)] "$r");
  #[global] Log'ptr_Write_unfold :: MethodUnfold (go.PointerType (Log)) "Write" (λ: "$r", MethodResolve (Log) Write #() (![(Log)] "$r");
  #[global] Log'ptr_lock_unfold :: MethodUnfold (go.PointerType (Log)) "lock" (λ: "$r", MethodResolve (Log) lock #() (![(Log)] "$r");
  #[global] Log'ptr_unlock_unfold :: MethodUnfold (go.PointerType (Log)) "unlock" (λ: "$r", MethodResolve (Log) unlock #() (![(Log)] "$r");
}.

Class Assumptions `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] unit_instance :: unit_Assumptions;
  #[global] Enc_instance :: Enc_Assumptions;
  #[global] Dec_instance :: Dec_Assumptions;
  #[global] Editor_instance :: Editor_Assumptions;
  #[global] Pair_instance :: Pair_Assumptions;
  #[global] Uint32_instance :: Uint32_Assumptions;
  #[global] geometryInterface_instance :: geometryInterface_Assumptions;
  #[global] SquareStruct_instance :: SquareStruct_Assumptions;
  #[global] LoopStruct_instance :: LoopStruct_Assumptions;
  #[global] BoolTest_instance :: BoolTest_Assumptions;
  #[global] ArrayEditor_instance :: ArrayEditor_Assumptions;
  #[global] Bar_instance :: Bar_Assumptions;
  #[global] Foo_instance :: Foo_Assumptions;
  #[global] TwoInts_instance :: TwoInts_Assumptions;
  #[global] S_instance :: S_Assumptions;
  #[global] StructWrap_instance :: StructWrap_Assumptions;
  #[global] StructWithFunc_instance :: StructWithFunc_Assumptions;
  #[global] switchConcrete_instance :: switchConcrete_Assumptions;
  #[global] switchInterface_instance :: switchInterface_Assumptions;
  #[global] Log_instance :: Log_Assumptions;
  #[global] findKey_unfold :: FuncUnfold findKey [] (findKeyⁱᵐᵖˡ);
  #[global] allocate_unfold :: FuncUnfold allocate [] (allocateⁱᵐᵖˡ);
  #[global] freeRange_unfold :: FuncUnfold freeRange [] (freeRangeⁱᵐᵖˡ);
  #[global] testAllocateDistinct_unfold :: FuncUnfold testAllocateDistinct [] (testAllocateDistinctⁱᵐᵖˡ);
  #[global] testAllocateFull_unfold :: FuncUnfold testAllocateFull [] (testAllocateFullⁱᵐᵖˡ);
  #[global] testExplicitBlockStmt_unfold :: FuncUnfold testExplicitBlockStmt [] (testExplicitBlockStmtⁱᵐᵖˡ);
  #[global] testMinUint64_unfold :: FuncUnfold testMinUint64 [] (testMinUint64ⁱᵐᵖˡ);
  #[global] testMaxUint64_unfold :: FuncUnfold testMaxUint64 [] (testMaxUint64ⁱᵐᵖˡ);
  #[global] adder_unfold :: FuncUnfold adder [] (adderⁱᵐᵖˡ);
  #[global] testClosureBasic_unfold :: FuncUnfold testClosureBasic [] (testClosureBasicⁱᵐᵖˡ);
  #[global] testCompareAll_unfold :: FuncUnfold testCompareAll [] (testCompareAllⁱᵐᵖˡ);
  #[global] testCompareGT_unfold :: FuncUnfold testCompareGT [] (testCompareGTⁱᵐᵖˡ);
  #[global] testCompareGE_unfold :: FuncUnfold testCompareGE [] (testCompareGEⁱᵐᵖˡ);
  #[global] testCompareLT_unfold :: FuncUnfold testCompareLT [] (testCompareLTⁱᵐᵖˡ);
  #[global] testCompareLE_unfold :: FuncUnfold testCompareLE [] (testCompareLEⁱᵐᵖˡ);
  #[global] literalCast_unfold :: FuncUnfold literalCast [] (literalCastⁱᵐᵖˡ);
  #[global] stringToByteSlice_unfold :: FuncUnfold stringToByteSlice [] (stringToByteSliceⁱᵐᵖˡ);
  #[global] byteSliceToString_unfold :: FuncUnfold byteSliceToString [] (byteSliceToStringⁱᵐᵖˡ);
  #[global] testByteSliceToString_unfold :: FuncUnfold testByteSliceToString [] (testByteSliceToStringⁱᵐᵖˡ);
  #[global] testCopySimple_unfold :: FuncUnfold testCopySimple [] (testCopySimpleⁱᵐᵖˡ);
  #[global] testCopyShorterDst_unfold :: FuncUnfold testCopyShorterDst [] (testCopyShorterDstⁱᵐᵖˡ);
  #[global] testCopyShorterSrc_unfold :: FuncUnfold testCopyShorterSrc [] (testCopyShorterSrcⁱᵐᵖˡ);
  #[global] deferSimple_unfold :: FuncUnfold deferSimple [] (deferSimpleⁱᵐᵖˡ);
  #[global] testDefer_unfold :: FuncUnfold testDefer [] (testDeferⁱᵐᵖˡ);
  #[global] testDeferFuncLit_unfold :: FuncUnfold testDeferFuncLit [] (testDeferFuncLitⁱᵐᵖˡ);
  #[global] roundtripEncDec32_unfold :: FuncUnfold roundtripEncDec32 [] (roundtripEncDec32ⁱᵐᵖˡ);
  #[global] roundtripEncDec64_unfold :: FuncUnfold roundtripEncDec64 [] (roundtripEncDec64ⁱᵐᵖˡ);
  #[global] testEncDec32Simple_unfold :: FuncUnfold testEncDec32Simple [] (testEncDec32Simpleⁱᵐᵖˡ);
  #[global] failing_testEncDec32_unfold :: FuncUnfold failing_testEncDec32 [] (failing_testEncDec32ⁱᵐᵖˡ);
  #[global] testEncDec64Simple_unfold :: FuncUnfold testEncDec64Simple [] (testEncDec64Simpleⁱᵐᵖˡ);
  #[global] testEncDec64_unfold :: FuncUnfold testEncDec64 [] (testEncDec64ⁱᵐᵖˡ);
  #[global] FirstClassFunction_unfold :: FuncUnfold FirstClassFunction [] (FirstClassFunctionⁱᵐᵖˡ);
  #[global] ApplyF_unfold :: FuncUnfold ApplyF [] (ApplyFⁱᵐᵖˡ);
  #[global] testFirstClassFunction_unfold :: FuncUnfold testFirstClassFunction [] (testFirstClassFunctionⁱᵐᵖˡ);
  #[global] addFour64_unfold :: FuncUnfold addFour64 [] (addFour64ⁱᵐᵖˡ);
  #[global] failing_testFunctionOrdering_unfold :: FuncUnfold failing_testFunctionOrdering [] (failing_testFunctionOrderingⁱᵐᵖˡ);
  #[global] storeAndReturn_unfold :: FuncUnfold storeAndReturn [] (storeAndReturnⁱᵐᵖˡ);
  #[global] failing_testArgumentOrder_unfold :: FuncUnfold failing_testArgumentOrder [] (failing_testArgumentOrderⁱᵐᵖˡ);
  #[global] testU64ToU32_unfold :: FuncUnfold testU64ToU32 [] (testU64ToU32ⁱᵐᵖˡ);
  #[global] testU32Len_unfold :: FuncUnfold testU32Len [] (testU32Lenⁱᵐᵖˡ);
  #[global] failing_testU32NewtypeLen_unfold :: FuncUnfold failing_testU32NewtypeLen [] (failing_testU32NewtypeLenⁱᵐᵖˡ);
  #[global] measureArea_unfold :: FuncUnfold measureArea [] (measureAreaⁱᵐᵖˡ);
  #[global] measureVolumePlusNM_unfold :: FuncUnfold measureVolumePlusNM [] (measureVolumePlusNMⁱᵐᵖˡ);
  #[global] measureVolume_unfold :: FuncUnfold measureVolume [] (measureVolumeⁱᵐᵖˡ);
  #[global] testBasicInterface_unfold :: FuncUnfold testBasicInterface [] (testBasicInterfaceⁱᵐᵖˡ);
  #[global] testAssignInterface_unfold :: FuncUnfold testAssignInterface [] (testAssignInterfaceⁱᵐᵖˡ);
  #[global] testMultipleInterface_unfold :: FuncUnfold testMultipleInterface [] (testMultipleInterfaceⁱᵐᵖˡ);
  #[global] testBinaryExprInterface_unfold :: FuncUnfold testBinaryExprInterface [] (testBinaryExprInterfaceⁱᵐᵖˡ);
  #[global] testIfStmtInterface_unfold :: FuncUnfold testIfStmtInterface [] (testIfStmtInterfaceⁱᵐᵖˡ);
  #[global] testsUseLocks_unfold :: FuncUnfold testsUseLocks [] (testsUseLocksⁱᵐᵖˡ);
  #[global] standardForLoop_unfold :: FuncUnfold standardForLoop [] (standardForLoopⁱᵐᵖˡ);
  #[global] testStandardForLoop_unfold :: FuncUnfold testStandardForLoop [] (testStandardForLoopⁱᵐᵖˡ);
  #[global] testForLoopWait_unfold :: FuncUnfold testForLoopWait [] (testForLoopWaitⁱᵐᵖˡ);
  #[global] testBreakFromLoopWithContinue_unfold :: FuncUnfold testBreakFromLoopWithContinue [] (testBreakFromLoopWithContinueⁱᵐᵖˡ);
  #[global] testBreakFromLoopNoContinue_unfold :: FuncUnfold testBreakFromLoopNoContinue [] (testBreakFromLoopNoContinueⁱᵐᵖˡ);
  #[global] testBreakFromLoopNoContinueDouble_unfold :: FuncUnfold testBreakFromLoopNoContinueDouble [] (testBreakFromLoopNoContinueDoubleⁱᵐᵖˡ);
  #[global] testBreakFromLoopForOnly_unfold :: FuncUnfold testBreakFromLoopForOnly [] (testBreakFromLoopForOnlyⁱᵐᵖˡ);
  #[global] testBreakFromLoopAssignAndContinue_unfold :: FuncUnfold testBreakFromLoopAssignAndContinue [] (testBreakFromLoopAssignAndContinueⁱᵐᵖˡ);
  #[global] testNestedLoops_unfold :: FuncUnfold testNestedLoops [] (testNestedLoopsⁱᵐᵖˡ);
  #[global] testNestedGoStyleLoops_unfold :: FuncUnfold testNestedGoStyleLoops [] (testNestedGoStyleLoopsⁱᵐᵖˡ);
  #[global] testNestedGoStyleLoopsNoComparison_unfold :: FuncUnfold testNestedGoStyleLoopsNoComparison [] (testNestedGoStyleLoopsNoComparisonⁱᵐᵖˡ);
  #[global] IterateMapKeys_unfold :: FuncUnfold IterateMapKeys [] (IterateMapKeysⁱᵐᵖˡ);
  #[global] IterateMapValues_unfold :: FuncUnfold IterateMapValues [] (IterateMapValuesⁱᵐᵖˡ);
  #[global] testIterateMap_unfold :: FuncUnfold testIterateMap [] (testIterateMapⁱᵐᵖˡ);
  #[global] testMapSize_unfold :: FuncUnfold testMapSize [] (testMapSizeⁱᵐᵖˡ);
  #[global] multReturnTwo_unfold :: FuncUnfold multReturnTwo [] (multReturnTwoⁱᵐᵖˡ);
  #[global] testAssignTwo_unfold :: FuncUnfold testAssignTwo [] (testAssignTwoⁱᵐᵖˡ);
  #[global] multReturnThree_unfold :: FuncUnfold multReturnThree [] (multReturnThreeⁱᵐᵖˡ);
  #[global] testAssignThree_unfold :: FuncUnfold testAssignThree [] (testAssignThreeⁱᵐᵖˡ);
  #[global] testMultipleAssignToMap_unfold :: FuncUnfold testMultipleAssignToMap [] (testMultipleAssignToMapⁱᵐᵖˡ);
  #[global] returnTwo_unfold :: FuncUnfold returnTwo [] (returnTwoⁱᵐᵖˡ);
  #[global] testReturnTwo_unfold :: FuncUnfold testReturnTwo [] (testReturnTwoⁱᵐᵖˡ);
  #[global] testAnonymousBinding_unfold :: FuncUnfold testAnonymousBinding [] (testAnonymousBindingⁱᵐᵖˡ);
  #[global] returnThree_unfold :: FuncUnfold returnThree [] (returnThreeⁱᵐᵖˡ);
  #[global] testReturnThree_unfold :: FuncUnfold testReturnThree [] (testReturnThreeⁱᵐᵖˡ);
  #[global] returnFour_unfold :: FuncUnfold returnFour [] (returnFourⁱᵐᵖˡ);
  #[global] testReturnFour_unfold :: FuncUnfold testReturnFour [] (testReturnFourⁱᵐᵖˡ);
  #[global] failing_testCompareSliceToNil_unfold :: FuncUnfold failing_testCompareSliceToNil [] (failing_testCompareSliceToNilⁱᵐᵖˡ);
  #[global] testComparePointerToNil_unfold :: FuncUnfold testComparePointerToNil [] (testComparePointerToNilⁱᵐᵖˡ);
  #[global] testCompareNilToNil_unfold :: FuncUnfold testCompareNilToNil [] (testCompareNilToNilⁱᵐᵖˡ);
  #[global] testComparePointerWrappedToNil_unfold :: FuncUnfold testComparePointerWrappedToNil [] (testComparePointerWrappedToNilⁱᵐᵖˡ);
  #[global] testComparePointerWrappedDefaultToNil_unfold :: FuncUnfold testComparePointerWrappedDefaultToNil [] (testComparePointerWrappedDefaultToNilⁱᵐᵖˡ);
  #[global] reverseAssignOps64_unfold :: FuncUnfold reverseAssignOps64 [] (reverseAssignOps64ⁱᵐᵖˡ);
  #[global] reverseAssignOps32_unfold :: FuncUnfold reverseAssignOps32 [] (reverseAssignOps32ⁱᵐᵖˡ);
  #[global] add64Equals_unfold :: FuncUnfold add64Equals [] (add64Equalsⁱᵐᵖˡ);
  #[global] sub64Equals_unfold :: FuncUnfold sub64Equals [] (sub64Equalsⁱᵐᵖˡ);
  #[global] testReverseAssignOps64_unfold :: FuncUnfold testReverseAssignOps64 [] (testReverseAssignOps64ⁱᵐᵖˡ);
  #[global] failing_testReverseAssignOps32_unfold :: FuncUnfold failing_testReverseAssignOps32 [] (failing_testReverseAssignOps32ⁱᵐᵖˡ);
  #[global] testAdd64Equals_unfold :: FuncUnfold testAdd64Equals [] (testAdd64Equalsⁱᵐᵖˡ);
  #[global] testSub64Equals_unfold :: FuncUnfold testSub64Equals [] (testSub64Equalsⁱᵐᵖˡ);
  #[global] testDivisionPrecedence_unfold :: FuncUnfold testDivisionPrecedence [] (testDivisionPrecedenceⁱᵐᵖˡ);
  #[global] testModPrecedence_unfold :: FuncUnfold testModPrecedence [] (testModPrecedenceⁱᵐᵖˡ);
  #[global] testBitwiseOpsPrecedence_unfold :: FuncUnfold testBitwiseOpsPrecedence [] (testBitwiseOpsPrecedenceⁱᵐᵖˡ);
  #[global] testArithmeticShifts_unfold :: FuncUnfold testArithmeticShifts [] (testArithmeticShiftsⁱᵐᵖˡ);
  #[global] testBitAddAnd_unfold :: FuncUnfold testBitAddAnd [] (testBitAddAndⁱᵐᵖˡ);
  #[global] testManyParentheses_unfold :: FuncUnfold testManyParentheses [] (testManyParenthesesⁱᵐᵖˡ);
  #[global] testPlusTimes_unfold :: FuncUnfold testPlusTimes [] (testPlusTimesⁱᵐᵖˡ);
  #[global] testOrCompareSimple_unfold :: FuncUnfold testOrCompareSimple [] (testOrCompareSimpleⁱᵐᵖˡ);
  #[global] testOrCompare_unfold :: FuncUnfold testOrCompare [] (testOrCompareⁱᵐᵖˡ);
  #[global] testAndCompare_unfold :: FuncUnfold testAndCompare [] (testAndCompareⁱᵐᵖˡ);
  #[global] testShiftMod_unfold :: FuncUnfold testShiftMod [] (testShiftModⁱᵐᵖˡ);
  #[global] testLinearize_unfold :: FuncUnfold testLinearize [] (testLinearizeⁱᵐᵖˡ);
  #[global] CheckTrue_unfold :: FuncUnfold CheckTrue [] (CheckTrueⁱᵐᵖˡ);
  #[global] CheckFalse_unfold :: FuncUnfold CheckFalse [] (CheckFalseⁱᵐᵖˡ);
  #[global] testShortcircuitAndTF_unfold :: FuncUnfold testShortcircuitAndTF [] (testShortcircuitAndTFⁱᵐᵖˡ);
  #[global] testShortcircuitAndFT_unfold :: FuncUnfold testShortcircuitAndFT [] (testShortcircuitAndFTⁱᵐᵖˡ);
  #[global] testShortcircuitOrTF_unfold :: FuncUnfold testShortcircuitOrTF [] (testShortcircuitOrTFⁱᵐᵖˡ);
  #[global] testShortcircuitOrFT_unfold :: FuncUnfold testShortcircuitOrFT [] (testShortcircuitOrFTⁱᵐᵖˡ);
  #[global] testSliceOps_unfold :: FuncUnfold testSliceOps [] (testSliceOpsⁱᵐᵖˡ);
  #[global] testSliceCapacityOps_unfold :: FuncUnfold testSliceCapacityOps [] (testSliceCapacityOpsⁱᵐᵖˡ);
  #[global] testOverwriteArray_unfold :: FuncUnfold testOverwriteArray [] (testOverwriteArrayⁱᵐᵖˡ);
  #[global] testSliceLiteral_unfold :: FuncUnfold testSliceLiteral [] (testSliceLiteralⁱᵐᵖˡ);
  #[global] testSliceAppend_unfold :: FuncUnfold testSliceAppend [] (testSliceAppendⁱᵐᵖˡ);
  #[global] testFooBarMutation_unfold :: FuncUnfold testFooBarMutation [] (testFooBarMutationⁱᵐᵖˡ);
  #[global] NewS_unfold :: FuncUnfold NewS [] (NewSⁱᵐᵖˡ);
  #[global] testStructUpdates_unfold :: FuncUnfold testStructUpdates [] (testStructUpdatesⁱᵐᵖˡ);
  #[global] testNestedStructUpdates_unfold :: FuncUnfold testNestedStructUpdates [] (testNestedStructUpdatesⁱᵐᵖˡ);
  #[global] testStructConstructions_unfold :: FuncUnfold testStructConstructions [] (testStructConstructionsⁱᵐᵖˡ);
  #[global] testIncompleteStruct_unfold :: FuncUnfold testIncompleteStruct [] (testIncompleteStructⁱᵐᵖˡ);
  #[global] testStoreInStructVar_unfold :: FuncUnfold testStoreInStructVar [] (testStoreInStructVarⁱᵐᵖˡ);
  #[global] testStoreInStructPointerVar_unfold :: FuncUnfold testStoreInStructPointerVar [] (testStoreInStructPointerVarⁱᵐᵖˡ);
  #[global] testStoreComposite_unfold :: FuncUnfold testStoreComposite [] (testStoreCompositeⁱᵐᵖˡ);
  #[global] testStoreSlice_unfold :: FuncUnfold testStoreSlice [] (testStoreSliceⁱᵐᵖˡ);
  #[global] testStructFieldFunc_unfold :: FuncUnfold testStructFieldFunc [] (testStructFieldFuncⁱᵐᵖˡ);
  #[global] testSwitchVal_unfold :: FuncUnfold testSwitchVal [] (testSwitchValⁱᵐᵖˡ);
  #[global] testSwitchMultiple_unfold :: FuncUnfold testSwitchMultiple [] (testSwitchMultipleⁱᵐᵖˡ);
  #[global] testSwitchDefaultTrue_unfold :: FuncUnfold testSwitchDefaultTrue [] (testSwitchDefaultTrueⁱᵐᵖˡ);
  #[global] testSwitchConversion_unfold :: FuncUnfold testSwitchConversion [] (testSwitchConversionⁱᵐᵖˡ);
  #[global] testPointerAssignment_unfold :: FuncUnfold testPointerAssignment [] (testPointerAssignmentⁱᵐᵖˡ);
  #[global] testAddressOfLocal_unfold :: FuncUnfold testAddressOfLocal [] (testAddressOfLocalⁱᵐᵖˡ);
  #[global] testAnonymousAssign_unfold :: FuncUnfold testAnonymousAssign [] (testAnonymousAssignⁱᵐᵖˡ);
  #[global] intToBlock_unfold :: FuncUnfold intToBlock [] (intToBlockⁱᵐᵖˡ);
  #[global] blockToInt_unfold :: FuncUnfold blockToInt [] (blockToIntⁱᵐᵖˡ);
  #[global] New_unfold :: FuncUnfold New [] (Newⁱᵐᵖˡ);
  #[global] getLogEntry_unfold :: FuncUnfold getLogEntry [] (getLogEntryⁱᵐᵖˡ);
  #[global] applyLog_unfold :: FuncUnfold applyLog [] (applyLogⁱᵐᵖˡ);
  #[global] clearLog_unfold :: FuncUnfold clearLog [] (clearLogⁱᵐᵖˡ);
  #[global] Open_unfold :: FuncUnfold Open [] (Openⁱᵐᵖˡ);
  #[global] disabled_testWal_unfold :: FuncUnfold disabled_testWal [] (disabled_testWalⁱᵐᵖˡ);
}.

End code.
End semantics.
