(* autogenerated from github.com/goose-lang/goose/testdata/examples/semantics *)
From New.golang Require Import defn.
Require Export New.code.github_com.goose_lang.primitive.
Require Export New.code.github_com.goose_lang.primitive.disk.
Require Export New.code.sync.

Definition semantics : go_string := "github.com/goose-lang/goose/testdata/examples/semantics".

From New Require Import disk_prelude.
Module semantics.
Section code.


Definition unit : go_type := structT [
].

Definition unitⁱᵈ : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.unit"%go.

Definition findKey : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.findKey"%go.

(* go: allocator.go:7:6 *)
Definition findKeyⁱᵐᵖˡ : val :=
  λ: "m",
    exception_do (let: "m" := (mem.alloc "m") in
    let: "found" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("found" <-[#uint64T] "$r0");;;
    let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "$r0" := #false in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$range" := (![type.mapT #uint64T #unit] "m") in
    (let: "k" := (mem.alloc (type.zero_val #uint64T)) in
    map.for_range "$range" (λ: "$key" "value",
      do:  ("k" <-[#uint64T] "$key");;;
      (if: (~ (![#boolT] "ok"))
      then
        let: "$r0" := (![#uint64T] "k") in
        do:  ("found" <-[#uint64T] "$r0");;;
        let: "$r0" := #true in
        do:  ("ok" <-[#boolT] "$r0")
      else do:  #())));;;
    return: (![#uint64T] "found", ![#boolT] "ok")).

Definition allocate : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.allocate"%go.

(* go: allocator.go:20:6 *)
Definition allocateⁱᵐᵖˡ : val :=
  λ: "m",
    exception_do (let: "m" := (mem.alloc "m") in
    let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "k" := (mem.alloc (type.zero_val #uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![type.mapT #uint64T #unit] "m") in
    (func_call #findKey) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("k" <-[#uint64T] "$r0");;;
    do:  ("ok" <-[#boolT] "$r1");;;
    do:  (let: "$a0" := (![type.mapT #uint64T #unit] "m") in
    let: "$a1" := (![#uint64T] "k") in
    map.delete "$a0" "$a1");;;
    return: (![#uint64T] "k", ![#boolT] "ok")).

Definition freeRange : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.freeRange"%go.

(* go: allocator.go:26:6 *)
Definition freeRangeⁱᵐᵖˡ : val :=
  λ: "sz",
    exception_do (let: "sz" := (mem.alloc "sz") in
    let: "m" := (mem.alloc (type.zero_val (type.mapT #uint64T #unit))) in
    let: "$r0" := (map.make #uint64T #unit) in
    do:  ("m" <-[type.mapT #uint64T #unit] "$r0");;;
    (let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (for: (λ: <>, (![#uint64T] "i") < (![#uint64T] "sz")); (λ: <>, do:  ("i" <-[#uint64T] ((![#uint64T] "i") + #(W64 1)))) := λ: <>,
      let: "$r0" := (struct.make #unit [{
      }]) in
      do:  (map.insert (![type.mapT #uint64T #unit] "m") (![#uint64T] "i") "$r0")));;;
    return: (![type.mapT #uint64T #unit] "m")).

Definition testAllocateDistinct : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testAllocateDistinct"%go.

(* go: allocator.go:34:6 *)
Definition testAllocateDistinctⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "free" := (mem.alloc (type.zero_val (type.mapT #uint64T #unit))) in
    let: "$r0" := (let: "$a0" := #(W64 4) in
    (func_call #freeRange) "$a0") in
    do:  ("free" <-[type.mapT #uint64T #unit] "$r0");;;
    let: "a1" := (mem.alloc (type.zero_val #uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![type.mapT #uint64T #unit] "free") in
    (func_call #allocate) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("a1" <-[#uint64T] "$r0");;;
    do:  "$r1";;;
    let: "a2" := (mem.alloc (type.zero_val #uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![type.mapT #uint64T #unit] "free") in
    (func_call #allocate) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("a2" <-[#uint64T] "$r0");;;
    do:  "$r1";;;
    return: ((![#uint64T] "a1") ≠ (![#uint64T] "a2"))).

Definition testAllocateFull : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testAllocateFull"%go.

(* go: allocator.go:41:6 *)
Definition testAllocateFullⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "free" := (mem.alloc (type.zero_val (type.mapT #uint64T #unit))) in
    let: "$r0" := (let: "$a0" := #(W64 2) in
    (func_call #freeRange) "$a0") in
    do:  ("free" <-[type.mapT #uint64T #unit] "$r0");;;
    let: "ok1" := (mem.alloc (type.zero_val #boolT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![type.mapT #uint64T #unit] "free") in
    (func_call #allocate) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  "$r0";;;
    do:  ("ok1" <-[#boolT] "$r1");;;
    let: "ok2" := (mem.alloc (type.zero_val #boolT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![type.mapT #uint64T #unit] "free") in
    (func_call #allocate) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  "$r0";;;
    do:  ("ok2" <-[#boolT] "$r1");;;
    let: "ok3" := (mem.alloc (type.zero_val #boolT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![type.mapT #uint64T #unit] "free") in
    (func_call #allocate) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  "$r0";;;
    do:  ("ok3" <-[#boolT] "$r1");;;
    return: (((![#boolT] "ok1") && (![#boolT] "ok2")) && (~ (![#boolT] "ok3")))).

Definition testExplicitBlockStmt : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testExplicitBlockStmt"%go.

(* go: block.go:3:6 *)
Definition testExplicitBlockStmtⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := #(W64 10) in
    do:  ("x" <-[#intT] "$r0");;;
    let: "x" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := #(W64 11) in
    do:  ("x" <-[#intT] "$r0");;;
    do:  ("x" <-[#intT] ((![#intT] "x") + #(W64 1)));;;
    return: ((![#intT] "x") = #(W64 10))).

Definition testMinUint64 : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testMinUint64"%go.

(* go: builtin.go:3:6 *)
Definition testMinUint64ⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 10) in
    do:  ("x" <-[#uint64T] "$r0");;;
    return: ((let: "$a0" := (![#uint64T] "x") in
     let: "$a1" := #(W64 1) in
     (minUint64 2) "$a0" "$a1") = #(W64 1))).

Definition testMaxUint64 : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testMaxUint64"%go.

(* go: builtin.go:8:6 *)
Definition testMaxUint64ⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 10) in
    do:  ("x" <-[#uint64T] "$r0");;;
    return: ((let: "$a0" := (![#uint64T] "x") in
     let: "$a1" := #(W64 1) in
     (maxUint64 2) "$a0" "$a1") = #(W64 10))).

Definition AdderType : go_type := funcT.

Definition AdderTypeⁱᵈ : go_string := funcTⁱᵈ [uint64Tⁱᵈ] [uint64Tⁱᵈ] false.

Definition MultipleArgsType : go_type := funcT.

Definition MultipleArgsTypeⁱᵈ : go_string := funcTⁱᵈ [uint64Tⁱᵈ; boolTⁱᵈ] [uint64Tⁱᵈ] false.

Definition adder : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.adder"%go.

(* go: closures.go:6:6 *)
Definition adderⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "sum" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("sum" <-[#uint64T] "$r0");;;
    return: ((λ: "x",
       exception_do (let: "x" := (mem.alloc "x") in
       do:  ("sum" <-[#uint64T] ((![#uint64T] "sum") + (![#uint64T] "x")));;;
       return: (![#uint64T] "sum"))
       ))).

Definition testClosureBasic : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testClosureBasic"%go.

(* go: closures.go:14:6 *)
Definition testClosureBasicⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "pos" := (mem.alloc (type.zero_val #funcT)) in
    let: "$r0" := ((func_call #adder) #()) in
    do:  ("pos" <-[#funcT] "$r0");;;
    let: "doub" := (mem.alloc (type.zero_val #funcT)) in
    let: "$r0" := ((func_call #adder) #()) in
    do:  ("doub" <-[#funcT] "$r0");;;
    (let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (for: (λ: <>, (![#uint64T] "i") < #(W64 10)); (λ: <>, do:  ("i" <-[#uint64T] ((![#uint64T] "i") + #(W64 1)))) := λ: <>,
      do:  (let: "$a0" := (![#uint64T] "i") in
      (![#funcT] "pos") "$a0");;;
      do:  (let: "$a0" := (#(W64 2) * (![#uint64T] "i")) in
      (![#funcT] "doub") "$a0")));;;
    (if: ((let: "$a0" := #(W64 0) in
    (![#funcT] "pos") "$a0") = #(W64 45)) && ((let: "$a0" := #(W64 0) in
    (![#funcT] "doub") "$a0") = #(W64 90))
    then return: (#true)
    else do:  #());;;
    return: (#false)).

Definition testCompareAll : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testCompareAll"%go.

(* go: comparisons.go:3:6 *)
Definition testCompareAllⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "$r0" := #true in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "nok" := (mem.alloc (type.zero_val #boolT)) in
    let: "$r0" := #false in
    do:  ("nok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && #(1 <? 2)) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && #(2 <? 1)) in
    do:  ("nok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && #(1 <=? 2)) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && #(2 <=? 2)) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && #(2 <=? 1)) in
    do:  ("nok" <-[#boolT] "$r0");;;
    (if: ![#boolT] "nok"
    then return: (#false)
    else do:  #());;;
    return: (![#boolT] "ok")).

Definition testCompareGT : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testCompareGT"%go.

(* go: comparisons.go:20:6 *)
Definition testCompareGTⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 4) in
    do:  ("x" <-[#uint64T] "$r0");;;
    let: "y" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 5) in
    do:  ("y" <-[#uint64T] "$r0");;;
    let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "$r0" := #true in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((![#uint64T] "y") > #(W64 4))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((![#uint64T] "y") > (![#uint64T] "x"))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    return: (![#boolT] "ok")).

Definition testCompareGE : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testCompareGE"%go.

(* go: comparisons.go:31:6 *)
Definition testCompareGEⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 4) in
    do:  ("x" <-[#uint64T] "$r0");;;
    let: "y" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 5) in
    do:  ("y" <-[#uint64T] "$r0");;;
    let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "$r0" := #true in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((![#uint64T] "y") ≥ #(W64 4))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((![#uint64T] "y") ≥ #(W64 5))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((![#uint64T] "y") ≥ (![#uint64T] "x"))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    (if: (![#uint64T] "y") > #(W64 5)
    then return: (#false)
    else do:  #());;;
    return: (![#boolT] "ok")).

Definition testCompareLT : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testCompareLT"%go.

(* go: comparisons.go:47:6 *)
Definition testCompareLTⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 4) in
    do:  ("x" <-[#uint64T] "$r0");;;
    let: "y" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 5) in
    do:  ("y" <-[#uint64T] "$r0");;;
    let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "$r0" := #true in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((![#uint64T] "y") < #(W64 6))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((![#uint64T] "x") < (![#uint64T] "y"))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    return: (![#boolT] "ok")).

Definition testCompareLE : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testCompareLE"%go.

(* go: comparisons.go:58:6 *)
Definition testCompareLEⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 4) in
    do:  ("x" <-[#uint64T] "$r0");;;
    let: "y" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 5) in
    do:  ("y" <-[#uint64T] "$r0");;;
    let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "$r0" := #true in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((![#uint64T] "y") ≤ #(W64 6))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((![#uint64T] "y") ≤ #(W64 5))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((![#uint64T] "x") ≤ (![#uint64T] "y"))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    (if: (![#uint64T] "y") < #(W64 5)
    then return: (#false)
    else do:  #());;;
    return: (![#boolT] "ok")).

Definition literalCast : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.literalCast"%go.

(* go: conversions.go:5:6 *)
Definition literalCastⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 2) in
    do:  ("x" <-[#uint64T] "$r0");;;
    return: ((![#uint64T] "x") + #(W64 2))).

Definition stringToByteSlice : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.stringToByteSlice"%go.

(* go: conversions.go:11:6 *)
Definition stringToByteSliceⁱᵐᵖˡ : val :=
  λ: "s",
    exception_do (let: "s" := (mem.alloc "s") in
    let: "p" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (string.to_bytes (![#stringT] "s")) in
    do:  ("p" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "p")).

Definition byteSliceToString : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.byteSliceToString"%go.

(* go: conversions.go:17:6 *)
Definition byteSliceToStringⁱᵐᵖˡ : val :=
  λ: "p",
    exception_do (let: "p" := (mem.alloc "p") in
    return: (string.from_bytes (![#sliceT] "p"))).

Definition testByteSliceToString : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testByteSliceToString"%go.

(* tests

   go: conversions.go:23:6 *)
Definition testByteSliceToStringⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make2 #byteT #(W64 3)) in
    do:  ("x" <-[#sliceT] "$r0");;;
    let: "$r0" := #(W8 65) in
    do:  ((slice.elem_ref #byteT (![#sliceT] "x") #(W64 0)) <-[#byteT] "$r0");;;
    let: "$r0" := #(W8 66) in
    do:  ((slice.elem_ref #byteT (![#sliceT] "x") #(W64 1)) <-[#byteT] "$r0");;;
    let: "$r0" := #(W8 67) in
    do:  ((slice.elem_ref #byteT (![#sliceT] "x") #(W64 2)) <-[#byteT] "$r0");;;
    return: ((let: "$a0" := (![#sliceT] "x") in
     (func_call #byteSliceToString) "$a0") = #"ABC"%go)).

Definition testCopySimple : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testCopySimple"%go.

(* go: copy.go:3:6 *)
Definition testCopySimpleⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make2 #byteT #(W64 10)) in
    do:  ("x" <-[#sliceT] "$r0");;;
    let: "$r0" := #(W8 1) in
    do:  ((slice.elem_ref #byteT (![#sliceT] "x") #(W64 3)) <-[#byteT] "$r0");;;
    let: "y" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make2 #byteT #(W64 10)) in
    do:  ("y" <-[#sliceT] "$r0");;;
    do:  (let: "$a0" := (![#sliceT] "y") in
    let: "$a1" := (![#sliceT] "x") in
    (slice.copy #byteT) "$a0" "$a1");;;
    return: ((![#byteT] (slice.elem_ref #byteT (![#sliceT] "y") #(W64 3))) = #(W8 1))).

Definition testCopyShorterDst : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testCopyShorterDst"%go.

(* go: copy.go:11:6 *)
Definition testCopyShorterDstⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make2 #byteT #(W64 15)) in
    do:  ("x" <-[#sliceT] "$r0");;;
    let: "$r0" := #(W8 1) in
    do:  ((slice.elem_ref #byteT (![#sliceT] "x") #(W64 3)) <-[#byteT] "$r0");;;
    let: "$r0" := #(W8 2) in
    do:  ((slice.elem_ref #byteT (![#sliceT] "x") #(W64 12)) <-[#byteT] "$r0");;;
    let: "y" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make2 #byteT #(W64 10)) in
    do:  ("y" <-[#sliceT] "$r0");;;
    let: "n" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (s_to_w64 (let: "$a0" := (![#sliceT] "y") in
    let: "$a1" := (![#sliceT] "x") in
    (slice.copy #byteT) "$a0" "$a1")) in
    do:  ("n" <-[#uint64T] "$r0");;;
    return: (((![#uint64T] "n") = #(W64 10)) && ((![#byteT] (slice.elem_ref #byteT (![#sliceT] "y") #(W64 3))) = #(W8 1)))).

Definition testCopyShorterSrc : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testCopyShorterSrc"%go.

(* go: copy.go:20:6 *)
Definition testCopyShorterSrcⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make2 #byteT #(W64 10)) in
    do:  ("x" <-[#sliceT] "$r0");;;
    let: "y" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make2 #byteT #(W64 15)) in
    do:  ("y" <-[#sliceT] "$r0");;;
    let: "$r0" := #(W8 1) in
    do:  ((slice.elem_ref #byteT (![#sliceT] "x") #(W64 3)) <-[#byteT] "$r0");;;
    let: "$r0" := #(W8 2) in
    do:  ((slice.elem_ref #byteT (![#sliceT] "y") #(W64 12)) <-[#byteT] "$r0");;;
    let: "n" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (s_to_w64 (let: "$a0" := (![#sliceT] "y") in
    let: "$a1" := (![#sliceT] "x") in
    (slice.copy #byteT) "$a0" "$a1")) in
    do:  ("n" <-[#uint64T] "$r0");;;
    return: ((((![#uint64T] "n") = #(W64 10)) && ((![#byteT] (slice.elem_ref #byteT (![#sliceT] "y") #(W64 3))) = #(W8 1))) && ((![#byteT] (slice.elem_ref #byteT (![#sliceT] "y") #(W64 12))) = #(W8 2)))).

Definition deferSimple : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.deferSimple"%go.

(* go: defer.go:3:6 *)
Definition deferSimpleⁱᵐᵖˡ : val :=
  λ: <>,
    with_defer: (let: "x" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #uint64T)) in
    do:  ("x" <-[#ptrT] "$r0");;;
    (let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (for: (λ: <>, (![#uint64T] "i") < #(W64 10)); (λ: <>, do:  ("i" <-[#uint64T] ((![#uint64T] "i") + #(W64 1)))) := λ: <>,
      do:  (let: "$f" := (λ: <>,
        exception_do (do:  ((![#ptrT] "x") <-[#uint64T] ((![#uint64T] (![#ptrT] "x")) + #(W64 1)));;;
        return: #())
        ) in
      "$defer" <-[#funcT] (let: "$oldf" := (![#funcT] "$defer") in
      (λ: <>,
        "$f" #();;
        "$oldf" #()
        )))));;;
    return: (![#ptrT] "x")).

Definition testDefer : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testDefer"%go.

(* go: defer.go:13:6 *)
Definition testDeferⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: ((![#uint64T] ((func_call #deferSimple) #())) = #(W64 10))).

Definition testDeferFuncLit : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testDeferFuncLit"%go.

(* go: defer.go:17:6 *)
Definition testDeferFuncLitⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := #(W64 10) in
    do:  ("x" <-[#intT] "$r0");;;
    let: "f" := (mem.alloc (type.zero_val #funcT)) in
    let: "$r0" := (λ: <>,
      with_defer: (do:  (let: "$f" := (λ: <>,
        exception_do (do:  ("x" <-[#intT] ((![#intT] "x") + #(W64 1)));;;
        return: #())
        ) in
      "$defer" <-[#funcT] (let: "$oldf" := (![#funcT] "$defer") in
      (λ: <>,
        "$f" #();;
        "$oldf" #()
        )));;;
      return: #())
      ) in
    do:  ("f" <-[#funcT] "$r0");;;
    do:  ((![#funcT] "f") #());;;
    return: ((![#intT] "x") = #(W64 11))).

Definition Enc : go_type := structT [
  "p" :: sliceT
].

Definition Encⁱᵈ : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.Enc"%go.

(* go: encoding.go:10:15 *)
Definition Enc__consumeⁱᵐᵖˡ : val :=
  λ: "e" "n",
    exception_do (let: "e" := (mem.alloc "e") in
    let: "n" := (mem.alloc "n") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$s" := (![#sliceT] (struct.field_ref #Enc #"p"%go (![#ptrT] "e"))) in
    slice.slice #byteT "$s" #(W64 0) (![#uint64T] "n")) in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$s" := (![#sliceT] (struct.field_ref #Enc #"p"%go (![#ptrT] "e"))) in
    slice.slice #byteT "$s" (![#uint64T] "n") (slice.len "$s")) in
    do:  ((struct.field_ref #Enc #"p"%go (![#ptrT] "e")) <-[#sliceT] "$r0");;;
    return: (![#sliceT] "b")).

Definition Dec : go_type := structT [
  "p" :: sliceT
].

Definition Decⁱᵈ : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.Dec"%go.

(* go: encoding.go:20:15 *)
Definition Dec__consumeⁱᵐᵖˡ : val :=
  λ: "d" "n",
    exception_do (let: "d" := (mem.alloc "d") in
    let: "n" := (mem.alloc "n") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$s" := (![#sliceT] (struct.field_ref #Dec #"p"%go (![#ptrT] "d"))) in
    slice.slice #byteT "$s" #(W64 0) (![#uint64T] "n")) in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$s" := (![#sliceT] (struct.field_ref #Dec #"p"%go (![#ptrT] "d"))) in
    slice.slice #byteT "$s" (![#uint64T] "n") (slice.len "$s")) in
    do:  ((struct.field_ref #Dec #"p"%go (![#ptrT] "d")) <-[#sliceT] "$r0");;;
    return: (![#sliceT] "b")).

Definition roundtripEncDec32 : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.roundtripEncDec32"%go.

(* go: encoding.go:26:6 *)
Definition roundtripEncDec32ⁱᵐᵖˡ : val :=
  λ: "x",
    exception_do (let: "x" := (mem.alloc "x") in
    let: "r" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make2 #byteT #(W64 4)) in
    do:  ("r" <-[#sliceT] "$r0");;;
    let: "e" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (let: "$p" := (![#sliceT] "r") in
    struct.make #Enc [{
      "p" ::= "$p"
    }])) in
    do:  ("e" <-[#ptrT] "$r0");;;
    let: "d" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (let: "$p" := (![#sliceT] "r") in
    struct.make #Dec [{
      "p" ::= "$p"
    }])) in
    do:  ("d" <-[#ptrT] "$r0");;;
    do:  (let: "$a0" := (let: "$a0" := #(W64 4) in
    (method_call #semantics.semantics #"Enc'ptr" #"consume" (![#ptrT] "e")) "$a0") in
    let: "$a1" := (![#uint32T] "x") in
    (func_call #primitive.UInt32Put) "$a0" "$a1");;;
    return: (let: "$a0" := (let: "$a0" := #(W64 4) in
     (method_call #semantics.semantics #"Dec'ptr" #"consume" (![#ptrT] "d")) "$a0") in
     (func_call #primitive.UInt32Get) "$a0")).

Definition roundtripEncDec64 : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.roundtripEncDec64"%go.

(* go: encoding.go:34:6 *)
Definition roundtripEncDec64ⁱᵐᵖˡ : val :=
  λ: "x",
    exception_do (let: "x" := (mem.alloc "x") in
    let: "r" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make2 #byteT #(W64 8)) in
    do:  ("r" <-[#sliceT] "$r0");;;
    let: "e" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (let: "$p" := (![#sliceT] "r") in
    struct.make #Enc [{
      "p" ::= "$p"
    }])) in
    do:  ("e" <-[#ptrT] "$r0");;;
    let: "d" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (let: "$p" := (![#sliceT] "r") in
    struct.make #Dec [{
      "p" ::= "$p"
    }])) in
    do:  ("d" <-[#ptrT] "$r0");;;
    do:  (let: "$a0" := (let: "$a0" := #(W64 8) in
    (method_call #semantics.semantics #"Enc'ptr" #"consume" (![#ptrT] "e")) "$a0") in
    let: "$a1" := (![#uint64T] "x") in
    (func_call #primitive.UInt64Put) "$a0" "$a1");;;
    return: (let: "$a0" := (let: "$a0" := #(W64 8) in
     (method_call #semantics.semantics #"Dec'ptr" #"consume" (![#ptrT] "d")) "$a0") in
     (func_call #primitive.UInt64Get) "$a0")).

Definition testEncDec32Simple : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testEncDec32Simple"%go.

(* tests

   go: encoding.go:43:6 *)
Definition testEncDec32Simpleⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "$r0" := #true in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((let: "$a0" := #(W32 0) in
    (func_call #roundtripEncDec32) "$a0") = #(W32 0))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((let: "$a0" := #(W32 1) in
    (func_call #roundtripEncDec32) "$a0") = #(W32 1))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((let: "$a0" := #(W32 1231234) in
    (func_call #roundtripEncDec32) "$a0") = #(W32 1231234))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    return: (![#boolT] "ok")).

Definition failing_testEncDec32 : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.failing_testEncDec32"%go.

(* go: encoding.go:51:6 *)
Definition failing_testEncDec32ⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "$r0" := #true in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((let: "$a0" := #(W32 3434807466) in
    (func_call #roundtripEncDec32) "$a0") = #(W32 3434807466))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((let: "$a0" := #(W32 1048576) in
    (func_call #roundtripEncDec32) "$a0") = #(W32 1048576))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((let: "$a0" := #(W32 262144) in
    (func_call #roundtripEncDec32) "$a0") = #(W32 262144))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((let: "$a0" := #(W32 1024) in
    (func_call #roundtripEncDec32) "$a0") = #(W32 1024))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((let: "$a0" := #(W32 1) in
    (func_call #roundtripEncDec32) "$a0") = #(W32 1))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((let: "$a0" := #(W32 (4294967296 - 1)) in
    (func_call #roundtripEncDec32) "$a0") = #(W32 (4294967296 - 1)))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    return: (![#boolT] "ok")).

Definition testEncDec64Simple : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testEncDec64Simple"%go.

(* go: encoding.go:62:6 *)
Definition testEncDec64Simpleⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "$r0" := #true in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((let: "$a0" := #(W64 0) in
    (func_call #roundtripEncDec64) "$a0") = #(W64 0))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((let: "$a0" := #(W64 1) in
    (func_call #roundtripEncDec64) "$a0") = #(W64 1))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((let: "$a0" := #(W64 1231234) in
    (func_call #roundtripEncDec64) "$a0") = #(W64 1231234))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    return: (![#boolT] "ok")).

Definition testEncDec64 : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testEncDec64"%go.

(* go: encoding.go:70:6 *)
Definition testEncDec64ⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "$r0" := #true in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((let: "$a0" := #(W64 62206846038638762) in
    (func_call #roundtripEncDec64) "$a0") = #(W64 62206846038638762))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((let: "$a0" := #(W64 9223372036854775808) in
    (func_call #roundtripEncDec64) "$a0") = #(W64 9223372036854775808))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((let: "$a0" := #(W64 140737488355328) in
    (func_call #roundtripEncDec64) "$a0") = #(W64 140737488355328))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((let: "$a0" := #(W64 1048576) in
    (func_call #roundtripEncDec64) "$a0") = #(W64 1048576))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((let: "$a0" := #(W64 262144) in
    (func_call #roundtripEncDec64) "$a0") = #(W64 262144))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((let: "$a0" := #(W64 1024) in
    (func_call #roundtripEncDec64) "$a0") = #(W64 1024))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((let: "$a0" := #(W64 1) in
    (func_call #roundtripEncDec64) "$a0") = #(W64 1))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((let: "$a0" := #(W64 (18446744073709551616 - 1)) in
    (func_call #roundtripEncDec64) "$a0") = #(W64 (18446744073709551616 - 1)))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    return: (![#boolT] "ok")).

Definition FirstClassFunction : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.FirstClassFunction"%go.

(* go: first_class_function.go:3:6 *)
Definition FirstClassFunctionⁱᵐᵖˡ : val :=
  λ: "a",
    exception_do (let: "a" := (mem.alloc "a") in
    return: ((![#uint64T] "a") + #(W64 10))).

Definition ApplyF : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.ApplyF"%go.

(* go: first_class_function.go:7:6 *)
Definition ApplyFⁱᵐᵖˡ : val :=
  λ: "a" "f",
    exception_do (let: "f" := (mem.alloc "f") in
    let: "a" := (mem.alloc "a") in
    return: (let: "$a0" := (![#uint64T] "a") in
     (![#funcT] "f") "$a0")).

Definition testFirstClassFunction : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testFirstClassFunction"%go.

(* go: first_class_function.go:11:6 *)
Definition testFirstClassFunctionⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: ((let: "$a0" := #(W64 1) in
     let: "$a1" := (func_call #FirstClassFunction) in
     (func_call #ApplyF) "$a0" "$a1") = #(W64 11))).

Definition Editor : go_type := structT [
  "s" :: sliceT;
  "next_val" :: uint64T
].

Definition Editorⁱᵈ : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.Editor"%go.

(* advances the array editor, and returns the value it wrote, storing
   "next" in next_val

   go: function_ordering.go:11:18 *)
Definition Editor__AdvanceReturnⁱᵐᵖˡ : val :=
  λ: "e" "next",
    exception_do (let: "e" := (mem.alloc "e") in
    let: "next" := (mem.alloc "next") in
    let: "tmp" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (![#uint64T] (struct.field_ref #Editor #"next_val"%go (![#ptrT] "e"))) in
    do:  ("tmp" <-[#uint64T] "$r0");;;
    let: "$r0" := (![#uint64T] "tmp") in
    do:  ((slice.elem_ref #uint64T (![#sliceT] (struct.field_ref #Editor #"s"%go (![#ptrT] "e"))) #(W64 0)) <-[#uint64T] "$r0");;;
    let: "$r0" := (![#uint64T] "next") in
    do:  ((struct.field_ref #Editor #"next_val"%go (![#ptrT] "e")) <-[#uint64T] "$r0");;;
    let: "$r0" := (let: "$s" := (![#sliceT] (struct.field_ref #Editor #"s"%go (![#ptrT] "e"))) in
    slice.slice #uint64T "$s" #(W64 1) (slice.len "$s")) in
    do:  ((struct.field_ref #Editor #"s"%go (![#ptrT] "e")) <-[#sliceT] "$r0");;;
    return: (![#uint64T] "tmp")).

Definition addFour64 : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.addFour64"%go.

(* we call this function with side-effectful function calls as arguments,
   its implementation is unimportant

   go: function_ordering.go:21:6 *)
Definition addFour64ⁱᵐᵖˡ : val :=
  λ: "a" "b" "c" "d",
    exception_do (let: "d" := (mem.alloc "d") in
    let: "c" := (mem.alloc "c") in
    let: "b" := (mem.alloc "b") in
    let: "a" := (mem.alloc "a") in
    return: ((((![#uint64T] "a") + (![#uint64T] "b")) + (![#uint64T] "c")) + (![#uint64T] "d"))).

Definition Pair : go_type := structT [
  "x" :: uint64T;
  "y" :: uint64T
].

Definition Pairⁱᵈ : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.Pair"%go.

Definition failing_testFunctionOrdering : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.failing_testFunctionOrdering"%go.

(* tests

   go: function_ordering.go:31:6 *)
Definition failing_testFunctionOrderingⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "arr" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make2 #uint64T #(W64 5)) in
    do:  ("arr" <-[#sliceT] "$r0");;;
    let: "e1" := (mem.alloc (type.zero_val #Editor)) in
    let: "$r0" := (let: "$s" := (let: "$s" := (![#sliceT] "arr") in
    slice.slice #uint64T "$s" #(W64 0) (slice.len "$s")) in
    let: "$next_val" := #(W64 1) in
    struct.make #Editor [{
      "s" ::= "$s";
      "next_val" ::= "$next_val"
    }]) in
    do:  ("e1" <-[#Editor] "$r0");;;
    let: "e2" := (mem.alloc (type.zero_val #Editor)) in
    let: "$r0" := (let: "$s" := (let: "$s" := (![#sliceT] "arr") in
    slice.slice #uint64T "$s" #(W64 0) (slice.len "$s")) in
    let: "$next_val" := #(W64 101) in
    struct.make #Editor [{
      "s" ::= "$s";
      "next_val" ::= "$next_val"
    }]) in
    do:  ("e2" <-[#Editor] "$r0");;;
    (if: ((let: "$a0" := #(W64 2) in
    (method_call #semantics.semantics #"Editor'ptr" #"AdvanceReturn" "e1") "$a0") + (let: "$a0" := #(W64 102) in
    (method_call #semantics.semantics #"Editor'ptr" #"AdvanceReturn" "e2") "$a0")) ≠ #(W64 102)
    then return: (#false)
    else do:  #());;;
    (if: (![#uint64T] (slice.elem_ref #uint64T (![#sliceT] "arr") #(W64 0))) ≠ #(W64 101)
    then return: (#false)
    else do:  #());;;
    (if: (let: "$a0" := (let: "$a0" := #(W64 3) in
    (method_call #semantics.semantics #"Editor'ptr" #"AdvanceReturn" "e1") "$a0") in
    let: "$a1" := (let: "$a0" := #(W64 103) in
    (method_call #semantics.semantics #"Editor'ptr" #"AdvanceReturn" "e2") "$a0") in
    let: "$a2" := (let: "$a0" := #(W64 104) in
    (method_call #semantics.semantics #"Editor'ptr" #"AdvanceReturn" "e2") "$a0") in
    let: "$a3" := (let: "$a0" := #(W64 4) in
    (method_call #semantics.semantics #"Editor'ptr" #"AdvanceReturn" "e1") "$a0") in
    (func_call #addFour64) "$a0" "$a1" "$a2" "$a3") ≠ #(W64 210)
    then return: (#false)
    else do:  #());;;
    (if: (![#uint64T] (slice.elem_ref #uint64T (![#sliceT] "arr") #(W64 1))) ≠ #(W64 102)
    then return: (#false)
    else do:  #());;;
    (if: (![#uint64T] (slice.elem_ref #uint64T (![#sliceT] "arr") #(W64 2))) ≠ #(W64 3)
    then return: (#false)
    else do:  #());;;
    let: "p" := (mem.alloc (type.zero_val #Pair)) in
    let: "$r0" := (let: "$x" := (let: "$a0" := #(W64 5) in
    (method_call #semantics.semantics #"Editor'ptr" #"AdvanceReturn" "e1") "$a0") in
    let: "$y" := (let: "$a0" := #(W64 105) in
    (method_call #semantics.semantics #"Editor'ptr" #"AdvanceReturn" "e2") "$a0") in
    struct.make #Pair [{
      "x" ::= "$x";
      "y" ::= "$y"
    }]) in
    do:  ("p" <-[#Pair] "$r0");;;
    (if: (![#uint64T] (slice.elem_ref #uint64T (![#sliceT] "arr") #(W64 3))) ≠ #(W64 104)
    then return: (#false)
    else do:  #());;;
    let: "q" := (mem.alloc (type.zero_val #Pair)) in
    let: "$r0" := (let: "$y" := (let: "$a0" := #(W64 6) in
    (method_call #semantics.semantics #"Editor'ptr" #"AdvanceReturn" "e1") "$a0") in
    let: "$x" := (let: "$a0" := #(W64 106) in
    (method_call #semantics.semantics #"Editor'ptr" #"AdvanceReturn" "e2") "$a0") in
    struct.make #Pair [{
      "x" ::= "$x";
      "y" ::= "$y"
    }]) in
    do:  ("q" <-[#Pair] "$r0");;;
    (if: (![#uint64T] (slice.elem_ref #uint64T (![#sliceT] "arr") #(W64 4))) ≠ #(W64 105)
    then return: (#false)
    else do:  #());;;
    return: (((![#uint64T] (struct.field_ref #Pair #"x"%go "p")) + (![#uint64T] (struct.field_ref #Pair #"x"%go "q"))) = #(W64 109))).

Definition storeAndReturn : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.storeAndReturn"%go.

(* go: function_ordering.go:74:6 *)
Definition storeAndReturnⁱᵐᵖˡ : val :=
  λ: "x" "v",
    exception_do (let: "v" := (mem.alloc "v") in
    let: "x" := (mem.alloc "x") in
    let: "$r0" := (![#uint64T] "v") in
    do:  ((![#ptrT] "x") <-[#uint64T] "$r0");;;
    return: (![#uint64T] "v")).

Definition failing_testArgumentOrder : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.failing_testArgumentOrder"%go.

(* Goose has a right-to-left evaluation order for function arguments,
   which is incorrect.

   go: function_ordering.go:81:6 *)
Definition failing_testArgumentOrderⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("x" <-[#uint64T] "$r0");;;
    do:  (let: "$a0" := (let: "$a0" := "x" in
    let: "$a1" := #(W64 1) in
    (func_call #storeAndReturn) "$a0" "$a1") in
    let: "$a1" := (let: "$a0" := "x" in
    let: "$a1" := #(W64 2) in
    (func_call #storeAndReturn) "$a0" "$a1") in
    let: "$a2" := (let: "$a0" := "x" in
    let: "$a1" := #(W64 3) in
    (func_call #storeAndReturn) "$a0" "$a1") in
    let: "$a3" := (let: "$a0" := "x" in
    let: "$a1" := #(W64 4) in
    (func_call #storeAndReturn) "$a0" "$a1") in
    (func_call #addFour64) "$a0" "$a1" "$a2" "$a3");;;
    let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "$r0" := ((![#uint64T] "x") = #(W64 4)) in
    do:  ("ok" <-[#boolT] "$r0");;;
    return: (![#boolT] "ok")).

Definition testU64ToU32 : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testU64ToU32"%go.

(* go: int_conversions.go:3:6 *)
Definition testU64ToU32ⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "$r0" := #true in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "x" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 1230) in
    do:  ("x" <-[#uint64T] "$r0");;;
    let: "y" := (mem.alloc (type.zero_val #uint32T)) in
    let: "$r0" := #(W32 1230) in
    do:  ("y" <-[#uint32T] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((u_to_w32 (![#uint64T] "x")) = (![#uint32T] "y"))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((u_to_w64 (![#uint32T] "y")) = (![#uint64T] "x"))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    return: (![#boolT] "ok")).

Definition testU32Len : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testU32Len"%go.

(* go: int_conversions.go:12:6 *)
Definition testU32Lenⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "s" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make2 #byteT #(W64 100)) in
    do:  ("s" <-[#sliceT] "$r0");;;
    return: ((s_to_w32 (let: "$a0" := (![#sliceT] "s") in
     slice.len "$a0")) = #(W32 100))).

Definition Uint32 : go_type := uint32T.

Definition Uint32ⁱᵈ : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.Uint32"%go.

Definition failing_testU32NewtypeLen : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.failing_testU32NewtypeLen"%go.

(* https://github.com/goose-lang/goose/issues/14

   go: int_conversions.go:20:6 *)
Definition failing_testU32NewtypeLenⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "s" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make2 #byteT #(W64 20)) in
    do:  ("s" <-[#sliceT] "$r0");;;
    return: ((s_to_w32 (let: "$a0" := (![#sliceT] "s") in
     slice.len "$a0")) = #(W32 20))).

Definition geometryInterface : go_type := interfaceT.

Definition geometryInterfaceⁱᵈ : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.geometryInterface"%go.

Definition measureArea : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.measureArea"%go.

(* go: interfaces.go:12:6 *)
Definition measureAreaⁱᵐᵖˡ : val :=
  λ: "t",
    exception_do (let: "t" := (mem.alloc "t") in
    return: ((interface.get #"Square"%go (![#geometryInterface] "t")) #())).

Definition measureVolumePlusNM : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.measureVolumePlusNM"%go.

(* go: interfaces.go:16:6 *)
Definition measureVolumePlusNMⁱᵐᵖˡ : val :=
  λ: "t" "n" "m",
    exception_do (let: "m" := (mem.alloc "m") in
    let: "n" := (mem.alloc "n") in
    let: "t" := (mem.alloc "t") in
    return: ((((interface.get #"Volume"%go (![#geometryInterface] "t")) #()) + (![#uint64T] "n")) + (![#uint64T] "m"))).

Definition measureVolume : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.measureVolume"%go.

(* go: interfaces.go:20:6 *)
Definition measureVolumeⁱᵐᵖˡ : val :=
  λ: "t",
    exception_do (let: "t" := (mem.alloc "t") in
    return: ((interface.get #"Volume"%go (![#geometryInterface] "t")) #())).

Definition SquareStruct : go_type := structT [
  "Side" :: uint64T
].

Definition SquareStructⁱᵈ : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.SquareStruct"%go.

(* go: interfaces.go:28:23 *)
Definition SquareStruct__Squareⁱᵐᵖˡ : val :=
  λ: "t" <>,
    exception_do (let: "t" := (mem.alloc "t") in
    return: ((![#uint64T] (struct.field_ref #SquareStruct #"Side"%go "t")) * (![#uint64T] (struct.field_ref #SquareStruct #"Side"%go "t")))).

(* go: interfaces.go:32:23 *)
Definition SquareStruct__Volumeⁱᵐᵖˡ : val :=
  λ: "t" <>,
    exception_do (let: "t" := (mem.alloc "t") in
    return: (((![#uint64T] (struct.field_ref #SquareStruct #"Side"%go "t")) * (![#uint64T] (struct.field_ref #SquareStruct #"Side"%go "t"))) * (![#uint64T] (struct.field_ref #SquareStruct #"Side"%go "t")))).

Definition testBasicInterface : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testBasicInterface"%go.

(* go: interfaces.go:40:6 *)
Definition testBasicInterfaceⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "s" := (mem.alloc (type.zero_val #SquareStruct)) in
    let: "$r0" := (let: "$Side" := #(W64 2) in
    struct.make #SquareStruct [{
      "Side" ::= "$Side"
    }]) in
    do:  ("s" <-[#SquareStruct] "$r0");;;
    return: ((let: "$a0" := (interface.make #SquareStructⁱᵈ (![#SquareStruct] "s")) in
     (func_call #measureArea) "$a0") = #(W64 4))).

Definition testAssignInterface : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testAssignInterface"%go.

(* go: interfaces.go:47:6 *)
Definition testAssignInterfaceⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "s" := (mem.alloc (type.zero_val #SquareStruct)) in
    let: "$r0" := (let: "$Side" := #(W64 3) in
    struct.make #SquareStruct [{
      "Side" ::= "$Side"
    }]) in
    do:  ("s" <-[#SquareStruct] "$r0");;;
    let: "area" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (let: "$a0" := (interface.make #SquareStructⁱᵈ (![#SquareStruct] "s")) in
    (func_call #measureArea) "$a0") in
    do:  ("area" <-[#uint64T] "$r0");;;
    return: ((![#uint64T] "area") = #(W64 9))).

Definition testMultipleInterface : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testMultipleInterface"%go.

(* go: interfaces.go:55:6 *)
Definition testMultipleInterfaceⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "s" := (mem.alloc (type.zero_val #SquareStruct)) in
    let: "$r0" := (let: "$Side" := #(W64 3) in
    struct.make #SquareStruct [{
      "Side" ::= "$Side"
    }]) in
    do:  ("s" <-[#SquareStruct] "$r0");;;
    let: "square1" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (let: "$a0" := (interface.make #SquareStructⁱᵈ (![#SquareStruct] "s")) in
    (func_call #measureArea) "$a0") in
    do:  ("square1" <-[#uint64T] "$r0");;;
    let: "square2" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (let: "$a0" := (interface.make #SquareStructⁱᵈ (![#SquareStruct] "s")) in
    (func_call #measureArea) "$a0") in
    do:  ("square2" <-[#uint64T] "$r0");;;
    return: ((![#uint64T] "square1") = (![#uint64T] "square2"))).

Definition testBinaryExprInterface : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testBinaryExprInterface"%go.

(* go: interfaces.go:64:6 *)
Definition testBinaryExprInterfaceⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "s" := (mem.alloc (type.zero_val #SquareStruct)) in
    let: "$r0" := (let: "$Side" := #(W64 3) in
    struct.make #SquareStruct [{
      "Side" ::= "$Side"
    }]) in
    do:  ("s" <-[#SquareStruct] "$r0");;;
    let: "square1" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (let: "$a0" := (interface.make #SquareStructⁱᵈ (![#SquareStruct] "s")) in
    (func_call #measureArea) "$a0") in
    do:  ("square1" <-[#uint64T] "$r0");;;
    let: "square2" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (let: "$a0" := (interface.make #SquareStructⁱᵈ (![#SquareStruct] "s")) in
    (func_call #measureVolume) "$a0") in
    do:  ("square2" <-[#uint64T] "$r0");;;
    return: (((![#uint64T] "square1") = (let: "$a0" := (interface.make #SquareStructⁱᵈ (![#SquareStruct] "s")) in
     (func_call #measureArea) "$a0")) && ((![#uint64T] "square2") = (let: "$a0" := (interface.make #SquareStructⁱᵈ (![#SquareStruct] "s")) in
     (func_call #measureVolume) "$a0")))).

Definition testIfStmtInterface : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testIfStmtInterface"%go.

(* go: interfaces.go:73:6 *)
Definition testIfStmtInterfaceⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "s" := (mem.alloc (type.zero_val #SquareStruct)) in
    let: "$r0" := (let: "$Side" := #(W64 3) in
    struct.make #SquareStruct [{
      "Side" ::= "$Side"
    }]) in
    do:  ("s" <-[#SquareStruct] "$r0");;;
    (if: (let: "$a0" := (interface.make #SquareStructⁱᵈ (![#SquareStruct] "s")) in
    (func_call #measureArea) "$a0") = #(W64 9)
    then return: (#true)
    else do:  #());;;
    return: (#false)).

Definition testsUseLocks : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testsUseLocks"%go.

(* We can't interpret multithreaded code, so this just checks that
   locks are correctly interpreted

   go: lock.go:7:6 *)
Definition testsUseLocksⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "m" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #sync.Mutex)) in
    do:  ("m" <-[#ptrT] "$r0");;;
    do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] "m")) #());;;
    do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] "m")) #());;;
    return: (#true)).

Definition standardForLoop : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.standardForLoop"%go.

(* helpers

   go: loops.go:4:6 *)
Definition standardForLoopⁱᵐᵖˡ : val :=
  λ: "s",
    exception_do (let: "s" := (mem.alloc "s") in
    let: "sumPtr" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #uint64T)) in
    do:  ("sumPtr" <-[#ptrT] "$r0");;;
    (let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (if: (![#uint64T] "i") < (s_to_w64 (let: "$a0" := (![#sliceT] "s") in
      slice.len "$a0"))
      then
        let: "sum" := (mem.alloc (type.zero_val #uint64T)) in
        let: "$r0" := (![#uint64T] (![#ptrT] "sumPtr")) in
        do:  ("sum" <-[#uint64T] "$r0");;;
        let: "x" := (mem.alloc (type.zero_val #uint64T)) in
        let: "$r0" := (![#uint64T] (slice.elem_ref #uint64T (![#sliceT] "s") (![#uint64T] "i"))) in
        do:  ("x" <-[#uint64T] "$r0");;;
        let: "$r0" := ((![#uint64T] "sum") + (![#uint64T] "x")) in
        do:  ((![#ptrT] "sumPtr") <-[#uint64T] "$r0");;;
        let: "$r0" := ((![#uint64T] "i") + #(W64 1)) in
        do:  ("i" <-[#uint64T] "$r0");;;
        continue: #()
      else do:  #());;;
      break: #()));;;
    let: "sum" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (![#uint64T] (![#ptrT] "sumPtr")) in
    do:  ("sum" <-[#uint64T] "$r0");;;
    return: (![#uint64T] "sum")).

Definition LoopStruct : go_type := structT [
  "loopNext" :: ptrT
].

Definition LoopStructⁱᵈ : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.LoopStruct"%go.

(* go: loops.go:28:22 *)
Definition LoopStruct__forLoopWaitⁱᵐᵖˡ : val :=
  λ: "ls" "i",
    exception_do (let: "ls" := (mem.alloc "ls") in
    let: "i" := (mem.alloc "i") in
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "nxt" := (mem.alloc (type.zero_val #ptrT)) in
      let: "$r0" := (![#ptrT] (struct.field_ref #LoopStruct #"loopNext"%go "ls")) in
      do:  ("nxt" <-[#ptrT] "$r0");;;
      (if: (![#uint64T] "i") < (![#uint64T] (![#ptrT] "nxt"))
      then break: #()
      else do:  #());;;
      let: "$r0" := ((![#uint64T] (![#ptrT] (struct.field_ref #LoopStruct #"loopNext"%go "ls"))) + #(W64 1)) in
      do:  ((![#ptrT] (struct.field_ref #LoopStruct #"loopNext"%go "ls")) <-[#uint64T] "$r0");;;
      continue: #());;;
    return: #()).

Definition testStandardForLoop : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testStandardForLoop"%go.

(* tests

   go: loops.go:40:6 *)
Definition testStandardForLoopⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "arr" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make2 #uint64T #(W64 4)) in
    do:  ("arr" <-[#sliceT] "$r0");;;
    do:  ((slice.elem_ref #uint64T (![#sliceT] "arr") #(W64 0)) <-[#uint64T] ((![#uint64T] (slice.elem_ref #uint64T (![#sliceT] "arr") #(W64 0))) + #(W64 1)));;;
    do:  ((slice.elem_ref #uint64T (![#sliceT] "arr") #(W64 1)) <-[#uint64T] ((![#uint64T] (slice.elem_ref #uint64T (![#sliceT] "arr") #(W64 1))) + #(W64 3)));;;
    do:  ((slice.elem_ref #uint64T (![#sliceT] "arr") #(W64 2)) <-[#uint64T] ((![#uint64T] (slice.elem_ref #uint64T (![#sliceT] "arr") #(W64 2))) + #(W64 5)));;;
    do:  ((slice.elem_ref #uint64T (![#sliceT] "arr") #(W64 3)) <-[#uint64T] ((![#uint64T] (slice.elem_ref #uint64T (![#sliceT] "arr") #(W64 3))) + #(W64 7)));;;
    return: ((let: "$a0" := (![#sliceT] "arr") in
     (func_call #standardForLoop) "$a0") = #(W64 16))).

Definition testForLoopWait : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testForLoopWait"%go.

(* go: loops.go:49:6 *)
Definition testForLoopWaitⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ls" := (mem.alloc (type.zero_val #LoopStruct)) in
    let: "$r0" := (let: "$loopNext" := (mem.alloc (type.zero_val #uint64T)) in
    struct.make #LoopStruct [{
      "loopNext" ::= "$loopNext"
    }]) in
    do:  ("ls" <-[#LoopStruct] "$r0");;;
    do:  (let: "$a0" := #(W64 3) in
    (method_call #semantics.semantics #"LoopStruct" #"forLoopWait" (![#LoopStruct] "ls")) "$a0");;;
    return: ((![#uint64T] (![#ptrT] (struct.field_ref #LoopStruct #"loopNext"%go "ls"))) = #(W64 4))).

Definition testBreakFromLoopWithContinue : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testBreakFromLoopWithContinue"%go.

(* go: loops.go:59:6 *)
Definition testBreakFromLoopWithContinueⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (if: #true
      then
        let: "$r0" := ((![#uint64T] "i") + #(W64 1)) in
        do:  ("i" <-[#uint64T] "$r0");;;
        break: #()
      else do:  #());;;
      continue: #());;;
    return: ((![#uint64T] "i") = #(W64 1))).

Definition testBreakFromLoopNoContinue : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testBreakFromLoopNoContinue"%go.

(* go: loops.go:71:6 *)
Definition testBreakFromLoopNoContinueⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (for: (λ: <>, (![#uint64T] "i") < #(W64 3)); (λ: <>, #()) := λ: <>,
      (if: #true
      then
        let: "$r0" := ((![#uint64T] "i") + #(W64 1)) in
        do:  ("i" <-[#uint64T] "$r0");;;
        break: #()
      else do:  #());;;
      let: "$r0" := ((![#uint64T] "i") + #(W64 2)) in
      do:  ("i" <-[#uint64T] "$r0"));;;
    return: ((![#uint64T] "i") = #(W64 1))).

Definition testBreakFromLoopNoContinueDouble : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testBreakFromLoopNoContinueDouble"%go.

(* go: loops.go:83:6 *)
Definition testBreakFromLoopNoContinueDoubleⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (for: (λ: <>, (![#uint64T] "i") < #(W64 3)); (λ: <>, #()) := λ: <>,
      (if: (![#uint64T] "i") = #(W64 1)
      then
        let: "$r0" := ((![#uint64T] "i") + #(W64 1)) in
        do:  ("i" <-[#uint64T] "$r0");;;
        break: #()
      else do:  #());;;
      let: "$r0" := ((![#uint64T] "i") + #(W64 2)) in
      do:  ("i" <-[#uint64T] "$r0");;;
      let: "$r0" := ((![#uint64T] "i") + #(W64 2)) in
      do:  ("i" <-[#uint64T] "$r0"));;;
    return: ((![#uint64T] "i") = #(W64 4))).

Definition testBreakFromLoopForOnly : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testBreakFromLoopForOnly"%go.

(* go: loops.go:96:6 *)
Definition testBreakFromLoopForOnlyⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (for: (λ: <>, (![#uint64T] "i") < #(W64 3)); (λ: <>, #()) := λ: <>,
      let: "$r0" := ((![#uint64T] "i") + #(W64 2)) in
      do:  ("i" <-[#uint64T] "$r0"));;;
    return: ((![#uint64T] "i") = #(W64 4))).

Definition testBreakFromLoopAssignAndContinue : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testBreakFromLoopAssignAndContinue"%go.

(* go: loops.go:104:6 *)
Definition testBreakFromLoopAssignAndContinueⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (for: (λ: <>, (![#uint64T] "i") < #(W64 3)); (λ: <>, #()) := λ: <>,
      (if: #true
      then
        let: "$r0" := ((![#uint64T] "i") + #(W64 1)) in
        do:  ("i" <-[#uint64T] "$r0");;;
        break: #()
      else do:  #());;;
      let: "$r0" := ((![#uint64T] "i") + #(W64 2)) in
      do:  ("i" <-[#uint64T] "$r0");;;
      continue: #());;;
    return: ((![#uint64T] "i") = #(W64 1))).

Definition testNestedLoops : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testNestedLoops"%go.

(* go: loops.go:117:6 *)
Definition testNestedLoopsⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok1" := (mem.alloc (type.zero_val #boolT)) in
    let: "$r0" := #false in
    do:  ("ok1" <-[#boolT] "$r0");;;
    let: "ok2" := (mem.alloc (type.zero_val #boolT)) in
    let: "$r0" := #false in
    do:  ("ok2" <-[#boolT] "$r0");;;
    (let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (let: "j" := (mem.alloc (type.zero_val #uint64T)) in
      let: "$r0" := #(W64 0) in
      do:  ("j" <-[#uint64T] "$r0");;;
      (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
        (if: (![#uint64T] "j") > #(W64 5)
        then break: #()
        else do:  #());;;
        let: "$r0" := ((![#uint64T] "j") + #(W64 1)) in
        do:  ("j" <-[#uint64T] "$r0");;;
        let: "$r0" := ((![#uint64T] "j") = #(W64 6)) in
        do:  ("ok1" <-[#boolT] "$r0");;;
        continue: #()));;;
      let: "$r0" := ((![#uint64T] "i") + #(W64 1)) in
      do:  ("i" <-[#uint64T] "$r0");;;
      let: "$r0" := ((![#uint64T] "i") = #(W64 1)) in
      do:  ("ok2" <-[#boolT] "$r0");;;
      break: #()));;;
    return: ((![#boolT] "ok1") && (![#boolT] "ok2"))).

Definition testNestedGoStyleLoops : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testNestedGoStyleLoops"%go.

(* go: loops.go:136:6 *)
Definition testNestedGoStyleLoopsⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "$r0" := #false in
    do:  ("ok" <-[#boolT] "$r0");;;
    (let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (for: (λ: <>, (![#uint64T] "i") < #(W64 10)); (λ: <>, do:  ("i" <-[#uint64T] ((![#uint64T] "i") + #(W64 1)))) := λ: <>,
      (let: "j" := (mem.alloc (type.zero_val #uint64T)) in
      let: "$r0" := #(W64 0) in
      do:  ("j" <-[#uint64T] "$r0");;;
      (for: (λ: <>, (![#uint64T] "j") < (![#uint64T] "i")); (λ: <>, do:  ("j" <-[#uint64T] ((![#uint64T] "j") + #(W64 1)))) := λ: <>,
        (if: #true
        then break: #()
        else do:  #());;;
        continue: #()));;;
      let: "$r0" := ((![#uint64T] "i") = #(W64 9)) in
      do:  ("ok" <-[#boolT] "$r0")));;;
    return: (![#boolT] "ok")).

Definition testNestedGoStyleLoopsNoComparison : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testNestedGoStyleLoopsNoComparison"%go.

(* go: loops.go:150:6 *)
Definition testNestedGoStyleLoopsNoComparisonⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "$r0" := #false in
    do:  ("ok" <-[#boolT] "$r0");;;
    (let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (for: (λ: <>, (![#uint64T] "i") < #(W64 10)); (λ: <>, do:  ("i" <-[#uint64T] ((![#uint64T] "i") + #(W64 1)))) := λ: <>,
      (let: "j" := (mem.alloc (type.zero_val #uint64T)) in
      let: "$r0" := #(W64 0) in
      do:  ("j" <-[#uint64T] "$r0");;;
      (for: (λ: <>, (![#uint64T] "j") < (![#uint64T] "i")); (λ: <>, do:  ("j" <-[#uint64T] ((![#uint64T] "j") + #(W64 1)))) := λ: <>,
        (if: #true
        then break: #()
        else do:  #());;;
        continue: #()));;;
      let: "$r0" := ((![#uint64T] "i") = #(W64 9)) in
      do:  ("ok" <-[#boolT] "$r0")));;;
    return: (![#boolT] "ok")).

Definition IterateMapKeys : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.IterateMapKeys"%go.

(* go: maps.go:3:6 *)
Definition IterateMapKeysⁱᵐᵖˡ : val :=
  λ: "m",
    exception_do (let: "m" := (mem.alloc "m") in
    let: "sum" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$range" := (![type.mapT #uint64T #uint64T] "m") in
    (let: "k" := (mem.alloc (type.zero_val #uint64T)) in
    map.for_range "$range" (λ: "$key" "value",
      do:  ("k" <-[#uint64T] "$key");;;
      let: "$r0" := ((![#uint64T] "sum") + (![#uint64T] "k")) in
      do:  ("sum" <-[#uint64T] "$r0")));;;
    return: (![#uint64T] "sum")).

Definition IterateMapValues : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.IterateMapValues"%go.

(* go: maps.go:11:6 *)
Definition IterateMapValuesⁱᵐᵖˡ : val :=
  λ: "m",
    exception_do (let: "m" := (mem.alloc "m") in
    let: "sum" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$range" := (![type.mapT #uint64T #uint64T] "m") in
    (let: "v" := (mem.alloc (type.zero_val #uint64T)) in
    map.for_range "$range" (λ: "$key" "value",
      do:  ("v" <-[#uint64T] "$value");;;
      do:  "$key";;;
      let: "$r0" := ((![#uint64T] "sum") + (![#uint64T] "v")) in
      do:  ("sum" <-[#uint64T] "$r0")));;;
    return: (![#uint64T] "sum")).

Definition testIterateMap : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testIterateMap"%go.

(* go: maps.go:19:6 *)
Definition testIterateMapⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "$r0" := #true in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "m" := (mem.alloc (type.zero_val (type.mapT #uint64T #uint64T))) in
    let: "$r0" := (map.make #uint64T #uint64T) in
    do:  ("m" <-[type.mapT #uint64T #uint64T] "$r0");;;
    let: "$r0" := #(W64 1) in
    do:  (map.insert (![type.mapT #uint64T #uint64T] "m") #(W64 0) "$r0");;;
    let: "$r0" := #(W64 2) in
    do:  (map.insert (![type.mapT #uint64T #uint64T] "m") #(W64 1) "$r0");;;
    let: "$r0" := #(W64 4) in
    do:  (map.insert (![type.mapT #uint64T #uint64T] "m") #(W64 3) "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((let: "$a0" := (![type.mapT #uint64T #uint64T] "m") in
    (func_call #IterateMapKeys) "$a0") = #(W64 4))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((let: "$a0" := (![type.mapT #uint64T #uint64T] "m") in
    (func_call #IterateMapValues) "$a0") = #(W64 7))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    return: (![#boolT] "ok")).

Definition testMapSize : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testMapSize"%go.

(* go: maps.go:37:6 *)
Definition testMapSizeⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "$r0" := #true in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "m" := (mem.alloc (type.zero_val (type.mapT #uint64T #uint64T))) in
    let: "$r0" := (map.make #uint64T #uint64T) in
    do:  ("m" <-[type.mapT #uint64T #uint64T] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((s_to_w64 (let: "$a0" := (![type.mapT #uint64T #uint64T] "m") in
    map.len "$a0")) = #(W64 0))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := #(W64 1) in
    do:  (map.insert (![type.mapT #uint64T #uint64T] "m") #(W64 0) "$r0");;;
    let: "$r0" := #(W64 2) in
    do:  (map.insert (![type.mapT #uint64T #uint64T] "m") #(W64 1) "$r0");;;
    let: "$r0" := #(W64 4) in
    do:  (map.insert (![type.mapT #uint64T #uint64T] "m") #(W64 3) "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((s_to_w64 (let: "$a0" := (![type.mapT #uint64T #uint64T] "m") in
    map.len "$a0")) = #(W64 3))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    return: (![#boolT] "ok")).

Definition multReturnTwo : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.multReturnTwo"%go.

(* go: multiple_assign.go:3:6 *)
Definition multReturnTwoⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (#(W64 2), #(W64 3))).

Definition testAssignTwo : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testAssignTwo"%go.

(* go: multiple_assign.go:7:6 *)
Definition testAssignTwoⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 10) in
    do:  ("x" <-[#uint64T] "$r0");;;
    let: "y" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 15) in
    do:  ("y" <-[#uint64T] "$r0");;;
    let: ("$ret0", "$ret1") := ((func_call #multReturnTwo) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("x" <-[#uint64T] "$r0");;;
    do:  ("y" <-[#uint64T] "$r1");;;
    return: (((![#uint64T] "x") = #(W64 2)) && ((![#uint64T] "y") = #(W64 3)))).

Definition multReturnThree : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.multReturnThree"%go.

(* go: multiple_assign.go:14:6 *)
Definition multReturnThreeⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (#(W64 2), #true, #(W32 1))).

Definition testAssignThree : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testAssignThree"%go.

(* go: multiple_assign.go:18:6 *)
Definition testAssignThreeⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 10) in
    do:  ("x" <-[#uint64T] "$r0");;;
    let: "y" := (mem.alloc (type.zero_val #boolT)) in
    let: "$r0" := #false in
    do:  ("y" <-[#boolT] "$r0");;;
    let: "z" := (mem.alloc (type.zero_val #uint32T)) in
    let: "$r0" := #(W32 15) in
    do:  ("z" <-[#uint32T] "$r0");;;
    let: (("$ret0", "$ret1"), "$ret2") := ((func_call #multReturnThree) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("x" <-[#uint64T] "$r0");;;
    do:  ("y" <-[#boolT] "$r1");;;
    do:  ("z" <-[#uint32T] "$r2");;;
    return: ((((![#uint64T] "x") = #(W64 2)) && ((![#boolT] "y") = #true)) && ((![#uint32T] "z") = #(W32 1)))).

Definition testMultipleAssignToMap : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testMultipleAssignToMap"%go.

(* go: multiple_assign.go:26:6 *)
Definition testMultipleAssignToMapⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 10) in
    do:  ("x" <-[#uint64T] "$r0");;;
    let: "m" := (mem.alloc (type.zero_val (type.mapT #uint64T #uint64T))) in
    let: "$r0" := (map.make #uint64T #uint64T) in
    do:  ("m" <-[type.mapT #uint64T #uint64T] "$r0");;;
    let: ("$ret0", "$ret1") := ((func_call #multReturnTwo) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("x" <-[#uint64T] "$r0");;;
    do:  (map.insert (![type.mapT #uint64T #uint64T] "m") #(W64 0) "$r1");;;
    return: (((![#uint64T] "x") = #(W64 2)) && ((Fst (map.get (![type.mapT #uint64T #uint64T] "m") #(W64 0))) = #(W64 3)))).

Definition returnTwo : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.returnTwo"%go.

(* go: multiple_return.go:3:6 *)
Definition returnTwoⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (#(W64 2), #(W64 3))).

Definition testReturnTwo : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testReturnTwo"%go.

(* go: multiple_return.go:7:6 *)
Definition testReturnTwoⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "y" := (mem.alloc (type.zero_val #uint64T)) in
    let: "x" := (mem.alloc (type.zero_val #uint64T)) in
    let: ("$ret0", "$ret1") := ((func_call #returnTwo) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("x" <-[#uint64T] "$r0");;;
    do:  ("y" <-[#uint64T] "$r1");;;
    return: (((![#uint64T] "x") = #(W64 2)) && ((![#uint64T] "y") = #(W64 3)))).

Definition testAnonymousBinding : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testAnonymousBinding"%go.

(* go: multiple_return.go:12:6 *)
Definition testAnonymousBindingⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "y" := (mem.alloc (type.zero_val #uint64T)) in
    let: ("$ret0", "$ret1") := ((func_call #returnTwo) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  "$r0";;;
    do:  ("y" <-[#uint64T] "$r1");;;
    return: ((![#uint64T] "y") = #(W64 3))).

Definition returnThree : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.returnThree"%go.

(* go: multiple_return.go:17:6 *)
Definition returnThreeⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (#(W64 2), #true, #(W32 1))).

Definition testReturnThree : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testReturnThree"%go.

(* go: multiple_return.go:21:6 *)
Definition testReturnThreeⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "z" := (mem.alloc (type.zero_val #uint32T)) in
    let: "y" := (mem.alloc (type.zero_val #boolT)) in
    let: "x" := (mem.alloc (type.zero_val #uint64T)) in
    let: (("$ret0", "$ret1"), "$ret2") := ((func_call #returnThree) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("x" <-[#uint64T] "$r0");;;
    do:  ("y" <-[#boolT] "$r1");;;
    do:  ("z" <-[#uint32T] "$r2");;;
    return: ((((![#uint64T] "x") = #(W64 2)) && ((![#boolT] "y") = #true)) && ((![#uint32T] "z") = #(W32 1)))).

Definition returnFour : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.returnFour"%go.

(* go: multiple_return.go:26:6 *)
Definition returnFourⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (#(W64 2), #true, #(W32 1), #(W64 7))).

Definition testReturnFour : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testReturnFour"%go.

(* go: multiple_return.go:30:6 *)
Definition testReturnFourⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "w" := (mem.alloc (type.zero_val #uint64T)) in
    let: "z" := (mem.alloc (type.zero_val #uint32T)) in
    let: "y" := (mem.alloc (type.zero_val #boolT)) in
    let: "x" := (mem.alloc (type.zero_val #uint64T)) in
    let: ((("$ret0", "$ret1"), "$ret2"), "$ret3") := ((func_call #returnFour) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    let: "$r3" := "$ret3" in
    do:  ("x" <-[#uint64T] "$r0");;;
    do:  ("y" <-[#boolT] "$r1");;;
    do:  ("z" <-[#uint32T] "$r2");;;
    do:  ("w" <-[#uint64T] "$r3");;;
    return: (((((![#uint64T] "x") = #(W64 2)) && ((![#boolT] "y") = #true)) && ((![#uint32T] "z") = #(W32 1))) && ((![#uint64T] "w") = #(W64 7)))).

Definition failing_testCompareSliceToNil : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.failing_testCompareSliceToNil"%go.

(* go: nil.go:3:6 *)
Definition failing_testCompareSliceToNilⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "s" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make2 #byteT #(W64 0)) in
    do:  ("s" <-[#sliceT] "$r0");;;
    return: ((![#sliceT] "s") ≠ #slice.nil)).

Definition testComparePointerToNil : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testComparePointerToNil"%go.

(* go: nil.go:8:6 *)
Definition testComparePointerToNilⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "s" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #uint64T)) in
    do:  ("s" <-[#ptrT] "$r0");;;
    return: ((![#ptrT] "s") ≠ #null)).

Definition testCompareNilToNil : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testCompareNilToNil"%go.

(* go: nil.go:13:6 *)
Definition testCompareNilToNilⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "s" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #ptrT)) in
    do:  ("s" <-[#ptrT] "$r0");;;
    return: ((![#ptrT] (![#ptrT] "s")) = #null)).

Definition testComparePointerWrappedToNil : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testComparePointerWrappedToNil"%go.

(* go: nil.go:18:6 *)
Definition testComparePointerWrappedToNilⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "s" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make2 #byteT #(W64 1)) in
    do:  ("s" <-[#sliceT] "$r0");;;
    return: ((![#sliceT] "s") ≠ #slice.nil)).

Definition testComparePointerWrappedDefaultToNil : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testComparePointerWrappedDefaultToNil"%go.

(* go: nil.go:24:6 *)
Definition testComparePointerWrappedDefaultToNilⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "s" := (mem.alloc (type.zero_val #sliceT)) in
    return: ((![#sliceT] "s") = #slice.nil)).

Definition reverseAssignOps64 : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.reverseAssignOps64"%go.

(* helpers

   go: operations.go:4:6 *)
Definition reverseAssignOps64ⁱᵐᵖˡ : val :=
  λ: "x",
    exception_do (let: "x" := (mem.alloc "x") in
    let: "y" := (mem.alloc (type.zero_val #uint64T)) in
    do:  ("y" <-[#uint64T] ((![#uint64T] "y") + (![#uint64T] "x")));;;
    do:  ("y" <-[#uint64T] ((![#uint64T] "y") - (![#uint64T] "x")));;;
    do:  ("y" <-[#uint64T] ((![#uint64T] "y") + #(W64 1)));;;
    do:  ("y" <-[#uint64T] ((![#uint64T] "y") - #(W64 1)));;;
    return: (![#uint64T] "y")).

Definition reverseAssignOps32 : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.reverseAssignOps32"%go.

(* go: operations.go:13:6 *)
Definition reverseAssignOps32ⁱᵐᵖˡ : val :=
  λ: "x",
    exception_do (let: "x" := (mem.alloc "x") in
    let: "y" := (mem.alloc (type.zero_val #uint32T)) in
    do:  ("y" <-[#uint32T] ((![#uint32T] "y") + (![#uint32T] "x")));;;
    do:  ("y" <-[#uint32T] ((![#uint32T] "y") - (![#uint32T] "x")));;;
    do:  ("y" <-[#uint32T] ((![#uint32T] "y") + #(W32 1)));;;
    do:  ("y" <-[#uint32T] ((![#uint32T] "y") - #(W32 1)));;;
    return: (![#uint32T] "y")).

Definition add64Equals : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.add64Equals"%go.

(* go: operations.go:22:6 *)
Definition add64Equalsⁱᵐᵖˡ : val :=
  λ: "x" "y" "z",
    exception_do (let: "z" := (mem.alloc "z") in
    let: "y" := (mem.alloc "y") in
    let: "x" := (mem.alloc "x") in
    return: (((![#uint64T] "x") + (![#uint64T] "y")) = (![#uint64T] "z"))).

Definition sub64Equals : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.sub64Equals"%go.

(* go: operations.go:26:6 *)
Definition sub64Equalsⁱᵐᵖˡ : val :=
  λ: "x" "y" "z",
    exception_do (let: "z" := (mem.alloc "z") in
    let: "y" := (mem.alloc "y") in
    let: "x" := (mem.alloc "x") in
    return: (((![#uint64T] "x") - (![#uint64T] "y")) = (![#uint64T] "z"))).

Definition testReverseAssignOps64 : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testReverseAssignOps64"%go.

(* tests

   go: operations.go:31:6 *)
Definition testReverseAssignOps64ⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "$r0" := #true in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((let: "$a0" := #(W64 0) in
    (func_call #reverseAssignOps64) "$a0") = #(W64 0))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((let: "$a0" := #(W64 1) in
    (func_call #reverseAssignOps64) "$a0") = #(W64 0))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((let: "$a0" := #(W64 1231234) in
    (func_call #reverseAssignOps64) "$a0") = #(W64 0))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((let: "$a0" := #(W64 62206846038638762) in
    (func_call #reverseAssignOps64) "$a0") = #(W64 0))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((let: "$a0" := #(W64 9223372036854775808) in
    (func_call #reverseAssignOps64) "$a0") = #(W64 0))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((let: "$a0" := #(W64 140737488355328) in
    (func_call #reverseAssignOps64) "$a0") = #(W64 0))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((let: "$a0" := #(W64 1048576) in
    (func_call #reverseAssignOps64) "$a0") = #(W64 0))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((let: "$a0" := #(W64 262144) in
    (func_call #reverseAssignOps64) "$a0") = #(W64 0))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((let: "$a0" := #(W64 1024) in
    (func_call #reverseAssignOps64) "$a0") = #(W64 0))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((let: "$a0" := #(W64 1) in
    (func_call #reverseAssignOps64) "$a0") = #(W64 0))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((let: "$a0" := #(W64 (18446744073709551616 - 1)) in
    (func_call #reverseAssignOps64) "$a0") = #(W64 0))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    return: (![#boolT] "ok")).

Definition failing_testReverseAssignOps32 : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.failing_testReverseAssignOps32"%go.

(* go: operations.go:47:6 *)
Definition failing_testReverseAssignOps32ⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "$r0" := #true in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((let: "$a0" := #(W32 0) in
    (func_call #reverseAssignOps32) "$a0") = #(W32 0))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((let: "$a0" := #(W32 1) in
    (func_call #reverseAssignOps32) "$a0") = #(W32 0))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((let: "$a0" := #(W32 1231234) in
    (func_call #reverseAssignOps32) "$a0") = #(W32 0))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((let: "$a0" := #(W32 3434807466) in
    (func_call #reverseAssignOps32) "$a0") = #(W32 0))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((let: "$a0" := #(W32 1048576) in
    (func_call #reverseAssignOps32) "$a0") = #(W32 0))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((let: "$a0" := #(W32 262144) in
    (func_call #reverseAssignOps32) "$a0") = #(W32 0))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((let: "$a0" := #(W32 1024) in
    (func_call #reverseAssignOps32) "$a0") = #(W32 0))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((let: "$a0" := #(W32 1) in
    (func_call #reverseAssignOps32) "$a0") = #(W32 0))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((let: "$a0" := #(W32 (4294967296 - 1)) in
    (func_call #reverseAssignOps32) "$a0") = #(W32 0))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    return: (![#boolT] "ok")).

Definition testAdd64Equals : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testAdd64Equals"%go.

(* go: operations.go:61:6 *)
Definition testAdd64Equalsⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "$r0" := #true in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && (let: "$a0" := #(W64 2) in
    let: "$a1" := #(W64 3) in
    let: "$a2" := #(W64 5) in
    (func_call #add64Equals) "$a0" "$a1" "$a2")) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && (let: "$a0" := #(W64 (18446744073709551616 - 1)) in
    let: "$a1" := #(W64 1) in
    let: "$a2" := #(W64 0) in
    (func_call #add64Equals) "$a0" "$a1" "$a2")) in
    do:  ("ok" <-[#boolT] "$r0");;;
    return: (![#boolT] "ok")).

Definition testSub64Equals : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testSub64Equals"%go.

(* go: operations.go:68:6 *)
Definition testSub64Equalsⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "$r0" := #true in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && (let: "$a0" := #(W64 2) in
    let: "$a1" := #(W64 1) in
    let: "$a2" := #(W64 1) in
    (func_call #sub64Equals) "$a0" "$a1" "$a2")) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && (let: "$a0" := #(W64 (18446744073709551616 - 1)) in
    let: "$a1" := #(W64 9223372036854775808) in
    let: "$a2" := #(W64 (9223372036854775808 - 1)) in
    (func_call #sub64Equals) "$a0" "$a1" "$a2")) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && (let: "$a0" := #(W64 2) in
    let: "$a1" := #(W64 8) in
    let: "$a2" := #(W64 (18446744073709551616 - 6)) in
    (func_call #sub64Equals) "$a0" "$a1" "$a2")) in
    do:  ("ok" <-[#boolT] "$r0");;;
    return: (![#boolT] "ok")).

Definition testDivisionPrecedence : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testDivisionPrecedence"%go.

(* go: operations.go:76:6 *)
Definition testDivisionPrecedenceⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "blockSize" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 4096) in
    do:  ("blockSize" <-[#uint64T] "$r0");;;
    let: "hdrmeta" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 8) in
    do:  ("hdrmeta" <-[#uint64T] "$r0");;;
    let: "hdraddrs" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (((![#uint64T] "blockSize") - (![#uint64T] "hdrmeta")) `quot` #(W64 8)) in
    do:  ("hdraddrs" <-[#uint64T] "$r0");;;
    return: ((![#uint64T] "hdraddrs") = #(W64 511))).

Definition testModPrecedence : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testModPrecedence"%go.

(* go: operations.go:83:6 *)
Definition testModPrecedenceⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x1" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := #(W64 (513 + (12 `rem` 8))) in
    do:  ("x1" <-[#intT] "$r0");;;
    let: "x2" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := #(W64 ((513 + 12) `rem` 8)) in
    do:  ("x2" <-[#intT] "$r0");;;
    return: (((![#intT] "x1") = #(W64 517)) && ((![#intT] "x2") = #(W64 5)))).

Definition testBitwiseOpsPrecedence : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testBitwiseOpsPrecedence"%go.

(* go: operations.go:89:6 *)
Definition testBitwiseOpsPrecedenceⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "$r0" := #true in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && #(479 =? 479)) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && #(132 =? 132)) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && #(828 =? 828)) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && #(893 =? 893)) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && #(461 =? 461)) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && #(negb (479 =? 389))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    return: (![#boolT] "ok")).

Definition testArithmeticShifts : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testArithmeticShifts"%go.

(* go: operations.go:102:6 *)
Definition testArithmeticShiftsⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "$r0" := #true in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && #(5376 =? 5376)) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && #(1513209474796486656 =? 1513209474796486656)) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && #(42 =? 42)) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && #(0 =? 0)) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && #(672 =? 672)) in
    do:  ("ok" <-[#boolT] "$r0");;;
    return: (![#boolT] "ok")).

Definition testBitAddAnd : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testBitAddAnd"%go.

(* go: operations.go:114:6 *)
Definition testBitAddAndⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "tid" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 17) in
    do:  ("tid" <-[#uint64T] "$r0");;;
    let: "n" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 16) in
    do:  ("n" <-[#uint64T] "$r0");;;
    return: ((((![#uint64T] "tid") + (![#uint64T] "n")) `and` (~ ((![#uint64T] "n") - #(W64 1)))) = #(W64 32))).

Definition testManyParentheses : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testManyParentheses"%go.

(* go: operations.go:120:6 *)
Definition testManyParenthesesⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (#((3 * 6) =? (3 * 6)))).

Definition testPlusTimes : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testPlusTimes"%go.

(* go: operations.go:124:6 *)
Definition testPlusTimesⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (#(((2 + 5) * 2) =? 14))).

Definition testOrCompareSimple : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testOrCompareSimple"%go.

(* go: precedence.go:3:6 *)
Definition testOrCompareSimpleⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do ((if: #(3 >? 4) || #(4 >? 3)
    then return: (#true)
    else do:  #());;;
    return: (#false)).

Definition testOrCompare : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testOrCompare"%go.

(* go: precedence.go:10:6 *)
Definition testOrCompareⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "$r0" := #true in
    do:  ("ok" <-[#boolT] "$r0");;;
    (if: (~ (#(3 >? 4) || #(4 >? 3)))
    then
      let: "$r0" := #false in
      do:  ("ok" <-[#boolT] "$r0")
    else do:  #());;;
    (if: #(4 <? 3) || #(2 >? 3)
    then
      let: "$r0" := #false in
      do:  ("ok" <-[#boolT] "$r0")
    else do:  #());;;
    return: (![#boolT] "ok")).

Definition testAndCompare : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testAndCompare"%go.

(* go: precedence.go:22:6 *)
Definition testAndCompareⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "$r0" := #true in
    do:  ("ok" <-[#boolT] "$r0");;;
    (if: #(3 >? 4) && #(4 >? 3)
    then
      let: "$r0" := #false in
      do:  ("ok" <-[#boolT] "$r0")
    else do:  #());;;
    (if: #(4 >? 3) || #(2 <? 3)
    then do:  #()
    else
      let: "$r0" := #false in
      do:  ("ok" <-[#boolT] "$r0"));;;
    return: (![#boolT] "ok")).

Definition testShiftMod : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testShiftMod"%go.

(* go: precedence.go:34:6 *)
Definition testShiftModⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (#(20 =? 20))).

Definition testLinearize : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testLinearize"%go.

(* go: prims.go:9:6 *)
Definition testLinearizeⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "m" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #sync.Mutex)) in
    do:  ("m" <-[#ptrT] "$r0");;;
    do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] "m")) #());;;
    do:  ((func_call #primitive.Linearize) #());;;
    do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] "m")) #());;;
    return: (#true)).

Definition BoolTest : go_type := structT [
  "t" :: boolT;
  "f" :: boolT;
  "tc" :: uint64T;
  "fc" :: uint64T
].

Definition BoolTestⁱᵈ : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.BoolTest"%go.

Definition CheckTrue : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.CheckTrue"%go.

(* go: shortcircuiting.go:11:6 *)
Definition CheckTrueⁱᵐᵖˡ : val :=
  λ: "b",
    exception_do (let: "b" := (mem.alloc "b") in
    do:  ((struct.field_ref #BoolTest #"tc"%go (![#ptrT] "b")) <-[#uint64T] ((![#uint64T] (struct.field_ref #BoolTest #"tc"%go (![#ptrT] "b"))) + #(W64 1)));;;
    return: (![#boolT] (struct.field_ref #BoolTest #"t"%go (![#ptrT] "b")))).

Definition CheckFalse : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.CheckFalse"%go.

(* go: shortcircuiting.go:16:6 *)
Definition CheckFalseⁱᵐᵖˡ : val :=
  λ: "b",
    exception_do (let: "b" := (mem.alloc "b") in
    do:  ((struct.field_ref #BoolTest #"fc"%go (![#ptrT] "b")) <-[#uint64T] ((![#uint64T] (struct.field_ref #BoolTest #"fc"%go (![#ptrT] "b"))) + #(W64 1)));;;
    return: (![#boolT] (struct.field_ref #BoolTest #"f"%go (![#ptrT] "b")))).

Definition testShortcircuitAndTF : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testShortcircuitAndTF"%go.

(* tests

   go: shortcircuiting.go:22:6 *)
Definition testShortcircuitAndTFⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "b" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (let: "$t" := #true in
    let: "$f" := #false in
    let: "$tc" := #(W64 0) in
    let: "$fc" := #(W64 0) in
    struct.make #BoolTest [{
      "t" ::= "$t";
      "f" ::= "$f";
      "tc" ::= "$tc";
      "fc" ::= "$fc"
    }])) in
    do:  ("b" <-[#ptrT] "$r0");;;
    (if: (let: "$a0" := (![#ptrT] "b") in
    (func_call #CheckTrue) "$a0") && (let: "$a0" := (![#ptrT] "b") in
    (func_call #CheckFalse) "$a0")
    then return: (#false)
    else do:  #());;;
    return: (((![#uint64T] (struct.field_ref #BoolTest #"tc"%go (![#ptrT] "b"))) = #(W64 1)) && ((![#uint64T] (struct.field_ref #BoolTest #"fc"%go (![#ptrT] "b"))) = #(W64 1)))).

Definition testShortcircuitAndFT : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testShortcircuitAndFT"%go.

(* go: shortcircuiting.go:31:6 *)
Definition testShortcircuitAndFTⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "b" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (let: "$t" := #true in
    let: "$f" := #false in
    let: "$tc" := #(W64 0) in
    let: "$fc" := #(W64 0) in
    struct.make #BoolTest [{
      "t" ::= "$t";
      "f" ::= "$f";
      "tc" ::= "$tc";
      "fc" ::= "$fc"
    }])) in
    do:  ("b" <-[#ptrT] "$r0");;;
    (if: (let: "$a0" := (![#ptrT] "b") in
    (func_call #CheckFalse) "$a0") && (let: "$a0" := (![#ptrT] "b") in
    (func_call #CheckTrue) "$a0")
    then return: (#false)
    else do:  #());;;
    return: (((![#uint64T] (struct.field_ref #BoolTest #"tc"%go (![#ptrT] "b"))) = #(W64 0)) && ((![#uint64T] (struct.field_ref #BoolTest #"fc"%go (![#ptrT] "b"))) = #(W64 1)))).

Definition testShortcircuitOrTF : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testShortcircuitOrTF"%go.

(* go: shortcircuiting.go:40:6 *)
Definition testShortcircuitOrTFⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "b" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (let: "$t" := #true in
    let: "$f" := #false in
    let: "$tc" := #(W64 0) in
    let: "$fc" := #(W64 0) in
    struct.make #BoolTest [{
      "t" ::= "$t";
      "f" ::= "$f";
      "tc" ::= "$tc";
      "fc" ::= "$fc"
    }])) in
    do:  ("b" <-[#ptrT] "$r0");;;
    (if: (let: "$a0" := (![#ptrT] "b") in
    (func_call #CheckTrue) "$a0") || (let: "$a0" := (![#ptrT] "b") in
    (func_call #CheckFalse) "$a0")
    then return: (((![#uint64T] (struct.field_ref #BoolTest #"tc"%go (![#ptrT] "b"))) = #(W64 1)) && ((![#uint64T] (struct.field_ref #BoolTest #"fc"%go (![#ptrT] "b"))) = #(W64 0)))
    else do:  #());;;
    return: (#false)).

Definition testShortcircuitOrFT : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testShortcircuitOrFT"%go.

(* go: shortcircuiting.go:48:6 *)
Definition testShortcircuitOrFTⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "b" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (let: "$t" := #true in
    let: "$f" := #false in
    let: "$tc" := #(W64 0) in
    let: "$fc" := #(W64 0) in
    struct.make #BoolTest [{
      "t" ::= "$t";
      "f" ::= "$f";
      "tc" ::= "$tc";
      "fc" ::= "$fc"
    }])) in
    do:  ("b" <-[#ptrT] "$r0");;;
    (if: (let: "$a0" := (![#ptrT] "b") in
    (func_call #CheckFalse) "$a0") || (let: "$a0" := (![#ptrT] "b") in
    (func_call #CheckTrue) "$a0")
    then return: (((![#uint64T] (struct.field_ref #BoolTest #"tc"%go (![#ptrT] "b"))) = #(W64 1)) && ((![#uint64T] (struct.field_ref #BoolTest #"fc"%go (![#ptrT] "b"))) = #(W64 1)))
    else do:  #());;;
    return: (#false)).

Definition ArrayEditor : go_type := structT [
  "s" :: sliceT;
  "next_val" :: uint64T
].

Definition ArrayEditorⁱᵈ : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.ArrayEditor"%go.

(* go: slices.go:9:24 *)
Definition ArrayEditor__Advanceⁱᵐᵖˡ : val :=
  λ: "ae" "arr" "next",
    exception_do (let: "ae" := (mem.alloc "ae") in
    let: "next" := (mem.alloc "next") in
    let: "arr" := (mem.alloc "arr") in
    do:  ((slice.elem_ref #uint64T (![#sliceT] "arr") #(W64 0)) <-[#uint64T] ((![#uint64T] (slice.elem_ref #uint64T (![#sliceT] "arr") #(W64 0))) + #(W64 1)));;;
    let: "$r0" := (![#uint64T] (struct.field_ref #ArrayEditor #"next_val"%go (![#ptrT] "ae"))) in
    do:  ((slice.elem_ref #uint64T (![#sliceT] (struct.field_ref #ArrayEditor #"s"%go (![#ptrT] "ae"))) #(W64 0)) <-[#uint64T] "$r0");;;
    let: "$r0" := (![#uint64T] "next") in
    do:  ((struct.field_ref #ArrayEditor #"next_val"%go (![#ptrT] "ae")) <-[#uint64T] "$r0");;;
    let: "$r0" := (let: "$s" := (![#sliceT] (struct.field_ref #ArrayEditor #"s"%go (![#ptrT] "ae"))) in
    slice.slice #uint64T "$s" #(W64 1) (slice.len "$s")) in
    do:  ((struct.field_ref #ArrayEditor #"s"%go (![#ptrT] "ae")) <-[#sliceT] "$r0");;;
    return: #()).

Definition testSliceOps : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testSliceOps"%go.

(* tests

   go: slices.go:17:6 *)
Definition testSliceOpsⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make2 #uint64T #(W64 10)) in
    do:  ("x" <-[#sliceT] "$r0");;;
    let: "$r0" := #(W64 5) in
    do:  ((slice.elem_ref #uint64T (![#sliceT] "x") #(W64 1)) <-[#uint64T] "$r0");;;
    let: "$r0" := #(W64 10) in
    do:  ((slice.elem_ref #uint64T (![#sliceT] "x") #(W64 2)) <-[#uint64T] "$r0");;;
    let: "$r0" := #(W64 15) in
    do:  ((slice.elem_ref #uint64T (![#sliceT] "x") #(W64 3)) <-[#uint64T] "$r0");;;
    let: "$r0" := #(W64 20) in
    do:  ((slice.elem_ref #uint64T (![#sliceT] "x") #(W64 4)) <-[#uint64T] "$r0");;;
    let: "v1" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (![#uint64T] (slice.elem_ref #uint64T (![#sliceT] "x") #(W64 2))) in
    do:  ("v1" <-[#uint64T] "$r0");;;
    let: "v2" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$s" := (![#sliceT] "x") in
    slice.slice #uint64T "$s" #(W64 2) #(W64 3)) in
    do:  ("v2" <-[#sliceT] "$r0");;;
    let: "v3" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$s" := (![#sliceT] "x") in
    slice.slice #uint64T "$s" #(W64 0) #(W64 3)) in
    do:  ("v3" <-[#sliceT] "$r0");;;
    let: "v4" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (slice.elem_ref #uint64T (![#sliceT] "x") #(W64 2)) in
    do:  ("v4" <-[#ptrT] "$r0");;;
    let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "$r0" := #true in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((![#uint64T] "v1") = #(W64 10))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((![#uint64T] (slice.elem_ref #uint64T (![#sliceT] "v2") #(W64 0))) = #(W64 10))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((let: "$a0" := (![#sliceT] "v2") in
    slice.len "$a0") = #(W64 1))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((![#uint64T] (slice.elem_ref #uint64T (![#sliceT] "v3") #(W64 1))) = #(W64 5))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((![#uint64T] (slice.elem_ref #uint64T (![#sliceT] "v3") #(W64 2))) = #(W64 10))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((let: "$a0" := (![#sliceT] "v3") in
    slice.len "$a0") = #(W64 3))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((![#uint64T] (![#ptrT] "v4")) = #(W64 10))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    return: (![#boolT] "ok")).

Definition testSliceCapacityOps : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testSliceCapacityOps"%go.

(* go: slices.go:40:6 *)
Definition testSliceCapacityOpsⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make3 #uint64T #(W64 0) #(W64 10)) in
    do:  ("x" <-[#sliceT] "$r0");;;
    let: "sub1" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$s" := (![#sliceT] "x") in
    slice.slice #uint64T "$s" #(W64 0) #(W64 6)) in
    do:  ("sub1" <-[#sliceT] "$r0");;;
    let: "$r0" := #(W64 1) in
    do:  ((slice.elem_ref #uint64T (![#sliceT] "sub1") #(W64 0)) <-[#uint64T] "$r0");;;
    let: "sub2" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$s" := (![#sliceT] "x") in
    slice.slice #uint64T "$s" #(W64 2) #(W64 4)) in
    do:  ("sub2" <-[#sliceT] "$r0");;;
    let: "$r0" := #(W64 2) in
    do:  ((slice.elem_ref #uint64T (![#sliceT] "sub2") #(W64 0)) <-[#uint64T] "$r0");;;
    let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "$r0" := #true in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((let: "$a0" := (![#sliceT] "sub1") in
    slice.len "$a0") = #(W64 6))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((let: "$a0" := (![#sliceT] "sub1") in
    slice.cap "$a0") = #(W64 10))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((![#uint64T] (slice.elem_ref #uint64T (let: "$s" := (![#sliceT] "x") in
    slice.slice #uint64T "$s" #(W64 0) #(W64 10)) #(W64 0))) = #(W64 1))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((let: "$a0" := (![#sliceT] "sub2") in
    slice.len "$a0") = #(W64 2))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((let: "$a0" := (![#sliceT] "sub2") in
    slice.cap "$a0") = #(W64 8))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((![#uint64T] (slice.elem_ref #uint64T (let: "$s" := (![#sliceT] "x") in
    slice.slice #uint64T "$s" #(W64 0) #(W64 10)) #(W64 2))) = #(W64 2))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    return: (![#boolT] "ok")).

Definition testOverwriteArray : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testOverwriteArray"%go.

(* go: slices.go:59:6 *)
Definition testOverwriteArrayⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "arr" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make2 #uint64T #(W64 4)) in
    do:  ("arr" <-[#sliceT] "$r0");;;
    let: "ae1" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (let: "$s" := (let: "$s" := (![#sliceT] "arr") in
    slice.slice #uint64T "$s" #(W64 0) (slice.len "$s")) in
    let: "$next_val" := #(W64 1) in
    struct.make #ArrayEditor [{
      "s" ::= "$s";
      "next_val" ::= "$next_val"
    }])) in
    do:  ("ae1" <-[#ptrT] "$r0");;;
    let: "ae2" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (let: "$s" := (let: "$s" := (![#sliceT] "arr") in
    slice.slice #uint64T "$s" #(W64 1) (slice.len "$s")) in
    let: "$next_val" := #(W64 102) in
    struct.make #ArrayEditor [{
      "s" ::= "$s";
      "next_val" ::= "$next_val"
    }])) in
    do:  ("ae2" <-[#ptrT] "$r0");;;
    do:  (let: "$a0" := (![#sliceT] "arr") in
    let: "$a1" := #(W64 103) in
    (method_call #semantics.semantics #"ArrayEditor'ptr" #"Advance" (![#ptrT] "ae2")) "$a0" "$a1");;;
    do:  (let: "$a0" := (![#sliceT] "arr") in
    let: "$a1" := #(W64 104) in
    (method_call #semantics.semantics #"ArrayEditor'ptr" #"Advance" (![#ptrT] "ae2")) "$a0" "$a1");;;
    do:  (let: "$a0" := (![#sliceT] "arr") in
    let: "$a1" := #(W64 105) in
    (method_call #semantics.semantics #"ArrayEditor'ptr" #"Advance" (![#ptrT] "ae2")) "$a0" "$a1");;;
    do:  (let: "$a0" := (![#sliceT] "arr") in
    let: "$a1" := #(W64 2) in
    (method_call #semantics.semantics #"ArrayEditor'ptr" #"Advance" (![#ptrT] "ae1")) "$a0" "$a1");;;
    do:  (let: "$a0" := (![#sliceT] "arr") in
    let: "$a1" := #(W64 3) in
    (method_call #semantics.semantics #"ArrayEditor'ptr" #"Advance" (![#ptrT] "ae1")) "$a0" "$a1");;;
    do:  (let: "$a0" := (![#sliceT] "arr") in
    let: "$a1" := #(W64 4) in
    (method_call #semantics.semantics #"ArrayEditor'ptr" #"Advance" (![#ptrT] "ae1")) "$a0" "$a1");;;
    do:  (let: "$a0" := (![#sliceT] "arr") in
    let: "$a1" := #(W64 5) in
    (method_call #semantics.semantics #"ArrayEditor'ptr" #"Advance" (![#ptrT] "ae1")) "$a0" "$a1");;;
    (if: ((((![#uint64T] (slice.elem_ref #uint64T (![#sliceT] "arr") #(W64 0))) + (![#uint64T] (slice.elem_ref #uint64T (![#sliceT] "arr") #(W64 1)))) + (![#uint64T] (slice.elem_ref #uint64T (![#sliceT] "arr") #(W64 2)))) + (![#uint64T] (slice.elem_ref #uint64T (![#sliceT] "arr") #(W64 3)))) ≥ #(W64 100)
    then return: (#false)
    else do:  #());;;
    return: (((![#uint64T] (slice.elem_ref #uint64T (![#sliceT] "arr") #(W64 3))) = #(W64 4)) && ((![#uint64T] (slice.elem_ref #uint64T (![#sliceT] "arr") #(W64 0))) = #(W64 4)))).

Definition testSliceLiteral : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testSliceLiteral"%go.

(* go: slices.go:80:6 *)
Definition testSliceLiteralⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "bytes" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := ((let: "$sl0" := #(W8 1) in
    let: "$sl1" := #(W8 2) in
    slice.literal #byteT ["$sl0"; "$sl1"])) in
    do:  ("bytes" <-[#sliceT] "$r0");;;
    let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "$r0" := #true in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((![#byteT] (slice.elem_ref #byteT (![#sliceT] "bytes") #(W64 0))) = #(W8 1))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "ints" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := ((let: "$sl0" := #(W64 1) in
    let: "$sl1" := #(W64 2) in
    let: "$sl2" := #(W64 3) in
    slice.literal #uint64T ["$sl0"; "$sl1"; "$sl2"])) in
    do:  ("ints" <-[#sliceT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((![#uint64T] (slice.elem_ref #uint64T (![#sliceT] "ints") #(W64 1))) = #(W64 2))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    return: (![#boolT] "ok")).

Definition testSliceAppend : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testSliceAppend"%go.

(* go: slices.go:89:6 *)
Definition testSliceAppendⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "$r0" := #true in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "bytes" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make2 #byteT #(W64 0)) in
    do:  ("bytes" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "bytes") in
    let: "$a1" := ((let: "$sl0" := #(W8 1) in
    slice.literal #byteT ["$sl0"])) in
    (slice.append #byteT) "$a0" "$a1") in
    do:  ("bytes" <-[#sliceT] "$r0");;;
    let: "newBytes" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := ((let: "$sl0" := #(W8 2) in
    let: "$sl1" := #(W8 3) in
    slice.literal #byteT ["$sl0"; "$sl1"])) in
    do:  ("newBytes" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "bytes") in
    let: "$a1" := (![#sliceT] "newBytes") in
    (slice.append #byteT) "$a0" "$a1") in
    do:  ("bytes" <-[#sliceT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((s_to_w64 (let: "$a0" := (![#sliceT] "bytes") in
    slice.len "$a0")) = #(W64 3))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((![#byteT] (slice.elem_ref #byteT (![#sliceT] "bytes") #(W64 2))) = #(W8 3))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    return: (![#boolT] "ok")).

Definition Bar : go_type := structT [
  "a" :: uint64T;
  "b" :: uint64T
].

Definition Barⁱᵈ : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.Bar"%go.

Definition Foo : go_type := structT [
  "bar" :: Bar
].

Definition Fooⁱᵈ : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.Foo"%go.

(* go: struct_pointers.go:14:17 *)
Definition Bar__mutateⁱᵐᵖˡ : val :=
  λ: "bar" <>,
    exception_do (let: "bar" := (mem.alloc "bar") in
    let: "$r0" := #(W64 2) in
    do:  ((struct.field_ref #Bar #"a"%go (![#ptrT] "bar")) <-[#uint64T] "$r0");;;
    let: "$r0" := #(W64 3) in
    do:  ((struct.field_ref #Bar #"b"%go (![#ptrT] "bar")) <-[#uint64T] "$r0");;;
    return: #()).

(* go: struct_pointers.go:19:17 *)
Definition Foo__mutateBarⁱᵐᵖˡ : val :=
  λ: "foo" <>,
    exception_do (let: "foo" := (mem.alloc "foo") in
    do:  ((method_call #semantics.semantics #"Bar'ptr" #"mutate" (struct.field_ref #Foo #"bar"%go (![#ptrT] "foo"))) #());;;
    return: #()).

Definition testFooBarMutation : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testFooBarMutation"%go.

(* go: struct_pointers.go:23:6 *)
Definition testFooBarMutationⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (mem.alloc (type.zero_val #Foo)) in
    let: "$r0" := (let: "$bar" := (let: "$a" := #(W64 0) in
    let: "$b" := #(W64 0) in
    struct.make #Bar [{
      "a" ::= "$a";
      "b" ::= "$b"
    }]) in
    struct.make #Foo [{
      "bar" ::= "$bar"
    }]) in
    do:  ("x" <-[#Foo] "$r0");;;
    do:  ((method_call #semantics.semantics #"Foo'ptr" #"mutateBar" "x") #());;;
    return: ((![#uint64T] (struct.field_ref #Bar #"a"%go (struct.field_ref #Foo #"bar"%go "x"))) = #(W64 2))).

Definition TwoInts : go_type := structT [
  "x" :: uint64T;
  "y" :: uint64T
].

Definition TwoIntsⁱᵈ : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.TwoInts"%go.

Definition S : go_type := structT [
  "a" :: uint64T;
  "b" :: TwoInts;
  "c" :: boolT
].

Definition Sⁱᵈ : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.S"%go.

Definition NewS : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.NewS"%go.

(* go: structs.go:14:6 *)
Definition NewSⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (mem.alloc (let: "$a" := #(W64 2) in
     let: "$b" := (let: "$x" := #(W64 1) in
     let: "$y" := #(W64 2) in
     struct.make #TwoInts [{
       "x" ::= "$x";
       "y" ::= "$y"
     }]) in
     let: "$c" := #true in
     struct.make #S [{
       "a" ::= "$a";
       "b" ::= "$b";
       "c" ::= "$c"
     }]))).

(* go: structs.go:22:13 *)
Definition S__readAⁱᵐᵖˡ : val :=
  λ: "s" <>,
    exception_do (let: "s" := (mem.alloc "s") in
    return: (![#uint64T] (struct.field_ref #S #"a"%go (![#ptrT] "s")))).

(* go: structs.go:26:13 *)
Definition S__readBⁱᵐᵖˡ : val :=
  λ: "s" <>,
    exception_do (let: "s" := (mem.alloc "s") in
    return: (![#TwoInts] (struct.field_ref #S #"b"%go (![#ptrT] "s")))).

(* go: structs.go:30:12 *)
Definition S__readBValⁱᵐᵖˡ : val :=
  λ: "s" <>,
    exception_do (let: "s" := (mem.alloc "s") in
    return: (![#TwoInts] (struct.field_ref #S #"b"%go "s"))).

(* go: structs.go:34:13 *)
Definition S__updateBValXⁱᵐᵖˡ : val :=
  λ: "s" "i",
    exception_do (let: "s" := (mem.alloc "s") in
    let: "i" := (mem.alloc "i") in
    let: "$r0" := (![#uint64T] "i") in
    do:  ((struct.field_ref #TwoInts #"x"%go (struct.field_ref #S #"b"%go (![#ptrT] "s"))) <-[#uint64T] "$r0");;;
    return: #()).

(* go: structs.go:38:13 *)
Definition S__negateCⁱᵐᵖˡ : val :=
  λ: "s" <>,
    exception_do (let: "s" := (mem.alloc "s") in
    let: "$r0" := (~ (![#boolT] (struct.field_ref #S #"c"%go (![#ptrT] "s")))) in
    do:  ((struct.field_ref #S #"c"%go (![#ptrT] "s")) <-[#boolT] "$r0");;;
    return: #()).

Definition testStructUpdates : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testStructUpdates"%go.

(* go: structs.go:42:6 *)
Definition testStructUpdatesⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "$r0" := #true in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "ns" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := ((func_call #NewS) #()) in
    do:  ("ns" <-[#ptrT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && (((method_call #semantics.semantics #"S'ptr" #"readA" (![#ptrT] "ns")) #()) = #(W64 2))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "b1" := (mem.alloc (type.zero_val #TwoInts)) in
    let: "$r0" := ((method_call #semantics.semantics #"S'ptr" #"readB" (![#ptrT] "ns")) #()) in
    do:  ("b1" <-[#TwoInts] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((![#uint64T] (struct.field_ref #TwoInts #"x"%go "b1")) = #(W64 1))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    do:  ((method_call #semantics.semantics #"S'ptr" #"negateC" (![#ptrT] "ns")) #());;;
    let: "$r0" := ((![#boolT] "ok") && ((![#boolT] (struct.field_ref #S #"c"%go (![#ptrT] "ns"))) = #false)) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := #(W64 3) in
    do:  ((struct.field_ref #TwoInts #"x"%go "b1") <-[#uint64T] "$r0");;;
    let: "b2" := (mem.alloc (type.zero_val #TwoInts)) in
    let: "$r0" := ((method_call #semantics.semantics #"S'ptr" #"readB" (![#ptrT] "ns")) #()) in
    do:  ("b2" <-[#TwoInts] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((![#uint64T] (struct.field_ref #TwoInts #"x"%go "b2")) = #(W64 1))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "b3" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (struct.field_ref #S #"b"%go (![#ptrT] "ns")) in
    do:  ("b3" <-[#ptrT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((![#uint64T] (struct.field_ref #TwoInts #"x"%go (![#ptrT] "b3"))) = #(W64 1))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    do:  (let: "$a0" := #(W64 4) in
    (method_call #semantics.semantics #"S'ptr" #"updateBValX" (![#ptrT] "ns")) "$a0");;;
    let: "$r0" := ((![#boolT] "ok") && ((struct.field_get #TwoInts "x" ((method_call #semantics.semantics #"S'ptr" #"readBVal" (![#ptrT] "ns")) #())) = #(W64 4))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    return: (![#boolT] "ok")).

Definition testNestedStructUpdates : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testNestedStructUpdates"%go.

(* go: structs.go:65:6 *)
Definition testNestedStructUpdatesⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "$r0" := #true in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "ns" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := ((func_call #NewS) #()) in
    do:  ("ns" <-[#ptrT] "$r0");;;
    let: "$r0" := #(W64 5) in
    do:  ((struct.field_ref #TwoInts #"x"%go (struct.field_ref #S #"b"%go (![#ptrT] "ns"))) <-[#uint64T] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((![#uint64T] (struct.field_ref #TwoInts #"x"%go (struct.field_ref #S #"b"%go (![#ptrT] "ns")))) = #(W64 5))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((func_call #NewS) #()) in
    do:  ("ns" <-[#ptrT] "$r0");;;
    let: "p" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (struct.field_ref #S #"b"%go (![#ptrT] "ns")) in
    do:  ("p" <-[#ptrT] "$r0");;;
    let: "$r0" := #(W64 5) in
    do:  ((struct.field_ref #TwoInts #"x"%go (![#ptrT] "p")) <-[#uint64T] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((![#uint64T] (struct.field_ref #TwoInts #"x"%go (struct.field_ref #S #"b"%go (![#ptrT] "ns")))) = #(W64 5))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((func_call #NewS) #()) in
    do:  ("ns" <-[#ptrT] "$r0");;;
    let: "$r0" := (struct.field_ref #S #"b"%go (![#ptrT] "ns")) in
    do:  ("p" <-[#ptrT] "$r0");;;
    let: "$r0" := #(W64 5) in
    do:  ((struct.field_ref #TwoInts #"x"%go (struct.field_ref #S #"b"%go (![#ptrT] "ns"))) <-[#uint64T] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((![#uint64T] (struct.field_ref #TwoInts #"x"%go (![#ptrT] "p"))) = #(W64 5))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((func_call #NewS) #()) in
    do:  ("ns" <-[#ptrT] "$r0");;;
    let: "$r0" := (struct.field_ref #S #"b"%go (![#ptrT] "ns")) in
    do:  ("p" <-[#ptrT] "$r0");;;
    let: "$r0" := #(W64 5) in
    do:  ((struct.field_ref #TwoInts #"x"%go (struct.field_ref #S #"b"%go (![#ptrT] "ns"))) <-[#uint64T] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((![#uint64T] (struct.field_ref #TwoInts #"x"%go (![#ptrT] "p"))) = #(W64 5))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    return: (![#boolT] "ok")).

Definition testStructConstructions : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testStructConstructions"%go.

(* go: structs.go:90:6 *)
Definition testStructConstructionsⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "$r0" := #true in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "p1" := (mem.alloc (type.zero_val #ptrT)) in
    let: "p2" := (mem.alloc (type.zero_val #TwoInts)) in
    let: "p3" := (mem.alloc (type.zero_val #TwoInts)) in
    let: "$r0" := (let: "$y" := #(W64 0) in
    let: "$x" := #(W64 0) in
    struct.make #TwoInts [{
      "x" ::= "$x";
      "y" ::= "$y"
    }]) in
    do:  ("p3" <-[#TwoInts] "$r0");;;
    let: "p4" := (mem.alloc (type.zero_val #TwoInts)) in
    let: "$r0" := (let: "$x" := #(W64 0) in
    let: "$y" := #(W64 0) in
    struct.make #TwoInts [{
      "x" ::= "$x";
      "y" ::= "$y"
    }]) in
    do:  ("p4" <-[#TwoInts] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((![#ptrT] "p1") = #null)) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := (mem.alloc (type.zero_val #TwoInts)) in
    do:  ("p1" <-[#ptrT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((![#TwoInts] "p2") = (![#TwoInts] "p3"))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((![#TwoInts] "p3") = (![#TwoInts] "p4"))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((![#TwoInts] "p4") = (![#TwoInts] (![#ptrT] "p1")))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ("p4" ≠ (![#ptrT] "p1"))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    return: (![#boolT] "ok")).

Definition testIncompleteStruct : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testIncompleteStruct"%go.

(* go: structs.go:109:6 *)
Definition testIncompleteStructⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "$r0" := #true in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "p1" := (mem.alloc (type.zero_val #TwoInts)) in
    let: "$r0" := (let: "$x" := #(W64 0) in
    struct.make #TwoInts [{
      "x" ::= "$x";
      "y" ::= type.zero_val #uint64T
    }]) in
    do:  ("p1" <-[#TwoInts] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((![#uint64T] (struct.field_ref #TwoInts #"y"%go "p1")) = #(W64 0))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "p2" := (mem.alloc (type.zero_val #S)) in
    let: "$r0" := (let: "$a" := #(W64 2) in
    struct.make #S [{
      "a" ::= "$a";
      "b" ::= type.zero_val #TwoInts;
      "c" ::= type.zero_val #boolT
    }]) in
    do:  ("p2" <-[#S] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((![#uint64T] (struct.field_ref #TwoInts #"x"%go (struct.field_ref #S #"b"%go "p2"))) = #(W64 0))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((![#boolT] (struct.field_ref #S #"c"%go "p2")) = #false)) in
    do:  ("ok" <-[#boolT] "$r0");;;
    return: (![#boolT] "ok")).

Definition StructWrap : go_type := structT [
  "i" :: uint64T
].

Definition StructWrapⁱᵈ : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.StructWrap"%go.

Definition testStoreInStructVar : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testStoreInStructVar"%go.

(* go: structs.go:126:6 *)
Definition testStoreInStructVarⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "p" := (mem.alloc (type.zero_val #StructWrap)) in
    let: "$r0" := (let: "$i" := #(W64 0) in
    struct.make #StructWrap [{
      "i" ::= "$i"
    }]) in
    do:  ("p" <-[#StructWrap] "$r0");;;
    let: "$r0" := #(W64 5) in
    do:  ((struct.field_ref #StructWrap #"i"%go "p") <-[#uint64T] "$r0");;;
    return: ((![#uint64T] (struct.field_ref #StructWrap #"i"%go "p")) = #(W64 5))).

Definition testStoreInStructPointerVar : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testStoreInStructPointerVar"%go.

(* go: structs.go:132:6 *)
Definition testStoreInStructPointerVarⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "p" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #StructWrap)) in
    do:  ("p" <-[#ptrT] "$r0");;;
    let: "$r0" := #(W64 5) in
    do:  ((struct.field_ref #StructWrap #"i"%go (![#ptrT] "p")) <-[#uint64T] "$r0");;;
    return: ((![#uint64T] (struct.field_ref #StructWrap #"i"%go (![#ptrT] "p"))) = #(W64 5))).

Definition testStoreComposite : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testStoreComposite"%go.

(* go: structs.go:138:6 *)
Definition testStoreCompositeⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "p" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #TwoInts)) in
    do:  ("p" <-[#ptrT] "$r0");;;
    let: "$r0" := (let: "$x" := #(W64 3) in
    let: "$y" := #(W64 4) in
    struct.make #TwoInts [{
      "x" ::= "$x";
      "y" ::= "$y"
    }]) in
    do:  ((![#ptrT] "p") <-[#TwoInts] "$r0");;;
    return: ((![#uint64T] (struct.field_ref #TwoInts #"y"%go (![#ptrT] "p"))) = #(W64 4))).

Definition testStoreSlice : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testStoreSlice"%go.

(* go: structs.go:144:6 *)
Definition testStoreSliceⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "p" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #sliceT)) in
    do:  ("p" <-[#ptrT] "$r0");;;
    let: "s" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make2 #uint64T #(W64 3)) in
    do:  ("s" <-[#sliceT] "$r0");;;
    let: "$r0" := (![#sliceT] "s") in
    do:  ((![#ptrT] "p") <-[#sliceT] "$r0");;;
    return: ((s_to_w64 (let: "$a0" := (![#sliceT] (![#ptrT] "p")) in
     slice.len "$a0")) = #(W64 3))).

Definition StructWithFunc : go_type := structT [
  "fn" :: funcT
].

Definition StructWithFuncⁱᵈ : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.StructWithFunc"%go.

Definition testStructFieldFunc : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testStructFieldFunc"%go.

(* go: structs.go:155:6 *)
Definition testStructFieldFuncⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "a" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #StructWithFunc)) in
    do:  ("a" <-[#ptrT] "$r0");;;
    let: "$r0" := (λ: "arg",
      exception_do (let: "arg" := (mem.alloc "arg") in
      return: ((![#uint64T] "arg") * #(W64 2)))
      ) in
    do:  ((struct.field_ref #StructWithFunc #"fn"%go (![#ptrT] "a")) <-[#funcT] "$r0");;;
    return: ((let: "$a0" := #(W64 10) in
     (![#funcT] (struct.field_ref #StructWithFunc #"fn"%go (![#ptrT] "a"))) "$a0") = #(W64 20))).

Definition testSwitchVal : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testSwitchVal"%go.

(* go: switch.go:3:6 *)
Definition testSwitchValⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("x" <-[#uint64T] "$r0");;;
    let: "$sw" := (![#uint64T] "x") in
    (if: "$sw" = #(W64 0)
    then return: (#true)
    else
      (if: "$sw" = #(W64 1)
      then return: (#false)
      else return: (#false)))).

Definition testSwitchMultiple : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testSwitchMultiple"%go.

(* go: switch.go:15:6 *)
Definition testSwitchMultipleⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("x" <-[#uint64T] "$r0");;;
    let: "$sw" := (![#uint64T] "x") in
    (if: ("$sw" = #(W64 1)) || ("$sw" = #(W64 10))
    then return: (#false)
    else
      (if: "$sw" = #(W64 0)
      then return: (#true)
      else do:  #()));;;
    return: (#false)).

Definition testSwitchDefaultTrue : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testSwitchDefaultTrue"%go.

(* go: switch.go:26:6 *)
Definition testSwitchDefaultTrueⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 1) in
    do:  ("x" <-[#uint64T] "$r0");;;
    let: "$sw" := #true in
    (if: "$sw" = #false
    then return: (#false)
    else
      (if: "$sw" = ((![#uint64T] "x") = #(W64 2))
      then return: (#false)
      else return: (#true)))).

Definition switchConcrete : go_type := structT [
].

Definition switchConcreteⁱᵈ : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.switchConcrete"%go.

Definition switchInterface : go_type := interfaceT.

Definition switchInterfaceⁱᵈ : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.switchInterface"%go.

(* go: switch.go:45:26 *)
Definition switchConcrete__markerⁱᵐᵖˡ : val :=
  λ: "c" <>,
    exception_do (let: "c" := (mem.alloc "c") in
    do:  #()).

Definition testSwitchConversion : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testSwitchConversion"%go.

(* go: switch.go:48:6 *)
Definition testSwitchConversionⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "v" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (struct.make #switchConcrete [{
    }])) in
    do:  ("v" <-[#ptrT] "$r0");;;
    let: "x" := (mem.alloc (type.zero_val #switchInterface)) in
    let: "$r0" := (interface.make #(ptrTⁱᵈ switchConcreteⁱᵈ) (![#ptrT] "v")) in
    do:  ("x" <-[#switchInterface] "$r0");;;
    let: "$sw" := (![#switchInterface] "x") in
    (if: "$sw" = (interface.make #(ptrTⁱᵈ switchConcreteⁱᵈ) (![#ptrT] "v"))
    then do:  #()
    else return: (#false));;;
    let: "$sw" := (![#ptrT] "v") in
    (if: (interface.make #(ptrTⁱᵈ switchConcreteⁱᵈ) "$sw") = (![#switchInterface] "x")
    then do:  #()
    else return: (#false));;;
    return: (#true)).

Definition testPointerAssignment : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testPointerAssignment"%go.

(* go: vars.go:3:6 *)
Definition testPointerAssignmentⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (mem.alloc (type.zero_val #boolT)) in
    let: "$r0" := #true in
    do:  ("x" <-[#boolT] "$r0");;;
    return: (![#boolT] "x")).

Definition testAddressOfLocal : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testAddressOfLocal"%go.

(* go: vars.go:9:6 *)
Definition testAddressOfLocalⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (mem.alloc (type.zero_val #boolT)) in
    let: "$r0" := #false in
    do:  ("x" <-[#boolT] "$r0");;;
    let: "xptr" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := "x" in
    do:  ("xptr" <-[#ptrT] "$r0");;;
    let: "$r0" := #true in
    do:  ((![#ptrT] "xptr") <-[#boolT] "$r0");;;
    return: ((![#boolT] "x") && (![#boolT] (![#ptrT] "xptr")))).

Definition testAnonymousAssign : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testAnonymousAssign"%go.

(* go: vars.go:16:6 *)
Definition testAnonymousAssignⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "$r0" := (#(W64 1) + #(W64 2)) in
    do:  "$r0";;;
    return: (#true)).

(* 10 is completely arbitrary *)
Definition MaxTxnWrites : expr := #(W64 10).

Definition logLength : expr := #(W64 21).

Definition Log : go_type := structT [
  "d" :: disk.Disk;
  "l" :: ptrT;
  "cache" :: mapT uint64T sliceT;
  "length" :: ptrT
].

Definition Logⁱᵈ : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.Log"%go.

Definition intToBlock : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.intToBlock"%go.

(* go: wal.go:25:6 *)
Definition intToBlockⁱᵐᵖˡ : val :=
  λ: "a",
    exception_do (let: "a" := (mem.alloc "a") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make2 #byteT disk.BlockSize) in
    do:  ("b" <-[#sliceT] "$r0");;;
    do:  (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#uint64T] "a") in
    (func_call #primitive.UInt64Put) "$a0" "$a1");;;
    return: (![#sliceT] "b")).

Definition blockToInt : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.blockToInt"%go.

(* go: wal.go:31:6 *)
Definition blockToIntⁱᵐᵖˡ : val :=
  λ: "v",
    exception_do (let: "v" := (mem.alloc "v") in
    let: "a" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "v") in
    (func_call #primitive.UInt64Get) "$a0") in
    do:  ("a" <-[#uint64T] "$r0");;;
    return: (![#uint64T] "a")).

Definition New : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.New"%go.

(* New initializes a fresh log

   go: wal.go:37:6 *)
Definition Newⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "d" := (mem.alloc (type.zero_val #disk.Disk)) in
    let: "$r0" := ((func_call #disk.Get) #()) in
    do:  ("d" <-[#disk.Disk] "$r0");;;
    let: "diskSize" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := ((interface.get #"Size"%go (![#disk.Disk] "d")) #()) in
    do:  ("diskSize" <-[#uint64T] "$r0");;;
    (if: (![#uint64T] "diskSize") ≤ logLength
    then
      do:  (let: "$a0" := (interface.make #stringTⁱᵈ #"disk is too small to host log"%go) in
      Panic "$a0")
    else do:  #());;;
    let: "cache" := (mem.alloc (type.zero_val (type.mapT #uint64T #sliceT))) in
    let: "$r0" := (map.make #uint64T #sliceT) in
    do:  ("cache" <-[type.mapT #uint64T #sliceT] "$r0");;;
    let: "header" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := #(W64 0) in
    (func_call #intToBlock) "$a0") in
    do:  ("header" <-[#sliceT] "$r0");;;
    do:  (let: "$a0" := #(W64 0) in
    let: "$a1" := (![#sliceT] "header") in
    (interface.get #"Write"%go (![#disk.Disk] "d")) "$a0" "$a1");;;
    let: "lengthPtr" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #uint64T)) in
    do:  ("lengthPtr" <-[#ptrT] "$r0");;;
    let: "$r0" := #(W64 0) in
    do:  ((![#ptrT] "lengthPtr") <-[#uint64T] "$r0");;;
    let: "l" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #sync.Mutex)) in
    do:  ("l" <-[#ptrT] "$r0");;;
    return: (let: "$d" := (![#disk.Disk] "d") in
     let: "$cache" := (![type.mapT #uint64T #sliceT] "cache") in
     let: "$length" := (![#ptrT] "lengthPtr") in
     let: "$l" := (![#ptrT] "l") in
     struct.make #Log [{
       "d" ::= "$d";
       "l" ::= "$l";
       "cache" ::= "$cache";
       "length" ::= "$length"
     }])).

(* go: wal.go:52:14 *)
Definition Log__lockⁱᵐᵖˡ : val :=
  λ: "l" <>,
    exception_do (let: "l" := (mem.alloc "l") in
    do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref #Log #"l"%go "l"))) #());;;
    return: #()).

(* go: wal.go:56:14 *)
Definition Log__unlockⁱᵐᵖˡ : val :=
  λ: "l" <>,
    exception_do (let: "l" := (mem.alloc "l") in
    do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Log #"l"%go "l"))) #());;;
    return: #()).

(* BeginTxn allocates space for a new transaction in the log.

   Returns true if the allocation succeeded.

   go: wal.go:63:14 *)
Definition Log__BeginTxnⁱᵐᵖˡ : val :=
  λ: "l" <>,
    exception_do (let: "l" := (mem.alloc "l") in
    do:  ((method_call #semantics.semantics #"Log" #"lock" (![#Log] "l")) #());;;
    let: "length" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (![#uint64T] (![#ptrT] (struct.field_ref #Log #"length"%go "l"))) in
    do:  ("length" <-[#uint64T] "$r0");;;
    (if: (![#uint64T] "length") = #(W64 0)
    then
      do:  ((method_call #semantics.semantics #"Log" #"unlock" (![#Log] "l")) #());;;
      return: (#true)
    else do:  #());;;
    do:  ((method_call #semantics.semantics #"Log" #"unlock" (![#Log] "l")) #());;;
    return: (#false)).

(* Read from the logical disk.

   Reads must go through the log to return committed but un-applied writes.

   go: wal.go:77:14 *)
Definition Log__Readⁱᵐᵖˡ : val :=
  λ: "l" "a",
    exception_do (let: "l" := (mem.alloc "l") in
    let: "a" := (mem.alloc "a") in
    do:  ((method_call #semantics.semantics #"Log" #"lock" (![#Log] "l")) #());;;
    let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "v" := (mem.alloc (type.zero_val #sliceT)) in
    let: ("$ret0", "$ret1") := (map.get (![type.mapT #uint64T #sliceT] (struct.field_ref #Log #"cache"%go "l")) (![#uint64T] "a")) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("v" <-[#sliceT] "$r0");;;
    do:  ("ok" <-[#boolT] "$r1");;;
    (if: ![#boolT] "ok"
    then
      do:  ((method_call #semantics.semantics #"Log" #"unlock" (![#Log] "l")) #());;;
      return: (![#sliceT] "v")
    else do:  #());;;
    do:  ((method_call #semantics.semantics #"Log" #"unlock" (![#Log] "l")) #());;;
    let: "dv" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (logLength + (![#uint64T] "a")) in
    (interface.get #"Read"%go (![#disk.Disk] (struct.field_ref #Log #"d"%go "l"))) "$a0") in
    do:  ("dv" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "dv")).

(* go: wal.go:90:14 *)
Definition Log__Sizeⁱᵐᵖˡ : val :=
  λ: "l" <>,
    exception_do (let: "l" := (mem.alloc "l") in
    let: "sz" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := ((interface.get #"Size"%go (![#disk.Disk] (struct.field_ref #Log #"d"%go "l"))) #()) in
    do:  ("sz" <-[#uint64T] "$r0");;;
    return: ((![#uint64T] "sz") - logLength)).

(* Write to the disk through the log.

   go: wal.go:97:14 *)
Definition Log__Writeⁱᵐᵖˡ : val :=
  λ: "l" "a" "v",
    exception_do (let: "l" := (mem.alloc "l") in
    let: "v" := (mem.alloc "v") in
    let: "a" := (mem.alloc "a") in
    do:  ((method_call #semantics.semantics #"Log" #"lock" (![#Log] "l")) #());;;
    let: "length" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (![#uint64T] (![#ptrT] (struct.field_ref #Log #"length"%go "l"))) in
    do:  ("length" <-[#uint64T] "$r0");;;
    (if: (![#uint64T] "length") ≥ MaxTxnWrites
    then
      do:  (let: "$a0" := (interface.make #stringTⁱᵈ #"transaction is at capacity"%go) in
      Panic "$a0")
    else do:  #());;;
    let: "aBlock" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#uint64T] "a") in
    (func_call #intToBlock) "$a0") in
    do:  ("aBlock" <-[#sliceT] "$r0");;;
    let: "nextAddr" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (#(W64 1) + (#(W64 2) * (![#uint64T] "length"))) in
    do:  ("nextAddr" <-[#uint64T] "$r0");;;
    do:  (let: "$a0" := (![#uint64T] "nextAddr") in
    let: "$a1" := (![#sliceT] "aBlock") in
    (interface.get #"Write"%go (![#disk.Disk] (struct.field_ref #Log #"d"%go "l"))) "$a0" "$a1");;;
    do:  (let: "$a0" := ((![#uint64T] "nextAddr") + #(W64 1)) in
    let: "$a1" := (![#sliceT] "v") in
    (interface.get #"Write"%go (![#disk.Disk] (struct.field_ref #Log #"d"%go "l"))) "$a0" "$a1");;;
    let: "$r0" := (![#sliceT] "v") in
    do:  (map.insert (![type.mapT #uint64T #sliceT] (struct.field_ref #Log #"cache"%go "l")) (![#uint64T] "a") "$r0");;;
    let: "$r0" := ((![#uint64T] "length") + #(W64 1)) in
    do:  ((![#ptrT] (struct.field_ref #Log #"length"%go "l")) <-[#uint64T] "$r0");;;
    do:  ((method_call #semantics.semantics #"Log" #"unlock" (![#Log] "l")) #());;;
    return: #()).

(* Commit the current transaction.

   go: wal.go:113:14 *)
Definition Log__Commitⁱᵐᵖˡ : val :=
  λ: "l" <>,
    exception_do (let: "l" := (mem.alloc "l") in
    do:  ((method_call #semantics.semantics #"Log" #"lock" (![#Log] "l")) #());;;
    let: "length" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (![#uint64T] (![#ptrT] (struct.field_ref #Log #"length"%go "l"))) in
    do:  ("length" <-[#uint64T] "$r0");;;
    do:  ((method_call #semantics.semantics #"Log" #"unlock" (![#Log] "l")) #());;;
    let: "header" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#uint64T] "length") in
    (func_call #intToBlock) "$a0") in
    do:  ("header" <-[#sliceT] "$r0");;;
    do:  (let: "$a0" := #(W64 0) in
    let: "$a1" := (![#sliceT] "header") in
    (interface.get #"Write"%go (![#disk.Disk] (struct.field_ref #Log #"d"%go "l"))) "$a0" "$a1");;;
    return: #()).

Definition getLogEntry : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.getLogEntry"%go.

(* go: wal.go:122:6 *)
Definition getLogEntryⁱᵐᵖˡ : val :=
  λ: "d" "logOffset",
    exception_do (let: "logOffset" := (mem.alloc "logOffset") in
    let: "d" := (mem.alloc "d") in
    let: "diskAddr" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (#(W64 1) + (#(W64 2) * (![#uint64T] "logOffset"))) in
    do:  ("diskAddr" <-[#uint64T] "$r0");;;
    let: "aBlock" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#uint64T] "diskAddr") in
    (interface.get #"Read"%go (![#disk.Disk] "d")) "$a0") in
    do:  ("aBlock" <-[#sliceT] "$r0");;;
    let: "a" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "aBlock") in
    (func_call #blockToInt) "$a0") in
    do:  ("a" <-[#uint64T] "$r0");;;
    let: "v" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := ((![#uint64T] "diskAddr") + #(W64 1)) in
    (interface.get #"Read"%go (![#disk.Disk] "d")) "$a0") in
    do:  ("v" <-[#sliceT] "$r0");;;
    return: (![#uint64T] "a", ![#sliceT] "v")).

Definition applyLog : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.applyLog"%go.

(* applyLog assumes we are running sequentially

   go: wal.go:131:6 *)
Definition applyLogⁱᵐᵖˡ : val :=
  λ: "d" "length",
    exception_do (let: "length" := (mem.alloc "length") in
    let: "d" := (mem.alloc "d") in
    (let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (if: (![#uint64T] "i") < (![#uint64T] "length")
      then
        let: "v" := (mem.alloc (type.zero_val #sliceT)) in
        let: "a" := (mem.alloc (type.zero_val #uint64T)) in
        let: ("$ret0", "$ret1") := (let: "$a0" := (![#disk.Disk] "d") in
        let: "$a1" := (![#uint64T] "i") in
        (func_call #getLogEntry) "$a0" "$a1") in
        let: "$r0" := "$ret0" in
        let: "$r1" := "$ret1" in
        do:  ("a" <-[#uint64T] "$r0");;;
        do:  ("v" <-[#sliceT] "$r1");;;
        do:  (let: "$a0" := (logLength + (![#uint64T] "a")) in
        let: "$a1" := (![#sliceT] "v") in
        (interface.get #"Write"%go (![#disk.Disk] "d")) "$a0" "$a1");;;
        let: "$r0" := ((![#uint64T] "i") + #(W64 1)) in
        do:  ("i" <-[#uint64T] "$r0");;;
        continue: #()
      else do:  #());;;
      break: #()));;;
    return: #()).

Definition clearLog : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.clearLog"%go.

(* go: wal.go:142:6 *)
Definition clearLogⁱᵐᵖˡ : val :=
  λ: "d",
    exception_do (let: "d" := (mem.alloc "d") in
    let: "header" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := #(W64 0) in
    (func_call #intToBlock) "$a0") in
    do:  ("header" <-[#sliceT] "$r0");;;
    do:  (let: "$a0" := #(W64 0) in
    let: "$a1" := (![#sliceT] "header") in
    (interface.get #"Write"%go (![#disk.Disk] "d")) "$a0" "$a1");;;
    return: #()).

(* Apply all the committed transactions.

   Frees all the space in the log.

   go: wal.go:150:14 *)
Definition Log__Applyⁱᵐᵖˡ : val :=
  λ: "l" <>,
    exception_do (let: "l" := (mem.alloc "l") in
    do:  ((method_call #semantics.semantics #"Log" #"lock" (![#Log] "l")) #());;;
    let: "length" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (![#uint64T] (![#ptrT] (struct.field_ref #Log #"length"%go "l"))) in
    do:  ("length" <-[#uint64T] "$r0");;;
    do:  (let: "$a0" := (![#disk.Disk] (struct.field_ref #Log #"d"%go "l")) in
    let: "$a1" := (![#uint64T] "length") in
    (func_call #applyLog) "$a0" "$a1");;;
    do:  (let: "$a0" := (![#disk.Disk] (struct.field_ref #Log #"d"%go "l")) in
    (func_call #clearLog) "$a0");;;
    let: "$r0" := #(W64 0) in
    do:  ((![#ptrT] (struct.field_ref #Log #"length"%go "l")) <-[#uint64T] "$r0");;;
    do:  ((method_call #semantics.semantics #"Log" #"unlock" (![#Log] "l")) #());;;
    return: #()).

Definition Open : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.Open"%go.

(* Open recovers the log following a crash or shutdown

   go: wal.go:163:6 *)
Definition Openⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "d" := (mem.alloc (type.zero_val #disk.Disk)) in
    let: "$r0" := ((func_call #disk.Get) #()) in
    do:  ("d" <-[#disk.Disk] "$r0");;;
    let: "header" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := #(W64 0) in
    (interface.get #"Read"%go (![#disk.Disk] "d")) "$a0") in
    do:  ("header" <-[#sliceT] "$r0");;;
    let: "length" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "header") in
    (func_call #blockToInt) "$a0") in
    do:  ("length" <-[#uint64T] "$r0");;;
    do:  (let: "$a0" := (![#disk.Disk] "d") in
    let: "$a1" := (![#uint64T] "length") in
    (func_call #applyLog) "$a0" "$a1");;;
    do:  (let: "$a0" := (![#disk.Disk] "d") in
    (func_call #clearLog) "$a0");;;
    let: "cache" := (mem.alloc (type.zero_val (type.mapT #uint64T #sliceT))) in
    let: "$r0" := (map.make #uint64T #sliceT) in
    do:  ("cache" <-[type.mapT #uint64T #sliceT] "$r0");;;
    let: "lengthPtr" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #uint64T)) in
    do:  ("lengthPtr" <-[#ptrT] "$r0");;;
    let: "$r0" := #(W64 0) in
    do:  ((![#ptrT] "lengthPtr") <-[#uint64T] "$r0");;;
    let: "l" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #sync.Mutex)) in
    do:  ("l" <-[#ptrT] "$r0");;;
    return: (let: "$d" := (![#disk.Disk] "d") in
     let: "$cache" := (![type.mapT #uint64T #sliceT] "cache") in
     let: "$length" := (![#ptrT] "lengthPtr") in
     let: "$l" := (![#ptrT] "l") in
     struct.make #Log [{
       "d" ::= "$d";
       "l" ::= "$l";
       "cache" ::= "$cache";
       "length" ::= "$length"
     }])).

Definition disabled_testWal : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.disabled_testWal"%go.

(* disabled since performance is quite poor

   go: wal.go:178:6 *)
Definition disabled_testWalⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "$r0" := #true in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "lg" := (mem.alloc (type.zero_val #Log)) in
    let: "$r0" := ((func_call #New) #()) in
    do:  ("lg" <-[#Log] "$r0");;;
    (if: (method_call #semantics.semantics #"Log" #"BeginTxn" (![#Log] "lg")) #()
    then
      do:  (let: "$a0" := #(W64 2) in
      let: "$a1" := (let: "$a0" := #(W64 11) in
      (func_call #intToBlock) "$a0") in
      (method_call #semantics.semantics #"Log" #"Write" (![#Log] "lg")) "$a0" "$a1")
    else do:  #());;;
    let: "$r0" := ((![#boolT] "ok") && ((let: "$a0" := (let: "$a0" := #(W64 2) in
    (method_call #semantics.semantics #"Log" #"Read" (![#Log] "lg")) "$a0") in
    (func_call #blockToInt) "$a0") = #(W64 11))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "$r0" := ((![#boolT] "ok") && ((let: "$a0" := (let: "$a0" := #(W64 0) in
    (interface.get #"Read"%go (![#disk.Disk] (struct.field_ref #Log #"d"%go "lg"))) "$a0") in
    (func_call #blockToInt) "$a0") = #(W64 0))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    do:  ((method_call #semantics.semantics #"Log" #"Commit" (![#Log] "lg")) #());;;
    let: "$r0" := ((![#boolT] "ok") && ((let: "$a0" := (let: "$a0" := #(W64 0) in
    (interface.get #"Read"%go (![#disk.Disk] (struct.field_ref #Log #"d"%go "lg"))) "$a0") in
    (func_call #blockToInt) "$a0") = #(W64 1))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    do:  ((method_call #semantics.semantics #"Log" #"Apply" (![#Log] "lg")) #());;;
    let: "$r0" := ((![#boolT] "ok") && ((![#uint64T] (![#ptrT] (struct.field_ref #Log #"length"%go "lg"))) = #(W64 0))) in
    do:  ("ok" <-[#boolT] "$r0");;;
    return: (![#boolT] "ok")).

Definition vars' : list (go_string * go_type) := [].

Definition functions' : list (go_string * val) := [(findKey, findKeyⁱᵐᵖˡ); (allocate, allocateⁱᵐᵖˡ); (freeRange, freeRangeⁱᵐᵖˡ); (testAllocateDistinct, testAllocateDistinctⁱᵐᵖˡ); (testAllocateFull, testAllocateFullⁱᵐᵖˡ); (testExplicitBlockStmt, testExplicitBlockStmtⁱᵐᵖˡ); (testMinUint64, testMinUint64ⁱᵐᵖˡ); (testMaxUint64, testMaxUint64ⁱᵐᵖˡ); (adder, adderⁱᵐᵖˡ); (testClosureBasic, testClosureBasicⁱᵐᵖˡ); (testCompareAll, testCompareAllⁱᵐᵖˡ); (testCompareGT, testCompareGTⁱᵐᵖˡ); (testCompareGE, testCompareGEⁱᵐᵖˡ); (testCompareLT, testCompareLTⁱᵐᵖˡ); (testCompareLE, testCompareLEⁱᵐᵖˡ); (literalCast, literalCastⁱᵐᵖˡ); (stringToByteSlice, stringToByteSliceⁱᵐᵖˡ); (byteSliceToString, byteSliceToStringⁱᵐᵖˡ); (testByteSliceToString, testByteSliceToStringⁱᵐᵖˡ); (testCopySimple, testCopySimpleⁱᵐᵖˡ); (testCopyShorterDst, testCopyShorterDstⁱᵐᵖˡ); (testCopyShorterSrc, testCopyShorterSrcⁱᵐᵖˡ); (deferSimple, deferSimpleⁱᵐᵖˡ); (testDefer, testDeferⁱᵐᵖˡ); (testDeferFuncLit, testDeferFuncLitⁱᵐᵖˡ); (roundtripEncDec32, roundtripEncDec32ⁱᵐᵖˡ); (roundtripEncDec64, roundtripEncDec64ⁱᵐᵖˡ); (testEncDec32Simple, testEncDec32Simpleⁱᵐᵖˡ); (failing_testEncDec32, failing_testEncDec32ⁱᵐᵖˡ); (testEncDec64Simple, testEncDec64Simpleⁱᵐᵖˡ); (testEncDec64, testEncDec64ⁱᵐᵖˡ); (FirstClassFunction, FirstClassFunctionⁱᵐᵖˡ); (ApplyF, ApplyFⁱᵐᵖˡ); (testFirstClassFunction, testFirstClassFunctionⁱᵐᵖˡ); (addFour64, addFour64ⁱᵐᵖˡ); (failing_testFunctionOrdering, failing_testFunctionOrderingⁱᵐᵖˡ); (storeAndReturn, storeAndReturnⁱᵐᵖˡ); (failing_testArgumentOrder, failing_testArgumentOrderⁱᵐᵖˡ); (testU64ToU32, testU64ToU32ⁱᵐᵖˡ); (testU32Len, testU32Lenⁱᵐᵖˡ); (failing_testU32NewtypeLen, failing_testU32NewtypeLenⁱᵐᵖˡ); (measureArea, measureAreaⁱᵐᵖˡ); (measureVolumePlusNM, measureVolumePlusNMⁱᵐᵖˡ); (measureVolume, measureVolumeⁱᵐᵖˡ); (testBasicInterface, testBasicInterfaceⁱᵐᵖˡ); (testAssignInterface, testAssignInterfaceⁱᵐᵖˡ); (testMultipleInterface, testMultipleInterfaceⁱᵐᵖˡ); (testBinaryExprInterface, testBinaryExprInterfaceⁱᵐᵖˡ); (testIfStmtInterface, testIfStmtInterfaceⁱᵐᵖˡ); (testsUseLocks, testsUseLocksⁱᵐᵖˡ); (standardForLoop, standardForLoopⁱᵐᵖˡ); (testStandardForLoop, testStandardForLoopⁱᵐᵖˡ); (testForLoopWait, testForLoopWaitⁱᵐᵖˡ); (testBreakFromLoopWithContinue, testBreakFromLoopWithContinueⁱᵐᵖˡ); (testBreakFromLoopNoContinue, testBreakFromLoopNoContinueⁱᵐᵖˡ); (testBreakFromLoopNoContinueDouble, testBreakFromLoopNoContinueDoubleⁱᵐᵖˡ); (testBreakFromLoopForOnly, testBreakFromLoopForOnlyⁱᵐᵖˡ); (testBreakFromLoopAssignAndContinue, testBreakFromLoopAssignAndContinueⁱᵐᵖˡ); (testNestedLoops, testNestedLoopsⁱᵐᵖˡ); (testNestedGoStyleLoops, testNestedGoStyleLoopsⁱᵐᵖˡ); (testNestedGoStyleLoopsNoComparison, testNestedGoStyleLoopsNoComparisonⁱᵐᵖˡ); (IterateMapKeys, IterateMapKeysⁱᵐᵖˡ); (IterateMapValues, IterateMapValuesⁱᵐᵖˡ); (testIterateMap, testIterateMapⁱᵐᵖˡ); (testMapSize, testMapSizeⁱᵐᵖˡ); (multReturnTwo, multReturnTwoⁱᵐᵖˡ); (testAssignTwo, testAssignTwoⁱᵐᵖˡ); (multReturnThree, multReturnThreeⁱᵐᵖˡ); (testAssignThree, testAssignThreeⁱᵐᵖˡ); (testMultipleAssignToMap, testMultipleAssignToMapⁱᵐᵖˡ); (returnTwo, returnTwoⁱᵐᵖˡ); (testReturnTwo, testReturnTwoⁱᵐᵖˡ); (testAnonymousBinding, testAnonymousBindingⁱᵐᵖˡ); (returnThree, returnThreeⁱᵐᵖˡ); (testReturnThree, testReturnThreeⁱᵐᵖˡ); (returnFour, returnFourⁱᵐᵖˡ); (testReturnFour, testReturnFourⁱᵐᵖˡ); (failing_testCompareSliceToNil, failing_testCompareSliceToNilⁱᵐᵖˡ); (testComparePointerToNil, testComparePointerToNilⁱᵐᵖˡ); (testCompareNilToNil, testCompareNilToNilⁱᵐᵖˡ); (testComparePointerWrappedToNil, testComparePointerWrappedToNilⁱᵐᵖˡ); (testComparePointerWrappedDefaultToNil, testComparePointerWrappedDefaultToNilⁱᵐᵖˡ); (reverseAssignOps64, reverseAssignOps64ⁱᵐᵖˡ); (reverseAssignOps32, reverseAssignOps32ⁱᵐᵖˡ); (add64Equals, add64Equalsⁱᵐᵖˡ); (sub64Equals, sub64Equalsⁱᵐᵖˡ); (testReverseAssignOps64, testReverseAssignOps64ⁱᵐᵖˡ); (failing_testReverseAssignOps32, failing_testReverseAssignOps32ⁱᵐᵖˡ); (testAdd64Equals, testAdd64Equalsⁱᵐᵖˡ); (testSub64Equals, testSub64Equalsⁱᵐᵖˡ); (testDivisionPrecedence, testDivisionPrecedenceⁱᵐᵖˡ); (testModPrecedence, testModPrecedenceⁱᵐᵖˡ); (testBitwiseOpsPrecedence, testBitwiseOpsPrecedenceⁱᵐᵖˡ); (testArithmeticShifts, testArithmeticShiftsⁱᵐᵖˡ); (testBitAddAnd, testBitAddAndⁱᵐᵖˡ); (testManyParentheses, testManyParenthesesⁱᵐᵖˡ); (testPlusTimes, testPlusTimesⁱᵐᵖˡ); (testOrCompareSimple, testOrCompareSimpleⁱᵐᵖˡ); (testOrCompare, testOrCompareⁱᵐᵖˡ); (testAndCompare, testAndCompareⁱᵐᵖˡ); (testShiftMod, testShiftModⁱᵐᵖˡ); (testLinearize, testLinearizeⁱᵐᵖˡ); (CheckTrue, CheckTrueⁱᵐᵖˡ); (CheckFalse, CheckFalseⁱᵐᵖˡ); (testShortcircuitAndTF, testShortcircuitAndTFⁱᵐᵖˡ); (testShortcircuitAndFT, testShortcircuitAndFTⁱᵐᵖˡ); (testShortcircuitOrTF, testShortcircuitOrTFⁱᵐᵖˡ); (testShortcircuitOrFT, testShortcircuitOrFTⁱᵐᵖˡ); (testSliceOps, testSliceOpsⁱᵐᵖˡ); (testSliceCapacityOps, testSliceCapacityOpsⁱᵐᵖˡ); (testOverwriteArray, testOverwriteArrayⁱᵐᵖˡ); (testSliceLiteral, testSliceLiteralⁱᵐᵖˡ); (testSliceAppend, testSliceAppendⁱᵐᵖˡ); (testFooBarMutation, testFooBarMutationⁱᵐᵖˡ); (NewS, NewSⁱᵐᵖˡ); (testStructUpdates, testStructUpdatesⁱᵐᵖˡ); (testNestedStructUpdates, testNestedStructUpdatesⁱᵐᵖˡ); (testStructConstructions, testStructConstructionsⁱᵐᵖˡ); (testIncompleteStruct, testIncompleteStructⁱᵐᵖˡ); (testStoreInStructVar, testStoreInStructVarⁱᵐᵖˡ); (testStoreInStructPointerVar, testStoreInStructPointerVarⁱᵐᵖˡ); (testStoreComposite, testStoreCompositeⁱᵐᵖˡ); (testStoreSlice, testStoreSliceⁱᵐᵖˡ); (testStructFieldFunc, testStructFieldFuncⁱᵐᵖˡ); (testSwitchVal, testSwitchValⁱᵐᵖˡ); (testSwitchMultiple, testSwitchMultipleⁱᵐᵖˡ); (testSwitchDefaultTrue, testSwitchDefaultTrueⁱᵐᵖˡ); (testSwitchConversion, testSwitchConversionⁱᵐᵖˡ); (testPointerAssignment, testPointerAssignmentⁱᵐᵖˡ); (testAddressOfLocal, testAddressOfLocalⁱᵐᵖˡ); (testAnonymousAssign, testAnonymousAssignⁱᵐᵖˡ); (intToBlock, intToBlockⁱᵐᵖˡ); (blockToInt, blockToIntⁱᵐᵖˡ); (New, Newⁱᵐᵖˡ); (getLogEntry, getLogEntryⁱᵐᵖˡ); (applyLog, applyLogⁱᵐᵖˡ); (clearLog, clearLogⁱᵐᵖˡ); (Open, Openⁱᵐᵖˡ); (disabled_testWal, disabled_testWalⁱᵐᵖˡ)].

Definition msets' : list (go_string * (list (go_string * val))) := [("unit"%go, []); ("unit'ptr"%go, []); ("Enc"%go, []); ("Enc'ptr"%go, [("consume"%go, Enc__consumeⁱᵐᵖˡ)]); ("Dec"%go, []); ("Dec'ptr"%go, [("consume"%go, Dec__consumeⁱᵐᵖˡ)]); ("Editor"%go, []); ("Editor'ptr"%go, [("AdvanceReturn"%go, Editor__AdvanceReturnⁱᵐᵖˡ)]); ("Pair"%go, []); ("Pair'ptr"%go, []); ("Uint32"%go, []); ("Uint32'ptr"%go, []); ("SquareStruct"%go, [("Square"%go, SquareStruct__Squareⁱᵐᵖˡ); ("Volume"%go, SquareStruct__Volumeⁱᵐᵖˡ)]); ("SquareStruct'ptr"%go, [("Square"%go, (λ: "$recvAddr",
                 method_call #semantics.semantics #"SquareStruct" #"Square" (![#SquareStruct] "$recvAddr")
                 )%V); ("Volume"%go, (λ: "$recvAddr",
                 method_call #semantics.semantics #"SquareStruct" #"Volume" (![#SquareStruct] "$recvAddr")
                 )%V)]); ("LoopStruct"%go, [("forLoopWait"%go, LoopStruct__forLoopWaitⁱᵐᵖˡ)]); ("LoopStruct'ptr"%go, [("forLoopWait"%go, (λ: "$recvAddr",
                 method_call #semantics.semantics #"LoopStruct" #"forLoopWait" (![#LoopStruct] "$recvAddr")
                 )%V)]); ("BoolTest"%go, []); ("BoolTest'ptr"%go, []); ("ArrayEditor"%go, []); ("ArrayEditor'ptr"%go, [("Advance"%go, ArrayEditor__Advanceⁱᵐᵖˡ)]); ("Bar"%go, []); ("Bar'ptr"%go, [("mutate"%go, Bar__mutateⁱᵐᵖˡ)]); ("Foo"%go, []); ("Foo'ptr"%go, [("mutateBar"%go, Foo__mutateBarⁱᵐᵖˡ)]); ("TwoInts"%go, []); ("TwoInts'ptr"%go, []); ("S"%go, [("readBVal"%go, S__readBValⁱᵐᵖˡ)]); ("S'ptr"%go, [("negateC"%go, S__negateCⁱᵐᵖˡ); ("readA"%go, S__readAⁱᵐᵖˡ); ("readB"%go, S__readBⁱᵐᵖˡ); ("readBVal"%go, (λ: "$recvAddr",
                 method_call #semantics.semantics #"S" #"readBVal" (![#S] "$recvAddr")
                 )%V); ("updateBValX"%go, S__updateBValXⁱᵐᵖˡ)]); ("StructWrap"%go, []); ("StructWrap'ptr"%go, []); ("StructWithFunc"%go, []); ("StructWithFunc'ptr"%go, []); ("switchConcrete"%go, []); ("switchConcrete'ptr"%go, [("marker"%go, switchConcrete__markerⁱᵐᵖˡ)]); ("Log"%go, [("Apply"%go, Log__Applyⁱᵐᵖˡ); ("BeginTxn"%go, Log__BeginTxnⁱᵐᵖˡ); ("Commit"%go, Log__Commitⁱᵐᵖˡ); ("Read"%go, Log__Readⁱᵐᵖˡ); ("Size"%go, Log__Sizeⁱᵐᵖˡ); ("Write"%go, Log__Writeⁱᵐᵖˡ); ("lock"%go, Log__lockⁱᵐᵖˡ); ("unlock"%go, Log__unlockⁱᵐᵖˡ)]); ("Log'ptr"%go, [("Apply"%go, (λ: "$recvAddr",
                 method_call #semantics.semantics #"Log" #"Apply" (![#Log] "$recvAddr")
                 )%V); ("BeginTxn"%go, (λ: "$recvAddr",
                 method_call #semantics.semantics #"Log" #"BeginTxn" (![#Log] "$recvAddr")
                 )%V); ("Commit"%go, (λ: "$recvAddr",
                 method_call #semantics.semantics #"Log" #"Commit" (![#Log] "$recvAddr")
                 )%V); ("Read"%go, (λ: "$recvAddr",
                 method_call #semantics.semantics #"Log" #"Read" (![#Log] "$recvAddr")
                 )%V); ("Size"%go, (λ: "$recvAddr",
                 method_call #semantics.semantics #"Log" #"Size" (![#Log] "$recvAddr")
                 )%V); ("Write"%go, (λ: "$recvAddr",
                 method_call #semantics.semantics #"Log" #"Write" (![#Log] "$recvAddr")
                 )%V); ("lock"%go, (λ: "$recvAddr",
                 method_call #semantics.semantics #"Log" #"lock" (![#Log] "$recvAddr")
                 )%V); ("unlock"%go, (λ: "$recvAddr",
                 method_call #semantics.semantics #"Log" #"unlock" (![#Log] "$recvAddr")
                 )%V)])].

#[global] Instance info' : PkgInfo semantics.semantics :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [primitive.primitive; sync.sync; disk.disk];
  |}.

Definition initialize' : val :=
  λ: <>,
    package.init #semantics.semantics (λ: <>,
      exception_do (do:  (disk.initialize' #());;;
      do:  (sync.initialize' #());;;
      do:  (primitive.initialize' #());;;
      do:  (package.alloc semantics.semantics #()))
      ).

End code.
End semantics.
