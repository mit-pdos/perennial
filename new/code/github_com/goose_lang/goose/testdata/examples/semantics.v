(* autogenerated from github.com/goose-lang/goose/testdata/examples/semantics *)
Require Export New.code.sync.
Require Export New.code.github_com.goose_lang.primitive.
Require Export New.code.encoding.binary.
Require Export New.code.github_com.goose_lang.primitive.disk.
From New.golang Require Import defn.
From New Require Import disk_prelude.
Module pkg_id.
Definition semantics : go_string := "github.com/goose-lang/goose/testdata/examples/semantics".

End pkg_id.
Export pkg_id.
Module semantics.

Definition unit {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/semantics.unit"%go [].

Definition Editor {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/semantics.Editor"%go [].

Definition Pair {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/semantics.Pair"%go [].

Definition Uint32 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/semantics.Uint32"%go [].

Definition geometryInterface {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/semantics.geometryInterface"%go [].

Definition SquareStruct {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/semantics.SquareStruct"%go [].

Definition NumStruct {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/semantics.NumStruct"%go [].

Definition shapeInterface {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/semantics.shapeInterface"%go [].

Definition polygonInterface {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/semantics.polygonInterface"%go [].

Definition shapeStruct {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/semantics.shapeStruct"%go [].

Definition polygonStruct {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/semantics.polygonStruct"%go [].

Definition dogInterface {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/semantics.dogInterface"%go [].

Definition catInterface {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/semantics.catInterface"%go [].

Definition Puppy {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/semantics.Puppy"%go [].

Definition Kitten {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/semantics.Kitten"%go [].

Definition printInterface {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/semantics.printInterface"%go [].

Definition PaperStruct {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/semantics.PaperStruct"%go [].

Definition Flower {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/semantics.Flower"%go [].

Definition Flora {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/semantics.Flora"%go [].

Definition Lily {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/semantics.Lily"%go [].

Definition Rose {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/semantics.Rose"%go [].

Definition Daisy {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/semantics.Daisy"%go [].

Definition LoopStruct {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/semantics.LoopStruct"%go [].

Definition BoolTest {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/semantics.BoolTest"%go [].

Definition ArrayEditor {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/semantics.ArrayEditor"%go [].

Definition Bar {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/semantics.Bar"%go [].

Definition Foo {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/semantics.Foo"%go [].

Definition TwoInts {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/semantics.TwoInts"%go [].

Definition S {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/semantics.S"%go [].

Definition StructWrap {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/semantics.StructWrap"%go [].

Definition StructWithFunc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/semantics.StructWithFunc"%go [].

Definition switchConcrete {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/semantics.switchConcrete"%go [].

Definition switchInterface {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/semantics.switchInterface"%go [].

Definition DefinedStr {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/semantics.DefinedStr"%go [].

Definition List {ext : ffi_syntax} {go_gctx : GoGlobalContext} (T : go.type) : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/semantics.List"%go [T].

Definition Log {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/semantics.Log"%go [].

Definition AdderType {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.FunctionType (go.Signature [go.uint64] false [go.uint64]).

Definition MultipleArgsType {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.FunctionType (go.Signature [go.uint64; go.bool] false [go.uint64]).

Definition DefinedStr2 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := DefinedStr.

(* 10 is completely arbitrary *)
Definition MaxTxnWrites {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 10).

Definition logLength {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 21).

Definition findKey {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.findKey"%go.

Definition allocate {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.allocate"%go.

Definition freeRange {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.freeRange"%go.

Definition testAllocateDistinct {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testAllocateDistinct"%go.

Definition testAllocateFull {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testAllocateFull"%go.

Definition testExplicitBlockStmt {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testExplicitBlockStmt"%go.

Definition testMinUint64 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testMinUint64"%go.

Definition testMaxUint64 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testMaxUint64"%go.

Definition adder {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.adder"%go.

Definition testClosureBasic {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testClosureBasic"%go.

Definition testCompareAll {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testCompareAll"%go.

Definition testCompareGT {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testCompareGT"%go.

Definition testCompareGE {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testCompareGE"%go.

Definition testCompareLT {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testCompareLT"%go.

Definition testCompareLE {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testCompareLE"%go.

Definition literalCast {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.literalCast"%go.

Definition stringToByteSlice {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.stringToByteSlice"%go.

Definition byteSliceToString {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.byteSliceToString"%go.

Definition testByteSliceToString {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testByteSliceToString"%go.

Definition testCopySimple {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testCopySimple"%go.

Definition testCopyShorterDst {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testCopyShorterDst"%go.

Definition testCopyShorterSrc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testCopyShorterSrc"%go.

Definition deferSimple {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.deferSimple"%go.

Definition testDefer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testDefer"%go.

Definition testDeferFuncLit {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testDeferFuncLit"%go.

Definition FirstClassFunction {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.FirstClassFunction"%go.

Definition ApplyF {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.ApplyF"%go.

Definition testFirstClassFunction {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testFirstClassFunction"%go.

Definition addFour64 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.addFour64"%go.

Definition failing_testFunctionOrdering {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.failing_testFunctionOrdering"%go.

Definition storeAndReturn {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.storeAndReturn"%go.

Definition failing_testArgumentOrder {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.failing_testArgumentOrder"%go.

Definition testU64ToU32 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testU64ToU32"%go.

Definition testU32ToU64 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testU32ToU64"%go.

Definition testU32Len {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testU32Len"%go.

Definition testU32NewtypeLen {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testU32NewtypeLen"%go.

Definition testUint32Untyped {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testUint32Untyped"%go.

Definition measureArea {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.measureArea"%go.

Definition measureVolumePlusNM {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.measureVolumePlusNM"%go.

Definition measureVolume {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.measureVolume"%go.

Definition testBasicInterface {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testBasicInterface"%go.

Definition testAssignInterface {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testAssignInterface"%go.

Definition testMultipleInterface {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testMultipleInterface"%go.

Definition testBinaryExprInterface {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testBinaryExprInterface"%go.

Definition testIfStmtInterface {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testIfStmtInterface"%go.

Definition testParamsInterface {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testParamsInterface"%go.

Definition testEmptyInterface {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testEmptyInterface"%go.

Definition testStringInterface {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testStringInterface"%go.

Definition testTypeAssertionInterface {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testTypeAssertionInterface"%go.

Definition testDoublePointerInterface {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testDoublePointerInterface"%go.

Definition testMultipleFieldsInterface {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testMultipleFieldsInterface"%go.

Definition testSharedFunctionsInterface {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testSharedFunctionsInterface"%go.

Definition testAcceptAddressInterface {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testAcceptAddressInterface"%go.

Definition testPolymorphismInterface {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testPolymorphismInterface"%go.

Definition testEmbeddingInterface {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testEmbeddingInterface"%go.

Definition testDowncastInterface {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testDowncastInterface"%go.

Definition testsUseLocks {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testsUseLocks"%go.

Definition standardForLoop {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.standardForLoop"%go.

Definition testStandardForLoop {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testStandardForLoop"%go.

Definition testForLoopWait {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testForLoopWait"%go.

Definition testBreakFromLoopWithContinue {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testBreakFromLoopWithContinue"%go.

Definition testBreakFromLoopNoContinue {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testBreakFromLoopNoContinue"%go.

Definition testBreakFromLoopNoContinueDouble {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testBreakFromLoopNoContinueDouble"%go.

Definition testBreakFromLoopForOnly {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testBreakFromLoopForOnly"%go.

Definition testBreakFromLoopAssignAndContinue {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testBreakFromLoopAssignAndContinue"%go.

Definition testNestedLoops {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testNestedLoops"%go.

Definition testNestedGoStyleLoops {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testNestedGoStyleLoops"%go.

Definition testNestedGoStyleLoopsNoComparison {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testNestedGoStyleLoopsNoComparison"%go.

Definition IterateMapKeys {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.IterateMapKeys"%go.

Definition IterateMapValues {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.IterateMapValues"%go.

Definition testIterateMap {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testIterateMap"%go.

Definition testMapSize {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testMapSize"%go.

Definition multReturnTwo {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.multReturnTwo"%go.

Definition testAssignTwo {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testAssignTwo"%go.

Definition multReturnThree {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.multReturnThree"%go.

Definition testAssignThree {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testAssignThree"%go.

Definition testMultipleAssignToMap {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testMultipleAssignToMap"%go.

Definition returnTwo {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.returnTwo"%go.

Definition testReturnTwo {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testReturnTwo"%go.

Definition testAnonymousBinding {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testAnonymousBinding"%go.

Definition returnThree {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.returnThree"%go.

Definition testReturnThree {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testReturnThree"%go.

Definition returnFour {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.returnFour"%go.

Definition testReturnFour {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testReturnFour"%go.

Definition testCompareSliceToNil {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testCompareSliceToNil"%go.

Definition testComparePointerToNil {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testComparePointerToNil"%go.

Definition testCompareNilToNil {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testCompareNilToNil"%go.

Definition testComparePointerWrappedToNil {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testComparePointerWrappedToNil"%go.

Definition testComparePointerWrappedDefaultToNil {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testComparePointerWrappedDefaultToNil"%go.

Definition testInterfaceNilWithType {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testInterfaceNilWithType"%go.

Definition reverseAssignOps64 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.reverseAssignOps64"%go.

Definition reverseAssignOps32 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.reverseAssignOps32"%go.

Definition add64Equals {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.add64Equals"%go.

Definition sub64Equals {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.sub64Equals"%go.

Definition testReverseAssignOps64 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testReverseAssignOps64"%go.

Definition failing_testReverseAssignOps32 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.failing_testReverseAssignOps32"%go.

Definition testAdd64Equals {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testAdd64Equals"%go.

Definition testSub64Equals {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testSub64Equals"%go.

Definition testDivisionPrecedence {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testDivisionPrecedence"%go.

Definition testModPrecedence {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testModPrecedence"%go.

Definition testBitwiseOpsPrecedence {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testBitwiseOpsPrecedence"%go.

Definition testArithmeticShifts {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testArithmeticShifts"%go.

Definition testBitAddAnd {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testBitAddAnd"%go.

Definition testManyParentheses {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testManyParentheses"%go.

Definition testPlusTimes {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testPlusTimes"%go.

Definition shouldPanic {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.shouldPanic"%go.

Definition testOrCompareSimple {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testOrCompareSimple"%go.

Definition testOrCompare {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testOrCompare"%go.

Definition testAndCompare {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testAndCompare"%go.

Definition testShiftMod {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testShiftMod"%go.

Definition testLinearize {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testLinearize"%go.

Definition CheckTrue {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.CheckTrue"%go.

Definition CheckFalse {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.CheckFalse"%go.

Definition testShortcircuitAndTF {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testShortcircuitAndTF"%go.

Definition testShortcircuitAndFT {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testShortcircuitAndFT"%go.

Definition testShortcircuitOrTF {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testShortcircuitOrTF"%go.

Definition testShortcircuitOrFT {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testShortcircuitOrFT"%go.

Definition testSliceOps {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testSliceOps"%go.

Definition testSliceCapacityOps {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testSliceCapacityOps"%go.

Definition testOverwriteArray {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testOverwriteArray"%go.

Definition testSliceLiteral {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testSliceLiteral"%go.

Definition testSliceAppend {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testSliceAppend"%go.

Definition testFooBarMutation {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testFooBarMutation"%go.

Definition NewS {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.NewS"%go.

Definition testStructUpdates {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testStructUpdates"%go.

Definition testNestedStructUpdates {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testNestedStructUpdates"%go.

Definition testStructConstructions {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testStructConstructions"%go.

Definition testIncompleteStruct {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testIncompleteStruct"%go.

Definition testStoreInStructVar {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testStoreInStructVar"%go.

Definition testStoreInStructPointerVar {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testStoreInStructPointerVar"%go.

Definition testStoreComposite {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testStoreComposite"%go.

Definition testStoreSlice {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testStoreSlice"%go.

Definition testStructFieldFunc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testStructFieldFunc"%go.

Definition testSwitchVal {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testSwitchVal"%go.

Definition testSwitchMultiple {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testSwitchMultiple"%go.

Definition testSwitchDefaultTrue {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testSwitchDefaultTrue"%go.

Definition testSwitchConversion {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testSwitchConversion"%go.

Definition TypesEqual {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.TypesEqual"%go.

Definition testPrimitiveTypesEqual {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testPrimitiveTypesEqual"%go.

Definition testDefinedStrTypesEqual {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testDefinedStrTypesEqual"%go.

Definition testListTypesEqual {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testListTypesEqual"%go.

Definition testPointerAssignment {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testPointerAssignment"%go.

Definition testAddressOfLocal {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testAddressOfLocal"%go.

Definition testAnonymousAssign {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testAnonymousAssign"%go.

Definition intToBlock {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.intToBlock"%go.

Definition blockToInt {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.blockToInt"%go.

Definition New {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.New"%go.

Definition getLogEntry {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.getLogEntry"%go.

Definition applyLog {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.applyLog"%go.

Definition clearLog {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.clearLog"%go.

Definition Open {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.Open"%go.

Definition disabled_testWal {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.disabled_testWal"%go.

(* go: allocator.go:7:6 *)
Definition findKeyⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "m",
    exception_do (let: "m" := (GoAlloc (go.MapType go.uint64 unit) "m") in
    let: "found" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("found" <-[go.uint64] "$r0");;;
    let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #false in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$range" := (![go.MapType go.uint64 unit] "m") in
    (let: "k" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    map.for_range go.uint64 unit "$range" (λ: "$key" "value",
      do:  ("k" <-[go.uint64] "$key");;;
      (if: (⟨go.bool⟩! (![go.bool] "ok"))
      then
        let: "$r0" := (![go.uint64] "k") in
        do:  ("found" <-[go.uint64] "$r0");;;
        let: "$r0" := #true in
        do:  ("ok" <-[go.bool] "$r0")
      else do:  #())));;;
    return: (![go.uint64] "found", ![go.bool] "ok")).

(* go: allocator.go:20:6 *)
Definition allocateⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "m",
    exception_do (let: "m" := (GoAlloc (go.MapType go.uint64 unit) "m") in
    let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "k" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.MapType go.uint64 unit] "m") in
    (FuncResolve findKey [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("k" <-[go.uint64] "$r0");;;
    do:  ("ok" <-[go.bool] "$r1");;;
    do:  (let: "$a0" := (![go.MapType go.uint64 unit] "m") in
    let: "$a1" := (![go.uint64] "k") in
    (FuncResolve go.delete [go.MapType go.uint64 unit] #()) "$a0" "$a1");;;
    return: (![go.uint64] "k", ![go.bool] "ok")).

(* go: allocator.go:26:6 *)
Definition freeRangeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "sz",
    exception_do (let: "sz" := (GoAlloc go.uint64 "sz") in
    let: "m" := (GoAlloc (go.MapType go.uint64 unit) (GoZeroVal (go.MapType go.uint64 unit) #())) in
    let: "$r0" := ((FuncResolve go.make1 [go.MapType go.uint64 unit] #()) #()) in
    do:  ("m" <-[go.MapType go.uint64 unit] "$r0");;;
    (let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, (![go.uint64] "i") <⟨go.uint64⟩ (![go.uint64] "sz")); (λ: <>, do:  ("i" <-[go.uint64] ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 1)))) := λ: <>,
      let: "$r0" := (CompositeLiteral unit (LiteralValue [])) in
      do:  (map.insert go.uint64 (![go.MapType go.uint64 unit] "m") (![go.uint64] "i") "$r0")));;;
    return: (![go.MapType go.uint64 unit] "m")).

(* go: allocator.go:34:6 *)
Definition testAllocateDistinctⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "free" := (GoAlloc (go.MapType go.uint64 unit) (GoZeroVal (go.MapType go.uint64 unit) #())) in
    let: "$r0" := (let: "$a0" := #(W64 4) in
    (FuncResolve freeRange [] #()) "$a0") in
    do:  ("free" <-[go.MapType go.uint64 unit] "$r0");;;
    let: "a1" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.MapType go.uint64 unit] "free") in
    (FuncResolve allocate [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("a1" <-[go.uint64] "$r0");;;
    do:  "$r1";;;
    let: "a2" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.MapType go.uint64 unit] "free") in
    (FuncResolve allocate [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("a2" <-[go.uint64] "$r0");;;
    do:  "$r1";;;
    return: ((![go.uint64] "a1") ≠⟨go.uint64⟩ (![go.uint64] "a2"))).

(* go: allocator.go:41:6 *)
Definition testAllocateFullⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "free" := (GoAlloc (go.MapType go.uint64 unit) (GoZeroVal (go.MapType go.uint64 unit) #())) in
    let: "$r0" := (let: "$a0" := #(W64 2) in
    (FuncResolve freeRange [] #()) "$a0") in
    do:  ("free" <-[go.MapType go.uint64 unit] "$r0");;;
    let: "ok1" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.MapType go.uint64 unit] "free") in
    (FuncResolve allocate [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  "$r0";;;
    do:  ("ok1" <-[go.bool] "$r1");;;
    let: "ok2" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.MapType go.uint64 unit] "free") in
    (FuncResolve allocate [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  "$r0";;;
    do:  ("ok2" <-[go.bool] "$r1");;;
    let: "ok3" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.MapType go.uint64 unit] "free") in
    (FuncResolve allocate [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  "$r0";;;
    do:  ("ok3" <-[go.bool] "$r1");;;
    return: (((![go.bool] "ok1") && (![go.bool] "ok2")) && (⟨go.bool⟩! (![go.bool] "ok3")))).

(* go: block.go:3:6 *)
Definition testExplicitBlockStmtⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := #(W64 10) in
    do:  ("x" <-[go.int] "$r0");;;
    let: "x" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := #(W64 11) in
    do:  ("x" <-[go.int] "$r0");;;
    do:  ("x" <-[go.int] ((![go.int] "x") +⟨go.int⟩ #(W64 1)));;;
    return: ((![go.int] "x") =⟨go.int⟩ #(W64 10))).

(* go: builtin.go:3:6 *)
Definition testMinUint64ⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 10) in
    do:  ("x" <-[go.uint64] "$r0");;;
    return: ((let: "$a0" := (![go.uint64] "x") in
     let: "$a1" := #(W64 1) in
     (FuncResolve go.min [go.uint64; go.uint64] #()) "$a0" "$a1") =⟨go.uint64⟩ #(W64 1))).

(* go: builtin.go:8:6 *)
Definition testMaxUint64ⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 10) in
    do:  ("x" <-[go.uint64] "$r0");;;
    return: ((let: "$a0" := (![go.uint64] "x") in
     let: "$a1" := #(W64 1) in
     (FuncResolve go.max [go.uint64; go.uint64] #()) "$a0" "$a1") =⟨go.uint64⟩ #(W64 10))).

(* go: closures.go:6:6 *)
Definition adderⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "sum" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("sum" <-[go.uint64] "$r0");;;
    return: ((λ: "x",
       exception_do (let: "x" := (GoAlloc go.uint64 "x") in
       do:  ("sum" <-[go.uint64] ((![go.uint64] "sum") +⟨go.uint64⟩ (![go.uint64] "x")));;;
       return: (![go.uint64] "sum"))
       ))).

(* go: closures.go:14:6 *)
Definition testClosureBasicⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "pos" := (GoAlloc AdderType (GoZeroVal AdderType #())) in
    let: "$r0" := ((FuncResolve adder [] #()) #()) in
    do:  ("pos" <-[AdderType] "$r0");;;
    let: "doub" := (GoAlloc AdderType (GoZeroVal AdderType #())) in
    let: "$r0" := ((FuncResolve adder [] #()) #()) in
    do:  ("doub" <-[AdderType] "$r0");;;
    (let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, (![go.uint64] "i") <⟨go.uint64⟩ #(W64 10)); (λ: <>, do:  ("i" <-[go.uint64] ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 1)))) := λ: <>,
      do:  (let: "$a0" := (![go.uint64] "i") in
      (![AdderType] "pos") "$a0");;;
      do:  (let: "$a0" := (#(W64 2) *⟨go.uint64⟩ (![go.uint64] "i")) in
      (![AdderType] "doub") "$a0")));;;
    (if: Convert go.untyped_bool go.bool (((let: "$a0" := #(W64 0) in
    (![AdderType] "pos") "$a0") =⟨go.uint64⟩ #(W64 45)) && ((let: "$a0" := #(W64 0) in
    (![AdderType] "doub") "$a0") =⟨go.uint64⟩ #(W64 90)))
    then return: (#true)
    else do:  #());;;
    return: (#false)).

(* go: comparisons.go:3:6 *)
Definition testCompareAllⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "nok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #false in
    do:  ("nok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && #true) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && #false) in
    do:  ("nok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && #true) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && #true) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && #false) in
    do:  ("nok" <-[go.bool] "$r0");;;
    (if: ![go.bool] "nok"
    then return: (#false)
    else do:  #());;;
    return: (![go.bool] "ok")).

(* go: comparisons.go:20:6 *)
Definition testCompareGTⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 4) in
    do:  ("x" <-[go.uint64] "$r0");;;
    let: "y" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 5) in
    do:  ("y" <-[go.uint64] "$r0");;;
    let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] "y") >⟨go.uint64⟩ #(W64 4))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] "y") >⟨go.uint64⟩ (![go.uint64] "x"))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    return: (![go.bool] "ok")).

(* go: comparisons.go:31:6 *)
Definition testCompareGEⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 4) in
    do:  ("x" <-[go.uint64] "$r0");;;
    let: "y" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 5) in
    do:  ("y" <-[go.uint64] "$r0");;;
    let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] "y") ≥⟨go.uint64⟩ #(W64 4))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] "y") ≥⟨go.uint64⟩ #(W64 5))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] "y") ≥⟨go.uint64⟩ (![go.uint64] "x"))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "y") >⟨go.uint64⟩ #(W64 5))
    then return: (#false)
    else do:  #());;;
    return: (![go.bool] "ok")).

(* go: comparisons.go:47:6 *)
Definition testCompareLTⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 4) in
    do:  ("x" <-[go.uint64] "$r0");;;
    let: "y" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 5) in
    do:  ("y" <-[go.uint64] "$r0");;;
    let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] "y") <⟨go.uint64⟩ #(W64 6))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] "x") <⟨go.uint64⟩ (![go.uint64] "y"))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    return: (![go.bool] "ok")).

(* go: comparisons.go:58:6 *)
Definition testCompareLEⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 4) in
    do:  ("x" <-[go.uint64] "$r0");;;
    let: "y" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 5) in
    do:  ("y" <-[go.uint64] "$r0");;;
    let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] "y") ≤⟨go.uint64⟩ #(W64 6))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] "y") ≤⟨go.uint64⟩ #(W64 5))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] "x") ≤⟨go.uint64⟩ (![go.uint64] "y"))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "y") <⟨go.uint64⟩ #(W64 5))
    then return: (#false)
    else do:  #());;;
    return: (![go.bool] "ok")).

(* go: conversions.go:5:6 *)
Definition literalCastⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 2) in
    do:  ("x" <-[go.uint64] "$r0");;;
    return: ((![go.uint64] "x") +⟨go.uint64⟩ #(W64 2))).

(* go: conversions.go:11:6 *)
Definition stringToByteSliceⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s",
    exception_do (let: "s" := (GoAlloc go.string "s") in
    let: "p" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (Convert go.string (go.SliceType go.byte) (![go.string] "s")) in
    do:  ("p" <-[go.SliceType go.byte] "$r0");;;
    return: (![go.SliceType go.byte] "p")).

(* go: conversions.go:17:6 *)
Definition byteSliceToStringⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "p",
    exception_do (let: "p" := (GoAlloc (go.SliceType go.byte) "p") in
    return: (Convert (go.SliceType go.byte) go.string (![go.SliceType go.byte] "p"))).

(* tests

   go: conversions.go:23:6 *)
Definition testByteSliceToStringⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 3)) in
    do:  ("x" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := #(W8 65) in
    do:  ((IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "x", #(W64 0))) <-[go.byte] "$r0");;;
    let: "$r0" := #(W8 66) in
    do:  ((IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "x", #(W64 1))) <-[go.byte] "$r0");;;
    let: "$r0" := #(W8 67) in
    do:  ((IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "x", #(W64 2))) <-[go.byte] "$r0");;;
    return: ((let: "$a0" := (![go.SliceType go.byte] "x") in
     (FuncResolve byteSliceToString [] #()) "$a0") =⟨go.string⟩ #"ABC"%go)).

(* go: copy.go:3:6 *)
Definition testCopySimpleⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 10)) in
    do:  ("x" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := #(W8 1) in
    do:  ((IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "x", #(W64 3))) <-[go.byte] "$r0");;;
    let: "y" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 10)) in
    do:  ("y" <-[go.SliceType go.byte] "$r0");;;
    do:  (let: "$a0" := (![go.SliceType go.byte] "y") in
    let: "$a1" := (![go.SliceType go.byte] "x") in
    (FuncResolve go.copy [go.SliceType go.byte] #()) "$a0" "$a1");;;
    return: ((![go.byte] (IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "y", #(W64 3)))) =⟨go.byte⟩ #(W8 1))).

(* go: copy.go:11:6 *)
Definition testCopyShorterDstⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 15)) in
    do:  ("x" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := #(W8 1) in
    do:  ((IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "x", #(W64 3))) <-[go.byte] "$r0");;;
    let: "$r0" := #(W8 2) in
    do:  ((IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "x", #(W64 12))) <-[go.byte] "$r0");;;
    let: "y" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 10)) in
    do:  ("y" <-[go.SliceType go.byte] "$r0");;;
    let: "n" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (Convert go.int go.uint64 (let: "$a0" := (![go.SliceType go.byte] "y") in
    let: "$a1" := (![go.SliceType go.byte] "x") in
    (FuncResolve go.copy [go.SliceType go.byte] #()) "$a0" "$a1")) in
    do:  ("n" <-[go.uint64] "$r0");;;
    return: (((![go.uint64] "n") =⟨go.uint64⟩ #(W64 10)) && ((![go.byte] (IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "y", #(W64 3)))) =⟨go.byte⟩ #(W8 1)))).

(* go: copy.go:20:6 *)
Definition testCopyShorterSrcⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 10)) in
    do:  ("x" <-[go.SliceType go.byte] "$r0");;;
    let: "y" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 15)) in
    do:  ("y" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := #(W8 1) in
    do:  ((IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "x", #(W64 3))) <-[go.byte] "$r0");;;
    let: "$r0" := #(W8 2) in
    do:  ((IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "y", #(W64 12))) <-[go.byte] "$r0");;;
    let: "n" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (Convert go.int go.uint64 (let: "$a0" := (![go.SliceType go.byte] "y") in
    let: "$a1" := (![go.SliceType go.byte] "x") in
    (FuncResolve go.copy [go.SliceType go.byte] #()) "$a0" "$a1")) in
    do:  ("n" <-[go.uint64] "$r0");;;
    return: ((((![go.uint64] "n") =⟨go.uint64⟩ #(W64 10)) && ((![go.byte] (IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "y", #(W64 3)))) =⟨go.byte⟩ #(W8 1))) && ((![go.byte] (IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "y", #(W64 12)))) =⟨go.byte⟩ #(W8 2)))).

(* go: defer.go:3:6 *)
Definition deferSimpleⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    with_defer: (let: "x" := (GoAlloc (go.PointerType go.uint64) (GoZeroVal (go.PointerType go.uint64) #())) in
    let: "$r0" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    do:  ("x" <-[go.PointerType go.uint64] "$r0");;;
    (let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, (![go.uint64] "i") <⟨go.uint64⟩ #(W64 10)); (λ: <>, do:  ("i" <-[go.uint64] ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 1)))) := λ: <>,
      do:  (let: "$f" := (λ: <>,
        exception_do (do:  ((![go.PointerType go.uint64] "x") <-[go.uint64] ((![go.uint64] (![go.PointerType go.uint64] "x")) +⟨go.uint64⟩ #(W64 1)));;;
        return: #())
        ) in
      "$defer" <-[deferType] (let: "$oldf" := (![deferType] "$defer") in
      (λ: <>,
        "$f" #();;
        "$oldf" #()
        )))));;;
    return: (![go.PointerType go.uint64] "x")).

(* go: defer.go:13:6 *)
Definition testDeferⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: ((![go.uint64] ((FuncResolve deferSimple [] #()) #())) =⟨go.uint64⟩ #(W64 10))).

(* go: defer.go:17:6 *)
Definition testDeferFuncLitⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := #(W64 10) in
    do:  ("x" <-[go.int] "$r0");;;
    let: "f" := (GoAlloc (go.FunctionType (go.Signature [] false [])) (GoZeroVal (go.FunctionType (go.Signature [] false [])) #())) in
    let: "$r0" := (λ: <>,
      with_defer: (do:  (let: "$f" := (λ: <>,
        exception_do (do:  ("x" <-[go.int] ((![go.int] "x") +⟨go.int⟩ #(W64 1)));;;
        return: #())
        ) in
      "$defer" <-[deferType] (let: "$oldf" := (![deferType] "$defer") in
      (λ: <>,
        "$f" #();;
        "$oldf" #()
        )));;;
      return: #())
      ) in
    do:  ("f" <-[go.FunctionType (go.Signature [] false [])] "$r0");;;
    do:  ((![go.FunctionType (go.Signature [] false [])] "f") #());;;
    return: ((![go.int] "x") =⟨go.int⟩ #(W64 11))).

(* go: first_class_function.go:3:6 *)
Definition FirstClassFunctionⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "a",
    exception_do (let: "a" := (GoAlloc go.uint64 "a") in
    return: ((![go.uint64] "a") +⟨go.uint64⟩ #(W64 10))).

(* go: first_class_function.go:7:6 *)
Definition ApplyFⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "a" "f",
    exception_do (let: "f" := (GoAlloc (go.FunctionType (go.Signature [go.uint64] false [go.uint64])) "f") in
    let: "a" := (GoAlloc go.uint64 "a") in
    return: (let: "$a0" := (![go.uint64] "a") in
     (![go.FunctionType (go.Signature [go.uint64] false [go.uint64])] "f") "$a0")).

(* go: first_class_function.go:11:6 *)
Definition testFirstClassFunctionⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: ((let: "$a0" := #(W64 1) in
     let: "$a1" := (FuncResolve FirstClassFunction [] #()) in
     (FuncResolve ApplyF [] #()) "$a0" "$a1") =⟨go.uint64⟩ #(W64 11))).

(* advances the array editor, and returns the value it wrote, storing
   "next" in next_val

   go: function_ordering.go:11:18 *)
Definition Editor__AdvanceReturnⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "e" "next",
    exception_do (let: "e" := (GoAlloc (go.PointerType Editor) "e") in
    let: "next" := (GoAlloc go.uint64 "next") in
    let: "tmp" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (![go.uint64] (StructFieldRef Editor "next_val"%go (![go.PointerType Editor] "e"))) in
    do:  ("tmp" <-[go.uint64] "$r0");;;
    let: "$r0" := (![go.uint64] "tmp") in
    do:  ((IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] (StructFieldRef Editor "s"%go (![go.PointerType Editor] "e")), #(W64 0))) <-[go.uint64] "$r0");;;
    let: "$r0" := (![go.uint64] "next") in
    do:  ((StructFieldRef Editor "next_val"%go (![go.PointerType Editor] "e")) <-[go.uint64] "$r0");;;
    let: "$r0" := (let: "$s" := (![go.SliceType go.uint64] (StructFieldRef Editor "s"%go (![go.PointerType Editor] "e"))) in
    Slice (go.SliceType go.uint64) ("$s", #(W64 1), FuncResolve go.len [go.SliceType go.uint64] #() (![go.SliceType go.uint64] (StructFieldRef Editor "s"%go (![go.PointerType Editor] "e"))))) in
    do:  ((StructFieldRef Editor "s"%go (![go.PointerType Editor] "e")) <-[go.SliceType go.uint64] "$r0");;;
    return: (![go.uint64] "tmp")).

(* we call this function with side-effectful function calls as arguments,
   its implementation is unimportant

   go: function_ordering.go:21:6 *)
Definition addFour64ⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "a" "b" "c" "d",
    exception_do (let: "d" := (GoAlloc go.uint64 "d") in
    let: "c" := (GoAlloc go.uint64 "c") in
    let: "b" := (GoAlloc go.uint64 "b") in
    let: "a" := (GoAlloc go.uint64 "a") in
    return: ((((![go.uint64] "a") +⟨go.uint64⟩ (![go.uint64] "b")) +⟨go.uint64⟩ (![go.uint64] "c")) +⟨go.uint64⟩ (![go.uint64] "d"))).

(* tests

   go: function_ordering.go:31:6 *)
Definition failing_testFunctionOrderingⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "arr" := (GoAlloc (go.SliceType go.uint64) (GoZeroVal (go.SliceType go.uint64) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType go.uint64] #()) #(W64 5)) in
    do:  ("arr" <-[go.SliceType go.uint64] "$r0");;;
    let: "e1" := (GoAlloc Editor (GoZeroVal Editor #())) in
    let: "$r0" := (let: "$v0" := (let: "$s" := (![go.SliceType go.uint64] "arr") in
    Slice (go.SliceType go.uint64) ("$s", #(W64 0), FuncResolve go.len [go.SliceType go.uint64] #() (![go.SliceType go.uint64] "arr"))) in
    let: "$v1" := #(W64 1) in
    CompositeLiteral Editor (LiteralValue [KeyedElement (Some (KeyField "s"%go)) (ElementExpression (go.SliceType go.uint64) "$v0"); KeyedElement (Some (KeyField "next_val"%go)) (ElementExpression go.uint64 "$v1")])) in
    do:  ("e1" <-[Editor] "$r0");;;
    let: "e2" := (GoAlloc Editor (GoZeroVal Editor #())) in
    let: "$r0" := (let: "$v0" := (let: "$s" := (![go.SliceType go.uint64] "arr") in
    Slice (go.SliceType go.uint64) ("$s", #(W64 0), FuncResolve go.len [go.SliceType go.uint64] #() (![go.SliceType go.uint64] "arr"))) in
    let: "$v1" := #(W64 101) in
    CompositeLiteral Editor (LiteralValue [KeyedElement (Some (KeyField "s"%go)) (ElementExpression (go.SliceType go.uint64) "$v0"); KeyedElement (Some (KeyField "next_val"%go)) (ElementExpression go.uint64 "$v1")])) in
    do:  ("e2" <-[Editor] "$r0");;;
    (if: Convert go.untyped_bool go.bool (((let: "$a0" := #(W64 2) in
    (MethodResolve (go.PointerType Editor) "AdvanceReturn"%go "e1") "$a0") +⟨go.uint64⟩ (let: "$a0" := #(W64 102) in
    (MethodResolve (go.PointerType Editor) "AdvanceReturn"%go "e2") "$a0")) ≠⟨go.uint64⟩ #(W64 102))
    then return: (#false)
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] (IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "arr", #(W64 0)))) ≠⟨go.uint64⟩ #(W64 101))
    then return: (#false)
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool ((let: "$a0" := (let: "$a0" := #(W64 3) in
    (MethodResolve (go.PointerType Editor) "AdvanceReturn"%go "e1") "$a0") in
    let: "$a1" := (let: "$a0" := #(W64 103) in
    (MethodResolve (go.PointerType Editor) "AdvanceReturn"%go "e2") "$a0") in
    let: "$a2" := (let: "$a0" := #(W64 104) in
    (MethodResolve (go.PointerType Editor) "AdvanceReturn"%go "e2") "$a0") in
    let: "$a3" := (let: "$a0" := #(W64 4) in
    (MethodResolve (go.PointerType Editor) "AdvanceReturn"%go "e1") "$a0") in
    (FuncResolve addFour64 [] #()) "$a0" "$a1" "$a2" "$a3") ≠⟨go.uint64⟩ #(W64 210))
    then return: (#false)
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] (IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "arr", #(W64 1)))) ≠⟨go.uint64⟩ #(W64 102))
    then return: (#false)
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] (IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "arr", #(W64 2)))) ≠⟨go.uint64⟩ #(W64 3))
    then return: (#false)
    else do:  #());;;
    let: "p" := (GoAlloc Pair (GoZeroVal Pair #())) in
    let: "$r0" := (let: "$v0" := (let: "$a0" := #(W64 5) in
    (MethodResolve (go.PointerType Editor) "AdvanceReturn"%go "e1") "$a0") in
    let: "$v1" := (let: "$a0" := #(W64 105) in
    (MethodResolve (go.PointerType Editor) "AdvanceReturn"%go "e2") "$a0") in
    CompositeLiteral Pair (LiteralValue [KeyedElement (Some (KeyField "x"%go)) (ElementExpression go.uint64 "$v0"); KeyedElement (Some (KeyField "y"%go)) (ElementExpression go.uint64 "$v1")])) in
    do:  ("p" <-[Pair] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] (IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "arr", #(W64 3)))) ≠⟨go.uint64⟩ #(W64 104))
    then return: (#false)
    else do:  #());;;
    let: "q" := (GoAlloc Pair (GoZeroVal Pair #())) in
    let: "$r0" := (let: "$v0" := (let: "$a0" := #(W64 6) in
    (MethodResolve (go.PointerType Editor) "AdvanceReturn"%go "e1") "$a0") in
    let: "$v1" := (let: "$a0" := #(W64 106) in
    (MethodResolve (go.PointerType Editor) "AdvanceReturn"%go "e2") "$a0") in
    CompositeLiteral Pair (LiteralValue [KeyedElement (Some (KeyField "y"%go)) (ElementExpression go.uint64 "$v0"); KeyedElement (Some (KeyField "x"%go)) (ElementExpression go.uint64 "$v1")])) in
    do:  ("q" <-[Pair] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] (IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "arr", #(W64 4)))) ≠⟨go.uint64⟩ #(W64 105))
    then return: (#false)
    else do:  #());;;
    return: (((![go.uint64] (StructFieldRef Pair "x"%go "p")) +⟨go.uint64⟩ (![go.uint64] (StructFieldRef Pair "x"%go "q"))) =⟨go.uint64⟩ #(W64 109))).

(* go: function_ordering.go:74:6 *)
Definition storeAndReturnⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x" "v",
    exception_do (let: "v" := (GoAlloc go.uint64 "v") in
    let: "x" := (GoAlloc (go.PointerType go.uint64) "x") in
    let: "$r0" := (![go.uint64] "v") in
    do:  ((![go.PointerType go.uint64] "x") <-[go.uint64] "$r0");;;
    return: (![go.uint64] "v")).

(* Goose has a right-to-left evaluation order for function arguments,
   which is incorrect.

   go: function_ordering.go:81:6 *)
Definition failing_testArgumentOrderⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("x" <-[go.uint64] "$r0");;;
    do:  (let: "$a0" := (let: "$a0" := "x" in
    let: "$a1" := #(W64 1) in
    (FuncResolve storeAndReturn [] #()) "$a0" "$a1") in
    let: "$a1" := (let: "$a0" := "x" in
    let: "$a1" := #(W64 2) in
    (FuncResolve storeAndReturn [] #()) "$a0" "$a1") in
    let: "$a2" := (let: "$a0" := "x" in
    let: "$a1" := #(W64 3) in
    (FuncResolve storeAndReturn [] #()) "$a0" "$a1") in
    let: "$a3" := (let: "$a0" := "x" in
    let: "$a1" := #(W64 4) in
    (FuncResolve storeAndReturn [] #()) "$a0" "$a1") in
    (FuncResolve addFour64 [] #()) "$a0" "$a1" "$a2" "$a3");;;
    let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := ((![go.uint64] "x") =⟨go.uint64⟩ #(W64 4)) in
    do:  ("ok" <-[go.bool] "$r0");;;
    return: (![go.bool] "ok")).

(* go: int_conversions.go:3:6 *)
Definition testU64ToU32ⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "x" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 1230) in
    do:  ("x" <-[go.uint64] "$r0");;;
    let: "y" := (GoAlloc go.uint32 (GoZeroVal go.uint32 #())) in
    let: "$r0" := #(W32 1230) in
    do:  ("y" <-[go.uint32] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((Convert go.uint64 go.uint32 (![go.uint64] "x")) =⟨go.uint32⟩ (![go.uint32] "y"))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((Convert go.uint32 go.uint64 (![go.uint32] "y")) =⟨go.uint64⟩ (![go.uint64] "x"))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    return: (![go.bool] "ok")).

(* go: int_conversions.go:12:6 *)
Definition testU32ToU64ⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "x" := (GoAlloc go.uint32 (GoZeroVal go.uint32 #())) in
    let: "$r0" := #(W32 1230) in
    do:  ("x" <-[go.uint32] "$r0");;;
    let: "y" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 1230) in
    do:  ("y" <-[go.uint64] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((Convert go.uint32 go.uint64 (![go.uint32] "x")) =⟨go.uint64⟩ (![go.uint64] "y"))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((Convert go.uint64 go.uint32 (![go.uint64] "y")) =⟨go.uint32⟩ (![go.uint32] "x"))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    return: (![go.bool] "ok")).

(* go: int_conversions.go:21:6 *)
Definition testU32Lenⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "s" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 100)) in
    do:  ("s" <-[go.SliceType go.byte] "$r0");;;
    return: ((Convert go.int go.uint32 (let: "$a0" := (![go.SliceType go.byte] "s") in
     (FuncResolve go.len [go.SliceType go.byte] #()) "$a0")) =⟨go.uint32⟩ #(W32 100))).

(* go: int_conversions.go:28:6 *)
Definition testU32NewtypeLenⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "s" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 20)) in
    do:  ("s" <-[go.SliceType go.byte] "$r0");;;
    return: ((Convert go.int Uint32 (let: "$a0" := (![go.SliceType go.byte] "s") in
     (FuncResolve go.len [go.SliceType go.byte] #()) "$a0")) =⟨go.uint32⟩ #(W32 20))).

(* go: int_conversions.go:33:6 *)
Definition testUint32Untypedⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc Uint32 (GoZeroVal Uint32 #())) in
    let: "$r0" := #(W32 1230) in
    do:  ("x" <-[Uint32] "$r0");;;
    return: ((![Uint32] "x") =⟨go.uint32⟩ #(W32 1230))).

(* go: interfaces.go:12:6 *)
Definition measureAreaⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "t",
    exception_do (let: "t" := (GoAlloc geometryInterface "t") in
    return: ((MethodResolve geometryInterface "Square"%go (![geometryInterface] "t")) #())).

(* go: interfaces.go:16:6 *)
Definition measureVolumePlusNMⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "t" "n" "m",
    exception_do (let: "m" := (GoAlloc go.uint64 "m") in
    let: "n" := (GoAlloc go.uint64 "n") in
    let: "t" := (GoAlloc geometryInterface "t") in
    return: ((((MethodResolve geometryInterface "Volume"%go (![geometryInterface] "t")) #()) +⟨go.uint64⟩ (![go.uint64] "n")) +⟨go.uint64⟩ (![go.uint64] "m"))).

(* go: interfaces.go:20:6 *)
Definition measureVolumeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "t",
    exception_do (let: "t" := (GoAlloc geometryInterface "t") in
    return: ((MethodResolve geometryInterface "Volume"%go (![geometryInterface] "t")) #())).

(* go: interfaces.go:28:23 *)
Definition SquareStruct__Squareⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "t" <>,
    exception_do (let: "t" := (GoAlloc SquareStruct "t") in
    return: ((![go.uint64] (StructFieldRef SquareStruct "Side"%go "t")) *⟨go.uint64⟩ (![go.uint64] (StructFieldRef SquareStruct "Side"%go "t")))).

(* go: interfaces.go:32:23 *)
Definition SquareStruct__Volumeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "t" <>,
    exception_do (let: "t" := (GoAlloc SquareStruct "t") in
    return: (((![go.uint64] (StructFieldRef SquareStruct "Side"%go "t")) *⟨go.uint64⟩ (![go.uint64] (StructFieldRef SquareStruct "Side"%go "t"))) *⟨go.uint64⟩ (![go.uint64] (StructFieldRef SquareStruct "Side"%go "t")))).

(* go: interfaces.go:40:6 *)
Definition testBasicInterfaceⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "s" := (GoAlloc SquareStruct (GoZeroVal SquareStruct #())) in
    let: "$r0" := (let: "$v0" := #(W64 2) in
    CompositeLiteral SquareStruct (LiteralValue [KeyedElement (Some (KeyField "Side"%go)) (ElementExpression go.uint64 "$v0")])) in
    do:  ("s" <-[SquareStruct] "$r0");;;
    return: ((let: "$a0" := (Convert SquareStruct geometryInterface (![SquareStruct] "s")) in
     (FuncResolve measureArea [] #()) "$a0") =⟨go.uint64⟩ #(W64 4))).

(* go: interfaces.go:47:6 *)
Definition testAssignInterfaceⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "s" := (GoAlloc SquareStruct (GoZeroVal SquareStruct #())) in
    let: "$r0" := (let: "$v0" := #(W64 3) in
    CompositeLiteral SquareStruct (LiteralValue [KeyedElement (Some (KeyField "Side"%go)) (ElementExpression go.uint64 "$v0")])) in
    do:  ("s" <-[SquareStruct] "$r0");;;
    let: "area" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (let: "$a0" := (Convert SquareStruct geometryInterface (![SquareStruct] "s")) in
    (FuncResolve measureArea [] #()) "$a0") in
    do:  ("area" <-[go.uint64] "$r0");;;
    return: ((![go.uint64] "area") =⟨go.uint64⟩ #(W64 9))).

(* go: interfaces.go:55:6 *)
Definition testMultipleInterfaceⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "s" := (GoAlloc SquareStruct (GoZeroVal SquareStruct #())) in
    let: "$r0" := (let: "$v0" := #(W64 3) in
    CompositeLiteral SquareStruct (LiteralValue [KeyedElement (Some (KeyField "Side"%go)) (ElementExpression go.uint64 "$v0")])) in
    do:  ("s" <-[SquareStruct] "$r0");;;
    let: "square1" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (let: "$a0" := (Convert SquareStruct geometryInterface (![SquareStruct] "s")) in
    (FuncResolve measureArea [] #()) "$a0") in
    do:  ("square1" <-[go.uint64] "$r0");;;
    let: "square2" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (let: "$a0" := (Convert SquareStruct geometryInterface (![SquareStruct] "s")) in
    (FuncResolve measureArea [] #()) "$a0") in
    do:  ("square2" <-[go.uint64] "$r0");;;
    return: ((![go.uint64] "square1") =⟨go.uint64⟩ (![go.uint64] "square2"))).

(* go: interfaces.go:64:6 *)
Definition testBinaryExprInterfaceⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "s" := (GoAlloc SquareStruct (GoZeroVal SquareStruct #())) in
    let: "$r0" := (let: "$v0" := #(W64 3) in
    CompositeLiteral SquareStruct (LiteralValue [KeyedElement (Some (KeyField "Side"%go)) (ElementExpression go.uint64 "$v0")])) in
    do:  ("s" <-[SquareStruct] "$r0");;;
    let: "square1" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (let: "$a0" := (Convert SquareStruct geometryInterface (![SquareStruct] "s")) in
    (FuncResolve measureArea [] #()) "$a0") in
    do:  ("square1" <-[go.uint64] "$r0");;;
    let: "square2" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (let: "$a0" := (Convert SquareStruct geometryInterface (![SquareStruct] "s")) in
    (FuncResolve measureVolume [] #()) "$a0") in
    do:  ("square2" <-[go.uint64] "$r0");;;
    return: (((![go.uint64] "square1") =⟨go.uint64⟩ (let: "$a0" := (Convert SquareStruct geometryInterface (![SquareStruct] "s")) in
     (FuncResolve measureArea [] #()) "$a0")) && ((![go.uint64] "square2") =⟨go.uint64⟩ (let: "$a0" := (Convert SquareStruct geometryInterface (![SquareStruct] "s")) in
     (FuncResolve measureVolume [] #()) "$a0")))).

(* go: interfaces.go:73:6 *)
Definition testIfStmtInterfaceⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "s" := (GoAlloc SquareStruct (GoZeroVal SquareStruct #())) in
    let: "$r0" := (let: "$v0" := #(W64 3) in
    CompositeLiteral SquareStruct (LiteralValue [KeyedElement (Some (KeyField "Side"%go)) (ElementExpression go.uint64 "$v0")])) in
    do:  ("s" <-[SquareStruct] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((let: "$a0" := (Convert SquareStruct geometryInterface (![SquareStruct] "s")) in
    (FuncResolve measureArea [] #()) "$a0") =⟨go.uint64⟩ #(W64 9))
    then return: (#true)
    else do:  #());;;
    return: (#false)).

(* go: interfaces_complex.go:11:6 *)
Definition testParamsInterfaceⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "s" := (GoAlloc SquareStruct (GoZeroVal SquareStruct #())) in
    let: "$r0" := (let: "$v0" := #(W64 3) in
    CompositeLiteral SquareStruct (LiteralValue [KeyedElement (Some (KeyField "Side"%go)) (ElementExpression go.uint64 "$v0")])) in
    do:  ("s" <-[SquareStruct] "$r0");;;
    let: "volume" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (let: "$a0" := (Convert SquareStruct geometryInterface (![SquareStruct] "s")) in
    let: "$a1" := #(W64 1) in
    let: "$a2" := #(W64 2) in
    (FuncResolve measureVolumePlusNM [] #()) "$a0" "$a1" "$a2") in
    do:  ("volume" <-[go.uint64] "$r0");;;
    return: ((![go.uint64] "volume") =⟨go.uint64⟩ #(W64 30))).

(* go: interfaces_complex.go:19:6 *)
Definition testEmptyInterfaceⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "i" := (GoAlloc (go.InterfaceType []) (GoZeroVal (go.InterfaceType []) #())) in
    let: "j" := (GoAlloc (go.InterfaceType []) (GoZeroVal (go.InterfaceType []) #())) in
    return: ((![go.InterfaceType []] "i") =⟨go.InterfaceType []⟩ (![go.InterfaceType []] "j"))).

(* go: interfaces_complex.go:25:6 *)
Definition testStringInterfaceⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "i" := (GoAlloc (go.InterfaceType []) (GoZeroVal (go.InterfaceType []) #())) in
    let: "$r0" := (Convert go.string (go.InterfaceType []) #"string"%go) in
    do:  ("i" <-[go.InterfaceType []] "$r0");;;
    let: "j" := (GoAlloc (go.InterfaceType []) (GoZeroVal (go.InterfaceType []) #())) in
    let: "$r0" := (Convert go.string (go.InterfaceType []) #"string"%go) in
    do:  ("j" <-[go.InterfaceType []] "$r0");;;
    return: ((![go.InterfaceType []] "i") =⟨go.InterfaceType []⟩ (![go.InterfaceType []] "j"))).

(* go: interfaces_complex.go:35:6 *)
Definition testTypeAssertionInterfaceⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "i" := (GoAlloc (go.InterfaceType []) (GoZeroVal (go.InterfaceType []) #())) in
    let: "$r0" := (Convert NumStruct (go.InterfaceType []) (let: "$v0" := #(W64 3) in
    CompositeLiteral NumStruct (LiteralValue [KeyedElement None (ElementExpression go.int "$v0")]))) in
    do:  ("i" <-[go.InterfaceType []] "$r0");;;
    return: ((TypeAssert NumStruct (![go.InterfaceType []] "i")) =⟨go.StructType [
       (go.FieldDecl "Value"%go go.int)
     ]⟩ (let: "$v0" := #(W64 3) in
     CompositeLiteral NumStruct (LiteralValue [KeyedElement None (ElementExpression go.int "$v0")])))).

(* go: interfaces_complex.go:52:22 *)
Definition shapeStruct__describeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" <>,
    exception_do (let: "s" := (GoAlloc shapeStruct "s") in
    return: (![go.string] (StructFieldRef shapeStruct "Shape"%go "s"))).

(* go: interfaces_complex.go:61:24 *)
Definition polygonStruct__describeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "p" <>,
    exception_do (let: "p" := (GoAlloc polygonStruct "p") in
    return: (![go.string] (StructFieldRef polygonStruct "Shape"%go "p"))).

(* go: interfaces_complex.go:65:24 *)
Definition polygonStruct__sidesⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "p" <>,
    exception_do (let: "p" := (GoAlloc polygonStruct "p") in
    return: (![go.uint64] (StructFieldRef polygonStruct "Sides"%go "p"))).

(* go: interfaces_complex.go:69:6 *)
Definition testDoublePointerInterfaceⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "s" := (GoAlloc shapeStruct (GoZeroVal shapeStruct #())) in
    let: "$r0" := (let: "$v0" := #"circle"%go in
    CompositeLiteral shapeStruct (LiteralValue [KeyedElement None (ElementExpression go.string "$v0")])) in
    do:  ("s" <-[shapeStruct] "$r0");;;
    let: "shapes" := (GoAlloc (go.SliceType shapeInterface) (GoZeroVal (go.SliceType shapeInterface) #())) in
    let: "$r0" := (let: "$v0" := (![shapeStruct] "s") in
    let: "$v1" := "s" in
    CompositeLiteral (go.SliceType shapeInterface) (LiteralValue [KeyedElement None (ElementExpression shapeStruct "$v0"); KeyedElement None (ElementExpression (go.PointerType shapeStruct) "$v1")])) in
    do:  ("shapes" <-[go.SliceType shapeInterface] "$r0");;;
    let: "$r0" := #"square"%go in
    do:  ((StructFieldRef shapeStruct "Shape"%go "s") <-[go.string] "$r0");;;
    return: (((MethodResolve shapeInterface "describe"%go (![shapeInterface] (IndexRef (go.SliceType shapeInterface) (![go.SliceType shapeInterface] "shapes", #(W64 0))))) #()) ≠⟨go.string⟩ ((MethodResolve shapeInterface "describe"%go (![shapeInterface] (IndexRef (go.SliceType shapeInterface) (![go.SliceType shapeInterface] "shapes", #(W64 1))))) #()))).

(* go: interfaces_complex.go:76:6 *)
Definition testMultipleFieldsInterfaceⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "s" := (GoAlloc polygonStruct (GoZeroVal polygonStruct #())) in
    let: "$r0" := (let: "$v0" := #"triangle"%go in
    let: "$v1" := #(W64 3) in
    CompositeLiteral polygonStruct (LiteralValue [KeyedElement None (ElementExpression go.string "$v0"); KeyedElement None (ElementExpression go.uint64 "$v1")])) in
    do:  ("s" <-[polygonStruct] "$r0");;;
    return: (((![go.string] (StructFieldRef polygonStruct "Shape"%go "s")) =⟨go.string⟩ #"triangle"%go) && ((![go.uint64] (StructFieldRef polygonStruct "Sides"%go "s")) =⟨go.uint64⟩ #(W64 3)))).

(* go: interfaces_complex.go:93:16 *)
Definition Puppy__Nameⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "p" <>,
    exception_do (let: "p" := (GoAlloc Puppy "p") in
    return: (#"Max"%go)).

(* go: interfaces_complex.go:97:16 *)
Definition Puppy__Speedⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "p" <>,
    exception_do (let: "p" := (GoAlloc Puppy "p") in
    return: (#(W64 1))).

(* go: interfaces_complex.go:103:17 *)
Definition Kitten__Nameⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "k" <>,
    exception_do (let: "k" := (GoAlloc Kitten "k") in
    return: (#"Max"%go)).

(* go: interfaces_complex.go:107:17 *)
Definition Kitten__Weightⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "k" <>,
    exception_do (let: "k" := (GoAlloc Kitten "k") in
    return: (#(W64 10))).

(* go: interfaces_complex.go:111:6 *)
Definition testSharedFunctionsInterfaceⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "kit" := (GoAlloc catInterface (GoZeroVal catInterface #())) in
    let: "$r0" := (Convert Kitten catInterface #"Kitten"%go) in
    do:  ("kit" <-[catInterface] "$r0");;;
    let: "pup" := (GoAlloc dogInterface (GoZeroVal dogInterface #())) in
    let: "$r0" := (Convert Puppy dogInterface #"Puppy"%go) in
    do:  ("pup" <-[dogInterface] "$r0");;;
    return: (((MethodResolve dogInterface "Name"%go (![dogInterface] "pup")) #()) =⟨go.string⟩ ((MethodResolve catInterface "Name"%go (![catInterface] "kit")) #()))).

(* go: interfaces_complex.go:126:23 *)
Definition PaperStruct__Assignⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "p" "t",
    exception_do (let: "p" := (GoAlloc (go.PointerType PaperStruct) "p") in
    let: "t" := (GoAlloc go.string "t") in
    let: "$r0" := (![go.string] "t") in
    do:  ((StructFieldRef PaperStruct "Title"%go (![go.PointerType PaperStruct] "p")) <-[go.string] "$r0");;;
    return: #()).

(* go: interfaces_complex.go:130:23 *)
Definition PaperStruct__GetTitleⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "p" <>,
    exception_do (let: "p" := (GoAlloc (go.PointerType PaperStruct) "p") in
    return: (![go.string] (StructFieldRef PaperStruct "Title"%go (![go.PointerType PaperStruct] "p")))).

(* go: interfaces_complex.go:134:6 *)
Definition testAcceptAddressInterfaceⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "p1" := (GoAlloc PaperStruct (GoZeroVal PaperStruct #())) in
    let: "p2" := (GoAlloc PaperStruct (GoZeroVal PaperStruct #())) in
    do:  (let: "$a0" := #"Sample Title"%go in
    (MethodResolve (go.PointerType PaperStruct) "Assign"%go "p1") "$a0");;;
    do:  (let: "$a0" := #"Sample Title"%go in
    (MethodResolve (go.PointerType PaperStruct) "Assign"%go "p2") "$a0");;;
    let: "print1" := (GoAlloc printInterface (GoZeroVal printInterface #())) in
    let: "print2" := (GoAlloc printInterface (GoZeroVal printInterface #())) in
    let: "$r0" := (Convert (go.PointerType PaperStruct) printInterface "p1") in
    do:  ("print1" <-[printInterface] "$r0");;;
    let: "$r0" := (Convert (go.PointerType PaperStruct) printInterface "p2") in
    do:  ("print2" <-[printInterface] "$r0");;;
    return: (((MethodResolve printInterface "GetTitle"%go (![printInterface] "print1")) #()) =⟨go.string⟩ ((MethodResolve printInterface "GetTitle"%go (![printInterface] "print2")) #()))).

(* go: interfaces_complex.go:157:15 *)
Definition Lily__Petalsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" <>,
    exception_do (let: "l" := (GoAlloc Lily "l") in
    return: (#(W64 3))).

(* go: interfaces_complex.go:158:15 *)
Definition Lily__Genusⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" <>,
    exception_do (let: "l" := (GoAlloc Lily "l") in
    return: (#"Lillium"%go)).

(* go: interfaces_complex.go:162:15 *)
Definition Rose__Petalsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "r" <>,
    exception_do (let: "r" := (GoAlloc Rose "r") in
    return: (#(W64 12))).

(* go: interfaces_complex.go:163:15 *)
Definition Rose__Genusⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "r" <>,
    exception_do (let: "r" := (GoAlloc Rose "r") in
    return: (#"Rosa"%go)).

(* go: interfaces_complex.go:167:16 *)
Definition Daisy__Petalsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "d" <>,
    exception_do (let: "d" := (GoAlloc Daisy "d") in
    return: (#(W64 5))).

(* go: interfaces_complex.go:168:16 *)
Definition Daisy__Genusⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "d" <>,
    exception_do (let: "d" := (GoAlloc Daisy "d") in
    return: (#"Bellis"%go)).

(* go: interfaces_complex.go:170:6 *)
Definition testPolymorphismInterfaceⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "l" := (GoAlloc (go.PointerType Lily) (GoZeroVal (go.PointerType Lily) #())) in
    let: "$r0" := (GoAlloc Lily (GoZeroVal Lily #())) in
    do:  ("l" <-[go.PointerType Lily] "$r0");;;
    let: "r" := (GoAlloc (go.PointerType Rose) (GoZeroVal (go.PointerType Rose) #())) in
    let: "$r0" := (GoAlloc Rose (GoZeroVal Rose #())) in
    do:  ("r" <-[go.PointerType Rose] "$r0");;;
    let: "d" := (GoAlloc (go.PointerType Daisy) (GoZeroVal (go.PointerType Daisy) #())) in
    let: "$r0" := (GoAlloc Daisy (GoZeroVal Daisy #())) in
    do:  ("d" <-[go.PointerType Daisy] "$r0");;;
    let: "f" := (GoAlloc (go.ArrayType 3 Flower) (GoZeroVal (go.ArrayType 3 Flower) #())) in
    let: "$r0" := (let: "$v0" := (![go.PointerType Lily] "l") in
    let: "$v1" := (![go.PointerType Rose] "r") in
    let: "$v2" := (![go.PointerType Daisy] "d") in
    CompositeLiteral (go.ArrayType 3 Flower) (LiteralValue [KeyedElement None (ElementExpression (go.PointerType Lily) "$v0"); KeyedElement None (ElementExpression (go.PointerType Rose) "$v1"); KeyedElement None (ElementExpression (go.PointerType Daisy) "$v2")])) in
    do:  ("f" <-[go.ArrayType 3 Flower] "$r0");;;
    return: (((MethodResolve Flower "Petals"%go (![Flower] (IndexRef (go.ArrayType 3 Flower) (![go.ArrayType 3 Flower] "f", #(W64 0))))) #()) =⟨go.uint64⟩ #(W64 3))).

(* go: interfaces_complex.go:178:6 *)
Definition testEmbeddingInterfaceⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "l" := (GoAlloc (go.PointerType Lily) (GoZeroVal (go.PointerType Lily) #())) in
    let: "$r0" := (GoAlloc Lily (GoZeroVal Lily #())) in
    do:  ("l" <-[go.PointerType Lily] "$r0");;;
    let: "r" := (GoAlloc (go.PointerType Rose) (GoZeroVal (go.PointerType Rose) #())) in
    let: "$r0" := (GoAlloc Rose (GoZeroVal Rose #())) in
    do:  ("r" <-[go.PointerType Rose] "$r0");;;
    let: "d" := (GoAlloc (go.PointerType Daisy) (GoZeroVal (go.PointerType Daisy) #())) in
    let: "$r0" := (GoAlloc Daisy (GoZeroVal Daisy #())) in
    do:  ("d" <-[go.PointerType Daisy] "$r0");;;
    let: "f" := (GoAlloc (go.ArrayType 3 Flora) (GoZeroVal (go.ArrayType 3 Flora) #())) in
    let: "$r0" := (let: "$v0" := (![go.PointerType Lily] "l") in
    let: "$v1" := (![go.PointerType Rose] "r") in
    let: "$v2" := (![go.PointerType Daisy] "d") in
    CompositeLiteral (go.ArrayType 3 Flora) (LiteralValue [KeyedElement None (ElementExpression (go.PointerType Lily) "$v0"); KeyedElement None (ElementExpression (go.PointerType Rose) "$v1"); KeyedElement None (ElementExpression (go.PointerType Daisy) "$v2")])) in
    do:  ("f" <-[go.ArrayType 3 Flora] "$r0");;;
    return: (((MethodResolve Flora "Petals"%go (![Flora] (IndexRef (go.ArrayType 3 Flora) (![go.ArrayType 3 Flora] "f", #(W64 0))))) #()) =⟨go.uint64⟩ #(W64 3))).

(* go: interfaces_complex.go:186:6 *)
Definition testDowncastInterfaceⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "l" := (GoAlloc Lily (GoZeroVal Lily #())) in
    let: "$r0" := (CompositeLiteral Lily (LiteralValue [])) in
    do:  ("l" <-[Lily] "$r0");;;
    let: "f" := (GoAlloc Flora (GoZeroVal Flora #())) in
    let: "$r0" := (Convert Lily Flora (![Lily] "l")) in
    do:  ("f" <-[Flora] "$r0");;;
    return: (((MethodResolve Flora "Petals"%go (![Flora] "f")) #()) =⟨go.uint64⟩ ((MethodResolve Flower "Petals"%go (TypeAssert Flower (![Flora] "f"))) #()))).

(* We can't interpret multithreaded code, so this just checks that
   locks are correctly interpreted

   go: lock.go:7:6 *)
Definition testsUseLocksⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "m" := (GoAlloc (go.PointerType sync.Mutex) (GoZeroVal (go.PointerType sync.Mutex) #())) in
    let: "$r0" := (GoAlloc sync.Mutex (GoZeroVal sync.Mutex #())) in
    do:  ("m" <-[go.PointerType sync.Mutex] "$r0");;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] "m")) #());;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] "m")) #());;;
    return: (#true)).

(* helpers

   go: loops.go:4:6 *)
Definition standardForLoopⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s",
    exception_do (let: "s" := (GoAlloc (go.SliceType go.uint64) "s") in
    let: "sumPtr" := (GoAlloc (go.PointerType go.uint64) (GoZeroVal (go.PointerType go.uint64) #())) in
    let: "$r0" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    do:  ("sumPtr" <-[go.PointerType go.uint64] "$r0");;;
    (let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (if: Convert go.untyped_bool go.bool ((![go.uint64] "i") <⟨go.uint64⟩ (Convert go.int go.uint64 (let: "$a0" := (![go.SliceType go.uint64] "s") in
      (FuncResolve go.len [go.SliceType go.uint64] #()) "$a0")))
      then
        let: "sum" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
        let: "$r0" := (![go.uint64] (![go.PointerType go.uint64] "sumPtr")) in
        do:  ("sum" <-[go.uint64] "$r0");;;
        let: "x" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
        let: "$r0" := (![go.uint64] (IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "s", Convert go.uint64 go.int (![go.uint64] "i")))) in
        do:  ("x" <-[go.uint64] "$r0");;;
        let: "$r0" := ((![go.uint64] "sum") +⟨go.uint64⟩ (![go.uint64] "x")) in
        do:  ((![go.PointerType go.uint64] "sumPtr") <-[go.uint64] "$r0");;;
        let: "$r0" := ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 1)) in
        do:  ("i" <-[go.uint64] "$r0");;;
        continue: #()
      else do:  #());;;
      break: #()));;;
    let: "sum" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (![go.uint64] (![go.PointerType go.uint64] "sumPtr")) in
    do:  ("sum" <-[go.uint64] "$r0");;;
    return: (![go.uint64] "sum")).

(* go: loops.go:28:22 *)
Definition LoopStruct__forLoopWaitⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "ls" "i",
    exception_do (let: "ls" := (GoAlloc LoopStruct "ls") in
    let: "i" := (GoAlloc go.uint64 "i") in
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "nxt" := (GoAlloc (go.PointerType go.uint64) (GoZeroVal (go.PointerType go.uint64) #())) in
      let: "$r0" := (![go.PointerType go.uint64] (StructFieldRef LoopStruct "loopNext"%go "ls")) in
      do:  ("nxt" <-[go.PointerType go.uint64] "$r0");;;
      (if: Convert go.untyped_bool go.bool ((![go.uint64] "i") <⟨go.uint64⟩ (![go.uint64] (![go.PointerType go.uint64] "nxt")))
      then break: #()
      else do:  #());;;
      let: "$r0" := ((![go.uint64] (![go.PointerType go.uint64] (StructFieldRef LoopStruct "loopNext"%go "ls"))) +⟨go.uint64⟩ #(W64 1)) in
      do:  ((![go.PointerType go.uint64] (StructFieldRef LoopStruct "loopNext"%go "ls")) <-[go.uint64] "$r0");;;
      continue: #());;;
    return: #()).

(* tests

   go: loops.go:40:6 *)
Definition testStandardForLoopⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "arr" := (GoAlloc (go.SliceType go.uint64) (GoZeroVal (go.SliceType go.uint64) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType go.uint64] #()) #(W64 4)) in
    do:  ("arr" <-[go.SliceType go.uint64] "$r0");;;
    do:  ((IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "arr", #(W64 0))) <-[go.uint64] ((![go.uint64] (IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "arr", #(W64 0)))) +⟨go.uint64⟩ #(W64 1)));;;
    do:  ((IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "arr", #(W64 1))) <-[go.uint64] ((![go.uint64] (IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "arr", #(W64 1)))) +⟨go.uint64⟩ #(W64 3)));;;
    do:  ((IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "arr", #(W64 2))) <-[go.uint64] ((![go.uint64] (IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "arr", #(W64 2)))) +⟨go.uint64⟩ #(W64 5)));;;
    do:  ((IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "arr", #(W64 3))) <-[go.uint64] ((![go.uint64] (IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "arr", #(W64 3)))) +⟨go.uint64⟩ #(W64 7)));;;
    return: ((let: "$a0" := (![go.SliceType go.uint64] "arr") in
     (FuncResolve standardForLoop [] #()) "$a0") =⟨go.uint64⟩ #(W64 16))).

(* go: loops.go:49:6 *)
Definition testForLoopWaitⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "ls" := (GoAlloc LoopStruct (GoZeroVal LoopStruct #())) in
    let: "$r0" := (let: "$v0" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    CompositeLiteral LoopStruct (LiteralValue [KeyedElement (Some (KeyField "loopNext"%go)) (ElementExpression (go.PointerType go.uint64) "$v0")])) in
    do:  ("ls" <-[LoopStruct] "$r0");;;
    do:  (let: "$a0" := #(W64 3) in
    (MethodResolve LoopStruct "forLoopWait"%go (![LoopStruct] "ls")) "$a0");;;
    return: ((![go.uint64] (![go.PointerType go.uint64] (StructFieldRef LoopStruct "loopNext"%go "ls"))) =⟨go.uint64⟩ #(W64 4))).

(* go: loops.go:59:6 *)
Definition testBreakFromLoopWithContinueⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (if: Convert go.untyped_bool go.bool #true
      then
        let: "$r0" := ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 1)) in
        do:  ("i" <-[go.uint64] "$r0");;;
        break: #()
      else do:  #());;;
      continue: #());;;
    return: ((![go.uint64] "i") =⟨go.uint64⟩ #(W64 1))).

(* go: loops.go:71:6 *)
Definition testBreakFromLoopNoContinueⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, (![go.uint64] "i") <⟨go.uint64⟩ #(W64 3)); (λ: <>, #()) := λ: <>,
      (if: Convert go.untyped_bool go.bool #true
      then
        let: "$r0" := ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 1)) in
        do:  ("i" <-[go.uint64] "$r0");;;
        break: #()
      else do:  #());;;
      let: "$r0" := ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 2)) in
      do:  ("i" <-[go.uint64] "$r0"));;;
    return: ((![go.uint64] "i") =⟨go.uint64⟩ #(W64 1))).

(* go: loops.go:83:6 *)
Definition testBreakFromLoopNoContinueDoubleⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, (![go.uint64] "i") <⟨go.uint64⟩ #(W64 3)); (λ: <>, #()) := λ: <>,
      (if: Convert go.untyped_bool go.bool ((![go.uint64] "i") =⟨go.uint64⟩ #(W64 1))
      then
        let: "$r0" := ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 1)) in
        do:  ("i" <-[go.uint64] "$r0");;;
        break: #()
      else do:  #());;;
      let: "$r0" := ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 2)) in
      do:  ("i" <-[go.uint64] "$r0");;;
      let: "$r0" := ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 2)) in
      do:  ("i" <-[go.uint64] "$r0"));;;
    return: ((![go.uint64] "i") =⟨go.uint64⟩ #(W64 4))).

(* go: loops.go:96:6 *)
Definition testBreakFromLoopForOnlyⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, (![go.uint64] "i") <⟨go.uint64⟩ #(W64 3)); (λ: <>, #()) := λ: <>,
      let: "$r0" := ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 2)) in
      do:  ("i" <-[go.uint64] "$r0"));;;
    return: ((![go.uint64] "i") =⟨go.uint64⟩ #(W64 4))).

(* go: loops.go:104:6 *)
Definition testBreakFromLoopAssignAndContinueⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, (![go.uint64] "i") <⟨go.uint64⟩ #(W64 3)); (λ: <>, #()) := λ: <>,
      (if: Convert go.untyped_bool go.bool #true
      then
        let: "$r0" := ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 1)) in
        do:  ("i" <-[go.uint64] "$r0");;;
        break: #()
      else do:  #());;;
      let: "$r0" := ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 2)) in
      do:  ("i" <-[go.uint64] "$r0");;;
      continue: #());;;
    return: ((![go.uint64] "i") =⟨go.uint64⟩ #(W64 1))).

(* go: loops.go:117:6 *)
Definition testNestedLoopsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "ok1" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #false in
    do:  ("ok1" <-[go.bool] "$r0");;;
    let: "ok2" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #false in
    do:  ("ok2" <-[go.bool] "$r0");;;
    (let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (let: "j" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: "$r0" := #(W64 0) in
      do:  ("j" <-[go.uint64] "$r0");;;
      (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
        (if: Convert go.untyped_bool go.bool ((![go.uint64] "j") >⟨go.uint64⟩ #(W64 5))
        then break: #()
        else do:  #());;;
        let: "$r0" := ((![go.uint64] "j") +⟨go.uint64⟩ #(W64 1)) in
        do:  ("j" <-[go.uint64] "$r0");;;
        let: "$r0" := ((![go.uint64] "j") =⟨go.uint64⟩ #(W64 6)) in
        do:  ("ok1" <-[go.bool] "$r0");;;
        continue: #()));;;
      let: "$r0" := ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 1)) in
      do:  ("i" <-[go.uint64] "$r0");;;
      let: "$r0" := ((![go.uint64] "i") =⟨go.uint64⟩ #(W64 1)) in
      do:  ("ok2" <-[go.bool] "$r0");;;
      break: #()));;;
    return: ((![go.bool] "ok1") && (![go.bool] "ok2"))).

(* go: loops.go:136:6 *)
Definition testNestedGoStyleLoopsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #false in
    do:  ("ok" <-[go.bool] "$r0");;;
    (let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, (![go.uint64] "i") <⟨go.uint64⟩ #(W64 10)); (λ: <>, do:  ("i" <-[go.uint64] ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 1)))) := λ: <>,
      (let: "j" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: "$r0" := #(W64 0) in
      do:  ("j" <-[go.uint64] "$r0");;;
      (for: (λ: <>, (![go.uint64] "j") <⟨go.uint64⟩ (![go.uint64] "i")); (λ: <>, do:  ("j" <-[go.uint64] ((![go.uint64] "j") +⟨go.uint64⟩ #(W64 1)))) := λ: <>,
        (if: Convert go.untyped_bool go.bool #true
        then break: #()
        else do:  #());;;
        continue: #()));;;
      let: "$r0" := ((![go.uint64] "i") =⟨go.uint64⟩ #(W64 9)) in
      do:  ("ok" <-[go.bool] "$r0")));;;
    return: (![go.bool] "ok")).

(* go: loops.go:150:6 *)
Definition testNestedGoStyleLoopsNoComparisonⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #false in
    do:  ("ok" <-[go.bool] "$r0");;;
    (let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, (![go.uint64] "i") <⟨go.uint64⟩ #(W64 10)); (λ: <>, do:  ("i" <-[go.uint64] ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 1)))) := λ: <>,
      (let: "j" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: "$r0" := #(W64 0) in
      do:  ("j" <-[go.uint64] "$r0");;;
      (for: (λ: <>, (![go.uint64] "j") <⟨go.uint64⟩ (![go.uint64] "i")); (λ: <>, do:  ("j" <-[go.uint64] ((![go.uint64] "j") +⟨go.uint64⟩ #(W64 1)))) := λ: <>,
        (if: Convert go.untyped_bool go.bool #true
        then break: #()
        else do:  #());;;
        continue: #()));;;
      let: "$r0" := ((![go.uint64] "i") =⟨go.uint64⟩ #(W64 9)) in
      do:  ("ok" <-[go.bool] "$r0")));;;
    return: (![go.bool] "ok")).

(* go: maps.go:3:6 *)
Definition IterateMapKeysⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "m",
    exception_do (let: "m" := (GoAlloc (go.MapType go.uint64 go.uint64) "m") in
    let: "sum" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$range" := (![go.MapType go.uint64 go.uint64] "m") in
    (let: "k" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    map.for_range go.uint64 go.uint64 "$range" (λ: "$key" "value",
      do:  ("k" <-[go.uint64] "$key");;;
      let: "$r0" := ((![go.uint64] "sum") +⟨go.uint64⟩ (![go.uint64] "k")) in
      do:  ("sum" <-[go.uint64] "$r0")));;;
    return: (![go.uint64] "sum")).

(* go: maps.go:11:6 *)
Definition IterateMapValuesⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "m",
    exception_do (let: "m" := (GoAlloc (go.MapType go.uint64 go.uint64) "m") in
    let: "sum" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$range" := (![go.MapType go.uint64 go.uint64] "m") in
    (let: "v" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    map.for_range go.uint64 go.uint64 "$range" (λ: "$key" "value",
      do:  ("v" <-[go.uint64] "$value");;;
      do:  "$key";;;
      let: "$r0" := ((![go.uint64] "sum") +⟨go.uint64⟩ (![go.uint64] "v")) in
      do:  ("sum" <-[go.uint64] "$r0")));;;
    return: (![go.uint64] "sum")).

(* go: maps.go:19:6 *)
Definition testIterateMapⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "m" := (GoAlloc (go.MapType go.uint64 go.uint64) (GoZeroVal (go.MapType go.uint64 go.uint64) #())) in
    let: "$r0" := ((FuncResolve go.make1 [go.MapType go.uint64 go.uint64] #()) #()) in
    do:  ("m" <-[go.MapType go.uint64 go.uint64] "$r0");;;
    let: "$r0" := #(W64 1) in
    do:  (map.insert go.uint64 (![go.MapType go.uint64 go.uint64] "m") #(W64 0) "$r0");;;
    let: "$r0" := #(W64 2) in
    do:  (map.insert go.uint64 (![go.MapType go.uint64 go.uint64] "m") #(W64 1) "$r0");;;
    let: "$r0" := #(W64 4) in
    do:  (map.insert go.uint64 (![go.MapType go.uint64 go.uint64] "m") #(W64 3) "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := (![go.MapType go.uint64 go.uint64] "m") in
    (FuncResolve IterateMapKeys [] #()) "$a0") =⟨go.uint64⟩ #(W64 4))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := (![go.MapType go.uint64 go.uint64] "m") in
    (FuncResolve IterateMapValues [] #()) "$a0") =⟨go.uint64⟩ #(W64 7))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    return: (![go.bool] "ok")).

(* go: maps.go:37:6 *)
Definition testMapSizeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "m" := (GoAlloc (go.MapType go.uint64 go.uint64) (GoZeroVal (go.MapType go.uint64 go.uint64) #())) in
    let: "$r0" := ((FuncResolve go.make1 [go.MapType go.uint64 go.uint64] #()) #()) in
    do:  ("m" <-[go.MapType go.uint64 go.uint64] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((Convert go.int go.uint64 (let: "$a0" := (![go.MapType go.uint64 go.uint64] "m") in
    (FuncResolve go.len [go.MapType go.uint64 go.uint64] #()) "$a0")) =⟨go.uint64⟩ #(W64 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := #(W64 1) in
    do:  (map.insert go.uint64 (![go.MapType go.uint64 go.uint64] "m") #(W64 0) "$r0");;;
    let: "$r0" := #(W64 2) in
    do:  (map.insert go.uint64 (![go.MapType go.uint64 go.uint64] "m") #(W64 1) "$r0");;;
    let: "$r0" := #(W64 4) in
    do:  (map.insert go.uint64 (![go.MapType go.uint64 go.uint64] "m") #(W64 3) "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((Convert go.int go.uint64 (let: "$a0" := (![go.MapType go.uint64 go.uint64] "m") in
    (FuncResolve go.len [go.MapType go.uint64 go.uint64] #()) "$a0")) =⟨go.uint64⟩ #(W64 3))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    return: (![go.bool] "ok")).

(* go: multiple_assign.go:3:6 *)
Definition multReturnTwoⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (#(W64 2), #(W64 3))).

(* go: multiple_assign.go:7:6 *)
Definition testAssignTwoⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 10) in
    do:  ("x" <-[go.uint64] "$r0");;;
    let: "y" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 15) in
    do:  ("y" <-[go.uint64] "$r0");;;
    let: ("$ret0", "$ret1") := ((FuncResolve multReturnTwo [] #()) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("x" <-[go.uint64] "$r0");;;
    do:  ("y" <-[go.uint64] "$r1");;;
    return: (((![go.uint64] "x") =⟨go.uint64⟩ #(W64 2)) && ((![go.uint64] "y") =⟨go.uint64⟩ #(W64 3)))).

(* go: multiple_assign.go:14:6 *)
Definition multReturnThreeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (#(W64 2), #true, #(W32 1))).

(* go: multiple_assign.go:18:6 *)
Definition testAssignThreeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 10) in
    do:  ("x" <-[go.uint64] "$r0");;;
    let: "y" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #false in
    do:  ("y" <-[go.bool] "$r0");;;
    let: "z" := (GoAlloc go.uint32 (GoZeroVal go.uint32 #())) in
    let: "$r0" := #(W32 15) in
    do:  ("z" <-[go.uint32] "$r0");;;
    let: (("$ret0", "$ret1"), "$ret2") := ((FuncResolve multReturnThree [] #()) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("x" <-[go.uint64] "$r0");;;
    do:  ("y" <-[go.bool] "$r1");;;
    do:  ("z" <-[go.uint32] "$r2");;;
    return: ((((![go.uint64] "x") =⟨go.uint64⟩ #(W64 2)) && ((![go.bool] "y") =⟨go.bool⟩ #true)) && ((![go.uint32] "z") =⟨go.uint32⟩ #(W32 1)))).

(* go: multiple_assign.go:26:6 *)
Definition testMultipleAssignToMapⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 10) in
    do:  ("x" <-[go.uint64] "$r0");;;
    let: "m" := (GoAlloc (go.MapType go.uint64 go.uint64) (GoZeroVal (go.MapType go.uint64 go.uint64) #())) in
    let: "$r0" := ((FuncResolve go.make1 [go.MapType go.uint64 go.uint64] #()) #()) in
    do:  ("m" <-[go.MapType go.uint64 go.uint64] "$r0");;;
    let: ("$ret0", "$ret1") := ((FuncResolve multReturnTwo [] #()) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("x" <-[go.uint64] "$r0");;;
    do:  (map.insert go.uint64 (![go.MapType go.uint64 go.uint64] "m") #(W64 0) "$r1");;;
    return: (((![go.uint64] "x") =⟨go.uint64⟩ #(W64 2)) && ((map.lookup1 go.uint64 go.uint64 (![go.MapType go.uint64 go.uint64] "m") #(W64 0)) =⟨go.uint64⟩ #(W64 3)))).

(* go: multiple_return.go:3:6 *)
Definition returnTwoⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (#(W64 2), #(W64 3))).

(* go: multiple_return.go:7:6 *)
Definition testReturnTwoⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "y" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "x" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: ("$ret0", "$ret1") := ((FuncResolve returnTwo [] #()) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("x" <-[go.uint64] "$r0");;;
    do:  ("y" <-[go.uint64] "$r1");;;
    return: (((![go.uint64] "x") =⟨go.uint64⟩ #(W64 2)) && ((![go.uint64] "y") =⟨go.uint64⟩ #(W64 3)))).

(* go: multiple_return.go:12:6 *)
Definition testAnonymousBindingⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "y" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: ("$ret0", "$ret1") := ((FuncResolve returnTwo [] #()) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  "$r0";;;
    do:  ("y" <-[go.uint64] "$r1");;;
    return: ((![go.uint64] "y") =⟨go.uint64⟩ #(W64 3))).

(* go: multiple_return.go:17:6 *)
Definition returnThreeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (#(W64 2), #true, #(W32 1))).

(* go: multiple_return.go:21:6 *)
Definition testReturnThreeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "z" := (GoAlloc go.uint32 (GoZeroVal go.uint32 #())) in
    let: "y" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "x" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: (("$ret0", "$ret1"), "$ret2") := ((FuncResolve returnThree [] #()) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("x" <-[go.uint64] "$r0");;;
    do:  ("y" <-[go.bool] "$r1");;;
    do:  ("z" <-[go.uint32] "$r2");;;
    return: ((((![go.uint64] "x") =⟨go.uint64⟩ #(W64 2)) && ((![go.bool] "y") =⟨go.bool⟩ #true)) && ((![go.uint32] "z") =⟨go.uint32⟩ #(W32 1)))).

(* go: multiple_return.go:26:6 *)
Definition returnFourⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (#(W64 2), #true, #(W32 1), #(W64 7))).

(* go: multiple_return.go:30:6 *)
Definition testReturnFourⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "w" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "z" := (GoAlloc go.uint32 (GoZeroVal go.uint32 #())) in
    let: "y" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "x" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: ((("$ret0", "$ret1"), "$ret2"), "$ret3") := ((FuncResolve returnFour [] #()) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    let: "$r3" := "$ret3" in
    do:  ("x" <-[go.uint64] "$r0");;;
    do:  ("y" <-[go.bool] "$r1");;;
    do:  ("z" <-[go.uint32] "$r2");;;
    do:  ("w" <-[go.uint64] "$r3");;;
    return: (((((![go.uint64] "x") =⟨go.uint64⟩ #(W64 2)) && ((![go.bool] "y") =⟨go.bool⟩ #true)) && ((![go.uint32] "z") =⟨go.uint32⟩ #(W32 1))) && ((![go.uint64] "w") =⟨go.uint64⟩ #(W64 7)))).

(* go: nil.go:3:6 *)
Definition testCompareSliceToNilⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "s" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 0)) in
    do:  ("s" <-[go.SliceType go.byte] "$r0");;;
    return: ((![go.SliceType go.byte] "s") ≠⟨go.SliceType go.byte⟩ (Convert go.untyped_nil (go.SliceType go.byte) UntypedNil))).

(* go: nil.go:8:6 *)
Definition testComparePointerToNilⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "s" := (GoAlloc (go.PointerType go.uint64) (GoZeroVal (go.PointerType go.uint64) #())) in
    let: "$r0" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    do:  ("s" <-[go.PointerType go.uint64] "$r0");;;
    return: ((![go.PointerType go.uint64] "s") ≠⟨go.PointerType go.uint64⟩ (Convert go.untyped_nil (go.PointerType go.uint64) UntypedNil))).

(* go: nil.go:13:6 *)
Definition testCompareNilToNilⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "s" := (GoAlloc (go.PointerType (go.PointerType go.uint64)) (GoZeroVal (go.PointerType (go.PointerType go.uint64)) #())) in
    let: "$r0" := (GoAlloc (go.PointerType go.uint64) (GoZeroVal (go.PointerType go.uint64) #())) in
    do:  ("s" <-[go.PointerType (go.PointerType go.uint64)] "$r0");;;
    return: ((![go.PointerType go.uint64] (![go.PointerType (go.PointerType go.uint64)] "s")) =⟨go.PointerType go.uint64⟩ (Convert go.untyped_nil (go.PointerType go.uint64) UntypedNil))).

(* go: nil.go:18:6 *)
Definition testComparePointerWrappedToNilⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "s" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 1)) in
    do:  ("s" <-[go.SliceType go.byte] "$r0");;;
    return: ((![go.SliceType go.byte] "s") ≠⟨go.SliceType go.byte⟩ (Convert go.untyped_nil (go.SliceType go.byte) UntypedNil))).

(* go: nil.go:24:6 *)
Definition testComparePointerWrappedDefaultToNilⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "s" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    return: ((![go.SliceType go.byte] "s") =⟨go.SliceType go.byte⟩ (Convert go.untyped_nil (go.SliceType go.byte) UntypedNil))).

(* go: nil.go:29:6 *)
Definition testInterfaceNilWithTypeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "isNil" := (GoAlloc go.any (GoZeroVal go.any #())) in
    let: "$r0" := (Convert go.untyped_nil go.any UntypedNil) in
    do:  ("isNil" <-[go.any] "$r0");;;
    let: "notNil" := (GoAlloc go.any (GoZeroVal go.any #())) in
    let: "$r0" := (Convert (go.PointerType go.string) go.any (Convert go.untyped_nil (go.PointerType go.string) UntypedNil)) in
    do:  ("notNil" <-[go.any] "$r0");;;
    return: ((((![go.any] "isNil") =⟨go.InterfaceType []⟩ (Convert go.untyped_nil (go.InterfaceType []) UntypedNil)) && ((![go.any] "notNil") ≠⟨go.InterfaceType []⟩ (Convert go.untyped_nil (go.InterfaceType []) UntypedNil))) && ((![go.any] "isNil") ≠⟨go.InterfaceType []⟩ (![go.any] "notNil")))).

(* helpers

   go: operations.go:4:6 *)
Definition reverseAssignOps64ⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x",
    exception_do (let: "x" := (GoAlloc go.uint64 "x") in
    let: "y" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    do:  ("y" <-[go.uint64] ((![go.uint64] "y") +⟨go.uint64⟩ (![go.uint64] "x")));;;
    do:  ("y" <-[go.uint64] ((![go.uint64] "y") -⟨go.uint64⟩ (![go.uint64] "x")));;;
    do:  ("y" <-[go.uint64] ((![go.uint64] "y") +⟨go.uint64⟩ #(W64 1)));;;
    do:  ("y" <-[go.uint64] ((![go.uint64] "y") -⟨go.uint64⟩ #(W64 1)));;;
    return: (![go.uint64] "y")).

(* go: operations.go:13:6 *)
Definition reverseAssignOps32ⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x",
    exception_do (let: "x" := (GoAlloc go.uint32 "x") in
    let: "y" := (GoAlloc go.uint32 (GoZeroVal go.uint32 #())) in
    do:  ("y" <-[go.uint32] ((![go.uint32] "y") +⟨go.uint32⟩ (![go.uint32] "x")));;;
    do:  ("y" <-[go.uint32] ((![go.uint32] "y") -⟨go.uint32⟩ (![go.uint32] "x")));;;
    do:  ("y" <-[go.uint32] ((![go.uint32] "y") +⟨go.uint32⟩ #(W32 1)));;;
    do:  ("y" <-[go.uint32] ((![go.uint32] "y") -⟨go.uint32⟩ #(W32 1)));;;
    return: (![go.uint32] "y")).

(* go: operations.go:22:6 *)
Definition add64Equalsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x" "y" "z",
    exception_do (let: "z" := (GoAlloc go.uint64 "z") in
    let: "y" := (GoAlloc go.uint64 "y") in
    let: "x" := (GoAlloc go.uint64 "x") in
    return: (((![go.uint64] "x") +⟨go.uint64⟩ (![go.uint64] "y")) =⟨go.uint64⟩ (![go.uint64] "z"))).

(* go: operations.go:26:6 *)
Definition sub64Equalsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x" "y" "z",
    exception_do (let: "z" := (GoAlloc go.uint64 "z") in
    let: "y" := (GoAlloc go.uint64 "y") in
    let: "x" := (GoAlloc go.uint64 "x") in
    return: (((![go.uint64] "x") -⟨go.uint64⟩ (![go.uint64] "y")) =⟨go.uint64⟩ (![go.uint64] "z"))).

(* tests

   go: operations.go:31:6 *)
Definition testReverseAssignOps64ⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W64 0) in
    (FuncResolve reverseAssignOps64 [] #()) "$a0") =⟨go.uint64⟩ #(W64 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W64 1) in
    (FuncResolve reverseAssignOps64 [] #()) "$a0") =⟨go.uint64⟩ #(W64 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W64 1231234) in
    (FuncResolve reverseAssignOps64 [] #()) "$a0") =⟨go.uint64⟩ #(W64 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W64 62206846038638762) in
    (FuncResolve reverseAssignOps64 [] #()) "$a0") =⟨go.uint64⟩ #(W64 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W64 9223372036854775808) in
    (FuncResolve reverseAssignOps64 [] #()) "$a0") =⟨go.uint64⟩ #(W64 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W64 140737488355328) in
    (FuncResolve reverseAssignOps64 [] #()) "$a0") =⟨go.uint64⟩ #(W64 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W64 1048576) in
    (FuncResolve reverseAssignOps64 [] #()) "$a0") =⟨go.uint64⟩ #(W64 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W64 262144) in
    (FuncResolve reverseAssignOps64 [] #()) "$a0") =⟨go.uint64⟩ #(W64 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W64 1024) in
    (FuncResolve reverseAssignOps64 [] #()) "$a0") =⟨go.uint64⟩ #(W64 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W64 1) in
    (FuncResolve reverseAssignOps64 [] #()) "$a0") =⟨go.uint64⟩ #(W64 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W64 18446744073709551615) in
    (FuncResolve reverseAssignOps64 [] #()) "$a0") =⟨go.uint64⟩ #(W64 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    return: (![go.bool] "ok")).

(* go: operations.go:47:6 *)
Definition failing_testReverseAssignOps32ⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W32 0) in
    (FuncResolve reverseAssignOps32 [] #()) "$a0") =⟨go.uint32⟩ #(W32 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W32 1) in
    (FuncResolve reverseAssignOps32 [] #()) "$a0") =⟨go.uint32⟩ #(W32 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W32 1231234) in
    (FuncResolve reverseAssignOps32 [] #()) "$a0") =⟨go.uint32⟩ #(W32 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W32 3434807466) in
    (FuncResolve reverseAssignOps32 [] #()) "$a0") =⟨go.uint32⟩ #(W32 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W32 1048576) in
    (FuncResolve reverseAssignOps32 [] #()) "$a0") =⟨go.uint32⟩ #(W32 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W32 262144) in
    (FuncResolve reverseAssignOps32 [] #()) "$a0") =⟨go.uint32⟩ #(W32 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W32 1024) in
    (FuncResolve reverseAssignOps32 [] #()) "$a0") =⟨go.uint32⟩ #(W32 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W32 1) in
    (FuncResolve reverseAssignOps32 [] #()) "$a0") =⟨go.uint32⟩ #(W32 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W32 4294967295) in
    (FuncResolve reverseAssignOps32 [] #()) "$a0") =⟨go.uint32⟩ #(W32 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    return: (![go.bool] "ok")).

(* go: operations.go:61:6 *)
Definition testAdd64Equalsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && (let: "$a0" := #(W64 2) in
    let: "$a1" := #(W64 3) in
    let: "$a2" := #(W64 5) in
    (FuncResolve add64Equals [] #()) "$a0" "$a1" "$a2")) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && (let: "$a0" := #(W64 18446744073709551615) in
    let: "$a1" := #(W64 1) in
    let: "$a2" := #(W64 0) in
    (FuncResolve add64Equals [] #()) "$a0" "$a1" "$a2")) in
    do:  ("ok" <-[go.bool] "$r0");;;
    return: (![go.bool] "ok")).

(* go: operations.go:68:6 *)
Definition testSub64Equalsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && (let: "$a0" := #(W64 2) in
    let: "$a1" := #(W64 1) in
    let: "$a2" := #(W64 1) in
    (FuncResolve sub64Equals [] #()) "$a0" "$a1" "$a2")) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && (let: "$a0" := #(W64 18446744073709551615) in
    let: "$a1" := #(W64 9223372036854775808) in
    let: "$a2" := #(W64 9223372036854775807) in
    (FuncResolve sub64Equals [] #()) "$a0" "$a1" "$a2")) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && (let: "$a0" := #(W64 2) in
    let: "$a1" := #(W64 8) in
    let: "$a2" := #(W64 18446744073709551610) in
    (FuncResolve sub64Equals [] #()) "$a0" "$a1" "$a2")) in
    do:  ("ok" <-[go.bool] "$r0");;;
    return: (![go.bool] "ok")).

(* go: operations.go:76:6 *)
Definition testDivisionPrecedenceⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "blockSize" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 4096) in
    do:  ("blockSize" <-[go.uint64] "$r0");;;
    let: "hdrmeta" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 8) in
    do:  ("hdrmeta" <-[go.uint64] "$r0");;;
    let: "hdraddrs" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (((![go.uint64] "blockSize") -⟨go.uint64⟩ (![go.uint64] "hdrmeta")) /⟨go.uint64⟩ #(W64 8)) in
    do:  ("hdraddrs" <-[go.uint64] "$r0");;;
    return: ((![go.uint64] "hdraddrs") =⟨go.uint64⟩ #(W64 511))).

(* go: operations.go:83:6 *)
Definition testModPrecedenceⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x1" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := #(W64 517) in
    do:  ("x1" <-[go.int] "$r0");;;
    let: "x2" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := #(W64 5) in
    do:  ("x2" <-[go.int] "$r0");;;
    return: (((![go.int] "x1") =⟨go.int⟩ #(W64 517)) && ((![go.int] "x2") =⟨go.int⟩ #(W64 5)))).

(* go: operations.go:89:6 *)
Definition testBitwiseOpsPrecedenceⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && #true) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && #true) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && #true) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && #true) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && #true) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && #true) in
    do:  ("ok" <-[go.bool] "$r0");;;
    return: (![go.bool] "ok")).

(* go: operations.go:102:6 *)
Definition testArithmeticShiftsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && #true) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && #true) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && #true) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && #true) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && #true) in
    do:  ("ok" <-[go.bool] "$r0");;;
    return: (![go.bool] "ok")).

(* go: operations.go:114:6 *)
Definition testBitAddAndⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "tid" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 17) in
    do:  ("tid" <-[go.uint64] "$r0");;;
    let: "n" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 16) in
    do:  ("n" <-[go.uint64] "$r0");;;
    return: ((((![go.uint64] "tid") +⟨go.uint64⟩ (![go.uint64] "n")) &⟨go.uint64⟩ (⟨go.bool⟩! ((![go.uint64] "n") -⟨go.uint64⟩ #(W64 1)))) =⟨go.uint64⟩ #(W64 32))).

(* go: operations.go:120:6 *)
Definition testManyParenthesesⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (#true)).

(* go: operations.go:124:6 *)
Definition testPlusTimesⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (#true)).

(* go: panic.go:3:6 *)
Definition shouldPanicⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"bad"%go) in
    (FuncResolve go.panic [] #()) "$a0");;;
    return: #()).

(* go: precedence.go:3:6 *)
Definition testOrCompareSimpleⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do ((if: Convert go.untyped_bool go.bool (#false || #true)
    then return: (#true)
    else do:  #());;;
    return: (#false)).

(* go: precedence.go:10:6 *)
Definition testOrCompareⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    (if: Convert go.untyped_bool go.bool (⟨go.bool⟩! (#false || #true))
    then
      let: "$r0" := #false in
      do:  ("ok" <-[go.bool] "$r0")
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool (#false || #false)
    then
      let: "$r0" := #false in
      do:  ("ok" <-[go.bool] "$r0")
    else do:  #());;;
    return: (![go.bool] "ok")).

(* go: precedence.go:22:6 *)
Definition testAndCompareⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    (if: Convert go.untyped_bool go.bool (#false && #true)
    then
      let: "$r0" := #false in
      do:  ("ok" <-[go.bool] "$r0")
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool (#true || #true)
    then do:  #()
    else
      let: "$r0" := #false in
      do:  ("ok" <-[go.bool] "$r0"));;;
    return: (![go.bool] "ok")).

(* go: precedence.go:34:6 *)
Definition testShiftModⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (#true)).

(* go: prims.go:9:6 *)
Definition testLinearizeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "m" := (GoAlloc (go.PointerType sync.Mutex) (GoZeroVal (go.PointerType sync.Mutex) #())) in
    let: "$r0" := (GoAlloc sync.Mutex (GoZeroVal sync.Mutex #())) in
    do:  ("m" <-[go.PointerType sync.Mutex] "$r0");;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] "m")) #());;;
    do:  ((FuncResolve primitive.Linearize [] #()) #());;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] "m")) #());;;
    return: (#true)).

(* go: shortcircuiting.go:11:6 *)
Definition CheckTrueⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "b",
    exception_do (let: "b" := (GoAlloc (go.PointerType BoolTest) "b") in
    do:  ((StructFieldRef BoolTest "tc"%go (![go.PointerType BoolTest] "b")) <-[go.uint64] ((![go.uint64] (StructFieldRef BoolTest "tc"%go (![go.PointerType BoolTest] "b"))) +⟨go.uint64⟩ #(W64 1)));;;
    return: (![go.bool] (StructFieldRef BoolTest "t"%go (![go.PointerType BoolTest] "b")))).

(* go: shortcircuiting.go:16:6 *)
Definition CheckFalseⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "b",
    exception_do (let: "b" := (GoAlloc (go.PointerType BoolTest) "b") in
    do:  ((StructFieldRef BoolTest "fc"%go (![go.PointerType BoolTest] "b")) <-[go.uint64] ((![go.uint64] (StructFieldRef BoolTest "fc"%go (![go.PointerType BoolTest] "b"))) +⟨go.uint64⟩ #(W64 1)));;;
    return: (![go.bool] (StructFieldRef BoolTest "f"%go (![go.PointerType BoolTest] "b")))).

(* tests

   go: shortcircuiting.go:22:6 *)
Definition testShortcircuitAndTFⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "b" := (GoAlloc (go.PointerType BoolTest) (GoZeroVal (go.PointerType BoolTest) #())) in
    let: "$r0" := (GoAlloc BoolTest (let: "$v0" := #true in
    let: "$v1" := #false in
    let: "$v2" := #(W64 0) in
    let: "$v3" := #(W64 0) in
    CompositeLiteral BoolTest (LiteralValue [KeyedElement (Some (KeyField "t"%go)) (ElementExpression go.bool "$v0"); KeyedElement (Some (KeyField "f"%go)) (ElementExpression go.bool "$v1"); KeyedElement (Some (KeyField "tc"%go)) (ElementExpression go.uint64 "$v2"); KeyedElement (Some (KeyField "fc"%go)) (ElementExpression go.uint64 "$v3")]))) in
    do:  ("b" <-[go.PointerType BoolTest] "$r0");;;
    (if: (let: "$a0" := (![go.PointerType BoolTest] "b") in
    (FuncResolve CheckTrue [] #()) "$a0") && (let: "$a0" := (![go.PointerType BoolTest] "b") in
    (FuncResolve CheckFalse [] #()) "$a0")
    then return: (#false)
    else do:  #());;;
    return: (((![go.uint64] (StructFieldRef BoolTest "tc"%go (![go.PointerType BoolTest] "b"))) =⟨go.uint64⟩ #(W64 1)) && ((![go.uint64] (StructFieldRef BoolTest "fc"%go (![go.PointerType BoolTest] "b"))) =⟨go.uint64⟩ #(W64 1)))).

(* go: shortcircuiting.go:31:6 *)
Definition testShortcircuitAndFTⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "b" := (GoAlloc (go.PointerType BoolTest) (GoZeroVal (go.PointerType BoolTest) #())) in
    let: "$r0" := (GoAlloc BoolTest (let: "$v0" := #true in
    let: "$v1" := #false in
    let: "$v2" := #(W64 0) in
    let: "$v3" := #(W64 0) in
    CompositeLiteral BoolTest (LiteralValue [KeyedElement (Some (KeyField "t"%go)) (ElementExpression go.bool "$v0"); KeyedElement (Some (KeyField "f"%go)) (ElementExpression go.bool "$v1"); KeyedElement (Some (KeyField "tc"%go)) (ElementExpression go.uint64 "$v2"); KeyedElement (Some (KeyField "fc"%go)) (ElementExpression go.uint64 "$v3")]))) in
    do:  ("b" <-[go.PointerType BoolTest] "$r0");;;
    (if: (let: "$a0" := (![go.PointerType BoolTest] "b") in
    (FuncResolve CheckFalse [] #()) "$a0") && (let: "$a0" := (![go.PointerType BoolTest] "b") in
    (FuncResolve CheckTrue [] #()) "$a0")
    then return: (#false)
    else do:  #());;;
    return: (((![go.uint64] (StructFieldRef BoolTest "tc"%go (![go.PointerType BoolTest] "b"))) =⟨go.uint64⟩ #(W64 0)) && ((![go.uint64] (StructFieldRef BoolTest "fc"%go (![go.PointerType BoolTest] "b"))) =⟨go.uint64⟩ #(W64 1)))).

(* go: shortcircuiting.go:40:6 *)
Definition testShortcircuitOrTFⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "b" := (GoAlloc (go.PointerType BoolTest) (GoZeroVal (go.PointerType BoolTest) #())) in
    let: "$r0" := (GoAlloc BoolTest (let: "$v0" := #true in
    let: "$v1" := #false in
    let: "$v2" := #(W64 0) in
    let: "$v3" := #(W64 0) in
    CompositeLiteral BoolTest (LiteralValue [KeyedElement (Some (KeyField "t"%go)) (ElementExpression go.bool "$v0"); KeyedElement (Some (KeyField "f"%go)) (ElementExpression go.bool "$v1"); KeyedElement (Some (KeyField "tc"%go)) (ElementExpression go.uint64 "$v2"); KeyedElement (Some (KeyField "fc"%go)) (ElementExpression go.uint64 "$v3")]))) in
    do:  ("b" <-[go.PointerType BoolTest] "$r0");;;
    (if: (let: "$a0" := (![go.PointerType BoolTest] "b") in
    (FuncResolve CheckTrue [] #()) "$a0") || (let: "$a0" := (![go.PointerType BoolTest] "b") in
    (FuncResolve CheckFalse [] #()) "$a0")
    then return: (((![go.uint64] (StructFieldRef BoolTest "tc"%go (![go.PointerType BoolTest] "b"))) =⟨go.uint64⟩ #(W64 1)) && ((![go.uint64] (StructFieldRef BoolTest "fc"%go (![go.PointerType BoolTest] "b"))) =⟨go.uint64⟩ #(W64 0)))
    else do:  #());;;
    return: (#false)).

(* go: shortcircuiting.go:48:6 *)
Definition testShortcircuitOrFTⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "b" := (GoAlloc (go.PointerType BoolTest) (GoZeroVal (go.PointerType BoolTest) #())) in
    let: "$r0" := (GoAlloc BoolTest (let: "$v0" := #true in
    let: "$v1" := #false in
    let: "$v2" := #(W64 0) in
    let: "$v3" := #(W64 0) in
    CompositeLiteral BoolTest (LiteralValue [KeyedElement (Some (KeyField "t"%go)) (ElementExpression go.bool "$v0"); KeyedElement (Some (KeyField "f"%go)) (ElementExpression go.bool "$v1"); KeyedElement (Some (KeyField "tc"%go)) (ElementExpression go.uint64 "$v2"); KeyedElement (Some (KeyField "fc"%go)) (ElementExpression go.uint64 "$v3")]))) in
    do:  ("b" <-[go.PointerType BoolTest] "$r0");;;
    (if: (let: "$a0" := (![go.PointerType BoolTest] "b") in
    (FuncResolve CheckFalse [] #()) "$a0") || (let: "$a0" := (![go.PointerType BoolTest] "b") in
    (FuncResolve CheckTrue [] #()) "$a0")
    then return: (((![go.uint64] (StructFieldRef BoolTest "tc"%go (![go.PointerType BoolTest] "b"))) =⟨go.uint64⟩ #(W64 1)) && ((![go.uint64] (StructFieldRef BoolTest "fc"%go (![go.PointerType BoolTest] "b"))) =⟨go.uint64⟩ #(W64 1)))
    else do:  #());;;
    return: (#false)).

(* go: slices.go:9:24 *)
Definition ArrayEditor__Advanceⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "ae" "arr" "next",
    exception_do (let: "ae" := (GoAlloc (go.PointerType ArrayEditor) "ae") in
    let: "next" := (GoAlloc go.uint64 "next") in
    let: "arr" := (GoAlloc (go.SliceType go.uint64) "arr") in
    do:  ((IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "arr", #(W64 0))) <-[go.uint64] ((![go.uint64] (IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "arr", #(W64 0)))) +⟨go.uint64⟩ #(W64 1)));;;
    let: "$r0" := (![go.uint64] (StructFieldRef ArrayEditor "next_val"%go (![go.PointerType ArrayEditor] "ae"))) in
    do:  ((IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] (StructFieldRef ArrayEditor "s"%go (![go.PointerType ArrayEditor] "ae")), #(W64 0))) <-[go.uint64] "$r0");;;
    let: "$r0" := (![go.uint64] "next") in
    do:  ((StructFieldRef ArrayEditor "next_val"%go (![go.PointerType ArrayEditor] "ae")) <-[go.uint64] "$r0");;;
    let: "$r0" := (let: "$s" := (![go.SliceType go.uint64] (StructFieldRef ArrayEditor "s"%go (![go.PointerType ArrayEditor] "ae"))) in
    Slice (go.SliceType go.uint64) ("$s", #(W64 1), FuncResolve go.len [go.SliceType go.uint64] #() (![go.SliceType go.uint64] (StructFieldRef ArrayEditor "s"%go (![go.PointerType ArrayEditor] "ae"))))) in
    do:  ((StructFieldRef ArrayEditor "s"%go (![go.PointerType ArrayEditor] "ae")) <-[go.SliceType go.uint64] "$r0");;;
    return: #()).

(* tests

   go: slices.go:17:6 *)
Definition testSliceOpsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc (go.SliceType go.uint64) (GoZeroVal (go.SliceType go.uint64) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType go.uint64] #()) #(W64 10)) in
    do:  ("x" <-[go.SliceType go.uint64] "$r0");;;
    let: "$r0" := #(W64 5) in
    do:  ((IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "x", #(W64 1))) <-[go.uint64] "$r0");;;
    let: "$r0" := #(W64 10) in
    do:  ((IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "x", #(W64 2))) <-[go.uint64] "$r0");;;
    let: "$r0" := #(W64 15) in
    do:  ((IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "x", #(W64 3))) <-[go.uint64] "$r0");;;
    let: "$r0" := #(W64 20) in
    do:  ((IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "x", #(W64 4))) <-[go.uint64] "$r0");;;
    let: "v1" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (![go.uint64] (IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "x", #(W64 2)))) in
    do:  ("v1" <-[go.uint64] "$r0");;;
    let: "v2" := (GoAlloc (go.SliceType go.uint64) (GoZeroVal (go.SliceType go.uint64) #())) in
    let: "$r0" := (let: "$s" := (![go.SliceType go.uint64] "x") in
    Slice (go.SliceType go.uint64) ("$s", #(W64 2), #(W64 3))) in
    do:  ("v2" <-[go.SliceType go.uint64] "$r0");;;
    let: "v3" := (GoAlloc (go.SliceType go.uint64) (GoZeroVal (go.SliceType go.uint64) #())) in
    let: "$r0" := (let: "$s" := (![go.SliceType go.uint64] "x") in
    Slice (go.SliceType go.uint64) ("$s", #(W64 0), #(W64 3))) in
    do:  ("v3" <-[go.SliceType go.uint64] "$r0");;;
    let: "v4" := (GoAlloc (go.PointerType go.uint64) (GoZeroVal (go.PointerType go.uint64) #())) in
    let: "$r0" := (IndexRef go.uint64 (![go.SliceType go.uint64] "x", #(W64 2))) in
    do:  ("v4" <-[go.PointerType go.uint64] "$r0");;;
    let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] "v1") =⟨go.uint64⟩ #(W64 10))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] (IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "v2", #(W64 0)))) =⟨go.uint64⟩ #(W64 10))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := (![go.SliceType go.uint64] "v2") in
    (FuncResolve go.len [go.SliceType go.uint64] #()) "$a0") =⟨go.int⟩ #(W64 1))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] (IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "v3", #(W64 1)))) =⟨go.uint64⟩ #(W64 5))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] (IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "v3", #(W64 2)))) =⟨go.uint64⟩ #(W64 10))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := (![go.SliceType go.uint64] "v3") in
    (FuncResolve go.len [go.SliceType go.uint64] #()) "$a0") =⟨go.int⟩ #(W64 3))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] (![go.PointerType go.uint64] "v4")) =⟨go.uint64⟩ #(W64 10))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    return: (![go.bool] "ok")).

(* go: slices.go:40:6 *)
Definition testSliceCapacityOpsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc (go.SliceType go.uint64) (GoZeroVal (go.SliceType go.uint64) #())) in
    let: "$r0" := ((FuncResolve go.make3 [go.SliceType go.uint64] #()) #(W64 0) #(W64 10)) in
    do:  ("x" <-[go.SliceType go.uint64] "$r0");;;
    let: "sub1" := (GoAlloc (go.SliceType go.uint64) (GoZeroVal (go.SliceType go.uint64) #())) in
    let: "$r0" := (let: "$s" := (![go.SliceType go.uint64] "x") in
    Slice (go.SliceType go.uint64) ("$s", #(W64 0), #(W64 6))) in
    do:  ("sub1" <-[go.SliceType go.uint64] "$r0");;;
    let: "$r0" := #(W64 1) in
    do:  ((IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "sub1", #(W64 0))) <-[go.uint64] "$r0");;;
    let: "sub2" := (GoAlloc (go.SliceType go.uint64) (GoZeroVal (go.SliceType go.uint64) #())) in
    let: "$r0" := (let: "$s" := (![go.SliceType go.uint64] "x") in
    Slice (go.SliceType go.uint64) ("$s", #(W64 2), #(W64 4))) in
    do:  ("sub2" <-[go.SliceType go.uint64] "$r0");;;
    let: "$r0" := #(W64 2) in
    do:  ((IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "sub2", #(W64 0))) <-[go.uint64] "$r0");;;
    let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := (![go.SliceType go.uint64] "sub1") in
    (FuncResolve go.len [go.SliceType go.uint64] #()) "$a0") =⟨go.int⟩ #(W64 6))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := (![go.SliceType go.uint64] "sub1") in
    (FuncResolve go.cap [go.SliceType go.uint64] #()) "$a0") =⟨go.int⟩ #(W64 10))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] (IndexRef (go.SliceType go.uint64) (let: "$s" := (![go.SliceType go.uint64] "x") in
     Slice (go.SliceType go.uint64) ("$s", #(W64 0), #(W64 10)), #(W64 0)))) =⟨go.uint64⟩ #(W64 1))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := (![go.SliceType go.uint64] "sub2") in
    (FuncResolve go.len [go.SliceType go.uint64] #()) "$a0") =⟨go.int⟩ #(W64 2))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := (![go.SliceType go.uint64] "sub2") in
    (FuncResolve go.cap [go.SliceType go.uint64] #()) "$a0") =⟨go.int⟩ #(W64 8))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] (IndexRef (go.SliceType go.uint64) (let: "$s" := (![go.SliceType go.uint64] "x") in
     Slice (go.SliceType go.uint64) ("$s", #(W64 0), #(W64 10)), #(W64 2)))) =⟨go.uint64⟩ #(W64 2))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    return: (![go.bool] "ok")).

(* go: slices.go:59:6 *)
Definition testOverwriteArrayⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "arr" := (GoAlloc (go.SliceType go.uint64) (GoZeroVal (go.SliceType go.uint64) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType go.uint64] #()) #(W64 4)) in
    do:  ("arr" <-[go.SliceType go.uint64] "$r0");;;
    let: "ae1" := (GoAlloc (go.PointerType ArrayEditor) (GoZeroVal (go.PointerType ArrayEditor) #())) in
    let: "$r0" := (GoAlloc ArrayEditor (let: "$v0" := (let: "$s" := (![go.SliceType go.uint64] "arr") in
    Slice (go.SliceType go.uint64) ("$s", #(W64 0), FuncResolve go.len [go.SliceType go.uint64] #() (![go.SliceType go.uint64] "arr"))) in
    let: "$v1" := #(W64 1) in
    CompositeLiteral ArrayEditor (LiteralValue [KeyedElement (Some (KeyField "s"%go)) (ElementExpression (go.SliceType go.uint64) "$v0"); KeyedElement (Some (KeyField "next_val"%go)) (ElementExpression go.uint64 "$v1")]))) in
    do:  ("ae1" <-[go.PointerType ArrayEditor] "$r0");;;
    let: "ae2" := (GoAlloc (go.PointerType ArrayEditor) (GoZeroVal (go.PointerType ArrayEditor) #())) in
    let: "$r0" := (GoAlloc ArrayEditor (let: "$v0" := (let: "$s" := (![go.SliceType go.uint64] "arr") in
    Slice (go.SliceType go.uint64) ("$s", #(W64 1), FuncResolve go.len [go.SliceType go.uint64] #() (![go.SliceType go.uint64] "arr"))) in
    let: "$v1" := #(W64 102) in
    CompositeLiteral ArrayEditor (LiteralValue [KeyedElement (Some (KeyField "s"%go)) (ElementExpression (go.SliceType go.uint64) "$v0"); KeyedElement (Some (KeyField "next_val"%go)) (ElementExpression go.uint64 "$v1")]))) in
    do:  ("ae2" <-[go.PointerType ArrayEditor] "$r0");;;
    do:  (let: "$a0" := (![go.SliceType go.uint64] "arr") in
    let: "$a1" := #(W64 103) in
    (MethodResolve (go.PointerType ArrayEditor) "Advance"%go (![go.PointerType ArrayEditor] "ae2")) "$a0" "$a1");;;
    do:  (let: "$a0" := (![go.SliceType go.uint64] "arr") in
    let: "$a1" := #(W64 104) in
    (MethodResolve (go.PointerType ArrayEditor) "Advance"%go (![go.PointerType ArrayEditor] "ae2")) "$a0" "$a1");;;
    do:  (let: "$a0" := (![go.SliceType go.uint64] "arr") in
    let: "$a1" := #(W64 105) in
    (MethodResolve (go.PointerType ArrayEditor) "Advance"%go (![go.PointerType ArrayEditor] "ae2")) "$a0" "$a1");;;
    do:  (let: "$a0" := (![go.SliceType go.uint64] "arr") in
    let: "$a1" := #(W64 2) in
    (MethodResolve (go.PointerType ArrayEditor) "Advance"%go (![go.PointerType ArrayEditor] "ae1")) "$a0" "$a1");;;
    do:  (let: "$a0" := (![go.SliceType go.uint64] "arr") in
    let: "$a1" := #(W64 3) in
    (MethodResolve (go.PointerType ArrayEditor) "Advance"%go (![go.PointerType ArrayEditor] "ae1")) "$a0" "$a1");;;
    do:  (let: "$a0" := (![go.SliceType go.uint64] "arr") in
    let: "$a1" := #(W64 4) in
    (MethodResolve (go.PointerType ArrayEditor) "Advance"%go (![go.PointerType ArrayEditor] "ae1")) "$a0" "$a1");;;
    do:  (let: "$a0" := (![go.SliceType go.uint64] "arr") in
    let: "$a1" := #(W64 5) in
    (MethodResolve (go.PointerType ArrayEditor) "Advance"%go (![go.PointerType ArrayEditor] "ae1")) "$a0" "$a1");;;
    (if: Convert go.untyped_bool go.bool (((((![go.uint64] (IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "arr", #(W64 0)))) +⟨go.uint64⟩ (![go.uint64] (IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "arr", #(W64 1))))) +⟨go.uint64⟩ (![go.uint64] (IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "arr", #(W64 2))))) +⟨go.uint64⟩ (![go.uint64] (IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "arr", #(W64 3))))) ≥⟨go.uint64⟩ #(W64 100))
    then return: (#false)
    else do:  #());;;
    return: (((![go.uint64] (IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "arr", #(W64 3)))) =⟨go.uint64⟩ #(W64 4)) && ((![go.uint64] (IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "arr", #(W64 0)))) =⟨go.uint64⟩ #(W64 4)))).

(* go: slices.go:80:6 *)
Definition testSliceLiteralⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "bytes" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (let: "$v0" := #(W8 1) in
    let: "$v1" := #(W8 2) in
    CompositeLiteral (go.SliceType go.byte) (LiteralValue [KeyedElement None (ElementExpression go.byte "$v0"); KeyedElement None (ElementExpression go.byte "$v1")])) in
    do:  ("bytes" <-[go.SliceType go.byte] "$r0");;;
    let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.byte] (IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "bytes", #(W64 0)))) =⟨go.byte⟩ #(W8 1))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "ints" := (GoAlloc (go.SliceType go.uint64) (GoZeroVal (go.SliceType go.uint64) #())) in
    let: "$r0" := (let: "$v0" := #(W64 1) in
    let: "$v1" := #(W64 2) in
    let: "$v2" := #(W64 3) in
    CompositeLiteral (go.SliceType go.uint64) (LiteralValue [KeyedElement None (ElementExpression go.uint64 "$v0"); KeyedElement None (ElementExpression go.uint64 "$v1"); KeyedElement None (ElementExpression go.uint64 "$v2")])) in
    do:  ("ints" <-[go.SliceType go.uint64] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] (IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "ints", #(W64 1)))) =⟨go.uint64⟩ #(W64 2))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    return: (![go.bool] "ok")).

(* go: slices.go:89:6 *)
Definition testSliceAppendⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "bytes" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 0)) in
    do:  ("bytes" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "bytes") in
    let: "$a1" := ((let: "$sl0" := #(W8 1) in
    CompositeLiteral (go.SliceType go.byte) (LiteralValue [KeyedElement None (ElementExpression go.byte "$sl0")]))) in
    (FuncResolve go.append [go.SliceType go.byte] #()) "$a0" "$a1") in
    do:  ("bytes" <-[go.SliceType go.byte] "$r0");;;
    let: "newBytes" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (let: "$v0" := #(W8 2) in
    let: "$v1" := #(W8 3) in
    CompositeLiteral (go.SliceType go.byte) (LiteralValue [KeyedElement None (ElementExpression go.byte "$v0"); KeyedElement None (ElementExpression go.byte "$v1")])) in
    do:  ("newBytes" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "bytes") in
    let: "$a1" := (![go.SliceType go.byte] "newBytes") in
    (FuncResolve go.append [go.SliceType go.byte] #()) "$a0" "$a1") in
    do:  ("bytes" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((Convert go.int go.uint64 (let: "$a0" := (![go.SliceType go.byte] "bytes") in
    (FuncResolve go.len [go.SliceType go.byte] #()) "$a0")) =⟨go.uint64⟩ #(W64 3))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.byte] (IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "bytes", #(W64 2)))) =⟨go.byte⟩ #(W8 3))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    return: (![go.bool] "ok")).

(* go: struct_pointers.go:14:17 *)
Definition Bar__mutateⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "bar" <>,
    exception_do (let: "bar" := (GoAlloc (go.PointerType Bar) "bar") in
    let: "$r0" := #(W64 2) in
    do:  ((StructFieldRef Bar "a"%go (![go.PointerType Bar] "bar")) <-[go.uint64] "$r0");;;
    let: "$r0" := #(W64 3) in
    do:  ((StructFieldRef Bar "b"%go (![go.PointerType Bar] "bar")) <-[go.uint64] "$r0");;;
    return: #()).

(* go: struct_pointers.go:19:17 *)
Definition Foo__mutateBarⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "foo" <>,
    exception_do (let: "foo" := (GoAlloc (go.PointerType Foo) "foo") in
    do:  ((MethodResolve (go.PointerType Bar) "mutate"%go (StructFieldRef Foo "bar"%go (![go.PointerType Foo] "foo"))) #());;;
    return: #()).

(* go: struct_pointers.go:23:6 *)
Definition testFooBarMutationⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc Foo (GoZeroVal Foo #())) in
    let: "$r0" := (let: "$v0" := (let: "$v0" := #(W64 0) in
    let: "$v1" := #(W64 0) in
    CompositeLiteral Bar (LiteralValue [KeyedElement (Some (KeyField "a"%go)) (ElementExpression go.uint64 "$v0"); KeyedElement (Some (KeyField "b"%go)) (ElementExpression go.uint64 "$v1")])) in
    CompositeLiteral Foo (LiteralValue [KeyedElement (Some (KeyField "bar"%go)) (ElementExpression Bar "$v0")])) in
    do:  ("x" <-[Foo] "$r0");;;
    do:  ((MethodResolve (go.PointerType Foo) "mutateBar"%go "x") #());;;
    return: ((![go.uint64] (StructFieldRef Bar "a"%go (StructFieldRef Foo "bar"%go "x"))) =⟨go.uint64⟩ #(W64 2))).

(* go: structs.go:14:6 *)
Definition NewSⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (GoAlloc S (let: "$v0" := #(W64 2) in
     let: "$v1" := (let: "$v0" := #(W64 1) in
     let: "$v1" := #(W64 2) in
     CompositeLiteral TwoInts (LiteralValue [KeyedElement (Some (KeyField "x"%go)) (ElementExpression go.uint64 "$v0"); KeyedElement (Some (KeyField "y"%go)) (ElementExpression go.uint64 "$v1")])) in
     let: "$v2" := #true in
     CompositeLiteral S (LiteralValue [KeyedElement (Some (KeyField "a"%go)) (ElementExpression go.uint64 "$v0"); KeyedElement (Some (KeyField "b"%go)) (ElementExpression TwoInts "$v1"); KeyedElement (Some (KeyField "c"%go)) (ElementExpression go.bool "$v2")])))).

(* go: structs.go:22:13 *)
Definition S__readAⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" <>,
    exception_do (let: "s" := (GoAlloc (go.PointerType S) "s") in
    return: (![go.uint64] (StructFieldRef S "a"%go (![go.PointerType S] "s")))).

(* go: structs.go:26:13 *)
Definition S__readBⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" <>,
    exception_do (let: "s" := (GoAlloc (go.PointerType S) "s") in
    return: (![TwoInts] (StructFieldRef S "b"%go (![go.PointerType S] "s")))).

(* go: structs.go:30:12 *)
Definition S__readBValⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" <>,
    exception_do (let: "s" := (GoAlloc S "s") in
    return: (![TwoInts] (StructFieldRef S "b"%go "s"))).

(* go: structs.go:34:13 *)
Definition S__updateBValXⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" "i",
    exception_do (let: "s" := (GoAlloc (go.PointerType S) "s") in
    let: "i" := (GoAlloc go.uint64 "i") in
    let: "$r0" := (![go.uint64] "i") in
    do:  ((StructFieldRef TwoInts "x"%go (StructFieldRef S "b"%go (![go.PointerType S] "s"))) <-[go.uint64] "$r0");;;
    return: #()).

(* go: structs.go:38:13 *)
Definition S__negateCⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" <>,
    exception_do (let: "s" := (GoAlloc (go.PointerType S) "s") in
    let: "$r0" := (⟨go.bool⟩! (![go.bool] (StructFieldRef S "c"%go (![go.PointerType S] "s")))) in
    do:  ((StructFieldRef S "c"%go (![go.PointerType S] "s")) <-[go.bool] "$r0");;;
    return: #()).

(* go: structs.go:42:6 *)
Definition testStructUpdatesⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "ns" := (GoAlloc (go.PointerType S) (GoZeroVal (go.PointerType S) #())) in
    let: "$r0" := ((FuncResolve NewS [] #()) #()) in
    do:  ("ns" <-[go.PointerType S] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && (((MethodResolve (go.PointerType S) "readA"%go (![go.PointerType S] "ns")) #()) =⟨go.uint64⟩ #(W64 2))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "b1" := (GoAlloc TwoInts (GoZeroVal TwoInts #())) in
    let: "$r0" := ((MethodResolve (go.PointerType S) "readB"%go (![go.PointerType S] "ns")) #()) in
    do:  ("b1" <-[TwoInts] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] (StructFieldRef TwoInts "x"%go "b1")) =⟨go.uint64⟩ #(W64 1))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    do:  ((MethodResolve (go.PointerType S) "negateC"%go (![go.PointerType S] "ns")) #());;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.bool] (StructFieldRef S "c"%go (![go.PointerType S] "ns"))) =⟨go.bool⟩ #false)) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := #(W64 3) in
    do:  ((StructFieldRef TwoInts "x"%go "b1") <-[go.uint64] "$r0");;;
    let: "b2" := (GoAlloc TwoInts (GoZeroVal TwoInts #())) in
    let: "$r0" := ((MethodResolve (go.PointerType S) "readB"%go (![go.PointerType S] "ns")) #()) in
    do:  ("b2" <-[TwoInts] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] (StructFieldRef TwoInts "x"%go "b2")) =⟨go.uint64⟩ #(W64 1))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "b3" := (GoAlloc (go.PointerType TwoInts) (GoZeroVal (go.PointerType TwoInts) #())) in
    let: "$r0" := (StructFieldRef S "b"%go (![go.PointerType S] "ns")) in
    do:  ("b3" <-[go.PointerType TwoInts] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] (StructFieldRef TwoInts "x"%go (![go.PointerType TwoInts] "b3"))) =⟨go.uint64⟩ #(W64 1))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    do:  (let: "$a0" := #(W64 4) in
    (MethodResolve (go.PointerType S) "updateBValX"%go (![go.PointerType S] "ns")) "$a0");;;
    let: "$r0" := ((![go.bool] "ok") && ((StructFieldGet TwoInts "x" ((MethodResolve (go.PointerType S) "readBVal"%go (![go.PointerType S] "ns")) #())) =⟨go.uint64⟩ #(W64 4))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    return: (![go.bool] "ok")).

(* go: structs.go:65:6 *)
Definition testNestedStructUpdatesⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "ns" := (GoAlloc (go.PointerType S) (GoZeroVal (go.PointerType S) #())) in
    let: "$r0" := ((FuncResolve NewS [] #()) #()) in
    do:  ("ns" <-[go.PointerType S] "$r0");;;
    let: "$r0" := #(W64 5) in
    do:  ((StructFieldRef TwoInts "x"%go (StructFieldRef S "b"%go (![go.PointerType S] "ns"))) <-[go.uint64] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] (StructFieldRef TwoInts "x"%go (StructFieldRef S "b"%go (![go.PointerType S] "ns")))) =⟨go.uint64⟩ #(W64 5))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((FuncResolve NewS [] #()) #()) in
    do:  ("ns" <-[go.PointerType S] "$r0");;;
    let: "p" := (GoAlloc (go.PointerType TwoInts) (GoZeroVal (go.PointerType TwoInts) #())) in
    let: "$r0" := (StructFieldRef S "b"%go (![go.PointerType S] "ns")) in
    do:  ("p" <-[go.PointerType TwoInts] "$r0");;;
    let: "$r0" := #(W64 5) in
    do:  ((StructFieldRef TwoInts "x"%go (![go.PointerType TwoInts] "p")) <-[go.uint64] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] (StructFieldRef TwoInts "x"%go (StructFieldRef S "b"%go (![go.PointerType S] "ns")))) =⟨go.uint64⟩ #(W64 5))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((FuncResolve NewS [] #()) #()) in
    do:  ("ns" <-[go.PointerType S] "$r0");;;
    let: "$r0" := (StructFieldRef S "b"%go (![go.PointerType S] "ns")) in
    do:  ("p" <-[go.PointerType TwoInts] "$r0");;;
    let: "$r0" := #(W64 5) in
    do:  ((StructFieldRef TwoInts "x"%go (StructFieldRef S "b"%go (![go.PointerType S] "ns"))) <-[go.uint64] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] (StructFieldRef TwoInts "x"%go (![go.PointerType TwoInts] "p"))) =⟨go.uint64⟩ #(W64 5))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((FuncResolve NewS [] #()) #()) in
    do:  ("ns" <-[go.PointerType S] "$r0");;;
    let: "$r0" := (StructFieldRef S "b"%go (![go.PointerType S] "ns")) in
    do:  ("p" <-[go.PointerType TwoInts] "$r0");;;
    let: "$r0" := #(W64 5) in
    do:  ((StructFieldRef TwoInts "x"%go (StructFieldRef S "b"%go (![go.PointerType S] "ns"))) <-[go.uint64] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] (StructFieldRef TwoInts "x"%go (![go.PointerType TwoInts] "p"))) =⟨go.uint64⟩ #(W64 5))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    return: (![go.bool] "ok")).

(* go: structs.go:90:6 *)
Definition testStructConstructionsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "p1" := (GoAlloc (go.PointerType TwoInts) (GoZeroVal (go.PointerType TwoInts) #())) in
    let: "p2" := (GoAlloc TwoInts (GoZeroVal TwoInts #())) in
    let: "p3" := (GoAlloc TwoInts (GoZeroVal TwoInts #())) in
    let: "$r0" := (let: "$v0" := #(W64 0) in
    let: "$v1" := #(W64 0) in
    CompositeLiteral TwoInts (LiteralValue [KeyedElement (Some (KeyField "y"%go)) (ElementExpression go.uint64 "$v0"); KeyedElement (Some (KeyField "x"%go)) (ElementExpression go.uint64 "$v1")])) in
    do:  ("p3" <-[TwoInts] "$r0");;;
    let: "p4" := (GoAlloc TwoInts (GoZeroVal TwoInts #())) in
    let: "$r0" := (let: "$v0" := #(W64 0) in
    let: "$v1" := #(W64 0) in
    CompositeLiteral TwoInts (LiteralValue [KeyedElement (Some (KeyField "x"%go)) (ElementExpression go.uint64 "$v0"); KeyedElement (Some (KeyField "y"%go)) (ElementExpression go.uint64 "$v1")])) in
    do:  ("p4" <-[TwoInts] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.PointerType TwoInts] "p1") =⟨go.PointerType TwoInts⟩ (Convert go.untyped_nil (go.PointerType TwoInts) UntypedNil))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := (GoAlloc TwoInts (GoZeroVal TwoInts #())) in
    do:  ("p1" <-[go.PointerType TwoInts] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![TwoInts] "p2") =⟨go.StructType [
      (go.FieldDecl "x"%go go.uint64);
      (go.FieldDecl "y"%go go.uint64)
    ]⟩ (![TwoInts] "p3"))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![TwoInts] "p3") =⟨go.StructType [
      (go.FieldDecl "x"%go go.uint64);
      (go.FieldDecl "y"%go go.uint64)
    ]⟩ (![TwoInts] "p4"))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![TwoInts] "p4") =⟨go.StructType [
      (go.FieldDecl "x"%go go.uint64);
      (go.FieldDecl "y"%go go.uint64)
    ]⟩ (![TwoInts] (![go.PointerType TwoInts] "p1")))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ("p4" ≠⟨go.PointerType TwoInts⟩ (![go.PointerType TwoInts] "p1"))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    return: (![go.bool] "ok")).

(* go: structs.go:109:6 *)
Definition testIncompleteStructⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "p1" := (GoAlloc TwoInts (GoZeroVal TwoInts #())) in
    let: "$r0" := (let: "$v0" := #(W64 0) in
    CompositeLiteral TwoInts (LiteralValue [KeyedElement (Some (KeyField "x"%go)) (ElementExpression go.uint64 "$v0")])) in
    do:  ("p1" <-[TwoInts] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] (StructFieldRef TwoInts "y"%go "p1")) =⟨go.uint64⟩ #(W64 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "p2" := (GoAlloc S (GoZeroVal S #())) in
    let: "$r0" := (let: "$v0" := #(W64 2) in
    CompositeLiteral S (LiteralValue [KeyedElement (Some (KeyField "a"%go)) (ElementExpression go.uint64 "$v0")])) in
    do:  ("p2" <-[S] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] (StructFieldRef TwoInts "x"%go (StructFieldRef S "b"%go "p2"))) =⟨go.uint64⟩ #(W64 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.bool] (StructFieldRef S "c"%go "p2")) =⟨go.bool⟩ #false)) in
    do:  ("ok" <-[go.bool] "$r0");;;
    return: (![go.bool] "ok")).

(* go: structs.go:126:6 *)
Definition testStoreInStructVarⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "p" := (GoAlloc StructWrap (GoZeroVal StructWrap #())) in
    let: "$r0" := (let: "$v0" := #(W64 0) in
    CompositeLiteral StructWrap (LiteralValue [KeyedElement (Some (KeyField "i"%go)) (ElementExpression go.uint64 "$v0")])) in
    do:  ("p" <-[StructWrap] "$r0");;;
    let: "$r0" := #(W64 5) in
    do:  ((StructFieldRef StructWrap "i"%go "p") <-[go.uint64] "$r0");;;
    return: ((![go.uint64] (StructFieldRef StructWrap "i"%go "p")) =⟨go.uint64⟩ #(W64 5))).

(* go: structs.go:132:6 *)
Definition testStoreInStructPointerVarⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "p" := (GoAlloc (go.PointerType StructWrap) (GoZeroVal (go.PointerType StructWrap) #())) in
    let: "$r0" := (GoAlloc StructWrap (GoZeroVal StructWrap #())) in
    do:  ("p" <-[go.PointerType StructWrap] "$r0");;;
    let: "$r0" := #(W64 5) in
    do:  ((StructFieldRef StructWrap "i"%go (![go.PointerType StructWrap] "p")) <-[go.uint64] "$r0");;;
    return: ((![go.uint64] (StructFieldRef StructWrap "i"%go (![go.PointerType StructWrap] "p"))) =⟨go.uint64⟩ #(W64 5))).

(* go: structs.go:138:6 *)
Definition testStoreCompositeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "p" := (GoAlloc (go.PointerType TwoInts) (GoZeroVal (go.PointerType TwoInts) #())) in
    let: "$r0" := (GoAlloc TwoInts (GoZeroVal TwoInts #())) in
    do:  ("p" <-[go.PointerType TwoInts] "$r0");;;
    let: "$r0" := (let: "$v0" := #(W64 3) in
    let: "$v1" := #(W64 4) in
    CompositeLiteral TwoInts (LiteralValue [KeyedElement (Some (KeyField "x"%go)) (ElementExpression go.uint64 "$v0"); KeyedElement (Some (KeyField "y"%go)) (ElementExpression go.uint64 "$v1")])) in
    do:  ((![go.PointerType TwoInts] "p") <-[TwoInts] "$r0");;;
    return: ((![go.uint64] (StructFieldRef TwoInts "y"%go (![go.PointerType TwoInts] "p"))) =⟨go.uint64⟩ #(W64 4))).

(* go: structs.go:144:6 *)
Definition testStoreSliceⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "p" := (GoAlloc (go.PointerType (go.SliceType go.uint64)) (GoZeroVal (go.PointerType (go.SliceType go.uint64)) #())) in
    let: "$r0" := (GoAlloc (go.SliceType go.uint64) (GoZeroVal (go.SliceType go.uint64) #())) in
    do:  ("p" <-[go.PointerType (go.SliceType go.uint64)] "$r0");;;
    let: "s" := (GoAlloc (go.SliceType go.uint64) (GoZeroVal (go.SliceType go.uint64) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType go.uint64] #()) #(W64 3)) in
    do:  ("s" <-[go.SliceType go.uint64] "$r0");;;
    let: "$r0" := (![go.SliceType go.uint64] "s") in
    do:  ((![go.PointerType (go.SliceType go.uint64)] "p") <-[go.SliceType go.uint64] "$r0");;;
    return: ((Convert go.int go.uint64 (let: "$a0" := (![go.SliceType go.uint64] (![go.PointerType (go.SliceType go.uint64)] "p")) in
     (FuncResolve go.len [go.SliceType go.uint64] #()) "$a0")) =⟨go.uint64⟩ #(W64 3))).

(* go: structs.go:155:6 *)
Definition testStructFieldFuncⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "a" := (GoAlloc (go.PointerType StructWithFunc) (GoZeroVal (go.PointerType StructWithFunc) #())) in
    let: "$r0" := (GoAlloc StructWithFunc (GoZeroVal StructWithFunc #())) in
    do:  ("a" <-[go.PointerType StructWithFunc] "$r0");;;
    let: "$r0" := (λ: "arg",
      exception_do (let: "arg" := (GoAlloc go.uint64 "arg") in
      return: ((![go.uint64] "arg") *⟨go.uint64⟩ #(W64 2)))
      ) in
    do:  ((StructFieldRef StructWithFunc "fn"%go (![go.PointerType StructWithFunc] "a")) <-[go.FunctionType (go.Signature [go.uint64] false [go.uint64])] "$r0");;;
    return: ((let: "$a0" := #(W64 10) in
     (![go.FunctionType (go.Signature [go.uint64] false [go.uint64])] (StructFieldRef StructWithFunc "fn"%go (![go.PointerType StructWithFunc] "a"))) "$a0") =⟨go.uint64⟩ #(W64 20))).

(* go: switch.go:3:6 *)
Definition testSwitchValⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("x" <-[go.uint64] "$r0");;;
    let: "$sw" := (![go.uint64] "x") in
    (if: "$sw" =⟨go.uint64⟩ #(W64 0)
    then return: (#true)
    else
      (if: "$sw" =⟨go.uint64⟩ #(W64 1)
      then return: (#false)
      else return: (#false)))).

(* go: switch.go:15:6 *)
Definition testSwitchMultipleⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("x" <-[go.uint64] "$r0");;;
    let: "$sw" := (![go.uint64] "x") in
    (if: ("$sw" =⟨go.uint64⟩ #(W64 1)) || ("$sw" =⟨go.uint64⟩ #(W64 10))
    then return: (#false)
    else
      (if: "$sw" =⟨go.uint64⟩ #(W64 0)
      then return: (#true)
      else do:  #()));;;
    return: (#false)).

(* go: switch.go:26:6 *)
Definition testSwitchDefaultTrueⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 1) in
    do:  ("x" <-[go.uint64] "$r0");;;
    let: "$sw" := #true in
    (if: "$sw" =⟨go.bool⟩ #false
    then return: (#false)
    else
      (if: "$sw" =⟨go.bool⟩ ((![go.uint64] "x") =⟨go.uint64⟩ #(W64 2))
      then return: (#false)
      else return: (#true)))).

(* go: switch.go:45:26 *)
Definition switchConcrete__markerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "c" <>,
    exception_do (let: "c" := (GoAlloc (go.PointerType switchConcrete) "c") in
    do:  #()).

(* go: switch.go:48:6 *)
Definition testSwitchConversionⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "v" := (GoAlloc (go.PointerType switchConcrete) (GoZeroVal (go.PointerType switchConcrete) #())) in
    let: "$r0" := (GoAlloc switchConcrete (CompositeLiteral switchConcrete (LiteralValue []))) in
    do:  ("v" <-[go.PointerType switchConcrete] "$r0");;;
    let: "x" := (GoAlloc switchInterface (GoZeroVal switchInterface #())) in
    let: "$r0" := (Convert (go.PointerType switchConcrete) switchInterface (![go.PointerType switchConcrete] "v")) in
    do:  ("x" <-[switchInterface] "$r0");;;
    let: "$sw" := (![switchInterface] "x") in
    (if: "$sw" =⟨switchInterface⟩ (Convert (go.PointerType switchConcrete) switchInterface (![go.PointerType switchConcrete] "v"))
    then do:  #()
    else return: (#false));;;
    let: "$sw" := (![go.PointerType switchConcrete] "v") in
    (if: (Convert (go.PointerType switchConcrete) switchInterface "$sw") =⟨switchInterface⟩ (![switchInterface] "x")
    then do:  #()
    else return: (#false));;;
    return: (#true)).

(* go: type_equality.go:3:6 *)
Definition TypesEqualⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} (T U : go.type) : val :=
  λ: <>,
    exception_do (let: "t" := (GoAlloc (go.PointerType T) (GoZeroVal (go.PointerType T) #())) in
    let: "u" := (GoAlloc (go.PointerType U) (GoZeroVal (go.PointerType U) #())) in
    return: ((Convert (go.PointerType T) go.any (![go.PointerType T] "t")) =⟨go.InterfaceType []⟩ (Convert (go.PointerType U) go.any (![go.PointerType U] "u")))).

(* go: type_equality.go:9:6 *)
Definition testPrimitiveTypesEqualⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (((((((FuncResolve TypesEqual [go.int; go.int] #()) #()) && (⟨go.bool⟩! ((FuncResolve TypesEqual [go.int; go.string] #()) #()))) && (⟨go.bool⟩! ((FuncResolve TypesEqual [go.int; go.uint32] #()) #()))) && (⟨go.bool⟩! ((FuncResolve TypesEqual [go.int; go.int64] #()) #()))) && (⟨go.bool⟩! ((FuncResolve TypesEqual [go.int; go.uint64] #()) #()))) && ((FuncResolve TypesEqual [go.FunctionType (go.Signature [] false [go.bool]); go.FunctionType (go.Signature [] false [go.bool])] #()) #()))).

(* go: type_equality.go:22:6 *)
Definition testDefinedStrTypesEqualⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: ((⟨go.bool⟩! ((FuncResolve TypesEqual [DefinedStr; go.string] #()) #())) && ((FuncResolve TypesEqual [DefinedStr; DefinedStr2] #()) #()))).

(* go: type_equality.go:32:6 *)
Definition testListTypesEqualⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (((FuncResolve TypesEqual [List go.int; List go.int] #()) #()) && (⟨go.bool⟩! ((FuncResolve TypesEqual [List go.int; List go.string] #()) #())))).

(* go: vars.go:3:6 *)
Definition testPointerAssignmentⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #true in
    do:  ("x" <-[go.bool] "$r0");;;
    return: (![go.bool] "x")).

(* go: vars.go:9:6 *)
Definition testAddressOfLocalⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #false in
    do:  ("x" <-[go.bool] "$r0");;;
    let: "xptr" := (GoAlloc (go.PointerType go.bool) (GoZeroVal (go.PointerType go.bool) #())) in
    let: "$r0" := "x" in
    do:  ("xptr" <-[go.PointerType go.bool] "$r0");;;
    let: "$r0" := #true in
    do:  ((![go.PointerType go.bool] "xptr") <-[go.bool] "$r0");;;
    return: ((![go.bool] "x") && (![go.bool] (![go.PointerType go.bool] "xptr")))).

(* go: vars.go:16:6 *)
Definition testAnonymousAssignⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "$r0" := (#(W64 1) +⟨go.uint64⟩ #(W64 2)) in
    do:  "$r0";;;
    return: (#true)).

(* go: wal.go:24:6 *)
Definition intToBlockⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "a",
    exception_do (let: "a" := (GoAlloc go.uint64 "a") in
    let: "b" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) disk.BlockSize) in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    do:  (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (![go.uint64] "a") in
    (MethodResolve binary.littleEndian "PutUint64"%go (![binary.littleEndian] (GlobalVarAddr binary.LittleEndian #()))) "$a0" "$a1");;;
    return: (![go.SliceType go.byte] "b")).

(* go: wal.go:30:6 *)
Definition blockToIntⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "v",
    exception_do (let: "v" := (GoAlloc disk.Block "v") in
    return: (let: "$a0" := (![disk.Block] "v") in
     (MethodResolve binary.littleEndian "Uint64"%go (![binary.littleEndian] (GlobalVarAddr binary.LittleEndian #()))) "$a0")).

(* New initializes a fresh log

   go: wal.go:35:6 *)
Definition Newⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "d" := (GoAlloc disk.Disk (GoZeroVal disk.Disk #())) in
    let: "$r0" := ((FuncResolve disk.Get [] #()) #()) in
    do:  ("d" <-[disk.Disk] "$r0");;;
    let: "diskSize" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := ((MethodResolve disk.Disk "Size"%go (![disk.Disk] "d")) #()) in
    do:  ("diskSize" <-[go.uint64] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "diskSize") ≤⟨go.uint64⟩ logLength)
    then
      do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"disk is too small to host log"%go) in
      (FuncResolve go.panic [] #()) "$a0")
    else do:  #());;;
    let: "cache" := (GoAlloc (go.MapType go.uint64 disk.Block) (GoZeroVal (go.MapType go.uint64 disk.Block) #())) in
    let: "$r0" := ((FuncResolve go.make1 [go.MapType go.uint64 disk.Block] #()) #()) in
    do:  ("cache" <-[go.MapType go.uint64 disk.Block] "$r0");;;
    let: "header" := (GoAlloc disk.Block (GoZeroVal disk.Block #())) in
    let: "$r0" := (let: "$a0" := #(W64 0) in
    (FuncResolve intToBlock [] #()) "$a0") in
    do:  ("header" <-[disk.Block] "$r0");;;
    do:  (let: "$a0" := #(W64 0) in
    let: "$a1" := (![disk.Block] "header") in
    (MethodResolve disk.Disk "Write"%go (![disk.Disk] "d")) "$a0" "$a1");;;
    let: "lengthPtr" := (GoAlloc (go.PointerType go.uint64) (GoZeroVal (go.PointerType go.uint64) #())) in
    let: "$r0" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    do:  ("lengthPtr" <-[go.PointerType go.uint64] "$r0");;;
    let: "$r0" := #(W64 0) in
    do:  ((![go.PointerType go.uint64] "lengthPtr") <-[go.uint64] "$r0");;;
    let: "l" := (GoAlloc (go.PointerType sync.Mutex) (GoZeroVal (go.PointerType sync.Mutex) #())) in
    let: "$r0" := (GoAlloc sync.Mutex (GoZeroVal sync.Mutex #())) in
    do:  ("l" <-[go.PointerType sync.Mutex] "$r0");;;
    return: (let: "$v0" := (![disk.Disk] "d") in
     let: "$v1" := (![go.MapType go.uint64 disk.Block] "cache") in
     let: "$v2" := (![go.PointerType go.uint64] "lengthPtr") in
     let: "$v3" := (![go.PointerType sync.Mutex] "l") in
     CompositeLiteral Log (LiteralValue [KeyedElement (Some (KeyField "d"%go)) (ElementExpression disk.Disk "$v0"); KeyedElement (Some (KeyField "cache"%go)) (ElementExpression (go.MapType go.uint64 disk.Block) "$v1"); KeyedElement (Some (KeyField "length"%go)) (ElementExpression (go.PointerType go.uint64) "$v2"); KeyedElement (Some (KeyField "l"%go)) (ElementExpression (go.PointerType sync.Mutex) "$v3")]))).

(* go: wal.go:50:14 *)
Definition Log__lockⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" <>,
    exception_do (let: "l" := (GoAlloc Log "l") in
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] (StructFieldRef Log "l"%go "l"))) #());;;
    return: #()).

(* go: wal.go:54:14 *)
Definition Log__unlockⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" <>,
    exception_do (let: "l" := (GoAlloc Log "l") in
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef Log "l"%go "l"))) #());;;
    return: #()).

(* BeginTxn allocates space for a new transaction in the log.

   Returns true if the allocation succeeded.

   go: wal.go:61:14 *)
Definition Log__BeginTxnⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" <>,
    exception_do (let: "l" := (GoAlloc Log "l") in
    do:  ((MethodResolve Log "lock"%go (![Log] "l")) #());;;
    let: "length" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (![go.uint64] (![go.PointerType go.uint64] (StructFieldRef Log "length"%go "l"))) in
    do:  ("length" <-[go.uint64] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "length") =⟨go.uint64⟩ #(W64 0))
    then
      do:  ((MethodResolve Log "unlock"%go (![Log] "l")) #());;;
      return: (#true)
    else do:  #());;;
    do:  ((MethodResolve Log "unlock"%go (![Log] "l")) #());;;
    return: (#false)).

(* Read from the logical disk.

   Reads must go through the log to return committed but un-applied writes.

   go: wal.go:75:14 *)
Definition Log__Readⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" "a",
    exception_do (let: "l" := (GoAlloc Log "l") in
    let: "a" := (GoAlloc go.uint64 "a") in
    do:  ((MethodResolve Log "lock"%go (![Log] "l")) #());;;
    let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "v" := (GoAlloc disk.Block (GoZeroVal disk.Block #())) in
    let: ("$ret0", "$ret1") := (map.lookup2 go.uint64 disk.Block (![go.MapType go.uint64 disk.Block] (StructFieldRef Log "cache"%go "l")) (![go.uint64] "a")) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("v" <-[disk.Block] "$r0");;;
    do:  ("ok" <-[go.bool] "$r1");;;
    (if: ![go.bool] "ok"
    then
      do:  ((MethodResolve Log "unlock"%go (![Log] "l")) #());;;
      return: (![disk.Block] "v")
    else do:  #());;;
    do:  ((MethodResolve Log "unlock"%go (![Log] "l")) #());;;
    let: "dv" := (GoAlloc disk.Block (GoZeroVal disk.Block #())) in
    let: "$r0" := (let: "$a0" := (logLength +⟨go.uint64⟩ (![go.uint64] "a")) in
    (MethodResolve disk.Disk "Read"%go (![disk.Disk] (StructFieldRef Log "d"%go "l"))) "$a0") in
    do:  ("dv" <-[disk.Block] "$r0");;;
    return: (![disk.Block] "dv")).

(* go: wal.go:88:14 *)
Definition Log__Sizeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" <>,
    exception_do (let: "l" := (GoAlloc Log "l") in
    let: "sz" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := ((MethodResolve disk.Disk "Size"%go (![disk.Disk] (StructFieldRef Log "d"%go "l"))) #()) in
    do:  ("sz" <-[go.uint64] "$r0");;;
    return: ((![go.uint64] "sz") -⟨go.uint64⟩ logLength)).

(* Write to the disk through the log.

   go: wal.go:95:14 *)
Definition Log__Writeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" "a" "v",
    exception_do (let: "l" := (GoAlloc Log "l") in
    let: "v" := (GoAlloc disk.Block "v") in
    let: "a" := (GoAlloc go.uint64 "a") in
    do:  ((MethodResolve Log "lock"%go (![Log] "l")) #());;;
    let: "length" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (![go.uint64] (![go.PointerType go.uint64] (StructFieldRef Log "length"%go "l"))) in
    do:  ("length" <-[go.uint64] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "length") ≥⟨go.uint64⟩ MaxTxnWrites)
    then
      do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"transaction is at capacity"%go) in
      (FuncResolve go.panic [] #()) "$a0")
    else do:  #());;;
    let: "aBlock" := (GoAlloc disk.Block (GoZeroVal disk.Block #())) in
    let: "$r0" := (let: "$a0" := (![go.uint64] "a") in
    (FuncResolve intToBlock [] #()) "$a0") in
    do:  ("aBlock" <-[disk.Block] "$r0");;;
    let: "nextAddr" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (#(W64 1) +⟨go.uint64⟩ (#(W64 2) *⟨go.uint64⟩ (![go.uint64] "length"))) in
    do:  ("nextAddr" <-[go.uint64] "$r0");;;
    do:  (let: "$a0" := (![go.uint64] "nextAddr") in
    let: "$a1" := (![disk.Block] "aBlock") in
    (MethodResolve disk.Disk "Write"%go (![disk.Disk] (StructFieldRef Log "d"%go "l"))) "$a0" "$a1");;;
    do:  (let: "$a0" := ((![go.uint64] "nextAddr") +⟨go.uint64⟩ #(W64 1)) in
    let: "$a1" := (![disk.Block] "v") in
    (MethodResolve disk.Disk "Write"%go (![disk.Disk] (StructFieldRef Log "d"%go "l"))) "$a0" "$a1");;;
    let: "$r0" := (![disk.Block] "v") in
    do:  (map.insert go.uint64 (![go.MapType go.uint64 disk.Block] (StructFieldRef Log "cache"%go "l")) (![go.uint64] "a") "$r0");;;
    let: "$r0" := ((![go.uint64] "length") +⟨go.uint64⟩ #(W64 1)) in
    do:  ((![go.PointerType go.uint64] (StructFieldRef Log "length"%go "l")) <-[go.uint64] "$r0");;;
    do:  ((MethodResolve Log "unlock"%go (![Log] "l")) #());;;
    return: #()).

(* Commit the current transaction.

   go: wal.go:111:14 *)
Definition Log__Commitⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" <>,
    exception_do (let: "l" := (GoAlloc Log "l") in
    do:  ((MethodResolve Log "lock"%go (![Log] "l")) #());;;
    let: "length" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (![go.uint64] (![go.PointerType go.uint64] (StructFieldRef Log "length"%go "l"))) in
    do:  ("length" <-[go.uint64] "$r0");;;
    do:  ((MethodResolve Log "unlock"%go (![Log] "l")) #());;;
    let: "header" := (GoAlloc disk.Block (GoZeroVal disk.Block #())) in
    let: "$r0" := (let: "$a0" := (![go.uint64] "length") in
    (FuncResolve intToBlock [] #()) "$a0") in
    do:  ("header" <-[disk.Block] "$r0");;;
    do:  (let: "$a0" := #(W64 0) in
    let: "$a1" := (![disk.Block] "header") in
    (MethodResolve disk.Disk "Write"%go (![disk.Disk] (StructFieldRef Log "d"%go "l"))) "$a0" "$a1");;;
    return: #()).

(* go: wal.go:120:6 *)
Definition getLogEntryⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "d" "logOffset",
    exception_do (let: "logOffset" := (GoAlloc go.uint64 "logOffset") in
    let: "d" := (GoAlloc disk.Disk "d") in
    let: "diskAddr" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (#(W64 1) +⟨go.uint64⟩ (#(W64 2) *⟨go.uint64⟩ (![go.uint64] "logOffset"))) in
    do:  ("diskAddr" <-[go.uint64] "$r0");;;
    let: "aBlock" := (GoAlloc disk.Block (GoZeroVal disk.Block #())) in
    let: "$r0" := (let: "$a0" := (![go.uint64] "diskAddr") in
    (MethodResolve disk.Disk "Read"%go (![disk.Disk] "d")) "$a0") in
    do:  ("aBlock" <-[disk.Block] "$r0");;;
    let: "a" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (let: "$a0" := (![disk.Block] "aBlock") in
    (FuncResolve blockToInt [] #()) "$a0") in
    do:  ("a" <-[go.uint64] "$r0");;;
    let: "v" := (GoAlloc disk.Block (GoZeroVal disk.Block #())) in
    let: "$r0" := (let: "$a0" := ((![go.uint64] "diskAddr") +⟨go.uint64⟩ #(W64 1)) in
    (MethodResolve disk.Disk "Read"%go (![disk.Disk] "d")) "$a0") in
    do:  ("v" <-[disk.Block] "$r0");;;
    return: (![go.uint64] "a", ![disk.Block] "v")).

(* applyLog assumes we are running sequentially

   go: wal.go:129:6 *)
Definition applyLogⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "d" "length",
    exception_do (let: "length" := (GoAlloc go.uint64 "length") in
    let: "d" := (GoAlloc disk.Disk "d") in
    (let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (if: Convert go.untyped_bool go.bool ((![go.uint64] "i") <⟨go.uint64⟩ (![go.uint64] "length"))
      then
        let: "v" := (GoAlloc disk.Block (GoZeroVal disk.Block #())) in
        let: "a" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
        let: ("$ret0", "$ret1") := (let: "$a0" := (![disk.Disk] "d") in
        let: "$a1" := (![go.uint64] "i") in
        (FuncResolve getLogEntry [] #()) "$a0" "$a1") in
        let: "$r0" := "$ret0" in
        let: "$r1" := "$ret1" in
        do:  ("a" <-[go.uint64] "$r0");;;
        do:  ("v" <-[disk.Block] "$r1");;;
        do:  (let: "$a0" := (logLength +⟨go.uint64⟩ (![go.uint64] "a")) in
        let: "$a1" := (![disk.Block] "v") in
        (MethodResolve disk.Disk "Write"%go (![disk.Disk] "d")) "$a0" "$a1");;;
        let: "$r0" := ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 1)) in
        do:  ("i" <-[go.uint64] "$r0");;;
        continue: #()
      else do:  #());;;
      break: #()));;;
    return: #()).

(* go: wal.go:140:6 *)
Definition clearLogⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "d",
    exception_do (let: "d" := (GoAlloc disk.Disk "d") in
    let: "header" := (GoAlloc disk.Block (GoZeroVal disk.Block #())) in
    let: "$r0" := (let: "$a0" := #(W64 0) in
    (FuncResolve intToBlock [] #()) "$a0") in
    do:  ("header" <-[disk.Block] "$r0");;;
    do:  (let: "$a0" := #(W64 0) in
    let: "$a1" := (![disk.Block] "header") in
    (MethodResolve disk.Disk "Write"%go (![disk.Disk] "d")) "$a0" "$a1");;;
    return: #()).

(* Apply all the committed transactions.

   Frees all the space in the log.

   go: wal.go:148:14 *)
Definition Log__Applyⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" <>,
    exception_do (let: "l" := (GoAlloc Log "l") in
    do:  ((MethodResolve Log "lock"%go (![Log] "l")) #());;;
    let: "length" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (![go.uint64] (![go.PointerType go.uint64] (StructFieldRef Log "length"%go "l"))) in
    do:  ("length" <-[go.uint64] "$r0");;;
    do:  (let: "$a0" := (![disk.Disk] (StructFieldRef Log "d"%go "l")) in
    let: "$a1" := (![go.uint64] "length") in
    (FuncResolve applyLog [] #()) "$a0" "$a1");;;
    do:  (let: "$a0" := (![disk.Disk] (StructFieldRef Log "d"%go "l")) in
    (FuncResolve clearLog [] #()) "$a0");;;
    let: "$r0" := #(W64 0) in
    do:  ((![go.PointerType go.uint64] (StructFieldRef Log "length"%go "l")) <-[go.uint64] "$r0");;;
    do:  ((MethodResolve Log "unlock"%go (![Log] "l")) #());;;
    return: #()).

(* Open recovers the log following a crash or shutdown

   go: wal.go:161:6 *)
Definition Openⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "d" := (GoAlloc disk.Disk (GoZeroVal disk.Disk #())) in
    let: "$r0" := ((FuncResolve disk.Get [] #()) #()) in
    do:  ("d" <-[disk.Disk] "$r0");;;
    let: "header" := (GoAlloc disk.Block (GoZeroVal disk.Block #())) in
    let: "$r0" := (let: "$a0" := #(W64 0) in
    (MethodResolve disk.Disk "Read"%go (![disk.Disk] "d")) "$a0") in
    do:  ("header" <-[disk.Block] "$r0");;;
    let: "length" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (let: "$a0" := (![disk.Block] "header") in
    (FuncResolve blockToInt [] #()) "$a0") in
    do:  ("length" <-[go.uint64] "$r0");;;
    do:  (let: "$a0" := (![disk.Disk] "d") in
    let: "$a1" := (![go.uint64] "length") in
    (FuncResolve applyLog [] #()) "$a0" "$a1");;;
    do:  (let: "$a0" := (![disk.Disk] "d") in
    (FuncResolve clearLog [] #()) "$a0");;;
    let: "cache" := (GoAlloc (go.MapType go.uint64 disk.Block) (GoZeroVal (go.MapType go.uint64 disk.Block) #())) in
    let: "$r0" := ((FuncResolve go.make1 [go.MapType go.uint64 disk.Block] #()) #()) in
    do:  ("cache" <-[go.MapType go.uint64 disk.Block] "$r0");;;
    let: "lengthPtr" := (GoAlloc (go.PointerType go.uint64) (GoZeroVal (go.PointerType go.uint64) #())) in
    let: "$r0" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    do:  ("lengthPtr" <-[go.PointerType go.uint64] "$r0");;;
    let: "$r0" := #(W64 0) in
    do:  ((![go.PointerType go.uint64] "lengthPtr") <-[go.uint64] "$r0");;;
    let: "l" := (GoAlloc (go.PointerType sync.Mutex) (GoZeroVal (go.PointerType sync.Mutex) #())) in
    let: "$r0" := (GoAlloc sync.Mutex (GoZeroVal sync.Mutex #())) in
    do:  ("l" <-[go.PointerType sync.Mutex] "$r0");;;
    return: (let: "$v0" := (![disk.Disk] "d") in
     let: "$v1" := (![go.MapType go.uint64 disk.Block] "cache") in
     let: "$v2" := (![go.PointerType go.uint64] "lengthPtr") in
     let: "$v3" := (![go.PointerType sync.Mutex] "l") in
     CompositeLiteral Log (LiteralValue [KeyedElement (Some (KeyField "d"%go)) (ElementExpression disk.Disk "$v0"); KeyedElement (Some (KeyField "cache"%go)) (ElementExpression (go.MapType go.uint64 disk.Block) "$v1"); KeyedElement (Some (KeyField "length"%go)) (ElementExpression (go.PointerType go.uint64) "$v2"); KeyedElement (Some (KeyField "l"%go)) (ElementExpression (go.PointerType sync.Mutex) "$v3")]))).

(* disabled since performance is quite poor

   go: wal.go:176:6 *)
Definition disabled_testWalⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "lg" := (GoAlloc Log (GoZeroVal Log #())) in
    let: "$r0" := ((FuncResolve New [] #()) #()) in
    do:  ("lg" <-[Log] "$r0");;;
    (if: (MethodResolve Log "BeginTxn"%go (![Log] "lg")) #()
    then
      do:  (let: "$a0" := #(W64 2) in
      let: "$a1" := (let: "$a0" := #(W64 11) in
      (FuncResolve intToBlock [] #()) "$a0") in
      (MethodResolve Log "Write"%go (![Log] "lg")) "$a0" "$a1")
    else do:  #());;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := (let: "$a0" := #(W64 2) in
    (MethodResolve Log "Read"%go (![Log] "lg")) "$a0") in
    (FuncResolve blockToInt [] #()) "$a0") =⟨go.uint64⟩ #(W64 11))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := (let: "$a0" := #(W64 0) in
    (MethodResolve disk.Disk "Read"%go (![disk.Disk] (StructFieldRef Log "d"%go "lg"))) "$a0") in
    (FuncResolve blockToInt [] #()) "$a0") =⟨go.uint64⟩ #(W64 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    do:  ((MethodResolve Log "Commit"%go (![Log] "lg")) #());;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := (let: "$a0" := #(W64 0) in
    (MethodResolve disk.Disk "Read"%go (![disk.Disk] (StructFieldRef Log "d"%go "lg"))) "$a0") in
    (FuncResolve blockToInt [] #()) "$a0") =⟨go.uint64⟩ #(W64 1))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    do:  ((MethodResolve Log "Apply"%go (![Log] "lg")) #());;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] (![go.PointerType go.uint64] (StructFieldRef Log "length"%go "lg"))) =⟨go.uint64⟩ #(W64 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    return: (![go.bool] "ok")).

#[global] Instance info' : PkgInfo pkg_id.semantics :=
{|
  pkg_imported_pkgs := [code.sync.pkg_id.sync; code.github_com.goose_lang.primitive.pkg_id.primitive; code.encoding.binary.pkg_id.binary; code.github_com.goose_lang.primitive.disk.pkg_id.disk]
|}.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init pkg_id.semantics (λ: <>,
      exception_do (do:  (disk.initialize' #());;;
      do:  (binary.initialize' #());;;
      do:  (primitive.initialize' #());;;
      do:  (sync.initialize' #()))
      ).

Module unit.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End unit.

Definition unit'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [

].
Program Definition unit'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (unit'fds_unsealed).
Global Instance equals_unfold_unit {ext : ffi_syntax} {go_gctx : GoGlobalContext} : unit'fds =→ unit'fds_unsealed.
Proof. rewrite /unit'fds seal_eq //. Qed.

Definition unitⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (unit'fds).

Class unit_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] unit_type_repr  :: go.TypeReprUnderlying unitⁱᵐᵖˡ unit.t;
  #[global] unit_underlying :: (unit) <u (unitⁱᵐᵖˡ);
}.

Module Editor.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  s' : slice.t;
  next_val' : w64;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End Editor.

Definition Editor'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "s"%go (go.SliceType go.uint64));
  (go.FieldDecl "next_val"%go go.uint64)
].
Program Definition Editor'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (Editor'fds_unsealed).
Global Instance equals_unfold_Editor {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Editor'fds =→ Editor'fds_unsealed.
Proof. rewrite /Editor'fds seal_eq //. Qed.

Definition Editorⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (Editor'fds).

Class Editor_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Editor_type_repr  :: go.TypeReprUnderlying Editorⁱᵐᵖˡ Editor.t;
  #[global] Editor_underlying :: (Editor) <u (Editorⁱᵐᵖˡ);
  #[global] Editor_get_s (x : Editor.t) :: ⟦StructFieldGet (Editorⁱᵐᵖˡ) "s", #x⟧ ⤳[under] #x.(Editor.s');
  #[global] Editor_set_s (x : Editor.t) y :: ⟦StructFieldSet (Editorⁱᵐᵖˡ) "s", (#x, #y)⟧ ⤳[under] #(x <|Editor.s' := y|>);
  #[global] Editor_get_next_val (x : Editor.t) :: ⟦StructFieldGet (Editorⁱᵐᵖˡ) "next_val", #x⟧ ⤳[under] #x.(Editor.next_val');
  #[global] Editor_set_next_val (x : Editor.t) y :: ⟦StructFieldSet (Editorⁱᵐᵖˡ) "next_val", (#x, #y)⟧ ⤳[under] #(x <|Editor.next_val' := y|>);
  #[global] Editor'ptr_AdvanceReturn_unfold :: MethodUnfold (go.PointerType (Editor)) "AdvanceReturn" (Editor__AdvanceReturnⁱᵐᵖˡ);
}.

Module Pair.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  x' : w64;
  y' : w64;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End Pair.

Definition Pair'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "x"%go go.uint64);
  (go.FieldDecl "y"%go go.uint64)
].
Program Definition Pair'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (Pair'fds_unsealed).
Global Instance equals_unfold_Pair {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Pair'fds =→ Pair'fds_unsealed.
Proof. rewrite /Pair'fds seal_eq //. Qed.

Definition Pairⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (Pair'fds).

Class Pair_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Pair_type_repr  :: go.TypeReprUnderlying Pairⁱᵐᵖˡ Pair.t;
  #[global] Pair_underlying :: (Pair) <u (Pairⁱᵐᵖˡ);
  #[global] Pair_get_x (x : Pair.t) :: ⟦StructFieldGet (Pairⁱᵐᵖˡ) "x", #x⟧ ⤳[under] #x.(Pair.x');
  #[global] Pair_set_x (x : Pair.t) y :: ⟦StructFieldSet (Pairⁱᵐᵖˡ) "x", (#x, #y)⟧ ⤳[under] #(x <|Pair.x' := y|>);
  #[global] Pair_get_y (x : Pair.t) :: ⟦StructFieldGet (Pairⁱᵐᵖˡ) "y", #x⟧ ⤳[under] #x.(Pair.y');
  #[global] Pair_set_y (x : Pair.t) y :: ⟦StructFieldSet (Pairⁱᵐᵖˡ) "y", (#x, #y)⟧ ⤳[under] #(x <|Pair.y' := y|>);
}.

Module Uint32.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := w32.
End def.
End Uint32.

Definition Uint32ⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.uint32.

Class Uint32_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Uint32_underlying :: (Uint32) <u (Uint32ⁱᵐᵖˡ);
}.

Module geometryInterface.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := interface.t.
End def.
End geometryInterface.

Definition geometryInterfaceⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.InterfaceType [go.MethodElem "Square"%go (go.Signature [] false [go.uint64]); go.MethodElem "Volume"%go (go.Signature [] false [go.uint64])].

Class geometryInterface_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] geometryInterface_underlying :: (geometryInterface) <u (geometryInterfaceⁱᵐᵖˡ);
}.

Module SquareStruct.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  Side' : w64;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End SquareStruct.

Definition SquareStruct'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "Side"%go go.uint64)
].
Program Definition SquareStruct'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (SquareStruct'fds_unsealed).
Global Instance equals_unfold_SquareStruct {ext : ffi_syntax} {go_gctx : GoGlobalContext} : SquareStruct'fds =→ SquareStruct'fds_unsealed.
Proof. rewrite /SquareStruct'fds seal_eq //. Qed.

Definition SquareStructⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (SquareStruct'fds).

Class SquareStruct_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] SquareStruct_type_repr  :: go.TypeReprUnderlying SquareStructⁱᵐᵖˡ SquareStruct.t;
  #[global] SquareStruct_underlying :: (SquareStruct) <u (SquareStructⁱᵐᵖˡ);
  #[global] SquareStruct_get_Side (x : SquareStruct.t) :: ⟦StructFieldGet (SquareStructⁱᵐᵖˡ) "Side", #x⟧ ⤳[under] #x.(SquareStruct.Side');
  #[global] SquareStruct_set_Side (x : SquareStruct.t) y :: ⟦StructFieldSet (SquareStructⁱᵐᵖˡ) "Side", (#x, #y)⟧ ⤳[under] #(x <|SquareStruct.Side' := y|>);
  #[global] SquareStruct_Square_unfold :: MethodUnfold (SquareStruct) "Square" (SquareStruct__Squareⁱᵐᵖˡ);
  #[global] SquareStruct_Volume_unfold :: MethodUnfold (SquareStruct) "Volume" (SquareStruct__Volumeⁱᵐᵖˡ);
  #[global] SquareStruct'ptr_Square_unfold :: MethodUnfold (go.PointerType (SquareStruct)) "Square" (λ: "$r", MethodResolve (SquareStruct) "Square" (![(SquareStruct)] "$r"));
  #[global] SquareStruct'ptr_Volume_unfold :: MethodUnfold (go.PointerType (SquareStruct)) "Volume" (λ: "$r", MethodResolve (SquareStruct) "Volume" (![(SquareStruct)] "$r"));
}.

Module NumStruct.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  Value' : w64;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End NumStruct.

Definition NumStruct'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "Value"%go go.int)
].
Program Definition NumStruct'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (NumStruct'fds_unsealed).
Global Instance equals_unfold_NumStruct {ext : ffi_syntax} {go_gctx : GoGlobalContext} : NumStruct'fds =→ NumStruct'fds_unsealed.
Proof. rewrite /NumStruct'fds seal_eq //. Qed.

Definition NumStructⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (NumStruct'fds).

Class NumStruct_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] NumStruct_type_repr  :: go.TypeReprUnderlying NumStructⁱᵐᵖˡ NumStruct.t;
  #[global] NumStruct_underlying :: (NumStruct) <u (NumStructⁱᵐᵖˡ);
  #[global] NumStruct_get_Value (x : NumStruct.t) :: ⟦StructFieldGet (NumStructⁱᵐᵖˡ) "Value", #x⟧ ⤳[under] #x.(NumStruct.Value');
  #[global] NumStruct_set_Value (x : NumStruct.t) y :: ⟦StructFieldSet (NumStructⁱᵐᵖˡ) "Value", (#x, #y)⟧ ⤳[under] #(x <|NumStruct.Value' := y|>);
}.

Module shapeInterface.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := interface.t.
End def.
End shapeInterface.

Definition shapeInterfaceⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.InterfaceType [go.MethodElem "describe"%go (go.Signature [] false [go.string])].

Class shapeInterface_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] shapeInterface_underlying :: (shapeInterface) <u (shapeInterfaceⁱᵐᵖˡ);
}.

Module polygonInterface.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := interface.t.
End def.
End polygonInterface.

Definition polygonInterfaceⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.InterfaceType [go.MethodElem "sides"%go (go.Signature [] false [go.uint64])].

Class polygonInterface_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] polygonInterface_underlying :: (polygonInterface) <u (polygonInterfaceⁱᵐᵖˡ);
}.

Module shapeStruct.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  Shape' : go_string;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End shapeStruct.

Definition shapeStruct'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "Shape"%go go.string)
].
Program Definition shapeStruct'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (shapeStruct'fds_unsealed).
Global Instance equals_unfold_shapeStruct {ext : ffi_syntax} {go_gctx : GoGlobalContext} : shapeStruct'fds =→ shapeStruct'fds_unsealed.
Proof. rewrite /shapeStruct'fds seal_eq //. Qed.

Definition shapeStructⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (shapeStruct'fds).

Class shapeStruct_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] shapeStruct_type_repr  :: go.TypeReprUnderlying shapeStructⁱᵐᵖˡ shapeStruct.t;
  #[global] shapeStruct_underlying :: (shapeStruct) <u (shapeStructⁱᵐᵖˡ);
  #[global] shapeStruct_get_Shape (x : shapeStruct.t) :: ⟦StructFieldGet (shapeStructⁱᵐᵖˡ) "Shape", #x⟧ ⤳[under] #x.(shapeStruct.Shape');
  #[global] shapeStruct_set_Shape (x : shapeStruct.t) y :: ⟦StructFieldSet (shapeStructⁱᵐᵖˡ) "Shape", (#x, #y)⟧ ⤳[under] #(x <|shapeStruct.Shape' := y|>);
  #[global] shapeStruct_describe_unfold :: MethodUnfold (shapeStruct) "describe" (shapeStruct__describeⁱᵐᵖˡ);
  #[global] shapeStruct'ptr_describe_unfold :: MethodUnfold (go.PointerType (shapeStruct)) "describe" (λ: "$r", MethodResolve (shapeStruct) "describe" (![(shapeStruct)] "$r"));
}.

Module polygonStruct.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  Shape' : go_string;
  Sides' : w64;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End polygonStruct.

Definition polygonStruct'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "Shape"%go go.string);
  (go.FieldDecl "Sides"%go go.uint64)
].
Program Definition polygonStruct'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (polygonStruct'fds_unsealed).
Global Instance equals_unfold_polygonStruct {ext : ffi_syntax} {go_gctx : GoGlobalContext} : polygonStruct'fds =→ polygonStruct'fds_unsealed.
Proof. rewrite /polygonStruct'fds seal_eq //. Qed.

Definition polygonStructⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (polygonStruct'fds).

Class polygonStruct_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] polygonStruct_type_repr  :: go.TypeReprUnderlying polygonStructⁱᵐᵖˡ polygonStruct.t;
  #[global] polygonStruct_underlying :: (polygonStruct) <u (polygonStructⁱᵐᵖˡ);
  #[global] polygonStruct_get_Shape (x : polygonStruct.t) :: ⟦StructFieldGet (polygonStructⁱᵐᵖˡ) "Shape", #x⟧ ⤳[under] #x.(polygonStruct.Shape');
  #[global] polygonStruct_set_Shape (x : polygonStruct.t) y :: ⟦StructFieldSet (polygonStructⁱᵐᵖˡ) "Shape", (#x, #y)⟧ ⤳[under] #(x <|polygonStruct.Shape' := y|>);
  #[global] polygonStruct_get_Sides (x : polygonStruct.t) :: ⟦StructFieldGet (polygonStructⁱᵐᵖˡ) "Sides", #x⟧ ⤳[under] #x.(polygonStruct.Sides');
  #[global] polygonStruct_set_Sides (x : polygonStruct.t) y :: ⟦StructFieldSet (polygonStructⁱᵐᵖˡ) "Sides", (#x, #y)⟧ ⤳[under] #(x <|polygonStruct.Sides' := y|>);
  #[global] polygonStruct_describe_unfold :: MethodUnfold (polygonStruct) "describe" (polygonStruct__describeⁱᵐᵖˡ);
  #[global] polygonStruct_sides_unfold :: MethodUnfold (polygonStruct) "sides" (polygonStruct__sidesⁱᵐᵖˡ);
  #[global] polygonStruct'ptr_describe_unfold :: MethodUnfold (go.PointerType (polygonStruct)) "describe" (λ: "$r", MethodResolve (polygonStruct) "describe" (![(polygonStruct)] "$r"));
  #[global] polygonStruct'ptr_sides_unfold :: MethodUnfold (go.PointerType (polygonStruct)) "sides" (λ: "$r", MethodResolve (polygonStruct) "sides" (![(polygonStruct)] "$r"));
}.

Module dogInterface.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := interface.t.
End def.
End dogInterface.

Definition dogInterfaceⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.InterfaceType [go.MethodElem "Name"%go (go.Signature [] false [go.string]); go.MethodElem "Speed"%go (go.Signature [] false [go.uint64])].

Class dogInterface_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] dogInterface_underlying :: (dogInterface) <u (dogInterfaceⁱᵐᵖˡ);
}.

Module catInterface.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := interface.t.
End def.
End catInterface.

Definition catInterfaceⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.InterfaceType [go.MethodElem "Name"%go (go.Signature [] false [go.string]); go.MethodElem "Weight"%go (go.Signature [] false [go.uint64])].

Class catInterface_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] catInterface_underlying :: (catInterface) <u (catInterfaceⁱᵐᵖˡ);
}.

Module Puppy.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := go_string.
End def.
End Puppy.

Definition Puppyⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.string.

Class Puppy_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Puppy_underlying :: (Puppy) <u (Puppyⁱᵐᵖˡ);
  #[global] Puppy_Name_unfold :: MethodUnfold (Puppy) "Name" (Puppy__Nameⁱᵐᵖˡ);
  #[global] Puppy_Speed_unfold :: MethodUnfold (Puppy) "Speed" (Puppy__Speedⁱᵐᵖˡ);
  #[global] Puppy'ptr_Name_unfold :: MethodUnfold (go.PointerType (Puppy)) "Name" (λ: "$r", MethodResolve (Puppy) "Name" (![(Puppy)] "$r"));
  #[global] Puppy'ptr_Speed_unfold :: MethodUnfold (go.PointerType (Puppy)) "Speed" (λ: "$r", MethodResolve (Puppy) "Speed" (![(Puppy)] "$r"));
}.

Module Kitten.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := go_string.
End def.
End Kitten.

Definition Kittenⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.string.

Class Kitten_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Kitten_underlying :: (Kitten) <u (Kittenⁱᵐᵖˡ);
  #[global] Kitten_Name_unfold :: MethodUnfold (Kitten) "Name" (Kitten__Nameⁱᵐᵖˡ);
  #[global] Kitten_Weight_unfold :: MethodUnfold (Kitten) "Weight" (Kitten__Weightⁱᵐᵖˡ);
  #[global] Kitten'ptr_Name_unfold :: MethodUnfold (go.PointerType (Kitten)) "Name" (λ: "$r", MethodResolve (Kitten) "Name" (![(Kitten)] "$r"));
  #[global] Kitten'ptr_Weight_unfold :: MethodUnfold (go.PointerType (Kitten)) "Weight" (λ: "$r", MethodResolve (Kitten) "Weight" (![(Kitten)] "$r"));
}.

Module printInterface.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := interface.t.
End def.
End printInterface.

Definition printInterfaceⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.InterfaceType [go.MethodElem "Assign"%go (go.Signature [go.string] false []); go.MethodElem "GetTitle"%go (go.Signature [] false [go.string])].

Class printInterface_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] printInterface_underlying :: (printInterface) <u (printInterfaceⁱᵐᵖˡ);
}.

Module PaperStruct.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  Title' : go_string;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End PaperStruct.

Definition PaperStruct'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "Title"%go go.string)
].
Program Definition PaperStruct'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (PaperStruct'fds_unsealed).
Global Instance equals_unfold_PaperStruct {ext : ffi_syntax} {go_gctx : GoGlobalContext} : PaperStruct'fds =→ PaperStruct'fds_unsealed.
Proof. rewrite /PaperStruct'fds seal_eq //. Qed.

Definition PaperStructⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (PaperStruct'fds).

Class PaperStruct_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] PaperStruct_type_repr  :: go.TypeReprUnderlying PaperStructⁱᵐᵖˡ PaperStruct.t;
  #[global] PaperStruct_underlying :: (PaperStruct) <u (PaperStructⁱᵐᵖˡ);
  #[global] PaperStruct_get_Title (x : PaperStruct.t) :: ⟦StructFieldGet (PaperStructⁱᵐᵖˡ) "Title", #x⟧ ⤳[under] #x.(PaperStruct.Title');
  #[global] PaperStruct_set_Title (x : PaperStruct.t) y :: ⟦StructFieldSet (PaperStructⁱᵐᵖˡ) "Title", (#x, #y)⟧ ⤳[under] #(x <|PaperStruct.Title' := y|>);
  #[global] PaperStruct'ptr_Assign_unfold :: MethodUnfold (go.PointerType (PaperStruct)) "Assign" (PaperStruct__Assignⁱᵐᵖˡ);
  #[global] PaperStruct'ptr_GetTitle_unfold :: MethodUnfold (go.PointerType (PaperStruct)) "GetTitle" (PaperStruct__GetTitleⁱᵐᵖˡ);
}.

Module Flower.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := interface.t.
End def.
End Flower.

Definition Flowerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.InterfaceType [go.MethodElem "Petals"%go (go.Signature [] false [go.uint64])].

Class Flower_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Flower_underlying :: (Flower) <u (Flowerⁱᵐᵖˡ);
}.

Module Flora.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := interface.t.
End def.
End Flora.

Definition Floraⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.InterfaceType [go.MethodElem "Genus"%go (go.Signature [] false [go.string]); go.TypeElem [go.TypeTerm Flower]].

Class Flora_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Flora_underlying :: (Flora) <u (Floraⁱᵐᵖˡ);
}.

Module Lily.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End Lily.

Definition Lily'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [

].
Program Definition Lily'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (Lily'fds_unsealed).
Global Instance equals_unfold_Lily {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Lily'fds =→ Lily'fds_unsealed.
Proof. rewrite /Lily'fds seal_eq //. Qed.

Definition Lilyⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (Lily'fds).

Class Lily_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Lily_type_repr  :: go.TypeReprUnderlying Lilyⁱᵐᵖˡ Lily.t;
  #[global] Lily_underlying :: (Lily) <u (Lilyⁱᵐᵖˡ);
  #[global] Lily_Genus_unfold :: MethodUnfold (Lily) "Genus" (Lily__Genusⁱᵐᵖˡ);
  #[global] Lily_Petals_unfold :: MethodUnfold (Lily) "Petals" (Lily__Petalsⁱᵐᵖˡ);
  #[global] Lily'ptr_Genus_unfold :: MethodUnfold (go.PointerType (Lily)) "Genus" (λ: "$r", MethodResolve (Lily) "Genus" (![(Lily)] "$r"));
  #[global] Lily'ptr_Petals_unfold :: MethodUnfold (go.PointerType (Lily)) "Petals" (λ: "$r", MethodResolve (Lily) "Petals" (![(Lily)] "$r"));
}.

Module Rose.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End Rose.

Definition Rose'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [

].
Program Definition Rose'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (Rose'fds_unsealed).
Global Instance equals_unfold_Rose {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Rose'fds =→ Rose'fds_unsealed.
Proof. rewrite /Rose'fds seal_eq //. Qed.

Definition Roseⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (Rose'fds).

Class Rose_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Rose_type_repr  :: go.TypeReprUnderlying Roseⁱᵐᵖˡ Rose.t;
  #[global] Rose_underlying :: (Rose) <u (Roseⁱᵐᵖˡ);
  #[global] Rose_Genus_unfold :: MethodUnfold (Rose) "Genus" (Rose__Genusⁱᵐᵖˡ);
  #[global] Rose_Petals_unfold :: MethodUnfold (Rose) "Petals" (Rose__Petalsⁱᵐᵖˡ);
  #[global] Rose'ptr_Genus_unfold :: MethodUnfold (go.PointerType (Rose)) "Genus" (λ: "$r", MethodResolve (Rose) "Genus" (![(Rose)] "$r"));
  #[global] Rose'ptr_Petals_unfold :: MethodUnfold (go.PointerType (Rose)) "Petals" (λ: "$r", MethodResolve (Rose) "Petals" (![(Rose)] "$r"));
}.

Module Daisy.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End Daisy.

Definition Daisy'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [

].
Program Definition Daisy'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (Daisy'fds_unsealed).
Global Instance equals_unfold_Daisy {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Daisy'fds =→ Daisy'fds_unsealed.
Proof. rewrite /Daisy'fds seal_eq //. Qed.

Definition Daisyⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (Daisy'fds).

Class Daisy_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Daisy_type_repr  :: go.TypeReprUnderlying Daisyⁱᵐᵖˡ Daisy.t;
  #[global] Daisy_underlying :: (Daisy) <u (Daisyⁱᵐᵖˡ);
  #[global] Daisy_Genus_unfold :: MethodUnfold (Daisy) "Genus" (Daisy__Genusⁱᵐᵖˡ);
  #[global] Daisy_Petals_unfold :: MethodUnfold (Daisy) "Petals" (Daisy__Petalsⁱᵐᵖˡ);
  #[global] Daisy'ptr_Genus_unfold :: MethodUnfold (go.PointerType (Daisy)) "Genus" (λ: "$r", MethodResolve (Daisy) "Genus" (![(Daisy)] "$r"));
  #[global] Daisy'ptr_Petals_unfold :: MethodUnfold (go.PointerType (Daisy)) "Petals" (λ: "$r", MethodResolve (Daisy) "Petals" (![(Daisy)] "$r"));
}.

Module LoopStruct.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  loopNext' : loc;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End LoopStruct.

Definition LoopStruct'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "loopNext"%go (go.PointerType go.uint64))
].
Program Definition LoopStruct'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (LoopStruct'fds_unsealed).
Global Instance equals_unfold_LoopStruct {ext : ffi_syntax} {go_gctx : GoGlobalContext} : LoopStruct'fds =→ LoopStruct'fds_unsealed.
Proof. rewrite /LoopStruct'fds seal_eq //. Qed.

Definition LoopStructⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (LoopStruct'fds).

Class LoopStruct_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] LoopStruct_type_repr  :: go.TypeReprUnderlying LoopStructⁱᵐᵖˡ LoopStruct.t;
  #[global] LoopStruct_underlying :: (LoopStruct) <u (LoopStructⁱᵐᵖˡ);
  #[global] LoopStruct_get_loopNext (x : LoopStruct.t) :: ⟦StructFieldGet (LoopStructⁱᵐᵖˡ) "loopNext", #x⟧ ⤳[under] #x.(LoopStruct.loopNext');
  #[global] LoopStruct_set_loopNext (x : LoopStruct.t) y :: ⟦StructFieldSet (LoopStructⁱᵐᵖˡ) "loopNext", (#x, #y)⟧ ⤳[under] #(x <|LoopStruct.loopNext' := y|>);
  #[global] LoopStruct_forLoopWait_unfold :: MethodUnfold (LoopStruct) "forLoopWait" (LoopStruct__forLoopWaitⁱᵐᵖˡ);
  #[global] LoopStruct'ptr_forLoopWait_unfold :: MethodUnfold (go.PointerType (LoopStruct)) "forLoopWait" (λ: "$r", MethodResolve (LoopStruct) "forLoopWait" (![(LoopStruct)] "$r"));
}.

Module BoolTest.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  t' : bool;
  f' : bool;
  tc' : w64;
  fc' : w64;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End BoolTest.

Definition BoolTest'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "t"%go go.bool);
  (go.FieldDecl "f"%go go.bool);
  (go.FieldDecl "tc"%go go.uint64);
  (go.FieldDecl "fc"%go go.uint64)
].
Program Definition BoolTest'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (BoolTest'fds_unsealed).
Global Instance equals_unfold_BoolTest {ext : ffi_syntax} {go_gctx : GoGlobalContext} : BoolTest'fds =→ BoolTest'fds_unsealed.
Proof. rewrite /BoolTest'fds seal_eq //. Qed.

Definition BoolTestⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (BoolTest'fds).

Class BoolTest_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] BoolTest_type_repr  :: go.TypeReprUnderlying BoolTestⁱᵐᵖˡ BoolTest.t;
  #[global] BoolTest_underlying :: (BoolTest) <u (BoolTestⁱᵐᵖˡ);
  #[global] BoolTest_get_t (x : BoolTest.t) :: ⟦StructFieldGet (BoolTestⁱᵐᵖˡ) "t", #x⟧ ⤳[under] #x.(BoolTest.t');
  #[global] BoolTest_set_t (x : BoolTest.t) y :: ⟦StructFieldSet (BoolTestⁱᵐᵖˡ) "t", (#x, #y)⟧ ⤳[under] #(x <|BoolTest.t' := y|>);
  #[global] BoolTest_get_f (x : BoolTest.t) :: ⟦StructFieldGet (BoolTestⁱᵐᵖˡ) "f", #x⟧ ⤳[under] #x.(BoolTest.f');
  #[global] BoolTest_set_f (x : BoolTest.t) y :: ⟦StructFieldSet (BoolTestⁱᵐᵖˡ) "f", (#x, #y)⟧ ⤳[under] #(x <|BoolTest.f' := y|>);
  #[global] BoolTest_get_tc (x : BoolTest.t) :: ⟦StructFieldGet (BoolTestⁱᵐᵖˡ) "tc", #x⟧ ⤳[under] #x.(BoolTest.tc');
  #[global] BoolTest_set_tc (x : BoolTest.t) y :: ⟦StructFieldSet (BoolTestⁱᵐᵖˡ) "tc", (#x, #y)⟧ ⤳[under] #(x <|BoolTest.tc' := y|>);
  #[global] BoolTest_get_fc (x : BoolTest.t) :: ⟦StructFieldGet (BoolTestⁱᵐᵖˡ) "fc", #x⟧ ⤳[under] #x.(BoolTest.fc');
  #[global] BoolTest_set_fc (x : BoolTest.t) y :: ⟦StructFieldSet (BoolTestⁱᵐᵖˡ) "fc", (#x, #y)⟧ ⤳[under] #(x <|BoolTest.fc' := y|>);
}.

Module ArrayEditor.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  s' : slice.t;
  next_val' : w64;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End ArrayEditor.

Definition ArrayEditor'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "s"%go (go.SliceType go.uint64));
  (go.FieldDecl "next_val"%go go.uint64)
].
Program Definition ArrayEditor'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (ArrayEditor'fds_unsealed).
Global Instance equals_unfold_ArrayEditor {ext : ffi_syntax} {go_gctx : GoGlobalContext} : ArrayEditor'fds =→ ArrayEditor'fds_unsealed.
Proof. rewrite /ArrayEditor'fds seal_eq //. Qed.

Definition ArrayEditorⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (ArrayEditor'fds).

Class ArrayEditor_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] ArrayEditor_type_repr  :: go.TypeReprUnderlying ArrayEditorⁱᵐᵖˡ ArrayEditor.t;
  #[global] ArrayEditor_underlying :: (ArrayEditor) <u (ArrayEditorⁱᵐᵖˡ);
  #[global] ArrayEditor_get_s (x : ArrayEditor.t) :: ⟦StructFieldGet (ArrayEditorⁱᵐᵖˡ) "s", #x⟧ ⤳[under] #x.(ArrayEditor.s');
  #[global] ArrayEditor_set_s (x : ArrayEditor.t) y :: ⟦StructFieldSet (ArrayEditorⁱᵐᵖˡ) "s", (#x, #y)⟧ ⤳[under] #(x <|ArrayEditor.s' := y|>);
  #[global] ArrayEditor_get_next_val (x : ArrayEditor.t) :: ⟦StructFieldGet (ArrayEditorⁱᵐᵖˡ) "next_val", #x⟧ ⤳[under] #x.(ArrayEditor.next_val');
  #[global] ArrayEditor_set_next_val (x : ArrayEditor.t) y :: ⟦StructFieldSet (ArrayEditorⁱᵐᵖˡ) "next_val", (#x, #y)⟧ ⤳[under] #(x <|ArrayEditor.next_val' := y|>);
  #[global] ArrayEditor'ptr_Advance_unfold :: MethodUnfold (go.PointerType (ArrayEditor)) "Advance" (ArrayEditor__Advanceⁱᵐᵖˡ);
}.

Module Bar.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  a' : w64;
  b' : w64;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End Bar.

Definition Bar'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "a"%go go.uint64);
  (go.FieldDecl "b"%go go.uint64)
].
Program Definition Bar'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (Bar'fds_unsealed).
Global Instance equals_unfold_Bar {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Bar'fds =→ Bar'fds_unsealed.
Proof. rewrite /Bar'fds seal_eq //. Qed.

Definition Barⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (Bar'fds).

Class Bar_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Bar_type_repr  :: go.TypeReprUnderlying Barⁱᵐᵖˡ Bar.t;
  #[global] Bar_underlying :: (Bar) <u (Barⁱᵐᵖˡ);
  #[global] Bar_get_a (x : Bar.t) :: ⟦StructFieldGet (Barⁱᵐᵖˡ) "a", #x⟧ ⤳[under] #x.(Bar.a');
  #[global] Bar_set_a (x : Bar.t) y :: ⟦StructFieldSet (Barⁱᵐᵖˡ) "a", (#x, #y)⟧ ⤳[under] #(x <|Bar.a' := y|>);
  #[global] Bar_get_b (x : Bar.t) :: ⟦StructFieldGet (Barⁱᵐᵖˡ) "b", #x⟧ ⤳[under] #x.(Bar.b');
  #[global] Bar_set_b (x : Bar.t) y :: ⟦StructFieldSet (Barⁱᵐᵖˡ) "b", (#x, #y)⟧ ⤳[under] #(x <|Bar.b' := y|>);
  #[global] Bar'ptr_mutate_unfold :: MethodUnfold (go.PointerType (Bar)) "mutate" (Bar__mutateⁱᵐᵖˡ);
}.

Module Foo.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  bar' : semantics.Bar.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End Foo.

Definition Foo'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "bar"%go Bar)
].
Program Definition Foo'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (Foo'fds_unsealed).
Global Instance equals_unfold_Foo {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Foo'fds =→ Foo'fds_unsealed.
Proof. rewrite /Foo'fds seal_eq //. Qed.

Definition Fooⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (Foo'fds).

Class Foo_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Foo_type_repr  :: go.TypeReprUnderlying Fooⁱᵐᵖˡ Foo.t;
  #[global] Foo_underlying :: (Foo) <u (Fooⁱᵐᵖˡ);
  #[global] Foo_get_bar (x : Foo.t) :: ⟦StructFieldGet (Fooⁱᵐᵖˡ) "bar", #x⟧ ⤳[under] #x.(Foo.bar');
  #[global] Foo_set_bar (x : Foo.t) y :: ⟦StructFieldSet (Fooⁱᵐᵖˡ) "bar", (#x, #y)⟧ ⤳[under] #(x <|Foo.bar' := y|>);
  #[global] Foo'ptr_mutateBar_unfold :: MethodUnfold (go.PointerType (Foo)) "mutateBar" (Foo__mutateBarⁱᵐᵖˡ);
}.

Module TwoInts.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  x' : w64;
  y' : w64;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End TwoInts.

Definition TwoInts'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "x"%go go.uint64);
  (go.FieldDecl "y"%go go.uint64)
].
Program Definition TwoInts'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (TwoInts'fds_unsealed).
Global Instance equals_unfold_TwoInts {ext : ffi_syntax} {go_gctx : GoGlobalContext} : TwoInts'fds =→ TwoInts'fds_unsealed.
Proof. rewrite /TwoInts'fds seal_eq //. Qed.

Definition TwoIntsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (TwoInts'fds).

Class TwoInts_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] TwoInts_type_repr  :: go.TypeReprUnderlying TwoIntsⁱᵐᵖˡ TwoInts.t;
  #[global] TwoInts_underlying :: (TwoInts) <u (TwoIntsⁱᵐᵖˡ);
  #[global] TwoInts_get_x (x : TwoInts.t) :: ⟦StructFieldGet (TwoIntsⁱᵐᵖˡ) "x", #x⟧ ⤳[under] #x.(TwoInts.x');
  #[global] TwoInts_set_x (x : TwoInts.t) y :: ⟦StructFieldSet (TwoIntsⁱᵐᵖˡ) "x", (#x, #y)⟧ ⤳[under] #(x <|TwoInts.x' := y|>);
  #[global] TwoInts_get_y (x : TwoInts.t) :: ⟦StructFieldGet (TwoIntsⁱᵐᵖˡ) "y", #x⟧ ⤳[under] #x.(TwoInts.y');
  #[global] TwoInts_set_y (x : TwoInts.t) y :: ⟦StructFieldSet (TwoIntsⁱᵐᵖˡ) "y", (#x, #y)⟧ ⤳[under] #(x <|TwoInts.y' := y|>);
}.

Module S.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  a' : w64;
  b' : semantics.TwoInts.t;
  c' : bool;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End S.

Definition S'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "a"%go go.uint64);
  (go.FieldDecl "b"%go TwoInts);
  (go.FieldDecl "c"%go go.bool)
].
Program Definition S'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (S'fds_unsealed).
Global Instance equals_unfold_S {ext : ffi_syntax} {go_gctx : GoGlobalContext} : S'fds =→ S'fds_unsealed.
Proof. rewrite /S'fds seal_eq //. Qed.

Definition Sⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (S'fds).

Class S_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] S_type_repr  :: go.TypeReprUnderlying Sⁱᵐᵖˡ S.t;
  #[global] S_underlying :: (S) <u (Sⁱᵐᵖˡ);
  #[global] S_get_a (x : S.t) :: ⟦StructFieldGet (Sⁱᵐᵖˡ) "a", #x⟧ ⤳[under] #x.(S.a');
  #[global] S_set_a (x : S.t) y :: ⟦StructFieldSet (Sⁱᵐᵖˡ) "a", (#x, #y)⟧ ⤳[under] #(x <|S.a' := y|>);
  #[global] S_get_b (x : S.t) :: ⟦StructFieldGet (Sⁱᵐᵖˡ) "b", #x⟧ ⤳[under] #x.(S.b');
  #[global] S_set_b (x : S.t) y :: ⟦StructFieldSet (Sⁱᵐᵖˡ) "b", (#x, #y)⟧ ⤳[under] #(x <|S.b' := y|>);
  #[global] S_get_c (x : S.t) :: ⟦StructFieldGet (Sⁱᵐᵖˡ) "c", #x⟧ ⤳[under] #x.(S.c');
  #[global] S_set_c (x : S.t) y :: ⟦StructFieldSet (Sⁱᵐᵖˡ) "c", (#x, #y)⟧ ⤳[under] #(x <|S.c' := y|>);
  #[global] S_readBVal_unfold :: MethodUnfold (S) "readBVal" (S__readBValⁱᵐᵖˡ);
  #[global] S'ptr_negateC_unfold :: MethodUnfold (go.PointerType (S)) "negateC" (S__negateCⁱᵐᵖˡ);
  #[global] S'ptr_readA_unfold :: MethodUnfold (go.PointerType (S)) "readA" (S__readAⁱᵐᵖˡ);
  #[global] S'ptr_readB_unfold :: MethodUnfold (go.PointerType (S)) "readB" (S__readBⁱᵐᵖˡ);
  #[global] S'ptr_readBVal_unfold :: MethodUnfold (go.PointerType (S)) "readBVal" (λ: "$r", MethodResolve (S) "readBVal" (![(S)] "$r"));
  #[global] S'ptr_updateBValX_unfold :: MethodUnfold (go.PointerType (S)) "updateBValX" (S__updateBValXⁱᵐᵖˡ);
}.

Module StructWrap.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  i' : w64;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End StructWrap.

Definition StructWrap'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "i"%go go.uint64)
].
Program Definition StructWrap'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (StructWrap'fds_unsealed).
Global Instance equals_unfold_StructWrap {ext : ffi_syntax} {go_gctx : GoGlobalContext} : StructWrap'fds =→ StructWrap'fds_unsealed.
Proof. rewrite /StructWrap'fds seal_eq //. Qed.

Definition StructWrapⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (StructWrap'fds).

Class StructWrap_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] StructWrap_type_repr  :: go.TypeReprUnderlying StructWrapⁱᵐᵖˡ StructWrap.t;
  #[global] StructWrap_underlying :: (StructWrap) <u (StructWrapⁱᵐᵖˡ);
  #[global] StructWrap_get_i (x : StructWrap.t) :: ⟦StructFieldGet (StructWrapⁱᵐᵖˡ) "i", #x⟧ ⤳[under] #x.(StructWrap.i');
  #[global] StructWrap_set_i (x : StructWrap.t) y :: ⟦StructFieldSet (StructWrapⁱᵐᵖˡ) "i", (#x, #y)⟧ ⤳[under] #(x <|StructWrap.i' := y|>);
}.

Module StructWithFunc.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  fn' : func.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End StructWithFunc.

Definition StructWithFunc'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "fn"%go (go.FunctionType (go.Signature [go.uint64] false [go.uint64])))
].
Program Definition StructWithFunc'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (StructWithFunc'fds_unsealed).
Global Instance equals_unfold_StructWithFunc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : StructWithFunc'fds =→ StructWithFunc'fds_unsealed.
Proof. rewrite /StructWithFunc'fds seal_eq //. Qed.

Definition StructWithFuncⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (StructWithFunc'fds).

Class StructWithFunc_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] StructWithFunc_type_repr  :: go.TypeReprUnderlying StructWithFuncⁱᵐᵖˡ StructWithFunc.t;
  #[global] StructWithFunc_underlying :: (StructWithFunc) <u (StructWithFuncⁱᵐᵖˡ);
  #[global] StructWithFunc_get_fn (x : StructWithFunc.t) :: ⟦StructFieldGet (StructWithFuncⁱᵐᵖˡ) "fn", #x⟧ ⤳[under] #x.(StructWithFunc.fn');
  #[global] StructWithFunc_set_fn (x : StructWithFunc.t) y :: ⟦StructFieldSet (StructWithFuncⁱᵐᵖˡ) "fn", (#x, #y)⟧ ⤳[under] #(x <|StructWithFunc.fn' := y|>);
}.

Module switchConcrete.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End switchConcrete.

Definition switchConcrete'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [

].
Program Definition switchConcrete'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (switchConcrete'fds_unsealed).
Global Instance equals_unfold_switchConcrete {ext : ffi_syntax} {go_gctx : GoGlobalContext} : switchConcrete'fds =→ switchConcrete'fds_unsealed.
Proof. rewrite /switchConcrete'fds seal_eq //. Qed.

Definition switchConcreteⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (switchConcrete'fds).

Class switchConcrete_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] switchConcrete_type_repr  :: go.TypeReprUnderlying switchConcreteⁱᵐᵖˡ switchConcrete.t;
  #[global] switchConcrete_underlying :: (switchConcrete) <u (switchConcreteⁱᵐᵖˡ);
  #[global] switchConcrete'ptr_marker_unfold :: MethodUnfold (go.PointerType (switchConcrete)) "marker" (switchConcrete__markerⁱᵐᵖˡ);
}.

Module switchInterface.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := interface.t.
End def.
End switchInterface.

Definition switchInterfaceⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.InterfaceType [go.MethodElem "marker"%go (go.Signature [] false [])].

Class switchInterface_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] switchInterface_underlying :: (switchInterface) <u (switchInterfaceⁱᵐᵖˡ);
}.

Module DefinedStr.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := go_string.
End def.
End DefinedStr.

Definition DefinedStrⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.string.

Class DefinedStr_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] DefinedStr_underlying :: (DefinedStr) <u (DefinedStrⁱᵐᵖˡ);
}.

Module List.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t {T : Type} :=
mk {
  X' : T;
  Next' : loc;
}.

#[global] Instance zero_val `{!ZeroVal T} : ZeroVal t := {| zero_val := mk T (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End List.

Definition List'fds_unsealed (T : go.type) {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "X"%go T);
  (go.FieldDecl "Next"%go (go.PointerType (List T)))
].
Program Definition List'fds (T : go.type) {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (List'fds_unsealed T).
Global Instance equals_unfold_List T {ext : ffi_syntax} {go_gctx : GoGlobalContext} : List'fds T =→ List'fds_unsealed T.
Proof. rewrite /List'fds seal_eq //. Qed.

Definition Listⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} (T : go.type) : go.type := go.StructType (List'fds T).

Class List_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] List_type_repr T T' `{!ZeroVal T'} `{!TypeRepr T T'} :: go.TypeReprUnderlying (Listⁱᵐᵖˡ T) (List.t T');
  #[global] List_underlying T :: (List T) <u (Listⁱᵐᵖˡ T);
  #[global] List_get_X T T' (x : List.t T') :: ⟦StructFieldGet (Listⁱᵐᵖˡ T) "X", #x⟧ ⤳[under] #x.(List.X');
  #[global] List_set_X T T' (x : List.t T') y :: ⟦StructFieldSet (Listⁱᵐᵖˡ T) "X", (#x, #y)⟧ ⤳[under] #(x <|List.X' := y|>);
  #[global] List_get_Next T T' (x : List.t T') :: ⟦StructFieldGet (Listⁱᵐᵖˡ T) "Next", #x⟧ ⤳[under] #x.(List.Next');
  #[global] List_set_Next T T' (x : List.t T') y :: ⟦StructFieldSet (Listⁱᵐᵖˡ T) "Next", (#x, #y)⟧ ⤳[under] #(x <|List.Next' := y|>);
}.

Module Log.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  d' : disk.Disk.t;
  l' : loc;
  cache' : map.t;
  length' : loc;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End Log.

Definition Log'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "d"%go disk.Disk);
  (go.FieldDecl "l"%go (go.PointerType sync.Mutex));
  (go.FieldDecl "cache"%go (go.MapType go.uint64 disk.Block));
  (go.FieldDecl "length"%go (go.PointerType go.uint64))
].
Program Definition Log'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (Log'fds_unsealed).
Global Instance equals_unfold_Log {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Log'fds =→ Log'fds_unsealed.
Proof. rewrite /Log'fds seal_eq //. Qed.

Definition Logⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (Log'fds).

Class Log_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Log_type_repr  :: go.TypeReprUnderlying Logⁱᵐᵖˡ Log.t;
  #[global] Log_underlying :: (Log) <u (Logⁱᵐᵖˡ);
  #[global] Log_get_d (x : Log.t) :: ⟦StructFieldGet (Logⁱᵐᵖˡ) "d", #x⟧ ⤳[under] #x.(Log.d');
  #[global] Log_set_d (x : Log.t) y :: ⟦StructFieldSet (Logⁱᵐᵖˡ) "d", (#x, #y)⟧ ⤳[under] #(x <|Log.d' := y|>);
  #[global] Log_get_l (x : Log.t) :: ⟦StructFieldGet (Logⁱᵐᵖˡ) "l", #x⟧ ⤳[under] #x.(Log.l');
  #[global] Log_set_l (x : Log.t) y :: ⟦StructFieldSet (Logⁱᵐᵖˡ) "l", (#x, #y)⟧ ⤳[under] #(x <|Log.l' := y|>);
  #[global] Log_get_cache (x : Log.t) :: ⟦StructFieldGet (Logⁱᵐᵖˡ) "cache", #x⟧ ⤳[under] #x.(Log.cache');
  #[global] Log_set_cache (x : Log.t) y :: ⟦StructFieldSet (Logⁱᵐᵖˡ) "cache", (#x, #y)⟧ ⤳[under] #(x <|Log.cache' := y|>);
  #[global] Log_get_length (x : Log.t) :: ⟦StructFieldGet (Logⁱᵐᵖˡ) "length", #x⟧ ⤳[under] #x.(Log.length');
  #[global] Log_set_length (x : Log.t) y :: ⟦StructFieldSet (Logⁱᵐᵖˡ) "length", (#x, #y)⟧ ⤳[under] #(x <|Log.length' := y|>);
  #[global] Log_Apply_unfold :: MethodUnfold (Log) "Apply" (Log__Applyⁱᵐᵖˡ);
  #[global] Log_BeginTxn_unfold :: MethodUnfold (Log) "BeginTxn" (Log__BeginTxnⁱᵐᵖˡ);
  #[global] Log_Commit_unfold :: MethodUnfold (Log) "Commit" (Log__Commitⁱᵐᵖˡ);
  #[global] Log_Read_unfold :: MethodUnfold (Log) "Read" (Log__Readⁱᵐᵖˡ);
  #[global] Log_Size_unfold :: MethodUnfold (Log) "Size" (Log__Sizeⁱᵐᵖˡ);
  #[global] Log_Write_unfold :: MethodUnfold (Log) "Write" (Log__Writeⁱᵐᵖˡ);
  #[global] Log_lock_unfold :: MethodUnfold (Log) "lock" (Log__lockⁱᵐᵖˡ);
  #[global] Log_unlock_unfold :: MethodUnfold (Log) "unlock" (Log__unlockⁱᵐᵖˡ);
  #[global] Log'ptr_Apply_unfold :: MethodUnfold (go.PointerType (Log)) "Apply" (λ: "$r", MethodResolve (Log) "Apply" (![(Log)] "$r"));
  #[global] Log'ptr_BeginTxn_unfold :: MethodUnfold (go.PointerType (Log)) "BeginTxn" (λ: "$r", MethodResolve (Log) "BeginTxn" (![(Log)] "$r"));
  #[global] Log'ptr_Commit_unfold :: MethodUnfold (go.PointerType (Log)) "Commit" (λ: "$r", MethodResolve (Log) "Commit" (![(Log)] "$r"));
  #[global] Log'ptr_Read_unfold :: MethodUnfold (go.PointerType (Log)) "Read" (λ: "$r", MethodResolve (Log) "Read" (![(Log)] "$r"));
  #[global] Log'ptr_Size_unfold :: MethodUnfold (go.PointerType (Log)) "Size" (λ: "$r", MethodResolve (Log) "Size" (![(Log)] "$r"));
  #[global] Log'ptr_Write_unfold :: MethodUnfold (go.PointerType (Log)) "Write" (λ: "$r", MethodResolve (Log) "Write" (![(Log)] "$r"));
  #[global] Log'ptr_lock_unfold :: MethodUnfold (go.PointerType (Log)) "lock" (λ: "$r", MethodResolve (Log) "lock" (![(Log)] "$r"));
  #[global] Log'ptr_unlock_unfold :: MethodUnfold (go.PointerType (Log)) "unlock" (λ: "$r", MethodResolve (Log) "unlock" (![(Log)] "$r"));
}.

Class Assumptions `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] unit_instance :: unit_Assumptions;
  #[global] Editor_instance :: Editor_Assumptions;
  #[global] Pair_instance :: Pair_Assumptions;
  #[global] Uint32_instance :: Uint32_Assumptions;
  #[global] geometryInterface_instance :: geometryInterface_Assumptions;
  #[global] SquareStruct_instance :: SquareStruct_Assumptions;
  #[global] NumStruct_instance :: NumStruct_Assumptions;
  #[global] shapeInterface_instance :: shapeInterface_Assumptions;
  #[global] polygonInterface_instance :: polygonInterface_Assumptions;
  #[global] shapeStruct_instance :: shapeStruct_Assumptions;
  #[global] polygonStruct_instance :: polygonStruct_Assumptions;
  #[global] dogInterface_instance :: dogInterface_Assumptions;
  #[global] catInterface_instance :: catInterface_Assumptions;
  #[global] Puppy_instance :: Puppy_Assumptions;
  #[global] Kitten_instance :: Kitten_Assumptions;
  #[global] printInterface_instance :: printInterface_Assumptions;
  #[global] PaperStruct_instance :: PaperStruct_Assumptions;
  #[global] Flower_instance :: Flower_Assumptions;
  #[global] Flora_instance :: Flora_Assumptions;
  #[global] Lily_instance :: Lily_Assumptions;
  #[global] Rose_instance :: Rose_Assumptions;
  #[global] Daisy_instance :: Daisy_Assumptions;
  #[global] LoopStruct_instance :: LoopStruct_Assumptions;
  #[global] BoolTest_instance :: BoolTest_Assumptions;
  #[global] ArrayEditor_instance :: ArrayEditor_Assumptions;
  #[global] Bar_instance :: Bar_Assumptions;
  #[global] Foo_instance :: Foo_Assumptions;
  #[global] TwoInts_instance :: TwoInts_Assumptions;
  #[global] S_instance :: S_Assumptions;
  #[global] StructWrap_instance :: StructWrap_Assumptions;
  #[global] StructWithFunc_instance :: StructWithFunc_Assumptions;
  #[global] switchConcrete_instance :: switchConcrete_Assumptions;
  #[global] switchInterface_instance :: switchInterface_Assumptions;
  #[global] DefinedStr_instance :: DefinedStr_Assumptions;
  #[global] List_instance :: List_Assumptions;
  #[global] Log_instance :: Log_Assumptions;
  #[global] findKey_unfold :: FuncUnfold findKey [] (findKeyⁱᵐᵖˡ);
  #[global] allocate_unfold :: FuncUnfold allocate [] (allocateⁱᵐᵖˡ);
  #[global] freeRange_unfold :: FuncUnfold freeRange [] (freeRangeⁱᵐᵖˡ);
  #[global] testAllocateDistinct_unfold :: FuncUnfold testAllocateDistinct [] (testAllocateDistinctⁱᵐᵖˡ);
  #[global] testAllocateFull_unfold :: FuncUnfold testAllocateFull [] (testAllocateFullⁱᵐᵖˡ);
  #[global] testExplicitBlockStmt_unfold :: FuncUnfold testExplicitBlockStmt [] (testExplicitBlockStmtⁱᵐᵖˡ);
  #[global] testMinUint64_unfold :: FuncUnfold testMinUint64 [] (testMinUint64ⁱᵐᵖˡ);
  #[global] testMaxUint64_unfold :: FuncUnfold testMaxUint64 [] (testMaxUint64ⁱᵐᵖˡ);
  #[global] adder_unfold :: FuncUnfold adder [] (adderⁱᵐᵖˡ);
  #[global] testClosureBasic_unfold :: FuncUnfold testClosureBasic [] (testClosureBasicⁱᵐᵖˡ);
  #[global] testCompareAll_unfold :: FuncUnfold testCompareAll [] (testCompareAllⁱᵐᵖˡ);
  #[global] testCompareGT_unfold :: FuncUnfold testCompareGT [] (testCompareGTⁱᵐᵖˡ);
  #[global] testCompareGE_unfold :: FuncUnfold testCompareGE [] (testCompareGEⁱᵐᵖˡ);
  #[global] testCompareLT_unfold :: FuncUnfold testCompareLT [] (testCompareLTⁱᵐᵖˡ);
  #[global] testCompareLE_unfold :: FuncUnfold testCompareLE [] (testCompareLEⁱᵐᵖˡ);
  #[global] literalCast_unfold :: FuncUnfold literalCast [] (literalCastⁱᵐᵖˡ);
  #[global] stringToByteSlice_unfold :: FuncUnfold stringToByteSlice [] (stringToByteSliceⁱᵐᵖˡ);
  #[global] byteSliceToString_unfold :: FuncUnfold byteSliceToString [] (byteSliceToStringⁱᵐᵖˡ);
  #[global] testByteSliceToString_unfold :: FuncUnfold testByteSliceToString [] (testByteSliceToStringⁱᵐᵖˡ);
  #[global] testCopySimple_unfold :: FuncUnfold testCopySimple [] (testCopySimpleⁱᵐᵖˡ);
  #[global] testCopyShorterDst_unfold :: FuncUnfold testCopyShorterDst [] (testCopyShorterDstⁱᵐᵖˡ);
  #[global] testCopyShorterSrc_unfold :: FuncUnfold testCopyShorterSrc [] (testCopyShorterSrcⁱᵐᵖˡ);
  #[global] deferSimple_unfold :: FuncUnfold deferSimple [] (deferSimpleⁱᵐᵖˡ);
  #[global] testDefer_unfold :: FuncUnfold testDefer [] (testDeferⁱᵐᵖˡ);
  #[global] testDeferFuncLit_unfold :: FuncUnfold testDeferFuncLit [] (testDeferFuncLitⁱᵐᵖˡ);
  #[global] FirstClassFunction_unfold :: FuncUnfold FirstClassFunction [] (FirstClassFunctionⁱᵐᵖˡ);
  #[global] ApplyF_unfold :: FuncUnfold ApplyF [] (ApplyFⁱᵐᵖˡ);
  #[global] testFirstClassFunction_unfold :: FuncUnfold testFirstClassFunction [] (testFirstClassFunctionⁱᵐᵖˡ);
  #[global] addFour64_unfold :: FuncUnfold addFour64 [] (addFour64ⁱᵐᵖˡ);
  #[global] failing_testFunctionOrdering_unfold :: FuncUnfold failing_testFunctionOrdering [] (failing_testFunctionOrderingⁱᵐᵖˡ);
  #[global] storeAndReturn_unfold :: FuncUnfold storeAndReturn [] (storeAndReturnⁱᵐᵖˡ);
  #[global] failing_testArgumentOrder_unfold :: FuncUnfold failing_testArgumentOrder [] (failing_testArgumentOrderⁱᵐᵖˡ);
  #[global] testU64ToU32_unfold :: FuncUnfold testU64ToU32 [] (testU64ToU32ⁱᵐᵖˡ);
  #[global] testU32ToU64_unfold :: FuncUnfold testU32ToU64 [] (testU32ToU64ⁱᵐᵖˡ);
  #[global] testU32Len_unfold :: FuncUnfold testU32Len [] (testU32Lenⁱᵐᵖˡ);
  #[global] testU32NewtypeLen_unfold :: FuncUnfold testU32NewtypeLen [] (testU32NewtypeLenⁱᵐᵖˡ);
  #[global] testUint32Untyped_unfold :: FuncUnfold testUint32Untyped [] (testUint32Untypedⁱᵐᵖˡ);
  #[global] measureArea_unfold :: FuncUnfold measureArea [] (measureAreaⁱᵐᵖˡ);
  #[global] measureVolumePlusNM_unfold :: FuncUnfold measureVolumePlusNM [] (measureVolumePlusNMⁱᵐᵖˡ);
  #[global] measureVolume_unfold :: FuncUnfold measureVolume [] (measureVolumeⁱᵐᵖˡ);
  #[global] testBasicInterface_unfold :: FuncUnfold testBasicInterface [] (testBasicInterfaceⁱᵐᵖˡ);
  #[global] testAssignInterface_unfold :: FuncUnfold testAssignInterface [] (testAssignInterfaceⁱᵐᵖˡ);
  #[global] testMultipleInterface_unfold :: FuncUnfold testMultipleInterface [] (testMultipleInterfaceⁱᵐᵖˡ);
  #[global] testBinaryExprInterface_unfold :: FuncUnfold testBinaryExprInterface [] (testBinaryExprInterfaceⁱᵐᵖˡ);
  #[global] testIfStmtInterface_unfold :: FuncUnfold testIfStmtInterface [] (testIfStmtInterfaceⁱᵐᵖˡ);
  #[global] testParamsInterface_unfold :: FuncUnfold testParamsInterface [] (testParamsInterfaceⁱᵐᵖˡ);
  #[global] testEmptyInterface_unfold :: FuncUnfold testEmptyInterface [] (testEmptyInterfaceⁱᵐᵖˡ);
  #[global] testStringInterface_unfold :: FuncUnfold testStringInterface [] (testStringInterfaceⁱᵐᵖˡ);
  #[global] testTypeAssertionInterface_unfold :: FuncUnfold testTypeAssertionInterface [] (testTypeAssertionInterfaceⁱᵐᵖˡ);
  #[global] testDoublePointerInterface_unfold :: FuncUnfold testDoublePointerInterface [] (testDoublePointerInterfaceⁱᵐᵖˡ);
  #[global] testMultipleFieldsInterface_unfold :: FuncUnfold testMultipleFieldsInterface [] (testMultipleFieldsInterfaceⁱᵐᵖˡ);
  #[global] testSharedFunctionsInterface_unfold :: FuncUnfold testSharedFunctionsInterface [] (testSharedFunctionsInterfaceⁱᵐᵖˡ);
  #[global] testAcceptAddressInterface_unfold :: FuncUnfold testAcceptAddressInterface [] (testAcceptAddressInterfaceⁱᵐᵖˡ);
  #[global] testPolymorphismInterface_unfold :: FuncUnfold testPolymorphismInterface [] (testPolymorphismInterfaceⁱᵐᵖˡ);
  #[global] testEmbeddingInterface_unfold :: FuncUnfold testEmbeddingInterface [] (testEmbeddingInterfaceⁱᵐᵖˡ);
  #[global] testDowncastInterface_unfold :: FuncUnfold testDowncastInterface [] (testDowncastInterfaceⁱᵐᵖˡ);
  #[global] testsUseLocks_unfold :: FuncUnfold testsUseLocks [] (testsUseLocksⁱᵐᵖˡ);
  #[global] standardForLoop_unfold :: FuncUnfold standardForLoop [] (standardForLoopⁱᵐᵖˡ);
  #[global] testStandardForLoop_unfold :: FuncUnfold testStandardForLoop [] (testStandardForLoopⁱᵐᵖˡ);
  #[global] testForLoopWait_unfold :: FuncUnfold testForLoopWait [] (testForLoopWaitⁱᵐᵖˡ);
  #[global] testBreakFromLoopWithContinue_unfold :: FuncUnfold testBreakFromLoopWithContinue [] (testBreakFromLoopWithContinueⁱᵐᵖˡ);
  #[global] testBreakFromLoopNoContinue_unfold :: FuncUnfold testBreakFromLoopNoContinue [] (testBreakFromLoopNoContinueⁱᵐᵖˡ);
  #[global] testBreakFromLoopNoContinueDouble_unfold :: FuncUnfold testBreakFromLoopNoContinueDouble [] (testBreakFromLoopNoContinueDoubleⁱᵐᵖˡ);
  #[global] testBreakFromLoopForOnly_unfold :: FuncUnfold testBreakFromLoopForOnly [] (testBreakFromLoopForOnlyⁱᵐᵖˡ);
  #[global] testBreakFromLoopAssignAndContinue_unfold :: FuncUnfold testBreakFromLoopAssignAndContinue [] (testBreakFromLoopAssignAndContinueⁱᵐᵖˡ);
  #[global] testNestedLoops_unfold :: FuncUnfold testNestedLoops [] (testNestedLoopsⁱᵐᵖˡ);
  #[global] testNestedGoStyleLoops_unfold :: FuncUnfold testNestedGoStyleLoops [] (testNestedGoStyleLoopsⁱᵐᵖˡ);
  #[global] testNestedGoStyleLoopsNoComparison_unfold :: FuncUnfold testNestedGoStyleLoopsNoComparison [] (testNestedGoStyleLoopsNoComparisonⁱᵐᵖˡ);
  #[global] IterateMapKeys_unfold :: FuncUnfold IterateMapKeys [] (IterateMapKeysⁱᵐᵖˡ);
  #[global] IterateMapValues_unfold :: FuncUnfold IterateMapValues [] (IterateMapValuesⁱᵐᵖˡ);
  #[global] testIterateMap_unfold :: FuncUnfold testIterateMap [] (testIterateMapⁱᵐᵖˡ);
  #[global] testMapSize_unfold :: FuncUnfold testMapSize [] (testMapSizeⁱᵐᵖˡ);
  #[global] multReturnTwo_unfold :: FuncUnfold multReturnTwo [] (multReturnTwoⁱᵐᵖˡ);
  #[global] testAssignTwo_unfold :: FuncUnfold testAssignTwo [] (testAssignTwoⁱᵐᵖˡ);
  #[global] multReturnThree_unfold :: FuncUnfold multReturnThree [] (multReturnThreeⁱᵐᵖˡ);
  #[global] testAssignThree_unfold :: FuncUnfold testAssignThree [] (testAssignThreeⁱᵐᵖˡ);
  #[global] testMultipleAssignToMap_unfold :: FuncUnfold testMultipleAssignToMap [] (testMultipleAssignToMapⁱᵐᵖˡ);
  #[global] returnTwo_unfold :: FuncUnfold returnTwo [] (returnTwoⁱᵐᵖˡ);
  #[global] testReturnTwo_unfold :: FuncUnfold testReturnTwo [] (testReturnTwoⁱᵐᵖˡ);
  #[global] testAnonymousBinding_unfold :: FuncUnfold testAnonymousBinding [] (testAnonymousBindingⁱᵐᵖˡ);
  #[global] returnThree_unfold :: FuncUnfold returnThree [] (returnThreeⁱᵐᵖˡ);
  #[global] testReturnThree_unfold :: FuncUnfold testReturnThree [] (testReturnThreeⁱᵐᵖˡ);
  #[global] returnFour_unfold :: FuncUnfold returnFour [] (returnFourⁱᵐᵖˡ);
  #[global] testReturnFour_unfold :: FuncUnfold testReturnFour [] (testReturnFourⁱᵐᵖˡ);
  #[global] testCompareSliceToNil_unfold :: FuncUnfold testCompareSliceToNil [] (testCompareSliceToNilⁱᵐᵖˡ);
  #[global] testComparePointerToNil_unfold :: FuncUnfold testComparePointerToNil [] (testComparePointerToNilⁱᵐᵖˡ);
  #[global] testCompareNilToNil_unfold :: FuncUnfold testCompareNilToNil [] (testCompareNilToNilⁱᵐᵖˡ);
  #[global] testComparePointerWrappedToNil_unfold :: FuncUnfold testComparePointerWrappedToNil [] (testComparePointerWrappedToNilⁱᵐᵖˡ);
  #[global] testComparePointerWrappedDefaultToNil_unfold :: FuncUnfold testComparePointerWrappedDefaultToNil [] (testComparePointerWrappedDefaultToNilⁱᵐᵖˡ);
  #[global] testInterfaceNilWithType_unfold :: FuncUnfold testInterfaceNilWithType [] (testInterfaceNilWithTypeⁱᵐᵖˡ);
  #[global] reverseAssignOps64_unfold :: FuncUnfold reverseAssignOps64 [] (reverseAssignOps64ⁱᵐᵖˡ);
  #[global] reverseAssignOps32_unfold :: FuncUnfold reverseAssignOps32 [] (reverseAssignOps32ⁱᵐᵖˡ);
  #[global] add64Equals_unfold :: FuncUnfold add64Equals [] (add64Equalsⁱᵐᵖˡ);
  #[global] sub64Equals_unfold :: FuncUnfold sub64Equals [] (sub64Equalsⁱᵐᵖˡ);
  #[global] testReverseAssignOps64_unfold :: FuncUnfold testReverseAssignOps64 [] (testReverseAssignOps64ⁱᵐᵖˡ);
  #[global] failing_testReverseAssignOps32_unfold :: FuncUnfold failing_testReverseAssignOps32 [] (failing_testReverseAssignOps32ⁱᵐᵖˡ);
  #[global] testAdd64Equals_unfold :: FuncUnfold testAdd64Equals [] (testAdd64Equalsⁱᵐᵖˡ);
  #[global] testSub64Equals_unfold :: FuncUnfold testSub64Equals [] (testSub64Equalsⁱᵐᵖˡ);
  #[global] testDivisionPrecedence_unfold :: FuncUnfold testDivisionPrecedence [] (testDivisionPrecedenceⁱᵐᵖˡ);
  #[global] testModPrecedence_unfold :: FuncUnfold testModPrecedence [] (testModPrecedenceⁱᵐᵖˡ);
  #[global] testBitwiseOpsPrecedence_unfold :: FuncUnfold testBitwiseOpsPrecedence [] (testBitwiseOpsPrecedenceⁱᵐᵖˡ);
  #[global] testArithmeticShifts_unfold :: FuncUnfold testArithmeticShifts [] (testArithmeticShiftsⁱᵐᵖˡ);
  #[global] testBitAddAnd_unfold :: FuncUnfold testBitAddAnd [] (testBitAddAndⁱᵐᵖˡ);
  #[global] testManyParentheses_unfold :: FuncUnfold testManyParentheses [] (testManyParenthesesⁱᵐᵖˡ);
  #[global] testPlusTimes_unfold :: FuncUnfold testPlusTimes [] (testPlusTimesⁱᵐᵖˡ);
  #[global] shouldPanic_unfold :: FuncUnfold shouldPanic [] (shouldPanicⁱᵐᵖˡ);
  #[global] testOrCompareSimple_unfold :: FuncUnfold testOrCompareSimple [] (testOrCompareSimpleⁱᵐᵖˡ);
  #[global] testOrCompare_unfold :: FuncUnfold testOrCompare [] (testOrCompareⁱᵐᵖˡ);
  #[global] testAndCompare_unfold :: FuncUnfold testAndCompare [] (testAndCompareⁱᵐᵖˡ);
  #[global] testShiftMod_unfold :: FuncUnfold testShiftMod [] (testShiftModⁱᵐᵖˡ);
  #[global] testLinearize_unfold :: FuncUnfold testLinearize [] (testLinearizeⁱᵐᵖˡ);
  #[global] CheckTrue_unfold :: FuncUnfold CheckTrue [] (CheckTrueⁱᵐᵖˡ);
  #[global] CheckFalse_unfold :: FuncUnfold CheckFalse [] (CheckFalseⁱᵐᵖˡ);
  #[global] testShortcircuitAndTF_unfold :: FuncUnfold testShortcircuitAndTF [] (testShortcircuitAndTFⁱᵐᵖˡ);
  #[global] testShortcircuitAndFT_unfold :: FuncUnfold testShortcircuitAndFT [] (testShortcircuitAndFTⁱᵐᵖˡ);
  #[global] testShortcircuitOrTF_unfold :: FuncUnfold testShortcircuitOrTF [] (testShortcircuitOrTFⁱᵐᵖˡ);
  #[global] testShortcircuitOrFT_unfold :: FuncUnfold testShortcircuitOrFT [] (testShortcircuitOrFTⁱᵐᵖˡ);
  #[global] testSliceOps_unfold :: FuncUnfold testSliceOps [] (testSliceOpsⁱᵐᵖˡ);
  #[global] testSliceCapacityOps_unfold :: FuncUnfold testSliceCapacityOps [] (testSliceCapacityOpsⁱᵐᵖˡ);
  #[global] testOverwriteArray_unfold :: FuncUnfold testOverwriteArray [] (testOverwriteArrayⁱᵐᵖˡ);
  #[global] testSliceLiteral_unfold :: FuncUnfold testSliceLiteral [] (testSliceLiteralⁱᵐᵖˡ);
  #[global] testSliceAppend_unfold :: FuncUnfold testSliceAppend [] (testSliceAppendⁱᵐᵖˡ);
  #[global] testFooBarMutation_unfold :: FuncUnfold testFooBarMutation [] (testFooBarMutationⁱᵐᵖˡ);
  #[global] NewS_unfold :: FuncUnfold NewS [] (NewSⁱᵐᵖˡ);
  #[global] testStructUpdates_unfold :: FuncUnfold testStructUpdates [] (testStructUpdatesⁱᵐᵖˡ);
  #[global] testNestedStructUpdates_unfold :: FuncUnfold testNestedStructUpdates [] (testNestedStructUpdatesⁱᵐᵖˡ);
  #[global] testStructConstructions_unfold :: FuncUnfold testStructConstructions [] (testStructConstructionsⁱᵐᵖˡ);
  #[global] testIncompleteStruct_unfold :: FuncUnfold testIncompleteStruct [] (testIncompleteStructⁱᵐᵖˡ);
  #[global] testStoreInStructVar_unfold :: FuncUnfold testStoreInStructVar [] (testStoreInStructVarⁱᵐᵖˡ);
  #[global] testStoreInStructPointerVar_unfold :: FuncUnfold testStoreInStructPointerVar [] (testStoreInStructPointerVarⁱᵐᵖˡ);
  #[global] testStoreComposite_unfold :: FuncUnfold testStoreComposite [] (testStoreCompositeⁱᵐᵖˡ);
  #[global] testStoreSlice_unfold :: FuncUnfold testStoreSlice [] (testStoreSliceⁱᵐᵖˡ);
  #[global] testStructFieldFunc_unfold :: FuncUnfold testStructFieldFunc [] (testStructFieldFuncⁱᵐᵖˡ);
  #[global] testSwitchVal_unfold :: FuncUnfold testSwitchVal [] (testSwitchValⁱᵐᵖˡ);
  #[global] testSwitchMultiple_unfold :: FuncUnfold testSwitchMultiple [] (testSwitchMultipleⁱᵐᵖˡ);
  #[global] testSwitchDefaultTrue_unfold :: FuncUnfold testSwitchDefaultTrue [] (testSwitchDefaultTrueⁱᵐᵖˡ);
  #[global] testSwitchConversion_unfold :: FuncUnfold testSwitchConversion [] (testSwitchConversionⁱᵐᵖˡ);
  #[global] TypesEqual_unfold T U :: FuncUnfold TypesEqual [T; U] (TypesEqualⁱᵐᵖˡ T U);
  #[global] testPrimitiveTypesEqual_unfold :: FuncUnfold testPrimitiveTypesEqual [] (testPrimitiveTypesEqualⁱᵐᵖˡ);
  #[global] testDefinedStrTypesEqual_unfold :: FuncUnfold testDefinedStrTypesEqual [] (testDefinedStrTypesEqualⁱᵐᵖˡ);
  #[global] testListTypesEqual_unfold :: FuncUnfold testListTypesEqual [] (testListTypesEqualⁱᵐᵖˡ);
  #[global] testPointerAssignment_unfold :: FuncUnfold testPointerAssignment [] (testPointerAssignmentⁱᵐᵖˡ);
  #[global] testAddressOfLocal_unfold :: FuncUnfold testAddressOfLocal [] (testAddressOfLocalⁱᵐᵖˡ);
  #[global] testAnonymousAssign_unfold :: FuncUnfold testAnonymousAssign [] (testAnonymousAssignⁱᵐᵖˡ);
  #[global] intToBlock_unfold :: FuncUnfold intToBlock [] (intToBlockⁱᵐᵖˡ);
  #[global] blockToInt_unfold :: FuncUnfold blockToInt [] (blockToIntⁱᵐᵖˡ);
  #[global] New_unfold :: FuncUnfold New [] (Newⁱᵐᵖˡ);
  #[global] getLogEntry_unfold :: FuncUnfold getLogEntry [] (getLogEntryⁱᵐᵖˡ);
  #[global] applyLog_unfold :: FuncUnfold applyLog [] (applyLogⁱᵐᵖˡ);
  #[global] clearLog_unfold :: FuncUnfold clearLog [] (clearLogⁱᵐᵖˡ);
  #[global] Open_unfold :: FuncUnfold Open [] (Openⁱᵐᵖˡ);
  #[global] disabled_testWal_unfold :: FuncUnfold disabled_testWal [] (disabled_testWalⁱᵐᵖˡ);
  #[global] import_sync_Assumption :: sync.Assumptions;
  #[global] import_primitive_Assumption :: primitive.Assumptions;
  #[global] import_binary_Assumption :: binary.Assumptions;
  #[global] import_disk_Assumption :: disk.Assumptions;
}.
End semantics.
