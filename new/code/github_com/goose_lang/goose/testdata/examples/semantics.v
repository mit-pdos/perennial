(* autogenerated from github.com/goose-lang/goose/testdata/examples/semantics *)
From New.golang Require Import defn.
From New.code Require github_com.goose_lang.primitive.
From New.code Require github_com.goose_lang.primitive.disk.
From New.code Require sync.

From New Require Import disk_prelude.

Definition unit : go_type := structT [
].

Definition unit__mset : list (string * val) := [
].

Definition unit__mset_ptr : list (string * val) := [
].

(* go: allocator.go:7:6 *)
Definition findKey : val :=
  rec: "findKey" "m" :=
    exception_do (let: "m" := (ref_ty (mapT uint64T unit) "m") in
    let: "found" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("found" <-[uint64T] "$r0");;;
    let: "ok" := (ref_ty boolT (zero_val boolT)) in
    let: "$r0" := #false in
    do:  ("ok" <-[boolT] "$r0");;;
    do:  (map.for_range (![mapT uint64T unit] "m") (λ: "k" <>,
      (if: (~ (![boolT] "ok"))
      then
        let: "$r0" := (![uint64T] "k") in
        do:  ("found" <-[uint64T] "$r0");;;
        let: "$r0" := #true in
        do:  ("ok" <-[boolT] "$r0")
      else do:  #())));;;
    return: (![uint64T] "found", ![boolT] "ok")).

(* go: allocator.go:20:6 *)
Definition allocate : val :=
  rec: "allocate" "m" :=
    exception_do (let: "m" := (ref_ty (mapT uint64T unit) "m") in
    let: "ok" := (ref_ty boolT (zero_val boolT)) in
    let: "k" := (ref_ty uint64T (zero_val uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![mapT uint64T unit] "m") in
    findKey "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("k" <-[uint64T] "$r0");;;
    do:  ("ok" <-[boolT] "$r1");;;
    do:  (let: "$a0" := (![mapT uint64T unit] "m") in
    let: "$a1" := (![uint64T] "k") in
    map.delete "$a0" "$a1");;;
    return: (![uint64T] "k", ![boolT] "ok")).

(* go: allocator.go:26:6 *)
Definition freeRange : val :=
  rec: "freeRange" "sz" :=
    exception_do (let: "sz" := (ref_ty uint64T "sz") in
    let: "m" := (ref_ty (mapT uint64T unit) (zero_val (mapT uint64T unit))) in
    let: "$r0" := (map.make uint64T unit #()) in
    do:  ("m" <-[mapT uint64T unit] "$r0");;;
    (let: "i" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[uint64T] "$r0");;;
    (for: (λ: <>, (![uint64T] "i") < (![uint64T] "sz")); (λ: <>, do:  ("i" <-[uint64T] ((![uint64T] "i") + #(W64 1)))) := λ: <>,
      let: "$r0" := (struct.make unit [{
      }]) in
      do:  (map.insert (![mapT uint64T unit] "m") (![uint64T] "i") "$r0")));;;
    return: (![mapT uint64T unit] "m")).

(* go: allocator.go:34:6 *)
Definition testAllocateDistinct : val :=
  rec: "testAllocateDistinct" <> :=
    exception_do (let: "free" := (ref_ty (mapT uint64T unit) (zero_val (mapT uint64T unit))) in
    let: "$r0" := (let: "$a0" := #(W64 4) in
    freeRange "$a0") in
    do:  ("free" <-[mapT uint64T unit] "$r0");;;
    let: "a1" := (ref_ty uint64T (zero_val uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![mapT uint64T unit] "free") in
    allocate "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("a1" <-[uint64T] "$r0");;;
    do:  "$r1";;;
    let: "a2" := (ref_ty uint64T (zero_val uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![mapT uint64T unit] "free") in
    allocate "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("a2" <-[uint64T] "$r0");;;
    do:  "$r1";;;
    return: ((![uint64T] "a1") ≠ (![uint64T] "a2"))).

(* go: allocator.go:41:6 *)
Definition testAllocateFull : val :=
  rec: "testAllocateFull" <> :=
    exception_do (let: "free" := (ref_ty (mapT uint64T unit) (zero_val (mapT uint64T unit))) in
    let: "$r0" := (let: "$a0" := #(W64 2) in
    freeRange "$a0") in
    do:  ("free" <-[mapT uint64T unit] "$r0");;;
    let: "ok1" := (ref_ty boolT (zero_val boolT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![mapT uint64T unit] "free") in
    allocate "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  "$r0";;;
    do:  ("ok1" <-[boolT] "$r1");;;
    let: "ok2" := (ref_ty boolT (zero_val boolT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![mapT uint64T unit] "free") in
    allocate "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  "$r0";;;
    do:  ("ok2" <-[boolT] "$r1");;;
    let: "ok3" := (ref_ty boolT (zero_val boolT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![mapT uint64T unit] "free") in
    allocate "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  "$r0";;;
    do:  ("ok3" <-[boolT] "$r1");;;
    return: (((![boolT] "ok1") && (![boolT] "ok2")) && (~ (![boolT] "ok3")))).

(* go: block.go:3:6 *)
Definition testExplicitBlockStmt : val :=
  rec: "testExplicitBlockStmt" <> :=
    exception_do (let: "x" := (ref_ty intT (zero_val intT)) in
    let: "$r0" := #(W64 10) in
    do:  ("x" <-[intT] "$r0");;;
    let: "x" := (ref_ty intT (zero_val intT)) in
    let: "$r0" := #(W64 11) in
    do:  ("x" <-[intT] "$r0");;;
    do:  ("x" <-[intT] ((![intT] "x") + #(W64 1)));;;
    return: ((![intT] "x") = #(W64 10))).

(* go: builtin.go:3:6 *)
Definition testMinUint64 : val :=
  rec: "testMinUint64" <> :=
    exception_do (let: "x" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := #(W64 10) in
    do:  ("x" <-[uint64T] "$r0");;;
    return: ((let: "$a0" := (![uint64T] "x") in
     let: "$a1" := #(W64 1) in
     (minUint64 2) "$a0" "$a1") = #(W64 1))).

(* go: builtin.go:8:6 *)
Definition testMaxUint64 : val :=
  rec: "testMaxUint64" <> :=
    exception_do (let: "x" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := #(W64 10) in
    do:  ("x" <-[uint64T] "$r0");;;
    return: ((let: "$a0" := (![uint64T] "x") in
     let: "$a1" := #(W64 1) in
     (maxUint64 2) "$a0" "$a1") = #(W64 10))).

Definition AdderType : go_type := funcT.

Definition MultipleArgsType : go_type := funcT.

(* go: closures.go:6:6 *)
Definition adder : val :=
  rec: "adder" <> :=
    exception_do (let: "sum" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("sum" <-[uint64T] "$r0");;;
    return: ((λ: "x",
       exception_do (let: "x" := (ref_ty uint64T "x") in
       do:  ("sum" <-[uint64T] ((![uint64T] "sum") + (![uint64T] "x")));;;
       return: (![uint64T] "sum"))
       ))).

(* go: closures.go:14:6 *)
Definition testClosureBasic : val :=
  rec: "testClosureBasic" <> :=
    exception_do (let: "pos" := (ref_ty funcT (zero_val funcT)) in
    let: "$r0" := (adder #()) in
    do:  ("pos" <-[funcT] "$r0");;;
    let: "doub" := (ref_ty funcT (zero_val funcT)) in
    let: "$r0" := (adder #()) in
    do:  ("doub" <-[funcT] "$r0");;;
    (let: "i" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[uint64T] "$r0");;;
    (for: (λ: <>, (![uint64T] "i") < #(W64 10)); (λ: <>, do:  ("i" <-[uint64T] ((![uint64T] "i") + #(W64 1)))) := λ: <>,
      do:  (let: "$a0" := (![uint64T] "i") in
      (![funcT] "pos") "$a0");;;
      do:  (let: "$a0" := (#(W64 2) * (![uint64T] "i")) in
      (![funcT] "doub") "$a0")));;;
    (if: ((let: "$a0" := #(W64 0) in
    (![funcT] "pos") "$a0") = #(W64 45)) && ((let: "$a0" := #(W64 0) in
    (![funcT] "doub") "$a0") = #(W64 90))
    then return: (#true)
    else do:  #());;;
    return: (#false)).

(* go: comparisons.go:3:6 *)
Definition testCompareAll : val :=
  rec: "testCompareAll" <> :=
    exception_do (let: "ok" := (ref_ty boolT (zero_val boolT)) in
    let: "$r0" := #true in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "nok" := (ref_ty boolT (zero_val boolT)) in
    let: "$r0" := #false in
    do:  ("nok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && #(1 <? 2)) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && #(2 <? 1)) in
    do:  ("nok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && #(1 <=? 2)) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && #(2 <=? 2)) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && #(2 <=? 1)) in
    do:  ("nok" <-[boolT] "$r0");;;
    (if: ![boolT] "nok"
    then return: (#false)
    else do:  #());;;
    return: (![boolT] "ok")).

(* go: comparisons.go:20:6 *)
Definition testCompareGT : val :=
  rec: "testCompareGT" <> :=
    exception_do (let: "x" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := #(W64 4) in
    do:  ("x" <-[uint64T] "$r0");;;
    let: "y" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := #(W64 5) in
    do:  ("y" <-[uint64T] "$r0");;;
    let: "ok" := (ref_ty boolT (zero_val boolT)) in
    let: "$r0" := #true in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((![uint64T] "y") > #(W64 4))) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((![uint64T] "y") > (![uint64T] "x"))) in
    do:  ("ok" <-[boolT] "$r0");;;
    return: (![boolT] "ok")).

(* go: comparisons.go:31:6 *)
Definition testCompareGE : val :=
  rec: "testCompareGE" <> :=
    exception_do (let: "x" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := #(W64 4) in
    do:  ("x" <-[uint64T] "$r0");;;
    let: "y" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := #(W64 5) in
    do:  ("y" <-[uint64T] "$r0");;;
    let: "ok" := (ref_ty boolT (zero_val boolT)) in
    let: "$r0" := #true in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((![uint64T] "y") ≥ #(W64 4))) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((![uint64T] "y") ≥ #(W64 5))) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((![uint64T] "y") ≥ (![uint64T] "x"))) in
    do:  ("ok" <-[boolT] "$r0");;;
    (if: (![uint64T] "y") > #(W64 5)
    then return: (#false)
    else do:  #());;;
    return: (![boolT] "ok")).

(* go: comparisons.go:47:6 *)
Definition testCompareLT : val :=
  rec: "testCompareLT" <> :=
    exception_do (let: "x" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := #(W64 4) in
    do:  ("x" <-[uint64T] "$r0");;;
    let: "y" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := #(W64 5) in
    do:  ("y" <-[uint64T] "$r0");;;
    let: "ok" := (ref_ty boolT (zero_val boolT)) in
    let: "$r0" := #true in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((![uint64T] "y") < #(W64 6))) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((![uint64T] "x") < (![uint64T] "y"))) in
    do:  ("ok" <-[boolT] "$r0");;;
    return: (![boolT] "ok")).

(* go: comparisons.go:58:6 *)
Definition testCompareLE : val :=
  rec: "testCompareLE" <> :=
    exception_do (let: "x" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := #(W64 4) in
    do:  ("x" <-[uint64T] "$r0");;;
    let: "y" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := #(W64 5) in
    do:  ("y" <-[uint64T] "$r0");;;
    let: "ok" := (ref_ty boolT (zero_val boolT)) in
    let: "$r0" := #true in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((![uint64T] "y") ≤ #(W64 6))) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((![uint64T] "y") ≤ #(W64 5))) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((![uint64T] "x") ≤ (![uint64T] "y"))) in
    do:  ("ok" <-[boolT] "$r0");;;
    (if: (![uint64T] "y") < #(W64 5)
    then return: (#false)
    else do:  #());;;
    return: (![boolT] "ok")).

(* go: conversions.go:5:6 *)
Definition literalCast : val :=
  rec: "literalCast" <> :=
    exception_do (let: "x" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := #(W64 2) in
    do:  ("x" <-[uint64T] "$r0");;;
    return: ((![uint64T] "x") + #(W64 2))).

(* go: conversions.go:11:6 *)
Definition stringToByteSlice : val :=
  rec: "stringToByteSlice" "s" :=
    exception_do (let: "s" := (ref_ty stringT "s") in
    let: "p" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (string.to_bytes (![stringT] "s")) in
    do:  ("p" <-[sliceT] "$r0");;;
    return: (![sliceT] "p")).

(* go: conversions.go:17:6 *)
Definition byteSliceToString : val :=
  rec: "byteSliceToString" "p" :=
    exception_do (let: "p" := (ref_ty sliceT "p") in
    return: (string.from_bytes (![sliceT] "p"))).

(* tests

   go: conversions.go:23:6 *)
Definition testByteSliceToString : val :=
  rec: "testByteSliceToString" <> :=
    exception_do (let: "x" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (slice.make2 byteT #(W64 3)) in
    do:  ("x" <-[sliceT] "$r0");;;
    let: "$r0" := #(W8 65) in
    do:  ((slice.elem_ref byteT (![sliceT] "x") #(W64 0)) <-[byteT] "$r0");;;
    let: "$r0" := #(W8 66) in
    do:  ((slice.elem_ref byteT (![sliceT] "x") #(W64 1)) <-[byteT] "$r0");;;
    let: "$r0" := #(W8 67) in
    do:  ((slice.elem_ref byteT (![sliceT] "x") #(W64 2)) <-[byteT] "$r0");;;
    return: ((let: "$a0" := (![sliceT] "x") in
     byteSliceToString "$a0") = #"ABC")).

(* go: copy.go:3:6 *)
Definition testCopySimple : val :=
  rec: "testCopySimple" <> :=
    exception_do (let: "x" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (slice.make2 byteT #(W64 10)) in
    do:  ("x" <-[sliceT] "$r0");;;
    let: "$r0" := #(W8 1) in
    do:  ((slice.elem_ref byteT (![sliceT] "x") #(W64 3)) <-[byteT] "$r0");;;
    let: "y" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (slice.make2 byteT #(W64 10)) in
    do:  ("y" <-[sliceT] "$r0");;;
    do:  (let: "$a0" := (![sliceT] "y") in
    let: "$a1" := (![sliceT] "x") in
    (slice.copy byteT) "$a0" "$a1");;;
    return: ((![byteT] (slice.elem_ref byteT (![sliceT] "y") #(W64 3))) = #(W8 1))).

(* go: copy.go:11:6 *)
Definition testCopyShorterDst : val :=
  rec: "testCopyShorterDst" <> :=
    exception_do (let: "x" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (slice.make2 byteT #(W64 15)) in
    do:  ("x" <-[sliceT] "$r0");;;
    let: "$r0" := #(W8 1) in
    do:  ((slice.elem_ref byteT (![sliceT] "x") #(W64 3)) <-[byteT] "$r0");;;
    let: "$r0" := #(W8 2) in
    do:  ((slice.elem_ref byteT (![sliceT] "x") #(W64 12)) <-[byteT] "$r0");;;
    let: "y" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (slice.make2 byteT #(W64 10)) in
    do:  ("y" <-[sliceT] "$r0");;;
    let: "n" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (let: "$a0" := (![sliceT] "y") in
    let: "$a1" := (![sliceT] "x") in
    (slice.copy byteT) "$a0" "$a1") in
    do:  ("n" <-[uint64T] "$r0");;;
    return: (((![uint64T] "n") = #(W64 10)) && ((![byteT] (slice.elem_ref byteT (![sliceT] "y") #(W64 3))) = #(W8 1)))).

(* go: copy.go:20:6 *)
Definition testCopyShorterSrc : val :=
  rec: "testCopyShorterSrc" <> :=
    exception_do (let: "x" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (slice.make2 byteT #(W64 10)) in
    do:  ("x" <-[sliceT] "$r0");;;
    let: "y" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (slice.make2 byteT #(W64 15)) in
    do:  ("y" <-[sliceT] "$r0");;;
    let: "$r0" := #(W8 1) in
    do:  ((slice.elem_ref byteT (![sliceT] "x") #(W64 3)) <-[byteT] "$r0");;;
    let: "$r0" := #(W8 2) in
    do:  ((slice.elem_ref byteT (![sliceT] "y") #(W64 12)) <-[byteT] "$r0");;;
    let: "n" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (let: "$a0" := (![sliceT] "y") in
    let: "$a1" := (![sliceT] "x") in
    (slice.copy byteT) "$a0" "$a1") in
    do:  ("n" <-[uint64T] "$r0");;;
    return: ((((![uint64T] "n") = #(W64 10)) && ((![byteT] (slice.elem_ref byteT (![sliceT] "y") #(W64 3))) = #(W8 1))) && ((![byteT] (slice.elem_ref byteT (![sliceT] "y") #(W64 12))) = #(W8 2)))).

(* go: defer.go:3:6 *)
Definition deferSimple : val :=
  rec: "deferSimple" <> :=
    with_defer: (let: "x" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty uint64T (zero_val uint64T)) in
    do:  ("x" <-[ptrT] "$r0");;;
    (let: "i" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[uint64T] "$r0");;;
    (for: (λ: <>, (![uint64T] "i") < #(W64 10)); (λ: <>, do:  ("i" <-[uint64T] ((![uint64T] "i") + #(W64 1)))) := λ: <>,
      do:  (let: "$f" := (λ: <>,
        exception_do (do:  ((![ptrT] "x") <-[uint64T] ((![uint64T] (![ptrT] "x")) + #(W64 1))))
        ) in
      "$defer" <-[funcT] (let: "$oldf" := (![funcT] "$defer") in
      (λ: <>,
        "$f" #();;
        "$oldf" #()
        )))));;;
    return: (![ptrT] "x")).

(* go: defer.go:13:6 *)
Definition testDefer : val :=
  rec: "testDefer" <> :=
    exception_do (return: ((![uint64T] (deferSimple #())) = #(W64 10))).

(* go: defer.go:17:6 *)
Definition testDeferFuncLit : val :=
  rec: "testDeferFuncLit" <> :=
    exception_do (let: "x" := (ref_ty intT (zero_val intT)) in
    let: "$r0" := #(W64 10) in
    do:  ("x" <-[intT] "$r0");;;
    let: "f" := (ref_ty funcT (zero_val funcT)) in
    let: "$r0" := (λ: <>,
      with_defer: (do:  (let: "$f" := (λ: <>,
        exception_do (do:  ("x" <-[intT] ((![intT] "x") + #(W64 1))))
        ) in
      "$defer" <-[funcT] (let: "$oldf" := (![funcT] "$defer") in
      (λ: <>,
        "$f" #();;
        "$oldf" #()
        ))))
      ) in
    do:  ("f" <-[funcT] "$r0");;;
    do:  ((![funcT] "f") #());;;
    return: ((![intT] "x") = #(W64 11))).

Definition Enc : go_type := structT [
  "p" :: sliceT
].

Definition Enc__mset : list (string * val) := [
].

(* go: encoding.go:10:15 *)
Definition Enc__consume : val :=
  rec: "Enc__consume" "e" "n" :=
    exception_do (let: "e" := (ref_ty ptrT "e") in
    let: "n" := (ref_ty uint64T "n") in
    let: "b" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (let: "$s" := (![sliceT] (struct.field_ref Enc "p" (![ptrT] "e"))) in
    slice.slice byteT "$s" #(W64 0) (![uint64T] "n")) in
    do:  ("b" <-[sliceT] "$r0");;;
    let: "$r0" := (let: "$s" := (![sliceT] (struct.field_ref Enc "p" (![ptrT] "e"))) in
    slice.slice byteT "$s" (![uint64T] "n") (slice.len "$s")) in
    do:  ((struct.field_ref Enc "p" (![ptrT] "e")) <-[sliceT] "$r0");;;
    return: (![sliceT] "b")).

Definition Enc__mset_ptr : list (string * val) := [
  ("consume", Enc__consume%V)
].

Definition Dec : go_type := structT [
  "p" :: sliceT
].

Definition Dec__mset : list (string * val) := [
].

(* go: encoding.go:20:15 *)
Definition Dec__consume : val :=
  rec: "Dec__consume" "d" "n" :=
    exception_do (let: "d" := (ref_ty ptrT "d") in
    let: "n" := (ref_ty uint64T "n") in
    let: "b" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (let: "$s" := (![sliceT] (struct.field_ref Dec "p" (![ptrT] "d"))) in
    slice.slice byteT "$s" #(W64 0) (![uint64T] "n")) in
    do:  ("b" <-[sliceT] "$r0");;;
    let: "$r0" := (let: "$s" := (![sliceT] (struct.field_ref Dec "p" (![ptrT] "d"))) in
    slice.slice byteT "$s" (![uint64T] "n") (slice.len "$s")) in
    do:  ((struct.field_ref Dec "p" (![ptrT] "d")) <-[sliceT] "$r0");;;
    return: (![sliceT] "b")).

Definition Dec__mset_ptr : list (string * val) := [
  ("consume", Dec__consume%V)
].

(* go: encoding.go:26:6 *)
Definition roundtripEncDec32 : val :=
  rec: "roundtripEncDec32" "x" :=
    exception_do (let: "x" := (ref_ty uint32T "x") in
    let: "r" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (slice.make2 byteT #(W64 4)) in
    do:  ("r" <-[sliceT] "$r0");;;
    let: "e" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty Enc (struct.make Enc [{
      "p" ::= ![sliceT] "r"
    }])) in
    do:  ("e" <-[ptrT] "$r0");;;
    let: "d" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty Dec (struct.make Dec [{
      "p" ::= ![sliceT] "r"
    }])) in
    do:  ("d" <-[ptrT] "$r0");;;
    do:  (let: "$a0" := (let: "$a0" := #(W64 4) in
    (Enc__consume (![ptrT] "e")) "$a0") in
    let: "$a1" := (![uint32T] "x") in
    primitive.UInt32Put "$a0" "$a1");;;
    return: (let: "$a0" := (let: "$a0" := #(W64 4) in
     (Dec__consume (![ptrT] "d")) "$a0") in
     primitive.UInt32Get "$a0")).

(* go: encoding.go:34:6 *)
Definition roundtripEncDec64 : val :=
  rec: "roundtripEncDec64" "x" :=
    exception_do (let: "x" := (ref_ty uint64T "x") in
    let: "r" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (slice.make2 byteT #(W64 8)) in
    do:  ("r" <-[sliceT] "$r0");;;
    let: "e" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty Enc (struct.make Enc [{
      "p" ::= ![sliceT] "r"
    }])) in
    do:  ("e" <-[ptrT] "$r0");;;
    let: "d" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty Dec (struct.make Dec [{
      "p" ::= ![sliceT] "r"
    }])) in
    do:  ("d" <-[ptrT] "$r0");;;
    do:  (let: "$a0" := (let: "$a0" := #(W64 8) in
    (Enc__consume (![ptrT] "e")) "$a0") in
    let: "$a1" := (![uint64T] "x") in
    primitive.UInt64Put "$a0" "$a1");;;
    return: (let: "$a0" := (let: "$a0" := #(W64 8) in
     (Dec__consume (![ptrT] "d")) "$a0") in
     primitive.UInt64Get "$a0")).

(* tests

   go: encoding.go:43:6 *)
Definition testEncDec32Simple : val :=
  rec: "testEncDec32Simple" <> :=
    exception_do (let: "ok" := (ref_ty boolT (zero_val boolT)) in
    let: "$r0" := #true in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((let: "$a0" := #(W32 0) in
    roundtripEncDec32 "$a0") = #(W32 0))) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((let: "$a0" := #(W32 1) in
    roundtripEncDec32 "$a0") = #(W32 1))) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((let: "$a0" := #(W32 1231234) in
    roundtripEncDec32 "$a0") = #(W32 1231234))) in
    do:  ("ok" <-[boolT] "$r0");;;
    return: (![boolT] "ok")).

(* go: encoding.go:51:6 *)
Definition failing_testEncDec32 : val :=
  rec: "failing_testEncDec32" <> :=
    exception_do (let: "ok" := (ref_ty boolT (zero_val boolT)) in
    let: "$r0" := #true in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((let: "$a0" := #(W32 3434807466) in
    roundtripEncDec32 "$a0") = #(W32 3434807466))) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((let: "$a0" := #(W32 1048576) in
    roundtripEncDec32 "$a0") = #(W32 1048576))) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((let: "$a0" := #(W32 262144) in
    roundtripEncDec32 "$a0") = #(W32 262144))) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((let: "$a0" := #(W32 1024) in
    roundtripEncDec32 "$a0") = #(W32 1024))) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((let: "$a0" := #(W32 1) in
    roundtripEncDec32 "$a0") = #(W32 1))) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((let: "$a0" := #(W32 (4294967296 - 1)) in
    roundtripEncDec32 "$a0") = #(W32 (4294967296 - 1)))) in
    do:  ("ok" <-[boolT] "$r0");;;
    return: (![boolT] "ok")).

(* go: encoding.go:62:6 *)
Definition testEncDec64Simple : val :=
  rec: "testEncDec64Simple" <> :=
    exception_do (let: "ok" := (ref_ty boolT (zero_val boolT)) in
    let: "$r0" := #true in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((let: "$a0" := #(W64 0) in
    roundtripEncDec64 "$a0") = #(W64 0))) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((let: "$a0" := #(W64 1) in
    roundtripEncDec64 "$a0") = #(W64 1))) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((let: "$a0" := #(W64 1231234) in
    roundtripEncDec64 "$a0") = #(W64 1231234))) in
    do:  ("ok" <-[boolT] "$r0");;;
    return: (![boolT] "ok")).

(* go: encoding.go:70:6 *)
Definition testEncDec64 : val :=
  rec: "testEncDec64" <> :=
    exception_do (let: "ok" := (ref_ty boolT (zero_val boolT)) in
    let: "$r0" := #true in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((let: "$a0" := #(W64 62206846038638762) in
    roundtripEncDec64 "$a0") = #(W64 62206846038638762))) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((let: "$a0" := #(W64 9223372036854775808) in
    roundtripEncDec64 "$a0") = #(W64 9223372036854775808))) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((let: "$a0" := #(W64 140737488355328) in
    roundtripEncDec64 "$a0") = #(W64 140737488355328))) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((let: "$a0" := #(W64 1048576) in
    roundtripEncDec64 "$a0") = #(W64 1048576))) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((let: "$a0" := #(W64 262144) in
    roundtripEncDec64 "$a0") = #(W64 262144))) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((let: "$a0" := #(W64 1024) in
    roundtripEncDec64 "$a0") = #(W64 1024))) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((let: "$a0" := #(W64 1) in
    roundtripEncDec64 "$a0") = #(W64 1))) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((let: "$a0" := #(W64 (18446744073709551616 - 1)) in
    roundtripEncDec64 "$a0") = #(W64 (18446744073709551616 - 1)))) in
    do:  ("ok" <-[boolT] "$r0");;;
    return: (![boolT] "ok")).

(* go: first_class_function.go:3:6 *)
Definition FirstClassFunction : val :=
  rec: "FirstClassFunction" "a" :=
    exception_do (let: "a" := (ref_ty uint64T "a") in
    return: ((![uint64T] "a") + #(W64 10))).

(* go: first_class_function.go:7:6 *)
Definition ApplyF : val :=
  rec: "ApplyF" "a" "f" :=
    exception_do (let: "f" := (ref_ty funcT "f") in
    let: "a" := (ref_ty uint64T "a") in
    return: (let: "$a0" := (![uint64T] "a") in
     (![funcT] "f") "$a0")).

(* go: first_class_function.go:11:6 *)
Definition testFirstClassFunction : val :=
  rec: "testFirstClassFunction" <> :=
    exception_do (return: ((let: "$a0" := #(W64 1) in
     let: "$a1" := FirstClassFunction in
     ApplyF "$a0" "$a1") = #(W64 11))).

Definition Editor : go_type := structT [
  "s" :: sliceT;
  "next_val" :: uint64T
].

Definition Editor__mset : list (string * val) := [
].

(* advances the array editor, and returns the value it wrote, storing
   "next" in next_val

   go: function_ordering.go:11:18 *)
Definition Editor__AdvanceReturn : val :=
  rec: "Editor__AdvanceReturn" "e" "next" :=
    exception_do (let: "e" := (ref_ty ptrT "e") in
    let: "next" := (ref_ty uint64T "next") in
    let: "tmp" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (![uint64T] (struct.field_ref Editor "next_val" (![ptrT] "e"))) in
    do:  ("tmp" <-[uint64T] "$r0");;;
    let: "$r0" := (![uint64T] "tmp") in
    do:  ((slice.elem_ref uint64T (![sliceT] (struct.field_ref Editor "s" (![ptrT] "e"))) #(W64 0)) <-[uint64T] "$r0");;;
    let: "$r0" := (![uint64T] "next") in
    do:  ((struct.field_ref Editor "next_val" (![ptrT] "e")) <-[uint64T] "$r0");;;
    let: "$r0" := (let: "$s" := (![sliceT] (struct.field_ref Editor "s" (![ptrT] "e"))) in
    slice.slice uint64T "$s" #(W64 1) (slice.len "$s")) in
    do:  ((struct.field_ref Editor "s" (![ptrT] "e")) <-[sliceT] "$r0");;;
    return: (![uint64T] "tmp")).

Definition Editor__mset_ptr : list (string * val) := [
  ("AdvanceReturn", Editor__AdvanceReturn%V)
].

(* we call this function with side-effectful function calls as arguments,
   its implementation is unimportant

   go: function_ordering.go:21:6 *)
Definition addFour64 : val :=
  rec: "addFour64" "a" "b" "c" "d" :=
    exception_do (let: "d" := (ref_ty uint64T "d") in
    let: "c" := (ref_ty uint64T "c") in
    let: "b" := (ref_ty uint64T "b") in
    let: "a" := (ref_ty uint64T "a") in
    return: ((((![uint64T] "a") + (![uint64T] "b")) + (![uint64T] "c")) + (![uint64T] "d"))).

Definition Pair : go_type := structT [
  "x" :: uint64T;
  "y" :: uint64T
].

Definition Pair__mset : list (string * val) := [
].

Definition Pair__mset_ptr : list (string * val) := [
].

(* tests

   go: function_ordering.go:31:6 *)
Definition failing_testFunctionOrdering : val :=
  rec: "failing_testFunctionOrdering" <> :=
    exception_do (let: "arr" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (slice.make2 uint64T #(W64 5)) in
    do:  ("arr" <-[sliceT] "$r0");;;
    let: "e1" := (ref_ty Editor (zero_val Editor)) in
    let: "$r0" := (struct.make Editor [{
      "s" ::= let: "$s" := (![sliceT] "arr") in
      slice.slice uint64T "$s" #(W64 0) (slice.len "$s");
      "next_val" ::= #(W64 1)
    }]) in
    do:  ("e1" <-[Editor] "$r0");;;
    let: "e2" := (ref_ty Editor (zero_val Editor)) in
    let: "$r0" := (struct.make Editor [{
      "s" ::= let: "$s" := (![sliceT] "arr") in
      slice.slice uint64T "$s" #(W64 0) (slice.len "$s");
      "next_val" ::= #(W64 101)
    }]) in
    do:  ("e2" <-[Editor] "$r0");;;
    (if: ((let: "$a0" := #(W64 2) in
    (Editor__AdvanceReturn "e1") "$a0") + (let: "$a0" := #(W64 102) in
    (Editor__AdvanceReturn "e2") "$a0")) ≠ #(W64 102)
    then return: (#false)
    else do:  #());;;
    (if: (![uint64T] (slice.elem_ref uint64T (![sliceT] "arr") #(W64 0))) ≠ #(W64 101)
    then return: (#false)
    else do:  #());;;
    (if: (let: "$a0" := (let: "$a0" := #(W64 3) in
    (Editor__AdvanceReturn "e1") "$a0") in
    let: "$a1" := (let: "$a0" := #(W64 103) in
    (Editor__AdvanceReturn "e2") "$a0") in
    let: "$a2" := (let: "$a0" := #(W64 104) in
    (Editor__AdvanceReturn "e2") "$a0") in
    let: "$a3" := (let: "$a0" := #(W64 4) in
    (Editor__AdvanceReturn "e1") "$a0") in
    addFour64 "$a0" "$a1" "$a2" "$a3") ≠ #(W64 210)
    then return: (#false)
    else do:  #());;;
    (if: (![uint64T] (slice.elem_ref uint64T (![sliceT] "arr") #(W64 1))) ≠ #(W64 102)
    then return: (#false)
    else do:  #());;;
    (if: (![uint64T] (slice.elem_ref uint64T (![sliceT] "arr") #(W64 2))) ≠ #(W64 3)
    then return: (#false)
    else do:  #());;;
    let: "p" := (ref_ty Pair (zero_val Pair)) in
    let: "$r0" := (struct.make Pair [{
      "x" ::= let: "$a0" := #(W64 5) in
      (Editor__AdvanceReturn "e1") "$a0";
      "y" ::= let: "$a0" := #(W64 105) in
      (Editor__AdvanceReturn "e2") "$a0"
    }]) in
    do:  ("p" <-[Pair] "$r0");;;
    (if: (![uint64T] (slice.elem_ref uint64T (![sliceT] "arr") #(W64 3))) ≠ #(W64 104)
    then return: (#false)
    else do:  #());;;
    let: "q" := (ref_ty Pair (zero_val Pair)) in
    let: "$r0" := (struct.make Pair [{
      "y" ::= let: "$a0" := #(W64 6) in
      (Editor__AdvanceReturn "e1") "$a0";
      "x" ::= let: "$a0" := #(W64 106) in
      (Editor__AdvanceReturn "e2") "$a0"
    }]) in
    do:  ("q" <-[Pair] "$r0");;;
    (if: (![uint64T] (slice.elem_ref uint64T (![sliceT] "arr") #(W64 4))) ≠ #(W64 105)
    then return: (#false)
    else do:  #());;;
    return: (((![uint64T] (struct.field_ref Pair "x" "p")) + (![uint64T] (struct.field_ref Pair "x" "q"))) = #(W64 109))).

(* go: function_ordering.go:74:6 *)
Definition storeAndReturn : val :=
  rec: "storeAndReturn" "x" "v" :=
    exception_do (let: "v" := (ref_ty uint64T "v") in
    let: "x" := (ref_ty ptrT "x") in
    let: "$r0" := (![uint64T] "v") in
    do:  ((![ptrT] "x") <-[uint64T] "$r0");;;
    return: (![uint64T] "v")).

(* Goose has a right-to-left evaluation order for function arguments,
   which is incorrect.

   go: function_ordering.go:81:6 *)
Definition failing_testArgumentOrder : val :=
  rec: "failing_testArgumentOrder" <> :=
    exception_do (let: "x" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("x" <-[uint64T] "$r0");;;
    do:  (let: "$a0" := (let: "$a0" := "x" in
    let: "$a1" := #(W64 1) in
    storeAndReturn "$a0" "$a1") in
    let: "$a1" := (let: "$a0" := "x" in
    let: "$a1" := #(W64 2) in
    storeAndReturn "$a0" "$a1") in
    let: "$a2" := (let: "$a0" := "x" in
    let: "$a1" := #(W64 3) in
    storeAndReturn "$a0" "$a1") in
    let: "$a3" := (let: "$a0" := "x" in
    let: "$a1" := #(W64 4) in
    storeAndReturn "$a0" "$a1") in
    addFour64 "$a0" "$a1" "$a2" "$a3");;;
    let: "ok" := (ref_ty boolT (zero_val boolT)) in
    let: "$r0" := ((![uint64T] "x") = #(W64 4)) in
    do:  ("ok" <-[boolT] "$r0");;;
    return: (![boolT] "ok")).

(* go: int_conversions.go:3:6 *)
Definition testU64ToU32 : val :=
  rec: "testU64ToU32" <> :=
    exception_do (let: "ok" := (ref_ty boolT (zero_val boolT)) in
    let: "$r0" := #true in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "x" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := #(W64 1230) in
    do:  ("x" <-[uint64T] "$r0");;;
    let: "y" := (ref_ty uint32T (zero_val uint32T)) in
    let: "$r0" := #(W32 1230) in
    do:  ("y" <-[uint32T] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((to_u32 (![uint64T] "x")) = (![uint32T] "y"))) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((to_u64 (![uint32T] "y")) = (![uint64T] "x"))) in
    do:  ("ok" <-[boolT] "$r0");;;
    return: (![boolT] "ok")).

(* go: int_conversions.go:12:6 *)
Definition testU32Len : val :=
  rec: "testU32Len" <> :=
    exception_do (let: "s" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (slice.make2 byteT #(W64 100)) in
    do:  ("s" <-[sliceT] "$r0");;;
    return: ((to_u32 (let: "$a0" := (![sliceT] "s") in
     slice.len "$a0")) = #(W32 100))).

Definition Uint32 : go_type := uint32T.

Definition Uint32__mset : list (string * val) := [
].

Definition Uint32__mset_ptr : list (string * val) := [
].

(* https://github.com/goose-lang/goose/issues/14

   go: int_conversions.go:20:6 *)
Definition failing_testU32NewtypeLen : val :=
  rec: "failing_testU32NewtypeLen" <> :=
    exception_do (let: "s" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (slice.make2 byteT #(W64 20)) in
    do:  ("s" <-[sliceT] "$r0");;;
    return: ((to_u32 (let: "$a0" := (![sliceT] "s") in
     slice.len "$a0")) = #(W32 20))).

Definition geometryInterface : go_type := interfaceT.

(* go: interfaces.go:12:6 *)
Definition measureArea : val :=
  rec: "measureArea" "t" :=
    exception_do (let: "t" := (ref_ty geometryInterface "t") in
    return: ((interface.get "Square" (![geometryInterface] "t")) #())).

(* go: interfaces.go:16:6 *)
Definition measureVolumePlusNM : val :=
  rec: "measureVolumePlusNM" "t" "n" "m" :=
    exception_do (let: "m" := (ref_ty uint64T "m") in
    let: "n" := (ref_ty uint64T "n") in
    let: "t" := (ref_ty geometryInterface "t") in
    return: ((((interface.get "Volume" (![geometryInterface] "t")) #()) + (![uint64T] "n")) + (![uint64T] "m"))).

(* go: interfaces.go:20:6 *)
Definition measureVolume : val :=
  rec: "measureVolume" "t" :=
    exception_do (let: "t" := (ref_ty geometryInterface "t") in
    return: ((interface.get "Volume" (![geometryInterface] "t")) #())).

Definition SquareStruct : go_type := structT [
  "Side" :: uint64T
].

(* go: interfaces.go:28:23 *)
Definition SquareStruct__Square : val :=
  rec: "SquareStruct__Square" "t" <> :=
    exception_do (let: "t" := (ref_ty SquareStruct "t") in
    return: ((![uint64T] (struct.field_ref SquareStruct "Side" "t")) * (![uint64T] (struct.field_ref SquareStruct "Side" "t")))).

(* go: interfaces.go:32:23 *)
Definition SquareStruct__Volume : val :=
  rec: "SquareStruct__Volume" "t" <> :=
    exception_do (let: "t" := (ref_ty SquareStruct "t") in
    return: (((![uint64T] (struct.field_ref SquareStruct "Side" "t")) * (![uint64T] (struct.field_ref SquareStruct "Side" "t"))) * (![uint64T] (struct.field_ref SquareStruct "Side" "t")))).

Definition SquareStruct__mset : list (string * val) := [
  ("Square", SquareStruct__Square%V);
  ("Volume", SquareStruct__Volume%V)
].

Definition SquareStruct__mset_ptr : list (string * val) := [
  ("Square", (λ: "$recvAddr",
    SquareStruct__Square (![SquareStruct] "$recvAddr")
    )%V);
  ("Volume", (λ: "$recvAddr",
    SquareStruct__Volume (![SquareStruct] "$recvAddr")
    )%V)
].

(* go: interfaces.go:40:6 *)
Definition testBasicInterface : val :=
  rec: "testBasicInterface" <> :=
    exception_do (let: "s" := (ref_ty SquareStruct (zero_val SquareStruct)) in
    let: "$r0" := (struct.make SquareStruct [{
      "Side" ::= #(W64 2)
    }]) in
    do:  ("s" <-[SquareStruct] "$r0");;;
    return: ((let: "$a0" := (interface.make SquareStruct__mset (![SquareStruct] "s")) in
     measureArea "$a0") = #(W64 4))).

(* go: interfaces.go:47:6 *)
Definition testAssignInterface : val :=
  rec: "testAssignInterface" <> :=
    exception_do (let: "s" := (ref_ty SquareStruct (zero_val SquareStruct)) in
    let: "$r0" := (struct.make SquareStruct [{
      "Side" ::= #(W64 3)
    }]) in
    do:  ("s" <-[SquareStruct] "$r0");;;
    let: "area" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (let: "$a0" := (interface.make SquareStruct__mset (![SquareStruct] "s")) in
    measureArea "$a0") in
    do:  ("area" <-[uint64T] "$r0");;;
    return: ((![uint64T] "area") = #(W64 9))).

(* go: interfaces.go:55:6 *)
Definition testMultipleInterface : val :=
  rec: "testMultipleInterface" <> :=
    exception_do (let: "s" := (ref_ty SquareStruct (zero_val SquareStruct)) in
    let: "$r0" := (struct.make SquareStruct [{
      "Side" ::= #(W64 3)
    }]) in
    do:  ("s" <-[SquareStruct] "$r0");;;
    let: "square1" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (let: "$a0" := (interface.make SquareStruct__mset (![SquareStruct] "s")) in
    measureArea "$a0") in
    do:  ("square1" <-[uint64T] "$r0");;;
    let: "square2" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (let: "$a0" := (interface.make SquareStruct__mset (![SquareStruct] "s")) in
    measureArea "$a0") in
    do:  ("square2" <-[uint64T] "$r0");;;
    return: ((![uint64T] "square1") = (![uint64T] "square2"))).

(* go: interfaces.go:64:6 *)
Definition testBinaryExprInterface : val :=
  rec: "testBinaryExprInterface" <> :=
    exception_do (let: "s" := (ref_ty SquareStruct (zero_val SquareStruct)) in
    let: "$r0" := (struct.make SquareStruct [{
      "Side" ::= #(W64 3)
    }]) in
    do:  ("s" <-[SquareStruct] "$r0");;;
    let: "square1" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (let: "$a0" := (interface.make SquareStruct__mset (![SquareStruct] "s")) in
    measureArea "$a0") in
    do:  ("square1" <-[uint64T] "$r0");;;
    let: "square2" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (let: "$a0" := (interface.make SquareStruct__mset (![SquareStruct] "s")) in
    measureVolume "$a0") in
    do:  ("square2" <-[uint64T] "$r0");;;
    return: (((![uint64T] "square1") = (let: "$a0" := (interface.make SquareStruct__mset (![SquareStruct] "s")) in
     measureArea "$a0")) && ((![uint64T] "square2") = (let: "$a0" := (interface.make SquareStruct__mset (![SquareStruct] "s")) in
     measureVolume "$a0")))).

(* go: interfaces.go:73:6 *)
Definition testIfStmtInterface : val :=
  rec: "testIfStmtInterface" <> :=
    exception_do (let: "s" := (ref_ty SquareStruct (zero_val SquareStruct)) in
    let: "$r0" := (struct.make SquareStruct [{
      "Side" ::= #(W64 3)
    }]) in
    do:  ("s" <-[SquareStruct] "$r0");;;
    (if: (let: "$a0" := (interface.make SquareStruct__mset (![SquareStruct] "s")) in
    measureArea "$a0") = #(W64 9)
    then return: (#true)
    else do:  #());;;
    return: (#false)).

(* We can't interpret multithreaded code, so this just checks that
   locks are correctly interpreted

   go: lock.go:7:6 *)
Definition testsUseLocks : val :=
  rec: "testsUseLocks" <> :=
    exception_do (let: "m" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty sync.Mutex (zero_val sync.Mutex)) in
    do:  ("m" <-[ptrT] "$r0");;;
    do:  ((sync.Mutex__Lock (![ptrT] "m")) #());;;
    do:  ((sync.Mutex__Unlock (![ptrT] "m")) #());;;
    return: (#true)).

(* helpers

   go: loops.go:4:6 *)
Definition standardForLoop : val :=
  rec: "standardForLoop" "s" :=
    exception_do (let: "s" := (ref_ty sliceT "s") in
    let: "sumPtr" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty uint64T (zero_val uint64T)) in
    do:  ("sumPtr" <-[ptrT] "$r0");;;
    (let: "i" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[uint64T] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      (if: (![uint64T] "i") < (let: "$a0" := (![sliceT] "s") in
      slice.len "$a0")
      then
        let: "sum" := (ref_ty uint64T (zero_val uint64T)) in
        let: "$r0" := (![uint64T] (![ptrT] "sumPtr")) in
        do:  ("sum" <-[uint64T] "$r0");;;
        let: "x" := (ref_ty uint64T (zero_val uint64T)) in
        let: "$r0" := (![uint64T] (slice.elem_ref uint64T (![sliceT] "s") (![uint64T] "i"))) in
        do:  ("x" <-[uint64T] "$r0");;;
        let: "$r0" := ((![uint64T] "sum") + (![uint64T] "x")) in
        do:  ((![ptrT] "sumPtr") <-[uint64T] "$r0");;;
        let: "$r0" := ((![uint64T] "i") + #(W64 1)) in
        do:  ("i" <-[uint64T] "$r0");;;
        continue: #()
      else do:  #());;;
      break: #()));;;
    let: "sum" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (![uint64T] (![ptrT] "sumPtr")) in
    do:  ("sum" <-[uint64T] "$r0");;;
    return: (![uint64T] "sum")).

Definition LoopStruct : go_type := structT [
  "loopNext" :: ptrT
].

(* go: loops.go:28:22 *)
Definition LoopStruct__forLoopWait : val :=
  rec: "LoopStruct__forLoopWait" "ls" "i" :=
    exception_do (let: "ls" := (ref_ty LoopStruct "ls") in
    let: "i" := (ref_ty uint64T "i") in
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "nxt" := (ref_ty ptrT (zero_val ptrT)) in
      let: "$r0" := (![ptrT] (struct.field_ref LoopStruct "loopNext" "ls")) in
      do:  ("nxt" <-[ptrT] "$r0");;;
      (if: (![uint64T] "i") < (![uint64T] (![ptrT] "nxt"))
      then break: #()
      else do:  #());;;
      let: "$r0" := ((![uint64T] (![ptrT] (struct.field_ref LoopStruct "loopNext" "ls"))) + #(W64 1)) in
      do:  ((![ptrT] (struct.field_ref LoopStruct "loopNext" "ls")) <-[uint64T] "$r0");;;
      continue: #())).

Definition LoopStruct__mset : list (string * val) := [
  ("forLoopWait", LoopStruct__forLoopWait%V)
].

Definition LoopStruct__mset_ptr : list (string * val) := [
  ("forLoopWait", (λ: "$recvAddr",
    LoopStruct__forLoopWait (![LoopStruct] "$recvAddr")
    )%V)
].

(* tests

   go: loops.go:40:6 *)
Definition testStandardForLoop : val :=
  rec: "testStandardForLoop" <> :=
    exception_do (let: "arr" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (slice.make2 uint64T #(W64 4)) in
    do:  ("arr" <-[sliceT] "$r0");;;
    do:  ((slice.elem_ref uint64T (![sliceT] "arr") #(W64 0)) <-[uint64T] ((![uint64T] (slice.elem_ref uint64T (![sliceT] "arr") #(W64 0))) + #(W64 1)));;;
    do:  ((slice.elem_ref uint64T (![sliceT] "arr") #(W64 1)) <-[uint64T] ((![uint64T] (slice.elem_ref uint64T (![sliceT] "arr") #(W64 1))) + #(W64 3)));;;
    do:  ((slice.elem_ref uint64T (![sliceT] "arr") #(W64 2)) <-[uint64T] ((![uint64T] (slice.elem_ref uint64T (![sliceT] "arr") #(W64 2))) + #(W64 5)));;;
    do:  ((slice.elem_ref uint64T (![sliceT] "arr") #(W64 3)) <-[uint64T] ((![uint64T] (slice.elem_ref uint64T (![sliceT] "arr") #(W64 3))) + #(W64 7)));;;
    return: ((let: "$a0" := (![sliceT] "arr") in
     standardForLoop "$a0") = #(W64 16))).

(* go: loops.go:49:6 *)
Definition testForLoopWait : val :=
  rec: "testForLoopWait" <> :=
    exception_do (let: "ls" := (ref_ty LoopStruct (zero_val LoopStruct)) in
    let: "$r0" := (struct.make LoopStruct [{
      "loopNext" ::= ref_ty uint64T (zero_val uint64T)
    }]) in
    do:  ("ls" <-[LoopStruct] "$r0");;;
    do:  (let: "$a0" := #(W64 3) in
    (LoopStruct__forLoopWait (![LoopStruct] "ls")) "$a0");;;
    return: ((![uint64T] (![ptrT] (struct.field_ref LoopStruct "loopNext" "ls"))) = #(W64 4))).

(* go: loops.go:59:6 *)
Definition testBreakFromLoopWithContinue : val :=
  rec: "testBreakFromLoopWithContinue" <> :=
    exception_do (let: "i" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[uint64T] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      (if: #true
      then
        let: "$r0" := ((![uint64T] "i") + #(W64 1)) in
        do:  ("i" <-[uint64T] "$r0");;;
        break: #()
      else do:  #());;;
      continue: #());;;
    return: ((![uint64T] "i") = #(W64 1))).

(* go: loops.go:71:6 *)
Definition testBreakFromLoopNoContinue : val :=
  rec: "testBreakFromLoopNoContinue" <> :=
    exception_do (let: "i" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[uint64T] "$r0");;;
    (for: (λ: <>, (![uint64T] "i") < #(W64 3)); (λ: <>, Skip) := λ: <>,
      (if: #true
      then
        let: "$r0" := ((![uint64T] "i") + #(W64 1)) in
        do:  ("i" <-[uint64T] "$r0");;;
        break: #()
      else do:  #());;;
      let: "$r0" := ((![uint64T] "i") + #(W64 2)) in
      do:  ("i" <-[uint64T] "$r0"));;;
    return: ((![uint64T] "i") = #(W64 1))).

(* go: loops.go:83:6 *)
Definition testBreakFromLoopNoContinueDouble : val :=
  rec: "testBreakFromLoopNoContinueDouble" <> :=
    exception_do (let: "i" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[uint64T] "$r0");;;
    (for: (λ: <>, (![uint64T] "i") < #(W64 3)); (λ: <>, Skip) := λ: <>,
      (if: (![uint64T] "i") = #(W64 1)
      then
        let: "$r0" := ((![uint64T] "i") + #(W64 1)) in
        do:  ("i" <-[uint64T] "$r0");;;
        break: #()
      else do:  #());;;
      let: "$r0" := ((![uint64T] "i") + #(W64 2)) in
      do:  ("i" <-[uint64T] "$r0");;;
      let: "$r0" := ((![uint64T] "i") + #(W64 2)) in
      do:  ("i" <-[uint64T] "$r0"));;;
    return: ((![uint64T] "i") = #(W64 4))).

(* go: loops.go:96:6 *)
Definition testBreakFromLoopForOnly : val :=
  rec: "testBreakFromLoopForOnly" <> :=
    exception_do (let: "i" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[uint64T] "$r0");;;
    (for: (λ: <>, (![uint64T] "i") < #(W64 3)); (λ: <>, Skip) := λ: <>,
      let: "$r0" := ((![uint64T] "i") + #(W64 2)) in
      do:  ("i" <-[uint64T] "$r0"));;;
    return: ((![uint64T] "i") = #(W64 4))).

(* go: loops.go:104:6 *)
Definition testBreakFromLoopAssignAndContinue : val :=
  rec: "testBreakFromLoopAssignAndContinue" <> :=
    exception_do (let: "i" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[uint64T] "$r0");;;
    (for: (λ: <>, (![uint64T] "i") < #(W64 3)); (λ: <>, Skip) := λ: <>,
      (if: #true
      then
        let: "$r0" := ((![uint64T] "i") + #(W64 1)) in
        do:  ("i" <-[uint64T] "$r0");;;
        break: #()
      else do:  #());;;
      let: "$r0" := ((![uint64T] "i") + #(W64 2)) in
      do:  ("i" <-[uint64T] "$r0");;;
      continue: #());;;
    return: ((![uint64T] "i") = #(W64 1))).

(* go: loops.go:117:6 *)
Definition testNestedLoops : val :=
  rec: "testNestedLoops" <> :=
    exception_do (let: "ok1" := (ref_ty boolT (zero_val boolT)) in
    let: "$r0" := #false in
    do:  ("ok1" <-[boolT] "$r0");;;
    let: "ok2" := (ref_ty boolT (zero_val boolT)) in
    let: "$r0" := #false in
    do:  ("ok2" <-[boolT] "$r0");;;
    (let: "i" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[uint64T] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      (let: "j" := (ref_ty uint64T (zero_val uint64T)) in
      let: "$r0" := #(W64 0) in
      do:  ("j" <-[uint64T] "$r0");;;
      (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
        (if: (![uint64T] "j") > #(W64 5)
        then break: #()
        else do:  #());;;
        let: "$r0" := ((![uint64T] "j") + #(W64 1)) in
        do:  ("j" <-[uint64T] "$r0");;;
        let: "$r0" := ((![uint64T] "j") = #(W64 6)) in
        do:  ("ok1" <-[boolT] "$r0");;;
        continue: #()));;;
      let: "$r0" := ((![uint64T] "i") + #(W64 1)) in
      do:  ("i" <-[uint64T] "$r0");;;
      let: "$r0" := ((![uint64T] "i") = #(W64 1)) in
      do:  ("ok2" <-[boolT] "$r0");;;
      break: #()));;;
    return: ((![boolT] "ok1") && (![boolT] "ok2"))).

(* go: loops.go:136:6 *)
Definition testNestedGoStyleLoops : val :=
  rec: "testNestedGoStyleLoops" <> :=
    exception_do (let: "ok" := (ref_ty boolT (zero_val boolT)) in
    let: "$r0" := #false in
    do:  ("ok" <-[boolT] "$r0");;;
    (let: "i" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[uint64T] "$r0");;;
    (for: (λ: <>, (![uint64T] "i") < #(W64 10)); (λ: <>, do:  ("i" <-[uint64T] ((![uint64T] "i") + #(W64 1)))) := λ: <>,
      (let: "j" := (ref_ty uint64T (zero_val uint64T)) in
      let: "$r0" := #(W64 0) in
      do:  ("j" <-[uint64T] "$r0");;;
      (for: (λ: <>, (![uint64T] "j") < (![uint64T] "i")); (λ: <>, do:  ("j" <-[uint64T] ((![uint64T] "j") + #(W64 1)))) := λ: <>,
        (if: #true
        then break: #()
        else do:  #());;;
        continue: #()));;;
      let: "$r0" := ((![uint64T] "i") = #(W64 9)) in
      do:  ("ok" <-[boolT] "$r0")));;;
    return: (![boolT] "ok")).

(* go: loops.go:150:6 *)
Definition testNestedGoStyleLoopsNoComparison : val :=
  rec: "testNestedGoStyleLoopsNoComparison" <> :=
    exception_do (let: "ok" := (ref_ty boolT (zero_val boolT)) in
    let: "$r0" := #false in
    do:  ("ok" <-[boolT] "$r0");;;
    (let: "i" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[uint64T] "$r0");;;
    (for: (λ: <>, (![uint64T] "i") < #(W64 10)); (λ: <>, do:  ("i" <-[uint64T] ((![uint64T] "i") + #(W64 1)))) := λ: <>,
      (let: "j" := (ref_ty uint64T (zero_val uint64T)) in
      let: "$r0" := #(W64 0) in
      do:  ("j" <-[uint64T] "$r0");;;
      (for: (λ: <>, (![uint64T] "j") < (![uint64T] "i")); (λ: <>, do:  ("j" <-[uint64T] ((![uint64T] "j") + #(W64 1)))) := λ: <>,
        (if: #true
        then break: #()
        else do:  #());;;
        continue: #()));;;
      let: "$r0" := ((![uint64T] "i") = #(W64 9)) in
      do:  ("ok" <-[boolT] "$r0")));;;
    return: (![boolT] "ok")).

(* go: maps.go:3:6 *)
Definition IterateMapKeys : val :=
  rec: "IterateMapKeys" "m" :=
    exception_do (let: "m" := (ref_ty (mapT uint64T uint64T) "m") in
    let: "sum" := (ref_ty uint64T (zero_val uint64T)) in
    do:  (map.for_range (![mapT uint64T uint64T] "m") (λ: "k" <>,
      let: "$r0" := ((![uint64T] "sum") + (![uint64T] "k")) in
      do:  ("sum" <-[uint64T] "$r0")));;;
    return: (![uint64T] "sum")).

(* go: maps.go:11:6 *)
Definition IterateMapValues : val :=
  rec: "IterateMapValues" "m" :=
    exception_do (let: "m" := (ref_ty (mapT uint64T uint64T) "m") in
    let: "sum" := (ref_ty uint64T (zero_val uint64T)) in
    do:  (map.for_range (![mapT uint64T uint64T] "m") (λ: <> "v",
      let: "$r0" := ((![uint64T] "sum") + (![uint64T] "v")) in
      do:  ("sum" <-[uint64T] "$r0")));;;
    return: (![uint64T] "sum")).

(* go: maps.go:19:6 *)
Definition testIterateMap : val :=
  rec: "testIterateMap" <> :=
    exception_do (let: "ok" := (ref_ty boolT (zero_val boolT)) in
    let: "$r0" := #true in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "m" := (ref_ty (mapT uint64T uint64T) (zero_val (mapT uint64T uint64T))) in
    let: "$r0" := (map.make uint64T uint64T #()) in
    do:  ("m" <-[mapT uint64T uint64T] "$r0");;;
    let: "$r0" := #(W64 1) in
    do:  (map.insert (![mapT uint64T uint64T] "m") #(W64 0) "$r0");;;
    let: "$r0" := #(W64 2) in
    do:  (map.insert (![mapT uint64T uint64T] "m") #(W64 1) "$r0");;;
    let: "$r0" := #(W64 4) in
    do:  (map.insert (![mapT uint64T uint64T] "m") #(W64 3) "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((let: "$a0" := (![mapT uint64T uint64T] "m") in
    IterateMapKeys "$a0") = #(W64 4))) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((let: "$a0" := (![mapT uint64T uint64T] "m") in
    IterateMapValues "$a0") = #(W64 7))) in
    do:  ("ok" <-[boolT] "$r0");;;
    return: (![boolT] "ok")).

(* go: maps.go:37:6 *)
Definition testMapSize : val :=
  rec: "testMapSize" <> :=
    exception_do (let: "ok" := (ref_ty boolT (zero_val boolT)) in
    let: "$r0" := #true in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "m" := (ref_ty (mapT uint64T uint64T) (zero_val (mapT uint64T uint64T))) in
    let: "$r0" := (map.make uint64T uint64T #()) in
    do:  ("m" <-[mapT uint64T uint64T] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((let: "$a0" := (![mapT uint64T uint64T] "m") in
    map.len "$a0") = #(W64 0))) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := #(W64 1) in
    do:  (map.insert (![mapT uint64T uint64T] "m") #(W64 0) "$r0");;;
    let: "$r0" := #(W64 2) in
    do:  (map.insert (![mapT uint64T uint64T] "m") #(W64 1) "$r0");;;
    let: "$r0" := #(W64 4) in
    do:  (map.insert (![mapT uint64T uint64T] "m") #(W64 3) "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((let: "$a0" := (![mapT uint64T uint64T] "m") in
    map.len "$a0") = #(W64 3))) in
    do:  ("ok" <-[boolT] "$r0");;;
    return: (![boolT] "ok")).

(* go: multiple_assign.go:3:6 *)
Definition multReturnTwo : val :=
  rec: "multReturnTwo" <> :=
    exception_do (return: (#(W64 2), #(W64 3))).

(* go: multiple_assign.go:7:6 *)
Definition testAssignTwo : val :=
  rec: "testAssignTwo" <> :=
    exception_do (let: "x" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := #(W64 10) in
    do:  ("x" <-[uint64T] "$r0");;;
    let: "y" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := #(W64 15) in
    do:  ("y" <-[uint64T] "$r0");;;
    let: ("$ret0", "$ret1") := (multReturnTwo #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("x" <-[uint64T] "$r0");;;
    do:  ("y" <-[uint64T] "$r1");;;
    return: (((![uint64T] "x") = #(W64 2)) && ((![uint64T] "y") = #(W64 3)))).

(* go: multiple_assign.go:14:6 *)
Definition multReturnThree : val :=
  rec: "multReturnThree" <> :=
    exception_do (return: (#(W64 2), #true, #(W32 1))).

(* go: multiple_assign.go:18:6 *)
Definition testAssignThree : val :=
  rec: "testAssignThree" <> :=
    exception_do (let: "x" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := #(W64 10) in
    do:  ("x" <-[uint64T] "$r0");;;
    let: "y" := (ref_ty boolT (zero_val boolT)) in
    let: "$r0" := #false in
    do:  ("y" <-[boolT] "$r0");;;
    let: "z" := (ref_ty uint32T (zero_val uint32T)) in
    let: "$r0" := #(W32 15) in
    do:  ("z" <-[uint32T] "$r0");;;
    let: (("$ret0", "$ret1"), "$ret2") := (multReturnThree #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("x" <-[uint64T] "$r0");;;
    do:  ("y" <-[boolT] "$r1");;;
    do:  ("z" <-[uint32T] "$r2");;;
    return: ((((![uint64T] "x") = #(W64 2)) && ((![boolT] "y") = #true)) && ((![uint32T] "z") = #(W32 1)))).

(* go: multiple_assign.go:26:6 *)
Definition testMultipleAssignToMap : val :=
  rec: "testMultipleAssignToMap" <> :=
    exception_do (let: "x" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := #(W64 10) in
    do:  ("x" <-[uint64T] "$r0");;;
    let: "m" := (ref_ty (mapT uint64T uint64T) (zero_val (mapT uint64T uint64T))) in
    let: "$r0" := (map.make uint64T uint64T #()) in
    do:  ("m" <-[mapT uint64T uint64T] "$r0");;;
    let: ("$ret0", "$ret1") := (multReturnTwo #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("x" <-[uint64T] "$r0");;;
    do:  (map.insert (![mapT uint64T uint64T] "m") #(W64 0) "$r1");;;
    return: (((![uint64T] "x") = #(W64 2)) && ((Fst (map.get (![mapT uint64T uint64T] "m") #(W64 0))) = #(W64 3)))).

(* go: multiple_return.go:3:6 *)
Definition returnTwo : val :=
  rec: "returnTwo" <> :=
    exception_do (return: (#(W64 2), #(W64 3))).

(* go: multiple_return.go:7:6 *)
Definition testReturnTwo : val :=
  rec: "testReturnTwo" <> :=
    exception_do (let: "y" := (ref_ty uint64T (zero_val uint64T)) in
    let: "x" := (ref_ty uint64T (zero_val uint64T)) in
    let: ("$ret0", "$ret1") := (returnTwo #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("x" <-[uint64T] "$r0");;;
    do:  ("y" <-[uint64T] "$r1");;;
    return: (((![uint64T] "x") = #(W64 2)) && ((![uint64T] "y") = #(W64 3)))).

(* go: multiple_return.go:12:6 *)
Definition testAnonymousBinding : val :=
  rec: "testAnonymousBinding" <> :=
    exception_do (let: "y" := (ref_ty uint64T (zero_val uint64T)) in
    let: ("$ret0", "$ret1") := (returnTwo #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  "$r0";;;
    do:  ("y" <-[uint64T] "$r1");;;
    return: ((![uint64T] "y") = #(W64 3))).

(* go: multiple_return.go:17:6 *)
Definition returnThree : val :=
  rec: "returnThree" <> :=
    exception_do (return: (#(W64 2), #true, #(W32 1))).

(* go: multiple_return.go:21:6 *)
Definition testReturnThree : val :=
  rec: "testReturnThree" <> :=
    exception_do (let: "z" := (ref_ty uint32T (zero_val uint32T)) in
    let: "y" := (ref_ty boolT (zero_val boolT)) in
    let: "x" := (ref_ty uint64T (zero_val uint64T)) in
    let: (("$ret0", "$ret1"), "$ret2") := (returnThree #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("x" <-[uint64T] "$r0");;;
    do:  ("y" <-[boolT] "$r1");;;
    do:  ("z" <-[uint32T] "$r2");;;
    return: ((((![uint64T] "x") = #(W64 2)) && ((![boolT] "y") = #true)) && ((![uint32T] "z") = #(W32 1)))).

(* go: multiple_return.go:26:6 *)
Definition returnFour : val :=
  rec: "returnFour" <> :=
    exception_do (return: (#(W64 2), #true, #(W32 1), #(W64 7))).

(* go: multiple_return.go:30:6 *)
Definition testReturnFour : val :=
  rec: "testReturnFour" <> :=
    exception_do (let: "w" := (ref_ty uint64T (zero_val uint64T)) in
    let: "z" := (ref_ty uint32T (zero_val uint32T)) in
    let: "y" := (ref_ty boolT (zero_val boolT)) in
    let: "x" := (ref_ty uint64T (zero_val uint64T)) in
    let: ((("$ret0", "$ret1"), "$ret2"), "$ret3") := (returnFour #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    let: "$r3" := "$ret3" in
    do:  ("x" <-[uint64T] "$r0");;;
    do:  ("y" <-[boolT] "$r1");;;
    do:  ("z" <-[uint32T] "$r2");;;
    do:  ("w" <-[uint64T] "$r3");;;
    return: (((((![uint64T] "x") = #(W64 2)) && ((![boolT] "y") = #true)) && ((![uint32T] "z") = #(W32 1))) && ((![uint64T] "w") = #(W64 7)))).

(* go: nil.go:3:6 *)
Definition failing_testCompareSliceToNil : val :=
  rec: "failing_testCompareSliceToNil" <> :=
    exception_do (let: "s" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (slice.make2 byteT #(W64 0)) in
    do:  ("s" <-[sliceT] "$r0");;;
    return: ((![sliceT] "s") ≠ #slice.nil)).

(* go: nil.go:8:6 *)
Definition testComparePointerToNil : val :=
  rec: "testComparePointerToNil" <> :=
    exception_do (let: "s" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty uint64T (zero_val uint64T)) in
    do:  ("s" <-[ptrT] "$r0");;;
    return: ((![ptrT] "s") ≠ #null)).

(* go: nil.go:13:6 *)
Definition testCompareNilToNil : val :=
  rec: "testCompareNilToNil" <> :=
    exception_do (let: "s" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty ptrT (zero_val ptrT)) in
    do:  ("s" <-[ptrT] "$r0");;;
    return: ((![ptrT] (![ptrT] "s")) = #null)).

(* go: nil.go:18:6 *)
Definition testComparePointerWrappedToNil : val :=
  rec: "testComparePointerWrappedToNil" <> :=
    exception_do (let: "s" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (slice.make2 byteT #(W64 1)) in
    do:  ("s" <-[sliceT] "$r0");;;
    return: ((![sliceT] "s") ≠ #slice.nil)).

(* go: nil.go:24:6 *)
Definition testComparePointerWrappedDefaultToNil : val :=
  rec: "testComparePointerWrappedDefaultToNil" <> :=
    exception_do (let: "s" := (ref_ty sliceT (zero_val sliceT)) in
    return: ((![sliceT] "s") = #slice.nil)).

(* helpers

   go: operations.go:4:6 *)
Definition reverseAssignOps64 : val :=
  rec: "reverseAssignOps64" "x" :=
    exception_do (let: "x" := (ref_ty uint64T "x") in
    let: "y" := (ref_ty uint64T (zero_val uint64T)) in
    do:  ("y" <-[uint64T] ((![uint64T] "y") + (![uint64T] "x")));;;
    do:  ("y" <-[uint64T] ((![uint64T] "y") - (![uint64T] "x")));;;
    do:  ("y" <-[uint64T] ((![uint64T] "y") + #(W64 1)));;;
    do:  ("y" <-[uint64T] ((![uint64T] "y") - #(W64 1)));;;
    return: (![uint64T] "y")).

(* go: operations.go:13:6 *)
Definition reverseAssignOps32 : val :=
  rec: "reverseAssignOps32" "x" :=
    exception_do (let: "x" := (ref_ty uint32T "x") in
    let: "y" := (ref_ty uint32T (zero_val uint32T)) in
    do:  ("y" <-[uint32T] ((![uint32T] "y") + (![uint32T] "x")));;;
    do:  ("y" <-[uint32T] ((![uint32T] "y") - (![uint32T] "x")));;;
    do:  ("y" <-[uint32T] ((![uint32T] "y") + #(W64 1)));;;
    do:  ("y" <-[uint32T] ((![uint32T] "y") - #(W64 1)));;;
    return: (![uint32T] "y")).

(* go: operations.go:22:6 *)
Definition add64Equals : val :=
  rec: "add64Equals" "x" "y" "z" :=
    exception_do (let: "z" := (ref_ty uint64T "z") in
    let: "y" := (ref_ty uint64T "y") in
    let: "x" := (ref_ty uint64T "x") in
    return: (((![uint64T] "x") + (![uint64T] "y")) = (![uint64T] "z"))).

(* go: operations.go:26:6 *)
Definition sub64Equals : val :=
  rec: "sub64Equals" "x" "y" "z" :=
    exception_do (let: "z" := (ref_ty uint64T "z") in
    let: "y" := (ref_ty uint64T "y") in
    let: "x" := (ref_ty uint64T "x") in
    return: (((![uint64T] "x") - (![uint64T] "y")) = (![uint64T] "z"))).

(* tests

   go: operations.go:31:6 *)
Definition testReverseAssignOps64 : val :=
  rec: "testReverseAssignOps64" <> :=
    exception_do (let: "ok" := (ref_ty boolT (zero_val boolT)) in
    let: "$r0" := #true in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((let: "$a0" := #(W64 0) in
    reverseAssignOps64 "$a0") = #(W64 0))) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((let: "$a0" := #(W64 1) in
    reverseAssignOps64 "$a0") = #(W64 0))) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((let: "$a0" := #(W64 1231234) in
    reverseAssignOps64 "$a0") = #(W64 0))) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((let: "$a0" := #(W64 62206846038638762) in
    reverseAssignOps64 "$a0") = #(W64 0))) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((let: "$a0" := #(W64 9223372036854775808) in
    reverseAssignOps64 "$a0") = #(W64 0))) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((let: "$a0" := #(W64 140737488355328) in
    reverseAssignOps64 "$a0") = #(W64 0))) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((let: "$a0" := #(W64 1048576) in
    reverseAssignOps64 "$a0") = #(W64 0))) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((let: "$a0" := #(W64 262144) in
    reverseAssignOps64 "$a0") = #(W64 0))) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((let: "$a0" := #(W64 1024) in
    reverseAssignOps64 "$a0") = #(W64 0))) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((let: "$a0" := #(W64 1) in
    reverseAssignOps64 "$a0") = #(W64 0))) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((let: "$a0" := #(W64 (18446744073709551616 - 1)) in
    reverseAssignOps64 "$a0") = #(W64 0))) in
    do:  ("ok" <-[boolT] "$r0");;;
    return: (![boolT] "ok")).

(* go: operations.go:47:6 *)
Definition failing_testReverseAssignOps32 : val :=
  rec: "failing_testReverseAssignOps32" <> :=
    exception_do (let: "ok" := (ref_ty boolT (zero_val boolT)) in
    let: "$r0" := #true in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((let: "$a0" := #(W32 0) in
    reverseAssignOps32 "$a0") = #(W32 0))) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((let: "$a0" := #(W32 1) in
    reverseAssignOps32 "$a0") = #(W32 0))) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((let: "$a0" := #(W32 1231234) in
    reverseAssignOps32 "$a0") = #(W32 0))) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((let: "$a0" := #(W32 3434807466) in
    reverseAssignOps32 "$a0") = #(W32 0))) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((let: "$a0" := #(W32 1048576) in
    reverseAssignOps32 "$a0") = #(W32 0))) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((let: "$a0" := #(W32 262144) in
    reverseAssignOps32 "$a0") = #(W32 0))) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((let: "$a0" := #(W32 1024) in
    reverseAssignOps32 "$a0") = #(W32 0))) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((let: "$a0" := #(W32 1) in
    reverseAssignOps32 "$a0") = #(W32 0))) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((let: "$a0" := #(W32 (4294967296 - 1)) in
    reverseAssignOps32 "$a0") = #(W32 0))) in
    do:  ("ok" <-[boolT] "$r0");;;
    return: (![boolT] "ok")).

(* go: operations.go:61:6 *)
Definition testAdd64Equals : val :=
  rec: "testAdd64Equals" <> :=
    exception_do (let: "ok" := (ref_ty boolT (zero_val boolT)) in
    let: "$r0" := #true in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && (let: "$a0" := #(W64 2) in
    let: "$a1" := #(W64 3) in
    let: "$a2" := #(W64 5) in
    add64Equals "$a0" "$a1" "$a2")) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && (let: "$a0" := #(W64 (18446744073709551616 - 1)) in
    let: "$a1" := #(W64 1) in
    let: "$a2" := #(W64 0) in
    add64Equals "$a0" "$a1" "$a2")) in
    do:  ("ok" <-[boolT] "$r0");;;
    return: (![boolT] "ok")).

(* go: operations.go:68:6 *)
Definition testSub64Equals : val :=
  rec: "testSub64Equals" <> :=
    exception_do (let: "ok" := (ref_ty boolT (zero_val boolT)) in
    let: "$r0" := #true in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && (let: "$a0" := #(W64 2) in
    let: "$a1" := #(W64 1) in
    let: "$a2" := #(W64 1) in
    sub64Equals "$a0" "$a1" "$a2")) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && (let: "$a0" := #(W64 (18446744073709551616 - 1)) in
    let: "$a1" := #(W64 9223372036854775808) in
    let: "$a2" := #(W64 (9223372036854775808 - 1)) in
    sub64Equals "$a0" "$a1" "$a2")) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && (let: "$a0" := #(W64 2) in
    let: "$a1" := #(W64 8) in
    let: "$a2" := #(W64 (18446744073709551616 - 6)) in
    sub64Equals "$a0" "$a1" "$a2")) in
    do:  ("ok" <-[boolT] "$r0");;;
    return: (![boolT] "ok")).

(* go: operations.go:76:6 *)
Definition testDivisionPrecedence : val :=
  rec: "testDivisionPrecedence" <> :=
    exception_do (let: "blockSize" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := #(W64 4096) in
    do:  ("blockSize" <-[uint64T] "$r0");;;
    let: "hdrmeta" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := #(W64 8) in
    do:  ("hdrmeta" <-[uint64T] "$r0");;;
    let: "hdraddrs" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (((![uint64T] "blockSize") - (![uint64T] "hdrmeta")) `quot` #(W64 8)) in
    do:  ("hdraddrs" <-[uint64T] "$r0");;;
    return: ((![uint64T] "hdraddrs") = #(W64 511))).

(* go: operations.go:83:6 *)
Definition testModPrecedence : val :=
  rec: "testModPrecedence" <> :=
    exception_do (let: "x1" := (ref_ty intT (zero_val intT)) in
    let: "$r0" := #(W64 (513 + (12 `rem` 8))) in
    do:  ("x1" <-[intT] "$r0");;;
    let: "x2" := (ref_ty intT (zero_val intT)) in
    let: "$r0" := #(W64 ((513 + 12) `rem` 8)) in
    do:  ("x2" <-[intT] "$r0");;;
    return: (((![intT] "x1") = #(W64 517)) && ((![intT] "x2") = #(W64 5)))).

(* go: operations.go:89:6 *)
Definition testBitwiseOpsPrecedence : val :=
  rec: "testBitwiseOpsPrecedence" <> :=
    exception_do (let: "ok" := (ref_ty boolT (zero_val boolT)) in
    let: "$r0" := #true in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && #(479 =? 479)) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && #(132 =? 132)) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && #(828 =? 828)) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && #(893 =? 893)) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && #(461 =? 461)) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && #(negb (479 =? 389))) in
    do:  ("ok" <-[boolT] "$r0");;;
    return: (![boolT] "ok")).

(* go: operations.go:102:6 *)
Definition testArithmeticShifts : val :=
  rec: "testArithmeticShifts" <> :=
    exception_do (let: "ok" := (ref_ty boolT (zero_val boolT)) in
    let: "$r0" := #true in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && #(5376 =? 5376)) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && #(1513209474796486656 =? 1513209474796486656)) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && #(42 =? 42)) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && #(0 =? 0)) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && #(672 =? 672)) in
    do:  ("ok" <-[boolT] "$r0");;;
    return: (![boolT] "ok")).

(* go: operations.go:114:6 *)
Definition testBitAddAnd : val :=
  rec: "testBitAddAnd" <> :=
    exception_do (let: "tid" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := #(W64 17) in
    do:  ("tid" <-[uint64T] "$r0");;;
    let: "n" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := #(W64 16) in
    do:  ("n" <-[uint64T] "$r0");;;
    return: ((((![uint64T] "tid") + (![uint64T] "n")) `and` (~ ((![uint64T] "n") - #(W64 1)))) = #(W64 32))).

(* go: operations.go:120:6 *)
Definition testManyParentheses : val :=
  rec: "testManyParentheses" <> :=
    exception_do (return: (#((3 * 6) =? (3 * 6)))).

(* go: operations.go:124:6 *)
Definition testPlusTimes : val :=
  rec: "testPlusTimes" <> :=
    exception_do (return: (#(((2 + 5) * 2) =? 14))).

(* go: precedence.go:3:6 *)
Definition testOrCompareSimple : val :=
  rec: "testOrCompareSimple" <> :=
    exception_do ((if: #(3 >? 4) || #(4 >? 3)
    then return: (#true)
    else do:  #());;;
    return: (#false)).

(* go: precedence.go:10:6 *)
Definition testOrCompare : val :=
  rec: "testOrCompare" <> :=
    exception_do (let: "ok" := (ref_ty boolT (zero_val boolT)) in
    let: "$r0" := #true in
    do:  ("ok" <-[boolT] "$r0");;;
    (if: (~ (#(3 >? 4) || #(4 >? 3)))
    then
      let: "$r0" := #false in
      do:  ("ok" <-[boolT] "$r0")
    else do:  #());;;
    (if: #(4 <? 3) || #(2 >? 3)
    then
      let: "$r0" := #false in
      do:  ("ok" <-[boolT] "$r0")
    else do:  #());;;
    return: (![boolT] "ok")).

(* go: precedence.go:22:6 *)
Definition testAndCompare : val :=
  rec: "testAndCompare" <> :=
    exception_do (let: "ok" := (ref_ty boolT (zero_val boolT)) in
    let: "$r0" := #true in
    do:  ("ok" <-[boolT] "$r0");;;
    (if: #(3 >? 4) && #(4 >? 3)
    then
      let: "$r0" := #false in
      do:  ("ok" <-[boolT] "$r0")
    else do:  #());;;
    (if: #(4 >? 3) || #(2 <? 3)
    then do:  #()
    else
      let: "$r0" := #false in
      do:  ("ok" <-[boolT] "$r0"));;;
    return: (![boolT] "ok")).

(* go: precedence.go:34:6 *)
Definition testShiftMod : val :=
  rec: "testShiftMod" <> :=
    exception_do (return: (#(20 =? 20))).

(* go: prims.go:9:6 *)
Definition testLinearize : val :=
  rec: "testLinearize" <> :=
    exception_do (let: "m" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty sync.Mutex (zero_val sync.Mutex)) in
    do:  ("m" <-[ptrT] "$r0");;;
    do:  ((sync.Mutex__Lock (![ptrT] "m")) #());;;
    do:  (primitive.Linearize #());;;
    do:  ((sync.Mutex__Unlock (![ptrT] "m")) #());;;
    return: (#true)).

Definition BoolTest : go_type := structT [
  "t" :: boolT;
  "f" :: boolT;
  "tc" :: uint64T;
  "fc" :: uint64T
].

Definition BoolTest__mset : list (string * val) := [
].

Definition BoolTest__mset_ptr : list (string * val) := [
].

(* go: shortcircuiting.go:11:6 *)
Definition CheckTrue : val :=
  rec: "CheckTrue" "b" :=
    exception_do (let: "b" := (ref_ty ptrT "b") in
    do:  ((struct.field_ref BoolTest "tc" (![ptrT] "b")) <-[uint64T] ((![uint64T] (struct.field_ref BoolTest "tc" (![ptrT] "b"))) + #(W64 1)));;;
    return: (![boolT] (struct.field_ref BoolTest "t" (![ptrT] "b")))).

(* go: shortcircuiting.go:16:6 *)
Definition CheckFalse : val :=
  rec: "CheckFalse" "b" :=
    exception_do (let: "b" := (ref_ty ptrT "b") in
    do:  ((struct.field_ref BoolTest "fc" (![ptrT] "b")) <-[uint64T] ((![uint64T] (struct.field_ref BoolTest "fc" (![ptrT] "b"))) + #(W64 1)));;;
    return: (![boolT] (struct.field_ref BoolTest "f" (![ptrT] "b")))).

(* tests

   go: shortcircuiting.go:22:6 *)
Definition testShortcircuitAndTF : val :=
  rec: "testShortcircuitAndTF" <> :=
    exception_do (let: "b" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty BoolTest (struct.make BoolTest [{
      "t" ::= #true;
      "f" ::= #false;
      "tc" ::= #(W64 0);
      "fc" ::= #(W64 0)
    }])) in
    do:  ("b" <-[ptrT] "$r0");;;
    (if: (let: "$a0" := (![ptrT] "b") in
    CheckTrue "$a0") && (let: "$a0" := (![ptrT] "b") in
    CheckFalse "$a0")
    then return: (#false)
    else do:  #());;;
    return: (((![uint64T] (struct.field_ref BoolTest "tc" (![ptrT] "b"))) = #(W64 1)) && ((![uint64T] (struct.field_ref BoolTest "fc" (![ptrT] "b"))) = #(W64 1)))).

(* go: shortcircuiting.go:31:6 *)
Definition testShortcircuitAndFT : val :=
  rec: "testShortcircuitAndFT" <> :=
    exception_do (let: "b" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty BoolTest (struct.make BoolTest [{
      "t" ::= #true;
      "f" ::= #false;
      "tc" ::= #(W64 0);
      "fc" ::= #(W64 0)
    }])) in
    do:  ("b" <-[ptrT] "$r0");;;
    (if: (let: "$a0" := (![ptrT] "b") in
    CheckFalse "$a0") && (let: "$a0" := (![ptrT] "b") in
    CheckTrue "$a0")
    then return: (#false)
    else do:  #());;;
    return: (((![uint64T] (struct.field_ref BoolTest "tc" (![ptrT] "b"))) = #(W64 0)) && ((![uint64T] (struct.field_ref BoolTest "fc" (![ptrT] "b"))) = #(W64 1)))).

(* go: shortcircuiting.go:40:6 *)
Definition testShortcircuitOrTF : val :=
  rec: "testShortcircuitOrTF" <> :=
    exception_do (let: "b" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty BoolTest (struct.make BoolTest [{
      "t" ::= #true;
      "f" ::= #false;
      "tc" ::= #(W64 0);
      "fc" ::= #(W64 0)
    }])) in
    do:  ("b" <-[ptrT] "$r0");;;
    (if: (let: "$a0" := (![ptrT] "b") in
    CheckTrue "$a0") || (let: "$a0" := (![ptrT] "b") in
    CheckFalse "$a0")
    then return: (((![uint64T] (struct.field_ref BoolTest "tc" (![ptrT] "b"))) = #(W64 1)) && ((![uint64T] (struct.field_ref BoolTest "fc" (![ptrT] "b"))) = #(W64 0)))
    else do:  #());;;
    return: (#false)).

(* go: shortcircuiting.go:48:6 *)
Definition testShortcircuitOrFT : val :=
  rec: "testShortcircuitOrFT" <> :=
    exception_do (let: "b" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty BoolTest (struct.make BoolTest [{
      "t" ::= #true;
      "f" ::= #false;
      "tc" ::= #(W64 0);
      "fc" ::= #(W64 0)
    }])) in
    do:  ("b" <-[ptrT] "$r0");;;
    (if: (let: "$a0" := (![ptrT] "b") in
    CheckFalse "$a0") || (let: "$a0" := (![ptrT] "b") in
    CheckTrue "$a0")
    then return: (((![uint64T] (struct.field_ref BoolTest "tc" (![ptrT] "b"))) = #(W64 1)) && ((![uint64T] (struct.field_ref BoolTest "fc" (![ptrT] "b"))) = #(W64 1)))
    else do:  #());;;
    return: (#false)).

Definition ArrayEditor : go_type := structT [
  "s" :: sliceT;
  "next_val" :: uint64T
].

Definition ArrayEditor__mset : list (string * val) := [
].

(* go: slices.go:9:24 *)
Definition ArrayEditor__Advance : val :=
  rec: "ArrayEditor__Advance" "ae" "arr" "next" :=
    exception_do (let: "ae" := (ref_ty ptrT "ae") in
    let: "next" := (ref_ty uint64T "next") in
    let: "arr" := (ref_ty sliceT "arr") in
    do:  ((slice.elem_ref uint64T (![sliceT] "arr") #(W64 0)) <-[uint64T] ((![uint64T] (slice.elem_ref uint64T (![sliceT] "arr") #(W64 0))) + #(W64 1)));;;
    let: "$r0" := (![uint64T] (struct.field_ref ArrayEditor "next_val" (![ptrT] "ae"))) in
    do:  ((slice.elem_ref uint64T (![sliceT] (struct.field_ref ArrayEditor "s" (![ptrT] "ae"))) #(W64 0)) <-[uint64T] "$r0");;;
    let: "$r0" := (![uint64T] "next") in
    do:  ((struct.field_ref ArrayEditor "next_val" (![ptrT] "ae")) <-[uint64T] "$r0");;;
    let: "$r0" := (let: "$s" := (![sliceT] (struct.field_ref ArrayEditor "s" (![ptrT] "ae"))) in
    slice.slice uint64T "$s" #(W64 1) (slice.len "$s")) in
    do:  ((struct.field_ref ArrayEditor "s" (![ptrT] "ae")) <-[sliceT] "$r0")).

Definition ArrayEditor__mset_ptr : list (string * val) := [
  ("Advance", ArrayEditor__Advance%V)
].

(* tests

   go: slices.go:17:6 *)
Definition testSliceOps : val :=
  rec: "testSliceOps" <> :=
    exception_do (let: "x" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (slice.make2 uint64T #(W64 10)) in
    do:  ("x" <-[sliceT] "$r0");;;
    let: "$r0" := #(W64 5) in
    do:  ((slice.elem_ref uint64T (![sliceT] "x") #(W64 1)) <-[uint64T] "$r0");;;
    let: "$r0" := #(W64 10) in
    do:  ((slice.elem_ref uint64T (![sliceT] "x") #(W64 2)) <-[uint64T] "$r0");;;
    let: "$r0" := #(W64 15) in
    do:  ((slice.elem_ref uint64T (![sliceT] "x") #(W64 3)) <-[uint64T] "$r0");;;
    let: "$r0" := #(W64 20) in
    do:  ((slice.elem_ref uint64T (![sliceT] "x") #(W64 4)) <-[uint64T] "$r0");;;
    let: "v1" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (![uint64T] (slice.elem_ref uint64T (![sliceT] "x") #(W64 2))) in
    do:  ("v1" <-[uint64T] "$r0");;;
    let: "v2" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (let: "$s" := (![sliceT] "x") in
    slice.slice uint64T "$s" #(W64 2) #(W64 3)) in
    do:  ("v2" <-[sliceT] "$r0");;;
    let: "v3" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (let: "$s" := (![sliceT] "x") in
    slice.slice uint64T "$s" #(W64 0) #(W64 3)) in
    do:  ("v3" <-[sliceT] "$r0");;;
    let: "v4" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (slice.elem_ref uint64T (![sliceT] "x") #(W64 2)) in
    do:  ("v4" <-[ptrT] "$r0");;;
    let: "ok" := (ref_ty boolT (zero_val boolT)) in
    let: "$r0" := #true in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((![uint64T] "v1") = #(W64 10))) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((![uint64T] (slice.elem_ref uint64T (![sliceT] "v2") #(W64 0))) = #(W64 10))) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((let: "$a0" := (![sliceT] "v2") in
    slice.len "$a0") = #(W64 1))) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((![uint64T] (slice.elem_ref uint64T (![sliceT] "v3") #(W64 1))) = #(W64 5))) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((![uint64T] (slice.elem_ref uint64T (![sliceT] "v3") #(W64 2))) = #(W64 10))) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((let: "$a0" := (![sliceT] "v3") in
    slice.len "$a0") = #(W64 3))) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((![uint64T] (![ptrT] "v4")) = #(W64 10))) in
    do:  ("ok" <-[boolT] "$r0");;;
    return: (![boolT] "ok")).

(* go: slices.go:40:6 *)
Definition testSliceCapacityOps : val :=
  rec: "testSliceCapacityOps" <> :=
    exception_do (let: "x" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (slice.make3 uint64T #(W64 0) #(W64 10)) in
    do:  ("x" <-[sliceT] "$r0");;;
    let: "sub1" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (let: "$s" := (![sliceT] "x") in
    slice.slice uint64T "$s" #(W64 0) #(W64 6)) in
    do:  ("sub1" <-[sliceT] "$r0");;;
    let: "$r0" := #(W64 1) in
    do:  ((slice.elem_ref uint64T (![sliceT] "sub1") #(W64 0)) <-[uint64T] "$r0");;;
    let: "sub2" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (let: "$s" := (![sliceT] "x") in
    slice.slice uint64T "$s" #(W64 2) #(W64 4)) in
    do:  ("sub2" <-[sliceT] "$r0");;;
    let: "$r0" := #(W64 2) in
    do:  ((slice.elem_ref uint64T (![sliceT] "sub2") #(W64 0)) <-[uint64T] "$r0");;;
    let: "ok" := (ref_ty boolT (zero_val boolT)) in
    let: "$r0" := #true in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((let: "$a0" := (![sliceT] "sub1") in
    slice.len "$a0") = #(W64 6))) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((let: "$a0" := (![sliceT] "sub1") in
    slice.cap "$a0") = #(W64 10))) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((![uint64T] (slice.elem_ref uint64T (let: "$s" := (![sliceT] "x") in
    slice.slice uint64T "$s" #(W64 0) #(W64 10)) #(W64 0))) = #(W64 1))) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((let: "$a0" := (![sliceT] "sub2") in
    slice.len "$a0") = #(W64 2))) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((let: "$a0" := (![sliceT] "sub2") in
    slice.cap "$a0") = #(W64 8))) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((![uint64T] (slice.elem_ref uint64T (let: "$s" := (![sliceT] "x") in
    slice.slice uint64T "$s" #(W64 0) #(W64 10)) #(W64 2))) = #(W64 2))) in
    do:  ("ok" <-[boolT] "$r0");;;
    return: (![boolT] "ok")).

(* go: slices.go:59:6 *)
Definition testOverwriteArray : val :=
  rec: "testOverwriteArray" <> :=
    exception_do (let: "arr" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (slice.make2 uint64T #(W64 4)) in
    do:  ("arr" <-[sliceT] "$r0");;;
    let: "ae1" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty ArrayEditor (struct.make ArrayEditor [{
      "s" ::= let: "$s" := (![sliceT] "arr") in
      slice.slice uint64T "$s" #(W64 0) (slice.len "$s");
      "next_val" ::= #(W64 1)
    }])) in
    do:  ("ae1" <-[ptrT] "$r0");;;
    let: "ae2" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty ArrayEditor (struct.make ArrayEditor [{
      "s" ::= let: "$s" := (![sliceT] "arr") in
      slice.slice uint64T "$s" #(W64 1) (slice.len "$s");
      "next_val" ::= #(W64 102)
    }])) in
    do:  ("ae2" <-[ptrT] "$r0");;;
    do:  (let: "$a0" := (![sliceT] "arr") in
    let: "$a1" := #(W64 103) in
    (ArrayEditor__Advance (![ptrT] "ae2")) "$a0" "$a1");;;
    do:  (let: "$a0" := (![sliceT] "arr") in
    let: "$a1" := #(W64 104) in
    (ArrayEditor__Advance (![ptrT] "ae2")) "$a0" "$a1");;;
    do:  (let: "$a0" := (![sliceT] "arr") in
    let: "$a1" := #(W64 105) in
    (ArrayEditor__Advance (![ptrT] "ae2")) "$a0" "$a1");;;
    do:  (let: "$a0" := (![sliceT] "arr") in
    let: "$a1" := #(W64 2) in
    (ArrayEditor__Advance (![ptrT] "ae1")) "$a0" "$a1");;;
    do:  (let: "$a0" := (![sliceT] "arr") in
    let: "$a1" := #(W64 3) in
    (ArrayEditor__Advance (![ptrT] "ae1")) "$a0" "$a1");;;
    do:  (let: "$a0" := (![sliceT] "arr") in
    let: "$a1" := #(W64 4) in
    (ArrayEditor__Advance (![ptrT] "ae1")) "$a0" "$a1");;;
    do:  (let: "$a0" := (![sliceT] "arr") in
    let: "$a1" := #(W64 5) in
    (ArrayEditor__Advance (![ptrT] "ae1")) "$a0" "$a1");;;
    (if: ((((![uint64T] (slice.elem_ref uint64T (![sliceT] "arr") #(W64 0))) + (![uint64T] (slice.elem_ref uint64T (![sliceT] "arr") #(W64 1)))) + (![uint64T] (slice.elem_ref uint64T (![sliceT] "arr") #(W64 2)))) + (![uint64T] (slice.elem_ref uint64T (![sliceT] "arr") #(W64 3)))) ≥ #(W64 100)
    then return: (#false)
    else do:  #());;;
    return: (((![uint64T] (slice.elem_ref uint64T (![sliceT] "arr") #(W64 3))) = #(W64 4)) && ((![uint64T] (slice.elem_ref uint64T (![sliceT] "arr") #(W64 0))) = #(W64 4)))).

(* go: slices.go:80:6 *)
Definition testSliceLiteral : val :=
  rec: "testSliceLiteral" <> :=
    exception_do (let: "bytes" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := ((let: "$sl0" := #(W8 1) in
    let: "$sl1" := #(W8 2) in
    slice.literal byteT ["$sl0"; "$sl1"])) in
    do:  ("bytes" <-[sliceT] "$r0");;;
    let: "ok" := (ref_ty boolT (zero_val boolT)) in
    let: "$r0" := #true in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((![byteT] (slice.elem_ref byteT (![sliceT] "bytes") #(W64 0))) = #(W8 1))) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "ints" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := ((let: "$sl0" := #(W64 1) in
    let: "$sl1" := #(W64 2) in
    let: "$sl2" := #(W64 3) in
    slice.literal uint64T ["$sl0"; "$sl1"; "$sl2"])) in
    do:  ("ints" <-[sliceT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((![uint64T] (slice.elem_ref uint64T (![sliceT] "ints") #(W64 1))) = #(W64 2))) in
    do:  ("ok" <-[boolT] "$r0");;;
    return: (![boolT] "ok")).

Definition Bar : go_type := structT [
  "a" :: uint64T;
  "b" :: uint64T
].

Definition Bar__mset : list (string * val) := [
].

(* go: struct_pointers.go:14:17 *)
Definition Bar__mutate : val :=
  rec: "Bar__mutate" "bar" <> :=
    exception_do (let: "bar" := (ref_ty ptrT "bar") in
    let: "$r0" := #(W64 2) in
    do:  ((struct.field_ref Bar "a" (![ptrT] "bar")) <-[uint64T] "$r0");;;
    let: "$r0" := #(W64 3) in
    do:  ((struct.field_ref Bar "b" (![ptrT] "bar")) <-[uint64T] "$r0")).

Definition Bar__mset_ptr : list (string * val) := [
  ("mutate", Bar__mutate%V)
].

Definition Foo : go_type := structT [
  "bar" :: Bar
].

Definition Foo__mset : list (string * val) := [
].

(* go: struct_pointers.go:19:17 *)
Definition Foo__mutateBar : val :=
  rec: "Foo__mutateBar" "foo" <> :=
    exception_do (let: "foo" := (ref_ty ptrT "foo") in
    do:  ((Bar__mutate (struct.field_ref Foo "bar" (![ptrT] "foo"))) #())).

Definition Foo__mset_ptr : list (string * val) := [
  ("mutateBar", Foo__mutateBar%V)
].

(* go: struct_pointers.go:23:6 *)
Definition failing_testFooBarMutation : val :=
  rec: "failing_testFooBarMutation" <> :=
    exception_do (let: "x" := (ref_ty Foo (zero_val Foo)) in
    let: "$r0" := (struct.make Foo [{
      "bar" ::= struct.make Bar [{
        "a" ::= #(W64 0);
        "b" ::= #(W64 0)
      }]
    }]) in
    do:  ("x" <-[Foo] "$r0");;;
    do:  ((Foo__mutateBar "x") #());;;
    return: ((![uint64T] (struct.field_ref Bar "a" (struct.field_ref Foo "bar" "x"))) = #(W64 2))).

Definition TwoInts : go_type := structT [
  "x" :: uint64T;
  "y" :: uint64T
].

Definition TwoInts__mset : list (string * val) := [
].

Definition TwoInts__mset_ptr : list (string * val) := [
].

Definition S : go_type := structT [
  "a" :: uint64T;
  "b" :: TwoInts;
  "c" :: boolT
].

(* go: structs.go:30:12 *)
Definition S__readBVal : val :=
  rec: "S__readBVal" "s" <> :=
    exception_do (let: "s" := (ref_ty S "s") in
    return: (![TwoInts] (struct.field_ref S "b" "s"))).

Definition S__mset : list (string * val) := [
  ("readBVal", S__readBVal%V)
].

(* go: structs.go:38:13 *)
Definition S__negateC : val :=
  rec: "S__negateC" "s" <> :=
    exception_do (let: "s" := (ref_ty ptrT "s") in
    let: "$r0" := (~ (![boolT] (struct.field_ref S "c" (![ptrT] "s")))) in
    do:  ((struct.field_ref S "c" (![ptrT] "s")) <-[boolT] "$r0")).

(* go: structs.go:22:13 *)
Definition S__readA : val :=
  rec: "S__readA" "s" <> :=
    exception_do (let: "s" := (ref_ty ptrT "s") in
    return: (![uint64T] (struct.field_ref S "a" (![ptrT] "s")))).

(* go: structs.go:26:13 *)
Definition S__readB : val :=
  rec: "S__readB" "s" <> :=
    exception_do (let: "s" := (ref_ty ptrT "s") in
    return: (![TwoInts] (struct.field_ref S "b" (![ptrT] "s")))).

(* go: structs.go:34:13 *)
Definition S__updateBValX : val :=
  rec: "S__updateBValX" "s" "i" :=
    exception_do (let: "s" := (ref_ty ptrT "s") in
    let: "i" := (ref_ty uint64T "i") in
    let: "$r0" := (![uint64T] "i") in
    do:  ((struct.field_ref TwoInts "x" (struct.field_ref S "b" (![ptrT] "s"))) <-[uint64T] "$r0")).

Definition S__mset_ptr : list (string * val) := [
  ("negateC", S__negateC%V);
  ("readA", S__readA%V);
  ("readB", S__readB%V);
  ("readBVal", (λ: "$recvAddr",
    S__readBVal (![S] "$recvAddr")
    )%V);
  ("updateBValX", S__updateBValX%V)
].

(* go: structs.go:14:6 *)
Definition NewS : val :=
  rec: "NewS" <> :=
    exception_do (return: (ref_ty S (struct.make S [{
       "a" ::= #(W64 2);
       "b" ::= struct.make TwoInts [{
         "x" ::= #(W64 1);
         "y" ::= #(W64 2)
       }];
       "c" ::= #true
     }]))).

(* go: structs.go:42:6 *)
Definition testStructUpdates : val :=
  rec: "testStructUpdates" <> :=
    exception_do (let: "ok" := (ref_ty boolT (zero_val boolT)) in
    let: "$r0" := #true in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "ns" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (NewS #()) in
    do:  ("ns" <-[ptrT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && (((S__readA (![ptrT] "ns")) #()) = #(W64 2))) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "b1" := (ref_ty TwoInts (zero_val TwoInts)) in
    let: "$r0" := ((S__readB (![ptrT] "ns")) #()) in
    do:  ("b1" <-[TwoInts] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((![uint64T] (struct.field_ref TwoInts "x" "b1")) = #(W64 1))) in
    do:  ("ok" <-[boolT] "$r0");;;
    do:  ((S__negateC (![ptrT] "ns")) #());;;
    let: "$r0" := ((![boolT] "ok") && ((![boolT] (struct.field_ref S "c" (![ptrT] "ns"))) = #false)) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := #(W64 3) in
    do:  ((struct.field_ref TwoInts "x" "b1") <-[uint64T] "$r0");;;
    let: "b2" := (ref_ty TwoInts (zero_val TwoInts)) in
    let: "$r0" := ((S__readB (![ptrT] "ns")) #()) in
    do:  ("b2" <-[TwoInts] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((![uint64T] (struct.field_ref TwoInts "x" "b2")) = #(W64 1))) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "b3" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (struct.field_ref S "b" (![ptrT] "ns")) in
    do:  ("b3" <-[ptrT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((![uint64T] (struct.field_ref TwoInts "x" (![ptrT] "b3"))) = #(W64 1))) in
    do:  ("ok" <-[boolT] "$r0");;;
    do:  (let: "$a0" := #(W64 4) in
    (S__updateBValX (![ptrT] "ns")) "$a0");;;
    let: "$r0" := ((![boolT] "ok") && ((struct.field_get TwoInts "x" ((S__readBVal (![S] (![ptrT] "ns"))) #())) = #(W64 4))) in
    do:  ("ok" <-[boolT] "$r0");;;
    return: (![boolT] "ok")).

(* go: structs.go:65:6 *)
Definition testNestedStructUpdates : val :=
  rec: "testNestedStructUpdates" <> :=
    exception_do (let: "ok" := (ref_ty boolT (zero_val boolT)) in
    let: "$r0" := #true in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "ns" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (NewS #()) in
    do:  ("ns" <-[ptrT] "$r0");;;
    let: "$r0" := #(W64 5) in
    do:  ((struct.field_ref TwoInts "x" (struct.field_ref S "b" (![ptrT] "ns"))) <-[uint64T] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((![uint64T] (struct.field_ref TwoInts "x" (struct.field_ref S "b" (![ptrT] "ns")))) = #(W64 5))) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := (NewS #()) in
    do:  ("ns" <-[ptrT] "$r0");;;
    let: "p" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (struct.field_ref S "b" (![ptrT] "ns")) in
    do:  ("p" <-[ptrT] "$r0");;;
    let: "$r0" := #(W64 5) in
    do:  ((struct.field_ref TwoInts "x" (![ptrT] "p")) <-[uint64T] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((![uint64T] (struct.field_ref TwoInts "x" (struct.field_ref S "b" (![ptrT] "ns")))) = #(W64 5))) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := (NewS #()) in
    do:  ("ns" <-[ptrT] "$r0");;;
    let: "$r0" := (struct.field_ref S "b" (![ptrT] "ns")) in
    do:  ("p" <-[ptrT] "$r0");;;
    let: "$r0" := #(W64 5) in
    do:  ((struct.field_ref TwoInts "x" (struct.field_ref S "b" (![ptrT] "ns"))) <-[uint64T] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((![uint64T] (struct.field_ref TwoInts "x" (![ptrT] "p"))) = #(W64 5))) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := (NewS #()) in
    do:  ("ns" <-[ptrT] "$r0");;;
    let: "$r0" := (struct.field_ref S "b" (![ptrT] "ns")) in
    do:  ("p" <-[ptrT] "$r0");;;
    let: "$r0" := #(W64 5) in
    do:  ((struct.field_ref TwoInts "x" (struct.field_ref S "b" (![ptrT] "ns"))) <-[uint64T] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((![uint64T] (struct.field_ref TwoInts "x" (![ptrT] "p"))) = #(W64 5))) in
    do:  ("ok" <-[boolT] "$r0");;;
    return: (![boolT] "ok")).

(* go: structs.go:90:6 *)
Definition testStructConstructions : val :=
  rec: "testStructConstructions" <> :=
    exception_do (let: "ok" := (ref_ty boolT (zero_val boolT)) in
    let: "$r0" := #true in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "p1" := (ref_ty ptrT (zero_val ptrT)) in
    let: "p2" := (ref_ty TwoInts (zero_val TwoInts)) in
    let: "p3" := (ref_ty TwoInts (zero_val TwoInts)) in
    let: "$r0" := (struct.make TwoInts [{
      "y" ::= #(W64 0);
      "x" ::= #(W64 0)
    }]) in
    do:  ("p3" <-[TwoInts] "$r0");;;
    let: "p4" := (ref_ty TwoInts (zero_val TwoInts)) in
    let: "$r0" := (struct.make TwoInts [{
      "x" ::= #(W64 0);
      "y" ::= #(W64 0)
    }]) in
    do:  ("p4" <-[TwoInts] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((![ptrT] "p1") = #null)) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := (ref_ty TwoInts (zero_val TwoInts)) in
    do:  ("p1" <-[ptrT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((![TwoInts] "p2") = (![TwoInts] "p3"))) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((![TwoInts] "p3") = (![TwoInts] "p4"))) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((![TwoInts] "p4") = (![TwoInts] (![ptrT] "p1")))) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ("p4" ≠ (![ptrT] "p1"))) in
    do:  ("ok" <-[boolT] "$r0");;;
    return: (![boolT] "ok")).

(* go: structs.go:109:6 *)
Definition testIncompleteStruct : val :=
  rec: "testIncompleteStruct" <> :=
    exception_do (let: "ok" := (ref_ty boolT (zero_val boolT)) in
    let: "$r0" := #true in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "p1" := (ref_ty TwoInts (zero_val TwoInts)) in
    let: "$r0" := (struct.make TwoInts [{
      "x" ::= #(W64 0)
    }]) in
    do:  ("p1" <-[TwoInts] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((![uint64T] (struct.field_ref TwoInts "y" "p1")) = #(W64 0))) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "p2" := (ref_ty S (zero_val S)) in
    let: "$r0" := (struct.make S [{
      "a" ::= #(W64 2)
    }]) in
    do:  ("p2" <-[S] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((![uint64T] (struct.field_ref TwoInts "x" (struct.field_ref S "b" "p2"))) = #(W64 0))) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((![boolT] (struct.field_ref S "c" "p2")) = #false)) in
    do:  ("ok" <-[boolT] "$r0");;;
    return: (![boolT] "ok")).

Definition StructWrap : go_type := structT [
  "i" :: uint64T
].

Definition StructWrap__mset : list (string * val) := [
].

Definition StructWrap__mset_ptr : list (string * val) := [
].

(* go: structs.go:126:6 *)
Definition testStoreInStructVar : val :=
  rec: "testStoreInStructVar" <> :=
    exception_do (let: "p" := (ref_ty StructWrap (zero_val StructWrap)) in
    let: "$r0" := (struct.make StructWrap [{
      "i" ::= #(W64 0)
    }]) in
    do:  ("p" <-[StructWrap] "$r0");;;
    let: "$r0" := #(W64 5) in
    do:  ((struct.field_ref StructWrap "i" "p") <-[uint64T] "$r0");;;
    return: ((![uint64T] (struct.field_ref StructWrap "i" "p")) = #(W64 5))).

(* go: structs.go:132:6 *)
Definition testStoreInStructPointerVar : val :=
  rec: "testStoreInStructPointerVar" <> :=
    exception_do (let: "p" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty StructWrap (zero_val StructWrap)) in
    do:  ("p" <-[ptrT] "$r0");;;
    let: "$r0" := #(W64 5) in
    do:  ((struct.field_ref StructWrap "i" (![ptrT] "p")) <-[uint64T] "$r0");;;
    return: ((![uint64T] (struct.field_ref StructWrap "i" (![ptrT] "p"))) = #(W64 5))).

(* go: structs.go:138:6 *)
Definition testStoreComposite : val :=
  rec: "testStoreComposite" <> :=
    exception_do (let: "p" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty TwoInts (zero_val TwoInts)) in
    do:  ("p" <-[ptrT] "$r0");;;
    let: "$r0" := (struct.make TwoInts [{
      "x" ::= #(W64 3);
      "y" ::= #(W64 4)
    }]) in
    do:  ((![ptrT] "p") <-[TwoInts] "$r0");;;
    return: ((![uint64T] (struct.field_ref TwoInts "y" (![ptrT] "p"))) = #(W64 4))).

(* go: structs.go:144:6 *)
Definition testStoreSlice : val :=
  rec: "testStoreSlice" <> :=
    exception_do (let: "p" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty sliceT (zero_val sliceT)) in
    do:  ("p" <-[ptrT] "$r0");;;
    let: "s" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (slice.make2 uint64T #(W64 3)) in
    do:  ("s" <-[sliceT] "$r0");;;
    let: "$r0" := (![sliceT] "s") in
    do:  ((![ptrT] "p") <-[sliceT] "$r0");;;
    return: ((let: "$a0" := (![sliceT] (![ptrT] "p")) in
     slice.len "$a0") = #(W64 3))).

Definition StructWithFunc : go_type := structT [
  "fn" :: funcT
].

Definition StructWithFunc__mset : list (string * val) := [
].

Definition StructWithFunc__mset_ptr : list (string * val) := [
].

(* go: structs.go:155:6 *)
Definition testStructFieldFunc : val :=
  rec: "testStructFieldFunc" <> :=
    exception_do (let: "a" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty StructWithFunc (zero_val StructWithFunc)) in
    do:  ("a" <-[ptrT] "$r0");;;
    let: "$r0" := (λ: "arg",
      exception_do (let: "arg" := (ref_ty uint64T "arg") in
      return: ((![uint64T] "arg") * #(W64 2)))
      ) in
    do:  ((struct.field_ref StructWithFunc "fn" (![ptrT] "a")) <-[funcT] "$r0");;;
    return: ((let: "$a0" := #(W64 10) in
     (![funcT] (struct.field_ref StructWithFunc "fn" (![ptrT] "a"))) "$a0") = #(W64 20))).

(* go: switch.go:3:6 *)
Definition testSwitchVal : val :=
  rec: "testSwitchVal" <> :=
    exception_do (let: "x" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("x" <-[uint64T] "$r0");;;
    let: "$sw" := (![uint64T] "x") in
    (if: "$sw" = #(W64 0)
    then return: (#true)
    else
      (if: "$sw" = #(W64 1)
      then return: (#false)
      else return: (#false)))).

(* go: switch.go:15:6 *)
Definition testSwitchMultiple : val :=
  rec: "testSwitchMultiple" <> :=
    exception_do (let: "x" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("x" <-[uint64T] "$r0");;;
    let: "$sw" := (![uint64T] "x") in
    (if: ("$sw" = #(W64 1)) || ("$sw" = #(W64 10))
    then return: (#false)
    else
      (if: "$sw" = #(W64 0)
      then return: (#true)
      else #()));;;
    return: (#false)).

(* go: switch.go:26:6 *)
Definition testSwitchDefaultTrue : val :=
  rec: "testSwitchDefaultTrue" <> :=
    exception_do (let: "x" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := #(W64 1) in
    do:  ("x" <-[uint64T] "$r0");;;
    let: "$sw" := #true in
    (if: "$sw" = #false
    then return: (#false)
    else
      (if: "$sw" = ((![uint64T] "x") = #(W64 2))
      then return: (#false)
      else return: (#true)))).

Definition switchConcrete : go_type := structT [
].

Definition switchConcrete__mset : list (string * val) := [
].

(* go: switch.go:45:26 *)
Definition switchConcrete__marker : val :=
  rec: "switchConcrete__marker" "c" <> :=
    exception_do (let: "c" := (ref_ty ptrT "c") in
    do:  #()).

Definition switchConcrete__mset_ptr : list (string * val) := [
  ("marker", switchConcrete__marker%V)
].

Definition switchInterface : go_type := interfaceT.

(* go: switch.go:48:6 *)
Definition testSwitchConversion : val :=
  rec: "testSwitchConversion" <> :=
    exception_do (let: "v" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty switchConcrete (struct.make switchConcrete [{
    }])) in
    do:  ("v" <-[ptrT] "$r0");;;
    let: "x" := (ref_ty switchInterface (zero_val switchInterface)) in
    let: "$r0" := (interface.make switchConcrete__mset_ptr (![ptrT] "v")) in
    do:  ("x" <-[switchInterface] "$r0");;;
    let: "$sw" := (![switchInterface] "x") in
    (if: "$sw" = (interface.make switchConcrete__mset_ptr (![ptrT] "v"))
    then do:  #()
    else return: (#false));;;
    let: "$sw" := (![ptrT] "v") in
    (if: (interface.make switchConcrete__mset_ptr "$sw") = (![switchInterface] "x")
    then do:  #()
    else return: (#false));;;
    return: (#true)).

(* go: vars.go:3:6 *)
Definition testPointerAssignment : val :=
  rec: "testPointerAssignment" <> :=
    exception_do (let: "x" := (ref_ty boolT (zero_val boolT)) in
    let: "$r0" := #true in
    do:  ("x" <-[boolT] "$r0");;;
    return: (![boolT] "x")).

(* go: vars.go:9:6 *)
Definition testAddressOfLocal : val :=
  rec: "testAddressOfLocal" <> :=
    exception_do (let: "x" := (ref_ty boolT (zero_val boolT)) in
    let: "$r0" := #false in
    do:  ("x" <-[boolT] "$r0");;;
    let: "xptr" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := "x" in
    do:  ("xptr" <-[ptrT] "$r0");;;
    let: "$r0" := #true in
    do:  ((![ptrT] "xptr") <-[boolT] "$r0");;;
    return: ((![boolT] "x") && (![boolT] (![ptrT] "xptr")))).

(* go: vars.go:16:6 *)
Definition testAnonymousAssign : val :=
  rec: "testAnonymousAssign" <> :=
    exception_do (let: "$r0" := (#(W64 1) + #(W64 2)) in
    do:  "$r0";;;
    return: (#true)).

(* 10 is completely arbitrary *)
Definition MaxTxnWrites : expr := #(W64 10).

Definition logLength : expr := #(W64 1) + (#(W64 2) * MaxTxnWrites).

Definition Log : go_type := structT [
  "d" :: disk.Disk;
  "l" :: ptrT;
  "cache" :: mapT uint64T sliceT;
  "length" :: ptrT
].

(* go: wal.go:56:14 *)
Definition Log__unlock : val :=
  rec: "Log__unlock" "l" <> :=
    exception_do (let: "l" := (ref_ty Log "l") in
    do:  ((sync.Mutex__Unlock (![ptrT] (struct.field_ref Log "l" "l"))) #())).

(* go: wal.go:25:6 *)
Definition intToBlock : val :=
  rec: "intToBlock" "a" :=
    exception_do (let: "a" := (ref_ty uint64T "a") in
    let: "b" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (slice.make2 byteT disk.BlockSize) in
    do:  ("b" <-[sliceT] "$r0");;;
    do:  (let: "$a0" := (![sliceT] "b") in
    let: "$a1" := (![uint64T] "a") in
    primitive.UInt64Put "$a0" "$a1");;;
    return: (![sliceT] "b")).

(* go: wal.go:142:6 *)
Definition clearLog : val :=
  rec: "clearLog" "d" :=
    exception_do (let: "d" := (ref_ty disk.Disk "d") in
    let: "header" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (let: "$a0" := #(W64 0) in
    intToBlock "$a0") in
    do:  ("header" <-[sliceT] "$r0");;;
    do:  (let: "$a0" := #(W64 0) in
    let: "$a1" := (![sliceT] "header") in
    (interface.get "Write" (![disk.Disk] "d")) "$a0" "$a1")).

(* go: wal.go:31:6 *)
Definition blockToInt : val :=
  rec: "blockToInt" "v" :=
    exception_do (let: "v" := (ref_ty sliceT "v") in
    let: "a" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (let: "$a0" := (![sliceT] "v") in
    primitive.UInt64Get "$a0") in
    do:  ("a" <-[uint64T] "$r0");;;
    return: (![uint64T] "a")).

(* go: wal.go:122:6 *)
Definition getLogEntry : val :=
  rec: "getLogEntry" "d" "logOffset" :=
    exception_do (let: "logOffset" := (ref_ty uint64T "logOffset") in
    let: "d" := (ref_ty disk.Disk "d") in
    let: "diskAddr" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (#(W64 1) + (#(W64 2) * (![uint64T] "logOffset"))) in
    do:  ("diskAddr" <-[uint64T] "$r0");;;
    let: "aBlock" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (let: "$a0" := (![uint64T] "diskAddr") in
    (interface.get "Read" (![disk.Disk] "d")) "$a0") in
    do:  ("aBlock" <-[sliceT] "$r0");;;
    let: "a" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (let: "$a0" := (![sliceT] "aBlock") in
    blockToInt "$a0") in
    do:  ("a" <-[uint64T] "$r0");;;
    let: "v" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (let: "$a0" := ((![uint64T] "diskAddr") + #(W64 1)) in
    (interface.get "Read" (![disk.Disk] "d")) "$a0") in
    do:  ("v" <-[sliceT] "$r0");;;
    return: (![uint64T] "a", ![sliceT] "v")).

(* applyLog assumes we are running sequentially

   go: wal.go:131:6 *)
Definition applyLog : val :=
  rec: "applyLog" "d" "length" :=
    exception_do (let: "length" := (ref_ty uint64T "length") in
    let: "d" := (ref_ty disk.Disk "d") in
    (let: "i" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[uint64T] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      (if: (![uint64T] "i") < (![uint64T] "length")
      then
        let: "v" := (ref_ty sliceT (zero_val sliceT)) in
        let: "a" := (ref_ty uint64T (zero_val uint64T)) in
        let: ("$ret0", "$ret1") := (let: "$a0" := (![disk.Disk] "d") in
        let: "$a1" := (![uint64T] "i") in
        getLogEntry "$a0" "$a1") in
        let: "$r0" := "$ret0" in
        let: "$r1" := "$ret1" in
        do:  ("a" <-[uint64T] "$r0");;;
        do:  ("v" <-[sliceT] "$r1");;;
        do:  (let: "$a0" := (logLength + (![uint64T] "a")) in
        let: "$a1" := (![sliceT] "v") in
        (interface.get "Write" (![disk.Disk] "d")) "$a0" "$a1");;;
        let: "$r0" := ((![uint64T] "i") + #(W64 1)) in
        do:  ("i" <-[uint64T] "$r0");;;
        continue: #()
      else do:  #());;;
      break: #()))).

(* go: wal.go:52:14 *)
Definition Log__lock : val :=
  rec: "Log__lock" "l" <> :=
    exception_do (let: "l" := (ref_ty Log "l") in
    do:  ((sync.Mutex__Lock (![ptrT] (struct.field_ref Log "l" "l"))) #())).

(* Apply all the committed transactions.

   Frees all the space in the log.

   go: wal.go:150:14 *)
Definition Log__Apply : val :=
  rec: "Log__Apply" "l" <> :=
    exception_do (let: "l" := (ref_ty Log "l") in
    do:  ((Log__lock (![Log] "l")) #());;;
    let: "length" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (![uint64T] (![ptrT] (struct.field_ref Log "length" "l"))) in
    do:  ("length" <-[uint64T] "$r0");;;
    do:  (let: "$a0" := (![disk.Disk] (struct.field_ref Log "d" "l")) in
    let: "$a1" := (![uint64T] "length") in
    applyLog "$a0" "$a1");;;
    do:  (let: "$a0" := (![disk.Disk] (struct.field_ref Log "d" "l")) in
    clearLog "$a0");;;
    let: "$r0" := #(W64 0) in
    do:  ((![ptrT] (struct.field_ref Log "length" "l")) <-[uint64T] "$r0");;;
    do:  ((Log__unlock (![Log] "l")) #())).

(* BeginTxn allocates space for a new transaction in the log.

   Returns true if the allocation succeeded.

   go: wal.go:63:14 *)
Definition Log__BeginTxn : val :=
  rec: "Log__BeginTxn" "l" <> :=
    exception_do (let: "l" := (ref_ty Log "l") in
    do:  ((Log__lock (![Log] "l")) #());;;
    let: "length" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (![uint64T] (![ptrT] (struct.field_ref Log "length" "l"))) in
    do:  ("length" <-[uint64T] "$r0");;;
    (if: (![uint64T] "length") = #(W64 0)
    then
      do:  ((Log__unlock (![Log] "l")) #());;;
      return: (#true)
    else do:  #());;;
    do:  ((Log__unlock (![Log] "l")) #());;;
    return: (#false)).

(* Commit the current transaction.

   go: wal.go:113:14 *)
Definition Log__Commit : val :=
  rec: "Log__Commit" "l" <> :=
    exception_do (let: "l" := (ref_ty Log "l") in
    do:  ((Log__lock (![Log] "l")) #());;;
    let: "length" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (![uint64T] (![ptrT] (struct.field_ref Log "length" "l"))) in
    do:  ("length" <-[uint64T] "$r0");;;
    do:  ((Log__unlock (![Log] "l")) #());;;
    let: "header" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (let: "$a0" := (![uint64T] "length") in
    intToBlock "$a0") in
    do:  ("header" <-[sliceT] "$r0");;;
    do:  (let: "$a0" := #(W64 0) in
    let: "$a1" := (![sliceT] "header") in
    (interface.get "Write" (![disk.Disk] (struct.field_ref Log "d" "l"))) "$a0" "$a1")).

(* Read from the logical disk.

   Reads must go through the log to return committed but un-applied writes.

   go: wal.go:77:14 *)
Definition Log__Read : val :=
  rec: "Log__Read" "l" "a" :=
    exception_do (let: "l" := (ref_ty Log "l") in
    let: "a" := (ref_ty uint64T "a") in
    do:  ((Log__lock (![Log] "l")) #());;;
    let: "ok" := (ref_ty boolT (zero_val boolT)) in
    let: "v" := (ref_ty sliceT (zero_val sliceT)) in
    let: ("$ret0", "$ret1") := (map.get (![mapT uint64T sliceT] (struct.field_ref Log "cache" "l")) (![uint64T] "a")) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("v" <-[sliceT] "$r0");;;
    do:  ("ok" <-[boolT] "$r1");;;
    (if: ![boolT] "ok"
    then
      do:  ((Log__unlock (![Log] "l")) #());;;
      return: (![sliceT] "v")
    else do:  #());;;
    do:  ((Log__unlock (![Log] "l")) #());;;
    let: "dv" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (let: "$a0" := (logLength + (![uint64T] "a")) in
    (interface.get "Read" (![disk.Disk] (struct.field_ref Log "d" "l"))) "$a0") in
    do:  ("dv" <-[sliceT] "$r0");;;
    return: (![sliceT] "dv")).

(* go: wal.go:90:14 *)
Definition Log__Size : val :=
  rec: "Log__Size" "l" <> :=
    exception_do (let: "l" := (ref_ty Log "l") in
    let: "sz" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := ((interface.get "Size" (![disk.Disk] (struct.field_ref Log "d" "l"))) #()) in
    do:  ("sz" <-[uint64T] "$r0");;;
    return: ((![uint64T] "sz") - logLength)).

(* Write to the disk through the log.

   go: wal.go:97:14 *)
Definition Log__Write : val :=
  rec: "Log__Write" "l" "a" "v" :=
    exception_do (let: "l" := (ref_ty Log "l") in
    let: "v" := (ref_ty sliceT "v") in
    let: "a" := (ref_ty uint64T "a") in
    do:  ((Log__lock (![Log] "l")) #());;;
    let: "length" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (![uint64T] (![ptrT] (struct.field_ref Log "length" "l"))) in
    do:  ("length" <-[uint64T] "$r0");;;
    (if: (![uint64T] "length") ≥ MaxTxnWrites
    then
      do:  (let: "$a0" := (interface.make string__mset #"transaction is at capacity") in
      Panic "$a0")
    else do:  #());;;
    let: "aBlock" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (let: "$a0" := (![uint64T] "a") in
    intToBlock "$a0") in
    do:  ("aBlock" <-[sliceT] "$r0");;;
    let: "nextAddr" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (#(W64 1) + (#(W64 2) * (![uint64T] "length"))) in
    do:  ("nextAddr" <-[uint64T] "$r0");;;
    do:  (let: "$a0" := (![uint64T] "nextAddr") in
    let: "$a1" := (![sliceT] "aBlock") in
    (interface.get "Write" (![disk.Disk] (struct.field_ref Log "d" "l"))) "$a0" "$a1");;;
    do:  (let: "$a0" := ((![uint64T] "nextAddr") + #(W64 1)) in
    let: "$a1" := (![sliceT] "v") in
    (interface.get "Write" (![disk.Disk] (struct.field_ref Log "d" "l"))) "$a0" "$a1");;;
    let: "$r0" := (![sliceT] "v") in
    do:  (map.insert (![mapT uint64T sliceT] (struct.field_ref Log "cache" "l")) (![uint64T] "a") "$r0");;;
    let: "$r0" := ((![uint64T] "length") + #(W64 1)) in
    do:  ((![ptrT] (struct.field_ref Log "length" "l")) <-[uint64T] "$r0");;;
    do:  ((Log__unlock (![Log] "l")) #())).

Definition Log__mset : list (string * val) := [
  ("Apply", Log__Apply%V);
  ("BeginTxn", Log__BeginTxn%V);
  ("Commit", Log__Commit%V);
  ("Read", Log__Read%V);
  ("Size", Log__Size%V);
  ("Write", Log__Write%V);
  ("lock", Log__lock%V);
  ("unlock", Log__unlock%V)
].

Definition Log__mset_ptr : list (string * val) := [
  ("Apply", (λ: "$recvAddr",
    Log__Apply (![Log] "$recvAddr")
    )%V);
  ("BeginTxn", (λ: "$recvAddr",
    Log__BeginTxn (![Log] "$recvAddr")
    )%V);
  ("Commit", (λ: "$recvAddr",
    Log__Commit (![Log] "$recvAddr")
    )%V);
  ("Read", (λ: "$recvAddr",
    Log__Read (![Log] "$recvAddr")
    )%V);
  ("Size", (λ: "$recvAddr",
    Log__Size (![Log] "$recvAddr")
    )%V);
  ("Write", (λ: "$recvAddr",
    Log__Write (![Log] "$recvAddr")
    )%V);
  ("lock", (λ: "$recvAddr",
    Log__lock (![Log] "$recvAddr")
    )%V);
  ("unlock", (λ: "$recvAddr",
    Log__unlock (![Log] "$recvAddr")
    )%V)
].

(* New initializes a fresh log

   go: wal.go:37:6 *)
Definition New : val :=
  rec: "New" <> :=
    exception_do (let: "d" := (ref_ty disk.Disk (zero_val disk.Disk)) in
    let: "$r0" := (disk.Get #()) in
    do:  ("d" <-[disk.Disk] "$r0");;;
    let: "diskSize" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := ((interface.get "Size" (![disk.Disk] "d")) #()) in
    do:  ("diskSize" <-[uint64T] "$r0");;;
    (if: (![uint64T] "diskSize") ≤ logLength
    then
      do:  (let: "$a0" := (interface.make string__mset #"disk is too small to host log") in
      Panic "$a0")
    else do:  #());;;
    let: "cache" := (ref_ty (mapT uint64T sliceT) (zero_val (mapT uint64T sliceT))) in
    let: "$r0" := (map.make uint64T sliceT #()) in
    do:  ("cache" <-[mapT uint64T sliceT] "$r0");;;
    let: "header" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (let: "$a0" := #(W64 0) in
    intToBlock "$a0") in
    do:  ("header" <-[sliceT] "$r0");;;
    do:  (let: "$a0" := #(W64 0) in
    let: "$a1" := (![sliceT] "header") in
    (interface.get "Write" (![disk.Disk] "d")) "$a0" "$a1");;;
    let: "lengthPtr" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty uint64T (zero_val uint64T)) in
    do:  ("lengthPtr" <-[ptrT] "$r0");;;
    let: "$r0" := #(W64 0) in
    do:  ((![ptrT] "lengthPtr") <-[uint64T] "$r0");;;
    let: "l" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty sync.Mutex (zero_val sync.Mutex)) in
    do:  ("l" <-[ptrT] "$r0");;;
    return: (struct.make Log [{
       "d" ::= ![disk.Disk] "d";
       "cache" ::= ![mapT uint64T sliceT] "cache";
       "length" ::= ![ptrT] "lengthPtr";
       "l" ::= ![ptrT] "l"
     }])).

(* Open recovers the log following a crash or shutdown

   go: wal.go:163:6 *)
Definition Open : val :=
  rec: "Open" <> :=
    exception_do (let: "d" := (ref_ty disk.Disk (zero_val disk.Disk)) in
    let: "$r0" := (disk.Get #()) in
    do:  ("d" <-[disk.Disk] "$r0");;;
    let: "header" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (let: "$a0" := #(W64 0) in
    (interface.get "Read" (![disk.Disk] "d")) "$a0") in
    do:  ("header" <-[sliceT] "$r0");;;
    let: "length" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (let: "$a0" := (![sliceT] "header") in
    blockToInt "$a0") in
    do:  ("length" <-[uint64T] "$r0");;;
    do:  (let: "$a0" := (![disk.Disk] "d") in
    let: "$a1" := (![uint64T] "length") in
    applyLog "$a0" "$a1");;;
    do:  (let: "$a0" := (![disk.Disk] "d") in
    clearLog "$a0");;;
    let: "cache" := (ref_ty (mapT uint64T sliceT) (zero_val (mapT uint64T sliceT))) in
    let: "$r0" := (map.make uint64T sliceT #()) in
    do:  ("cache" <-[mapT uint64T sliceT] "$r0");;;
    let: "lengthPtr" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty uint64T (zero_val uint64T)) in
    do:  ("lengthPtr" <-[ptrT] "$r0");;;
    let: "$r0" := #(W64 0) in
    do:  ((![ptrT] "lengthPtr") <-[uint64T] "$r0");;;
    let: "l" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty sync.Mutex (zero_val sync.Mutex)) in
    do:  ("l" <-[ptrT] "$r0");;;
    return: (struct.make Log [{
       "d" ::= ![disk.Disk] "d";
       "cache" ::= ![mapT uint64T sliceT] "cache";
       "length" ::= ![ptrT] "lengthPtr";
       "l" ::= ![ptrT] "l"
     }])).

(* disabled since performance is quite poor

   go: wal.go:178:6 *)
Definition disabled_testWal : val :=
  rec: "disabled_testWal" <> :=
    exception_do (let: "ok" := (ref_ty boolT (zero_val boolT)) in
    let: "$r0" := #true in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "lg" := (ref_ty Log (zero_val Log)) in
    let: "$r0" := (New #()) in
    do:  ("lg" <-[Log] "$r0");;;
    (if: (Log__BeginTxn (![Log] "lg")) #()
    then
      do:  (let: "$a0" := #(W64 2) in
      let: "$a1" := (let: "$a0" := #(W64 11) in
      intToBlock "$a0") in
      (Log__Write (![Log] "lg")) "$a0" "$a1")
    else do:  #());;;
    let: "$r0" := ((![boolT] "ok") && ((let: "$a0" := (let: "$a0" := #(W64 2) in
    (Log__Read (![Log] "lg")) "$a0") in
    blockToInt "$a0") = #(W64 11))) in
    do:  ("ok" <-[boolT] "$r0");;;
    let: "$r0" := ((![boolT] "ok") && ((let: "$a0" := (let: "$a0" := #(W64 0) in
    (interface.get "Read" (![disk.Disk] (struct.field_ref Log "d" "lg"))) "$a0") in
    blockToInt "$a0") = #(W64 0))) in
    do:  ("ok" <-[boolT] "$r0");;;
    do:  ((Log__Commit (![Log] "lg")) #());;;
    let: "$r0" := ((![boolT] "ok") && ((let: "$a0" := (let: "$a0" := #(W64 0) in
    (interface.get "Read" (![disk.Disk] (struct.field_ref Log "d" "lg"))) "$a0") in
    blockToInt "$a0") = #(W64 1))) in
    do:  ("ok" <-[boolT] "$r0");;;
    do:  ((Log__Apply (![Log] "lg")) #());;;
    let: "$r0" := ((![boolT] "ok") && ((![uint64T] (![ptrT] (struct.field_ref Log "length" "lg"))) = #(W64 0))) in
    do:  ("ok" <-[boolT] "$r0");;;
    return: (![boolT] "ok")).
