(* autogenerated from github.com/goose-lang/goose/testdata/examples/semantics *)
Require Export New.code.github_com.goose_lang.primitive.
Require Export New.code.github_com.goose_lang.primitive.disk.
Require Export New.code.sync.

From New.golang Require Import defn.
Definition semantics : go_string := "github.com/goose-lang/goose/testdata/examples/semantics".

From New Require Import disk_prelude.
Module semantics.

Section code.


Definition unitⁱᵐᵖˡ  : go.type := go.StructType [
].

Definition findKey : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.findKey"%go.

(* go: allocator.go:7:6 *)
Definition findKeyⁱᵐᵖˡ : val :=
  λ: "m",
    exception_do (let: "m" := (GoAllocValue (go.MapType go.uint64 unit) "m") in
    let: "found" := (GoAlloc go.uint64 #()) in
    let: "$r0" := #(W64 0) in
    do:  ("found" <-[go.uint64] "$r0");;;
    let: "ok" := (GoAlloc go.bool #()) in
    let: "$r0" := #false in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$range" := (![go.MapType go.uint64 unit] "m") in
    (let: "k" := (GoAlloc go.uint64 #()) in
    map.for_range "$range" (λ: "$key" "value",
      do:  ("k" <-[go.uint64] "$key");;;
      (if: (~ (![go.bool] "ok"))
      then
        let: "$r0" := (![go.uint64] "k") in
        do:  ("found" <-[go.uint64] "$r0");;;
        let: "$r0" := #true in
        do:  ("ok" <-[go.bool] "$r0")
      else do:  #())));;;
    return: (![go.uint64] "found", ![go.bool] "ok")).

Definition allocate : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.allocate"%go.

(* go: allocator.go:20:6 *)
Definition allocateⁱᵐᵖˡ : val :=
  λ: "m",
    exception_do (let: "m" := (GoAllocValue (go.MapType go.uint64 unit) "m") in
    let: "ok" := (GoAlloc go.bool #()) in
    let: "k" := (GoAlloc go.uint64 #()) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.MapType go.uint64 unit] "m") in
    (FuncResolve findKey #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("k" <-[go.uint64] "$r0");;;
    do:  ("ok" <-[go.bool] "$r1");;;
    do:  (let: "$a0" := (![go.MapType go.uint64 unit] "m") in
    let: "$a1" := (![go.uint64] "k") in
    map.delete "$a0" "$a1");;;
    return: (![go.uint64] "k", ![go.bool] "ok")).

Definition freeRange : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.freeRange"%go.

(* go: allocator.go:26:6 *)
Definition freeRangeⁱᵐᵖˡ : val :=
  λ: "sz",
    exception_do (let: "sz" := (GoAllocValue go.uint64 "sz") in
    let: "m" := (GoAlloc (go.MapType go.uint64 unit) #()) in
    let: "$r0" := (map.make go.uint64 unit) in
    do:  ("m" <-[go.MapType go.uint64 unit] "$r0");;;
    (let: "i" := (GoAlloc go.uint64 #()) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, (![go.uint64] "i") < (![go.uint64] "sz")); (λ: <>, do:  ("i" <-[go.uint64] ((![go.uint64] "i") + #(W64 1)))) := λ: <>,
      let: "$r0" := (struct.make unit [{
      }]) in
      do:  (map.insert (![go.MapType go.uint64 unit] "m") (![go.uint64] "i") "$r0")));;;
    return: (![go.MapType go.uint64 unit] "m")).

Definition testAllocateDistinct : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testAllocateDistinct"%go.

(* go: allocator.go:34:6 *)
Definition testAllocateDistinctⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "free" := (GoAlloc (go.MapType go.uint64 unit) #()) in
    let: "$r0" := (let: "$a0" := #(W64 4) in
    (FuncResolve freeRange #()) "$a0") in
    do:  ("free" <-[go.MapType go.uint64 unit] "$r0");;;
    let: "a1" := (GoAlloc go.uint64 #()) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.MapType go.uint64 unit] "free") in
    (FuncResolve allocate #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("a1" <-[go.uint64] "$r0");;;
    do:  "$r1";;;
    let: "a2" := (GoAlloc go.uint64 #()) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.MapType go.uint64 unit] "free") in
    (FuncResolve allocate #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("a2" <-[go.uint64] "$r0");;;
    do:  "$r1";;;
    return: ((![go.uint64] "a1") ≠ (![go.uint64] "a2"))).

Definition testAllocateFull : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testAllocateFull"%go.

(* go: allocator.go:41:6 *)
Definition testAllocateFullⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "free" := (GoAlloc (go.MapType go.uint64 unit) #()) in
    let: "$r0" := (let: "$a0" := #(W64 2) in
    (FuncResolve freeRange #()) "$a0") in
    do:  ("free" <-[go.MapType go.uint64 unit] "$r0");;;
    let: "ok1" := (GoAlloc go.bool #()) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.MapType go.uint64 unit] "free") in
    (FuncResolve allocate #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  "$r0";;;
    do:  ("ok1" <-[go.bool] "$r1");;;
    let: "ok2" := (GoAlloc go.bool #()) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.MapType go.uint64 unit] "free") in
    (FuncResolve allocate #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  "$r0";;;
    do:  ("ok2" <-[go.bool] "$r1");;;
    let: "ok3" := (GoAlloc go.bool #()) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.MapType go.uint64 unit] "free") in
    (FuncResolve allocate #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  "$r0";;;
    do:  ("ok3" <-[go.bool] "$r1");;;
    return: (((![go.bool] "ok1") && (![go.bool] "ok2")) && (~ (![go.bool] "ok3")))).

Definition testExplicitBlockStmt : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testExplicitBlockStmt"%go.

(* go: block.go:3:6 *)
Definition testExplicitBlockStmtⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.int #()) in
    let: "$r0" := #(W64 10) in
    do:  ("x" <-[go.int] "$r0");;;
    let: "x" := (GoAlloc go.int #()) in
    let: "$r0" := #(W64 11) in
    do:  ("x" <-[go.int] "$r0");;;
    do:  ("x" <-[go.int] ((![go.int] "x") + #(W64 1)));;;
    return: ((![go.int] "x") = #(W64 10))).

Definition testMinUint64 : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testMinUint64"%go.

(* go: builtin.go:3:6 *)
Definition testMinUint64ⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.uint64 #()) in
    let: "$r0" := #(W64 10) in
    do:  ("x" <-[go.uint64] "$r0");;;
    return: ((let: "$a0" := (![go.uint64] "x") in
     let: "$a1" := #(W64 1) in
     (minUint64 2) "$a0" "$a1") = #(W64 1))).

Definition testMaxUint64 : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testMaxUint64"%go.

(* go: builtin.go:8:6 *)
Definition testMaxUint64ⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.uint64 #()) in
    let: "$r0" := #(W64 10) in
    do:  ("x" <-[go.uint64] "$r0");;;
    return: ((let: "$a0" := (![go.uint64] "x") in
     let: "$a1" := #(W64 1) in
     (maxUint64 2) "$a0" "$a1") = #(W64 10))).

Definition AdderType  : go.type := go.FunctionType (go.Signature [go.uint64] #false [go.uint64]).

Definition MultipleArgsType  : go.type := go.FunctionType (go.Signature [go.uint64; go.bool] #false [go.uint64]).

Definition adder : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.adder"%go.

(* go: closures.go:6:6 *)
Definition adderⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "sum" := (GoAlloc go.uint64 #()) in
    let: "$r0" := #(W64 0) in
    do:  ("sum" <-[go.uint64] "$r0");;;
    return: ((λ: "x",
       exception_do (let: "x" := (GoAllocValue go.uint64 "x") in
       do:  ("sum" <-[go.uint64] ((![go.uint64] "sum") + (![go.uint64] "x")));;;
       return: (![go.uint64] "sum"))
       ))).

Definition testClosureBasic : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testClosureBasic"%go.

(* go: closures.go:14:6 *)
Definition testClosureBasicⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "pos" := (GoAlloc (go.FunctionType (go.Signature [go.uint64] #false [go.uint64])) #()) in
    let: "$r0" := ((FuncResolve adder #()) #()) in
    do:  ("pos" <-[go.FunctionType (go.Signature [go.uint64] #false [go.uint64])] "$r0");;;
    let: "doub" := (GoAlloc (go.FunctionType (go.Signature [go.uint64] #false [go.uint64])) #()) in
    let: "$r0" := ((FuncResolve adder #()) #()) in
    do:  ("doub" <-[go.FunctionType (go.Signature [go.uint64] #false [go.uint64])] "$r0");;;
    (let: "i" := (GoAlloc go.uint64 #()) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, (![go.uint64] "i") < #(W64 10)); (λ: <>, do:  ("i" <-[go.uint64] ((![go.uint64] "i") + #(W64 1)))) := λ: <>,
      do:  (let: "$a0" := (![go.uint64] "i") in
      (![go.FunctionType (go.Signature [go.uint64] #false [go.uint64])] "pos") "$a0");;;
      do:  (let: "$a0" := (#(W64 2) * (![go.uint64] "i")) in
      (![go.FunctionType (go.Signature [go.uint64] #false [go.uint64])] "doub") "$a0")));;;
    (if: ((let: "$a0" := #(W64 0) in
    (![go.FunctionType (go.Signature [go.uint64] #false [go.uint64])] "pos") "$a0") = #(W64 45)) && ((let: "$a0" := #(W64 0) in
    (![go.FunctionType (go.Signature [go.uint64] #false [go.uint64])] "doub") "$a0") = #(W64 90))
    then return: (#true)
    else do:  #());;;
    return: (#false)).

Definition testCompareAll : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testCompareAll"%go.

(* go: comparisons.go:3:6 *)
Definition testCompareAllⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok" := (GoAlloc go.bool #()) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "nok" := (GoAlloc go.bool #()) in
    let: "$r0" := #false in
    do:  ("nok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && #(1 <? 2)) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && #(2 <? 1)) in
    do:  ("nok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && #(1 <=? 2)) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && #(2 <=? 2)) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && #(2 <=? 1)) in
    do:  ("nok" <-[go.bool] "$r0");;;
    (if: ![go.bool] "nok"
    then return: (#false)
    else do:  #());;;
    return: (![go.bool] "ok")).

Definition testCompareGT : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testCompareGT"%go.

(* go: comparisons.go:20:6 *)
Definition testCompareGTⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.uint64 #()) in
    let: "$r0" := #(W64 4) in
    do:  ("x" <-[go.uint64] "$r0");;;
    let: "y" := (GoAlloc go.uint64 #()) in
    let: "$r0" := #(W64 5) in
    do:  ("y" <-[go.uint64] "$r0");;;
    let: "ok" := (GoAlloc go.bool #()) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] "y") > #(W64 4))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] "y") > (![go.uint64] "x"))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    return: (![go.bool] "ok")).

Definition testCompareGE : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testCompareGE"%go.

(* go: comparisons.go:31:6 *)
Definition testCompareGEⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.uint64 #()) in
    let: "$r0" := #(W64 4) in
    do:  ("x" <-[go.uint64] "$r0");;;
    let: "y" := (GoAlloc go.uint64 #()) in
    let: "$r0" := #(W64 5) in
    do:  ("y" <-[go.uint64] "$r0");;;
    let: "ok" := (GoAlloc go.bool #()) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] "y") ≥ #(W64 4))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] "y") ≥ #(W64 5))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] "y") ≥ (![go.uint64] "x"))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    (if: (![go.uint64] "y") > #(W64 5)
    then return: (#false)
    else do:  #());;;
    return: (![go.bool] "ok")).

Definition testCompareLT : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testCompareLT"%go.

(* go: comparisons.go:47:6 *)
Definition testCompareLTⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.uint64 #()) in
    let: "$r0" := #(W64 4) in
    do:  ("x" <-[go.uint64] "$r0");;;
    let: "y" := (GoAlloc go.uint64 #()) in
    let: "$r0" := #(W64 5) in
    do:  ("y" <-[go.uint64] "$r0");;;
    let: "ok" := (GoAlloc go.bool #()) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] "y") < #(W64 6))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] "x") < (![go.uint64] "y"))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    return: (![go.bool] "ok")).

Definition testCompareLE : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testCompareLE"%go.

(* go: comparisons.go:58:6 *)
Definition testCompareLEⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.uint64 #()) in
    let: "$r0" := #(W64 4) in
    do:  ("x" <-[go.uint64] "$r0");;;
    let: "y" := (GoAlloc go.uint64 #()) in
    let: "$r0" := #(W64 5) in
    do:  ("y" <-[go.uint64] "$r0");;;
    let: "ok" := (GoAlloc go.bool #()) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] "y") ≤ #(W64 6))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] "y") ≤ #(W64 5))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] "x") ≤ (![go.uint64] "y"))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    (if: (![go.uint64] "y") < #(W64 5)
    then return: (#false)
    else do:  #());;;
    return: (![go.bool] "ok")).

Definition literalCast : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.literalCast"%go.

(* go: conversions.go:5:6 *)
Definition literalCastⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.uint64 #()) in
    let: "$r0" := #(W64 2) in
    do:  ("x" <-[go.uint64] "$r0");;;
    return: ((![go.uint64] "x") + #(W64 2))).

Definition stringToByteSlice : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.stringToByteSlice"%go.

(* go: conversions.go:11:6 *)
Definition stringToByteSliceⁱᵐᵖˡ : val :=
  λ: "s",
    exception_do (let: "s" := (GoAllocValue go.string "s") in
    let: "p" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := (string.to_bytes (![go.string] "s")) in
    do:  ("p" <-[go.SliceType go.byte] "$r0");;;
    return: (![go.SliceType go.byte] "p")).

Definition byteSliceToString : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.byteSliceToString"%go.

(* go: conversions.go:17:6 *)
Definition byteSliceToStringⁱᵐᵖˡ : val :=
  λ: "p",
    exception_do (let: "p" := (GoAllocValue (go.SliceType go.byte) "p") in
    return: (string.from_bytes (![go.SliceType go.byte] "p"))).

Definition testByteSliceToString : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testByteSliceToString"%go.

(* tests

   go: conversions.go:23:6 *)
Definition testByteSliceToStringⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := (slice.make2 go.byte #(W64 3)) in
    do:  ("x" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := #(W8 65) in
    do:  ((slice.elem_ref go.byte (![go.SliceType go.byte] "x") #(W64 0)) <-[go.byte] "$r0");;;
    let: "$r0" := #(W8 66) in
    do:  ((slice.elem_ref go.byte (![go.SliceType go.byte] "x") #(W64 1)) <-[go.byte] "$r0");;;
    let: "$r0" := #(W8 67) in
    do:  ((slice.elem_ref go.byte (![go.SliceType go.byte] "x") #(W64 2)) <-[go.byte] "$r0");;;
    return: ((let: "$a0" := (![go.SliceType go.byte] "x") in
     (FuncResolve byteSliceToString #()) "$a0") = #"ABC"%go)).

Definition testCopySimple : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testCopySimple"%go.

(* go: copy.go:3:6 *)
Definition testCopySimpleⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := (slice.make2 go.byte #(W64 10)) in
    do:  ("x" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := #(W8 1) in
    do:  ((slice.elem_ref go.byte (![go.SliceType go.byte] "x") #(W64 3)) <-[go.byte] "$r0");;;
    let: "y" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := (slice.make2 go.byte #(W64 10)) in
    do:  ("y" <-[go.SliceType go.byte] "$r0");;;
    do:  (let: "$a0" := (![go.SliceType go.byte] "y") in
    let: "$a1" := (![go.SliceType go.byte] "x") in
    (slice.copy go.byte) "$a0" "$a1");;;
    return: ((![go.byte] (slice.elem_ref go.byte (![go.SliceType go.byte] "y") #(W64 3))) = #(W8 1))).

Definition testCopyShorterDst : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testCopyShorterDst"%go.

(* go: copy.go:11:6 *)
Definition testCopyShorterDstⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := (slice.make2 go.byte #(W64 15)) in
    do:  ("x" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := #(W8 1) in
    do:  ((slice.elem_ref go.byte (![go.SliceType go.byte] "x") #(W64 3)) <-[go.byte] "$r0");;;
    let: "$r0" := #(W8 2) in
    do:  ((slice.elem_ref go.byte (![go.SliceType go.byte] "x") #(W64 12)) <-[go.byte] "$r0");;;
    let: "y" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := (slice.make2 go.byte #(W64 10)) in
    do:  ("y" <-[go.SliceType go.byte] "$r0");;;
    let: "n" := (GoAlloc go.uint64 #()) in
    let: "$r0" := (s_to_w64 (let: "$a0" := (![go.SliceType go.byte] "y") in
    let: "$a1" := (![go.SliceType go.byte] "x") in
    (slice.copy go.byte) "$a0" "$a1")) in
    do:  ("n" <-[go.uint64] "$r0");;;
    return: (((![go.uint64] "n") = #(W64 10)) && ((![go.byte] (slice.elem_ref go.byte (![go.SliceType go.byte] "y") #(W64 3))) = #(W8 1)))).

Definition testCopyShorterSrc : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testCopyShorterSrc"%go.

(* go: copy.go:20:6 *)
Definition testCopyShorterSrcⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := (slice.make2 go.byte #(W64 10)) in
    do:  ("x" <-[go.SliceType go.byte] "$r0");;;
    let: "y" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := (slice.make2 go.byte #(W64 15)) in
    do:  ("y" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := #(W8 1) in
    do:  ((slice.elem_ref go.byte (![go.SliceType go.byte] "x") #(W64 3)) <-[go.byte] "$r0");;;
    let: "$r0" := #(W8 2) in
    do:  ((slice.elem_ref go.byte (![go.SliceType go.byte] "y") #(W64 12)) <-[go.byte] "$r0");;;
    let: "n" := (GoAlloc go.uint64 #()) in
    let: "$r0" := (s_to_w64 (let: "$a0" := (![go.SliceType go.byte] "y") in
    let: "$a1" := (![go.SliceType go.byte] "x") in
    (slice.copy go.byte) "$a0" "$a1")) in
    do:  ("n" <-[go.uint64] "$r0");;;
    return: ((((![go.uint64] "n") = #(W64 10)) && ((![go.byte] (slice.elem_ref go.byte (![go.SliceType go.byte] "y") #(W64 3))) = #(W8 1))) && ((![go.byte] (slice.elem_ref go.byte (![go.SliceType go.byte] "y") #(W64 12))) = #(W8 2)))).

Definition deferSimple : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.deferSimple"%go.

(* go: defer.go:3:6 *)
Definition deferSimpleⁱᵐᵖˡ : val :=
  λ: <>,
    with_defer: (let: "x" := (GoAlloc (go.PointerType go.uint64) #()) in
    let: "$r0" := (GoAlloc go.uint64 #()) in
    do:  ("x" <-[go.PointerType go.uint64] "$r0");;;
    (let: "i" := (GoAlloc go.uint64 #()) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, (![go.uint64] "i") < #(W64 10)); (λ: <>, do:  ("i" <-[go.uint64] ((![go.uint64] "i") + #(W64 1)))) := λ: <>,
      do:  (let: "$f" := (λ: <>,
        exception_do (do:  ((![go.PointerType go.uint64] "x") <-[go.uint64] ((![go.uint64] (![go.PointerType go.uint64] "x")) + #(W64 1)));;;
        return: #())
        ) in
      "$defer" <-[deferType] (let: "$oldf" := (![deferType] "$defer") in
      (λ: <>,
        "$f" #();;
        "$oldf" #()
        )))));;;
    return: (![go.PointerType go.uint64] "x")).

Definition testDefer : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testDefer"%go.

(* go: defer.go:13:6 *)
Definition testDeferⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: ((![go.uint64] ((FuncResolve deferSimple #()) #())) = #(W64 10))).

Definition testDeferFuncLit : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testDeferFuncLit"%go.

(* go: defer.go:17:6 *)
Definition testDeferFuncLitⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.int #()) in
    let: "$r0" := #(W64 10) in
    do:  ("x" <-[go.int] "$r0");;;
    let: "f" := (GoAlloc (go.FunctionType (go.Signature [] #false [])) #()) in
    let: "$r0" := (λ: <>,
      with_defer: (do:  (let: "$f" := (λ: <>,
        exception_do (do:  ("x" <-[go.int] ((![go.int] "x") + #(W64 1)));;;
        return: #())
        ) in
      "$defer" <-[deferType] (let: "$oldf" := (![deferType] "$defer") in
      (λ: <>,
        "$f" #();;
        "$oldf" #()
        )));;;
      return: #())
      ) in
    do:  ("f" <-[go.FunctionType (go.Signature [] #false [])] "$r0");;;
    do:  ((![go.FunctionType (go.Signature [] #false [])] "f") #());;;
    return: ((![go.int] "x") = #(W64 11))).

Definition Encⁱᵐᵖˡ  : go.type := go.StructType [
  (go.FieldDecl "p"%go go.SliceType go.byte)
].

(* go: encoding.go:10:15 *)
Definition Enc__consumeⁱᵐᵖˡ : val :=
  λ: "e" "n",
    exception_do (let: "e" := (GoAllocValue (go.PointerType Enc) "e") in
    let: "n" := (GoAllocValue go.uint64 "n") in
    let: "b" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := (let: "$s" := (![go.SliceType go.byte] (struct.field_ref Enc #"p"%go (![go.PointerType Enc] "e"))) in
    slice.slice go.byte "$s" #(W64 0) (![go.uint64] "n")) in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$s" := (![go.SliceType go.byte] (struct.field_ref Enc #"p"%go (![go.PointerType Enc] "e"))) in
    slice.slice go.byte "$s" (![go.uint64] "n") (slice.len "$s")) in
    do:  ((struct.field_ref Enc #"p"%go (![go.PointerType Enc] "e")) <-[go.SliceType go.byte] "$r0");;;
    return: (![go.SliceType go.byte] "b")).

Definition Decⁱᵐᵖˡ  : go.type := go.StructType [
  (go.FieldDecl "p"%go go.SliceType go.byte)
].

(* go: encoding.go:20:15 *)
Definition Dec__consumeⁱᵐᵖˡ : val :=
  λ: "d" "n",
    exception_do (let: "d" := (GoAllocValue (go.PointerType Dec) "d") in
    let: "n" := (GoAllocValue go.uint64 "n") in
    let: "b" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := (let: "$s" := (![go.SliceType go.byte] (struct.field_ref Dec #"p"%go (![go.PointerType Dec] "d"))) in
    slice.slice go.byte "$s" #(W64 0) (![go.uint64] "n")) in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$s" := (![go.SliceType go.byte] (struct.field_ref Dec #"p"%go (![go.PointerType Dec] "d"))) in
    slice.slice go.byte "$s" (![go.uint64] "n") (slice.len "$s")) in
    do:  ((struct.field_ref Dec #"p"%go (![go.PointerType Dec] "d")) <-[go.SliceType go.byte] "$r0");;;
    return: (![go.SliceType go.byte] "b")).

Definition roundtripEncDec32 : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.roundtripEncDec32"%go.

(* go: encoding.go:26:6 *)
Definition roundtripEncDec32ⁱᵐᵖˡ : val :=
  λ: "x",
    exception_do (let: "x" := (GoAllocValue go.uint32 "x") in
    let: "r" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := (slice.make2 go.byte #(W64 4)) in
    do:  ("r" <-[go.SliceType go.byte] "$r0");;;
    let: "e" := (GoAlloc (go.PointerType Enc) #()) in
    let: "$r0" := (GoAllocValue Enc (let: "$p" := (![go.SliceType go.byte] "r") in
    struct.make Enc [{
      "p" ::= "$p"
    }])) in
    do:  ("e" <-[go.PointerType Enc] "$r0");;;
    let: "d" := (GoAlloc (go.PointerType Dec) #()) in
    let: "$r0" := (GoAllocValue Dec (let: "$p" := (![go.SliceType go.byte] "r") in
    struct.make Dec [{
      "p" ::= "$p"
    }])) in
    do:  ("d" <-[go.PointerType Dec] "$r0");;;
    do:  (let: "$a0" := (let: "$a0" := #(W64 4) in
    (MethodResolve (go.PointerType Enc) consume #() (![go.PointerType Enc] "e")) "$a0") in
    let: "$a1" := (![go.uint32] "x") in
    (FuncResolve primitive.UInt32Put #()) "$a0" "$a1");;;
    return: (let: "$a0" := (let: "$a0" := #(W64 4) in
     (MethodResolve (go.PointerType Dec) consume #() (![go.PointerType Dec] "d")) "$a0") in
     (FuncResolve primitive.UInt32Get #()) "$a0")).

Definition roundtripEncDec64 : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.roundtripEncDec64"%go.

(* go: encoding.go:34:6 *)
Definition roundtripEncDec64ⁱᵐᵖˡ : val :=
  λ: "x",
    exception_do (let: "x" := (GoAllocValue go.uint64 "x") in
    let: "r" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := (slice.make2 go.byte #(W64 8)) in
    do:  ("r" <-[go.SliceType go.byte] "$r0");;;
    let: "e" := (GoAlloc (go.PointerType Enc) #()) in
    let: "$r0" := (GoAllocValue Enc (let: "$p" := (![go.SliceType go.byte] "r") in
    struct.make Enc [{
      "p" ::= "$p"
    }])) in
    do:  ("e" <-[go.PointerType Enc] "$r0");;;
    let: "d" := (GoAlloc (go.PointerType Dec) #()) in
    let: "$r0" := (GoAllocValue Dec (let: "$p" := (![go.SliceType go.byte] "r") in
    struct.make Dec [{
      "p" ::= "$p"
    }])) in
    do:  ("d" <-[go.PointerType Dec] "$r0");;;
    do:  (let: "$a0" := (let: "$a0" := #(W64 8) in
    (MethodResolve (go.PointerType Enc) consume #() (![go.PointerType Enc] "e")) "$a0") in
    let: "$a1" := (![go.uint64] "x") in
    (FuncResolve primitive.UInt64Put #()) "$a0" "$a1");;;
    return: (let: "$a0" := (let: "$a0" := #(W64 8) in
     (MethodResolve (go.PointerType Dec) consume #() (![go.PointerType Dec] "d")) "$a0") in
     (FuncResolve primitive.UInt64Get #()) "$a0")).

Definition testEncDec32Simple : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testEncDec32Simple"%go.

(* tests

   go: encoding.go:43:6 *)
Definition testEncDec32Simpleⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok" := (GoAlloc go.bool #()) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W32 0) in
    (FuncResolve roundtripEncDec32 #()) "$a0") = #(W32 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W32 1) in
    (FuncResolve roundtripEncDec32 #()) "$a0") = #(W32 1))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W32 1231234) in
    (FuncResolve roundtripEncDec32 #()) "$a0") = #(W32 1231234))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    return: (![go.bool] "ok")).

Definition failing_testEncDec32 : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.failing_testEncDec32"%go.

(* go: encoding.go:51:6 *)
Definition failing_testEncDec32ⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok" := (GoAlloc go.bool #()) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W32 3434807466) in
    (FuncResolve roundtripEncDec32 #()) "$a0") = #(W32 3434807466))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W32 1048576) in
    (FuncResolve roundtripEncDec32 #()) "$a0") = #(W32 1048576))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W32 262144) in
    (FuncResolve roundtripEncDec32 #()) "$a0") = #(W32 262144))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W32 1024) in
    (FuncResolve roundtripEncDec32 #()) "$a0") = #(W32 1024))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W32 1) in
    (FuncResolve roundtripEncDec32 #()) "$a0") = #(W32 1))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W32 (4294967296 - 1)) in
    (FuncResolve roundtripEncDec32 #()) "$a0") = #(W32 (4294967296 - 1)))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    return: (![go.bool] "ok")).

Definition testEncDec64Simple : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testEncDec64Simple"%go.

(* go: encoding.go:62:6 *)
Definition testEncDec64Simpleⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok" := (GoAlloc go.bool #()) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W64 0) in
    (FuncResolve roundtripEncDec64 #()) "$a0") = #(W64 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W64 1) in
    (FuncResolve roundtripEncDec64 #()) "$a0") = #(W64 1))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W64 1231234) in
    (FuncResolve roundtripEncDec64 #()) "$a0") = #(W64 1231234))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    return: (![go.bool] "ok")).

Definition testEncDec64 : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testEncDec64"%go.

(* go: encoding.go:70:6 *)
Definition testEncDec64ⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok" := (GoAlloc go.bool #()) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W64 62206846038638762) in
    (FuncResolve roundtripEncDec64 #()) "$a0") = #(W64 62206846038638762))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W64 9223372036854775808) in
    (FuncResolve roundtripEncDec64 #()) "$a0") = #(W64 9223372036854775808))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W64 140737488355328) in
    (FuncResolve roundtripEncDec64 #()) "$a0") = #(W64 140737488355328))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W64 1048576) in
    (FuncResolve roundtripEncDec64 #()) "$a0") = #(W64 1048576))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W64 262144) in
    (FuncResolve roundtripEncDec64 #()) "$a0") = #(W64 262144))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W64 1024) in
    (FuncResolve roundtripEncDec64 #()) "$a0") = #(W64 1024))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W64 1) in
    (FuncResolve roundtripEncDec64 #()) "$a0") = #(W64 1))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W64 (18446744073709551616 - 1)) in
    (FuncResolve roundtripEncDec64 #()) "$a0") = #(W64 (18446744073709551616 - 1)))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    return: (![go.bool] "ok")).

Definition FirstClassFunction : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.FirstClassFunction"%go.

(* go: first_class_function.go:3:6 *)
Definition FirstClassFunctionⁱᵐᵖˡ : val :=
  λ: "a",
    exception_do (let: "a" := (GoAllocValue go.uint64 "a") in
    return: ((![go.uint64] "a") + #(W64 10))).

Definition ApplyF : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.ApplyF"%go.

(* go: first_class_function.go:7:6 *)
Definition ApplyFⁱᵐᵖˡ : val :=
  λ: "a" "f",
    exception_do (let: "f" := (GoAllocValue (go.FunctionType (go.Signature [go.uint64] #false [go.uint64])) "f") in
    let: "a" := (GoAllocValue go.uint64 "a") in
    return: (let: "$a0" := (![go.uint64] "a") in
     (![go.FunctionType (go.Signature [go.uint64] #false [go.uint64])] "f") "$a0")).

Definition testFirstClassFunction : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testFirstClassFunction"%go.

(* go: first_class_function.go:11:6 *)
Definition testFirstClassFunctionⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: ((let: "$a0" := #(W64 1) in
     let: "$a1" := (FuncResolve FirstClassFunction #()) in
     (FuncResolve ApplyF #()) "$a0" "$a1") = #(W64 11))).

Definition Editorⁱᵐᵖˡ  : go.type := go.StructType [
  (go.FieldDecl "s"%go go.SliceType go.uint64);
  (go.FieldDecl "next_val"%go go.uint64)
].

(* advances the array editor, and returns the value it wrote, storing
   "next" in next_val

   go: function_ordering.go:11:18 *)
Definition Editor__AdvanceReturnⁱᵐᵖˡ : val :=
  λ: "e" "next",
    exception_do (let: "e" := (GoAllocValue (go.PointerType Editor) "e") in
    let: "next" := (GoAllocValue go.uint64 "next") in
    let: "tmp" := (GoAlloc go.uint64 #()) in
    let: "$r0" := (![go.uint64] (struct.field_ref Editor #"next_val"%go (![go.PointerType Editor] "e"))) in
    do:  ("tmp" <-[go.uint64] "$r0");;;
    let: "$r0" := (![go.uint64] "tmp") in
    do:  ((slice.elem_ref go.uint64 (![go.SliceType go.uint64] (struct.field_ref Editor #"s"%go (![go.PointerType Editor] "e"))) #(W64 0)) <-[go.uint64] "$r0");;;
    let: "$r0" := (![go.uint64] "next") in
    do:  ((struct.field_ref Editor #"next_val"%go (![go.PointerType Editor] "e")) <-[go.uint64] "$r0");;;
    let: "$r0" := (let: "$s" := (![go.SliceType go.uint64] (struct.field_ref Editor #"s"%go (![go.PointerType Editor] "e"))) in
    slice.slice go.uint64 "$s" #(W64 1) (slice.len "$s")) in
    do:  ((struct.field_ref Editor #"s"%go (![go.PointerType Editor] "e")) <-[go.SliceType go.uint64] "$r0");;;
    return: (![go.uint64] "tmp")).

Definition addFour64 : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.addFour64"%go.

(* we call this function with side-effectful function calls as arguments,
   its implementation is unimportant

   go: function_ordering.go:21:6 *)
Definition addFour64ⁱᵐᵖˡ : val :=
  λ: "a" "b" "c" "d",
    exception_do (let: "d" := (GoAllocValue go.uint64 "d") in
    let: "c" := (GoAllocValue go.uint64 "c") in
    let: "b" := (GoAllocValue go.uint64 "b") in
    let: "a" := (GoAllocValue go.uint64 "a") in
    return: ((((![go.uint64] "a") + (![go.uint64] "b")) + (![go.uint64] "c")) + (![go.uint64] "d"))).

Definition Pairⁱᵐᵖˡ  : go.type := go.StructType [
  (go.FieldDecl "x"%go go.uint64);
  (go.FieldDecl "y"%go go.uint64)
].

Definition failing_testFunctionOrdering : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.failing_testFunctionOrdering"%go.

(* tests

   go: function_ordering.go:31:6 *)
Definition failing_testFunctionOrderingⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "arr" := (GoAlloc (go.SliceType go.uint64) #()) in
    let: "$r0" := (slice.make2 go.uint64 #(W64 5)) in
    do:  ("arr" <-[go.SliceType go.uint64] "$r0");;;
    let: "e1" := (GoAlloc Editor #()) in
    let: "$r0" := (let: "$s" := (let: "$s" := (![go.SliceType go.uint64] "arr") in
    slice.slice go.uint64 "$s" #(W64 0) (slice.len "$s")) in
    let: "$next_val" := #(W64 1) in
    struct.make Editor [{
      "s" ::= "$s";
      "next_val" ::= "$next_val"
    }]) in
    do:  ("e1" <-[Editor] "$r0");;;
    let: "e2" := (GoAlloc Editor #()) in
    let: "$r0" := (let: "$s" := (let: "$s" := (![go.SliceType go.uint64] "arr") in
    slice.slice go.uint64 "$s" #(W64 0) (slice.len "$s")) in
    let: "$next_val" := #(W64 101) in
    struct.make Editor [{
      "s" ::= "$s";
      "next_val" ::= "$next_val"
    }]) in
    do:  ("e2" <-[Editor] "$r0");;;
    (if: ((let: "$a0" := #(W64 2) in
    (MethodResolve (go.PointerType Editor) AdvanceReturn #() "e1") "$a0") + (let: "$a0" := #(W64 102) in
    (MethodResolve (go.PointerType Editor) AdvanceReturn #() "e2") "$a0")) ≠ #(W64 102)
    then return: (#false)
    else do:  #());;;
    (if: (![go.uint64] (slice.elem_ref go.uint64 (![go.SliceType go.uint64] "arr") #(W64 0))) ≠ #(W64 101)
    then return: (#false)
    else do:  #());;;
    (if: (let: "$a0" := (let: "$a0" := #(W64 3) in
    (MethodResolve (go.PointerType Editor) AdvanceReturn #() "e1") "$a0") in
    let: "$a1" := (let: "$a0" := #(W64 103) in
    (MethodResolve (go.PointerType Editor) AdvanceReturn #() "e2") "$a0") in
    let: "$a2" := (let: "$a0" := #(W64 104) in
    (MethodResolve (go.PointerType Editor) AdvanceReturn #() "e2") "$a0") in
    let: "$a3" := (let: "$a0" := #(W64 4) in
    (MethodResolve (go.PointerType Editor) AdvanceReturn #() "e1") "$a0") in
    (FuncResolve addFour64 #()) "$a0" "$a1" "$a2" "$a3") ≠ #(W64 210)
    then return: (#false)
    else do:  #());;;
    (if: (![go.uint64] (slice.elem_ref go.uint64 (![go.SliceType go.uint64] "arr") #(W64 1))) ≠ #(W64 102)
    then return: (#false)
    else do:  #());;;
    (if: (![go.uint64] (slice.elem_ref go.uint64 (![go.SliceType go.uint64] "arr") #(W64 2))) ≠ #(W64 3)
    then return: (#false)
    else do:  #());;;
    let: "p" := (GoAlloc Pair #()) in
    let: "$r0" := (let: "$x" := (let: "$a0" := #(W64 5) in
    (MethodResolve (go.PointerType Editor) AdvanceReturn #() "e1") "$a0") in
    let: "$y" := (let: "$a0" := #(W64 105) in
    (MethodResolve (go.PointerType Editor) AdvanceReturn #() "e2") "$a0") in
    struct.make Pair [{
      "x" ::= "$x";
      "y" ::= "$y"
    }]) in
    do:  ("p" <-[Pair] "$r0");;;
    (if: (![go.uint64] (slice.elem_ref go.uint64 (![go.SliceType go.uint64] "arr") #(W64 3))) ≠ #(W64 104)
    then return: (#false)
    else do:  #());;;
    let: "q" := (GoAlloc Pair #()) in
    let: "$r0" := (let: "$y" := (let: "$a0" := #(W64 6) in
    (MethodResolve (go.PointerType Editor) AdvanceReturn #() "e1") "$a0") in
    let: "$x" := (let: "$a0" := #(W64 106) in
    (MethodResolve (go.PointerType Editor) AdvanceReturn #() "e2") "$a0") in
    struct.make Pair [{
      "x" ::= "$x";
      "y" ::= "$y"
    }]) in
    do:  ("q" <-[Pair] "$r0");;;
    (if: (![go.uint64] (slice.elem_ref go.uint64 (![go.SliceType go.uint64] "arr") #(W64 4))) ≠ #(W64 105)
    then return: (#false)
    else do:  #());;;
    return: (((![go.uint64] (struct.field_ref Pair #"x"%go "p")) + (![go.uint64] (struct.field_ref Pair #"x"%go "q"))) = #(W64 109))).

Definition storeAndReturn : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.storeAndReturn"%go.

(* go: function_ordering.go:74:6 *)
Definition storeAndReturnⁱᵐᵖˡ : val :=
  λ: "x" "v",
    exception_do (let: "v" := (GoAllocValue go.uint64 "v") in
    let: "x" := (GoAllocValue (go.PointerType go.uint64) "x") in
    let: "$r0" := (![go.uint64] "v") in
    do:  ((![go.PointerType go.uint64] "x") <-[go.uint64] "$r0");;;
    return: (![go.uint64] "v")).

Definition failing_testArgumentOrder : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.failing_testArgumentOrder"%go.

(* Goose has a right-to-left evaluation order for function arguments,
   which is incorrect.

   go: function_ordering.go:81:6 *)
Definition failing_testArgumentOrderⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.uint64 #()) in
    let: "$r0" := #(W64 0) in
    do:  ("x" <-[go.uint64] "$r0");;;
    do:  (let: "$a0" := (let: "$a0" := "x" in
    let: "$a1" := #(W64 1) in
    (FuncResolve storeAndReturn #()) "$a0" "$a1") in
    let: "$a1" := (let: "$a0" := "x" in
    let: "$a1" := #(W64 2) in
    (FuncResolve storeAndReturn #()) "$a0" "$a1") in
    let: "$a2" := (let: "$a0" := "x" in
    let: "$a1" := #(W64 3) in
    (FuncResolve storeAndReturn #()) "$a0" "$a1") in
    let: "$a3" := (let: "$a0" := "x" in
    let: "$a1" := #(W64 4) in
    (FuncResolve storeAndReturn #()) "$a0" "$a1") in
    (FuncResolve addFour64 #()) "$a0" "$a1" "$a2" "$a3");;;
    let: "ok" := (GoAlloc go.bool #()) in
    let: "$r0" := ((![go.uint64] "x") = #(W64 4)) in
    do:  ("ok" <-[go.bool] "$r0");;;
    return: (![go.bool] "ok")).

Definition testU64ToU32 : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testU64ToU32"%go.

(* go: int_conversions.go:3:6 *)
Definition testU64ToU32ⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok" := (GoAlloc go.bool #()) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "x" := (GoAlloc go.uint64 #()) in
    let: "$r0" := #(W64 1230) in
    do:  ("x" <-[go.uint64] "$r0");;;
    let: "y" := (GoAlloc go.uint32 #()) in
    let: "$r0" := #(W32 1230) in
    do:  ("y" <-[go.uint32] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((u_to_w32 (![go.uint64] "x")) = (![go.uint32] "y"))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((u_to_w64 (![go.uint32] "y")) = (![go.uint64] "x"))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    return: (![go.bool] "ok")).

Definition testU32Len : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testU32Len"%go.

(* go: int_conversions.go:12:6 *)
Definition testU32Lenⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "s" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := (slice.make2 go.byte #(W64 100)) in
    do:  ("s" <-[go.SliceType go.byte] "$r0");;;
    return: ((s_to_w32 (let: "$a0" := (![go.SliceType go.byte] "s") in
     slice.len "$a0")) = #(W32 100))).

Definition Uint32ⁱᵐᵖˡ  : go.type := go.uint32.

Definition failing_testU32NewtypeLen : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.failing_testU32NewtypeLen"%go.

(* https://github.com/goose-lang/goose/issues/14

   go: int_conversions.go:20:6 *)
Definition failing_testU32NewtypeLenⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "s" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := (slice.make2 go.byte #(W64 20)) in
    do:  ("s" <-[go.SliceType go.byte] "$r0");;;
    return: ((s_to_w32 (let: "$a0" := (![go.SliceType go.byte] "s") in
     slice.len "$a0")) = #(W32 20))).

Definition geometryInterfaceⁱᵐᵖˡ  : go.type := go.InterfaceType [go.MethodElem #"Square"%go (go.Signature [] #false [go.uint64]); go.MethodElem #"Volume"%go (go.Signature [] #false [go.uint64])].

Definition measureArea : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.measureArea"%go.

(* go: interfaces.go:12:6 *)
Definition measureAreaⁱᵐᵖˡ : val :=
  λ: "t",
    exception_do (let: "t" := (GoAllocValue geometryInterface "t") in
    return: ((interface.get #"Square"%go (![geometryInterface] "t")) #())).

Definition measureVolumePlusNM : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.measureVolumePlusNM"%go.

(* go: interfaces.go:16:6 *)
Definition measureVolumePlusNMⁱᵐᵖˡ : val :=
  λ: "t" "n" "m",
    exception_do (let: "m" := (GoAllocValue go.uint64 "m") in
    let: "n" := (GoAllocValue go.uint64 "n") in
    let: "t" := (GoAllocValue geometryInterface "t") in
    return: ((((interface.get #"Volume"%go (![geometryInterface] "t")) #()) + (![go.uint64] "n")) + (![go.uint64] "m"))).

Definition measureVolume : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.measureVolume"%go.

(* go: interfaces.go:20:6 *)
Definition measureVolumeⁱᵐᵖˡ : val :=
  λ: "t",
    exception_do (let: "t" := (GoAllocValue geometryInterface "t") in
    return: ((interface.get #"Volume"%go (![geometryInterface] "t")) #())).

Definition SquareStructⁱᵐᵖˡ  : go.type := go.StructType [
  (go.FieldDecl "Side"%go go.uint64)
].

(* go: interfaces.go:28:23 *)
Definition SquareStruct__Squareⁱᵐᵖˡ : val :=
  λ: "t" <>,
    exception_do (let: "t" := (GoAllocValue SquareStruct "t") in
    return: ((![go.uint64] (struct.field_ref SquareStruct #"Side"%go "t")) * (![go.uint64] (struct.field_ref SquareStruct #"Side"%go "t")))).

(* go: interfaces.go:32:23 *)
Definition SquareStruct__Volumeⁱᵐᵖˡ : val :=
  λ: "t" <>,
    exception_do (let: "t" := (GoAllocValue SquareStruct "t") in
    return: (((![go.uint64] (struct.field_ref SquareStruct #"Side"%go "t")) * (![go.uint64] (struct.field_ref SquareStruct #"Side"%go "t"))) * (![go.uint64] (struct.field_ref SquareStruct #"Side"%go "t")))).

Definition testBasicInterface : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testBasicInterface"%go.

(* go: interfaces.go:40:6 *)
Definition testBasicInterfaceⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "s" := (GoAlloc SquareStruct #()) in
    let: "$r0" := (let: "$Side" := #(W64 2) in
    struct.make SquareStruct [{
      "Side" ::= "$Side"
    }]) in
    do:  ("s" <-[SquareStruct] "$r0");;;
    return: ((let: "$a0" := (InterfaceMake SquareStruct (![SquareStruct] "s")) in
     (FuncResolve measureArea #()) "$a0") = #(W64 4))).

Definition testAssignInterface : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testAssignInterface"%go.

(* go: interfaces.go:47:6 *)
Definition testAssignInterfaceⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "s" := (GoAlloc SquareStruct #()) in
    let: "$r0" := (let: "$Side" := #(W64 3) in
    struct.make SquareStruct [{
      "Side" ::= "$Side"
    }]) in
    do:  ("s" <-[SquareStruct] "$r0");;;
    let: "area" := (GoAlloc go.uint64 #()) in
    let: "$r0" := (let: "$a0" := (InterfaceMake SquareStruct (![SquareStruct] "s")) in
    (FuncResolve measureArea #()) "$a0") in
    do:  ("area" <-[go.uint64] "$r0");;;
    return: ((![go.uint64] "area") = #(W64 9))).

Definition testMultipleInterface : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testMultipleInterface"%go.

(* go: interfaces.go:55:6 *)
Definition testMultipleInterfaceⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "s" := (GoAlloc SquareStruct #()) in
    let: "$r0" := (let: "$Side" := #(W64 3) in
    struct.make SquareStruct [{
      "Side" ::= "$Side"
    }]) in
    do:  ("s" <-[SquareStruct] "$r0");;;
    let: "square1" := (GoAlloc go.uint64 #()) in
    let: "$r0" := (let: "$a0" := (InterfaceMake SquareStruct (![SquareStruct] "s")) in
    (FuncResolve measureArea #()) "$a0") in
    do:  ("square1" <-[go.uint64] "$r0");;;
    let: "square2" := (GoAlloc go.uint64 #()) in
    let: "$r0" := (let: "$a0" := (InterfaceMake SquareStruct (![SquareStruct] "s")) in
    (FuncResolve measureArea #()) "$a0") in
    do:  ("square2" <-[go.uint64] "$r0");;;
    return: ((![go.uint64] "square1") = (![go.uint64] "square2"))).

Definition testBinaryExprInterface : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testBinaryExprInterface"%go.

(* go: interfaces.go:64:6 *)
Definition testBinaryExprInterfaceⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "s" := (GoAlloc SquareStruct #()) in
    let: "$r0" := (let: "$Side" := #(W64 3) in
    struct.make SquareStruct [{
      "Side" ::= "$Side"
    }]) in
    do:  ("s" <-[SquareStruct] "$r0");;;
    let: "square1" := (GoAlloc go.uint64 #()) in
    let: "$r0" := (let: "$a0" := (InterfaceMake SquareStruct (![SquareStruct] "s")) in
    (FuncResolve measureArea #()) "$a0") in
    do:  ("square1" <-[go.uint64] "$r0");;;
    let: "square2" := (GoAlloc go.uint64 #()) in
    let: "$r0" := (let: "$a0" := (InterfaceMake SquareStruct (![SquareStruct] "s")) in
    (FuncResolve measureVolume #()) "$a0") in
    do:  ("square2" <-[go.uint64] "$r0");;;
    return: (((![go.uint64] "square1") = (let: "$a0" := (InterfaceMake SquareStruct (![SquareStruct] "s")) in
     (FuncResolve measureArea #()) "$a0")) && ((![go.uint64] "square2") = (let: "$a0" := (InterfaceMake SquareStruct (![SquareStruct] "s")) in
     (FuncResolve measureVolume #()) "$a0")))).

Definition testIfStmtInterface : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testIfStmtInterface"%go.

(* go: interfaces.go:73:6 *)
Definition testIfStmtInterfaceⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "s" := (GoAlloc SquareStruct #()) in
    let: "$r0" := (let: "$Side" := #(W64 3) in
    struct.make SquareStruct [{
      "Side" ::= "$Side"
    }]) in
    do:  ("s" <-[SquareStruct] "$r0");;;
    (if: (let: "$a0" := (InterfaceMake SquareStruct (![SquareStruct] "s")) in
    (FuncResolve measureArea #()) "$a0") = #(W64 9)
    then return: (#true)
    else do:  #());;;
    return: (#false)).

Definition testsUseLocks : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testsUseLocks"%go.

(* We can't interpret multithreaded code, so this just checks that
   locks are correctly interpreted

   go: lock.go:7:6 *)
Definition testsUseLocksⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "m" := (GoAlloc (go.PointerType sync.Mutex) #()) in
    let: "$r0" := (GoAlloc sync.Mutex #()) in
    do:  ("m" <-[go.PointerType sync.Mutex] "$r0");;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) Lock #() (![go.PointerType sync.Mutex] "m")) #());;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) Unlock #() (![go.PointerType sync.Mutex] "m")) #());;;
    return: (#true)).

Definition standardForLoop : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.standardForLoop"%go.

(* helpers

   go: loops.go:4:6 *)
Definition standardForLoopⁱᵐᵖˡ : val :=
  λ: "s",
    exception_do (let: "s" := (GoAllocValue (go.SliceType go.uint64) "s") in
    let: "sumPtr" := (GoAlloc (go.PointerType go.uint64) #()) in
    let: "$r0" := (GoAlloc go.uint64 #()) in
    do:  ("sumPtr" <-[go.PointerType go.uint64] "$r0");;;
    (let: "i" := (GoAlloc go.uint64 #()) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (if: (![go.uint64] "i") < (s_to_w64 (let: "$a0" := (![go.SliceType go.uint64] "s") in
      slice.len "$a0"))
      then
        let: "sum" := (GoAlloc go.uint64 #()) in
        let: "$r0" := (![go.uint64] (![go.PointerType go.uint64] "sumPtr")) in
        do:  ("sum" <-[go.uint64] "$r0");;;
        let: "x" := (GoAlloc go.uint64 #()) in
        let: "$r0" := (![go.uint64] (slice.elem_ref go.uint64 (![go.SliceType go.uint64] "s") (![go.uint64] "i"))) in
        do:  ("x" <-[go.uint64] "$r0");;;
        let: "$r0" := ((![go.uint64] "sum") + (![go.uint64] "x")) in
        do:  ((![go.PointerType go.uint64] "sumPtr") <-[go.uint64] "$r0");;;
        let: "$r0" := ((![go.uint64] "i") + #(W64 1)) in
        do:  ("i" <-[go.uint64] "$r0");;;
        continue: #()
      else do:  #());;;
      break: #()));;;
    let: "sum" := (GoAlloc go.uint64 #()) in
    let: "$r0" := (![go.uint64] (![go.PointerType go.uint64] "sumPtr")) in
    do:  ("sum" <-[go.uint64] "$r0");;;
    return: (![go.uint64] "sum")).

Definition LoopStructⁱᵐᵖˡ  : go.type := go.StructType [
  (go.FieldDecl "loopNext"%go go.PointerType go.uint64)
].

(* go: loops.go:28:22 *)
Definition LoopStruct__forLoopWaitⁱᵐᵖˡ : val :=
  λ: "ls" "i",
    exception_do (let: "ls" := (GoAllocValue LoopStruct "ls") in
    let: "i" := (GoAllocValue go.uint64 "i") in
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "nxt" := (GoAlloc (go.PointerType go.uint64) #()) in
      let: "$r0" := (![go.PointerType go.uint64] (struct.field_ref LoopStruct #"loopNext"%go "ls")) in
      do:  ("nxt" <-[go.PointerType go.uint64] "$r0");;;
      (if: (![go.uint64] "i") < (![go.uint64] (![go.PointerType go.uint64] "nxt"))
      then break: #()
      else do:  #());;;
      let: "$r0" := ((![go.uint64] (![go.PointerType go.uint64] (struct.field_ref LoopStruct #"loopNext"%go "ls"))) + #(W64 1)) in
      do:  ((![go.PointerType go.uint64] (struct.field_ref LoopStruct #"loopNext"%go "ls")) <-[go.uint64] "$r0");;;
      continue: #());;;
    return: #()).

Definition testStandardForLoop : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testStandardForLoop"%go.

(* tests

   go: loops.go:40:6 *)
Definition testStandardForLoopⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "arr" := (GoAlloc (go.SliceType go.uint64) #()) in
    let: "$r0" := (slice.make2 go.uint64 #(W64 4)) in
    do:  ("arr" <-[go.SliceType go.uint64] "$r0");;;
    do:  ((slice.elem_ref go.uint64 (![go.SliceType go.uint64] "arr") #(W64 0)) <-[go.uint64] ((![go.uint64] (slice.elem_ref go.uint64 (![go.SliceType go.uint64] "arr") #(W64 0))) + #(W64 1)));;;
    do:  ((slice.elem_ref go.uint64 (![go.SliceType go.uint64] "arr") #(W64 1)) <-[go.uint64] ((![go.uint64] (slice.elem_ref go.uint64 (![go.SliceType go.uint64] "arr") #(W64 1))) + #(W64 3)));;;
    do:  ((slice.elem_ref go.uint64 (![go.SliceType go.uint64] "arr") #(W64 2)) <-[go.uint64] ((![go.uint64] (slice.elem_ref go.uint64 (![go.SliceType go.uint64] "arr") #(W64 2))) + #(W64 5)));;;
    do:  ((slice.elem_ref go.uint64 (![go.SliceType go.uint64] "arr") #(W64 3)) <-[go.uint64] ((![go.uint64] (slice.elem_ref go.uint64 (![go.SliceType go.uint64] "arr") #(W64 3))) + #(W64 7)));;;
    return: ((let: "$a0" := (![go.SliceType go.uint64] "arr") in
     (FuncResolve standardForLoop #()) "$a0") = #(W64 16))).

Definition testForLoopWait : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testForLoopWait"%go.

(* go: loops.go:49:6 *)
Definition testForLoopWaitⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ls" := (GoAlloc LoopStruct #()) in
    let: "$r0" := (let: "$loopNext" := (GoAlloc go.uint64 #()) in
    struct.make LoopStruct [{
      "loopNext" ::= "$loopNext"
    }]) in
    do:  ("ls" <-[LoopStruct] "$r0");;;
    do:  (let: "$a0" := #(W64 3) in
    (MethodResolve LoopStruct forLoopWait #() (![LoopStruct] "ls")) "$a0");;;
    return: ((![go.uint64] (![go.PointerType go.uint64] (struct.field_ref LoopStruct #"loopNext"%go "ls"))) = #(W64 4))).

Definition testBreakFromLoopWithContinue : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testBreakFromLoopWithContinue"%go.

(* go: loops.go:59:6 *)
Definition testBreakFromLoopWithContinueⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "i" := (GoAlloc go.uint64 #()) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (if: #true
      then
        let: "$r0" := ((![go.uint64] "i") + #(W64 1)) in
        do:  ("i" <-[go.uint64] "$r0");;;
        break: #()
      else do:  #());;;
      continue: #());;;
    return: ((![go.uint64] "i") = #(W64 1))).

Definition testBreakFromLoopNoContinue : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testBreakFromLoopNoContinue"%go.

(* go: loops.go:71:6 *)
Definition testBreakFromLoopNoContinueⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "i" := (GoAlloc go.uint64 #()) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, (![go.uint64] "i") < #(W64 3)); (λ: <>, #()) := λ: <>,
      (if: #true
      then
        let: "$r0" := ((![go.uint64] "i") + #(W64 1)) in
        do:  ("i" <-[go.uint64] "$r0");;;
        break: #()
      else do:  #());;;
      let: "$r0" := ((![go.uint64] "i") + #(W64 2)) in
      do:  ("i" <-[go.uint64] "$r0"));;;
    return: ((![go.uint64] "i") = #(W64 1))).

Definition testBreakFromLoopNoContinueDouble : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testBreakFromLoopNoContinueDouble"%go.

(* go: loops.go:83:6 *)
Definition testBreakFromLoopNoContinueDoubleⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "i" := (GoAlloc go.uint64 #()) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, (![go.uint64] "i") < #(W64 3)); (λ: <>, #()) := λ: <>,
      (if: (![go.uint64] "i") = #(W64 1)
      then
        let: "$r0" := ((![go.uint64] "i") + #(W64 1)) in
        do:  ("i" <-[go.uint64] "$r0");;;
        break: #()
      else do:  #());;;
      let: "$r0" := ((![go.uint64] "i") + #(W64 2)) in
      do:  ("i" <-[go.uint64] "$r0");;;
      let: "$r0" := ((![go.uint64] "i") + #(W64 2)) in
      do:  ("i" <-[go.uint64] "$r0"));;;
    return: ((![go.uint64] "i") = #(W64 4))).

Definition testBreakFromLoopForOnly : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testBreakFromLoopForOnly"%go.

(* go: loops.go:96:6 *)
Definition testBreakFromLoopForOnlyⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "i" := (GoAlloc go.uint64 #()) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, (![go.uint64] "i") < #(W64 3)); (λ: <>, #()) := λ: <>,
      let: "$r0" := ((![go.uint64] "i") + #(W64 2)) in
      do:  ("i" <-[go.uint64] "$r0"));;;
    return: ((![go.uint64] "i") = #(W64 4))).

Definition testBreakFromLoopAssignAndContinue : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testBreakFromLoopAssignAndContinue"%go.

(* go: loops.go:104:6 *)
Definition testBreakFromLoopAssignAndContinueⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "i" := (GoAlloc go.uint64 #()) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, (![go.uint64] "i") < #(W64 3)); (λ: <>, #()) := λ: <>,
      (if: #true
      then
        let: "$r0" := ((![go.uint64] "i") + #(W64 1)) in
        do:  ("i" <-[go.uint64] "$r0");;;
        break: #()
      else do:  #());;;
      let: "$r0" := ((![go.uint64] "i") + #(W64 2)) in
      do:  ("i" <-[go.uint64] "$r0");;;
      continue: #());;;
    return: ((![go.uint64] "i") = #(W64 1))).

Definition testNestedLoops : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testNestedLoops"%go.

(* go: loops.go:117:6 *)
Definition testNestedLoopsⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok1" := (GoAlloc go.bool #()) in
    let: "$r0" := #false in
    do:  ("ok1" <-[go.bool] "$r0");;;
    let: "ok2" := (GoAlloc go.bool #()) in
    let: "$r0" := #false in
    do:  ("ok2" <-[go.bool] "$r0");;;
    (let: "i" := (GoAlloc go.uint64 #()) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (let: "j" := (GoAlloc go.uint64 #()) in
      let: "$r0" := #(W64 0) in
      do:  ("j" <-[go.uint64] "$r0");;;
      (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
        (if: (![go.uint64] "j") > #(W64 5)
        then break: #()
        else do:  #());;;
        let: "$r0" := ((![go.uint64] "j") + #(W64 1)) in
        do:  ("j" <-[go.uint64] "$r0");;;
        let: "$r0" := ((![go.uint64] "j") = #(W64 6)) in
        do:  ("ok1" <-[go.bool] "$r0");;;
        continue: #()));;;
      let: "$r0" := ((![go.uint64] "i") + #(W64 1)) in
      do:  ("i" <-[go.uint64] "$r0");;;
      let: "$r0" := ((![go.uint64] "i") = #(W64 1)) in
      do:  ("ok2" <-[go.bool] "$r0");;;
      break: #()));;;
    return: ((![go.bool] "ok1") && (![go.bool] "ok2"))).

Definition testNestedGoStyleLoops : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testNestedGoStyleLoops"%go.

(* go: loops.go:136:6 *)
Definition testNestedGoStyleLoopsⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok" := (GoAlloc go.bool #()) in
    let: "$r0" := #false in
    do:  ("ok" <-[go.bool] "$r0");;;
    (let: "i" := (GoAlloc go.uint64 #()) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, (![go.uint64] "i") < #(W64 10)); (λ: <>, do:  ("i" <-[go.uint64] ((![go.uint64] "i") + #(W64 1)))) := λ: <>,
      (let: "j" := (GoAlloc go.uint64 #()) in
      let: "$r0" := #(W64 0) in
      do:  ("j" <-[go.uint64] "$r0");;;
      (for: (λ: <>, (![go.uint64] "j") < (![go.uint64] "i")); (λ: <>, do:  ("j" <-[go.uint64] ((![go.uint64] "j") + #(W64 1)))) := λ: <>,
        (if: #true
        then break: #()
        else do:  #());;;
        continue: #()));;;
      let: "$r0" := ((![go.uint64] "i") = #(W64 9)) in
      do:  ("ok" <-[go.bool] "$r0")));;;
    return: (![go.bool] "ok")).

Definition testNestedGoStyleLoopsNoComparison : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testNestedGoStyleLoopsNoComparison"%go.

(* go: loops.go:150:6 *)
Definition testNestedGoStyleLoopsNoComparisonⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok" := (GoAlloc go.bool #()) in
    let: "$r0" := #false in
    do:  ("ok" <-[go.bool] "$r0");;;
    (let: "i" := (GoAlloc go.uint64 #()) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, (![go.uint64] "i") < #(W64 10)); (λ: <>, do:  ("i" <-[go.uint64] ((![go.uint64] "i") + #(W64 1)))) := λ: <>,
      (let: "j" := (GoAlloc go.uint64 #()) in
      let: "$r0" := #(W64 0) in
      do:  ("j" <-[go.uint64] "$r0");;;
      (for: (λ: <>, (![go.uint64] "j") < (![go.uint64] "i")); (λ: <>, do:  ("j" <-[go.uint64] ((![go.uint64] "j") + #(W64 1)))) := λ: <>,
        (if: #true
        then break: #()
        else do:  #());;;
        continue: #()));;;
      let: "$r0" := ((![go.uint64] "i") = #(W64 9)) in
      do:  ("ok" <-[go.bool] "$r0")));;;
    return: (![go.bool] "ok")).

Definition IterateMapKeys : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.IterateMapKeys"%go.

(* go: maps.go:3:6 *)
Definition IterateMapKeysⁱᵐᵖˡ : val :=
  λ: "m",
    exception_do (let: "m" := (GoAllocValue (go.MapType go.uint64 go.uint64) "m") in
    let: "sum" := (GoAlloc go.uint64 #()) in
    let: "$range" := (![go.MapType go.uint64 go.uint64] "m") in
    (let: "k" := (GoAlloc go.uint64 #()) in
    map.for_range "$range" (λ: "$key" "value",
      do:  ("k" <-[go.uint64] "$key");;;
      let: "$r0" := ((![go.uint64] "sum") + (![go.uint64] "k")) in
      do:  ("sum" <-[go.uint64] "$r0")));;;
    return: (![go.uint64] "sum")).

Definition IterateMapValues : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.IterateMapValues"%go.

(* go: maps.go:11:6 *)
Definition IterateMapValuesⁱᵐᵖˡ : val :=
  λ: "m",
    exception_do (let: "m" := (GoAllocValue (go.MapType go.uint64 go.uint64) "m") in
    let: "sum" := (GoAlloc go.uint64 #()) in
    let: "$range" := (![go.MapType go.uint64 go.uint64] "m") in
    (let: "v" := (GoAlloc go.uint64 #()) in
    map.for_range "$range" (λ: "$key" "value",
      do:  ("v" <-[go.uint64] "$value");;;
      do:  "$key";;;
      let: "$r0" := ((![go.uint64] "sum") + (![go.uint64] "v")) in
      do:  ("sum" <-[go.uint64] "$r0")));;;
    return: (![go.uint64] "sum")).

Definition testIterateMap : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testIterateMap"%go.

(* go: maps.go:19:6 *)
Definition testIterateMapⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok" := (GoAlloc go.bool #()) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "m" := (GoAlloc (go.MapType go.uint64 go.uint64) #()) in
    let: "$r0" := (map.make go.uint64 go.uint64) in
    do:  ("m" <-[go.MapType go.uint64 go.uint64] "$r0");;;
    let: "$r0" := #(W64 1) in
    do:  (map.insert (![go.MapType go.uint64 go.uint64] "m") #(W64 0) "$r0");;;
    let: "$r0" := #(W64 2) in
    do:  (map.insert (![go.MapType go.uint64 go.uint64] "m") #(W64 1) "$r0");;;
    let: "$r0" := #(W64 4) in
    do:  (map.insert (![go.MapType go.uint64 go.uint64] "m") #(W64 3) "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := (![go.MapType go.uint64 go.uint64] "m") in
    (FuncResolve IterateMapKeys #()) "$a0") = #(W64 4))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := (![go.MapType go.uint64 go.uint64] "m") in
    (FuncResolve IterateMapValues #()) "$a0") = #(W64 7))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    return: (![go.bool] "ok")).

Definition testMapSize : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testMapSize"%go.

(* go: maps.go:37:6 *)
Definition testMapSizeⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok" := (GoAlloc go.bool #()) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "m" := (GoAlloc (go.MapType go.uint64 go.uint64) #()) in
    let: "$r0" := (map.make go.uint64 go.uint64) in
    do:  ("m" <-[go.MapType go.uint64 go.uint64] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((s_to_w64 (let: "$a0" := (![go.MapType go.uint64 go.uint64] "m") in
    map.len "$a0")) = #(W64 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := #(W64 1) in
    do:  (map.insert (![go.MapType go.uint64 go.uint64] "m") #(W64 0) "$r0");;;
    let: "$r0" := #(W64 2) in
    do:  (map.insert (![go.MapType go.uint64 go.uint64] "m") #(W64 1) "$r0");;;
    let: "$r0" := #(W64 4) in
    do:  (map.insert (![go.MapType go.uint64 go.uint64] "m") #(W64 3) "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((s_to_w64 (let: "$a0" := (![go.MapType go.uint64 go.uint64] "m") in
    map.len "$a0")) = #(W64 3))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    return: (![go.bool] "ok")).

Definition multReturnTwo : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.multReturnTwo"%go.

(* go: multiple_assign.go:3:6 *)
Definition multReturnTwoⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (#(W64 2), #(W64 3))).

Definition testAssignTwo : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testAssignTwo"%go.

(* go: multiple_assign.go:7:6 *)
Definition testAssignTwoⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.uint64 #()) in
    let: "$r0" := #(W64 10) in
    do:  ("x" <-[go.uint64] "$r0");;;
    let: "y" := (GoAlloc go.uint64 #()) in
    let: "$r0" := #(W64 15) in
    do:  ("y" <-[go.uint64] "$r0");;;
    let: ("$ret0", "$ret1") := ((FuncResolve multReturnTwo #()) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("x" <-[go.uint64] "$r0");;;
    do:  ("y" <-[go.uint64] "$r1");;;
    return: (((![go.uint64] "x") = #(W64 2)) && ((![go.uint64] "y") = #(W64 3)))).

Definition multReturnThree : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.multReturnThree"%go.

(* go: multiple_assign.go:14:6 *)
Definition multReturnThreeⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (#(W64 2), #true, #(W32 1))).

Definition testAssignThree : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testAssignThree"%go.

(* go: multiple_assign.go:18:6 *)
Definition testAssignThreeⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.uint64 #()) in
    let: "$r0" := #(W64 10) in
    do:  ("x" <-[go.uint64] "$r0");;;
    let: "y" := (GoAlloc go.bool #()) in
    let: "$r0" := #false in
    do:  ("y" <-[go.bool] "$r0");;;
    let: "z" := (GoAlloc go.uint32 #()) in
    let: "$r0" := #(W32 15) in
    do:  ("z" <-[go.uint32] "$r0");;;
    let: (("$ret0", "$ret1"), "$ret2") := ((FuncResolve multReturnThree #()) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("x" <-[go.uint64] "$r0");;;
    do:  ("y" <-[go.bool] "$r1");;;
    do:  ("z" <-[go.uint32] "$r2");;;
    return: ((((![go.uint64] "x") = #(W64 2)) && ((![go.bool] "y") = #true)) && ((![go.uint32] "z") = #(W32 1)))).

Definition testMultipleAssignToMap : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testMultipleAssignToMap"%go.

(* go: multiple_assign.go:26:6 *)
Definition testMultipleAssignToMapⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.uint64 #()) in
    let: "$r0" := #(W64 10) in
    do:  ("x" <-[go.uint64] "$r0");;;
    let: "m" := (GoAlloc (go.MapType go.uint64 go.uint64) #()) in
    let: "$r0" := (map.make go.uint64 go.uint64) in
    do:  ("m" <-[go.MapType go.uint64 go.uint64] "$r0");;;
    let: ("$ret0", "$ret1") := ((FuncResolve multReturnTwo #()) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("x" <-[go.uint64] "$r0");;;
    do:  (map.insert (![go.MapType go.uint64 go.uint64] "m") #(W64 0) "$r1");;;
    return: (((![go.uint64] "x") = #(W64 2)) && ((Fst (map.get (![go.MapType go.uint64 go.uint64] "m") #(W64 0))) = #(W64 3)))).

Definition returnTwo : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.returnTwo"%go.

(* go: multiple_return.go:3:6 *)
Definition returnTwoⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (#(W64 2), #(W64 3))).

Definition testReturnTwo : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testReturnTwo"%go.

(* go: multiple_return.go:7:6 *)
Definition testReturnTwoⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "y" := (GoAlloc go.uint64 #()) in
    let: "x" := (GoAlloc go.uint64 #()) in
    let: ("$ret0", "$ret1") := ((FuncResolve returnTwo #()) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("x" <-[go.uint64] "$r0");;;
    do:  ("y" <-[go.uint64] "$r1");;;
    return: (((![go.uint64] "x") = #(W64 2)) && ((![go.uint64] "y") = #(W64 3)))).

Definition testAnonymousBinding : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testAnonymousBinding"%go.

(* go: multiple_return.go:12:6 *)
Definition testAnonymousBindingⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "y" := (GoAlloc go.uint64 #()) in
    let: ("$ret0", "$ret1") := ((FuncResolve returnTwo #()) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  "$r0";;;
    do:  ("y" <-[go.uint64] "$r1");;;
    return: ((![go.uint64] "y") = #(W64 3))).

Definition returnThree : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.returnThree"%go.

(* go: multiple_return.go:17:6 *)
Definition returnThreeⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (#(W64 2), #true, #(W32 1))).

Definition testReturnThree : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testReturnThree"%go.

(* go: multiple_return.go:21:6 *)
Definition testReturnThreeⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "z" := (GoAlloc go.uint32 #()) in
    let: "y" := (GoAlloc go.bool #()) in
    let: "x" := (GoAlloc go.uint64 #()) in
    let: (("$ret0", "$ret1"), "$ret2") := ((FuncResolve returnThree #()) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("x" <-[go.uint64] "$r0");;;
    do:  ("y" <-[go.bool] "$r1");;;
    do:  ("z" <-[go.uint32] "$r2");;;
    return: ((((![go.uint64] "x") = #(W64 2)) && ((![go.bool] "y") = #true)) && ((![go.uint32] "z") = #(W32 1)))).

Definition returnFour : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.returnFour"%go.

(* go: multiple_return.go:26:6 *)
Definition returnFourⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (#(W64 2), #true, #(W32 1), #(W64 7))).

Definition testReturnFour : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testReturnFour"%go.

(* go: multiple_return.go:30:6 *)
Definition testReturnFourⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "w" := (GoAlloc go.uint64 #()) in
    let: "z" := (GoAlloc go.uint32 #()) in
    let: "y" := (GoAlloc go.bool #()) in
    let: "x" := (GoAlloc go.uint64 #()) in
    let: ((("$ret0", "$ret1"), "$ret2"), "$ret3") := ((FuncResolve returnFour #()) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    let: "$r3" := "$ret3" in
    do:  ("x" <-[go.uint64] "$r0");;;
    do:  ("y" <-[go.bool] "$r1");;;
    do:  ("z" <-[go.uint32] "$r2");;;
    do:  ("w" <-[go.uint64] "$r3");;;
    return: (((((![go.uint64] "x") = #(W64 2)) && ((![go.bool] "y") = #true)) && ((![go.uint32] "z") = #(W32 1))) && ((![go.uint64] "w") = #(W64 7)))).

Definition failing_testCompareSliceToNil : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.failing_testCompareSliceToNil"%go.

(* go: nil.go:3:6 *)
Definition failing_testCompareSliceToNilⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "s" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := (slice.make2 go.byte #(W64 0)) in
    do:  ("s" <-[go.SliceType go.byte] "$r0");;;
    return: ((![go.SliceType go.byte] "s") ≠ #slice.nil)).

Definition testComparePointerToNil : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testComparePointerToNil"%go.

(* go: nil.go:8:6 *)
Definition testComparePointerToNilⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "s" := (GoAlloc (go.PointerType go.uint64) #()) in
    let: "$r0" := (GoAlloc go.uint64 #()) in
    do:  ("s" <-[go.PointerType go.uint64] "$r0");;;
    return: ((![go.PointerType go.uint64] "s") ≠ #null)).

Definition testCompareNilToNil : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testCompareNilToNil"%go.

(* go: nil.go:13:6 *)
Definition testCompareNilToNilⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "s" := (GoAlloc (go.PointerType (go.PointerType go.uint64)) #()) in
    let: "$r0" := (GoAlloc (go.PointerType go.uint64) #()) in
    do:  ("s" <-[go.PointerType (go.PointerType go.uint64)] "$r0");;;
    return: ((![go.PointerType go.uint64] (![go.PointerType (go.PointerType go.uint64)] "s")) = #null)).

Definition testComparePointerWrappedToNil : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testComparePointerWrappedToNil"%go.

(* go: nil.go:18:6 *)
Definition testComparePointerWrappedToNilⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "s" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := (slice.make2 go.byte #(W64 1)) in
    do:  ("s" <-[go.SliceType go.byte] "$r0");;;
    return: ((![go.SliceType go.byte] "s") ≠ #slice.nil)).

Definition testComparePointerWrappedDefaultToNil : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testComparePointerWrappedDefaultToNil"%go.

(* go: nil.go:24:6 *)
Definition testComparePointerWrappedDefaultToNilⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "s" := (GoAlloc (go.SliceType go.byte) #()) in
    return: ((![go.SliceType go.byte] "s") = #slice.nil)).

Definition reverseAssignOps64 : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.reverseAssignOps64"%go.

(* helpers

   go: operations.go:4:6 *)
Definition reverseAssignOps64ⁱᵐᵖˡ : val :=
  λ: "x",
    exception_do (let: "x" := (GoAllocValue go.uint64 "x") in
    let: "y" := (GoAlloc go.uint64 #()) in
    do:  ("y" <-[go.uint64] ((![go.uint64] "y") + (![go.uint64] "x")));;;
    do:  ("y" <-[go.uint64] ((![go.uint64] "y") - (![go.uint64] "x")));;;
    do:  ("y" <-[go.uint64] ((![go.uint64] "y") + #(W64 1)));;;
    do:  ("y" <-[go.uint64] ((![go.uint64] "y") - #(W64 1)));;;
    return: (![go.uint64] "y")).

Definition reverseAssignOps32 : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.reverseAssignOps32"%go.

(* go: operations.go:13:6 *)
Definition reverseAssignOps32ⁱᵐᵖˡ : val :=
  λ: "x",
    exception_do (let: "x" := (GoAllocValue go.uint32 "x") in
    let: "y" := (GoAlloc go.uint32 #()) in
    do:  ("y" <-[go.uint32] ((![go.uint32] "y") + (![go.uint32] "x")));;;
    do:  ("y" <-[go.uint32] ((![go.uint32] "y") - (![go.uint32] "x")));;;
    do:  ("y" <-[go.uint32] ((![go.uint32] "y") + #(W32 1)));;;
    do:  ("y" <-[go.uint32] ((![go.uint32] "y") - #(W32 1)));;;
    return: (![go.uint32] "y")).

Definition add64Equals : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.add64Equals"%go.

(* go: operations.go:22:6 *)
Definition add64Equalsⁱᵐᵖˡ : val :=
  λ: "x" "y" "z",
    exception_do (let: "z" := (GoAllocValue go.uint64 "z") in
    let: "y" := (GoAllocValue go.uint64 "y") in
    let: "x" := (GoAllocValue go.uint64 "x") in
    return: (((![go.uint64] "x") + (![go.uint64] "y")) = (![go.uint64] "z"))).

Definition sub64Equals : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.sub64Equals"%go.

(* go: operations.go:26:6 *)
Definition sub64Equalsⁱᵐᵖˡ : val :=
  λ: "x" "y" "z",
    exception_do (let: "z" := (GoAllocValue go.uint64 "z") in
    let: "y" := (GoAllocValue go.uint64 "y") in
    let: "x" := (GoAllocValue go.uint64 "x") in
    return: (((![go.uint64] "x") - (![go.uint64] "y")) = (![go.uint64] "z"))).

Definition testReverseAssignOps64 : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testReverseAssignOps64"%go.

(* tests

   go: operations.go:31:6 *)
Definition testReverseAssignOps64ⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok" := (GoAlloc go.bool #()) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W64 0) in
    (FuncResolve reverseAssignOps64 #()) "$a0") = #(W64 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W64 1) in
    (FuncResolve reverseAssignOps64 #()) "$a0") = #(W64 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W64 1231234) in
    (FuncResolve reverseAssignOps64 #()) "$a0") = #(W64 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W64 62206846038638762) in
    (FuncResolve reverseAssignOps64 #()) "$a0") = #(W64 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W64 9223372036854775808) in
    (FuncResolve reverseAssignOps64 #()) "$a0") = #(W64 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W64 140737488355328) in
    (FuncResolve reverseAssignOps64 #()) "$a0") = #(W64 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W64 1048576) in
    (FuncResolve reverseAssignOps64 #()) "$a0") = #(W64 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W64 262144) in
    (FuncResolve reverseAssignOps64 #()) "$a0") = #(W64 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W64 1024) in
    (FuncResolve reverseAssignOps64 #()) "$a0") = #(W64 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W64 1) in
    (FuncResolve reverseAssignOps64 #()) "$a0") = #(W64 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W64 (18446744073709551616 - 1)) in
    (FuncResolve reverseAssignOps64 #()) "$a0") = #(W64 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    return: (![go.bool] "ok")).

Definition failing_testReverseAssignOps32 : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.failing_testReverseAssignOps32"%go.

(* go: operations.go:47:6 *)
Definition failing_testReverseAssignOps32ⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok" := (GoAlloc go.bool #()) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W32 0) in
    (FuncResolve reverseAssignOps32 #()) "$a0") = #(W32 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W32 1) in
    (FuncResolve reverseAssignOps32 #()) "$a0") = #(W32 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W32 1231234) in
    (FuncResolve reverseAssignOps32 #()) "$a0") = #(W32 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W32 3434807466) in
    (FuncResolve reverseAssignOps32 #()) "$a0") = #(W32 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W32 1048576) in
    (FuncResolve reverseAssignOps32 #()) "$a0") = #(W32 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W32 262144) in
    (FuncResolve reverseAssignOps32 #()) "$a0") = #(W32 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W32 1024) in
    (FuncResolve reverseAssignOps32 #()) "$a0") = #(W32 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W32 1) in
    (FuncResolve reverseAssignOps32 #()) "$a0") = #(W32 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := #(W32 (4294967296 - 1)) in
    (FuncResolve reverseAssignOps32 #()) "$a0") = #(W32 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    return: (![go.bool] "ok")).

Definition testAdd64Equals : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testAdd64Equals"%go.

(* go: operations.go:61:6 *)
Definition testAdd64Equalsⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok" := (GoAlloc go.bool #()) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && (let: "$a0" := #(W64 2) in
    let: "$a1" := #(W64 3) in
    let: "$a2" := #(W64 5) in
    (FuncResolve add64Equals #()) "$a0" "$a1" "$a2")) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && (let: "$a0" := #(W64 (18446744073709551616 - 1)) in
    let: "$a1" := #(W64 1) in
    let: "$a2" := #(W64 0) in
    (FuncResolve add64Equals #()) "$a0" "$a1" "$a2")) in
    do:  ("ok" <-[go.bool] "$r0");;;
    return: (![go.bool] "ok")).

Definition testSub64Equals : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testSub64Equals"%go.

(* go: operations.go:68:6 *)
Definition testSub64Equalsⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok" := (GoAlloc go.bool #()) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && (let: "$a0" := #(W64 2) in
    let: "$a1" := #(W64 1) in
    let: "$a2" := #(W64 1) in
    (FuncResolve sub64Equals #()) "$a0" "$a1" "$a2")) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && (let: "$a0" := #(W64 (18446744073709551616 - 1)) in
    let: "$a1" := #(W64 9223372036854775808) in
    let: "$a2" := #(W64 (9223372036854775808 - 1)) in
    (FuncResolve sub64Equals #()) "$a0" "$a1" "$a2")) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && (let: "$a0" := #(W64 2) in
    let: "$a1" := #(W64 8) in
    let: "$a2" := #(W64 (18446744073709551616 - 6)) in
    (FuncResolve sub64Equals #()) "$a0" "$a1" "$a2")) in
    do:  ("ok" <-[go.bool] "$r0");;;
    return: (![go.bool] "ok")).

Definition testDivisionPrecedence : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testDivisionPrecedence"%go.

(* go: operations.go:76:6 *)
Definition testDivisionPrecedenceⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "blockSize" := (GoAlloc go.uint64 #()) in
    let: "$r0" := #(W64 4096) in
    do:  ("blockSize" <-[go.uint64] "$r0");;;
    let: "hdrmeta" := (GoAlloc go.uint64 #()) in
    let: "$r0" := #(W64 8) in
    do:  ("hdrmeta" <-[go.uint64] "$r0");;;
    let: "hdraddrs" := (GoAlloc go.uint64 #()) in
    let: "$r0" := (((![go.uint64] "blockSize") - (![go.uint64] "hdrmeta")) `quot` #(W64 8)) in
    do:  ("hdraddrs" <-[go.uint64] "$r0");;;
    return: ((![go.uint64] "hdraddrs") = #(W64 511))).

Definition testModPrecedence : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testModPrecedence"%go.

(* go: operations.go:83:6 *)
Definition testModPrecedenceⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x1" := (GoAlloc go.int #()) in
    let: "$r0" := #(W64 (513 + (12 `rem` 8))) in
    do:  ("x1" <-[go.int] "$r0");;;
    let: "x2" := (GoAlloc go.int #()) in
    let: "$r0" := #(W64 ((513 + 12) `rem` 8)) in
    do:  ("x2" <-[go.int] "$r0");;;
    return: (((![go.int] "x1") = #(W64 517)) && ((![go.int] "x2") = #(W64 5)))).

Definition testBitwiseOpsPrecedence : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testBitwiseOpsPrecedence"%go.

(* go: operations.go:89:6 *)
Definition testBitwiseOpsPrecedenceⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok" := (GoAlloc go.bool #()) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && #(479 =? 479)) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && #(132 =? 132)) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && #(828 =? 828)) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && #(893 =? 893)) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && #(461 =? 461)) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && #(negb (479 =? 389))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    return: (![go.bool] "ok")).

Definition testArithmeticShifts : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testArithmeticShifts"%go.

(* go: operations.go:102:6 *)
Definition testArithmeticShiftsⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok" := (GoAlloc go.bool #()) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && #(5376 =? 5376)) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && #(1513209474796486656 =? 1513209474796486656)) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && #(42 =? 42)) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && #(0 =? 0)) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && #(672 =? 672)) in
    do:  ("ok" <-[go.bool] "$r0");;;
    return: (![go.bool] "ok")).

Definition testBitAddAnd : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testBitAddAnd"%go.

(* go: operations.go:114:6 *)
Definition testBitAddAndⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "tid" := (GoAlloc go.uint64 #()) in
    let: "$r0" := #(W64 17) in
    do:  ("tid" <-[go.uint64] "$r0");;;
    let: "n" := (GoAlloc go.uint64 #()) in
    let: "$r0" := #(W64 16) in
    do:  ("n" <-[go.uint64] "$r0");;;
    return: ((((![go.uint64] "tid") + (![go.uint64] "n")) `and` (~ ((![go.uint64] "n") - #(W64 1)))) = #(W64 32))).

Definition testManyParentheses : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testManyParentheses"%go.

(* go: operations.go:120:6 *)
Definition testManyParenthesesⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (#((3 * 6) =? (3 * 6)))).

Definition testPlusTimes : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testPlusTimes"%go.

(* go: operations.go:124:6 *)
Definition testPlusTimesⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (#(((2 + 5) * 2) =? 14))).

Definition testOrCompareSimple : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testOrCompareSimple"%go.

(* go: precedence.go:3:6 *)
Definition testOrCompareSimpleⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do ((if: #(3 >? 4) || #(4 >? 3)
    then return: (#true)
    else do:  #());;;
    return: (#false)).

Definition testOrCompare : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testOrCompare"%go.

(* go: precedence.go:10:6 *)
Definition testOrCompareⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok" := (GoAlloc go.bool #()) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    (if: (~ (#(3 >? 4) || #(4 >? 3)))
    then
      let: "$r0" := #false in
      do:  ("ok" <-[go.bool] "$r0")
    else do:  #());;;
    (if: #(4 <? 3) || #(2 >? 3)
    then
      let: "$r0" := #false in
      do:  ("ok" <-[go.bool] "$r0")
    else do:  #());;;
    return: (![go.bool] "ok")).

Definition testAndCompare : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testAndCompare"%go.

(* go: precedence.go:22:6 *)
Definition testAndCompareⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok" := (GoAlloc go.bool #()) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    (if: #(3 >? 4) && #(4 >? 3)
    then
      let: "$r0" := #false in
      do:  ("ok" <-[go.bool] "$r0")
    else do:  #());;;
    (if: #(4 >? 3) || #(2 <? 3)
    then do:  #()
    else
      let: "$r0" := #false in
      do:  ("ok" <-[go.bool] "$r0"));;;
    return: (![go.bool] "ok")).

Definition testShiftMod : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testShiftMod"%go.

(* go: precedence.go:34:6 *)
Definition testShiftModⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (#(20 =? 20))).

Definition testLinearize : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testLinearize"%go.

(* go: prims.go:9:6 *)
Definition testLinearizeⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "m" := (GoAlloc (go.PointerType sync.Mutex) #()) in
    let: "$r0" := (GoAlloc sync.Mutex #()) in
    do:  ("m" <-[go.PointerType sync.Mutex] "$r0");;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) Lock #() (![go.PointerType sync.Mutex] "m")) #());;;
    do:  ((FuncResolve primitive.Linearize #()) #());;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) Unlock #() (![go.PointerType sync.Mutex] "m")) #());;;
    return: (#true)).

Definition BoolTestⁱᵐᵖˡ  : go.type := go.StructType [
  (go.FieldDecl "t"%go go.bool);
  (go.FieldDecl "f"%go go.bool);
  (go.FieldDecl "tc"%go go.uint64);
  (go.FieldDecl "fc"%go go.uint64)
].

Definition CheckTrue : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.CheckTrue"%go.

(* go: shortcircuiting.go:11:6 *)
Definition CheckTrueⁱᵐᵖˡ : val :=
  λ: "b",
    exception_do (let: "b" := (GoAllocValue (go.PointerType BoolTest) "b") in
    do:  ((struct.field_ref BoolTest #"tc"%go (![go.PointerType BoolTest] "b")) <-[go.uint64] ((![go.uint64] (struct.field_ref BoolTest #"tc"%go (![go.PointerType BoolTest] "b"))) + #(W64 1)));;;
    return: (![go.bool] (struct.field_ref BoolTest #"t"%go (![go.PointerType BoolTest] "b")))).

Definition CheckFalse : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.CheckFalse"%go.

(* go: shortcircuiting.go:16:6 *)
Definition CheckFalseⁱᵐᵖˡ : val :=
  λ: "b",
    exception_do (let: "b" := (GoAllocValue (go.PointerType BoolTest) "b") in
    do:  ((struct.field_ref BoolTest #"fc"%go (![go.PointerType BoolTest] "b")) <-[go.uint64] ((![go.uint64] (struct.field_ref BoolTest #"fc"%go (![go.PointerType BoolTest] "b"))) + #(W64 1)));;;
    return: (![go.bool] (struct.field_ref BoolTest #"f"%go (![go.PointerType BoolTest] "b")))).

Definition testShortcircuitAndTF : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testShortcircuitAndTF"%go.

(* tests

   go: shortcircuiting.go:22:6 *)
Definition testShortcircuitAndTFⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "b" := (GoAlloc (go.PointerType BoolTest) #()) in
    let: "$r0" := (GoAllocValue BoolTest (let: "$t" := #true in
    let: "$f" := #false in
    let: "$tc" := #(W64 0) in
    let: "$fc" := #(W64 0) in
    struct.make BoolTest [{
      "t" ::= "$t";
      "f" ::= "$f";
      "tc" ::= "$tc";
      "fc" ::= "$fc"
    }])) in
    do:  ("b" <-[go.PointerType BoolTest] "$r0");;;
    (if: (let: "$a0" := (![go.PointerType BoolTest] "b") in
    (FuncResolve CheckTrue #()) "$a0") && (let: "$a0" := (![go.PointerType BoolTest] "b") in
    (FuncResolve CheckFalse #()) "$a0")
    then return: (#false)
    else do:  #());;;
    return: (((![go.uint64] (struct.field_ref BoolTest #"tc"%go (![go.PointerType BoolTest] "b"))) = #(W64 1)) && ((![go.uint64] (struct.field_ref BoolTest #"fc"%go (![go.PointerType BoolTest] "b"))) = #(W64 1)))).

Definition testShortcircuitAndFT : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testShortcircuitAndFT"%go.

(* go: shortcircuiting.go:31:6 *)
Definition testShortcircuitAndFTⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "b" := (GoAlloc (go.PointerType BoolTest) #()) in
    let: "$r0" := (GoAllocValue BoolTest (let: "$t" := #true in
    let: "$f" := #false in
    let: "$tc" := #(W64 0) in
    let: "$fc" := #(W64 0) in
    struct.make BoolTest [{
      "t" ::= "$t";
      "f" ::= "$f";
      "tc" ::= "$tc";
      "fc" ::= "$fc"
    }])) in
    do:  ("b" <-[go.PointerType BoolTest] "$r0");;;
    (if: (let: "$a0" := (![go.PointerType BoolTest] "b") in
    (FuncResolve CheckFalse #()) "$a0") && (let: "$a0" := (![go.PointerType BoolTest] "b") in
    (FuncResolve CheckTrue #()) "$a0")
    then return: (#false)
    else do:  #());;;
    return: (((![go.uint64] (struct.field_ref BoolTest #"tc"%go (![go.PointerType BoolTest] "b"))) = #(W64 0)) && ((![go.uint64] (struct.field_ref BoolTest #"fc"%go (![go.PointerType BoolTest] "b"))) = #(W64 1)))).

Definition testShortcircuitOrTF : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testShortcircuitOrTF"%go.

(* go: shortcircuiting.go:40:6 *)
Definition testShortcircuitOrTFⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "b" := (GoAlloc (go.PointerType BoolTest) #()) in
    let: "$r0" := (GoAllocValue BoolTest (let: "$t" := #true in
    let: "$f" := #false in
    let: "$tc" := #(W64 0) in
    let: "$fc" := #(W64 0) in
    struct.make BoolTest [{
      "t" ::= "$t";
      "f" ::= "$f";
      "tc" ::= "$tc";
      "fc" ::= "$fc"
    }])) in
    do:  ("b" <-[go.PointerType BoolTest] "$r0");;;
    (if: (let: "$a0" := (![go.PointerType BoolTest] "b") in
    (FuncResolve CheckTrue #()) "$a0") || (let: "$a0" := (![go.PointerType BoolTest] "b") in
    (FuncResolve CheckFalse #()) "$a0")
    then return: (((![go.uint64] (struct.field_ref BoolTest #"tc"%go (![go.PointerType BoolTest] "b"))) = #(W64 1)) && ((![go.uint64] (struct.field_ref BoolTest #"fc"%go (![go.PointerType BoolTest] "b"))) = #(W64 0)))
    else do:  #());;;
    return: (#false)).

Definition testShortcircuitOrFT : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testShortcircuitOrFT"%go.

(* go: shortcircuiting.go:48:6 *)
Definition testShortcircuitOrFTⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "b" := (GoAlloc (go.PointerType BoolTest) #()) in
    let: "$r0" := (GoAllocValue BoolTest (let: "$t" := #true in
    let: "$f" := #false in
    let: "$tc" := #(W64 0) in
    let: "$fc" := #(W64 0) in
    struct.make BoolTest [{
      "t" ::= "$t";
      "f" ::= "$f";
      "tc" ::= "$tc";
      "fc" ::= "$fc"
    }])) in
    do:  ("b" <-[go.PointerType BoolTest] "$r0");;;
    (if: (let: "$a0" := (![go.PointerType BoolTest] "b") in
    (FuncResolve CheckFalse #()) "$a0") || (let: "$a0" := (![go.PointerType BoolTest] "b") in
    (FuncResolve CheckTrue #()) "$a0")
    then return: (((![go.uint64] (struct.field_ref BoolTest #"tc"%go (![go.PointerType BoolTest] "b"))) = #(W64 1)) && ((![go.uint64] (struct.field_ref BoolTest #"fc"%go (![go.PointerType BoolTest] "b"))) = #(W64 1)))
    else do:  #());;;
    return: (#false)).

Definition ArrayEditorⁱᵐᵖˡ  : go.type := go.StructType [
  (go.FieldDecl "s"%go go.SliceType go.uint64);
  (go.FieldDecl "next_val"%go go.uint64)
].

(* go: slices.go:9:24 *)
Definition ArrayEditor__Advanceⁱᵐᵖˡ : val :=
  λ: "ae" "arr" "next",
    exception_do (let: "ae" := (GoAllocValue (go.PointerType ArrayEditor) "ae") in
    let: "next" := (GoAllocValue go.uint64 "next") in
    let: "arr" := (GoAllocValue (go.SliceType go.uint64) "arr") in
    do:  ((slice.elem_ref go.uint64 (![go.SliceType go.uint64] "arr") #(W64 0)) <-[go.uint64] ((![go.uint64] (slice.elem_ref go.uint64 (![go.SliceType go.uint64] "arr") #(W64 0))) + #(W64 1)));;;
    let: "$r0" := (![go.uint64] (struct.field_ref ArrayEditor #"next_val"%go (![go.PointerType ArrayEditor] "ae"))) in
    do:  ((slice.elem_ref go.uint64 (![go.SliceType go.uint64] (struct.field_ref ArrayEditor #"s"%go (![go.PointerType ArrayEditor] "ae"))) #(W64 0)) <-[go.uint64] "$r0");;;
    let: "$r0" := (![go.uint64] "next") in
    do:  ((struct.field_ref ArrayEditor #"next_val"%go (![go.PointerType ArrayEditor] "ae")) <-[go.uint64] "$r0");;;
    let: "$r0" := (let: "$s" := (![go.SliceType go.uint64] (struct.field_ref ArrayEditor #"s"%go (![go.PointerType ArrayEditor] "ae"))) in
    slice.slice go.uint64 "$s" #(W64 1) (slice.len "$s")) in
    do:  ((struct.field_ref ArrayEditor #"s"%go (![go.PointerType ArrayEditor] "ae")) <-[go.SliceType go.uint64] "$r0");;;
    return: #()).

Definition testSliceOps : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testSliceOps"%go.

(* tests

   go: slices.go:17:6 *)
Definition testSliceOpsⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc (go.SliceType go.uint64) #()) in
    let: "$r0" := (slice.make2 go.uint64 #(W64 10)) in
    do:  ("x" <-[go.SliceType go.uint64] "$r0");;;
    let: "$r0" := #(W64 5) in
    do:  ((slice.elem_ref go.uint64 (![go.SliceType go.uint64] "x") #(W64 1)) <-[go.uint64] "$r0");;;
    let: "$r0" := #(W64 10) in
    do:  ((slice.elem_ref go.uint64 (![go.SliceType go.uint64] "x") #(W64 2)) <-[go.uint64] "$r0");;;
    let: "$r0" := #(W64 15) in
    do:  ((slice.elem_ref go.uint64 (![go.SliceType go.uint64] "x") #(W64 3)) <-[go.uint64] "$r0");;;
    let: "$r0" := #(W64 20) in
    do:  ((slice.elem_ref go.uint64 (![go.SliceType go.uint64] "x") #(W64 4)) <-[go.uint64] "$r0");;;
    let: "v1" := (GoAlloc go.uint64 #()) in
    let: "$r0" := (![go.uint64] (slice.elem_ref go.uint64 (![go.SliceType go.uint64] "x") #(W64 2))) in
    do:  ("v1" <-[go.uint64] "$r0");;;
    let: "v2" := (GoAlloc (go.SliceType go.uint64) #()) in
    let: "$r0" := (let: "$s" := (![go.SliceType go.uint64] "x") in
    slice.slice go.uint64 "$s" #(W64 2) #(W64 3)) in
    do:  ("v2" <-[go.SliceType go.uint64] "$r0");;;
    let: "v3" := (GoAlloc (go.SliceType go.uint64) #()) in
    let: "$r0" := (let: "$s" := (![go.SliceType go.uint64] "x") in
    slice.slice go.uint64 "$s" #(W64 0) #(W64 3)) in
    do:  ("v3" <-[go.SliceType go.uint64] "$r0");;;
    let: "v4" := (GoAlloc (go.PointerType go.uint64) #()) in
    let: "$r0" := (slice.elem_ref go.uint64 (![go.SliceType go.uint64] "x") #(W64 2)) in
    do:  ("v4" <-[go.PointerType go.uint64] "$r0");;;
    let: "ok" := (GoAlloc go.bool #()) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] "v1") = #(W64 10))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] (slice.elem_ref go.uint64 (![go.SliceType go.uint64] "v2") #(W64 0))) = #(W64 10))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := (![go.SliceType go.uint64] "v2") in
    slice.len "$a0") = #(W64 1))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] (slice.elem_ref go.uint64 (![go.SliceType go.uint64] "v3") #(W64 1))) = #(W64 5))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] (slice.elem_ref go.uint64 (![go.SliceType go.uint64] "v3") #(W64 2))) = #(W64 10))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := (![go.SliceType go.uint64] "v3") in
    slice.len "$a0") = #(W64 3))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] (![go.PointerType go.uint64] "v4")) = #(W64 10))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    return: (![go.bool] "ok")).

Definition testSliceCapacityOps : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testSliceCapacityOps"%go.

(* go: slices.go:40:6 *)
Definition testSliceCapacityOpsⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc (go.SliceType go.uint64) #()) in
    let: "$r0" := (slice.make3 go.uint64 #(W64 0) #(W64 10)) in
    do:  ("x" <-[go.SliceType go.uint64] "$r0");;;
    let: "sub1" := (GoAlloc (go.SliceType go.uint64) #()) in
    let: "$r0" := (let: "$s" := (![go.SliceType go.uint64] "x") in
    slice.slice go.uint64 "$s" #(W64 0) #(W64 6)) in
    do:  ("sub1" <-[go.SliceType go.uint64] "$r0");;;
    let: "$r0" := #(W64 1) in
    do:  ((slice.elem_ref go.uint64 (![go.SliceType go.uint64] "sub1") #(W64 0)) <-[go.uint64] "$r0");;;
    let: "sub2" := (GoAlloc (go.SliceType go.uint64) #()) in
    let: "$r0" := (let: "$s" := (![go.SliceType go.uint64] "x") in
    slice.slice go.uint64 "$s" #(W64 2) #(W64 4)) in
    do:  ("sub2" <-[go.SliceType go.uint64] "$r0");;;
    let: "$r0" := #(W64 2) in
    do:  ((slice.elem_ref go.uint64 (![go.SliceType go.uint64] "sub2") #(W64 0)) <-[go.uint64] "$r0");;;
    let: "ok" := (GoAlloc go.bool #()) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := (![go.SliceType go.uint64] "sub1") in
    slice.len "$a0") = #(W64 6))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := (![go.SliceType go.uint64] "sub1") in
    slice.cap "$a0") = #(W64 10))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] (slice.elem_ref go.uint64 (let: "$s" := (![go.SliceType go.uint64] "x") in
    slice.slice go.uint64 "$s" #(W64 0) #(W64 10)) #(W64 0))) = #(W64 1))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := (![go.SliceType go.uint64] "sub2") in
    slice.len "$a0") = #(W64 2))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := (![go.SliceType go.uint64] "sub2") in
    slice.cap "$a0") = #(W64 8))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] (slice.elem_ref go.uint64 (let: "$s" := (![go.SliceType go.uint64] "x") in
    slice.slice go.uint64 "$s" #(W64 0) #(W64 10)) #(W64 2))) = #(W64 2))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    return: (![go.bool] "ok")).

Definition testOverwriteArray : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testOverwriteArray"%go.

(* go: slices.go:59:6 *)
Definition testOverwriteArrayⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "arr" := (GoAlloc (go.SliceType go.uint64) #()) in
    let: "$r0" := (slice.make2 go.uint64 #(W64 4)) in
    do:  ("arr" <-[go.SliceType go.uint64] "$r0");;;
    let: "ae1" := (GoAlloc (go.PointerType ArrayEditor) #()) in
    let: "$r0" := (GoAllocValue ArrayEditor (let: "$s" := (let: "$s" := (![go.SliceType go.uint64] "arr") in
    slice.slice go.uint64 "$s" #(W64 0) (slice.len "$s")) in
    let: "$next_val" := #(W64 1) in
    struct.make ArrayEditor [{
      "s" ::= "$s";
      "next_val" ::= "$next_val"
    }])) in
    do:  ("ae1" <-[go.PointerType ArrayEditor] "$r0");;;
    let: "ae2" := (GoAlloc (go.PointerType ArrayEditor) #()) in
    let: "$r0" := (GoAllocValue ArrayEditor (let: "$s" := (let: "$s" := (![go.SliceType go.uint64] "arr") in
    slice.slice go.uint64 "$s" #(W64 1) (slice.len "$s")) in
    let: "$next_val" := #(W64 102) in
    struct.make ArrayEditor [{
      "s" ::= "$s";
      "next_val" ::= "$next_val"
    }])) in
    do:  ("ae2" <-[go.PointerType ArrayEditor] "$r0");;;
    do:  (let: "$a0" := (![go.SliceType go.uint64] "arr") in
    let: "$a1" := #(W64 103) in
    (MethodResolve (go.PointerType ArrayEditor) Advance #() (![go.PointerType ArrayEditor] "ae2")) "$a0" "$a1");;;
    do:  (let: "$a0" := (![go.SliceType go.uint64] "arr") in
    let: "$a1" := #(W64 104) in
    (MethodResolve (go.PointerType ArrayEditor) Advance #() (![go.PointerType ArrayEditor] "ae2")) "$a0" "$a1");;;
    do:  (let: "$a0" := (![go.SliceType go.uint64] "arr") in
    let: "$a1" := #(W64 105) in
    (MethodResolve (go.PointerType ArrayEditor) Advance #() (![go.PointerType ArrayEditor] "ae2")) "$a0" "$a1");;;
    do:  (let: "$a0" := (![go.SliceType go.uint64] "arr") in
    let: "$a1" := #(W64 2) in
    (MethodResolve (go.PointerType ArrayEditor) Advance #() (![go.PointerType ArrayEditor] "ae1")) "$a0" "$a1");;;
    do:  (let: "$a0" := (![go.SliceType go.uint64] "arr") in
    let: "$a1" := #(W64 3) in
    (MethodResolve (go.PointerType ArrayEditor) Advance #() (![go.PointerType ArrayEditor] "ae1")) "$a0" "$a1");;;
    do:  (let: "$a0" := (![go.SliceType go.uint64] "arr") in
    let: "$a1" := #(W64 4) in
    (MethodResolve (go.PointerType ArrayEditor) Advance #() (![go.PointerType ArrayEditor] "ae1")) "$a0" "$a1");;;
    do:  (let: "$a0" := (![go.SliceType go.uint64] "arr") in
    let: "$a1" := #(W64 5) in
    (MethodResolve (go.PointerType ArrayEditor) Advance #() (![go.PointerType ArrayEditor] "ae1")) "$a0" "$a1");;;
    (if: ((((![go.uint64] (slice.elem_ref go.uint64 (![go.SliceType go.uint64] "arr") #(W64 0))) + (![go.uint64] (slice.elem_ref go.uint64 (![go.SliceType go.uint64] "arr") #(W64 1)))) + (![go.uint64] (slice.elem_ref go.uint64 (![go.SliceType go.uint64] "arr") #(W64 2)))) + (![go.uint64] (slice.elem_ref go.uint64 (![go.SliceType go.uint64] "arr") #(W64 3)))) ≥ #(W64 100)
    then return: (#false)
    else do:  #());;;
    return: (((![go.uint64] (slice.elem_ref go.uint64 (![go.SliceType go.uint64] "arr") #(W64 3))) = #(W64 4)) && ((![go.uint64] (slice.elem_ref go.uint64 (![go.SliceType go.uint64] "arr") #(W64 0))) = #(W64 4)))).

Definition testSliceLiteral : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testSliceLiteral"%go.

(* go: slices.go:80:6 *)
Definition testSliceLiteralⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "bytes" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := ((let: "$sl0" := #(W8 1) in
    let: "$sl1" := #(W8 2) in
    slice.literal go.byte ["$sl0"; "$sl1"])) in
    do:  ("bytes" <-[go.SliceType go.byte] "$r0");;;
    let: "ok" := (GoAlloc go.bool #()) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.byte] (slice.elem_ref go.byte (![go.SliceType go.byte] "bytes") #(W64 0))) = #(W8 1))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "ints" := (GoAlloc (go.SliceType go.uint64) #()) in
    let: "$r0" := ((let: "$sl0" := #(W64 1) in
    let: "$sl1" := #(W64 2) in
    let: "$sl2" := #(W64 3) in
    slice.literal go.uint64 ["$sl0"; "$sl1"; "$sl2"])) in
    do:  ("ints" <-[go.SliceType go.uint64] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] (slice.elem_ref go.uint64 (![go.SliceType go.uint64] "ints") #(W64 1))) = #(W64 2))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    return: (![go.bool] "ok")).

Definition testSliceAppend : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testSliceAppend"%go.

(* go: slices.go:89:6 *)
Definition testSliceAppendⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok" := (GoAlloc go.bool #()) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "bytes" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := (slice.make2 go.byte #(W64 0)) in
    do:  ("bytes" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "bytes") in
    let: "$a1" := ((let: "$sl0" := #(W8 1) in
    slice.literal go.byte ["$sl0"])) in
    (slice.append go.byte) "$a0" "$a1") in
    do:  ("bytes" <-[go.SliceType go.byte] "$r0");;;
    let: "newBytes" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := ((let: "$sl0" := #(W8 2) in
    let: "$sl1" := #(W8 3) in
    slice.literal go.byte ["$sl0"; "$sl1"])) in
    do:  ("newBytes" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "bytes") in
    let: "$a1" := (![go.SliceType go.byte] "newBytes") in
    (slice.append go.byte) "$a0" "$a1") in
    do:  ("bytes" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((s_to_w64 (let: "$a0" := (![go.SliceType go.byte] "bytes") in
    slice.len "$a0")) = #(W64 3))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.byte] (slice.elem_ref go.byte (![go.SliceType go.byte] "bytes") #(W64 2))) = #(W8 3))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    return: (![go.bool] "ok")).

Definition Barⁱᵐᵖˡ  : go.type := go.StructType [
  (go.FieldDecl "a"%go go.uint64);
  (go.FieldDecl "b"%go go.uint64)
].

Definition Fooⁱᵐᵖˡ  : go.type := go.StructType [
  (go.FieldDecl "bar"%go Bar)
].

(* go: struct_pointers.go:14:17 *)
Definition Bar__mutateⁱᵐᵖˡ : val :=
  λ: "bar" <>,
    exception_do (let: "bar" := (GoAllocValue (go.PointerType Bar) "bar") in
    let: "$r0" := #(W64 2) in
    do:  ((struct.field_ref Bar #"a"%go (![go.PointerType Bar] "bar")) <-[go.uint64] "$r0");;;
    let: "$r0" := #(W64 3) in
    do:  ((struct.field_ref Bar #"b"%go (![go.PointerType Bar] "bar")) <-[go.uint64] "$r0");;;
    return: #()).

(* go: struct_pointers.go:19:17 *)
Definition Foo__mutateBarⁱᵐᵖˡ : val :=
  λ: "foo" <>,
    exception_do (let: "foo" := (GoAllocValue (go.PointerType Foo) "foo") in
    do:  ((MethodResolve (go.PointerType Bar) mutate #() (struct.field_ref Foo #"bar"%go (![go.PointerType Foo] "foo"))) #());;;
    return: #()).

Definition testFooBarMutation : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testFooBarMutation"%go.

(* go: struct_pointers.go:23:6 *)
Definition testFooBarMutationⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc Foo #()) in
    let: "$r0" := (let: "$bar" := (let: "$a" := #(W64 0) in
    let: "$b" := #(W64 0) in
    struct.make Bar [{
      "a" ::= "$a";
      "b" ::= "$b"
    }]) in
    struct.make Foo [{
      "bar" ::= "$bar"
    }]) in
    do:  ("x" <-[Foo] "$r0");;;
    do:  ((MethodResolve (go.PointerType Foo) mutateBar #() "x") #());;;
    return: ((![go.uint64] (struct.field_ref Bar #"a"%go (struct.field_ref Foo #"bar"%go "x"))) = #(W64 2))).

Definition TwoIntsⁱᵐᵖˡ  : go.type := go.StructType [
  (go.FieldDecl "x"%go go.uint64);
  (go.FieldDecl "y"%go go.uint64)
].

Definition Sⁱᵐᵖˡ  : go.type := go.StructType [
  (go.FieldDecl "a"%go go.uint64);
  (go.FieldDecl "b"%go TwoInts);
  (go.FieldDecl "c"%go go.bool)
].

Definition NewS : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.NewS"%go.

(* go: structs.go:14:6 *)
Definition NewSⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (GoAllocValue S (let: "$a" := #(W64 2) in
     let: "$b" := (let: "$x" := #(W64 1) in
     let: "$y" := #(W64 2) in
     struct.make TwoInts [{
       "x" ::= "$x";
       "y" ::= "$y"
     }]) in
     let: "$c" := #true in
     struct.make S [{
       "a" ::= "$a";
       "b" ::= "$b";
       "c" ::= "$c"
     }]))).

(* go: structs.go:22:13 *)
Definition S__readAⁱᵐᵖˡ : val :=
  λ: "s" <>,
    exception_do (let: "s" := (GoAllocValue (go.PointerType S) "s") in
    return: (![go.uint64] (struct.field_ref S #"a"%go (![go.PointerType S] "s")))).

(* go: structs.go:26:13 *)
Definition S__readBⁱᵐᵖˡ : val :=
  λ: "s" <>,
    exception_do (let: "s" := (GoAllocValue (go.PointerType S) "s") in
    return: (![TwoInts] (struct.field_ref S #"b"%go (![go.PointerType S] "s")))).

(* go: structs.go:30:12 *)
Definition S__readBValⁱᵐᵖˡ : val :=
  λ: "s" <>,
    exception_do (let: "s" := (GoAllocValue S "s") in
    return: (![TwoInts] (struct.field_ref S #"b"%go "s"))).

(* go: structs.go:34:13 *)
Definition S__updateBValXⁱᵐᵖˡ : val :=
  λ: "s" "i",
    exception_do (let: "s" := (GoAllocValue (go.PointerType S) "s") in
    let: "i" := (GoAllocValue go.uint64 "i") in
    let: "$r0" := (![go.uint64] "i") in
    do:  ((struct.field_ref TwoInts #"x"%go (struct.field_ref S #"b"%go (![go.PointerType S] "s"))) <-[go.uint64] "$r0");;;
    return: #()).

(* go: structs.go:38:13 *)
Definition S__negateCⁱᵐᵖˡ : val :=
  λ: "s" <>,
    exception_do (let: "s" := (GoAllocValue (go.PointerType S) "s") in
    let: "$r0" := (~ (![go.bool] (struct.field_ref S #"c"%go (![go.PointerType S] "s")))) in
    do:  ((struct.field_ref S #"c"%go (![go.PointerType S] "s")) <-[go.bool] "$r0");;;
    return: #()).

Definition testStructUpdates : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testStructUpdates"%go.

(* go: structs.go:42:6 *)
Definition testStructUpdatesⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok" := (GoAlloc go.bool #()) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "ns" := (GoAlloc (go.PointerType S) #()) in
    let: "$r0" := ((FuncResolve NewS #()) #()) in
    do:  ("ns" <-[go.PointerType S] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && (((MethodResolve (go.PointerType S) readA #() (![go.PointerType S] "ns")) #()) = #(W64 2))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "b1" := (GoAlloc TwoInts #()) in
    let: "$r0" := ((MethodResolve (go.PointerType S) readB #() (![go.PointerType S] "ns")) #()) in
    do:  ("b1" <-[TwoInts] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] (struct.field_ref TwoInts #"x"%go "b1")) = #(W64 1))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    do:  ((MethodResolve (go.PointerType S) negateC #() (![go.PointerType S] "ns")) #());;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.bool] (struct.field_ref S #"c"%go (![go.PointerType S] "ns"))) = #false)) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := #(W64 3) in
    do:  ((struct.field_ref TwoInts #"x"%go "b1") <-[go.uint64] "$r0");;;
    let: "b2" := (GoAlloc TwoInts #()) in
    let: "$r0" := ((MethodResolve (go.PointerType S) readB #() (![go.PointerType S] "ns")) #()) in
    do:  ("b2" <-[TwoInts] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] (struct.field_ref TwoInts #"x"%go "b2")) = #(W64 1))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "b3" := (GoAlloc (go.PointerType TwoInts) #()) in
    let: "$r0" := (struct.field_ref S #"b"%go (![go.PointerType S] "ns")) in
    do:  ("b3" <-[go.PointerType TwoInts] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] (struct.field_ref TwoInts #"x"%go (![go.PointerType TwoInts] "b3"))) = #(W64 1))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    do:  (let: "$a0" := #(W64 4) in
    (MethodResolve (go.PointerType S) updateBValX #() (![go.PointerType S] "ns")) "$a0");;;
    let: "$r0" := ((![go.bool] "ok") && ((struct.field_get TwoInts "x" ((MethodResolve (go.PointerType S) readBVal #() (![go.PointerType S] "ns")) #())) = #(W64 4))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    return: (![go.bool] "ok")).

Definition testNestedStructUpdates : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testNestedStructUpdates"%go.

(* go: structs.go:65:6 *)
Definition testNestedStructUpdatesⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok" := (GoAlloc go.bool #()) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "ns" := (GoAlloc (go.PointerType S) #()) in
    let: "$r0" := ((FuncResolve NewS #()) #()) in
    do:  ("ns" <-[go.PointerType S] "$r0");;;
    let: "$r0" := #(W64 5) in
    do:  ((struct.field_ref TwoInts #"x"%go (struct.field_ref S #"b"%go (![go.PointerType S] "ns"))) <-[go.uint64] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] (struct.field_ref TwoInts #"x"%go (struct.field_ref S #"b"%go (![go.PointerType S] "ns")))) = #(W64 5))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((FuncResolve NewS #()) #()) in
    do:  ("ns" <-[go.PointerType S] "$r0");;;
    let: "p" := (GoAlloc (go.PointerType TwoInts) #()) in
    let: "$r0" := (struct.field_ref S #"b"%go (![go.PointerType S] "ns")) in
    do:  ("p" <-[go.PointerType TwoInts] "$r0");;;
    let: "$r0" := #(W64 5) in
    do:  ((struct.field_ref TwoInts #"x"%go (![go.PointerType TwoInts] "p")) <-[go.uint64] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] (struct.field_ref TwoInts #"x"%go (struct.field_ref S #"b"%go (![go.PointerType S] "ns")))) = #(W64 5))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((FuncResolve NewS #()) #()) in
    do:  ("ns" <-[go.PointerType S] "$r0");;;
    let: "$r0" := (struct.field_ref S #"b"%go (![go.PointerType S] "ns")) in
    do:  ("p" <-[go.PointerType TwoInts] "$r0");;;
    let: "$r0" := #(W64 5) in
    do:  ((struct.field_ref TwoInts #"x"%go (struct.field_ref S #"b"%go (![go.PointerType S] "ns"))) <-[go.uint64] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] (struct.field_ref TwoInts #"x"%go (![go.PointerType TwoInts] "p"))) = #(W64 5))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((FuncResolve NewS #()) #()) in
    do:  ("ns" <-[go.PointerType S] "$r0");;;
    let: "$r0" := (struct.field_ref S #"b"%go (![go.PointerType S] "ns")) in
    do:  ("p" <-[go.PointerType TwoInts] "$r0");;;
    let: "$r0" := #(W64 5) in
    do:  ((struct.field_ref TwoInts #"x"%go (struct.field_ref S #"b"%go (![go.PointerType S] "ns"))) <-[go.uint64] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] (struct.field_ref TwoInts #"x"%go (![go.PointerType TwoInts] "p"))) = #(W64 5))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    return: (![go.bool] "ok")).

Definition testStructConstructions : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testStructConstructions"%go.

(* go: structs.go:90:6 *)
Definition testStructConstructionsⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok" := (GoAlloc go.bool #()) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "p1" := (GoAlloc (go.PointerType TwoInts) #()) in
    let: "p2" := (GoAlloc TwoInts #()) in
    let: "p3" := (GoAlloc TwoInts #()) in
    let: "$r0" := (let: "$y" := #(W64 0) in
    let: "$x" := #(W64 0) in
    struct.make TwoInts [{
      "x" ::= "$x";
      "y" ::= "$y"
    }]) in
    do:  ("p3" <-[TwoInts] "$r0");;;
    let: "p4" := (GoAlloc TwoInts #()) in
    let: "$r0" := (let: "$x" := #(W64 0) in
    let: "$y" := #(W64 0) in
    struct.make TwoInts [{
      "x" ::= "$x";
      "y" ::= "$y"
    }]) in
    do:  ("p4" <-[TwoInts] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.PointerType TwoInts] "p1") = #null)) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := (GoAlloc TwoInts #()) in
    do:  ("p1" <-[go.PointerType TwoInts] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![TwoInts] "p2") = (![TwoInts] "p3"))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![TwoInts] "p3") = (![TwoInts] "p4"))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![TwoInts] "p4") = (![TwoInts] (![go.PointerType TwoInts] "p1")))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ("p4" ≠ (![go.PointerType TwoInts] "p1"))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    return: (![go.bool] "ok")).

Definition testIncompleteStruct : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testIncompleteStruct"%go.

(* go: structs.go:109:6 *)
Definition testIncompleteStructⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok" := (GoAlloc go.bool #()) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "p1" := (GoAlloc TwoInts #()) in
    let: "$r0" := (let: "$x" := #(W64 0) in
    struct.make TwoInts [{
      "x" ::= "$x";
      "y" ::= GoZeroVal go.uint64 #()
    }]) in
    do:  ("p1" <-[TwoInts] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] (struct.field_ref TwoInts #"y"%go "p1")) = #(W64 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "p2" := (GoAlloc S #()) in
    let: "$r0" := (let: "$a" := #(W64 2) in
    struct.make S [{
      "a" ::= "$a";
      "b" ::= GoZeroVal TwoInts #();
      "c" ::= GoZeroVal go.bool #()
    }]) in
    do:  ("p2" <-[S] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] (struct.field_ref TwoInts #"x"%go (struct.field_ref S #"b"%go "p2"))) = #(W64 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.bool] (struct.field_ref S #"c"%go "p2")) = #false)) in
    do:  ("ok" <-[go.bool] "$r0");;;
    return: (![go.bool] "ok")).

Definition StructWrapⁱᵐᵖˡ  : go.type := go.StructType [
  (go.FieldDecl "i"%go go.uint64)
].

Definition testStoreInStructVar : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testStoreInStructVar"%go.

(* go: structs.go:126:6 *)
Definition testStoreInStructVarⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "p" := (GoAlloc StructWrap #()) in
    let: "$r0" := (let: "$i" := #(W64 0) in
    struct.make StructWrap [{
      "i" ::= "$i"
    }]) in
    do:  ("p" <-[StructWrap] "$r0");;;
    let: "$r0" := #(W64 5) in
    do:  ((struct.field_ref StructWrap #"i"%go "p") <-[go.uint64] "$r0");;;
    return: ((![go.uint64] (struct.field_ref StructWrap #"i"%go "p")) = #(W64 5))).

Definition testStoreInStructPointerVar : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testStoreInStructPointerVar"%go.

(* go: structs.go:132:6 *)
Definition testStoreInStructPointerVarⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "p" := (GoAlloc (go.PointerType StructWrap) #()) in
    let: "$r0" := (GoAlloc StructWrap #()) in
    do:  ("p" <-[go.PointerType StructWrap] "$r0");;;
    let: "$r0" := #(W64 5) in
    do:  ((struct.field_ref StructWrap #"i"%go (![go.PointerType StructWrap] "p")) <-[go.uint64] "$r0");;;
    return: ((![go.uint64] (struct.field_ref StructWrap #"i"%go (![go.PointerType StructWrap] "p"))) = #(W64 5))).

Definition testStoreComposite : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testStoreComposite"%go.

(* go: structs.go:138:6 *)
Definition testStoreCompositeⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "p" := (GoAlloc (go.PointerType TwoInts) #()) in
    let: "$r0" := (GoAlloc TwoInts #()) in
    do:  ("p" <-[go.PointerType TwoInts] "$r0");;;
    let: "$r0" := (let: "$x" := #(W64 3) in
    let: "$y" := #(W64 4) in
    struct.make TwoInts [{
      "x" ::= "$x";
      "y" ::= "$y"
    }]) in
    do:  ((![go.PointerType TwoInts] "p") <-[TwoInts] "$r0");;;
    return: ((![go.uint64] (struct.field_ref TwoInts #"y"%go (![go.PointerType TwoInts] "p"))) = #(W64 4))).

Definition testStoreSlice : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testStoreSlice"%go.

(* go: structs.go:144:6 *)
Definition testStoreSliceⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "p" := (GoAlloc (go.PointerType (go.SliceType go.uint64)) #()) in
    let: "$r0" := (GoAlloc (go.SliceType go.uint64) #()) in
    do:  ("p" <-[go.PointerType (go.SliceType go.uint64)] "$r0");;;
    let: "s" := (GoAlloc (go.SliceType go.uint64) #()) in
    let: "$r0" := (slice.make2 go.uint64 #(W64 3)) in
    do:  ("s" <-[go.SliceType go.uint64] "$r0");;;
    let: "$r0" := (![go.SliceType go.uint64] "s") in
    do:  ((![go.PointerType (go.SliceType go.uint64)] "p") <-[go.SliceType go.uint64] "$r0");;;
    return: ((s_to_w64 (let: "$a0" := (![go.SliceType go.uint64] (![go.PointerType (go.SliceType go.uint64)] "p")) in
     slice.len "$a0")) = #(W64 3))).

Definition StructWithFuncⁱᵐᵖˡ  : go.type := go.StructType [
  (go.FieldDecl "fn"%go go.FunctionType (go.Signature [go.uint64] #false [go.uint64]))
].

Definition testStructFieldFunc : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testStructFieldFunc"%go.

(* go: structs.go:155:6 *)
Definition testStructFieldFuncⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "a" := (GoAlloc (go.PointerType StructWithFunc) #()) in
    let: "$r0" := (GoAlloc StructWithFunc #()) in
    do:  ("a" <-[go.PointerType StructWithFunc] "$r0");;;
    let: "$r0" := (λ: "arg",
      exception_do (let: "arg" := (GoAllocValue go.uint64 "arg") in
      return: ((![go.uint64] "arg") * #(W64 2)))
      ) in
    do:  ((struct.field_ref StructWithFunc #"fn"%go (![go.PointerType StructWithFunc] "a")) <-[go.FunctionType (go.Signature [go.uint64] #false [go.uint64])] "$r0");;;
    return: ((let: "$a0" := #(W64 10) in
     (![go.FunctionType (go.Signature [go.uint64] #false [go.uint64])] (struct.field_ref StructWithFunc #"fn"%go (![go.PointerType StructWithFunc] "a"))) "$a0") = #(W64 20))).

Definition testSwitchVal : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testSwitchVal"%go.

(* go: switch.go:3:6 *)
Definition testSwitchValⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.uint64 #()) in
    let: "$r0" := #(W64 0) in
    do:  ("x" <-[go.uint64] "$r0");;;
    let: "$sw" := (![go.uint64] "x") in
    (if: "$sw" = #(W64 0)
    then return: (#true)
    else
      (if: "$sw" = #(W64 1)
      then return: (#false)
      else return: (#false)))).

Definition testSwitchMultiple : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testSwitchMultiple"%go.

(* go: switch.go:15:6 *)
Definition testSwitchMultipleⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.uint64 #()) in
    let: "$r0" := #(W64 0) in
    do:  ("x" <-[go.uint64] "$r0");;;
    let: "$sw" := (![go.uint64] "x") in
    (if: ("$sw" = #(W64 1)) || ("$sw" = #(W64 10))
    then return: (#false)
    else
      (if: "$sw" = #(W64 0)
      then return: (#true)
      else do:  #()));;;
    return: (#false)).

Definition testSwitchDefaultTrue : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testSwitchDefaultTrue"%go.

(* go: switch.go:26:6 *)
Definition testSwitchDefaultTrueⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.uint64 #()) in
    let: "$r0" := #(W64 1) in
    do:  ("x" <-[go.uint64] "$r0");;;
    let: "$sw" := #true in
    (if: "$sw" = #false
    then return: (#false)
    else
      (if: "$sw" = ((![go.uint64] "x") = #(W64 2))
      then return: (#false)
      else return: (#true)))).

Definition switchConcreteⁱᵐᵖˡ  : go.type := go.StructType [
].

Definition switchInterfaceⁱᵐᵖˡ  : go.type := go.InterfaceType [go.MethodElem #"marker"%go (go.Signature [] #false [])].

(* go: switch.go:45:26 *)
Definition switchConcrete__markerⁱᵐᵖˡ : val :=
  λ: "c" <>,
    exception_do (let: "c" := (GoAllocValue (go.PointerType switchConcrete) "c") in
    do:  #()).

Definition testSwitchConversion : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testSwitchConversion"%go.

(* go: switch.go:48:6 *)
Definition testSwitchConversionⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "v" := (GoAlloc (go.PointerType switchConcrete) #()) in
    let: "$r0" := (GoAllocValue switchConcrete (struct.make switchConcrete [{
    }])) in
    do:  ("v" <-[go.PointerType switchConcrete] "$r0");;;
    let: "x" := (GoAlloc switchInterface #()) in
    let: "$r0" := (InterfaceMake (go.PointerType switchConcrete) (![go.PointerType switchConcrete] "v")) in
    do:  ("x" <-[switchInterface] "$r0");;;
    let: "$sw" := (![switchInterface] "x") in
    (if: "$sw" = (InterfaceMake (go.PointerType switchConcrete) (![go.PointerType switchConcrete] "v"))
    then do:  #()
    else return: (#false));;;
    let: "$sw" := (![go.PointerType switchConcrete] "v") in
    (if: (InterfaceMake (go.PointerType switchConcrete) "$sw") = (![switchInterface] "x")
    then do:  #()
    else return: (#false));;;
    return: (#true)).

Definition testPointerAssignment : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testPointerAssignment"%go.

(* go: vars.go:3:6 *)
Definition testPointerAssignmentⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.bool #()) in
    let: "$r0" := #true in
    do:  ("x" <-[go.bool] "$r0");;;
    return: (![go.bool] "x")).

Definition testAddressOfLocal : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testAddressOfLocal"%go.

(* go: vars.go:9:6 *)
Definition testAddressOfLocalⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "x" := (GoAlloc go.bool #()) in
    let: "$r0" := #false in
    do:  ("x" <-[go.bool] "$r0");;;
    let: "xptr" := (GoAlloc (go.PointerType go.bool) #()) in
    let: "$r0" := "x" in
    do:  ("xptr" <-[go.PointerType go.bool] "$r0");;;
    let: "$r0" := #true in
    do:  ((![go.PointerType go.bool] "xptr") <-[go.bool] "$r0");;;
    return: ((![go.bool] "x") && (![go.bool] (![go.PointerType go.bool] "xptr")))).

Definition testAnonymousAssign : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.testAnonymousAssign"%go.

(* go: vars.go:16:6 *)
Definition testAnonymousAssignⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "$r0" := (#(W64 1) + #(W64 2)) in
    do:  "$r0";;;
    return: (#true)).

(* 10 is completely arbitrary *)
Definition MaxTxnWrites : val := #(W64 10).

Definition logLength : val := #(W64 21).

Definition Logⁱᵐᵖˡ  : go.type := go.StructType [
  (go.FieldDecl "d"%go disk.Disk);
  (go.FieldDecl "l"%go go.PointerType sync.Mutex);
  (go.FieldDecl "cache"%go go.MapType go.uint64 (go.SliceType go.byte));
  (go.FieldDecl "length"%go go.PointerType go.uint64)
].

Definition intToBlock : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.intToBlock"%go.

(* go: wal.go:25:6 *)
Definition intToBlockⁱᵐᵖˡ : val :=
  λ: "a",
    exception_do (let: "a" := (GoAllocValue go.uint64 "a") in
    let: "b" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := (slice.make2 go.byte disk.BlockSize) in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    do:  (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (![go.uint64] "a") in
    (FuncResolve primitive.UInt64Put #()) "$a0" "$a1");;;
    return: (![go.SliceType go.byte] "b")).

Definition blockToInt : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.blockToInt"%go.

(* go: wal.go:31:6 *)
Definition blockToIntⁱᵐᵖˡ : val :=
  λ: "v",
    exception_do (let: "v" := (GoAllocValue (go.SliceType go.byte) "v") in
    let: "a" := (GoAlloc go.uint64 #()) in
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "v") in
    (FuncResolve primitive.UInt64Get #()) "$a0") in
    do:  ("a" <-[go.uint64] "$r0");;;
    return: (![go.uint64] "a")).

Definition New : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.New"%go.

(* New initializes a fresh log

   go: wal.go:37:6 *)
Definition Newⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "d" := (GoAlloc disk.Disk #()) in
    let: "$r0" := ((FuncResolve disk.Get #()) #()) in
    do:  ("d" <-[disk.Disk] "$r0");;;
    let: "diskSize" := (GoAlloc go.uint64 #()) in
    let: "$r0" := ((interface.get #"Size"%go (![disk.Disk] "d")) #()) in
    do:  ("diskSize" <-[go.uint64] "$r0");;;
    (if: (![go.uint64] "diskSize") ≤ logLength
    then
      do:  (let: "$a0" := (InterfaceMake go.string #"disk is too small to host log"%go) in
      Panic "$a0")
    else do:  #());;;
    let: "cache" := (GoAlloc (go.MapType go.uint64 (go.SliceType go.byte)) #()) in
    let: "$r0" := (map.make go.uint64 (go.SliceType go.byte)) in
    do:  ("cache" <-[go.MapType go.uint64 (go.SliceType go.byte)] "$r0");;;
    let: "header" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := (let: "$a0" := #(W64 0) in
    (FuncResolve intToBlock #()) "$a0") in
    do:  ("header" <-[go.SliceType go.byte] "$r0");;;
    do:  (let: "$a0" := #(W64 0) in
    let: "$a1" := (![go.SliceType go.byte] "header") in
    (interface.get #"Write"%go (![disk.Disk] "d")) "$a0" "$a1");;;
    let: "lengthPtr" := (GoAlloc (go.PointerType go.uint64) #()) in
    let: "$r0" := (GoAlloc go.uint64 #()) in
    do:  ("lengthPtr" <-[go.PointerType go.uint64] "$r0");;;
    let: "$r0" := #(W64 0) in
    do:  ((![go.PointerType go.uint64] "lengthPtr") <-[go.uint64] "$r0");;;
    let: "l" := (GoAlloc (go.PointerType sync.Mutex) #()) in
    let: "$r0" := (GoAlloc sync.Mutex #()) in
    do:  ("l" <-[go.PointerType sync.Mutex] "$r0");;;
    return: (let: "$d" := (![disk.Disk] "d") in
     let: "$cache" := (![go.MapType go.uint64 (go.SliceType go.byte)] "cache") in
     let: "$length" := (![go.PointerType go.uint64] "lengthPtr") in
     let: "$l" := (![go.PointerType sync.Mutex] "l") in
     struct.make Log [{
       "d" ::= "$d";
       "l" ::= "$l";
       "cache" ::= "$cache";
       "length" ::= "$length"
     }])).

(* go: wal.go:52:14 *)
Definition Log__lockⁱᵐᵖˡ : val :=
  λ: "l" <>,
    exception_do (let: "l" := (GoAllocValue Log "l") in
    do:  ((MethodResolve (go.PointerType sync.Mutex) Lock #() (![go.PointerType sync.Mutex] (struct.field_ref Log #"l"%go "l"))) #());;;
    return: #()).

(* go: wal.go:56:14 *)
Definition Log__unlockⁱᵐᵖˡ : val :=
  λ: "l" <>,
    exception_do (let: "l" := (GoAllocValue Log "l") in
    do:  ((MethodResolve (go.PointerType sync.Mutex) Unlock #() (![go.PointerType sync.Mutex] (struct.field_ref Log #"l"%go "l"))) #());;;
    return: #()).

(* BeginTxn allocates space for a new transaction in the log.

   Returns true if the allocation succeeded.

   go: wal.go:63:14 *)
Definition Log__BeginTxnⁱᵐᵖˡ : val :=
  λ: "l" <>,
    exception_do (let: "l" := (GoAllocValue Log "l") in
    do:  ((MethodResolve Log lock #() (![Log] "l")) #());;;
    let: "length" := (GoAlloc go.uint64 #()) in
    let: "$r0" := (![go.uint64] (![go.PointerType go.uint64] (struct.field_ref Log #"length"%go "l"))) in
    do:  ("length" <-[go.uint64] "$r0");;;
    (if: (![go.uint64] "length") = #(W64 0)
    then
      do:  ((MethodResolve Log unlock #() (![Log] "l")) #());;;
      return: (#true)
    else do:  #());;;
    do:  ((MethodResolve Log unlock #() (![Log] "l")) #());;;
    return: (#false)).

(* Read from the logical disk.

   Reads must go through the log to return committed but un-applied writes.

   go: wal.go:77:14 *)
Definition Log__Readⁱᵐᵖˡ : val :=
  λ: "l" "a",
    exception_do (let: "l" := (GoAllocValue Log "l") in
    let: "a" := (GoAllocValue go.uint64 "a") in
    do:  ((MethodResolve Log lock #() (![Log] "l")) #());;;
    let: "ok" := (GoAlloc go.bool #()) in
    let: "v" := (GoAlloc (go.SliceType go.byte) #()) in
    let: ("$ret0", "$ret1") := (map.get (![go.MapType go.uint64 (go.SliceType go.byte)] (struct.field_ref Log #"cache"%go "l")) (![go.uint64] "a")) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("v" <-[go.SliceType go.byte] "$r0");;;
    do:  ("ok" <-[go.bool] "$r1");;;
    (if: ![go.bool] "ok"
    then
      do:  ((MethodResolve Log unlock #() (![Log] "l")) #());;;
      return: (![go.SliceType go.byte] "v")
    else do:  #());;;
    do:  ((MethodResolve Log unlock #() (![Log] "l")) #());;;
    let: "dv" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := (let: "$a0" := (logLength + (![go.uint64] "a")) in
    (interface.get #"Read"%go (![disk.Disk] (struct.field_ref Log #"d"%go "l"))) "$a0") in
    do:  ("dv" <-[go.SliceType go.byte] "$r0");;;
    return: (![go.SliceType go.byte] "dv")).

(* go: wal.go:90:14 *)
Definition Log__Sizeⁱᵐᵖˡ : val :=
  λ: "l" <>,
    exception_do (let: "l" := (GoAllocValue Log "l") in
    let: "sz" := (GoAlloc go.uint64 #()) in
    let: "$r0" := ((interface.get #"Size"%go (![disk.Disk] (struct.field_ref Log #"d"%go "l"))) #()) in
    do:  ("sz" <-[go.uint64] "$r0");;;
    return: ((![go.uint64] "sz") - logLength)).

(* Write to the disk through the log.

   go: wal.go:97:14 *)
Definition Log__Writeⁱᵐᵖˡ : val :=
  λ: "l" "a" "v",
    exception_do (let: "l" := (GoAllocValue Log "l") in
    let: "v" := (GoAllocValue (go.SliceType go.byte) "v") in
    let: "a" := (GoAllocValue go.uint64 "a") in
    do:  ((MethodResolve Log lock #() (![Log] "l")) #());;;
    let: "length" := (GoAlloc go.uint64 #()) in
    let: "$r0" := (![go.uint64] (![go.PointerType go.uint64] (struct.field_ref Log #"length"%go "l"))) in
    do:  ("length" <-[go.uint64] "$r0");;;
    (if: (![go.uint64] "length") ≥ MaxTxnWrites
    then
      do:  (let: "$a0" := (InterfaceMake go.string #"transaction is at capacity"%go) in
      Panic "$a0")
    else do:  #());;;
    let: "aBlock" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := (let: "$a0" := (![go.uint64] "a") in
    (FuncResolve intToBlock #()) "$a0") in
    do:  ("aBlock" <-[go.SliceType go.byte] "$r0");;;
    let: "nextAddr" := (GoAlloc go.uint64 #()) in
    let: "$r0" := (#(W64 1) + (#(W64 2) * (![go.uint64] "length"))) in
    do:  ("nextAddr" <-[go.uint64] "$r0");;;
    do:  (let: "$a0" := (![go.uint64] "nextAddr") in
    let: "$a1" := (![go.SliceType go.byte] "aBlock") in
    (interface.get #"Write"%go (![disk.Disk] (struct.field_ref Log #"d"%go "l"))) "$a0" "$a1");;;
    do:  (let: "$a0" := ((![go.uint64] "nextAddr") + #(W64 1)) in
    let: "$a1" := (![go.SliceType go.byte] "v") in
    (interface.get #"Write"%go (![disk.Disk] (struct.field_ref Log #"d"%go "l"))) "$a0" "$a1");;;
    let: "$r0" := (![go.SliceType go.byte] "v") in
    do:  (map.insert (![go.MapType go.uint64 (go.SliceType go.byte)] (struct.field_ref Log #"cache"%go "l")) (![go.uint64] "a") "$r0");;;
    let: "$r0" := ((![go.uint64] "length") + #(W64 1)) in
    do:  ((![go.PointerType go.uint64] (struct.field_ref Log #"length"%go "l")) <-[go.uint64] "$r0");;;
    do:  ((MethodResolve Log unlock #() (![Log] "l")) #());;;
    return: #()).

(* Commit the current transaction.

   go: wal.go:113:14 *)
Definition Log__Commitⁱᵐᵖˡ : val :=
  λ: "l" <>,
    exception_do (let: "l" := (GoAllocValue Log "l") in
    do:  ((MethodResolve Log lock #() (![Log] "l")) #());;;
    let: "length" := (GoAlloc go.uint64 #()) in
    let: "$r0" := (![go.uint64] (![go.PointerType go.uint64] (struct.field_ref Log #"length"%go "l"))) in
    do:  ("length" <-[go.uint64] "$r0");;;
    do:  ((MethodResolve Log unlock #() (![Log] "l")) #());;;
    let: "header" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := (let: "$a0" := (![go.uint64] "length") in
    (FuncResolve intToBlock #()) "$a0") in
    do:  ("header" <-[go.SliceType go.byte] "$r0");;;
    do:  (let: "$a0" := #(W64 0) in
    let: "$a1" := (![go.SliceType go.byte] "header") in
    (interface.get #"Write"%go (![disk.Disk] (struct.field_ref Log #"d"%go "l"))) "$a0" "$a1");;;
    return: #()).

Definition getLogEntry : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.getLogEntry"%go.

(* go: wal.go:122:6 *)
Definition getLogEntryⁱᵐᵖˡ : val :=
  λ: "d" "logOffset",
    exception_do (let: "logOffset" := (GoAllocValue go.uint64 "logOffset") in
    let: "d" := (GoAllocValue disk.Disk "d") in
    let: "diskAddr" := (GoAlloc go.uint64 #()) in
    let: "$r0" := (#(W64 1) + (#(W64 2) * (![go.uint64] "logOffset"))) in
    do:  ("diskAddr" <-[go.uint64] "$r0");;;
    let: "aBlock" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := (let: "$a0" := (![go.uint64] "diskAddr") in
    (interface.get #"Read"%go (![disk.Disk] "d")) "$a0") in
    do:  ("aBlock" <-[go.SliceType go.byte] "$r0");;;
    let: "a" := (GoAlloc go.uint64 #()) in
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "aBlock") in
    (FuncResolve blockToInt #()) "$a0") in
    do:  ("a" <-[go.uint64] "$r0");;;
    let: "v" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := (let: "$a0" := ((![go.uint64] "diskAddr") + #(W64 1)) in
    (interface.get #"Read"%go (![disk.Disk] "d")) "$a0") in
    do:  ("v" <-[go.SliceType go.byte] "$r0");;;
    return: (![go.uint64] "a", ![go.SliceType go.byte] "v")).

Definition applyLog : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.applyLog"%go.

(* applyLog assumes we are running sequentially

   go: wal.go:131:6 *)
Definition applyLogⁱᵐᵖˡ : val :=
  λ: "d" "length",
    exception_do (let: "length" := (GoAllocValue go.uint64 "length") in
    let: "d" := (GoAllocValue disk.Disk "d") in
    (let: "i" := (GoAlloc go.uint64 #()) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (if: (![go.uint64] "i") < (![go.uint64] "length")
      then
        let: "v" := (GoAlloc (go.SliceType go.byte) #()) in
        let: "a" := (GoAlloc go.uint64 #()) in
        let: ("$ret0", "$ret1") := (let: "$a0" := (![disk.Disk] "d") in
        let: "$a1" := (![go.uint64] "i") in
        (FuncResolve getLogEntry #()) "$a0" "$a1") in
        let: "$r0" := "$ret0" in
        let: "$r1" := "$ret1" in
        do:  ("a" <-[go.uint64] "$r0");;;
        do:  ("v" <-[go.SliceType go.byte] "$r1");;;
        do:  (let: "$a0" := (logLength + (![go.uint64] "a")) in
        let: "$a1" := (![go.SliceType go.byte] "v") in
        (interface.get #"Write"%go (![disk.Disk] "d")) "$a0" "$a1");;;
        let: "$r0" := ((![go.uint64] "i") + #(W64 1)) in
        do:  ("i" <-[go.uint64] "$r0");;;
        continue: #()
      else do:  #());;;
      break: #()));;;
    return: #()).

Definition clearLog : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.clearLog"%go.

(* go: wal.go:142:6 *)
Definition clearLogⁱᵐᵖˡ : val :=
  λ: "d",
    exception_do (let: "d" := (GoAllocValue disk.Disk "d") in
    let: "header" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := (let: "$a0" := #(W64 0) in
    (FuncResolve intToBlock #()) "$a0") in
    do:  ("header" <-[go.SliceType go.byte] "$r0");;;
    do:  (let: "$a0" := #(W64 0) in
    let: "$a1" := (![go.SliceType go.byte] "header") in
    (interface.get #"Write"%go (![disk.Disk] "d")) "$a0" "$a1");;;
    return: #()).

(* Apply all the committed transactions.

   Frees all the space in the log.

   go: wal.go:150:14 *)
Definition Log__Applyⁱᵐᵖˡ : val :=
  λ: "l" <>,
    exception_do (let: "l" := (GoAllocValue Log "l") in
    do:  ((MethodResolve Log lock #() (![Log] "l")) #());;;
    let: "length" := (GoAlloc go.uint64 #()) in
    let: "$r0" := (![go.uint64] (![go.PointerType go.uint64] (struct.field_ref Log #"length"%go "l"))) in
    do:  ("length" <-[go.uint64] "$r0");;;
    do:  (let: "$a0" := (![disk.Disk] (struct.field_ref Log #"d"%go "l")) in
    let: "$a1" := (![go.uint64] "length") in
    (FuncResolve applyLog #()) "$a0" "$a1");;;
    do:  (let: "$a0" := (![disk.Disk] (struct.field_ref Log #"d"%go "l")) in
    (FuncResolve clearLog #()) "$a0");;;
    let: "$r0" := #(W64 0) in
    do:  ((![go.PointerType go.uint64] (struct.field_ref Log #"length"%go "l")) <-[go.uint64] "$r0");;;
    do:  ((MethodResolve Log unlock #() (![Log] "l")) #());;;
    return: #()).

Definition Open : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.Open"%go.

(* Open recovers the log following a crash or shutdown

   go: wal.go:163:6 *)
Definition Openⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "d" := (GoAlloc disk.Disk #()) in
    let: "$r0" := ((FuncResolve disk.Get #()) #()) in
    do:  ("d" <-[disk.Disk] "$r0");;;
    let: "header" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := (let: "$a0" := #(W64 0) in
    (interface.get #"Read"%go (![disk.Disk] "d")) "$a0") in
    do:  ("header" <-[go.SliceType go.byte] "$r0");;;
    let: "length" := (GoAlloc go.uint64 #()) in
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "header") in
    (FuncResolve blockToInt #()) "$a0") in
    do:  ("length" <-[go.uint64] "$r0");;;
    do:  (let: "$a0" := (![disk.Disk] "d") in
    let: "$a1" := (![go.uint64] "length") in
    (FuncResolve applyLog #()) "$a0" "$a1");;;
    do:  (let: "$a0" := (![disk.Disk] "d") in
    (FuncResolve clearLog #()) "$a0");;;
    let: "cache" := (GoAlloc (go.MapType go.uint64 (go.SliceType go.byte)) #()) in
    let: "$r0" := (map.make go.uint64 (go.SliceType go.byte)) in
    do:  ("cache" <-[go.MapType go.uint64 (go.SliceType go.byte)] "$r0");;;
    let: "lengthPtr" := (GoAlloc (go.PointerType go.uint64) #()) in
    let: "$r0" := (GoAlloc go.uint64 #()) in
    do:  ("lengthPtr" <-[go.PointerType go.uint64] "$r0");;;
    let: "$r0" := #(W64 0) in
    do:  ((![go.PointerType go.uint64] "lengthPtr") <-[go.uint64] "$r0");;;
    let: "l" := (GoAlloc (go.PointerType sync.Mutex) #()) in
    let: "$r0" := (GoAlloc sync.Mutex #()) in
    do:  ("l" <-[go.PointerType sync.Mutex] "$r0");;;
    return: (let: "$d" := (![disk.Disk] "d") in
     let: "$cache" := (![go.MapType go.uint64 (go.SliceType go.byte)] "cache") in
     let: "$length" := (![go.PointerType go.uint64] "lengthPtr") in
     let: "$l" := (![go.PointerType sync.Mutex] "l") in
     struct.make Log [{
       "d" ::= "$d";
       "l" ::= "$l";
       "cache" ::= "$cache";
       "length" ::= "$length"
     }])).

Definition disabled_testWal : go_string := "github.com/goose-lang/goose/testdata/examples/semantics.disabled_testWal"%go.

(* disabled since performance is quite poor

   go: wal.go:178:6 *)
Definition disabled_testWalⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "ok" := (GoAlloc go.bool #()) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "lg" := (GoAlloc Log #()) in
    let: "$r0" := ((FuncResolve New #()) #()) in
    do:  ("lg" <-[Log] "$r0");;;
    (if: (MethodResolve Log BeginTxn #() (![Log] "lg")) #()
    then
      do:  (let: "$a0" := #(W64 2) in
      let: "$a1" := (let: "$a0" := #(W64 11) in
      (FuncResolve intToBlock #()) "$a0") in
      (MethodResolve Log Write #() (![Log] "lg")) "$a0" "$a1")
    else do:  #());;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := (let: "$a0" := #(W64 2) in
    (MethodResolve Log Read #() (![Log] "lg")) "$a0") in
    (FuncResolve blockToInt #()) "$a0") = #(W64 11))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := (let: "$a0" := #(W64 0) in
    (interface.get #"Read"%go (![disk.Disk] (struct.field_ref Log #"d"%go "lg"))) "$a0") in
    (FuncResolve blockToInt #()) "$a0") = #(W64 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    do:  ((MethodResolve Log Commit #() (![Log] "lg")) #());;;
    let: "$r0" := ((![go.bool] "ok") && ((let: "$a0" := (let: "$a0" := #(W64 0) in
    (interface.get #"Read"%go (![disk.Disk] (struct.field_ref Log #"d"%go "lg"))) "$a0") in
    (FuncResolve blockToInt #()) "$a0") = #(W64 1))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    do:  ((MethodResolve Log Apply #() (![Log] "lg")) #());;;
    let: "$r0" := ((![go.bool] "ok") && ((![go.uint64] (![go.PointerType go.uint64] (struct.field_ref Log #"length"%go "lg"))) = #(W64 0))) in
    do:  ("ok" <-[go.bool] "$r0");;;
    return: (![go.bool] "ok")).

Definition vars' : list (go_string * go.type) := [].

Definition functions' : list (go_string * val) := [(findKey, findKeyⁱᵐᵖˡ); (allocate, allocateⁱᵐᵖˡ); (freeRange, freeRangeⁱᵐᵖˡ); (testAllocateDistinct, testAllocateDistinctⁱᵐᵖˡ); (testAllocateFull, testAllocateFullⁱᵐᵖˡ); (testExplicitBlockStmt, testExplicitBlockStmtⁱᵐᵖˡ); (testMinUint64, testMinUint64ⁱᵐᵖˡ); (testMaxUint64, testMaxUint64ⁱᵐᵖˡ); (adder, adderⁱᵐᵖˡ); (testClosureBasic, testClosureBasicⁱᵐᵖˡ); (testCompareAll, testCompareAllⁱᵐᵖˡ); (testCompareGT, testCompareGTⁱᵐᵖˡ); (testCompareGE, testCompareGEⁱᵐᵖˡ); (testCompareLT, testCompareLTⁱᵐᵖˡ); (testCompareLE, testCompareLEⁱᵐᵖˡ); (literalCast, literalCastⁱᵐᵖˡ); (stringToByteSlice, stringToByteSliceⁱᵐᵖˡ); (byteSliceToString, byteSliceToStringⁱᵐᵖˡ); (testByteSliceToString, testByteSliceToStringⁱᵐᵖˡ); (testCopySimple, testCopySimpleⁱᵐᵖˡ); (testCopyShorterDst, testCopyShorterDstⁱᵐᵖˡ); (testCopyShorterSrc, testCopyShorterSrcⁱᵐᵖˡ); (deferSimple, deferSimpleⁱᵐᵖˡ); (testDefer, testDeferⁱᵐᵖˡ); (testDeferFuncLit, testDeferFuncLitⁱᵐᵖˡ); (roundtripEncDec32, roundtripEncDec32ⁱᵐᵖˡ); (roundtripEncDec64, roundtripEncDec64ⁱᵐᵖˡ); (testEncDec32Simple, testEncDec32Simpleⁱᵐᵖˡ); (failing_testEncDec32, failing_testEncDec32ⁱᵐᵖˡ); (testEncDec64Simple, testEncDec64Simpleⁱᵐᵖˡ); (testEncDec64, testEncDec64ⁱᵐᵖˡ); (FirstClassFunction, FirstClassFunctionⁱᵐᵖˡ); (ApplyF, ApplyFⁱᵐᵖˡ); (testFirstClassFunction, testFirstClassFunctionⁱᵐᵖˡ); (addFour64, addFour64ⁱᵐᵖˡ); (failing_testFunctionOrdering, failing_testFunctionOrderingⁱᵐᵖˡ); (storeAndReturn, storeAndReturnⁱᵐᵖˡ); (failing_testArgumentOrder, failing_testArgumentOrderⁱᵐᵖˡ); (testU64ToU32, testU64ToU32ⁱᵐᵖˡ); (testU32Len, testU32Lenⁱᵐᵖˡ); (failing_testU32NewtypeLen, failing_testU32NewtypeLenⁱᵐᵖˡ); (measureArea, measureAreaⁱᵐᵖˡ); (measureVolumePlusNM, measureVolumePlusNMⁱᵐᵖˡ); (measureVolume, measureVolumeⁱᵐᵖˡ); (testBasicInterface, testBasicInterfaceⁱᵐᵖˡ); (testAssignInterface, testAssignInterfaceⁱᵐᵖˡ); (testMultipleInterface, testMultipleInterfaceⁱᵐᵖˡ); (testBinaryExprInterface, testBinaryExprInterfaceⁱᵐᵖˡ); (testIfStmtInterface, testIfStmtInterfaceⁱᵐᵖˡ); (testsUseLocks, testsUseLocksⁱᵐᵖˡ); (standardForLoop, standardForLoopⁱᵐᵖˡ); (testStandardForLoop, testStandardForLoopⁱᵐᵖˡ); (testForLoopWait, testForLoopWaitⁱᵐᵖˡ); (testBreakFromLoopWithContinue, testBreakFromLoopWithContinueⁱᵐᵖˡ); (testBreakFromLoopNoContinue, testBreakFromLoopNoContinueⁱᵐᵖˡ); (testBreakFromLoopNoContinueDouble, testBreakFromLoopNoContinueDoubleⁱᵐᵖˡ); (testBreakFromLoopForOnly, testBreakFromLoopForOnlyⁱᵐᵖˡ); (testBreakFromLoopAssignAndContinue, testBreakFromLoopAssignAndContinueⁱᵐᵖˡ); (testNestedLoops, testNestedLoopsⁱᵐᵖˡ); (testNestedGoStyleLoops, testNestedGoStyleLoopsⁱᵐᵖˡ); (testNestedGoStyleLoopsNoComparison, testNestedGoStyleLoopsNoComparisonⁱᵐᵖˡ); (IterateMapKeys, IterateMapKeysⁱᵐᵖˡ); (IterateMapValues, IterateMapValuesⁱᵐᵖˡ); (testIterateMap, testIterateMapⁱᵐᵖˡ); (testMapSize, testMapSizeⁱᵐᵖˡ); (multReturnTwo, multReturnTwoⁱᵐᵖˡ); (testAssignTwo, testAssignTwoⁱᵐᵖˡ); (multReturnThree, multReturnThreeⁱᵐᵖˡ); (testAssignThree, testAssignThreeⁱᵐᵖˡ); (testMultipleAssignToMap, testMultipleAssignToMapⁱᵐᵖˡ); (returnTwo, returnTwoⁱᵐᵖˡ); (testReturnTwo, testReturnTwoⁱᵐᵖˡ); (testAnonymousBinding, testAnonymousBindingⁱᵐᵖˡ); (returnThree, returnThreeⁱᵐᵖˡ); (testReturnThree, testReturnThreeⁱᵐᵖˡ); (returnFour, returnFourⁱᵐᵖˡ); (testReturnFour, testReturnFourⁱᵐᵖˡ); (failing_testCompareSliceToNil, failing_testCompareSliceToNilⁱᵐᵖˡ); (testComparePointerToNil, testComparePointerToNilⁱᵐᵖˡ); (testCompareNilToNil, testCompareNilToNilⁱᵐᵖˡ); (testComparePointerWrappedToNil, testComparePointerWrappedToNilⁱᵐᵖˡ); (testComparePointerWrappedDefaultToNil, testComparePointerWrappedDefaultToNilⁱᵐᵖˡ); (reverseAssignOps64, reverseAssignOps64ⁱᵐᵖˡ); (reverseAssignOps32, reverseAssignOps32ⁱᵐᵖˡ); (add64Equals, add64Equalsⁱᵐᵖˡ); (sub64Equals, sub64Equalsⁱᵐᵖˡ); (testReverseAssignOps64, testReverseAssignOps64ⁱᵐᵖˡ); (failing_testReverseAssignOps32, failing_testReverseAssignOps32ⁱᵐᵖˡ); (testAdd64Equals, testAdd64Equalsⁱᵐᵖˡ); (testSub64Equals, testSub64Equalsⁱᵐᵖˡ); (testDivisionPrecedence, testDivisionPrecedenceⁱᵐᵖˡ); (testModPrecedence, testModPrecedenceⁱᵐᵖˡ); (testBitwiseOpsPrecedence, testBitwiseOpsPrecedenceⁱᵐᵖˡ); (testArithmeticShifts, testArithmeticShiftsⁱᵐᵖˡ); (testBitAddAnd, testBitAddAndⁱᵐᵖˡ); (testManyParentheses, testManyParenthesesⁱᵐᵖˡ); (testPlusTimes, testPlusTimesⁱᵐᵖˡ); (testOrCompareSimple, testOrCompareSimpleⁱᵐᵖˡ); (testOrCompare, testOrCompareⁱᵐᵖˡ); (testAndCompare, testAndCompareⁱᵐᵖˡ); (testShiftMod, testShiftModⁱᵐᵖˡ); (testLinearize, testLinearizeⁱᵐᵖˡ); (CheckTrue, CheckTrueⁱᵐᵖˡ); (CheckFalse, CheckFalseⁱᵐᵖˡ); (testShortcircuitAndTF, testShortcircuitAndTFⁱᵐᵖˡ); (testShortcircuitAndFT, testShortcircuitAndFTⁱᵐᵖˡ); (testShortcircuitOrTF, testShortcircuitOrTFⁱᵐᵖˡ); (testShortcircuitOrFT, testShortcircuitOrFTⁱᵐᵖˡ); (testSliceOps, testSliceOpsⁱᵐᵖˡ); (testSliceCapacityOps, testSliceCapacityOpsⁱᵐᵖˡ); (testOverwriteArray, testOverwriteArrayⁱᵐᵖˡ); (testSliceLiteral, testSliceLiteralⁱᵐᵖˡ); (testSliceAppend, testSliceAppendⁱᵐᵖˡ); (testFooBarMutation, testFooBarMutationⁱᵐᵖˡ); (NewS, NewSⁱᵐᵖˡ); (testStructUpdates, testStructUpdatesⁱᵐᵖˡ); (testNestedStructUpdates, testNestedStructUpdatesⁱᵐᵖˡ); (testStructConstructions, testStructConstructionsⁱᵐᵖˡ); (testIncompleteStruct, testIncompleteStructⁱᵐᵖˡ); (testStoreInStructVar, testStoreInStructVarⁱᵐᵖˡ); (testStoreInStructPointerVar, testStoreInStructPointerVarⁱᵐᵖˡ); (testStoreComposite, testStoreCompositeⁱᵐᵖˡ); (testStoreSlice, testStoreSliceⁱᵐᵖˡ); (testStructFieldFunc, testStructFieldFuncⁱᵐᵖˡ); (testSwitchVal, testSwitchValⁱᵐᵖˡ); (testSwitchMultiple, testSwitchMultipleⁱᵐᵖˡ); (testSwitchDefaultTrue, testSwitchDefaultTrueⁱᵐᵖˡ); (testSwitchConversion, testSwitchConversionⁱᵐᵖˡ); (testPointerAssignment, testPointerAssignmentⁱᵐᵖˡ); (testAddressOfLocal, testAddressOfLocalⁱᵐᵖˡ); (testAnonymousAssign, testAnonymousAssignⁱᵐᵖˡ); (intToBlock, intToBlockⁱᵐᵖˡ); (blockToInt, blockToIntⁱᵐᵖˡ); (New, Newⁱᵐᵖˡ); (getLogEntry, getLogEntryⁱᵐᵖˡ); (applyLog, applyLogⁱᵐᵖˡ); (clearLog, clearLogⁱᵐᵖˡ); (Open, Openⁱᵐᵖˡ); (disabled_testWal, disabled_testWalⁱᵐᵖˡ)].

Definition msets' : list (go_string * (list (go_string * val))) := [(unit, []); (go.PointerType unit, []); (Enc, []); (go.PointerType Enc, [("consume"%go, Enc__consumeⁱᵐᵖˡ)]); (Dec, []); (go.PointerType Dec, [("consume"%go, Dec__consumeⁱᵐᵖˡ)]); (Editor, []); (go.PointerType Editor, [("AdvanceReturn"%go, Editor__AdvanceReturnⁱᵐᵖˡ)]); (Pair, []); (go.PointerType Pair, []); (Uint32, []); (go.PointerType Uint32, []); (SquareStruct, [("Square"%go, SquareStruct__Squareⁱᵐᵖˡ); ("Volume"%go, SquareStruct__Volumeⁱᵐᵖˡ)]); (go.PointerType SquareStruct, [("Square"%go, (λ: "$r",
                 MethodResolve SquareStruct Square #() (![SquareStruct] "$r")
                 )%V); ("Volume"%go, (λ: "$r",
                 MethodResolve SquareStruct Volume #() (![SquareStruct] "$r")
                 )%V)]); (LoopStruct, [("forLoopWait"%go, LoopStruct__forLoopWaitⁱᵐᵖˡ)]); (go.PointerType LoopStruct, [("forLoopWait"%go, (λ: "$r",
                 MethodResolve LoopStruct forLoopWait #() (![LoopStruct] "$r")
                 )%V)]); (BoolTest, []); (go.PointerType BoolTest, []); (ArrayEditor, []); (go.PointerType ArrayEditor, [("Advance"%go, ArrayEditor__Advanceⁱᵐᵖˡ)]); (Bar, []); (go.PointerType Bar, [("mutate"%go, Bar__mutateⁱᵐᵖˡ)]); (Foo, []); (go.PointerType Foo, [("mutateBar"%go, Foo__mutateBarⁱᵐᵖˡ)]); (TwoInts, []); (go.PointerType TwoInts, []); (S, [("readBVal"%go, S__readBValⁱᵐᵖˡ)]); (go.PointerType S, [("negateC"%go, S__negateCⁱᵐᵖˡ); ("readA"%go, S__readAⁱᵐᵖˡ); ("readB"%go, S__readBⁱᵐᵖˡ); ("readBVal"%go, (λ: "$r",
                 MethodResolve S readBVal #() (![S] "$r")
                 )%V); ("updateBValX"%go, S__updateBValXⁱᵐᵖˡ)]); (StructWrap, []); (go.PointerType StructWrap, []); (StructWithFunc, []); (go.PointerType StructWithFunc, []); (switchConcrete, []); (go.PointerType switchConcrete, [("marker"%go, switchConcrete__markerⁱᵐᵖˡ)]); (Log, [("Apply"%go, Log__Applyⁱᵐᵖˡ); ("BeginTxn"%go, Log__BeginTxnⁱᵐᵖˡ); ("Commit"%go, Log__Commitⁱᵐᵖˡ); ("Read"%go, Log__Readⁱᵐᵖˡ); ("Size"%go, Log__Sizeⁱᵐᵖˡ); ("Write"%go, Log__Writeⁱᵐᵖˡ); ("lock"%go, Log__lockⁱᵐᵖˡ); ("unlock"%go, Log__unlockⁱᵐᵖˡ)]); (go.PointerType Log, [("Apply"%go, (λ: "$r",
                 MethodResolve Log Apply #() (![Log] "$r")
                 )%V); ("BeginTxn"%go, (λ: "$r",
                 MethodResolve Log BeginTxn #() (![Log] "$r")
                 )%V); ("Commit"%go, (λ: "$r",
                 MethodResolve Log Commit #() (![Log] "$r")
                 )%V); ("Read"%go, (λ: "$r",
                 MethodResolve Log Read #() (![Log] "$r")
                 )%V); ("Size"%go, (λ: "$r",
                 MethodResolve Log Size #() (![Log] "$r")
                 )%V); ("Write"%go, (λ: "$r",
                 MethodResolve Log Write #() (![Log] "$r")
                 )%V); ("lock"%go, (λ: "$r",
                 MethodResolve Log lock #() (![Log] "$r")
                 )%V); ("unlock"%go, (λ: "$r",
                 MethodResolve Log unlock #() (![Log] "$r")
                 )%V)])].

#[global] Instance info' : PkgInfo semantics.semantics :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [code.github_com.goose_lang.primitive.primitive; code.sync.sync; code.github_com.goose_lang.primitive.disk.disk];
  |}.

Definition initialize' : val :=
  λ: <>,
    package.init #semantics.semantics (λ: <>,
      exception_do (do:  (disk.initialize' #());;;
      do:  (sync.initialize' #());;;
      do:  (primitive.initialize' #());;;
      do:  (package.alloc semantics.semantics #()))
      ).

End code.
End semantics.
