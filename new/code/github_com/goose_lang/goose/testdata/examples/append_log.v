(* autogenerated from github.com/goose-lang/goose/testdata/examples/append_log *)
Require Export New.code.sync.
Require Export New.code.github_com.tchajed.marshal.
Require Export New.code.github_com.goose_lang.primitive.disk.
From New.golang Require Import defn.
From New Require Import disk_prelude.
Module pkg_id.
Definition append_log : go_string := "github.com/goose-lang/goose/testdata/examples/append_log".

End pkg_id.
Export pkg_id.
Module append_log.

Definition Log {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/goose/testdata/examples/append_log.Log"%go [].

Definition Init {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/append_log.Init"%go.

Definition Open {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/append_log.Open"%go.

Definition writeAll {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/testdata/examples/append_log.writeAll"%go.

(* go: append_log.go:22:17 *)
Definition Log__mkHdrⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "log" <>,
    exception_do (let: "log" := (GoAlloc (go.PointerType Log) "log") in
    let: "enc" := (GoAlloc marshal.Enc (GoZeroVal marshal.Enc #())) in
    let: "$r0" := (let: "$a0" := disk.BlockSize in
    (FuncResolve marshal.NewEnc [] #()) "$a0") in
    do:  ("enc" <-[marshal.Enc] "$r0");;;
    do:  (let: "$a0" := (![go.uint64] (StructFieldRef Log "sz"%go (![go.PointerType Log] "log"))) in
    (MethodResolve marshal.Enc "PutInt"%go (![marshal.Enc] "enc")) "$a0");;;
    do:  (let: "$a0" := (![go.uint64] (StructFieldRef Log "diskSz"%go (![go.PointerType Log] "log"))) in
    (MethodResolve marshal.Enc "PutInt"%go (![marshal.Enc] "enc")) "$a0");;;
    return: ((MethodResolve marshal.Enc "Finish"%go (![marshal.Enc] "enc")) #())).

(* go: append_log.go:29:17 *)
Definition Log__writeHdrⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "log" <>,
    exception_do (let: "log" := (GoAlloc (go.PointerType Log) "log") in
    do:  (let: "$a0" := #(W64 0) in
    let: "$a1" := ((MethodResolve (go.PointerType Log) "mkHdr"%go (![go.PointerType Log] "log")) #()) in
    (FuncResolve disk.Write [] #()) "$a0" "$a1");;;
    return: #()).

(* go: append_log.go:33:6 *)
Definition Initⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "diskSz",
    exception_do (let: "diskSz" := (GoAlloc go.uint64 "diskSz") in
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "diskSz") <⟨go.uint64⟩ #(W64 1))
    then return: (GoAlloc Log (CompositeLiteral Log (LiteralValue [KeyedElement (Some (KeyField "m"%go)) (ElementExpression (GoAlloc sync.Mutex (GoZeroVal sync.Mutex #()))); KeyedElement (Some (KeyField "sz"%go)) (ElementExpression #(W64 0)); KeyedElement (Some (KeyField "diskSz"%go)) (ElementExpression #(W64 0))])), #false)
    else do:  #());;;
    let: "log" := (GoAlloc (go.PointerType Log) (GoZeroVal (go.PointerType Log) #())) in
    let: "$r0" := (GoAlloc Log (CompositeLiteral Log (LiteralValue [KeyedElement (Some (KeyField "m"%go)) (ElementExpression (GoAlloc sync.Mutex (GoZeroVal sync.Mutex #()))); KeyedElement (Some (KeyField "sz"%go)) (ElementExpression #(W64 0)); KeyedElement (Some (KeyField "diskSz"%go)) (ElementExpression (![go.uint64] "diskSz"))]))) in
    do:  ("log" <-[go.PointerType Log] "$r0");;;
    do:  ((MethodResolve (go.PointerType Log) "writeHdr"%go (![go.PointerType Log] "log")) #());;;
    return: (![go.PointerType Log] "log", #true)).

(* go: append_log.go:42:6 *)
Definition Openⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "hdr" := (GoAlloc disk.Block (GoZeroVal disk.Block #())) in
    let: "$r0" := (let: "$a0" := #(W64 0) in
    (FuncResolve disk.Read [] #()) "$a0") in
    do:  ("hdr" <-[disk.Block] "$r0");;;
    let: "dec" := (GoAlloc marshal.Dec (GoZeroVal marshal.Dec #())) in
    let: "$r0" := (let: "$a0" := (![disk.Block] "hdr") in
    (FuncResolve marshal.NewDec [] #()) "$a0") in
    do:  ("dec" <-[marshal.Dec] "$r0");;;
    let: "sz" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := ((MethodResolve marshal.Dec "GetInt"%go (![marshal.Dec] "dec")) #()) in
    do:  ("sz" <-[go.uint64] "$r0");;;
    let: "diskSz" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := ((MethodResolve marshal.Dec "GetInt"%go (![marshal.Dec] "dec")) #()) in
    do:  ("diskSz" <-[go.uint64] "$r0");;;
    return: (GoAlloc Log (CompositeLiteral Log (LiteralValue [KeyedElement (Some (KeyField "m"%go)) (ElementExpression (GoAlloc sync.Mutex (GoZeroVal sync.Mutex #()))); KeyedElement (Some (KeyField "sz"%go)) (ElementExpression (![go.uint64] "sz")); KeyedElement (Some (KeyField "diskSz"%go)) (ElementExpression (![go.uint64] "diskSz"))])))).

(* go: append_log.go:50:17 *)
Definition Log__getⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "log" "i",
    exception_do (let: "log" := (GoAlloc (go.PointerType Log) "log") in
    let: "i" := (GoAlloc go.uint64 "i") in
    let: "sz" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (![go.uint64] (StructFieldRef Log "sz"%go (![go.PointerType Log] "log"))) in
    do:  ("sz" <-[go.uint64] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "i") <⟨go.uint64⟩ (![go.uint64] "sz"))
    then
      return: (let: "$a0" := (#(W64 1) +⟨go.uint64⟩ (![go.uint64] "i")) in
       (FuncResolve disk.Read [] #()) "$a0", #true)
    else do:  #());;;
    return: (Convert go.untyped_nil disk.Block UntypedNil, #false)).

(* go: append_log.go:58:17 *)
Definition Log__Getⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "log" "i",
    exception_do (let: "log" := (GoAlloc (go.PointerType Log) "log") in
    let: "i" := (GoAlloc go.uint64 "i") in
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] (StructFieldRef Log "m"%go (![go.PointerType Log] "log")))) #());;;
    let: "b" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "v" := (GoAlloc disk.Block (GoZeroVal disk.Block #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.uint64] "i") in
    (MethodResolve (go.PointerType Log) "get"%go (![go.PointerType Log] "log")) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("v" <-[disk.Block] "$r0");;;
    do:  ("b" <-[go.bool] "$r1");;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef Log "m"%go (![go.PointerType Log] "log")))) #());;;
    return: (![disk.Block] "v", ![go.bool] "b")).

(* go: append_log.go:65:6 *)
Definition writeAllⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "bks" "off",
    exception_do (let: "off" := (GoAlloc go.uint64 "off") in
    let: "bks" := (GoAlloc (go.SliceType disk.Block) "bks") in
    let: "$range" := (![go.SliceType disk.Block] "bks") in
    (let: "bk" := (GoAlloc disk.Block (GoZeroVal disk.Block #())) in
    let: "i" := (GoAlloc go.int (GoZeroVal go.int #())) in
    slice.for_range disk.Block "$range" (λ: "$key" "$value",
      do:  ("bk" <-[disk.Block] "$value");;;
      do:  ("i" <-[go.int] "$key");;;
      do:  (let: "$a0" := ((![go.uint64] "off") +⟨go.uint64⟩ (Convert go.int go.uint64 (![go.int] "i"))) in
      let: "$a1" := (![disk.Block] "bk") in
      (FuncResolve disk.Write [] #()) "$a0" "$a1")));;;
    return: #()).

(* go: append_log.go:71:17 *)
Definition Log__appendⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "log" "bks",
    exception_do (let: "log" := (GoAlloc (go.PointerType Log) "log") in
    let: "bks" := (GoAlloc (go.SliceType disk.Block) "bks") in
    let: "sz" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (![go.uint64] (StructFieldRef Log "sz"%go (![go.PointerType Log] "log"))) in
    do:  ("sz" <-[go.uint64] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((Convert go.int go.uint64 (let: "$a0" := (![go.SliceType disk.Block] "bks") in
    (FuncResolve go.len [go.SliceType disk.Block] #()) "$a0")) ≥⟨go.uint64⟩ (((![go.uint64] (StructFieldRef Log "diskSz"%go (![go.PointerType Log] "log"))) -⟨go.uint64⟩ #(W64 1)) -⟨go.uint64⟩ (![go.uint64] "sz")))
    then return: (#false)
    else do:  #());;;
    do:  (let: "$a0" := (![go.SliceType disk.Block] "bks") in
    let: "$a1" := (#(W64 1) +⟨go.uint64⟩ (![go.uint64] "sz")) in
    (FuncResolve writeAll [] #()) "$a0" "$a1");;;
    do:  ((StructFieldRef Log "sz"%go (![go.PointerType Log] "log")) <-[go.uint64] ((![go.uint64] (StructFieldRef Log "sz"%go (![go.PointerType Log] "log"))) +⟨go.uint64⟩ (Convert go.int go.uint64 (let: "$a0" := (![go.SliceType disk.Block] "bks") in
    (FuncResolve go.len [go.SliceType disk.Block] #()) "$a0"))));;;
    do:  ((MethodResolve (go.PointerType Log) "writeHdr"%go (![go.PointerType Log] "log")) #());;;
    return: (#true)).

(* go: append_log.go:82:17 *)
Definition Log__Appendⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "log" "bks",
    exception_do (let: "log" := (GoAlloc (go.PointerType Log) "log") in
    let: "bks" := (GoAlloc (go.SliceType disk.Block) "bks") in
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] (StructFieldRef Log "m"%go (![go.PointerType Log] "log")))) #());;;
    let: "b" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := (let: "$a0" := (![go.SliceType disk.Block] "bks") in
    (MethodResolve (go.PointerType Log) "append"%go (![go.PointerType Log] "log")) "$a0") in
    do:  ("b" <-[go.bool] "$r0");;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef Log "m"%go (![go.PointerType Log] "log")))) #());;;
    return: (![go.bool] "b")).

(* go: append_log.go:89:17 *)
Definition Log__resetⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "log" <>,
    exception_do (let: "log" := (GoAlloc (go.PointerType Log) "log") in
    let: "$r0" := #(W64 0) in
    do:  ((StructFieldRef Log "sz"%go (![go.PointerType Log] "log")) <-[go.uint64] "$r0");;;
    do:  ((MethodResolve (go.PointerType Log) "writeHdr"%go (![go.PointerType Log] "log")) #());;;
    return: #()).

(* go: append_log.go:94:17 *)
Definition Log__Resetⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "log" <>,
    exception_do (let: "log" := (GoAlloc (go.PointerType Log) "log") in
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] (StructFieldRef Log "m"%go (![go.PointerType Log] "log")))) #());;;
    do:  ((MethodResolve (go.PointerType Log) "reset"%go (![go.PointerType Log] "log")) #());;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef Log "m"%go (![go.PointerType Log] "log")))) #());;;
    return: #()).

#[global] Instance info' : PkgInfo pkg_id.append_log :=
{|
  pkg_imported_pkgs := [code.sync.pkg_id.sync; code.github_com.tchajed.marshal.pkg_id.marshal; code.github_com.goose_lang.primitive.disk.pkg_id.disk]
|}.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init pkg_id.append_log (λ: <>,
      exception_do (do:  (disk.initialize' #());;;
      do:  (marshal.initialize' #());;;
      do:  (sync.initialize' #()))
      ).

Module Log.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  m' : loc;
  sz' : w64;
  diskSz' : w64;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End Log.

Definition Logⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType [
  (go.FieldDecl "m"%go (go.PointerType sync.Mutex));
  (go.FieldDecl "sz"%go go.uint64);
  (go.FieldDecl "diskSz"%go go.uint64)
].

Class Log_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Log_type_repr  :: go.TypeRepr Log Log.t;
  #[global] Log_underlying :: (Log) <u (Logⁱᵐᵖˡ);
  #[global] Log_get_m (x : Log.t) :: go.IsGoStepPureDet (StructFieldGet (Log) "m") #x #x.(Log.m');
  #[global] Log_set_m (x : Log.t) y :: go.IsGoStepPureDet (StructFieldSet (Log) "m") (#x, #y) #(x <|Log.m' := y|>);
  #[global] Log_get_sz (x : Log.t) :: go.IsGoStepPureDet (StructFieldGet (Log) "sz") #x #x.(Log.sz');
  #[global] Log_set_sz (x : Log.t) y :: go.IsGoStepPureDet (StructFieldSet (Log) "sz") (#x, #y) #(x <|Log.sz' := y|>);
  #[global] Log_get_diskSz (x : Log.t) :: go.IsGoStepPureDet (StructFieldGet (Log) "diskSz") #x #x.(Log.diskSz');
  #[global] Log_set_diskSz (x : Log.t) y :: go.IsGoStepPureDet (StructFieldSet (Log) "diskSz") (#x, #y) #(x <|Log.diskSz' := y|>);
  #[global] Log'ptr_Append_unfold :: MethodUnfold (go.PointerType (Log)) "Append" (Log__Appendⁱᵐᵖˡ);
  #[global] Log'ptr_Get_unfold :: MethodUnfold (go.PointerType (Log)) "Get" (Log__Getⁱᵐᵖˡ);
  #[global] Log'ptr_Reset_unfold :: MethodUnfold (go.PointerType (Log)) "Reset" (Log__Resetⁱᵐᵖˡ);
  #[global] Log'ptr_append_unfold :: MethodUnfold (go.PointerType (Log)) "append" (Log__appendⁱᵐᵖˡ);
  #[global] Log'ptr_get_unfold :: MethodUnfold (go.PointerType (Log)) "get" (Log__getⁱᵐᵖˡ);
  #[global] Log'ptr_mkHdr_unfold :: MethodUnfold (go.PointerType (Log)) "mkHdr" (Log__mkHdrⁱᵐᵖˡ);
  #[global] Log'ptr_reset_unfold :: MethodUnfold (go.PointerType (Log)) "reset" (Log__resetⁱᵐᵖˡ);
  #[global] Log'ptr_writeHdr_unfold :: MethodUnfold (go.PointerType (Log)) "writeHdr" (Log__writeHdrⁱᵐᵖˡ);
}.

Class Assumptions `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Log_instance :: Log_Assumptions;
  #[global] Init_unfold :: FuncUnfold Init [] (Initⁱᵐᵖˡ);
  #[global] Open_unfold :: FuncUnfold Open [] (Openⁱᵐᵖˡ);
  #[global] writeAll_unfold :: FuncUnfold writeAll [] (writeAllⁱᵐᵖˡ);
  #[global] import_sync_Assumption :: sync.Assumptions;
  #[global] import_marshal_Assumption :: marshal.Assumptions;
  #[global] import_disk_Assumption :: disk.Assumptions;
}.
End append_log.
