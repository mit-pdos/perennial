(* autogenerated from github.com/goose-lang/goose/model/channel *)
From New.golang Require Import defn.
Require Export New.code.github_com.goose_lang.primitive.
Require Export New.code.sync.

Definition channel : go_string := "github.com/goose-lang/goose/model/channel".

Module channel.
Section code.
Context `{ffi_syntax}.


Definition ChannelStateⁱᵈ : go_string := "github.com/goose-lang/goose/model/channel.ChannelState"%go.

Definition ChannelState : go_type := uint64T.

Definition start : expr := #(W64 0).

Definition receiver_ready : expr := #(W64 1).

Definition sender_ready : expr := #(W64 2).

Definition receiver_done : expr := #(W64 3).

Definition sender_done : expr := #(W64 4).

Definition closed : expr := #(W64 5).

Definition Channelⁱᵈ : go_string := "github.com/goose-lang/goose/model/channel.Channel"%go.

Definition Channel : val :=
  λ: "T", type.structT [
    (#"lock"%go, #ptrT);
    (#"state"%go, #ChannelState);
    (#"buffer"%go, #sliceT);
    (#"first"%go, #uint64T);
    (#"count"%go, #uint64T);
    (#"v"%go, "T")
  ].

Definition NewChannelRef : go_string := "github.com/goose-lang/goose/model/channel.NewChannelRef"%go.

(* buffer_size = 0 is an unbuffered channel

   go: channel.go:36:6 *)
Definition NewChannelRefⁱᵐᵖˡ : val :=
  λ: "T" "buffer_size",
    exception_do (let: "buffer_size" := (mem.alloc "buffer_size") in
    return: (mem.alloc (let: "$buffer" := (slice.make2 "T" (![#uint64T] "buffer_size")) in
     let: "$lock" := (mem.alloc (type.zero_val #sync.Mutex)) in
     let: "$first" := #(W64 0) in
     let: "$count" := #(W64 0) in
     let: "$state" := start in
     struct.make (Channel "T") [{
       "lock" ::= "$lock";
       "state" ::= "$state";
       "buffer" ::= "$buffer";
       "first" ::= "$first";
       "count" ::= "$count";
       "v" ::= type.zero_val "T"
     }]))).

Definition Select1 : go_string := "github.com/goose-lang/goose/model/channel.Select1"%go.

Definition NewSendCase : go_string := "github.com/goose-lang/goose/model/channel.NewSendCase"%go.

(* c.Send(val)

   is equivalent to:

   c <- val

   go: channel.go:51:22 *)
Definition Channel__Sendⁱᵐᵖˡ : val :=
  λ: "c" "T" "val",
    exception_do (let: "c" := (mem.alloc "c") in
    let: "val" := (mem.alloc "val") in
    (if: (![#ptrT] "c") = #null
    then
      (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
        do:  #())
    else do:  #());;;
    let: "sendCase" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := (![#ptrT] "c") in
    let: "$a1" := (!["T"] "val") in
    ((func_call #NewSendCase) "T") "$a0" "$a1") in
    do:  ("sendCase" <-[#ptrT] "$r0");;;
    do:  (let: "$a0" := (![#ptrT] "sendCase") in
    let: "$a1" := #true in
    ((func_call #Select1) "T") "$a0" "$a1");;;
    return: (#());;;
    return: #()).

Definition SelectDir : go_type := uint64T.

Definition SelectCase : val :=
  λ: "T", type.structT [
    (#"channel"%go, #ptrT);
    (#"dir"%go, #SelectDir);
    (#"Value"%go, "T");
    (#"Ok"%go, #boolT)
  ].

Definition NewRecvCase : go_string := "github.com/goose-lang/goose/model/channel.NewRecvCase"%go.

(* Equivalent to:
   value, ok := <-c
   Notably, this requires the user to consume the ok bool which is not actually required with Go
   channels. This should be able to be solved by adding an overload wrapper that discards the ok
   bool.

   go: channel.go:72:22 *)
Definition Channel__Receiveⁱᵐᵖˡ : val :=
  λ: "c" "T" <>,
    exception_do (let: "c" := (mem.alloc "c") in
    (if: (![#ptrT] "c") = #null
    then
      (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
        do:  #())
    else do:  #());;;
    let: "recvCase" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := (![#ptrT] "c") in
    ((func_call #NewRecvCase) "T") "$a0") in
    do:  ("recvCase" <-[#ptrT] "$r0");;;
    do:  (let: "$a0" := (![#ptrT] "recvCase") in
    let: "$a1" := #true in
    ((func_call #Select1) "T") "$a0" "$a1");;;
    return: (!["T"] (struct.field_ref (SelectCase "T") #"Value"%go (![#ptrT] "recvCase")), ![#boolT] (struct.field_ref (SelectCase "T") #"Ok"%go (![#ptrT] "recvCase")))).

(* This is a non-blocking attempt at closing. The only reason close blocks ever is because there
   may be successful exchanges that need to complete, which is equivalent to the go runtime where
   the closer must still obtain the channel's lock

   go: channel.go:92:22 *)
Definition Channel__TryCloseⁱᵐᵖˡ : val :=
  λ: "c" "T" <>,
    exception_do (let: "c" := (mem.alloc "c") in
    (if: (![#ChannelState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = closed
    then
      do:  (let: "$a0" := (interface.make #stringTⁱᵈ #"close of closed channel"%go) in
      Panic "$a0")
    else do:  #());;;
    (if: ((![#ChannelState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) ≠ receiver_done) && ((![#ChannelState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) ≠ sender_done)
    then
      let: "$r0" := closed in
      do:  ((struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c")) <-[#ChannelState] "$r0");;;
      return: (#true)
    else do:  #());;;
    return: (#false)).

(* c.Close()

   is equivalent to:

   close(c)

   go: channel.go:110:22 *)
Definition Channel__Closeⁱᵐᵖˡ : val :=
  λ: "c" "T" <>,
    exception_do (let: "c" := (mem.alloc "c") in
    (if: (![#ptrT] "c") = #null
    then
      do:  (let: "$a0" := (interface.make #stringTⁱᵈ #"close of nil channel"%go) in
      Panic "$a0")
    else do:  #());;;
    let: "done" := (mem.alloc (type.zero_val #boolT)) in
    let: "$r0" := #false in
    do:  ("done" <-[#boolT] "$r0");;;
    (for: (λ: <>, (~ (![#boolT] "done"))); (λ: <>, #()) := λ: <>,
      do:  ((method_call #(ptrTⁱᵈ sync.Mutexⁱᵈ) #"Lock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
      let: "$r0" := ((method_call #(ptrTⁱᵈ Channelⁱᵈ) #"TryClose"%go (![#ptrT] "c") "T") #()) in
      do:  ("done" <-[#boolT] "$r0");;;
      do:  ((method_call #(ptrTⁱᵈ sync.Mutexⁱᵈ) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #()));;;
    return: #()).

(* v := c.ReceiveDiscardOk

   is equivalent to:
   v := c<-
   It seems like Go requires ignored return values to be annotated with _ but channels don't
   require this so this will need to be translated.

   go: channel.go:128:22 *)
Definition Channel__ReceiveDiscardOkⁱᵐᵖˡ : val :=
  λ: "c" "T" <>,
    exception_do (let: "c" := (mem.alloc "c") in
    let: "return_val" := (mem.alloc (type.zero_val "T")) in
    let: ("$ret0", "$ret1") := ((method_call #(ptrTⁱᵈ Channelⁱᵈ) #"Receive"%go (![#ptrT] "c") "T") #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("return_val" <-["T"] "$r0");;;
    do:  "$r1";;;
    return: (!["T"] "return_val")).

(* If there is a value available in the buffer, consume it, otherwise, don't select.

   go: channel.go:135:22 *)
Definition Channel__BufferedTryReceiveLockedⁱᵐᵖˡ : val :=
  λ: "c" "T" <>,
    exception_do (let: "c" := (mem.alloc "c") in
    let: "v" := (mem.alloc (type.zero_val "T")) in
    (if: (![#uint64T] (struct.field_ref (Channel "T") #"count"%go (![#ptrT] "c"))) > #(W64 0)
    then
      let: "$r0" := (!["T"] (slice.elem_ref "T" (![#sliceT] (struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c"))) (![#uint64T] (struct.field_ref (Channel "T") #"first"%go (![#ptrT] "c"))))) in
      do:  ((struct.field_ref (Channel "T") #"v"%go (![#ptrT] "c")) <-["T"] "$r0");;;
      let: "$r0" := (((![#uint64T] (struct.field_ref (Channel "T") #"first"%go (![#ptrT] "c"))) + #(W64 1)) `rem` (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c"))) in
      slice.len "$a0"))) in
      do:  ((struct.field_ref (Channel "T") #"first"%go (![#ptrT] "c")) <-[#uint64T] "$r0");;;
      do:  ((struct.field_ref (Channel "T") #"count"%go (![#ptrT] "c")) <-[#uint64T] ((![#uint64T] (struct.field_ref (Channel "T") #"count"%go (![#ptrT] "c"))) - #(W64 1)));;;
      return: (#true, !["T"] (struct.field_ref (Channel "T") #"v"%go (![#ptrT] "c")), #true)
    else do:  #());;;
    (if: (![#ChannelState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = closed
    then return: (#true, !["T"] "v", #false)
    else do:  #());;;
    return: (#false, !["T"] "v", #true)).

(* go: channel.go:149:22 *)
Definition Channel__BufferedTryReceiveⁱᵐᵖˡ : val :=
  λ: "c" "T" <>,
    exception_do (let: "c" := (mem.alloc "c") in
    do:  ((method_call #(ptrTⁱᵈ sync.Mutexⁱᵈ) #"Lock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
    let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "return_val" := (mem.alloc (type.zero_val "T")) in
    let: "selected" := (mem.alloc (type.zero_val #boolT)) in
    let: (("$ret0", "$ret1"), "$ret2") := ((method_call #(ptrTⁱᵈ Channelⁱᵈ) #"BufferedTryReceiveLocked"%go (![#ptrT] "c") "T") #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("selected" <-[#boolT] "$r0");;;
    do:  ("return_val" <-["T"] "$r1");;;
    do:  ("ok" <-[#boolT] "$r2");;;
    do:  ((method_call #(ptrTⁱᵈ sync.Mutexⁱᵈ) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
    return: (![#boolT] "selected", !["T"] "return_val", ![#boolT] "ok")).

Definition OfferResultⁱᵈ : go_string := "github.com/goose-lang/goose/model/channel.OfferResult"%go.

Definition OfferResult : go_type := uint64T.

(* Offer was rescinded (other party didn't arrive in time) *)
Definition OfferRescinded : expr := #(W64 0).

(* Other party responded to our offer *)
Definition CompletedExchange : expr := #(W64 1).

(* Unexpected state, indicates model bugs. *)
Definition CloseInterruptedOffer : expr := #(W64 2).

(* go: channel.go:164:22 *)
Definition Channel__UnbufferedTryReceiveⁱᵐᵖˡ : val :=
  λ: "c" "T" <>,
    exception_do (let: "c" := (mem.alloc "c") in
    let: "local_val" := (mem.alloc (type.zero_val "T")) in
    do:  ((method_call #(ptrTⁱᵈ sync.Mutexⁱᵈ) #"Lock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
    (if: (![#ChannelState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = closed
    then
      do:  ((method_call #(ptrTⁱᵈ sync.Mutexⁱᵈ) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
      return: (#true, !["T"] "local_val", #false)
    else do:  #());;;
    (if: (![#ChannelState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = sender_ready
    then
      let: "$r0" := (!["T"] (struct.field_ref (Channel "T") #"v"%go (![#ptrT] "c"))) in
      do:  ("local_val" <-["T"] "$r0");;;
      let: "$r0" := receiver_done in
      do:  ((struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c")) <-[#ChannelState] "$r0");;;
      do:  ((method_call #(ptrTⁱᵈ sync.Mutexⁱᵈ) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
      return: (#true, !["T"] "local_val", #true)
    else do:  #());;;
    (if: (((![#ChannelState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = sender_done) || ((![#ChannelState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = receiver_ready)) || ((![#ChannelState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = receiver_done)
    then
      do:  ((method_call #(ptrTⁱᵈ sync.Mutexⁱᵈ) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
      return: (#false, !["T"] "local_val", #true)
    else do:  #());;;
    (if: (![#ChannelState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = start
    then
      let: "$r0" := receiver_ready in
      do:  ((struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c")) <-[#ChannelState] "$r0");;;
      do:  ((method_call #(ptrTⁱᵈ sync.Mutexⁱᵈ) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
      do:  ((method_call #(ptrTⁱᵈ sync.Mutexⁱᵈ) #"Lock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
      (if: (![#ChannelState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = closed
      then
        do:  ((method_call #(ptrTⁱᵈ sync.Mutexⁱᵈ) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
        return: (#true, !["T"] "local_val", #false)
      else do:  #());;;
      (if: (![#ChannelState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = receiver_ready
      then
        let: "$r0" := start in
        do:  ((struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c")) <-[#ChannelState] "$r0");;;
        do:  ((method_call #(ptrTⁱᵈ sync.Mutexⁱᵈ) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
        return: (#false, !["T"] "local_val", #true)
      else do:  #());;;
      (if: (![#ChannelState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = sender_done
      then
        let: "$r0" := start in
        do:  ((struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c")) <-[#ChannelState] "$r0");;;
        let: "$r0" := (!["T"] (struct.field_ref (Channel "T") #"v"%go (![#ptrT] "c"))) in
        do:  ("local_val" <-["T"] "$r0");;;
        do:  ((method_call #(ptrTⁱᵈ sync.Mutexⁱᵈ) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
        return: (#true, !["T"] "local_val", #true)
      else do:  #());;;
      do:  (let: "$a0" := (interface.make #stringTⁱᵈ #"not supposed to be here!"%go) in
      Panic "$a0")
    else do:  #());;;
    do:  (let: "$a0" := (interface.make #stringTⁱᵈ #"not supposed to be here!"%go) in
    Panic "$a0")).

(* Non-blocking receive function used for select statements. Blocking receive is modeled as
   a single blocking select statement which amounts to a for loop until selected.

   go: channel.go:215:22 *)
Definition Channel__TryReceiveⁱᵐᵖˡ : val :=
  λ: "c" "T" <>,
    exception_do (let: "c" := (mem.alloc "c") in
    (if: (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c"))) in
    slice.len "$a0")) > #(W64 0)
    then
      let: (("$ret0", "$ret1"), "$ret2") := (((method_call #(ptrTⁱᵈ Channelⁱᵈ) #"BufferedTryReceive"%go (![#ptrT] "c") "T") #())) in
      return: ("$ret0", "$ret1", "$ret2")
    else
      let: (("$ret0", "$ret1"), "$ret2") := (((method_call #(ptrTⁱᵈ Channelⁱᵈ) #"UnbufferedTryReceive"%go (![#ptrT] "c") "T") #())) in
      return: ("$ret0", "$ret1", "$ret2"))).

Definition SenderStateⁱᵈ : go_string := "github.com/goose-lang/goose/model/channel.SenderState"%go.

Definition SenderState : go_type := uint64T.

(* Sender found a waiting receiver *)
Definition SenderCompletedWithReceiver : expr := #(W64 0).

(* Sender made an offer (no receiver waiting) *)
Definition SenderMadeOffer : expr := #(W64 1).

(* Exchange in progress, don't select *)
Definition SenderCannotProceed : expr := #(W64 2).

(* go: channel.go:231:22 *)
Definition Channel__SenderCompleteOrOfferⁱᵐᵖˡ : val :=
  λ: "c" "T" "val",
    exception_do (let: "c" := (mem.alloc "c") in
    let: "val" := (mem.alloc "val") in
    (if: (![#ChannelState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = closed
    then
      do:  (let: "$a0" := (interface.make #stringTⁱᵈ #"send on closed channel"%go) in
      Panic "$a0")
    else do:  #());;;
    (if: (![#ChannelState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = receiver_ready
    then
      let: "$r0" := sender_done in
      do:  ((struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c")) <-[#ChannelState] "$r0");;;
      let: "$r0" := (!["T"] "val") in
      do:  ((struct.field_ref (Channel "T") #"v"%go (![#ptrT] "c")) <-["T"] "$r0");;;
      return: (SenderCompletedWithReceiver)
    else do:  #());;;
    (if: (![#ChannelState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = start
    then
      let: "$r0" := sender_ready in
      do:  ((struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c")) <-[#ChannelState] "$r0");;;
      let: "$r0" := (!["T"] "val") in
      do:  ((struct.field_ref (Channel "T") #"v"%go (![#ptrT] "c")) <-["T"] "$r0");;;
      return: (SenderMadeOffer)
    else do:  #());;;
    return: (SenderCannotProceed)).

(* go: channel.go:252:22 *)
Definition Channel__SenderCheckOfferResultⁱᵐᵖˡ : val :=
  λ: "c" "T" <>,
    exception_do (let: "c" := (mem.alloc "c") in
    (if: (![#ChannelState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = closed
    then
      do:  (let: "$a0" := (interface.make #stringTⁱᵈ #"send on closed channel"%go) in
      Panic "$a0")
    else do:  #());;;
    (if: (![#ChannelState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = receiver_done
    then
      let: "$r0" := start in
      do:  ((struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c")) <-[#ChannelState] "$r0");;;
      return: (CompletedExchange)
    else do:  #());;;
    (if: (![#ChannelState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = sender_ready
    then
      let: "$r0" := start in
      do:  ((struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c")) <-[#ChannelState] "$r0");;;
      return: (OfferRescinded)
    else do:  #());;;
    do:  (let: "$a0" := (interface.make #stringTⁱᵈ #"Invalid state transition with open receive offer"%go) in
    Panic "$a0")).

(* If the buffer has free space, push our value.

   go: channel.go:270:22 *)
Definition Channel__BufferedTrySendⁱᵐᵖˡ : val :=
  λ: "c" "T" "val",
    exception_do (let: "c" := (mem.alloc "c") in
    let: "val" := (mem.alloc "val") in
    (if: (![#ChannelState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = closed
    then
      do:  (let: "$a0" := (interface.make #stringTⁱᵈ #"send on closed channel"%go) in
      Panic "$a0")
    else do:  #());;;
    (if: (![#uint64T] (struct.field_ref (Channel "T") #"count"%go (![#ptrT] "c"))) < (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c"))) in
    slice.len "$a0"))
    then
      let: "last" := (mem.alloc (type.zero_val #uint64T)) in
      let: "$r0" := (((![#uint64T] (struct.field_ref (Channel "T") #"first"%go (![#ptrT] "c"))) + (![#uint64T] (struct.field_ref (Channel "T") #"count"%go (![#ptrT] "c")))) `rem` (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c"))) in
      slice.len "$a0"))) in
      do:  ("last" <-[#uint64T] "$r0");;;
      let: "$r0" := (!["T"] "val") in
      do:  ((slice.elem_ref "T" (![#sliceT] (struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c"))) (![#uint64T] "last")) <-["T"] "$r0");;;
      do:  ((struct.field_ref (Channel "T") #"count"%go (![#ptrT] "c")) <-[#uint64T] ((![#uint64T] (struct.field_ref (Channel "T") #"count"%go (![#ptrT] "c"))) + #(W64 1)));;;
      return: (#true)
    else do:  #());;;
    return: (#false)).

(* Non-Blocking send operation for select statements. Blocking send and blocking select
   statements simply call this in a for loop until it returns true.

   go: channel.go:287:22 *)
Definition Channel__TrySendⁱᵐᵖˡ : val :=
  λ: "c" "T" "val",
    exception_do (let: "c" := (mem.alloc "c") in
    let: "val" := (mem.alloc "val") in
    let: "buffer_size" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c"))) in
    slice.len "$a0")) in
    do:  ("buffer_size" <-[#uint64T] "$r0");;;
    (if: (![#uint64T] "buffer_size") ≠ #(W64 0)
    then
      do:  ((method_call #(ptrTⁱᵈ sync.Mutexⁱᵈ) #"Lock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
      let: "sendResult" := (mem.alloc (type.zero_val #boolT)) in
      let: "$r0" := (let: "$a0" := (!["T"] "val") in
      (method_call #(ptrTⁱᵈ Channelⁱᵈ) #"BufferedTrySend"%go (![#ptrT] "c") "T") "$a0") in
      do:  ("sendResult" <-[#boolT] "$r0");;;
      do:  ((method_call #(ptrTⁱᵈ sync.Mutexⁱᵈ) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
      return: (![#boolT] "sendResult")
    else do:  #());;;
    do:  ((method_call #(ptrTⁱᵈ sync.Mutexⁱᵈ) #"Lock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
    let: "senderState" := (mem.alloc (type.zero_val #SenderState)) in
    let: "$r0" := (let: "$a0" := (!["T"] "val") in
    (method_call #(ptrTⁱᵈ Channelⁱᵈ) #"SenderCompleteOrOffer"%go (![#ptrT] "c") "T") "$a0") in
    do:  ("senderState" <-[#SenderState] "$r0");;;
    do:  ((method_call #(ptrTⁱᵈ sync.Mutexⁱᵈ) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
    (if: (![#SenderState] "senderState") = SenderMadeOffer
    then
      do:  ((method_call #(ptrTⁱᵈ sync.Mutexⁱᵈ) #"Lock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
      let: "offerResult" := (mem.alloc (type.zero_val #OfferResult)) in
      let: "$r0" := ((method_call #(ptrTⁱᵈ Channelⁱᵈ) #"SenderCheckOfferResult"%go (![#ptrT] "c") "T") #()) in
      do:  ("offerResult" <-[#OfferResult] "$r0");;;
      do:  ((method_call #(ptrTⁱᵈ sync.Mutexⁱᵈ) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
      return: ((![#OfferResult] "offerResult") = CompletedExchange)
    else do:  #());;;
    return: ((![#SenderState] "senderState") = SenderCompletedWithReceiver)).

(* c.Len()

   is equivalent to:
   len(c)

   This might not be worth specifying since it is hard to make good use of channel length
   semantics.

   go: channel.go:323:22 *)
Definition Channel__Lenⁱᵐᵖˡ : val :=
  λ: "c" "T" <>,
    exception_do (let: "c" := (mem.alloc "c") in
    (if: (![#ptrT] "c") = #null
    then return: (#(W64 0))
    else do:  #());;;
    let: "chan_len" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("chan_len" <-[#uint64T] "$r0");;;
    do:  ((method_call #(ptrTⁱᵈ sync.Mutexⁱᵈ) #"Lock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
    let: "$r0" := (![#uint64T] (struct.field_ref (Channel "T") #"count"%go (![#ptrT] "c"))) in
    do:  ("chan_len" <-[#uint64T] "$r0");;;
    do:  ((method_call #(ptrTⁱᵈ sync.Mutexⁱᵈ) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
    return: (![#uint64T] "chan_len")).

(* c.Cap()

   is equivalent to:
   cap(c)

   go: channel.go:338:22 *)
Definition Channel__Capⁱᵐᵖˡ : val :=
  λ: "c" "T" <>,
    exception_do (let: "c" := (mem.alloc "c") in
    (if: (![#ptrT] "c") = #null
    then return: (#(W64 0))
    else do:  #());;;
    return: (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c"))) in
     slice.len "$a0"))).

Definition SelectDirⁱᵈ : go_string := "github.com/goose-lang/goose/model/channel.SelectDir"%go.

(* case Chan <- Send *)
Definition SelectSend : expr := #(W64 0).

(* case <-Chan: *)
Definition SelectRecv : expr := #(W64 1).

Definition SelectCaseⁱᵈ : go_string := "github.com/goose-lang/goose/model/channel.SelectCase"%go.

(* go: channel.go:364:6 *)
Definition NewSendCaseⁱᵐᵖˡ : val :=
  λ: "T" "channel" "value",
    exception_do (let: "value" := (mem.alloc "value") in
    let: "channel" := (mem.alloc "channel") in
    return: (mem.alloc (let: "$channel" := (![#ptrT] "channel") in
     let: "$dir" := SelectSend in
     let: "$Value" := (!["T"] "value") in
     struct.make (SelectCase "T") [{
       "channel" ::= "$channel";
       "dir" ::= "$dir";
       "Value" ::= "$Value";
       "Ok" ::= type.zero_val #boolT
     }]))).

(* go: channel.go:372:6 *)
Definition NewRecvCaseⁱᵐᵖˡ : val :=
  λ: "T" "channel",
    exception_do (let: "channel" := (mem.alloc "channel") in
    return: (mem.alloc (let: "$channel" := (![#ptrT] "channel") in
     let: "$dir" := SelectRecv in
     struct.make (SelectCase "T") [{
       "channel" ::= "$channel";
       "dir" ::= "$dir";
       "Value" ::= type.zero_val "T";
       "Ok" ::= type.zero_val #boolT
     }]))).

Definition TrySelect : go_string := "github.com/goose-lang/goose/model/channel.TrySelect"%go.

(* Uses the applicable Try<Operation> function on the select case's channel. Default is always
   selectable so simply returns true.

   go: channel.go:381:6 *)
Definition TrySelectⁱᵐᵖˡ : val :=
  λ: "T" "select_case",
    exception_do (let: "select_case" := (mem.alloc "select_case") in
    let: "channel" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (![#ptrT] (struct.field_ref (SelectCase "T") #"channel"%go (![#ptrT] "select_case"))) in
    do:  ("channel" <-[#ptrT] "$r0");;;
    (if: (![#ptrT] "channel") = #null
    then return: (#false)
    else do:  #());;;
    (if: (![#SelectDir] (struct.field_ref (SelectCase "T") #"dir"%go (![#ptrT] "select_case"))) = SelectSend
    then
      return: (let: "$a0" := (!["T"] (struct.field_ref (SelectCase "T") #"Value"%go (![#ptrT] "select_case"))) in
       (method_call #(ptrTⁱᵈ Channelⁱᵈ) #"TrySend"%go (![#ptrT] "channel") "T") "$a0")
    else do:  #());;;
    (if: (![#SelectDir] (struct.field_ref (SelectCase "T") #"dir"%go (![#ptrT] "select_case"))) = SelectRecv
    then
      let: "item" := (mem.alloc (type.zero_val "T")) in
      let: "ok" := (mem.alloc (type.zero_val #boolT)) in
      let: "selected" := (mem.alloc (type.zero_val #boolT)) in
      let: (("$ret0", "$ret1"), "$ret2") := ((method_call #(ptrTⁱᵈ Channelⁱᵈ) #"TryReceive"%go (![#ptrT] "channel") "T") #()) in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      let: "$r2" := "$ret2" in
      do:  ("selected" <-[#boolT] "$r0");;;
      do:  ("item" <-["T"] "$r1");;;
      do:  ("ok" <-[#boolT] "$r2");;;
      let: "$r0" := (!["T"] "item") in
      do:  ((struct.field_ref (SelectCase "T") #"Value"%go (![#ptrT] "select_case")) <-["T"] "$r0");;;
      let: "$r0" := (![#boolT] "ok") in
      do:  ((struct.field_ref (SelectCase "T") #"Ok"%go (![#ptrT] "select_case")) <-[#boolT] "$r0");;;
      return: (![#boolT] "selected")
    else do:  #());;;
    return: (#false)).

(* Select1 performs a select operation on 1 case. This is used for Send and
   Receive as well, since these channel operations in Go are equivalent to
   a single case select statement with no default.

   go: channel.go:408:6 *)
Definition Select1ⁱᵐᵖˡ : val :=
  λ: "T1" "case1" "blocking",
    exception_do (let: "blocking" := (mem.alloc "blocking") in
    let: "case1" := (mem.alloc "case1") in
    let: "selected" := (mem.alloc (type.zero_val #boolT)) in
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "$r0" := (let: "$a0" := (![#ptrT] "case1") in
      ((func_call #TrySelect) "T1") "$a0") in
      do:  ("selected" <-[#boolT] "$r0");;;
      (if: (![#boolT] "selected") || (~ (![#boolT] "blocking"))
      then break: #()
      else do:  #()));;;
    return: (![#boolT] "selected")).

Definition TrySelectCase2 : go_string := "github.com/goose-lang/goose/model/channel.TrySelectCase2"%go.

(* go: channel.go:421:6 *)
Definition TrySelectCase2ⁱᵐᵖˡ : val :=
  λ: "T1" "T2" "index" "case1" "case2",
    exception_do (let: "case2" := (mem.alloc "case2") in
    let: "case1" := (mem.alloc "case1") in
    let: "index" := (mem.alloc "index") in
    (if: (![#uint64T] "index") = #(W64 0)
    then
      return: (let: "$a0" := (![#ptrT] "case1") in
       ((func_call #TrySelect) "T1") "$a0")
    else do:  #());;;
    (if: (![#uint64T] "index") = #(W64 1)
    then
      return: (let: "$a0" := (![#ptrT] "case2") in
       ((func_call #TrySelect) "T2") "$a0")
    else do:  #());;;
    do:  (let: "$a0" := (interface.make #stringTⁱᵈ #"index needs to be 0 or 1"%go) in
    Panic "$a0")).

Definition Select2 : go_string := "github.com/goose-lang/goose/model/channel.Select2"%go.

(* go: channel.go:434:6 *)
Definition Select2ⁱᵐᵖˡ : val :=
  λ: "T1" "T2" "case1" "case2" "blocking",
    exception_do (let: "blocking" := (mem.alloc "blocking") in
    let: "case2" := (mem.alloc "case2") in
    let: "case1" := (mem.alloc "case1") in
    let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (((func_call #primitive.RandomUint64) #()) `rem` #(W64 2)) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (if: let: "$a0" := (![#uint64T] "i") in
    let: "$a1" := (![#ptrT] "case1") in
    let: "$a2" := (![#ptrT] "case2") in
    ((func_call #TrySelectCase2) "T1" "T2") "$a0" "$a1" "$a2"
    then return: (![#uint64T] "i")
    else do:  #());;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (if: let: "$a0" := (![#ptrT] "case1") in
      ((func_call #TrySelect) "T1") "$a0"
      then return: (#(W64 0))
      else do:  #());;;
      (if: let: "$a0" := (![#ptrT] "case2") in
      ((func_call #TrySelect) "T2") "$a0"
      then return: (#(W64 1))
      else do:  #());;;
      (if: (~ (![#boolT] "blocking"))
      then return: (#(W64 2))
      else do:  #()))).

Definition TrySelectCase3 : go_string := "github.com/goose-lang/goose/model/channel.TrySelectCase3"%go.

(* go: channel.go:458:6 *)
Definition TrySelectCase3ⁱᵐᵖˡ : val :=
  λ: "T1" "T2" "T3" "index" "case1" "case2" "case3",
    exception_do (let: "case3" := (mem.alloc "case3") in
    let: "case2" := (mem.alloc "case2") in
    let: "case1" := (mem.alloc "case1") in
    let: "index" := (mem.alloc "index") in
    (if: (![#uint64T] "index") = #(W64 0)
    then
      return: (let: "$a0" := (![#ptrT] "case1") in
       ((func_call #TrySelect) "T1") "$a0")
    else do:  #());;;
    (if: (![#uint64T] "index") = #(W64 1)
    then
      return: (let: "$a0" := (![#ptrT] "case2") in
       ((func_call #TrySelect) "T2") "$a0")
    else do:  #());;;
    (if: (![#uint64T] "index") = #(W64 2)
    then
      return: (let: "$a0" := (![#ptrT] "case3") in
       ((func_call #TrySelect) "T3") "$a0")
    else do:  #());;;
    do:  (let: "$a0" := (interface.make #stringTⁱᵈ #"index needs to be 0, 1 or 2"%go) in
    Panic "$a0")).

Definition Select3 : go_string := "github.com/goose-lang/goose/model/channel.Select3"%go.

(* go: channel.go:475:6 *)
Definition Select3ⁱᵐᵖˡ : val :=
  λ: "T1" "T2" "T3" "case1" "case2" "case3" "blocking",
    exception_do (let: "blocking" := (mem.alloc "blocking") in
    let: "case3" := (mem.alloc "case3") in
    let: "case2" := (mem.alloc "case2") in
    let: "case1" := (mem.alloc "case1") in
    let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (((func_call #primitive.RandomUint64) #()) `rem` #(W64 3)) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (if: let: "$a0" := (![#uint64T] "i") in
    let: "$a1" := (![#ptrT] "case1") in
    let: "$a2" := (![#ptrT] "case2") in
    let: "$a3" := (![#ptrT] "case3") in
    ((func_call #TrySelectCase3) "T1" "T2" "T3") "$a0" "$a1" "$a2" "$a3"
    then return: (![#uint64T] "i")
    else do:  #());;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (if: let: "$a0" := (![#ptrT] "case1") in
      ((func_call #TrySelect) "T1") "$a0"
      then return: (#(W64 0))
      else do:  #());;;
      (if: let: "$a0" := (![#ptrT] "case2") in
      ((func_call #TrySelect) "T2") "$a0"
      then return: (#(W64 1))
      else do:  #());;;
      (if: let: "$a0" := (![#ptrT] "case3") in
      ((func_call #TrySelect) "T3") "$a0"
      then return: (#(W64 2))
      else do:  #());;;
      (if: (~ (![#boolT] "blocking"))
      then return: (#(W64 3))
      else do:  #()))).

Definition TrySelectCase4 : go_string := "github.com/goose-lang/goose/model/channel.TrySelectCase4"%go.

(* go: channel.go:502:6 *)
Definition TrySelectCase4ⁱᵐᵖˡ : val :=
  λ: "T1" "T2" "T3" "T4" "index" "case1" "case2" "case3" "case4",
    exception_do (let: "case4" := (mem.alloc "case4") in
    let: "case3" := (mem.alloc "case3") in
    let: "case2" := (mem.alloc "case2") in
    let: "case1" := (mem.alloc "case1") in
    let: "index" := (mem.alloc "index") in
    (if: (![#uint64T] "index") = #(W64 0)
    then
      return: (let: "$a0" := (![#ptrT] "case1") in
       ((func_call #TrySelect) "T1") "$a0")
    else do:  #());;;
    (if: (![#uint64T] "index") = #(W64 1)
    then
      return: (let: "$a0" := (![#ptrT] "case2") in
       ((func_call #TrySelect) "T2") "$a0")
    else do:  #());;;
    (if: (![#uint64T] "index") = #(W64 2)
    then
      return: (let: "$a0" := (![#ptrT] "case3") in
       ((func_call #TrySelect) "T3") "$a0")
    else do:  #());;;
    (if: (![#uint64T] "index") = #(W64 3)
    then
      return: (let: "$a0" := (![#ptrT] "case4") in
       ((func_call #TrySelect) "T4") "$a0")
    else do:  #());;;
    do:  (let: "$a0" := (interface.make #stringTⁱᵈ #"index needs to be 0, 1, 2 or 3"%go) in
    Panic "$a0")).

Definition Select4 : go_string := "github.com/goose-lang/goose/model/channel.Select4"%go.

(* go: channel.go:523:6 *)
Definition Select4ⁱᵐᵖˡ : val :=
  λ: "T1" "T2" "T3" "T4" "case1" "case2" "case3" "case4" "blocking",
    exception_do (let: "blocking" := (mem.alloc "blocking") in
    let: "case4" := (mem.alloc "case4") in
    let: "case3" := (mem.alloc "case3") in
    let: "case2" := (mem.alloc "case2") in
    let: "case1" := (mem.alloc "case1") in
    let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (((func_call #primitive.RandomUint64) #()) `rem` #(W64 4)) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (if: let: "$a0" := (![#uint64T] "i") in
    let: "$a1" := (![#ptrT] "case1") in
    let: "$a2" := (![#ptrT] "case2") in
    let: "$a3" := (![#ptrT] "case3") in
    let: "$a4" := (![#ptrT] "case4") in
    ((func_call #TrySelectCase4) "T1" "T2" "T3" "T4") "$a0" "$a1" "$a2" "$a3" "$a4"
    then return: (![#uint64T] "i")
    else do:  #());;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (if: let: "$a0" := (![#ptrT] "case1") in
      ((func_call #TrySelect) "T1") "$a0"
      then return: (#(W64 0))
      else do:  #());;;
      (if: let: "$a0" := (![#ptrT] "case2") in
      ((func_call #TrySelect) "T2") "$a0"
      then return: (#(W64 1))
      else do:  #());;;
      (if: let: "$a0" := (![#ptrT] "case3") in
      ((func_call #TrySelect) "T3") "$a0"
      then return: (#(W64 2))
      else do:  #());;;
      (if: let: "$a0" := (![#ptrT] "case4") in
      ((func_call #TrySelect) "T4") "$a0"
      then return: (#(W64 3))
      else do:  #());;;
      (if: (~ (![#boolT] "blocking"))
      then return: (#(W64 4))
      else do:  #()))).

Definition TrySelectCase5 : go_string := "github.com/goose-lang/goose/model/channel.TrySelectCase5"%go.

(* go: channel.go:554:6 *)
Definition TrySelectCase5ⁱᵐᵖˡ : val :=
  λ: "T1" "T2" "T3" "T4" "T5" "index" "case1" "case2" "case3" "case4" "case5",
    exception_do (let: "case5" := (mem.alloc "case5") in
    let: "case4" := (mem.alloc "case4") in
    let: "case3" := (mem.alloc "case3") in
    let: "case2" := (mem.alloc "case2") in
    let: "case1" := (mem.alloc "case1") in
    let: "index" := (mem.alloc "index") in
    (if: (![#uint64T] "index") = #(W64 0)
    then
      return: (let: "$a0" := (![#ptrT] "case1") in
       ((func_call #TrySelect) "T1") "$a0")
    else do:  #());;;
    (if: (![#uint64T] "index") = #(W64 1)
    then
      return: (let: "$a0" := (![#ptrT] "case2") in
       ((func_call #TrySelect) "T2") "$a0")
    else do:  #());;;
    (if: (![#uint64T] "index") = #(W64 2)
    then
      return: (let: "$a0" := (![#ptrT] "case3") in
       ((func_call #TrySelect) "T3") "$a0")
    else do:  #());;;
    (if: (![#uint64T] "index") = #(W64 3)
    then
      return: (let: "$a0" := (![#ptrT] "case4") in
       ((func_call #TrySelect) "T4") "$a0")
    else do:  #());;;
    (if: (![#uint64T] "index") = #(W64 4)
    then
      return: (let: "$a0" := (![#ptrT] "case5") in
       ((func_call #TrySelect) "T5") "$a0")
    else do:  #());;;
    do:  (let: "$a0" := (interface.make #stringTⁱᵈ #"index needs to be 0, 1, 2, 3 or 4"%go) in
    Panic "$a0")).

Definition Select5 : go_string := "github.com/goose-lang/goose/model/channel.Select5"%go.

(* go: channel.go:579:6 *)
Definition Select5ⁱᵐᵖˡ : val :=
  λ: "T1" "T2" "T3" "T4" "T5" "case1" "case2" "case3" "case4" "case5" "blocking",
    exception_do (let: "blocking" := (mem.alloc "blocking") in
    let: "case5" := (mem.alloc "case5") in
    let: "case4" := (mem.alloc "case4") in
    let: "case3" := (mem.alloc "case3") in
    let: "case2" := (mem.alloc "case2") in
    let: "case1" := (mem.alloc "case1") in
    let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (((func_call #primitive.RandomUint64) #()) `rem` #(W64 5)) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (if: let: "$a0" := (![#uint64T] "i") in
    let: "$a1" := (![#ptrT] "case1") in
    let: "$a2" := (![#ptrT] "case2") in
    let: "$a3" := (![#ptrT] "case3") in
    let: "$a4" := (![#ptrT] "case4") in
    let: "$a5" := (![#ptrT] "case5") in
    ((func_call #TrySelectCase5) "T1" "T2" "T3" "T4" "T5") "$a0" "$a1" "$a2" "$a3" "$a4" "$a5"
    then return: (![#uint64T] "i")
    else do:  #());;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (if: let: "$a0" := (![#ptrT] "case1") in
      ((func_call #TrySelect) "T1") "$a0"
      then return: (#(W64 0))
      else do:  #());;;
      (if: let: "$a0" := (![#ptrT] "case2") in
      ((func_call #TrySelect) "T2") "$a0"
      then return: (#(W64 1))
      else do:  #());;;
      (if: let: "$a0" := (![#ptrT] "case3") in
      ((func_call #TrySelect) "T3") "$a0"
      then return: (#(W64 2))
      else do:  #());;;
      (if: let: "$a0" := (![#ptrT] "case4") in
      ((func_call #TrySelect) "T4") "$a0"
      then return: (#(W64 3))
      else do:  #());;;
      (if: let: "$a0" := (![#ptrT] "case5") in
      ((func_call #TrySelect) "T5") "$a0"
      then return: (#(W64 4))
      else do:  #());;;
      (if: (~ (![#boolT] "blocking"))
      then return: (#(W64 5))
      else do:  #()))).

Definition vars' : list (go_string * go_type) := [].

Definition functions' : list (go_string * val) := [(NewChannelRef, NewChannelRefⁱᵐᵖˡ); (NewSendCase, NewSendCaseⁱᵐᵖˡ); (NewRecvCase, NewRecvCaseⁱᵐᵖˡ); (TrySelect, TrySelectⁱᵐᵖˡ); (Select1, Select1ⁱᵐᵖˡ); (TrySelectCase2, TrySelectCase2ⁱᵐᵖˡ); (Select2, Select2ⁱᵐᵖˡ); (TrySelectCase3, TrySelectCase3ⁱᵐᵖˡ); (Select3, Select3ⁱᵐᵖˡ); (TrySelectCase4, TrySelectCase4ⁱᵐᵖˡ); (Select4, Select4ⁱᵐᵖˡ); (TrySelectCase5, TrySelectCase5ⁱᵐᵖˡ); (Select5, Select5ⁱᵐᵖˡ)].

Definition msets' : list (go_string * (list (go_string * val))) := [(ChannelStateⁱᵈ, []); (ptrTⁱᵈ ChannelStateⁱᵈ, []); (Channelⁱᵈ, []); (ptrTⁱᵈ Channelⁱᵈ, [("BufferedTryReceive"%go, Channel__BufferedTryReceiveⁱᵐᵖˡ); ("BufferedTryReceiveLocked"%go, Channel__BufferedTryReceiveLockedⁱᵐᵖˡ); ("BufferedTrySend"%go, Channel__BufferedTrySendⁱᵐᵖˡ); ("Cap"%go, Channel__Capⁱᵐᵖˡ); ("Close"%go, Channel__Closeⁱᵐᵖˡ); ("Len"%go, Channel__Lenⁱᵐᵖˡ); ("Receive"%go, Channel__Receiveⁱᵐᵖˡ); ("ReceiveDiscardOk"%go, Channel__ReceiveDiscardOkⁱᵐᵖˡ); ("Send"%go, Channel__Sendⁱᵐᵖˡ); ("SenderCheckOfferResult"%go, Channel__SenderCheckOfferResultⁱᵐᵖˡ); ("SenderCompleteOrOffer"%go, Channel__SenderCompleteOrOfferⁱᵐᵖˡ); ("TryClose"%go, Channel__TryCloseⁱᵐᵖˡ); ("TryReceive"%go, Channel__TryReceiveⁱᵐᵖˡ); ("TrySend"%go, Channel__TrySendⁱᵐᵖˡ); ("UnbufferedTryReceive"%go, Channel__UnbufferedTryReceiveⁱᵐᵖˡ)]); (OfferResultⁱᵈ, []); (ptrTⁱᵈ OfferResultⁱᵈ, []); (SenderStateⁱᵈ, []); (ptrTⁱᵈ SenderStateⁱᵈ, []); (SelectDirⁱᵈ, []); (ptrTⁱᵈ SelectDirⁱᵈ, []); (SelectCaseⁱᵈ, []); (ptrTⁱᵈ SelectCaseⁱᵈ, [])].

#[global] Instance info' : PkgInfo channel.channel :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [sync.sync; primitive.primitive];
  |}.

Definition initialize' : val :=
  λ: <>,
    package.init #channel.channel (λ: <>,
      exception_do (do:  (primitive.initialize' #());;;
      do:  (sync.initialize' #());;;
      do:  (package.alloc channel.channel #()))
      ).

End code.
End channel.
