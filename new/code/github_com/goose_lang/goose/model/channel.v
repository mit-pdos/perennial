(* autogenerated from github.com/goose-lang/goose/model/channel *)
Require Export New.code.github_com.goose_lang.primitive.
Require Export New.code.sync.

From New.golang Require Import defn.
Definition channel : go_string := "github.com/goose-lang/goose/model/channel".

Module channel.

Module OfferState. Definition id : go_string := "github.com/goose-lang/goose/model/channel.OfferState"%go. End OfferState.
Module Channel. Definition id : go_string := "github.com/goose-lang/goose/model/channel.Channel"%go. End Channel.
Module SelectDir. Definition id : go_string := "github.com/goose-lang/goose/model/channel.SelectDir"%go. End SelectDir.

Section code.
Context `{ffi_syntax}.


Definition OfferState : go_type := uint64T.
#[global] Typeclasses Opaque OfferState.
#[global] Opaque OfferState.

Definition Buffered : val := #(W64 0).

Definition Idle : val := #(W64 1).

Definition SndWait : val := #(W64 2).

Definition RcvWait : val := #(W64 3).

Definition SndDone : val := #(W64 4).

Definition RcvDone : val := #(W64 5).

Definition Closed : val := #(W64 6).

Definition Channel : val :=
  λ: "T", type.structT [
    (#"lock"%go, #ptrT);
    (#"state"%go, #OfferState);
    (#"buffer"%go, #sliceT);
    (#"cap"%go, #uint64T);
    (#"v"%go, "T")
  ].
  #[global] Typeclasses Opaque Channel.
  #[global] Opaque Channel.

Definition NewChannelRef : go_string := "github.com/goose-lang/goose/model/channel.NewChannelRef"%go.

(* buffer_size = 0 is an unbuffered channel

   go: channel.go:33:6 *)
Definition NewChannelRefⁱᵐᵖˡ : val :=
  λ: "T" "buffer_size",
    exception_do (let: "buffer_size" := (mem.alloc "buffer_size") in
    let: "local_state" := (mem.alloc (type.zero_val #OfferState)) in
    let: "$r0" := Idle in
    do:  ("local_state" <-[#OfferState] "$r0");;;
    (if: (![#uint64T] "buffer_size") > #(W64 0)
    then
      let: "$r0" := Buffered in
      do:  ("local_state" <-[#OfferState] "$r0")
    else do:  #());;;
    return: (mem.alloc (let: "$buffer" := (slice.make2 "T" #(W64 0)) in
     let: "$lock" := (mem.alloc (type.zero_val #sync.Mutex)) in
     let: "$cap" := (![#uint64T] "buffer_size") in
     let: "$state" := (![#OfferState] "local_state") in
     struct.make (Channel "T") [{
       "lock" ::= "$lock";
       "state" ::= "$state";
       "buffer" ::= "$buffer";
       "cap" ::= "$cap";
       "v" ::= type.zero_val "T"
     }]))).

(* c.Send(val)

   is equivalent to:

   c <- val

   go: channel.go:51:22 *)
Definition Channel__Sendⁱᵐᵖˡ : val :=
  λ: "c" "T" "v",
    exception_do (let: "c" := (mem.alloc "c") in
    let: "v" := (mem.alloc "v") in
    (if: (![#ptrT] "c") = #null
    then
      (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
        do:  #())
    else do:  #());;;
    (for: (λ: <>, (~ (let: "$a0" := (!["T"] "v") in
    let: "$a1" := #true in
    (method_call #(ptrT.id Channel.id) #"TrySend"%go (![#ptrT] "c") "T") "$a0" "$a1"))); (λ: <>, #()) := λ: <>,
      do:  #());;;
    return: #()).

(* go: channel.go:67:22 *)
Definition Channel__Receiveⁱᵐᵖˡ : val :=
  λ: "c" "T" <>,
    exception_do (let: "c" := (mem.alloc "c") in
    (if: (![#ptrT] "c") = #null
    then
      (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
        do:  #())
    else do:  #());;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "ok" := (mem.alloc (type.zero_val #boolT)) in
      let: "v" := (mem.alloc (type.zero_val "T")) in
      let: "success" := (mem.alloc (type.zero_val #boolT)) in
      let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := #true in
      (method_call #(ptrT.id Channel.id) #"TryReceive"%go (![#ptrT] "c") "T") "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      let: "$r2" := "$ret2" in
      do:  ("success" <-[#boolT] "$r0");;;
      do:  ("v" <-["T"] "$r1");;;
      do:  ("ok" <-[#boolT] "$r2");;;
      (if: ![#boolT] "success"
      then return: (!["T"] "v", ![#boolT] "ok")
      else do:  #()))).

(* This is a non-blocking attempt at closing. The only reason close blocks ever is because there
   may be successful exchanges that need to complete, which is equivalent to the go runtime where
   the closer must still obtain the channel's lock

   go: channel.go:84:22 *)
Definition Channel__TryCloseⁱᵐᵖˡ : val :=
  λ: "c" "T" <>,
    exception_do (let: "c" := (mem.alloc "c") in
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
    let: "$sw" := (![#OfferState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) in
    (if: "$sw" = Closed
    then
      do:  (let: "$a0" := (interface.make #stringT.id #"close of closed channel"%go) in
      Panic "$a0")
    else
      (if: ("$sw" = Buffered) || ("$sw" = Idle)
      then
        let: "$r0" := Closed in
        do:  ((struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c")) <-[#OfferState] "$r0");;;
        do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
        return: (#true)
      else
        do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
        return: (#false)))).

(* c.Close()

   is equivalent to:

   close(c)

   go: channel.go:106:22 *)
Definition Channel__Closeⁱᵐᵖˡ : val :=
  λ: "c" "T" <>,
    exception_do (let: "c" := (mem.alloc "c") in
    (if: (![#ptrT] "c") = #null
    then
      do:  (let: "$a0" := (interface.make #stringT.id #"close of nil channel"%go) in
      Panic "$a0")
    else do:  #());;;
    (for: (λ: <>, (~ ((method_call #(ptrT.id Channel.id) #"TryClose"%go (![#ptrT] "c") "T") #()))); (λ: <>, #()) := λ: <>,
      do:  #());;;
    return: #()).

(* v := c.ReceiveDiscardOk

   is equivalent to:
   v := c<-
   It seems like Go requires ignored return values to be annotated with _ but channels don't
   require this so this will need to be translated.

   go: channel.go:120:22 *)
Definition Channel__ReceiveDiscardOkⁱᵐᵖˡ : val :=
  λ: "c" "T" <>,
    exception_do (let: "c" := (mem.alloc "c") in
    let: "return_val" := (mem.alloc (type.zero_val "T")) in
    let: ("$ret0", "$ret1") := ((method_call #(ptrT.id Channel.id) #"Receive"%go (![#ptrT] "c") "T") #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("return_val" <-["T"] "$r0");;;
    do:  "$r1";;;
    return: (!["T"] "return_val")).

(* Non-blocking receive function used for select statements.
   The blocking parameter here is used to determine whether or not we will make an offer to a
   waiting sender. If true, we will make an offer since blocking receive is modeled as a for loop
   around nonblocking TryReceive. If false, we don't make an offer since we don't need to match
   with another non-blocking send.

   go: channel.go:131:22 *)
Definition Channel__TryReceiveⁱᵐᵖˡ : val :=
  λ: "c" "T" "blocking",
    exception_do (let: "c" := (mem.alloc "c") in
    let: "blocking" := (mem.alloc "blocking") in
    let: "local_val" := (mem.alloc (type.zero_val "T")) in
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
    let: "$sw" := (![#OfferState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) in
    (if: "$sw" = Buffered
    then
      let: "v" := (mem.alloc (type.zero_val "T")) in
      (if: int_gt (let: "$a0" := (![#sliceT] (struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c"))) in
      slice.len "$a0") #(W64 0)
      then
        let: "val_copy" := (mem.alloc (type.zero_val "T")) in
        let: "$r0" := (!["T"] (slice.elem_ref "T" (![#sliceT] (struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c"))) #(W64 0))) in
        do:  ("val_copy" <-["T"] "$r0");;;
        let: "$r0" := (let: "$s" := (![#sliceT] (struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c"))) in
        slice.slice "T" "$s" #(W64 1) (slice.len "$s")) in
        do:  ((struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c")) <-[#sliceT] "$r0");;;
        do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
        return: (#true, !["T"] "val_copy", #true)
      else do:  #());;;
      do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
      return: (#false, !["T"] "v", #true)
    else
      (if: "$sw" = Closed
      then
        (if: int_gt (let: "$a0" := (![#sliceT] (struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c"))) in
        slice.len "$a0") #(W64 0)
        then
          let: "val_copy" := (mem.alloc (type.zero_val "T")) in
          let: "$r0" := (!["T"] (slice.elem_ref "T" (![#sliceT] (struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c"))) #(W64 0))) in
          do:  ("val_copy" <-["T"] "$r0");;;
          let: "$r0" := (let: "$s" := (![#sliceT] (struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c"))) in
          slice.slice "T" "$s" #(W64 1) (slice.len "$s")) in
          do:  ((struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c")) <-[#sliceT] "$r0");;;
          do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
          return: (#true, !["T"] "val_copy", #true)
        else do:  #());;;
        do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
        return: (#true, !["T"] "local_val", #false)
      else
        (if: "$sw" = SndWait
        then
          let: "$r0" := (!["T"] (struct.field_ref (Channel "T") #"v"%go (![#ptrT] "c"))) in
          do:  ("local_val" <-["T"] "$r0");;;
          let: "$r0" := RcvDone in
          do:  ((struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c")) <-[#OfferState] "$r0");;;
          do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
          return: (#true, !["T"] "local_val", #true)
        else
          (if: "$sw" = Idle
          then
            (if: ![#boolT] "blocking"
            then
              let: "$r0" := RcvWait in
              do:  ((struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c")) <-[#OfferState] "$r0");;;
              do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
              do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
              let: "$sw" := (![#OfferState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) in
              (if: "$sw" = RcvWait
              then
                let: "$r0" := Idle in
                do:  ((struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c")) <-[#OfferState] "$r0");;;
                do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
                return: (#false, !["T"] "local_val", #true)
              else
                (if: "$sw" = SndDone
                then
                  let: "$r0" := Idle in
                  do:  ((struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c")) <-[#OfferState] "$r0");;;
                  let: "$r0" := (!["T"] (struct.field_ref (Channel "T") #"v"%go (![#ptrT] "c"))) in
                  do:  ("local_val" <-["T"] "$r0");;;
                  do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
                  return: (#true, !["T"] "local_val", #true)
                else
                  do:  (let: "$a0" := (interface.make #stringT.id #"not supposed to be here!"%go) in
                  Panic "$a0")))
            else do:  #());;;
            do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
            return: (#false, !["T"] "local_val", #true)
          else
            do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
            return: (#false, !["T"] "local_val", #true)))))).

(* Non-Blocking send operation for select statements. Blocking send and blocking select
   statements simply call this in a for loop until it returns true.

   go: channel.go:196:22 *)
Definition Channel__TrySendⁱᵐᵖˡ : val :=
  λ: "c" "T" "val" "blocking",
    exception_do (let: "c" := (mem.alloc "c") in
    let: "blocking" := (mem.alloc "blocking") in
    let: "val" := (mem.alloc "val") in
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
    let: "$sw" := (![#OfferState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) in
    (if: "$sw" = Closed
    then
      do:  (let: "$a0" := (interface.make #stringT.id #"send on closed channel"%go) in
      Panic "$a0")
    else
      (if: "$sw" = Buffered
      then
        (if: int_lt (let: "$a0" := (![#sliceT] (struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c"))) in
        slice.len "$a0") (u_to_w64 (![#uint64T] (struct.field_ref (Channel "T") #"cap"%go (![#ptrT] "c"))))
        then
          let: "$r0" := (let: "$a0" := (![#sliceT] (struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c"))) in
          let: "$a1" := ((let: "$sl0" := (!["T"] "val") in
          slice.literal "T" ["$sl0"])) in
          (slice.append "T") "$a0" "$a1") in
          do:  ((struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c")) <-[#sliceT] "$r0");;;
          do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
          return: (#true)
        else do:  #());;;
        do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
        return: (#false)
      else
        (if: "$sw" = RcvWait
        then
          let: "$r0" := SndDone in
          do:  ((struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c")) <-[#OfferState] "$r0");;;
          let: "$r0" := (!["T"] "val") in
          do:  ((struct.field_ref (Channel "T") #"v"%go (![#ptrT] "c")) <-["T"] "$r0");;;
          do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
          return: (#true)
        else
          (if: "$sw" = Idle
          then
            (if: ![#boolT] "blocking"
            then
              let: "$r0" := SndWait in
              do:  ((struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c")) <-[#OfferState] "$r0");;;
              let: "$r0" := (!["T"] "val") in
              do:  ((struct.field_ref (Channel "T") #"v"%go (![#ptrT] "c")) <-["T"] "$r0");;;
              do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
              do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
              let: "$sw" := (![#OfferState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) in
              (if: "$sw" = RcvDone
              then
                let: "$r0" := Idle in
                do:  ((struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c")) <-[#OfferState] "$r0");;;
                do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
                return: (#true)
              else
                (if: "$sw" = SndWait
                then
                  let: "$r0" := Idle in
                  do:  ((struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c")) <-[#OfferState] "$r0");;;
                  do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
                  return: (#false)
                else
                  do:  (let: "$a0" := (interface.make #stringT.id #"Invalid state transition with open receive offer"%go) in
                  Panic "$a0")))
            else do:  #());;;
            do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
            return: (#false)
          else
            do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
            return: (#false)))))).

(* c.Len()

   is equivalent to:
   len(c)

   This might not be worth specifying since it is hard to make good use of channel length
   semantics.

   go: channel.go:257:22 *)
Definition Channel__Lenⁱᵐᵖˡ : val :=
  λ: "c" "T" <>,
    exception_do (let: "c" := (mem.alloc "c") in
    (if: (![#ptrT] "c") = #null
    then return: (#(W64 0))
    else do:  #());;;
    let: "chan_len" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("chan_len" <-[#uint64T] "$r0");;;
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
    let: "$r0" := (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c"))) in
    slice.len "$a0")) in
    do:  ("chan_len" <-[#uint64T] "$r0");;;
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
    return: (![#uint64T] "chan_len")).

(* c.Cap()

   is equivalent to:
   cap(c)

   go: channel.go:272:22 *)
Definition Channel__Capⁱᵐᵖˡ : val :=
  λ: "c" "T" <>,
    exception_do (let: "c" := (mem.alloc "c") in
    (if: (![#ptrT] "c") = #null
    then return: (#(W64 0))
    else do:  #());;;
    return: (![#uint64T] (struct.field_ref (Channel "T") #"cap"%go (![#ptrT] "c")))).

(* c.Iter() returns an iterator that models a for range loop over the channel.

   go: channel.go:280:22 *)
Definition Channel__Iterⁱᵐᵖˡ : val :=
  λ: "c" "T" <>,
    exception_do (let: "c" := (mem.alloc "c") in
    return: ((λ: "yield",
       exception_do (let: "yield" := (mem.alloc "yield") in
       (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
         let: "ok" := (mem.alloc (type.zero_val #boolT)) in
         let: "v" := (mem.alloc (type.zero_val "T")) in
         let: "selected" := (mem.alloc (type.zero_val #boolT)) in
         let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := #true in
         (method_call #(ptrT.id Channel.id) #"TryReceive"%go (![#ptrT] "c") "T") "$a0") in
         let: "$r0" := "$ret0" in
         let: "$r1" := "$ret1" in
         let: "$r2" := "$ret2" in
         do:  ("selected" <-[#boolT] "$r0");;;
         do:  ("v" <-["T"] "$r1");;;
         do:  ("ok" <-[#boolT] "$r2");;;
         (if: (~ (![#boolT] "selected"))
         then continue: #()
         else do:  #());;;
         (if: (~ (![#boolT] "ok"))
         then return: (#())
         else do:  #());;;
         (if: (~ (let: "$a0" := (!["T"] "v") in
         (![#funcT] "yield") "$a0"))
         then return: (#())
         else do:  #()));;;
       return: #())
       ))).

Definition SelectDir : go_type := uint64T.
#[global] Typeclasses Opaque SelectDir.
#[global] Opaque SelectDir.

(* case Chan <- Send *)
Definition SelectSend : val := #(W64 0).

(* case <-Chan: *)
Definition SelectRecv : val := #(W64 1).

Definition NonBlockingSelect1 : go_string := "github.com/goose-lang/goose/model/channel.NonBlockingSelect1"%go.

(* Non-blocking select with 1 case (send or receive)
   For receive: value parameter is ignored
   Returns (selected, received_value, ok)

   go: channel.go:313:6 *)
Definition NonBlockingSelect1ⁱᵐᵖˡ : val :=
  λ: "T" "ch" "dir" "value",
    exception_do (let: "value" := (mem.alloc "value") in
    let: "dir" := (mem.alloc "dir") in
    let: "ch" := (mem.alloc "ch") in
    let: "zero" := (mem.alloc (type.zero_val "T")) in
    (if: (![#SelectDir] "dir") = SelectSend
    then
      let: "selected" := (mem.alloc (type.zero_val #boolT)) in
      let: "$r0" := (let: "$a0" := (!["T"] "value") in
      let: "$a1" := #false in
      (method_call #(ptrT.id Channel.id) #"TrySend"%go (![#ptrT] "ch") "T") "$a0" "$a1") in
      do:  ("selected" <-[#boolT] "$r0");;;
      return: (![#boolT] "selected", !["T"] "zero", #false)
    else
      let: "ok" := (mem.alloc (type.zero_val #boolT)) in
      let: "recv_val" := (mem.alloc (type.zero_val "T")) in
      let: "selected" := (mem.alloc (type.zero_val #boolT)) in
      let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := #false in
      (method_call #(ptrT.id Channel.id) #"TryReceive"%go (![#ptrT] "ch") "T") "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      let: "$r2" := "$ret2" in
      do:  ("selected" <-[#boolT] "$r0");;;
      do:  ("recv_val" <-["T"] "$r1");;;
      do:  ("ok" <-[#boolT] "$r2");;;
      return: (![#boolT] "selected", !["T"] "recv_val", ![#boolT] "ok"))).

Definition BlockingSelect2 : go_string := "github.com/goose-lang/goose/model/channel.BlockingSelect2"%go.

(* Blocking select with 2 cases
   Returns (caseIndex, received_value1, received_value2, ok)

   go: channel.go:327:6 *)
Definition BlockingSelect2ⁱᵐᵖˡ : val :=
  λ: "T1" "T2" "ch1" "dir1" "val1" "ch2" "dir2" "val2",
    exception_do (let: "val2" := (mem.alloc "val2") in
    let: "dir2" := (mem.alloc "dir2") in
    let: "ch2" := (mem.alloc "ch2") in
    let: "val1" := (mem.alloc "val1") in
    let: "dir1" := (mem.alloc "dir1") in
    let: "ch1" := (mem.alloc "ch1") in
    let: "zero1" := (mem.alloc (type.zero_val "T1")) in
    let: "zero2" := (mem.alloc (type.zero_val "T2")) in
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (if: (((func_call #primitive.RandomUint64) #()) `rem` #(W64 2)) = #(W64 0)
      then
        (if: (![#SelectDir] "dir1") = SelectSend
        then
          (if: let: "$a0" := (!["T1"] "val1") in
          let: "$a1" := #true in
          (method_call #(ptrT.id Channel.id) #"TrySend"%go (![#ptrT] "ch1") "T1") "$a0" "$a1"
          then return: (#(W64 0), !["T1"] "zero1", !["T2"] "zero2", #false)
          else do:  #())
        else
          let: "ok" := (mem.alloc (type.zero_val #boolT)) in
          let: "recv_val" := (mem.alloc (type.zero_val "T1")) in
          let: "selected" := (mem.alloc (type.zero_val #boolT)) in
          let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := #true in
          (method_call #(ptrT.id Channel.id) #"TryReceive"%go (![#ptrT] "ch1") "T1") "$a0") in
          let: "$r0" := "$ret0" in
          let: "$r1" := "$ret1" in
          let: "$r2" := "$ret2" in
          do:  ("selected" <-[#boolT] "$r0");;;
          do:  ("recv_val" <-["T1"] "$r1");;;
          do:  ("ok" <-[#boolT] "$r2");;;
          (if: ![#boolT] "selected"
          then return: (#(W64 0), !["T1"] "recv_val", !["T2"] "zero2", ![#boolT] "ok")
          else do:  #()))
      else
        (if: (![#SelectDir] "dir2") = SelectSend
        then
          (if: let: "$a0" := (!["T2"] "val2") in
          let: "$a1" := #true in
          (method_call #(ptrT.id Channel.id) #"TrySend"%go (![#ptrT] "ch2") "T2") "$a0" "$a1"
          then return: (#(W64 1), !["T1"] "zero1", !["T2"] "zero2", #false)
          else do:  #())
        else
          let: "ok" := (mem.alloc (type.zero_val #boolT)) in
          let: "recv_val" := (mem.alloc (type.zero_val "T2")) in
          let: "selected" := (mem.alloc (type.zero_val #boolT)) in
          let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := #true in
          (method_call #(ptrT.id Channel.id) #"TryReceive"%go (![#ptrT] "ch2") "T2") "$a0") in
          let: "$r0" := "$ret0" in
          let: "$r1" := "$ret1" in
          let: "$r2" := "$ret2" in
          do:  ("selected" <-[#boolT] "$r0");;;
          do:  ("recv_val" <-["T2"] "$r1");;;
          do:  ("ok" <-[#boolT] "$r2");;;
          (if: ![#boolT] "selected"
          then return: (#(W64 1), !["T1"] "zero1", !["T2"] "recv_val", ![#boolT] "ok")
          else do:  #()))))).

Definition NonBlockingSelect2 : go_string := "github.com/goose-lang/goose/model/channel.NonBlockingSelect2"%go.

(* Non-blocking select with 2 cases
   Returns (caseIndex, received_value1, received_value2, ok)
   caseIndex = 2 means no selection

   go: channel.go:367:6 *)
Definition NonBlockingSelect2ⁱᵐᵖˡ : val :=
  λ: "T1" "T2" "ch1" "dir1" "val1" "ch2" "dir2" "val2",
    exception_do (let: "val2" := (mem.alloc "val2") in
    let: "dir2" := (mem.alloc "dir2") in
    let: "ch2" := (mem.alloc "ch2") in
    let: "val1" := (mem.alloc "val1") in
    let: "dir1" := (mem.alloc "dir1") in
    let: "ch1" := (mem.alloc "ch1") in
    let: "zero1" := (mem.alloc (type.zero_val "T1")) in
    let: "zero2" := (mem.alloc (type.zero_val "T2")) in
    (if: (((func_call #primitive.RandomUint64) #()) `rem` #(W64 2)) = #(W64 0)
    then
      (if: (![#SelectDir] "dir1") = SelectSend
      then
        (if: let: "$a0" := (!["T1"] "val1") in
        let: "$a1" := #false in
        (method_call #(ptrT.id Channel.id) #"TrySend"%go (![#ptrT] "ch1") "T1") "$a0" "$a1"
        then return: (#(W64 0), !["T1"] "zero1", !["T2"] "zero2", #false)
        else do:  #())
      else
        let: "ok" := (mem.alloc (type.zero_val #boolT)) in
        let: "recv_val" := (mem.alloc (type.zero_val "T1")) in
        let: "selected" := (mem.alloc (type.zero_val #boolT)) in
        let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := #false in
        (method_call #(ptrT.id Channel.id) #"TryReceive"%go (![#ptrT] "ch1") "T1") "$a0") in
        let: "$r0" := "$ret0" in
        let: "$r1" := "$ret1" in
        let: "$r2" := "$ret2" in
        do:  ("selected" <-[#boolT] "$r0");;;
        do:  ("recv_val" <-["T1"] "$r1");;;
        do:  ("ok" <-[#boolT] "$r2");;;
        (if: ![#boolT] "selected"
        then return: (#(W64 0), !["T1"] "recv_val", !["T2"] "zero2", ![#boolT] "ok")
        else do:  #()));;;
      (if: (![#SelectDir] "dir2") = SelectSend
      then
        (if: let: "$a0" := (!["T2"] "val2") in
        let: "$a1" := #false in
        (method_call #(ptrT.id Channel.id) #"TrySend"%go (![#ptrT] "ch2") "T2") "$a0" "$a1"
        then return: (#(W64 1), !["T1"] "zero1", !["T2"] "zero2", #false)
        else do:  #())
      else
        let: "ok" := (mem.alloc (type.zero_val #boolT)) in
        let: "recv_val" := (mem.alloc (type.zero_val "T2")) in
        let: "selected" := (mem.alloc (type.zero_val #boolT)) in
        let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := #false in
        (method_call #(ptrT.id Channel.id) #"TryReceive"%go (![#ptrT] "ch2") "T2") "$a0") in
        let: "$r0" := "$ret0" in
        let: "$r1" := "$ret1" in
        let: "$r2" := "$ret2" in
        do:  ("selected" <-[#boolT] "$r0");;;
        do:  ("recv_val" <-["T2"] "$r1");;;
        do:  ("ok" <-[#boolT] "$r2");;;
        (if: ![#boolT] "selected"
        then return: (#(W64 1), !["T1"] "zero1", !["T2"] "recv_val", ![#boolT] "ok")
        else do:  #()))
    else
      (if: (![#SelectDir] "dir2") = SelectSend
      then
        (if: let: "$a0" := (!["T2"] "val2") in
        let: "$a1" := #false in
        (method_call #(ptrT.id Channel.id) #"TrySend"%go (![#ptrT] "ch2") "T2") "$a0" "$a1"
        then return: (#(W64 1), !["T1"] "zero1", !["T2"] "zero2", #false)
        else do:  #())
      else
        let: "ok" := (mem.alloc (type.zero_val #boolT)) in
        let: "recv_val" := (mem.alloc (type.zero_val "T2")) in
        let: "selected" := (mem.alloc (type.zero_val #boolT)) in
        let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := #false in
        (method_call #(ptrT.id Channel.id) #"TryReceive"%go (![#ptrT] "ch2") "T2") "$a0") in
        let: "$r0" := "$ret0" in
        let: "$r1" := "$ret1" in
        let: "$r2" := "$ret2" in
        do:  ("selected" <-[#boolT] "$r0");;;
        do:  ("recv_val" <-["T2"] "$r1");;;
        do:  ("ok" <-[#boolT] "$r2");;;
        (if: ![#boolT] "selected"
        then return: (#(W64 1), !["T1"] "zero1", !["T2"] "recv_val", ![#boolT] "ok")
        else do:  #()));;;
      (if: (![#SelectDir] "dir1") = SelectSend
      then
        (if: let: "$a0" := (!["T1"] "val1") in
        let: "$a1" := #false in
        (method_call #(ptrT.id Channel.id) #"TrySend"%go (![#ptrT] "ch1") "T1") "$a0" "$a1"
        then return: (#(W64 0), !["T1"] "zero1", !["T2"] "zero2", #false)
        else do:  #())
      else
        let: "ok" := (mem.alloc (type.zero_val #boolT)) in
        let: "recv_val" := (mem.alloc (type.zero_val "T1")) in
        let: "selected" := (mem.alloc (type.zero_val #boolT)) in
        let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := #false in
        (method_call #(ptrT.id Channel.id) #"TryReceive"%go (![#ptrT] "ch1") "T1") "$a0") in
        let: "$r0" := "$ret0" in
        let: "$r1" := "$ret1" in
        let: "$r2" := "$ret2" in
        do:  ("selected" <-[#boolT] "$r0");;;
        do:  ("recv_val" <-["T1"] "$r1");;;
        do:  ("ok" <-[#boolT] "$r2");;;
        (if: ![#boolT] "selected"
        then return: (#(W64 0), !["T1"] "recv_val", !["T2"] "zero2", ![#boolT] "ok")
        else do:  #())));;;
    return: (#(W64 2), !["T1"] "zero1", !["T2"] "zero2", #false)).

Definition BlockingSelect3 : go_string := "github.com/goose-lang/goose/model/channel.BlockingSelect3"%go.

(* go: channel.go:429:6 *)
Definition BlockingSelect3ⁱᵐᵖˡ : val :=
  λ: "T1" "T2" "T3" "ch1" "dir1" "val1" "ch2" "dir2" "val2" "ch3" "dir3" "val3",
    exception_do (let: "val3" := (mem.alloc "val3") in
    let: "dir3" := (mem.alloc "dir3") in
    let: "ch3" := (mem.alloc "ch3") in
    let: "val2" := (mem.alloc "val2") in
    let: "dir2" := (mem.alloc "dir2") in
    let: "ch2" := (mem.alloc "ch2") in
    let: "val1" := (mem.alloc "val1") in
    let: "dir1" := (mem.alloc "dir1") in
    let: "ch1" := (mem.alloc "ch1") in
    let: "zero1" := (mem.alloc (type.zero_val "T1")) in
    let: "zero2" := (mem.alloc (type.zero_val "T2")) in
    let: "zero3" := (mem.alloc (type.zero_val "T3")) in
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "r" := (mem.alloc (type.zero_val #uint64T)) in
      let: "$r0" := (((func_call #primitive.RandomUint64) #()) `rem` #(W64 3)) in
      do:  ("r" <-[#uint64T] "$r0");;;
      (if: (![#uint64T] "r") = #(W64 0)
      then
        (if: (![#SelectDir] "dir1") = SelectSend
        then
          (if: let: "$a0" := (!["T1"] "val1") in
          let: "$a1" := #true in
          (method_call #(ptrT.id Channel.id) #"TrySend"%go (![#ptrT] "ch1") "T1") "$a0" "$a1"
          then return: (#(W64 0), !["T1"] "zero1", !["T2"] "zero2", !["T3"] "zero3", #false)
          else do:  #())
        else
          let: "ok" := (mem.alloc (type.zero_val #boolT)) in
          let: "recv_val" := (mem.alloc (type.zero_val "T1")) in
          let: "selected" := (mem.alloc (type.zero_val #boolT)) in
          let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := #true in
          (method_call #(ptrT.id Channel.id) #"TryReceive"%go (![#ptrT] "ch1") "T1") "$a0") in
          let: "$r0" := "$ret0" in
          let: "$r1" := "$ret1" in
          let: "$r2" := "$ret2" in
          do:  ("selected" <-[#boolT] "$r0");;;
          do:  ("recv_val" <-["T1"] "$r1");;;
          do:  ("ok" <-[#boolT] "$r2");;;
          (if: ![#boolT] "selected"
          then return: (#(W64 0), !["T1"] "recv_val", !["T2"] "zero2", !["T3"] "zero3", ![#boolT] "ok")
          else do:  #()))
      else
        (if: (![#uint64T] "r") = #(W64 1)
        then
          (if: (![#SelectDir] "dir2") = SelectSend
          then
            (if: let: "$a0" := (!["T2"] "val2") in
            let: "$a1" := #true in
            (method_call #(ptrT.id Channel.id) #"TrySend"%go (![#ptrT] "ch2") "T2") "$a0" "$a1"
            then return: (#(W64 1), !["T1"] "zero1", !["T2"] "zero2", !["T3"] "zero3", #false)
            else do:  #())
          else
            let: "ok" := (mem.alloc (type.zero_val #boolT)) in
            let: "recv_val" := (mem.alloc (type.zero_val "T2")) in
            let: "selected" := (mem.alloc (type.zero_val #boolT)) in
            let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := #true in
            (method_call #(ptrT.id Channel.id) #"TryReceive"%go (![#ptrT] "ch2") "T2") "$a0") in
            let: "$r0" := "$ret0" in
            let: "$r1" := "$ret1" in
            let: "$r2" := "$ret2" in
            do:  ("selected" <-[#boolT] "$r0");;;
            do:  ("recv_val" <-["T2"] "$r1");;;
            do:  ("ok" <-[#boolT] "$r2");;;
            (if: ![#boolT] "selected"
            then return: (#(W64 1), !["T1"] "zero1", !["T2"] "recv_val", !["T3"] "zero3", ![#boolT] "ok")
            else do:  #()))
        else
          (if: (![#SelectDir] "dir3") = SelectSend
          then
            (if: let: "$a0" := (!["T3"] "val3") in
            let: "$a1" := #true in
            (method_call #(ptrT.id Channel.id) #"TrySend"%go (![#ptrT] "ch3") "T3") "$a0" "$a1"
            then return: (#(W64 2), !["T1"] "zero1", !["T2"] "zero2", !["T3"] "zero3", #false)
            else do:  #())
          else
            let: "ok" := (mem.alloc (type.zero_val #boolT)) in
            let: "recv_val" := (mem.alloc (type.zero_val "T3")) in
            let: "selected" := (mem.alloc (type.zero_val #boolT)) in
            let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := #true in
            (method_call #(ptrT.id Channel.id) #"TryReceive"%go (![#ptrT] "ch3") "T3") "$a0") in
            let: "$r0" := "$ret0" in
            let: "$r1" := "$ret1" in
            let: "$r2" := "$ret2" in
            do:  ("selected" <-[#boolT] "$r0");;;
            do:  ("recv_val" <-["T3"] "$r1");;;
            do:  ("ok" <-[#boolT] "$r2");;;
            (if: ![#boolT] "selected"
            then return: (#(W64 2), !["T1"] "zero1", !["T2"] "zero2", !["T3"] "recv_val", ![#boolT] "ok")
            else do:  #())))))).

Definition NonBlockingSelect3 : go_string := "github.com/goose-lang/goose/model/channel.NonBlockingSelect3"%go.

(* Non-blocking select with 3 cases
   Returns (caseIndex, received_value1, received_value2, received_value3, ok)
   caseIndex = 3 means no selection

   go: channel.go:482:6 *)
Definition NonBlockingSelect3ⁱᵐᵖˡ : val :=
  λ: "T1" "T2" "T3" "ch1" "dir1" "val1" "ch2" "dir2" "val2" "ch3" "dir3" "val3",
    exception_do (let: "val3" := (mem.alloc "val3") in
    let: "dir3" := (mem.alloc "dir3") in
    let: "ch3" := (mem.alloc "ch3") in
    let: "val2" := (mem.alloc "val2") in
    let: "dir2" := (mem.alloc "dir2") in
    let: "ch2" := (mem.alloc "ch2") in
    let: "val1" := (mem.alloc "val1") in
    let: "dir1" := (mem.alloc "dir1") in
    let: "ch1" := (mem.alloc "ch1") in
    let: "zero1" := (mem.alloc (type.zero_val "T1")) in
    let: "zero2" := (mem.alloc (type.zero_val "T2")) in
    let: "zero3" := (mem.alloc (type.zero_val "T3")) in
    let: "start" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (((func_call #primitive.RandomUint64) #()) `rem` #(W64 3)) in
    do:  ("start" <-[#uint64T] "$r0");;;
    (let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (for: (λ: <>, (![#uint64T] "i") < #(W64 3)); (λ: <>, do:  ("i" <-[#uint64T] ((![#uint64T] "i") + #(W64 1)))) := λ: <>,
      let: "caseIdx" := (mem.alloc (type.zero_val #uint64T)) in
      let: "$r0" := (((![#uint64T] "start") + (![#uint64T] "i")) `rem` #(W64 3)) in
      do:  ("caseIdx" <-[#uint64T] "$r0");;;
      (if: (![#uint64T] "caseIdx") = #(W64 0)
      then
        (if: (![#SelectDir] "dir1") = SelectSend
        then
          (if: let: "$a0" := (!["T1"] "val1") in
          let: "$a1" := #false in
          (method_call #(ptrT.id Channel.id) #"TrySend"%go (![#ptrT] "ch1") "T1") "$a0" "$a1"
          then return: (#(W64 0), !["T1"] "zero1", !["T2"] "zero2", !["T3"] "zero3", #false)
          else do:  #())
        else
          let: "ok" := (mem.alloc (type.zero_val #boolT)) in
          let: "recv_val" := (mem.alloc (type.zero_val "T1")) in
          let: "selected" := (mem.alloc (type.zero_val #boolT)) in
          let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := #false in
          (method_call #(ptrT.id Channel.id) #"TryReceive"%go (![#ptrT] "ch1") "T1") "$a0") in
          let: "$r0" := "$ret0" in
          let: "$r1" := "$ret1" in
          let: "$r2" := "$ret2" in
          do:  ("selected" <-[#boolT] "$r0");;;
          do:  ("recv_val" <-["T1"] "$r1");;;
          do:  ("ok" <-[#boolT] "$r2");;;
          (if: ![#boolT] "selected"
          then return: (#(W64 0), !["T1"] "recv_val", !["T2"] "zero2", !["T3"] "zero3", ![#boolT] "ok")
          else do:  #()))
      else
        (if: (![#uint64T] "caseIdx") = #(W64 1)
        then
          (if: (![#SelectDir] "dir2") = SelectSend
          then
            (if: let: "$a0" := (!["T2"] "val2") in
            let: "$a1" := #false in
            (method_call #(ptrT.id Channel.id) #"TrySend"%go (![#ptrT] "ch2") "T2") "$a0" "$a1"
            then return: (#(W64 1), !["T1"] "zero1", !["T2"] "zero2", !["T3"] "zero3", #false)
            else do:  #())
          else
            let: "ok" := (mem.alloc (type.zero_val #boolT)) in
            let: "recv_val" := (mem.alloc (type.zero_val "T2")) in
            let: "selected" := (mem.alloc (type.zero_val #boolT)) in
            let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := #false in
            (method_call #(ptrT.id Channel.id) #"TryReceive"%go (![#ptrT] "ch2") "T2") "$a0") in
            let: "$r0" := "$ret0" in
            let: "$r1" := "$ret1" in
            let: "$r2" := "$ret2" in
            do:  ("selected" <-[#boolT] "$r0");;;
            do:  ("recv_val" <-["T2"] "$r1");;;
            do:  ("ok" <-[#boolT] "$r2");;;
            (if: ![#boolT] "selected"
            then return: (#(W64 1), !["T1"] "zero1", !["T2"] "recv_val", !["T3"] "zero3", ![#boolT] "ok")
            else do:  #()))
        else
          (if: (![#SelectDir] "dir3") = SelectSend
          then
            (if: let: "$a0" := (!["T3"] "val3") in
            let: "$a1" := #false in
            (method_call #(ptrT.id Channel.id) #"TrySend"%go (![#ptrT] "ch3") "T3") "$a0" "$a1"
            then return: (#(W64 2), !["T1"] "zero1", !["T2"] "zero2", !["T3"] "zero3", #false)
            else do:  #())
          else
            let: "ok" := (mem.alloc (type.zero_val #boolT)) in
            let: "recv_val" := (mem.alloc (type.zero_val "T3")) in
            let: "selected" := (mem.alloc (type.zero_val #boolT)) in
            let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := #false in
            (method_call #(ptrT.id Channel.id) #"TryReceive"%go (![#ptrT] "ch3") "T3") "$a0") in
            let: "$r0" := "$ret0" in
            let: "$r1" := "$ret1" in
            let: "$r2" := "$ret2" in
            do:  ("selected" <-[#boolT] "$r0");;;
            do:  ("recv_val" <-["T3"] "$r1");;;
            do:  ("ok" <-[#boolT] "$r2");;;
            (if: ![#boolT] "selected"
            then return: (#(W64 2), !["T1"] "zero1", !["T2"] "zero2", !["T3"] "recv_val", ![#boolT] "ok")
            else do:  #()))))));;;
    return: (#(W64 3), !["T1"] "zero1", !["T2"] "zero2", !["T3"] "zero3", #false)).

Definition vars' : list (go_string * go_type) := [].

Definition functions' : list (go_string * val) := [(NewChannelRef, NewChannelRefⁱᵐᵖˡ); (NonBlockingSelect1, NonBlockingSelect1ⁱᵐᵖˡ); (BlockingSelect2, BlockingSelect2ⁱᵐᵖˡ); (NonBlockingSelect2, NonBlockingSelect2ⁱᵐᵖˡ); (BlockingSelect3, BlockingSelect3ⁱᵐᵖˡ); (NonBlockingSelect3, NonBlockingSelect3ⁱᵐᵖˡ)].

Definition msets' : list (go_string * (list (go_string * val))) := [(OfferState.id, []); (ptrT.id OfferState.id, []); (Channel.id, []); (ptrT.id Channel.id, [("Cap"%go, Channel__Capⁱᵐᵖˡ); ("Close"%go, Channel__Closeⁱᵐᵖˡ); ("Iter"%go, Channel__Iterⁱᵐᵖˡ); ("Len"%go, Channel__Lenⁱᵐᵖˡ); ("Receive"%go, Channel__Receiveⁱᵐᵖˡ); ("ReceiveDiscardOk"%go, Channel__ReceiveDiscardOkⁱᵐᵖˡ); ("Send"%go, Channel__Sendⁱᵐᵖˡ); ("TryClose"%go, Channel__TryCloseⁱᵐᵖˡ); ("TryReceive"%go, Channel__TryReceiveⁱᵐᵖˡ); ("TrySend"%go, Channel__TrySendⁱᵐᵖˡ)]); (SelectDir.id, []); (ptrT.id SelectDir.id, [])].

#[global] Instance info' : PkgInfo channel.channel :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [code.sync.sync; code.github_com.goose_lang.primitive.primitive];
  |}.

Definition initialize' : val :=
  λ: <>,
    package.init #channel.channel (λ: <>,
      exception_do (do:  (primitive.initialize' #());;;
      do:  (sync.initialize' #());;;
      do:  (package.alloc channel.channel #()))
      ).

End code.
End channel.
