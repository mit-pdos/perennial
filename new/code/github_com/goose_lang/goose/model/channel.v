(* autogenerated from github.com/goose-lang/goose/model/channel *)
From New.golang Require Import defn.
Require Export New.code.github_com.goose_lang.std.std_core.
Require Export New.code.sync.

Definition channel : go_string := "github.com/goose-lang/goose/model/channel".

Module channel.
Section code.
Context `{ffi_syntax}.


Definition ChannelState : go_type := uint64T.

Definition start : expr := #(W64 0).

Definition receiver_ready : expr := #(W64 1).

Definition sender_ready : expr := #(W64 2).

Definition receiver_done : expr := #(W64 3).

Definition sender_done : expr := #(W64 4).

Definition closed : expr := #(W64 5).

Definition Channel : val :=
  λ: "T", type.structT [
    (#"lock"%go, #ptrT);
    (#"state"%go, #ChannelState);
    (#"buffer"%go, #sliceT);
    (#"first"%go, #uint64T);
    (#"count"%go, #uint64T);
    (#"v"%go, "T")
  ].

(* buffer_size = 0 is an unbuffered channel

   go: channel.go:36:6 *)
Definition NewChannelRef : val :=
  rec: "NewChannelRef" "T" "buffer_size" :=
    exception_do (let: "buffer_size" := (mem.alloc "buffer_size") in
    return: (mem.alloc (let: "$buffer" := (slice.make2 "T" (![#uint64T] "buffer_size")) in
     let: "$lock" := (mem.alloc (type.zero_val #sync.Mutex)) in
     let: "$first" := #(W64 0) in
     let: "$count" := #(W64 0) in
     let: "$state" := start in
     struct.make (Channel "T") [{
       "lock" ::= "$lock";
       "state" ::= "$state";
       "buffer" ::= "$buffer";
       "first" ::= "$first";
       "count" ::= "$count";
       "v" ::= type.zero_val "T"
     }]))).

Definition SelectDir : go_type := uint64T.

Definition SelectCase : val :=
  λ: "T", type.structT [
    (#"channel"%go, #ptrT);
    (#"dir"%go, #SelectDir);
    (#"Value"%go, "T");
    (#"Ok"%go, #boolT)
  ].

(* case Chan <- Send *)
Definition SelectSend : expr := #(W64 0).

(* c.Send(val)

   is equivalent to:

   c <- val

   go: channel.go:51:22 *)
Definition Channel__Send : val :=
  rec: "Channel__Send" "c" "T" "val" :=
    exception_do (let: "c" := (mem.alloc "c") in
    let: "val" := (mem.alloc "val") in
    (if: (![#ptrT] "c") = #null
    then
      (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
        do:  #())
    else do:  #());;;
    let: "send_case" := (mem.alloc (type.zero_val (SelectCase "T"))) in
    let: "$r0" := (let: "$channel" := (![#ptrT] "c") in
    let: "$dir" := SelectSend in
    let: "$Value" := (!["T"] "val") in
    struct.make (SelectCase "T") [{
      "channel" ::= "$channel";
      "dir" ::= "$dir";
      "Value" ::= "$Value";
      "Ok" ::= type.zero_val #boolT
    }]) in
    do:  ("send_case" <-[SelectCase "T"] "$r0");;;
    do:  (let: "$a0" := "send_case" in
    let: "$a1" := #true in
    ((func_call #channel.channel #"Select1"%go) "T") "$a0" "$a1")).

(* Equivalent to:
   value, ok := <-c
   Notably, this requires the user to consume the ok bool which is not actually required with Go
   channels. This should be able to be solved by adding an overload wrapper that discards the ok
   bool.

   go: channel.go:75:22 *)
Definition Channel__Receive : val :=
  rec: "Channel__Receive" "c" "T" <> :=
    exception_do (let: "c" := (mem.alloc "c") in
    (if: (![#ptrT] "c") = #null
    then
      (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
        do:  #())
    else do:  #());;;
    let: "recvCase" := (mem.alloc (type.zero_val (SelectCase "T"))) in
    let: "$r0" := (let: "$a0" := (![#ptrT] "c") in
    ((func_call #channel.channel #"NewRecvCase"%go) "T") "$a0") in
    do:  ("recvCase" <-[SelectCase "T"] "$r0");;;
    do:  (let: "$a0" := "recvCase" in
    let: "$a1" := #true in
    ((func_call #channel.channel #"Select1"%go) "T") "$a0" "$a1");;;
    return: (!["T"] (struct.field_ref (SelectCase "T") #"Value"%go "recvCase"), ![#boolT] (struct.field_ref (SelectCase "T") #"Ok"%go "recvCase"))).

(* This is a non-blocking attempt at closing. The only reason close blocks ever is because there
   may be successful exchanges that need to complete, which is equivalent to the go runtime where
   the closer must still obtain the channel's lock

   go: channel.go:95:22 *)
Definition Channel__TryClose : val :=
  rec: "Channel__TryClose" "c" "T" <> :=
    exception_do (let: "c" := (mem.alloc "c") in
    (if: (![#ChannelState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = closed
    then
      do:  (let: "$a0" := (interface.make #""%go #"string"%go #"close of closed channel"%go) in
      Panic "$a0")
    else do:  #());;;
    (if: ((![#ChannelState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) ≠ receiver_done) && ((![#ChannelState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) ≠ sender_done)
    then
      let: "$r0" := closed in
      do:  ((struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c")) <-[#ChannelState] "$r0");;;
      return: (#true)
    else do:  #());;;
    return: (#false)).

(* c.Close()

   is equivalent to:

   close(c)

   go: channel.go:113:22 *)
Definition Channel__Close : val :=
  rec: "Channel__Close" "c" "T" <> :=
    exception_do (let: "c" := (mem.alloc "c") in
    (if: (![#ptrT] "c") = #null
    then
      do:  (let: "$a0" := (interface.make #""%go #"string"%go #"close of nil channel"%go) in
      Panic "$a0")
    else do:  #());;;
    let: "done" := (mem.alloc (type.zero_val #boolT)) in
    let: "$r0" := #false in
    do:  ("done" <-[#boolT] "$r0");;;
    (for: (λ: <>, (~ (![#boolT] "done"))); (λ: <>, Skip) := λ: <>,
      do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
      let: "$r0" := ((method_call #channel.channel #"Channel'ptr" #"TryClose" (![#ptrT] "c") "T") #()) in
      do:  ("done" <-[#boolT] "$r0");;;
      do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #()))).

(* v := c.ReceiveDiscardOk

   is equivalent to:
   v := c<-
   It seems like Go requires ignored return values to be annotated with _ but channels don't
   require this so this will need to be translated.

   go: channel.go:131:22 *)
Definition Channel__ReceiveDiscardOk : val :=
  rec: "Channel__ReceiveDiscardOk" "c" "T" <> :=
    exception_do (let: "c" := (mem.alloc "c") in
    let: "return_val" := (mem.alloc (type.zero_val "T")) in
    let: ("$ret0", "$ret1") := ((method_call #channel.channel #"Channel'ptr" #"Receive" (![#ptrT] "c") "T") #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("return_val" <-["T"] "$r0");;;
    do:  "$r1";;;
    return: (!["T"] "return_val")).

(* If there is a value available in the buffer, consume it, otherwise, don't select.

   go: channel.go:138:22 *)
Definition Channel__BufferedTryReceiveLocked : val :=
  rec: "Channel__BufferedTryReceiveLocked" "c" "T" <> :=
    exception_do (let: "c" := (mem.alloc "c") in
    let: "v" := (mem.alloc (type.zero_val "T")) in
    (if: (![#uint64T] (struct.field_ref (Channel "T") #"count"%go (![#ptrT] "c"))) > #(W64 0)
    then
      let: "$r0" := (!["T"] (slice.elem_ref "T" (![#sliceT] (struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c"))) (![#uint64T] (struct.field_ref (Channel "T") #"first"%go (![#ptrT] "c"))))) in
      do:  ("v" <-["T"] "$r0");;;
      let: "$r0" := (((![#uint64T] (struct.field_ref (Channel "T") #"first"%go (![#ptrT] "c"))) + #(W64 1)) `rem` (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c"))) in
      slice.len "$a0"))) in
      do:  ((struct.field_ref (Channel "T") #"first"%go (![#ptrT] "c")) <-[#uint64T] "$r0");;;
      do:  ((struct.field_ref (Channel "T") #"count"%go (![#ptrT] "c")) <-[#uint64T] ((![#uint64T] (struct.field_ref (Channel "T") #"count"%go (![#ptrT] "c"))) - #(W64 1)));;;
      return: (#true, !["T"] "v", #true)
    else do:  #());;;
    (if: (![#ChannelState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = closed
    then return: (#true, !["T"] "v", #false)
    else do:  #());;;
    return: (#false, !["T"] "v", #true)).

(* go: channel.go:152:22 *)
Definition Channel__BufferedTryReceive : val :=
  rec: "Channel__BufferedTryReceive" "c" "T" <> :=
    exception_do (let: "c" := (mem.alloc "c") in
    do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
    let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "return_val" := (mem.alloc (type.zero_val "T")) in
    let: "selected" := (mem.alloc (type.zero_val #boolT)) in
    let: (("$ret0", "$ret1"), "$ret2") := ((method_call #channel.channel #"Channel'ptr" #"BufferedTryReceiveLocked" (![#ptrT] "c") "T") #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("selected" <-[#boolT] "$r0");;;
    do:  ("return_val" <-["T"] "$r1");;;
    do:  ("ok" <-[#boolT] "$r2");;;
    do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
    return: (![#boolT] "selected", !["T"] "return_val", ![#boolT] "ok")).

Definition ReceiverState : go_type := uint64T.

(* Receiver found a waiting sender *)
Definition ReceiverCompletedWithSender : expr := #(W64 0).

(* Receiver made an offer (no sender waiting) *)
Definition ReceiverMadeOffer : expr := #(W64 1).

(* Receiver saw that the channel was closed *)
Definition ReceiverObservedClosed : expr := #(W64 2).

(* Invalid state for receiving *)
Definition ReceiverCannotProceed : expr := #(W64 3).

(* go: channel.go:168:22 *)
Definition Channel__ReceiverCompleteOrOffer : val :=
  rec: "Channel__ReceiverCompleteOrOffer" "c" "T" <> :=
    exception_do (let: "c" := (mem.alloc "c") in
    (if: (![#ChannelState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = sender_ready
    then
      let: "$r0" := receiver_done in
      do:  ((struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c")) <-[#ChannelState] "$r0");;;
      return: (ReceiverCompletedWithSender)
    else do:  #());;;
    (if: (![#ChannelState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = start
    then
      let: "$r0" := receiver_ready in
      do:  ((struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c")) <-[#ChannelState] "$r0");;;
      return: (ReceiverMadeOffer)
    else do:  #());;;
    (if: (![#ChannelState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = closed
    then return: (ReceiverObservedClosed)
    else do:  #());;;
    return: (ReceiverCannotProceed)).

Definition OfferResult : go_type := uint64T.

(* Offer was rescinded (other party didn't arrive in time) *)
Definition OfferRescinded : expr := #(W64 0).

(* Other party responded to our offer *)
Definition CompletedExchange : expr := #(W64 1).

(* Unexpected state, indicates model bugs. *)
Definition CloseInterruptedOffer : expr := #(W64 2).

(* go: channel.go:196:22 *)
Definition Channel__ReceiverCompleteOrRescindOffer : val :=
  rec: "Channel__ReceiverCompleteOrRescindOffer" "c" "T" <> :=
    exception_do (let: "c" := (mem.alloc "c") in
    (if: (![#ChannelState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = closed
    then return: (CloseInterruptedOffer)
    else do:  #());;;
    (if: (![#ChannelState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = receiver_ready
    then
      let: "$r0" := start in
      do:  ((struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c")) <-[#ChannelState] "$r0");;;
      return: (OfferRescinded)
    else do:  #());;;
    (if: (![#ChannelState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = sender_done
    then
      let: "$r0" := start in
      do:  ((struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c")) <-[#ChannelState] "$r0");;;
      return: (CompletedExchange)
    else do:  #());;;
    do:  (let: "$a0" := (interface.make #""%go #"string"%go #"Invalid state transition with open receive offer"%go) in
    Panic "$a0")).

(* go: channel.go:214:22 *)
Definition Channel__UnbufferedTryReceive : val :=
  rec: "Channel__UnbufferedTryReceive" "c" "T" <> :=
    exception_do (let: "c" := (mem.alloc "c") in
    let: "local_val" := (mem.alloc (type.zero_val "T")) in
    do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
    let: "try_select" := (mem.alloc (type.zero_val #ReceiverState)) in
    let: "$r0" := ((method_call #channel.channel #"Channel'ptr" #"ReceiverCompleteOrOffer" (![#ptrT] "c") "T") #()) in
    do:  ("try_select" <-[#ReceiverState] "$r0");;;
    let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "$r0" := (~ ((![#ReceiverState] "try_select") = ReceiverObservedClosed)) in
    do:  ("ok" <-[#boolT] "$r0");;;
    let: "selected" := (mem.alloc (type.zero_val #boolT)) in
    let: "$r0" := (((![#ReceiverState] "try_select") = ReceiverCompletedWithSender) || (~ (![#boolT] "ok"))) in
    do:  ("selected" <-[#boolT] "$r0");;;
    (if: ![#boolT] "selected"
    then
      let: "$r0" := (!["T"] (struct.field_ref (Channel "T") #"v"%go (![#ptrT] "c"))) in
      do:  ("local_val" <-["T"] "$r0")
    else do:  #());;;
    do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
    (if: (![#ReceiverState] "try_select") = ReceiverMadeOffer
    then
      do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
      let: "offer_result" := (mem.alloc (type.zero_val #OfferResult)) in
      let: "$r0" := ((method_call #channel.channel #"Channel'ptr" #"ReceiverCompleteOrRescindOffer" (![#ptrT] "c") "T") #()) in
      do:  ("offer_result" <-[#OfferResult] "$r0");;;
      (if: (![#OfferResult] "offer_result") = CompletedExchange
      then
        let: "$r0" := (!["T"] (struct.field_ref (Channel "T") #"v"%go (![#ptrT] "c"))) in
        do:  ("local_val" <-["T"] "$r0");;;
        let: "$r0" := #true in
        do:  ("selected" <-[#boolT] "$r0")
      else do:  #());;;
      do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #())
    else do:  #());;;
    return: (![#boolT] "selected", !["T"] "local_val", ![#boolT] "ok")).

(* Non-blocking receive function used for select statements. Blocking receive is modeled as
   a single blocking select statement which amounts to a for loop until selected.

   go: channel.go:246:22 *)
Definition Channel__TryReceive : val :=
  rec: "Channel__TryReceive" "c" "T" <> :=
    exception_do (let: "c" := (mem.alloc "c") in
    (if: (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c"))) in
    slice.len "$a0")) > #(W64 0)
    then
      let: (("$ret0", "$ret1"), "$ret2") := (((method_call #channel.channel #"Channel'ptr" #"BufferedTryReceive" (![#ptrT] "c") "T") #())) in
      return: ("$ret0", "$ret1", "$ret2")
    else
      let: (("$ret0", "$ret1"), "$ret2") := (((method_call #channel.channel #"Channel'ptr" #"UnbufferedTryReceive" (![#ptrT] "c") "T") #())) in
      return: ("$ret0", "$ret1", "$ret2"))).

Definition SenderState : go_type := uint64T.

(* Sender found a waiting receiver *)
Definition SenderCompletedWithReceiver : expr := #(W64 0).

(* Sender made an offer (no receiver waiting) *)
Definition SenderMadeOffer : expr := #(W64 1).

(* Exchange in progress, don't select *)
Definition SenderCannotProceed : expr := #(W64 2).

(* go: channel.go:262:22 *)
Definition Channel__SenderCompleteOrOffer : val :=
  rec: "Channel__SenderCompleteOrOffer" "c" "T" "val" :=
    exception_do (let: "c" := (mem.alloc "c") in
    let: "val" := (mem.alloc "val") in
    (if: (![#ChannelState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = closed
    then
      do:  (let: "$a0" := (interface.make #""%go #"string"%go #"send on closed channel"%go) in
      Panic "$a0")
    else do:  #());;;
    (if: (![#ChannelState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = receiver_ready
    then
      let: "$r0" := sender_done in
      do:  ((struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c")) <-[#ChannelState] "$r0");;;
      let: "$r0" := (!["T"] "val") in
      do:  ((struct.field_ref (Channel "T") #"v"%go (![#ptrT] "c")) <-["T"] "$r0");;;
      return: (SenderCompletedWithReceiver)
    else do:  #());;;
    (if: (![#ChannelState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = start
    then
      let: "$r0" := sender_ready in
      do:  ((struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c")) <-[#ChannelState] "$r0");;;
      let: "$r0" := (!["T"] "val") in
      do:  ((struct.field_ref (Channel "T") #"v"%go (![#ptrT] "c")) <-["T"] "$r0");;;
      return: (SenderMadeOffer)
    else do:  #());;;
    return: (SenderCannotProceed)).

(* go: channel.go:283:22 *)
Definition Channel__SenderCheckOfferResult : val :=
  rec: "Channel__SenderCheckOfferResult" "c" "T" <> :=
    exception_do (let: "c" := (mem.alloc "c") in
    (if: (![#ChannelState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = closed
    then
      do:  (let: "$a0" := (interface.make #""%go #"string"%go #"send on closed channel"%go) in
      Panic "$a0")
    else do:  #());;;
    (if: (![#ChannelState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = receiver_done
    then
      let: "$r0" := start in
      do:  ((struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c")) <-[#ChannelState] "$r0");;;
      return: (CompletedExchange)
    else do:  #());;;
    (if: (![#ChannelState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = sender_ready
    then
      let: "$r0" := start in
      do:  ((struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c")) <-[#ChannelState] "$r0");;;
      return: (OfferRescinded)
    else do:  #());;;
    do:  (let: "$a0" := (interface.make #""%go #"string"%go #"Invalid state transition with open receive offer"%go) in
    Panic "$a0")).

(* If the buffer has free space, push our value.

   go: channel.go:301:22 *)
Definition Channel__BufferedTrySend : val :=
  rec: "Channel__BufferedTrySend" "c" "T" "val" :=
    exception_do (let: "c" := (mem.alloc "c") in
    let: "val" := (mem.alloc "val") in
    (if: (![#ChannelState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = closed
    then
      do:  (let: "$a0" := (interface.make #""%go #"string"%go #"send on closed channel"%go) in
      Panic "$a0")
    else do:  #());;;
    (if: (![#uint64T] (struct.field_ref (Channel "T") #"count"%go (![#ptrT] "c"))) < (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c"))) in
    slice.len "$a0"))
    then
      let: "last" := (mem.alloc (type.zero_val #uint64T)) in
      let: "$r0" := (((![#uint64T] (struct.field_ref (Channel "T") #"first"%go (![#ptrT] "c"))) + (![#uint64T] (struct.field_ref (Channel "T") #"count"%go (![#ptrT] "c")))) `rem` (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c"))) in
      slice.len "$a0"))) in
      do:  ("last" <-[#uint64T] "$r0");;;
      let: "$r0" := (!["T"] "val") in
      do:  ((slice.elem_ref "T" (![#sliceT] (struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c"))) (![#uint64T] "last")) <-["T"] "$r0");;;
      do:  ((struct.field_ref (Channel "T") #"count"%go (![#ptrT] "c")) <-[#uint64T] ((![#uint64T] (struct.field_ref (Channel "T") #"count"%go (![#ptrT] "c"))) + #(W64 1)));;;
      return: (#true)
    else do:  #());;;
    return: (#false)).

(* Non-Blocking send operation for select statements. Blocking send and blocking select
   statements simply call this in a for loop until it returns true.

   go: channel.go:318:22 *)
Definition Channel__TrySend : val :=
  rec: "Channel__TrySend" "c" "T" "val" :=
    exception_do (let: "c" := (mem.alloc "c") in
    let: "val" := (mem.alloc "val") in
    let: "buffer_size" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c"))) in
    slice.len "$a0")) in
    do:  ("buffer_size" <-[#uint64T] "$r0");;;
    (if: (![#uint64T] "buffer_size") ≠ #(W64 0)
    then
      do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
      let: "sendResult" := (mem.alloc (type.zero_val #boolT)) in
      let: "$r0" := (let: "$a0" := (!["T"] "val") in
      (method_call #channel.channel #"Channel'ptr" #"BufferedTrySend" (![#ptrT] "c") "T") "$a0") in
      do:  ("sendResult" <-[#boolT] "$r0");;;
      do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
      return: (![#boolT] "sendResult")
    else do:  #());;;
    do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
    let: "senderState" := (mem.alloc (type.zero_val #SenderState)) in
    let: "$r0" := (let: "$a0" := (!["T"] "val") in
    (method_call #channel.channel #"Channel'ptr" #"SenderCompleteOrOffer" (![#ptrT] "c") "T") "$a0") in
    do:  ("senderState" <-[#SenderState] "$r0");;;
    do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
    (if: (![#SenderState] "senderState") = SenderMadeOffer
    then
      do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
      let: "offerResult" := (mem.alloc (type.zero_val #OfferResult)) in
      let: "$r0" := ((method_call #channel.channel #"Channel'ptr" #"SenderCheckOfferResult" (![#ptrT] "c") "T") #()) in
      do:  ("offerResult" <-[#OfferResult] "$r0");;;
      do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
      return: ((![#OfferResult] "offerResult") = CompletedExchange)
    else do:  #());;;
    return: ((![#SenderState] "senderState") = SenderCompletedWithReceiver)).

(* c.Len()

   is equivalent to:
   len(c)

   This might not be worth specifying since it is hard to make good use of channel length
   semantics.

   go: channel.go:354:22 *)
Definition Channel__Len : val :=
  rec: "Channel__Len" "c" "T" <> :=
    exception_do (let: "c" := (mem.alloc "c") in
    (if: (![#ptrT] "c") = #null
    then return: (#(W64 0))
    else do:  #());;;
    let: "chan_len" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("chan_len" <-[#uint64T] "$r0");;;
    do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
    let: "$r0" := (![#uint64T] (struct.field_ref (Channel "T") #"count"%go (![#ptrT] "c"))) in
    do:  ("chan_len" <-[#uint64T] "$r0");;;
    do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
    return: (![#uint64T] "chan_len")).

(* c.Cap()

   is equivalent to:
   cap(c)

   go: channel.go:369:22 *)
Definition Channel__Cap : val :=
  rec: "Channel__Cap" "c" "T" <> :=
    exception_do (let: "c" := (mem.alloc "c") in
    (if: (![#ptrT] "c") = #null
    then return: (#(W64 0))
    else do:  #());;;
    return: (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c"))) in
     slice.len "$a0"))).

(* case <-Chan: *)
Definition SelectRecv : expr := #(W64 1).

(* TrySelectAt attempts to select a specific case

   go: channel.go:396:6 *)
Definition TrySelectAt : val :=
  rec: "TrySelectAt" "T" "selectCase" :=
    exception_do (let: "selectCase" := (mem.alloc "selectCase") in
    (if: (![#ptrT] (struct.field_ref (SelectCase "T") #"channel"%go (![#ptrT] "selectCase"))) ≠ #null
    then
      return: (let: "$a0" := (![#ptrT] "selectCase") in
       ((func_call #channel.channel #"TrySelect"%go) "T") "$a0")
    else do:  #());;;
    return: (#false)).

(* TrySelectCase attempts to select a specific case at a given index
   Returns true if the case was selected, false otherwise

   go: channel.go:406:6 *)
Definition TrySelectCase : val :=
  rec: "TrySelectCase" "T1" "T2" "T3" "T4" "T5" "index" "case1" "case2" "case3" "case4" "case5" :=
    exception_do (let: "case5" := (mem.alloc "case5") in
    let: "case4" := (mem.alloc "case4") in
    let: "case3" := (mem.alloc "case3") in
    let: "case2" := (mem.alloc "case2") in
    let: "case1" := (mem.alloc "case1") in
    let: "index" := (mem.alloc "index") in
    (if: (![#uint64T] "index") = #(W64 0)
    then
      return: (let: "$a0" := (![#ptrT] "case1") in
       ((func_call #channel.channel #"TrySelectAt"%go) "T1") "$a0")
    else do:  #());;;
    (if: (![#uint64T] "index") = #(W64 1)
    then
      return: (let: "$a0" := (![#ptrT] "case2") in
       ((func_call #channel.channel #"TrySelectAt"%go) "T2") "$a0")
    else do:  #());;;
    (if: (![#uint64T] "index") = #(W64 2)
    then
      return: (let: "$a0" := (![#ptrT] "case3") in
       ((func_call #channel.channel #"TrySelectAt"%go) "T3") "$a0")
    else do:  #());;;
    (if: (![#uint64T] "index") = #(W64 3)
    then
      return: (let: "$a0" := (![#ptrT] "case4") in
       ((func_call #channel.channel #"TrySelectAt"%go) "T4") "$a0")
    else do:  #());;;
    (if: (![#uint64T] "index") = #(W64 4)
    then
      return: (let: "$a0" := (![#ptrT] "case5") in
       ((func_call #channel.channel #"TrySelectAt"%go) "T5") "$a0")
    else do:  #());;;
    return: (#false)).

(* The value representing the default case *)
Definition DefaultCase : expr := #(W64 5).

(* TryCasesInOrder attempts to select one of the cases in the given order
   Returns the index of the selected case, or 5 if none was selected.
   I would probably return a sentinel value of 1 here but we are limited to
   uint64 and the index after the last makes sense since that would be where the
   default block is.

   go: channel.go:443:6 *)
Definition TryCasesInOrder : val :=
  rec: "TryCasesInOrder" "T1" "T2" "T3" "T4" "T5" "order" "case1" "case2" "case3" "case4" "case5" :=
    exception_do (let: "case5" := (mem.alloc "case5") in
    let: "case4" := (mem.alloc "case4") in
    let: "case3" := (mem.alloc "case3") in
    let: "case2" := (mem.alloc "case2") in
    let: "case1" := (mem.alloc "case1") in
    let: "order" := (mem.alloc "order") in
    let: "select_case" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (s_to_w64 (let: "$a0" := (![#sliceT] "order") in
    slice.len "$a0")) in
    do:  ("select_case" <-[#uint64T] "$r0");;;
    let: "$range" := (![#sliceT] "order") in
    (let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    slice.for_range #uint64T "$range" (λ: "$key" "$value",
      do:  ("i" <-[#uint64T] "$value");;;
      do:  "$key";;;
      (if: ((![#uint64T] "select_case") = (s_to_w64 (let: "$a0" := (![#sliceT] "order") in
      slice.len "$a0"))) && (let: "$a0" := (![#uint64T] "i") in
      let: "$a1" := (![#ptrT] "case1") in
      let: "$a2" := (![#ptrT] "case2") in
      let: "$a3" := (![#ptrT] "case3") in
      let: "$a4" := (![#ptrT] "case4") in
      let: "$a5" := (![#ptrT] "case5") in
      ((func_call #channel.channel #"TrySelectCase"%go) "T1" "T2" "T3" "T4" "T5") "$a0" "$a1" "$a2" "$a3" "$a4" "$a5")
      then
        let: "$r0" := (![#uint64T] "i") in
        do:  ("select_case" <-[#uint64T] "$r0")
      else do:  #())));;;
    return: (![#uint64T] "select_case")).

(* MultiSelect performs a select operation on up to 5 cases.
   This is the largest number of cases the model will support, at least for now.
   Because of the fact that nil channels are not selectable, we can simply make
   this function never select a case with a nil channel and take advantage of
   this behavior to model selects with fewer than 5 statements by simply passing
   in "empty cases" that have a nil channel. This will allow verifying only the
   5 statement case with a thin wrapper for the smaller ones.

   Cases with nil channels are ignored.
   This function returns the index of the selected case.
   If blocking is true, keep trying to select until a select succeeds.
   If blocking is false, return 5. 5 is the equivalent of a default case
   in Go channels.

   go: channel.go:472:6 *)
Definition multiSelect : val :=
  rec: "multiSelect" "T1" "T2" "T3" "T4" "T5" "case1" "case2" "case3" "case4" "case5" "blocking" :=
    exception_do (let: "blocking" := (mem.alloc "blocking") in
    let: "case5" := (mem.alloc "case5") in
    let: "case4" := (mem.alloc "case4") in
    let: "case3" := (mem.alloc "case3") in
    let: "case2" := (mem.alloc "case2") in
    let: "case1" := (mem.alloc "case1") in
    let: "selected_case" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := DefaultCase in
    do:  ("selected_case" <-[#uint64T] "$r0");;;
    let: "order" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := #(W64 5) in
    (func_call #std_core.std_core #"Permutation"%go) "$a0") in
    do:  ("order" <-[#sliceT] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "$r0" := (let: "$a0" := (![#sliceT] "order") in
      let: "$a1" := (![#ptrT] "case1") in
      let: "$a2" := (![#ptrT] "case2") in
      let: "$a3" := (![#ptrT] "case3") in
      let: "$a4" := (![#ptrT] "case4") in
      let: "$a5" := (![#ptrT] "case5") in
      ((func_call #channel.channel #"TryCasesInOrder"%go) "T1" "T2" "T3" "T4" "T5") "$a0" "$a1" "$a2" "$a3" "$a4" "$a5") in
      do:  ("selected_case" <-[#uint64T] "$r0");;;
      (if: ((![#uint64T] "selected_case") ≠ DefaultCase) || (~ (![#boolT] "blocking"))
      then break: #()
      else do:  #()));;;
    return: (![#uint64T] "selected_case")).

(* Select1 performs a select operation on 1 case. This is used for Send and
   Receive as well, since these channel operations in Go are equivalent to
   a single case select statement with no default.

   go: channel.go:498:6 *)
Definition Select1 : val :=
  rec: "Select1" "T1" "case1" "blocking" :=
    exception_do (let: "blocking" := (mem.alloc "blocking") in
    let: "case1" := (mem.alloc "case1") in
    let: "emptyCase2" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (let: "$channel" := #null in
    struct.make (SelectCase #uint64T) [{
      "channel" ::= "$channel";
      "dir" ::= type.zero_val #SelectDir;
      "Value" ::= type.zero_val #uint64T;
      "Ok" ::= type.zero_val #boolT
    }])) in
    do:  ("emptyCase2" <-[#ptrT] "$r0");;;
    let: "emptyCase3" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (let: "$channel" := #null in
    struct.make (SelectCase #uint64T) [{
      "channel" ::= "$channel";
      "dir" ::= type.zero_val #SelectDir;
      "Value" ::= type.zero_val #uint64T;
      "Ok" ::= type.zero_val #boolT
    }])) in
    do:  ("emptyCase3" <-[#ptrT] "$r0");;;
    let: "emptyCase4" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (let: "$channel" := #null in
    struct.make (SelectCase #uint64T) [{
      "channel" ::= "$channel";
      "dir" ::= type.zero_val #SelectDir;
      "Value" ::= type.zero_val #uint64T;
      "Ok" ::= type.zero_val #boolT
    }])) in
    do:  ("emptyCase4" <-[#ptrT] "$r0");;;
    let: "emptyCase5" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (let: "$channel" := #null in
    struct.make (SelectCase #uint64T) [{
      "channel" ::= "$channel";
      "dir" ::= type.zero_val #SelectDir;
      "Value" ::= type.zero_val #uint64T;
      "Ok" ::= type.zero_val #boolT
    }])) in
    do:  ("emptyCase5" <-[#ptrT] "$r0");;;
    return: (let: "$a0" := (![#ptrT] "case1") in
     let: "$a1" := (![#ptrT] "emptyCase2") in
     let: "$a2" := (![#ptrT] "emptyCase3") in
     let: "$a3" := (![#ptrT] "emptyCase4") in
     let: "$a4" := (![#ptrT] "emptyCase5") in
     let: "$a5" := (![#boolT] "blocking") in
     ((func_call #channel.channel #"multiSelect"%go) "T1" #uint64T #uint64T #uint64T #uint64T) "$a0" "$a1" "$a2" "$a3" "$a4" "$a5")).

(* Select2 performs a select operation on 2 cases.

   go: channel.go:518:6 *)
Definition Select2 : val :=
  rec: "Select2" "T1" "T2" "case1" "case2" "blocking" :=
    exception_do (let: "blocking" := (mem.alloc "blocking") in
    let: "case2" := (mem.alloc "case2") in
    let: "case1" := (mem.alloc "case1") in
    let: "emptyCase3" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (struct.make (SelectCase #uint64T) [{
      "channel" ::= type.zero_val #ptrT;
      "dir" ::= type.zero_val #SelectDir;
      "Value" ::= type.zero_val #uint64T;
      "Ok" ::= type.zero_val #boolT
    }])) in
    do:  ("emptyCase3" <-[#ptrT] "$r0");;;
    let: "emptyCase4" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (struct.make (SelectCase #uint64T) [{
      "channel" ::= type.zero_val #ptrT;
      "dir" ::= type.zero_val #SelectDir;
      "Value" ::= type.zero_val #uint64T;
      "Ok" ::= type.zero_val #boolT
    }])) in
    do:  ("emptyCase4" <-[#ptrT] "$r0");;;
    let: "emptyCase5" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (struct.make (SelectCase #uint64T) [{
      "channel" ::= type.zero_val #ptrT;
      "dir" ::= type.zero_val #SelectDir;
      "Value" ::= type.zero_val #uint64T;
      "Ok" ::= type.zero_val #boolT
    }])) in
    do:  ("emptyCase5" <-[#ptrT] "$r0");;;
    return: (let: "$a0" := (![#ptrT] "case1") in
     let: "$a1" := (![#ptrT] "case2") in
     let: "$a2" := (![#ptrT] "emptyCase3") in
     let: "$a3" := (![#ptrT] "emptyCase4") in
     let: "$a4" := (![#ptrT] "emptyCase5") in
     let: "$a5" := (![#boolT] "blocking") in
     ((func_call #channel.channel #"multiSelect"%go) "T1" "T2" #uint64T #uint64T #uint64T) "$a0" "$a1" "$a2" "$a3" "$a4" "$a5")).

(* Select3 performs a select operation on 3 cases.

   go: channel.go:538:6 *)
Definition Select3 : val :=
  rec: "Select3" "T1" "T2" "T3" "case1" "case2" "case3" "blocking" :=
    exception_do (let: "blocking" := (mem.alloc "blocking") in
    let: "case3" := (mem.alloc "case3") in
    let: "case2" := (mem.alloc "case2") in
    let: "case1" := (mem.alloc "case1") in
    let: "emptyCase4" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (struct.make (SelectCase #uint64T) [{
      "channel" ::= type.zero_val #ptrT;
      "dir" ::= type.zero_val #SelectDir;
      "Value" ::= type.zero_val #uint64T;
      "Ok" ::= type.zero_val #boolT
    }])) in
    do:  ("emptyCase4" <-[#ptrT] "$r0");;;
    let: "emptyCase5" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (struct.make (SelectCase #uint64T) [{
      "channel" ::= type.zero_val #ptrT;
      "dir" ::= type.zero_val #SelectDir;
      "Value" ::= type.zero_val #uint64T;
      "Ok" ::= type.zero_val #boolT
    }])) in
    do:  ("emptyCase5" <-[#ptrT] "$r0");;;
    return: (let: "$a0" := (![#ptrT] "case1") in
     let: "$a1" := (![#ptrT] "case2") in
     let: "$a2" := (![#ptrT] "case3") in
     let: "$a3" := (![#ptrT] "emptyCase4") in
     let: "$a4" := (![#ptrT] "emptyCase5") in
     let: "$a5" := (![#boolT] "blocking") in
     ((func_call #channel.channel #"multiSelect"%go) "T1" "T2" "T3" #uint64T #uint64T) "$a0" "$a1" "$a2" "$a3" "$a4" "$a5")).

(* Select4 performs a select operation on 4 cases.

   go: channel.go:558:6 *)
Definition Select4 : val :=
  rec: "Select4" "T1" "T2" "T3" "T4" "case1" "case2" "case3" "case4" "blocking" :=
    exception_do (let: "blocking" := (mem.alloc "blocking") in
    let: "case4" := (mem.alloc "case4") in
    let: "case3" := (mem.alloc "case3") in
    let: "case2" := (mem.alloc "case2") in
    let: "case1" := (mem.alloc "case1") in
    let: "emptyCase5" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (struct.make (SelectCase #uint64T) [{
      "channel" ::= type.zero_val #ptrT;
      "dir" ::= type.zero_val #SelectDir;
      "Value" ::= type.zero_val #uint64T;
      "Ok" ::= type.zero_val #boolT
    }])) in
    do:  ("emptyCase5" <-[#ptrT] "$r0");;;
    return: (let: "$a0" := (![#ptrT] "case1") in
     let: "$a1" := (![#ptrT] "case2") in
     let: "$a2" := (![#ptrT] "case3") in
     let: "$a3" := (![#ptrT] "case4") in
     let: "$a4" := (![#ptrT] "emptyCase5") in
     let: "$a5" := (![#boolT] "blocking") in
     ((func_call #channel.channel #"multiSelect"%go) "T1" "T2" "T3" "T4" #uint64T) "$a0" "$a1" "$a2" "$a3" "$a4" "$a5")).

(* Select5 is just an alias to MultiSelect for consistency in the API.

   go: channel.go:578:6 *)
Definition Select5 : val :=
  rec: "Select5" "T1" "T2" "T3" "T4" "T5" "case1" "case2" "case3" "case4" "case5" "blocking" :=
    exception_do (let: "blocking" := (mem.alloc "blocking") in
    let: "case5" := (mem.alloc "case5") in
    let: "case4" := (mem.alloc "case4") in
    let: "case3" := (mem.alloc "case3") in
    let: "case2" := (mem.alloc "case2") in
    let: "case1" := (mem.alloc "case1") in
    return: (let: "$a0" := (![#ptrT] "case1") in
     let: "$a1" := (![#ptrT] "case2") in
     let: "$a2" := (![#ptrT] "case3") in
     let: "$a3" := (![#ptrT] "case4") in
     let: "$a4" := (![#ptrT] "case5") in
     let: "$a5" := (![#boolT] "blocking") in
     ((func_call #channel.channel #"multiSelect"%go) "T1" "T2" "T3" "T4" "T5") "$a0" "$a1" "$a2" "$a3" "$a4" "$a5")).

(* Uses the applicable Try<Operation> function on the select case's channel. Default is always
   selectable so simply returns true.

   go: channel.go:597:6 *)
Definition TrySelect : val :=
  rec: "TrySelect" "T" "select_case" :=
    exception_do (let: "select_case" := (mem.alloc "select_case") in
    let: "channel" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (![#ptrT] (struct.field_ref (SelectCase "T") #"channel"%go (![#ptrT] "select_case"))) in
    do:  ("channel" <-[#ptrT] "$r0");;;
    (if: (![#ptrT] "channel") = #null
    then return: (#false)
    else do:  #());;;
    (if: (![#SelectDir] (struct.field_ref (SelectCase "T") #"dir"%go (![#ptrT] "select_case"))) = SelectSend
    then
      return: (let: "$a0" := (!["T"] (struct.field_ref (SelectCase "T") #"Value"%go (![#ptrT] "select_case"))) in
       (method_call #channel.channel #"Channel'ptr" #"TrySend" (![#ptrT] "channel") "T") "$a0")
    else do:  #());;;
    (if: (![#SelectDir] (struct.field_ref (SelectCase "T") #"dir"%go (![#ptrT] "select_case"))) = SelectRecv
    then
      let: "item" := (mem.alloc (type.zero_val "T")) in
      let: "ok" := (mem.alloc (type.zero_val #boolT)) in
      let: "selected" := (mem.alloc (type.zero_val #boolT)) in
      let: (("$ret0", "$ret1"), "$ret2") := ((method_call #channel.channel #"Channel'ptr" #"TryReceive" (![#ptrT] "channel") "T") #()) in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      let: "$r2" := "$ret2" in
      do:  ("selected" <-[#boolT] "$r0");;;
      do:  ("item" <-["T"] "$r1");;;
      do:  ("ok" <-[#boolT] "$r2");;;
      let: "$r0" := (!["T"] "item") in
      do:  ((struct.field_ref (SelectCase "T") #"Value"%go (![#ptrT] "select_case")) <-["T"] "$r0");;;
      let: "$r0" := (![#boolT] "ok") in
      do:  ((struct.field_ref (SelectCase "T") #"Ok"%go (![#ptrT] "select_case")) <-[#boolT] "$r0");;;
      return: (![#boolT] "selected")
    else do:  #());;;
    return: (#false)).

(* go: channel.go:621:6 *)
Definition NewSendCase : val :=
  rec: "NewSendCase" "T" "channel" "value" :=
    exception_do (let: "value" := (mem.alloc "value") in
    let: "channel" := (mem.alloc "channel") in
    return: (let: "$channel" := (![#ptrT] "channel") in
     let: "$dir" := SelectSend in
     let: "$Value" := (!["T"] "value") in
     struct.make (SelectCase "T") [{
       "channel" ::= "$channel";
       "dir" ::= "$dir";
       "Value" ::= "$Value";
       "Ok" ::= type.zero_val #boolT
     }])).

(* go: channel.go:629:6 *)
Definition NewRecvCase : val :=
  rec: "NewRecvCase" "T" "channel" :=
    exception_do (let: "channel" := (mem.alloc "channel") in
    return: (let: "$channel" := (![#ptrT] "channel") in
     let: "$dir" := SelectRecv in
     struct.make (SelectCase "T") [{
       "channel" ::= "$channel";
       "dir" ::= "$dir";
       "Value" ::= type.zero_val "T";
       "Ok" ::= type.zero_val #boolT
     }])).

Definition vars' : list (go_string * go_type) := [].

Definition functions' : list (go_string * val) := [("NewChannelRef"%go, NewChannelRef); ("TrySelectAt"%go, TrySelectAt); ("TrySelectCase"%go, TrySelectCase); ("TryCasesInOrder"%go, TryCasesInOrder); ("multiSelect"%go, multiSelect); ("Select1"%go, Select1); ("Select2"%go, Select2); ("Select3"%go, Select3); ("Select4"%go, Select4); ("Select5"%go, Select5); ("TrySelect"%go, TrySelect); ("NewSendCase"%go, NewSendCase); ("NewRecvCase"%go, NewRecvCase)].

Definition msets' : list (go_string * (list (go_string * val))) := [("ChannelState"%go, []); ("ChannelState'ptr"%go, []); ("Channel"%go, []); ("Channel'ptr"%go, [("BufferedTryReceive"%go, Channel__BufferedTryReceive); ("BufferedTryReceiveLocked"%go, Channel__BufferedTryReceiveLocked); ("BufferedTrySend"%go, Channel__BufferedTrySend); ("Cap"%go, Channel__Cap); ("Close"%go, Channel__Close); ("Len"%go, Channel__Len); ("Receive"%go, Channel__Receive); ("ReceiveDiscardOk"%go, Channel__ReceiveDiscardOk); ("ReceiverCompleteOrOffer"%go, Channel__ReceiverCompleteOrOffer); ("ReceiverCompleteOrRescindOffer"%go, Channel__ReceiverCompleteOrRescindOffer); ("Send"%go, Channel__Send); ("SenderCheckOfferResult"%go, Channel__SenderCheckOfferResult); ("SenderCompleteOrOffer"%go, Channel__SenderCompleteOrOffer); ("TryClose"%go, Channel__TryClose); ("TryReceive"%go, Channel__TryReceive); ("TrySend"%go, Channel__TrySend); ("UnbufferedTryReceive"%go, Channel__UnbufferedTryReceive)]); ("ReceiverState"%go, []); ("ReceiverState'ptr"%go, []); ("OfferResult"%go, []); ("OfferResult'ptr"%go, []); ("SenderState"%go, []); ("SenderState'ptr"%go, []); ("SelectDir"%go, []); ("SelectDir'ptr"%go, []); ("SelectCase"%go, []); ("SelectCase'ptr"%go, [])].

#[global] Instance info' : PkgInfo channel.channel :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [sync.sync; std_core.std_core];
  |}.

Definition initialize' : val :=
  rec: "initialize'" <> :=
    globals.package_init channel.channel (λ: <>,
      exception_do (do:  std_core.initialize';;;
      do:  sync.initialize')
      ).

End code.
End channel.
