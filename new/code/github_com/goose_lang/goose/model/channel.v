(* autogenerated from github.com/goose-lang/goose/model/channel *)
Require Export New.code.github_com.goose_lang.primitive.
Require Export New.code.sync.

From New.golang Require Import defn.
Definition channel : go_string := "github.com/goose-lang/goose/model/channel".

Module channel.

Module OfferState. Definition id : go_string := "github.com/goose-lang/goose/model/channel.OfferState"%go. End OfferState.
Module Channel. Definition id : go_string := "github.com/goose-lang/goose/model/channel.Channel"%go. End Channel.
Module SelectDir. Definition id : go_string := "github.com/goose-lang/goose/model/channel.SelectDir"%go. End SelectDir.
Module SelectCase. Definition id : go_string := "github.com/goose-lang/goose/model/channel.SelectCase"%go. End SelectCase.

Section code.
Context `{ffi_syntax}.


Definition OfferState : go_type := uint64T.

Definition idle : expr := #(W64 0).

Definition offer : expr := #(W64 1).

Definition accepted : expr := #(W64 2).

Definition closed : expr := #(W64 3).

Definition Channel : val :=
  λ: "T", type.structT [
    (#"lock"%go, #ptrT);
    (#"state"%go, #OfferState);
    (#"buffer"%go, #sliceT);
    (#"cap"%go, #uint64T);
    (#"v"%go, #ptrT)
  ].

Definition NewChannelRef : go_string := "github.com/goose-lang/goose/model/channel.NewChannelRef"%go.

(* buffer_size = 0 is an unbuffered channel

   go: channel.go:32:6 *)
Definition NewChannelRefⁱᵐᵖˡ : val :=
  λ: "T" "buffer_size",
    exception_do (let: "buffer_size" := (mem.alloc "buffer_size") in
    return: (mem.alloc (let: "$buffer" := (slice.make2 "T" #(W64 0)) in
     let: "$lock" := (mem.alloc (type.zero_val #sync.Mutex)) in
     let: "$cap" := (![#uint64T] "buffer_size") in
     let: "$state" := idle in
     struct.make (Channel "T") [{
       "lock" ::= "$lock";
       "state" ::= "$state";
       "buffer" ::= "$buffer";
       "cap" ::= "$cap";
       "v" ::= type.zero_val #ptrT
     }]))).

Definition Select1 : go_string := "github.com/goose-lang/goose/model/channel.Select1"%go.

Definition NewSendCase : go_string := "github.com/goose-lang/goose/model/channel.NewSendCase"%go.

(* c.Send(val)

   is equivalent to:

   c <- val

   go: channel.go:46:22 *)
Definition Channel__Sendⁱᵐᵖˡ : val :=
  λ: "c" "T" "val",
    exception_do (let: "c" := (mem.alloc "c") in
    let: "val" := (mem.alloc "val") in
    (if: (![#ptrT] "c") = #null
    then
      (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
        do:  #())
    else do:  #());;;
    let: "sendCase" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := (![#ptrT] "c") in
    let: "$a1" := (!["T"] "val") in
    ((func_call #NewSendCase) "T") "$a0" "$a1") in
    do:  ("sendCase" <-[#ptrT] "$r0");;;
    do:  (let: "$a0" := (![#ptrT] "sendCase") in
    let: "$a1" := #true in
    ((func_call #Select1) "T") "$a0" "$a1");;;
    return: (#());;;
    return: #()).

Definition SelectDir : go_type := uint64T.

Definition SelectCase : val :=
  λ: "T", type.structT [
    (#"channel"%go, #ptrT);
    (#"dir"%go, #SelectDir);
    (#"Value"%go, "T");
    (#"Ok"%go, #boolT)
  ].

Definition NewRecvCase : go_string := "github.com/goose-lang/goose/model/channel.NewRecvCase"%go.

(* Equivalent to:
   value, ok := <-c
   Notably, this requires the user to consume the ok bool which is not actually required with Go
   channels. This should be able to be solved by adding an overload wrapper that discards the ok
   bool.

   go: channel.go:67:22 *)
Definition Channel__Receiveⁱᵐᵖˡ : val :=
  λ: "c" "T" <>,
    exception_do (let: "c" := (mem.alloc "c") in
    (if: (![#ptrT] "c") = #null
    then
      (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
        do:  #())
    else do:  #());;;
    let: "recvCase" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := (![#ptrT] "c") in
    ((func_call #NewRecvCase) "T") "$a0") in
    do:  ("recvCase" <-[#ptrT] "$r0");;;
    do:  (let: "$a0" := (![#ptrT] "recvCase") in
    let: "$a1" := #true in
    ((func_call #Select1) "T") "$a0" "$a1");;;
    return: (!["T"] (struct.field_ref (SelectCase "T") #"Value"%go (![#ptrT] "recvCase")), ![#boolT] (struct.field_ref (SelectCase "T") #"Ok"%go (![#ptrT] "recvCase")))).

(* This is a non-blocking attempt at closing. The only reason close blocks ever is because there
   may be successful exchanges that need to complete, which is equivalent to the go runtime where
   the closer must still obtain the channel's lock

   go: channel.go:87:22 *)
Definition Channel__TryCloseⁱᵐᵖˡ : val :=
  λ: "c" "T" <>,
    exception_do (let: "c" := (mem.alloc "c") in
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
    (if: (![#OfferState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = closed
    then
      do:  (let: "$a0" := (interface.make #stringT.id #"close of closed channel"%go) in
      Panic "$a0")
    else do:  #());;;
    (if: (![#OfferState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = idle
    then
      let: "$r0" := closed in
      do:  ((struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c")) <-[#OfferState] "$r0");;;
      do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
      return: (#true)
    else do:  #());;;
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
    return: (#false)).

(* c.Close()

   is equivalent to:

   close(c)

   go: channel.go:108:22 *)
Definition Channel__Closeⁱᵐᵖˡ : val :=
  λ: "c" "T" <>,
    exception_do (let: "c" := (mem.alloc "c") in
    (if: (![#ptrT] "c") = #null
    then
      do:  (let: "$a0" := (interface.make #stringT.id #"close of nil channel"%go) in
      Panic "$a0")
    else do:  #());;;
    let: "done" := (mem.alloc (type.zero_val #boolT)) in
    let: "$r0" := #false in
    do:  ("done" <-[#boolT] "$r0");;;
    (for: (λ: <>, (~ (![#boolT] "done"))); (λ: <>, #()) := λ: <>,
      let: "$r0" := ((method_call #(ptrT.id Channel.id) #"TryClose"%go (![#ptrT] "c") "T") #()) in
      do:  ("done" <-[#boolT] "$r0"));;;
    return: #()).

(* v := c.ReceiveDiscardOk

   is equivalent to:
   v := c<-
   It seems like Go requires ignored return values to be annotated with _ but channels don't
   require this so this will need to be translated.

   go: channel.go:124:22 *)
Definition Channel__ReceiveDiscardOkⁱᵐᵖˡ : val :=
  λ: "c" "T" <>,
    exception_do (let: "c" := (mem.alloc "c") in
    let: "return_val" := (mem.alloc (type.zero_val "T")) in
    let: ("$ret0", "$ret1") := ((method_call #(ptrT.id Channel.id) #"Receive"%go (![#ptrT] "c") "T") #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("return_val" <-["T"] "$r0");;;
    do:  "$r1";;;
    return: (!["T"] "return_val")).

(* If there is a value available in the buffer, consume it, otherwise, don't select.

   go: channel.go:131:22 *)
Definition Channel__BufferedTryReceiveⁱᵐᵖˡ : val :=
  λ: "c" "T" <>,
    exception_do (let: "c" := (mem.alloc "c") in
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
    let: "v" := (mem.alloc (type.zero_val "T")) in
    (if: int_gt (let: "$a0" := (![#sliceT] (struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c"))) in
    slice.len "$a0") #(W64 0)
    then
      let: "val_copy" := (mem.alloc (type.zero_val "T")) in
      let: "$r0" := (!["T"] (slice.elem_ref "T" (![#sliceT] (struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c"))) #(W64 0))) in
      do:  ("val_copy" <-["T"] "$r0");;;
      let: "$r0" := (let: "$s" := (![#sliceT] (struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c"))) in
      slice.slice "T" "$s" #(W64 1) (slice.len "$s")) in
      do:  ((struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c")) <-[#sliceT] "$r0");;;
      do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
      return: (#true, !["T"] "val_copy", #true)
    else do:  #());;;
    (if: (![#OfferState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = closed
    then
      do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
      return: (#true, !["T"] "v", #false)
    else do:  #());;;
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
    return: (#false, !["T"] "v", #true)).

(* go: channel.go:148:22 *)
Definition Channel__UnbufferedTryReceiveⁱᵐᵖˡ : val :=
  λ: "c" "T" "blocking",
    exception_do (let: "c" := (mem.alloc "c") in
    let: "blocking" := (mem.alloc "blocking") in
    let: "local_val" := (mem.alloc (type.zero_val "T")) in
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
    (if: (![#OfferState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = closed
    then
      do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
      return: (#true, !["T"] "local_val", #false)
    else do:  #());;;
    (if: ((![#OfferState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = offer) && ((![#ptrT] (struct.field_ref (Channel "T") #"v"%go (![#ptrT] "c"))) ≠ #null)
    then
      let: "$r0" := (!["T"] (![#ptrT] (struct.field_ref (Channel "T") #"v"%go (![#ptrT] "c")))) in
      do:  ("local_val" <-["T"] "$r0");;;
      let: "$r0" := accepted in
      do:  ((struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c")) <-[#OfferState] "$r0");;;
      do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
      return: (#true, !["T"] "local_val", #true)
    else do:  #());;;
    (if: ((![#OfferState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = idle) && (![#boolT] "blocking")
    then
      let: "$r0" := offer in
      do:  ((struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c")) <-[#OfferState] "$r0");;;
      do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
      do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
      (if: (![#OfferState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = closed
      then
        do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
        return: (#true, !["T"] "local_val", #false)
      else do:  #());;;
      (if: (![#OfferState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = offer
      then
        let: "$r0" := idle in
        do:  ((struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c")) <-[#OfferState] "$r0");;;
        do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
        return: (#false, !["T"] "local_val", #true)
      else do:  #());;;
      (if: (![#OfferState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = accepted
      then
        let: "$r0" := idle in
        do:  ((struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c")) <-[#OfferState] "$r0");;;
        let: "$r0" := (!["T"] (![#ptrT] (struct.field_ref (Channel "T") #"v"%go (![#ptrT] "c")))) in
        do:  ("local_val" <-["T"] "$r0");;;
        let: "$r0" := #null in
        do:  ((struct.field_ref (Channel "T") #"v"%go (![#ptrT] "c")) <-[#ptrT] "$r0");;;
        do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
        return: (#true, !["T"] "local_val", #true)
      else do:  #());;;
      do:  (let: "$a0" := (interface.make #stringT.id #"not supposed to be here!"%go) in
      Panic "$a0")
    else do:  #());;;
    (if: (((![#OfferState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = accepted) || ((![#OfferState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = offer)) || (~ (![#boolT] "blocking"))
    then
      do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
      return: (#false, !["T"] "local_val", #true)
    else do:  #());;;
    do:  (let: "$a0" := (interface.make #stringT.id #"not supposed to be here!"%go) in
    Panic "$a0")).

(* Non-blocking receive function used for select statements. Blocking receive is modeled as
   a single blocking select statement which amounts to a for loop until selected.
   The blocking parameter here is used to determine whether or not we will make an offer to a
   waiting sender. If true, we will make an offer since blocking receive is modeled as a for loop
   around nonblocking TryReceive. If false, we don't make an offer since we don't need to match
   with another non-blocking send.

   go: channel.go:206:22 *)
Definition Channel__TryReceiveⁱᵐᵖˡ : val :=
  λ: "c" "T" "blocking",
    exception_do (let: "c" := (mem.alloc "c") in
    let: "blocking" := (mem.alloc "blocking") in
    (if: (![#uint64T] (struct.field_ref (Channel "T") #"cap"%go (![#ptrT] "c"))) > #(W64 0)
    then
      let: (("$ret0", "$ret1"), "$ret2") := (((method_call #(ptrT.id Channel.id) #"BufferedTryReceive"%go (![#ptrT] "c") "T") #())) in
      return: ("$ret0", "$ret1", "$ret2")
    else
      let: (("$ret0", "$ret1"), "$ret2") := ((let: "$a0" := (![#boolT] "blocking") in
      (method_call #(ptrT.id Channel.id) #"UnbufferedTryReceive"%go (![#ptrT] "c") "T") "$a0")) in
      return: ("$ret0", "$ret1", "$ret2"))).

(* go: channel.go:214:22 *)
Definition Channel__UnbufferedTrySendⁱᵐᵖˡ : val :=
  λ: "c" "T" "val" "blocking",
    exception_do (let: "c" := (mem.alloc "c") in
    let: "blocking" := (mem.alloc "blocking") in
    let: "val" := (mem.alloc "val") in
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
    (if: (![#OfferState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = closed
    then
      do:  (let: "$a0" := (interface.make #stringT.id #"send on closed channel"%go) in
      Panic "$a0")
    else do:  #());;;
    (if: ((![#OfferState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = offer) && ((![#ptrT] (struct.field_ref (Channel "T") #"v"%go (![#ptrT] "c"))) = #null)
    then
      let: "$r0" := (mem.alloc (type.zero_val "T")) in
      do:  ((struct.field_ref (Channel "T") #"v"%go (![#ptrT] "c")) <-[#ptrT] "$r0");;;
      let: "$r0" := accepted in
      do:  ((struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c")) <-[#OfferState] "$r0");;;
      let: "$r0" := (!["T"] "val") in
      do:  ((![#ptrT] (struct.field_ref (Channel "T") #"v"%go (![#ptrT] "c"))) <-["T"] "$r0");;;
      do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
      return: (#true)
    else do:  #());;;
    (if: ((![#OfferState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = idle) && (![#boolT] "blocking")
    then
      let: "$r0" := (mem.alloc (type.zero_val "T")) in
      do:  ((struct.field_ref (Channel "T") #"v"%go (![#ptrT] "c")) <-[#ptrT] "$r0");;;
      let: "$r0" := offer in
      do:  ((struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c")) <-[#OfferState] "$r0");;;
      let: "$r0" := (!["T"] "val") in
      do:  ((![#ptrT] (struct.field_ref (Channel "T") #"v"%go (![#ptrT] "c"))) <-["T"] "$r0");;;
      do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
      do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
      (if: (![#OfferState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = accepted
      then
        let: "$r0" := idle in
        do:  ((struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c")) <-[#OfferState] "$r0");;;
        let: "$r0" := #null in
        do:  ((struct.field_ref (Channel "T") #"v"%go (![#ptrT] "c")) <-[#ptrT] "$r0");;;
        do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
        return: (#true)
      else do:  #());;;
      (if: (![#OfferState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = offer
      then
        let: "$r0" := idle in
        do:  ((struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c")) <-[#OfferState] "$r0");;;
        let: "$r0" := #null in
        do:  ((struct.field_ref (Channel "T") #"v"%go (![#ptrT] "c")) <-[#ptrT] "$r0");;;
        do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
        return: (#false)
      else do:  #());;;
      do:  (let: "$a0" := (interface.make #stringT.id #"Invalid state transition with open receive offer"%go) in
      Panic "$a0")
    else do:  #());;;
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
    return: (#false)).

(* If the buffer has free space, push our value.

   go: channel.go:258:22 *)
Definition Channel__BufferedTrySendⁱᵐᵖˡ : val :=
  λ: "c" "T" "val",
    exception_do (let: "c" := (mem.alloc "c") in
    let: "val" := (mem.alloc "val") in
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
    (if: (![#OfferState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) = closed
    then
      do:  (let: "$a0" := (interface.make #stringT.id #"send on closed channel"%go) in
      Panic "$a0")
    else do:  #());;;
    (if: int_lt (let: "$a0" := (![#sliceT] (struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c"))) in
    slice.len "$a0") (u_to_w64 (![#uint64T] (struct.field_ref (Channel "T") #"cap"%go (![#ptrT] "c"))))
    then
      let: "$r0" := (let: "$a0" := (![#sliceT] (struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c"))) in
      let: "$a1" := ((let: "$sl0" := (!["T"] "val") in
      slice.literal "T" ["$sl0"])) in
      (slice.append "T") "$a0" "$a1") in
      do:  ((struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c")) <-[#sliceT] "$r0");;;
      do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
      return: (#true)
    else do:  #());;;
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
    return: (#false)).

(* Non-Blocking send operation for select statements. Blocking send and blocking select
   statements simply call this in a for loop until it returns true.

   go: channel.go:276:22 *)
Definition Channel__TrySendⁱᵐᵖˡ : val :=
  λ: "c" "T" "val" "blocking",
    exception_do (let: "c" := (mem.alloc "c") in
    let: "blocking" := (mem.alloc "blocking") in
    let: "val" := (mem.alloc "val") in
    let: "sendResult" := (mem.alloc (type.zero_val #boolT)) in
    let: "$r0" := #false in
    do:  ("sendResult" <-[#boolT] "$r0");;;
    (if: (![#uint64T] (struct.field_ref (Channel "T") #"cap"%go (![#ptrT] "c"))) ≠ #(W64 0)
    then
      let: "$r0" := (let: "$a0" := (!["T"] "val") in
      (method_call #(ptrT.id Channel.id) #"BufferedTrySend"%go (![#ptrT] "c") "T") "$a0") in
      do:  ("sendResult" <-[#boolT] "$r0")
    else
      let: "$r0" := (let: "$a0" := (!["T"] "val") in
      let: "$a1" := (![#boolT] "blocking") in
      (method_call #(ptrT.id Channel.id) #"UnbufferedTrySend"%go (![#ptrT] "c") "T") "$a0" "$a1") in
      do:  ("sendResult" <-[#boolT] "$r0"));;;
    return: (![#boolT] "sendResult")).

(* c.Len()

   is equivalent to:
   len(c)

   This might not be worth specifying since it is hard to make good use of channel length
   semantics.

   go: channel.go:295:22 *)
Definition Channel__Lenⁱᵐᵖˡ : val :=
  λ: "c" "T" <>,
    exception_do (let: "c" := (mem.alloc "c") in
    (if: (![#ptrT] "c") = #null
    then return: (#(W64 0))
    else do:  #());;;
    let: "chan_len" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("chan_len" <-[#uint64T] "$r0");;;
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
    let: "$r0" := (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c"))) in
    slice.len "$a0")) in
    do:  ("chan_len" <-[#uint64T] "$r0");;;
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
    return: (![#uint64T] "chan_len")).

(* c.Cap()

   is equivalent to:
   cap(c)

   go: channel.go:310:22 *)
Definition Channel__Capⁱᵐᵖˡ : val :=
  λ: "c" "T" <>,
    exception_do (let: "c" := (mem.alloc "c") in
    (if: (![#ptrT] "c") = #null
    then return: (#(W64 0))
    else do:  #());;;
    return: (![#uint64T] (struct.field_ref (Channel "T") #"cap"%go (![#ptrT] "c")))).

(* case Chan <- Send *)
Definition SelectSend : expr := #(W64 0).

(* case <-Chan: *)
Definition SelectRecv : expr := #(W64 1).

(* go: channel.go:336:6 *)
Definition NewSendCaseⁱᵐᵖˡ : val :=
  λ: "T" "channel" "value",
    exception_do (let: "value" := (mem.alloc "value") in
    let: "channel" := (mem.alloc "channel") in
    return: (mem.alloc (let: "$channel" := (![#ptrT] "channel") in
     let: "$dir" := SelectSend in
     let: "$Value" := (!["T"] "value") in
     struct.make (SelectCase "T") [{
       "channel" ::= "$channel";
       "dir" ::= "$dir";
       "Value" ::= "$Value";
       "Ok" ::= type.zero_val #boolT
     }]))).

(* go: channel.go:344:6 *)
Definition NewRecvCaseⁱᵐᵖˡ : val :=
  λ: "T" "channel",
    exception_do (let: "channel" := (mem.alloc "channel") in
    return: (mem.alloc (let: "$channel" := (![#ptrT] "channel") in
     let: "$dir" := SelectRecv in
     struct.make (SelectCase "T") [{
       "channel" ::= "$channel";
       "dir" ::= "$dir";
       "Value" ::= type.zero_val "T";
       "Ok" ::= type.zero_val #boolT
     }]))).

Definition TrySelect : go_string := "github.com/goose-lang/goose/model/channel.TrySelect"%go.

(* Uses the applicable Try<Operation> function on the select case's channel. Default is always
   selectable so simply returns true.

   go: channel.go:353:6 *)
Definition TrySelectⁱᵐᵖˡ : val :=
  λ: "T" "select_case" "blocking",
    exception_do (let: "blocking" := (mem.alloc "blocking") in
    let: "select_case" := (mem.alloc "select_case") in
    let: "channel" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (![#ptrT] (struct.field_ref (SelectCase "T") #"channel"%go (![#ptrT] "select_case"))) in
    do:  ("channel" <-[#ptrT] "$r0");;;
    (if: (![#ptrT] "channel") = #null
    then return: (#false)
    else do:  #());;;
    (if: (![#SelectDir] (struct.field_ref (SelectCase "T") #"dir"%go (![#ptrT] "select_case"))) = SelectSend
    then
      return: (let: "$a0" := (!["T"] (struct.field_ref (SelectCase "T") #"Value"%go (![#ptrT] "select_case"))) in
       let: "$a1" := (![#boolT] "blocking") in
       (method_call #(ptrT.id Channel.id) #"TrySend"%go (![#ptrT] "channel") "T") "$a0" "$a1")
    else do:  #());;;
    (if: (![#SelectDir] (struct.field_ref (SelectCase "T") #"dir"%go (![#ptrT] "select_case"))) = SelectRecv
    then
      let: "item" := (mem.alloc (type.zero_val "T")) in
      let: "ok" := (mem.alloc (type.zero_val #boolT)) in
      let: "selected" := (mem.alloc (type.zero_val #boolT)) in
      let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#boolT] "blocking") in
      (method_call #(ptrT.id Channel.id) #"TryReceive"%go (![#ptrT] "channel") "T") "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      let: "$r2" := "$ret2" in
      do:  ("selected" <-[#boolT] "$r0");;;
      do:  ("item" <-["T"] "$r1");;;
      do:  ("ok" <-[#boolT] "$r2");;;
      let: "$r0" := (!["T"] "item") in
      do:  ((struct.field_ref (SelectCase "T") #"Value"%go (![#ptrT] "select_case")) <-["T"] "$r0");;;
      let: "$r0" := (![#boolT] "ok") in
      do:  ((struct.field_ref (SelectCase "T") #"Ok"%go (![#ptrT] "select_case")) <-[#boolT] "$r0");;;
      return: (![#boolT] "selected")
    else do:  #());;;
    return: (#false)).

(* Select1 performs a select operation on 1 case. This is used for Send and
   Receive as well, since these channel operations in Go are equivalent to
   a single case select statement with no default.

   go: channel.go:380:6 *)
Definition Select1ⁱᵐᵖˡ : val :=
  λ: "T1" "case1" "blocking",
    exception_do (let: "blocking" := (mem.alloc "blocking") in
    let: "case1" := (mem.alloc "case1") in
    let: "selected" := (mem.alloc (type.zero_val #boolT)) in
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "$r0" := (let: "$a0" := (![#ptrT] "case1") in
      let: "$a1" := (![#boolT] "blocking") in
      ((func_call #TrySelect) "T1") "$a0" "$a1") in
      do:  ("selected" <-[#boolT] "$r0");;;
      (if: (![#boolT] "selected") || (~ (![#boolT] "blocking"))
      then break: #()
      else do:  #()));;;
    return: (![#boolT] "selected")).

Definition TrySelectCase2 : go_string := "github.com/goose-lang/goose/model/channel.TrySelectCase2"%go.

(* go: channel.go:393:6 *)
Definition TrySelectCase2ⁱᵐᵖˡ : val :=
  λ: "T1" "T2" "index" "case1" "case2" "blocking",
    exception_do (let: "blocking" := (mem.alloc "blocking") in
    let: "case2" := (mem.alloc "case2") in
    let: "case1" := (mem.alloc "case1") in
    let: "index" := (mem.alloc "index") in
    (if: (![#uint64T] "index") = #(W64 0)
    then
      return: (let: "$a0" := (![#ptrT] "case1") in
       let: "$a1" := (![#boolT] "blocking") in
       ((func_call #TrySelect) "T1") "$a0" "$a1")
    else do:  #());;;
    (if: (![#uint64T] "index") = #(W64 1)
    then
      return: (let: "$a0" := (![#ptrT] "case2") in
       let: "$a1" := (![#boolT] "blocking") in
       ((func_call #TrySelect) "T2") "$a0" "$a1")
    else do:  #());;;
    do:  (let: "$a0" := (interface.make #stringT.id #"index needs to be 0 or 1"%go) in
    Panic "$a0")).

Definition Select2 : go_string := "github.com/goose-lang/goose/model/channel.Select2"%go.

(* go: channel.go:406:6 *)
Definition Select2ⁱᵐᵖˡ : val :=
  λ: "T1" "T2" "case1" "case2" "blocking",
    exception_do (let: "blocking" := (mem.alloc "blocking") in
    let: "case2" := (mem.alloc "case2") in
    let: "case1" := (mem.alloc "case1") in
    let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (((func_call #primitive.RandomUint64) #()) `rem` #(W64 2)) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (if: let: "$a0" := (![#uint64T] "i") in
    let: "$a1" := (![#ptrT] "case1") in
    let: "$a2" := (![#ptrT] "case2") in
    let: "$a3" := (![#boolT] "blocking") in
    ((func_call #TrySelectCase2) "T1" "T2") "$a0" "$a1" "$a2" "$a3"
    then return: (![#uint64T] "i")
    else do:  #());;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (if: let: "$a0" := (![#ptrT] "case1") in
      let: "$a1" := (![#boolT] "blocking") in
      ((func_call #TrySelect) "T1") "$a0" "$a1"
      then return: (#(W64 0))
      else do:  #());;;
      (if: let: "$a0" := (![#ptrT] "case2") in
      let: "$a1" := (![#boolT] "blocking") in
      ((func_call #TrySelect) "T2") "$a0" "$a1"
      then return: (#(W64 1))
      else do:  #());;;
      (if: (~ (![#boolT] "blocking"))
      then return: (#(W64 2))
      else do:  #()))).

Definition TrySelectCase3 : go_string := "github.com/goose-lang/goose/model/channel.TrySelectCase3"%go.

(* go: channel.go:430:6 *)
Definition TrySelectCase3ⁱᵐᵖˡ : val :=
  λ: "T1" "T2" "T3" "index" "case1" "case2" "case3" "blocking",
    exception_do (let: "blocking" := (mem.alloc "blocking") in
    let: "case3" := (mem.alloc "case3") in
    let: "case2" := (mem.alloc "case2") in
    let: "case1" := (mem.alloc "case1") in
    let: "index" := (mem.alloc "index") in
    (if: (![#uint64T] "index") = #(W64 0)
    then
      return: (let: "$a0" := (![#ptrT] "case1") in
       let: "$a1" := (![#boolT] "blocking") in
       ((func_call #TrySelect) "T1") "$a0" "$a1")
    else do:  #());;;
    (if: (![#uint64T] "index") = #(W64 1)
    then
      return: (let: "$a0" := (![#ptrT] "case2") in
       let: "$a1" := (![#boolT] "blocking") in
       ((func_call #TrySelect) "T2") "$a0" "$a1")
    else do:  #());;;
    (if: (![#uint64T] "index") = #(W64 2)
    then
      return: (let: "$a0" := (![#ptrT] "case3") in
       let: "$a1" := (![#boolT] "blocking") in
       ((func_call #TrySelect) "T3") "$a0" "$a1")
    else do:  #());;;
    do:  (let: "$a0" := (interface.make #stringT.id #"index needs to be 0, 1 or 2"%go) in
    Panic "$a0")).

Definition Select3 : go_string := "github.com/goose-lang/goose/model/channel.Select3"%go.

(* go: channel.go:447:6 *)
Definition Select3ⁱᵐᵖˡ : val :=
  λ: "T1" "T2" "T3" "case1" "case2" "case3" "blocking",
    exception_do (let: "blocking" := (mem.alloc "blocking") in
    let: "case3" := (mem.alloc "case3") in
    let: "case2" := (mem.alloc "case2") in
    let: "case1" := (mem.alloc "case1") in
    let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (((func_call #primitive.RandomUint64) #()) `rem` #(W64 3)) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (if: let: "$a0" := (![#uint64T] "i") in
    let: "$a1" := (![#ptrT] "case1") in
    let: "$a2" := (![#ptrT] "case2") in
    let: "$a3" := (![#ptrT] "case3") in
    let: "$a4" := (![#boolT] "blocking") in
    ((func_call #TrySelectCase3) "T1" "T2" "T3") "$a0" "$a1" "$a2" "$a3" "$a4"
    then return: (![#uint64T] "i")
    else do:  #());;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (if: let: "$a0" := (![#ptrT] "case1") in
      let: "$a1" := (![#boolT] "blocking") in
      ((func_call #TrySelect) "T1") "$a0" "$a1"
      then return: (#(W64 0))
      else do:  #());;;
      (if: let: "$a0" := (![#ptrT] "case2") in
      let: "$a1" := (![#boolT] "blocking") in
      ((func_call #TrySelect) "T2") "$a0" "$a1"
      then return: (#(W64 1))
      else do:  #());;;
      (if: let: "$a0" := (![#ptrT] "case3") in
      let: "$a1" := (![#boolT] "blocking") in
      ((func_call #TrySelect) "T3") "$a0" "$a1"
      then return: (#(W64 2))
      else do:  #());;;
      (if: (~ (![#boolT] "blocking"))
      then return: (#(W64 3))
      else do:  #()))).

Definition TrySelectCase4 : go_string := "github.com/goose-lang/goose/model/channel.TrySelectCase4"%go.

(* go: channel.go:474:6 *)
Definition TrySelectCase4ⁱᵐᵖˡ : val :=
  λ: "T1" "T2" "T3" "T4" "index" "case1" "case2" "case3" "case4" "blocking",
    exception_do (let: "blocking" := (mem.alloc "blocking") in
    let: "case4" := (mem.alloc "case4") in
    let: "case3" := (mem.alloc "case3") in
    let: "case2" := (mem.alloc "case2") in
    let: "case1" := (mem.alloc "case1") in
    let: "index" := (mem.alloc "index") in
    (if: (![#uint64T] "index") = #(W64 0)
    then
      return: (let: "$a0" := (![#ptrT] "case1") in
       let: "$a1" := (![#boolT] "blocking") in
       ((func_call #TrySelect) "T1") "$a0" "$a1")
    else do:  #());;;
    (if: (![#uint64T] "index") = #(W64 1)
    then
      return: (let: "$a0" := (![#ptrT] "case2") in
       let: "$a1" := (![#boolT] "blocking") in
       ((func_call #TrySelect) "T2") "$a0" "$a1")
    else do:  #());;;
    (if: (![#uint64T] "index") = #(W64 2)
    then
      return: (let: "$a0" := (![#ptrT] "case3") in
       let: "$a1" := (![#boolT] "blocking") in
       ((func_call #TrySelect) "T3") "$a0" "$a1")
    else do:  #());;;
    (if: (![#uint64T] "index") = #(W64 3)
    then
      return: (let: "$a0" := (![#ptrT] "case4") in
       let: "$a1" := (![#boolT] "blocking") in
       ((func_call #TrySelect) "T4") "$a0" "$a1")
    else do:  #());;;
    do:  (let: "$a0" := (interface.make #stringT.id #"index needs to be 0, 1, 2 or 3"%go) in
    Panic "$a0")).

Definition Select4 : go_string := "github.com/goose-lang/goose/model/channel.Select4"%go.

(* go: channel.go:495:6 *)
Definition Select4ⁱᵐᵖˡ : val :=
  λ: "T1" "T2" "T3" "T4" "case1" "case2" "case3" "case4" "blocking",
    exception_do (let: "blocking" := (mem.alloc "blocking") in
    let: "case4" := (mem.alloc "case4") in
    let: "case3" := (mem.alloc "case3") in
    let: "case2" := (mem.alloc "case2") in
    let: "case1" := (mem.alloc "case1") in
    let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (((func_call #primitive.RandomUint64) #()) `rem` #(W64 4)) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (if: let: "$a0" := (![#uint64T] "i") in
    let: "$a1" := (![#ptrT] "case1") in
    let: "$a2" := (![#ptrT] "case2") in
    let: "$a3" := (![#ptrT] "case3") in
    let: "$a4" := (![#ptrT] "case4") in
    let: "$a5" := (![#boolT] "blocking") in
    ((func_call #TrySelectCase4) "T1" "T2" "T3" "T4") "$a0" "$a1" "$a2" "$a3" "$a4" "$a5"
    then return: (![#uint64T] "i")
    else do:  #());;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (if: let: "$a0" := (![#ptrT] "case1") in
      let: "$a1" := (![#boolT] "blocking") in
      ((func_call #TrySelect) "T1") "$a0" "$a1"
      then return: (#(W64 0))
      else do:  #());;;
      (if: let: "$a0" := (![#ptrT] "case2") in
      let: "$a1" := (![#boolT] "blocking") in
      ((func_call #TrySelect) "T2") "$a0" "$a1"
      then return: (#(W64 1))
      else do:  #());;;
      (if: let: "$a0" := (![#ptrT] "case3") in
      let: "$a1" := (![#boolT] "blocking") in
      ((func_call #TrySelect) "T3") "$a0" "$a1"
      then return: (#(W64 2))
      else do:  #());;;
      (if: let: "$a0" := (![#ptrT] "case4") in
      let: "$a1" := (![#boolT] "blocking") in
      ((func_call #TrySelect) "T4") "$a0" "$a1"
      then return: (#(W64 3))
      else do:  #());;;
      (if: (~ (![#boolT] "blocking"))
      then return: (#(W64 4))
      else do:  #()))).

Definition TrySelectCase5 : go_string := "github.com/goose-lang/goose/model/channel.TrySelectCase5"%go.

(* go: channel.go:526:6 *)
Definition TrySelectCase5ⁱᵐᵖˡ : val :=
  λ: "T1" "T2" "T3" "T4" "T5" "index" "case1" "case2" "case3" "case4" "case5" "blocking",
    exception_do (let: "blocking" := (mem.alloc "blocking") in
    let: "case5" := (mem.alloc "case5") in
    let: "case4" := (mem.alloc "case4") in
    let: "case3" := (mem.alloc "case3") in
    let: "case2" := (mem.alloc "case2") in
    let: "case1" := (mem.alloc "case1") in
    let: "index" := (mem.alloc "index") in
    (if: (![#uint64T] "index") = #(W64 0)
    then
      return: (let: "$a0" := (![#ptrT] "case1") in
       let: "$a1" := (![#boolT] "blocking") in
       ((func_call #TrySelect) "T1") "$a0" "$a1")
    else do:  #());;;
    (if: (![#uint64T] "index") = #(W64 1)
    then
      return: (let: "$a0" := (![#ptrT] "case2") in
       let: "$a1" := (![#boolT] "blocking") in
       ((func_call #TrySelect) "T2") "$a0" "$a1")
    else do:  #());;;
    (if: (![#uint64T] "index") = #(W64 2)
    then
      return: (let: "$a0" := (![#ptrT] "case3") in
       let: "$a1" := (![#boolT] "blocking") in
       ((func_call #TrySelect) "T3") "$a0" "$a1")
    else do:  #());;;
    (if: (![#uint64T] "index") = #(W64 3)
    then
      return: (let: "$a0" := (![#ptrT] "case4") in
       let: "$a1" := (![#boolT] "blocking") in
       ((func_call #TrySelect) "T4") "$a0" "$a1")
    else do:  #());;;
    (if: (![#uint64T] "index") = #(W64 4)
    then
      return: (let: "$a0" := (![#ptrT] "case5") in
       let: "$a1" := (![#boolT] "blocking") in
       ((func_call #TrySelect) "T5") "$a0" "$a1")
    else do:  #());;;
    do:  (let: "$a0" := (interface.make #stringT.id #"index needs to be 0, 1, 2, 3 or 4"%go) in
    Panic "$a0")).

Definition Select5 : go_string := "github.com/goose-lang/goose/model/channel.Select5"%go.

(* go: channel.go:551:6 *)
Definition Select5ⁱᵐᵖˡ : val :=
  λ: "T1" "T2" "T3" "T4" "T5" "case1" "case2" "case3" "case4" "case5" "blocking",
    exception_do (let: "blocking" := (mem.alloc "blocking") in
    let: "case5" := (mem.alloc "case5") in
    let: "case4" := (mem.alloc "case4") in
    let: "case3" := (mem.alloc "case3") in
    let: "case2" := (mem.alloc "case2") in
    let: "case1" := (mem.alloc "case1") in
    let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (((func_call #primitive.RandomUint64) #()) `rem` #(W64 5)) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (if: let: "$a0" := (![#uint64T] "i") in
    let: "$a1" := (![#ptrT] "case1") in
    let: "$a2" := (![#ptrT] "case2") in
    let: "$a3" := (![#ptrT] "case3") in
    let: "$a4" := (![#ptrT] "case4") in
    let: "$a5" := (![#ptrT] "case5") in
    let: "$a6" := (![#boolT] "blocking") in
    ((func_call #TrySelectCase5) "T1" "T2" "T3" "T4" "T5") "$a0" "$a1" "$a2" "$a3" "$a4" "$a5" "$a6"
    then return: (![#uint64T] "i")
    else do:  #());;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (if: let: "$a0" := (![#ptrT] "case1") in
      let: "$a1" := (![#boolT] "blocking") in
      ((func_call #TrySelect) "T1") "$a0" "$a1"
      then return: (#(W64 0))
      else do:  #());;;
      (if: let: "$a0" := (![#ptrT] "case2") in
      let: "$a1" := (![#boolT] "blocking") in
      ((func_call #TrySelect) "T2") "$a0" "$a1"
      then return: (#(W64 1))
      else do:  #());;;
      (if: let: "$a0" := (![#ptrT] "case3") in
      let: "$a1" := (![#boolT] "blocking") in
      ((func_call #TrySelect) "T3") "$a0" "$a1"
      then return: (#(W64 2))
      else do:  #());;;
      (if: let: "$a0" := (![#ptrT] "case4") in
      let: "$a1" := (![#boolT] "blocking") in
      ((func_call #TrySelect) "T4") "$a0" "$a1"
      then return: (#(W64 3))
      else do:  #());;;
      (if: let: "$a0" := (![#ptrT] "case5") in
      let: "$a1" := (![#boolT] "blocking") in
      ((func_call #TrySelect) "T5") "$a0" "$a1"
      then return: (#(W64 4))
      else do:  #());;;
      (if: (~ (![#boolT] "blocking"))
      then return: (#(W64 5))
      else do:  #()))).

Definition vars' : list (go_string * go_type) := [].

Definition functions' : list (go_string * val) := [(NewChannelRef, NewChannelRefⁱᵐᵖˡ); (NewSendCase, NewSendCaseⁱᵐᵖˡ); (NewRecvCase, NewRecvCaseⁱᵐᵖˡ); (TrySelect, TrySelectⁱᵐᵖˡ); (Select1, Select1ⁱᵐᵖˡ); (TrySelectCase2, TrySelectCase2ⁱᵐᵖˡ); (Select2, Select2ⁱᵐᵖˡ); (TrySelectCase3, TrySelectCase3ⁱᵐᵖˡ); (Select3, Select3ⁱᵐᵖˡ); (TrySelectCase4, TrySelectCase4ⁱᵐᵖˡ); (Select4, Select4ⁱᵐᵖˡ); (TrySelectCase5, TrySelectCase5ⁱᵐᵖˡ); (Select5, Select5ⁱᵐᵖˡ)].

Definition msets' : list (go_string * (list (go_string * val))) := [(OfferState.id, []); (ptrT.id OfferState.id, []); (Channel.id, []); (ptrT.id Channel.id, [("BufferedTryReceive"%go, Channel__BufferedTryReceiveⁱᵐᵖˡ); ("BufferedTrySend"%go, Channel__BufferedTrySendⁱᵐᵖˡ); ("Cap"%go, Channel__Capⁱᵐᵖˡ); ("Close"%go, Channel__Closeⁱᵐᵖˡ); ("Len"%go, Channel__Lenⁱᵐᵖˡ); ("Receive"%go, Channel__Receiveⁱᵐᵖˡ); ("ReceiveDiscardOk"%go, Channel__ReceiveDiscardOkⁱᵐᵖˡ); ("Send"%go, Channel__Sendⁱᵐᵖˡ); ("TryClose"%go, Channel__TryCloseⁱᵐᵖˡ); ("TryReceive"%go, Channel__TryReceiveⁱᵐᵖˡ); ("TrySend"%go, Channel__TrySendⁱᵐᵖˡ); ("UnbufferedTryReceive"%go, Channel__UnbufferedTryReceiveⁱᵐᵖˡ); ("UnbufferedTrySend"%go, Channel__UnbufferedTrySendⁱᵐᵖˡ)]); (SelectDir.id, []); (ptrT.id SelectDir.id, []); (SelectCase.id, []); (ptrT.id SelectCase.id, [])].

#[global] Instance info' : PkgInfo channel.channel :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [sync.sync; primitive.primitive];
  |}.

Definition initialize' : val :=
  λ: <>,
    package.init #channel.channel (λ: <>,
      exception_do (do:  (primitive.initialize' #());;;
      do:  (sync.initialize' #());;;
      do:  (package.alloc channel.channel #()))
      ).

End code.
End channel.
