(* autogenerated from github.com/goose-lang/goose/model/channel *)
Require Export New.code.github_com.goose_lang.primitive.

From New.golang Require Import defn.core.
From New.golang.defn Require Export slice defer.
Definition channel : go_string := "github.com/goose-lang/goose/model/channel".

Module channel.

Section code.
Context `{ffi_syntax}.


Definition offerStateⁱᵐᵖˡ : go.type := go.uint64.

Definition buffered : val := #(W64 0).

Definition idle : val := #(W64 1).

Definition sndPending : val := #(W64 2).

Definition rcvPending : val := #(W64 3).

Definition sndCommit : val := #(W64 4).

Definition rcvDone : val := #(W64 5).

Definition closed : val := #(W64 6).

Definition offerState : go.type := go.Named "github.com/goose-lang/goose/model/channel.offerState"%go [].

Definition Channelⁱᵐᵖˡ(T : go.type)  : go.type := go.StructType [
  (go.FieldDecl "cap"%go go.int);
  (go.FieldDecl "mu"%go (go.PointerType primitive.Mutex));
  (go.FieldDecl "state"%go offerState);
  (go.FieldDecl "buffer"%go (go.SliceType T));
  (go.FieldDecl "v"%go T)
].

Definition NewChannel : go_string := "github.com/goose-lang/goose/model/channel.NewChannel"%go.

Definition Channel(T : go.type)  : go.type := go.Named "github.com/goose-lang/goose/model/channel.Channel"%go [T].

(* go: channel.go:31:6 *)
Definition NewChannelⁱᵐᵖˡ (T : go.type) : val :=
  λ: "cap",
    exception_do (let: "cap" := (go.AllocValue go.int "cap") in
    let: "local_state" := (GoAlloc offerState #()) in
    let: "$r0" := idle in
    do:  ("local_state" <-[offerState] "$r0");;;
    (if: (![go.int] "cap") >⟨go.int⟩ #(W64 0)
    then
      let: "$r0" := buffered in
      do:  ("local_state" <-[offerState] "$r0")
    else do:  #());;;
    return: (go.AllocValue (Channel T) (let: "$cap" := (![go.int] "cap") in
     let: "$mu" := (GoAlloc primitive.Mutex #()) in
     let: "$buffer" := ((FuncResolve go.make2 [go.SliceType T] #()) #(W64 0)) in
     let: "$state" := (![offerState] "local_state") in
     CompositeLiteral (Channel T) (
       let: "$$vs" := go.StructElementListNil #() in 
       let: "$$vs" := go.ElementListApp "$$vs" "$cap" in
       let: "$$vs" := go.ElementListApp "$$vs" "$mu" in
       let: "$$vs" := go.ElementListApp "$$vs" "$state" in
       let: "$$vs" := go.ElementListApp "$$vs" "$buffer" in
       let: "$$vs" := go.ElementListApp "$$vs" (go.ZeroVal T #()) in
       "$$vs"
     )))).

(* Non-Blocking send operation for select statements. Blocking send and blocking select
   statements simply call this in a for loop until it returns true.

   go: channel.go:46:22 *)
Definition Channel__TrySendⁱᵐᵖˡ (T : go.type) : val :=
  λ: "c" "val" "blocking",
    exception_do (let: "c" := (go.AllocValue (go.PointerType (Channel T)) "c") in
    let: "blocking" := (go.AllocValue go.bool "blocking") in
    let: "val" := (go.AllocValue T "val") in
    do:  ((primitive.Mutex__Lockⁱᵐᵖˡ (![go.PointerType primitive.Mutex] (StructFieldRef (Channel T) "mu"%go (![go.PointerType (Channel T)] "c")))) #());;;
    let: "$sw" := (![offerState] (StructFieldRef (Channel T) "state"%go (![go.PointerType (Channel T)] "c"))) in
    (if: "$sw" =⟨offerState⟩ closed
    then
      do:  (let: "$a0" := (InterfaceMake go.string #"send on closed channel"%go) in
      (FuncResolve go.panic [] #()) "$a0")
    else
      (if: "$sw" =⟨offerState⟩ buffered
      then
        (if: (let: "$a0" := (![go.SliceType T] (StructFieldRef (Channel T) "buffer"%go (![go.PointerType (Channel T)] "c"))) in
        (FuncResolve go.len [go.SliceType T] #()) "$a0") <⟨go.int⟩ (![go.int] (StructFieldRef (Channel T) "cap"%go (![go.PointerType (Channel T)] "c")))
        then
          let: "$r0" := (let: "$a0" := (![go.SliceType T] (StructFieldRef (Channel T) "buffer"%go (![go.PointerType (Channel T)] "c"))) in
          let: "$a1" := ((let: "$sl0" := (![T] "val") in
          CompositeLiteral T T ["$sl0"])) in
          (FuncResolve go.append [go.SliceType T] #()) "$a0" "$a1") in
          do:  ((StructFieldRef (Channel T) "buffer"%go (![go.PointerType (Channel T)] "c")) <-[go.SliceType T] "$r0");;;
          do:  ((primitive.Mutex__Unlockⁱᵐᵖˡ (![go.PointerType primitive.Mutex] (StructFieldRef (Channel T) "mu"%go (![go.PointerType (Channel T)] "c")))) #());;;
          return: (#true)
        else do:  #());;;
        do:  ((primitive.Mutex__Unlockⁱᵐᵖˡ (![go.PointerType primitive.Mutex] (StructFieldRef (Channel T) "mu"%go (![go.PointerType (Channel T)] "c")))) #());;;
        return: (#false)
      else
        (if: "$sw" =⟨offerState⟩ rcvPending
        then
          let: "$r0" := sndCommit in
          do:  ((StructFieldRef (Channel T) "state"%go (![go.PointerType (Channel T)] "c")) <-[offerState] "$r0");;;
          let: "$r0" := (![T] "val") in
          do:  ((StructFieldRef (Channel T) "v"%go (![go.PointerType (Channel T)] "c")) <-[T] "$r0");;;
          do:  ((primitive.Mutex__Unlockⁱᵐᵖˡ (![go.PointerType primitive.Mutex] (StructFieldRef (Channel T) "mu"%go (![go.PointerType (Channel T)] "c")))) #());;;
          return: (#true)
        else
          (if: "$sw" =⟨offerState⟩ idle
          then
            (if: ![go.bool] "blocking"
            then
              let: "$r0" := sndPending in
              do:  ((StructFieldRef (Channel T) "state"%go (![go.PointerType (Channel T)] "c")) <-[offerState] "$r0");;;
              let: "$r0" := (![T] "val") in
              do:  ((StructFieldRef (Channel T) "v"%go (![go.PointerType (Channel T)] "c")) <-[T] "$r0");;;
              do:  ((primitive.Mutex__Unlockⁱᵐᵖˡ (![go.PointerType primitive.Mutex] (StructFieldRef (Channel T) "mu"%go (![go.PointerType (Channel T)] "c")))) #());;;
              do:  ((primitive.Mutex__Lockⁱᵐᵖˡ (![go.PointerType primitive.Mutex] (StructFieldRef (Channel T) "mu"%go (![go.PointerType (Channel T)] "c")))) #());;;
              let: "$sw" := (![offerState] (StructFieldRef (Channel T) "state"%go (![go.PointerType (Channel T)] "c"))) in
              (if: "$sw" =⟨offerState⟩ rcvDone
              then
                let: "$r0" := idle in
                do:  ((StructFieldRef (Channel T) "state"%go (![go.PointerType (Channel T)] "c")) <-[offerState] "$r0");;;
                do:  ((primitive.Mutex__Unlockⁱᵐᵖˡ (![go.PointerType primitive.Mutex] (StructFieldRef (Channel T) "mu"%go (![go.PointerType (Channel T)] "c")))) #());;;
                return: (#true)
              else
                (if: "$sw" =⟨offerState⟩ sndPending
                then
                  let: "$r0" := idle in
                  do:  ((StructFieldRef (Channel T) "state"%go (![go.PointerType (Channel T)] "c")) <-[offerState] "$r0");;;
                  do:  ((primitive.Mutex__Unlockⁱᵐᵖˡ (![go.PointerType primitive.Mutex] (StructFieldRef (Channel T) "mu"%go (![go.PointerType (Channel T)] "c")))) #());;;
                  return: (#false)
                else
                  do:  (let: "$a0" := (InterfaceMake go.string #"Invalid state transition with open receive offer"%go) in
                  (FuncResolve go.panic [] #()) "$a0")))
            else do:  #());;;
            do:  ((primitive.Mutex__Unlockⁱᵐᵖˡ (![go.PointerType primitive.Mutex] (StructFieldRef (Channel T) "mu"%go (![go.PointerType (Channel T)] "c")))) #());;;
            return: (#false)
          else
            do:  ((primitive.Mutex__Unlockⁱᵐᵖˡ (![go.PointerType primitive.Mutex] (StructFieldRef (Channel T) "mu"%go (![go.PointerType (Channel T)] "c")))) #());;;
            return: (#false)))))).

(* c.Send(val)

   is equivalent to:

   c <- val

   go: channel.go:105:22 *)
Definition Channel__Sendⁱᵐᵖˡ (T : go.type) : val :=
  λ: "c" "v",
    exception_do (let: "c" := (go.AllocValue (go.PointerType (Channel T)) "c") in
    let: "v" := (go.AllocValue T "v") in
    (if: (![go.PointerType (Channel T)] "c") =⟨go.PointerType (Channel T)⟩ #null
    then
      (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
        do:  #())
    else do:  #());;;
    (for: (λ: <>, (~ (let: "$a0" := (![T] "v") in
    let: "$a1" := #true in
    (Channel__TrySendⁱᵐᵖˡ (![go.PointerType (Channel T)] "c")) "$a0" "$a1"))); (λ: <>, #()) := λ: <>,
      do:  #());;;
    return: #()).

(* Non-blocking receive function used for select statements.
   The blocking parameter here is used to determine whether or not we will make an offer to a
   waiting sender. If true, we will make an offer since blocking receive is modeled as a for loop
   around nonblocking TryReceive. If false, we don't make an offer since we don't need to match
   with another non-blocking send.

   go: channel.go:120:22 *)
Definition Channel__TryReceiveⁱᵐᵖˡ (T : go.type) : val :=
  λ: "c" "blocking",
    exception_do (let: "c" := (go.AllocValue (go.PointerType (Channel T)) "c") in
    let: "blocking" := (go.AllocValue go.bool "blocking") in
    let: "local_val" := (GoAlloc T #()) in
    do:  ((primitive.Mutex__Lockⁱᵐᵖˡ (![go.PointerType primitive.Mutex] (StructFieldRef (Channel T) "mu"%go (![go.PointerType (Channel T)] "c")))) #());;;
    let: "$sw" := (![offerState] (StructFieldRef (Channel T) "state"%go (![go.PointerType (Channel T)] "c"))) in
    (if: "$sw" =⟨offerState⟩ buffered
    then
      let: "v" := (GoAlloc T #()) in
      (if: (let: "$a0" := (![go.SliceType T] (StructFieldRef (Channel T) "buffer"%go (![go.PointerType (Channel T)] "c"))) in
      (FuncResolve go.len [go.SliceType T] #()) "$a0") >⟨go.int⟩ #(W64 0)
      then
        let: "val_copy" := (GoAlloc T #()) in
        let: "$r0" := (![T] (slice.elem_ref T (![go.SliceType T] (StructFieldRef (Channel T) "buffer"%go (![go.PointerType (Channel T)] "c"))) #(W64 0))) in
        do:  ("val_copy" <-[T] "$r0");;;
        let: "$r0" := (let: "$s" := (![go.SliceType T] (StructFieldRef (Channel T) "buffer"%go (![go.PointerType (Channel T)] "c"))) in
        slice.slice T "$s" #(W64 1) (slice.len "$s")) in
        do:  ((StructFieldRef (Channel T) "buffer"%go (![go.PointerType (Channel T)] "c")) <-[go.SliceType T] "$r0");;;
        do:  ((primitive.Mutex__Unlockⁱᵐᵖˡ (![go.PointerType primitive.Mutex] (StructFieldRef (Channel T) "mu"%go (![go.PointerType (Channel T)] "c")))) #());;;
        return: (#true, ![T] "val_copy", #true)
      else do:  #());;;
      do:  ((primitive.Mutex__Unlockⁱᵐᵖˡ (![go.PointerType primitive.Mutex] (StructFieldRef (Channel T) "mu"%go (![go.PointerType (Channel T)] "c")))) #());;;
      return: (#false, ![T] "v", #true)
    else
      (if: "$sw" =⟨offerState⟩ closed
      then
        (if: (let: "$a0" := (![go.SliceType T] (StructFieldRef (Channel T) "buffer"%go (![go.PointerType (Channel T)] "c"))) in
        (FuncResolve go.len [go.SliceType T] #()) "$a0") >⟨go.int⟩ #(W64 0)
        then
          let: "val_copy" := (GoAlloc T #()) in
          let: "$r0" := (![T] (slice.elem_ref T (![go.SliceType T] (StructFieldRef (Channel T) "buffer"%go (![go.PointerType (Channel T)] "c"))) #(W64 0))) in
          do:  ("val_copy" <-[T] "$r0");;;
          let: "$r0" := (let: "$s" := (![go.SliceType T] (StructFieldRef (Channel T) "buffer"%go (![go.PointerType (Channel T)] "c"))) in
          slice.slice T "$s" #(W64 1) (slice.len "$s")) in
          do:  ((StructFieldRef (Channel T) "buffer"%go (![go.PointerType (Channel T)] "c")) <-[go.SliceType T] "$r0");;;
          do:  ((primitive.Mutex__Unlockⁱᵐᵖˡ (![go.PointerType primitive.Mutex] (StructFieldRef (Channel T) "mu"%go (![go.PointerType (Channel T)] "c")))) #());;;
          return: (#true, ![T] "val_copy", #true)
        else do:  #());;;
        do:  ((primitive.Mutex__Unlockⁱᵐᵖˡ (![go.PointerType primitive.Mutex] (StructFieldRef (Channel T) "mu"%go (![go.PointerType (Channel T)] "c")))) #());;;
        return: (#true, ![T] "local_val", #false)
      else
        (if: "$sw" =⟨offerState⟩ sndPending
        then
          let: "$r0" := (![T] (StructFieldRef (Channel T) "v"%go (![go.PointerType (Channel T)] "c"))) in
          do:  ("local_val" <-[T] "$r0");;;
          let: "$r0" := rcvDone in
          do:  ((StructFieldRef (Channel T) "state"%go (![go.PointerType (Channel T)] "c")) <-[offerState] "$r0");;;
          do:  ((primitive.Mutex__Unlockⁱᵐᵖˡ (![go.PointerType primitive.Mutex] (StructFieldRef (Channel T) "mu"%go (![go.PointerType (Channel T)] "c")))) #());;;
          return: (#true, ![T] "local_val", #true)
        else
          (if: "$sw" =⟨offerState⟩ idle
          then
            (if: ![go.bool] "blocking"
            then
              let: "$r0" := rcvPending in
              do:  ((StructFieldRef (Channel T) "state"%go (![go.PointerType (Channel T)] "c")) <-[offerState] "$r0");;;
              do:  ((primitive.Mutex__Unlockⁱᵐᵖˡ (![go.PointerType primitive.Mutex] (StructFieldRef (Channel T) "mu"%go (![go.PointerType (Channel T)] "c")))) #());;;
              do:  ((primitive.Mutex__Lockⁱᵐᵖˡ (![go.PointerType primitive.Mutex] (StructFieldRef (Channel T) "mu"%go (![go.PointerType (Channel T)] "c")))) #());;;
              let: "$sw" := (![offerState] (StructFieldRef (Channel T) "state"%go (![go.PointerType (Channel T)] "c"))) in
              (if: "$sw" =⟨offerState⟩ rcvPending
              then
                let: "$r0" := idle in
                do:  ((StructFieldRef (Channel T) "state"%go (![go.PointerType (Channel T)] "c")) <-[offerState] "$r0");;;
                do:  ((primitive.Mutex__Unlockⁱᵐᵖˡ (![go.PointerType primitive.Mutex] (StructFieldRef (Channel T) "mu"%go (![go.PointerType (Channel T)] "c")))) #());;;
                return: (#false, ![T] "local_val", #true)
              else
                (if: "$sw" =⟨offerState⟩ sndCommit
                then
                  let: "$r0" := idle in
                  do:  ((StructFieldRef (Channel T) "state"%go (![go.PointerType (Channel T)] "c")) <-[offerState] "$r0");;;
                  let: "$r0" := (![T] (StructFieldRef (Channel T) "v"%go (![go.PointerType (Channel T)] "c"))) in
                  do:  ("local_val" <-[T] "$r0");;;
                  do:  ((primitive.Mutex__Unlockⁱᵐᵖˡ (![go.PointerType primitive.Mutex] (StructFieldRef (Channel T) "mu"%go (![go.PointerType (Channel T)] "c")))) #());;;
                  return: (#true, ![T] "local_val", #true)
                else
                  do:  (let: "$a0" := (InterfaceMake go.string #"not supposed to be here!"%go) in
                  (FuncResolve go.panic [] #()) "$a0")))
            else do:  #());;;
            do:  ((primitive.Mutex__Unlockⁱᵐᵖˡ (![go.PointerType primitive.Mutex] (StructFieldRef (Channel T) "mu"%go (![go.PointerType (Channel T)] "c")))) #());;;
            return: (#false, ![T] "local_val", #true)
          else
            do:  ((primitive.Mutex__Unlockⁱᵐᵖˡ (![go.PointerType primitive.Mutex] (StructFieldRef (Channel T) "mu"%go (![go.PointerType (Channel T)] "c")))) #());;;
            return: (#false, ![T] "local_val", #true)))))).

(* go: channel.go:189:22 *)
Definition Channel__Receiveⁱᵐᵖˡ (T : go.type) : val :=
  λ: "c" <>,
    exception_do (let: "c" := (go.AllocValue (go.PointerType (Channel T)) "c") in
    (if: (![go.PointerType (Channel T)] "c") =⟨go.PointerType (Channel T)⟩ #null
    then
      (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
        do:  #())
    else do:  #());;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "ok" := (GoAlloc go.bool #()) in
      let: "v" := (GoAlloc T #()) in
      let: "success" := (GoAlloc go.bool #()) in
      let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := #true in
      (Channel__TryReceiveⁱᵐᵖˡ (![go.PointerType (Channel T)] "c")) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      let: "$r2" := "$ret2" in
      do:  ("success" <-[go.bool] "$r0");;;
      do:  ("v" <-[T] "$r1");;;
      do:  ("ok" <-[go.bool] "$r2");;;
      (if: ![go.bool] "success"
      then return: (![T] "v", ![go.bool] "ok")
      else do:  #()))).

(* This is a non-blocking attempt at closing. The only reason close blocks ever is because there
   may be successful exchanges that need to complete, which is equivalent to the go runtime where
   the closer must still obtain the channel's lock

   go: channel.go:206:22 *)
Definition Channel__tryCloseⁱᵐᵖˡ (T : go.type) : val :=
  λ: "c" <>,
    exception_do (let: "c" := (go.AllocValue (go.PointerType (Channel T)) "c") in
    do:  ((primitive.Mutex__Lockⁱᵐᵖˡ (![go.PointerType primitive.Mutex] (StructFieldRef (Channel T) "mu"%go (![go.PointerType (Channel T)] "c")))) #());;;
    let: "$sw" := (![offerState] (StructFieldRef (Channel T) "state"%go (![go.PointerType (Channel T)] "c"))) in
    (if: "$sw" =⟨offerState⟩ closed
    then
      do:  (let: "$a0" := (InterfaceMake go.string #"close of closed channel"%go) in
      (FuncResolve go.panic [] #()) "$a0")
    else
      (if: ("$sw" =⟨offerState⟩ buffered) || ("$sw" =⟨offerState⟩ idle)
      then
        let: "$r0" := closed in
        do:  ((StructFieldRef (Channel T) "state"%go (![go.PointerType (Channel T)] "c")) <-[offerState] "$r0");;;
        do:  ((primitive.Mutex__Unlockⁱᵐᵖˡ (![go.PointerType primitive.Mutex] (StructFieldRef (Channel T) "mu"%go (![go.PointerType (Channel T)] "c")))) #());;;
        return: (#true)
      else
        do:  ((primitive.Mutex__Unlockⁱᵐᵖˡ (![go.PointerType primitive.Mutex] (StructFieldRef (Channel T) "mu"%go (![go.PointerType (Channel T)] "c")))) #());;;
        return: (#false)))).

(* c.Close()

   is equivalent to:

   close(c)

   go: channel.go:228:22 *)
Definition Channel__Closeⁱᵐᵖˡ (T : go.type) : val :=
  λ: "c" <>,
    exception_do (let: "c" := (go.AllocValue (go.PointerType (Channel T)) "c") in
    (if: (![go.PointerType (Channel T)] "c") =⟨go.PointerType (Channel T)⟩ #null
    then
      do:  (let: "$a0" := (InterfaceMake go.string #"close of nil channel"%go) in
      (FuncResolve go.panic [] #()) "$a0")
    else do:  #());;;
    (for: (λ: <>, (~ ((Channel__tryCloseⁱᵐᵖˡ (![go.PointerType (Channel T)] "c")) #()))); (λ: <>, #()) := λ: <>,
      do:  #());;;
    return: #()).

(* v := c.ReceiveDiscardOk

   is equivalent to:
   v := c<-

   go: channel.go:240:22 *)
Definition Channel__ReceiveDiscardOkⁱᵐᵖˡ (T : go.type) : val :=
  λ: "c" <>,
    exception_do (let: "c" := (go.AllocValue (go.PointerType (Channel T)) "c") in
    let: "return_val" := (GoAlloc T #()) in
    let: ("$ret0", "$ret1") := ((Channel__Receiveⁱᵐᵖˡ (![go.PointerType (Channel T)] "c")) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("return_val" <-[T] "$r0");;;
    do:  "$r1";;;
    return: (![T] "return_val")).

(* c.Len()

   is equivalent to:
   len(c)

   This might not be worth specifying since it is hard to make good use of channel length
   semantics.

   go: channel.go:252:22 *)
Definition Channel__Lenⁱᵐᵖˡ (T : go.type) : val :=
  λ: "c" <>,
    exception_do (let: "c" := (go.AllocValue (go.PointerType (Channel T)) "c") in
    (if: (![go.PointerType (Channel T)] "c") =⟨go.PointerType (Channel T)⟩ #null
    then return: (#(W64 0))
    else do:  #());;;
    do:  ((primitive.Mutex__Lockⁱᵐᵖˡ (![go.PointerType primitive.Mutex] (StructFieldRef (Channel T) "mu"%go (![go.PointerType (Channel T)] "c")))) #());;;
    let: "chan_len" := (GoAlloc go.int #()) in
    let: "$r0" := (let: "$a0" := (![go.SliceType T] (StructFieldRef (Channel T) "buffer"%go (![go.PointerType (Channel T)] "c"))) in
    (FuncResolve go.len [go.SliceType T] #()) "$a0") in
    do:  ("chan_len" <-[go.int] "$r0");;;
    do:  ((primitive.Mutex__Unlockⁱᵐᵖˡ (![go.PointerType primitive.Mutex] (StructFieldRef (Channel T) "mu"%go (![go.PointerType (Channel T)] "c")))) #());;;
    return: (![go.int] "chan_len")).

(* c.Cap()

   is equivalent to:
   cap(c)

   go: channel.go:266:22 *)
Definition Channel__Capⁱᵐᵖˡ (T : go.type) : val :=
  λ: "c" <>,
    exception_do (let: "c" := (go.AllocValue (go.PointerType (Channel T)) "c") in
    (if: (![go.PointerType (Channel T)] "c") =⟨go.PointerType (Channel T)⟩ #null
    then return: (#(W64 0))
    else do:  #());;;
    return: (![go.int] (StructFieldRef (Channel T) "cap"%go (![go.PointerType (Channel T)] "c")))).

(* c.Iter() returns an iterator that models a for range loop over the channel.

   go: channel.go:274:22 *)
Definition Channel__Iterⁱᵐᵖˡ (T : go.type) : val :=
  λ: "c" <>,
    exception_do (let: "c" := (go.AllocValue (go.PointerType (Channel T)) "c") in
    return: ((λ: "yield",
       exception_do (let: "yield" := (go.AllocValue (go.FunctionType (go.Signature [T] #false [go.bool])) "yield") in
       (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
         let: "ok" := (GoAlloc go.bool #()) in
         let: "v" := (GoAlloc T #()) in
         let: "selected" := (GoAlloc go.bool #()) in
         let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := #true in
         (Channel__TryReceiveⁱᵐᵖˡ (![go.PointerType (Channel T)] "c")) "$a0") in
         let: "$r0" := "$ret0" in
         let: "$r1" := "$ret1" in
         let: "$r2" := "$ret2" in
         do:  ("selected" <-[go.bool] "$r0");;;
         do:  ("v" <-[T] "$r1");;;
         do:  ("ok" <-[go.bool] "$r2");;;
         (if: (~ (![go.bool] "selected"))
         then continue: #()
         else do:  #());;;
         (if: (~ (![go.bool] "ok"))
         then return: (#())
         else do:  #());;;
         (if: (~ (let: "$a0" := (![T] "v") in
         (![go.FunctionType (go.Signature [T] #false [go.bool])] "yield") "$a0"))
         then return: (#())
         else do:  #()));;;
       return: #())
       ))).

Definition SelectDirⁱᵐᵖˡ : go.type := go.uint64.

(* case ch <- Send *)
Definition SelectSend : val := #(W64 0).

(* case <-ch: *)
Definition SelectRecv : val := #(W64 1).

Definition NonBlockingSelect1 : go_string := "github.com/goose-lang/goose/model/channel.NonBlockingSelect1"%go.

Definition SelectDir : go.type := go.Named "github.com/goose-lang/goose/model/channel.SelectDir"%go [].

(* Non-blocking select with 1 case (send or receive)
   For receive: value parameter is ignored
   Returns (selected, received_value, ok)

   go: select.go:19:6 *)
Definition NonBlockingSelect1ⁱᵐᵖˡ (T : go.type) : val :=
  λ: "ch" "dir" "value",
    exception_do (let: "value" := (go.AllocValue T "value") in
    let: "dir" := (go.AllocValue SelectDir "dir") in
    let: "ch" := (go.AllocValue (go.PointerType (Channel T)) "ch") in
    let: "zero" := (GoAlloc T #()) in
    (if: (![SelectDir] "dir") =⟨go.uint64⟩ SelectSend
    then
      let: "selected" := (GoAlloc go.bool #()) in
      let: "$r0" := (let: "$a0" := (![T] "value") in
      let: "$a1" := #false in
      (Channel__TrySendⁱᵐᵖˡ (![go.PointerType (Channel T)] "ch")) "$a0" "$a1") in
      do:  ("selected" <-[go.bool] "$r0");;;
      return: (![go.bool] "selected", ![T] "zero", #false)
    else
      let: "ok" := (GoAlloc go.bool #()) in
      let: "recv_val" := (GoAlloc T #()) in
      let: "selected" := (GoAlloc go.bool #()) in
      let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := #false in
      (Channel__TryReceiveⁱᵐᵖˡ (![go.PointerType (Channel T)] "ch")) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      let: "$r2" := "$ret2" in
      do:  ("selected" <-[go.bool] "$r0");;;
      do:  ("recv_val" <-[T] "$r1");;;
      do:  ("ok" <-[go.bool] "$r2");;;
      return: (![go.bool] "selected", ![T] "recv_val", ![go.bool] "ok"))).

Definition BlockingSelect2 : go_string := "github.com/goose-lang/goose/model/channel.BlockingSelect2"%go.

(* Blocking select with 2 cases
   Returns (caseIndex, received_value1, received_value2, ok)

   go: select.go:33:6 *)
Definition BlockingSelect2ⁱᵐᵖˡ (T1 T2 : go.type) : val :=
  λ: "ch1" "dir1" "val1" "ch2" "dir2" "val2",
    exception_do (let: "val2" := (go.AllocValue T2 "val2") in
    let: "dir2" := (go.AllocValue SelectDir "dir2") in
    let: "ch2" := (go.AllocValue (go.PointerType (Channel T2)) "ch2") in
    let: "val1" := (go.AllocValue T1 "val1") in
    let: "dir1" := (go.AllocValue SelectDir "dir1") in
    let: "ch1" := (go.AllocValue (go.PointerType (Channel T1)) "ch1") in
    let: "zero1" := (GoAlloc T1 #()) in
    let: "zero2" := (GoAlloc T2 #()) in
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (if: (((primitive.RandomUint64ⁱᵐᵖˡ [] #()) #()) `rem`⟨go.uint64⟩ #(W64 2)) =⟨go.uint64⟩ #(W64 0)
      then
        (if: (![SelectDir] "dir1") =⟨go.uint64⟩ SelectSend
        then
          (if: let: "$a0" := (![T1] "val1") in
          let: "$a1" := #true in
          (Channel__TrySendⁱᵐᵖˡ (![go.PointerType (Channel T1)] "ch1")) "$a0" "$a1"
          then return: (#(W64 0), ![T1] "zero1", ![T2] "zero2", #false)
          else do:  #())
        else
          let: "ok" := (GoAlloc go.bool #()) in
          let: "recv_val" := (GoAlloc T1 #()) in
          let: "selected" := (GoAlloc go.bool #()) in
          let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := #true in
          (Channel__TryReceiveⁱᵐᵖˡ (![go.PointerType (Channel T1)] "ch1")) "$a0") in
          let: "$r0" := "$ret0" in
          let: "$r1" := "$ret1" in
          let: "$r2" := "$ret2" in
          do:  ("selected" <-[go.bool] "$r0");;;
          do:  ("recv_val" <-[T1] "$r1");;;
          do:  ("ok" <-[go.bool] "$r2");;;
          (if: ![go.bool] "selected"
          then return: (#(W64 0), ![T1] "recv_val", ![T2] "zero2", ![go.bool] "ok")
          else do:  #()))
      else
        (if: (![SelectDir] "dir2") =⟨go.uint64⟩ SelectSend
        then
          (if: let: "$a0" := (![T2] "val2") in
          let: "$a1" := #true in
          (Channel__TrySendⁱᵐᵖˡ (![go.PointerType (Channel T2)] "ch2")) "$a0" "$a1"
          then return: (#(W64 1), ![T1] "zero1", ![T2] "zero2", #false)
          else do:  #())
        else
          let: "ok" := (GoAlloc go.bool #()) in
          let: "recv_val" := (GoAlloc T2 #()) in
          let: "selected" := (GoAlloc go.bool #()) in
          let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := #true in
          (Channel__TryReceiveⁱᵐᵖˡ (![go.PointerType (Channel T2)] "ch2")) "$a0") in
          let: "$r0" := "$ret0" in
          let: "$r1" := "$ret1" in
          let: "$r2" := "$ret2" in
          do:  ("selected" <-[go.bool] "$r0");;;
          do:  ("recv_val" <-[T2] "$r1");;;
          do:  ("ok" <-[go.bool] "$r2");;;
          (if: ![go.bool] "selected"
          then return: (#(W64 1), ![T1] "zero1", ![T2] "recv_val", ![go.bool] "ok")
          else do:  #()))))).

Definition NonBlockingSelect2 : go_string := "github.com/goose-lang/goose/model/channel.NonBlockingSelect2"%go.

(* Non-blocking select with 2 cases
   Returns (caseIndex, received_value1, received_value2, ok)
   caseIndex = 2 means no selection

   go: select.go:73:6 *)
Definition NonBlockingSelect2ⁱᵐᵖˡ (T1 T2 : go.type) : val :=
  λ: "ch1" "dir1" "val1" "ch2" "dir2" "val2",
    exception_do (let: "val2" := (go.AllocValue T2 "val2") in
    let: "dir2" := (go.AllocValue SelectDir "dir2") in
    let: "ch2" := (go.AllocValue (go.PointerType (Channel T2)) "ch2") in
    let: "val1" := (go.AllocValue T1 "val1") in
    let: "dir1" := (go.AllocValue SelectDir "dir1") in
    let: "ch1" := (go.AllocValue (go.PointerType (Channel T1)) "ch1") in
    let: "zero1" := (GoAlloc T1 #()) in
    let: "zero2" := (GoAlloc T2 #()) in
    (if: (((primitive.RandomUint64ⁱᵐᵖˡ [] #()) #()) `rem`⟨go.uint64⟩ #(W64 2)) =⟨go.uint64⟩ #(W64 0)
    then
      (if: (![SelectDir] "dir1") =⟨go.uint64⟩ SelectSend
      then
        (if: let: "$a0" := (![T1] "val1") in
        let: "$a1" := #false in
        (Channel__TrySendⁱᵐᵖˡ (![go.PointerType (Channel T1)] "ch1")) "$a0" "$a1"
        then return: (#(W64 0), ![T1] "zero1", ![T2] "zero2", #false)
        else do:  #())
      else
        let: "ok" := (GoAlloc go.bool #()) in
        let: "recv_val" := (GoAlloc T1 #()) in
        let: "selected" := (GoAlloc go.bool #()) in
        let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := #false in
        (Channel__TryReceiveⁱᵐᵖˡ (![go.PointerType (Channel T1)] "ch1")) "$a0") in
        let: "$r0" := "$ret0" in
        let: "$r1" := "$ret1" in
        let: "$r2" := "$ret2" in
        do:  ("selected" <-[go.bool] "$r0");;;
        do:  ("recv_val" <-[T1] "$r1");;;
        do:  ("ok" <-[go.bool] "$r2");;;
        (if: ![go.bool] "selected"
        then return: (#(W64 0), ![T1] "recv_val", ![T2] "zero2", ![go.bool] "ok")
        else do:  #()));;;
      (if: (![SelectDir] "dir2") =⟨go.uint64⟩ SelectSend
      then
        (if: let: "$a0" := (![T2] "val2") in
        let: "$a1" := #false in
        (Channel__TrySendⁱᵐᵖˡ (![go.PointerType (Channel T2)] "ch2")) "$a0" "$a1"
        then return: (#(W64 1), ![T1] "zero1", ![T2] "zero2", #false)
        else do:  #())
      else
        let: "ok" := (GoAlloc go.bool #()) in
        let: "recv_val" := (GoAlloc T2 #()) in
        let: "selected" := (GoAlloc go.bool #()) in
        let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := #false in
        (Channel__TryReceiveⁱᵐᵖˡ (![go.PointerType (Channel T2)] "ch2")) "$a0") in
        let: "$r0" := "$ret0" in
        let: "$r1" := "$ret1" in
        let: "$r2" := "$ret2" in
        do:  ("selected" <-[go.bool] "$r0");;;
        do:  ("recv_val" <-[T2] "$r1");;;
        do:  ("ok" <-[go.bool] "$r2");;;
        (if: ![go.bool] "selected"
        then return: (#(W64 1), ![T1] "zero1", ![T2] "recv_val", ![go.bool] "ok")
        else do:  #()))
    else
      (if: (![SelectDir] "dir2") =⟨go.uint64⟩ SelectSend
      then
        (if: let: "$a0" := (![T2] "val2") in
        let: "$a1" := #false in
        (Channel__TrySendⁱᵐᵖˡ (![go.PointerType (Channel T2)] "ch2")) "$a0" "$a1"
        then return: (#(W64 1), ![T1] "zero1", ![T2] "zero2", #false)
        else do:  #())
      else
        let: "ok" := (GoAlloc go.bool #()) in
        let: "recv_val" := (GoAlloc T2 #()) in
        let: "selected" := (GoAlloc go.bool #()) in
        let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := #false in
        (Channel__TryReceiveⁱᵐᵖˡ (![go.PointerType (Channel T2)] "ch2")) "$a0") in
        let: "$r0" := "$ret0" in
        let: "$r1" := "$ret1" in
        let: "$r2" := "$ret2" in
        do:  ("selected" <-[go.bool] "$r0");;;
        do:  ("recv_val" <-[T2] "$r1");;;
        do:  ("ok" <-[go.bool] "$r2");;;
        (if: ![go.bool] "selected"
        then return: (#(W64 1), ![T1] "zero1", ![T2] "recv_val", ![go.bool] "ok")
        else do:  #()));;;
      (if: (![SelectDir] "dir1") =⟨go.uint64⟩ SelectSend
      then
        (if: let: "$a0" := (![T1] "val1") in
        let: "$a1" := #false in
        (Channel__TrySendⁱᵐᵖˡ (![go.PointerType (Channel T1)] "ch1")) "$a0" "$a1"
        then return: (#(W64 0), ![T1] "zero1", ![T2] "zero2", #false)
        else do:  #())
      else
        let: "ok" := (GoAlloc go.bool #()) in
        let: "recv_val" := (GoAlloc T1 #()) in
        let: "selected" := (GoAlloc go.bool #()) in
        let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := #false in
        (Channel__TryReceiveⁱᵐᵖˡ (![go.PointerType (Channel T1)] "ch1")) "$a0") in
        let: "$r0" := "$ret0" in
        let: "$r1" := "$ret1" in
        let: "$r2" := "$ret2" in
        do:  ("selected" <-[go.bool] "$r0");;;
        do:  ("recv_val" <-[T1] "$r1");;;
        do:  ("ok" <-[go.bool] "$r2");;;
        (if: ![go.bool] "selected"
        then return: (#(W64 0), ![T1] "recv_val", ![T2] "zero2", ![go.bool] "ok")
        else do:  #())));;;
    return: (#(W64 2), ![T1] "zero1", ![T2] "zero2", #false)).

Definition BlockingSelect3 : go_string := "github.com/goose-lang/goose/model/channel.BlockingSelect3"%go.

(* go: select.go:135:6 *)
Definition BlockingSelect3ⁱᵐᵖˡ (T1 T2 T3 : go.type) : val :=
  λ: "ch1" "dir1" "val1" "ch2" "dir2" "val2" "ch3" "dir3" "val3",
    exception_do (let: "val3" := (go.AllocValue T3 "val3") in
    let: "dir3" := (go.AllocValue SelectDir "dir3") in
    let: "ch3" := (go.AllocValue (go.PointerType (Channel T3)) "ch3") in
    let: "val2" := (go.AllocValue T2 "val2") in
    let: "dir2" := (go.AllocValue SelectDir "dir2") in
    let: "ch2" := (go.AllocValue (go.PointerType (Channel T2)) "ch2") in
    let: "val1" := (go.AllocValue T1 "val1") in
    let: "dir1" := (go.AllocValue SelectDir "dir1") in
    let: "ch1" := (go.AllocValue (go.PointerType (Channel T1)) "ch1") in
    let: "zero1" := (GoAlloc T1 #()) in
    let: "zero2" := (GoAlloc T2 #()) in
    let: "zero3" := (GoAlloc T3 #()) in
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "r" := (GoAlloc go.uint64 #()) in
      let: "$r0" := (((primitive.RandomUint64ⁱᵐᵖˡ [] #()) #()) `rem`⟨go.uint64⟩ #(W64 3)) in
      do:  ("r" <-[go.uint64] "$r0");;;
      let: "$sw" := (![go.uint64] "r") in
      (if: "$sw" =⟨go.uint64⟩ #(W64 0)
      then
        (if: (![SelectDir] "dir1") =⟨go.uint64⟩ SelectSend
        then
          (if: let: "$a0" := (![T1] "val1") in
          let: "$a1" := #true in
          (Channel__TrySendⁱᵐᵖˡ (![go.PointerType (Channel T1)] "ch1")) "$a0" "$a1"
          then return: (#(W64 0), ![T1] "zero1", ![T2] "zero2", ![T3] "zero3", #false)
          else do:  #())
        else
          let: "ok" := (GoAlloc go.bool #()) in
          let: "recv_val" := (GoAlloc T1 #()) in
          let: "selected" := (GoAlloc go.bool #()) in
          let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := #true in
          (Channel__TryReceiveⁱᵐᵖˡ (![go.PointerType (Channel T1)] "ch1")) "$a0") in
          let: "$r0" := "$ret0" in
          let: "$r1" := "$ret1" in
          let: "$r2" := "$ret2" in
          do:  ("selected" <-[go.bool] "$r0");;;
          do:  ("recv_val" <-[T1] "$r1");;;
          do:  ("ok" <-[go.bool] "$r2");;;
          (if: ![go.bool] "selected"
          then return: (#(W64 0), ![T1] "recv_val", ![T2] "zero2", ![T3] "zero3", ![go.bool] "ok")
          else do:  #()))
      else
        (if: "$sw" =⟨go.uint64⟩ #(W64 1)
        then
          (if: (![SelectDir] "dir2") =⟨go.uint64⟩ SelectSend
          then
            (if: let: "$a0" := (![T2] "val2") in
            let: "$a1" := #true in
            (Channel__TrySendⁱᵐᵖˡ (![go.PointerType (Channel T2)] "ch2")) "$a0" "$a1"
            then return: (#(W64 1), ![T1] "zero1", ![T2] "zero2", ![T3] "zero3", #false)
            else do:  #())
          else
            let: "ok" := (GoAlloc go.bool #()) in
            let: "recv_val" := (GoAlloc T2 #()) in
            let: "selected" := (GoAlloc go.bool #()) in
            let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := #true in
            (Channel__TryReceiveⁱᵐᵖˡ (![go.PointerType (Channel T2)] "ch2")) "$a0") in
            let: "$r0" := "$ret0" in
            let: "$r1" := "$ret1" in
            let: "$r2" := "$ret2" in
            do:  ("selected" <-[go.bool] "$r0");;;
            do:  ("recv_val" <-[T2] "$r1");;;
            do:  ("ok" <-[go.bool] "$r2");;;
            (if: ![go.bool] "selected"
            then return: (#(W64 1), ![T1] "zero1", ![T2] "recv_val", ![T3] "zero3", ![go.bool] "ok")
            else do:  #()))
        else
          (if: (![SelectDir] "dir3") =⟨go.uint64⟩ SelectSend
          then
            (if: let: "$a0" := (![T3] "val3") in
            let: "$a1" := #true in
            (Channel__TrySendⁱᵐᵖˡ (![go.PointerType (Channel T3)] "ch3")) "$a0" "$a1"
            then return: (#(W64 2), ![T1] "zero1", ![T2] "zero2", ![T3] "zero3", #false)
            else do:  #())
          else
            let: "ok" := (GoAlloc go.bool #()) in
            let: "recv_val" := (GoAlloc T3 #()) in
            let: "selected" := (GoAlloc go.bool #()) in
            let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := #true in
            (Channel__TryReceiveⁱᵐᵖˡ (![go.PointerType (Channel T3)] "ch3")) "$a0") in
            let: "$r0" := "$ret0" in
            let: "$r1" := "$ret1" in
            let: "$r2" := "$ret2" in
            do:  ("selected" <-[go.bool] "$r0");;;
            do:  ("recv_val" <-[T3] "$r1");;;
            do:  ("ok" <-[go.bool] "$r2");;;
            (if: ![go.bool] "selected"
            then return: (#(W64 2), ![T1] "zero1", ![T2] "zero2", ![T3] "recv_val", ![go.bool] "ok")
            else do:  #())))))).

Definition NonBlockingSelect3 : go_string := "github.com/goose-lang/goose/model/channel.NonBlockingSelect3"%go.

(* Non-blocking select with 3 cases
   Returns (caseIndex, received_value1, received_value2, received_value3, ok)
   caseIndex = 3 means no selection

   go: select.go:189:6 *)
Definition NonBlockingSelect3ⁱᵐᵖˡ (T1 T2 T3 : go.type) : val :=
  λ: "ch1" "dir1" "val1" "ch2" "dir2" "val2" "ch3" "dir3" "val3",
    exception_do (let: "val3" := (go.AllocValue T3 "val3") in
    let: "dir3" := (go.AllocValue SelectDir "dir3") in
    let: "ch3" := (go.AllocValue (go.PointerType (Channel T3)) "ch3") in
    let: "val2" := (go.AllocValue T2 "val2") in
    let: "dir2" := (go.AllocValue SelectDir "dir2") in
    let: "ch2" := (go.AllocValue (go.PointerType (Channel T2)) "ch2") in
    let: "val1" := (go.AllocValue T1 "val1") in
    let: "dir1" := (go.AllocValue SelectDir "dir1") in
    let: "ch1" := (go.AllocValue (go.PointerType (Channel T1)) "ch1") in
    let: "zero1" := (GoAlloc T1 #()) in
    let: "zero2" := (GoAlloc T2 #()) in
    let: "zero3" := (GoAlloc T3 #()) in
    let: "start" := (GoAlloc go.uint64 #()) in
    let: "$r0" := (((primitive.RandomUint64ⁱᵐᵖˡ [] #()) #()) `rem`⟨go.uint64⟩ #(W64 3)) in
    do:  ("start" <-[go.uint64] "$r0");;;
    (let: "i" := (GoAlloc go.uint64 #()) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, (![go.uint64] "i") <⟨go.uint64⟩ #(W64 3)); (λ: <>, do:  ("i" <-[go.uint64] ((![go.uint64] "i") +⟨go.uint64⟩ #(W8 1)))) := λ: <>,
      let: "caseIdx" := (GoAlloc go.uint64 #()) in
      let: "$r0" := (((![go.uint64] "start") +⟨go.uint64⟩ (![go.uint64] "i")) `rem`⟨go.uint64⟩ #(W64 3)) in
      do:  ("caseIdx" <-[go.uint64] "$r0");;;
      (if: (![go.uint64] "caseIdx") =⟨go.uint64⟩ #(W64 0)
      then
        (if: (![SelectDir] "dir1") =⟨go.uint64⟩ SelectSend
        then
          (if: let: "$a0" := (![T1] "val1") in
          let: "$a1" := #false in
          (Channel__TrySendⁱᵐᵖˡ (![go.PointerType (Channel T1)] "ch1")) "$a0" "$a1"
          then return: (#(W64 0), ![T1] "zero1", ![T2] "zero2", ![T3] "zero3", #false)
          else do:  #())
        else
          let: "ok" := (GoAlloc go.bool #()) in
          let: "recv_val" := (GoAlloc T1 #()) in
          let: "selected" := (GoAlloc go.bool #()) in
          let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := #false in
          (Channel__TryReceiveⁱᵐᵖˡ (![go.PointerType (Channel T1)] "ch1")) "$a0") in
          let: "$r0" := "$ret0" in
          let: "$r1" := "$ret1" in
          let: "$r2" := "$ret2" in
          do:  ("selected" <-[go.bool] "$r0");;;
          do:  ("recv_val" <-[T1] "$r1");;;
          do:  ("ok" <-[go.bool] "$r2");;;
          (if: ![go.bool] "selected"
          then return: (#(W64 0), ![T1] "recv_val", ![T2] "zero2", ![T3] "zero3", ![go.bool] "ok")
          else do:  #()))
      else
        (if: (![go.uint64] "caseIdx") =⟨go.uint64⟩ #(W64 1)
        then
          (if: (![SelectDir] "dir2") =⟨go.uint64⟩ SelectSend
          then
            (if: let: "$a0" := (![T2] "val2") in
            let: "$a1" := #false in
            (Channel__TrySendⁱᵐᵖˡ (![go.PointerType (Channel T2)] "ch2")) "$a0" "$a1"
            then return: (#(W64 1), ![T1] "zero1", ![T2] "zero2", ![T3] "zero3", #false)
            else do:  #())
          else
            let: "ok" := (GoAlloc go.bool #()) in
            let: "recv_val" := (GoAlloc T2 #()) in
            let: "selected" := (GoAlloc go.bool #()) in
            let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := #false in
            (Channel__TryReceiveⁱᵐᵖˡ (![go.PointerType (Channel T2)] "ch2")) "$a0") in
            let: "$r0" := "$ret0" in
            let: "$r1" := "$ret1" in
            let: "$r2" := "$ret2" in
            do:  ("selected" <-[go.bool] "$r0");;;
            do:  ("recv_val" <-[T2] "$r1");;;
            do:  ("ok" <-[go.bool] "$r2");;;
            (if: ![go.bool] "selected"
            then return: (#(W64 1), ![T1] "zero1", ![T2] "recv_val", ![T3] "zero3", ![go.bool] "ok")
            else do:  #()))
        else
          (if: (![SelectDir] "dir3") =⟨go.uint64⟩ SelectSend
          then
            (if: let: "$a0" := (![T3] "val3") in
            let: "$a1" := #false in
            (Channel__TrySendⁱᵐᵖˡ (![go.PointerType (Channel T3)] "ch3")) "$a0" "$a1"
            then return: (#(W64 2), ![T1] "zero1", ![T2] "zero2", ![T3] "zero3", #false)
            else do:  #())
          else
            let: "ok" := (GoAlloc go.bool #()) in
            let: "recv_val" := (GoAlloc T3 #()) in
            let: "selected" := (GoAlloc go.bool #()) in
            let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := #false in
            (Channel__TryReceiveⁱᵐᵖˡ (![go.PointerType (Channel T3)] "ch3")) "$a0") in
            let: "$r0" := "$ret0" in
            let: "$r1" := "$ret1" in
            let: "$r2" := "$ret2" in
            do:  ("selected" <-[go.bool] "$r0");;;
            do:  ("recv_val" <-[T3] "$r1");;;
            do:  ("ok" <-[go.bool] "$r2");;;
            (if: ![go.bool] "selected"
            then return: (#(W64 2), ![T1] "zero1", ![T2] "zero2", ![T3] "recv_val", ![go.bool] "ok")
            else do:  #()))))));;;
    return: (#(W64 3), ![T1] "zero1", ![T2] "zero2", ![T3] "zero3", #false)).

Definition functions' : list (go_string * val) := [(NewChannel, NewChannelⁱᵐᵖˡ); (NonBlockingSelect1, NonBlockingSelect1ⁱᵐᵖˡ); (BlockingSelect2, BlockingSelect2ⁱᵐᵖˡ); (NonBlockingSelect2, NonBlockingSelect2ⁱᵐᵖˡ); (BlockingSelect3, BlockingSelect3ⁱᵐᵖˡ); (NonBlockingSelect3, NonBlockingSelect3ⁱᵐᵖˡ)].

#[global] Instance info' : PkgInfo channel.channel :=
  {|
    pkg_imported_pkgs := [code.github_com.goose_lang.primitive.primitive];
  |}.

Definition initialize' : val :=
  λ: <>,
    package.init channel.channel (λ: <>,
      exception_do (do:  (primitive.initialize' #()))
      ).

End code.
End channel.
