(* autogenerated from github.com/goose-lang/goose/model/channel *)
Require Export New.code.github_com.goose_lang.primitive.
Require Export New.code.sync.

From New.golang Require Import defn.
Definition channel : go_string := "github.com/goose-lang/goose/model/channel".

Module channel.

Module OfferState. Definition id : go_string := "github.com/goose-lang/goose/model/channel.OfferState"%go. End OfferState.
Module Channel. Definition id : go_string := "github.com/goose-lang/goose/model/channel.Channel"%go. End Channel.
Module SelectDir. Definition id : go_string := "github.com/goose-lang/goose/model/channel.SelectDir"%go. End SelectDir.
Module SelectCase. Definition id : go_string := "github.com/goose-lang/goose/model/channel.SelectCase"%go. End SelectCase.

Section code.
Context `{ffi_syntax}.


Definition OfferState : go_type := uint64T.

Definition Buffered : val := #(W64 0).

Definition Idle : val := #(W64 1).

Definition SndWait : val := #(W64 2).

Definition RcvWait : val := #(W64 3).

Definition SndDone : val := #(W64 4).

Definition RcvDone : val := #(W64 5).

Definition Closed : val := #(W64 6).

Definition Channel : val :=
  λ: "T", type.structT [
    (#"lock"%go, #ptrT);
    (#"state"%go, #OfferState);
    (#"buffer"%go, #sliceT);
    (#"cap"%go, #uint64T);
    (#"v"%go, "T")
  ].

Definition NewChannelRef : go_string := "github.com/goose-lang/goose/model/channel.NewChannelRef"%go.

(* buffer_size = 0 is an unbuffered channel

   go: channel.go:33:6 *)
Definition NewChannelRefⁱᵐᵖˡ : val :=
  λ: "T" "buffer_size",
    exception_do (let: "buffer_size" := (mem.alloc "buffer_size") in
    let: "local_state" := (mem.alloc (type.zero_val #OfferState)) in
    let: "$r0" := Idle in
    do:  ("local_state" <-[#OfferState] "$r0");;;
    (if: (![#uint64T] "buffer_size") > #(W64 0)
    then
      let: "$r0" := Buffered in
      do:  ("local_state" <-[#OfferState] "$r0")
    else do:  #());;;
    return: (mem.alloc (let: "$buffer" := (slice.make2 "T" #(W64 0)) in
     let: "$lock" := (mem.alloc (type.zero_val #sync.Mutex)) in
     let: "$cap" := (![#uint64T] "buffer_size") in
     let: "$state" := (![#OfferState] "local_state") in
     struct.make (Channel "T") [{
       "lock" ::= "$lock";
       "state" ::= "$state";
       "buffer" ::= "$buffer";
       "cap" ::= "$cap";
       "v" ::= type.zero_val "T"
     }]))).

(* c.Send(val)

   is equivalent to:

   c <- val

   go: channel.go:51:22 *)
Definition Channel__Sendⁱᵐᵖˡ : val :=
  λ: "c" "T" "v",
    exception_do (let: "c" := (mem.alloc "c") in
    let: "v" := (mem.alloc "v") in
    (if: (![#ptrT] "c") = #null
    then
      (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
        do:  #())
    else do:  #());;;
    (for: (λ: <>, (~ (let: "$a0" := (!["T"] "v") in
    let: "$a1" := #true in
    (method_call #(ptrT.id Channel.id) #"TrySend"%go (![#ptrT] "c") "T") "$a0" "$a1"))); (λ: <>, #()) := λ: <>,
      do:  #());;;
    return: #()).

(* go: channel.go:67:22 *)
Definition Channel__Receiveⁱᵐᵖˡ : val :=
  λ: "c" "T" <>,
    exception_do (let: "c" := (mem.alloc "c") in
    (if: (![#ptrT] "c") = #null
    then
      (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
        do:  #())
    else do:  #());;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "ok" := (mem.alloc (type.zero_val #boolT)) in
      let: "v" := (mem.alloc (type.zero_val "T")) in
      let: "success" := (mem.alloc (type.zero_val #boolT)) in
      let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := #true in
      (method_call #(ptrT.id Channel.id) #"TryReceive"%go (![#ptrT] "c") "T") "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      let: "$r2" := "$ret2" in
      do:  ("success" <-[#boolT] "$r0");;;
      do:  ("v" <-["T"] "$r1");;;
      do:  ("ok" <-[#boolT] "$r2");;;
      (if: ![#boolT] "success"
      then return: (!["T"] "v", ![#boolT] "ok")
      else do:  #()))).

(* This is a non-blocking attempt at closing. The only reason close blocks ever is because there
   may be successful exchanges that need to complete, which is equivalent to the go runtime where
   the closer must still obtain the channel's lock

   go: channel.go:84:22 *)
Definition Channel__TryCloseⁱᵐᵖˡ : val :=
  λ: "c" "T" <>,
    exception_do (let: "c" := (mem.alloc "c") in
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
    let: "$sw" := (![#OfferState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) in
    (if: "$sw" = Closed
    then
      do:  (let: "$a0" := (interface.make #stringT.id #"close of closed channel"%go) in
      Panic "$a0")
    else
      (if: ("$sw" = Buffered) || ("$sw" = Idle)
      then
        let: "$r0" := Closed in
        do:  ((struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c")) <-[#OfferState] "$r0");;;
        do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
        return: (#true)
      else
        do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
        return: (#false)))).

(* c.Close()

   is equivalent to:

   close(c)

   go: channel.go:106:22 *)
Definition Channel__Closeⁱᵐᵖˡ : val :=
  λ: "c" "T" <>,
    exception_do (let: "c" := (mem.alloc "c") in
    (if: (![#ptrT] "c") = #null
    then
      do:  (let: "$a0" := (interface.make #stringT.id #"close of nil channel"%go) in
      Panic "$a0")
    else do:  #());;;
    (for: (λ: <>, (~ ((method_call #(ptrT.id Channel.id) #"TryClose"%go (![#ptrT] "c") "T") #()))); (λ: <>, #()) := λ: <>,
      do:  #());;;
    return: #()).

(* v := c.ReceiveDiscardOk

   is equivalent to:
   v := c<-
   It seems like Go requires ignored return values to be annotated with _ but channels don't
   require this so this will need to be translated.

   go: channel.go:120:22 *)
Definition Channel__ReceiveDiscardOkⁱᵐᵖˡ : val :=
  λ: "c" "T" <>,
    exception_do (let: "c" := (mem.alloc "c") in
    let: "return_val" := (mem.alloc (type.zero_val "T")) in
    let: ("$ret0", "$ret1") := ((method_call #(ptrT.id Channel.id) #"Receive"%go (![#ptrT] "c") "T") #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("return_val" <-["T"] "$r0");;;
    do:  "$r1";;;
    return: (!["T"] "return_val")).

(* Non-blocking receive function used for select statements.
   The blocking parameter here is used to determine whether or not we will make an offer to a
   waiting sender. If true, we will make an offer since blocking receive is modeled as a for loop
   around nonblocking TryReceive. If false, we don't make an offer since we don't need to match
   with another non-blocking send.

   go: channel.go:131:22 *)
Definition Channel__TryReceiveⁱᵐᵖˡ : val :=
  λ: "c" "T" "blocking",
    exception_do (let: "c" := (mem.alloc "c") in
    let: "blocking" := (mem.alloc "blocking") in
    let: "local_val" := (mem.alloc (type.zero_val "T")) in
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
    let: "$sw" := (![#OfferState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) in
    (if: "$sw" = Buffered
    then
      let: "v" := (mem.alloc (type.zero_val "T")) in
      (if: int_gt (let: "$a0" := (![#sliceT] (struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c"))) in
      slice.len "$a0") #(W64 0)
      then
        let: "val_copy" := (mem.alloc (type.zero_val "T")) in
        let: "$r0" := (!["T"] (slice.elem_ref "T" (![#sliceT] (struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c"))) #(W64 0))) in
        do:  ("val_copy" <-["T"] "$r0");;;
        let: "$r0" := (let: "$s" := (![#sliceT] (struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c"))) in
        slice.slice "T" "$s" #(W64 1) (slice.len "$s")) in
        do:  ((struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c")) <-[#sliceT] "$r0");;;
        do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
        return: (#true, !["T"] "val_copy", #true)
      else do:  #());;;
      do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
      return: (#false, !["T"] "v", #true)
    else
      (if: "$sw" = Closed
      then
        (if: int_gt (let: "$a0" := (![#sliceT] (struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c"))) in
        slice.len "$a0") #(W64 0)
        then
          let: "val_copy" := (mem.alloc (type.zero_val "T")) in
          let: "$r0" := (!["T"] (slice.elem_ref "T" (![#sliceT] (struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c"))) #(W64 0))) in
          do:  ("val_copy" <-["T"] "$r0");;;
          let: "$r0" := (let: "$s" := (![#sliceT] (struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c"))) in
          slice.slice "T" "$s" #(W64 1) (slice.len "$s")) in
          do:  ((struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c")) <-[#sliceT] "$r0");;;
          do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
          return: (#true, !["T"] "val_copy", #true)
        else do:  #());;;
        do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
        return: (#true, !["T"] "local_val", #false)
      else
        (if: "$sw" = SndWait
        then
          let: "$r0" := (!["T"] (struct.field_ref (Channel "T") #"v"%go (![#ptrT] "c"))) in
          do:  ("local_val" <-["T"] "$r0");;;
          let: "$r0" := RcvDone in
          do:  ((struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c")) <-[#OfferState] "$r0");;;
          do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
          return: (#true, !["T"] "local_val", #true)
        else
          (if: "$sw" = Idle
          then
            (if: ![#boolT] "blocking"
            then
              let: "$r0" := RcvWait in
              do:  ((struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c")) <-[#OfferState] "$r0");;;
              do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
              do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
              let: "$sw" := (![#OfferState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) in
              (if: "$sw" = RcvWait
              then
                let: "$r0" := Idle in
                do:  ((struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c")) <-[#OfferState] "$r0");;;
                do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
                return: (#false, !["T"] "local_val", #true)
              else
                (if: "$sw" = SndDone
                then
                  let: "$r0" := Idle in
                  do:  ((struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c")) <-[#OfferState] "$r0");;;
                  let: "$r0" := (!["T"] (struct.field_ref (Channel "T") #"v"%go (![#ptrT] "c"))) in
                  do:  ("local_val" <-["T"] "$r0");;;
                  do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
                  return: (#true, !["T"] "local_val", #true)
                else
                  do:  (let: "$a0" := (interface.make #stringT.id #"not supposed to be here!"%go) in
                  Panic "$a0")))
            else do:  #());;;
            do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
            return: (#false, !["T"] "local_val", #true)
          else
            do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
            return: (#false, !["T"] "local_val", #true)))))).

(* Non-Blocking send operation for select statements. Blocking send and blocking select
   statements simply call this in a for loop until it returns true.

   go: channel.go:196:22 *)
Definition Channel__TrySendⁱᵐᵖˡ : val :=
  λ: "c" "T" "val" "blocking",
    exception_do (let: "c" := (mem.alloc "c") in
    let: "blocking" := (mem.alloc "blocking") in
    let: "val" := (mem.alloc "val") in
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
    let: "$sw" := (![#OfferState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) in
    (if: "$sw" = Closed
    then
      do:  (let: "$a0" := (interface.make #stringT.id #"send on closed channel"%go) in
      Panic "$a0")
    else
      (if: "$sw" = Buffered
      then
        (if: int_lt (let: "$a0" := (![#sliceT] (struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c"))) in
        slice.len "$a0") (u_to_w64 (![#uint64T] (struct.field_ref (Channel "T") #"cap"%go (![#ptrT] "c"))))
        then
          let: "$r0" := (let: "$a0" := (![#sliceT] (struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c"))) in
          let: "$a1" := ((let: "$sl0" := (!["T"] "val") in
          slice.literal "T" ["$sl0"])) in
          (slice.append "T") "$a0" "$a1") in
          do:  ((struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c")) <-[#sliceT] "$r0");;;
          do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
          return: (#true)
        else do:  #());;;
        do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
        return: (#false)
      else
        (if: "$sw" = RcvWait
        then
          let: "$r0" := SndDone in
          do:  ((struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c")) <-[#OfferState] "$r0");;;
          let: "$r0" := (!["T"] "val") in
          do:  ((struct.field_ref (Channel "T") #"v"%go (![#ptrT] "c")) <-["T"] "$r0");;;
          do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
          return: (#true)
        else
          (if: "$sw" = Idle
          then
            (if: ![#boolT] "blocking"
            then
              let: "$r0" := SndWait in
              do:  ((struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c")) <-[#OfferState] "$r0");;;
              let: "$r0" := (!["T"] "val") in
              do:  ((struct.field_ref (Channel "T") #"v"%go (![#ptrT] "c")) <-["T"] "$r0");;;
              do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
              do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
              let: "$sw" := (![#OfferState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) in
              (if: "$sw" = RcvDone
              then
                let: "$r0" := Idle in
                do:  ((struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c")) <-[#OfferState] "$r0");;;
                do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
                return: (#true)
              else
                (if: "$sw" = SndWait
                then
                  let: "$r0" := Idle in
                  do:  ((struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c")) <-[#OfferState] "$r0");;;
                  do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
                  return: (#false)
                else
                  do:  (let: "$a0" := (interface.make #stringT.id #"Invalid state transition with open receive offer"%go) in
                  Panic "$a0")))
            else do:  #());;;
            do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
            return: (#false)
          else
            do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
            return: (#false)))))).

(* c.Len()

   is equivalent to:
   len(c)

   This might not be worth specifying since it is hard to make good use of channel length
   semantics.

   go: channel.go:257:22 *)
Definition Channel__Lenⁱᵐᵖˡ : val :=
  λ: "c" "T" <>,
    exception_do (let: "c" := (mem.alloc "c") in
    (if: (![#ptrT] "c") = #null
    then return: (#(W64 0))
    else do:  #());;;
    let: "chan_len" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("chan_len" <-[#uint64T] "$r0");;;
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
    let: "$r0" := (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c"))) in
    slice.len "$a0")) in
    do:  ("chan_len" <-[#uint64T] "$r0");;;
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref (Channel "T") #"lock"%go (![#ptrT] "c")))) #());;;
    return: (![#uint64T] "chan_len")).

(* c.Cap()

   is equivalent to:
   cap(c)

   go: channel.go:272:22 *)
Definition Channel__Capⁱᵐᵖˡ : val :=
  λ: "c" "T" <>,
    exception_do (let: "c" := (mem.alloc "c") in
    (if: (![#ptrT] "c") = #null
    then return: (#(W64 0))
    else do:  #());;;
    return: (![#uint64T] (struct.field_ref (Channel "T") #"cap"%go (![#ptrT] "c")))).

Definition SelectDir : go_type := uint64T.

(* case Chan <- Send *)
Definition SelectSend : val := #(W64 0).

(* case <-Chan: *)
Definition SelectRecv : val := #(W64 1).

Definition SelectCase : val :=
  λ: "T", type.structT [
    (#"channel"%go, #ptrT);
    (#"dir"%go, #SelectDir);
    (#"Value"%go, "T");
    (#"Ok"%go, #boolT)
  ].

Definition NewSendCase : go_string := "github.com/goose-lang/goose/model/channel.NewSendCase"%go.

(* go: channel.go:298:6 *)
Definition NewSendCaseⁱᵐᵖˡ : val :=
  λ: "T" "channel" "value",
    exception_do (let: "value" := (mem.alloc "value") in
    let: "channel" := (mem.alloc "channel") in
    return: (mem.alloc (let: "$channel" := (![#ptrT] "channel") in
     let: "$dir" := SelectSend in
     let: "$Value" := (!["T"] "value") in
     struct.make (SelectCase "T") [{
       "channel" ::= "$channel";
       "dir" ::= "$dir";
       "Value" ::= "$Value";
       "Ok" ::= type.zero_val #boolT
     }]))).

Definition NewRecvCase : go_string := "github.com/goose-lang/goose/model/channel.NewRecvCase"%go.

(* go: channel.go:306:6 *)
Definition NewRecvCaseⁱᵐᵖˡ : val :=
  λ: "T" "channel",
    exception_do (let: "channel" := (mem.alloc "channel") in
    return: (mem.alloc (let: "$channel" := (![#ptrT] "channel") in
     let: "$dir" := SelectRecv in
     struct.make (SelectCase "T") [{
       "channel" ::= "$channel";
       "dir" ::= "$dir";
       "Value" ::= type.zero_val "T";
       "Ok" ::= type.zero_val #boolT
     }]))).

Definition TrySelect : go_string := "github.com/goose-lang/goose/model/channel.TrySelect"%go.

(* Uses the applicable Try<Operation> function on the select case's channel. Default is always
   selectable so simply returns true.

   go: channel.go:315:6 *)
Definition TrySelectⁱᵐᵖˡ : val :=
  λ: "T" "select_case" "blocking",
    exception_do (let: "blocking" := (mem.alloc "blocking") in
    let: "select_case" := (mem.alloc "select_case") in
    let: "channel" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (![#ptrT] (struct.field_ref (SelectCase "T") #"channel"%go (![#ptrT] "select_case"))) in
    do:  ("channel" <-[#ptrT] "$r0");;;
    (if: (![#ptrT] "channel") = #null
    then return: (#false)
    else do:  #());;;
    (if: (![#SelectDir] (struct.field_ref (SelectCase "T") #"dir"%go (![#ptrT] "select_case"))) = SelectSend
    then
      return: (let: "$a0" := (!["T"] (struct.field_ref (SelectCase "T") #"Value"%go (![#ptrT] "select_case"))) in
       let: "$a1" := (![#boolT] "blocking") in
       (method_call #(ptrT.id Channel.id) #"TrySend"%go (![#ptrT] "channel") "T") "$a0" "$a1")
    else do:  #());;;
    (if: (![#SelectDir] (struct.field_ref (SelectCase "T") #"dir"%go (![#ptrT] "select_case"))) = SelectRecv
    then
      let: "item" := (mem.alloc (type.zero_val "T")) in
      let: "ok" := (mem.alloc (type.zero_val #boolT)) in
      let: "selected" := (mem.alloc (type.zero_val #boolT)) in
      let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#boolT] "blocking") in
      (method_call #(ptrT.id Channel.id) #"TryReceive"%go (![#ptrT] "channel") "T") "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      let: "$r2" := "$ret2" in
      do:  ("selected" <-[#boolT] "$r0");;;
      do:  ("item" <-["T"] "$r1");;;
      do:  ("ok" <-[#boolT] "$r2");;;
      let: "$r0" := (!["T"] "item") in
      do:  ((struct.field_ref (SelectCase "T") #"Value"%go (![#ptrT] "select_case")) <-["T"] "$r0");;;
      let: "$r0" := (![#boolT] "ok") in
      do:  ((struct.field_ref (SelectCase "T") #"Ok"%go (![#ptrT] "select_case")) <-[#boolT] "$r0");;;
      return: (![#boolT] "selected")
    else do:  #());;;
    return: (#false)).

Definition Select1 : go_string := "github.com/goose-lang/goose/model/channel.Select1"%go.

(* Select1 performs a select operation on 1 case. This is used for Send and
   Receive as well, since these channel operations in Go are equivalent to
   a single case select statement with no default.

   go: channel.go:342:6 *)
Definition Select1ⁱᵐᵖˡ : val :=
  λ: "T1" "case1" "blocking",
    exception_do (let: "blocking" := (mem.alloc "blocking") in
    let: "case1" := (mem.alloc "case1") in
    let: "selected" := (mem.alloc (type.zero_val #boolT)) in
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "$r0" := (let: "$a0" := (![#ptrT] "case1") in
      let: "$a1" := (![#boolT] "blocking") in
      ((func_call #TrySelect) "T1") "$a0" "$a1") in
      do:  ("selected" <-[#boolT] "$r0");;;
      (if: (![#boolT] "selected") || (~ (![#boolT] "blocking"))
      then break: #()
      else do:  #()));;;
    return: (![#boolT] "selected")).

Definition TrySelectCase2 : go_string := "github.com/goose-lang/goose/model/channel.TrySelectCase2"%go.

(* go: channel.go:355:6 *)
Definition TrySelectCase2ⁱᵐᵖˡ : val :=
  λ: "T1" "T2" "index" "case1" "case2" "blocking",
    exception_do (let: "blocking" := (mem.alloc "blocking") in
    let: "case2" := (mem.alloc "case2") in
    let: "case1" := (mem.alloc "case1") in
    let: "index" := (mem.alloc "index") in
    (if: (![#uint64T] "index") = #(W64 0)
    then
      return: (let: "$a0" := (![#ptrT] "case1") in
       let: "$a1" := (![#boolT] "blocking") in
       ((func_call #TrySelect) "T1") "$a0" "$a1")
    else do:  #());;;
    (if: (![#uint64T] "index") = #(W64 1)
    then
      return: (let: "$a0" := (![#ptrT] "case2") in
       let: "$a1" := (![#boolT] "blocking") in
       ((func_call #TrySelect) "T2") "$a0" "$a1")
    else do:  #());;;
    do:  (let: "$a0" := (interface.make #stringT.id #"index needs to be 0 or 1"%go) in
    Panic "$a0")).

Definition Select2 : go_string := "github.com/goose-lang/goose/model/channel.Select2"%go.

(* go: channel.go:368:6 *)
Definition Select2ⁱᵐᵖˡ : val :=
  λ: "T1" "T2" "case1" "case2" "blocking",
    exception_do (let: "blocking" := (mem.alloc "blocking") in
    let: "case2" := (mem.alloc "case2") in
    let: "case1" := (mem.alloc "case1") in
    let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (((func_call #primitive.RandomUint64) #()) `rem` #(W64 2)) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (if: let: "$a0" := (![#uint64T] "i") in
    let: "$a1" := (![#ptrT] "case1") in
    let: "$a2" := (![#ptrT] "case2") in
    let: "$a3" := (![#boolT] "blocking") in
    ((func_call #TrySelectCase2) "T1" "T2") "$a0" "$a1" "$a2" "$a3"
    then return: (![#uint64T] "i")
    else do:  #());;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (if: let: "$a0" := (![#ptrT] "case1") in
      let: "$a1" := (![#boolT] "blocking") in
      ((func_call #TrySelect) "T1") "$a0" "$a1"
      then return: (#(W64 0))
      else do:  #());;;
      (if: let: "$a0" := (![#ptrT] "case2") in
      let: "$a1" := (![#boolT] "blocking") in
      ((func_call #TrySelect) "T2") "$a0" "$a1"
      then return: (#(W64 1))
      else do:  #());;;
      (if: (~ (![#boolT] "blocking"))
      then return: (#(W64 2))
      else do:  #()))).

Definition TrySelectCase3 : go_string := "github.com/goose-lang/goose/model/channel.TrySelectCase3"%go.

(* go: channel.go:392:6 *)
Definition TrySelectCase3ⁱᵐᵖˡ : val :=
  λ: "T1" "T2" "T3" "index" "case1" "case2" "case3" "blocking",
    exception_do (let: "blocking" := (mem.alloc "blocking") in
    let: "case3" := (mem.alloc "case3") in
    let: "case2" := (mem.alloc "case2") in
    let: "case1" := (mem.alloc "case1") in
    let: "index" := (mem.alloc "index") in
    (if: (![#uint64T] "index") = #(W64 0)
    then
      return: (let: "$a0" := (![#ptrT] "case1") in
       let: "$a1" := (![#boolT] "blocking") in
       ((func_call #TrySelect) "T1") "$a0" "$a1")
    else do:  #());;;
    (if: (![#uint64T] "index") = #(W64 1)
    then
      return: (let: "$a0" := (![#ptrT] "case2") in
       let: "$a1" := (![#boolT] "blocking") in
       ((func_call #TrySelect) "T2") "$a0" "$a1")
    else do:  #());;;
    (if: (![#uint64T] "index") = #(W64 2)
    then
      return: (let: "$a0" := (![#ptrT] "case3") in
       let: "$a1" := (![#boolT] "blocking") in
       ((func_call #TrySelect) "T3") "$a0" "$a1")
    else do:  #());;;
    do:  (let: "$a0" := (interface.make #stringT.id #"index needs to be 0, 1 or 2"%go) in
    Panic "$a0")).

Definition Select3 : go_string := "github.com/goose-lang/goose/model/channel.Select3"%go.

(* go: channel.go:409:6 *)
Definition Select3ⁱᵐᵖˡ : val :=
  λ: "T1" "T2" "T3" "case1" "case2" "case3" "blocking",
    exception_do (let: "blocking" := (mem.alloc "blocking") in
    let: "case3" := (mem.alloc "case3") in
    let: "case2" := (mem.alloc "case2") in
    let: "case1" := (mem.alloc "case1") in
    let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (((func_call #primitive.RandomUint64) #()) `rem` #(W64 3)) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (if: let: "$a0" := (![#uint64T] "i") in
    let: "$a1" := (![#ptrT] "case1") in
    let: "$a2" := (![#ptrT] "case2") in
    let: "$a3" := (![#ptrT] "case3") in
    let: "$a4" := (![#boolT] "blocking") in
    ((func_call #TrySelectCase3) "T1" "T2" "T3") "$a0" "$a1" "$a2" "$a3" "$a4"
    then return: (![#uint64T] "i")
    else do:  #());;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (if: let: "$a0" := (![#ptrT] "case1") in
      let: "$a1" := (![#boolT] "blocking") in
      ((func_call #TrySelect) "T1") "$a0" "$a1"
      then return: (#(W64 0))
      else do:  #());;;
      (if: let: "$a0" := (![#ptrT] "case2") in
      let: "$a1" := (![#boolT] "blocking") in
      ((func_call #TrySelect) "T2") "$a0" "$a1"
      then return: (#(W64 1))
      else do:  #());;;
      (if: let: "$a0" := (![#ptrT] "case3") in
      let: "$a1" := (![#boolT] "blocking") in
      ((func_call #TrySelect) "T3") "$a0" "$a1"
      then return: (#(W64 2))
      else do:  #());;;
      (if: (~ (![#boolT] "blocking"))
      then return: (#(W64 3))
      else do:  #()))).

Definition TrySelectCase4 : go_string := "github.com/goose-lang/goose/model/channel.TrySelectCase4"%go.

(* go: channel.go:436:6 *)
Definition TrySelectCase4ⁱᵐᵖˡ : val :=
  λ: "T1" "T2" "T3" "T4" "index" "case1" "case2" "case3" "case4" "blocking",
    exception_do (let: "blocking" := (mem.alloc "blocking") in
    let: "case4" := (mem.alloc "case4") in
    let: "case3" := (mem.alloc "case3") in
    let: "case2" := (mem.alloc "case2") in
    let: "case1" := (mem.alloc "case1") in
    let: "index" := (mem.alloc "index") in
    (if: (![#uint64T] "index") = #(W64 0)
    then
      return: (let: "$a0" := (![#ptrT] "case1") in
       let: "$a1" := (![#boolT] "blocking") in
       ((func_call #TrySelect) "T1") "$a0" "$a1")
    else do:  #());;;
    (if: (![#uint64T] "index") = #(W64 1)
    then
      return: (let: "$a0" := (![#ptrT] "case2") in
       let: "$a1" := (![#boolT] "blocking") in
       ((func_call #TrySelect) "T2") "$a0" "$a1")
    else do:  #());;;
    (if: (![#uint64T] "index") = #(W64 2)
    then
      return: (let: "$a0" := (![#ptrT] "case3") in
       let: "$a1" := (![#boolT] "blocking") in
       ((func_call #TrySelect) "T3") "$a0" "$a1")
    else do:  #());;;
    (if: (![#uint64T] "index") = #(W64 3)
    then
      return: (let: "$a0" := (![#ptrT] "case4") in
       let: "$a1" := (![#boolT] "blocking") in
       ((func_call #TrySelect) "T4") "$a0" "$a1")
    else do:  #());;;
    do:  (let: "$a0" := (interface.make #stringT.id #"index needs to be 0, 1, 2 or 3"%go) in
    Panic "$a0")).

Definition Select4 : go_string := "github.com/goose-lang/goose/model/channel.Select4"%go.

(* go: channel.go:457:6 *)
Definition Select4ⁱᵐᵖˡ : val :=
  λ: "T1" "T2" "T3" "T4" "case1" "case2" "case3" "case4" "blocking",
    exception_do (let: "blocking" := (mem.alloc "blocking") in
    let: "case4" := (mem.alloc "case4") in
    let: "case3" := (mem.alloc "case3") in
    let: "case2" := (mem.alloc "case2") in
    let: "case1" := (mem.alloc "case1") in
    let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (((func_call #primitive.RandomUint64) #()) `rem` #(W64 4)) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (if: let: "$a0" := (![#uint64T] "i") in
    let: "$a1" := (![#ptrT] "case1") in
    let: "$a2" := (![#ptrT] "case2") in
    let: "$a3" := (![#ptrT] "case3") in
    let: "$a4" := (![#ptrT] "case4") in
    let: "$a5" := (![#boolT] "blocking") in
    ((func_call #TrySelectCase4) "T1" "T2" "T3" "T4") "$a0" "$a1" "$a2" "$a3" "$a4" "$a5"
    then return: (![#uint64T] "i")
    else do:  #());;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (if: let: "$a0" := (![#ptrT] "case1") in
      let: "$a1" := (![#boolT] "blocking") in
      ((func_call #TrySelect) "T1") "$a0" "$a1"
      then return: (#(W64 0))
      else do:  #());;;
      (if: let: "$a0" := (![#ptrT] "case2") in
      let: "$a1" := (![#boolT] "blocking") in
      ((func_call #TrySelect) "T2") "$a0" "$a1"
      then return: (#(W64 1))
      else do:  #());;;
      (if: let: "$a0" := (![#ptrT] "case3") in
      let: "$a1" := (![#boolT] "blocking") in
      ((func_call #TrySelect) "T3") "$a0" "$a1"
      then return: (#(W64 2))
      else do:  #());;;
      (if: let: "$a0" := (![#ptrT] "case4") in
      let: "$a1" := (![#boolT] "blocking") in
      ((func_call #TrySelect) "T4") "$a0" "$a1"
      then return: (#(W64 3))
      else do:  #());;;
      (if: (~ (![#boolT] "blocking"))
      then return: (#(W64 4))
      else do:  #()))).

Definition TrySelectCase5 : go_string := "github.com/goose-lang/goose/model/channel.TrySelectCase5"%go.

(* go: channel.go:488:6 *)
Definition TrySelectCase5ⁱᵐᵖˡ : val :=
  λ: "T1" "T2" "T3" "T4" "T5" "index" "case1" "case2" "case3" "case4" "case5" "blocking",
    exception_do (let: "blocking" := (mem.alloc "blocking") in
    let: "case5" := (mem.alloc "case5") in
    let: "case4" := (mem.alloc "case4") in
    let: "case3" := (mem.alloc "case3") in
    let: "case2" := (mem.alloc "case2") in
    let: "case1" := (mem.alloc "case1") in
    let: "index" := (mem.alloc "index") in
    (if: (![#uint64T] "index") = #(W64 0)
    then
      return: (let: "$a0" := (![#ptrT] "case1") in
       let: "$a1" := (![#boolT] "blocking") in
       ((func_call #TrySelect) "T1") "$a0" "$a1")
    else do:  #());;;
    (if: (![#uint64T] "index") = #(W64 1)
    then
      return: (let: "$a0" := (![#ptrT] "case2") in
       let: "$a1" := (![#boolT] "blocking") in
       ((func_call #TrySelect) "T2") "$a0" "$a1")
    else do:  #());;;
    (if: (![#uint64T] "index") = #(W64 2)
    then
      return: (let: "$a0" := (![#ptrT] "case3") in
       let: "$a1" := (![#boolT] "blocking") in
       ((func_call #TrySelect) "T3") "$a0" "$a1")
    else do:  #());;;
    (if: (![#uint64T] "index") = #(W64 3)
    then
      return: (let: "$a0" := (![#ptrT] "case4") in
       let: "$a1" := (![#boolT] "blocking") in
       ((func_call #TrySelect) "T4") "$a0" "$a1")
    else do:  #());;;
    (if: (![#uint64T] "index") = #(W64 4)
    then
      return: (let: "$a0" := (![#ptrT] "case5") in
       let: "$a1" := (![#boolT] "blocking") in
       ((func_call #TrySelect) "T5") "$a0" "$a1")
    else do:  #());;;
    do:  (let: "$a0" := (interface.make #stringT.id #"index needs to be 0, 1, 2, 3 or 4"%go) in
    Panic "$a0")).

Definition Select5 : go_string := "github.com/goose-lang/goose/model/channel.Select5"%go.

(* go: channel.go:513:6 *)
Definition Select5ⁱᵐᵖˡ : val :=
  λ: "T1" "T2" "T3" "T4" "T5" "case1" "case2" "case3" "case4" "case5" "blocking",
    exception_do (let: "blocking" := (mem.alloc "blocking") in
    let: "case5" := (mem.alloc "case5") in
    let: "case4" := (mem.alloc "case4") in
    let: "case3" := (mem.alloc "case3") in
    let: "case2" := (mem.alloc "case2") in
    let: "case1" := (mem.alloc "case1") in
    let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (((func_call #primitive.RandomUint64) #()) `rem` #(W64 5)) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (if: let: "$a0" := (![#uint64T] "i") in
    let: "$a1" := (![#ptrT] "case1") in
    let: "$a2" := (![#ptrT] "case2") in
    let: "$a3" := (![#ptrT] "case3") in
    let: "$a4" := (![#ptrT] "case4") in
    let: "$a5" := (![#ptrT] "case5") in
    let: "$a6" := (![#boolT] "blocking") in
    ((func_call #TrySelectCase5) "T1" "T2" "T3" "T4" "T5") "$a0" "$a1" "$a2" "$a3" "$a4" "$a5" "$a6"
    then return: (![#uint64T] "i")
    else do:  #());;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (if: let: "$a0" := (![#ptrT] "case1") in
      let: "$a1" := (![#boolT] "blocking") in
      ((func_call #TrySelect) "T1") "$a0" "$a1"
      then return: (#(W64 0))
      else do:  #());;;
      (if: let: "$a0" := (![#ptrT] "case2") in
      let: "$a1" := (![#boolT] "blocking") in
      ((func_call #TrySelect) "T2") "$a0" "$a1"
      then return: (#(W64 1))
      else do:  #());;;
      (if: let: "$a0" := (![#ptrT] "case3") in
      let: "$a1" := (![#boolT] "blocking") in
      ((func_call #TrySelect) "T3") "$a0" "$a1"
      then return: (#(W64 2))
      else do:  #());;;
      (if: let: "$a0" := (![#ptrT] "case4") in
      let: "$a1" := (![#boolT] "blocking") in
      ((func_call #TrySelect) "T4") "$a0" "$a1"
      then return: (#(W64 3))
      else do:  #());;;
      (if: let: "$a0" := (![#ptrT] "case5") in
      let: "$a1" := (![#boolT] "blocking") in
      ((func_call #TrySelect) "T5") "$a0" "$a1"
      then return: (#(W64 4))
      else do:  #());;;
      (if: (~ (![#boolT] "blocking"))
      then return: (#(W64 5))
      else do:  #()))).

Definition vars' : list (go_string * go_type) := [].

Definition functions' : list (go_string * val) := [(NewChannelRef, NewChannelRefⁱᵐᵖˡ); (NewSendCase, NewSendCaseⁱᵐᵖˡ); (NewRecvCase, NewRecvCaseⁱᵐᵖˡ); (TrySelect, TrySelectⁱᵐᵖˡ); (Select1, Select1ⁱᵐᵖˡ); (TrySelectCase2, TrySelectCase2ⁱᵐᵖˡ); (Select2, Select2ⁱᵐᵖˡ); (TrySelectCase3, TrySelectCase3ⁱᵐᵖˡ); (Select3, Select3ⁱᵐᵖˡ); (TrySelectCase4, TrySelectCase4ⁱᵐᵖˡ); (Select4, Select4ⁱᵐᵖˡ); (TrySelectCase5, TrySelectCase5ⁱᵐᵖˡ); (Select5, Select5ⁱᵐᵖˡ)].

Definition msets' : list (go_string * (list (go_string * val))) := [(OfferState.id, []); (ptrT.id OfferState.id, []); (Channel.id, []); (ptrT.id Channel.id, [("Cap"%go, Channel__Capⁱᵐᵖˡ); ("Close"%go, Channel__Closeⁱᵐᵖˡ); ("Len"%go, Channel__Lenⁱᵐᵖˡ); ("Receive"%go, Channel__Receiveⁱᵐᵖˡ); ("ReceiveDiscardOk"%go, Channel__ReceiveDiscardOkⁱᵐᵖˡ); ("Send"%go, Channel__Sendⁱᵐᵖˡ); ("TryClose"%go, Channel__TryCloseⁱᵐᵖˡ); ("TryReceive"%go, Channel__TryReceiveⁱᵐᵖˡ); ("TrySend"%go, Channel__TrySendⁱᵐᵖˡ)]); (SelectDir.id, []); (ptrT.id SelectDir.id, []); (SelectCase.id, []); (ptrT.id SelectCase.id, [])].

#[global] Instance info' : PkgInfo channel.channel :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [code.sync.sync; code.github_com.goose_lang.primitive.primitive];
  |}.

Definition initialize' : val :=
  λ: <>,
    package.init #channel.channel (λ: <>,
      exception_do (do:  (primitive.initialize' #());;;
      do:  (sync.initialize' #());;;
      do:  (package.alloc channel.channel #()))
      ).

End code.
End channel.
