(* autogenerated from github.com/goose-lang/goose/model/channel *)
Require Export New.code.github_com.goose_lang.primitive.

From New.golang Require Import defn.core.
From New.golang.defn Require Export slice string interface defer builtin.
Definition channel : go_string := "github.com/goose-lang/goose/model/channel".

Module channel.

Module offerState. Definition id : go_string := "github.com/goose-lang/goose/model/channel.offerState"%go. End offerState.
Module Channel. Definition id : go_string := "github.com/goose-lang/goose/model/channel.Channel"%go. End Channel.
Module SelectDir. Definition id : go_string := "github.com/goose-lang/goose/model/channel.SelectDir"%go. End SelectDir.

Section code.
Context `{ffi_syntax}.


Definition offerState : go_type := uint64T.
#[global] Typeclasses Opaque offerState.
#[global] Opaque offerState.

Definition buffered : val := #(W64 0).

Definition idle : val := #(W64 1).

Definition sndPending : val := #(W64 2).

Definition rcvPending : val := #(W64 3).

Definition sndCommit : val := #(W64 4).

Definition rcvDone : val := #(W64 5).

Definition closed : val := #(W64 6).

Definition Channel : val :=
  λ: "T", type.structT [
    (#"cap"%go, #intT);
    (#"mu"%go, #ptrT);
    (#"state"%go, #offerState);
    (#"buffer"%go, #sliceT);
    (#"v"%go, "T")
  ].
  #[global] Typeclasses Opaque Channel.
  #[global] Opaque Channel.

Definition NewChannel : go_string := "github.com/goose-lang/goose/model/channel.NewChannel"%go.

(* go: channel.go:31:6 *)
Definition NewChannelⁱᵐᵖˡ : val :=
  λ: "T" "cap",
    exception_do (let: "cap" := (mem.alloc "cap") in
    let: "local_state" := (mem.alloc (type.zero_val #offerState)) in
    let: "$r0" := idle in
    do:  ("local_state" <-[#offerState] "$r0");;;
    (if: int_gt (![#intT] "cap") #(W64 0)
    then
      let: "$r0" := buffered in
      do:  ("local_state" <-[#offerState] "$r0")
    else do:  #());;;
    return: (mem.alloc (let: "$cap" := (![#intT] "cap") in
     let: "$mu" := (mem.alloc (type.zero_val #primitive.Mutex)) in
     let: "$buffer" := (slice.make2 "T" #(W64 0)) in
     let: "$state" := (![#offerState] "local_state") in
     struct.make (Channel "T") [{
       "cap" ::= "$cap";
       "mu" ::= "$mu";
       "state" ::= "$state";
       "buffer" ::= "$buffer";
       "v" ::= type.zero_val "T"
     }]))).

(* Non-Blocking send operation for select statements. Blocking send and blocking select
   statements simply call this in a for loop until it returns true.

   go: channel.go:46:22 *)
Definition Channel__TrySendⁱᵐᵖˡ : val :=
  λ: "c" "T" "val" "blocking",
    exception_do (let: "c" := (mem.alloc "c") in
    let: "blocking" := (mem.alloc "blocking") in
    let: "val" := (mem.alloc "val") in
    do:  ((primitive.Mutex__Lockⁱᵐᵖˡ (![#ptrT] (struct.field_ref (Channel "T") #"mu"%go (![#ptrT] "c")))) #());;;
    let: "$sw" := (![#offerState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) in
    (if: "$sw" = closed
    then
      do:  (let: "$a0" := (interface.make #stringT.id #"send on closed channel"%go) in
      Panic "$a0")
    else
      (if: "$sw" = buffered
      then
        (if: int_lt (let: "$a0" := (![#sliceT] (struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c"))) in
        slice.len "$a0") (![#intT] (struct.field_ref (Channel "T") #"cap"%go (![#ptrT] "c")))
        then
          let: "$r0" := (let: "$a0" := (![#sliceT] (struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c"))) in
          let: "$a1" := ((let: "$sl0" := (!["T"] "val") in
          slice.literal "T" ["$sl0"])) in
          (slice.append "T") "$a0" "$a1") in
          do:  ((struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c")) <-[#sliceT] "$r0");;;
          do:  ((primitive.Mutex__Unlockⁱᵐᵖˡ (![#ptrT] (struct.field_ref (Channel "T") #"mu"%go (![#ptrT] "c")))) #());;;
          return: (#true)
        else do:  #());;;
        do:  ((primitive.Mutex__Unlockⁱᵐᵖˡ (![#ptrT] (struct.field_ref (Channel "T") #"mu"%go (![#ptrT] "c")))) #());;;
        return: (#false)
      else
        (if: "$sw" = rcvPending
        then
          let: "$r0" := sndCommit in
          do:  ((struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c")) <-[#offerState] "$r0");;;
          let: "$r0" := (!["T"] "val") in
          do:  ((struct.field_ref (Channel "T") #"v"%go (![#ptrT] "c")) <-["T"] "$r0");;;
          do:  ((primitive.Mutex__Unlockⁱᵐᵖˡ (![#ptrT] (struct.field_ref (Channel "T") #"mu"%go (![#ptrT] "c")))) #());;;
          return: (#true)
        else
          (if: "$sw" = idle
          then
            (if: ![#boolT] "blocking"
            then
              let: "$r0" := sndPending in
              do:  ((struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c")) <-[#offerState] "$r0");;;
              let: "$r0" := (!["T"] "val") in
              do:  ((struct.field_ref (Channel "T") #"v"%go (![#ptrT] "c")) <-["T"] "$r0");;;
              do:  ((primitive.Mutex__Unlockⁱᵐᵖˡ (![#ptrT] (struct.field_ref (Channel "T") #"mu"%go (![#ptrT] "c")))) #());;;
              do:  ((primitive.Mutex__Lockⁱᵐᵖˡ (![#ptrT] (struct.field_ref (Channel "T") #"mu"%go (![#ptrT] "c")))) #());;;
              let: "$sw" := (![#offerState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) in
              (if: "$sw" = rcvDone
              then
                let: "$r0" := idle in
                do:  ((struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c")) <-[#offerState] "$r0");;;
                do:  ((primitive.Mutex__Unlockⁱᵐᵖˡ (![#ptrT] (struct.field_ref (Channel "T") #"mu"%go (![#ptrT] "c")))) #());;;
                return: (#true)
              else
                (if: "$sw" = sndPending
                then
                  let: "$r0" := idle in
                  do:  ((struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c")) <-[#offerState] "$r0");;;
                  do:  ((primitive.Mutex__Unlockⁱᵐᵖˡ (![#ptrT] (struct.field_ref (Channel "T") #"mu"%go (![#ptrT] "c")))) #());;;
                  return: (#false)
                else
                  do:  (let: "$a0" := (interface.make #stringT.id #"Invalid state transition with open receive offer"%go) in
                  Panic "$a0")))
            else do:  #());;;
            do:  ((primitive.Mutex__Unlockⁱᵐᵖˡ (![#ptrT] (struct.field_ref (Channel "T") #"mu"%go (![#ptrT] "c")))) #());;;
            return: (#false)
          else
            do:  ((primitive.Mutex__Unlockⁱᵐᵖˡ (![#ptrT] (struct.field_ref (Channel "T") #"mu"%go (![#ptrT] "c")))) #());;;
            return: (#false)))))).

(* c.Send(val)

   is equivalent to:

   c <- val

   go: channel.go:105:22 *)
Definition Channel__Sendⁱᵐᵖˡ : val :=
  λ: "c" "T" "v",
    exception_do (let: "c" := (mem.alloc "c") in
    let: "v" := (mem.alloc "v") in
    (if: (![#ptrT] "c") = #null
    then
      (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
        do:  #())
    else do:  #());;;
    (for: (λ: <>, (~ (let: "$a0" := (!["T"] "v") in
    let: "$a1" := #true in
    (Channel__TrySendⁱᵐᵖˡ (![#ptrT] "c") "T") "$a0" "$a1"))); (λ: <>, #()) := λ: <>,
      do:  #());;;
    return: #()).

(* Non-blocking receive function used for select statements.
   The blocking parameter here is used to determine whether or not we will make an offer to a
   waiting sender. If true, we will make an offer since blocking receive is modeled as a for loop
   around nonblocking TryReceive. If false, we don't make an offer since we don't need to match
   with another non-blocking send.

   go: channel.go:120:22 *)
Definition Channel__TryReceiveⁱᵐᵖˡ : val :=
  λ: "c" "T" "blocking",
    exception_do (let: "c" := (mem.alloc "c") in
    let: "blocking" := (mem.alloc "blocking") in
    let: "local_val" := (mem.alloc (type.zero_val "T")) in
    do:  ((primitive.Mutex__Lockⁱᵐᵖˡ (![#ptrT] (struct.field_ref (Channel "T") #"mu"%go (![#ptrT] "c")))) #());;;
    let: "$sw" := (![#offerState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) in
    (if: "$sw" = buffered
    then
      let: "v" := (mem.alloc (type.zero_val "T")) in
      (if: int_gt (let: "$a0" := (![#sliceT] (struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c"))) in
      slice.len "$a0") #(W64 0)
      then
        let: "val_copy" := (mem.alloc (type.zero_val "T")) in
        let: "$r0" := (!["T"] (slice.elem_ref "T" (![#sliceT] (struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c"))) #(W64 0))) in
        do:  ("val_copy" <-["T"] "$r0");;;
        let: "$r0" := (let: "$s" := (![#sliceT] (struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c"))) in
        slice.slice "T" "$s" #(W64 1) (slice.len "$s")) in
        do:  ((struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c")) <-[#sliceT] "$r0");;;
        do:  ((primitive.Mutex__Unlockⁱᵐᵖˡ (![#ptrT] (struct.field_ref (Channel "T") #"mu"%go (![#ptrT] "c")))) #());;;
        return: (#true, !["T"] "val_copy", #true)
      else do:  #());;;
      do:  ((primitive.Mutex__Unlockⁱᵐᵖˡ (![#ptrT] (struct.field_ref (Channel "T") #"mu"%go (![#ptrT] "c")))) #());;;
      return: (#false, !["T"] "v", #true)
    else
      (if: "$sw" = closed
      then
        (if: int_gt (let: "$a0" := (![#sliceT] (struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c"))) in
        slice.len "$a0") #(W64 0)
        then
          let: "val_copy" := (mem.alloc (type.zero_val "T")) in
          let: "$r0" := (!["T"] (slice.elem_ref "T" (![#sliceT] (struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c"))) #(W64 0))) in
          do:  ("val_copy" <-["T"] "$r0");;;
          let: "$r0" := (let: "$s" := (![#sliceT] (struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c"))) in
          slice.slice "T" "$s" #(W64 1) (slice.len "$s")) in
          do:  ((struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c")) <-[#sliceT] "$r0");;;
          do:  ((primitive.Mutex__Unlockⁱᵐᵖˡ (![#ptrT] (struct.field_ref (Channel "T") #"mu"%go (![#ptrT] "c")))) #());;;
          return: (#true, !["T"] "val_copy", #true)
        else do:  #());;;
        do:  ((primitive.Mutex__Unlockⁱᵐᵖˡ (![#ptrT] (struct.field_ref (Channel "T") #"mu"%go (![#ptrT] "c")))) #());;;
        return: (#true, !["T"] "local_val", #false)
      else
        (if: "$sw" = sndPending
        then
          let: "$r0" := (!["T"] (struct.field_ref (Channel "T") #"v"%go (![#ptrT] "c"))) in
          do:  ("local_val" <-["T"] "$r0");;;
          let: "$r0" := rcvDone in
          do:  ((struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c")) <-[#offerState] "$r0");;;
          do:  ((primitive.Mutex__Unlockⁱᵐᵖˡ (![#ptrT] (struct.field_ref (Channel "T") #"mu"%go (![#ptrT] "c")))) #());;;
          return: (#true, !["T"] "local_val", #true)
        else
          (if: "$sw" = idle
          then
            (if: ![#boolT] "blocking"
            then
              let: "$r0" := rcvPending in
              do:  ((struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c")) <-[#offerState] "$r0");;;
              do:  ((primitive.Mutex__Unlockⁱᵐᵖˡ (![#ptrT] (struct.field_ref (Channel "T") #"mu"%go (![#ptrT] "c")))) #());;;
              do:  ((primitive.Mutex__Lockⁱᵐᵖˡ (![#ptrT] (struct.field_ref (Channel "T") #"mu"%go (![#ptrT] "c")))) #());;;
              let: "$sw" := (![#offerState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) in
              (if: "$sw" = rcvPending
              then
                let: "$r0" := idle in
                do:  ((struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c")) <-[#offerState] "$r0");;;
                do:  ((primitive.Mutex__Unlockⁱᵐᵖˡ (![#ptrT] (struct.field_ref (Channel "T") #"mu"%go (![#ptrT] "c")))) #());;;
                return: (#false, !["T"] "local_val", #true)
              else
                (if: "$sw" = sndCommit
                then
                  let: "$r0" := idle in
                  do:  ((struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c")) <-[#offerState] "$r0");;;
                  let: "$r0" := (!["T"] (struct.field_ref (Channel "T") #"v"%go (![#ptrT] "c"))) in
                  do:  ("local_val" <-["T"] "$r0");;;
                  do:  ((primitive.Mutex__Unlockⁱᵐᵖˡ (![#ptrT] (struct.field_ref (Channel "T") #"mu"%go (![#ptrT] "c")))) #());;;
                  return: (#true, !["T"] "local_val", #true)
                else
                  do:  (let: "$a0" := (interface.make #stringT.id #"not supposed to be here!"%go) in
                  Panic "$a0")))
            else do:  #());;;
            do:  ((primitive.Mutex__Unlockⁱᵐᵖˡ (![#ptrT] (struct.field_ref (Channel "T") #"mu"%go (![#ptrT] "c")))) #());;;
            return: (#false, !["T"] "local_val", #true)
          else
            do:  ((primitive.Mutex__Unlockⁱᵐᵖˡ (![#ptrT] (struct.field_ref (Channel "T") #"mu"%go (![#ptrT] "c")))) #());;;
            return: (#false, !["T"] "local_val", #true)))))).

(* go: channel.go:189:22 *)
Definition Channel__Receiveⁱᵐᵖˡ : val :=
  λ: "c" "T" <>,
    exception_do (let: "c" := (mem.alloc "c") in
    (if: (![#ptrT] "c") = #null
    then
      (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
        do:  #())
    else do:  #());;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "ok" := (mem.alloc (type.zero_val #boolT)) in
      let: "v" := (mem.alloc (type.zero_val "T")) in
      let: "success" := (mem.alloc (type.zero_val #boolT)) in
      let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := #true in
      (Channel__TryReceiveⁱᵐᵖˡ (![#ptrT] "c") "T") "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      let: "$r2" := "$ret2" in
      do:  ("success" <-[#boolT] "$r0");;;
      do:  ("v" <-["T"] "$r1");;;
      do:  ("ok" <-[#boolT] "$r2");;;
      (if: ![#boolT] "success"
      then return: (!["T"] "v", ![#boolT] "ok")
      else do:  #()))).

(* This is a non-blocking attempt at closing. The only reason close blocks ever is because there
   may be successful exchanges that need to complete, which is equivalent to the go runtime where
   the closer must still obtain the channel's lock

   go: channel.go:206:22 *)
Definition Channel__tryCloseⁱᵐᵖˡ : val :=
  λ: "c" "T" <>,
    exception_do (let: "c" := (mem.alloc "c") in
    do:  ((primitive.Mutex__Lockⁱᵐᵖˡ (![#ptrT] (struct.field_ref (Channel "T") #"mu"%go (![#ptrT] "c")))) #());;;
    let: "$sw" := (![#offerState] (struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c"))) in
    (if: "$sw" = closed
    then
      do:  (let: "$a0" := (interface.make #stringT.id #"close of closed channel"%go) in
      Panic "$a0")
    else
      (if: ("$sw" = buffered) || ("$sw" = idle)
      then
        let: "$r0" := closed in
        do:  ((struct.field_ref (Channel "T") #"state"%go (![#ptrT] "c")) <-[#offerState] "$r0");;;
        do:  ((primitive.Mutex__Unlockⁱᵐᵖˡ (![#ptrT] (struct.field_ref (Channel "T") #"mu"%go (![#ptrT] "c")))) #());;;
        return: (#true)
      else
        do:  ((primitive.Mutex__Unlockⁱᵐᵖˡ (![#ptrT] (struct.field_ref (Channel "T") #"mu"%go (![#ptrT] "c")))) #());;;
        return: (#false)))).

(* c.Close()

   is equivalent to:

   close(c)

   go: channel.go:228:22 *)
Definition Channel__Closeⁱᵐᵖˡ : val :=
  λ: "c" "T" <>,
    exception_do (let: "c" := (mem.alloc "c") in
    (if: (![#ptrT] "c") = #null
    then
      do:  (let: "$a0" := (interface.make #stringT.id #"close of nil channel"%go) in
      Panic "$a0")
    else do:  #());;;
    (for: (λ: <>, (~ ((Channel__tryCloseⁱᵐᵖˡ (![#ptrT] "c") "T") #()))); (λ: <>, #()) := λ: <>,
      do:  #());;;
    return: #()).

(* v := c.ReceiveDiscardOk

   is equivalent to:
   v := c<-

   go: channel.go:240:22 *)
Definition Channel__ReceiveDiscardOkⁱᵐᵖˡ : val :=
  λ: "c" "T" <>,
    exception_do (let: "c" := (mem.alloc "c") in
    let: "return_val" := (mem.alloc (type.zero_val "T")) in
    let: ("$ret0", "$ret1") := ((Channel__Receiveⁱᵐᵖˡ (![#ptrT] "c") "T") #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("return_val" <-["T"] "$r0");;;
    do:  "$r1";;;
    return: (!["T"] "return_val")).

(* c.Len()

   is equivalent to:
   len(c)

   This might not be worth specifying since it is hard to make good use of channel length
   semantics.

   go: channel.go:252:22 *)
Definition Channel__Lenⁱᵐᵖˡ : val :=
  λ: "c" "T" <>,
    exception_do (let: "c" := (mem.alloc "c") in
    (if: (![#ptrT] "c") = #null
    then return: (#(W64 0))
    else do:  #());;;
    do:  ((primitive.Mutex__Lockⁱᵐᵖˡ (![#ptrT] (struct.field_ref (Channel "T") #"mu"%go (![#ptrT] "c")))) #());;;
    let: "chan_len" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] (struct.field_ref (Channel "T") #"buffer"%go (![#ptrT] "c"))) in
    slice.len "$a0") in
    do:  ("chan_len" <-[#intT] "$r0");;;
    do:  ((primitive.Mutex__Unlockⁱᵐᵖˡ (![#ptrT] (struct.field_ref (Channel "T") #"mu"%go (![#ptrT] "c")))) #());;;
    return: (![#intT] "chan_len")).

(* c.Cap()

   is equivalent to:
   cap(c)

   go: channel.go:266:22 *)
Definition Channel__Capⁱᵐᵖˡ : val :=
  λ: "c" "T" <>,
    exception_do (let: "c" := (mem.alloc "c") in
    (if: (![#ptrT] "c") = #null
    then return: (#(W64 0))
    else do:  #());;;
    return: (![#intT] (struct.field_ref (Channel "T") #"cap"%go (![#ptrT] "c")))).

(* c.Iter() returns an iterator that models a for range loop over the channel.

   go: channel.go:274:22 *)
Definition Channel__Iterⁱᵐᵖˡ : val :=
  λ: "c" "T" <>,
    exception_do (let: "c" := (mem.alloc "c") in
    return: ((λ: "yield",
       exception_do (let: "yield" := (mem.alloc "yield") in
       (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
         let: "ok" := (mem.alloc (type.zero_val #boolT)) in
         let: "v" := (mem.alloc (type.zero_val "T")) in
         let: "selected" := (mem.alloc (type.zero_val #boolT)) in
         let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := #true in
         (Channel__TryReceiveⁱᵐᵖˡ (![#ptrT] "c") "T") "$a0") in
         let: "$r0" := "$ret0" in
         let: "$r1" := "$ret1" in
         let: "$r2" := "$ret2" in
         do:  ("selected" <-[#boolT] "$r0");;;
         do:  ("v" <-["T"] "$r1");;;
         do:  ("ok" <-[#boolT] "$r2");;;
         (if: (~ (![#boolT] "selected"))
         then continue: #()
         else do:  #());;;
         (if: (~ (![#boolT] "ok"))
         then return: (#())
         else do:  #());;;
         (if: (~ (let: "$a0" := (!["T"] "v") in
         (![#funcT] "yield") "$a0"))
         then return: (#())
         else do:  #()));;;
       return: #())
       ))).

Definition SelectDir : go_type := uint64T.
#[global] Typeclasses Opaque SelectDir.
#[global] Opaque SelectDir.

(* case ch <- Send *)
Definition SelectSend : val := #(W64 0).

(* case <-ch: *)
Definition SelectRecv : val := #(W64 1).

Definition NonBlockingSelect1 : go_string := "github.com/goose-lang/goose/model/channel.NonBlockingSelect1"%go.

(* Non-blocking select with 1 case (send or receive)
   For receive: value parameter is ignored
   Returns (selected, received_value, ok)

   go: select.go:19:6 *)
Definition NonBlockingSelect1ⁱᵐᵖˡ : val :=
  λ: "T" "ch" "dir" "value",
    exception_do (let: "value" := (mem.alloc "value") in
    let: "dir" := (mem.alloc "dir") in
    let: "ch" := (mem.alloc "ch") in
    let: "zero" := (mem.alloc (type.zero_val "T")) in
    (if: (![#SelectDir] "dir") = SelectSend
    then
      let: "selected" := (mem.alloc (type.zero_val #boolT)) in
      let: "$r0" := (let: "$a0" := (!["T"] "value") in
      let: "$a1" := #false in
      (Channel__TrySendⁱᵐᵖˡ (![#ptrT] "ch") "T") "$a0" "$a1") in
      do:  ("selected" <-[#boolT] "$r0");;;
      return: (![#boolT] "selected", !["T"] "zero", #false)
    else
      let: "ok" := (mem.alloc (type.zero_val #boolT)) in
      let: "recv_val" := (mem.alloc (type.zero_val "T")) in
      let: "selected" := (mem.alloc (type.zero_val #boolT)) in
      let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := #false in
      (Channel__TryReceiveⁱᵐᵖˡ (![#ptrT] "ch") "T") "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      let: "$r2" := "$ret2" in
      do:  ("selected" <-[#boolT] "$r0");;;
      do:  ("recv_val" <-["T"] "$r1");;;
      do:  ("ok" <-[#boolT] "$r2");;;
      return: (![#boolT] "selected", !["T"] "recv_val", ![#boolT] "ok"))).

Definition BlockingSelect2 : go_string := "github.com/goose-lang/goose/model/channel.BlockingSelect2"%go.

(* Blocking select with 2 cases
   Returns (caseIndex, received_value1, received_value2, ok)

   go: select.go:33:6 *)
Definition BlockingSelect2ⁱᵐᵖˡ : val :=
  λ: "T1" "T2" "ch1" "dir1" "val1" "ch2" "dir2" "val2",
    exception_do (let: "val2" := (mem.alloc "val2") in
    let: "dir2" := (mem.alloc "dir2") in
    let: "ch2" := (mem.alloc "ch2") in
    let: "val1" := (mem.alloc "val1") in
    let: "dir1" := (mem.alloc "dir1") in
    let: "ch1" := (mem.alloc "ch1") in
    let: "zero1" := (mem.alloc (type.zero_val "T1")) in
    let: "zero2" := (mem.alloc (type.zero_val "T2")) in
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (if: (((primitive.RandomUint64ⁱᵐᵖˡ #()) #()) `rem` #(W64 2)) = #(W64 0)
      then
        (if: (![#SelectDir] "dir1") = SelectSend
        then
          (if: let: "$a0" := (!["T1"] "val1") in
          let: "$a1" := #true in
          (Channel__TrySendⁱᵐᵖˡ (![#ptrT] "ch1") "T1") "$a0" "$a1"
          then return: (#(W64 0), !["T1"] "zero1", !["T2"] "zero2", #false)
          else do:  #())
        else
          let: "ok" := (mem.alloc (type.zero_val #boolT)) in
          let: "recv_val" := (mem.alloc (type.zero_val "T1")) in
          let: "selected" := (mem.alloc (type.zero_val #boolT)) in
          let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := #true in
          (Channel__TryReceiveⁱᵐᵖˡ (![#ptrT] "ch1") "T1") "$a0") in
          let: "$r0" := "$ret0" in
          let: "$r1" := "$ret1" in
          let: "$r2" := "$ret2" in
          do:  ("selected" <-[#boolT] "$r0");;;
          do:  ("recv_val" <-["T1"] "$r1");;;
          do:  ("ok" <-[#boolT] "$r2");;;
          (if: ![#boolT] "selected"
          then return: (#(W64 0), !["T1"] "recv_val", !["T2"] "zero2", ![#boolT] "ok")
          else do:  #()))
      else
        (if: (![#SelectDir] "dir2") = SelectSend
        then
          (if: let: "$a0" := (!["T2"] "val2") in
          let: "$a1" := #true in
          (Channel__TrySendⁱᵐᵖˡ (![#ptrT] "ch2") "T2") "$a0" "$a1"
          then return: (#(W64 1), !["T1"] "zero1", !["T2"] "zero2", #false)
          else do:  #())
        else
          let: "ok" := (mem.alloc (type.zero_val #boolT)) in
          let: "recv_val" := (mem.alloc (type.zero_val "T2")) in
          let: "selected" := (mem.alloc (type.zero_val #boolT)) in
          let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := #true in
          (Channel__TryReceiveⁱᵐᵖˡ (![#ptrT] "ch2") "T2") "$a0") in
          let: "$r0" := "$ret0" in
          let: "$r1" := "$ret1" in
          let: "$r2" := "$ret2" in
          do:  ("selected" <-[#boolT] "$r0");;;
          do:  ("recv_val" <-["T2"] "$r1");;;
          do:  ("ok" <-[#boolT] "$r2");;;
          (if: ![#boolT] "selected"
          then return: (#(W64 1), !["T1"] "zero1", !["T2"] "recv_val", ![#boolT] "ok")
          else do:  #()))))).

Definition NonBlockingSelect2 : go_string := "github.com/goose-lang/goose/model/channel.NonBlockingSelect2"%go.

(* Non-blocking select with 2 cases
   Returns (caseIndex, received_value1, received_value2, ok)
   caseIndex = 2 means no selection

   go: select.go:73:6 *)
Definition NonBlockingSelect2ⁱᵐᵖˡ : val :=
  λ: "T1" "T2" "ch1" "dir1" "val1" "ch2" "dir2" "val2",
    exception_do (let: "val2" := (mem.alloc "val2") in
    let: "dir2" := (mem.alloc "dir2") in
    let: "ch2" := (mem.alloc "ch2") in
    let: "val1" := (mem.alloc "val1") in
    let: "dir1" := (mem.alloc "dir1") in
    let: "ch1" := (mem.alloc "ch1") in
    let: "zero1" := (mem.alloc (type.zero_val "T1")) in
    let: "zero2" := (mem.alloc (type.zero_val "T2")) in
    (if: (((primitive.RandomUint64ⁱᵐᵖˡ #()) #()) `rem` #(W64 2)) = #(W64 0)
    then
      (if: (![#SelectDir] "dir1") = SelectSend
      then
        (if: let: "$a0" := (!["T1"] "val1") in
        let: "$a1" := #false in
        (Channel__TrySendⁱᵐᵖˡ (![#ptrT] "ch1") "T1") "$a0" "$a1"
        then return: (#(W64 0), !["T1"] "zero1", !["T2"] "zero2", #false)
        else do:  #())
      else
        let: "ok" := (mem.alloc (type.zero_val #boolT)) in
        let: "recv_val" := (mem.alloc (type.zero_val "T1")) in
        let: "selected" := (mem.alloc (type.zero_val #boolT)) in
        let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := #false in
        (Channel__TryReceiveⁱᵐᵖˡ (![#ptrT] "ch1") "T1") "$a0") in
        let: "$r0" := "$ret0" in
        let: "$r1" := "$ret1" in
        let: "$r2" := "$ret2" in
        do:  ("selected" <-[#boolT] "$r0");;;
        do:  ("recv_val" <-["T1"] "$r1");;;
        do:  ("ok" <-[#boolT] "$r2");;;
        (if: ![#boolT] "selected"
        then return: (#(W64 0), !["T1"] "recv_val", !["T2"] "zero2", ![#boolT] "ok")
        else do:  #()));;;
      (if: (![#SelectDir] "dir2") = SelectSend
      then
        (if: let: "$a0" := (!["T2"] "val2") in
        let: "$a1" := #false in
        (Channel__TrySendⁱᵐᵖˡ (![#ptrT] "ch2") "T2") "$a0" "$a1"
        then return: (#(W64 1), !["T1"] "zero1", !["T2"] "zero2", #false)
        else do:  #())
      else
        let: "ok" := (mem.alloc (type.zero_val #boolT)) in
        let: "recv_val" := (mem.alloc (type.zero_val "T2")) in
        let: "selected" := (mem.alloc (type.zero_val #boolT)) in
        let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := #false in
        (Channel__TryReceiveⁱᵐᵖˡ (![#ptrT] "ch2") "T2") "$a0") in
        let: "$r0" := "$ret0" in
        let: "$r1" := "$ret1" in
        let: "$r2" := "$ret2" in
        do:  ("selected" <-[#boolT] "$r0");;;
        do:  ("recv_val" <-["T2"] "$r1");;;
        do:  ("ok" <-[#boolT] "$r2");;;
        (if: ![#boolT] "selected"
        then return: (#(W64 1), !["T1"] "zero1", !["T2"] "recv_val", ![#boolT] "ok")
        else do:  #()))
    else
      (if: (![#SelectDir] "dir2") = SelectSend
      then
        (if: let: "$a0" := (!["T2"] "val2") in
        let: "$a1" := #false in
        (Channel__TrySendⁱᵐᵖˡ (![#ptrT] "ch2") "T2") "$a0" "$a1"
        then return: (#(W64 1), !["T1"] "zero1", !["T2"] "zero2", #false)
        else do:  #())
      else
        let: "ok" := (mem.alloc (type.zero_val #boolT)) in
        let: "recv_val" := (mem.alloc (type.zero_val "T2")) in
        let: "selected" := (mem.alloc (type.zero_val #boolT)) in
        let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := #false in
        (Channel__TryReceiveⁱᵐᵖˡ (![#ptrT] "ch2") "T2") "$a0") in
        let: "$r0" := "$ret0" in
        let: "$r1" := "$ret1" in
        let: "$r2" := "$ret2" in
        do:  ("selected" <-[#boolT] "$r0");;;
        do:  ("recv_val" <-["T2"] "$r1");;;
        do:  ("ok" <-[#boolT] "$r2");;;
        (if: ![#boolT] "selected"
        then return: (#(W64 1), !["T1"] "zero1", !["T2"] "recv_val", ![#boolT] "ok")
        else do:  #()));;;
      (if: (![#SelectDir] "dir1") = SelectSend
      then
        (if: let: "$a0" := (!["T1"] "val1") in
        let: "$a1" := #false in
        (Channel__TrySendⁱᵐᵖˡ (![#ptrT] "ch1") "T1") "$a0" "$a1"
        then return: (#(W64 0), !["T1"] "zero1", !["T2"] "zero2", #false)
        else do:  #())
      else
        let: "ok" := (mem.alloc (type.zero_val #boolT)) in
        let: "recv_val" := (mem.alloc (type.zero_val "T1")) in
        let: "selected" := (mem.alloc (type.zero_val #boolT)) in
        let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := #false in
        (Channel__TryReceiveⁱᵐᵖˡ (![#ptrT] "ch1") "T1") "$a0") in
        let: "$r0" := "$ret0" in
        let: "$r1" := "$ret1" in
        let: "$r2" := "$ret2" in
        do:  ("selected" <-[#boolT] "$r0");;;
        do:  ("recv_val" <-["T1"] "$r1");;;
        do:  ("ok" <-[#boolT] "$r2");;;
        (if: ![#boolT] "selected"
        then return: (#(W64 0), !["T1"] "recv_val", !["T2"] "zero2", ![#boolT] "ok")
        else do:  #())));;;
    return: (#(W64 2), !["T1"] "zero1", !["T2"] "zero2", #false)).

Definition BlockingSelect3 : go_string := "github.com/goose-lang/goose/model/channel.BlockingSelect3"%go.

(* go: select.go:135:6 *)
Definition BlockingSelect3ⁱᵐᵖˡ : val :=
  λ: "T1" "T2" "T3" "ch1" "dir1" "val1" "ch2" "dir2" "val2" "ch3" "dir3" "val3",
    exception_do (let: "val3" := (mem.alloc "val3") in
    let: "dir3" := (mem.alloc "dir3") in
    let: "ch3" := (mem.alloc "ch3") in
    let: "val2" := (mem.alloc "val2") in
    let: "dir2" := (mem.alloc "dir2") in
    let: "ch2" := (mem.alloc "ch2") in
    let: "val1" := (mem.alloc "val1") in
    let: "dir1" := (mem.alloc "dir1") in
    let: "ch1" := (mem.alloc "ch1") in
    let: "zero1" := (mem.alloc (type.zero_val "T1")) in
    let: "zero2" := (mem.alloc (type.zero_val "T2")) in
    let: "zero3" := (mem.alloc (type.zero_val "T3")) in
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "r" := (mem.alloc (type.zero_val #uint64T)) in
      let: "$r0" := (((primitive.RandomUint64ⁱᵐᵖˡ #()) #()) `rem` #(W64 3)) in
      do:  ("r" <-[#uint64T] "$r0");;;
      let: "$sw" := (![#uint64T] "r") in
      (if: "$sw" = #(W64 0)
      then
        (if: (![#SelectDir] "dir1") = SelectSend
        then
          (if: let: "$a0" := (!["T1"] "val1") in
          let: "$a1" := #true in
          (Channel__TrySendⁱᵐᵖˡ (![#ptrT] "ch1") "T1") "$a0" "$a1"
          then return: (#(W64 0), !["T1"] "zero1", !["T2"] "zero2", !["T3"] "zero3", #false)
          else do:  #())
        else
          let: "ok" := (mem.alloc (type.zero_val #boolT)) in
          let: "recv_val" := (mem.alloc (type.zero_val "T1")) in
          let: "selected" := (mem.alloc (type.zero_val #boolT)) in
          let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := #true in
          (Channel__TryReceiveⁱᵐᵖˡ (![#ptrT] "ch1") "T1") "$a0") in
          let: "$r0" := "$ret0" in
          let: "$r1" := "$ret1" in
          let: "$r2" := "$ret2" in
          do:  ("selected" <-[#boolT] "$r0");;;
          do:  ("recv_val" <-["T1"] "$r1");;;
          do:  ("ok" <-[#boolT] "$r2");;;
          (if: ![#boolT] "selected"
          then return: (#(W64 0), !["T1"] "recv_val", !["T2"] "zero2", !["T3"] "zero3", ![#boolT] "ok")
          else do:  #()))
      else
        (if: "$sw" = #(W64 1)
        then
          (if: (![#SelectDir] "dir2") = SelectSend
          then
            (if: let: "$a0" := (!["T2"] "val2") in
            let: "$a1" := #true in
            (Channel__TrySendⁱᵐᵖˡ (![#ptrT] "ch2") "T2") "$a0" "$a1"
            then return: (#(W64 1), !["T1"] "zero1", !["T2"] "zero2", !["T3"] "zero3", #false)
            else do:  #())
          else
            let: "ok" := (mem.alloc (type.zero_val #boolT)) in
            let: "recv_val" := (mem.alloc (type.zero_val "T2")) in
            let: "selected" := (mem.alloc (type.zero_val #boolT)) in
            let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := #true in
            (Channel__TryReceiveⁱᵐᵖˡ (![#ptrT] "ch2") "T2") "$a0") in
            let: "$r0" := "$ret0" in
            let: "$r1" := "$ret1" in
            let: "$r2" := "$ret2" in
            do:  ("selected" <-[#boolT] "$r0");;;
            do:  ("recv_val" <-["T2"] "$r1");;;
            do:  ("ok" <-[#boolT] "$r2");;;
            (if: ![#boolT] "selected"
            then return: (#(W64 1), !["T1"] "zero1", !["T2"] "recv_val", !["T3"] "zero3", ![#boolT] "ok")
            else do:  #()))
        else
          (if: (![#SelectDir] "dir3") = SelectSend
          then
            (if: let: "$a0" := (!["T3"] "val3") in
            let: "$a1" := #true in
            (Channel__TrySendⁱᵐᵖˡ (![#ptrT] "ch3") "T3") "$a0" "$a1"
            then return: (#(W64 2), !["T1"] "zero1", !["T2"] "zero2", !["T3"] "zero3", #false)
            else do:  #())
          else
            let: "ok" := (mem.alloc (type.zero_val #boolT)) in
            let: "recv_val" := (mem.alloc (type.zero_val "T3")) in
            let: "selected" := (mem.alloc (type.zero_val #boolT)) in
            let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := #true in
            (Channel__TryReceiveⁱᵐᵖˡ (![#ptrT] "ch3") "T3") "$a0") in
            let: "$r0" := "$ret0" in
            let: "$r1" := "$ret1" in
            let: "$r2" := "$ret2" in
            do:  ("selected" <-[#boolT] "$r0");;;
            do:  ("recv_val" <-["T3"] "$r1");;;
            do:  ("ok" <-[#boolT] "$r2");;;
            (if: ![#boolT] "selected"
            then return: (#(W64 2), !["T1"] "zero1", !["T2"] "zero2", !["T3"] "recv_val", ![#boolT] "ok")
            else do:  #())))))).

Definition NonBlockingSelect3 : go_string := "github.com/goose-lang/goose/model/channel.NonBlockingSelect3"%go.

(* Non-blocking select with 3 cases
   Returns (caseIndex, received_value1, received_value2, received_value3, ok)
   caseIndex = 3 means no selection

   go: select.go:189:6 *)
Definition NonBlockingSelect3ⁱᵐᵖˡ : val :=
  λ: "T1" "T2" "T3" "ch1" "dir1" "val1" "ch2" "dir2" "val2" "ch3" "dir3" "val3",
    exception_do (let: "val3" := (mem.alloc "val3") in
    let: "dir3" := (mem.alloc "dir3") in
    let: "ch3" := (mem.alloc "ch3") in
    let: "val2" := (mem.alloc "val2") in
    let: "dir2" := (mem.alloc "dir2") in
    let: "ch2" := (mem.alloc "ch2") in
    let: "val1" := (mem.alloc "val1") in
    let: "dir1" := (mem.alloc "dir1") in
    let: "ch1" := (mem.alloc "ch1") in
    let: "zero1" := (mem.alloc (type.zero_val "T1")) in
    let: "zero2" := (mem.alloc (type.zero_val "T2")) in
    let: "zero3" := (mem.alloc (type.zero_val "T3")) in
    let: "start" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (((primitive.RandomUint64ⁱᵐᵖˡ #()) #()) `rem` #(W64 3)) in
    do:  ("start" <-[#uint64T] "$r0");;;
    (let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (for: (λ: <>, (![#uint64T] "i") < #(W64 3)); (λ: <>, do:  ("i" <-[#uint64T] ((![#uint64T] "i") + #(W64 1)))) := λ: <>,
      let: "caseIdx" := (mem.alloc (type.zero_val #uint64T)) in
      let: "$r0" := (((![#uint64T] "start") + (![#uint64T] "i")) `rem` #(W64 3)) in
      do:  ("caseIdx" <-[#uint64T] "$r0");;;
      (if: (![#uint64T] "caseIdx") = #(W64 0)
      then
        (if: (![#SelectDir] "dir1") = SelectSend
        then
          (if: let: "$a0" := (!["T1"] "val1") in
          let: "$a1" := #false in
          (Channel__TrySendⁱᵐᵖˡ (![#ptrT] "ch1") "T1") "$a0" "$a1"
          then return: (#(W64 0), !["T1"] "zero1", !["T2"] "zero2", !["T3"] "zero3", #false)
          else do:  #())
        else
          let: "ok" := (mem.alloc (type.zero_val #boolT)) in
          let: "recv_val" := (mem.alloc (type.zero_val "T1")) in
          let: "selected" := (mem.alloc (type.zero_val #boolT)) in
          let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := #false in
          (Channel__TryReceiveⁱᵐᵖˡ (![#ptrT] "ch1") "T1") "$a0") in
          let: "$r0" := "$ret0" in
          let: "$r1" := "$ret1" in
          let: "$r2" := "$ret2" in
          do:  ("selected" <-[#boolT] "$r0");;;
          do:  ("recv_val" <-["T1"] "$r1");;;
          do:  ("ok" <-[#boolT] "$r2");;;
          (if: ![#boolT] "selected"
          then return: (#(W64 0), !["T1"] "recv_val", !["T2"] "zero2", !["T3"] "zero3", ![#boolT] "ok")
          else do:  #()))
      else
        (if: (![#uint64T] "caseIdx") = #(W64 1)
        then
          (if: (![#SelectDir] "dir2") = SelectSend
          then
            (if: let: "$a0" := (!["T2"] "val2") in
            let: "$a1" := #false in
            (Channel__TrySendⁱᵐᵖˡ (![#ptrT] "ch2") "T2") "$a0" "$a1"
            then return: (#(W64 1), !["T1"] "zero1", !["T2"] "zero2", !["T3"] "zero3", #false)
            else do:  #())
          else
            let: "ok" := (mem.alloc (type.zero_val #boolT)) in
            let: "recv_val" := (mem.alloc (type.zero_val "T2")) in
            let: "selected" := (mem.alloc (type.zero_val #boolT)) in
            let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := #false in
            (Channel__TryReceiveⁱᵐᵖˡ (![#ptrT] "ch2") "T2") "$a0") in
            let: "$r0" := "$ret0" in
            let: "$r1" := "$ret1" in
            let: "$r2" := "$ret2" in
            do:  ("selected" <-[#boolT] "$r0");;;
            do:  ("recv_val" <-["T2"] "$r1");;;
            do:  ("ok" <-[#boolT] "$r2");;;
            (if: ![#boolT] "selected"
            then return: (#(W64 1), !["T1"] "zero1", !["T2"] "recv_val", !["T3"] "zero3", ![#boolT] "ok")
            else do:  #()))
        else
          (if: (![#SelectDir] "dir3") = SelectSend
          then
            (if: let: "$a0" := (!["T3"] "val3") in
            let: "$a1" := #false in
            (Channel__TrySendⁱᵐᵖˡ (![#ptrT] "ch3") "T3") "$a0" "$a1"
            then return: (#(W64 2), !["T1"] "zero1", !["T2"] "zero2", !["T3"] "zero3", #false)
            else do:  #())
          else
            let: "ok" := (mem.alloc (type.zero_val #boolT)) in
            let: "recv_val" := (mem.alloc (type.zero_val "T3")) in
            let: "selected" := (mem.alloc (type.zero_val #boolT)) in
            let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := #false in
            (Channel__TryReceiveⁱᵐᵖˡ (![#ptrT] "ch3") "T3") "$a0") in
            let: "$r0" := "$ret0" in
            let: "$r1" := "$ret1" in
            let: "$r2" := "$ret2" in
            do:  ("selected" <-[#boolT] "$r0");;;
            do:  ("recv_val" <-["T3"] "$r1");;;
            do:  ("ok" <-[#boolT] "$r2");;;
            (if: ![#boolT] "selected"
            then return: (#(W64 2), !["T1"] "zero1", !["T2"] "zero2", !["T3"] "recv_val", ![#boolT] "ok")
            else do:  #()))))));;;
    return: (#(W64 3), !["T1"] "zero1", !["T2"] "zero2", !["T3"] "zero3", #false)).

Definition vars' : list (go_string * go_type) := [].

Definition functions' : list (go_string * val) := [(NewChannel, NewChannelⁱᵐᵖˡ); (NonBlockingSelect1, NonBlockingSelect1ⁱᵐᵖˡ); (BlockingSelect2, BlockingSelect2ⁱᵐᵖˡ); (NonBlockingSelect2, NonBlockingSelect2ⁱᵐᵖˡ); (BlockingSelect3, BlockingSelect3ⁱᵐᵖˡ); (NonBlockingSelect3, NonBlockingSelect3ⁱᵐᵖˡ)].

Definition msets' : list (go_string * (list (go_string * val))) := [(offerState.id, []); (ptrT.id offerState.id, []); (Channel.id, []); (ptrT.id Channel.id, [("Cap"%go, Channel__Capⁱᵐᵖˡ); ("Close"%go, Channel__Closeⁱᵐᵖˡ); ("Iter"%go, Channel__Iterⁱᵐᵖˡ); ("Len"%go, Channel__Lenⁱᵐᵖˡ); ("Receive"%go, Channel__Receiveⁱᵐᵖˡ); ("ReceiveDiscardOk"%go, Channel__ReceiveDiscardOkⁱᵐᵖˡ); ("Send"%go, Channel__Sendⁱᵐᵖˡ); ("TryReceive"%go, Channel__TryReceiveⁱᵐᵖˡ); ("TrySend"%go, Channel__TrySendⁱᵐᵖˡ); ("tryClose"%go, Channel__tryCloseⁱᵐᵖˡ)]); (SelectDir.id, []); (ptrT.id SelectDir.id, [])].

#[global] Instance info' : PkgInfo channel.channel :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [code.github_com.goose_lang.primitive.primitive];
  |}.

Definition initialize' : val :=
  λ: <>,
    package.init #channel.channel (λ: <>,
      exception_do (do:  (primitive.initialize' #());;;
      do:  (package.alloc channel.channel #()))
      ).

End code.
End channel.
