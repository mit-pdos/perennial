(* autogenerated from github.com/goose-lang/goose/model/channel *)
Require Export New.code.github_com.goose_lang.primitive.

From New.golang Require Import defn.core.
From New.golang.defn Require Export slice defer.
Definition channel : go_string := "github.com/goose-lang/goose/model/channel".

Module channel.

Definition offerStateⁱᵐᵖˡ : go.type := go.uint64.

Definition offerState : go.type := go.Named "github.com/goose-lang/goose/model/channel.offerState"%go [].

Module offerState.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t  : Type := w64.
End def.
End offerState.

Class offerState_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] offerState_type_repr  :: go.TypeRepr offerState offerState.t;
  #[global] offerState_underlying :: go.Underlying (offerState) (offerStateⁱᵐᵖˡ);
}.

Definition buffered {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 0).

Definition idle {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 1).

Definition sndPending {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 2).

Definition rcvPending {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 3).

Definition sndCommit {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 4).

Definition rcvDone {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 5).

Definition closed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 6).

Definition Channel(T : go.type)  : go.type := go.Named "github.com/goose-lang/goose/model/channel.Channel"%go [T].

(* c.Cap()

   is equivalent to:
   cap(c)

   go: channel.go:266:22 *)
Definition Channel__Capⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} (T : go.type) : val :=
  λ: "c" <>,
    exception_do (let: "c" := (GoAlloc (go.PointerType (Channel T)) "c") in
    (if: (![go.PointerType (Channel T)] "c") =⟨go.PointerType (Channel T)⟩ #null
    then return: (#(W64 0))
    else do:  #());;;
    return: (![go.int] (StructFieldRef (Channel T) "cap"%go (![go.PointerType (Channel T)] "c")))).

(* c.Close()

   is equivalent to:

   close(c)

   go: channel.go:228:22 *)
Definition Channel__Closeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} (T : go.type) : val :=
  λ: "c" <>,
    exception_do (let: "c" := (GoAlloc (go.PointerType (Channel T)) "c") in
    (if: (![go.PointerType (Channel T)] "c") =⟨go.PointerType (Channel T)⟩ #null
    then
      do:  (let: "$a0" := (InterfaceMake go.string #"close of nil channel"%go) in
      (FuncResolve go.panic [] #()) "$a0")
    else do:  #());;;
    (for: (λ: <>, (~ ((MethodResolve (go.PointerType (Channel T)) "tryClose"%go #() (![go.PointerType (Channel T)] "c")) #()))); (λ: <>, #()) := λ: <>,
      do:  #());;;
    return: #()).

(* c.Iter() returns an iterator that models a for range loop over the channel.

   go: channel.go:274:22 *)
Definition Channel__Iterⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} (T : go.type) : val :=
  λ: "c" <>,
    exception_do (let: "c" := (GoAlloc (go.PointerType (Channel T)) "c") in
    return: ((λ: "yield",
       exception_do (let: "yield" := (GoAlloc (go.FunctionType (go.Signature [T] false [go.bool])) "yield") in
       (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
         let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
         let: "v" := (GoAlloc T (GoZeroVal T #())) in
         let: "selected" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
         let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := #true in
         (MethodResolve (go.PointerType (Channel T)) "TryReceive"%go #() (![go.PointerType (Channel T)] "c")) "$a0") in
         let: "$r0" := "$ret0" in
         let: "$r1" := "$ret1" in
         let: "$r2" := "$ret2" in
         do:  ("selected" <-[go.bool] "$r0");;;
         do:  ("v" <-[T] "$r1");;;
         do:  ("ok" <-[go.bool] "$r2");;;
         (if: (~ (![go.bool] "selected"))
         then continue: #()
         else do:  #());;;
         (if: (~ (![go.bool] "ok"))
         then return: (#())
         else do:  #());;;
         (if: (~ (let: "$a0" := (![T] "v") in
         (![go.FunctionType (go.Signature [T] false [go.bool])] "yield") "$a0"))
         then return: (#())
         else do:  #()));;;
       return: #())
       ))).

(* c.Len()

   is equivalent to:
   len(c)

   This might not be worth specifying since it is hard to make good use of channel length
   semantics.

   go: channel.go:252:22 *)
Definition Channel__Lenⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} (T : go.type) : val :=
  λ: "c" <>,
    exception_do (let: "c" := (GoAlloc (go.PointerType (Channel T)) "c") in
    (if: (![go.PointerType (Channel T)] "c") =⟨go.PointerType (Channel T)⟩ #null
    then return: (#(W64 0))
    else do:  #());;;
    do:  ((MethodResolve (go.PointerType primitive.Mutex) "Lock"%go #() (![go.PointerType primitive.Mutex] (StructFieldRef (Channel T) "mu"%go (![go.PointerType (Channel T)] "c")))) #());;;
    let: "chan_len" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := (let: "$a0" := (![go.SliceType T] (StructFieldRef (Channel T) "buffer"%go (![go.PointerType (Channel T)] "c"))) in
    (FuncResolve go.len [go.SliceType T] #()) "$a0") in
    do:  ("chan_len" <-[go.int] "$r0");;;
    do:  ((MethodResolve (go.PointerType primitive.Mutex) "Unlock"%go #() (![go.PointerType primitive.Mutex] (StructFieldRef (Channel T) "mu"%go (![go.PointerType (Channel T)] "c")))) #());;;
    return: (![go.int] "chan_len")).

(* go: channel.go:189:22 *)
Definition Channel__Receiveⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} (T : go.type) : val :=
  λ: "c" <>,
    exception_do (let: "c" := (GoAlloc (go.PointerType (Channel T)) "c") in
    (if: (![go.PointerType (Channel T)] "c") =⟨go.PointerType (Channel T)⟩ #null
    then
      (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
        do:  #())
    else do:  #());;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
      let: "v" := (GoAlloc T (GoZeroVal T #())) in
      let: "success" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
      let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := #true in
      (MethodResolve (go.PointerType (Channel T)) "TryReceive"%go #() (![go.PointerType (Channel T)] "c")) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      let: "$r2" := "$ret2" in
      do:  ("success" <-[go.bool] "$r0");;;
      do:  ("v" <-[T] "$r1");;;
      do:  ("ok" <-[go.bool] "$r2");;;
      (if: ![go.bool] "success"
      then return: (![T] "v", ![go.bool] "ok")
      else do:  #()))).

(* v := c.ReceiveDiscardOk

   is equivalent to:
   v := c<-

   go: channel.go:240:22 *)
Definition Channel__ReceiveDiscardOkⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} (T : go.type) : val :=
  λ: "c" <>,
    exception_do (let: "c" := (GoAlloc (go.PointerType (Channel T)) "c") in
    let: "return_val" := (GoAlloc T (GoZeroVal T #())) in
    let: ("$ret0", "$ret1") := ((MethodResolve (go.PointerType (Channel T)) "Receive"%go #() (![go.PointerType (Channel T)] "c")) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("return_val" <-[T] "$r0");;;
    do:  "$r1";;;
    return: (![T] "return_val")).

(* c.Send(val)

   is equivalent to:

   c <- val

   go: channel.go:105:22 *)
Definition Channel__Sendⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} (T : go.type) : val :=
  λ: "c" "v",
    exception_do (let: "c" := (GoAlloc (go.PointerType (Channel T)) "c") in
    let: "v" := (GoAlloc T "v") in
    (if: (![go.PointerType (Channel T)] "c") =⟨go.PointerType (Channel T)⟩ #null
    then
      (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
        do:  #())
    else do:  #());;;
    (for: (λ: <>, (~ (let: "$a0" := (![T] "v") in
    let: "$a1" := #true in
    (MethodResolve (go.PointerType (Channel T)) "TrySend"%go #() (![go.PointerType (Channel T)] "c")) "$a0" "$a1"))); (λ: <>, #()) := λ: <>,
      do:  #());;;
    return: #()).

(* Non-blocking receive function used for select statements.
   The blocking parameter here is used to determine whether or not we will make an offer to a
   waiting sender. If true, we will make an offer since blocking receive is modeled as a for loop
   around nonblocking TryReceive. If false, we don't make an offer since we don't need to match
   with another non-blocking send.

   go: channel.go:120:22 *)
Definition Channel__TryReceiveⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} (T : go.type) : val :=
  λ: "c" "blocking",
    exception_do (let: "c" := (GoAlloc (go.PointerType (Channel T)) "c") in
    let: "blocking" := (GoAlloc go.bool "blocking") in
    let: "local_val" := (GoAlloc T (GoZeroVal T #())) in
    do:  ((MethodResolve (go.PointerType primitive.Mutex) "Lock"%go #() (![go.PointerType primitive.Mutex] (StructFieldRef (Channel T) "mu"%go (![go.PointerType (Channel T)] "c")))) #());;;
    let: "$sw" := (![offerState] (StructFieldRef (Channel T) "state"%go (![go.PointerType (Channel T)] "c"))) in
    (if: "$sw" =⟨offerState⟩ buffered
    then
      let: "v" := (GoAlloc T (GoZeroVal T #())) in
      (if: (let: "$a0" := (![go.SliceType T] (StructFieldRef (Channel T) "buffer"%go (![go.PointerType (Channel T)] "c"))) in
      (FuncResolve go.len [go.SliceType T] #()) "$a0") >⟨go.int⟩ #(W64 0)
      then
        let: "val_copy" := (GoAlloc T (GoZeroVal T #())) in
        let: "$r0" := (![T] (IndexRef (go.SliceType T) (![go.SliceType T] (StructFieldRef (Channel T) "buffer"%go (![go.PointerType (Channel T)] "c")), #(W64 0)))) in
        do:  ("val_copy" <-[T] "$r0");;;
        let: "$r0" := (let: "$s" := (![go.SliceType T] (StructFieldRef (Channel T) "buffer"%go (![go.PointerType (Channel T)] "c"))) in
        Slice (go.SliceType T) ("$s", #(W64 1), FuncResolve go.len [go.SliceType T] #() (![go.SliceType T] (StructFieldRef (Channel T) "buffer"%go (![go.PointerType (Channel T)] "c"))))) in
        do:  ((StructFieldRef (Channel T) "buffer"%go (![go.PointerType (Channel T)] "c")) <-[go.SliceType T] "$r0");;;
        do:  ((MethodResolve (go.PointerType primitive.Mutex) "Unlock"%go #() (![go.PointerType primitive.Mutex] (StructFieldRef (Channel T) "mu"%go (![go.PointerType (Channel T)] "c")))) #());;;
        return: (#true, ![T] "val_copy", #true)
      else do:  #());;;
      do:  ((MethodResolve (go.PointerType primitive.Mutex) "Unlock"%go #() (![go.PointerType primitive.Mutex] (StructFieldRef (Channel T) "mu"%go (![go.PointerType (Channel T)] "c")))) #());;;
      return: (#false, ![T] "v", #true)
    else
      (if: "$sw" =⟨offerState⟩ closed
      then
        (if: (let: "$a0" := (![go.SliceType T] (StructFieldRef (Channel T) "buffer"%go (![go.PointerType (Channel T)] "c"))) in
        (FuncResolve go.len [go.SliceType T] #()) "$a0") >⟨go.int⟩ #(W64 0)
        then
          let: "val_copy" := (GoAlloc T (GoZeroVal T #())) in
          let: "$r0" := (![T] (IndexRef (go.SliceType T) (![go.SliceType T] (StructFieldRef (Channel T) "buffer"%go (![go.PointerType (Channel T)] "c")), #(W64 0)))) in
          do:  ("val_copy" <-[T] "$r0");;;
          let: "$r0" := (let: "$s" := (![go.SliceType T] (StructFieldRef (Channel T) "buffer"%go (![go.PointerType (Channel T)] "c"))) in
          Slice (go.SliceType T) ("$s", #(W64 1), FuncResolve go.len [go.SliceType T] #() (![go.SliceType T] (StructFieldRef (Channel T) "buffer"%go (![go.PointerType (Channel T)] "c"))))) in
          do:  ((StructFieldRef (Channel T) "buffer"%go (![go.PointerType (Channel T)] "c")) <-[go.SliceType T] "$r0");;;
          do:  ((MethodResolve (go.PointerType primitive.Mutex) "Unlock"%go #() (![go.PointerType primitive.Mutex] (StructFieldRef (Channel T) "mu"%go (![go.PointerType (Channel T)] "c")))) #());;;
          return: (#true, ![T] "val_copy", #true)
        else do:  #());;;
        do:  ((MethodResolve (go.PointerType primitive.Mutex) "Unlock"%go #() (![go.PointerType primitive.Mutex] (StructFieldRef (Channel T) "mu"%go (![go.PointerType (Channel T)] "c")))) #());;;
        return: (#true, ![T] "local_val", #false)
      else
        (if: "$sw" =⟨offerState⟩ sndPending
        then
          let: "$r0" := (![T] (StructFieldRef (Channel T) "v"%go (![go.PointerType (Channel T)] "c"))) in
          do:  ("local_val" <-[T] "$r0");;;
          let: "$r0" := rcvDone in
          do:  ((StructFieldRef (Channel T) "state"%go (![go.PointerType (Channel T)] "c")) <-[offerState] "$r0");;;
          do:  ((MethodResolve (go.PointerType primitive.Mutex) "Unlock"%go #() (![go.PointerType primitive.Mutex] (StructFieldRef (Channel T) "mu"%go (![go.PointerType (Channel T)] "c")))) #());;;
          return: (#true, ![T] "local_val", #true)
        else
          (if: "$sw" =⟨offerState⟩ idle
          then
            (if: ![go.bool] "blocking"
            then
              let: "$r0" := rcvPending in
              do:  ((StructFieldRef (Channel T) "state"%go (![go.PointerType (Channel T)] "c")) <-[offerState] "$r0");;;
              do:  ((MethodResolve (go.PointerType primitive.Mutex) "Unlock"%go #() (![go.PointerType primitive.Mutex] (StructFieldRef (Channel T) "mu"%go (![go.PointerType (Channel T)] "c")))) #());;;
              do:  ((MethodResolve (go.PointerType primitive.Mutex) "Lock"%go #() (![go.PointerType primitive.Mutex] (StructFieldRef (Channel T) "mu"%go (![go.PointerType (Channel T)] "c")))) #());;;
              let: "$sw" := (![offerState] (StructFieldRef (Channel T) "state"%go (![go.PointerType (Channel T)] "c"))) in
              (if: "$sw" =⟨offerState⟩ rcvPending
              then
                let: "$r0" := idle in
                do:  ((StructFieldRef (Channel T) "state"%go (![go.PointerType (Channel T)] "c")) <-[offerState] "$r0");;;
                do:  ((MethodResolve (go.PointerType primitive.Mutex) "Unlock"%go #() (![go.PointerType primitive.Mutex] (StructFieldRef (Channel T) "mu"%go (![go.PointerType (Channel T)] "c")))) #());;;
                return: (#false, ![T] "local_val", #true)
              else
                (if: "$sw" =⟨offerState⟩ sndCommit
                then
                  let: "$r0" := idle in
                  do:  ((StructFieldRef (Channel T) "state"%go (![go.PointerType (Channel T)] "c")) <-[offerState] "$r0");;;
                  let: "$r0" := (![T] (StructFieldRef (Channel T) "v"%go (![go.PointerType (Channel T)] "c"))) in
                  do:  ("local_val" <-[T] "$r0");;;
                  do:  ((MethodResolve (go.PointerType primitive.Mutex) "Unlock"%go #() (![go.PointerType primitive.Mutex] (StructFieldRef (Channel T) "mu"%go (![go.PointerType (Channel T)] "c")))) #());;;
                  return: (#true, ![T] "local_val", #true)
                else
                  do:  (let: "$a0" := (InterfaceMake go.string #"not supposed to be here!"%go) in
                  (FuncResolve go.panic [] #()) "$a0")))
            else do:  #());;;
            do:  ((MethodResolve (go.PointerType primitive.Mutex) "Unlock"%go #() (![go.PointerType primitive.Mutex] (StructFieldRef (Channel T) "mu"%go (![go.PointerType (Channel T)] "c")))) #());;;
            return: (#false, ![T] "local_val", #true)
          else
            do:  ((MethodResolve (go.PointerType primitive.Mutex) "Unlock"%go #() (![go.PointerType primitive.Mutex] (StructFieldRef (Channel T) "mu"%go (![go.PointerType (Channel T)] "c")))) #());;;
            return: (#false, ![T] "local_val", #true)))))).

(* Non-Blocking send operation for select statements. Blocking send and blocking select
   statements simply call this in a for loop until it returns true.

   go: channel.go:46:22 *)
Definition Channel__TrySendⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} (T : go.type) : val :=
  λ: "c" "val" "blocking",
    exception_do (let: "c" := (GoAlloc (go.PointerType (Channel T)) "c") in
    let: "blocking" := (GoAlloc go.bool "blocking") in
    let: "val" := (GoAlloc T "val") in
    do:  ((MethodResolve (go.PointerType primitive.Mutex) "Lock"%go #() (![go.PointerType primitive.Mutex] (StructFieldRef (Channel T) "mu"%go (![go.PointerType (Channel T)] "c")))) #());;;
    let: "$sw" := (![offerState] (StructFieldRef (Channel T) "state"%go (![go.PointerType (Channel T)] "c"))) in
    (if: "$sw" =⟨offerState⟩ closed
    then
      do:  (let: "$a0" := (InterfaceMake go.string #"send on closed channel"%go) in
      (FuncResolve go.panic [] #()) "$a0")
    else
      (if: "$sw" =⟨offerState⟩ buffered
      then
        (if: (let: "$a0" := (![go.SliceType T] (StructFieldRef (Channel T) "buffer"%go (![go.PointerType (Channel T)] "c"))) in
        (FuncResolve go.len [go.SliceType T] #()) "$a0") <⟨go.int⟩ (![go.int] (StructFieldRef (Channel T) "cap"%go (![go.PointerType (Channel T)] "c")))
        then
          let: "$r0" := (let: "$a0" := (![go.SliceType T] (StructFieldRef (Channel T) "buffer"%go (![go.PointerType (Channel T)] "c"))) in
          let: "$a1" := ((let: "$sl0" := (![T] "val") in
          CompositeLiteral (go.SliceType T) (LiteralValue [KeyedElement None (ElementExpression "$sl0")]))) in
          (FuncResolve go.append [go.SliceType T] #()) "$a0" "$a1") in
          do:  ((StructFieldRef (Channel T) "buffer"%go (![go.PointerType (Channel T)] "c")) <-[go.SliceType T] "$r0");;;
          do:  ((MethodResolve (go.PointerType primitive.Mutex) "Unlock"%go #() (![go.PointerType primitive.Mutex] (StructFieldRef (Channel T) "mu"%go (![go.PointerType (Channel T)] "c")))) #());;;
          return: (#true)
        else do:  #());;;
        do:  ((MethodResolve (go.PointerType primitive.Mutex) "Unlock"%go #() (![go.PointerType primitive.Mutex] (StructFieldRef (Channel T) "mu"%go (![go.PointerType (Channel T)] "c")))) #());;;
        return: (#false)
      else
        (if: "$sw" =⟨offerState⟩ rcvPending
        then
          let: "$r0" := sndCommit in
          do:  ((StructFieldRef (Channel T) "state"%go (![go.PointerType (Channel T)] "c")) <-[offerState] "$r0");;;
          let: "$r0" := (![T] "val") in
          do:  ((StructFieldRef (Channel T) "v"%go (![go.PointerType (Channel T)] "c")) <-[T] "$r0");;;
          do:  ((MethodResolve (go.PointerType primitive.Mutex) "Unlock"%go #() (![go.PointerType primitive.Mutex] (StructFieldRef (Channel T) "mu"%go (![go.PointerType (Channel T)] "c")))) #());;;
          return: (#true)
        else
          (if: "$sw" =⟨offerState⟩ idle
          then
            (if: ![go.bool] "blocking"
            then
              let: "$r0" := sndPending in
              do:  ((StructFieldRef (Channel T) "state"%go (![go.PointerType (Channel T)] "c")) <-[offerState] "$r0");;;
              let: "$r0" := (![T] "val") in
              do:  ((StructFieldRef (Channel T) "v"%go (![go.PointerType (Channel T)] "c")) <-[T] "$r0");;;
              do:  ((MethodResolve (go.PointerType primitive.Mutex) "Unlock"%go #() (![go.PointerType primitive.Mutex] (StructFieldRef (Channel T) "mu"%go (![go.PointerType (Channel T)] "c")))) #());;;
              do:  ((MethodResolve (go.PointerType primitive.Mutex) "Lock"%go #() (![go.PointerType primitive.Mutex] (StructFieldRef (Channel T) "mu"%go (![go.PointerType (Channel T)] "c")))) #());;;
              let: "$sw" := (![offerState] (StructFieldRef (Channel T) "state"%go (![go.PointerType (Channel T)] "c"))) in
              (if: "$sw" =⟨offerState⟩ rcvDone
              then
                let: "$r0" := idle in
                do:  ((StructFieldRef (Channel T) "state"%go (![go.PointerType (Channel T)] "c")) <-[offerState] "$r0");;;
                do:  ((MethodResolve (go.PointerType primitive.Mutex) "Unlock"%go #() (![go.PointerType primitive.Mutex] (StructFieldRef (Channel T) "mu"%go (![go.PointerType (Channel T)] "c")))) #());;;
                return: (#true)
              else
                (if: "$sw" =⟨offerState⟩ sndPending
                then
                  let: "$r0" := idle in
                  do:  ((StructFieldRef (Channel T) "state"%go (![go.PointerType (Channel T)] "c")) <-[offerState] "$r0");;;
                  do:  ((MethodResolve (go.PointerType primitive.Mutex) "Unlock"%go #() (![go.PointerType primitive.Mutex] (StructFieldRef (Channel T) "mu"%go (![go.PointerType (Channel T)] "c")))) #());;;
                  return: (#false)
                else
                  do:  (let: "$a0" := (InterfaceMake go.string #"Invalid state transition with open receive offer"%go) in
                  (FuncResolve go.panic [] #()) "$a0")))
            else do:  #());;;
            do:  ((MethodResolve (go.PointerType primitive.Mutex) "Unlock"%go #() (![go.PointerType primitive.Mutex] (StructFieldRef (Channel T) "mu"%go (![go.PointerType (Channel T)] "c")))) #());;;
            return: (#false)
          else
            do:  ((MethodResolve (go.PointerType primitive.Mutex) "Unlock"%go #() (![go.PointerType primitive.Mutex] (StructFieldRef (Channel T) "mu"%go (![go.PointerType (Channel T)] "c")))) #());;;
            return: (#false)))))).

(* This is a non-blocking attempt at closing. The only reason close blocks ever is because there
   may be successful exchanges that need to complete, which is equivalent to the go runtime where
   the closer must still obtain the channel's lock

   go: channel.go:206:22 *)
Definition Channel__tryCloseⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} (T : go.type) : val :=
  λ: "c" <>,
    exception_do (let: "c" := (GoAlloc (go.PointerType (Channel T)) "c") in
    do:  ((MethodResolve (go.PointerType primitive.Mutex) "Lock"%go #() (![go.PointerType primitive.Mutex] (StructFieldRef (Channel T) "mu"%go (![go.PointerType (Channel T)] "c")))) #());;;
    let: "$sw" := (![offerState] (StructFieldRef (Channel T) "state"%go (![go.PointerType (Channel T)] "c"))) in
    (if: "$sw" =⟨offerState⟩ closed
    then
      do:  (let: "$a0" := (InterfaceMake go.string #"close of closed channel"%go) in
      (FuncResolve go.panic [] #()) "$a0")
    else
      (if: ("$sw" =⟨offerState⟩ buffered) || ("$sw" =⟨offerState⟩ idle)
      then
        let: "$r0" := closed in
        do:  ((StructFieldRef (Channel T) "state"%go (![go.PointerType (Channel T)] "c")) <-[offerState] "$r0");;;
        do:  ((MethodResolve (go.PointerType primitive.Mutex) "Unlock"%go #() (![go.PointerType primitive.Mutex] (StructFieldRef (Channel T) "mu"%go (![go.PointerType (Channel T)] "c")))) #());;;
        return: (#true)
      else
        do:  ((MethodResolve (go.PointerType primitive.Mutex) "Unlock"%go #() (![go.PointerType primitive.Mutex] (StructFieldRef (Channel T) "mu"%go (![go.PointerType (Channel T)] "c")))) #());;;
        return: (#false)))).

Definition Channelⁱᵐᵖˡ(T : go.type)  : go.type := go.StructType [
  (go.FieldDecl "cap"%go go.int);
  (go.FieldDecl "mu"%go (go.PointerType primitive.Mutex));
  (go.FieldDecl "state"%go offerState);
  (go.FieldDecl "buffer"%go (go.SliceType T));
  (go.FieldDecl "v"%go T)
].

Module Channel.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t {T : Type} :=
mk {
  cap : w64;
  mu : loc;
  state : channel.offerState.t;
  buffer : slice.t;
  v : T;
}.

#[global] Instance zero_val `{!ZeroVal T} : ZeroVal t := {| zero_val := mk T (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End Channel.

Class Channel_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Channel_type_repr T T' `{!ZeroVal T'} `{!go.TypeRepr T T'} :: go.TypeRepr (Channel T) (Channel.t T');
  #[global] Channel_underlying T :: go.Underlying (Channel T) (Channelⁱᵐᵖˡ T);
  #[global] Channel_get_cap T T' (x : Channel.t T') :: go.IsGoStepPureDet (StructFieldGet (Channel T) "cap") #x #x.(Channel.cap);
  #[global] Channel_set_cap T T' (x : Channel.t T') y :: go.IsGoStepPureDet (StructFieldSet (Channel T) "cap") (#x, #y) #(x <|Channel.cap := y|>);
  #[global] Channel_get_mu T T' (x : Channel.t T') :: go.IsGoStepPureDet (StructFieldGet (Channel T) "mu") #x #x.(Channel.mu);
  #[global] Channel_set_mu T T' (x : Channel.t T') y :: go.IsGoStepPureDet (StructFieldSet (Channel T) "mu") (#x, #y) #(x <|Channel.mu := y|>);
  #[global] Channel_get_state T T' (x : Channel.t T') :: go.IsGoStepPureDet (StructFieldGet (Channel T) "state") #x #x.(Channel.state);
  #[global] Channel_set_state T T' (x : Channel.t T') y :: go.IsGoStepPureDet (StructFieldSet (Channel T) "state") (#x, #y) #(x <|Channel.state := y|>);
  #[global] Channel_get_buffer T T' (x : Channel.t T') :: go.IsGoStepPureDet (StructFieldGet (Channel T) "buffer") #x #x.(Channel.buffer);
  #[global] Channel_set_buffer T T' (x : Channel.t T') y :: go.IsGoStepPureDet (StructFieldSet (Channel T) "buffer") (#x, #y) #(x <|Channel.buffer := y|>);
  #[global] Channel_get_v T T' (x : Channel.t T') :: go.IsGoStepPureDet (StructFieldGet (Channel T) "v") #x #x.(Channel.v);
  #[global] Channel_set_v T T' (x : Channel.t T') y :: go.IsGoStepPureDet (StructFieldSet (Channel T) "v") (#x, #y) #(x <|Channel.v := y|>);
  #[global] Channel'ptr_Cap_unfold T :: MethodUnfold (go.PointerType (Channel T)) "Cap" (Channel__Capⁱᵐᵖˡ T);
  #[global] Channel'ptr_Close_unfold T :: MethodUnfold (go.PointerType (Channel T)) "Close" (Channel__Closeⁱᵐᵖˡ T);
  #[global] Channel'ptr_Iter_unfold T :: MethodUnfold (go.PointerType (Channel T)) "Iter" (Channel__Iterⁱᵐᵖˡ T);
  #[global] Channel'ptr_Len_unfold T :: MethodUnfold (go.PointerType (Channel T)) "Len" (Channel__Lenⁱᵐᵖˡ T);
  #[global] Channel'ptr_Receive_unfold T :: MethodUnfold (go.PointerType (Channel T)) "Receive" (Channel__Receiveⁱᵐᵖˡ T);
  #[global] Channel'ptr_ReceiveDiscardOk_unfold T :: MethodUnfold (go.PointerType (Channel T)) "ReceiveDiscardOk" (Channel__ReceiveDiscardOkⁱᵐᵖˡ T);
  #[global] Channel'ptr_Send_unfold T :: MethodUnfold (go.PointerType (Channel T)) "Send" (Channel__Sendⁱᵐᵖˡ T);
  #[global] Channel'ptr_TryReceive_unfold T :: MethodUnfold (go.PointerType (Channel T)) "TryReceive" (Channel__TryReceiveⁱᵐᵖˡ T);
  #[global] Channel'ptr_TrySend_unfold T :: MethodUnfold (go.PointerType (Channel T)) "TrySend" (Channel__TrySendⁱᵐᵖˡ T);
  #[global] Channel'ptr_tryClose_unfold T :: MethodUnfold (go.PointerType (Channel T)) "tryClose" (Channel__tryCloseⁱᵐᵖˡ T);
}.

Definition NewChannel {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/model/channel.NewChannel"%go.

(* go: channel.go:31:6 *)
Definition NewChannelⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} (T : go.type) : val :=
  λ: "cap",
    exception_do (let: "cap" := (GoAlloc go.int "cap") in
    let: "local_state" := (GoAlloc offerState (GoZeroVal offerState #())) in
    let: "$r0" := idle in
    do:  ("local_state" <-[offerState] "$r0");;;
    (if: (![go.int] "cap") >⟨go.int⟩ #(W64 0)
    then
      let: "$r0" := buffered in
      do:  ("local_state" <-[offerState] "$r0")
    else do:  #());;;
    return: (GoAlloc (Channel T) (CompositeLiteral (Channel T) (LiteralValue [KeyedElement (Some (KeyField "cap"%go)) (ElementExpression (![go.int] "cap")); KeyedElement (Some (KeyField "mu"%go)) (ElementExpression (GoAlloc primitive.Mutex (GoZeroVal primitive.Mutex #()))); KeyedElement (Some (KeyField "buffer"%go)) (ElementExpression ((FuncResolve go.make2 [go.SliceType T] #()) #(W64 0))); KeyedElement (Some (KeyField "state"%go)) (ElementExpression (![offerState] "local_state"))])))).

Definition SelectDirⁱᵐᵖˡ : go.type := go.uint64.

Definition SelectDir : go.type := go.Named "github.com/goose-lang/goose/model/channel.SelectDir"%go [].

Module SelectDir.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t  : Type := w64.
End def.
End SelectDir.

Class SelectDir_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] SelectDir_type_repr  :: go.TypeRepr SelectDir SelectDir.t;
  #[global] SelectDir_underlying :: go.Underlying (SelectDir) (SelectDirⁱᵐᵖˡ);
}.

(* case ch <- Send *)
Definition SelectSend {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 0).

(* case <-ch: *)
Definition SelectRecv {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 1).

Definition NonBlockingSelect1 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/model/channel.NonBlockingSelect1"%go.

(* Non-blocking select with 1 case (send or receive)
   For receive: value parameter is ignored
   Returns (selected, received_value, ok)

   go: select.go:19:6 *)
Definition NonBlockingSelect1ⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} (T : go.type) : val :=
  λ: "ch" "dir" "value",
    exception_do (let: "value" := (GoAlloc T "value") in
    let: "dir" := (GoAlloc SelectDir "dir") in
    let: "ch" := (GoAlloc (go.PointerType (Channel T)) "ch") in
    let: "zero" := (GoAlloc T (GoZeroVal T #())) in
    (if: (![SelectDir] "dir") =⟨go.uint64⟩ SelectSend
    then
      let: "selected" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
      let: "$r0" := (let: "$a0" := (![T] "value") in
      let: "$a1" := #false in
      (MethodResolve (go.PointerType (Channel T)) "TrySend"%go #() (![go.PointerType (Channel T)] "ch")) "$a0" "$a1") in
      do:  ("selected" <-[go.bool] "$r0");;;
      return: (![go.bool] "selected", ![T] "zero", #false)
    else
      let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
      let: "recv_val" := (GoAlloc T (GoZeroVal T #())) in
      let: "selected" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
      let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := #false in
      (MethodResolve (go.PointerType (Channel T)) "TryReceive"%go #() (![go.PointerType (Channel T)] "ch")) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      let: "$r2" := "$ret2" in
      do:  ("selected" <-[go.bool] "$r0");;;
      do:  ("recv_val" <-[T] "$r1");;;
      do:  ("ok" <-[go.bool] "$r2");;;
      return: (![go.bool] "selected", ![T] "recv_val", ![go.bool] "ok"))).

Definition BlockingSelect2 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/model/channel.BlockingSelect2"%go.

(* Blocking select with 2 cases
   Returns (caseIndex, received_value1, received_value2, ok)

   go: select.go:33:6 *)
Definition BlockingSelect2ⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} (T1 T2 : go.type) : val :=
  λ: "ch1" "dir1" "val1" "ch2" "dir2" "val2",
    exception_do (let: "val2" := (GoAlloc T2 "val2") in
    let: "dir2" := (GoAlloc SelectDir "dir2") in
    let: "ch2" := (GoAlloc (go.PointerType (Channel T2)) "ch2") in
    let: "val1" := (GoAlloc T1 "val1") in
    let: "dir1" := (GoAlloc SelectDir "dir1") in
    let: "ch1" := (GoAlloc (go.PointerType (Channel T1)) "ch1") in
    let: "zero1" := (GoAlloc T1 (GoZeroVal T1 #())) in
    let: "zero2" := (GoAlloc T2 (GoZeroVal T2 #())) in
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (if: (((FuncResolve primitive.RandomUint64 [] #()) #()) %⟨go.uint64⟩ #(W64 2)) =⟨go.uint64⟩ #(W64 0)
      then
        (if: (![SelectDir] "dir1") =⟨go.uint64⟩ SelectSend
        then
          (if: let: "$a0" := (![T1] "val1") in
          let: "$a1" := #true in
          (MethodResolve (go.PointerType (Channel T1)) "TrySend"%go #() (![go.PointerType (Channel T1)] "ch1")) "$a0" "$a1"
          then return: (#(W64 0), ![T1] "zero1", ![T2] "zero2", #false)
          else do:  #())
        else
          let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
          let: "recv_val" := (GoAlloc T1 (GoZeroVal T1 #())) in
          let: "selected" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
          let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := #true in
          (MethodResolve (go.PointerType (Channel T1)) "TryReceive"%go #() (![go.PointerType (Channel T1)] "ch1")) "$a0") in
          let: "$r0" := "$ret0" in
          let: "$r1" := "$ret1" in
          let: "$r2" := "$ret2" in
          do:  ("selected" <-[go.bool] "$r0");;;
          do:  ("recv_val" <-[T1] "$r1");;;
          do:  ("ok" <-[go.bool] "$r2");;;
          (if: ![go.bool] "selected"
          then return: (#(W64 0), ![T1] "recv_val", ![T2] "zero2", ![go.bool] "ok")
          else do:  #()))
      else
        (if: (![SelectDir] "dir2") =⟨go.uint64⟩ SelectSend
        then
          (if: let: "$a0" := (![T2] "val2") in
          let: "$a1" := #true in
          (MethodResolve (go.PointerType (Channel T2)) "TrySend"%go #() (![go.PointerType (Channel T2)] "ch2")) "$a0" "$a1"
          then return: (#(W64 1), ![T1] "zero1", ![T2] "zero2", #false)
          else do:  #())
        else
          let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
          let: "recv_val" := (GoAlloc T2 (GoZeroVal T2 #())) in
          let: "selected" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
          let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := #true in
          (MethodResolve (go.PointerType (Channel T2)) "TryReceive"%go #() (![go.PointerType (Channel T2)] "ch2")) "$a0") in
          let: "$r0" := "$ret0" in
          let: "$r1" := "$ret1" in
          let: "$r2" := "$ret2" in
          do:  ("selected" <-[go.bool] "$r0");;;
          do:  ("recv_val" <-[T2] "$r1");;;
          do:  ("ok" <-[go.bool] "$r2");;;
          (if: ![go.bool] "selected"
          then return: (#(W64 1), ![T1] "zero1", ![T2] "recv_val", ![go.bool] "ok")
          else do:  #()))))).

Definition NonBlockingSelect2 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/model/channel.NonBlockingSelect2"%go.

(* Non-blocking select with 2 cases
   Returns (caseIndex, received_value1, received_value2, ok)
   caseIndex = 2 means no selection

   go: select.go:73:6 *)
Definition NonBlockingSelect2ⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} (T1 T2 : go.type) : val :=
  λ: "ch1" "dir1" "val1" "ch2" "dir2" "val2",
    exception_do (let: "val2" := (GoAlloc T2 "val2") in
    let: "dir2" := (GoAlloc SelectDir "dir2") in
    let: "ch2" := (GoAlloc (go.PointerType (Channel T2)) "ch2") in
    let: "val1" := (GoAlloc T1 "val1") in
    let: "dir1" := (GoAlloc SelectDir "dir1") in
    let: "ch1" := (GoAlloc (go.PointerType (Channel T1)) "ch1") in
    let: "zero1" := (GoAlloc T1 (GoZeroVal T1 #())) in
    let: "zero2" := (GoAlloc T2 (GoZeroVal T2 #())) in
    (if: (((FuncResolve primitive.RandomUint64 [] #()) #()) %⟨go.uint64⟩ #(W64 2)) =⟨go.uint64⟩ #(W64 0)
    then
      (if: (![SelectDir] "dir1") =⟨go.uint64⟩ SelectSend
      then
        (if: let: "$a0" := (![T1] "val1") in
        let: "$a1" := #false in
        (MethodResolve (go.PointerType (Channel T1)) "TrySend"%go #() (![go.PointerType (Channel T1)] "ch1")) "$a0" "$a1"
        then return: (#(W64 0), ![T1] "zero1", ![T2] "zero2", #false)
        else do:  #())
      else
        let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
        let: "recv_val" := (GoAlloc T1 (GoZeroVal T1 #())) in
        let: "selected" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
        let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := #false in
        (MethodResolve (go.PointerType (Channel T1)) "TryReceive"%go #() (![go.PointerType (Channel T1)] "ch1")) "$a0") in
        let: "$r0" := "$ret0" in
        let: "$r1" := "$ret1" in
        let: "$r2" := "$ret2" in
        do:  ("selected" <-[go.bool] "$r0");;;
        do:  ("recv_val" <-[T1] "$r1");;;
        do:  ("ok" <-[go.bool] "$r2");;;
        (if: ![go.bool] "selected"
        then return: (#(W64 0), ![T1] "recv_val", ![T2] "zero2", ![go.bool] "ok")
        else do:  #()));;;
      (if: (![SelectDir] "dir2") =⟨go.uint64⟩ SelectSend
      then
        (if: let: "$a0" := (![T2] "val2") in
        let: "$a1" := #false in
        (MethodResolve (go.PointerType (Channel T2)) "TrySend"%go #() (![go.PointerType (Channel T2)] "ch2")) "$a0" "$a1"
        then return: (#(W64 1), ![T1] "zero1", ![T2] "zero2", #false)
        else do:  #())
      else
        let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
        let: "recv_val" := (GoAlloc T2 (GoZeroVal T2 #())) in
        let: "selected" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
        let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := #false in
        (MethodResolve (go.PointerType (Channel T2)) "TryReceive"%go #() (![go.PointerType (Channel T2)] "ch2")) "$a0") in
        let: "$r0" := "$ret0" in
        let: "$r1" := "$ret1" in
        let: "$r2" := "$ret2" in
        do:  ("selected" <-[go.bool] "$r0");;;
        do:  ("recv_val" <-[T2] "$r1");;;
        do:  ("ok" <-[go.bool] "$r2");;;
        (if: ![go.bool] "selected"
        then return: (#(W64 1), ![T1] "zero1", ![T2] "recv_val", ![go.bool] "ok")
        else do:  #()))
    else
      (if: (![SelectDir] "dir2") =⟨go.uint64⟩ SelectSend
      then
        (if: let: "$a0" := (![T2] "val2") in
        let: "$a1" := #false in
        (MethodResolve (go.PointerType (Channel T2)) "TrySend"%go #() (![go.PointerType (Channel T2)] "ch2")) "$a0" "$a1"
        then return: (#(W64 1), ![T1] "zero1", ![T2] "zero2", #false)
        else do:  #())
      else
        let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
        let: "recv_val" := (GoAlloc T2 (GoZeroVal T2 #())) in
        let: "selected" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
        let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := #false in
        (MethodResolve (go.PointerType (Channel T2)) "TryReceive"%go #() (![go.PointerType (Channel T2)] "ch2")) "$a0") in
        let: "$r0" := "$ret0" in
        let: "$r1" := "$ret1" in
        let: "$r2" := "$ret2" in
        do:  ("selected" <-[go.bool] "$r0");;;
        do:  ("recv_val" <-[T2] "$r1");;;
        do:  ("ok" <-[go.bool] "$r2");;;
        (if: ![go.bool] "selected"
        then return: (#(W64 1), ![T1] "zero1", ![T2] "recv_val", ![go.bool] "ok")
        else do:  #()));;;
      (if: (![SelectDir] "dir1") =⟨go.uint64⟩ SelectSend
      then
        (if: let: "$a0" := (![T1] "val1") in
        let: "$a1" := #false in
        (MethodResolve (go.PointerType (Channel T1)) "TrySend"%go #() (![go.PointerType (Channel T1)] "ch1")) "$a0" "$a1"
        then return: (#(W64 0), ![T1] "zero1", ![T2] "zero2", #false)
        else do:  #())
      else
        let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
        let: "recv_val" := (GoAlloc T1 (GoZeroVal T1 #())) in
        let: "selected" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
        let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := #false in
        (MethodResolve (go.PointerType (Channel T1)) "TryReceive"%go #() (![go.PointerType (Channel T1)] "ch1")) "$a0") in
        let: "$r0" := "$ret0" in
        let: "$r1" := "$ret1" in
        let: "$r2" := "$ret2" in
        do:  ("selected" <-[go.bool] "$r0");;;
        do:  ("recv_val" <-[T1] "$r1");;;
        do:  ("ok" <-[go.bool] "$r2");;;
        (if: ![go.bool] "selected"
        then return: (#(W64 0), ![T1] "recv_val", ![T2] "zero2", ![go.bool] "ok")
        else do:  #())));;;
    return: (#(W64 2), ![T1] "zero1", ![T2] "zero2", #false)).

Definition BlockingSelect3 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/model/channel.BlockingSelect3"%go.

(* go: select.go:135:6 *)
Definition BlockingSelect3ⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} (T1 T2 T3 : go.type) : val :=
  λ: "ch1" "dir1" "val1" "ch2" "dir2" "val2" "ch3" "dir3" "val3",
    exception_do (let: "val3" := (GoAlloc T3 "val3") in
    let: "dir3" := (GoAlloc SelectDir "dir3") in
    let: "ch3" := (GoAlloc (go.PointerType (Channel T3)) "ch3") in
    let: "val2" := (GoAlloc T2 "val2") in
    let: "dir2" := (GoAlloc SelectDir "dir2") in
    let: "ch2" := (GoAlloc (go.PointerType (Channel T2)) "ch2") in
    let: "val1" := (GoAlloc T1 "val1") in
    let: "dir1" := (GoAlloc SelectDir "dir1") in
    let: "ch1" := (GoAlloc (go.PointerType (Channel T1)) "ch1") in
    let: "zero1" := (GoAlloc T1 (GoZeroVal T1 #())) in
    let: "zero2" := (GoAlloc T2 (GoZeroVal T2 #())) in
    let: "zero3" := (GoAlloc T3 (GoZeroVal T3 #())) in
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "r" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: "$r0" := (((FuncResolve primitive.RandomUint64 [] #()) #()) %⟨go.uint64⟩ #(W64 3)) in
      do:  ("r" <-[go.uint64] "$r0");;;
      let: "$sw" := (![go.uint64] "r") in
      (if: "$sw" =⟨go.uint64⟩ #(W64 0)
      then
        (if: (![SelectDir] "dir1") =⟨go.uint64⟩ SelectSend
        then
          (if: let: "$a0" := (![T1] "val1") in
          let: "$a1" := #true in
          (MethodResolve (go.PointerType (Channel T1)) "TrySend"%go #() (![go.PointerType (Channel T1)] "ch1")) "$a0" "$a1"
          then return: (#(W64 0), ![T1] "zero1", ![T2] "zero2", ![T3] "zero3", #false)
          else do:  #())
        else
          let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
          let: "recv_val" := (GoAlloc T1 (GoZeroVal T1 #())) in
          let: "selected" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
          let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := #true in
          (MethodResolve (go.PointerType (Channel T1)) "TryReceive"%go #() (![go.PointerType (Channel T1)] "ch1")) "$a0") in
          let: "$r0" := "$ret0" in
          let: "$r1" := "$ret1" in
          let: "$r2" := "$ret2" in
          do:  ("selected" <-[go.bool] "$r0");;;
          do:  ("recv_val" <-[T1] "$r1");;;
          do:  ("ok" <-[go.bool] "$r2");;;
          (if: ![go.bool] "selected"
          then return: (#(W64 0), ![T1] "recv_val", ![T2] "zero2", ![T3] "zero3", ![go.bool] "ok")
          else do:  #()))
      else
        (if: "$sw" =⟨go.uint64⟩ #(W64 1)
        then
          (if: (![SelectDir] "dir2") =⟨go.uint64⟩ SelectSend
          then
            (if: let: "$a0" := (![T2] "val2") in
            let: "$a1" := #true in
            (MethodResolve (go.PointerType (Channel T2)) "TrySend"%go #() (![go.PointerType (Channel T2)] "ch2")) "$a0" "$a1"
            then return: (#(W64 1), ![T1] "zero1", ![T2] "zero2", ![T3] "zero3", #false)
            else do:  #())
          else
            let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
            let: "recv_val" := (GoAlloc T2 (GoZeroVal T2 #())) in
            let: "selected" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
            let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := #true in
            (MethodResolve (go.PointerType (Channel T2)) "TryReceive"%go #() (![go.PointerType (Channel T2)] "ch2")) "$a0") in
            let: "$r0" := "$ret0" in
            let: "$r1" := "$ret1" in
            let: "$r2" := "$ret2" in
            do:  ("selected" <-[go.bool] "$r0");;;
            do:  ("recv_val" <-[T2] "$r1");;;
            do:  ("ok" <-[go.bool] "$r2");;;
            (if: ![go.bool] "selected"
            then return: (#(W64 1), ![T1] "zero1", ![T2] "recv_val", ![T3] "zero3", ![go.bool] "ok")
            else do:  #()))
        else
          (if: (![SelectDir] "dir3") =⟨go.uint64⟩ SelectSend
          then
            (if: let: "$a0" := (![T3] "val3") in
            let: "$a1" := #true in
            (MethodResolve (go.PointerType (Channel T3)) "TrySend"%go #() (![go.PointerType (Channel T3)] "ch3")) "$a0" "$a1"
            then return: (#(W64 2), ![T1] "zero1", ![T2] "zero2", ![T3] "zero3", #false)
            else do:  #())
          else
            let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
            let: "recv_val" := (GoAlloc T3 (GoZeroVal T3 #())) in
            let: "selected" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
            let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := #true in
            (MethodResolve (go.PointerType (Channel T3)) "TryReceive"%go #() (![go.PointerType (Channel T3)] "ch3")) "$a0") in
            let: "$r0" := "$ret0" in
            let: "$r1" := "$ret1" in
            let: "$r2" := "$ret2" in
            do:  ("selected" <-[go.bool] "$r0");;;
            do:  ("recv_val" <-[T3] "$r1");;;
            do:  ("ok" <-[go.bool] "$r2");;;
            (if: ![go.bool] "selected"
            then return: (#(W64 2), ![T1] "zero1", ![T2] "zero2", ![T3] "recv_val", ![go.bool] "ok")
            else do:  #())))))).

Definition NonBlockingSelect3 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/model/channel.NonBlockingSelect3"%go.

(* Non-blocking select with 3 cases
   Returns (caseIndex, received_value1, received_value2, received_value3, ok)
   caseIndex = 3 means no selection

   go: select.go:189:6 *)
Definition NonBlockingSelect3ⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} (T1 T2 T3 : go.type) : val :=
  λ: "ch1" "dir1" "val1" "ch2" "dir2" "val2" "ch3" "dir3" "val3",
    exception_do (let: "val3" := (GoAlloc T3 "val3") in
    let: "dir3" := (GoAlloc SelectDir "dir3") in
    let: "ch3" := (GoAlloc (go.PointerType (Channel T3)) "ch3") in
    let: "val2" := (GoAlloc T2 "val2") in
    let: "dir2" := (GoAlloc SelectDir "dir2") in
    let: "ch2" := (GoAlloc (go.PointerType (Channel T2)) "ch2") in
    let: "val1" := (GoAlloc T1 "val1") in
    let: "dir1" := (GoAlloc SelectDir "dir1") in
    let: "ch1" := (GoAlloc (go.PointerType (Channel T1)) "ch1") in
    let: "zero1" := (GoAlloc T1 (GoZeroVal T1 #())) in
    let: "zero2" := (GoAlloc T2 (GoZeroVal T2 #())) in
    let: "zero3" := (GoAlloc T3 (GoZeroVal T3 #())) in
    let: "start" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (((FuncResolve primitive.RandomUint64 [] #()) #()) %⟨go.uint64⟩ #(W64 3)) in
    do:  ("start" <-[go.uint64] "$r0");;;
    (let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, (![go.uint64] "i") <⟨go.uint64⟩ #(W64 3)); (λ: <>, do:  ("i" <-[go.uint64] ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 1)))) := λ: <>,
      let: "caseIdx" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: "$r0" := (((![go.uint64] "start") +⟨go.uint64⟩ (![go.uint64] "i")) %⟨go.uint64⟩ #(W64 3)) in
      do:  ("caseIdx" <-[go.uint64] "$r0");;;
      (if: (![go.uint64] "caseIdx") =⟨go.uint64⟩ #(W64 0)
      then
        (if: (![SelectDir] "dir1") =⟨go.uint64⟩ SelectSend
        then
          (if: let: "$a0" := (![T1] "val1") in
          let: "$a1" := #false in
          (MethodResolve (go.PointerType (Channel T1)) "TrySend"%go #() (![go.PointerType (Channel T1)] "ch1")) "$a0" "$a1"
          then return: (#(W64 0), ![T1] "zero1", ![T2] "zero2", ![T3] "zero3", #false)
          else do:  #())
        else
          let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
          let: "recv_val" := (GoAlloc T1 (GoZeroVal T1 #())) in
          let: "selected" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
          let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := #false in
          (MethodResolve (go.PointerType (Channel T1)) "TryReceive"%go #() (![go.PointerType (Channel T1)] "ch1")) "$a0") in
          let: "$r0" := "$ret0" in
          let: "$r1" := "$ret1" in
          let: "$r2" := "$ret2" in
          do:  ("selected" <-[go.bool] "$r0");;;
          do:  ("recv_val" <-[T1] "$r1");;;
          do:  ("ok" <-[go.bool] "$r2");;;
          (if: ![go.bool] "selected"
          then return: (#(W64 0), ![T1] "recv_val", ![T2] "zero2", ![T3] "zero3", ![go.bool] "ok")
          else do:  #()))
      else
        (if: (![go.uint64] "caseIdx") =⟨go.uint64⟩ #(W64 1)
        then
          (if: (![SelectDir] "dir2") =⟨go.uint64⟩ SelectSend
          then
            (if: let: "$a0" := (![T2] "val2") in
            let: "$a1" := #false in
            (MethodResolve (go.PointerType (Channel T2)) "TrySend"%go #() (![go.PointerType (Channel T2)] "ch2")) "$a0" "$a1"
            then return: (#(W64 1), ![T1] "zero1", ![T2] "zero2", ![T3] "zero3", #false)
            else do:  #())
          else
            let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
            let: "recv_val" := (GoAlloc T2 (GoZeroVal T2 #())) in
            let: "selected" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
            let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := #false in
            (MethodResolve (go.PointerType (Channel T2)) "TryReceive"%go #() (![go.PointerType (Channel T2)] "ch2")) "$a0") in
            let: "$r0" := "$ret0" in
            let: "$r1" := "$ret1" in
            let: "$r2" := "$ret2" in
            do:  ("selected" <-[go.bool] "$r0");;;
            do:  ("recv_val" <-[T2] "$r1");;;
            do:  ("ok" <-[go.bool] "$r2");;;
            (if: ![go.bool] "selected"
            then return: (#(W64 1), ![T1] "zero1", ![T2] "recv_val", ![T3] "zero3", ![go.bool] "ok")
            else do:  #()))
        else
          (if: (![SelectDir] "dir3") =⟨go.uint64⟩ SelectSend
          then
            (if: let: "$a0" := (![T3] "val3") in
            let: "$a1" := #false in
            (MethodResolve (go.PointerType (Channel T3)) "TrySend"%go #() (![go.PointerType (Channel T3)] "ch3")) "$a0" "$a1"
            then return: (#(W64 2), ![T1] "zero1", ![T2] "zero2", ![T3] "zero3", #false)
            else do:  #())
          else
            let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
            let: "recv_val" := (GoAlloc T3 (GoZeroVal T3 #())) in
            let: "selected" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
            let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := #false in
            (MethodResolve (go.PointerType (Channel T3)) "TryReceive"%go #() (![go.PointerType (Channel T3)] "ch3")) "$a0") in
            let: "$r0" := "$ret0" in
            let: "$r1" := "$ret1" in
            let: "$r2" := "$ret2" in
            do:  ("selected" <-[go.bool] "$r0");;;
            do:  ("recv_val" <-[T3] "$r1");;;
            do:  ("ok" <-[go.bool] "$r2");;;
            (if: ![go.bool] "selected"
            then return: (#(W64 2), ![T1] "zero1", ![T2] "zero2", ![T3] "recv_val", ![go.bool] "ok")
            else do:  #()))))));;;
    return: (#(W64 3), ![T1] "zero1", ![T2] "zero2", ![T3] "zero3", #false)).

#[global] Instance info' : PkgInfo channel.channel := 
{|
  pkg_imported_pkgs := [code.github_com.goose_lang.primitive.primitive]
|}.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init channel.channel (λ: <>,
      exception_do (do:  (primitive.initialize' #()))
      ).

Class Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] offerState_instance :: offerState_Assumptions;
  #[global] Channel_instance :: Channel_Assumptions;
  #[global] SelectDir_instance :: SelectDir_Assumptions;
  #[global] NewChannel_unfold T :: FuncUnfold NewChannel [T] (NewChannelⁱᵐᵖˡ T);
  #[global] NonBlockingSelect1_unfold T :: FuncUnfold NonBlockingSelect1 [T] (NonBlockingSelect1ⁱᵐᵖˡ T);
  #[global] BlockingSelect2_unfold T1 T2 :: FuncUnfold BlockingSelect2 [T1; T2] (BlockingSelect2ⁱᵐᵖˡ T1 T2);
  #[global] NonBlockingSelect2_unfold T1 T2 :: FuncUnfold NonBlockingSelect2 [T1; T2] (NonBlockingSelect2ⁱᵐᵖˡ T1 T2);
  #[global] BlockingSelect3_unfold T1 T2 T3 :: FuncUnfold BlockingSelect3 [T1; T2; T3] (BlockingSelect3ⁱᵐᵖˡ T1 T2 T3);
  #[global] NonBlockingSelect3_unfold T1 T2 T3 :: FuncUnfold NonBlockingSelect3 [T1; T2; T3] (NonBlockingSelect3ⁱᵐᵖˡ T1 T2 T3);
}.
End channel.
