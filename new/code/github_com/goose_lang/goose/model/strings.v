(* autogenerated from github.com/goose-lang/goose/model/strings *)
From New.golang Require Import defn.core.
From New.golang.defn Require Export slice defer.
Module pkg_id.
Definition strings : go_string := "github.com/goose-lang/goose/model/strings".

End pkg_id.
Export pkg_id.
Module strings.

Definition StringToByteSlice {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/model/strings.StringToByteSlice"%go.

Definition ByteSliceToString {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/goose/model/strings.ByteSliceToString"%go.

(* go: convert.go:3:6 *)
Definition StringToByteSliceⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s",
    exception_do (let: "a" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "s" := (GoAlloc go.string "s") in
    (let: "i" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.int] "$r0");;;
    (for: (λ: <>, (![go.int] "i") <⟨go.int⟩ (let: "$a0" := (![go.string] "s") in
    (FuncResolve go.len [go.string] #()) "$a0")); (λ: <>, do:  ("i" <-[go.int] ((![go.int] "i") +⟨go.int⟩ #(W64 1)))) := λ: <>,
      let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "a") in
      let: "$a1" := ((let: "$sl0" := (Index go.string (![go.string] "s", ![go.int] "i")) in
      CompositeLiteral (go.SliceType go.byte) (LiteralValue [KeyedElement None (ElementExpression "$sl0")]))) in
      (FuncResolve go.append [go.SliceType go.byte] #()) "$a0" "$a1") in
      do:  ("a" <-[go.SliceType go.byte] "$r0")));;;
    return: (![go.SliceType go.byte] "a")).

(* go: convert.go:11:6 *)
Definition ByteSliceToStringⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "a",
    exception_do (let: "s" := (GoAlloc go.string (GoZeroVal go.string #())) in
    let: "a" := (GoAlloc (go.SliceType go.byte) "a") in
    let: "$range" := (![go.SliceType go.byte] "a") in
    (let: "c" := (GoAlloc go.byte (GoZeroVal go.byte #())) in
    slice.for_range go.byte "$range" (λ: "$key" "$value",
      do:  ("c" <-[go.byte] "$value");;;
      do:  "$key";;;
      let: "$r0" := ((![go.string] "s") +⟨go.string⟩ (Convert go.byte go.string (![go.byte] "c"))) in
      do:  ("s" <-[go.string] "$r0")));;;
    return: (![go.string] "s")).

#[global] Instance info' : PkgInfo pkg_id.strings :=
{|
  pkg_imported_pkgs := []
|}.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init pkg_id.strings (λ: <>,
      exception_do (do:  #())
      ).

Class Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] StringToByteSlice_unfold :: FuncUnfold StringToByteSlice [] (StringToByteSliceⁱᵐᵖˡ);
  #[global] ByteSliceToString_unfold :: FuncUnfold ByteSliceToString [] (ByteSliceToStringⁱᵐᵖˡ);
}.
End strings.
