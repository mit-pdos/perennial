(* autogenerated from github.com/goose-lang/std *)
Require Export New.code.math.
Require Export New.code.sync.
Require Export New.code.time.
Require Export New.code.github_com.goose_lang.primitive.
Require Export New.code.github_com.goose_lang.std.std_core.
From New.golang Require Import defn.
Module pkg_id.
Definition std : go_string := "github.com/goose-lang/std".

End pkg_id.
Export pkg_id.
Module std.

Definition JoinHandle {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/goose-lang/std.JoinHandle"%go [].

#[global] Opaque JoinHandle.

Definition Assert {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/std.Assert"%go.

Definition SumNoOverflow {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/std.SumNoOverflow"%go.

Definition SumAssumeNoOverflow {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/std.SumAssumeNoOverflow"%go.

Definition SignedSumAssumeNoOverflow {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/std.SignedSumAssumeNoOverflow"%go.

Definition BytesEqual {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/std.BytesEqual"%go.

Definition BytesClone {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/std.BytesClone"%go.

Definition SliceSplit {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/std.SliceSplit"%go.

Definition newJoinHandle {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/std.newJoinHandle"%go.

Definition Spawn {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/std.Spawn"%go.

Definition Multipar {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/std.Multipar"%go.

Definition Skip {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/std.Skip"%go.

Definition WaitTimeout {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/std.WaitTimeout"%go.

(* Assert(b) panics if b doesn't hold

   go: goose_std.go:13:6 *)
Definition Assertⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "b",
    exception_do (let: "b" := (GoAlloc go.bool "b") in
    (if: (⟨go.bool⟩! (![go.bool] "b"))
    then
      do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"assertion failure"%go) in
      (FuncResolve go.panic [] #()) "$a0")
    else do:  #());;;
    return: #()).

(* Returns true if x + y does not overflow

   go: goose_std.go:20:6 *)
Definition SumNoOverflowⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x" "y",
    exception_do (let: "y" := (GoAlloc go.uint64 "y") in
    let: "x" := (GoAlloc go.uint64 "x") in
    return: (let: "$a0" := (![go.uint64] "x") in
     let: "$a1" := (![go.uint64] "y") in
     (FuncResolve std_core.SumNoOverflow [] #()) "$a0" "$a1")).

(* SumAssumeNoOverflow returns x + y, `Assume`ing that this does not overflow.

   *Use with care* - if the assumption is violated this function will panic.

   go: goose_std.go:27:6 *)
Definition SumAssumeNoOverflowⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x" "y",
    exception_do (let: "y" := (GoAlloc go.uint64 "y") in
    let: "x" := (GoAlloc go.uint64 "x") in
    return: (let: "$a0" := (![go.uint64] "x") in
     let: "$a1" := (![go.uint64] "y") in
     (FuncResolve std_core.SumAssumeNoOverflow [] #()) "$a0" "$a1")).

(* go: goose_std.go:31:6 *)
Definition SignedSumAssumeNoOverflowⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x" "y",
    exception_do (let: "y" := (GoAlloc go.int "y") in
    let: "x" := (GoAlloc go.int "x") in
    do:  (let: "$a0" := ((((![go.int] "y") ≥⟨go.int⟩ #(W64 0)) && ((![go.int] "x") ≤⟨go.int⟩ ((Convert go.untyped_int go.int math.MaxInt) -⟨go.int⟩ (![go.int] "y")))) || (((![go.int] "y") <⟨go.int⟩ #(W64 0)) && ((![go.int] "x") ≥⟨go.int⟩ ((Convert go.untyped_int go.int math.MinInt) -⟨go.int⟩ (![go.int] "y"))))) in
    (FuncResolve primitive.Assume [] #()) "$a0");;;
    return: ((![go.int] "x") +⟨go.int⟩ (![go.int] "y"))).

(* BytesEqual returns if the two byte slices are equal.

   go: goose_std.go:37:6 *)
Definition BytesEqualⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x" "y",
    exception_do (let: "y" := (GoAlloc (go.SliceType go.byte) "y") in
    let: "x" := (GoAlloc (go.SliceType go.byte) "x") in
    let: "xlen" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "x") in
    (FuncResolve go.len [go.SliceType go.byte] #()) "$a0") in
    do:  ("xlen" <-[go.int] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.int] "xlen") ≠⟨go.int⟩ (let: "$a0" := (![go.SliceType go.byte] "y") in
    (FuncResolve go.len [go.SliceType go.byte] #()) "$a0"))
    then return: (#false)
    else do:  #());;;
    let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    let: "retval" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #true in
    do:  ("retval" <-[go.bool] "$r0");;;
    (for: (λ: <>, (![go.uint64] "i") <⟨go.uint64⟩ (Convert go.int go.uint64 (![go.int] "xlen"))); (λ: <>, #()) := λ: <>,
      (if: Convert go.untyped_bool go.bool ((![go.byte] (IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "x", Convert go.uint64 go.int (![go.uint64] "i")))) ≠⟨go.byte⟩ (![go.byte] (IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "y", Convert go.uint64 go.int (![go.uint64] "i")))))
      then
        let: "$r0" := #false in
        do:  ("retval" <-[go.bool] "$r0");;;
        break: #()
      else do:  #());;;
      do:  ("i" <-[go.uint64] ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 1)));;;
      continue: #());;;
    return: (![go.bool] "retval")).

(* See the [reference].

   [reference]: https://pkg.go.dev/bytes#Clone

   go: goose_std.go:58:6 *)
Definition BytesCloneⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "b",
    exception_do (let: "b" := (GoAlloc (go.SliceType go.byte) "b") in
    (if: Convert go.untyped_bool go.bool ((![go.SliceType go.byte] "b") =⟨go.SliceType go.byte⟩ (Convert go.untyped_nil (go.SliceType go.byte) UntypedNil))
    then return: (Convert go.untyped_nil (go.SliceType go.byte) UntypedNil)
    else do:  #());;;
    return: (let: "$a0" := (CompositeLiteral (go.SliceType go.byte) (LiteralValue [])) in
     let: "$a1" := (![go.SliceType go.byte] "b") in
     (FuncResolve go.append [go.SliceType go.byte] #()) "$a0" "$a1")).

(* SliceSplit splits xs at n into two slices.

   The capacity of the first slice overlaps with the second, so afterward it is
   no longer safe to append to the first slice.

   go: goose_std.go:69:6 *)
Definition SliceSplitⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} (T : go.type) : val :=
  λ: "xs" "n",
    exception_do (let: "n" := (GoAlloc go.uint64 "n") in
    let: "xs" := (GoAlloc (go.SliceType T) "xs") in
    return: (let: "$s" := (![go.SliceType T] "xs") in
     Slice (go.SliceType T) ("$s", #(W64 0), ![go.uint64] "n"), let: "$s" := (![go.SliceType T] "xs") in
     Slice (go.SliceType T) ("$s", ![go.uint64] "n", FuncResolve go.len [go.SliceType T] #() (![go.SliceType T] "xs")))).

(* go: goose_std.go:84:6 *)
Definition newJoinHandleⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "mu" := (GoAlloc (go.PointerType sync.Mutex) (GoZeroVal (go.PointerType sync.Mutex) #())) in
    let: "$r0" := (GoAlloc sync.Mutex (GoZeroVal sync.Mutex #())) in
    do:  ("mu" <-[go.PointerType sync.Mutex] "$r0");;;
    let: "cond" := (GoAlloc (go.PointerType sync.Cond) (GoZeroVal (go.PointerType sync.Cond) #())) in
    let: "$r0" := (let: "$a0" := (Convert (go.PointerType sync.Mutex) sync.Locker (![go.PointerType sync.Mutex] "mu")) in
    (FuncResolve sync.NewCond [] #()) "$a0") in
    do:  ("cond" <-[go.PointerType sync.Cond] "$r0");;;
    return: (GoAlloc JoinHandle (let: "$v0" := (![go.PointerType sync.Mutex] "mu") in
     let: "$v1" := #false in
     let: "$v2" := (![go.PointerType sync.Cond] "cond") in
     CompositeLiteral JoinHandle (LiteralValue [KeyedElement (Some (KeyField "mu"%go)) (ElementExpression (go.PointerType sync.Mutex) "$v0"); KeyedElement (Some (KeyField "done"%go)) (ElementExpression go.bool "$v1"); KeyedElement (Some (KeyField "cond"%go)) (ElementExpression (go.PointerType sync.Cond) "$v2")])))).

(* go: goose_std.go:94:22 *)
Definition JoinHandle__finishⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "h" <>,
    exception_do (let: "h" := (GoAlloc (go.PointerType JoinHandle) "h") in
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] (StructFieldRef JoinHandle "mu"%go (![go.PointerType JoinHandle] "h")))) #());;;
    let: "$r0" := #true in
    do:  ((StructFieldRef JoinHandle "done"%go (![go.PointerType JoinHandle] "h")) <-[go.bool] "$r0");;;
    do:  ((MethodResolve (go.PointerType sync.Cond) "Signal"%go (![go.PointerType sync.Cond] (StructFieldRef JoinHandle "cond"%go (![go.PointerType JoinHandle] "h")))) #());;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef JoinHandle "mu"%go (![go.PointerType JoinHandle] "h")))) #());;;
    return: #()).

(* Spawn runs `f` in a parallel goroutine and returns a handle to wait for
   it to finish.

   Due to Goose limitations we do not return anything from the function, but it
   could return an `interface{}` value or be generic in the return value with
   essentially the same implementation, replacing `done` with a pointer to the
   result value.

   go: goose_std.go:108:6 *)
Definition Spawnⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "f",
    exception_do (let: "f" := (GoAlloc (go.FunctionType (go.Signature [] false [])) "f") in
    let: "h" := (GoAlloc (go.PointerType JoinHandle) (GoZeroVal (go.PointerType JoinHandle) #())) in
    let: "$r0" := ((FuncResolve newJoinHandle [] #()) #()) in
    do:  ("h" <-[go.PointerType JoinHandle] "$r0");;;
    let: "$go" := (λ: <>,
      exception_do (do:  ((![go.FunctionType (go.Signature [] false [])] "f") #());;;
      do:  ((MethodResolve (go.PointerType JoinHandle) "finish"%go (![go.PointerType JoinHandle] "h")) #());;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    return: (![go.PointerType JoinHandle] "h")).

(* go: goose_std.go:117:22 *)
Definition JoinHandle__Joinⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "h" <>,
    exception_do (let: "h" := (GoAlloc (go.PointerType JoinHandle) "h") in
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] (StructFieldRef JoinHandle "mu"%go (![go.PointerType JoinHandle] "h")))) #());;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (if: ![go.bool] (StructFieldRef JoinHandle "done"%go (![go.PointerType JoinHandle] "h"))
      then
        let: "$r0" := #false in
        do:  ((StructFieldRef JoinHandle "done"%go (![go.PointerType JoinHandle] "h")) <-[go.bool] "$r0");;;
        break: #()
      else do:  #());;;
      do:  ((MethodResolve (go.PointerType sync.Cond) "Wait"%go (![go.PointerType sync.Cond] (StructFieldRef JoinHandle "cond"%go (![go.PointerType JoinHandle] "h")))) #()));;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef JoinHandle "mu"%go (![go.PointerType JoinHandle] "h")))) #());;;
    return: #()).

(* Multipar runs op(0) ... op(num-1) in parallel and waits for them all to finish.

   Implementation note: does not use a done channel (which is the standard
   pattern in Go) because this is not supported by Goose. Instead uses mutexes
   and condition variables since these are modeled in Goose

   go: goose_std.go:136:6 *)
Definition Multiparⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "num" "op",
    exception_do (let: "op" := (GoAlloc (go.FunctionType (go.Signature [go.uint64] false [])) "op") in
    let: "num" := (GoAlloc go.uint64 "num") in
    let: "num_left" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (![go.uint64] "num") in
    do:  ("num_left" <-[go.uint64] "$r0");;;
    let: "num_left_mu" := (GoAlloc (go.PointerType sync.Mutex) (GoZeroVal (go.PointerType sync.Mutex) #())) in
    let: "$r0" := (GoAlloc sync.Mutex (GoZeroVal sync.Mutex #())) in
    do:  ("num_left_mu" <-[go.PointerType sync.Mutex] "$r0");;;
    let: "num_left_cond" := (GoAlloc (go.PointerType sync.Cond) (GoZeroVal (go.PointerType sync.Cond) #())) in
    let: "$r0" := (let: "$a0" := (Convert (go.PointerType sync.Mutex) sync.Locker (![go.PointerType sync.Mutex] "num_left_mu")) in
    (FuncResolve sync.NewCond [] #()) "$a0") in
    do:  ("num_left_cond" <-[go.PointerType sync.Cond] "$r0");;;
    (let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, (![go.uint64] "i") <⟨go.uint64⟩ (![go.uint64] "num")); (λ: <>, do:  ("i" <-[go.uint64] ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 1)))) := λ: <>,
      let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: "$r0" := (![go.uint64] "i") in
      do:  ("i" <-[go.uint64] "$r0");;;
      let: "$go" := (λ: <>,
        exception_do (do:  (let: "$a0" := (![go.uint64] "i") in
        (![go.FunctionType (go.Signature [go.uint64] false [])] "op") "$a0");;;
        do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] "num_left_mu")) #());;;
        do:  ("num_left" <-[go.uint64] ((![go.uint64] "num_left") -⟨go.uint64⟩ #(W64 1)));;;
        do:  ((MethodResolve (go.PointerType sync.Cond) "Signal"%go (![go.PointerType sync.Cond] "num_left_cond")) #());;;
        do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] "num_left_mu")) #());;;
        return: #())
        ) in
      do:  (Fork ("$go" #()))));;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] "num_left_mu")) #());;;
    (for: (λ: <>, (![go.uint64] "num_left") >⟨go.uint64⟩ #(W64 0)); (λ: <>, #()) := λ: <>,
      do:  ((MethodResolve (go.PointerType sync.Cond) "Wait"%go (![go.PointerType sync.Cond] "num_left_cond")) #()));;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] "num_left_mu")) #());;;
    return: #()).

(* Skip is a no-op that can be useful in proofs.

   Occasionally a proof may need to open an invariant and perform a ghost update
   across a step in the operational semantics. The GooseLang model may not have
   a convenient step, but it is always sound to insert more. Calling std.Skip()
   is a simple way to do so - the model always requires one step to reduce this
   application to a value.

   go: goose_std.go:167:6 *)
Definition Skipⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (do:  #()).

(* WaitTimeout is like cond.Wait(), but waits for a maximum time of timeoutMs
   milliseconds.

   Not provided by sync.Cond, so we have to (inefficiently) implement this
   ourselves.

   go: goose_std.go:174:6 *)
Definition WaitTimeoutⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "cond" "timeoutMs",
    exception_do (let: "timeoutMs" := (GoAlloc go.uint64 "timeoutMs") in
    let: "cond" := (GoAlloc (go.PointerType sync.Cond) "cond") in
    let: "done" := (GoAlloc (go.ChannelType go.sendrecv (go.StructType [

    ])) (GoZeroVal (go.ChannelType go.sendrecv (go.StructType [

    ])) #())) in
    let: "$r0" := ((FuncResolve go.make1 [go.ChannelType go.sendrecv (go.StructType [

     ])] #()) #()) in
    do:  ("done" <-[go.ChannelType go.sendrecv (go.StructType [

    ])] "$r0");;;
    let: "$go" := (λ: <>,
      exception_do (do:  ((MethodResolve (go.PointerType sync.Cond) "Wait"%go (![go.PointerType sync.Cond] "cond")) #());;;
      do:  ((MethodResolve sync.Locker "Unlock"%go (![sync.Locker] (StructFieldRef sync.Cond "L"%go (![go.PointerType sync.Cond] "cond")))) #());;;
      do:  (let: "$a0" := (![go.ChannelType go.sendrecv (go.StructType [

      ])] "done") in
      (FuncResolve go.close [go.ChannelType go.sendrecv (go.StructType [

       ])] #()) "$a0");;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    let: "$ch0" := (let: "$a0" := ((Convert go.uint64 time.Duration (![go.uint64] "timeoutMs")) *⟨time.Duration⟩ time.Millisecond) in
    (FuncResolve time.After [] #()) "$a0") in
    let: "$ch1" := (![go.ChannelType go.sendrecv (go.StructType [

    ])] "done") in
    SelectStmt (SelectStmtClauses None [(CommClause (RecvCase time.Time "$ch0") (do:  ((MethodResolve sync.Locker "Lock"%go (![sync.Locker] (StructFieldRef sync.Cond "L"%go (![go.PointerType sync.Cond] "cond")))) #());;;
    return: (#()))); (CommClause (RecvCase (go.StructType [

    ]) "$ch1") (do:  ((MethodResolve sync.Locker "Lock"%go (![sync.Locker] (StructFieldRef sync.Cond "L"%go (![go.PointerType sync.Cond] "cond")))) #());;;
    return: (#())))]);;;
    return: #()).

#[global] Instance info' : PkgInfo pkg_id.std :=
{|
  pkg_imported_pkgs := [code.math.pkg_id.math; code.sync.pkg_id.sync; code.time.pkg_id.time; code.github_com.goose_lang.primitive.pkg_id.primitive; code.github_com.goose_lang.std.std_core.pkg_id.std_core]
|}.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init pkg_id.std (λ: <>,
      exception_do (do:  (std_core.initialize' #());;;
      do:  (primitive.initialize' #());;;
      do:  (time.initialize' #());;;
      do:  (sync.initialize' #());;;
      do:  (math.initialize' #()))
      ).

Module JoinHandle.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  mu' : loc;
  done' : bool;
  cond' : loc;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End JoinHandle.

Definition JoinHandle'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "mu"%go (go.PointerType sync.Mutex));
  (go.FieldDecl "done"%go go.bool);
  (go.FieldDecl "cond"%go (go.PointerType sync.Cond))
].
Program Definition JoinHandle'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (JoinHandle'fds_unsealed).
Global Instance equals_unfold_JoinHandle {ext : ffi_syntax} {go_gctx : GoGlobalContext} : JoinHandle'fds =→ JoinHandle'fds_unsealed.
Proof. rewrite /JoinHandle'fds seal_eq //. Qed.

Definition JoinHandleⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (JoinHandle'fds).

Class JoinHandle_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] JoinHandle_type_repr  :: go.TypeReprUnderlying JoinHandleⁱᵐᵖˡ JoinHandle.t;
  #[global] JoinHandle_underlying :: (JoinHandle) <u (JoinHandleⁱᵐᵖˡ);
  #[global] JoinHandle_get_mu (x : JoinHandle.t) :: ⟦StructFieldGet (JoinHandleⁱᵐᵖˡ) "mu", #x⟧ ⤳[under] #x.(JoinHandle.mu');
  #[global] JoinHandle_set_mu (x : JoinHandle.t) y :: ⟦StructFieldSet (JoinHandleⁱᵐᵖˡ) "mu", (#x, #y)⟧ ⤳[under] #(x <|JoinHandle.mu' := y|>);
  #[global] JoinHandle_get_done (x : JoinHandle.t) :: ⟦StructFieldGet (JoinHandleⁱᵐᵖˡ) "done", #x⟧ ⤳[under] #x.(JoinHandle.done');
  #[global] JoinHandle_set_done (x : JoinHandle.t) y :: ⟦StructFieldSet (JoinHandleⁱᵐᵖˡ) "done", (#x, #y)⟧ ⤳[under] #(x <|JoinHandle.done' := y|>);
  #[global] JoinHandle_get_cond (x : JoinHandle.t) :: ⟦StructFieldGet (JoinHandleⁱᵐᵖˡ) "cond", #x⟧ ⤳[under] #x.(JoinHandle.cond');
  #[global] JoinHandle_set_cond (x : JoinHandle.t) y :: ⟦StructFieldSet (JoinHandleⁱᵐᵖˡ) "cond", (#x, #y)⟧ ⤳[under] #(x <|JoinHandle.cond' := y|>);
  #[global] JoinHandle'ptr_Join_unfold :: MethodUnfold (go.PointerType (JoinHandle)) "Join" (JoinHandle__Joinⁱᵐᵖˡ);
  #[global] JoinHandle'ptr_finish_unfold :: MethodUnfold (go.PointerType (JoinHandle)) "finish" (JoinHandle__finishⁱᵐᵖˡ);
}.

Class Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] JoinHandle_instance :: JoinHandle_Assumptions;
  #[global] Assert_unfold :: FuncUnfold Assert [] (Assertⁱᵐᵖˡ);
  #[global] SumNoOverflow_unfold :: FuncUnfold SumNoOverflow [] (SumNoOverflowⁱᵐᵖˡ);
  #[global] SumAssumeNoOverflow_unfold :: FuncUnfold SumAssumeNoOverflow [] (SumAssumeNoOverflowⁱᵐᵖˡ);
  #[global] SignedSumAssumeNoOverflow_unfold :: FuncUnfold SignedSumAssumeNoOverflow [] (SignedSumAssumeNoOverflowⁱᵐᵖˡ);
  #[global] BytesEqual_unfold :: FuncUnfold BytesEqual [] (BytesEqualⁱᵐᵖˡ);
  #[global] BytesClone_unfold :: FuncUnfold BytesClone [] (BytesCloneⁱᵐᵖˡ);
  #[global] SliceSplit_unfold T :: FuncUnfold SliceSplit [T] (SliceSplitⁱᵐᵖˡ T);
  #[global] newJoinHandle_unfold :: FuncUnfold newJoinHandle [] (newJoinHandleⁱᵐᵖˡ);
  #[global] Spawn_unfold :: FuncUnfold Spawn [] (Spawnⁱᵐᵖˡ);
  #[global] Multipar_unfold :: FuncUnfold Multipar [] (Multiparⁱᵐᵖˡ);
  #[global] Skip_unfold :: FuncUnfold Skip [] (Skipⁱᵐᵖˡ);
  #[global] WaitTimeout_unfold :: FuncUnfold WaitTimeout [] (WaitTimeoutⁱᵐᵖˡ);
  #[global] import_math_Assumption :: math.Assumptions;
  #[global] import_sync_Assumption :: sync.Assumptions;
  #[global] import_time_Assumption :: time.Assumptions;
  #[global] import_primitive_Assumption :: primitive.Assumptions;
  #[global] import_std_core_Assumption :: std_core.Assumptions;
}.
End std.
