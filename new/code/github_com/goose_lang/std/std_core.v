(* autogenerated from github.com/goose-lang/std/std_core *)
Require Export New.code.github_com.goose_lang.primitive.
From New.golang Require Import defn.pre.
From New.golang.defn Require Export slice.
Module pkg_id.
Definition std_core : go_string := "github.com/goose-lang/std/std_core".

End pkg_id.
Export pkg_id.
Module std_core.

Definition SumNoOverflow {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/std/std_core.SumNoOverflow"%go.

Definition SumAssumeNoOverflow {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/std/std_core.SumAssumeNoOverflow"%go.

Definition MulNoOverflow {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/std/std_core.MulNoOverflow"%go.

Definition MulAssumeNoOverflow {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/std/std_core.MulAssumeNoOverflow"%go.

Definition Shuffle {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/std/std_core.Shuffle"%go.

Definition Permutation {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/goose-lang/std/std_core.Permutation"%go.

(* Returns true if x + y does not overflow

   go: std_core.go:11:6 *)
Definition SumNoOverflowⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x" "y",
    exception_do (let: "y" := (GoAlloc go.uint64 "y") in
    let: "x" := (GoAlloc go.uint64 "x") in
    return: (((![go.uint64] "x") +⟨go.uint64⟩ (![go.uint64] "y")) ≥⟨go.uint64⟩ (![go.uint64] "x"))).

(* SumAssumeNoOverflow returns x + y, `Assume`ing that this does not overflow.

   *Use with care* - if the assumption is violated this function will panic.

   go: std_core.go:18:6 *)
Definition SumAssumeNoOverflowⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x" "y",
    exception_do (let: "y" := (GoAlloc go.uint64 "y") in
    let: "x" := (GoAlloc go.uint64 "x") in
    do:  (let: "$a0" := (let: "$a0" := (![go.uint64] "x") in
    let: "$a1" := (![go.uint64] "y") in
    (FuncResolve SumNoOverflow [] #()) "$a0" "$a1") in
    (FuncResolve primitive.Assume [] #()) "$a0");;;
    return: ((![go.uint64] "x") +⟨go.uint64⟩ (![go.uint64] "y"))).

(* MulNoOverflow returns true if x * y does not overflow

   go: std_core.go:24:6 *)
Definition MulNoOverflowⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x" "y",
    exception_do (let: "y" := (GoAlloc go.uint64 "y") in
    let: "x" := (GoAlloc go.uint64 "x") in
    (if: Convert go.untyped_bool go.bool (((![go.uint64] "x") =⟨go.uint64⟩ #(W64 0)) || ((![go.uint64] "y") =⟨go.uint64⟩ #(W64 0)))
    then return: (#true)
    else do:  #());;;
    return: ((![go.uint64] "x") ≤⟨go.uint64⟩ (#(W64 18446744073709551615) /⟨go.uint64⟩ (![go.uint64] "y")))).

(* MulAssumeNoOverflow returns x * y, `Assume`ing that this does not overflow.

   *Use with care* - if the assumption is violated this function will panic.

   go: std_core.go:34:6 *)
Definition MulAssumeNoOverflowⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x" "y",
    exception_do (let: "y" := (GoAlloc go.uint64 "y") in
    let: "x" := (GoAlloc go.uint64 "x") in
    do:  (let: "$a0" := (let: "$a0" := (![go.uint64] "x") in
    let: "$a1" := (![go.uint64] "y") in
    (FuncResolve MulNoOverflow [] #()) "$a0" "$a1") in
    (FuncResolve primitive.Assume [] #()) "$a0");;;
    return: ((![go.uint64] "x") *⟨go.uint64⟩ (![go.uint64] "y"))).

(* Shuffle shuffles the elements of xs in place, using a Fisher-Yates shuffle.

   go: std_core.go:40:6 *)
Definition Shuffleⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "xs",
    exception_do (let: "xs" := (GoAlloc (go.SliceType go.uint64) "xs") in
    (if: Convert go.untyped_bool go.bool ((let: "$a0" := (![go.SliceType go.uint64] "xs") in
    (FuncResolve go.len [go.SliceType go.uint64] #()) "$a0") =⟨go.int⟩ #(W64 0))
    then return: (#())
    else do:  #());;;
    (let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (Convert go.int go.uint64 ((let: "$a0" := (![go.SliceType go.uint64] "xs") in
    (FuncResolve go.len [go.SliceType go.uint64] #()) "$a0") -⟨go.int⟩ #(W64 1))) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, (![go.uint64] "i") >⟨go.uint64⟩ #(W64 0)); (λ: <>, do:  ("i" <-[go.uint64] ((![go.uint64] "i") -⟨go.uint64⟩ #(W64 1)))) := λ: <>,
      let: "j" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: "$r0" := (((FuncResolve primitive.RandomUint64 [] #()) #()) %⟨go.uint64⟩ ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 1))) in
      do:  ("j" <-[go.uint64] "$r0");;;
      let: "temp" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: "$r0" := (![go.uint64] (IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "xs", Convert go.uint64 go.int (![go.uint64] "i")))) in
      do:  ("temp" <-[go.uint64] "$r0");;;
      let: "$r0" := (![go.uint64] (IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "xs", Convert go.uint64 go.int (![go.uint64] "j")))) in
      do:  ((IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "xs", Convert go.uint64 go.int (![go.uint64] "i"))) <-[go.uint64] "$r0");;;
      let: "$r0" := (![go.uint64] "temp") in
      do:  ((IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "xs", Convert go.uint64 go.int (![go.uint64] "j"))) <-[go.uint64] "$r0")));;;
    return: #()).

(* Permutation returns a random permutation of the integers 0, ..., n-1, using a
   Fisher-Yates shuffle.

   go: std_core.go:54:6 *)
Definition Permutationⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "n",
    exception_do (let: "n" := (GoAlloc go.uint64 "n") in
    let: "order" := (GoAlloc (go.SliceType go.uint64) (GoZeroVal (go.SliceType go.uint64) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType go.uint64] #()) (![go.uint64] "n")) in
    do:  ("order" <-[go.SliceType go.uint64] "$r0");;;
    (let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, (![go.uint64] "i") <⟨go.uint64⟩ (![go.uint64] "n")); (λ: <>, do:  ("i" <-[go.uint64] ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 1)))) := λ: <>,
      let: "$r0" := (![go.uint64] "i") in
      do:  ((IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "order", Convert go.uint64 go.int (![go.uint64] "i"))) <-[go.uint64] "$r0")));;;
    do:  (let: "$a0" := (![go.SliceType go.uint64] "order") in
    (FuncResolve Shuffle [] #()) "$a0");;;
    return: (![go.SliceType go.uint64] "order")).

#[global] Instance info' : PkgInfo pkg_id.std_core :=
{|
  pkg_imported_pkgs := [code.github_com.goose_lang.primitive.pkg_id.primitive]
|}.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init pkg_id.std_core (λ: <>,
      exception_do (do:  (primitive.initialize' #()))
      ).

Class Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] SumNoOverflow_unfold :: FuncUnfold SumNoOverflow [] (SumNoOverflowⁱᵐᵖˡ);
  #[global] SumAssumeNoOverflow_unfold :: FuncUnfold SumAssumeNoOverflow [] (SumAssumeNoOverflowⁱᵐᵖˡ);
  #[global] MulNoOverflow_unfold :: FuncUnfold MulNoOverflow [] (MulNoOverflowⁱᵐᵖˡ);
  #[global] MulAssumeNoOverflow_unfold :: FuncUnfold MulAssumeNoOverflow [] (MulAssumeNoOverflowⁱᵐᵖˡ);
  #[global] Shuffle_unfold :: FuncUnfold Shuffle [] (Shuffleⁱᵐᵖˡ);
  #[global] Permutation_unfold :: FuncUnfold Permutation [] (Permutationⁱᵐᵖˡ);
  #[global] import_primitive_Assumption :: primitive.Assumptions;
}.
End std_core.
