(* autogenerated from github.com/goose-lang/std/std_core *)
Require Export New.code.github_com.goose_lang.primitive.

From New.golang Require Import defn.core.
From New.golang.defn Require Export slice.
Definition std_core : go_string := "github.com/goose-lang/std/std_core".

Module std_core.

Section code.
Context `{ffi_syntax}.


Definition SumNoOverflow : go_string := "github.com/goose-lang/std/std_core.SumNoOverflow"%go.

(* Returns true if x + y does not overflow

   go: std_core.go:11:6 *)
Definition SumNoOverflowⁱᵐᵖˡ : val :=
  λ: "x" "y",
    exception_do (let: "y" := (GoAllocValue go.uint64 "y") in
    let: "x" := (GoAllocValue go.uint64 "x") in
    return: (((![go.uint64] "x") + (![go.uint64] "y")) ≥ (![go.uint64] "x"))).

Definition SumAssumeNoOverflow : go_string := "github.com/goose-lang/std/std_core.SumAssumeNoOverflow"%go.

(* SumAssumeNoOverflow returns x + y, `Assume`ing that this does not overflow.

   *Use with care* - if the assumption is violated this function will panic.

   go: std_core.go:18:6 *)
Definition SumAssumeNoOverflowⁱᵐᵖˡ : val :=
  λ: "x" "y",
    exception_do (let: "y" := (GoAllocValue go.uint64 "y") in
    let: "x" := (GoAllocValue go.uint64 "x") in
    do:  (let: "$a0" := (let: "$a0" := (![go.uint64] "x") in
    let: "$a1" := (![go.uint64] "y") in
    (FuncResolve SumNoOverflow #()) "$a0" "$a1") in
    (FuncResolve primitive.Assume #()) "$a0");;;
    return: ((![go.uint64] "x") + (![go.uint64] "y"))).

Definition MulNoOverflow : go_string := "github.com/goose-lang/std/std_core.MulNoOverflow"%go.

(* MulNoOverflow returns true if x * y does not overflow

   go: std_core.go:24:6 *)
Definition MulNoOverflowⁱᵐᵖˡ : val :=
  λ: "x" "y",
    exception_do (let: "y" := (GoAllocValue go.uint64 "y") in
    let: "x" := (GoAllocValue go.uint64 "x") in
    (if: ((![go.uint64] "x") = #(W64 0)) || ((![go.uint64] "y") = #(W64 0))
    then return: (#true)
    else do:  #());;;
    return: ((![go.uint64] "x") ≤ (#(W64 (18446744073709551616 - 1)) `quot` (![go.uint64] "y")))).

Definition MulAssumeNoOverflow : go_string := "github.com/goose-lang/std/std_core.MulAssumeNoOverflow"%go.

(* MulAssumeNoOverflow returns x * y, `Assume`ing that this does not overflow.

   *Use with care* - if the assumption is violated this function will panic.

   go: std_core.go:34:6 *)
Definition MulAssumeNoOverflowⁱᵐᵖˡ : val :=
  λ: "x" "y",
    exception_do (let: "y" := (GoAllocValue go.uint64 "y") in
    let: "x" := (GoAllocValue go.uint64 "x") in
    do:  (let: "$a0" := (let: "$a0" := (![go.uint64] "x") in
    let: "$a1" := (![go.uint64] "y") in
    (FuncResolve MulNoOverflow #()) "$a0" "$a1") in
    (FuncResolve primitive.Assume #()) "$a0");;;
    return: ((![go.uint64] "x") * (![go.uint64] "y"))).

Definition Shuffle : go_string := "github.com/goose-lang/std/std_core.Shuffle"%go.

(* Shuffle shuffles the elements of xs in place, using a Fisher-Yates shuffle.

   go: std_core.go:40:6 *)
Definition Shuffleⁱᵐᵖˡ : val :=
  λ: "xs",
    exception_do (let: "xs" := (GoAllocValue (go.SliceType go.uint64) "xs") in
    (if: (let: "$a0" := (![go.SliceType go.uint64] "xs") in
    slice.len "$a0") = #(W64 0)
    then return: (#())
    else do:  #());;;
    (let: "i" := (GoAlloc go.uint64 #()) in
    let: "$r0" := (s_to_w64 ((let: "$a0" := (![go.SliceType go.uint64] "xs") in
    slice.len "$a0") - #(W64 1))) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, (![go.uint64] "i") > #(W64 0)); (λ: <>, do:  ("i" <-[go.uint64] ((![go.uint64] "i") - #(W64 1)))) := λ: <>,
      let: "j" := (GoAlloc go.uint64 #()) in
      let: "$r0" := (((FuncResolve primitive.RandomUint64 #()) #()) `rem` ((![go.uint64] "i") + #(W64 1))) in
      do:  ("j" <-[go.uint64] "$r0");;;
      let: "temp" := (GoAlloc go.uint64 #()) in
      let: "$r0" := (![go.uint64] (slice.elem_ref go.uint64 (![go.SliceType go.uint64] "xs") (![go.uint64] "i"))) in
      do:  ("temp" <-[go.uint64] "$r0");;;
      let: "$r0" := (![go.uint64] (slice.elem_ref go.uint64 (![go.SliceType go.uint64] "xs") (![go.uint64] "j"))) in
      do:  ((slice.elem_ref go.uint64 (![go.SliceType go.uint64] "xs") (![go.uint64] "i")) <-[go.uint64] "$r0");;;
      let: "$r0" := (![go.uint64] "temp") in
      do:  ((slice.elem_ref go.uint64 (![go.SliceType go.uint64] "xs") (![go.uint64] "j")) <-[go.uint64] "$r0")));;;
    return: #()).

Definition Permutation : go_string := "github.com/goose-lang/std/std_core.Permutation"%go.

(* Permutation returns a random permutation of the integers 0, ..., n-1, using a
   Fisher-Yates shuffle.

   go: std_core.go:54:6 *)
Definition Permutationⁱᵐᵖˡ : val :=
  λ: "n",
    exception_do (let: "n" := (GoAllocValue go.uint64 "n") in
    let: "order" := (GoAlloc (go.SliceType go.uint64) #()) in
    let: "$r0" := (slice.make2 go.uint64 (![go.uint64] "n")) in
    do:  ("order" <-[go.SliceType go.uint64] "$r0");;;
    (let: "i" := (GoAlloc go.uint64 #()) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, (![go.uint64] "i") < (![go.uint64] "n")); (λ: <>, do:  ("i" <-[go.uint64] ((![go.uint64] "i") + #(W64 1)))) := λ: <>,
      let: "$r0" := (![go.uint64] "i") in
      do:  ((slice.elem_ref go.uint64 (![go.SliceType go.uint64] "order") (![go.uint64] "i")) <-[go.uint64] "$r0")));;;
    do:  (let: "$a0" := (![go.SliceType go.uint64] "order") in
    (FuncResolve Shuffle #()) "$a0");;;
    return: (![go.SliceType go.uint64] "order")).

Definition vars' : list (go_string * go.type) := [].

Definition functions' : list (go_string * val) := [(SumNoOverflow, SumNoOverflowⁱᵐᵖˡ); (SumAssumeNoOverflow, SumAssumeNoOverflowⁱᵐᵖˡ); (MulNoOverflow, MulNoOverflowⁱᵐᵖˡ); (MulAssumeNoOverflow, MulAssumeNoOverflowⁱᵐᵖˡ); (Shuffle, Shuffleⁱᵐᵖˡ); (Permutation, Permutationⁱᵐᵖˡ)].

Definition msets' : list (go_string * (list (go_string * val))) := [].

#[global] Instance info' : PkgInfo std_core.std_core :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [code.github_com.goose_lang.primitive.primitive];
  |}.

Definition initialize' : val :=
  λ: <>,
    package.init #std_core.std_core (λ: <>,
      exception_do (do:  (primitive.initialize' #());;;
      do:  (package.alloc std_core.std_core #()))
      ).

End code.
End std_core.
