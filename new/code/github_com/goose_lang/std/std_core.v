(* autogenerated from github.com/goose-lang/std/std_core *)
Require Export New.code.github_com.goose_lang.primitive.

From New.golang Require Import defn.core.
From New.golang.defn Require Export slice.
Definition std_core : go_string := "github.com/goose-lang/std/std_core".

Module std_core.

Section code.
Context `{ffi_syntax}.


Definition SumNoOverflow : go_string := "github.com/goose-lang/std/std_core.SumNoOverflow"%go.

(* Returns true if x + y does not overflow

   go: std_core.go:11:6 *)
Definition SumNoOverflowⁱᵐᵖˡ : val :=
  λ: "x" "y",
    exception_do (let: "y" := (mem.alloc "y") in
    let: "x" := (mem.alloc "x") in
    return: (((![#uint64T] "x") + (![#uint64T] "y")) ≥ (![#uint64T] "x"))).

Definition SumAssumeNoOverflow : go_string := "github.com/goose-lang/std/std_core.SumAssumeNoOverflow"%go.

(* SumAssumeNoOverflow returns x + y, `Assume`ing that this does not overflow.

   *Use with care* - if the assumption is violated this function will panic.

   go: std_core.go:18:6 *)
Definition SumAssumeNoOverflowⁱᵐᵖˡ : val :=
  λ: "x" "y",
    exception_do (let: "y" := (mem.alloc "y") in
    let: "x" := (mem.alloc "x") in
    do:  (let: "$a0" := (let: "$a0" := (![#uint64T] "x") in
    let: "$a1" := (![#uint64T] "y") in
    (func_call #SumNoOverflow) "$a0" "$a1") in
    (func_call #primitive.Assume) "$a0");;;
    return: ((![#uint64T] "x") + (![#uint64T] "y"))).

Definition MulNoOverflow : go_string := "github.com/goose-lang/std/std_core.MulNoOverflow"%go.

(* MulNoOverflow returns true if x * y does not overflow

   go: std_core.go:24:6 *)
Definition MulNoOverflowⁱᵐᵖˡ : val :=
  λ: "x" "y",
    exception_do (let: "y" := (mem.alloc "y") in
    let: "x" := (mem.alloc "x") in
    (if: ((![#uint64T] "x") = #(W64 0)) || ((![#uint64T] "y") = #(W64 0))
    then return: (#true)
    else do:  #());;;
    return: ((![#uint64T] "x") ≤ (#(W64 (18446744073709551616 - 1)) `quot` (![#uint64T] "y")))).

Definition MulAssumeNoOverflow : go_string := "github.com/goose-lang/std/std_core.MulAssumeNoOverflow"%go.

(* MulAssumeNoOverflow returns x * y, `Assume`ing that this does not overflow.

   *Use with care* - if the assumption is violated this function will panic.

   go: std_core.go:34:6 *)
Definition MulAssumeNoOverflowⁱᵐᵖˡ : val :=
  λ: "x" "y",
    exception_do (let: "y" := (mem.alloc "y") in
    let: "x" := (mem.alloc "x") in
    do:  (let: "$a0" := (let: "$a0" := (![#uint64T] "x") in
    let: "$a1" := (![#uint64T] "y") in
    (func_call #MulNoOverflow) "$a0" "$a1") in
    (func_call #primitive.Assume) "$a0");;;
    return: ((![#uint64T] "x") * (![#uint64T] "y"))).

Definition Shuffle : go_string := "github.com/goose-lang/std/std_core.Shuffle"%go.

(* Shuffle shuffles the elements of xs in place, using a Fisher-Yates shuffle.

   go: std_core.go:40:6 *)
Definition Shuffleⁱᵐᵖˡ : val :=
  λ: "xs",
    exception_do (let: "xs" := (mem.alloc "xs") in
    (if: (let: "$a0" := (![#sliceT] "xs") in
    slice.len "$a0") = #(W64 0)
    then return: (#())
    else do:  #());;;
    (let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (s_to_w64 ((let: "$a0" := (![#sliceT] "xs") in
    slice.len "$a0") - #(W64 1))) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (for: (λ: <>, (![#uint64T] "i") > #(W64 0)); (λ: <>, do:  ("i" <-[#uint64T] ((![#uint64T] "i") - #(W64 1)))) := λ: <>,
      let: "j" := (mem.alloc (type.zero_val #uint64T)) in
      let: "$r0" := (((func_call #primitive.RandomUint64) #()) `rem` ((![#uint64T] "i") + #(W64 1))) in
      do:  ("j" <-[#uint64T] "$r0");;;
      let: "temp" := (mem.alloc (type.zero_val #uint64T)) in
      let: "$r0" := (![#uint64T] (slice.elem_ref #uint64T (![#sliceT] "xs") (![#uint64T] "i"))) in
      do:  ("temp" <-[#uint64T] "$r0");;;
      let: "$r0" := (![#uint64T] (slice.elem_ref #uint64T (![#sliceT] "xs") (![#uint64T] "j"))) in
      do:  ((slice.elem_ref #uint64T (![#sliceT] "xs") (![#uint64T] "i")) <-[#uint64T] "$r0");;;
      let: "$r0" := (![#uint64T] "temp") in
      do:  ((slice.elem_ref #uint64T (![#sliceT] "xs") (![#uint64T] "j")) <-[#uint64T] "$r0")));;;
    return: #()).

Definition Permutation : go_string := "github.com/goose-lang/std/std_core.Permutation"%go.

(* Permutation returns a random permutation of the integers 0, ..., n-1, using a
   Fisher-Yates shuffle.

   go: std_core.go:54:6 *)
Definition Permutationⁱᵐᵖˡ : val :=
  λ: "n",
    exception_do (let: "n" := (mem.alloc "n") in
    let: "order" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make2 #uint64T (![#uint64T] "n")) in
    do:  ("order" <-[#sliceT] "$r0");;;
    (let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (for: (λ: <>, (![#uint64T] "i") < (![#uint64T] "n")); (λ: <>, do:  ("i" <-[#uint64T] ((![#uint64T] "i") + #(W64 1)))) := λ: <>,
      let: "$r0" := (![#uint64T] "i") in
      do:  ((slice.elem_ref #uint64T (![#sliceT] "order") (![#uint64T] "i")) <-[#uint64T] "$r0")));;;
    do:  (let: "$a0" := (![#sliceT] "order") in
    (func_call #Shuffle) "$a0");;;
    return: (![#sliceT] "order")).

Definition vars' : list (go_string * go_type) := [].

Definition functions' : list (go_string * val) := [(SumNoOverflow, SumNoOverflowⁱᵐᵖˡ); (SumAssumeNoOverflow, SumAssumeNoOverflowⁱᵐᵖˡ); (MulNoOverflow, MulNoOverflowⁱᵐᵖˡ); (MulAssumeNoOverflow, MulAssumeNoOverflowⁱᵐᵖˡ); (Shuffle, Shuffleⁱᵐᵖˡ); (Permutation, Permutationⁱᵐᵖˡ)].

Definition msets' : list (go_string * (list (go_string * val))) := [].

#[global] Instance info' : PkgInfo std_core.std_core :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [code.github_com.goose_lang.primitive.primitive];
  |}.

Definition initialize' : val :=
  λ: <>,
    package.init #std_core.std_core (λ: <>,
      exception_do (do:  (primitive.initialize' #());;;
      do:  (package.alloc std_core.std_core #()))
      ).

End code.
End std_core.
