(* autogenerated from github.com/sanjit-bhat/pav/safemarshal *)
Require Export New.code.github_com.tchajed.marshal.

From New.golang Require Import defn.
Definition safemarshal : go_string := "github.com/sanjit-bhat/pav/safemarshal".

Module safemarshal.

Section code.
Context `{ffi_syntax}.


Definition ReadBool : go_string := "github.com/sanjit-bhat/pav/safemarshal.ReadBool"%go.

(* go: safemarshal.go:9:6 *)
Definition ReadBoolⁱᵐᵖˡ : val :=
  λ: "b",
    exception_do (let: "err" := (GoAlloc go.bool #()) in
    let: "rem" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "data" := (GoAlloc go.bool #()) in
    let: "b" := (go.AllocValue (go.SliceType go.byte) "b") in
    let: "$r0" := (![go.SliceType go.byte] "b") in
    do:  ("rem" <-[go.SliceType go.byte] "$r0");;;
    (if: (let: "$a0" := (![go.SliceType go.byte] "rem") in
    (FuncResolve go.len [go.SliceType go.byte] #()) "$a0") <⟨go.int⟩ #(W64 1)
    then
      let: "$r0" := #true in
      do:  ("err" <-[go.bool] "$r0");;;
      return: (![go.bool] "data", ![go.SliceType go.byte] "rem", ![go.bool] "err")
    else do:  #());;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] "rem") in
    (FuncResolve marshal.ReadBool [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("data" <-[go.bool] "$r0");;;
    do:  ("rem" <-[go.SliceType go.byte] "$r1");;;
    return: (![go.bool] "data", ![go.SliceType go.byte] "rem", ![go.bool] "err")).

Definition ReadConstBool : go_string := "github.com/sanjit-bhat/pav/safemarshal.ReadConstBool"%go.

(* go: safemarshal.go:19:6 *)
Definition ReadConstBoolⁱᵐᵖˡ : val :=
  λ: "b" "cst",
    exception_do (let: "err" := (GoAlloc go.bool #()) in
    let: "rem" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "cst" := (go.AllocValue go.bool "cst") in
    let: "b" := (go.AllocValue (go.SliceType go.byte) "b") in
    let: "$r0" := (![go.SliceType go.byte] "b") in
    do:  ("rem" <-[go.SliceType go.byte] "$r0");;;
    let: "data" := (GoAlloc go.bool #()) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "rem") in
    (FuncResolve ReadBool [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("data" <-[go.bool] "$r0");;;
    do:  ("rem" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err"
    then return: (![go.SliceType go.byte] "rem", ![go.bool] "err")
    else do:  #());;;
    (if: (![go.bool] "data") ≠⟨go.bool⟩ (![go.bool] "cst")
    then
      let: "$r0" := #true in
      do:  ("err" <-[go.bool] "$r0");;;
      return: (![go.SliceType go.byte] "rem", ![go.bool] "err")
    else do:  #());;;
    return: (![go.SliceType go.byte] "rem", ![go.bool] "err")).

Definition ReadInt : go_string := "github.com/sanjit-bhat/pav/safemarshal.ReadInt"%go.

(* go: safemarshal.go:32:6 *)
Definition ReadIntⁱᵐᵖˡ : val :=
  λ: "b",
    exception_do (let: "err" := (GoAlloc go.bool #()) in
    let: "rem" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "data" := (GoAlloc go.uint64 #()) in
    let: "b" := (go.AllocValue (go.SliceType go.byte) "b") in
    let: "$r0" := (![go.SliceType go.byte] "b") in
    do:  ("rem" <-[go.SliceType go.byte] "$r0");;;
    (if: (let: "$a0" := (![go.SliceType go.byte] "rem") in
    (FuncResolve go.len [go.SliceType go.byte] #()) "$a0") <⟨go.int⟩ #(W64 8)
    then
      let: "$r0" := #true in
      do:  ("err" <-[go.bool] "$r0");;;
      return: (![go.uint64] "data", ![go.SliceType go.byte] "rem", ![go.bool] "err")
    else do:  #());;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] "rem") in
    (FuncResolve marshal.ReadInt [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("data" <-[go.uint64] "$r0");;;
    do:  ("rem" <-[go.SliceType go.byte] "$r1");;;
    return: (![go.uint64] "data", ![go.SliceType go.byte] "rem", ![go.bool] "err")).

Definition ReadConstInt : go_string := "github.com/sanjit-bhat/pav/safemarshal.ReadConstInt"%go.

(* go: safemarshal.go:42:6 *)
Definition ReadConstIntⁱᵐᵖˡ : val :=
  λ: "b" "cst",
    exception_do (let: "err" := (GoAlloc go.bool #()) in
    let: "rem" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "cst" := (go.AllocValue go.uint64 "cst") in
    let: "b" := (go.AllocValue (go.SliceType go.byte) "b") in
    let: "$r0" := (![go.SliceType go.byte] "b") in
    do:  ("rem" <-[go.SliceType go.byte] "$r0");;;
    let: "data" := (GoAlloc go.uint64 #()) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "rem") in
    (FuncResolve ReadInt [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("data" <-[go.uint64] "$r0");;;
    do:  ("rem" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err"
    then return: (![go.SliceType go.byte] "rem", ![go.bool] "err")
    else do:  #());;;
    (if: (![go.uint64] "data") ≠⟨go.uint64⟩ (![go.uint64] "cst")
    then
      let: "$r0" := #true in
      do:  ("err" <-[go.bool] "$r0");;;
      return: (![go.SliceType go.byte] "rem", ![go.bool] "err")
    else do:  #());;;
    return: (![go.SliceType go.byte] "rem", ![go.bool] "err")).

Definition ReadByte : go_string := "github.com/sanjit-bhat/pav/safemarshal.ReadByte"%go.

(* go: safemarshal.go:55:6 *)
Definition ReadByteⁱᵐᵖˡ : val :=
  λ: "b",
    exception_do (let: "err" := (GoAlloc go.bool #()) in
    let: "rem" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "data" := (GoAlloc go.byte #()) in
    let: "b" := (go.AllocValue (go.SliceType go.byte) "b") in
    let: "$r0" := (![go.SliceType go.byte] "b") in
    do:  ("rem" <-[go.SliceType go.byte] "$r0");;;
    (if: (let: "$a0" := (![go.SliceType go.byte] "rem") in
    (FuncResolve go.len [go.SliceType go.byte] #()) "$a0") <⟨go.int⟩ #(W64 1)
    then
      let: "$r0" := #true in
      do:  ("err" <-[go.bool] "$r0");;;
      return: (![go.byte] "data", ![go.SliceType go.byte] "rem", ![go.bool] "err")
    else do:  #());;;
    let: "data0" := (GoAlloc (go.SliceType go.byte) #()) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] "rem") in
    let: "$a1" := #(W64 1) in
    (FuncResolve marshal.ReadBytes [] #()) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("data0" <-[go.SliceType go.byte] "$r0");;;
    do:  ("rem" <-[go.SliceType go.byte] "$r1");;;
    let: "$r0" := (![go.byte] (slice.elem_ref go.byte (![go.SliceType go.byte] "data0") #(W64 0))) in
    do:  ("data" <-[go.byte] "$r0");;;
    return: (![go.byte] "data", ![go.SliceType go.byte] "rem", ![go.bool] "err")).

Definition ReadConstByte : go_string := "github.com/sanjit-bhat/pav/safemarshal.ReadConstByte"%go.

(* go: safemarshal.go:66:6 *)
Definition ReadConstByteⁱᵐᵖˡ : val :=
  λ: "b" "cst",
    exception_do (let: "err" := (GoAlloc go.bool #()) in
    let: "rem" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "cst" := (go.AllocValue go.byte "cst") in
    let: "b" := (go.AllocValue (go.SliceType go.byte) "b") in
    let: "$r0" := (![go.SliceType go.byte] "b") in
    do:  ("rem" <-[go.SliceType go.byte] "$r0");;;
    let: "data" := (GoAlloc go.byte #()) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "rem") in
    (FuncResolve ReadByte [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("data" <-[go.byte] "$r0");;;
    do:  ("rem" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err"
    then return: (![go.SliceType go.byte] "rem", ![go.bool] "err")
    else do:  #());;;
    (if: (![go.byte] "data") ≠⟨go.byte⟩ (![go.byte] "cst")
    then
      let: "$r0" := #true in
      do:  ("err" <-[go.bool] "$r0");;;
      return: (![go.SliceType go.byte] "rem", ![go.bool] "err")
    else do:  #());;;
    return: (![go.SliceType go.byte] "rem", ![go.bool] "err")).

Definition WriteByte : go_string := "github.com/sanjit-bhat/pav/safemarshal.WriteByte"%go.

(* go: safemarshal.go:79:6 *)
Definition WriteByteⁱᵐᵖˡ : val :=
  λ: "b" "data",
    exception_do (let: "data" := (go.AllocValue go.byte "data") in
    let: "b" := (go.AllocValue (go.SliceType go.byte) "b") in
    return: (let: "$a0" := (![go.SliceType go.byte] "b") in
     let: "$a1" := ((let: "$sl0" := (![go.byte] "data") in
     CompositeLiteral go.byte go.byte ["$sl0"])) in
     (FuncResolve marshal.WriteBytes [] #()) "$a0" "$a1")).

Definition ReadBytes : go_string := "github.com/sanjit-bhat/pav/safemarshal.ReadBytes"%go.

(* go: safemarshal.go:83:6 *)
Definition ReadBytesⁱᵐᵖˡ : val :=
  λ: "b" "length",
    exception_do (let: "err" := (GoAlloc go.bool #()) in
    let: "rem" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "data" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "length" := (go.AllocValue go.uint64 "length") in
    let: "b" := (go.AllocValue (go.SliceType go.byte) "b") in
    let: "$r0" := (![go.SliceType go.byte] "b") in
    do:  ("rem" <-[go.SliceType go.byte] "$r0");;;
    (if: (s_to_w64 (let: "$a0" := (![go.SliceType go.byte] "rem") in
    (FuncResolve go.len [go.SliceType go.byte] #()) "$a0")) <⟨go.uint64⟩ (![go.uint64] "length")
    then
      let: "$r0" := #true in
      do:  ("err" <-[go.bool] "$r0");;;
      return: (![go.SliceType go.byte] "data", ![go.SliceType go.byte] "rem", ![go.bool] "err")
    else do:  #());;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] "rem") in
    let: "$a1" := (![go.uint64] "length") in
    (FuncResolve marshal.ReadBytes [] #()) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("data" <-[go.SliceType go.byte] "$r0");;;
    do:  ("rem" <-[go.SliceType go.byte] "$r1");;;
    return: (![go.SliceType go.byte] "data", ![go.SliceType go.byte] "rem", ![go.bool] "err")).

Definition ReadSlice1D : go_string := "github.com/sanjit-bhat/pav/safemarshal.ReadSlice1D"%go.

(* go: safemarshal.go:93:6 *)
Definition ReadSlice1Dⁱᵐᵖˡ : val :=
  λ: "b",
    exception_do (let: "err" := (GoAlloc go.bool #()) in
    let: "rem" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "data" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "b" := (go.AllocValue (go.SliceType go.byte) "b") in
    let: "$r0" := (![go.SliceType go.byte] "b") in
    do:  ("rem" <-[go.SliceType go.byte] "$r0");;;
    let: "length" := (GoAlloc go.uint64 #()) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "rem") in
    (FuncResolve ReadInt [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("length" <-[go.uint64] "$r0");;;
    do:  ("rem" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err"
    then return: (![go.SliceType go.byte] "data", ![go.SliceType go.byte] "rem", ![go.bool] "err")
    else do:  #());;;
    let: (("$ret0", "$ret1"), "$ret2") := ((let: "$a0" := (![go.SliceType go.byte] "rem") in
    let: "$a1" := (![go.uint64] "length") in
    (FuncResolve ReadBytes [] #()) "$a0" "$a1")) in
    return: ("$ret0", "$ret1", "$ret2")).

Definition WriteSlice1D : go_string := "github.com/sanjit-bhat/pav/safemarshal.WriteSlice1D"%go.

(* go: safemarshal.go:102:6 *)
Definition WriteSlice1Dⁱᵐᵖˡ : val :=
  λ: "b" "data",
    exception_do (let: "data" := (go.AllocValue (go.SliceType go.byte) "data") in
    let: "b" := (go.AllocValue (go.SliceType go.byte) "b") in
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (s_to_w64 (let: "$a0" := (![go.SliceType go.byte] "data") in
    (FuncResolve go.len [go.SliceType go.byte] #()) "$a0")) in
    (FuncResolve marshal.WriteInt [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    return: (let: "$a0" := (![go.SliceType go.byte] "b") in
     let: "$a1" := (![go.SliceType go.byte] "data") in
     (FuncResolve marshal.WriteBytes [] #()) "$a0" "$a1")).

Definition ReadSlice2D : go_string := "github.com/sanjit-bhat/pav/safemarshal.ReadSlice2D"%go.

(* go: safemarshal.go:107:6 *)
Definition ReadSlice2Dⁱᵐᵖˡ : val :=
  λ: "b",
    exception_do (let: "err" := (GoAlloc go.bool #()) in
    let: "rem" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "data" := (GoAlloc (go.SliceType (go.SliceType go.byte)) #()) in
    let: "b" := (go.AllocValue (go.SliceType go.byte) "b") in
    let: "$r0" := (![go.SliceType go.byte] "b") in
    do:  ("rem" <-[go.SliceType go.byte] "$r0");;;
    let: "length" := (GoAlloc go.uint64 #()) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "rem") in
    (FuncResolve ReadInt [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("length" <-[go.uint64] "$r0");;;
    do:  ("rem" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err"
    then return: (![go.SliceType (go.SliceType go.byte)] "data", ![go.SliceType go.byte] "rem", ![go.bool] "err")
    else do:  #());;;
    (let: "i" := (GoAlloc go.uint64 #()) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, (![go.uint64] "i") <⟨go.uint64⟩ (![go.uint64] "length")); (λ: <>, do:  ("i" <-[go.uint64] ((![go.uint64] "i") +⟨go.uint64⟩ #(W8 1)))) := λ: <>,
      let: "data0" := (GoAlloc (go.SliceType go.byte) #()) in
      let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "rem") in
      (FuncResolve ReadSlice1D [] #()) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      let: "$r2" := "$ret2" in
      do:  ("data0" <-[go.SliceType go.byte] "$r0");;;
      do:  ("rem" <-[go.SliceType go.byte] "$r1");;;
      do:  ("err" <-[go.bool] "$r2");;;
      (if: ![go.bool] "err"
      then return: (![go.SliceType (go.SliceType go.byte)] "data", ![go.SliceType go.byte] "rem", ![go.bool] "err")
      else do:  #());;;
      let: "$r0" := (let: "$a0" := (![go.SliceType (go.SliceType go.byte)] "data") in
      let: "$a1" := ((let: "$sl0" := (![go.SliceType go.byte] "data0") in
      CompositeLiteral (go.SliceType go.byte) (go.SliceType go.byte) ["$sl0"])) in
      (FuncResolve go.append [go.SliceType (go.SliceType go.byte)] #()) "$a0" "$a1") in
      do:  ("data" <-[go.SliceType (go.SliceType go.byte)] "$r0")));;;
    return: (![go.SliceType (go.SliceType go.byte)] "data", ![go.SliceType go.byte] "rem", ![go.bool] "err")).

Definition WriteSlice2D : go_string := "github.com/sanjit-bhat/pav/safemarshal.WriteSlice2D"%go.

(* go: safemarshal.go:124:6 *)
Definition WriteSlice2Dⁱᵐᵖˡ : val :=
  λ: "b" "data",
    exception_do (let: "data" := (go.AllocValue (go.SliceType (go.SliceType go.byte)) "data") in
    let: "b" := (go.AllocValue (go.SliceType go.byte) "b") in
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (s_to_w64 (let: "$a0" := (![go.SliceType (go.SliceType go.byte)] "data") in
    (FuncResolve go.len [go.SliceType (go.SliceType go.byte)] #()) "$a0")) in
    (FuncResolve marshal.WriteInt [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$range" := (![go.SliceType (go.SliceType go.byte)] "data") in
    (let: "data1" := (GoAlloc (go.SliceType go.byte) #()) in
    slice.for_range (go.SliceType go.byte) "$range" (λ: "$key" "$value",
      do:  ("data1" <-[go.SliceType go.byte] "$value");;;
      do:  "$key";;;
      let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
      let: "$a1" := (![go.SliceType go.byte] "data1") in
      (FuncResolve WriteSlice1D [] #()) "$a0" "$a1") in
      do:  ("b" <-[go.SliceType go.byte] "$r0")));;;
    return: (![go.SliceType go.byte] "b")).

Definition ReadSlice3D : go_string := "github.com/sanjit-bhat/pav/safemarshal.ReadSlice3D"%go.

(* go: safemarshal.go:132:6 *)
Definition ReadSlice3Dⁱᵐᵖˡ : val :=
  λ: "b",
    exception_do (let: "err" := (GoAlloc go.bool #()) in
    let: "rem" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "data" := (GoAlloc (go.SliceType (go.SliceType (go.SliceType go.byte))) #()) in
    let: "b" := (go.AllocValue (go.SliceType go.byte) "b") in
    let: "$r0" := (![go.SliceType go.byte] "b") in
    do:  ("rem" <-[go.SliceType go.byte] "$r0");;;
    let: "length" := (GoAlloc go.uint64 #()) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "rem") in
    (FuncResolve ReadInt [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("length" <-[go.uint64] "$r0");;;
    do:  ("rem" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err"
    then return: (![go.SliceType (go.SliceType (go.SliceType go.byte))] "data", ![go.SliceType go.byte] "rem", ![go.bool] "err")
    else do:  #());;;
    (let: "i" := (GoAlloc go.uint64 #()) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, (![go.uint64] "i") <⟨go.uint64⟩ (![go.uint64] "length")); (λ: <>, do:  ("i" <-[go.uint64] ((![go.uint64] "i") +⟨go.uint64⟩ #(W8 1)))) := λ: <>,
      let: "data0" := (GoAlloc (go.SliceType (go.SliceType go.byte)) #()) in
      let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "rem") in
      (FuncResolve ReadSlice2D [] #()) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      let: "$r2" := "$ret2" in
      do:  ("data0" <-[go.SliceType (go.SliceType go.byte)] "$r0");;;
      do:  ("rem" <-[go.SliceType go.byte] "$r1");;;
      do:  ("err" <-[go.bool] "$r2");;;
      (if: ![go.bool] "err"
      then return: (![go.SliceType (go.SliceType (go.SliceType go.byte))] "data", ![go.SliceType go.byte] "rem", ![go.bool] "err")
      else do:  #());;;
      let: "$r0" := (let: "$a0" := (![go.SliceType (go.SliceType (go.SliceType go.byte))] "data") in
      let: "$a1" := ((let: "$sl0" := (![go.SliceType (go.SliceType go.byte)] "data0") in
      CompositeLiteral (go.SliceType (go.SliceType go.byte)) (go.SliceType (go.SliceType go.byte)) ["$sl0"])) in
      (FuncResolve go.append [go.SliceType (go.SliceType (go.SliceType go.byte))] #()) "$a0" "$a1") in
      do:  ("data" <-[go.SliceType (go.SliceType (go.SliceType go.byte))] "$r0")));;;
    return: (![go.SliceType (go.SliceType (go.SliceType go.byte))] "data", ![go.SliceType go.byte] "rem", ![go.bool] "err")).

Definition WriteSlice3D : go_string := "github.com/sanjit-bhat/pav/safemarshal.WriteSlice3D"%go.

(* go: safemarshal.go:149:6 *)
Definition WriteSlice3Dⁱᵐᵖˡ : val :=
  λ: "b" "data",
    exception_do (let: "data" := (go.AllocValue (go.SliceType (go.SliceType (go.SliceType go.byte))) "data") in
    let: "b" := (go.AllocValue (go.SliceType go.byte) "b") in
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (s_to_w64 (let: "$a0" := (![go.SliceType (go.SliceType (go.SliceType go.byte))] "data") in
    (FuncResolve go.len [go.SliceType (go.SliceType (go.SliceType go.byte))] #()) "$a0")) in
    (FuncResolve marshal.WriteInt [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$range" := (![go.SliceType (go.SliceType (go.SliceType go.byte))] "data") in
    (let: "data1" := (GoAlloc (go.SliceType (go.SliceType go.byte)) #()) in
    slice.for_range (go.SliceType (go.SliceType go.byte)) "$range" (λ: "$key" "$value",
      do:  ("data1" <-[go.SliceType (go.SliceType go.byte)] "$value");;;
      do:  "$key";;;
      let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
      let: "$a1" := (![go.SliceType (go.SliceType go.byte)] "data1") in
      (FuncResolve WriteSlice2D [] #()) "$a0" "$a1") in
      do:  ("b" <-[go.SliceType go.byte] "$r0")));;;
    return: (![go.SliceType go.byte] "b")).

Definition functions' : list (go_string * val) := [(ReadBool, ReadBoolⁱᵐᵖˡ); (ReadConstBool, ReadConstBoolⁱᵐᵖˡ); (ReadInt, ReadIntⁱᵐᵖˡ); (ReadConstInt, ReadConstIntⁱᵐᵖˡ); (ReadByte, ReadByteⁱᵐᵖˡ); (ReadConstByte, ReadConstByteⁱᵐᵖˡ); (WriteByte, WriteByteⁱᵐᵖˡ); (ReadBytes, ReadBytesⁱᵐᵖˡ); (ReadSlice1D, ReadSlice1Dⁱᵐᵖˡ); (WriteSlice1D, WriteSlice1Dⁱᵐᵖˡ); (ReadSlice2D, ReadSlice2Dⁱᵐᵖˡ); (WriteSlice2D, WriteSlice2Dⁱᵐᵖˡ); (ReadSlice3D, ReadSlice3Dⁱᵐᵖˡ); (WriteSlice3D, WriteSlice3Dⁱᵐᵖˡ)].

#[global] Instance info' : PkgInfo safemarshal.safemarshal :=
  {|
    pkg_imported_pkgs := [code.github_com.tchajed.marshal.marshal];
  |}.

Definition initialize' : val :=
  λ: <>,
    package.init safemarshal.safemarshal (λ: <>,
      exception_do (do:  (marshal.initialize' #()))
      ).

End code.
End safemarshal.
