(* autogenerated from github.com/sanjit-bhat/pav/safemarshal *)
Require Export New.code.github_com.tchajed.marshal.
From New.golang Require Import defn.
Module pkg_id.
Definition safemarshal : go_string := "github.com/sanjit-bhat/pav/safemarshal".

End pkg_id.
Export pkg_id.
Module safemarshal.

Definition ReadBool {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/sanjit-bhat/pav/safemarshal.ReadBool"%go.

Definition ReadConstBool {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/sanjit-bhat/pav/safemarshal.ReadConstBool"%go.

Definition ReadInt {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/sanjit-bhat/pav/safemarshal.ReadInt"%go.

Definition ReadConstInt {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/sanjit-bhat/pav/safemarshal.ReadConstInt"%go.

Definition ReadByte {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/sanjit-bhat/pav/safemarshal.ReadByte"%go.

Definition ReadConstByte {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/sanjit-bhat/pav/safemarshal.ReadConstByte"%go.

Definition WriteByte {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/sanjit-bhat/pav/safemarshal.WriteByte"%go.

Definition ReadBytes {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/sanjit-bhat/pav/safemarshal.ReadBytes"%go.

Definition ReadSlice1D {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/sanjit-bhat/pav/safemarshal.ReadSlice1D"%go.

Definition WriteSlice1D {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/sanjit-bhat/pav/safemarshal.WriteSlice1D"%go.

Definition ReadSlice2D {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/sanjit-bhat/pav/safemarshal.ReadSlice2D"%go.

Definition WriteSlice2D {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/sanjit-bhat/pav/safemarshal.WriteSlice2D"%go.

Definition ReadSlice3D {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/sanjit-bhat/pav/safemarshal.ReadSlice3D"%go.

Definition WriteSlice3D {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/sanjit-bhat/pav/safemarshal.WriteSlice3D"%go.

(* go: safemarshal.go:9:6 *)
Definition ReadBoolⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "b",
    exception_do (let: "err" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "rem" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "data" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "b" := (GoAlloc (go.SliceType go.byte) "b") in
    let: "$r0" := (![go.SliceType go.byte] "b") in
    do:  ("rem" <-[go.SliceType go.byte] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((let: "$a0" := (![go.SliceType go.byte] "rem") in
    (FuncResolve go.len [go.SliceType go.byte] #()) "$a0") <⟨go.int⟩ #(W64 1))
    then
      let: "$r0" := #true in
      do:  ("err" <-[go.bool] "$r0");;;
      return: (![go.bool] "data", ![go.SliceType go.byte] "rem", ![go.bool] "err")
    else do:  #());;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] "rem") in
    (FuncResolve marshal.ReadBool [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("data" <-[go.bool] "$r0");;;
    do:  ("rem" <-[go.SliceType go.byte] "$r1");;;
    return: (![go.bool] "data", ![go.SliceType go.byte] "rem", ![go.bool] "err")).

(* go: safemarshal.go:19:6 *)
Definition ReadConstBoolⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "b" "cst",
    exception_do (let: "err" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "rem" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "cst" := (GoAlloc go.bool "cst") in
    let: "b" := (GoAlloc (go.SliceType go.byte) "b") in
    let: "$r0" := (![go.SliceType go.byte] "b") in
    do:  ("rem" <-[go.SliceType go.byte] "$r0");;;
    let: "data" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "rem") in
    (FuncResolve ReadBool [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("data" <-[go.bool] "$r0");;;
    do:  ("rem" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err"
    then return: (![go.SliceType go.byte] "rem", ![go.bool] "err")
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool ((![go.bool] "data") ≠⟨go.bool⟩ (![go.bool] "cst"))
    then
      let: "$r0" := #true in
      do:  ("err" <-[go.bool] "$r0");;;
      return: (![go.SliceType go.byte] "rem", ![go.bool] "err")
    else do:  #());;;
    return: (![go.SliceType go.byte] "rem", ![go.bool] "err")).

(* go: safemarshal.go:32:6 *)
Definition ReadIntⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "b",
    exception_do (let: "err" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "rem" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "data" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "b" := (GoAlloc (go.SliceType go.byte) "b") in
    let: "$r0" := (![go.SliceType go.byte] "b") in
    do:  ("rem" <-[go.SliceType go.byte] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((let: "$a0" := (![go.SliceType go.byte] "rem") in
    (FuncResolve go.len [go.SliceType go.byte] #()) "$a0") <⟨go.int⟩ #(W64 8))
    then
      let: "$r0" := #true in
      do:  ("err" <-[go.bool] "$r0");;;
      return: (![go.uint64] "data", ![go.SliceType go.byte] "rem", ![go.bool] "err")
    else do:  #());;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] "rem") in
    (FuncResolve marshal.ReadInt [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("data" <-[go.uint64] "$r0");;;
    do:  ("rem" <-[go.SliceType go.byte] "$r1");;;
    return: (![go.uint64] "data", ![go.SliceType go.byte] "rem", ![go.bool] "err")).

(* go: safemarshal.go:42:6 *)
Definition ReadConstIntⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "b" "cst",
    exception_do (let: "err" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "rem" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "cst" := (GoAlloc go.uint64 "cst") in
    let: "b" := (GoAlloc (go.SliceType go.byte) "b") in
    let: "$r0" := (![go.SliceType go.byte] "b") in
    do:  ("rem" <-[go.SliceType go.byte] "$r0");;;
    let: "data" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "rem") in
    (FuncResolve ReadInt [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("data" <-[go.uint64] "$r0");;;
    do:  ("rem" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err"
    then return: (![go.SliceType go.byte] "rem", ![go.bool] "err")
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "data") ≠⟨go.uint64⟩ (![go.uint64] "cst"))
    then
      let: "$r0" := #true in
      do:  ("err" <-[go.bool] "$r0");;;
      return: (![go.SliceType go.byte] "rem", ![go.bool] "err")
    else do:  #());;;
    return: (![go.SliceType go.byte] "rem", ![go.bool] "err")).

(* go: safemarshal.go:55:6 *)
Definition ReadByteⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "b",
    exception_do (let: "err" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "rem" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "data" := (GoAlloc go.byte (GoZeroVal go.byte #())) in
    let: "b" := (GoAlloc (go.SliceType go.byte) "b") in
    let: "$r0" := (![go.SliceType go.byte] "b") in
    do:  ("rem" <-[go.SliceType go.byte] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((let: "$a0" := (![go.SliceType go.byte] "rem") in
    (FuncResolve go.len [go.SliceType go.byte] #()) "$a0") <⟨go.int⟩ #(W64 1))
    then
      let: "$r0" := #true in
      do:  ("err" <-[go.bool] "$r0");;;
      return: (![go.byte] "data", ![go.SliceType go.byte] "rem", ![go.bool] "err")
    else do:  #());;;
    let: "data0" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] "rem") in
    let: "$a1" := #(W64 1) in
    (FuncResolve marshal.ReadBytes [] #()) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("data0" <-[go.SliceType go.byte] "$r0");;;
    do:  ("rem" <-[go.SliceType go.byte] "$r1");;;
    let: "$r0" := (![go.byte] (IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "data0", #(W64 0)))) in
    do:  ("data" <-[go.byte] "$r0");;;
    return: (![go.byte] "data", ![go.SliceType go.byte] "rem", ![go.bool] "err")).

(* go: safemarshal.go:66:6 *)
Definition ReadConstByteⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "b" "cst",
    exception_do (let: "err" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "rem" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "cst" := (GoAlloc go.byte "cst") in
    let: "b" := (GoAlloc (go.SliceType go.byte) "b") in
    let: "$r0" := (![go.SliceType go.byte] "b") in
    do:  ("rem" <-[go.SliceType go.byte] "$r0");;;
    let: "data" := (GoAlloc go.byte (GoZeroVal go.byte #())) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "rem") in
    (FuncResolve ReadByte [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("data" <-[go.byte] "$r0");;;
    do:  ("rem" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err"
    then return: (![go.SliceType go.byte] "rem", ![go.bool] "err")
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool ((![go.byte] "data") ≠⟨go.byte⟩ (![go.byte] "cst"))
    then
      let: "$r0" := #true in
      do:  ("err" <-[go.bool] "$r0");;;
      return: (![go.SliceType go.byte] "rem", ![go.bool] "err")
    else do:  #());;;
    return: (![go.SliceType go.byte] "rem", ![go.bool] "err")).

(* go: safemarshal.go:79:6 *)
Definition WriteByteⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "b" "data",
    exception_do (let: "data" := (GoAlloc go.byte "data") in
    let: "b" := (GoAlloc (go.SliceType go.byte) "b") in
    return: (let: "$a0" := (![go.SliceType go.byte] "b") in
     let: "$a1" := (CompositeLiteral (go.SliceType go.byte) (LiteralValue [KeyedElement None (ElementExpression go.byte (![go.byte] "data"))])) in
     (FuncResolve marshal.WriteBytes [] #()) "$a0" "$a1")).

(* go: safemarshal.go:83:6 *)
Definition ReadBytesⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "b" "length",
    exception_do (let: "err" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "rem" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "data" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "length" := (GoAlloc go.uint64 "length") in
    let: "b" := (GoAlloc (go.SliceType go.byte) "b") in
    let: "$r0" := (![go.SliceType go.byte] "b") in
    do:  ("rem" <-[go.SliceType go.byte] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((Convert go.int go.uint64 (let: "$a0" := (![go.SliceType go.byte] "rem") in
    (FuncResolve go.len [go.SliceType go.byte] #()) "$a0")) <⟨go.uint64⟩ (![go.uint64] "length"))
    then
      let: "$r0" := #true in
      do:  ("err" <-[go.bool] "$r0");;;
      return: (![go.SliceType go.byte] "data", ![go.SliceType go.byte] "rem", ![go.bool] "err")
    else do:  #());;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] "rem") in
    let: "$a1" := (![go.uint64] "length") in
    (FuncResolve marshal.ReadBytes [] #()) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("data" <-[go.SliceType go.byte] "$r0");;;
    do:  ("rem" <-[go.SliceType go.byte] "$r1");;;
    return: (![go.SliceType go.byte] "data", ![go.SliceType go.byte] "rem", ![go.bool] "err")).

(* go: safemarshal.go:93:6 *)
Definition ReadSlice1Dⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "b",
    exception_do (let: "err" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "rem" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "data" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "b" := (GoAlloc (go.SliceType go.byte) "b") in
    let: "$r0" := (![go.SliceType go.byte] "b") in
    do:  ("rem" <-[go.SliceType go.byte] "$r0");;;
    let: "length" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "rem") in
    (FuncResolve ReadInt [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("length" <-[go.uint64] "$r0");;;
    do:  ("rem" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err"
    then return: (![go.SliceType go.byte] "data", ![go.SliceType go.byte] "rem", ![go.bool] "err")
    else do:  #());;;
    let: (("$ret0", "$ret1"), "$ret2") := ((let: "$a0" := (![go.SliceType go.byte] "rem") in
    let: "$a1" := (![go.uint64] "length") in
    (FuncResolve ReadBytes [] #()) "$a0" "$a1")) in
    return: ("$ret0", "$ret1", "$ret2")).

(* go: safemarshal.go:102:6 *)
Definition WriteSlice1Dⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "b" "data",
    exception_do (let: "data" := (GoAlloc (go.SliceType go.byte) "data") in
    let: "b" := (GoAlloc (go.SliceType go.byte) "b") in
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (Convert go.int go.uint64 (let: "$a0" := (![go.SliceType go.byte] "data") in
    (FuncResolve go.len [go.SliceType go.byte] #()) "$a0")) in
    (FuncResolve marshal.WriteInt [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    return: (let: "$a0" := (![go.SliceType go.byte] "b") in
     let: "$a1" := (![go.SliceType go.byte] "data") in
     (FuncResolve marshal.WriteBytes [] #()) "$a0" "$a1")).

(* go: safemarshal.go:107:6 *)
Definition ReadSlice2Dⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "b",
    exception_do (let: "err" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "rem" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "data" := (GoAlloc (go.SliceType (go.SliceType go.byte)) (GoZeroVal (go.SliceType (go.SliceType go.byte)) #())) in
    let: "b" := (GoAlloc (go.SliceType go.byte) "b") in
    let: "$r0" := (![go.SliceType go.byte] "b") in
    do:  ("rem" <-[go.SliceType go.byte] "$r0");;;
    let: "length" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "rem") in
    (FuncResolve ReadInt [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("length" <-[go.uint64] "$r0");;;
    do:  ("rem" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err"
    then return: (![go.SliceType (go.SliceType go.byte)] "data", ![go.SliceType go.byte] "rem", ![go.bool] "err")
    else do:  #());;;
    (let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, (![go.uint64] "i") <⟨go.uint64⟩ (![go.uint64] "length")); (λ: <>, do:  ("i" <-[go.uint64] ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 1)))) := λ: <>,
      let: "data0" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
      let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "rem") in
      (FuncResolve ReadSlice1D [] #()) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      let: "$r2" := "$ret2" in
      do:  ("data0" <-[go.SliceType go.byte] "$r0");;;
      do:  ("rem" <-[go.SliceType go.byte] "$r1");;;
      do:  ("err" <-[go.bool] "$r2");;;
      (if: ![go.bool] "err"
      then return: (![go.SliceType (go.SliceType go.byte)] "data", ![go.SliceType go.byte] "rem", ![go.bool] "err")
      else do:  #());;;
      let: "$r0" := (let: "$a0" := (![go.SliceType (go.SliceType go.byte)] "data") in
      let: "$a1" := ((let: "$sl0" := (![go.SliceType go.byte] "data0") in
      CompositeLiteral (go.SliceType (go.SliceType go.byte)) (LiteralValue [KeyedElement None (ElementExpression (go.SliceType go.byte) "$sl0")]))) in
      (FuncResolve go.append [go.SliceType (go.SliceType go.byte)] #()) "$a0" "$a1") in
      do:  ("data" <-[go.SliceType (go.SliceType go.byte)] "$r0")));;;
    return: (![go.SliceType (go.SliceType go.byte)] "data", ![go.SliceType go.byte] "rem", ![go.bool] "err")).

(* go: safemarshal.go:124:6 *)
Definition WriteSlice2Dⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "b" "data",
    exception_do (let: "data" := (GoAlloc (go.SliceType (go.SliceType go.byte)) "data") in
    let: "b" := (GoAlloc (go.SliceType go.byte) "b") in
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (Convert go.int go.uint64 (let: "$a0" := (![go.SliceType (go.SliceType go.byte)] "data") in
    (FuncResolve go.len [go.SliceType (go.SliceType go.byte)] #()) "$a0")) in
    (FuncResolve marshal.WriteInt [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$range" := (![go.SliceType (go.SliceType go.byte)] "data") in
    (let: "data1" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    slice.for_range (go.SliceType go.byte) "$range" (λ: "$key" "$value",
      do:  ("data1" <-[go.SliceType go.byte] "$value");;;
      do:  "$key";;;
      let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
      let: "$a1" := (![go.SliceType go.byte] "data1") in
      (FuncResolve WriteSlice1D [] #()) "$a0" "$a1") in
      do:  ("b" <-[go.SliceType go.byte] "$r0")));;;
    return: (![go.SliceType go.byte] "b")).

(* go: safemarshal.go:132:6 *)
Definition ReadSlice3Dⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "b",
    exception_do (let: "err" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "rem" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "data" := (GoAlloc (go.SliceType (go.SliceType (go.SliceType go.byte))) (GoZeroVal (go.SliceType (go.SliceType (go.SliceType go.byte))) #())) in
    let: "b" := (GoAlloc (go.SliceType go.byte) "b") in
    let: "$r0" := (![go.SliceType go.byte] "b") in
    do:  ("rem" <-[go.SliceType go.byte] "$r0");;;
    let: "length" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "rem") in
    (FuncResolve ReadInt [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("length" <-[go.uint64] "$r0");;;
    do:  ("rem" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err"
    then return: (![go.SliceType (go.SliceType (go.SliceType go.byte))] "data", ![go.SliceType go.byte] "rem", ![go.bool] "err")
    else do:  #());;;
    (let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, (![go.uint64] "i") <⟨go.uint64⟩ (![go.uint64] "length")); (λ: <>, do:  ("i" <-[go.uint64] ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 1)))) := λ: <>,
      let: "data0" := (GoAlloc (go.SliceType (go.SliceType go.byte)) (GoZeroVal (go.SliceType (go.SliceType go.byte)) #())) in
      let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "rem") in
      (FuncResolve ReadSlice2D [] #()) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      let: "$r2" := "$ret2" in
      do:  ("data0" <-[go.SliceType (go.SliceType go.byte)] "$r0");;;
      do:  ("rem" <-[go.SliceType go.byte] "$r1");;;
      do:  ("err" <-[go.bool] "$r2");;;
      (if: ![go.bool] "err"
      then return: (![go.SliceType (go.SliceType (go.SliceType go.byte))] "data", ![go.SliceType go.byte] "rem", ![go.bool] "err")
      else do:  #());;;
      let: "$r0" := (let: "$a0" := (![go.SliceType (go.SliceType (go.SliceType go.byte))] "data") in
      let: "$a1" := ((let: "$sl0" := (![go.SliceType (go.SliceType go.byte)] "data0") in
      CompositeLiteral (go.SliceType (go.SliceType (go.SliceType go.byte))) (LiteralValue [KeyedElement None (ElementExpression (go.SliceType (go.SliceType go.byte)) "$sl0")]))) in
      (FuncResolve go.append [go.SliceType (go.SliceType (go.SliceType go.byte))] #()) "$a0" "$a1") in
      do:  ("data" <-[go.SliceType (go.SliceType (go.SliceType go.byte))] "$r0")));;;
    return: (![go.SliceType (go.SliceType (go.SliceType go.byte))] "data", ![go.SliceType go.byte] "rem", ![go.bool] "err")).

(* go: safemarshal.go:149:6 *)
Definition WriteSlice3Dⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "b" "data",
    exception_do (let: "data" := (GoAlloc (go.SliceType (go.SliceType (go.SliceType go.byte))) "data") in
    let: "b" := (GoAlloc (go.SliceType go.byte) "b") in
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (Convert go.int go.uint64 (let: "$a0" := (![go.SliceType (go.SliceType (go.SliceType go.byte))] "data") in
    (FuncResolve go.len [go.SliceType (go.SliceType (go.SliceType go.byte))] #()) "$a0")) in
    (FuncResolve marshal.WriteInt [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$range" := (![go.SliceType (go.SliceType (go.SliceType go.byte))] "data") in
    (let: "data1" := (GoAlloc (go.SliceType (go.SliceType go.byte)) (GoZeroVal (go.SliceType (go.SliceType go.byte)) #())) in
    slice.for_range (go.SliceType (go.SliceType go.byte)) "$range" (λ: "$key" "$value",
      do:  ("data1" <-[go.SliceType (go.SliceType go.byte)] "$value");;;
      do:  "$key";;;
      let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
      let: "$a1" := (![go.SliceType (go.SliceType go.byte)] "data1") in
      (FuncResolve WriteSlice2D [] #()) "$a0" "$a1") in
      do:  ("b" <-[go.SliceType go.byte] "$r0")));;;
    return: (![go.SliceType go.byte] "b")).

#[global] Instance info' : PkgInfo pkg_id.safemarshal :=
{|
  pkg_imported_pkgs := [code.github_com.tchajed.marshal.pkg_id.marshal]
|}.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init pkg_id.safemarshal (λ: <>,
      exception_do (do:  (marshal.initialize' #()))
      ).

Class Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] ReadBool_unfold :: FuncUnfold ReadBool [] (ReadBoolⁱᵐᵖˡ);
  #[global] ReadConstBool_unfold :: FuncUnfold ReadConstBool [] (ReadConstBoolⁱᵐᵖˡ);
  #[global] ReadInt_unfold :: FuncUnfold ReadInt [] (ReadIntⁱᵐᵖˡ);
  #[global] ReadConstInt_unfold :: FuncUnfold ReadConstInt [] (ReadConstIntⁱᵐᵖˡ);
  #[global] ReadByte_unfold :: FuncUnfold ReadByte [] (ReadByteⁱᵐᵖˡ);
  #[global] ReadConstByte_unfold :: FuncUnfold ReadConstByte [] (ReadConstByteⁱᵐᵖˡ);
  #[global] WriteByte_unfold :: FuncUnfold WriteByte [] (WriteByteⁱᵐᵖˡ);
  #[global] ReadBytes_unfold :: FuncUnfold ReadBytes [] (ReadBytesⁱᵐᵖˡ);
  #[global] ReadSlice1D_unfold :: FuncUnfold ReadSlice1D [] (ReadSlice1Dⁱᵐᵖˡ);
  #[global] WriteSlice1D_unfold :: FuncUnfold WriteSlice1D [] (WriteSlice1Dⁱᵐᵖˡ);
  #[global] ReadSlice2D_unfold :: FuncUnfold ReadSlice2D [] (ReadSlice2Dⁱᵐᵖˡ);
  #[global] WriteSlice2D_unfold :: FuncUnfold WriteSlice2D [] (WriteSlice2Dⁱᵐᵖˡ);
  #[global] ReadSlice3D_unfold :: FuncUnfold ReadSlice3D [] (ReadSlice3Dⁱᵐᵖˡ);
  #[global] WriteSlice3D_unfold :: FuncUnfold WriteSlice3D [] (WriteSlice3Dⁱᵐᵖˡ);
  #[global] import_marshal_Assumption :: marshal.Assumptions;
}.
End safemarshal.
