(* autogenerated from github.com/sanjit-bhat/pav/alicebob *)
Require Export New.code.bytes.
Require Export New.code.sync.
Require Export New.code.time.
Require Export New.code.github_com.goose_lang.primitive.
Require Export New.code.github_com.goose_lang.std.
Require Export New.code.github_com.sanjit_bhat.pav.auditor.
Require Export New.code.github_com.sanjit_bhat.pav.client.
Require Export New.code.github_com.sanjit_bhat.pav.cryptoffi.
Require Export New.code.github_com.sanjit_bhat.pav.ktcore.
Require Export New.code.github_com.sanjit_bhat.pav.server.
From New.golang Require Import defn.
Module pkg_id.
Definition alicebob : go_string := "github.com/sanjit-bhat/pav/alicebob".

End pkg_id.
Export pkg_id.
Module alicebob.

Definition histEntry {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/sanjit-bhat/pav/alicebob.histEntry"%go [].

Definition aliceUid {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 0).

Definition bobUid {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 1).

Definition testAliceBob {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/sanjit-bhat/pav/alicebob.testAliceBob"%go.

Definition equal {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/sanjit-bhat/pav/alicebob.equal"%go.

Definition runAlice {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/sanjit-bhat/pav/alicebob.runAlice"%go.

Definition loopPending {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/sanjit-bhat/pav/alicebob.loopPending"%go.

Definition runBob {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/sanjit-bhat/pav/alicebob.runBob"%go.

(* go: alicebob.go:26:6 *)
Definition testAliceBobⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "servAddr" "adtrAddr",
    exception_do (let: "evid" := (GoAlloc (go.PointerType ktcore.Evid) (GoZeroVal (go.PointerType ktcore.Evid) #())) in
    let: "err" := (GoAlloc ktcore.Blame (GoZeroVal ktcore.Blame #())) in
    let: "adtrAddr" := (GoAlloc go.uint64 "adtrAddr") in
    let: "servAddr" := (GoAlloc go.uint64 "servAddr") in
    let: "servSigPk" := (GoAlloc cryptoffi.SigPublicKey (GoZeroVal cryptoffi.SigPublicKey #())) in
    let: "serv" := (GoAlloc (go.PointerType server.Server) (GoZeroVal (go.PointerType server.Server) #())) in
    let: ("$ret0", "$ret1") := ((FuncResolve server.New [] #()) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("serv" <-[go.PointerType server.Server] "$r0");;;
    do:  ("servSigPk" <-[cryptoffi.SigPublicKey] "$r1");;;
    let: "servRpc" := (GoAlloc (go.PointerType advrpc.Server) (GoZeroVal (go.PointerType advrpc.Server) #())) in
    let: "$r0" := (let: "$a0" := (![go.PointerType server.Server] "serv") in
    (FuncResolve server.NewRpcServer [] #()) "$a0") in
    do:  ("servRpc" <-[go.PointerType advrpc.Server] "$r0");;;
    do:  (let: "$a0" := (![go.uint64] "servAddr") in
    (MethodResolve (go.PointerType advrpc.Server) "Serve"%go (![go.PointerType advrpc.Server] "servRpc")) "$a0");;;
    do:  (let: "$a0" := time.Millisecond in
    (FuncResolve time.Sleep [] #()) "$a0");;;
    let: "adtrPk" := (GoAlloc cryptoffi.SigPublicKey (GoZeroVal cryptoffi.SigPublicKey #())) in
    let: "adtr" := (GoAlloc (go.PointerType auditor.Auditor) (GoZeroVal (go.PointerType auditor.Auditor) #())) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.uint64] "servAddr") in
    let: "$a1" := (![cryptoffi.SigPublicKey] "servSigPk") in
    (FuncResolve auditor.New [] #()) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("adtr" <-[go.PointerType auditor.Auditor] "$r0");;;
    do:  ("adtrPk" <-[cryptoffi.SigPublicKey] "$r1");;;
    do:  ("err" <-[ktcore.Blame] "$r2");;;
    (if: Convert go.untyped_bool go.bool ((![ktcore.Blame] "err") ≠⟨go.uint64⟩ ktcore.BlameNone)
    then return: (![ktcore.Blame] "err", ![go.PointerType ktcore.Evid] "evid")
    else do:  #());;;
    let: "adtrRpc" := (GoAlloc (go.PointerType advrpc.Server) (GoZeroVal (go.PointerType advrpc.Server) #())) in
    let: "$r0" := (let: "$a0" := (![go.PointerType auditor.Auditor] "adtr") in
    (FuncResolve auditor.NewRpcAuditor [] #()) "$a0") in
    do:  ("adtrRpc" <-[go.PointerType advrpc.Server] "$r0");;;
    do:  (let: "$a0" := (![go.uint64] "adtrAddr") in
    (MethodResolve (go.PointerType advrpc.Server) "Serve"%go (![go.PointerType advrpc.Server] "adtrRpc")) "$a0");;;
    do:  (let: "$a0" := time.Millisecond in
    (FuncResolve time.Sleep [] #()) "$a0");;;
    let: "alice" := (GoAlloc (go.PointerType client.Client) (GoZeroVal (go.PointerType client.Client) #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := aliceUid in
    let: "$a1" := (![go.uint64] "servAddr") in
    let: "$a2" := (![cryptoffi.SigPublicKey] "servSigPk") in
    (FuncResolve client.New [] #()) "$a0" "$a1" "$a2") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("alice" <-[go.PointerType client.Client] "$r0");;;
    do:  ("err" <-[ktcore.Blame] "$r1");;;
    (if: Convert go.untyped_bool go.bool ((![ktcore.Blame] "err") ≠⟨go.uint64⟩ ktcore.BlameNone)
    then return: (![ktcore.Blame] "err", ![go.PointerType ktcore.Evid] "evid")
    else do:  #());;;
    let: "bob" := (GoAlloc (go.PointerType client.Client) (GoZeroVal (go.PointerType client.Client) #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := bobUid in
    let: "$a1" := (![go.uint64] "servAddr") in
    let: "$a2" := (![cryptoffi.SigPublicKey] "servSigPk") in
    (FuncResolve client.New [] #()) "$a0" "$a1" "$a2") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("bob" <-[go.PointerType client.Client] "$r0");;;
    do:  ("err" <-[ktcore.Blame] "$r1");;;
    (if: Convert go.untyped_bool go.bool ((![ktcore.Blame] "err") ≠⟨go.uint64⟩ ktcore.BlameNone)
    then return: (![ktcore.Blame] "err", ![go.PointerType ktcore.Evid] "evid")
    else do:  #());;;
    (let: ("$ret0", "$ret1") := (let: "$a0" := (![go.uint64] "adtrAddr") in
    let: "$a1" := (![cryptoffi.SigPublicKey] "adtrPk") in
    (MethodResolve (go.PointerType client.Client) "Audit"%go (![go.PointerType client.Client] "alice")) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("err" <-[ktcore.Blame] "$r0");;;
    do:  ("evid" <-[go.PointerType ktcore.Evid] "$r1");;;
    (if: Convert go.untyped_bool go.bool ((![ktcore.Blame] "err") ≠⟨go.uint64⟩ ktcore.BlameNone)
    then return: (![ktcore.Blame] "err", ![go.PointerType ktcore.Evid] "evid")
    else do:  #()));;;
    (let: ("$ret0", "$ret1") := (let: "$a0" := (![go.uint64] "adtrAddr") in
    let: "$a1" := (![cryptoffi.SigPublicKey] "adtrPk") in
    (MethodResolve (go.PointerType client.Client) "Audit"%go (![go.PointerType client.Client] "bob")) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("err" <-[ktcore.Blame] "$r0");;;
    do:  ("evid" <-[go.PointerType ktcore.Evid] "$r1");;;
    (if: Convert go.untyped_bool go.bool ((![ktcore.Blame] "err") ≠⟨go.uint64⟩ ktcore.BlameNone)
    then return: (![ktcore.Blame] "err", ![go.PointerType ktcore.Evid] "evid")
    else do:  #()));;;
    let: "aliceHist" := (GoAlloc (go.SliceType (go.PointerType histEntry)) (GoZeroVal (go.SliceType (go.PointerType histEntry)) #())) in
    let: "aliceErr" := (GoAlloc ktcore.Blame (GoZeroVal ktcore.Blame #())) in
    let: "bobEp" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "bobAlicePk" := (GoAlloc (go.PointerType histEntry) (GoZeroVal (go.PointerType histEntry) #())) in
    let: "bobErr" := (GoAlloc ktcore.Blame (GoZeroVal ktcore.Blame #())) in
    let: "wg" := (GoAlloc (go.PointerType sync.WaitGroup) (GoZeroVal (go.PointerType sync.WaitGroup) #())) in
    let: "$r0" := (GoAlloc sync.WaitGroup (GoZeroVal sync.WaitGroup #())) in
    do:  ("wg" <-[go.PointerType sync.WaitGroup] "$r0");;;
    do:  (let: "$a0" := #(W64 1) in
    (MethodResolve (go.PointerType sync.WaitGroup) "Add"%go (![go.PointerType sync.WaitGroup] "wg")) "$a0");;;
    do:  (let: "$a0" := #(W64 1) in
    (MethodResolve (go.PointerType sync.WaitGroup) "Add"%go (![go.PointerType sync.WaitGroup] "wg")) "$a0");;;
    let: "$go" := (λ: <>,
      exception_do (let: "r1" := (GoAlloc ktcore.Blame (GoZeroVal ktcore.Blame #())) in
      let: "r0" := (GoAlloc (go.SliceType (go.PointerType histEntry)) (GoZeroVal (go.SliceType (go.PointerType histEntry)) #())) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![go.PointerType client.Client] "alice") in
      (FuncResolve runAlice [] #()) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("r0" <-[go.SliceType (go.PointerType histEntry)] "$r0");;;
      do:  ("r1" <-[ktcore.Blame] "$r1");;;
      let: "$r0" := (![go.SliceType (go.PointerType histEntry)] "r0") in
      do:  ("aliceHist" <-[go.SliceType (go.PointerType histEntry)] "$r0");;;
      let: "$r0" := (![ktcore.Blame] "r1") in
      do:  ("aliceErr" <-[ktcore.Blame] "$r0");;;
      do:  ((MethodResolve (go.PointerType sync.WaitGroup) "Done"%go (![go.PointerType sync.WaitGroup] "wg")) #());;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    let: "$go" := (λ: <>,
      exception_do (let: "r2" := (GoAlloc ktcore.Blame (GoZeroVal ktcore.Blame #())) in
      let: "r1" := (GoAlloc (go.PointerType histEntry) (GoZeroVal (go.PointerType histEntry) #())) in
      let: "r0" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.PointerType client.Client] "bob") in
      (FuncResolve runBob [] #()) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      let: "$r2" := "$ret2" in
      do:  ("r0" <-[go.uint64] "$r0");;;
      do:  ("r1" <-[go.PointerType histEntry] "$r1");;;
      do:  ("r2" <-[ktcore.Blame] "$r2");;;
      let: "$r0" := (![go.uint64] "r0") in
      do:  ("bobEp" <-[go.uint64] "$r0");;;
      let: "$r0" := (![go.PointerType histEntry] "r1") in
      do:  ("bobAlicePk" <-[go.PointerType histEntry] "$r0");;;
      let: "$r0" := (![ktcore.Blame] "r2") in
      do:  ("bobErr" <-[ktcore.Blame] "$r0");;;
      do:  ((MethodResolve (go.PointerType sync.WaitGroup) "Done"%go (![go.PointerType sync.WaitGroup] "wg")) #());;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    do:  ((MethodResolve (go.PointerType sync.WaitGroup) "Wait"%go (![go.PointerType sync.WaitGroup] "wg")) #());;;
    (if: Convert go.untyped_bool go.bool ((![ktcore.Blame] "aliceErr") ≠⟨go.uint64⟩ ktcore.BlameNone)
    then
      let: "$r0" := (![ktcore.Blame] "aliceErr") in
      do:  ("err" <-[ktcore.Blame] "$r0");;;
      return: (![ktcore.Blame] "err", ![go.PointerType ktcore.Evid] "evid")
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool ((![ktcore.Blame] "bobErr") ≠⟨go.uint64⟩ ktcore.BlameNone)
    then
      let: "$r0" := (![ktcore.Blame] "bobErr") in
      do:  ("err" <-[ktcore.Blame] "$r0");;;
      return: (![ktcore.Blame] "err", ![go.PointerType ktcore.Evid] "evid")
    else do:  #());;;
    (let: "$r0" := ((MethodResolve (go.PointerType auditor.Auditor) "Update"%go (![go.PointerType auditor.Auditor] "adtr")) #()) in
    do:  ("err" <-[ktcore.Blame] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![ktcore.Blame] "err") ≠⟨go.uint64⟩ ktcore.BlameNone)
    then return: (![ktcore.Blame] "err", ![go.PointerType ktcore.Evid] "evid")
    else do:  #()));;;
    (let: ("$ret0", "$ret1") := (let: "$a0" := (![go.uint64] "adtrAddr") in
    let: "$a1" := (![cryptoffi.SigPublicKey] "adtrPk") in
    (MethodResolve (go.PointerType client.Client) "Audit"%go (![go.PointerType client.Client] "alice")) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("err" <-[ktcore.Blame] "$r0");;;
    do:  ("evid" <-[go.PointerType ktcore.Evid] "$r1");;;
    (if: Convert go.untyped_bool go.bool ((![ktcore.Blame] "err") ≠⟨go.uint64⟩ ktcore.BlameNone)
    then return: (![ktcore.Blame] "err", ![go.PointerType ktcore.Evid] "evid")
    else do:  #()));;;
    (let: ("$ret0", "$ret1") := (let: "$a0" := (![go.uint64] "adtrAddr") in
    let: "$a1" := (![cryptoffi.SigPublicKey] "adtrPk") in
    (MethodResolve (go.PointerType client.Client) "Audit"%go (![go.PointerType client.Client] "bob")) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("err" <-[ktcore.Blame] "$r0");;;
    do:  ("evid" <-[go.PointerType ktcore.Evid] "$r1");;;
    (if: Convert go.untyped_bool go.bool ((![ktcore.Blame] "err") ≠⟨go.uint64⟩ ktcore.BlameNone)
    then return: (![ktcore.Blame] "err", ![go.PointerType ktcore.Evid] "evid")
    else do:  #()));;;
    do:  (let: "$a0" := ((![go.uint64] "bobEp") <⟨go.uint64⟩ (Convert go.int go.uint64 (let: "$a0" := (![go.SliceType (go.PointerType histEntry)] "aliceHist") in
    (FuncResolve go.len [go.SliceType (go.PointerType histEntry)] #()) "$a0"))) in
    (FuncResolve primitive.Assume [] #()) "$a0");;;
    let: "alicePk" := (GoAlloc (go.PointerType histEntry) (GoZeroVal (go.PointerType histEntry) #())) in
    let: "$r0" := (![go.PointerType histEntry] (IndexRef (go.SliceType (go.PointerType histEntry)) (![go.SliceType (go.PointerType histEntry)] "aliceHist", Convert go.uint64 go.int (![go.uint64] "bobEp")))) in
    do:  ("alicePk" <-[go.PointerType histEntry] "$r0");;;
    (if: (~ (let: "$a0" := (![go.PointerType histEntry] "alicePk") in
    let: "$a1" := (![go.PointerType histEntry] "bobAlicePk") in
    (FuncResolve equal [] #()) "$a0" "$a1"))
    then
      let: "$r0" := ktcore.BlameAdtrSig in
      do:  ("err" <-[ktcore.Blame] "$r0");;;
      return: (![ktcore.Blame] "err", ![go.PointerType ktcore.Evid] "evid")
    else do:  #());;;
    return: (![ktcore.Blame] "err", ![go.PointerType ktcore.Evid] "evid")).

(* go: alicebob.go:124:6 *)
Definition equalⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "o0" "o1",
    exception_do (let: "o1" := (GoAlloc (go.PointerType histEntry) "o1") in
    let: "o0" := (GoAlloc (go.PointerType histEntry) "o0") in
    (if: Convert go.untyped_bool go.bool ((![go.bool] (StructFieldRef histEntry "isReg"%go (![go.PointerType histEntry] "o0"))) ≠⟨go.bool⟩ (![go.bool] (StructFieldRef histEntry "isReg"%go (![go.PointerType histEntry] "o1"))))
    then return: (#false)
    else do:  #());;;
    (if: ![go.bool] (StructFieldRef histEntry "isReg"%go (![go.PointerType histEntry] "o0"))
    then
      return: (let: "$a0" := (![go.SliceType go.byte] (StructFieldRef histEntry "pk"%go (![go.PointerType histEntry] "o0"))) in
       let: "$a1" := (![go.SliceType go.byte] (StructFieldRef histEntry "pk"%go (![go.PointerType histEntry] "o1"))) in
       (FuncResolve bytes.Equal [] #()) "$a0" "$a1")
    else do:  #());;;
    return: (#true)).

(* runAlice does a bunch of puts.

   go: alicebob.go:135:6 *)
Definition runAliceⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "cli",
    exception_do (let: "err" := (GoAlloc ktcore.Blame (GoZeroVal ktcore.Blame #())) in
    let: "hist" := (GoAlloc (go.SliceType (go.PointerType histEntry)) (GoZeroVal (go.SliceType (go.PointerType histEntry)) #())) in
    let: "cli" := (GoAlloc (go.PointerType client.Client) "cli") in
    let: "ep" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "isInsert" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: (("$ret0", "$ret1"), "$ret2") := ((MethodResolve (go.PointerType client.Client) "SelfMon"%go (![go.PointerType client.Client] "cli")) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("ep" <-[go.uint64] "$r0");;;
    do:  ("isInsert" <-[go.bool] "$r1");;;
    do:  ("err" <-[ktcore.Blame] "$r2");;;
    (if: Convert go.untyped_bool go.bool ((![ktcore.Blame] "err") ≠⟨go.uint64⟩ ktcore.BlameNone)
    then return: (![go.SliceType (go.PointerType histEntry)] "hist", ![ktcore.Blame] "err")
    else do:  #());;;
    do:  (let: "$a0" := (~ (![go.bool] "isInsert")) in
    (FuncResolve std.Assert [] #()) "$a0");;;
    do:  (let: "$a0" := ((![go.uint64] "ep") =⟨go.uint64⟩ #(W64 0)) in
    (FuncResolve primitive.Assume [] #()) "$a0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType (go.PointerType histEntry)] "hist") in
    let: "$a1" := ((let: "$sl0" := (GoAlloc histEntry (CompositeLiteral histEntry (LiteralValue []))) in
    CompositeLiteral (go.SliceType (go.PointerType histEntry)) (LiteralValue [KeyedElement None (ElementExpression (go.PointerType histEntry) "$sl0")]))) in
    (FuncResolve go.append [go.SliceType (go.PointerType histEntry)] #()) "$a0" "$a1") in
    do:  ("hist" <-[go.SliceType (go.PointerType histEntry)] "$r0");;;
    (let: "i" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.int] "$r0");;;
    (for: (λ: <>, (![go.int] "i") <⟨go.int⟩ #(W64 20)); (λ: <>, do:  ("i" <-[go.int] ((![go.int] "i") +⟨go.int⟩ #(W64 1)))) := λ: <>,
      do:  (let: "$a0" := (#(W64 5) *⟨go.int64⟩ time.Millisecond) in
      (FuncResolve time.Sleep [] #()) "$a0");;;
      let: "pk" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
      let: "$r0" := (let: "$a0" := #(W64 32) in
      (FuncResolve cryptoffi.RandBytes [] #()) "$a0") in
      do:  ("pk" <-[go.SliceType go.byte] "$r0");;;
      do:  (let: "$a0" := (![go.SliceType go.byte] "pk") in
      (MethodResolve (go.PointerType client.Client) "Put"%go (![go.PointerType client.Client] "cli")) "$a0");;;
      (let: "$r0" := (let: "$a0" := (![go.PointerType client.Client] "cli") in
      let: "$a1" := (Convert go.int go.uint64 (let: "$a0" := (![go.SliceType (go.PointerType histEntry)] "hist") in
      (FuncResolve go.len [go.SliceType (go.PointerType histEntry)] #()) "$a0")) in
      (FuncResolve loopPending [] #()) "$a0" "$a1") in
      do:  ("err" <-[ktcore.Blame] "$r0");;;
      (if: Convert go.untyped_bool go.bool ((![ktcore.Blame] "err") ≠⟨go.uint64⟩ ktcore.BlameNone)
      then return: (![go.SliceType (go.PointerType histEntry)] "hist", ![ktcore.Blame] "err")
      else do:  #()));;;
      let: "$r0" := (let: "$a0" := (![go.SliceType (go.PointerType histEntry)] "hist") in
      let: "$a1" := ((let: "$sl0" := (GoAlloc histEntry (CompositeLiteral histEntry (LiteralValue [KeyedElement (Some (KeyField "isReg"%go)) (ElementExpression go.bool #true); KeyedElement (Some (KeyField "pk"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] "pk"))]))) in
      CompositeLiteral (go.SliceType (go.PointerType histEntry)) (LiteralValue [KeyedElement None (ElementExpression (go.PointerType histEntry) "$sl0")]))) in
      (FuncResolve go.append [go.SliceType (go.PointerType histEntry)] #()) "$a0" "$a1") in
      do:  ("hist" <-[go.SliceType (go.PointerType histEntry)] "$r0")));;;
    return: (![go.SliceType (go.PointerType histEntry)] "hist", ![ktcore.Blame] "err")).

(* go: alicebob.go:165:6 *)
Definition loopPendingⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "cli" "ep",
    exception_do (let: "err" := (GoAlloc ktcore.Blame (GoZeroVal ktcore.Blame #())) in
    let: "ep" := (GoAlloc go.uint64 "ep") in
    let: "cli" := (GoAlloc (go.PointerType client.Client) "cli") in
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "ep0" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: "done" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
      let: (("$ret0", "$ret1"), "$ret2") := ((MethodResolve (go.PointerType client.Client) "SelfMon"%go (![go.PointerType client.Client] "cli")) #()) in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      let: "$r2" := "$ret2" in
      do:  ("ep0" <-[go.uint64] "$r0");;;
      do:  ("done" <-[go.bool] "$r1");;;
      do:  ("err" <-[ktcore.Blame] "$r2");;;
      (if: Convert go.untyped_bool go.bool ((![ktcore.Blame] "err") ≠⟨go.uint64⟩ ktcore.BlameNone)
      then return: (![ktcore.Blame] "err")
      else do:  #());;;
      (if: ![go.bool] "done"
      then
        do:  (let: "$a0" := ((![go.uint64] "ep0") =⟨go.uint64⟩ (![go.uint64] "ep")) in
        (FuncResolve primitive.Assume [] #()) "$a0");;;
        break: #()
      else do:  #()));;;
    return: (![ktcore.Blame] "err")).

(* runBob does a get at some time in the middle of alice's puts.

   go: alicebob.go:182:6 *)
Definition runBobⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "cli",
    exception_do (let: "err" := (GoAlloc ktcore.Blame (GoZeroVal ktcore.Blame #())) in
    let: "ent" := (GoAlloc (go.PointerType histEntry) (GoZeroVal (go.PointerType histEntry) #())) in
    let: "ep" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "cli" := (GoAlloc (go.PointerType client.Client) "cli") in
    do:  (let: "$a0" := (#(W64 120) *⟨go.int64⟩ time.Millisecond) in
    (FuncResolve time.Sleep [] #()) "$a0");;;
    let: "pk" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "isReg" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: ((("$ret0", "$ret1"), "$ret2"), "$ret3") := (let: "$a0" := aliceUid in
    (MethodResolve (go.PointerType client.Client) "Get"%go (![go.PointerType client.Client] "cli")) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    let: "$r3" := "$ret3" in
    do:  ("ep" <-[go.uint64] "$r0");;;
    do:  ("isReg" <-[go.bool] "$r1");;;
    do:  ("pk" <-[go.SliceType go.byte] "$r2");;;
    do:  ("err" <-[ktcore.Blame] "$r3");;;
    let: "$r0" := (GoAlloc histEntry (CompositeLiteral histEntry (LiteralValue [KeyedElement (Some (KeyField "isReg"%go)) (ElementExpression go.bool (![go.bool] "isReg")); KeyedElement (Some (KeyField "pk"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] "pk"))]))) in
    do:  ("ent" <-[go.PointerType histEntry] "$r0");;;
    return: (![go.uint64] "ep", ![go.PointerType histEntry] "ent", ![ktcore.Blame] "err")).

#[global] Instance info' : PkgInfo pkg_id.alicebob :=
{|
  pkg_imported_pkgs := [code.bytes.pkg_id.bytes; code.sync.pkg_id.sync; code.time.pkg_id.time; code.github_com.goose_lang.primitive.pkg_id.primitive; code.github_com.goose_lang.std.pkg_id.std; code.github_com.sanjit_bhat.pav.auditor.pkg_id.auditor; code.github_com.sanjit_bhat.pav.client.pkg_id.client; code.github_com.sanjit_bhat.pav.cryptoffi.pkg_id.cryptoffi; code.github_com.sanjit_bhat.pav.ktcore.pkg_id.ktcore; code.github_com.sanjit_bhat.pav.server.pkg_id.server]
|}.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init pkg_id.alicebob (λ: <>,
      exception_do (do:  (server.initialize' #());;;
      do:  (ktcore.initialize' #());;;
      do:  (cryptoffi.initialize' #());;;
      do:  (client.initialize' #());;;
      do:  (auditor.initialize' #());;;
      do:  (std.initialize' #());;;
      do:  (primitive.initialize' #());;;
      do:  (time.initialize' #());;;
      do:  (sync.initialize' #());;;
      do:  (bytes.initialize' #());;;
      do:  ((λ: <>,
        exception_do (let: "$r0" := time.Millisecond in
        do:  ((GlobalVarAddr server.BatchTimeout #()) <-[time.Duration] "$r0");;;
        return: #())
        ) #()))
      ).

Module histEntry.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  isReg' : bool;
  pk' : slice.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End histEntry.

Definition histEntry'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "isReg"%go go.bool);
  (go.FieldDecl "pk"%go (go.SliceType go.byte))
].
Program Definition histEntry'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (histEntry'fds_unsealed).
Global Instance equals_unfold_histEntry {ext : ffi_syntax} {go_gctx : GoGlobalContext} : histEntry'fds =→ histEntry'fds_unsealed.
Proof. rewrite /histEntry'fds seal_eq //. Qed.

Definition histEntryⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (histEntry'fds).

Class histEntry_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] histEntry_type_repr  :: go.TypeReprUnderlying histEntryⁱᵐᵖˡ histEntry.t;
  #[global] histEntry_underlying :: (histEntry) <u (histEntryⁱᵐᵖˡ);
  #[global] histEntry_get_isReg (x : histEntry.t) :: ⟦StructFieldGet (histEntryⁱᵐᵖˡ) "isReg", #x⟧ ⤳[under] #x.(histEntry.isReg');
  #[global] histEntry_set_isReg (x : histEntry.t) y :: ⟦StructFieldSet (histEntryⁱᵐᵖˡ) "isReg", (#x, #y)⟧ ⤳[under] #(x <|histEntry.isReg' := y|>);
  #[global] histEntry_get_pk (x : histEntry.t) :: ⟦StructFieldGet (histEntryⁱᵐᵖˡ) "pk", #x⟧ ⤳[under] #x.(histEntry.pk');
  #[global] histEntry_set_pk (x : histEntry.t) y :: ⟦StructFieldSet (histEntryⁱᵐᵖˡ) "pk", (#x, #y)⟧ ⤳[under] #(x <|histEntry.pk' := y|>);
}.

Class Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] histEntry_instance :: histEntry_Assumptions;
  #[global] testAliceBob_unfold :: FuncUnfold testAliceBob [] (testAliceBobⁱᵐᵖˡ);
  #[global] equal_unfold :: FuncUnfold equal [] (equalⁱᵐᵖˡ);
  #[global] runAlice_unfold :: FuncUnfold runAlice [] (runAliceⁱᵐᵖˡ);
  #[global] loopPending_unfold :: FuncUnfold loopPending [] (loopPendingⁱᵐᵖˡ);
  #[global] runBob_unfold :: FuncUnfold runBob [] (runBobⁱᵐᵖˡ);
  #[global] import_bytes_Assumption :: bytes.Assumptions;
  #[global] import_sync_Assumption :: sync.Assumptions;
  #[global] import_time_Assumption :: time.Assumptions;
  #[global] import_primitive_Assumption :: primitive.Assumptions;
  #[global] import_std_Assumption :: std.Assumptions;
  #[global] import_auditor_Assumption :: auditor.Assumptions;
  #[global] import_client_Assumption :: client.Assumptions;
  #[global] import_cryptoffi_Assumption :: cryptoffi.Assumptions;
  #[global] import_ktcore_Assumption :: ktcore.Assumptions;
  #[global] import_server_Assumption :: server.Assumptions;
}.
End alicebob.
