(* autogenerated from github.com/sanjit-bhat/pav/auditor *)
Require Export New.code.bytes.
Require Export New.code.github_com.goose_lang.std.
Require Export New.code.github_com.sanjit_bhat.pav.advrpc.
Require Export New.code.github_com.sanjit_bhat.pav.cryptoffi.
Require Export New.code.github_com.sanjit_bhat.pav.hashchain.
Require Export New.code.github_com.sanjit_bhat.pav.ktcore.
Require Export New.code.github_com.sanjit_bhat.pav.merkle.
Require Export New.code.github_com.sanjit_bhat.pav.safemarshal.
Require Export New.code.github_com.sanjit_bhat.pav.server.
Require Export New.code.github_com.tchajed.marshal.
Require Export New.code.sync.

From New.golang Require Import defn.
Definition auditor : go_string := "github.com/sanjit-bhat/pav/auditor".

Module auditor.

Module Auditor. Definition id : go_string := "github.com/sanjit-bhat/pav/auditor.Auditor"%go. End Auditor.
Module history. Definition id : go_string := "github.com/sanjit-bhat/pav/auditor.history"%go. End history.
Module serv. Definition id : go_string := "github.com/sanjit-bhat/pav/auditor.serv"%go. End serv.
Module UpdateReply. Definition id : go_string := "github.com/sanjit-bhat/pav/auditor.UpdateReply"%go. End UpdateReply.
Module GetArg. Definition id : go_string := "github.com/sanjit-bhat/pav/auditor.GetArg"%go. End GetArg.
Module GetReply. Definition id : go_string := "github.com/sanjit-bhat/pav/auditor.GetReply"%go. End GetReply.

Section code.
Context `{ffi_syntax}.


Definition Auditor : go_type := structT [
  "mu" :: ptrT;
  "sk" :: ptrT;
  "lastDig" :: sliceT;
  "startEp" :: uint64T;
  "hist" :: sliceT;
  "serv" :: ptrT
].
#[global] Typeclasses Opaque Auditor.
#[global] Opaque Auditor.

Definition history : go_type := structT [
  "link" :: sliceT;
  "servSig" :: sliceT;
  "adtrSig" :: sliceT
].
#[global] Typeclasses Opaque history.
#[global] Opaque history.

Definition serv : go_type := structT [
  "cli" :: ptrT;
  "sigPk" :: cryptoffi.SigPublicKey;
  "vrfPk" :: sliceT;
  "servVrfSig" :: sliceT;
  "adtrVrfSig" :: sliceT
].
#[global] Typeclasses Opaque serv.
#[global] Opaque serv.

Definition getNextLink : go_string := "github.com/sanjit-bhat/pav/auditor.getNextLink"%go.

(* Update queries server for a new epoch update and applies it.

   go: auditor.go:43:19 *)
Definition Auditor__Updateⁱᵐᵖˡ : val :=
  λ: "a" <>,
    with_defer: (let: "err" := (mem.alloc (type.zero_val ktcore.Blame)) in
    let: "a" := (mem.alloc "a") in
    do:  ((method_call #(ptrT.id sync.RWMutex.id) #"Lock"%go (![ptrT] (struct.field_ref ptrT #"mu"%go (![ptrT] "a")))) #());;;
    do:  (let: "$f" := (method_call #(ptrT.id sync.RWMutex.id) #"Unlock"%go (![ptrT] (struct.field_ref ptrT #"mu"%go (![ptrT] "a")))) in
    "$defer" <-[funcT] (let: "$oldf" := (![funcT] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
<<<<<<< HEAD
    let: "numEps" := (mem.alloc (type.zero_val uint64T)) in
    let: "$r0" := (s_to_w64 (let: "$a0" := (![sliceT] (struct.field_ref ptrT #"hist"%go (![ptrT] "a"))) in
    slice.len "$a0")) in
    do:  ("numEps" <-[uint64T] "$r0");;;
    let: "upd" := (mem.alloc (type.zero_val sliceT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![ptrT] (struct.field_ref ptrT #"cli"%go (![ptrT] (struct.field_ref ptrT #"serv"%go (![ptrT] "a"))))) in
    let: "$a1" := (![uint64T] "numEps") in
=======
    let: "numEps" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := ((![#uint64T] (struct.field_ref #Auditor #"startEp"%go (![#ptrT] "a"))) + (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref #Auditor #"hist"%go (![#ptrT] "a"))) in
    slice.len "$a0"))) in
    do:  ("numEps" <-[#uint64T] "$r0");;;
    let: "upd" := (mem.alloc (type.zero_val #sliceT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#ptrT] (struct.field_ref #serv #"cli"%go (![#ptrT] (struct.field_ref #Auditor #"serv"%go (![#ptrT] "a"))))) in
    let: "$a1" := (![#uint64T] "numEps") in
>>>>>>> master
    (func_call #server.CallAudit) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("upd" <-[sliceT] "$r0");;;
    do:  ("err" <-[ktcore.Blame] "$r1");;;
    (if: (![ktcore.Blame] "err") ≠ ktcore.BlameNone
    then return: (![ktcore.Blame] "err")
    else do:  #());;;
    let: "$range" := (![sliceT] "upd") in
    (let: "p" := (mem.alloc (type.zero_val ptrT)) in
    slice.for_range ptrT "$range" (λ: "$key" "$value",
      do:  ("p" <-[ptrT] "$value");;;
      do:  "$key";;;
<<<<<<< HEAD
      let: "$r0" := (let: "$a0" := (![ptrT] "p") in
      (method_call #(ptrT.id Auditor.id) #"updOnce"%go (![ptrT] "a")) "$a0") in
      do:  ("err" <-[ktcore.Blame] "$r0");;;
      (if: (![ktcore.Blame] "err") ≠ ktcore.BlameNone
      then return: (![ktcore.Blame] "err")
      else do:  #())));;;
    return: (![ktcore.Blame] "err")).

Definition getNextDig : go_string := "github.com/sanjit-bhat/pav/auditor.getNextDig"%go.

(* go: auditor.go:56:19 *)
Definition Auditor__updOnceⁱᵐᵖˡ : val :=
  λ: "a" "p",
    exception_do (let: "err" := (mem.alloc (type.zero_val ktcore.Blame)) in
    let: "a" := (mem.alloc "a") in
    let: "p" := (mem.alloc "p") in
    let: "numEps" := (mem.alloc (type.zero_val uint64T)) in
    let: "$r0" := (s_to_w64 (let: "$a0" := (![sliceT] (struct.field_ref ptrT #"hist"%go (![ptrT] "a"))) in
    slice.len "$a0")) in
    do:  ("numEps" <-[uint64T] "$r0");;;
    let: "lastLink" := (mem.alloc (type.zero_val sliceT)) in
    (if: (![uint64T] "numEps") = #(W64 0)
    then
      let: "$r0" := ((func_call #hashchain.GetEmptyLink) #()) in
      do:  ("lastLink" <-[sliceT] "$r0")
    else
      let: "$r0" := (![sliceT] (struct.field_ref ptrT #"link"%go (![ptrT] (slice.elem_ref ptrT (![sliceT] (struct.field_ref ptrT #"hist"%go (![ptrT] "a"))) ((![uint64T] "numEps") - #(W64 1)))))) in
      do:  ("lastLink" <-[sliceT] "$r0"));;;
    let: "errb" := (mem.alloc (type.zero_val boolT)) in
    let: "nextDig" := (mem.alloc (type.zero_val sliceT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![sliceT] (struct.field_ref ptrT #"lastDig"%go (![ptrT] "a"))) in
    let: "$a1" := (![sliceT] (struct.field_ref ptrT #"Updates"%go (![ptrT] "p"))) in
    (func_call #getNextDig) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("nextDig" <-[sliceT] "$r0");;;
    do:  ("errb" <-[boolT] "$r1");;;
    (if: ![boolT] "errb"
    then return: (ktcore.BlameServFull)
    else do:  #());;;
    let: "nextLink" := (mem.alloc (type.zero_val sliceT)) in
    let: "$r0" := (let: "$a0" := (![sliceT] "lastLink") in
    let: "$a1" := (![sliceT] "nextDig") in
    (func_call #hashchain.GetNextLink) "$a0" "$a1") in
    do:  ("nextLink" <-[sliceT] "$r0");;;
    (if: let: "$a0" := (![cryptoffi.SigPublicKey] (struct.field_ref ptrT #"sigPk"%go (![ptrT] (struct.field_ref ptrT #"serv"%go (![ptrT] "a"))))) in
    let: "$a1" := (![uint64T] "numEps") in
    let: "$a2" := (![sliceT] "nextLink") in
    let: "$a3" := (![sliceT] (struct.field_ref ptrT #"LinkSig"%go (![ptrT] "p"))) in
    (func_call #ktcore.VerifyLinkSig) "$a0" "$a1" "$a2" "$a3"
    then return: (ktcore.BlameServFull)
    else do:  #());;;
    let: "sig" := (mem.alloc (type.zero_val sliceT)) in
    let: "$r0" := (let: "$a0" := (![ptrT] (struct.field_ref ptrT #"sk"%go (![ptrT] "a"))) in
    let: "$a1" := (![uint64T] "numEps") in
    let: "$a2" := (![sliceT] "nextLink") in
    (func_call #ktcore.SignLink) "$a0" "$a1" "$a2") in
    do:  ("sig" <-[sliceT] "$r0");;;
    let: "$r0" := (![sliceT] "nextDig") in
    do:  ((struct.field_ref ptrT #"lastDig"%go (![ptrT] "a")) <-[sliceT] "$r0");;;
    let: "info" := (mem.alloc (type.zero_val ptrT)) in
    let: "$r0" := (mem.alloc (let: "$link" := (![sliceT] "nextLink") in
    let: "$servSig" := (![sliceT] (struct.field_ref ptrT #"LinkSig"%go (![ptrT] "p"))) in
    let: "$adtrSig" := (![sliceT] "sig") in
    struct.make history [{
      "link" ::= "$link";
      "servSig" ::= "$servSig";
      "adtrSig" ::= "$adtrSig"
    }])) in
    do:  ("info" <-[ptrT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT] (struct.field_ref ptrT #"hist"%go (![ptrT] "a"))) in
    let: "$a1" := ((let: "$sl0" := (![ptrT] "info") in
    slice.literal ptrT ["$sl0"])) in
    (slice.append ptrT) "$a0" "$a1") in
    do:  ((struct.field_ref ptrT #"hist"%go (![ptrT] "a")) <-[sliceT] "$r0");;;
    return: (ktcore.BlameNone)).

=======
      let: "sigPk" := (mem.alloc (type.zero_val #cryptoffi.SigPublicKey)) in
      let: "$r0" := (![#cryptoffi.SigPublicKey] (struct.field_ref #serv #"sigPk"%go (![#ptrT] (struct.field_ref #Auditor #"serv"%go (![#ptrT] "a"))))) in
      do:  ("sigPk" <-[#cryptoffi.SigPublicKey] "$r0");;;
      let: "prevEp" := (mem.alloc (type.zero_val #uint64T)) in
      let: "$r0" := (((![#uint64T] (struct.field_ref #Auditor #"startEp"%go (![#ptrT] "a"))) + (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref #Auditor #"hist"%go (![#ptrT] "a"))) in
      slice.len "$a0"))) - #(W64 1)) in
      do:  ("prevEp" <-[#uint64T] "$r0");;;
      let: "prevLink" := (mem.alloc (type.zero_val #sliceT)) in
      let: "$r0" := (![#sliceT] (struct.field_ref #history #"link"%go (![#ptrT] (slice.elem_ref #ptrT (![#sliceT] (struct.field_ref #Auditor #"hist"%go (![#ptrT] "a"))) ((let: "$a0" := (![#sliceT] (struct.field_ref #Auditor #"hist"%go (![#ptrT] "a"))) in
      slice.len "$a0") - #(W64 1)))))) in
      do:  ("prevLink" <-[#sliceT] "$r0");;;
      let: "errb" := (mem.alloc (type.zero_val #boolT)) in
      let: "link" := (mem.alloc (type.zero_val #sliceT)) in
      let: "dig" := (mem.alloc (type.zero_val #sliceT)) in
      let: "ep" := (mem.alloc (type.zero_val #uint64T)) in
      let: ((("$ret0", "$ret1"), "$ret2"), "$ret3") := (let: "$a0" := (![#cryptoffi.SigPublicKey] "sigPk") in
      let: "$a1" := (![#uint64T] "prevEp") in
      let: "$a2" := (![#sliceT] (struct.field_ref #Auditor #"lastDig"%go (![#ptrT] "a"))) in
      let: "$a3" := (![#sliceT] "prevLink") in
      let: "$a4" := (![#ptrT] "p") in
      (func_call #getNextLink) "$a0" "$a1" "$a2" "$a3" "$a4") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      let: "$r2" := "$ret2" in
      let: "$r3" := "$ret3" in
      do:  ("ep" <-[#uint64T] "$r0");;;
      do:  ("dig" <-[#sliceT] "$r1");;;
      do:  ("link" <-[#sliceT] "$r2");;;
      do:  ("errb" <-[#boolT] "$r3");;;
      (if: ![#boolT] "errb"
      then
        let: "$r0" := ktcore.BlameServFull in
        do:  ("err" <-[#ktcore.Blame] "$r0");;;
        return: (![#ktcore.Blame] "err")
      else do:  #());;;
      let: "sig" := (mem.alloc (type.zero_val #sliceT)) in
      let: "$r0" := (let: "$a0" := (![#ptrT] (struct.field_ref #Auditor #"sk"%go (![#ptrT] "a"))) in
      let: "$a1" := (![#uint64T] "ep") in
      let: "$a2" := (![#sliceT] "link") in
      (func_call #ktcore.SignLink) "$a0" "$a1" "$a2") in
      do:  ("sig" <-[#sliceT] "$r0");;;
      let: "$r0" := (![#sliceT] "dig") in
      do:  ((struct.field_ref #Auditor #"lastDig"%go (![#ptrT] "a")) <-[#sliceT] "$r0");;;
      let: "info" := (mem.alloc (type.zero_val #ptrT)) in
      let: "$r0" := (mem.alloc (let: "$link" := (![#sliceT] "link") in
      let: "$servSig" := (![#sliceT] (struct.field_ref #ktcore.AuditProof #"LinkSig"%go (![#ptrT] "p"))) in
      let: "$adtrSig" := (![#sliceT] "sig") in
      struct.make #history [{
        "link" ::= "$link";
        "servSig" ::= "$servSig";
        "adtrSig" ::= "$adtrSig"
      }])) in
      do:  ("info" <-[#ptrT] "$r0");;;
      let: "$r0" := (let: "$a0" := (![#sliceT] (struct.field_ref #Auditor #"hist"%go (![#ptrT] "a"))) in
      let: "$a1" := ((let: "$sl0" := (![#ptrT] "info") in
      slice.literal #ptrT ["$sl0"])) in
      (slice.append #ptrT) "$a0" "$a1") in
      do:  ((struct.field_ref #Auditor #"hist"%go (![#ptrT] "a")) <-[#sliceT] "$r0")));;;
    return: (![#ktcore.Blame] "err")).

>>>>>>> master
Definition GetReply : go_type := structT [
  "Link" :: sliceT;
  "ServLinkSig" :: sliceT;
  "AdtrLinkSig" :: sliceT;
  "VrfPk" :: sliceT;
  "ServVrfSig" :: sliceT;
  "AdtrVrfSig" :: sliceT;
  "Err" :: ktcore.Blame
].
#[global] Typeclasses Opaque GetReply.
#[global] Opaque GetReply.

(* Get returns the auditor's info for a particular epoch.
   it errors if the epoch is out of bounds.

   go: auditor.go:73:19 *)
Definition Auditor__Getⁱᵐᵖˡ : val :=
  λ: "a" "epoch",
    with_defer: (let: "a" := (mem.alloc "a") in
    let: "epoch" := (mem.alloc "epoch") in
    do:  ((method_call #(ptrT.id sync.RWMutex.id) #"RLock"%go (![ptrT] (struct.field_ref ptrT #"mu"%go (![ptrT] "a")))) #());;;
    do:  (let: "$f" := (method_call #(ptrT.id sync.RWMutex.id) #"RUnlock"%go (![ptrT] (struct.field_ref ptrT #"mu"%go (![ptrT] "a")))) in
    "$defer" <-[funcT] (let: "$oldf" := (![funcT] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
<<<<<<< HEAD
    let: "numEpochs" := (mem.alloc (type.zero_val uint64T)) in
    let: "$r0" := (s_to_w64 (let: "$a0" := (![sliceT] (struct.field_ref ptrT #"hist"%go (![ptrT] "a"))) in
    slice.len "$a0")) in
    do:  ("numEpochs" <-[uint64T] "$r0");;;
    (if: (![uint64T] "epoch") ≥ (![uint64T] "numEpochs")
=======
    let: "numEpochs" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := ((![#uint64T] (struct.field_ref #Auditor #"startEp"%go (![#ptrT] "a"))) + (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref #Auditor #"hist"%go (![#ptrT] "a"))) in
    slice.len "$a0"))) in
    do:  ("numEpochs" <-[#uint64T] "$r0");;;
    (if: (![#uint64T] "epoch") < (![#uint64T] (struct.field_ref #Auditor #"startEp"%go (![#ptrT] "a")))
    then
      return: (mem.alloc (let: "$Err" := ktcore.BlameUnknown in
       struct.make #GetReply [{
         "Link" ::= type.zero_val #sliceT;
         "ServLinkSig" ::= type.zero_val #sliceT;
         "AdtrLinkSig" ::= type.zero_val #sliceT;
         "VrfPk" ::= type.zero_val #sliceT;
         "ServVrfSig" ::= type.zero_val #sliceT;
         "AdtrVrfSig" ::= type.zero_val #sliceT;
         "Err" ::= "$Err"
       }]))
    else do:  #());;;
    (if: (![#uint64T] "epoch") ≥ (![#uint64T] "numEpochs")
>>>>>>> master
    then
      return: (mem.alloc (let: "$Err" := ktcore.BlameUnknown in
       struct.make GetReply [{
         "Link" ::= type.zero_val sliceT;
         "ServLinkSig" ::= type.zero_val sliceT;
         "AdtrLinkSig" ::= type.zero_val sliceT;
         "VrfPk" ::= type.zero_val sliceT;
         "ServVrfSig" ::= type.zero_val sliceT;
         "AdtrVrfSig" ::= type.zero_val sliceT;
         "Err" ::= "$Err"
       }]))
    else do:  #());;;
<<<<<<< HEAD
    let: "x" := (mem.alloc (type.zero_val ptrT)) in
    let: "$r0" := (![ptrT] (slice.elem_ref ptrT (![sliceT] (struct.field_ref ptrT #"hist"%go (![ptrT] "a"))) (![uint64T] "epoch"))) in
    do:  ("x" <-[ptrT] "$r0");;;
    return: (mem.alloc (let: "$Link" := (![sliceT] (struct.field_ref ptrT #"link"%go (![ptrT] "x"))) in
     let: "$ServLinkSig" := (![sliceT] (struct.field_ref ptrT #"servSig"%go (![ptrT] "x"))) in
     let: "$AdtrLinkSig" := (![sliceT] (struct.field_ref ptrT #"adtrSig"%go (![ptrT] "x"))) in
     let: "$VrfPk" := (![sliceT] (struct.field_ref ptrT #"vrfPk"%go (![ptrT] (struct.field_ref ptrT #"serv"%go (![ptrT] "a"))))) in
     let: "$ServVrfSig" := (![sliceT] (struct.field_ref ptrT #"servVrfSig"%go (![ptrT] (struct.field_ref ptrT #"serv"%go (![ptrT] "a"))))) in
     let: "$AdtrVrfSig" := (![sliceT] (struct.field_ref ptrT #"adtrVrfSig"%go (![ptrT] (struct.field_ref ptrT #"serv"%go (![ptrT] "a"))))) in
     struct.make GetReply [{
=======
    let: "x" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (![#ptrT] (slice.elem_ref #ptrT (![#sliceT] (struct.field_ref #Auditor #"hist"%go (![#ptrT] "a"))) ((![#uint64T] "epoch") - (![#uint64T] (struct.field_ref #Auditor #"startEp"%go (![#ptrT] "a")))))) in
    do:  ("x" <-[#ptrT] "$r0");;;
    return: (mem.alloc (let: "$Link" := (![#sliceT] (struct.field_ref #history #"link"%go (![#ptrT] "x"))) in
     let: "$ServLinkSig" := (![#sliceT] (struct.field_ref #history #"servSig"%go (![#ptrT] "x"))) in
     let: "$AdtrLinkSig" := (![#sliceT] (struct.field_ref #history #"adtrSig"%go (![#ptrT] "x"))) in
     let: "$VrfPk" := (![#sliceT] (struct.field_ref #serv #"vrfPk"%go (![#ptrT] (struct.field_ref #Auditor #"serv"%go (![#ptrT] "a"))))) in
     let: "$ServVrfSig" := (![#sliceT] (struct.field_ref #serv #"servVrfSig"%go (![#ptrT] (struct.field_ref #Auditor #"serv"%go (![#ptrT] "a"))))) in
     let: "$AdtrVrfSig" := (![#sliceT] (struct.field_ref #serv #"adtrVrfSig"%go (![#ptrT] (struct.field_ref #Auditor #"serv"%go (![#ptrT] "a"))))) in
     struct.make #GetReply [{
>>>>>>> master
       "Link" ::= "$Link";
       "ServLinkSig" ::= "$ServLinkSig";
       "AdtrLinkSig" ::= "$AdtrLinkSig";
       "VrfPk" ::= "$VrfPk";
       "ServVrfSig" ::= "$ServVrfSig";
       "AdtrVrfSig" ::= "$AdtrVrfSig";
       "Err" ::= type.zero_val ktcore.Blame
     }]))).

Definition New : go_string := "github.com/sanjit-bhat/pav/auditor.New"%go.

Definition CheckStart : go_string := "github.com/sanjit-bhat/pav/auditor.CheckStart"%go.

(* go: auditor.go:90:6 *)
Definition Newⁱᵐᵖˡ : val :=
  λ: "servAddr" "servPk",
    exception_do (let: "err" := (mem.alloc (type.zero_val ktcore.Blame)) in
    let: "sigPk" := (mem.alloc (type.zero_val cryptoffi.SigPublicKey)) in
    let: "a" := (mem.alloc (type.zero_val ptrT)) in
    let: "servPk" := (mem.alloc "servPk") in
    let: "servAddr" := (mem.alloc "servAddr") in
    let: "cli" := (mem.alloc (type.zero_val ptrT)) in
    let: "$r0" := (let: "$a0" := (![uint64T] "servAddr") in
    (func_call #advrpc.Dial) "$a0") in
    do:  ("cli" <-[ptrT] "$r0");;;
    let: "reply" := (mem.alloc (type.zero_val ptrT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![ptrT] "cli") in
    (func_call #server.CallStart) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("reply" <-[ptrT] "$r0");;;
    do:  ("err" <-[ktcore.Blame] "$r1");;;
    (if: (![ktcore.Blame] "err") ≠ ktcore.BlameNone
    then return: (![ptrT] "a", ![cryptoffi.SigPublicKey] "sigPk", ![ktcore.Blame] "err")
    else do:  #());;;
<<<<<<< HEAD
    (if: let: "$a0" := (![cryptoffi.SigPublicKey] "servPk") in
    let: "$a1" := (![sliceT] (struct.field_ref ptrT #"VrfPk"%go (![ptrT] "reply"))) in
    let: "$a2" := (![sliceT] (struct.field_ref ptrT #"VrfSig"%go (![ptrT] "reply"))) in
    (func_call #ktcore.VerifyVrfSig) "$a0" "$a1" "$a2"
=======
    let: "errb" := (mem.alloc (type.zero_val #boolT)) in
    let: "startLink" := (mem.alloc (type.zero_val #sliceT)) in
    let: "startDig" := (mem.alloc (type.zero_val #sliceT)) in
    let: "startEp" := (mem.alloc (type.zero_val #uint64T)) in
    let: (((("$ret0", "$ret1"), "$ret2"), "$ret3"), "$ret4") := (let: "$a0" := (![#cryptoffi.SigPublicKey] "servPk") in
    let: "$a1" := (![#ptrT] "reply") in
    (func_call #CheckStart) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    let: "$r3" := "$ret3" in
    let: "$r4" := "$ret4" in
    do:  ("startEp" <-[#uint64T] "$r0");;;
    do:  ("startDig" <-[#sliceT] "$r1");;;
    do:  ("startLink" <-[#sliceT] "$r2");;;
    do:  "$r3";;;
    do:  ("errb" <-[#boolT] "$r4");;;
    (if: ![#boolT] "errb"
>>>>>>> master
    then
      let: "$r0" := ktcore.BlameServFull in
      do:  ("err" <-[ktcore.Blame] "$r0");;;
      return: (![ptrT] "a", ![cryptoffi.SigPublicKey] "sigPk", ![ktcore.Blame] "err")
    else do:  #());;;
    let: "mu" := (mem.alloc (type.zero_val ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val sync.RWMutex)) in
    do:  ("mu" <-[ptrT] "$r0");;;
    let: "sk" := (mem.alloc (type.zero_val ptrT)) in
    let: ("$ret0", "$ret1") := ((func_call #cryptoffi.SigGenerateKey) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
<<<<<<< HEAD
    do:  ("sigPk" <-[cryptoffi.SigPublicKey] "$r0");;;
    do:  ("sk" <-[ptrT] "$r1");;;
    let: "m" := (mem.alloc (type.zero_val ptrT)) in
    let: "$r0" := (mem.alloc (struct.make merkle.Map [{
      "root" ::= type.zero_val ptrT
    }])) in
    do:  ("m" <-[ptrT] "$r0");;;
    let: "dig" := (mem.alloc (type.zero_val sliceT)) in
    let: "$r0" := ((method_call #(ptrT.id merkle.Map.id) #"Hash"%go (![ptrT] "m")) #()) in
    do:  ("dig" <-[sliceT] "$r0");;;
    let: "sig" := (mem.alloc (type.zero_val sliceT)) in
    let: "$r0" := (let: "$a0" := (![ptrT] "sk") in
    let: "$a1" := (![sliceT] (struct.field_ref ptrT #"VrfPk"%go (![ptrT] "reply"))) in
    (func_call #ktcore.SignVrf) "$a0" "$a1") in
    do:  ("sig" <-[sliceT] "$r0");;;
    let: "serv" := (mem.alloc (type.zero_val ptrT)) in
    let: "$r0" := (mem.alloc (let: "$cli" := (![ptrT] "cli") in
    let: "$sigPk" := (![cryptoffi.SigPublicKey] "servPk") in
    let: "$vrfPk" := (![sliceT] (struct.field_ref ptrT #"VrfPk"%go (![ptrT] "reply"))) in
    let: "$servVrfSig" := (![sliceT] (struct.field_ref ptrT #"VrfSig"%go (![ptrT] "reply"))) in
    let: "$adtrVrfSig" := (![sliceT] "sig") in
    struct.make serv [{
=======
    do:  ("sigPk" <-[#cryptoffi.SigPublicKey] "$r0");;;
    do:  ("sk" <-[#ptrT] "$r1");;;
    let: "linkSig" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#ptrT] "sk") in
    let: "$a1" := (![#uint64T] "startEp") in
    let: "$a2" := (![#sliceT] "startLink") in
    (func_call #ktcore.SignLink) "$a0" "$a1" "$a2") in
    do:  ("linkSig" <-[#sliceT] "$r0");;;
    let: "h" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (let: "$link" := (![#sliceT] "startLink") in
    let: "$servSig" := (![#sliceT] (struct.field_ref #server.StartReply #"LinkSig"%go (![#ptrT] "reply"))) in
    let: "$adtrSig" := (![#sliceT] "linkSig") in
    struct.make #history [{
      "link" ::= "$link";
      "servSig" ::= "$servSig";
      "adtrSig" ::= "$adtrSig"
    }])) in
    do:  ("h" <-[#ptrT] "$r0");;;
    let: "vrfSig" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#ptrT] "sk") in
    let: "$a1" := (![#sliceT] (struct.field_ref #server.StartReply #"VrfPk"%go (![#ptrT] "reply"))) in
    (func_call #ktcore.SignVrf) "$a0" "$a1") in
    do:  ("vrfSig" <-[#sliceT] "$r0");;;
    let: "serv" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (let: "$cli" := (![#ptrT] "cli") in
    let: "$sigPk" := (![#cryptoffi.SigPublicKey] "servPk") in
    let: "$vrfPk" := (![#sliceT] (struct.field_ref #server.StartReply #"VrfPk"%go (![#ptrT] "reply"))) in
    let: "$servVrfSig" := (![#sliceT] (struct.field_ref #server.StartReply #"VrfSig"%go (![#ptrT] "reply"))) in
    let: "$adtrVrfSig" := (![#sliceT] "vrfSig") in
    struct.make #serv [{
>>>>>>> master
      "cli" ::= "$cli";
      "sigPk" ::= "$sigPk";
      "vrfPk" ::= "$vrfPk";
      "servVrfSig" ::= "$servVrfSig";
      "adtrVrfSig" ::= "$adtrVrfSig"
    }])) in
<<<<<<< HEAD
    do:  ("serv" <-[ptrT] "$r0");;;
    let: "$r0" := (mem.alloc (let: "$mu" := (![ptrT] "mu") in
    let: "$sk" := (![ptrT] "sk") in
    let: "$lastDig" := (![sliceT] "dig") in
    let: "$serv" := (![ptrT] "serv") in
    struct.make Auditor [{
      "mu" ::= "$mu";
      "sk" ::= "$sk";
      "lastDig" ::= "$lastDig";
      "hist" ::= type.zero_val sliceT;
=======
    do:  ("serv" <-[#ptrT] "$r0");;;
    let: "$r0" := (mem.alloc (let: "$mu" := (![#ptrT] "mu") in
    let: "$sk" := (![#ptrT] "sk") in
    let: "$lastDig" := (![#sliceT] "startDig") in
    let: "$startEp" := (![#uint64T] "startEp") in
    let: "$hist" := ((let: "$sl0" := (![#ptrT] "h") in
    slice.literal #ptrT ["$sl0"])) in
    let: "$serv" := (![#ptrT] "serv") in
    struct.make #Auditor [{
      "mu" ::= "$mu";
      "sk" ::= "$sk";
      "lastDig" ::= "$lastDig";
      "startEp" ::= "$startEp";
      "hist" ::= "$hist";
>>>>>>> master
      "serv" ::= "$serv"
    }])) in
    do:  ("a" <-[ptrT] "$r0");;;
    return: (![ptrT] "a", ![cryptoffi.SigPublicKey] "sigPk", ![ktcore.Blame] "err")).

Definition getNextDig : go_string := "github.com/sanjit-bhat/pav/auditor.getNextDig"%go.

(* go: auditor.go:112:6 *)
Definition getNextLinkⁱᵐᵖˡ : val :=
  λ: "sigPk" "prevEp" "prevDig" "prevLink" "p",
    exception_do (let: "err" := (mem.alloc (type.zero_val #boolT)) in
    let: "link" := (mem.alloc (type.zero_val #sliceT)) in
    let: "dig" := (mem.alloc (type.zero_val #sliceT)) in
    let: "ep" := (mem.alloc (type.zero_val #uint64T)) in
    let: "p" := (mem.alloc "p") in
    let: "prevLink" := (mem.alloc "prevLink") in
    let: "prevDig" := (mem.alloc "prevDig") in
    let: "prevEp" := (mem.alloc "prevEp") in
    let: "sigPk" := (mem.alloc "sigPk") in
    (if: (~ (let: "$a0" := (![#uint64T] "prevEp") in
    let: "$a1" := #(W64 1) in
    (func_call #std.SumNoOverflow) "$a0" "$a1"))
    then
      let: "$r0" := #true in
      do:  ("err" <-[#boolT] "$r0");;;
      return: (![#uint64T] "ep", ![#sliceT] "dig", ![#sliceT] "link", ![#boolT] "err")
    else do:  #());;;
    let: "$r0" := ((![#uint64T] "prevEp") + #(W64 1)) in
    do:  ("ep" <-[#uint64T] "$r0");;;
    (let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "prevDig") in
    let: "$a1" := (![#sliceT] (struct.field_ref #ktcore.AuditProof #"Updates"%go (![#ptrT] "p"))) in
    (func_call #getNextDig) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("dig" <-[#sliceT] "$r0");;;
    do:  ("err" <-[#boolT] "$r1");;;
    (if: ![#boolT] "err"
    then return: (![#uint64T] "ep", ![#sliceT] "dig", ![#sliceT] "link", ![#boolT] "err")
    else do:  #()));;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "prevLink") in
    let: "$a1" := (![#sliceT] "dig") in
    (func_call #hashchain.GetNextLink) "$a0" "$a1") in
    do:  ("link" <-[#sliceT] "$r0");;;
    (if: let: "$a0" := (![#cryptoffi.SigPublicKey] "sigPk") in
    let: "$a1" := (![#uint64T] "ep") in
    let: "$a2" := (![#sliceT] "link") in
    let: "$a3" := (![#sliceT] (struct.field_ref #ktcore.AuditProof #"LinkSig"%go (![#ptrT] "p"))) in
    (func_call #ktcore.VerifyLinkSig) "$a0" "$a1" "$a2" "$a3"
    then
      let: "$r0" := #true in
      do:  ("err" <-[#boolT] "$r0");;;
      return: (![#uint64T] "ep", ![#sliceT] "dig", ![#sliceT] "link", ![#boolT] "err")
    else do:  #());;;
    return: (![#uint64T] "ep", ![#sliceT] "dig", ![#sliceT] "link", ![#boolT] "err")).

(* go: auditor.go:129:6 *)
Definition getNextDigⁱᵐᵖˡ : val :=
<<<<<<< HEAD
  λ: "lastDig" "updates",
    exception_do (let: "err" := (mem.alloc (type.zero_val boolT)) in
    let: "dig" := (mem.alloc (type.zero_val sliceT)) in
    let: "updates" := (mem.alloc "updates") in
    let: "lastDig" := (mem.alloc "lastDig") in
    let: "$r0" := (![sliceT] "lastDig") in
    do:  ("dig" <-[sliceT] "$r0");;;
    let: "$range" := (![sliceT] "updates") in
    (let: "u" := (mem.alloc (type.zero_val ptrT)) in
    slice.for_range ptrT "$range" (λ: "$key" "$value",
      do:  ("u" <-[ptrT] "$value");;;
=======
  λ: "prevDig" "updates",
    exception_do (let: "err" := (mem.alloc (type.zero_val #boolT)) in
    let: "dig" := (mem.alloc (type.zero_val #sliceT)) in
    let: "updates" := (mem.alloc "updates") in
    let: "prevDig" := (mem.alloc "prevDig") in
    let: "$r0" := (![#sliceT] "prevDig") in
    do:  ("dig" <-[#sliceT] "$r0");;;
    let: "$range" := (![#sliceT] "updates") in
    (let: "u" := (mem.alloc (type.zero_val #ptrT)) in
    slice.for_range #ptrT "$range" (λ: "$key" "$value",
      do:  ("u" <-[#ptrT] "$value");;;
>>>>>>> master
      do:  "$key";;;
      let: "next" := (mem.alloc (type.zero_val sliceT)) in
      let: "prev" := (mem.alloc (type.zero_val sliceT)) in
      let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![sliceT] (struct.field_ref ptrT #"MapLabel"%go (![ptrT] "u"))) in
      let: "$a1" := (![sliceT] (struct.field_ref ptrT #"MapVal"%go (![ptrT] "u"))) in
      let: "$a2" := (![sliceT] (struct.field_ref ptrT #"NonMembProof"%go (![ptrT] "u"))) in
      (func_call #merkle.VerifyUpdate) "$a0" "$a1" "$a2") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      let: "$r2" := "$ret2" in
      do:  ("prev" <-[sliceT] "$r0");;;
      do:  ("next" <-[sliceT] "$r1");;;
      do:  ("err" <-[boolT] "$r2");;;
      (if: ![boolT] "err"
      then return: (![sliceT] "dig", ![boolT] "err")
      else do:  #());;;
      (if: (~ (let: "$a0" := (![sliceT] "dig") in
      let: "$a1" := (![sliceT] "prev") in
      (func_call #bytes.Equal) "$a0" "$a1"))
      then
        let: "$r0" := #true in
        do:  ("err" <-[boolT] "$r0");;;
        return: (![sliceT] "dig", ![boolT] "err")
      else do:  #());;;
      let: "$r0" := (![sliceT] "next") in
      do:  ("dig" <-[sliceT] "$r0")));;;
    return: (![sliceT] "dig", ![boolT] "err")).

(* go: auditor.go:146:6 *)
Definition CheckStartⁱᵐᵖˡ : val :=
  λ: "servPk" "reply",
    exception_do (let: "err" := (mem.alloc (type.zero_val #boolT)) in
    let: "vrfPk" := (mem.alloc (type.zero_val #ptrT)) in
    let: "link" := (mem.alloc (type.zero_val #sliceT)) in
    let: "dig" := (mem.alloc (type.zero_val #sliceT)) in
    let: "ep" := (mem.alloc (type.zero_val #uint64T)) in
    let: "reply" := (mem.alloc "reply") in
    let: "servPk" := (mem.alloc "servPk") in
    (if: (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref #server.StartReply #"PrevLink"%go (![#ptrT] "reply"))) in
    slice.len "$a0")) ≠ cryptoffi.HashLen
    then
      let: "$r0" := #true in
      do:  ("err" <-[#boolT] "$r0");;;
      return: (![#uint64T] "ep", ![#sliceT] "dig", ![#sliceT] "link", ![#ptrT] "vrfPk", ![#boolT] "err")
    else do:  #());;;
    let: "errb" := (mem.alloc (type.zero_val #boolT)) in
    let: "extLen" := (mem.alloc (type.zero_val #uint64T)) in
    let: ((("$ret0", "$ret1"), "$ret2"), "$ret3") := (let: "$a0" := (![#sliceT] (struct.field_ref #server.StartReply #"PrevLink"%go (![#ptrT] "reply"))) in
    let: "$a1" := (![#sliceT] (struct.field_ref #server.StartReply #"ChainProof"%go (![#ptrT] "reply"))) in
    (func_call #hashchain.Verify) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    let: "$r3" := "$ret3" in
    do:  ("extLen" <-[#uint64T] "$r0");;;
    do:  ("dig" <-[#sliceT] "$r1");;;
    do:  ("link" <-[#sliceT] "$r2");;;
    do:  ("errb" <-[#boolT] "$r3");;;
    (if: ![#boolT] "errb"
    then
      let: "$r0" := #true in
      do:  ("err" <-[#boolT] "$r0");;;
      return: (![#uint64T] "ep", ![#sliceT] "dig", ![#sliceT] "link", ![#ptrT] "vrfPk", ![#boolT] "err")
    else do:  #());;;
    (if: (![#uint64T] "extLen") = #(W64 0)
    then
      let: "$r0" := #true in
      do:  ("err" <-[#boolT] "$r0");;;
      return: (![#uint64T] "ep", ![#sliceT] "dig", ![#sliceT] "link", ![#ptrT] "vrfPk", ![#boolT] "err")
    else do:  #());;;
    (if: (~ (let: "$a0" := (![#uint64T] (struct.field_ref #server.StartReply #"PrevEpochLen"%go (![#ptrT] "reply"))) in
    let: "$a1" := ((![#uint64T] "extLen") - #(W64 1)) in
    (func_call #std.SumNoOverflow) "$a0" "$a1"))
    then
      let: "$r0" := #true in
      do:  ("err" <-[#boolT] "$r0");;;
      return: (![#uint64T] "ep", ![#sliceT] "dig", ![#sliceT] "link", ![#ptrT] "vrfPk", ![#boolT] "err")
    else do:  #());;;
    let: "$r0" := (((![#uint64T] (struct.field_ref #server.StartReply #"PrevEpochLen"%go (![#ptrT] "reply"))) + (![#uint64T] "extLen")) - #(W64 1)) in
    do:  ("ep" <-[#uint64T] "$r0");;;
    (if: let: "$a0" := (![#cryptoffi.SigPublicKey] "servPk") in
    let: "$a1" := (![#uint64T] "ep") in
    let: "$a2" := (![#sliceT] "link") in
    let: "$a3" := (![#sliceT] (struct.field_ref #server.StartReply #"LinkSig"%go (![#ptrT] "reply"))) in
    (func_call #ktcore.VerifyLinkSig) "$a0" "$a1" "$a2" "$a3"
    then
      let: "$r0" := #true in
      do:  ("err" <-[#boolT] "$r0");;;
      return: (![#uint64T] "ep", ![#sliceT] "dig", ![#sliceT] "link", ![#ptrT] "vrfPk", ![#boolT] "err")
    else do:  #());;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] (struct.field_ref #server.StartReply #"VrfPk"%go (![#ptrT] "reply"))) in
    (func_call #cryptoffi.VrfPublicKeyDecode) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("vrfPk" <-[#ptrT] "$r0");;;
    do:  ("errb" <-[#boolT] "$r1");;;
    (if: ![#boolT] "errb"
    then
      let: "$r0" := #true in
      do:  ("err" <-[#boolT] "$r0");;;
      return: (![#uint64T] "ep", ![#sliceT] "dig", ![#sliceT] "link", ![#ptrT] "vrfPk", ![#boolT] "err")
    else do:  #());;;
    (if: let: "$a0" := (![#cryptoffi.SigPublicKey] "servPk") in
    let: "$a1" := (![#sliceT] (struct.field_ref #server.StartReply #"VrfPk"%go (![#ptrT] "reply"))) in
    let: "$a2" := (![#sliceT] (struct.field_ref #server.StartReply #"VrfSig"%go (![#ptrT] "reply"))) in
    (func_call #ktcore.VerifyVrfSig) "$a0" "$a1" "$a2"
    then
      let: "$r0" := #true in
      do:  ("err" <-[#boolT] "$r0");;;
      return: (![#uint64T] "ep", ![#sliceT] "dig", ![#sliceT] "link", ![#ptrT] "vrfPk", ![#boolT] "err")
    else do:  #());;;
    return: (![#uint64T] "ep", ![#sliceT] "dig", ![#sliceT] "link", ![#ptrT] "vrfPk", ![#boolT] "err")).

Definition UpdateRpc : val := #(W64 0).

Definition GetRpc : val := #(W64 1).

Definition NewRpcAuditor : go_string := "github.com/sanjit-bhat/pav/auditor.NewRpcAuditor"%go.

Definition GetReplyEncode : go_string := "github.com/sanjit-bhat/pav/auditor.GetReplyEncode"%go.

Definition GetArgDecode : go_string := "github.com/sanjit-bhat/pav/auditor.GetArgDecode"%go.

Definition UpdateReplyEncode : go_string := "github.com/sanjit-bhat/pav/auditor.UpdateReplyEncode"%go.

Definition UpdateReply : go_type := structT [
  "Err" :: ktcore.Blame
].
#[global] Typeclasses Opaque UpdateReply.
#[global] Opaque UpdateReply.

(* go: rpc.go:13:6 *)
Definition NewRpcAuditorⁱᵐᵖˡ : val :=
  λ: "adtr",
    exception_do (let: "adtr" := (mem.alloc "adtr") in
    let: "h" := (mem.alloc (type.zero_val (mapT uint64T funcT))) in
    let: "$r0" := (map.make uint64T funcT) in
    do:  ("h" <-[mapT uint64T funcT] "$r0");;;
    let: "$r0" := (λ: "arg" "reply",
      exception_do (let: "reply" := (mem.alloc "reply") in
      let: "arg" := (mem.alloc "arg") in
      let: "r0" := (mem.alloc (type.zero_val ktcore.Blame)) in
      let: "$r0" := ((method_call #(ptrT.id Auditor.id) #"Update"%go (![ptrT] "adtr")) #()) in
      do:  ("r0" <-[ktcore.Blame] "$r0");;;
      let: "replyObj" := (mem.alloc (type.zero_val ptrT)) in
      let: "$r0" := (mem.alloc (let: "$Err" := (![ktcore.Blame] "r0") in
      struct.make UpdateReply [{
        "Err" ::= "$Err"
      }])) in
      do:  ("replyObj" <-[ptrT] "$r0");;;
      let: "$r0" := (let: "$a0" := (![sliceT] (![ptrT] "reply")) in
      let: "$a1" := (![ptrT] "replyObj") in
      (func_call #UpdateReplyEncode) "$a0" "$a1") in
      do:  ((![ptrT] "reply") <-[sliceT] "$r0");;;
      return: #())
      ) in
    do:  (map.insert (![mapT uint64T funcT] "h") UpdateRpc "$r0");;;
    let: "$r0" := (λ: "arg" "reply",
      exception_do (let: "reply" := (mem.alloc "reply") in
      let: "arg" := (mem.alloc "arg") in
      let: "err" := (mem.alloc (type.zero_val boolT)) in
      let: "a" := (mem.alloc (type.zero_val ptrT)) in
      let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![sliceT] "arg") in
      (func_call #GetArgDecode) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      let: "$r2" := "$ret2" in
      do:  ("a" <-[ptrT] "$r0");;;
      do:  "$r1";;;
      do:  ("err" <-[boolT] "$r2");;;
      (if: ![boolT] "err"
      then
        let: "r" := (mem.alloc (type.zero_val ptrT)) in
        let: "$r0" := (mem.alloc (let: "$Err" := ktcore.BlameUnknown in
        struct.make GetReply [{
          "Link" ::= type.zero_val sliceT;
          "ServLinkSig" ::= type.zero_val sliceT;
          "AdtrLinkSig" ::= type.zero_val sliceT;
          "VrfPk" ::= type.zero_val sliceT;
          "ServVrfSig" ::= type.zero_val sliceT;
          "AdtrVrfSig" ::= type.zero_val sliceT;
          "Err" ::= "$Err"
        }])) in
        do:  ("r" <-[ptrT] "$r0");;;
        let: "$r0" := (let: "$a0" := (![sliceT] (![ptrT] "reply")) in
        let: "$a1" := (![ptrT] "r") in
        (func_call #GetReplyEncode) "$a0" "$a1") in
        do:  ((![ptrT] "reply") <-[sliceT] "$r0");;;
        return: (#())
      else do:  #());;;
      let: "r" := (mem.alloc (type.zero_val ptrT)) in
      let: "$r0" := (let: "$a0" := (![uint64T] (struct.field_ref ptrT #"Epoch"%go (![ptrT] "a"))) in
      (method_call #(ptrT.id Auditor.id) #"Get"%go (![ptrT] "adtr")) "$a0") in
      do:  ("r" <-[ptrT] "$r0");;;
      let: "$r0" := (let: "$a0" := (![sliceT] (![ptrT] "reply")) in
      let: "$a1" := (![ptrT] "r") in
      (func_call #GetReplyEncode) "$a0" "$a1") in
      do:  ((![ptrT] "reply") <-[sliceT] "$r0");;;
      return: #())
      ) in
    do:  (map.insert (![mapT uint64T funcT] "h") GetRpc "$r0");;;
    return: (let: "$a0" := (![mapT uint64T funcT] "h") in
     (func_call #advrpc.NewServer) "$a0")).

Definition CallUpdate : go_string := "github.com/sanjit-bhat/pav/auditor.CallUpdate"%go.

Definition UpdateReplyDecode : go_string := "github.com/sanjit-bhat/pav/auditor.UpdateReplyDecode"%go.

(* go: rpc.go:33:6 *)
Definition CallUpdateⁱᵐᵖˡ : val :=
  λ: "c",
    exception_do (let: "err" := (mem.alloc (type.zero_val ktcore.Blame)) in
    let: "c" := (mem.alloc "c") in
    let: "rb" := (mem.alloc (type.zero_val ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val sliceT)) in
    do:  ("rb" <-[ptrT] "$r0");;;
    (if: let: "$a0" := UpdateRpc in
    let: "$a1" := #slice.nil in
    let: "$a2" := (![ptrT] "rb") in
    (method_call #(ptrT.id advrpc.Client.id) #"Call"%go (![ptrT] "c")) "$a0" "$a1" "$a2"
    then return: (ktcore.BlameUnknown)
    else do:  #());;;
    let: "errb" := (mem.alloc (type.zero_val boolT)) in
    let: "r" := (mem.alloc (type.zero_val ptrT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![sliceT] (![ptrT] "rb")) in
    (func_call #UpdateReplyDecode) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("r" <-[ptrT] "$r0");;;
    do:  "$r1";;;
    do:  ("errb" <-[boolT] "$r2");;;
    (if: ![boolT] "errb"
    then return: (ktcore.BlameAdtrFull)
    else do:  #());;;
    (if: let: "$a0" := (![ktcore.Blame] (struct.field_ref ptrT #"Err"%go (![ptrT] "r"))) in
    let: "$a1" := ((let: "$sl0" := ktcore.BlameServFull in
    let: "$sl1" := ktcore.BlameUnknown in
    slice.literal ktcore.Blame ["$sl0"; "$sl1"])) in
    (func_call #ktcore.CheckBlame) "$a0" "$a1"
    then return: (ktcore.BlameAdtrFull)
    else do:  #());;;
    return: (![ktcore.Blame] "err")).

Definition CallGet : go_string := "github.com/sanjit-bhat/pav/auditor.CallGet"%go.

Definition GetReplyDecode : go_string := "github.com/sanjit-bhat/pav/auditor.GetReplyDecode"%go.

Definition GetArgEncode : go_string := "github.com/sanjit-bhat/pav/auditor.GetArgEncode"%go.

Definition GetArg : go_type := structT [
  "Epoch" :: uint64T
].
#[global] Typeclasses Opaque GetArg.
#[global] Opaque GetArg.

(* go: rpc.go:49:6 *)
Definition CallGetⁱᵐᵖˡ : val :=
  λ: "c" "epoch",
    exception_do (let: "epoch" := (mem.alloc "epoch") in
    let: "c" := (mem.alloc "c") in
    let: "a" := (mem.alloc (type.zero_val ptrT)) in
    let: "$r0" := (mem.alloc (let: "$Epoch" := (![uint64T] "epoch") in
    struct.make GetArg [{
      "Epoch" ::= "$Epoch"
    }])) in
    do:  ("a" <-[ptrT] "$r0");;;
    let: "ab" := (mem.alloc (type.zero_val sliceT)) in
    let: "$r0" := (let: "$a0" := #slice.nil in
    let: "$a1" := (![ptrT] "a") in
    (func_call #GetArgEncode) "$a0" "$a1") in
    do:  ("ab" <-[sliceT] "$r0");;;
    let: "rb" := (mem.alloc (type.zero_val ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val sliceT)) in
    do:  ("rb" <-[ptrT] "$r0");;;
    (if: let: "$a0" := GetRpc in
    let: "$a1" := (![sliceT] "ab") in
    let: "$a2" := (![ptrT] "rb") in
    (method_call #(ptrT.id advrpc.Client.id) #"Call"%go (![ptrT] "c")) "$a0" "$a1" "$a2"
    then
      return: (mem.alloc (let: "$Err" := ktcore.BlameUnknown in
       struct.make GetReply [{
         "Link" ::= type.zero_val sliceT;
         "ServLinkSig" ::= type.zero_val sliceT;
         "AdtrLinkSig" ::= type.zero_val sliceT;
         "VrfPk" ::= type.zero_val sliceT;
         "ServVrfSig" ::= type.zero_val sliceT;
         "AdtrVrfSig" ::= type.zero_val sliceT;
         "Err" ::= "$Err"
       }]))
    else do:  #());;;
    let: "errb" := (mem.alloc (type.zero_val boolT)) in
    let: "r" := (mem.alloc (type.zero_val ptrT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![sliceT] (![ptrT] "rb")) in
    (func_call #GetReplyDecode) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("r" <-[ptrT] "$r0");;;
    do:  "$r1";;;
    do:  ("errb" <-[boolT] "$r2");;;
    (if: ![boolT] "errb"
    then
      return: (mem.alloc (let: "$Err" := ktcore.BlameAdtrFull in
       struct.make GetReply [{
         "Link" ::= type.zero_val sliceT;
         "ServLinkSig" ::= type.zero_val sliceT;
         "AdtrLinkSig" ::= type.zero_val sliceT;
         "VrfPk" ::= type.zero_val sliceT;
         "ServVrfSig" ::= type.zero_val sliceT;
         "AdtrVrfSig" ::= type.zero_val sliceT;
         "Err" ::= "$Err"
       }]))
    else do:  #());;;
    (if: let: "$a0" := (![ktcore.Blame] (struct.field_ref ptrT #"Err"%go (![ptrT] "r"))) in
    let: "$a1" := ((let: "$sl0" := ktcore.BlameUnknown in
    slice.literal ktcore.Blame ["$sl0"])) in
    (func_call #ktcore.CheckBlame) "$a0" "$a1"
    then
      return: (mem.alloc (let: "$Err" := ktcore.BlameAdtrFull in
       struct.make GetReply [{
         "Link" ::= type.zero_val sliceT;
         "ServLinkSig" ::= type.zero_val sliceT;
         "AdtrLinkSig" ::= type.zero_val sliceT;
         "VrfPk" ::= type.zero_val sliceT;
         "ServVrfSig" ::= type.zero_val sliceT;
         "AdtrVrfSig" ::= type.zero_val sliceT;
         "Err" ::= "$Err"
       }]))
    else do:  #());;;
    return: (![ptrT] "r")).

(* go: serde.out.go:11:6 *)
Definition UpdateReplyEncodeⁱᵐᵖˡ : val :=
  λ: "b0" "o",
    exception_do (let: "o" := (mem.alloc "o") in
    let: "b0" := (mem.alloc "b0") in
    let: "b" := (mem.alloc (type.zero_val sliceT)) in
    let: "$r0" := (![sliceT] "b0") in
    do:  ("b" <-[sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT] "b") in
    let: "$a1" := (![ktcore.Blame] (struct.field_ref ptrT #"Err"%go (![ptrT] "o"))) in
    (func_call #marshal.WriteInt) "$a0" "$a1") in
    do:  ("b" <-[sliceT] "$r0");;;
    return: (![sliceT] "b")).

(* go: serde.out.go:16:6 *)
Definition UpdateReplyDecodeⁱᵐᵖˡ : val :=
  λ: "b0",
    exception_do (let: "b0" := (mem.alloc "b0") in
    let: "err1" := (mem.alloc (type.zero_val boolT)) in
    let: "b1" := (mem.alloc (type.zero_val sliceT)) in
    let: "a1" := (mem.alloc (type.zero_val uint64T)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![sliceT] "b0") in
    (func_call #safemarshal.ReadInt) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a1" <-[uint64T] "$r0");;;
    do:  ("b1" <-[sliceT] "$r1");;;
    do:  ("err1" <-[boolT] "$r2");;;
    (if: ![boolT] "err1"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    return: (mem.alloc (let: "$Err" := (![uint64T] "a1") in
     struct.make UpdateReply [{
       "Err" ::= "$Err"
     }]), ![sliceT] "b1", #false)).

(* go: serde.out.go:23:6 *)
Definition GetArgEncodeⁱᵐᵖˡ : val :=
  λ: "b0" "o",
    exception_do (let: "o" := (mem.alloc "o") in
    let: "b0" := (mem.alloc "b0") in
    let: "b" := (mem.alloc (type.zero_val sliceT)) in
    let: "$r0" := (![sliceT] "b0") in
    do:  ("b" <-[sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT] "b") in
    let: "$a1" := (![uint64T] (struct.field_ref ptrT #"Epoch"%go (![ptrT] "o"))) in
    (func_call #marshal.WriteInt) "$a0" "$a1") in
    do:  ("b" <-[sliceT] "$r0");;;
    return: (![sliceT] "b")).

(* go: serde.out.go:28:6 *)
Definition GetArgDecodeⁱᵐᵖˡ : val :=
  λ: "b0",
    exception_do (let: "b0" := (mem.alloc "b0") in
    let: "err1" := (mem.alloc (type.zero_val boolT)) in
    let: "b1" := (mem.alloc (type.zero_val sliceT)) in
    let: "a1" := (mem.alloc (type.zero_val uint64T)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![sliceT] "b0") in
    (func_call #safemarshal.ReadInt) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a1" <-[uint64T] "$r0");;;
    do:  ("b1" <-[sliceT] "$r1");;;
    do:  ("err1" <-[boolT] "$r2");;;
    (if: ![boolT] "err1"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    return: (mem.alloc (let: "$Epoch" := (![uint64T] "a1") in
     struct.make GetArg [{
       "Epoch" ::= "$Epoch"
     }]), ![sliceT] "b1", #false)).

(* go: serde.out.go:35:6 *)
Definition GetReplyEncodeⁱᵐᵖˡ : val :=
  λ: "b0" "o",
    exception_do (let: "o" := (mem.alloc "o") in
    let: "b0" := (mem.alloc "b0") in
    let: "b" := (mem.alloc (type.zero_val sliceT)) in
    let: "$r0" := (![sliceT] "b0") in
    do:  ("b" <-[sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT] "b") in
    let: "$a1" := (![sliceT] (struct.field_ref ptrT #"Link"%go (![ptrT] "o"))) in
    (func_call #safemarshal.WriteSlice1D) "$a0" "$a1") in
    do:  ("b" <-[sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT] "b") in
    let: "$a1" := (![sliceT] (struct.field_ref ptrT #"ServLinkSig"%go (![ptrT] "o"))) in
    (func_call #safemarshal.WriteSlice1D) "$a0" "$a1") in
    do:  ("b" <-[sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT] "b") in
    let: "$a1" := (![sliceT] (struct.field_ref ptrT #"AdtrLinkSig"%go (![ptrT] "o"))) in
    (func_call #safemarshal.WriteSlice1D) "$a0" "$a1") in
    do:  ("b" <-[sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT] "b") in
    let: "$a1" := (![sliceT] (struct.field_ref ptrT #"VrfPk"%go (![ptrT] "o"))) in
    (func_call #safemarshal.WriteSlice1D) "$a0" "$a1") in
    do:  ("b" <-[sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT] "b") in
    let: "$a1" := (![sliceT] (struct.field_ref ptrT #"ServVrfSig"%go (![ptrT] "o"))) in
    (func_call #safemarshal.WriteSlice1D) "$a0" "$a1") in
    do:  ("b" <-[sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT] "b") in
    let: "$a1" := (![sliceT] (struct.field_ref ptrT #"AdtrVrfSig"%go (![ptrT] "o"))) in
    (func_call #safemarshal.WriteSlice1D) "$a0" "$a1") in
    do:  ("b" <-[sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT] "b") in
    let: "$a1" := (![ktcore.Blame] (struct.field_ref ptrT #"Err"%go (![ptrT] "o"))) in
    (func_call #marshal.WriteInt) "$a0" "$a1") in
    do:  ("b" <-[sliceT] "$r0");;;
    return: (![sliceT] "b")).

(* go: serde.out.go:46:6 *)
Definition GetReplyDecodeⁱᵐᵖˡ : val :=
  λ: "b0",
    exception_do (let: "b0" := (mem.alloc "b0") in
    let: "err1" := (mem.alloc (type.zero_val boolT)) in
    let: "b1" := (mem.alloc (type.zero_val sliceT)) in
    let: "a1" := (mem.alloc (type.zero_val sliceT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![sliceT] "b0") in
    (func_call #safemarshal.ReadSlice1D) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a1" <-[sliceT] "$r0");;;
    do:  ("b1" <-[sliceT] "$r1");;;
    do:  ("err1" <-[boolT] "$r2");;;
    (if: ![boolT] "err1"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err2" := (mem.alloc (type.zero_val boolT)) in
    let: "b2" := (mem.alloc (type.zero_val sliceT)) in
    let: "a2" := (mem.alloc (type.zero_val sliceT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![sliceT] "b1") in
    (func_call #safemarshal.ReadSlice1D) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a2" <-[sliceT] "$r0");;;
    do:  ("b2" <-[sliceT] "$r1");;;
    do:  ("err2" <-[boolT] "$r2");;;
    (if: ![boolT] "err2"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err3" := (mem.alloc (type.zero_val boolT)) in
    let: "b3" := (mem.alloc (type.zero_val sliceT)) in
    let: "a3" := (mem.alloc (type.zero_val sliceT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![sliceT] "b2") in
    (func_call #safemarshal.ReadSlice1D) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a3" <-[sliceT] "$r0");;;
    do:  ("b3" <-[sliceT] "$r1");;;
    do:  ("err3" <-[boolT] "$r2");;;
    (if: ![boolT] "err3"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err4" := (mem.alloc (type.zero_val boolT)) in
    let: "b4" := (mem.alloc (type.zero_val sliceT)) in
    let: "a4" := (mem.alloc (type.zero_val sliceT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![sliceT] "b3") in
    (func_call #safemarshal.ReadSlice1D) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a4" <-[sliceT] "$r0");;;
    do:  ("b4" <-[sliceT] "$r1");;;
    do:  ("err4" <-[boolT] "$r2");;;
    (if: ![boolT] "err4"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err5" := (mem.alloc (type.zero_val boolT)) in
    let: "b5" := (mem.alloc (type.zero_val sliceT)) in
    let: "a5" := (mem.alloc (type.zero_val sliceT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![sliceT] "b4") in
    (func_call #safemarshal.ReadSlice1D) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a5" <-[sliceT] "$r0");;;
    do:  ("b5" <-[sliceT] "$r1");;;
    do:  ("err5" <-[boolT] "$r2");;;
    (if: ![boolT] "err5"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err6" := (mem.alloc (type.zero_val boolT)) in
    let: "b6" := (mem.alloc (type.zero_val sliceT)) in
    let: "a6" := (mem.alloc (type.zero_val sliceT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![sliceT] "b5") in
    (func_call #safemarshal.ReadSlice1D) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a6" <-[sliceT] "$r0");;;
    do:  ("b6" <-[sliceT] "$r1");;;
    do:  ("err6" <-[boolT] "$r2");;;
    (if: ![boolT] "err6"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err7" := (mem.alloc (type.zero_val boolT)) in
    let: "b7" := (mem.alloc (type.zero_val sliceT)) in
    let: "a7" := (mem.alloc (type.zero_val uint64T)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![sliceT] "b6") in
    (func_call #safemarshal.ReadInt) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a7" <-[uint64T] "$r0");;;
    do:  ("b7" <-[sliceT] "$r1");;;
    do:  ("err7" <-[boolT] "$r2");;;
    (if: ![boolT] "err7"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    return: (mem.alloc (let: "$Link" := (![sliceT] "a1") in
     let: "$ServLinkSig" := (![sliceT] "a2") in
     let: "$AdtrLinkSig" := (![sliceT] "a3") in
     let: "$VrfPk" := (![sliceT] "a4") in
     let: "$ServVrfSig" := (![sliceT] "a5") in
     let: "$AdtrVrfSig" := (![sliceT] "a6") in
     let: "$Err" := (![uint64T] "a7") in
     struct.make GetReply [{
       "Link" ::= "$Link";
       "ServLinkSig" ::= "$ServLinkSig";
       "AdtrLinkSig" ::= "$AdtrLinkSig";
       "VrfPk" ::= "$VrfPk";
       "ServVrfSig" ::= "$ServVrfSig";
       "AdtrVrfSig" ::= "$AdtrVrfSig";
       "Err" ::= "$Err"
     }]), ![sliceT] "b7", #false)).

Definition vars' : list (go_string * go_type) := [].

Definition functions' : list (go_string * val) := [(New, Newⁱᵐᵖˡ); (getNextLink, getNextLinkⁱᵐᵖˡ); (getNextDig, getNextDigⁱᵐᵖˡ); (CheckStart, CheckStartⁱᵐᵖˡ); (NewRpcAuditor, NewRpcAuditorⁱᵐᵖˡ); (CallUpdate, CallUpdateⁱᵐᵖˡ); (CallGet, CallGetⁱᵐᵖˡ); (UpdateReplyEncode, UpdateReplyEncodeⁱᵐᵖˡ); (UpdateReplyDecode, UpdateReplyDecodeⁱᵐᵖˡ); (GetArgEncode, GetArgEncodeⁱᵐᵖˡ); (GetArgDecode, GetArgDecodeⁱᵐᵖˡ); (GetReplyEncode, GetReplyEncodeⁱᵐᵖˡ); (GetReplyDecode, GetReplyDecodeⁱᵐᵖˡ)].

Definition msets' : list (go_string * (list (go_string * val))) := [(Auditor.id, []); (ptrT.id Auditor.id, [("Get"%go, Auditor__Getⁱᵐᵖˡ); ("Update"%go, Auditor__Updateⁱᵐᵖˡ)]); (history.id, []); (ptrT.id history.id, []); (serv.id, []); (ptrT.id serv.id, []); (UpdateReply.id, []); (ptrT.id UpdateReply.id, []); (GetArg.id, []); (ptrT.id GetArg.id, []); (GetReply.id, []); (ptrT.id GetReply.id, [])].

#[global] Instance info' : PkgInfo auditor.auditor :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [code.bytes.bytes; code.sync.sync; code.github_com.goose_lang.std.std; code.github_com.sanjit_bhat.pav.advrpc.advrpc; code.github_com.sanjit_bhat.pav.cryptoffi.cryptoffi; code.github_com.sanjit_bhat.pav.hashchain.hashchain; code.github_com.sanjit_bhat.pav.ktcore.ktcore; code.github_com.sanjit_bhat.pav.merkle.merkle; code.github_com.sanjit_bhat.pav.server.server; code.github_com.sanjit_bhat.pav.safemarshal.safemarshal; code.github_com.tchajed.marshal.marshal];
  |}.

Definition initialize' : val :=
  λ: <>,
    package.init #auditor.auditor (λ: <>,
      exception_do (do:  (marshal.initialize' #());;;
      do:  (safemarshal.initialize' #());;;
      do:  (server.initialize' #());;;
      do:  (merkle.initialize' #());;;
      do:  (ktcore.initialize' #());;;
      do:  (hashchain.initialize' #());;;
      do:  (cryptoffi.initialize' #());;;
      do:  (advrpc.initialize' #());;;
      do:  (std.initialize' #());;;
      do:  (sync.initialize' #());;;
      do:  (bytes.initialize' #());;;
      do:  (package.alloc auditor.auditor #()))
      ).

End code.
End auditor.
