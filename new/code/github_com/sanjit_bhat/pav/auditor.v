(* autogenerated from github.com/sanjit-bhat/pav/auditor *)
Require Export New.code.bytes.
Require Export New.code.github_com.goose_lang.std.
Require Export New.code.github_com.sanjit_bhat.pav.advrpc.
Require Export New.code.github_com.sanjit_bhat.pav.cryptoffi.
Require Export New.code.github_com.sanjit_bhat.pav.hashchain.
Require Export New.code.github_com.sanjit_bhat.pav.ktcore.
Require Export New.code.github_com.sanjit_bhat.pav.merkle.
Require Export New.code.github_com.sanjit_bhat.pav.safemarshal.
Require Export New.code.github_com.sanjit_bhat.pav.server.
Require Export New.code.github_com.tchajed.marshal.
Require Export New.code.sync.

From New.golang Require Import defn.
Definition auditor : go_string := "github.com/sanjit-bhat/pav/auditor".

Module auditor.

Section code.
Context `{ffi_syntax}.


Definition history : go.type := go.Named "github.com/sanjit-bhat/pav/auditor.history"%go [].

Definition serv : go.type := go.Named "github.com/sanjit-bhat/pav/auditor.serv"%go [].

Definition Auditorⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "mu"%go (go.PointerType sync.RWMutex));
  (go.FieldDecl "sk"%go (go.PointerType cryptoffi.SigPrivateKey));
  (go.FieldDecl "lastDig"%go (go.SliceType go.byte));
  (go.FieldDecl "startEp"%go go.uint64);
  (go.FieldDecl "hist"%go (go.SliceType (go.PointerType history)));
  (go.FieldDecl "serv"%go (go.PointerType serv))
].

Definition historyⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "link"%go (go.SliceType go.byte));
  (go.FieldDecl "servSig"%go (go.SliceType go.byte));
  (go.FieldDecl "adtrSig"%go (go.SliceType go.byte))
].

Definition servⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "cli"%go (go.PointerType advrpc.Client));
  (go.FieldDecl "sigPk"%go cryptoffi.SigPublicKey);
  (go.FieldDecl "vrfPk"%go (go.SliceType go.byte));
  (go.FieldDecl "servVrfSig"%go (go.SliceType go.byte));
  (go.FieldDecl "adtrVrfSig"%go (go.SliceType go.byte))
].

Definition Auditor : go.type := go.Named "github.com/sanjit-bhat/pav/auditor.Auditor"%go [].

Definition getNextLink : go_string := "github.com/sanjit-bhat/pav/auditor.getNextLink"%go.

(* Update queries server for a new epoch update and applies it.

   go: auditor.go:44:19 *)
Definition Auditor__Updateⁱᵐᵖˡ : val :=
  λ: "a" <>,
    with_defer: (let: "err" := (GoAlloc ktcore.Blame #()) in
    let: "a" := (go.AllocValue (go.PointerType Auditor) "a") in
    do:  ((MethodResolve (go.PointerType sync.RWMutex) Lock #() (![go.PointerType sync.RWMutex] (StructFieldRef Auditor "mu"%go (![go.PointerType Auditor] "a")))) #());;;
    do:  (let: "$f" := (MethodResolve (go.PointerType sync.RWMutex) Unlock #() (![go.PointerType sync.RWMutex] (StructFieldRef Auditor "mu"%go (![go.PointerType Auditor] "a")))) in
    "$defer" <-[deferType] (let: "$oldf" := (![deferType] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    let: "prevEp" := (GoAlloc go.uint64 #()) in
    let: "$r0" := (((![go.uint64] (StructFieldRef Auditor "startEp"%go (![go.PointerType Auditor] "a"))) +⟨go.uint64⟩ (s_to_w64 (let: "$a0" := (![go.SliceType (go.PointerType history)] (StructFieldRef Auditor "hist"%go (![go.PointerType Auditor] "a"))) in
    (FuncResolve go.len [go.SliceType (go.PointerType history)] #()) "$a0"))) -⟨go.uint64⟩ #(W64 1)) in
    do:  ("prevEp" <-[go.uint64] "$r0");;;
    let: "upd" := (GoAlloc (go.SliceType (go.PointerType ktcore.AuditProof)) #()) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.PointerType advrpc.Client] (StructFieldRef serv "cli"%go (![go.PointerType serv] (StructFieldRef Auditor "serv"%go (![go.PointerType Auditor] "a"))))) in
    let: "$a1" := (![go.uint64] "prevEp") in
    (FuncResolve server.CallAudit [] #()) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("upd" <-[go.SliceType (go.PointerType ktcore.AuditProof)] "$r0");;;
    do:  ("err" <-[ktcore.Blame] "$r1");;;
    (if: (![ktcore.Blame] "err") ≠⟨go.uint64⟩ ktcore.BlameNone
    then return: (![ktcore.Blame] "err")
    else do:  #());;;
    let: "$range" := (![go.SliceType (go.PointerType ktcore.AuditProof)] "upd") in
    (let: "p" := (GoAlloc (go.PointerType ktcore.AuditProof) #()) in
    slice.for_range (go.PointerType ktcore.AuditProof) "$range" (λ: "$key" "$value",
      do:  ("p" <-[go.PointerType ktcore.AuditProof] "$value");;;
      do:  "$key";;;
      let: "sigPk" := (GoAlloc cryptoffi.SigPublicKey #()) in
      let: "$r0" := (![cryptoffi.SigPublicKey] (StructFieldRef serv "sigPk"%go (![go.PointerType serv] (StructFieldRef Auditor "serv"%go (![go.PointerType Auditor] "a"))))) in
      do:  ("sigPk" <-[cryptoffi.SigPublicKey] "$r0");;;
      let: "prevEp" := (GoAlloc go.uint64 #()) in
      let: "$r0" := (((![go.uint64] (StructFieldRef Auditor "startEp"%go (![go.PointerType Auditor] "a"))) +⟨go.uint64⟩ (s_to_w64 (let: "$a0" := (![go.SliceType (go.PointerType history)] (StructFieldRef Auditor "hist"%go (![go.PointerType Auditor] "a"))) in
      (FuncResolve go.len [go.SliceType (go.PointerType history)] #()) "$a0"))) -⟨go.uint64⟩ #(W64 1)) in
      do:  ("prevEp" <-[go.uint64] "$r0");;;
      let: "prevLink" := (GoAlloc (go.SliceType go.byte) #()) in
      let: "$r0" := (![go.SliceType go.byte] (StructFieldRef history "link"%go (![go.PointerType history] (slice.elem_ref (go.PointerType history) (![go.SliceType (go.PointerType history)] (StructFieldRef Auditor "hist"%go (![go.PointerType Auditor] "a"))) ((let: "$a0" := (![go.SliceType (go.PointerType history)] (StructFieldRef Auditor "hist"%go (![go.PointerType Auditor] "a"))) in
      (FuncResolve go.len [go.SliceType (go.PointerType history)] #()) "$a0") -⟨go.int⟩ #(W64 1)))))) in
      do:  ("prevLink" <-[go.SliceType go.byte] "$r0");;;
      let: "errb" := (GoAlloc go.bool #()) in
      let: "link" := (GoAlloc (go.SliceType go.byte) #()) in
      let: "dig" := (GoAlloc (go.SliceType go.byte) #()) in
      let: "ep" := (GoAlloc go.uint64 #()) in
      let: ((("$ret0", "$ret1"), "$ret2"), "$ret3") := (let: "$a0" := (![cryptoffi.SigPublicKey] "sigPk") in
      let: "$a1" := (![go.uint64] "prevEp") in
      let: "$a2" := (![go.SliceType go.byte] (StructFieldRef Auditor "lastDig"%go (![go.PointerType Auditor] "a"))) in
      let: "$a3" := (![go.SliceType go.byte] "prevLink") in
      let: "$a4" := (![go.PointerType ktcore.AuditProof] "p") in
      (FuncResolve getNextLink [] #()) "$a0" "$a1" "$a2" "$a3" "$a4") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      let: "$r2" := "$ret2" in
      let: "$r3" := "$ret3" in
      do:  ("ep" <-[go.uint64] "$r0");;;
      do:  ("dig" <-[go.SliceType go.byte] "$r1");;;
      do:  ("link" <-[go.SliceType go.byte] "$r2");;;
      do:  ("errb" <-[go.bool] "$r3");;;
      (if: ![go.bool] "errb"
      then
        let: "$r0" := ktcore.BlameServFull in
        do:  ("err" <-[ktcore.Blame] "$r0");;;
        return: (![ktcore.Blame] "err")
      else do:  #());;;
      let: "sig" := (GoAlloc (go.SliceType go.byte) #()) in
      let: "$r0" := (let: "$a0" := (![go.PointerType cryptoffi.SigPrivateKey] (StructFieldRef Auditor "sk"%go (![go.PointerType Auditor] "a"))) in
      let: "$a1" := (![go.uint64] "ep") in
      let: "$a2" := (![go.SliceType go.byte] "link") in
      (FuncResolve ktcore.SignLink [] #()) "$a0" "$a1" "$a2") in
      do:  ("sig" <-[go.SliceType go.byte] "$r0");;;
      let: "$r0" := (![go.SliceType go.byte] "dig") in
      do:  ((StructFieldRef Auditor "lastDig"%go (![go.PointerType Auditor] "a")) <-[go.SliceType go.byte] "$r0");;;
      let: "info" := (GoAlloc (go.PointerType history) #()) in
      let: "$r0" := (go.AllocValue history (let: "$link" := (![go.SliceType go.byte] "link") in
      let: "$servSig" := (![go.SliceType go.byte] (StructFieldRef ktcore.AuditProof "LinkSig"%go (![go.PointerType ktcore.AuditProof] "p"))) in
      let: "$adtrSig" := (![go.SliceType go.byte] "sig") in
      CompositeLiteral history (
        let: "$$vs" := go.StructElementListNil #() in 
        let: "$$vs" := go.ElementListApp "$$vs" "$link" in
        let: "$$vs" := go.ElementListApp "$$vs" "$servSig" in
        let: "$$vs" := go.ElementListApp "$$vs" "$adtrSig" in
        "$$vs"
      ))) in
      do:  ("info" <-[go.PointerType history] "$r0");;;
      let: "$r0" := (let: "$a0" := (![go.SliceType (go.PointerType history)] (StructFieldRef Auditor "hist"%go (![go.PointerType Auditor] "a"))) in
      let: "$a1" := ((let: "$sl0" := (![go.PointerType history] "info") in
      CompositeLiteral (go.PointerType history) (go.PointerType history) ["$sl0"])) in
      (FuncResolve go.append [go.SliceType (go.PointerType history)] #()) "$a0" "$a1") in
      do:  ((StructFieldRef Auditor "hist"%go (![go.PointerType Auditor] "a")) <-[go.SliceType (go.PointerType history)] "$r0")));;;
    return: (![ktcore.Blame] "err")).

Definition SignedLink : go.type := go.Named "github.com/sanjit-bhat/pav/auditor.SignedLink"%go [].

Definition SignedVrf : go.type := go.Named "github.com/sanjit-bhat/pav/auditor.SignedVrf"%go [].

(* Get returns the auditor's info for a particular epoch.
   it errors if the epoch is out of bounds.

   go: auditor.go:74:19 *)
Definition Auditor__Getⁱᵐᵖˡ : val :=
  λ: "a" "epoch",
    with_defer: (let: "err" := (GoAlloc go.bool #()) in
    let: "vrf" := (GoAlloc (go.PointerType SignedVrf) #()) in
    let: "link" := (GoAlloc (go.PointerType SignedLink) #()) in
    let: "a" := (go.AllocValue (go.PointerType Auditor) "a") in
    let: "epoch" := (go.AllocValue go.uint64 "epoch") in
    do:  ((MethodResolve (go.PointerType sync.RWMutex) RLock #() (![go.PointerType sync.RWMutex] (StructFieldRef Auditor "mu"%go (![go.PointerType Auditor] "a")))) #());;;
    do:  (let: "$f" := (MethodResolve (go.PointerType sync.RWMutex) RUnlock #() (![go.PointerType sync.RWMutex] (StructFieldRef Auditor "mu"%go (![go.PointerType Auditor] "a")))) in
    "$defer" <-[deferType] (let: "$oldf" := (![deferType] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    (if: (![go.uint64] "epoch") <⟨go.uint64⟩ (![go.uint64] (StructFieldRef Auditor "startEp"%go (![go.PointerType Auditor] "a")))
    then
      let: "$r0" := #true in
      do:  ("err" <-[go.bool] "$r0");;;
      return: (![go.PointerType SignedLink] "link", ![go.PointerType SignedVrf] "vrf", ![go.bool] "err")
    else do:  #());;;
    let: "lastEp" := (GoAlloc go.uint64 #()) in
    let: "$r0" := (((![go.uint64] (StructFieldRef Auditor "startEp"%go (![go.PointerType Auditor] "a"))) +⟨go.uint64⟩ (s_to_w64 (let: "$a0" := (![go.SliceType (go.PointerType history)] (StructFieldRef Auditor "hist"%go (![go.PointerType Auditor] "a"))) in
    (FuncResolve go.len [go.SliceType (go.PointerType history)] #()) "$a0"))) -⟨go.uint64⟩ #(W64 1)) in
    do:  ("lastEp" <-[go.uint64] "$r0");;;
    (if: (![go.uint64] "epoch") >⟨go.uint64⟩ (![go.uint64] "lastEp")
    then
      let: "$r0" := #true in
      do:  ("err" <-[go.bool] "$r0");;;
      return: (![go.PointerType SignedLink] "link", ![go.PointerType SignedVrf] "vrf", ![go.bool] "err")
    else do:  #());;;
    let: "x" := (GoAlloc (go.PointerType history) #()) in
    let: "$r0" := (![go.PointerType history] (slice.elem_ref (go.PointerType history) (![go.SliceType (go.PointerType history)] (StructFieldRef Auditor "hist"%go (![go.PointerType Auditor] "a"))) ((![go.uint64] "epoch") -⟨go.uint64⟩ (![go.uint64] (StructFieldRef Auditor "startEp"%go (![go.PointerType Auditor] "a")))))) in
    do:  ("x" <-[go.PointerType history] "$r0");;;
    let: "$r0" := (go.AllocValue SignedLink (let: "$Link" := (![go.SliceType go.byte] (StructFieldRef history "link"%go (![go.PointerType history] "x"))) in
    let: "$ServSig" := (![go.SliceType go.byte] (StructFieldRef history "servSig"%go (![go.PointerType history] "x"))) in
    let: "$AdtrSig" := (![go.SliceType go.byte] (StructFieldRef history "adtrSig"%go (![go.PointerType history] "x"))) in
    CompositeLiteral SignedLink (
      let: "$$vs" := go.StructElementListNil #() in 
      let: "$$vs" := go.ElementListApp "$$vs" "$Link" in
      let: "$$vs" := go.ElementListApp "$$vs" "$ServSig" in
      let: "$$vs" := go.ElementListApp "$$vs" "$AdtrSig" in
      "$$vs"
    ))) in
    do:  ("link" <-[go.PointerType SignedLink] "$r0");;;
    let: "$r0" := (go.AllocValue SignedVrf (let: "$VrfPk" := (![go.SliceType go.byte] (StructFieldRef serv "vrfPk"%go (![go.PointerType serv] (StructFieldRef Auditor "serv"%go (![go.PointerType Auditor] "a"))))) in
    let: "$ServSig" := (![go.SliceType go.byte] (StructFieldRef serv "servVrfSig"%go (![go.PointerType serv] (StructFieldRef Auditor "serv"%go (![go.PointerType Auditor] "a"))))) in
    let: "$AdtrSig" := (![go.SliceType go.byte] (StructFieldRef serv "adtrVrfSig"%go (![go.PointerType serv] (StructFieldRef Auditor "serv"%go (![go.PointerType Auditor] "a"))))) in
    CompositeLiteral SignedVrf (
      let: "$$vs" := go.StructElementListNil #() in 
      let: "$$vs" := go.ElementListApp "$$vs" "$VrfPk" in
      let: "$$vs" := go.ElementListApp "$$vs" "$ServSig" in
      let: "$$vs" := go.ElementListApp "$$vs" "$AdtrSig" in
      "$$vs"
    ))) in
    do:  ("vrf" <-[go.PointerType SignedVrf] "$r0");;;
    return: (![go.PointerType SignedLink] "link", ![go.PointerType SignedVrf] "vrf", ![go.bool] "err")).

Definition New : go_string := "github.com/sanjit-bhat/pav/auditor.New"%go.

Definition CheckStartVrf : go_string := "github.com/sanjit-bhat/pav/auditor.CheckStartVrf"%go.

Definition CheckStartChain : go_string := "github.com/sanjit-bhat/pav/auditor.CheckStartChain"%go.

(* go: auditor.go:95:6 *)
Definition Newⁱᵐᵖˡ : val :=
  λ: "servAddr" "servPk",
    exception_do (let: "err" := (GoAlloc ktcore.Blame #()) in
    let: "sigPk" := (GoAlloc cryptoffi.SigPublicKey #()) in
    let: "a" := (GoAlloc (go.PointerType Auditor) #()) in
    let: "servPk" := (go.AllocValue cryptoffi.SigPublicKey "servPk") in
    let: "servAddr" := (go.AllocValue go.uint64 "servAddr") in
    let: "cli" := (GoAlloc (go.PointerType advrpc.Client) #()) in
    let: "$r0" := (let: "$a0" := (![go.uint64] "servAddr") in
    (FuncResolve advrpc.Dial [] #()) "$a0") in
    do:  ("cli" <-[go.PointerType advrpc.Client] "$r0");;;
    let: "vrf" := (GoAlloc (go.PointerType server.StartVrf) #()) in
    let: "chain" := (GoAlloc (go.PointerType server.StartChain) #()) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.PointerType advrpc.Client] "cli") in
    (FuncResolve server.CallStart [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("chain" <-[go.PointerType server.StartChain] "$r0");;;
    do:  ("vrf" <-[go.PointerType server.StartVrf] "$r1");;;
    do:  ("err" <-[ktcore.Blame] "$r2");;;
    (if: (![ktcore.Blame] "err") ≠⟨go.uint64⟩ ktcore.BlameNone
    then return: (![go.PointerType Auditor] "a", ![cryptoffi.SigPublicKey] "sigPk", ![ktcore.Blame] "err")
    else do:  #());;;
    let: "errb" := (GoAlloc go.bool #()) in
    let: "startLink" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "startDig" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "startEp" := (GoAlloc go.uint64 #()) in
    let: ((("$ret0", "$ret1"), "$ret2"), "$ret3") := (let: "$a0" := (![cryptoffi.SigPublicKey] "servPk") in
    let: "$a1" := (![go.PointerType server.StartChain] "chain") in
    (FuncResolve CheckStartChain [] #()) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    let: "$r3" := "$ret3" in
    do:  ("startEp" <-[go.uint64] "$r0");;;
    do:  ("startDig" <-[go.SliceType go.byte] "$r1");;;
    do:  ("startLink" <-[go.SliceType go.byte] "$r2");;;
    do:  ("errb" <-[go.bool] "$r3");;;
    (if: ![go.bool] "errb"
    then
      let: "$r0" := ktcore.BlameServFull in
      do:  ("err" <-[ktcore.Blame] "$r0");;;
      return: (![go.PointerType Auditor] "a", ![cryptoffi.SigPublicKey] "sigPk", ![ktcore.Blame] "err")
    else do:  #());;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![cryptoffi.SigPublicKey] "servPk") in
    let: "$a1" := (![go.PointerType server.StartVrf] "vrf") in
    (FuncResolve CheckStartVrf [] #()) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  "$r0";;;
    do:  ("errb" <-[go.bool] "$r1");;;
    (if: ![go.bool] "errb"
    then
      let: "$r0" := ktcore.BlameServFull in
      do:  ("err" <-[ktcore.Blame] "$r0");;;
      return: (![go.PointerType Auditor] "a", ![cryptoffi.SigPublicKey] "sigPk", ![ktcore.Blame] "err")
    else do:  #());;;
    let: "mu" := (GoAlloc (go.PointerType sync.RWMutex) #()) in
    let: "$r0" := (GoAlloc sync.RWMutex #()) in
    do:  ("mu" <-[go.PointerType sync.RWMutex] "$r0");;;
    let: "sk" := (GoAlloc (go.PointerType cryptoffi.SigPrivateKey) #()) in
    let: ("$ret0", "$ret1") := ((FuncResolve cryptoffi.SigGenerateKey [] #()) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("sigPk" <-[cryptoffi.SigPublicKey] "$r0");;;
    do:  ("sk" <-[go.PointerType cryptoffi.SigPrivateKey] "$r1");;;
    let: "linkSig" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := (let: "$a0" := (![go.PointerType cryptoffi.SigPrivateKey] "sk") in
    let: "$a1" := (![go.uint64] "startEp") in
    let: "$a2" := (![go.SliceType go.byte] "startLink") in
    (FuncResolve ktcore.SignLink [] #()) "$a0" "$a1" "$a2") in
    do:  ("linkSig" <-[go.SliceType go.byte] "$r0");;;
    let: "h" := (GoAlloc (go.PointerType history) #()) in
    let: "$r0" := (go.AllocValue history (let: "$link" := (![go.SliceType go.byte] "startLink") in
    let: "$servSig" := (![go.SliceType go.byte] (StructFieldRef server.StartChain "LinkSig"%go (![go.PointerType server.StartChain] "chain"))) in
    let: "$adtrSig" := (![go.SliceType go.byte] "linkSig") in
    CompositeLiteral history (
      let: "$$vs" := go.StructElementListNil #() in 
      let: "$$vs" := go.ElementListApp "$$vs" "$link" in
      let: "$$vs" := go.ElementListApp "$$vs" "$servSig" in
      let: "$$vs" := go.ElementListApp "$$vs" "$adtrSig" in
      "$$vs"
    ))) in
    do:  ("h" <-[go.PointerType history] "$r0");;;
    let: "vrfSig" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := (let: "$a0" := (![go.PointerType cryptoffi.SigPrivateKey] "sk") in
    let: "$a1" := (![go.SliceType go.byte] (StructFieldRef server.StartVrf "VrfPk"%go (![go.PointerType server.StartVrf] "vrf"))) in
    (FuncResolve ktcore.SignVrf [] #()) "$a0" "$a1") in
    do:  ("vrfSig" <-[go.SliceType go.byte] "$r0");;;
    let: "serv" := (GoAlloc (go.PointerType serv) #()) in
    let: "$r0" := (go.AllocValue serv (let: "$cli" := (![go.PointerType advrpc.Client] "cli") in
    let: "$sigPk" := (![cryptoffi.SigPublicKey] "servPk") in
    let: "$vrfPk" := (![go.SliceType go.byte] (StructFieldRef server.StartVrf "VrfPk"%go (![go.PointerType server.StartVrf] "vrf"))) in
    let: "$servVrfSig" := (![go.SliceType go.byte] (StructFieldRef server.StartVrf "VrfSig"%go (![go.PointerType server.StartVrf] "vrf"))) in
    let: "$adtrVrfSig" := (![go.SliceType go.byte] "vrfSig") in
    CompositeLiteral serv (
      let: "$$vs" := go.StructElementListNil #() in 
      let: "$$vs" := go.ElementListApp "$$vs" "$cli" in
      let: "$$vs" := go.ElementListApp "$$vs" "$sigPk" in
      let: "$$vs" := go.ElementListApp "$$vs" "$vrfPk" in
      let: "$$vs" := go.ElementListApp "$$vs" "$servVrfSig" in
      let: "$$vs" := go.ElementListApp "$$vs" "$adtrVrfSig" in
      "$$vs"
    ))) in
    do:  ("serv" <-[go.PointerType serv] "$r0");;;
    let: "$r0" := (go.AllocValue Auditor (let: "$mu" := (![go.PointerType sync.RWMutex] "mu") in
    let: "$sk" := (![go.PointerType cryptoffi.SigPrivateKey] "sk") in
    let: "$lastDig" := (![go.SliceType go.byte] "startDig") in
    let: "$startEp" := (![go.uint64] "startEp") in
    let: "$hist" := ((let: "$sl0" := (![go.PointerType history] "h") in
    CompositeLiteral (go.PointerType history) (go.PointerType history) ["$sl0"])) in
    let: "$serv" := (![go.PointerType serv] "serv") in
    CompositeLiteral Auditor (
      let: "$$vs" := go.StructElementListNil #() in 
      let: "$$vs" := go.ElementListApp "$$vs" "$mu" in
      let: "$$vs" := go.ElementListApp "$$vs" "$sk" in
      let: "$$vs" := go.ElementListApp "$$vs" "$lastDig" in
      let: "$$vs" := go.ElementListApp "$$vs" "$startEp" in
      let: "$$vs" := go.ElementListApp "$$vs" "$hist" in
      let: "$$vs" := go.ElementListApp "$$vs" "$serv" in
      "$$vs"
    ))) in
    do:  ("a" <-[go.PointerType Auditor] "$r0");;;
    return: (![go.PointerType Auditor] "a", ![cryptoffi.SigPublicKey] "sigPk", ![ktcore.Blame] "err")).

Definition getNextDig : go_string := "github.com/sanjit-bhat/pav/auditor.getNextDig"%go.

(* go: auditor.go:122:6 *)
Definition getNextLinkⁱᵐᵖˡ : val :=
  λ: "sigPk" "prevEp" "prevDig" "prevLink" "p",
    exception_do (let: "err" := (GoAlloc go.bool #()) in
    let: "link" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "dig" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "ep" := (GoAlloc go.uint64 #()) in
    let: "p" := (go.AllocValue (go.PointerType ktcore.AuditProof) "p") in
    let: "prevLink" := (go.AllocValue (go.SliceType go.byte) "prevLink") in
    let: "prevDig" := (go.AllocValue (go.SliceType go.byte) "prevDig") in
    let: "prevEp" := (go.AllocValue go.uint64 "prevEp") in
    let: "sigPk" := (go.AllocValue cryptoffi.SigPublicKey "sigPk") in
    (if: (~ (let: "$a0" := (![go.uint64] "prevEp") in
    let: "$a1" := #(W64 1) in
    (FuncResolve std.SumNoOverflow [] #()) "$a0" "$a1"))
    then
      let: "$r0" := #true in
      do:  ("err" <-[go.bool] "$r0");;;
      return: (![go.uint64] "ep", ![go.SliceType go.byte] "dig", ![go.SliceType go.byte] "link", ![go.bool] "err")
    else do:  #());;;
    let: "$r0" := ((![go.uint64] "prevEp") +⟨go.uint64⟩ #(W64 1)) in
    do:  ("ep" <-[go.uint64] "$r0");;;
    (let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] "prevDig") in
    let: "$a1" := (![go.SliceType (go.PointerType ktcore.UpdateProof)] (StructFieldRef ktcore.AuditProof "Updates"%go (![go.PointerType ktcore.AuditProof] "p"))) in
    (FuncResolve getNextDig [] #()) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("dig" <-[go.SliceType go.byte] "$r0");;;
    do:  ("err" <-[go.bool] "$r1");;;
    (if: ![go.bool] "err"
    then return: (![go.uint64] "ep", ![go.SliceType go.byte] "dig", ![go.SliceType go.byte] "link", ![go.bool] "err")
    else do:  #()));;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "prevLink") in
    let: "$a1" := (![go.SliceType go.byte] "dig") in
    (FuncResolve hashchain.GetNextLink [] #()) "$a0" "$a1") in
    do:  ("link" <-[go.SliceType go.byte] "$r0");;;
    (if: let: "$a0" := (![cryptoffi.SigPublicKey] "sigPk") in
    let: "$a1" := (![go.uint64] "ep") in
    let: "$a2" := (![go.SliceType go.byte] "link") in
    let: "$a3" := (![go.SliceType go.byte] (StructFieldRef ktcore.AuditProof "LinkSig"%go (![go.PointerType ktcore.AuditProof] "p"))) in
    (FuncResolve ktcore.VerifyLinkSig [] #()) "$a0" "$a1" "$a2" "$a3"
    then
      let: "$r0" := #true in
      do:  ("err" <-[go.bool] "$r0");;;
      return: (![go.uint64] "ep", ![go.SliceType go.byte] "dig", ![go.SliceType go.byte] "link", ![go.bool] "err")
    else do:  #());;;
    return: (![go.uint64] "ep", ![go.SliceType go.byte] "dig", ![go.SliceType go.byte] "link", ![go.bool] "err")).

(* go: auditor.go:139:6 *)
Definition getNextDigⁱᵐᵖˡ : val :=
  λ: "prevDig" "updates",
    exception_do (let: "err" := (GoAlloc go.bool #()) in
    let: "dig" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "updates" := (go.AllocValue (go.SliceType (go.PointerType ktcore.UpdateProof)) "updates") in
    let: "prevDig" := (go.AllocValue (go.SliceType go.byte) "prevDig") in
    let: "$r0" := (![go.SliceType go.byte] "prevDig") in
    do:  ("dig" <-[go.SliceType go.byte] "$r0");;;
    let: "$range" := (![go.SliceType (go.PointerType ktcore.UpdateProof)] "updates") in
    (let: "u" := (GoAlloc (go.PointerType ktcore.UpdateProof) #()) in
    slice.for_range (go.PointerType ktcore.UpdateProof) "$range" (λ: "$key" "$value",
      do:  ("u" <-[go.PointerType ktcore.UpdateProof] "$value");;;
      do:  "$key";;;
      let: "next" := (GoAlloc (go.SliceType go.byte) #()) in
      let: "prev" := (GoAlloc (go.SliceType go.byte) #()) in
      let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] (StructFieldRef ktcore.UpdateProof "MapLabel"%go (![go.PointerType ktcore.UpdateProof] "u"))) in
      let: "$a1" := (![go.SliceType go.byte] (StructFieldRef ktcore.UpdateProof "MapVal"%go (![go.PointerType ktcore.UpdateProof] "u"))) in
      let: "$a2" := (![go.SliceType go.byte] (StructFieldRef ktcore.UpdateProof "NonMembProof"%go (![go.PointerType ktcore.UpdateProof] "u"))) in
      (FuncResolve merkle.VerifyUpdate [] #()) "$a0" "$a1" "$a2") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      let: "$r2" := "$ret2" in
      do:  ("prev" <-[go.SliceType go.byte] "$r0");;;
      do:  ("next" <-[go.SliceType go.byte] "$r1");;;
      do:  ("err" <-[go.bool] "$r2");;;
      (if: ![go.bool] "err"
      then return: (![go.SliceType go.byte] "dig", ![go.bool] "err")
      else do:  #());;;
      (if: (~ (let: "$a0" := (![go.SliceType go.byte] "dig") in
      let: "$a1" := (![go.SliceType go.byte] "prev") in
      (FuncResolve bytes.Equal [] #()) "$a0" "$a1"))
      then
        let: "$r0" := #true in
        do:  ("err" <-[go.bool] "$r0");;;
        return: (![go.SliceType go.byte] "dig", ![go.bool] "err")
      else do:  #());;;
      let: "$r0" := (![go.SliceType go.byte] "next") in
      do:  ("dig" <-[go.SliceType go.byte] "$r0")));;;
    return: (![go.SliceType go.byte] "dig", ![go.bool] "err")).

(* go: auditor.go:156:6 *)
Definition CheckStartChainⁱᵐᵖˡ : val :=
  λ: "servPk" "chain",
    exception_do (let: "err" := (GoAlloc go.bool #()) in
    let: "link" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "dig" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "ep" := (GoAlloc go.uint64 #()) in
    let: "chain" := (go.AllocValue (go.PointerType server.StartChain) "chain") in
    let: "servPk" := (go.AllocValue cryptoffi.SigPublicKey "servPk") in
    (if: (s_to_w64 (let: "$a0" := (![go.SliceType go.byte] (StructFieldRef server.StartChain "PrevLink"%go (![go.PointerType server.StartChain] "chain"))) in
    (FuncResolve go.len [go.SliceType go.byte] #()) "$a0")) ≠⟨go.uint64⟩ cryptoffi.HashLen
    then
      let: "$r0" := #true in
      do:  ("err" <-[go.bool] "$r0");;;
      return: (![go.uint64] "ep", ![go.SliceType go.byte] "dig", ![go.SliceType go.byte] "link", ![go.bool] "err")
    else do:  #());;;
    let: "errb" := (GoAlloc go.bool #()) in
    let: "extLen" := (GoAlloc go.uint64 #()) in
    let: ((("$ret0", "$ret1"), "$ret2"), "$ret3") := (let: "$a0" := (![go.SliceType go.byte] (StructFieldRef server.StartChain "PrevLink"%go (![go.PointerType server.StartChain] "chain"))) in
    let: "$a1" := (![go.SliceType go.byte] (StructFieldRef server.StartChain "ChainProof"%go (![go.PointerType server.StartChain] "chain"))) in
    (FuncResolve hashchain.Verify [] #()) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    let: "$r3" := "$ret3" in
    do:  ("extLen" <-[go.uint64] "$r0");;;
    do:  ("dig" <-[go.SliceType go.byte] "$r1");;;
    do:  ("link" <-[go.SliceType go.byte] "$r2");;;
    do:  ("errb" <-[go.bool] "$r3");;;
    (if: ![go.bool] "errb"
    then
      let: "$r0" := #true in
      do:  ("err" <-[go.bool] "$r0");;;
      return: (![go.uint64] "ep", ![go.SliceType go.byte] "dig", ![go.SliceType go.byte] "link", ![go.bool] "err")
    else do:  #());;;
    (if: (![go.uint64] "extLen") =⟨go.uint64⟩ #(W64 0)
    then
      let: "$r0" := #true in
      do:  ("err" <-[go.bool] "$r0");;;
      return: (![go.uint64] "ep", ![go.SliceType go.byte] "dig", ![go.SliceType go.byte] "link", ![go.bool] "err")
    else do:  #());;;
    (if: (~ (let: "$a0" := (![go.uint64] (StructFieldRef server.StartChain "PrevEpochLen"%go (![go.PointerType server.StartChain] "chain"))) in
    let: "$a1" := ((![go.uint64] "extLen") -⟨go.uint64⟩ #(W64 1)) in
    (FuncResolve std.SumNoOverflow [] #()) "$a0" "$a1"))
    then
      let: "$r0" := #true in
      do:  ("err" <-[go.bool] "$r0");;;
      return: (![go.uint64] "ep", ![go.SliceType go.byte] "dig", ![go.SliceType go.byte] "link", ![go.bool] "err")
    else do:  #());;;
    let: "$r0" := (((![go.uint64] (StructFieldRef server.StartChain "PrevEpochLen"%go (![go.PointerType server.StartChain] "chain"))) +⟨go.uint64⟩ (![go.uint64] "extLen")) -⟨go.uint64⟩ #(W64 1)) in
    do:  ("ep" <-[go.uint64] "$r0");;;
    (if: let: "$a0" := (![cryptoffi.SigPublicKey] "servPk") in
    let: "$a1" := (![go.uint64] "ep") in
    let: "$a2" := (![go.SliceType go.byte] "link") in
    let: "$a3" := (![go.SliceType go.byte] (StructFieldRef server.StartChain "LinkSig"%go (![go.PointerType server.StartChain] "chain"))) in
    (FuncResolve ktcore.VerifyLinkSig [] #()) "$a0" "$a1" "$a2" "$a3"
    then
      let: "$r0" := #true in
      do:  ("err" <-[go.bool] "$r0");;;
      return: (![go.uint64] "ep", ![go.SliceType go.byte] "dig", ![go.SliceType go.byte] "link", ![go.bool] "err")
    else do:  #());;;
    return: (![go.uint64] "ep", ![go.SliceType go.byte] "dig", ![go.SliceType go.byte] "link", ![go.bool] "err")).

(* go: auditor.go:183:6 *)
Definition CheckStartVrfⁱᵐᵖˡ : val :=
  λ: "servPk" "vrf",
    exception_do (let: "err" := (GoAlloc go.bool #()) in
    let: "vrfPk" := (GoAlloc (go.PointerType cryptoffi.VrfPublicKey) #()) in
    let: "vrf" := (go.AllocValue (go.PointerType server.StartVrf) "vrf") in
    let: "servPk" := (go.AllocValue cryptoffi.SigPublicKey "servPk") in
    let: "errb" := (GoAlloc go.bool #()) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] (StructFieldRef server.StartVrf "VrfPk"%go (![go.PointerType server.StartVrf] "vrf"))) in
    (FuncResolve cryptoffi.VrfPublicKeyDecode [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("vrfPk" <-[go.PointerType cryptoffi.VrfPublicKey] "$r0");;;
    do:  ("errb" <-[go.bool] "$r1");;;
    (if: ![go.bool] "errb"
    then
      let: "$r0" := #true in
      do:  ("err" <-[go.bool] "$r0");;;
      return: (![go.PointerType cryptoffi.VrfPublicKey] "vrfPk", ![go.bool] "err")
    else do:  #());;;
    (if: let: "$a0" := (![cryptoffi.SigPublicKey] "servPk") in
    let: "$a1" := (![go.SliceType go.byte] (StructFieldRef server.StartVrf "VrfPk"%go (![go.PointerType server.StartVrf] "vrf"))) in
    let: "$a2" := (![go.SliceType go.byte] (StructFieldRef server.StartVrf "VrfSig"%go (![go.PointerType server.StartVrf] "vrf"))) in
    (FuncResolve ktcore.VerifyVrfSig [] #()) "$a0" "$a1" "$a2"
    then
      let: "$r0" := #true in
      do:  ("err" <-[go.bool] "$r0");;;
      return: (![go.PointerType cryptoffi.VrfPublicKey] "vrfPk", ![go.bool] "err")
    else do:  #());;;
    return: (![go.PointerType cryptoffi.VrfPublicKey] "vrfPk", ![go.bool] "err")).

Definition GetRpc : val := #(W64 0).

Definition NewRpcAuditor : go_string := "github.com/sanjit-bhat/pav/auditor.NewRpcAuditor"%go.

Definition GetReplyEncode : go_string := "github.com/sanjit-bhat/pav/auditor.GetReplyEncode"%go.

Definition GetReply : go.type := go.Named "github.com/sanjit-bhat/pav/auditor.GetReply"%go [].

Definition GetArg : go.type := go.Named "github.com/sanjit-bhat/pav/auditor.GetArg"%go [].

Definition GetArgDecode : go_string := "github.com/sanjit-bhat/pav/auditor.GetArgDecode"%go.

(* go: rpc.go:12:6 *)
Definition NewRpcAuditorⁱᵐᵖˡ : val :=
  λ: "adtr",
    exception_do (let: "adtr" := (go.AllocValue (go.PointerType Auditor) "adtr") in
    let: "h" := (GoAlloc (go.MapType go.uint64 (go.FunctionType (go.Signature [go.SliceType go.byte; go.PointerType (go.SliceType go.byte)] #false []))) #()) in
    let: "$r0" := ((FuncResolve go.make1 [go.MapType go.uint64 (go.FunctionType (go.Signature [go.SliceType go.byte; go.PointerType (go.SliceType go.byte)] #false []))] #()) #()) in
    do:  ("h" <-[go.MapType go.uint64 (go.FunctionType (go.Signature [go.SliceType go.byte; go.PointerType (go.SliceType go.byte)] #false []))] "$r0");;;
    let: "$r0" := (λ: "arg" "reply",
      exception_do (let: "reply" := (go.AllocValue (go.PointerType (go.SliceType go.byte)) "reply") in
      let: "arg" := (go.AllocValue (go.SliceType go.byte) "arg") in
      let: "err" := (GoAlloc go.bool #()) in
      let: "a" := (GoAlloc (go.PointerType GetArg) #()) in
      let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "arg") in
      (FuncResolve GetArgDecode [] #()) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      let: "$r2" := "$ret2" in
      do:  ("a" <-[go.PointerType GetArg] "$r0");;;
      do:  "$r1";;;
      do:  ("err" <-[go.bool] "$r2");;;
      (if: ![go.bool] "err"
      then
        let: "r" := (GoAlloc (go.PointerType GetReply) #()) in
        let: "$r0" := (go.AllocValue GetReply (let: "$Err" := #true in
        CompositeLiteral GetReply (
          let: "$$vs" := go.StructElementListNil #() in 
          let: "$$vs" := go.ElementListApp "$$vs" (go.ZeroVal (go.PointerType SignedLink) #()) in
          let: "$$vs" := go.ElementListApp "$$vs" (go.ZeroVal (go.PointerType SignedVrf) #()) in
          let: "$$vs" := go.ElementListApp "$$vs" "$Err" in
          "$$vs"
        ))) in
        do:  ("r" <-[go.PointerType GetReply] "$r0");;;
        let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] (![go.PointerType (go.SliceType go.byte)] "reply")) in
        let: "$a1" := (![go.PointerType GetReply] "r") in
        (FuncResolve GetReplyEncode [] #()) "$a0" "$a1") in
        do:  ((![go.PointerType (go.SliceType go.byte)] "reply") <-[go.SliceType go.byte] "$r0");;;
        return: (#())
      else do:  #());;;
      let: "r2" := (GoAlloc go.bool #()) in
      let: "r1" := (GoAlloc (go.PointerType SignedVrf) #()) in
      let: "r0" := (GoAlloc (go.PointerType SignedLink) #()) in
      let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.uint64] (StructFieldRef GetArg "Epoch"%go (![go.PointerType GetArg] "a"))) in
      (MethodResolve (go.PointerType Auditor) Get #() (![go.PointerType Auditor] "adtr")) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      let: "$r2" := "$ret2" in
      do:  ("r0" <-[go.PointerType SignedLink] "$r0");;;
      do:  ("r1" <-[go.PointerType SignedVrf] "$r1");;;
      do:  ("r2" <-[go.bool] "$r2");;;
      let: "r" := (GoAlloc (go.PointerType GetReply) #()) in
      let: "$r0" := (go.AllocValue GetReply (let: "$Link" := (![go.PointerType SignedLink] "r0") in
      let: "$Vrf" := (![go.PointerType SignedVrf] "r1") in
      let: "$Err" := (![go.bool] "r2") in
      CompositeLiteral GetReply (
        let: "$$vs" := go.StructElementListNil #() in 
        let: "$$vs" := go.ElementListApp "$$vs" "$Link" in
        let: "$$vs" := go.ElementListApp "$$vs" "$Vrf" in
        let: "$$vs" := go.ElementListApp "$$vs" "$Err" in
        "$$vs"
      ))) in
      do:  ("r" <-[go.PointerType GetReply] "$r0");;;
      let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] (![go.PointerType (go.SliceType go.byte)] "reply")) in
      let: "$a1" := (![go.PointerType GetReply] "r") in
      (FuncResolve GetReplyEncode [] #()) "$a0" "$a1") in
      do:  ((![go.PointerType (go.SliceType go.byte)] "reply") <-[go.SliceType go.byte] "$r0");;;
      return: #())
      ) in
    do:  (map.insert (![go.MapType go.uint64 (go.FunctionType (go.Signature [go.SliceType go.byte; go.PointerType (go.SliceType go.byte)] #false []))] "h") GetRpc "$r0");;;
    return: (let: "$a0" := (![go.MapType go.uint64 (go.FunctionType (go.Signature [go.SliceType go.byte; go.PointerType (go.SliceType go.byte)] #false []))] "h") in
     (FuncResolve advrpc.NewServer [] #()) "$a0")).

Definition CallGet : go_string := "github.com/sanjit-bhat/pav/auditor.CallGet"%go.

Definition GetReplyDecode : go_string := "github.com/sanjit-bhat/pav/auditor.GetReplyDecode"%go.

Definition GetArgEncode : go_string := "github.com/sanjit-bhat/pav/auditor.GetArgEncode"%go.

(* go: rpc.go:28:6 *)
Definition CallGetⁱᵐᵖˡ : val :=
  λ: "c" "epoch",
    exception_do (let: "err" := (GoAlloc ktcore.Blame #()) in
    let: "vrf" := (GoAlloc (go.PointerType SignedVrf) #()) in
    let: "link" := (GoAlloc (go.PointerType SignedLink) #()) in
    let: "epoch" := (go.AllocValue go.uint64 "epoch") in
    let: "c" := (go.AllocValue (go.PointerType advrpc.Client) "c") in
    let: "a" := (GoAlloc (go.PointerType GetArg) #()) in
    let: "$r0" := (go.AllocValue GetArg (let: "$Epoch" := (![go.uint64] "epoch") in
    CompositeLiteral GetArg (
      let: "$$vs" := go.StructElementListNil #() in 
      let: "$$vs" := go.ElementListApp "$$vs" "$Epoch" in
      "$$vs"
    ))) in
    do:  ("a" <-[go.PointerType GetArg] "$r0");;;
    let: "ab" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := (let: "$a0" := #slice.nil in
    let: "$a1" := (![go.PointerType GetArg] "a") in
    (FuncResolve GetArgEncode [] #()) "$a0" "$a1") in
    do:  ("ab" <-[go.SliceType go.byte] "$r0");;;
    let: "rb" := (GoAlloc (go.PointerType (go.SliceType go.byte)) #()) in
    let: "$r0" := (GoAlloc (go.SliceType go.byte) #()) in
    do:  ("rb" <-[go.PointerType (go.SliceType go.byte)] "$r0");;;
    (if: let: "$a0" := GetRpc in
    let: "$a1" := (![go.SliceType go.byte] "ab") in
    let: "$a2" := (![go.PointerType (go.SliceType go.byte)] "rb") in
    (MethodResolve (go.PointerType advrpc.Client) Call #() (![go.PointerType advrpc.Client] "c")) "$a0" "$a1" "$a2"
    then
      let: "$r0" := ktcore.BlameUnknown in
      do:  ("err" <-[ktcore.Blame] "$r0");;;
      return: (![go.PointerType SignedLink] "link", ![go.PointerType SignedVrf] "vrf", ![ktcore.Blame] "err")
    else do:  #());;;
    let: "errb" := (GoAlloc go.bool #()) in
    let: "r" := (GoAlloc (go.PointerType GetReply) #()) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] (![go.PointerType (go.SliceType go.byte)] "rb")) in
    (FuncResolve GetReplyDecode [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("r" <-[go.PointerType GetReply] "$r0");;;
    do:  "$r1";;;
    do:  ("errb" <-[go.bool] "$r2");;;
    let: "$r0" := (![go.PointerType SignedLink] (StructFieldRef GetReply "Link"%go (![go.PointerType GetReply] "r"))) in
    do:  ("link" <-[go.PointerType SignedLink] "$r0");;;
    let: "$r0" := (![go.PointerType SignedVrf] (StructFieldRef GetReply "Vrf"%go (![go.PointerType GetReply] "r"))) in
    do:  ("vrf" <-[go.PointerType SignedVrf] "$r0");;;
    (if: ![go.bool] "errb"
    then
      let: "$r0" := ktcore.BlameAdtrFull in
      do:  ("err" <-[ktcore.Blame] "$r0");;;
      return: (![go.PointerType SignedLink] "link", ![go.PointerType SignedVrf] "vrf", ![ktcore.Blame] "err")
    else do:  #());;;
    (if: ![go.bool] (StructFieldRef GetReply "Err"%go (![go.PointerType GetReply] "r"))
    then
      let: "$r0" := ktcore.BlameUnknown in
      do:  ("err" <-[ktcore.Blame] "$r0");;;
      return: (![go.PointerType SignedLink] "link", ![go.PointerType SignedVrf] "vrf", ![ktcore.Blame] "err")
    else do:  #());;;
    return: (![go.PointerType SignedLink] "link", ![go.PointerType SignedVrf] "vrf", ![ktcore.Blame] "err")).

Definition GetArgⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "Epoch"%go go.uint64)
].

Definition SignedLinkⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "Link"%go (go.SliceType go.byte));
  (go.FieldDecl "ServSig"%go (go.SliceType go.byte));
  (go.FieldDecl "AdtrSig"%go (go.SliceType go.byte))
].

Definition SignedVrfⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "VrfPk"%go (go.SliceType go.byte));
  (go.FieldDecl "ServSig"%go (go.SliceType go.byte));
  (go.FieldDecl "AdtrSig"%go (go.SliceType go.byte))
].

Definition GetReplyⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "Link"%go (go.PointerType SignedLink));
  (go.FieldDecl "Vrf"%go (go.PointerType SignedVrf));
  (go.FieldDecl "Err"%go go.bool)
].

(* go: serde.out.go:10:6 *)
Definition GetArgEncodeⁱᵐᵖˡ : val :=
  λ: "b0" "o",
    exception_do (let: "o" := (go.AllocValue (go.PointerType GetArg) "o") in
    let: "b0" := (go.AllocValue (go.SliceType go.byte) "b0") in
    let: "b" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := (![go.SliceType go.byte] "b0") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (![go.uint64] (StructFieldRef GetArg "Epoch"%go (![go.PointerType GetArg] "o"))) in
    (FuncResolve marshal.WriteInt [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    return: (![go.SliceType go.byte] "b")).

(* go: serde.out.go:15:6 *)
Definition GetArgDecodeⁱᵐᵖˡ : val :=
  λ: "b0",
    exception_do (let: "b0" := (go.AllocValue (go.SliceType go.byte) "b0") in
    let: "err1" := (GoAlloc go.bool #()) in
    let: "b1" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "a1" := (GoAlloc go.uint64 #()) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "b0") in
    (FuncResolve safemarshal.ReadInt [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a1" <-[go.uint64] "$r0");;;
    do:  ("b1" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err1" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err1"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    return: (go.AllocValue GetArg (let: "$Epoch" := (![go.uint64] "a1") in
     CompositeLiteral GetArg (
       let: "$$vs" := go.StructElementListNil #() in 
       let: "$$vs" := go.ElementListApp "$$vs" "$Epoch" in
       "$$vs"
     )), ![go.SliceType go.byte] "b1", #false)).

Definition SignedLinkEncode : go_string := "github.com/sanjit-bhat/pav/auditor.SignedLinkEncode"%go.

(* go: serde.out.go:22:6 *)
Definition SignedLinkEncodeⁱᵐᵖˡ : val :=
  λ: "b0" "o",
    exception_do (let: "o" := (go.AllocValue (go.PointerType SignedLink) "o") in
    let: "b0" := (go.AllocValue (go.SliceType go.byte) "b0") in
    let: "b" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := (![go.SliceType go.byte] "b0") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (![go.SliceType go.byte] (StructFieldRef SignedLink "Link"%go (![go.PointerType SignedLink] "o"))) in
    (FuncResolve safemarshal.WriteSlice1D [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (![go.SliceType go.byte] (StructFieldRef SignedLink "ServSig"%go (![go.PointerType SignedLink] "o"))) in
    (FuncResolve safemarshal.WriteSlice1D [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (![go.SliceType go.byte] (StructFieldRef SignedLink "AdtrSig"%go (![go.PointerType SignedLink] "o"))) in
    (FuncResolve safemarshal.WriteSlice1D [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    return: (![go.SliceType go.byte] "b")).

Definition SignedLinkDecode : go_string := "github.com/sanjit-bhat/pav/auditor.SignedLinkDecode"%go.

(* go: serde.out.go:29:6 *)
Definition SignedLinkDecodeⁱᵐᵖˡ : val :=
  λ: "b0",
    exception_do (let: "b0" := (go.AllocValue (go.SliceType go.byte) "b0") in
    let: "err1" := (GoAlloc go.bool #()) in
    let: "b1" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "a1" := (GoAlloc (go.SliceType go.byte) #()) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "b0") in
    (FuncResolve safemarshal.ReadSlice1D [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a1" <-[go.SliceType go.byte] "$r0");;;
    do:  ("b1" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err1" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err1"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err2" := (GoAlloc go.bool #()) in
    let: "b2" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "a2" := (GoAlloc (go.SliceType go.byte) #()) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "b1") in
    (FuncResolve safemarshal.ReadSlice1D [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a2" <-[go.SliceType go.byte] "$r0");;;
    do:  ("b2" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err2" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err2"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err3" := (GoAlloc go.bool #()) in
    let: "b3" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "a3" := (GoAlloc (go.SliceType go.byte) #()) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "b2") in
    (FuncResolve safemarshal.ReadSlice1D [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a3" <-[go.SliceType go.byte] "$r0");;;
    do:  ("b3" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err3" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err3"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    return: (go.AllocValue SignedLink (let: "$Link" := (![go.SliceType go.byte] "a1") in
     let: "$ServSig" := (![go.SliceType go.byte] "a2") in
     let: "$AdtrSig" := (![go.SliceType go.byte] "a3") in
     CompositeLiteral SignedLink (
       let: "$$vs" := go.StructElementListNil #() in 
       let: "$$vs" := go.ElementListApp "$$vs" "$Link" in
       let: "$$vs" := go.ElementListApp "$$vs" "$ServSig" in
       let: "$$vs" := go.ElementListApp "$$vs" "$AdtrSig" in
       "$$vs"
     )), ![go.SliceType go.byte] "b3", #false)).

Definition SignedVrfEncode : go_string := "github.com/sanjit-bhat/pav/auditor.SignedVrfEncode"%go.

(* go: serde.out.go:44:6 *)
Definition SignedVrfEncodeⁱᵐᵖˡ : val :=
  λ: "b0" "o",
    exception_do (let: "o" := (go.AllocValue (go.PointerType SignedVrf) "o") in
    let: "b0" := (go.AllocValue (go.SliceType go.byte) "b0") in
    let: "b" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := (![go.SliceType go.byte] "b0") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (![go.SliceType go.byte] (StructFieldRef SignedVrf "VrfPk"%go (![go.PointerType SignedVrf] "o"))) in
    (FuncResolve safemarshal.WriteSlice1D [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (![go.SliceType go.byte] (StructFieldRef SignedVrf "ServSig"%go (![go.PointerType SignedVrf] "o"))) in
    (FuncResolve safemarshal.WriteSlice1D [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (![go.SliceType go.byte] (StructFieldRef SignedVrf "AdtrSig"%go (![go.PointerType SignedVrf] "o"))) in
    (FuncResolve safemarshal.WriteSlice1D [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    return: (![go.SliceType go.byte] "b")).

Definition SignedVrfDecode : go_string := "github.com/sanjit-bhat/pav/auditor.SignedVrfDecode"%go.

(* go: serde.out.go:51:6 *)
Definition SignedVrfDecodeⁱᵐᵖˡ : val :=
  λ: "b0",
    exception_do (let: "b0" := (go.AllocValue (go.SliceType go.byte) "b0") in
    let: "err1" := (GoAlloc go.bool #()) in
    let: "b1" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "a1" := (GoAlloc (go.SliceType go.byte) #()) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "b0") in
    (FuncResolve safemarshal.ReadSlice1D [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a1" <-[go.SliceType go.byte] "$r0");;;
    do:  ("b1" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err1" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err1"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err2" := (GoAlloc go.bool #()) in
    let: "b2" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "a2" := (GoAlloc (go.SliceType go.byte) #()) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "b1") in
    (FuncResolve safemarshal.ReadSlice1D [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a2" <-[go.SliceType go.byte] "$r0");;;
    do:  ("b2" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err2" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err2"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err3" := (GoAlloc go.bool #()) in
    let: "b3" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "a3" := (GoAlloc (go.SliceType go.byte) #()) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "b2") in
    (FuncResolve safemarshal.ReadSlice1D [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a3" <-[go.SliceType go.byte] "$r0");;;
    do:  ("b3" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err3" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err3"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    return: (go.AllocValue SignedVrf (let: "$VrfPk" := (![go.SliceType go.byte] "a1") in
     let: "$ServSig" := (![go.SliceType go.byte] "a2") in
     let: "$AdtrSig" := (![go.SliceType go.byte] "a3") in
     CompositeLiteral SignedVrf (
       let: "$$vs" := go.StructElementListNil #() in 
       let: "$$vs" := go.ElementListApp "$$vs" "$VrfPk" in
       let: "$$vs" := go.ElementListApp "$$vs" "$ServSig" in
       let: "$$vs" := go.ElementListApp "$$vs" "$AdtrSig" in
       "$$vs"
     )), ![go.SliceType go.byte] "b3", #false)).

(* go: serde.out.go:66:6 *)
Definition GetReplyEncodeⁱᵐᵖˡ : val :=
  λ: "b0" "o",
    exception_do (let: "o" := (go.AllocValue (go.PointerType GetReply) "o") in
    let: "b0" := (go.AllocValue (go.SliceType go.byte) "b0") in
    let: "b" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := (![go.SliceType go.byte] "b0") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (![go.PointerType SignedLink] (StructFieldRef GetReply "Link"%go (![go.PointerType GetReply] "o"))) in
    (FuncResolve SignedLinkEncode [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (![go.PointerType SignedVrf] (StructFieldRef GetReply "Vrf"%go (![go.PointerType GetReply] "o"))) in
    (FuncResolve SignedVrfEncode [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (![go.bool] (StructFieldRef GetReply "Err"%go (![go.PointerType GetReply] "o"))) in
    (FuncResolve marshal.WriteBool [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    return: (![go.SliceType go.byte] "b")).

(* go: serde.out.go:73:6 *)
Definition GetReplyDecodeⁱᵐᵖˡ : val :=
  λ: "b0",
    exception_do (let: "b0" := (go.AllocValue (go.SliceType go.byte) "b0") in
    let: "err1" := (GoAlloc go.bool #()) in
    let: "b1" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "a1" := (GoAlloc (go.PointerType SignedLink) #()) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "b0") in
    (FuncResolve SignedLinkDecode [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a1" <-[go.PointerType SignedLink] "$r0");;;
    do:  ("b1" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err1" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err1"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err2" := (GoAlloc go.bool #()) in
    let: "b2" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "a2" := (GoAlloc (go.PointerType SignedVrf) #()) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "b1") in
    (FuncResolve SignedVrfDecode [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a2" <-[go.PointerType SignedVrf] "$r0");;;
    do:  ("b2" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err2" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err2"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err3" := (GoAlloc go.bool #()) in
    let: "b3" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "a3" := (GoAlloc go.bool #()) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "b2") in
    (FuncResolve safemarshal.ReadBool [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a3" <-[go.bool] "$r0");;;
    do:  ("b3" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err3" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err3"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    return: (go.AllocValue GetReply (let: "$Link" := (![go.PointerType SignedLink] "a1") in
     let: "$Vrf" := (![go.PointerType SignedVrf] "a2") in
     let: "$Err" := (![go.bool] "a3") in
     CompositeLiteral GetReply (
       let: "$$vs" := go.StructElementListNil #() in 
       let: "$$vs" := go.ElementListApp "$$vs" "$Link" in
       let: "$$vs" := go.ElementListApp "$$vs" "$Vrf" in
       let: "$$vs" := go.ElementListApp "$$vs" "$Err" in
       "$$vs"
     )), ![go.SliceType go.byte] "b3", #false)).

Definition functions' : list (go_string * val) := [(New, Newⁱᵐᵖˡ); (getNextLink, getNextLinkⁱᵐᵖˡ); (getNextDig, getNextDigⁱᵐᵖˡ); (CheckStartChain, CheckStartChainⁱᵐᵖˡ); (CheckStartVrf, CheckStartVrfⁱᵐᵖˡ); (NewRpcAuditor, NewRpcAuditorⁱᵐᵖˡ); (CallGet, CallGetⁱᵐᵖˡ); (GetArgEncode, GetArgEncodeⁱᵐᵖˡ); (GetArgDecode, GetArgDecodeⁱᵐᵖˡ); (SignedLinkEncode, SignedLinkEncodeⁱᵐᵖˡ); (SignedLinkDecode, SignedLinkDecodeⁱᵐᵖˡ); (SignedVrfEncode, SignedVrfEncodeⁱᵐᵖˡ); (SignedVrfDecode, SignedVrfDecodeⁱᵐᵖˡ); (GetReplyEncode, GetReplyEncodeⁱᵐᵖˡ); (GetReplyDecode, GetReplyDecodeⁱᵐᵖˡ)].

#[global] Instance info' : PkgInfo auditor.auditor :=
  {|
    pkg_imported_pkgs := [code.bytes.bytes; code.sync.sync; code.github_com.goose_lang.std.std; code.github_com.sanjit_bhat.pav.advrpc.advrpc; code.github_com.sanjit_bhat.pav.cryptoffi.cryptoffi; code.github_com.sanjit_bhat.pav.hashchain.hashchain; code.github_com.sanjit_bhat.pav.ktcore.ktcore; code.github_com.sanjit_bhat.pav.merkle.merkle; code.github_com.sanjit_bhat.pav.server.server; code.github_com.sanjit_bhat.pav.safemarshal.safemarshal; code.github_com.tchajed.marshal.marshal];
  |}.

Definition initialize' : val :=
  λ: <>,
    package.init auditor.auditor (λ: <>,
      exception_do (do:  (marshal.initialize' #());;;
      do:  (safemarshal.initialize' #());;;
      do:  (server.initialize' #());;;
      do:  (merkle.initialize' #());;;
      do:  (ktcore.initialize' #());;;
      do:  (hashchain.initialize' #());;;
      do:  (cryptoffi.initialize' #());;;
      do:  (advrpc.initialize' #());;;
      do:  (std.initialize' #());;;
      do:  (sync.initialize' #());;;
      do:  (bytes.initialize' #()))
      ).

End code.
End auditor.
