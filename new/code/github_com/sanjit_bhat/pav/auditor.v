(* autogenerated from github.com/sanjit-bhat/pav/auditor *)
From New.golang Require Import defn.
Require Export New.code.bytes.
Require Export New.code.github_com.sanjit_bhat.pav.advrpc.
Require Export New.code.github_com.sanjit_bhat.pav.cryptoffi.
Require Export New.code.github_com.sanjit_bhat.pav.hashchain.
Require Export New.code.github_com.sanjit_bhat.pav.ktcore.
Require Export New.code.github_com.sanjit_bhat.pav.merkle.
Require Export New.code.github_com.sanjit_bhat.pav.safemarshal.
Require Export New.code.github_com.sanjit_bhat.pav.server.
Require Export New.code.github_com.tchajed.marshal.
Require Export New.code.sync.

Definition auditor : go_string := "github.com/sanjit-bhat/pav/auditor".

Module auditor.
Section code.
Context `{ffi_syntax}.


Definition Auditor : go_type := structT [
  "mu" :: ptrT;
  "sk" :: ptrT;
  "lastDig" :: sliceT;
  "hist" :: sliceT;
  "serv" :: ptrT
].

Definition history : go_type := structT [
  "link" :: sliceT;
  "servSig" :: sliceT;
  "adtrSig" :: sliceT
].

Definition serv : go_type := structT [
  "cli" :: ptrT;
  "sigPk" :: cryptoffi.SigPublicKey;
  "vrfPk" :: sliceT;
  "servVrfSig" :: sliceT;
  "adtrVrfSig" :: sliceT
].

(* Update queries server for a new epoch update and applies it.

   go: auditor.go:38:19 *)
Definition Auditor__Update : val :=
  rec: "Auditor__Update" "a" <> :=
    with_defer: (let: "err" := (mem.alloc (type.zero_val #ktcore.Blame)) in
    let: "a" := (mem.alloc "a") in
    do:  ((method_call #sync #"RWMutex'ptr" #"Lock" (![#ptrT] (struct.field_ref #Auditor #"mu"%go (![#ptrT] "a")))) #());;;
    do:  (let: "$f" := (method_call #sync #"RWMutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Auditor #"mu"%go (![#ptrT] "a")))) in
    "$defer" <-[#funcT] (let: "$oldf" := (![#funcT] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    let: "numEps" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref #Auditor #"hist"%go (![#ptrT] "a"))) in
    slice.len "$a0")) in
    do:  ("numEps" <-[#uint64T] "$r0");;;
    let: "upd" := (mem.alloc (type.zero_val #sliceT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#ptrT] (struct.field_ref #serv #"cli"%go (![#ptrT] (struct.field_ref #Auditor #"serv"%go (![#ptrT] "a"))))) in
    let: "$a1" := (![#uint64T] "numEps") in
    (func_call #server.server #"CallAudit"%go) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("upd" <-[#sliceT] "$r0");;;
    do:  ("err" <-[#ktcore.Blame] "$r1");;;
    (if: (![#ktcore.Blame] "err") ≠ ktcore.BlameNone
    then return: (![#ktcore.Blame] "err")
    else do:  #());;;
    let: "$range" := (![#sliceT] "upd") in
    (let: "p" := (mem.alloc (type.zero_val #ptrT)) in
    slice.for_range #ptrT "$range" (λ: "$key" "$value",
      do:  ("p" <-[#ptrT] "$value");;;
      do:  "$key";;;
      let: "$r0" := (let: "$a0" := (![#ptrT] "p") in
      (method_call #auditor.auditor #"Auditor'ptr" #"updOnce" (![#ptrT] "a")) "$a0") in
      do:  ("err" <-[#ktcore.Blame] "$r0");;;
      (if: (![#ktcore.Blame] "err") ≠ ktcore.BlameNone
      then return: (![#ktcore.Blame] "err")
      else do:  #())));;;
    return: (![#ktcore.Blame] "err")).

(* go: auditor.go:56:19 *)
Definition Auditor__updOnce : val :=
  rec: "Auditor__updOnce" "a" "p" :=
    exception_do (let: "err" := (mem.alloc (type.zero_val #ktcore.Blame)) in
    let: "a" := (mem.alloc "a") in
    let: "p" := (mem.alloc "p") in
    let: "numEps" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref #Auditor #"hist"%go (![#ptrT] "a"))) in
    slice.len "$a0")) in
    do:  ("numEps" <-[#uint64T] "$r0");;;
    let: "lastLink" := (mem.alloc (type.zero_val #sliceT)) in
    (if: (![#uint64T] "numEps") = #(W64 0)
    then
      let: "$r0" := ((func_call #hashchain.hashchain #"GetEmptyLink"%go) #()) in
      do:  ("lastLink" <-[#sliceT] "$r0")
    else
      let: "$r0" := (![#sliceT] (struct.field_ref #history #"link"%go (![#ptrT] (slice.elem_ref #ptrT (![#sliceT] (struct.field_ref #Auditor #"hist"%go (![#ptrT] "a"))) ((![#uint64T] "numEps") - #(W64 1)))))) in
      do:  ("lastLink" <-[#sliceT] "$r0"));;;
    let: "errb" := (mem.alloc (type.zero_val #boolT)) in
    let: "nextDig" := (mem.alloc (type.zero_val #sliceT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] (struct.field_ref #Auditor #"lastDig"%go (![#ptrT] "a"))) in
    let: "$a1" := (![#sliceT] (struct.field_ref #ktcore.AuditProof #"Updates"%go (![#ptrT] "p"))) in
    (func_call #auditor.auditor #"getNextDig"%go) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("nextDig" <-[#sliceT] "$r0");;;
    do:  ("errb" <-[#boolT] "$r1");;;
    (if: ![#boolT] "errb"
    then return: (ktcore.BlameServFull)
    else do:  #());;;
    let: "nextLink" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "lastLink") in
    let: "$a1" := (![#sliceT] "nextDig") in
    (func_call #hashchain.hashchain #"GetNextLink"%go) "$a0" "$a1") in
    do:  ("nextLink" <-[#sliceT] "$r0");;;
    (if: let: "$a0" := (![#cryptoffi.SigPublicKey] (struct.field_ref #serv #"sigPk"%go (![#ptrT] (struct.field_ref #Auditor #"serv"%go (![#ptrT] "a"))))) in
    let: "$a1" := (![#uint64T] "numEps") in
    let: "$a2" := (![#sliceT] "nextLink") in
    let: "$a3" := (![#sliceT] (struct.field_ref #ktcore.AuditProof #"LinkSig"%go (![#ptrT] "p"))) in
    (func_call #ktcore.ktcore #"VerifyLinkSig"%go) "$a0" "$a1" "$a2" "$a3"
    then return: (ktcore.BlameServFull)
    else do:  #());;;
    let: "sig" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#ptrT] (struct.field_ref #Auditor #"sk"%go (![#ptrT] "a"))) in
    let: "$a1" := (![#uint64T] "numEps") in
    let: "$a2" := (![#sliceT] "nextLink") in
    (func_call #ktcore.ktcore #"SignLink"%go) "$a0" "$a1" "$a2") in
    do:  ("sig" <-[#sliceT] "$r0");;;
    let: "$r0" := (![#sliceT] "nextDig") in
    do:  ((struct.field_ref #Auditor #"lastDig"%go (![#ptrT] "a")) <-[#sliceT] "$r0");;;
    let: "info" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (let: "$link" := (![#sliceT] "nextLink") in
    let: "$servSig" := (![#sliceT] (struct.field_ref #ktcore.AuditProof #"LinkSig"%go (![#ptrT] "p"))) in
    let: "$adtrSig" := (![#sliceT] "sig") in
    struct.make #history [{
      "link" ::= "$link";
      "servSig" ::= "$servSig";
      "adtrSig" ::= "$adtrSig"
    }])) in
    do:  ("info" <-[#ptrT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] (struct.field_ref #Auditor #"hist"%go (![#ptrT] "a"))) in
    let: "$a1" := ((let: "$sl0" := (![#ptrT] "info") in
    slice.literal #ptrT ["$sl0"])) in
    (slice.append #ptrT) "$a0" "$a1") in
    do:  ((struct.field_ref #Auditor #"hist"%go (![#ptrT] "a")) <-[#sliceT] "$r0");;;
    return: (ktcore.BlameNone)).

Definition GetReply : go_type := structT [
  "Link" :: sliceT;
  "ServLinkSig" :: sliceT;
  "AdtrLinkSig" :: sliceT;
  "VrfPk" :: sliceT;
  "ServVrfSig" :: sliceT;
  "AdtrVrfSig" :: sliceT;
  "Err" :: ktcore.Blame
].

(* Get returns the auditor's info for a particular epoch.
   it errors if the epoch is out of bounds.

   go: auditor.go:86:19 *)
Definition Auditor__Get : val :=
  rec: "Auditor__Get" "a" "epoch" :=
    with_defer: (let: "a" := (mem.alloc "a") in
    let: "epoch" := (mem.alloc "epoch") in
    do:  ((method_call #sync #"RWMutex'ptr" #"RLock" (![#ptrT] (struct.field_ref #Auditor #"mu"%go (![#ptrT] "a")))) #());;;
    do:  (let: "$f" := (method_call #sync #"RWMutex'ptr" #"RUnlock" (![#ptrT] (struct.field_ref #Auditor #"mu"%go (![#ptrT] "a")))) in
    "$defer" <-[#funcT] (let: "$oldf" := (![#funcT] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    let: "numEpochs" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref #Auditor #"hist"%go (![#ptrT] "a"))) in
    slice.len "$a0")) in
    do:  ("numEpochs" <-[#uint64T] "$r0");;;
    (if: (![#uint64T] "epoch") ≥ (![#uint64T] "numEpochs")
    then
      return: (mem.alloc (let: "$Err" := ktcore.BlameUnknown in
       struct.make #GetReply [{
         "Link" ::= type.zero_val #sliceT;
         "ServLinkSig" ::= type.zero_val #sliceT;
         "AdtrLinkSig" ::= type.zero_val #sliceT;
         "VrfPk" ::= type.zero_val #sliceT;
         "ServVrfSig" ::= type.zero_val #sliceT;
         "AdtrVrfSig" ::= type.zero_val #sliceT;
         "Err" ::= "$Err"
       }]))
    else do:  #());;;
    let: "x" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (![#ptrT] (slice.elem_ref #ptrT (![#sliceT] (struct.field_ref #Auditor #"hist"%go (![#ptrT] "a"))) (![#uint64T] "epoch"))) in
    do:  ("x" <-[#ptrT] "$r0");;;
    return: (mem.alloc (let: "$Link" := (![#sliceT] (struct.field_ref #history #"link"%go (![#ptrT] "x"))) in
     let: "$ServLinkSig" := (![#sliceT] (struct.field_ref #history #"servSig"%go (![#ptrT] "x"))) in
     let: "$AdtrLinkSig" := (![#sliceT] (struct.field_ref #history #"adtrSig"%go (![#ptrT] "x"))) in
     let: "$VrfPk" := (![#sliceT] (struct.field_ref #serv #"vrfPk"%go (![#ptrT] (struct.field_ref #Auditor #"serv"%go (![#ptrT] "a"))))) in
     let: "$ServVrfSig" := (![#sliceT] (struct.field_ref #serv #"servVrfSig"%go (![#ptrT] (struct.field_ref #Auditor #"serv"%go (![#ptrT] "a"))))) in
     let: "$AdtrVrfSig" := (![#sliceT] (struct.field_ref #serv #"adtrVrfSig"%go (![#ptrT] (struct.field_ref #Auditor #"serv"%go (![#ptrT] "a"))))) in
     struct.make #GetReply [{
       "Link" ::= "$Link";
       "ServLinkSig" ::= "$ServLinkSig";
       "AdtrLinkSig" ::= "$AdtrLinkSig";
       "VrfPk" ::= "$VrfPk";
       "ServVrfSig" ::= "$ServVrfSig";
       "AdtrVrfSig" ::= "$AdtrVrfSig";
       "Err" ::= type.zero_val #ktcore.Blame
     }]))).

(* go: auditor.go:99:6 *)
Definition New : val :=
  rec: "New" "servAddr" "servPk" :=
    exception_do (let: "err" := (mem.alloc (type.zero_val #ktcore.Blame)) in
    let: "sigPk" := (mem.alloc (type.zero_val #cryptoffi.SigPublicKey)) in
    let: "a" := (mem.alloc (type.zero_val #ptrT)) in
    let: "servPk" := (mem.alloc "servPk") in
    let: "servAddr" := (mem.alloc "servAddr") in
    let: "cli" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := (![#uint64T] "servAddr") in
    (func_call #advrpc.advrpc #"Dial"%go) "$a0") in
    do:  ("cli" <-[#ptrT] "$r0");;;
    let: "reply" := (mem.alloc (type.zero_val #ptrT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#ptrT] "cli") in
    (func_call #server.server #"CallStart"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("reply" <-[#ptrT] "$r0");;;
    do:  ("err" <-[#ktcore.Blame] "$r1");;;
    (if: (![#ktcore.Blame] "err") ≠ ktcore.BlameNone
    then return: (![#ptrT] "a", ![#cryptoffi.SigPublicKey] "sigPk", ![#ktcore.Blame] "err")
    else do:  #());;;
    (if: let: "$a0" := (![#cryptoffi.SigPublicKey] "servPk") in
    let: "$a1" := (![#sliceT] (struct.field_ref #server.StartReply #"VrfPk"%go (![#ptrT] "reply"))) in
    let: "$a2" := (![#sliceT] (struct.field_ref #server.StartReply #"VrfSig"%go (![#ptrT] "reply"))) in
    (func_call #ktcore.ktcore #"VerifyVrfSig"%go) "$a0" "$a1" "$a2"
    then
      let: "$r0" := ktcore.BlameServFull in
      do:  ("err" <-[#ktcore.Blame] "$r0");;;
      return: (![#ptrT] "a", ![#cryptoffi.SigPublicKey] "sigPk", ![#ktcore.Blame] "err")
    else do:  #());;;
    let: "mu" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #sync.RWMutex)) in
    do:  ("mu" <-[#ptrT] "$r0");;;
    let: "sk" := (mem.alloc (type.zero_val #ptrT)) in
    let: ("$ret0", "$ret1") := ((func_call #cryptoffi.cryptoffi #"SigGenerateKey"%go) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("sigPk" <-[#cryptoffi.SigPublicKey] "$r0");;;
    do:  ("sk" <-[#ptrT] "$r1");;;
    let: "tr" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (struct.make #merkle.Tree [{
      "root" ::= type.zero_val #ptrT
    }])) in
    do:  ("tr" <-[#ptrT] "$r0");;;
    let: "dig" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := ((method_call #merkle #"Tree'ptr" #"Digest" (![#ptrT] "tr")) #()) in
    do:  ("dig" <-[#sliceT] "$r0");;;
    let: "sig" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#ptrT] "sk") in
    let: "$a1" := (![#sliceT] (struct.field_ref #server.StartReply #"VrfPk"%go (![#ptrT] "reply"))) in
    (func_call #ktcore.ktcore #"SignVrf"%go) "$a0" "$a1") in
    do:  ("sig" <-[#sliceT] "$r0");;;
    let: "serv" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (let: "$cli" := (![#ptrT] "cli") in
    let: "$sigPk" := (![#cryptoffi.SigPublicKey] "servPk") in
    let: "$vrfPk" := (![#sliceT] (struct.field_ref #server.StartReply #"VrfPk"%go (![#ptrT] "reply"))) in
    let: "$servVrfSig" := (![#sliceT] (struct.field_ref #server.StartReply #"VrfSig"%go (![#ptrT] "reply"))) in
    let: "$adtrVrfSig" := (![#sliceT] "sig") in
    struct.make #serv [{
      "cli" ::= "$cli";
      "sigPk" ::= "$sigPk";
      "vrfPk" ::= "$vrfPk";
      "servVrfSig" ::= "$servVrfSig";
      "adtrVrfSig" ::= "$adtrVrfSig"
    }])) in
    do:  ("serv" <-[#ptrT] "$r0");;;
    let: "$r0" := (mem.alloc (let: "$mu" := (![#ptrT] "mu") in
    let: "$sk" := (![#ptrT] "sk") in
    let: "$lastDig" := (![#sliceT] "dig") in
    let: "$serv" := (![#ptrT] "serv") in
    struct.make #Auditor [{
      "mu" ::= "$mu";
      "sk" ::= "$sk";
      "lastDig" ::= "$lastDig";
      "hist" ::= type.zero_val #sliceT;
      "serv" ::= "$serv"
    }])) in
    do:  ("a" <-[#ptrT] "$r0");;;
    return: (![#ptrT] "a", ![#cryptoffi.SigPublicKey] "sigPk", ![#ktcore.Blame] "err")).

(* go: auditor.go:121:6 *)
Definition getNextDig : val :=
  rec: "getNextDig" "lastDig" "updates" :=
    exception_do (let: "err" := (mem.alloc (type.zero_val #boolT)) in
    let: "dig" := (mem.alloc (type.zero_val #sliceT)) in
    let: "updates" := (mem.alloc "updates") in
    let: "lastDig" := (mem.alloc "lastDig") in
    let: "$r0" := (![#sliceT] "lastDig") in
    do:  ("dig" <-[#sliceT] "$r0");;;
    let: "$range" := (![#sliceT] "updates") in
    (let: "u" := (mem.alloc (type.zero_val #ptrT)) in
    slice.for_range #ptrT "$range" (λ: "$key" "$value",
      do:  ("u" <-[#ptrT] "$value");;;
      do:  "$key";;;
      let: "next" := (mem.alloc (type.zero_val #sliceT)) in
      let: "prev" := (mem.alloc (type.zero_val #sliceT)) in
      let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] (struct.field_ref #ktcore.UpdateProof #"MapLabel"%go (![#ptrT] "u"))) in
      let: "$a1" := (![#sliceT] (struct.field_ref #ktcore.UpdateProof #"MapVal"%go (![#ptrT] "u"))) in
      let: "$a2" := (![#sliceT] (struct.field_ref #ktcore.UpdateProof #"NonMembProof"%go (![#ptrT] "u"))) in
      (func_call #merkle.merkle #"VerifyUpdate"%go) "$a0" "$a1" "$a2") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      let: "$r2" := "$ret2" in
      do:  ("prev" <-[#sliceT] "$r0");;;
      do:  ("next" <-[#sliceT] "$r1");;;
      do:  ("err" <-[#boolT] "$r2");;;
      (if: ![#boolT] "err"
      then return: (![#sliceT] "dig", ![#boolT] "err")
      else do:  #());;;
      (if: (~ (let: "$a0" := (![#sliceT] "dig") in
      let: "$a1" := (![#sliceT] "prev") in
      (func_call #bytes.bytes #"Equal"%go) "$a0" "$a1"))
      then
        let: "$r0" := #true in
        do:  ("err" <-[#boolT] "$r0");;;
        return: (![#sliceT] "dig", ![#boolT] "err")
      else do:  #());;;
      let: "$r0" := (![#sliceT] "next") in
      do:  ("dig" <-[#sliceT] "$r0")));;;
    return: (![#sliceT] "dig", ![#boolT] "err")).

Definition UpdateRpc : expr := #(W64 0).

Definition GetRpc : expr := #(W64 1).

Definition GetArg : go_type := structT [
  "Epoch" :: uint64T
].

Definition UpdateReply : go_type := structT [
  "Err" :: ktcore.Blame
].

(* go: rpc.go:13:6 *)
Definition NewRpcAuditor : val :=
  rec: "NewRpcAuditor" "adtr" :=
    exception_do (let: "adtr" := (mem.alloc "adtr") in
    let: "h" := (mem.alloc (type.zero_val (type.mapT #uint64T #funcT))) in
    let: "$r0" := (map.make #uint64T #funcT) in
    do:  ("h" <-[type.mapT #uint64T #funcT] "$r0");;;
    let: "$r0" := (λ: "arg" "reply",
      exception_do (let: "reply" := (mem.alloc "reply") in
      let: "arg" := (mem.alloc "arg") in
      let: "r0" := (mem.alloc (type.zero_val #ktcore.Blame)) in
      let: "$r0" := ((method_call #auditor.auditor #"Auditor'ptr" #"Update" (![#ptrT] "adtr")) #()) in
      do:  ("r0" <-[#ktcore.Blame] "$r0");;;
      let: "replyObj" := (mem.alloc (type.zero_val #ptrT)) in
      let: "$r0" := (mem.alloc (let: "$Err" := (![#ktcore.Blame] "r0") in
      struct.make #UpdateReply [{
        "Err" ::= "$Err"
      }])) in
      do:  ("replyObj" <-[#ptrT] "$r0");;;
      let: "$r0" := (let: "$a0" := (![#sliceT] (![#ptrT] "reply")) in
      let: "$a1" := (![#ptrT] "replyObj") in
      (func_call #auditor.auditor #"UpdateReplyEncode"%go) "$a0" "$a1") in
      do:  ((![#ptrT] "reply") <-[#sliceT] "$r0");;;
      return: #())
      ) in
    do:  (map.insert (![type.mapT #uint64T #funcT] "h") UpdateRpc "$r0");;;
    let: "$r0" := (λ: "arg" "reply",
      exception_do (let: "reply" := (mem.alloc "reply") in
      let: "arg" := (mem.alloc "arg") in
      let: "err" := (mem.alloc (type.zero_val #boolT)) in
      let: "a" := (mem.alloc (type.zero_val #ptrT)) in
      let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "arg") in
      (func_call #auditor.auditor #"GetArgDecode"%go) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      let: "$r2" := "$ret2" in
      do:  ("a" <-[#ptrT] "$r0");;;
      do:  "$r1";;;
      do:  ("err" <-[#boolT] "$r2");;;
      (if: ![#boolT] "err"
      then
        let: "r" := (mem.alloc (type.zero_val #ptrT)) in
        let: "$r0" := (mem.alloc (let: "$Err" := ktcore.BlameUnknown in
        struct.make #GetReply [{
          "Link" ::= type.zero_val #sliceT;
          "ServLinkSig" ::= type.zero_val #sliceT;
          "AdtrLinkSig" ::= type.zero_val #sliceT;
          "VrfPk" ::= type.zero_val #sliceT;
          "ServVrfSig" ::= type.zero_val #sliceT;
          "AdtrVrfSig" ::= type.zero_val #sliceT;
          "Err" ::= "$Err"
        }])) in
        do:  ("r" <-[#ptrT] "$r0");;;
        let: "$r0" := (let: "$a0" := (![#sliceT] (![#ptrT] "reply")) in
        let: "$a1" := (![#ptrT] "r") in
        (func_call #auditor.auditor #"GetReplyEncode"%go) "$a0" "$a1") in
        do:  ((![#ptrT] "reply") <-[#sliceT] "$r0");;;
        return: (#())
      else do:  #());;;
      let: "r" := (mem.alloc (type.zero_val #ptrT)) in
      let: "$r0" := (let: "$a0" := (![#uint64T] (struct.field_ref #GetArg #"Epoch"%go (![#ptrT] "a"))) in
      (method_call #auditor.auditor #"Auditor'ptr" #"Get" (![#ptrT] "adtr")) "$a0") in
      do:  ("r" <-[#ptrT] "$r0");;;
      let: "$r0" := (let: "$a0" := (![#sliceT] (![#ptrT] "reply")) in
      let: "$a1" := (![#ptrT] "r") in
      (func_call #auditor.auditor #"GetReplyEncode"%go) "$a0" "$a1") in
      do:  ((![#ptrT] "reply") <-[#sliceT] "$r0");;;
      return: #())
      ) in
    do:  (map.insert (![type.mapT #uint64T #funcT] "h") GetRpc "$r0");;;
    return: (let: "$a0" := (![type.mapT #uint64T #funcT] "h") in
     (func_call #advrpc.advrpc #"NewServer"%go) "$a0")).

(* go: rpc.go:33:6 *)
Definition CallUpdate : val :=
  rec: "CallUpdate" "c" :=
    exception_do (let: "err" := (mem.alloc (type.zero_val #ktcore.Blame)) in
    let: "c" := (mem.alloc "c") in
    let: "rb" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #sliceT)) in
    do:  ("rb" <-[#ptrT] "$r0");;;
    (if: let: "$a0" := UpdateRpc in
    let: "$a1" := #slice.nil in
    let: "$a2" := (![#ptrT] "rb") in
    (method_call #advrpc #"Client'ptr" #"Call" (![#ptrT] "c")) "$a0" "$a1" "$a2"
    then return: (ktcore.BlameUnknown)
    else do:  #());;;
    let: "errb" := (mem.alloc (type.zero_val #boolT)) in
    let: "r" := (mem.alloc (type.zero_val #ptrT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] (![#ptrT] "rb")) in
    (func_call #auditor.auditor #"UpdateReplyDecode"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("r" <-[#ptrT] "$r0");;;
    do:  "$r1";;;
    do:  ("errb" <-[#boolT] "$r2");;;
    (if: ![#boolT] "errb"
    then return: (ktcore.BlameAdtrFull)
    else do:  #());;;
    (if: let: "$a0" := (![#ktcore.Blame] (struct.field_ref #UpdateReply #"Err"%go (![#ptrT] "r"))) in
    let: "$a1" := ((let: "$sl0" := ktcore.BlameServFull in
    let: "$sl1" := ktcore.BlameUnknown in
    slice.literal #ktcore.Blame ["$sl0"; "$sl1"])) in
    (func_call #ktcore.ktcore #"CheckBlame"%go) "$a0" "$a1"
    then return: (ktcore.BlameAdtrFull)
    else do:  #());;;
    return: (![#ktcore.Blame] "err")).

(* go: rpc.go:49:6 *)
Definition CallGet : val :=
  rec: "CallGet" "c" "epoch" :=
    exception_do (let: "epoch" := (mem.alloc "epoch") in
    let: "c" := (mem.alloc "c") in
    let: "a" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (let: "$Epoch" := (![#uint64T] "epoch") in
    struct.make #GetArg [{
      "Epoch" ::= "$Epoch"
    }])) in
    do:  ("a" <-[#ptrT] "$r0");;;
    let: "ab" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := #slice.nil in
    let: "$a1" := (![#ptrT] "a") in
    (func_call #auditor.auditor #"GetArgEncode"%go) "$a0" "$a1") in
    do:  ("ab" <-[#sliceT] "$r0");;;
    let: "rb" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #sliceT)) in
    do:  ("rb" <-[#ptrT] "$r0");;;
    (if: let: "$a0" := GetRpc in
    let: "$a1" := (![#sliceT] "ab") in
    let: "$a2" := (![#ptrT] "rb") in
    (method_call #advrpc #"Client'ptr" #"Call" (![#ptrT] "c")) "$a0" "$a1" "$a2"
    then
      return: (mem.alloc (let: "$Err" := ktcore.BlameUnknown in
       struct.make #GetReply [{
         "Link" ::= type.zero_val #sliceT;
         "ServLinkSig" ::= type.zero_val #sliceT;
         "AdtrLinkSig" ::= type.zero_val #sliceT;
         "VrfPk" ::= type.zero_val #sliceT;
         "ServVrfSig" ::= type.zero_val #sliceT;
         "AdtrVrfSig" ::= type.zero_val #sliceT;
         "Err" ::= "$Err"
       }]))
    else do:  #());;;
    let: "errb" := (mem.alloc (type.zero_val #boolT)) in
    let: "r" := (mem.alloc (type.zero_val #ptrT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] (![#ptrT] "rb")) in
    (func_call #auditor.auditor #"GetReplyDecode"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("r" <-[#ptrT] "$r0");;;
    do:  "$r1";;;
    do:  ("errb" <-[#boolT] "$r2");;;
    (if: ![#boolT] "errb"
    then
      return: (mem.alloc (let: "$Err" := ktcore.BlameAdtrFull in
       struct.make #GetReply [{
         "Link" ::= type.zero_val #sliceT;
         "ServLinkSig" ::= type.zero_val #sliceT;
         "AdtrLinkSig" ::= type.zero_val #sliceT;
         "VrfPk" ::= type.zero_val #sliceT;
         "ServVrfSig" ::= type.zero_val #sliceT;
         "AdtrVrfSig" ::= type.zero_val #sliceT;
         "Err" ::= "$Err"
       }]))
    else do:  #());;;
    (if: let: "$a0" := (![#ktcore.Blame] (struct.field_ref #GetReply #"Err"%go (![#ptrT] "r"))) in
    let: "$a1" := ((let: "$sl0" := ktcore.BlameUnknown in
    slice.literal #ktcore.Blame ["$sl0"])) in
    (func_call #ktcore.ktcore #"CheckBlame"%go) "$a0" "$a1"
    then
      return: (mem.alloc (let: "$Err" := ktcore.BlameAdtrFull in
       struct.make #GetReply [{
         "Link" ::= type.zero_val #sliceT;
         "ServLinkSig" ::= type.zero_val #sliceT;
         "AdtrLinkSig" ::= type.zero_val #sliceT;
         "VrfPk" ::= type.zero_val #sliceT;
         "ServVrfSig" ::= type.zero_val #sliceT;
         "AdtrVrfSig" ::= type.zero_val #sliceT;
         "Err" ::= "$Err"
       }]))
    else do:  #());;;
    return: (![#ptrT] "r")).

(* go: serde.out.go:11:6 *)
Definition UpdateReplyEncode : val :=
  rec: "UpdateReplyEncode" "b0" "o" :=
    exception_do (let: "o" := (mem.alloc "o") in
    let: "b0" := (mem.alloc "b0") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "b0") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#ktcore.Blame] (struct.field_ref #UpdateReply #"Err"%go (![#ptrT] "o"))) in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "b")).

(* go: serde.out.go:16:6 *)
Definition UpdateReplyDecode : val :=
  rec: "UpdateReplyDecode" "b0" :=
    exception_do (let: "b0" := (mem.alloc "b0") in
    let: "err1" := (mem.alloc (type.zero_val #boolT)) in
    let: "b1" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a1" := (mem.alloc (type.zero_val #uint64T)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b0") in
    (func_call #safemarshal.safemarshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a1" <-[#uint64T] "$r0");;;
    do:  ("b1" <-[#sliceT] "$r1");;;
    do:  ("err1" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err1"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    return: (mem.alloc (let: "$Err" := (![#uint64T] "a1") in
     struct.make #UpdateReply [{
       "Err" ::= "$Err"
     }]), ![#sliceT] "b1", #false)).

(* go: serde.out.go:23:6 *)
Definition GetArgEncode : val :=
  rec: "GetArgEncode" "b0" "o" :=
    exception_do (let: "o" := (mem.alloc "o") in
    let: "b0" := (mem.alloc "b0") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "b0") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#uint64T] (struct.field_ref #GetArg #"Epoch"%go (![#ptrT] "o"))) in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "b")).

(* go: serde.out.go:28:6 *)
Definition GetArgDecode : val :=
  rec: "GetArgDecode" "b0" :=
    exception_do (let: "b0" := (mem.alloc "b0") in
    let: "err1" := (mem.alloc (type.zero_val #boolT)) in
    let: "b1" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a1" := (mem.alloc (type.zero_val #uint64T)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b0") in
    (func_call #safemarshal.safemarshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a1" <-[#uint64T] "$r0");;;
    do:  ("b1" <-[#sliceT] "$r1");;;
    do:  ("err1" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err1"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    return: (mem.alloc (let: "$Epoch" := (![#uint64T] "a1") in
     struct.make #GetArg [{
       "Epoch" ::= "$Epoch"
     }]), ![#sliceT] "b1", #false)).

(* go: serde.out.go:35:6 *)
Definition GetReplyEncode : val :=
  rec: "GetReplyEncode" "b0" "o" :=
    exception_do (let: "o" := (mem.alloc "o") in
    let: "b0" := (mem.alloc "b0") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "b0") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#sliceT] (struct.field_ref #GetReply #"Link"%go (![#ptrT] "o"))) in
    (func_call #safemarshal.safemarshal #"WriteSlice1D"%go) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#sliceT] (struct.field_ref #GetReply #"ServLinkSig"%go (![#ptrT] "o"))) in
    (func_call #safemarshal.safemarshal #"WriteSlice1D"%go) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#sliceT] (struct.field_ref #GetReply #"AdtrLinkSig"%go (![#ptrT] "o"))) in
    (func_call #safemarshal.safemarshal #"WriteSlice1D"%go) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#sliceT] (struct.field_ref #GetReply #"VrfPk"%go (![#ptrT] "o"))) in
    (func_call #safemarshal.safemarshal #"WriteSlice1D"%go) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#sliceT] (struct.field_ref #GetReply #"ServVrfSig"%go (![#ptrT] "o"))) in
    (func_call #safemarshal.safemarshal #"WriteSlice1D"%go) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#sliceT] (struct.field_ref #GetReply #"AdtrVrfSig"%go (![#ptrT] "o"))) in
    (func_call #safemarshal.safemarshal #"WriteSlice1D"%go) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#ktcore.Blame] (struct.field_ref #GetReply #"Err"%go (![#ptrT] "o"))) in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "b")).

(* go: serde.out.go:46:6 *)
Definition GetReplyDecode : val :=
  rec: "GetReplyDecode" "b0" :=
    exception_do (let: "b0" := (mem.alloc "b0") in
    let: "err1" := (mem.alloc (type.zero_val #boolT)) in
    let: "b1" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a1" := (mem.alloc (type.zero_val #sliceT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b0") in
    (func_call #safemarshal.safemarshal #"ReadSlice1D"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a1" <-[#sliceT] "$r0");;;
    do:  ("b1" <-[#sliceT] "$r1");;;
    do:  ("err1" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err1"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err2" := (mem.alloc (type.zero_val #boolT)) in
    let: "b2" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a2" := (mem.alloc (type.zero_val #sliceT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b1") in
    (func_call #safemarshal.safemarshal #"ReadSlice1D"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a2" <-[#sliceT] "$r0");;;
    do:  ("b2" <-[#sliceT] "$r1");;;
    do:  ("err2" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err2"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err3" := (mem.alloc (type.zero_val #boolT)) in
    let: "b3" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a3" := (mem.alloc (type.zero_val #sliceT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b2") in
    (func_call #safemarshal.safemarshal #"ReadSlice1D"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a3" <-[#sliceT] "$r0");;;
    do:  ("b3" <-[#sliceT] "$r1");;;
    do:  ("err3" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err3"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err4" := (mem.alloc (type.zero_val #boolT)) in
    let: "b4" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a4" := (mem.alloc (type.zero_val #sliceT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b3") in
    (func_call #safemarshal.safemarshal #"ReadSlice1D"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a4" <-[#sliceT] "$r0");;;
    do:  ("b4" <-[#sliceT] "$r1");;;
    do:  ("err4" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err4"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err5" := (mem.alloc (type.zero_val #boolT)) in
    let: "b5" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a5" := (mem.alloc (type.zero_val #sliceT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b4") in
    (func_call #safemarshal.safemarshal #"ReadSlice1D"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a5" <-[#sliceT] "$r0");;;
    do:  ("b5" <-[#sliceT] "$r1");;;
    do:  ("err5" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err5"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err6" := (mem.alloc (type.zero_val #boolT)) in
    let: "b6" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a6" := (mem.alloc (type.zero_val #sliceT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b5") in
    (func_call #safemarshal.safemarshal #"ReadSlice1D"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a6" <-[#sliceT] "$r0");;;
    do:  ("b6" <-[#sliceT] "$r1");;;
    do:  ("err6" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err6"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err7" := (mem.alloc (type.zero_val #boolT)) in
    let: "b7" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a7" := (mem.alloc (type.zero_val #uint64T)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b6") in
    (func_call #safemarshal.safemarshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a7" <-[#uint64T] "$r0");;;
    do:  ("b7" <-[#sliceT] "$r1");;;
    do:  ("err7" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err7"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    return: (mem.alloc (let: "$Link" := (![#sliceT] "a1") in
     let: "$ServLinkSig" := (![#sliceT] "a2") in
     let: "$AdtrLinkSig" := (![#sliceT] "a3") in
     let: "$VrfPk" := (![#sliceT] "a4") in
     let: "$ServVrfSig" := (![#sliceT] "a5") in
     let: "$AdtrVrfSig" := (![#sliceT] "a6") in
     let: "$Err" := (![#uint64T] "a7") in
     struct.make #GetReply [{
       "Link" ::= "$Link";
       "ServLinkSig" ::= "$ServLinkSig";
       "AdtrLinkSig" ::= "$AdtrLinkSig";
       "VrfPk" ::= "$VrfPk";
       "ServVrfSig" ::= "$ServVrfSig";
       "AdtrVrfSig" ::= "$AdtrVrfSig";
       "Err" ::= "$Err"
     }]), ![#sliceT] "b7", #false)).

Definition vars' : list (go_string * go_type) := [].

Definition functions' : list (go_string * val) := [("New"%go, New); ("getNextDig"%go, getNextDig); ("NewRpcAuditor"%go, NewRpcAuditor); ("CallUpdate"%go, CallUpdate); ("CallGet"%go, CallGet); ("UpdateReplyEncode"%go, UpdateReplyEncode); ("UpdateReplyDecode"%go, UpdateReplyDecode); ("GetArgEncode"%go, GetArgEncode); ("GetArgDecode"%go, GetArgDecode); ("GetReplyEncode"%go, GetReplyEncode); ("GetReplyDecode"%go, GetReplyDecode)].

Definition msets' : list (go_string * (list (go_string * val))) := [("Auditor"%go, []); ("Auditor'ptr"%go, [("Get"%go, Auditor__Get); ("Update"%go, Auditor__Update); ("updOnce"%go, Auditor__updOnce)]); ("history"%go, []); ("history'ptr"%go, []); ("serv"%go, []); ("serv'ptr"%go, []); ("UpdateReply"%go, []); ("UpdateReply'ptr"%go, []); ("GetArg"%go, []); ("GetArg'ptr"%go, []); ("GetReply"%go, []); ("GetReply'ptr"%go, [])].

#[global] Instance info' : PkgInfo auditor.auditor :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [bytes.bytes; sync.sync; advrpc.advrpc; cryptoffi.cryptoffi; hashchain.hashchain; ktcore.ktcore; merkle.merkle; server.server; safemarshal.safemarshal; marshal.marshal];
  |}.

Definition initialize' : val :=
  rec: "initialize'" <> :=
    globals.package_init auditor.auditor (λ: <>,
      exception_do (do:  marshal.initialize';;;
      do:  safemarshal.initialize';;;
      do:  server.initialize';;;
      do:  merkle.initialize';;;
      do:  ktcore.initialize';;;
      do:  hashchain.initialize';;;
      do:  cryptoffi.initialize';;;
      do:  advrpc.initialize';;;
      do:  sync.initialize';;;
      do:  bytes.initialize')
      ).

End code.
End auditor.
