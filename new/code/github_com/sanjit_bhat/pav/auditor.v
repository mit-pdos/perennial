(* autogenerated from github.com/sanjit-bhat/pav/auditor *)
Require Export New.code.bytes.
Require Export New.code.github_com.goose_lang.std.
Require Export New.code.github_com.sanjit_bhat.pav.advrpc.
Require Export New.code.github_com.sanjit_bhat.pav.cryptoffi.
Require Export New.code.github_com.sanjit_bhat.pav.hashchain.
Require Export New.code.github_com.sanjit_bhat.pav.ktcore.
Require Export New.code.github_com.sanjit_bhat.pav.merkle.
Require Export New.code.github_com.sanjit_bhat.pav.safemarshal.
Require Export New.code.github_com.sanjit_bhat.pav.server.
Require Export New.code.github_com.tchajed.marshal.
Require Export New.code.sync.

From New.golang Require Import defn.
Definition auditor : go_string := "github.com/sanjit-bhat/pav/auditor".

Module auditor.

Module Auditor. Definition id : go_string := "github.com/sanjit-bhat/pav/auditor.Auditor"%go. End Auditor.
Module history. Definition id : go_string := "github.com/sanjit-bhat/pav/auditor.history"%go. End history.
Module serv. Definition id : go_string := "github.com/sanjit-bhat/pav/auditor.serv"%go. End serv.
Module GetArg. Definition id : go_string := "github.com/sanjit-bhat/pav/auditor.GetArg"%go. End GetArg.
Module SignedLink. Definition id : go_string := "github.com/sanjit-bhat/pav/auditor.SignedLink"%go. End SignedLink.
Module SignedVrf. Definition id : go_string := "github.com/sanjit-bhat/pav/auditor.SignedVrf"%go. End SignedVrf.
Module GetReply. Definition id : go_string := "github.com/sanjit-bhat/pav/auditor.GetReply"%go. End GetReply.

Section code.
Context `{ffi_syntax}.


Definition Auditor : go_type := structT [
  "mu" :: ptrT;
  "sk" :: ptrT;
  "lastDig" :: sliceT;
  "startEp" :: uint64T;
  "hist" :: sliceT;
  "serv" :: ptrT
].
#[global] Typeclasses Opaque Auditor.
#[global] Opaque Auditor.

Definition history : go_type := structT [
  "link" :: sliceT;
  "servSig" :: sliceT;
  "adtrSig" :: sliceT
].
#[global] Typeclasses Opaque history.
#[global] Opaque history.

Definition serv : go_type := structT [
  "cli" :: ptrT;
  "sigPk" :: cryptoffi.SigPublicKey;
  "vrfPk" :: sliceT;
  "servVrfSig" :: sliceT;
  "adtrVrfSig" :: sliceT
].
#[global] Typeclasses Opaque serv.
#[global] Opaque serv.

Definition getNextLink : go_string := "github.com/sanjit-bhat/pav/auditor.getNextLink"%go.

(* Update queries server for a new epoch update and applies it.

   go: auditor.go:44:19 *)
Definition Auditor__Updateⁱᵐᵖˡ : val :=
  λ: "a" <>,
    with_defer: (let: "err" := (mem.alloc (type.zero_val #ktcore.Blame)) in
    let: "a" := (mem.alloc "a") in
    do:  ((method_call #(ptrT.id sync.RWMutex.id) #"Lock"%go (![#ptrT] (struct.field_ref #Auditor #"mu"%go (![#ptrT] "a")))) #());;;
    do:  (let: "$f" := (method_call #(ptrT.id sync.RWMutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref #Auditor #"mu"%go (![#ptrT] "a")))) in
    "$defer" <-[#funcT] (let: "$oldf" := (![#funcT] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    let: "prevEp" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (((![#uint64T] (struct.field_ref #Auditor #"startEp"%go (![#ptrT] "a"))) + (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref #Auditor #"hist"%go (![#ptrT] "a"))) in
    slice.len "$a0"))) - #(W64 1)) in
    do:  ("prevEp" <-[#uint64T] "$r0");;;
    let: "upd" := (mem.alloc (type.zero_val #sliceT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#ptrT] (struct.field_ref #serv #"cli"%go (![#ptrT] (struct.field_ref #Auditor #"serv"%go (![#ptrT] "a"))))) in
    let: "$a1" := (![#uint64T] "prevEp") in
    (func_call #server.CallAudit) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("upd" <-[#sliceT] "$r0");;;
    do:  ("err" <-[#ktcore.Blame] "$r1");;;
    (if: (![#ktcore.Blame] "err") ≠ ktcore.BlameNone
    then return: (![#ktcore.Blame] "err")
    else do:  #());;;
    let: "$range" := (![#sliceT] "upd") in
    (let: "p" := (mem.alloc (type.zero_val #ptrT)) in
    slice.for_range #ptrT "$range" (λ: "$key" "$value",
      do:  ("p" <-[#ptrT] "$value");;;
      do:  "$key";;;
      let: "sigPk" := (mem.alloc (type.zero_val #cryptoffi.SigPublicKey)) in
      let: "$r0" := (![#cryptoffi.SigPublicKey] (struct.field_ref #serv #"sigPk"%go (![#ptrT] (struct.field_ref #Auditor #"serv"%go (![#ptrT] "a"))))) in
      do:  ("sigPk" <-[#cryptoffi.SigPublicKey] "$r0");;;
      let: "prevEp" := (mem.alloc (type.zero_val #uint64T)) in
      let: "$r0" := (((![#uint64T] (struct.field_ref #Auditor #"startEp"%go (![#ptrT] "a"))) + (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref #Auditor #"hist"%go (![#ptrT] "a"))) in
      slice.len "$a0"))) - #(W64 1)) in
      do:  ("prevEp" <-[#uint64T] "$r0");;;
      let: "prevLink" := (mem.alloc (type.zero_val #sliceT)) in
      let: "$r0" := (![#sliceT] (struct.field_ref #history #"link"%go (![#ptrT] (slice.elem_ref #ptrT (![#sliceT] (struct.field_ref #Auditor #"hist"%go (![#ptrT] "a"))) ((let: "$a0" := (![#sliceT] (struct.field_ref #Auditor #"hist"%go (![#ptrT] "a"))) in
      slice.len "$a0") - #(W64 1)))))) in
      do:  ("prevLink" <-[#sliceT] "$r0");;;
      let: "errb" := (mem.alloc (type.zero_val #boolT)) in
      let: "link" := (mem.alloc (type.zero_val #sliceT)) in
      let: "dig" := (mem.alloc (type.zero_val #sliceT)) in
      let: "ep" := (mem.alloc (type.zero_val #uint64T)) in
      let: ((("$ret0", "$ret1"), "$ret2"), "$ret3") := (let: "$a0" := (![#cryptoffi.SigPublicKey] "sigPk") in
      let: "$a1" := (![#uint64T] "prevEp") in
      let: "$a2" := (![#sliceT] (struct.field_ref #Auditor #"lastDig"%go (![#ptrT] "a"))) in
      let: "$a3" := (![#sliceT] "prevLink") in
      let: "$a4" := (![#ptrT] "p") in
      (func_call #getNextLink) "$a0" "$a1" "$a2" "$a3" "$a4") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      let: "$r2" := "$ret2" in
      let: "$r3" := "$ret3" in
      do:  ("ep" <-[#uint64T] "$r0");;;
      do:  ("dig" <-[#sliceT] "$r1");;;
      do:  ("link" <-[#sliceT] "$r2");;;
      do:  ("errb" <-[#boolT] "$r3");;;
      (if: ![#boolT] "errb"
      then
        let: "$r0" := ktcore.BlameServFull in
        do:  ("err" <-[#ktcore.Blame] "$r0");;;
        return: (![#ktcore.Blame] "err")
      else do:  #());;;
      let: "sig" := (mem.alloc (type.zero_val #sliceT)) in
      let: "$r0" := (let: "$a0" := (![#ptrT] (struct.field_ref #Auditor #"sk"%go (![#ptrT] "a"))) in
      let: "$a1" := (![#uint64T] "ep") in
      let: "$a2" := (![#sliceT] "link") in
      (func_call #ktcore.SignLink) "$a0" "$a1" "$a2") in
      do:  ("sig" <-[#sliceT] "$r0");;;
      let: "$r0" := (![#sliceT] "dig") in
      do:  ((struct.field_ref #Auditor #"lastDig"%go (![#ptrT] "a")) <-[#sliceT] "$r0");;;
      let: "info" := (mem.alloc (type.zero_val #ptrT)) in
      let: "$r0" := (mem.alloc (let: "$link" := (![#sliceT] "link") in
      let: "$servSig" := (![#sliceT] (struct.field_ref #ktcore.AuditProof #"LinkSig"%go (![#ptrT] "p"))) in
      let: "$adtrSig" := (![#sliceT] "sig") in
      struct.make #history [{
        "link" ::= "$link";
        "servSig" ::= "$servSig";
        "adtrSig" ::= "$adtrSig"
      }])) in
      do:  ("info" <-[#ptrT] "$r0");;;
      let: "$r0" := (let: "$a0" := (![#sliceT] (struct.field_ref #Auditor #"hist"%go (![#ptrT] "a"))) in
      let: "$a1" := ((let: "$sl0" := (![#ptrT] "info") in
      slice.literal #ptrT ["$sl0"])) in
      (slice.append #ptrT) "$a0" "$a1") in
      do:  ((struct.field_ref #Auditor #"hist"%go (![#ptrT] "a")) <-[#sliceT] "$r0")));;;
    return: (![#ktcore.Blame] "err")).

Definition SignedVrf : go_type := structT [
  "VrfPk" :: sliceT;
  "ServSig" :: sliceT;
  "AdtrSig" :: sliceT
].
#[global] Typeclasses Opaque SignedVrf.
#[global] Opaque SignedVrf.

Definition SignedLink : go_type := structT [
  "Link" :: sliceT;
  "ServSig" :: sliceT;
  "AdtrSig" :: sliceT
].
#[global] Typeclasses Opaque SignedLink.
#[global] Opaque SignedLink.

(* Get returns the auditor's info for a particular epoch.
   it errors if the epoch is out of bounds.

   go: auditor.go:74:19 *)
Definition Auditor__Getⁱᵐᵖˡ : val :=
  λ: "a" "epoch",
    with_defer: (let: "err" := (mem.alloc (type.zero_val #boolT)) in
    let: "vrf" := (mem.alloc (type.zero_val #ptrT)) in
    let: "link" := (mem.alloc (type.zero_val #ptrT)) in
    let: "a" := (mem.alloc "a") in
    let: "epoch" := (mem.alloc "epoch") in
    do:  ((method_call #(ptrT.id sync.RWMutex.id) #"RLock"%go (![#ptrT] (struct.field_ref #Auditor #"mu"%go (![#ptrT] "a")))) #());;;
    do:  (let: "$f" := (method_call #(ptrT.id sync.RWMutex.id) #"RUnlock"%go (![#ptrT] (struct.field_ref #Auditor #"mu"%go (![#ptrT] "a")))) in
    "$defer" <-[#funcT] (let: "$oldf" := (![#funcT] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    (if: (![#uint64T] "epoch") < (![#uint64T] (struct.field_ref #Auditor #"startEp"%go (![#ptrT] "a")))
    then
      let: "$r0" := #true in
      do:  ("err" <-[#boolT] "$r0");;;
      return: (![#ptrT] "link", ![#ptrT] "vrf", ![#boolT] "err")
    else do:  #());;;
    let: "lastEp" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (((![#uint64T] (struct.field_ref #Auditor #"startEp"%go (![#ptrT] "a"))) + (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref #Auditor #"hist"%go (![#ptrT] "a"))) in
    slice.len "$a0"))) - #(W64 1)) in
    do:  ("lastEp" <-[#uint64T] "$r0");;;
    (if: (![#uint64T] "epoch") > (![#uint64T] "lastEp")
    then
      let: "$r0" := #true in
      do:  ("err" <-[#boolT] "$r0");;;
      return: (![#ptrT] "link", ![#ptrT] "vrf", ![#boolT] "err")
    else do:  #());;;
    let: "x" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (![#ptrT] (slice.elem_ref #ptrT (![#sliceT] (struct.field_ref #Auditor #"hist"%go (![#ptrT] "a"))) ((![#uint64T] "epoch") - (![#uint64T] (struct.field_ref #Auditor #"startEp"%go (![#ptrT] "a")))))) in
    do:  ("x" <-[#ptrT] "$r0");;;
    let: "$r0" := (mem.alloc (let: "$Link" := (![#sliceT] (struct.field_ref #history #"link"%go (![#ptrT] "x"))) in
    let: "$ServSig" := (![#sliceT] (struct.field_ref #history #"servSig"%go (![#ptrT] "x"))) in
    let: "$AdtrSig" := (![#sliceT] (struct.field_ref #history #"adtrSig"%go (![#ptrT] "x"))) in
    struct.make #SignedLink [{
      "Link" ::= "$Link";
      "ServSig" ::= "$ServSig";
      "AdtrSig" ::= "$AdtrSig"
    }])) in
    do:  ("link" <-[#ptrT] "$r0");;;
    let: "$r0" := (mem.alloc (let: "$VrfPk" := (![#sliceT] (struct.field_ref #serv #"vrfPk"%go (![#ptrT] (struct.field_ref #Auditor #"serv"%go (![#ptrT] "a"))))) in
    let: "$ServSig" := (![#sliceT] (struct.field_ref #serv #"servVrfSig"%go (![#ptrT] (struct.field_ref #Auditor #"serv"%go (![#ptrT] "a"))))) in
    let: "$AdtrSig" := (![#sliceT] (struct.field_ref #serv #"adtrVrfSig"%go (![#ptrT] (struct.field_ref #Auditor #"serv"%go (![#ptrT] "a"))))) in
    struct.make #SignedVrf [{
      "VrfPk" ::= "$VrfPk";
      "ServSig" ::= "$ServSig";
      "AdtrSig" ::= "$AdtrSig"
    }])) in
    do:  ("vrf" <-[#ptrT] "$r0");;;
    return: (![#ptrT] "link", ![#ptrT] "vrf", ![#boolT] "err")).

Definition New : go_string := "github.com/sanjit-bhat/pav/auditor.New"%go.

Definition CheckStartVrf : go_string := "github.com/sanjit-bhat/pav/auditor.CheckStartVrf"%go.

Definition CheckStartChain : go_string := "github.com/sanjit-bhat/pav/auditor.CheckStartChain"%go.

(* go: auditor.go:95:6 *)
Definition Newⁱᵐᵖˡ : val :=
  λ: "servAddr" "servPk",
    exception_do (let: "err" := (mem.alloc (type.zero_val #ktcore.Blame)) in
    let: "sigPk" := (mem.alloc (type.zero_val #cryptoffi.SigPublicKey)) in
    let: "a" := (mem.alloc (type.zero_val #ptrT)) in
    let: "servPk" := (mem.alloc "servPk") in
    let: "servAddr" := (mem.alloc "servAddr") in
    let: "cli" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := (![#uint64T] "servAddr") in
    (func_call #advrpc.Dial) "$a0") in
    do:  ("cli" <-[#ptrT] "$r0");;;
    let: "vrf" := (mem.alloc (type.zero_val #ptrT)) in
    let: "chain" := (mem.alloc (type.zero_val #ptrT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#ptrT] "cli") in
    (func_call #server.CallStart) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("chain" <-[#ptrT] "$r0");;;
    do:  ("vrf" <-[#ptrT] "$r1");;;
    do:  ("err" <-[#ktcore.Blame] "$r2");;;
    (if: (![#ktcore.Blame] "err") ≠ ktcore.BlameNone
    then return: (![#ptrT] "a", ![#cryptoffi.SigPublicKey] "sigPk", ![#ktcore.Blame] "err")
    else do:  #());;;
    let: "errb" := (mem.alloc (type.zero_val #boolT)) in
    let: "startLink" := (mem.alloc (type.zero_val #sliceT)) in
    let: "startDig" := (mem.alloc (type.zero_val #sliceT)) in
    let: "startEp" := (mem.alloc (type.zero_val #uint64T)) in
    let: ((("$ret0", "$ret1"), "$ret2"), "$ret3") := (let: "$a0" := (![#cryptoffi.SigPublicKey] "servPk") in
    let: "$a1" := (![#ptrT] "chain") in
    (func_call #CheckStartChain) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    let: "$r3" := "$ret3" in
    do:  ("startEp" <-[#uint64T] "$r0");;;
    do:  ("startDig" <-[#sliceT] "$r1");;;
    do:  ("startLink" <-[#sliceT] "$r2");;;
    do:  ("errb" <-[#boolT] "$r3");;;
    (if: ![#boolT] "errb"
    then
      let: "$r0" := ktcore.BlameServFull in
      do:  ("err" <-[#ktcore.Blame] "$r0");;;
      return: (![#ptrT] "a", ![#cryptoffi.SigPublicKey] "sigPk", ![#ktcore.Blame] "err")
    else do:  #());;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#cryptoffi.SigPublicKey] "servPk") in
    let: "$a1" := (![#ptrT] "vrf") in
    (func_call #CheckStartVrf) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  "$r0";;;
    do:  ("errb" <-[#boolT] "$r1");;;
    (if: ![#boolT] "errb"
    then
      let: "$r0" := ktcore.BlameServFull in
      do:  ("err" <-[#ktcore.Blame] "$r0");;;
      return: (![#ptrT] "a", ![#cryptoffi.SigPublicKey] "sigPk", ![#ktcore.Blame] "err")
    else do:  #());;;
    let: "mu" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #sync.RWMutex)) in
    do:  ("mu" <-[#ptrT] "$r0");;;
    let: "sk" := (mem.alloc (type.zero_val #ptrT)) in
    let: ("$ret0", "$ret1") := ((func_call #cryptoffi.SigGenerateKey) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("sigPk" <-[#cryptoffi.SigPublicKey] "$r0");;;
    do:  ("sk" <-[#ptrT] "$r1");;;
    let: "linkSig" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#ptrT] "sk") in
    let: "$a1" := (![#uint64T] "startEp") in
    let: "$a2" := (![#sliceT] "startLink") in
    (func_call #ktcore.SignLink) "$a0" "$a1" "$a2") in
    do:  ("linkSig" <-[#sliceT] "$r0");;;
    let: "h" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (let: "$link" := (![#sliceT] "startLink") in
    let: "$servSig" := (![#sliceT] (struct.field_ref #server.StartChain #"LinkSig"%go (![#ptrT] "chain"))) in
    let: "$adtrSig" := (![#sliceT] "linkSig") in
    struct.make #history [{
      "link" ::= "$link";
      "servSig" ::= "$servSig";
      "adtrSig" ::= "$adtrSig"
    }])) in
    do:  ("h" <-[#ptrT] "$r0");;;
    let: "vrfSig" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#ptrT] "sk") in
    let: "$a1" := (![#sliceT] (struct.field_ref #server.StartVrf #"VrfPk"%go (![#ptrT] "vrf"))) in
    (func_call #ktcore.SignVrf) "$a0" "$a1") in
    do:  ("vrfSig" <-[#sliceT] "$r0");;;
    let: "serv" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (let: "$cli" := (![#ptrT] "cli") in
    let: "$sigPk" := (![#cryptoffi.SigPublicKey] "servPk") in
    let: "$vrfPk" := (![#sliceT] (struct.field_ref #server.StartVrf #"VrfPk"%go (![#ptrT] "vrf"))) in
    let: "$servVrfSig" := (![#sliceT] (struct.field_ref #server.StartVrf #"VrfSig"%go (![#ptrT] "vrf"))) in
    let: "$adtrVrfSig" := (![#sliceT] "vrfSig") in
    struct.make #serv [{
      "cli" ::= "$cli";
      "sigPk" ::= "$sigPk";
      "vrfPk" ::= "$vrfPk";
      "servVrfSig" ::= "$servVrfSig";
      "adtrVrfSig" ::= "$adtrVrfSig"
    }])) in
    do:  ("serv" <-[#ptrT] "$r0");;;
    let: "$r0" := (mem.alloc (let: "$mu" := (![#ptrT] "mu") in
    let: "$sk" := (![#ptrT] "sk") in
    let: "$lastDig" := (![#sliceT] "startDig") in
    let: "$startEp" := (![#uint64T] "startEp") in
    let: "$hist" := ((let: "$sl0" := (![#ptrT] "h") in
    slice.literal #ptrT ["$sl0"])) in
    let: "$serv" := (![#ptrT] "serv") in
    struct.make #Auditor [{
      "mu" ::= "$mu";
      "sk" ::= "$sk";
      "lastDig" ::= "$lastDig";
      "startEp" ::= "$startEp";
      "hist" ::= "$hist";
      "serv" ::= "$serv"
    }])) in
    do:  ("a" <-[#ptrT] "$r0");;;
    return: (![#ptrT] "a", ![#cryptoffi.SigPublicKey] "sigPk", ![#ktcore.Blame] "err")).

Definition getNextDig : go_string := "github.com/sanjit-bhat/pav/auditor.getNextDig"%go.

(* go: auditor.go:122:6 *)
Definition getNextLinkⁱᵐᵖˡ : val :=
  λ: "sigPk" "prevEp" "prevDig" "prevLink" "p",
    exception_do (let: "err" := (mem.alloc (type.zero_val #boolT)) in
    let: "link" := (mem.alloc (type.zero_val #sliceT)) in
    let: "dig" := (mem.alloc (type.zero_val #sliceT)) in
    let: "ep" := (mem.alloc (type.zero_val #uint64T)) in
    let: "p" := (mem.alloc "p") in
    let: "prevLink" := (mem.alloc "prevLink") in
    let: "prevDig" := (mem.alloc "prevDig") in
    let: "prevEp" := (mem.alloc "prevEp") in
    let: "sigPk" := (mem.alloc "sigPk") in
    (if: (~ (let: "$a0" := (![#uint64T] "prevEp") in
    let: "$a1" := #(W64 1) in
    (func_call #std.SumNoOverflow) "$a0" "$a1"))
    then
      let: "$r0" := #true in
      do:  ("err" <-[#boolT] "$r0");;;
      return: (![#uint64T] "ep", ![#sliceT] "dig", ![#sliceT] "link", ![#boolT] "err")
    else do:  #());;;
    let: "$r0" := ((![#uint64T] "prevEp") + #(W64 1)) in
    do:  ("ep" <-[#uint64T] "$r0");;;
    (let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "prevDig") in
    let: "$a1" := (![#sliceT] (struct.field_ref #ktcore.AuditProof #"Updates"%go (![#ptrT] "p"))) in
    (func_call #getNextDig) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("dig" <-[#sliceT] "$r0");;;
    do:  ("err" <-[#boolT] "$r1");;;
    (if: ![#boolT] "err"
    then return: (![#uint64T] "ep", ![#sliceT] "dig", ![#sliceT] "link", ![#boolT] "err")
    else do:  #()));;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "prevLink") in
    let: "$a1" := (![#sliceT] "dig") in
    (func_call #hashchain.GetNextLink) "$a0" "$a1") in
    do:  ("link" <-[#sliceT] "$r0");;;
    (if: let: "$a0" := (![#cryptoffi.SigPublicKey] "sigPk") in
    let: "$a1" := (![#uint64T] "ep") in
    let: "$a2" := (![#sliceT] "link") in
    let: "$a3" := (![#sliceT] (struct.field_ref #ktcore.AuditProof #"LinkSig"%go (![#ptrT] "p"))) in
    (func_call #ktcore.VerifyLinkSig) "$a0" "$a1" "$a2" "$a3"
    then
      let: "$r0" := #true in
      do:  ("err" <-[#boolT] "$r0");;;
      return: (![#uint64T] "ep", ![#sliceT] "dig", ![#sliceT] "link", ![#boolT] "err")
    else do:  #());;;
    return: (![#uint64T] "ep", ![#sliceT] "dig", ![#sliceT] "link", ![#boolT] "err")).

(* go: auditor.go:139:6 *)
Definition getNextDigⁱᵐᵖˡ : val :=
  λ: "prevDig" "updates",
    exception_do (let: "err" := (mem.alloc (type.zero_val #boolT)) in
    let: "dig" := (mem.alloc (type.zero_val #sliceT)) in
    let: "updates" := (mem.alloc "updates") in
    let: "prevDig" := (mem.alloc "prevDig") in
    let: "$r0" := (![#sliceT] "prevDig") in
    do:  ("dig" <-[#sliceT] "$r0");;;
    let: "$range" := (![#sliceT] "updates") in
    (let: "u" := (mem.alloc (type.zero_val #ptrT)) in
    slice.for_range #ptrT "$range" (λ: "$key" "$value",
      do:  ("u" <-[#ptrT] "$value");;;
      do:  "$key";;;
      let: "next" := (mem.alloc (type.zero_val #sliceT)) in
      let: "prev" := (mem.alloc (type.zero_val #sliceT)) in
      let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] (struct.field_ref #ktcore.UpdateProof #"MapLabel"%go (![#ptrT] "u"))) in
      let: "$a1" := (![#sliceT] (struct.field_ref #ktcore.UpdateProof #"MapVal"%go (![#ptrT] "u"))) in
      let: "$a2" := (![#sliceT] (struct.field_ref #ktcore.UpdateProof #"NonMembProof"%go (![#ptrT] "u"))) in
      (func_call #merkle.VerifyUpdate) "$a0" "$a1" "$a2") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      let: "$r2" := "$ret2" in
      do:  ("prev" <-[#sliceT] "$r0");;;
      do:  ("next" <-[#sliceT] "$r1");;;
      do:  ("err" <-[#boolT] "$r2");;;
      (if: ![#boolT] "err"
      then return: (![#sliceT] "dig", ![#boolT] "err")
      else do:  #());;;
      (if: (~ (let: "$a0" := (![#sliceT] "dig") in
      let: "$a1" := (![#sliceT] "prev") in
      (func_call #bytes.Equal) "$a0" "$a1"))
      then
        let: "$r0" := #true in
        do:  ("err" <-[#boolT] "$r0");;;
        return: (![#sliceT] "dig", ![#boolT] "err")
      else do:  #());;;
      let: "$r0" := (![#sliceT] "next") in
      do:  ("dig" <-[#sliceT] "$r0")));;;
    return: (![#sliceT] "dig", ![#boolT] "err")).

(* go: auditor.go:156:6 *)
Definition CheckStartChainⁱᵐᵖˡ : val :=
  λ: "servPk" "chain",
    exception_do (let: "err" := (mem.alloc (type.zero_val #boolT)) in
    let: "link" := (mem.alloc (type.zero_val #sliceT)) in
    let: "dig" := (mem.alloc (type.zero_val #sliceT)) in
    let: "ep" := (mem.alloc (type.zero_val #uint64T)) in
    let: "chain" := (mem.alloc "chain") in
    let: "servPk" := (mem.alloc "servPk") in
    (if: (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref #server.StartChain #"PrevLink"%go (![#ptrT] "chain"))) in
    slice.len "$a0")) ≠ cryptoffi.HashLen
    then
      let: "$r0" := #true in
      do:  ("err" <-[#boolT] "$r0");;;
      return: (![#uint64T] "ep", ![#sliceT] "dig", ![#sliceT] "link", ![#boolT] "err")
    else do:  #());;;
    let: "errb" := (mem.alloc (type.zero_val #boolT)) in
    let: "extLen" := (mem.alloc (type.zero_val #uint64T)) in
    let: ((("$ret0", "$ret1"), "$ret2"), "$ret3") := (let: "$a0" := (![#sliceT] (struct.field_ref #server.StartChain #"PrevLink"%go (![#ptrT] "chain"))) in
    let: "$a1" := (![#sliceT] (struct.field_ref #server.StartChain #"ChainProof"%go (![#ptrT] "chain"))) in
    (func_call #hashchain.Verify) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    let: "$r3" := "$ret3" in
    do:  ("extLen" <-[#uint64T] "$r0");;;
    do:  ("dig" <-[#sliceT] "$r1");;;
    do:  ("link" <-[#sliceT] "$r2");;;
    do:  ("errb" <-[#boolT] "$r3");;;
    (if: ![#boolT] "errb"
    then
      let: "$r0" := #true in
      do:  ("err" <-[#boolT] "$r0");;;
      return: (![#uint64T] "ep", ![#sliceT] "dig", ![#sliceT] "link", ![#boolT] "err")
    else do:  #());;;
    (if: (![#uint64T] "extLen") = #(W64 0)
    then
      let: "$r0" := #true in
      do:  ("err" <-[#boolT] "$r0");;;
      return: (![#uint64T] "ep", ![#sliceT] "dig", ![#sliceT] "link", ![#boolT] "err")
    else do:  #());;;
    (if: (~ (let: "$a0" := (![#uint64T] (struct.field_ref #server.StartChain #"PrevEpochLen"%go (![#ptrT] "chain"))) in
    let: "$a1" := ((![#uint64T] "extLen") - #(W64 1)) in
    (func_call #std.SumNoOverflow) "$a0" "$a1"))
    then
      let: "$r0" := #true in
      do:  ("err" <-[#boolT] "$r0");;;
      return: (![#uint64T] "ep", ![#sliceT] "dig", ![#sliceT] "link", ![#boolT] "err")
    else do:  #());;;
    let: "$r0" := (((![#uint64T] (struct.field_ref #server.StartChain #"PrevEpochLen"%go (![#ptrT] "chain"))) + (![#uint64T] "extLen")) - #(W64 1)) in
    do:  ("ep" <-[#uint64T] "$r0");;;
    (if: let: "$a0" := (![#cryptoffi.SigPublicKey] "servPk") in
    let: "$a1" := (![#uint64T] "ep") in
    let: "$a2" := (![#sliceT] "link") in
    let: "$a3" := (![#sliceT] (struct.field_ref #server.StartChain #"LinkSig"%go (![#ptrT] "chain"))) in
    (func_call #ktcore.VerifyLinkSig) "$a0" "$a1" "$a2" "$a3"
    then
      let: "$r0" := #true in
      do:  ("err" <-[#boolT] "$r0");;;
      return: (![#uint64T] "ep", ![#sliceT] "dig", ![#sliceT] "link", ![#boolT] "err")
    else do:  #());;;
    return: (![#uint64T] "ep", ![#sliceT] "dig", ![#sliceT] "link", ![#boolT] "err")).

(* go: auditor.go:183:6 *)
Definition CheckStartVrfⁱᵐᵖˡ : val :=
  λ: "servPk" "vrf",
    exception_do (let: "err" := (mem.alloc (type.zero_val #boolT)) in
    let: "vrfPk" := (mem.alloc (type.zero_val #ptrT)) in
    let: "vrf" := (mem.alloc "vrf") in
    let: "servPk" := (mem.alloc "servPk") in
    let: "errb" := (mem.alloc (type.zero_val #boolT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] (struct.field_ref #server.StartVrf #"VrfPk"%go (![#ptrT] "vrf"))) in
    (func_call #cryptoffi.VrfPublicKeyDecode) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("vrfPk" <-[#ptrT] "$r0");;;
    do:  ("errb" <-[#boolT] "$r1");;;
    (if: ![#boolT] "errb"
    then
      let: "$r0" := #true in
      do:  ("err" <-[#boolT] "$r0");;;
      return: (![#ptrT] "vrfPk", ![#boolT] "err")
    else do:  #());;;
    (if: let: "$a0" := (![#cryptoffi.SigPublicKey] "servPk") in
    let: "$a1" := (![#sliceT] (struct.field_ref #server.StartVrf #"VrfPk"%go (![#ptrT] "vrf"))) in
    let: "$a2" := (![#sliceT] (struct.field_ref #server.StartVrf #"VrfSig"%go (![#ptrT] "vrf"))) in
    (func_call #ktcore.VerifyVrfSig) "$a0" "$a1" "$a2"
    then
      let: "$r0" := #true in
      do:  ("err" <-[#boolT] "$r0");;;
      return: (![#ptrT] "vrfPk", ![#boolT] "err")
    else do:  #());;;
    return: (![#ptrT] "vrfPk", ![#boolT] "err")).

Definition GetRpc : val := #(W64 0).

Definition NewRpcAuditor : go_string := "github.com/sanjit-bhat/pav/auditor.NewRpcAuditor"%go.

Definition GetReplyEncode : go_string := "github.com/sanjit-bhat/pav/auditor.GetReplyEncode"%go.

Definition GetReply : go_type := structT [
  "Link" :: ptrT;
  "Vrf" :: ptrT;
  "Err" :: boolT
].
#[global] Typeclasses Opaque GetReply.
#[global] Opaque GetReply.

Definition GetArg : go_type := structT [
  "Epoch" :: uint64T
].
#[global] Typeclasses Opaque GetArg.
#[global] Opaque GetArg.

Definition GetArgDecode : go_string := "github.com/sanjit-bhat/pav/auditor.GetArgDecode"%go.

(* go: rpc.go:12:6 *)
Definition NewRpcAuditorⁱᵐᵖˡ : val :=
  λ: "adtr",
    exception_do (let: "adtr" := (mem.alloc "adtr") in
    let: "h" := (mem.alloc (type.zero_val (type.mapT #uint64T #funcT))) in
    let: "$r0" := (map.make #uint64T #funcT) in
    do:  ("h" <-[type.mapT #uint64T #funcT] "$r0");;;
    let: "$r0" := (λ: "arg" "reply",
      exception_do (let: "reply" := (mem.alloc "reply") in
      let: "arg" := (mem.alloc "arg") in
      let: "err" := (mem.alloc (type.zero_val #boolT)) in
      let: "a" := (mem.alloc (type.zero_val #ptrT)) in
      let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "arg") in
      (func_call #GetArgDecode) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      let: "$r2" := "$ret2" in
      do:  ("a" <-[#ptrT] "$r0");;;
      do:  "$r1";;;
      do:  ("err" <-[#boolT] "$r2");;;
      (if: ![#boolT] "err"
      then
        let: "r" := (mem.alloc (type.zero_val #ptrT)) in
        let: "$r0" := (mem.alloc (let: "$Err" := #true in
        struct.make #GetReply [{
          "Link" ::= type.zero_val #ptrT;
          "Vrf" ::= type.zero_val #ptrT;
          "Err" ::= "$Err"
        }])) in
        do:  ("r" <-[#ptrT] "$r0");;;
        let: "$r0" := (let: "$a0" := (![#sliceT] (![#ptrT] "reply")) in
        let: "$a1" := (![#ptrT] "r") in
        (func_call #GetReplyEncode) "$a0" "$a1") in
        do:  ((![#ptrT] "reply") <-[#sliceT] "$r0");;;
        return: (#())
      else do:  #());;;
      let: "r2" := (mem.alloc (type.zero_val #boolT)) in
      let: "r1" := (mem.alloc (type.zero_val #ptrT)) in
      let: "r0" := (mem.alloc (type.zero_val #ptrT)) in
      let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#uint64T] (struct.field_ref #GetArg #"Epoch"%go (![#ptrT] "a"))) in
      (method_call #(ptrT.id Auditor.id) #"Get"%go (![#ptrT] "adtr")) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      let: "$r2" := "$ret2" in
      do:  ("r0" <-[#ptrT] "$r0");;;
      do:  ("r1" <-[#ptrT] "$r1");;;
      do:  ("r2" <-[#boolT] "$r2");;;
      let: "r" := (mem.alloc (type.zero_val #ptrT)) in
      let: "$r0" := (mem.alloc (let: "$Link" := (![#ptrT] "r0") in
      let: "$Vrf" := (![#ptrT] "r1") in
      let: "$Err" := (![#boolT] "r2") in
      struct.make #GetReply [{
        "Link" ::= "$Link";
        "Vrf" ::= "$Vrf";
        "Err" ::= "$Err"
      }])) in
      do:  ("r" <-[#ptrT] "$r0");;;
      let: "$r0" := (let: "$a0" := (![#sliceT] (![#ptrT] "reply")) in
      let: "$a1" := (![#ptrT] "r") in
      (func_call #GetReplyEncode) "$a0" "$a1") in
      do:  ((![#ptrT] "reply") <-[#sliceT] "$r0");;;
      return: #())
      ) in
    do:  (map.insert (![type.mapT #uint64T #funcT] "h") GetRpc "$r0");;;
    return: (let: "$a0" := (![type.mapT #uint64T #funcT] "h") in
     (func_call #advrpc.NewServer) "$a0")).

Definition CallGet : go_string := "github.com/sanjit-bhat/pav/auditor.CallGet"%go.

Definition GetReplyDecode : go_string := "github.com/sanjit-bhat/pav/auditor.GetReplyDecode"%go.

Definition GetArgEncode : go_string := "github.com/sanjit-bhat/pav/auditor.GetArgEncode"%go.

(* go: rpc.go:28:6 *)
Definition CallGetⁱᵐᵖˡ : val :=
  λ: "c" "epoch",
    exception_do (let: "err" := (mem.alloc (type.zero_val #ktcore.Blame)) in
    let: "vrf" := (mem.alloc (type.zero_val #ptrT)) in
    let: "link" := (mem.alloc (type.zero_val #ptrT)) in
    let: "epoch" := (mem.alloc "epoch") in
    let: "c" := (mem.alloc "c") in
    let: "a" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (let: "$Epoch" := (![#uint64T] "epoch") in
    struct.make #GetArg [{
      "Epoch" ::= "$Epoch"
    }])) in
    do:  ("a" <-[#ptrT] "$r0");;;
    let: "ab" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := #slice.nil in
    let: "$a1" := (![#ptrT] "a") in
    (func_call #GetArgEncode) "$a0" "$a1") in
    do:  ("ab" <-[#sliceT] "$r0");;;
    let: "rb" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #sliceT)) in
    do:  ("rb" <-[#ptrT] "$r0");;;
    (if: let: "$a0" := GetRpc in
    let: "$a1" := (![#sliceT] "ab") in
    let: "$a2" := (![#ptrT] "rb") in
    (method_call #(ptrT.id advrpc.Client.id) #"Call"%go (![#ptrT] "c")) "$a0" "$a1" "$a2"
    then
      let: "$r0" := ktcore.BlameUnknown in
      do:  ("err" <-[#ktcore.Blame] "$r0");;;
      return: (![#ptrT] "link", ![#ptrT] "vrf", ![#ktcore.Blame] "err")
    else do:  #());;;
    let: "errb" := (mem.alloc (type.zero_val #boolT)) in
    let: "r" := (mem.alloc (type.zero_val #ptrT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] (![#ptrT] "rb")) in
    (func_call #GetReplyDecode) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("r" <-[#ptrT] "$r0");;;
    do:  "$r1";;;
    do:  ("errb" <-[#boolT] "$r2");;;
    let: "$r0" := (![#ptrT] (struct.field_ref #GetReply #"Link"%go (![#ptrT] "r"))) in
    do:  ("link" <-[#ptrT] "$r0");;;
    let: "$r0" := (![#ptrT] (struct.field_ref #GetReply #"Vrf"%go (![#ptrT] "r"))) in
    do:  ("vrf" <-[#ptrT] "$r0");;;
    (if: ![#boolT] "errb"
    then
      let: "$r0" := ktcore.BlameAdtrFull in
      do:  ("err" <-[#ktcore.Blame] "$r0");;;
      return: (![#ptrT] "link", ![#ptrT] "vrf", ![#ktcore.Blame] "err")
    else do:  #());;;
    (if: ![#boolT] (struct.field_ref #GetReply #"Err"%go (![#ptrT] "r"))
    then
      let: "$r0" := ktcore.BlameUnknown in
      do:  ("err" <-[#ktcore.Blame] "$r0");;;
      return: (![#ptrT] "link", ![#ptrT] "vrf", ![#ktcore.Blame] "err")
    else do:  #());;;
    return: (![#ptrT] "link", ![#ptrT] "vrf", ![#ktcore.Blame] "err")).

(* go: serde.out.go:10:6 *)
Definition GetArgEncodeⁱᵐᵖˡ : val :=
  λ: "b0" "o",
    exception_do (let: "o" := (mem.alloc "o") in
    let: "b0" := (mem.alloc "b0") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "b0") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#uint64T] (struct.field_ref #GetArg #"Epoch"%go (![#ptrT] "o"))) in
    (func_call #marshal.WriteInt) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "b")).

(* go: serde.out.go:15:6 *)
Definition GetArgDecodeⁱᵐᵖˡ : val :=
  λ: "b0",
    exception_do (let: "b0" := (mem.alloc "b0") in
    let: "err1" := (mem.alloc (type.zero_val #boolT)) in
    let: "b1" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a1" := (mem.alloc (type.zero_val #uint64T)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b0") in
    (func_call #safemarshal.ReadInt) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a1" <-[#uint64T] "$r0");;;
    do:  ("b1" <-[#sliceT] "$r1");;;
    do:  ("err1" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err1"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    return: (mem.alloc (let: "$Epoch" := (![#uint64T] "a1") in
     struct.make #GetArg [{
       "Epoch" ::= "$Epoch"
     }]), ![#sliceT] "b1", #false)).

Definition SignedLinkEncode : go_string := "github.com/sanjit-bhat/pav/auditor.SignedLinkEncode"%go.

(* go: serde.out.go:22:6 *)
Definition SignedLinkEncodeⁱᵐᵖˡ : val :=
  λ: "b0" "o",
    exception_do (let: "o" := (mem.alloc "o") in
    let: "b0" := (mem.alloc "b0") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "b0") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#sliceT] (struct.field_ref #SignedLink #"Link"%go (![#ptrT] "o"))) in
    (func_call #safemarshal.WriteSlice1D) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#sliceT] (struct.field_ref #SignedLink #"ServSig"%go (![#ptrT] "o"))) in
    (func_call #safemarshal.WriteSlice1D) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#sliceT] (struct.field_ref #SignedLink #"AdtrSig"%go (![#ptrT] "o"))) in
    (func_call #safemarshal.WriteSlice1D) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "b")).

Definition SignedLinkDecode : go_string := "github.com/sanjit-bhat/pav/auditor.SignedLinkDecode"%go.

(* go: serde.out.go:29:6 *)
Definition SignedLinkDecodeⁱᵐᵖˡ : val :=
  λ: "b0",
    exception_do (let: "b0" := (mem.alloc "b0") in
    let: "err1" := (mem.alloc (type.zero_val #boolT)) in
    let: "b1" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a1" := (mem.alloc (type.zero_val #sliceT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b0") in
    (func_call #safemarshal.ReadSlice1D) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a1" <-[#sliceT] "$r0");;;
    do:  ("b1" <-[#sliceT] "$r1");;;
    do:  ("err1" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err1"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err2" := (mem.alloc (type.zero_val #boolT)) in
    let: "b2" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a2" := (mem.alloc (type.zero_val #sliceT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b1") in
    (func_call #safemarshal.ReadSlice1D) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a2" <-[#sliceT] "$r0");;;
    do:  ("b2" <-[#sliceT] "$r1");;;
    do:  ("err2" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err2"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err3" := (mem.alloc (type.zero_val #boolT)) in
    let: "b3" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a3" := (mem.alloc (type.zero_val #sliceT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b2") in
    (func_call #safemarshal.ReadSlice1D) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a3" <-[#sliceT] "$r0");;;
    do:  ("b3" <-[#sliceT] "$r1");;;
    do:  ("err3" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err3"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    return: (mem.alloc (let: "$Link" := (![#sliceT] "a1") in
     let: "$ServSig" := (![#sliceT] "a2") in
     let: "$AdtrSig" := (![#sliceT] "a3") in
     struct.make #SignedLink [{
       "Link" ::= "$Link";
       "ServSig" ::= "$ServSig";
       "AdtrSig" ::= "$AdtrSig"
     }]), ![#sliceT] "b3", #false)).

Definition SignedVrfEncode : go_string := "github.com/sanjit-bhat/pav/auditor.SignedVrfEncode"%go.

(* go: serde.out.go:44:6 *)
Definition SignedVrfEncodeⁱᵐᵖˡ : val :=
  λ: "b0" "o",
    exception_do (let: "o" := (mem.alloc "o") in
    let: "b0" := (mem.alloc "b0") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "b0") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#sliceT] (struct.field_ref #SignedVrf #"VrfPk"%go (![#ptrT] "o"))) in
    (func_call #safemarshal.WriteSlice1D) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#sliceT] (struct.field_ref #SignedVrf #"ServSig"%go (![#ptrT] "o"))) in
    (func_call #safemarshal.WriteSlice1D) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#sliceT] (struct.field_ref #SignedVrf #"AdtrSig"%go (![#ptrT] "o"))) in
    (func_call #safemarshal.WriteSlice1D) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "b")).

Definition SignedVrfDecode : go_string := "github.com/sanjit-bhat/pav/auditor.SignedVrfDecode"%go.

(* go: serde.out.go:51:6 *)
Definition SignedVrfDecodeⁱᵐᵖˡ : val :=
  λ: "b0",
    exception_do (let: "b0" := (mem.alloc "b0") in
    let: "err1" := (mem.alloc (type.zero_val #boolT)) in
    let: "b1" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a1" := (mem.alloc (type.zero_val #sliceT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b0") in
    (func_call #safemarshal.ReadSlice1D) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a1" <-[#sliceT] "$r0");;;
    do:  ("b1" <-[#sliceT] "$r1");;;
    do:  ("err1" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err1"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err2" := (mem.alloc (type.zero_val #boolT)) in
    let: "b2" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a2" := (mem.alloc (type.zero_val #sliceT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b1") in
    (func_call #safemarshal.ReadSlice1D) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a2" <-[#sliceT] "$r0");;;
    do:  ("b2" <-[#sliceT] "$r1");;;
    do:  ("err2" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err2"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err3" := (mem.alloc (type.zero_val #boolT)) in
    let: "b3" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a3" := (mem.alloc (type.zero_val #sliceT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b2") in
    (func_call #safemarshal.ReadSlice1D) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a3" <-[#sliceT] "$r0");;;
    do:  ("b3" <-[#sliceT] "$r1");;;
    do:  ("err3" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err3"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    return: (mem.alloc (let: "$VrfPk" := (![#sliceT] "a1") in
     let: "$ServSig" := (![#sliceT] "a2") in
     let: "$AdtrSig" := (![#sliceT] "a3") in
     struct.make #SignedVrf [{
       "VrfPk" ::= "$VrfPk";
       "ServSig" ::= "$ServSig";
       "AdtrSig" ::= "$AdtrSig"
     }]), ![#sliceT] "b3", #false)).

(* go: serde.out.go:66:6 *)
Definition GetReplyEncodeⁱᵐᵖˡ : val :=
  λ: "b0" "o",
    exception_do (let: "o" := (mem.alloc "o") in
    let: "b0" := (mem.alloc "b0") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "b0") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#ptrT] (struct.field_ref #GetReply #"Link"%go (![#ptrT] "o"))) in
    (func_call #SignedLinkEncode) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#ptrT] (struct.field_ref #GetReply #"Vrf"%go (![#ptrT] "o"))) in
    (func_call #SignedVrfEncode) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#boolT] (struct.field_ref #GetReply #"Err"%go (![#ptrT] "o"))) in
    (func_call #marshal.WriteBool) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "b")).

(* go: serde.out.go:73:6 *)
Definition GetReplyDecodeⁱᵐᵖˡ : val :=
  λ: "b0",
    exception_do (let: "b0" := (mem.alloc "b0") in
    let: "err1" := (mem.alloc (type.zero_val #boolT)) in
    let: "b1" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a1" := (mem.alloc (type.zero_val #ptrT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b0") in
    (func_call #SignedLinkDecode) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a1" <-[#ptrT] "$r0");;;
    do:  ("b1" <-[#sliceT] "$r1");;;
    do:  ("err1" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err1"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err2" := (mem.alloc (type.zero_val #boolT)) in
    let: "b2" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a2" := (mem.alloc (type.zero_val #ptrT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b1") in
    (func_call #SignedVrfDecode) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a2" <-[#ptrT] "$r0");;;
    do:  ("b2" <-[#sliceT] "$r1");;;
    do:  ("err2" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err2"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err3" := (mem.alloc (type.zero_val #boolT)) in
    let: "b3" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a3" := (mem.alloc (type.zero_val #boolT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b2") in
    (func_call #safemarshal.ReadBool) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a3" <-[#boolT] "$r0");;;
    do:  ("b3" <-[#sliceT] "$r1");;;
    do:  ("err3" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err3"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    return: (mem.alloc (let: "$Link" := (![#ptrT] "a1") in
     let: "$Vrf" := (![#ptrT] "a2") in
     let: "$Err" := (![#boolT] "a3") in
     struct.make #GetReply [{
       "Link" ::= "$Link";
       "Vrf" ::= "$Vrf";
       "Err" ::= "$Err"
     }]), ![#sliceT] "b3", #false)).

Definition vars' : list (go_string * go_type) := [].

Definition functions' : list (go_string * val) := [(New, Newⁱᵐᵖˡ); (getNextLink, getNextLinkⁱᵐᵖˡ); (getNextDig, getNextDigⁱᵐᵖˡ); (CheckStartChain, CheckStartChainⁱᵐᵖˡ); (CheckStartVrf, CheckStartVrfⁱᵐᵖˡ); (NewRpcAuditor, NewRpcAuditorⁱᵐᵖˡ); (CallGet, CallGetⁱᵐᵖˡ); (GetArgEncode, GetArgEncodeⁱᵐᵖˡ); (GetArgDecode, GetArgDecodeⁱᵐᵖˡ); (SignedLinkEncode, SignedLinkEncodeⁱᵐᵖˡ); (SignedLinkDecode, SignedLinkDecodeⁱᵐᵖˡ); (SignedVrfEncode, SignedVrfEncodeⁱᵐᵖˡ); (SignedVrfDecode, SignedVrfDecodeⁱᵐᵖˡ); (GetReplyEncode, GetReplyEncodeⁱᵐᵖˡ); (GetReplyDecode, GetReplyDecodeⁱᵐᵖˡ)].

Definition msets' : list (go_string * (list (go_string * val))) := [(Auditor.id, []); (ptrT.id Auditor.id, [("Get"%go, Auditor__Getⁱᵐᵖˡ); ("Update"%go, Auditor__Updateⁱᵐᵖˡ)]); (history.id, []); (ptrT.id history.id, []); (serv.id, []); (ptrT.id serv.id, []); (GetArg.id, []); (ptrT.id GetArg.id, []); (SignedLink.id, []); (ptrT.id SignedLink.id, []); (SignedVrf.id, []); (ptrT.id SignedVrf.id, []); (GetReply.id, []); (ptrT.id GetReply.id, [])].

#[global] Instance info' : PkgInfo auditor.auditor :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [code.bytes.bytes; code.sync.sync; code.github_com.goose_lang.std.std; code.github_com.sanjit_bhat.pav.advrpc.advrpc; code.github_com.sanjit_bhat.pav.cryptoffi.cryptoffi; code.github_com.sanjit_bhat.pav.hashchain.hashchain; code.github_com.sanjit_bhat.pav.ktcore.ktcore; code.github_com.sanjit_bhat.pav.merkle.merkle; code.github_com.sanjit_bhat.pav.server.server; code.github_com.sanjit_bhat.pav.safemarshal.safemarshal; code.github_com.tchajed.marshal.marshal];
  |}.

Definition initialize' : val :=
  λ: <>,
    package.init #auditor.auditor (λ: <>,
      exception_do (do:  (marshal.initialize' #());;;
      do:  (safemarshal.initialize' #());;;
      do:  (server.initialize' #());;;
      do:  (merkle.initialize' #());;;
      do:  (ktcore.initialize' #());;;
      do:  (hashchain.initialize' #());;;
      do:  (cryptoffi.initialize' #());;;
      do:  (advrpc.initialize' #());;;
      do:  (std.initialize' #());;;
      do:  (sync.initialize' #());;;
      do:  (bytes.initialize' #());;;
      do:  (package.alloc auditor.auditor #()))
      ).

End code.
End auditor.
