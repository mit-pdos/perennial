(* autogenerated from github.com/sanjit-bhat/pav/auditor *)
Require Export New.code.bytes.
Require Export New.code.sync.
Require Export New.code.github_com.goose_lang.std.
Require Export New.code.github_com.sanjit_bhat.pav.advrpc.
Require Export New.code.github_com.sanjit_bhat.pav.cryptoffi.
Require Export New.code.github_com.sanjit_bhat.pav.hashchain.
Require Export New.code.github_com.sanjit_bhat.pav.ktcore.
Require Export New.code.github_com.sanjit_bhat.pav.merkle.
Require Export New.code.github_com.sanjit_bhat.pav.server.
Require Export New.code.github_com.sanjit_bhat.pav.safemarshal.
Require Export New.code.github_com.tchajed.marshal.
From New.golang Require Import defn.
Module pkg_id.
Definition auditor : go_string := "github.com/sanjit-bhat/pav/auditor".

End pkg_id.
Export pkg_id.
Module auditor.

Definition Auditor {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/sanjit-bhat/pav/auditor.Auditor"%go [].

Definition history {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/sanjit-bhat/pav/auditor.history"%go [].

Definition epoch {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/sanjit-bhat/pav/auditor.epoch"%go [].

Definition serv {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/sanjit-bhat/pav/auditor.serv"%go [].

Definition GetArg {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/sanjit-bhat/pav/auditor.GetArg"%go [].

Definition SignedLink {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/sanjit-bhat/pav/auditor.SignedLink"%go [].

Definition SignedVrf {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/sanjit-bhat/pav/auditor.SignedVrf"%go [].

Definition GetReply {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/sanjit-bhat/pav/auditor.GetReply"%go [].

Definition GetRpc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 0).

Definition New {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/sanjit-bhat/pav/auditor.New"%go.

Definition getNextLink {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/sanjit-bhat/pav/auditor.getNextLink"%go.

Definition getNextDig {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/sanjit-bhat/pav/auditor.getNextDig"%go.

Definition CheckStartChain {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/sanjit-bhat/pav/auditor.CheckStartChain"%go.

Definition CheckStartVrf {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/sanjit-bhat/pav/auditor.CheckStartVrf"%go.

Definition NewRpcAuditor {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/sanjit-bhat/pav/auditor.NewRpcAuditor"%go.

Definition CallGet {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/sanjit-bhat/pav/auditor.CallGet"%go.

Definition GetArgEncode {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/sanjit-bhat/pav/auditor.GetArgEncode"%go.

Definition GetArgDecode {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/sanjit-bhat/pav/auditor.GetArgDecode"%go.

Definition SignedLinkEncode {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/sanjit-bhat/pav/auditor.SignedLinkEncode"%go.

Definition SignedLinkDecode {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/sanjit-bhat/pav/auditor.SignedLinkDecode"%go.

Definition SignedVrfEncode {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/sanjit-bhat/pav/auditor.SignedVrfEncode"%go.

Definition SignedVrfDecode {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/sanjit-bhat/pav/auditor.SignedVrfDecode"%go.

Definition GetReplyEncode {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/sanjit-bhat/pav/auditor.GetReplyEncode"%go.

Definition GetReplyDecode {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/sanjit-bhat/pav/auditor.GetReplyDecode"%go.

(* Update queries server for a new epoch update and applies it.

   go: auditor.go:48:19 *)
Definition Auditor__Updateⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "a" <>,
    with_defer: (let: "err" := (GoAlloc ktcore.Blame (GoZeroVal ktcore.Blame #())) in
    let: "a" := (GoAlloc (go.PointerType Auditor) "a") in
    do:  ((MethodResolve (go.PointerType sync.RWMutex) "Lock"%go (![go.PointerType sync.RWMutex] (StructFieldRef Auditor "mu"%go (![go.PointerType Auditor] "a")))) #());;;
    do:  (let: "$f" := (MethodResolve (go.PointerType sync.RWMutex) "Unlock"%go (![go.PointerType sync.RWMutex] (StructFieldRef Auditor "mu"%go (![go.PointerType Auditor] "a")))) in
    "$defer" <-[deferType] (let: "$oldf" := (![deferType] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    let: "prevEp" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (((![go.uint64] (StructFieldRef history "startEp"%go (![go.PointerType history] (StructFieldRef Auditor "hist"%go (![go.PointerType Auditor] "a"))))) +⟨go.uint64⟩ (Convert go.int go.uint64 (let: "$a0" := (![go.SliceType (go.PointerType epoch)] (StructFieldRef history "epochs"%go (![go.PointerType history] (StructFieldRef Auditor "hist"%go (![go.PointerType Auditor] "a"))))) in
    (FuncResolve go.len [go.SliceType (go.PointerType epoch)] #()) "$a0"))) -⟨go.uint64⟩ #(W64 1)) in
    do:  ("prevEp" <-[go.uint64] "$r0");;;
    let: "upd" := (GoAlloc (go.SliceType (go.PointerType ktcore.AuditProof)) (GoZeroVal (go.SliceType (go.PointerType ktcore.AuditProof)) #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.PointerType advrpc.Client] (StructFieldRef serv "cli"%go (![go.PointerType serv] (StructFieldRef Auditor "serv"%go (![go.PointerType Auditor] "a"))))) in
    let: "$a1" := (![go.uint64] "prevEp") in
    (FuncResolve server.CallAudit [] #()) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("upd" <-[go.SliceType (go.PointerType ktcore.AuditProof)] "$r0");;;
    do:  ("err" <-[ktcore.Blame] "$r1");;;
    (if: Convert go.untyped_bool go.bool ((![ktcore.Blame] "err") ≠⟨go.uint64⟩ ktcore.BlameNone)
    then return: (![ktcore.Blame] "err")
    else do:  #());;;
    let: "$range" := (![go.SliceType (go.PointerType ktcore.AuditProof)] "upd") in
    (let: "p" := (GoAlloc (go.PointerType ktcore.AuditProof) (GoZeroVal (go.PointerType ktcore.AuditProof) #())) in
    slice.for_range (go.PointerType ktcore.AuditProof) "$range" (λ: "$key" "$value",
      do:  ("p" <-[go.PointerType ktcore.AuditProof] "$value");;;
      do:  "$key";;;
      (let: "$r0" := (let: "$a0" := (![go.PointerType ktcore.AuditProof] "p") in
      (MethodResolve (go.PointerType Auditor) "updOnce"%go (![go.PointerType Auditor] "a")) "$a0") in
      do:  ("err" <-[ktcore.Blame] "$r0");;;
      (if: Convert go.untyped_bool go.bool ((![ktcore.Blame] "err") ≠⟨go.uint64⟩ ktcore.BlameNone)
      then return: (![ktcore.Blame] "err")
      else do:  #()))));;;
    return: (![ktcore.Blame] "err")).

(* go: auditor.go:65:19 *)
Definition Auditor__updOnceⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "a" "p",
    exception_do (let: "err" := (GoAlloc ktcore.Blame (GoZeroVal ktcore.Blame #())) in
    let: "a" := (GoAlloc (go.PointerType Auditor) "a") in
    let: "p" := (GoAlloc (go.PointerType ktcore.AuditProof) "p") in
    let: "sigPk" := (GoAlloc cryptoffi.SigPublicKey (GoZeroVal cryptoffi.SigPublicKey #())) in
    let: "$r0" := (![cryptoffi.SigPublicKey] (StructFieldRef serv "sigPk"%go (![go.PointerType serv] (StructFieldRef Auditor "serv"%go (![go.PointerType Auditor] "a"))))) in
    do:  ("sigPk" <-[cryptoffi.SigPublicKey] "$r0");;;
    let: "hist" := (GoAlloc (go.PointerType history) (GoZeroVal (go.PointerType history) #())) in
    let: "$r0" := (![go.PointerType history] (StructFieldRef Auditor "hist"%go (![go.PointerType Auditor] "a"))) in
    do:  ("hist" <-[go.PointerType history] "$r0");;;
    let: "prevEp" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (((![go.uint64] (StructFieldRef history "startEp"%go (![go.PointerType history] "hist"))) +⟨go.uint64⟩ (Convert go.int go.uint64 (let: "$a0" := (![go.SliceType (go.PointerType epoch)] (StructFieldRef history "epochs"%go (![go.PointerType history] "hist"))) in
    (FuncResolve go.len [go.SliceType (go.PointerType epoch)] #()) "$a0"))) -⟨go.uint64⟩ #(W64 1)) in
    do:  ("prevEp" <-[go.uint64] "$r0");;;
    let: "prevLink" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (![go.SliceType go.byte] (StructFieldRef epoch "link"%go (![go.PointerType epoch] (IndexRef (go.SliceType (go.PointerType epoch)) (![go.SliceType (go.PointerType epoch)] (StructFieldRef history "epochs"%go (![go.PointerType history] "hist")), (let: "$a0" := (![go.SliceType (go.PointerType epoch)] (StructFieldRef history "epochs"%go (![go.PointerType history] "hist"))) in
     (FuncResolve go.len [go.SliceType (go.PointerType epoch)] #()) "$a0") -⟨go.int⟩ #(W64 1)))))) in
    do:  ("prevLink" <-[go.SliceType go.byte] "$r0");;;
    let: "errb" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "link" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "dig" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "ep" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: ((("$ret0", "$ret1"), "$ret2"), "$ret3") := (let: "$a0" := (![cryptoffi.SigPublicKey] "sigPk") in
    let: "$a1" := (![go.uint64] "prevEp") in
    let: "$a2" := (![go.SliceType go.byte] (StructFieldRef history "lastDig"%go (![go.PointerType history] "hist"))) in
    let: "$a3" := (![go.SliceType go.byte] "prevLink") in
    let: "$a4" := (![go.PointerType ktcore.AuditProof] "p") in
    (FuncResolve getNextLink [] #()) "$a0" "$a1" "$a2" "$a3" "$a4") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    let: "$r3" := "$ret3" in
    do:  ("ep" <-[go.uint64] "$r0");;;
    do:  ("dig" <-[go.SliceType go.byte] "$r1");;;
    do:  ("link" <-[go.SliceType go.byte] "$r2");;;
    do:  ("errb" <-[go.bool] "$r3");;;
    (if: ![go.bool] "errb"
    then
      let: "$r0" := ktcore.BlameServFull in
      do:  ("err" <-[ktcore.Blame] "$r0");;;
      return: (![ktcore.Blame] "err")
    else do:  #());;;
    let: "sig" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (let: "$a0" := (![go.PointerType cryptoffi.SigPrivateKey] (StructFieldRef Auditor "sk"%go (![go.PointerType Auditor] "a"))) in
    let: "$a1" := (![go.uint64] "ep") in
    let: "$a2" := (![go.SliceType go.byte] "link") in
    (FuncResolve ktcore.SignLink [] #()) "$a0" "$a1" "$a2") in
    do:  ("sig" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (![go.SliceType go.byte] "dig") in
    do:  ((StructFieldRef history "lastDig"%go (![go.PointerType history] "hist")) <-[go.SliceType go.byte] "$r0");;;
    let: "info" := (GoAlloc (go.PointerType epoch) (GoZeroVal (go.PointerType epoch) #())) in
    let: "$r0" := (GoAlloc epoch (CompositeLiteral epoch (LiteralValue [KeyedElement (Some (KeyField "link"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] "link")); KeyedElement (Some (KeyField "servSig"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] (StructFieldRef ktcore.AuditProof "LinkSig"%go (![go.PointerType ktcore.AuditProof] "p")))); KeyedElement (Some (KeyField "adtrSig"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] "sig"))]))) in
    do:  ("info" <-[go.PointerType epoch] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType (go.PointerType epoch)] (StructFieldRef history "epochs"%go (![go.PointerType history] "hist"))) in
    let: "$a1" := ((let: "$sl0" := (![go.PointerType epoch] "info") in
    CompositeLiteral (go.SliceType (go.PointerType epoch)) (LiteralValue [KeyedElement None (ElementExpression (go.PointerType epoch) "$sl0")]))) in
    (FuncResolve go.append [go.SliceType (go.PointerType epoch)] #()) "$a0" "$a1") in
    do:  ((StructFieldRef history "epochs"%go (![go.PointerType history] "hist")) <-[go.SliceType (go.PointerType epoch)] "$r0");;;
    let: "$r0" := (![go.PointerType history] "hist") in
    do:  ((StructFieldRef Auditor "hist"%go (![go.PointerType Auditor] "a")) <-[go.PointerType history] "$r0");;;
    return: (![ktcore.Blame] "err")).

(* Get returns the auditor's info for a particular epoch.
   it errors if the epoch is out of bounds.

   go: auditor.go:87:19 *)
Definition Auditor__Getⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "a" "epoch",
    with_defer: (let: "err" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "vrf" := (GoAlloc (go.PointerType SignedVrf) (GoZeroVal (go.PointerType SignedVrf) #())) in
    let: "link" := (GoAlloc (go.PointerType SignedLink) (GoZeroVal (go.PointerType SignedLink) #())) in
    let: "a" := (GoAlloc (go.PointerType Auditor) "a") in
    let: "epoch" := (GoAlloc go.uint64 "epoch") in
    do:  ((MethodResolve (go.PointerType sync.RWMutex) "RLock"%go (![go.PointerType sync.RWMutex] (StructFieldRef Auditor "mu"%go (![go.PointerType Auditor] "a")))) #());;;
    do:  (let: "$f" := (MethodResolve (go.PointerType sync.RWMutex) "RUnlock"%go (![go.PointerType sync.RWMutex] (StructFieldRef Auditor "mu"%go (![go.PointerType Auditor] "a")))) in
    "$defer" <-[deferType] (let: "$oldf" := (![deferType] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    let: "hist" := (GoAlloc (go.PointerType history) (GoZeroVal (go.PointerType history) #())) in
    let: "$r0" := (![go.PointerType history] (StructFieldRef Auditor "hist"%go (![go.PointerType Auditor] "a"))) in
    do:  ("hist" <-[go.PointerType history] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "epoch") <⟨go.uint64⟩ (![go.uint64] (StructFieldRef history "startEp"%go (![go.PointerType history] "hist"))))
    then
      let: "$r0" := #true in
      do:  ("err" <-[go.bool] "$r0");;;
      return: (![go.PointerType SignedLink] "link", ![go.PointerType SignedVrf] "vrf", ![go.bool] "err")
    else do:  #());;;
    let: "lastEp" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (((![go.uint64] (StructFieldRef history "startEp"%go (![go.PointerType history] "hist"))) +⟨go.uint64⟩ (Convert go.int go.uint64 (let: "$a0" := (![go.SliceType (go.PointerType epoch)] (StructFieldRef history "epochs"%go (![go.PointerType history] "hist"))) in
    (FuncResolve go.len [go.SliceType (go.PointerType epoch)] #()) "$a0"))) -⟨go.uint64⟩ #(W64 1)) in
    do:  ("lastEp" <-[go.uint64] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "epoch") >⟨go.uint64⟩ (![go.uint64] "lastEp"))
    then
      let: "$r0" := #true in
      do:  ("err" <-[go.bool] "$r0");;;
      return: (![go.PointerType SignedLink] "link", ![go.PointerType SignedVrf] "vrf", ![go.bool] "err")
    else do:  #());;;
    let: "x" := (GoAlloc (go.PointerType epoch) (GoZeroVal (go.PointerType epoch) #())) in
    let: "$r0" := (![go.PointerType epoch] (IndexRef (go.SliceType (go.PointerType epoch)) (![go.SliceType (go.PointerType epoch)] (StructFieldRef history "epochs"%go (![go.PointerType history] "hist")), Convert go.uint64 go.int ((![go.uint64] "epoch") -⟨go.uint64⟩ (![go.uint64] (StructFieldRef history "startEp"%go (![go.PointerType history] "hist"))))))) in
    do:  ("x" <-[go.PointerType epoch] "$r0");;;
    let: "$r0" := (GoAlloc SignedLink (CompositeLiteral SignedLink (LiteralValue [KeyedElement (Some (KeyField "Link"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] (StructFieldRef epoch "link"%go (![go.PointerType epoch] "x")))); KeyedElement (Some (KeyField "ServSig"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] (StructFieldRef epoch "servSig"%go (![go.PointerType epoch] "x")))); KeyedElement (Some (KeyField "AdtrSig"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] (StructFieldRef epoch "adtrSig"%go (![go.PointerType epoch] "x"))))]))) in
    do:  ("link" <-[go.PointerType SignedLink] "$r0");;;
    let: "$r0" := (GoAlloc SignedVrf (CompositeLiteral SignedVrf (LiteralValue [KeyedElement (Some (KeyField "VrfPk"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] (StructFieldRef serv "vrfPk"%go (![go.PointerType serv] (StructFieldRef Auditor "serv"%go (![go.PointerType Auditor] "a")))))); KeyedElement (Some (KeyField "ServSig"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] (StructFieldRef serv "servVrfSig"%go (![go.PointerType serv] (StructFieldRef Auditor "serv"%go (![go.PointerType Auditor] "a")))))); KeyedElement (Some (KeyField "AdtrSig"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] (StructFieldRef serv "adtrVrfSig"%go (![go.PointerType serv] (StructFieldRef Auditor "serv"%go (![go.PointerType Auditor] "a"))))))]))) in
    do:  ("vrf" <-[go.PointerType SignedVrf] "$r0");;;
    return: (![go.PointerType SignedLink] "link", ![go.PointerType SignedVrf] "vrf", ![go.bool] "err")).

(* go: auditor.go:109:6 *)
Definition Newⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "servAddr" "servPk",
    exception_do (let: "err" := (GoAlloc ktcore.Blame (GoZeroVal ktcore.Blame #())) in
    let: "sigPk" := (GoAlloc cryptoffi.SigPublicKey (GoZeroVal cryptoffi.SigPublicKey #())) in
    let: "a" := (GoAlloc (go.PointerType Auditor) (GoZeroVal (go.PointerType Auditor) #())) in
    let: "servPk" := (GoAlloc cryptoffi.SigPublicKey "servPk") in
    let: "servAddr" := (GoAlloc go.uint64 "servAddr") in
    let: "cli" := (GoAlloc (go.PointerType advrpc.Client) (GoZeroVal (go.PointerType advrpc.Client) #())) in
    let: "$r0" := (let: "$a0" := (![go.uint64] "servAddr") in
    (FuncResolve advrpc.Dial [] #()) "$a0") in
    do:  ("cli" <-[go.PointerType advrpc.Client] "$r0");;;
    let: "vrf" := (GoAlloc (go.PointerType server.StartVrf) (GoZeroVal (go.PointerType server.StartVrf) #())) in
    let: "chain" := (GoAlloc (go.PointerType server.StartChain) (GoZeroVal (go.PointerType server.StartChain) #())) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.PointerType advrpc.Client] "cli") in
    (FuncResolve server.CallStart [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("chain" <-[go.PointerType server.StartChain] "$r0");;;
    do:  ("vrf" <-[go.PointerType server.StartVrf] "$r1");;;
    do:  ("err" <-[ktcore.Blame] "$r2");;;
    (if: Convert go.untyped_bool go.bool ((![ktcore.Blame] "err") ≠⟨go.uint64⟩ ktcore.BlameNone)
    then return: (![go.PointerType Auditor] "a", ![cryptoffi.SigPublicKey] "sigPk", ![ktcore.Blame] "err")
    else do:  #());;;
    let: "errb" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "startLink" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "startDig" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "startEp" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: ((("$ret0", "$ret1"), "$ret2"), "$ret3") := (let: "$a0" := (![cryptoffi.SigPublicKey] "servPk") in
    let: "$a1" := (![go.PointerType server.StartChain] "chain") in
    (FuncResolve CheckStartChain [] #()) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    let: "$r3" := "$ret3" in
    do:  ("startEp" <-[go.uint64] "$r0");;;
    do:  ("startDig" <-[go.SliceType go.byte] "$r1");;;
    do:  ("startLink" <-[go.SliceType go.byte] "$r2");;;
    do:  ("errb" <-[go.bool] "$r3");;;
    (if: ![go.bool] "errb"
    then
      let: "$r0" := ktcore.BlameServFull in
      do:  ("err" <-[ktcore.Blame] "$r0");;;
      return: (![go.PointerType Auditor] "a", ![cryptoffi.SigPublicKey] "sigPk", ![ktcore.Blame] "err")
    else do:  #());;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![cryptoffi.SigPublicKey] "servPk") in
    let: "$a1" := (![go.PointerType server.StartVrf] "vrf") in
    (FuncResolve CheckStartVrf [] #()) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  "$r0";;;
    do:  ("errb" <-[go.bool] "$r1");;;
    (if: ![go.bool] "errb"
    then
      let: "$r0" := ktcore.BlameServFull in
      do:  ("err" <-[ktcore.Blame] "$r0");;;
      return: (![go.PointerType Auditor] "a", ![cryptoffi.SigPublicKey] "sigPk", ![ktcore.Blame] "err")
    else do:  #());;;
    let: "mu" := (GoAlloc (go.PointerType sync.RWMutex) (GoZeroVal (go.PointerType sync.RWMutex) #())) in
    let: "$r0" := (GoAlloc sync.RWMutex (GoZeroVal sync.RWMutex #())) in
    do:  ("mu" <-[go.PointerType sync.RWMutex] "$r0");;;
    let: "sk" := (GoAlloc (go.PointerType cryptoffi.SigPrivateKey) (GoZeroVal (go.PointerType cryptoffi.SigPrivateKey) #())) in
    let: ("$ret0", "$ret1") := ((FuncResolve cryptoffi.SigGenerateKey [] #()) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("sigPk" <-[cryptoffi.SigPublicKey] "$r0");;;
    do:  ("sk" <-[go.PointerType cryptoffi.SigPrivateKey] "$r1");;;
    let: "linkSig" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (let: "$a0" := (![go.PointerType cryptoffi.SigPrivateKey] "sk") in
    let: "$a1" := (![go.uint64] "startEp") in
    let: "$a2" := (![go.SliceType go.byte] "startLink") in
    (FuncResolve ktcore.SignLink [] #()) "$a0" "$a1" "$a2") in
    do:  ("linkSig" <-[go.SliceType go.byte] "$r0");;;
    let: "info" := (GoAlloc (go.PointerType epoch) (GoZeroVal (go.PointerType epoch) #())) in
    let: "$r0" := (GoAlloc epoch (CompositeLiteral epoch (LiteralValue [KeyedElement (Some (KeyField "link"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] "startLink")); KeyedElement (Some (KeyField "servSig"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] (StructFieldRef server.StartChain "LinkSig"%go (![go.PointerType server.StartChain] "chain")))); KeyedElement (Some (KeyField "adtrSig"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] "linkSig"))]))) in
    do:  ("info" <-[go.PointerType epoch] "$r0");;;
    let: "hist" := (GoAlloc (go.PointerType history) (GoZeroVal (go.PointerType history) #())) in
    let: "$r0" := (GoAlloc history (CompositeLiteral history (LiteralValue [KeyedElement (Some (KeyField "lastDig"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] "startDig")); KeyedElement (Some (KeyField "startEp"%go)) (ElementExpression go.uint64 (![go.uint64] "startEp")); KeyedElement (Some (KeyField "epochs"%go)) (ElementExpression (go.SliceType (go.PointerType epoch)) (CompositeLiteral (go.SliceType (go.PointerType epoch)) (LiteralValue [KeyedElement None (ElementExpression (go.PointerType epoch) (![go.PointerType epoch] "info"))])))]))) in
    do:  ("hist" <-[go.PointerType history] "$r0");;;
    let: "vrfSig" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (let: "$a0" := (![go.PointerType cryptoffi.SigPrivateKey] "sk") in
    let: "$a1" := (![go.SliceType go.byte] (StructFieldRef server.StartVrf "VrfPk"%go (![go.PointerType server.StartVrf] "vrf"))) in
    (FuncResolve ktcore.SignVrf [] #()) "$a0" "$a1") in
    do:  ("vrfSig" <-[go.SliceType go.byte] "$r0");;;
    let: "serv" := (GoAlloc (go.PointerType serv) (GoZeroVal (go.PointerType serv) #())) in
    let: "$r0" := (GoAlloc serv (CompositeLiteral serv (LiteralValue [KeyedElement (Some (KeyField "cli"%go)) (ElementExpression (go.PointerType advrpc.Client) (![go.PointerType advrpc.Client] "cli")); KeyedElement (Some (KeyField "sigPk"%go)) (ElementExpression cryptoffi.SigPublicKey (![cryptoffi.SigPublicKey] "servPk")); KeyedElement (Some (KeyField "vrfPk"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] (StructFieldRef server.StartVrf "VrfPk"%go (![go.PointerType server.StartVrf] "vrf")))); KeyedElement (Some (KeyField "servVrfSig"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] (StructFieldRef server.StartVrf "VrfSig"%go (![go.PointerType server.StartVrf] "vrf")))); KeyedElement (Some (KeyField "adtrVrfSig"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] "vrfSig"))]))) in
    do:  ("serv" <-[go.PointerType serv] "$r0");;;
    let: "$r0" := (GoAlloc Auditor (CompositeLiteral Auditor (LiteralValue [KeyedElement (Some (KeyField "mu"%go)) (ElementExpression (go.PointerType sync.RWMutex) (![go.PointerType sync.RWMutex] "mu")); KeyedElement (Some (KeyField "sk"%go)) (ElementExpression (go.PointerType cryptoffi.SigPrivateKey) (![go.PointerType cryptoffi.SigPrivateKey] "sk")); KeyedElement (Some (KeyField "hist"%go)) (ElementExpression (go.PointerType history) (![go.PointerType history] "hist")); KeyedElement (Some (KeyField "serv"%go)) (ElementExpression (go.PointerType serv) (![go.PointerType serv] "serv"))]))) in
    do:  ("a" <-[go.PointerType Auditor] "$r0");;;
    return: (![go.PointerType Auditor] "a", ![cryptoffi.SigPublicKey] "sigPk", ![ktcore.Blame] "err")).

(* go: auditor.go:137:6 *)
Definition getNextLinkⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "sigPk" "prevEp" "prevDig" "prevLink" "p",
    exception_do (let: "err" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "link" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "dig" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "ep" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "p" := (GoAlloc (go.PointerType ktcore.AuditProof) "p") in
    let: "prevLink" := (GoAlloc (go.SliceType go.byte) "prevLink") in
    let: "prevDig" := (GoAlloc (go.SliceType go.byte) "prevDig") in
    let: "prevEp" := (GoAlloc go.uint64 "prevEp") in
    let: "sigPk" := (GoAlloc cryptoffi.SigPublicKey "sigPk") in
    (if: (~ (let: "$a0" := (![go.uint64] "prevEp") in
    let: "$a1" := #(W64 1) in
    (FuncResolve std.SumNoOverflow [] #()) "$a0" "$a1"))
    then
      let: "$r0" := #true in
      do:  ("err" <-[go.bool] "$r0");;;
      return: (![go.uint64] "ep", ![go.SliceType go.byte] "dig", ![go.SliceType go.byte] "link", ![go.bool] "err")
    else do:  #());;;
    let: "$r0" := ((![go.uint64] "prevEp") +⟨go.uint64⟩ #(W64 1)) in
    do:  ("ep" <-[go.uint64] "$r0");;;
    (let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] "prevDig") in
    let: "$a1" := (![go.SliceType (go.PointerType ktcore.UpdateProof)] (StructFieldRef ktcore.AuditProof "Updates"%go (![go.PointerType ktcore.AuditProof] "p"))) in
    (FuncResolve getNextDig [] #()) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("dig" <-[go.SliceType go.byte] "$r0");;;
    do:  ("err" <-[go.bool] "$r1");;;
    (if: ![go.bool] "err"
    then return: (![go.uint64] "ep", ![go.SliceType go.byte] "dig", ![go.SliceType go.byte] "link", ![go.bool] "err")
    else do:  #()));;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "prevLink") in
    let: "$a1" := (![go.SliceType go.byte] "dig") in
    (FuncResolve hashchain.GetNextLink [] #()) "$a0" "$a1") in
    do:  ("link" <-[go.SliceType go.byte] "$r0");;;
    (if: let: "$a0" := (![cryptoffi.SigPublicKey] "sigPk") in
    let: "$a1" := (![go.uint64] "ep") in
    let: "$a2" := (![go.SliceType go.byte] "link") in
    let: "$a3" := (![go.SliceType go.byte] (StructFieldRef ktcore.AuditProof "LinkSig"%go (![go.PointerType ktcore.AuditProof] "p"))) in
    (FuncResolve ktcore.VerifyLinkSig [] #()) "$a0" "$a1" "$a2" "$a3"
    then
      let: "$r0" := #true in
      do:  ("err" <-[go.bool] "$r0");;;
      return: (![go.uint64] "ep", ![go.SliceType go.byte] "dig", ![go.SliceType go.byte] "link", ![go.bool] "err")
    else do:  #());;;
    return: (![go.uint64] "ep", ![go.SliceType go.byte] "dig", ![go.SliceType go.byte] "link", ![go.bool] "err")).

(* go: auditor.go:154:6 *)
Definition getNextDigⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "prevDig" "updates",
    exception_do (let: "err" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "dig" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "updates" := (GoAlloc (go.SliceType (go.PointerType ktcore.UpdateProof)) "updates") in
    let: "prevDig" := (GoAlloc (go.SliceType go.byte) "prevDig") in
    let: "$r0" := (![go.SliceType go.byte] "prevDig") in
    do:  ("dig" <-[go.SliceType go.byte] "$r0");;;
    let: "$range" := (![go.SliceType (go.PointerType ktcore.UpdateProof)] "updates") in
    (let: "u" := (GoAlloc (go.PointerType ktcore.UpdateProof) (GoZeroVal (go.PointerType ktcore.UpdateProof) #())) in
    slice.for_range (go.PointerType ktcore.UpdateProof) "$range" (λ: "$key" "$value",
      do:  ("u" <-[go.PointerType ktcore.UpdateProof] "$value");;;
      do:  "$key";;;
      let: "next" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
      let: "prev" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
      let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] (StructFieldRef ktcore.UpdateProof "MapLabel"%go (![go.PointerType ktcore.UpdateProof] "u"))) in
      let: "$a1" := (![go.SliceType go.byte] (StructFieldRef ktcore.UpdateProof "MapVal"%go (![go.PointerType ktcore.UpdateProof] "u"))) in
      let: "$a2" := (![go.SliceType go.byte] (StructFieldRef ktcore.UpdateProof "NonMembProof"%go (![go.PointerType ktcore.UpdateProof] "u"))) in
      (FuncResolve merkle.VerifyUpdate [] #()) "$a0" "$a1" "$a2") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      let: "$r2" := "$ret2" in
      do:  ("prev" <-[go.SliceType go.byte] "$r0");;;
      do:  ("next" <-[go.SliceType go.byte] "$r1");;;
      do:  ("err" <-[go.bool] "$r2");;;
      (if: ![go.bool] "err"
      then return: (![go.SliceType go.byte] "dig", ![go.bool] "err")
      else do:  #());;;
      (if: (~ (let: "$a0" := (![go.SliceType go.byte] "dig") in
      let: "$a1" := (![go.SliceType go.byte] "prev") in
      (FuncResolve bytes.Equal [] #()) "$a0" "$a1"))
      then
        let: "$r0" := #true in
        do:  ("err" <-[go.bool] "$r0");;;
        return: (![go.SliceType go.byte] "dig", ![go.bool] "err")
      else do:  #());;;
      let: "$r0" := (![go.SliceType go.byte] "next") in
      do:  ("dig" <-[go.SliceType go.byte] "$r0")));;;
    return: (![go.SliceType go.byte] "dig", ![go.bool] "err")).

(* go: auditor.go:171:6 *)
Definition CheckStartChainⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "servPk" "chain",
    exception_do (let: "err" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "link" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "dig" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "ep" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "chain" := (GoAlloc (go.PointerType server.StartChain) "chain") in
    let: "servPk" := (GoAlloc cryptoffi.SigPublicKey "servPk") in
    (if: Convert go.untyped_bool go.bool ((Convert go.int go.uint64 (let: "$a0" := (![go.SliceType go.byte] (StructFieldRef server.StartChain "PrevLink"%go (![go.PointerType server.StartChain] "chain"))) in
    (FuncResolve go.len [go.SliceType go.byte] #()) "$a0")) ≠⟨go.uint64⟩ cryptoffi.HashLen)
    then
      let: "$r0" := #true in
      do:  ("err" <-[go.bool] "$r0");;;
      return: (![go.uint64] "ep", ![go.SliceType go.byte] "dig", ![go.SliceType go.byte] "link", ![go.bool] "err")
    else do:  #());;;
    let: "errb" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "extLen" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: ((("$ret0", "$ret1"), "$ret2"), "$ret3") := (let: "$a0" := (![go.SliceType go.byte] (StructFieldRef server.StartChain "PrevLink"%go (![go.PointerType server.StartChain] "chain"))) in
    let: "$a1" := (![go.SliceType go.byte] (StructFieldRef server.StartChain "ChainProof"%go (![go.PointerType server.StartChain] "chain"))) in
    (FuncResolve hashchain.Verify [] #()) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    let: "$r3" := "$ret3" in
    do:  ("extLen" <-[go.uint64] "$r0");;;
    do:  ("dig" <-[go.SliceType go.byte] "$r1");;;
    do:  ("link" <-[go.SliceType go.byte] "$r2");;;
    do:  ("errb" <-[go.bool] "$r3");;;
    (if: ![go.bool] "errb"
    then
      let: "$r0" := #true in
      do:  ("err" <-[go.bool] "$r0");;;
      return: (![go.uint64] "ep", ![go.SliceType go.byte] "dig", ![go.SliceType go.byte] "link", ![go.bool] "err")
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "extLen") =⟨go.uint64⟩ #(W64 0))
    then
      let: "$r0" := #true in
      do:  ("err" <-[go.bool] "$r0");;;
      return: (![go.uint64] "ep", ![go.SliceType go.byte] "dig", ![go.SliceType go.byte] "link", ![go.bool] "err")
    else do:  #());;;
    (if: (~ (let: "$a0" := (![go.uint64] (StructFieldRef server.StartChain "PrevEpochLen"%go (![go.PointerType server.StartChain] "chain"))) in
    let: "$a1" := ((![go.uint64] "extLen") -⟨go.uint64⟩ #(W64 1)) in
    (FuncResolve std.SumNoOverflow [] #()) "$a0" "$a1"))
    then
      let: "$r0" := #true in
      do:  ("err" <-[go.bool] "$r0");;;
      return: (![go.uint64] "ep", ![go.SliceType go.byte] "dig", ![go.SliceType go.byte] "link", ![go.bool] "err")
    else do:  #());;;
    let: "$r0" := (((![go.uint64] (StructFieldRef server.StartChain "PrevEpochLen"%go (![go.PointerType server.StartChain] "chain"))) +⟨go.uint64⟩ (![go.uint64] "extLen")) -⟨go.uint64⟩ #(W64 1)) in
    do:  ("ep" <-[go.uint64] "$r0");;;
    (if: let: "$a0" := (![cryptoffi.SigPublicKey] "servPk") in
    let: "$a1" := (![go.uint64] "ep") in
    let: "$a2" := (![go.SliceType go.byte] "link") in
    let: "$a3" := (![go.SliceType go.byte] (StructFieldRef server.StartChain "LinkSig"%go (![go.PointerType server.StartChain] "chain"))) in
    (FuncResolve ktcore.VerifyLinkSig [] #()) "$a0" "$a1" "$a2" "$a3"
    then
      let: "$r0" := #true in
      do:  ("err" <-[go.bool] "$r0");;;
      return: (![go.uint64] "ep", ![go.SliceType go.byte] "dig", ![go.SliceType go.byte] "link", ![go.bool] "err")
    else do:  #());;;
    return: (![go.uint64] "ep", ![go.SliceType go.byte] "dig", ![go.SliceType go.byte] "link", ![go.bool] "err")).

(* go: auditor.go:198:6 *)
Definition CheckStartVrfⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "servPk" "vrf",
    exception_do (let: "err" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "vrfPk" := (GoAlloc (go.PointerType cryptoffi.VrfPublicKey) (GoZeroVal (go.PointerType cryptoffi.VrfPublicKey) #())) in
    let: "vrf" := (GoAlloc (go.PointerType server.StartVrf) "vrf") in
    let: "servPk" := (GoAlloc cryptoffi.SigPublicKey "servPk") in
    let: "errb" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] (StructFieldRef server.StartVrf "VrfPk"%go (![go.PointerType server.StartVrf] "vrf"))) in
    (FuncResolve cryptoffi.VrfPublicKeyDecode [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("vrfPk" <-[go.PointerType cryptoffi.VrfPublicKey] "$r0");;;
    do:  ("errb" <-[go.bool] "$r1");;;
    (if: ![go.bool] "errb"
    then
      let: "$r0" := #true in
      do:  ("err" <-[go.bool] "$r0");;;
      return: (![go.PointerType cryptoffi.VrfPublicKey] "vrfPk", ![go.bool] "err")
    else do:  #());;;
    (if: let: "$a0" := (![cryptoffi.SigPublicKey] "servPk") in
    let: "$a1" := (![go.SliceType go.byte] (StructFieldRef server.StartVrf "VrfPk"%go (![go.PointerType server.StartVrf] "vrf"))) in
    let: "$a2" := (![go.SliceType go.byte] (StructFieldRef server.StartVrf "VrfSig"%go (![go.PointerType server.StartVrf] "vrf"))) in
    (FuncResolve ktcore.VerifyVrfSig [] #()) "$a0" "$a1" "$a2"
    then
      let: "$r0" := #true in
      do:  ("err" <-[go.bool] "$r0");;;
      return: (![go.PointerType cryptoffi.VrfPublicKey] "vrfPk", ![go.bool] "err")
    else do:  #());;;
    return: (![go.PointerType cryptoffi.VrfPublicKey] "vrfPk", ![go.bool] "err")).

(* go: rpc.go:12:6 *)
Definition NewRpcAuditorⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "adtr",
    exception_do (let: "adtr" := (GoAlloc (go.PointerType Auditor) "adtr") in
    let: "h" := (GoAlloc (go.MapType go.uint64 (go.FunctionType (go.Signature [go.SliceType go.byte; go.PointerType (go.SliceType go.byte)] false []))) (GoZeroVal (go.MapType go.uint64 (go.FunctionType (go.Signature [go.SliceType go.byte; go.PointerType (go.SliceType go.byte)] false []))) #())) in
    let: "$r0" := ((FuncResolve go.make1 [go.MapType go.uint64 (go.FunctionType (go.Signature [go.SliceType go.byte; go.PointerType (go.SliceType go.byte)] false []))] #()) #()) in
    do:  ("h" <-[go.MapType go.uint64 (go.FunctionType (go.Signature [go.SliceType go.byte; go.PointerType (go.SliceType go.byte)] false []))] "$r0");;;
    let: "$r0" := (λ: "arg" "reply",
      exception_do (let: "reply" := (GoAlloc (go.PointerType (go.SliceType go.byte)) "reply") in
      let: "arg" := (GoAlloc (go.SliceType go.byte) "arg") in
      let: "err" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
      let: "a" := (GoAlloc (go.PointerType GetArg) (GoZeroVal (go.PointerType GetArg) #())) in
      let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "arg") in
      (FuncResolve GetArgDecode [] #()) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      let: "$r2" := "$ret2" in
      do:  ("a" <-[go.PointerType GetArg] "$r0");;;
      do:  "$r1";;;
      do:  ("err" <-[go.bool] "$r2");;;
      (if: ![go.bool] "err"
      then
        let: "r" := (GoAlloc (go.PointerType GetReply) (GoZeroVal (go.PointerType GetReply) #())) in
        let: "$r0" := (GoAlloc GetReply (CompositeLiteral GetReply (LiteralValue [KeyedElement (Some (KeyField "Err"%go)) (ElementExpression go.bool #true)]))) in
        do:  ("r" <-[go.PointerType GetReply] "$r0");;;
        let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] (![go.PointerType (go.SliceType go.byte)] "reply")) in
        let: "$a1" := (![go.PointerType GetReply] "r") in
        (FuncResolve GetReplyEncode [] #()) "$a0" "$a1") in
        do:  ((![go.PointerType (go.SliceType go.byte)] "reply") <-[go.SliceType go.byte] "$r0");;;
        return: (#())
      else do:  #());;;
      let: "r2" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
      let: "r1" := (GoAlloc (go.PointerType SignedVrf) (GoZeroVal (go.PointerType SignedVrf) #())) in
      let: "r0" := (GoAlloc (go.PointerType SignedLink) (GoZeroVal (go.PointerType SignedLink) #())) in
      let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.uint64] (StructFieldRef GetArg "Epoch"%go (![go.PointerType GetArg] "a"))) in
      (MethodResolve (go.PointerType Auditor) "Get"%go (![go.PointerType Auditor] "adtr")) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      let: "$r2" := "$ret2" in
      do:  ("r0" <-[go.PointerType SignedLink] "$r0");;;
      do:  ("r1" <-[go.PointerType SignedVrf] "$r1");;;
      do:  ("r2" <-[go.bool] "$r2");;;
      let: "r" := (GoAlloc (go.PointerType GetReply) (GoZeroVal (go.PointerType GetReply) #())) in
      let: "$r0" := (GoAlloc GetReply (CompositeLiteral GetReply (LiteralValue [KeyedElement (Some (KeyField "Link"%go)) (ElementExpression (go.PointerType SignedLink) (![go.PointerType SignedLink] "r0")); KeyedElement (Some (KeyField "Vrf"%go)) (ElementExpression (go.PointerType SignedVrf) (![go.PointerType SignedVrf] "r1")); KeyedElement (Some (KeyField "Err"%go)) (ElementExpression go.bool (![go.bool] "r2"))]))) in
      do:  ("r" <-[go.PointerType GetReply] "$r0");;;
      let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] (![go.PointerType (go.SliceType go.byte)] "reply")) in
      let: "$a1" := (![go.PointerType GetReply] "r") in
      (FuncResolve GetReplyEncode [] #()) "$a0" "$a1") in
      do:  ((![go.PointerType (go.SliceType go.byte)] "reply") <-[go.SliceType go.byte] "$r0");;;
      return: #())
      ) in
    do:  (map.insert go.uint64 (![go.MapType go.uint64 (go.FunctionType (go.Signature [go.SliceType go.byte; go.PointerType (go.SliceType go.byte)] false []))] "h") GetRpc "$r0");;;
    return: (let: "$a0" := (![go.MapType go.uint64 (go.FunctionType (go.Signature [go.SliceType go.byte; go.PointerType (go.SliceType go.byte)] false []))] "h") in
     (FuncResolve advrpc.NewServer [] #()) "$a0")).

(* go: rpc.go:28:6 *)
Definition CallGetⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "c" "epoch",
    exception_do (let: "err" := (GoAlloc ktcore.Blame (GoZeroVal ktcore.Blame #())) in
    let: "vrf" := (GoAlloc (go.PointerType SignedVrf) (GoZeroVal (go.PointerType SignedVrf) #())) in
    let: "link" := (GoAlloc (go.PointerType SignedLink) (GoZeroVal (go.PointerType SignedLink) #())) in
    let: "epoch" := (GoAlloc go.uint64 "epoch") in
    let: "c" := (GoAlloc (go.PointerType advrpc.Client) "c") in
    let: "a" := (GoAlloc (go.PointerType GetArg) (GoZeroVal (go.PointerType GetArg) #())) in
    let: "$r0" := (GoAlloc GetArg (CompositeLiteral GetArg (LiteralValue [KeyedElement (Some (KeyField "Epoch"%go)) (ElementExpression go.uint64 (![go.uint64] "epoch"))]))) in
    do:  ("a" <-[go.PointerType GetArg] "$r0");;;
    let: "ab" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (let: "$a0" := (Convert go.untyped_nil (go.SliceType go.byte) UntypedNil) in
    let: "$a1" := (![go.PointerType GetArg] "a") in
    (FuncResolve GetArgEncode [] #()) "$a0" "$a1") in
    do:  ("ab" <-[go.SliceType go.byte] "$r0");;;
    let: "rb" := (GoAlloc (go.PointerType (go.SliceType go.byte)) (GoZeroVal (go.PointerType (go.SliceType go.byte)) #())) in
    let: "$r0" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    do:  ("rb" <-[go.PointerType (go.SliceType go.byte)] "$r0");;;
    (if: let: "$a0" := GetRpc in
    let: "$a1" := (![go.SliceType go.byte] "ab") in
    let: "$a2" := (![go.PointerType (go.SliceType go.byte)] "rb") in
    (MethodResolve (go.PointerType advrpc.Client) "Call"%go (![go.PointerType advrpc.Client] "c")) "$a0" "$a1" "$a2"
    then
      let: "$r0" := ktcore.BlameUnknown in
      do:  ("err" <-[ktcore.Blame] "$r0");;;
      return: (![go.PointerType SignedLink] "link", ![go.PointerType SignedVrf] "vrf", ![ktcore.Blame] "err")
    else do:  #());;;
    let: "errb" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "r" := (GoAlloc (go.PointerType GetReply) (GoZeroVal (go.PointerType GetReply) #())) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] (![go.PointerType (go.SliceType go.byte)] "rb")) in
    (FuncResolve GetReplyDecode [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("r" <-[go.PointerType GetReply] "$r0");;;
    do:  "$r1";;;
    do:  ("errb" <-[go.bool] "$r2");;;
    let: "$r0" := (![go.PointerType SignedLink] (StructFieldRef GetReply "Link"%go (![go.PointerType GetReply] "r"))) in
    do:  ("link" <-[go.PointerType SignedLink] "$r0");;;
    let: "$r0" := (![go.PointerType SignedVrf] (StructFieldRef GetReply "Vrf"%go (![go.PointerType GetReply] "r"))) in
    do:  ("vrf" <-[go.PointerType SignedVrf] "$r0");;;
    (if: ![go.bool] "errb"
    then
      let: "$r0" := ktcore.BlameAdtrFull in
      do:  ("err" <-[ktcore.Blame] "$r0");;;
      return: (![go.PointerType SignedLink] "link", ![go.PointerType SignedVrf] "vrf", ![ktcore.Blame] "err")
    else do:  #());;;
    (if: ![go.bool] (StructFieldRef GetReply "Err"%go (![go.PointerType GetReply] "r"))
    then
      let: "$r0" := ktcore.BlameUnknown in
      do:  ("err" <-[ktcore.Blame] "$r0");;;
      return: (![go.PointerType SignedLink] "link", ![go.PointerType SignedVrf] "vrf", ![ktcore.Blame] "err")
    else do:  #());;;
    return: (![go.PointerType SignedLink] "link", ![go.PointerType SignedVrf] "vrf", ![ktcore.Blame] "err")).

(* go: serde.out.go:10:6 *)
Definition GetArgEncodeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "b0" "o",
    exception_do (let: "o" := (GoAlloc (go.PointerType GetArg) "o") in
    let: "b0" := (GoAlloc (go.SliceType go.byte) "b0") in
    let: "b" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (![go.SliceType go.byte] "b0") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (![go.uint64] (StructFieldRef GetArg "Epoch"%go (![go.PointerType GetArg] "o"))) in
    (FuncResolve marshal.WriteInt [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    return: (![go.SliceType go.byte] "b")).

(* go: serde.out.go:15:6 *)
Definition GetArgDecodeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "b0",
    exception_do (let: "b0" := (GoAlloc (go.SliceType go.byte) "b0") in
    let: "err1" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "b1" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "a1" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "b0") in
    (FuncResolve safemarshal.ReadInt [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a1" <-[go.uint64] "$r0");;;
    do:  ("b1" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err1" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err1"
    then return: (Convert go.untyped_nil (go.PointerType GetArg) UntypedNil, Convert go.untyped_nil (go.SliceType go.byte) UntypedNil, #true)
    else do:  #());;;
    return: (GoAlloc GetArg (CompositeLiteral GetArg (LiteralValue [KeyedElement (Some (KeyField "Epoch"%go)) (ElementExpression go.uint64 (![go.uint64] "a1"))])), ![go.SliceType go.byte] "b1", #false)).

(* go: serde.out.go:22:6 *)
Definition SignedLinkEncodeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "b0" "o",
    exception_do (let: "o" := (GoAlloc (go.PointerType SignedLink) "o") in
    let: "b0" := (GoAlloc (go.SliceType go.byte) "b0") in
    let: "b" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (![go.SliceType go.byte] "b0") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (![go.SliceType go.byte] (StructFieldRef SignedLink "Link"%go (![go.PointerType SignedLink] "o"))) in
    (FuncResolve safemarshal.WriteSlice1D [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (![go.SliceType go.byte] (StructFieldRef SignedLink "ServSig"%go (![go.PointerType SignedLink] "o"))) in
    (FuncResolve safemarshal.WriteSlice1D [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (![go.SliceType go.byte] (StructFieldRef SignedLink "AdtrSig"%go (![go.PointerType SignedLink] "o"))) in
    (FuncResolve safemarshal.WriteSlice1D [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    return: (![go.SliceType go.byte] "b")).

(* go: serde.out.go:29:6 *)
Definition SignedLinkDecodeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "b0",
    exception_do (let: "b0" := (GoAlloc (go.SliceType go.byte) "b0") in
    let: "err1" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "b1" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "a1" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "b0") in
    (FuncResolve safemarshal.ReadSlice1D [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a1" <-[go.SliceType go.byte] "$r0");;;
    do:  ("b1" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err1" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err1"
    then return: (Convert go.untyped_nil (go.PointerType SignedLink) UntypedNil, Convert go.untyped_nil (go.SliceType go.byte) UntypedNil, #true)
    else do:  #());;;
    let: "err2" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "b2" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "a2" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "b1") in
    (FuncResolve safemarshal.ReadSlice1D [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a2" <-[go.SliceType go.byte] "$r0");;;
    do:  ("b2" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err2" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err2"
    then return: (Convert go.untyped_nil (go.PointerType SignedLink) UntypedNil, Convert go.untyped_nil (go.SliceType go.byte) UntypedNil, #true)
    else do:  #());;;
    let: "err3" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "b3" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "a3" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "b2") in
    (FuncResolve safemarshal.ReadSlice1D [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a3" <-[go.SliceType go.byte] "$r0");;;
    do:  ("b3" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err3" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err3"
    then return: (Convert go.untyped_nil (go.PointerType SignedLink) UntypedNil, Convert go.untyped_nil (go.SliceType go.byte) UntypedNil, #true)
    else do:  #());;;
    return: (GoAlloc SignedLink (CompositeLiteral SignedLink (LiteralValue [KeyedElement (Some (KeyField "Link"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] "a1")); KeyedElement (Some (KeyField "ServSig"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] "a2")); KeyedElement (Some (KeyField "AdtrSig"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] "a3"))])), ![go.SliceType go.byte] "b3", #false)).

(* go: serde.out.go:44:6 *)
Definition SignedVrfEncodeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "b0" "o",
    exception_do (let: "o" := (GoAlloc (go.PointerType SignedVrf) "o") in
    let: "b0" := (GoAlloc (go.SliceType go.byte) "b0") in
    let: "b" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (![go.SliceType go.byte] "b0") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (![go.SliceType go.byte] (StructFieldRef SignedVrf "VrfPk"%go (![go.PointerType SignedVrf] "o"))) in
    (FuncResolve safemarshal.WriteSlice1D [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (![go.SliceType go.byte] (StructFieldRef SignedVrf "ServSig"%go (![go.PointerType SignedVrf] "o"))) in
    (FuncResolve safemarshal.WriteSlice1D [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (![go.SliceType go.byte] (StructFieldRef SignedVrf "AdtrSig"%go (![go.PointerType SignedVrf] "o"))) in
    (FuncResolve safemarshal.WriteSlice1D [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    return: (![go.SliceType go.byte] "b")).

(* go: serde.out.go:51:6 *)
Definition SignedVrfDecodeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "b0",
    exception_do (let: "b0" := (GoAlloc (go.SliceType go.byte) "b0") in
    let: "err1" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "b1" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "a1" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "b0") in
    (FuncResolve safemarshal.ReadSlice1D [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a1" <-[go.SliceType go.byte] "$r0");;;
    do:  ("b1" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err1" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err1"
    then return: (Convert go.untyped_nil (go.PointerType SignedVrf) UntypedNil, Convert go.untyped_nil (go.SliceType go.byte) UntypedNil, #true)
    else do:  #());;;
    let: "err2" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "b2" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "a2" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "b1") in
    (FuncResolve safemarshal.ReadSlice1D [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a2" <-[go.SliceType go.byte] "$r0");;;
    do:  ("b2" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err2" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err2"
    then return: (Convert go.untyped_nil (go.PointerType SignedVrf) UntypedNil, Convert go.untyped_nil (go.SliceType go.byte) UntypedNil, #true)
    else do:  #());;;
    let: "err3" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "b3" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "a3" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "b2") in
    (FuncResolve safemarshal.ReadSlice1D [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a3" <-[go.SliceType go.byte] "$r0");;;
    do:  ("b3" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err3" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err3"
    then return: (Convert go.untyped_nil (go.PointerType SignedVrf) UntypedNil, Convert go.untyped_nil (go.SliceType go.byte) UntypedNil, #true)
    else do:  #());;;
    return: (GoAlloc SignedVrf (CompositeLiteral SignedVrf (LiteralValue [KeyedElement (Some (KeyField "VrfPk"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] "a1")); KeyedElement (Some (KeyField "ServSig"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] "a2")); KeyedElement (Some (KeyField "AdtrSig"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] "a3"))])), ![go.SliceType go.byte] "b3", #false)).

(* go: serde.out.go:66:6 *)
Definition GetReplyEncodeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "b0" "o",
    exception_do (let: "o" := (GoAlloc (go.PointerType GetReply) "o") in
    let: "b0" := (GoAlloc (go.SliceType go.byte) "b0") in
    let: "b" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (![go.SliceType go.byte] "b0") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (![go.PointerType SignedLink] (StructFieldRef GetReply "Link"%go (![go.PointerType GetReply] "o"))) in
    (FuncResolve SignedLinkEncode [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (![go.PointerType SignedVrf] (StructFieldRef GetReply "Vrf"%go (![go.PointerType GetReply] "o"))) in
    (FuncResolve SignedVrfEncode [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (![go.bool] (StructFieldRef GetReply "Err"%go (![go.PointerType GetReply] "o"))) in
    (FuncResolve marshal.WriteBool [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    return: (![go.SliceType go.byte] "b")).

(* go: serde.out.go:73:6 *)
Definition GetReplyDecodeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "b0",
    exception_do (let: "b0" := (GoAlloc (go.SliceType go.byte) "b0") in
    let: "err1" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "b1" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "a1" := (GoAlloc (go.PointerType SignedLink) (GoZeroVal (go.PointerType SignedLink) #())) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "b0") in
    (FuncResolve SignedLinkDecode [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a1" <-[go.PointerType SignedLink] "$r0");;;
    do:  ("b1" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err1" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err1"
    then return: (Convert go.untyped_nil (go.PointerType GetReply) UntypedNil, Convert go.untyped_nil (go.SliceType go.byte) UntypedNil, #true)
    else do:  #());;;
    let: "err2" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "b2" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "a2" := (GoAlloc (go.PointerType SignedVrf) (GoZeroVal (go.PointerType SignedVrf) #())) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "b1") in
    (FuncResolve SignedVrfDecode [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a2" <-[go.PointerType SignedVrf] "$r0");;;
    do:  ("b2" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err2" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err2"
    then return: (Convert go.untyped_nil (go.PointerType GetReply) UntypedNil, Convert go.untyped_nil (go.SliceType go.byte) UntypedNil, #true)
    else do:  #());;;
    let: "err3" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "b3" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "a3" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "b2") in
    (FuncResolve safemarshal.ReadBool [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a3" <-[go.bool] "$r0");;;
    do:  ("b3" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err3" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err3"
    then return: (Convert go.untyped_nil (go.PointerType GetReply) UntypedNil, Convert go.untyped_nil (go.SliceType go.byte) UntypedNil, #true)
    else do:  #());;;
    return: (GoAlloc GetReply (CompositeLiteral GetReply (LiteralValue [KeyedElement (Some (KeyField "Link"%go)) (ElementExpression (go.PointerType SignedLink) (![go.PointerType SignedLink] "a1")); KeyedElement (Some (KeyField "Vrf"%go)) (ElementExpression (go.PointerType SignedVrf) (![go.PointerType SignedVrf] "a2")); KeyedElement (Some (KeyField "Err"%go)) (ElementExpression go.bool (![go.bool] "a3"))])), ![go.SliceType go.byte] "b3", #false)).

#[global] Instance info' : PkgInfo pkg_id.auditor :=
{|
  pkg_imported_pkgs := [code.bytes.pkg_id.bytes; code.sync.pkg_id.sync; code.github_com.goose_lang.std.pkg_id.std; code.github_com.sanjit_bhat.pav.advrpc.pkg_id.advrpc; code.github_com.sanjit_bhat.pav.cryptoffi.pkg_id.cryptoffi; code.github_com.sanjit_bhat.pav.hashchain.pkg_id.hashchain; code.github_com.sanjit_bhat.pav.ktcore.pkg_id.ktcore; code.github_com.sanjit_bhat.pav.merkle.pkg_id.merkle; code.github_com.sanjit_bhat.pav.server.pkg_id.server; code.github_com.sanjit_bhat.pav.safemarshal.pkg_id.safemarshal; code.github_com.tchajed.marshal.pkg_id.marshal]
|}.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init pkg_id.auditor (λ: <>,
      exception_do (do:  (marshal.initialize' #());;;
      do:  (safemarshal.initialize' #());;;
      do:  (server.initialize' #());;;
      do:  (merkle.initialize' #());;;
      do:  (ktcore.initialize' #());;;
      do:  (hashchain.initialize' #());;;
      do:  (cryptoffi.initialize' #());;;
      do:  (advrpc.initialize' #());;;
      do:  (std.initialize' #());;;
      do:  (sync.initialize' #());;;
      do:  (bytes.initialize' #()))
      ).

Module Auditor.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  mu' : loc;
  sk' : loc;
  hist' : loc;
  serv' : loc;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End Auditor.

Definition Auditor'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "mu"%go (go.PointerType sync.RWMutex));
  (go.FieldDecl "sk"%go (go.PointerType cryptoffi.SigPrivateKey));
  (go.FieldDecl "hist"%go (go.PointerType history));
  (go.FieldDecl "serv"%go (go.PointerType serv))
].
Program Definition Auditor'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (Auditor'fds_unsealed).
Global Instance equals_unfold_Auditor {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Auditor'fds =→ Auditor'fds_unsealed.
Proof. rewrite /Auditor'fds seal_eq //. Qed.

Definition Auditorⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (Auditor'fds).

Class Auditor_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Auditor_type_repr  :: go.TypeReprUnderlying Auditorⁱᵐᵖˡ Auditor.t;
  #[global] Auditor_underlying :: (Auditor) <u (Auditorⁱᵐᵖˡ);
  #[global] Auditor_get_mu (x : Auditor.t) :: ⟦StructFieldGet (Auditorⁱᵐᵖˡ) "mu", #x⟧ ⤳[under] #x.(Auditor.mu');
  #[global] Auditor_set_mu (x : Auditor.t) y :: ⟦StructFieldSet (Auditorⁱᵐᵖˡ) "mu", (#x, #y)⟧ ⤳[under] #(x <|Auditor.mu' := y|>);
  #[global] Auditor_get_sk (x : Auditor.t) :: ⟦StructFieldGet (Auditorⁱᵐᵖˡ) "sk", #x⟧ ⤳[under] #x.(Auditor.sk');
  #[global] Auditor_set_sk (x : Auditor.t) y :: ⟦StructFieldSet (Auditorⁱᵐᵖˡ) "sk", (#x, #y)⟧ ⤳[under] #(x <|Auditor.sk' := y|>);
  #[global] Auditor_get_hist (x : Auditor.t) :: ⟦StructFieldGet (Auditorⁱᵐᵖˡ) "hist", #x⟧ ⤳[under] #x.(Auditor.hist');
  #[global] Auditor_set_hist (x : Auditor.t) y :: ⟦StructFieldSet (Auditorⁱᵐᵖˡ) "hist", (#x, #y)⟧ ⤳[under] #(x <|Auditor.hist' := y|>);
  #[global] Auditor_get_serv (x : Auditor.t) :: ⟦StructFieldGet (Auditorⁱᵐᵖˡ) "serv", #x⟧ ⤳[under] #x.(Auditor.serv');
  #[global] Auditor_set_serv (x : Auditor.t) y :: ⟦StructFieldSet (Auditorⁱᵐᵖˡ) "serv", (#x, #y)⟧ ⤳[under] #(x <|Auditor.serv' := y|>);
  #[global] Auditor'ptr_Get_unfold :: MethodUnfold (go.PointerType (Auditor)) "Get" (Auditor__Getⁱᵐᵖˡ);
  #[global] Auditor'ptr_Update_unfold :: MethodUnfold (go.PointerType (Auditor)) "Update" (Auditor__Updateⁱᵐᵖˡ);
  #[global] Auditor'ptr_updOnce_unfold :: MethodUnfold (go.PointerType (Auditor)) "updOnce" (Auditor__updOnceⁱᵐᵖˡ);
}.

Module history.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  lastDig' : slice.t;
  startEp' : w64;
  epochs' : slice.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End history.

Definition history'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "lastDig"%go (go.SliceType go.byte));
  (go.FieldDecl "startEp"%go go.uint64);
  (go.FieldDecl "epochs"%go (go.SliceType (go.PointerType epoch)))
].
Program Definition history'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (history'fds_unsealed).
Global Instance equals_unfold_history {ext : ffi_syntax} {go_gctx : GoGlobalContext} : history'fds =→ history'fds_unsealed.
Proof. rewrite /history'fds seal_eq //. Qed.

Definition historyⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (history'fds).

Class history_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] history_type_repr  :: go.TypeReprUnderlying historyⁱᵐᵖˡ history.t;
  #[global] history_underlying :: (history) <u (historyⁱᵐᵖˡ);
  #[global] history_get_lastDig (x : history.t) :: ⟦StructFieldGet (historyⁱᵐᵖˡ) "lastDig", #x⟧ ⤳[under] #x.(history.lastDig');
  #[global] history_set_lastDig (x : history.t) y :: ⟦StructFieldSet (historyⁱᵐᵖˡ) "lastDig", (#x, #y)⟧ ⤳[under] #(x <|history.lastDig' := y|>);
  #[global] history_get_startEp (x : history.t) :: ⟦StructFieldGet (historyⁱᵐᵖˡ) "startEp", #x⟧ ⤳[under] #x.(history.startEp');
  #[global] history_set_startEp (x : history.t) y :: ⟦StructFieldSet (historyⁱᵐᵖˡ) "startEp", (#x, #y)⟧ ⤳[under] #(x <|history.startEp' := y|>);
  #[global] history_get_epochs (x : history.t) :: ⟦StructFieldGet (historyⁱᵐᵖˡ) "epochs", #x⟧ ⤳[under] #x.(history.epochs');
  #[global] history_set_epochs (x : history.t) y :: ⟦StructFieldSet (historyⁱᵐᵖˡ) "epochs", (#x, #y)⟧ ⤳[under] #(x <|history.epochs' := y|>);
}.

Module epoch.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  link' : slice.t;
  servSig' : slice.t;
  adtrSig' : slice.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End epoch.

Definition epoch'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "link"%go (go.SliceType go.byte));
  (go.FieldDecl "servSig"%go (go.SliceType go.byte));
  (go.FieldDecl "adtrSig"%go (go.SliceType go.byte))
].
Program Definition epoch'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (epoch'fds_unsealed).
Global Instance equals_unfold_epoch {ext : ffi_syntax} {go_gctx : GoGlobalContext} : epoch'fds =→ epoch'fds_unsealed.
Proof. rewrite /epoch'fds seal_eq //. Qed.

Definition epochⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (epoch'fds).

Class epoch_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] epoch_type_repr  :: go.TypeReprUnderlying epochⁱᵐᵖˡ epoch.t;
  #[global] epoch_underlying :: (epoch) <u (epochⁱᵐᵖˡ);
  #[global] epoch_get_link (x : epoch.t) :: ⟦StructFieldGet (epochⁱᵐᵖˡ) "link", #x⟧ ⤳[under] #x.(epoch.link');
  #[global] epoch_set_link (x : epoch.t) y :: ⟦StructFieldSet (epochⁱᵐᵖˡ) "link", (#x, #y)⟧ ⤳[under] #(x <|epoch.link' := y|>);
  #[global] epoch_get_servSig (x : epoch.t) :: ⟦StructFieldGet (epochⁱᵐᵖˡ) "servSig", #x⟧ ⤳[under] #x.(epoch.servSig');
  #[global] epoch_set_servSig (x : epoch.t) y :: ⟦StructFieldSet (epochⁱᵐᵖˡ) "servSig", (#x, #y)⟧ ⤳[under] #(x <|epoch.servSig' := y|>);
  #[global] epoch_get_adtrSig (x : epoch.t) :: ⟦StructFieldGet (epochⁱᵐᵖˡ) "adtrSig", #x⟧ ⤳[under] #x.(epoch.adtrSig');
  #[global] epoch_set_adtrSig (x : epoch.t) y :: ⟦StructFieldSet (epochⁱᵐᵖˡ) "adtrSig", (#x, #y)⟧ ⤳[under] #(x <|epoch.adtrSig' := y|>);
}.

Module serv.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  cli' : loc;
  sigPk' : cryptoffi.SigPublicKey.t;
  vrfPk' : slice.t;
  servVrfSig' : slice.t;
  adtrVrfSig' : slice.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End serv.

Definition serv'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "cli"%go (go.PointerType advrpc.Client));
  (go.FieldDecl "sigPk"%go cryptoffi.SigPublicKey);
  (go.FieldDecl "vrfPk"%go (go.SliceType go.byte));
  (go.FieldDecl "servVrfSig"%go (go.SliceType go.byte));
  (go.FieldDecl "adtrVrfSig"%go (go.SliceType go.byte))
].
Program Definition serv'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (serv'fds_unsealed).
Global Instance equals_unfold_serv {ext : ffi_syntax} {go_gctx : GoGlobalContext} : serv'fds =→ serv'fds_unsealed.
Proof. rewrite /serv'fds seal_eq //. Qed.

Definition servⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (serv'fds).

Class serv_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] serv_type_repr  :: go.TypeReprUnderlying servⁱᵐᵖˡ serv.t;
  #[global] serv_underlying :: (serv) <u (servⁱᵐᵖˡ);
  #[global] serv_get_cli (x : serv.t) :: ⟦StructFieldGet (servⁱᵐᵖˡ) "cli", #x⟧ ⤳[under] #x.(serv.cli');
  #[global] serv_set_cli (x : serv.t) y :: ⟦StructFieldSet (servⁱᵐᵖˡ) "cli", (#x, #y)⟧ ⤳[under] #(x <|serv.cli' := y|>);
  #[global] serv_get_sigPk (x : serv.t) :: ⟦StructFieldGet (servⁱᵐᵖˡ) "sigPk", #x⟧ ⤳[under] #x.(serv.sigPk');
  #[global] serv_set_sigPk (x : serv.t) y :: ⟦StructFieldSet (servⁱᵐᵖˡ) "sigPk", (#x, #y)⟧ ⤳[under] #(x <|serv.sigPk' := y|>);
  #[global] serv_get_vrfPk (x : serv.t) :: ⟦StructFieldGet (servⁱᵐᵖˡ) "vrfPk", #x⟧ ⤳[under] #x.(serv.vrfPk');
  #[global] serv_set_vrfPk (x : serv.t) y :: ⟦StructFieldSet (servⁱᵐᵖˡ) "vrfPk", (#x, #y)⟧ ⤳[under] #(x <|serv.vrfPk' := y|>);
  #[global] serv_get_servVrfSig (x : serv.t) :: ⟦StructFieldGet (servⁱᵐᵖˡ) "servVrfSig", #x⟧ ⤳[under] #x.(serv.servVrfSig');
  #[global] serv_set_servVrfSig (x : serv.t) y :: ⟦StructFieldSet (servⁱᵐᵖˡ) "servVrfSig", (#x, #y)⟧ ⤳[under] #(x <|serv.servVrfSig' := y|>);
  #[global] serv_get_adtrVrfSig (x : serv.t) :: ⟦StructFieldGet (servⁱᵐᵖˡ) "adtrVrfSig", #x⟧ ⤳[under] #x.(serv.adtrVrfSig');
  #[global] serv_set_adtrVrfSig (x : serv.t) y :: ⟦StructFieldSet (servⁱᵐᵖˡ) "adtrVrfSig", (#x, #y)⟧ ⤳[under] #(x <|serv.adtrVrfSig' := y|>);
}.

Module GetArg.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  Epoch' : w64;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End GetArg.

Definition GetArg'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "Epoch"%go go.uint64)
].
Program Definition GetArg'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (GetArg'fds_unsealed).
Global Instance equals_unfold_GetArg {ext : ffi_syntax} {go_gctx : GoGlobalContext} : GetArg'fds =→ GetArg'fds_unsealed.
Proof. rewrite /GetArg'fds seal_eq //. Qed.

Definition GetArgⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (GetArg'fds).

Class GetArg_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] GetArg_type_repr  :: go.TypeReprUnderlying GetArgⁱᵐᵖˡ GetArg.t;
  #[global] GetArg_underlying :: (GetArg) <u (GetArgⁱᵐᵖˡ);
  #[global] GetArg_get_Epoch (x : GetArg.t) :: ⟦StructFieldGet (GetArgⁱᵐᵖˡ) "Epoch", #x⟧ ⤳[under] #x.(GetArg.Epoch');
  #[global] GetArg_set_Epoch (x : GetArg.t) y :: ⟦StructFieldSet (GetArgⁱᵐᵖˡ) "Epoch", (#x, #y)⟧ ⤳[under] #(x <|GetArg.Epoch' := y|>);
}.

Module SignedLink.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  Link' : slice.t;
  ServSig' : slice.t;
  AdtrSig' : slice.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End SignedLink.

Definition SignedLink'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "Link"%go (go.SliceType go.byte));
  (go.FieldDecl "ServSig"%go (go.SliceType go.byte));
  (go.FieldDecl "AdtrSig"%go (go.SliceType go.byte))
].
Program Definition SignedLink'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (SignedLink'fds_unsealed).
Global Instance equals_unfold_SignedLink {ext : ffi_syntax} {go_gctx : GoGlobalContext} : SignedLink'fds =→ SignedLink'fds_unsealed.
Proof. rewrite /SignedLink'fds seal_eq //. Qed.

Definition SignedLinkⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (SignedLink'fds).

Class SignedLink_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] SignedLink_type_repr  :: go.TypeReprUnderlying SignedLinkⁱᵐᵖˡ SignedLink.t;
  #[global] SignedLink_underlying :: (SignedLink) <u (SignedLinkⁱᵐᵖˡ);
  #[global] SignedLink_get_Link (x : SignedLink.t) :: ⟦StructFieldGet (SignedLinkⁱᵐᵖˡ) "Link", #x⟧ ⤳[under] #x.(SignedLink.Link');
  #[global] SignedLink_set_Link (x : SignedLink.t) y :: ⟦StructFieldSet (SignedLinkⁱᵐᵖˡ) "Link", (#x, #y)⟧ ⤳[under] #(x <|SignedLink.Link' := y|>);
  #[global] SignedLink_get_ServSig (x : SignedLink.t) :: ⟦StructFieldGet (SignedLinkⁱᵐᵖˡ) "ServSig", #x⟧ ⤳[under] #x.(SignedLink.ServSig');
  #[global] SignedLink_set_ServSig (x : SignedLink.t) y :: ⟦StructFieldSet (SignedLinkⁱᵐᵖˡ) "ServSig", (#x, #y)⟧ ⤳[under] #(x <|SignedLink.ServSig' := y|>);
  #[global] SignedLink_get_AdtrSig (x : SignedLink.t) :: ⟦StructFieldGet (SignedLinkⁱᵐᵖˡ) "AdtrSig", #x⟧ ⤳[under] #x.(SignedLink.AdtrSig');
  #[global] SignedLink_set_AdtrSig (x : SignedLink.t) y :: ⟦StructFieldSet (SignedLinkⁱᵐᵖˡ) "AdtrSig", (#x, #y)⟧ ⤳[under] #(x <|SignedLink.AdtrSig' := y|>);
}.

Module SignedVrf.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  VrfPk' : slice.t;
  ServSig' : slice.t;
  AdtrSig' : slice.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End SignedVrf.

Definition SignedVrf'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "VrfPk"%go (go.SliceType go.byte));
  (go.FieldDecl "ServSig"%go (go.SliceType go.byte));
  (go.FieldDecl "AdtrSig"%go (go.SliceType go.byte))
].
Program Definition SignedVrf'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (SignedVrf'fds_unsealed).
Global Instance equals_unfold_SignedVrf {ext : ffi_syntax} {go_gctx : GoGlobalContext} : SignedVrf'fds =→ SignedVrf'fds_unsealed.
Proof. rewrite /SignedVrf'fds seal_eq //. Qed.

Definition SignedVrfⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (SignedVrf'fds).

Class SignedVrf_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] SignedVrf_type_repr  :: go.TypeReprUnderlying SignedVrfⁱᵐᵖˡ SignedVrf.t;
  #[global] SignedVrf_underlying :: (SignedVrf) <u (SignedVrfⁱᵐᵖˡ);
  #[global] SignedVrf_get_VrfPk (x : SignedVrf.t) :: ⟦StructFieldGet (SignedVrfⁱᵐᵖˡ) "VrfPk", #x⟧ ⤳[under] #x.(SignedVrf.VrfPk');
  #[global] SignedVrf_set_VrfPk (x : SignedVrf.t) y :: ⟦StructFieldSet (SignedVrfⁱᵐᵖˡ) "VrfPk", (#x, #y)⟧ ⤳[under] #(x <|SignedVrf.VrfPk' := y|>);
  #[global] SignedVrf_get_ServSig (x : SignedVrf.t) :: ⟦StructFieldGet (SignedVrfⁱᵐᵖˡ) "ServSig", #x⟧ ⤳[under] #x.(SignedVrf.ServSig');
  #[global] SignedVrf_set_ServSig (x : SignedVrf.t) y :: ⟦StructFieldSet (SignedVrfⁱᵐᵖˡ) "ServSig", (#x, #y)⟧ ⤳[under] #(x <|SignedVrf.ServSig' := y|>);
  #[global] SignedVrf_get_AdtrSig (x : SignedVrf.t) :: ⟦StructFieldGet (SignedVrfⁱᵐᵖˡ) "AdtrSig", #x⟧ ⤳[under] #x.(SignedVrf.AdtrSig');
  #[global] SignedVrf_set_AdtrSig (x : SignedVrf.t) y :: ⟦StructFieldSet (SignedVrfⁱᵐᵖˡ) "AdtrSig", (#x, #y)⟧ ⤳[under] #(x <|SignedVrf.AdtrSig' := y|>);
}.

Module GetReply.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  Link' : loc;
  Vrf' : loc;
  Err' : bool;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End GetReply.

Definition GetReply'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "Link"%go (go.PointerType SignedLink));
  (go.FieldDecl "Vrf"%go (go.PointerType SignedVrf));
  (go.FieldDecl "Err"%go go.bool)
].
Program Definition GetReply'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (GetReply'fds_unsealed).
Global Instance equals_unfold_GetReply {ext : ffi_syntax} {go_gctx : GoGlobalContext} : GetReply'fds =→ GetReply'fds_unsealed.
Proof. rewrite /GetReply'fds seal_eq //. Qed.

Definition GetReplyⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (GetReply'fds).

Class GetReply_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] GetReply_type_repr  :: go.TypeReprUnderlying GetReplyⁱᵐᵖˡ GetReply.t;
  #[global] GetReply_underlying :: (GetReply) <u (GetReplyⁱᵐᵖˡ);
  #[global] GetReply_get_Link (x : GetReply.t) :: ⟦StructFieldGet (GetReplyⁱᵐᵖˡ) "Link", #x⟧ ⤳[under] #x.(GetReply.Link');
  #[global] GetReply_set_Link (x : GetReply.t) y :: ⟦StructFieldSet (GetReplyⁱᵐᵖˡ) "Link", (#x, #y)⟧ ⤳[under] #(x <|GetReply.Link' := y|>);
  #[global] GetReply_get_Vrf (x : GetReply.t) :: ⟦StructFieldGet (GetReplyⁱᵐᵖˡ) "Vrf", #x⟧ ⤳[under] #x.(GetReply.Vrf');
  #[global] GetReply_set_Vrf (x : GetReply.t) y :: ⟦StructFieldSet (GetReplyⁱᵐᵖˡ) "Vrf", (#x, #y)⟧ ⤳[under] #(x <|GetReply.Vrf' := y|>);
  #[global] GetReply_get_Err (x : GetReply.t) :: ⟦StructFieldGet (GetReplyⁱᵐᵖˡ) "Err", #x⟧ ⤳[under] #x.(GetReply.Err');
  #[global] GetReply_set_Err (x : GetReply.t) y :: ⟦StructFieldSet (GetReplyⁱᵐᵖˡ) "Err", (#x, #y)⟧ ⤳[under] #(x <|GetReply.Err' := y|>);
}.

Class Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Auditor_instance :: Auditor_Assumptions;
  #[global] history_instance :: history_Assumptions;
  #[global] epoch_instance :: epoch_Assumptions;
  #[global] serv_instance :: serv_Assumptions;
  #[global] GetArg_instance :: GetArg_Assumptions;
  #[global] SignedLink_instance :: SignedLink_Assumptions;
  #[global] SignedVrf_instance :: SignedVrf_Assumptions;
  #[global] GetReply_instance :: GetReply_Assumptions;
  #[global] New_unfold :: FuncUnfold New [] (Newⁱᵐᵖˡ);
  #[global] getNextLink_unfold :: FuncUnfold getNextLink [] (getNextLinkⁱᵐᵖˡ);
  #[global] getNextDig_unfold :: FuncUnfold getNextDig [] (getNextDigⁱᵐᵖˡ);
  #[global] CheckStartChain_unfold :: FuncUnfold CheckStartChain [] (CheckStartChainⁱᵐᵖˡ);
  #[global] CheckStartVrf_unfold :: FuncUnfold CheckStartVrf [] (CheckStartVrfⁱᵐᵖˡ);
  #[global] NewRpcAuditor_unfold :: FuncUnfold NewRpcAuditor [] (NewRpcAuditorⁱᵐᵖˡ);
  #[global] CallGet_unfold :: FuncUnfold CallGet [] (CallGetⁱᵐᵖˡ);
  #[global] GetArgEncode_unfold :: FuncUnfold GetArgEncode [] (GetArgEncodeⁱᵐᵖˡ);
  #[global] GetArgDecode_unfold :: FuncUnfold GetArgDecode [] (GetArgDecodeⁱᵐᵖˡ);
  #[global] SignedLinkEncode_unfold :: FuncUnfold SignedLinkEncode [] (SignedLinkEncodeⁱᵐᵖˡ);
  #[global] SignedLinkDecode_unfold :: FuncUnfold SignedLinkDecode [] (SignedLinkDecodeⁱᵐᵖˡ);
  #[global] SignedVrfEncode_unfold :: FuncUnfold SignedVrfEncode [] (SignedVrfEncodeⁱᵐᵖˡ);
  #[global] SignedVrfDecode_unfold :: FuncUnfold SignedVrfDecode [] (SignedVrfDecodeⁱᵐᵖˡ);
  #[global] GetReplyEncode_unfold :: FuncUnfold GetReplyEncode [] (GetReplyEncodeⁱᵐᵖˡ);
  #[global] GetReplyDecode_unfold :: FuncUnfold GetReplyDecode [] (GetReplyDecodeⁱᵐᵖˡ);
  #[global] import_bytes_Assumption :: bytes.Assumptions;
  #[global] import_sync_Assumption :: sync.Assumptions;
  #[global] import_std_Assumption :: std.Assumptions;
  #[global] import_advrpc_Assumption :: advrpc.Assumptions;
  #[global] import_cryptoffi_Assumption :: cryptoffi.Assumptions;
  #[global] import_hashchain_Assumption :: hashchain.Assumptions;
  #[global] import_ktcore_Assumption :: ktcore.Assumptions;
  #[global] import_merkle_Assumption :: merkle.Assumptions;
  #[global] import_server_Assumption :: server.Assumptions;
  #[global] import_safemarshal_Assumption :: safemarshal.Assumptions;
  #[global] import_marshal_Assumption :: marshal.Assumptions;
}.
End auditor.
