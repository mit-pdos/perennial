(* autogenerated from github.com/sanjit-bhat/pav/cryptoutil *)
Require Export New.code.github_com.sanjit_bhat.pav.cryptoffi.
From New.golang Require Import defn.
Module pkg_id.
Definition cryptoutil : go_string := "github.com/sanjit-bhat/pav/cryptoutil".

End pkg_id.
Export pkg_id.
Module cryptoutil.

Definition Hash {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/sanjit-bhat/pav/cryptoutil.Hash"%go.

(* go: cryptoutil.go:7:6 *)
Definition Hashⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "b",
    exception_do (let: "hash" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "b" := (GoAlloc (go.SliceType go.byte) "b") in
    let: "hr" := (GoAlloc (go.PointerType cryptoffi.Hasher) (GoZeroVal (go.PointerType cryptoffi.Hasher) #())) in
    let: "$r0" := ((FuncResolve cryptoffi.NewHasher [] #()) #()) in
    do:  ("hr" <-[go.PointerType cryptoffi.Hasher] "$r0");;;
    do:  (let: "$a0" := (![go.SliceType go.byte] "b") in
    (MethodResolve (go.PointerType cryptoffi.Hasher) "Write"%go (![go.PointerType cryptoffi.Hasher] "hr")) "$a0");;;
    return: (let: "$a0" := (Convert go.untyped_nil (go.SliceType go.byte) UntypedNil) in
     (MethodResolve (go.PointerType cryptoffi.Hasher) "Sum"%go (![go.PointerType cryptoffi.Hasher] "hr")) "$a0")).

#[global] Instance info' : PkgInfo pkg_id.cryptoutil :=
{|
  pkg_imported_pkgs := [code.github_com.sanjit_bhat.pav.cryptoffi.pkg_id.cryptoffi]
|}.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init pkg_id.cryptoutil (λ: <>,
      exception_do (do:  (cryptoffi.initialize' #()))
      ).

Class Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Hash_unfold :: FuncUnfold Hash [] (Hashⁱᵐᵖˡ);
  #[global] import_cryptoffi_Assumption :: cryptoffi.Assumptions;
}.
End cryptoutil.
