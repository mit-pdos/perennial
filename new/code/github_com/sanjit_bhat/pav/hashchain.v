(* autogenerated from github.com/sanjit-bhat/pav/hashchain *)
Require Export New.code.bytes.
Require Export New.code.github_com.goose_lang.std.
Require Export New.code.github_com.sanjit_bhat.pav.cryptoffi.
Require Export New.code.github_com.sanjit_bhat.pav.cryptoutil.

From New.golang Require Import defn.
Definition hashchain : go_string := "github.com/sanjit-bhat/pav/hashchain".

Module hashchain.

Section code.
Context `{ffi_syntax}.


Definition HashChainⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "predLastLink"%go (go.SliceType go.byte));
  (go.FieldDecl "lastLink"%go (go.SliceType go.byte));
  (go.FieldDecl "vals"%go (go.SliceType go.byte))
].

Definition HashChain : go.type := go.Named "github.com/sanjit-bhat/pav/hashchain.HashChain"%go [].

Definition GetNextLink : go_string := "github.com/sanjit-bhat/pav/hashchain.GetNextLink"%go.

(* Append adds a val.
   it expects val to be of constant len, which lets us encode smaller proofs.

   go: hashchain.go:21:21 *)
Definition HashChain__Appendⁱᵐᵖˡ : val :=
  λ: "c" "val",
    exception_do (let: "newLink" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "c" := (go.AllocValue (go.PointerType HashChain) "c") in
    let: "val" := (go.AllocValue (go.SliceType go.byte) "val") in
    do:  (let: "$a0" := ((s_to_w64 (let: "$a0" := (![go.SliceType go.byte] "val") in
    (FuncResolve go.len [go.SliceType go.byte] #()) "$a0")) =⟨go.uint64⟩ cryptoffi.HashLen) in
    (FuncResolve std.Assert [] #()) "$a0");;;
    let: "$r0" := (![go.SliceType go.byte] (StructFieldRef HashChain "lastLink"%go (![go.PointerType HashChain] "c"))) in
    do:  ((StructFieldRef HashChain "predLastLink"%go (![go.PointerType HashChain] "c")) <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] (StructFieldRef HashChain "lastLink"%go (![go.PointerType HashChain] "c"))) in
    let: "$a1" := (![go.SliceType go.byte] "val") in
    (FuncResolve GetNextLink [] #()) "$a0" "$a1") in
    do:  ((StructFieldRef HashChain "lastLink"%go (![go.PointerType HashChain] "c")) <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] (StructFieldRef HashChain "vals"%go (![go.PointerType HashChain] "c"))) in
    let: "$a1" := (![go.SliceType go.byte] "val") in
    (FuncResolve go.append [go.SliceType go.byte] #()) "$a0" "$a1") in
    do:  ((StructFieldRef HashChain "vals"%go (![go.PointerType HashChain] "c")) <-[go.SliceType go.byte] "$r0");;;
    return: (![go.SliceType go.byte] (StructFieldRef HashChain "lastLink"%go (![go.PointerType HashChain] "c")))).

(* Prove transitions from knowing a prevLen prefix to knowing the latest list.
   it expects prevLen <= curr len.

   go: hashchain.go:31:21 *)
Definition HashChain__Proveⁱᵐᵖˡ : val :=
  λ: "c" "prevLen",
    exception_do (let: "proof" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "c" := (go.AllocValue (go.PointerType HashChain) "c") in
    let: "prevLen" := (go.AllocValue go.uint64 "prevLen") in
    let: "start" := (GoAlloc go.uint64 #()) in
    let: "$r0" := ((![go.uint64] "prevLen") *⟨go.uint64⟩ cryptoffi.HashLen) in
    do:  ("start" <-[go.uint64] "$r0");;;
    return: (let: "$a0" := (let: "$s" := (![go.SliceType go.byte] (StructFieldRef HashChain "vals"%go (![go.PointerType HashChain] "c"))) in
     slice.slice go.byte "$s" (![go.uint64] "start") (slice.len "$s")) in
     (FuncResolve bytes.Clone [] #()) "$a0")).

(* Bootstrap hashchain verifiers with the last value.
   it expects non-empty values.

   go: hashchain.go:38:21 *)
Definition HashChain__Bootstrapⁱᵐᵖˡ : val :=
  λ: "c" <>,
    exception_do (let: "proof" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "bootLink" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "c" := (go.AllocValue (go.PointerType HashChain) "c") in
    let: "start" := (GoAlloc go.uint64 #()) in
    let: "$r0" := ((s_to_w64 (let: "$a0" := (![go.SliceType go.byte] (StructFieldRef HashChain "vals"%go (![go.PointerType HashChain] "c"))) in
    (FuncResolve go.len [go.SliceType go.byte] #()) "$a0")) -⟨go.uint64⟩ cryptoffi.HashLen) in
    do:  ("start" <-[go.uint64] "$r0");;;
    return: (![go.SliceType go.byte] (StructFieldRef HashChain "predLastLink"%go (![go.PointerType HashChain] "c")), let: "$a0" := (let: "$s" := (![go.SliceType go.byte] (StructFieldRef HashChain "vals"%go (![go.PointerType HashChain] "c"))) in
     slice.slice go.byte "$s" (![go.uint64] "start") (slice.len "$s")) in
     (FuncResolve bytes.Clone [] #()) "$a0")).

Definition Verify : go_string := "github.com/sanjit-bhat/pav/hashchain.Verify"%go.

(* Verify updates prevLink with proof.
   if extended length is 0, new val is nil.
   it errors for a badly-encoded proof.

   go: hashchain.go:46:6 *)
Definition Verifyⁱᵐᵖˡ : val :=
  λ: "prevLink" "proof",
    exception_do (let: "err" := (GoAlloc go.bool #()) in
    let: "newLink" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "newVal" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "extLen" := (GoAlloc go.uint64 #()) in
    let: "proof" := (go.AllocValue (go.SliceType go.byte) "proof") in
    let: "prevLink" := (go.AllocValue (go.SliceType go.byte) "prevLink") in
    let: "proofLen" := (GoAlloc go.uint64 #()) in
    let: "$r0" := (s_to_w64 (let: "$a0" := (![go.SliceType go.byte] "proof") in
    (FuncResolve go.len [go.SliceType go.byte] #()) "$a0")) in
    do:  ("proofLen" <-[go.uint64] "$r0");;;
    (if: ((![go.uint64] "proofLen") `rem`⟨go.uint64⟩ cryptoffi.HashLen) ≠⟨go.uint64⟩ #(W64 0)
    then
      let: "$r0" := #true in
      do:  ("err" <-[go.bool] "$r0");;;
      return: (![go.uint64] "extLen", ![go.SliceType go.byte] "newVal", ![go.SliceType go.byte] "newLink", ![go.bool] "err")
    else do:  #());;;
    let: "$r0" := ((![go.uint64] "proofLen") `quot`⟨go.uint64⟩ cryptoffi.HashLen) in
    do:  ("extLen" <-[go.uint64] "$r0");;;
    let: "$r0" := (![go.SliceType go.byte] "prevLink") in
    do:  ("newLink" <-[go.SliceType go.byte] "$r0");;;
    (let: "i" := (GoAlloc go.uint64 #()) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, (![go.uint64] "i") <⟨go.uint64⟩ (![go.uint64] "extLen")); (λ: <>, do:  ("i" <-[go.uint64] ((![go.uint64] "i") +⟨go.uint64⟩ #(W8 1)))) := λ: <>,
      let: "$r0" := (let: "$s" := (![go.SliceType go.byte] "proof") in
      slice.slice go.byte "$s" #(W64 0) cryptoffi.HashLen) in
      do:  ("newVal" <-[go.SliceType go.byte] "$r0");;;
      let: "$r0" := (let: "$s" := (![go.SliceType go.byte] "proof") in
      slice.slice go.byte "$s" cryptoffi.HashLen (slice.len "$s")) in
      do:  ("proof" <-[go.SliceType go.byte] "$r0");;;
      let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "newLink") in
      let: "$a1" := (![go.SliceType go.byte] "newVal") in
      (FuncResolve GetNextLink [] #()) "$a0" "$a1") in
      do:  ("newLink" <-[go.SliceType go.byte] "$r0")));;;
    return: (![go.uint64] "extLen", ![go.SliceType go.byte] "newVal", ![go.SliceType go.byte] "newLink", ![go.bool] "err")).

Definition New : go_string := "github.com/sanjit-bhat/pav/hashchain.New"%go.

Definition GetEmptyLink : go_string := "github.com/sanjit-bhat/pav/hashchain.GetEmptyLink"%go.

(* go: hashchain.go:63:6 *)
Definition Newⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (go.AllocValue HashChain (let: "$lastLink" := ((FuncResolve GetEmptyLink [] #()) #()) in
     CompositeLiteral HashChain (
       let: "$$vs" := go.StructElementListNil #() in 
       let: "$$vs" := go.ElementListApp "$$vs" (go.ZeroVal (go.SliceType go.byte) #()) in
       let: "$$vs" := go.ElementListApp "$$vs" "$lastLink" in
       let: "$$vs" := go.ElementListApp "$$vs" (go.ZeroVal (go.SliceType go.byte) #()) in
       "$$vs"
     )))).

(* go: hashchain.go:67:6 *)
Definition GetEmptyLinkⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (let: "$a0" := #slice.nil in
     (FuncResolve cryptoutil.Hash [] #()) "$a0")).

(* go: hashchain.go:71:6 *)
Definition GetNextLinkⁱᵐᵖˡ : val :=
  λ: "prevLink" "nextVal",
    exception_do (let: "nextVal" := (go.AllocValue (go.SliceType go.byte) "nextVal") in
    let: "prevLink" := (go.AllocValue (go.SliceType go.byte) "prevLink") in
    let: "hr" := (GoAlloc (go.PointerType cryptoffi.Hasher) #()) in
    let: "$r0" := ((FuncResolve cryptoffi.NewHasher [] #()) #()) in
    do:  ("hr" <-[go.PointerType cryptoffi.Hasher] "$r0");;;
    do:  (let: "$a0" := (![go.SliceType go.byte] "prevLink") in
    (MethodResolve (go.PointerType cryptoffi.Hasher) Write #() (![go.PointerType cryptoffi.Hasher] "hr")) "$a0");;;
    do:  (let: "$a0" := (![go.SliceType go.byte] "nextVal") in
    (MethodResolve (go.PointerType cryptoffi.Hasher) Write #() (![go.PointerType cryptoffi.Hasher] "hr")) "$a0");;;
    return: (let: "$a0" := #slice.nil in
     (MethodResolve (go.PointerType cryptoffi.Hasher) Sum #() (![go.PointerType cryptoffi.Hasher] "hr")) "$a0")).

Definition functions' : list (go_string * val) := [(Verify, Verifyⁱᵐᵖˡ); (New, Newⁱᵐᵖˡ); (GetEmptyLink, GetEmptyLinkⁱᵐᵖˡ); (GetNextLink, GetNextLinkⁱᵐᵖˡ)].

#[global] Instance info' : PkgInfo hashchain.hashchain :=
  {|
    pkg_imported_pkgs := [code.bytes.bytes; code.github_com.goose_lang.std.std; code.github_com.sanjit_bhat.pav.cryptoffi.cryptoffi; code.github_com.sanjit_bhat.pav.cryptoutil.cryptoutil];
  |}.

Definition initialize' : val :=
  λ: <>,
    package.init hashchain.hashchain (λ: <>,
      exception_do (do:  (cryptoutil.initialize' #());;;
      do:  (cryptoffi.initialize' #());;;
      do:  (std.initialize' #());;;
      do:  (bytes.initialize' #()))
      ).

End code.
End hashchain.
