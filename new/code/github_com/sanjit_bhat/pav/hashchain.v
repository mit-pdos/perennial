(* autogenerated from github.com/sanjit-bhat/pav/hashchain *)
From New.golang Require Import defn.
Require Export New.code.bytes.
Require Export New.code.github_com.goose_lang.std.
Require Export New.code.github_com.sanjit_bhat.pav.cryptoffi.
Require Export New.code.github_com.sanjit_bhat.pav.cryptoutil.

Definition hashchain : go_string := "github.com/sanjit-bhat/pav/hashchain".

Module hashchain.
Section code.
Context `{ffi_syntax}.


Definition HashChain : go_type := structT [
  "predLastLink" :: sliceT;
  "lastLink" :: sliceT;
  "vals" :: sliceT
].

(* Append adds a val.
   it expects val to be of constant len, which lets us encode smaller proofs.

   go: hashchain.go:21:21 *)
Definition HashChain__Append : val :=
  rec: "HashChain__Append" "c" "val" :=
    exception_do (let: "newLink" := (mem.alloc (type.zero_val #sliceT)) in
    let: "c" := (mem.alloc "c") in
    let: "val" := (mem.alloc "val") in
    do:  (let: "$a0" := ((s_to_w64 (let: "$a0" := (![#sliceT] "val") in
    slice.len "$a0")) = cryptoffi.HashLen) in
    (func_call #std.std #"Assert"%go) "$a0");;;
    let: "$r0" := (![#sliceT] (struct.field_ref #HashChain #"lastLink"%go (![#ptrT] "c"))) in
    do:  ((struct.field_ref #HashChain #"predLastLink"%go (![#ptrT] "c")) <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] (struct.field_ref #HashChain #"lastLink"%go (![#ptrT] "c"))) in
    let: "$a1" := (![#sliceT] "val") in
    (func_call #hashchain.hashchain #"GetNextLink"%go) "$a0" "$a1") in
    do:  ((struct.field_ref #HashChain #"lastLink"%go (![#ptrT] "c")) <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] (struct.field_ref #HashChain #"vals"%go (![#ptrT] "c"))) in
    let: "$a1" := (![#sliceT] "val") in
    (slice.append #byteT) "$a0" "$a1") in
    do:  ((struct.field_ref #HashChain #"vals"%go (![#ptrT] "c")) <-[#sliceT] "$r0");;;
    return: (![#sliceT] (struct.field_ref #HashChain #"lastLink"%go (![#ptrT] "c")))).

(* Prove transitions from knowing a prevLen prefix to knowing the latest list.
   it expects prevLen <= curr len.

   go: hashchain.go:31:21 *)
Definition HashChain__Prove : val :=
  rec: "HashChain__Prove" "c" "prevLen" :=
    exception_do (let: "proof" := (mem.alloc (type.zero_val #sliceT)) in
    let: "c" := (mem.alloc "c") in
    let: "prevLen" := (mem.alloc "prevLen") in
    let: "start" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := ((![#uint64T] "prevLen") * cryptoffi.HashLen) in
    do:  ("start" <-[#uint64T] "$r0");;;
    return: (let: "$a0" := (let: "$s" := (![#sliceT] (struct.field_ref #HashChain #"vals"%go (![#ptrT] "c"))) in
     slice.slice #byteT "$s" (![#uint64T] "start") (slice.len "$s")) in
     (func_call #bytes.bytes #"Clone"%go) "$a0")).

(* Bootstrap hashchain verifiers with the last value.
   it expects non-empty values.

   go: hashchain.go:38:21 *)
Definition HashChain__Bootstrap : val :=
  rec: "HashChain__Bootstrap" "c" <> :=
    exception_do (let: "proof" := (mem.alloc (type.zero_val #sliceT)) in
    let: "bootLink" := (mem.alloc (type.zero_val #sliceT)) in
    let: "c" := (mem.alloc "c") in
    let: "start" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := ((s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref #HashChain #"vals"%go (![#ptrT] "c"))) in
    slice.len "$a0")) - cryptoffi.HashLen) in
    do:  ("start" <-[#uint64T] "$r0");;;
    return: (![#sliceT] (struct.field_ref #HashChain #"predLastLink"%go (![#ptrT] "c")), let: "$a0" := (let: "$s" := (![#sliceT] (struct.field_ref #HashChain #"vals"%go (![#ptrT] "c"))) in
     slice.slice #byteT "$s" (![#uint64T] "start") (slice.len "$s")) in
     (func_call #bytes.bytes #"Clone"%go) "$a0")).

(* Verify updates prevLink with proof.
   if extended length is 0, new val is nil.
   it errors for a badly-encoded proof.

   go: hashchain.go:46:6 *)
Definition Verify : val :=
  rec: "Verify" "prevLink" "proof" :=
    exception_do (let: "err" := (mem.alloc (type.zero_val #boolT)) in
    let: "newLink" := (mem.alloc (type.zero_val #sliceT)) in
    let: "newVal" := (mem.alloc (type.zero_val #sliceT)) in
    let: "extLen" := (mem.alloc (type.zero_val #uint64T)) in
    let: "proof" := (mem.alloc "proof") in
    let: "prevLink" := (mem.alloc "prevLink") in
    let: "proofLen" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (s_to_w64 (let: "$a0" := (![#sliceT] "proof") in
    slice.len "$a0")) in
    do:  ("proofLen" <-[#uint64T] "$r0");;;
    (if: ((![#uint64T] "proofLen") `rem` cryptoffi.HashLen) ≠ #(W64 0)
    then
      let: "$r0" := #true in
      do:  ("err" <-[#boolT] "$r0");;;
      return: (![#uint64T] "extLen", ![#sliceT] "newVal", ![#sliceT] "newLink", ![#boolT] "err")
    else do:  #());;;
    let: "$r0" := ((![#uint64T] "proofLen") `quot` cryptoffi.HashLen) in
    do:  ("extLen" <-[#uint64T] "$r0");;;
    let: "$r0" := (![#sliceT] "prevLink") in
    do:  ("newLink" <-[#sliceT] "$r0");;;
    (let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (for: (λ: <>, (![#uint64T] "i") < (![#uint64T] "extLen")); (λ: <>, do:  ("i" <-[#uint64T] ((![#uint64T] "i") + #(W64 1)))) := λ: <>,
      let: "start" := (mem.alloc (type.zero_val #uint64T)) in
      let: "$r0" := ((![#uint64T] "i") * cryptoffi.HashLen) in
      do:  ("start" <-[#uint64T] "$r0");;;
      let: "end" := (mem.alloc (type.zero_val #uint64T)) in
      let: "$r0" := (((![#uint64T] "i") + #(W64 1)) * cryptoffi.HashLen) in
      do:  ("end" <-[#uint64T] "$r0");;;
      let: "$r0" := (let: "$s" := (![#sliceT] "proof") in
      slice.slice #byteT "$s" (![#uint64T] "start") (![#uint64T] "end")) in
      do:  ("newVal" <-[#sliceT] "$r0");;;
      let: "$r0" := (let: "$a0" := (![#sliceT] "newLink") in
      let: "$a1" := (![#sliceT] "newVal") in
      (func_call #hashchain.hashchain #"GetNextLink"%go) "$a0" "$a1") in
      do:  ("newLink" <-[#sliceT] "$r0")));;;
    return: (![#uint64T] "extLen", ![#sliceT] "newVal", ![#sliceT] "newLink", ![#boolT] "err")).

(* go: hashchain.go:64:6 *)
Definition New : val :=
  rec: "New" <> :=
    exception_do (return: (mem.alloc (let: "$lastLink" := ((func_call #hashchain.hashchain #"GetEmptyLink"%go) #()) in
     struct.make #HashChain [{
       "predLastLink" ::= type.zero_val #sliceT;
       "lastLink" ::= "$lastLink";
       "vals" ::= type.zero_val #sliceT
     }]))).

(* go: hashchain.go:68:6 *)
Definition GetEmptyLink : val :=
  rec: "GetEmptyLink" <> :=
    exception_do (return: (let: "$a0" := #slice.nil in
     (func_call #cryptoutil.cryptoutil #"Hash"%go) "$a0")).

(* go: hashchain.go:72:6 *)
Definition GetNextLink : val :=
  rec: "GetNextLink" "prevLink" "nextVal" :=
    exception_do (let: "nextVal" := (mem.alloc "nextVal") in
    let: "prevLink" := (mem.alloc "prevLink") in
    let: "hr" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := ((func_call #cryptoffi.cryptoffi #"NewHasher"%go) #()) in
    do:  ("hr" <-[#ptrT] "$r0");;;
    do:  (let: "$a0" := (![#sliceT] "prevLink") in
    (method_call #cryptoffi #"Hasher'ptr" #"Write" (![#ptrT] "hr")) "$a0");;;
    do:  (let: "$a0" := (![#sliceT] "nextVal") in
    (method_call #cryptoffi #"Hasher'ptr" #"Write" (![#ptrT] "hr")) "$a0");;;
    return: (let: "$a0" := #slice.nil in
     (method_call #cryptoffi #"Hasher'ptr" #"Sum" (![#ptrT] "hr")) "$a0")).

Definition vars' : list (go_string * go_type) := [].

Definition functions' : list (go_string * val) := [("Verify"%go, Verify); ("New"%go, New); ("GetEmptyLink"%go, GetEmptyLink); ("GetNextLink"%go, GetNextLink)].

Definition msets' : list (go_string * (list (go_string * val))) := [("HashChain"%go, []); ("HashChain'ptr"%go, [("Append"%go, HashChain__Append); ("Bootstrap"%go, HashChain__Bootstrap); ("Prove"%go, HashChain__Prove)])].

#[global] Instance info' : PkgInfo hashchain.hashchain :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [bytes.bytes; std.std; cryptoffi.cryptoffi; cryptoutil.cryptoutil];
  |}.

Definition initialize' : val :=
  rec: "initialize'" <> :=
    globals.package_init hashchain.hashchain (λ: <>,
      exception_do (do:  cryptoutil.initialize';;;
      do:  cryptoffi.initialize';;;
      do:  std.initialize';;;
      do:  bytes.initialize')
      ).

End code.
End hashchain.
