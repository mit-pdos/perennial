(* autogenerated from github.com/sanjit-bhat/pav/hashchain *)
Require Export New.code.bytes.
Require Export New.code.github_com.goose_lang.std.
Require Export New.code.github_com.sanjit_bhat.pav.cryptoffi.
Require Export New.code.github_com.sanjit_bhat.pav.cryptoutil.

From New.golang Require Import defn.
Definition hashchain : go_string := "github.com/sanjit-bhat/pav/hashchain".

Module hashchain.

Module HashChain. Definition id : go_string := "github.com/sanjit-bhat/pav/hashchain.HashChain"%go. End HashChain.

Section code.
Context `{ffi_syntax}.


Definition HashChain : go_type := structT [
  "predLastLink" :: sliceT;
  "lastLink" :: sliceT;
  "vals" :: sliceT
].

Definition GetNextLink : go_string := "github.com/sanjit-bhat/pav/hashchain.GetNextLink"%go.

(* Append adds a val.
   it expects val to be of constant len, which lets us encode smaller proofs.

   go: hashchain.go:21:21 *)
Definition HashChain__Appendⁱᵐᵖˡ : val :=
  λ: "c" "val",
    exception_do (let: "newLink" := (mem.alloc (type.zero_val #sliceT)) in
    let: "c" := (mem.alloc "c") in
    let: "val" := (mem.alloc "val") in
    do:  (let: "$a0" := ((s_to_w64 (let: "$a0" := (![#sliceT] "val") in
    slice.len "$a0")) = cryptoffi.HashLen) in
    (func_call #std.Assert) "$a0");;;
    let: "$r0" := (![#sliceT] (struct.field_ref #HashChain #"lastLink"%go (![#ptrT] "c"))) in
    do:  ((struct.field_ref #HashChain #"predLastLink"%go (![#ptrT] "c")) <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] (struct.field_ref #HashChain #"lastLink"%go (![#ptrT] "c"))) in
    let: "$a1" := (![#sliceT] "val") in
    (func_call #GetNextLink) "$a0" "$a1") in
    do:  ((struct.field_ref #HashChain #"lastLink"%go (![#ptrT] "c")) <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] (struct.field_ref #HashChain #"vals"%go (![#ptrT] "c"))) in
    let: "$a1" := (![#sliceT] "val") in
    (slice.append #byteT) "$a0" "$a1") in
    do:  ((struct.field_ref #HashChain #"vals"%go (![#ptrT] "c")) <-[#sliceT] "$r0");;;
    return: (![#sliceT] (struct.field_ref #HashChain #"lastLink"%go (![#ptrT] "c")))).

(* Prove transitions from knowing a prevLen prefix to knowing the latest list.
   it expects prevLen <= curr len.

   go: hashchain.go:31:21 *)
Definition HashChain__Proveⁱᵐᵖˡ : val :=
  λ: "c" "prevLen",
    exception_do (let: "proof" := (mem.alloc (type.zero_val #sliceT)) in
    let: "c" := (mem.alloc "c") in
    let: "prevLen" := (mem.alloc "prevLen") in
    let: "start" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := ((![#uint64T] "prevLen") * cryptoffi.HashLen) in
    do:  ("start" <-[#uint64T] "$r0");;;
    return: (let: "$a0" := (let: "$s" := (![#sliceT] (struct.field_ref #HashChain #"vals"%go (![#ptrT] "c"))) in
     slice.slice #byteT "$s" (![#uint64T] "start") (slice.len "$s")) in
     (func_call #bytes.Clone) "$a0")).

(* Bootstrap hashchain verifiers with the last value.
   it expects non-empty values.

   go: hashchain.go:38:21 *)
Definition HashChain__Bootstrapⁱᵐᵖˡ : val :=
  λ: "c" <>,
    exception_do (let: "proof" := (mem.alloc (type.zero_val #sliceT)) in
    let: "bootLink" := (mem.alloc (type.zero_val #sliceT)) in
    let: "c" := (mem.alloc "c") in
    let: "start" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := ((s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref #HashChain #"vals"%go (![#ptrT] "c"))) in
    slice.len "$a0")) - cryptoffi.HashLen) in
    do:  ("start" <-[#uint64T] "$r0");;;
    return: (![#sliceT] (struct.field_ref #HashChain #"predLastLink"%go (![#ptrT] "c")), let: "$a0" := (let: "$s" := (![#sliceT] (struct.field_ref #HashChain #"vals"%go (![#ptrT] "c"))) in
     slice.slice #byteT "$s" (![#uint64T] "start") (slice.len "$s")) in
     (func_call #bytes.Clone) "$a0")).

Definition Verify : go_string := "github.com/sanjit-bhat/pav/hashchain.Verify"%go.

(* Verify updates prevLink with proof.
   if extended length is 0, new val is nil.
   it errors for a badly-encoded proof.

   go: hashchain.go:46:6 *)
Definition Verifyⁱᵐᵖˡ : val :=
  λ: "prevLink" "proof",
    exception_do (let: "err" := (mem.alloc (type.zero_val #boolT)) in
    let: "newLink" := (mem.alloc (type.zero_val #sliceT)) in
    let: "newVal" := (mem.alloc (type.zero_val #sliceT)) in
    let: "extLen" := (mem.alloc (type.zero_val #uint64T)) in
    let: "proof" := (mem.alloc "proof") in
    let: "prevLink" := (mem.alloc "prevLink") in
    let: "proofLen" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (s_to_w64 (let: "$a0" := (![#sliceT] "proof") in
    slice.len "$a0")) in
    do:  ("proofLen" <-[#uint64T] "$r0");;;
    (if: ((![#uint64T] "proofLen") `rem` cryptoffi.HashLen) ≠ #(W64 0)
    then
      let: "$r0" := #true in
      do:  ("err" <-[#boolT] "$r0");;;
      return: (![#uint64T] "extLen", ![#sliceT] "newVal", ![#sliceT] "newLink", ![#boolT] "err")
    else do:  #());;;
    let: "$r0" := ((![#uint64T] "proofLen") `quot` cryptoffi.HashLen) in
    do:  ("extLen" <-[#uint64T] "$r0");;;
    let: "$r0" := (![#sliceT] "prevLink") in
    do:  ("newLink" <-[#sliceT] "$r0");;;
    (let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (for: (λ: <>, (![#uint64T] "i") < (![#uint64T] "extLen")); (λ: <>, do:  ("i" <-[#uint64T] ((![#uint64T] "i") + #(W64 1)))) := λ: <>,
      let: "start" := (mem.alloc (type.zero_val #uint64T)) in
      let: "$r0" := ((![#uint64T] "i") * cryptoffi.HashLen) in
      do:  ("start" <-[#uint64T] "$r0");;;
      let: "end" := (mem.alloc (type.zero_val #uint64T)) in
      let: "$r0" := (((![#uint64T] "i") + #(W64 1)) * cryptoffi.HashLen) in
      do:  ("end" <-[#uint64T] "$r0");;;
      let: "$r0" := (let: "$s" := (![#sliceT] "proof") in
      slice.slice #byteT "$s" (![#uint64T] "start") (![#uint64T] "end")) in
      do:  ("newVal" <-[#sliceT] "$r0");;;
      let: "$r0" := (let: "$a0" := (![#sliceT] "newLink") in
      let: "$a1" := (![#sliceT] "newVal") in
      (func_call #GetNextLink) "$a0" "$a1") in
      do:  ("newLink" <-[#sliceT] "$r0")));;;
    return: (![#uint64T] "extLen", ![#sliceT] "newVal", ![#sliceT] "newLink", ![#boolT] "err")).

Definition New : go_string := "github.com/sanjit-bhat/pav/hashchain.New"%go.

Definition GetEmptyLink : go_string := "github.com/sanjit-bhat/pav/hashchain.GetEmptyLink"%go.

(* go: hashchain.go:64:6 *)
Definition Newⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (mem.alloc (let: "$lastLink" := ((func_call #GetEmptyLink) #()) in
     struct.make #HashChain [{
       "predLastLink" ::= type.zero_val #sliceT;
       "lastLink" ::= "$lastLink";
       "vals" ::= type.zero_val #sliceT
     }]))).

(* go: hashchain.go:68:6 *)
Definition GetEmptyLinkⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (let: "$a0" := #slice.nil in
     (func_call #cryptoutil.Hash) "$a0")).

(* go: hashchain.go:72:6 *)
Definition GetNextLinkⁱᵐᵖˡ : val :=
  λ: "prevLink" "nextVal",
    exception_do (let: "nextVal" := (mem.alloc "nextVal") in
    let: "prevLink" := (mem.alloc "prevLink") in
    let: "hr" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := ((func_call #cryptoffi.NewHasher) #()) in
    do:  ("hr" <-[#ptrT] "$r0");;;
    do:  (let: "$a0" := (![#sliceT] "prevLink") in
    (method_call #(ptrT.id cryptoffi.Hasher.id) #"Write"%go (![#ptrT] "hr")) "$a0");;;
    do:  (let: "$a0" := (![#sliceT] "nextVal") in
    (method_call #(ptrT.id cryptoffi.Hasher.id) #"Write"%go (![#ptrT] "hr")) "$a0");;;
    return: (let: "$a0" := #slice.nil in
     (method_call #(ptrT.id cryptoffi.Hasher.id) #"Sum"%go (![#ptrT] "hr")) "$a0")).

Definition vars' : list (go_string * go_type) := [].

Definition functions' : list (go_string * val) := [(Verify, Verifyⁱᵐᵖˡ); (New, Newⁱᵐᵖˡ); (GetEmptyLink, GetEmptyLinkⁱᵐᵖˡ); (GetNextLink, GetNextLinkⁱᵐᵖˡ)].

Definition msets' : list (go_string * (list (go_string * val))) := [(HashChain.id, []); (ptrT.id HashChain.id, [("Append"%go, HashChain__Appendⁱᵐᵖˡ); ("Bootstrap"%go, HashChain__Bootstrapⁱᵐᵖˡ); ("Prove"%go, HashChain__Proveⁱᵐᵖˡ)])].

#[global] Instance info' : PkgInfo hashchain.hashchain :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [bytes.bytes; github_com.goose_lang.std.std; github_com.sanjit_bhat.pav.cryptoffi.cryptoffi; github_com.sanjit_bhat.pav.cryptoutil.cryptoutil];
  |}.

Definition initialize' : val :=
  λ: <>,
    package.init #hashchain.hashchain (λ: <>,
      exception_do (do:  (cryptoutil.initialize' #());;;
      do:  (cryptoffi.initialize' #());;;
      do:  (std.initialize' #());;;
      do:  (bytes.initialize' #());;;
      do:  (package.alloc hashchain.hashchain #()))
      ).

End code.
End hashchain.
