(* autogenerated from github.com/sanjit-bhat/pav/hashchain *)
Require Export New.code.bytes.
Require Export New.code.github_com.goose_lang.std.
Require Export New.code.github_com.sanjit_bhat.pav.cryptoffi.
Require Export New.code.github_com.sanjit_bhat.pav.cryptoutil.
From New.golang Require Import defn.
Module pkg_id.
Definition hashchain : go_string := "github.com/sanjit-bhat/pav/hashchain".

End pkg_id.
Export pkg_id.
Module hashchain.

Definition HashChain {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/sanjit-bhat/pav/hashchain.HashChain"%go [].

Definition Verify {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/sanjit-bhat/pav/hashchain.Verify"%go.

Definition New {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/sanjit-bhat/pav/hashchain.New"%go.

Definition GetEmptyLink {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/sanjit-bhat/pav/hashchain.GetEmptyLink"%go.

Definition GetNextLink {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/sanjit-bhat/pav/hashchain.GetNextLink"%go.

(* Append adds a val.
   it expects val to be of constant len, which lets us encode smaller proofs.

   go: hashchain.go:21:21 *)
Definition HashChain__Appendⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "c" "val",
    exception_do (let: "newLink" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "c" := (GoAlloc (go.PointerType HashChain) "c") in
    let: "val" := (GoAlloc (go.SliceType go.byte) "val") in
    do:  (let: "$a0" := ((Convert go.int go.uint64 (let: "$a0" := (![go.SliceType go.byte] "val") in
    (FuncResolve go.len [go.SliceType go.byte] #()) "$a0")) =⟨go.uint64⟩ cryptoffi.HashLen) in
    (FuncResolve std.Assert [] #()) "$a0");;;
    let: "$r0" := (![go.SliceType go.byte] (StructFieldRef HashChain "lastLink"%go (![go.PointerType HashChain] "c"))) in
    do:  ((StructFieldRef HashChain "predLastLink"%go (![go.PointerType HashChain] "c")) <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] (StructFieldRef HashChain "lastLink"%go (![go.PointerType HashChain] "c"))) in
    let: "$a1" := (![go.SliceType go.byte] "val") in
    (FuncResolve GetNextLink [] #()) "$a0" "$a1") in
    do:  ((StructFieldRef HashChain "lastLink"%go (![go.PointerType HashChain] "c")) <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] (StructFieldRef HashChain "vals"%go (![go.PointerType HashChain] "c"))) in
    let: "$a1" := (![go.SliceType go.byte] "val") in
    (FuncResolve go.append [go.SliceType go.byte] #()) "$a0" "$a1") in
    do:  ((StructFieldRef HashChain "vals"%go (![go.PointerType HashChain] "c")) <-[go.SliceType go.byte] "$r0");;;
    return: (![go.SliceType go.byte] (StructFieldRef HashChain "lastLink"%go (![go.PointerType HashChain] "c")))).

(* Prove transitions from knowing a prevLen prefix to knowing the latest list.
   it expects prevLen <= curr len.

   go: hashchain.go:31:21 *)
Definition HashChain__Proveⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "c" "prevLen",
    exception_do (let: "proof" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "c" := (GoAlloc (go.PointerType HashChain) "c") in
    let: "prevLen" := (GoAlloc go.uint64 "prevLen") in
    let: "start" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := ((![go.uint64] "prevLen") *⟨go.uint64⟩ cryptoffi.HashLen) in
    do:  ("start" <-[go.uint64] "$r0");;;
    return: (let: "$a0" := (let: "$s" := (![go.SliceType go.byte] (StructFieldRef HashChain "vals"%go (![go.PointerType HashChain] "c"))) in
     Slice (go.SliceType go.byte) ("$s", ![go.uint64] "start", FuncResolve go.len [go.SliceType go.byte] #() (![go.SliceType go.byte] (StructFieldRef HashChain "vals"%go (![go.PointerType HashChain] "c"))))) in
     (FuncResolve bytes.Clone [] #()) "$a0")).

(* Bootstrap hashchain verifiers with the last value.
   it expects non-empty values.

   go: hashchain.go:38:21 *)
Definition HashChain__Bootstrapⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "c" <>,
    exception_do (let: "proof" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "bootLink" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "c" := (GoAlloc (go.PointerType HashChain) "c") in
    let: "start" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := ((Convert go.int go.uint64 (let: "$a0" := (![go.SliceType go.byte] (StructFieldRef HashChain "vals"%go (![go.PointerType HashChain] "c"))) in
    (FuncResolve go.len [go.SliceType go.byte] #()) "$a0")) -⟨go.uint64⟩ cryptoffi.HashLen) in
    do:  ("start" <-[go.uint64] "$r0");;;
    return: (![go.SliceType go.byte] (StructFieldRef HashChain "predLastLink"%go (![go.PointerType HashChain] "c")), let: "$a0" := (let: "$s" := (![go.SliceType go.byte] (StructFieldRef HashChain "vals"%go (![go.PointerType HashChain] "c"))) in
     Slice (go.SliceType go.byte) ("$s", ![go.uint64] "start", FuncResolve go.len [go.SliceType go.byte] #() (![go.SliceType go.byte] (StructFieldRef HashChain "vals"%go (![go.PointerType HashChain] "c"))))) in
     (FuncResolve bytes.Clone [] #()) "$a0")).

(* Verify updates prevLink with proof.
   if extended length is 0, new val is nil.
   it errors for a badly-encoded proof.

   go: hashchain.go:46:6 *)
Definition Verifyⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "prevLink" "proof",
    exception_do (let: "err" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "newLink" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "newVal" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "extLen" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "proof" := (GoAlloc (go.SliceType go.byte) "proof") in
    let: "prevLink" := (GoAlloc (go.SliceType go.byte) "prevLink") in
    let: "proofLen" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (Convert go.int go.uint64 (let: "$a0" := (![go.SliceType go.byte] "proof") in
    (FuncResolve go.len [go.SliceType go.byte] #()) "$a0")) in
    do:  ("proofLen" <-[go.uint64] "$r0");;;
    (if: Convert go.untyped_bool go.bool (((![go.uint64] "proofLen") %⟨go.uint64⟩ cryptoffi.HashLen) ≠⟨go.uint64⟩ #(W64 0))
    then
      let: "$r0" := #true in
      do:  ("err" <-[go.bool] "$r0");;;
      return: (![go.uint64] "extLen", ![go.SliceType go.byte] "newVal", ![go.SliceType go.byte] "newLink", ![go.bool] "err")
    else do:  #());;;
    let: "$r0" := ((![go.uint64] "proofLen") /⟨go.uint64⟩ cryptoffi.HashLen) in
    do:  ("extLen" <-[go.uint64] "$r0");;;
    let: "$r0" := (![go.SliceType go.byte] "prevLink") in
    do:  ("newLink" <-[go.SliceType go.byte] "$r0");;;
    (let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, (![go.uint64] "i") <⟨go.uint64⟩ (![go.uint64] "extLen")); (λ: <>, do:  ("i" <-[go.uint64] ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 1)))) := λ: <>,
      let: "$r0" := (let: "$s" := (![go.SliceType go.byte] "proof") in
      Slice (go.SliceType go.byte) ("$s", #(W64 0), cryptoffi.HashLen)) in
      do:  ("newVal" <-[go.SliceType go.byte] "$r0");;;
      let: "$r0" := (let: "$s" := (![go.SliceType go.byte] "proof") in
      Slice (go.SliceType go.byte) ("$s", cryptoffi.HashLen, FuncResolve go.len [go.SliceType go.byte] #() (![go.SliceType go.byte] "proof"))) in
      do:  ("proof" <-[go.SliceType go.byte] "$r0");;;
      let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "newLink") in
      let: "$a1" := (![go.SliceType go.byte] "newVal") in
      (FuncResolve GetNextLink [] #()) "$a0" "$a1") in
      do:  ("newLink" <-[go.SliceType go.byte] "$r0")));;;
    return: (![go.uint64] "extLen", ![go.SliceType go.byte] "newVal", ![go.SliceType go.byte] "newLink", ![go.bool] "err")).

(* go: hashchain.go:63:6 *)
Definition Newⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (GoAlloc HashChain (CompositeLiteral HashChain (LiteralValue [KeyedElement (Some (KeyField "lastLink"%go)) (ElementExpression (go.SliceType go.byte) ((FuncResolve GetEmptyLink [] #()) #()))])))).

(* go: hashchain.go:67:6 *)
Definition GetEmptyLinkⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (let: "$a0" := (Convert go.untyped_nil (go.SliceType go.byte) UntypedNil) in
     (FuncResolve cryptoutil.Hash [] #()) "$a0")).

(* go: hashchain.go:71:6 *)
Definition GetNextLinkⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "prevLink" "nextVal",
    exception_do (let: "nextVal" := (GoAlloc (go.SliceType go.byte) "nextVal") in
    let: "prevLink" := (GoAlloc (go.SliceType go.byte) "prevLink") in
    let: "hr" := (GoAlloc (go.PointerType cryptoffi.Hasher) (GoZeroVal (go.PointerType cryptoffi.Hasher) #())) in
    let: "$r0" := ((FuncResolve cryptoffi.NewHasher [] #()) #()) in
    do:  ("hr" <-[go.PointerType cryptoffi.Hasher] "$r0");;;
    do:  (let: "$a0" := (![go.SliceType go.byte] "prevLink") in
    (MethodResolve (go.PointerType cryptoffi.Hasher) "Write"%go (![go.PointerType cryptoffi.Hasher] "hr")) "$a0");;;
    do:  (let: "$a0" := (![go.SliceType go.byte] "nextVal") in
    (MethodResolve (go.PointerType cryptoffi.Hasher) "Write"%go (![go.PointerType cryptoffi.Hasher] "hr")) "$a0");;;
    return: (let: "$a0" := (Convert go.untyped_nil (go.SliceType go.byte) UntypedNil) in
     (MethodResolve (go.PointerType cryptoffi.Hasher) "Sum"%go (![go.PointerType cryptoffi.Hasher] "hr")) "$a0")).

#[global] Instance info' : PkgInfo pkg_id.hashchain :=
{|
  pkg_imported_pkgs := [code.bytes.pkg_id.bytes; code.github_com.goose_lang.std.pkg_id.std; code.github_com.sanjit_bhat.pav.cryptoffi.pkg_id.cryptoffi; code.github_com.sanjit_bhat.pav.cryptoutil.pkg_id.cryptoutil]
|}.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init pkg_id.hashchain (λ: <>,
      exception_do (do:  (cryptoutil.initialize' #());;;
      do:  (cryptoffi.initialize' #());;;
      do:  (std.initialize' #());;;
      do:  (bytes.initialize' #()))
      ).

Module HashChain.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  predLastLink' : slice.t;
  lastLink' : slice.t;
  vals' : slice.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End HashChain.

Definition HashChain'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "predLastLink"%go (go.SliceType go.byte));
  (go.FieldDecl "lastLink"%go (go.SliceType go.byte));
  (go.FieldDecl "vals"%go (go.SliceType go.byte))
].
Program Definition HashChain'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (HashChain'fds_unsealed).
Global Instance equals_unfold_HashChain {ext : ffi_syntax} {go_gctx : GoGlobalContext} : HashChain'fds =→ HashChain'fds_unsealed.
Proof. rewrite /HashChain'fds seal_eq //. Qed.

Definition HashChainⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (HashChain'fds).

Class HashChain_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] HashChain_type_repr  :: go.TypeReprUnderlying HashChainⁱᵐᵖˡ HashChain.t;
  #[global] HashChain_underlying :: (HashChain) <u (HashChainⁱᵐᵖˡ);
  #[global] HashChain_get_predLastLink (x : HashChain.t) :: ⟦StructFieldGet (HashChainⁱᵐᵖˡ) "predLastLink", #x⟧ ⤳[under] #x.(HashChain.predLastLink');
  #[global] HashChain_set_predLastLink (x : HashChain.t) y :: ⟦StructFieldSet (HashChainⁱᵐᵖˡ) "predLastLink", (#x, #y)⟧ ⤳[under] #(x <|HashChain.predLastLink' := y|>);
  #[global] HashChain_get_lastLink (x : HashChain.t) :: ⟦StructFieldGet (HashChainⁱᵐᵖˡ) "lastLink", #x⟧ ⤳[under] #x.(HashChain.lastLink');
  #[global] HashChain_set_lastLink (x : HashChain.t) y :: ⟦StructFieldSet (HashChainⁱᵐᵖˡ) "lastLink", (#x, #y)⟧ ⤳[under] #(x <|HashChain.lastLink' := y|>);
  #[global] HashChain_get_vals (x : HashChain.t) :: ⟦StructFieldGet (HashChainⁱᵐᵖˡ) "vals", #x⟧ ⤳[under] #x.(HashChain.vals');
  #[global] HashChain_set_vals (x : HashChain.t) y :: ⟦StructFieldSet (HashChainⁱᵐᵖˡ) "vals", (#x, #y)⟧ ⤳[under] #(x <|HashChain.vals' := y|>);
  #[global] HashChain'ptr_Append_unfold :: MethodUnfold (go.PointerType (HashChain)) "Append" (HashChain__Appendⁱᵐᵖˡ);
  #[global] HashChain'ptr_Bootstrap_unfold :: MethodUnfold (go.PointerType (HashChain)) "Bootstrap" (HashChain__Bootstrapⁱᵐᵖˡ);
  #[global] HashChain'ptr_Prove_unfold :: MethodUnfold (go.PointerType (HashChain)) "Prove" (HashChain__Proveⁱᵐᵖˡ);
}.

Class Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] HashChain_instance :: HashChain_Assumptions;
  #[global] Verify_unfold :: FuncUnfold Verify [] (Verifyⁱᵐᵖˡ);
  #[global] New_unfold :: FuncUnfold New [] (Newⁱᵐᵖˡ);
  #[global] GetEmptyLink_unfold :: FuncUnfold GetEmptyLink [] (GetEmptyLinkⁱᵐᵖˡ);
  #[global] GetNextLink_unfold :: FuncUnfold GetNextLink [] (GetNextLinkⁱᵐᵖˡ);
  #[global] import_bytes_Assumption :: bytes.Assumptions;
  #[global] import_std_Assumption :: std.Assumptions;
  #[global] import_cryptoffi_Assumption :: cryptoffi.Assumptions;
  #[global] import_cryptoutil_Assumption :: cryptoutil.Assumptions;
}.
End hashchain.
