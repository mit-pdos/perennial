(* autogenerated from github.com/sanjit-bhat/pav/merkle *)
Require Export New.code.bytes.
Require Export New.code.github_com.goose_lang.primitive.
Require Export New.code.github_com.goose_lang.std.
Require Export New.code.github_com.sanjit_bhat.pav.cryptoffi.
Require Export New.code.github_com.sanjit_bhat.pav.cryptoutil.
Require Export New.code.github_com.sanjit_bhat.pav.safemarshal.
Require Export New.code.github_com.tchajed.marshal.

From New.golang Require Import defn.
Definition merkle : go_string := "github.com/sanjit-bhat/pav/merkle".

Module merkle.

Section code.
Context `{ffi_syntax}.


Definition emptyNodeTag : val := #(W8 0).

Definition leafNodeTag : val := #(W8 1).

Definition innerNodeTag : val := #(W8 2).

Definition cutNodeTy : val := #(W8 0).

Definition leafNodeTy : val := #(W8 1).

Definition innerNodeTy : val := #(W8 2).

Definition maxDepth : val := #(W64 256).

Definition emptyHash : go_string := "github.com/sanjit-bhat/pav/merkle.emptyHash"%go.

Definition node : go.type := go.Named "github.com/sanjit-bhat/pav/merkle.node"%go [].

Definition Mapⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "root"%go (go.PointerType node))
].

Definition nodeⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "nodeTy"%go go.byte);
  (go.FieldDecl "hash"%go (go.SliceType go.byte));
  (go.FieldDecl "child0"%go (go.PointerType node));
  (go.FieldDecl "child1"%go (go.PointerType node));
  (go.FieldDecl "label"%go (go.SliceType go.byte));
  (go.FieldDecl "val"%go (go.SliceType go.byte))
].

Definition put : go_string := "github.com/sanjit-bhat/pav/merkle.put"%go.

Definition Map : go.type := go.Named "github.com/sanjit-bhat/pav/merkle.Map"%go [].

(* Put adds the leaf (label, val), storing immutable references to both.
   for liveness and safety reasons, it expects the label to have fixed length.

   go: merkle.go:60:15 *)
Definition Map__Putⁱᵐᵖˡ : val :=
  λ: "m" "label" "val",
    exception_do (let: "updProof" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "m" := (go.AllocValue (go.PointerType Map) "m") in
    let: "val" := (go.AllocValue (go.SliceType go.byte) "val") in
    let: "label" := (go.AllocValue (go.SliceType go.byte) "label") in
    do:  (let: "$a0" := ((s_to_w64 (let: "$a0" := (![go.SliceType go.byte] "label") in
    (FuncResolve go.len [go.SliceType go.byte] #()) "$a0")) =⟨go.uint64⟩ cryptoffi.HashLen) in
    (FuncResolve std.Assert [] #()) "$a0");;;
    let: "inMap" := (GoAlloc go.bool #()) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "label") in
    let: "$a1" := #true in
    (MethodResolve (go.PointerType node) prove #() (![go.PointerType node] (StructFieldRef Map "root"%go (![go.PointerType Map] "m")))) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("inMap" <-[go.bool] "$r0");;;
    do:  "$r1";;;
    do:  ("updProof" <-[go.SliceType go.byte] "$r2");;;
    do:  (let: "$a0" := (~ (![go.bool] "inMap")) in
    (FuncResolve std.Assert [] #()) "$a0");;;
    do:  (let: "$a0" := (~ (let: "$a0" := (StructFieldRef Map "root"%go (![go.PointerType Map] "m")) in
    let: "$a1" := #(W64 0) in
    let: "$a2" := (![go.SliceType go.byte] "label") in
    let: "$a3" := (![go.SliceType go.byte] "val") in
    (FuncResolve put [] #()) "$a0" "$a1" "$a2" "$a3")) in
    (FuncResolve std.Assert [] #()) "$a0");;;
    return: (![go.SliceType go.byte] "updProof")).

Definition compInnerHash : go_string := "github.com/sanjit-bhat/pav/merkle.compInnerHash"%go.

Definition compLeafHash : go_string := "github.com/sanjit-bhat/pav/merkle.compLeafHash"%go.

(* put inserts leaf node (label, val) into the n0 sub-tree.
   it errors iff there's an insert into a cut node, since that almost always
   leaves the tree in an unintended state.

   go: merkle.go:74:6 *)
Definition putⁱᵐᵖˡ : val :=
  λ: "n0" "depth" "label" "val",
    exception_do (let: "err" := (GoAlloc go.bool #()) in
    let: "val" := (go.AllocValue (go.SliceType go.byte) "val") in
    let: "label" := (go.AllocValue (go.SliceType go.byte) "label") in
    let: "depth" := (go.AllocValue go.uint64 "depth") in
    let: "n0" := (go.AllocValue (go.PointerType (go.PointerType node)) "n0") in
    do:  (let: "$a0" := ((![go.uint64] "depth") ≤⟨go.uint64⟩ maxDepth) in
    (FuncResolve std.Assert [] #()) "$a0");;;
    let: "n" := (GoAlloc (go.PointerType node) #()) in
    let: "$r0" := (![go.PointerType node] (![go.PointerType (go.PointerType node)] "n0")) in
    do:  ("n" <-[go.PointerType node] "$r0");;;
    (if: (![go.PointerType node] "n") =⟨go.PointerType node⟩ #null
    then
      let: "leaf" := (GoAlloc (go.PointerType node) #()) in
      let: "$r0" := (go.AllocValue node (let: "$nodeTy" := leafNodeTy in
      let: "$label" := (![go.SliceType go.byte] "label") in
      let: "$val" := (![go.SliceType go.byte] "val") in
      CompositeLiteral node (
        let: "$$vs" := go.StructElementListNil #() in 
        let: "$$vs" := go.ElementListApp "$$vs" "$nodeTy" in
        let: "$$vs" := go.ElementListApp "$$vs" (go.ZeroVal (go.SliceType go.byte) #()) in
        let: "$$vs" := go.ElementListApp "$$vs" (go.ZeroVal (go.PointerType node) #()) in
        let: "$$vs" := go.ElementListApp "$$vs" (go.ZeroVal (go.PointerType node) #()) in
        let: "$$vs" := go.ElementListApp "$$vs" "$label" in
        let: "$$vs" := go.ElementListApp "$$vs" "$val" in
        "$$vs"
      ))) in
      do:  ("leaf" <-[go.PointerType node] "$r0");;;
      let: "$r0" := (![go.PointerType node] "leaf") in
      do:  ((![go.PointerType (go.PointerType node)] "n0") <-[go.PointerType node] "$r0");;;
      let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "label") in
      let: "$a1" := (![go.SliceType go.byte] "val") in
      (FuncResolve compLeafHash [] #()) "$a0" "$a1") in
      do:  ((StructFieldRef node "hash"%go (![go.PointerType node] "leaf")) <-[go.SliceType go.byte] "$r0");;;
      return: (![go.bool] "err")
    else do:  #());;;
    (if: (![go.byte] (StructFieldRef node "nodeTy"%go (![go.PointerType node] "n"))) =⟨go.byte⟩ leafNodeTy
    then
      (if: let: "$a0" := (![go.SliceType go.byte] (StructFieldRef node "label"%go (![go.PointerType node] "n"))) in
      let: "$a1" := (![go.SliceType go.byte] "label") in
      (FuncResolve bytes.Equal [] #()) "$a0" "$a1"
      then
        let: "$r0" := (![go.SliceType go.byte] "val") in
        do:  ((StructFieldRef node "val"%go (![go.PointerType node] "n")) <-[go.SliceType go.byte] "$r0");;;
        let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "label") in
        let: "$a1" := (![go.SliceType go.byte] "val") in
        (FuncResolve compLeafHash [] #()) "$a0" "$a1") in
        do:  ((StructFieldRef node "hash"%go (![go.PointerType node] "n")) <-[go.SliceType go.byte] "$r0");;;
        return: (![go.bool] "err")
      else do:  #());;;
      let: "inner" := (GoAlloc (go.PointerType node) #()) in
      let: "$r0" := (go.AllocValue node (let: "$nodeTy" := innerNodeTy in
      CompositeLiteral node (
        let: "$$vs" := go.StructElementListNil #() in 
        let: "$$vs" := go.ElementListApp "$$vs" "$nodeTy" in
        let: "$$vs" := go.ElementListApp "$$vs" (go.ZeroVal (go.SliceType go.byte) #()) in
        let: "$$vs" := go.ElementListApp "$$vs" (go.ZeroVal (go.PointerType node) #()) in
        let: "$$vs" := go.ElementListApp "$$vs" (go.ZeroVal (go.PointerType node) #()) in
        let: "$$vs" := go.ElementListApp "$$vs" (go.ZeroVal (go.SliceType go.byte) #()) in
        let: "$$vs" := go.ElementListApp "$$vs" (go.ZeroVal (go.SliceType go.byte) #()) in
        "$$vs"
      ))) in
      do:  ("inner" <-[go.PointerType node] "$r0");;;
      let: "$r0" := (![go.PointerType node] "inner") in
      do:  ((![go.PointerType (go.PointerType node)] "n0") <-[go.PointerType node] "$r0");;;
      let: "oldChild" := (GoAlloc (go.PointerType (go.PointerType node)) #()) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] (StructFieldRef node "label"%go (![go.PointerType node] "n"))) in
      let: "$a1" := (![go.uint64] "depth") in
      (MethodResolve (go.PointerType node) getChild #() (![go.PointerType node] "inner")) "$a0" "$a1") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("oldChild" <-[go.PointerType (go.PointerType node)] "$r0");;;
      do:  "$r1";;;
      let: "$r0" := (![go.PointerType node] "n") in
      do:  ((![go.PointerType (go.PointerType node)] "oldChild") <-[go.PointerType node] "$r0");;;
      let: "newChild" := (GoAlloc (go.PointerType (go.PointerType node)) #()) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] "label") in
      let: "$a1" := (![go.uint64] "depth") in
      (MethodResolve (go.PointerType node) getChild #() (![go.PointerType node] "inner")) "$a0" "$a1") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("newChild" <-[go.PointerType (go.PointerType node)] "$r0");;;
      do:  "$r1";;;
      do:  (let: "$a0" := (~ (let: "$a0" := (![go.PointerType (go.PointerType node)] "newChild") in
      let: "$a1" := ((![go.uint64] "depth") +⟨go.uint64⟩ #(W64 1)) in
      let: "$a2" := (![go.SliceType go.byte] "label") in
      let: "$a3" := (![go.SliceType go.byte] "val") in
      (FuncResolve put [] #()) "$a0" "$a1" "$a2" "$a3")) in
      (FuncResolve std.Assert [] #()) "$a0");;;
      let: "$r0" := (let: "$a0" := ((MethodResolve (go.PointerType node) getHash #() (![go.PointerType node] (StructFieldRef node "child0"%go (![go.PointerType node] "inner")))) #()) in
      let: "$a1" := ((MethodResolve (go.PointerType node) getHash #() (![go.PointerType node] (StructFieldRef node "child1"%go (![go.PointerType node] "inner")))) #()) in
      (FuncResolve compInnerHash [] #()) "$a0" "$a1") in
      do:  ((StructFieldRef node "hash"%go (![go.PointerType node] "inner")) <-[go.SliceType go.byte] "$r0");;;
      return: (![go.bool] "err")
    else do:  #());;;
    (if: (![go.byte] (StructFieldRef node "nodeTy"%go (![go.PointerType node] "n"))) =⟨go.byte⟩ innerNodeTy
    then
      let: "c" := (GoAlloc (go.PointerType (go.PointerType node)) #()) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] "label") in
      let: "$a1" := (![go.uint64] "depth") in
      (MethodResolve (go.PointerType node) getChild #() (![go.PointerType node] "n")) "$a0" "$a1") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("c" <-[go.PointerType (go.PointerType node)] "$r0");;;
      do:  "$r1";;;
      (let: "$r0" := (let: "$a0" := (![go.PointerType (go.PointerType node)] "c") in
      let: "$a1" := ((![go.uint64] "depth") +⟨go.uint64⟩ #(W64 1)) in
      let: "$a2" := (![go.SliceType go.byte] "label") in
      let: "$a3" := (![go.SliceType go.byte] "val") in
      (FuncResolve put [] #()) "$a0" "$a1" "$a2" "$a3") in
      do:  ("err" <-[go.bool] "$r0");;;
      (if: ![go.bool] "err"
      then return: (![go.bool] "err")
      else do:  #()));;;
      let: "$r0" := (let: "$a0" := ((MethodResolve (go.PointerType node) getHash #() (![go.PointerType node] (StructFieldRef node "child0"%go (![go.PointerType node] "n")))) #()) in
      let: "$a1" := ((MethodResolve (go.PointerType node) getHash #() (![go.PointerType node] (StructFieldRef node "child1"%go (![go.PointerType node] "n")))) #()) in
      (FuncResolve compInnerHash [] #()) "$a0" "$a1") in
      do:  ((StructFieldRef node "hash"%go (![go.PointerType node] "n")) <-[go.SliceType go.byte] "$r0");;;
      return: (![go.bool] "err")
    else do:  #());;;
    do:  (let: "$a0" := ((![go.byte] (StructFieldRef node "nodeTy"%go (![go.PointerType node] "n"))) =⟨go.byte⟩ cutNodeTy) in
    (FuncResolve std.Assert [] #()) "$a0");;;
    return: (#true)).

(* Prove the membership of label.

   go: merkle.go:121:15 *)
Definition Map__Proveⁱᵐᵖˡ : val :=
  λ: "m" "label",
    exception_do (let: "entryProof" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "val" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "inMap" := (GoAlloc go.bool #()) in
    let: "m" := (go.AllocValue (go.PointerType Map) "m") in
    let: "label" := (go.AllocValue (go.SliceType go.byte) "label") in
    do:  (let: "$a0" := ((s_to_w64 (let: "$a0" := (![go.SliceType go.byte] "label") in
    (FuncResolve go.len [go.SliceType go.byte] #()) "$a0")) =⟨go.uint64⟩ cryptoffi.HashLen) in
    (FuncResolve std.Assert [] #()) "$a0");;;
    let: (("$ret0", "$ret1"), "$ret2") := ((let: "$a0" := (![go.SliceType go.byte] "label") in
    let: "$a1" := #true in
    (MethodResolve (go.PointerType node) prove #() (![go.PointerType node] (StructFieldRef Map "root"%go (![go.PointerType Map] "m")))) "$a0" "$a1")) in
    return: ("$ret0", "$ret1", "$ret2")).

(* prove expects no cut nodes along label.

   go: merkle.go:129:16 *)
Definition node__proveⁱᵐᵖˡ : val :=
  λ: "n" "label" "getProof",
    exception_do (let: "proof" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "val" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "inTree" := (GoAlloc go.bool #()) in
    let: "n" := (go.AllocValue (go.PointerType node) "n") in
    let: "getProof" := (go.AllocValue go.bool "getProof") in
    let: "label" := (go.AllocValue (go.SliceType go.byte) "label") in
    let: "foundLabel" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "found" := (GoAlloc go.bool #()) in
    let: ((("$ret0", "$ret1"), "$ret2"), "$ret3") := (let: "$a0" := #(W64 0) in
    let: "$a1" := (![go.SliceType go.byte] "label") in
    let: "$a2" := (![go.bool] "getProof") in
    (MethodResolve (go.PointerType node) find #() (![go.PointerType node] "n")) "$a0" "$a1" "$a2") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    let: "$r3" := "$ret3" in
    do:  ("found" <-[go.bool] "$r0");;;
    do:  ("foundLabel" <-[go.SliceType go.byte] "$r1");;;
    do:  ("val" <-[go.SliceType go.byte] "$r2");;;
    do:  ("proof" <-[go.SliceType go.byte] "$r3");;;
    (if: ![go.bool] "getProof"
    then
      do:  (let: "$a0" := (![go.SliceType go.byte] "proof") in
      let: "$a1" := ((s_to_w64 (let: "$a0" := (![go.SliceType go.byte] "proof") in
      (FuncResolve go.len [go.SliceType go.byte] #()) "$a0")) -⟨go.uint64⟩ #(W64 8)) in
      (FuncResolve primitive.UInt64Put [] #()) "$a0" "$a1")
    else do:  #());;;
    (if: (~ (![go.bool] "found"))
    then
      (if: ![go.bool] "getProof"
      then
        let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "proof") in
        let: "$a1" := #false in
        (FuncResolve marshal.WriteBool [] #()) "$a0" "$a1") in
        do:  ("proof" <-[go.SliceType go.byte] "$r0");;;
        let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "proof") in
        let: "$a1" := #(W64 0) in
        (FuncResolve marshal.WriteInt [] #()) "$a0" "$a1") in
        do:  ("proof" <-[go.SliceType go.byte] "$r0");;;
        let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "proof") in
        let: "$a1" := #(W64 0) in
        (FuncResolve marshal.WriteInt [] #()) "$a0" "$a1") in
        do:  ("proof" <-[go.SliceType go.byte] "$r0")
      else do:  #());;;
      return: (![go.bool] "inTree", ![go.SliceType go.byte] "val", ![go.SliceType go.byte] "proof")
    else do:  #());;;
    (if: (~ (let: "$a0" := (![go.SliceType go.byte] "foundLabel") in
    let: "$a1" := (![go.SliceType go.byte] "label") in
    (FuncResolve bytes.Equal [] #()) "$a0" "$a1"))
    then
      (if: ![go.bool] "getProof"
      then
        let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "proof") in
        let: "$a1" := #true in
        (FuncResolve marshal.WriteBool [] #()) "$a0" "$a1") in
        do:  ("proof" <-[go.SliceType go.byte] "$r0");;;
        let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "proof") in
        let: "$a1" := (s_to_w64 (let: "$a0" := (![go.SliceType go.byte] "foundLabel") in
        (FuncResolve go.len [go.SliceType go.byte] #()) "$a0")) in
        (FuncResolve marshal.WriteInt [] #()) "$a0" "$a1") in
        do:  ("proof" <-[go.SliceType go.byte] "$r0");;;
        let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "proof") in
        let: "$a1" := (![go.SliceType go.byte] "foundLabel") in
        (FuncResolve marshal.WriteBytes [] #()) "$a0" "$a1") in
        do:  ("proof" <-[go.SliceType go.byte] "$r0");;;
        let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "proof") in
        let: "$a1" := (s_to_w64 (let: "$a0" := (![go.SliceType go.byte] "val") in
        (FuncResolve go.len [go.SliceType go.byte] #()) "$a0")) in
        (FuncResolve marshal.WriteInt [] #()) "$a0" "$a1") in
        do:  ("proof" <-[go.SliceType go.byte] "$r0");;;
        let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "proof") in
        let: "$a1" := (![go.SliceType go.byte] "val") in
        (FuncResolve marshal.WriteBytes [] #()) "$a0" "$a1") in
        do:  ("proof" <-[go.SliceType go.byte] "$r0")
      else do:  #());;;
      return: (![go.bool] "inTree", ![go.SliceType go.byte] "val", ![go.SliceType go.byte] "proof")
    else do:  #());;;
    (if: ![go.bool] "getProof"
    then
      let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "proof") in
      let: "$a1" := #false in
      (FuncResolve marshal.WriteBool [] #()) "$a0" "$a1") in
      do:  ("proof" <-[go.SliceType go.byte] "$r0");;;
      let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "proof") in
      let: "$a1" := #(W64 0) in
      (FuncResolve marshal.WriteInt [] #()) "$a0" "$a1") in
      do:  ("proof" <-[go.SliceType go.byte] "$r0");;;
      let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "proof") in
      let: "$a1" := #(W64 0) in
      (FuncResolve marshal.WriteInt [] #()) "$a0" "$a1") in
      do:  ("proof" <-[go.SliceType go.byte] "$r0")
    else do:  #());;;
    let: "$r0" := #true in
    do:  ("inTree" <-[go.bool] "$r0");;;
    return: (![go.bool] "inTree", ![go.SliceType go.byte] "val", ![go.SliceType go.byte] "proof")).

Definition getProofCap : go_string := "github.com/sanjit-bhat/pav/merkle.getProofCap"%go.

(* find searches the tree for a leaf node down path label.
   it expects no cut nodes along label.

   go: merkle.go:164:16 *)
Definition node__findⁱᵐᵖˡ : val :=
  λ: "n" "depth" "label" "getProof",
    exception_do (let: "sibs" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "foundVal" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "foundLabel" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "found" := (GoAlloc go.bool #()) in
    let: "n" := (go.AllocValue (go.PointerType node) "n") in
    let: "getProof" := (go.AllocValue go.bool "getProof") in
    let: "label" := (go.AllocValue (go.SliceType go.byte) "label") in
    let: "depth" := (go.AllocValue go.uint64 "depth") in
    (if: (![go.PointerType node] "n") =⟨go.PointerType node⟩ #null
    then
      (if: ![go.bool] "getProof"
      then
        let: "$r0" := ((FuncResolve go.make3 [go.SliceType go.byte] #()) #(W64 8) (let: "$a0" := (![go.uint64] "depth") in
        (FuncResolve getProofCap [] #()) "$a0")) in
        do:  ("sibs" <-[go.SliceType go.byte] "$r0")
      else do:  #());;;
      return: (![go.bool] "found", ![go.SliceType go.byte] "foundLabel", ![go.SliceType go.byte] "foundVal", ![go.SliceType go.byte] "sibs")
    else do:  #());;;
    (if: (![go.byte] (StructFieldRef node "nodeTy"%go (![go.PointerType node] "n"))) =⟨go.byte⟩ leafNodeTy
    then
      let: "$r0" := #true in
      do:  ("found" <-[go.bool] "$r0");;;
      let: "$r0" := (![go.SliceType go.byte] (StructFieldRef node "label"%go (![go.PointerType node] "n"))) in
      do:  ("foundLabel" <-[go.SliceType go.byte] "$r0");;;
      let: "$r0" := (![go.SliceType go.byte] (StructFieldRef node "val"%go (![go.PointerType node] "n"))) in
      do:  ("foundVal" <-[go.SliceType go.byte] "$r0");;;
      (if: ![go.bool] "getProof"
      then
        let: "$r0" := ((FuncResolve go.make3 [go.SliceType go.byte] #()) #(W64 8) (let: "$a0" := (![go.uint64] "depth") in
        (FuncResolve getProofCap [] #()) "$a0")) in
        do:  ("sibs" <-[go.SliceType go.byte] "$r0")
      else do:  #());;;
      return: (![go.bool] "found", ![go.SliceType go.byte] "foundLabel", ![go.SliceType go.byte] "foundVal", ![go.SliceType go.byte] "sibs")
    else do:  #());;;
    (if: (![go.byte] (StructFieldRef node "nodeTy"%go (![go.PointerType node] "n"))) =⟨go.byte⟩ innerNodeTy
    then
      let: "sib" := (GoAlloc (go.PointerType (go.PointerType node)) #()) in
      let: "child" := (GoAlloc (go.PointerType (go.PointerType node)) #()) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] "label") in
      let: "$a1" := (![go.uint64] "depth") in
      (MethodResolve (go.PointerType node) getChild #() (![go.PointerType node] "n")) "$a0" "$a1") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("child" <-[go.PointerType (go.PointerType node)] "$r0");;;
      do:  ("sib" <-[go.PointerType (go.PointerType node)] "$r1");;;
      let: ((("$ret0", "$ret1"), "$ret2"), "$ret3") := (let: "$a0" := ((![go.uint64] "depth") +⟨go.uint64⟩ #(W64 1)) in
      let: "$a1" := (![go.SliceType go.byte] "label") in
      let: "$a2" := (![go.bool] "getProof") in
      (MethodResolve (go.PointerType node) find #() (![go.PointerType node] (![go.PointerType (go.PointerType node)] "child"))) "$a0" "$a1" "$a2") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      let: "$r2" := "$ret2" in
      let: "$r3" := "$ret3" in
      do:  ("found" <-[go.bool] "$r0");;;
      do:  ("foundLabel" <-[go.SliceType go.byte] "$r1");;;
      do:  ("foundVal" <-[go.SliceType go.byte] "$r2");;;
      do:  ("sibs" <-[go.SliceType go.byte] "$r3");;;
      (if: ![go.bool] "getProof"
      then
        let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "sibs") in
        let: "$a1" := ((MethodResolve (go.PointerType node) getHash #() (![go.PointerType node] (![go.PointerType (go.PointerType node)] "sib"))) #()) in
        (FuncResolve go.append [go.SliceType go.byte] #()) "$a0" "$a1") in
        do:  ("sibs" <-[go.SliceType go.byte] "$r0")
      else do:  #());;;
      return: (![go.bool] "found", ![go.SliceType go.byte] "foundLabel", ![go.SliceType go.byte] "foundVal", ![go.SliceType go.byte] "sibs")
    else do:  #());;;
    do:  (let: "$a0" := (InterfaceMake go.string #"merkle: find into cut node"%go) in
    (FuncResolve go.panic [] #()) "$a0")).

(* go: merkle.go:199:6 *)
Definition getProofCapⁱᵐᵖˡ : val :=
  λ: "depth",
    exception_do (let: "depth" := (go.AllocValue go.uint64 "depth") in
    return: ((((((#(W64 8) +⟨go.uint64⟩ ((![go.uint64] "depth") *⟨go.uint64⟩ cryptoffi.HashLen)) +⟨go.uint64⟩ #(W64 1)) +⟨go.uint64⟩ #(W64 8)) +⟨go.uint64⟩ cryptoffi.HashLen) +⟨go.uint64⟩ #(W64 8)) +⟨go.uint64⟩ #(W64 32))).

Definition VerifyMemb : go_string := "github.com/sanjit-bhat/pav/merkle.VerifyMemb"%go.

Definition proofToTree : go_string := "github.com/sanjit-bhat/pav/merkle.proofToTree"%go.

(* VerifyMemb checks that (label, val) in tree described by proof.
   to save on bandwidth, some callers get hash from Verify.
   callers that expect some hash should check that they got the right one.

   go: merkle.go:209:6 *)
Definition VerifyMembⁱᵐᵖˡ : val :=
  λ: "label" "val" "entryProof",
    exception_do (let: "err" := (GoAlloc go.bool #()) in
    let: "hash" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "entryProof" := (go.AllocValue (go.SliceType go.byte) "entryProof") in
    let: "val" := (go.AllocValue (go.SliceType go.byte) "val") in
    let: "label" := (go.AllocValue (go.SliceType go.byte) "label") in
    let: "tr" := (GoAlloc (go.PointerType node) #()) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] "label") in
    let: "$a1" := (![go.SliceType go.byte] "entryProof") in
    (FuncResolve proofToTree [] #()) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("tr" <-[go.PointerType node] "$r0");;;
    do:  ("err" <-[go.bool] "$r1");;;
    (if: ![go.bool] "err"
    then return: (![go.SliceType go.byte] "hash", ![go.bool] "err")
    else do:  #());;;
    do:  (let: "$a0" := (~ (let: "$a0" := "tr" in
    let: "$a1" := #(W64 0) in
    let: "$a2" := (![go.SliceType go.byte] "label") in
    let: "$a3" := (![go.SliceType go.byte] "val") in
    (FuncResolve put [] #()) "$a0" "$a1" "$a2" "$a3")) in
    (FuncResolve std.Assert [] #()) "$a0");;;
    let: "$r0" := ((MethodResolve (go.PointerType node) getHash #() (![go.PointerType node] "tr")) #()) in
    do:  ("hash" <-[go.SliceType go.byte] "$r0");;;
    return: (![go.SliceType go.byte] "hash", ![go.bool] "err")).

Definition VerifyNonMemb : go_string := "github.com/sanjit-bhat/pav/merkle.VerifyNonMemb"%go.

(* VerifyNonMemb checks that label not in tree described by proof.

   go: merkle.go:220:6 *)
Definition VerifyNonMembⁱᵐᵖˡ : val :=
  λ: "label" "entryProof",
    exception_do (let: "err" := (GoAlloc go.bool #()) in
    let: "hash" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "entryProof" := (go.AllocValue (go.SliceType go.byte) "entryProof") in
    let: "label" := (go.AllocValue (go.SliceType go.byte) "label") in
    let: "tr" := (GoAlloc (go.PointerType node) #()) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] "label") in
    let: "$a1" := (![go.SliceType go.byte] "entryProof") in
    (FuncResolve proofToTree [] #()) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("tr" <-[go.PointerType node] "$r0");;;
    do:  ("err" <-[go.bool] "$r1");;;
    (if: ![go.bool] "err"
    then return: (![go.SliceType go.byte] "hash", ![go.bool] "err")
    else do:  #());;;
    let: "$r0" := ((MethodResolve (go.PointerType node) getHash #() (![go.PointerType node] "tr")) #()) in
    do:  ("hash" <-[go.SliceType go.byte] "$r0");;;
    return: (![go.SliceType go.byte] "hash", ![go.bool] "err")).

Definition VerifyUpdate : go_string := "github.com/sanjit-bhat/pav/merkle.VerifyUpdate"%go.

(* VerifyUpdate returns the hash for an old tree without label and
   the hash after inserting (label, val).

   go: merkle.go:231:6 *)
Definition VerifyUpdateⁱᵐᵖˡ : val :=
  λ: "label" "val" "updProof",
    exception_do (let: "err" := (GoAlloc go.bool #()) in
    let: "hashNew" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "hashOld" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "updProof" := (go.AllocValue (go.SliceType go.byte) "updProof") in
    let: "val" := (go.AllocValue (go.SliceType go.byte) "val") in
    let: "label" := (go.AllocValue (go.SliceType go.byte) "label") in
    let: "tr" := (GoAlloc (go.PointerType node) #()) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] "label") in
    let: "$a1" := (![go.SliceType go.byte] "updProof") in
    (FuncResolve proofToTree [] #()) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("tr" <-[go.PointerType node] "$r0");;;
    do:  ("err" <-[go.bool] "$r1");;;
    (if: ![go.bool] "err"
    then return: (![go.SliceType go.byte] "hashOld", ![go.SliceType go.byte] "hashNew", ![go.bool] "err")
    else do:  #());;;
    let: "$r0" := ((MethodResolve (go.PointerType node) getHash #() (![go.PointerType node] "tr")) #()) in
    do:  ("hashOld" <-[go.SliceType go.byte] "$r0");;;
    do:  (let: "$a0" := (~ (let: "$a0" := "tr" in
    let: "$a1" := #(W64 0) in
    let: "$a2" := (![go.SliceType go.byte] "label") in
    let: "$a3" := (![go.SliceType go.byte] "val") in
    (FuncResolve put [] #()) "$a0" "$a1" "$a2" "$a3")) in
    (FuncResolve std.Assert [] #()) "$a0");;;
    let: "$r0" := ((MethodResolve (go.PointerType node) getHash #() (![go.PointerType node] "tr")) #()) in
    do:  ("hashNew" <-[go.SliceType go.byte] "$r0");;;
    return: (![go.SliceType go.byte] "hashOld", ![go.SliceType go.byte] "hashNew", ![go.bool] "err")).

(* go: merkle.go:242:15 *)
Definition Map__Hashⁱᵐᵖˡ : val :=
  λ: "m" <>,
    exception_do (let: "m" := (go.AllocValue (go.PointerType Map) "m") in
    return: ((MethodResolve (go.PointerType node) getHash #() (![go.PointerType node] (StructFieldRef Map "root"%go (![go.PointerType Map] "m")))) #())).

Definition Proof : go.type := go.Named "github.com/sanjit-bhat/pav/merkle.Proof"%go [].

Definition newShell : go_string := "github.com/sanjit-bhat/pav/merkle.newShell"%go.

Definition ProofDecode : go_string := "github.com/sanjit-bhat/pav/merkle.ProofDecode"%go.

(* proofToTree guarantees that label not in tree and that label has fixed len.

   go: merkle.go:247:6 *)
Definition proofToTreeⁱᵐᵖˡ : val :=
  λ: "label" "proof",
    exception_do (let: "err" := (GoAlloc go.bool #()) in
    let: "tr" := (GoAlloc (go.PointerType node) #()) in
    let: "proof" := (go.AllocValue (go.SliceType go.byte) "proof") in
    let: "label" := (go.AllocValue (go.SliceType go.byte) "label") in
    (if: (s_to_w64 (let: "$a0" := (![go.SliceType go.byte] "label") in
    (FuncResolve go.len [go.SliceType go.byte] #()) "$a0")) ≠⟨go.uint64⟩ cryptoffi.HashLen
    then
      let: "$r0" := #true in
      do:  ("err" <-[go.bool] "$r0");;;
      return: (![go.PointerType node] "tr", ![go.bool] "err")
    else do:  #());;;
    let: "p" := (GoAlloc (go.PointerType Proof) #()) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "proof") in
    (FuncResolve ProofDecode [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("p" <-[go.PointerType Proof] "$r0");;;
    do:  "$r1";;;
    do:  ("err" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err"
    then return: (![go.PointerType node] "tr", ![go.bool] "err")
    else do:  #());;;
    (if: ((s_to_w64 (let: "$a0" := (![go.SliceType go.byte] (StructFieldRef Proof "Siblings"%go (![go.PointerType Proof] "p"))) in
    (FuncResolve go.len [go.SliceType go.byte] #()) "$a0")) `rem`⟨go.uint64⟩ cryptoffi.HashLen) ≠⟨go.uint64⟩ #(W64 0)
    then
      let: "$r0" := #true in
      do:  ("err" <-[go.bool] "$r0");;;
      return: (![go.PointerType node] "tr", ![go.bool] "err")
    else do:  #());;;
    let: "sibsDepth" := (GoAlloc go.uint64 #()) in
    let: "$r0" := ((s_to_w64 (let: "$a0" := (![go.SliceType go.byte] (StructFieldRef Proof "Siblings"%go (![go.PointerType Proof] "p"))) in
    (FuncResolve go.len [go.SliceType go.byte] #()) "$a0")) `quot`⟨go.uint64⟩ cryptoffi.HashLen) in
    do:  ("sibsDepth" <-[go.uint64] "$r0");;;
    (if: (![go.uint64] "sibsDepth") >⟨go.uint64⟩ maxDepth
    then
      let: "$r0" := #true in
      do:  ("err" <-[go.bool] "$r0");;;
      return: (![go.PointerType node] "tr", ![go.bool] "err")
    else do:  #());;;
    let: "$r0" := (let: "$a0" := #(W64 0) in
    let: "$a1" := (![go.SliceType go.byte] "label") in
    let: "$a2" := (![go.SliceType go.byte] (StructFieldRef Proof "Siblings"%go (![go.PointerType Proof] "p"))) in
    (FuncResolve newShell [] #()) "$a0" "$a1" "$a2") in
    do:  ("tr" <-[go.PointerType node] "$r0");;;
    (if: ![go.bool] (StructFieldRef Proof "IsOtherLeaf"%go (![go.PointerType Proof] "p"))
    then
      (if: (s_to_w64 (let: "$a0" := (![go.SliceType go.byte] (StructFieldRef Proof "LeafLabel"%go (![go.PointerType Proof] "p"))) in
      (FuncResolve go.len [go.SliceType go.byte] #()) "$a0")) ≠⟨go.uint64⟩ cryptoffi.HashLen
      then
        let: "$r0" := #true in
        do:  ("err" <-[go.bool] "$r0");;;
        return: (![go.PointerType node] "tr", ![go.bool] "err")
      else do:  #());;;
      (if: let: "$a0" := (![go.SliceType go.byte] "label") in
      let: "$a1" := (![go.SliceType go.byte] (StructFieldRef Proof "LeafLabel"%go (![go.PointerType Proof] "p"))) in
      (FuncResolve bytes.Equal [] #()) "$a0" "$a1"
      then
        let: "$r0" := #true in
        do:  ("err" <-[go.bool] "$r0");;;
        return: (![go.PointerType node] "tr", ![go.bool] "err")
      else do:  #());;;
      (let: "$r0" := (let: "$a0" := "tr" in
      let: "$a1" := #(W64 0) in
      let: "$a2" := (![go.SliceType go.byte] (StructFieldRef Proof "LeafLabel"%go (![go.PointerType Proof] "p"))) in
      let: "$a3" := (![go.SliceType go.byte] (StructFieldRef Proof "LeafVal"%go (![go.PointerType Proof] "p"))) in
      (FuncResolve put [] #()) "$a0" "$a1" "$a2" "$a3") in
      do:  ("err" <-[go.bool] "$r0");;;
      (if: ![go.bool] "err"
      then return: (![go.PointerType node] "tr", ![go.bool] "err")
      else do:  #()))
    else do:  #());;;
    return: (![go.PointerType node] "tr", ![go.bool] "err")).

(* go: merkle.go:282:6 *)
Definition newShellⁱᵐᵖˡ : val :=
  λ: "depth" "label" "sibs",
    exception_do (let: "n" := (GoAlloc (go.PointerType node) #()) in
    let: "sibs" := (go.AllocValue (go.SliceType go.byte) "sibs") in
    let: "label" := (go.AllocValue (go.SliceType go.byte) "label") in
    let: "depth" := (go.AllocValue go.uint64 "depth") in
    let: "sibsLen" := (GoAlloc go.uint64 #()) in
    let: "$r0" := (s_to_w64 (let: "$a0" := (![go.SliceType go.byte] "sibs") in
    (FuncResolve go.len [go.SliceType go.byte] #()) "$a0")) in
    do:  ("sibsLen" <-[go.uint64] "$r0");;;
    (if: (![go.uint64] "sibsLen") =⟨go.uint64⟩ #(W64 0)
    then return: (![go.PointerType node] "n")
    else do:  #());;;
    let: "split" := (GoAlloc go.uint64 #()) in
    let: "$r0" := ((![go.uint64] "sibsLen") -⟨go.uint64⟩ cryptoffi.HashLen) in
    do:  ("split" <-[go.uint64] "$r0");;;
    let: "sibs0" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := (let: "$s" := (![go.SliceType go.byte] "sibs") in
    slice.slice go.byte "$s" #(W64 0) (![go.uint64] "split")) in
    do:  ("sibs0" <-[go.SliceType go.byte] "$r0");;;
    let: "hash" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := (let: "$s" := (![go.SliceType go.byte] "sibs") in
    slice.slice go.byte "$s" (![go.uint64] "split") (slice.len "$s")) in
    do:  ("hash" <-[go.SliceType go.byte] "$r0");;;
    let: "cut" := (GoAlloc (go.PointerType node) #()) in
    let: "$r0" := (go.AllocValue node (let: "$nodeTy" := cutNodeTy in
    let: "$hash" := (![go.SliceType go.byte] "hash") in
    CompositeLiteral node (
      let: "$$vs" := go.StructElementListNil #() in 
      let: "$$vs" := go.ElementListApp "$$vs" "$nodeTy" in
      let: "$$vs" := go.ElementListApp "$$vs" "$hash" in
      let: "$$vs" := go.ElementListApp "$$vs" (go.ZeroVal (go.PointerType node) #()) in
      let: "$$vs" := go.ElementListApp "$$vs" (go.ZeroVal (go.PointerType node) #()) in
      let: "$$vs" := go.ElementListApp "$$vs" (go.ZeroVal (go.SliceType go.byte) #()) in
      let: "$$vs" := go.ElementListApp "$$vs" (go.ZeroVal (go.SliceType go.byte) #()) in
      "$$vs"
    ))) in
    do:  ("cut" <-[go.PointerType node] "$r0");;;
    let: "inner" := (GoAlloc (go.PointerType node) #()) in
    let: "$r0" := (go.AllocValue node (let: "$nodeTy" := innerNodeTy in
    CompositeLiteral node (
      let: "$$vs" := go.StructElementListNil #() in 
      let: "$$vs" := go.ElementListApp "$$vs" "$nodeTy" in
      let: "$$vs" := go.ElementListApp "$$vs" (go.ZeroVal (go.SliceType go.byte) #()) in
      let: "$$vs" := go.ElementListApp "$$vs" (go.ZeroVal (go.PointerType node) #()) in
      let: "$$vs" := go.ElementListApp "$$vs" (go.ZeroVal (go.PointerType node) #()) in
      let: "$$vs" := go.ElementListApp "$$vs" (go.ZeroVal (go.SliceType go.byte) #()) in
      let: "$$vs" := go.ElementListApp "$$vs" (go.ZeroVal (go.SliceType go.byte) #()) in
      "$$vs"
    ))) in
    do:  ("inner" <-[go.PointerType node] "$r0");;;
    let: "sib" := (GoAlloc (go.PointerType (go.PointerType node)) #()) in
    let: "child" := (GoAlloc (go.PointerType (go.PointerType node)) #()) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] "label") in
    let: "$a1" := (![go.uint64] "depth") in
    (MethodResolve (go.PointerType node) getChild #() (![go.PointerType node] "inner")) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("child" <-[go.PointerType (go.PointerType node)] "$r0");;;
    do:  ("sib" <-[go.PointerType (go.PointerType node)] "$r1");;;
    let: "$r0" := (![go.PointerType node] "cut") in
    do:  ((![go.PointerType (go.PointerType node)] "sib") <-[go.PointerType node] "$r0");;;
    let: "$r0" := (let: "$a0" := ((![go.uint64] "depth") +⟨go.uint64⟩ #(W64 1)) in
    let: "$a1" := (![go.SliceType go.byte] "label") in
    let: "$a2" := (![go.SliceType go.byte] "sibs0") in
    (FuncResolve newShell [] #()) "$a0" "$a1" "$a2") in
    do:  ((![go.PointerType (go.PointerType node)] "child") <-[go.PointerType node] "$r0");;;
    let: "$r0" := (let: "$a0" := ((MethodResolve (go.PointerType node) getHash #() (![go.PointerType node] (StructFieldRef node "child0"%go (![go.PointerType node] "inner")))) #()) in
    let: "$a1" := ((MethodResolve (go.PointerType node) getHash #() (![go.PointerType node] (StructFieldRef node "child1"%go (![go.PointerType node] "inner")))) #()) in
    (FuncResolve compInnerHash [] #()) "$a0" "$a1") in
    do:  ((StructFieldRef node "hash"%go (![go.PointerType node] "inner")) <-[go.SliceType go.byte] "$r0");;;
    return: (![go.PointerType node] "inner")).

(* go: merkle.go:299:16 *)
Definition node__getHashⁱᵐᵖˡ : val :=
  λ: "n" <>,
    exception_do (let: "n" := (go.AllocValue (go.PointerType node) "n") in
    (if: (![go.PointerType node] "n") =⟨go.PointerType node⟩ #null
    then return: (![go.SliceType go.byte] (GlobalVarAddr emptyHash #()))
    else do:  #());;;
    return: (![go.SliceType go.byte] (StructFieldRef node "hash"%go (![go.PointerType node] "n")))).

Definition compEmptyHash : go_string := "github.com/sanjit-bhat/pav/merkle.compEmptyHash"%go.

(* go: merkle.go:306:6 *)
Definition compEmptyHashⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (let: "$a0" := ((let: "$sl0" := emptyNodeTag in
     CompositeLiteral go.byte go.byte ["$sl0"])) in
     (FuncResolve cryptoutil.Hash [] #()) "$a0")).

(* go: merkle.go:310:6 *)
Definition compLeafHashⁱᵐᵖˡ : val :=
  λ: "label" "val",
    exception_do (let: "val" := (go.AllocValue (go.SliceType go.byte) "val") in
    let: "label" := (go.AllocValue (go.SliceType go.byte) "label") in
    let: "hr" := (GoAlloc (go.PointerType cryptoffi.Hasher) #()) in
    let: "$r0" := ((FuncResolve cryptoffi.NewHasher [] #()) #()) in
    do:  ("hr" <-[go.PointerType cryptoffi.Hasher] "$r0");;;
    do:  (let: "$a0" := ((let: "$sl0" := leafNodeTag in
    CompositeLiteral go.byte go.byte ["$sl0"])) in
    (MethodResolve (go.PointerType cryptoffi.Hasher) Write #() (![go.PointerType cryptoffi.Hasher] "hr")) "$a0");;;
    do:  (let: "$a0" := (let: "$a0" := #slice.nil in
    let: "$a1" := (s_to_w64 (let: "$a0" := (![go.SliceType go.byte] "label") in
    (FuncResolve go.len [go.SliceType go.byte] #()) "$a0")) in
    (FuncResolve marshal.WriteInt [] #()) "$a0" "$a1") in
    (MethodResolve (go.PointerType cryptoffi.Hasher) Write #() (![go.PointerType cryptoffi.Hasher] "hr")) "$a0");;;
    do:  (let: "$a0" := (![go.SliceType go.byte] "label") in
    (MethodResolve (go.PointerType cryptoffi.Hasher) Write #() (![go.PointerType cryptoffi.Hasher] "hr")) "$a0");;;
    do:  (let: "$a0" := (let: "$a0" := #slice.nil in
    let: "$a1" := (s_to_w64 (let: "$a0" := (![go.SliceType go.byte] "val") in
    (FuncResolve go.len [go.SliceType go.byte] #()) "$a0")) in
    (FuncResolve marshal.WriteInt [] #()) "$a0" "$a1") in
    (MethodResolve (go.PointerType cryptoffi.Hasher) Write #() (![go.PointerType cryptoffi.Hasher] "hr")) "$a0");;;
    do:  (let: "$a0" := (![go.SliceType go.byte] "val") in
    (MethodResolve (go.PointerType cryptoffi.Hasher) Write #() (![go.PointerType cryptoffi.Hasher] "hr")) "$a0");;;
    return: (let: "$a0" := #slice.nil in
     (MethodResolve (go.PointerType cryptoffi.Hasher) Sum #() (![go.PointerType cryptoffi.Hasher] "hr")) "$a0")).

(* go: merkle.go:320:6 *)
Definition compInnerHashⁱᵐᵖˡ : val :=
  λ: "child0" "child1",
    exception_do (let: "child1" := (go.AllocValue (go.SliceType go.byte) "child1") in
    let: "child0" := (go.AllocValue (go.SliceType go.byte) "child0") in
    let: "hr" := (GoAlloc (go.PointerType cryptoffi.Hasher) #()) in
    let: "$r0" := ((FuncResolve cryptoffi.NewHasher [] #()) #()) in
    do:  ("hr" <-[go.PointerType cryptoffi.Hasher] "$r0");;;
    do:  (let: "$a0" := ((let: "$sl0" := innerNodeTag in
    CompositeLiteral go.byte go.byte ["$sl0"])) in
    (MethodResolve (go.PointerType cryptoffi.Hasher) Write #() (![go.PointerType cryptoffi.Hasher] "hr")) "$a0");;;
    do:  (let: "$a0" := (![go.SliceType go.byte] "child0") in
    (MethodResolve (go.PointerType cryptoffi.Hasher) Write #() (![go.PointerType cryptoffi.Hasher] "hr")) "$a0");;;
    do:  (let: "$a0" := (![go.SliceType go.byte] "child1") in
    (MethodResolve (go.PointerType cryptoffi.Hasher) Write #() (![go.PointerType cryptoffi.Hasher] "hr")) "$a0");;;
    return: (let: "$a0" := #slice.nil in
     (MethodResolve (go.PointerType cryptoffi.Hasher) Sum #() (![go.PointerType cryptoffi.Hasher] "hr")) "$a0")).

Definition getBit : go_string := "github.com/sanjit-bhat/pav/merkle.getBit"%go.

(* getChild returns a child and its sibling child,
   relative to the bit referenced by label and depth.

   go: merkle.go:330:16 *)
Definition node__getChildⁱᵐᵖˡ : val :=
  λ: "n" "label" "depth",
    exception_do (let: "n" := (go.AllocValue (go.PointerType node) "n") in
    let: "depth" := (go.AllocValue go.uint64 "depth") in
    let: "label" := (go.AllocValue (go.SliceType go.byte) "label") in
    (if: let: "$a0" := (![go.SliceType go.byte] "label") in
    let: "$a1" := (![go.uint64] "depth") in
    (FuncResolve getBit [] #()) "$a0" "$a1"
    then return: (StructFieldRef node "child1"%go (![go.PointerType node] "n"), StructFieldRef node "child0"%go (![go.PointerType node] "n"))
    else return: (StructFieldRef node "child0"%go (![go.PointerType node] "n"), StructFieldRef node "child1"%go (![go.PointerType node] "n")))).

(* getBit returns false if the nth bit of b is 0.
   if n exceeds b, it returns true.

   go: merkle.go:340:6 *)
Definition getBitⁱᵐᵖˡ : val :=
  λ: "b" "n",
    exception_do (let: "n" := (go.AllocValue go.uint64 "n") in
    let: "b" := (go.AllocValue (go.SliceType go.byte) "b") in
    let: "slot" := (GoAlloc go.uint64 #()) in
    let: "$r0" := ((![go.uint64] "n") `quot`⟨go.uint64⟩ #(W64 8)) in
    do:  ("slot" <-[go.uint64] "$r0");;;
    (if: (![go.uint64] "slot") <⟨go.uint64⟩ (s_to_w64 (let: "$a0" := (![go.SliceType go.byte] "b") in
    (FuncResolve go.len [go.SliceType go.byte] #()) "$a0"))
    then
      let: "off" := (GoAlloc go.uint64 #()) in
      let: "$r0" := ((![go.uint64] "n") `rem`⟨go.uint64⟩ #(W64 8)) in
      do:  ("off" <-[go.uint64] "$r0");;;
      let: "x" := (GoAlloc go.byte #()) in
      let: "$r0" := (![go.byte] (slice.elem_ref go.byte (![go.SliceType go.byte] "b") (![go.uint64] "slot"))) in
      do:  ("x" <-[go.byte] "$r0");;;
      return: (((![go.byte] "x") `and` (#(W8 1) ≪⟨go.byte⟩ (u_to_w8 (![go.uint64] "off")))) ≠⟨go.byte⟩ #(W8 0))
    else return: (#true))).

Definition Proofⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "Siblings"%go (go.SliceType go.byte));
  (go.FieldDecl "IsOtherLeaf"%go go.bool);
  (go.FieldDecl "LeafLabel"%go (go.SliceType go.byte));
  (go.FieldDecl "LeafVal"%go (go.SliceType go.byte))
].

Definition ProofEncode : go_string := "github.com/sanjit-bhat/pav/merkle.ProofEncode"%go.

(* go: serde.out.go:10:6 *)
Definition ProofEncodeⁱᵐᵖˡ : val :=
  λ: "b0" "o",
    exception_do (let: "o" := (go.AllocValue (go.PointerType Proof) "o") in
    let: "b0" := (go.AllocValue (go.SliceType go.byte) "b0") in
    let: "b" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := (![go.SliceType go.byte] "b0") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (![go.SliceType go.byte] (StructFieldRef Proof "Siblings"%go (![go.PointerType Proof] "o"))) in
    (FuncResolve safemarshal.WriteSlice1D [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (![go.bool] (StructFieldRef Proof "IsOtherLeaf"%go (![go.PointerType Proof] "o"))) in
    (FuncResolve marshal.WriteBool [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (![go.SliceType go.byte] (StructFieldRef Proof "LeafLabel"%go (![go.PointerType Proof] "o"))) in
    (FuncResolve safemarshal.WriteSlice1D [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (![go.SliceType go.byte] (StructFieldRef Proof "LeafVal"%go (![go.PointerType Proof] "o"))) in
    (FuncResolve safemarshal.WriteSlice1D [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    return: (![go.SliceType go.byte] "b")).

(* go: serde.out.go:18:6 *)
Definition ProofDecodeⁱᵐᵖˡ : val :=
  λ: "b0",
    exception_do (let: "b0" := (go.AllocValue (go.SliceType go.byte) "b0") in
    let: "err1" := (GoAlloc go.bool #()) in
    let: "b1" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "a1" := (GoAlloc (go.SliceType go.byte) #()) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "b0") in
    (FuncResolve safemarshal.ReadSlice1D [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a1" <-[go.SliceType go.byte] "$r0");;;
    do:  ("b1" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err1" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err1"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err2" := (GoAlloc go.bool #()) in
    let: "b2" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "a2" := (GoAlloc go.bool #()) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "b1") in
    (FuncResolve safemarshal.ReadBool [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a2" <-[go.bool] "$r0");;;
    do:  ("b2" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err2" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err2"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err3" := (GoAlloc go.bool #()) in
    let: "b3" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "a3" := (GoAlloc (go.SliceType go.byte) #()) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "b2") in
    (FuncResolve safemarshal.ReadSlice1D [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a3" <-[go.SliceType go.byte] "$r0");;;
    do:  ("b3" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err3" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err3"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err4" := (GoAlloc go.bool #()) in
    let: "b4" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "a4" := (GoAlloc (go.SliceType go.byte) #()) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "b3") in
    (FuncResolve safemarshal.ReadSlice1D [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a4" <-[go.SliceType go.byte] "$r0");;;
    do:  ("b4" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err4" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err4"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    return: (go.AllocValue Proof (let: "$Siblings" := (![go.SliceType go.byte] "a1") in
     let: "$IsOtherLeaf" := (![go.bool] "a2") in
     let: "$LeafLabel" := (![go.SliceType go.byte] "a3") in
     let: "$LeafVal" := (![go.SliceType go.byte] "a4") in
     CompositeLiteral Proof (
       let: "$$vs" := go.StructElementListNil #() in 
       let: "$$vs" := go.ElementListApp "$$vs" "$Siblings" in
       let: "$$vs" := go.ElementListApp "$$vs" "$IsOtherLeaf" in
       let: "$$vs" := go.ElementListApp "$$vs" "$LeafLabel" in
       let: "$$vs" := go.ElementListApp "$$vs" "$LeafVal" in
       "$$vs"
     )), ![go.SliceType go.byte] "b4", #false)).

Definition functions' : list (go_string * val) := [(put, putⁱᵐᵖˡ); (getProofCap, getProofCapⁱᵐᵖˡ); (VerifyMemb, VerifyMembⁱᵐᵖˡ); (VerifyNonMemb, VerifyNonMembⁱᵐᵖˡ); (VerifyUpdate, VerifyUpdateⁱᵐᵖˡ); (proofToTree, proofToTreeⁱᵐᵖˡ); (newShell, newShellⁱᵐᵖˡ); (compEmptyHash, compEmptyHashⁱᵐᵖˡ); (compLeafHash, compLeafHashⁱᵐᵖˡ); (compInnerHash, compInnerHashⁱᵐᵖˡ); (getBit, getBitⁱᵐᵖˡ); (ProofEncode, ProofEncodeⁱᵐᵖˡ); (ProofDecode, ProofDecodeⁱᵐᵖˡ)].

#[global] Instance info' : PkgInfo merkle.merkle :=
  {|
    pkg_imported_pkgs := [code.bytes.bytes; code.github_com.goose_lang.primitive.primitive; code.github_com.goose_lang.std.std; code.github_com.sanjit_bhat.pav.cryptoffi.cryptoffi; code.github_com.sanjit_bhat.pav.cryptoutil.cryptoutil; code.github_com.tchajed.marshal.marshal; code.github_com.sanjit_bhat.pav.safemarshal.safemarshal];
  |}.

Definition initialize' : val :=
  λ: <>,
    package.init merkle.merkle (λ: <>,
      exception_do (do:  (GoGlobalAlloc emptyHash (go.SliceType go.byte));;;
      do:  (safemarshal.initialize' #());;;
      do:  (marshal.initialize' #());;;
      do:  (cryptoutil.initialize' #());;;
      do:  (cryptoffi.initialize' #());;;
      do:  (std.initialize' #());;;
      do:  (primitive.initialize' #());;;
      do:  (bytes.initialize' #());;;
      let: "$r0" := ((FuncResolve compEmptyHash [] #()) #()) in
      do:  ((GloblalVarAddr #emptyHash) <-[go.SliceType go.byte] "$r0"))
      ).

End code.
End merkle.
