(* autogenerated from github.com/sanjit-bhat/pav/merkle *)
Require Export New.code.bytes.
Require Export New.code.github_com.goose_lang.primitive.
Require Export New.code.github_com.goose_lang.std.
Require Export New.code.github_com.sanjit_bhat.pav.cryptoffi.
Require Export New.code.github_com.sanjit_bhat.pav.cryptoutil.
Require Export New.code.github_com.sanjit_bhat.pav.safemarshal.
Require Export New.code.github_com.tchajed.marshal.

From New.golang Require Import defn.
Definition merkle : go_string := "github.com/sanjit-bhat/pav/merkle".

Module merkle.

Module Map. Definition id : go_string := "github.com/sanjit-bhat/pav/merkle.Map"%go. End Map.
Module node. Definition id : go_string := "github.com/sanjit-bhat/pav/merkle.node"%go. End node.
Module Proof. Definition id : go_string := "github.com/sanjit-bhat/pav/merkle.Proof"%go. End Proof.

Section code.
Context `{ffi_syntax}.


Definition emptyNodeTag : val := #(W8 0).

Definition leafNodeTag : val := #(W8 1).

Definition innerNodeTag : val := #(W8 2).

Definition cutNodeTy : val := #(W8 0).

Definition leafNodeTy : val := #(W8 1).

Definition innerNodeTy : val := #(W8 2).

Definition maxDepth : val := #(W64 256).

Definition emptyHash : go_string := "github.com/sanjit-bhat/pav/merkle.emptyHash"%go.

Definition Map : go_type := structT [
  "root" :: ptrT
].
#[global] Typeclasses Opaque Map.
#[global] Opaque Map.

Definition node : go_type := structT [
  "nodeTy" :: byteT;
  "hash" :: sliceT;
  "child0" :: ptrT;
  "child1" :: ptrT;
  "label" :: sliceT;
  "val" :: sliceT
].
#[global] Typeclasses Opaque node.
#[global] Opaque node.

Definition put : go_string := "github.com/sanjit-bhat/pav/merkle.put"%go.

(* Put adds the leaf (label, val), storing immutable references to both.
   for liveness and safety reasons, it expects the label to have fixed length.

   go: merkle.go:60:15 *)
Definition Map__Putⁱᵐᵖˡ : val :=
  λ: "m" "label" "val",
    exception_do (let: "updProof" := (mem.alloc (type.zero_val #sliceT)) in
    let: "m" := (mem.alloc "m") in
    let: "val" := (mem.alloc "val") in
    let: "label" := (mem.alloc "label") in
    do:  (let: "$a0" := ((s_to_w64 (let: "$a0" := (![#sliceT] "label") in
    slice.len "$a0")) = cryptoffi.HashLen) in
    (func_call #std.Assert) "$a0");;;
    let: "inMap" := (mem.alloc (type.zero_val #boolT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "label") in
    let: "$a1" := #true in
    (method_call #(ptrT.id node.id) #"prove"%go (![#ptrT] (struct.field_ref #Map #"root"%go (![#ptrT] "m")))) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("inMap" <-[#boolT] "$r0");;;
    do:  "$r1";;;
    do:  ("updProof" <-[#sliceT] "$r2");;;
    do:  (let: "$a0" := (~ (![#boolT] "inMap")) in
    (func_call #std.Assert) "$a0");;;
    do:  (let: "$a0" := (~ (let: "$a0" := (struct.field_ref #Map #"root"%go (![#ptrT] "m")) in
    let: "$a1" := #(W64 0) in
    let: "$a2" := (![#sliceT] "label") in
    let: "$a3" := (![#sliceT] "val") in
    (func_call #put) "$a0" "$a1" "$a2" "$a3")) in
    (func_call #std.Assert) "$a0");;;
    return: (![#sliceT] "updProof")).

Definition compInnerHash : go_string := "github.com/sanjit-bhat/pav/merkle.compInnerHash"%go.

Definition compLeafHash : go_string := "github.com/sanjit-bhat/pav/merkle.compLeafHash"%go.

(* put inserts leaf node (label, val) into the n0 sub-tree.
   it errors iff there's an insert into a cut node, since that almost always
   leaves the tree in an unintended state.

   go: merkle.go:74:6 *)
Definition putⁱᵐᵖˡ : val :=
  λ: "n0" "depth" "label" "val",
    exception_do (let: "err" := (mem.alloc (type.zero_val #boolT)) in
    let: "val" := (mem.alloc "val") in
    let: "label" := (mem.alloc "label") in
    let: "depth" := (mem.alloc "depth") in
    let: "n0" := (mem.alloc "n0") in
    do:  (let: "$a0" := ((![#uint64T] "depth") ≤ maxDepth) in
    (func_call #std.Assert) "$a0");;;
    let: "n" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (![#ptrT] (![#ptrT] "n0")) in
    do:  ("n" <-[#ptrT] "$r0");;;
    (if: (![#ptrT] "n") = #null
    then
      let: "leaf" := (mem.alloc (type.zero_val #ptrT)) in
      let: "$r0" := (mem.alloc (let: "$nodeTy" := leafNodeTy in
      let: "$label" := (![#sliceT] "label") in
      let: "$val" := (![#sliceT] "val") in
      struct.make #node [{
        "nodeTy" ::= "$nodeTy";
        "hash" ::= type.zero_val #sliceT;
        "child0" ::= type.zero_val #ptrT;
        "child1" ::= type.zero_val #ptrT;
        "label" ::= "$label";
        "val" ::= "$val"
      }])) in
      do:  ("leaf" <-[#ptrT] "$r0");;;
      let: "$r0" := (![#ptrT] "leaf") in
      do:  ((![#ptrT] "n0") <-[#ptrT] "$r0");;;
      let: "$r0" := (let: "$a0" := (![#sliceT] "label") in
      let: "$a1" := (![#sliceT] "val") in
      (func_call #compLeafHash) "$a0" "$a1") in
      do:  ((struct.field_ref #node #"hash"%go (![#ptrT] "leaf")) <-[#sliceT] "$r0");;;
      return: (![#boolT] "err")
    else do:  #());;;
    (if: (![#byteT] (struct.field_ref #node #"nodeTy"%go (![#ptrT] "n"))) = leafNodeTy
    then
      (if: let: "$a0" := (![#sliceT] (struct.field_ref #node #"label"%go (![#ptrT] "n"))) in
      let: "$a1" := (![#sliceT] "label") in
      (func_call #bytes.Equal) "$a0" "$a1"
      then
        let: "$r0" := (![#sliceT] "val") in
        do:  ((struct.field_ref #node #"val"%go (![#ptrT] "n")) <-[#sliceT] "$r0");;;
        let: "$r0" := (let: "$a0" := (![#sliceT] "label") in
        let: "$a1" := (![#sliceT] "val") in
        (func_call #compLeafHash) "$a0" "$a1") in
        do:  ((struct.field_ref #node #"hash"%go (![#ptrT] "n")) <-[#sliceT] "$r0");;;
        return: (![#boolT] "err")
      else do:  #());;;
      let: "inner" := (mem.alloc (type.zero_val #ptrT)) in
      let: "$r0" := (mem.alloc (let: "$nodeTy" := innerNodeTy in
      struct.make #node [{
        "nodeTy" ::= "$nodeTy";
        "hash" ::= type.zero_val #sliceT;
        "child0" ::= type.zero_val #ptrT;
        "child1" ::= type.zero_val #ptrT;
        "label" ::= type.zero_val #sliceT;
        "val" ::= type.zero_val #sliceT
      }])) in
      do:  ("inner" <-[#ptrT] "$r0");;;
      let: "$r0" := (![#ptrT] "inner") in
      do:  ((![#ptrT] "n0") <-[#ptrT] "$r0");;;
      let: "oldChild" := (mem.alloc (type.zero_val #ptrT)) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] (struct.field_ref #node #"label"%go (![#ptrT] "n"))) in
      let: "$a1" := (![#uint64T] "depth") in
      (method_call #(ptrT.id node.id) #"getChild"%go (![#ptrT] "inner")) "$a0" "$a1") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("oldChild" <-[#ptrT] "$r0");;;
      do:  "$r1";;;
      let: "$r0" := (![#ptrT] "n") in
      do:  ((![#ptrT] "oldChild") <-[#ptrT] "$r0");;;
      let: "newChild" := (mem.alloc (type.zero_val #ptrT)) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "label") in
      let: "$a1" := (![#uint64T] "depth") in
      (method_call #(ptrT.id node.id) #"getChild"%go (![#ptrT] "inner")) "$a0" "$a1") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("newChild" <-[#ptrT] "$r0");;;
      do:  "$r1";;;
      do:  (let: "$a0" := (~ (let: "$a0" := (![#ptrT] "newChild") in
      let: "$a1" := ((![#uint64T] "depth") + #(W64 1)) in
      let: "$a2" := (![#sliceT] "label") in
      let: "$a3" := (![#sliceT] "val") in
      (func_call #put) "$a0" "$a1" "$a2" "$a3")) in
      (func_call #std.Assert) "$a0");;;
      let: "$r0" := (let: "$a0" := ((method_call #(ptrT.id node.id) #"getHash"%go (![#ptrT] (struct.field_ref #node #"child0"%go (![#ptrT] "inner")))) #()) in
      let: "$a1" := ((method_call #(ptrT.id node.id) #"getHash"%go (![#ptrT] (struct.field_ref #node #"child1"%go (![#ptrT] "inner")))) #()) in
      (func_call #compInnerHash) "$a0" "$a1") in
      do:  ((struct.field_ref #node #"hash"%go (![#ptrT] "inner")) <-[#sliceT] "$r0");;;
      return: (![#boolT] "err")
    else do:  #());;;
    (if: (![#byteT] (struct.field_ref #node #"nodeTy"%go (![#ptrT] "n"))) = innerNodeTy
    then
      let: "c" := (mem.alloc (type.zero_val #ptrT)) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "label") in
      let: "$a1" := (![#uint64T] "depth") in
      (method_call #(ptrT.id node.id) #"getChild"%go (![#ptrT] "n")) "$a0" "$a1") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("c" <-[#ptrT] "$r0");;;
      do:  "$r1";;;
      (let: "$r0" := (let: "$a0" := (![#ptrT] "c") in
      let: "$a1" := ((![#uint64T] "depth") + #(W64 1)) in
      let: "$a2" := (![#sliceT] "label") in
      let: "$a3" := (![#sliceT] "val") in
      (func_call #put) "$a0" "$a1" "$a2" "$a3") in
      do:  ("err" <-[#boolT] "$r0");;;
      (if: ![#boolT] "err"
      then return: (![#boolT] "err")
      else do:  #()));;;
      let: "$r0" := (let: "$a0" := ((method_call #(ptrT.id node.id) #"getHash"%go (![#ptrT] (struct.field_ref #node #"child0"%go (![#ptrT] "n")))) #()) in
      let: "$a1" := ((method_call #(ptrT.id node.id) #"getHash"%go (![#ptrT] (struct.field_ref #node #"child1"%go (![#ptrT] "n")))) #()) in
      (func_call #compInnerHash) "$a0" "$a1") in
      do:  ((struct.field_ref #node #"hash"%go (![#ptrT] "n")) <-[#sliceT] "$r0");;;
      return: (![#boolT] "err")
    else do:  #());;;
    do:  (let: "$a0" := ((![#byteT] (struct.field_ref #node #"nodeTy"%go (![#ptrT] "n"))) = cutNodeTy) in
    (func_call #std.Assert) "$a0");;;
    return: (#true)).

(* Prove the membership of label.

   go: merkle.go:121:15 *)
Definition Map__Proveⁱᵐᵖˡ : val :=
  λ: "m" "label",
    exception_do (let: "entryProof" := (mem.alloc (type.zero_val #sliceT)) in
    let: "val" := (mem.alloc (type.zero_val #sliceT)) in
    let: "inMap" := (mem.alloc (type.zero_val #boolT)) in
    let: "m" := (mem.alloc "m") in
    let: "label" := (mem.alloc "label") in
    do:  (let: "$a0" := ((s_to_w64 (let: "$a0" := (![#sliceT] "label") in
    slice.len "$a0")) = cryptoffi.HashLen) in
    (func_call #std.Assert) "$a0");;;
    let: (("$ret0", "$ret1"), "$ret2") := ((let: "$a0" := (![#sliceT] "label") in
    let: "$a1" := #true in
    (method_call #(ptrT.id node.id) #"prove"%go (![#ptrT] (struct.field_ref #Map #"root"%go (![#ptrT] "m")))) "$a0" "$a1")) in
    return: ("$ret0", "$ret1", "$ret2")).

(* prove expects no cut nodes along label.

   go: merkle.go:129:16 *)
Definition node__proveⁱᵐᵖˡ : val :=
  λ: "n" "label" "getProof",
    exception_do (let: "proof" := (mem.alloc (type.zero_val #sliceT)) in
    let: "val" := (mem.alloc (type.zero_val #sliceT)) in
    let: "inTree" := (mem.alloc (type.zero_val #boolT)) in
    let: "n" := (mem.alloc "n") in
    let: "getProof" := (mem.alloc "getProof") in
    let: "label" := (mem.alloc "label") in
    let: "foundLabel" := (mem.alloc (type.zero_val #sliceT)) in
    let: "found" := (mem.alloc (type.zero_val #boolT)) in
    let: ((("$ret0", "$ret1"), "$ret2"), "$ret3") := (let: "$a0" := #(W64 0) in
    let: "$a1" := (![#sliceT] "label") in
    let: "$a2" := (![#boolT] "getProof") in
    (method_call #(ptrT.id node.id) #"find"%go (![#ptrT] "n")) "$a0" "$a1" "$a2") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    let: "$r3" := "$ret3" in
    do:  ("found" <-[#boolT] "$r0");;;
    do:  ("foundLabel" <-[#sliceT] "$r1");;;
    do:  ("val" <-[#sliceT] "$r2");;;
    do:  ("proof" <-[#sliceT] "$r3");;;
    (if: ![#boolT] "getProof"
    then
      do:  (let: "$a0" := (![#sliceT] "proof") in
      let: "$a1" := ((s_to_w64 (let: "$a0" := (![#sliceT] "proof") in
      slice.len "$a0")) - #(W64 8)) in
      (func_call #primitive.UInt64Put) "$a0" "$a1")
    else do:  #());;;
    (if: (~ (![#boolT] "found"))
    then
      (if: ![#boolT] "getProof"
      then
        let: "$r0" := (let: "$a0" := (![#sliceT] "proof") in
        let: "$a1" := #false in
        (func_call #marshal.WriteBool) "$a0" "$a1") in
        do:  ("proof" <-[#sliceT] "$r0");;;
        let: "$r0" := (let: "$a0" := (![#sliceT] "proof") in
        let: "$a1" := #(W64 0) in
        (func_call #marshal.WriteInt) "$a0" "$a1") in
        do:  ("proof" <-[#sliceT] "$r0");;;
        let: "$r0" := (let: "$a0" := (![#sliceT] "proof") in
        let: "$a1" := #(W64 0) in
        (func_call #marshal.WriteInt) "$a0" "$a1") in
        do:  ("proof" <-[#sliceT] "$r0")
      else do:  #());;;
      return: (![#boolT] "inTree", ![#sliceT] "val", ![#sliceT] "proof")
    else do:  #());;;
    (if: (~ (let: "$a0" := (![#sliceT] "foundLabel") in
    let: "$a1" := (![#sliceT] "label") in
    (func_call #bytes.Equal) "$a0" "$a1"))
    then
      (if: ![#boolT] "getProof"
      then
        let: "$r0" := (let: "$a0" := (![#sliceT] "proof") in
        let: "$a1" := #true in
        (func_call #marshal.WriteBool) "$a0" "$a1") in
        do:  ("proof" <-[#sliceT] "$r0");;;
        let: "$r0" := (let: "$a0" := (![#sliceT] "proof") in
        let: "$a1" := (s_to_w64 (let: "$a0" := (![#sliceT] "foundLabel") in
        slice.len "$a0")) in
        (func_call #marshal.WriteInt) "$a0" "$a1") in
        do:  ("proof" <-[#sliceT] "$r0");;;
        let: "$r0" := (let: "$a0" := (![#sliceT] "proof") in
        let: "$a1" := (![#sliceT] "foundLabel") in
        (func_call #marshal.WriteBytes) "$a0" "$a1") in
        do:  ("proof" <-[#sliceT] "$r0");;;
        let: "$r0" := (let: "$a0" := (![#sliceT] "proof") in
        let: "$a1" := (s_to_w64 (let: "$a0" := (![#sliceT] "val") in
        slice.len "$a0")) in
        (func_call #marshal.WriteInt) "$a0" "$a1") in
        do:  ("proof" <-[#sliceT] "$r0");;;
        let: "$r0" := (let: "$a0" := (![#sliceT] "proof") in
        let: "$a1" := (![#sliceT] "val") in
        (func_call #marshal.WriteBytes) "$a0" "$a1") in
        do:  ("proof" <-[#sliceT] "$r0")
      else do:  #());;;
      return: (![#boolT] "inTree", ![#sliceT] "val", ![#sliceT] "proof")
    else do:  #());;;
    (if: ![#boolT] "getProof"
    then
      let: "$r0" := (let: "$a0" := (![#sliceT] "proof") in
      let: "$a1" := #false in
      (func_call #marshal.WriteBool) "$a0" "$a1") in
      do:  ("proof" <-[#sliceT] "$r0");;;
      let: "$r0" := (let: "$a0" := (![#sliceT] "proof") in
      let: "$a1" := #(W64 0) in
      (func_call #marshal.WriteInt) "$a0" "$a1") in
      do:  ("proof" <-[#sliceT] "$r0");;;
      let: "$r0" := (let: "$a0" := (![#sliceT] "proof") in
      let: "$a1" := #(W64 0) in
      (func_call #marshal.WriteInt) "$a0" "$a1") in
      do:  ("proof" <-[#sliceT] "$r0")
    else do:  #());;;
    let: "$r0" := #true in
    do:  ("inTree" <-[#boolT] "$r0");;;
    return: (![#boolT] "inTree", ![#sliceT] "val", ![#sliceT] "proof")).

Definition getProofCap : go_string := "github.com/sanjit-bhat/pav/merkle.getProofCap"%go.

(* find searches the tree for a leaf node down path label.
   it expects no cut nodes along label.

   go: merkle.go:164:16 *)
Definition node__findⁱᵐᵖˡ : val :=
  λ: "n" "depth" "label" "getProof",
    exception_do (let: "sibs" := (mem.alloc (type.zero_val #sliceT)) in
    let: "foundVal" := (mem.alloc (type.zero_val #sliceT)) in
    let: "foundLabel" := (mem.alloc (type.zero_val #sliceT)) in
    let: "found" := (mem.alloc (type.zero_val #boolT)) in
    let: "n" := (mem.alloc "n") in
    let: "getProof" := (mem.alloc "getProof") in
    let: "label" := (mem.alloc "label") in
    let: "depth" := (mem.alloc "depth") in
    (if: (![#ptrT] "n") = #null
    then
      (if: ![#boolT] "getProof"
      then
        let: "$r0" := (slice.make3 #byteT #(W64 8) (let: "$a0" := (![#uint64T] "depth") in
        (func_call #getProofCap) "$a0")) in
        do:  ("sibs" <-[#sliceT] "$r0")
      else do:  #());;;
      return: (![#boolT] "found", ![#sliceT] "foundLabel", ![#sliceT] "foundVal", ![#sliceT] "sibs")
    else do:  #());;;
    (if: (![#byteT] (struct.field_ref #node #"nodeTy"%go (![#ptrT] "n"))) = leafNodeTy
    then
      let: "$r0" := #true in
      do:  ("found" <-[#boolT] "$r0");;;
      let: "$r0" := (![#sliceT] (struct.field_ref #node #"label"%go (![#ptrT] "n"))) in
      do:  ("foundLabel" <-[#sliceT] "$r0");;;
      let: "$r0" := (![#sliceT] (struct.field_ref #node #"val"%go (![#ptrT] "n"))) in
      do:  ("foundVal" <-[#sliceT] "$r0");;;
      (if: ![#boolT] "getProof"
      then
        let: "$r0" := (slice.make3 #byteT #(W64 8) (let: "$a0" := (![#uint64T] "depth") in
        (func_call #getProofCap) "$a0")) in
        do:  ("sibs" <-[#sliceT] "$r0")
      else do:  #());;;
      return: (![#boolT] "found", ![#sliceT] "foundLabel", ![#sliceT] "foundVal", ![#sliceT] "sibs")
    else do:  #());;;
    (if: (![#byteT] (struct.field_ref #node #"nodeTy"%go (![#ptrT] "n"))) = innerNodeTy
    then
      let: "sib" := (mem.alloc (type.zero_val #ptrT)) in
      let: "child" := (mem.alloc (type.zero_val #ptrT)) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "label") in
      let: "$a1" := (![#uint64T] "depth") in
      (method_call #(ptrT.id node.id) #"getChild"%go (![#ptrT] "n")) "$a0" "$a1") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("child" <-[#ptrT] "$r0");;;
      do:  ("sib" <-[#ptrT] "$r1");;;
      let: ((("$ret0", "$ret1"), "$ret2"), "$ret3") := (let: "$a0" := ((![#uint64T] "depth") + #(W64 1)) in
      let: "$a1" := (![#sliceT] "label") in
      let: "$a2" := (![#boolT] "getProof") in
      (method_call #(ptrT.id node.id) #"find"%go (![#ptrT] (![#ptrT] "child"))) "$a0" "$a1" "$a2") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      let: "$r2" := "$ret2" in
      let: "$r3" := "$ret3" in
      do:  ("found" <-[#boolT] "$r0");;;
      do:  ("foundLabel" <-[#sliceT] "$r1");;;
      do:  ("foundVal" <-[#sliceT] "$r2");;;
      do:  ("sibs" <-[#sliceT] "$r3");;;
      (if: ![#boolT] "getProof"
      then
        let: "$r0" := (let: "$a0" := (![#sliceT] "sibs") in
        let: "$a1" := ((method_call #(ptrT.id node.id) #"getHash"%go (![#ptrT] (![#ptrT] "sib"))) #()) in
        (slice.append #byteT) "$a0" "$a1") in
        do:  ("sibs" <-[#sliceT] "$r0")
      else do:  #());;;
      return: (![#boolT] "found", ![#sliceT] "foundLabel", ![#sliceT] "foundVal", ![#sliceT] "sibs")
    else do:  #());;;
    do:  (let: "$a0" := (interface.make #stringT.id #"merkle: find into cut node"%go) in
    Panic "$a0")).

(* go: merkle.go:199:6 *)
Definition getProofCapⁱᵐᵖˡ : val :=
  λ: "depth",
    exception_do (let: "depth" := (mem.alloc "depth") in
    return: ((((((#(W64 8) + ((![#uint64T] "depth") * cryptoffi.HashLen)) + #(W64 1)) + #(W64 8)) + cryptoffi.HashLen) + #(W64 8)) + #(W64 32))).

Definition VerifyMemb : go_string := "github.com/sanjit-bhat/pav/merkle.VerifyMemb"%go.

Definition proofToTree : go_string := "github.com/sanjit-bhat/pav/merkle.proofToTree"%go.

(* VerifyMemb checks that (label, val) in tree described by proof.
   to save on bandwidth, some callers get hash from Verify.
   callers that expect some hash should check that they got the right one.

   go: merkle.go:209:6 *)
Definition VerifyMembⁱᵐᵖˡ : val :=
  λ: "label" "val" "entryProof",
    exception_do (let: "err" := (mem.alloc (type.zero_val #boolT)) in
    let: "hash" := (mem.alloc (type.zero_val #sliceT)) in
    let: "entryProof" := (mem.alloc "entryProof") in
    let: "val" := (mem.alloc "val") in
    let: "label" := (mem.alloc "label") in
    let: "tr" := (mem.alloc (type.zero_val #ptrT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "label") in
    let: "$a1" := (![#sliceT] "entryProof") in
    (func_call #proofToTree) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("tr" <-[#ptrT] "$r0");;;
    do:  ("err" <-[#boolT] "$r1");;;
    (if: ![#boolT] "err"
    then return: (![#sliceT] "hash", ![#boolT] "err")
    else do:  #());;;
    do:  (let: "$a0" := (~ (let: "$a0" := "tr" in
    let: "$a1" := #(W64 0) in
    let: "$a2" := (![#sliceT] "label") in
    let: "$a3" := (![#sliceT] "val") in
    (func_call #put) "$a0" "$a1" "$a2" "$a3")) in
    (func_call #std.Assert) "$a0");;;
    let: "$r0" := ((method_call #(ptrT.id node.id) #"getHash"%go (![#ptrT] "tr")) #()) in
    do:  ("hash" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "hash", ![#boolT] "err")).

Definition VerifyNonMemb : go_string := "github.com/sanjit-bhat/pav/merkle.VerifyNonMemb"%go.

(* VerifyNonMemb checks that label not in tree described by proof.

   go: merkle.go:220:6 *)
Definition VerifyNonMembⁱᵐᵖˡ : val :=
  λ: "label" "entryProof",
    exception_do (let: "err" := (mem.alloc (type.zero_val #boolT)) in
    let: "hash" := (mem.alloc (type.zero_val #sliceT)) in
    let: "entryProof" := (mem.alloc "entryProof") in
    let: "label" := (mem.alloc "label") in
    let: "tr" := (mem.alloc (type.zero_val #ptrT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "label") in
    let: "$a1" := (![#sliceT] "entryProof") in
    (func_call #proofToTree) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("tr" <-[#ptrT] "$r0");;;
    do:  ("err" <-[#boolT] "$r1");;;
    (if: ![#boolT] "err"
    then return: (![#sliceT] "hash", ![#boolT] "err")
    else do:  #());;;
    let: "$r0" := ((method_call #(ptrT.id node.id) #"getHash"%go (![#ptrT] "tr")) #()) in
    do:  ("hash" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "hash", ![#boolT] "err")).

Definition VerifyUpdate : go_string := "github.com/sanjit-bhat/pav/merkle.VerifyUpdate"%go.

(* VerifyUpdate returns the hash for an old tree without label and
   the hash after inserting (label, val).

   go: merkle.go:231:6 *)
Definition VerifyUpdateⁱᵐᵖˡ : val :=
  λ: "label" "val" "updProof",
    exception_do (let: "err" := (mem.alloc (type.zero_val #boolT)) in
    let: "hashNew" := (mem.alloc (type.zero_val #sliceT)) in
    let: "hashOld" := (mem.alloc (type.zero_val #sliceT)) in
    let: "updProof" := (mem.alloc "updProof") in
    let: "val" := (mem.alloc "val") in
    let: "label" := (mem.alloc "label") in
    let: "tr" := (mem.alloc (type.zero_val #ptrT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "label") in
    let: "$a1" := (![#sliceT] "updProof") in
    (func_call #proofToTree) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("tr" <-[#ptrT] "$r0");;;
    do:  ("err" <-[#boolT] "$r1");;;
    (if: ![#boolT] "err"
    then return: (![#sliceT] "hashOld", ![#sliceT] "hashNew", ![#boolT] "err")
    else do:  #());;;
    let: "$r0" := ((method_call #(ptrT.id node.id) #"getHash"%go (![#ptrT] "tr")) #()) in
    do:  ("hashOld" <-[#sliceT] "$r0");;;
    do:  (let: "$a0" := (~ (let: "$a0" := "tr" in
    let: "$a1" := #(W64 0) in
    let: "$a2" := (![#sliceT] "label") in
    let: "$a3" := (![#sliceT] "val") in
    (func_call #put) "$a0" "$a1" "$a2" "$a3")) in
    (func_call #std.Assert) "$a0");;;
    let: "$r0" := ((method_call #(ptrT.id node.id) #"getHash"%go (![#ptrT] "tr")) #()) in
    do:  ("hashNew" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "hashOld", ![#sliceT] "hashNew", ![#boolT] "err")).

(* go: merkle.go:242:15 *)
Definition Map__Hashⁱᵐᵖˡ : val :=
  λ: "m" <>,
    exception_do (let: "m" := (mem.alloc "m") in
    return: ((method_call #(ptrT.id node.id) #"getHash"%go (![#ptrT] (struct.field_ref #Map #"root"%go (![#ptrT] "m")))) #())).

Definition Proof : go_type := structT [
  "Siblings" :: sliceT;
  "IsOtherLeaf" :: boolT;
  "LeafLabel" :: sliceT;
  "LeafVal" :: sliceT
].
#[global] Typeclasses Opaque Proof.
#[global] Opaque Proof.

Definition newShell : go_string := "github.com/sanjit-bhat/pav/merkle.newShell"%go.

Definition ProofDecode : go_string := "github.com/sanjit-bhat/pav/merkle.ProofDecode"%go.

(* proofToTree guarantees that label not in tree and that label has fixed len.

   go: merkle.go:247:6 *)
Definition proofToTreeⁱᵐᵖˡ : val :=
  λ: "label" "proof",
    exception_do (let: "err" := (mem.alloc (type.zero_val #boolT)) in
    let: "tr" := (mem.alloc (type.zero_val #ptrT)) in
    let: "proof" := (mem.alloc "proof") in
    let: "label" := (mem.alloc "label") in
    (if: (s_to_w64 (let: "$a0" := (![#sliceT] "label") in
    slice.len "$a0")) ≠ cryptoffi.HashLen
    then
      let: "$r0" := #true in
      do:  ("err" <-[#boolT] "$r0");;;
      return: (![#ptrT] "tr", ![#boolT] "err")
    else do:  #());;;
    let: "p" := (mem.alloc (type.zero_val #ptrT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "proof") in
    (func_call #ProofDecode) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("p" <-[#ptrT] "$r0");;;
    do:  "$r1";;;
    do:  ("err" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err"
    then return: (![#ptrT] "tr", ![#boolT] "err")
    else do:  #());;;
    (if: ((s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref #Proof #"Siblings"%go (![#ptrT] "p"))) in
    slice.len "$a0")) `rem` cryptoffi.HashLen) ≠ #(W64 0)
    then
      let: "$r0" := #true in
      do:  ("err" <-[#boolT] "$r0");;;
      return: (![#ptrT] "tr", ![#boolT] "err")
    else do:  #());;;
    let: "sibsDepth" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := ((s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref #Proof #"Siblings"%go (![#ptrT] "p"))) in
    slice.len "$a0")) `quot` cryptoffi.HashLen) in
    do:  ("sibsDepth" <-[#uint64T] "$r0");;;
    (if: (![#uint64T] "sibsDepth") > maxDepth
    then
      let: "$r0" := #true in
      do:  ("err" <-[#boolT] "$r0");;;
      return: (![#ptrT] "tr", ![#boolT] "err")
    else do:  #());;;
    let: "$r0" := (let: "$a0" := #(W64 0) in
    let: "$a1" := (![#sliceT] "label") in
    let: "$a2" := (![#sliceT] (struct.field_ref #Proof #"Siblings"%go (![#ptrT] "p"))) in
    (func_call #newShell) "$a0" "$a1" "$a2") in
    do:  ("tr" <-[#ptrT] "$r0");;;
    (if: ![#boolT] (struct.field_ref #Proof #"IsOtherLeaf"%go (![#ptrT] "p"))
    then
      (if: (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref #Proof #"LeafLabel"%go (![#ptrT] "p"))) in
      slice.len "$a0")) ≠ cryptoffi.HashLen
      then
        let: "$r0" := #true in
        do:  ("err" <-[#boolT] "$r0");;;
        return: (![#ptrT] "tr", ![#boolT] "err")
      else do:  #());;;
      (if: let: "$a0" := (![#sliceT] "label") in
      let: "$a1" := (![#sliceT] (struct.field_ref #Proof #"LeafLabel"%go (![#ptrT] "p"))) in
      (func_call #bytes.Equal) "$a0" "$a1"
      then
        let: "$r0" := #true in
        do:  ("err" <-[#boolT] "$r0");;;
        return: (![#ptrT] "tr", ![#boolT] "err")
      else do:  #());;;
      (let: "$r0" := (let: "$a0" := "tr" in
      let: "$a1" := #(W64 0) in
      let: "$a2" := (![#sliceT] (struct.field_ref #Proof #"LeafLabel"%go (![#ptrT] "p"))) in
      let: "$a3" := (![#sliceT] (struct.field_ref #Proof #"LeafVal"%go (![#ptrT] "p"))) in
      (func_call #put) "$a0" "$a1" "$a2" "$a3") in
      do:  ("err" <-[#boolT] "$r0");;;
      (if: ![#boolT] "err"
      then return: (![#ptrT] "tr", ![#boolT] "err")
      else do:  #()))
    else do:  #());;;
    return: (![#ptrT] "tr", ![#boolT] "err")).

(* go: merkle.go:282:6 *)
Definition newShellⁱᵐᵖˡ : val :=
  λ: "depth" "label" "sibs",
    exception_do (let: "n" := (mem.alloc (type.zero_val #ptrT)) in
    let: "sibs" := (mem.alloc "sibs") in
    let: "label" := (mem.alloc "label") in
    let: "depth" := (mem.alloc "depth") in
    let: "sibsLen" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (s_to_w64 (let: "$a0" := (![#sliceT] "sibs") in
    slice.len "$a0")) in
    do:  ("sibsLen" <-[#uint64T] "$r0");;;
    (if: (![#uint64T] "sibsLen") = #(W64 0)
    then return: (![#ptrT] "n")
    else do:  #());;;
    let: "split" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := ((![#uint64T] "sibsLen") - cryptoffi.HashLen) in
    do:  ("split" <-[#uint64T] "$r0");;;
    let: "sibs0" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$s" := (![#sliceT] "sibs") in
    slice.slice #byteT "$s" #(W64 0) (![#uint64T] "split")) in
    do:  ("sibs0" <-[#sliceT] "$r0");;;
    let: "hash" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$s" := (![#sliceT] "sibs") in
    slice.slice #byteT "$s" (![#uint64T] "split") (slice.len "$s")) in
    do:  ("hash" <-[#sliceT] "$r0");;;
    let: "cut" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (let: "$nodeTy" := cutNodeTy in
    let: "$hash" := (![#sliceT] "hash") in
    struct.make #node [{
      "nodeTy" ::= "$nodeTy";
      "hash" ::= "$hash";
      "child0" ::= type.zero_val #ptrT;
      "child1" ::= type.zero_val #ptrT;
      "label" ::= type.zero_val #sliceT;
      "val" ::= type.zero_val #sliceT
    }])) in
    do:  ("cut" <-[#ptrT] "$r0");;;
    let: "inner" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (let: "$nodeTy" := innerNodeTy in
    struct.make #node [{
      "nodeTy" ::= "$nodeTy";
      "hash" ::= type.zero_val #sliceT;
      "child0" ::= type.zero_val #ptrT;
      "child1" ::= type.zero_val #ptrT;
      "label" ::= type.zero_val #sliceT;
      "val" ::= type.zero_val #sliceT
    }])) in
    do:  ("inner" <-[#ptrT] "$r0");;;
    let: "sib" := (mem.alloc (type.zero_val #ptrT)) in
    let: "child" := (mem.alloc (type.zero_val #ptrT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "label") in
    let: "$a1" := (![#uint64T] "depth") in
    (method_call #(ptrT.id node.id) #"getChild"%go (![#ptrT] "inner")) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("child" <-[#ptrT] "$r0");;;
    do:  ("sib" <-[#ptrT] "$r1");;;
    let: "$r0" := (![#ptrT] "cut") in
    do:  ((![#ptrT] "sib") <-[#ptrT] "$r0");;;
    let: "$r0" := (let: "$a0" := ((![#uint64T] "depth") + #(W64 1)) in
    let: "$a1" := (![#sliceT] "label") in
    let: "$a2" := (![#sliceT] "sibs0") in
    (func_call #newShell) "$a0" "$a1" "$a2") in
    do:  ((![#ptrT] "child") <-[#ptrT] "$r0");;;
    let: "$r0" := (let: "$a0" := ((method_call #(ptrT.id node.id) #"getHash"%go (![#ptrT] (struct.field_ref #node #"child0"%go (![#ptrT] "inner")))) #()) in
    let: "$a1" := ((method_call #(ptrT.id node.id) #"getHash"%go (![#ptrT] (struct.field_ref #node #"child1"%go (![#ptrT] "inner")))) #()) in
    (func_call #compInnerHash) "$a0" "$a1") in
    do:  ((struct.field_ref #node #"hash"%go (![#ptrT] "inner")) <-[#sliceT] "$r0");;;
    return: (![#ptrT] "inner")).

(* go: merkle.go:299:16 *)
Definition node__getHashⁱᵐᵖˡ : val :=
  λ: "n" <>,
    exception_do (let: "n" := (mem.alloc "n") in
    (if: (![#ptrT] "n") = #null
    then return: (![#sliceT] (globals.get #emptyHash))
    else do:  #());;;
    return: (![#sliceT] (struct.field_ref #node #"hash"%go (![#ptrT] "n")))).

Definition compEmptyHash : go_string := "github.com/sanjit-bhat/pav/merkle.compEmptyHash"%go.

(* go: merkle.go:306:6 *)
Definition compEmptyHashⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (let: "$a0" := ((let: "$sl0" := emptyNodeTag in
     slice.literal #byteT ["$sl0"])) in
     (func_call #cryptoutil.Hash) "$a0")).

(* go: merkle.go:310:6 *)
Definition compLeafHashⁱᵐᵖˡ : val :=
  λ: "label" "val",
    exception_do (let: "val" := (mem.alloc "val") in
    let: "label" := (mem.alloc "label") in
    let: "hr" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := ((func_call #cryptoffi.NewHasher) #()) in
    do:  ("hr" <-[#ptrT] "$r0");;;
    do:  (let: "$a0" := ((let: "$sl0" := leafNodeTag in
    slice.literal #byteT ["$sl0"])) in
    (method_call #(ptrT.id cryptoffi.Hasher.id) #"Write"%go (![#ptrT] "hr")) "$a0");;;
    do:  (let: "$a0" := (let: "$a0" := #slice.nil in
    let: "$a1" := (s_to_w64 (let: "$a0" := (![#sliceT] "label") in
    slice.len "$a0")) in
    (func_call #marshal.WriteInt) "$a0" "$a1") in
    (method_call #(ptrT.id cryptoffi.Hasher.id) #"Write"%go (![#ptrT] "hr")) "$a0");;;
    do:  (let: "$a0" := (![#sliceT] "label") in
    (method_call #(ptrT.id cryptoffi.Hasher.id) #"Write"%go (![#ptrT] "hr")) "$a0");;;
    do:  (let: "$a0" := (let: "$a0" := #slice.nil in
    let: "$a1" := (s_to_w64 (let: "$a0" := (![#sliceT] "val") in
    slice.len "$a0")) in
    (func_call #marshal.WriteInt) "$a0" "$a1") in
    (method_call #(ptrT.id cryptoffi.Hasher.id) #"Write"%go (![#ptrT] "hr")) "$a0");;;
    do:  (let: "$a0" := (![#sliceT] "val") in
    (method_call #(ptrT.id cryptoffi.Hasher.id) #"Write"%go (![#ptrT] "hr")) "$a0");;;
    return: (let: "$a0" := #slice.nil in
     (method_call #(ptrT.id cryptoffi.Hasher.id) #"Sum"%go (![#ptrT] "hr")) "$a0")).

(* go: merkle.go:320:6 *)
Definition compInnerHashⁱᵐᵖˡ : val :=
  λ: "child0" "child1",
    exception_do (let: "child1" := (mem.alloc "child1") in
    let: "child0" := (mem.alloc "child0") in
    let: "hr" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := ((func_call #cryptoffi.NewHasher) #()) in
    do:  ("hr" <-[#ptrT] "$r0");;;
    do:  (let: "$a0" := ((let: "$sl0" := innerNodeTag in
    slice.literal #byteT ["$sl0"])) in
    (method_call #(ptrT.id cryptoffi.Hasher.id) #"Write"%go (![#ptrT] "hr")) "$a0");;;
    do:  (let: "$a0" := (![#sliceT] "child0") in
    (method_call #(ptrT.id cryptoffi.Hasher.id) #"Write"%go (![#ptrT] "hr")) "$a0");;;
    do:  (let: "$a0" := (![#sliceT] "child1") in
    (method_call #(ptrT.id cryptoffi.Hasher.id) #"Write"%go (![#ptrT] "hr")) "$a0");;;
    return: (let: "$a0" := #slice.nil in
     (method_call #(ptrT.id cryptoffi.Hasher.id) #"Sum"%go (![#ptrT] "hr")) "$a0")).

Definition getBit : go_string := "github.com/sanjit-bhat/pav/merkle.getBit"%go.

(* getChild returns a child and its sibling child,
   relative to the bit referenced by label and depth.

   go: merkle.go:330:16 *)
Definition node__getChildⁱᵐᵖˡ : val :=
  λ: "n" "label" "depth",
    exception_do (let: "n" := (mem.alloc "n") in
    let: "depth" := (mem.alloc "depth") in
    let: "label" := (mem.alloc "label") in
    (if: let: "$a0" := (![#sliceT] "label") in
    let: "$a1" := (![#uint64T] "depth") in
    (func_call #getBit) "$a0" "$a1"
    then return: (struct.field_ref #node #"child1"%go (![#ptrT] "n"), struct.field_ref #node #"child0"%go (![#ptrT] "n"))
    else return: (struct.field_ref #node #"child0"%go (![#ptrT] "n"), struct.field_ref #node #"child1"%go (![#ptrT] "n")))).

(* getBit returns false if the nth bit of b is 0.
   if n exceeds b, it returns true.

   go: merkle.go:340:6 *)
Definition getBitⁱᵐᵖˡ : val :=
  λ: "b" "n",
    exception_do (let: "n" := (mem.alloc "n") in
    let: "b" := (mem.alloc "b") in
    let: "slot" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := ((![#uint64T] "n") `quot` #(W64 8)) in
    do:  ("slot" <-[#uint64T] "$r0");;;
    (if: (![#uint64T] "slot") < (s_to_w64 (let: "$a0" := (![#sliceT] "b") in
    slice.len "$a0"))
    then
      let: "off" := (mem.alloc (type.zero_val #uint64T)) in
      let: "$r0" := ((![#uint64T] "n") `rem` #(W64 8)) in
      do:  ("off" <-[#uint64T] "$r0");;;
      let: "x" := (mem.alloc (type.zero_val #byteT)) in
      let: "$r0" := (![#byteT] (slice.elem_ref #byteT (![#sliceT] "b") (![#uint64T] "slot"))) in
      do:  ("x" <-[#byteT] "$r0");;;
      return: (((![#byteT] "x") `and` (#(W8 1) ≪ (u_to_w8 (![#uint64T] "off")))) ≠ #(W8 0))
    else return: (#true))).

Definition ProofEncode : go_string := "github.com/sanjit-bhat/pav/merkle.ProofEncode"%go.

(* go: serde.out.go:10:6 *)
Definition ProofEncodeⁱᵐᵖˡ : val :=
  λ: "b0" "o",
    exception_do (let: "o" := (mem.alloc "o") in
    let: "b0" := (mem.alloc "b0") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "b0") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#sliceT] (struct.field_ref #Proof #"Siblings"%go (![#ptrT] "o"))) in
    (func_call #safemarshal.WriteSlice1D) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#boolT] (struct.field_ref #Proof #"IsOtherLeaf"%go (![#ptrT] "o"))) in
    (func_call #marshal.WriteBool) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#sliceT] (struct.field_ref #Proof #"LeafLabel"%go (![#ptrT] "o"))) in
    (func_call #safemarshal.WriteSlice1D) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#sliceT] (struct.field_ref #Proof #"LeafVal"%go (![#ptrT] "o"))) in
    (func_call #safemarshal.WriteSlice1D) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "b")).

(* go: serde.out.go:18:6 *)
Definition ProofDecodeⁱᵐᵖˡ : val :=
  λ: "b0",
    exception_do (let: "b0" := (mem.alloc "b0") in
    let: "err1" := (mem.alloc (type.zero_val #boolT)) in
    let: "b1" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a1" := (mem.alloc (type.zero_val #sliceT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b0") in
    (func_call #safemarshal.ReadSlice1D) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a1" <-[#sliceT] "$r0");;;
    do:  ("b1" <-[#sliceT] "$r1");;;
    do:  ("err1" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err1"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err2" := (mem.alloc (type.zero_val #boolT)) in
    let: "b2" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a2" := (mem.alloc (type.zero_val #boolT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b1") in
    (func_call #safemarshal.ReadBool) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a2" <-[#boolT] "$r0");;;
    do:  ("b2" <-[#sliceT] "$r1");;;
    do:  ("err2" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err2"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err3" := (mem.alloc (type.zero_val #boolT)) in
    let: "b3" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a3" := (mem.alloc (type.zero_val #sliceT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b2") in
    (func_call #safemarshal.ReadSlice1D) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a3" <-[#sliceT] "$r0");;;
    do:  ("b3" <-[#sliceT] "$r1");;;
    do:  ("err3" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err3"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err4" := (mem.alloc (type.zero_val #boolT)) in
    let: "b4" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a4" := (mem.alloc (type.zero_val #sliceT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b3") in
    (func_call #safemarshal.ReadSlice1D) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a4" <-[#sliceT] "$r0");;;
    do:  ("b4" <-[#sliceT] "$r1");;;
    do:  ("err4" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err4"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    return: (mem.alloc (let: "$Siblings" := (![#sliceT] "a1") in
     let: "$IsOtherLeaf" := (![#boolT] "a2") in
     let: "$LeafLabel" := (![#sliceT] "a3") in
     let: "$LeafVal" := (![#sliceT] "a4") in
     struct.make #Proof [{
       "Siblings" ::= "$Siblings";
       "IsOtherLeaf" ::= "$IsOtherLeaf";
       "LeafLabel" ::= "$LeafLabel";
       "LeafVal" ::= "$LeafVal"
     }]), ![#sliceT] "b4", #false)).

Definition vars' : list (go_string * go_type) := [(emptyHash, sliceT)].

Definition functions' : list (go_string * val) := [(put, putⁱᵐᵖˡ); (getProofCap, getProofCapⁱᵐᵖˡ); (VerifyMemb, VerifyMembⁱᵐᵖˡ); (VerifyNonMemb, VerifyNonMembⁱᵐᵖˡ); (VerifyUpdate, VerifyUpdateⁱᵐᵖˡ); (proofToTree, proofToTreeⁱᵐᵖˡ); (newShell, newShellⁱᵐᵖˡ); (compEmptyHash, compEmptyHashⁱᵐᵖˡ); (compLeafHash, compLeafHashⁱᵐᵖˡ); (compInnerHash, compInnerHashⁱᵐᵖˡ); (getBit, getBitⁱᵐᵖˡ); (ProofEncode, ProofEncodeⁱᵐᵖˡ); (ProofDecode, ProofDecodeⁱᵐᵖˡ)].

Definition msets' : list (go_string * (list (go_string * val))) := [(Map.id, []); (ptrT.id Map.id, [("Hash"%go, Map__Hashⁱᵐᵖˡ); ("Prove"%go, Map__Proveⁱᵐᵖˡ); ("Put"%go, Map__Putⁱᵐᵖˡ)]); (node.id, []); (ptrT.id node.id, [("find"%go, node__findⁱᵐᵖˡ); ("getChild"%go, node__getChildⁱᵐᵖˡ); ("getHash"%go, node__getHashⁱᵐᵖˡ); ("prove"%go, node__proveⁱᵐᵖˡ)]); (Proof.id, []); (ptrT.id Proof.id, [])].

#[global] Instance info' : PkgInfo merkle.merkle :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [code.bytes.bytes; code.github_com.goose_lang.primitive.primitive; code.github_com.goose_lang.std.std; code.github_com.sanjit_bhat.pav.cryptoffi.cryptoffi; code.github_com.sanjit_bhat.pav.cryptoutil.cryptoutil; code.github_com.tchajed.marshal.marshal; code.github_com.sanjit_bhat.pav.safemarshal.safemarshal];
  |}.

Definition initialize' : val :=
  λ: <>,
    package.init #merkle.merkle (λ: <>,
      exception_do (do:  (safemarshal.initialize' #());;;
      do:  (marshal.initialize' #());;;
      do:  (cryptoutil.initialize' #());;;
      do:  (cryptoffi.initialize' #());;;
      do:  (std.initialize' #());;;
      do:  (primitive.initialize' #());;;
      do:  (bytes.initialize' #());;;
      do:  (package.alloc merkle.merkle #());;;
      let: "$r0" := ((func_call #compEmptyHash) #()) in
      do:  ((globals.get #emptyHash) <-[#sliceT] "$r0"))
      ).

End code.
End merkle.
