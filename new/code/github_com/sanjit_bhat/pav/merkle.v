(* autogenerated from github.com/sanjit-bhat/pav/merkle *)
From New.golang Require Import defn.
Require Export New.code.github_com.goose_lang.primitive.
Require Export New.code.github_com.goose_lang.std.
Require Export New.code.github_com.sanjit_bhat.pav.cryptoffi.
Require Export New.code.github_com.sanjit_bhat.pav.cryptoutil.
Require Export New.code.github_com.sanjit_bhat.pav.safemarshal.
Require Export New.code.github_com.tchajed.marshal.

Definition merkle : go_string := "github.com/sanjit-bhat/pav/merkle".

Module merkle.
Section code.
Context `{ffi_syntax}.


Definition emptyNodeTag : expr := #(W8 0).

Definition leafNodeTag : expr := #(W8 1).

Definition innerNodeTag : expr := #(W8 2).

Definition cutNodeTy : expr := #(W8 0).

Definition leafNodeTy : expr := #(W8 1).

Definition innerNodeTy : expr := #(W8 2).

Definition Tree : go_type := structT [
  "root" :: ptrT
].

Definition node : go_type := structT [
  "nodeTy" :: byteT;
  "hash" :: sliceT;
  "child0" :: ptrT;
  "child1" :: ptrT;
  "label" :: sliceT;
  "val" :: sliceT
].

(* Put adds the leaf (label, val), storing immutable references to both.
   for liveness (not safety) reasons, it returns an error
   if the label does not have a fixed length.

   go: merkle.go:53:16 *)
Definition Tree__Put : val :=
  rec: "Tree__Put" "t" "label" "val" :=
    exception_do (let: "err" := (mem.alloc (type.zero_val #boolT)) in
    let: "t" := (mem.alloc "t") in
    let: "val" := (mem.alloc "val") in
    let: "label" := (mem.alloc "label") in
    (if: (s_to_w64 (let: "$a0" := (![#sliceT] "label") in
    slice.len "$a0")) ≠ cryptoffi.HashLen
    then return: (#true)
    else do:  #());;;
    do:  (let: "$a0" := (struct.field_ref #Tree #"root"%go (![#ptrT] "t")) in
    let: "$a1" := #(W64 0) in
    let: "$a2" := (![#sliceT] "label") in
    let: "$a3" := (![#sliceT] "val") in
    (func_call #merkle.merkle #"put"%go) "$a0" "$a1" "$a2" "$a3");;;
    return: (![#boolT] "err")).

(* put inserts leaf node (label, val) into the n0 sub-tree.
   it never drops the update.

   go: merkle.go:63:6 *)
Definition put : val :=
  rec: "put" "n0" "depth" "label" "val" :=
    exception_do (let: "val" := (mem.alloc "val") in
    let: "label" := (mem.alloc "label") in
    let: "depth" := (mem.alloc "depth") in
    let: "n0" := (mem.alloc "n0") in
    let: "n" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (![#ptrT] (![#ptrT] "n0")) in
    do:  ("n" <-[#ptrT] "$r0");;;
    (if: ((![#ptrT] "n") = #null) || ((![#byteT] (struct.field_ref #node #"nodeTy"%go (![#ptrT] "n"))) = cutNodeTy)
    then
      let: "leaf" := (mem.alloc (type.zero_val #ptrT)) in
      let: "$r0" := (mem.alloc (let: "$nodeTy" := leafNodeTy in
      let: "$label" := (![#sliceT] "label") in
      let: "$val" := (![#sliceT] "val") in
      struct.make #node [{
        "nodeTy" ::= "$nodeTy";
        "hash" ::= type.zero_val #sliceT;
        "child0" ::= type.zero_val #ptrT;
        "child1" ::= type.zero_val #ptrT;
        "label" ::= "$label";
        "val" ::= "$val"
      }])) in
      do:  ("leaf" <-[#ptrT] "$r0");;;
      let: "$r0" := (![#ptrT] "leaf") in
      do:  ((![#ptrT] "n0") <-[#ptrT] "$r0");;;
      do:  (let: "$a0" := (![#ptrT] "leaf") in
      (func_call #merkle.merkle #"setLeafHash"%go) "$a0");;;
      return: (#())
    else do:  #());;;
    (if: (![#byteT] (struct.field_ref #node #"nodeTy"%go (![#ptrT] "n"))) = leafNodeTy
    then
      (if: let: "$a0" := (![#sliceT] (struct.field_ref #node #"label"%go (![#ptrT] "n"))) in
      let: "$a1" := (![#sliceT] "label") in
      (func_call #std.std #"BytesEqual"%go) "$a0" "$a1"
      then
        let: "$r0" := (![#sliceT] "val") in
        do:  ((struct.field_ref #node #"val"%go (![#ptrT] "n")) <-[#sliceT] "$r0");;;
        do:  (let: "$a0" := (![#ptrT] "n") in
        (func_call #merkle.merkle #"setLeafHash"%go) "$a0");;;
        return: (#())
      else do:  #());;;
      let: "inner" := (mem.alloc (type.zero_val #ptrT)) in
      let: "$r0" := (mem.alloc (let: "$nodeTy" := innerNodeTy in
      struct.make #node [{
        "nodeTy" ::= "$nodeTy";
        "hash" ::= type.zero_val #sliceT;
        "child0" ::= type.zero_val #ptrT;
        "child1" ::= type.zero_val #ptrT;
        "label" ::= type.zero_val #sliceT;
        "val" ::= type.zero_val #sliceT
      }])) in
      do:  ("inner" <-[#ptrT] "$r0");;;
      let: "$r0" := (![#ptrT] "inner") in
      do:  ((![#ptrT] "n0") <-[#ptrT] "$r0");;;
      let: "leafChild" := (mem.alloc (type.zero_val #ptrT)) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![#ptrT] "inner") in
      let: "$a1" := (![#sliceT] (struct.field_ref #node #"label"%go (![#ptrT] "n"))) in
      let: "$a2" := (![#uint64T] "depth") in
      (func_call #merkle.merkle #"getChild"%go) "$a0" "$a1" "$a2") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("leafChild" <-[#ptrT] "$r0");;;
      do:  "$r1";;;
      let: "$r0" := (![#ptrT] "n") in
      do:  ((![#ptrT] "leafChild") <-[#ptrT] "$r0");;;
      let: "recurChild" := (mem.alloc (type.zero_val #ptrT)) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![#ptrT] "inner") in
      let: "$a1" := (![#sliceT] "label") in
      let: "$a2" := (![#uint64T] "depth") in
      (func_call #merkle.merkle #"getChild"%go) "$a0" "$a1" "$a2") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("recurChild" <-[#ptrT] "$r0");;;
      do:  "$r1";;;
      do:  (let: "$a0" := (![#ptrT] "recurChild") in
      let: "$a1" := ((![#uint64T] "depth") + #(W64 1)) in
      let: "$a2" := (![#sliceT] "label") in
      let: "$a3" := (![#sliceT] "val") in
      (func_call #merkle.merkle #"put"%go) "$a0" "$a1" "$a2" "$a3");;;
      do:  (let: "$a0" := (![#ptrT] "inner") in
      (func_call #merkle.merkle #"setInnerHash"%go) "$a0");;;
      return: (#())
    else do:  #());;;
    do:  (let: "$a0" := ((![#byteT] (struct.field_ref #node #"nodeTy"%go (![#ptrT] "n"))) = innerNodeTy) in
    (func_call #std.std #"Assert"%go) "$a0");;;
    let: "c" := (mem.alloc (type.zero_val #ptrT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#ptrT] "n") in
    let: "$a1" := (![#sliceT] "label") in
    let: "$a2" := (![#uint64T] "depth") in
    (func_call #merkle.merkle #"getChild"%go) "$a0" "$a1" "$a2") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("c" <-[#ptrT] "$r0");;;
    do:  "$r1";;;
    do:  (let: "$a0" := (![#ptrT] "c") in
    let: "$a1" := ((![#uint64T] "depth") + #(W64 1)) in
    let: "$a2" := (![#sliceT] "label") in
    let: "$a3" := (![#sliceT] "val") in
    (func_call #merkle.merkle #"put"%go) "$a0" "$a1" "$a2" "$a3");;;
    do:  (let: "$a0" := (![#ptrT] "n") in
    (func_call #merkle.merkle #"setInnerHash"%go) "$a0");;;
    return: #()).

(* Get should only be called on complete trees (no cuts).

   go: merkle.go:102:16 *)
Definition Tree__Get : val :=
  rec: "Tree__Get" "t" "label" :=
    exception_do (let: "val" := (mem.alloc (type.zero_val #sliceT)) in
    let: "inTree" := (mem.alloc (type.zero_val #boolT)) in
    let: "t" := (mem.alloc "t") in
    let: "label" := (mem.alloc "label") in
    let: "errb" := (mem.alloc (type.zero_val #boolT)) in
    let: ((("$ret0", "$ret1"), "$ret2"), "$ret3") := (let: "$a0" := (![#sliceT] "label") in
    let: "$a1" := #false in
    (method_call #merkle.merkle #"Tree'ptr" #"prove" (![#ptrT] "t")) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    let: "$r3" := "$ret3" in
    do:  ("inTree" <-[#boolT] "$r0");;;
    do:  ("val" <-[#sliceT] "$r1");;;
    do:  "$r2";;;
    do:  ("errb" <-[#boolT] "$r3");;;
    do:  (let: "$a0" := (~ (![#boolT] "errb")) in
    (func_call #std.std #"Assert"%go) "$a0");;;
    return: (![#boolT] "inTree", ![#sliceT] "val")).

(* Prove should only be called on complete trees (no cuts).

   go: merkle.go:109:16 *)
Definition Tree__Prove : val :=
  rec: "Tree__Prove" "t" "label" :=
    exception_do (let: "proof" := (mem.alloc (type.zero_val #sliceT)) in
    let: "val" := (mem.alloc (type.zero_val #sliceT)) in
    let: "inTree" := (mem.alloc (type.zero_val #boolT)) in
    let: "t" := (mem.alloc "t") in
    let: "label" := (mem.alloc "label") in
    let: "errb" := (mem.alloc (type.zero_val #boolT)) in
    let: ((("$ret0", "$ret1"), "$ret2"), "$ret3") := (let: "$a0" := (![#sliceT] "label") in
    let: "$a1" := #true in
    (method_call #merkle.merkle #"Tree'ptr" #"prove" (![#ptrT] "t")) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    let: "$r3" := "$ret3" in
    do:  ("inTree" <-[#boolT] "$r0");;;
    do:  ("val" <-[#sliceT] "$r1");;;
    do:  ("proof" <-[#sliceT] "$r2");;;
    do:  ("errb" <-[#boolT] "$r3");;;
    do:  (let: "$a0" := (~ (![#boolT] "errb")) in
    (func_call #std.std #"Assert"%go) "$a0");;;
    return: (![#boolT] "inTree", ![#sliceT] "val", ![#sliceT] "proof")).

(* prove errors if search lands on a cut node.

   go: merkle.go:116:16 *)
Definition Tree__prove : val :=
  rec: "Tree__prove" "t" "label" "getProof" :=
    exception_do (let: "err" := (mem.alloc (type.zero_val #boolT)) in
    let: "proof" := (mem.alloc (type.zero_val #sliceT)) in
    let: "val" := (mem.alloc (type.zero_val #sliceT)) in
    let: "inTree" := (mem.alloc (type.zero_val #boolT)) in
    let: "t" := (mem.alloc "t") in
    let: "getProof" := (mem.alloc "getProof") in
    let: "label" := (mem.alloc "label") in
    let: "foundLabel" := (mem.alloc (type.zero_val #sliceT)) in
    let: "found" := (mem.alloc (type.zero_val #boolT)) in
    let: (((("$ret0", "$ret1"), "$ret2"), "$ret3"), "$ret4") := (let: "$a0" := (![#sliceT] "label") in
    let: "$a1" := (![#boolT] "getProof") in
    let: "$a2" := (![#ptrT] (struct.field_ref #Tree #"root"%go (![#ptrT] "t"))) in
    let: "$a3" := #(W64 0) in
    (func_call #merkle.merkle #"find"%go) "$a0" "$a1" "$a2" "$a3") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    let: "$r3" := "$ret3" in
    let: "$r4" := "$ret4" in
    do:  ("found" <-[#boolT] "$r0");;;
    do:  ("foundLabel" <-[#sliceT] "$r1");;;
    do:  ("val" <-[#sliceT] "$r2");;;
    do:  ("proof" <-[#sliceT] "$r3");;;
    do:  ("err" <-[#boolT] "$r4");;;
    (if: ![#boolT] "err"
    then return: (![#boolT] "inTree", ![#sliceT] "val", ![#sliceT] "proof", ![#boolT] "err")
    else do:  #());;;
    (if: ![#boolT] "getProof"
    then
      do:  (let: "$a0" := (![#sliceT] "proof") in
      let: "$a1" := ((s_to_w64 (let: "$a0" := (![#sliceT] "proof") in
      slice.len "$a0")) - #(W64 8)) in
      (func_call #primitive.primitive #"UInt64Put"%go) "$a0" "$a1")
    else do:  #());;;
    (if: (~ (![#boolT] "found"))
    then
      (if: ![#boolT] "getProof"
      then
        let: "$r0" := (let: "$a0" := (![#sliceT] "proof") in
        let: "$a1" := #false in
        (func_call #marshal.marshal #"WriteBool"%go) "$a0" "$a1") in
        do:  ("proof" <-[#sliceT] "$r0");;;
        let: "$r0" := (let: "$a0" := (![#sliceT] "proof") in
        let: "$a1" := #(W64 0) in
        (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
        do:  ("proof" <-[#sliceT] "$r0");;;
        let: "$r0" := (let: "$a0" := (![#sliceT] "proof") in
        let: "$a1" := #(W64 0) in
        (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
        do:  ("proof" <-[#sliceT] "$r0")
      else do:  #());;;
      return: (![#boolT] "inTree", ![#sliceT] "val", ![#sliceT] "proof", ![#boolT] "err")
    else do:  #());;;
    (if: (~ (let: "$a0" := (![#sliceT] "foundLabel") in
    let: "$a1" := (![#sliceT] "label") in
    (func_call #std.std #"BytesEqual"%go) "$a0" "$a1"))
    then
      (if: ![#boolT] "getProof"
      then
        let: "$r0" := (let: "$a0" := (![#sliceT] "proof") in
        let: "$a1" := #true in
        (func_call #marshal.marshal #"WriteBool"%go) "$a0" "$a1") in
        do:  ("proof" <-[#sliceT] "$r0");;;
        let: "$r0" := (let: "$a0" := (![#sliceT] "proof") in
        let: "$a1" := (s_to_w64 (let: "$a0" := (![#sliceT] "foundLabel") in
        slice.len "$a0")) in
        (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
        do:  ("proof" <-[#sliceT] "$r0");;;
        let: "$r0" := (let: "$a0" := (![#sliceT] "proof") in
        let: "$a1" := (![#sliceT] "foundLabel") in
        (func_call #marshal.marshal #"WriteBytes"%go) "$a0" "$a1") in
        do:  ("proof" <-[#sliceT] "$r0");;;
        let: "$r0" := (let: "$a0" := (![#sliceT] "proof") in
        let: "$a1" := (s_to_w64 (let: "$a0" := (![#sliceT] "val") in
        slice.len "$a0")) in
        (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
        do:  ("proof" <-[#sliceT] "$r0");;;
        let: "$r0" := (let: "$a0" := (![#sliceT] "proof") in
        let: "$a1" := (![#sliceT] "val") in
        (func_call #marshal.marshal #"WriteBytes"%go) "$a0" "$a1") in
        do:  ("proof" <-[#sliceT] "$r0")
      else do:  #());;;
      return: (![#boolT] "inTree", ![#sliceT] "val", ![#sliceT] "proof", ![#boolT] "err")
    else do:  #());;;
    (if: ![#boolT] "getProof"
    then
      let: "$r0" := (let: "$a0" := (![#sliceT] "proof") in
      let: "$a1" := #false in
      (func_call #marshal.marshal #"WriteBool"%go) "$a0" "$a1") in
      do:  ("proof" <-[#sliceT] "$r0");;;
      let: "$r0" := (let: "$a0" := (![#sliceT] "proof") in
      let: "$a1" := #(W64 0) in
      (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
      do:  ("proof" <-[#sliceT] "$r0");;;
      let: "$r0" := (let: "$a0" := (![#sliceT] "proof") in
      let: "$a1" := #(W64 0) in
      (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
      do:  ("proof" <-[#sliceT] "$r0")
    else do:  #());;;
    let: "$r0" := #true in
    do:  ("inTree" <-[#boolT] "$r0");;;
    return: (![#boolT] "inTree", ![#sliceT] "val", ![#sliceT] "proof", ![#boolT] "err")).

(* find searches the tree for a leaf node down path label.
   it errors if search lands on a cut node.

   go: merkle.go:154:6 *)
Definition find : val :=
  rec: "find" "label" "getProof" "n" "depth" :=
    exception_do (let: "err" := (mem.alloc (type.zero_val #boolT)) in
    let: "proof" := (mem.alloc (type.zero_val #sliceT)) in
    let: "foundVal" := (mem.alloc (type.zero_val #sliceT)) in
    let: "foundLabel" := (mem.alloc (type.zero_val #sliceT)) in
    let: "found" := (mem.alloc (type.zero_val #boolT)) in
    let: "depth" := (mem.alloc "depth") in
    let: "n" := (mem.alloc "n") in
    let: "getProof" := (mem.alloc "getProof") in
    let: "label" := (mem.alloc "label") in
    (if: (![#ptrT] "n") = #null
    then
      (if: ![#boolT] "getProof"
      then
        let: "$r0" := (slice.make3 #byteT #(W64 8) (let: "$a0" := (![#uint64T] "depth") in
        (func_call #merkle.merkle #"getProofLen"%go) "$a0")) in
        do:  ("proof" <-[#sliceT] "$r0")
      else do:  #());;;
      return: (![#boolT] "found", ![#sliceT] "foundLabel", ![#sliceT] "foundVal", ![#sliceT] "proof", ![#boolT] "err")
    else do:  #());;;
    (if: (![#byteT] (struct.field_ref #node #"nodeTy"%go (![#ptrT] "n"))) = cutNodeTy
    then
      let: "$r0" := #true in
      do:  ("err" <-[#boolT] "$r0");;;
      return: (![#boolT] "found", ![#sliceT] "foundLabel", ![#sliceT] "foundVal", ![#sliceT] "proof", ![#boolT] "err")
    else do:  #());;;
    (if: (![#byteT] (struct.field_ref #node #"nodeTy"%go (![#ptrT] "n"))) = leafNodeTy
    then
      (if: ![#boolT] "getProof"
      then
        let: "$r0" := (slice.make3 #byteT #(W64 8) (let: "$a0" := (![#uint64T] "depth") in
        (func_call #merkle.merkle #"getProofLen"%go) "$a0")) in
        do:  ("proof" <-[#sliceT] "$r0")
      else do:  #());;;
      let: "$r0" := #true in
      do:  ("found" <-[#boolT] "$r0");;;
      let: "$r0" := (![#sliceT] (struct.field_ref #node #"label"%go (![#ptrT] "n"))) in
      do:  ("foundLabel" <-[#sliceT] "$r0");;;
      let: "$r0" := (![#sliceT] (struct.field_ref #node #"val"%go (![#ptrT] "n"))) in
      do:  ("foundVal" <-[#sliceT] "$r0");;;
      return: (![#boolT] "found", ![#sliceT] "foundLabel", ![#sliceT] "foundVal", ![#sliceT] "proof", ![#boolT] "err")
    else do:  #());;;
    do:  (let: "$a0" := ((![#byteT] (struct.field_ref #node #"nodeTy"%go (![#ptrT] "n"))) = innerNodeTy) in
    (func_call #std.std #"Assert"%go) "$a0");;;
    let: "sib" := (mem.alloc (type.zero_val #ptrT)) in
    let: "child" := (mem.alloc (type.zero_val #ptrT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#ptrT] "n") in
    let: "$a1" := (![#sliceT] "label") in
    let: "$a2" := (![#uint64T] "depth") in
    (func_call #merkle.merkle #"getChild"%go) "$a0" "$a1" "$a2") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("child" <-[#ptrT] "$r0");;;
    do:  ("sib" <-[#ptrT] "$r1");;;
    let: (((("$ret0", "$ret1"), "$ret2"), "$ret3"), "$ret4") := (let: "$a0" := (![#sliceT] "label") in
    let: "$a1" := (![#boolT] "getProof") in
    let: "$a2" := (![#ptrT] (![#ptrT] "child")) in
    let: "$a3" := ((![#uint64T] "depth") + #(W64 1)) in
    (func_call #merkle.merkle #"find"%go) "$a0" "$a1" "$a2" "$a3") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    let: "$r3" := "$ret3" in
    let: "$r4" := "$ret4" in
    do:  ("found" <-[#boolT] "$r0");;;
    do:  ("foundLabel" <-[#sliceT] "$r1");;;
    do:  ("foundVal" <-[#sliceT] "$r2");;;
    do:  ("proof" <-[#sliceT] "$r3");;;
    do:  ("err" <-[#boolT] "$r4");;;
    (if: ![#boolT] "err"
    then return: (![#boolT] "found", ![#sliceT] "foundLabel", ![#sliceT] "foundVal", ![#sliceT] "proof", ![#boolT] "err")
    else do:  #());;;
    (if: ![#boolT] "getProof"
    then
      let: "$r0" := (let: "$a0" := (![#sliceT] "proof") in
      let: "$a1" := (let: "$a0" := (![#ptrT] (![#ptrT] "sib")) in
      (func_call #merkle.merkle #"getNodeHash"%go) "$a0") in
      (slice.append #byteT) "$a0" "$a1") in
      do:  ("proof" <-[#sliceT] "$r0")
    else do:  #());;;
    return: (![#boolT] "found", ![#sliceT] "foundLabel", ![#sliceT] "foundVal", ![#sliceT] "proof", ![#boolT] "err")).

(* go: merkle.go:192:6 *)
Definition getProofLen : val :=
  rec: "getProofLen" "depth" :=
    exception_do (let: "depth" := (mem.alloc "depth") in
    return: ((((((#(W64 8) + ((![#uint64T] "depth") * cryptoffi.HashLen)) + #(W64 1)) + #(W64 8)) + cryptoffi.HashLen) + #(W64 8)) + #(W64 32))).

(* VerifyMemb checks that (label, val) in tree described by proof.

   go: merkle.go:199:6 *)
Definition VerifyMemb : val :=
  rec: "VerifyMemb" "label" "val" "proof" :=
    exception_do (let: "err" := (mem.alloc (type.zero_val #boolT)) in
    let: "dig" := (mem.alloc (type.zero_val #sliceT)) in
    let: "proof" := (mem.alloc "proof") in
    let: "val" := (mem.alloc "val") in
    let: "label" := (mem.alloc "label") in
    let: "tr" := (mem.alloc (type.zero_val #ptrT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "label") in
    let: "$a1" := (![#sliceT] "proof") in
    (func_call #merkle.merkle #"proofToTree"%go) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("tr" <-[#ptrT] "$r0");;;
    do:  ("err" <-[#boolT] "$r1");;;
    (if: ![#boolT] "err"
    then return: (![#sliceT] "dig", ![#boolT] "err")
    else do:  #());;;
    do:  (let: "$a0" := (![#sliceT] "label") in
    let: "$a1" := (![#sliceT] "val") in
    (method_call #merkle.merkle #"Tree'ptr" #"Put" (![#ptrT] "tr")) "$a0" "$a1");;;
    let: "$r0" := ((method_call #merkle.merkle #"Tree'ptr" #"Digest" (![#ptrT] "tr")) #()) in
    do:  ("dig" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "dig", ![#boolT] "err")).

(* VerifyNonMemb checks that label not in tree described by proof.

   go: merkle.go:210:6 *)
Definition VerifyNonMemb : val :=
  rec: "VerifyNonMemb" "label" "proof" :=
    exception_do (let: "err" := (mem.alloc (type.zero_val #boolT)) in
    let: "dig" := (mem.alloc (type.zero_val #sliceT)) in
    let: "proof" := (mem.alloc "proof") in
    let: "label" := (mem.alloc "label") in
    let: "tr" := (mem.alloc (type.zero_val #ptrT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "label") in
    let: "$a1" := (![#sliceT] "proof") in
    (func_call #merkle.merkle #"proofToTree"%go) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("tr" <-[#ptrT] "$r0");;;
    do:  ("err" <-[#boolT] "$r1");;;
    (if: ![#boolT] "err"
    then return: (![#sliceT] "dig", ![#boolT] "err")
    else do:  #());;;
    let: "found" := (mem.alloc (type.zero_val #boolT)) in
    let: ((("$ret0", "$ret1"), "$ret2"), "$ret3") := (let: "$a0" := (![#sliceT] "label") in
    let: "$a1" := #false in
    (method_call #merkle.merkle #"Tree'ptr" #"prove" (![#ptrT] "tr")) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    let: "$r3" := "$ret3" in
    do:  ("found" <-[#boolT] "$r0");;;
    do:  "$r1";;;
    do:  "$r2";;;
    do:  ("err" <-[#boolT] "$r3");;;
    (if: ![#boolT] "err"
    then return: (![#sliceT] "dig", ![#boolT] "err")
    else do:  #());;;
    (if: ![#boolT] "found"
    then
      let: "$r0" := #true in
      do:  ("err" <-[#boolT] "$r0");;;
      return: (![#sliceT] "dig", ![#boolT] "err")
    else do:  #());;;
    let: "$r0" := ((method_call #merkle.merkle #"Tree'ptr" #"Digest" (![#ptrT] "tr")) #()) in
    do:  ("dig" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "dig", ![#boolT] "err")).

(* VerifyUpdate returns the dig for an old tree without label and
   the dig after inserting (label, val).

   go: merkle.go:229:6 *)
Definition VerifyUpdate : val :=
  rec: "VerifyUpdate" "label" "val" "proof" :=
    exception_do (let: "err" := (mem.alloc (type.zero_val #boolT)) in
    let: "newDig" := (mem.alloc (type.zero_val #sliceT)) in
    let: "oldDig" := (mem.alloc (type.zero_val #sliceT)) in
    let: "proof" := (mem.alloc "proof") in
    let: "val" := (mem.alloc "val") in
    let: "label" := (mem.alloc "label") in
    let: "tr" := (mem.alloc (type.zero_val #ptrT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "label") in
    let: "$a1" := (![#sliceT] "proof") in
    (func_call #merkle.merkle #"proofToTree"%go) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("tr" <-[#ptrT] "$r0");;;
    do:  ("err" <-[#boolT] "$r1");;;
    (if: ![#boolT] "err"
    then return: (![#sliceT] "oldDig", ![#sliceT] "newDig", ![#boolT] "err")
    else do:  #());;;
    let: "$r0" := ((method_call #merkle.merkle #"Tree'ptr" #"Digest" (![#ptrT] "tr")) #()) in
    do:  ("oldDig" <-[#sliceT] "$r0");;;
    let: "found" := (mem.alloc (type.zero_val #boolT)) in
    let: ((("$ret0", "$ret1"), "$ret2"), "$ret3") := (let: "$a0" := (![#sliceT] "label") in
    let: "$a1" := #false in
    (method_call #merkle.merkle #"Tree'ptr" #"prove" (![#ptrT] "tr")) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    let: "$r3" := "$ret3" in
    do:  ("found" <-[#boolT] "$r0");;;
    do:  "$r1";;;
    do:  "$r2";;;
    do:  ("err" <-[#boolT] "$r3");;;
    (if: ![#boolT] "err"
    then return: (![#sliceT] "oldDig", ![#sliceT] "newDig", ![#boolT] "err")
    else do:  #());;;
    (if: ![#boolT] "found"
    then
      let: "$r0" := #true in
      do:  ("err" <-[#boolT] "$r0");;;
      return: (![#sliceT] "oldDig", ![#sliceT] "newDig", ![#boolT] "err")
    else do:  #());;;
    (let: "$r0" := (let: "$a0" := (![#sliceT] "label") in
    let: "$a1" := (![#sliceT] "val") in
    (method_call #merkle.merkle #"Tree'ptr" #"Put" (![#ptrT] "tr")) "$a0" "$a1") in
    do:  ("err" <-[#boolT] "$r0");;;
    (if: ![#boolT] "err"
    then return: (![#sliceT] "oldDig", ![#sliceT] "newDig", ![#boolT] "err")
    else do:  #()));;;
    let: "$r0" := ((method_call #merkle.merkle #"Tree'ptr" #"Digest" (![#ptrT] "tr")) #()) in
    do:  ("newDig" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "oldDig", ![#sliceT] "newDig", ![#boolT] "err")).

(* go: merkle.go:252:16 *)
Definition Tree__Digest : val :=
  rec: "Tree__Digest" "t" <> :=
    exception_do (let: "t" := (mem.alloc "t") in
    return: (let: "$a0" := (![#ptrT] (struct.field_ref #Tree #"root"%go (![#ptrT] "t"))) in
     (func_call #merkle.merkle #"getNodeHash"%go) "$a0")).

(* newShell makes a tree shell from sibs, guaranteeing that down label is empty.

   go: merkle.go:257:6 *)
Definition newShell : val :=
  rec: "newShell" "label" "depth" "sibs" :=
    exception_do (let: "n" := (mem.alloc (type.zero_val #ptrT)) in
    let: "sibs" := (mem.alloc "sibs") in
    let: "depth" := (mem.alloc "depth") in
    let: "label" := (mem.alloc "label") in
    let: "sibsLen" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (s_to_w64 (let: "$a0" := (![#sliceT] "sibs") in
    slice.len "$a0")) in
    do:  ("sibsLen" <-[#uint64T] "$r0");;;
    (if: (![#uint64T] "sibsLen") = #(W64 0)
    then return: (![#ptrT] "n")
    else do:  #());;;
    let: "split" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := ((![#uint64T] "sibsLen") - cryptoffi.HashLen) in
    do:  ("split" <-[#uint64T] "$r0");;;
    let: "sibs0" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$s" := (![#sliceT] "sibs") in
    slice.slice #byteT "$s" #(W64 0) (![#uint64T] "split")) in
    do:  ("sibs0" <-[#sliceT] "$r0");;;
    let: "hash" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$s" := (![#sliceT] "sibs") in
    slice.slice #byteT "$s" (![#uint64T] "split") (slice.len "$s")) in
    do:  ("hash" <-[#sliceT] "$r0");;;
    let: "cut" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (let: "$nodeTy" := cutNodeTy in
    let: "$hash" := (![#sliceT] "hash") in
    struct.make #node [{
      "nodeTy" ::= "$nodeTy";
      "hash" ::= "$hash";
      "child0" ::= type.zero_val #ptrT;
      "child1" ::= type.zero_val #ptrT;
      "label" ::= type.zero_val #sliceT;
      "val" ::= type.zero_val #sliceT
    }])) in
    do:  ("cut" <-[#ptrT] "$r0");;;
    let: "inner" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (let: "$nodeTy" := innerNodeTy in
    struct.make #node [{
      "nodeTy" ::= "$nodeTy";
      "hash" ::= type.zero_val #sliceT;
      "child0" ::= type.zero_val #ptrT;
      "child1" ::= type.zero_val #ptrT;
      "label" ::= type.zero_val #sliceT;
      "val" ::= type.zero_val #sliceT
    }])) in
    do:  ("inner" <-[#ptrT] "$r0");;;
    let: "sib" := (mem.alloc (type.zero_val #ptrT)) in
    let: "child" := (mem.alloc (type.zero_val #ptrT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#ptrT] "inner") in
    let: "$a1" := (![#sliceT] "label") in
    let: "$a2" := (![#uint64T] "depth") in
    (func_call #merkle.merkle #"getChild"%go) "$a0" "$a1" "$a2") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("child" <-[#ptrT] "$r0");;;
    do:  ("sib" <-[#ptrT] "$r1");;;
    let: "$r0" := (![#ptrT] "cut") in
    do:  ((![#ptrT] "sib") <-[#ptrT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "label") in
    let: "$a1" := ((![#uint64T] "depth") + #(W64 1)) in
    let: "$a2" := (![#sliceT] "sibs0") in
    (func_call #merkle.merkle #"newShell"%go) "$a0" "$a1" "$a2") in
    do:  ((![#ptrT] "child") <-[#ptrT] "$r0");;;
    do:  (let: "$a0" := (![#ptrT] "inner") in
    (func_call #merkle.merkle #"setInnerHash"%go) "$a0");;;
    return: (![#ptrT] "inner")).

Definition MerkleProof : go_type := structT [
  "Siblings" :: sliceT;
  "IsOtherLeaf" :: boolT;
  "LeafLabel" :: sliceT;
  "LeafVal" :: sliceT
].

(* go: merkle.go:274:6 *)
Definition proofToTree : val :=
  rec: "proofToTree" "label" "proof" :=
    exception_do (let: "err" := (mem.alloc (type.zero_val #boolT)) in
    let: "tr" := (mem.alloc (type.zero_val #ptrT)) in
    let: "proof" := (mem.alloc "proof") in
    let: "label" := (mem.alloc "label") in
    let: "p" := (mem.alloc (type.zero_val #ptrT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "proof") in
    (func_call #merkle.merkle #"MerkleProofDecode"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("p" <-[#ptrT] "$r0");;;
    do:  "$r1";;;
    do:  ("err" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err"
    then return: (![#ptrT] "tr", ![#boolT] "err")
    else do:  #());;;
    (if: ((s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref #MerkleProof #"Siblings"%go (![#ptrT] "p"))) in
    slice.len "$a0")) `rem` cryptoffi.HashLen) ≠ #(W64 0)
    then
      let: "$r0" := #true in
      do:  ("err" <-[#boolT] "$r0");;;
      return: (![#ptrT] "tr", ![#boolT] "err")
    else do:  #());;;
    let: "root" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "label") in
    let: "$a1" := #(W64 0) in
    let: "$a2" := (![#sliceT] (struct.field_ref #MerkleProof #"Siblings"%go (![#ptrT] "p"))) in
    (func_call #merkle.merkle #"newShell"%go) "$a0" "$a1" "$a2") in
    do:  ("root" <-[#ptrT] "$r0");;;
    let: "$r0" := (mem.alloc (let: "$root" := (![#ptrT] "root") in
    struct.make #Tree [{
      "root" ::= "$root"
    }])) in
    do:  ("tr" <-[#ptrT] "$r0");;;
    (if: ![#boolT] (struct.field_ref #MerkleProof #"IsOtherLeaf"%go (![#ptrT] "p"))
    then
      do:  (let: "$a0" := (![#sliceT] (struct.field_ref #MerkleProof #"LeafLabel"%go (![#ptrT] "p"))) in
      let: "$a1" := (![#sliceT] (struct.field_ref #MerkleProof #"LeafVal"%go (![#ptrT] "p"))) in
      (method_call #merkle.merkle #"Tree'ptr" #"Put" (![#ptrT] "tr")) "$a0" "$a1")
    else do:  #());;;
    return: (![#ptrT] "tr", ![#boolT] "err")).

(* go: merkle.go:291:6 *)
Definition getNodeHash : val :=
  rec: "getNodeHash" "n" :=
    exception_do (let: "n" := (mem.alloc "n") in
    (if: (![#ptrT] "n") = #null
    then return: (![#sliceT] (globals.get #merkle.merkle #"emptyHash"%go))
    else do:  #());;;
    return: (![#sliceT] (struct.field_ref #node #"hash"%go (![#ptrT] "n")))).

(* go: merkle.go:298:6 *)
Definition compEmptyHash : val :=
  rec: "compEmptyHash" <> :=
    exception_do (return: (let: "$a0" := ((let: "$sl0" := emptyNodeTag in
     slice.literal #byteT ["$sl0"])) in
     (func_call #cryptoutil.cryptoutil #"Hash"%go) "$a0")).

(* go: merkle.go:302:6 *)
Definition setLeafHash : val :=
  rec: "setLeafHash" "n" :=
    exception_do (let: "n" := (mem.alloc "n") in
    let: "$r0" := (let: "$a0" := (![#sliceT] (struct.field_ref #node #"label"%go (![#ptrT] "n"))) in
    let: "$a1" := (![#sliceT] (struct.field_ref #node #"val"%go (![#ptrT] "n"))) in
    (func_call #merkle.merkle #"compLeafHash"%go) "$a0" "$a1") in
    do:  ((struct.field_ref #node #"hash"%go (![#ptrT] "n")) <-[#sliceT] "$r0");;;
    return: #()).

(* go: merkle.go:306:6 *)
Definition compLeafHash : val :=
  rec: "compLeafHash" "label" "val" :=
    exception_do (let: "val" := (mem.alloc "val") in
    let: "label" := (mem.alloc "label") in
    let: "hr" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := ((func_call #cryptoffi.cryptoffi #"NewHasher"%go) #()) in
    do:  ("hr" <-[#ptrT] "$r0");;;
    do:  (let: "$a0" := ((let: "$sl0" := leafNodeTag in
    slice.literal #byteT ["$sl0"])) in
    (method_call #cryptoffi #"Hasher'ptr" #"Write" (![#ptrT] "hr")) "$a0");;;
    do:  (let: "$a0" := (let: "$a0" := #slice.nil in
    let: "$a1" := (s_to_w64 (let: "$a0" := (![#sliceT] "label") in
    slice.len "$a0")) in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    (method_call #cryptoffi #"Hasher'ptr" #"Write" (![#ptrT] "hr")) "$a0");;;
    do:  (let: "$a0" := (![#sliceT] "label") in
    (method_call #cryptoffi #"Hasher'ptr" #"Write" (![#ptrT] "hr")) "$a0");;;
    do:  (let: "$a0" := (let: "$a0" := #slice.nil in
    let: "$a1" := (s_to_w64 (let: "$a0" := (![#sliceT] "val") in
    slice.len "$a0")) in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    (method_call #cryptoffi #"Hasher'ptr" #"Write" (![#ptrT] "hr")) "$a0");;;
    do:  (let: "$a0" := (![#sliceT] "val") in
    (method_call #cryptoffi #"Hasher'ptr" #"Write" (![#ptrT] "hr")) "$a0");;;
    return: (let: "$a0" := #slice.nil in
     (method_call #cryptoffi #"Hasher'ptr" #"Sum" (![#ptrT] "hr")) "$a0")).

(* go: merkle.go:316:6 *)
Definition setInnerHash : val :=
  rec: "setInnerHash" "n" :=
    exception_do (let: "n" := (mem.alloc "n") in
    let: "child0" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#ptrT] (struct.field_ref #node #"child0"%go (![#ptrT] "n"))) in
    (func_call #merkle.merkle #"getNodeHash"%go) "$a0") in
    do:  ("child0" <-[#sliceT] "$r0");;;
    let: "child1" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#ptrT] (struct.field_ref #node #"child1"%go (![#ptrT] "n"))) in
    (func_call #merkle.merkle #"getNodeHash"%go) "$a0") in
    do:  ("child1" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "child0") in
    let: "$a1" := (![#sliceT] "child1") in
    let: "$a2" := #slice.nil in
    (func_call #merkle.merkle #"compInnerHash"%go) "$a0" "$a1" "$a2") in
    do:  ((struct.field_ref #node #"hash"%go (![#ptrT] "n")) <-[#sliceT] "$r0");;;
    return: #()).

(* go: merkle.go:322:6 *)
Definition compInnerHash : val :=
  rec: "compInnerHash" "child0" "child1" "h" :=
    exception_do (let: "h" := (mem.alloc "h") in
    let: "child1" := (mem.alloc "child1") in
    let: "child0" := (mem.alloc "child0") in
    let: "hr" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := ((func_call #cryptoffi.cryptoffi #"NewHasher"%go) #()) in
    do:  ("hr" <-[#ptrT] "$r0");;;
    do:  (let: "$a0" := ((let: "$sl0" := innerNodeTag in
    slice.literal #byteT ["$sl0"])) in
    (method_call #cryptoffi #"Hasher'ptr" #"Write" (![#ptrT] "hr")) "$a0");;;
    do:  (let: "$a0" := (![#sliceT] "child0") in
    (method_call #cryptoffi #"Hasher'ptr" #"Write" (![#ptrT] "hr")) "$a0");;;
    do:  (let: "$a0" := (![#sliceT] "child1") in
    (method_call #cryptoffi #"Hasher'ptr" #"Write" (![#ptrT] "hr")) "$a0");;;
    return: (let: "$a0" := (![#sliceT] "h") in
     (method_call #cryptoffi #"Hasher'ptr" #"Sum" (![#ptrT] "hr")) "$a0")).

(* getChild returns a child and its sibling child,
   relative to the bit referenced by label and depth.

   go: merkle.go:332:6 *)
Definition getChild : val :=
  rec: "getChild" "n" "label" "depth" :=
    exception_do (let: "depth" := (mem.alloc "depth") in
    let: "label" := (mem.alloc "label") in
    let: "n" := (mem.alloc "n") in
    (if: (~ (let: "$a0" := (![#sliceT] "label") in
    let: "$a1" := (![#uint64T] "depth") in
    (func_call #merkle.merkle #"getBit"%go) "$a0" "$a1"))
    then return: (struct.field_ref #node #"child0"%go (![#ptrT] "n"), struct.field_ref #node #"child1"%go (![#ptrT] "n"))
    else return: (struct.field_ref #node #"child1"%go (![#ptrT] "n"), struct.field_ref #node #"child0"%go (![#ptrT] "n")))).

(* getBit returns false if the nth bit of b is 0.
   if n exceeds b, it returns false.
   this is fine as long as the code consistently treats labels as
   having variable length.

   go: merkle.go:344:6 *)
Definition getBit : val :=
  rec: "getBit" "b" "n" :=
    exception_do (let: "n" := (mem.alloc "n") in
    let: "b" := (mem.alloc "b") in
    let: "slot" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := ((![#uint64T] "n") `quot` #(W64 8)) in
    do:  ("slot" <-[#uint64T] "$r0");;;
    (if: (![#uint64T] "slot") < (s_to_w64 (let: "$a0" := (![#sliceT] "b") in
    slice.len "$a0"))
    then
      let: "off" := (mem.alloc (type.zero_val #uint64T)) in
      let: "$r0" := ((![#uint64T] "n") `rem` #(W64 8)) in
      do:  ("off" <-[#uint64T] "$r0");;;
      let: "x" := (mem.alloc (type.zero_val #byteT)) in
      let: "$r0" := (![#byteT] (slice.elem_ref #byteT (![#sliceT] "b") (![#uint64T] "slot"))) in
      do:  ("x" <-[#byteT] "$r0");;;
      return: (((![#byteT] "x") `and` (#(W8 1) ≪ (u_to_w8 (![#uint64T] "off")))) ≠ #(W8 0))
    else return: (#false))).

(* go: serde.out.go:10:6 *)
Definition MerkleProofEncode : val :=
  rec: "MerkleProofEncode" "b0" "o" :=
    exception_do (let: "o" := (mem.alloc "o") in
    let: "b0" := (mem.alloc "b0") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "b0") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#sliceT] (struct.field_ref #MerkleProof #"Siblings"%go (![#ptrT] "o"))) in
    (func_call #safemarshal.safemarshal #"WriteSlice1D"%go) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#boolT] (struct.field_ref #MerkleProof #"IsOtherLeaf"%go (![#ptrT] "o"))) in
    (func_call #marshal.marshal #"WriteBool"%go) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#sliceT] (struct.field_ref #MerkleProof #"LeafLabel"%go (![#ptrT] "o"))) in
    (func_call #safemarshal.safemarshal #"WriteSlice1D"%go) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#sliceT] (struct.field_ref #MerkleProof #"LeafVal"%go (![#ptrT] "o"))) in
    (func_call #safemarshal.safemarshal #"WriteSlice1D"%go) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "b")).

(* go: serde.out.go:18:6 *)
Definition MerkleProofDecode : val :=
  rec: "MerkleProofDecode" "b0" :=
    exception_do (let: "b0" := (mem.alloc "b0") in
    let: "err1" := (mem.alloc (type.zero_val #boolT)) in
    let: "b1" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a1" := (mem.alloc (type.zero_val #sliceT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b0") in
    (func_call #safemarshal.safemarshal #"ReadSlice1D"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a1" <-[#sliceT] "$r0");;;
    do:  ("b1" <-[#sliceT] "$r1");;;
    do:  ("err1" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err1"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err2" := (mem.alloc (type.zero_val #boolT)) in
    let: "b2" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a2" := (mem.alloc (type.zero_val #boolT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b1") in
    (func_call #safemarshal.safemarshal #"ReadBool"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a2" <-[#boolT] "$r0");;;
    do:  ("b2" <-[#sliceT] "$r1");;;
    do:  ("err2" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err2"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err3" := (mem.alloc (type.zero_val #boolT)) in
    let: "b3" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a3" := (mem.alloc (type.zero_val #sliceT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b2") in
    (func_call #safemarshal.safemarshal #"ReadSlice1D"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a3" <-[#sliceT] "$r0");;;
    do:  ("b3" <-[#sliceT] "$r1");;;
    do:  ("err3" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err3"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err4" := (mem.alloc (type.zero_val #boolT)) in
    let: "b4" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a4" := (mem.alloc (type.zero_val #sliceT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b3") in
    (func_call #safemarshal.safemarshal #"ReadSlice1D"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a4" <-[#sliceT] "$r0");;;
    do:  ("b4" <-[#sliceT] "$r1");;;
    do:  ("err4" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err4"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    return: (mem.alloc (let: "$Siblings" := (![#sliceT] "a1") in
     let: "$IsOtherLeaf" := (![#boolT] "a2") in
     let: "$LeafLabel" := (![#sliceT] "a3") in
     let: "$LeafVal" := (![#sliceT] "a4") in
     struct.make #MerkleProof [{
       "Siblings" ::= "$Siblings";
       "IsOtherLeaf" ::= "$IsOtherLeaf";
       "LeafLabel" ::= "$LeafLabel";
       "LeafVal" ::= "$LeafVal"
     }]), ![#sliceT] "b4", #false)).

Definition vars' : list (go_string * go_type) := [("emptyHash"%go, sliceT)].

Definition functions' : list (go_string * val) := [("put"%go, put); ("find"%go, find); ("getProofLen"%go, getProofLen); ("VerifyMemb"%go, VerifyMemb); ("VerifyNonMemb"%go, VerifyNonMemb); ("VerifyUpdate"%go, VerifyUpdate); ("newShell"%go, newShell); ("proofToTree"%go, proofToTree); ("getNodeHash"%go, getNodeHash); ("compEmptyHash"%go, compEmptyHash); ("setLeafHash"%go, setLeafHash); ("compLeafHash"%go, compLeafHash); ("setInnerHash"%go, setInnerHash); ("compInnerHash"%go, compInnerHash); ("getChild"%go, getChild); ("getBit"%go, getBit); ("MerkleProofEncode"%go, MerkleProofEncode); ("MerkleProofDecode"%go, MerkleProofDecode)].

Definition msets' : list (go_string * (list (go_string * val))) := [("Tree"%go, []); ("Tree'ptr"%go, [("Digest"%go, Tree__Digest); ("Get"%go, Tree__Get); ("Prove"%go, Tree__Prove); ("Put"%go, Tree__Put); ("prove"%go, Tree__prove)]); ("node"%go, []); ("node'ptr"%go, []); ("MerkleProof"%go, []); ("MerkleProof'ptr"%go, [])].

#[global] Instance info' : PkgInfo merkle.merkle :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [primitive.primitive; std.std; cryptoffi.cryptoffi; cryptoutil.cryptoutil; marshal.marshal; safemarshal.safemarshal];
  |}.

Definition initialize' : val :=
  rec: "initialize'" <> :=
    globals.package_init merkle.merkle (λ: <>,
      exception_do (do:  safemarshal.initialize';;;
      do:  marshal.initialize';;;
      do:  cryptoutil.initialize';;;
      do:  cryptoffi.initialize';;;
      do:  std.initialize';;;
      do:  primitive.initialize';;;
      let: "$r0" := ((func_call #merkle.merkle #"compEmptyHash"%go) #()) in
      do:  ((globals.get #merkle.merkle #"emptyHash"%go) <-[#sliceT] "$r0"))
      ).

End code.
End merkle.
