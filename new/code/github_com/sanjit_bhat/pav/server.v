(* autogenerated from github.com/sanjit-bhat/pav/server *)
Require Export New.code.github_com.sanjit_bhat.pav.advrpc.
Require Export New.code.github_com.sanjit_bhat.pav.ktcore.
Require Export New.code.github_com.sanjit_bhat.pav.safemarshal.
Require Export New.code.github_com.tchajed.marshal.
Require Export New.code.sync.
Require Export New.code.time.
Require Export New.code.github_com.goose_lang.std.
Require Export New.code.github_com.sanjit_bhat.pav.cryptoffi.
Require Export New.code.github_com.sanjit_bhat.pav.hashchain.
Require Export New.code.github_com.sanjit_bhat.pav.merkle.
From New.golang Require Import defn.
Module pkg_id.
Definition server : go_string := "github.com/sanjit-bhat/pav/server".

End pkg_id.
Export pkg_id.
Module server.

Definition StartChain {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/sanjit-bhat/pav/server.StartChain"%go [].

Definition StartVrf {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/sanjit-bhat/pav/server.StartVrf"%go [].

Definition StartReply {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/sanjit-bhat/pav/server.StartReply"%go [].

Definition PutArg {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/sanjit-bhat/pav/server.PutArg"%go [].

Definition HistoryArg {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/sanjit-bhat/pav/server.HistoryArg"%go [].

Definition HistoryReply {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/sanjit-bhat/pav/server.HistoryReply"%go [].

Definition AuditArg {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/sanjit-bhat/pav/server.AuditArg"%go [].

Definition AuditReply {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/sanjit-bhat/pav/server.AuditReply"%go [].

Definition Server {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/sanjit-bhat/pav/server.Server"%go [].

Definition secrets {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/sanjit-bhat/pav/server.secrets"%go [].

Definition keyStore {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/sanjit-bhat/pav/server.keyStore"%go [].

Definition history {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/sanjit-bhat/pav/server.history"%go [].

Definition Work {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/sanjit-bhat/pav/server.Work"%go [].

Definition mapEntry {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/sanjit-bhat/pav/server.mapEntry"%go [].

Definition StartRpc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 0).

Definition PutRpc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 1).

Definition HistoryRpc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 2).

Definition AuditRpc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 3).

Definition WorkQSize {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/sanjit-bhat/pav/server.WorkQSize"%go.

Definition BatchSize {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/sanjit-bhat/pav/server.BatchSize"%go.

Definition BatchTimeout {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/sanjit-bhat/pav/server.BatchTimeout"%go.

Definition NewRpcServer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/sanjit-bhat/pav/server.NewRpcServer"%go.

Definition CallStart {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/sanjit-bhat/pav/server.CallStart"%go.

Definition CallPut {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/sanjit-bhat/pav/server.CallPut"%go.

Definition CallHistory {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/sanjit-bhat/pav/server.CallHistory"%go.

Definition CallAudit {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/sanjit-bhat/pav/server.CallAudit"%go.

Definition StartChainEncode {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/sanjit-bhat/pav/server.StartChainEncode"%go.

Definition StartChainDecode {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/sanjit-bhat/pav/server.StartChainDecode"%go.

Definition StartVrfEncode {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/sanjit-bhat/pav/server.StartVrfEncode"%go.

Definition StartVrfDecode {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/sanjit-bhat/pav/server.StartVrfDecode"%go.

Definition StartReplyEncode {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/sanjit-bhat/pav/server.StartReplyEncode"%go.

Definition StartReplyDecode {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/sanjit-bhat/pav/server.StartReplyDecode"%go.

Definition PutArgEncode {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/sanjit-bhat/pav/server.PutArgEncode"%go.

Definition PutArgDecode {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/sanjit-bhat/pav/server.PutArgDecode"%go.

Definition HistoryArgEncode {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/sanjit-bhat/pav/server.HistoryArgEncode"%go.

Definition HistoryArgDecode {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/sanjit-bhat/pav/server.HistoryArgDecode"%go.

Definition HistoryReplyEncode {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/sanjit-bhat/pav/server.HistoryReplyEncode"%go.

Definition HistoryReplyDecode {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/sanjit-bhat/pav/server.HistoryReplyDecode"%go.

Definition AuditArgEncode {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/sanjit-bhat/pav/server.AuditArgEncode"%go.

Definition AuditArgDecode {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/sanjit-bhat/pav/server.AuditArgDecode"%go.

Definition AuditReplyEncode {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/sanjit-bhat/pav/server.AuditReplyEncode"%go.

Definition AuditReplyDecode {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/sanjit-bhat/pav/server.AuditReplyDecode"%go.

Definition getWork {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/sanjit-bhat/pav/server.getWork"%go.

Definition New {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/sanjit-bhat/pav/server.New"%go.

(* go: rpc.go:15:6 *)
Definition NewRpcServerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s",
    exception_do (let: "s" := (GoAlloc (go.PointerType Server) "s") in
    let: "h" := (GoAlloc (go.MapType go.uint64 (go.FunctionType (go.Signature [go.SliceType go.byte; go.PointerType (go.SliceType go.byte)] false []))) (GoZeroVal (go.MapType go.uint64 (go.FunctionType (go.Signature [go.SliceType go.byte; go.PointerType (go.SliceType go.byte)] false []))) #())) in
    let: "$r0" := ((FuncResolve go.make1 [go.MapType go.uint64 (go.FunctionType (go.Signature [go.SliceType go.byte; go.PointerType (go.SliceType go.byte)] false []))] #()) #()) in
    do:  ("h" <-[go.MapType go.uint64 (go.FunctionType (go.Signature [go.SliceType go.byte; go.PointerType (go.SliceType go.byte)] false []))] "$r0");;;
    let: "$r0" := (λ: "arg" "reply",
      exception_do (let: "reply" := (GoAlloc (go.PointerType (go.SliceType go.byte)) "reply") in
      let: "arg" := (GoAlloc (go.SliceType go.byte) "arg") in
      let: "r1" := (GoAlloc (go.PointerType StartVrf) (GoZeroVal (go.PointerType StartVrf) #())) in
      let: "r0" := (GoAlloc (go.PointerType StartChain) (GoZeroVal (go.PointerType StartChain) #())) in
      let: ("$ret0", "$ret1") := ((MethodResolve (go.PointerType Server) "Start"%go (![go.PointerType Server] "s")) #()) in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("r0" <-[go.PointerType StartChain] "$r0");;;
      do:  ("r1" <-[go.PointerType StartVrf] "$r1");;;
      let: "r" := (GoAlloc (go.PointerType StartReply) (GoZeroVal (go.PointerType StartReply) #())) in
      let: "$r0" := (GoAlloc StartReply (CompositeLiteral StartReply (LiteralValue [KeyedElement (Some (KeyField "Chain"%go)) (ElementExpression (go.PointerType StartChain) (![go.PointerType StartChain] "r0")); KeyedElement (Some (KeyField "Vrf"%go)) (ElementExpression (go.PointerType StartVrf) (![go.PointerType StartVrf] "r1"))]))) in
      do:  ("r" <-[go.PointerType StartReply] "$r0");;;
      let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] (![go.PointerType (go.SliceType go.byte)] "reply")) in
      let: "$a1" := (![go.PointerType StartReply] "r") in
      (FuncResolve StartReplyEncode [] #()) "$a0" "$a1") in
      do:  ((![go.PointerType (go.SliceType go.byte)] "reply") <-[go.SliceType go.byte] "$r0");;;
      return: #())
      ) in
    do:  (map.insert go.uint64 (![go.MapType go.uint64 (go.FunctionType (go.Signature [go.SliceType go.byte; go.PointerType (go.SliceType go.byte)] false []))] "h") StartRpc "$r0");;;
    let: "$r0" := (λ: "arg" "reply",
      exception_do (let: "reply" := (GoAlloc (go.PointerType (go.SliceType go.byte)) "reply") in
      let: "arg" := (GoAlloc (go.SliceType go.byte) "arg") in
      let: "err" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
      let: "a" := (GoAlloc (go.PointerType PutArg) (GoZeroVal (go.PointerType PutArg) #())) in
      let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "arg") in
      (FuncResolve PutArgDecode [] #()) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      let: "$r2" := "$ret2" in
      do:  ("a" <-[go.PointerType PutArg] "$r0");;;
      do:  "$r1";;;
      do:  ("err" <-[go.bool] "$r2");;;
      (if: ![go.bool] "err"
      then return: (#())
      else do:  #());;;
      do:  (let: "$a0" := (![go.uint64] (StructFieldRef PutArg "Uid"%go (![go.PointerType PutArg] "a"))) in
      let: "$a1" := (![go.SliceType go.byte] (StructFieldRef PutArg "Pk"%go (![go.PointerType PutArg] "a"))) in
      let: "$a2" := (![go.uint64] (StructFieldRef PutArg "Ver"%go (![go.PointerType PutArg] "a"))) in
      (MethodResolve (go.PointerType Server) "Put"%go (![go.PointerType Server] "s")) "$a0" "$a1" "$a2");;;
      let: "$r0" := (Convert go.untyped_nil (go.SliceType go.byte) UntypedNil) in
      do:  ((![go.PointerType (go.SliceType go.byte)] "reply") <-[go.SliceType go.byte] "$r0");;;
      return: #())
      ) in
    do:  (map.insert go.uint64 (![go.MapType go.uint64 (go.FunctionType (go.Signature [go.SliceType go.byte; go.PointerType (go.SliceType go.byte)] false []))] "h") PutRpc "$r0");;;
    let: "$r0" := (λ: "arg" "reply",
      exception_do (let: "reply" := (GoAlloc (go.PointerType (go.SliceType go.byte)) "reply") in
      let: "arg" := (GoAlloc (go.SliceType go.byte) "arg") in
      let: "err" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
      let: "a" := (GoAlloc (go.PointerType HistoryArg) (GoZeroVal (go.PointerType HistoryArg) #())) in
      let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "arg") in
      (FuncResolve HistoryArgDecode [] #()) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      let: "$r2" := "$ret2" in
      do:  ("a" <-[go.PointerType HistoryArg] "$r0");;;
      do:  "$r1";;;
      do:  ("err" <-[go.bool] "$r2");;;
      (if: ![go.bool] "err"
      then
        let: "r" := (GoAlloc (go.PointerType HistoryReply) (GoZeroVal (go.PointerType HistoryReply) #())) in
        let: "$r0" := (GoAlloc HistoryReply (CompositeLiteral HistoryReply (LiteralValue [KeyedElement (Some (KeyField "Err"%go)) (ElementExpression go.bool #true)]))) in
        do:  ("r" <-[go.PointerType HistoryReply] "$r0");;;
        let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] (![go.PointerType (go.SliceType go.byte)] "reply")) in
        let: "$a1" := (![go.PointerType HistoryReply] "r") in
        (FuncResolve HistoryReplyEncode [] #()) "$a0" "$a1") in
        do:  ((![go.PointerType (go.SliceType go.byte)] "reply") <-[go.SliceType go.byte] "$r0");;;
        return: (#())
      else do:  #());;;
      let: "r4" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
      let: "r3" := (GoAlloc (go.PointerType ktcore.NonMemb) (GoZeroVal (go.PointerType ktcore.NonMemb) #())) in
      let: "r2" := (GoAlloc (go.SliceType (go.PointerType ktcore.Memb)) (GoZeroVal (go.SliceType (go.PointerType ktcore.Memb)) #())) in
      let: "r1" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
      let: "r0" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
      let: (((("$ret0", "$ret1"), "$ret2"), "$ret3"), "$ret4") := (let: "$a0" := (![go.uint64] (StructFieldRef HistoryArg "Uid"%go (![go.PointerType HistoryArg] "a"))) in
      let: "$a1" := (![go.uint64] (StructFieldRef HistoryArg "PrevEpoch"%go (![go.PointerType HistoryArg] "a"))) in
      let: "$a2" := (![go.uint64] (StructFieldRef HistoryArg "PrevVerLen"%go (![go.PointerType HistoryArg] "a"))) in
      (MethodResolve (go.PointerType Server) "History"%go (![go.PointerType Server] "s")) "$a0" "$a1" "$a2") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      let: "$r2" := "$ret2" in
      let: "$r3" := "$ret3" in
      let: "$r4" := "$ret4" in
      do:  ("r0" <-[go.SliceType go.byte] "$r0");;;
      do:  ("r1" <-[go.SliceType go.byte] "$r1");;;
      do:  ("r2" <-[go.SliceType (go.PointerType ktcore.Memb)] "$r2");;;
      do:  ("r3" <-[go.PointerType ktcore.NonMemb] "$r3");;;
      do:  ("r4" <-[go.bool] "$r4");;;
      let: "r" := (GoAlloc (go.PointerType HistoryReply) (GoZeroVal (go.PointerType HistoryReply) #())) in
      let: "$r0" := (GoAlloc HistoryReply (CompositeLiteral HistoryReply (LiteralValue [KeyedElement (Some (KeyField "ChainProof"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] "r0")); KeyedElement (Some (KeyField "LinkSig"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] "r1")); KeyedElement (Some (KeyField "Hist"%go)) (ElementExpression (go.SliceType (go.PointerType ktcore.Memb)) (![go.SliceType (go.PointerType ktcore.Memb)] "r2")); KeyedElement (Some (KeyField "Bound"%go)) (ElementExpression (go.PointerType ktcore.NonMemb) (![go.PointerType ktcore.NonMemb] "r3")); KeyedElement (Some (KeyField "Err"%go)) (ElementExpression go.bool (![go.bool] "r4"))]))) in
      do:  ("r" <-[go.PointerType HistoryReply] "$r0");;;
      let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] (![go.PointerType (go.SliceType go.byte)] "reply")) in
      let: "$a1" := (![go.PointerType HistoryReply] "r") in
      (FuncResolve HistoryReplyEncode [] #()) "$a0" "$a1") in
      do:  ((![go.PointerType (go.SliceType go.byte)] "reply") <-[go.SliceType go.byte] "$r0");;;
      return: #())
      ) in
    do:  (map.insert go.uint64 (![go.MapType go.uint64 (go.FunctionType (go.Signature [go.SliceType go.byte; go.PointerType (go.SliceType go.byte)] false []))] "h") HistoryRpc "$r0");;;
    let: "$r0" := (λ: "arg" "reply",
      exception_do (let: "reply" := (GoAlloc (go.PointerType (go.SliceType go.byte)) "reply") in
      let: "arg" := (GoAlloc (go.SliceType go.byte) "arg") in
      let: "err" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
      let: "a" := (GoAlloc (go.PointerType AuditArg) (GoZeroVal (go.PointerType AuditArg) #())) in
      let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "arg") in
      (FuncResolve AuditArgDecode [] #()) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      let: "$r2" := "$ret2" in
      do:  ("a" <-[go.PointerType AuditArg] "$r0");;;
      do:  "$r1";;;
      do:  ("err" <-[go.bool] "$r2");;;
      (if: ![go.bool] "err"
      then
        let: "r" := (GoAlloc (go.PointerType AuditReply) (GoZeroVal (go.PointerType AuditReply) #())) in
        let: "$r0" := (GoAlloc AuditReply (CompositeLiteral AuditReply (LiteralValue [KeyedElement (Some (KeyField "Err"%go)) (ElementExpression go.bool #true)]))) in
        do:  ("r" <-[go.PointerType AuditReply] "$r0");;;
        let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] (![go.PointerType (go.SliceType go.byte)] "reply")) in
        let: "$a1" := (![go.PointerType AuditReply] "r") in
        (FuncResolve AuditReplyEncode [] #()) "$a0" "$a1") in
        do:  ((![go.PointerType (go.SliceType go.byte)] "reply") <-[go.SliceType go.byte] "$r0");;;
        return: (#())
      else do:  #());;;
      let: "r1" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
      let: "r0" := (GoAlloc (go.SliceType (go.PointerType ktcore.AuditProof)) (GoZeroVal (go.SliceType (go.PointerType ktcore.AuditProof)) #())) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![go.uint64] (StructFieldRef AuditArg "PrevEpoch"%go (![go.PointerType AuditArg] "a"))) in
      (MethodResolve (go.PointerType Server) "Audit"%go (![go.PointerType Server] "s")) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("r0" <-[go.SliceType (go.PointerType ktcore.AuditProof)] "$r0");;;
      do:  ("r1" <-[go.bool] "$r1");;;
      let: "r" := (GoAlloc (go.PointerType AuditReply) (GoZeroVal (go.PointerType AuditReply) #())) in
      let: "$r0" := (GoAlloc AuditReply (CompositeLiteral AuditReply (LiteralValue [KeyedElement (Some (KeyField "P"%go)) (ElementExpression (go.SliceType (go.PointerType ktcore.AuditProof)) (![go.SliceType (go.PointerType ktcore.AuditProof)] "r0")); KeyedElement (Some (KeyField "Err"%go)) (ElementExpression go.bool (![go.bool] "r1"))]))) in
      do:  ("r" <-[go.PointerType AuditReply] "$r0");;;
      let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] (![go.PointerType (go.SliceType go.byte)] "reply")) in
      let: "$a1" := (![go.PointerType AuditReply] "r") in
      (FuncResolve AuditReplyEncode [] #()) "$a0" "$a1") in
      do:  ((![go.PointerType (go.SliceType go.byte)] "reply") <-[go.SliceType go.byte] "$r0");;;
      return: #())
      ) in
    do:  (map.insert go.uint64 (![go.MapType go.uint64 (go.FunctionType (go.Signature [go.SliceType go.byte; go.PointerType (go.SliceType go.byte)] false []))] "h") AuditRpc "$r0");;;
    return: (let: "$a0" := (![go.MapType go.uint64 (go.FunctionType (go.Signature [go.SliceType go.byte; go.PointerType (go.SliceType go.byte)] false []))] "h") in
     (FuncResolve advrpc.NewServer [] #()) "$a0")).

(* go: rpc.go:56:6 *)
Definition CallStartⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "c",
    exception_do (let: "err" := (GoAlloc ktcore.Blame (GoZeroVal ktcore.Blame #())) in
    let: "vrf" := (GoAlloc (go.PointerType StartVrf) (GoZeroVal (go.PointerType StartVrf) #())) in
    let: "chain" := (GoAlloc (go.PointerType StartChain) (GoZeroVal (go.PointerType StartChain) #())) in
    let: "c" := (GoAlloc (go.PointerType advrpc.Client) "c") in
    let: "rb" := (GoAlloc (go.PointerType (go.SliceType go.byte)) (GoZeroVal (go.PointerType (go.SliceType go.byte)) #())) in
    let: "$r0" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    do:  ("rb" <-[go.PointerType (go.SliceType go.byte)] "$r0");;;
    (if: let: "$a0" := StartRpc in
    let: "$a1" := (Convert go.untyped_nil (go.SliceType go.byte) UntypedNil) in
    let: "$a2" := (![go.PointerType (go.SliceType go.byte)] "rb") in
    (MethodResolve (go.PointerType advrpc.Client) "Call"%go (![go.PointerType advrpc.Client] "c")) "$a0" "$a1" "$a2"
    then
      let: "$r0" := ktcore.BlameUnknown in
      do:  ("err" <-[ktcore.Blame] "$r0");;;
      return: (![go.PointerType StartChain] "chain", ![go.PointerType StartVrf] "vrf", ![ktcore.Blame] "err")
    else do:  #());;;
    let: "errb" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "r" := (GoAlloc (go.PointerType StartReply) (GoZeroVal (go.PointerType StartReply) #())) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] (![go.PointerType (go.SliceType go.byte)] "rb")) in
    (FuncResolve StartReplyDecode [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("r" <-[go.PointerType StartReply] "$r0");;;
    do:  "$r1";;;
    do:  ("errb" <-[go.bool] "$r2");;;
    let: "$r0" := (![go.PointerType StartChain] (StructFieldRef StartReply "Chain"%go (![go.PointerType StartReply] "r"))) in
    do:  ("chain" <-[go.PointerType StartChain] "$r0");;;
    let: "$r0" := (![go.PointerType StartVrf] (StructFieldRef StartReply "Vrf"%go (![go.PointerType StartReply] "r"))) in
    do:  ("vrf" <-[go.PointerType StartVrf] "$r0");;;
    (if: ![go.bool] "errb"
    then
      let: "$r0" := ktcore.BlameServFull in
      do:  ("err" <-[ktcore.Blame] "$r0");;;
      return: (![go.PointerType StartChain] "chain", ![go.PointerType StartVrf] "vrf", ![ktcore.Blame] "err")
    else do:  #());;;
    return: (![go.PointerType StartChain] "chain", ![go.PointerType StartVrf] "vrf", ![ktcore.Blame] "err")).

(* go: rpc.go:72:6 *)
Definition CallPutⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "c" "uid" "pk" "ver",
    exception_do (let: "ver" := (GoAlloc go.uint64 "ver") in
    let: "pk" := (GoAlloc (go.SliceType go.byte) "pk") in
    let: "uid" := (GoAlloc go.uint64 "uid") in
    let: "c" := (GoAlloc (go.PointerType advrpc.Client) "c") in
    let: "a" := (GoAlloc (go.PointerType PutArg) (GoZeroVal (go.PointerType PutArg) #())) in
    let: "$r0" := (GoAlloc PutArg (CompositeLiteral PutArg (LiteralValue [KeyedElement (Some (KeyField "Uid"%go)) (ElementExpression go.uint64 (![go.uint64] "uid")); KeyedElement (Some (KeyField "Pk"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] "pk")); KeyedElement (Some (KeyField "Ver"%go)) (ElementExpression go.uint64 (![go.uint64] "ver"))]))) in
    do:  ("a" <-[go.PointerType PutArg] "$r0");;;
    let: "ab" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (let: "$a0" := (Convert go.untyped_nil (go.SliceType go.byte) UntypedNil) in
    let: "$a1" := (![go.PointerType PutArg] "a") in
    (FuncResolve PutArgEncode [] #()) "$a0" "$a1") in
    do:  ("ab" <-[go.SliceType go.byte] "$r0");;;
    let: "rb" := (GoAlloc (go.PointerType (go.SliceType go.byte)) (GoZeroVal (go.PointerType (go.SliceType go.byte)) #())) in
    let: "$r0" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    do:  ("rb" <-[go.PointerType (go.SliceType go.byte)] "$r0");;;
    do:  (let: "$a0" := PutRpc in
    let: "$a1" := (![go.SliceType go.byte] "ab") in
    let: "$a2" := (![go.PointerType (go.SliceType go.byte)] "rb") in
    (MethodResolve (go.PointerType advrpc.Client) "Call"%go (![go.PointerType advrpc.Client] "c")) "$a0" "$a1" "$a2");;;
    return: #()).

(* go: rpc.go:80:6 *)
Definition CallHistoryⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "c" "uid" "prevEpoch" "prevVerLen",
    exception_do (let: "err" := (GoAlloc ktcore.Blame (GoZeroVal ktcore.Blame #())) in
    let: "bound" := (GoAlloc (go.PointerType ktcore.NonMemb) (GoZeroVal (go.PointerType ktcore.NonMemb) #())) in
    let: "hist" := (GoAlloc (go.SliceType (go.PointerType ktcore.Memb)) (GoZeroVal (go.SliceType (go.PointerType ktcore.Memb)) #())) in
    let: "linkSig" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "chainProof" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "prevVerLen" := (GoAlloc go.uint64 "prevVerLen") in
    let: "prevEpoch" := (GoAlloc go.uint64 "prevEpoch") in
    let: "uid" := (GoAlloc go.uint64 "uid") in
    let: "c" := (GoAlloc (go.PointerType advrpc.Client) "c") in
    let: "a" := (GoAlloc (go.PointerType HistoryArg) (GoZeroVal (go.PointerType HistoryArg) #())) in
    let: "$r0" := (GoAlloc HistoryArg (CompositeLiteral HistoryArg (LiteralValue [KeyedElement (Some (KeyField "Uid"%go)) (ElementExpression go.uint64 (![go.uint64] "uid")); KeyedElement (Some (KeyField "PrevEpoch"%go)) (ElementExpression go.uint64 (![go.uint64] "prevEpoch")); KeyedElement (Some (KeyField "PrevVerLen"%go)) (ElementExpression go.uint64 (![go.uint64] "prevVerLen"))]))) in
    do:  ("a" <-[go.PointerType HistoryArg] "$r0");;;
    let: "ab" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (let: "$a0" := (Convert go.untyped_nil (go.SliceType go.byte) UntypedNil) in
    let: "$a1" := (![go.PointerType HistoryArg] "a") in
    (FuncResolve HistoryArgEncode [] #()) "$a0" "$a1") in
    do:  ("ab" <-[go.SliceType go.byte] "$r0");;;
    let: "rb" := (GoAlloc (go.PointerType (go.SliceType go.byte)) (GoZeroVal (go.PointerType (go.SliceType go.byte)) #())) in
    let: "$r0" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    do:  ("rb" <-[go.PointerType (go.SliceType go.byte)] "$r0");;;
    (if: let: "$a0" := HistoryRpc in
    let: "$a1" := (![go.SliceType go.byte] "ab") in
    let: "$a2" := (![go.PointerType (go.SliceType go.byte)] "rb") in
    (MethodResolve (go.PointerType advrpc.Client) "Call"%go (![go.PointerType advrpc.Client] "c")) "$a0" "$a1" "$a2"
    then
      let: "$r0" := ktcore.BlameUnknown in
      do:  ("err" <-[ktcore.Blame] "$r0");;;
      return: (![go.SliceType go.byte] "chainProof", ![go.SliceType go.byte] "linkSig", ![go.SliceType (go.PointerType ktcore.Memb)] "hist", ![go.PointerType ktcore.NonMemb] "bound", ![ktcore.Blame] "err")
    else do:  #());;;
    let: "errb" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "r" := (GoAlloc (go.PointerType HistoryReply) (GoZeroVal (go.PointerType HistoryReply) #())) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] (![go.PointerType (go.SliceType go.byte)] "rb")) in
    (FuncResolve HistoryReplyDecode [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("r" <-[go.PointerType HistoryReply] "$r0");;;
    do:  "$r1";;;
    do:  ("errb" <-[go.bool] "$r2");;;
    (if: ![go.bool] "errb"
    then
      let: "$r0" := ktcore.BlameServFull in
      do:  ("err" <-[ktcore.Blame] "$r0");;;
      return: (![go.SliceType go.byte] "chainProof", ![go.SliceType go.byte] "linkSig", ![go.SliceType (go.PointerType ktcore.Memb)] "hist", ![go.PointerType ktcore.NonMemb] "bound", ![ktcore.Blame] "err")
    else do:  #());;;
    (if: ![go.bool] (StructFieldRef HistoryReply "Err"%go (![go.PointerType HistoryReply] "r"))
    then
      let: "$r0" := ktcore.BlameServFull in
      do:  ("err" <-[ktcore.Blame] "$r0");;;
      return: (![go.SliceType go.byte] "chainProof", ![go.SliceType go.byte] "linkSig", ![go.SliceType (go.PointerType ktcore.Memb)] "hist", ![go.PointerType ktcore.NonMemb] "bound", ![ktcore.Blame] "err")
    else do:  #());;;
    return: (![go.SliceType go.byte] (StructFieldRef HistoryReply "ChainProof"%go (![go.PointerType HistoryReply] "r")), ![go.SliceType go.byte] (StructFieldRef HistoryReply "LinkSig"%go (![go.PointerType HistoryReply] "r")), ![go.SliceType (go.PointerType ktcore.Memb)] (StructFieldRef HistoryReply "Hist"%go (![go.PointerType HistoryReply] "r")), ![go.PointerType ktcore.NonMemb] (StructFieldRef HistoryReply "Bound"%go (![go.PointerType HistoryReply] "r")), ktcore.BlameNone)).

(* go: rpc.go:100:6 *)
Definition CallAuditⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "c" "prevEpoch",
    exception_do (let: "err" := (GoAlloc ktcore.Blame (GoZeroVal ktcore.Blame #())) in
    let: "p" := (GoAlloc (go.SliceType (go.PointerType ktcore.AuditProof)) (GoZeroVal (go.SliceType (go.PointerType ktcore.AuditProof)) #())) in
    let: "prevEpoch" := (GoAlloc go.uint64 "prevEpoch") in
    let: "c" := (GoAlloc (go.PointerType advrpc.Client) "c") in
    let: "a" := (GoAlloc (go.PointerType AuditArg) (GoZeroVal (go.PointerType AuditArg) #())) in
    let: "$r0" := (GoAlloc AuditArg (CompositeLiteral AuditArg (LiteralValue [KeyedElement (Some (KeyField "PrevEpoch"%go)) (ElementExpression go.uint64 (![go.uint64] "prevEpoch"))]))) in
    do:  ("a" <-[go.PointerType AuditArg] "$r0");;;
    let: "ab" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (let: "$a0" := (Convert go.untyped_nil (go.SliceType go.byte) UntypedNil) in
    let: "$a1" := (![go.PointerType AuditArg] "a") in
    (FuncResolve AuditArgEncode [] #()) "$a0" "$a1") in
    do:  ("ab" <-[go.SliceType go.byte] "$r0");;;
    let: "rb" := (GoAlloc (go.PointerType (go.SliceType go.byte)) (GoZeroVal (go.PointerType (go.SliceType go.byte)) #())) in
    let: "$r0" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    do:  ("rb" <-[go.PointerType (go.SliceType go.byte)] "$r0");;;
    (if: let: "$a0" := AuditRpc in
    let: "$a1" := (![go.SliceType go.byte] "ab") in
    let: "$a2" := (![go.PointerType (go.SliceType go.byte)] "rb") in
    (MethodResolve (go.PointerType advrpc.Client) "Call"%go (![go.PointerType advrpc.Client] "c")) "$a0" "$a1" "$a2"
    then
      let: "$r0" := ktcore.BlameUnknown in
      do:  ("err" <-[ktcore.Blame] "$r0");;;
      return: (![go.SliceType (go.PointerType ktcore.AuditProof)] "p", ![ktcore.Blame] "err")
    else do:  #());;;
    let: "errb" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "r" := (GoAlloc (go.PointerType AuditReply) (GoZeroVal (go.PointerType AuditReply) #())) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] (![go.PointerType (go.SliceType go.byte)] "rb")) in
    (FuncResolve AuditReplyDecode [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("r" <-[go.PointerType AuditReply] "$r0");;;
    do:  "$r1";;;
    do:  ("errb" <-[go.bool] "$r2");;;
    (if: ![go.bool] "errb"
    then
      let: "$r0" := ktcore.BlameServFull in
      do:  ("err" <-[ktcore.Blame] "$r0");;;
      return: (![go.SliceType (go.PointerType ktcore.AuditProof)] "p", ![ktcore.Blame] "err")
    else do:  #());;;
    (if: ![go.bool] (StructFieldRef AuditReply "Err"%go (![go.PointerType AuditReply] "r"))
    then
      let: "$r0" := ktcore.BlameServFull in
      do:  ("err" <-[ktcore.Blame] "$r0");;;
      return: (![go.SliceType (go.PointerType ktcore.AuditProof)] "p", ![ktcore.Blame] "err")
    else do:  #());;;
    return: (![go.SliceType (go.PointerType ktcore.AuditProof)] (StructFieldRef AuditReply "P"%go (![go.PointerType AuditReply] "r")), ktcore.BlameNone)).

(* go: serde.out.go:9:6 *)
Definition StartChainEncodeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "b0" "o",
    exception_do (let: "o" := (GoAlloc (go.PointerType StartChain) "o") in
    let: "b0" := (GoAlloc (go.SliceType go.byte) "b0") in
    let: "b" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (![go.SliceType go.byte] "b0") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (![go.uint64] (StructFieldRef StartChain "PrevEpochLen"%go (![go.PointerType StartChain] "o"))) in
    (FuncResolve marshal.WriteInt [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (![go.SliceType go.byte] (StructFieldRef StartChain "PrevLink"%go (![go.PointerType StartChain] "o"))) in
    (FuncResolve safemarshal.WriteSlice1D [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (![go.SliceType go.byte] (StructFieldRef StartChain "ChainProof"%go (![go.PointerType StartChain] "o"))) in
    (FuncResolve safemarshal.WriteSlice1D [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (![go.SliceType go.byte] (StructFieldRef StartChain "LinkSig"%go (![go.PointerType StartChain] "o"))) in
    (FuncResolve safemarshal.WriteSlice1D [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    return: (![go.SliceType go.byte] "b")).

(* go: serde.out.go:17:6 *)
Definition StartChainDecodeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "b0",
    exception_do (let: "b0" := (GoAlloc (go.SliceType go.byte) "b0") in
    let: "err1" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "b1" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "a1" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "b0") in
    (FuncResolve safemarshal.ReadInt [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a1" <-[go.uint64] "$r0");;;
    do:  ("b1" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err1" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err1"
    then return: (Convert go.untyped_nil (go.PointerType StartChain) UntypedNil, Convert go.untyped_nil (go.SliceType go.byte) UntypedNil, #true)
    else do:  #());;;
    let: "err2" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "b2" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "a2" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "b1") in
    (FuncResolve safemarshal.ReadSlice1D [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a2" <-[go.SliceType go.byte] "$r0");;;
    do:  ("b2" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err2" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err2"
    then return: (Convert go.untyped_nil (go.PointerType StartChain) UntypedNil, Convert go.untyped_nil (go.SliceType go.byte) UntypedNil, #true)
    else do:  #());;;
    let: "err3" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "b3" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "a3" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "b2") in
    (FuncResolve safemarshal.ReadSlice1D [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a3" <-[go.SliceType go.byte] "$r0");;;
    do:  ("b3" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err3" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err3"
    then return: (Convert go.untyped_nil (go.PointerType StartChain) UntypedNil, Convert go.untyped_nil (go.SliceType go.byte) UntypedNil, #true)
    else do:  #());;;
    let: "err4" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "b4" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "a4" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "b3") in
    (FuncResolve safemarshal.ReadSlice1D [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a4" <-[go.SliceType go.byte] "$r0");;;
    do:  ("b4" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err4" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err4"
    then return: (Convert go.untyped_nil (go.PointerType StartChain) UntypedNil, Convert go.untyped_nil (go.SliceType go.byte) UntypedNil, #true)
    else do:  #());;;
    return: (GoAlloc StartChain (CompositeLiteral StartChain (LiteralValue [KeyedElement (Some (KeyField "PrevEpochLen"%go)) (ElementExpression go.uint64 (![go.uint64] "a1")); KeyedElement (Some (KeyField "PrevLink"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] "a2")); KeyedElement (Some (KeyField "ChainProof"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] "a3")); KeyedElement (Some (KeyField "LinkSig"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] "a4"))])), ![go.SliceType go.byte] "b4", #false)).

(* go: serde.out.go:36:6 *)
Definition StartVrfEncodeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "b0" "o",
    exception_do (let: "o" := (GoAlloc (go.PointerType StartVrf) "o") in
    let: "b0" := (GoAlloc (go.SliceType go.byte) "b0") in
    let: "b" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (![go.SliceType go.byte] "b0") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (![go.SliceType go.byte] (StructFieldRef StartVrf "VrfPk"%go (![go.PointerType StartVrf] "o"))) in
    (FuncResolve safemarshal.WriteSlice1D [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (![go.SliceType go.byte] (StructFieldRef StartVrf "VrfSig"%go (![go.PointerType StartVrf] "o"))) in
    (FuncResolve safemarshal.WriteSlice1D [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    return: (![go.SliceType go.byte] "b")).

(* go: serde.out.go:42:6 *)
Definition StartVrfDecodeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "b0",
    exception_do (let: "b0" := (GoAlloc (go.SliceType go.byte) "b0") in
    let: "err1" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "b1" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "a1" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "b0") in
    (FuncResolve safemarshal.ReadSlice1D [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a1" <-[go.SliceType go.byte] "$r0");;;
    do:  ("b1" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err1" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err1"
    then return: (Convert go.untyped_nil (go.PointerType StartVrf) UntypedNil, Convert go.untyped_nil (go.SliceType go.byte) UntypedNil, #true)
    else do:  #());;;
    let: "err2" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "b2" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "a2" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "b1") in
    (FuncResolve safemarshal.ReadSlice1D [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a2" <-[go.SliceType go.byte] "$r0");;;
    do:  ("b2" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err2" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err2"
    then return: (Convert go.untyped_nil (go.PointerType StartVrf) UntypedNil, Convert go.untyped_nil (go.SliceType go.byte) UntypedNil, #true)
    else do:  #());;;
    return: (GoAlloc StartVrf (CompositeLiteral StartVrf (LiteralValue [KeyedElement (Some (KeyField "VrfPk"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] "a1")); KeyedElement (Some (KeyField "VrfSig"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] "a2"))])), ![go.SliceType go.byte] "b2", #false)).

(* go: serde.out.go:53:6 *)
Definition StartReplyEncodeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "b0" "o",
    exception_do (let: "o" := (GoAlloc (go.PointerType StartReply) "o") in
    let: "b0" := (GoAlloc (go.SliceType go.byte) "b0") in
    let: "b" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (![go.SliceType go.byte] "b0") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (![go.PointerType StartChain] (StructFieldRef StartReply "Chain"%go (![go.PointerType StartReply] "o"))) in
    (FuncResolve StartChainEncode [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (![go.PointerType StartVrf] (StructFieldRef StartReply "Vrf"%go (![go.PointerType StartReply] "o"))) in
    (FuncResolve StartVrfEncode [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    return: (![go.SliceType go.byte] "b")).

(* go: serde.out.go:59:6 *)
Definition StartReplyDecodeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "b0",
    exception_do (let: "b0" := (GoAlloc (go.SliceType go.byte) "b0") in
    let: "err1" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "b1" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "a1" := (GoAlloc (go.PointerType StartChain) (GoZeroVal (go.PointerType StartChain) #())) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "b0") in
    (FuncResolve StartChainDecode [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a1" <-[go.PointerType StartChain] "$r0");;;
    do:  ("b1" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err1" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err1"
    then return: (Convert go.untyped_nil (go.PointerType StartReply) UntypedNil, Convert go.untyped_nil (go.SliceType go.byte) UntypedNil, #true)
    else do:  #());;;
    let: "err2" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "b2" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "a2" := (GoAlloc (go.PointerType StartVrf) (GoZeroVal (go.PointerType StartVrf) #())) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "b1") in
    (FuncResolve StartVrfDecode [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a2" <-[go.PointerType StartVrf] "$r0");;;
    do:  ("b2" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err2" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err2"
    then return: (Convert go.untyped_nil (go.PointerType StartReply) UntypedNil, Convert go.untyped_nil (go.SliceType go.byte) UntypedNil, #true)
    else do:  #());;;
    return: (GoAlloc StartReply (CompositeLiteral StartReply (LiteralValue [KeyedElement (Some (KeyField "Chain"%go)) (ElementExpression (go.PointerType StartChain) (![go.PointerType StartChain] "a1")); KeyedElement (Some (KeyField "Vrf"%go)) (ElementExpression (go.PointerType StartVrf) (![go.PointerType StartVrf] "a2"))])), ![go.SliceType go.byte] "b2", #false)).

(* go: serde.out.go:70:6 *)
Definition PutArgEncodeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "b0" "o",
    exception_do (let: "o" := (GoAlloc (go.PointerType PutArg) "o") in
    let: "b0" := (GoAlloc (go.SliceType go.byte) "b0") in
    let: "b" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (![go.SliceType go.byte] "b0") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (![go.uint64] (StructFieldRef PutArg "Uid"%go (![go.PointerType PutArg] "o"))) in
    (FuncResolve marshal.WriteInt [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (![go.SliceType go.byte] (StructFieldRef PutArg "Pk"%go (![go.PointerType PutArg] "o"))) in
    (FuncResolve safemarshal.WriteSlice1D [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (![go.uint64] (StructFieldRef PutArg "Ver"%go (![go.PointerType PutArg] "o"))) in
    (FuncResolve marshal.WriteInt [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    return: (![go.SliceType go.byte] "b")).

(* go: serde.out.go:77:6 *)
Definition PutArgDecodeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "b0",
    exception_do (let: "b0" := (GoAlloc (go.SliceType go.byte) "b0") in
    let: "err1" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "b1" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "a1" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "b0") in
    (FuncResolve safemarshal.ReadInt [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a1" <-[go.uint64] "$r0");;;
    do:  ("b1" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err1" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err1"
    then return: (Convert go.untyped_nil (go.PointerType PutArg) UntypedNil, Convert go.untyped_nil (go.SliceType go.byte) UntypedNil, #true)
    else do:  #());;;
    let: "err2" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "b2" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "a2" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "b1") in
    (FuncResolve safemarshal.ReadSlice1D [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a2" <-[go.SliceType go.byte] "$r0");;;
    do:  ("b2" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err2" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err2"
    then return: (Convert go.untyped_nil (go.PointerType PutArg) UntypedNil, Convert go.untyped_nil (go.SliceType go.byte) UntypedNil, #true)
    else do:  #());;;
    let: "err3" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "b3" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "a3" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "b2") in
    (FuncResolve safemarshal.ReadInt [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a3" <-[go.uint64] "$r0");;;
    do:  ("b3" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err3" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err3"
    then return: (Convert go.untyped_nil (go.PointerType PutArg) UntypedNil, Convert go.untyped_nil (go.SliceType go.byte) UntypedNil, #true)
    else do:  #());;;
    return: (GoAlloc PutArg (CompositeLiteral PutArg (LiteralValue [KeyedElement (Some (KeyField "Uid"%go)) (ElementExpression go.uint64 (![go.uint64] "a1")); KeyedElement (Some (KeyField "Pk"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] "a2")); KeyedElement (Some (KeyField "Ver"%go)) (ElementExpression go.uint64 (![go.uint64] "a3"))])), ![go.SliceType go.byte] "b3", #false)).

(* go: serde.out.go:92:6 *)
Definition HistoryArgEncodeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "b0" "o",
    exception_do (let: "o" := (GoAlloc (go.PointerType HistoryArg) "o") in
    let: "b0" := (GoAlloc (go.SliceType go.byte) "b0") in
    let: "b" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (![go.SliceType go.byte] "b0") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (![go.uint64] (StructFieldRef HistoryArg "Uid"%go (![go.PointerType HistoryArg] "o"))) in
    (FuncResolve marshal.WriteInt [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (![go.uint64] (StructFieldRef HistoryArg "PrevEpoch"%go (![go.PointerType HistoryArg] "o"))) in
    (FuncResolve marshal.WriteInt [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (![go.uint64] (StructFieldRef HistoryArg "PrevVerLen"%go (![go.PointerType HistoryArg] "o"))) in
    (FuncResolve marshal.WriteInt [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    return: (![go.SliceType go.byte] "b")).

(* go: serde.out.go:99:6 *)
Definition HistoryArgDecodeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "b0",
    exception_do (let: "b0" := (GoAlloc (go.SliceType go.byte) "b0") in
    let: "err1" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "b1" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "a1" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "b0") in
    (FuncResolve safemarshal.ReadInt [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a1" <-[go.uint64] "$r0");;;
    do:  ("b1" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err1" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err1"
    then return: (Convert go.untyped_nil (go.PointerType HistoryArg) UntypedNil, Convert go.untyped_nil (go.SliceType go.byte) UntypedNil, #true)
    else do:  #());;;
    let: "err2" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "b2" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "a2" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "b1") in
    (FuncResolve safemarshal.ReadInt [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a2" <-[go.uint64] "$r0");;;
    do:  ("b2" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err2" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err2"
    then return: (Convert go.untyped_nil (go.PointerType HistoryArg) UntypedNil, Convert go.untyped_nil (go.SliceType go.byte) UntypedNil, #true)
    else do:  #());;;
    let: "err3" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "b3" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "a3" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "b2") in
    (FuncResolve safemarshal.ReadInt [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a3" <-[go.uint64] "$r0");;;
    do:  ("b3" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err3" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err3"
    then return: (Convert go.untyped_nil (go.PointerType HistoryArg) UntypedNil, Convert go.untyped_nil (go.SliceType go.byte) UntypedNil, #true)
    else do:  #());;;
    return: (GoAlloc HistoryArg (CompositeLiteral HistoryArg (LiteralValue [KeyedElement (Some (KeyField "Uid"%go)) (ElementExpression go.uint64 (![go.uint64] "a1")); KeyedElement (Some (KeyField "PrevEpoch"%go)) (ElementExpression go.uint64 (![go.uint64] "a2")); KeyedElement (Some (KeyField "PrevVerLen"%go)) (ElementExpression go.uint64 (![go.uint64] "a3"))])), ![go.SliceType go.byte] "b3", #false)).

(* go: serde.out.go:114:6 *)
Definition HistoryReplyEncodeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "b0" "o",
    exception_do (let: "o" := (GoAlloc (go.PointerType HistoryReply) "o") in
    let: "b0" := (GoAlloc (go.SliceType go.byte) "b0") in
    let: "b" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (![go.SliceType go.byte] "b0") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (![go.SliceType go.byte] (StructFieldRef HistoryReply "ChainProof"%go (![go.PointerType HistoryReply] "o"))) in
    (FuncResolve safemarshal.WriteSlice1D [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (![go.SliceType go.byte] (StructFieldRef HistoryReply "LinkSig"%go (![go.PointerType HistoryReply] "o"))) in
    (FuncResolve safemarshal.WriteSlice1D [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (![go.SliceType (go.PointerType ktcore.Memb)] (StructFieldRef HistoryReply "Hist"%go (![go.PointerType HistoryReply] "o"))) in
    (FuncResolve ktcore.MembSlice1DEncode [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (![go.PointerType ktcore.NonMemb] (StructFieldRef HistoryReply "Bound"%go (![go.PointerType HistoryReply] "o"))) in
    (FuncResolve ktcore.NonMembEncode [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (![go.bool] (StructFieldRef HistoryReply "Err"%go (![go.PointerType HistoryReply] "o"))) in
    (FuncResolve marshal.WriteBool [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    return: (![go.SliceType go.byte] "b")).

(* go: serde.out.go:123:6 *)
Definition HistoryReplyDecodeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "b0",
    exception_do (let: "b0" := (GoAlloc (go.SliceType go.byte) "b0") in
    let: "err1" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "b1" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "a1" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "b0") in
    (FuncResolve safemarshal.ReadSlice1D [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a1" <-[go.SliceType go.byte] "$r0");;;
    do:  ("b1" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err1" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err1"
    then return: (Convert go.untyped_nil (go.PointerType HistoryReply) UntypedNil, Convert go.untyped_nil (go.SliceType go.byte) UntypedNil, #true)
    else do:  #());;;
    let: "err2" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "b2" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "a2" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "b1") in
    (FuncResolve safemarshal.ReadSlice1D [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a2" <-[go.SliceType go.byte] "$r0");;;
    do:  ("b2" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err2" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err2"
    then return: (Convert go.untyped_nil (go.PointerType HistoryReply) UntypedNil, Convert go.untyped_nil (go.SliceType go.byte) UntypedNil, #true)
    else do:  #());;;
    let: "err3" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "b3" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "a3" := (GoAlloc (go.SliceType (go.PointerType ktcore.Memb)) (GoZeroVal (go.SliceType (go.PointerType ktcore.Memb)) #())) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "b2") in
    (FuncResolve ktcore.MembSlice1DDecode [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a3" <-[go.SliceType (go.PointerType ktcore.Memb)] "$r0");;;
    do:  ("b3" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err3" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err3"
    then return: (Convert go.untyped_nil (go.PointerType HistoryReply) UntypedNil, Convert go.untyped_nil (go.SliceType go.byte) UntypedNil, #true)
    else do:  #());;;
    let: "err4" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "b4" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "a4" := (GoAlloc (go.PointerType ktcore.NonMemb) (GoZeroVal (go.PointerType ktcore.NonMemb) #())) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "b3") in
    (FuncResolve ktcore.NonMembDecode [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a4" <-[go.PointerType ktcore.NonMemb] "$r0");;;
    do:  ("b4" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err4" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err4"
    then return: (Convert go.untyped_nil (go.PointerType HistoryReply) UntypedNil, Convert go.untyped_nil (go.SliceType go.byte) UntypedNil, #true)
    else do:  #());;;
    let: "err5" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "b5" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "a5" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "b4") in
    (FuncResolve safemarshal.ReadBool [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a5" <-[go.bool] "$r0");;;
    do:  ("b5" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err5" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err5"
    then return: (Convert go.untyped_nil (go.PointerType HistoryReply) UntypedNil, Convert go.untyped_nil (go.SliceType go.byte) UntypedNil, #true)
    else do:  #());;;
    return: (GoAlloc HistoryReply (CompositeLiteral HistoryReply (LiteralValue [KeyedElement (Some (KeyField "ChainProof"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] "a1")); KeyedElement (Some (KeyField "LinkSig"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] "a2")); KeyedElement (Some (KeyField "Hist"%go)) (ElementExpression (go.SliceType (go.PointerType ktcore.Memb)) (![go.SliceType (go.PointerType ktcore.Memb)] "a3")); KeyedElement (Some (KeyField "Bound"%go)) (ElementExpression (go.PointerType ktcore.NonMemb) (![go.PointerType ktcore.NonMemb] "a4")); KeyedElement (Some (KeyField "Err"%go)) (ElementExpression go.bool (![go.bool] "a5"))])), ![go.SliceType go.byte] "b5", #false)).

(* go: serde.out.go:146:6 *)
Definition AuditArgEncodeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "b0" "o",
    exception_do (let: "o" := (GoAlloc (go.PointerType AuditArg) "o") in
    let: "b0" := (GoAlloc (go.SliceType go.byte) "b0") in
    let: "b" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (![go.SliceType go.byte] "b0") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (![go.uint64] (StructFieldRef AuditArg "PrevEpoch"%go (![go.PointerType AuditArg] "o"))) in
    (FuncResolve marshal.WriteInt [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    return: (![go.SliceType go.byte] "b")).

(* go: serde.out.go:151:6 *)
Definition AuditArgDecodeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "b0",
    exception_do (let: "b0" := (GoAlloc (go.SliceType go.byte) "b0") in
    let: "err1" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "b1" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "a1" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "b0") in
    (FuncResolve safemarshal.ReadInt [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a1" <-[go.uint64] "$r0");;;
    do:  ("b1" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err1" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err1"
    then return: (Convert go.untyped_nil (go.PointerType AuditArg) UntypedNil, Convert go.untyped_nil (go.SliceType go.byte) UntypedNil, #true)
    else do:  #());;;
    return: (GoAlloc AuditArg (CompositeLiteral AuditArg (LiteralValue [KeyedElement (Some (KeyField "PrevEpoch"%go)) (ElementExpression go.uint64 (![go.uint64] "a1"))])), ![go.SliceType go.byte] "b1", #false)).

(* go: serde.out.go:158:6 *)
Definition AuditReplyEncodeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "b0" "o",
    exception_do (let: "o" := (GoAlloc (go.PointerType AuditReply) "o") in
    let: "b0" := (GoAlloc (go.SliceType go.byte) "b0") in
    let: "b" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (![go.SliceType go.byte] "b0") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (![go.SliceType (go.PointerType ktcore.AuditProof)] (StructFieldRef AuditReply "P"%go (![go.PointerType AuditReply] "o"))) in
    (FuncResolve ktcore.AuditProofSlice1DEncode [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (![go.bool] (StructFieldRef AuditReply "Err"%go (![go.PointerType AuditReply] "o"))) in
    (FuncResolve marshal.WriteBool [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    return: (![go.SliceType go.byte] "b")).

(* go: serde.out.go:164:6 *)
Definition AuditReplyDecodeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "b0",
    exception_do (let: "b0" := (GoAlloc (go.SliceType go.byte) "b0") in
    let: "err1" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "b1" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "a1" := (GoAlloc (go.SliceType (go.PointerType ktcore.AuditProof)) (GoZeroVal (go.SliceType (go.PointerType ktcore.AuditProof)) #())) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "b0") in
    (FuncResolve ktcore.AuditProofSlice1DDecode [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a1" <-[go.SliceType (go.PointerType ktcore.AuditProof)] "$r0");;;
    do:  ("b1" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err1" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err1"
    then return: (Convert go.untyped_nil (go.PointerType AuditReply) UntypedNil, Convert go.untyped_nil (go.SliceType go.byte) UntypedNil, #true)
    else do:  #());;;
    let: "err2" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "b2" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "a2" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "b1") in
    (FuncResolve safemarshal.ReadBool [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a2" <-[go.bool] "$r0");;;
    do:  ("b2" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err2" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err2"
    then return: (Convert go.untyped_nil (go.PointerType AuditReply) UntypedNil, Convert go.untyped_nil (go.SliceType go.byte) UntypedNil, #true)
    else do:  #());;;
    return: (GoAlloc AuditReply (CompositeLiteral AuditReply (LiteralValue [KeyedElement (Some (KeyField "P"%go)) (ElementExpression (go.SliceType (go.PointerType ktcore.AuditProof)) (![go.SliceType (go.PointerType ktcore.AuditProof)] "a1")); KeyedElement (Some (KeyField "Err"%go)) (ElementExpression go.bool (![go.bool] "a2"))])), ![go.SliceType go.byte] "b2", #false)).

(* Start bootstraps a party with knowledge of the last hash
   in the hashchain and vrf.

   go: server.go:57:18 *)
Definition Server__Startⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" <>,
    with_defer: (let: "vrf" := (GoAlloc (go.PointerType StartVrf) (GoZeroVal (go.PointerType StartVrf) #())) in
    let: "chain" := (GoAlloc (go.PointerType StartChain) (GoZeroVal (go.PointerType StartChain) #())) in
    let: "s" := (GoAlloc (go.PointerType Server) "s") in
    do:  ((MethodResolve (go.PointerType sync.RWMutex) "RLock"%go (![go.PointerType sync.RWMutex] (StructFieldRef Server "mu"%go (![go.PointerType Server] "s")))) #());;;
    do:  (let: "$f" := (MethodResolve (go.PointerType sync.RWMutex) "RUnlock"%go (![go.PointerType sync.RWMutex] (StructFieldRef Server "mu"%go (![go.PointerType Server] "s")))) in
    "$defer" <-[deferType] (let: "$oldf" := (![deferType] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    let: "predLen" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := ((Convert go.int go.uint64 (let: "$a0" := (![go.SliceType (go.PointerType ktcore.AuditProof)] (StructFieldRef history "audits"%go (![go.PointerType history] (StructFieldRef Server "hist"%go (![go.PointerType Server] "s"))))) in
    (FuncResolve go.len [go.SliceType (go.PointerType ktcore.AuditProof)] #()) "$a0")) -⟨go.uint64⟩ #(W64 1)) in
    do:  ("predLen" <-[go.uint64] "$r0");;;
    let: "proof" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "predLink" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: ("$ret0", "$ret1") := ((MethodResolve (go.PointerType hashchain.HashChain) "Bootstrap"%go (![go.PointerType hashchain.HashChain] (StructFieldRef history "chain"%go (![go.PointerType history] (StructFieldRef Server "hist"%go (![go.PointerType Server] "s")))))) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("predLink" <-[go.SliceType go.byte] "$r0");;;
    do:  ("proof" <-[go.SliceType go.byte] "$r1");;;
    let: "lastSig" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (![go.SliceType go.byte] (StructFieldRef ktcore.AuditProof "LinkSig"%go (![go.PointerType ktcore.AuditProof] (IndexRef (go.SliceType (go.PointerType ktcore.AuditProof)) (![go.SliceType (go.PointerType ktcore.AuditProof)] (StructFieldRef history "audits"%go (![go.PointerType history] (StructFieldRef Server "hist"%go (![go.PointerType Server] "s")))), Convert go.uint64 go.int (![go.uint64] "predLen")))))) in
    do:  ("lastSig" <-[go.SliceType go.byte] "$r0");;;
    let: "pk" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := ((MethodResolve (go.PointerType cryptoffi.VrfPrivateKey) "PublicKey"%go (![go.PointerType cryptoffi.VrfPrivateKey] (StructFieldRef secrets "vrf"%go (![go.PointerType secrets] (StructFieldRef Server "secs"%go (![go.PointerType Server] "s")))))) #()) in
    do:  ("pk" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (GoAlloc StartChain (CompositeLiteral StartChain (LiteralValue [KeyedElement (Some (KeyField "PrevEpochLen"%go)) (ElementExpression go.uint64 (![go.uint64] "predLen")); KeyedElement (Some (KeyField "PrevLink"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] "predLink")); KeyedElement (Some (KeyField "ChainProof"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] "proof")); KeyedElement (Some (KeyField "LinkSig"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] "lastSig"))]))) in
    do:  ("chain" <-[go.PointerType StartChain] "$r0");;;
    let: "$r0" := (GoAlloc StartVrf (CompositeLiteral StartVrf (LiteralValue [KeyedElement (Some (KeyField "VrfPk"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] "pk")); KeyedElement (Some (KeyField "VrfSig"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] (StructFieldRef history "vrfPkSig"%go (![go.PointerType history] (StructFieldRef Server "hist"%go (![go.PointerType Server] "s"))))))]))) in
    do:  ("vrf" <-[go.PointerType StartVrf] "$r0");;;
    return: (![go.PointerType StartChain] "chain", ![go.PointerType StartVrf] "vrf")).

(* Put queues pk (at the specified version) for insertion.

   go: server.go:70:18 *)
Definition Server__Putⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" "uid" "pk" "ver",
    exception_do (let: "s" := (GoAlloc (go.PointerType Server) "s") in
    let: "ver" := (GoAlloc go.uint64 "ver") in
    let: "pk" := (GoAlloc (go.SliceType go.byte) "pk") in
    let: "uid" := (GoAlloc go.uint64 "uid") in
    do:  (let: "$chan" := (![go.ChannelType go.sendrecv (go.PointerType Work)] (StructFieldRef Server "workQ"%go (![go.PointerType Server] "s"))) in
    let: "$v" := (GoAlloc Work (CompositeLiteral Work (LiteralValue [KeyedElement (Some (KeyField "Uid"%go)) (ElementExpression go.uint64 (![go.uint64] "uid")); KeyedElement (Some (KeyField "Pk"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] "pk")); KeyedElement (Some (KeyField "Ver"%go)) (ElementExpression go.uint64 (![go.uint64] "ver"))]))) in
    chan.send (go.PointerType Work) "$chan" "$v");;;
    return: #()).

(* History gives key history for uid, excluding first prevVerLen versions.
   the caller already saw prevEpoch.

   go: server.go:76:18 *)
Definition Server__Historyⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" "uid" "prevEpoch" "prevVerLen",
    with_defer: (let: "err" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "bound" := (GoAlloc (go.PointerType ktcore.NonMemb) (GoZeroVal (go.PointerType ktcore.NonMemb) #())) in
    let: "hist" := (GoAlloc (go.SliceType (go.PointerType ktcore.Memb)) (GoZeroVal (go.SliceType (go.PointerType ktcore.Memb)) #())) in
    let: "linkSig" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "chainProof" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "s" := (GoAlloc (go.PointerType Server) "s") in
    let: "prevVerLen" := (GoAlloc go.uint64 "prevVerLen") in
    let: "prevEpoch" := (GoAlloc go.uint64 "prevEpoch") in
    let: "uid" := (GoAlloc go.uint64 "uid") in
    do:  ((MethodResolve (go.PointerType sync.RWMutex) "RLock"%go (![go.PointerType sync.RWMutex] (StructFieldRef Server "mu"%go (![go.PointerType Server] "s")))) #());;;
    do:  (let: "$f" := (MethodResolve (go.PointerType sync.RWMutex) "RUnlock"%go (![go.PointerType sync.RWMutex] (StructFieldRef Server "mu"%go (![go.PointerType Server] "s")))) in
    "$defer" <-[deferType] (let: "$oldf" := (![deferType] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    let: "numEps" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (Convert go.int go.uint64 (let: "$a0" := (![go.SliceType (go.PointerType ktcore.AuditProof)] (StructFieldRef history "audits"%go (![go.PointerType history] (StructFieldRef Server "hist"%go (![go.PointerType Server] "s"))))) in
    (FuncResolve go.len [go.SliceType (go.PointerType ktcore.AuditProof)] #()) "$a0")) in
    do:  ("numEps" <-[go.uint64] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "prevEpoch") ≥⟨go.uint64⟩ (![go.uint64] "numEps"))
    then
      let: "$r0" := #true in
      do:  ("err" <-[go.bool] "$r0");;;
      return: (![go.SliceType go.byte] "chainProof", ![go.SliceType go.byte] "linkSig", ![go.SliceType (go.PointerType ktcore.Memb)] "hist", ![go.PointerType ktcore.NonMemb] "bound", ![go.bool] "err")
    else do:  #());;;
    let: "numVers" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (Convert go.int go.uint64 (let: "$a0" := (map.lookup1 go.uint64 (go.SliceType (go.SliceType go.byte)) (![go.MapType go.uint64 (go.SliceType (go.SliceType go.byte))] (StructFieldRef keyStore "plain"%go (![go.PointerType keyStore] (StructFieldRef Server "keys"%go (![go.PointerType Server] "s"))))) (![go.uint64] "uid")) in
    (FuncResolve go.len [go.SliceType (go.SliceType go.byte)] #()) "$a0")) in
    do:  ("numVers" <-[go.uint64] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "prevVerLen") >⟨go.uint64⟩ (![go.uint64] "numVers"))
    then
      let: "$r0" := #true in
      do:  ("err" <-[go.bool] "$r0");;;
      return: (![go.SliceType go.byte] "chainProof", ![go.SliceType go.byte] "linkSig", ![go.SliceType (go.PointerType ktcore.Memb)] "hist", ![go.PointerType ktcore.NonMemb] "bound", ![go.bool] "err")
    else do:  #());;;
    let: "$r0" := (let: "$a0" := ((![go.uint64] "prevEpoch") +⟨go.uint64⟩ #(W64 1)) in
    (MethodResolve (go.PointerType hashchain.HashChain) "Prove"%go (![go.PointerType hashchain.HashChain] (StructFieldRef history "chain"%go (![go.PointerType history] (StructFieldRef Server "hist"%go (![go.PointerType Server] "s")))))) "$a0") in
    do:  ("chainProof" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (![go.SliceType go.byte] (StructFieldRef ktcore.AuditProof "LinkSig"%go (![go.PointerType ktcore.AuditProof] (IndexRef (go.SliceType (go.PointerType ktcore.AuditProof)) (![go.SliceType (go.PointerType ktcore.AuditProof)] (StructFieldRef history "audits"%go (![go.PointerType history] (StructFieldRef Server "hist"%go (![go.PointerType Server] "s")))), (let: "$a0" := (![go.SliceType (go.PointerType ktcore.AuditProof)] (StructFieldRef history "audits"%go (![go.PointerType history] (StructFieldRef Server "hist"%go (![go.PointerType Server] "s"))))) in
     (FuncResolve go.len [go.SliceType (go.PointerType ktcore.AuditProof)] #()) "$a0") -⟨go.int⟩ #(W64 1)))))) in
    do:  ("linkSig" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.uint64] "uid") in
    let: "$a1" := (![go.uint64] "prevVerLen") in
    (MethodResolve (go.PointerType Server) "getHist"%go (![go.PointerType Server] "s")) "$a0" "$a1") in
    do:  ("hist" <-[go.SliceType (go.PointerType ktcore.Memb)] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.uint64] "uid") in
    let: "$a1" := (![go.uint64] "numVers") in
    (MethodResolve (go.PointerType Server) "getBound"%go (![go.PointerType Server] "s")) "$a0" "$a1") in
    do:  ("bound" <-[go.PointerType ktcore.NonMemb] "$r0");;;
    return: (![go.SliceType go.byte] "chainProof", ![go.SliceType go.byte] "linkSig", ![go.SliceType (go.PointerType ktcore.Memb)] "hist", ![go.PointerType ktcore.NonMemb] "bound", ![go.bool] "err")).

(* Audit errors if args out of bounds.

   go: server.go:98:18 *)
Definition Server__Auditⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" "prevEpoch",
    with_defer: (let: "err" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "proof" := (GoAlloc (go.SliceType (go.PointerType ktcore.AuditProof)) (GoZeroVal (go.SliceType (go.PointerType ktcore.AuditProof)) #())) in
    let: "s" := (GoAlloc (go.PointerType Server) "s") in
    let: "prevEpoch" := (GoAlloc go.uint64 "prevEpoch") in
    do:  ((MethodResolve (go.PointerType sync.RWMutex) "RLock"%go (![go.PointerType sync.RWMutex] (StructFieldRef Server "mu"%go (![go.PointerType Server] "s")))) #());;;
    do:  (let: "$f" := (MethodResolve (go.PointerType sync.RWMutex) "RUnlock"%go (![go.PointerType sync.RWMutex] (StructFieldRef Server "mu"%go (![go.PointerType Server] "s")))) in
    "$defer" <-[deferType] (let: "$oldf" := (![deferType] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    let: "numEps" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (Convert go.int go.uint64 (let: "$a0" := (![go.SliceType (go.PointerType ktcore.AuditProof)] (StructFieldRef history "audits"%go (![go.PointerType history] (StructFieldRef Server "hist"%go (![go.PointerType Server] "s"))))) in
    (FuncResolve go.len [go.SliceType (go.PointerType ktcore.AuditProof)] #()) "$a0")) in
    do:  ("numEps" <-[go.uint64] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "prevEpoch") ≥⟨go.uint64⟩ (![go.uint64] "numEps"))
    then
      let: "$r0" := #true in
      do:  ("err" <-[go.bool] "$r0");;;
      return: (![go.SliceType (go.PointerType ktcore.AuditProof)] "proof", ![go.bool] "err")
    else do:  #());;;
    let: "$r0" := (let: "$a0" := (![go.SliceType (go.PointerType ktcore.AuditProof)] "proof") in
    let: "$a1" := (let: "$s" := (![go.SliceType (go.PointerType ktcore.AuditProof)] (StructFieldRef history "audits"%go (![go.PointerType history] (StructFieldRef Server "hist"%go (![go.PointerType Server] "s"))))) in
    Slice (go.SliceType (go.PointerType ktcore.AuditProof)) ("$s", (![go.uint64] "prevEpoch") +⟨go.uint64⟩ #(W64 1), FuncResolve go.len [go.SliceType (go.PointerType ktcore.AuditProof)] #() (![go.SliceType (go.PointerType ktcore.AuditProof)] (StructFieldRef history "audits"%go (![go.PointerType history] (StructFieldRef Server "hist"%go (![go.PointerType Server] "s"))))))) in
    (FuncResolve go.append [go.SliceType (go.PointerType ktcore.AuditProof)] #()) "$a0" "$a1") in
    do:  ("proof" <-[go.SliceType (go.PointerType ktcore.AuditProof)] "$r0");;;
    return: (![go.SliceType (go.PointerType ktcore.AuditProof)] "proof", ![go.bool] "err")).

(* go: server.go:122:18 *)
Definition Server__workerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" <>,
    exception_do (let: "s" := (GoAlloc (go.PointerType Server) "s") in
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "work" := (GoAlloc (go.SliceType (go.PointerType Work)) (GoZeroVal (go.SliceType (go.PointerType Work)) #())) in
      let: "$r0" := (let: "$a0" := (Convert (go.ChannelType go.sendrecv (go.PointerType Work)) (go.ChannelType go.recvonly (go.PointerType Work)) (![go.ChannelType go.sendrecv (go.PointerType Work)] (StructFieldRef Server "workQ"%go (![go.PointerType Server] "s")))) in
      (FuncResolve getWork [] #()) "$a0") in
      do:  ("work" <-[go.SliceType (go.PointerType Work)] "$r0");;;
      (if: Convert go.untyped_bool go.bool ((let: "$a0" := (![go.SliceType (go.PointerType Work)] "work") in
      (FuncResolve go.len [go.SliceType (go.PointerType Work)] #()) "$a0") =⟨go.int⟩ #(W64 0))
      then continue: #()
      else do:  #());;;
      do:  (let: "$a0" := (![go.SliceType (go.PointerType Work)] "work") in
      (MethodResolve (go.PointerType Server) "doWork"%go (![go.PointerType Server] "s")) "$a0"));;;
    return: #()).

(* go: server.go:132:6 *)
Definition getWorkⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "workQ",
    exception_do (let: "work" := (GoAlloc (go.SliceType (go.PointerType Work)) (GoZeroVal (go.SliceType (go.PointerType Work)) #())) in
    let: "workQ" := (GoAlloc (go.ChannelType go.recvonly (go.PointerType Work)) "workQ") in
    let: "$r0" := ((FuncResolve go.make3 [go.SliceType (go.PointerType Work)] #()) #(W64 0) (![go.int] (GlobalVarAddr BatchSize #()))) in
    do:  ("work" <-[go.SliceType (go.PointerType Work)] "$r0");;;
    let: "timer" := (GoAlloc (go.PointerType time.Timer) (GoZeroVal (go.PointerType time.Timer) #())) in
    let: "$r0" := (let: "$a0" := (![time.Duration] (GlobalVarAddr BatchTimeout #())) in
    (FuncResolve time.NewTimer [] #()) "$a0") in
    do:  ("timer" <-[go.PointerType time.Timer] "$r0");;;
    (let: "i" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.int] "$r0");;;
    (for: (λ: <>, (![go.int] "i") <⟨go.int⟩ (![go.int] (GlobalVarAddr BatchSize #()))); (λ: <>, do:  ("i" <-[go.int] ((![go.int] "i") +⟨go.int⟩ #(W64 1)))) := λ: <>,
      SelectStmt (SelectStmtClauses None [(CommClause (RecvCase (go.PointerType Work) (![go.ChannelType go.recvonly (go.PointerType Work)] "workQ")) (λ: "$recvVal",
        let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
        let: "job" := (GoAlloc (go.PointerType Work) (GoZeroVal (go.PointerType Work) #())) in
        let: ("$ret0", "$ret1") := "$recvVal" in
        let: "$r0" := "$ret0" in
        let: "$r1" := "$ret1" in
        do:  ("job" <-[go.PointerType Work] "$r0");;;
        do:  ("ok" <-[go.bool] "$r1");;;
        do:  (let: "$a0" := (![go.bool] "ok") in
        (FuncResolve std.Assert [] #()) "$a0");;;
        let: "$r0" := (let: "$a0" := (![go.SliceType (go.PointerType Work)] "work") in
        let: "$a1" := ((let: "$sl0" := (![go.PointerType Work] "job") in
        CompositeLiteral (go.SliceType (go.PointerType Work)) (LiteralValue [KeyedElement None (ElementExpression (go.PointerType Work) "$sl0")]))) in
        (FuncResolve go.append [go.SliceType (go.PointerType Work)] #()) "$a0" "$a1") in
        do:  ("work" <-[go.SliceType (go.PointerType Work)] "$r0")
        )); (CommClause (RecvCase time.Time (![go.ChannelType go.recvonly time.Time] (StructFieldRef time.Timer "C"%go (![go.PointerType time.Timer] "timer")))) (λ: "$recvVal",
        return: (![go.SliceType (go.PointerType Work)] "work")
        ))])));;;
    return: (![go.SliceType (go.PointerType Work)] "work")).

(* go: server.go:150:18 *)
Definition Server__doWorkⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" "work",
    exception_do (let: "s" := (GoAlloc (go.PointerType Server) "s") in
    let: "work" := (GoAlloc (go.SliceType (go.PointerType Work)) "work") in
    do:  (let: "$a0" := (![go.SliceType (go.PointerType Work)] "work") in
    (MethodResolve (go.PointerType Server) "checkWork"%go (![go.PointerType Server] "s")) "$a0");;;
    let: "ents" := (GoAlloc (go.SliceType (go.PointerType mapEntry)) (GoZeroVal (go.SliceType (go.PointerType mapEntry)) #())) in
    let: "$r0" := (let: "$a0" := (![go.SliceType (go.PointerType Work)] "work") in
    (MethodResolve (go.PointerType Server) "makeEntries"%go (![go.PointerType Server] "s")) "$a0") in
    do:  ("ents" <-[go.SliceType (go.PointerType mapEntry)] "$r0");;;
    do:  ((MethodResolve (go.PointerType sync.RWMutex) "Lock"%go (![go.PointerType sync.RWMutex] (StructFieldRef Server "mu"%go (![go.PointerType Server] "s")))) #());;;
    do:  (let: "$a0" := (![go.SliceType (go.PointerType Work)] "work") in
    let: "$a1" := (![go.SliceType (go.PointerType mapEntry)] "ents") in
    (MethodResolve (go.PointerType Server) "addEntries"%go (![go.PointerType Server] "s")) "$a0" "$a1");;;
    do:  ((MethodResolve (go.PointerType sync.RWMutex) "Unlock"%go (![go.PointerType sync.RWMutex] (StructFieldRef Server "mu"%go (![go.PointerType Server] "s")))) #());;;
    return: #()).

(* go: server.go:162:6 *)
Definition Newⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "mu" := (GoAlloc (go.PointerType sync.RWMutex) (GoZeroVal (go.PointerType sync.RWMutex) #())) in
    let: "$r0" := (GoAlloc sync.RWMutex (GoZeroVal sync.RWMutex #())) in
    do:  ("mu" <-[go.PointerType sync.RWMutex] "$r0");;;
    let: "sigSk" := (GoAlloc (go.PointerType cryptoffi.SigPrivateKey) (GoZeroVal (go.PointerType cryptoffi.SigPrivateKey) #())) in
    let: "sigPk" := (GoAlloc cryptoffi.SigPublicKey (GoZeroVal cryptoffi.SigPublicKey #())) in
    let: ("$ret0", "$ret1") := ((FuncResolve cryptoffi.SigGenerateKey [] #()) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("sigPk" <-[cryptoffi.SigPublicKey] "$r0");;;
    do:  ("sigSk" <-[go.PointerType cryptoffi.SigPrivateKey] "$r1");;;
    let: "vrfSk" := (GoAlloc (go.PointerType cryptoffi.VrfPrivateKey) (GoZeroVal (go.PointerType cryptoffi.VrfPrivateKey) #())) in
    let: "$r0" := ((FuncResolve cryptoffi.VrfGenerateKey [] #()) #()) in
    do:  ("vrfSk" <-[go.PointerType cryptoffi.VrfPrivateKey] "$r0");;;
    let: "vrfSig" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (let: "$a0" := (![go.PointerType cryptoffi.SigPrivateKey] "sigSk") in
    let: "$a1" := ((MethodResolve (go.PointerType cryptoffi.VrfPrivateKey) "PublicKey"%go (![go.PointerType cryptoffi.VrfPrivateKey] "vrfSk")) #()) in
    (FuncResolve ktcore.SignVrf [] #()) "$a0" "$a1") in
    do:  ("vrfSig" <-[go.SliceType go.byte] "$r0");;;
    let: "commitSec" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (let: "$a0" := cryptoffi.HashLen in
    (FuncResolve cryptoffi.RandBytes [] #()) "$a0") in
    do:  ("commitSec" <-[go.SliceType go.byte] "$r0");;;
    let: "secs" := (GoAlloc (go.PointerType secrets) (GoZeroVal (go.PointerType secrets) #())) in
    let: "$r0" := (GoAlloc secrets (CompositeLiteral secrets (LiteralValue [KeyedElement (Some (KeyField "sig"%go)) (ElementExpression (go.PointerType cryptoffi.SigPrivateKey) (![go.PointerType cryptoffi.SigPrivateKey] "sigSk")); KeyedElement (Some (KeyField "vrf"%go)) (ElementExpression (go.PointerType cryptoffi.VrfPrivateKey) (![go.PointerType cryptoffi.VrfPrivateKey] "vrfSk")); KeyedElement (Some (KeyField "commit"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] "commitSec"))]))) in
    do:  ("secs" <-[go.PointerType secrets] "$r0");;;
    let: "hidden" := (GoAlloc (go.PointerType merkle.Map) (GoZeroVal (go.PointerType merkle.Map) #())) in
    let: "$r0" := (GoAlloc merkle.Map (CompositeLiteral merkle.Map (LiteralValue []))) in
    do:  ("hidden" <-[go.PointerType merkle.Map] "$r0");;;
    let: "plain" := (GoAlloc (go.MapType go.uint64 (go.SliceType (go.SliceType go.byte))) (GoZeroVal (go.MapType go.uint64 (go.SliceType (go.SliceType go.byte))) #())) in
    let: "$r0" := ((FuncResolve go.make1 [go.MapType go.uint64 (go.SliceType (go.SliceType go.byte))] #()) #()) in
    do:  ("plain" <-[go.MapType go.uint64 (go.SliceType (go.SliceType go.byte))] "$r0");;;
    let: "keys" := (GoAlloc (go.PointerType keyStore) (GoZeroVal (go.PointerType keyStore) #())) in
    let: "$r0" := (GoAlloc keyStore (CompositeLiteral keyStore (LiteralValue [KeyedElement (Some (KeyField "hidden"%go)) (ElementExpression (go.PointerType merkle.Map) (![go.PointerType merkle.Map] "hidden")); KeyedElement (Some (KeyField "plain"%go)) (ElementExpression (go.MapType go.uint64 (go.SliceType (go.SliceType go.byte))) (![go.MapType go.uint64 (go.SliceType (go.SliceType go.byte))] "plain"))]))) in
    do:  ("keys" <-[go.PointerType keyStore] "$r0");;;
    let: "chain" := (GoAlloc (go.PointerType hashchain.HashChain) (GoZeroVal (go.PointerType hashchain.HashChain) #())) in
    let: "$r0" := ((FuncResolve hashchain.New [] #()) #()) in
    do:  ("chain" <-[go.PointerType hashchain.HashChain] "$r0");;;
    let: "hist" := (GoAlloc (go.PointerType history) (GoZeroVal (go.PointerType history) #())) in
    let: "$r0" := (GoAlloc history (CompositeLiteral history (LiteralValue [KeyedElement (Some (KeyField "chain"%go)) (ElementExpression (go.PointerType hashchain.HashChain) (![go.PointerType hashchain.HashChain] "chain")); KeyedElement (Some (KeyField "vrfPkSig"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] "vrfSig"))]))) in
    do:  ("hist" <-[go.PointerType history] "$r0");;;
    let: "wq" := (GoAlloc (go.ChannelType go.sendrecv (go.PointerType Work)) (GoZeroVal (go.ChannelType go.sendrecv (go.PointerType Work)) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.ChannelType go.sendrecv (go.PointerType Work)] #()) (![go.int] (GlobalVarAddr WorkQSize #()))) in
    do:  ("wq" <-[go.ChannelType go.sendrecv (go.PointerType Work)] "$r0");;;
    let: "s" := (GoAlloc (go.PointerType Server) (GoZeroVal (go.PointerType Server) #())) in
    let: "$r0" := (GoAlloc Server (CompositeLiteral Server (LiteralValue [KeyedElement (Some (KeyField "mu"%go)) (ElementExpression (go.PointerType sync.RWMutex) (![go.PointerType sync.RWMutex] "mu")); KeyedElement (Some (KeyField "secs"%go)) (ElementExpression (go.PointerType secrets) (![go.PointerType secrets] "secs")); KeyedElement (Some (KeyField "keys"%go)) (ElementExpression (go.PointerType keyStore) (![go.PointerType keyStore] "keys")); KeyedElement (Some (KeyField "hist"%go)) (ElementExpression (go.PointerType history) (![go.PointerType history] "hist")); KeyedElement (Some (KeyField "workQ"%go)) (ElementExpression (go.ChannelType go.sendrecv (go.PointerType Work)) (![go.ChannelType go.sendrecv (go.PointerType Work)] "wq"))]))) in
    do:  ("s" <-[go.PointerType Server] "$r0");;;
    let: "dig" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := ((MethodResolve (go.PointerType merkle.Map) "Hash"%go (![go.PointerType merkle.Map] (StructFieldRef keyStore "hidden"%go (![go.PointerType keyStore] "keys")))) #()) in
    do:  ("dig" <-[go.SliceType go.byte] "$r0");;;
    let: "link" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "dig") in
    (MethodResolve (go.PointerType hashchain.HashChain) "Append"%go (![go.PointerType hashchain.HashChain] "chain")) "$a0") in
    do:  ("link" <-[go.SliceType go.byte] "$r0");;;
    let: "linkSig" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (let: "$a0" := (![go.PointerType cryptoffi.SigPrivateKey] (StructFieldRef secrets "sig"%go (![go.PointerType secrets] (StructFieldRef Server "secs"%go (![go.PointerType Server] "s"))))) in
    let: "$a1" := #(W64 0) in
    let: "$a2" := (![go.SliceType go.byte] "link") in
    (FuncResolve ktcore.SignLink [] #()) "$a0" "$a1" "$a2") in
    do:  ("linkSig" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType (go.PointerType ktcore.AuditProof)] (StructFieldRef history "audits"%go (![go.PointerType history] (StructFieldRef Server "hist"%go (![go.PointerType Server] "s"))))) in
    let: "$a1" := ((let: "$sl0" := (GoAlloc ktcore.AuditProof (CompositeLiteral ktcore.AuditProof (LiteralValue [KeyedElement (Some (KeyField "LinkSig"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] "linkSig"))]))) in
    CompositeLiteral (go.SliceType (go.PointerType ktcore.AuditProof)) (LiteralValue [KeyedElement None (ElementExpression (go.PointerType ktcore.AuditProof) "$sl0")]))) in
    (FuncResolve go.append [go.SliceType (go.PointerType ktcore.AuditProof)] #()) "$a0" "$a1") in
    do:  ((StructFieldRef history "audits"%go (![go.PointerType history] (StructFieldRef Server "hist"%go (![go.PointerType Server] "s")))) <-[go.SliceType (go.PointerType ktcore.AuditProof)] "$r0");;;
    let: "$go" := (MethodResolve (go.PointerType Server) "worker"%go (![go.PointerType Server] "s")) in
    do:  (Fork ("$go" #()));;;
    return: (![go.PointerType Server] "s", ![cryptoffi.SigPublicKey] "sigPk")).

(* go: server.go:187:18 *)
Definition Server__checkWorkⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" "work",
    exception_do (let: "s" := (GoAlloc (go.PointerType Server) "s") in
    let: "work" := (GoAlloc (go.SliceType (go.PointerType Work)) "work") in
    let: "uidSet" := (GoAlloc (go.MapType go.uint64 go.bool) (GoZeroVal (go.MapType go.uint64 go.bool) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.MapType go.uint64 go.bool] #()) (let: "$a0" := (![go.SliceType (go.PointerType Work)] "work") in
    (FuncResolve go.len [go.SliceType (go.PointerType Work)] #()) "$a0")) in
    do:  ("uidSet" <-[go.MapType go.uint64 go.bool] "$r0");;;
    let: "$range" := (![go.SliceType (go.PointerType Work)] "work") in
    (let: "w" := (GoAlloc (go.PointerType Work) (GoZeroVal (go.PointerType Work) #())) in
    slice.for_range (go.PointerType Work) "$range" (λ: "$key" "$value",
      do:  ("w" <-[go.PointerType Work] "$value");;;
      do:  "$key";;;
      let: "uid" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: "$r0" := (![go.uint64] (StructFieldRef Work "Uid"%go (![go.PointerType Work] "w"))) in
      do:  ("uid" <-[go.uint64] "$r0");;;
      let: "nextVer" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: "$r0" := (Convert go.int go.uint64 (let: "$a0" := (map.lookup1 go.uint64 (go.SliceType (go.SliceType go.byte)) (![go.MapType go.uint64 (go.SliceType (go.SliceType go.byte))] (StructFieldRef keyStore "plain"%go (![go.PointerType keyStore] (StructFieldRef Server "keys"%go (![go.PointerType Server] "s"))))) (![go.uint64] "uid")) in
      (FuncResolve go.len [go.SliceType (go.SliceType go.byte)] #()) "$a0")) in
      do:  ("nextVer" <-[go.uint64] "$r0");;;
      (if: Convert go.untyped_bool go.bool ((![go.uint64] (StructFieldRef Work "Ver"%go (![go.PointerType Work] "w"))) ≠⟨go.uint64⟩ (![go.uint64] "nextVer"))
      then
        let: "$r0" := #true in
        do:  ((StructFieldRef Work "Err"%go (![go.PointerType Work] "w")) <-[go.bool] "$r0");;;
        continue: #()
      else do:  #());;;
      let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
      let: ("$ret0", "$ret1") := (map.lookup2 go.uint64 go.bool (![go.MapType go.uint64 go.bool] "uidSet") (![go.uint64] "uid")) in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  "$r0";;;
      do:  ("ok" <-[go.bool] "$r1");;;
      (if: ![go.bool] "ok"
      then
        let: "$r0" := #true in
        do:  ((StructFieldRef Work "Err"%go (![go.PointerType Work] "w")) <-[go.bool] "$r0");;;
        continue: #()
      else do:  #());;;
      let: "$r0" := #false in
      do:  (map.insert go.uint64 (![go.MapType go.uint64 go.bool] "uidSet") (![go.uint64] "uid") "$r0")));;;
    return: #()).

(* go: server.go:207:18 *)
Definition Server__makeEntriesⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" "work",
    exception_do (let: "ents" := (GoAlloc (go.SliceType (go.PointerType mapEntry)) (GoZeroVal (go.SliceType (go.PointerType mapEntry)) #())) in
    let: "s" := (GoAlloc (go.PointerType Server) "s") in
    let: "work" := (GoAlloc (go.SliceType (go.PointerType Work)) "work") in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType (go.PointerType mapEntry)] #()) (let: "$a0" := (![go.SliceType (go.PointerType Work)] "work") in
    (FuncResolve go.len [go.SliceType (go.PointerType Work)] #()) "$a0")) in
    do:  ("ents" <-[go.SliceType (go.PointerType mapEntry)] "$r0");;;
    let: "wg" := (GoAlloc (go.PointerType sync.WaitGroup) (GoZeroVal (go.PointerType sync.WaitGroup) #())) in
    let: "$r0" := (GoAlloc sync.WaitGroup (GoZeroVal sync.WaitGroup #())) in
    do:  ("wg" <-[go.PointerType sync.WaitGroup] "$r0");;;
    (let: "i" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.int] "$r0");;;
    (for: (λ: <>, (![go.int] "i") <⟨go.int⟩ (let: "$a0" := (![go.SliceType (go.PointerType Work)] "work") in
    (FuncResolve go.len [go.SliceType (go.PointerType Work)] #()) "$a0")); (λ: <>, do:  ("i" <-[go.int] ((![go.int] "i") +⟨go.int⟩ #(W64 1)))) := λ: <>,
      let: "job" := (GoAlloc (go.PointerType Work) (GoZeroVal (go.PointerType Work) #())) in
      let: "$r0" := (![go.PointerType Work] (IndexRef (go.SliceType (go.PointerType Work)) (![go.SliceType (go.PointerType Work)] "work", ![go.int] "i"))) in
      do:  ("job" <-[go.PointerType Work] "$r0");;;
      (if: ![go.bool] (StructFieldRef Work "Err"%go (![go.PointerType Work] "job"))
      then continue: #()
      else do:  #());;;
      let: "out" := (GoAlloc (go.PointerType mapEntry) (GoZeroVal (go.PointerType mapEntry) #())) in
      let: "$r0" := (GoAlloc mapEntry (CompositeLiteral mapEntry (LiteralValue []))) in
      do:  ("out" <-[go.PointerType mapEntry] "$r0");;;
      let: "$r0" := (![go.PointerType mapEntry] "out") in
      do:  ((IndexRef (go.SliceType (go.PointerType mapEntry)) (![go.SliceType (go.PointerType mapEntry)] "ents", ![go.int] "i")) <-[go.PointerType mapEntry] "$r0");;;
      do:  (let: "$a0" := #(W64 1) in
      (MethodResolve (go.PointerType sync.WaitGroup) "Add"%go (![go.PointerType sync.WaitGroup] "wg")) "$a0");;;
      let: "$go" := (λ: <>,
        exception_do (do:  (let: "$a0" := (![go.PointerType Work] "job") in
        let: "$a1" := (![go.PointerType mapEntry] "out") in
        (MethodResolve (go.PointerType Server) "makeEntry"%go (![go.PointerType Server] "s")) "$a0" "$a1");;;
        do:  ((MethodResolve (go.PointerType sync.WaitGroup) "Done"%go (![go.PointerType sync.WaitGroup] "wg")) #());;;
        return: #())
        ) in
      do:  (Fork ("$go" #()))));;;
    do:  ((MethodResolve (go.PointerType sync.WaitGroup) "Wait"%go (![go.PointerType sync.WaitGroup] "wg")) #());;;
    return: (![go.SliceType (go.PointerType mapEntry)] "ents")).

(* go: server.go:227:18 *)
Definition Server__makeEntryⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" "in" "out",
    exception_do (let: "s" := (GoAlloc (go.PointerType Server) "s") in
    let: "out" := (GoAlloc (go.PointerType mapEntry) "out") in
    let: "in" := (GoAlloc (go.PointerType Work) "in") in
    let: "numVers" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (Convert go.int go.uint64 (let: "$a0" := (map.lookup1 go.uint64 (go.SliceType (go.SliceType go.byte)) (![go.MapType go.uint64 (go.SliceType (go.SliceType go.byte))] (StructFieldRef keyStore "plain"%go (![go.PointerType keyStore] (StructFieldRef Server "keys"%go (![go.PointerType Server] "s"))))) (![go.uint64] (StructFieldRef Work "Uid"%go (![go.PointerType Work] "in")))) in
    (FuncResolve go.len [go.SliceType (go.SliceType go.byte)] #()) "$a0")) in
    do:  ("numVers" <-[go.uint64] "$r0");;;
    let: "mapLabel" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (let: "$a0" := (![go.PointerType cryptoffi.VrfPrivateKey] (StructFieldRef secrets "vrf"%go (![go.PointerType secrets] (StructFieldRef Server "secs"%go (![go.PointerType Server] "s"))))) in
    let: "$a1" := (![go.uint64] (StructFieldRef Work "Uid"%go (![go.PointerType Work] "in"))) in
    let: "$a2" := (![go.uint64] "numVers") in
    (FuncResolve ktcore.EvalMapLabel [] #()) "$a0" "$a1" "$a2") in
    do:  ("mapLabel" <-[go.SliceType go.byte] "$r0");;;
    let: "rand" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] (StructFieldRef secrets "commit"%go (![go.PointerType secrets] (StructFieldRef Server "secs"%go (![go.PointerType Server] "s"))))) in
    let: "$a1" := (![go.SliceType go.byte] "mapLabel") in
    (FuncResolve ktcore.GetCommitRand [] #()) "$a0" "$a1") in
    do:  ("rand" <-[go.SliceType go.byte] "$r0");;;
    let: "open" := (GoAlloc (go.PointerType ktcore.CommitOpen) (GoZeroVal (go.PointerType ktcore.CommitOpen) #())) in
    let: "$r0" := (GoAlloc ktcore.CommitOpen (CompositeLiteral ktcore.CommitOpen (LiteralValue [KeyedElement (Some (KeyField "Val"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] (StructFieldRef Work "Pk"%go (![go.PointerType Work] "in")))); KeyedElement (Some (KeyField "Rand"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] "rand"))]))) in
    do:  ("open" <-[go.PointerType ktcore.CommitOpen] "$r0");;;
    let: "mapVal" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (let: "$a0" := (![go.PointerType ktcore.CommitOpen] "open") in
    (FuncResolve ktcore.GetMapVal [] #()) "$a0") in
    do:  ("mapVal" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (![go.SliceType go.byte] "mapLabel") in
    do:  ((StructFieldRef mapEntry "label"%go (![go.PointerType mapEntry] "out")) <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (![go.SliceType go.byte] "mapVal") in
    do:  ((StructFieldRef mapEntry "val"%go (![go.PointerType mapEntry] "out")) <-[go.SliceType go.byte] "$r0");;;
    return: #()).

(* go: server.go:238:18 *)
Definition Server__addEntriesⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" "work" "ents",
    exception_do (let: "s" := (GoAlloc (go.PointerType Server) "s") in
    let: "ents" := (GoAlloc (go.SliceType (go.PointerType mapEntry)) "ents") in
    let: "work" := (GoAlloc (go.SliceType (go.PointerType Work)) "work") in
    let: "upd" := (GoAlloc (go.SliceType (go.PointerType ktcore.UpdateProof)) (GoZeroVal (go.SliceType (go.PointerType ktcore.UpdateProof)) #())) in
    let: "$r0" := ((FuncResolve go.make3 [go.SliceType (go.PointerType ktcore.UpdateProof)] #()) #(W64 0) (let: "$a0" := (![go.SliceType (go.PointerType Work)] "work") in
    (FuncResolve go.len [go.SliceType (go.PointerType Work)] #()) "$a0")) in
    do:  ("upd" <-[go.SliceType (go.PointerType ktcore.UpdateProof)] "$r0");;;
    (let: "i" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.int] "$r0");;;
    (for: (λ: <>, (![go.int] "i") <⟨go.int⟩ (let: "$a0" := (![go.SliceType (go.PointerType Work)] "work") in
    (FuncResolve go.len [go.SliceType (go.PointerType Work)] #()) "$a0")); (λ: <>, do:  ("i" <-[go.int] ((![go.int] "i") +⟨go.int⟩ #(W64 1)))) := λ: <>,
      let: "job" := (GoAlloc (go.PointerType Work) (GoZeroVal (go.PointerType Work) #())) in
      let: "$r0" := (![go.PointerType Work] (IndexRef (go.SliceType (go.PointerType Work)) (![go.SliceType (go.PointerType Work)] "work", ![go.int] "i"))) in
      do:  ("job" <-[go.PointerType Work] "$r0");;;
      (if: ![go.bool] (StructFieldRef Work "Err"%go (![go.PointerType Work] "job"))
      then continue: #()
      else do:  #());;;
      let: "out" := (GoAlloc (go.PointerType mapEntry) (GoZeroVal (go.PointerType mapEntry) #())) in
      let: "$r0" := (![go.PointerType mapEntry] (IndexRef (go.SliceType (go.PointerType mapEntry)) (![go.SliceType (go.PointerType mapEntry)] "ents", ![go.int] "i"))) in
      do:  ("out" <-[go.PointerType mapEntry] "$r0");;;
      let: "label" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
      let: "$r0" := (![go.SliceType go.byte] (StructFieldRef mapEntry "label"%go (![go.PointerType mapEntry] "out"))) in
      do:  ("label" <-[go.SliceType go.byte] "$r0");;;
      let: "proof" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
      let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "label") in
      let: "$a1" := (![go.SliceType go.byte] (StructFieldRef mapEntry "val"%go (![go.PointerType mapEntry] "out"))) in
      (MethodResolve (go.PointerType merkle.Map) "Put"%go (![go.PointerType merkle.Map] (StructFieldRef keyStore "hidden"%go (![go.PointerType keyStore] (StructFieldRef Server "keys"%go (![go.PointerType Server] "s")))))) "$a0" "$a1") in
      do:  ("proof" <-[go.SliceType go.byte] "$r0");;;
      let: "$r0" := (let: "$a0" := (map.lookup1 go.uint64 (go.SliceType (go.SliceType go.byte)) (![go.MapType go.uint64 (go.SliceType (go.SliceType go.byte))] (StructFieldRef keyStore "plain"%go (![go.PointerType keyStore] (StructFieldRef Server "keys"%go (![go.PointerType Server] "s"))))) (![go.uint64] (StructFieldRef Work "Uid"%go (![go.PointerType Work] "job")))) in
      let: "$a1" := ((let: "$sl0" := (![go.SliceType go.byte] (StructFieldRef Work "Pk"%go (![go.PointerType Work] "job"))) in
      CompositeLiteral (go.SliceType (go.SliceType go.byte)) (LiteralValue [KeyedElement None (ElementExpression (go.SliceType go.byte) "$sl0")]))) in
      (FuncResolve go.append [go.SliceType (go.SliceType go.byte)] #()) "$a0" "$a1") in
      do:  (map.insert go.uint64 (![go.MapType go.uint64 (go.SliceType (go.SliceType go.byte))] (StructFieldRef keyStore "plain"%go (![go.PointerType keyStore] (StructFieldRef Server "keys"%go (![go.PointerType Server] "s"))))) (![go.uint64] (StructFieldRef Work "Uid"%go (![go.PointerType Work] "job"))) "$r0");;;
      let: "info" := (GoAlloc (go.PointerType ktcore.UpdateProof) (GoZeroVal (go.PointerType ktcore.UpdateProof) #())) in
      let: "$r0" := (GoAlloc ktcore.UpdateProof (CompositeLiteral ktcore.UpdateProof (LiteralValue [KeyedElement (Some (KeyField "MapLabel"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] "label")); KeyedElement (Some (KeyField "MapVal"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] (StructFieldRef mapEntry "val"%go (![go.PointerType mapEntry] "out")))); KeyedElement (Some (KeyField "NonMembProof"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] "proof"))]))) in
      do:  ("info" <-[go.PointerType ktcore.UpdateProof] "$r0");;;
      let: "$r0" := (let: "$a0" := (![go.SliceType (go.PointerType ktcore.UpdateProof)] "upd") in
      let: "$a1" := ((let: "$sl0" := (![go.PointerType ktcore.UpdateProof] "info") in
      CompositeLiteral (go.SliceType (go.PointerType ktcore.UpdateProof)) (LiteralValue [KeyedElement None (ElementExpression (go.PointerType ktcore.UpdateProof) "$sl0")]))) in
      (FuncResolve go.append [go.SliceType (go.PointerType ktcore.UpdateProof)] #()) "$a0" "$a1") in
      do:  ("upd" <-[go.SliceType (go.PointerType ktcore.UpdateProof)] "$r0")));;;
    let: "dig" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := ((MethodResolve (go.PointerType merkle.Map) "Hash"%go (![go.PointerType merkle.Map] (StructFieldRef keyStore "hidden"%go (![go.PointerType keyStore] (StructFieldRef Server "keys"%go (![go.PointerType Server] "s")))))) #()) in
    do:  ("dig" <-[go.SliceType go.byte] "$r0");;;
    let: "link" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "dig") in
    (MethodResolve (go.PointerType hashchain.HashChain) "Append"%go (![go.PointerType hashchain.HashChain] (StructFieldRef history "chain"%go (![go.PointerType history] (StructFieldRef Server "hist"%go (![go.PointerType Server] "s")))))) "$a0") in
    do:  ("link" <-[go.SliceType go.byte] "$r0");;;
    let: "epoch" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (Convert go.int go.uint64 (let: "$a0" := (![go.SliceType (go.PointerType ktcore.AuditProof)] (StructFieldRef history "audits"%go (![go.PointerType history] (StructFieldRef Server "hist"%go (![go.PointerType Server] "s"))))) in
    (FuncResolve go.len [go.SliceType (go.PointerType ktcore.AuditProof)] #()) "$a0")) in
    do:  ("epoch" <-[go.uint64] "$r0");;;
    let: "sig" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (let: "$a0" := (![go.PointerType cryptoffi.SigPrivateKey] (StructFieldRef secrets "sig"%go (![go.PointerType secrets] (StructFieldRef Server "secs"%go (![go.PointerType Server] "s"))))) in
    let: "$a1" := (![go.uint64] "epoch") in
    let: "$a2" := (![go.SliceType go.byte] "link") in
    (FuncResolve ktcore.SignLink [] #()) "$a0" "$a1" "$a2") in
    do:  ("sig" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType (go.PointerType ktcore.AuditProof)] (StructFieldRef history "audits"%go (![go.PointerType history] (StructFieldRef Server "hist"%go (![go.PointerType Server] "s"))))) in
    let: "$a1" := ((let: "$sl0" := (GoAlloc ktcore.AuditProof (CompositeLiteral ktcore.AuditProof (LiteralValue [KeyedElement (Some (KeyField "Updates"%go)) (ElementExpression (go.SliceType (go.PointerType ktcore.UpdateProof)) (![go.SliceType (go.PointerType ktcore.UpdateProof)] "upd")); KeyedElement (Some (KeyField "LinkSig"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] "sig"))]))) in
    CompositeLiteral (go.SliceType (go.PointerType ktcore.AuditProof)) (LiteralValue [KeyedElement None (ElementExpression (go.PointerType ktcore.AuditProof) "$sl0")]))) in
    (FuncResolve go.append [go.SliceType (go.PointerType ktcore.AuditProof)] #()) "$a0" "$a1") in
    do:  ((StructFieldRef history "audits"%go (![go.PointerType history] (StructFieldRef Server "hist"%go (![go.PointerType Server] "s")))) <-[go.SliceType (go.PointerType ktcore.AuditProof)] "$r0");;;
    return: #()).

(* getHist returns a history of membership proofs for all post-prefix versions.

   go: server.go:264:18 *)
Definition Server__getHistⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" "uid" "prefixLen",
    exception_do (let: "hist" := (GoAlloc (go.SliceType (go.PointerType ktcore.Memb)) (GoZeroVal (go.SliceType (go.PointerType ktcore.Memb)) #())) in
    let: "s" := (GoAlloc (go.PointerType Server) "s") in
    let: "prefixLen" := (GoAlloc go.uint64 "prefixLen") in
    let: "uid" := (GoAlloc go.uint64 "uid") in
    let: "pks" := (GoAlloc (go.SliceType (go.SliceType go.byte)) (GoZeroVal (go.SliceType (go.SliceType go.byte)) #())) in
    let: "$r0" := (map.lookup1 go.uint64 (go.SliceType (go.SliceType go.byte)) (![go.MapType go.uint64 (go.SliceType (go.SliceType go.byte))] (StructFieldRef keyStore "plain"%go (![go.PointerType keyStore] (StructFieldRef Server "keys"%go (![go.PointerType Server] "s"))))) (![go.uint64] "uid")) in
    do:  ("pks" <-[go.SliceType (go.SliceType go.byte)] "$r0");;;
    let: "numVers" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (Convert go.int go.uint64 (let: "$a0" := (![go.SliceType (go.SliceType go.byte)] "pks") in
    (FuncResolve go.len [go.SliceType (go.SliceType go.byte)] #()) "$a0")) in
    do:  ("numVers" <-[go.uint64] "$r0");;;
    (let: "ver" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (![go.uint64] "prefixLen") in
    do:  ("ver" <-[go.uint64] "$r0");;;
    (for: (λ: <>, (![go.uint64] "ver") <⟨go.uint64⟩ (![go.uint64] "numVers")); (λ: <>, do:  ("ver" <-[go.uint64] ((![go.uint64] "ver") +⟨go.uint64⟩ #(W64 1)))) := λ: <>,
      let: "labelProof" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
      let: "label" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![go.PointerType cryptoffi.VrfPrivateKey] (StructFieldRef secrets "vrf"%go (![go.PointerType secrets] (StructFieldRef Server "secs"%go (![go.PointerType Server] "s"))))) in
      let: "$a1" := (![go.uint64] "uid") in
      let: "$a2" := (![go.uint64] "ver") in
      (FuncResolve ktcore.ProveMapLabel [] #()) "$a0" "$a1" "$a2") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("label" <-[go.SliceType go.byte] "$r0");;;
      do:  ("labelProof" <-[go.SliceType go.byte] "$r1");;;
      let: "mapProof" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
      let: "inMap" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
      let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "label") in
      (MethodResolve (go.PointerType merkle.Map) "Prove"%go (![go.PointerType merkle.Map] (StructFieldRef keyStore "hidden"%go (![go.PointerType keyStore] (StructFieldRef Server "keys"%go (![go.PointerType Server] "s")))))) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      let: "$r2" := "$ret2" in
      do:  ("inMap" <-[go.bool] "$r0");;;
      do:  "$r1";;;
      do:  ("mapProof" <-[go.SliceType go.byte] "$r2");;;
      do:  (let: "$a0" := (![go.bool] "inMap") in
      (FuncResolve std.Assert [] #()) "$a0");;;
      let: "rand" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
      let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] (StructFieldRef secrets "commit"%go (![go.PointerType secrets] (StructFieldRef Server "secs"%go (![go.PointerType Server] "s"))))) in
      let: "$a1" := (![go.SliceType go.byte] "label") in
      (FuncResolve ktcore.GetCommitRand [] #()) "$a0" "$a1") in
      do:  ("rand" <-[go.SliceType go.byte] "$r0");;;
      let: "open" := (GoAlloc (go.PointerType ktcore.CommitOpen) (GoZeroVal (go.PointerType ktcore.CommitOpen) #())) in
      let: "$r0" := (GoAlloc ktcore.CommitOpen (CompositeLiteral ktcore.CommitOpen (LiteralValue [KeyedElement (Some (KeyField "Val"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] (IndexRef (go.SliceType (go.SliceType go.byte)) (![go.SliceType (go.SliceType go.byte)] "pks", Convert go.uint64 go.int (![go.uint64] "ver"))))); KeyedElement (Some (KeyField "Rand"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] "rand"))]))) in
      do:  ("open" <-[go.PointerType ktcore.CommitOpen] "$r0");;;
      let: "memb" := (GoAlloc (go.PointerType ktcore.Memb) (GoZeroVal (go.PointerType ktcore.Memb) #())) in
      let: "$r0" := (GoAlloc ktcore.Memb (CompositeLiteral ktcore.Memb (LiteralValue [KeyedElement (Some (KeyField "LabelProof"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] "labelProof")); KeyedElement (Some (KeyField "PkOpen"%go)) (ElementExpression (go.PointerType ktcore.CommitOpen) (![go.PointerType ktcore.CommitOpen] "open")); KeyedElement (Some (KeyField "MerkleProof"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] "mapProof"))]))) in
      do:  ("memb" <-[go.PointerType ktcore.Memb] "$r0");;;
      let: "$r0" := (let: "$a0" := (![go.SliceType (go.PointerType ktcore.Memb)] "hist") in
      let: "$a1" := ((let: "$sl0" := (![go.PointerType ktcore.Memb] "memb") in
      CompositeLiteral (go.SliceType (go.PointerType ktcore.Memb)) (LiteralValue [KeyedElement None (ElementExpression (go.PointerType ktcore.Memb) "$sl0")]))) in
      (FuncResolve go.append [go.SliceType (go.PointerType ktcore.Memb)] #()) "$a0" "$a1") in
      do:  ("hist" <-[go.SliceType (go.PointerType ktcore.Memb)] "$r0")));;;
    return: (![go.SliceType (go.PointerType ktcore.Memb)] "hist")).

(* getBound returns a non-membership proof for the boundary version.

   go: server.go:280:18 *)
Definition Server__getBoundⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" "uid" "numVers",
    exception_do (let: "bound" := (GoAlloc (go.PointerType ktcore.NonMemb) (GoZeroVal (go.PointerType ktcore.NonMemb) #())) in
    let: "s" := (GoAlloc (go.PointerType Server) "s") in
    let: "numVers" := (GoAlloc go.uint64 "numVers") in
    let: "uid" := (GoAlloc go.uint64 "uid") in
    let: "labelProof" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "label" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.PointerType cryptoffi.VrfPrivateKey] (StructFieldRef secrets "vrf"%go (![go.PointerType secrets] (StructFieldRef Server "secs"%go (![go.PointerType Server] "s"))))) in
    let: "$a1" := (![go.uint64] "uid") in
    let: "$a2" := (![go.uint64] "numVers") in
    (FuncResolve ktcore.ProveMapLabel [] #()) "$a0" "$a1" "$a2") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("label" <-[go.SliceType go.byte] "$r0");;;
    do:  ("labelProof" <-[go.SliceType go.byte] "$r1");;;
    let: "mapProof" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "inMap" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "label") in
    (MethodResolve (go.PointerType merkle.Map) "Prove"%go (![go.PointerType merkle.Map] (StructFieldRef keyStore "hidden"%go (![go.PointerType keyStore] (StructFieldRef Server "keys"%go (![go.PointerType Server] "s")))))) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("inMap" <-[go.bool] "$r0");;;
    do:  "$r1";;;
    do:  ("mapProof" <-[go.SliceType go.byte] "$r2");;;
    do:  (let: "$a0" := (~ (![go.bool] "inMap")) in
    (FuncResolve std.Assert [] #()) "$a0");;;
    let: "$r0" := (GoAlloc ktcore.NonMemb (CompositeLiteral ktcore.NonMemb (LiteralValue [KeyedElement (Some (KeyField "LabelProof"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] "labelProof")); KeyedElement (Some (KeyField "MerkleProof"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] "mapProof"))]))) in
    do:  ("bound" <-[go.PointerType ktcore.NonMemb] "$r0");;;
    return: (![go.PointerType ktcore.NonMemb] "bound")).

#[global] Instance info' : PkgInfo pkg_id.server :=
{|
  pkg_imported_pkgs := [code.github_com.sanjit_bhat.pav.advrpc.pkg_id.advrpc; code.github_com.sanjit_bhat.pav.ktcore.pkg_id.ktcore; code.github_com.sanjit_bhat.pav.safemarshal.pkg_id.safemarshal; code.github_com.tchajed.marshal.pkg_id.marshal; code.sync.pkg_id.sync; code.time.pkg_id.time; code.github_com.goose_lang.std.pkg_id.std; code.github_com.sanjit_bhat.pav.cryptoffi.pkg_id.cryptoffi; code.github_com.sanjit_bhat.pav.hashchain.pkg_id.hashchain; code.github_com.sanjit_bhat.pav.merkle.pkg_id.merkle]
|}.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init pkg_id.server (λ: <>,
      exception_do (do:  (go.GlobalAlloc BatchTimeout time.Duration #());;;
      do:  (go.GlobalAlloc BatchSize go.int #());;;
      do:  (go.GlobalAlloc WorkQSize go.int #());;;
      do:  (merkle.initialize' #());;;
      do:  (hashchain.initialize' #());;;
      do:  (cryptoffi.initialize' #());;;
      do:  (std.initialize' #());;;
      do:  (time.initialize' #());;;
      do:  (sync.initialize' #());;;
      do:  (marshal.initialize' #());;;
      do:  (safemarshal.initialize' #());;;
      do:  (ktcore.initialize' #());;;
      do:  (advrpc.initialize' #());;;
      let: "$r0" := #(W64 1024) in
      do:  ((GlobalVarAddr WorkQSize #()) <-[go.int] "$r0");;;
      let: "$r0" := #(W64 128) in
      do:  ((GlobalVarAddr BatchSize #()) <-[go.int] "$r0");;;
      let: "$r0" := time.Second in
      do:  ((GlobalVarAddr BatchTimeout #()) <-[time.Duration] "$r0"))
      ).

Module StartChain.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  PrevEpochLen' : w64;
  PrevLink' : slice.t;
  ChainProof' : slice.t;
  LinkSig' : slice.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End StartChain.

Definition StartChain'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "PrevEpochLen"%go go.uint64);
  (go.FieldDecl "PrevLink"%go (go.SliceType go.byte));
  (go.FieldDecl "ChainProof"%go (go.SliceType go.byte));
  (go.FieldDecl "LinkSig"%go (go.SliceType go.byte))
].
Program Definition StartChain'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (StartChain'fds_unsealed).
Global Instance equals_unfold_StartChain {ext : ffi_syntax} {go_gctx : GoGlobalContext} : StartChain'fds =→ StartChain'fds_unsealed.
Proof. rewrite /StartChain'fds seal_eq //. Qed.

Definition StartChainⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (StartChain'fds).

Class StartChain_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] StartChain_type_repr  :: go.TypeReprUnderlying StartChainⁱᵐᵖˡ StartChain.t;
  #[global] StartChain_underlying :: (StartChain) <u (StartChainⁱᵐᵖˡ);
  #[global] StartChain_get_PrevEpochLen (x : StartChain.t) :: ⟦StructFieldGet (StartChainⁱᵐᵖˡ) "PrevEpochLen", #x⟧ ⤳[under] #x.(StartChain.PrevEpochLen');
  #[global] StartChain_set_PrevEpochLen (x : StartChain.t) y :: ⟦StructFieldSet (StartChainⁱᵐᵖˡ) "PrevEpochLen", (#x, #y)⟧ ⤳[under] #(x <|StartChain.PrevEpochLen' := y|>);
  #[global] StartChain_get_PrevLink (x : StartChain.t) :: ⟦StructFieldGet (StartChainⁱᵐᵖˡ) "PrevLink", #x⟧ ⤳[under] #x.(StartChain.PrevLink');
  #[global] StartChain_set_PrevLink (x : StartChain.t) y :: ⟦StructFieldSet (StartChainⁱᵐᵖˡ) "PrevLink", (#x, #y)⟧ ⤳[under] #(x <|StartChain.PrevLink' := y|>);
  #[global] StartChain_get_ChainProof (x : StartChain.t) :: ⟦StructFieldGet (StartChainⁱᵐᵖˡ) "ChainProof", #x⟧ ⤳[under] #x.(StartChain.ChainProof');
  #[global] StartChain_set_ChainProof (x : StartChain.t) y :: ⟦StructFieldSet (StartChainⁱᵐᵖˡ) "ChainProof", (#x, #y)⟧ ⤳[under] #(x <|StartChain.ChainProof' := y|>);
  #[global] StartChain_get_LinkSig (x : StartChain.t) :: ⟦StructFieldGet (StartChainⁱᵐᵖˡ) "LinkSig", #x⟧ ⤳[under] #x.(StartChain.LinkSig');
  #[global] StartChain_set_LinkSig (x : StartChain.t) y :: ⟦StructFieldSet (StartChainⁱᵐᵖˡ) "LinkSig", (#x, #y)⟧ ⤳[under] #(x <|StartChain.LinkSig' := y|>);
}.

Module StartVrf.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  VrfPk' : slice.t;
  VrfSig' : slice.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End StartVrf.

Definition StartVrf'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "VrfPk"%go (go.SliceType go.byte));
  (go.FieldDecl "VrfSig"%go (go.SliceType go.byte))
].
Program Definition StartVrf'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (StartVrf'fds_unsealed).
Global Instance equals_unfold_StartVrf {ext : ffi_syntax} {go_gctx : GoGlobalContext} : StartVrf'fds =→ StartVrf'fds_unsealed.
Proof. rewrite /StartVrf'fds seal_eq //. Qed.

Definition StartVrfⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (StartVrf'fds).

Class StartVrf_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] StartVrf_type_repr  :: go.TypeReprUnderlying StartVrfⁱᵐᵖˡ StartVrf.t;
  #[global] StartVrf_underlying :: (StartVrf) <u (StartVrfⁱᵐᵖˡ);
  #[global] StartVrf_get_VrfPk (x : StartVrf.t) :: ⟦StructFieldGet (StartVrfⁱᵐᵖˡ) "VrfPk", #x⟧ ⤳[under] #x.(StartVrf.VrfPk');
  #[global] StartVrf_set_VrfPk (x : StartVrf.t) y :: ⟦StructFieldSet (StartVrfⁱᵐᵖˡ) "VrfPk", (#x, #y)⟧ ⤳[under] #(x <|StartVrf.VrfPk' := y|>);
  #[global] StartVrf_get_VrfSig (x : StartVrf.t) :: ⟦StructFieldGet (StartVrfⁱᵐᵖˡ) "VrfSig", #x⟧ ⤳[under] #x.(StartVrf.VrfSig');
  #[global] StartVrf_set_VrfSig (x : StartVrf.t) y :: ⟦StructFieldSet (StartVrfⁱᵐᵖˡ) "VrfSig", (#x, #y)⟧ ⤳[under] #(x <|StartVrf.VrfSig' := y|>);
}.

Module StartReply.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  Chain' : loc;
  Vrf' : loc;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End StartReply.

Definition StartReply'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "Chain"%go (go.PointerType StartChain));
  (go.FieldDecl "Vrf"%go (go.PointerType StartVrf))
].
Program Definition StartReply'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (StartReply'fds_unsealed).
Global Instance equals_unfold_StartReply {ext : ffi_syntax} {go_gctx : GoGlobalContext} : StartReply'fds =→ StartReply'fds_unsealed.
Proof. rewrite /StartReply'fds seal_eq //. Qed.

Definition StartReplyⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (StartReply'fds).

Class StartReply_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] StartReply_type_repr  :: go.TypeReprUnderlying StartReplyⁱᵐᵖˡ StartReply.t;
  #[global] StartReply_underlying :: (StartReply) <u (StartReplyⁱᵐᵖˡ);
  #[global] StartReply_get_Chain (x : StartReply.t) :: ⟦StructFieldGet (StartReplyⁱᵐᵖˡ) "Chain", #x⟧ ⤳[under] #x.(StartReply.Chain');
  #[global] StartReply_set_Chain (x : StartReply.t) y :: ⟦StructFieldSet (StartReplyⁱᵐᵖˡ) "Chain", (#x, #y)⟧ ⤳[under] #(x <|StartReply.Chain' := y|>);
  #[global] StartReply_get_Vrf (x : StartReply.t) :: ⟦StructFieldGet (StartReplyⁱᵐᵖˡ) "Vrf", #x⟧ ⤳[under] #x.(StartReply.Vrf');
  #[global] StartReply_set_Vrf (x : StartReply.t) y :: ⟦StructFieldSet (StartReplyⁱᵐᵖˡ) "Vrf", (#x, #y)⟧ ⤳[under] #(x <|StartReply.Vrf' := y|>);
}.

Module PutArg.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  Uid' : w64;
  Pk' : slice.t;
  Ver' : w64;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End PutArg.

Definition PutArg'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "Uid"%go go.uint64);
  (go.FieldDecl "Pk"%go (go.SliceType go.byte));
  (go.FieldDecl "Ver"%go go.uint64)
].
Program Definition PutArg'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (PutArg'fds_unsealed).
Global Instance equals_unfold_PutArg {ext : ffi_syntax} {go_gctx : GoGlobalContext} : PutArg'fds =→ PutArg'fds_unsealed.
Proof. rewrite /PutArg'fds seal_eq //. Qed.

Definition PutArgⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (PutArg'fds).

Class PutArg_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] PutArg_type_repr  :: go.TypeReprUnderlying PutArgⁱᵐᵖˡ PutArg.t;
  #[global] PutArg_underlying :: (PutArg) <u (PutArgⁱᵐᵖˡ);
  #[global] PutArg_get_Uid (x : PutArg.t) :: ⟦StructFieldGet (PutArgⁱᵐᵖˡ) "Uid", #x⟧ ⤳[under] #x.(PutArg.Uid');
  #[global] PutArg_set_Uid (x : PutArg.t) y :: ⟦StructFieldSet (PutArgⁱᵐᵖˡ) "Uid", (#x, #y)⟧ ⤳[under] #(x <|PutArg.Uid' := y|>);
  #[global] PutArg_get_Pk (x : PutArg.t) :: ⟦StructFieldGet (PutArgⁱᵐᵖˡ) "Pk", #x⟧ ⤳[under] #x.(PutArg.Pk');
  #[global] PutArg_set_Pk (x : PutArg.t) y :: ⟦StructFieldSet (PutArgⁱᵐᵖˡ) "Pk", (#x, #y)⟧ ⤳[under] #(x <|PutArg.Pk' := y|>);
  #[global] PutArg_get_Ver (x : PutArg.t) :: ⟦StructFieldGet (PutArgⁱᵐᵖˡ) "Ver", #x⟧ ⤳[under] #x.(PutArg.Ver');
  #[global] PutArg_set_Ver (x : PutArg.t) y :: ⟦StructFieldSet (PutArgⁱᵐᵖˡ) "Ver", (#x, #y)⟧ ⤳[under] #(x <|PutArg.Ver' := y|>);
}.

Module HistoryArg.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  Uid' : w64;
  PrevEpoch' : w64;
  PrevVerLen' : w64;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End HistoryArg.

Definition HistoryArg'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "Uid"%go go.uint64);
  (go.FieldDecl "PrevEpoch"%go go.uint64);
  (go.FieldDecl "PrevVerLen"%go go.uint64)
].
Program Definition HistoryArg'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (HistoryArg'fds_unsealed).
Global Instance equals_unfold_HistoryArg {ext : ffi_syntax} {go_gctx : GoGlobalContext} : HistoryArg'fds =→ HistoryArg'fds_unsealed.
Proof. rewrite /HistoryArg'fds seal_eq //. Qed.

Definition HistoryArgⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (HistoryArg'fds).

Class HistoryArg_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] HistoryArg_type_repr  :: go.TypeReprUnderlying HistoryArgⁱᵐᵖˡ HistoryArg.t;
  #[global] HistoryArg_underlying :: (HistoryArg) <u (HistoryArgⁱᵐᵖˡ);
  #[global] HistoryArg_get_Uid (x : HistoryArg.t) :: ⟦StructFieldGet (HistoryArgⁱᵐᵖˡ) "Uid", #x⟧ ⤳[under] #x.(HistoryArg.Uid');
  #[global] HistoryArg_set_Uid (x : HistoryArg.t) y :: ⟦StructFieldSet (HistoryArgⁱᵐᵖˡ) "Uid", (#x, #y)⟧ ⤳[under] #(x <|HistoryArg.Uid' := y|>);
  #[global] HistoryArg_get_PrevEpoch (x : HistoryArg.t) :: ⟦StructFieldGet (HistoryArgⁱᵐᵖˡ) "PrevEpoch", #x⟧ ⤳[under] #x.(HistoryArg.PrevEpoch');
  #[global] HistoryArg_set_PrevEpoch (x : HistoryArg.t) y :: ⟦StructFieldSet (HistoryArgⁱᵐᵖˡ) "PrevEpoch", (#x, #y)⟧ ⤳[under] #(x <|HistoryArg.PrevEpoch' := y|>);
  #[global] HistoryArg_get_PrevVerLen (x : HistoryArg.t) :: ⟦StructFieldGet (HistoryArgⁱᵐᵖˡ) "PrevVerLen", #x⟧ ⤳[under] #x.(HistoryArg.PrevVerLen');
  #[global] HistoryArg_set_PrevVerLen (x : HistoryArg.t) y :: ⟦StructFieldSet (HistoryArgⁱᵐᵖˡ) "PrevVerLen", (#x, #y)⟧ ⤳[under] #(x <|HistoryArg.PrevVerLen' := y|>);
}.

Module HistoryReply.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  ChainProof' : slice.t;
  LinkSig' : slice.t;
  Hist' : slice.t;
  Bound' : loc;
  Err' : bool;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End HistoryReply.

Definition HistoryReply'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "ChainProof"%go (go.SliceType go.byte));
  (go.FieldDecl "LinkSig"%go (go.SliceType go.byte));
  (go.FieldDecl "Hist"%go (go.SliceType (go.PointerType ktcore.Memb)));
  (go.FieldDecl "Bound"%go (go.PointerType ktcore.NonMemb));
  (go.FieldDecl "Err"%go go.bool)
].
Program Definition HistoryReply'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (HistoryReply'fds_unsealed).
Global Instance equals_unfold_HistoryReply {ext : ffi_syntax} {go_gctx : GoGlobalContext} : HistoryReply'fds =→ HistoryReply'fds_unsealed.
Proof. rewrite /HistoryReply'fds seal_eq //. Qed.

Definition HistoryReplyⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (HistoryReply'fds).

Class HistoryReply_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] HistoryReply_type_repr  :: go.TypeReprUnderlying HistoryReplyⁱᵐᵖˡ HistoryReply.t;
  #[global] HistoryReply_underlying :: (HistoryReply) <u (HistoryReplyⁱᵐᵖˡ);
  #[global] HistoryReply_get_ChainProof (x : HistoryReply.t) :: ⟦StructFieldGet (HistoryReplyⁱᵐᵖˡ) "ChainProof", #x⟧ ⤳[under] #x.(HistoryReply.ChainProof');
  #[global] HistoryReply_set_ChainProof (x : HistoryReply.t) y :: ⟦StructFieldSet (HistoryReplyⁱᵐᵖˡ) "ChainProof", (#x, #y)⟧ ⤳[under] #(x <|HistoryReply.ChainProof' := y|>);
  #[global] HistoryReply_get_LinkSig (x : HistoryReply.t) :: ⟦StructFieldGet (HistoryReplyⁱᵐᵖˡ) "LinkSig", #x⟧ ⤳[under] #x.(HistoryReply.LinkSig');
  #[global] HistoryReply_set_LinkSig (x : HistoryReply.t) y :: ⟦StructFieldSet (HistoryReplyⁱᵐᵖˡ) "LinkSig", (#x, #y)⟧ ⤳[under] #(x <|HistoryReply.LinkSig' := y|>);
  #[global] HistoryReply_get_Hist (x : HistoryReply.t) :: ⟦StructFieldGet (HistoryReplyⁱᵐᵖˡ) "Hist", #x⟧ ⤳[under] #x.(HistoryReply.Hist');
  #[global] HistoryReply_set_Hist (x : HistoryReply.t) y :: ⟦StructFieldSet (HistoryReplyⁱᵐᵖˡ) "Hist", (#x, #y)⟧ ⤳[under] #(x <|HistoryReply.Hist' := y|>);
  #[global] HistoryReply_get_Bound (x : HistoryReply.t) :: ⟦StructFieldGet (HistoryReplyⁱᵐᵖˡ) "Bound", #x⟧ ⤳[under] #x.(HistoryReply.Bound');
  #[global] HistoryReply_set_Bound (x : HistoryReply.t) y :: ⟦StructFieldSet (HistoryReplyⁱᵐᵖˡ) "Bound", (#x, #y)⟧ ⤳[under] #(x <|HistoryReply.Bound' := y|>);
  #[global] HistoryReply_get_Err (x : HistoryReply.t) :: ⟦StructFieldGet (HistoryReplyⁱᵐᵖˡ) "Err", #x⟧ ⤳[under] #x.(HistoryReply.Err');
  #[global] HistoryReply_set_Err (x : HistoryReply.t) y :: ⟦StructFieldSet (HistoryReplyⁱᵐᵖˡ) "Err", (#x, #y)⟧ ⤳[under] #(x <|HistoryReply.Err' := y|>);
}.

Module AuditArg.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  PrevEpoch' : w64;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End AuditArg.

Definition AuditArg'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "PrevEpoch"%go go.uint64)
].
Program Definition AuditArg'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (AuditArg'fds_unsealed).
Global Instance equals_unfold_AuditArg {ext : ffi_syntax} {go_gctx : GoGlobalContext} : AuditArg'fds =→ AuditArg'fds_unsealed.
Proof. rewrite /AuditArg'fds seal_eq //. Qed.

Definition AuditArgⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (AuditArg'fds).

Class AuditArg_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] AuditArg_type_repr  :: go.TypeReprUnderlying AuditArgⁱᵐᵖˡ AuditArg.t;
  #[global] AuditArg_underlying :: (AuditArg) <u (AuditArgⁱᵐᵖˡ);
  #[global] AuditArg_get_PrevEpoch (x : AuditArg.t) :: ⟦StructFieldGet (AuditArgⁱᵐᵖˡ) "PrevEpoch", #x⟧ ⤳[under] #x.(AuditArg.PrevEpoch');
  #[global] AuditArg_set_PrevEpoch (x : AuditArg.t) y :: ⟦StructFieldSet (AuditArgⁱᵐᵖˡ) "PrevEpoch", (#x, #y)⟧ ⤳[under] #(x <|AuditArg.PrevEpoch' := y|>);
}.

Module AuditReply.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  P' : slice.t;
  Err' : bool;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End AuditReply.

Definition AuditReply'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "P"%go (go.SliceType (go.PointerType ktcore.AuditProof)));
  (go.FieldDecl "Err"%go go.bool)
].
Program Definition AuditReply'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (AuditReply'fds_unsealed).
Global Instance equals_unfold_AuditReply {ext : ffi_syntax} {go_gctx : GoGlobalContext} : AuditReply'fds =→ AuditReply'fds_unsealed.
Proof. rewrite /AuditReply'fds seal_eq //. Qed.

Definition AuditReplyⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (AuditReply'fds).

Class AuditReply_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] AuditReply_type_repr  :: go.TypeReprUnderlying AuditReplyⁱᵐᵖˡ AuditReply.t;
  #[global] AuditReply_underlying :: (AuditReply) <u (AuditReplyⁱᵐᵖˡ);
  #[global] AuditReply_get_P (x : AuditReply.t) :: ⟦StructFieldGet (AuditReplyⁱᵐᵖˡ) "P", #x⟧ ⤳[under] #x.(AuditReply.P');
  #[global] AuditReply_set_P (x : AuditReply.t) y :: ⟦StructFieldSet (AuditReplyⁱᵐᵖˡ) "P", (#x, #y)⟧ ⤳[under] #(x <|AuditReply.P' := y|>);
  #[global] AuditReply_get_Err (x : AuditReply.t) :: ⟦StructFieldGet (AuditReplyⁱᵐᵖˡ) "Err", #x⟧ ⤳[under] #x.(AuditReply.Err');
  #[global] AuditReply_set_Err (x : AuditReply.t) y :: ⟦StructFieldSet (AuditReplyⁱᵐᵖˡ) "Err", (#x, #y)⟧ ⤳[under] #(x <|AuditReply.Err' := y|>);
}.

Module Server.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  mu' : loc;
  secs' : loc;
  keys' : loc;
  hist' : loc;
  workQ' : loc;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End Server.

Definition Server'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "mu"%go (go.PointerType sync.RWMutex));
  (go.FieldDecl "secs"%go (go.PointerType secrets));
  (go.FieldDecl "keys"%go (go.PointerType keyStore));
  (go.FieldDecl "hist"%go (go.PointerType history));
  (go.FieldDecl "workQ"%go (go.ChannelType go.sendrecv (go.PointerType Work)))
].
Program Definition Server'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (Server'fds_unsealed).
Global Instance equals_unfold_Server {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Server'fds =→ Server'fds_unsealed.
Proof. rewrite /Server'fds seal_eq //. Qed.

Definition Serverⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (Server'fds).

Class Server_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Server_type_repr  :: go.TypeReprUnderlying Serverⁱᵐᵖˡ Server.t;
  #[global] Server_underlying :: (Server) <u (Serverⁱᵐᵖˡ);
  #[global] Server_get_mu (x : Server.t) :: ⟦StructFieldGet (Serverⁱᵐᵖˡ) "mu", #x⟧ ⤳[under] #x.(Server.mu');
  #[global] Server_set_mu (x : Server.t) y :: ⟦StructFieldSet (Serverⁱᵐᵖˡ) "mu", (#x, #y)⟧ ⤳[under] #(x <|Server.mu' := y|>);
  #[global] Server_get_secs (x : Server.t) :: ⟦StructFieldGet (Serverⁱᵐᵖˡ) "secs", #x⟧ ⤳[under] #x.(Server.secs');
  #[global] Server_set_secs (x : Server.t) y :: ⟦StructFieldSet (Serverⁱᵐᵖˡ) "secs", (#x, #y)⟧ ⤳[under] #(x <|Server.secs' := y|>);
  #[global] Server_get_keys (x : Server.t) :: ⟦StructFieldGet (Serverⁱᵐᵖˡ) "keys", #x⟧ ⤳[under] #x.(Server.keys');
  #[global] Server_set_keys (x : Server.t) y :: ⟦StructFieldSet (Serverⁱᵐᵖˡ) "keys", (#x, #y)⟧ ⤳[under] #(x <|Server.keys' := y|>);
  #[global] Server_get_hist (x : Server.t) :: ⟦StructFieldGet (Serverⁱᵐᵖˡ) "hist", #x⟧ ⤳[under] #x.(Server.hist');
  #[global] Server_set_hist (x : Server.t) y :: ⟦StructFieldSet (Serverⁱᵐᵖˡ) "hist", (#x, #y)⟧ ⤳[under] #(x <|Server.hist' := y|>);
  #[global] Server_get_workQ (x : Server.t) :: ⟦StructFieldGet (Serverⁱᵐᵖˡ) "workQ", #x⟧ ⤳[under] #x.(Server.workQ');
  #[global] Server_set_workQ (x : Server.t) y :: ⟦StructFieldSet (Serverⁱᵐᵖˡ) "workQ", (#x, #y)⟧ ⤳[under] #(x <|Server.workQ' := y|>);
  #[global] Server'ptr_Audit_unfold :: MethodUnfold (go.PointerType (Server)) "Audit" (Server__Auditⁱᵐᵖˡ);
  #[global] Server'ptr_History_unfold :: MethodUnfold (go.PointerType (Server)) "History" (Server__Historyⁱᵐᵖˡ);
  #[global] Server'ptr_Put_unfold :: MethodUnfold (go.PointerType (Server)) "Put" (Server__Putⁱᵐᵖˡ);
  #[global] Server'ptr_Start_unfold :: MethodUnfold (go.PointerType (Server)) "Start" (Server__Startⁱᵐᵖˡ);
  #[global] Server'ptr_addEntries_unfold :: MethodUnfold (go.PointerType (Server)) "addEntries" (Server__addEntriesⁱᵐᵖˡ);
  #[global] Server'ptr_checkWork_unfold :: MethodUnfold (go.PointerType (Server)) "checkWork" (Server__checkWorkⁱᵐᵖˡ);
  #[global] Server'ptr_doWork_unfold :: MethodUnfold (go.PointerType (Server)) "doWork" (Server__doWorkⁱᵐᵖˡ);
  #[global] Server'ptr_getBound_unfold :: MethodUnfold (go.PointerType (Server)) "getBound" (Server__getBoundⁱᵐᵖˡ);
  #[global] Server'ptr_getHist_unfold :: MethodUnfold (go.PointerType (Server)) "getHist" (Server__getHistⁱᵐᵖˡ);
  #[global] Server'ptr_makeEntries_unfold :: MethodUnfold (go.PointerType (Server)) "makeEntries" (Server__makeEntriesⁱᵐᵖˡ);
  #[global] Server'ptr_makeEntry_unfold :: MethodUnfold (go.PointerType (Server)) "makeEntry" (Server__makeEntryⁱᵐᵖˡ);
  #[global] Server'ptr_worker_unfold :: MethodUnfold (go.PointerType (Server)) "worker" (Server__workerⁱᵐᵖˡ);
}.

Module secrets.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  sig' : loc;
  vrf' : loc;
  commit' : slice.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End secrets.

Definition secrets'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "sig"%go (go.PointerType cryptoffi.SigPrivateKey));
  (go.FieldDecl "vrf"%go (go.PointerType cryptoffi.VrfPrivateKey));
  (go.FieldDecl "commit"%go (go.SliceType go.byte))
].
Program Definition secrets'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (secrets'fds_unsealed).
Global Instance equals_unfold_secrets {ext : ffi_syntax} {go_gctx : GoGlobalContext} : secrets'fds =→ secrets'fds_unsealed.
Proof. rewrite /secrets'fds seal_eq //. Qed.

Definition secretsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (secrets'fds).

Class secrets_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] secrets_type_repr  :: go.TypeReprUnderlying secretsⁱᵐᵖˡ secrets.t;
  #[global] secrets_underlying :: (secrets) <u (secretsⁱᵐᵖˡ);
  #[global] secrets_get_sig (x : secrets.t) :: ⟦StructFieldGet (secretsⁱᵐᵖˡ) "sig", #x⟧ ⤳[under] #x.(secrets.sig');
  #[global] secrets_set_sig (x : secrets.t) y :: ⟦StructFieldSet (secretsⁱᵐᵖˡ) "sig", (#x, #y)⟧ ⤳[under] #(x <|secrets.sig' := y|>);
  #[global] secrets_get_vrf (x : secrets.t) :: ⟦StructFieldGet (secretsⁱᵐᵖˡ) "vrf", #x⟧ ⤳[under] #x.(secrets.vrf');
  #[global] secrets_set_vrf (x : secrets.t) y :: ⟦StructFieldSet (secretsⁱᵐᵖˡ) "vrf", (#x, #y)⟧ ⤳[under] #(x <|secrets.vrf' := y|>);
  #[global] secrets_get_commit (x : secrets.t) :: ⟦StructFieldGet (secretsⁱᵐᵖˡ) "commit", #x⟧ ⤳[under] #x.(secrets.commit');
  #[global] secrets_set_commit (x : secrets.t) y :: ⟦StructFieldSet (secretsⁱᵐᵖˡ) "commit", (#x, #y)⟧ ⤳[under] #(x <|secrets.commit' := y|>);
}.

Module keyStore.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  hidden' : loc;
  plain' : loc;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End keyStore.

Definition keyStore'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "hidden"%go (go.PointerType merkle.Map));
  (go.FieldDecl "plain"%go (go.MapType go.uint64 (go.SliceType (go.SliceType go.byte))))
].
Program Definition keyStore'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (keyStore'fds_unsealed).
Global Instance equals_unfold_keyStore {ext : ffi_syntax} {go_gctx : GoGlobalContext} : keyStore'fds =→ keyStore'fds_unsealed.
Proof. rewrite /keyStore'fds seal_eq //. Qed.

Definition keyStoreⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (keyStore'fds).

Class keyStore_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] keyStore_type_repr  :: go.TypeReprUnderlying keyStoreⁱᵐᵖˡ keyStore.t;
  #[global] keyStore_underlying :: (keyStore) <u (keyStoreⁱᵐᵖˡ);
  #[global] keyStore_get_hidden (x : keyStore.t) :: ⟦StructFieldGet (keyStoreⁱᵐᵖˡ) "hidden", #x⟧ ⤳[under] #x.(keyStore.hidden');
  #[global] keyStore_set_hidden (x : keyStore.t) y :: ⟦StructFieldSet (keyStoreⁱᵐᵖˡ) "hidden", (#x, #y)⟧ ⤳[under] #(x <|keyStore.hidden' := y|>);
  #[global] keyStore_get_plain (x : keyStore.t) :: ⟦StructFieldGet (keyStoreⁱᵐᵖˡ) "plain", #x⟧ ⤳[under] #x.(keyStore.plain');
  #[global] keyStore_set_plain (x : keyStore.t) y :: ⟦StructFieldSet (keyStoreⁱᵐᵖˡ) "plain", (#x, #y)⟧ ⤳[under] #(x <|keyStore.plain' := y|>);
}.

Module history.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  chain' : loc;
  audits' : slice.t;
  vrfPkSig' : slice.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End history.

Definition history'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "chain"%go (go.PointerType hashchain.HashChain));
  (go.FieldDecl "audits"%go (go.SliceType (go.PointerType ktcore.AuditProof)));
  (go.FieldDecl "vrfPkSig"%go (go.SliceType go.byte))
].
Program Definition history'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (history'fds_unsealed).
Global Instance equals_unfold_history {ext : ffi_syntax} {go_gctx : GoGlobalContext} : history'fds =→ history'fds_unsealed.
Proof. rewrite /history'fds seal_eq //. Qed.

Definition historyⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (history'fds).

Class history_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] history_type_repr  :: go.TypeReprUnderlying historyⁱᵐᵖˡ history.t;
  #[global] history_underlying :: (history) <u (historyⁱᵐᵖˡ);
  #[global] history_get_chain (x : history.t) :: ⟦StructFieldGet (historyⁱᵐᵖˡ) "chain", #x⟧ ⤳[under] #x.(history.chain');
  #[global] history_set_chain (x : history.t) y :: ⟦StructFieldSet (historyⁱᵐᵖˡ) "chain", (#x, #y)⟧ ⤳[under] #(x <|history.chain' := y|>);
  #[global] history_get_audits (x : history.t) :: ⟦StructFieldGet (historyⁱᵐᵖˡ) "audits", #x⟧ ⤳[under] #x.(history.audits');
  #[global] history_set_audits (x : history.t) y :: ⟦StructFieldSet (historyⁱᵐᵖˡ) "audits", (#x, #y)⟧ ⤳[under] #(x <|history.audits' := y|>);
  #[global] history_get_vrfPkSig (x : history.t) :: ⟦StructFieldGet (historyⁱᵐᵖˡ) "vrfPkSig", #x⟧ ⤳[under] #x.(history.vrfPkSig');
  #[global] history_set_vrfPkSig (x : history.t) y :: ⟦StructFieldSet (historyⁱᵐᵖˡ) "vrfPkSig", (#x, #y)⟧ ⤳[under] #(x <|history.vrfPkSig' := y|>);
}.

Module Work.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  Uid' : w64;
  Pk' : slice.t;
  Ver' : w64;
  Err' : bool;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End Work.

Definition Work'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "Uid"%go go.uint64);
  (go.FieldDecl "Pk"%go (go.SliceType go.byte));
  (go.FieldDecl "Ver"%go go.uint64);
  (go.FieldDecl "Err"%go go.bool)
].
Program Definition Work'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (Work'fds_unsealed).
Global Instance equals_unfold_Work {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Work'fds =→ Work'fds_unsealed.
Proof. rewrite /Work'fds seal_eq //. Qed.

Definition Workⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (Work'fds).

Class Work_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Work_type_repr  :: go.TypeReprUnderlying Workⁱᵐᵖˡ Work.t;
  #[global] Work_underlying :: (Work) <u (Workⁱᵐᵖˡ);
  #[global] Work_get_Uid (x : Work.t) :: ⟦StructFieldGet (Workⁱᵐᵖˡ) "Uid", #x⟧ ⤳[under] #x.(Work.Uid');
  #[global] Work_set_Uid (x : Work.t) y :: ⟦StructFieldSet (Workⁱᵐᵖˡ) "Uid", (#x, #y)⟧ ⤳[under] #(x <|Work.Uid' := y|>);
  #[global] Work_get_Pk (x : Work.t) :: ⟦StructFieldGet (Workⁱᵐᵖˡ) "Pk", #x⟧ ⤳[under] #x.(Work.Pk');
  #[global] Work_set_Pk (x : Work.t) y :: ⟦StructFieldSet (Workⁱᵐᵖˡ) "Pk", (#x, #y)⟧ ⤳[under] #(x <|Work.Pk' := y|>);
  #[global] Work_get_Ver (x : Work.t) :: ⟦StructFieldGet (Workⁱᵐᵖˡ) "Ver", #x⟧ ⤳[under] #x.(Work.Ver');
  #[global] Work_set_Ver (x : Work.t) y :: ⟦StructFieldSet (Workⁱᵐᵖˡ) "Ver", (#x, #y)⟧ ⤳[under] #(x <|Work.Ver' := y|>);
  #[global] Work_get_Err (x : Work.t) :: ⟦StructFieldGet (Workⁱᵐᵖˡ) "Err", #x⟧ ⤳[under] #x.(Work.Err');
  #[global] Work_set_Err (x : Work.t) y :: ⟦StructFieldSet (Workⁱᵐᵖˡ) "Err", (#x, #y)⟧ ⤳[under] #(x <|Work.Err' := y|>);
}.

Module mapEntry.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  label' : slice.t;
  val' : slice.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End mapEntry.

Definition mapEntry'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "label"%go (go.SliceType go.byte));
  (go.FieldDecl "val"%go (go.SliceType go.byte))
].
Program Definition mapEntry'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (mapEntry'fds_unsealed).
Global Instance equals_unfold_mapEntry {ext : ffi_syntax} {go_gctx : GoGlobalContext} : mapEntry'fds =→ mapEntry'fds_unsealed.
Proof. rewrite /mapEntry'fds seal_eq //. Qed.

Definition mapEntryⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (mapEntry'fds).

Class mapEntry_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] mapEntry_type_repr  :: go.TypeReprUnderlying mapEntryⁱᵐᵖˡ mapEntry.t;
  #[global] mapEntry_underlying :: (mapEntry) <u (mapEntryⁱᵐᵖˡ);
  #[global] mapEntry_get_label (x : mapEntry.t) :: ⟦StructFieldGet (mapEntryⁱᵐᵖˡ) "label", #x⟧ ⤳[under] #x.(mapEntry.label');
  #[global] mapEntry_set_label (x : mapEntry.t) y :: ⟦StructFieldSet (mapEntryⁱᵐᵖˡ) "label", (#x, #y)⟧ ⤳[under] #(x <|mapEntry.label' := y|>);
  #[global] mapEntry_get_val (x : mapEntry.t) :: ⟦StructFieldGet (mapEntryⁱᵐᵖˡ) "val", #x⟧ ⤳[under] #x.(mapEntry.val');
  #[global] mapEntry_set_val (x : mapEntry.t) y :: ⟦StructFieldSet (mapEntryⁱᵐᵖˡ) "val", (#x, #y)⟧ ⤳[under] #(x <|mapEntry.val' := y|>);
}.

Class Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] StartChain_instance :: StartChain_Assumptions;
  #[global] StartVrf_instance :: StartVrf_Assumptions;
  #[global] StartReply_instance :: StartReply_Assumptions;
  #[global] PutArg_instance :: PutArg_Assumptions;
  #[global] HistoryArg_instance :: HistoryArg_Assumptions;
  #[global] HistoryReply_instance :: HistoryReply_Assumptions;
  #[global] AuditArg_instance :: AuditArg_Assumptions;
  #[global] AuditReply_instance :: AuditReply_Assumptions;
  #[global] Server_instance :: Server_Assumptions;
  #[global] secrets_instance :: secrets_Assumptions;
  #[global] keyStore_instance :: keyStore_Assumptions;
  #[global] history_instance :: history_Assumptions;
  #[global] Work_instance :: Work_Assumptions;
  #[global] mapEntry_instance :: mapEntry_Assumptions;
  #[global] NewRpcServer_unfold :: FuncUnfold NewRpcServer [] (NewRpcServerⁱᵐᵖˡ);
  #[global] CallStart_unfold :: FuncUnfold CallStart [] (CallStartⁱᵐᵖˡ);
  #[global] CallPut_unfold :: FuncUnfold CallPut [] (CallPutⁱᵐᵖˡ);
  #[global] CallHistory_unfold :: FuncUnfold CallHistory [] (CallHistoryⁱᵐᵖˡ);
  #[global] CallAudit_unfold :: FuncUnfold CallAudit [] (CallAuditⁱᵐᵖˡ);
  #[global] StartChainEncode_unfold :: FuncUnfold StartChainEncode [] (StartChainEncodeⁱᵐᵖˡ);
  #[global] StartChainDecode_unfold :: FuncUnfold StartChainDecode [] (StartChainDecodeⁱᵐᵖˡ);
  #[global] StartVrfEncode_unfold :: FuncUnfold StartVrfEncode [] (StartVrfEncodeⁱᵐᵖˡ);
  #[global] StartVrfDecode_unfold :: FuncUnfold StartVrfDecode [] (StartVrfDecodeⁱᵐᵖˡ);
  #[global] StartReplyEncode_unfold :: FuncUnfold StartReplyEncode [] (StartReplyEncodeⁱᵐᵖˡ);
  #[global] StartReplyDecode_unfold :: FuncUnfold StartReplyDecode [] (StartReplyDecodeⁱᵐᵖˡ);
  #[global] PutArgEncode_unfold :: FuncUnfold PutArgEncode [] (PutArgEncodeⁱᵐᵖˡ);
  #[global] PutArgDecode_unfold :: FuncUnfold PutArgDecode [] (PutArgDecodeⁱᵐᵖˡ);
  #[global] HistoryArgEncode_unfold :: FuncUnfold HistoryArgEncode [] (HistoryArgEncodeⁱᵐᵖˡ);
  #[global] HistoryArgDecode_unfold :: FuncUnfold HistoryArgDecode [] (HistoryArgDecodeⁱᵐᵖˡ);
  #[global] HistoryReplyEncode_unfold :: FuncUnfold HistoryReplyEncode [] (HistoryReplyEncodeⁱᵐᵖˡ);
  #[global] HistoryReplyDecode_unfold :: FuncUnfold HistoryReplyDecode [] (HistoryReplyDecodeⁱᵐᵖˡ);
  #[global] AuditArgEncode_unfold :: FuncUnfold AuditArgEncode [] (AuditArgEncodeⁱᵐᵖˡ);
  #[global] AuditArgDecode_unfold :: FuncUnfold AuditArgDecode [] (AuditArgDecodeⁱᵐᵖˡ);
  #[global] AuditReplyEncode_unfold :: FuncUnfold AuditReplyEncode [] (AuditReplyEncodeⁱᵐᵖˡ);
  #[global] AuditReplyDecode_unfold :: FuncUnfold AuditReplyDecode [] (AuditReplyDecodeⁱᵐᵖˡ);
  #[global] getWork_unfold :: FuncUnfold getWork [] (getWorkⁱᵐᵖˡ);
  #[global] New_unfold :: FuncUnfold New [] (Newⁱᵐᵖˡ);
  #[global] import_advrpc_Assumption :: advrpc.Assumptions;
  #[global] import_ktcore_Assumption :: ktcore.Assumptions;
  #[global] import_safemarshal_Assumption :: safemarshal.Assumptions;
  #[global] import_marshal_Assumption :: marshal.Assumptions;
  #[global] import_sync_Assumption :: sync.Assumptions;
  #[global] import_time_Assumption :: time.Assumptions;
  #[global] import_std_Assumption :: std.Assumptions;
  #[global] import_cryptoffi_Assumption :: cryptoffi.Assumptions;
  #[global] import_hashchain_Assumption :: hashchain.Assumptions;
  #[global] import_merkle_Assumption :: merkle.Assumptions;
}.
End server.
