(* autogenerated from github.com/sanjit-bhat/pav/server *)
Require Export New.code.github_com.goose_lang.std.
Require Export New.code.github_com.sanjit_bhat.pav.advrpc.
Require Export New.code.github_com.sanjit_bhat.pav.cryptoffi.
Require Export New.code.github_com.sanjit_bhat.pav.hashchain.
Require Export New.code.github_com.sanjit_bhat.pav.ktcore.
Require Export New.code.github_com.sanjit_bhat.pav.merkle.
Require Export New.code.github_com.sanjit_bhat.pav.safemarshal.
Require Export New.code.github_com.tchajed.marshal.
Require Export New.code.sync.
Require Export New.code.time.

From New.golang Require Import defn.
Definition server : go_string := "github.com/sanjit-bhat/pav/server".

Module server.

Module Server. Definition id : go_string := "github.com/sanjit-bhat/pav/server.Server"%go. End Server.
Module StartChain. Definition id : go_string := "github.com/sanjit-bhat/pav/server.StartChain"%go. End StartChain.
Module StartVrf. Definition id : go_string := "github.com/sanjit-bhat/pav/server.StartVrf"%go. End StartVrf.
Module StartReply. Definition id : go_string := "github.com/sanjit-bhat/pav/server.StartReply"%go. End StartReply.
Module PutArg. Definition id : go_string := "github.com/sanjit-bhat/pav/server.PutArg"%go. End PutArg.
Module HistoryArg. Definition id : go_string := "github.com/sanjit-bhat/pav/server.HistoryArg"%go. End HistoryArg.
Module HistoryReply. Definition id : go_string := "github.com/sanjit-bhat/pav/server.HistoryReply"%go. End HistoryReply.
Module AuditArg. Definition id : go_string := "github.com/sanjit-bhat/pav/server.AuditArg"%go. End AuditArg.
Module AuditReply. Definition id : go_string := "github.com/sanjit-bhat/pav/server.AuditReply"%go. End AuditReply.
Module secrets. Definition id : go_string := "github.com/sanjit-bhat/pav/server.secrets"%go. End secrets.
Module keyStore. Definition id : go_string := "github.com/sanjit-bhat/pav/server.keyStore"%go. End keyStore.
Module history. Definition id : go_string := "github.com/sanjit-bhat/pav/server.history"%go. End history.
Module Work. Definition id : go_string := "github.com/sanjit-bhat/pav/server.Work"%go. End Work.
Module mapEntry. Definition id : go_string := "github.com/sanjit-bhat/pav/server.mapEntry"%go. End mapEntry.

Section code.
Context `{ffi_syntax}.


Definition StartRpc : val := #(W64 0).

Definition PutRpc : val := #(W64 1).

Definition HistoryRpc : val := #(W64 2).

Definition AuditRpc : val := #(W64 3).

Definition NewRpcServer : go_string := "github.com/sanjit-bhat/pav/server.NewRpcServer"%go.

Definition AuditReplyEncode : go_string := "github.com/sanjit-bhat/pav/server.AuditReplyEncode"%go.

Definition AuditReply : go_type := structT [
  "P" :: sliceT;
  "Err" :: boolT
].
#[global] Typeclasses Opaque AuditReply.
#[global] Opaque AuditReply.

Definition AuditArg : go_type := structT [
  "PrevEpoch" :: uint64T
].
#[global] Typeclasses Opaque AuditArg.
#[global] Opaque AuditArg.

Definition AuditArgDecode : go_string := "github.com/sanjit-bhat/pav/server.AuditArgDecode"%go.

Definition HistoryReplyEncode : go_string := "github.com/sanjit-bhat/pav/server.HistoryReplyEncode"%go.

Definition HistoryReply : go_type := structT [
  "ChainProof" :: sliceT;
  "LinkSig" :: sliceT;
  "Hist" :: sliceT;
  "Bound" :: ptrT;
  "Err" :: boolT
].
#[global] Typeclasses Opaque HistoryReply.
#[global] Opaque HistoryReply.

Definition HistoryArg : go_type := structT [
  "Uid" :: uint64T;
  "PrevEpoch" :: uint64T;
  "PrevVerLen" :: uint64T
].
#[global] Typeclasses Opaque HistoryArg.
#[global] Opaque HistoryArg.

Definition HistoryArgDecode : go_string := "github.com/sanjit-bhat/pav/server.HistoryArgDecode"%go.

Definition PutArg : go_type := structT [
  "Uid" :: uint64T;
  "Pk" :: sliceT;
  "Ver" :: uint64T
].
#[global] Typeclasses Opaque PutArg.
#[global] Opaque PutArg.

Definition PutArgDecode : go_string := "github.com/sanjit-bhat/pav/server.PutArgDecode"%go.

Definition StartReplyEncode : go_string := "github.com/sanjit-bhat/pav/server.StartReplyEncode"%go.

Definition StartReply : go_type := structT [
  "Chain" :: ptrT;
  "Vrf" :: ptrT
].
#[global] Typeclasses Opaque StartReply.
#[global] Opaque StartReply.

(* go: rpc.go:15:6 *)
Definition NewRpcServerⁱᵐᵖˡ : val :=
  λ: "s",
    exception_do (let: "s" := (mem.alloc "s") in
    let: "h" := (mem.alloc (type.zero_val (type.mapT #uint64T #funcT))) in
    let: "$r0" := (map.make #uint64T #funcT) in
    do:  ("h" <-[type.mapT #uint64T #funcT] "$r0");;;
    let: "$r0" := (λ: "arg" "reply",
      exception_do (let: "reply" := (mem.alloc "reply") in
      let: "arg" := (mem.alloc "arg") in
      let: "r1" := (mem.alloc (type.zero_val #ptrT)) in
      let: "r0" := (mem.alloc (type.zero_val #ptrT)) in
      let: ("$ret0", "$ret1") := ((method_call #(ptrT.id Server.id) #"Start"%go (![#ptrT] "s")) #()) in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("r0" <-[#ptrT] "$r0");;;
      do:  ("r1" <-[#ptrT] "$r1");;;
      let: "r" := (mem.alloc (type.zero_val #ptrT)) in
      let: "$r0" := (mem.alloc (let: "$Chain" := (![#ptrT] "r0") in
      let: "$Vrf" := (![#ptrT] "r1") in
      struct.make #StartReply [{
        "Chain" ::= "$Chain";
        "Vrf" ::= "$Vrf"
      }])) in
      do:  ("r" <-[#ptrT] "$r0");;;
      let: "$r0" := (let: "$a0" := (![#sliceT] (![#ptrT] "reply")) in
      let: "$a1" := (![#ptrT] "r") in
      (func_call #StartReplyEncode) "$a0" "$a1") in
      do:  ((![#ptrT] "reply") <-[#sliceT] "$r0");;;
      return: #())
      ) in
    do:  (map.insert (![type.mapT #uint64T #funcT] "h") StartRpc "$r0");;;
    let: "$r0" := (λ: "arg" "reply",
      exception_do (let: "reply" := (mem.alloc "reply") in
      let: "arg" := (mem.alloc "arg") in
      let: "err" := (mem.alloc (type.zero_val #boolT)) in
      let: "a" := (mem.alloc (type.zero_val #ptrT)) in
      let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "arg") in
      (func_call #PutArgDecode) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      let: "$r2" := "$ret2" in
      do:  ("a" <-[#ptrT] "$r0");;;
      do:  "$r1";;;
      do:  ("err" <-[#boolT] "$r2");;;
      (if: ![#boolT] "err"
      then return: (#())
      else do:  #());;;
      do:  (let: "$a0" := (![#uint64T] (struct.field_ref #PutArg #"Uid"%go (![#ptrT] "a"))) in
      let: "$a1" := (![#sliceT] (struct.field_ref #PutArg #"Pk"%go (![#ptrT] "a"))) in
      let: "$a2" := (![#uint64T] (struct.field_ref #PutArg #"Ver"%go (![#ptrT] "a"))) in
      (method_call #(ptrT.id Server.id) #"Put"%go (![#ptrT] "s")) "$a0" "$a1" "$a2");;;
      let: "$r0" := #slice.nil in
      do:  ((![#ptrT] "reply") <-[#sliceT] "$r0");;;
      return: #())
      ) in
    do:  (map.insert (![type.mapT #uint64T #funcT] "h") PutRpc "$r0");;;
    let: "$r0" := (λ: "arg" "reply",
      exception_do (let: "reply" := (mem.alloc "reply") in
      let: "arg" := (mem.alloc "arg") in
      let: "err" := (mem.alloc (type.zero_val #boolT)) in
      let: "a" := (mem.alloc (type.zero_val #ptrT)) in
      let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "arg") in
      (func_call #HistoryArgDecode) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      let: "$r2" := "$ret2" in
      do:  ("a" <-[#ptrT] "$r0");;;
      do:  "$r1";;;
      do:  ("err" <-[#boolT] "$r2");;;
      (if: ![#boolT] "err"
      then
        let: "r" := (mem.alloc (type.zero_val #ptrT)) in
        let: "$r0" := (mem.alloc (let: "$Err" := #true in
        struct.make #HistoryReply [{
          "ChainProof" ::= type.zero_val #sliceT;
          "LinkSig" ::= type.zero_val #sliceT;
          "Hist" ::= type.zero_val #sliceT;
          "Bound" ::= type.zero_val #ptrT;
          "Err" ::= "$Err"
        }])) in
        do:  ("r" <-[#ptrT] "$r0");;;
        let: "$r0" := (let: "$a0" := (![#sliceT] (![#ptrT] "reply")) in
        let: "$a1" := (![#ptrT] "r") in
        (func_call #HistoryReplyEncode) "$a0" "$a1") in
        do:  ((![#ptrT] "reply") <-[#sliceT] "$r0");;;
        return: (#())
      else do:  #());;;
      let: "r4" := (mem.alloc (type.zero_val #boolT)) in
      let: "r3" := (mem.alloc (type.zero_val #ptrT)) in
      let: "r2" := (mem.alloc (type.zero_val #sliceT)) in
      let: "r1" := (mem.alloc (type.zero_val #sliceT)) in
      let: "r0" := (mem.alloc (type.zero_val #sliceT)) in
      let: (((("$ret0", "$ret1"), "$ret2"), "$ret3"), "$ret4") := (let: "$a0" := (![#uint64T] (struct.field_ref #HistoryArg #"Uid"%go (![#ptrT] "a"))) in
      let: "$a1" := (![#uint64T] (struct.field_ref #HistoryArg #"PrevEpoch"%go (![#ptrT] "a"))) in
      let: "$a2" := (![#uint64T] (struct.field_ref #HistoryArg #"PrevVerLen"%go (![#ptrT] "a"))) in
      (method_call #(ptrT.id Server.id) #"History"%go (![#ptrT] "s")) "$a0" "$a1" "$a2") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      let: "$r2" := "$ret2" in
      let: "$r3" := "$ret3" in
      let: "$r4" := "$ret4" in
      do:  ("r0" <-[#sliceT] "$r0");;;
      do:  ("r1" <-[#sliceT] "$r1");;;
      do:  ("r2" <-[#sliceT] "$r2");;;
      do:  ("r3" <-[#ptrT] "$r3");;;
      do:  ("r4" <-[#boolT] "$r4");;;
      let: "r" := (mem.alloc (type.zero_val #ptrT)) in
      let: "$r0" := (mem.alloc (let: "$ChainProof" := (![#sliceT] "r0") in
      let: "$LinkSig" := (![#sliceT] "r1") in
      let: "$Hist" := (![#sliceT] "r2") in
      let: "$Bound" := (![#ptrT] "r3") in
      let: "$Err" := (![#boolT] "r4") in
      struct.make #HistoryReply [{
        "ChainProof" ::= "$ChainProof";
        "LinkSig" ::= "$LinkSig";
        "Hist" ::= "$Hist";
        "Bound" ::= "$Bound";
        "Err" ::= "$Err"
      }])) in
      do:  ("r" <-[#ptrT] "$r0");;;
      let: "$r0" := (let: "$a0" := (![#sliceT] (![#ptrT] "reply")) in
      let: "$a1" := (![#ptrT] "r") in
      (func_call #HistoryReplyEncode) "$a0" "$a1") in
      do:  ((![#ptrT] "reply") <-[#sliceT] "$r0");;;
      return: #())
      ) in
    do:  (map.insert (![type.mapT #uint64T #funcT] "h") HistoryRpc "$r0");;;
    let: "$r0" := (λ: "arg" "reply",
      exception_do (let: "reply" := (mem.alloc "reply") in
      let: "arg" := (mem.alloc "arg") in
      let: "err" := (mem.alloc (type.zero_val #boolT)) in
      let: "a" := (mem.alloc (type.zero_val #ptrT)) in
      let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "arg") in
      (func_call #AuditArgDecode) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      let: "$r2" := "$ret2" in
      do:  ("a" <-[#ptrT] "$r0");;;
      do:  "$r1";;;
      do:  ("err" <-[#boolT] "$r2");;;
      (if: ![#boolT] "err"
      then
        let: "r" := (mem.alloc (type.zero_val #ptrT)) in
        let: "$r0" := (mem.alloc (let: "$Err" := #true in
        struct.make #AuditReply [{
          "P" ::= type.zero_val #sliceT;
          "Err" ::= "$Err"
        }])) in
        do:  ("r" <-[#ptrT] "$r0");;;
        let: "$r0" := (let: "$a0" := (![#sliceT] (![#ptrT] "reply")) in
        let: "$a1" := (![#ptrT] "r") in
        (func_call #AuditReplyEncode) "$a0" "$a1") in
        do:  ((![#ptrT] "reply") <-[#sliceT] "$r0");;;
        return: (#())
      else do:  #());;;
      let: "r1" := (mem.alloc (type.zero_val #boolT)) in
      let: "r0" := (mem.alloc (type.zero_val #sliceT)) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![#uint64T] (struct.field_ref #AuditArg #"PrevEpoch"%go (![#ptrT] "a"))) in
      (method_call #(ptrT.id Server.id) #"Audit"%go (![#ptrT] "s")) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("r0" <-[#sliceT] "$r0");;;
      do:  ("r1" <-[#boolT] "$r1");;;
      let: "r" := (mem.alloc (type.zero_val #ptrT)) in
      let: "$r0" := (mem.alloc (let: "$P" := (![#sliceT] "r0") in
      let: "$Err" := (![#boolT] "r1") in
      struct.make #AuditReply [{
        "P" ::= "$P";
        "Err" ::= "$Err"
      }])) in
      do:  ("r" <-[#ptrT] "$r0");;;
      let: "$r0" := (let: "$a0" := (![#sliceT] (![#ptrT] "reply")) in
      let: "$a1" := (![#ptrT] "r") in
      (func_call #AuditReplyEncode) "$a0" "$a1") in
      do:  ((![#ptrT] "reply") <-[#sliceT] "$r0");;;
      return: #())
      ) in
    do:  (map.insert (![type.mapT #uint64T #funcT] "h") AuditRpc "$r0");;;
    return: (let: "$a0" := (![type.mapT #uint64T #funcT] "h") in
     (func_call #advrpc.NewServer) "$a0")).

Definition CallStart : go_string := "github.com/sanjit-bhat/pav/server.CallStart"%go.

Definition StartReplyDecode : go_string := "github.com/sanjit-bhat/pav/server.StartReplyDecode"%go.

(* go: rpc.go:56:6 *)
Definition CallStartⁱᵐᵖˡ : val :=
  λ: "c",
    exception_do (let: "err" := (mem.alloc (type.zero_val #ktcore.Blame)) in
    let: "vrf" := (mem.alloc (type.zero_val #ptrT)) in
    let: "chain" := (mem.alloc (type.zero_val #ptrT)) in
    let: "c" := (mem.alloc "c") in
    let: "rb" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #sliceT)) in
    do:  ("rb" <-[#ptrT] "$r0");;;
    (if: let: "$a0" := StartRpc in
    let: "$a1" := #slice.nil in
    let: "$a2" := (![#ptrT] "rb") in
    (method_call #(ptrT.id advrpc.Client.id) #"Call"%go (![#ptrT] "c")) "$a0" "$a1" "$a2"
    then
      let: "$r0" := ktcore.BlameUnknown in
      do:  ("err" <-[#ktcore.Blame] "$r0");;;
      return: (![#ptrT] "chain", ![#ptrT] "vrf", ![#ktcore.Blame] "err")
    else do:  #());;;
    let: "errb" := (mem.alloc (type.zero_val #boolT)) in
    let: "r" := (mem.alloc (type.zero_val #ptrT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] (![#ptrT] "rb")) in
    (func_call #StartReplyDecode) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("r" <-[#ptrT] "$r0");;;
    do:  "$r1";;;
    do:  ("errb" <-[#boolT] "$r2");;;
    let: "$r0" := (![#ptrT] (struct.field_ref #StartReply #"Chain"%go (![#ptrT] "r"))) in
    do:  ("chain" <-[#ptrT] "$r0");;;
    let: "$r0" := (![#ptrT] (struct.field_ref #StartReply #"Vrf"%go (![#ptrT] "r"))) in
    do:  ("vrf" <-[#ptrT] "$r0");;;
    (if: ![#boolT] "errb"
    then
      let: "$r0" := ktcore.BlameServFull in
      do:  ("err" <-[#ktcore.Blame] "$r0");;;
      return: (![#ptrT] "chain", ![#ptrT] "vrf", ![#ktcore.Blame] "err")
    else do:  #());;;
    return: (![#ptrT] "chain", ![#ptrT] "vrf", ![#ktcore.Blame] "err")).

Definition CallPut : go_string := "github.com/sanjit-bhat/pav/server.CallPut"%go.

Definition PutArgEncode : go_string := "github.com/sanjit-bhat/pav/server.PutArgEncode"%go.

(* go: rpc.go:72:6 *)
Definition CallPutⁱᵐᵖˡ : val :=
  λ: "c" "uid" "pk" "ver",
    exception_do (let: "ver" := (mem.alloc "ver") in
    let: "pk" := (mem.alloc "pk") in
    let: "uid" := (mem.alloc "uid") in
    let: "c" := (mem.alloc "c") in
    let: "a" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (let: "$Uid" := (![#uint64T] "uid") in
    let: "$Pk" := (![#sliceT] "pk") in
    let: "$Ver" := (![#uint64T] "ver") in
    struct.make #PutArg [{
      "Uid" ::= "$Uid";
      "Pk" ::= "$Pk";
      "Ver" ::= "$Ver"
    }])) in
    do:  ("a" <-[#ptrT] "$r0");;;
    let: "ab" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := #slice.nil in
    let: "$a1" := (![#ptrT] "a") in
    (func_call #PutArgEncode) "$a0" "$a1") in
    do:  ("ab" <-[#sliceT] "$r0");;;
    let: "rb" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #sliceT)) in
    do:  ("rb" <-[#ptrT] "$r0");;;
    do:  (let: "$a0" := PutRpc in
    let: "$a1" := (![#sliceT] "ab") in
    let: "$a2" := (![#ptrT] "rb") in
    (method_call #(ptrT.id advrpc.Client.id) #"Call"%go (![#ptrT] "c")) "$a0" "$a1" "$a2");;;
    return: #()).

Definition CallHistory : go_string := "github.com/sanjit-bhat/pav/server.CallHistory"%go.

Definition HistoryReplyDecode : go_string := "github.com/sanjit-bhat/pav/server.HistoryReplyDecode"%go.

Definition HistoryArgEncode : go_string := "github.com/sanjit-bhat/pav/server.HistoryArgEncode"%go.

(* go: rpc.go:80:6 *)
Definition CallHistoryⁱᵐᵖˡ : val :=
  λ: "c" "uid" "prevEpoch" "prevVerLen",
    exception_do (let: "err" := (mem.alloc (type.zero_val #ktcore.Blame)) in
    let: "bound" := (mem.alloc (type.zero_val #ptrT)) in
    let: "hist" := (mem.alloc (type.zero_val #sliceT)) in
    let: "linkSig" := (mem.alloc (type.zero_val #sliceT)) in
    let: "chainProof" := (mem.alloc (type.zero_val #sliceT)) in
    let: "prevVerLen" := (mem.alloc "prevVerLen") in
    let: "prevEpoch" := (mem.alloc "prevEpoch") in
    let: "uid" := (mem.alloc "uid") in
    let: "c" := (mem.alloc "c") in
    let: "a" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (let: "$Uid" := (![#uint64T] "uid") in
    let: "$PrevEpoch" := (![#uint64T] "prevEpoch") in
    let: "$PrevVerLen" := (![#uint64T] "prevVerLen") in
    struct.make #HistoryArg [{
      "Uid" ::= "$Uid";
      "PrevEpoch" ::= "$PrevEpoch";
      "PrevVerLen" ::= "$PrevVerLen"
    }])) in
    do:  ("a" <-[#ptrT] "$r0");;;
    let: "ab" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := #slice.nil in
    let: "$a1" := (![#ptrT] "a") in
    (func_call #HistoryArgEncode) "$a0" "$a1") in
    do:  ("ab" <-[#sliceT] "$r0");;;
    let: "rb" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #sliceT)) in
    do:  ("rb" <-[#ptrT] "$r0");;;
    (if: let: "$a0" := HistoryRpc in
    let: "$a1" := (![#sliceT] "ab") in
    let: "$a2" := (![#ptrT] "rb") in
    (method_call #(ptrT.id advrpc.Client.id) #"Call"%go (![#ptrT] "c")) "$a0" "$a1" "$a2"
    then
      let: "$r0" := ktcore.BlameUnknown in
      do:  ("err" <-[#ktcore.Blame] "$r0");;;
      return: (![#sliceT] "chainProof", ![#sliceT] "linkSig", ![#sliceT] "hist", ![#ptrT] "bound", ![#ktcore.Blame] "err")
    else do:  #());;;
    let: "errb" := (mem.alloc (type.zero_val #boolT)) in
    let: "r" := (mem.alloc (type.zero_val #ptrT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] (![#ptrT] "rb")) in
    (func_call #HistoryReplyDecode) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("r" <-[#ptrT] "$r0");;;
    do:  "$r1";;;
    do:  ("errb" <-[#boolT] "$r2");;;
    (if: ![#boolT] "errb"
    then
      let: "$r0" := ktcore.BlameServFull in
      do:  ("err" <-[#ktcore.Blame] "$r0");;;
      return: (![#sliceT] "chainProof", ![#sliceT] "linkSig", ![#sliceT] "hist", ![#ptrT] "bound", ![#ktcore.Blame] "err")
    else do:  #());;;
    (if: ![#boolT] (struct.field_ref #HistoryReply #"Err"%go (![#ptrT] "r"))
    then
      let: "$r0" := ktcore.BlameServFull in
      do:  ("err" <-[#ktcore.Blame] "$r0");;;
      return: (![#sliceT] "chainProof", ![#sliceT] "linkSig", ![#sliceT] "hist", ![#ptrT] "bound", ![#ktcore.Blame] "err")
    else do:  #());;;
    return: (![#sliceT] (struct.field_ref #HistoryReply #"ChainProof"%go (![#ptrT] "r")), ![#sliceT] (struct.field_ref #HistoryReply #"LinkSig"%go (![#ptrT] "r")), ![#sliceT] (struct.field_ref #HistoryReply #"Hist"%go (![#ptrT] "r")), ![#ptrT] (struct.field_ref #HistoryReply #"Bound"%go (![#ptrT] "r")), ktcore.BlameNone)).

Definition CallAudit : go_string := "github.com/sanjit-bhat/pav/server.CallAudit"%go.

Definition AuditReplyDecode : go_string := "github.com/sanjit-bhat/pav/server.AuditReplyDecode"%go.

Definition AuditArgEncode : go_string := "github.com/sanjit-bhat/pav/server.AuditArgEncode"%go.

(* go: rpc.go:100:6 *)
Definition CallAuditⁱᵐᵖˡ : val :=
  λ: "c" "prevEpoch",
    exception_do (let: "err" := (mem.alloc (type.zero_val #ktcore.Blame)) in
    let: "p" := (mem.alloc (type.zero_val #sliceT)) in
    let: "prevEpoch" := (mem.alloc "prevEpoch") in
    let: "c" := (mem.alloc "c") in
    let: "a" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (let: "$PrevEpoch" := (![#uint64T] "prevEpoch") in
    struct.make #AuditArg [{
      "PrevEpoch" ::= "$PrevEpoch"
    }])) in
    do:  ("a" <-[#ptrT] "$r0");;;
    let: "ab" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := #slice.nil in
    let: "$a1" := (![#ptrT] "a") in
    (func_call #AuditArgEncode) "$a0" "$a1") in
    do:  ("ab" <-[#sliceT] "$r0");;;
    let: "rb" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #sliceT)) in
    do:  ("rb" <-[#ptrT] "$r0");;;
    (if: let: "$a0" := AuditRpc in
    let: "$a1" := (![#sliceT] "ab") in
    let: "$a2" := (![#ptrT] "rb") in
    (method_call #(ptrT.id advrpc.Client.id) #"Call"%go (![#ptrT] "c")) "$a0" "$a1" "$a2"
    then
      let: "$r0" := ktcore.BlameUnknown in
      do:  ("err" <-[#ktcore.Blame] "$r0");;;
      return: (![#sliceT] "p", ![#ktcore.Blame] "err")
    else do:  #());;;
    let: "errb" := (mem.alloc (type.zero_val #boolT)) in
    let: "r" := (mem.alloc (type.zero_val #ptrT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] (![#ptrT] "rb")) in
    (func_call #AuditReplyDecode) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("r" <-[#ptrT] "$r0");;;
    do:  "$r1";;;
    do:  ("errb" <-[#boolT] "$r2");;;
    (if: ![#boolT] "errb"
    then
      let: "$r0" := ktcore.BlameServFull in
      do:  ("err" <-[#ktcore.Blame] "$r0");;;
      return: (![#sliceT] "p", ![#ktcore.Blame] "err")
    else do:  #());;;
    (if: ![#boolT] (struct.field_ref #AuditReply #"Err"%go (![#ptrT] "r"))
    then
      let: "$r0" := ktcore.BlameServFull in
      do:  ("err" <-[#ktcore.Blame] "$r0");;;
      return: (![#sliceT] "p", ![#ktcore.Blame] "err")
    else do:  #());;;
    return: (![#sliceT] (struct.field_ref #AuditReply #"P"%go (![#ptrT] "r")), ktcore.BlameNone)).

Definition StartChain : go_type := structT [
  "PrevEpochLen" :: uint64T;
  "PrevLink" :: sliceT;
  "ChainProof" :: sliceT;
  "LinkSig" :: sliceT
].
#[global] Typeclasses Opaque StartChain.
#[global] Opaque StartChain.

Definition StartVrf : go_type := structT [
  "VrfPk" :: sliceT;
  "VrfSig" :: sliceT
].
#[global] Typeclasses Opaque StartVrf.
#[global] Opaque StartVrf.

Definition StartChainEncode : go_string := "github.com/sanjit-bhat/pav/server.StartChainEncode"%go.

(* go: serde.out.go:9:6 *)
Definition StartChainEncodeⁱᵐᵖˡ : val :=
  λ: "b0" "o",
    exception_do (let: "o" := (mem.alloc "o") in
    let: "b0" := (mem.alloc "b0") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "b0") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#uint64T] (struct.field_ref #StartChain #"PrevEpochLen"%go (![#ptrT] "o"))) in
    (func_call #marshal.WriteInt) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#sliceT] (struct.field_ref #StartChain #"PrevLink"%go (![#ptrT] "o"))) in
    (func_call #safemarshal.WriteSlice1D) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#sliceT] (struct.field_ref #StartChain #"ChainProof"%go (![#ptrT] "o"))) in
    (func_call #safemarshal.WriteSlice1D) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#sliceT] (struct.field_ref #StartChain #"LinkSig"%go (![#ptrT] "o"))) in
    (func_call #safemarshal.WriteSlice1D) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "b")).

Definition StartChainDecode : go_string := "github.com/sanjit-bhat/pav/server.StartChainDecode"%go.

(* go: serde.out.go:17:6 *)
Definition StartChainDecodeⁱᵐᵖˡ : val :=
  λ: "b0",
    exception_do (let: "b0" := (mem.alloc "b0") in
    let: "err1" := (mem.alloc (type.zero_val #boolT)) in
    let: "b1" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a1" := (mem.alloc (type.zero_val #uint64T)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b0") in
    (func_call #safemarshal.ReadInt) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a1" <-[#uint64T] "$r0");;;
    do:  ("b1" <-[#sliceT] "$r1");;;
    do:  ("err1" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err1"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err2" := (mem.alloc (type.zero_val #boolT)) in
    let: "b2" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a2" := (mem.alloc (type.zero_val #sliceT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b1") in
    (func_call #safemarshal.ReadSlice1D) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a2" <-[#sliceT] "$r0");;;
    do:  ("b2" <-[#sliceT] "$r1");;;
    do:  ("err2" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err2"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err3" := (mem.alloc (type.zero_val #boolT)) in
    let: "b3" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a3" := (mem.alloc (type.zero_val #sliceT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b2") in
    (func_call #safemarshal.ReadSlice1D) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a3" <-[#sliceT] "$r0");;;
    do:  ("b3" <-[#sliceT] "$r1");;;
    do:  ("err3" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err3"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err4" := (mem.alloc (type.zero_val #boolT)) in
    let: "b4" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a4" := (mem.alloc (type.zero_val #sliceT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b3") in
    (func_call #safemarshal.ReadSlice1D) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a4" <-[#sliceT] "$r0");;;
    do:  ("b4" <-[#sliceT] "$r1");;;
    do:  ("err4" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err4"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    return: (mem.alloc (let: "$PrevEpochLen" := (![#uint64T] "a1") in
     let: "$PrevLink" := (![#sliceT] "a2") in
     let: "$ChainProof" := (![#sliceT] "a3") in
     let: "$LinkSig" := (![#sliceT] "a4") in
     struct.make #StartChain [{
       "PrevEpochLen" ::= "$PrevEpochLen";
       "PrevLink" ::= "$PrevLink";
       "ChainProof" ::= "$ChainProof";
       "LinkSig" ::= "$LinkSig"
     }]), ![#sliceT] "b4", #false)).

Definition StartVrfEncode : go_string := "github.com/sanjit-bhat/pav/server.StartVrfEncode"%go.

(* go: serde.out.go:36:6 *)
Definition StartVrfEncodeⁱᵐᵖˡ : val :=
  λ: "b0" "o",
    exception_do (let: "o" := (mem.alloc "o") in
    let: "b0" := (mem.alloc "b0") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "b0") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#sliceT] (struct.field_ref #StartVrf #"VrfPk"%go (![#ptrT] "o"))) in
    (func_call #safemarshal.WriteSlice1D) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#sliceT] (struct.field_ref #StartVrf #"VrfSig"%go (![#ptrT] "o"))) in
    (func_call #safemarshal.WriteSlice1D) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "b")).

Definition StartVrfDecode : go_string := "github.com/sanjit-bhat/pav/server.StartVrfDecode"%go.

(* go: serde.out.go:42:6 *)
Definition StartVrfDecodeⁱᵐᵖˡ : val :=
  λ: "b0",
    exception_do (let: "b0" := (mem.alloc "b0") in
    let: "err1" := (mem.alloc (type.zero_val #boolT)) in
    let: "b1" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a1" := (mem.alloc (type.zero_val #sliceT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b0") in
    (func_call #safemarshal.ReadSlice1D) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a1" <-[#sliceT] "$r0");;;
    do:  ("b1" <-[#sliceT] "$r1");;;
    do:  ("err1" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err1"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err2" := (mem.alloc (type.zero_val #boolT)) in
    let: "b2" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a2" := (mem.alloc (type.zero_val #sliceT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b1") in
    (func_call #safemarshal.ReadSlice1D) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a2" <-[#sliceT] "$r0");;;
    do:  ("b2" <-[#sliceT] "$r1");;;
    do:  ("err2" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err2"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    return: (mem.alloc (let: "$VrfPk" := (![#sliceT] "a1") in
     let: "$VrfSig" := (![#sliceT] "a2") in
     struct.make #StartVrf [{
       "VrfPk" ::= "$VrfPk";
       "VrfSig" ::= "$VrfSig"
     }]), ![#sliceT] "b2", #false)).

(* go: serde.out.go:53:6 *)
Definition StartReplyEncodeⁱᵐᵖˡ : val :=
  λ: "b0" "o",
    exception_do (let: "o" := (mem.alloc "o") in
    let: "b0" := (mem.alloc "b0") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "b0") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#ptrT] (struct.field_ref #StartReply #"Chain"%go (![#ptrT] "o"))) in
    (func_call #StartChainEncode) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#ptrT] (struct.field_ref #StartReply #"Vrf"%go (![#ptrT] "o"))) in
    (func_call #StartVrfEncode) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "b")).

(* go: serde.out.go:59:6 *)
Definition StartReplyDecodeⁱᵐᵖˡ : val :=
  λ: "b0",
    exception_do (let: "b0" := (mem.alloc "b0") in
    let: "err1" := (mem.alloc (type.zero_val #boolT)) in
    let: "b1" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a1" := (mem.alloc (type.zero_val #ptrT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b0") in
    (func_call #StartChainDecode) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a1" <-[#ptrT] "$r0");;;
    do:  ("b1" <-[#sliceT] "$r1");;;
    do:  ("err1" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err1"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err2" := (mem.alloc (type.zero_val #boolT)) in
    let: "b2" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a2" := (mem.alloc (type.zero_val #ptrT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b1") in
    (func_call #StartVrfDecode) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a2" <-[#ptrT] "$r0");;;
    do:  ("b2" <-[#sliceT] "$r1");;;
    do:  ("err2" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err2"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    return: (mem.alloc (let: "$Chain" := (![#ptrT] "a1") in
     let: "$Vrf" := (![#ptrT] "a2") in
     struct.make #StartReply [{
       "Chain" ::= "$Chain";
       "Vrf" ::= "$Vrf"
     }]), ![#sliceT] "b2", #false)).

(* go: serde.out.go:70:6 *)
Definition PutArgEncodeⁱᵐᵖˡ : val :=
  λ: "b0" "o",
    exception_do (let: "o" := (mem.alloc "o") in
    let: "b0" := (mem.alloc "b0") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "b0") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#uint64T] (struct.field_ref #PutArg #"Uid"%go (![#ptrT] "o"))) in
    (func_call #marshal.WriteInt) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#sliceT] (struct.field_ref #PutArg #"Pk"%go (![#ptrT] "o"))) in
    (func_call #safemarshal.WriteSlice1D) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#uint64T] (struct.field_ref #PutArg #"Ver"%go (![#ptrT] "o"))) in
    (func_call #marshal.WriteInt) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "b")).

(* go: serde.out.go:77:6 *)
Definition PutArgDecodeⁱᵐᵖˡ : val :=
  λ: "b0",
    exception_do (let: "b0" := (mem.alloc "b0") in
    let: "err1" := (mem.alloc (type.zero_val #boolT)) in
    let: "b1" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a1" := (mem.alloc (type.zero_val #uint64T)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b0") in
    (func_call #safemarshal.ReadInt) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a1" <-[#uint64T] "$r0");;;
    do:  ("b1" <-[#sliceT] "$r1");;;
    do:  ("err1" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err1"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err2" := (mem.alloc (type.zero_val #boolT)) in
    let: "b2" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a2" := (mem.alloc (type.zero_val #sliceT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b1") in
    (func_call #safemarshal.ReadSlice1D) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a2" <-[#sliceT] "$r0");;;
    do:  ("b2" <-[#sliceT] "$r1");;;
    do:  ("err2" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err2"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err3" := (mem.alloc (type.zero_val #boolT)) in
    let: "b3" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a3" := (mem.alloc (type.zero_val #uint64T)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b2") in
    (func_call #safemarshal.ReadInt) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a3" <-[#uint64T] "$r0");;;
    do:  ("b3" <-[#sliceT] "$r1");;;
    do:  ("err3" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err3"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    return: (mem.alloc (let: "$Uid" := (![#uint64T] "a1") in
     let: "$Pk" := (![#sliceT] "a2") in
     let: "$Ver" := (![#uint64T] "a3") in
     struct.make #PutArg [{
       "Uid" ::= "$Uid";
       "Pk" ::= "$Pk";
       "Ver" ::= "$Ver"
     }]), ![#sliceT] "b3", #false)).

(* go: serde.out.go:92:6 *)
Definition HistoryArgEncodeⁱᵐᵖˡ : val :=
  λ: "b0" "o",
    exception_do (let: "o" := (mem.alloc "o") in
    let: "b0" := (mem.alloc "b0") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "b0") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#uint64T] (struct.field_ref #HistoryArg #"Uid"%go (![#ptrT] "o"))) in
    (func_call #marshal.WriteInt) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#uint64T] (struct.field_ref #HistoryArg #"PrevEpoch"%go (![#ptrT] "o"))) in
    (func_call #marshal.WriteInt) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#uint64T] (struct.field_ref #HistoryArg #"PrevVerLen"%go (![#ptrT] "o"))) in
    (func_call #marshal.WriteInt) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "b")).

(* go: serde.out.go:99:6 *)
Definition HistoryArgDecodeⁱᵐᵖˡ : val :=
  λ: "b0",
    exception_do (let: "b0" := (mem.alloc "b0") in
    let: "err1" := (mem.alloc (type.zero_val #boolT)) in
    let: "b1" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a1" := (mem.alloc (type.zero_val #uint64T)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b0") in
    (func_call #safemarshal.ReadInt) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a1" <-[#uint64T] "$r0");;;
    do:  ("b1" <-[#sliceT] "$r1");;;
    do:  ("err1" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err1"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err2" := (mem.alloc (type.zero_val #boolT)) in
    let: "b2" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a2" := (mem.alloc (type.zero_val #uint64T)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b1") in
    (func_call #safemarshal.ReadInt) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a2" <-[#uint64T] "$r0");;;
    do:  ("b2" <-[#sliceT] "$r1");;;
    do:  ("err2" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err2"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err3" := (mem.alloc (type.zero_val #boolT)) in
    let: "b3" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a3" := (mem.alloc (type.zero_val #uint64T)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b2") in
    (func_call #safemarshal.ReadInt) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a3" <-[#uint64T] "$r0");;;
    do:  ("b3" <-[#sliceT] "$r1");;;
    do:  ("err3" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err3"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    return: (mem.alloc (let: "$Uid" := (![#uint64T] "a1") in
     let: "$PrevEpoch" := (![#uint64T] "a2") in
     let: "$PrevVerLen" := (![#uint64T] "a3") in
     struct.make #HistoryArg [{
       "Uid" ::= "$Uid";
       "PrevEpoch" ::= "$PrevEpoch";
       "PrevVerLen" ::= "$PrevVerLen"
     }]), ![#sliceT] "b3", #false)).

(* go: serde.out.go:114:6 *)
Definition HistoryReplyEncodeⁱᵐᵖˡ : val :=
  λ: "b0" "o",
    exception_do (let: "o" := (mem.alloc "o") in
    let: "b0" := (mem.alloc "b0") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "b0") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#sliceT] (struct.field_ref #HistoryReply #"ChainProof"%go (![#ptrT] "o"))) in
    (func_call #safemarshal.WriteSlice1D) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#sliceT] (struct.field_ref #HistoryReply #"LinkSig"%go (![#ptrT] "o"))) in
    (func_call #safemarshal.WriteSlice1D) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#sliceT] (struct.field_ref #HistoryReply #"Hist"%go (![#ptrT] "o"))) in
    (func_call #ktcore.MembSlice1DEncode) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#ptrT] (struct.field_ref #HistoryReply #"Bound"%go (![#ptrT] "o"))) in
    (func_call #ktcore.NonMembEncode) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#boolT] (struct.field_ref #HistoryReply #"Err"%go (![#ptrT] "o"))) in
    (func_call #marshal.WriteBool) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "b")).

(* go: serde.out.go:123:6 *)
Definition HistoryReplyDecodeⁱᵐᵖˡ : val :=
  λ: "b0",
    exception_do (let: "b0" := (mem.alloc "b0") in
    let: "err1" := (mem.alloc (type.zero_val #boolT)) in
    let: "b1" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a1" := (mem.alloc (type.zero_val #sliceT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b0") in
    (func_call #safemarshal.ReadSlice1D) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a1" <-[#sliceT] "$r0");;;
    do:  ("b1" <-[#sliceT] "$r1");;;
    do:  ("err1" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err1"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err2" := (mem.alloc (type.zero_val #boolT)) in
    let: "b2" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a2" := (mem.alloc (type.zero_val #sliceT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b1") in
    (func_call #safemarshal.ReadSlice1D) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a2" <-[#sliceT] "$r0");;;
    do:  ("b2" <-[#sliceT] "$r1");;;
    do:  ("err2" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err2"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err3" := (mem.alloc (type.zero_val #boolT)) in
    let: "b3" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a3" := (mem.alloc (type.zero_val #sliceT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b2") in
    (func_call #ktcore.MembSlice1DDecode) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a3" <-[#sliceT] "$r0");;;
    do:  ("b3" <-[#sliceT] "$r1");;;
    do:  ("err3" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err3"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err4" := (mem.alloc (type.zero_val #boolT)) in
    let: "b4" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a4" := (mem.alloc (type.zero_val #ptrT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b3") in
    (func_call #ktcore.NonMembDecode) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a4" <-[#ptrT] "$r0");;;
    do:  ("b4" <-[#sliceT] "$r1");;;
    do:  ("err4" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err4"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err5" := (mem.alloc (type.zero_val #boolT)) in
    let: "b5" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a5" := (mem.alloc (type.zero_val #boolT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b4") in
    (func_call #safemarshal.ReadBool) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a5" <-[#boolT] "$r0");;;
    do:  ("b5" <-[#sliceT] "$r1");;;
    do:  ("err5" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err5"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    return: (mem.alloc (let: "$ChainProof" := (![#sliceT] "a1") in
     let: "$LinkSig" := (![#sliceT] "a2") in
     let: "$Hist" := (![#sliceT] "a3") in
     let: "$Bound" := (![#ptrT] "a4") in
     let: "$Err" := (![#boolT] "a5") in
     struct.make #HistoryReply [{
       "ChainProof" ::= "$ChainProof";
       "LinkSig" ::= "$LinkSig";
       "Hist" ::= "$Hist";
       "Bound" ::= "$Bound";
       "Err" ::= "$Err"
     }]), ![#sliceT] "b5", #false)).

(* go: serde.out.go:146:6 *)
Definition AuditArgEncodeⁱᵐᵖˡ : val :=
  λ: "b0" "o",
    exception_do (let: "o" := (mem.alloc "o") in
    let: "b0" := (mem.alloc "b0") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "b0") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#uint64T] (struct.field_ref #AuditArg #"PrevEpoch"%go (![#ptrT] "o"))) in
    (func_call #marshal.WriteInt) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "b")).

(* go: serde.out.go:151:6 *)
Definition AuditArgDecodeⁱᵐᵖˡ : val :=
  λ: "b0",
    exception_do (let: "b0" := (mem.alloc "b0") in
    let: "err1" := (mem.alloc (type.zero_val #boolT)) in
    let: "b1" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a1" := (mem.alloc (type.zero_val #uint64T)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b0") in
    (func_call #safemarshal.ReadInt) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a1" <-[#uint64T] "$r0");;;
    do:  ("b1" <-[#sliceT] "$r1");;;
    do:  ("err1" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err1"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    return: (mem.alloc (let: "$PrevEpoch" := (![#uint64T] "a1") in
     struct.make #AuditArg [{
       "PrevEpoch" ::= "$PrevEpoch"
     }]), ![#sliceT] "b1", #false)).

(* go: serde.out.go:158:6 *)
Definition AuditReplyEncodeⁱᵐᵖˡ : val :=
  λ: "b0" "o",
    exception_do (let: "o" := (mem.alloc "o") in
    let: "b0" := (mem.alloc "b0") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "b0") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#sliceT] (struct.field_ref #AuditReply #"P"%go (![#ptrT] "o"))) in
    (func_call #ktcore.AuditProofSlice1DEncode) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#boolT] (struct.field_ref #AuditReply #"Err"%go (![#ptrT] "o"))) in
    (func_call #marshal.WriteBool) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "b")).

(* go: serde.out.go:164:6 *)
Definition AuditReplyDecodeⁱᵐᵖˡ : val :=
  λ: "b0",
    exception_do (let: "b0" := (mem.alloc "b0") in
    let: "err1" := (mem.alloc (type.zero_val #boolT)) in
    let: "b1" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a1" := (mem.alloc (type.zero_val #sliceT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b0") in
    (func_call #ktcore.AuditProofSlice1DDecode) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a1" <-[#sliceT] "$r0");;;
    do:  ("b1" <-[#sliceT] "$r1");;;
    do:  ("err1" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err1"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err2" := (mem.alloc (type.zero_val #boolT)) in
    let: "b2" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a2" := (mem.alloc (type.zero_val #boolT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b1") in
    (func_call #safemarshal.ReadBool) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a2" <-[#boolT] "$r0");;;
    do:  ("b2" <-[#sliceT] "$r1");;;
    do:  ("err2" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err2"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    return: (mem.alloc (let: "$P" := (![#sliceT] "a1") in
     let: "$Err" := (![#boolT] "a2") in
     struct.make #AuditReply [{
       "P" ::= "$P";
       "Err" ::= "$Err"
     }]), ![#sliceT] "b2", #false)).

Definition WorkQSize : go_string := "github.com/sanjit-bhat/pav/server.WorkQSize"%go.

Definition BatchSize : go_string := "github.com/sanjit-bhat/pav/server.BatchSize"%go.

Definition BatchTimeout : go_string := "github.com/sanjit-bhat/pav/server.BatchTimeout"%go.

Definition Server : go_type := structT [
  "mu" :: ptrT;
  "secs" :: ptrT;
  "keys" :: ptrT;
  "hist" :: ptrT;
  "workQ" :: chanT ptrT
].
#[global] Typeclasses Opaque Server.
#[global] Opaque Server.

Definition secrets : go_type := structT [
  "sig" :: ptrT;
  "vrf" :: ptrT;
  "commit" :: sliceT
].
#[global] Typeclasses Opaque secrets.
#[global] Opaque secrets.

Definition keyStore : go_type := structT [
  "hidden" :: ptrT;
  "plain" :: mapT uint64T sliceT
].
#[global] Typeclasses Opaque keyStore.
#[global] Opaque keyStore.

Definition history : go_type := structT [
  "chain" :: ptrT;
  "audits" :: sliceT;
  "vrfPkSig" :: sliceT
].
#[global] Typeclasses Opaque history.
#[global] Opaque history.

(* Start bootstraps a party with knowledge of the last hash
   in the hashchain and vrf.

   go: server.go:56:18 *)
Definition Server__Startⁱᵐᵖˡ : val :=
  λ: "s" <>,
    with_defer: (let: "vrf" := (mem.alloc (type.zero_val #ptrT)) in
    let: "chain" := (mem.alloc (type.zero_val #ptrT)) in
    let: "s" := (mem.alloc "s") in
    do:  ((method_call #(ptrT.id sync.RWMutex.id) #"RLock"%go (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #());;;
    do:  (let: "$f" := (method_call #(ptrT.id sync.RWMutex.id) #"RUnlock"%go (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) in
    "$defer" <-[#funcT] (let: "$oldf" := (![#funcT] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    let: "predLen" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := ((s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref #history #"audits"%go (![#ptrT] (struct.field_ref #Server #"hist"%go (![#ptrT] "s"))))) in
    slice.len "$a0")) - #(W64 1)) in
    do:  ("predLen" <-[#uint64T] "$r0");;;
    let: "proof" := (mem.alloc (type.zero_val #sliceT)) in
    let: "predLink" := (mem.alloc (type.zero_val #sliceT)) in
    let: ("$ret0", "$ret1") := ((method_call #(ptrT.id hashchain.HashChain.id) #"Bootstrap"%go (![#ptrT] (struct.field_ref #history #"chain"%go (![#ptrT] (struct.field_ref #Server #"hist"%go (![#ptrT] "s")))))) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("predLink" <-[#sliceT] "$r0");;;
    do:  ("proof" <-[#sliceT] "$r1");;;
    let: "lastSig" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] (struct.field_ref #ktcore.AuditProof #"LinkSig"%go (![#ptrT] (slice.elem_ref #ptrT (![#sliceT] (struct.field_ref #history #"audits"%go (![#ptrT] (struct.field_ref #Server #"hist"%go (![#ptrT] "s"))))) (![#uint64T] "predLen"))))) in
    do:  ("lastSig" <-[#sliceT] "$r0");;;
    let: "pk" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := ((method_call #(ptrT.id cryptoffi.VrfPrivateKey.id) #"PublicKey"%go (![#ptrT] (struct.field_ref #secrets #"vrf"%go (![#ptrT] (struct.field_ref #Server #"secs"%go (![#ptrT] "s")))))) #()) in
    do:  ("pk" <-[#sliceT] "$r0");;;
    let: "$r0" := (mem.alloc (let: "$PrevEpochLen" := (![#uint64T] "predLen") in
    let: "$PrevLink" := (![#sliceT] "predLink") in
    let: "$ChainProof" := (![#sliceT] "proof") in
    let: "$LinkSig" := (![#sliceT] "lastSig") in
    struct.make #StartChain [{
      "PrevEpochLen" ::= "$PrevEpochLen";
      "PrevLink" ::= "$PrevLink";
      "ChainProof" ::= "$ChainProof";
      "LinkSig" ::= "$LinkSig"
    }])) in
    do:  ("chain" <-[#ptrT] "$r0");;;
    let: "$r0" := (mem.alloc (let: "$VrfPk" := (![#sliceT] "pk") in
    let: "$VrfSig" := (![#sliceT] (struct.field_ref #history #"vrfPkSig"%go (![#ptrT] (struct.field_ref #Server #"hist"%go (![#ptrT] "s"))))) in
    struct.make #StartVrf [{
      "VrfPk" ::= "$VrfPk";
      "VrfSig" ::= "$VrfSig"
    }])) in
    do:  ("vrf" <-[#ptrT] "$r0");;;
    return: (![#ptrT] "chain", ![#ptrT] "vrf")).

Definition Work : go_type := structT [
  "Uid" :: uint64T;
  "Pk" :: sliceT;
  "Ver" :: uint64T;
  "Err" :: boolT
].
#[global] Typeclasses Opaque Work.
#[global] Opaque Work.

(* Put queues pk (at the specified version) for insertion.

   go: server.go:69:18 *)
Definition Server__Putⁱᵐᵖˡ : val :=
  λ: "s" "uid" "pk" "ver",
    exception_do (let: "s" := (mem.alloc "s") in
    let: "ver" := (mem.alloc "ver") in
    let: "pk" := (mem.alloc "pk") in
    let: "uid" := (mem.alloc "uid") in
    do:  (let: "$chan" := (![type.chanT #ptrT] (struct.field_ref #Server #"workQ"%go (![#ptrT] "s"))) in
    let: "$v" := (mem.alloc (let: "$Uid" := (![#uint64T] "uid") in
    let: "$Pk" := (![#sliceT] "pk") in
    let: "$Ver" := (![#uint64T] "ver") in
    struct.make #Work [{
      "Uid" ::= "$Uid";
      "Pk" ::= "$Pk";
      "Ver" ::= "$Ver";
      "Err" ::= type.zero_val #boolT
    }])) in
    chan.send #ptrT "$chan" "$v");;;
    return: #()).

(* History gives key history for uid, excluding first prevVerLen versions.
   the caller already saw prevEpoch.

   go: server.go:75:18 *)
Definition Server__Historyⁱᵐᵖˡ : val :=
  λ: "s" "uid" "prevEpoch" "prevVerLen",
    with_defer: (let: "err" := (mem.alloc (type.zero_val #boolT)) in
    let: "bound" := (mem.alloc (type.zero_val #ptrT)) in
    let: "hist" := (mem.alloc (type.zero_val #sliceT)) in
    let: "linkSig" := (mem.alloc (type.zero_val #sliceT)) in
    let: "chainProof" := (mem.alloc (type.zero_val #sliceT)) in
    let: "s" := (mem.alloc "s") in
    let: "prevVerLen" := (mem.alloc "prevVerLen") in
    let: "prevEpoch" := (mem.alloc "prevEpoch") in
    let: "uid" := (mem.alloc "uid") in
    do:  ((method_call #(ptrT.id sync.RWMutex.id) #"RLock"%go (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #());;;
    do:  (let: "$f" := (method_call #(ptrT.id sync.RWMutex.id) #"RUnlock"%go (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) in
    "$defer" <-[#funcT] (let: "$oldf" := (![#funcT] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    let: "numEps" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref #history #"audits"%go (![#ptrT] (struct.field_ref #Server #"hist"%go (![#ptrT] "s"))))) in
    slice.len "$a0")) in
    do:  ("numEps" <-[#uint64T] "$r0");;;
    (if: (![#uint64T] "prevEpoch") ≥ (![#uint64T] "numEps")
    then
      let: "$r0" := #true in
      do:  ("err" <-[#boolT] "$r0");;;
      return: (![#sliceT] "chainProof", ![#sliceT] "linkSig", ![#sliceT] "hist", ![#ptrT] "bound", ![#boolT] "err")
    else do:  #());;;
    let: "numVers" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (s_to_w64 (let: "$a0" := (Fst (map.get (![type.mapT #uint64T #sliceT] (struct.field_ref #keyStore #"plain"%go (![#ptrT] (struct.field_ref #Server #"keys"%go (![#ptrT] "s"))))) (![#uint64T] "uid"))) in
    slice.len "$a0")) in
    do:  ("numVers" <-[#uint64T] "$r0");;;
    (if: (![#uint64T] "prevVerLen") > (![#uint64T] "numVers")
    then
      let: "$r0" := #true in
      do:  ("err" <-[#boolT] "$r0");;;
      return: (![#sliceT] "chainProof", ![#sliceT] "linkSig", ![#sliceT] "hist", ![#ptrT] "bound", ![#boolT] "err")
    else do:  #());;;
    let: "$r0" := (let: "$a0" := ((![#uint64T] "prevEpoch") + #(W64 1)) in
    (method_call #(ptrT.id hashchain.HashChain.id) #"Prove"%go (![#ptrT] (struct.field_ref #history #"chain"%go (![#ptrT] (struct.field_ref #Server #"hist"%go (![#ptrT] "s")))))) "$a0") in
    do:  ("chainProof" <-[#sliceT] "$r0");;;
    let: "$r0" := (![#sliceT] (struct.field_ref #ktcore.AuditProof #"LinkSig"%go (![#ptrT] (slice.elem_ref #ptrT (![#sliceT] (struct.field_ref #history #"audits"%go (![#ptrT] (struct.field_ref #Server #"hist"%go (![#ptrT] "s"))))) ((let: "$a0" := (![#sliceT] (struct.field_ref #history #"audits"%go (![#ptrT] (struct.field_ref #Server #"hist"%go (![#ptrT] "s"))))) in
    slice.len "$a0") - #(W64 1)))))) in
    do:  ("linkSig" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#uint64T] "uid") in
    let: "$a1" := (![#uint64T] "prevVerLen") in
    (method_call #(ptrT.id Server.id) #"getHist"%go (![#ptrT] "s")) "$a0" "$a1") in
    do:  ("hist" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#uint64T] "uid") in
    let: "$a1" := (![#uint64T] "numVers") in
    (method_call #(ptrT.id Server.id) #"getBound"%go (![#ptrT] "s")) "$a0" "$a1") in
    do:  ("bound" <-[#ptrT] "$r0");;;
    return: (![#sliceT] "chainProof", ![#sliceT] "linkSig", ![#sliceT] "hist", ![#ptrT] "bound", ![#boolT] "err")).

(* Audit errors if args out of bounds.

   go: server.go:97:18 *)
Definition Server__Auditⁱᵐᵖˡ : val :=
  λ: "s" "prevEpoch",
    with_defer: (let: "err" := (mem.alloc (type.zero_val #boolT)) in
    let: "proof" := (mem.alloc (type.zero_val #sliceT)) in
    let: "s" := (mem.alloc "s") in
    let: "prevEpoch" := (mem.alloc "prevEpoch") in
    do:  ((method_call #(ptrT.id sync.RWMutex.id) #"RLock"%go (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #());;;
    do:  (let: "$f" := (method_call #(ptrT.id sync.RWMutex.id) #"RUnlock"%go (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) in
    "$defer" <-[#funcT] (let: "$oldf" := (![#funcT] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    let: "numEps" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref #history #"audits"%go (![#ptrT] (struct.field_ref #Server #"hist"%go (![#ptrT] "s"))))) in
    slice.len "$a0")) in
    do:  ("numEps" <-[#uint64T] "$r0");;;
    (if: (![#uint64T] "prevEpoch") ≥ (![#uint64T] "numEps")
    then
      let: "$r0" := #true in
      do:  ("err" <-[#boolT] "$r0");;;
      return: (![#sliceT] "proof", ![#boolT] "err")
    else do:  #());;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "proof") in
    let: "$a1" := (let: "$s" := (![#sliceT] (struct.field_ref #history #"audits"%go (![#ptrT] (struct.field_ref #Server #"hist"%go (![#ptrT] "s"))))) in
    slice.slice #ptrT "$s" ((![#uint64T] "prevEpoch") + #(W64 1)) (slice.len "$s")) in
    (slice.append #ptrT) "$a0" "$a1") in
    do:  ("proof" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "proof", ![#boolT] "err")).

Definition mapEntry : go_type := structT [
  "label" :: sliceT;
  "val" :: sliceT
].
#[global] Typeclasses Opaque mapEntry.
#[global] Opaque mapEntry.

Definition getWork : go_string := "github.com/sanjit-bhat/pav/server.getWork"%go.

(* go: server.go:121:18 *)
Definition Server__workerⁱᵐᵖˡ : val :=
  λ: "s" <>,
    exception_do (let: "s" := (mem.alloc "s") in
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "work" := (mem.alloc (type.zero_val #sliceT)) in
      let: "$r0" := (let: "$a0" := (![type.chanT #ptrT] (struct.field_ref #Server #"workQ"%go (![#ptrT] "s"))) in
      (func_call #getWork) "$a0") in
      do:  ("work" <-[#sliceT] "$r0");;;
      (if: (let: "$a0" := (![#sliceT] "work") in
      slice.len "$a0") = #(W64 0)
      then continue: #()
      else do:  #());;;
      do:  (let: "$a0" := (![#sliceT] "work") in
      (method_call #(ptrT.id Server.id) #"doWork"%go (![#ptrT] "s")) "$a0"));;;
    return: #()).

(* go: server.go:131:6 *)
Definition getWorkⁱᵐᵖˡ : val :=
  λ: "workQ",
    exception_do (let: "work" := (mem.alloc (type.zero_val #sliceT)) in
    let: "workQ" := (mem.alloc "workQ") in
    let: "$r0" := (slice.make3 #ptrT #(W64 0) (![#intT] (globals.get #BatchSize))) in
    do:  ("work" <-[#sliceT] "$r0");;;
    let: "timer" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := (![#time.Duration] (globals.get #BatchTimeout)) in
    (func_call #time.NewTimer) "$a0") in
    do:  ("timer" <-[#ptrT] "$r0");;;
    (let: "i" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[#intT] "$r0");;;
    (for: (λ: <>, int_lt (![#intT] "i") (![#intT] (globals.get #BatchSize))); (λ: <>, do:  ("i" <-[#intT] ((![#intT] "i") + #(W64 1)))) := λ: <>,
      chan.select_blocking [chan.select_receive #ptrT (![type.chanT #ptrT] "workQ") (λ: "$recvVal",
         let: "ok" := (mem.alloc (type.zero_val #boolT)) in
         let: "job" := (mem.alloc (type.zero_val #ptrT)) in
         let: ("$ret0", "$ret1") := "$recvVal" in
         let: "$r0" := "$ret0" in
         let: "$r1" := "$ret1" in
         do:  ("job" <-[#ptrT] "$r0");;;
         do:  ("ok" <-[#boolT] "$r1");;;
         do:  (let: "$a0" := (![#boolT] "ok") in
         (func_call #std.Assert) "$a0");;;
         let: "$r0" := (let: "$a0" := (![#sliceT] "work") in
         let: "$a1" := ((let: "$sl0" := (![#ptrT] "job") in
         slice.literal #ptrT ["$sl0"])) in
         (slice.append #ptrT) "$a0" "$a1") in
         do:  ("work" <-[#sliceT] "$r0")
         ); chan.select_receive #time.Time (![type.chanT #time.Time] (struct.field_ref #time.Timer #"C"%go (![#ptrT] "timer"))) (λ: "$recvVal",
         return: (![#sliceT] "work")
         )]));;;
    return: (![#sliceT] "work")).

(* go: server.go:149:18 *)
Definition Server__doWorkⁱᵐᵖˡ : val :=
  λ: "s" "work",
    exception_do (let: "s" := (mem.alloc "s") in
    let: "work" := (mem.alloc "work") in
    do:  (let: "$a0" := (![#sliceT] "work") in
    (method_call #(ptrT.id Server.id) #"checkWork"%go (![#ptrT] "s")) "$a0");;;
    let: "ents" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "work") in
    (method_call #(ptrT.id Server.id) #"makeEntries"%go (![#ptrT] "s")) "$a0") in
    do:  ("ents" <-[#sliceT] "$r0");;;
    do:  ((method_call #(ptrT.id sync.RWMutex.id) #"Lock"%go (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #());;;
    do:  (let: "$a0" := (![#sliceT] "work") in
    let: "$a1" := (![#sliceT] "ents") in
    (method_call #(ptrT.id Server.id) #"addEntries"%go (![#ptrT] "s")) "$a0" "$a1");;;
    do:  ((method_call #(ptrT.id sync.RWMutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #());;;
    return: #()).

Definition New : go_string := "github.com/sanjit-bhat/pav/server.New"%go.

(* go: server.go:161:6 *)
Definition Newⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "mu" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #sync.RWMutex)) in
    do:  ("mu" <-[#ptrT] "$r0");;;
    let: "sigSk" := (mem.alloc (type.zero_val #ptrT)) in
    let: "sigPk" := (mem.alloc (type.zero_val #cryptoffi.SigPublicKey)) in
    let: ("$ret0", "$ret1") := ((func_call #cryptoffi.SigGenerateKey) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("sigPk" <-[#cryptoffi.SigPublicKey] "$r0");;;
    do:  ("sigSk" <-[#ptrT] "$r1");;;
    let: "vrfSk" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := ((func_call #cryptoffi.VrfGenerateKey) #()) in
    do:  ("vrfSk" <-[#ptrT] "$r0");;;
    let: "vrfSig" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#ptrT] "sigSk") in
    let: "$a1" := ((method_call #(ptrT.id cryptoffi.VrfPrivateKey.id) #"PublicKey"%go (![#ptrT] "vrfSk")) #()) in
    (func_call #ktcore.SignVrf) "$a0" "$a1") in
    do:  ("vrfSig" <-[#sliceT] "$r0");;;
    let: "commitSec" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := cryptoffi.HashLen in
    (func_call #cryptoffi.RandBytes) "$a0") in
    do:  ("commitSec" <-[#sliceT] "$r0");;;
    let: "secs" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (let: "$sig" := (![#ptrT] "sigSk") in
    let: "$vrf" := (![#ptrT] "vrfSk") in
    let: "$commit" := (![#sliceT] "commitSec") in
    struct.make #secrets [{
      "sig" ::= "$sig";
      "vrf" ::= "$vrf";
      "commit" ::= "$commit"
    }])) in
    do:  ("secs" <-[#ptrT] "$r0");;;
    let: "hidden" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (struct.make #merkle.Map [{
      "root" ::= type.zero_val #ptrT
    }])) in
    do:  ("hidden" <-[#ptrT] "$r0");;;
    let: "plain" := (mem.alloc (type.zero_val (type.mapT #uint64T #sliceT))) in
    let: "$r0" := (map.make #uint64T #sliceT) in
    do:  ("plain" <-[type.mapT #uint64T #sliceT] "$r0");;;
    let: "keys" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (let: "$hidden" := (![#ptrT] "hidden") in
    let: "$plain" := (![type.mapT #uint64T #sliceT] "plain") in
    struct.make #keyStore [{
      "hidden" ::= "$hidden";
      "plain" ::= "$plain"
    }])) in
    do:  ("keys" <-[#ptrT] "$r0");;;
    let: "chain" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := ((func_call #hashchain.New) #()) in
    do:  ("chain" <-[#ptrT] "$r0");;;
    let: "hist" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (let: "$chain" := (![#ptrT] "chain") in
    let: "$vrfPkSig" := (![#sliceT] "vrfSig") in
    struct.make #history [{
      "chain" ::= "$chain";
      "audits" ::= type.zero_val #sliceT;
      "vrfPkSig" ::= "$vrfPkSig"
    }])) in
    do:  ("hist" <-[#ptrT] "$r0");;;
    let: "wq" := (mem.alloc (type.zero_val (type.chanT #ptrT))) in
    let: "$r0" := (chan.make #ptrT (![#intT] (globals.get #WorkQSize))) in
    do:  ("wq" <-[type.chanT #ptrT] "$r0");;;
    let: "s" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (let: "$mu" := (![#ptrT] "mu") in
    let: "$secs" := (![#ptrT] "secs") in
    let: "$keys" := (![#ptrT] "keys") in
    let: "$hist" := (![#ptrT] "hist") in
    let: "$workQ" := (![type.chanT #ptrT] "wq") in
    struct.make #Server [{
      "mu" ::= "$mu";
      "secs" ::= "$secs";
      "keys" ::= "$keys";
      "hist" ::= "$hist";
      "workQ" ::= "$workQ"
    }])) in
    do:  ("s" <-[#ptrT] "$r0");;;
    let: "dig" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := ((method_call #(ptrT.id merkle.Map.id) #"Hash"%go (![#ptrT] (struct.field_ref #keyStore #"hidden"%go (![#ptrT] "keys")))) #()) in
    do:  ("dig" <-[#sliceT] "$r0");;;
    let: "link" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "dig") in
    (method_call #(ptrT.id hashchain.HashChain.id) #"Append"%go (![#ptrT] "chain")) "$a0") in
    do:  ("link" <-[#sliceT] "$r0");;;
    let: "linkSig" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#ptrT] (struct.field_ref #secrets #"sig"%go (![#ptrT] (struct.field_ref #Server #"secs"%go (![#ptrT] "s"))))) in
    let: "$a1" := #(W64 0) in
    let: "$a2" := (![#sliceT] "link") in
    (func_call #ktcore.SignLink) "$a0" "$a1" "$a2") in
    do:  ("linkSig" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] (struct.field_ref #history #"audits"%go (![#ptrT] (struct.field_ref #Server #"hist"%go (![#ptrT] "s"))))) in
    let: "$a1" := ((let: "$sl0" := (mem.alloc (let: "$LinkSig" := (![#sliceT] "linkSig") in
    struct.make #ktcore.AuditProof [{
      "Updates" ::= type.zero_val #sliceT;
      "LinkSig" ::= "$LinkSig"
    }])) in
    slice.literal #ptrT ["$sl0"])) in
    (slice.append #ptrT) "$a0" "$a1") in
    do:  ((struct.field_ref #history #"audits"%go (![#ptrT] (struct.field_ref #Server #"hist"%go (![#ptrT] "s")))) <-[#sliceT] "$r0");;;
    let: "$go" := (method_call #(ptrT.id Server.id) #"worker"%go (![#ptrT] "s")) in
    do:  (Fork ("$go" #()));;;
    return: (![#ptrT] "s", ![#cryptoffi.SigPublicKey] "sigPk")).

(* go: server.go:186:18 *)
Definition Server__checkWorkⁱᵐᵖˡ : val :=
  λ: "s" "work",
    exception_do (let: "s" := (mem.alloc "s") in
    let: "work" := (mem.alloc "work") in
    let: "uidSet" := (mem.alloc (type.zero_val (type.mapT #uint64T #boolT))) in
    let: "$r0" := (map.make #uint64T #boolT) in
    do:  ("uidSet" <-[type.mapT #uint64T #boolT] "$r0");;;
    let: "$range" := (![#sliceT] "work") in
    (let: "w" := (mem.alloc (type.zero_val #ptrT)) in
    slice.for_range #ptrT "$range" (λ: "$key" "$value",
      do:  ("w" <-[#ptrT] "$value");;;
      do:  "$key";;;
      let: "uid" := (mem.alloc (type.zero_val #uint64T)) in
      let: "$r0" := (![#uint64T] (struct.field_ref #Work #"Uid"%go (![#ptrT] "w"))) in
      do:  ("uid" <-[#uint64T] "$r0");;;
      let: "nextVer" := (mem.alloc (type.zero_val #uint64T)) in
      let: "$r0" := (s_to_w64 (let: "$a0" := (Fst (map.get (![type.mapT #uint64T #sliceT] (struct.field_ref #keyStore #"plain"%go (![#ptrT] (struct.field_ref #Server #"keys"%go (![#ptrT] "s"))))) (![#uint64T] "uid"))) in
      slice.len "$a0")) in
      do:  ("nextVer" <-[#uint64T] "$r0");;;
      (if: (![#uint64T] (struct.field_ref #Work #"Ver"%go (![#ptrT] "w"))) ≠ (![#uint64T] "nextVer")
      then
        let: "$r0" := #true in
        do:  ((struct.field_ref #Work #"Err"%go (![#ptrT] "w")) <-[#boolT] "$r0");;;
        continue: #()
      else do:  #());;;
      let: "ok" := (mem.alloc (type.zero_val #boolT)) in
      let: ("$ret0", "$ret1") := (map.get (![type.mapT #uint64T #boolT] "uidSet") (![#uint64T] "uid")) in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  "$r0";;;
      do:  ("ok" <-[#boolT] "$r1");;;
      (if: ![#boolT] "ok"
      then
        let: "$r0" := #true in
        do:  ((struct.field_ref #Work #"Err"%go (![#ptrT] "w")) <-[#boolT] "$r0");;;
        continue: #()
      else do:  #());;;
      let: "$r0" := #false in
      do:  (map.insert (![type.mapT #uint64T #boolT] "uidSet") (![#uint64T] "uid") "$r0")));;;
    return: #()).

(* go: server.go:206:18 *)
Definition Server__makeEntriesⁱᵐᵖˡ : val :=
  λ: "s" "work",
    exception_do (let: "ents" := (mem.alloc (type.zero_val #sliceT)) in
    let: "s" := (mem.alloc "s") in
    let: "work" := (mem.alloc "work") in
    let: "$r0" := (slice.make2 #ptrT (let: "$a0" := (![#sliceT] "work") in
    slice.len "$a0")) in
    do:  ("ents" <-[#sliceT] "$r0");;;
    let: "wg" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #sync.WaitGroup)) in
    do:  ("wg" <-[#ptrT] "$r0");;;
    (let: "i" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[#intT] "$r0");;;
    (for: (λ: <>, int_lt (![#intT] "i") (let: "$a0" := (![#sliceT] "work") in
    slice.len "$a0")); (λ: <>, do:  ("i" <-[#intT] ((![#intT] "i") + #(W64 1)))) := λ: <>,
      let: "job" := (mem.alloc (type.zero_val #ptrT)) in
      let: "$r0" := (![#ptrT] (slice.elem_ref #ptrT (![#sliceT] "work") (![#intT] "i"))) in
      do:  ("job" <-[#ptrT] "$r0");;;
      (if: ![#boolT] (struct.field_ref #Work #"Err"%go (![#ptrT] "job"))
      then continue: #()
      else do:  #());;;
      let: "out" := (mem.alloc (type.zero_val #ptrT)) in
      let: "$r0" := (mem.alloc (struct.make #mapEntry [{
        "label" ::= type.zero_val #sliceT;
        "val" ::= type.zero_val #sliceT
      }])) in
      do:  ("out" <-[#ptrT] "$r0");;;
      let: "$r0" := (![#ptrT] "out") in
      do:  ((slice.elem_ref #ptrT (![#sliceT] "ents") (![#intT] "i")) <-[#ptrT] "$r0");;;
      do:  (let: "$a0" := #(W64 1) in
      (method_call #(ptrT.id sync.WaitGroup.id) #"Add"%go (![#ptrT] "wg")) "$a0");;;
      let: "$go" := (λ: <>,
        exception_do (do:  (let: "$a0" := (![#ptrT] "job") in
        let: "$a1" := (![#ptrT] "out") in
        (method_call #(ptrT.id Server.id) #"makeEntry"%go (![#ptrT] "s")) "$a0" "$a1");;;
        do:  ((method_call #(ptrT.id sync.WaitGroup.id) #"Done"%go (![#ptrT] "wg")) #());;;
        return: #())
        ) in
      do:  (Fork ("$go" #()))));;;
    do:  ((method_call #(ptrT.id sync.WaitGroup.id) #"Wait"%go (![#ptrT] "wg")) #());;;
    return: (![#sliceT] "ents")).

(* go: server.go:226:18 *)
Definition Server__makeEntryⁱᵐᵖˡ : val :=
  λ: "s" "in" "out",
    exception_do (let: "s" := (mem.alloc "s") in
    let: "out" := (mem.alloc "out") in
    let: "in" := (mem.alloc "in") in
    let: "numVers" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (s_to_w64 (let: "$a0" := (Fst (map.get (![type.mapT #uint64T #sliceT] (struct.field_ref #keyStore #"plain"%go (![#ptrT] (struct.field_ref #Server #"keys"%go (![#ptrT] "s"))))) (![#uint64T] (struct.field_ref #Work #"Uid"%go (![#ptrT] "in"))))) in
    slice.len "$a0")) in
    do:  ("numVers" <-[#uint64T] "$r0");;;
    let: "mapLabel" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#ptrT] (struct.field_ref #secrets #"vrf"%go (![#ptrT] (struct.field_ref #Server #"secs"%go (![#ptrT] "s"))))) in
    let: "$a1" := (![#uint64T] (struct.field_ref #Work #"Uid"%go (![#ptrT] "in"))) in
    let: "$a2" := (![#uint64T] "numVers") in
    (func_call #ktcore.EvalMapLabel) "$a0" "$a1" "$a2") in
    do:  ("mapLabel" <-[#sliceT] "$r0");;;
    let: "rand" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] (struct.field_ref #secrets #"commit"%go (![#ptrT] (struct.field_ref #Server #"secs"%go (![#ptrT] "s"))))) in
    let: "$a1" := (![#sliceT] "mapLabel") in
    (func_call #ktcore.GetCommitRand) "$a0" "$a1") in
    do:  ("rand" <-[#sliceT] "$r0");;;
    let: "open" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (let: "$Val" := (![#sliceT] (struct.field_ref #Work #"Pk"%go (![#ptrT] "in"))) in
    let: "$Rand" := (![#sliceT] "rand") in
    struct.make #ktcore.CommitOpen [{
      "Val" ::= "$Val";
      "Rand" ::= "$Rand"
    }])) in
    do:  ("open" <-[#ptrT] "$r0");;;
    let: "mapVal" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#ptrT] "open") in
    (func_call #ktcore.GetMapVal) "$a0") in
    do:  ("mapVal" <-[#sliceT] "$r0");;;
    let: "$r0" := (![#sliceT] "mapLabel") in
    do:  ((struct.field_ref #mapEntry #"label"%go (![#ptrT] "out")) <-[#sliceT] "$r0");;;
    let: "$r0" := (![#sliceT] "mapVal") in
    do:  ((struct.field_ref #mapEntry #"val"%go (![#ptrT] "out")) <-[#sliceT] "$r0");;;
    return: #()).

(* go: server.go:237:18 *)
Definition Server__addEntriesⁱᵐᵖˡ : val :=
  λ: "s" "work" "ents",
    exception_do (let: "s" := (mem.alloc "s") in
    let: "ents" := (mem.alloc "ents") in
    let: "work" := (mem.alloc "work") in
    let: "upd" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make3 #ptrT #(W64 0) (let: "$a0" := (![#sliceT] "work") in
    slice.len "$a0")) in
    do:  ("upd" <-[#sliceT] "$r0");;;
    (let: "i" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[#intT] "$r0");;;
    (for: (λ: <>, int_lt (![#intT] "i") (let: "$a0" := (![#sliceT] "work") in
    slice.len "$a0")); (λ: <>, do:  ("i" <-[#intT] ((![#intT] "i") + #(W64 1)))) := λ: <>,
      let: "job" := (mem.alloc (type.zero_val #ptrT)) in
      let: "$r0" := (![#ptrT] (slice.elem_ref #ptrT (![#sliceT] "work") (![#intT] "i"))) in
      do:  ("job" <-[#ptrT] "$r0");;;
      (if: ![#boolT] (struct.field_ref #Work #"Err"%go (![#ptrT] "job"))
      then continue: #()
      else do:  #());;;
      let: "out" := (mem.alloc (type.zero_val #ptrT)) in
      let: "$r0" := (![#ptrT] (slice.elem_ref #ptrT (![#sliceT] "ents") (![#intT] "i"))) in
      do:  ("out" <-[#ptrT] "$r0");;;
      let: "label" := (mem.alloc (type.zero_val #sliceT)) in
      let: "$r0" := (![#sliceT] (struct.field_ref #mapEntry #"label"%go (![#ptrT] "out"))) in
      do:  ("label" <-[#sliceT] "$r0");;;
      let: "proof" := (mem.alloc (type.zero_val #sliceT)) in
      let: "$r0" := (let: "$a0" := (![#sliceT] "label") in
      let: "$a1" := (![#sliceT] (struct.field_ref #mapEntry #"val"%go (![#ptrT] "out"))) in
      (method_call #(ptrT.id merkle.Map.id) #"Put"%go (![#ptrT] (struct.field_ref #keyStore #"hidden"%go (![#ptrT] (struct.field_ref #Server #"keys"%go (![#ptrT] "s")))))) "$a0" "$a1") in
      do:  ("proof" <-[#sliceT] "$r0");;;
      let: "$r0" := (let: "$a0" := (Fst (map.get (![type.mapT #uint64T #sliceT] (struct.field_ref #keyStore #"plain"%go (![#ptrT] (struct.field_ref #Server #"keys"%go (![#ptrT] "s"))))) (![#uint64T] (struct.field_ref #Work #"Uid"%go (![#ptrT] "job"))))) in
      let: "$a1" := ((let: "$sl0" := (![#sliceT] (struct.field_ref #Work #"Pk"%go (![#ptrT] "job"))) in
      slice.literal #sliceT ["$sl0"])) in
      (slice.append #sliceT) "$a0" "$a1") in
      do:  (map.insert (![type.mapT #uint64T #sliceT] (struct.field_ref #keyStore #"plain"%go (![#ptrT] (struct.field_ref #Server #"keys"%go (![#ptrT] "s"))))) (![#uint64T] (struct.field_ref #Work #"Uid"%go (![#ptrT] "job"))) "$r0");;;
      let: "info" := (mem.alloc (type.zero_val #ptrT)) in
      let: "$r0" := (mem.alloc (let: "$MapLabel" := (![#sliceT] "label") in
      let: "$MapVal" := (![#sliceT] (struct.field_ref #mapEntry #"val"%go (![#ptrT] "out"))) in
      let: "$NonMembProof" := (![#sliceT] "proof") in
      struct.make #ktcore.UpdateProof [{
        "MapLabel" ::= "$MapLabel";
        "MapVal" ::= "$MapVal";
        "NonMembProof" ::= "$NonMembProof"
      }])) in
      do:  ("info" <-[#ptrT] "$r0");;;
      let: "$r0" := (let: "$a0" := (![#sliceT] "upd") in
      let: "$a1" := ((let: "$sl0" := (![#ptrT] "info") in
      slice.literal #ptrT ["$sl0"])) in
      (slice.append #ptrT) "$a0" "$a1") in
      do:  ("upd" <-[#sliceT] "$r0")));;;
    let: "dig" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := ((method_call #(ptrT.id merkle.Map.id) #"Hash"%go (![#ptrT] (struct.field_ref #keyStore #"hidden"%go (![#ptrT] (struct.field_ref #Server #"keys"%go (![#ptrT] "s")))))) #()) in
    do:  ("dig" <-[#sliceT] "$r0");;;
    let: "link" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "dig") in
    (method_call #(ptrT.id hashchain.HashChain.id) #"Append"%go (![#ptrT] (struct.field_ref #history #"chain"%go (![#ptrT] (struct.field_ref #Server #"hist"%go (![#ptrT] "s")))))) "$a0") in
    do:  ("link" <-[#sliceT] "$r0");;;
    let: "epoch" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref #history #"audits"%go (![#ptrT] (struct.field_ref #Server #"hist"%go (![#ptrT] "s"))))) in
    slice.len "$a0")) in
    do:  ("epoch" <-[#uint64T] "$r0");;;
    let: "sig" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#ptrT] (struct.field_ref #secrets #"sig"%go (![#ptrT] (struct.field_ref #Server #"secs"%go (![#ptrT] "s"))))) in
    let: "$a1" := (![#uint64T] "epoch") in
    let: "$a2" := (![#sliceT] "link") in
    (func_call #ktcore.SignLink) "$a0" "$a1" "$a2") in
    do:  ("sig" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] (struct.field_ref #history #"audits"%go (![#ptrT] (struct.field_ref #Server #"hist"%go (![#ptrT] "s"))))) in
    let: "$a1" := ((let: "$sl0" := (mem.alloc (let: "$Updates" := (![#sliceT] "upd") in
    let: "$LinkSig" := (![#sliceT] "sig") in
    struct.make #ktcore.AuditProof [{
      "Updates" ::= "$Updates";
      "LinkSig" ::= "$LinkSig"
    }])) in
    slice.literal #ptrT ["$sl0"])) in
    (slice.append #ptrT) "$a0" "$a1") in
    do:  ((struct.field_ref #history #"audits"%go (![#ptrT] (struct.field_ref #Server #"hist"%go (![#ptrT] "s")))) <-[#sliceT] "$r0");;;
    return: #()).

(* getHist returns a history of membership proofs for all post-prefix versions.

   go: server.go:263:18 *)
Definition Server__getHistⁱᵐᵖˡ : val :=
  λ: "s" "uid" "prefixLen",
    exception_do (let: "hist" := (mem.alloc (type.zero_val #sliceT)) in
    let: "s" := (mem.alloc "s") in
    let: "prefixLen" := (mem.alloc "prefixLen") in
    let: "uid" := (mem.alloc "uid") in
    let: "pks" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (Fst (map.get (![type.mapT #uint64T #sliceT] (struct.field_ref #keyStore #"plain"%go (![#ptrT] (struct.field_ref #Server #"keys"%go (![#ptrT] "s"))))) (![#uint64T] "uid"))) in
    do:  ("pks" <-[#sliceT] "$r0");;;
    let: "numVers" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (s_to_w64 (let: "$a0" := (![#sliceT] "pks") in
    slice.len "$a0")) in
    do:  ("numVers" <-[#uint64T] "$r0");;;
    (let: "ver" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (![#uint64T] "prefixLen") in
    do:  ("ver" <-[#uint64T] "$r0");;;
    (for: (λ: <>, (![#uint64T] "ver") < (![#uint64T] "numVers")); (λ: <>, do:  ("ver" <-[#uint64T] ((![#uint64T] "ver") + #(W64 1)))) := λ: <>,
      let: "labelProof" := (mem.alloc (type.zero_val #sliceT)) in
      let: "label" := (mem.alloc (type.zero_val #sliceT)) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![#ptrT] (struct.field_ref #secrets #"vrf"%go (![#ptrT] (struct.field_ref #Server #"secs"%go (![#ptrT] "s"))))) in
      let: "$a1" := (![#uint64T] "uid") in
      let: "$a2" := (![#uint64T] "ver") in
      (func_call #ktcore.ProveMapLabel) "$a0" "$a1" "$a2") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("label" <-[#sliceT] "$r0");;;
      do:  ("labelProof" <-[#sliceT] "$r1");;;
      let: "mapProof" := (mem.alloc (type.zero_val #sliceT)) in
      let: "inMap" := (mem.alloc (type.zero_val #boolT)) in
      let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "label") in
      (method_call #(ptrT.id merkle.Map.id) #"Prove"%go (![#ptrT] (struct.field_ref #keyStore #"hidden"%go (![#ptrT] (struct.field_ref #Server #"keys"%go (![#ptrT] "s")))))) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      let: "$r2" := "$ret2" in
      do:  ("inMap" <-[#boolT] "$r0");;;
      do:  "$r1";;;
      do:  ("mapProof" <-[#sliceT] "$r2");;;
      do:  (let: "$a0" := (![#boolT] "inMap") in
      (func_call #std.Assert) "$a0");;;
      let: "rand" := (mem.alloc (type.zero_val #sliceT)) in
      let: "$r0" := (let: "$a0" := (![#sliceT] (struct.field_ref #secrets #"commit"%go (![#ptrT] (struct.field_ref #Server #"secs"%go (![#ptrT] "s"))))) in
      let: "$a1" := (![#sliceT] "label") in
      (func_call #ktcore.GetCommitRand) "$a0" "$a1") in
      do:  ("rand" <-[#sliceT] "$r0");;;
      let: "open" := (mem.alloc (type.zero_val #ptrT)) in
      let: "$r0" := (mem.alloc (let: "$Val" := (![#sliceT] (slice.elem_ref #sliceT (![#sliceT] "pks") (![#uint64T] "ver"))) in
      let: "$Rand" := (![#sliceT] "rand") in
      struct.make #ktcore.CommitOpen [{
        "Val" ::= "$Val";
        "Rand" ::= "$Rand"
      }])) in
      do:  ("open" <-[#ptrT] "$r0");;;
      let: "memb" := (mem.alloc (type.zero_val #ptrT)) in
      let: "$r0" := (mem.alloc (let: "$LabelProof" := (![#sliceT] "labelProof") in
      let: "$PkOpen" := (![#ptrT] "open") in
      let: "$MerkleProof" := (![#sliceT] "mapProof") in
      struct.make #ktcore.Memb [{
        "LabelProof" ::= "$LabelProof";
        "PkOpen" ::= "$PkOpen";
        "MerkleProof" ::= "$MerkleProof"
      }])) in
      do:  ("memb" <-[#ptrT] "$r0");;;
      let: "$r0" := (let: "$a0" := (![#sliceT] "hist") in
      let: "$a1" := ((let: "$sl0" := (![#ptrT] "memb") in
      slice.literal #ptrT ["$sl0"])) in
      (slice.append #ptrT) "$a0" "$a1") in
      do:  ("hist" <-[#sliceT] "$r0")));;;
    return: (![#sliceT] "hist")).

(* getBound returns a non-membership proof for the boundary version.

   go: server.go:279:18 *)
Definition Server__getBoundⁱᵐᵖˡ : val :=
  λ: "s" "uid" "numVers",
    exception_do (let: "bound" := (mem.alloc (type.zero_val #ptrT)) in
    let: "s" := (mem.alloc "s") in
    let: "numVers" := (mem.alloc "numVers") in
    let: "uid" := (mem.alloc "uid") in
    let: "labelProof" := (mem.alloc (type.zero_val #sliceT)) in
    let: "label" := (mem.alloc (type.zero_val #sliceT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#ptrT] (struct.field_ref #secrets #"vrf"%go (![#ptrT] (struct.field_ref #Server #"secs"%go (![#ptrT] "s"))))) in
    let: "$a1" := (![#uint64T] "uid") in
    let: "$a2" := (![#uint64T] "numVers") in
    (func_call #ktcore.ProveMapLabel) "$a0" "$a1" "$a2") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("label" <-[#sliceT] "$r0");;;
    do:  ("labelProof" <-[#sliceT] "$r1");;;
    let: "mapProof" := (mem.alloc (type.zero_val #sliceT)) in
    let: "inMap" := (mem.alloc (type.zero_val #boolT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "label") in
    (method_call #(ptrT.id merkle.Map.id) #"Prove"%go (![#ptrT] (struct.field_ref #keyStore #"hidden"%go (![#ptrT] (struct.field_ref #Server #"keys"%go (![#ptrT] "s")))))) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("inMap" <-[#boolT] "$r0");;;
    do:  "$r1";;;
    do:  ("mapProof" <-[#sliceT] "$r2");;;
    do:  (let: "$a0" := (~ (![#boolT] "inMap")) in
    (func_call #std.Assert) "$a0");;;
    let: "$r0" := (mem.alloc (let: "$LabelProof" := (![#sliceT] "labelProof") in
    let: "$MerkleProof" := (![#sliceT] "mapProof") in
    struct.make #ktcore.NonMemb [{
      "LabelProof" ::= "$LabelProof";
      "MerkleProof" ::= "$MerkleProof"
    }])) in
    do:  ("bound" <-[#ptrT] "$r0");;;
    return: (![#ptrT] "bound")).

Definition vars' : list (go_string * go_type) := [(WorkQSize, intT); (BatchSize, intT); (BatchTimeout, time.Duration)].

Definition functions' : list (go_string * val) := [(NewRpcServer, NewRpcServerⁱᵐᵖˡ); (CallStart, CallStartⁱᵐᵖˡ); (CallPut, CallPutⁱᵐᵖˡ); (CallHistory, CallHistoryⁱᵐᵖˡ); (CallAudit, CallAuditⁱᵐᵖˡ); (StartChainEncode, StartChainEncodeⁱᵐᵖˡ); (StartChainDecode, StartChainDecodeⁱᵐᵖˡ); (StartVrfEncode, StartVrfEncodeⁱᵐᵖˡ); (StartVrfDecode, StartVrfDecodeⁱᵐᵖˡ); (StartReplyEncode, StartReplyEncodeⁱᵐᵖˡ); (StartReplyDecode, StartReplyDecodeⁱᵐᵖˡ); (PutArgEncode, PutArgEncodeⁱᵐᵖˡ); (PutArgDecode, PutArgDecodeⁱᵐᵖˡ); (HistoryArgEncode, HistoryArgEncodeⁱᵐᵖˡ); (HistoryArgDecode, HistoryArgDecodeⁱᵐᵖˡ); (HistoryReplyEncode, HistoryReplyEncodeⁱᵐᵖˡ); (HistoryReplyDecode, HistoryReplyDecodeⁱᵐᵖˡ); (AuditArgEncode, AuditArgEncodeⁱᵐᵖˡ); (AuditArgDecode, AuditArgDecodeⁱᵐᵖˡ); (AuditReplyEncode, AuditReplyEncodeⁱᵐᵖˡ); (AuditReplyDecode, AuditReplyDecodeⁱᵐᵖˡ); (getWork, getWorkⁱᵐᵖˡ); (New, Newⁱᵐᵖˡ)].

Definition msets' : list (go_string * (list (go_string * val))) := [(StartChain.id, []); (ptrT.id StartChain.id, []); (StartVrf.id, []); (ptrT.id StartVrf.id, []); (StartReply.id, []); (ptrT.id StartReply.id, []); (PutArg.id, []); (ptrT.id PutArg.id, []); (HistoryArg.id, []); (ptrT.id HistoryArg.id, []); (HistoryReply.id, []); (ptrT.id HistoryReply.id, []); (AuditArg.id, []); (ptrT.id AuditArg.id, []); (AuditReply.id, []); (ptrT.id AuditReply.id, []); (Server.id, []); (ptrT.id Server.id, [("Audit"%go, Server__Auditⁱᵐᵖˡ); ("History"%go, Server__Historyⁱᵐᵖˡ); ("Put"%go, Server__Putⁱᵐᵖˡ); ("Start"%go, Server__Startⁱᵐᵖˡ); ("addEntries"%go, Server__addEntriesⁱᵐᵖˡ); ("checkWork"%go, Server__checkWorkⁱᵐᵖˡ); ("doWork"%go, Server__doWorkⁱᵐᵖˡ); ("getBound"%go, Server__getBoundⁱᵐᵖˡ); ("getHist"%go, Server__getHistⁱᵐᵖˡ); ("makeEntries"%go, Server__makeEntriesⁱᵐᵖˡ); ("makeEntry"%go, Server__makeEntryⁱᵐᵖˡ); ("worker"%go, Server__workerⁱᵐᵖˡ)]); (secrets.id, []); (ptrT.id secrets.id, []); (keyStore.id, []); (ptrT.id keyStore.id, []); (history.id, []); (ptrT.id history.id, []); (Work.id, []); (ptrT.id Work.id, []); (mapEntry.id, []); (ptrT.id mapEntry.id, [])].

#[global] Instance info' : PkgInfo server.server :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [code.github_com.sanjit_bhat.pav.advrpc.advrpc; code.github_com.sanjit_bhat.pav.ktcore.ktcore; code.github_com.sanjit_bhat.pav.safemarshal.safemarshal; code.github_com.tchajed.marshal.marshal; code.sync.sync; code.time.time; code.github_com.goose_lang.std.std; code.github_com.sanjit_bhat.pav.cryptoffi.cryptoffi; code.github_com.sanjit_bhat.pav.hashchain.hashchain; code.github_com.sanjit_bhat.pav.merkle.merkle];
  |}.

Definition initialize' : val :=
  λ: <>,
    package.init #server.server (λ: <>,
      exception_do (do:  (merkle.initialize' #());;;
      do:  (hashchain.initialize' #());;;
      do:  (cryptoffi.initialize' #());;;
      do:  (std.initialize' #());;;
      do:  (time.initialize' #());;;
      do:  (sync.initialize' #());;;
      do:  (marshal.initialize' #());;;
      do:  (safemarshal.initialize' #());;;
      do:  (ktcore.initialize' #());;;
      do:  (advrpc.initialize' #());;;
      do:  (package.alloc server.server #());;;
      let: "$r0" := #(W64 1024) in
      do:  ((globals.get #WorkQSize) <-[#intT] "$r0");;;
      let: "$r0" := #(W64 128) in
      do:  ((globals.get #BatchSize) <-[#intT] "$r0");;;
      let: "$r0" := time.Second in
      do:  ((globals.get #BatchTimeout) <-[#time.Duration] "$r0"))
      ).

End code.
End server.
