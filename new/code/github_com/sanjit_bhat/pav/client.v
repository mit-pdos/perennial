(* autogenerated from github.com/sanjit-bhat/pav/client *)
Require Export New.code.bytes.
Require Export New.code.github_com.goose_lang.std.
Require Export New.code.github_com.sanjit_bhat.pav.advrpc.
Require Export New.code.github_com.sanjit_bhat.pav.auditor.
Require Export New.code.github_com.sanjit_bhat.pav.cryptoffi.
Require Export New.code.github_com.sanjit_bhat.pav.hashchain.
Require Export New.code.github_com.sanjit_bhat.pav.ktcore.
Require Export New.code.github_com.sanjit_bhat.pav.merkle.
Require Export New.code.github_com.sanjit_bhat.pav.server.

From New.golang Require Import defn.
Definition client : go_string := "github.com/sanjit-bhat/pav/client".

Module client.

Module Client. Definition id : go_string := "github.com/sanjit-bhat/pav/client.Client"%go. End Client.
Module pending. Definition id : go_string := "github.com/sanjit-bhat/pav/client.pending"%go. End pending.
Module epoch. Definition id : go_string := "github.com/sanjit-bhat/pav/client.epoch"%go. End epoch.
Module serv. Definition id : go_string := "github.com/sanjit-bhat/pav/client.serv"%go. End serv.
Module Evid. Definition id : go_string := "github.com/sanjit-bhat/pav/client.Evid"%go. End Evid.
Module evidVrf. Definition id : go_string := "github.com/sanjit-bhat/pav/client.evidVrf"%go. End evidVrf.
Module evidLink. Definition id : go_string := "github.com/sanjit-bhat/pav/client.evidLink"%go. End evidLink.

Section code.
Context `{ffi_syntax}.


Definition Client : go_type := structT [
  "uid" :: uint64T;
  "pend" :: ptrT;
  "last" :: ptrT;
  "serv" :: ptrT
].

Definition pending : go_type := structT [
  "nextVer" :: uint64T;
  "isPending" :: boolT;
  "pk" :: sliceT
].

Definition epoch : go_type := structT [
  "epoch" :: uint64T;
  "dig" :: sliceT;
  "link" :: sliceT;
  "sig" :: sliceT
].

Definition serv : go_type := structT [
  "cli" :: ptrT;
  "sigPk" :: cryptoffi.SigPublicKey;
  "vrfPk" :: ptrT;
  "vrfSig" :: sliceT
].

(* Put queues pk for insertion.
   if we have a pending Put, it requires the pk to be the same.

   go: client.go:45:18 *)
Definition Client__Putⁱᵐᵖˡ : val :=
  λ: "c" "pk",
    exception_do (let: "c" := (mem.alloc "c") in
    let: "pk" := (mem.alloc "pk") in
    (if: ![#boolT] (struct.field_ref #pending #"isPending"%go (![#ptrT] (struct.field_ref #Client #"pend"%go (![#ptrT] "c"))))
    then
      do:  (let: "$a0" := (let: "$a0" := (![#sliceT] (struct.field_ref #pending #"pk"%go (![#ptrT] (struct.field_ref #Client #"pend"%go (![#ptrT] "c"))))) in
      let: "$a1" := (![#sliceT] "pk") in
      (func_call #bytes.Equal) "$a0" "$a1") in
      (func_call #std.Assert) "$a0")
    else
      let: "$r0" := #true in
      do:  ((struct.field_ref #pending #"isPending"%go (![#ptrT] (struct.field_ref #Client #"pend"%go (![#ptrT] "c")))) <-[#boolT] "$r0");;;
      let: "$r0" := (![#sliceT] "pk") in
      do:  ((struct.field_ref #pending #"pk"%go (![#ptrT] (struct.field_ref #Client #"pend"%go (![#ptrT] "c")))) <-[#sliceT] "$r0"));;;
    do:  (let: "$a0" := (![#ptrT] (struct.field_ref #serv #"cli"%go (![#ptrT] (struct.field_ref #Client #"serv"%go (![#ptrT] "c"))))) in
    let: "$a1" := (![#uint64T] (struct.field_ref #Client #"uid"%go (![#ptrT] "c"))) in
    let: "$a2" := (![#sliceT] "pk") in
    let: "$a3" := (![#uint64T] (struct.field_ref #pending #"nextVer"%go (![#ptrT] (struct.field_ref #Client #"pend"%go (![#ptrT] "c"))))) in
    (func_call #server.CallPut) "$a0" "$a1" "$a2" "$a3");;;
    return: #()).

Definition CheckNonMemb : go_string := "github.com/sanjit-bhat/pav/client.CheckNonMemb"%go.

Definition CheckHist : go_string := "github.com/sanjit-bhat/pav/client.CheckHist"%go.

(* Get a uid's pk.

   go: client.go:56:18 *)
Definition Client__Getⁱᵐᵖˡ : val :=
  λ: "c" "uid",
    exception_do (let: "err" := (mem.alloc (type.zero_val #ktcore.Blame)) in
    let: "pk" := (mem.alloc (type.zero_val #sliceT)) in
    let: "isReg" := (mem.alloc (type.zero_val #boolT)) in
    let: "ep" := (mem.alloc (type.zero_val #uint64T)) in
    let: "c" := (mem.alloc "c") in
    let: "uid" := (mem.alloc "uid") in
    let: "bound" := (mem.alloc (type.zero_val #ptrT)) in
    let: "hist" := (mem.alloc (type.zero_val #sliceT)) in
    let: "sig" := (mem.alloc (type.zero_val #sliceT)) in
    let: "chainProof" := (mem.alloc (type.zero_val #sliceT)) in
    let: (((("$ret0", "$ret1"), "$ret2"), "$ret3"), "$ret4") := (let: "$a0" := (![#ptrT] (struct.field_ref #serv #"cli"%go (![#ptrT] (struct.field_ref #Client #"serv"%go (![#ptrT] "c"))))) in
    let: "$a1" := (![#uint64T] "uid") in
    let: "$a2" := (![#uint64T] (struct.field_ref #epoch #"epoch"%go (![#ptrT] (struct.field_ref #Client #"last"%go (![#ptrT] "c"))))) in
    let: "$a3" := #(W64 0) in
    (func_call #server.CallHistory) "$a0" "$a1" "$a2" "$a3") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    let: "$r3" := "$ret3" in
    let: "$r4" := "$ret4" in
    do:  ("chainProof" <-[#sliceT] "$r0");;;
    do:  ("sig" <-[#sliceT] "$r1");;;
    do:  ("hist" <-[#sliceT] "$r2");;;
    do:  ("bound" <-[#ptrT] "$r3");;;
    do:  ("err" <-[#ktcore.Blame] "$r4");;;
    (if: (![#ktcore.Blame] "err") ≠ ktcore.BlameNone
    then return: (![#uint64T] "ep", ![#boolT] "isReg", ![#sliceT] "pk", ![#ktcore.Blame] "err")
    else do:  #());;;
    let: "errb" := (mem.alloc (type.zero_val #boolT)) in
    let: "last" := (mem.alloc (type.zero_val #ptrT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "chainProof") in
    let: "$a1" := (![#sliceT] "sig") in
    (method_call #(ptrT.id Client.id) #"getChainExt"%go (![#ptrT] "c")) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("last" <-[#ptrT] "$r0");;;
    do:  ("errb" <-[#boolT] "$r1");;;
    (if: ![#boolT] "errb"
    then
      let: "$r0" := ktcore.BlameServFull in
      do:  ("err" <-[#ktcore.Blame] "$r0");;;
      return: (![#uint64T] "ep", ![#boolT] "isReg", ![#sliceT] "pk", ![#ktcore.Blame] "err")
    else do:  #());;;
    (if: let: "$a0" := (![#ptrT] (struct.field_ref #serv #"vrfPk"%go (![#ptrT] (struct.field_ref #Client #"serv"%go (![#ptrT] "c"))))) in
    let: "$a1" := (![#uint64T] "uid") in
    let: "$a2" := #(W64 0) in
    let: "$a3" := (![#sliceT] (struct.field_ref #epoch #"dig"%go (![#ptrT] "last"))) in
    let: "$a4" := (![#sliceT] "hist") in
    (func_call #CheckHist) "$a0" "$a1" "$a2" "$a3" "$a4"
    then
      let: "$r0" := ktcore.BlameServFull in
      do:  ("err" <-[#ktcore.Blame] "$r0");;;
      return: (![#uint64T] "ep", ![#boolT] "isReg", ![#sliceT] "pk", ![#ktcore.Blame] "err")
    else do:  #());;;
    let: "boundVer" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (s_to_w64 (let: "$a0" := (![#sliceT] "hist") in
    slice.len "$a0")) in
    do:  ("boundVer" <-[#uint64T] "$r0");;;
    (if: let: "$a0" := (![#ptrT] (struct.field_ref #serv #"vrfPk"%go (![#ptrT] (struct.field_ref #Client #"serv"%go (![#ptrT] "c"))))) in
    let: "$a1" := (![#uint64T] "uid") in
    let: "$a2" := (![#uint64T] "boundVer") in
    let: "$a3" := (![#sliceT] (struct.field_ref #epoch #"dig"%go (![#ptrT] "last"))) in
    let: "$a4" := (![#ptrT] "bound") in
    (func_call #CheckNonMemb) "$a0" "$a1" "$a2" "$a3" "$a4"
    then
      let: "$r0" := ktcore.BlameServFull in
      do:  ("err" <-[#ktcore.Blame] "$r0");;;
      return: (![#uint64T] "ep", ![#boolT] "isReg", ![#sliceT] "pk", ![#ktcore.Blame] "err")
    else do:  #());;;
    let: "$r0" := (![#ptrT] "last") in
    do:  ((struct.field_ref #Client #"last"%go (![#ptrT] "c")) <-[#ptrT] "$r0");;;
    (if: (![#uint64T] "boundVer") = #(W64 0)
    then return: (![#uint64T] (struct.field_ref #epoch #"epoch"%go (![#ptrT] "last")), #false, #slice.nil, ktcore.BlameNone)
    else
      let: "lastKey" := (mem.alloc (type.zero_val #ptrT)) in
      let: "$r0" := (![#ptrT] (slice.elem_ref #ptrT (![#sliceT] "hist") ((![#uint64T] "boundVer") - #(W64 1)))) in
      do:  ("lastKey" <-[#ptrT] "$r0");;;
      return: (![#uint64T] (struct.field_ref #epoch #"epoch"%go (![#ptrT] "last")), #true, ![#sliceT] (struct.field_ref #ktcore.CommitOpen #"Val"%go (![#ptrT] (struct.field_ref #ktcore.Memb #"PkOpen"%go (![#ptrT] "lastKey")))), ktcore.BlameNone))).

(* SelfMon a client's own uid.
   if isChanged, the key was added sometime from the last SelfMon.

   go: client.go:89:18 *)
Definition Client__SelfMonⁱᵐᵖˡ : val :=
  λ: "c" <>,
    exception_do (let: "err" := (mem.alloc (type.zero_val #ktcore.Blame)) in
    let: "isChanged" := (mem.alloc (type.zero_val #boolT)) in
    let: "ep" := (mem.alloc (type.zero_val #uint64T)) in
    let: "c" := (mem.alloc "c") in
    let: "bound" := (mem.alloc (type.zero_val #ptrT)) in
    let: "hist" := (mem.alloc (type.zero_val #sliceT)) in
    let: "sig" := (mem.alloc (type.zero_val #sliceT)) in
    let: "chainProof" := (mem.alloc (type.zero_val #sliceT)) in
    let: (((("$ret0", "$ret1"), "$ret2"), "$ret3"), "$ret4") := (let: "$a0" := (![#ptrT] (struct.field_ref #serv #"cli"%go (![#ptrT] (struct.field_ref #Client #"serv"%go (![#ptrT] "c"))))) in
    let: "$a1" := (![#uint64T] (struct.field_ref #Client #"uid"%go (![#ptrT] "c"))) in
    let: "$a2" := (![#uint64T] (struct.field_ref #epoch #"epoch"%go (![#ptrT] (struct.field_ref #Client #"last"%go (![#ptrT] "c"))))) in
    let: "$a3" := (![#uint64T] (struct.field_ref #pending #"nextVer"%go (![#ptrT] (struct.field_ref #Client #"pend"%go (![#ptrT] "c"))))) in
    (func_call #server.CallHistory) "$a0" "$a1" "$a2" "$a3") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    let: "$r3" := "$ret3" in
    let: "$r4" := "$ret4" in
    do:  ("chainProof" <-[#sliceT] "$r0");;;
    do:  ("sig" <-[#sliceT] "$r1");;;
    do:  ("hist" <-[#sliceT] "$r2");;;
    do:  ("bound" <-[#ptrT] "$r3");;;
    do:  ("err" <-[#ktcore.Blame] "$r4");;;
    (if: (![#ktcore.Blame] "err") ≠ ktcore.BlameNone
    then return: (![#uint64T] "ep", ![#boolT] "isChanged", ![#ktcore.Blame] "err")
    else do:  #());;;
    let: "errb" := (mem.alloc (type.zero_val #boolT)) in
    let: "last" := (mem.alloc (type.zero_val #ptrT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "chainProof") in
    let: "$a1" := (![#sliceT] "sig") in
    (method_call #(ptrT.id Client.id) #"getChainExt"%go (![#ptrT] "c")) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("last" <-[#ptrT] "$r0");;;
    do:  ("errb" <-[#boolT] "$r1");;;
    (if: ![#boolT] "errb"
    then
      let: "$r0" := ktcore.BlameServFull in
      do:  ("err" <-[#ktcore.Blame] "$r0");;;
      return: (![#uint64T] "ep", ![#boolT] "isChanged", ![#ktcore.Blame] "err")
    else do:  #());;;
    (if: let: "$a0" := (![#ptrT] (struct.field_ref #serv #"vrfPk"%go (![#ptrT] (struct.field_ref #Client #"serv"%go (![#ptrT] "c"))))) in
    let: "$a1" := (![#uint64T] (struct.field_ref #Client #"uid"%go (![#ptrT] "c"))) in
    let: "$a2" := (![#uint64T] (struct.field_ref #pending #"nextVer"%go (![#ptrT] (struct.field_ref #Client #"pend"%go (![#ptrT] "c"))))) in
    let: "$a3" := (![#sliceT] (struct.field_ref #epoch #"dig"%go (![#ptrT] "last"))) in
    let: "$a4" := (![#sliceT] "hist") in
    (func_call #CheckHist) "$a0" "$a1" "$a2" "$a3" "$a4"
    then
      let: "$r0" := ktcore.BlameServFull in
      do:  ("err" <-[#ktcore.Blame] "$r0");;;
      return: (![#uint64T] "ep", ![#boolT] "isChanged", ![#ktcore.Blame] "err")
    else do:  #());;;
    let: "histLen" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (s_to_w64 (let: "$a0" := (![#sliceT] "hist") in
    slice.len "$a0")) in
    do:  ("histLen" <-[#uint64T] "$r0");;;
    let: "boundVer" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := ((![#uint64T] (struct.field_ref #pending #"nextVer"%go (![#ptrT] (struct.field_ref #Client #"pend"%go (![#ptrT] "c"))))) + (![#uint64T] "histLen")) in
    do:  ("boundVer" <-[#uint64T] "$r0");;;
    (if: let: "$a0" := (![#ptrT] (struct.field_ref #serv #"vrfPk"%go (![#ptrT] (struct.field_ref #Client #"serv"%go (![#ptrT] "c"))))) in
    let: "$a1" := (![#uint64T] (struct.field_ref #Client #"uid"%go (![#ptrT] "c"))) in
    let: "$a2" := (![#uint64T] "boundVer") in
    let: "$a3" := (![#sliceT] (struct.field_ref #epoch #"dig"%go (![#ptrT] "last"))) in
    let: "$a4" := (![#ptrT] "bound") in
    (func_call #CheckNonMemb) "$a0" "$a1" "$a2" "$a3" "$a4"
    then
      let: "$r0" := ktcore.BlameServFull in
      do:  ("err" <-[#ktcore.Blame] "$r0");;;
      return: (![#uint64T] "ep", ![#boolT] "isChanged", ![#ktcore.Blame] "err")
    else do:  #());;;
    (if: (~ (![#boolT] (struct.field_ref #pending #"isPending"%go (![#ptrT] (struct.field_ref #Client #"pend"%go (![#ptrT] "c"))))))
    then
      (if: (![#uint64T] "histLen") ≠ #(W64 0)
      then
        let: "$r0" := (ktcore.BlameServFull `or` ktcore.BlameClients) in
        do:  ("err" <-[#ktcore.Blame] "$r0");;;
        return: (![#uint64T] "ep", ![#boolT] "isChanged", ![#ktcore.Blame] "err")
      else do:  #());;;
      let: "$r0" := (![#ptrT] "last") in
      do:  ((struct.field_ref #Client #"last"%go (![#ptrT] "c")) <-[#ptrT] "$r0");;;
      return: (![#uint64T] (struct.field_ref #epoch #"epoch"%go (![#ptrT] "last")), #false, ktcore.BlameNone)
    else do:  #());;;
    (if: (![#uint64T] "histLen") > #(W64 1)
    then
      let: "$r0" := (ktcore.BlameServFull `or` ktcore.BlameClients) in
      do:  ("err" <-[#ktcore.Blame] "$r0");;;
      return: (![#uint64T] "ep", ![#boolT] "isChanged", ![#ktcore.Blame] "err")
    else do:  #());;;
    (if: (![#uint64T] "histLen") = #(W64 0)
    then
      let: "$r0" := (![#ptrT] "last") in
      do:  ((struct.field_ref #Client #"last"%go (![#ptrT] "c")) <-[#ptrT] "$r0");;;
      return: (![#uint64T] (struct.field_ref #epoch #"epoch"%go (![#ptrT] "last")), #false, ktcore.BlameNone)
    else do:  #());;;
    let: "newKey" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (![#ptrT] (slice.elem_ref #ptrT (![#sliceT] "hist") #(W64 0))) in
    do:  ("newKey" <-[#ptrT] "$r0");;;
    (if: (~ (let: "$a0" := (![#sliceT] (struct.field_ref #ktcore.CommitOpen #"Val"%go (![#ptrT] (struct.field_ref #ktcore.Memb #"PkOpen"%go (![#ptrT] "newKey"))))) in
    let: "$a1" := (![#sliceT] (struct.field_ref #pending #"pk"%go (![#ptrT] (struct.field_ref #Client #"pend"%go (![#ptrT] "c"))))) in
    (func_call #bytes.Equal) "$a0" "$a1"))
    then
      let: "$r0" := (ktcore.BlameServFull `or` ktcore.BlameClients) in
      do:  ("err" <-[#ktcore.Blame] "$r0");;;
      return: (![#uint64T] "ep", ![#boolT] "isChanged", ![#ktcore.Blame] "err")
    else do:  #());;;
    let: "$r0" := (![#ptrT] "last") in
    do:  ((struct.field_ref #Client #"last"%go (![#ptrT] "c")) <-[#ptrT] "$r0");;;
    let: "$r0" := #false in
    do:  ((struct.field_ref #pending #"isPending"%go (![#ptrT] (struct.field_ref #Client #"pend"%go (![#ptrT] "c")))) <-[#boolT] "$r0");;;
    let: "$r0" := #slice.nil in
    do:  ((struct.field_ref #pending #"pk"%go (![#ptrT] (struct.field_ref #Client #"pend"%go (![#ptrT] "c")))) <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#uint64T] (struct.field_ref #pending #"nextVer"%go (![#ptrT] (struct.field_ref #Client #"pend"%go (![#ptrT] "c"))))) in
    let: "$a1" := #(W64 1) in
    (func_call #std.SumAssumeNoOverflow) "$a0" "$a1") in
    do:  ((struct.field_ref #pending #"nextVer"%go (![#ptrT] (struct.field_ref #Client #"pend"%go (![#ptrT] "c")))) <-[#uint64T] "$r0");;;
    return: (![#uint64T] (struct.field_ref #epoch #"epoch"%go (![#ptrT] "last")), #true, ktcore.BlameNone)).

Definition Evid : go_type := structT [
  "vrf" :: ptrT;
  "link" :: ptrT
].

Definition evidLink : go_type := structT [
  "epoch" :: uint64T;
  "link0" :: sliceT;
  "sig0" :: sliceT;
  "link1" :: sliceT;
  "sig1" :: sliceT
].

Definition evidVrf : go_type := structT [
  "vrfPk0" :: sliceT;
  "sig0" :: sliceT;
  "vrfPk1" :: sliceT;
  "sig1" :: sliceT
].

(* go: client.go:148:18 *)
Definition Client__Auditⁱᵐᵖˡ : val :=
  λ: "c" "adtrAddr" "adtrPk",
    exception_do (let: "err" := (mem.alloc (type.zero_val #ktcore.Blame)) in
    let: "evid" := (mem.alloc (type.zero_val #ptrT)) in
    let: "c" := (mem.alloc "c") in
    let: "adtrPk" := (mem.alloc "adtrPk") in
    let: "adtrAddr" := (mem.alloc "adtrAddr") in
    let: "cli" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := (![#uint64T] "adtrAddr") in
    (func_call #advrpc.Dial) "$a0") in
    do:  ("cli" <-[#ptrT] "$r0");;;
    let: "last" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (![#ptrT] (struct.field_ref #Client #"last"%go (![#ptrT] "c"))) in
    do:  ("last" <-[#ptrT] "$r0");;;
    let: "audit" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := (![#ptrT] "cli") in
    let: "$a1" := (![#uint64T] (struct.field_ref #epoch #"epoch"%go (![#ptrT] "last"))) in
    (func_call #auditor.CallGet) "$a0" "$a1") in
    do:  ("audit" <-[#ptrT] "$r0");;;
    (if: (![#ktcore.Blame] (struct.field_ref #auditor.GetReply #"Err"%go (![#ptrT] "audit"))) ≠ ktcore.BlameNone
    then
      let: "$r0" := (![#ktcore.Blame] (struct.field_ref #auditor.GetReply #"Err"%go (![#ptrT] "audit"))) in
      do:  ("err" <-[#ktcore.Blame] "$r0");;;
      return: (![#ptrT] "evid", ![#ktcore.Blame] "err")
    else do:  #());;;
    (if: let: "$a0" := (![#cryptoffi.SigPublicKey] "adtrPk") in
    let: "$a1" := (![#sliceT] (struct.field_ref #auditor.GetReply #"VrfPk"%go (![#ptrT] "audit"))) in
    let: "$a2" := (![#sliceT] (struct.field_ref #auditor.GetReply #"AdtrVrfSig"%go (![#ptrT] "audit"))) in
    (func_call #ktcore.VerifyVrfSig) "$a0" "$a1" "$a2"
    then
      let: "$r0" := ktcore.BlameAdtrFull in
      do:  ("err" <-[#ktcore.Blame] "$r0");;;
      return: (![#ptrT] "evid", ![#ktcore.Blame] "err")
    else do:  #());;;
    (if: let: "$a0" := (![#cryptoffi.SigPublicKey] (struct.field_ref #serv #"sigPk"%go (![#ptrT] (struct.field_ref #Client #"serv"%go (![#ptrT] "c"))))) in
    let: "$a1" := (![#sliceT] (struct.field_ref #auditor.GetReply #"VrfPk"%go (![#ptrT] "audit"))) in
    let: "$a2" := (![#sliceT] (struct.field_ref #auditor.GetReply #"ServVrfSig"%go (![#ptrT] "audit"))) in
    (func_call #ktcore.VerifyVrfSig) "$a0" "$a1" "$a2"
    then
      let: "$r0" := ktcore.BlameAdtrFull in
      do:  ("err" <-[#ktcore.Blame] "$r0");;;
      return: (![#ptrT] "evid", ![#ktcore.Blame] "err")
    else do:  #());;;
    let: "vrfPkB" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#ptrT] (struct.field_ref #serv #"vrfPk"%go (![#ptrT] (struct.field_ref #Client #"serv"%go (![#ptrT] "c"))))) in
    (func_call #cryptoffi.VrfPublicKeyEncode) "$a0") in
    do:  ("vrfPkB" <-[#sliceT] "$r0");;;
    (if: (~ (let: "$a0" := (![#sliceT] "vrfPkB") in
    let: "$a1" := (![#sliceT] (struct.field_ref #auditor.GetReply #"VrfPk"%go (![#ptrT] "audit"))) in
    (func_call #bytes.Equal) "$a0" "$a1"))
    then
      let: "$r0" := (mem.alloc (let: "$vrf" := (mem.alloc (let: "$vrfPk0" := (![#sliceT] "vrfPkB") in
      let: "$sig0" := (![#sliceT] (struct.field_ref #serv #"vrfSig"%go (![#ptrT] (struct.field_ref #Client #"serv"%go (![#ptrT] "c"))))) in
      let: "$vrfPk1" := (![#sliceT] (struct.field_ref #auditor.GetReply #"VrfPk"%go (![#ptrT] "audit"))) in
      let: "$sig1" := (![#sliceT] (struct.field_ref #auditor.GetReply #"ServVrfSig"%go (![#ptrT] "audit"))) in
      struct.make #evidVrf [{
        "vrfPk0" ::= "$vrfPk0";
        "sig0" ::= "$sig0";
        "vrfPk1" ::= "$vrfPk1";
        "sig1" ::= "$sig1"
      }])) in
      struct.make #Evid [{
        "vrf" ::= "$vrf";
        "link" ::= type.zero_val #ptrT
      }])) in
      do:  ("evid" <-[#ptrT] "$r0");;;
      let: "$r0" := ktcore.BlameServSig in
      do:  ("err" <-[#ktcore.Blame] "$r0");;;
      return: (![#ptrT] "evid", ![#ktcore.Blame] "err")
    else do:  #());;;
    (if: let: "$a0" := (![#cryptoffi.SigPublicKey] "adtrPk") in
    let: "$a1" := (![#uint64T] (struct.field_ref #epoch #"epoch"%go (![#ptrT] "last"))) in
    let: "$a2" := (![#sliceT] (struct.field_ref #auditor.GetReply #"Link"%go (![#ptrT] "audit"))) in
    let: "$a3" := (![#sliceT] (struct.field_ref #auditor.GetReply #"AdtrLinkSig"%go (![#ptrT] "audit"))) in
    (func_call #ktcore.VerifyLinkSig) "$a0" "$a1" "$a2" "$a3"
    then
      let: "$r0" := ktcore.BlameAdtrFull in
      do:  ("err" <-[#ktcore.Blame] "$r0");;;
      return: (![#ptrT] "evid", ![#ktcore.Blame] "err")
    else do:  #());;;
    (if: let: "$a0" := (![#cryptoffi.SigPublicKey] (struct.field_ref #serv #"sigPk"%go (![#ptrT] (struct.field_ref #Client #"serv"%go (![#ptrT] "c"))))) in
    let: "$a1" := (![#uint64T] (struct.field_ref #epoch #"epoch"%go (![#ptrT] "last"))) in
    let: "$a2" := (![#sliceT] (struct.field_ref #auditor.GetReply #"Link"%go (![#ptrT] "audit"))) in
    let: "$a3" := (![#sliceT] (struct.field_ref #auditor.GetReply #"ServLinkSig"%go (![#ptrT] "audit"))) in
    (func_call #ktcore.VerifyLinkSig) "$a0" "$a1" "$a2" "$a3"
    then
      let: "$r0" := ktcore.BlameAdtrFull in
      do:  ("err" <-[#ktcore.Blame] "$r0");;;
      return: (![#ptrT] "evid", ![#ktcore.Blame] "err")
    else do:  #());;;
    (if: (~ (let: "$a0" := (![#sliceT] (struct.field_ref #epoch #"link"%go (![#ptrT] "last"))) in
    let: "$a1" := (![#sliceT] (struct.field_ref #auditor.GetReply #"Link"%go (![#ptrT] "audit"))) in
    (func_call #bytes.Equal) "$a0" "$a1"))
    then
      let: "$r0" := (mem.alloc (let: "$link" := (mem.alloc (let: "$epoch" := (![#uint64T] (struct.field_ref #epoch #"epoch"%go (![#ptrT] "last"))) in
      let: "$link0" := (![#sliceT] (struct.field_ref #epoch #"link"%go (![#ptrT] "last"))) in
      let: "$sig0" := (![#sliceT] (struct.field_ref #epoch #"sig"%go (![#ptrT] "last"))) in
      let: "$link1" := (![#sliceT] (struct.field_ref #auditor.GetReply #"Link"%go (![#ptrT] "audit"))) in
      let: "$sig1" := (![#sliceT] (struct.field_ref #auditor.GetReply #"ServLinkSig"%go (![#ptrT] "audit"))) in
      struct.make #evidLink [{
        "epoch" ::= "$epoch";
        "link0" ::= "$link0";
        "sig0" ::= "$sig0";
        "link1" ::= "$link1";
        "sig1" ::= "$sig1"
      }])) in
      struct.make #Evid [{
        "vrf" ::= type.zero_val #ptrT;
        "link" ::= "$link"
      }])) in
      do:  ("evid" <-[#ptrT] "$r0");;;
      let: "$r0" := ktcore.BlameServSig in
      do:  ("err" <-[#ktcore.Blame] "$r0");;;
      return: (![#ptrT] "evid", ![#ktcore.Blame] "err")
    else do:  #());;;
    return: (![#ptrT] "evid", ![#ktcore.Blame] "err")).

Definition New : go_string := "github.com/sanjit-bhat/pav/client.New"%go.

(* go: client.go:193:6 *)
Definition Newⁱᵐᵖˡ : val :=
  λ: "uid" "servAddr" "servPk",
    exception_do (let: "err" := (mem.alloc (type.zero_val #ktcore.Blame)) in
    let: "c" := (mem.alloc (type.zero_val #ptrT)) in
    let: "servPk" := (mem.alloc "servPk") in
    let: "servAddr" := (mem.alloc "servAddr") in
    let: "uid" := (mem.alloc "uid") in
    let: "cli" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := (![#uint64T] "servAddr") in
    (func_call #advrpc.Dial) "$a0") in
    do:  ("cli" <-[#ptrT] "$r0");;;
    let: "reply" := (mem.alloc (type.zero_val #ptrT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#ptrT] "cli") in
    (func_call #server.CallStart) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("reply" <-[#ptrT] "$r0");;;
    do:  ("err" <-[#ktcore.Blame] "$r1");;;
    (if: (![#ktcore.Blame] "err") ≠ ktcore.BlameNone
    then return: (![#ptrT] "c", ![#ktcore.Blame] "err")
    else do:  #());;;
    (if: (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref #server.StartReply #"StartLink"%go (![#ptrT] "reply"))) in
    slice.len "$a0")) ≠ cryptoffi.HashLen
    then
      let: "$r0" := ktcore.BlameServFull in
      do:  ("err" <-[#ktcore.Blame] "$r0");;;
      return: (![#ptrT] "c", ![#ktcore.Blame] "err")
    else do:  #());;;
    let: "errb" := (mem.alloc (type.zero_val #boolT)) in
    let: "newLink" := (mem.alloc (type.zero_val #sliceT)) in
    let: "newDig" := (mem.alloc (type.zero_val #sliceT)) in
    let: "extLen" := (mem.alloc (type.zero_val #uint64T)) in
    let: ((("$ret0", "$ret1"), "$ret2"), "$ret3") := (let: "$a0" := (![#sliceT] (struct.field_ref #server.StartReply #"StartLink"%go (![#ptrT] "reply"))) in
    let: "$a1" := (![#sliceT] (struct.field_ref #server.StartReply #"ChainProof"%go (![#ptrT] "reply"))) in
    (func_call #hashchain.Verify) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    let: "$r3" := "$ret3" in
    do:  ("extLen" <-[#uint64T] "$r0");;;
    do:  ("newDig" <-[#sliceT] "$r1");;;
    do:  ("newLink" <-[#sliceT] "$r2");;;
    do:  ("errb" <-[#boolT] "$r3");;;
    (if: ![#boolT] "errb"
    then
      let: "$r0" := ktcore.BlameServFull in
      do:  ("err" <-[#ktcore.Blame] "$r0");;;
      return: (![#ptrT] "c", ![#ktcore.Blame] "err")
    else do:  #());;;
    (if: (![#uint64T] "extLen") = #(W64 0)
    then
      let: "$r0" := ktcore.BlameServFull in
      do:  ("err" <-[#ktcore.Blame] "$r0");;;
      return: (![#ptrT] "c", ![#ktcore.Blame] "err")
    else do:  #());;;
    (if: (~ (let: "$a0" := (![#uint64T] (struct.field_ref #server.StartReply #"StartEpochLen"%go (![#ptrT] "reply"))) in
    let: "$a1" := ((![#uint64T] "extLen") - #(W64 1)) in
    (func_call #std.SumNoOverflow) "$a0" "$a1"))
    then
      let: "$r0" := ktcore.BlameServFull in
      do:  ("err" <-[#ktcore.Blame] "$r0");;;
      return: (![#ptrT] "c", ![#ktcore.Blame] "err")
    else do:  #());;;
    let: "lastEp" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (((![#uint64T] (struct.field_ref #server.StartReply #"StartEpochLen"%go (![#ptrT] "reply"))) + (![#uint64T] "extLen")) - #(W64 1)) in
    do:  ("lastEp" <-[#uint64T] "$r0");;;
    (if: let: "$a0" := (![#cryptoffi.SigPublicKey] "servPk") in
    let: "$a1" := (![#uint64T] "lastEp") in
    let: "$a2" := (![#sliceT] "newLink") in
    let: "$a3" := (![#sliceT] (struct.field_ref #server.StartReply #"LinkSig"%go (![#ptrT] "reply"))) in
    (func_call #ktcore.VerifyLinkSig) "$a0" "$a1" "$a2" "$a3"
    then
      let: "$r0" := ktcore.BlameServFull in
      do:  ("err" <-[#ktcore.Blame] "$r0");;;
      return: (![#ptrT] "c", ![#ktcore.Blame] "err")
    else do:  #());;;
    let: "vrfPk" := (mem.alloc (type.zero_val #ptrT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] (struct.field_ref #server.StartReply #"VrfPk"%go (![#ptrT] "reply"))) in
    (func_call #cryptoffi.VrfPublicKeyDecode) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("vrfPk" <-[#ptrT] "$r0");;;
    do:  ("errb" <-[#boolT] "$r1");;;
    (if: ![#boolT] "errb"
    then
      let: "$r0" := ktcore.BlameServFull in
      do:  ("err" <-[#ktcore.Blame] "$r0");;;
      return: (![#ptrT] "c", ![#ktcore.Blame] "err")
    else do:  #());;;
    (if: let: "$a0" := (![#cryptoffi.SigPublicKey] "servPk") in
    let: "$a1" := (![#sliceT] (struct.field_ref #server.StartReply #"VrfPk"%go (![#ptrT] "reply"))) in
    let: "$a2" := (![#sliceT] (struct.field_ref #server.StartReply #"VrfSig"%go (![#ptrT] "reply"))) in
    (func_call #ktcore.VerifyVrfSig) "$a0" "$a1" "$a2"
    then
      let: "$r0" := ktcore.BlameServFull in
      do:  ("err" <-[#ktcore.Blame] "$r0");;;
      return: (![#ptrT] "c", ![#ktcore.Blame] "err")
    else do:  #());;;
    let: "pendingPut" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (struct.make #pending [{
      "nextVer" ::= type.zero_val #uint64T;
      "isPending" ::= type.zero_val #boolT;
      "pk" ::= type.zero_val #sliceT
    }])) in
    do:  ("pendingPut" <-[#ptrT] "$r0");;;
    let: "last" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (let: "$epoch" := (![#uint64T] "lastEp") in
    let: "$dig" := (![#sliceT] "newDig") in
    let: "$link" := (![#sliceT] "newLink") in
    let: "$sig" := (![#sliceT] (struct.field_ref #server.StartReply #"LinkSig"%go (![#ptrT] "reply"))) in
    struct.make #epoch [{
      "epoch" ::= "$epoch";
      "dig" ::= "$dig";
      "link" ::= "$link";
      "sig" ::= "$sig"
    }])) in
    do:  ("last" <-[#ptrT] "$r0");;;
    let: "serv" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (let: "$cli" := (![#ptrT] "cli") in
    let: "$sigPk" := (![#cryptoffi.SigPublicKey] "servPk") in
    let: "$vrfPk" := (![#ptrT] "vrfPk") in
    let: "$vrfSig" := (![#sliceT] (struct.field_ref #server.StartReply #"VrfSig"%go (![#ptrT] "reply"))) in
    struct.make #serv [{
      "cli" ::= "$cli";
      "sigPk" ::= "$sigPk";
      "vrfPk" ::= "$vrfPk";
      "vrfSig" ::= "$vrfSig"
    }])) in
    do:  ("serv" <-[#ptrT] "$r0");;;
    let: "$r0" := (mem.alloc (let: "$uid" := (![#uint64T] "uid") in
    let: "$pend" := (![#ptrT] "pendingPut") in
    let: "$last" := (![#ptrT] "last") in
    let: "$serv" := (![#ptrT] "serv") in
    struct.make #Client [{
      "uid" ::= "$uid";
      "pend" ::= "$pend";
      "last" ::= "$last";
      "serv" ::= "$serv"
    }])) in
    do:  ("c" <-[#ptrT] "$r0");;;
    return: (![#ptrT] "c", ![#ktcore.Blame] "err")).

(* go: client.go:239:18 *)
Definition Client__getChainExtⁱᵐᵖˡ : val :=
  λ: "c" "chainProof" "sig",
    exception_do (let: "err" := (mem.alloc (type.zero_val #boolT)) in
    let: "ep" := (mem.alloc (type.zero_val #ptrT)) in
    let: "c" := (mem.alloc "c") in
    let: "sig" := (mem.alloc "sig") in
    let: "chainProof" := (mem.alloc "chainProof") in
    let: "newLink" := (mem.alloc (type.zero_val #sliceT)) in
    let: "newDig" := (mem.alloc (type.zero_val #sliceT)) in
    let: "extLen" := (mem.alloc (type.zero_val #uint64T)) in
    let: ((("$ret0", "$ret1"), "$ret2"), "$ret3") := (let: "$a0" := (![#sliceT] (struct.field_ref #epoch #"link"%go (![#ptrT] (struct.field_ref #Client #"last"%go (![#ptrT] "c"))))) in
    let: "$a1" := (![#sliceT] "chainProof") in
    (func_call #hashchain.Verify) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    let: "$r3" := "$ret3" in
    do:  ("extLen" <-[#uint64T] "$r0");;;
    do:  ("newDig" <-[#sliceT] "$r1");;;
    do:  ("newLink" <-[#sliceT] "$r2");;;
    do:  ("err" <-[#boolT] "$r3");;;
    (if: ![#boolT] "err"
    then return: (![#ptrT] "ep", ![#boolT] "err")
    else do:  #());;;
    (if: (![#uint64T] "extLen") = #(W64 0)
    then
      let: "$r0" := (![#ptrT] (struct.field_ref #Client #"last"%go (![#ptrT] "c"))) in
      do:  ("ep" <-[#ptrT] "$r0");;;
      return: (![#ptrT] "ep", ![#boolT] "err")
    else do:  #());;;
    (if: (~ (let: "$a0" := (![#uint64T] (struct.field_ref #epoch #"epoch"%go (![#ptrT] (struct.field_ref #Client #"last"%go (![#ptrT] "c"))))) in
    let: "$a1" := (![#uint64T] "extLen") in
    (func_call #std.SumNoOverflow) "$a0" "$a1"))
    then
      let: "$r0" := #true in
      do:  ("err" <-[#boolT] "$r0");;;
      return: (![#ptrT] "ep", ![#boolT] "err")
    else do:  #());;;
    let: "newEp" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := ((![#uint64T] (struct.field_ref #epoch #"epoch"%go (![#ptrT] (struct.field_ref #Client #"last"%go (![#ptrT] "c"))))) + (![#uint64T] "extLen")) in
    do:  ("newEp" <-[#uint64T] "$r0");;;
    (if: let: "$a0" := (![#cryptoffi.SigPublicKey] (struct.field_ref #serv #"sigPk"%go (![#ptrT] (struct.field_ref #Client #"serv"%go (![#ptrT] "c"))))) in
    let: "$a1" := (![#uint64T] "newEp") in
    let: "$a2" := (![#sliceT] "newLink") in
    let: "$a3" := (![#sliceT] "sig") in
    (func_call #ktcore.VerifyLinkSig) "$a0" "$a1" "$a2" "$a3"
    then
      let: "$r0" := #true in
      do:  ("err" <-[#boolT] "$r0");;;
      return: (![#ptrT] "ep", ![#boolT] "err")
    else do:  #());;;
    let: "$r0" := (mem.alloc (let: "$epoch" := (![#uint64T] "newEp") in
    let: "$dig" := (![#sliceT] "newDig") in
    let: "$link" := (![#sliceT] "newLink") in
    let: "$sig" := (![#sliceT] "sig") in
    struct.make #epoch [{
      "epoch" ::= "$epoch";
      "dig" ::= "$dig";
      "link" ::= "$link";
      "sig" ::= "$sig"
    }])) in
    do:  ("ep" <-[#ptrT] "$r0");;;
    return: (![#ptrT] "ep", ![#boolT] "err")).

Definition CheckMemb : go_string := "github.com/sanjit-bhat/pav/client.CheckMemb"%go.

(* go: client.go:261:6 *)
Definition CheckMembⁱᵐᵖˡ : val :=
  λ: "vrfPk" "uid" "ver" "dig" "memb",
    exception_do (let: "err" := (mem.alloc (type.zero_val #boolT)) in
    let: "memb" := (mem.alloc "memb") in
    let: "dig" := (mem.alloc "dig") in
    let: "ver" := (mem.alloc "ver") in
    let: "uid" := (mem.alloc "uid") in
    let: "vrfPk" := (mem.alloc "vrfPk") in
    let: "label" := (mem.alloc (type.zero_val #sliceT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#ptrT] "vrfPk") in
    let: "$a1" := (![#uint64T] "uid") in
    let: "$a2" := (![#uint64T] "ver") in
    let: "$a3" := (![#sliceT] (struct.field_ref #ktcore.Memb #"LabelProof"%go (![#ptrT] "memb"))) in
    (func_call #ktcore.CheckMapLabel) "$a0" "$a1" "$a2" "$a3") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("label" <-[#sliceT] "$r0");;;
    do:  ("err" <-[#boolT] "$r1");;;
    (if: ![#boolT] "err"
    then return: (![#boolT] "err")
    else do:  #());;;
    let: "mapVal" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#ptrT] (struct.field_ref #ktcore.Memb #"PkOpen"%go (![#ptrT] "memb"))) in
    (func_call #ktcore.GetMapVal) "$a0") in
    do:  ("mapVal" <-[#sliceT] "$r0");;;
    let: "dig0" := (mem.alloc (type.zero_val #sliceT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "label") in
    let: "$a1" := (![#sliceT] "mapVal") in
    let: "$a2" := (![#sliceT] (struct.field_ref #ktcore.Memb #"MerkleProof"%go (![#ptrT] "memb"))) in
    (func_call #merkle.VerifyMemb) "$a0" "$a1" "$a2") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("dig0" <-[#sliceT] "$r0");;;
    do:  ("err" <-[#boolT] "$r1");;;
    (if: ![#boolT] "err"
    then return: (![#boolT] "err")
    else do:  #());;;
    (if: (~ (let: "$a0" := (![#sliceT] "dig") in
    let: "$a1" := (![#sliceT] "dig0") in
    (func_call #bytes.Equal) "$a0" "$a1"))
    then
      let: "$r0" := #true in
      do:  ("err" <-[#boolT] "$r0");;;
      return: (![#boolT] "err")
    else do:  #());;;
    return: (![#boolT] "err")).

(* go: client.go:278:6 *)
Definition CheckHistⁱᵐᵖˡ : val :=
  λ: "vrfPk" "uid" "prefixLen" "dig" "hist",
    exception_do (let: "err" := (mem.alloc (type.zero_val #boolT)) in
    let: "hist" := (mem.alloc "hist") in
    let: "dig" := (mem.alloc "dig") in
    let: "prefixLen" := (mem.alloc "prefixLen") in
    let: "uid" := (mem.alloc "uid") in
    let: "vrfPk" := (mem.alloc "vrfPk") in
    let: "$range" := (![#sliceT] "hist") in
    (let: "memb" := (mem.alloc (type.zero_val #ptrT)) in
    let: "ver" := (mem.alloc (type.zero_val #intT)) in
    slice.for_range #ptrT "$range" (λ: "$key" "$value",
      do:  ("memb" <-[#ptrT] "$value");;;
      do:  ("ver" <-[#intT] "$key");;;
      (let: "$r0" := (let: "$a0" := (![#ptrT] "vrfPk") in
      let: "$a1" := (![#uint64T] "uid") in
      let: "$a2" := ((![#uint64T] "prefixLen") + (s_to_w64 (![#intT] "ver"))) in
      let: "$a3" := (![#sliceT] "dig") in
      let: "$a4" := (![#ptrT] "memb") in
      (func_call #CheckMemb) "$a0" "$a1" "$a2" "$a3" "$a4") in
      do:  ("err" <-[#boolT] "$r0");;;
      (if: ![#boolT] "err"
      then return: (![#boolT] "err")
      else do:  #()))));;;
    return: (![#boolT] "err")).

(* go: client.go:287:6 *)
Definition CheckNonMembⁱᵐᵖˡ : val :=
  λ: "vrfPk" "uid" "ver" "dig" "nonMemb",
    exception_do (let: "err" := (mem.alloc (type.zero_val #boolT)) in
    let: "nonMemb" := (mem.alloc "nonMemb") in
    let: "dig" := (mem.alloc "dig") in
    let: "ver" := (mem.alloc "ver") in
    let: "uid" := (mem.alloc "uid") in
    let: "vrfPk" := (mem.alloc "vrfPk") in
    let: "label" := (mem.alloc (type.zero_val #sliceT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#ptrT] "vrfPk") in
    let: "$a1" := (![#uint64T] "uid") in
    let: "$a2" := (![#uint64T] "ver") in
    let: "$a3" := (![#sliceT] (struct.field_ref #ktcore.NonMemb #"LabelProof"%go (![#ptrT] "nonMemb"))) in
    (func_call #ktcore.CheckMapLabel) "$a0" "$a1" "$a2" "$a3") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("label" <-[#sliceT] "$r0");;;
    do:  ("err" <-[#boolT] "$r1");;;
    (if: ![#boolT] "err"
    then return: (![#boolT] "err")
    else do:  #());;;
    let: "dig0" := (mem.alloc (type.zero_val #sliceT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "label") in
    let: "$a1" := (![#sliceT] (struct.field_ref #ktcore.NonMemb #"MerkleProof"%go (![#ptrT] "nonMemb"))) in
    (func_call #merkle.VerifyNonMemb) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("dig0" <-[#sliceT] "$r0");;;
    do:  ("err" <-[#boolT] "$r1");;;
    (if: ![#boolT] "err"
    then return: (![#boolT] "err")
    else do:  #());;;
    (if: (~ (let: "$a0" := (![#sliceT] "dig") in
    let: "$a1" := (![#sliceT] "dig0") in
    (func_call #bytes.Equal) "$a0" "$a1"))
    then
      let: "$r0" := #true in
      do:  ("err" <-[#boolT] "$r0");;;
      return: (![#boolT] "err")
    else do:  #());;;
    return: (![#boolT] "err")).

(* go: evidence.go:31:19 *)
Definition evidVrf__Checkⁱᵐᵖˡ : val :=
  λ: "e" "pk",
    exception_do (let: "err" := (mem.alloc (type.zero_val #boolT)) in
    let: "e" := (mem.alloc "e") in
    let: "pk" := (mem.alloc "pk") in
    (if: let: "$a0" := (![#cryptoffi.SigPublicKey] "pk") in
    let: "$a1" := (![#sliceT] (struct.field_ref #evidVrf #"vrfPk0"%go (![#ptrT] "e"))) in
    let: "$a2" := (![#sliceT] (struct.field_ref #evidVrf #"sig0"%go (![#ptrT] "e"))) in
    (func_call #ktcore.VerifyVrfSig) "$a0" "$a1" "$a2"
    then return: (#true)
    else do:  #());;;
    (if: let: "$a0" := (![#cryptoffi.SigPublicKey] "pk") in
    let: "$a1" := (![#sliceT] (struct.field_ref #evidVrf #"vrfPk1"%go (![#ptrT] "e"))) in
    let: "$a2" := (![#sliceT] (struct.field_ref #evidVrf #"sig1"%go (![#ptrT] "e"))) in
    (func_call #ktcore.VerifyVrfSig) "$a0" "$a1" "$a2"
    then return: (#true)
    else do:  #());;;
    return: (let: "$a0" := (![#sliceT] (struct.field_ref #evidVrf #"vrfPk0"%go (![#ptrT] "e"))) in
     let: "$a1" := (![#sliceT] (struct.field_ref #evidVrf #"vrfPk1"%go (![#ptrT] "e"))) in
     (func_call #bytes.Equal) "$a0" "$a1")).

(* go: evidence.go:41:20 *)
Definition evidLink__Checkⁱᵐᵖˡ : val :=
  λ: "e" "pk",
    exception_do (let: "err" := (mem.alloc (type.zero_val #boolT)) in
    let: "e" := (mem.alloc "e") in
    let: "pk" := (mem.alloc "pk") in
    (if: let: "$a0" := (![#cryptoffi.SigPublicKey] "pk") in
    let: "$a1" := (![#uint64T] (struct.field_ref #evidLink #"epoch"%go (![#ptrT] "e"))) in
    let: "$a2" := (![#sliceT] (struct.field_ref #evidLink #"link0"%go (![#ptrT] "e"))) in
    let: "$a3" := (![#sliceT] (struct.field_ref #evidLink #"sig0"%go (![#ptrT] "e"))) in
    (func_call #ktcore.VerifyLinkSig) "$a0" "$a1" "$a2" "$a3"
    then return: (#true)
    else do:  #());;;
    (if: let: "$a0" := (![#cryptoffi.SigPublicKey] "pk") in
    let: "$a1" := (![#uint64T] (struct.field_ref #evidLink #"epoch"%go (![#ptrT] "e"))) in
    let: "$a2" := (![#sliceT] (struct.field_ref #evidLink #"link1"%go (![#ptrT] "e"))) in
    let: "$a3" := (![#sliceT] (struct.field_ref #evidLink #"sig1"%go (![#ptrT] "e"))) in
    (func_call #ktcore.VerifyLinkSig) "$a0" "$a1" "$a2" "$a3"
    then return: (#true)
    else do:  #());;;
    return: (let: "$a0" := (![#sliceT] (struct.field_ref #evidLink #"link0"%go (![#ptrT] "e"))) in
     let: "$a1" := (![#sliceT] (struct.field_ref #evidLink #"link1"%go (![#ptrT] "e"))) in
     (func_call #bytes.Equal) "$a0" "$a1")).

(* Check returns an error if the evidence does not check out.
   otherwise, it proves that the server was dishonest.

   go: evidence.go:53:16 *)
Definition Evid__Checkⁱᵐᵖˡ : val :=
  λ: "e" "pk",
    exception_do (let: "e" := (mem.alloc "e") in
    let: "pk" := (mem.alloc "pk") in
    (if: (![#ptrT] (struct.field_ref #Evid #"vrf"%go (![#ptrT] "e"))) ≠ #null
    then
      return: (let: "$a0" := (![#cryptoffi.SigPublicKey] "pk") in
       (method_call #(ptrT.id evidVrf.id) #"Check"%go (![#ptrT] (struct.field_ref #Evid #"vrf"%go (![#ptrT] "e")))) "$a0")
    else do:  #());;;
    (if: (![#ptrT] (struct.field_ref #Evid #"link"%go (![#ptrT] "e"))) ≠ #null
    then
      return: (let: "$a0" := (![#cryptoffi.SigPublicKey] "pk") in
       (method_call #(ptrT.id evidLink.id) #"Check"%go (![#ptrT] (struct.field_ref #Evid #"link"%go (![#ptrT] "e")))) "$a0")
    else do:  #());;;
    return: (#true)).

Definition vars' : list (go_string * go_type) := [].

Definition functions' : list (go_string * val) := [(New, Newⁱᵐᵖˡ); (CheckMemb, CheckMembⁱᵐᵖˡ); (CheckHist, CheckHistⁱᵐᵖˡ); (CheckNonMemb, CheckNonMembⁱᵐᵖˡ)].

Definition msets' : list (go_string * (list (go_string * val))) := [(Client.id, []); (ptrT.id Client.id, [("Audit"%go, Client__Auditⁱᵐᵖˡ); ("Get"%go, Client__Getⁱᵐᵖˡ); ("Put"%go, Client__Putⁱᵐᵖˡ); ("SelfMon"%go, Client__SelfMonⁱᵐᵖˡ); ("getChainExt"%go, Client__getChainExtⁱᵐᵖˡ)]); (pending.id, []); (ptrT.id pending.id, []); (epoch.id, []); (ptrT.id epoch.id, []); (serv.id, []); (ptrT.id serv.id, []); (Evid.id, []); (ptrT.id Evid.id, [("Check"%go, Evid__Checkⁱᵐᵖˡ)]); (evidVrf.id, []); (ptrT.id evidVrf.id, [("Check"%go, evidVrf__Checkⁱᵐᵖˡ)]); (evidLink.id, []); (ptrT.id evidLink.id, [("Check"%go, evidLink__Checkⁱᵐᵖˡ)])].

#[global] Instance info' : PkgInfo client.client :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [code.bytes.bytes; code.github_com.goose_lang.std.std; code.github_com.sanjit_bhat.pav.advrpc.advrpc; code.github_com.sanjit_bhat.pav.auditor.auditor; code.github_com.sanjit_bhat.pav.cryptoffi.cryptoffi; code.github_com.sanjit_bhat.pav.hashchain.hashchain; code.github_com.sanjit_bhat.pav.ktcore.ktcore; code.github_com.sanjit_bhat.pav.merkle.merkle; code.github_com.sanjit_bhat.pav.server.server];
  |}.

Definition initialize' : val :=
  λ: <>,
    package.init #client.client (λ: <>,
      exception_do (do:  (server.initialize' #());;;
      do:  (merkle.initialize' #());;;
      do:  (ktcore.initialize' #());;;
      do:  (hashchain.initialize' #());;;
      do:  (cryptoffi.initialize' #());;;
      do:  (auditor.initialize' #());;;
      do:  (advrpc.initialize' #());;;
      do:  (std.initialize' #());;;
      do:  (bytes.initialize' #());;;
      do:  (package.alloc client.client #()))
      ).

End code.
End client.
