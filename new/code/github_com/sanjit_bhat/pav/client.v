(* autogenerated from github.com/sanjit-bhat/pav/client *)
Require Export New.code.bytes.
Require Export New.code.github_com.goose_lang.std.
Require Export New.code.github_com.sanjit_bhat.pav.advrpc.
Require Export New.code.github_com.sanjit_bhat.pav.auditor.
Require Export New.code.github_com.sanjit_bhat.pav.cryptoffi.
Require Export New.code.github_com.sanjit_bhat.pav.hashchain.
Require Export New.code.github_com.sanjit_bhat.pav.ktcore.
Require Export New.code.github_com.sanjit_bhat.pav.merkle.
Require Export New.code.github_com.sanjit_bhat.pav.server.

From New.golang Require Import defn.
Definition client : go_string := "github.com/sanjit-bhat/pav/client".

Module client.

Section code.
Context `{ffi_syntax}.


Definition nextVer : go.type := go.Named "github.com/sanjit-bhat/pav/client.nextVer"%go [].

Definition epoch : go.type := go.Named "github.com/sanjit-bhat/pav/client.epoch"%go [].

Definition serv : go.type := go.Named "github.com/sanjit-bhat/pav/client.serv"%go [].

Definition Clientⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "uid"%go go.uint64);
  (go.FieldDecl "pend"%go (go.PointerType nextVer));
  (go.FieldDecl "last"%go (go.PointerType epoch));
  (go.FieldDecl "serv"%go (go.PointerType serv))
].

Definition nextVerⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "ver"%go go.uint64);
  (go.FieldDecl "isPending"%go go.bool);
  (go.FieldDecl "pendingPk"%go (go.SliceType go.byte))
].

Definition epochⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "epoch"%go go.uint64);
  (go.FieldDecl "dig"%go (go.SliceType go.byte));
  (go.FieldDecl "link"%go (go.SliceType go.byte));
  (go.FieldDecl "sig"%go (go.SliceType go.byte))
].

Definition servⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "cli"%go (go.PointerType advrpc.Client));
  (go.FieldDecl "sigPk"%go cryptoffi.SigPublicKey);
  (go.FieldDecl "vrfPk"%go (go.PointerType cryptoffi.VrfPublicKey));
  (go.FieldDecl "vrfSig"%go (go.SliceType go.byte))
].

Definition Client : go.type := go.Named "github.com/sanjit-bhat/pav/client.Client"%go [].

(* Put queues pk for insertion.
   if we have a pending Put, it requires the pk to be the same.

   go: client.go:45:18 *)
Definition Client__Putⁱᵐᵖˡ : val :=
  λ: "c" "pk",
    exception_do (let: "c" := (go.AllocValue (go.PointerType Client) "c") in
    let: "pk" := (go.AllocValue (go.SliceType go.byte) "pk") in
    (if: ![go.bool] (StructFieldRef nextVer "isPending"%go (![go.PointerType nextVer] (StructFieldRef Client "pend"%go (![go.PointerType Client] "c"))))
    then
      do:  (let: "$a0" := (let: "$a0" := (![go.SliceType go.byte] (StructFieldRef nextVer "pendingPk"%go (![go.PointerType nextVer] (StructFieldRef Client "pend"%go (![go.PointerType Client] "c"))))) in
      let: "$a1" := (![go.SliceType go.byte] "pk") in
      (FuncResolve bytes.Equal [] #()) "$a0" "$a1") in
      (FuncResolve std.Assert [] #()) "$a0")
    else
      let: "$r0" := #true in
      do:  ((StructFieldRef nextVer "isPending"%go (![go.PointerType nextVer] (StructFieldRef Client "pend"%go (![go.PointerType Client] "c")))) <-[go.bool] "$r0");;;
      let: "$r0" := (![go.SliceType go.byte] "pk") in
      do:  ((StructFieldRef nextVer "pendingPk"%go (![go.PointerType nextVer] (StructFieldRef Client "pend"%go (![go.PointerType Client] "c")))) <-[go.SliceType go.byte] "$r0"));;;
    do:  (let: "$a0" := (![go.PointerType advrpc.Client] (StructFieldRef serv "cli"%go (![go.PointerType serv] (StructFieldRef Client "serv"%go (![go.PointerType Client] "c"))))) in
    let: "$a1" := (![go.uint64] (StructFieldRef Client "uid"%go (![go.PointerType Client] "c"))) in
    let: "$a2" := (![go.SliceType go.byte] "pk") in
    let: "$a3" := (![go.uint64] (StructFieldRef nextVer "ver"%go (![go.PointerType nextVer] (StructFieldRef Client "pend"%go (![go.PointerType Client] "c"))))) in
    (FuncResolve server.CallPut [] #()) "$a0" "$a1" "$a2" "$a3");;;
    return: #()).

Definition checkNonMemb : go_string := "github.com/sanjit-bhat/pav/client.checkNonMemb"%go.

Definition checkHist : go_string := "github.com/sanjit-bhat/pav/client.checkHist"%go.

Definition getNextEp : go_string := "github.com/sanjit-bhat/pav/client.getNextEp"%go.

(* Get a uid's pk.

   go: client.go:56:18 *)
Definition Client__Getⁱᵐᵖˡ : val :=
  λ: "c" "uid",
    exception_do (let: "err" := (GoAlloc ktcore.Blame #()) in
    let: "pk" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "isReg" := (GoAlloc go.bool #()) in
    let: "ep" := (GoAlloc go.uint64 #()) in
    let: "c" := (go.AllocValue (go.PointerType Client) "c") in
    let: "uid" := (go.AllocValue go.uint64 "uid") in
    let: "bound" := (GoAlloc (go.PointerType ktcore.NonMemb) #()) in
    let: "hist" := (GoAlloc (go.SliceType (go.PointerType ktcore.Memb)) #()) in
    let: "sig" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "chainProof" := (GoAlloc (go.SliceType go.byte) #()) in
    let: (((("$ret0", "$ret1"), "$ret2"), "$ret3"), "$ret4") := (let: "$a0" := (![go.PointerType advrpc.Client] (StructFieldRef serv "cli"%go (![go.PointerType serv] (StructFieldRef Client "serv"%go (![go.PointerType Client] "c"))))) in
    let: "$a1" := (![go.uint64] "uid") in
    let: "$a2" := (![go.uint64] (StructFieldRef epoch "epoch"%go (![go.PointerType epoch] (StructFieldRef Client "last"%go (![go.PointerType Client] "c"))))) in
    let: "$a3" := #(W64 0) in
    (FuncResolve server.CallHistory [] #()) "$a0" "$a1" "$a2" "$a3") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    let: "$r3" := "$ret3" in
    let: "$r4" := "$ret4" in
    do:  ("chainProof" <-[go.SliceType go.byte] "$r0");;;
    do:  ("sig" <-[go.SliceType go.byte] "$r1");;;
    do:  ("hist" <-[go.SliceType (go.PointerType ktcore.Memb)] "$r2");;;
    do:  ("bound" <-[go.PointerType ktcore.NonMemb] "$r3");;;
    do:  ("err" <-[ktcore.Blame] "$r4");;;
    (if: (![ktcore.Blame] "err") ≠⟨go.uint64⟩ ktcore.BlameNone
    then return: (![go.uint64] "ep", ![go.bool] "isReg", ![go.SliceType go.byte] "pk", ![ktcore.Blame] "err")
    else do:  #());;;
    let: "errb" := (GoAlloc go.bool #()) in
    let: "next" := (GoAlloc (go.PointerType epoch) #()) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.PointerType epoch] (StructFieldRef Client "last"%go (![go.PointerType Client] "c"))) in
    let: "$a1" := (![cryptoffi.SigPublicKey] (StructFieldRef serv "sigPk"%go (![go.PointerType serv] (StructFieldRef Client "serv"%go (![go.PointerType Client] "c"))))) in
    let: "$a2" := (![go.SliceType go.byte] "chainProof") in
    let: "$a3" := (![go.SliceType go.byte] "sig") in
    (FuncResolve getNextEp [] #()) "$a0" "$a1" "$a2" "$a3") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("next" <-[go.PointerType epoch] "$r0");;;
    do:  ("errb" <-[go.bool] "$r1");;;
    (if: ![go.bool] "errb"
    then
      let: "$r0" := ktcore.BlameServFull in
      do:  ("err" <-[ktcore.Blame] "$r0");;;
      return: (![go.uint64] "ep", ![go.bool] "isReg", ![go.SliceType go.byte] "pk", ![ktcore.Blame] "err")
    else do:  #());;;
    (if: let: "$a0" := (![go.PointerType cryptoffi.VrfPublicKey] (StructFieldRef serv "vrfPk"%go (![go.PointerType serv] (StructFieldRef Client "serv"%go (![go.PointerType Client] "c"))))) in
    let: "$a1" := (![go.uint64] "uid") in
    let: "$a2" := #(W64 0) in
    let: "$a3" := (![go.SliceType go.byte] (StructFieldRef epoch "dig"%go (![go.PointerType epoch] "next"))) in
    let: "$a4" := (![go.SliceType (go.PointerType ktcore.Memb)] "hist") in
    (FuncResolve checkHist [] #()) "$a0" "$a1" "$a2" "$a3" "$a4"
    then
      let: "$r0" := ktcore.BlameServFull in
      do:  ("err" <-[ktcore.Blame] "$r0");;;
      return: (![go.uint64] "ep", ![go.bool] "isReg", ![go.SliceType go.byte] "pk", ![ktcore.Blame] "err")
    else do:  #());;;
    let: "boundVer" := (GoAlloc go.uint64 #()) in
    let: "$r0" := (s_to_w64 (let: "$a0" := (![go.SliceType (go.PointerType ktcore.Memb)] "hist") in
    (FuncResolve go.len [go.SliceType (go.PointerType ktcore.Memb)] #()) "$a0")) in
    do:  ("boundVer" <-[go.uint64] "$r0");;;
    (if: let: "$a0" := (![go.PointerType cryptoffi.VrfPublicKey] (StructFieldRef serv "vrfPk"%go (![go.PointerType serv] (StructFieldRef Client "serv"%go (![go.PointerType Client] "c"))))) in
    let: "$a1" := (![go.uint64] "uid") in
    let: "$a2" := (![go.uint64] "boundVer") in
    let: "$a3" := (![go.SliceType go.byte] (StructFieldRef epoch "dig"%go (![go.PointerType epoch] "next"))) in
    let: "$a4" := (![go.PointerType ktcore.NonMemb] "bound") in
    (FuncResolve checkNonMemb [] #()) "$a0" "$a1" "$a2" "$a3" "$a4"
    then
      let: "$r0" := ktcore.BlameServFull in
      do:  ("err" <-[ktcore.Blame] "$r0");;;
      return: (![go.uint64] "ep", ![go.bool] "isReg", ![go.SliceType go.byte] "pk", ![ktcore.Blame] "err")
    else do:  #());;;
    let: "$r0" := (![go.PointerType epoch] "next") in
    do:  ((StructFieldRef Client "last"%go (![go.PointerType Client] "c")) <-[go.PointerType epoch] "$r0");;;
    (if: (![go.uint64] "boundVer") =⟨go.uint64⟩ #(W64 0)
    then return: (![go.uint64] (StructFieldRef epoch "epoch"%go (![go.PointerType epoch] "next")), #false, #slice.nil, ktcore.BlameNone)
    else
      let: "lastKey" := (GoAlloc (go.PointerType ktcore.Memb) #()) in
      let: "$r0" := (![go.PointerType ktcore.Memb] (slice.elem_ref (go.PointerType ktcore.Memb) (![go.SliceType (go.PointerType ktcore.Memb)] "hist") ((![go.uint64] "boundVer") -⟨go.uint64⟩ #(W64 1)))) in
      do:  ("lastKey" <-[go.PointerType ktcore.Memb] "$r0");;;
      return: (![go.uint64] (StructFieldRef epoch "epoch"%go (![go.PointerType epoch] "next")), #true, ![go.SliceType go.byte] (StructFieldRef ktcore.CommitOpen "Val"%go (![go.PointerType ktcore.CommitOpen] (StructFieldRef ktcore.Memb "PkOpen"%go (![go.PointerType ktcore.Memb] "lastKey")))), ktcore.BlameNone))).

(* SelfMon a client's own uid.
   if isChanged, the key was added sometime from the last SelfMon.

   go: client.go:89:18 *)
Definition Client__SelfMonⁱᵐᵖˡ : val :=
  λ: "c" <>,
    exception_do (let: "err" := (GoAlloc ktcore.Blame #()) in
    let: "isChanged" := (GoAlloc go.bool #()) in
    let: "ep" := (GoAlloc go.uint64 #()) in
    let: "c" := (go.AllocValue (go.PointerType Client) "c") in
    let: "bound" := (GoAlloc (go.PointerType ktcore.NonMemb) #()) in
    let: "hist" := (GoAlloc (go.SliceType (go.PointerType ktcore.Memb)) #()) in
    let: "sig" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "chainProof" := (GoAlloc (go.SliceType go.byte) #()) in
    let: (((("$ret0", "$ret1"), "$ret2"), "$ret3"), "$ret4") := (let: "$a0" := (![go.PointerType advrpc.Client] (StructFieldRef serv "cli"%go (![go.PointerType serv] (StructFieldRef Client "serv"%go (![go.PointerType Client] "c"))))) in
    let: "$a1" := (![go.uint64] (StructFieldRef Client "uid"%go (![go.PointerType Client] "c"))) in
    let: "$a2" := (![go.uint64] (StructFieldRef epoch "epoch"%go (![go.PointerType epoch] (StructFieldRef Client "last"%go (![go.PointerType Client] "c"))))) in
    let: "$a3" := (![go.uint64] (StructFieldRef nextVer "ver"%go (![go.PointerType nextVer] (StructFieldRef Client "pend"%go (![go.PointerType Client] "c"))))) in
    (FuncResolve server.CallHistory [] #()) "$a0" "$a1" "$a2" "$a3") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    let: "$r3" := "$ret3" in
    let: "$r4" := "$ret4" in
    do:  ("chainProof" <-[go.SliceType go.byte] "$r0");;;
    do:  ("sig" <-[go.SliceType go.byte] "$r1");;;
    do:  ("hist" <-[go.SliceType (go.PointerType ktcore.Memb)] "$r2");;;
    do:  ("bound" <-[go.PointerType ktcore.NonMemb] "$r3");;;
    do:  ("err" <-[ktcore.Blame] "$r4");;;
    (if: (![ktcore.Blame] "err") ≠⟨go.uint64⟩ ktcore.BlameNone
    then return: (![go.uint64] "ep", ![go.bool] "isChanged", ![ktcore.Blame] "err")
    else do:  #());;;
    let: "errb" := (GoAlloc go.bool #()) in
    let: "next" := (GoAlloc (go.PointerType epoch) #()) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.PointerType epoch] (StructFieldRef Client "last"%go (![go.PointerType Client] "c"))) in
    let: "$a1" := (![cryptoffi.SigPublicKey] (StructFieldRef serv "sigPk"%go (![go.PointerType serv] (StructFieldRef Client "serv"%go (![go.PointerType Client] "c"))))) in
    let: "$a2" := (![go.SliceType go.byte] "chainProof") in
    let: "$a3" := (![go.SliceType go.byte] "sig") in
    (FuncResolve getNextEp [] #()) "$a0" "$a1" "$a2" "$a3") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("next" <-[go.PointerType epoch] "$r0");;;
    do:  ("errb" <-[go.bool] "$r1");;;
    (if: ![go.bool] "errb"
    then
      let: "$r0" := ktcore.BlameServFull in
      do:  ("err" <-[ktcore.Blame] "$r0");;;
      return: (![go.uint64] "ep", ![go.bool] "isChanged", ![ktcore.Blame] "err")
    else do:  #());;;
    let: "histLen" := (GoAlloc go.uint64 #()) in
    let: "$r0" := (s_to_w64 (let: "$a0" := (![go.SliceType (go.PointerType ktcore.Memb)] "hist") in
    (FuncResolve go.len [go.SliceType (go.PointerType ktcore.Memb)] #()) "$a0")) in
    do:  ("histLen" <-[go.uint64] "$r0");;;
    let: "boundVer" := (GoAlloc go.uint64 #()) in
    let: "$r0" := ((![go.uint64] (StructFieldRef nextVer "ver"%go (![go.PointerType nextVer] (StructFieldRef Client "pend"%go (![go.PointerType Client] "c"))))) +⟨go.uint64⟩ (![go.uint64] "histLen")) in
    do:  ("boundVer" <-[go.uint64] "$r0");;;
    (if: (~ (let: "$a0" := (![go.uint64] (StructFieldRef nextVer "ver"%go (![go.PointerType nextVer] (StructFieldRef Client "pend"%go (![go.PointerType Client] "c"))))) in
    let: "$a1" := (![go.uint64] "histLen") in
    (FuncResolve std.SumNoOverflow [] #()) "$a0" "$a1"))
    then
      let: "$r0" := ktcore.BlameServFull in
      do:  ("err" <-[ktcore.Blame] "$r0");;;
      return: (![go.uint64] "ep", ![go.bool] "isChanged", ![ktcore.Blame] "err")
    else do:  #());;;
    (if: let: "$a0" := (![go.PointerType cryptoffi.VrfPublicKey] (StructFieldRef serv "vrfPk"%go (![go.PointerType serv] (StructFieldRef Client "serv"%go (![go.PointerType Client] "c"))))) in
    let: "$a1" := (![go.uint64] (StructFieldRef Client "uid"%go (![go.PointerType Client] "c"))) in
    let: "$a2" := (![go.uint64] (StructFieldRef nextVer "ver"%go (![go.PointerType nextVer] (StructFieldRef Client "pend"%go (![go.PointerType Client] "c"))))) in
    let: "$a3" := (![go.SliceType go.byte] (StructFieldRef epoch "dig"%go (![go.PointerType epoch] "next"))) in
    let: "$a4" := (![go.SliceType (go.PointerType ktcore.Memb)] "hist") in
    (FuncResolve checkHist [] #()) "$a0" "$a1" "$a2" "$a3" "$a4"
    then
      let: "$r0" := ktcore.BlameServFull in
      do:  ("err" <-[ktcore.Blame] "$r0");;;
      return: (![go.uint64] "ep", ![go.bool] "isChanged", ![ktcore.Blame] "err")
    else do:  #());;;
    (if: let: "$a0" := (![go.PointerType cryptoffi.VrfPublicKey] (StructFieldRef serv "vrfPk"%go (![go.PointerType serv] (StructFieldRef Client "serv"%go (![go.PointerType Client] "c"))))) in
    let: "$a1" := (![go.uint64] (StructFieldRef Client "uid"%go (![go.PointerType Client] "c"))) in
    let: "$a2" := (![go.uint64] "boundVer") in
    let: "$a3" := (![go.SliceType go.byte] (StructFieldRef epoch "dig"%go (![go.PointerType epoch] "next"))) in
    let: "$a4" := (![go.PointerType ktcore.NonMemb] "bound") in
    (FuncResolve checkNonMemb [] #()) "$a0" "$a1" "$a2" "$a3" "$a4"
    then
      let: "$r0" := ktcore.BlameServFull in
      do:  ("err" <-[ktcore.Blame] "$r0");;;
      return: (![go.uint64] "ep", ![go.bool] "isChanged", ![ktcore.Blame] "err")
    else do:  #());;;
    (if: (~ (![go.bool] (StructFieldRef nextVer "isPending"%go (![go.PointerType nextVer] (StructFieldRef Client "pend"%go (![go.PointerType Client] "c"))))))
    then
      (if: (![go.uint64] "histLen") ≠⟨go.uint64⟩ #(W64 0)
      then
        let: "$r0" := (ktcore.BlameServFull `or` ktcore.BlameClients) in
        do:  ("err" <-[ktcore.Blame] "$r0");;;
        return: (![go.uint64] "ep", ![go.bool] "isChanged", ![ktcore.Blame] "err")
      else do:  #());;;
      let: "$r0" := (![go.PointerType epoch] "next") in
      do:  ((StructFieldRef Client "last"%go (![go.PointerType Client] "c")) <-[go.PointerType epoch] "$r0");;;
      return: (![go.uint64] (StructFieldRef epoch "epoch"%go (![go.PointerType epoch] "next")), #false, ktcore.BlameNone)
    else do:  #());;;
    (if: (![go.uint64] "histLen") >⟨go.uint64⟩ #(W64 1)
    then
      let: "$r0" := (ktcore.BlameServFull `or` ktcore.BlameClients) in
      do:  ("err" <-[ktcore.Blame] "$r0");;;
      return: (![go.uint64] "ep", ![go.bool] "isChanged", ![ktcore.Blame] "err")
    else do:  #());;;
    (if: (![go.uint64] "histLen") =⟨go.uint64⟩ #(W64 0)
    then
      let: "$r0" := (![go.PointerType epoch] "next") in
      do:  ((StructFieldRef Client "last"%go (![go.PointerType Client] "c")) <-[go.PointerType epoch] "$r0");;;
      return: (![go.uint64] (StructFieldRef epoch "epoch"%go (![go.PointerType epoch] "next")), #false, ktcore.BlameNone)
    else do:  #());;;
    let: "newKey" := (GoAlloc (go.PointerType ktcore.Memb) #()) in
    let: "$r0" := (![go.PointerType ktcore.Memb] (slice.elem_ref (go.PointerType ktcore.Memb) (![go.SliceType (go.PointerType ktcore.Memb)] "hist") #(W64 0))) in
    do:  ("newKey" <-[go.PointerType ktcore.Memb] "$r0");;;
    (if: (~ (let: "$a0" := (![go.SliceType go.byte] (StructFieldRef ktcore.CommitOpen "Val"%go (![go.PointerType ktcore.CommitOpen] (StructFieldRef ktcore.Memb "PkOpen"%go (![go.PointerType ktcore.Memb] "newKey"))))) in
    let: "$a1" := (![go.SliceType go.byte] (StructFieldRef nextVer "pendingPk"%go (![go.PointerType nextVer] (StructFieldRef Client "pend"%go (![go.PointerType Client] "c"))))) in
    (FuncResolve bytes.Equal [] #()) "$a0" "$a1"))
    then
      let: "$r0" := (ktcore.BlameServFull `or` ktcore.BlameClients) in
      do:  ("err" <-[ktcore.Blame] "$r0");;;
      return: (![go.uint64] "ep", ![go.bool] "isChanged", ![ktcore.Blame] "err")
    else do:  #());;;
    let: "$r0" := (![go.PointerType epoch] "next") in
    do:  ((StructFieldRef Client "last"%go (![go.PointerType Client] "c")) <-[go.PointerType epoch] "$r0");;;
    let: "$r0" := #false in
    do:  ((StructFieldRef nextVer "isPending"%go (![go.PointerType nextVer] (StructFieldRef Client "pend"%go (![go.PointerType Client] "c")))) <-[go.bool] "$r0");;;
    let: "$r0" := #slice.nil in
    do:  ((StructFieldRef nextVer "pendingPk"%go (![go.PointerType nextVer] (StructFieldRef Client "pend"%go (![go.PointerType Client] "c")))) <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (![go.uint64] "boundVer") in
    do:  ((StructFieldRef nextVer "ver"%go (![go.PointerType nextVer] (StructFieldRef Client "pend"%go (![go.PointerType Client] "c")))) <-[go.uint64] "$r0");;;
    return: (![go.uint64] (StructFieldRef epoch "epoch"%go (![go.PointerType epoch] "next")), #true, ktcore.BlameNone)).

Definition Evid : go.type := go.Named "github.com/sanjit-bhat/pav/client.Evid"%go [].

Definition evidVrf : go.type := go.Named "github.com/sanjit-bhat/pav/client.evidVrf"%go [].

Definition evidLink : go.type := go.Named "github.com/sanjit-bhat/pav/client.evidLink"%go [].

Definition checkAuditVrf : go_string := "github.com/sanjit-bhat/pav/client.checkAuditVrf"%go.

Definition checkAuditLink : go_string := "github.com/sanjit-bhat/pav/client.checkAuditLink"%go.

(* go: client.go:151:18 *)
Definition Client__Auditⁱᵐᵖˡ : val :=
  λ: "c" "adtrAddr" "adtrPk",
    exception_do (let: "err" := (GoAlloc ktcore.Blame #()) in
    let: "evid" := (GoAlloc (go.PointerType Evid) #()) in
    let: "c" := (go.AllocValue (go.PointerType Client) "c") in
    let: "adtrPk" := (go.AllocValue cryptoffi.SigPublicKey "adtrPk") in
    let: "adtrAddr" := (go.AllocValue go.uint64 "adtrAddr") in
    let: "cli" := (GoAlloc (go.PointerType advrpc.Client) #()) in
    let: "$r0" := (let: "$a0" := (![go.uint64] "adtrAddr") in
    (FuncResolve advrpc.Dial [] #()) "$a0") in
    do:  ("cli" <-[go.PointerType advrpc.Client] "$r0");;;
    let: "last" := (GoAlloc (go.PointerType epoch) #()) in
    let: "$r0" := (![go.PointerType epoch] (StructFieldRef Client "last"%go (![go.PointerType Client] "c"))) in
    do:  ("last" <-[go.PointerType epoch] "$r0");;;
    let: "vrf" := (GoAlloc (go.PointerType auditor.SignedVrf) #()) in
    let: "link" := (GoAlloc (go.PointerType auditor.SignedLink) #()) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.PointerType advrpc.Client] "cli") in
    let: "$a1" := (![go.uint64] (StructFieldRef epoch "epoch"%go (![go.PointerType epoch] "last"))) in
    (FuncResolve auditor.CallGet [] #()) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("link" <-[go.PointerType auditor.SignedLink] "$r0");;;
    do:  ("vrf" <-[go.PointerType auditor.SignedVrf] "$r1");;;
    do:  ("err" <-[ktcore.Blame] "$r2");;;
    (if: (![ktcore.Blame] "err") ≠⟨go.uint64⟩ ktcore.BlameNone
    then return: (![go.PointerType Evid] "evid", ![ktcore.Blame] "err")
    else do:  #());;;
    (if: let: "$a0" := (![cryptoffi.SigPublicKey] (StructFieldRef serv "sigPk"%go (![go.PointerType serv] (StructFieldRef Client "serv"%go (![go.PointerType Client] "c"))))) in
    let: "$a1" := (![cryptoffi.SigPublicKey] "adtrPk") in
    let: "$a2" := (![go.uint64] (StructFieldRef epoch "epoch"%go (![go.PointerType epoch] "last"))) in
    let: "$a3" := (![go.PointerType auditor.SignedLink] "link") in
    (FuncResolve checkAuditLink [] #()) "$a0" "$a1" "$a2" "$a3"
    then
      let: "$r0" := ktcore.BlameAdtrFull in
      do:  ("err" <-[ktcore.Blame] "$r0");;;
      return: (![go.PointerType Evid] "evid", ![ktcore.Blame] "err")
    else do:  #());;;
    (if: let: "$a0" := (![cryptoffi.SigPublicKey] (StructFieldRef serv "sigPk"%go (![go.PointerType serv] (StructFieldRef Client "serv"%go (![go.PointerType Client] "c"))))) in
    let: "$a1" := (![cryptoffi.SigPublicKey] "adtrPk") in
    let: "$a2" := (![go.PointerType auditor.SignedVrf] "vrf") in
    (FuncResolve checkAuditVrf [] #()) "$a0" "$a1" "$a2"
    then
      let: "$r0" := ktcore.BlameAdtrFull in
      do:  ("err" <-[ktcore.Blame] "$r0");;;
      return: (![go.PointerType Evid] "evid", ![ktcore.Blame] "err")
    else do:  #());;;
    let: "vrfPkB" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := (let: "$a0" := (![go.PointerType cryptoffi.VrfPublicKey] (StructFieldRef serv "vrfPk"%go (![go.PointerType serv] (StructFieldRef Client "serv"%go (![go.PointerType Client] "c"))))) in
    (FuncResolve cryptoffi.VrfPublicKeyEncode [] #()) "$a0") in
    do:  ("vrfPkB" <-[go.SliceType go.byte] "$r0");;;
    (if: (~ (let: "$a0" := (![go.SliceType go.byte] "vrfPkB") in
    let: "$a1" := (![go.SliceType go.byte] (StructFieldRef auditor.SignedVrf "VrfPk"%go (![go.PointerType auditor.SignedVrf] "vrf"))) in
    (FuncResolve bytes.Equal [] #()) "$a0" "$a1"))
    then
      let: "$r0" := (go.AllocValue Evid (let: "$vrf" := (go.AllocValue evidVrf (let: "$vrfPk0" := (![go.SliceType go.byte] "vrfPkB") in
      let: "$sig0" := (![go.SliceType go.byte] (StructFieldRef serv "vrfSig"%go (![go.PointerType serv] (StructFieldRef Client "serv"%go (![go.PointerType Client] "c"))))) in
      let: "$vrfPk1" := (![go.SliceType go.byte] (StructFieldRef auditor.SignedVrf "VrfPk"%go (![go.PointerType auditor.SignedVrf] "vrf"))) in
      let: "$sig1" := (![go.SliceType go.byte] (StructFieldRef auditor.SignedVrf "ServSig"%go (![go.PointerType auditor.SignedVrf] "vrf"))) in
      CompositeLiteral evidVrf (
        let: "$$vs" := go.StructElementListNil #() in 
        let: "$$vs" := go.ElementListApp "$$vs" "$vrfPk0" in
        let: "$$vs" := go.ElementListApp "$$vs" "$sig0" in
        let: "$$vs" := go.ElementListApp "$$vs" "$vrfPk1" in
        let: "$$vs" := go.ElementListApp "$$vs" "$sig1" in
        "$$vs"
      ))) in
      CompositeLiteral Evid (
        let: "$$vs" := go.StructElementListNil #() in 
        let: "$$vs" := go.ElementListApp "$$vs" "$vrf" in
        let: "$$vs" := go.ElementListApp "$$vs" (go.ZeroVal (go.PointerType evidLink) #()) in
        "$$vs"
      ))) in
      do:  ("evid" <-[go.PointerType Evid] "$r0");;;
      let: "$r0" := ktcore.BlameServSig in
      do:  ("err" <-[ktcore.Blame] "$r0");;;
      return: (![go.PointerType Evid] "evid", ![ktcore.Blame] "err")
    else do:  #());;;
    (if: (~ (let: "$a0" := (![go.SliceType go.byte] (StructFieldRef epoch "link"%go (![go.PointerType epoch] "last"))) in
    let: "$a1" := (![go.SliceType go.byte] (StructFieldRef auditor.SignedLink "Link"%go (![go.PointerType auditor.SignedLink] "link"))) in
    (FuncResolve bytes.Equal [] #()) "$a0" "$a1"))
    then
      let: "$r0" := (go.AllocValue Evid (let: "$link" := (go.AllocValue evidLink (let: "$epoch" := (![go.uint64] (StructFieldRef epoch "epoch"%go (![go.PointerType epoch] "last"))) in
      let: "$link0" := (![go.SliceType go.byte] (StructFieldRef epoch "link"%go (![go.PointerType epoch] "last"))) in
      let: "$sig0" := (![go.SliceType go.byte] (StructFieldRef epoch "sig"%go (![go.PointerType epoch] "last"))) in
      let: "$link1" := (![go.SliceType go.byte] (StructFieldRef auditor.SignedLink "Link"%go (![go.PointerType auditor.SignedLink] "link"))) in
      let: "$sig1" := (![go.SliceType go.byte] (StructFieldRef auditor.SignedLink "ServSig"%go (![go.PointerType auditor.SignedLink] "link"))) in
      CompositeLiteral evidLink (
        let: "$$vs" := go.StructElementListNil #() in 
        let: "$$vs" := go.ElementListApp "$$vs" "$epoch" in
        let: "$$vs" := go.ElementListApp "$$vs" "$link0" in
        let: "$$vs" := go.ElementListApp "$$vs" "$sig0" in
        let: "$$vs" := go.ElementListApp "$$vs" "$link1" in
        let: "$$vs" := go.ElementListApp "$$vs" "$sig1" in
        "$$vs"
      ))) in
      CompositeLiteral Evid (
        let: "$$vs" := go.StructElementListNil #() in 
        let: "$$vs" := go.ElementListApp "$$vs" (go.ZeroVal (go.PointerType evidVrf) #()) in
        let: "$$vs" := go.ElementListApp "$$vs" "$link" in
        "$$vs"
      ))) in
      do:  ("evid" <-[go.PointerType Evid] "$r0");;;
      let: "$r0" := ktcore.BlameServSig in
      do:  ("err" <-[ktcore.Blame] "$r0");;;
      return: (![go.PointerType Evid] "evid", ![ktcore.Blame] "err")
    else do:  #());;;
    return: (![go.PointerType Evid] "evid", ![ktcore.Blame] "err")).

Definition New : go_string := "github.com/sanjit-bhat/pav/client.New"%go.

(* go: client.go:185:6 *)
Definition Newⁱᵐᵖˡ : val :=
  λ: "uid" "servAddr" "servPk",
    exception_do (let: "err" := (GoAlloc ktcore.Blame #()) in
    let: "c" := (GoAlloc (go.PointerType Client) #()) in
    let: "servPk" := (go.AllocValue cryptoffi.SigPublicKey "servPk") in
    let: "servAddr" := (go.AllocValue go.uint64 "servAddr") in
    let: "uid" := (go.AllocValue go.uint64 "uid") in
    let: "cli" := (GoAlloc (go.PointerType advrpc.Client) #()) in
    let: "$r0" := (let: "$a0" := (![go.uint64] "servAddr") in
    (FuncResolve advrpc.Dial [] #()) "$a0") in
    do:  ("cli" <-[go.PointerType advrpc.Client] "$r0");;;
    let: "vrf" := (GoAlloc (go.PointerType server.StartVrf) #()) in
    let: "chain" := (GoAlloc (go.PointerType server.StartChain) #()) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.PointerType advrpc.Client] "cli") in
    (FuncResolve server.CallStart [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("chain" <-[go.PointerType server.StartChain] "$r0");;;
    do:  ("vrf" <-[go.PointerType server.StartVrf] "$r1");;;
    do:  ("err" <-[ktcore.Blame] "$r2");;;
    (if: (![ktcore.Blame] "err") ≠⟨go.uint64⟩ ktcore.BlameNone
    then return: (![go.PointerType Client] "c", ![ktcore.Blame] "err")
    else do:  #());;;
    let: "errb" := (GoAlloc go.bool #()) in
    let: "startLink" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "startDig" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "startEp" := (GoAlloc go.uint64 #()) in
    let: ((("$ret0", "$ret1"), "$ret2"), "$ret3") := (let: "$a0" := (![cryptoffi.SigPublicKey] "servPk") in
    let: "$a1" := (![go.PointerType server.StartChain] "chain") in
    (FuncResolve auditor.CheckStartChain [] #()) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    let: "$r3" := "$ret3" in
    do:  ("startEp" <-[go.uint64] "$r0");;;
    do:  ("startDig" <-[go.SliceType go.byte] "$r1");;;
    do:  ("startLink" <-[go.SliceType go.byte] "$r2");;;
    do:  ("errb" <-[go.bool] "$r3");;;
    (if: ![go.bool] "errb"
    then
      let: "$r0" := ktcore.BlameServFull in
      do:  ("err" <-[ktcore.Blame] "$r0");;;
      return: (![go.PointerType Client] "c", ![ktcore.Blame] "err")
    else do:  #());;;
    let: "vrfPk" := (GoAlloc (go.PointerType cryptoffi.VrfPublicKey) #()) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![cryptoffi.SigPublicKey] "servPk") in
    let: "$a1" := (![go.PointerType server.StartVrf] "vrf") in
    (FuncResolve auditor.CheckStartVrf [] #()) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("vrfPk" <-[go.PointerType cryptoffi.VrfPublicKey] "$r0");;;
    do:  ("errb" <-[go.bool] "$r1");;;
    (if: ![go.bool] "errb"
    then
      let: "$r0" := ktcore.BlameServFull in
      do:  ("err" <-[ktcore.Blame] "$r0");;;
      return: (![go.PointerType Client] "c", ![ktcore.Blame] "err")
    else do:  #());;;
    let: "pendingPut" := (GoAlloc (go.PointerType nextVer) #()) in
    let: "$r0" := (go.AllocValue nextVer (CompositeLiteral nextVer (
      let: "$$vs" := go.StructElementListNil #() in 
      let: "$$vs" := go.ElementListApp "$$vs" (go.ZeroVal go.uint64 #()) in
      let: "$$vs" := go.ElementListApp "$$vs" (go.ZeroVal go.bool #()) in
      let: "$$vs" := go.ElementListApp "$$vs" (go.ZeroVal (go.SliceType go.byte) #()) in
      "$$vs"
    ))) in
    do:  ("pendingPut" <-[go.PointerType nextVer] "$r0");;;
    let: "last" := (GoAlloc (go.PointerType epoch) #()) in
    let: "$r0" := (go.AllocValue epoch (let: "$epoch" := (![go.uint64] "startEp") in
    let: "$dig" := (![go.SliceType go.byte] "startDig") in
    let: "$link" := (![go.SliceType go.byte] "startLink") in
    let: "$sig" := (![go.SliceType go.byte] (StructFieldRef server.StartChain "LinkSig"%go (![go.PointerType server.StartChain] "chain"))) in
    CompositeLiteral epoch (
      let: "$$vs" := go.StructElementListNil #() in 
      let: "$$vs" := go.ElementListApp "$$vs" "$epoch" in
      let: "$$vs" := go.ElementListApp "$$vs" "$dig" in
      let: "$$vs" := go.ElementListApp "$$vs" "$link" in
      let: "$$vs" := go.ElementListApp "$$vs" "$sig" in
      "$$vs"
    ))) in
    do:  ("last" <-[go.PointerType epoch] "$r0");;;
    let: "serv" := (GoAlloc (go.PointerType serv) #()) in
    let: "$r0" := (go.AllocValue serv (let: "$cli" := (![go.PointerType advrpc.Client] "cli") in
    let: "$sigPk" := (![cryptoffi.SigPublicKey] "servPk") in
    let: "$vrfPk" := (![go.PointerType cryptoffi.VrfPublicKey] "vrfPk") in
    let: "$vrfSig" := (![go.SliceType go.byte] (StructFieldRef server.StartVrf "VrfSig"%go (![go.PointerType server.StartVrf] "vrf"))) in
    CompositeLiteral serv (
      let: "$$vs" := go.StructElementListNil #() in 
      let: "$$vs" := go.ElementListApp "$$vs" "$cli" in
      let: "$$vs" := go.ElementListApp "$$vs" "$sigPk" in
      let: "$$vs" := go.ElementListApp "$$vs" "$vrfPk" in
      let: "$$vs" := go.ElementListApp "$$vs" "$vrfSig" in
      "$$vs"
    ))) in
    do:  ("serv" <-[go.PointerType serv] "$r0");;;
    let: "$r0" := (go.AllocValue Client (let: "$uid" := (![go.uint64] "uid") in
    let: "$pend" := (![go.PointerType nextVer] "pendingPut") in
    let: "$last" := (![go.PointerType epoch] "last") in
    let: "$serv" := (![go.PointerType serv] "serv") in
    CompositeLiteral Client (
      let: "$$vs" := go.StructElementListNil #() in 
      let: "$$vs" := go.ElementListApp "$$vs" "$uid" in
      let: "$$vs" := go.ElementListApp "$$vs" "$pend" in
      let: "$$vs" := go.ElementListApp "$$vs" "$last" in
      let: "$$vs" := go.ElementListApp "$$vs" "$serv" in
      "$$vs"
    ))) in
    do:  ("c" <-[go.PointerType Client] "$r0");;;
    return: (![go.PointerType Client] "c", ![ktcore.Blame] "err")).

(* go: client.go:209:6 *)
Definition getNextEpⁱᵐᵖˡ : val :=
  λ: "prev" "sigPk" "chainProof" "sig",
    exception_do (let: "err" := (GoAlloc go.bool #()) in
    let: "next" := (GoAlloc (go.PointerType epoch) #()) in
    let: "sig" := (go.AllocValue (go.SliceType go.byte) "sig") in
    let: "chainProof" := (go.AllocValue (go.SliceType go.byte) "chainProof") in
    let: "sigPk" := (go.AllocValue cryptoffi.SigPublicKey "sigPk") in
    let: "prev" := (go.AllocValue (go.PointerType epoch) "prev") in
    let: "newLink" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "newDig" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "extLen" := (GoAlloc go.uint64 #()) in
    let: ((("$ret0", "$ret1"), "$ret2"), "$ret3") := (let: "$a0" := (![go.SliceType go.byte] (StructFieldRef epoch "link"%go (![go.PointerType epoch] "prev"))) in
    let: "$a1" := (![go.SliceType go.byte] "chainProof") in
    (FuncResolve hashchain.Verify [] #()) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    let: "$r3" := "$ret3" in
    do:  ("extLen" <-[go.uint64] "$r0");;;
    do:  ("newDig" <-[go.SliceType go.byte] "$r1");;;
    do:  ("newLink" <-[go.SliceType go.byte] "$r2");;;
    do:  ("err" <-[go.bool] "$r3");;;
    (if: ![go.bool] "err"
    then return: (![go.PointerType epoch] "next", ![go.bool] "err")
    else do:  #());;;
    (if: (![go.uint64] "extLen") =⟨go.uint64⟩ #(W64 0)
    then
      let: "$r0" := (![go.PointerType epoch] "prev") in
      do:  ("next" <-[go.PointerType epoch] "$r0");;;
      return: (![go.PointerType epoch] "next", ![go.bool] "err")
    else do:  #());;;
    let: "newEp" := (GoAlloc go.uint64 #()) in
    let: "$r0" := ((![go.uint64] (StructFieldRef epoch "epoch"%go (![go.PointerType epoch] "prev"))) +⟨go.uint64⟩ (![go.uint64] "extLen")) in
    do:  ("newEp" <-[go.uint64] "$r0");;;
    (if: (~ (let: "$a0" := (![go.uint64] (StructFieldRef epoch "epoch"%go (![go.PointerType epoch] "prev"))) in
    let: "$a1" := (![go.uint64] "extLen") in
    (FuncResolve std.SumNoOverflow [] #()) "$a0" "$a1"))
    then
      let: "$r0" := #true in
      do:  ("err" <-[go.bool] "$r0");;;
      return: (![go.PointerType epoch] "next", ![go.bool] "err")
    else do:  #());;;
    (if: let: "$a0" := (![cryptoffi.SigPublicKey] "sigPk") in
    let: "$a1" := (![go.uint64] "newEp") in
    let: "$a2" := (![go.SliceType go.byte] "newLink") in
    let: "$a3" := (![go.SliceType go.byte] "sig") in
    (FuncResolve ktcore.VerifyLinkSig [] #()) "$a0" "$a1" "$a2" "$a3"
    then
      let: "$r0" := #true in
      do:  ("err" <-[go.bool] "$r0");;;
      return: (![go.PointerType epoch] "next", ![go.bool] "err")
    else do:  #());;;
    let: "$r0" := (go.AllocValue epoch (let: "$epoch" := (![go.uint64] "newEp") in
    let: "$dig" := (![go.SliceType go.byte] "newDig") in
    let: "$link" := (![go.SliceType go.byte] "newLink") in
    let: "$sig" := (![go.SliceType go.byte] "sig") in
    CompositeLiteral epoch (
      let: "$$vs" := go.StructElementListNil #() in 
      let: "$$vs" := go.ElementListApp "$$vs" "$epoch" in
      let: "$$vs" := go.ElementListApp "$$vs" "$dig" in
      let: "$$vs" := go.ElementListApp "$$vs" "$link" in
      let: "$$vs" := go.ElementListApp "$$vs" "$sig" in
      "$$vs"
    ))) in
    do:  ("next" <-[go.PointerType epoch] "$r0");;;
    return: (![go.PointerType epoch] "next", ![go.bool] "err")).

Definition checkMemb : go_string := "github.com/sanjit-bhat/pav/client.checkMemb"%go.

(* go: client.go:231:6 *)
Definition checkMembⁱᵐᵖˡ : val :=
  λ: "vrfPk" "uid" "ver" "dig" "memb",
    exception_do (let: "err" := (GoAlloc go.bool #()) in
    let: "memb" := (go.AllocValue (go.PointerType ktcore.Memb) "memb") in
    let: "dig" := (go.AllocValue (go.SliceType go.byte) "dig") in
    let: "ver" := (go.AllocValue go.uint64 "ver") in
    let: "uid" := (go.AllocValue go.uint64 "uid") in
    let: "vrfPk" := (go.AllocValue (go.PointerType cryptoffi.VrfPublicKey) "vrfPk") in
    let: "label" := (GoAlloc (go.SliceType go.byte) #()) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.PointerType cryptoffi.VrfPublicKey] "vrfPk") in
    let: "$a1" := (![go.uint64] "uid") in
    let: "$a2" := (![go.uint64] "ver") in
    let: "$a3" := (![go.SliceType go.byte] (StructFieldRef ktcore.Memb "LabelProof"%go (![go.PointerType ktcore.Memb] "memb"))) in
    (FuncResolve ktcore.CheckMapLabel [] #()) "$a0" "$a1" "$a2" "$a3") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("label" <-[go.SliceType go.byte] "$r0");;;
    do:  ("err" <-[go.bool] "$r1");;;
    (if: ![go.bool] "err"
    then return: (![go.bool] "err")
    else do:  #());;;
    let: "mapVal" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := (let: "$a0" := (![go.PointerType ktcore.CommitOpen] (StructFieldRef ktcore.Memb "PkOpen"%go (![go.PointerType ktcore.Memb] "memb"))) in
    (FuncResolve ktcore.GetMapVal [] #()) "$a0") in
    do:  ("mapVal" <-[go.SliceType go.byte] "$r0");;;
    let: "dig0" := (GoAlloc (go.SliceType go.byte) #()) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] "label") in
    let: "$a1" := (![go.SliceType go.byte] "mapVal") in
    let: "$a2" := (![go.SliceType go.byte] (StructFieldRef ktcore.Memb "MerkleProof"%go (![go.PointerType ktcore.Memb] "memb"))) in
    (FuncResolve merkle.VerifyMemb [] #()) "$a0" "$a1" "$a2") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("dig0" <-[go.SliceType go.byte] "$r0");;;
    do:  ("err" <-[go.bool] "$r1");;;
    (if: ![go.bool] "err"
    then return: (![go.bool] "err")
    else do:  #());;;
    (if: (~ (let: "$a0" := (![go.SliceType go.byte] "dig") in
    let: "$a1" := (![go.SliceType go.byte] "dig0") in
    (FuncResolve bytes.Equal [] #()) "$a0" "$a1"))
    then
      let: "$r0" := #true in
      do:  ("err" <-[go.bool] "$r0");;;
      return: (![go.bool] "err")
    else do:  #());;;
    return: (![go.bool] "err")).

(* go: client.go:248:6 *)
Definition checkHistⁱᵐᵖˡ : val :=
  λ: "vrfPk" "uid" "prefixLen" "dig" "hist",
    exception_do (let: "err" := (GoAlloc go.bool #()) in
    let: "hist" := (go.AllocValue (go.SliceType (go.PointerType ktcore.Memb)) "hist") in
    let: "dig" := (go.AllocValue (go.SliceType go.byte) "dig") in
    let: "prefixLen" := (go.AllocValue go.uint64 "prefixLen") in
    let: "uid" := (go.AllocValue go.uint64 "uid") in
    let: "vrfPk" := (go.AllocValue (go.PointerType cryptoffi.VrfPublicKey) "vrfPk") in
    let: "$range" := (![go.SliceType (go.PointerType ktcore.Memb)] "hist") in
    (let: "memb" := (GoAlloc (go.PointerType ktcore.Memb) #()) in
    let: "ver" := (GoAlloc go.int #()) in
    slice.for_range (go.PointerType ktcore.Memb) "$range" (λ: "$key" "$value",
      do:  ("memb" <-[go.PointerType ktcore.Memb] "$value");;;
      do:  ("ver" <-[go.int] "$key");;;
      (let: "$r0" := (let: "$a0" := (![go.PointerType cryptoffi.VrfPublicKey] "vrfPk") in
      let: "$a1" := (![go.uint64] "uid") in
      let: "$a2" := ((![go.uint64] "prefixLen") +⟨go.uint64⟩ (s_to_w64 (![go.int] "ver"))) in
      let: "$a3" := (![go.SliceType go.byte] "dig") in
      let: "$a4" := (![go.PointerType ktcore.Memb] "memb") in
      (FuncResolve checkMemb [] #()) "$a0" "$a1" "$a2" "$a3" "$a4") in
      do:  ("err" <-[go.bool] "$r0");;;
      (if: ![go.bool] "err"
      then return: (![go.bool] "err")
      else do:  #()))));;;
    return: (![go.bool] "err")).

(* go: client.go:257:6 *)
Definition checkNonMembⁱᵐᵖˡ : val :=
  λ: "vrfPk" "uid" "ver" "dig" "nonMemb",
    exception_do (let: "err" := (GoAlloc go.bool #()) in
    let: "nonMemb" := (go.AllocValue (go.PointerType ktcore.NonMemb) "nonMemb") in
    let: "dig" := (go.AllocValue (go.SliceType go.byte) "dig") in
    let: "ver" := (go.AllocValue go.uint64 "ver") in
    let: "uid" := (go.AllocValue go.uint64 "uid") in
    let: "vrfPk" := (go.AllocValue (go.PointerType cryptoffi.VrfPublicKey) "vrfPk") in
    let: "label" := (GoAlloc (go.SliceType go.byte) #()) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.PointerType cryptoffi.VrfPublicKey] "vrfPk") in
    let: "$a1" := (![go.uint64] "uid") in
    let: "$a2" := (![go.uint64] "ver") in
    let: "$a3" := (![go.SliceType go.byte] (StructFieldRef ktcore.NonMemb "LabelProof"%go (![go.PointerType ktcore.NonMemb] "nonMemb"))) in
    (FuncResolve ktcore.CheckMapLabel [] #()) "$a0" "$a1" "$a2" "$a3") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("label" <-[go.SliceType go.byte] "$r0");;;
    do:  ("err" <-[go.bool] "$r1");;;
    (if: ![go.bool] "err"
    then return: (![go.bool] "err")
    else do:  #());;;
    let: "dig0" := (GoAlloc (go.SliceType go.byte) #()) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] "label") in
    let: "$a1" := (![go.SliceType go.byte] (StructFieldRef ktcore.NonMemb "MerkleProof"%go (![go.PointerType ktcore.NonMemb] "nonMemb"))) in
    (FuncResolve merkle.VerifyNonMemb [] #()) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("dig0" <-[go.SliceType go.byte] "$r0");;;
    do:  ("err" <-[go.bool] "$r1");;;
    (if: ![go.bool] "err"
    then return: (![go.bool] "err")
    else do:  #());;;
    (if: (~ (let: "$a0" := (![go.SliceType go.byte] "dig") in
    let: "$a1" := (![go.SliceType go.byte] "dig0") in
    (FuncResolve bytes.Equal [] #()) "$a0" "$a1"))
    then
      let: "$r0" := #true in
      do:  ("err" <-[go.bool] "$r0");;;
      return: (![go.bool] "err")
    else do:  #());;;
    return: (![go.bool] "err")).

(* go: client.go:273:6 *)
Definition checkAuditLinkⁱᵐᵖˡ : val :=
  λ: "servPk" "adtrPk" "ep" "link",
    exception_do (let: "err" := (GoAlloc go.bool #()) in
    let: "link" := (go.AllocValue (go.PointerType auditor.SignedLink) "link") in
    let: "ep" := (go.AllocValue go.uint64 "ep") in
    let: "adtrPk" := (go.AllocValue cryptoffi.SigPublicKey "adtrPk") in
    let: "servPk" := (go.AllocValue cryptoffi.SigPublicKey "servPk") in
    (if: let: "$a0" := (![cryptoffi.SigPublicKey] "adtrPk") in
    let: "$a1" := (![go.uint64] "ep") in
    let: "$a2" := (![go.SliceType go.byte] (StructFieldRef auditor.SignedLink "Link"%go (![go.PointerType auditor.SignedLink] "link"))) in
    let: "$a3" := (![go.SliceType go.byte] (StructFieldRef auditor.SignedLink "AdtrSig"%go (![go.PointerType auditor.SignedLink] "link"))) in
    (FuncResolve ktcore.VerifyLinkSig [] #()) "$a0" "$a1" "$a2" "$a3"
    then return: (#true)
    else do:  #());;;
    (if: let: "$a0" := (![cryptoffi.SigPublicKey] "servPk") in
    let: "$a1" := (![go.uint64] "ep") in
    let: "$a2" := (![go.SliceType go.byte] (StructFieldRef auditor.SignedLink "Link"%go (![go.PointerType auditor.SignedLink] "link"))) in
    let: "$a3" := (![go.SliceType go.byte] (StructFieldRef auditor.SignedLink "ServSig"%go (![go.PointerType auditor.SignedLink] "link"))) in
    (FuncResolve ktcore.VerifyLinkSig [] #()) "$a0" "$a1" "$a2" "$a3"
    then return: (#true)
    else do:  #());;;
    return: (![go.bool] "err")).

(* go: client.go:283:6 *)
Definition checkAuditVrfⁱᵐᵖˡ : val :=
  λ: "servPk" "adtrPk" "vrf",
    exception_do (let: "err" := (GoAlloc go.bool #()) in
    let: "vrf" := (go.AllocValue (go.PointerType auditor.SignedVrf) "vrf") in
    let: "adtrPk" := (go.AllocValue cryptoffi.SigPublicKey "adtrPk") in
    let: "servPk" := (go.AllocValue cryptoffi.SigPublicKey "servPk") in
    (if: let: "$a0" := (![cryptoffi.SigPublicKey] "adtrPk") in
    let: "$a1" := (![go.SliceType go.byte] (StructFieldRef auditor.SignedVrf "VrfPk"%go (![go.PointerType auditor.SignedVrf] "vrf"))) in
    let: "$a2" := (![go.SliceType go.byte] (StructFieldRef auditor.SignedVrf "AdtrSig"%go (![go.PointerType auditor.SignedVrf] "vrf"))) in
    (FuncResolve ktcore.VerifyVrfSig [] #()) "$a0" "$a1" "$a2"
    then return: (#true)
    else do:  #());;;
    (if: let: "$a0" := (![cryptoffi.SigPublicKey] "servPk") in
    let: "$a1" := (![go.SliceType go.byte] (StructFieldRef auditor.SignedVrf "VrfPk"%go (![go.PointerType auditor.SignedVrf] "vrf"))) in
    let: "$a2" := (![go.SliceType go.byte] (StructFieldRef auditor.SignedVrf "ServSig"%go (![go.PointerType auditor.SignedVrf] "vrf"))) in
    (FuncResolve ktcore.VerifyVrfSig [] #()) "$a0" "$a1" "$a2"
    then return: (#true)
    else do:  #());;;
    return: (![go.bool] "err")).

Definition Evidⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "vrf"%go (go.PointerType evidVrf));
  (go.FieldDecl "link"%go (go.PointerType evidLink))
].

Definition evidVrfⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "vrfPk0"%go (go.SliceType go.byte));
  (go.FieldDecl "sig0"%go (go.SliceType go.byte));
  (go.FieldDecl "vrfPk1"%go (go.SliceType go.byte));
  (go.FieldDecl "sig1"%go (go.SliceType go.byte))
].

Definition evidLinkⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "epoch"%go go.uint64);
  (go.FieldDecl "link0"%go (go.SliceType go.byte));
  (go.FieldDecl "sig0"%go (go.SliceType go.byte));
  (go.FieldDecl "link1"%go (go.SliceType go.byte));
  (go.FieldDecl "sig1"%go (go.SliceType go.byte))
].

(* go: evidence.go:32:19 *)
Definition evidVrf__checkⁱᵐᵖˡ : val :=
  λ: "e" "pk",
    exception_do (let: "err" := (GoAlloc go.bool #()) in
    let: "e" := (go.AllocValue (go.PointerType evidVrf) "e") in
    let: "pk" := (go.AllocValue cryptoffi.SigPublicKey "pk") in
    (if: let: "$a0" := (![cryptoffi.SigPublicKey] "pk") in
    let: "$a1" := (![go.SliceType go.byte] (StructFieldRef evidVrf "vrfPk0"%go (![go.PointerType evidVrf] "e"))) in
    let: "$a2" := (![go.SliceType go.byte] (StructFieldRef evidVrf "sig0"%go (![go.PointerType evidVrf] "e"))) in
    (FuncResolve ktcore.VerifyVrfSig [] #()) "$a0" "$a1" "$a2"
    then return: (#true)
    else do:  #());;;
    (if: let: "$a0" := (![cryptoffi.SigPublicKey] "pk") in
    let: "$a1" := (![go.SliceType go.byte] (StructFieldRef evidVrf "vrfPk1"%go (![go.PointerType evidVrf] "e"))) in
    let: "$a2" := (![go.SliceType go.byte] (StructFieldRef evidVrf "sig1"%go (![go.PointerType evidVrf] "e"))) in
    (FuncResolve ktcore.VerifyVrfSig [] #()) "$a0" "$a1" "$a2"
    then return: (#true)
    else do:  #());;;
    return: (let: "$a0" := (![go.SliceType go.byte] (StructFieldRef evidVrf "vrfPk0"%go (![go.PointerType evidVrf] "e"))) in
     let: "$a1" := (![go.SliceType go.byte] (StructFieldRef evidVrf "vrfPk1"%go (![go.PointerType evidVrf] "e"))) in
     (FuncResolve bytes.Equal [] #()) "$a0" "$a1")).

(* go: evidence.go:42:20 *)
Definition evidLink__checkⁱᵐᵖˡ : val :=
  λ: "e" "pk",
    exception_do (let: "err" := (GoAlloc go.bool #()) in
    let: "e" := (go.AllocValue (go.PointerType evidLink) "e") in
    let: "pk" := (go.AllocValue cryptoffi.SigPublicKey "pk") in
    (if: let: "$a0" := (![cryptoffi.SigPublicKey] "pk") in
    let: "$a1" := (![go.uint64] (StructFieldRef evidLink "epoch"%go (![go.PointerType evidLink] "e"))) in
    let: "$a2" := (![go.SliceType go.byte] (StructFieldRef evidLink "link0"%go (![go.PointerType evidLink] "e"))) in
    let: "$a3" := (![go.SliceType go.byte] (StructFieldRef evidLink "sig0"%go (![go.PointerType evidLink] "e"))) in
    (FuncResolve ktcore.VerifyLinkSig [] #()) "$a0" "$a1" "$a2" "$a3"
    then return: (#true)
    else do:  #());;;
    (if: let: "$a0" := (![cryptoffi.SigPublicKey] "pk") in
    let: "$a1" := (![go.uint64] (StructFieldRef evidLink "epoch"%go (![go.PointerType evidLink] "e"))) in
    let: "$a2" := (![go.SliceType go.byte] (StructFieldRef evidLink "link1"%go (![go.PointerType evidLink] "e"))) in
    let: "$a3" := (![go.SliceType go.byte] (StructFieldRef evidLink "sig1"%go (![go.PointerType evidLink] "e"))) in
    (FuncResolve ktcore.VerifyLinkSig [] #()) "$a0" "$a1" "$a2" "$a3"
    then return: (#true)
    else do:  #());;;
    return: (let: "$a0" := (![go.SliceType go.byte] (StructFieldRef evidLink "link0"%go (![go.PointerType evidLink] "e"))) in
     let: "$a1" := (![go.SliceType go.byte] (StructFieldRef evidLink "link1"%go (![go.PointerType evidLink] "e"))) in
     (FuncResolve bytes.Equal [] #()) "$a0" "$a1")).

(* Check returns an error if the evidence does not check out.
   otherwise, it proves that the server was dishonest.

   go: evidence.go:54:16 *)
Definition Evid__Checkⁱᵐᵖˡ : val :=
  λ: "e" "pk",
    exception_do (let: "e" := (go.AllocValue (go.PointerType Evid) "e") in
    let: "pk" := (go.AllocValue cryptoffi.SigPublicKey "pk") in
    (if: (![go.PointerType evidVrf] (StructFieldRef Evid "vrf"%go (![go.PointerType Evid] "e"))) ≠⟨go.PointerType evidVrf⟩ #null
    then
      (if: (![go.PointerType evidLink] (StructFieldRef Evid "link"%go (![go.PointerType Evid] "e"))) ≠⟨go.PointerType evidLink⟩ #null
      then return: (#true)
      else do:  #());;;
      return: (let: "$a0" := (![cryptoffi.SigPublicKey] "pk") in
       (MethodResolve (go.PointerType evidVrf) check #() (![go.PointerType evidVrf] (StructFieldRef Evid "vrf"%go (![go.PointerType Evid] "e")))) "$a0")
    else
      (if: (![go.PointerType evidLink] (StructFieldRef Evid "link"%go (![go.PointerType Evid] "e"))) =⟨go.PointerType evidLink⟩ #null
      then return: (#true)
      else do:  #());;;
      return: (let: "$a0" := (![cryptoffi.SigPublicKey] "pk") in
       (MethodResolve (go.PointerType evidLink) check #() (![go.PointerType evidLink] (StructFieldRef Evid "link"%go (![go.PointerType Evid] "e")))) "$a0"))).

Definition functions' : list (go_string * val) := [(New, Newⁱᵐᵖˡ); (getNextEp, getNextEpⁱᵐᵖˡ); (checkMemb, checkMembⁱᵐᵖˡ); (checkHist, checkHistⁱᵐᵖˡ); (checkNonMemb, checkNonMembⁱᵐᵖˡ); (checkAuditLink, checkAuditLinkⁱᵐᵖˡ); (checkAuditVrf, checkAuditVrfⁱᵐᵖˡ)].

#[global] Instance info' : PkgInfo client.client :=
  {|
    pkg_imported_pkgs := [code.bytes.bytes; code.github_com.goose_lang.std.std; code.github_com.sanjit_bhat.pav.advrpc.advrpc; code.github_com.sanjit_bhat.pav.auditor.auditor; code.github_com.sanjit_bhat.pav.cryptoffi.cryptoffi; code.github_com.sanjit_bhat.pav.hashchain.hashchain; code.github_com.sanjit_bhat.pav.ktcore.ktcore; code.github_com.sanjit_bhat.pav.merkle.merkle; code.github_com.sanjit_bhat.pav.server.server];
  |}.

Definition initialize' : val :=
  λ: <>,
    package.init client.client (λ: <>,
      exception_do (do:  (server.initialize' #());;;
      do:  (merkle.initialize' #());;;
      do:  (ktcore.initialize' #());;;
      do:  (hashchain.initialize' #());;;
      do:  (cryptoffi.initialize' #());;;
      do:  (auditor.initialize' #());;;
      do:  (advrpc.initialize' #());;;
      do:  (std.initialize' #());;;
      do:  (bytes.initialize' #()))
      ).

End code.
End client.
