(* autogenerated from github.com/sanjit-bhat/pav/client *)
Require Export New.code.bytes.
Require Export New.code.github_com.goose_lang.std.
Require Export New.code.github_com.sanjit_bhat.pav.advrpc.
Require Export New.code.github_com.sanjit_bhat.pav.auditor.
Require Export New.code.github_com.sanjit_bhat.pav.cryptoffi.
Require Export New.code.github_com.sanjit_bhat.pav.hashchain.
Require Export New.code.github_com.sanjit_bhat.pav.ktcore.
Require Export New.code.github_com.sanjit_bhat.pav.merkle.
Require Export New.code.github_com.sanjit_bhat.pav.server.

From New.golang Require Import defn.
Definition client : go_string := "github.com/sanjit-bhat/pav/client".

Module client.

Module Client. Definition id : go_string := "github.com/sanjit-bhat/pav/client.Client"%go. End Client.
Module nextVer. Definition id : go_string := "github.com/sanjit-bhat/pav/client.nextVer"%go. End nextVer.
Module epoch. Definition id : go_string := "github.com/sanjit-bhat/pav/client.epoch"%go. End epoch.
Module serv. Definition id : go_string := "github.com/sanjit-bhat/pav/client.serv"%go. End serv.
Module Evid. Definition id : go_string := "github.com/sanjit-bhat/pav/client.Evid"%go. End Evid.
Module evidVrf. Definition id : go_string := "github.com/sanjit-bhat/pav/client.evidVrf"%go. End evidVrf.
Module evidLink. Definition id : go_string := "github.com/sanjit-bhat/pav/client.evidLink"%go. End evidLink.

Section code.
Context `{ffi_syntax}.


Definition Client : go_type := structT [
  "uid" :: uint64T;
  "pend" :: ptrT;
  "last" :: ptrT;
  "serv" :: ptrT
].
#[global] Typeclasses Opaque Client.
#[global] Opaque Client.

Definition nextVer : go_type := structT [
  "ver" :: uint64T;
  "isPending" :: boolT;
  "pendingPk" :: sliceT
].
#[global] Typeclasses Opaque nextVer.
#[global] Opaque nextVer.

Definition epoch : go_type := structT [
  "epoch" :: uint64T;
  "dig" :: sliceT;
  "link" :: sliceT;
  "sig" :: sliceT
].
#[global] Typeclasses Opaque epoch.
#[global] Opaque epoch.

Definition serv : go_type := structT [
  "cli" :: ptrT;
  "sigPk" :: cryptoffi.SigPublicKey;
  "vrfPk" :: ptrT;
  "vrfSig" :: sliceT
].
#[global] Typeclasses Opaque serv.
#[global] Opaque serv.

(* Put queues pk for insertion.
   if we have a pending Put, it requires the pk to be the same.

   go: client.go:45:18 *)
Definition Client__Putⁱᵐᵖˡ : val :=
  λ: "c" "pk",
    exception_do (let: "c" := (mem.alloc "c") in
    let: "pk" := (mem.alloc "pk") in
    (if: ![#boolT] (struct.field_ref #nextVer #"isPending"%go (![#ptrT] (struct.field_ref #Client #"pend"%go (![#ptrT] "c"))))
    then
      do:  (let: "$a0" := (let: "$a0" := (![#sliceT] (struct.field_ref #nextVer #"pendingPk"%go (![#ptrT] (struct.field_ref #Client #"pend"%go (![#ptrT] "c"))))) in
      let: "$a1" := (![#sliceT] "pk") in
      (func_call #bytes.Equal) "$a0" "$a1") in
      (func_call #std.Assert) "$a0")
    else
      let: "$r0" := #true in
      do:  ((struct.field_ref #nextVer #"isPending"%go (![#ptrT] (struct.field_ref #Client #"pend"%go (![#ptrT] "c")))) <-[#boolT] "$r0");;;
      let: "$r0" := (![#sliceT] "pk") in
      do:  ((struct.field_ref #nextVer #"pendingPk"%go (![#ptrT] (struct.field_ref #Client #"pend"%go (![#ptrT] "c")))) <-[#sliceT] "$r0"));;;
    do:  (let: "$a0" := (![#ptrT] (struct.field_ref #serv #"cli"%go (![#ptrT] (struct.field_ref #Client #"serv"%go (![#ptrT] "c"))))) in
    let: "$a1" := (![#uint64T] (struct.field_ref #Client #"uid"%go (![#ptrT] "c"))) in
    let: "$a2" := (![#sliceT] "pk") in
    let: "$a3" := (![#uint64T] (struct.field_ref #nextVer #"ver"%go (![#ptrT] (struct.field_ref #Client #"pend"%go (![#ptrT] "c"))))) in
    (func_call #server.CallPut) "$a0" "$a1" "$a2" "$a3");;;
    return: #()).

Definition checkNonMemb : go_string := "github.com/sanjit-bhat/pav/client.checkNonMemb"%go.

Definition checkHist : go_string := "github.com/sanjit-bhat/pav/client.checkHist"%go.

Definition getNextEp : go_string := "github.com/sanjit-bhat/pav/client.getNextEp"%go.

(* Get a uid's pk.

   go: client.go:56:18 *)
Definition Client__Getⁱᵐᵖˡ : val :=
  λ: "c" "uid",
    exception_do (let: "err" := (mem.alloc (type.zero_val #ktcore.Blame)) in
    let: "pk" := (mem.alloc (type.zero_val #sliceT)) in
    let: "isReg" := (mem.alloc (type.zero_val #boolT)) in
    let: "ep" := (mem.alloc (type.zero_val #uint64T)) in
    let: "c" := (mem.alloc "c") in
    let: "uid" := (mem.alloc "uid") in
    let: "bound" := (mem.alloc (type.zero_val #ptrT)) in
    let: "hist" := (mem.alloc (type.zero_val #sliceT)) in
    let: "sig" := (mem.alloc (type.zero_val #sliceT)) in
    let: "chainProof" := (mem.alloc (type.zero_val #sliceT)) in
    let: (((("$ret0", "$ret1"), "$ret2"), "$ret3"), "$ret4") := (let: "$a0" := (![#ptrT] (struct.field_ref #serv #"cli"%go (![#ptrT] (struct.field_ref #Client #"serv"%go (![#ptrT] "c"))))) in
    let: "$a1" := (![#uint64T] "uid") in
    let: "$a2" := (![#uint64T] (struct.field_ref #epoch #"epoch"%go (![#ptrT] (struct.field_ref #Client #"last"%go (![#ptrT] "c"))))) in
    let: "$a3" := #(W64 0) in
    (func_call #server.CallHistory) "$a0" "$a1" "$a2" "$a3") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    let: "$r3" := "$ret3" in
    let: "$r4" := "$ret4" in
    do:  ("chainProof" <-[#sliceT] "$r0");;;
    do:  ("sig" <-[#sliceT] "$r1");;;
    do:  ("hist" <-[#sliceT] "$r2");;;
    do:  ("bound" <-[#ptrT] "$r3");;;
    do:  ("err" <-[#ktcore.Blame] "$r4");;;
    (if: (![#ktcore.Blame] "err") ≠ ktcore.BlameNone
    then return: (![#uint64T] "ep", ![#boolT] "isReg", ![#sliceT] "pk", ![#ktcore.Blame] "err")
    else do:  #());;;
    let: "errb" := (mem.alloc (type.zero_val #boolT)) in
    let: "next" := (mem.alloc (type.zero_val #ptrT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#ptrT] (struct.field_ref #Client #"last"%go (![#ptrT] "c"))) in
    let: "$a1" := (![#cryptoffi.SigPublicKey] (struct.field_ref #serv #"sigPk"%go (![#ptrT] (struct.field_ref #Client #"serv"%go (![#ptrT] "c"))))) in
    let: "$a2" := (![#sliceT] "chainProof") in
    let: "$a3" := (![#sliceT] "sig") in
    (func_call #getNextEp) "$a0" "$a1" "$a2" "$a3") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("next" <-[#ptrT] "$r0");;;
    do:  ("errb" <-[#boolT] "$r1");;;
    (if: ![#boolT] "errb"
    then
      let: "$r0" := ktcore.BlameServFull in
      do:  ("err" <-[#ktcore.Blame] "$r0");;;
      return: (![#uint64T] "ep", ![#boolT] "isReg", ![#sliceT] "pk", ![#ktcore.Blame] "err")
    else do:  #());;;
    (if: let: "$a0" := (![#ptrT] (struct.field_ref #serv #"vrfPk"%go (![#ptrT] (struct.field_ref #Client #"serv"%go (![#ptrT] "c"))))) in
    let: "$a1" := (![#uint64T] "uid") in
    let: "$a2" := #(W64 0) in
    let: "$a3" := (![#sliceT] (struct.field_ref #epoch #"dig"%go (![#ptrT] "next"))) in
    let: "$a4" := (![#sliceT] "hist") in
    (func_call #checkHist) "$a0" "$a1" "$a2" "$a3" "$a4"
    then
      let: "$r0" := ktcore.BlameServFull in
      do:  ("err" <-[#ktcore.Blame] "$r0");;;
      return: (![#uint64T] "ep", ![#boolT] "isReg", ![#sliceT] "pk", ![#ktcore.Blame] "err")
    else do:  #());;;
    let: "boundVer" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (s_to_w64 (let: "$a0" := (![#sliceT] "hist") in
    slice.len "$a0")) in
    do:  ("boundVer" <-[#uint64T] "$r0");;;
    (if: let: "$a0" := (![#ptrT] (struct.field_ref #serv #"vrfPk"%go (![#ptrT] (struct.field_ref #Client #"serv"%go (![#ptrT] "c"))))) in
    let: "$a1" := (![#uint64T] "uid") in
    let: "$a2" := (![#uint64T] "boundVer") in
    let: "$a3" := (![#sliceT] (struct.field_ref #epoch #"dig"%go (![#ptrT] "next"))) in
    let: "$a4" := (![#ptrT] "bound") in
    (func_call #checkNonMemb) "$a0" "$a1" "$a2" "$a3" "$a4"
    then
      let: "$r0" := ktcore.BlameServFull in
      do:  ("err" <-[#ktcore.Blame] "$r0");;;
      return: (![#uint64T] "ep", ![#boolT] "isReg", ![#sliceT] "pk", ![#ktcore.Blame] "err")
    else do:  #());;;
    let: "$r0" := (![#ptrT] "next") in
    do:  ((struct.field_ref #Client #"last"%go (![#ptrT] "c")) <-[#ptrT] "$r0");;;
    let: "$r0" := (![#uint64T] (struct.field_ref #epoch #"epoch"%go (![#ptrT] "next"))) in
    do:  ("ep" <-[#uint64T] "$r0");;;
    (if: (![#uint64T] "boundVer") ≠ #(W64 0)
    then
      let: "$r0" := #true in
      do:  ("isReg" <-[#boolT] "$r0");;;
      let: "$r0" := (![#sliceT] (struct.field_ref #ktcore.CommitOpen #"Val"%go (![#ptrT] (struct.field_ref #ktcore.Memb #"PkOpen"%go (![#ptrT] (slice.elem_ref #ptrT (![#sliceT] "hist") ((![#uint64T] "boundVer") - #(W64 1)))))))) in
      do:  ("pk" <-[#sliceT] "$r0")
    else do:  #());;;
    return: (![#uint64T] "ep", ![#boolT] "isReg", ![#sliceT] "pk", ![#ktcore.Blame] "err")).

(* SelfMon a client's own uid.
   if isChanged, the key was added sometime from the last SelfMon.

   go: client.go:89:18 *)
Definition Client__SelfMonⁱᵐᵖˡ : val :=
  λ: "c" <>,
    exception_do (let: "err" := (mem.alloc (type.zero_val #ktcore.Blame)) in
    let: "isChanged" := (mem.alloc (type.zero_val #boolT)) in
    let: "ep" := (mem.alloc (type.zero_val #uint64T)) in
    let: "c" := (mem.alloc "c") in
    let: "bound" := (mem.alloc (type.zero_val #ptrT)) in
    let: "hist" := (mem.alloc (type.zero_val #sliceT)) in
    let: "sig" := (mem.alloc (type.zero_val #sliceT)) in
    let: "chainProof" := (mem.alloc (type.zero_val #sliceT)) in
    let: (((("$ret0", "$ret1"), "$ret2"), "$ret3"), "$ret4") := (let: "$a0" := (![#ptrT] (struct.field_ref #serv #"cli"%go (![#ptrT] (struct.field_ref #Client #"serv"%go (![#ptrT] "c"))))) in
    let: "$a1" := (![#uint64T] (struct.field_ref #Client #"uid"%go (![#ptrT] "c"))) in
    let: "$a2" := (![#uint64T] (struct.field_ref #epoch #"epoch"%go (![#ptrT] (struct.field_ref #Client #"last"%go (![#ptrT] "c"))))) in
    let: "$a3" := (![#uint64T] (struct.field_ref #nextVer #"ver"%go (![#ptrT] (struct.field_ref #Client #"pend"%go (![#ptrT] "c"))))) in
    (func_call #server.CallHistory) "$a0" "$a1" "$a2" "$a3") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    let: "$r3" := "$ret3" in
    let: "$r4" := "$ret4" in
    do:  ("chainProof" <-[#sliceT] "$r0");;;
    do:  ("sig" <-[#sliceT] "$r1");;;
    do:  ("hist" <-[#sliceT] "$r2");;;
    do:  ("bound" <-[#ptrT] "$r3");;;
    do:  ("err" <-[#ktcore.Blame] "$r4");;;
    (if: (![#ktcore.Blame] "err") ≠ ktcore.BlameNone
    then return: (![#uint64T] "ep", ![#boolT] "isChanged", ![#ktcore.Blame] "err")
    else do:  #());;;
    let: "errb" := (mem.alloc (type.zero_val #boolT)) in
    let: "next" := (mem.alloc (type.zero_val #ptrT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#ptrT] (struct.field_ref #Client #"last"%go (![#ptrT] "c"))) in
    let: "$a1" := (![#cryptoffi.SigPublicKey] (struct.field_ref #serv #"sigPk"%go (![#ptrT] (struct.field_ref #Client #"serv"%go (![#ptrT] "c"))))) in
    let: "$a2" := (![#sliceT] "chainProof") in
    let: "$a3" := (![#sliceT] "sig") in
    (func_call #getNextEp) "$a0" "$a1" "$a2" "$a3") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("next" <-[#ptrT] "$r0");;;
    do:  ("errb" <-[#boolT] "$r1");;;
    (if: ![#boolT] "errb"
    then
      let: "$r0" := ktcore.BlameServFull in
      do:  ("err" <-[#ktcore.Blame] "$r0");;;
      return: (![#uint64T] "ep", ![#boolT] "isChanged", ![#ktcore.Blame] "err")
    else do:  #());;;
    let: "$r0" := (![#uint64T] (struct.field_ref #epoch #"epoch"%go (![#ptrT] "next"))) in
    do:  ("ep" <-[#uint64T] "$r0");;;
    let: "histLen" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (s_to_w64 (let: "$a0" := (![#sliceT] "hist") in
    slice.len "$a0")) in
    do:  ("histLen" <-[#uint64T] "$r0");;;
    let: "boundVer" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := ((![#uint64T] (struct.field_ref #nextVer #"ver"%go (![#ptrT] (struct.field_ref #Client #"pend"%go (![#ptrT] "c"))))) + (![#uint64T] "histLen")) in
    do:  ("boundVer" <-[#uint64T] "$r0");;;
    (if: (~ (let: "$a0" := (![#uint64T] (struct.field_ref #nextVer #"ver"%go (![#ptrT] (struct.field_ref #Client #"pend"%go (![#ptrT] "c"))))) in
    let: "$a1" := (![#uint64T] "histLen") in
    (func_call #std.SumNoOverflow) "$a0" "$a1"))
    then
      let: "$r0" := ktcore.BlameServFull in
      do:  ("err" <-[#ktcore.Blame] "$r0");;;
      return: (![#uint64T] "ep", ![#boolT] "isChanged", ![#ktcore.Blame] "err")
    else do:  #());;;
    (if: let: "$a0" := (![#ptrT] (struct.field_ref #serv #"vrfPk"%go (![#ptrT] (struct.field_ref #Client #"serv"%go (![#ptrT] "c"))))) in
    let: "$a1" := (![#uint64T] (struct.field_ref #Client #"uid"%go (![#ptrT] "c"))) in
    let: "$a2" := (![#uint64T] (struct.field_ref #nextVer #"ver"%go (![#ptrT] (struct.field_ref #Client #"pend"%go (![#ptrT] "c"))))) in
    let: "$a3" := (![#sliceT] (struct.field_ref #epoch #"dig"%go (![#ptrT] "next"))) in
    let: "$a4" := (![#sliceT] "hist") in
    (func_call #checkHist) "$a0" "$a1" "$a2" "$a3" "$a4"
    then
      let: "$r0" := ktcore.BlameServFull in
      do:  ("err" <-[#ktcore.Blame] "$r0");;;
      return: (![#uint64T] "ep", ![#boolT] "isChanged", ![#ktcore.Blame] "err")
    else do:  #());;;
    (if: let: "$a0" := (![#ptrT] (struct.field_ref #serv #"vrfPk"%go (![#ptrT] (struct.field_ref #Client #"serv"%go (![#ptrT] "c"))))) in
    let: "$a1" := (![#uint64T] (struct.field_ref #Client #"uid"%go (![#ptrT] "c"))) in
    let: "$a2" := (![#uint64T] "boundVer") in
    let: "$a3" := (![#sliceT] (struct.field_ref #epoch #"dig"%go (![#ptrT] "next"))) in
    let: "$a4" := (![#ptrT] "bound") in
    (func_call #checkNonMemb) "$a0" "$a1" "$a2" "$a3" "$a4"
    then
      let: "$r0" := ktcore.BlameServFull in
      do:  ("err" <-[#ktcore.Blame] "$r0");;;
      return: (![#uint64T] "ep", ![#boolT] "isChanged", ![#ktcore.Blame] "err")
    else do:  #());;;
    (if: (~ (![#boolT] (struct.field_ref #nextVer #"isPending"%go (![#ptrT] (struct.field_ref #Client #"pend"%go (![#ptrT] "c"))))))
    then
      (if: (![#uint64T] "histLen") ≠ #(W64 0)
      then
        let: "$r0" := (ktcore.BlameServFull `or` ktcore.BlameClients) in
        do:  ("err" <-[#ktcore.Blame] "$r0");;;
        return: (![#uint64T] "ep", ![#boolT] "isChanged", ![#ktcore.Blame] "err")
      else do:  #());;;
      let: "$r0" := (![#ptrT] "next") in
      do:  ((struct.field_ref #Client #"last"%go (![#ptrT] "c")) <-[#ptrT] "$r0");;;
      return: (![#uint64T] "ep", ![#boolT] "isChanged", ![#ktcore.Blame] "err")
    else do:  #());;;
    (if: (![#uint64T] "histLen") > #(W64 1)
    then
      let: "$r0" := (ktcore.BlameServFull `or` ktcore.BlameClients) in
      do:  ("err" <-[#ktcore.Blame] "$r0");;;
      return: (![#uint64T] "ep", ![#boolT] "isChanged", ![#ktcore.Blame] "err")
    else do:  #());;;
    (if: (![#uint64T] "histLen") = #(W64 0)
    then
      let: "$r0" := (![#ptrT] "next") in
      do:  ((struct.field_ref #Client #"last"%go (![#ptrT] "c")) <-[#ptrT] "$r0");;;
      return: (![#uint64T] "ep", ![#boolT] "isChanged", ![#ktcore.Blame] "err")
    else do:  #());;;
    let: "newKey" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (![#ptrT] (slice.elem_ref #ptrT (![#sliceT] "hist") #(W64 0))) in
    do:  ("newKey" <-[#ptrT] "$r0");;;
    (if: (~ (let: "$a0" := (![#sliceT] (struct.field_ref #ktcore.CommitOpen #"Val"%go (![#ptrT] (struct.field_ref #ktcore.Memb #"PkOpen"%go (![#ptrT] "newKey"))))) in
    let: "$a1" := (![#sliceT] (struct.field_ref #nextVer #"pendingPk"%go (![#ptrT] (struct.field_ref #Client #"pend"%go (![#ptrT] "c"))))) in
    (func_call #bytes.Equal) "$a0" "$a1"))
    then
      let: "$r0" := (ktcore.BlameServFull `or` ktcore.BlameClients) in
      do:  ("err" <-[#ktcore.Blame] "$r0");;;
      return: (![#uint64T] "ep", ![#boolT] "isChanged", ![#ktcore.Blame] "err")
    else do:  #());;;
    let: "$r0" := (![#ptrT] "next") in
    do:  ((struct.field_ref #Client #"last"%go (![#ptrT] "c")) <-[#ptrT] "$r0");;;
    let: "$r0" := #false in
    do:  ((struct.field_ref #nextVer #"isPending"%go (![#ptrT] (struct.field_ref #Client #"pend"%go (![#ptrT] "c")))) <-[#boolT] "$r0");;;
    let: "$r0" := #slice.nil in
    do:  ((struct.field_ref #nextVer #"pendingPk"%go (![#ptrT] (struct.field_ref #Client #"pend"%go (![#ptrT] "c")))) <-[#sliceT] "$r0");;;
    let: "$r0" := (![#uint64T] "boundVer") in
    do:  ((struct.field_ref #nextVer #"ver"%go (![#ptrT] (struct.field_ref #Client #"pend"%go (![#ptrT] "c")))) <-[#uint64T] "$r0");;;
    let: "$r0" := #true in
    do:  ("isChanged" <-[#boolT] "$r0");;;
    return: (![#uint64T] "ep", ![#boolT] "isChanged", ![#ktcore.Blame] "err")).

Definition Evid : go_type := structT [
  "vrf" :: ptrT;
  "link" :: ptrT
].
#[global] Typeclasses Opaque Evid.
#[global] Opaque Evid.

Definition evidLink : go_type := structT [
  "epoch" :: uint64T;
  "link0" :: sliceT;
  "sig0" :: sliceT;
  "link1" :: sliceT;
  "sig1" :: sliceT
].
#[global] Typeclasses Opaque evidLink.
#[global] Opaque evidLink.

Definition evidVrf : go_type := structT [
  "vrfPk0" :: sliceT;
  "sig0" :: sliceT;
  "vrfPk1" :: sliceT;
  "sig1" :: sliceT
].
#[global] Typeclasses Opaque evidVrf.
#[global] Opaque evidVrf.

Definition checkAuditVrf : go_string := "github.com/sanjit-bhat/pav/client.checkAuditVrf"%go.

Definition checkAuditLink : go_string := "github.com/sanjit-bhat/pav/client.checkAuditLink"%go.

(* go: client.go:154:18 *)
Definition Client__Auditⁱᵐᵖˡ : val :=
  λ: "c" "adtrAddr" "adtrPk",
    exception_do (let: "err" := (mem.alloc (type.zero_val #ktcore.Blame)) in
    let: "evid" := (mem.alloc (type.zero_val #ptrT)) in
    let: "c" := (mem.alloc "c") in
    let: "adtrPk" := (mem.alloc "adtrPk") in
    let: "adtrAddr" := (mem.alloc "adtrAddr") in
    let: "cli" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := (![#uint64T] "adtrAddr") in
    (func_call #advrpc.Dial) "$a0") in
    do:  ("cli" <-[#ptrT] "$r0");;;
    let: "last" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (![#ptrT] (struct.field_ref #Client #"last"%go (![#ptrT] "c"))) in
    do:  ("last" <-[#ptrT] "$r0");;;
    let: "vrf" := (mem.alloc (type.zero_val #ptrT)) in
    let: "link" := (mem.alloc (type.zero_val #ptrT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#ptrT] "cli") in
    let: "$a1" := (![#uint64T] (struct.field_ref #epoch #"epoch"%go (![#ptrT] "last"))) in
    (func_call #auditor.CallGet) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("link" <-[#ptrT] "$r0");;;
    do:  ("vrf" <-[#ptrT] "$r1");;;
    do:  ("err" <-[#ktcore.Blame] "$r2");;;
    (if: (![#ktcore.Blame] "err") ≠ ktcore.BlameNone
    then return: (![#ptrT] "evid", ![#ktcore.Blame] "err")
    else do:  #());;;
    (if: let: "$a0" := (![#cryptoffi.SigPublicKey] (struct.field_ref #serv #"sigPk"%go (![#ptrT] (struct.field_ref #Client #"serv"%go (![#ptrT] "c"))))) in
    let: "$a1" := (![#cryptoffi.SigPublicKey] "adtrPk") in
    let: "$a2" := (![#uint64T] (struct.field_ref #epoch #"epoch"%go (![#ptrT] "last"))) in
    let: "$a3" := (![#ptrT] "link") in
    (func_call #checkAuditLink) "$a0" "$a1" "$a2" "$a3"
    then
      let: "$r0" := ktcore.BlameAdtrFull in
      do:  ("err" <-[#ktcore.Blame] "$r0");;;
      return: (![#ptrT] "evid", ![#ktcore.Blame] "err")
    else do:  #());;;
    (if: let: "$a0" := (![#cryptoffi.SigPublicKey] (struct.field_ref #serv #"sigPk"%go (![#ptrT] (struct.field_ref #Client #"serv"%go (![#ptrT] "c"))))) in
    let: "$a1" := (![#cryptoffi.SigPublicKey] "adtrPk") in
    let: "$a2" := (![#ptrT] "vrf") in
    (func_call #checkAuditVrf) "$a0" "$a1" "$a2"
    then
      let: "$r0" := ktcore.BlameAdtrFull in
      do:  ("err" <-[#ktcore.Blame] "$r0");;;
      return: (![#ptrT] "evid", ![#ktcore.Blame] "err")
    else do:  #());;;
    let: "vrfPkB" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#ptrT] (struct.field_ref #serv #"vrfPk"%go (![#ptrT] (struct.field_ref #Client #"serv"%go (![#ptrT] "c"))))) in
    (func_call #cryptoffi.VrfPublicKeyEncode) "$a0") in
    do:  ("vrfPkB" <-[#sliceT] "$r0");;;
    (if: (~ (let: "$a0" := (![#sliceT] "vrfPkB") in
    let: "$a1" := (![#sliceT] (struct.field_ref #auditor.SignedVrf #"VrfPk"%go (![#ptrT] "vrf"))) in
    (func_call #bytes.Equal) "$a0" "$a1"))
    then
      let: "$r0" := (mem.alloc (let: "$vrf" := (mem.alloc (let: "$vrfPk0" := (![#sliceT] "vrfPkB") in
      let: "$sig0" := (![#sliceT] (struct.field_ref #serv #"vrfSig"%go (![#ptrT] (struct.field_ref #Client #"serv"%go (![#ptrT] "c"))))) in
      let: "$vrfPk1" := (![#sliceT] (struct.field_ref #auditor.SignedVrf #"VrfPk"%go (![#ptrT] "vrf"))) in
      let: "$sig1" := (![#sliceT] (struct.field_ref #auditor.SignedVrf #"ServSig"%go (![#ptrT] "vrf"))) in
      struct.make #evidVrf [{
        "vrfPk0" ::= "$vrfPk0";
        "sig0" ::= "$sig0";
        "vrfPk1" ::= "$vrfPk1";
        "sig1" ::= "$sig1"
      }])) in
      struct.make #Evid [{
        "vrf" ::= "$vrf";
        "link" ::= type.zero_val #ptrT
      }])) in
      do:  ("evid" <-[#ptrT] "$r0");;;
      let: "$r0" := ktcore.BlameServSig in
      do:  ("err" <-[#ktcore.Blame] "$r0");;;
      return: (![#ptrT] "evid", ![#ktcore.Blame] "err")
    else do:  #());;;
    (if: (~ (let: "$a0" := (![#sliceT] (struct.field_ref #epoch #"link"%go (![#ptrT] "last"))) in
    let: "$a1" := (![#sliceT] (struct.field_ref #auditor.SignedLink #"Link"%go (![#ptrT] "link"))) in
    (func_call #bytes.Equal) "$a0" "$a1"))
    then
      let: "$r0" := (mem.alloc (let: "$link" := (mem.alloc (let: "$epoch" := (![#uint64T] (struct.field_ref #epoch #"epoch"%go (![#ptrT] "last"))) in
      let: "$link0" := (![#sliceT] (struct.field_ref #epoch #"link"%go (![#ptrT] "last"))) in
      let: "$sig0" := (![#sliceT] (struct.field_ref #epoch #"sig"%go (![#ptrT] "last"))) in
      let: "$link1" := (![#sliceT] (struct.field_ref #auditor.SignedLink #"Link"%go (![#ptrT] "link"))) in
      let: "$sig1" := (![#sliceT] (struct.field_ref #auditor.SignedLink #"ServSig"%go (![#ptrT] "link"))) in
      struct.make #evidLink [{
        "epoch" ::= "$epoch";
        "link0" ::= "$link0";
        "sig0" ::= "$sig0";
        "link1" ::= "$link1";
        "sig1" ::= "$sig1"
      }])) in
      struct.make #Evid [{
        "vrf" ::= type.zero_val #ptrT;
        "link" ::= "$link"
      }])) in
      do:  ("evid" <-[#ptrT] "$r0");;;
      let: "$r0" := ktcore.BlameServSig in
      do:  ("err" <-[#ktcore.Blame] "$r0");;;
      return: (![#ptrT] "evid", ![#ktcore.Blame] "err")
    else do:  #());;;
    return: (![#ptrT] "evid", ![#ktcore.Blame] "err")).

Definition New : go_string := "github.com/sanjit-bhat/pav/client.New"%go.

(* go: client.go:188:6 *)
Definition Newⁱᵐᵖˡ : val :=
  λ: "uid" "servAddr" "servPk",
    exception_do (let: "err" := (mem.alloc (type.zero_val #ktcore.Blame)) in
    let: "c" := (mem.alloc (type.zero_val #ptrT)) in
    let: "servPk" := (mem.alloc "servPk") in
    let: "servAddr" := (mem.alloc "servAddr") in
    let: "uid" := (mem.alloc "uid") in
    let: "cli" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := (![#uint64T] "servAddr") in
    (func_call #advrpc.Dial) "$a0") in
    do:  ("cli" <-[#ptrT] "$r0");;;
    let: "vrf" := (mem.alloc (type.zero_val #ptrT)) in
    let: "chain" := (mem.alloc (type.zero_val #ptrT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#ptrT] "cli") in
    (func_call #server.CallStart) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("chain" <-[#ptrT] "$r0");;;
    do:  ("vrf" <-[#ptrT] "$r1");;;
    do:  ("err" <-[#ktcore.Blame] "$r2");;;
    (if: (![#ktcore.Blame] "err") ≠ ktcore.BlameNone
    then return: (![#ptrT] "c", ![#ktcore.Blame] "err")
    else do:  #());;;
    let: "errb" := (mem.alloc (type.zero_val #boolT)) in
    let: "startLink" := (mem.alloc (type.zero_val #sliceT)) in
    let: "startDig" := (mem.alloc (type.zero_val #sliceT)) in
    let: "startEp" := (mem.alloc (type.zero_val #uint64T)) in
    let: ((("$ret0", "$ret1"), "$ret2"), "$ret3") := (let: "$a0" := (![#cryptoffi.SigPublicKey] "servPk") in
    let: "$a1" := (![#ptrT] "chain") in
    (func_call #auditor.CheckStartChain) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    let: "$r3" := "$ret3" in
    do:  ("startEp" <-[#uint64T] "$r0");;;
    do:  ("startDig" <-[#sliceT] "$r1");;;
    do:  ("startLink" <-[#sliceT] "$r2");;;
    do:  ("errb" <-[#boolT] "$r3");;;
    (if: ![#boolT] "errb"
    then
      let: "$r0" := ktcore.BlameServFull in
      do:  ("err" <-[#ktcore.Blame] "$r0");;;
      return: (![#ptrT] "c", ![#ktcore.Blame] "err")
    else do:  #());;;
    let: "vrfPk" := (mem.alloc (type.zero_val #ptrT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#cryptoffi.SigPublicKey] "servPk") in
    let: "$a1" := (![#ptrT] "vrf") in
    (func_call #auditor.CheckStartVrf) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("vrfPk" <-[#ptrT] "$r0");;;
    do:  ("errb" <-[#boolT] "$r1");;;
    (if: ![#boolT] "errb"
    then
      let: "$r0" := ktcore.BlameServFull in
      do:  ("err" <-[#ktcore.Blame] "$r0");;;
      return: (![#ptrT] "c", ![#ktcore.Blame] "err")
    else do:  #());;;
    let: "pendingPut" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (struct.make #nextVer [{
      "ver" ::= type.zero_val #uint64T;
      "isPending" ::= type.zero_val #boolT;
      "pendingPk" ::= type.zero_val #sliceT
    }])) in
    do:  ("pendingPut" <-[#ptrT] "$r0");;;
    let: "last" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (let: "$epoch" := (![#uint64T] "startEp") in
    let: "$dig" := (![#sliceT] "startDig") in
    let: "$link" := (![#sliceT] "startLink") in
    let: "$sig" := (![#sliceT] (struct.field_ref #server.StartChain #"LinkSig"%go (![#ptrT] "chain"))) in
    struct.make #epoch [{
      "epoch" ::= "$epoch";
      "dig" ::= "$dig";
      "link" ::= "$link";
      "sig" ::= "$sig"
    }])) in
    do:  ("last" <-[#ptrT] "$r0");;;
    let: "serv" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (let: "$cli" := (![#ptrT] "cli") in
    let: "$sigPk" := (![#cryptoffi.SigPublicKey] "servPk") in
    let: "$vrfPk" := (![#ptrT] "vrfPk") in
    let: "$vrfSig" := (![#sliceT] (struct.field_ref #server.StartVrf #"VrfSig"%go (![#ptrT] "vrf"))) in
    struct.make #serv [{
      "cli" ::= "$cli";
      "sigPk" ::= "$sigPk";
      "vrfPk" ::= "$vrfPk";
      "vrfSig" ::= "$vrfSig"
    }])) in
    do:  ("serv" <-[#ptrT] "$r0");;;
    let: "$r0" := (mem.alloc (let: "$uid" := (![#uint64T] "uid") in
    let: "$pend" := (![#ptrT] "pendingPut") in
    let: "$last" := (![#ptrT] "last") in
    let: "$serv" := (![#ptrT] "serv") in
    struct.make #Client [{
      "uid" ::= "$uid";
      "pend" ::= "$pend";
      "last" ::= "$last";
      "serv" ::= "$serv"
    }])) in
    do:  ("c" <-[#ptrT] "$r0");;;
    return: (![#ptrT] "c", ![#ktcore.Blame] "err")).

(* go: client.go:212:6 *)
Definition getNextEpⁱᵐᵖˡ : val :=
  λ: "prev" "sigPk" "chainProof" "sig",
    exception_do (let: "err" := (mem.alloc (type.zero_val #boolT)) in
    let: "next" := (mem.alloc (type.zero_val #ptrT)) in
    let: "sig" := (mem.alloc "sig") in
    let: "chainProof" := (mem.alloc "chainProof") in
    let: "sigPk" := (mem.alloc "sigPk") in
    let: "prev" := (mem.alloc "prev") in
    let: "nextLink" := (mem.alloc (type.zero_val #sliceT)) in
    let: "nextDig" := (mem.alloc (type.zero_val #sliceT)) in
    let: "extLen" := (mem.alloc (type.zero_val #uint64T)) in
    let: ((("$ret0", "$ret1"), "$ret2"), "$ret3") := (let: "$a0" := (![#sliceT] (struct.field_ref #epoch #"link"%go (![#ptrT] "prev"))) in
    let: "$a1" := (![#sliceT] "chainProof") in
    (func_call #hashchain.Verify) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    let: "$r3" := "$ret3" in
    do:  ("extLen" <-[#uint64T] "$r0");;;
    do:  ("nextDig" <-[#sliceT] "$r1");;;
    do:  ("nextLink" <-[#sliceT] "$r2");;;
    do:  ("err" <-[#boolT] "$r3");;;
    (if: ![#boolT] "err"
    then return: (![#ptrT] "next", ![#boolT] "err")
    else do:  #());;;
    let: "nextEp" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := ((![#uint64T] (struct.field_ref #epoch #"epoch"%go (![#ptrT] "prev"))) + (![#uint64T] "extLen")) in
    do:  ("nextEp" <-[#uint64T] "$r0");;;
    (if: (~ (let: "$a0" := (![#uint64T] (struct.field_ref #epoch #"epoch"%go (![#ptrT] "prev"))) in
    let: "$a1" := (![#uint64T] "extLen") in
    (func_call #std.SumNoOverflow) "$a0" "$a1"))
    then
      let: "$r0" := #true in
      do:  ("err" <-[#boolT] "$r0");;;
      return: (![#ptrT] "next", ![#boolT] "err")
    else do:  #());;;
    (if: let: "$a0" := (![#cryptoffi.SigPublicKey] "sigPk") in
    let: "$a1" := (![#uint64T] "nextEp") in
    let: "$a2" := (![#sliceT] "nextLink") in
    let: "$a3" := (![#sliceT] "sig") in
    (func_call #ktcore.VerifyLinkSig) "$a0" "$a1" "$a2" "$a3"
    then
      let: "$r0" := #true in
      do:  ("err" <-[#boolT] "$r0");;;
      return: (![#ptrT] "next", ![#boolT] "err")
    else do:  #());;;
    (if: (![#uint64T] "extLen") = #(W64 0)
    then
      let: "$r0" := (![#sliceT] (struct.field_ref #epoch #"dig"%go (![#ptrT] "prev"))) in
      do:  ("nextDig" <-[#sliceT] "$r0")
    else do:  #());;;
    let: "$r0" := (mem.alloc (let: "$epoch" := (![#uint64T] "nextEp") in
    let: "$dig" := (![#sliceT] "nextDig") in
    let: "$link" := (![#sliceT] "nextLink") in
    let: "$sig" := (![#sliceT] "sig") in
    struct.make #epoch [{
      "epoch" ::= "$epoch";
      "dig" ::= "$dig";
      "link" ::= "$link";
      "sig" ::= "$sig"
    }])) in
    do:  ("next" <-[#ptrT] "$r0");;;
    return: (![#ptrT] "next", ![#boolT] "err")).

Definition checkMemb : go_string := "github.com/sanjit-bhat/pav/client.checkMemb"%go.

(* go: client.go:233:6 *)
Definition checkMembⁱᵐᵖˡ : val :=
  λ: "vrfPk" "uid" "ver" "dig" "memb",
    exception_do (let: "err" := (mem.alloc (type.zero_val #boolT)) in
    let: "memb" := (mem.alloc "memb") in
    let: "dig" := (mem.alloc "dig") in
    let: "ver" := (mem.alloc "ver") in
    let: "uid" := (mem.alloc "uid") in
    let: "vrfPk" := (mem.alloc "vrfPk") in
    let: "label" := (mem.alloc (type.zero_val #sliceT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#ptrT] "vrfPk") in
    let: "$a1" := (![#uint64T] "uid") in
    let: "$a2" := (![#uint64T] "ver") in
    let: "$a3" := (![#sliceT] (struct.field_ref #ktcore.Memb #"LabelProof"%go (![#ptrT] "memb"))) in
    (func_call #ktcore.CheckMapLabel) "$a0" "$a1" "$a2" "$a3") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("label" <-[#sliceT] "$r0");;;
    do:  ("err" <-[#boolT] "$r1");;;
    (if: ![#boolT] "err"
    then return: (![#boolT] "err")
    else do:  #());;;
    let: "mapVal" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#ptrT] (struct.field_ref #ktcore.Memb #"PkOpen"%go (![#ptrT] "memb"))) in
    (func_call #ktcore.GetMapVal) "$a0") in
    do:  ("mapVal" <-[#sliceT] "$r0");;;
    let: "dig0" := (mem.alloc (type.zero_val #sliceT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "label") in
    let: "$a1" := (![#sliceT] "mapVal") in
    let: "$a2" := (![#sliceT] (struct.field_ref #ktcore.Memb #"MerkleProof"%go (![#ptrT] "memb"))) in
    (func_call #merkle.VerifyMemb) "$a0" "$a1" "$a2") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("dig0" <-[#sliceT] "$r0");;;
    do:  ("err" <-[#boolT] "$r1");;;
    (if: ![#boolT] "err"
    then return: (![#boolT] "err")
    else do:  #());;;
    (if: (~ (let: "$a0" := (![#sliceT] "dig") in
    let: "$a1" := (![#sliceT] "dig0") in
    (func_call #bytes.Equal) "$a0" "$a1"))
    then
      let: "$r0" := #true in
      do:  ("err" <-[#boolT] "$r0");;;
      return: (![#boolT] "err")
    else do:  #());;;
    return: (![#boolT] "err")).

(* go: client.go:250:6 *)
Definition checkHistⁱᵐᵖˡ : val :=
  λ: "vrfPk" "uid" "prefixLen" "dig" "hist",
    exception_do (let: "err" := (mem.alloc (type.zero_val #boolT)) in
    let: "hist" := (mem.alloc "hist") in
    let: "dig" := (mem.alloc "dig") in
    let: "prefixLen" := (mem.alloc "prefixLen") in
    let: "uid" := (mem.alloc "uid") in
    let: "vrfPk" := (mem.alloc "vrfPk") in
    let: "$range" := (![#sliceT] "hist") in
    (let: "memb" := (mem.alloc (type.zero_val #ptrT)) in
    let: "ver" := (mem.alloc (type.zero_val #intT)) in
    slice.for_range #ptrT "$range" (λ: "$key" "$value",
      do:  ("memb" <-[#ptrT] "$value");;;
      do:  ("ver" <-[#intT] "$key");;;
      (let: "$r0" := (let: "$a0" := (![#ptrT] "vrfPk") in
      let: "$a1" := (![#uint64T] "uid") in
      let: "$a2" := ((![#uint64T] "prefixLen") + (s_to_w64 (![#intT] "ver"))) in
      let: "$a3" := (![#sliceT] "dig") in
      let: "$a4" := (![#ptrT] "memb") in
      (func_call #checkMemb) "$a0" "$a1" "$a2" "$a3" "$a4") in
      do:  ("err" <-[#boolT] "$r0");;;
      (if: ![#boolT] "err"
      then return: (![#boolT] "err")
      else do:  #()))));;;
    return: (![#boolT] "err")).

(* go: client.go:259:6 *)
Definition checkNonMembⁱᵐᵖˡ : val :=
  λ: "vrfPk" "uid" "ver" "dig" "nonMemb",
    exception_do (let: "err" := (mem.alloc (type.zero_val #boolT)) in
    let: "nonMemb" := (mem.alloc "nonMemb") in
    let: "dig" := (mem.alloc "dig") in
    let: "ver" := (mem.alloc "ver") in
    let: "uid" := (mem.alloc "uid") in
    let: "vrfPk" := (mem.alloc "vrfPk") in
    let: "label" := (mem.alloc (type.zero_val #sliceT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#ptrT] "vrfPk") in
    let: "$a1" := (![#uint64T] "uid") in
    let: "$a2" := (![#uint64T] "ver") in
    let: "$a3" := (![#sliceT] (struct.field_ref #ktcore.NonMemb #"LabelProof"%go (![#ptrT] "nonMemb"))) in
    (func_call #ktcore.CheckMapLabel) "$a0" "$a1" "$a2" "$a3") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("label" <-[#sliceT] "$r0");;;
    do:  ("err" <-[#boolT] "$r1");;;
    (if: ![#boolT] "err"
    then return: (![#boolT] "err")
    else do:  #());;;
    let: "dig0" := (mem.alloc (type.zero_val #sliceT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "label") in
    let: "$a1" := (![#sliceT] (struct.field_ref #ktcore.NonMemb #"MerkleProof"%go (![#ptrT] "nonMemb"))) in
    (func_call #merkle.VerifyNonMemb) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("dig0" <-[#sliceT] "$r0");;;
    do:  ("err" <-[#boolT] "$r1");;;
    (if: ![#boolT] "err"
    then return: (![#boolT] "err")
    else do:  #());;;
    (if: (~ (let: "$a0" := (![#sliceT] "dig") in
    let: "$a1" := (![#sliceT] "dig0") in
    (func_call #bytes.Equal) "$a0" "$a1"))
    then
      let: "$r0" := #true in
      do:  ("err" <-[#boolT] "$r0");;;
      return: (![#boolT] "err")
    else do:  #());;;
    return: (![#boolT] "err")).

(* go: client.go:275:6 *)
Definition checkAuditLinkⁱᵐᵖˡ : val :=
  λ: "servPk" "adtrPk" "ep" "link",
    exception_do (let: "err" := (mem.alloc (type.zero_val #boolT)) in
    let: "link" := (mem.alloc "link") in
    let: "ep" := (mem.alloc "ep") in
    let: "adtrPk" := (mem.alloc "adtrPk") in
    let: "servPk" := (mem.alloc "servPk") in
    (if: let: "$a0" := (![#cryptoffi.SigPublicKey] "adtrPk") in
    let: "$a1" := (![#uint64T] "ep") in
    let: "$a2" := (![#sliceT] (struct.field_ref #auditor.SignedLink #"Link"%go (![#ptrT] "link"))) in
    let: "$a3" := (![#sliceT] (struct.field_ref #auditor.SignedLink #"AdtrSig"%go (![#ptrT] "link"))) in
    (func_call #ktcore.VerifyLinkSig) "$a0" "$a1" "$a2" "$a3"
    then return: (#true)
    else do:  #());;;
    (if: let: "$a0" := (![#cryptoffi.SigPublicKey] "servPk") in
    let: "$a1" := (![#uint64T] "ep") in
    let: "$a2" := (![#sliceT] (struct.field_ref #auditor.SignedLink #"Link"%go (![#ptrT] "link"))) in
    let: "$a3" := (![#sliceT] (struct.field_ref #auditor.SignedLink #"ServSig"%go (![#ptrT] "link"))) in
    (func_call #ktcore.VerifyLinkSig) "$a0" "$a1" "$a2" "$a3"
    then return: (#true)
    else do:  #());;;
    return: (![#boolT] "err")).

(* go: client.go:285:6 *)
Definition checkAuditVrfⁱᵐᵖˡ : val :=
  λ: "servPk" "adtrPk" "vrf",
    exception_do (let: "err" := (mem.alloc (type.zero_val #boolT)) in
    let: "vrf" := (mem.alloc "vrf") in
    let: "adtrPk" := (mem.alloc "adtrPk") in
    let: "servPk" := (mem.alloc "servPk") in
    (if: let: "$a0" := (![#cryptoffi.SigPublicKey] "adtrPk") in
    let: "$a1" := (![#sliceT] (struct.field_ref #auditor.SignedVrf #"VrfPk"%go (![#ptrT] "vrf"))) in
    let: "$a2" := (![#sliceT] (struct.field_ref #auditor.SignedVrf #"AdtrSig"%go (![#ptrT] "vrf"))) in
    (func_call #ktcore.VerifyVrfSig) "$a0" "$a1" "$a2"
    then return: (#true)
    else do:  #());;;
    (if: let: "$a0" := (![#cryptoffi.SigPublicKey] "servPk") in
    let: "$a1" := (![#sliceT] (struct.field_ref #auditor.SignedVrf #"VrfPk"%go (![#ptrT] "vrf"))) in
    let: "$a2" := (![#sliceT] (struct.field_ref #auditor.SignedVrf #"ServSig"%go (![#ptrT] "vrf"))) in
    (func_call #ktcore.VerifyVrfSig) "$a0" "$a1" "$a2"
    then return: (#true)
    else do:  #());;;
    return: (![#boolT] "err")).

(* go: evidence.go:32:19 *)
Definition evidVrf__checkⁱᵐᵖˡ : val :=
  λ: "e" "pk",
    exception_do (let: "err" := (mem.alloc (type.zero_val #boolT)) in
    let: "e" := (mem.alloc "e") in
    let: "pk" := (mem.alloc "pk") in
    (if: let: "$a0" := (![#cryptoffi.SigPublicKey] "pk") in
    let: "$a1" := (![#sliceT] (struct.field_ref #evidVrf #"vrfPk0"%go (![#ptrT] "e"))) in
    let: "$a2" := (![#sliceT] (struct.field_ref #evidVrf #"sig0"%go (![#ptrT] "e"))) in
    (func_call #ktcore.VerifyVrfSig) "$a0" "$a1" "$a2"
    then return: (#true)
    else do:  #());;;
    (if: let: "$a0" := (![#cryptoffi.SigPublicKey] "pk") in
    let: "$a1" := (![#sliceT] (struct.field_ref #evidVrf #"vrfPk1"%go (![#ptrT] "e"))) in
    let: "$a2" := (![#sliceT] (struct.field_ref #evidVrf #"sig1"%go (![#ptrT] "e"))) in
    (func_call #ktcore.VerifyVrfSig) "$a0" "$a1" "$a2"
    then return: (#true)
    else do:  #());;;
    return: (let: "$a0" := (![#sliceT] (struct.field_ref #evidVrf #"vrfPk0"%go (![#ptrT] "e"))) in
     let: "$a1" := (![#sliceT] (struct.field_ref #evidVrf #"vrfPk1"%go (![#ptrT] "e"))) in
     (func_call #bytes.Equal) "$a0" "$a1")).

(* go: evidence.go:42:20 *)
Definition evidLink__checkⁱᵐᵖˡ : val :=
  λ: "e" "pk",
    exception_do (let: "err" := (mem.alloc (type.zero_val #boolT)) in
    let: "e" := (mem.alloc "e") in
    let: "pk" := (mem.alloc "pk") in
    (if: let: "$a0" := (![#cryptoffi.SigPublicKey] "pk") in
    let: "$a1" := (![#uint64T] (struct.field_ref #evidLink #"epoch"%go (![#ptrT] "e"))) in
    let: "$a2" := (![#sliceT] (struct.field_ref #evidLink #"link0"%go (![#ptrT] "e"))) in
    let: "$a3" := (![#sliceT] (struct.field_ref #evidLink #"sig0"%go (![#ptrT] "e"))) in
    (func_call #ktcore.VerifyLinkSig) "$a0" "$a1" "$a2" "$a3"
    then return: (#true)
    else do:  #());;;
    (if: let: "$a0" := (![#cryptoffi.SigPublicKey] "pk") in
    let: "$a1" := (![#uint64T] (struct.field_ref #evidLink #"epoch"%go (![#ptrT] "e"))) in
    let: "$a2" := (![#sliceT] (struct.field_ref #evidLink #"link1"%go (![#ptrT] "e"))) in
    let: "$a3" := (![#sliceT] (struct.field_ref #evidLink #"sig1"%go (![#ptrT] "e"))) in
    (func_call #ktcore.VerifyLinkSig) "$a0" "$a1" "$a2" "$a3"
    then return: (#true)
    else do:  #());;;
    return: (let: "$a0" := (![#sliceT] (struct.field_ref #evidLink #"link0"%go (![#ptrT] "e"))) in
     let: "$a1" := (![#sliceT] (struct.field_ref #evidLink #"link1"%go (![#ptrT] "e"))) in
     (func_call #bytes.Equal) "$a0" "$a1")).

(* Check returns an error if the evidence does not check out.
   otherwise, it proves that the server was dishonest.

   go: evidence.go:54:16 *)
Definition Evid__Checkⁱᵐᵖˡ : val :=
  λ: "e" "pk",
    exception_do (let: "e" := (mem.alloc "e") in
    let: "pk" := (mem.alloc "pk") in
    (if: (![#ptrT] (struct.field_ref #Evid #"vrf"%go (![#ptrT] "e"))) ≠ #null
    then
      (if: (![#ptrT] (struct.field_ref #Evid #"link"%go (![#ptrT] "e"))) ≠ #null
      then return: (#true)
      else do:  #());;;
      return: (let: "$a0" := (![#cryptoffi.SigPublicKey] "pk") in
       (method_call #(ptrT.id evidVrf.id) #"check"%go (![#ptrT] (struct.field_ref #Evid #"vrf"%go (![#ptrT] "e")))) "$a0")
    else
      (if: (![#ptrT] (struct.field_ref #Evid #"link"%go (![#ptrT] "e"))) = #null
      then return: (#true)
      else do:  #());;;
      return: (let: "$a0" := (![#cryptoffi.SigPublicKey] "pk") in
       (method_call #(ptrT.id evidLink.id) #"check"%go (![#ptrT] (struct.field_ref #Evid #"link"%go (![#ptrT] "e")))) "$a0"))).

Definition vars' : list (go_string * go_type) := [].

Definition functions' : list (go_string * val) := [(New, Newⁱᵐᵖˡ); (getNextEp, getNextEpⁱᵐᵖˡ); (checkMemb, checkMembⁱᵐᵖˡ); (checkHist, checkHistⁱᵐᵖˡ); (checkNonMemb, checkNonMembⁱᵐᵖˡ); (checkAuditLink, checkAuditLinkⁱᵐᵖˡ); (checkAuditVrf, checkAuditVrfⁱᵐᵖˡ)].

Definition msets' : list (go_string * (list (go_string * val))) := [(Client.id, []); (ptrT.id Client.id, [("Audit"%go, Client__Auditⁱᵐᵖˡ); ("Get"%go, Client__Getⁱᵐᵖˡ); ("Put"%go, Client__Putⁱᵐᵖˡ); ("SelfMon"%go, Client__SelfMonⁱᵐᵖˡ)]); (nextVer.id, []); (ptrT.id nextVer.id, []); (epoch.id, []); (ptrT.id epoch.id, []); (serv.id, []); (ptrT.id serv.id, []); (Evid.id, []); (ptrT.id Evid.id, [("Check"%go, Evid__Checkⁱᵐᵖˡ)]); (evidVrf.id, []); (ptrT.id evidVrf.id, [("check"%go, evidVrf__checkⁱᵐᵖˡ)]); (evidLink.id, []); (ptrT.id evidLink.id, [("check"%go, evidLink__checkⁱᵐᵖˡ)])].

#[global] Instance info' : PkgInfo client.client :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [code.bytes.bytes; code.github_com.goose_lang.std.std; code.github_com.sanjit_bhat.pav.advrpc.advrpc; code.github_com.sanjit_bhat.pav.auditor.auditor; code.github_com.sanjit_bhat.pav.cryptoffi.cryptoffi; code.github_com.sanjit_bhat.pav.hashchain.hashchain; code.github_com.sanjit_bhat.pav.ktcore.ktcore; code.github_com.sanjit_bhat.pav.merkle.merkle; code.github_com.sanjit_bhat.pav.server.server];
  |}.

Definition initialize' : val :=
  λ: <>,
    package.init #client.client (λ: <>,
      exception_do (do:  (server.initialize' #());;;
      do:  (merkle.initialize' #());;;
      do:  (ktcore.initialize' #());;;
      do:  (hashchain.initialize' #());;;
      do:  (cryptoffi.initialize' #());;;
      do:  (auditor.initialize' #());;;
      do:  (advrpc.initialize' #());;;
      do:  (std.initialize' #());;;
      do:  (bytes.initialize' #());;;
      do:  (package.alloc client.client #()))
      ).

End code.
End client.
