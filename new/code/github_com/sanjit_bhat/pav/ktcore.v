(* autogenerated from github.com/sanjit-bhat/pav/ktcore *)
Require Export New.code.github_com.sanjit_bhat.pav.cryptoffi.
Require Export New.code.github_com.sanjit_bhat.pav.cryptoutil.
Require Export New.code.github_com.sanjit_bhat.pav.safemarshal.
Require Export New.code.github_com.tchajed.marshal.

From New.golang Require Import defn.
Definition ktcore : go_string := "github.com/sanjit-bhat/pav/ktcore".

Module ktcore.

Section code.
Context `{ffi_syntax}.


Definition Blameⁱᵐᵖˡ : go.type := go.uint64.

Definition BlameNone : val := #(W64 0).

Definition BlameServSig : val := #(W64 1).

Definition BlameServFull : val := #(W64 2).

Definition BlameAdtrSig : val := #(W64 4).

Definition BlameAdtrFull : val := #(W64 8).

Definition BlameClients : val := #(W64 16).

Definition BlameUnknown : val := #(W64 32).

Definition SignVrf : go_string := "github.com/sanjit-bhat/pav/ktcore.SignVrf"%go.

Definition VrfSigEncode : go_string := "github.com/sanjit-bhat/pav/ktcore.VrfSigEncode"%go.

Definition VrfSig : go.type := go.Named "github.com/sanjit-bhat/pav/ktcore.VrfSig"%go [].

Definition VrfSigTag : val := #(W8 0).

(* go: ktcore.go:36:6 *)
Definition SignVrfⁱᵐᵖˡ : val :=
  λ: "sk" "vrfPk",
    exception_do (let: "sig" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "vrfPk" := (go.AllocValue (go.SliceType go.byte) "vrfPk") in
    let: "sk" := (go.AllocValue (go.PointerType cryptoffi.SigPrivateKey) "sk") in
    let: "b" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := ((FuncResolve go.make3 [go.SliceType go.byte] #()) #(W64 0) ((1 +⟨go.untyped int⟩ 8) +⟨go.uint64⟩ cryptoffi.HashLen)) in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (go.AllocValue VrfSig (let: "$SigTag" := VrfSigTag in
    let: "$VrfPk" := (![go.SliceType go.byte] "vrfPk") in
    CompositeLiteral VrfSig (
      let: "$$vs" := go.StructElementListNil #() in 
      let: "$$vs" := go.ElementListApp "$$vs" "$SigTag" in
      let: "$$vs" := go.ElementListApp "$$vs" "$VrfPk" in
      "$$vs"
    ))) in
    (FuncResolve VrfSigEncode [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    (MethodResolve (go.PointerType cryptoffi.SigPrivateKey) Sign #() (![go.PointerType cryptoffi.SigPrivateKey] "sk")) "$a0") in
    do:  ("sig" <-[go.SliceType go.byte] "$r0");;;
    return: (![go.SliceType go.byte] "sig")).

Definition VerifyVrfSig : go_string := "github.com/sanjit-bhat/pav/ktcore.VerifyVrfSig"%go.

(* go: ktcore.go:44:6 *)
Definition VerifyVrfSigⁱᵐᵖˡ : val :=
  λ: "pk" "vrfPk" "sig",
    exception_do (let: "err" := (GoAlloc go.bool #()) in
    let: "sig" := (go.AllocValue (go.SliceType go.byte) "sig") in
    let: "vrfPk" := (go.AllocValue (go.SliceType go.byte) "vrfPk") in
    let: "pk" := (go.AllocValue cryptoffi.SigPublicKey "pk") in
    let: "b" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := ((FuncResolve go.make3 [go.SliceType go.byte] #()) #(W64 0) ((1 +⟨go.untyped int⟩ 8) +⟨go.uint64⟩ cryptoffi.HashLen)) in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (go.AllocValue VrfSig (let: "$SigTag" := VrfSigTag in
    let: "$VrfPk" := (![go.SliceType go.byte] "vrfPk") in
    CompositeLiteral VrfSig (
      let: "$$vs" := go.StructElementListNil #() in 
      let: "$$vs" := go.ElementListApp "$$vs" "$SigTag" in
      let: "$$vs" := go.ElementListApp "$$vs" "$VrfPk" in
      "$$vs"
    ))) in
    (FuncResolve VrfSigEncode [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    return: (let: "$a0" := (![go.SliceType go.byte] "b") in
     let: "$a1" := (![go.SliceType go.byte] "sig") in
     (MethodResolve cryptoffi.SigPublicKey Verify #() (![cryptoffi.SigPublicKey] "pk")) "$a0" "$a1")).

Definition SignLink : go_string := "github.com/sanjit-bhat/pav/ktcore.SignLink"%go.

Definition LinkSigEncode : go_string := "github.com/sanjit-bhat/pav/ktcore.LinkSigEncode"%go.

Definition LinkSig : go.type := go.Named "github.com/sanjit-bhat/pav/ktcore.LinkSig"%go [].

Definition LinkSigTag : val := #(W8 1).

(* go: ktcore.go:50:6 *)
Definition SignLinkⁱᵐᵖˡ : val :=
  λ: "sk" "epoch" "link",
    exception_do (let: "sig" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "link" := (go.AllocValue (go.SliceType go.byte) "link") in
    let: "epoch" := (go.AllocValue go.uint64 "epoch") in
    let: "sk" := (go.AllocValue (go.PointerType cryptoffi.SigPrivateKey) "sk") in
    let: "b" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := ((FuncResolve go.make3 [go.SliceType go.byte] #()) #(W64 0) (((1 +⟨go.untyped int⟩ 8) +⟨go.untyped int⟩ 8) +⟨go.uint64⟩ cryptoffi.HashLen)) in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (go.AllocValue LinkSig (let: "$SigTag" := LinkSigTag in
    let: "$Epoch" := (![go.uint64] "epoch") in
    let: "$Link" := (![go.SliceType go.byte] "link") in
    CompositeLiteral LinkSig (
      let: "$$vs" := go.StructElementListNil #() in 
      let: "$$vs" := go.ElementListApp "$$vs" "$SigTag" in
      let: "$$vs" := go.ElementListApp "$$vs" "$Epoch" in
      let: "$$vs" := go.ElementListApp "$$vs" "$Link" in
      "$$vs"
    ))) in
    (FuncResolve LinkSigEncode [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    (MethodResolve (go.PointerType cryptoffi.SigPrivateKey) Sign #() (![go.PointerType cryptoffi.SigPrivateKey] "sk")) "$a0") in
    do:  ("sig" <-[go.SliceType go.byte] "$r0");;;
    return: (![go.SliceType go.byte] "sig")).

Definition VerifyLinkSig : go_string := "github.com/sanjit-bhat/pav/ktcore.VerifyLinkSig"%go.

(* go: ktcore.go:58:6 *)
Definition VerifyLinkSigⁱᵐᵖˡ : val :=
  λ: "pk" "epoch" "link" "sig",
    exception_do (let: "err" := (GoAlloc go.bool #()) in
    let: "sig" := (go.AllocValue (go.SliceType go.byte) "sig") in
    let: "link" := (go.AllocValue (go.SliceType go.byte) "link") in
    let: "epoch" := (go.AllocValue go.uint64 "epoch") in
    let: "pk" := (go.AllocValue cryptoffi.SigPublicKey "pk") in
    let: "b" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := ((FuncResolve go.make3 [go.SliceType go.byte] #()) #(W64 0) (((1 +⟨go.untyped int⟩ 8) +⟨go.untyped int⟩ 8) +⟨go.uint64⟩ cryptoffi.HashLen)) in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (go.AllocValue LinkSig (let: "$SigTag" := LinkSigTag in
    let: "$Epoch" := (![go.uint64] "epoch") in
    let: "$Link" := (![go.SliceType go.byte] "link") in
    CompositeLiteral LinkSig (
      let: "$$vs" := go.StructElementListNil #() in 
      let: "$$vs" := go.ElementListApp "$$vs" "$SigTag" in
      let: "$$vs" := go.ElementListApp "$$vs" "$Epoch" in
      let: "$$vs" := go.ElementListApp "$$vs" "$Link" in
      "$$vs"
    ))) in
    (FuncResolve LinkSigEncode [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    return: (let: "$a0" := (![go.SliceType go.byte] "b") in
     let: "$a1" := (![go.SliceType go.byte] "sig") in
     (MethodResolve cryptoffi.SigPublicKey Verify #() (![cryptoffi.SigPublicKey] "pk")) "$a0" "$a1")).

Definition ProveMapLabel : go_string := "github.com/sanjit-bhat/pav/ktcore.ProveMapLabel"%go.

Definition MapLabelEncode : go_string := "github.com/sanjit-bhat/pav/ktcore.MapLabelEncode"%go.

Definition MapLabel : go.type := go.Named "github.com/sanjit-bhat/pav/ktcore.MapLabel"%go [].

(* go: ktcore.go:64:6 *)
Definition ProveMapLabelⁱᵐᵖˡ : val :=
  λ: "sk" "uid" "ver",
    exception_do (let: "proof" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "label" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "ver" := (go.AllocValue go.uint64 "ver") in
    let: "uid" := (go.AllocValue go.uint64 "uid") in
    let: "sk" := (go.AllocValue (go.PointerType cryptoffi.VrfPrivateKey) "sk") in
    let: "b" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := ((FuncResolve go.make3 [go.SliceType go.byte] #()) #(W64 0) #(W64 16)) in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (go.AllocValue MapLabel (let: "$Uid" := (![go.uint64] "uid") in
    let: "$Ver" := (![go.uint64] "ver") in
    CompositeLiteral MapLabel (
      let: "$$vs" := go.StructElementListNil #() in 
      let: "$$vs" := go.ElementListApp "$$vs" "$Uid" in
      let: "$$vs" := go.ElementListApp "$$vs" "$Ver" in
      "$$vs"
    ))) in
    (FuncResolve MapLabelEncode [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: ("$ret0", "$ret1") := ((let: "$a0" := (![go.SliceType go.byte] "b") in
    (MethodResolve (go.PointerType cryptoffi.VrfPrivateKey) Prove #() (![go.PointerType cryptoffi.VrfPrivateKey] "sk")) "$a0")) in
    return: ("$ret0", "$ret1")).

Definition EvalMapLabel : go_string := "github.com/sanjit-bhat/pav/ktcore.EvalMapLabel"%go.

(* go: ktcore.go:70:6 *)
Definition EvalMapLabelⁱᵐᵖˡ : val :=
  λ: "sk" "uid" "ver",
    exception_do (let: "label" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "ver" := (go.AllocValue go.uint64 "ver") in
    let: "uid" := (go.AllocValue go.uint64 "uid") in
    let: "sk" := (go.AllocValue (go.PointerType cryptoffi.VrfPrivateKey) "sk") in
    let: "b" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := ((FuncResolve go.make3 [go.SliceType go.byte] #()) #(W64 0) #(W64 16)) in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (go.AllocValue MapLabel (let: "$Uid" := (![go.uint64] "uid") in
    let: "$Ver" := (![go.uint64] "ver") in
    CompositeLiteral MapLabel (
      let: "$$vs" := go.StructElementListNil #() in 
      let: "$$vs" := go.ElementListApp "$$vs" "$Uid" in
      let: "$$vs" := go.ElementListApp "$$vs" "$Ver" in
      "$$vs"
    ))) in
    (FuncResolve MapLabelEncode [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    return: (let: "$a0" := (![go.SliceType go.byte] "b") in
     (MethodResolve (go.PointerType cryptoffi.VrfPrivateKey) Evaluate #() (![go.PointerType cryptoffi.VrfPrivateKey] "sk")) "$a0")).

Definition CheckMapLabel : go_string := "github.com/sanjit-bhat/pav/ktcore.CheckMapLabel"%go.

(* go: ktcore.go:76:6 *)
Definition CheckMapLabelⁱᵐᵖˡ : val :=
  λ: "pk" "uid" "ver" "proof",
    exception_do (let: "err" := (GoAlloc go.bool #()) in
    let: "label" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "proof" := (go.AllocValue (go.SliceType go.byte) "proof") in
    let: "ver" := (go.AllocValue go.uint64 "ver") in
    let: "uid" := (go.AllocValue go.uint64 "uid") in
    let: "pk" := (go.AllocValue (go.PointerType cryptoffi.VrfPublicKey) "pk") in
    let: "b" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := ((FuncResolve go.make3 [go.SliceType go.byte] #()) #(W64 0) #(W64 16)) in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (go.AllocValue MapLabel (let: "$Uid" := (![go.uint64] "uid") in
    let: "$Ver" := (![go.uint64] "ver") in
    CompositeLiteral MapLabel (
      let: "$$vs" := go.StructElementListNil #() in 
      let: "$$vs" := go.ElementListApp "$$vs" "$Uid" in
      let: "$$vs" := go.ElementListApp "$$vs" "$Ver" in
      "$$vs"
    ))) in
    (FuncResolve MapLabelEncode [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: ("$ret0", "$ret1") := ((let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (![go.SliceType go.byte] "proof") in
    (MethodResolve (go.PointerType cryptoffi.VrfPublicKey) Verify #() (![go.PointerType cryptoffi.VrfPublicKey] "pk")) "$a0" "$a1")) in
    return: ("$ret0", "$ret1")).

Definition GetMapVal : go_string := "github.com/sanjit-bhat/pav/ktcore.GetMapVal"%go.

Definition CommitOpenEncode : go_string := "github.com/sanjit-bhat/pav/ktcore.CommitOpenEncode"%go.

Definition CommitOpen : go.type := go.Named "github.com/sanjit-bhat/pav/ktcore.CommitOpen"%go [].

(* go: ktcore.go:82:6 *)
Definition GetMapValⁱᵐᵖˡ : val :=
  λ: "pkOpen",
    exception_do (let: "val" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "pkOpen" := (go.AllocValue (go.PointerType CommitOpen) "pkOpen") in
    let: "b" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := (let: "$a0" := #slice.nil in
    let: "$a1" := (![go.PointerType CommitOpen] "pkOpen") in
    (FuncResolve CommitOpenEncode [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    return: (let: "$a0" := (![go.SliceType go.byte] "b") in
     (FuncResolve cryptoutil.Hash [] #()) "$a0")).

Definition GetCommitRand : go_string := "github.com/sanjit-bhat/pav/ktcore.GetCommitRand"%go.

(* GetCommitRand computes the psuedo-random (wrt commitSecret) bits
   used in a mapVal commitment.

   go: ktcore.go:89:6 *)
Definition GetCommitRandⁱᵐᵖˡ : val :=
  λ: "commitSecret" "label",
    exception_do (let: "rand" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "label" := (go.AllocValue (go.SliceType go.byte) "label") in
    let: "commitSecret" := (go.AllocValue (go.SliceType go.byte) "commitSecret") in
    let: "hr" := (GoAlloc (go.PointerType cryptoffi.Hasher) #()) in
    let: "$r0" := ((FuncResolve cryptoffi.NewHasher [] #()) #()) in
    do:  ("hr" <-[go.PointerType cryptoffi.Hasher] "$r0");;;
    do:  (let: "$a0" := (![go.SliceType go.byte] "commitSecret") in
    (MethodResolve (go.PointerType cryptoffi.Hasher) Write #() (![go.PointerType cryptoffi.Hasher] "hr")) "$a0");;;
    do:  (let: "$a0" := (![go.SliceType go.byte] "label") in
    (MethodResolve (go.PointerType cryptoffi.Hasher) Write #() (![go.PointerType cryptoffi.Hasher] "hr")) "$a0");;;
    return: (let: "$a0" := #slice.nil in
     (MethodResolve (go.PointerType cryptoffi.Hasher) Sum #() (![go.PointerType cryptoffi.Hasher] "hr")) "$a0")).

Definition VrfSigⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "SigTag"%go go.byte);
  (go.FieldDecl "VrfPk"%go (go.SliceType go.byte))
].

Definition LinkSigⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "SigTag"%go go.byte);
  (go.FieldDecl "Epoch"%go go.uint64);
  (go.FieldDecl "Link"%go (go.SliceType go.byte))
].

Definition MapLabelⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "Uid"%go go.uint64);
  (go.FieldDecl "Ver"%go go.uint64)
].

Definition CommitOpenⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "Val"%go (go.SliceType go.byte));
  (go.FieldDecl "Rand"%go (go.SliceType go.byte))
].

Definition Membⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "LabelProof"%go (go.SliceType go.byte));
  (go.FieldDecl "PkOpen"%go (go.PointerType CommitOpen));
  (go.FieldDecl "MerkleProof"%go (go.SliceType go.byte))
].

Definition NonMembⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "LabelProof"%go (go.SliceType go.byte));
  (go.FieldDecl "MerkleProof"%go (go.SliceType go.byte))
].

Definition UpdateProof : go.type := go.Named "github.com/sanjit-bhat/pav/ktcore.UpdateProof"%go [].

Definition AuditProofⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "Updates"%go (go.SliceType (go.PointerType UpdateProof)));
  (go.FieldDecl "LinkSig"%go (go.SliceType go.byte))
].

Definition UpdateProofⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "MapLabel"%go (go.SliceType go.byte));
  (go.FieldDecl "MapVal"%go (go.SliceType go.byte));
  (go.FieldDecl "NonMembProof"%go (go.SliceType go.byte))
].

(* go: serde.out.go:10:6 *)
Definition VrfSigEncodeⁱᵐᵖˡ : val :=
  λ: "b0" "o",
    exception_do (let: "o" := (go.AllocValue (go.PointerType VrfSig) "o") in
    let: "b0" := (go.AllocValue (go.SliceType go.byte) "b0") in
    let: "b" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := (![go.SliceType go.byte] "b0") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (![go.byte] (StructFieldRef VrfSig "SigTag"%go (![go.PointerType VrfSig] "o"))) in
    (FuncResolve safemarshal.WriteByte [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (![go.SliceType go.byte] (StructFieldRef VrfSig "VrfPk"%go (![go.PointerType VrfSig] "o"))) in
    (FuncResolve safemarshal.WriteSlice1D [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    return: (![go.SliceType go.byte] "b")).

Definition VrfSigDecode : go_string := "github.com/sanjit-bhat/pav/ktcore.VrfSigDecode"%go.

(* go: serde.out.go:16:6 *)
Definition VrfSigDecodeⁱᵐᵖˡ : val :=
  λ: "b0",
    exception_do (let: "b0" := (go.AllocValue (go.SliceType go.byte) "b0") in
    let: "err1" := (GoAlloc go.bool #()) in
    let: "b1" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "a1" := (GoAlloc go.byte #()) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "b0") in
    (FuncResolve safemarshal.ReadByte [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a1" <-[go.byte] "$r0");;;
    do:  ("b1" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err1" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err1"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err2" := (GoAlloc go.bool #()) in
    let: "b2" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "a2" := (GoAlloc (go.SliceType go.byte) #()) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "b1") in
    (FuncResolve safemarshal.ReadSlice1D [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a2" <-[go.SliceType go.byte] "$r0");;;
    do:  ("b2" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err2" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err2"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    return: (go.AllocValue VrfSig (let: "$SigTag" := (![go.byte] "a1") in
     let: "$VrfPk" := (![go.SliceType go.byte] "a2") in
     CompositeLiteral VrfSig (
       let: "$$vs" := go.StructElementListNil #() in 
       let: "$$vs" := go.ElementListApp "$$vs" "$SigTag" in
       let: "$$vs" := go.ElementListApp "$$vs" "$VrfPk" in
       "$$vs"
     )), ![go.SliceType go.byte] "b2", #false)).

(* go: serde.out.go:27:6 *)
Definition LinkSigEncodeⁱᵐᵖˡ : val :=
  λ: "b0" "o",
    exception_do (let: "o" := (go.AllocValue (go.PointerType LinkSig) "o") in
    let: "b0" := (go.AllocValue (go.SliceType go.byte) "b0") in
    let: "b" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := (![go.SliceType go.byte] "b0") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (![go.byte] (StructFieldRef LinkSig "SigTag"%go (![go.PointerType LinkSig] "o"))) in
    (FuncResolve safemarshal.WriteByte [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (![go.uint64] (StructFieldRef LinkSig "Epoch"%go (![go.PointerType LinkSig] "o"))) in
    (FuncResolve marshal.WriteInt [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (![go.SliceType go.byte] (StructFieldRef LinkSig "Link"%go (![go.PointerType LinkSig] "o"))) in
    (FuncResolve safemarshal.WriteSlice1D [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    return: (![go.SliceType go.byte] "b")).

Definition LinkSigDecode : go_string := "github.com/sanjit-bhat/pav/ktcore.LinkSigDecode"%go.

(* go: serde.out.go:34:6 *)
Definition LinkSigDecodeⁱᵐᵖˡ : val :=
  λ: "b0",
    exception_do (let: "b0" := (go.AllocValue (go.SliceType go.byte) "b0") in
    let: "err1" := (GoAlloc go.bool #()) in
    let: "b1" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "a1" := (GoAlloc go.byte #()) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "b0") in
    (FuncResolve safemarshal.ReadByte [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a1" <-[go.byte] "$r0");;;
    do:  ("b1" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err1" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err1"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err2" := (GoAlloc go.bool #()) in
    let: "b2" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "a2" := (GoAlloc go.uint64 #()) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "b1") in
    (FuncResolve safemarshal.ReadInt [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a2" <-[go.uint64] "$r0");;;
    do:  ("b2" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err2" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err2"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err3" := (GoAlloc go.bool #()) in
    let: "b3" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "a3" := (GoAlloc (go.SliceType go.byte) #()) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "b2") in
    (FuncResolve safemarshal.ReadSlice1D [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a3" <-[go.SliceType go.byte] "$r0");;;
    do:  ("b3" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err3" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err3"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    return: (go.AllocValue LinkSig (let: "$SigTag" := (![go.byte] "a1") in
     let: "$Epoch" := (![go.uint64] "a2") in
     let: "$Link" := (![go.SliceType go.byte] "a3") in
     CompositeLiteral LinkSig (
       let: "$$vs" := go.StructElementListNil #() in 
       let: "$$vs" := go.ElementListApp "$$vs" "$SigTag" in
       let: "$$vs" := go.ElementListApp "$$vs" "$Epoch" in
       let: "$$vs" := go.ElementListApp "$$vs" "$Link" in
       "$$vs"
     )), ![go.SliceType go.byte] "b3", #false)).

(* go: serde.out.go:49:6 *)
Definition MapLabelEncodeⁱᵐᵖˡ : val :=
  λ: "b0" "o",
    exception_do (let: "o" := (go.AllocValue (go.PointerType MapLabel) "o") in
    let: "b0" := (go.AllocValue (go.SliceType go.byte) "b0") in
    let: "b" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := (![go.SliceType go.byte] "b0") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (![go.uint64] (StructFieldRef MapLabel "Uid"%go (![go.PointerType MapLabel] "o"))) in
    (FuncResolve marshal.WriteInt [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (![go.uint64] (StructFieldRef MapLabel "Ver"%go (![go.PointerType MapLabel] "o"))) in
    (FuncResolve marshal.WriteInt [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    return: (![go.SliceType go.byte] "b")).

Definition MapLabelDecode : go_string := "github.com/sanjit-bhat/pav/ktcore.MapLabelDecode"%go.

(* go: serde.out.go:55:6 *)
Definition MapLabelDecodeⁱᵐᵖˡ : val :=
  λ: "b0",
    exception_do (let: "b0" := (go.AllocValue (go.SliceType go.byte) "b0") in
    let: "err1" := (GoAlloc go.bool #()) in
    let: "b1" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "a1" := (GoAlloc go.uint64 #()) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "b0") in
    (FuncResolve safemarshal.ReadInt [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a1" <-[go.uint64] "$r0");;;
    do:  ("b1" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err1" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err1"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err2" := (GoAlloc go.bool #()) in
    let: "b2" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "a2" := (GoAlloc go.uint64 #()) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "b1") in
    (FuncResolve safemarshal.ReadInt [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a2" <-[go.uint64] "$r0");;;
    do:  ("b2" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err2" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err2"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    return: (go.AllocValue MapLabel (let: "$Uid" := (![go.uint64] "a1") in
     let: "$Ver" := (![go.uint64] "a2") in
     CompositeLiteral MapLabel (
       let: "$$vs" := go.StructElementListNil #() in 
       let: "$$vs" := go.ElementListApp "$$vs" "$Uid" in
       let: "$$vs" := go.ElementListApp "$$vs" "$Ver" in
       "$$vs"
     )), ![go.SliceType go.byte] "b2", #false)).

(* go: serde.out.go:66:6 *)
Definition CommitOpenEncodeⁱᵐᵖˡ : val :=
  λ: "b0" "o",
    exception_do (let: "o" := (go.AllocValue (go.PointerType CommitOpen) "o") in
    let: "b0" := (go.AllocValue (go.SliceType go.byte) "b0") in
    let: "b" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := (![go.SliceType go.byte] "b0") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (![go.SliceType go.byte] (StructFieldRef CommitOpen "Val"%go (![go.PointerType CommitOpen] "o"))) in
    (FuncResolve safemarshal.WriteSlice1D [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (![go.SliceType go.byte] (StructFieldRef CommitOpen "Rand"%go (![go.PointerType CommitOpen] "o"))) in
    (FuncResolve safemarshal.WriteSlice1D [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    return: (![go.SliceType go.byte] "b")).

Definition CommitOpenDecode : go_string := "github.com/sanjit-bhat/pav/ktcore.CommitOpenDecode"%go.

(* go: serde.out.go:72:6 *)
Definition CommitOpenDecodeⁱᵐᵖˡ : val :=
  λ: "b0",
    exception_do (let: "b0" := (go.AllocValue (go.SliceType go.byte) "b0") in
    let: "err1" := (GoAlloc go.bool #()) in
    let: "b1" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "a1" := (GoAlloc (go.SliceType go.byte) #()) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "b0") in
    (FuncResolve safemarshal.ReadSlice1D [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a1" <-[go.SliceType go.byte] "$r0");;;
    do:  ("b1" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err1" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err1"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err2" := (GoAlloc go.bool #()) in
    let: "b2" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "a2" := (GoAlloc (go.SliceType go.byte) #()) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "b1") in
    (FuncResolve safemarshal.ReadSlice1D [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a2" <-[go.SliceType go.byte] "$r0");;;
    do:  ("b2" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err2" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err2"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    return: (go.AllocValue CommitOpen (let: "$Val" := (![go.SliceType go.byte] "a1") in
     let: "$Rand" := (![go.SliceType go.byte] "a2") in
     CompositeLiteral CommitOpen (
       let: "$$vs" := go.StructElementListNil #() in 
       let: "$$vs" := go.ElementListApp "$$vs" "$Val" in
       let: "$$vs" := go.ElementListApp "$$vs" "$Rand" in
       "$$vs"
     )), ![go.SliceType go.byte] "b2", #false)).

Definition MembEncode : go_string := "github.com/sanjit-bhat/pav/ktcore.MembEncode"%go.

Definition Memb : go.type := go.Named "github.com/sanjit-bhat/pav/ktcore.Memb"%go [].

(* go: serde.out.go:83:6 *)
Definition MembEncodeⁱᵐᵖˡ : val :=
  λ: "b0" "o",
    exception_do (let: "o" := (go.AllocValue (go.PointerType Memb) "o") in
    let: "b0" := (go.AllocValue (go.SliceType go.byte) "b0") in
    let: "b" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := (![go.SliceType go.byte] "b0") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (![go.SliceType go.byte] (StructFieldRef Memb "LabelProof"%go (![go.PointerType Memb] "o"))) in
    (FuncResolve safemarshal.WriteSlice1D [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (![go.PointerType CommitOpen] (StructFieldRef Memb "PkOpen"%go (![go.PointerType Memb] "o"))) in
    (FuncResolve CommitOpenEncode [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (![go.SliceType go.byte] (StructFieldRef Memb "MerkleProof"%go (![go.PointerType Memb] "o"))) in
    (FuncResolve safemarshal.WriteSlice1D [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    return: (![go.SliceType go.byte] "b")).

Definition MembDecode : go_string := "github.com/sanjit-bhat/pav/ktcore.MembDecode"%go.

(* go: serde.out.go:90:6 *)
Definition MembDecodeⁱᵐᵖˡ : val :=
  λ: "b0",
    exception_do (let: "b0" := (go.AllocValue (go.SliceType go.byte) "b0") in
    let: "err1" := (GoAlloc go.bool #()) in
    let: "b1" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "a1" := (GoAlloc (go.SliceType go.byte) #()) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "b0") in
    (FuncResolve safemarshal.ReadSlice1D [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a1" <-[go.SliceType go.byte] "$r0");;;
    do:  ("b1" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err1" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err1"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err2" := (GoAlloc go.bool #()) in
    let: "b2" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "a2" := (GoAlloc (go.PointerType CommitOpen) #()) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "b1") in
    (FuncResolve CommitOpenDecode [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a2" <-[go.PointerType CommitOpen] "$r0");;;
    do:  ("b2" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err2" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err2"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err3" := (GoAlloc go.bool #()) in
    let: "b3" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "a3" := (GoAlloc (go.SliceType go.byte) #()) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "b2") in
    (FuncResolve safemarshal.ReadSlice1D [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a3" <-[go.SliceType go.byte] "$r0");;;
    do:  ("b3" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err3" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err3"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    return: (go.AllocValue Memb (let: "$LabelProof" := (![go.SliceType go.byte] "a1") in
     let: "$PkOpen" := (![go.PointerType CommitOpen] "a2") in
     let: "$MerkleProof" := (![go.SliceType go.byte] "a3") in
     CompositeLiteral Memb (
       let: "$$vs" := go.StructElementListNil #() in 
       let: "$$vs" := go.ElementListApp "$$vs" "$LabelProof" in
       let: "$$vs" := go.ElementListApp "$$vs" "$PkOpen" in
       let: "$$vs" := go.ElementListApp "$$vs" "$MerkleProof" in
       "$$vs"
     )), ![go.SliceType go.byte] "b3", #false)).

Definition NonMembEncode : go_string := "github.com/sanjit-bhat/pav/ktcore.NonMembEncode"%go.

Definition NonMemb : go.type := go.Named "github.com/sanjit-bhat/pav/ktcore.NonMemb"%go [].

(* go: serde.out.go:105:6 *)
Definition NonMembEncodeⁱᵐᵖˡ : val :=
  λ: "b0" "o",
    exception_do (let: "o" := (go.AllocValue (go.PointerType NonMemb) "o") in
    let: "b0" := (go.AllocValue (go.SliceType go.byte) "b0") in
    let: "b" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := (![go.SliceType go.byte] "b0") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (![go.SliceType go.byte] (StructFieldRef NonMemb "LabelProof"%go (![go.PointerType NonMemb] "o"))) in
    (FuncResolve safemarshal.WriteSlice1D [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (![go.SliceType go.byte] (StructFieldRef NonMemb "MerkleProof"%go (![go.PointerType NonMemb] "o"))) in
    (FuncResolve safemarshal.WriteSlice1D [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    return: (![go.SliceType go.byte] "b")).

Definition NonMembDecode : go_string := "github.com/sanjit-bhat/pav/ktcore.NonMembDecode"%go.

(* go: serde.out.go:111:6 *)
Definition NonMembDecodeⁱᵐᵖˡ : val :=
  λ: "b0",
    exception_do (let: "b0" := (go.AllocValue (go.SliceType go.byte) "b0") in
    let: "err1" := (GoAlloc go.bool #()) in
    let: "b1" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "a1" := (GoAlloc (go.SliceType go.byte) #()) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "b0") in
    (FuncResolve safemarshal.ReadSlice1D [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a1" <-[go.SliceType go.byte] "$r0");;;
    do:  ("b1" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err1" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err1"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err2" := (GoAlloc go.bool #()) in
    let: "b2" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "a2" := (GoAlloc (go.SliceType go.byte) #()) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "b1") in
    (FuncResolve safemarshal.ReadSlice1D [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a2" <-[go.SliceType go.byte] "$r0");;;
    do:  ("b2" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err2" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err2"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    return: (go.AllocValue NonMemb (let: "$LabelProof" := (![go.SliceType go.byte] "a1") in
     let: "$MerkleProof" := (![go.SliceType go.byte] "a2") in
     CompositeLiteral NonMemb (
       let: "$$vs" := go.StructElementListNil #() in 
       let: "$$vs" := go.ElementListApp "$$vs" "$LabelProof" in
       let: "$$vs" := go.ElementListApp "$$vs" "$MerkleProof" in
       "$$vs"
     )), ![go.SliceType go.byte] "b2", #false)).

Definition AuditProofEncode : go_string := "github.com/sanjit-bhat/pav/ktcore.AuditProofEncode"%go.

Definition AuditProof : go.type := go.Named "github.com/sanjit-bhat/pav/ktcore.AuditProof"%go [].

Definition UpdateProofSlice1DEncode : go_string := "github.com/sanjit-bhat/pav/ktcore.UpdateProofSlice1DEncode"%go.

(* go: serde.out.go:122:6 *)
Definition AuditProofEncodeⁱᵐᵖˡ : val :=
  λ: "b0" "o",
    exception_do (let: "o" := (go.AllocValue (go.PointerType AuditProof) "o") in
    let: "b0" := (go.AllocValue (go.SliceType go.byte) "b0") in
    let: "b" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := (![go.SliceType go.byte] "b0") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (![go.SliceType (go.PointerType UpdateProof)] (StructFieldRef AuditProof "Updates"%go (![go.PointerType AuditProof] "o"))) in
    (FuncResolve UpdateProofSlice1DEncode [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (![go.SliceType go.byte] (StructFieldRef AuditProof "LinkSig"%go (![go.PointerType AuditProof] "o"))) in
    (FuncResolve safemarshal.WriteSlice1D [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    return: (![go.SliceType go.byte] "b")).

Definition AuditProofDecode : go_string := "github.com/sanjit-bhat/pav/ktcore.AuditProofDecode"%go.

Definition UpdateProofSlice1DDecode : go_string := "github.com/sanjit-bhat/pav/ktcore.UpdateProofSlice1DDecode"%go.

(* go: serde.out.go:128:6 *)
Definition AuditProofDecodeⁱᵐᵖˡ : val :=
  λ: "b0",
    exception_do (let: "b0" := (go.AllocValue (go.SliceType go.byte) "b0") in
    let: "err1" := (GoAlloc go.bool #()) in
    let: "b1" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "a1" := (GoAlloc (go.SliceType (go.PointerType UpdateProof)) #()) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "b0") in
    (FuncResolve UpdateProofSlice1DDecode [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a1" <-[go.SliceType (go.PointerType UpdateProof)] "$r0");;;
    do:  ("b1" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err1" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err1"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err2" := (GoAlloc go.bool #()) in
    let: "b2" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "a2" := (GoAlloc (go.SliceType go.byte) #()) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "b1") in
    (FuncResolve safemarshal.ReadSlice1D [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a2" <-[go.SliceType go.byte] "$r0");;;
    do:  ("b2" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err2" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err2"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    return: (go.AllocValue AuditProof (let: "$Updates" := (![go.SliceType (go.PointerType UpdateProof)] "a1") in
     let: "$LinkSig" := (![go.SliceType go.byte] "a2") in
     CompositeLiteral AuditProof (
       let: "$$vs" := go.StructElementListNil #() in 
       let: "$$vs" := go.ElementListApp "$$vs" "$Updates" in
       let: "$$vs" := go.ElementListApp "$$vs" "$LinkSig" in
       "$$vs"
     )), ![go.SliceType go.byte] "b2", #false)).

Definition UpdateProofEncode : go_string := "github.com/sanjit-bhat/pav/ktcore.UpdateProofEncode"%go.

(* go: serde.out.go:139:6 *)
Definition UpdateProofEncodeⁱᵐᵖˡ : val :=
  λ: "b0" "o",
    exception_do (let: "o" := (go.AllocValue (go.PointerType UpdateProof) "o") in
    let: "b0" := (go.AllocValue (go.SliceType go.byte) "b0") in
    let: "b" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := (![go.SliceType go.byte] "b0") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (![go.SliceType go.byte] (StructFieldRef UpdateProof "MapLabel"%go (![go.PointerType UpdateProof] "o"))) in
    (FuncResolve safemarshal.WriteSlice1D [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (![go.SliceType go.byte] (StructFieldRef UpdateProof "MapVal"%go (![go.PointerType UpdateProof] "o"))) in
    (FuncResolve safemarshal.WriteSlice1D [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (![go.SliceType go.byte] (StructFieldRef UpdateProof "NonMembProof"%go (![go.PointerType UpdateProof] "o"))) in
    (FuncResolve safemarshal.WriteSlice1D [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    return: (![go.SliceType go.byte] "b")).

Definition UpdateProofDecode : go_string := "github.com/sanjit-bhat/pav/ktcore.UpdateProofDecode"%go.

(* go: serde.out.go:146:6 *)
Definition UpdateProofDecodeⁱᵐᵖˡ : val :=
  λ: "b0",
    exception_do (let: "b0" := (go.AllocValue (go.SliceType go.byte) "b0") in
    let: "err1" := (GoAlloc go.bool #()) in
    let: "b1" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "a1" := (GoAlloc (go.SliceType go.byte) #()) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "b0") in
    (FuncResolve safemarshal.ReadSlice1D [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a1" <-[go.SliceType go.byte] "$r0");;;
    do:  ("b1" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err1" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err1"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err2" := (GoAlloc go.bool #()) in
    let: "b2" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "a2" := (GoAlloc (go.SliceType go.byte) #()) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "b1") in
    (FuncResolve safemarshal.ReadSlice1D [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a2" <-[go.SliceType go.byte] "$r0");;;
    do:  ("b2" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err2" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err2"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err3" := (GoAlloc go.bool #()) in
    let: "b3" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "a3" := (GoAlloc (go.SliceType go.byte) #()) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "b2") in
    (FuncResolve safemarshal.ReadSlice1D [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a3" <-[go.SliceType go.byte] "$r0");;;
    do:  ("b3" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err3" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err3"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    return: (go.AllocValue UpdateProof (let: "$MapLabel" := (![go.SliceType go.byte] "a1") in
     let: "$MapVal" := (![go.SliceType go.byte] "a2") in
     let: "$NonMembProof" := (![go.SliceType go.byte] "a3") in
     CompositeLiteral UpdateProof (
       let: "$$vs" := go.StructElementListNil #() in 
       let: "$$vs" := go.ElementListApp "$$vs" "$MapLabel" in
       let: "$$vs" := go.ElementListApp "$$vs" "$MapVal" in
       let: "$$vs" := go.ElementListApp "$$vs" "$NonMembProof" in
       "$$vs"
     )), ![go.SliceType go.byte] "b3", #false)).

(* go: serde_misc.go:8:6 *)
Definition UpdateProofSlice1DEncodeⁱᵐᵖˡ : val :=
  λ: "b0" "o",
    exception_do (let: "o" := (go.AllocValue (go.SliceType (go.PointerType UpdateProof)) "o") in
    let: "b0" := (go.AllocValue (go.SliceType go.byte) "b0") in
    let: "b" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := (![go.SliceType go.byte] "b0") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (s_to_w64 (let: "$a0" := (![go.SliceType (go.PointerType UpdateProof)] "o") in
    (FuncResolve go.len [go.SliceType (go.PointerType UpdateProof)] #()) "$a0")) in
    (FuncResolve marshal.WriteInt [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$range" := (![go.SliceType (go.PointerType UpdateProof)] "o") in
    (let: "e" := (GoAlloc (go.PointerType UpdateProof) #()) in
    slice.for_range (go.PointerType UpdateProof) "$range" (λ: "$key" "$value",
      do:  ("e" <-[go.PointerType UpdateProof] "$value");;;
      do:  "$key";;;
      let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
      let: "$a1" := (![go.PointerType UpdateProof] "e") in
      (FuncResolve UpdateProofEncode [] #()) "$a0" "$a1") in
      do:  ("b" <-[go.SliceType go.byte] "$r0")));;;
    return: (![go.SliceType go.byte] "b")).

(* go: serde_misc.go:17:6 *)
Definition UpdateProofSlice1DDecodeⁱᵐᵖˡ : val :=
  λ: "b0",
    exception_do (let: "b0" := (go.AllocValue (go.SliceType go.byte) "b0") in
    let: "err1" := (GoAlloc go.bool #()) in
    let: "b1" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "length" := (GoAlloc go.uint64 #()) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "b0") in
    (FuncResolve safemarshal.ReadInt [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("length" <-[go.uint64] "$r0");;;
    do:  ("b1" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err1" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err1"
    then return: (#slice.nil, #slice.nil, #true)
    else do:  #());;;
    let: "loopO" := (GoAlloc (go.SliceType (go.PointerType UpdateProof)) #()) in
    let: "$r0" := ((FuncResolve go.make3 [go.SliceType (go.PointerType UpdateProof)] #()) #(W64 0) (![go.uint64] "length")) in
    do:  ("loopO" <-[go.SliceType (go.PointerType UpdateProof)] "$r0");;;
    let: "loopErr" := (GoAlloc go.bool #()) in
    let: "loopB" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := (![go.SliceType go.byte] "b1") in
    do:  ("loopB" <-[go.SliceType go.byte] "$r0");;;
    (let: "i" := (GoAlloc go.uint64 #()) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, (![go.uint64] "i") <⟨go.uint64⟩ (![go.uint64] "length")); (λ: <>, do:  ("i" <-[go.uint64] ((![go.uint64] "i") +⟨go.uint64⟩ #(W8 1)))) := λ: <>,
      let: "err2" := (GoAlloc go.bool #()) in
      let: "loopB1" := (GoAlloc (go.SliceType go.byte) #()) in
      let: "a2" := (GoAlloc (go.PointerType UpdateProof) #()) in
      let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "loopB") in
      (FuncResolve UpdateProofDecode [] #()) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      let: "$r2" := "$ret2" in
      do:  ("a2" <-[go.PointerType UpdateProof] "$r0");;;
      do:  ("loopB1" <-[go.SliceType go.byte] "$r1");;;
      do:  ("err2" <-[go.bool] "$r2");;;
      let: "$r0" := (![go.SliceType go.byte] "loopB1") in
      do:  ("loopB" <-[go.SliceType go.byte] "$r0");;;
      (if: ![go.bool] "err2"
      then
        let: "$r0" := #true in
        do:  ("loopErr" <-[go.bool] "$r0");;;
        break: #()
      else do:  #());;;
      let: "$r0" := (let: "$a0" := (![go.SliceType (go.PointerType UpdateProof)] "loopO") in
      let: "$a1" := ((let: "$sl0" := (![go.PointerType UpdateProof] "a2") in
      CompositeLiteral (go.PointerType UpdateProof) (go.PointerType UpdateProof) ["$sl0"])) in
      (FuncResolve go.append [go.SliceType (go.PointerType UpdateProof)] #()) "$a0" "$a1") in
      do:  ("loopO" <-[go.SliceType (go.PointerType UpdateProof)] "$r0")));;;
    (if: ![go.bool] "loopErr"
    then return: (#slice.nil, #slice.nil, #true)
    else do:  #());;;
    return: (![go.SliceType (go.PointerType UpdateProof)] "loopO", ![go.SliceType go.byte] "loopB", #false)).

Definition MembSlice1DEncode : go_string := "github.com/sanjit-bhat/pav/ktcore.MembSlice1DEncode"%go.

(* go: serde_misc.go:40:6 *)
Definition MembSlice1DEncodeⁱᵐᵖˡ : val :=
  λ: "b0" "o",
    exception_do (let: "o" := (go.AllocValue (go.SliceType (go.PointerType Memb)) "o") in
    let: "b0" := (go.AllocValue (go.SliceType go.byte) "b0") in
    let: "b" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := (![go.SliceType go.byte] "b0") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (s_to_w64 (let: "$a0" := (![go.SliceType (go.PointerType Memb)] "o") in
    (FuncResolve go.len [go.SliceType (go.PointerType Memb)] #()) "$a0")) in
    (FuncResolve marshal.WriteInt [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$range" := (![go.SliceType (go.PointerType Memb)] "o") in
    (let: "e" := (GoAlloc (go.PointerType Memb) #()) in
    slice.for_range (go.PointerType Memb) "$range" (λ: "$key" "$value",
      do:  ("e" <-[go.PointerType Memb] "$value");;;
      do:  "$key";;;
      let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
      let: "$a1" := (![go.PointerType Memb] "e") in
      (FuncResolve MembEncode [] #()) "$a0" "$a1") in
      do:  ("b" <-[go.SliceType go.byte] "$r0")));;;
    return: (![go.SliceType go.byte] "b")).

Definition MembSlice1DDecode : go_string := "github.com/sanjit-bhat/pav/ktcore.MembSlice1DDecode"%go.

(* go: serde_misc.go:49:6 *)
Definition MembSlice1DDecodeⁱᵐᵖˡ : val :=
  λ: "b0",
    exception_do (let: "b0" := (go.AllocValue (go.SliceType go.byte) "b0") in
    let: "err1" := (GoAlloc go.bool #()) in
    let: "b1" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "length" := (GoAlloc go.uint64 #()) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "b0") in
    (FuncResolve safemarshal.ReadInt [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("length" <-[go.uint64] "$r0");;;
    do:  ("b1" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err1" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err1"
    then return: (#slice.nil, #slice.nil, #true)
    else do:  #());;;
    let: "loopO" := (GoAlloc (go.SliceType (go.PointerType Memb)) #()) in
    let: "$r0" := ((FuncResolve go.make3 [go.SliceType (go.PointerType Memb)] #()) #(W64 0) (![go.uint64] "length")) in
    do:  ("loopO" <-[go.SliceType (go.PointerType Memb)] "$r0");;;
    let: "loopErr" := (GoAlloc go.bool #()) in
    let: "loopB" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := (![go.SliceType go.byte] "b1") in
    do:  ("loopB" <-[go.SliceType go.byte] "$r0");;;
    (let: "i" := (GoAlloc go.uint64 #()) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, (![go.uint64] "i") <⟨go.uint64⟩ (![go.uint64] "length")); (λ: <>, do:  ("i" <-[go.uint64] ((![go.uint64] "i") +⟨go.uint64⟩ #(W8 1)))) := λ: <>,
      let: "err2" := (GoAlloc go.bool #()) in
      let: "loopB1" := (GoAlloc (go.SliceType go.byte) #()) in
      let: "a2" := (GoAlloc (go.PointerType Memb) #()) in
      let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "loopB") in
      (FuncResolve MembDecode [] #()) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      let: "$r2" := "$ret2" in
      do:  ("a2" <-[go.PointerType Memb] "$r0");;;
      do:  ("loopB1" <-[go.SliceType go.byte] "$r1");;;
      do:  ("err2" <-[go.bool] "$r2");;;
      let: "$r0" := (![go.SliceType go.byte] "loopB1") in
      do:  ("loopB" <-[go.SliceType go.byte] "$r0");;;
      (if: ![go.bool] "err2"
      then
        let: "$r0" := #true in
        do:  ("loopErr" <-[go.bool] "$r0");;;
        break: #()
      else do:  #());;;
      let: "$r0" := (let: "$a0" := (![go.SliceType (go.PointerType Memb)] "loopO") in
      let: "$a1" := ((let: "$sl0" := (![go.PointerType Memb] "a2") in
      CompositeLiteral (go.PointerType Memb) (go.PointerType Memb) ["$sl0"])) in
      (FuncResolve go.append [go.SliceType (go.PointerType Memb)] #()) "$a0" "$a1") in
      do:  ("loopO" <-[go.SliceType (go.PointerType Memb)] "$r0")));;;
    (if: ![go.bool] "loopErr"
    then return: (#slice.nil, #slice.nil, #true)
    else do:  #());;;
    return: (![go.SliceType (go.PointerType Memb)] "loopO", ![go.SliceType go.byte] "loopB", #false)).

Definition AuditProofSlice1DEncode : go_string := "github.com/sanjit-bhat/pav/ktcore.AuditProofSlice1DEncode"%go.

(* go: serde_misc.go:72:6 *)
Definition AuditProofSlice1DEncodeⁱᵐᵖˡ : val :=
  λ: "b0" "o",
    exception_do (let: "o" := (go.AllocValue (go.SliceType (go.PointerType AuditProof)) "o") in
    let: "b0" := (go.AllocValue (go.SliceType go.byte) "b0") in
    let: "b" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := (![go.SliceType go.byte] "b0") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (s_to_w64 (let: "$a0" := (![go.SliceType (go.PointerType AuditProof)] "o") in
    (FuncResolve go.len [go.SliceType (go.PointerType AuditProof)] #()) "$a0")) in
    (FuncResolve marshal.WriteInt [] #()) "$a0" "$a1") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "$range" := (![go.SliceType (go.PointerType AuditProof)] "o") in
    (let: "e" := (GoAlloc (go.PointerType AuditProof) #()) in
    slice.for_range (go.PointerType AuditProof) "$range" (λ: "$key" "$value",
      do:  ("e" <-[go.PointerType AuditProof] "$value");;;
      do:  "$key";;;
      let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
      let: "$a1" := (![go.PointerType AuditProof] "e") in
      (FuncResolve AuditProofEncode [] #()) "$a0" "$a1") in
      do:  ("b" <-[go.SliceType go.byte] "$r0")));;;
    return: (![go.SliceType go.byte] "b")).

Definition AuditProofSlice1DDecode : go_string := "github.com/sanjit-bhat/pav/ktcore.AuditProofSlice1DDecode"%go.

(* go: serde_misc.go:81:6 *)
Definition AuditProofSlice1DDecodeⁱᵐᵖˡ : val :=
  λ: "b0",
    exception_do (let: "b0" := (go.AllocValue (go.SliceType go.byte) "b0") in
    let: "err1" := (GoAlloc go.bool #()) in
    let: "b1" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "length" := (GoAlloc go.uint64 #()) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "b0") in
    (FuncResolve safemarshal.ReadInt [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("length" <-[go.uint64] "$r0");;;
    do:  ("b1" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err1" <-[go.bool] "$r2");;;
    (if: ![go.bool] "err1"
    then return: (#slice.nil, #slice.nil, #true)
    else do:  #());;;
    let: "loopO" := (GoAlloc (go.SliceType (go.PointerType AuditProof)) #()) in
    let: "$r0" := ((FuncResolve go.make3 [go.SliceType (go.PointerType AuditProof)] #()) #(W64 0) (![go.uint64] "length")) in
    do:  ("loopO" <-[go.SliceType (go.PointerType AuditProof)] "$r0");;;
    let: "loopErr" := (GoAlloc go.bool #()) in
    let: "loopB" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := (![go.SliceType go.byte] "b1") in
    do:  ("loopB" <-[go.SliceType go.byte] "$r0");;;
    (let: "i" := (GoAlloc go.uint64 #()) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, (![go.uint64] "i") <⟨go.uint64⟩ (![go.uint64] "length")); (λ: <>, do:  ("i" <-[go.uint64] ((![go.uint64] "i") +⟨go.uint64⟩ #(W8 1)))) := λ: <>,
      let: "err2" := (GoAlloc go.bool #()) in
      let: "loopB1" := (GoAlloc (go.SliceType go.byte) #()) in
      let: "a2" := (GoAlloc (go.PointerType AuditProof) #()) in
      let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "loopB") in
      (FuncResolve AuditProofDecode [] #()) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      let: "$r2" := "$ret2" in
      do:  ("a2" <-[go.PointerType AuditProof] "$r0");;;
      do:  ("loopB1" <-[go.SliceType go.byte] "$r1");;;
      do:  ("err2" <-[go.bool] "$r2");;;
      let: "$r0" := (![go.SliceType go.byte] "loopB1") in
      do:  ("loopB" <-[go.SliceType go.byte] "$r0");;;
      (if: ![go.bool] "err2"
      then
        let: "$r0" := #true in
        do:  ("loopErr" <-[go.bool] "$r0");;;
        break: #()
      else do:  #());;;
      let: "$r0" := (let: "$a0" := (![go.SliceType (go.PointerType AuditProof)] "loopO") in
      let: "$a1" := ((let: "$sl0" := (![go.PointerType AuditProof] "a2") in
      CompositeLiteral (go.PointerType AuditProof) (go.PointerType AuditProof) ["$sl0"])) in
      (FuncResolve go.append [go.SliceType (go.PointerType AuditProof)] #()) "$a0" "$a1") in
      do:  ("loopO" <-[go.SliceType (go.PointerType AuditProof)] "$r0")));;;
    (if: ![go.bool] "loopErr"
    then return: (#slice.nil, #slice.nil, #true)
    else do:  #());;;
    return: (![go.SliceType (go.PointerType AuditProof)] "loopO", ![go.SliceType go.byte] "loopB", #false)).

Definition Blame : go.type := go.Named "github.com/sanjit-bhat/pav/ktcore.Blame"%go [].

Definition functions' : list (go_string * val) := [(SignVrf, SignVrfⁱᵐᵖˡ); (VerifyVrfSig, VerifyVrfSigⁱᵐᵖˡ); (SignLink, SignLinkⁱᵐᵖˡ); (VerifyLinkSig, VerifyLinkSigⁱᵐᵖˡ); (ProveMapLabel, ProveMapLabelⁱᵐᵖˡ); (EvalMapLabel, EvalMapLabelⁱᵐᵖˡ); (CheckMapLabel, CheckMapLabelⁱᵐᵖˡ); (GetMapVal, GetMapValⁱᵐᵖˡ); (GetCommitRand, GetCommitRandⁱᵐᵖˡ); (VrfSigEncode, VrfSigEncodeⁱᵐᵖˡ); (VrfSigDecode, VrfSigDecodeⁱᵐᵖˡ); (LinkSigEncode, LinkSigEncodeⁱᵐᵖˡ); (LinkSigDecode, LinkSigDecodeⁱᵐᵖˡ); (MapLabelEncode, MapLabelEncodeⁱᵐᵖˡ); (MapLabelDecode, MapLabelDecodeⁱᵐᵖˡ); (CommitOpenEncode, CommitOpenEncodeⁱᵐᵖˡ); (CommitOpenDecode, CommitOpenDecodeⁱᵐᵖˡ); (MembEncode, MembEncodeⁱᵐᵖˡ); (MembDecode, MembDecodeⁱᵐᵖˡ); (NonMembEncode, NonMembEncodeⁱᵐᵖˡ); (NonMembDecode, NonMembDecodeⁱᵐᵖˡ); (AuditProofEncode, AuditProofEncodeⁱᵐᵖˡ); (AuditProofDecode, AuditProofDecodeⁱᵐᵖˡ); (UpdateProofEncode, UpdateProofEncodeⁱᵐᵖˡ); (UpdateProofDecode, UpdateProofDecodeⁱᵐᵖˡ); (UpdateProofSlice1DEncode, UpdateProofSlice1DEncodeⁱᵐᵖˡ); (UpdateProofSlice1DDecode, UpdateProofSlice1DDecodeⁱᵐᵖˡ); (MembSlice1DEncode, MembSlice1DEncodeⁱᵐᵖˡ); (MembSlice1DDecode, MembSlice1DDecodeⁱᵐᵖˡ); (AuditProofSlice1DEncode, AuditProofSlice1DEncodeⁱᵐᵖˡ); (AuditProofSlice1DDecode, AuditProofSlice1DDecodeⁱᵐᵖˡ)].

#[global] Instance info' : PkgInfo ktcore.ktcore :=
  {|
    pkg_imported_pkgs := [code.github_com.sanjit_bhat.pav.cryptoffi.cryptoffi; code.github_com.sanjit_bhat.pav.cryptoutil.cryptoutil; code.github_com.sanjit_bhat.pav.safemarshal.safemarshal; code.github_com.tchajed.marshal.marshal];
  |}.

Definition initialize' : val :=
  λ: <>,
    package.init ktcore.ktcore (λ: <>,
      exception_do (do:  (marshal.initialize' #());;;
      do:  (safemarshal.initialize' #());;;
      do:  (cryptoutil.initialize' #());;;
      do:  (cryptoffi.initialize' #()))
      ).

End code.
End ktcore.
