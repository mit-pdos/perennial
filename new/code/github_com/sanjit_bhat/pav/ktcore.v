(* autogenerated from github.com/sanjit-bhat/pav/ktcore *)
From New.golang Require Import defn.
Require Export New.code.github_com.sanjit_bhat.pav.cryptoffi.
Require Export New.code.github_com.sanjit_bhat.pav.cryptoutil.
Require Export New.code.github_com.sanjit_bhat.pav.safemarshal.
Require Export New.code.github_com.tchajed.marshal.

Definition ktcore : go_string := "github.com/sanjit-bhat/pav/ktcore".

Module ktcore.
Section code.
Context `{ffi_syntax}.


Definition Blame : go_type := uint64T.

Definition BlameNone : expr := #(W64 0).

Definition BlameServSig : expr := #(W64 1).

Definition BlameServFull : expr := #(W64 2).

Definition BlameAdtrSig : expr := #(W64 4).

Definition BlameAdtrFull : expr := #(W64 8).

Definition BlameClients : expr := #(W64 16).

Definition BlameUnknown : expr := #(W64 32).

(* CheckBlame prevents bad parties from giving bad [Blame] codes.

   go: ktcore.go:32:6 *)
Definition CheckBlame : val :=
  rec: "CheckBlame" "b" "allowed" :=
    exception_do (let: "err" := (mem.alloc (type.zero_val #boolT)) in
    let: "allowed" := (mem.alloc "allowed") in
    let: "b" := (mem.alloc "b") in
    let: "all" := (mem.alloc (type.zero_val #Blame)) in
    let: "$range" := (![#sliceT] "allowed") in
    (let: "x" := (mem.alloc (type.zero_val #Blame)) in
    slice.for_range #Blame "$range" (λ: "$key" "$value",
      do:  ("x" <-[#Blame] "$value");;;
      do:  "$key";;;
      do:  ("all" <-[#Blame] ((![#Blame] "all") `or` (![#Blame] "x")))));;;
    return: (((![#Blame] "b") `and` (~ (![#Blame] "all"))) ≠ #(W64 0))).

Definition VrfSig : go_type := structT [
  "SigTag" :: byteT;
  "VrfPk" :: sliceT
].

Definition VrfSigTag : expr := #(W8 0).

(* go: ktcore.go:40:6 *)
Definition SignVrf : val :=
  rec: "SignVrf" "sk" "vrfPk" :=
    exception_do (let: "sig" := (mem.alloc (type.zero_val #sliceT)) in
    let: "vrfPk" := (mem.alloc "vrfPk") in
    let: "sk" := (mem.alloc "sk") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make3 #byteT #(W64 0) (#(W64 (1 + 8)) + cryptoffi.HashLen)) in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (mem.alloc (let: "$SigTag" := VrfSigTag in
    let: "$VrfPk" := (![#sliceT] "vrfPk") in
    struct.make #VrfSig [{
      "SigTag" ::= "$SigTag";
      "VrfPk" ::= "$VrfPk"
    }])) in
    (func_call #ktcore.ktcore #"VrfSigEncode"%go) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    (method_call #cryptoffi #"SigPrivateKey'ptr" #"Sign" (![#ptrT] "sk")) "$a0") in
    do:  ("sig" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "sig")).

(* go: ktcore.go:48:6 *)
Definition VerifyVrfSig : val :=
  rec: "VerifyVrfSig" "pk" "vrfPk" "sig" :=
    exception_do (let: "err" := (mem.alloc (type.zero_val #boolT)) in
    let: "sig" := (mem.alloc "sig") in
    let: "vrfPk" := (mem.alloc "vrfPk") in
    let: "pk" := (mem.alloc "pk") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make3 #byteT #(W64 0) (#(W64 (1 + 8)) + cryptoffi.HashLen)) in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (mem.alloc (let: "$SigTag" := VrfSigTag in
    let: "$VrfPk" := (![#sliceT] "vrfPk") in
    struct.make #VrfSig [{
      "SigTag" ::= "$SigTag";
      "VrfPk" ::= "$VrfPk"
    }])) in
    (func_call #ktcore.ktcore #"VrfSigEncode"%go) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    return: (let: "$a0" := (![#sliceT] "b") in
     let: "$a1" := (![#sliceT] "sig") in
     (method_call #cryptoffi #"SigPublicKey" #"Verify" (![#cryptoffi.SigPublicKey] "pk")) "$a0" "$a1")).

Definition LinkSig : go_type := structT [
  "SigTag" :: byteT;
  "Epoch" :: uint64T;
  "Link" :: sliceT
].

Definition LinkSigTag : expr := #(W8 1).

(* go: ktcore.go:54:6 *)
Definition SignLink : val :=
  rec: "SignLink" "sk" "epoch" "link" :=
    exception_do (let: "sig" := (mem.alloc (type.zero_val #sliceT)) in
    let: "link" := (mem.alloc "link") in
    let: "epoch" := (mem.alloc "epoch") in
    let: "sk" := (mem.alloc "sk") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make3 #byteT #(W64 0) (#(W64 ((1 + 8) + 8)) + cryptoffi.HashLen)) in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (mem.alloc (let: "$SigTag" := LinkSigTag in
    let: "$Epoch" := (![#uint64T] "epoch") in
    let: "$Link" := (![#sliceT] "link") in
    struct.make #LinkSig [{
      "SigTag" ::= "$SigTag";
      "Epoch" ::= "$Epoch";
      "Link" ::= "$Link"
    }])) in
    (func_call #ktcore.ktcore #"LinkSigEncode"%go) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    (method_call #cryptoffi #"SigPrivateKey'ptr" #"Sign" (![#ptrT] "sk")) "$a0") in
    do:  ("sig" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "sig")).

(* go: ktcore.go:62:6 *)
Definition VerifyLinkSig : val :=
  rec: "VerifyLinkSig" "pk" "epoch" "link" "sig" :=
    exception_do (let: "err" := (mem.alloc (type.zero_val #boolT)) in
    let: "sig" := (mem.alloc "sig") in
    let: "link" := (mem.alloc "link") in
    let: "epoch" := (mem.alloc "epoch") in
    let: "pk" := (mem.alloc "pk") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make3 #byteT #(W64 0) (#(W64 ((1 + 8) + 8)) + cryptoffi.HashLen)) in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (mem.alloc (let: "$SigTag" := LinkSigTag in
    let: "$Epoch" := (![#uint64T] "epoch") in
    let: "$Link" := (![#sliceT] "link") in
    struct.make #LinkSig [{
      "SigTag" ::= "$SigTag";
      "Epoch" ::= "$Epoch";
      "Link" ::= "$Link"
    }])) in
    (func_call #ktcore.ktcore #"LinkSigEncode"%go) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    return: (let: "$a0" := (![#sliceT] "b") in
     let: "$a1" := (![#sliceT] "sig") in
     (method_call #cryptoffi #"SigPublicKey" #"Verify" (![#cryptoffi.SigPublicKey] "pk")) "$a0" "$a1")).

Definition MapLabel : go_type := structT [
  "Uid" :: uint64T;
  "Ver" :: uint64T
].

(* go: ktcore.go:68:6 *)
Definition ProveMapLabel : val :=
  rec: "ProveMapLabel" "uid" "ver" "sk" :=
    exception_do (let: "proof" := (mem.alloc (type.zero_val #sliceT)) in
    let: "label" := (mem.alloc (type.zero_val #sliceT)) in
    let: "sk" := (mem.alloc "sk") in
    let: "ver" := (mem.alloc "ver") in
    let: "uid" := (mem.alloc "uid") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make3 #byteT #(W64 0) #(W64 16)) in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (mem.alloc (let: "$Uid" := (![#uint64T] "uid") in
    let: "$Ver" := (![#uint64T] "ver") in
    struct.make #MapLabel [{
      "Uid" ::= "$Uid";
      "Ver" ::= "$Ver"
    }])) in
    (func_call #ktcore.ktcore #"MapLabelEncode"%go) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: ("$ret0", "$ret1") := ((let: "$a0" := (![#sliceT] "b") in
    (method_call #cryptoffi #"VrfPrivateKey'ptr" #"Prove" (![#ptrT] "sk")) "$a0")) in
    return: ("$ret0", "$ret1")).

(* go: ktcore.go:74:6 *)
Definition EvalMapLabel : val :=
  rec: "EvalMapLabel" "uid" "ver" "sk" :=
    exception_do (let: "label" := (mem.alloc (type.zero_val #sliceT)) in
    let: "sk" := (mem.alloc "sk") in
    let: "ver" := (mem.alloc "ver") in
    let: "uid" := (mem.alloc "uid") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make3 #byteT #(W64 0) #(W64 16)) in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (mem.alloc (let: "$Uid" := (![#uint64T] "uid") in
    let: "$Ver" := (![#uint64T] "ver") in
    struct.make #MapLabel [{
      "Uid" ::= "$Uid";
      "Ver" ::= "$Ver"
    }])) in
    (func_call #ktcore.ktcore #"MapLabelEncode"%go) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    return: (let: "$a0" := (![#sliceT] "b") in
     (method_call #cryptoffi #"VrfPrivateKey'ptr" #"Evaluate" (![#ptrT] "sk")) "$a0")).

(* go: ktcore.go:80:6 *)
Definition CheckMapLabel : val :=
  rec: "CheckMapLabel" "pk" "uid" "ver" "proof" :=
    exception_do (let: "err" := (mem.alloc (type.zero_val #boolT)) in
    let: "label" := (mem.alloc (type.zero_val #sliceT)) in
    let: "proof" := (mem.alloc "proof") in
    let: "ver" := (mem.alloc "ver") in
    let: "uid" := (mem.alloc "uid") in
    let: "pk" := (mem.alloc "pk") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make3 #byteT #(W64 0) #(W64 16)) in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (mem.alloc (let: "$Uid" := (![#uint64T] "uid") in
    let: "$Ver" := (![#uint64T] "ver") in
    struct.make #MapLabel [{
      "Uid" ::= "$Uid";
      "Ver" ::= "$Ver"
    }])) in
    (func_call #ktcore.ktcore #"MapLabelEncode"%go) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: ("$ret0", "$ret1") := ((let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#sliceT] "proof") in
    (method_call #cryptoffi #"VrfPublicKey'ptr" #"Verify" (![#ptrT] "pk")) "$a0" "$a1")) in
    return: ("$ret0", "$ret1")).

Definition CommitOpen : go_type := structT [
  "Val" :: sliceT;
  "Rand" :: sliceT
].

(* go: ktcore.go:86:6 *)
Definition GetMapVal : val :=
  rec: "GetMapVal" "pkOpen" :=
    exception_do (let: "val" := (mem.alloc (type.zero_val #sliceT)) in
    let: "pkOpen" := (mem.alloc "pkOpen") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make3 #byteT #(W64 0) (((#(W64 8) + (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref #CommitOpen #"Val"%go (![#ptrT] "pkOpen"))) in
    slice.len "$a0"))) + #(W64 8)) + cryptoffi.HashLen)) in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#ptrT] "pkOpen") in
    (func_call #ktcore.ktcore #"CommitOpenEncode"%go) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    return: (let: "$a0" := (![#sliceT] "b") in
     (func_call #cryptoutil.cryptoutil #"Hash"%go) "$a0")).

(* GetCommitRand computes the psuedo-random (wrt commitSecret) bits
   used in a mapVal commitment.

   go: ktcore.go:94:6 *)
Definition GetCommitRand : val :=
  rec: "GetCommitRand" "commitSecret" "label" :=
    exception_do (let: "rand" := (mem.alloc (type.zero_val #sliceT)) in
    let: "label" := (mem.alloc "label") in
    let: "commitSecret" := (mem.alloc "commitSecret") in
    let: "hr" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := ((func_call #cryptoffi.cryptoffi #"NewHasher"%go) #()) in
    do:  ("hr" <-[#ptrT] "$r0");;;
    do:  (let: "$a0" := (![#sliceT] "commitSecret") in
    (method_call #cryptoffi #"Hasher'ptr" #"Write" (![#ptrT] "hr")) "$a0");;;
    do:  (let: "$a0" := (![#sliceT] "label") in
    (method_call #cryptoffi #"Hasher'ptr" #"Write" (![#ptrT] "hr")) "$a0");;;
    return: (let: "$a0" := #slice.nil in
     (method_call #cryptoffi #"Hasher'ptr" #"Sum" (![#ptrT] "hr")) "$a0")).

Definition Memb : go_type := structT [
  "LabelProof" :: sliceT;
  "PkOpen" :: ptrT;
  "MerkleProof" :: sliceT
].

Definition NonMemb : go_type := structT [
  "LabelProof" :: sliceT;
  "MerkleProof" :: sliceT
].

Definition AuditProof : go_type := structT [
  "Updates" :: sliceT;
  "LinkSig" :: sliceT
].

Definition UpdateProof : go_type := structT [
  "MapLabel" :: sliceT;
  "MapVal" :: sliceT;
  "NonMembProof" :: sliceT
].

(* go: serde.out.go:10:6 *)
Definition VrfSigEncode : val :=
  rec: "VrfSigEncode" "b0" "o" :=
    exception_do (let: "o" := (mem.alloc "o") in
    let: "b0" := (mem.alloc "b0") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "b0") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#byteT] (struct.field_ref #VrfSig #"SigTag"%go (![#ptrT] "o"))) in
    (func_call #safemarshal.safemarshal #"WriteByte"%go) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#sliceT] (struct.field_ref #VrfSig #"VrfPk"%go (![#ptrT] "o"))) in
    (func_call #safemarshal.safemarshal #"WriteSlice1D"%go) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "b")).

(* go: serde.out.go:16:6 *)
Definition VrfSigDecode : val :=
  rec: "VrfSigDecode" "b0" :=
    exception_do (let: "b0" := (mem.alloc "b0") in
    let: "err1" := (mem.alloc (type.zero_val #boolT)) in
    let: "b1" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a1" := (mem.alloc (type.zero_val #byteT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b0") in
    (func_call #safemarshal.safemarshal #"ReadByte"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a1" <-[#byteT] "$r0");;;
    do:  ("b1" <-[#sliceT] "$r1");;;
    do:  ("err1" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err1"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err2" := (mem.alloc (type.zero_val #boolT)) in
    let: "b2" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a2" := (mem.alloc (type.zero_val #sliceT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b1") in
    (func_call #safemarshal.safemarshal #"ReadSlice1D"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a2" <-[#sliceT] "$r0");;;
    do:  ("b2" <-[#sliceT] "$r1");;;
    do:  ("err2" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err2"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    return: (mem.alloc (let: "$SigTag" := (![#byteT] "a1") in
     let: "$VrfPk" := (![#sliceT] "a2") in
     struct.make #VrfSig [{
       "SigTag" ::= "$SigTag";
       "VrfPk" ::= "$VrfPk"
     }]), ![#sliceT] "b2", #false)).

(* go: serde.out.go:27:6 *)
Definition LinkSigEncode : val :=
  rec: "LinkSigEncode" "b0" "o" :=
    exception_do (let: "o" := (mem.alloc "o") in
    let: "b0" := (mem.alloc "b0") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "b0") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#byteT] (struct.field_ref #LinkSig #"SigTag"%go (![#ptrT] "o"))) in
    (func_call #safemarshal.safemarshal #"WriteByte"%go) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#uint64T] (struct.field_ref #LinkSig #"Epoch"%go (![#ptrT] "o"))) in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#sliceT] (struct.field_ref #LinkSig #"Link"%go (![#ptrT] "o"))) in
    (func_call #safemarshal.safemarshal #"WriteSlice1D"%go) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "b")).

(* go: serde.out.go:34:6 *)
Definition LinkSigDecode : val :=
  rec: "LinkSigDecode" "b0" :=
    exception_do (let: "b0" := (mem.alloc "b0") in
    let: "err1" := (mem.alloc (type.zero_val #boolT)) in
    let: "b1" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a1" := (mem.alloc (type.zero_val #byteT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b0") in
    (func_call #safemarshal.safemarshal #"ReadByte"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a1" <-[#byteT] "$r0");;;
    do:  ("b1" <-[#sliceT] "$r1");;;
    do:  ("err1" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err1"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err2" := (mem.alloc (type.zero_val #boolT)) in
    let: "b2" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a2" := (mem.alloc (type.zero_val #uint64T)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b1") in
    (func_call #safemarshal.safemarshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a2" <-[#uint64T] "$r0");;;
    do:  ("b2" <-[#sliceT] "$r1");;;
    do:  ("err2" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err2"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err3" := (mem.alloc (type.zero_val #boolT)) in
    let: "b3" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a3" := (mem.alloc (type.zero_val #sliceT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b2") in
    (func_call #safemarshal.safemarshal #"ReadSlice1D"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a3" <-[#sliceT] "$r0");;;
    do:  ("b3" <-[#sliceT] "$r1");;;
    do:  ("err3" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err3"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    return: (mem.alloc (let: "$SigTag" := (![#byteT] "a1") in
     let: "$Epoch" := (![#uint64T] "a2") in
     let: "$Link" := (![#sliceT] "a3") in
     struct.make #LinkSig [{
       "SigTag" ::= "$SigTag";
       "Epoch" ::= "$Epoch";
       "Link" ::= "$Link"
     }]), ![#sliceT] "b3", #false)).

(* go: serde.out.go:49:6 *)
Definition MapLabelEncode : val :=
  rec: "MapLabelEncode" "b0" "o" :=
    exception_do (let: "o" := (mem.alloc "o") in
    let: "b0" := (mem.alloc "b0") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "b0") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#uint64T] (struct.field_ref #MapLabel #"Uid"%go (![#ptrT] "o"))) in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#uint64T] (struct.field_ref #MapLabel #"Ver"%go (![#ptrT] "o"))) in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "b")).

(* go: serde.out.go:55:6 *)
Definition MapLabelDecode : val :=
  rec: "MapLabelDecode" "b0" :=
    exception_do (let: "b0" := (mem.alloc "b0") in
    let: "err1" := (mem.alloc (type.zero_val #boolT)) in
    let: "b1" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a1" := (mem.alloc (type.zero_val #uint64T)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b0") in
    (func_call #safemarshal.safemarshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a1" <-[#uint64T] "$r0");;;
    do:  ("b1" <-[#sliceT] "$r1");;;
    do:  ("err1" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err1"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err2" := (mem.alloc (type.zero_val #boolT)) in
    let: "b2" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a2" := (mem.alloc (type.zero_val #uint64T)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b1") in
    (func_call #safemarshal.safemarshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a2" <-[#uint64T] "$r0");;;
    do:  ("b2" <-[#sliceT] "$r1");;;
    do:  ("err2" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err2"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    return: (mem.alloc (let: "$Uid" := (![#uint64T] "a1") in
     let: "$Ver" := (![#uint64T] "a2") in
     struct.make #MapLabel [{
       "Uid" ::= "$Uid";
       "Ver" ::= "$Ver"
     }]), ![#sliceT] "b2", #false)).

(* go: serde.out.go:66:6 *)
Definition CommitOpenEncode : val :=
  rec: "CommitOpenEncode" "b0" "o" :=
    exception_do (let: "o" := (mem.alloc "o") in
    let: "b0" := (mem.alloc "b0") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "b0") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#sliceT] (struct.field_ref #CommitOpen #"Val"%go (![#ptrT] "o"))) in
    (func_call #safemarshal.safemarshal #"WriteSlice1D"%go) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#sliceT] (struct.field_ref #CommitOpen #"Rand"%go (![#ptrT] "o"))) in
    (func_call #safemarshal.safemarshal #"WriteSlice1D"%go) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "b")).

(* go: serde.out.go:72:6 *)
Definition CommitOpenDecode : val :=
  rec: "CommitOpenDecode" "b0" :=
    exception_do (let: "b0" := (mem.alloc "b0") in
    let: "err1" := (mem.alloc (type.zero_val #boolT)) in
    let: "b1" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a1" := (mem.alloc (type.zero_val #sliceT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b0") in
    (func_call #safemarshal.safemarshal #"ReadSlice1D"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a1" <-[#sliceT] "$r0");;;
    do:  ("b1" <-[#sliceT] "$r1");;;
    do:  ("err1" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err1"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err2" := (mem.alloc (type.zero_val #boolT)) in
    let: "b2" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a2" := (mem.alloc (type.zero_val #sliceT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b1") in
    (func_call #safemarshal.safemarshal #"ReadSlice1D"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a2" <-[#sliceT] "$r0");;;
    do:  ("b2" <-[#sliceT] "$r1");;;
    do:  ("err2" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err2"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    return: (mem.alloc (let: "$Val" := (![#sliceT] "a1") in
     let: "$Rand" := (![#sliceT] "a2") in
     struct.make #CommitOpen [{
       "Val" ::= "$Val";
       "Rand" ::= "$Rand"
     }]), ![#sliceT] "b2", #false)).

(* go: serde.out.go:83:6 *)
Definition MembEncode : val :=
  rec: "MembEncode" "b0" "o" :=
    exception_do (let: "o" := (mem.alloc "o") in
    let: "b0" := (mem.alloc "b0") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "b0") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#sliceT] (struct.field_ref #Memb #"LabelProof"%go (![#ptrT] "o"))) in
    (func_call #safemarshal.safemarshal #"WriteSlice1D"%go) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#ptrT] (struct.field_ref #Memb #"PkOpen"%go (![#ptrT] "o"))) in
    (func_call #ktcore.ktcore #"CommitOpenEncode"%go) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#sliceT] (struct.field_ref #Memb #"MerkleProof"%go (![#ptrT] "o"))) in
    (func_call #safemarshal.safemarshal #"WriteSlice1D"%go) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "b")).

(* go: serde.out.go:90:6 *)
Definition MembDecode : val :=
  rec: "MembDecode" "b0" :=
    exception_do (let: "b0" := (mem.alloc "b0") in
    let: "err1" := (mem.alloc (type.zero_val #boolT)) in
    let: "b1" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a1" := (mem.alloc (type.zero_val #sliceT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b0") in
    (func_call #safemarshal.safemarshal #"ReadSlice1D"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a1" <-[#sliceT] "$r0");;;
    do:  ("b1" <-[#sliceT] "$r1");;;
    do:  ("err1" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err1"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err2" := (mem.alloc (type.zero_val #boolT)) in
    let: "b2" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a2" := (mem.alloc (type.zero_val #ptrT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b1") in
    (func_call #ktcore.ktcore #"CommitOpenDecode"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a2" <-[#ptrT] "$r0");;;
    do:  ("b2" <-[#sliceT] "$r1");;;
    do:  ("err2" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err2"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err3" := (mem.alloc (type.zero_val #boolT)) in
    let: "b3" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a3" := (mem.alloc (type.zero_val #sliceT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b2") in
    (func_call #safemarshal.safemarshal #"ReadSlice1D"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a3" <-[#sliceT] "$r0");;;
    do:  ("b3" <-[#sliceT] "$r1");;;
    do:  ("err3" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err3"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    return: (mem.alloc (let: "$LabelProof" := (![#sliceT] "a1") in
     let: "$PkOpen" := (![#ptrT] "a2") in
     let: "$MerkleProof" := (![#sliceT] "a3") in
     struct.make #Memb [{
       "LabelProof" ::= "$LabelProof";
       "PkOpen" ::= "$PkOpen";
       "MerkleProof" ::= "$MerkleProof"
     }]), ![#sliceT] "b3", #false)).

(* go: serde.out.go:105:6 *)
Definition NonMembEncode : val :=
  rec: "NonMembEncode" "b0" "o" :=
    exception_do (let: "o" := (mem.alloc "o") in
    let: "b0" := (mem.alloc "b0") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "b0") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#sliceT] (struct.field_ref #NonMemb #"LabelProof"%go (![#ptrT] "o"))) in
    (func_call #safemarshal.safemarshal #"WriteSlice1D"%go) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#sliceT] (struct.field_ref #NonMemb #"MerkleProof"%go (![#ptrT] "o"))) in
    (func_call #safemarshal.safemarshal #"WriteSlice1D"%go) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "b")).

(* go: serde.out.go:111:6 *)
Definition NonMembDecode : val :=
  rec: "NonMembDecode" "b0" :=
    exception_do (let: "b0" := (mem.alloc "b0") in
    let: "err1" := (mem.alloc (type.zero_val #boolT)) in
    let: "b1" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a1" := (mem.alloc (type.zero_val #sliceT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b0") in
    (func_call #safemarshal.safemarshal #"ReadSlice1D"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a1" <-[#sliceT] "$r0");;;
    do:  ("b1" <-[#sliceT] "$r1");;;
    do:  ("err1" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err1"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err2" := (mem.alloc (type.zero_val #boolT)) in
    let: "b2" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a2" := (mem.alloc (type.zero_val #sliceT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b1") in
    (func_call #safemarshal.safemarshal #"ReadSlice1D"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a2" <-[#sliceT] "$r0");;;
    do:  ("b2" <-[#sliceT] "$r1");;;
    do:  ("err2" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err2"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    return: (mem.alloc (let: "$LabelProof" := (![#sliceT] "a1") in
     let: "$MerkleProof" := (![#sliceT] "a2") in
     struct.make #NonMemb [{
       "LabelProof" ::= "$LabelProof";
       "MerkleProof" ::= "$MerkleProof"
     }]), ![#sliceT] "b2", #false)).

(* go: serde.out.go:122:6 *)
Definition AuditProofEncode : val :=
  rec: "AuditProofEncode" "b0" "o" :=
    exception_do (let: "o" := (mem.alloc "o") in
    let: "b0" := (mem.alloc "b0") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "b0") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#sliceT] (struct.field_ref #AuditProof #"Updates"%go (![#ptrT] "o"))) in
    (func_call #ktcore.ktcore #"UpdateProofSlice1DEncode"%go) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#sliceT] (struct.field_ref #AuditProof #"LinkSig"%go (![#ptrT] "o"))) in
    (func_call #safemarshal.safemarshal #"WriteSlice1D"%go) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "b")).

(* go: serde.out.go:128:6 *)
Definition AuditProofDecode : val :=
  rec: "AuditProofDecode" "b0" :=
    exception_do (let: "b0" := (mem.alloc "b0") in
    let: "err1" := (mem.alloc (type.zero_val #boolT)) in
    let: "b1" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a1" := (mem.alloc (type.zero_val #sliceT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b0") in
    (func_call #ktcore.ktcore #"UpdateProofSlice1DDecode"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a1" <-[#sliceT] "$r0");;;
    do:  ("b1" <-[#sliceT] "$r1");;;
    do:  ("err1" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err1"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err2" := (mem.alloc (type.zero_val #boolT)) in
    let: "b2" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a2" := (mem.alloc (type.zero_val #sliceT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b1") in
    (func_call #safemarshal.safemarshal #"ReadSlice1D"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a2" <-[#sliceT] "$r0");;;
    do:  ("b2" <-[#sliceT] "$r1");;;
    do:  ("err2" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err2"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    return: (mem.alloc (let: "$Updates" := (![#sliceT] "a1") in
     let: "$LinkSig" := (![#sliceT] "a2") in
     struct.make #AuditProof [{
       "Updates" ::= "$Updates";
       "LinkSig" ::= "$LinkSig"
     }]), ![#sliceT] "b2", #false)).

(* go: serde.out.go:139:6 *)
Definition UpdateProofEncode : val :=
  rec: "UpdateProofEncode" "b0" "o" :=
    exception_do (let: "o" := (mem.alloc "o") in
    let: "b0" := (mem.alloc "b0") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "b0") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#sliceT] (struct.field_ref #UpdateProof #"MapLabel"%go (![#ptrT] "o"))) in
    (func_call #safemarshal.safemarshal #"WriteSlice1D"%go) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#sliceT] (struct.field_ref #UpdateProof #"MapVal"%go (![#ptrT] "o"))) in
    (func_call #safemarshal.safemarshal #"WriteSlice1D"%go) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#sliceT] (struct.field_ref #UpdateProof #"NonMembProof"%go (![#ptrT] "o"))) in
    (func_call #safemarshal.safemarshal #"WriteSlice1D"%go) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "b")).

(* go: serde.out.go:146:6 *)
Definition UpdateProofDecode : val :=
  rec: "UpdateProofDecode" "b0" :=
    exception_do (let: "b0" := (mem.alloc "b0") in
    let: "err1" := (mem.alloc (type.zero_val #boolT)) in
    let: "b1" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a1" := (mem.alloc (type.zero_val #sliceT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b0") in
    (func_call #safemarshal.safemarshal #"ReadSlice1D"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a1" <-[#sliceT] "$r0");;;
    do:  ("b1" <-[#sliceT] "$r1");;;
    do:  ("err1" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err1"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err2" := (mem.alloc (type.zero_val #boolT)) in
    let: "b2" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a2" := (mem.alloc (type.zero_val #sliceT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b1") in
    (func_call #safemarshal.safemarshal #"ReadSlice1D"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a2" <-[#sliceT] "$r0");;;
    do:  ("b2" <-[#sliceT] "$r1");;;
    do:  ("err2" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err2"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err3" := (mem.alloc (type.zero_val #boolT)) in
    let: "b3" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a3" := (mem.alloc (type.zero_val #sliceT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b2") in
    (func_call #safemarshal.safemarshal #"ReadSlice1D"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a3" <-[#sliceT] "$r0");;;
    do:  ("b3" <-[#sliceT] "$r1");;;
    do:  ("err3" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err3"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    return: (mem.alloc (let: "$MapLabel" := (![#sliceT] "a1") in
     let: "$MapVal" := (![#sliceT] "a2") in
     let: "$NonMembProof" := (![#sliceT] "a3") in
     struct.make #UpdateProof [{
       "MapLabel" ::= "$MapLabel";
       "MapVal" ::= "$MapVal";
       "NonMembProof" ::= "$NonMembProof"
     }]), ![#sliceT] "b3", #false)).

(* go: serde_misc.go:8:6 *)
Definition UpdateProofSlice1DEncode : val :=
  rec: "UpdateProofSlice1DEncode" "b0" "o" :=
    exception_do (let: "o" := (mem.alloc "o") in
    let: "b0" := (mem.alloc "b0") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "b0") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (s_to_w64 (let: "$a0" := (![#sliceT] "o") in
    slice.len "$a0")) in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$range" := (![#sliceT] "o") in
    (let: "e" := (mem.alloc (type.zero_val #ptrT)) in
    slice.for_range #ptrT "$range" (λ: "$key" "$value",
      do:  ("e" <-[#ptrT] "$value");;;
      do:  "$key";;;
      let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
      let: "$a1" := (![#ptrT] "e") in
      (func_call #ktcore.ktcore #"UpdateProofEncode"%go) "$a0" "$a1") in
      do:  ("b" <-[#sliceT] "$r0")));;;
    return: (![#sliceT] "b")).

(* go: serde_misc.go:17:6 *)
Definition UpdateProofSlice1DDecode : val :=
  rec: "UpdateProofSlice1DDecode" "b0" :=
    exception_do (let: "b0" := (mem.alloc "b0") in
    let: "err1" := (mem.alloc (type.zero_val #boolT)) in
    let: "b1" := (mem.alloc (type.zero_val #sliceT)) in
    let: "length" := (mem.alloc (type.zero_val #uint64T)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b0") in
    (func_call #safemarshal.safemarshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("length" <-[#uint64T] "$r0");;;
    do:  ("b1" <-[#sliceT] "$r1");;;
    do:  ("err1" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err1"
    then return: (#slice.nil, #slice.nil, #true)
    else do:  #());;;
    let: "loopO" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make3 #ptrT #(W64 0) (![#uint64T] "length")) in
    do:  ("loopO" <-[#sliceT] "$r0");;;
    let: "loopErr" := (mem.alloc (type.zero_val #boolT)) in
    let: "loopB" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "b1") in
    do:  ("loopB" <-[#sliceT] "$r0");;;
    (let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (for: (λ: <>, (![#uint64T] "i") < (![#uint64T] "length")); (λ: <>, do:  ("i" <-[#uint64T] ((![#uint64T] "i") + #(W64 1)))) := λ: <>,
      let: "err2" := (mem.alloc (type.zero_val #boolT)) in
      let: "loopB1" := (mem.alloc (type.zero_val #sliceT)) in
      let: "a2" := (mem.alloc (type.zero_val #ptrT)) in
      let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "loopB") in
      (func_call #ktcore.ktcore #"UpdateProofDecode"%go) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      let: "$r2" := "$ret2" in
      do:  ("a2" <-[#ptrT] "$r0");;;
      do:  ("loopB1" <-[#sliceT] "$r1");;;
      do:  ("err2" <-[#boolT] "$r2");;;
      let: "$r0" := (![#sliceT] "loopB1") in
      do:  ("loopB" <-[#sliceT] "$r0");;;
      (if: ![#boolT] "err2"
      then
        let: "$r0" := #true in
        do:  ("loopErr" <-[#boolT] "$r0");;;
        break: #()
      else do:  #());;;
      let: "$r0" := (let: "$a0" := (![#sliceT] "loopO") in
      let: "$a1" := ((let: "$sl0" := (![#ptrT] "a2") in
      slice.literal #ptrT ["$sl0"])) in
      (slice.append #ptrT) "$a0" "$a1") in
      do:  ("loopO" <-[#sliceT] "$r0")));;;
    (if: ![#boolT] "loopErr"
    then return: (#slice.nil, #slice.nil, #true)
    else do:  #());;;
    return: (![#sliceT] "loopO", ![#sliceT] "loopB", #false)).

(* go: serde_misc.go:40:6 *)
Definition MembSlice1DEncode : val :=
  rec: "MembSlice1DEncode" "b0" "o" :=
    exception_do (let: "o" := (mem.alloc "o") in
    let: "b0" := (mem.alloc "b0") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "b0") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (s_to_w64 (let: "$a0" := (![#sliceT] "o") in
    slice.len "$a0")) in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$range" := (![#sliceT] "o") in
    (let: "e" := (mem.alloc (type.zero_val #ptrT)) in
    slice.for_range #ptrT "$range" (λ: "$key" "$value",
      do:  ("e" <-[#ptrT] "$value");;;
      do:  "$key";;;
      let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
      let: "$a1" := (![#ptrT] "e") in
      (func_call #ktcore.ktcore #"MembEncode"%go) "$a0" "$a1") in
      do:  ("b" <-[#sliceT] "$r0")));;;
    return: (![#sliceT] "b")).

(* go: serde_misc.go:49:6 *)
Definition MembSlice1DDecode : val :=
  rec: "MembSlice1DDecode" "b0" :=
    exception_do (let: "b0" := (mem.alloc "b0") in
    let: "err1" := (mem.alloc (type.zero_val #boolT)) in
    let: "b1" := (mem.alloc (type.zero_val #sliceT)) in
    let: "length" := (mem.alloc (type.zero_val #uint64T)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b0") in
    (func_call #safemarshal.safemarshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("length" <-[#uint64T] "$r0");;;
    do:  ("b1" <-[#sliceT] "$r1");;;
    do:  ("err1" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err1"
    then return: (#slice.nil, #slice.nil, #true)
    else do:  #());;;
    let: "loopO" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make3 #ptrT #(W64 0) (![#uint64T] "length")) in
    do:  ("loopO" <-[#sliceT] "$r0");;;
    let: "loopErr" := (mem.alloc (type.zero_val #boolT)) in
    let: "loopB" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "b1") in
    do:  ("loopB" <-[#sliceT] "$r0");;;
    (let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (for: (λ: <>, (![#uint64T] "i") < (![#uint64T] "length")); (λ: <>, do:  ("i" <-[#uint64T] ((![#uint64T] "i") + #(W64 1)))) := λ: <>,
      let: "err2" := (mem.alloc (type.zero_val #boolT)) in
      let: "loopB1" := (mem.alloc (type.zero_val #sliceT)) in
      let: "a2" := (mem.alloc (type.zero_val #ptrT)) in
      let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "loopB") in
      (func_call #ktcore.ktcore #"MembDecode"%go) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      let: "$r2" := "$ret2" in
      do:  ("a2" <-[#ptrT] "$r0");;;
      do:  ("loopB1" <-[#sliceT] "$r1");;;
      do:  ("err2" <-[#boolT] "$r2");;;
      let: "$r0" := (![#sliceT] "loopB1") in
      do:  ("loopB" <-[#sliceT] "$r0");;;
      (if: ![#boolT] "err2"
      then
        let: "$r0" := #true in
        do:  ("loopErr" <-[#boolT] "$r0");;;
        break: #()
      else do:  #());;;
      let: "$r0" := (let: "$a0" := (![#sliceT] "loopO") in
      let: "$a1" := ((let: "$sl0" := (![#ptrT] "a2") in
      slice.literal #ptrT ["$sl0"])) in
      (slice.append #ptrT) "$a0" "$a1") in
      do:  ("loopO" <-[#sliceT] "$r0")));;;
    (if: ![#boolT] "loopErr"
    then return: (#slice.nil, #slice.nil, #true)
    else do:  #());;;
    return: (![#sliceT] "loopO", ![#sliceT] "loopB", #false)).

(* go: serde_misc.go:72:6 *)
Definition AuditProofSlice1DEncode : val :=
  rec: "AuditProofSlice1DEncode" "b0" "o" :=
    exception_do (let: "o" := (mem.alloc "o") in
    let: "b0" := (mem.alloc "b0") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "b0") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (s_to_w64 (let: "$a0" := (![#sliceT] "o") in
    slice.len "$a0")) in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$range" := (![#sliceT] "o") in
    (let: "e" := (mem.alloc (type.zero_val #ptrT)) in
    slice.for_range #ptrT "$range" (λ: "$key" "$value",
      do:  ("e" <-[#ptrT] "$value");;;
      do:  "$key";;;
      let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
      let: "$a1" := (![#ptrT] "e") in
      (func_call #ktcore.ktcore #"AuditProofEncode"%go) "$a0" "$a1") in
      do:  ("b" <-[#sliceT] "$r0")));;;
    return: (![#sliceT] "b")).

(* go: serde_misc.go:81:6 *)
Definition AuditProofSlice1DDecode : val :=
  rec: "AuditProofSlice1DDecode" "b0" :=
    exception_do (let: "b0" := (mem.alloc "b0") in
    let: "err1" := (mem.alloc (type.zero_val #boolT)) in
    let: "b1" := (mem.alloc (type.zero_val #sliceT)) in
    let: "length" := (mem.alloc (type.zero_val #uint64T)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b0") in
    (func_call #safemarshal.safemarshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("length" <-[#uint64T] "$r0");;;
    do:  ("b1" <-[#sliceT] "$r1");;;
    do:  ("err1" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err1"
    then return: (#slice.nil, #slice.nil, #true)
    else do:  #());;;
    let: "loopO" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make3 #ptrT #(W64 0) (![#uint64T] "length")) in
    do:  ("loopO" <-[#sliceT] "$r0");;;
    let: "loopErr" := (mem.alloc (type.zero_val #boolT)) in
    let: "loopB" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "b1") in
    do:  ("loopB" <-[#sliceT] "$r0");;;
    (let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (for: (λ: <>, (![#uint64T] "i") < (![#uint64T] "length")); (λ: <>, do:  ("i" <-[#uint64T] ((![#uint64T] "i") + #(W64 1)))) := λ: <>,
      let: "err2" := (mem.alloc (type.zero_val #boolT)) in
      let: "loopB1" := (mem.alloc (type.zero_val #sliceT)) in
      let: "a2" := (mem.alloc (type.zero_val #ptrT)) in
      let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "loopB") in
      (func_call #ktcore.ktcore #"AuditProofDecode"%go) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      let: "$r2" := "$ret2" in
      do:  ("a2" <-[#ptrT] "$r0");;;
      do:  ("loopB1" <-[#sliceT] "$r1");;;
      do:  ("err2" <-[#boolT] "$r2");;;
      let: "$r0" := (![#sliceT] "loopB1") in
      do:  ("loopB" <-[#sliceT] "$r0");;;
      (if: ![#boolT] "err2"
      then
        let: "$r0" := #true in
        do:  ("loopErr" <-[#boolT] "$r0");;;
        break: #()
      else do:  #());;;
      let: "$r0" := (let: "$a0" := (![#sliceT] "loopO") in
      let: "$a1" := ((let: "$sl0" := (![#ptrT] "a2") in
      slice.literal #ptrT ["$sl0"])) in
      (slice.append #ptrT) "$a0" "$a1") in
      do:  ("loopO" <-[#sliceT] "$r0")));;;
    (if: ![#boolT] "loopErr"
    then return: (#slice.nil, #slice.nil, #true)
    else do:  #());;;
    return: (![#sliceT] "loopO", ![#sliceT] "loopB", #false)).

Definition vars' : list (go_string * go_type) := [].

Definition functions' : list (go_string * val) := [("CheckBlame"%go, CheckBlame); ("SignVrf"%go, SignVrf); ("VerifyVrfSig"%go, VerifyVrfSig); ("SignLink"%go, SignLink); ("VerifyLinkSig"%go, VerifyLinkSig); ("ProveMapLabel"%go, ProveMapLabel); ("EvalMapLabel"%go, EvalMapLabel); ("CheckMapLabel"%go, CheckMapLabel); ("GetMapVal"%go, GetMapVal); ("GetCommitRand"%go, GetCommitRand); ("VrfSigEncode"%go, VrfSigEncode); ("VrfSigDecode"%go, VrfSigDecode); ("LinkSigEncode"%go, LinkSigEncode); ("LinkSigDecode"%go, LinkSigDecode); ("MapLabelEncode"%go, MapLabelEncode); ("MapLabelDecode"%go, MapLabelDecode); ("CommitOpenEncode"%go, CommitOpenEncode); ("CommitOpenDecode"%go, CommitOpenDecode); ("MembEncode"%go, MembEncode); ("MembDecode"%go, MembDecode); ("NonMembEncode"%go, NonMembEncode); ("NonMembDecode"%go, NonMembDecode); ("AuditProofEncode"%go, AuditProofEncode); ("AuditProofDecode"%go, AuditProofDecode); ("UpdateProofEncode"%go, UpdateProofEncode); ("UpdateProofDecode"%go, UpdateProofDecode); ("UpdateProofSlice1DEncode"%go, UpdateProofSlice1DEncode); ("UpdateProofSlice1DDecode"%go, UpdateProofSlice1DDecode); ("MembSlice1DEncode"%go, MembSlice1DEncode); ("MembSlice1DDecode"%go, MembSlice1DDecode); ("AuditProofSlice1DEncode"%go, AuditProofSlice1DEncode); ("AuditProofSlice1DDecode"%go, AuditProofSlice1DDecode)].

Definition msets' : list (go_string * (list (go_string * val))) := [("Blame"%go, []); ("Blame'ptr"%go, []); ("VrfSig"%go, []); ("VrfSig'ptr"%go, []); ("LinkSig"%go, []); ("LinkSig'ptr"%go, []); ("MapLabel"%go, []); ("MapLabel'ptr"%go, []); ("CommitOpen"%go, []); ("CommitOpen'ptr"%go, []); ("Memb"%go, []); ("Memb'ptr"%go, []); ("NonMemb"%go, []); ("NonMemb'ptr"%go, []); ("AuditProof"%go, []); ("AuditProof'ptr"%go, []); ("UpdateProof"%go, []); ("UpdateProof'ptr"%go, [])].

#[global] Instance info' : PkgInfo ktcore.ktcore :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [cryptoffi.cryptoffi; cryptoutil.cryptoutil; safemarshal.safemarshal; marshal.marshal];
  |}.

Definition initialize' : val :=
  rec: "initialize'" <> :=
    globals.package_init ktcore.ktcore (λ: <>,
      exception_do (do:  marshal.initialize';;;
      do:  safemarshal.initialize';;;
      do:  cryptoutil.initialize';;;
      do:  cryptoffi.initialize')
      ).

End code.
End ktcore.
