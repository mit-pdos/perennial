(* autogenerated from github.com/sanjit-bhat/pav/ktcore *)
Require Export New.code.github_com.sanjit_bhat.pav.cryptoffi.
Require Export New.code.github_com.sanjit_bhat.pav.cryptoutil.
Require Export New.code.github_com.sanjit_bhat.pav.safemarshal.
Require Export New.code.github_com.tchajed.marshal.

From New.golang Require Import defn.
Definition ktcore : go_string := "github.com/sanjit-bhat/pav/ktcore".

Module ktcore.

Module Blame. Definition id : go_string := "github.com/sanjit-bhat/pav/ktcore.Blame"%go. End Blame.
Module VrfSig. Definition id : go_string := "github.com/sanjit-bhat/pav/ktcore.VrfSig"%go. End VrfSig.
Module LinkSig. Definition id : go_string := "github.com/sanjit-bhat/pav/ktcore.LinkSig"%go. End LinkSig.
Module MapLabel. Definition id : go_string := "github.com/sanjit-bhat/pav/ktcore.MapLabel"%go. End MapLabel.
Module CommitOpen. Definition id : go_string := "github.com/sanjit-bhat/pav/ktcore.CommitOpen"%go. End CommitOpen.
Module Memb. Definition id : go_string := "github.com/sanjit-bhat/pav/ktcore.Memb"%go. End Memb.
Module NonMemb. Definition id : go_string := "github.com/sanjit-bhat/pav/ktcore.NonMemb"%go. End NonMemb.
Module AuditProof. Definition id : go_string := "github.com/sanjit-bhat/pav/ktcore.AuditProof"%go. End AuditProof.
Module UpdateProof. Definition id : go_string := "github.com/sanjit-bhat/pav/ktcore.UpdateProof"%go. End UpdateProof.

Section code.
Context `{ffi_syntax}.


Definition Blame : go_type := uint64T.

Definition BlameNone : expr := #(W64 0).

Definition BlameServSig : expr := #(W64 1).

Definition BlameServFull : expr := #(W64 2).

Definition BlameAdtrSig : expr := #(W64 4).

Definition BlameAdtrFull : expr := #(W64 8).

Definition BlameClients : expr := #(W64 16).

Definition BlameUnknown : expr := #(W64 32).

Definition CheckBlame : go_string := "github.com/sanjit-bhat/pav/ktcore.CheckBlame"%go.

(* CheckBlame prevents bad parties from giving bad [Blame] codes.

   go: ktcore.go:32:6 *)
Definition CheckBlameⁱᵐᵖˡ : val :=
  λ: "b" "allowed",
    exception_do (let: "err" := (mem.alloc (type.zero_val #boolT)) in
    let: "allowed" := (mem.alloc "allowed") in
    let: "b" := (mem.alloc "b") in
    let: "all" := (mem.alloc (type.zero_val #Blame)) in
    let: "$range" := (![#sliceT] "allowed") in
    (let: "x" := (mem.alloc (type.zero_val #Blame)) in
    slice.for_range #Blame "$range" (λ: "$key" "$value",
      do:  ("x" <-[#Blame] "$value");;;
      do:  "$key";;;
      do:  ("all" <-[#Blame] ((![#Blame] "all") `or` (![#Blame] "x")))));;;
    return: (((![#Blame] "b") `and` (~ (![#Blame] "all"))) ≠ #(W64 0))).

Definition SignVrf : go_string := "github.com/sanjit-bhat/pav/ktcore.SignVrf"%go.

Definition VrfSigEncode : go_string := "github.com/sanjit-bhat/pav/ktcore.VrfSigEncode"%go.

Definition VrfSig : go_type := structT [
  "SigTag" :: byteT;
  "VrfPk" :: sliceT
].

Definition VrfSigTag : expr := #(W8 0).

(* go: ktcore.go:40:6 *)
Definition SignVrfⁱᵐᵖˡ : val :=
  λ: "sk" "vrfPk",
    exception_do (let: "sig" := (mem.alloc (type.zero_val #sliceT)) in
    let: "vrfPk" := (mem.alloc "vrfPk") in
    let: "sk" := (mem.alloc "sk") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make3 #byteT #(W64 0) (#(W64 (1 + 8)) + cryptoffi.HashLen)) in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (mem.alloc (let: "$SigTag" := VrfSigTag in
    let: "$VrfPk" := (![#sliceT] "vrfPk") in
    struct.make #VrfSig [{
      "SigTag" ::= "$SigTag";
      "VrfPk" ::= "$VrfPk"
    }])) in
    (func_call #VrfSigEncode) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    (method_call #(ptrT.id cryptoffi.SigPrivateKey.id) #"Sign"%go (![#ptrT] "sk")) "$a0") in
    do:  ("sig" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "sig")).

Definition VerifyVrfSig : go_string := "github.com/sanjit-bhat/pav/ktcore.VerifyVrfSig"%go.

(* go: ktcore.go:48:6 *)
Definition VerifyVrfSigⁱᵐᵖˡ : val :=
  λ: "pk" "vrfPk" "sig",
    exception_do (let: "err" := (mem.alloc (type.zero_val #boolT)) in
    let: "sig" := (mem.alloc "sig") in
    let: "vrfPk" := (mem.alloc "vrfPk") in
    let: "pk" := (mem.alloc "pk") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make3 #byteT #(W64 0) (#(W64 (1 + 8)) + cryptoffi.HashLen)) in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (mem.alloc (let: "$SigTag" := VrfSigTag in
    let: "$VrfPk" := (![#sliceT] "vrfPk") in
    struct.make #VrfSig [{
      "SigTag" ::= "$SigTag";
      "VrfPk" ::= "$VrfPk"
    }])) in
    (func_call #VrfSigEncode) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    return: (let: "$a0" := (![#sliceT] "b") in
     let: "$a1" := (![#sliceT] "sig") in
     (method_call #cryptoffi.SigPublicKey.id #"Verify"%go (![#cryptoffi.SigPublicKey] "pk")) "$a0" "$a1")).

Definition SignLink : go_string := "github.com/sanjit-bhat/pav/ktcore.SignLink"%go.

Definition LinkSigEncode : go_string := "github.com/sanjit-bhat/pav/ktcore.LinkSigEncode"%go.

Definition LinkSig : go_type := structT [
  "SigTag" :: byteT;
  "Epoch" :: uint64T;
  "Link" :: sliceT
].

Definition LinkSigTag : expr := #(W8 1).

(* go: ktcore.go:54:6 *)
Definition SignLinkⁱᵐᵖˡ : val :=
  λ: "sk" "epoch" "link",
    exception_do (let: "sig" := (mem.alloc (type.zero_val #sliceT)) in
    let: "link" := (mem.alloc "link") in
    let: "epoch" := (mem.alloc "epoch") in
    let: "sk" := (mem.alloc "sk") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make3 #byteT #(W64 0) (#(W64 ((1 + 8) + 8)) + cryptoffi.HashLen)) in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (mem.alloc (let: "$SigTag" := LinkSigTag in
    let: "$Epoch" := (![#uint64T] "epoch") in
    let: "$Link" := (![#sliceT] "link") in
    struct.make #LinkSig [{
      "SigTag" ::= "$SigTag";
      "Epoch" ::= "$Epoch";
      "Link" ::= "$Link"
    }])) in
    (func_call #LinkSigEncode) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    (method_call #(ptrT.id cryptoffi.SigPrivateKey.id) #"Sign"%go (![#ptrT] "sk")) "$a0") in
    do:  ("sig" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "sig")).

Definition VerifyLinkSig : go_string := "github.com/sanjit-bhat/pav/ktcore.VerifyLinkSig"%go.

(* go: ktcore.go:62:6 *)
Definition VerifyLinkSigⁱᵐᵖˡ : val :=
  λ: "pk" "epoch" "link" "sig",
    exception_do (let: "err" := (mem.alloc (type.zero_val #boolT)) in
    let: "sig" := (mem.alloc "sig") in
    let: "link" := (mem.alloc "link") in
    let: "epoch" := (mem.alloc "epoch") in
    let: "pk" := (mem.alloc "pk") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make3 #byteT #(W64 0) (#(W64 ((1 + 8) + 8)) + cryptoffi.HashLen)) in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (mem.alloc (let: "$SigTag" := LinkSigTag in
    let: "$Epoch" := (![#uint64T] "epoch") in
    let: "$Link" := (![#sliceT] "link") in
    struct.make #LinkSig [{
      "SigTag" ::= "$SigTag";
      "Epoch" ::= "$Epoch";
      "Link" ::= "$Link"
    }])) in
    (func_call #LinkSigEncode) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    return: (let: "$a0" := (![#sliceT] "b") in
     let: "$a1" := (![#sliceT] "sig") in
     (method_call #cryptoffi.SigPublicKey.id #"Verify"%go (![#cryptoffi.SigPublicKey] "pk")) "$a0" "$a1")).

Definition ProveMapLabel : go_string := "github.com/sanjit-bhat/pav/ktcore.ProveMapLabel"%go.

Definition MapLabelEncode : go_string := "github.com/sanjit-bhat/pav/ktcore.MapLabelEncode"%go.

Definition MapLabel : go_type := structT [
  "Uid" :: uint64T;
  "Ver" :: uint64T
].

(* go: ktcore.go:68:6 *)
Definition ProveMapLabelⁱᵐᵖˡ : val :=
  λ: "uid" "ver" "sk",
    exception_do (let: "proof" := (mem.alloc (type.zero_val #sliceT)) in
    let: "label" := (mem.alloc (type.zero_val #sliceT)) in
    let: "sk" := (mem.alloc "sk") in
    let: "ver" := (mem.alloc "ver") in
    let: "uid" := (mem.alloc "uid") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make3 #byteT #(W64 0) #(W64 16)) in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (mem.alloc (let: "$Uid" := (![#uint64T] "uid") in
    let: "$Ver" := (![#uint64T] "ver") in
    struct.make #MapLabel [{
      "Uid" ::= "$Uid";
      "Ver" ::= "$Ver"
    }])) in
    (func_call #MapLabelEncode) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: ("$ret0", "$ret1") := ((let: "$a0" := (![#sliceT] "b") in
    (method_call #(ptrT.id cryptoffi.VrfPrivateKey.id) #"Prove"%go (![#ptrT] "sk")) "$a0")) in
    return: ("$ret0", "$ret1")).

Definition EvalMapLabel : go_string := "github.com/sanjit-bhat/pav/ktcore.EvalMapLabel"%go.

(* go: ktcore.go:74:6 *)
Definition EvalMapLabelⁱᵐᵖˡ : val :=
  λ: "uid" "ver" "sk",
    exception_do (let: "label" := (mem.alloc (type.zero_val #sliceT)) in
    let: "sk" := (mem.alloc "sk") in
    let: "ver" := (mem.alloc "ver") in
    let: "uid" := (mem.alloc "uid") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make3 #byteT #(W64 0) #(W64 16)) in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (mem.alloc (let: "$Uid" := (![#uint64T] "uid") in
    let: "$Ver" := (![#uint64T] "ver") in
    struct.make #MapLabel [{
      "Uid" ::= "$Uid";
      "Ver" ::= "$Ver"
    }])) in
    (func_call #MapLabelEncode) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    return: (let: "$a0" := (![#sliceT] "b") in
     (method_call #(ptrT.id cryptoffi.VrfPrivateKey.id) #"Evaluate"%go (![#ptrT] "sk")) "$a0")).

Definition CheckMapLabel : go_string := "github.com/sanjit-bhat/pav/ktcore.CheckMapLabel"%go.

(* go: ktcore.go:80:6 *)
Definition CheckMapLabelⁱᵐᵖˡ : val :=
  λ: "pk" "uid" "ver" "proof",
    exception_do (let: "err" := (mem.alloc (type.zero_val #boolT)) in
    let: "label" := (mem.alloc (type.zero_val #sliceT)) in
    let: "proof" := (mem.alloc "proof") in
    let: "ver" := (mem.alloc "ver") in
    let: "uid" := (mem.alloc "uid") in
    let: "pk" := (mem.alloc "pk") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make3 #byteT #(W64 0) #(W64 16)) in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (mem.alloc (let: "$Uid" := (![#uint64T] "uid") in
    let: "$Ver" := (![#uint64T] "ver") in
    struct.make #MapLabel [{
      "Uid" ::= "$Uid";
      "Ver" ::= "$Ver"
    }])) in
    (func_call #MapLabelEncode) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: ("$ret0", "$ret1") := ((let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#sliceT] "proof") in
    (method_call #(ptrT.id cryptoffi.VrfPublicKey.id) #"Verify"%go (![#ptrT] "pk")) "$a0" "$a1")) in
    return: ("$ret0", "$ret1")).

Definition GetMapVal : go_string := "github.com/sanjit-bhat/pav/ktcore.GetMapVal"%go.

Definition CommitOpenEncode : go_string := "github.com/sanjit-bhat/pav/ktcore.CommitOpenEncode"%go.

Definition CommitOpen : go_type := structT [
  "Val" :: sliceT;
  "Rand" :: sliceT
].

(* go: ktcore.go:86:6 *)
Definition GetMapValⁱᵐᵖˡ : val :=
  λ: "pkOpen",
    exception_do (let: "val" := (mem.alloc (type.zero_val #sliceT)) in
    let: "pkOpen" := (mem.alloc "pkOpen") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make3 #byteT #(W64 0) (((#(W64 8) + (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref #CommitOpen #"Val"%go (![#ptrT] "pkOpen"))) in
    slice.len "$a0"))) + #(W64 8)) + cryptoffi.HashLen)) in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#ptrT] "pkOpen") in
    (func_call #CommitOpenEncode) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    return: (let: "$a0" := (![#sliceT] "b") in
     (func_call #cryptoutil.Hash) "$a0")).

Definition GetCommitRand : go_string := "github.com/sanjit-bhat/pav/ktcore.GetCommitRand"%go.

(* GetCommitRand computes the psuedo-random (wrt commitSecret) bits
   used in a mapVal commitment.

   go: ktcore.go:94:6 *)
Definition GetCommitRandⁱᵐᵖˡ : val :=
  λ: "commitSecret" "label",
    exception_do (let: "rand" := (mem.alloc (type.zero_val #sliceT)) in
    let: "label" := (mem.alloc "label") in
    let: "commitSecret" := (mem.alloc "commitSecret") in
    let: "hr" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := ((func_call #cryptoffi.NewHasher) #()) in
    do:  ("hr" <-[#ptrT] "$r0");;;
    do:  (let: "$a0" := (![#sliceT] "commitSecret") in
    (method_call #(ptrT.id cryptoffi.Hasher.id) #"Write"%go (![#ptrT] "hr")) "$a0");;;
    do:  (let: "$a0" := (![#sliceT] "label") in
    (method_call #(ptrT.id cryptoffi.Hasher.id) #"Write"%go (![#ptrT] "hr")) "$a0");;;
    return: (let: "$a0" := #slice.nil in
     (method_call #(ptrT.id cryptoffi.Hasher.id) #"Sum"%go (![#ptrT] "hr")) "$a0")).

Definition Memb : go_type := structT [
  "LabelProof" :: sliceT;
  "PkOpen" :: ptrT;
  "MerkleProof" :: sliceT
].

Definition NonMemb : go_type := structT [
  "LabelProof" :: sliceT;
  "MerkleProof" :: sliceT
].

Definition AuditProof : go_type := structT [
  "Updates" :: sliceT;
  "LinkSig" :: sliceT
].

Definition UpdateProof : go_type := structT [
  "MapLabel" :: sliceT;
  "MapVal" :: sliceT;
  "NonMembProof" :: sliceT
].

(* go: serde.out.go:10:6 *)
Definition VrfSigEncodeⁱᵐᵖˡ : val :=
  λ: "b0" "o",
    exception_do (let: "o" := (mem.alloc "o") in
    let: "b0" := (mem.alloc "b0") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "b0") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#byteT] (struct.field_ref #VrfSig #"SigTag"%go (![#ptrT] "o"))) in
    (func_call #safemarshal.WriteByte) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#sliceT] (struct.field_ref #VrfSig #"VrfPk"%go (![#ptrT] "o"))) in
    (func_call #safemarshal.WriteSlice1D) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "b")).

Definition VrfSigDecode : go_string := "github.com/sanjit-bhat/pav/ktcore.VrfSigDecode"%go.

(* go: serde.out.go:16:6 *)
Definition VrfSigDecodeⁱᵐᵖˡ : val :=
  λ: "b0",
    exception_do (let: "b0" := (mem.alloc "b0") in
    let: "err1" := (mem.alloc (type.zero_val #boolT)) in
    let: "b1" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a1" := (mem.alloc (type.zero_val #byteT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b0") in
    (func_call #safemarshal.ReadByte) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a1" <-[#byteT] "$r0");;;
    do:  ("b1" <-[#sliceT] "$r1");;;
    do:  ("err1" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err1"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err2" := (mem.alloc (type.zero_val #boolT)) in
    let: "b2" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a2" := (mem.alloc (type.zero_val #sliceT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b1") in
    (func_call #safemarshal.ReadSlice1D) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a2" <-[#sliceT] "$r0");;;
    do:  ("b2" <-[#sliceT] "$r1");;;
    do:  ("err2" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err2"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    return: (mem.alloc (let: "$SigTag" := (![#byteT] "a1") in
     let: "$VrfPk" := (![#sliceT] "a2") in
     struct.make #VrfSig [{
       "SigTag" ::= "$SigTag";
       "VrfPk" ::= "$VrfPk"
     }]), ![#sliceT] "b2", #false)).

(* go: serde.out.go:27:6 *)
Definition LinkSigEncodeⁱᵐᵖˡ : val :=
  λ: "b0" "o",
    exception_do (let: "o" := (mem.alloc "o") in
    let: "b0" := (mem.alloc "b0") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "b0") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#byteT] (struct.field_ref #LinkSig #"SigTag"%go (![#ptrT] "o"))) in
    (func_call #safemarshal.WriteByte) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#uint64T] (struct.field_ref #LinkSig #"Epoch"%go (![#ptrT] "o"))) in
    (func_call #marshal.WriteInt) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#sliceT] (struct.field_ref #LinkSig #"Link"%go (![#ptrT] "o"))) in
    (func_call #safemarshal.WriteSlice1D) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "b")).

Definition LinkSigDecode : go_string := "github.com/sanjit-bhat/pav/ktcore.LinkSigDecode"%go.

(* go: serde.out.go:34:6 *)
Definition LinkSigDecodeⁱᵐᵖˡ : val :=
  λ: "b0",
    exception_do (let: "b0" := (mem.alloc "b0") in
    let: "err1" := (mem.alloc (type.zero_val #boolT)) in
    let: "b1" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a1" := (mem.alloc (type.zero_val #byteT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b0") in
    (func_call #safemarshal.ReadByte) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a1" <-[#byteT] "$r0");;;
    do:  ("b1" <-[#sliceT] "$r1");;;
    do:  ("err1" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err1"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err2" := (mem.alloc (type.zero_val #boolT)) in
    let: "b2" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a2" := (mem.alloc (type.zero_val #uint64T)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b1") in
    (func_call #safemarshal.ReadInt) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a2" <-[#uint64T] "$r0");;;
    do:  ("b2" <-[#sliceT] "$r1");;;
    do:  ("err2" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err2"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err3" := (mem.alloc (type.zero_val #boolT)) in
    let: "b3" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a3" := (mem.alloc (type.zero_val #sliceT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b2") in
    (func_call #safemarshal.ReadSlice1D) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a3" <-[#sliceT] "$r0");;;
    do:  ("b3" <-[#sliceT] "$r1");;;
    do:  ("err3" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err3"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    return: (mem.alloc (let: "$SigTag" := (![#byteT] "a1") in
     let: "$Epoch" := (![#uint64T] "a2") in
     let: "$Link" := (![#sliceT] "a3") in
     struct.make #LinkSig [{
       "SigTag" ::= "$SigTag";
       "Epoch" ::= "$Epoch";
       "Link" ::= "$Link"
     }]), ![#sliceT] "b3", #false)).

(* go: serde.out.go:49:6 *)
Definition MapLabelEncodeⁱᵐᵖˡ : val :=
  λ: "b0" "o",
    exception_do (let: "o" := (mem.alloc "o") in
    let: "b0" := (mem.alloc "b0") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "b0") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#uint64T] (struct.field_ref #MapLabel #"Uid"%go (![#ptrT] "o"))) in
    (func_call #marshal.WriteInt) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#uint64T] (struct.field_ref #MapLabel #"Ver"%go (![#ptrT] "o"))) in
    (func_call #marshal.WriteInt) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "b")).

Definition MapLabelDecode : go_string := "github.com/sanjit-bhat/pav/ktcore.MapLabelDecode"%go.

(* go: serde.out.go:55:6 *)
Definition MapLabelDecodeⁱᵐᵖˡ : val :=
  λ: "b0",
    exception_do (let: "b0" := (mem.alloc "b0") in
    let: "err1" := (mem.alloc (type.zero_val #boolT)) in
    let: "b1" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a1" := (mem.alloc (type.zero_val #uint64T)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b0") in
    (func_call #safemarshal.ReadInt) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a1" <-[#uint64T] "$r0");;;
    do:  ("b1" <-[#sliceT] "$r1");;;
    do:  ("err1" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err1"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err2" := (mem.alloc (type.zero_val #boolT)) in
    let: "b2" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a2" := (mem.alloc (type.zero_val #uint64T)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b1") in
    (func_call #safemarshal.ReadInt) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a2" <-[#uint64T] "$r0");;;
    do:  ("b2" <-[#sliceT] "$r1");;;
    do:  ("err2" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err2"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    return: (mem.alloc (let: "$Uid" := (![#uint64T] "a1") in
     let: "$Ver" := (![#uint64T] "a2") in
     struct.make #MapLabel [{
       "Uid" ::= "$Uid";
       "Ver" ::= "$Ver"
     }]), ![#sliceT] "b2", #false)).

(* go: serde.out.go:66:6 *)
Definition CommitOpenEncodeⁱᵐᵖˡ : val :=
  λ: "b0" "o",
    exception_do (let: "o" := (mem.alloc "o") in
    let: "b0" := (mem.alloc "b0") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "b0") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#sliceT] (struct.field_ref #CommitOpen #"Val"%go (![#ptrT] "o"))) in
    (func_call #safemarshal.WriteSlice1D) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#sliceT] (struct.field_ref #CommitOpen #"Rand"%go (![#ptrT] "o"))) in
    (func_call #safemarshal.WriteSlice1D) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "b")).

Definition CommitOpenDecode : go_string := "github.com/sanjit-bhat/pav/ktcore.CommitOpenDecode"%go.

(* go: serde.out.go:72:6 *)
Definition CommitOpenDecodeⁱᵐᵖˡ : val :=
  λ: "b0",
    exception_do (let: "b0" := (mem.alloc "b0") in
    let: "err1" := (mem.alloc (type.zero_val #boolT)) in
    let: "b1" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a1" := (mem.alloc (type.zero_val #sliceT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b0") in
    (func_call #safemarshal.ReadSlice1D) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a1" <-[#sliceT] "$r0");;;
    do:  ("b1" <-[#sliceT] "$r1");;;
    do:  ("err1" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err1"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err2" := (mem.alloc (type.zero_val #boolT)) in
    let: "b2" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a2" := (mem.alloc (type.zero_val #sliceT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b1") in
    (func_call #safemarshal.ReadSlice1D) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a2" <-[#sliceT] "$r0");;;
    do:  ("b2" <-[#sliceT] "$r1");;;
    do:  ("err2" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err2"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    return: (mem.alloc (let: "$Val" := (![#sliceT] "a1") in
     let: "$Rand" := (![#sliceT] "a2") in
     struct.make #CommitOpen [{
       "Val" ::= "$Val";
       "Rand" ::= "$Rand"
     }]), ![#sliceT] "b2", #false)).

Definition MembEncode : go_string := "github.com/sanjit-bhat/pav/ktcore.MembEncode"%go.

(* go: serde.out.go:83:6 *)
Definition MembEncodeⁱᵐᵖˡ : val :=
  λ: "b0" "o",
    exception_do (let: "o" := (mem.alloc "o") in
    let: "b0" := (mem.alloc "b0") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "b0") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#sliceT] (struct.field_ref #Memb #"LabelProof"%go (![#ptrT] "o"))) in
    (func_call #safemarshal.WriteSlice1D) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#ptrT] (struct.field_ref #Memb #"PkOpen"%go (![#ptrT] "o"))) in
    (func_call #CommitOpenEncode) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#sliceT] (struct.field_ref #Memb #"MerkleProof"%go (![#ptrT] "o"))) in
    (func_call #safemarshal.WriteSlice1D) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "b")).

Definition MembDecode : go_string := "github.com/sanjit-bhat/pav/ktcore.MembDecode"%go.

(* go: serde.out.go:90:6 *)
Definition MembDecodeⁱᵐᵖˡ : val :=
  λ: "b0",
    exception_do (let: "b0" := (mem.alloc "b0") in
    let: "err1" := (mem.alloc (type.zero_val #boolT)) in
    let: "b1" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a1" := (mem.alloc (type.zero_val #sliceT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b0") in
    (func_call #safemarshal.ReadSlice1D) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a1" <-[#sliceT] "$r0");;;
    do:  ("b1" <-[#sliceT] "$r1");;;
    do:  ("err1" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err1"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err2" := (mem.alloc (type.zero_val #boolT)) in
    let: "b2" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a2" := (mem.alloc (type.zero_val #ptrT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b1") in
    (func_call #CommitOpenDecode) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a2" <-[#ptrT] "$r0");;;
    do:  ("b2" <-[#sliceT] "$r1");;;
    do:  ("err2" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err2"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err3" := (mem.alloc (type.zero_val #boolT)) in
    let: "b3" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a3" := (mem.alloc (type.zero_val #sliceT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b2") in
    (func_call #safemarshal.ReadSlice1D) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a3" <-[#sliceT] "$r0");;;
    do:  ("b3" <-[#sliceT] "$r1");;;
    do:  ("err3" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err3"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    return: (mem.alloc (let: "$LabelProof" := (![#sliceT] "a1") in
     let: "$PkOpen" := (![#ptrT] "a2") in
     let: "$MerkleProof" := (![#sliceT] "a3") in
     struct.make #Memb [{
       "LabelProof" ::= "$LabelProof";
       "PkOpen" ::= "$PkOpen";
       "MerkleProof" ::= "$MerkleProof"
     }]), ![#sliceT] "b3", #false)).

Definition NonMembEncode : go_string := "github.com/sanjit-bhat/pav/ktcore.NonMembEncode"%go.

(* go: serde.out.go:105:6 *)
Definition NonMembEncodeⁱᵐᵖˡ : val :=
  λ: "b0" "o",
    exception_do (let: "o" := (mem.alloc "o") in
    let: "b0" := (mem.alloc "b0") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "b0") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#sliceT] (struct.field_ref #NonMemb #"LabelProof"%go (![#ptrT] "o"))) in
    (func_call #safemarshal.WriteSlice1D) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#sliceT] (struct.field_ref #NonMemb #"MerkleProof"%go (![#ptrT] "o"))) in
    (func_call #safemarshal.WriteSlice1D) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "b")).

Definition NonMembDecode : go_string := "github.com/sanjit-bhat/pav/ktcore.NonMembDecode"%go.

(* go: serde.out.go:111:6 *)
Definition NonMembDecodeⁱᵐᵖˡ : val :=
  λ: "b0",
    exception_do (let: "b0" := (mem.alloc "b0") in
    let: "err1" := (mem.alloc (type.zero_val #boolT)) in
    let: "b1" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a1" := (mem.alloc (type.zero_val #sliceT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b0") in
    (func_call #safemarshal.ReadSlice1D) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a1" <-[#sliceT] "$r0");;;
    do:  ("b1" <-[#sliceT] "$r1");;;
    do:  ("err1" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err1"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err2" := (mem.alloc (type.zero_val #boolT)) in
    let: "b2" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a2" := (mem.alloc (type.zero_val #sliceT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b1") in
    (func_call #safemarshal.ReadSlice1D) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a2" <-[#sliceT] "$r0");;;
    do:  ("b2" <-[#sliceT] "$r1");;;
    do:  ("err2" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err2"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    return: (mem.alloc (let: "$LabelProof" := (![#sliceT] "a1") in
     let: "$MerkleProof" := (![#sliceT] "a2") in
     struct.make #NonMemb [{
       "LabelProof" ::= "$LabelProof";
       "MerkleProof" ::= "$MerkleProof"
     }]), ![#sliceT] "b2", #false)).

Definition AuditProofEncode : go_string := "github.com/sanjit-bhat/pav/ktcore.AuditProofEncode"%go.

Definition UpdateProofSlice1DEncode : go_string := "github.com/sanjit-bhat/pav/ktcore.UpdateProofSlice1DEncode"%go.

(* go: serde.out.go:122:6 *)
Definition AuditProofEncodeⁱᵐᵖˡ : val :=
  λ: "b0" "o",
    exception_do (let: "o" := (mem.alloc "o") in
    let: "b0" := (mem.alloc "b0") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "b0") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#sliceT] (struct.field_ref #AuditProof #"Updates"%go (![#ptrT] "o"))) in
    (func_call #UpdateProofSlice1DEncode) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#sliceT] (struct.field_ref #AuditProof #"LinkSig"%go (![#ptrT] "o"))) in
    (func_call #safemarshal.WriteSlice1D) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "b")).

Definition AuditProofDecode : go_string := "github.com/sanjit-bhat/pav/ktcore.AuditProofDecode"%go.

Definition UpdateProofSlice1DDecode : go_string := "github.com/sanjit-bhat/pav/ktcore.UpdateProofSlice1DDecode"%go.

(* go: serde.out.go:128:6 *)
Definition AuditProofDecodeⁱᵐᵖˡ : val :=
  λ: "b0",
    exception_do (let: "b0" := (mem.alloc "b0") in
    let: "err1" := (mem.alloc (type.zero_val #boolT)) in
    let: "b1" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a1" := (mem.alloc (type.zero_val #sliceT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b0") in
    (func_call #UpdateProofSlice1DDecode) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a1" <-[#sliceT] "$r0");;;
    do:  ("b1" <-[#sliceT] "$r1");;;
    do:  ("err1" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err1"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err2" := (mem.alloc (type.zero_val #boolT)) in
    let: "b2" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a2" := (mem.alloc (type.zero_val #sliceT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b1") in
    (func_call #safemarshal.ReadSlice1D) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a2" <-[#sliceT] "$r0");;;
    do:  ("b2" <-[#sliceT] "$r1");;;
    do:  ("err2" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err2"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    return: (mem.alloc (let: "$Updates" := (![#sliceT] "a1") in
     let: "$LinkSig" := (![#sliceT] "a2") in
     struct.make #AuditProof [{
       "Updates" ::= "$Updates";
       "LinkSig" ::= "$LinkSig"
     }]), ![#sliceT] "b2", #false)).

Definition UpdateProofEncode : go_string := "github.com/sanjit-bhat/pav/ktcore.UpdateProofEncode"%go.

(* go: serde.out.go:139:6 *)
Definition UpdateProofEncodeⁱᵐᵖˡ : val :=
  λ: "b0" "o",
    exception_do (let: "o" := (mem.alloc "o") in
    let: "b0" := (mem.alloc "b0") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "b0") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#sliceT] (struct.field_ref #UpdateProof #"MapLabel"%go (![#ptrT] "o"))) in
    (func_call #safemarshal.WriteSlice1D) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#sliceT] (struct.field_ref #UpdateProof #"MapVal"%go (![#ptrT] "o"))) in
    (func_call #safemarshal.WriteSlice1D) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (![#sliceT] (struct.field_ref #UpdateProof #"NonMembProof"%go (![#ptrT] "o"))) in
    (func_call #safemarshal.WriteSlice1D) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "b")).

Definition UpdateProofDecode : go_string := "github.com/sanjit-bhat/pav/ktcore.UpdateProofDecode"%go.

(* go: serde.out.go:146:6 *)
Definition UpdateProofDecodeⁱᵐᵖˡ : val :=
  λ: "b0",
    exception_do (let: "b0" := (mem.alloc "b0") in
    let: "err1" := (mem.alloc (type.zero_val #boolT)) in
    let: "b1" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a1" := (mem.alloc (type.zero_val #sliceT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b0") in
    (func_call #safemarshal.ReadSlice1D) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a1" <-[#sliceT] "$r0");;;
    do:  ("b1" <-[#sliceT] "$r1");;;
    do:  ("err1" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err1"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err2" := (mem.alloc (type.zero_val #boolT)) in
    let: "b2" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a2" := (mem.alloc (type.zero_val #sliceT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b1") in
    (func_call #safemarshal.ReadSlice1D) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a2" <-[#sliceT] "$r0");;;
    do:  ("b2" <-[#sliceT] "$r1");;;
    do:  ("err2" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err2"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    let: "err3" := (mem.alloc (type.zero_val #boolT)) in
    let: "b3" := (mem.alloc (type.zero_val #sliceT)) in
    let: "a3" := (mem.alloc (type.zero_val #sliceT)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b2") in
    (func_call #safemarshal.ReadSlice1D) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("a3" <-[#sliceT] "$r0");;;
    do:  ("b3" <-[#sliceT] "$r1");;;
    do:  ("err3" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err3"
    then return: (#null, #slice.nil, #true)
    else do:  #());;;
    return: (mem.alloc (let: "$MapLabel" := (![#sliceT] "a1") in
     let: "$MapVal" := (![#sliceT] "a2") in
     let: "$NonMembProof" := (![#sliceT] "a3") in
     struct.make #UpdateProof [{
       "MapLabel" ::= "$MapLabel";
       "MapVal" ::= "$MapVal";
       "NonMembProof" ::= "$NonMembProof"
     }]), ![#sliceT] "b3", #false)).

(* go: serde_misc.go:8:6 *)
Definition UpdateProofSlice1DEncodeⁱᵐᵖˡ : val :=
  λ: "b0" "o",
    exception_do (let: "o" := (mem.alloc "o") in
    let: "b0" := (mem.alloc "b0") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "b0") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (s_to_w64 (let: "$a0" := (![#sliceT] "o") in
    slice.len "$a0")) in
    (func_call #marshal.WriteInt) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$range" := (![#sliceT] "o") in
    (let: "e" := (mem.alloc (type.zero_val #ptrT)) in
    slice.for_range #ptrT "$range" (λ: "$key" "$value",
      do:  ("e" <-[#ptrT] "$value");;;
      do:  "$key";;;
      let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
      let: "$a1" := (![#ptrT] "e") in
      (func_call #UpdateProofEncode) "$a0" "$a1") in
      do:  ("b" <-[#sliceT] "$r0")));;;
    return: (![#sliceT] "b")).

(* go: serde_misc.go:17:6 *)
Definition UpdateProofSlice1DDecodeⁱᵐᵖˡ : val :=
  λ: "b0",
    exception_do (let: "b0" := (mem.alloc "b0") in
    let: "err1" := (mem.alloc (type.zero_val #boolT)) in
    let: "b1" := (mem.alloc (type.zero_val #sliceT)) in
    let: "length" := (mem.alloc (type.zero_val #uint64T)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b0") in
    (func_call #safemarshal.ReadInt) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("length" <-[#uint64T] "$r0");;;
    do:  ("b1" <-[#sliceT] "$r1");;;
    do:  ("err1" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err1"
    then return: (#slice.nil, #slice.nil, #true)
    else do:  #());;;
    let: "loopO" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make3 #ptrT #(W64 0) (![#uint64T] "length")) in
    do:  ("loopO" <-[#sliceT] "$r0");;;
    let: "loopErr" := (mem.alloc (type.zero_val #boolT)) in
    let: "loopB" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "b1") in
    do:  ("loopB" <-[#sliceT] "$r0");;;
    (let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (for: (λ: <>, (![#uint64T] "i") < (![#uint64T] "length")); (λ: <>, do:  ("i" <-[#uint64T] ((![#uint64T] "i") + #(W64 1)))) := λ: <>,
      let: "err2" := (mem.alloc (type.zero_val #boolT)) in
      let: "loopB1" := (mem.alloc (type.zero_val #sliceT)) in
      let: "a2" := (mem.alloc (type.zero_val #ptrT)) in
      let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "loopB") in
      (func_call #UpdateProofDecode) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      let: "$r2" := "$ret2" in
      do:  ("a2" <-[#ptrT] "$r0");;;
      do:  ("loopB1" <-[#sliceT] "$r1");;;
      do:  ("err2" <-[#boolT] "$r2");;;
      let: "$r0" := (![#sliceT] "loopB1") in
      do:  ("loopB" <-[#sliceT] "$r0");;;
      (if: ![#boolT] "err2"
      then
        let: "$r0" := #true in
        do:  ("loopErr" <-[#boolT] "$r0");;;
        break: #()
      else do:  #());;;
      let: "$r0" := (let: "$a0" := (![#sliceT] "loopO") in
      let: "$a1" := ((let: "$sl0" := (![#ptrT] "a2") in
      slice.literal #ptrT ["$sl0"])) in
      (slice.append #ptrT) "$a0" "$a1") in
      do:  ("loopO" <-[#sliceT] "$r0")));;;
    (if: ![#boolT] "loopErr"
    then return: (#slice.nil, #slice.nil, #true)
    else do:  #());;;
    return: (![#sliceT] "loopO", ![#sliceT] "loopB", #false)).

Definition MembSlice1DEncode : go_string := "github.com/sanjit-bhat/pav/ktcore.MembSlice1DEncode"%go.

(* go: serde_misc.go:40:6 *)
Definition MembSlice1DEncodeⁱᵐᵖˡ : val :=
  λ: "b0" "o",
    exception_do (let: "o" := (mem.alloc "o") in
    let: "b0" := (mem.alloc "b0") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "b0") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (s_to_w64 (let: "$a0" := (![#sliceT] "o") in
    slice.len "$a0")) in
    (func_call #marshal.WriteInt) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$range" := (![#sliceT] "o") in
    (let: "e" := (mem.alloc (type.zero_val #ptrT)) in
    slice.for_range #ptrT "$range" (λ: "$key" "$value",
      do:  ("e" <-[#ptrT] "$value");;;
      do:  "$key";;;
      let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
      let: "$a1" := (![#ptrT] "e") in
      (func_call #MembEncode) "$a0" "$a1") in
      do:  ("b" <-[#sliceT] "$r0")));;;
    return: (![#sliceT] "b")).

Definition MembSlice1DDecode : go_string := "github.com/sanjit-bhat/pav/ktcore.MembSlice1DDecode"%go.

(* go: serde_misc.go:49:6 *)
Definition MembSlice1DDecodeⁱᵐᵖˡ : val :=
  λ: "b0",
    exception_do (let: "b0" := (mem.alloc "b0") in
    let: "err1" := (mem.alloc (type.zero_val #boolT)) in
    let: "b1" := (mem.alloc (type.zero_val #sliceT)) in
    let: "length" := (mem.alloc (type.zero_val #uint64T)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b0") in
    (func_call #safemarshal.ReadInt) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("length" <-[#uint64T] "$r0");;;
    do:  ("b1" <-[#sliceT] "$r1");;;
    do:  ("err1" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err1"
    then return: (#slice.nil, #slice.nil, #true)
    else do:  #());;;
    let: "loopO" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make3 #ptrT #(W64 0) (![#uint64T] "length")) in
    do:  ("loopO" <-[#sliceT] "$r0");;;
    let: "loopErr" := (mem.alloc (type.zero_val #boolT)) in
    let: "loopB" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "b1") in
    do:  ("loopB" <-[#sliceT] "$r0");;;
    (let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (for: (λ: <>, (![#uint64T] "i") < (![#uint64T] "length")); (λ: <>, do:  ("i" <-[#uint64T] ((![#uint64T] "i") + #(W64 1)))) := λ: <>,
      let: "err2" := (mem.alloc (type.zero_val #boolT)) in
      let: "loopB1" := (mem.alloc (type.zero_val #sliceT)) in
      let: "a2" := (mem.alloc (type.zero_val #ptrT)) in
      let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "loopB") in
      (func_call #MembDecode) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      let: "$r2" := "$ret2" in
      do:  ("a2" <-[#ptrT] "$r0");;;
      do:  ("loopB1" <-[#sliceT] "$r1");;;
      do:  ("err2" <-[#boolT] "$r2");;;
      let: "$r0" := (![#sliceT] "loopB1") in
      do:  ("loopB" <-[#sliceT] "$r0");;;
      (if: ![#boolT] "err2"
      then
        let: "$r0" := #true in
        do:  ("loopErr" <-[#boolT] "$r0");;;
        break: #()
      else do:  #());;;
      let: "$r0" := (let: "$a0" := (![#sliceT] "loopO") in
      let: "$a1" := ((let: "$sl0" := (![#ptrT] "a2") in
      slice.literal #ptrT ["$sl0"])) in
      (slice.append #ptrT) "$a0" "$a1") in
      do:  ("loopO" <-[#sliceT] "$r0")));;;
    (if: ![#boolT] "loopErr"
    then return: (#slice.nil, #slice.nil, #true)
    else do:  #());;;
    return: (![#sliceT] "loopO", ![#sliceT] "loopB", #false)).

Definition AuditProofSlice1DEncode : go_string := "github.com/sanjit-bhat/pav/ktcore.AuditProofSlice1DEncode"%go.

(* go: serde_misc.go:72:6 *)
Definition AuditProofSlice1DEncodeⁱᵐᵖˡ : val :=
  λ: "b0" "o",
    exception_do (let: "o" := (mem.alloc "o") in
    let: "b0" := (mem.alloc "b0") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "b0") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (s_to_w64 (let: "$a0" := (![#sliceT] "o") in
    slice.len "$a0")) in
    (func_call #marshal.WriteInt) "$a0" "$a1") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "$range" := (![#sliceT] "o") in
    (let: "e" := (mem.alloc (type.zero_val #ptrT)) in
    slice.for_range #ptrT "$range" (λ: "$key" "$value",
      do:  ("e" <-[#ptrT] "$value");;;
      do:  "$key";;;
      let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
      let: "$a1" := (![#ptrT] "e") in
      (func_call #AuditProofEncode) "$a0" "$a1") in
      do:  ("b" <-[#sliceT] "$r0")));;;
    return: (![#sliceT] "b")).

Definition AuditProofSlice1DDecode : go_string := "github.com/sanjit-bhat/pav/ktcore.AuditProofSlice1DDecode"%go.

(* go: serde_misc.go:81:6 *)
Definition AuditProofSlice1DDecodeⁱᵐᵖˡ : val :=
  λ: "b0",
    exception_do (let: "b0" := (mem.alloc "b0") in
    let: "err1" := (mem.alloc (type.zero_val #boolT)) in
    let: "b1" := (mem.alloc (type.zero_val #sliceT)) in
    let: "length" := (mem.alloc (type.zero_val #uint64T)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "b0") in
    (func_call #safemarshal.ReadInt) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("length" <-[#uint64T] "$r0");;;
    do:  ("b1" <-[#sliceT] "$r1");;;
    do:  ("err1" <-[#boolT] "$r2");;;
    (if: ![#boolT] "err1"
    then return: (#slice.nil, #slice.nil, #true)
    else do:  #());;;
    let: "loopO" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make3 #ptrT #(W64 0) (![#uint64T] "length")) in
    do:  ("loopO" <-[#sliceT] "$r0");;;
    let: "loopErr" := (mem.alloc (type.zero_val #boolT)) in
    let: "loopB" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "b1") in
    do:  ("loopB" <-[#sliceT] "$r0");;;
    (let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (for: (λ: <>, (![#uint64T] "i") < (![#uint64T] "length")); (λ: <>, do:  ("i" <-[#uint64T] ((![#uint64T] "i") + #(W64 1)))) := λ: <>,
      let: "err2" := (mem.alloc (type.zero_val #boolT)) in
      let: "loopB1" := (mem.alloc (type.zero_val #sliceT)) in
      let: "a2" := (mem.alloc (type.zero_val #ptrT)) in
      let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "loopB") in
      (func_call #AuditProofDecode) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      let: "$r2" := "$ret2" in
      do:  ("a2" <-[#ptrT] "$r0");;;
      do:  ("loopB1" <-[#sliceT] "$r1");;;
      do:  ("err2" <-[#boolT] "$r2");;;
      let: "$r0" := (![#sliceT] "loopB1") in
      do:  ("loopB" <-[#sliceT] "$r0");;;
      (if: ![#boolT] "err2"
      then
        let: "$r0" := #true in
        do:  ("loopErr" <-[#boolT] "$r0");;;
        break: #()
      else do:  #());;;
      let: "$r0" := (let: "$a0" := (![#sliceT] "loopO") in
      let: "$a1" := ((let: "$sl0" := (![#ptrT] "a2") in
      slice.literal #ptrT ["$sl0"])) in
      (slice.append #ptrT) "$a0" "$a1") in
      do:  ("loopO" <-[#sliceT] "$r0")));;;
    (if: ![#boolT] "loopErr"
    then return: (#slice.nil, #slice.nil, #true)
    else do:  #());;;
    return: (![#sliceT] "loopO", ![#sliceT] "loopB", #false)).

Definition vars' : list (go_string * go_type) := [].

Definition functions' : list (go_string * val) := [(CheckBlame, CheckBlameⁱᵐᵖˡ); (SignVrf, SignVrfⁱᵐᵖˡ); (VerifyVrfSig, VerifyVrfSigⁱᵐᵖˡ); (SignLink, SignLinkⁱᵐᵖˡ); (VerifyLinkSig, VerifyLinkSigⁱᵐᵖˡ); (ProveMapLabel, ProveMapLabelⁱᵐᵖˡ); (EvalMapLabel, EvalMapLabelⁱᵐᵖˡ); (CheckMapLabel, CheckMapLabelⁱᵐᵖˡ); (GetMapVal, GetMapValⁱᵐᵖˡ); (GetCommitRand, GetCommitRandⁱᵐᵖˡ); (VrfSigEncode, VrfSigEncodeⁱᵐᵖˡ); (VrfSigDecode, VrfSigDecodeⁱᵐᵖˡ); (LinkSigEncode, LinkSigEncodeⁱᵐᵖˡ); (LinkSigDecode, LinkSigDecodeⁱᵐᵖˡ); (MapLabelEncode, MapLabelEncodeⁱᵐᵖˡ); (MapLabelDecode, MapLabelDecodeⁱᵐᵖˡ); (CommitOpenEncode, CommitOpenEncodeⁱᵐᵖˡ); (CommitOpenDecode, CommitOpenDecodeⁱᵐᵖˡ); (MembEncode, MembEncodeⁱᵐᵖˡ); (MembDecode, MembDecodeⁱᵐᵖˡ); (NonMembEncode, NonMembEncodeⁱᵐᵖˡ); (NonMembDecode, NonMembDecodeⁱᵐᵖˡ); (AuditProofEncode, AuditProofEncodeⁱᵐᵖˡ); (AuditProofDecode, AuditProofDecodeⁱᵐᵖˡ); (UpdateProofEncode, UpdateProofEncodeⁱᵐᵖˡ); (UpdateProofDecode, UpdateProofDecodeⁱᵐᵖˡ); (UpdateProofSlice1DEncode, UpdateProofSlice1DEncodeⁱᵐᵖˡ); (UpdateProofSlice1DDecode, UpdateProofSlice1DDecodeⁱᵐᵖˡ); (MembSlice1DEncode, MembSlice1DEncodeⁱᵐᵖˡ); (MembSlice1DDecode, MembSlice1DDecodeⁱᵐᵖˡ); (AuditProofSlice1DEncode, AuditProofSlice1DEncodeⁱᵐᵖˡ); (AuditProofSlice1DDecode, AuditProofSlice1DDecodeⁱᵐᵖˡ)].

Definition msets' : list (go_string * (list (go_string * val))) := [(Blame.id, []); (ptrT.id Blame.id, []); (VrfSig.id, []); (ptrT.id VrfSig.id, []); (LinkSig.id, []); (ptrT.id LinkSig.id, []); (MapLabel.id, []); (ptrT.id MapLabel.id, []); (CommitOpen.id, []); (ptrT.id CommitOpen.id, []); (Memb.id, []); (ptrT.id Memb.id, []); (NonMemb.id, []); (ptrT.id NonMemb.id, []); (AuditProof.id, []); (ptrT.id AuditProof.id, []); (UpdateProof.id, []); (ptrT.id UpdateProof.id, [])].

#[global] Instance info' : PkgInfo ktcore.ktcore :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [github_com.sanjit_bhat.pav.cryptoffi.cryptoffi; github_com.sanjit_bhat.pav.cryptoutil.cryptoutil; github_com.sanjit_bhat.pav.safemarshal.safemarshal; github_com.tchajed.marshal.marshal];
  |}.

Definition initialize' : val :=
  λ: <>,
    package.init #ktcore.ktcore (λ: <>,
      exception_do (do:  (marshal.initialize' #());;;
      do:  (safemarshal.initialize' #());;;
      do:  (cryptoutil.initialize' #());;;
      do:  (cryptoffi.initialize' #());;;
      do:  (package.alloc ktcore.ktcore #()))
      ).

End code.
End ktcore.
