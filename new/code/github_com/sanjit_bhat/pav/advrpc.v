(* autogenerated from github.com/sanjit-bhat/pav/advrpc *)
Require Export New.code.github_com.sanjit_bhat.pav.netffi.
Require Export New.code.github_com.sanjit_bhat.pav.safemarshal.
Require Export New.code.github_com.tchajed.marshal.

From New.golang Require Import defn.
Definition advrpc : go_string := "github.com/sanjit-bhat/pav/advrpc".

Module advrpc.

Section code.
Context `{ffi_syntax}.


Definition Serverⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "handlers"%go (go.MapType go.uint64 (go.FunctionType (go.Signature [go.SliceType go.byte; go.PointerType (go.SliceType go.byte)] #false []))))
].

Definition Server : go.type := go.Named "github.com/sanjit-bhat/pav/advrpc.Server"%go [].

(* go: advrpc.go:19:18 *)
Definition Server__handleⁱᵐᵖˡ : val :=
  λ: "s" "conn" "rpcId" "data",
    exception_do (let: "s" := (go.AllocValue (go.PointerType Server) "s") in
    let: "data" := (go.AllocValue (go.SliceType go.byte) "data") in
    let: "rpcId" := (go.AllocValue go.uint64 "rpcId") in
    let: "conn" := (go.AllocValue (go.PointerType netffi.Conn) "conn") in
    let: "ok0" := (GoAlloc go.bool #()) in
    let: "f" := (GoAlloc (go.FunctionType (go.Signature [go.SliceType go.byte; go.PointerType (go.SliceType go.byte)] #false [])) #()) in
    let: ("$ret0", "$ret1") := (map.get (![go.MapType go.uint64 (go.FunctionType (go.Signature [go.SliceType go.byte; go.PointerType (go.SliceType go.byte)] #false []))] (StructFieldRef Server "handlers"%go (![go.PointerType Server] "s"))) (![go.uint64] "rpcId")) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("f" <-[go.FunctionType (go.Signature [go.SliceType go.byte; go.PointerType (go.SliceType go.byte)] #false [])] "$r0");;;
    do:  ("ok0" <-[go.bool] "$r1");;;
    (if: (~ (![go.bool] "ok0"))
    then return: (#())
    else do:  #());;;
    let: "resp" := (GoAlloc (go.PointerType (go.SliceType go.byte)) #()) in
    let: "$r0" := (GoAlloc (go.SliceType go.byte) #()) in
    do:  ("resp" <-[go.PointerType (go.SliceType go.byte)] "$r0");;;
    do:  (let: "$a0" := (![go.SliceType go.byte] "data") in
    let: "$a1" := (![go.PointerType (go.SliceType go.byte)] "resp") in
    (![go.FunctionType (go.Signature [go.SliceType go.byte; go.PointerType (go.SliceType go.byte)] #false [])] "f") "$a0" "$a1");;;
    do:  (let: "$a0" := (![go.SliceType go.byte] (![go.PointerType (go.SliceType go.byte)] "resp")) in
    (MethodResolve (go.PointerType netffi.Conn) Send #() (![go.PointerType netffi.Conn] "conn")) "$a0");;;
    return: #()).

(* go: advrpc.go:31:18 *)
Definition Server__readⁱᵐᵖˡ : val :=
  λ: "s" "conn",
    exception_do (let: "s" := (go.AllocValue (go.PointerType Server) "s") in
    let: "conn" := (go.AllocValue (go.PointerType netffi.Conn) "conn") in
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "err0" := (GoAlloc go.bool #()) in
      let: "req" := (GoAlloc (go.SliceType go.byte) #()) in
      let: ("$ret0", "$ret1") := ((MethodResolve (go.PointerType netffi.Conn) Receive #() (![go.PointerType netffi.Conn] "conn")) #()) in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("req" <-[go.SliceType go.byte] "$r0");;;
      do:  ("err0" <-[go.bool] "$r1");;;
      (if: ![go.bool] "err0"
      then break: #()
      else do:  #());;;
      let: "err1" := (GoAlloc go.bool #()) in
      let: "data" := (GoAlloc (go.SliceType go.byte) #()) in
      let: "rpcId" := (GoAlloc go.uint64 #()) in
      let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.SliceType go.byte] "req") in
      (FuncResolve safemarshal.ReadInt [] #()) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      let: "$r2" := "$ret2" in
      do:  ("rpcId" <-[go.uint64] "$r0");;;
      do:  ("data" <-[go.SliceType go.byte] "$r1");;;
      do:  ("err1" <-[go.bool] "$r2");;;
      (if: ![go.bool] "err1"
      then continue: #()
      else do:  #());;;
      let: "$go" := (λ: <>,
        exception_do (do:  (let: "$a0" := (![go.PointerType netffi.Conn] "conn") in
        let: "$a1" := (![go.uint64] "rpcId") in
        let: "$a2" := (![go.SliceType go.byte] "data") in
        (MethodResolve (go.PointerType Server) handle #() (![go.PointerType Server] "s")) "$a0" "$a1" "$a2");;;
        return: #())
        ) in
      do:  (Fork ("$go" #())));;;
    return: #()).

(* go: advrpc.go:49:18 *)
Definition Server__Serveⁱᵐᵖˡ : val :=
  λ: "s" "addr",
    exception_do (let: "s" := (go.AllocValue (go.PointerType Server) "s") in
    let: "addr" := (go.AllocValue go.uint64 "addr") in
    let: "l" := (GoAlloc (go.PointerType netffi.Listener) #()) in
    let: "$r0" := (let: "$a0" := (![go.uint64] "addr") in
    (FuncResolve netffi.Listen [] #()) "$a0") in
    do:  ("l" <-[go.PointerType netffi.Listener] "$r0");;;
    let: "$go" := (λ: <>,
      exception_do ((for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
        let: "conn" := (GoAlloc (go.PointerType netffi.Conn) #()) in
        let: "$r0" := ((MethodResolve (go.PointerType netffi.Listener) Accept #() (![go.PointerType netffi.Listener] "l")) #()) in
        do:  ("conn" <-[go.PointerType netffi.Conn] "$r0");;;
        let: "$go" := (λ: <>,
          exception_do (do:  (let: "$a0" := (![go.PointerType netffi.Conn] "conn") in
          (MethodResolve (go.PointerType Server) read #() (![go.PointerType Server] "s")) "$a0");;;
          return: #())
          ) in
        do:  (Fork ("$go" #())));;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    return: #()).

Definition NewServer : go_string := "github.com/sanjit-bhat/pav/advrpc.NewServer"%go.

(* go: advrpc.go:61:6 *)
Definition NewServerⁱᵐᵖˡ : val :=
  λ: "handlers",
    exception_do (let: "handlers" := (go.AllocValue (go.MapType go.uint64 (go.FunctionType (go.Signature [go.SliceType go.byte; go.PointerType (go.SliceType go.byte)] #false []))) "handlers") in
    return: (go.AllocValue Server (let: "$handlers" := (![go.MapType go.uint64 (go.FunctionType (go.Signature [go.SliceType go.byte; go.PointerType (go.SliceType go.byte)] #false []))] "handlers") in
     CompositeLiteral Server (
       let: "$$vs" := go.StructElementListNil #() in 
       let: "$$vs" := go.ElementListApp "$$vs" "$handlers" in
       "$$vs"
     )))).

Definition Clientⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "conn"%go (go.PointerType netffi.Conn))
].

Definition Dial : go_string := "github.com/sanjit-bhat/pav/advrpc.Dial"%go.

Definition Client : go.type := go.Named "github.com/sanjit-bhat/pav/advrpc.Client"%go [].

(* go: advrpc.go:72:6 *)
Definition Dialⁱᵐᵖˡ : val :=
  λ: "addr",
    exception_do (let: "addr" := (go.AllocValue go.uint64 "addr") in
    let: "c" := (GoAlloc (go.PointerType netffi.Conn) #()) in
    let: "$r0" := (let: "$a0" := (![go.uint64] "addr") in
    (FuncResolve netffi.Dial [] #()) "$a0") in
    do:  ("c" <-[go.PointerType netffi.Conn] "$r0");;;
    return: (go.AllocValue Client (let: "$conn" := (![go.PointerType netffi.Conn] "c") in
     CompositeLiteral Client (
       let: "$$vs" := go.StructElementListNil #() in 
       let: "$$vs" := go.ElementListApp "$$vs" "$conn" in
       "$$vs"
     )))).

(* Call does an rpc.

   go: advrpc.go:78:18 *)
Definition Client__Callⁱᵐᵖˡ : val :=
  λ: "c" "rpcId" "args" "reply",
    exception_do (let: "err" := (GoAlloc go.bool #()) in
    let: "c" := (go.AllocValue (go.PointerType Client) "c") in
    let: "reply" := (go.AllocValue (go.PointerType (go.SliceType go.byte)) "reply") in
    let: "args" := (go.AllocValue (go.SliceType go.byte) "args") in
    let: "rpcId" := (go.AllocValue go.uint64 "rpcId") in
    let: "req0" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := ((FuncResolve go.make3 [go.SliceType go.byte] #()) #(W64 0) (#(W64 8) +⟨go.int⟩ (let: "$a0" := (![go.SliceType go.byte] "args") in
    (FuncResolve go.len [go.SliceType go.byte] #()) "$a0"))) in
    do:  ("req0" <-[go.SliceType go.byte] "$r0");;;
    let: "req1" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "req0") in
    let: "$a1" := (![go.uint64] "rpcId") in
    (FuncResolve marshal.WriteInt [] #()) "$a0" "$a1") in
    do:  ("req1" <-[go.SliceType go.byte] "$r0");;;
    let: "req2" := (GoAlloc (go.SliceType go.byte) #()) in
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "req1") in
    let: "$a1" := (![go.SliceType go.byte] "args") in
    (FuncResolve marshal.WriteBytes [] #()) "$a0" "$a1") in
    do:  ("req2" <-[go.SliceType go.byte] "$r0");;;
    (if: let: "$a0" := (![go.SliceType go.byte] "req2") in
    (MethodResolve (go.PointerType netffi.Conn) Send #() (![go.PointerType netffi.Conn] (StructFieldRef Client "conn"%go (![go.PointerType Client] "c")))) "$a0"
    then return: (#true)
    else do:  #());;;
    let: "err0" := (GoAlloc go.bool #()) in
    let: "resp" := (GoAlloc (go.SliceType go.byte) #()) in
    let: ("$ret0", "$ret1") := ((MethodResolve (go.PointerType netffi.Conn) Receive #() (![go.PointerType netffi.Conn] (StructFieldRef Client "conn"%go (![go.PointerType Client] "c")))) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("resp" <-[go.SliceType go.byte] "$r0");;;
    do:  ("err0" <-[go.bool] "$r1");;;
    (if: ![go.bool] "err0"
    then return: (#true)
    else do:  #());;;
    let: "$r0" := (![go.SliceType go.byte] "resp") in
    do:  ((![go.PointerType (go.SliceType go.byte)] "reply") <-[go.SliceType go.byte] "$r0");;;
    return: (#false)).

Definition functions' : list (go_string * val) := [(NewServer, NewServerⁱᵐᵖˡ); (Dial, Dialⁱᵐᵖˡ)].

#[global] Instance info' : PkgInfo advrpc.advrpc :=
  {|
    pkg_imported_pkgs := [code.github_com.sanjit_bhat.pav.netffi.netffi; code.github_com.sanjit_bhat.pav.safemarshal.safemarshal; code.github_com.tchajed.marshal.marshal];
  |}.

Definition initialize' : val :=
  λ: <>,
    package.init advrpc.advrpc (λ: <>,
      exception_do (do:  (marshal.initialize' #());;;
      do:  (safemarshal.initialize' #());;;
      do:  (netffi.initialize' #()))
      ).

End code.
End advrpc.
