(* autogenerated from github.com/sanjit-bhat/pav/advrpc *)
From New.golang Require Import defn.
Require Export New.code.github_com.sanjit_bhat.pav.netffi.
Require Export New.code.github_com.sanjit_bhat.pav.safemarshal.
Require Export New.code.github_com.tchajed.marshal.

Definition advrpc : go_string := "github.com/sanjit-bhat/pav/advrpc".

Module advrpc.
Section code.
Context `{ffi_syntax}.


Definition Server : go_type := structT [
  "handlers" :: mapT uint64T funcT
].

(* go: advrpc.go:19:18 *)
Definition Server__handle : val :=
  rec: "Server__handle" "s" "conn" "rpcId" "data" :=
    exception_do (let: "s" := (mem.alloc "s") in
    let: "data" := (mem.alloc "data") in
    let: "rpcId" := (mem.alloc "rpcId") in
    let: "conn" := (mem.alloc "conn") in
    let: "ok0" := (mem.alloc (type.zero_val #boolT)) in
    let: "f" := (mem.alloc (type.zero_val #funcT)) in
    let: ("$ret0", "$ret1") := (map.get (![type.mapT #uint64T #funcT] (struct.field_ref #Server #"handlers"%go (![#ptrT] "s"))) (![#uint64T] "rpcId")) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("f" <-[#funcT] "$r0");;;
    do:  ("ok0" <-[#boolT] "$r1");;;
    (if: (~ (![#boolT] "ok0"))
    then return: (#())
    else do:  #());;;
    let: "resp" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #sliceT)) in
    do:  ("resp" <-[#ptrT] "$r0");;;
    do:  (let: "$a0" := (![#sliceT] "data") in
    let: "$a1" := (![#ptrT] "resp") in
    (![#funcT] "f") "$a0" "$a1");;;
    do:  (let: "$a0" := (![#sliceT] (![#ptrT] "resp")) in
    (method_call #netffi #"Conn'ptr" #"Send" (![#ptrT] "conn")) "$a0");;;
    return: #()).

(* go: advrpc.go:31:18 *)
Definition Server__read : val :=
  rec: "Server__read" "s" "conn" :=
    exception_do (let: "s" := (mem.alloc "s") in
    let: "conn" := (mem.alloc "conn") in
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "err0" := (mem.alloc (type.zero_val #boolT)) in
      let: "req" := (mem.alloc (type.zero_val #sliceT)) in
      let: ("$ret0", "$ret1") := ((method_call #netffi #"Conn'ptr" #"Receive" (![#ptrT] "conn")) #()) in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("req" <-[#sliceT] "$r0");;;
      do:  ("err0" <-[#boolT] "$r1");;;
      (if: ![#boolT] "err0"
      then break: #()
      else do:  #());;;
      let: "err1" := (mem.alloc (type.zero_val #boolT)) in
      let: "data" := (mem.alloc (type.zero_val #sliceT)) in
      let: "rpcId" := (mem.alloc (type.zero_val #uint64T)) in
      let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![#sliceT] "req") in
      (func_call #safemarshal.safemarshal #"ReadInt"%go) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      let: "$r2" := "$ret2" in
      do:  ("rpcId" <-[#uint64T] "$r0");;;
      do:  ("data" <-[#sliceT] "$r1");;;
      do:  ("err1" <-[#boolT] "$r2");;;
      (if: ![#boolT] "err1"
      then continue: #()
      else do:  #());;;
      let: "$go" := (λ: <>,
        exception_do (do:  (let: "$a0" := (![#ptrT] "conn") in
        let: "$a1" := (![#uint64T] "rpcId") in
        let: "$a2" := (![#sliceT] "data") in
        (method_call #advrpc.advrpc #"Server'ptr" #"handle" (![#ptrT] "s")) "$a0" "$a1" "$a2");;;
        return: #())
        ) in
      do:  (Fork ("$go" #())));;;
    return: #()).

(* go: advrpc.go:49:18 *)
Definition Server__Serve : val :=
  rec: "Server__Serve" "s" "addr" :=
    exception_do (let: "s" := (mem.alloc "s") in
    let: "addr" := (mem.alloc "addr") in
    let: "l" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := (![#uint64T] "addr") in
    (func_call #netffi.netffi #"Listen"%go) "$a0") in
    do:  ("l" <-[#ptrT] "$r0");;;
    let: "$go" := (λ: <>,
      exception_do ((for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
        let: "conn" := (mem.alloc (type.zero_val #ptrT)) in
        let: "$r0" := ((method_call #netffi #"Listener'ptr" #"Accept" (![#ptrT] "l")) #()) in
        do:  ("conn" <-[#ptrT] "$r0");;;
        let: "$go" := (λ: <>,
          exception_do (do:  (let: "$a0" := (![#ptrT] "conn") in
          (method_call #advrpc.advrpc #"Server'ptr" #"read" (![#ptrT] "s")) "$a0");;;
          return: #())
          ) in
        do:  (Fork ("$go" #())));;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    return: #()).

(* go: advrpc.go:61:6 *)
Definition NewServer : val :=
  rec: "NewServer" "handlers" :=
    exception_do (let: "handlers" := (mem.alloc "handlers") in
    return: (mem.alloc (let: "$handlers" := (![type.mapT #uint64T #funcT] "handlers") in
     struct.make #Server [{
       "handlers" ::= "$handlers"
     }]))).

Definition Client : go_type := structT [
  "conn" :: ptrT
].

(* go: advrpc.go:72:6 *)
Definition Dial : val :=
  rec: "Dial" "addr" :=
    exception_do (let: "addr" := (mem.alloc "addr") in
    let: "c" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := (![#uint64T] "addr") in
    (func_call #netffi.netffi #"Dial"%go) "$a0") in
    do:  ("c" <-[#ptrT] "$r0");;;
    return: (mem.alloc (let: "$conn" := (![#ptrT] "c") in
     struct.make #Client [{
       "conn" ::= "$conn"
     }]))).

(* Call does an rpc.

   go: advrpc.go:78:18 *)
Definition Client__Call : val :=
  rec: "Client__Call" "c" "rpcId" "args" "reply" :=
    exception_do (let: "err" := (mem.alloc (type.zero_val #boolT)) in
    let: "c" := (mem.alloc "c") in
    let: "reply" := (mem.alloc "reply") in
    let: "args" := (mem.alloc "args") in
    let: "rpcId" := (mem.alloc "rpcId") in
    let: "req0" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make3 #byteT #(W64 0) (#(W64 8) + (let: "$a0" := (![#sliceT] "args") in
    slice.len "$a0"))) in
    do:  ("req0" <-[#sliceT] "$r0");;;
    let: "req1" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "req0") in
    let: "$a1" := (![#uint64T] "rpcId") in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("req1" <-[#sliceT] "$r0");;;
    let: "req2" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "req1") in
    let: "$a1" := (![#sliceT] "args") in
    (func_call #marshal.marshal #"WriteBytes"%go) "$a0" "$a1") in
    do:  ("req2" <-[#sliceT] "$r0");;;
    (if: let: "$a0" := (![#sliceT] "req2") in
    (method_call #netffi #"Conn'ptr" #"Send" (![#ptrT] (struct.field_ref #Client #"conn"%go (![#ptrT] "c")))) "$a0"
    then return: (#true)
    else do:  #());;;
    let: "err0" := (mem.alloc (type.zero_val #boolT)) in
    let: "resp" := (mem.alloc (type.zero_val #sliceT)) in
    let: ("$ret0", "$ret1") := ((method_call #netffi #"Conn'ptr" #"Receive" (![#ptrT] (struct.field_ref #Client #"conn"%go (![#ptrT] "c")))) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("resp" <-[#sliceT] "$r0");;;
    do:  ("err0" <-[#boolT] "$r1");;;
    (if: ![#boolT] "err0"
    then return: (#true)
    else do:  #());;;
    let: "$r0" := (![#sliceT] "resp") in
    do:  ((![#ptrT] "reply") <-[#sliceT] "$r0");;;
    return: (#false)).

Definition vars' : list (go_string * go_type) := [].

Definition functions' : list (go_string * val) := [("NewServer"%go, NewServer); ("Dial"%go, Dial)].

Definition msets' : list (go_string * (list (go_string * val))) := [("Server"%go, []); ("Server'ptr"%go, [("Serve"%go, Server__Serve); ("handle"%go, Server__handle); ("read"%go, Server__read)]); ("Client"%go, []); ("Client'ptr"%go, [("Call"%go, Client__Call)])].

#[global] Instance info' : PkgInfo advrpc.advrpc :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [netffi.netffi; safemarshal.safemarshal; marshal.marshal];
  |}.

Definition initialize' : val :=
  rec: "initialize'" <> :=
    globals.package_init advrpc.advrpc (λ: <>,
      exception_do (do:  marshal.initialize';;;
      do:  safemarshal.initialize';;;
      do:  netffi.initialize')
      ).

End code.
End advrpc.
