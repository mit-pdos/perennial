(* autogenerated from github.com/mit-pdos/gokv/asyncfile *)
Require Export New.code.sync.
Require Export New.code.github_com.goose_lang.std.
Require Export New.code.github_com.mit_pdos.gokv.grove_ffi.
From New.golang Require Import defn.
From New Require Import grove_prelude.
Module pkg_id.
Definition asyncfile : go_string := "github.com/mit-pdos/gokv/asyncfile".

End pkg_id.
Export pkg_id.
Module asyncfile.

Definition AsyncFile {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/mit-pdos/gokv/asyncfile.AsyncFile"%go [].

Definition MakeAsyncFile {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/gokv/asyncfile.MakeAsyncFile"%go.

(* go: storage.go:24:21 *)
Definition AsyncFile__Writeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" "data",
    with_defer: (let: "s" := (GoAlloc (go.PointerType AsyncFile) "s") in
    let: "data" := (GoAlloc (go.SliceType go.byte) "data") in
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] (StructFieldRef AsyncFile "mu"%go (![go.PointerType AsyncFile] "s")))) #());;;
    do:  (let: "$f" := (MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef AsyncFile "mu"%go (![go.PointerType AsyncFile] "s")))) in
    "$defer" <-[deferType] (let: "$oldf" := (![deferType] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    let: "$r0" := (![go.SliceType go.byte] "data") in
    do:  ((StructFieldRef AsyncFile "data"%go (![go.PointerType AsyncFile] "s")) <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.uint64] (StructFieldRef AsyncFile "index"%go (![go.PointerType AsyncFile] "s"))) in
    let: "$a1" := #(W64 1) in
    (FuncResolve std.SumAssumeNoOverflow [] #()) "$a0" "$a1") in
    do:  ((StructFieldRef AsyncFile "index"%go (![go.PointerType AsyncFile] "s")) <-[go.uint64] "$r0");;;
    let: "index" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (![go.uint64] (StructFieldRef AsyncFile "index"%go (![go.PointerType AsyncFile] "s"))) in
    do:  ("index" <-[go.uint64] "$r0");;;
    do:  ((MethodResolve (go.PointerType sync.Cond) "Signal"%go (![go.PointerType sync.Cond] (StructFieldRef AsyncFile "indexCond"%go (![go.PointerType AsyncFile] "s")))) #());;;
    return: ((λ: <>,
       exception_do (do:  (let: "$a0" := (![go.uint64] "index") in
       (MethodResolve (go.PointerType AsyncFile) "wait"%go (![go.PointerType AsyncFile] "s")) "$a0");;;
       return: #())
       ))).

(* go: storage.go:36:21 *)
Definition AsyncFile__waitⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" "index",
    with_defer: (let: "s" := (GoAlloc (go.PointerType AsyncFile) "s") in
    let: "index" := (GoAlloc go.uint64 "index") in
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] (StructFieldRef AsyncFile "mu"%go (![go.PointerType AsyncFile] "s")))) #());;;
    do:  (let: "$f" := (MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef AsyncFile "mu"%go (![go.PointerType AsyncFile] "s")))) in
    "$defer" <-[deferType] (let: "$oldf" := (![deferType] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    (for: (λ: <>, (![go.uint64] (StructFieldRef AsyncFile "durableIndex"%go (![go.PointerType AsyncFile] "s"))) <⟨go.uint64⟩ (![go.uint64] "index")); (λ: <>, #()) := λ: <>,
      do:  ((MethodResolve (go.PointerType sync.Cond) "Wait"%go (![go.PointerType sync.Cond] (StructFieldRef AsyncFile "durableIndexCond"%go (![go.PointerType AsyncFile] "s")))) #()));;;
    return: #()).

(* go: storage.go:45:21 *)
Definition AsyncFile__flushThreadⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" <>,
    exception_do (let: "s" := (GoAlloc (go.PointerType AsyncFile) "s") in
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] (StructFieldRef AsyncFile "mu"%go (![go.PointerType AsyncFile] "s")))) #());;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (if: ![go.bool] (StructFieldRef AsyncFile "closeRequested"%go (![go.PointerType AsyncFile] "s"))
      then
        do:  (let: "$a0" := (![go.string] (StructFieldRef AsyncFile "filename"%go (![go.PointerType AsyncFile] "s"))) in
        let: "$a1" := (![go.SliceType go.byte] (StructFieldRef AsyncFile "data"%go (![go.PointerType AsyncFile] "s"))) in
        (FuncResolve grove_ffi.FileWrite [] #()) "$a0" "$a1");;;
        let: "$r0" := (![go.uint64] (StructFieldRef AsyncFile "index"%go (![go.PointerType AsyncFile] "s"))) in
        do:  ((StructFieldRef AsyncFile "durableIndex"%go (![go.PointerType AsyncFile] "s")) <-[go.uint64] "$r0");;;
        do:  ((MethodResolve (go.PointerType sync.Cond) "Broadcast"%go (![go.PointerType sync.Cond] (StructFieldRef AsyncFile "durableIndexCond"%go (![go.PointerType AsyncFile] "s")))) #());;;
        let: "$r0" := #true in
        do:  ((StructFieldRef AsyncFile "closed"%go (![go.PointerType AsyncFile] "s")) <-[go.bool] "$r0");;;
        do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef AsyncFile "mu"%go (![go.PointerType AsyncFile] "s")))) #());;;
        do:  ((MethodResolve (go.PointerType sync.Cond) "Signal"%go (![go.PointerType sync.Cond] (StructFieldRef AsyncFile "closedCond"%go (![go.PointerType AsyncFile] "s")))) #());;;
        return: (#())
      else do:  #());;;
      (if: Convert go.untyped_bool go.bool ((![go.uint64] (StructFieldRef AsyncFile "durableIndex"%go (![go.PointerType AsyncFile] "s"))) ≥⟨go.uint64⟩ (![go.uint64] (StructFieldRef AsyncFile "index"%go (![go.PointerType AsyncFile] "s"))))
      then
        do:  ((MethodResolve (go.PointerType sync.Cond) "Wait"%go (![go.PointerType sync.Cond] (StructFieldRef AsyncFile "indexCond"%go (![go.PointerType AsyncFile] "s")))) #());;;
        continue: #()
      else do:  #());;;
      let: "index" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: "$r0" := (![go.uint64] (StructFieldRef AsyncFile "index"%go (![go.PointerType AsyncFile] "s"))) in
      do:  ("index" <-[go.uint64] "$r0");;;
      let: "data" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
      let: "$r0" := (![go.SliceType go.byte] (StructFieldRef AsyncFile "data"%go (![go.PointerType AsyncFile] "s"))) in
      do:  ("data" <-[go.SliceType go.byte] "$r0");;;
      do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef AsyncFile "mu"%go (![go.PointerType AsyncFile] "s")))) #());;;
      do:  (let: "$a0" := (![go.string] (StructFieldRef AsyncFile "filename"%go (![go.PointerType AsyncFile] "s"))) in
      let: "$a1" := (![go.SliceType go.byte] "data") in
      (FuncResolve grove_ffi.FileWrite [] #()) "$a0" "$a1");;;
      do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] (StructFieldRef AsyncFile "mu"%go (![go.PointerType AsyncFile] "s")))) #());;;
      let: "$r0" := (![go.uint64] "index") in
      do:  ((StructFieldRef AsyncFile "durableIndex"%go (![go.PointerType AsyncFile] "s")) <-[go.uint64] "$r0");;;
      do:  ((MethodResolve (go.PointerType sync.Cond) "Broadcast"%go (![go.PointerType sync.Cond] (StructFieldRef AsyncFile "durableIndexCond"%go (![go.PointerType AsyncFile] "s")))) #()));;;
    return: #()).

(* go: storage.go:73:21 *)
Definition AsyncFile__Closeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" <>,
    with_defer: (let: "s" := (GoAlloc (go.PointerType AsyncFile) "s") in
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] (StructFieldRef AsyncFile "mu"%go (![go.PointerType AsyncFile] "s")))) #());;;
    do:  (let: "$f" := (MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef AsyncFile "mu"%go (![go.PointerType AsyncFile] "s")))) in
    "$defer" <-[deferType] (let: "$oldf" := (![deferType] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    let: "$r0" := #true in
    do:  ((StructFieldRef AsyncFile "closeRequested"%go (![go.PointerType AsyncFile] "s")) <-[go.bool] "$r0");;;
    do:  ((MethodResolve (go.PointerType sync.Cond) "Signal"%go (![go.PointerType sync.Cond] (StructFieldRef AsyncFile "indexCond"%go (![go.PointerType AsyncFile] "s")))) #());;;
    (for: (λ: <>, (⟨go.bool⟩! (![go.bool] (StructFieldRef AsyncFile "closed"%go (![go.PointerType AsyncFile] "s"))))); (λ: <>, #()) := λ: <>,
      do:  ((MethodResolve (go.PointerType sync.Cond) "Wait"%go (![go.PointerType sync.Cond] (StructFieldRef AsyncFile "closedCond"%go (![go.PointerType AsyncFile] "s")))) #()));;;
    return: #()).

(* returns the state, then the File object

   go: storage.go:85:6 *)
Definition MakeAsyncFileⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "filename",
    exception_do (let: "filename" := (GoAlloc go.string "filename") in
    let: "mu" := (GoAlloc sync.Mutex (GoZeroVal sync.Mutex #())) in
    let: "s" := (GoAlloc (go.PointerType AsyncFile) (GoZeroVal (go.PointerType AsyncFile) #())) in
    let: "$r0" := (GoAlloc AsyncFile (CompositeLiteral AsyncFile (LiteralValue [KeyedElement (Some (KeyField "mu"%go)) (ElementExpression (go.PointerType sync.Mutex) "mu"); KeyedElement (Some (KeyField "indexCond"%go)) (ElementExpression (go.PointerType sync.Cond) (let: "$a0" := (Convert (go.PointerType sync.Mutex) sync.Locker "mu") in
     (FuncResolve sync.NewCond [] #()) "$a0")); KeyedElement (Some (KeyField "closedCond"%go)) (ElementExpression (go.PointerType sync.Cond) (let: "$a0" := (Convert (go.PointerType sync.Mutex) sync.Locker "mu") in
     (FuncResolve sync.NewCond [] #()) "$a0")); KeyedElement (Some (KeyField "durableIndexCond"%go)) (ElementExpression (go.PointerType sync.Cond) (let: "$a0" := (Convert (go.PointerType sync.Mutex) sync.Locker "mu") in
     (FuncResolve sync.NewCond [] #()) "$a0")); KeyedElement (Some (KeyField "filename"%go)) (ElementExpression go.string (![go.string] "filename")); KeyedElement (Some (KeyField "data"%go)) (ElementExpression (go.SliceType go.byte) (let: "$a0" := (![go.string] "filename") in
     (FuncResolve grove_ffi.FileRead [] #()) "$a0")); KeyedElement (Some (KeyField "index"%go)) (ElementExpression go.uint64 #(W64 0)); KeyedElement (Some (KeyField "durableIndex"%go)) (ElementExpression go.uint64 #(W64 0)); KeyedElement (Some (KeyField "closed"%go)) (ElementExpression go.bool #false); KeyedElement (Some (KeyField "closeRequested"%go)) (ElementExpression go.bool #false)]))) in
    do:  ("s" <-[go.PointerType AsyncFile] "$r0");;;
    let: "data" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (![go.SliceType go.byte] (StructFieldRef AsyncFile "data"%go (![go.PointerType AsyncFile] "s"))) in
    do:  ("data" <-[go.SliceType go.byte] "$r0");;;
    let: "$go" := (MethodResolve (go.PointerType AsyncFile) "flushThread"%go (![go.PointerType AsyncFile] "s")) in
    do:  (Fork ("$go" #()));;;
    return: (![go.SliceType go.byte] "data", ![go.PointerType AsyncFile] "s")).

#[global] Instance info' : PkgInfo pkg_id.asyncfile :=
{|
  pkg_imported_pkgs := [code.sync.pkg_id.sync; code.github_com.goose_lang.std.pkg_id.std; code.github_com.mit_pdos.gokv.grove_ffi.pkg_id.grove_ffi]
|}.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init pkg_id.asyncfile (λ: <>,
      exception_do (do:  (grove_ffi.initialize' #());;;
      do:  (std.initialize' #());;;
      do:  (sync.initialize' #()))
      ).

Module AsyncFile.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  mu' : loc;
  data' : slice.t;
  filename' : go_string;
  index' : w64;
  indexCond' : loc;
  durableIndex' : w64;
  durableIndexCond' : loc;
  closeRequested' : bool;
  closed' : bool;
  closedCond' : loc;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End AsyncFile.

Definition AsyncFile'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "mu"%go (go.PointerType sync.Mutex));
  (go.FieldDecl "data"%go (go.SliceType go.byte));
  (go.FieldDecl "filename"%go go.string);
  (go.FieldDecl "index"%go go.uint64);
  (go.FieldDecl "indexCond"%go (go.PointerType sync.Cond));
  (go.FieldDecl "durableIndex"%go go.uint64);
  (go.FieldDecl "durableIndexCond"%go (go.PointerType sync.Cond));
  (go.FieldDecl "closeRequested"%go go.bool);
  (go.FieldDecl "closed"%go go.bool);
  (go.FieldDecl "closedCond"%go (go.PointerType sync.Cond))
].
Program Definition AsyncFile'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (AsyncFile'fds_unsealed).
Global Instance equals_unfold_AsyncFile {ext : ffi_syntax} {go_gctx : GoGlobalContext} : AsyncFile'fds =→ AsyncFile'fds_unsealed.
Proof. rewrite /AsyncFile'fds seal_eq //. Qed.

Definition AsyncFileⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (AsyncFile'fds).

Class AsyncFile_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] AsyncFile_type_repr  :: go.TypeReprUnderlying AsyncFileⁱᵐᵖˡ AsyncFile.t;
  #[global] AsyncFile_underlying :: (AsyncFile) <u (AsyncFileⁱᵐᵖˡ);
  #[global] AsyncFile_get_mu (x : AsyncFile.t) :: ⟦StructFieldGet (AsyncFileⁱᵐᵖˡ) "mu", #x⟧ ⤳[under] #x.(AsyncFile.mu');
  #[global] AsyncFile_set_mu (x : AsyncFile.t) y :: ⟦StructFieldSet (AsyncFileⁱᵐᵖˡ) "mu", (#x, #y)⟧ ⤳[under] #(x <|AsyncFile.mu' := y|>);
  #[global] AsyncFile_get_data (x : AsyncFile.t) :: ⟦StructFieldGet (AsyncFileⁱᵐᵖˡ) "data", #x⟧ ⤳[under] #x.(AsyncFile.data');
  #[global] AsyncFile_set_data (x : AsyncFile.t) y :: ⟦StructFieldSet (AsyncFileⁱᵐᵖˡ) "data", (#x, #y)⟧ ⤳[under] #(x <|AsyncFile.data' := y|>);
  #[global] AsyncFile_get_filename (x : AsyncFile.t) :: ⟦StructFieldGet (AsyncFileⁱᵐᵖˡ) "filename", #x⟧ ⤳[under] #x.(AsyncFile.filename');
  #[global] AsyncFile_set_filename (x : AsyncFile.t) y :: ⟦StructFieldSet (AsyncFileⁱᵐᵖˡ) "filename", (#x, #y)⟧ ⤳[under] #(x <|AsyncFile.filename' := y|>);
  #[global] AsyncFile_get_index (x : AsyncFile.t) :: ⟦StructFieldGet (AsyncFileⁱᵐᵖˡ) "index", #x⟧ ⤳[under] #x.(AsyncFile.index');
  #[global] AsyncFile_set_index (x : AsyncFile.t) y :: ⟦StructFieldSet (AsyncFileⁱᵐᵖˡ) "index", (#x, #y)⟧ ⤳[under] #(x <|AsyncFile.index' := y|>);
  #[global] AsyncFile_get_indexCond (x : AsyncFile.t) :: ⟦StructFieldGet (AsyncFileⁱᵐᵖˡ) "indexCond", #x⟧ ⤳[under] #x.(AsyncFile.indexCond');
  #[global] AsyncFile_set_indexCond (x : AsyncFile.t) y :: ⟦StructFieldSet (AsyncFileⁱᵐᵖˡ) "indexCond", (#x, #y)⟧ ⤳[under] #(x <|AsyncFile.indexCond' := y|>);
  #[global] AsyncFile_get_durableIndex (x : AsyncFile.t) :: ⟦StructFieldGet (AsyncFileⁱᵐᵖˡ) "durableIndex", #x⟧ ⤳[under] #x.(AsyncFile.durableIndex');
  #[global] AsyncFile_set_durableIndex (x : AsyncFile.t) y :: ⟦StructFieldSet (AsyncFileⁱᵐᵖˡ) "durableIndex", (#x, #y)⟧ ⤳[under] #(x <|AsyncFile.durableIndex' := y|>);
  #[global] AsyncFile_get_durableIndexCond (x : AsyncFile.t) :: ⟦StructFieldGet (AsyncFileⁱᵐᵖˡ) "durableIndexCond", #x⟧ ⤳[under] #x.(AsyncFile.durableIndexCond');
  #[global] AsyncFile_set_durableIndexCond (x : AsyncFile.t) y :: ⟦StructFieldSet (AsyncFileⁱᵐᵖˡ) "durableIndexCond", (#x, #y)⟧ ⤳[under] #(x <|AsyncFile.durableIndexCond' := y|>);
  #[global] AsyncFile_get_closeRequested (x : AsyncFile.t) :: ⟦StructFieldGet (AsyncFileⁱᵐᵖˡ) "closeRequested", #x⟧ ⤳[under] #x.(AsyncFile.closeRequested');
  #[global] AsyncFile_set_closeRequested (x : AsyncFile.t) y :: ⟦StructFieldSet (AsyncFileⁱᵐᵖˡ) "closeRequested", (#x, #y)⟧ ⤳[under] #(x <|AsyncFile.closeRequested' := y|>);
  #[global] AsyncFile_get_closed (x : AsyncFile.t) :: ⟦StructFieldGet (AsyncFileⁱᵐᵖˡ) "closed", #x⟧ ⤳[under] #x.(AsyncFile.closed');
  #[global] AsyncFile_set_closed (x : AsyncFile.t) y :: ⟦StructFieldSet (AsyncFileⁱᵐᵖˡ) "closed", (#x, #y)⟧ ⤳[under] #(x <|AsyncFile.closed' := y|>);
  #[global] AsyncFile_get_closedCond (x : AsyncFile.t) :: ⟦StructFieldGet (AsyncFileⁱᵐᵖˡ) "closedCond", #x⟧ ⤳[under] #x.(AsyncFile.closedCond');
  #[global] AsyncFile_set_closedCond (x : AsyncFile.t) y :: ⟦StructFieldSet (AsyncFileⁱᵐᵖˡ) "closedCond", (#x, #y)⟧ ⤳[under] #(x <|AsyncFile.closedCond' := y|>);
  #[global] AsyncFile'ptr_Close_unfold :: MethodUnfold (go.PointerType (AsyncFile)) "Close" (AsyncFile__Closeⁱᵐᵖˡ);
  #[global] AsyncFile'ptr_Write_unfold :: MethodUnfold (go.PointerType (AsyncFile)) "Write" (AsyncFile__Writeⁱᵐᵖˡ);
  #[global] AsyncFile'ptr_flushThread_unfold :: MethodUnfold (go.PointerType (AsyncFile)) "flushThread" (AsyncFile__flushThreadⁱᵐᵖˡ);
  #[global] AsyncFile'ptr_wait_unfold :: MethodUnfold (go.PointerType (AsyncFile)) "wait" (AsyncFile__waitⁱᵐᵖˡ);
}.

Class Assumptions `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] AsyncFile_instance :: AsyncFile_Assumptions;
  #[global] MakeAsyncFile_unfold :: FuncUnfold MakeAsyncFile [] (MakeAsyncFileⁱᵐᵖˡ);
  #[global] import_sync_Assumption :: sync.Assumptions;
  #[global] import_std_Assumption :: std.Assumptions;
  #[global] import_grove_ffi_Assumption :: grove_ffi.Assumptions;
}.
End asyncfile.
