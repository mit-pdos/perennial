(* autogenerated from github.com/mit-pdos/gokv/globals_test *)
From New.golang Require Import defn.
Module pkg_id.
Definition main : go_string := "github.com/mit-pdos/gokv/globals_test".

End pkg_id.
Export pkg_id.
Module main.

Definition GlobalX {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/gokv/globals_test.GlobalX"%go.

Definition globalY {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/gokv/globals_test.globalY"%go.

Definition globalA {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/gokv/globals_test.globalA"%go.

Definition globalB {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/gokv/globals_test.globalB"%go.

Definition foo {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/gokv/globals_test.foo"%go.

Definition other {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/gokv/globals_test.other"%go.

Definition bar {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/gokv/globals_test.bar"%go.

Definition main {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/gokv/globals_test.main"%go.

(* go: globals.go:3:6 *)
Definition fooⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (#(W64 10))).

(* go: globals.go:12:6 *)
Definition otherⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "$r0" := #"ok"%go in
    do:  ((GlobalVarAddr globalY #()) <-[go.string] "$r0");;;
    return: #()).

(* go: globals.go:16:6 *)
Definition barⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (do:  ((FuncResolve other [] #()) #());;;
    (if: Convert go.untyped_bool go.bool (((![go.uint64] (GlobalVarAddr GlobalX #())) ≠⟨go.uint64⟩ #(W64 10)) || ((![go.string] (GlobalVarAddr globalY #())) ≠⟨go.string⟩ #"ok"%go))
    then
      do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"bad"%go) in
      (FuncResolve go.panic [] #()) "$a0")
    else do:  #());;;
    return: #()).

(* go: globals.go:31:6 *)
Definition mainⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (do:  ((FuncResolve bar [] #()) #());;;
    return: #()).

#[global] Instance info' : PkgInfo pkg_id.main :=
{|
  pkg_imported_pkgs := []
|}.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init pkg_id.main (λ: <>,
      exception_do (do:  (go.GlobalAlloc globalB go.string #());;;
      do:  (go.GlobalAlloc globalA go.string #());;;
      do:  (go.GlobalAlloc globalY go.string #());;;
      do:  (go.GlobalAlloc GlobalX go.uint64 #());;;
      let: "$r0" := ((FuncResolve foo [] #()) #()) in
      do:  ((GlobalVarAddr GlobalX #()) <-[go.uint64] "$r0");;;
      let: "$r0" := #"a"%go in
      do:  ((GlobalVarAddr globalA #()) <-[go.string] "$r0");;;
      let: "$r0" := #"b"%go in
      do:  ((GlobalVarAddr globalB #()) <-[go.string] "$r0");;;
      do:  ((λ: <>,
        exception_do (let: "$r0" := ((![go.uint64] (GlobalVarAddr GlobalX #())) +⟨go.uint64⟩ #(W64 0)) in
        do:  ((GlobalVarAddr GlobalX #()) <-[go.uint64] "$r0");;;
        return: #())
        ) #());;;
      do:  ((λ: <>,
        exception_do (let: "$r0" := #""%go in
        do:  ((GlobalVarAddr globalY #()) <-[go.string] "$r0");;;
        return: #())
        ) #()))
      ).

Class Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] foo_unfold :: FuncUnfold foo [] (fooⁱᵐᵖˡ);
  #[global] other_unfold :: FuncUnfold other [] (otherⁱᵐᵖˡ);
  #[global] bar_unfold :: FuncUnfold bar [] (barⁱᵐᵖˡ);
  #[global] main_unfold :: FuncUnfold main [] (mainⁱᵐᵖˡ);
}.
End main.
