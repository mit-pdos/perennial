(* autogenerated from github.com/mit-pdos/gokv/urpc *)
Require Export New.code.log.
Require Export New.code.sync.
Require Export New.code.time.
Require Export New.code.github_com.goose_lang.primitive.
Require Export New.code.github_com.goose_lang.std.
Require Export New.code.github_com.mit_pdos.gokv.grove_ffi.
Require Export New.code.github_com.tchajed.marshal.
From New.golang Require Import defn.
From New Require Import grove_prelude.
Module pkg_id.
Definition urpc : go_string := "github.com/mit-pdos/gokv/urpc".

End pkg_id.
Export pkg_id.
Module urpc.

Definition Server {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/mit-pdos/gokv/urpc.Server"%go [].

Definition Callback {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/mit-pdos/gokv/urpc.Callback"%go [].

Definition Client {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/mit-pdos/gokv/urpc.Client"%go [].

Definition Error {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.uint64.

Definition callbackStateWaiting {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 0).

Definition callbackStateDone {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 1).

Definition callbackStateAborted {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 2).

Definition ErrNone {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 0).

Definition ErrTimeout {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 1).

Definition ErrDisconnect {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 2).

Definition MakeServer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/gokv/urpc.MakeServer"%go.

Definition TryMakeClient {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/gokv/urpc.TryMakeClient"%go.

Definition MakeClient {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/gokv/urpc.MakeClient"%go.

(* go: urpc.go:21:20 *)
Definition Server__rpcHandleⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "srv" "conn" "rpcid" "seqno" "data",
    exception_do (let: "srv" := (GoAlloc (go.PointerType Server) "srv") in
    let: "data" := (GoAlloc (go.SliceType go.byte) "data") in
    let: "seqno" := (GoAlloc go.uint64 "seqno") in
    let: "rpcid" := (GoAlloc go.uint64 "rpcid") in
    let: "conn" := (GoAlloc grove_ffi.Connection "conn") in
    let: "replyData" := (GoAlloc (go.PointerType (go.SliceType go.byte)) (GoZeroVal (go.PointerType (go.SliceType go.byte)) #())) in
    let: "$r0" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    do:  ("replyData" <-[go.PointerType (go.SliceType go.byte)] "$r0");;;
    let: "f" := (GoAlloc (go.FunctionType (go.Signature [go.SliceType go.byte; go.PointerType (go.SliceType go.byte)] false [])) (GoZeroVal (go.FunctionType (go.Signature [go.SliceType go.byte; go.PointerType (go.SliceType go.byte)] false [])) #())) in
    let: "$r0" := (map.lookup1 go.uint64 (go.FunctionType (go.Signature [go.SliceType go.byte; go.PointerType (go.SliceType go.byte)] false [])) (![go.MapType go.uint64 (go.FunctionType (go.Signature [go.SliceType go.byte; go.PointerType (go.SliceType go.byte)] false []))] (StructFieldRef Server "handlers"%go (![go.PointerType Server] "srv"))) (![go.uint64] "rpcid")) in
    do:  ("f" <-[go.FunctionType (go.Signature [go.SliceType go.byte; go.PointerType (go.SliceType go.byte)] false [])] "$r0");;;
    do:  (let: "$a0" := (![go.SliceType go.byte] "data") in
    let: "$a1" := (![go.PointerType (go.SliceType go.byte)] "replyData") in
    (![go.FunctionType (go.Signature [go.SliceType go.byte; go.PointerType (go.SliceType go.byte)] false [])] "f") "$a0" "$a1");;;
    let: "data1" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := ((FuncResolve go.make3 [go.SliceType go.byte] #()) #(W64 0) (#(W64 8) +⟨go.int⟩ (let: "$a0" := (![go.SliceType go.byte] (![go.PointerType (go.SliceType go.byte)] "replyData")) in
    (FuncResolve go.len [go.SliceType go.byte] #()) "$a0"))) in
    do:  ("data1" <-[go.SliceType go.byte] "$r0");;;
    let: "data2" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "data1") in
    let: "$a1" := (![go.uint64] "seqno") in
    (FuncResolve marshal.WriteInt [] #()) "$a0" "$a1") in
    do:  ("data2" <-[go.SliceType go.byte] "$r0");;;
    let: "data3" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "data2") in
    let: "$a1" := (![go.SliceType go.byte] (![go.PointerType (go.SliceType go.byte)] "replyData")) in
    (FuncResolve marshal.WriteBytes [] #()) "$a0" "$a1") in
    do:  ("data3" <-[go.SliceType go.byte] "$r0");;;
    do:  (let: "$a0" := (![grove_ffi.Connection] "conn") in
    let: "$a1" := (![go.SliceType go.byte] "data3") in
    (FuncResolve grove_ffi.Send [] #()) "$a0" "$a1");;;
    return: #()).

(* go: urpc.go:34:6 *)
Definition MakeServerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "handlers",
    exception_do (let: "handlers" := (GoAlloc (go.MapType go.uint64 (go.FunctionType (go.Signature [go.SliceType go.byte; go.PointerType (go.SliceType go.byte)] false []))) "handlers") in
    return: (GoAlloc Server (CompositeLiteral Server (LiteralValue [KeyedElement (Some (KeyField "handlers"%go)) (ElementExpression (go.MapType go.uint64 (go.FunctionType (go.Signature [go.SliceType go.byte; go.PointerType (go.SliceType go.byte)] false []))) (![go.MapType go.uint64 (go.FunctionType (go.Signature [go.SliceType go.byte; go.PointerType (go.SliceType go.byte)] false []))] "handlers"))])))).

(* go: urpc.go:38:20 *)
Definition Server__readThreadⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "srv" "conn",
    exception_do (let: "srv" := (GoAlloc (go.PointerType Server) "srv") in
    let: "conn" := (GoAlloc grove_ffi.Connection "conn") in
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "data" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
      let: "err" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![grove_ffi.Connection] "conn") in
      (FuncResolve grove_ffi.Receive [] #()) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("err" <-[go.bool] "$r0");;;
      do:  ("data" <-[go.SliceType go.byte] "$r1");;;
      (if: ![go.bool] "err"
      then break: #()
      else do:  #());;;
      let: "rpcid" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] "data") in
      (FuncResolve marshal.ReadInt [] #()) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("rpcid" <-[go.uint64] "$r0");;;
      do:  ("data" <-[go.SliceType go.byte] "$r1");;;
      let: "seqno" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] "data") in
      (FuncResolve marshal.ReadInt [] #()) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("seqno" <-[go.uint64] "$r0");;;
      do:  ("data" <-[go.SliceType go.byte] "$r1");;;
      let: "req" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
      let: "$r0" := (![go.SliceType go.byte] "data") in
      do:  ("req" <-[go.SliceType go.byte] "$r0");;;
      let: "$go" := (λ: <>,
        exception_do (do:  (let: "$a0" := (![grove_ffi.Connection] "conn") in
        let: "$a1" := (![go.uint64] "rpcid") in
        let: "$a2" := (![go.uint64] "seqno") in
        let: "$a3" := (![go.SliceType go.byte] "req") in
        (MethodResolve (go.PointerType Server) "rpcHandle"%go (![go.PointerType Server] "srv")) "$a0" "$a1" "$a2" "$a3");;;
        return: #())
        ) in
      do:  (Fork ("$go" #()));;;
      continue: #());;;
    return: #()).

(* go: urpc.go:59:20 *)
Definition Server__Serveⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "srv" "host",
    exception_do (let: "srv" := (GoAlloc (go.PointerType Server) "srv") in
    let: "host" := (GoAlloc grove_ffi.Address "host") in
    let: "listener" := (GoAlloc grove_ffi.Listener (GoZeroVal grove_ffi.Listener #())) in
    let: "$r0" := (let: "$a0" := (![grove_ffi.Address] "host") in
    (FuncResolve grove_ffi.Listen [] #()) "$a0") in
    do:  ("listener" <-[grove_ffi.Listener] "$r0");;;
    let: "$go" := (λ: <>,
      exception_do ((for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
        let: "conn" := (GoAlloc grove_ffi.Connection (GoZeroVal grove_ffi.Connection #())) in
        let: "$r0" := (let: "$a0" := (![grove_ffi.Listener] "listener") in
        (FuncResolve grove_ffi.Accept [] #()) "$a0") in
        do:  ("conn" <-[grove_ffi.Connection] "$r0");;;
        let: "$go" := (λ: <>,
          exception_do (do:  (let: "$a0" := (![grove_ffi.Connection] "conn") in
          (MethodResolve (go.PointerType Server) "readThread"%go (![go.PointerType Server] "srv")) "$a0");;;
          return: #())
          ) in
        do:  (Fork ("$go" #())));;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    return: #()).

(* go: urpc.go:89:19 *)
Definition Client__replyThreadⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "cl" <>,
    exception_do (let: "cl" := (GoAlloc (go.PointerType Client) "cl") in
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "data" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
      let: "err" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![grove_ffi.Connection] (StructFieldRef Client "conn"%go (![go.PointerType Client] "cl"))) in
      (FuncResolve grove_ffi.Receive [] #()) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("err" <-[go.bool] "$r0");;;
      do:  ("data" <-[go.SliceType go.byte] "$r1");;;
      (if: ![go.bool] "err"
      then
        do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] (StructFieldRef Client "mu"%go (![go.PointerType Client] "cl")))) #());;;
        let: "$range" := (![go.MapType go.uint64 (go.PointerType Callback)] (StructFieldRef Client "pending"%go (![go.PointerType Client] "cl"))) in
        (let: "cb" := (GoAlloc (go.PointerType Callback) (GoZeroVal (go.PointerType Callback) #())) in
        map.for_range go.uint64 (go.PointerType Callback) "$range" (λ: "$key" "value",
          do:  ("cb" <-[go.PointerType Callback] "$value");;;
          do:  "$key";;;
          let: "$r0" := callbackStateAborted in
          do:  ((![go.PointerType go.uint64] (StructFieldRef Callback "state"%go (![go.PointerType Callback] "cb"))) <-[go.uint64] "$r0");;;
          do:  ((MethodResolve (go.PointerType sync.Cond) "Signal"%go (![go.PointerType sync.Cond] (StructFieldRef Callback "cond"%go (![go.PointerType Callback] "cb")))) #())));;;
        do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef Client "mu"%go (![go.PointerType Client] "cl")))) #());;;
        break: #()
      else do:  #());;;
      let: "seqno" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] "data") in
      (FuncResolve marshal.ReadInt [] #()) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("seqno" <-[go.uint64] "$r0");;;
      do:  ("data" <-[go.SliceType go.byte] "$r1");;;
      let: "reply" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
      let: "$r0" := (![go.SliceType go.byte] "data") in
      do:  ("reply" <-[go.SliceType go.byte] "$r0");;;
      do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] (StructFieldRef Client "mu"%go (![go.PointerType Client] "cl")))) #());;;
      let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
      let: "cb" := (GoAlloc (go.PointerType Callback) (GoZeroVal (go.PointerType Callback) #())) in
      let: ("$ret0", "$ret1") := (map.lookup2 go.uint64 (go.PointerType Callback) (![go.MapType go.uint64 (go.PointerType Callback)] (StructFieldRef Client "pending"%go (![go.PointerType Client] "cl"))) (![go.uint64] "seqno")) in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("cb" <-[go.PointerType Callback] "$r0");;;
      do:  ("ok" <-[go.bool] "$r1");;;
      (if: ![go.bool] "ok"
      then
        do:  (let: "$a0" := (![go.MapType go.uint64 (go.PointerType Callback)] (StructFieldRef Client "pending"%go (![go.PointerType Client] "cl"))) in
        let: "$a1" := (![go.uint64] "seqno") in
        (FuncResolve go.delete [go.MapType go.uint64 (go.PointerType Callback)] #()) "$a0" "$a1");;;
        let: "$r0" := (![go.SliceType go.byte] "reply") in
        do:  ((![go.PointerType (go.SliceType go.byte)] (StructFieldRef Callback "reply"%go (![go.PointerType Callback] "cb"))) <-[go.SliceType go.byte] "$r0");;;
        let: "$r0" := callbackStateDone in
        do:  ((![go.PointerType go.uint64] (StructFieldRef Callback "state"%go (![go.PointerType Callback] "cb"))) <-[go.uint64] "$r0");;;
        do:  ((MethodResolve (go.PointerType sync.Cond) "Signal"%go (![go.PointerType sync.Cond] (StructFieldRef Callback "cond"%go (![go.PointerType Callback] "cb")))) #())
      else do:  #());;;
      do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef Client "mu"%go (![go.PointerType Client] "cl")))) #());;;
      continue: #());;;
    return: #()).

(* go: urpc.go:120:6 *)
Definition TryMakeClientⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "host_name",
    exception_do (let: "host_name" := (GoAlloc grove_ffi.Address "host_name") in
    let: "host" := (GoAlloc grove_ffi.Address (GoZeroVal grove_ffi.Address #())) in
    let: "$r0" := (![grove_ffi.Address] "host_name") in
    do:  ("host" <-[grove_ffi.Address] "$r0");;;
    let: "conn" := (GoAlloc grove_ffi.Connection (GoZeroVal grove_ffi.Connection #())) in
    let: "err" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![grove_ffi.Address] "host") in
    (FuncResolve grove_ffi.Connect [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("err" <-[go.bool] "$r0");;;
    do:  ("conn" <-[grove_ffi.Connection] "$r1");;;
    let: "nilClient" := (GoAlloc (go.PointerType Client) (GoZeroVal (go.PointerType Client) #())) in
    (if: ![go.bool] "err"
    then return: (#(W64 1), ![go.PointerType Client] "nilClient")
    else do:  #());;;
    let: "cl" := (GoAlloc (go.PointerType Client) (GoZeroVal (go.PointerType Client) #())) in
    let: "$r0" := (GoAlloc Client (CompositeLiteral Client (LiteralValue [KeyedElement (Some (KeyField "conn"%go)) (ElementExpression grove_ffi.Connection (![grove_ffi.Connection] "conn")); KeyedElement (Some (KeyField "mu"%go)) (ElementExpression (go.PointerType sync.Mutex) (GoAlloc sync.Mutex (GoZeroVal sync.Mutex #()))); KeyedElement (Some (KeyField "seq"%go)) (ElementExpression go.uint64 #(W64 1)); KeyedElement (Some (KeyField "pending"%go)) (ElementExpression (go.MapType go.uint64 (go.PointerType Callback)) ((FuncResolve go.make1 [go.MapType go.uint64 (go.PointerType Callback)] #()) #()))]))) in
    do:  ("cl" <-[go.PointerType Client] "$r0");;;
    let: "$go" := (λ: <>,
      exception_do (do:  ((MethodResolve (go.PointerType Client) "replyThread"%go (![go.PointerType Client] "cl")) #());;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    return: (#(W64 0), ![go.PointerType Client] "cl")).

(* go: urpc.go:140:6 *)
Definition MakeClientⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "host_name",
    exception_do (let: "host_name" := (GoAlloc grove_ffi.Address "host_name") in
    let: "cl" := (GoAlloc (go.PointerType Client) (GoZeroVal (go.PointerType Client) #())) in
    let: "err" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![grove_ffi.Address] "host_name") in
    (FuncResolve TryMakeClient [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("err" <-[go.uint64] "$r0");;;
    do:  ("cl" <-[go.PointerType Client] "$r1");;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "err") ≠⟨go.uint64⟩ #(W64 0))
    then
      do:  (let: "$a0" := #"Unable to connect to %s"%go in
      let: "$a1" := ((let: "$sl0" := (Convert go.string go.any (let: "$a0" := (![grove_ffi.Address] "host_name") in
      (FuncResolve grove_ffi.AddressToStr [] #()) "$a0")) in
      CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0")]))) in
      (FuncResolve log.Printf [] #()) "$a0" "$a1")
    else do:  #());;;
    do:  (let: "$a0" := ((![go.uint64] "err") =⟨go.uint64⟩ #(W64 0)) in
    (FuncResolve primitive.Assume [] #()) "$a0");;;
    return: (![go.PointerType Client] "cl")).

(* go: urpc.go:155:19 *)
Definition Client__CallStartⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "cl" "rpcid" "args",
    exception_do (let: "cl" := (GoAlloc (go.PointerType Client) "cl") in
    let: "args" := (GoAlloc (go.SliceType go.byte) "args") in
    let: "rpcid" := (GoAlloc go.uint64 "rpcid") in
    let: "reply_buf" := (GoAlloc (go.PointerType (go.SliceType go.byte)) (GoZeroVal (go.PointerType (go.SliceType go.byte)) #())) in
    let: "$r0" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    do:  ("reply_buf" <-[go.PointerType (go.SliceType go.byte)] "$r0");;;
    let: "cb" := (GoAlloc (go.PointerType Callback) (GoZeroVal (go.PointerType Callback) #())) in
    let: "$r0" := (GoAlloc Callback (CompositeLiteral Callback (LiteralValue [KeyedElement (Some (KeyField "reply"%go)) (ElementExpression (go.PointerType (go.SliceType go.byte)) (![go.PointerType (go.SliceType go.byte)] "reply_buf")); KeyedElement (Some (KeyField "state"%go)) (ElementExpression (go.PointerType go.uint64) (GoAlloc go.uint64 (GoZeroVal go.uint64 #()))); KeyedElement (Some (KeyField "cond"%go)) (ElementExpression (go.PointerType sync.Cond) (let: "$a0" := (Convert (go.PointerType sync.Mutex) sync.Locker (![go.PointerType sync.Mutex] (StructFieldRef Client "mu"%go (![go.PointerType Client] "cl")))) in
     (FuncResolve sync.NewCond [] #()) "$a0"))]))) in
    do:  ("cb" <-[go.PointerType Callback] "$r0");;;
    let: "$r0" := callbackStateWaiting in
    do:  ((![go.PointerType go.uint64] (StructFieldRef Callback "state"%go (![go.PointerType Callback] "cb"))) <-[go.uint64] "$r0");;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] (StructFieldRef Client "mu"%go (![go.PointerType Client] "cl")))) #());;;
    let: "seqno" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (![go.uint64] (StructFieldRef Client "seq"%go (![go.PointerType Client] "cl"))) in
    do:  ("seqno" <-[go.uint64] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.uint64] (StructFieldRef Client "seq"%go (![go.PointerType Client] "cl"))) in
    let: "$a1" := #(W64 1) in
    (FuncResolve std.SumAssumeNoOverflow [] #()) "$a0" "$a1") in
    do:  ((StructFieldRef Client "seq"%go (![go.PointerType Client] "cl")) <-[go.uint64] "$r0");;;
    let: "$r0" := (![go.PointerType Callback] "cb") in
    do:  (map.insert go.uint64 (![go.MapType go.uint64 (go.PointerType Callback)] (StructFieldRef Client "pending"%go (![go.PointerType Client] "cl"))) (![go.uint64] "seqno") "$r0");;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef Client "mu"%go (![go.PointerType Client] "cl")))) #());;;
    let: "data1" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := ((FuncResolve go.make3 [go.SliceType go.byte] #()) #(W64 0) (#(W64 16) +⟨go.int⟩ (let: "$a0" := (![go.SliceType go.byte] "args") in
    (FuncResolve go.len [go.SliceType go.byte] #()) "$a0"))) in
    do:  ("data1" <-[go.SliceType go.byte] "$r0");;;
    let: "data2" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "data1") in
    let: "$a1" := (![go.uint64] "rpcid") in
    (FuncResolve marshal.WriteInt [] #()) "$a0" "$a1") in
    do:  ("data2" <-[go.SliceType go.byte] "$r0");;;
    let: "data3" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "data2") in
    let: "$a1" := (![go.uint64] "seqno") in
    (FuncResolve marshal.WriteInt [] #()) "$a0" "$a1") in
    do:  ("data3" <-[go.SliceType go.byte] "$r0");;;
    let: "reqData" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "data3") in
    let: "$a1" := (![go.SliceType go.byte] "args") in
    (FuncResolve marshal.WriteBytes [] #()) "$a0" "$a1") in
    do:  ("reqData" <-[go.SliceType go.byte] "$r0");;;
    (if: let: "$a0" := (![grove_ffi.Connection] (StructFieldRef Client "conn"%go (![go.PointerType Client] "cl"))) in
    let: "$a1" := (![go.SliceType go.byte] "reqData") in
    (FuncResolve grove_ffi.Send [] #()) "$a0" "$a1"
    then return: (GoAlloc Callback (CompositeLiteral Callback (LiteralValue [])), ErrDisconnect)
    else do:  #());;;
    return: (![go.PointerType Callback] "cb", ErrNone)).

(* go: urpc.go:188:19 *)
Definition Client__CallCompleteⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "cl" "cb" "reply" "timeoutMs",
    exception_do (let: "cl" := (GoAlloc (go.PointerType Client) "cl") in
    let: "timeoutMs" := (GoAlloc go.uint64 "timeoutMs") in
    let: "reply" := (GoAlloc (go.PointerType (go.SliceType go.byte)) "reply") in
    let: "cb" := (GoAlloc (go.PointerType Callback) "cb") in
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] (StructFieldRef Client "mu"%go (![go.PointerType Client] "cl")))) #());;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] (![go.PointerType go.uint64] (StructFieldRef Callback "state"%go (![go.PointerType Callback] "cb")))) =⟨go.uint64⟩ callbackStateWaiting)
    then
      let: "done" := (GoAlloc (go.ChannelType go.sendrecv (go.StructType [

      ])) (GoZeroVal (go.ChannelType go.sendrecv (go.StructType [

      ])) #())) in
      let: "$r0" := ((FuncResolve go.make1 [go.ChannelType go.sendrecv (go.StructType [

       ])] #()) #()) in
      do:  ("done" <-[go.ChannelType go.sendrecv (go.StructType [

      ])] "$r0");;;
      let: "$go" := (λ: <>,
        exception_do (do:  ((MethodResolve (go.PointerType sync.Cond) "Wait"%go (![go.PointerType sync.Cond] (StructFieldRef Callback "cond"%go (![go.PointerType Callback] "cb")))) #());;;
        do:  ((MethodResolve sync.Locker "Unlock"%go (![sync.Locker] (StructFieldRef sync.Cond "L"%go (![go.PointerType sync.Cond] (StructFieldRef Callback "cond"%go (![go.PointerType Callback] "cb")))))) #());;;
        do:  (let: "$a0" := (![go.ChannelType go.sendrecv (go.StructType [

        ])] "done") in
        (FuncResolve go.close [go.ChannelType go.sendrecv (go.StructType [

         ])] #()) "$a0");;;
        return: #())
        ) in
      do:  (Fork ("$go" #()));;;
      let: "$ch0" := (let: "$a0" := ((Convert go.uint64 time.Duration (![go.uint64] "timeoutMs")) *⟨go.int64⟩ time.Millisecond) in
      (FuncResolve time.After [] #()) "$a0") in
      let: "$ch1" := (![go.ChannelType go.sendrecv (go.StructType [

      ])] "done") in
      SelectStmt (SelectStmtClauses None [(CommClause (RecvCase time.Time "$ch0") (do:  ((MethodResolve sync.Locker "Lock"%go (![sync.Locker] (StructFieldRef sync.Cond "L"%go (![go.PointerType sync.Cond] (StructFieldRef Callback "cond"%go (![go.PointerType Callback] "cb")))))) #()))); (CommClause (RecvCase (go.StructType [

      ]) "$ch1") (do:  ((MethodResolve sync.Locker "Lock"%go (![sync.Locker] (StructFieldRef sync.Cond "L"%go (![go.PointerType sync.Cond] (StructFieldRef Callback "cond"%go (![go.PointerType Callback] "cb")))))) #())))])
    else do:  #());;;
    let: "state" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (![go.uint64] (![go.PointerType go.uint64] (StructFieldRef Callback "state"%go (![go.PointerType Callback] "cb")))) in
    do:  ("state" <-[go.uint64] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "state") =⟨go.uint64⟩ callbackStateDone)
    then
      let: "$r0" := (![go.SliceType go.byte] (![go.PointerType (go.SliceType go.byte)] (StructFieldRef Callback "reply"%go (![go.PointerType Callback] "cb")))) in
      do:  ((![go.PointerType (go.SliceType go.byte)] "reply") <-[go.SliceType go.byte] "$r0");;;
      do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef Client "mu"%go (![go.PointerType Client] "cl")))) #());;;
      return: (#(W64 0))
    else
      do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef Client "mu"%go (![go.PointerType Client] "cl")))) #());;;
      (if: Convert go.untyped_bool go.bool ((![go.uint64] "state") =⟨go.uint64⟩ callbackStateAborted)
      then return: (ErrDisconnect)
      else return: (ErrTimeout)))).

(* go: urpc.go:229:19 *)
Definition Client__Callⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "cl" "rpcid" "args" "reply" "timeout_ms",
    exception_do (let: "cl" := (GoAlloc (go.PointerType Client) "cl") in
    let: "timeout_ms" := (GoAlloc go.uint64 "timeout_ms") in
    let: "reply" := (GoAlloc (go.PointerType (go.SliceType go.byte)) "reply") in
    let: "args" := (GoAlloc (go.SliceType go.byte) "args") in
    let: "rpcid" := (GoAlloc go.uint64 "rpcid") in
    let: "err" := (GoAlloc Error (GoZeroVal Error #())) in
    let: "cb" := (GoAlloc (go.PointerType Callback) (GoZeroVal (go.PointerType Callback) #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.uint64] "rpcid") in
    let: "$a1" := (![go.SliceType go.byte] "args") in
    (MethodResolve (go.PointerType Client) "CallStart"%go (![go.PointerType Client] "cl")) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("cb" <-[go.PointerType Callback] "$r0");;;
    do:  ("err" <-[Error] "$r1");;;
    (if: Convert go.untyped_bool go.bool ((![Error] "err") ≠⟨go.uint64⟩ #(W64 0))
    then return: (![Error] "err")
    else do:  #());;;
    return: (let: "$a0" := (![go.PointerType Callback] "cb") in
     let: "$a1" := (![go.PointerType (go.SliceType go.byte)] "reply") in
     let: "$a2" := (![go.uint64] "timeout_ms") in
     (MethodResolve (go.PointerType Client) "CallComplete"%go (![go.PointerType Client] "cl")) "$a0" "$a1" "$a2")).

#[global] Instance info' : PkgInfo pkg_id.urpc :=
{|
  pkg_imported_pkgs := [code.log.pkg_id.log; code.sync.pkg_id.sync; code.time.pkg_id.time; code.github_com.goose_lang.primitive.pkg_id.primitive; code.github_com.goose_lang.std.pkg_id.std; code.github_com.mit_pdos.gokv.grove_ffi.pkg_id.grove_ffi; code.github_com.tchajed.marshal.pkg_id.marshal]
|}.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init pkg_id.urpc (λ: <>,
      exception_do (do:  (marshal.initialize' #());;;
      do:  (grove_ffi.initialize' #());;;
      do:  (std.initialize' #());;;
      do:  (primitive.initialize' #());;;
      do:  (time.initialize' #());;;
      do:  (sync.initialize' #());;;
      do:  (log.initialize' #()))
      ).

Module Server.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  handlers' : map.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End Server.

Definition Server'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "handlers"%go (go.MapType go.uint64 (go.FunctionType (go.Signature [go.SliceType go.byte; go.PointerType (go.SliceType go.byte)] false []))))
].
Program Definition Server'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (Server'fds_unsealed).
Global Instance equals_unfold_Server {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Server'fds =→ Server'fds_unsealed.
Proof. rewrite /Server'fds seal_eq //. Qed.

Definition Serverⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (Server'fds).

Class Server_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Server_type_repr  :: go.TypeReprUnderlying Serverⁱᵐᵖˡ Server.t;
  #[global] Server_underlying :: (Server) <u (Serverⁱᵐᵖˡ);
  #[global] Server_get_handlers (x : Server.t) :: ⟦StructFieldGet (Serverⁱᵐᵖˡ) "handlers", #x⟧ ⤳[under] #x.(Server.handlers');
  #[global] Server_set_handlers (x : Server.t) y :: ⟦StructFieldSet (Serverⁱᵐᵖˡ) "handlers", (#x, #y)⟧ ⤳[under] #(x <|Server.handlers' := y|>);
  #[global] Server'ptr_Serve_unfold :: MethodUnfold (go.PointerType (Server)) "Serve" (Server__Serveⁱᵐᵖˡ);
  #[global] Server'ptr_readThread_unfold :: MethodUnfold (go.PointerType (Server)) "readThread" (Server__readThreadⁱᵐᵖˡ);
  #[global] Server'ptr_rpcHandle_unfold :: MethodUnfold (go.PointerType (Server)) "rpcHandle" (Server__rpcHandleⁱᵐᵖˡ);
}.

Module Callback.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  reply' : loc;
  state' : loc;
  cond' : loc;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End Callback.

Definition Callback'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "reply"%go (go.PointerType (go.SliceType go.byte)));
  (go.FieldDecl "state"%go (go.PointerType go.uint64));
  (go.FieldDecl "cond"%go (go.PointerType sync.Cond))
].
Program Definition Callback'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (Callback'fds_unsealed).
Global Instance equals_unfold_Callback {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Callback'fds =→ Callback'fds_unsealed.
Proof. rewrite /Callback'fds seal_eq //. Qed.

Definition Callbackⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (Callback'fds).

Class Callback_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Callback_type_repr  :: go.TypeReprUnderlying Callbackⁱᵐᵖˡ Callback.t;
  #[global] Callback_underlying :: (Callback) <u (Callbackⁱᵐᵖˡ);
  #[global] Callback_get_reply (x : Callback.t) :: ⟦StructFieldGet (Callbackⁱᵐᵖˡ) "reply", #x⟧ ⤳[under] #x.(Callback.reply');
  #[global] Callback_set_reply (x : Callback.t) y :: ⟦StructFieldSet (Callbackⁱᵐᵖˡ) "reply", (#x, #y)⟧ ⤳[under] #(x <|Callback.reply' := y|>);
  #[global] Callback_get_state (x : Callback.t) :: ⟦StructFieldGet (Callbackⁱᵐᵖˡ) "state", #x⟧ ⤳[under] #x.(Callback.state');
  #[global] Callback_set_state (x : Callback.t) y :: ⟦StructFieldSet (Callbackⁱᵐᵖˡ) "state", (#x, #y)⟧ ⤳[under] #(x <|Callback.state' := y|>);
  #[global] Callback_get_cond (x : Callback.t) :: ⟦StructFieldGet (Callbackⁱᵐᵖˡ) "cond", #x⟧ ⤳[under] #x.(Callback.cond');
  #[global] Callback_set_cond (x : Callback.t) y :: ⟦StructFieldSet (Callbackⁱᵐᵖˡ) "cond", (#x, #y)⟧ ⤳[under] #(x <|Callback.cond' := y|>);
}.

Module Client.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  mu' : loc;
  conn' : grove_ffi.Connection.t;
  seq' : w64;
  pending' : map.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End Client.

Definition Client'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "mu"%go (go.PointerType sync.Mutex));
  (go.FieldDecl "conn"%go grove_ffi.Connection);
  (go.FieldDecl "seq"%go go.uint64);
  (go.FieldDecl "pending"%go (go.MapType go.uint64 (go.PointerType Callback)))
].
Program Definition Client'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (Client'fds_unsealed).
Global Instance equals_unfold_Client {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Client'fds =→ Client'fds_unsealed.
Proof. rewrite /Client'fds seal_eq //. Qed.

Definition Clientⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (Client'fds).

Class Client_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Client_type_repr  :: go.TypeReprUnderlying Clientⁱᵐᵖˡ Client.t;
  #[global] Client_underlying :: (Client) <u (Clientⁱᵐᵖˡ);
  #[global] Client_get_mu (x : Client.t) :: ⟦StructFieldGet (Clientⁱᵐᵖˡ) "mu", #x⟧ ⤳[under] #x.(Client.mu');
  #[global] Client_set_mu (x : Client.t) y :: ⟦StructFieldSet (Clientⁱᵐᵖˡ) "mu", (#x, #y)⟧ ⤳[under] #(x <|Client.mu' := y|>);
  #[global] Client_get_conn (x : Client.t) :: ⟦StructFieldGet (Clientⁱᵐᵖˡ) "conn", #x⟧ ⤳[under] #x.(Client.conn');
  #[global] Client_set_conn (x : Client.t) y :: ⟦StructFieldSet (Clientⁱᵐᵖˡ) "conn", (#x, #y)⟧ ⤳[under] #(x <|Client.conn' := y|>);
  #[global] Client_get_seq (x : Client.t) :: ⟦StructFieldGet (Clientⁱᵐᵖˡ) "seq", #x⟧ ⤳[under] #x.(Client.seq');
  #[global] Client_set_seq (x : Client.t) y :: ⟦StructFieldSet (Clientⁱᵐᵖˡ) "seq", (#x, #y)⟧ ⤳[under] #(x <|Client.seq' := y|>);
  #[global] Client_get_pending (x : Client.t) :: ⟦StructFieldGet (Clientⁱᵐᵖˡ) "pending", #x⟧ ⤳[under] #x.(Client.pending');
  #[global] Client_set_pending (x : Client.t) y :: ⟦StructFieldSet (Clientⁱᵐᵖˡ) "pending", (#x, #y)⟧ ⤳[under] #(x <|Client.pending' := y|>);
  #[global] Client'ptr_Call_unfold :: MethodUnfold (go.PointerType (Client)) "Call" (Client__Callⁱᵐᵖˡ);
  #[global] Client'ptr_CallComplete_unfold :: MethodUnfold (go.PointerType (Client)) "CallComplete" (Client__CallCompleteⁱᵐᵖˡ);
  #[global] Client'ptr_CallStart_unfold :: MethodUnfold (go.PointerType (Client)) "CallStart" (Client__CallStartⁱᵐᵖˡ);
  #[global] Client'ptr_replyThread_unfold :: MethodUnfold (go.PointerType (Client)) "replyThread" (Client__replyThreadⁱᵐᵖˡ);
}.

Class Assumptions `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Server_instance :: Server_Assumptions;
  #[global] Callback_instance :: Callback_Assumptions;
  #[global] Client_instance :: Client_Assumptions;
  #[global] MakeServer_unfold :: FuncUnfold MakeServer [] (MakeServerⁱᵐᵖˡ);
  #[global] TryMakeClient_unfold :: FuncUnfold TryMakeClient [] (TryMakeClientⁱᵐᵖˡ);
  #[global] MakeClient_unfold :: FuncUnfold MakeClient [] (MakeClientⁱᵐᵖˡ);
  #[global] import_log_Assumption :: log.Assumptions;
  #[global] import_sync_Assumption :: sync.Assumptions;
  #[global] import_time_Assumption :: time.Assumptions;
  #[global] import_primitive_Assumption :: primitive.Assumptions;
  #[global] import_std_Assumption :: std.Assumptions;
  #[global] import_grove_ffi_Assumption :: grove_ffi.Assumptions;
  #[global] import_marshal_Assumption :: marshal.Assumptions;
}.
End urpc.
