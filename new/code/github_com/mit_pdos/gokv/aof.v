(* autogenerated from github.com/mit-pdos/gokv/aof *)
From New.golang Require Import defn.
Require Export New.code.github_com.goose_lang.std.
Require Export New.code.github_com.mit_pdos.gokv.grove_ffi.
Require Export New.code.github_com.tchajed.marshal.
Require Export New.code.sync.

Definition aof : go_string := "github.com/mit-pdos/gokv/aof".

From New Require Import grove_prelude.
Module aof.
Section code.


Definition AppendOnlyFile : go_type := structT [
  "mu" :: ptrT;
  "oldDurableCond" :: ptrT;
  "durableCond" :: ptrT;
  "lengthCond" :: ptrT;
  "membuf" :: sliceT;
  "length" :: uint64T;
  "durableLength" :: uint64T;
  "closeRequested" :: boolT;
  "closed" :: boolT;
  "closedCond" :: ptrT
].

(* go: aof.go:29:6 *)
Definition CreateAppendOnlyFile : val :=
  rec: "CreateAppendOnlyFile" "fname" :=
    exception_do (let: "fname" := (mem.alloc "fname") in
    let: "a" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #AppendOnlyFile)) in
    do:  ("a" <-[#ptrT] "$r0");;;
    let: "$r0" := (mem.alloc (type.zero_val #sync.Mutex)) in
    do:  ((struct.field_ref #AppendOnlyFile #"mu"%go (![#ptrT] "a")) <-[#ptrT] "$r0");;;
    let: "$r0" := (let: "$a0" := (interface.make #sync #"Mutex'ptr" (![#ptrT] (struct.field_ref #AppendOnlyFile #"mu"%go (![#ptrT] "a")))) in
    (func_call #sync.sync #"NewCond"%go) "$a0") in
    do:  ((struct.field_ref #AppendOnlyFile #"lengthCond"%go (![#ptrT] "a")) <-[#ptrT] "$r0");;;
    let: "$r0" := (let: "$a0" := (interface.make #sync #"Mutex'ptr" (![#ptrT] (struct.field_ref #AppendOnlyFile #"mu"%go (![#ptrT] "a")))) in
    (func_call #sync.sync #"NewCond"%go) "$a0") in
    do:  ((struct.field_ref #AppendOnlyFile #"oldDurableCond"%go (![#ptrT] "a")) <-[#ptrT] "$r0");;;
    let: "$r0" := (let: "$a0" := (interface.make #sync #"Mutex'ptr" (![#ptrT] (struct.field_ref #AppendOnlyFile #"mu"%go (![#ptrT] "a")))) in
    (func_call #sync.sync #"NewCond"%go) "$a0") in
    do:  ((struct.field_ref #AppendOnlyFile #"durableCond"%go (![#ptrT] "a")) <-[#ptrT] "$r0");;;
    let: "$r0" := (let: "$a0" := (interface.make #sync #"Mutex'ptr" (![#ptrT] (struct.field_ref #AppendOnlyFile #"mu"%go (![#ptrT] "a")))) in
    (func_call #sync.sync #"NewCond"%go) "$a0") in
    do:  ((struct.field_ref #AppendOnlyFile #"closedCond"%go (![#ptrT] "a")) <-[#ptrT] "$r0");;;
    let: "$go" := (λ: <>,
      exception_do (do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref #AppendOnlyFile #"mu"%go (![#ptrT] "a")))) #());;;
      (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
        (if: ((let: "$a0" := (![#sliceT] (struct.field_ref #AppendOnlyFile #"membuf"%go (![#ptrT] "a"))) in
        slice.len "$a0") = #(W64 0)) && (~ (![#boolT] (struct.field_ref #AppendOnlyFile #"closeRequested"%go (![#ptrT] "a"))))
        then
          do:  ((method_call #sync #"Cond'ptr" #"Wait" (![#ptrT] (struct.field_ref #AppendOnlyFile #"lengthCond"%go (![#ptrT] "a")))) #());;;
          continue: #()
        else do:  #());;;
        (if: ![#boolT] (struct.field_ref #AppendOnlyFile #"closeRequested"%go (![#ptrT] "a"))
        then
          do:  (let: "$a0" := (![#stringT] "fname") in
          let: "$a1" := (![#sliceT] (struct.field_ref #AppendOnlyFile #"membuf"%go (![#ptrT] "a"))) in
          (func_call #grove_ffi.grove_ffi #"FileAppend"%go) "$a0" "$a1");;;
          let: "$r0" := (slice.make2 #byteT #(W64 0)) in
          do:  ((struct.field_ref #AppendOnlyFile #"membuf"%go (![#ptrT] "a")) <-[#sliceT] "$r0");;;
          let: "$r0" := (![#uint64T] (struct.field_ref #AppendOnlyFile #"length"%go (![#ptrT] "a"))) in
          do:  ((struct.field_ref #AppendOnlyFile #"durableLength"%go (![#ptrT] "a")) <-[#uint64T] "$r0");;;
          do:  ((method_call #sync #"Cond'ptr" #"Broadcast" (![#ptrT] (struct.field_ref #AppendOnlyFile #"durableCond"%go (![#ptrT] "a")))) #());;;
          let: "$r0" := #true in
          do:  ((struct.field_ref #AppendOnlyFile #"closed"%go (![#ptrT] "a")) <-[#boolT] "$r0");;;
          do:  ((method_call #sync #"Cond'ptr" #"Broadcast" (![#ptrT] (struct.field_ref #AppendOnlyFile #"closedCond"%go (![#ptrT] "a")))) #());;;
          do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #AppendOnlyFile #"mu"%go (![#ptrT] "a")))) #());;;
          break: #()
        else do:  #());;;
        let: "l" := (mem.alloc (type.zero_val #sliceT)) in
        let: "$r0" := (![#sliceT] (struct.field_ref #AppendOnlyFile #"membuf"%go (![#ptrT] "a"))) in
        do:  ("l" <-[#sliceT] "$r0");;;
        let: "newLength" := (mem.alloc (type.zero_val #uint64T)) in
        let: "$r0" := (![#uint64T] (struct.field_ref #AppendOnlyFile #"length"%go (![#ptrT] "a"))) in
        do:  ("newLength" <-[#uint64T] "$r0");;;
        let: "$r0" := (slice.make2 #byteT #(W64 0)) in
        do:  ((struct.field_ref #AppendOnlyFile #"membuf"%go (![#ptrT] "a")) <-[#sliceT] "$r0");;;
        let: "cond" := (mem.alloc (type.zero_val #ptrT)) in
        let: "$r0" := (![#ptrT] (struct.field_ref #AppendOnlyFile #"durableCond"%go (![#ptrT] "a"))) in
        do:  ("cond" <-[#ptrT] "$r0");;;
        let: "$r0" := (![#ptrT] (struct.field_ref #AppendOnlyFile #"oldDurableCond"%go (![#ptrT] "a"))) in
        do:  ((struct.field_ref #AppendOnlyFile #"durableCond"%go (![#ptrT] "a")) <-[#ptrT] "$r0");;;
        let: "$r0" := (![#ptrT] "cond") in
        do:  ((struct.field_ref #AppendOnlyFile #"oldDurableCond"%go (![#ptrT] "a")) <-[#ptrT] "$r0");;;
        do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #AppendOnlyFile #"mu"%go (![#ptrT] "a")))) #());;;
        do:  (let: "$a0" := (![#stringT] "fname") in
        let: "$a1" := (![#sliceT] "l") in
        (func_call #grove_ffi.grove_ffi #"FileAppend"%go) "$a0" "$a1");;;
        do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref #AppendOnlyFile #"mu"%go (![#ptrT] "a")))) #());;;
        let: "$r0" := (![#uint64T] "newLength") in
        do:  ((struct.field_ref #AppendOnlyFile #"durableLength"%go (![#ptrT] "a")) <-[#uint64T] "$r0");;;
        do:  ((method_call #sync #"Cond'ptr" #"Broadcast" (![#ptrT] "cond")) #());;;
        continue: #()))
      ) in
    do:  (Fork ("$go" #()));;;
    return: (![#ptrT] "a")).

(* NOTE: cannot be called concurrently with Append()

   go: aof.go:84:26 *)
Definition AppendOnlyFile__Close : val :=
  rec: "AppendOnlyFile__Close" "a" <> :=
    exception_do (let: "a" := (mem.alloc "a") in
    do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref #AppendOnlyFile #"mu"%go (![#ptrT] "a")))) #());;;
    let: "$r0" := #true in
    do:  ((struct.field_ref #AppendOnlyFile #"closeRequested"%go (![#ptrT] "a")) <-[#boolT] "$r0");;;
    do:  ((method_call #sync #"Cond'ptr" #"Signal" (![#ptrT] (struct.field_ref #AppendOnlyFile #"lengthCond"%go (![#ptrT] "a")))) #());;;
    (for: (λ: <>, (~ (![#boolT] (struct.field_ref #AppendOnlyFile #"closed"%go (![#ptrT] "a"))))); (λ: <>, Skip) := λ: <>,
      do:  ((method_call #sync #"Cond'ptr" #"Wait" (![#ptrT] (struct.field_ref #AppendOnlyFile #"closedCond"%go (![#ptrT] "a")))) #()));;;
    do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #AppendOnlyFile #"mu"%go (![#ptrT] "a")))) #())).

(* NOTE: cannot be called concurrently with Close()

   go: aof.go:95:26 *)
Definition AppendOnlyFile__Append : val :=
  rec: "AppendOnlyFile__Append" "a" "data" :=
    exception_do (let: "a" := (mem.alloc "a") in
    let: "data" := (mem.alloc "data") in
    do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref #AppendOnlyFile #"mu"%go (![#ptrT] "a")))) #());;;
    let: "$r0" := (let: "$a0" := (![#sliceT] (struct.field_ref #AppendOnlyFile #"membuf"%go (![#ptrT] "a"))) in
    let: "$a1" := (![#sliceT] "data") in
    (func_call #marshal.marshal #"WriteBytes"%go) "$a0" "$a1") in
    do:  ((struct.field_ref #AppendOnlyFile #"membuf"%go (![#ptrT] "a")) <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#uint64T] (struct.field_ref #AppendOnlyFile #"length"%go (![#ptrT] "a"))) in
    let: "$a1" := (s_to_w64 (let: "$a0" := (![#sliceT] "data") in
    slice.len "$a0")) in
    (func_call #std.std #"SumAssumeNoOverflow"%go) "$a0" "$a1") in
    do:  ((struct.field_ref #AppendOnlyFile #"length"%go (![#ptrT] "a")) <-[#uint64T] "$r0");;;
    let: "r" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (![#uint64T] (struct.field_ref #AppendOnlyFile #"length"%go (![#ptrT] "a"))) in
    do:  ("r" <-[#uint64T] "$r0");;;
    do:  ((method_call #sync #"Cond'ptr" #"Signal" (![#ptrT] (struct.field_ref #AppendOnlyFile #"lengthCond"%go (![#ptrT] "a")))) #());;;
    do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #AppendOnlyFile #"mu"%go (![#ptrT] "a")))) #());;;
    return: (![#uint64T] "r")).

(* go: aof.go:109:26 *)
Definition AppendOnlyFile__WaitAppend : val :=
  rec: "AppendOnlyFile__WaitAppend" "a" "length" :=
    exception_do (let: "a" := (mem.alloc "a") in
    let: "length" := (mem.alloc "length") in
    do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref #AppendOnlyFile #"mu"%go (![#ptrT] "a")))) #());;;
    let: "cond" := (mem.alloc (type.zero_val #ptrT)) in
    (if: ((![#uint64T] "length") + (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref #AppendOnlyFile #"membuf"%go (![#ptrT] "a"))) in
    slice.len "$a0"))) ≤ (![#uint64T] (struct.field_ref #AppendOnlyFile #"length"%go (![#ptrT] "a")))
    then
      let: "$r0" := (![#ptrT] (struct.field_ref #AppendOnlyFile #"oldDurableCond"%go (![#ptrT] "a"))) in
      do:  ("cond" <-[#ptrT] "$r0")
    else
      let: "$r0" := (![#ptrT] (struct.field_ref #AppendOnlyFile #"durableCond"%go (![#ptrT] "a"))) in
      do:  ("cond" <-[#ptrT] "$r0"));;;
    (for: (λ: <>, (![#uint64T] (struct.field_ref #AppendOnlyFile #"durableLength"%go (![#ptrT] "a"))) < (![#uint64T] "length")); (λ: <>, Skip) := λ: <>,
      do:  ((method_call #sync #"Cond'ptr" #"Wait" (![#ptrT] "cond")) #()));;;
    do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #AppendOnlyFile #"mu"%go (![#ptrT] "a")))) #())).

Definition vars' : list (go_string * go_type) := [].

Definition functions' : list (go_string * val) := [("CreateAppendOnlyFile"%go, CreateAppendOnlyFile)].

Definition msets' : list (go_string * (list (go_string * val))) := [("AppendOnlyFile"%go, []); ("AppendOnlyFile'ptr"%go, [("Append"%go, AppendOnlyFile__Append); ("Close"%go, AppendOnlyFile__Close); ("WaitAppend"%go, AppendOnlyFile__WaitAppend)])].

#[global] Instance info' : PkgInfo aof.aof :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [sync.sync; std.std; grove_ffi.grove_ffi; marshal.marshal];
  |}.

Definition initialize' : val :=
  rec: "initialize'" <> :=
    globals.package_init aof.aof (λ: <>,
      exception_do (do:  marshal.initialize';;;
      do:  grove_ffi.initialize';;;
      do:  std.initialize';;;
      do:  sync.initialize')
      ).

End code.
End aof.
