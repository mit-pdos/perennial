(* autogenerated from github.com/mit-pdos/gokv/aof *)
Require Export New.code.sync.
Require Export New.code.github_com.goose_lang.std.
Require Export New.code.github_com.mit_pdos.gokv.grove_ffi.
Require Export New.code.github_com.tchajed.marshal.
From New.golang Require Import defn.
From New Require Import grove_prelude.
Module pkg_id.
Definition aof : go_string := "github.com/mit-pdos/gokv/aof".

End pkg_id.
Export pkg_id.
Module aof.

Definition AppendOnlyFile {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/mit-pdos/gokv/aof.AppendOnlyFile"%go [].

Definition CreateAppendOnlyFile {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/gokv/aof.CreateAppendOnlyFile"%go.

(* go: aof.go:29:6 *)
Definition CreateAppendOnlyFileⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "fname",
    exception_do (let: "fname" := (GoAlloc go.string "fname") in
    let: "a" := (GoAlloc (go.PointerType AppendOnlyFile) (GoZeroVal (go.PointerType AppendOnlyFile) #())) in
    let: "$r0" := (GoAlloc AppendOnlyFile (GoZeroVal AppendOnlyFile #())) in
    do:  ("a" <-[go.PointerType AppendOnlyFile] "$r0");;;
    let: "$r0" := (GoAlloc sync.Mutex (GoZeroVal sync.Mutex #())) in
    do:  ((StructFieldRef AppendOnlyFile "mu"%go (![go.PointerType AppendOnlyFile] "a")) <-[go.PointerType sync.Mutex] "$r0");;;
    let: "$r0" := (let: "$a0" := (Convert (go.PointerType sync.Mutex) sync.Locker (![go.PointerType sync.Mutex] (StructFieldRef AppendOnlyFile "mu"%go (![go.PointerType AppendOnlyFile] "a")))) in
    (FuncResolve sync.NewCond [] #()) "$a0") in
    do:  ((StructFieldRef AppendOnlyFile "lengthCond"%go (![go.PointerType AppendOnlyFile] "a")) <-[go.PointerType sync.Cond] "$r0");;;
    let: "$r0" := (let: "$a0" := (Convert (go.PointerType sync.Mutex) sync.Locker (![go.PointerType sync.Mutex] (StructFieldRef AppendOnlyFile "mu"%go (![go.PointerType AppendOnlyFile] "a")))) in
    (FuncResolve sync.NewCond [] #()) "$a0") in
    do:  ((StructFieldRef AppendOnlyFile "oldDurableCond"%go (![go.PointerType AppendOnlyFile] "a")) <-[go.PointerType sync.Cond] "$r0");;;
    let: "$r0" := (let: "$a0" := (Convert (go.PointerType sync.Mutex) sync.Locker (![go.PointerType sync.Mutex] (StructFieldRef AppendOnlyFile "mu"%go (![go.PointerType AppendOnlyFile] "a")))) in
    (FuncResolve sync.NewCond [] #()) "$a0") in
    do:  ((StructFieldRef AppendOnlyFile "durableCond"%go (![go.PointerType AppendOnlyFile] "a")) <-[go.PointerType sync.Cond] "$r0");;;
    let: "$r0" := (let: "$a0" := (Convert (go.PointerType sync.Mutex) sync.Locker (![go.PointerType sync.Mutex] (StructFieldRef AppendOnlyFile "mu"%go (![go.PointerType AppendOnlyFile] "a")))) in
    (FuncResolve sync.NewCond [] #()) "$a0") in
    do:  ((StructFieldRef AppendOnlyFile "closedCond"%go (![go.PointerType AppendOnlyFile] "a")) <-[go.PointerType sync.Cond] "$r0");;;
    let: "$go" := (λ: <>,
      exception_do (do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] (StructFieldRef AppendOnlyFile "mu"%go (![go.PointerType AppendOnlyFile] "a")))) #());;;
      (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
        (if: ((let: "$a0" := (![go.SliceType go.byte] (StructFieldRef AppendOnlyFile "membuf"%go (![go.PointerType AppendOnlyFile] "a"))) in
        (FuncResolve go.len [go.SliceType go.byte] #()) "$a0") =⟨go.int⟩ #(W64 0)) && (⟨go.bool⟩! (![go.bool] (StructFieldRef AppendOnlyFile "closeRequested"%go (![go.PointerType AppendOnlyFile] "a"))))
        then
          do:  ((MethodResolve (go.PointerType sync.Cond) "Wait"%go (![go.PointerType sync.Cond] (StructFieldRef AppendOnlyFile "lengthCond"%go (![go.PointerType AppendOnlyFile] "a")))) #());;;
          continue: #()
        else do:  #());;;
        (if: ![go.bool] (StructFieldRef AppendOnlyFile "closeRequested"%go (![go.PointerType AppendOnlyFile] "a"))
        then
          do:  (let: "$a0" := (![go.string] "fname") in
          let: "$a1" := (![go.SliceType go.byte] (StructFieldRef AppendOnlyFile "membuf"%go (![go.PointerType AppendOnlyFile] "a"))) in
          (FuncResolve grove_ffi.FileAppend [] #()) "$a0" "$a1");;;
          let: "$r0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 0)) in
          do:  ((StructFieldRef AppendOnlyFile "membuf"%go (![go.PointerType AppendOnlyFile] "a")) <-[go.SliceType go.byte] "$r0");;;
          let: "$r0" := (![go.uint64] (StructFieldRef AppendOnlyFile "length"%go (![go.PointerType AppendOnlyFile] "a"))) in
          do:  ((StructFieldRef AppendOnlyFile "durableLength"%go (![go.PointerType AppendOnlyFile] "a")) <-[go.uint64] "$r0");;;
          do:  ((MethodResolve (go.PointerType sync.Cond) "Broadcast"%go (![go.PointerType sync.Cond] (StructFieldRef AppendOnlyFile "durableCond"%go (![go.PointerType AppendOnlyFile] "a")))) #());;;
          let: "$r0" := #true in
          do:  ((StructFieldRef AppendOnlyFile "closed"%go (![go.PointerType AppendOnlyFile] "a")) <-[go.bool] "$r0");;;
          do:  ((MethodResolve (go.PointerType sync.Cond) "Broadcast"%go (![go.PointerType sync.Cond] (StructFieldRef AppendOnlyFile "closedCond"%go (![go.PointerType AppendOnlyFile] "a")))) #());;;
          do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef AppendOnlyFile "mu"%go (![go.PointerType AppendOnlyFile] "a")))) #());;;
          break: #()
        else do:  #());;;
        let: "l" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
        let: "$r0" := (![go.SliceType go.byte] (StructFieldRef AppendOnlyFile "membuf"%go (![go.PointerType AppendOnlyFile] "a"))) in
        do:  ("l" <-[go.SliceType go.byte] "$r0");;;
        let: "newLength" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
        let: "$r0" := (![go.uint64] (StructFieldRef AppendOnlyFile "length"%go (![go.PointerType AppendOnlyFile] "a"))) in
        do:  ("newLength" <-[go.uint64] "$r0");;;
        let: "$r0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 0)) in
        do:  ((StructFieldRef AppendOnlyFile "membuf"%go (![go.PointerType AppendOnlyFile] "a")) <-[go.SliceType go.byte] "$r0");;;
        let: "cond" := (GoAlloc (go.PointerType sync.Cond) (GoZeroVal (go.PointerType sync.Cond) #())) in
        let: "$r0" := (![go.PointerType sync.Cond] (StructFieldRef AppendOnlyFile "durableCond"%go (![go.PointerType AppendOnlyFile] "a"))) in
        do:  ("cond" <-[go.PointerType sync.Cond] "$r0");;;
        let: "$r0" := (![go.PointerType sync.Cond] (StructFieldRef AppendOnlyFile "oldDurableCond"%go (![go.PointerType AppendOnlyFile] "a"))) in
        do:  ((StructFieldRef AppendOnlyFile "durableCond"%go (![go.PointerType AppendOnlyFile] "a")) <-[go.PointerType sync.Cond] "$r0");;;
        let: "$r0" := (![go.PointerType sync.Cond] "cond") in
        do:  ((StructFieldRef AppendOnlyFile "oldDurableCond"%go (![go.PointerType AppendOnlyFile] "a")) <-[go.PointerType sync.Cond] "$r0");;;
        do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef AppendOnlyFile "mu"%go (![go.PointerType AppendOnlyFile] "a")))) #());;;
        do:  (let: "$a0" := (![go.string] "fname") in
        let: "$a1" := (![go.SliceType go.byte] "l") in
        (FuncResolve grove_ffi.FileAppend [] #()) "$a0" "$a1");;;
        do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] (StructFieldRef AppendOnlyFile "mu"%go (![go.PointerType AppendOnlyFile] "a")))) #());;;
        let: "$r0" := (![go.uint64] "newLength") in
        do:  ((StructFieldRef AppendOnlyFile "durableLength"%go (![go.PointerType AppendOnlyFile] "a")) <-[go.uint64] "$r0");;;
        do:  ((MethodResolve (go.PointerType sync.Cond) "Broadcast"%go (![go.PointerType sync.Cond] "cond")) #());;;
        continue: #());;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    return: (![go.PointerType AppendOnlyFile] "a")).

(* NOTE: cannot be called concurrently with Append()

   go: aof.go:84:26 *)
Definition AppendOnlyFile__Closeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "a" <>,
    exception_do (let: "a" := (GoAlloc (go.PointerType AppendOnlyFile) "a") in
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] (StructFieldRef AppendOnlyFile "mu"%go (![go.PointerType AppendOnlyFile] "a")))) #());;;
    let: "$r0" := #true in
    do:  ((StructFieldRef AppendOnlyFile "closeRequested"%go (![go.PointerType AppendOnlyFile] "a")) <-[go.bool] "$r0");;;
    do:  ((MethodResolve (go.PointerType sync.Cond) "Signal"%go (![go.PointerType sync.Cond] (StructFieldRef AppendOnlyFile "lengthCond"%go (![go.PointerType AppendOnlyFile] "a")))) #());;;
    (for: (λ: <>, (⟨go.bool⟩! (![go.bool] (StructFieldRef AppendOnlyFile "closed"%go (![go.PointerType AppendOnlyFile] "a"))))); (λ: <>, #()) := λ: <>,
      do:  ((MethodResolve (go.PointerType sync.Cond) "Wait"%go (![go.PointerType sync.Cond] (StructFieldRef AppendOnlyFile "closedCond"%go (![go.PointerType AppendOnlyFile] "a")))) #()));;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef AppendOnlyFile "mu"%go (![go.PointerType AppendOnlyFile] "a")))) #());;;
    return: #()).

(* NOTE: cannot be called concurrently with Close()

   go: aof.go:95:26 *)
Definition AppendOnlyFile__Appendⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "a" "data",
    exception_do (let: "a" := (GoAlloc (go.PointerType AppendOnlyFile) "a") in
    let: "data" := (GoAlloc (go.SliceType go.byte) "data") in
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] (StructFieldRef AppendOnlyFile "mu"%go (![go.PointerType AppendOnlyFile] "a")))) #());;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] (StructFieldRef AppendOnlyFile "membuf"%go (![go.PointerType AppendOnlyFile] "a"))) in
    let: "$a1" := (![go.SliceType go.byte] "data") in
    (FuncResolve marshal.WriteBytes [] #()) "$a0" "$a1") in
    do:  ((StructFieldRef AppendOnlyFile "membuf"%go (![go.PointerType AppendOnlyFile] "a")) <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.uint64] (StructFieldRef AppendOnlyFile "length"%go (![go.PointerType AppendOnlyFile] "a"))) in
    let: "$a1" := (Convert go.int go.uint64 (let: "$a0" := (![go.SliceType go.byte] "data") in
    (FuncResolve go.len [go.SliceType go.byte] #()) "$a0")) in
    (FuncResolve std.SumAssumeNoOverflow [] #()) "$a0" "$a1") in
    do:  ((StructFieldRef AppendOnlyFile "length"%go (![go.PointerType AppendOnlyFile] "a")) <-[go.uint64] "$r0");;;
    let: "r" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (![go.uint64] (StructFieldRef AppendOnlyFile "length"%go (![go.PointerType AppendOnlyFile] "a"))) in
    do:  ("r" <-[go.uint64] "$r0");;;
    do:  ((MethodResolve (go.PointerType sync.Cond) "Signal"%go (![go.PointerType sync.Cond] (StructFieldRef AppendOnlyFile "lengthCond"%go (![go.PointerType AppendOnlyFile] "a")))) #());;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef AppendOnlyFile "mu"%go (![go.PointerType AppendOnlyFile] "a")))) #());;;
    return: (![go.uint64] "r")).

(* go: aof.go:109:26 *)
Definition AppendOnlyFile__WaitAppendⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "a" "length",
    exception_do (let: "a" := (GoAlloc (go.PointerType AppendOnlyFile) "a") in
    let: "length" := (GoAlloc go.uint64 "length") in
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] (StructFieldRef AppendOnlyFile "mu"%go (![go.PointerType AppendOnlyFile] "a")))) #());;;
    let: "cond" := (GoAlloc (go.PointerType sync.Cond) (GoZeroVal (go.PointerType sync.Cond) #())) in
    (if: Convert go.untyped_bool go.bool (((![go.uint64] "length") +⟨go.uint64⟩ (Convert go.int go.uint64 (let: "$a0" := (![go.SliceType go.byte] (StructFieldRef AppendOnlyFile "membuf"%go (![go.PointerType AppendOnlyFile] "a"))) in
    (FuncResolve go.len [go.SliceType go.byte] #()) "$a0"))) ≤⟨go.uint64⟩ (![go.uint64] (StructFieldRef AppendOnlyFile "length"%go (![go.PointerType AppendOnlyFile] "a"))))
    then
      let: "$r0" := (![go.PointerType sync.Cond] (StructFieldRef AppendOnlyFile "oldDurableCond"%go (![go.PointerType AppendOnlyFile] "a"))) in
      do:  ("cond" <-[go.PointerType sync.Cond] "$r0")
    else
      let: "$r0" := (![go.PointerType sync.Cond] (StructFieldRef AppendOnlyFile "durableCond"%go (![go.PointerType AppendOnlyFile] "a"))) in
      do:  ("cond" <-[go.PointerType sync.Cond] "$r0"));;;
    (for: (λ: <>, (![go.uint64] (StructFieldRef AppendOnlyFile "durableLength"%go (![go.PointerType AppendOnlyFile] "a"))) <⟨go.uint64⟩ (![go.uint64] "length")); (λ: <>, #()) := λ: <>,
      do:  ((MethodResolve (go.PointerType sync.Cond) "Wait"%go (![go.PointerType sync.Cond] "cond")) #()));;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef AppendOnlyFile "mu"%go (![go.PointerType AppendOnlyFile] "a")))) #());;;
    return: #()).

#[global] Instance info' : PkgInfo pkg_id.aof :=
{|
  pkg_imported_pkgs := [code.sync.pkg_id.sync; code.github_com.goose_lang.std.pkg_id.std; code.github_com.mit_pdos.gokv.grove_ffi.pkg_id.grove_ffi; code.github_com.tchajed.marshal.pkg_id.marshal]
|}.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init pkg_id.aof (λ: <>,
      exception_do (do:  (marshal.initialize' #());;;
      do:  (grove_ffi.initialize' #());;;
      do:  (std.initialize' #());;;
      do:  (sync.initialize' #()))
      ).

Module AppendOnlyFile.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  mu' : loc;
  oldDurableCond' : loc;
  durableCond' : loc;
  lengthCond' : loc;
  membuf' : slice.t;
  length' : w64;
  durableLength' : w64;
  closeRequested' : bool;
  closed' : bool;
  closedCond' : loc;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End AppendOnlyFile.

Definition AppendOnlyFile'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "mu"%go (go.PointerType sync.Mutex));
  (go.FieldDecl "oldDurableCond"%go (go.PointerType sync.Cond));
  (go.FieldDecl "durableCond"%go (go.PointerType sync.Cond));
  (go.FieldDecl "lengthCond"%go (go.PointerType sync.Cond));
  (go.FieldDecl "membuf"%go (go.SliceType go.byte));
  (go.FieldDecl "length"%go go.uint64);
  (go.FieldDecl "durableLength"%go go.uint64);
  (go.FieldDecl "closeRequested"%go go.bool);
  (go.FieldDecl "closed"%go go.bool);
  (go.FieldDecl "closedCond"%go (go.PointerType sync.Cond))
].
Program Definition AppendOnlyFile'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (AppendOnlyFile'fds_unsealed).
Global Instance equals_unfold_AppendOnlyFile {ext : ffi_syntax} {go_gctx : GoGlobalContext} : AppendOnlyFile'fds =→ AppendOnlyFile'fds_unsealed.
Proof. rewrite /AppendOnlyFile'fds seal_eq //. Qed.

Definition AppendOnlyFileⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (AppendOnlyFile'fds).

Class AppendOnlyFile_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] AppendOnlyFile_type_repr  :: go.TypeReprUnderlying AppendOnlyFileⁱᵐᵖˡ AppendOnlyFile.t;
  #[global] AppendOnlyFile_underlying :: (AppendOnlyFile) <u (AppendOnlyFileⁱᵐᵖˡ);
  #[global] AppendOnlyFile_get_mu (x : AppendOnlyFile.t) :: ⟦StructFieldGet (AppendOnlyFileⁱᵐᵖˡ) "mu", #x⟧ ⤳[under] #x.(AppendOnlyFile.mu');
  #[global] AppendOnlyFile_set_mu (x : AppendOnlyFile.t) y :: ⟦StructFieldSet (AppendOnlyFileⁱᵐᵖˡ) "mu", (#x, #y)⟧ ⤳[under] #(x <|AppendOnlyFile.mu' := y|>);
  #[global] AppendOnlyFile_get_oldDurableCond (x : AppendOnlyFile.t) :: ⟦StructFieldGet (AppendOnlyFileⁱᵐᵖˡ) "oldDurableCond", #x⟧ ⤳[under] #x.(AppendOnlyFile.oldDurableCond');
  #[global] AppendOnlyFile_set_oldDurableCond (x : AppendOnlyFile.t) y :: ⟦StructFieldSet (AppendOnlyFileⁱᵐᵖˡ) "oldDurableCond", (#x, #y)⟧ ⤳[under] #(x <|AppendOnlyFile.oldDurableCond' := y|>);
  #[global] AppendOnlyFile_get_durableCond (x : AppendOnlyFile.t) :: ⟦StructFieldGet (AppendOnlyFileⁱᵐᵖˡ) "durableCond", #x⟧ ⤳[under] #x.(AppendOnlyFile.durableCond');
  #[global] AppendOnlyFile_set_durableCond (x : AppendOnlyFile.t) y :: ⟦StructFieldSet (AppendOnlyFileⁱᵐᵖˡ) "durableCond", (#x, #y)⟧ ⤳[under] #(x <|AppendOnlyFile.durableCond' := y|>);
  #[global] AppendOnlyFile_get_lengthCond (x : AppendOnlyFile.t) :: ⟦StructFieldGet (AppendOnlyFileⁱᵐᵖˡ) "lengthCond", #x⟧ ⤳[under] #x.(AppendOnlyFile.lengthCond');
  #[global] AppendOnlyFile_set_lengthCond (x : AppendOnlyFile.t) y :: ⟦StructFieldSet (AppendOnlyFileⁱᵐᵖˡ) "lengthCond", (#x, #y)⟧ ⤳[under] #(x <|AppendOnlyFile.lengthCond' := y|>);
  #[global] AppendOnlyFile_get_membuf (x : AppendOnlyFile.t) :: ⟦StructFieldGet (AppendOnlyFileⁱᵐᵖˡ) "membuf", #x⟧ ⤳[under] #x.(AppendOnlyFile.membuf');
  #[global] AppendOnlyFile_set_membuf (x : AppendOnlyFile.t) y :: ⟦StructFieldSet (AppendOnlyFileⁱᵐᵖˡ) "membuf", (#x, #y)⟧ ⤳[under] #(x <|AppendOnlyFile.membuf' := y|>);
  #[global] AppendOnlyFile_get_length (x : AppendOnlyFile.t) :: ⟦StructFieldGet (AppendOnlyFileⁱᵐᵖˡ) "length", #x⟧ ⤳[under] #x.(AppendOnlyFile.length');
  #[global] AppendOnlyFile_set_length (x : AppendOnlyFile.t) y :: ⟦StructFieldSet (AppendOnlyFileⁱᵐᵖˡ) "length", (#x, #y)⟧ ⤳[under] #(x <|AppendOnlyFile.length' := y|>);
  #[global] AppendOnlyFile_get_durableLength (x : AppendOnlyFile.t) :: ⟦StructFieldGet (AppendOnlyFileⁱᵐᵖˡ) "durableLength", #x⟧ ⤳[under] #x.(AppendOnlyFile.durableLength');
  #[global] AppendOnlyFile_set_durableLength (x : AppendOnlyFile.t) y :: ⟦StructFieldSet (AppendOnlyFileⁱᵐᵖˡ) "durableLength", (#x, #y)⟧ ⤳[under] #(x <|AppendOnlyFile.durableLength' := y|>);
  #[global] AppendOnlyFile_get_closeRequested (x : AppendOnlyFile.t) :: ⟦StructFieldGet (AppendOnlyFileⁱᵐᵖˡ) "closeRequested", #x⟧ ⤳[under] #x.(AppendOnlyFile.closeRequested');
  #[global] AppendOnlyFile_set_closeRequested (x : AppendOnlyFile.t) y :: ⟦StructFieldSet (AppendOnlyFileⁱᵐᵖˡ) "closeRequested", (#x, #y)⟧ ⤳[under] #(x <|AppendOnlyFile.closeRequested' := y|>);
  #[global] AppendOnlyFile_get_closed (x : AppendOnlyFile.t) :: ⟦StructFieldGet (AppendOnlyFileⁱᵐᵖˡ) "closed", #x⟧ ⤳[under] #x.(AppendOnlyFile.closed');
  #[global] AppendOnlyFile_set_closed (x : AppendOnlyFile.t) y :: ⟦StructFieldSet (AppendOnlyFileⁱᵐᵖˡ) "closed", (#x, #y)⟧ ⤳[under] #(x <|AppendOnlyFile.closed' := y|>);
  #[global] AppendOnlyFile_get_closedCond (x : AppendOnlyFile.t) :: ⟦StructFieldGet (AppendOnlyFileⁱᵐᵖˡ) "closedCond", #x⟧ ⤳[under] #x.(AppendOnlyFile.closedCond');
  #[global] AppendOnlyFile_set_closedCond (x : AppendOnlyFile.t) y :: ⟦StructFieldSet (AppendOnlyFileⁱᵐᵖˡ) "closedCond", (#x, #y)⟧ ⤳[under] #(x <|AppendOnlyFile.closedCond' := y|>);
  #[global] AppendOnlyFile'ptr_Append_unfold :: MethodUnfold (go.PointerType (AppendOnlyFile)) "Append" (AppendOnlyFile__Appendⁱᵐᵖˡ);
  #[global] AppendOnlyFile'ptr_Close_unfold :: MethodUnfold (go.PointerType (AppendOnlyFile)) "Close" (AppendOnlyFile__Closeⁱᵐᵖˡ);
  #[global] AppendOnlyFile'ptr_WaitAppend_unfold :: MethodUnfold (go.PointerType (AppendOnlyFile)) "WaitAppend" (AppendOnlyFile__WaitAppendⁱᵐᵖˡ);
}.

Class Assumptions `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] AppendOnlyFile_instance :: AppendOnlyFile_Assumptions;
  #[global] CreateAppendOnlyFile_unfold :: FuncUnfold CreateAppendOnlyFile [] (CreateAppendOnlyFileⁱᵐᵖˡ);
  #[global] import_sync_Assumption :: sync.Assumptions;
  #[global] import_std_Assumption :: std.Assumptions;
  #[global] import_grove_ffi_Assumption :: grove_ffi.Assumptions;
  #[global] import_marshal_Assumption :: marshal.Assumptions;
}.
End aof.
