(* autogenerated from github.com/mit-pdos/gokv/vrsm/paxos *)
From New.golang Require Import defn.
From New.code Require github_com.goose_lang.std.
From New.code Require github_com.mit_pdos.gokv.asyncfile.
From New.code Require github_com.mit_pdos.gokv.grove_ffi.
From New.code Require github_com.mit_pdos.gokv.reconnectclient.
From New.code Require github_com.mit_pdos.gokv.urpc.
From New.code Require github_com.tchajed.marshal.
From New.code Require log.
From New.code Require sync.

From New Require Import grove_prelude.

Definition RPC_APPLY_AS_FOLLOWER : expr := #(W64 0).

Definition RPC_ENTER_NEW_EPOCH : expr := #(W64 1).

Definition RPC_BECOME_LEADER : expr := #(W64 2).

Definition singleClerk : go_type := structT [
  "cl" :: ptrT
].

Definition singleClerk__mset : list (string * val) := [
].

(* go: internalclerk.go:51:23 *)
Definition singleClerk__TryBecomeLeader : val :=
  rec: "singleClerk__TryBecomeLeader" "s" <> :=
    exception_do (let: "s" := (ref_ty ptrT "s") in
    let: "reply" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty (sliceT byteT) (zero_val (sliceT byteT))) in
    do:  ("reply" <-[ptrT] "$r0");;;
    do:  (let: "$a0" := RPC_BECOME_LEADER in
    let: "$a1" := (slice.make2 byteT #(W64 0)) in
    let: "$a2" := (![ptrT] "reply") in
    let: "$a3" := #(W64 500) in
    (reconnectclient.ReconnectingClient__Call (![ptrT] (struct.field_ref singleClerk "cl" (![ptrT] "s")))) "$a0" "$a1" "$a2" "$a3")).

Definition Error : go_type := uint64T.

Definition applyAsFollowerReply : go_type := structT [
  "err" :: Error
].

Definition ETimeout : expr := #(W64 3).

(* go: marshal.go:41:6 *)
Definition decodeApplyAsFollowerReply : val :=
  rec: "decodeApplyAsFollowerReply" "s" :=
    exception_do (let: "s" := (ref_ty (sliceT byteT) "s") in
    let: "o" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty applyAsFollowerReply (struct.make applyAsFollowerReply [{
    }])) in
    do:  ("o" <-[ptrT] "$r0");;;
    let: "err" := (ref_ty uint64T (zero_val uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![sliceT byteT] "s") in
    marshal.ReadInt "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("err" <-[uint64T] "$r0");;;
    do:  "$r1";;;
    let: "$r0" := (![uint64T] "err") in
    do:  ((struct.field_ref applyAsFollowerReply "err" (![ptrT] "o")) <-[Error] "$r0");;;
    return: (![ptrT] "o")).

Definition applyAsFollowerArgs : go_type := structT [
  "epoch" :: uint64T;
  "nextIndex" :: uint64T;
  "state" :: sliceT byteT
].

(* go: marshal.go:21:6 *)
Definition encodeApplyAsFollowerArgs : val :=
  rec: "encodeApplyAsFollowerArgs" "o" :=
    exception_do (let: "o" := (ref_ty ptrT "o") in
    let: "enc" := (ref_ty (sliceT byteT) (zero_val (sliceT byteT))) in
    let: "$r0" := (slice.make3 byteT #(W64 0) (#(W64 (8 + 8)) + (let: "$a0" := (![sliceT byteT] (struct.field_ref applyAsFollowerArgs "state" (![ptrT] "o"))) in
    slice.len "$a0"))) in
    do:  ("enc" <-[sliceT byteT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT byteT] "enc") in
    let: "$a1" := (![uint64T] (struct.field_ref applyAsFollowerArgs "epoch" (![ptrT] "o"))) in
    marshal.WriteInt "$a0" "$a1") in
    do:  ("enc" <-[sliceT byteT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT byteT] "enc") in
    let: "$a1" := (![uint64T] (struct.field_ref applyAsFollowerArgs "nextIndex" (![ptrT] "o"))) in
    marshal.WriteInt "$a0" "$a1") in
    do:  ("enc" <-[sliceT byteT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT byteT] "enc") in
    let: "$a1" := (![sliceT byteT] (struct.field_ref applyAsFollowerArgs "state" (![ptrT] "o"))) in
    marshal.WriteBytes "$a0" "$a1") in
    do:  ("enc" <-[sliceT byteT] "$r0");;;
    return: (![sliceT byteT] "enc")).

(* go: internalclerk.go:40:23 *)
Definition singleClerk__applyAsFollower : val :=
  rec: "singleClerk__applyAsFollower" "s" "args" :=
    exception_do (let: "s" := (ref_ty ptrT "s") in
    let: "args" := (ref_ty ptrT "args") in
    let: "raw_args" := (ref_ty (sliceT byteT) (zero_val (sliceT byteT))) in
    let: "$r0" := (let: "$a0" := (![ptrT] "args") in
    encodeApplyAsFollowerArgs "$a0") in
    do:  ("raw_args" <-[sliceT byteT] "$r0");;;
    let: "raw_reply" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty (sliceT byteT) (zero_val (sliceT byteT))) in
    do:  ("raw_reply" <-[ptrT] "$r0");;;
    let: "err" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (let: "$a0" := RPC_APPLY_AS_FOLLOWER in
    let: "$a1" := (![sliceT byteT] "raw_args") in
    let: "$a2" := (![ptrT] "raw_reply") in
    let: "$a3" := #(W64 500) in
    (reconnectclient.ReconnectingClient__Call (![ptrT] (struct.field_ref singleClerk "cl" (![ptrT] "s")))) "$a0" "$a1" "$a2" "$a3") in
    do:  ("err" <-[uint64T] "$r0");;;
    (if: (![uint64T] "err") = #(W64 0)
    then
      return: (let: "$a0" := (![sliceT byteT] (![ptrT] "raw_reply")) in
       decodeApplyAsFollowerReply "$a0")
    else
      return: (ref_ty applyAsFollowerReply (struct.make applyAsFollowerReply [{
         "err" ::= ETimeout
       }])))).

Definition enterNewEpochReply : go_type := structT [
  "err" :: Error;
  "acceptedEpoch" :: uint64T;
  "nextIndex" :: uint64T;
  "state" :: sliceT byteT
].

(* go: marshal.go:77:6 *)
Definition decodeEnterNewEpochReply : val :=
  rec: "decodeEnterNewEpochReply" "enc" :=
    exception_do (let: "enc" := (ref_ty (sliceT byteT) "enc") in
    let: "o" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty enterNewEpochReply (struct.make enterNewEpochReply [{
    }])) in
    do:  ("o" <-[ptrT] "$r0");;;
    let: "err" := (ref_ty uint64T (zero_val uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![sliceT byteT] "enc") in
    marshal.ReadInt "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("err" <-[uint64T] "$r0");;;
    do:  ("enc" <-[sliceT byteT] "$r1");;;
    let: "$r0" := (![uint64T] "err") in
    do:  ((struct.field_ref enterNewEpochReply "err" (![ptrT] "o")) <-[Error] "$r0");;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![sliceT byteT] "enc") in
    marshal.ReadInt "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ((struct.field_ref enterNewEpochReply "acceptedEpoch" (![ptrT] "o")) <-[uint64T] "$r0");;;
    do:  ("enc" <-[sliceT byteT] "$r1");;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![sliceT byteT] "enc") in
    marshal.ReadInt "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ((struct.field_ref enterNewEpochReply "nextIndex" (![ptrT] "o")) <-[uint64T] "$r0");;;
    do:  ("enc" <-[sliceT byteT] "$r1");;;
    let: "$r0" := (![sliceT byteT] "enc") in
    do:  ((struct.field_ref enterNewEpochReply "state" (![ptrT] "o")) <-[sliceT byteT] "$r0");;;
    return: (![ptrT] "o")).

Definition enterNewEpochArgs : go_type := structT [
  "epoch" :: uint64T
].

(* go: marshal.go:58:6 *)
Definition encodeEnterNewEpochArgs : val :=
  rec: "encodeEnterNewEpochArgs" "o" :=
    exception_do (let: "o" := (ref_ty ptrT "o") in
    let: "enc" := (ref_ty (sliceT byteT) (zero_val (sliceT byteT))) in
    let: "$r0" := (slice.make3 byteT #(W64 0) #(W64 8)) in
    do:  ("enc" <-[sliceT byteT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT byteT] "enc") in
    let: "$a1" := (![uint64T] (struct.field_ref enterNewEpochArgs "epoch" (![ptrT] "o"))) in
    marshal.WriteInt "$a0" "$a1") in
    do:  ("enc" <-[sliceT byteT] "$r0");;;
    return: (![sliceT byteT] "enc")).

(* go: internalclerk.go:28:23 *)
Definition singleClerk__enterNewEpoch : val :=
  rec: "singleClerk__enterNewEpoch" "s" "args" :=
    exception_do (let: "s" := (ref_ty ptrT "s") in
    let: "args" := (ref_ty ptrT "args") in
    let: "raw_args" := (ref_ty (sliceT byteT) (zero_val (sliceT byteT))) in
    let: "$r0" := (let: "$a0" := (![ptrT] "args") in
    encodeEnterNewEpochArgs "$a0") in
    do:  ("raw_args" <-[sliceT byteT] "$r0");;;
    let: "raw_reply" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty (sliceT byteT) (zero_val (sliceT byteT))) in
    do:  ("raw_reply" <-[ptrT] "$r0");;;
    let: "err" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (let: "$a0" := RPC_ENTER_NEW_EPOCH in
    let: "$a1" := (![sliceT byteT] "raw_args") in
    let: "$a2" := (![ptrT] "raw_reply") in
    let: "$a3" := #(W64 500) in
    (reconnectclient.ReconnectingClient__Call (![ptrT] (struct.field_ref singleClerk "cl" (![ptrT] "s")))) "$a0" "$a1" "$a2" "$a3") in
    do:  ("err" <-[uint64T] "$r0");;;
    (if: (![uint64T] "err") = #(W64 0)
    then
      return: (let: "$a0" := (![sliceT byteT] (![ptrT] "raw_reply")) in
       decodeEnterNewEpochReply "$a0")
    else
      return: (ref_ty enterNewEpochReply (struct.make enterNewEpochReply [{
         "err" ::= ETimeout
       }])))).

Definition singleClerk__mset_ptr : list (string * val) := [
  ("TryBecomeLeader", singleClerk__TryBecomeLeader%V);
  ("applyAsFollower", singleClerk__applyAsFollower%V);
  ("enterNewEpoch", singleClerk__enterNewEpoch%V)
].

(* go: internalclerk.go:19:6 *)
Definition MakeSingleClerk : val :=
  rec: "MakeSingleClerk" "addr" :=
    exception_do (let: "addr" := (ref_ty uint64T "addr") in
    let: "ck" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty singleClerk (struct.make singleClerk [{
      "cl" ::= let: "$a0" := (![uint64T] "addr") in
      reconnectclient.MakeReconnectingClient "$a0"
    }])) in
    do:  ("ck" <-[ptrT] "$r0");;;
    return: (![ptrT] "ck")).

Definition Error__mset : list (string * val) := [
].

Definition Error__mset_ptr : list (string * val) := [
].

Definition ENone : expr := #(W64 0).

Definition EEpochStale : expr := #(W64 1).

Definition EOutOfOrder : expr := #(W64 2).

Definition ENotLeader : expr := #(W64 4).

Definition applyAsFollowerArgs__mset : list (string * val) := [
].

Definition applyAsFollowerArgs__mset_ptr : list (string * val) := [
].

(* go: marshal.go:29:6 *)
Definition decodeApplyAsFollowerArgs : val :=
  rec: "decodeApplyAsFollowerArgs" "enc" :=
    exception_do (let: "enc" := (ref_ty (sliceT byteT) "enc") in
    let: "o" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty applyAsFollowerArgs (zero_val applyAsFollowerArgs)) in
    do:  ("o" <-[ptrT] "$r0");;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![sliceT byteT] "enc") in
    marshal.ReadInt "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ((struct.field_ref applyAsFollowerArgs "epoch" (![ptrT] "o")) <-[uint64T] "$r0");;;
    do:  ("enc" <-[sliceT byteT] "$r1");;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![sliceT byteT] "enc") in
    marshal.ReadInt "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ((struct.field_ref applyAsFollowerArgs "nextIndex" (![ptrT] "o")) <-[uint64T] "$r0");;;
    do:  ("enc" <-[sliceT byteT] "$r1");;;
    let: "$r0" := (![sliceT byteT] "enc") in
    do:  ((struct.field_ref applyAsFollowerArgs "state" (![ptrT] "o")) <-[sliceT byteT] "$r0");;;
    return: (![ptrT] "o")).

Definition applyAsFollowerReply__mset : list (string * val) := [
].

Definition applyAsFollowerReply__mset_ptr : list (string * val) := [
].

(* go: marshal.go:48:6 *)
Definition encodeApplyAsFollowerReply : val :=
  rec: "encodeApplyAsFollowerReply" "o" :=
    exception_do (let: "o" := (ref_ty ptrT "o") in
    let: "enc" := (ref_ty (sliceT byteT) (zero_val (sliceT byteT))) in
    let: "$r0" := (slice.make3 byteT #(W64 0) #(W64 8)) in
    do:  ("enc" <-[sliceT byteT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT byteT] "enc") in
    let: "$a1" := (![Error] (struct.field_ref applyAsFollowerReply "err" (![ptrT] "o"))) in
    marshal.WriteInt "$a0" "$a1") in
    do:  ("enc" <-[sliceT byteT] "$r0");;;
    return: (![sliceT byteT] "enc")).

Definition enterNewEpochArgs__mset : list (string * val) := [
].

Definition enterNewEpochArgs__mset_ptr : list (string * val) := [
].

(* go: marshal.go:64:6 *)
Definition decodeEnterNewEpochArgs : val :=
  rec: "decodeEnterNewEpochArgs" "s" :=
    exception_do (let: "s" := (ref_ty (sliceT byteT) "s") in
    let: "o" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty enterNewEpochArgs (zero_val enterNewEpochArgs)) in
    do:  ("o" <-[ptrT] "$r0");;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![sliceT byteT] "s") in
    marshal.ReadInt "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ((struct.field_ref enterNewEpochArgs "epoch" (![ptrT] "o")) <-[uint64T] "$r0");;;
    do:  "$r1";;;
    return: (![ptrT] "o")).

Definition enterNewEpochReply__mset : list (string * val) := [
].

Definition enterNewEpochReply__mset_ptr : list (string * val) := [
].

(* go: marshal.go:89:6 *)
Definition encodeEnterNewEpochReply : val :=
  rec: "encodeEnterNewEpochReply" "o" :=
    exception_do (let: "o" := (ref_ty ptrT "o") in
    let: "enc" := (ref_ty (sliceT byteT) (zero_val (sliceT byteT))) in
    let: "$r0" := (slice.make3 byteT #(W64 0) (#(W64 ((8 + 8) + 8)) + (let: "$a0" := (![sliceT byteT] (struct.field_ref enterNewEpochReply "state" (![ptrT] "o"))) in
    slice.len "$a0"))) in
    do:  ("enc" <-[sliceT byteT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT byteT] "enc") in
    let: "$a1" := (![Error] (struct.field_ref enterNewEpochReply "err" (![ptrT] "o"))) in
    marshal.WriteInt "$a0" "$a1") in
    do:  ("enc" <-[sliceT byteT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT byteT] "enc") in
    let: "$a1" := (![uint64T] (struct.field_ref enterNewEpochReply "acceptedEpoch" (![ptrT] "o"))) in
    marshal.WriteInt "$a0" "$a1") in
    do:  ("enc" <-[sliceT byteT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT byteT] "enc") in
    let: "$a1" := (![uint64T] (struct.field_ref enterNewEpochReply "nextIndex" (![ptrT] "o"))) in
    marshal.WriteInt "$a0" "$a1") in
    do:  ("enc" <-[sliceT byteT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT byteT] "enc") in
    let: "$a1" := (![sliceT byteT] (struct.field_ref enterNewEpochReply "state" (![ptrT] "o"))) in
    marshal.WriteBytes "$a0" "$a1") in
    do:  ("enc" <-[sliceT byteT] "$r0");;;
    return: (![sliceT byteT] "enc")).

Definition applyReply : go_type := structT [
  "err" :: Error;
  "ret" :: sliceT byteT
].

Definition applyReply__mset : list (string * val) := [
].

Definition applyReply__mset_ptr : list (string * val) := [
].

(* go: marshal.go:103:6 *)
Definition encodeApplyReply : val :=
  rec: "encodeApplyReply" "o" :=
    exception_do (let: "o" := (ref_ty ptrT "o") in
    let: "enc" := (ref_ty (sliceT byteT) (zero_val (sliceT byteT))) in
    let: "$r0" := (slice.make3 byteT #(W64 0) (#(W64 8) + (let: "$a0" := (![sliceT byteT] (struct.field_ref applyReply "ret" (![ptrT] "o"))) in
    slice.len "$a0"))) in
    do:  ("enc" <-[sliceT byteT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT byteT] "enc") in
    let: "$a1" := (![Error] (struct.field_ref applyReply "err" (![ptrT] "o"))) in
    marshal.WriteInt "$a0" "$a1") in
    do:  ("enc" <-[sliceT byteT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT byteT] "enc") in
    let: "$a1" := (![sliceT byteT] (struct.field_ref applyReply "ret" (![ptrT] "o"))) in
    marshal.WriteBytes "$a0" "$a1") in
    do:  ("enc" <-[sliceT byteT] "$r0");;;
    return: (![sliceT byteT] "enc")).

(* go: marshal.go:110:6 *)
Definition decodeApplyReply : val :=
  rec: "decodeApplyReply" "enc" :=
    exception_do (let: "enc" := (ref_ty (sliceT byteT) "enc") in
    let: "o" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty applyReply (struct.make applyReply [{
    }])) in
    do:  ("o" <-[ptrT] "$r0");;;
    let: "err" := (ref_ty uint64T (zero_val uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![sliceT byteT] "enc") in
    marshal.ReadInt "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("err" <-[uint64T] "$r0");;;
    do:  ("enc" <-[sliceT byteT] "$r1");;;
    let: "$r0" := (![uint64T] "err") in
    do:  ((struct.field_ref applyReply "err" (![ptrT] "o")) <-[Error] "$r0");;;
    let: "$r0" := (![sliceT byteT] "enc") in
    do:  ((struct.field_ref applyReply "ret" (![ptrT] "o")) <-[sliceT byteT] "$r0");;;
    return: (![ptrT] "o")).

(* go: marshal.go:120:6 *)
Definition boolToU64 : val :=
  rec: "boolToU64" "b" :=
    exception_do (let: "b" := (ref_ty boolT "b") in
    (if: ![boolT] "b"
    then return: (#(W64 1))
    else return: (#(W64 0)))).

Definition paxosState : go_type := structT [
  "epoch" :: uint64T;
  "acceptedEpoch" :: uint64T;
  "nextIndex" :: uint64T;
  "state" :: sliceT byteT;
  "isLeader" :: boolT
].

(* go: marshal.go:128:6 *)
Definition encodePaxosState : val :=
  rec: "encodePaxosState" "ps" :=
    exception_do (let: "ps" := (ref_ty ptrT "ps") in
    let: "e" := (ref_ty (sliceT byteT) (zero_val (sliceT byteT))) in
    let: "$r0" := (slice.make2 byteT #(W64 0)) in
    do:  ("e" <-[sliceT byteT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT byteT] "e") in
    let: "$a1" := (![uint64T] (struct.field_ref paxosState "epoch" (![ptrT] "ps"))) in
    marshal.WriteInt "$a0" "$a1") in
    do:  ("e" <-[sliceT byteT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT byteT] "e") in
    let: "$a1" := (![uint64T] (struct.field_ref paxosState "acceptedEpoch" (![ptrT] "ps"))) in
    marshal.WriteInt "$a0" "$a1") in
    do:  ("e" <-[sliceT byteT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT byteT] "e") in
    let: "$a1" := (![uint64T] (struct.field_ref paxosState "nextIndex" (![ptrT] "ps"))) in
    marshal.WriteInt "$a0" "$a1") in
    do:  ("e" <-[sliceT byteT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT byteT] "e") in
    let: "$a1" := (let: "$a0" := (![boolT] (struct.field_ref paxosState "isLeader" (![ptrT] "ps"))) in
    boolToU64 "$a0") in
    marshal.WriteInt "$a0" "$a1") in
    do:  ("e" <-[sliceT byteT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT byteT] "e") in
    let: "$a1" := (![sliceT byteT] (struct.field_ref paxosState "state" (![ptrT] "ps"))) in
    marshal.WriteBytes "$a0" "$a1") in
    do:  ("e" <-[sliceT byteT] "$r0");;;
    return: (![sliceT byteT] "e")).

(* go: marshal.go:138:6 *)
Definition decodePaxosState : val :=
  rec: "decodePaxosState" "enc" :=
    exception_do (let: "enc" := (ref_ty (sliceT byteT) "enc") in
    let: "e" := (ref_ty (sliceT byteT) (zero_val (sliceT byteT))) in
    let: "$r0" := (![sliceT byteT] "enc") in
    do:  ("e" <-[sliceT byteT] "$r0");;;
    let: "leaderInt" := (ref_ty uint64T (zero_val uint64T)) in
    let: "ps" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty paxosState (zero_val paxosState)) in
    do:  ("ps" <-[ptrT] "$r0");;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![sliceT byteT] "e") in
    marshal.ReadInt "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ((struct.field_ref paxosState "epoch" (![ptrT] "ps")) <-[uint64T] "$r0");;;
    do:  ("e" <-[sliceT byteT] "$r1");;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![sliceT byteT] "e") in
    marshal.ReadInt "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ((struct.field_ref paxosState "acceptedEpoch" (![ptrT] "ps")) <-[uint64T] "$r0");;;
    do:  ("e" <-[sliceT byteT] "$r1");;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![sliceT byteT] "e") in
    marshal.ReadInt "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ((struct.field_ref paxosState "nextIndex" (![ptrT] "ps")) <-[uint64T] "$r0");;;
    do:  ("e" <-[sliceT byteT] "$r1");;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![sliceT byteT] "e") in
    marshal.ReadInt "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("leaderInt" <-[uint64T] "$r0");;;
    do:  ((struct.field_ref paxosState "state" (![ptrT] "ps")) <-[sliceT byteT] "$r1");;;
    let: "$r0" := ((![uint64T] "leaderInt") = #(W64 1)) in
    do:  ((struct.field_ref paxosState "isLeader" (![ptrT] "ps")) <-[boolT] "$r0");;;
    return: (![ptrT] "ps")).

Definition paxosState__mset : list (string * val) := [
].

Definition paxosState__mset_ptr : list (string * val) := [
].

Definition Server : go_type := structT [
  "mu" :: ptrT;
  "ps" :: ptrT;
  "storage" :: ptrT;
  "clerks" :: sliceT ptrT
].

Definition Server__mset : list (string * val) := [
].

(* go: server.go:165:18 *)
Definition Server__TryAcquire : val :=
  rec: "Server__TryAcquire" "s" <> :=
    exception_do (let: "s" := (ref_ty ptrT "s") in
    let: "retErr" := (ref_ty Error (zero_val Error)) in
    do:  ((sync.Mutex__Lock (![ptrT] (struct.field_ref Server "mu" (![ptrT] "s")))) #());;;
    (if: (~ (![boolT] (struct.field_ref paxosState "isLeader" (![ptrT] (struct.field_ref Server "ps" (![ptrT] "s"))))))
    then
      do:  ((sync.Mutex__Unlock (![ptrT] (struct.field_ref Server "mu" (![ptrT] "s")))) #());;;
      let: "n" := (ref_ty ptrT (zero_val ptrT)) in
      return: (ENotLeader, ![ptrT] "n", #func.nil)
    else do:  #());;;
    let: "tryRelease" := (ref_ty funcT (zero_val funcT)) in
    let: "$r0" := (λ: <>,
      exception_do (let: "$r0" := (let: "$a0" := (![uint64T] (struct.field_ref paxosState "nextIndex" (![ptrT] (struct.field_ref Server "ps" (![ptrT] "s"))))) in
      let: "$a1" := #(W64 1) in
      std.SumAssumeNoOverflow "$a0" "$a1") in
      do:  ((struct.field_ref paxosState "nextIndex" (![ptrT] (struct.field_ref Server "ps" (![ptrT] "s")))) <-[uint64T] "$r0");;;
      let: "args" := (ref_ty ptrT (zero_val ptrT)) in
      let: "$r0" := (ref_ty applyAsFollowerArgs (struct.make applyAsFollowerArgs [{
        "epoch" ::= ![uint64T] (struct.field_ref paxosState "epoch" (![ptrT] (struct.field_ref Server "ps" (![ptrT] "s"))));
        "nextIndex" ::= ![uint64T] (struct.field_ref paxosState "nextIndex" (![ptrT] (struct.field_ref Server "ps" (![ptrT] "s"))));
        "state" ::= ![sliceT byteT] (struct.field_ref paxosState "state" (![ptrT] (struct.field_ref Server "ps" (![ptrT] "s"))))
      }])) in
      do:  ("args" <-[ptrT] "$r0");;;
      let: "waitFn" := (ref_ty funcT (zero_val funcT)) in
      let: "$r0" := (let: "$a0" := (let: "$a0" := (![ptrT] (struct.field_ref Server "ps" (![ptrT] "s"))) in
      encodePaxosState "$a0") in
      (asyncfile.AsyncFile__Write (![ptrT] (struct.field_ref Server "storage" (![ptrT] "s")))) "$a0") in
      do:  ("waitFn" <-[funcT] "$r0");;;
      do:  ((sync.Mutex__Unlock (![ptrT] (struct.field_ref Server "mu" (![ptrT] "s")))) #());;;
      do:  ((![funcT] "waitFn") #());;;
      let: "clerks" := (ref_ty (sliceT ptrT) (zero_val (sliceT ptrT))) in
      let: "$r0" := (![sliceT ptrT] (struct.field_ref Server "clerks" (![ptrT] "s"))) in
      do:  ("clerks" <-[sliceT ptrT] "$r0");;;
      let: "numReplies" := (ref_ty uint64T (zero_val uint64T)) in
      let: "$r0" := #(W64 0) in
      do:  ("numReplies" <-[uint64T] "$r0");;;
      let: "replies" := (ref_ty (sliceT ptrT) (zero_val (sliceT ptrT))) in
      let: "$r0" := (slice.make2 ptrT (let: "$a0" := (![sliceT ptrT] "clerks") in
      slice.len "$a0")) in
      do:  ("replies" <-[sliceT ptrT] "$r0");;;
      let: "mu" := (ref_ty ptrT (zero_val ptrT)) in
      let: "$r0" := (ref_ty sync.Mutex (zero_val sync.Mutex)) in
      do:  ("mu" <-[ptrT] "$r0");;;
      let: "numReplies_cond" := (ref_ty ptrT (zero_val ptrT)) in
      let: "$r0" := (let: "$a0" := (interface.make sync.Mutex__mset_ptr (![ptrT] "mu")) in
      sync.NewCond "$a0") in
      do:  ("numReplies_cond" <-[ptrT] "$r0");;;
      let: "n" := (ref_ty uint64T (zero_val uint64T)) in
      let: "$r0" := (let: "$a0" := (![sliceT ptrT] "clerks") in
      slice.len "$a0") in
      do:  ("n" <-[uint64T] "$r0");;;
      do:  (let: "$range" := (![sliceT ptrT] "clerks") in
      slice.for_range ptrT "$range" (λ: "i" "ck",
        let: "i" := ref_ty uint64T "i" in
        let: "ck" := ref_ty ptrT "ck" in
        let: "ck" := (ref_ty ptrT (zero_val ptrT)) in
        let: "$r0" := (![ptrT] "ck") in
        do:  ("ck" <-[ptrT] "$r0");;;
        let: "i" := (ref_ty intT (zero_val intT)) in
        let: "$r0" := (![intT] "i") in
        do:  ("i" <-[intT] "$r0");;;
        let: "$go" := (λ: <>,
          exception_do (let: "reply" := (ref_ty ptrT (zero_val ptrT)) in
          let: "$r0" := (let: "$a0" := (![ptrT] "args") in
          (singleClerk__applyAsFollower (![ptrT] "ck")) "$a0") in
          do:  ("reply" <-[ptrT] "$r0");;;
          do:  ((sync.Mutex__Lock (![ptrT] "mu")) #());;;
          do:  ("numReplies" <-[uint64T] ((![uint64T] "numReplies") + #(W64 1)));;;
          let: "$r0" := (![ptrT] "reply") in
          do:  ((slice.elem_ref ptrT (![sliceT ptrT] "replies") (![intT] "i")) <-[ptrT] "$r0");;;
          (if: (#(W64 2) * (![uint64T] "numReplies")) > (![uint64T] "n")
          then do:  ((sync.Cond__Signal (![ptrT] "numReplies_cond")) #())
          else do:  #());;;
          do:  ((sync.Mutex__Unlock (![ptrT] "mu")) #()))
          ) in
        do:  (Fork ("$go" #()))));;;
      do:  ((sync.Mutex__Lock (![ptrT] "mu")) #());;;
      (for: (λ: <>, (#(W64 2) * (![uint64T] "numReplies")) ≤ (![uint64T] "n")); (λ: <>, Skip) := λ: <>,
        do:  ((sync.Cond__Wait (![ptrT] "numReplies_cond")) #()));;;
      let: "numSuccesses" := (ref_ty uint64T (zero_val uint64T)) in
      let: "$r0" := #(W64 0) in
      do:  ("numSuccesses" <-[uint64T] "$r0");;;
      do:  (let: "$range" := (![sliceT ptrT] "replies") in
      slice.for_range ptrT "$range" (λ: <> "reply",
        let: "reply" := ref_ty ptrT "reply" in
        (if: (![ptrT] "reply") ≠ #null
        then
          (if: (![Error] (struct.field_ref applyAsFollowerReply "err" (![ptrT] "reply"))) = ENone
          then do:  ("numSuccesses" <-[uint64T] ((![uint64T] "numSuccesses") + #(W64 1)))
          else do:  #())
        else do:  #())));;;
      (if: (#(W64 2) * (![uint64T] "numSuccesses")) > (![uint64T] "n")
      then
        let: "$r0" := ENone in
        do:  ("retErr" <-[Error] "$r0")
      else
        let: "$r0" := EEpochStale in
        do:  ("retErr" <-[Error] "$r0"));;;
      return: (![Error] "retErr"))
      ) in
    do:  ("tryRelease" <-[funcT] "$r0");;;
    return: (ENone, struct.field_ref paxosState "state" (![ptrT] (struct.field_ref Server "ps" (![ptrT] "s"))), ![funcT] "tryRelease")).

(* go: server.go:28:18 *)
Definition Server__withLock : val :=
  rec: "Server__withLock" "s" "f" :=
    exception_do (let: "s" := (ref_ty ptrT "s") in
    let: "f" := (ref_ty funcT "f") in
    do:  ((sync.Mutex__Lock (![ptrT] (struct.field_ref Server "mu" (![ptrT] "s")))) #());;;
    do:  (let: "$a0" := (![ptrT] (struct.field_ref Server "ps" (![ptrT] "s"))) in
    (![funcT] "f") "$a0");;;
    let: "waitFn" := (ref_ty funcT (zero_val funcT)) in
    let: "$r0" := (let: "$a0" := (let: "$a0" := (![ptrT] (struct.field_ref Server "ps" (![ptrT] "s"))) in
    encodePaxosState "$a0") in
    (asyncfile.AsyncFile__Write (![ptrT] (struct.field_ref Server "storage" (![ptrT] "s")))) "$a0") in
    do:  ("waitFn" <-[funcT] "$r0");;;
    do:  ((sync.Mutex__Unlock (![ptrT] (struct.field_ref Server "mu" (![ptrT] "s")))) #());;;
    do:  ((![funcT] "waitFn") #())).

(* go: server.go:83:18 *)
Definition Server__TryBecomeLeader : val :=
  rec: "Server__TryBecomeLeader" "s" <> :=
    exception_do (let: "s" := (ref_ty ptrT "s") in
    do:  (let: "$a0" := ((let: "$sl0" := (interface.make string__mset #"started trybecomeleader") in
    slice.literal interfaceT ["$sl0"])) in
    log.Println "$a0");;;
    do:  ((sync.Mutex__Lock (![ptrT] (struct.field_ref Server "mu" (![ptrT] "s")))) #());;;
    (if: ![boolT] (struct.field_ref paxosState "isLeader" (![ptrT] (struct.field_ref Server "ps" (![ptrT] "s"))))
    then
      do:  (let: "$a0" := ((let: "$sl0" := (interface.make string__mset #"already leader") in
      slice.literal interfaceT ["$sl0"])) in
      log.Println "$a0");;;
      do:  ((sync.Mutex__Unlock (![ptrT] (struct.field_ref Server "mu" (![ptrT] "s")))) #());;;
      return: (#())
    else do:  #());;;
    let: "clerks" := (ref_ty (sliceT ptrT) (zero_val (sliceT ptrT))) in
    let: "$r0" := (![sliceT ptrT] (struct.field_ref Server "clerks" (![ptrT] "s"))) in
    do:  ("clerks" <-[sliceT ptrT] "$r0");;;
    let: "args" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty enterNewEpochArgs (struct.make enterNewEpochArgs [{
      "epoch" ::= (![uint64T] (struct.field_ref paxosState "epoch" (![ptrT] (struct.field_ref Server "ps" (![ptrT] "s"))))) + #(W64 1)
    }])) in
    do:  ("args" <-[ptrT] "$r0");;;
    do:  ((sync.Mutex__Unlock (![ptrT] (struct.field_ref Server "mu" (![ptrT] "s")))) #());;;
    let: "numReplies" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("numReplies" <-[uint64T] "$r0");;;
    let: "replies" := (ref_ty (sliceT ptrT) (zero_val (sliceT ptrT))) in
    let: "$r0" := (slice.make2 ptrT (let: "$a0" := (![sliceT ptrT] "clerks") in
    slice.len "$a0")) in
    do:  ("replies" <-[sliceT ptrT] "$r0");;;
    let: "mu" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty sync.Mutex (zero_val sync.Mutex)) in
    do:  ("mu" <-[ptrT] "$r0");;;
    let: "numReplies_cond" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (let: "$a0" := (interface.make sync.Mutex__mset_ptr (![ptrT] "mu")) in
    sync.NewCond "$a0") in
    do:  ("numReplies_cond" <-[ptrT] "$r0");;;
    let: "n" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (let: "$a0" := (![sliceT ptrT] "clerks") in
    slice.len "$a0") in
    do:  ("n" <-[uint64T] "$r0");;;
    do:  (let: "$range" := (![sliceT ptrT] "clerks") in
    slice.for_range ptrT "$range" (λ: "i" "ck",
      let: "i" := ref_ty uint64T "i" in
      let: "ck" := ref_ty ptrT "ck" in
      let: "$go" := (λ: <>,
        exception_do (let: "reply" := (ref_ty ptrT (zero_val ptrT)) in
        let: "$r0" := (let: "$a0" := (![ptrT] "args") in
        (singleClerk__enterNewEpoch (![ptrT] "ck")) "$a0") in
        do:  ("reply" <-[ptrT] "$r0");;;
        do:  ((sync.Mutex__Lock (![ptrT] "mu")) #());;;
        do:  ("numReplies" <-[uint64T] ((![uint64T] "numReplies") + #(W64 1)));;;
        let: "$r0" := (![ptrT] "reply") in
        do:  ((slice.elem_ref ptrT (![sliceT ptrT] "replies") (![intT] "i")) <-[ptrT] "$r0");;;
        (if: (#(W64 2) * (![uint64T] "numReplies")) > (![uint64T] "n")
        then do:  ((sync.Cond__Signal (![ptrT] "numReplies_cond")) #())
        else do:  #());;;
        do:  ((sync.Mutex__Unlock (![ptrT] "mu")) #()))
        ) in
      do:  (Fork ("$go" #()))));;;
    do:  ((sync.Mutex__Lock (![ptrT] "mu")) #());;;
    (for: (λ: <>, (#(W64 2) * (![uint64T] "numReplies")) ≤ (![uint64T] "n")); (λ: <>, Skip) := λ: <>,
      do:  ((sync.Cond__Wait (![ptrT] "numReplies_cond")) #()));;;
    let: "latestReply" := (ref_ty ptrT (zero_val ptrT)) in
    let: "numSuccesses" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("numSuccesses" <-[uint64T] "$r0");;;
    do:  (let: "$range" := (![sliceT ptrT] "replies") in
    slice.for_range ptrT "$range" (λ: <> "reply",
      let: "reply" := ref_ty ptrT "reply" in
      (if: (![ptrT] "reply") ≠ #null
      then
        (if: (![Error] (struct.field_ref enterNewEpochReply "err" (![ptrT] "reply"))) = ENone
        then
          (if: (![uint64T] "numSuccesses") = #(W64 0)
          then
            let: "$r0" := (![ptrT] "reply") in
            do:  ("latestReply" <-[ptrT] "$r0")
          else
            (if: (![uint64T] (struct.field_ref enterNewEpochReply "acceptedEpoch" (![ptrT] "latestReply"))) < (![uint64T] (struct.field_ref enterNewEpochReply "acceptedEpoch" (![ptrT] "reply")))
            then
              let: "$r0" := (![ptrT] "reply") in
              do:  ("latestReply" <-[ptrT] "$r0")
            else
              (if: ((![uint64T] (struct.field_ref enterNewEpochReply "acceptedEpoch" (![ptrT] "latestReply"))) = (![uint64T] (struct.field_ref enterNewEpochReply "acceptedEpoch" (![ptrT] "reply")))) && ((![uint64T] (struct.field_ref enterNewEpochReply "nextIndex" (![ptrT] "reply"))) > (![uint64T] (struct.field_ref enterNewEpochReply "nextIndex" (![ptrT] "latestReply"))))
              then
                let: "$r0" := (![ptrT] "reply") in
                do:  ("latestReply" <-[ptrT] "$r0")
              else do:  #())));;;
          do:  ("numSuccesses" <-[uint64T] ((![uint64T] "numSuccesses") + #(W64 1)))
        else do:  #())
      else do:  #())));;;
    (if: (#(W64 2) * (![uint64T] "numSuccesses")) > (![uint64T] "n")
    then
      do:  (let: "$a0" := (λ: "ps",
        exception_do (let: "ps" := (ref_ty ptrT "ps") in
        (if: (![uint64T] (struct.field_ref paxosState "epoch" (![ptrT] "ps"))) ≤ (![uint64T] (struct.field_ref enterNewEpochArgs "epoch" (![ptrT] "args")))
        then
          do:  (let: "$a0" := #"succeeded becomeleader in epoch %d
          " in
          let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref enterNewEpochArgs "epoch" (![ptrT] "args")))) in
          slice.literal interfaceT ["$sl0"])) in
          log.Printf "$a0" "$a1");;;
          let: "$r0" := (![uint64T] (struct.field_ref enterNewEpochArgs "epoch" (![ptrT] "args"))) in
          do:  ((struct.field_ref paxosState "epoch" (![ptrT] "ps")) <-[uint64T] "$r0");;;
          let: "$r0" := #true in
          do:  ((struct.field_ref paxosState "isLeader" (![ptrT] "ps")) <-[boolT] "$r0");;;
          let: "$r0" := (![uint64T] (struct.field_ref paxosState "epoch" (![ptrT] "ps"))) in
          do:  ((struct.field_ref paxosState "acceptedEpoch" (![ptrT] "ps")) <-[uint64T] "$r0");;;
          let: "$r0" := (![uint64T] (struct.field_ref enterNewEpochReply "nextIndex" (![ptrT] "latestReply"))) in
          do:  ((struct.field_ref paxosState "nextIndex" (![ptrT] "ps")) <-[uint64T] "$r0");;;
          let: "$r0" := (![sliceT byteT] (struct.field_ref enterNewEpochReply "state" (![ptrT] "latestReply"))) in
          do:  ((struct.field_ref paxosState "state" (![ptrT] "ps")) <-[sliceT byteT] "$r0")
        else do:  #()))
        ) in
      (Server__withLock (![ptrT] "s")) "$a0");;;
      do:  ((sync.Mutex__Unlock (![ptrT] "mu")) #())
    else
      do:  ((sync.Mutex__Unlock (![ptrT] "mu")) #());;;
      do:  (let: "$a0" := ((let: "$sl0" := (interface.make string__mset #"failed becomeleader") in
      slice.literal interfaceT ["$sl0"])) in
      log.Println "$a0"))).

(* go: server.go:235:18 *)
Definition Server__WeakRead : val :=
  rec: "Server__WeakRead" "s" <> :=
    exception_do (let: "s" := (ref_ty ptrT "s") in
    do:  ((sync.Mutex__Lock (![ptrT] (struct.field_ref Server "mu" (![ptrT] "s")))) #());;;
    let: "ret" := (ref_ty (sliceT byteT) (zero_val (sliceT byteT))) in
    let: "$r0" := (![sliceT byteT] (struct.field_ref paxosState "state" (![ptrT] (struct.field_ref Server "ps" (![ptrT] "s"))))) in
    do:  ("ret" <-[sliceT byteT] "$r0");;;
    do:  ((sync.Mutex__Unlock (![ptrT] (struct.field_ref Server "mu" (![ptrT] "s")))) #());;;
    return: (![sliceT byteT] "ret")).

(* go: server.go:36:18 *)
Definition Server__applyAsFollower : val :=
  rec: "Server__applyAsFollower" "s" "args" "reply" :=
    exception_do (let: "s" := (ref_ty ptrT "s") in
    let: "reply" := (ref_ty ptrT "reply") in
    let: "args" := (ref_ty ptrT "args") in
    do:  (let: "$a0" := (λ: "ps",
      exception_do (let: "ps" := (ref_ty ptrT "ps") in
      (if: (![uint64T] (struct.field_ref paxosState "epoch" (![ptrT] "ps"))) ≤ (![uint64T] (struct.field_ref applyAsFollowerArgs "epoch" (![ptrT] "args")))
      then
        (if: (![uint64T] (struct.field_ref paxosState "acceptedEpoch" (![ptrT] "ps"))) = (![uint64T] (struct.field_ref applyAsFollowerArgs "epoch" (![ptrT] "args")))
        then
          (if: (![uint64T] (struct.field_ref paxosState "nextIndex" (![ptrT] "ps"))) < (![uint64T] (struct.field_ref applyAsFollowerArgs "nextIndex" (![ptrT] "args")))
          then
            let: "$r0" := (![uint64T] (struct.field_ref applyAsFollowerArgs "nextIndex" (![ptrT] "args"))) in
            do:  ((struct.field_ref paxosState "nextIndex" (![ptrT] "ps")) <-[uint64T] "$r0");;;
            let: "$r0" := (![sliceT byteT] (struct.field_ref applyAsFollowerArgs "state" (![ptrT] "args"))) in
            do:  ((struct.field_ref paxosState "state" (![ptrT] "ps")) <-[sliceT byteT] "$r0");;;
            let: "$r0" := ENone in
            do:  ((struct.field_ref applyAsFollowerReply "err" (![ptrT] "reply")) <-[Error] "$r0")
          else
            let: "$r0" := ENone in
            do:  ((struct.field_ref applyAsFollowerReply "err" (![ptrT] "reply")) <-[Error] "$r0"))
        else
          let: "$r0" := (![uint64T] (struct.field_ref applyAsFollowerArgs "epoch" (![ptrT] "args"))) in
          do:  ((struct.field_ref paxosState "acceptedEpoch" (![ptrT] "ps")) <-[uint64T] "$r0");;;
          let: "$r0" := (![uint64T] (struct.field_ref applyAsFollowerArgs "epoch" (![ptrT] "args"))) in
          do:  ((struct.field_ref paxosState "epoch" (![ptrT] "ps")) <-[uint64T] "$r0");;;
          let: "$r0" := (![sliceT byteT] (struct.field_ref applyAsFollowerArgs "state" (![ptrT] "args"))) in
          do:  ((struct.field_ref paxosState "state" (![ptrT] "ps")) <-[sliceT byteT] "$r0");;;
          let: "$r0" := (![uint64T] (struct.field_ref applyAsFollowerArgs "nextIndex" (![ptrT] "args"))) in
          do:  ((struct.field_ref paxosState "nextIndex" (![ptrT] "ps")) <-[uint64T] "$r0");;;
          let: "$r0" := #false in
          do:  ((struct.field_ref paxosState "isLeader" (![ptrT] "ps")) <-[boolT] "$r0");;;
          let: "$r0" := ENone in
          do:  ((struct.field_ref applyAsFollowerReply "err" (![ptrT] "reply")) <-[Error] "$r0"))
      else
        let: "$r0" := EEpochStale in
        do:  ((struct.field_ref applyAsFollowerReply "err" (![ptrT] "reply")) <-[Error] "$r0")))
      ) in
    (Server__withLock (![ptrT] "s")) "$a0")).

(* NOTE:
   This will vote yes only the first time it's called in an epoch.
   If you have too aggressive of a timeout and end up retrying this, the retry
   might fail because it may be the second execution of enterNewEpoch(epoch) on
   the server.
   Solution: either conservative (maybe double) timeouts, or don't use this for
   leader election, only for coming up with a valid proposal.

   go: server.go:68:18 *)
Definition Server__enterNewEpoch : val :=
  rec: "Server__enterNewEpoch" "s" "args" "reply" :=
    exception_do (let: "s" := (ref_ty ptrT "s") in
    let: "reply" := (ref_ty ptrT "reply") in
    let: "args" := (ref_ty ptrT "args") in
    do:  (let: "$a0" := (λ: "ps",
      exception_do (let: "ps" := (ref_ty ptrT "ps") in
      (if: (![uint64T] (struct.field_ref paxosState "epoch" (![ptrT] "ps"))) ≥ (![uint64T] (struct.field_ref enterNewEpochArgs "epoch" (![ptrT] "args")))
      then
        let: "$r0" := EEpochStale in
        do:  ((struct.field_ref enterNewEpochReply "err" (![ptrT] "reply")) <-[Error] "$r0");;;
        return: (#())
      else do:  #());;;
      let: "$r0" := #false in
      do:  ((struct.field_ref paxosState "isLeader" (![ptrT] "ps")) <-[boolT] "$r0");;;
      let: "$r0" := (![uint64T] (struct.field_ref enterNewEpochArgs "epoch" (![ptrT] "args"))) in
      do:  ((struct.field_ref paxosState "epoch" (![ptrT] "ps")) <-[uint64T] "$r0");;;
      let: "$r0" := (![uint64T] (struct.field_ref paxosState "acceptedEpoch" (![ptrT] "ps"))) in
      do:  ((struct.field_ref enterNewEpochReply "acceptedEpoch" (![ptrT] "reply")) <-[uint64T] "$r0");;;
      let: "$r0" := (![uint64T] (struct.field_ref paxosState "nextIndex" (![ptrT] "ps"))) in
      do:  ((struct.field_ref enterNewEpochReply "nextIndex" (![ptrT] "reply")) <-[uint64T] "$r0");;;
      let: "$r0" := (![sliceT byteT] (struct.field_ref paxosState "state" (![ptrT] "ps"))) in
      do:  ((struct.field_ref enterNewEpochReply "state" (![ptrT] "reply")) <-[sliceT byteT] "$r0"))
      ) in
    (Server__withLock (![ptrT] "s")) "$a0")).

Definition Server__mset_ptr : list (string * val) := [
  ("TryAcquire", Server__TryAcquire%V);
  ("TryBecomeLeader", Server__TryBecomeLeader%V);
  ("WeakRead", Server__WeakRead%V);
  ("applyAsFollower", Server__applyAsFollower%V);
  ("enterNewEpoch", Server__enterNewEpoch%V);
  ("withLock", Server__withLock%V)
].

(* go: server.go:242:6 *)
Definition makeServer : val :=
  rec: "makeServer" "fname" "initstate" "config" :=
    exception_do (let: "config" := (ref_ty (sliceT uint64T) "config") in
    let: "initstate" := (ref_ty (sliceT byteT) "initstate") in
    let: "fname" := (ref_ty stringT "fname") in
    let: "s" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty Server (zero_val Server)) in
    do:  ("s" <-[ptrT] "$r0");;;
    let: "$r0" := (ref_ty sync.Mutex (zero_val sync.Mutex)) in
    do:  ((struct.field_ref Server "mu" (![ptrT] "s")) <-[ptrT] "$r0");;;
    let: "$r0" := (slice.make2 ptrT #(W64 0)) in
    do:  ((struct.field_ref Server "clerks" (![ptrT] "s")) <-[sliceT ptrT] "$r0");;;
    do:  (let: "$range" := (![sliceT uint64T] "config") in
    slice.for_range uint64T "$range" (λ: <> "host",
      let: "host" := ref_ty uint64T "host" in
      let: "$r0" := (let: "$a0" := (![sliceT ptrT] (struct.field_ref Server "clerks" (![ptrT] "s"))) in
      let: "$a1" := ((let: "$sl0" := (let: "$a0" := (![uint64T] "host") in
      MakeSingleClerk "$a0") in
      slice.literal ptrT ["$sl0"])) in
      (slice.append (sliceT ptrT)) "$a0" "$a1") in
      do:  ((struct.field_ref Server "clerks" (![ptrT] "s")) <-[sliceT ptrT] "$r0")));;;
    let: "encstate" := (ref_ty (sliceT byteT) (zero_val (sliceT byteT))) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![stringT] "fname") in
    asyncfile.MakeAsyncFile "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("encstate" <-[sliceT byteT] "$r0");;;
    do:  ((struct.field_ref Server "storage" (![ptrT] "s")) <-[ptrT] "$r1");;;
    (if: (let: "$a0" := (![sliceT byteT] "encstate") in
    slice.len "$a0") = #(W64 0)
    then
      let: "$r0" := (ref_ty paxosState (zero_val paxosState)) in
      do:  ((struct.field_ref Server "ps" (![ptrT] "s")) <-[ptrT] "$r0");;;
      let: "$r0" := (![sliceT byteT] "initstate") in
      do:  ((struct.field_ref paxosState "state" (![ptrT] (struct.field_ref Server "ps" (![ptrT] "s")))) <-[sliceT byteT] "$r0")
    else
      let: "$r0" := (let: "$a0" := (![sliceT byteT] "encstate") in
      decodePaxosState "$a0") in
      do:  ((struct.field_ref Server "ps" (![ptrT] "s")) <-[ptrT] "$r0"));;;
    return: (![ptrT] "s")).

(* go: server.go:262:6 *)
Definition StartServer : val :=
  rec: "StartServer" "fname" "initstate" "me" "config" :=
    exception_do (let: "config" := (ref_ty (sliceT uint64T) "config") in
    let: "me" := (ref_ty uint64T "me") in
    let: "initstate" := (ref_ty (sliceT byteT) "initstate") in
    let: "fname" := (ref_ty stringT "fname") in
    let: "s" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (let: "$a0" := (![stringT] "fname") in
    let: "$a1" := (![sliceT byteT] "initstate") in
    let: "$a2" := (![sliceT uint64T] "config") in
    makeServer "$a0" "$a1" "$a2") in
    do:  ("s" <-[ptrT] "$r0");;;
    let: "handlers" := (ref_ty (mapT uint64T funcT) (zero_val (mapT uint64T funcT))) in
    let: "$r0" := (map.make uint64T funcT #()) in
    do:  ("handlers" <-[mapT uint64T funcT] "$r0");;;
    let: "$r0" := (λ: "raw_args" "raw_reply",
      exception_do (let: "raw_reply" := (ref_ty ptrT "raw_reply") in
      let: "raw_args" := (ref_ty (sliceT byteT) "raw_args") in
      let: "reply" := (ref_ty ptrT (zero_val ptrT)) in
      let: "$r0" := (ref_ty applyAsFollowerReply (zero_val applyAsFollowerReply)) in
      do:  ("reply" <-[ptrT] "$r0");;;
      let: "args" := (ref_ty ptrT (zero_val ptrT)) in
      let: "$r0" := (let: "$a0" := (![sliceT byteT] "raw_args") in
      decodeApplyAsFollowerArgs "$a0") in
      do:  ("args" <-[ptrT] "$r0");;;
      do:  (let: "$a0" := (![ptrT] "args") in
      let: "$a1" := (![ptrT] "reply") in
      (Server__applyAsFollower (![ptrT] "s")) "$a0" "$a1");;;
      let: "$r0" := (let: "$a0" := (![ptrT] "reply") in
      encodeApplyAsFollowerReply "$a0") in
      do:  ((![ptrT] "raw_reply") <-[sliceT byteT] "$r0"))
      ) in
    do:  (map.insert (![mapT uint64T funcT] "handlers") RPC_APPLY_AS_FOLLOWER "$r0");;;
    let: "$r0" := (λ: "raw_args" "raw_reply",
      exception_do (let: "raw_reply" := (ref_ty ptrT "raw_reply") in
      let: "raw_args" := (ref_ty (sliceT byteT) "raw_args") in
      let: "reply" := (ref_ty ptrT (zero_val ptrT)) in
      let: "$r0" := (ref_ty enterNewEpochReply (zero_val enterNewEpochReply)) in
      do:  ("reply" <-[ptrT] "$r0");;;
      let: "args" := (ref_ty ptrT (zero_val ptrT)) in
      let: "$r0" := (let: "$a0" := (![sliceT byteT] "raw_args") in
      decodeEnterNewEpochArgs "$a0") in
      do:  ("args" <-[ptrT] "$r0");;;
      do:  (let: "$a0" := (![ptrT] "args") in
      let: "$a1" := (![ptrT] "reply") in
      (Server__enterNewEpoch (![ptrT] "s")) "$a0" "$a1");;;
      let: "$r0" := (let: "$a0" := (![ptrT] "reply") in
      encodeEnterNewEpochReply "$a0") in
      do:  ((![ptrT] "raw_reply") <-[sliceT byteT] "$r0"))
      ) in
    do:  (map.insert (![mapT uint64T funcT] "handlers") RPC_ENTER_NEW_EPOCH "$r0");;;
    let: "$r0" := (λ: "raw_args" "raw_reply",
      exception_do (let: "raw_reply" := (ref_ty ptrT "raw_reply") in
      let: "raw_args" := (ref_ty (sliceT byteT) "raw_args") in
      do:  ((Server__TryBecomeLeader (![ptrT] "s")) #()))
      ) in
    do:  (map.insert (![mapT uint64T funcT] "handlers") RPC_BECOME_LEADER "$r0");;;
    let: "r" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (let: "$a0" := (![mapT uint64T funcT] "handlers") in
    urpc.MakeServer "$a0") in
    do:  ("r" <-[ptrT] "$r0");;;
    do:  (let: "$a0" := (![uint64T] "me") in
    (urpc.Server__Serve (![ptrT] "r")) "$a0");;;
    return: (![ptrT] "s")).
