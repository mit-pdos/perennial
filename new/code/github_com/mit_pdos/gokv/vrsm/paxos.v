(* autogenerated from github.com/mit-pdos/gokv/vrsm/paxos *)
Require Export New.code.github_com.mit_pdos.gokv.grove_ffi.
Require Export New.code.github_com.mit_pdos.gokv.reconnectclient.
Require Export New.code.github_com.mit_pdos.gokv.vrsm.paxos.applyasfollowerargs_gk.
Require Export New.code.github_com.mit_pdos.gokv.vrsm.paxos.applyasfollowerreply_gk.
Require Export New.code.github_com.mit_pdos.gokv.vrsm.paxos.enternewepochargs_gk.
Require Export New.code.github_com.mit_pdos.gokv.vrsm.paxos.enternewepochreply_gk.
Require Export New.code.github_com.mit_pdos.gokv.vrsm.paxos.error_gk.
Require Export New.code.log.
Require Export New.code.sync.
Require Export New.code.github_com.goose_lang.std.
Require Export New.code.github_com.mit_pdos.gokv.asyncfile.
Require Export New.code.github_com.mit_pdos.gokv.urpc.
Require Export New.code.github_com.mit_pdos.gokv.vrsm.paxos.paxosstate_gk.
From New.golang Require Import defn.
From New Require Import grove_prelude.
Module pkg_id.
Definition paxos : go_string := "github.com/mit-pdos/gokv/vrsm/paxos".

End pkg_id.
Export pkg_id.
Module paxos.

Definition singleClerk {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/mit-pdos/gokv/vrsm/paxos.singleClerk"%go [].

Definition Server {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/mit-pdos/gokv/vrsm/paxos.Server"%go [].

Definition RPC_APPLY_AS_FOLLOWER {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 0).

Definition RPC_ENTER_NEW_EPOCH {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 1).

Definition RPC_BECOME_LEADER {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 2).

Definition MakeSingleClerk {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/gokv/vrsm/paxos.MakeSingleClerk"%go.

Definition makeServer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/gokv/vrsm/paxos.makeServer"%go.

Definition StartServer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/gokv/vrsm/paxos.StartServer"%go.

(* go: internalclerk.go:24:6 *)
Definition MakeSingleClerkⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "addr",
    exception_do (let: "addr" := (GoAlloc grove_ffi.Address "addr") in
    let: "ck" := (GoAlloc (go.PointerType singleClerk) (GoZeroVal (go.PointerType singleClerk) #())) in
    let: "$r0" := (GoAlloc singleClerk (CompositeLiteral singleClerk (LiteralValue [KeyedElement (Some (KeyField "cl"%go)) (ElementExpression (go.PointerType reconnectclient.ReconnectingClient) (let: "$a0" := (![grove_ffi.Address] "addr") in
     (FuncResolve reconnectclient.MakeReconnectingClient [] #()) "$a0"))]))) in
    do:  ("ck" <-[go.PointerType singleClerk] "$r0");;;
    return: (![go.PointerType singleClerk] "ck")).

(* go: internalclerk.go:33:23 *)
Definition singleClerk__enterNewEpochⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" "args",
    exception_do (let: "s" := (GoAlloc (go.PointerType singleClerk) "s") in
    let: "args" := (GoAlloc (go.PointerType enternewepochargs_gk.S) "args") in
    let: "raw_args" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (let: "$a0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 0)) in
    let: "$a1" := (![enternewepochargs_gk.S] (![go.PointerType enternewepochargs_gk.S] "args")) in
    (FuncResolve enternewepochargs_gk.Marshal [] #()) "$a0" "$a1") in
    do:  ("raw_args" <-[go.SliceType go.byte] "$r0");;;
    let: "raw_reply" := (GoAlloc (go.PointerType (go.SliceType go.byte)) (GoZeroVal (go.PointerType (go.SliceType go.byte)) #())) in
    let: "$r0" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    do:  ("raw_reply" <-[go.PointerType (go.SliceType go.byte)] "$r0");;;
    let: "err" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (let: "$a0" := RPC_ENTER_NEW_EPOCH in
    let: "$a1" := (![go.SliceType go.byte] "raw_args") in
    let: "$a2" := (![go.PointerType (go.SliceType go.byte)] "raw_reply") in
    let: "$a3" := #(W64 500) in
    (MethodResolve (go.PointerType reconnectclient.ReconnectingClient) "Call"%go (![go.PointerType reconnectclient.ReconnectingClient] (StructFieldRef singleClerk "cl"%go (![go.PointerType singleClerk] "s")))) "$a0" "$a1" "$a2" "$a3") in
    do:  ("err" <-[go.uint64] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "err") =⟨go.uint64⟩ #(W64 0))
    then
      let: "ret" := (GoAlloc enternewepochreply_gk.S (GoZeroVal enternewepochreply_gk.S #())) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] (![go.PointerType (go.SliceType go.byte)] "raw_reply")) in
      (FuncResolve enternewepochreply_gk.Unmarshal [] #()) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("ret" <-[enternewepochreply_gk.S] "$r0");;;
      do:  "$r1";;;
      return: ("ret")
    else return: (GoAlloc enternewepochreply_gk.S (CompositeLiteral enternewepochreply_gk.S (LiteralValue [KeyedElement (Some (KeyField "Err"%go)) (ElementExpression error_gk.E error_gk.ETimeout)]))))).

(* go: internalclerk.go:45:23 *)
Definition singleClerk__applyAsFollowerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" "args",
    exception_do (let: "s" := (GoAlloc (go.PointerType singleClerk) "s") in
    let: "args" := (GoAlloc (go.PointerType applyasfollowerargs_gk.S) "args") in
    let: "raw_args" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (let: "$a0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 0)) in
    let: "$a1" := (![applyasfollowerargs_gk.S] (![go.PointerType applyasfollowerargs_gk.S] "args")) in
    (FuncResolve applyasfollowerargs_gk.Marshal [] #()) "$a0" "$a1") in
    do:  ("raw_args" <-[go.SliceType go.byte] "$r0");;;
    let: "raw_reply" := (GoAlloc (go.PointerType (go.SliceType go.byte)) (GoZeroVal (go.PointerType (go.SliceType go.byte)) #())) in
    let: "$r0" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    do:  ("raw_reply" <-[go.PointerType (go.SliceType go.byte)] "$r0");;;
    let: "err" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (let: "$a0" := RPC_APPLY_AS_FOLLOWER in
    let: "$a1" := (![go.SliceType go.byte] "raw_args") in
    let: "$a2" := (![go.PointerType (go.SliceType go.byte)] "raw_reply") in
    let: "$a3" := #(W64 500) in
    (MethodResolve (go.PointerType reconnectclient.ReconnectingClient) "Call"%go (![go.PointerType reconnectclient.ReconnectingClient] (StructFieldRef singleClerk "cl"%go (![go.PointerType singleClerk] "s")))) "$a0" "$a1" "$a2" "$a3") in
    do:  ("err" <-[go.uint64] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "err") =⟨go.uint64⟩ #(W64 0))
    then
      let: "ret" := (GoAlloc applyasfollowerreply_gk.S (GoZeroVal applyasfollowerreply_gk.S #())) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] (![go.PointerType (go.SliceType go.byte)] "raw_reply")) in
      (FuncResolve applyasfollowerreply_gk.Unmarshal [] #()) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("ret" <-[applyasfollowerreply_gk.S] "$r0");;;
      do:  "$r1";;;
      return: ("ret")
    else return: (GoAlloc applyasfollowerreply_gk.S (CompositeLiteral applyasfollowerreply_gk.S (LiteralValue [KeyedElement (Some (KeyField "Err"%go)) (ElementExpression error_gk.E error_gk.ETimeout)]))))).

(* go: internalclerk.go:57:23 *)
Definition singleClerk__TryBecomeLeaderⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" <>,
    exception_do (let: "s" := (GoAlloc (go.PointerType singleClerk) "s") in
    let: "reply" := (GoAlloc (go.PointerType (go.SliceType go.byte)) (GoZeroVal (go.PointerType (go.SliceType go.byte)) #())) in
    let: "$r0" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    do:  ("reply" <-[go.PointerType (go.SliceType go.byte)] "$r0");;;
    do:  (let: "$a0" := RPC_BECOME_LEADER in
    let: "$a1" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 0)) in
    let: "$a2" := (![go.PointerType (go.SliceType go.byte)] "reply") in
    let: "$a3" := #(W64 500) in
    (MethodResolve (go.PointerType reconnectclient.ReconnectingClient) "Call"%go (![go.PointerType reconnectclient.ReconnectingClient] (StructFieldRef singleClerk "cl"%go (![go.PointerType singleClerk] "s")))) "$a0" "$a1" "$a2" "$a3");;;
    return: #()).

(* go: server.go:26:18 *)
Definition Server__withLockⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" "f",
    exception_do (let: "s" := (GoAlloc (go.PointerType Server) "s") in
    let: "f" := (GoAlloc (go.FunctionType (go.Signature [go.PointerType paxosstate_gk.S] false [])) "f") in
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] (StructFieldRef Server "mu"%go (![go.PointerType Server] "s")))) #());;;
    do:  (let: "$a0" := (![go.PointerType paxosstate_gk.S] (StructFieldRef Server "ps"%go (![go.PointerType Server] "s"))) in
    (![go.FunctionType (go.Signature [go.PointerType paxosstate_gk.S] false [])] "f") "$a0");;;
    let: "waitFn" := (GoAlloc (go.FunctionType (go.Signature [] false [])) (GoZeroVal (go.FunctionType (go.Signature [] false [])) #())) in
    let: "$r0" := (let: "$a0" := (let: "$a0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 0)) in
    let: "$a1" := (![paxosstate_gk.S] (![go.PointerType paxosstate_gk.S] (StructFieldRef Server "ps"%go (![go.PointerType Server] "s")))) in
    (FuncResolve paxosstate_gk.Marshal [] #()) "$a0" "$a1") in
    (MethodResolve (go.PointerType asyncfile.AsyncFile) "Write"%go (![go.PointerType asyncfile.AsyncFile] (StructFieldRef Server "storage"%go (![go.PointerType Server] "s")))) "$a0") in
    do:  ("waitFn" <-[go.FunctionType (go.Signature [] false [])] "$r0");;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef Server "mu"%go (![go.PointerType Server] "s")))) #());;;
    do:  ((![go.FunctionType (go.Signature [] false [])] "waitFn") #());;;
    return: #()).

(* go: server.go:34:18 *)
Definition Server__applyAsFollowerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" "args" "reply",
    exception_do (let: "s" := (GoAlloc (go.PointerType Server) "s") in
    let: "reply" := (GoAlloc (go.PointerType applyasfollowerreply_gk.S) "reply") in
    let: "args" := (GoAlloc (go.PointerType applyasfollowerargs_gk.S) "args") in
    do:  (let: "$a0" := (λ: "ps",
      exception_do (let: "ps" := (GoAlloc (go.PointerType paxosstate_gk.S) "ps") in
      (if: Convert go.untyped_bool go.bool ((![go.uint64] (StructFieldRef paxosstate_gk.S "Epoch"%go (![go.PointerType paxosstate_gk.S] "ps"))) ≤⟨go.uint64⟩ (![go.uint64] (StructFieldRef applyasfollowerargs_gk.S "Epoch"%go (![go.PointerType applyasfollowerargs_gk.S] "args"))))
      then
        (if: Convert go.untyped_bool go.bool ((![go.uint64] (StructFieldRef paxosstate_gk.S "AcceptedEpoch"%go (![go.PointerType paxosstate_gk.S] "ps"))) =⟨go.uint64⟩ (![go.uint64] (StructFieldRef applyasfollowerargs_gk.S "Epoch"%go (![go.PointerType applyasfollowerargs_gk.S] "args"))))
        then
          (if: Convert go.untyped_bool go.bool ((![go.uint64] (StructFieldRef paxosstate_gk.S "NextIndex"%go (![go.PointerType paxosstate_gk.S] "ps"))) <⟨go.uint64⟩ (![go.uint64] (StructFieldRef applyasfollowerargs_gk.S "NextIndex"%go (![go.PointerType applyasfollowerargs_gk.S] "args"))))
          then
            let: "$r0" := (![go.uint64] (StructFieldRef applyasfollowerargs_gk.S "NextIndex"%go (![go.PointerType applyasfollowerargs_gk.S] "args"))) in
            do:  ((StructFieldRef paxosstate_gk.S "NextIndex"%go (![go.PointerType paxosstate_gk.S] "ps")) <-[go.uint64] "$r0");;;
            let: "$r0" := (![go.SliceType go.byte] (StructFieldRef applyasfollowerargs_gk.S "State"%go (![go.PointerType applyasfollowerargs_gk.S] "args"))) in
            do:  ((StructFieldRef paxosstate_gk.S "State"%go (![go.PointerType paxosstate_gk.S] "ps")) <-[go.SliceType go.byte] "$r0");;;
            let: "$r0" := error_gk.ENone in
            do:  ((StructFieldRef applyasfollowerreply_gk.S "Err"%go (![go.PointerType applyasfollowerreply_gk.S] "reply")) <-[error_gk.E] "$r0")
          else
            let: "$r0" := error_gk.ENone in
            do:  ((StructFieldRef applyasfollowerreply_gk.S "Err"%go (![go.PointerType applyasfollowerreply_gk.S] "reply")) <-[error_gk.E] "$r0"))
        else
          let: "$r0" := (![go.uint64] (StructFieldRef applyasfollowerargs_gk.S "Epoch"%go (![go.PointerType applyasfollowerargs_gk.S] "args"))) in
          do:  ((StructFieldRef paxosstate_gk.S "AcceptedEpoch"%go (![go.PointerType paxosstate_gk.S] "ps")) <-[go.uint64] "$r0");;;
          let: "$r0" := (![go.uint64] (StructFieldRef applyasfollowerargs_gk.S "Epoch"%go (![go.PointerType applyasfollowerargs_gk.S] "args"))) in
          do:  ((StructFieldRef paxosstate_gk.S "Epoch"%go (![go.PointerType paxosstate_gk.S] "ps")) <-[go.uint64] "$r0");;;
          let: "$r0" := (![go.SliceType go.byte] (StructFieldRef applyasfollowerargs_gk.S "State"%go (![go.PointerType applyasfollowerargs_gk.S] "args"))) in
          do:  ((StructFieldRef paxosstate_gk.S "State"%go (![go.PointerType paxosstate_gk.S] "ps")) <-[go.SliceType go.byte] "$r0");;;
          let: "$r0" := (![go.uint64] (StructFieldRef applyasfollowerargs_gk.S "NextIndex"%go (![go.PointerType applyasfollowerargs_gk.S] "args"))) in
          do:  ((StructFieldRef paxosstate_gk.S "NextIndex"%go (![go.PointerType paxosstate_gk.S] "ps")) <-[go.uint64] "$r0");;;
          let: "$r0" := #false in
          do:  ((StructFieldRef paxosstate_gk.S "IsLeader"%go (![go.PointerType paxosstate_gk.S] "ps")) <-[go.bool] "$r0");;;
          let: "$r0" := error_gk.ENone in
          do:  ((StructFieldRef applyasfollowerreply_gk.S "Err"%go (![go.PointerType applyasfollowerreply_gk.S] "reply")) <-[error_gk.E] "$r0"))
      else
        let: "$r0" := error_gk.EEpochStale in
        do:  ((StructFieldRef applyasfollowerreply_gk.S "Err"%go (![go.PointerType applyasfollowerreply_gk.S] "reply")) <-[error_gk.E] "$r0"));;;
      return: #())
      ) in
    (MethodResolve (go.PointerType Server) "withLock"%go (![go.PointerType Server] "s")) "$a0");;;
    return: #()).

(* NOTE:
   This will vote yes only the first time it's called in an epoch.
   If you have too aggressive of a timeout and end up retrying this, the retry
   might fail because it may be the second execution of enterNewEpoch(epoch) on
   the server.
   Solution: either conservative (maybe double) timeouts, or don't use this for
   leader election, only for coming up with a valid proposal.

   go: server.go:66:18 *)
Definition Server__enterNewEpochⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" "args" "reply",
    exception_do (let: "s" := (GoAlloc (go.PointerType Server) "s") in
    let: "reply" := (GoAlloc (go.PointerType enternewepochreply_gk.S) "reply") in
    let: "args" := (GoAlloc (go.PointerType enternewepochargs_gk.S) "args") in
    do:  (let: "$a0" := (λ: "ps",
      exception_do (let: "ps" := (GoAlloc (go.PointerType paxosstate_gk.S) "ps") in
      (if: Convert go.untyped_bool go.bool ((![go.uint64] (StructFieldRef paxosstate_gk.S "Epoch"%go (![go.PointerType paxosstate_gk.S] "ps"))) ≥⟨go.uint64⟩ (![go.uint64] (StructFieldRef enternewepochargs_gk.S "Epoch"%go (![go.PointerType enternewepochargs_gk.S] "args"))))
      then
        let: "$r0" := error_gk.EEpochStale in
        do:  ((StructFieldRef enternewepochreply_gk.S "Err"%go (![go.PointerType enternewepochreply_gk.S] "reply")) <-[error_gk.E] "$r0");;;
        return: (#())
      else do:  #());;;
      let: "$r0" := #false in
      do:  ((StructFieldRef paxosstate_gk.S "IsLeader"%go (![go.PointerType paxosstate_gk.S] "ps")) <-[go.bool] "$r0");;;
      let: "$r0" := (![go.uint64] (StructFieldRef enternewepochargs_gk.S "Epoch"%go (![go.PointerType enternewepochargs_gk.S] "args"))) in
      do:  ((StructFieldRef paxosstate_gk.S "Epoch"%go (![go.PointerType paxosstate_gk.S] "ps")) <-[go.uint64] "$r0");;;
      let: "$r0" := (![go.uint64] (StructFieldRef paxosstate_gk.S "AcceptedEpoch"%go (![go.PointerType paxosstate_gk.S] "ps"))) in
      do:  ((StructFieldRef enternewepochreply_gk.S "AcceptedEpoch"%go (![go.PointerType enternewepochreply_gk.S] "reply")) <-[go.uint64] "$r0");;;
      let: "$r0" := (![go.uint64] (StructFieldRef paxosstate_gk.S "NextIndex"%go (![go.PointerType paxosstate_gk.S] "ps"))) in
      do:  ((StructFieldRef enternewepochreply_gk.S "NextIndex"%go (![go.PointerType enternewepochreply_gk.S] "reply")) <-[go.uint64] "$r0");;;
      let: "$r0" := (![go.SliceType go.byte] (StructFieldRef paxosstate_gk.S "State"%go (![go.PointerType paxosstate_gk.S] "ps"))) in
      do:  ((StructFieldRef enternewepochreply_gk.S "State"%go (![go.PointerType enternewepochreply_gk.S] "reply")) <-[go.SliceType go.byte] "$r0");;;
      return: #())
      ) in
    (MethodResolve (go.PointerType Server) "withLock"%go (![go.PointerType Server] "s")) "$a0");;;
    return: #()).

(* go: server.go:81:18 *)
Definition Server__TryBecomeLeaderⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" <>,
    exception_do (let: "s" := (GoAlloc (go.PointerType Server) "s") in
    do:  (let: "$a0" := ((let: "$sl0" := (Convert go.string go.any #"started trybecomeleader"%go) in
    CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0")]))) in
    (FuncResolve log.Println [] #()) "$a0");;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] (StructFieldRef Server "mu"%go (![go.PointerType Server] "s")))) #());;;
    (if: ![go.bool] (StructFieldRef paxosstate_gk.S "IsLeader"%go (![go.PointerType paxosstate_gk.S] (StructFieldRef Server "ps"%go (![go.PointerType Server] "s"))))
    then
      do:  (let: "$a0" := ((let: "$sl0" := (Convert go.string go.any #"already leader"%go) in
      CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0")]))) in
      (FuncResolve log.Println [] #()) "$a0");;;
      do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef Server "mu"%go (![go.PointerType Server] "s")))) #());;;
      return: (#())
    else do:  #());;;
    let: "clerks" := (GoAlloc (go.SliceType (go.PointerType singleClerk)) (GoZeroVal (go.SliceType (go.PointerType singleClerk)) #())) in
    let: "$r0" := (![go.SliceType (go.PointerType singleClerk)] (StructFieldRef Server "clerks"%go (![go.PointerType Server] "s"))) in
    do:  ("clerks" <-[go.SliceType (go.PointerType singleClerk)] "$r0");;;
    let: "args" := (GoAlloc (go.PointerType enternewepochargs_gk.S) (GoZeroVal (go.PointerType enternewepochargs_gk.S) #())) in
    let: "$r0" := (GoAlloc enternewepochargs_gk.S (CompositeLiteral enternewepochargs_gk.S (LiteralValue [KeyedElement (Some (KeyField "Epoch"%go)) (ElementExpression go.uint64 ((![go.uint64] (StructFieldRef paxosstate_gk.S "Epoch"%go (![go.PointerType paxosstate_gk.S] (StructFieldRef Server "ps"%go (![go.PointerType Server] "s"))))) +⟨go.uint64⟩ #(W64 1)))]))) in
    do:  ("args" <-[go.PointerType enternewepochargs_gk.S] "$r0");;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef Server "mu"%go (![go.PointerType Server] "s")))) #());;;
    let: "numReplies" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("numReplies" <-[go.uint64] "$r0");;;
    let: "replies" := (GoAlloc (go.SliceType (go.PointerType enternewepochreply_gk.S)) (GoZeroVal (go.SliceType (go.PointerType enternewepochreply_gk.S)) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType (go.PointerType enternewepochreply_gk.S)] #()) (Convert go.int go.uint64 (let: "$a0" := (![go.SliceType (go.PointerType singleClerk)] "clerks") in
    (FuncResolve go.len [go.SliceType (go.PointerType singleClerk)] #()) "$a0"))) in
    do:  ("replies" <-[go.SliceType (go.PointerType enternewepochreply_gk.S)] "$r0");;;
    let: "mu" := (GoAlloc (go.PointerType sync.Mutex) (GoZeroVal (go.PointerType sync.Mutex) #())) in
    let: "$r0" := (GoAlloc sync.Mutex (GoZeroVal sync.Mutex #())) in
    do:  ("mu" <-[go.PointerType sync.Mutex] "$r0");;;
    let: "numReplies_cond" := (GoAlloc (go.PointerType sync.Cond) (GoZeroVal (go.PointerType sync.Cond) #())) in
    let: "$r0" := (let: "$a0" := (Convert (go.PointerType sync.Mutex) sync.Locker (![go.PointerType sync.Mutex] "mu")) in
    (FuncResolve sync.NewCond [] #()) "$a0") in
    do:  ("numReplies_cond" <-[go.PointerType sync.Cond] "$r0");;;
    let: "n" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (Convert go.int go.uint64 (let: "$a0" := (![go.SliceType (go.PointerType singleClerk)] "clerks") in
    (FuncResolve go.len [go.SliceType (go.PointerType singleClerk)] #()) "$a0")) in
    do:  ("n" <-[go.uint64] "$r0");;;
    let: "$range" := (![go.SliceType (go.PointerType singleClerk)] "clerks") in
    (let: "ck" := (GoAlloc (go.PointerType singleClerk) (GoZeroVal (go.PointerType singleClerk) #())) in
    let: "i" := (GoAlloc go.int (GoZeroVal go.int #())) in
    slice.for_range (go.PointerType singleClerk) "$range" (λ: "$key" "$value",
      do:  ("ck" <-[go.PointerType singleClerk] "$value");;;
      do:  ("i" <-[go.int] "$key");;;
      let: "$go" := (λ: <>,
        exception_do (let: "reply" := (GoAlloc (go.PointerType enternewepochreply_gk.S) (GoZeroVal (go.PointerType enternewepochreply_gk.S) #())) in
        let: "$r0" := (let: "$a0" := (![go.PointerType enternewepochargs_gk.S] "args") in
        (MethodResolve (go.PointerType singleClerk) "enterNewEpoch"%go (![go.PointerType singleClerk] "ck")) "$a0") in
        do:  ("reply" <-[go.PointerType enternewepochreply_gk.S] "$r0");;;
        do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] "mu")) #());;;
        do:  ("numReplies" <-[go.uint64] ((![go.uint64] "numReplies") +⟨go.uint64⟩ #(W64 1)));;;
        let: "$r0" := (![go.PointerType enternewepochreply_gk.S] "reply") in
        do:  ((IndexRef (go.SliceType (go.PointerType enternewepochreply_gk.S)) (![go.SliceType (go.PointerType enternewepochreply_gk.S)] "replies", ![go.int] "i")) <-[go.PointerType enternewepochreply_gk.S] "$r0");;;
        (if: Convert go.untyped_bool go.bool ((#(W64 2) *⟨go.uint64⟩ (![go.uint64] "numReplies")) >⟨go.uint64⟩ (![go.uint64] "n"))
        then do:  ((MethodResolve (go.PointerType sync.Cond) "Signal"%go (![go.PointerType sync.Cond] "numReplies_cond")) #())
        else do:  #());;;
        do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] "mu")) #());;;
        return: #())
        ) in
      do:  (Fork ("$go" #()))));;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] "mu")) #());;;
    (for: (λ: <>, (#(W64 2) *⟨go.uint64⟩ (![go.uint64] "numReplies")) ≤⟨go.uint64⟩ (![go.uint64] "n")); (λ: <>, #()) := λ: <>,
      do:  ((MethodResolve (go.PointerType sync.Cond) "Wait"%go (![go.PointerType sync.Cond] "numReplies_cond")) #()));;;
    let: "latestReply" := (GoAlloc (go.PointerType enternewepochreply_gk.S) (GoZeroVal (go.PointerType enternewepochreply_gk.S) #())) in
    let: "numSuccesses" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("numSuccesses" <-[go.uint64] "$r0");;;
    let: "$range" := (![go.SliceType (go.PointerType enternewepochreply_gk.S)] "replies") in
    (let: "reply" := (GoAlloc (go.PointerType enternewepochreply_gk.S) (GoZeroVal (go.PointerType enternewepochreply_gk.S) #())) in
    slice.for_range (go.PointerType enternewepochreply_gk.S) "$range" (λ: "$key" "$value",
      do:  ("reply" <-[go.PointerType enternewepochreply_gk.S] "$value");;;
      do:  "$key";;;
      (if: Convert go.untyped_bool go.bool ((![go.PointerType enternewepochreply_gk.S] "reply") ≠⟨go.PointerType enternewepochreply_gk.S⟩ (Convert go.untyped_nil (go.PointerType enternewepochreply_gk.S) UntypedNil))
      then
        (if: Convert go.untyped_bool go.bool ((![error_gk.E] (StructFieldRef enternewepochreply_gk.S "Err"%go (![go.PointerType enternewepochreply_gk.S] "reply"))) =⟨go.uint32⟩ error_gk.ENone)
        then
          (if: Convert go.untyped_bool go.bool ((![go.uint64] "numSuccesses") =⟨go.uint64⟩ #(W64 0))
          then
            let: "$r0" := (![go.PointerType enternewepochreply_gk.S] "reply") in
            do:  ("latestReply" <-[go.PointerType enternewepochreply_gk.S] "$r0")
          else
            (if: Convert go.untyped_bool go.bool ((![go.uint64] (StructFieldRef enternewepochreply_gk.S "AcceptedEpoch"%go (![go.PointerType enternewepochreply_gk.S] "latestReply"))) <⟨go.uint64⟩ (![go.uint64] (StructFieldRef enternewepochreply_gk.S "AcceptedEpoch"%go (![go.PointerType enternewepochreply_gk.S] "reply"))))
            then
              let: "$r0" := (![go.PointerType enternewepochreply_gk.S] "reply") in
              do:  ("latestReply" <-[go.PointerType enternewepochreply_gk.S] "$r0")
            else
              (if: Convert go.untyped_bool go.bool (((![go.uint64] (StructFieldRef enternewepochreply_gk.S "AcceptedEpoch"%go (![go.PointerType enternewepochreply_gk.S] "latestReply"))) =⟨go.uint64⟩ (![go.uint64] (StructFieldRef enternewepochreply_gk.S "AcceptedEpoch"%go (![go.PointerType enternewepochreply_gk.S] "reply")))) && ((![go.uint64] (StructFieldRef enternewepochreply_gk.S "NextIndex"%go (![go.PointerType enternewepochreply_gk.S] "reply"))) >⟨go.uint64⟩ (![go.uint64] (StructFieldRef enternewepochreply_gk.S "NextIndex"%go (![go.PointerType enternewepochreply_gk.S] "latestReply")))))
              then
                let: "$r0" := (![go.PointerType enternewepochreply_gk.S] "reply") in
                do:  ("latestReply" <-[go.PointerType enternewepochreply_gk.S] "$r0")
              else do:  #())));;;
          do:  ("numSuccesses" <-[go.uint64] ((![go.uint64] "numSuccesses") +⟨go.uint64⟩ #(W64 1)))
        else do:  #())
      else do:  #())));;;
    (if: Convert go.untyped_bool go.bool ((#(W64 2) *⟨go.uint64⟩ (![go.uint64] "numSuccesses")) >⟨go.uint64⟩ (![go.uint64] "n"))
    then
      do:  (let: "$a0" := (λ: "ps",
        exception_do (let: "ps" := (GoAlloc (go.PointerType paxosstate_gk.S) "ps") in
        (if: Convert go.untyped_bool go.bool ((![go.uint64] (StructFieldRef paxosstate_gk.S "Epoch"%go (![go.PointerType paxosstate_gk.S] "ps"))) ≤⟨go.uint64⟩ (![go.uint64] (StructFieldRef enternewepochargs_gk.S "Epoch"%go (![go.PointerType enternewepochargs_gk.S] "args"))))
        then
          do:  (let: "$a0" := #"succeeded becomeleader in epoch %d
          "%go in
          let: "$a1" := ((let: "$sl0" := (Convert go.uint64 go.any (![go.uint64] (StructFieldRef enternewepochargs_gk.S "Epoch"%go (![go.PointerType enternewepochargs_gk.S] "args")))) in
          CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0")]))) in
          (FuncResolve log.Printf [] #()) "$a0" "$a1");;;
          let: "$r0" := (![go.uint64] (StructFieldRef enternewepochargs_gk.S "Epoch"%go (![go.PointerType enternewepochargs_gk.S] "args"))) in
          do:  ((StructFieldRef paxosstate_gk.S "Epoch"%go (![go.PointerType paxosstate_gk.S] "ps")) <-[go.uint64] "$r0");;;
          let: "$r0" := #true in
          do:  ((StructFieldRef paxosstate_gk.S "IsLeader"%go (![go.PointerType paxosstate_gk.S] "ps")) <-[go.bool] "$r0");;;
          let: "$r0" := (![go.uint64] (StructFieldRef paxosstate_gk.S "Epoch"%go (![go.PointerType paxosstate_gk.S] "ps"))) in
          do:  ((StructFieldRef paxosstate_gk.S "AcceptedEpoch"%go (![go.PointerType paxosstate_gk.S] "ps")) <-[go.uint64] "$r0");;;
          let: "$r0" := (![go.uint64] (StructFieldRef enternewepochreply_gk.S "NextIndex"%go (![go.PointerType enternewepochreply_gk.S] "latestReply"))) in
          do:  ((StructFieldRef paxosstate_gk.S "NextIndex"%go (![go.PointerType paxosstate_gk.S] "ps")) <-[go.uint64] "$r0");;;
          let: "$r0" := (![go.SliceType go.byte] (StructFieldRef enternewepochreply_gk.S "State"%go (![go.PointerType enternewepochreply_gk.S] "latestReply"))) in
          do:  ((StructFieldRef paxosstate_gk.S "State"%go (![go.PointerType paxosstate_gk.S] "ps")) <-[go.SliceType go.byte] "$r0")
        else do:  #());;;
        return: #())
        ) in
      (MethodResolve (go.PointerType Server) "withLock"%go (![go.PointerType Server] "s")) "$a0");;;
      do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] "mu")) #())
    else
      do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] "mu")) #());;;
      do:  (let: "$a0" := ((let: "$sl0" := (Convert go.string go.any #"failed becomeleader"%go) in
      CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0")]))) in
      (FuncResolve log.Println [] #()) "$a0"));;;
    return: #()).

(* go: server.go:163:18 *)
Definition Server__TryAcquireⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" <>,
    exception_do (let: "s" := (GoAlloc (go.PointerType Server) "s") in
    let: "retErr" := (GoAlloc error_gk.E (GoZeroVal error_gk.E #())) in
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] (StructFieldRef Server "mu"%go (![go.PointerType Server] "s")))) #());;;
    (if: (⟨go.bool⟩! (![go.bool] (StructFieldRef paxosstate_gk.S "IsLeader"%go (![go.PointerType paxosstate_gk.S] (StructFieldRef Server "ps"%go (![go.PointerType Server] "s"))))))
    then
      do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef Server "mu"%go (![go.PointerType Server] "s")))) #());;;
      let: "n" := (GoAlloc (go.PointerType (go.SliceType go.byte)) (GoZeroVal (go.PointerType (go.SliceType go.byte)) #())) in
      return: (error_gk.ENotLeader, ![go.PointerType (go.SliceType go.byte)] "n", Convert go.untyped_nil (go.FunctionType (go.Signature [] false [error_gk.E])) UntypedNil)
    else do:  #());;;
    let: "tryRelease" := (GoAlloc (go.FunctionType (go.Signature [] false [error_gk.E])) (GoZeroVal (go.FunctionType (go.Signature [] false [error_gk.E])) #())) in
    let: "$r0" := (λ: <>,
      exception_do (let: "$r0" := (let: "$a0" := (![go.uint64] (StructFieldRef paxosstate_gk.S "NextIndex"%go (![go.PointerType paxosstate_gk.S] (StructFieldRef Server "ps"%go (![go.PointerType Server] "s"))))) in
      let: "$a1" := #(W64 1) in
      (FuncResolve std.SumAssumeNoOverflow [] #()) "$a0" "$a1") in
      do:  ((StructFieldRef paxosstate_gk.S "NextIndex"%go (![go.PointerType paxosstate_gk.S] (StructFieldRef Server "ps"%go (![go.PointerType Server] "s")))) <-[go.uint64] "$r0");;;
      let: "args" := (GoAlloc (go.PointerType applyasfollowerargs_gk.S) (GoZeroVal (go.PointerType applyasfollowerargs_gk.S) #())) in
      let: "$r0" := (GoAlloc applyasfollowerargs_gk.S (CompositeLiteral applyasfollowerargs_gk.S (LiteralValue [KeyedElement (Some (KeyField "Epoch"%go)) (ElementExpression go.uint64 (![go.uint64] (StructFieldRef paxosstate_gk.S "Epoch"%go (![go.PointerType paxosstate_gk.S] (StructFieldRef Server "ps"%go (![go.PointerType Server] "s")))))); KeyedElement (Some (KeyField "NextIndex"%go)) (ElementExpression go.uint64 (![go.uint64] (StructFieldRef paxosstate_gk.S "NextIndex"%go (![go.PointerType paxosstate_gk.S] (StructFieldRef Server "ps"%go (![go.PointerType Server] "s")))))); KeyedElement (Some (KeyField "State"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] (StructFieldRef paxosstate_gk.S "State"%go (![go.PointerType paxosstate_gk.S] (StructFieldRef Server "ps"%go (![go.PointerType Server] "s"))))))]))) in
      do:  ("args" <-[go.PointerType applyasfollowerargs_gk.S] "$r0");;;
      let: "waitFn" := (GoAlloc (go.FunctionType (go.Signature [] false [])) (GoZeroVal (go.FunctionType (go.Signature [] false [])) #())) in
      let: "$r0" := (let: "$a0" := (let: "$a0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 0)) in
      let: "$a1" := (![paxosstate_gk.S] (![go.PointerType paxosstate_gk.S] (StructFieldRef Server "ps"%go (![go.PointerType Server] "s")))) in
      (FuncResolve paxosstate_gk.Marshal [] #()) "$a0" "$a1") in
      (MethodResolve (go.PointerType asyncfile.AsyncFile) "Write"%go (![go.PointerType asyncfile.AsyncFile] (StructFieldRef Server "storage"%go (![go.PointerType Server] "s")))) "$a0") in
      do:  ("waitFn" <-[go.FunctionType (go.Signature [] false [])] "$r0");;;
      do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef Server "mu"%go (![go.PointerType Server] "s")))) #());;;
      do:  ((![go.FunctionType (go.Signature [] false [])] "waitFn") #());;;
      let: "clerks" := (GoAlloc (go.SliceType (go.PointerType singleClerk)) (GoZeroVal (go.SliceType (go.PointerType singleClerk)) #())) in
      let: "$r0" := (![go.SliceType (go.PointerType singleClerk)] (StructFieldRef Server "clerks"%go (![go.PointerType Server] "s"))) in
      do:  ("clerks" <-[go.SliceType (go.PointerType singleClerk)] "$r0");;;
      let: "numReplies" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: "$r0" := #(W64 0) in
      do:  ("numReplies" <-[go.uint64] "$r0");;;
      let: "replies" := (GoAlloc (go.SliceType (go.PointerType applyasfollowerreply_gk.S)) (GoZeroVal (go.SliceType (go.PointerType applyasfollowerreply_gk.S)) #())) in
      let: "$r0" := ((FuncResolve go.make2 [go.SliceType (go.PointerType applyasfollowerreply_gk.S)] #()) (Convert go.int go.uint64 (let: "$a0" := (![go.SliceType (go.PointerType singleClerk)] "clerks") in
      (FuncResolve go.len [go.SliceType (go.PointerType singleClerk)] #()) "$a0"))) in
      do:  ("replies" <-[go.SliceType (go.PointerType applyasfollowerreply_gk.S)] "$r0");;;
      let: "mu" := (GoAlloc (go.PointerType sync.Mutex) (GoZeroVal (go.PointerType sync.Mutex) #())) in
      let: "$r0" := (GoAlloc sync.Mutex (GoZeroVal sync.Mutex #())) in
      do:  ("mu" <-[go.PointerType sync.Mutex] "$r0");;;
      let: "numReplies_cond" := (GoAlloc (go.PointerType sync.Cond) (GoZeroVal (go.PointerType sync.Cond) #())) in
      let: "$r0" := (let: "$a0" := (Convert (go.PointerType sync.Mutex) sync.Locker (![go.PointerType sync.Mutex] "mu")) in
      (FuncResolve sync.NewCond [] #()) "$a0") in
      do:  ("numReplies_cond" <-[go.PointerType sync.Cond] "$r0");;;
      let: "n" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: "$r0" := (Convert go.int go.uint64 (let: "$a0" := (![go.SliceType (go.PointerType singleClerk)] "clerks") in
      (FuncResolve go.len [go.SliceType (go.PointerType singleClerk)] #()) "$a0")) in
      do:  ("n" <-[go.uint64] "$r0");;;
      let: "$range" := (![go.SliceType (go.PointerType singleClerk)] "clerks") in
      (let: "ck" := (GoAlloc (go.PointerType singleClerk) (GoZeroVal (go.PointerType singleClerk) #())) in
      let: "i" := (GoAlloc go.int (GoZeroVal go.int #())) in
      slice.for_range (go.PointerType singleClerk) "$range" (λ: "$key" "$value",
        do:  ("ck" <-[go.PointerType singleClerk] "$value");;;
        do:  ("i" <-[go.int] "$key");;;
        let: "ck" := (GoAlloc (go.PointerType singleClerk) (GoZeroVal (go.PointerType singleClerk) #())) in
        let: "$r0" := (![go.PointerType singleClerk] "ck") in
        do:  ("ck" <-[go.PointerType singleClerk] "$r0");;;
        let: "i" := (GoAlloc go.int (GoZeroVal go.int #())) in
        let: "$r0" := (![go.int] "i") in
        do:  ("i" <-[go.int] "$r0");;;
        let: "$go" := (λ: <>,
          exception_do (let: "reply" := (GoAlloc (go.PointerType applyasfollowerreply_gk.S) (GoZeroVal (go.PointerType applyasfollowerreply_gk.S) #())) in
          let: "$r0" := (let: "$a0" := (![go.PointerType applyasfollowerargs_gk.S] "args") in
          (MethodResolve (go.PointerType singleClerk) "applyAsFollower"%go (![go.PointerType singleClerk] "ck")) "$a0") in
          do:  ("reply" <-[go.PointerType applyasfollowerreply_gk.S] "$r0");;;
          do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] "mu")) #());;;
          do:  ("numReplies" <-[go.uint64] ((![go.uint64] "numReplies") +⟨go.uint64⟩ #(W64 1)));;;
          let: "$r0" := (![go.PointerType applyasfollowerreply_gk.S] "reply") in
          do:  ((IndexRef (go.SliceType (go.PointerType applyasfollowerreply_gk.S)) (![go.SliceType (go.PointerType applyasfollowerreply_gk.S)] "replies", ![go.int] "i")) <-[go.PointerType applyasfollowerreply_gk.S] "$r0");;;
          (if: Convert go.untyped_bool go.bool ((#(W64 2) *⟨go.uint64⟩ (![go.uint64] "numReplies")) >⟨go.uint64⟩ (![go.uint64] "n"))
          then do:  ((MethodResolve (go.PointerType sync.Cond) "Signal"%go (![go.PointerType sync.Cond] "numReplies_cond")) #())
          else do:  #());;;
          do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] "mu")) #());;;
          return: #())
          ) in
        do:  (Fork ("$go" #()))));;;
      do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] "mu")) #());;;
      (for: (λ: <>, (#(W64 2) *⟨go.uint64⟩ (![go.uint64] "numReplies")) ≤⟨go.uint64⟩ (![go.uint64] "n")); (λ: <>, #()) := λ: <>,
        do:  ((MethodResolve (go.PointerType sync.Cond) "Wait"%go (![go.PointerType sync.Cond] "numReplies_cond")) #()));;;
      let: "numSuccesses" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: "$r0" := #(W64 0) in
      do:  ("numSuccesses" <-[go.uint64] "$r0");;;
      let: "$range" := (![go.SliceType (go.PointerType applyasfollowerreply_gk.S)] "replies") in
      (let: "reply" := (GoAlloc (go.PointerType applyasfollowerreply_gk.S) (GoZeroVal (go.PointerType applyasfollowerreply_gk.S) #())) in
      slice.for_range (go.PointerType applyasfollowerreply_gk.S) "$range" (λ: "$key" "$value",
        do:  ("reply" <-[go.PointerType applyasfollowerreply_gk.S] "$value");;;
        do:  "$key";;;
        (if: Convert go.untyped_bool go.bool ((![go.PointerType applyasfollowerreply_gk.S] "reply") ≠⟨go.PointerType applyasfollowerreply_gk.S⟩ (Convert go.untyped_nil (go.PointerType applyasfollowerreply_gk.S) UntypedNil))
        then
          (if: Convert go.untyped_bool go.bool ((![error_gk.E] (StructFieldRef applyasfollowerreply_gk.S "Err"%go (![go.PointerType applyasfollowerreply_gk.S] "reply"))) =⟨go.uint32⟩ error_gk.ENone)
          then do:  ("numSuccesses" <-[go.uint64] ((![go.uint64] "numSuccesses") +⟨go.uint64⟩ #(W64 1)))
          else do:  #())
        else do:  #())));;;
      (if: Convert go.untyped_bool go.bool ((#(W64 2) *⟨go.uint64⟩ (![go.uint64] "numSuccesses")) >⟨go.uint64⟩ (![go.uint64] "n"))
      then
        let: "$r0" := error_gk.ENone in
        do:  ("retErr" <-[error_gk.E] "$r0")
      else
        let: "$r0" := error_gk.EEpochStale in
        do:  ("retErr" <-[error_gk.E] "$r0"));;;
      return: (![error_gk.E] "retErr"))
      ) in
    do:  ("tryRelease" <-[go.FunctionType (go.Signature [] false [error_gk.E])] "$r0");;;
    return: (error_gk.ENone, StructFieldRef paxosstate_gk.S "State"%go (![go.PointerType paxosstate_gk.S] (StructFieldRef Server "ps"%go (![go.PointerType Server] "s"))), ![go.FunctionType (go.Signature [] false [error_gk.E])] "tryRelease")).

(* go: server.go:233:18 *)
Definition Server__WeakReadⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" <>,
    exception_do (let: "s" := (GoAlloc (go.PointerType Server) "s") in
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] (StructFieldRef Server "mu"%go (![go.PointerType Server] "s")))) #());;;
    let: "ret" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (![go.SliceType go.byte] (StructFieldRef paxosstate_gk.S "State"%go (![go.PointerType paxosstate_gk.S] (StructFieldRef Server "ps"%go (![go.PointerType Server] "s"))))) in
    do:  ("ret" <-[go.SliceType go.byte] "$r0");;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef Server "mu"%go (![go.PointerType Server] "s")))) #());;;
    return: (![go.SliceType go.byte] "ret")).

(* go: server.go:240:6 *)
Definition makeServerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "fname" "initstate" "config",
    exception_do (let: "config" := (GoAlloc (go.SliceType grove_ffi.Address) "config") in
    let: "initstate" := (GoAlloc (go.SliceType go.byte) "initstate") in
    let: "fname" := (GoAlloc go.string "fname") in
    let: "s" := (GoAlloc (go.PointerType Server) (GoZeroVal (go.PointerType Server) #())) in
    let: "$r0" := (GoAlloc Server (GoZeroVal Server #())) in
    do:  ("s" <-[go.PointerType Server] "$r0");;;
    let: "$r0" := (GoAlloc sync.Mutex (GoZeroVal sync.Mutex #())) in
    do:  ((StructFieldRef Server "mu"%go (![go.PointerType Server] "s")) <-[go.PointerType sync.Mutex] "$r0");;;
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType (go.PointerType singleClerk)] #()) #(W64 0)) in
    do:  ((StructFieldRef Server "clerks"%go (![go.PointerType Server] "s")) <-[go.SliceType (go.PointerType singleClerk)] "$r0");;;
    let: "$range" := (![go.SliceType grove_ffi.Address] "config") in
    (let: "host" := (GoAlloc grove_ffi.Address (GoZeroVal grove_ffi.Address #())) in
    slice.for_range grove_ffi.Address "$range" (λ: "$key" "$value",
      do:  ("host" <-[grove_ffi.Address] "$value");;;
      do:  "$key";;;
      let: "$r0" := (let: "$a0" := (![go.SliceType (go.PointerType singleClerk)] (StructFieldRef Server "clerks"%go (![go.PointerType Server] "s"))) in
      let: "$a1" := ((let: "$sl0" := (let: "$a0" := (![grove_ffi.Address] "host") in
      (FuncResolve MakeSingleClerk [] #()) "$a0") in
      CompositeLiteral (go.SliceType (go.PointerType singleClerk)) (LiteralValue [KeyedElement None (ElementExpression (go.PointerType singleClerk) "$sl0")]))) in
      (FuncResolve go.append [go.SliceType (go.PointerType singleClerk)] #()) "$a0" "$a1") in
      do:  ((StructFieldRef Server "clerks"%go (![go.PointerType Server] "s")) <-[go.SliceType (go.PointerType singleClerk)] "$r0")));;;
    let: "encstate" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.string] "fname") in
    (FuncResolve asyncfile.MakeAsyncFile [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("encstate" <-[go.SliceType go.byte] "$r0");;;
    do:  ((StructFieldRef Server "storage"%go (![go.PointerType Server] "s")) <-[go.PointerType asyncfile.AsyncFile] "$r1");;;
    (if: Convert go.untyped_bool go.bool ((let: "$a0" := (![go.SliceType go.byte] "encstate") in
    (FuncResolve go.len [go.SliceType go.byte] #()) "$a0") =⟨go.int⟩ #(W64 0))
    then
      let: "$r0" := (GoAlloc paxosstate_gk.S (GoZeroVal paxosstate_gk.S #())) in
      do:  ((StructFieldRef Server "ps"%go (![go.PointerType Server] "s")) <-[go.PointerType paxosstate_gk.S] "$r0");;;
      let: "$r0" := (![go.SliceType go.byte] "initstate") in
      do:  ((StructFieldRef paxosstate_gk.S "State"%go (![go.PointerType paxosstate_gk.S] (StructFieldRef Server "ps"%go (![go.PointerType Server] "s")))) <-[go.SliceType go.byte] "$r0")
    else
      let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] "encstate") in
      (FuncResolve paxosstate_gk.Unmarshal [] #()) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ((![go.PointerType paxosstate_gk.S] (StructFieldRef Server "ps"%go (![go.PointerType Server] "s"))) <-[paxosstate_gk.S] "$r0");;;
      do:  "$r1");;;
    return: (![go.PointerType Server] "s")).

(* go: server.go:260:6 *)
Definition StartServerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "fname" "initstate" "me" "config",
    exception_do (let: "config" := (GoAlloc (go.SliceType grove_ffi.Address) "config") in
    let: "me" := (GoAlloc grove_ffi.Address "me") in
    let: "initstate" := (GoAlloc (go.SliceType go.byte) "initstate") in
    let: "fname" := (GoAlloc go.string "fname") in
    let: "s" := (GoAlloc (go.PointerType Server) (GoZeroVal (go.PointerType Server) #())) in
    let: "$r0" := (let: "$a0" := (![go.string] "fname") in
    let: "$a1" := (![go.SliceType go.byte] "initstate") in
    let: "$a2" := (![go.SliceType grove_ffi.Address] "config") in
    (FuncResolve makeServer [] #()) "$a0" "$a1" "$a2") in
    do:  ("s" <-[go.PointerType Server] "$r0");;;
    let: "handlers" := (GoAlloc (go.MapType go.uint64 (go.FunctionType (go.Signature [go.SliceType go.byte; go.PointerType (go.SliceType go.byte)] false []))) (GoZeroVal (go.MapType go.uint64 (go.FunctionType (go.Signature [go.SliceType go.byte; go.PointerType (go.SliceType go.byte)] false []))) #())) in
    let: "$r0" := ((FuncResolve go.make1 [go.MapType go.uint64 (go.FunctionType (go.Signature [go.SliceType go.byte; go.PointerType (go.SliceType go.byte)] false []))] #()) #()) in
    do:  ("handlers" <-[go.MapType go.uint64 (go.FunctionType (go.Signature [go.SliceType go.byte; go.PointerType (go.SliceType go.byte)] false []))] "$r0");;;
    let: "$r0" := (λ: "raw_args" "raw_reply",
      exception_do (let: "raw_reply" := (GoAlloc (go.PointerType (go.SliceType go.byte)) "raw_reply") in
      let: "raw_args" := (GoAlloc (go.SliceType go.byte) "raw_args") in
      let: "reply" := (GoAlloc (go.PointerType applyasfollowerreply_gk.S) (GoZeroVal (go.PointerType applyasfollowerreply_gk.S) #())) in
      let: "$r0" := (GoAlloc applyasfollowerreply_gk.S (GoZeroVal applyasfollowerreply_gk.S #())) in
      do:  ("reply" <-[go.PointerType applyasfollowerreply_gk.S] "$r0");;;
      let: "args" := (GoAlloc applyasfollowerargs_gk.S (GoZeroVal applyasfollowerargs_gk.S #())) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] "raw_args") in
      (FuncResolve applyasfollowerargs_gk.Unmarshal [] #()) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("args" <-[applyasfollowerargs_gk.S] "$r0");;;
      do:  "$r1";;;
      do:  (let: "$a0" := "args" in
      let: "$a1" := (![go.PointerType applyasfollowerreply_gk.S] "reply") in
      (MethodResolve (go.PointerType Server) "applyAsFollower"%go (![go.PointerType Server] "s")) "$a0" "$a1");;;
      let: "$r0" := (let: "$a0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 0)) in
      let: "$a1" := (![applyasfollowerreply_gk.S] (![go.PointerType applyasfollowerreply_gk.S] "reply")) in
      (FuncResolve applyasfollowerreply_gk.Marshal [] #()) "$a0" "$a1") in
      do:  ((![go.PointerType (go.SliceType go.byte)] "raw_reply") <-[go.SliceType go.byte] "$r0");;;
      return: #())
      ) in
    do:  (map.insert go.uint64 (![go.MapType go.uint64 (go.FunctionType (go.Signature [go.SliceType go.byte; go.PointerType (go.SliceType go.byte)] false []))] "handlers") RPC_APPLY_AS_FOLLOWER "$r0");;;
    let: "$r0" := (λ: "raw_args" "raw_reply",
      exception_do (let: "raw_reply" := (GoAlloc (go.PointerType (go.SliceType go.byte)) "raw_reply") in
      let: "raw_args" := (GoAlloc (go.SliceType go.byte) "raw_args") in
      let: "reply" := (GoAlloc (go.PointerType enternewepochreply_gk.S) (GoZeroVal (go.PointerType enternewepochreply_gk.S) #())) in
      let: "$r0" := (GoAlloc enternewepochreply_gk.S (GoZeroVal enternewepochreply_gk.S #())) in
      do:  ("reply" <-[go.PointerType enternewepochreply_gk.S] "$r0");;;
      let: "args" := (GoAlloc enternewepochargs_gk.S (GoZeroVal enternewepochargs_gk.S #())) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] "raw_args") in
      (FuncResolve enternewepochargs_gk.Unmarshal [] #()) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("args" <-[enternewepochargs_gk.S] "$r0");;;
      do:  "$r1";;;
      do:  (let: "$a0" := "args" in
      let: "$a1" := (![go.PointerType enternewepochreply_gk.S] "reply") in
      (MethodResolve (go.PointerType Server) "enterNewEpoch"%go (![go.PointerType Server] "s")) "$a0" "$a1");;;
      let: "$r0" := (let: "$a0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 0)) in
      let: "$a1" := (![enternewepochreply_gk.S] (![go.PointerType enternewepochreply_gk.S] "reply")) in
      (FuncResolve enternewepochreply_gk.Marshal [] #()) "$a0" "$a1") in
      do:  ((![go.PointerType (go.SliceType go.byte)] "raw_reply") <-[go.SliceType go.byte] "$r0");;;
      return: #())
      ) in
    do:  (map.insert go.uint64 (![go.MapType go.uint64 (go.FunctionType (go.Signature [go.SliceType go.byte; go.PointerType (go.SliceType go.byte)] false []))] "handlers") RPC_ENTER_NEW_EPOCH "$r0");;;
    let: "$r0" := (λ: "raw_args" "raw_reply",
      exception_do (let: "raw_reply" := (GoAlloc (go.PointerType (go.SliceType go.byte)) "raw_reply") in
      let: "raw_args" := (GoAlloc (go.SliceType go.byte) "raw_args") in
      do:  ((MethodResolve (go.PointerType Server) "TryBecomeLeader"%go (![go.PointerType Server] "s")) #());;;
      return: #())
      ) in
    do:  (map.insert go.uint64 (![go.MapType go.uint64 (go.FunctionType (go.Signature [go.SliceType go.byte; go.PointerType (go.SliceType go.byte)] false []))] "handlers") RPC_BECOME_LEADER "$r0");;;
    let: "r" := (GoAlloc (go.PointerType urpc.Server) (GoZeroVal (go.PointerType urpc.Server) #())) in
    let: "$r0" := (let: "$a0" := (![go.MapType go.uint64 (go.FunctionType (go.Signature [go.SliceType go.byte; go.PointerType (go.SliceType go.byte)] false []))] "handlers") in
    (FuncResolve urpc.MakeServer [] #()) "$a0") in
    do:  ("r" <-[go.PointerType urpc.Server] "$r0");;;
    do:  (let: "$a0" := (![grove_ffi.Address] "me") in
    (MethodResolve (go.PointerType urpc.Server) "Serve"%go (![go.PointerType urpc.Server] "r")) "$a0");;;
    return: (![go.PointerType Server] "s")).

#[global] Instance info' : PkgInfo pkg_id.paxos :=
{|
  pkg_imported_pkgs := [code.github_com.mit_pdos.gokv.grove_ffi.pkg_id.grove_ffi; code.github_com.mit_pdos.gokv.reconnectclient.pkg_id.reconnectclient; code.github_com.mit_pdos.gokv.vrsm.paxos.applyasfollowerargs_gk.pkg_id.applyasfollowerargs_gk; code.github_com.mit_pdos.gokv.vrsm.paxos.applyasfollowerreply_gk.pkg_id.applyasfollowerreply_gk; code.github_com.mit_pdos.gokv.vrsm.paxos.enternewepochargs_gk.pkg_id.enternewepochargs_gk; code.github_com.mit_pdos.gokv.vrsm.paxos.enternewepochreply_gk.pkg_id.enternewepochreply_gk; code.github_com.mit_pdos.gokv.vrsm.paxos.error_gk.pkg_id.error_gk; code.log.pkg_id.log; code.sync.pkg_id.sync; code.github_com.goose_lang.std.pkg_id.std; code.github_com.mit_pdos.gokv.asyncfile.pkg_id.asyncfile; code.github_com.mit_pdos.gokv.urpc.pkg_id.urpc; code.github_com.mit_pdos.gokv.vrsm.paxos.paxosstate_gk.pkg_id.paxosstate_gk]
|}.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init pkg_id.paxos (λ: <>,
      exception_do (do:  (paxosstate_gk.initialize' #());;;
      do:  (urpc.initialize' #());;;
      do:  (asyncfile.initialize' #());;;
      do:  (std.initialize' #());;;
      do:  (sync.initialize' #());;;
      do:  (log.initialize' #());;;
      do:  (error_gk.initialize' #());;;
      do:  (enternewepochreply_gk.initialize' #());;;
      do:  (enternewepochargs_gk.initialize' #());;;
      do:  (applyasfollowerreply_gk.initialize' #());;;
      do:  (applyasfollowerargs_gk.initialize' #());;;
      do:  (reconnectclient.initialize' #());;;
      do:  (grove_ffi.initialize' #()))
      ).

Module singleClerk.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  cl' : loc;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End singleClerk.

Definition singleClerk'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "cl"%go (go.PointerType reconnectclient.ReconnectingClient))
].
Program Definition singleClerk'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (singleClerk'fds_unsealed).
Global Instance equals_unfold_singleClerk {ext : ffi_syntax} {go_gctx : GoGlobalContext} : singleClerk'fds =→ singleClerk'fds_unsealed.
Proof. rewrite /singleClerk'fds seal_eq //. Qed.

Definition singleClerkⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (singleClerk'fds).

Class singleClerk_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] singleClerk_type_repr  :: go.TypeReprUnderlying singleClerkⁱᵐᵖˡ singleClerk.t;
  #[global] singleClerk_underlying :: (singleClerk) <u (singleClerkⁱᵐᵖˡ);
  #[global] singleClerk_get_cl (x : singleClerk.t) :: ⟦StructFieldGet (singleClerkⁱᵐᵖˡ) "cl", #x⟧ ⤳[under] #x.(singleClerk.cl');
  #[global] singleClerk_set_cl (x : singleClerk.t) y :: ⟦StructFieldSet (singleClerkⁱᵐᵖˡ) "cl", (#x, #y)⟧ ⤳[under] #(x <|singleClerk.cl' := y|>);
  #[global] singleClerk'ptr_TryBecomeLeader_unfold :: MethodUnfold (go.PointerType (singleClerk)) "TryBecomeLeader" (singleClerk__TryBecomeLeaderⁱᵐᵖˡ);
  #[global] singleClerk'ptr_applyAsFollower_unfold :: MethodUnfold (go.PointerType (singleClerk)) "applyAsFollower" (singleClerk__applyAsFollowerⁱᵐᵖˡ);
  #[global] singleClerk'ptr_enterNewEpoch_unfold :: MethodUnfold (go.PointerType (singleClerk)) "enterNewEpoch" (singleClerk__enterNewEpochⁱᵐᵖˡ);
}.

Module Server.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  mu' : loc;
  ps' : loc;
  storage' : loc;
  clerks' : slice.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End Server.

Definition Server'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "mu"%go (go.PointerType sync.Mutex));
  (go.FieldDecl "ps"%go (go.PointerType paxosstate_gk.S));
  (go.FieldDecl "storage"%go (go.PointerType asyncfile.AsyncFile));
  (go.FieldDecl "clerks"%go (go.SliceType (go.PointerType singleClerk)))
].
Program Definition Server'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (Server'fds_unsealed).
Global Instance equals_unfold_Server {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Server'fds =→ Server'fds_unsealed.
Proof. rewrite /Server'fds seal_eq //. Qed.

Definition Serverⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (Server'fds).

Class Server_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Server_type_repr  :: go.TypeReprUnderlying Serverⁱᵐᵖˡ Server.t;
  #[global] Server_underlying :: (Server) <u (Serverⁱᵐᵖˡ);
  #[global] Server_get_mu (x : Server.t) :: ⟦StructFieldGet (Serverⁱᵐᵖˡ) "mu", #x⟧ ⤳[under] #x.(Server.mu');
  #[global] Server_set_mu (x : Server.t) y :: ⟦StructFieldSet (Serverⁱᵐᵖˡ) "mu", (#x, #y)⟧ ⤳[under] #(x <|Server.mu' := y|>);
  #[global] Server_get_ps (x : Server.t) :: ⟦StructFieldGet (Serverⁱᵐᵖˡ) "ps", #x⟧ ⤳[under] #x.(Server.ps');
  #[global] Server_set_ps (x : Server.t) y :: ⟦StructFieldSet (Serverⁱᵐᵖˡ) "ps", (#x, #y)⟧ ⤳[under] #(x <|Server.ps' := y|>);
  #[global] Server_get_storage (x : Server.t) :: ⟦StructFieldGet (Serverⁱᵐᵖˡ) "storage", #x⟧ ⤳[under] #x.(Server.storage');
  #[global] Server_set_storage (x : Server.t) y :: ⟦StructFieldSet (Serverⁱᵐᵖˡ) "storage", (#x, #y)⟧ ⤳[under] #(x <|Server.storage' := y|>);
  #[global] Server_get_clerks (x : Server.t) :: ⟦StructFieldGet (Serverⁱᵐᵖˡ) "clerks", #x⟧ ⤳[under] #x.(Server.clerks');
  #[global] Server_set_clerks (x : Server.t) y :: ⟦StructFieldSet (Serverⁱᵐᵖˡ) "clerks", (#x, #y)⟧ ⤳[under] #(x <|Server.clerks' := y|>);
  #[global] Server'ptr_TryAcquire_unfold :: MethodUnfold (go.PointerType (Server)) "TryAcquire" (Server__TryAcquireⁱᵐᵖˡ);
  #[global] Server'ptr_TryBecomeLeader_unfold :: MethodUnfold (go.PointerType (Server)) "TryBecomeLeader" (Server__TryBecomeLeaderⁱᵐᵖˡ);
  #[global] Server'ptr_WeakRead_unfold :: MethodUnfold (go.PointerType (Server)) "WeakRead" (Server__WeakReadⁱᵐᵖˡ);
  #[global] Server'ptr_applyAsFollower_unfold :: MethodUnfold (go.PointerType (Server)) "applyAsFollower" (Server__applyAsFollowerⁱᵐᵖˡ);
  #[global] Server'ptr_enterNewEpoch_unfold :: MethodUnfold (go.PointerType (Server)) "enterNewEpoch" (Server__enterNewEpochⁱᵐᵖˡ);
  #[global] Server'ptr_withLock_unfold :: MethodUnfold (go.PointerType (Server)) "withLock" (Server__withLockⁱᵐᵖˡ);
}.

Class Assumptions `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] singleClerk_instance :: singleClerk_Assumptions;
  #[global] Server_instance :: Server_Assumptions;
  #[global] MakeSingleClerk_unfold :: FuncUnfold MakeSingleClerk [] (MakeSingleClerkⁱᵐᵖˡ);
  #[global] makeServer_unfold :: FuncUnfold makeServer [] (makeServerⁱᵐᵖˡ);
  #[global] StartServer_unfold :: FuncUnfold StartServer [] (StartServerⁱᵐᵖˡ);
  #[global] import_grove_ffi_Assumption :: grove_ffi.Assumptions;
  #[global] import_reconnectclient_Assumption :: reconnectclient.Assumptions;
  #[global] import_applyasfollowerargs_gk_Assumption :: applyasfollowerargs_gk.Assumptions;
  #[global] import_applyasfollowerreply_gk_Assumption :: applyasfollowerreply_gk.Assumptions;
  #[global] import_enternewepochargs_gk_Assumption :: enternewepochargs_gk.Assumptions;
  #[global] import_enternewepochreply_gk_Assumption :: enternewepochreply_gk.Assumptions;
  #[global] import_error_gk_Assumption :: error_gk.Assumptions;
  #[global] import_log_Assumption :: log.Assumptions;
  #[global] import_sync_Assumption :: sync.Assumptions;
  #[global] import_std_Assumption :: std.Assumptions;
  #[global] import_asyncfile_Assumption :: asyncfile.Assumptions;
  #[global] import_urpc_Assumption :: urpc.Assumptions;
  #[global] import_paxosstate_gk_Assumption :: paxosstate_gk.Assumptions;
}.
End paxos.
