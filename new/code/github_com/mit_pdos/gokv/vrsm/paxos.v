(* autogenerated from github.com/mit-pdos/gokv/vrsm/paxos *)
Require Export New.code.github_com.goose_lang.std.
Require Export New.code.github_com.mit_pdos.gokv.asyncfile.
Require Export New.code.github_com.mit_pdos.gokv.grove_ffi.
Require Export New.code.github_com.mit_pdos.gokv.reconnectclient.
Require Export New.code.github_com.mit_pdos.gokv.urpc.
Require Export New.code.github_com.mit_pdos.gokv.vrsm.paxos.applyasfollowerargs_gk.
Require Export New.code.github_com.mit_pdos.gokv.vrsm.paxos.applyasfollowerreply_gk.
Require Export New.code.github_com.mit_pdos.gokv.vrsm.paxos.enternewepochargs_gk.
Require Export New.code.github_com.mit_pdos.gokv.vrsm.paxos.enternewepochreply_gk.
Require Export New.code.github_com.mit_pdos.gokv.vrsm.paxos.error_gk.
Require Export New.code.github_com.mit_pdos.gokv.vrsm.paxos.paxosstate_gk.
Require Export New.code.log.
Require Export New.code.sync.

From New.golang Require Import defn.
Definition paxos : go_string := "github.com/mit-pdos/gokv/vrsm/paxos".

From New Require Import grove_prelude.
Module paxos.

Module singleClerk. Definition id : go_string := "github.com/mit-pdos/gokv/vrsm/paxos.singleClerk"%go. End singleClerk.
Module Server. Definition id : go_string := "github.com/mit-pdos/gokv/vrsm/paxos.Server"%go. End Server.

Section code.


Definition RPC_APPLY_AS_FOLLOWER : val := #(W64 0).

Definition RPC_ENTER_NEW_EPOCH : val := #(W64 1).

Definition RPC_BECOME_LEADER : val := #(W64 2).

Definition singleClerk : go_type := structT [
  "cl" :: ptrT
].
#[global] Typeclasses Opaque singleClerk.
#[global] Opaque singleClerk.

Definition MakeSingleClerk : go_string := "github.com/mit-pdos/gokv/vrsm/paxos.MakeSingleClerk"%go.

(* go: internalclerk.go:24:6 *)
Definition MakeSingleClerkⁱᵐᵖˡ : val :=
  λ: "addr",
    exception_do (let: "addr" := (mem.alloc "addr") in
    let: "ck" := (mem.alloc (type.zero_val ptrT)) in
    let: "$r0" := (mem.alloc (let: "$cl" := (let: "$a0" := (![uint64T] "addr") in
    (func_call #reconnectclient.MakeReconnectingClient) "$a0") in
    struct.make singleClerk [{
      "cl" ::= "$cl"
    }])) in
    do:  ("ck" <-[ptrT] "$r0");;;
    return: (![ptrT] "ck")).

(* go: internalclerk.go:33:23 *)
Definition singleClerk__enterNewEpochⁱᵐᵖˡ : val :=
  λ: "s" "args",
    exception_do (let: "s" := (mem.alloc "s") in
    let: "args" := (mem.alloc "args") in
<<<<<<< HEAD
    let: "raw_args" := (mem.alloc (type.zero_val sliceT)) in
    let: "$r0" := (let: "$a0" := (![ptrT] "args") in
    (func_call #encodeEnterNewEpochArgs) "$a0") in
    do:  ("raw_args" <-[sliceT] "$r0");;;
    let: "raw_reply" := (mem.alloc (type.zero_val ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val sliceT)) in
    do:  ("raw_reply" <-[ptrT] "$r0");;;
    let: "err" := (mem.alloc (type.zero_val uint64T)) in
=======
    let: "raw_args" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (slice.make2 #byteT #(W64 0)) in
    let: "$a1" := (![#enternewepochargs_gk.S] (![#ptrT] "args")) in
    (func_call #enternewepochargs_gk.Marshal) "$a0" "$a1") in
    do:  ("raw_args" <-[#sliceT] "$r0");;;
    let: "raw_reply" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #sliceT)) in
    do:  ("raw_reply" <-[#ptrT] "$r0");;;
    let: "err" := (mem.alloc (type.zero_val #uint64T)) in
>>>>>>> master
    let: "$r0" := (let: "$a0" := RPC_ENTER_NEW_EPOCH in
    let: "$a1" := (![sliceT] "raw_args") in
    let: "$a2" := (![ptrT] "raw_reply") in
    let: "$a3" := #(W64 500) in
    (method_call #(ptrT.id reconnectclient.ReconnectingClient.id) #"Call"%go (![ptrT] (struct.field_ref ptrT #"cl"%go (![ptrT] "s")))) "$a0" "$a1" "$a2" "$a3") in
    do:  ("err" <-[uint64T] "$r0");;;
    (if: (![uint64T] "err") = #(W64 0)
    then
<<<<<<< HEAD
      return: (let: "$a0" := (![sliceT] (![ptrT] "raw_reply")) in
       (func_call #decodeEnterNewEpochReply) "$a0")
    else
      return: (mem.alloc (let: "$err" := ETimeout in
       struct.make enterNewEpochReply [{
         "err" ::= "$err";
         "acceptedEpoch" ::= type.zero_val uint64T;
         "nextIndex" ::= type.zero_val uint64T;
         "state" ::= type.zero_val sliceT
=======
      let: "ret" := (mem.alloc (type.zero_val #enternewepochreply_gk.S)) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] (![#ptrT] "raw_reply")) in
      (func_call #enternewepochreply_gk.Unmarshal) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("ret" <-[#enternewepochreply_gk.S] "$r0");;;
      do:  "$r1";;;
      return: ("ret")
    else
      return: (mem.alloc (let: "$Err" := error_gk.ETimeout in
       struct.make #enternewepochreply_gk.S [{
         "Err" ::= "$Err";
         "AcceptedEpoch" ::= type.zero_val #uint64T;
         "NextIndex" ::= type.zero_val #uint64T;
         "State" ::= type.zero_val #sliceT
>>>>>>> master
       }])))).

(* go: internalclerk.go:45:23 *)
Definition singleClerk__applyAsFollowerⁱᵐᵖˡ : val :=
  λ: "s" "args",
    exception_do (let: "s" := (mem.alloc "s") in
    let: "args" := (mem.alloc "args") in
<<<<<<< HEAD
    let: "raw_args" := (mem.alloc (type.zero_val sliceT)) in
    let: "$r0" := (let: "$a0" := (![ptrT] "args") in
    (func_call #encodeApplyAsFollowerArgs) "$a0") in
    do:  ("raw_args" <-[sliceT] "$r0");;;
    let: "raw_reply" := (mem.alloc (type.zero_val ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val sliceT)) in
    do:  ("raw_reply" <-[ptrT] "$r0");;;
    let: "err" := (mem.alloc (type.zero_val uint64T)) in
=======
    let: "raw_args" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (slice.make2 #byteT #(W64 0)) in
    let: "$a1" := (![#applyasfollowerargs_gk.S] (![#ptrT] "args")) in
    (func_call #applyasfollowerargs_gk.Marshal) "$a0" "$a1") in
    do:  ("raw_args" <-[#sliceT] "$r0");;;
    let: "raw_reply" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #sliceT)) in
    do:  ("raw_reply" <-[#ptrT] "$r0");;;
    let: "err" := (mem.alloc (type.zero_val #uint64T)) in
>>>>>>> master
    let: "$r0" := (let: "$a0" := RPC_APPLY_AS_FOLLOWER in
    let: "$a1" := (![sliceT] "raw_args") in
    let: "$a2" := (![ptrT] "raw_reply") in
    let: "$a3" := #(W64 500) in
    (method_call #(ptrT.id reconnectclient.ReconnectingClient.id) #"Call"%go (![ptrT] (struct.field_ref ptrT #"cl"%go (![ptrT] "s")))) "$a0" "$a1" "$a2" "$a3") in
    do:  ("err" <-[uint64T] "$r0");;;
    (if: (![uint64T] "err") = #(W64 0)
    then
<<<<<<< HEAD
      return: (let: "$a0" := (![sliceT] (![ptrT] "raw_reply")) in
       (func_call #decodeApplyAsFollowerReply) "$a0")
    else
      return: (mem.alloc (let: "$err" := ETimeout in
       struct.make applyAsFollowerReply [{
         "err" ::= "$err"
=======
      let: "ret" := (mem.alloc (type.zero_val #applyasfollowerreply_gk.S)) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] (![#ptrT] "raw_reply")) in
      (func_call #applyasfollowerreply_gk.Unmarshal) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("ret" <-[#applyasfollowerreply_gk.S] "$r0");;;
      do:  "$r1";;;
      return: ("ret")
    else
      return: (mem.alloc (let: "$Err" := error_gk.ETimeout in
       struct.make #applyasfollowerreply_gk.S [{
         "Err" ::= "$Err"
>>>>>>> master
       }])))).

(* go: internalclerk.go:57:23 *)
Definition singleClerk__TryBecomeLeaderⁱᵐᵖˡ : val :=
  λ: "s" <>,
    exception_do (let: "s" := (mem.alloc "s") in
    let: "reply" := (mem.alloc (type.zero_val ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val sliceT)) in
    do:  ("reply" <-[ptrT] "$r0");;;
    do:  (let: "$a0" := RPC_BECOME_LEADER in
    let: "$a1" := (slice.make2 byteT #(W64 0)) in
    let: "$a2" := (![ptrT] "reply") in
    let: "$a3" := #(W64 500) in
    (method_call #(ptrT.id reconnectclient.ReconnectingClient.id) #"Call"%go (![ptrT] (struct.field_ref ptrT #"cl"%go (![ptrT] "s")))) "$a0" "$a1" "$a2" "$a3");;;
    return: #()).

<<<<<<< HEAD
Definition ENone : val := #(W64 0).

Definition EEpochStale : val := #(W64 1).

Definition EOutOfOrder : val := #(W64 2).

Definition ENotLeader : val := #(W64 4).

Definition applyAsFollowerArgs : go_type := structT [
  "epoch" :: uint64T;
  "nextIndex" :: uint64T;
  "state" :: sliceT
].
#[global] Typeclasses Opaque applyAsFollowerArgs.
#[global] Opaque applyAsFollowerArgs.

(* go: marshal.go:21:6 *)
Definition encodeApplyAsFollowerArgsⁱᵐᵖˡ : val :=
  λ: "o",
    exception_do (let: "o" := (mem.alloc "o") in
    let: "enc" := (mem.alloc (type.zero_val sliceT)) in
    let: "$r0" := (slice.make3 byteT #(W64 0) (#(W64 (8 + 8)) + (let: "$a0" := (![sliceT] (struct.field_ref ptrT #"state"%go (![ptrT] "o"))) in
    slice.len "$a0"))) in
    do:  ("enc" <-[sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT] "enc") in
    let: "$a1" := (![uint64T] (struct.field_ref ptrT #"epoch"%go (![ptrT] "o"))) in
    (func_call #marshal.WriteInt) "$a0" "$a1") in
    do:  ("enc" <-[sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT] "enc") in
    let: "$a1" := (![uint64T] (struct.field_ref ptrT #"nextIndex"%go (![ptrT] "o"))) in
    (func_call #marshal.WriteInt) "$a0" "$a1") in
    do:  ("enc" <-[sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT] "enc") in
    let: "$a1" := (![sliceT] (struct.field_ref ptrT #"state"%go (![ptrT] "o"))) in
    (func_call #marshal.WriteBytes) "$a0" "$a1") in
    do:  ("enc" <-[sliceT] "$r0");;;
    return: (![sliceT] "enc")).

Definition decodeApplyAsFollowerArgs : go_string := "github.com/mit-pdos/gokv/vrsm/paxos.decodeApplyAsFollowerArgs"%go.

(* go: marshal.go:29:6 *)
Definition decodeApplyAsFollowerArgsⁱᵐᵖˡ : val :=
  λ: "enc",
    exception_do (let: "enc" := (mem.alloc "enc") in
    let: "o" := (mem.alloc (type.zero_val ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val applyAsFollowerArgs)) in
    do:  ("o" <-[ptrT] "$r0");;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![sliceT] "enc") in
    (func_call #marshal.ReadInt) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ((struct.field_ref ptrT #"epoch"%go (![ptrT] "o")) <-[uint64T] "$r0");;;
    do:  ("enc" <-[sliceT] "$r1");;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![sliceT] "enc") in
    (func_call #marshal.ReadInt) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ((struct.field_ref ptrT #"nextIndex"%go (![ptrT] "o")) <-[uint64T] "$r0");;;
    do:  ("enc" <-[sliceT] "$r1");;;
    let: "$r0" := (![sliceT] "enc") in
    do:  ((struct.field_ref ptrT #"state"%go (![ptrT] "o")) <-[sliceT] "$r0");;;
    return: (![ptrT] "o")).

(* go: marshal.go:41:6 *)
Definition decodeApplyAsFollowerReplyⁱᵐᵖˡ : val :=
  λ: "s",
    exception_do (let: "s" := (mem.alloc "s") in
    let: "o" := (mem.alloc (type.zero_val ptrT)) in
    let: "$r0" := (mem.alloc (struct.make applyAsFollowerReply [{
      "err" ::= type.zero_val Error
    }])) in
    do:  ("o" <-[ptrT] "$r0");;;
    let: "err" := (mem.alloc (type.zero_val uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![sliceT] "s") in
    (func_call #marshal.ReadInt) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("err" <-[uint64T] "$r0");;;
    do:  "$r1";;;
    let: "$r0" := (![uint64T] "err") in
    do:  ((struct.field_ref ptrT #"err"%go (![ptrT] "o")) <-[Error] "$r0");;;
    return: (![ptrT] "o")).

Definition encodeApplyAsFollowerReply : go_string := "github.com/mit-pdos/gokv/vrsm/paxos.encodeApplyAsFollowerReply"%go.

(* go: marshal.go:48:6 *)
Definition encodeApplyAsFollowerReplyⁱᵐᵖˡ : val :=
  λ: "o",
    exception_do (let: "o" := (mem.alloc "o") in
    let: "enc" := (mem.alloc (type.zero_val sliceT)) in
    let: "$r0" := (slice.make3 byteT #(W64 0) #(W64 8)) in
    do:  ("enc" <-[sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT] "enc") in
    let: "$a1" := (![Error] (struct.field_ref ptrT #"err"%go (![ptrT] "o"))) in
    (func_call #marshal.WriteInt) "$a0" "$a1") in
    do:  ("enc" <-[sliceT] "$r0");;;
    return: (![sliceT] "enc")).

Definition enterNewEpochArgs : go_type := structT [
  "epoch" :: uint64T
].
#[global] Typeclasses Opaque enterNewEpochArgs.
#[global] Opaque enterNewEpochArgs.

(* go: marshal.go:58:6 *)
Definition encodeEnterNewEpochArgsⁱᵐᵖˡ : val :=
  λ: "o",
    exception_do (let: "o" := (mem.alloc "o") in
    let: "enc" := (mem.alloc (type.zero_val sliceT)) in
    let: "$r0" := (slice.make3 byteT #(W64 0) #(W64 8)) in
    do:  ("enc" <-[sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT] "enc") in
    let: "$a1" := (![uint64T] (struct.field_ref ptrT #"epoch"%go (![ptrT] "o"))) in
    (func_call #marshal.WriteInt) "$a0" "$a1") in
    do:  ("enc" <-[sliceT] "$r0");;;
    return: (![sliceT] "enc")).

Definition decodeEnterNewEpochArgs : go_string := "github.com/mit-pdos/gokv/vrsm/paxos.decodeEnterNewEpochArgs"%go.

(* go: marshal.go:64:6 *)
Definition decodeEnterNewEpochArgsⁱᵐᵖˡ : val :=
  λ: "s",
    exception_do (let: "s" := (mem.alloc "s") in
    let: "o" := (mem.alloc (type.zero_val ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val enterNewEpochArgs)) in
    do:  ("o" <-[ptrT] "$r0");;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![sliceT] "s") in
    (func_call #marshal.ReadInt) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ((struct.field_ref ptrT #"epoch"%go (![ptrT] "o")) <-[uint64T] "$r0");;;
    do:  "$r1";;;
    return: (![ptrT] "o")).

(* go: marshal.go:77:6 *)
Definition decodeEnterNewEpochReplyⁱᵐᵖˡ : val :=
  λ: "enc",
    exception_do (let: "enc" := (mem.alloc "enc") in
    let: "o" := (mem.alloc (type.zero_val ptrT)) in
    let: "$r0" := (mem.alloc (struct.make enterNewEpochReply [{
      "err" ::= type.zero_val Error;
      "acceptedEpoch" ::= type.zero_val uint64T;
      "nextIndex" ::= type.zero_val uint64T;
      "state" ::= type.zero_val sliceT
    }])) in
    do:  ("o" <-[ptrT] "$r0");;;
    let: "err" := (mem.alloc (type.zero_val uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![sliceT] "enc") in
    (func_call #marshal.ReadInt) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("err" <-[uint64T] "$r0");;;
    do:  ("enc" <-[sliceT] "$r1");;;
    let: "$r0" := (![uint64T] "err") in
    do:  ((struct.field_ref ptrT #"err"%go (![ptrT] "o")) <-[Error] "$r0");;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![sliceT] "enc") in
    (func_call #marshal.ReadInt) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ((struct.field_ref ptrT #"acceptedEpoch"%go (![ptrT] "o")) <-[uint64T] "$r0");;;
    do:  ("enc" <-[sliceT] "$r1");;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![sliceT] "enc") in
    (func_call #marshal.ReadInt) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ((struct.field_ref ptrT #"nextIndex"%go (![ptrT] "o")) <-[uint64T] "$r0");;;
    do:  ("enc" <-[sliceT] "$r1");;;
    let: "$r0" := (![sliceT] "enc") in
    do:  ((struct.field_ref ptrT #"state"%go (![ptrT] "o")) <-[sliceT] "$r0");;;
    return: (![ptrT] "o")).

Definition encodeEnterNewEpochReply : go_string := "github.com/mit-pdos/gokv/vrsm/paxos.encodeEnterNewEpochReply"%go.

(* go: marshal.go:89:6 *)
Definition encodeEnterNewEpochReplyⁱᵐᵖˡ : val :=
  λ: "o",
    exception_do (let: "o" := (mem.alloc "o") in
    let: "enc" := (mem.alloc (type.zero_val sliceT)) in
    let: "$r0" := (slice.make3 byteT #(W64 0) (#(W64 ((8 + 8) + 8)) + (s_to_w64 (let: "$a0" := (![sliceT] (struct.field_ref ptrT #"state"%go (![ptrT] "o"))) in
    slice.len "$a0")))) in
    do:  ("enc" <-[sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT] "enc") in
    let: "$a1" := (![Error] (struct.field_ref ptrT #"err"%go (![ptrT] "o"))) in
    (func_call #marshal.WriteInt) "$a0" "$a1") in
    do:  ("enc" <-[sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT] "enc") in
    let: "$a1" := (![uint64T] (struct.field_ref ptrT #"acceptedEpoch"%go (![ptrT] "o"))) in
    (func_call #marshal.WriteInt) "$a0" "$a1") in
    do:  ("enc" <-[sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT] "enc") in
    let: "$a1" := (![uint64T] (struct.field_ref ptrT #"nextIndex"%go (![ptrT] "o"))) in
    (func_call #marshal.WriteInt) "$a0" "$a1") in
    do:  ("enc" <-[sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT] "enc") in
    let: "$a1" := (![sliceT] (struct.field_ref ptrT #"state"%go (![ptrT] "o"))) in
    (func_call #marshal.WriteBytes) "$a0" "$a1") in
    do:  ("enc" <-[sliceT] "$r0");;;
    return: (![sliceT] "enc")).

Definition applyReply : go_type := structT [
  "err" :: Error;
  "ret" :: sliceT
].
#[global] Typeclasses Opaque applyReply.
#[global] Opaque applyReply.

Definition encodeApplyReply : go_string := "github.com/mit-pdos/gokv/vrsm/paxos.encodeApplyReply"%go.

(* go: marshal.go:103:6 *)
Definition encodeApplyReplyⁱᵐᵖˡ : val :=
  λ: "o",
    exception_do (let: "o" := (mem.alloc "o") in
    let: "enc" := (mem.alloc (type.zero_val sliceT)) in
    let: "$r0" := (slice.make3 byteT #(W64 0) (#(W64 8) + (s_to_w64 (let: "$a0" := (![sliceT] (struct.field_ref ptrT #"ret"%go (![ptrT] "o"))) in
    slice.len "$a0")))) in
    do:  ("enc" <-[sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT] "enc") in
    let: "$a1" := (![Error] (struct.field_ref ptrT #"err"%go (![ptrT] "o"))) in
    (func_call #marshal.WriteInt) "$a0" "$a1") in
    do:  ("enc" <-[sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT] "enc") in
    let: "$a1" := (![sliceT] (struct.field_ref ptrT #"ret"%go (![ptrT] "o"))) in
    (func_call #marshal.WriteBytes) "$a0" "$a1") in
    do:  ("enc" <-[sliceT] "$r0");;;
    return: (![sliceT] "enc")).

Definition decodeApplyReply : go_string := "github.com/mit-pdos/gokv/vrsm/paxos.decodeApplyReply"%go.

(* go: marshal.go:110:6 *)
Definition decodeApplyReplyⁱᵐᵖˡ : val :=
  λ: "enc",
    exception_do (let: "enc" := (mem.alloc "enc") in
    let: "o" := (mem.alloc (type.zero_val ptrT)) in
    let: "$r0" := (mem.alloc (struct.make applyReply [{
      "err" ::= type.zero_val Error;
      "ret" ::= type.zero_val sliceT
    }])) in
    do:  ("o" <-[ptrT] "$r0");;;
    let: "err" := (mem.alloc (type.zero_val uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![sliceT] "enc") in
    (func_call #marshal.ReadInt) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("err" <-[uint64T] "$r0");;;
    do:  ("enc" <-[sliceT] "$r1");;;
    let: "$r0" := (![uint64T] "err") in
    do:  ((struct.field_ref ptrT #"err"%go (![ptrT] "o")) <-[Error] "$r0");;;
    let: "$r0" := (![sliceT] "enc") in
    do:  ((struct.field_ref ptrT #"ret"%go (![ptrT] "o")) <-[sliceT] "$r0");;;
    return: (![ptrT] "o")).

Definition boolToU64 : go_string := "github.com/mit-pdos/gokv/vrsm/paxos.boolToU64"%go.

(* go: marshal.go:120:6 *)
Definition boolToU64ⁱᵐᵖˡ : val :=
  λ: "b",
    exception_do (let: "b" := (mem.alloc "b") in
    (if: ![boolT] "b"
    then return: (#(W64 1))
    else return: (#(W64 0)))).

Definition encodePaxosState : go_string := "github.com/mit-pdos/gokv/vrsm/paxos.encodePaxosState"%go.

(* go: marshal.go:128:6 *)
Definition encodePaxosStateⁱᵐᵖˡ : val :=
  λ: "ps",
    exception_do (let: "ps" := (mem.alloc "ps") in
    let: "e" := (mem.alloc (type.zero_val sliceT)) in
    let: "$r0" := (slice.make2 byteT #(W64 0)) in
    do:  ("e" <-[sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT] "e") in
    let: "$a1" := (![uint64T] (struct.field_ref ptrT #"epoch"%go (![ptrT] "ps"))) in
    (func_call #marshal.WriteInt) "$a0" "$a1") in
    do:  ("e" <-[sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT] "e") in
    let: "$a1" := (![uint64T] (struct.field_ref ptrT #"acceptedEpoch"%go (![ptrT] "ps"))) in
    (func_call #marshal.WriteInt) "$a0" "$a1") in
    do:  ("e" <-[sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT] "e") in
    let: "$a1" := (![uint64T] (struct.field_ref ptrT #"nextIndex"%go (![ptrT] "ps"))) in
    (func_call #marshal.WriteInt) "$a0" "$a1") in
    do:  ("e" <-[sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT] "e") in
    let: "$a1" := (let: "$a0" := (![boolT] (struct.field_ref ptrT #"isLeader"%go (![ptrT] "ps"))) in
    (func_call #boolToU64) "$a0") in
    (func_call #marshal.WriteInt) "$a0" "$a1") in
    do:  ("e" <-[sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT] "e") in
    let: "$a1" := (![sliceT] (struct.field_ref ptrT #"state"%go (![ptrT] "ps"))) in
    (func_call #marshal.WriteBytes) "$a0" "$a1") in
    do:  ("e" <-[sliceT] "$r0");;;
    return: (![sliceT] "e")).

Definition decodePaxosState : go_string := "github.com/mit-pdos/gokv/vrsm/paxos.decodePaxosState"%go.

Definition paxosState : go_type := structT [
  "epoch" :: uint64T;
  "acceptedEpoch" :: uint64T;
  "nextIndex" :: uint64T;
  "state" :: sliceT;
  "isLeader" :: boolT
].
#[global] Typeclasses Opaque paxosState.
#[global] Opaque paxosState.

(* go: marshal.go:138:6 *)
Definition decodePaxosStateⁱᵐᵖˡ : val :=
  λ: "enc",
    exception_do (let: "enc" := (mem.alloc "enc") in
    let: "e" := (mem.alloc (type.zero_val sliceT)) in
    let: "$r0" := (![sliceT] "enc") in
    do:  ("e" <-[sliceT] "$r0");;;
    let: "leaderInt" := (mem.alloc (type.zero_val uint64T)) in
    let: "ps" := (mem.alloc (type.zero_val ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val paxosState)) in
    do:  ("ps" <-[ptrT] "$r0");;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![sliceT] "e") in
    (func_call #marshal.ReadInt) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ((struct.field_ref ptrT #"epoch"%go (![ptrT] "ps")) <-[uint64T] "$r0");;;
    do:  ("e" <-[sliceT] "$r1");;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![sliceT] "e") in
    (func_call #marshal.ReadInt) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ((struct.field_ref ptrT #"acceptedEpoch"%go (![ptrT] "ps")) <-[uint64T] "$r0");;;
    do:  ("e" <-[sliceT] "$r1");;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![sliceT] "e") in
    (func_call #marshal.ReadInt) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ((struct.field_ref ptrT #"nextIndex"%go (![ptrT] "ps")) <-[uint64T] "$r0");;;
    do:  ("e" <-[sliceT] "$r1");;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![sliceT] "e") in
    (func_call #marshal.ReadInt) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("leaderInt" <-[uint64T] "$r0");;;
    do:  ((struct.field_ref ptrT #"state"%go (![ptrT] "ps")) <-[sliceT] "$r1");;;
    let: "$r0" := ((![uint64T] "leaderInt") = #(W64 1)) in
    do:  ((struct.field_ref ptrT #"isLeader"%go (![ptrT] "ps")) <-[boolT] "$r0");;;
    return: (![ptrT] "ps")).

=======
>>>>>>> master
Definition Server : go_type := structT [
  "mu" :: ptrT;
  "ps" :: ptrT;
  "storage" :: ptrT;
  "clerks" :: sliceT
].
#[global] Typeclasses Opaque Server.
#[global] Opaque Server.

(* go: server.go:26:18 *)
Definition Server__withLockⁱᵐᵖˡ : val :=
  λ: "s" "f",
    exception_do (let: "s" := (mem.alloc "s") in
    let: "f" := (mem.alloc "f") in
<<<<<<< HEAD
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![ptrT] (struct.field_ref ptrT #"mu"%go (![ptrT] "s")))) #());;;
    do:  (let: "$a0" := (![ptrT] (struct.field_ref ptrT #"ps"%go (![ptrT] "s"))) in
    (![funcT] "f") "$a0");;;
    let: "waitFn" := (mem.alloc (type.zero_val funcT)) in
    let: "$r0" := (let: "$a0" := (let: "$a0" := (![ptrT] (struct.field_ref ptrT #"ps"%go (![ptrT] "s"))) in
    (func_call #encodePaxosState) "$a0") in
    (method_call #(ptrT.id asyncfile.AsyncFile.id) #"Write"%go (![ptrT] (struct.field_ref ptrT #"storage"%go (![ptrT] "s")))) "$a0") in
    do:  ("waitFn" <-[funcT] "$r0");;;
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![ptrT] (struct.field_ref ptrT #"mu"%go (![ptrT] "s")))) #());;;
    do:  ((![funcT] "waitFn") #());;;
=======
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #());;;
    do:  (let: "$a0" := (![#ptrT] (struct.field_ref #Server #"ps"%go (![#ptrT] "s"))) in
    (![#funcT] "f") "$a0");;;
    let: "waitFn" := (mem.alloc (type.zero_val #funcT)) in
    let: "$r0" := (let: "$a0" := (let: "$a0" := (slice.make2 #byteT #(W64 0)) in
    let: "$a1" := (![#paxosstate_gk.S] (![#ptrT] (struct.field_ref #Server #"ps"%go (![#ptrT] "s")))) in
    (func_call #paxosstate_gk.Marshal) "$a0" "$a1") in
    (method_call #(ptrT.id asyncfile.AsyncFile.id) #"Write"%go (![#ptrT] (struct.field_ref #Server #"storage"%go (![#ptrT] "s")))) "$a0") in
    do:  ("waitFn" <-[#funcT] "$r0");;;
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #());;;
    do:  ((![#funcT] "waitFn") #());;;
>>>>>>> master
    return: #()).

(* go: server.go:34:18 *)
Definition Server__applyAsFollowerⁱᵐᵖˡ : val :=
  λ: "s" "args" "reply",
    exception_do (let: "s" := (mem.alloc "s") in
    let: "reply" := (mem.alloc "reply") in
    let: "args" := (mem.alloc "args") in
    do:  (let: "$a0" := (λ: "ps",
      exception_do (let: "ps" := (mem.alloc "ps") in
<<<<<<< HEAD
      (if: (![uint64T] (struct.field_ref ptrT #"epoch"%go (![ptrT] "ps"))) ≤ (![uint64T] (struct.field_ref ptrT #"epoch"%go (![ptrT] "args")))
      then
        (if: (![uint64T] (struct.field_ref ptrT #"acceptedEpoch"%go (![ptrT] "ps"))) = (![uint64T] (struct.field_ref ptrT #"epoch"%go (![ptrT] "args")))
        then
          (if: (![uint64T] (struct.field_ref ptrT #"nextIndex"%go (![ptrT] "ps"))) < (![uint64T] (struct.field_ref ptrT #"nextIndex"%go (![ptrT] "args")))
          then
            let: "$r0" := (![uint64T] (struct.field_ref ptrT #"nextIndex"%go (![ptrT] "args"))) in
            do:  ((struct.field_ref ptrT #"nextIndex"%go (![ptrT] "ps")) <-[uint64T] "$r0");;;
            let: "$r0" := (![sliceT] (struct.field_ref ptrT #"state"%go (![ptrT] "args"))) in
            do:  ((struct.field_ref ptrT #"state"%go (![ptrT] "ps")) <-[sliceT] "$r0");;;
            let: "$r0" := ENone in
            do:  ((struct.field_ref ptrT #"err"%go (![ptrT] "reply")) <-[Error] "$r0")
          else
            let: "$r0" := ENone in
            do:  ((struct.field_ref ptrT #"err"%go (![ptrT] "reply")) <-[Error] "$r0"))
        else
          let: "$r0" := (![uint64T] (struct.field_ref ptrT #"epoch"%go (![ptrT] "args"))) in
          do:  ((struct.field_ref ptrT #"acceptedEpoch"%go (![ptrT] "ps")) <-[uint64T] "$r0");;;
          let: "$r0" := (![uint64T] (struct.field_ref ptrT #"epoch"%go (![ptrT] "args"))) in
          do:  ((struct.field_ref ptrT #"epoch"%go (![ptrT] "ps")) <-[uint64T] "$r0");;;
          let: "$r0" := (![sliceT] (struct.field_ref ptrT #"state"%go (![ptrT] "args"))) in
          do:  ((struct.field_ref ptrT #"state"%go (![ptrT] "ps")) <-[sliceT] "$r0");;;
          let: "$r0" := (![uint64T] (struct.field_ref ptrT #"nextIndex"%go (![ptrT] "args"))) in
          do:  ((struct.field_ref ptrT #"nextIndex"%go (![ptrT] "ps")) <-[uint64T] "$r0");;;
          let: "$r0" := #false in
          do:  ((struct.field_ref ptrT #"isLeader"%go (![ptrT] "ps")) <-[boolT] "$r0");;;
          let: "$r0" := ENone in
          do:  ((struct.field_ref ptrT #"err"%go (![ptrT] "reply")) <-[Error] "$r0"))
      else
        let: "$r0" := EEpochStale in
        do:  ((struct.field_ref ptrT #"err"%go (![ptrT] "reply")) <-[Error] "$r0"));;;
=======
      (if: (![#uint64T] (struct.field_ref #paxosstate_gk.S #"Epoch"%go (![#ptrT] "ps"))) ≤ (![#uint64T] (struct.field_ref #applyasfollowerargs_gk.S #"Epoch"%go (![#ptrT] "args")))
      then
        (if: (![#uint64T] (struct.field_ref #paxosstate_gk.S #"AcceptedEpoch"%go (![#ptrT] "ps"))) = (![#uint64T] (struct.field_ref #applyasfollowerargs_gk.S #"Epoch"%go (![#ptrT] "args")))
        then
          (if: (![#uint64T] (struct.field_ref #paxosstate_gk.S #"NextIndex"%go (![#ptrT] "ps"))) < (![#uint64T] (struct.field_ref #applyasfollowerargs_gk.S #"NextIndex"%go (![#ptrT] "args")))
          then
            let: "$r0" := (![#uint64T] (struct.field_ref #applyasfollowerargs_gk.S #"NextIndex"%go (![#ptrT] "args"))) in
            do:  ((struct.field_ref #paxosstate_gk.S #"NextIndex"%go (![#ptrT] "ps")) <-[#uint64T] "$r0");;;
            let: "$r0" := (![#sliceT] (struct.field_ref #applyasfollowerargs_gk.S #"State"%go (![#ptrT] "args"))) in
            do:  ((struct.field_ref #paxosstate_gk.S #"State"%go (![#ptrT] "ps")) <-[#sliceT] "$r0");;;
            let: "$r0" := error_gk.ENone in
            do:  ((struct.field_ref #applyasfollowerreply_gk.S #"Err"%go (![#ptrT] "reply")) <-[#error_gk.E] "$r0")
          else
            let: "$r0" := error_gk.ENone in
            do:  ((struct.field_ref #applyasfollowerreply_gk.S #"Err"%go (![#ptrT] "reply")) <-[#error_gk.E] "$r0"))
        else
          let: "$r0" := (![#uint64T] (struct.field_ref #applyasfollowerargs_gk.S #"Epoch"%go (![#ptrT] "args"))) in
          do:  ((struct.field_ref #paxosstate_gk.S #"AcceptedEpoch"%go (![#ptrT] "ps")) <-[#uint64T] "$r0");;;
          let: "$r0" := (![#uint64T] (struct.field_ref #applyasfollowerargs_gk.S #"Epoch"%go (![#ptrT] "args"))) in
          do:  ((struct.field_ref #paxosstate_gk.S #"Epoch"%go (![#ptrT] "ps")) <-[#uint64T] "$r0");;;
          let: "$r0" := (![#sliceT] (struct.field_ref #applyasfollowerargs_gk.S #"State"%go (![#ptrT] "args"))) in
          do:  ((struct.field_ref #paxosstate_gk.S #"State"%go (![#ptrT] "ps")) <-[#sliceT] "$r0");;;
          let: "$r0" := (![#uint64T] (struct.field_ref #applyasfollowerargs_gk.S #"NextIndex"%go (![#ptrT] "args"))) in
          do:  ((struct.field_ref #paxosstate_gk.S #"NextIndex"%go (![#ptrT] "ps")) <-[#uint64T] "$r0");;;
          let: "$r0" := #false in
          do:  ((struct.field_ref #paxosstate_gk.S #"IsLeader"%go (![#ptrT] "ps")) <-[#boolT] "$r0");;;
          let: "$r0" := error_gk.ENone in
          do:  ((struct.field_ref #applyasfollowerreply_gk.S #"Err"%go (![#ptrT] "reply")) <-[#error_gk.E] "$r0"))
      else
        let: "$r0" := error_gk.EEpochStale in
        do:  ((struct.field_ref #applyasfollowerreply_gk.S #"Err"%go (![#ptrT] "reply")) <-[#error_gk.E] "$r0"));;;
>>>>>>> master
      return: #())
      ) in
    (method_call #(ptrT.id Server.id) #"withLock"%go (![ptrT] "s")) "$a0");;;
    return: #()).

(* NOTE:
   This will vote yes only the first time it's called in an epoch.
   If you have too aggressive of a timeout and end up retrying this, the retry
   might fail because it may be the second execution of enterNewEpoch(epoch) on
   the server.
   Solution: either conservative (maybe double) timeouts, or don't use this for
   leader election, only for coming up with a valid proposal.

   go: server.go:66:18 *)
Definition Server__enterNewEpochⁱᵐᵖˡ : val :=
  λ: "s" "args" "reply",
    exception_do (let: "s" := (mem.alloc "s") in
    let: "reply" := (mem.alloc "reply") in
    let: "args" := (mem.alloc "args") in
    do:  (let: "$a0" := (λ: "ps",
      exception_do (let: "ps" := (mem.alloc "ps") in
<<<<<<< HEAD
      (if: (![uint64T] (struct.field_ref ptrT #"epoch"%go (![ptrT] "ps"))) ≥ (![uint64T] (struct.field_ref ptrT #"epoch"%go (![ptrT] "args")))
      then
        let: "$r0" := EEpochStale in
        do:  ((struct.field_ref ptrT #"err"%go (![ptrT] "reply")) <-[Error] "$r0");;;
        return: (#())
      else do:  #());;;
      let: "$r0" := #false in
      do:  ((struct.field_ref ptrT #"isLeader"%go (![ptrT] "ps")) <-[boolT] "$r0");;;
      let: "$r0" := (![uint64T] (struct.field_ref ptrT #"epoch"%go (![ptrT] "args"))) in
      do:  ((struct.field_ref ptrT #"epoch"%go (![ptrT] "ps")) <-[uint64T] "$r0");;;
      let: "$r0" := (![uint64T] (struct.field_ref ptrT #"acceptedEpoch"%go (![ptrT] "ps"))) in
      do:  ((struct.field_ref ptrT #"acceptedEpoch"%go (![ptrT] "reply")) <-[uint64T] "$r0");;;
      let: "$r0" := (![uint64T] (struct.field_ref ptrT #"nextIndex"%go (![ptrT] "ps"))) in
      do:  ((struct.field_ref ptrT #"nextIndex"%go (![ptrT] "reply")) <-[uint64T] "$r0");;;
      let: "$r0" := (![sliceT] (struct.field_ref ptrT #"state"%go (![ptrT] "ps"))) in
      do:  ((struct.field_ref ptrT #"state"%go (![ptrT] "reply")) <-[sliceT] "$r0");;;
=======
      (if: (![#uint64T] (struct.field_ref #paxosstate_gk.S #"Epoch"%go (![#ptrT] "ps"))) ≥ (![#uint64T] (struct.field_ref #enternewepochargs_gk.S #"Epoch"%go (![#ptrT] "args")))
      then
        let: "$r0" := error_gk.EEpochStale in
        do:  ((struct.field_ref #enternewepochreply_gk.S #"Err"%go (![#ptrT] "reply")) <-[#error_gk.E] "$r0");;;
        return: (#())
      else do:  #());;;
      let: "$r0" := #false in
      do:  ((struct.field_ref #paxosstate_gk.S #"IsLeader"%go (![#ptrT] "ps")) <-[#boolT] "$r0");;;
      let: "$r0" := (![#uint64T] (struct.field_ref #enternewepochargs_gk.S #"Epoch"%go (![#ptrT] "args"))) in
      do:  ((struct.field_ref #paxosstate_gk.S #"Epoch"%go (![#ptrT] "ps")) <-[#uint64T] "$r0");;;
      let: "$r0" := (![#uint64T] (struct.field_ref #paxosstate_gk.S #"AcceptedEpoch"%go (![#ptrT] "ps"))) in
      do:  ((struct.field_ref #enternewepochreply_gk.S #"AcceptedEpoch"%go (![#ptrT] "reply")) <-[#uint64T] "$r0");;;
      let: "$r0" := (![#uint64T] (struct.field_ref #paxosstate_gk.S #"NextIndex"%go (![#ptrT] "ps"))) in
      do:  ((struct.field_ref #enternewepochreply_gk.S #"NextIndex"%go (![#ptrT] "reply")) <-[#uint64T] "$r0");;;
      let: "$r0" := (![#sliceT] (struct.field_ref #paxosstate_gk.S #"State"%go (![#ptrT] "ps"))) in
      do:  ((struct.field_ref #enternewepochreply_gk.S #"State"%go (![#ptrT] "reply")) <-[#sliceT] "$r0");;;
>>>>>>> master
      return: #())
      ) in
    (method_call #(ptrT.id Server.id) #"withLock"%go (![ptrT] "s")) "$a0");;;
    return: #()).

(* go: server.go:81:18 *)
Definition Server__TryBecomeLeaderⁱᵐᵖˡ : val :=
  λ: "s" <>,
    exception_do (let: "s" := (mem.alloc "s") in
    do:  (let: "$a0" := ((let: "$sl0" := (interface.make #stringT.id #"started trybecomeleader"%go) in
    slice.literal interfaceT ["$sl0"])) in
    (func_call #log.Println) "$a0");;;
<<<<<<< HEAD
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![ptrT] (struct.field_ref ptrT #"mu"%go (![ptrT] "s")))) #());;;
    (if: ![boolT] (struct.field_ref ptrT #"isLeader"%go (![ptrT] (struct.field_ref ptrT #"ps"%go (![ptrT] "s"))))
=======
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #());;;
    (if: ![#boolT] (struct.field_ref #paxosstate_gk.S #"IsLeader"%go (![#ptrT] (struct.field_ref #Server #"ps"%go (![#ptrT] "s"))))
>>>>>>> master
    then
      do:  (let: "$a0" := ((let: "$sl0" := (interface.make #stringT.id #"already leader"%go) in
      slice.literal interfaceT ["$sl0"])) in
      (func_call #log.Println) "$a0");;;
      do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![ptrT] (struct.field_ref ptrT #"mu"%go (![ptrT] "s")))) #());;;
      return: (#())
    else do:  #());;;
<<<<<<< HEAD
    let: "clerks" := (mem.alloc (type.zero_val sliceT)) in
    let: "$r0" := (![sliceT] (struct.field_ref ptrT #"clerks"%go (![ptrT] "s"))) in
    do:  ("clerks" <-[sliceT] "$r0");;;
    let: "args" := (mem.alloc (type.zero_val ptrT)) in
    let: "$r0" := (mem.alloc (let: "$epoch" := ((![uint64T] (struct.field_ref ptrT #"epoch"%go (![ptrT] (struct.field_ref ptrT #"ps"%go (![ptrT] "s"))))) + #(W64 1)) in
    struct.make enterNewEpochArgs [{
      "epoch" ::= "$epoch"
=======
    let: "clerks" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] (struct.field_ref #Server #"clerks"%go (![#ptrT] "s"))) in
    do:  ("clerks" <-[#sliceT] "$r0");;;
    let: "args" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (let: "$Epoch" := ((![#uint64T] (struct.field_ref #paxosstate_gk.S #"Epoch"%go (![#ptrT] (struct.field_ref #Server #"ps"%go (![#ptrT] "s"))))) + #(W64 1)) in
    struct.make #enternewepochargs_gk.S [{
      "Epoch" ::= "$Epoch"
>>>>>>> master
    }])) in
    do:  ("args" <-[ptrT] "$r0");;;
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![ptrT] (struct.field_ref ptrT #"mu"%go (![ptrT] "s")))) #());;;
    let: "numReplies" := (mem.alloc (type.zero_val uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("numReplies" <-[uint64T] "$r0");;;
    let: "replies" := (mem.alloc (type.zero_val sliceT)) in
    let: "$r0" := (slice.make2 ptrT (s_to_w64 (let: "$a0" := (![sliceT] "clerks") in
    slice.len "$a0"))) in
    do:  ("replies" <-[sliceT] "$r0");;;
    let: "mu" := (mem.alloc (type.zero_val ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val sync.Mutex)) in
    do:  ("mu" <-[ptrT] "$r0");;;
    let: "numReplies_cond" := (mem.alloc (type.zero_val ptrT)) in
    let: "$r0" := (let: "$a0" := (interface.make #(ptrT.id sync.Mutex.id) (![ptrT] "mu")) in
    (func_call #sync.NewCond) "$a0") in
    do:  ("numReplies_cond" <-[ptrT] "$r0");;;
    let: "n" := (mem.alloc (type.zero_val uint64T)) in
    let: "$r0" := (s_to_w64 (let: "$a0" := (![sliceT] "clerks") in
    slice.len "$a0")) in
    do:  ("n" <-[uint64T] "$r0");;;
    let: "$range" := (![sliceT] "clerks") in
    (let: "ck" := (mem.alloc (type.zero_val ptrT)) in
    let: "i" := (mem.alloc (type.zero_val intT)) in
    slice.for_range ptrT "$range" (λ: "$key" "$value",
      do:  ("ck" <-[ptrT] "$value");;;
      do:  ("i" <-[intT] "$key");;;
      let: "$go" := (λ: <>,
        exception_do (let: "reply" := (mem.alloc (type.zero_val ptrT)) in
        let: "$r0" := (let: "$a0" := (![ptrT] "args") in
        (method_call #(ptrT.id singleClerk.id) #"enterNewEpoch"%go (![ptrT] "ck")) "$a0") in
        do:  ("reply" <-[ptrT] "$r0");;;
        do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![ptrT] "mu")) #());;;
        do:  ("numReplies" <-[uint64T] ((![uint64T] "numReplies") + #(W64 1)));;;
        let: "$r0" := (![ptrT] "reply") in
        do:  ((slice.elem_ref ptrT (![sliceT] "replies") (![intT] "i")) <-[ptrT] "$r0");;;
        (if: (#(W64 2) * (![uint64T] "numReplies")) > (![uint64T] "n")
        then do:  ((method_call #(ptrT.id sync.Cond.id) #"Signal"%go (![ptrT] "numReplies_cond")) #())
        else do:  #());;;
        do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![ptrT] "mu")) #());;;
        return: #())
        ) in
      do:  (Fork ("$go" #()))));;;
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![ptrT] "mu")) #());;;
    (for: (λ: <>, (#(W64 2) * (![uint64T] "numReplies")) ≤ (![uint64T] "n")); (λ: <>, #()) := λ: <>,
      do:  ((method_call #(ptrT.id sync.Cond.id) #"Wait"%go (![ptrT] "numReplies_cond")) #()));;;
    let: "latestReply" := (mem.alloc (type.zero_val ptrT)) in
    let: "numSuccesses" := (mem.alloc (type.zero_val uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("numSuccesses" <-[uint64T] "$r0");;;
    let: "$range" := (![sliceT] "replies") in
    (let: "reply" := (mem.alloc (type.zero_val ptrT)) in
    slice.for_range ptrT "$range" (λ: "$key" "$value",
      do:  ("reply" <-[ptrT] "$value");;;
      do:  "$key";;;
      (if: (![ptrT] "reply") ≠ #null
      then
<<<<<<< HEAD
        (if: (![Error] (struct.field_ref ptrT #"err"%go (![ptrT] "reply"))) = ENone
=======
        (if: (![#error_gk.E] (struct.field_ref #enternewepochreply_gk.S #"Err"%go (![#ptrT] "reply"))) = error_gk.ENone
>>>>>>> master
        then
          (if: (![uint64T] "numSuccesses") = #(W64 0)
          then
            let: "$r0" := (![ptrT] "reply") in
            do:  ("latestReply" <-[ptrT] "$r0")
          else
<<<<<<< HEAD
            (if: (![uint64T] (struct.field_ref ptrT #"acceptedEpoch"%go (![ptrT] "latestReply"))) < (![uint64T] (struct.field_ref ptrT #"acceptedEpoch"%go (![ptrT] "reply")))
=======
            (if: (![#uint64T] (struct.field_ref #enternewepochreply_gk.S #"AcceptedEpoch"%go (![#ptrT] "latestReply"))) < (![#uint64T] (struct.field_ref #enternewepochreply_gk.S #"AcceptedEpoch"%go (![#ptrT] "reply")))
>>>>>>> master
            then
              let: "$r0" := (![ptrT] "reply") in
              do:  ("latestReply" <-[ptrT] "$r0")
            else
<<<<<<< HEAD
              (if: ((![uint64T] (struct.field_ref ptrT #"acceptedEpoch"%go (![ptrT] "latestReply"))) = (![uint64T] (struct.field_ref ptrT #"acceptedEpoch"%go (![ptrT] "reply")))) && ((![uint64T] (struct.field_ref ptrT #"nextIndex"%go (![ptrT] "reply"))) > (![uint64T] (struct.field_ref ptrT #"nextIndex"%go (![ptrT] "latestReply"))))
=======
              (if: ((![#uint64T] (struct.field_ref #enternewepochreply_gk.S #"AcceptedEpoch"%go (![#ptrT] "latestReply"))) = (![#uint64T] (struct.field_ref #enternewepochreply_gk.S #"AcceptedEpoch"%go (![#ptrT] "reply")))) && ((![#uint64T] (struct.field_ref #enternewepochreply_gk.S #"NextIndex"%go (![#ptrT] "reply"))) > (![#uint64T] (struct.field_ref #enternewepochreply_gk.S #"NextIndex"%go (![#ptrT] "latestReply"))))
>>>>>>> master
              then
                let: "$r0" := (![ptrT] "reply") in
                do:  ("latestReply" <-[ptrT] "$r0")
              else do:  #())));;;
          do:  ("numSuccesses" <-[uint64T] ((![uint64T] "numSuccesses") + #(W64 1)))
        else do:  #())
      else do:  #())));;;
    (if: (#(W64 2) * (![uint64T] "numSuccesses")) > (![uint64T] "n")
    then
      do:  (let: "$a0" := (λ: "ps",
        exception_do (let: "ps" := (mem.alloc "ps") in
<<<<<<< HEAD
        (if: (![uint64T] (struct.field_ref ptrT #"epoch"%go (![ptrT] "ps"))) ≤ (![uint64T] (struct.field_ref ptrT #"epoch"%go (![ptrT] "args")))
        then
          do:  (let: "$a0" := #"succeeded becomeleader in epoch %d
          "%go in
          let: "$a1" := ((let: "$sl0" := (interface.make #uint64T.id (![uint64T] (struct.field_ref ptrT #"epoch"%go (![ptrT] "args")))) in
          slice.literal interfaceT ["$sl0"])) in
          (func_call #log.Printf) "$a0" "$a1");;;
          let: "$r0" := (![uint64T] (struct.field_ref ptrT #"epoch"%go (![ptrT] "args"))) in
          do:  ((struct.field_ref ptrT #"epoch"%go (![ptrT] "ps")) <-[uint64T] "$r0");;;
          let: "$r0" := #true in
          do:  ((struct.field_ref ptrT #"isLeader"%go (![ptrT] "ps")) <-[boolT] "$r0");;;
          let: "$r0" := (![uint64T] (struct.field_ref ptrT #"epoch"%go (![ptrT] "ps"))) in
          do:  ((struct.field_ref ptrT #"acceptedEpoch"%go (![ptrT] "ps")) <-[uint64T] "$r0");;;
          let: "$r0" := (![uint64T] (struct.field_ref ptrT #"nextIndex"%go (![ptrT] "latestReply"))) in
          do:  ((struct.field_ref ptrT #"nextIndex"%go (![ptrT] "ps")) <-[uint64T] "$r0");;;
          let: "$r0" := (![sliceT] (struct.field_ref ptrT #"state"%go (![ptrT] "latestReply"))) in
          do:  ((struct.field_ref ptrT #"state"%go (![ptrT] "ps")) <-[sliceT] "$r0")
=======
        (if: (![#uint64T] (struct.field_ref #paxosstate_gk.S #"Epoch"%go (![#ptrT] "ps"))) ≤ (![#uint64T] (struct.field_ref #enternewepochargs_gk.S #"Epoch"%go (![#ptrT] "args")))
        then
          do:  (let: "$a0" := #"succeeded becomeleader in epoch %d
          "%go in
          let: "$a1" := ((let: "$sl0" := (interface.make #uint64T.id (![#uint64T] (struct.field_ref #enternewepochargs_gk.S #"Epoch"%go (![#ptrT] "args")))) in
          slice.literal #interfaceT ["$sl0"])) in
          (func_call #log.Printf) "$a0" "$a1");;;
          let: "$r0" := (![#uint64T] (struct.field_ref #enternewepochargs_gk.S #"Epoch"%go (![#ptrT] "args"))) in
          do:  ((struct.field_ref #paxosstate_gk.S #"Epoch"%go (![#ptrT] "ps")) <-[#uint64T] "$r0");;;
          let: "$r0" := #true in
          do:  ((struct.field_ref #paxosstate_gk.S #"IsLeader"%go (![#ptrT] "ps")) <-[#boolT] "$r0");;;
          let: "$r0" := (![#uint64T] (struct.field_ref #paxosstate_gk.S #"Epoch"%go (![#ptrT] "ps"))) in
          do:  ((struct.field_ref #paxosstate_gk.S #"AcceptedEpoch"%go (![#ptrT] "ps")) <-[#uint64T] "$r0");;;
          let: "$r0" := (![#uint64T] (struct.field_ref #enternewepochreply_gk.S #"NextIndex"%go (![#ptrT] "latestReply"))) in
          do:  ((struct.field_ref #paxosstate_gk.S #"NextIndex"%go (![#ptrT] "ps")) <-[#uint64T] "$r0");;;
          let: "$r0" := (![#sliceT] (struct.field_ref #enternewepochreply_gk.S #"State"%go (![#ptrT] "latestReply"))) in
          do:  ((struct.field_ref #paxosstate_gk.S #"State"%go (![#ptrT] "ps")) <-[#sliceT] "$r0")
>>>>>>> master
        else do:  #());;;
        return: #())
        ) in
      (method_call #(ptrT.id Server.id) #"withLock"%go (![ptrT] "s")) "$a0");;;
      do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![ptrT] "mu")) #())
    else
      do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![ptrT] "mu")) #());;;
      do:  (let: "$a0" := ((let: "$sl0" := (interface.make #stringT.id #"failed becomeleader"%go) in
      slice.literal interfaceT ["$sl0"])) in
      (func_call #log.Println) "$a0"));;;
    return: #()).

(* go: server.go:163:18 *)
Definition Server__TryAcquireⁱᵐᵖˡ : val :=
  λ: "s" <>,
    exception_do (let: "s" := (mem.alloc "s") in
<<<<<<< HEAD
    let: "retErr" := (mem.alloc (type.zero_val Error)) in
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![ptrT] (struct.field_ref ptrT #"mu"%go (![ptrT] "s")))) #());;;
    (if: (~ (![boolT] (struct.field_ref ptrT #"isLeader"%go (![ptrT] (struct.field_ref ptrT #"ps"%go (![ptrT] "s"))))))
    then
      do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![ptrT] (struct.field_ref ptrT #"mu"%go (![ptrT] "s")))) #());;;
      let: "n" := (mem.alloc (type.zero_val ptrT)) in
      return: (ENotLeader, ![ptrT] "n", #func.nil)
=======
    let: "retErr" := (mem.alloc (type.zero_val #error_gk.E)) in
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #());;;
    (if: (~ (![#boolT] (struct.field_ref #paxosstate_gk.S #"IsLeader"%go (![#ptrT] (struct.field_ref #Server #"ps"%go (![#ptrT] "s"))))))
    then
      do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #());;;
      let: "n" := (mem.alloc (type.zero_val #ptrT)) in
      return: (error_gk.ENotLeader, ![#ptrT] "n", #func.nil)
>>>>>>> master
    else do:  #());;;
    let: "tryRelease" := (mem.alloc (type.zero_val funcT)) in
    let: "$r0" := (λ: <>,
<<<<<<< HEAD
      exception_do (let: "$r0" := (let: "$a0" := (![uint64T] (struct.field_ref ptrT #"nextIndex"%go (![ptrT] (struct.field_ref ptrT #"ps"%go (![ptrT] "s"))))) in
      let: "$a1" := #(W64 1) in
      (func_call #std.SumAssumeNoOverflow) "$a0" "$a1") in
      do:  ((struct.field_ref ptrT #"nextIndex"%go (![ptrT] (struct.field_ref ptrT #"ps"%go (![ptrT] "s")))) <-[uint64T] "$r0");;;
      let: "args" := (mem.alloc (type.zero_val ptrT)) in
      let: "$r0" := (mem.alloc (let: "$epoch" := (![uint64T] (struct.field_ref ptrT #"epoch"%go (![ptrT] (struct.field_ref ptrT #"ps"%go (![ptrT] "s"))))) in
      let: "$nextIndex" := (![uint64T] (struct.field_ref ptrT #"nextIndex"%go (![ptrT] (struct.field_ref ptrT #"ps"%go (![ptrT] "s"))))) in
      let: "$state" := (![sliceT] (struct.field_ref ptrT #"state"%go (![ptrT] (struct.field_ref ptrT #"ps"%go (![ptrT] "s"))))) in
      struct.make applyAsFollowerArgs [{
        "epoch" ::= "$epoch";
        "nextIndex" ::= "$nextIndex";
        "state" ::= "$state"
      }])) in
      do:  ("args" <-[ptrT] "$r0");;;
      let: "waitFn" := (mem.alloc (type.zero_val funcT)) in
      let: "$r0" := (let: "$a0" := (let: "$a0" := (![ptrT] (struct.field_ref ptrT #"ps"%go (![ptrT] "s"))) in
      (func_call #encodePaxosState) "$a0") in
      (method_call #(ptrT.id asyncfile.AsyncFile.id) #"Write"%go (![ptrT] (struct.field_ref ptrT #"storage"%go (![ptrT] "s")))) "$a0") in
      do:  ("waitFn" <-[funcT] "$r0");;;
      do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![ptrT] (struct.field_ref ptrT #"mu"%go (![ptrT] "s")))) #());;;
      do:  ((![funcT] "waitFn") #());;;
      let: "clerks" := (mem.alloc (type.zero_val sliceT)) in
      let: "$r0" := (![sliceT] (struct.field_ref ptrT #"clerks"%go (![ptrT] "s"))) in
      do:  ("clerks" <-[sliceT] "$r0");;;
      let: "numReplies" := (mem.alloc (type.zero_val uint64T)) in
=======
      exception_do (let: "$r0" := (let: "$a0" := (![#uint64T] (struct.field_ref #paxosstate_gk.S #"NextIndex"%go (![#ptrT] (struct.field_ref #Server #"ps"%go (![#ptrT] "s"))))) in
      let: "$a1" := #(W64 1) in
      (func_call #std.SumAssumeNoOverflow) "$a0" "$a1") in
      do:  ((struct.field_ref #paxosstate_gk.S #"NextIndex"%go (![#ptrT] (struct.field_ref #Server #"ps"%go (![#ptrT] "s")))) <-[#uint64T] "$r0");;;
      let: "args" := (mem.alloc (type.zero_val #ptrT)) in
      let: "$r0" := (mem.alloc (let: "$Epoch" := (![#uint64T] (struct.field_ref #paxosstate_gk.S #"Epoch"%go (![#ptrT] (struct.field_ref #Server #"ps"%go (![#ptrT] "s"))))) in
      let: "$NextIndex" := (![#uint64T] (struct.field_ref #paxosstate_gk.S #"NextIndex"%go (![#ptrT] (struct.field_ref #Server #"ps"%go (![#ptrT] "s"))))) in
      let: "$State" := (![#sliceT] (struct.field_ref #paxosstate_gk.S #"State"%go (![#ptrT] (struct.field_ref #Server #"ps"%go (![#ptrT] "s"))))) in
      struct.make #applyasfollowerargs_gk.S [{
        "Epoch" ::= "$Epoch";
        "NextIndex" ::= "$NextIndex";
        "State" ::= "$State"
      }])) in
      do:  ("args" <-[#ptrT] "$r0");;;
      let: "waitFn" := (mem.alloc (type.zero_val #funcT)) in
      let: "$r0" := (let: "$a0" := (let: "$a0" := (slice.make2 #byteT #(W64 0)) in
      let: "$a1" := (![#paxosstate_gk.S] (![#ptrT] (struct.field_ref #Server #"ps"%go (![#ptrT] "s")))) in
      (func_call #paxosstate_gk.Marshal) "$a0" "$a1") in
      (method_call #(ptrT.id asyncfile.AsyncFile.id) #"Write"%go (![#ptrT] (struct.field_ref #Server #"storage"%go (![#ptrT] "s")))) "$a0") in
      do:  ("waitFn" <-[#funcT] "$r0");;;
      do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #());;;
      do:  ((![#funcT] "waitFn") #());;;
      let: "clerks" := (mem.alloc (type.zero_val #sliceT)) in
      let: "$r0" := (![#sliceT] (struct.field_ref #Server #"clerks"%go (![#ptrT] "s"))) in
      do:  ("clerks" <-[#sliceT] "$r0");;;
      let: "numReplies" := (mem.alloc (type.zero_val #uint64T)) in
>>>>>>> master
      let: "$r0" := #(W64 0) in
      do:  ("numReplies" <-[uint64T] "$r0");;;
      let: "replies" := (mem.alloc (type.zero_val sliceT)) in
      let: "$r0" := (slice.make2 ptrT (s_to_w64 (let: "$a0" := (![sliceT] "clerks") in
      slice.len "$a0"))) in
      do:  ("replies" <-[sliceT] "$r0");;;
      let: "mu" := (mem.alloc (type.zero_val ptrT)) in
      let: "$r0" := (mem.alloc (type.zero_val sync.Mutex)) in
      do:  ("mu" <-[ptrT] "$r0");;;
      let: "numReplies_cond" := (mem.alloc (type.zero_val ptrT)) in
      let: "$r0" := (let: "$a0" := (interface.make #(ptrT.id sync.Mutex.id) (![ptrT] "mu")) in
      (func_call #sync.NewCond) "$a0") in
      do:  ("numReplies_cond" <-[ptrT] "$r0");;;
      let: "n" := (mem.alloc (type.zero_val uint64T)) in
      let: "$r0" := (s_to_w64 (let: "$a0" := (![sliceT] "clerks") in
      slice.len "$a0")) in
      do:  ("n" <-[uint64T] "$r0");;;
      let: "$range" := (![sliceT] "clerks") in
      (let: "ck" := (mem.alloc (type.zero_val ptrT)) in
      let: "i" := (mem.alloc (type.zero_val intT)) in
      slice.for_range ptrT "$range" (λ: "$key" "$value",
        do:  ("ck" <-[ptrT] "$value");;;
        do:  ("i" <-[intT] "$key");;;
        let: "ck" := (mem.alloc (type.zero_val ptrT)) in
        let: "$r0" := (![ptrT] "ck") in
        do:  ("ck" <-[ptrT] "$r0");;;
        let: "i" := (mem.alloc (type.zero_val intT)) in
        let: "$r0" := (![intT] "i") in
        do:  ("i" <-[intT] "$r0");;;
        let: "$go" := (λ: <>,
          exception_do (let: "reply" := (mem.alloc (type.zero_val ptrT)) in
          let: "$r0" := (let: "$a0" := (![ptrT] "args") in
          (method_call #(ptrT.id singleClerk.id) #"applyAsFollower"%go (![ptrT] "ck")) "$a0") in
          do:  ("reply" <-[ptrT] "$r0");;;
          do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![ptrT] "mu")) #());;;
          do:  ("numReplies" <-[uint64T] ((![uint64T] "numReplies") + #(W64 1)));;;
          let: "$r0" := (![ptrT] "reply") in
          do:  ((slice.elem_ref ptrT (![sliceT] "replies") (![intT] "i")) <-[ptrT] "$r0");;;
          (if: (#(W64 2) * (![uint64T] "numReplies")) > (![uint64T] "n")
          then do:  ((method_call #(ptrT.id sync.Cond.id) #"Signal"%go (![ptrT] "numReplies_cond")) #())
          else do:  #());;;
          do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![ptrT] "mu")) #());;;
          return: #())
          ) in
        do:  (Fork ("$go" #()))));;;
      do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![ptrT] "mu")) #());;;
      (for: (λ: <>, (#(W64 2) * (![uint64T] "numReplies")) ≤ (![uint64T] "n")); (λ: <>, #()) := λ: <>,
        do:  ((method_call #(ptrT.id sync.Cond.id) #"Wait"%go (![ptrT] "numReplies_cond")) #()));;;
      let: "numSuccesses" := (mem.alloc (type.zero_val uint64T)) in
      let: "$r0" := #(W64 0) in
      do:  ("numSuccesses" <-[uint64T] "$r0");;;
      let: "$range" := (![sliceT] "replies") in
      (let: "reply" := (mem.alloc (type.zero_val ptrT)) in
      slice.for_range ptrT "$range" (λ: "$key" "$value",
        do:  ("reply" <-[ptrT] "$value");;;
        do:  "$key";;;
        (if: (![ptrT] "reply") ≠ #null
        then
<<<<<<< HEAD
          (if: (![Error] (struct.field_ref ptrT #"err"%go (![ptrT] "reply"))) = ENone
          then do:  ("numSuccesses" <-[uint64T] ((![uint64T] "numSuccesses") + #(W64 1)))
=======
          (if: (![#error_gk.E] (struct.field_ref #applyasfollowerreply_gk.S #"Err"%go (![#ptrT] "reply"))) = error_gk.ENone
          then do:  ("numSuccesses" <-[#uint64T] ((![#uint64T] "numSuccesses") + #(W64 1)))
>>>>>>> master
          else do:  #())
        else do:  #())));;;
      (if: (#(W64 2) * (![uint64T] "numSuccesses")) > (![uint64T] "n")
      then
<<<<<<< HEAD
        let: "$r0" := ENone in
        do:  ("retErr" <-[Error] "$r0")
      else
        let: "$r0" := EEpochStale in
        do:  ("retErr" <-[Error] "$r0"));;;
      return: (![Error] "retErr"))
      ) in
    do:  ("tryRelease" <-[funcT] "$r0");;;
    return: (ENone, struct.field_ref ptrT #"state"%go (![ptrT] (struct.field_ref ptrT #"ps"%go (![ptrT] "s"))), ![funcT] "tryRelease")).
=======
        let: "$r0" := error_gk.ENone in
        do:  ("retErr" <-[#error_gk.E] "$r0")
      else
        let: "$r0" := error_gk.EEpochStale in
        do:  ("retErr" <-[#error_gk.E] "$r0"));;;
      return: (![#error_gk.E] "retErr"))
      ) in
    do:  ("tryRelease" <-[#funcT] "$r0");;;
    return: (error_gk.ENone, struct.field_ref #paxosstate_gk.S #"State"%go (![#ptrT] (struct.field_ref #Server #"ps"%go (![#ptrT] "s"))), ![#funcT] "tryRelease")).
>>>>>>> master

(* go: server.go:233:18 *)
Definition Server__WeakReadⁱᵐᵖˡ : val :=
  λ: "s" <>,
    exception_do (let: "s" := (mem.alloc "s") in
<<<<<<< HEAD
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![ptrT] (struct.field_ref ptrT #"mu"%go (![ptrT] "s")))) #());;;
    let: "ret" := (mem.alloc (type.zero_val sliceT)) in
    let: "$r0" := (![sliceT] (struct.field_ref ptrT #"state"%go (![ptrT] (struct.field_ref ptrT #"ps"%go (![ptrT] "s"))))) in
    do:  ("ret" <-[sliceT] "$r0");;;
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![ptrT] (struct.field_ref ptrT #"mu"%go (![ptrT] "s")))) #());;;
    return: (![sliceT] "ret")).
=======
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #());;;
    let: "ret" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] (struct.field_ref #paxosstate_gk.S #"State"%go (![#ptrT] (struct.field_ref #Server #"ps"%go (![#ptrT] "s"))))) in
    do:  ("ret" <-[#sliceT] "$r0");;;
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #());;;
    return: (![#sliceT] "ret")).
>>>>>>> master

Definition makeServer : go_string := "github.com/mit-pdos/gokv/vrsm/paxos.makeServer"%go.

(* go: server.go:240:6 *)
Definition makeServerⁱᵐᵖˡ : val :=
  λ: "fname" "initstate" "config",
    exception_do (let: "config" := (mem.alloc "config") in
    let: "initstate" := (mem.alloc "initstate") in
    let: "fname" := (mem.alloc "fname") in
    let: "s" := (mem.alloc (type.zero_val ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val Server)) in
    do:  ("s" <-[ptrT] "$r0");;;
    let: "$r0" := (mem.alloc (type.zero_val sync.Mutex)) in
    do:  ((struct.field_ref ptrT #"mu"%go (![ptrT] "s")) <-[ptrT] "$r0");;;
    let: "$r0" := (slice.make2 ptrT #(W64 0)) in
    do:  ((struct.field_ref ptrT #"clerks"%go (![ptrT] "s")) <-[sliceT] "$r0");;;
    let: "$range" := (![sliceT] "config") in
    (let: "host" := (mem.alloc (type.zero_val uint64T)) in
    slice.for_range uint64T "$range" (λ: "$key" "$value",
      do:  ("host" <-[uint64T] "$value");;;
      do:  "$key";;;
      let: "$r0" := (let: "$a0" := (![sliceT] (struct.field_ref ptrT #"clerks"%go (![ptrT] "s"))) in
      let: "$a1" := ((let: "$sl0" := (let: "$a0" := (![uint64T] "host") in
      (func_call #MakeSingleClerk) "$a0") in
      slice.literal ptrT ["$sl0"])) in
      (slice.append ptrT) "$a0" "$a1") in
      do:  ((struct.field_ref ptrT #"clerks"%go (![ptrT] "s")) <-[sliceT] "$r0")));;;
    let: "encstate" := (mem.alloc (type.zero_val sliceT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![stringT] "fname") in
    (func_call #asyncfile.MakeAsyncFile) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("encstate" <-[sliceT] "$r0");;;
    do:  ((struct.field_ref ptrT #"storage"%go (![ptrT] "s")) <-[ptrT] "$r1");;;
    (if: (let: "$a0" := (![sliceT] "encstate") in
    slice.len "$a0") = #(W64 0)
    then
<<<<<<< HEAD
      let: "$r0" := (mem.alloc (type.zero_val paxosState)) in
      do:  ((struct.field_ref ptrT #"ps"%go (![ptrT] "s")) <-[ptrT] "$r0");;;
      let: "$r0" := (![sliceT] "initstate") in
      do:  ((struct.field_ref ptrT #"state"%go (![ptrT] (struct.field_ref ptrT #"ps"%go (![ptrT] "s")))) <-[sliceT] "$r0")
    else
      let: "$r0" := (let: "$a0" := (![sliceT] "encstate") in
      (func_call #decodePaxosState) "$a0") in
      do:  ((struct.field_ref ptrT #"ps"%go (![ptrT] "s")) <-[ptrT] "$r0"));;;
    return: (![ptrT] "s")).
=======
      let: "$r0" := (mem.alloc (type.zero_val #paxosstate_gk.S)) in
      do:  ((struct.field_ref #Server #"ps"%go (![#ptrT] "s")) <-[#ptrT] "$r0");;;
      let: "$r0" := (![#sliceT] "initstate") in
      do:  ((struct.field_ref #paxosstate_gk.S #"State"%go (![#ptrT] (struct.field_ref #Server #"ps"%go (![#ptrT] "s")))) <-[#sliceT] "$r0")
    else
      let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "encstate") in
      (func_call #paxosstate_gk.Unmarshal) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ((![#ptrT] (struct.field_ref #Server #"ps"%go (![#ptrT] "s"))) <-[#paxosstate_gk.S] "$r0");;;
      do:  "$r1");;;
    return: (![#ptrT] "s")).
>>>>>>> master

Definition StartServer : go_string := "github.com/mit-pdos/gokv/vrsm/paxos.StartServer"%go.

(* go: server.go:260:6 *)
Definition StartServerⁱᵐᵖˡ : val :=
  λ: "fname" "initstate" "me" "config",
    exception_do (let: "config" := (mem.alloc "config") in
    let: "me" := (mem.alloc "me") in
    let: "initstate" := (mem.alloc "initstate") in
    let: "fname" := (mem.alloc "fname") in
    let: "s" := (mem.alloc (type.zero_val ptrT)) in
    let: "$r0" := (let: "$a0" := (![stringT] "fname") in
    let: "$a1" := (![sliceT] "initstate") in
    let: "$a2" := (![sliceT] "config") in
    (func_call #makeServer) "$a0" "$a1" "$a2") in
    do:  ("s" <-[ptrT] "$r0");;;
    let: "handlers" := (mem.alloc (type.zero_val (mapT uint64T funcT))) in
    let: "$r0" := (map.make uint64T funcT) in
    do:  ("handlers" <-[mapT uint64T funcT] "$r0");;;
    let: "$r0" := (λ: "raw_args" "raw_reply",
      exception_do (let: "raw_reply" := (mem.alloc "raw_reply") in
      let: "raw_args" := (mem.alloc "raw_args") in
<<<<<<< HEAD
      let: "reply" := (mem.alloc (type.zero_val ptrT)) in
      let: "$r0" := (mem.alloc (type.zero_val applyAsFollowerReply)) in
      do:  ("reply" <-[ptrT] "$r0");;;
      let: "args" := (mem.alloc (type.zero_val ptrT)) in
      let: "$r0" := (let: "$a0" := (![sliceT] "raw_args") in
      (func_call #decodeApplyAsFollowerArgs) "$a0") in
      do:  ("args" <-[ptrT] "$r0");;;
      do:  (let: "$a0" := (![ptrT] "args") in
      let: "$a1" := (![ptrT] "reply") in
      (method_call #(ptrT.id Server.id) #"applyAsFollower"%go (![ptrT] "s")) "$a0" "$a1");;;
      let: "$r0" := (let: "$a0" := (![ptrT] "reply") in
      (func_call #encodeApplyAsFollowerReply) "$a0") in
      do:  ((![ptrT] "raw_reply") <-[sliceT] "$r0");;;
=======
      let: "reply" := (mem.alloc (type.zero_val #ptrT)) in
      let: "$r0" := (mem.alloc (type.zero_val #applyasfollowerreply_gk.S)) in
      do:  ("reply" <-[#ptrT] "$r0");;;
      let: "args" := (mem.alloc (type.zero_val #applyasfollowerargs_gk.S)) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "raw_args") in
      (func_call #applyasfollowerargs_gk.Unmarshal) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("args" <-[#applyasfollowerargs_gk.S] "$r0");;;
      do:  "$r1";;;
      do:  (let: "$a0" := "args" in
      let: "$a1" := (![#ptrT] "reply") in
      (method_call #(ptrT.id Server.id) #"applyAsFollower"%go (![#ptrT] "s")) "$a0" "$a1");;;
      let: "$r0" := (let: "$a0" := (slice.make2 #byteT #(W64 0)) in
      let: "$a1" := (![#applyasfollowerreply_gk.S] (![#ptrT] "reply")) in
      (func_call #applyasfollowerreply_gk.Marshal) "$a0" "$a1") in
      do:  ((![#ptrT] "raw_reply") <-[#sliceT] "$r0");;;
>>>>>>> master
      return: #())
      ) in
    do:  (map.insert (![mapT uint64T funcT] "handlers") RPC_APPLY_AS_FOLLOWER "$r0");;;
    let: "$r0" := (λ: "raw_args" "raw_reply",
      exception_do (let: "raw_reply" := (mem.alloc "raw_reply") in
      let: "raw_args" := (mem.alloc "raw_args") in
<<<<<<< HEAD
      let: "reply" := (mem.alloc (type.zero_val ptrT)) in
      let: "$r0" := (mem.alloc (type.zero_val enterNewEpochReply)) in
      do:  ("reply" <-[ptrT] "$r0");;;
      let: "args" := (mem.alloc (type.zero_val ptrT)) in
      let: "$r0" := (let: "$a0" := (![sliceT] "raw_args") in
      (func_call #decodeEnterNewEpochArgs) "$a0") in
      do:  ("args" <-[ptrT] "$r0");;;
      do:  (let: "$a0" := (![ptrT] "args") in
      let: "$a1" := (![ptrT] "reply") in
      (method_call #(ptrT.id Server.id) #"enterNewEpoch"%go (![ptrT] "s")) "$a0" "$a1");;;
      let: "$r0" := (let: "$a0" := (![ptrT] "reply") in
      (func_call #encodeEnterNewEpochReply) "$a0") in
      do:  ((![ptrT] "raw_reply") <-[sliceT] "$r0");;;
=======
      let: "reply" := (mem.alloc (type.zero_val #ptrT)) in
      let: "$r0" := (mem.alloc (type.zero_val #enternewepochreply_gk.S)) in
      do:  ("reply" <-[#ptrT] "$r0");;;
      let: "args" := (mem.alloc (type.zero_val #enternewepochargs_gk.S)) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "raw_args") in
      (func_call #enternewepochargs_gk.Unmarshal) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("args" <-[#enternewepochargs_gk.S] "$r0");;;
      do:  "$r1";;;
      do:  (let: "$a0" := "args" in
      let: "$a1" := (![#ptrT] "reply") in
      (method_call #(ptrT.id Server.id) #"enterNewEpoch"%go (![#ptrT] "s")) "$a0" "$a1");;;
      let: "$r0" := (let: "$a0" := (slice.make2 #byteT #(W64 0)) in
      let: "$a1" := (![#enternewepochreply_gk.S] (![#ptrT] "reply")) in
      (func_call #enternewepochreply_gk.Marshal) "$a0" "$a1") in
      do:  ((![#ptrT] "raw_reply") <-[#sliceT] "$r0");;;
>>>>>>> master
      return: #())
      ) in
    do:  (map.insert (![mapT uint64T funcT] "handlers") RPC_ENTER_NEW_EPOCH "$r0");;;
    let: "$r0" := (λ: "raw_args" "raw_reply",
      exception_do (let: "raw_reply" := (mem.alloc "raw_reply") in
      let: "raw_args" := (mem.alloc "raw_args") in
      do:  ((method_call #(ptrT.id Server.id) #"TryBecomeLeader"%go (![ptrT] "s")) #());;;
      return: #())
      ) in
    do:  (map.insert (![mapT uint64T funcT] "handlers") RPC_BECOME_LEADER "$r0");;;
    let: "r" := (mem.alloc (type.zero_val ptrT)) in
    let: "$r0" := (let: "$a0" := (![mapT uint64T funcT] "handlers") in
    (func_call #urpc.MakeServer) "$a0") in
    do:  ("r" <-[ptrT] "$r0");;;
    do:  (let: "$a0" := (![uint64T] "me") in
    (method_call #(ptrT.id urpc.Server.id) #"Serve"%go (![ptrT] "r")) "$a0");;;
    return: (![ptrT] "s")).

Definition vars' : list (go_string * go_type) := [].

Definition functions' : list (go_string * val) := [(MakeSingleClerk, MakeSingleClerkⁱᵐᵖˡ); (makeServer, makeServerⁱᵐᵖˡ); (StartServer, StartServerⁱᵐᵖˡ)].

Definition msets' : list (go_string * (list (go_string * val))) := [(singleClerk.id, []); (ptrT.id singleClerk.id, [("TryBecomeLeader"%go, singleClerk__TryBecomeLeaderⁱᵐᵖˡ); ("applyAsFollower"%go, singleClerk__applyAsFollowerⁱᵐᵖˡ); ("enterNewEpoch"%go, singleClerk__enterNewEpochⁱᵐᵖˡ)]); (Server.id, []); (ptrT.id Server.id, [("TryAcquire"%go, Server__TryAcquireⁱᵐᵖˡ); ("TryBecomeLeader"%go, Server__TryBecomeLeaderⁱᵐᵖˡ); ("WeakRead"%go, Server__WeakReadⁱᵐᵖˡ); ("applyAsFollower"%go, Server__applyAsFollowerⁱᵐᵖˡ); ("enterNewEpoch"%go, Server__enterNewEpochⁱᵐᵖˡ); ("withLock"%go, Server__withLockⁱᵐᵖˡ)])].

#[global] Instance info' : PkgInfo paxos.paxos :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [code.github_com.mit_pdos.gokv.grove_ffi.grove_ffi; code.github_com.mit_pdos.gokv.reconnectclient.reconnectclient; code.github_com.mit_pdos.gokv.vrsm.paxos.applyasfollowerargs_gk.applyasfollowerargs_gk; code.github_com.mit_pdos.gokv.vrsm.paxos.applyasfollowerreply_gk.applyasfollowerreply_gk; code.github_com.mit_pdos.gokv.vrsm.paxos.enternewepochargs_gk.enternewepochargs_gk; code.github_com.mit_pdos.gokv.vrsm.paxos.enternewepochreply_gk.enternewepochreply_gk; code.github_com.mit_pdos.gokv.vrsm.paxos.error_gk.error_gk; code.log.log; code.sync.sync; code.github_com.goose_lang.std.std; code.github_com.mit_pdos.gokv.asyncfile.asyncfile; code.github_com.mit_pdos.gokv.urpc.urpc; code.github_com.mit_pdos.gokv.vrsm.paxos.paxosstate_gk.paxosstate_gk];
  |}.

Definition initialize' : val :=
  λ: <>,
    package.init #paxos.paxos (λ: <>,
      exception_do (do:  (paxosstate_gk.initialize' #());;;
      do:  (urpc.initialize' #());;;
      do:  (asyncfile.initialize' #());;;
      do:  (std.initialize' #());;;
      do:  (sync.initialize' #());;;
      do:  (log.initialize' #());;;
      do:  (error_gk.initialize' #());;;
      do:  (enternewepochreply_gk.initialize' #());;;
      do:  (enternewepochargs_gk.initialize' #());;;
      do:  (applyasfollowerreply_gk.initialize' #());;;
      do:  (applyasfollowerargs_gk.initialize' #());;;
      do:  (reconnectclient.initialize' #());;;
      do:  (grove_ffi.initialize' #());;;
      do:  (package.alloc paxos.paxos #()))
      ).

End code.
End paxos.
