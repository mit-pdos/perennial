(* autogenerated from github.com/mit-pdos/gokv/vrsm/paxos *)
From New.golang Require Import defn.
Require Export New.code.github_com.goose_lang.std.
Require Export New.code.github_com.mit_pdos.gokv.asyncfile.
Require Export New.code.github_com.mit_pdos.gokv.grove_ffi.
Require Export New.code.github_com.mit_pdos.gokv.reconnectclient.
Require Export New.code.github_com.mit_pdos.gokv.urpc.
Require Export New.code.github_com.tchajed.marshal.
Require Export New.code.log.
Require Export New.code.sync.

Definition paxos : go_string := "github.com/mit-pdos/gokv/vrsm/paxos".

From New Require Import grove_prelude.
Module paxos.
Section code.


Definition RPC_APPLY_AS_FOLLOWER : expr := #(W64 0).

Definition RPC_ENTER_NEW_EPOCH : expr := #(W64 1).

Definition RPC_BECOME_LEADER : expr := #(W64 2).

Definition singleClerk : go_type := structT [
  "cl" :: ptrT
].

(* go: internalclerk.go:19:6 *)
Definition MakeSingleClerk : val :=
  rec: "MakeSingleClerk" "addr" :=
    exception_do (let: "addr" := (ref_ty uint64T "addr") in
    let: "ck" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty singleClerk (let: "$cl" := (let: "$a0" := (![uint64T] "addr") in
    (func_call #reconnectclient #"MakeReconnectingClient"%go) "$a0") in
    struct.make singleClerk [{
      "cl" ::= "$cl"
    }])) in
    do:  ("ck" <-[ptrT] "$r0");;;
    return: (![ptrT] "ck")).

Definition Error : go_type := uint64T.

Definition enterNewEpochReply : go_type := structT [
  "err" :: Error;
  "acceptedEpoch" :: uint64T;
  "nextIndex" :: uint64T;
  "state" :: sliceT
].

Definition ETimeout : expr := #(W64 3).

(* go: internalclerk.go:28:23 *)
Definition singleClerk__enterNewEpoch : val :=
  rec: "singleClerk__enterNewEpoch" "s" "args" :=
    exception_do (let: "s" := (ref_ty ptrT "s") in
    let: "args" := (ref_ty ptrT "args") in
    let: "raw_args" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (let: "$a0" := (![ptrT] "args") in
    (func_call #paxos.paxos #"encodeEnterNewEpochArgs"%go) "$a0") in
    do:  ("raw_args" <-[sliceT] "$r0");;;
    let: "raw_reply" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty sliceT (zero_val sliceT)) in
    do:  ("raw_reply" <-[ptrT] "$r0");;;
    let: "err" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (let: "$a0" := RPC_ENTER_NEW_EPOCH in
    let: "$a1" := (![sliceT] "raw_args") in
    let: "$a2" := (![ptrT] "raw_reply") in
    let: "$a3" := #(W64 500) in
    (method_call #reconnectclient #"ReconnectingClient'ptr" #"Call" (![ptrT] (struct.field_ref singleClerk "cl" (![ptrT] "s")))) "$a0" "$a1" "$a2" "$a3") in
    do:  ("err" <-[uint64T] "$r0");;;
    (if: (![uint64T] "err") = #(W64 0)
    then
      return: (let: "$a0" := (![sliceT] (![ptrT] "raw_reply")) in
       (func_call #paxos.paxos #"decodeEnterNewEpochReply"%go) "$a0")
    else
      return: (ref_ty enterNewEpochReply (let: "$err" := ETimeout in
       struct.make enterNewEpochReply [{
         "err" ::= "$err";
         "acceptedEpoch" ::= zero_val uint64T;
         "nextIndex" ::= zero_val uint64T;
         "state" ::= zero_val sliceT
       }])))).

Definition applyAsFollowerReply : go_type := structT [
  "err" :: Error
].

(* go: internalclerk.go:40:23 *)
Definition singleClerk__applyAsFollower : val :=
  rec: "singleClerk__applyAsFollower" "s" "args" :=
    exception_do (let: "s" := (ref_ty ptrT "s") in
    let: "args" := (ref_ty ptrT "args") in
    let: "raw_args" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (let: "$a0" := (![ptrT] "args") in
    (func_call #paxos.paxos #"encodeApplyAsFollowerArgs"%go) "$a0") in
    do:  ("raw_args" <-[sliceT] "$r0");;;
    let: "raw_reply" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty sliceT (zero_val sliceT)) in
    do:  ("raw_reply" <-[ptrT] "$r0");;;
    let: "err" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (let: "$a0" := RPC_APPLY_AS_FOLLOWER in
    let: "$a1" := (![sliceT] "raw_args") in
    let: "$a2" := (![ptrT] "raw_reply") in
    let: "$a3" := #(W64 500) in
    (method_call #reconnectclient #"ReconnectingClient'ptr" #"Call" (![ptrT] (struct.field_ref singleClerk "cl" (![ptrT] "s")))) "$a0" "$a1" "$a2" "$a3") in
    do:  ("err" <-[uint64T] "$r0");;;
    (if: (![uint64T] "err") = #(W64 0)
    then
      return: (let: "$a0" := (![sliceT] (![ptrT] "raw_reply")) in
       (func_call #paxos.paxos #"decodeApplyAsFollowerReply"%go) "$a0")
    else
      return: (ref_ty applyAsFollowerReply (let: "$err" := ETimeout in
       struct.make applyAsFollowerReply [{
         "err" ::= "$err"
       }])))).

(* go: internalclerk.go:51:23 *)
Definition singleClerk__TryBecomeLeader : val :=
  rec: "singleClerk__TryBecomeLeader" "s" <> :=
    exception_do (let: "s" := (ref_ty ptrT "s") in
    let: "reply" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty sliceT (zero_val sliceT)) in
    do:  ("reply" <-[ptrT] "$r0");;;
    do:  (let: "$a0" := RPC_BECOME_LEADER in
    let: "$a1" := (slice.make2 byteT #(W64 0)) in
    let: "$a2" := (![ptrT] "reply") in
    let: "$a3" := #(W64 500) in
    (method_call #reconnectclient #"ReconnectingClient'ptr" #"Call" (![ptrT] (struct.field_ref singleClerk "cl" (![ptrT] "s")))) "$a0" "$a1" "$a2" "$a3")).

Definition ENone : expr := #(W64 0).

Definition EEpochStale : expr := #(W64 1).

Definition EOutOfOrder : expr := #(W64 2).

Definition ENotLeader : expr := #(W64 4).

Definition applyAsFollowerArgs : go_type := structT [
  "epoch" :: uint64T;
  "nextIndex" :: uint64T;
  "state" :: sliceT
].

(* go: marshal.go:21:6 *)
Definition encodeApplyAsFollowerArgs : val :=
  rec: "encodeApplyAsFollowerArgs" "o" :=
    exception_do (let: "o" := (ref_ty ptrT "o") in
    let: "enc" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (slice.make3 byteT #(W64 0) (#(W64 (8 + 8)) + (let: "$a0" := (![sliceT] (struct.field_ref applyAsFollowerArgs "state" (![ptrT] "o"))) in
    slice.len "$a0"))) in
    do:  ("enc" <-[sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT] "enc") in
    let: "$a1" := (![uint64T] (struct.field_ref applyAsFollowerArgs "epoch" (![ptrT] "o"))) in
    (func_call #marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("enc" <-[sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT] "enc") in
    let: "$a1" := (![uint64T] (struct.field_ref applyAsFollowerArgs "nextIndex" (![ptrT] "o"))) in
    (func_call #marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("enc" <-[sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT] "enc") in
    let: "$a1" := (![sliceT] (struct.field_ref applyAsFollowerArgs "state" (![ptrT] "o"))) in
    (func_call #marshal #"WriteBytes"%go) "$a0" "$a1") in
    do:  ("enc" <-[sliceT] "$r0");;;
    return: (![sliceT] "enc")).

(* go: marshal.go:29:6 *)
Definition decodeApplyAsFollowerArgs : val :=
  rec: "decodeApplyAsFollowerArgs" "enc" :=
    exception_do (let: "enc" := (ref_ty sliceT "enc") in
    let: "o" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty applyAsFollowerArgs (zero_val applyAsFollowerArgs)) in
    do:  ("o" <-[ptrT] "$r0");;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![sliceT] "enc") in
    (func_call #marshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ((struct.field_ref applyAsFollowerArgs "epoch" (![ptrT] "o")) <-[uint64T] "$r0");;;
    do:  ("enc" <-[sliceT] "$r1");;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![sliceT] "enc") in
    (func_call #marshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ((struct.field_ref applyAsFollowerArgs "nextIndex" (![ptrT] "o")) <-[uint64T] "$r0");;;
    do:  ("enc" <-[sliceT] "$r1");;;
    let: "$r0" := (![sliceT] "enc") in
    do:  ((struct.field_ref applyAsFollowerArgs "state" (![ptrT] "o")) <-[sliceT] "$r0");;;
    return: (![ptrT] "o")).

(* go: marshal.go:41:6 *)
Definition decodeApplyAsFollowerReply : val :=
  rec: "decodeApplyAsFollowerReply" "s" :=
    exception_do (let: "s" := (ref_ty sliceT "s") in
    let: "o" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty applyAsFollowerReply (struct.make applyAsFollowerReply [{
      "err" ::= zero_val Error
    }])) in
    do:  ("o" <-[ptrT] "$r0");;;
    let: "err" := (ref_ty uint64T (zero_val uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![sliceT] "s") in
    (func_call #marshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("err" <-[uint64T] "$r0");;;
    do:  "$r1";;;
    let: "$r0" := (![uint64T] "err") in
    do:  ((struct.field_ref applyAsFollowerReply "err" (![ptrT] "o")) <-[Error] "$r0");;;
    return: (![ptrT] "o")).

(* go: marshal.go:48:6 *)
Definition encodeApplyAsFollowerReply : val :=
  rec: "encodeApplyAsFollowerReply" "o" :=
    exception_do (let: "o" := (ref_ty ptrT "o") in
    let: "enc" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (slice.make3 byteT #(W64 0) #(W64 8)) in
    do:  ("enc" <-[sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT] "enc") in
    let: "$a1" := (![Error] (struct.field_ref applyAsFollowerReply "err" (![ptrT] "o"))) in
    (func_call #marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("enc" <-[sliceT] "$r0");;;
    return: (![sliceT] "enc")).

Definition enterNewEpochArgs : go_type := structT [
  "epoch" :: uint64T
].

(* go: marshal.go:58:6 *)
Definition encodeEnterNewEpochArgs : val :=
  rec: "encodeEnterNewEpochArgs" "o" :=
    exception_do (let: "o" := (ref_ty ptrT "o") in
    let: "enc" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (slice.make3 byteT #(W64 0) #(W64 8)) in
    do:  ("enc" <-[sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT] "enc") in
    let: "$a1" := (![uint64T] (struct.field_ref enterNewEpochArgs "epoch" (![ptrT] "o"))) in
    (func_call #marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("enc" <-[sliceT] "$r0");;;
    return: (![sliceT] "enc")).

(* go: marshal.go:64:6 *)
Definition decodeEnterNewEpochArgs : val :=
  rec: "decodeEnterNewEpochArgs" "s" :=
    exception_do (let: "s" := (ref_ty sliceT "s") in
    let: "o" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty enterNewEpochArgs (zero_val enterNewEpochArgs)) in
    do:  ("o" <-[ptrT] "$r0");;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![sliceT] "s") in
    (func_call #marshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ((struct.field_ref enterNewEpochArgs "epoch" (![ptrT] "o")) <-[uint64T] "$r0");;;
    do:  "$r1";;;
    return: (![ptrT] "o")).

(* go: marshal.go:77:6 *)
Definition decodeEnterNewEpochReply : val :=
  rec: "decodeEnterNewEpochReply" "enc" :=
    exception_do (let: "enc" := (ref_ty sliceT "enc") in
    let: "o" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty enterNewEpochReply (struct.make enterNewEpochReply [{
      "err" ::= zero_val Error;
      "acceptedEpoch" ::= zero_val uint64T;
      "nextIndex" ::= zero_val uint64T;
      "state" ::= zero_val sliceT
    }])) in
    do:  ("o" <-[ptrT] "$r0");;;
    let: "err" := (ref_ty uint64T (zero_val uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![sliceT] "enc") in
    (func_call #marshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("err" <-[uint64T] "$r0");;;
    do:  ("enc" <-[sliceT] "$r1");;;
    let: "$r0" := (![uint64T] "err") in
    do:  ((struct.field_ref enterNewEpochReply "err" (![ptrT] "o")) <-[Error] "$r0");;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![sliceT] "enc") in
    (func_call #marshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ((struct.field_ref enterNewEpochReply "acceptedEpoch" (![ptrT] "o")) <-[uint64T] "$r0");;;
    do:  ("enc" <-[sliceT] "$r1");;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![sliceT] "enc") in
    (func_call #marshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ((struct.field_ref enterNewEpochReply "nextIndex" (![ptrT] "o")) <-[uint64T] "$r0");;;
    do:  ("enc" <-[sliceT] "$r1");;;
    let: "$r0" := (![sliceT] "enc") in
    do:  ((struct.field_ref enterNewEpochReply "state" (![ptrT] "o")) <-[sliceT] "$r0");;;
    return: (![ptrT] "o")).

(* go: marshal.go:89:6 *)
Definition encodeEnterNewEpochReply : val :=
  rec: "encodeEnterNewEpochReply" "o" :=
    exception_do (let: "o" := (ref_ty ptrT "o") in
    let: "enc" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (slice.make3 byteT #(W64 0) (#(W64 ((8 + 8) + 8)) + (let: "$a0" := (![sliceT] (struct.field_ref enterNewEpochReply "state" (![ptrT] "o"))) in
    slice.len "$a0"))) in
    do:  ("enc" <-[sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT] "enc") in
    let: "$a1" := (![Error] (struct.field_ref enterNewEpochReply "err" (![ptrT] "o"))) in
    (func_call #marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("enc" <-[sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT] "enc") in
    let: "$a1" := (![uint64T] (struct.field_ref enterNewEpochReply "acceptedEpoch" (![ptrT] "o"))) in
    (func_call #marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("enc" <-[sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT] "enc") in
    let: "$a1" := (![uint64T] (struct.field_ref enterNewEpochReply "nextIndex" (![ptrT] "o"))) in
    (func_call #marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("enc" <-[sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT] "enc") in
    let: "$a1" := (![sliceT] (struct.field_ref enterNewEpochReply "state" (![ptrT] "o"))) in
    (func_call #marshal #"WriteBytes"%go) "$a0" "$a1") in
    do:  ("enc" <-[sliceT] "$r0");;;
    return: (![sliceT] "enc")).

Definition applyReply : go_type := structT [
  "err" :: Error;
  "ret" :: sliceT
].

(* go: marshal.go:103:6 *)
Definition encodeApplyReply : val :=
  rec: "encodeApplyReply" "o" :=
    exception_do (let: "o" := (ref_ty ptrT "o") in
    let: "enc" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (slice.make3 byteT #(W64 0) (#(W64 8) + (let: "$a0" := (![sliceT] (struct.field_ref applyReply "ret" (![ptrT] "o"))) in
    slice.len "$a0"))) in
    do:  ("enc" <-[sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT] "enc") in
    let: "$a1" := (![Error] (struct.field_ref applyReply "err" (![ptrT] "o"))) in
    (func_call #marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("enc" <-[sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT] "enc") in
    let: "$a1" := (![sliceT] (struct.field_ref applyReply "ret" (![ptrT] "o"))) in
    (func_call #marshal #"WriteBytes"%go) "$a0" "$a1") in
    do:  ("enc" <-[sliceT] "$r0");;;
    return: (![sliceT] "enc")).

(* go: marshal.go:110:6 *)
Definition decodeApplyReply : val :=
  rec: "decodeApplyReply" "enc" :=
    exception_do (let: "enc" := (ref_ty sliceT "enc") in
    let: "o" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty applyReply (struct.make applyReply [{
      "err" ::= zero_val Error;
      "ret" ::= zero_val sliceT
    }])) in
    do:  ("o" <-[ptrT] "$r0");;;
    let: "err" := (ref_ty uint64T (zero_val uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![sliceT] "enc") in
    (func_call #marshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("err" <-[uint64T] "$r0");;;
    do:  ("enc" <-[sliceT] "$r1");;;
    let: "$r0" := (![uint64T] "err") in
    do:  ((struct.field_ref applyReply "err" (![ptrT] "o")) <-[Error] "$r0");;;
    let: "$r0" := (![sliceT] "enc") in
    do:  ((struct.field_ref applyReply "ret" (![ptrT] "o")) <-[sliceT] "$r0");;;
    return: (![ptrT] "o")).

(* go: marshal.go:120:6 *)
Definition boolToU64 : val :=
  rec: "boolToU64" "b" :=
    exception_do (let: "b" := (ref_ty boolT "b") in
    (if: ![boolT] "b"
    then return: (#(W64 1))
    else return: (#(W64 0)))).

Definition paxosState : go_type := structT [
  "epoch" :: uint64T;
  "acceptedEpoch" :: uint64T;
  "nextIndex" :: uint64T;
  "state" :: sliceT;
  "isLeader" :: boolT
].

(* go: marshal.go:128:6 *)
Definition encodePaxosState : val :=
  rec: "encodePaxosState" "ps" :=
    exception_do (let: "ps" := (ref_ty ptrT "ps") in
    let: "e" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (slice.make2 byteT #(W64 0)) in
    do:  ("e" <-[sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT] "e") in
    let: "$a1" := (![uint64T] (struct.field_ref paxosState "epoch" (![ptrT] "ps"))) in
    (func_call #marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("e" <-[sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT] "e") in
    let: "$a1" := (![uint64T] (struct.field_ref paxosState "acceptedEpoch" (![ptrT] "ps"))) in
    (func_call #marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("e" <-[sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT] "e") in
    let: "$a1" := (![uint64T] (struct.field_ref paxosState "nextIndex" (![ptrT] "ps"))) in
    (func_call #marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("e" <-[sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT] "e") in
    let: "$a1" := (let: "$a0" := (![boolT] (struct.field_ref paxosState "isLeader" (![ptrT] "ps"))) in
    (func_call #paxos.paxos #"boolToU64"%go) "$a0") in
    (func_call #marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("e" <-[sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT] "e") in
    let: "$a1" := (![sliceT] (struct.field_ref paxosState "state" (![ptrT] "ps"))) in
    (func_call #marshal #"WriteBytes"%go) "$a0" "$a1") in
    do:  ("e" <-[sliceT] "$r0");;;
    return: (![sliceT] "e")).

(* go: marshal.go:138:6 *)
Definition decodePaxosState : val :=
  rec: "decodePaxosState" "enc" :=
    exception_do (let: "enc" := (ref_ty sliceT "enc") in
    let: "e" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (![sliceT] "enc") in
    do:  ("e" <-[sliceT] "$r0");;;
    let: "leaderInt" := (ref_ty uint64T (zero_val uint64T)) in
    let: "ps" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty paxosState (zero_val paxosState)) in
    do:  ("ps" <-[ptrT] "$r0");;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![sliceT] "e") in
    (func_call #marshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ((struct.field_ref paxosState "epoch" (![ptrT] "ps")) <-[uint64T] "$r0");;;
    do:  ("e" <-[sliceT] "$r1");;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![sliceT] "e") in
    (func_call #marshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ((struct.field_ref paxosState "acceptedEpoch" (![ptrT] "ps")) <-[uint64T] "$r0");;;
    do:  ("e" <-[sliceT] "$r1");;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![sliceT] "e") in
    (func_call #marshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ((struct.field_ref paxosState "nextIndex" (![ptrT] "ps")) <-[uint64T] "$r0");;;
    do:  ("e" <-[sliceT] "$r1");;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![sliceT] "e") in
    (func_call #marshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("leaderInt" <-[uint64T] "$r0");;;
    do:  ((struct.field_ref paxosState "state" (![ptrT] "ps")) <-[sliceT] "$r1");;;
    let: "$r0" := ((![uint64T] "leaderInt") = #(W64 1)) in
    do:  ((struct.field_ref paxosState "isLeader" (![ptrT] "ps")) <-[boolT] "$r0");;;
    return: (![ptrT] "ps")).

Definition Server : go_type := structT [
  "mu" :: ptrT;
  "ps" :: ptrT;
  "storage" :: ptrT;
  "clerks" :: sliceT
].

(* go: server.go:28:18 *)
Definition Server__withLock : val :=
  rec: "Server__withLock" "s" "f" :=
    exception_do (let: "s" := (ref_ty ptrT "s") in
    let: "f" := (ref_ty funcT "f") in
    do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![ptrT] (struct.field_ref Server "mu" (![ptrT] "s")))) #());;;
    do:  (let: "$a0" := (![ptrT] (struct.field_ref Server "ps" (![ptrT] "s"))) in
    (![funcT] "f") "$a0");;;
    let: "waitFn" := (ref_ty funcT (zero_val funcT)) in
    let: "$r0" := (let: "$a0" := (let: "$a0" := (![ptrT] (struct.field_ref Server "ps" (![ptrT] "s"))) in
    (func_call #paxos.paxos #"encodePaxosState"%go) "$a0") in
    (method_call #asyncfile #"AsyncFile'ptr" #"Write" (![ptrT] (struct.field_ref Server "storage" (![ptrT] "s")))) "$a0") in
    do:  ("waitFn" <-[funcT] "$r0");;;
    do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![ptrT] (struct.field_ref Server "mu" (![ptrT] "s")))) #());;;
    do:  ((![funcT] "waitFn") #())).

(* go: server.go:36:18 *)
Definition Server__applyAsFollower : val :=
  rec: "Server__applyAsFollower" "s" "args" "reply" :=
    exception_do (let: "s" := (ref_ty ptrT "s") in
    let: "reply" := (ref_ty ptrT "reply") in
    let: "args" := (ref_ty ptrT "args") in
    do:  (let: "$a0" := (λ: "ps",
      exception_do (let: "ps" := (ref_ty ptrT "ps") in
      (if: (![uint64T] (struct.field_ref paxosState "epoch" (![ptrT] "ps"))) ≤ (![uint64T] (struct.field_ref applyAsFollowerArgs "epoch" (![ptrT] "args")))
      then
        (if: (![uint64T] (struct.field_ref paxosState "acceptedEpoch" (![ptrT] "ps"))) = (![uint64T] (struct.field_ref applyAsFollowerArgs "epoch" (![ptrT] "args")))
        then
          (if: (![uint64T] (struct.field_ref paxosState "nextIndex" (![ptrT] "ps"))) < (![uint64T] (struct.field_ref applyAsFollowerArgs "nextIndex" (![ptrT] "args")))
          then
            let: "$r0" := (![uint64T] (struct.field_ref applyAsFollowerArgs "nextIndex" (![ptrT] "args"))) in
            do:  ((struct.field_ref paxosState "nextIndex" (![ptrT] "ps")) <-[uint64T] "$r0");;;
            let: "$r0" := (![sliceT] (struct.field_ref applyAsFollowerArgs "state" (![ptrT] "args"))) in
            do:  ((struct.field_ref paxosState "state" (![ptrT] "ps")) <-[sliceT] "$r0");;;
            let: "$r0" := ENone in
            do:  ((struct.field_ref applyAsFollowerReply "err" (![ptrT] "reply")) <-[Error] "$r0")
          else
            let: "$r0" := ENone in
            do:  ((struct.field_ref applyAsFollowerReply "err" (![ptrT] "reply")) <-[Error] "$r0"))
        else
          let: "$r0" := (![uint64T] (struct.field_ref applyAsFollowerArgs "epoch" (![ptrT] "args"))) in
          do:  ((struct.field_ref paxosState "acceptedEpoch" (![ptrT] "ps")) <-[uint64T] "$r0");;;
          let: "$r0" := (![uint64T] (struct.field_ref applyAsFollowerArgs "epoch" (![ptrT] "args"))) in
          do:  ((struct.field_ref paxosState "epoch" (![ptrT] "ps")) <-[uint64T] "$r0");;;
          let: "$r0" := (![sliceT] (struct.field_ref applyAsFollowerArgs "state" (![ptrT] "args"))) in
          do:  ((struct.field_ref paxosState "state" (![ptrT] "ps")) <-[sliceT] "$r0");;;
          let: "$r0" := (![uint64T] (struct.field_ref applyAsFollowerArgs "nextIndex" (![ptrT] "args"))) in
          do:  ((struct.field_ref paxosState "nextIndex" (![ptrT] "ps")) <-[uint64T] "$r0");;;
          let: "$r0" := #false in
          do:  ((struct.field_ref paxosState "isLeader" (![ptrT] "ps")) <-[boolT] "$r0");;;
          let: "$r0" := ENone in
          do:  ((struct.field_ref applyAsFollowerReply "err" (![ptrT] "reply")) <-[Error] "$r0"))
      else
        let: "$r0" := EEpochStale in
        do:  ((struct.field_ref applyAsFollowerReply "err" (![ptrT] "reply")) <-[Error] "$r0")))
      ) in
    (method_call #paxos.paxos #"Server'ptr" #"withLock" (![ptrT] "s")) "$a0")).

(* NOTE:
   This will vote yes only the first time it's called in an epoch.
   If you have too aggressive of a timeout and end up retrying this, the retry
   might fail because it may be the second execution of enterNewEpoch(epoch) on
   the server.
   Solution: either conservative (maybe double) timeouts, or don't use this for
   leader election, only for coming up with a valid proposal.

   go: server.go:68:18 *)
Definition Server__enterNewEpoch : val :=
  rec: "Server__enterNewEpoch" "s" "args" "reply" :=
    exception_do (let: "s" := (ref_ty ptrT "s") in
    let: "reply" := (ref_ty ptrT "reply") in
    let: "args" := (ref_ty ptrT "args") in
    do:  (let: "$a0" := (λ: "ps",
      exception_do (let: "ps" := (ref_ty ptrT "ps") in
      (if: (![uint64T] (struct.field_ref paxosState "epoch" (![ptrT] "ps"))) ≥ (![uint64T] (struct.field_ref enterNewEpochArgs "epoch" (![ptrT] "args")))
      then
        let: "$r0" := EEpochStale in
        do:  ((struct.field_ref enterNewEpochReply "err" (![ptrT] "reply")) <-[Error] "$r0");;;
        return: (#())
      else do:  #());;;
      let: "$r0" := #false in
      do:  ((struct.field_ref paxosState "isLeader" (![ptrT] "ps")) <-[boolT] "$r0");;;
      let: "$r0" := (![uint64T] (struct.field_ref enterNewEpochArgs "epoch" (![ptrT] "args"))) in
      do:  ((struct.field_ref paxosState "epoch" (![ptrT] "ps")) <-[uint64T] "$r0");;;
      let: "$r0" := (![uint64T] (struct.field_ref paxosState "acceptedEpoch" (![ptrT] "ps"))) in
      do:  ((struct.field_ref enterNewEpochReply "acceptedEpoch" (![ptrT] "reply")) <-[uint64T] "$r0");;;
      let: "$r0" := (![uint64T] (struct.field_ref paxosState "nextIndex" (![ptrT] "ps"))) in
      do:  ((struct.field_ref enterNewEpochReply "nextIndex" (![ptrT] "reply")) <-[uint64T] "$r0");;;
      let: "$r0" := (![sliceT] (struct.field_ref paxosState "state" (![ptrT] "ps"))) in
      do:  ((struct.field_ref enterNewEpochReply "state" (![ptrT] "reply")) <-[sliceT] "$r0"))
      ) in
    (method_call #paxos.paxos #"Server'ptr" #"withLock" (![ptrT] "s")) "$a0")).

(* go: server.go:83:18 *)
Definition Server__TryBecomeLeader : val :=
  rec: "Server__TryBecomeLeader" "s" <> :=
    exception_do (let: "s" := (ref_ty ptrT "s") in
    do:  (let: "$a0" := ((let: "$sl0" := (interface.make #""%go #"string"%go #"started trybecomeleader"%go) in
    slice.literal interfaceT ["$sl0"])) in
    (func_call #log #"Println"%go) "$a0");;;
    do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![ptrT] (struct.field_ref Server "mu" (![ptrT] "s")))) #());;;
    (if: ![boolT] (struct.field_ref paxosState "isLeader" (![ptrT] (struct.field_ref Server "ps" (![ptrT] "s"))))
    then
      do:  (let: "$a0" := ((let: "$sl0" := (interface.make #""%go #"string"%go #"already leader"%go) in
      slice.literal interfaceT ["$sl0"])) in
      (func_call #log #"Println"%go) "$a0");;;
      do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![ptrT] (struct.field_ref Server "mu" (![ptrT] "s")))) #());;;
      return: (#())
    else do:  #());;;
    let: "clerks" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (![sliceT] (struct.field_ref Server "clerks" (![ptrT] "s"))) in
    do:  ("clerks" <-[sliceT] "$r0");;;
    let: "args" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty enterNewEpochArgs (let: "$epoch" := ((![uint64T] (struct.field_ref paxosState "epoch" (![ptrT] (struct.field_ref Server "ps" (![ptrT] "s"))))) + #(W64 1)) in
    struct.make enterNewEpochArgs [{
      "epoch" ::= "$epoch"
    }])) in
    do:  ("args" <-[ptrT] "$r0");;;
    do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![ptrT] (struct.field_ref Server "mu" (![ptrT] "s")))) #());;;
    let: "numReplies" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("numReplies" <-[uint64T] "$r0");;;
    let: "replies" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (slice.make2 ptrT (let: "$a0" := (![sliceT] "clerks") in
    slice.len "$a0")) in
    do:  ("replies" <-[sliceT] "$r0");;;
    let: "mu" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty sync.Mutex (zero_val sync.Mutex)) in
    do:  ("mu" <-[ptrT] "$r0");;;
    let: "numReplies_cond" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (let: "$a0" := (interface.make #sync #"Mutex'ptr" (![ptrT] "mu")) in
    (func_call #sync #"NewCond"%go) "$a0") in
    do:  ("numReplies_cond" <-[ptrT] "$r0");;;
    let: "n" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (let: "$a0" := (![sliceT] "clerks") in
    slice.len "$a0") in
    do:  ("n" <-[uint64T] "$r0");;;
    (let: "ck" := (ref_ty intT (zero_val intT)) in
    let: "i" := (ref_ty intT (zero_val intT)) in
    let: "$range" := (![sliceT] "clerks") in
    slice.for_range ptrT "$range" (λ: "$key" "$value",
      do:  ("ck" <-[ptrT] "$value");;;
      do:  ("i" <-[intT] "$key");;;
      let: "$go" := (λ: <>,
        exception_do (let: "reply" := (ref_ty ptrT (zero_val ptrT)) in
        let: "$r0" := (let: "$a0" := (![ptrT] "args") in
        (method_call #paxos.paxos #"singleClerk'ptr" #"enterNewEpoch" (![ptrT] "ck")) "$a0") in
        do:  ("reply" <-[ptrT] "$r0");;;
        do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![ptrT] "mu")) #());;;
        do:  ("numReplies" <-[uint64T] ((![uint64T] "numReplies") + #(W64 1)));;;
        let: "$r0" := (![ptrT] "reply") in
        do:  ((slice.elem_ref ptrT (![sliceT] "replies") (![intT] "i")) <-[ptrT] "$r0");;;
        (if: (#(W64 2) * (![uint64T] "numReplies")) > (![uint64T] "n")
        then do:  ((method_call #sync #"Cond'ptr" #"Signal" (![ptrT] "numReplies_cond")) #())
        else do:  #());;;
        do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![ptrT] "mu")) #()))
        ) in
      do:  (Fork ("$go" #()))));;;
    do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![ptrT] "mu")) #());;;
    (for: (λ: <>, (#(W64 2) * (![uint64T] "numReplies")) ≤ (![uint64T] "n")); (λ: <>, Skip) := λ: <>,
      do:  ((method_call #sync #"Cond'ptr" #"Wait" (![ptrT] "numReplies_cond")) #()));;;
    let: "latestReply" := (ref_ty ptrT (zero_val ptrT)) in
    let: "numSuccesses" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("numSuccesses" <-[uint64T] "$r0");;;
    (let: "reply" := (ref_ty intT (zero_val intT)) in
    let: "$range" := (![sliceT] "replies") in
    slice.for_range ptrT "$range" (λ: "$key" "$value",
      do:  ("reply" <-[ptrT] "$value");;;
      do:  "$key";;;
      (if: (![ptrT] "reply") ≠ #null
      then
        (if: (![Error] (struct.field_ref enterNewEpochReply "err" (![ptrT] "reply"))) = ENone
        then
          (if: (![uint64T] "numSuccesses") = #(W64 0)
          then
            let: "$r0" := (![ptrT] "reply") in
            do:  ("latestReply" <-[ptrT] "$r0")
          else
            (if: (![uint64T] (struct.field_ref enterNewEpochReply "acceptedEpoch" (![ptrT] "latestReply"))) < (![uint64T] (struct.field_ref enterNewEpochReply "acceptedEpoch" (![ptrT] "reply")))
            then
              let: "$r0" := (![ptrT] "reply") in
              do:  ("latestReply" <-[ptrT] "$r0")
            else
              (if: ((![uint64T] (struct.field_ref enterNewEpochReply "acceptedEpoch" (![ptrT] "latestReply"))) = (![uint64T] (struct.field_ref enterNewEpochReply "acceptedEpoch" (![ptrT] "reply")))) && ((![uint64T] (struct.field_ref enterNewEpochReply "nextIndex" (![ptrT] "reply"))) > (![uint64T] (struct.field_ref enterNewEpochReply "nextIndex" (![ptrT] "latestReply"))))
              then
                let: "$r0" := (![ptrT] "reply") in
                do:  ("latestReply" <-[ptrT] "$r0")
              else do:  #())));;;
          do:  ("numSuccesses" <-[uint64T] ((![uint64T] "numSuccesses") + #(W64 1)))
        else do:  #())
      else do:  #())));;;
    (if: (#(W64 2) * (![uint64T] "numSuccesses")) > (![uint64T] "n")
    then
      do:  (let: "$a0" := (λ: "ps",
        exception_do (let: "ps" := (ref_ty ptrT "ps") in
        (if: (![uint64T] (struct.field_ref paxosState "epoch" (![ptrT] "ps"))) ≤ (![uint64T] (struct.field_ref enterNewEpochArgs "epoch" (![ptrT] "args")))
        then
          do:  (let: "$a0" := #"succeeded becomeleader in epoch %d
          "%go in
          let: "$a1" := ((let: "$sl0" := (interface.make #""%go #"uint64"%go (![uint64T] (struct.field_ref enterNewEpochArgs "epoch" (![ptrT] "args")))) in
          slice.literal interfaceT ["$sl0"])) in
          (func_call #log #"Printf"%go) "$a0" "$a1");;;
          let: "$r0" := (![uint64T] (struct.field_ref enterNewEpochArgs "epoch" (![ptrT] "args"))) in
          do:  ((struct.field_ref paxosState "epoch" (![ptrT] "ps")) <-[uint64T] "$r0");;;
          let: "$r0" := #true in
          do:  ((struct.field_ref paxosState "isLeader" (![ptrT] "ps")) <-[boolT] "$r0");;;
          let: "$r0" := (![uint64T] (struct.field_ref paxosState "epoch" (![ptrT] "ps"))) in
          do:  ((struct.field_ref paxosState "acceptedEpoch" (![ptrT] "ps")) <-[uint64T] "$r0");;;
          let: "$r0" := (![uint64T] (struct.field_ref enterNewEpochReply "nextIndex" (![ptrT] "latestReply"))) in
          do:  ((struct.field_ref paxosState "nextIndex" (![ptrT] "ps")) <-[uint64T] "$r0");;;
          let: "$r0" := (![sliceT] (struct.field_ref enterNewEpochReply "state" (![ptrT] "latestReply"))) in
          do:  ((struct.field_ref paxosState "state" (![ptrT] "ps")) <-[sliceT] "$r0")
        else do:  #()))
        ) in
      (method_call #paxos.paxos #"Server'ptr" #"withLock" (![ptrT] "s")) "$a0");;;
      do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![ptrT] "mu")) #())
    else
      do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![ptrT] "mu")) #());;;
      do:  (let: "$a0" := ((let: "$sl0" := (interface.make #""%go #"string"%go #"failed becomeleader"%go) in
      slice.literal interfaceT ["$sl0"])) in
      (func_call #log #"Println"%go) "$a0"))).

(* go: server.go:165:18 *)
Definition Server__TryAcquire : val :=
  rec: "Server__TryAcquire" "s" <> :=
    exception_do (let: "s" := (ref_ty ptrT "s") in
    let: "retErr" := (ref_ty Error (zero_val Error)) in
    do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![ptrT] (struct.field_ref Server "mu" (![ptrT] "s")))) #());;;
    (if: (~ (![boolT] (struct.field_ref paxosState "isLeader" (![ptrT] (struct.field_ref Server "ps" (![ptrT] "s"))))))
    then
      do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![ptrT] (struct.field_ref Server "mu" (![ptrT] "s")))) #());;;
      let: "n" := (ref_ty ptrT (zero_val ptrT)) in
      return: (ENotLeader, ![ptrT] "n", #func.nil)
    else do:  #());;;
    let: "tryRelease" := (ref_ty funcT (zero_val funcT)) in
    let: "$r0" := (λ: <>,
      exception_do (let: "$r0" := (let: "$a0" := (![uint64T] (struct.field_ref paxosState "nextIndex" (![ptrT] (struct.field_ref Server "ps" (![ptrT] "s"))))) in
      let: "$a1" := #(W64 1) in
      (func_call #std #"SumAssumeNoOverflow"%go) "$a0" "$a1") in
      do:  ((struct.field_ref paxosState "nextIndex" (![ptrT] (struct.field_ref Server "ps" (![ptrT] "s")))) <-[uint64T] "$r0");;;
      let: "args" := (ref_ty ptrT (zero_val ptrT)) in
      let: "$r0" := (ref_ty applyAsFollowerArgs (let: "$epoch" := (![uint64T] (struct.field_ref paxosState "epoch" (![ptrT] (struct.field_ref Server "ps" (![ptrT] "s"))))) in
      let: "$nextIndex" := (![uint64T] (struct.field_ref paxosState "nextIndex" (![ptrT] (struct.field_ref Server "ps" (![ptrT] "s"))))) in
      let: "$state" := (![sliceT] (struct.field_ref paxosState "state" (![ptrT] (struct.field_ref Server "ps" (![ptrT] "s"))))) in
      struct.make applyAsFollowerArgs [{
        "epoch" ::= "$epoch";
        "nextIndex" ::= "$nextIndex";
        "state" ::= "$state"
      }])) in
      do:  ("args" <-[ptrT] "$r0");;;
      let: "waitFn" := (ref_ty funcT (zero_val funcT)) in
      let: "$r0" := (let: "$a0" := (let: "$a0" := (![ptrT] (struct.field_ref Server "ps" (![ptrT] "s"))) in
      (func_call #paxos.paxos #"encodePaxosState"%go) "$a0") in
      (method_call #asyncfile #"AsyncFile'ptr" #"Write" (![ptrT] (struct.field_ref Server "storage" (![ptrT] "s")))) "$a0") in
      do:  ("waitFn" <-[funcT] "$r0");;;
      do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![ptrT] (struct.field_ref Server "mu" (![ptrT] "s")))) #());;;
      do:  ((![funcT] "waitFn") #());;;
      let: "clerks" := (ref_ty sliceT (zero_val sliceT)) in
      let: "$r0" := (![sliceT] (struct.field_ref Server "clerks" (![ptrT] "s"))) in
      do:  ("clerks" <-[sliceT] "$r0");;;
      let: "numReplies" := (ref_ty uint64T (zero_val uint64T)) in
      let: "$r0" := #(W64 0) in
      do:  ("numReplies" <-[uint64T] "$r0");;;
      let: "replies" := (ref_ty sliceT (zero_val sliceT)) in
      let: "$r0" := (slice.make2 ptrT (let: "$a0" := (![sliceT] "clerks") in
      slice.len "$a0")) in
      do:  ("replies" <-[sliceT] "$r0");;;
      let: "mu" := (ref_ty ptrT (zero_val ptrT)) in
      let: "$r0" := (ref_ty sync.Mutex (zero_val sync.Mutex)) in
      do:  ("mu" <-[ptrT] "$r0");;;
      let: "numReplies_cond" := (ref_ty ptrT (zero_val ptrT)) in
      let: "$r0" := (let: "$a0" := (interface.make #sync #"Mutex'ptr" (![ptrT] "mu")) in
      (func_call #sync #"NewCond"%go) "$a0") in
      do:  ("numReplies_cond" <-[ptrT] "$r0");;;
      let: "n" := (ref_ty uint64T (zero_val uint64T)) in
      let: "$r0" := (let: "$a0" := (![sliceT] "clerks") in
      slice.len "$a0") in
      do:  ("n" <-[uint64T] "$r0");;;
      (let: "ck" := (ref_ty intT (zero_val intT)) in
      let: "i" := (ref_ty intT (zero_val intT)) in
      let: "$range" := (![sliceT] "clerks") in
      slice.for_range ptrT "$range" (λ: "$key" "$value",
        do:  ("ck" <-[ptrT] "$value");;;
        do:  ("i" <-[intT] "$key");;;
        let: "ck" := (ref_ty ptrT (zero_val ptrT)) in
        let: "$r0" := (![ptrT] "ck") in
        do:  ("ck" <-[ptrT] "$r0");;;
        let: "i" := (ref_ty intT (zero_val intT)) in
        let: "$r0" := (![intT] "i") in
        do:  ("i" <-[intT] "$r0");;;
        let: "$go" := (λ: <>,
          exception_do (let: "reply" := (ref_ty ptrT (zero_val ptrT)) in
          let: "$r0" := (let: "$a0" := (![ptrT] "args") in
          (method_call #paxos.paxos #"singleClerk'ptr" #"applyAsFollower" (![ptrT] "ck")) "$a0") in
          do:  ("reply" <-[ptrT] "$r0");;;
          do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![ptrT] "mu")) #());;;
          do:  ("numReplies" <-[uint64T] ((![uint64T] "numReplies") + #(W64 1)));;;
          let: "$r0" := (![ptrT] "reply") in
          do:  ((slice.elem_ref ptrT (![sliceT] "replies") (![intT] "i")) <-[ptrT] "$r0");;;
          (if: (#(W64 2) * (![uint64T] "numReplies")) > (![uint64T] "n")
          then do:  ((method_call #sync #"Cond'ptr" #"Signal" (![ptrT] "numReplies_cond")) #())
          else do:  #());;;
          do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![ptrT] "mu")) #()))
          ) in
        do:  (Fork ("$go" #()))));;;
      do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![ptrT] "mu")) #());;;
      (for: (λ: <>, (#(W64 2) * (![uint64T] "numReplies")) ≤ (![uint64T] "n")); (λ: <>, Skip) := λ: <>,
        do:  ((method_call #sync #"Cond'ptr" #"Wait" (![ptrT] "numReplies_cond")) #()));;;
      let: "numSuccesses" := (ref_ty uint64T (zero_val uint64T)) in
      let: "$r0" := #(W64 0) in
      do:  ("numSuccesses" <-[uint64T] "$r0");;;
      (let: "reply" := (ref_ty intT (zero_val intT)) in
      let: "$range" := (![sliceT] "replies") in
      slice.for_range ptrT "$range" (λ: "$key" "$value",
        do:  ("reply" <-[ptrT] "$value");;;
        do:  "$key";;;
        (if: (![ptrT] "reply") ≠ #null
        then
          (if: (![Error] (struct.field_ref applyAsFollowerReply "err" (![ptrT] "reply"))) = ENone
          then do:  ("numSuccesses" <-[uint64T] ((![uint64T] "numSuccesses") + #(W64 1)))
          else do:  #())
        else do:  #())));;;
      (if: (#(W64 2) * (![uint64T] "numSuccesses")) > (![uint64T] "n")
      then
        let: "$r0" := ENone in
        do:  ("retErr" <-[Error] "$r0")
      else
        let: "$r0" := EEpochStale in
        do:  ("retErr" <-[Error] "$r0"));;;
      return: (![Error] "retErr"))
      ) in
    do:  ("tryRelease" <-[funcT] "$r0");;;
    return: (ENone, struct.field_ref paxosState "state" (![ptrT] (struct.field_ref Server "ps" (![ptrT] "s"))), ![funcT] "tryRelease")).

(* go: server.go:235:18 *)
Definition Server__WeakRead : val :=
  rec: "Server__WeakRead" "s" <> :=
    exception_do (let: "s" := (ref_ty ptrT "s") in
    do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![ptrT] (struct.field_ref Server "mu" (![ptrT] "s")))) #());;;
    let: "ret" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (![sliceT] (struct.field_ref paxosState "state" (![ptrT] (struct.field_ref Server "ps" (![ptrT] "s"))))) in
    do:  ("ret" <-[sliceT] "$r0");;;
    do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![ptrT] (struct.field_ref Server "mu" (![ptrT] "s")))) #());;;
    return: (![sliceT] "ret")).

(* go: server.go:242:6 *)
Definition makeServer : val :=
  rec: "makeServer" "fname" "initstate" "config" :=
    exception_do (let: "config" := (ref_ty sliceT "config") in
    let: "initstate" := (ref_ty sliceT "initstate") in
    let: "fname" := (ref_ty stringT "fname") in
    let: "s" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty Server (zero_val Server)) in
    do:  ("s" <-[ptrT] "$r0");;;
    let: "$r0" := (ref_ty sync.Mutex (zero_val sync.Mutex)) in
    do:  ((struct.field_ref Server "mu" (![ptrT] "s")) <-[ptrT] "$r0");;;
    let: "$r0" := (slice.make2 ptrT #(W64 0)) in
    do:  ((struct.field_ref Server "clerks" (![ptrT] "s")) <-[sliceT] "$r0");;;
    (let: "host" := (ref_ty intT (zero_val intT)) in
    let: "$range" := (![sliceT] "config") in
    slice.for_range uint64T "$range" (λ: "$key" "$value",
      do:  ("host" <-[uint64T] "$value");;;
      do:  "$key";;;
      let: "$r0" := (let: "$a0" := (![sliceT] (struct.field_ref Server "clerks" (![ptrT] "s"))) in
      let: "$a1" := ((let: "$sl0" := (let: "$a0" := (![uint64T] "host") in
      (func_call #paxos.paxos #"MakeSingleClerk"%go) "$a0") in
      slice.literal ptrT ["$sl0"])) in
      (slice.append sliceT) "$a0" "$a1") in
      do:  ((struct.field_ref Server "clerks" (![ptrT] "s")) <-[sliceT] "$r0")));;;
    let: "encstate" := (ref_ty sliceT (zero_val sliceT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![stringT] "fname") in
    (func_call #asyncfile #"MakeAsyncFile"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("encstate" <-[sliceT] "$r0");;;
    do:  ((struct.field_ref Server "storage" (![ptrT] "s")) <-[ptrT] "$r1");;;
    (if: (let: "$a0" := (![sliceT] "encstate") in
    slice.len "$a0") = #(W64 0)
    then
      let: "$r0" := (ref_ty paxosState (zero_val paxosState)) in
      do:  ((struct.field_ref Server "ps" (![ptrT] "s")) <-[ptrT] "$r0");;;
      let: "$r0" := (![sliceT] "initstate") in
      do:  ((struct.field_ref paxosState "state" (![ptrT] (struct.field_ref Server "ps" (![ptrT] "s")))) <-[sliceT] "$r0")
    else
      let: "$r0" := (let: "$a0" := (![sliceT] "encstate") in
      (func_call #paxos.paxos #"decodePaxosState"%go) "$a0") in
      do:  ((struct.field_ref Server "ps" (![ptrT] "s")) <-[ptrT] "$r0"));;;
    return: (![ptrT] "s")).

(* go: server.go:262:6 *)
Definition StartServer : val :=
  rec: "StartServer" "fname" "initstate" "me" "config" :=
    exception_do (let: "config" := (ref_ty sliceT "config") in
    let: "me" := (ref_ty uint64T "me") in
    let: "initstate" := (ref_ty sliceT "initstate") in
    let: "fname" := (ref_ty stringT "fname") in
    let: "s" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (let: "$a0" := (![stringT] "fname") in
    let: "$a1" := (![sliceT] "initstate") in
    let: "$a2" := (![sliceT] "config") in
    (func_call #paxos.paxos #"makeServer"%go) "$a0" "$a1" "$a2") in
    do:  ("s" <-[ptrT] "$r0");;;
    let: "handlers" := (ref_ty (mapT uint64T funcT) (zero_val (mapT uint64T funcT))) in
    let: "$r0" := (map.make uint64T funcT #()) in
    do:  ("handlers" <-[mapT uint64T funcT] "$r0");;;
    let: "$r0" := (λ: "raw_args" "raw_reply",
      exception_do (let: "raw_reply" := (ref_ty ptrT "raw_reply") in
      let: "raw_args" := (ref_ty sliceT "raw_args") in
      let: "reply" := (ref_ty ptrT (zero_val ptrT)) in
      let: "$r0" := (ref_ty applyAsFollowerReply (zero_val applyAsFollowerReply)) in
      do:  ("reply" <-[ptrT] "$r0");;;
      let: "args" := (ref_ty ptrT (zero_val ptrT)) in
      let: "$r0" := (let: "$a0" := (![sliceT] "raw_args") in
      (func_call #paxos.paxos #"decodeApplyAsFollowerArgs"%go) "$a0") in
      do:  ("args" <-[ptrT] "$r0");;;
      do:  (let: "$a0" := (![ptrT] "args") in
      let: "$a1" := (![ptrT] "reply") in
      (method_call #paxos.paxos #"Server'ptr" #"applyAsFollower" (![ptrT] "s")) "$a0" "$a1");;;
      let: "$r0" := (let: "$a0" := (![ptrT] "reply") in
      (func_call #paxos.paxos #"encodeApplyAsFollowerReply"%go) "$a0") in
      do:  ((![ptrT] "raw_reply") <-[sliceT] "$r0"))
      ) in
    do:  (map.insert (![mapT uint64T funcT] "handlers") RPC_APPLY_AS_FOLLOWER "$r0");;;
    let: "$r0" := (λ: "raw_args" "raw_reply",
      exception_do (let: "raw_reply" := (ref_ty ptrT "raw_reply") in
      let: "raw_args" := (ref_ty sliceT "raw_args") in
      let: "reply" := (ref_ty ptrT (zero_val ptrT)) in
      let: "$r0" := (ref_ty enterNewEpochReply (zero_val enterNewEpochReply)) in
      do:  ("reply" <-[ptrT] "$r0");;;
      let: "args" := (ref_ty ptrT (zero_val ptrT)) in
      let: "$r0" := (let: "$a0" := (![sliceT] "raw_args") in
      (func_call #paxos.paxos #"decodeEnterNewEpochArgs"%go) "$a0") in
      do:  ("args" <-[ptrT] "$r0");;;
      do:  (let: "$a0" := (![ptrT] "args") in
      let: "$a1" := (![ptrT] "reply") in
      (method_call #paxos.paxos #"Server'ptr" #"enterNewEpoch" (![ptrT] "s")) "$a0" "$a1");;;
      let: "$r0" := (let: "$a0" := (![ptrT] "reply") in
      (func_call #paxos.paxos #"encodeEnterNewEpochReply"%go) "$a0") in
      do:  ((![ptrT] "raw_reply") <-[sliceT] "$r0"))
      ) in
    do:  (map.insert (![mapT uint64T funcT] "handlers") RPC_ENTER_NEW_EPOCH "$r0");;;
    let: "$r0" := (λ: "raw_args" "raw_reply",
      exception_do (let: "raw_reply" := (ref_ty ptrT "raw_reply") in
      let: "raw_args" := (ref_ty sliceT "raw_args") in
      do:  ((method_call #paxos.paxos #"Server'ptr" #"TryBecomeLeader" (![ptrT] "s")) #()))
      ) in
    do:  (map.insert (![mapT uint64T funcT] "handlers") RPC_BECOME_LEADER "$r0");;;
    let: "r" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (let: "$a0" := (![mapT uint64T funcT] "handlers") in
    (func_call #urpc #"MakeServer"%go) "$a0") in
    do:  ("r" <-[ptrT] "$r0");;;
    do:  (let: "$a0" := (![uint64T] "me") in
    (method_call #urpc #"Server'ptr" #"Serve" (![ptrT] "r")) "$a0");;;
    return: (![ptrT] "s")).

Definition vars' : list (go_string * go_type) := [].

Definition functions' : list (go_string * val) := [("MakeSingleClerk"%go, MakeSingleClerk); ("encodeApplyAsFollowerArgs"%go, encodeApplyAsFollowerArgs); ("decodeApplyAsFollowerArgs"%go, decodeApplyAsFollowerArgs); ("decodeApplyAsFollowerReply"%go, decodeApplyAsFollowerReply); ("encodeApplyAsFollowerReply"%go, encodeApplyAsFollowerReply); ("encodeEnterNewEpochArgs"%go, encodeEnterNewEpochArgs); ("decodeEnterNewEpochArgs"%go, decodeEnterNewEpochArgs); ("decodeEnterNewEpochReply"%go, decodeEnterNewEpochReply); ("encodeEnterNewEpochReply"%go, encodeEnterNewEpochReply); ("encodeApplyReply"%go, encodeApplyReply); ("decodeApplyReply"%go, decodeApplyReply); ("boolToU64"%go, boolToU64); ("encodePaxosState"%go, encodePaxosState); ("decodePaxosState"%go, decodePaxosState); ("makeServer"%go, makeServer); ("StartServer"%go, StartServer)].

Definition msets' : list (go_string * (list (go_string * val))) := [("singleClerk"%go, []); ("singleClerk'ptr"%go, [("TryBecomeLeader"%go, singleClerk__TryBecomeLeader); ("applyAsFollower"%go, singleClerk__applyAsFollower); ("enterNewEpoch"%go, singleClerk__enterNewEpoch)]); ("Error"%go, []); ("Error'ptr"%go, []); ("applyAsFollowerArgs"%go, []); ("applyAsFollowerArgs'ptr"%go, []); ("applyAsFollowerReply"%go, []); ("applyAsFollowerReply'ptr"%go, []); ("enterNewEpochArgs"%go, []); ("enterNewEpochArgs'ptr"%go, []); ("enterNewEpochReply"%go, []); ("enterNewEpochReply'ptr"%go, []); ("applyReply"%go, []); ("applyReply'ptr"%go, []); ("paxosState"%go, []); ("paxosState'ptr"%go, []); ("Server"%go, []); ("Server'ptr"%go, [("TryAcquire"%go, Server__TryAcquire); ("TryBecomeLeader"%go, Server__TryBecomeLeader); ("WeakRead"%go, Server__WeakRead); ("applyAsFollower"%go, Server__applyAsFollower); ("enterNewEpoch"%go, Server__enterNewEpoch); ("withLock"%go, Server__withLock)])].

#[global] Instance info' : PkgInfo paxos.paxos :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [grove_ffi; reconnectclient; marshal; log; sync; std; asyncfile; urpc];
  |}.

Definition initialize' : val :=
  rec: "initialize'" <> :=
    globals.package_init paxos.paxos (λ: <>,
      exception_do (do:  urpc.initialize';;;
      do:  asyncfile.initialize';;;
      do:  std.initialize';;;
      do:  sync.initialize';;;
      do:  log.initialize';;;
      do:  marshal.initialize';;;
      do:  reconnectclient.initialize';;;
      do:  grove_ffi.initialize')
      ).

End code.
End paxos.
