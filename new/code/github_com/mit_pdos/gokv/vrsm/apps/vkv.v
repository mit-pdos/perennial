(* autogenerated from github.com/mit-pdos/gokv/vrsm/apps/vkv *)
Require Export New.code.github_com.mit_pdos.gokv.grove_ffi.
Require Export New.code.github_com.mit_pdos.gokv.kv.
Require Export New.code.github_com.mit_pdos.gokv.map_string_marshal.
Require Export New.code.github_com.mit_pdos.gokv.vrsm.apps.exactlyonce.
Require Export New.code.github_com.mit_pdos.gokv.vrsm.apps.vkv.condputargs_gk.
Require Export New.code.github_com.mit_pdos.gokv.vrsm.apps.vkv.getargs_gk.
Require Export New.code.github_com.mit_pdos.gokv.vrsm.apps.vkv.putargs_gk.
Require Export New.code.github_com.mit_pdos.gokv.vrsm.storage.
Require Export New.code.sync.

From New.golang Require Import defn.
Definition vkv : go_string := "github.com/mit-pdos/gokv/vrsm/apps/vkv".

From New Require Import grove_prelude.
Module vkv.

Module Clerk. Definition id : go_string := "github.com/mit-pdos/gokv/vrsm/apps/vkv.Clerk"%go. End Clerk.
Module ClerkPool. Definition id : go_string := "github.com/mit-pdos/gokv/vrsm/apps/vkv.ClerkPool"%go. End ClerkPool.
Module KVState. Definition id : go_string := "github.com/mit-pdos/gokv/vrsm/apps/vkv.KVState"%go. End KVState.

Section code.


Definition Clerk : go_type := structT [
  "cl" :: ptrT
].

Definition MakeClerk : go_string := "github.com/mit-pdos/gokv/vrsm/apps/vkv.MakeClerk"%go.

(* go: clerk.go:15:6 *)
Definition MakeClerkⁱᵐᵖˡ : val :=
  λ: "confHosts",
    exception_do (let: "confHosts" := (mem.alloc "confHosts") in
    return: (mem.alloc (let: "$cl" := (let: "$a0" := (![#sliceT] "confHosts") in
     (func_call #exactlyonce.MakeClerk) "$a0") in
     struct.make #Clerk [{
       "cl" ::= "$cl"
     }]))).

(* go: clerk.go:19:18 *)
Definition Clerk__Putⁱᵐᵖˡ : val :=
  λ: "ck" "key" "val",
    exception_do (let: "ck" := (mem.alloc "ck") in
    let: "val" := (mem.alloc "val") in
    let: "key" := (mem.alloc "key") in
    let: "args" := (mem.alloc (type.zero_val #putargs_gk.S)) in
    let: "$r0" := (let: "$Key" := (![#stringT] "key") in
    let: "$Val" := (![#stringT] "val") in
    struct.make #putargs_gk.S [{
      "Key" ::= "$Key";
      "Val" ::= "$Val"
    }]) in
    do:  ("args" <-[#putargs_gk.S] "$r0");;;
    do:  (let: "$a0" := (let: "$a0" := (slice.make2 #byteT #(W64 0)) in
    let: "$a1" := (![#putargs_gk.S] "args") in
    (func_call #putargs_gk.Marshal) "$a0" "$a1") in
    (method_call #(ptrT.id exactlyonce.Clerk.id) #"ApplyExactlyOnce"%go (![#ptrT] (struct.field_ref #Clerk #"cl"%go (![#ptrT] "ck")))) "$a0");;;
    return: #()).

(* go: clerk.go:27:18 *)
Definition Clerk__Getⁱᵐᵖˡ : val :=
  λ: "ck" "key",
    exception_do (let: "ck" := (mem.alloc "ck") in
    let: "key" := (mem.alloc "key") in
    let: "args" := (mem.alloc (type.zero_val #getargs_gk.S)) in
    let: "$r0" := (let: "$Get" := (![#stringT] "key") in
    struct.make #getargs_gk.S [{
      "Get" ::= "$Get"
    }]) in
    do:  ("args" <-[#getargs_gk.S] "$r0");;;
    return: (string.from_bytes (let: "$a0" := (let: "$a0" := (slice.make2 #byteT #(W64 0)) in
     let: "$a1" := (![#getargs_gk.S] "args") in
     (func_call #getargs_gk.Marshal) "$a0" "$a1") in
     (method_call #(ptrT.id exactlyonce.Clerk.id) #"ApplyReadonly"%go (![#ptrT] (struct.field_ref #Clerk #"cl"%go (![#ptrT] "ck")))) "$a0"))).

(* go: clerk.go:34:18 *)
Definition Clerk__CondPutⁱᵐᵖˡ : val :=
  λ: "ck" "key" "expect" "val",
    exception_do (let: "ck" := (mem.alloc "ck") in
    let: "val" := (mem.alloc "val") in
    let: "expect" := (mem.alloc "expect") in
    let: "key" := (mem.alloc "key") in
    let: "args" := (mem.alloc (type.zero_val #condputargs_gk.S)) in
    let: "$r0" := (let: "$Key" := (![#stringT] "key") in
    let: "$Expect" := (![#stringT] "expect") in
    let: "$Val" := (![#stringT] "val") in
    struct.make #condputargs_gk.S [{
      "Key" ::= "$Key";
      "Expect" ::= "$Expect";
      "Val" ::= "$Val"
    }]) in
    do:  ("args" <-[#condputargs_gk.S] "$r0");;;
    return: (string.from_bytes (let: "$a0" := (let: "$a0" := (slice.make2 #byteT #(W64 0)) in
     let: "$a1" := (![#condputargs_gk.S] "args") in
     (func_call #condputargs_gk.Marshal) "$a0" "$a1") in
     (method_call #(ptrT.id exactlyonce.Clerk.id) #"ApplyExactlyOnce"%go (![#ptrT] (struct.field_ref #Clerk #"cl"%go (![#ptrT] "ck")))) "$a0"))).

Definition ClerkPool : go_type := structT [
  "mu" :: ptrT;
  "cls" :: sliceT;
  "confHosts" :: sliceT
].

Definition MakeClerkPool : go_string := "github.com/mit-pdos/gokv/vrsm/apps/vkv.MakeClerkPool"%go.

(* go: clerkpool.go:18:6 *)
Definition MakeClerkPoolⁱᵐᵖˡ : val :=
  λ: "confHosts",
    exception_do (let: "confHosts" := (mem.alloc "confHosts") in
    return: (mem.alloc (let: "$mu" := (mem.alloc (type.zero_val #sync.Mutex)) in
     let: "$cls" := (slice.make2 #ptrT #(W64 0)) in
     let: "$confHosts" := (![#sliceT] "confHosts") in
     struct.make #ClerkPool [{
       "mu" ::= "$mu";
       "cls" ::= "$cls";
       "confHosts" ::= "$confHosts"
     }]))).

(* TODO: get rid of stale clerks from the ck.cls list?
   TODO: keep failed clerks out of ck.cls list? Maybe f(cl) can return an
   optional error saying "get rid of cl".

   go: clerkpool.go:29:22 *)
Definition ClerkPool__doWithClerkⁱᵐᵖˡ : val :=
  λ: "ck" "f",
    exception_do (let: "ck" := (mem.alloc "ck") in
    let: "f" := (mem.alloc "f") in
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] (struct.field_ref #ClerkPool #"mu"%go (![#ptrT] "ck")))) #());;;
    let: "cl" := (mem.alloc (type.zero_val #ptrT)) in
    (if: int_gt (let: "$a0" := (![#sliceT] (struct.field_ref #ClerkPool #"cls"%go (![#ptrT] "ck"))) in
    slice.len "$a0") #(W64 0)
    then
      let: "$r0" := (![#ptrT] (slice.elem_ref #ptrT (![#sliceT] (struct.field_ref #ClerkPool #"cls"%go (![#ptrT] "ck"))) #(W64 0))) in
      do:  ("cl" <-[#ptrT] "$r0");;;
      let: "$r0" := (let: "$s" := (![#sliceT] (struct.field_ref #ClerkPool #"cls"%go (![#ptrT] "ck"))) in
      slice.slice #ptrT "$s" #(W64 1) (slice.len "$s")) in
      do:  ((struct.field_ref #ClerkPool #"cls"%go (![#ptrT] "ck")) <-[#sliceT] "$r0");;;
      do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref #ClerkPool #"mu"%go (![#ptrT] "ck")))) #());;;
      do:  (let: "$a0" := (![#ptrT] "cl") in
      (![#funcT] "f") "$a0");;;
      do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] (struct.field_ref #ClerkPool #"mu"%go (![#ptrT] "ck")))) #());;;
      let: "$r0" := (let: "$a0" := (![#sliceT] (struct.field_ref #ClerkPool #"cls"%go (![#ptrT] "ck"))) in
      let: "$a1" := ((let: "$sl0" := (![#ptrT] "cl") in
      slice.literal #ptrT ["$sl0"])) in
      (slice.append #ptrT) "$a0" "$a1") in
      do:  ((struct.field_ref #ClerkPool #"cls"%go (![#ptrT] "ck")) <-[#sliceT] "$r0");;;
      do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref #ClerkPool #"mu"%go (![#ptrT] "ck")))) #())
    else
      do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref #ClerkPool #"mu"%go (![#ptrT] "ck")))) #());;;
      let: "$r0" := (let: "$a0" := (![#sliceT] (struct.field_ref #ClerkPool #"confHosts"%go (![#ptrT] "ck"))) in
      (func_call #MakeClerk) "$a0") in
      do:  ("cl" <-[#ptrT] "$r0");;;
      do:  (let: "$a0" := (![#ptrT] "cl") in
      (![#funcT] "f") "$a0");;;
      do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] (struct.field_ref #ClerkPool #"mu"%go (![#ptrT] "ck")))) #());;;
      let: "$r0" := (let: "$a0" := (![#sliceT] (struct.field_ref #ClerkPool #"cls"%go (![#ptrT] "ck"))) in
      let: "$a1" := ((let: "$sl0" := (![#ptrT] "cl") in
      slice.literal #ptrT ["$sl0"])) in
      (slice.append #ptrT) "$a0" "$a1") in
      do:  ((struct.field_ref #ClerkPool #"cls"%go (![#ptrT] "ck")) <-[#sliceT] "$r0");;;
      do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref #ClerkPool #"mu"%go (![#ptrT] "ck")))) #()));;;
    return: #()).

(* go: clerkpool.go:55:22 *)
Definition ClerkPool__Putⁱᵐᵖˡ : val :=
  λ: "ck" "key" "val",
    exception_do (let: "ck" := (mem.alloc "ck") in
    let: "val" := (mem.alloc "val") in
    let: "key" := (mem.alloc "key") in
    do:  (let: "$a0" := (λ: "ck",
      exception_do (let: "ck" := (mem.alloc "ck") in
      do:  (let: "$a0" := (![#stringT] "key") in
      let: "$a1" := (![#stringT] "val") in
      (method_call #(ptrT.id Clerk.id) #"Put"%go (![#ptrT] "ck")) "$a0" "$a1");;;
      return: #())
      ) in
    (method_call #(ptrT.id ClerkPool.id) #"doWithClerk"%go (![#ptrT] "ck")) "$a0");;;
    return: #()).

(* go: clerkpool.go:61:22 *)
Definition ClerkPool__Getⁱᵐᵖˡ : val :=
  λ: "ck" "key",
    exception_do (let: "ck" := (mem.alloc "ck") in
    let: "key" := (mem.alloc "key") in
    let: "ret" := (mem.alloc (type.zero_val #stringT)) in
    do:  (let: "$a0" := (λ: "ck",
      exception_do (let: "ck" := (mem.alloc "ck") in
      let: "$r0" := (let: "$a0" := (![#stringT] "key") in
      (method_call #(ptrT.id Clerk.id) #"Get"%go (![#ptrT] "ck")) "$a0") in
      do:  ("ret" <-[#stringT] "$r0");;;
      return: #())
      ) in
    (method_call #(ptrT.id ClerkPool.id) #"doWithClerk"%go (![#ptrT] "ck")) "$a0");;;
    return: (![#stringT] "ret")).

(* go: clerkpool.go:69:22 *)
Definition ClerkPool__ConditionalPutⁱᵐᵖˡ : val :=
  λ: "ck" "key" "expect" "val",
    exception_do (let: "ck" := (mem.alloc "ck") in
    let: "val" := (mem.alloc "val") in
    let: "expect" := (mem.alloc "expect") in
    let: "key" := (mem.alloc "key") in
    let: "ret" := (mem.alloc (type.zero_val #stringT)) in
    do:  (let: "$a0" := (λ: "ck",
      exception_do (let: "ck" := (mem.alloc "ck") in
      let: "$r0" := (let: "$a0" := (![#stringT] "key") in
      let: "$a1" := (![#stringT] "expect") in
      let: "$a2" := (![#stringT] "val") in
      (method_call #(ptrT.id Clerk.id) #"CondPut"%go (![#ptrT] "ck")) "$a0" "$a1" "$a2") in
      do:  ("ret" <-[#stringT] "$r0");;;
      return: #())
      ) in
    (method_call #(ptrT.id ClerkPool.id) #"doWithClerk"%go (![#ptrT] "ck")) "$a0");;;
    return: (![#stringT] "ret")).

Definition MakeKv : go_string := "github.com/mit-pdos/gokv/vrsm/apps/vkv.MakeKv"%go.

(* go: clerkpool.go:77:6 *)
Definition MakeKvⁱᵐᵖˡ : val :=
  λ: "confHosts",
    exception_do (let: "confHosts" := (mem.alloc "confHosts") in
    let: "ck" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "confHosts") in
    (func_call #MakeClerkPool) "$a0") in
    do:  ("ck" <-[#ptrT] "$r0");;;
    return: (interface.make #(ptrT.id ClerkPool.id) (![#ptrT] "ck"))).

Definition KVState : go_type := structT [
  "kvs" :: mapT stringT stringT;
  "vnums" :: mapT stringT uint64T;
  "minVnum" :: uint64T
].

Definition OP_PUT : expr := #(W8 0).

Definition OP_GET : expr := #(W8 1).

Definition OP_COND_PUT : expr := #(W8 2).

(* go: server.go:31:19 *)
Definition KVState__putⁱᵐᵖˡ : val :=
  λ: "s" "args",
    exception_do (let: "s" := (mem.alloc "s") in
    let: "args" := (mem.alloc "args") in
    let: "$r0" := (![#stringT] (struct.field_ref #putargs_gk.S #"Val"%go (![#ptrT] "args"))) in
    do:  (map.insert (![type.mapT #stringT #stringT] (struct.field_ref #KVState #"kvs"%go (![#ptrT] "s"))) (![#stringT] (struct.field_ref #putargs_gk.S #"Key"%go (![#ptrT] "args"))) "$r0");;;
    return: (slice.make2 #byteT #(W64 0))).

(* go: server.go:36:19 *)
Definition KVState__getⁱᵐᵖˡ : val :=
  λ: "s" "args",
    exception_do (let: "s" := (mem.alloc "s") in
    let: "args" := (mem.alloc "args") in
    return: (string.to_bytes (Fst (map.get (![type.mapT #stringT #stringT] (struct.field_ref #KVState #"kvs"%go (![#ptrT] "s"))) (![#stringT] (struct.field_ref #getargs_gk.S #"Get"%go "args")))))).

(* go: server.go:40:19 *)
Definition KVState__applyⁱᵐᵖˡ : val :=
  λ: "s" "args" "vnum",
    exception_do (let: "s" := (mem.alloc "s") in
    let: "vnum" := (mem.alloc "vnum") in
    let: "args" := (mem.alloc "args") in
    (if: (![#byteT] (slice.elem_ref #byteT (![#sliceT] "args") #(W64 0))) = OP_PUT
    then
      let: "args" := (mem.alloc (type.zero_val #putargs_gk.S)) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "args") in
      (func_call #putargs_gk.Unmarshal) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("args" <-[#putargs_gk.S] "$r0");;;
      do:  "$r1";;;
      let: "$r0" := (![#uint64T] "vnum") in
      do:  (map.insert (![type.mapT #stringT #uint64T] (struct.field_ref #KVState #"vnums"%go (![#ptrT] "s"))) (![#stringT] (struct.field_ref #putargs_gk.S #"Key"%go "args")) "$r0");;;
      return: (let: "$a0" := "args" in
       (method_call #(ptrT.id KVState.id) #"put"%go (![#ptrT] "s")) "$a0")
    else
      (if: (![#byteT] (slice.elem_ref #byteT (![#sliceT] "args") #(W64 0))) = OP_GET
      then
        let: "key" := (mem.alloc (type.zero_val #getargs_gk.S)) in
        let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "args") in
        (func_call #getargs_gk.Unmarshal) "$a0") in
        let: "$r0" := "$ret0" in
        let: "$r1" := "$ret1" in
        do:  ("key" <-[#getargs_gk.S] "$r0");;;
        do:  "$r1";;;
        let: "$r0" := (![#uint64T] "vnum") in
        do:  (map.insert (![type.mapT #stringT #uint64T] (struct.field_ref #KVState #"vnums"%go (![#ptrT] "s"))) (![#stringT] (struct.field_ref #getargs_gk.S #"Get"%go "key")) "$r0");;;
        return: (let: "$a0" := (![#getargs_gk.S] "key") in
         (method_call #(ptrT.id KVState.id) #"get"%go (![#ptrT] "s")) "$a0")
      else
        (if: (![#byteT] (slice.elem_ref #byteT (![#sliceT] "args") #(W64 0))) = OP_COND_PUT
        then
          let: "args" := (mem.alloc (type.zero_val #condputargs_gk.S)) in
          let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "args") in
          (func_call #condputargs_gk.Unmarshal) "$a0") in
          let: "$r0" := "$ret0" in
          let: "$r1" := "$ret1" in
          do:  ("args" <-[#condputargs_gk.S] "$r0");;;
          do:  "$r1";;;
          (if: (Fst (map.get (![type.mapT #stringT #stringT] (struct.field_ref #KVState #"kvs"%go (![#ptrT] "s"))) (![#stringT] (struct.field_ref #condputargs_gk.S #"Key"%go "args")))) = (![#stringT] (struct.field_ref #condputargs_gk.S #"Expect"%go "args"))
          then
            let: "$r0" := (![#uint64T] "vnum") in
            do:  (map.insert (![type.mapT #stringT #uint64T] (struct.field_ref #KVState #"vnums"%go (![#ptrT] "s"))) (![#stringT] (struct.field_ref #condputargs_gk.S #"Key"%go "args")) "$r0");;;
            let: "$r0" := (![#stringT] (struct.field_ref #condputargs_gk.S #"Val"%go "args")) in
            do:  (map.insert (![type.mapT #stringT #stringT] (struct.field_ref #KVState #"kvs"%go (![#ptrT] "s"))) (![#stringT] (struct.field_ref #condputargs_gk.S #"Key"%go "args")) "$r0");;;
            return: (string.to_bytes #"ok"%go)
          else do:  #());;;
          return: (string.to_bytes #""%go)
        else
          do:  (let: "$a0" := (interface.make #stringT.id #"unexpected op type"%go) in
          Panic "$a0"))))).

(* go: server.go:62:19 *)
Definition KVState__applyReadonlyⁱᵐᵖˡ : val :=
  λ: "s" "args",
    exception_do (let: "s" := (mem.alloc "s") in
    let: "args" := (mem.alloc "args") in
    (if: (![#byteT] (slice.elem_ref #byteT (![#sliceT] "args") #(W64 0))) ≠ OP_GET
    then
      do:  (let: "$a0" := (interface.make #stringT.id #"expected a GET as readonly-operation"%go) in
      Panic "$a0")
    else do:  #());;;
    let: "key" := (mem.alloc (type.zero_val #getargs_gk.S)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "args") in
    (func_call #getargs_gk.Unmarshal) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("key" <-[#getargs_gk.S] "$r0");;;
    do:  "$r1";;;
    let: "reply" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#getargs_gk.S] "key") in
    (method_call #(ptrT.id KVState.id) #"get"%go (![#ptrT] "s")) "$a0") in
    do:  ("reply" <-[#sliceT] "$r0");;;
    let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "vnum" := (mem.alloc (type.zero_val #uint64T)) in
    let: ("$ret0", "$ret1") := (map.get (![type.mapT #stringT #uint64T] (struct.field_ref #KVState #"vnums"%go (![#ptrT] "s"))) (![#stringT] (struct.field_ref #getargs_gk.S #"Get"%go "key"))) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("vnum" <-[#uint64T] "$r0");;;
    do:  ("ok" <-[#boolT] "$r1");;;
    (if: ![#boolT] "ok"
    then return: (![#uint64T] "vnum", ![#sliceT] "reply")
    else return: (![#uint64T] (struct.field_ref #KVState #"minVnum"%go (![#ptrT] "s")), ![#sliceT] "reply"))).

(* go: server.go:76:19 *)
Definition KVState__getStateⁱᵐᵖˡ : val :=
  λ: "s" <>,
    exception_do (let: "s" := (mem.alloc "s") in
    return: (let: "$a0" := (![type.mapT #stringT #stringT] (struct.field_ref #KVState #"kvs"%go (![#ptrT] "s"))) in
     (func_call #map_string_marshal.EncodeStringMap) "$a0")).

(* go: server.go:80:19 *)
Definition KVState__setStateⁱᵐᵖˡ : val :=
  λ: "s" "snap" "nextIndex",
    exception_do (let: "s" := (mem.alloc "s") in
    let: "nextIndex" := (mem.alloc "nextIndex") in
    let: "snap" := (mem.alloc "snap") in
    let: "$r0" := (![#uint64T] "nextIndex") in
    do:  ((struct.field_ref #KVState #"minVnum"%go (![#ptrT] "s")) <-[#uint64T] "$r0");;;
    let: "$r0" := (map.make #stringT #uint64T) in
    do:  ((struct.field_ref #KVState #"vnums"%go (![#ptrT] "s")) <-[type.mapT #stringT #uint64T] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "snap") in
    (func_call #map_string_marshal.DecodeStringMap) "$a0") in
    do:  ((struct.field_ref #KVState #"kvs"%go (![#ptrT] "s")) <-[type.mapT #stringT #stringT] "$r0");;;
    return: #()).

Definition makeVersionedStateMachine : go_string := "github.com/mit-pdos/gokv/vrsm/apps/vkv.makeVersionedStateMachine"%go.

(* go: server.go:99:6 *)
Definition makeVersionedStateMachineⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "s" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #KVState)) in
    do:  ("s" <-[#ptrT] "$r0");;;
    let: "$r0" := (map.make #stringT #stringT) in
    do:  ((struct.field_ref #KVState #"kvs"%go (![#ptrT] "s")) <-[type.mapT #stringT #stringT] "$r0");;;
    let: "$r0" := (map.make #stringT #uint64T) in
    do:  ((struct.field_ref #KVState #"vnums"%go (![#ptrT] "s")) <-[type.mapT #stringT #uint64T] "$r0");;;
    return: (mem.alloc (let: "$ApplyVolatile" := (method_call #(ptrT.id KVState.id) #"apply"%go (![#ptrT] "s")) in
     let: "$ApplyReadonly" := (method_call #(ptrT.id KVState.id) #"applyReadonly"%go (![#ptrT] "s")) in
     let: "$GetState" := (λ: <>,
       exception_do (return: ((method_call #(ptrT.id KVState.id) #"getState"%go (![#ptrT] "s")) #()))
       ) in
     let: "$SetState" := (method_call #(ptrT.id KVState.id) #"setState"%go (![#ptrT] "s")) in
     struct.make #exactlyonce.VersionedStateMachine [{
       "ApplyVolatile" ::= "$ApplyVolatile";
       "ApplyReadonly" ::= "$ApplyReadonly";
       "SetState" ::= "$SetState";
       "GetState" ::= "$GetState"
     }]))).

Definition Start : go_string := "github.com/mit-pdos/gokv/vrsm/apps/vkv.Start"%go.

(* go: server.go:112:6 *)
Definition Startⁱᵐᵖˡ : val :=
  λ: "fname" "host" "confHosts",
    exception_do (let: "confHosts" := (mem.alloc "confHosts") in
    let: "host" := (mem.alloc "host") in
    let: "fname" := (mem.alloc "fname") in
    do:  (let: "$a0" := (![#uint64T] "host") in
    (method_call #(ptrT.id replica.Server.id) #"Serve"%go (let: "$a0" := (let: "$a0" := ((func_call #makeVersionedStateMachine) #()) in
    (func_call #exactlyonce.MakeExactlyOnceStateMachine) "$a0") in
    let: "$a1" := (![#stringT] "fname") in
    let: "$a2" := (![#sliceT] "confHosts") in
    (func_call #storage.MakePbServer) "$a0" "$a1" "$a2")) "$a0");;;
    return: #()).

Definition vars' : list (go_string * go_type) := [].

Definition functions' : list (go_string * val) := [(MakeClerk, MakeClerkⁱᵐᵖˡ); (MakeClerkPool, MakeClerkPoolⁱᵐᵖˡ); (MakeKv, MakeKvⁱᵐᵖˡ); (makeVersionedStateMachine, makeVersionedStateMachineⁱᵐᵖˡ); (Start, Startⁱᵐᵖˡ)].

Definition msets' : list (go_string * (list (go_string * val))) := [(Clerk.id, []); (ptrT.id Clerk.id, [("CondPut"%go, Clerk__CondPutⁱᵐᵖˡ); ("Get"%go, Clerk__Getⁱᵐᵖˡ); ("Put"%go, Clerk__Putⁱᵐᵖˡ)]); (ClerkPool.id, []); (ptrT.id ClerkPool.id, [("ConditionalPut"%go, ClerkPool__ConditionalPutⁱᵐᵖˡ); ("Get"%go, ClerkPool__Getⁱᵐᵖˡ); ("Put"%go, ClerkPool__Putⁱᵐᵖˡ); ("doWithClerk"%go, ClerkPool__doWithClerkⁱᵐᵖˡ)]); (KVState.id, []); (ptrT.id KVState.id, [("apply"%go, KVState__applyⁱᵐᵖˡ); ("applyReadonly"%go, KVState__applyReadonlyⁱᵐᵖˡ); ("get"%go, KVState__getⁱᵐᵖˡ); ("getState"%go, KVState__getStateⁱᵐᵖˡ); ("put"%go, KVState__putⁱᵐᵖˡ); ("setState"%go, KVState__setStateⁱᵐᵖˡ)])].

#[global] Instance info' : PkgInfo vkv.vkv :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [code.github_com.mit_pdos.gokv.grove_ffi.grove_ffi; code.github_com.mit_pdos.gokv.vrsm.apps.exactlyonce.exactlyonce; code.github_com.mit_pdos.gokv.vrsm.apps.vkv.condputargs_gk.condputargs_gk; code.github_com.mit_pdos.gokv.vrsm.apps.vkv.getargs_gk.getargs_gk; code.github_com.mit_pdos.gokv.vrsm.apps.vkv.putargs_gk.putargs_gk; code.sync.sync; code.github_com.mit_pdos.gokv.kv.kv; code.github_com.mit_pdos.gokv.map_string_marshal.map_string_marshal; code.github_com.mit_pdos.gokv.vrsm.storage.storage];
  |}.

Definition initialize' : val :=
  λ: <>,
    package.init #vkv.vkv (λ: <>,
      exception_do (do:  (storage.initialize' #());;;
      do:  (map_string_marshal.initialize' #());;;
      do:  (kv.initialize' #());;;
      do:  (sync.initialize' #());;;
      do:  (putargs_gk.initialize' #());;;
      do:  (getargs_gk.initialize' #());;;
      do:  (condputargs_gk.initialize' #());;;
      do:  (exactlyonce.initialize' #());;;
      do:  (grove_ffi.initialize' #());;;
      do:  (package.alloc vkv.vkv #()))
      ).

End code.
End vkv.
