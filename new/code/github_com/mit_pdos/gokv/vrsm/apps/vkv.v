(* autogenerated from github.com/mit-pdos/gokv/vrsm/apps/vkv *)
Require Export New.code.github_com.mit_pdos.gokv.grove_ffi.
Require Export New.code.github_com.mit_pdos.gokv.vrsm.apps.exactlyonce.
Require Export New.code.github_com.mit_pdos.gokv.vrsm.apps.vkv.condputargs_gk.
Require Export New.code.github_com.mit_pdos.gokv.vrsm.apps.vkv.getargs_gk.
Require Export New.code.github_com.mit_pdos.gokv.vrsm.apps.vkv.putargs_gk.
Require Export New.code.sync.
Require Export New.code.github_com.mit_pdos.gokv.kv.
Require Export New.code.github_com.mit_pdos.gokv.map_string_marshal.
Require Export New.code.github_com.mit_pdos.gokv.vrsm.storage.
From New.golang Require Import defn.
From New Require Import grove_prelude.
Module pkg_id.
Definition vkv : go_string := "github.com/mit-pdos/gokv/vrsm/apps/vkv".

End pkg_id.
Export pkg_id.
Module vkv.

Definition Clerk {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/mit-pdos/gokv/vrsm/apps/vkv.Clerk"%go [].

Definition ClerkPool {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/mit-pdos/gokv/vrsm/apps/vkv.ClerkPool"%go [].

Definition KVState {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/mit-pdos/gokv/vrsm/apps/vkv.KVState"%go [].

Definition OP_PUT {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W8 0).

Definition OP_GET {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W8 1).

Definition OP_COND_PUT {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W8 2).

Definition MakeClerk {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/gokv/vrsm/apps/vkv.MakeClerk"%go.

Definition MakeClerkPool {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/gokv/vrsm/apps/vkv.MakeClerkPool"%go.

Definition MakeKv {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/gokv/vrsm/apps/vkv.MakeKv"%go.

Definition makeVersionedStateMachine {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/gokv/vrsm/apps/vkv.makeVersionedStateMachine"%go.

Definition Start {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/gokv/vrsm/apps/vkv.Start"%go.

(* go: clerk.go:15:6 *)
Definition MakeClerkⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "confHosts",
    exception_do (let: "confHosts" := (GoAlloc (go.SliceType grove_ffi.Address) "confHosts") in
    return: (GoAlloc Clerk (CompositeLiteral Clerk (LiteralValue [KeyedElement (Some (KeyField "cl"%go)) (ElementExpression (go.PointerType exactlyonce.Clerk) (let: "$a0" := (![go.SliceType grove_ffi.Address] "confHosts") in
      (FuncResolve exactlyonce.MakeClerk [] #()) "$a0"))])))).

(* go: clerk.go:19:18 *)
Definition Clerk__Putⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "ck" "key" "val",
    exception_do (let: "ck" := (GoAlloc (go.PointerType Clerk) "ck") in
    let: "val" := (GoAlloc go.string "val") in
    let: "key" := (GoAlloc go.string "key") in
    let: "args" := (GoAlloc putargs_gk.S (GoZeroVal putargs_gk.S #())) in
    let: "$r0" := (CompositeLiteral putargs_gk.S (LiteralValue [KeyedElement (Some (KeyField "Key"%go)) (ElementExpression go.string (![go.string] "key")); KeyedElement (Some (KeyField "Val"%go)) (ElementExpression go.string (![go.string] "val"))])) in
    do:  ("args" <-[putargs_gk.S] "$r0");;;
    do:  (let: "$a0" := (let: "$a0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 0)) in
    let: "$a1" := (![putargs_gk.S] "args") in
    (FuncResolve putargs_gk.Marshal [] #()) "$a0" "$a1") in
    (MethodResolve (go.PointerType exactlyonce.Clerk) "ApplyExactlyOnce"%go (![go.PointerType exactlyonce.Clerk] (StructFieldRef Clerk "cl"%go (![go.PointerType Clerk] "ck")))) "$a0");;;
    return: #()).

(* go: clerk.go:27:18 *)
Definition Clerk__Getⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "ck" "key",
    exception_do (let: "ck" := (GoAlloc (go.PointerType Clerk) "ck") in
    let: "key" := (GoAlloc go.string "key") in
    let: "args" := (GoAlloc getargs_gk.S (GoZeroVal getargs_gk.S #())) in
    let: "$r0" := (CompositeLiteral getargs_gk.S (LiteralValue [KeyedElement (Some (KeyField "Get"%go)) (ElementExpression go.string (![go.string] "key"))])) in
    do:  ("args" <-[getargs_gk.S] "$r0");;;
    return: (Convert (go.SliceType go.byte) go.string (let: "$a0" := (let: "$a0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 0)) in
     let: "$a1" := (![getargs_gk.S] "args") in
     (FuncResolve getargs_gk.Marshal [] #()) "$a0" "$a1") in
     (MethodResolve (go.PointerType exactlyonce.Clerk) "ApplyReadonly"%go (![go.PointerType exactlyonce.Clerk] (StructFieldRef Clerk "cl"%go (![go.PointerType Clerk] "ck")))) "$a0"))).

(* go: clerk.go:34:18 *)
Definition Clerk__CondPutⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "ck" "key" "expect" "val",
    exception_do (let: "ck" := (GoAlloc (go.PointerType Clerk) "ck") in
    let: "val" := (GoAlloc go.string "val") in
    let: "expect" := (GoAlloc go.string "expect") in
    let: "key" := (GoAlloc go.string "key") in
    let: "args" := (GoAlloc condputargs_gk.S (GoZeroVal condputargs_gk.S #())) in
    let: "$r0" := (CompositeLiteral condputargs_gk.S (LiteralValue [KeyedElement (Some (KeyField "Key"%go)) (ElementExpression go.string (![go.string] "key")); KeyedElement (Some (KeyField "Expect"%go)) (ElementExpression go.string (![go.string] "expect")); KeyedElement (Some (KeyField "Val"%go)) (ElementExpression go.string (![go.string] "val"))])) in
    do:  ("args" <-[condputargs_gk.S] "$r0");;;
    return: (Convert (go.SliceType go.byte) go.string (let: "$a0" := (let: "$a0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 0)) in
     let: "$a1" := (![condputargs_gk.S] "args") in
     (FuncResolve condputargs_gk.Marshal [] #()) "$a0" "$a1") in
     (MethodResolve (go.PointerType exactlyonce.Clerk) "ApplyExactlyOnce"%go (![go.PointerType exactlyonce.Clerk] (StructFieldRef Clerk "cl"%go (![go.PointerType Clerk] "ck")))) "$a0"))).

(* go: clerkpool.go:18:6 *)
Definition MakeClerkPoolⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "confHosts",
    exception_do (let: "confHosts" := (GoAlloc (go.SliceType grove_ffi.Address) "confHosts") in
    return: (GoAlloc ClerkPool (CompositeLiteral ClerkPool (LiteralValue [KeyedElement (Some (KeyField "mu"%go)) (ElementExpression (go.PointerType sync.Mutex) (GoAlloc sync.Mutex (GoZeroVal sync.Mutex #()))); KeyedElement (Some (KeyField "cls"%go)) (ElementExpression (go.SliceType (go.PointerType Clerk)) ((FuncResolve go.make2 [go.SliceType (go.PointerType Clerk)] #()) #(W64 0))); KeyedElement (Some (KeyField "confHosts"%go)) (ElementExpression (go.SliceType grove_ffi.Address) (![go.SliceType grove_ffi.Address] "confHosts"))])))).

(* TODO: get rid of stale clerks from the ck.cls list?
   TODO: keep failed clerks out of ck.cls list? Maybe f(cl) can return an
   optional error saying "get rid of cl".

   go: clerkpool.go:29:22 *)
Definition ClerkPool__doWithClerkⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "ck" "f",
    exception_do (let: "ck" := (GoAlloc (go.PointerType ClerkPool) "ck") in
    let: "f" := (GoAlloc (go.FunctionType (go.Signature [go.PointerType Clerk] false [])) "f") in
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] (StructFieldRef ClerkPool "mu"%go (![go.PointerType ClerkPool] "ck")))) #());;;
    let: "cl" := (GoAlloc (go.PointerType Clerk) (GoZeroVal (go.PointerType Clerk) #())) in
    (if: Convert go.untyped_bool go.bool ((let: "$a0" := (![go.SliceType (go.PointerType Clerk)] (StructFieldRef ClerkPool "cls"%go (![go.PointerType ClerkPool] "ck"))) in
    (FuncResolve go.len [go.SliceType (go.PointerType Clerk)] #()) "$a0") >⟨go.int⟩ #(W64 0))
    then
      let: "$r0" := (![go.PointerType Clerk] (IndexRef (go.SliceType (go.PointerType Clerk)) (![go.SliceType (go.PointerType Clerk)] (StructFieldRef ClerkPool "cls"%go (![go.PointerType ClerkPool] "ck")), #(W64 0)))) in
      do:  ("cl" <-[go.PointerType Clerk] "$r0");;;
      let: "$r0" := (let: "$s" := (![go.SliceType (go.PointerType Clerk)] (StructFieldRef ClerkPool "cls"%go (![go.PointerType ClerkPool] "ck"))) in
      Slice (go.SliceType (go.PointerType Clerk)) ("$s", #(W64 1), FuncResolve go.len [go.SliceType (go.PointerType Clerk)] #() (![go.SliceType (go.PointerType Clerk)] (StructFieldRef ClerkPool "cls"%go (![go.PointerType ClerkPool] "ck"))))) in
      do:  ((StructFieldRef ClerkPool "cls"%go (![go.PointerType ClerkPool] "ck")) <-[go.SliceType (go.PointerType Clerk)] "$r0");;;
      do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef ClerkPool "mu"%go (![go.PointerType ClerkPool] "ck")))) #());;;
      do:  (let: "$a0" := (![go.PointerType Clerk] "cl") in
      (![go.FunctionType (go.Signature [go.PointerType Clerk] false [])] "f") "$a0");;;
      do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] (StructFieldRef ClerkPool "mu"%go (![go.PointerType ClerkPool] "ck")))) #());;;
      let: "$r0" := (let: "$a0" := (![go.SliceType (go.PointerType Clerk)] (StructFieldRef ClerkPool "cls"%go (![go.PointerType ClerkPool] "ck"))) in
      let: "$a1" := ((let: "$sl0" := (![go.PointerType Clerk] "cl") in
      CompositeLiteral (go.SliceType (go.PointerType Clerk)) (LiteralValue [KeyedElement None (ElementExpression (go.PointerType Clerk) "$sl0")]))) in
      (FuncResolve go.append [go.SliceType (go.PointerType Clerk)] #()) "$a0" "$a1") in
      do:  ((StructFieldRef ClerkPool "cls"%go (![go.PointerType ClerkPool] "ck")) <-[go.SliceType (go.PointerType Clerk)] "$r0");;;
      do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef ClerkPool "mu"%go (![go.PointerType ClerkPool] "ck")))) #())
    else
      do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef ClerkPool "mu"%go (![go.PointerType ClerkPool] "ck")))) #());;;
      let: "$r0" := (let: "$a0" := (![go.SliceType grove_ffi.Address] (StructFieldRef ClerkPool "confHosts"%go (![go.PointerType ClerkPool] "ck"))) in
      (FuncResolve MakeClerk [] #()) "$a0") in
      do:  ("cl" <-[go.PointerType Clerk] "$r0");;;
      do:  (let: "$a0" := (![go.PointerType Clerk] "cl") in
      (![go.FunctionType (go.Signature [go.PointerType Clerk] false [])] "f") "$a0");;;
      do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] (StructFieldRef ClerkPool "mu"%go (![go.PointerType ClerkPool] "ck")))) #());;;
      let: "$r0" := (let: "$a0" := (![go.SliceType (go.PointerType Clerk)] (StructFieldRef ClerkPool "cls"%go (![go.PointerType ClerkPool] "ck"))) in
      let: "$a1" := ((let: "$sl0" := (![go.PointerType Clerk] "cl") in
      CompositeLiteral (go.SliceType (go.PointerType Clerk)) (LiteralValue [KeyedElement None (ElementExpression (go.PointerType Clerk) "$sl0")]))) in
      (FuncResolve go.append [go.SliceType (go.PointerType Clerk)] #()) "$a0" "$a1") in
      do:  ((StructFieldRef ClerkPool "cls"%go (![go.PointerType ClerkPool] "ck")) <-[go.SliceType (go.PointerType Clerk)] "$r0");;;
      do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef ClerkPool "mu"%go (![go.PointerType ClerkPool] "ck")))) #()));;;
    return: #()).

(* go: clerkpool.go:55:22 *)
Definition ClerkPool__Putⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "ck" "key" "val",
    exception_do (let: "ck" := (GoAlloc (go.PointerType ClerkPool) "ck") in
    let: "val" := (GoAlloc go.string "val") in
    let: "key" := (GoAlloc go.string "key") in
    do:  (let: "$a0" := (λ: "ck",
      exception_do (let: "ck" := (GoAlloc (go.PointerType Clerk) "ck") in
      do:  (let: "$a0" := (![go.string] "key") in
      let: "$a1" := (![go.string] "val") in
      (MethodResolve (go.PointerType Clerk) "Put"%go (![go.PointerType Clerk] "ck")) "$a0" "$a1");;;
      return: #())
      ) in
    (MethodResolve (go.PointerType ClerkPool) "doWithClerk"%go (![go.PointerType ClerkPool] "ck")) "$a0");;;
    return: #()).

(* go: clerkpool.go:61:22 *)
Definition ClerkPool__Getⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "ck" "key",
    exception_do (let: "ck" := (GoAlloc (go.PointerType ClerkPool) "ck") in
    let: "key" := (GoAlloc go.string "key") in
    let: "ret" := (GoAlloc go.string (GoZeroVal go.string #())) in
    do:  (let: "$a0" := (λ: "ck",
      exception_do (let: "ck" := (GoAlloc (go.PointerType Clerk) "ck") in
      let: "$r0" := (let: "$a0" := (![go.string] "key") in
      (MethodResolve (go.PointerType Clerk) "Get"%go (![go.PointerType Clerk] "ck")) "$a0") in
      do:  ("ret" <-[go.string] "$r0");;;
      return: #())
      ) in
    (MethodResolve (go.PointerType ClerkPool) "doWithClerk"%go (![go.PointerType ClerkPool] "ck")) "$a0");;;
    return: (![go.string] "ret")).

(* go: clerkpool.go:69:22 *)
Definition ClerkPool__ConditionalPutⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "ck" "key" "expect" "val",
    exception_do (let: "ck" := (GoAlloc (go.PointerType ClerkPool) "ck") in
    let: "val" := (GoAlloc go.string "val") in
    let: "expect" := (GoAlloc go.string "expect") in
    let: "key" := (GoAlloc go.string "key") in
    let: "ret" := (GoAlloc go.string (GoZeroVal go.string #())) in
    do:  (let: "$a0" := (λ: "ck",
      exception_do (let: "ck" := (GoAlloc (go.PointerType Clerk) "ck") in
      let: "$r0" := (let: "$a0" := (![go.string] "key") in
      let: "$a1" := (![go.string] "expect") in
      let: "$a2" := (![go.string] "val") in
      (MethodResolve (go.PointerType Clerk) "CondPut"%go (![go.PointerType Clerk] "ck")) "$a0" "$a1" "$a2") in
      do:  ("ret" <-[go.string] "$r0");;;
      return: #())
      ) in
    (MethodResolve (go.PointerType ClerkPool) "doWithClerk"%go (![go.PointerType ClerkPool] "ck")) "$a0");;;
    return: (![go.string] "ret")).

(* go: clerkpool.go:77:6 *)
Definition MakeKvⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "confHosts",
    exception_do (let: "confHosts" := (GoAlloc (go.SliceType grove_ffi.Address) "confHosts") in
    let: "ck" := (GoAlloc (go.PointerType ClerkPool) (GoZeroVal (go.PointerType ClerkPool) #())) in
    let: "$r0" := (let: "$a0" := (![go.SliceType grove_ffi.Address] "confHosts") in
    (FuncResolve MakeClerkPool [] #()) "$a0") in
    do:  ("ck" <-[go.PointerType ClerkPool] "$r0");;;
    return: (Convert (go.PointerType ClerkPool) kv.KvCput (![go.PointerType ClerkPool] "ck"))).

(* go: server.go:31:19 *)
Definition KVState__putⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" "args",
    exception_do (let: "s" := (GoAlloc (go.PointerType KVState) "s") in
    let: "args" := (GoAlloc (go.PointerType putargs_gk.S) "args") in
    let: "$r0" := (![go.string] (StructFieldRef putargs_gk.S "Val"%go (![go.PointerType putargs_gk.S] "args"))) in
    do:  (map.insert go.string (![go.MapType go.string go.string] (StructFieldRef KVState "kvs"%go (![go.PointerType KVState] "s"))) (![go.string] (StructFieldRef putargs_gk.S "Key"%go (![go.PointerType putargs_gk.S] "args"))) "$r0");;;
    return: ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 0))).

(* go: server.go:36:19 *)
Definition KVState__getⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" "args",
    exception_do (let: "s" := (GoAlloc (go.PointerType KVState) "s") in
    let: "args" := (GoAlloc getargs_gk.S "args") in
    return: (Convert go.string (go.SliceType go.byte) (map.lookup1 go.string go.string (![go.MapType go.string go.string] (StructFieldRef KVState "kvs"%go (![go.PointerType KVState] "s"))) (![go.string] (StructFieldRef getargs_gk.S "Get"%go "args"))))).

(* go: server.go:40:19 *)
Definition KVState__applyⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" "args" "vnum",
    exception_do (let: "s" := (GoAlloc (go.PointerType KVState) "s") in
    let: "vnum" := (GoAlloc go.uint64 "vnum") in
    let: "args" := (GoAlloc (go.SliceType go.byte) "args") in
    (if: Convert go.untyped_bool go.bool ((![go.byte] (IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "args", #(W64 0)))) =⟨go.byte⟩ OP_PUT)
    then
      let: "args" := (GoAlloc putargs_gk.S (GoZeroVal putargs_gk.S #())) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] "args") in
      (FuncResolve putargs_gk.Unmarshal [] #()) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("args" <-[putargs_gk.S] "$r0");;;
      do:  "$r1";;;
      let: "$r0" := (![go.uint64] "vnum") in
      do:  (map.insert go.string (![go.MapType go.string go.uint64] (StructFieldRef KVState "vnums"%go (![go.PointerType KVState] "s"))) (![go.string] (StructFieldRef putargs_gk.S "Key"%go "args")) "$r0");;;
      return: (let: "$a0" := "args" in
       (MethodResolve (go.PointerType KVState) "put"%go (![go.PointerType KVState] "s")) "$a0")
    else
      (if: Convert go.untyped_bool go.bool ((![go.byte] (IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "args", #(W64 0)))) =⟨go.byte⟩ OP_GET)
      then
        let: "key" := (GoAlloc getargs_gk.S (GoZeroVal getargs_gk.S #())) in
        let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] "args") in
        (FuncResolve getargs_gk.Unmarshal [] #()) "$a0") in
        let: "$r0" := "$ret0" in
        let: "$r1" := "$ret1" in
        do:  ("key" <-[getargs_gk.S] "$r0");;;
        do:  "$r1";;;
        let: "$r0" := (![go.uint64] "vnum") in
        do:  (map.insert go.string (![go.MapType go.string go.uint64] (StructFieldRef KVState "vnums"%go (![go.PointerType KVState] "s"))) (![go.string] (StructFieldRef getargs_gk.S "Get"%go "key")) "$r0");;;
        return: (let: "$a0" := (![getargs_gk.S] "key") in
         (MethodResolve (go.PointerType KVState) "get"%go (![go.PointerType KVState] "s")) "$a0")
      else
        (if: Convert go.untyped_bool go.bool ((![go.byte] (IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "args", #(W64 0)))) =⟨go.byte⟩ OP_COND_PUT)
        then
          let: "args" := (GoAlloc condputargs_gk.S (GoZeroVal condputargs_gk.S #())) in
          let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] "args") in
          (FuncResolve condputargs_gk.Unmarshal [] #()) "$a0") in
          let: "$r0" := "$ret0" in
          let: "$r1" := "$ret1" in
          do:  ("args" <-[condputargs_gk.S] "$r0");;;
          do:  "$r1";;;
          (if: Convert go.untyped_bool go.bool ((map.lookup1 go.string go.string (![go.MapType go.string go.string] (StructFieldRef KVState "kvs"%go (![go.PointerType KVState] "s"))) (![go.string] (StructFieldRef condputargs_gk.S "Key"%go "args"))) =⟨go.string⟩ (![go.string] (StructFieldRef condputargs_gk.S "Expect"%go "args")))
          then
            let: "$r0" := (![go.uint64] "vnum") in
            do:  (map.insert go.string (![go.MapType go.string go.uint64] (StructFieldRef KVState "vnums"%go (![go.PointerType KVState] "s"))) (![go.string] (StructFieldRef condputargs_gk.S "Key"%go "args")) "$r0");;;
            let: "$r0" := (![go.string] (StructFieldRef condputargs_gk.S "Val"%go "args")) in
            do:  (map.insert go.string (![go.MapType go.string go.string] (StructFieldRef KVState "kvs"%go (![go.PointerType KVState] "s"))) (![go.string] (StructFieldRef condputargs_gk.S "Key"%go "args")) "$r0");;;
            return: (Convert go.string (go.SliceType go.byte) #"ok"%go)
          else do:  #());;;
          return: (Convert go.string (go.SliceType go.byte) #""%go)
        else
          do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"unexpected op type"%go) in
          (FuncResolve go.panic [] #()) "$a0"))))).

(* go: server.go:62:19 *)
Definition KVState__applyReadonlyⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" "args",
    exception_do (let: "s" := (GoAlloc (go.PointerType KVState) "s") in
    let: "args" := (GoAlloc (go.SliceType go.byte) "args") in
    (if: Convert go.untyped_bool go.bool ((![go.byte] (IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "args", #(W64 0)))) ≠⟨go.byte⟩ OP_GET)
    then
      do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"expected a GET as readonly-operation"%go) in
      (FuncResolve go.panic [] #()) "$a0")
    else do:  #());;;
    let: "key" := (GoAlloc getargs_gk.S (GoZeroVal getargs_gk.S #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] "args") in
    (FuncResolve getargs_gk.Unmarshal [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("key" <-[getargs_gk.S] "$r0");;;
    do:  "$r1";;;
    let: "reply" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (let: "$a0" := (![getargs_gk.S] "key") in
    (MethodResolve (go.PointerType KVState) "get"%go (![go.PointerType KVState] "s")) "$a0") in
    do:  ("reply" <-[go.SliceType go.byte] "$r0");;;
    let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "vnum" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: ("$ret0", "$ret1") := (map.lookup2 go.string go.uint64 (![go.MapType go.string go.uint64] (StructFieldRef KVState "vnums"%go (![go.PointerType KVState] "s"))) (![go.string] (StructFieldRef getargs_gk.S "Get"%go "key"))) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("vnum" <-[go.uint64] "$r0");;;
    do:  ("ok" <-[go.bool] "$r1");;;
    (if: ![go.bool] "ok"
    then return: (![go.uint64] "vnum", ![go.SliceType go.byte] "reply")
    else return: (![go.uint64] (StructFieldRef KVState "minVnum"%go (![go.PointerType KVState] "s")), ![go.SliceType go.byte] "reply"))).

(* go: server.go:76:19 *)
Definition KVState__getStateⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" <>,
    exception_do (let: "s" := (GoAlloc (go.PointerType KVState) "s") in
    return: (let: "$a0" := (![go.MapType go.string go.string] (StructFieldRef KVState "kvs"%go (![go.PointerType KVState] "s"))) in
     (FuncResolve map_string_marshal.EncodeStringMap [] #()) "$a0")).

(* go: server.go:80:19 *)
Definition KVState__setStateⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" "snap" "nextIndex",
    exception_do (let: "s" := (GoAlloc (go.PointerType KVState) "s") in
    let: "nextIndex" := (GoAlloc go.uint64 "nextIndex") in
    let: "snap" := (GoAlloc (go.SliceType go.byte) "snap") in
    let: "$r0" := (![go.uint64] "nextIndex") in
    do:  ((StructFieldRef KVState "minVnum"%go (![go.PointerType KVState] "s")) <-[go.uint64] "$r0");;;
    let: "$r0" := ((FuncResolve go.make1 [go.MapType go.string go.uint64] #()) #()) in
    do:  ((StructFieldRef KVState "vnums"%go (![go.PointerType KVState] "s")) <-[go.MapType go.string go.uint64] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "snap") in
    (FuncResolve map_string_marshal.DecodeStringMap [] #()) "$a0") in
    do:  ((StructFieldRef KVState "kvs"%go (![go.PointerType KVState] "s")) <-[go.MapType go.string go.string] "$r0");;;
    return: #()).

(* go: server.go:99:6 *)
Definition makeVersionedStateMachineⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "s" := (GoAlloc (go.PointerType KVState) (GoZeroVal (go.PointerType KVState) #())) in
    let: "$r0" := (GoAlloc KVState (GoZeroVal KVState #())) in
    do:  ("s" <-[go.PointerType KVState] "$r0");;;
    let: "$r0" := ((FuncResolve go.make2 [go.MapType go.string go.string] #()) #(W64 0)) in
    do:  ((StructFieldRef KVState "kvs"%go (![go.PointerType KVState] "s")) <-[go.MapType go.string go.string] "$r0");;;
    let: "$r0" := ((FuncResolve go.make1 [go.MapType go.string go.uint64] #()) #()) in
    do:  ((StructFieldRef KVState "vnums"%go (![go.PointerType KVState] "s")) <-[go.MapType go.string go.uint64] "$r0");;;
    return: (GoAlloc exactlyonce.VersionedStateMachine (CompositeLiteral exactlyonce.VersionedStateMachine (LiteralValue [KeyedElement (Some (KeyField "ApplyVolatile"%go)) (ElementExpression (go.FunctionType (go.Signature [go.SliceType go.byte; go.uint64] false [go.SliceType go.byte])) (MethodResolve (go.PointerType KVState) "apply"%go (![go.PointerType KVState] "s"))); KeyedElement (Some (KeyField "ApplyReadonly"%go)) (ElementExpression (go.FunctionType (go.Signature [go.SliceType go.byte] false [go.uint64; go.SliceType go.byte])) (MethodResolve (go.PointerType KVState) "applyReadonly"%go (![go.PointerType KVState] "s"))); KeyedElement (Some (KeyField "GetState"%go)) (ElementExpression (go.FunctionType (go.Signature [] false [go.SliceType go.byte])) (λ: <>,
        exception_do (return: ((MethodResolve (go.PointerType KVState) "getState"%go (![go.PointerType KVState] "s")) #()))
        )); KeyedElement (Some (KeyField "SetState"%go)) (ElementExpression (go.FunctionType (go.Signature [go.SliceType go.byte; go.uint64] false [])) (MethodResolve (go.PointerType KVState) "setState"%go (![go.PointerType KVState] "s")))])))).

(* go: server.go:112:6 *)
Definition Startⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "fname" "host" "confHosts",
    exception_do (let: "confHosts" := (GoAlloc (go.SliceType grove_ffi.Address) "confHosts") in
    let: "host" := (GoAlloc grove_ffi.Address "host") in
    let: "fname" := (GoAlloc go.string "fname") in
    do:  (let: "$a0" := (![grove_ffi.Address] "host") in
    (MethodResolve (go.PointerType replica.Server) "Serve"%go (let: "$a0" := (let: "$a0" := ((FuncResolve makeVersionedStateMachine [] #()) #()) in
    (FuncResolve exactlyonce.MakeExactlyOnceStateMachine [] #()) "$a0") in
    let: "$a1" := (![go.string] "fname") in
    let: "$a2" := (![go.SliceType grove_ffi.Address] "confHosts") in
    (FuncResolve storage.MakePbServer [] #()) "$a0" "$a1" "$a2")) "$a0");;;
    return: #()).

#[global] Instance info' : PkgInfo pkg_id.vkv :=
{|
  pkg_imported_pkgs := [code.github_com.mit_pdos.gokv.grove_ffi.pkg_id.grove_ffi; code.github_com.mit_pdos.gokv.vrsm.apps.exactlyonce.pkg_id.exactlyonce; code.github_com.mit_pdos.gokv.vrsm.apps.vkv.condputargs_gk.pkg_id.condputargs_gk; code.github_com.mit_pdos.gokv.vrsm.apps.vkv.getargs_gk.pkg_id.getargs_gk; code.github_com.mit_pdos.gokv.vrsm.apps.vkv.putargs_gk.pkg_id.putargs_gk; code.sync.pkg_id.sync; code.github_com.mit_pdos.gokv.kv.pkg_id.kv; code.github_com.mit_pdos.gokv.map_string_marshal.pkg_id.map_string_marshal; code.github_com.mit_pdos.gokv.vrsm.storage.pkg_id.storage]
|}.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init pkg_id.vkv (λ: <>,
      exception_do (do:  (storage.initialize' #());;;
      do:  (map_string_marshal.initialize' #());;;
      do:  (kv.initialize' #());;;
      do:  (sync.initialize' #());;;
      do:  (putargs_gk.initialize' #());;;
      do:  (getargs_gk.initialize' #());;;
      do:  (condputargs_gk.initialize' #());;;
      do:  (exactlyonce.initialize' #());;;
      do:  (grove_ffi.initialize' #()))
      ).

Module Clerk.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  cl' : loc;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End Clerk.

Definition Clerk'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "cl"%go (go.PointerType exactlyonce.Clerk))
].
Program Definition Clerk'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (Clerk'fds_unsealed).
Global Instance equals_unfold_Clerk {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Clerk'fds =→ Clerk'fds_unsealed.
Proof. rewrite /Clerk'fds seal_eq //. Qed.

Definition Clerkⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (Clerk'fds).

Class Clerk_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Clerk_type_repr  :: go.TypeReprUnderlying Clerkⁱᵐᵖˡ Clerk.t;
  #[global] Clerk_underlying :: (Clerk) <u (Clerkⁱᵐᵖˡ);
  #[global] Clerk_get_cl (x : Clerk.t) :: ⟦StructFieldGet (Clerkⁱᵐᵖˡ) "cl", #x⟧ ⤳[under] #x.(Clerk.cl');
  #[global] Clerk_set_cl (x : Clerk.t) y :: ⟦StructFieldSet (Clerkⁱᵐᵖˡ) "cl", (#x, #y)⟧ ⤳[under] #(x <|Clerk.cl' := y|>);
  #[global] Clerk'ptr_CondPut_unfold :: MethodUnfold (go.PointerType (Clerk)) "CondPut" (Clerk__CondPutⁱᵐᵖˡ);
  #[global] Clerk'ptr_Get_unfold :: MethodUnfold (go.PointerType (Clerk)) "Get" (Clerk__Getⁱᵐᵖˡ);
  #[global] Clerk'ptr_Put_unfold :: MethodUnfold (go.PointerType (Clerk)) "Put" (Clerk__Putⁱᵐᵖˡ);
}.

Module ClerkPool.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  mu' : loc;
  cls' : slice.t;
  confHosts' : slice.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End ClerkPool.

Definition ClerkPool'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "mu"%go (go.PointerType sync.Mutex));
  (go.FieldDecl "cls"%go (go.SliceType (go.PointerType Clerk)));
  (go.FieldDecl "confHosts"%go (go.SliceType grove_ffi.Address))
].
Program Definition ClerkPool'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (ClerkPool'fds_unsealed).
Global Instance equals_unfold_ClerkPool {ext : ffi_syntax} {go_gctx : GoGlobalContext} : ClerkPool'fds =→ ClerkPool'fds_unsealed.
Proof. rewrite /ClerkPool'fds seal_eq //. Qed.

Definition ClerkPoolⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (ClerkPool'fds).

Class ClerkPool_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] ClerkPool_type_repr  :: go.TypeReprUnderlying ClerkPoolⁱᵐᵖˡ ClerkPool.t;
  #[global] ClerkPool_underlying :: (ClerkPool) <u (ClerkPoolⁱᵐᵖˡ);
  #[global] ClerkPool_get_mu (x : ClerkPool.t) :: ⟦StructFieldGet (ClerkPoolⁱᵐᵖˡ) "mu", #x⟧ ⤳[under] #x.(ClerkPool.mu');
  #[global] ClerkPool_set_mu (x : ClerkPool.t) y :: ⟦StructFieldSet (ClerkPoolⁱᵐᵖˡ) "mu", (#x, #y)⟧ ⤳[under] #(x <|ClerkPool.mu' := y|>);
  #[global] ClerkPool_get_cls (x : ClerkPool.t) :: ⟦StructFieldGet (ClerkPoolⁱᵐᵖˡ) "cls", #x⟧ ⤳[under] #x.(ClerkPool.cls');
  #[global] ClerkPool_set_cls (x : ClerkPool.t) y :: ⟦StructFieldSet (ClerkPoolⁱᵐᵖˡ) "cls", (#x, #y)⟧ ⤳[under] #(x <|ClerkPool.cls' := y|>);
  #[global] ClerkPool_get_confHosts (x : ClerkPool.t) :: ⟦StructFieldGet (ClerkPoolⁱᵐᵖˡ) "confHosts", #x⟧ ⤳[under] #x.(ClerkPool.confHosts');
  #[global] ClerkPool_set_confHosts (x : ClerkPool.t) y :: ⟦StructFieldSet (ClerkPoolⁱᵐᵖˡ) "confHosts", (#x, #y)⟧ ⤳[under] #(x <|ClerkPool.confHosts' := y|>);
  #[global] ClerkPool'ptr_ConditionalPut_unfold :: MethodUnfold (go.PointerType (ClerkPool)) "ConditionalPut" (ClerkPool__ConditionalPutⁱᵐᵖˡ);
  #[global] ClerkPool'ptr_Get_unfold :: MethodUnfold (go.PointerType (ClerkPool)) "Get" (ClerkPool__Getⁱᵐᵖˡ);
  #[global] ClerkPool'ptr_Put_unfold :: MethodUnfold (go.PointerType (ClerkPool)) "Put" (ClerkPool__Putⁱᵐᵖˡ);
  #[global] ClerkPool'ptr_doWithClerk_unfold :: MethodUnfold (go.PointerType (ClerkPool)) "doWithClerk" (ClerkPool__doWithClerkⁱᵐᵖˡ);
}.

Module KVState.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  kvs' : loc;
  vnums' : loc;
  minVnum' : w64;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End KVState.

Definition KVState'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "kvs"%go (go.MapType go.string go.string));
  (go.FieldDecl "vnums"%go (go.MapType go.string go.uint64));
  (go.FieldDecl "minVnum"%go go.uint64)
].
Program Definition KVState'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (KVState'fds_unsealed).
Global Instance equals_unfold_KVState {ext : ffi_syntax} {go_gctx : GoGlobalContext} : KVState'fds =→ KVState'fds_unsealed.
Proof. rewrite /KVState'fds seal_eq //. Qed.

Definition KVStateⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (KVState'fds).

Class KVState_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] KVState_type_repr  :: go.TypeReprUnderlying KVStateⁱᵐᵖˡ KVState.t;
  #[global] KVState_underlying :: (KVState) <u (KVStateⁱᵐᵖˡ);
  #[global] KVState_get_kvs (x : KVState.t) :: ⟦StructFieldGet (KVStateⁱᵐᵖˡ) "kvs", #x⟧ ⤳[under] #x.(KVState.kvs');
  #[global] KVState_set_kvs (x : KVState.t) y :: ⟦StructFieldSet (KVStateⁱᵐᵖˡ) "kvs", (#x, #y)⟧ ⤳[under] #(x <|KVState.kvs' := y|>);
  #[global] KVState_get_vnums (x : KVState.t) :: ⟦StructFieldGet (KVStateⁱᵐᵖˡ) "vnums", #x⟧ ⤳[under] #x.(KVState.vnums');
  #[global] KVState_set_vnums (x : KVState.t) y :: ⟦StructFieldSet (KVStateⁱᵐᵖˡ) "vnums", (#x, #y)⟧ ⤳[under] #(x <|KVState.vnums' := y|>);
  #[global] KVState_get_minVnum (x : KVState.t) :: ⟦StructFieldGet (KVStateⁱᵐᵖˡ) "minVnum", #x⟧ ⤳[under] #x.(KVState.minVnum');
  #[global] KVState_set_minVnum (x : KVState.t) y :: ⟦StructFieldSet (KVStateⁱᵐᵖˡ) "minVnum", (#x, #y)⟧ ⤳[under] #(x <|KVState.minVnum' := y|>);
  #[global] KVState'ptr_apply_unfold :: MethodUnfold (go.PointerType (KVState)) "apply" (KVState__applyⁱᵐᵖˡ);
  #[global] KVState'ptr_applyReadonly_unfold :: MethodUnfold (go.PointerType (KVState)) "applyReadonly" (KVState__applyReadonlyⁱᵐᵖˡ);
  #[global] KVState'ptr_get_unfold :: MethodUnfold (go.PointerType (KVState)) "get" (KVState__getⁱᵐᵖˡ);
  #[global] KVState'ptr_getState_unfold :: MethodUnfold (go.PointerType (KVState)) "getState" (KVState__getStateⁱᵐᵖˡ);
  #[global] KVState'ptr_put_unfold :: MethodUnfold (go.PointerType (KVState)) "put" (KVState__putⁱᵐᵖˡ);
  #[global] KVState'ptr_setState_unfold :: MethodUnfold (go.PointerType (KVState)) "setState" (KVState__setStateⁱᵐᵖˡ);
}.

Class Assumptions `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Clerk_instance :: Clerk_Assumptions;
  #[global] ClerkPool_instance :: ClerkPool_Assumptions;
  #[global] KVState_instance :: KVState_Assumptions;
  #[global] MakeClerk_unfold :: FuncUnfold MakeClerk [] (MakeClerkⁱᵐᵖˡ);
  #[global] MakeClerkPool_unfold :: FuncUnfold MakeClerkPool [] (MakeClerkPoolⁱᵐᵖˡ);
  #[global] MakeKv_unfold :: FuncUnfold MakeKv [] (MakeKvⁱᵐᵖˡ);
  #[global] makeVersionedStateMachine_unfold :: FuncUnfold makeVersionedStateMachine [] (makeVersionedStateMachineⁱᵐᵖˡ);
  #[global] Start_unfold :: FuncUnfold Start [] (Startⁱᵐᵖˡ);
  #[global] import_grove_ffi_Assumption :: grove_ffi.Assumptions;
  #[global] import_exactlyonce_Assumption :: exactlyonce.Assumptions;
  #[global] import_condputargs_gk_Assumption :: condputargs_gk.Assumptions;
  #[global] import_getargs_gk_Assumption :: getargs_gk.Assumptions;
  #[global] import_putargs_gk_Assumption :: putargs_gk.Assumptions;
  #[global] import_sync_Assumption :: sync.Assumptions;
  #[global] import_kv_Assumption :: kv.Assumptions;
  #[global] import_map_string_marshal_Assumption :: map_string_marshal.Assumptions;
  #[global] import_storage_Assumption :: storage.Assumptions;
}.
End vkv.
