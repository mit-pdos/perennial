(* autogenerated from github.com/mit-pdos/gokv/vrsm/apps/vkv *)
From New.golang Require Import defn.
Require Export New.code.github_com.mit_pdos.gokv.grove_ffi.
Require Export New.code.github_com.mit_pdos.gokv.kv.
Require Export New.code.github_com.mit_pdos.gokv.map_string_marshal.
Require Export New.code.github_com.mit_pdos.gokv.vrsm.apps.exactlyonce.
Require Export New.code.github_com.mit_pdos.gokv.vrsm.storage.
Require Export New.code.github_com.tchajed.marshal.
Require Export New.code.sync.

Definition vkv : go_string := "github.com/mit-pdos/gokv/vrsm/apps/vkv".

From New Require Import grove_prelude.
Module vkv.
Section code.


Definition Clerk : go_type := structT [
  "cl" :: ptrT
].

(* go: clerk.go:12:6 *)
Definition MakeClerk : val :=
  rec: "MakeClerk" "confHosts" :=
    exception_do (let: "confHosts" := (mem.alloc "confHosts") in
    return: (mem.alloc (let: "$cl" := (let: "$a0" := (![#sliceT] "confHosts") in
     (func_call #exactlyonce.exactlyonce #"MakeClerk"%go) "$a0") in
     struct.make #Clerk [{
       "cl" ::= "$cl"
     }]))).

Definition PutArgs : go_type := structT [
  "Key" :: stringT;
  "Val" :: stringT
].

(* go: clerk.go:16:18 *)
Definition Clerk__Put : val :=
  rec: "Clerk__Put" "ck" "key" "val" :=
    exception_do (let: "ck" := (mem.alloc "ck") in
    let: "val" := (mem.alloc "val") in
    let: "key" := (mem.alloc "key") in
    let: "args" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (let: "$Key" := (![#stringT] "key") in
    let: "$Val" := (![#stringT] "val") in
    struct.make #PutArgs [{
      "Key" ::= "$Key";
      "Val" ::= "$Val"
    }])) in
    do:  ("args" <-[#ptrT] "$r0");;;
    do:  (let: "$a0" := (let: "$a0" := (![#ptrT] "args") in
    (func_call #vkv.vkv #"encodePutArgs"%go) "$a0") in
    (method_call #exactlyonce #"Clerk'ptr" #"ApplyExactlyOnce" (![#ptrT] (struct.field_ref #Clerk #"cl"%go (![#ptrT] "ck")))) "$a0")).

(* go: clerk.go:24:18 *)
Definition Clerk__Get : val :=
  rec: "Clerk__Get" "ck" "key" :=
    exception_do (let: "ck" := (mem.alloc "ck") in
    let: "key" := (mem.alloc "key") in
    return: (string.from_bytes (let: "$a0" := (let: "$a0" := (![#stringT] "key") in
     (func_call #vkv.vkv #"encodeGetArgs"%go) "$a0") in
     (method_call #exactlyonce #"Clerk'ptr" #"ApplyReadonly" (![#ptrT] (struct.field_ref #Clerk #"cl"%go (![#ptrT] "ck")))) "$a0"))).

Definition CondPutArgs : go_type := structT [
  "Key" :: stringT;
  "Expect" :: stringT;
  "Val" :: stringT
].

(* go: clerk.go:28:18 *)
Definition Clerk__CondPut : val :=
  rec: "Clerk__CondPut" "ck" "key" "expect" "val" :=
    exception_do (let: "ck" := (mem.alloc "ck") in
    let: "val" := (mem.alloc "val") in
    let: "expect" := (mem.alloc "expect") in
    let: "key" := (mem.alloc "key") in
    let: "args" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (let: "$Key" := (![#stringT] "key") in
    let: "$Expect" := (![#stringT] "expect") in
    let: "$Val" := (![#stringT] "val") in
    struct.make #CondPutArgs [{
      "Key" ::= "$Key";
      "Expect" ::= "$Expect";
      "Val" ::= "$Val"
    }])) in
    do:  ("args" <-[#ptrT] "$r0");;;
    return: (string.from_bytes (let: "$a0" := (let: "$a0" := (![#ptrT] "args") in
     (func_call #vkv.vkv #"encodeCondPutArgs"%go) "$a0") in
     (method_call #exactlyonce #"Clerk'ptr" #"ApplyExactlyOnce" (![#ptrT] (struct.field_ref #Clerk #"cl"%go (![#ptrT] "ck")))) "$a0"))).

Definition ClerkPool : go_type := structT [
  "mu" :: ptrT;
  "cls" :: sliceT;
  "confHosts" :: sliceT
].

(* go: clerkpool.go:18:6 *)
Definition MakeClerkPool : val :=
  rec: "MakeClerkPool" "confHosts" :=
    exception_do (let: "confHosts" := (mem.alloc "confHosts") in
    return: (mem.alloc (let: "$mu" := (mem.alloc (type.zero_val #sync.Mutex)) in
     let: "$cls" := (slice.make2 #ptrT #(W64 0)) in
     let: "$confHosts" := (![#sliceT] "confHosts") in
     struct.make #ClerkPool [{
       "mu" ::= "$mu";
       "cls" ::= "$cls";
       "confHosts" ::= "$confHosts"
     }]))).

(* TODO: get rid of stale clerks from the ck.cls list?
   TODO: keep failed clerks out of ck.cls list? Maybe f(cl) can return an
   optional error saying "get rid of cl".

   go: clerkpool.go:29:22 *)
Definition ClerkPool__doWithClerk : val :=
  rec: "ClerkPool__doWithClerk" "ck" "f" :=
    exception_do (let: "ck" := (mem.alloc "ck") in
    let: "f" := (mem.alloc "f") in
    do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref #ClerkPool #"mu"%go (![#ptrT] "ck")))) #());;;
    let: "cl" := (mem.alloc (type.zero_val #ptrT)) in
    (if: int_gt (let: "$a0" := (![#sliceT] (struct.field_ref #ClerkPool #"cls"%go (![#ptrT] "ck"))) in
    slice.len "$a0") #(W64 0)
    then
      let: "$r0" := (![#ptrT] (slice.elem_ref #ptrT (![#sliceT] (struct.field_ref #ClerkPool #"cls"%go (![#ptrT] "ck"))) #(W64 0))) in
      do:  ("cl" <-[#ptrT] "$r0");;;
      let: "$r0" := (let: "$s" := (![#sliceT] (struct.field_ref #ClerkPool #"cls"%go (![#ptrT] "ck"))) in
      slice.slice #ptrT "$s" #(W64 1) (slice.len "$s")) in
      do:  ((struct.field_ref #ClerkPool #"cls"%go (![#ptrT] "ck")) <-[#sliceT] "$r0");;;
      do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #ClerkPool #"mu"%go (![#ptrT] "ck")))) #());;;
      do:  (let: "$a0" := (![#ptrT] "cl") in
      (![#funcT] "f") "$a0");;;
      do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref #ClerkPool #"mu"%go (![#ptrT] "ck")))) #());;;
      let: "$r0" := (let: "$a0" := (![#sliceT] (struct.field_ref #ClerkPool #"cls"%go (![#ptrT] "ck"))) in
      let: "$a1" := ((let: "$sl0" := (![#ptrT] "cl") in
      slice.literal #ptrT ["$sl0"])) in
      (slice.append #ptrT) "$a0" "$a1") in
      do:  ((struct.field_ref #ClerkPool #"cls"%go (![#ptrT] "ck")) <-[#sliceT] "$r0");;;
      do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #ClerkPool #"mu"%go (![#ptrT] "ck")))) #())
    else
      do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #ClerkPool #"mu"%go (![#ptrT] "ck")))) #());;;
      let: "$r0" := (let: "$a0" := (![#sliceT] (struct.field_ref #ClerkPool #"confHosts"%go (![#ptrT] "ck"))) in
      (func_call #vkv.vkv #"MakeClerk"%go) "$a0") in
      do:  ("cl" <-[#ptrT] "$r0");;;
      do:  (let: "$a0" := (![#ptrT] "cl") in
      (![#funcT] "f") "$a0");;;
      do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref #ClerkPool #"mu"%go (![#ptrT] "ck")))) #());;;
      let: "$r0" := (let: "$a0" := (![#sliceT] (struct.field_ref #ClerkPool #"cls"%go (![#ptrT] "ck"))) in
      let: "$a1" := ((let: "$sl0" := (![#ptrT] "cl") in
      slice.literal #ptrT ["$sl0"])) in
      (slice.append #ptrT) "$a0" "$a1") in
      do:  ((struct.field_ref #ClerkPool #"cls"%go (![#ptrT] "ck")) <-[#sliceT] "$r0");;;
      do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #ClerkPool #"mu"%go (![#ptrT] "ck")))) #()))).

(* go: clerkpool.go:55:22 *)
Definition ClerkPool__Put : val :=
  rec: "ClerkPool__Put" "ck" "key" "val" :=
    exception_do (let: "ck" := (mem.alloc "ck") in
    let: "val" := (mem.alloc "val") in
    let: "key" := (mem.alloc "key") in
    do:  (let: "$a0" := (λ: "ck",
      exception_do (let: "ck" := (mem.alloc "ck") in
      do:  (let: "$a0" := (![#stringT] "key") in
      let: "$a1" := (![#stringT] "val") in
      (method_call #vkv.vkv #"Clerk'ptr" #"Put" (![#ptrT] "ck")) "$a0" "$a1"))
      ) in
    (method_call #vkv.vkv #"ClerkPool'ptr" #"doWithClerk" (![#ptrT] "ck")) "$a0")).

(* go: clerkpool.go:61:22 *)
Definition ClerkPool__Get : val :=
  rec: "ClerkPool__Get" "ck" "key" :=
    exception_do (let: "ck" := (mem.alloc "ck") in
    let: "key" := (mem.alloc "key") in
    let: "ret" := (mem.alloc (type.zero_val #stringT)) in
    do:  (let: "$a0" := (λ: "ck",
      exception_do (let: "ck" := (mem.alloc "ck") in
      let: "$r0" := (let: "$a0" := (![#stringT] "key") in
      (method_call #vkv.vkv #"Clerk'ptr" #"Get" (![#ptrT] "ck")) "$a0") in
      do:  ("ret" <-[#stringT] "$r0"))
      ) in
    (method_call #vkv.vkv #"ClerkPool'ptr" #"doWithClerk" (![#ptrT] "ck")) "$a0");;;
    return: (![#stringT] "ret")).

(* go: clerkpool.go:69:22 *)
Definition ClerkPool__ConditionalPut : val :=
  rec: "ClerkPool__ConditionalPut" "ck" "key" "expect" "val" :=
    exception_do (let: "ck" := (mem.alloc "ck") in
    let: "val" := (mem.alloc "val") in
    let: "expect" := (mem.alloc "expect") in
    let: "key" := (mem.alloc "key") in
    let: "ret" := (mem.alloc (type.zero_val #stringT)) in
    do:  (let: "$a0" := (λ: "ck",
      exception_do (let: "ck" := (mem.alloc "ck") in
      let: "$r0" := (let: "$a0" := (![#stringT] "key") in
      let: "$a1" := (![#stringT] "expect") in
      let: "$a2" := (![#stringT] "val") in
      (method_call #vkv.vkv #"Clerk'ptr" #"CondPut" (![#ptrT] "ck")) "$a0" "$a1" "$a2") in
      do:  ("ret" <-[#stringT] "$r0"))
      ) in
    (method_call #vkv.vkv #"ClerkPool'ptr" #"doWithClerk" (![#ptrT] "ck")) "$a0");;;
    return: (![#stringT] "ret")).

(* go: clerkpool.go:77:6 *)
Definition MakeKv : val :=
  rec: "MakeKv" "confHosts" :=
    exception_do (let: "confHosts" := (mem.alloc "confHosts") in
    let: "ck" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "confHosts") in
    (func_call #vkv.vkv #"MakeClerkPool"%go) "$a0") in
    do:  ("ck" <-[#ptrT] "$r0");;;
    return: (interface.make #vkv.vkv #"ClerkPool'ptr" (![#ptrT] "ck"))).

Definition KVState : go_type := structT [
  "kvs" :: mapT stringT stringT;
  "vnums" :: mapT stringT uint64T;
  "minVnum" :: uint64T
].

Definition OP_PUT : expr := #(W8 0).

Definition OP_GET : expr := #(W8 1).

Definition OP_COND_PUT : expr := #(W8 2).

(* go: server.go:35:6 *)
Definition encodePutArgs : val :=
  rec: "encodePutArgs" "args" :=
    exception_do (let: "args" := (mem.alloc "args") in
    let: "enc" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make3 #byteT #(W64 1) #(W64 (1 + 8))) in
    do:  ("enc" <-[#sliceT] "$r0");;;
    let: "$r0" := OP_PUT in
    do:  ((slice.elem_ref #byteT (![#sliceT] "enc") #(W64 0)) <-[#byteT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "enc") in
    let: "$a1" := (s_to_w64 (let: "$a0" := (![#stringT] (struct.field_ref #PutArgs #"Key"%go (![#ptrT] "args"))) in
    StringLength "$a0")) in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("enc" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "enc") in
    let: "$a1" := (string.to_bytes (![#stringT] (struct.field_ref #PutArgs #"Key"%go (![#ptrT] "args")))) in
    (func_call #marshal.marshal #"WriteBytes"%go) "$a0" "$a1") in
    do:  ("enc" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "enc") in
    let: "$a1" := (string.to_bytes (![#stringT] (struct.field_ref #PutArgs #"Val"%go (![#ptrT] "args")))) in
    (func_call #marshal.marshal #"WriteBytes"%go) "$a0" "$a1") in
    do:  ("enc" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "enc")).

(* go: server.go:46:6 *)
Definition decodePutArgs : val :=
  rec: "decodePutArgs" "raw_args" :=
    exception_do (let: "raw_args" := (mem.alloc "raw_args") in
    let: "enc" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$s" := (![#sliceT] "raw_args") in
    slice.slice #byteT "$s" #(W64 1) (slice.len "$s")) in
    do:  ("enc" <-[#sliceT] "$r0");;;
    let: "args" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #PutArgs)) in
    do:  ("args" <-[#ptrT] "$r0");;;
    let: "l" := (mem.alloc (type.zero_val #uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "enc") in
    (func_call #marshal.marshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("l" <-[#uint64T] "$r0");;;
    do:  ("enc" <-[#sliceT] "$r1");;;
    let: "$r0" := (string.from_bytes (let: "$s" := (![#sliceT] "enc") in
    slice.slice #byteT "$s" #(W64 0) (![#uint64T] "l"))) in
    do:  ((struct.field_ref #PutArgs #"Key"%go (![#ptrT] "args")) <-[#stringT] "$r0");;;
    let: "$r0" := (string.from_bytes (let: "$s" := (![#sliceT] "enc") in
    slice.slice #byteT "$s" (![#uint64T] "l") (slice.len "$s"))) in
    do:  ((struct.field_ref #PutArgs #"Val"%go (![#ptrT] "args")) <-[#stringT] "$r0");;;
    return: (![#ptrT] "args")).

Definition getArgs : go_type := stringT.

(* go: server.go:60:6 *)
Definition encodeGetArgs : val :=
  rec: "encodeGetArgs" "args" :=
    exception_do (let: "args" := (mem.alloc "args") in
    let: "enc" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make3 #byteT #(W64 1) #(W64 1)) in
    do:  ("enc" <-[#sliceT] "$r0");;;
    let: "$r0" := OP_GET in
    do:  ((slice.elem_ref #byteT (![#sliceT] "enc") #(W64 0)) <-[#byteT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "enc") in
    let: "$a1" := (string.to_bytes (![#stringT] "args")) in
    (func_call #marshal.marshal #"WriteBytes"%go) "$a0" "$a1") in
    do:  ("enc" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "enc")).

(* go: server.go:67:6 *)
Definition decodeGetArgs : val :=
  rec: "decodeGetArgs" "raw_args" :=
    exception_do (let: "raw_args" := (mem.alloc "raw_args") in
    return: (string.from_bytes (let: "$s" := (![#sliceT] "raw_args") in
     slice.slice #byteT "$s" #(W64 1) (slice.len "$s")))).

(* go: server.go:78:6 *)
Definition encodeCondPutArgs : val :=
  rec: "encodeCondPutArgs" "args" :=
    exception_do (let: "args" := (mem.alloc "args") in
    let: "enc" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make3 #byteT #(W64 1) #(W64 (1 + 8))) in
    do:  ("enc" <-[#sliceT] "$r0");;;
    let: "$r0" := OP_COND_PUT in
    do:  ((slice.elem_ref #byteT (![#sliceT] "enc") #(W64 0)) <-[#byteT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "enc") in
    let: "$a1" := (s_to_w64 (let: "$a0" := (![#stringT] (struct.field_ref #CondPutArgs #"Key"%go (![#ptrT] "args"))) in
    StringLength "$a0")) in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("enc" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "enc") in
    let: "$a1" := (string.to_bytes (![#stringT] (struct.field_ref #CondPutArgs #"Key"%go (![#ptrT] "args")))) in
    (func_call #marshal.marshal #"WriteBytes"%go) "$a0" "$a1") in
    do:  ("enc" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "enc") in
    let: "$a1" := (s_to_w64 (let: "$a0" := (![#stringT] (struct.field_ref #CondPutArgs #"Expect"%go (![#ptrT] "args"))) in
    StringLength "$a0")) in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("enc" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "enc") in
    let: "$a1" := (string.to_bytes (![#stringT] (struct.field_ref #CondPutArgs #"Expect"%go (![#ptrT] "args")))) in
    (func_call #marshal.marshal #"WriteBytes"%go) "$a0" "$a1") in
    do:  ("enc" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "enc") in
    let: "$a1" := (string.to_bytes (![#stringT] (struct.field_ref #CondPutArgs #"Val"%go (![#ptrT] "args")))) in
    (func_call #marshal.marshal #"WriteBytes"%go) "$a0" "$a1") in
    do:  ("enc" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "enc")).

(* go: server.go:91:6 *)
Definition decodeCondPutArgs : val :=
  rec: "decodeCondPutArgs" "raw_args" :=
    exception_do (let: "raw_args" := (mem.alloc "raw_args") in
    let: "enc" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$s" := (![#sliceT] "raw_args") in
    slice.slice #byteT "$s" #(W64 1) (slice.len "$s")) in
    do:  ("enc" <-[#sliceT] "$r0");;;
    let: "args" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #CondPutArgs)) in
    do:  ("args" <-[#ptrT] "$r0");;;
    let: "l" := (mem.alloc (type.zero_val #uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "enc") in
    (func_call #marshal.marshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("l" <-[#uint64T] "$r0");;;
    do:  ("enc" <-[#sliceT] "$r1");;;
    let: "enc2" := (mem.alloc (type.zero_val #sliceT)) in
    let: "keybytes" := (mem.alloc (type.zero_val #sliceT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "enc") in
    let: "$a1" := (![#uint64T] "l") in
    (func_call #marshal.marshal #"ReadBytes"%go) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("keybytes" <-[#sliceT] "$r0");;;
    do:  ("enc2" <-[#sliceT] "$r1");;;
    let: "$r0" := (string.from_bytes (![#sliceT] "keybytes")) in
    do:  ((struct.field_ref #CondPutArgs #"Key"%go (![#ptrT] "args")) <-[#stringT] "$r0");;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "enc2") in
    (func_call #marshal.marshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("l" <-[#uint64T] "$r0");;;
    do:  ("enc" <-[#sliceT] "$r1");;;
    let: "$r0" := (string.from_bytes (let: "$s" := (![#sliceT] "enc") in
    slice.slice #byteT "$s" #(W64 0) (![#uint64T] "l"))) in
    do:  ((struct.field_ref #CondPutArgs #"Expect"%go (![#ptrT] "args")) <-[#stringT] "$r0");;;
    let: "$r0" := (string.from_bytes (let: "$s" := (![#sliceT] "enc") in
    slice.slice #byteT "$s" (![#uint64T] "l") (slice.len "$s"))) in
    do:  ((struct.field_ref #CondPutArgs #"Val"%go (![#ptrT] "args")) <-[#stringT] "$r0");;;
    return: (![#ptrT] "args")).

(* end of marshalling

   go: server.go:107:19 *)
Definition KVState__put : val :=
  rec: "KVState__put" "s" "args" :=
    exception_do (let: "s" := (mem.alloc "s") in
    let: "args" := (mem.alloc "args") in
    let: "$r0" := (![#stringT] (struct.field_ref #PutArgs #"Val"%go (![#ptrT] "args"))) in
    do:  (map.insert (![type.mapT #stringT #stringT] (struct.field_ref #KVState #"kvs"%go (![#ptrT] "s"))) (![#stringT] (struct.field_ref #PutArgs #"Key"%go (![#ptrT] "args"))) "$r0");;;
    return: (slice.make2 #byteT #(W64 0))).

(* go: server.go:112:19 *)
Definition KVState__get : val :=
  rec: "KVState__get" "s" "args" :=
    exception_do (let: "s" := (mem.alloc "s") in
    let: "args" := (mem.alloc "args") in
    return: (string.to_bytes (Fst (map.get (![type.mapT #stringT #stringT] (struct.field_ref #KVState #"kvs"%go (![#ptrT] "s"))) (![#stringT] "args"))))).

(* go: server.go:116:19 *)
Definition KVState__apply : val :=
  rec: "KVState__apply" "s" "args" "vnum" :=
    exception_do (let: "s" := (mem.alloc "s") in
    let: "vnum" := (mem.alloc "vnum") in
    let: "args" := (mem.alloc "args") in
    (if: (![#byteT] (slice.elem_ref #byteT (![#sliceT] "args") #(W64 0))) = OP_PUT
    then
      let: "args" := (mem.alloc (type.zero_val #ptrT)) in
      let: "$r0" := (let: "$a0" := (![#sliceT] "args") in
      (func_call #vkv.vkv #"decodePutArgs"%go) "$a0") in
      do:  ("args" <-[#ptrT] "$r0");;;
      let: "$r0" := (![#uint64T] "vnum") in
      do:  (map.insert (![type.mapT #stringT #uint64T] (struct.field_ref #KVState #"vnums"%go (![#ptrT] "s"))) (![#stringT] (struct.field_ref #PutArgs #"Key"%go (![#ptrT] "args"))) "$r0");;;
      return: (let: "$a0" := (![#ptrT] "args") in
       (method_call #vkv.vkv #"KVState'ptr" #"put" (![#ptrT] "s")) "$a0")
    else
      (if: (![#byteT] (slice.elem_ref #byteT (![#sliceT] "args") #(W64 0))) = OP_GET
      then
        let: "key" := (mem.alloc (type.zero_val #stringT)) in
        let: "$r0" := (let: "$a0" := (![#sliceT] "args") in
        (func_call #vkv.vkv #"decodeGetArgs"%go) "$a0") in
        do:  ("key" <-[#stringT] "$r0");;;
        let: "$r0" := (![#uint64T] "vnum") in
        do:  (map.insert (![type.mapT #stringT #uint64T] (struct.field_ref #KVState #"vnums"%go (![#ptrT] "s"))) (![#stringT] "key") "$r0");;;
        return: (let: "$a0" := (![#stringT] "key") in
         (method_call #vkv.vkv #"KVState'ptr" #"get" (![#ptrT] "s")) "$a0")
      else
        (if: (![#byteT] (slice.elem_ref #byteT (![#sliceT] "args") #(W64 0))) = OP_COND_PUT
        then
          let: "args" := (mem.alloc (type.zero_val #ptrT)) in
          let: "$r0" := (let: "$a0" := (![#sliceT] "args") in
          (func_call #vkv.vkv #"decodeCondPutArgs"%go) "$a0") in
          do:  ("args" <-[#ptrT] "$r0");;;
          (if: (Fst (map.get (![type.mapT #stringT #stringT] (struct.field_ref #KVState #"kvs"%go (![#ptrT] "s"))) (![#stringT] (struct.field_ref #CondPutArgs #"Key"%go (![#ptrT] "args"))))) = (![#stringT] (struct.field_ref #CondPutArgs #"Expect"%go (![#ptrT] "args")))
          then
            let: "$r0" := (![#uint64T] "vnum") in
            do:  (map.insert (![type.mapT #stringT #uint64T] (struct.field_ref #KVState #"vnums"%go (![#ptrT] "s"))) (![#stringT] (struct.field_ref #CondPutArgs #"Key"%go (![#ptrT] "args"))) "$r0");;;
            let: "$r0" := (![#stringT] (struct.field_ref #CondPutArgs #"Val"%go (![#ptrT] "args"))) in
            do:  (map.insert (![type.mapT #stringT #stringT] (struct.field_ref #KVState #"kvs"%go (![#ptrT] "s"))) (![#stringT] (struct.field_ref #CondPutArgs #"Key"%go (![#ptrT] "args"))) "$r0");;;
            return: (string.to_bytes #"ok"%go)
          else do:  #());;;
          return: (string.to_bytes #""%go)
        else
          do:  (let: "$a0" := (interface.make #""%go #"string"%go #"unexpected op type"%go) in
          Panic "$a0"))))).

(* go: server.go:138:19 *)
Definition KVState__applyReadonly : val :=
  rec: "KVState__applyReadonly" "s" "args" :=
    exception_do (let: "s" := (mem.alloc "s") in
    let: "args" := (mem.alloc "args") in
    (if: (![#byteT] (slice.elem_ref #byteT (![#sliceT] "args") #(W64 0))) ≠ OP_GET
    then
      do:  (let: "$a0" := (interface.make #""%go #"string"%go #"expected a GET as readonly-operation"%go) in
      Panic "$a0")
    else do:  #());;;
    let: "key" := (mem.alloc (type.zero_val #stringT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "args") in
    (func_call #vkv.vkv #"decodeGetArgs"%go) "$a0") in
    do:  ("key" <-[#stringT] "$r0");;;
    let: "reply" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#stringT] "key") in
    (method_call #vkv.vkv #"KVState'ptr" #"get" (![#ptrT] "s")) "$a0") in
    do:  ("reply" <-[#sliceT] "$r0");;;
    let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "vnum" := (mem.alloc (type.zero_val #uint64T)) in
    let: ("$ret0", "$ret1") := (map.get (![type.mapT #stringT #uint64T] (struct.field_ref #KVState #"vnums"%go (![#ptrT] "s"))) (![#stringT] "key")) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("vnum" <-[#uint64T] "$r0");;;
    do:  ("ok" <-[#boolT] "$r1");;;
    (if: ![#boolT] "ok"
    then return: (![#uint64T] "vnum", ![#sliceT] "reply")
    else return: (![#uint64T] (struct.field_ref #KVState #"minVnum"%go (![#ptrT] "s")), ![#sliceT] "reply"))).

(* go: server.go:152:19 *)
Definition KVState__getState : val :=
  rec: "KVState__getState" "s" <> :=
    exception_do (let: "s" := (mem.alloc "s") in
    return: (let: "$a0" := (![type.mapT #stringT #stringT] (struct.field_ref #KVState #"kvs"%go (![#ptrT] "s"))) in
     (func_call #map_string_marshal.map_string_marshal #"EncodeStringMap"%go) "$a0")).

(* go: server.go:156:19 *)
Definition KVState__setState : val :=
  rec: "KVState__setState" "s" "snap" "nextIndex" :=
    exception_do (let: "s" := (mem.alloc "s") in
    let: "nextIndex" := (mem.alloc "nextIndex") in
    let: "snap" := (mem.alloc "snap") in
    let: "$r0" := (![#uint64T] "nextIndex") in
    do:  ((struct.field_ref #KVState #"minVnum"%go (![#ptrT] "s")) <-[#uint64T] "$r0");;;
    let: "$r0" := (map.make #stringT #uint64T) in
    do:  ((struct.field_ref #KVState #"vnums"%go (![#ptrT] "s")) <-[type.mapT #stringT #uint64T] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "snap") in
    (func_call #map_string_marshal.map_string_marshal #"DecodeStringMap"%go) "$a0") in
    do:  ((struct.field_ref #KVState #"kvs"%go (![#ptrT] "s")) <-[type.mapT #stringT #stringT] "$r0")).

(* go: server.go:175:6 *)
Definition makeVersionedStateMachine : val :=
  rec: "makeVersionedStateMachine" <> :=
    exception_do (let: "s" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #KVState)) in
    do:  ("s" <-[#ptrT] "$r0");;;
    let: "$r0" := (map.make #stringT #stringT) in
    do:  ((struct.field_ref #KVState #"kvs"%go (![#ptrT] "s")) <-[type.mapT #stringT #stringT] "$r0");;;
    let: "$r0" := (map.make #stringT #uint64T) in
    do:  ((struct.field_ref #KVState #"vnums"%go (![#ptrT] "s")) <-[type.mapT #stringT #uint64T] "$r0");;;
    return: (mem.alloc (let: "$ApplyVolatile" := (method_call #vkv.vkv #"KVState'ptr" #"apply" (![#ptrT] "s")) in
     let: "$ApplyReadonly" := (method_call #vkv.vkv #"KVState'ptr" #"applyReadonly" (![#ptrT] "s")) in
     let: "$GetState" := (λ: <>,
       exception_do (return: ((method_call #vkv.vkv #"KVState'ptr" #"getState" (![#ptrT] "s")) #()))
       ) in
     let: "$SetState" := (method_call #vkv.vkv #"KVState'ptr" #"setState" (![#ptrT] "s")) in
     struct.make #exactlyonce.VersionedStateMachine [{
       "ApplyVolatile" ::= "$ApplyVolatile";
       "ApplyReadonly" ::= "$ApplyReadonly";
       "SetState" ::= "$SetState";
       "GetState" ::= "$GetState"
     }]))).

(* go: server.go:188:6 *)
Definition Start : val :=
  rec: "Start" "fname" "host" "confHosts" :=
    exception_do (let: "confHosts" := (mem.alloc "confHosts") in
    let: "host" := (mem.alloc "host") in
    let: "fname" := (mem.alloc "fname") in
    do:  (let: "$a0" := (![#uint64T] "host") in
    (method_call #replica #"Server'ptr" #"Serve" (let: "$a0" := (let: "$a0" := ((func_call #vkv.vkv #"makeVersionedStateMachine"%go) #()) in
    (func_call #exactlyonce.exactlyonce #"MakeExactlyOnceStateMachine"%go) "$a0") in
    let: "$a1" := (![#stringT] "fname") in
    let: "$a2" := (![#sliceT] "confHosts") in
    (func_call #storage.storage #"MakePbServer"%go) "$a0" "$a1" "$a2")) "$a0")).

Definition vars' : list (go_string * go_type) := [].

Definition functions' : list (go_string * val) := [("MakeClerk"%go, MakeClerk); ("MakeClerkPool"%go, MakeClerkPool); ("MakeKv"%go, MakeKv); ("encodePutArgs"%go, encodePutArgs); ("decodePutArgs"%go, decodePutArgs); ("encodeGetArgs"%go, encodeGetArgs); ("decodeGetArgs"%go, decodeGetArgs); ("encodeCondPutArgs"%go, encodeCondPutArgs); ("decodeCondPutArgs"%go, decodeCondPutArgs); ("makeVersionedStateMachine"%go, makeVersionedStateMachine); ("Start"%go, Start)].

Definition msets' : list (go_string * (list (go_string * val))) := [("Clerk"%go, []); ("Clerk'ptr"%go, [("CondPut"%go, Clerk__CondPut); ("Get"%go, Clerk__Get); ("Put"%go, Clerk__Put)]); ("ClerkPool"%go, []); ("ClerkPool'ptr"%go, [("ConditionalPut"%go, ClerkPool__ConditionalPut); ("Get"%go, ClerkPool__Get); ("Put"%go, ClerkPool__Put); ("doWithClerk"%go, ClerkPool__doWithClerk)]); ("KVState"%go, []); ("KVState'ptr"%go, [("apply"%go, KVState__apply); ("applyReadonly"%go, KVState__applyReadonly); ("get"%go, KVState__get); ("getState"%go, KVState__getState); ("put"%go, KVState__put); ("setState"%go, KVState__setState)]); ("PutArgs"%go, []); ("PutArgs'ptr"%go, []); ("CondPutArgs"%go, []); ("CondPutArgs'ptr"%go, [])].

#[global] Instance info' : PkgInfo vkv.vkv :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [grove_ffi.grove_ffi; exactlyonce.exactlyonce; sync.sync; kv.kv; map_string_marshal.map_string_marshal; storage.storage; marshal.marshal];
  |}.

Definition initialize' : val :=
  rec: "initialize'" <> :=
    globals.package_init vkv.vkv (λ: <>,
      exception_do (do:  marshal.initialize';;;
      do:  storage.initialize';;;
      do:  map_string_marshal.initialize';;;
      do:  kv.initialize';;;
      do:  sync.initialize';;;
      do:  exactlyonce.initialize';;;
      do:  grove_ffi.initialize')
      ).

End code.
End vkv.
