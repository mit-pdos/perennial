(* autogenerated from github.com/mit-pdos/gokv/vrsm/apps/closed *)
From New.golang Require Import defn.
Require Export New.code.github_com.mit_pdos.gokv.bank.
Require Export New.code.github_com.mit_pdos.gokv.cachekv.
Require Export New.code.github_com.mit_pdos.gokv.grove_ffi.
Require Export New.code.github_com.mit_pdos.gokv.lockservice.
Require Export New.code.github_com.mit_pdos.gokv.vrsm.apps.vkv.
Require Export New.code.github_com.mit_pdos.gokv.vrsm.configservice.

Definition closed : go_string := "github.com/mit-pdos/gokv/vrsm/apps/closed".

From New Require Import grove_prelude.
Module closed.
Section code.


Definition dconfigHost : expr := #(W64 11).

Definition dconfigHostPaxos : expr := #(W64 12).

Definition dr1 : expr := #(W64 1).

Definition dr2 : expr := #(W64 2).

Definition lconfigHost : expr := #(W64 111).

Definition lconfigHostPaxos : expr := #(W64 112).

Definition lr1 : expr := #(W64 101).

Definition lr2 : expr := #(W64 102).

(* go: mains.go:28:6 *)
Definition mk_lconfig_hosts : val :=
  rec: "mk_lconfig_hosts" <> :=
    exception_do (let: "configHosts" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make2 #uint64T #(W64 0)) in
    do:  ("configHosts" <-[#sliceT] "$r0");;;
    return: (let: "$a0" := (![#sliceT] "configHosts") in
     let: "$a1" := ((let: "$sl0" := lconfigHost in
     slice.literal #uint64T ["$sl0"])) in
     (slice.append #uint64T) "$a0" "$a1")).

(* go: mains.go:33:6 *)
Definition mk_dconfig_hosts : val :=
  rec: "mk_dconfig_hosts" <> :=
    exception_do (let: "configHosts" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make2 #uint64T #(W64 0)) in
    do:  ("configHosts" <-[#sliceT] "$r0");;;
    return: (let: "$a0" := (![#sliceT] "configHosts") in
     let: "$a1" := ((let: "$sl0" := dconfigHost in
     slice.literal #uint64T ["$sl0"])) in
     (slice.append #uint64T) "$a0" "$a1")).

(* go: mains.go:38:6 *)
Definition mk_lconfig_paxosHosts : val :=
  rec: "mk_lconfig_paxosHosts" <> :=
    exception_do (let: "configHosts" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make2 #uint64T #(W64 0)) in
    do:  ("configHosts" <-[#sliceT] "$r0");;;
    return: (let: "$a0" := (![#sliceT] "configHosts") in
     let: "$a1" := ((let: "$sl0" := lconfigHostPaxos in
     slice.literal #uint64T ["$sl0"])) in
     (slice.append #uint64T) "$a0" "$a1")).

(* go: mains.go:43:6 *)
Definition mk_dconfig_paxosHosts : val :=
  rec: "mk_dconfig_paxosHosts" <> :=
    exception_do (let: "configHosts" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make2 #uint64T #(W64 0)) in
    do:  ("configHosts" <-[#sliceT] "$r0");;;
    return: (let: "$a0" := (![#sliceT] "configHosts") in
     let: "$a1" := ((let: "$sl0" := dconfigHostPaxos in
     slice.literal #uint64T ["$sl0"])) in
     (slice.append #uint64T) "$a0" "$a1")).

(* go: mains.go:48:6 *)
Definition lconfig_main : val :=
  rec: "lconfig_main" "fname" :=
    exception_do (let: "fname" := (mem.alloc "fname") in
    let: "servers" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make2 #uint64T #(W64 0)) in
    do:  ("servers" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "servers") in
    let: "$a1" := ((let: "$sl0" := lr1 in
    slice.literal #uint64T ["$sl0"])) in
    (slice.append #uint64T) "$a0" "$a1") in
    do:  ("servers" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "servers") in
    let: "$a1" := ((let: "$sl0" := lr2 in
    slice.literal #uint64T ["$sl0"])) in
    (slice.append #uint64T) "$a0" "$a1") in
    do:  ("servers" <-[#sliceT] "$r0");;;
    do:  (let: "$a0" := (![#stringT] "fname") in
    let: "$a1" := lconfigHost in
    let: "$a2" := lconfigHostPaxos in
    let: "$a3" := ((func_call #closed.closed #"mk_lconfig_paxosHosts"%go) #()) in
    let: "$a4" := (![#sliceT] "servers") in
    (func_call #configservice.configservice #"StartServer"%go) "$a0" "$a1" "$a2" "$a3" "$a4");;;
    return: #()).

(* go: mains.go:55:6 *)
Definition dconfig_main : val :=
  rec: "dconfig_main" "fname" :=
    exception_do (let: "fname" := (mem.alloc "fname") in
    let: "servers" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make2 #uint64T #(W64 0)) in
    do:  ("servers" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "servers") in
    let: "$a1" := ((let: "$sl0" := dr1 in
    slice.literal #uint64T ["$sl0"])) in
    (slice.append #uint64T) "$a0" "$a1") in
    do:  ("servers" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "servers") in
    let: "$a1" := ((let: "$sl0" := dr2 in
    slice.literal #uint64T ["$sl0"])) in
    (slice.append #uint64T) "$a0" "$a1") in
    do:  ("servers" <-[#sliceT] "$r0");;;
    do:  (let: "$a0" := (![#stringT] "fname") in
    let: "$a1" := dconfigHost in
    let: "$a2" := dconfigHostPaxos in
    let: "$a3" := ((func_call #closed.closed #"mk_dconfig_paxosHosts"%go) #()) in
    let: "$a4" := (![#sliceT] "servers") in
    (func_call #configservice.configservice #"StartServer"%go) "$a0" "$a1" "$a2" "$a3" "$a4");;;
    return: #()).

(* go: mains.go:62:6 *)
Definition kv_replica_main : val :=
  rec: "kv_replica_main" "fname" "me" "configHost" :=
    exception_do (let: "configHost" := (mem.alloc "configHost") in
    let: "me" := (mem.alloc "me") in
    let: "fname" := (mem.alloc "fname") in
    let: "x" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #uint64T)) in
    do:  ("x" <-[#ptrT] "$r0");;;
    let: "$r0" := #(W64 1) in
    do:  ((![#ptrT] "x") <-[#uint64T] "$r0");;;
    let: "configHosts" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make2 #uint64T #(W64 0)) in
    do:  ("configHosts" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "configHosts") in
    let: "$a1" := ((let: "$sl0" := (![#uint64T] "configHost") in
    slice.literal #uint64T ["$sl0"])) in
    (slice.append #uint64T) "$a0" "$a1") in
    do:  ("configHosts" <-[#sliceT] "$r0");;;
    do:  (let: "$a0" := (![#stringT] "fname") in
    let: "$a1" := (![#uint64T] "me") in
    let: "$a2" := (![#sliceT] "configHosts") in
    (func_call #vkv.vkv #"Start"%go) "$a0" "$a1" "$a2");;;
    return: #()).

(* go: mains.go:70:6 *)
Definition makeBankClerk : val :=
  rec: "makeBankClerk" <> :=
    exception_do (let: "kvck" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := (let: "$a0" := ((func_call #closed.closed #"mk_dconfig_hosts"%go) #()) in
    (func_call #vkv.vkv #"MakeKv"%go) "$a0") in
    (func_call #cachekv.cachekv #"Make"%go) "$a0") in
    do:  ("kvck" <-[#ptrT] "$r0");;;
    let: "lck" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := (let: "$a0" := ((func_call #closed.closed #"mk_lconfig_hosts"%go) #()) in
    (func_call #vkv.vkv #"MakeKv"%go) "$a0") in
    (func_call #lockservice.lockservice #"MakeLockClerk"%go) "$a0") in
    do:  ("lck" <-[#ptrT] "$r0");;;
    return: (let: "$a0" := (![#ptrT] "lck") in
     let: "$a1" := (interface.make (#cachekv, #"CacheKv'ptr") (![#ptrT] "kvck")) in
     let: "$a2" := #"init"%go in
     let: "$a3" := #"a1"%go in
     let: "$a4" := #"a2"%go in
     (func_call #bank.bank #"MakeBankClerk"%go) "$a0" "$a1" "$a2" "$a3" "$a4")).

(* go: mains.go:77:6 *)
Definition bank_transferer_main : val :=
  rec: "bank_transferer_main" <> :=
    exception_do (let: "bck" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := ((func_call #closed.closed #"makeBankClerk"%go) #()) in
    do:  ("bck" <-[#ptrT] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      do:  ((method_call #bank #"BankClerk'ptr" #"SimpleTransfer" (![#ptrT] "bck")) #()));;;
    return: #()).

(* go: mains.go:84:6 *)
Definition bank_auditor_main : val :=
  rec: "bank_auditor_main" <> :=
    exception_do (let: "bck" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := ((func_call #closed.closed #"makeBankClerk"%go) #()) in
    do:  ("bck" <-[#ptrT] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      do:  ((method_call #bank #"BankClerk'ptr" #"SimpleAudit" (![#ptrT] "bck")) #()));;;
    return: #()).

Definition vars' : list (go_string * go_type) := [].

Definition functions' : list (go_string * val) := [("mk_lconfig_hosts"%go, mk_lconfig_hosts); ("mk_dconfig_hosts"%go, mk_dconfig_hosts); ("mk_lconfig_paxosHosts"%go, mk_lconfig_paxosHosts); ("mk_dconfig_paxosHosts"%go, mk_dconfig_paxosHosts); ("lconfig_main"%go, lconfig_main); ("dconfig_main"%go, dconfig_main); ("kv_replica_main"%go, kv_replica_main); ("makeBankClerk"%go, makeBankClerk); ("bank_transferer_main"%go, bank_transferer_main); ("bank_auditor_main"%go, bank_auditor_main)].

Definition msets' : list (go_string * (list (go_string * val))) := [].

#[global] Instance info' : PkgInfo closed.closed :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [bank.bank; cachekv.cachekv; grove_ffi.grove_ffi; lockservice.lockservice; vkv.vkv; configservice.configservice];
  |}.

Definition initialize' : val :=
  rec: "initialize'" <> :=
    globals.package_init closed.closed (λ: <>,
      exception_do (do:  configservice.initialize';;;
      do:  vkv.initialize';;;
      do:  lockservice.initialize';;;
      do:  grove_ffi.initialize';;;
      do:  cachekv.initialize';;;
      do:  bank.initialize')
      ).

End code.
End closed.
