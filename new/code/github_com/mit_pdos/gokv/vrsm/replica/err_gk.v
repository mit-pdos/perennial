(* autogenerated from github.com/mit-pdos/gokv/vrsm/replica/err_gk *)
Require Export New.code.github_com.tchajed.marshal.
From New.golang Require Import defn.
Module pkg_id.
Definition err_gk : go_string := "github.com/mit-pdos/gokv/vrsm/replica/err_gk".

End pkg_id.
Export pkg_id.
Module err_gk.

Definition E {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/mit-pdos/gokv/vrsm/replica/err_gk.E"%go [].

Definition None {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W32 0).

Definition Stale {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W32 1).

Definition OutOfOrder {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W32 2).

Definition Timeout {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W32 3).

Definition EmptyConfig {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W32 4).

Definition NotLeader {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W32 5).

Definition Sealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W32 6).

Definition LeaseExpired {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W32 7).

Definition Leased {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W32 8).

Definition Name {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/gokv/vrsm/replica/err_gk.Name"%go.

Definition Value {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/gokv/vrsm/replica/err_gk.Value"%go.

Definition Marshal {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/gokv/vrsm/replica/err_gk.Marshal"%go.

Definition Unmarshal {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/gokv/vrsm/replica/err_gk.Unmarshal"%go.

(* go: err_gk.go:19:6 *)
Definition Marshalⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "enc" "e",
    exception_do (let: "e" := (GoAlloc E "e") in
    let: "enc" := (GoAlloc (go.SliceType go.byte) "enc") in
    return: (let: "$a0" := (![go.SliceType go.byte] "enc") in
     let: "$a1" := (![E] "e") in
     (FuncResolve marshal.WriteInt32 [] #()) "$a0" "$a1")).

(* go: err_gk.go:23:6 *)
Definition Unmarshalⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s",
    exception_do (let: "s" := (GoAlloc (go.SliceType go.byte) "s") in
    let: "e_raw" := (GoAlloc go.uint32 (GoZeroVal go.uint32 #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] "s") in
    (FuncResolve marshal.ReadInt32 [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("e_raw" <-[go.uint32] "$r0");;;
    do:  ("s" <-[go.SliceType go.byte] "$r1");;;
    return: (![go.uint32] "e_raw", ![go.SliceType go.byte] "s")).

(* go: err_gk.go:52:12 *)
Definition E__Stringⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "e" <>,
    exception_do (let: "e" := (GoAlloc E "e") in
    return: (map.lookup1 go.uint32 go.string (![go.MapType go.uint32 go.string] (GlobalVarAddr Name #())) (![E] "e"))).

#[global] Instance info' : PkgInfo pkg_id.err_gk :=
{|
  pkg_imported_pkgs := [code.github_com.tchajed.marshal.pkg_id.marshal]
|}.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init pkg_id.err_gk (λ: <>,
      exception_do (do:  (go.GlobalAlloc Value (go.MapType go.string go.uint32) #());;;
      do:  (go.GlobalAlloc Name (go.MapType go.uint32 go.string) #());;;
      do:  (marshal.initialize' #());;;
      let: "$r0" := (CompositeLiteral (go.MapType go.uint32 go.string) (LiteralValue [KeyedElement (Some (KeyExpression go.uint32 #(W32 0))) (ElementExpression go.string #"None"%go); KeyedElement (Some (KeyExpression go.uint32 #(W32 1))) (ElementExpression go.string #"Stale"%go); KeyedElement (Some (KeyExpression go.uint32 #(W32 2))) (ElementExpression go.string #"OutOfOrder"%go); KeyedElement (Some (KeyExpression go.uint32 #(W32 3))) (ElementExpression go.string #"Timeout"%go); KeyedElement (Some (KeyExpression go.uint32 #(W32 4))) (ElementExpression go.string #"EmptyConfig"%go); KeyedElement (Some (KeyExpression go.uint32 #(W32 5))) (ElementExpression go.string #"NotLeader"%go); KeyedElement (Some (KeyExpression go.uint32 #(W32 6))) (ElementExpression go.string #"Sealed"%go); KeyedElement (Some (KeyExpression go.uint32 #(W32 7))) (ElementExpression go.string #"LeaseExpired"%go); KeyedElement (Some (KeyExpression go.uint32 #(W32 8))) (ElementExpression go.string #"Leased"%go)])) in
      do:  ((GlobalVarAddr Name #()) <-[go.MapType go.uint32 go.string] "$r0");;;
      let: "$r0" := (CompositeLiteral (go.MapType go.string go.uint32) (LiteralValue [KeyedElement (Some (KeyExpression go.string #"None"%go)) (ElementExpression go.uint32 #(W32 0)); KeyedElement (Some (KeyExpression go.string #"Stale"%go)) (ElementExpression go.uint32 #(W32 1)); KeyedElement (Some (KeyExpression go.string #"OutOfOrder"%go)) (ElementExpression go.uint32 #(W32 2)); KeyedElement (Some (KeyExpression go.string #"Timeout"%go)) (ElementExpression go.uint32 #(W32 3)); KeyedElement (Some (KeyExpression go.string #"EmptyConfig"%go)) (ElementExpression go.uint32 #(W32 4)); KeyedElement (Some (KeyExpression go.string #"NotLeader"%go)) (ElementExpression go.uint32 #(W32 5)); KeyedElement (Some (KeyExpression go.string #"Sealed"%go)) (ElementExpression go.uint32 #(W32 6)); KeyedElement (Some (KeyExpression go.string #"LeaseExpired"%go)) (ElementExpression go.uint32 #(W32 7)); KeyedElement (Some (KeyExpression go.string #"Leased"%go)) (ElementExpression go.uint32 #(W32 8))])) in
      do:  ((GlobalVarAddr Value #()) <-[go.MapType go.string go.uint32] "$r0"))
      ).

Module E.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := w32.
End def.
End E.

Definition Eⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.uint32.

Class E_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] E_underlying :: (E) <u (Eⁱᵐᵖˡ);
  #[global] E_String_unfold :: MethodUnfold (E) "String" (E__Stringⁱᵐᵖˡ);
  #[global] E'ptr_String_unfold :: MethodUnfold (go.PointerType (E)) "String" (λ: "$r", MethodResolve (E) "String" (![(E)] "$r"));
}.

Class Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] E_instance :: E_Assumptions;
  #[global] Marshal_unfold :: FuncUnfold Marshal [] (Marshalⁱᵐᵖˡ);
  #[global] Unmarshal_unfold :: FuncUnfold Unmarshal [] (Unmarshalⁱᵐᵖˡ);
  #[global] import_marshal_Assumption :: marshal.Assumptions;
}.
End err_gk.
