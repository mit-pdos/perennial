(* autogenerated from github.com/mit-pdos/gokv/vrsm/replica/err_gk *)
Require Export New.code.github_com.tchajed.marshal.

From New.golang Require Import defn.
Definition err_gk : go_string := "github.com/mit-pdos/gokv/vrsm/replica/err_gk".

Module err_gk.

Module E. Definition id : go_string := "github.com/mit-pdos/gokv/vrsm/replica/err_gk.E"%go. End E.

Section code.
Context `{ffi_syntax}.


Definition E : go_type := uint32T.
#[global] Typeclasses Opaque E.
#[global] Opaque E.

Definition None : val := #(W32 0).

Definition Stale : val := #(W32 1).

Definition OutOfOrder : val := #(W32 2).

Definition Timeout : val := #(W32 3).

Definition EmptyConfig : val := #(W32 4).

Definition NotLeader : val := #(W32 5).

Definition Sealed : val := #(W32 6).

Definition LeaseExpired : val := #(W32 7).

Definition Leased : val := #(W32 8).

Definition Marshal : go_string := "github.com/mit-pdos/gokv/vrsm/replica/err_gk.Marshal"%go.

(* go: err_gk.go:19:6 *)
Definition Marshalⁱᵐᵖˡ : val :=
  λ: "enc" "e",
    exception_do (let: "e" := (mem.alloc "e") in
    let: "enc" := (mem.alloc "enc") in
    return: (let: "$a0" := (![#sliceT] "enc") in
     let: "$a1" := (![#E] "e") in
     (func_call #marshal.WriteInt32) "$a0" "$a1")).

Definition Unmarshal : go_string := "github.com/mit-pdos/gokv/vrsm/replica/err_gk.Unmarshal"%go.

(* go: err_gk.go:23:6 *)
Definition Unmarshalⁱᵐᵖˡ : val :=
  λ: "s",
    exception_do (let: "s" := (mem.alloc "s") in
    let: "e_raw" := (mem.alloc (type.zero_val #uint32T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "s") in
    (func_call #marshal.ReadInt32) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("e_raw" <-[#uint32T] "$r0");;;
    do:  ("s" <-[#sliceT] "$r1");;;
    return: (![#uint32T] "e_raw", ![#sliceT] "s")).

Definition Name : go_string := "github.com/mit-pdos/gokv/vrsm/replica/err_gk.Name"%go.

Definition Value : go_string := "github.com/mit-pdos/gokv/vrsm/replica/err_gk.Value"%go.

(* go: err_gk.go:52:12 *)
Definition E__Stringⁱᵐᵖˡ : val :=
  λ: "e" <>,
    exception_do (let: "e" := (mem.alloc "e") in
    return: (Fst (map.get (![type.mapT #uint32T #stringT] (globals.get #Name)) (![#E] "e")))).

Definition vars' : list (go_string * go_type) := [(Name, mapT uint32T stringT); (Value, mapT stringT uint32T)].

Definition functions' : list (go_string * val) := [(Marshal, Marshalⁱᵐᵖˡ); (Unmarshal, Unmarshalⁱᵐᵖˡ)].

Definition msets' : list (go_string * (list (go_string * val))) := [(E.id, [("String"%go, E__Stringⁱᵐᵖˡ)]); (ptrT.id E.id, [("String"%go, (λ: "$r",
                 method_call #E.id #"String"%go (![#E] "$r")
                 )%V)])].

#[global] Instance info' : PkgInfo err_gk.err_gk :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [code.github_com.tchajed.marshal.marshal];
  |}.

Definition initialize' : val :=
  λ: <>,
    package.init #err_gk.err_gk (λ: <>,
      exception_do (do:  (marshal.initialize' #());;;
      do:  (package.alloc err_gk.err_gk #());;;
      let: "$r0" := ((let: "$v0" := #"None"%go in
      let: "$k0" := #(W32 0) in
      let: "$v1" := #"Stale"%go in
      let: "$k1" := #(W32 1) in
      let: "$v2" := #"OutOfOrder"%go in
      let: "$k2" := #(W32 2) in
      let: "$v3" := #"Timeout"%go in
      let: "$k3" := #(W32 3) in
      let: "$v4" := #"EmptyConfig"%go in
      let: "$k4" := #(W32 4) in
      let: "$v5" := #"NotLeader"%go in
      let: "$k5" := #(W32 5) in
      let: "$v6" := #"Sealed"%go in
      let: "$k6" := #(W32 6) in
      let: "$v7" := #"LeaseExpired"%go in
      let: "$k7" := #(W32 7) in
      let: "$v8" := #"Leased"%go in
      let: "$k8" := #(W32 8) in
      map.literal #uint32T #stringT [map.kv_entry "$k0" "$v0"; map.kv_entry "$k1" "$v1"; map.kv_entry "$k2" "$v2"; map.kv_entry "$k3" "$v3"; map.kv_entry "$k4" "$v4"; map.kv_entry "$k5" "$v5"; map.kv_entry "$k6" "$v6"; map.kv_entry "$k7" "$v7"; map.kv_entry "$k8" "$v8"])) in
      do:  ((globals.get #Name) <-[type.mapT #uint32T #stringT] "$r0");;;
      let: "$r0" := ((let: "$v0" := #(W32 0) in
      let: "$k0" := #"None"%go in
      let: "$v1" := #(W32 1) in
      let: "$k1" := #"Stale"%go in
      let: "$v2" := #(W32 2) in
      let: "$k2" := #"OutOfOrder"%go in
      let: "$v3" := #(W32 3) in
      let: "$k3" := #"Timeout"%go in
      let: "$v4" := #(W32 4) in
      let: "$k4" := #"EmptyConfig"%go in
      let: "$v5" := #(W32 5) in
      let: "$k5" := #"NotLeader"%go in
      let: "$v6" := #(W32 6) in
      let: "$k6" := #"Sealed"%go in
      let: "$v7" := #(W32 7) in
      let: "$k7" := #"LeaseExpired"%go in
      let: "$v8" := #(W32 8) in
      let: "$k8" := #"Leased"%go in
      map.literal #stringT #uint32T [map.kv_entry "$k0" "$v0"; map.kv_entry "$k1" "$v1"; map.kv_entry "$k2" "$v2"; map.kv_entry "$k3" "$v3"; map.kv_entry "$k4" "$v4"; map.kv_entry "$k5" "$v5"; map.kv_entry "$k6" "$v6"; map.kv_entry "$k7" "$v7"; map.kv_entry "$k8" "$v8"])) in
      do:  ((globals.get #Value) <-[type.mapT #stringT #uint32T] "$r0"))
      ).

End code.
End err_gk.
