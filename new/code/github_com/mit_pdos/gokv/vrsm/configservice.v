(* autogenerated from github.com/mit-pdos/gokv/vrsm/configservice *)
Require Export New.code.sync.
Require Export New.code.github_com.goose_lang.primitive.
Require Export New.code.github_com.mit_pdos.gokv.grove_ffi.
Require Export New.code.github_com.mit_pdos.gokv.reconnectclient.
Require Export New.code.github_com.mit_pdos.gokv.vrsm.configservice.config_gk.
Require Export New.code.github_com.mit_pdos.gokv.vrsm.replica.err_gk.
Require Export New.code.github_com.tchajed.marshal.
Require Export New.code.log.
Require Export New.code.github_com.goose_lang.std.
Require Export New.code.github_com.mit_pdos.gokv.urpc.
Require Export New.code.github_com.mit_pdos.gokv.vrsm.paxos.
From New.golang Require Import defn.
From New Require Import grove_prelude.
Module pkg_id.
Definition configservice : go_string := "github.com/mit-pdos/gokv/vrsm/configservice".

End pkg_id.
Export pkg_id.
Module configservice.

Definition Clerk {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/mit-pdos/gokv/vrsm/configservice.Clerk"%go [].

Definition state {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/mit-pdos/gokv/vrsm/configservice.state"%go [].

Definition Server {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/mit-pdos/gokv/vrsm/configservice.Server"%go [].

Definition RPC_RESERVEEPOCH {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 0).

Definition RPC_GETCONFIG {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 1).

Definition RPC_TRYWRITECONFIG {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 2).

Definition RPC_GETLEASE {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 3).

(* 1 second *)
Definition LeaseInterval {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 1000000000).

Definition MakeClerk {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/gokv/vrsm/configservice.MakeClerk"%go.

Definition encodeState {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/gokv/vrsm/configservice.encodeState"%go.

Definition decodeState {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/gokv/vrsm/configservice.decodeState"%go.

Definition makeServer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/gokv/vrsm/configservice.makeServer"%go.

Definition StartServer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/gokv/vrsm/configservice.StartServer"%go.

(* go: client.go:27:6 *)
Definition MakeClerkⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "hosts",
    exception_do (let: "hosts" := (GoAlloc (go.SliceType grove_ffi.Address) "hosts") in
    let: "cls" := (GoAlloc (go.SliceType (go.PointerType reconnectclient.ReconnectingClient)) (GoZeroVal (go.SliceType (go.PointerType reconnectclient.ReconnectingClient)) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType (go.PointerType reconnectclient.ReconnectingClient)] #()) #(W64 0)) in
    do:  ("cls" <-[go.SliceType (go.PointerType reconnectclient.ReconnectingClient)] "$r0");;;
    let: "$range" := (![go.SliceType grove_ffi.Address] "hosts") in
    (let: "host" := (GoAlloc grove_ffi.Address (GoZeroVal grove_ffi.Address #())) in
    slice.for_range grove_ffi.Address "$range" (λ: "$key" "$value",
      do:  ("host" <-[grove_ffi.Address] "$value");;;
      do:  "$key";;;
      let: "$r0" := (let: "$a0" := (![go.SliceType (go.PointerType reconnectclient.ReconnectingClient)] "cls") in
      let: "$a1" := ((let: "$sl0" := (let: "$a0" := (![grove_ffi.Address] "host") in
      (FuncResolve reconnectclient.MakeReconnectingClient [] #()) "$a0") in
      CompositeLiteral (go.SliceType (go.PointerType reconnectclient.ReconnectingClient)) (LiteralValue [KeyedElement None (ElementExpression (go.PointerType reconnectclient.ReconnectingClient) "$sl0")]))) in
      (FuncResolve go.append [go.SliceType (go.PointerType reconnectclient.ReconnectingClient)] #()) "$a0" "$a1") in
      do:  ("cls" <-[go.SliceType (go.PointerType reconnectclient.ReconnectingClient)] "$r0")));;;
    return: (GoAlloc Clerk (CompositeLiteral Clerk (LiteralValue [KeyedElement (Some (KeyField "cls"%go)) (ElementExpression (go.SliceType (go.PointerType reconnectclient.ReconnectingClient)) (![go.SliceType (go.PointerType reconnectclient.ReconnectingClient)] "cls")); KeyedElement (Some (KeyField "mu"%go)) (ElementExpression (go.PointerType sync.Mutex) (GoAlloc sync.Mutex (GoZeroVal sync.Mutex #())))])))).

(* go: client.go:35:18 *)
Definition Clerk__ReserveEpochAndGetConfigⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "ck" <>,
    exception_do (let: "ck" := (GoAlloc (go.PointerType Clerk) "ck") in
    let: "reply" := (GoAlloc (go.PointerType (go.SliceType go.byte)) (GoZeroVal (go.PointerType (go.SliceType go.byte)) #())) in
    let: "$r0" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    do:  ("reply" <-[go.PointerType (go.SliceType go.byte)] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] (StructFieldRef Clerk "mu"%go (![go.PointerType Clerk] "ck")))) #());;;
      let: "l" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: "$r0" := (![go.uint64] (StructFieldRef Clerk "leader"%go (![go.PointerType Clerk] "ck"))) in
      do:  ("l" <-[go.uint64] "$r0");;;
      do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef Clerk "mu"%go (![go.PointerType Clerk] "ck")))) #());;;
      let: "err" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: "$r0" := (let: "$a0" := RPC_RESERVEEPOCH in
      let: "$a1" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 0)) in
      let: "$a2" := (![go.PointerType (go.SliceType go.byte)] "reply") in
      let: "$a3" := #(W64 100) in
      (MethodResolve (go.PointerType reconnectclient.ReconnectingClient) "Call"%go (![go.PointerType reconnectclient.ReconnectingClient] (IndexRef (go.SliceType (go.PointerType reconnectclient.ReconnectingClient)) (![go.SliceType (go.PointerType reconnectclient.ReconnectingClient)] (StructFieldRef Clerk "cls"%go (![go.PointerType Clerk] "ck")), Convert go.uint64 go.int (![go.uint64] "l"))))) "$a0" "$a1" "$a2" "$a3") in
      do:  ("err" <-[go.uint64] "$r0");;;
      (if: Convert go.untyped_bool go.bool ((![go.uint64] "err") ≠⟨go.uint64⟩ #(W64 0))
      then continue: #()
      else do:  #());;;
      let: "err2" := (GoAlloc err_gk.E (GoZeroVal err_gk.E #())) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] (![go.PointerType (go.SliceType go.byte)] "reply")) in
      (FuncResolve err_gk.Unmarshal [] #()) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("err2" <-[err_gk.E] "$r0");;;
      do:  ((![go.PointerType (go.SliceType go.byte)] "reply") <-[go.SliceType go.byte] "$r1");;;
      (if: Convert go.untyped_bool go.bool ((![err_gk.E] "err2") =⟨go.uint32⟩ err_gk.NotLeader)
      then
        do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] (StructFieldRef Clerk "mu"%go (![go.PointerType Clerk] "ck")))) #());;;
        (if: Convert go.untyped_bool go.bool ((![go.uint64] "l") =⟨go.uint64⟩ (![go.uint64] (StructFieldRef Clerk "leader"%go (![go.PointerType Clerk] "ck"))))
        then
          let: "$r0" := (((![go.uint64] (StructFieldRef Clerk "leader"%go (![go.PointerType Clerk] "ck"))) +⟨go.uint64⟩ #(W64 1)) %⟨go.uint64⟩ (Convert go.int go.uint64 (let: "$a0" := (![go.SliceType (go.PointerType reconnectclient.ReconnectingClient)] (StructFieldRef Clerk "cls"%go (![go.PointerType Clerk] "ck"))) in
          (FuncResolve go.len [go.SliceType (go.PointerType reconnectclient.ReconnectingClient)] #()) "$a0"))) in
          do:  ((StructFieldRef Clerk "leader"%go (![go.PointerType Clerk] "ck")) <-[go.uint64] "$r0")
        else do:  #());;;
        do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef Clerk "mu"%go (![go.PointerType Clerk] "ck")))) #());;;
        continue: #()
      else do:  #());;;
      (if: Convert go.untyped_bool go.bool ((![err_gk.E] "err2") =⟨go.uint32⟩ err_gk.None')
      then break: #()
      else do:  #()));;;
    let: "epoch" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] (![go.PointerType (go.SliceType go.byte)] "reply")) in
    (FuncResolve marshal.ReadInt [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("epoch" <-[go.uint64] "$r0");;;
    do:  ((![go.PointerType (go.SliceType go.byte)] "reply") <-[go.SliceType go.byte] "$r1");;;
    let: "config" := (GoAlloc config_gk.S (GoZeroVal config_gk.S #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] (![go.PointerType (go.SliceType go.byte)] "reply")) in
    (FuncResolve config_gk.Unmarshal [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("config" <-[config_gk.S] "$r0");;;
    do:  "$r1";;;
    return: (![go.uint64] "epoch", ![config_gk.S] "config")).

(* go: client.go:68:18 *)
Definition Clerk__GetConfigⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "ck" <>,
    exception_do (let: "ck" := (GoAlloc (go.PointerType Clerk) "ck") in
    let: "reply" := (GoAlloc (go.PointerType (go.SliceType go.byte)) (GoZeroVal (go.PointerType (go.SliceType go.byte)) #())) in
    let: "$r0" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    do:  ("reply" <-[go.PointerType (go.SliceType go.byte)] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: "$r0" := (((FuncResolve primitive.RandomUint64 [] #()) #()) %⟨go.uint64⟩ (Convert go.int go.uint64 (let: "$a0" := (![go.SliceType (go.PointerType reconnectclient.ReconnectingClient)] (StructFieldRef Clerk "cls"%go (![go.PointerType Clerk] "ck"))) in
      (FuncResolve go.len [go.SliceType (go.PointerType reconnectclient.ReconnectingClient)] #()) "$a0"))) in
      do:  ("i" <-[go.uint64] "$r0");;;
      let: "err" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: "$r0" := (let: "$a0" := RPC_GETCONFIG in
      let: "$a1" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 0)) in
      let: "$a2" := (![go.PointerType (go.SliceType go.byte)] "reply") in
      let: "$a3" := #(W64 100) in
      (MethodResolve (go.PointerType reconnectclient.ReconnectingClient) "Call"%go (![go.PointerType reconnectclient.ReconnectingClient] (IndexRef (go.SliceType (go.PointerType reconnectclient.ReconnectingClient)) (![go.SliceType (go.PointerType reconnectclient.ReconnectingClient)] (StructFieldRef Clerk "cls"%go (![go.PointerType Clerk] "ck")), Convert go.uint64 go.int (![go.uint64] "i"))))) "$a0" "$a1" "$a2" "$a3") in
      do:  ("err" <-[go.uint64] "$r0");;;
      (if: Convert go.untyped_bool go.bool ((![go.uint64] "err") =⟨go.uint64⟩ #(W64 0))
      then break: #()
      else do:  #());;;
      continue: #());;;
    let: "config" := (GoAlloc config_gk.S (GoZeroVal config_gk.S #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] (![go.PointerType (go.SliceType go.byte)] "reply")) in
    (FuncResolve config_gk.Unmarshal [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("config" <-[config_gk.S] "$r0");;;
    do:  "$r1";;;
    return: (![config_gk.S] "config")).

(* go: client.go:82:18 *)
Definition Clerk__TryWriteConfigⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "ck" "epoch" "config",
    exception_do (let: "ck" := (GoAlloc (go.PointerType Clerk) "ck") in
    let: "config" := (GoAlloc config_gk.S "config") in
    let: "epoch" := (GoAlloc go.uint64 "epoch") in
    let: "reply" := (GoAlloc (go.PointerType (go.SliceType go.byte)) (GoZeroVal (go.PointerType (go.SliceType go.byte)) #())) in
    let: "$r0" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    do:  ("reply" <-[go.PointerType (go.SliceType go.byte)] "$r0");;;
    let: "args" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := ((FuncResolve go.make3 [go.SliceType go.byte] #()) #(W64 0) (#(W64 8) +⟨go.int⟩ (#(W64 8) *⟨go.int⟩ (let: "$a0" := (![go.SliceType go.uint64] (StructFieldRef config_gk.S "Addrs"%go "config")) in
    (FuncResolve go.len [go.SliceType go.uint64] #()) "$a0")))) in
    do:  ("args" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "args") in
    let: "$a1" := (![go.uint64] "epoch") in
    (FuncResolve marshal.WriteInt [] #()) "$a0" "$a1") in
    do:  ("args" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "args") in
    let: "$a1" := (![config_gk.S] "config") in
    (FuncResolve config_gk.Marshal [] #()) "$a0" "$a1") in
    do:  ("args" <-[go.SliceType go.byte] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] (StructFieldRef Clerk "mu"%go (![go.PointerType Clerk] "ck")))) #());;;
      let: "l" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: "$r0" := (![go.uint64] (StructFieldRef Clerk "leader"%go (![go.PointerType Clerk] "ck"))) in
      do:  ("l" <-[go.uint64] "$r0");;;
      do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef Clerk "mu"%go (![go.PointerType Clerk] "ck")))) #());;;
      let: "err" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: "$r0" := (let: "$a0" := RPC_TRYWRITECONFIG in
      let: "$a1" := (![go.SliceType go.byte] "args") in
      let: "$a2" := (![go.PointerType (go.SliceType go.byte)] "reply") in
      let: "$a3" := #(W64 2000) in
      (MethodResolve (go.PointerType reconnectclient.ReconnectingClient) "Call"%go (![go.PointerType reconnectclient.ReconnectingClient] (IndexRef (go.SliceType (go.PointerType reconnectclient.ReconnectingClient)) (![go.SliceType (go.PointerType reconnectclient.ReconnectingClient)] (StructFieldRef Clerk "cls"%go (![go.PointerType Clerk] "ck")), Convert go.uint64 go.int (![go.uint64] "l"))))) "$a0" "$a1" "$a2" "$a3") in
      do:  ("err" <-[go.uint64] "$r0");;;
      (if: Convert go.untyped_bool go.bool ((![go.uint64] "err") ≠⟨go.uint64⟩ #(W64 0))
      then continue: #()
      else do:  #());;;
      let: "err2" := (GoAlloc err_gk.E (GoZeroVal err_gk.E #())) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] (![go.PointerType (go.SliceType go.byte)] "reply")) in
      (FuncResolve err_gk.Unmarshal [] #()) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("err2" <-[err_gk.E] "$r0");;;
      do:  "$r1";;;
      (if: Convert go.untyped_bool go.bool ((![err_gk.E] "err2") =⟨go.uint32⟩ err_gk.NotLeader)
      then
        do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] (StructFieldRef Clerk "mu"%go (![go.PointerType Clerk] "ck")))) #());;;
        (if: Convert go.untyped_bool go.bool ((![go.uint64] "l") =⟨go.uint64⟩ (![go.uint64] (StructFieldRef Clerk "leader"%go (![go.PointerType Clerk] "ck"))))
        then
          let: "$r0" := (((![go.uint64] (StructFieldRef Clerk "leader"%go (![go.PointerType Clerk] "ck"))) +⟨go.uint64⟩ #(W64 1)) %⟨go.uint64⟩ (Convert go.int go.uint64 (let: "$a0" := (![go.SliceType (go.PointerType reconnectclient.ReconnectingClient)] (StructFieldRef Clerk "cls"%go (![go.PointerType Clerk] "ck"))) in
          (FuncResolve go.len [go.SliceType (go.PointerType reconnectclient.ReconnectingClient)] #()) "$a0"))) in
          do:  ((StructFieldRef Clerk "leader"%go (![go.PointerType Clerk] "ck")) <-[go.uint64] "$r0")
        else do:  #());;;
        do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef Clerk "mu"%go (![go.PointerType Clerk] "ck")))) #());;;
        continue: #()
      else break: #()));;;
    let: "err" := (GoAlloc err_gk.E (GoZeroVal err_gk.E #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] (![go.PointerType (go.SliceType go.byte)] "reply")) in
    (FuncResolve err_gk.Unmarshal [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("err" <-[err_gk.E] "$r0");;;
    do:  "$r1";;;
    return: (![err_gk.E] "err")).

(* returns e.None if the lease was granted for the given epoch, and a conservative
   guess on when the lease expires.

   go: client.go:118:18 *)
Definition Clerk__GetLeaseⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "ck" "epoch",
    exception_do (let: "ck" := (GoAlloc (go.PointerType Clerk) "ck") in
    let: "epoch" := (GoAlloc go.uint64 "epoch") in
    let: "reply" := (GoAlloc (go.PointerType (go.SliceType go.byte)) (GoZeroVal (go.PointerType (go.SliceType go.byte)) #())) in
    let: "$r0" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    do:  ("reply" <-[go.PointerType (go.SliceType go.byte)] "$r0");;;
    let: "args" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := ((FuncResolve go.make3 [go.SliceType go.byte] #()) #(W64 0) #(W64 8)) in
    do:  ("args" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "args") in
    let: "$a1" := (![go.uint64] "epoch") in
    (FuncResolve marshal.WriteInt [] #()) "$a0" "$a1") in
    do:  ("args" <-[go.SliceType go.byte] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] (StructFieldRef Clerk "mu"%go (![go.PointerType Clerk] "ck")))) #());;;
      let: "l" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: "$r0" := (![go.uint64] (StructFieldRef Clerk "leader"%go (![go.PointerType Clerk] "ck"))) in
      do:  ("l" <-[go.uint64] "$r0");;;
      do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef Clerk "mu"%go (![go.PointerType Clerk] "ck")))) #());;;
      let: "err" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: "$r0" := (let: "$a0" := RPC_GETLEASE in
      let: "$a1" := (![go.SliceType go.byte] "args") in
      let: "$a2" := (![go.PointerType (go.SliceType go.byte)] "reply") in
      let: "$a3" := #(W64 100) in
      (MethodResolve (go.PointerType reconnectclient.ReconnectingClient) "Call"%go (![go.PointerType reconnectclient.ReconnectingClient] (IndexRef (go.SliceType (go.PointerType reconnectclient.ReconnectingClient)) (![go.SliceType (go.PointerType reconnectclient.ReconnectingClient)] (StructFieldRef Clerk "cls"%go (![go.PointerType Clerk] "ck")), Convert go.uint64 go.int (![go.uint64] "l"))))) "$a0" "$a1" "$a2" "$a3") in
      do:  ("err" <-[go.uint64] "$r0");;;
      (if: Convert go.untyped_bool go.bool ((![go.uint64] "err") ≠⟨go.uint64⟩ #(W64 0))
      then continue: #()
      else do:  #());;;
      let: "err2" := (GoAlloc err_gk.E (GoZeroVal err_gk.E #())) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] (![go.PointerType (go.SliceType go.byte)] "reply")) in
      (FuncResolve err_gk.Unmarshal [] #()) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("err2" <-[err_gk.E] "$r0");;;
      do:  "$r1";;;
      (if: Convert go.untyped_bool go.bool ((![err_gk.E] "err2") =⟨go.uint32⟩ err_gk.NotLeader)
      then
        do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] (StructFieldRef Clerk "mu"%go (![go.PointerType Clerk] "ck")))) #());;;
        (if: Convert go.untyped_bool go.bool ((![go.uint64] "l") =⟨go.uint64⟩ (![go.uint64] (StructFieldRef Clerk "leader"%go (![go.PointerType Clerk] "ck"))))
        then
          let: "$r0" := (((![go.uint64] (StructFieldRef Clerk "leader"%go (![go.PointerType Clerk] "ck"))) +⟨go.uint64⟩ #(W64 1)) %⟨go.uint64⟩ (Convert go.int go.uint64 (let: "$a0" := (![go.SliceType (go.PointerType reconnectclient.ReconnectingClient)] (StructFieldRef Clerk "cls"%go (![go.PointerType Clerk] "ck"))) in
          (FuncResolve go.len [go.SliceType (go.PointerType reconnectclient.ReconnectingClient)] #()) "$a0"))) in
          do:  ((StructFieldRef Clerk "leader"%go (![go.PointerType Clerk] "ck")) <-[go.uint64] "$r0")
        else do:  #());;;
        do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef Clerk "mu"%go (![go.PointerType Clerk] "ck")))) #());;;
        continue: #()
      else break: #()));;;
    let: "enc" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "err2" := (GoAlloc err_gk.E (GoZeroVal err_gk.E #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] (![go.PointerType (go.SliceType go.byte)] "reply")) in
    (FuncResolve err_gk.Unmarshal [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("err2" <-[err_gk.E] "$r0");;;
    do:  ("enc" <-[go.SliceType go.byte] "$r1");;;
    let: "leaseExpiration" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] "enc") in
    (FuncResolve marshal.ReadInt [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("leaseExpiration" <-[go.uint64] "$r0");;;
    do:  "$r1";;;
    return: (![err_gk.E] "err2", ![go.uint64] "leaseExpiration")).

(* go: server.go:26:6 *)
Definition encodeStateⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "st",
    exception_do (let: "st" := (GoAlloc (go.PointerType state) "st") in
    let: "e" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (let: "$a0" := (Convert go.untyped_nil (go.SliceType go.byte) UntypedNil) in
    let: "$a1" := (![go.uint64] (StructFieldRef state "epoch"%go (![go.PointerType state] "st"))) in
    (FuncResolve marshal.WriteInt [] #()) "$a0" "$a1") in
    do:  ("e" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "e") in
    let: "$a1" := (![go.uint64] (StructFieldRef state "reservedEpoch"%go (![go.PointerType state] "st"))) in
    (FuncResolve marshal.WriteInt [] #()) "$a0" "$a1") in
    do:  ("e" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "e") in
    let: "$a1" := (![go.uint64] (StructFieldRef state "leaseExpiration"%go (![go.PointerType state] "st"))) in
    (FuncResolve marshal.WriteInt [] #()) "$a0" "$a1") in
    do:  ("e" <-[go.SliceType go.byte] "$r0");;;
    (if: ![go.bool] (StructFieldRef state "wantLeaseToExpire"%go (![go.PointerType state] "st"))
    then
      let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "e") in
      let: "$a1" := #(W64 1) in
      (FuncResolve marshal.WriteInt [] #()) "$a0" "$a1") in
      do:  ("e" <-[go.SliceType go.byte] "$r0")
    else
      let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "e") in
      let: "$a1" := #(W64 0) in
      (FuncResolve marshal.WriteInt [] #()) "$a0" "$a1") in
      do:  ("e" <-[go.SliceType go.byte] "$r0"));;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "e") in
    let: "$a1" := (![config_gk.S] (StructFieldRef state "config"%go (![go.PointerType state] "st"))) in
    (FuncResolve config_gk.Marshal [] #()) "$a0" "$a1") in
    do:  ("e" <-[go.SliceType go.byte] "$r0");;;
    return: (![go.SliceType go.byte] "e")).

(* go: server.go:40:6 *)
Definition decodeStateⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "e",
    exception_do (let: "e" := (GoAlloc (go.SliceType go.byte) "e") in
    let: "st" := (GoAlloc (go.PointerType state) (GoZeroVal (go.PointerType state) #())) in
    let: "$r0" := (GoAlloc state (GoZeroVal state #())) in
    do:  ("st" <-[go.PointerType state] "$r0");;;
    let: "e2" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (![go.SliceType go.byte] "e") in
    do:  ("e2" <-[go.SliceType go.byte] "$r0");;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] "e2") in
    (FuncResolve marshal.ReadInt [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ((StructFieldRef state "epoch"%go (![go.PointerType state] "st")) <-[go.uint64] "$r0");;;
    do:  ("e2" <-[go.SliceType go.byte] "$r1");;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] "e2") in
    (FuncResolve marshal.ReadInt [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ((StructFieldRef state "reservedEpoch"%go (![go.PointerType state] "st")) <-[go.uint64] "$r0");;;
    do:  ("e2" <-[go.SliceType go.byte] "$r1");;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] "e2") in
    (FuncResolve marshal.ReadInt [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ((StructFieldRef state "leaseExpiration"%go (![go.PointerType state] "st")) <-[go.uint64] "$r0");;;
    do:  ("e2" <-[go.SliceType go.byte] "$r1");;;
    let: "wantExp" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] "e2") in
    (FuncResolve marshal.ReadInt [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("wantExp" <-[go.uint64] "$r0");;;
    do:  ("e2" <-[go.SliceType go.byte] "$r1");;;
    let: "$r0" := ((![go.uint64] "wantExp") =⟨go.uint64⟩ #(W64 1)) in
    do:  ((StructFieldRef state "wantLeaseToExpire"%go (![go.PointerType state] "st")) <-[go.bool] "$r0");;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] "e2") in
    (FuncResolve config_gk.Unmarshal [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ((StructFieldRef state "config"%go (![go.PointerType state] "st")) <-[config_gk.S] "$r0");;;
    do:  "$r1";;;
    return: (![go.PointerType state] "st")).

(* go: server.go:57:18 *)
Definition Server__tryAcquireⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" <>,
    exception_do (let: "s" := (GoAlloc (go.PointerType Server) "s") in
    let: "relF" := (GoAlloc (go.FunctionType (go.Signature [] false [error_gk.E])) (GoZeroVal (go.FunctionType (go.Signature [] false [error_gk.E])) #())) in
    let: "e" := (GoAlloc (go.PointerType (go.SliceType go.byte)) (GoZeroVal (go.PointerType (go.SliceType go.byte)) #())) in
    let: "err" := (GoAlloc error_gk.E (GoZeroVal error_gk.E #())) in
    let: (("$ret0", "$ret1"), "$ret2") := ((MethodResolve (go.PointerType paxos.Server) "TryAcquire"%go (![go.PointerType paxos.Server] (StructFieldRef Server "s"%go (![go.PointerType Server] "s")))) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("err" <-[error_gk.E] "$r0");;;
    do:  ("e" <-[go.PointerType (go.SliceType go.byte)] "$r1");;;
    do:  ("relF" <-[go.FunctionType (go.Signature [] false [error_gk.E])] "$r2");;;
    (if: Convert go.untyped_bool go.bool ((![error_gk.E] "err") ≠⟨go.uint32⟩ #(W32 0))
    then
      let: "p" := (GoAlloc (go.PointerType state) (GoZeroVal (go.PointerType state) #())) in
      return: (#false, ![go.PointerType state] "p", Convert go.untyped_nil (go.FunctionType (go.Signature [] false [go.bool])) UntypedNil)
    else do:  #());;;
    let: "st" := (GoAlloc (go.PointerType state) (GoZeroVal (go.PointerType state) #())) in
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] (![go.PointerType (go.SliceType go.byte)] "e")) in
    (FuncResolve decodeState [] #()) "$a0") in
    do:  ("st" <-[go.PointerType state] "$r0");;;
    let: "releaseFn" := (GoAlloc (go.FunctionType (go.Signature [] false [go.bool])) (GoZeroVal (go.FunctionType (go.Signature [] false [go.bool])) #())) in
    let: "$r0" := (λ: <>,
      exception_do (let: "$r0" := (let: "$a0" := (![go.PointerType state] "st") in
      (FuncResolve encodeState [] #()) "$a0") in
      do:  ((![go.PointerType (go.SliceType go.byte)] "e") <-[go.SliceType go.byte] "$r0");;;
      return: (((![go.FunctionType (go.Signature [] false [error_gk.E])] "relF") #()) =⟨go.uint32⟩ #(W32 0)))
      ) in
    do:  ("releaseFn" <-[go.FunctionType (go.Signature [] false [go.bool])] "$r0");;;
    return: (#true, ![go.PointerType state] "st", ![go.FunctionType (go.Signature [] false [go.bool])] "releaseFn")).

(* go: server.go:71:18 *)
Definition Server__ReserveEpochAndGetConfigⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" "args" "reply",
    exception_do (let: "s" := (GoAlloc (go.PointerType Server) "s") in
    let: "reply" := (GoAlloc (go.PointerType (go.SliceType go.byte)) "reply") in
    let: "args" := (GoAlloc (go.SliceType go.byte) "args") in
    let: "$r0" := (let: "$a0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 0)) in
    let: "$a1" := err_gk.NotLeader in
    (FuncResolve err_gk.Marshal [] #()) "$a0" "$a1") in
    do:  ((![go.PointerType (go.SliceType go.byte)] "reply") <-[go.SliceType go.byte] "$r0");;;
    let: "tryReleaseFn" := (GoAlloc (go.FunctionType (go.Signature [] false [go.bool])) (GoZeroVal (go.FunctionType (go.Signature [] false [go.bool])) #())) in
    let: "st" := (GoAlloc (go.PointerType state) (GoZeroVal (go.PointerType state) #())) in
    let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: (("$ret0", "$ret1"), "$ret2") := ((MethodResolve (go.PointerType Server) "tryAcquire"%go (![go.PointerType Server] "s")) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("ok" <-[go.bool] "$r0");;;
    do:  ("st" <-[go.PointerType state] "$r1");;;
    do:  ("tryReleaseFn" <-[go.FunctionType (go.Signature [] false [go.bool])] "$r2");;;
    (if: (⟨go.bool⟩! (![go.bool] "ok"))
    then return: (#())
    else do:  #());;;
    let: "$r0" := (let: "$a0" := (![go.uint64] (StructFieldRef state "reservedEpoch"%go (![go.PointerType state] "st"))) in
    let: "$a1" := #(W64 1) in
    (FuncResolve std.SumAssumeNoOverflow [] #()) "$a0" "$a1") in
    do:  ((StructFieldRef state "reservedEpoch"%go (![go.PointerType state] "st")) <-[go.uint64] "$r0");;;
    let: "config" := (GoAlloc config_gk.S (GoZeroVal config_gk.S #())) in
    let: "$r0" := (![config_gk.S] (StructFieldRef state "config"%go (![go.PointerType state] "st"))) in
    do:  ("config" <-[config_gk.S] "$r0");;;
    let: "reservedEpoch" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (![go.uint64] (StructFieldRef state "reservedEpoch"%go (![go.PointerType state] "st"))) in
    do:  ("reservedEpoch" <-[go.uint64] "$r0");;;
    (if: (⟨go.bool⟩! ((![go.FunctionType (go.Signature [] false [go.bool])] "tryReleaseFn") #()))
    then return: (#())
    else do:  #());;;
    let: "$r0" := ((FuncResolve go.make3 [go.SliceType go.byte] #()) #(W64 0) (#(W64 16) +⟨go.int⟩ (#(W64 8) *⟨go.int⟩ (let: "$a0" := (![go.SliceType go.uint64] (StructFieldRef config_gk.S "Addrs"%go "config")) in
    (FuncResolve go.len [go.SliceType go.uint64] #()) "$a0")))) in
    do:  ((![go.PointerType (go.SliceType go.byte)] "reply") <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] (![go.PointerType (go.SliceType go.byte)] "reply")) in
    let: "$a1" := err_gk.None' in
    (FuncResolve err_gk.Marshal [] #()) "$a0" "$a1") in
    do:  ((![go.PointerType (go.SliceType go.byte)] "reply") <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] (![go.PointerType (go.SliceType go.byte)] "reply")) in
    let: "$a1" := (![go.uint64] "reservedEpoch") in
    (FuncResolve marshal.WriteInt [] #()) "$a0" "$a1") in
    do:  ((![go.PointerType (go.SliceType go.byte)] "reply") <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] (![go.PointerType (go.SliceType go.byte)] "reply")) in
    let: "$a1" := (![config_gk.S] "config") in
    (FuncResolve config_gk.Marshal [] #()) "$a0" "$a1") in
    do:  ((![go.PointerType (go.SliceType go.byte)] "reply") <-[go.SliceType go.byte] "$r0");;;
    return: #()).

(* go: server.go:89:18 *)
Definition Server__GetConfigⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" "args" "reply",
    exception_do (let: "s" := (GoAlloc (go.PointerType Server) "s") in
    let: "reply" := (GoAlloc (go.PointerType (go.SliceType go.byte)) "reply") in
    let: "args" := (GoAlloc (go.SliceType go.byte) "args") in
    let: "st" := (GoAlloc (go.PointerType state) (GoZeroVal (go.PointerType state) #())) in
    let: "$r0" := (let: "$a0" := ((MethodResolve (go.PointerType paxos.Server) "WeakRead"%go (![go.PointerType paxos.Server] (StructFieldRef Server "s"%go (![go.PointerType Server] "s")))) #()) in
    (FuncResolve decodeState [] #()) "$a0") in
    do:  ("st" <-[go.PointerType state] "$r0");;;
    let: "$r0" := (let: "$a0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 0)) in
    let: "$a1" := (![config_gk.S] (StructFieldRef state "config"%go (![go.PointerType state] "st"))) in
    (FuncResolve config_gk.Marshal [] #()) "$a0" "$a1") in
    do:  ((![go.PointerType (go.SliceType go.byte)] "reply") <-[go.SliceType go.byte] "$r0");;;
    return: #()).

(* go: server.go:94:18 *)
Definition Server__TryWriteConfigⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" "args" "reply",
    exception_do (let: "s" := (GoAlloc (go.PointerType Server) "s") in
    let: "reply" := (GoAlloc (go.PointerType (go.SliceType go.byte)) "reply") in
    let: "args" := (GoAlloc (go.SliceType go.byte) "args") in
    let: "$r0" := (let: "$a0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 0)) in
    let: "$a1" := err_gk.NotLeader in
    (FuncResolve err_gk.Marshal [] #()) "$a0" "$a1") in
    do:  ((![go.PointerType (go.SliceType go.byte)] "reply") <-[go.SliceType go.byte] "$r0");;;
    let: "enc" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "epoch" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] "args") in
    (FuncResolve marshal.ReadInt [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("epoch" <-[go.uint64] "$r0");;;
    do:  ("enc" <-[go.SliceType go.byte] "$r1");;;
    let: "config" := (GoAlloc config_gk.S (GoZeroVal config_gk.S #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] "enc") in
    (FuncResolve config_gk.Unmarshal [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("config" <-[config_gk.S] "$r0");;;
    do:  "$r1";;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "tryReleaseFn" := (GoAlloc (go.FunctionType (go.Signature [] false [go.bool])) (GoZeroVal (go.FunctionType (go.Signature [] false [go.bool])) #())) in
      let: "st" := (GoAlloc (go.PointerType state) (GoZeroVal (go.PointerType state) #())) in
      let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
      let: (("$ret0", "$ret1"), "$ret2") := ((MethodResolve (go.PointerType Server) "tryAcquire"%go (![go.PointerType Server] "s")) #()) in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      let: "$r2" := "$ret2" in
      do:  ("ok" <-[go.bool] "$r0");;;
      do:  ("st" <-[go.PointerType state] "$r1");;;
      do:  ("tryReleaseFn" <-[go.FunctionType (go.Signature [] false [go.bool])] "$r2");;;
      (if: (⟨go.bool⟩! (![go.bool] "ok"))
      then break: #()
      else do:  #());;;
      (if: Convert go.untyped_bool go.bool ((![go.uint64] "epoch") <⟨go.uint64⟩ (![go.uint64] (StructFieldRef state "reservedEpoch"%go (![go.PointerType state] "st"))))
      then
        (if: (⟨go.bool⟩! ((![go.FunctionType (go.Signature [] false [go.bool])] "tryReleaseFn") #()))
        then break: #()
        else do:  #());;;
        let: "$r0" := (let: "$a0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 0)) in
        let: "$a1" := err_gk.Stale in
        (FuncResolve err_gk.Marshal [] #()) "$a0" "$a1") in
        do:  ((![go.PointerType (go.SliceType go.byte)] "reply") <-[go.SliceType go.byte] "$r0");;;
        do:  (let: "$a0" := #"Stale: %d < %d"%go in
        let: "$a1" := ((let: "$sl0" := (Convert go.uint64 go.any (![go.uint64] "epoch")) in
        let: "$sl1" := (Convert go.uint64 go.any (![go.uint64] (StructFieldRef state "reservedEpoch"%go (![go.PointerType state] "st")))) in
        CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0"); KeyedElement None (ElementExpression go.any "$sl1")]))) in
        (FuncResolve log.Printf [] #()) "$a0" "$a1");;;
        break: #()
      else
        (if: Convert go.untyped_bool go.bool ((![go.uint64] "epoch") >⟨go.uint64⟩ (![go.uint64] (StructFieldRef state "epoch"%go (![go.PointerType state] "st"))))
        then
          let: "l" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
          let: ("$ret0", "$ret1") := ((FuncResolve grove_ffi.GetTimeRange [] #()) #()) in
          let: "$r0" := "$ret0" in
          let: "$r1" := "$ret1" in
          do:  ("l" <-[go.uint64] "$r0");;;
          do:  "$r1";;;
          (if: Convert go.untyped_bool go.bool ((![go.uint64] "l") ≥⟨go.uint64⟩ (![go.uint64] (StructFieldRef state "leaseExpiration"%go (![go.PointerType state] "st"))))
          then
            let: "$r0" := #false in
            do:  ((StructFieldRef state "wantLeaseToExpire"%go (![go.PointerType state] "st")) <-[go.bool] "$r0");;;
            let: "$r0" := (![go.uint64] "epoch") in
            do:  ((StructFieldRef state "epoch"%go (![go.PointerType state] "st")) <-[go.uint64] "$r0");;;
            let: "$r0" := (![config_gk.S] "config") in
            do:  ((StructFieldRef state "config"%go (![go.PointerType state] "st")) <-[config_gk.S] "$r0");;;
            (if: (⟨go.bool⟩! ((![go.FunctionType (go.Signature [] false [go.bool])] "tryReleaseFn") #()))
            then break: #()
            else do:  #());;;
            do:  (let: "$a0" := ((let: "$sl0" := (Convert go.string go.any #"New config is:"%go) in
            let: "$sl1" := (Convert config_gk.S go.any (![config_gk.S] (StructFieldRef state "config"%go (![go.PointerType state] "st")))) in
            CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0"); KeyedElement None (ElementExpression go.any "$sl1")]))) in
            (FuncResolve log.Println [] #()) "$a0");;;
            let: "$r0" := (let: "$a0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 0)) in
            let: "$a1" := err_gk.None' in
            (FuncResolve err_gk.Marshal [] #()) "$a0" "$a1") in
            do:  ((![go.PointerType (go.SliceType go.byte)] "reply") <-[go.SliceType go.byte] "$r0");;;
            break: #()
          else
            let: "$r0" := #true in
            do:  ((StructFieldRef state "wantLeaseToExpire"%go (![go.PointerType state] "st")) <-[go.bool] "$r0");;;
            let: "timeToSleep" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
            let: "$r0" := ((![go.uint64] (StructFieldRef state "leaseExpiration"%go (![go.PointerType state] "st"))) -⟨go.uint64⟩ (![go.uint64] "l")) in
            do:  ("timeToSleep" <-[go.uint64] "$r0");;;
            (if: (⟨go.bool⟩! ((![go.FunctionType (go.Signature [] false [go.bool])] "tryReleaseFn") #()))
            then break: #()
            else do:  #());;;
            do:  (let: "$a0" := (![go.uint64] "timeToSleep") in
            (FuncResolve primitive.Sleep [] #()) "$a0");;;
            continue: #())
        else
          let: "$r0" := (![config_gk.S] "config") in
          do:  ((StructFieldRef state "config"%go (![go.PointerType state] "st")) <-[config_gk.S] "$r0");;;
          (if: (⟨go.bool⟩! ((![go.FunctionType (go.Signature [] false [go.bool])] "tryReleaseFn") #()))
          then break: #()
          else do:  #());;;
          let: "$r0" := (let: "$a0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 0)) in
          let: "$a1" := err_gk.None' in
          (FuncResolve err_gk.Marshal [] #()) "$a0" "$a1") in
          do:  ((![go.PointerType (go.SliceType go.byte)] "reply") <-[go.SliceType go.byte] "$r0");;;
          break: #())));;;
    return: #()).

(* go: server.go:146:18 *)
Definition Server__GetLeaseⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" "args" "reply",
    exception_do (let: "s" := (GoAlloc (go.PointerType Server) "s") in
    let: "reply" := (GoAlloc (go.PointerType (go.SliceType go.byte)) "reply") in
    let: "args" := (GoAlloc (go.SliceType go.byte) "args") in
    let: "$r0" := (let: "$a0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 0)) in
    let: "$a1" := err_gk.NotLeader in
    (FuncResolve err_gk.Marshal [] #()) "$a0" "$a1") in
    do:  ((![go.PointerType (go.SliceType go.byte)] "reply") <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] (![go.PointerType (go.SliceType go.byte)] "reply")) in
    let: "$a1" := #(W64 0) in
    (FuncResolve marshal.WriteInt [] #()) "$a0" "$a1") in
    do:  ((![go.PointerType (go.SliceType go.byte)] "reply") <-[go.SliceType go.byte] "$r0");;;
    let: "epoch" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] "args") in
    (FuncResolve marshal.ReadInt [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("epoch" <-[go.uint64] "$r0");;;
    do:  "$r1";;;
    let: "tryReleaseFn" := (GoAlloc (go.FunctionType (go.Signature [] false [go.bool])) (GoZeroVal (go.FunctionType (go.Signature [] false [go.bool])) #())) in
    let: "st" := (GoAlloc (go.PointerType state) (GoZeroVal (go.PointerType state) #())) in
    let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: (("$ret0", "$ret1"), "$ret2") := ((MethodResolve (go.PointerType Server) "tryAcquire"%go (![go.PointerType Server] "s")) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("ok" <-[go.bool] "$r0");;;
    do:  ("st" <-[go.PointerType state] "$r1");;;
    do:  ("tryReleaseFn" <-[go.FunctionType (go.Signature [] false [go.bool])] "$r2");;;
    (if: (⟨go.bool⟩! (![go.bool] "ok"))
    then return: (#())
    else do:  #());;;
    (if: ((![go.uint64] (StructFieldRef state "epoch"%go (![go.PointerType state] "st"))) ≠⟨go.uint64⟩ (![go.uint64] "epoch")) || (![go.bool] (StructFieldRef state "wantLeaseToExpire"%go (![go.PointerType state] "st")))
    then
      do:  (let: "$a0" := ((let: "$sl0" := (Convert go.string go.any #"Rejected lease request"%go) in
      let: "$sl1" := (Convert go.uint64 go.any (![go.uint64] "epoch")) in
      let: "$sl2" := (Convert go.uint64 go.any (![go.uint64] (StructFieldRef state "epoch"%go (![go.PointerType state] "st")))) in
      let: "$sl3" := (Convert go.bool go.any (![go.bool] (StructFieldRef state "wantLeaseToExpire"%go (![go.PointerType state] "st")))) in
      CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0"); KeyedElement None (ElementExpression go.any "$sl1"); KeyedElement None (ElementExpression go.any "$sl2"); KeyedElement None (ElementExpression go.any "$sl3")]))) in
      (FuncResolve log.Println [] #()) "$a0");;;
      (if: (⟨go.bool⟩! ((![go.FunctionType (go.Signature [] false [go.bool])] "tryReleaseFn") #()))
      then return: (#())
      else do:  #());;;
      let: "$r0" := (let: "$a0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 0)) in
      let: "$a1" := err_gk.Stale in
      (FuncResolve err_gk.Marshal [] #()) "$a0" "$a1") in
      do:  ((![go.PointerType (go.SliceType go.byte)] "reply") <-[go.SliceType go.byte] "$r0");;;
      let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] (![go.PointerType (go.SliceType go.byte)] "reply")) in
      let: "$a1" := #(W64 0) in
      (FuncResolve marshal.WriteInt [] #()) "$a0" "$a1") in
      do:  ((![go.PointerType (go.SliceType go.byte)] "reply") <-[go.SliceType go.byte] "$r0");;;
      return: (#())
    else do:  #());;;
    let: "l" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: ("$ret0", "$ret1") := ((FuncResolve grove_ffi.GetTimeRange [] #()) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("l" <-[go.uint64] "$r0");;;
    do:  "$r1";;;
    let: "newLeaseExpiration" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := ((![go.uint64] "l") +⟨go.uint64⟩ LeaseInterval) in
    do:  ("newLeaseExpiration" <-[go.uint64] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "newLeaseExpiration") >⟨go.uint64⟩ (![go.uint64] (StructFieldRef state "leaseExpiration"%go (![go.PointerType state] "st"))))
    then
      let: "$r0" := (![go.uint64] "newLeaseExpiration") in
      do:  ((StructFieldRef state "leaseExpiration"%go (![go.PointerType state] "st")) <-[go.uint64] "$r0")
    else do:  #());;;
    (if: (⟨go.bool⟩! ((![go.FunctionType (go.Signature [] false [go.bool])] "tryReleaseFn") #()))
    then return: (#())
    else do:  #());;;
    let: "$r0" := (let: "$a0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 0)) in
    let: "$a1" := err_gk.None' in
    (FuncResolve err_gk.Marshal [] #()) "$a0" "$a1") in
    do:  ((![go.PointerType (go.SliceType go.byte)] "reply") <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] (![go.PointerType (go.SliceType go.byte)] "reply")) in
    let: "$a1" := (![go.uint64] "newLeaseExpiration") in
    (FuncResolve marshal.WriteInt [] #()) "$a0" "$a1") in
    do:  ((![go.PointerType (go.SliceType go.byte)] "reply") <-[go.SliceType go.byte] "$r0");;;
    return: #()).

(* go: server.go:178:6 *)
Definition makeServerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "fname" "paxosMe" "hosts" "initconfig",
    exception_do (let: "initconfig" := (GoAlloc (go.SliceType grove_ffi.Address) "initconfig") in
    let: "hosts" := (GoAlloc (go.SliceType grove_ffi.Address) "hosts") in
    let: "paxosMe" := (GoAlloc grove_ffi.Address "paxosMe") in
    let: "fname" := (GoAlloc go.string "fname") in
    let: "s" := (GoAlloc (go.PointerType Server) (GoZeroVal (go.PointerType Server) #())) in
    let: "$r0" := (GoAlloc Server (GoZeroVal Server #())) in
    do:  ("s" <-[go.PointerType Server] "$r0");;;
    let: "initEnc" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (let: "$a0" := (GoAlloc state (CompositeLiteral state (LiteralValue [KeyedElement (Some (KeyField "config"%go)) (ElementExpression config_gk.S (CompositeLiteral config_gk.S (LiteralValue [KeyedElement (Some (KeyField "Addrs"%go)) (ElementExpression (go.SliceType grove_ffi.Address) (![go.SliceType grove_ffi.Address] "initconfig"))])))]))) in
    (FuncResolve encodeState [] #()) "$a0") in
    do:  ("initEnc" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.string] "fname") in
    let: "$a1" := (![go.SliceType go.byte] "initEnc") in
    let: "$a2" := (![grove_ffi.Address] "paxosMe") in
    let: "$a3" := (![go.SliceType grove_ffi.Address] "hosts") in
    (FuncResolve paxos.StartServer [] #()) "$a0" "$a1" "$a2" "$a3") in
    do:  ((StructFieldRef Server "s"%go (![go.PointerType Server] "s")) <-[go.PointerType paxos.Server] "$r0");;;
    return: (![go.PointerType Server] "s")).

(* go: server.go:188:6 *)
Definition StartServerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "fname" "me" "paxosMe" "hosts" "initconfig",
    exception_do (let: "initconfig" := (GoAlloc (go.SliceType grove_ffi.Address) "initconfig") in
    let: "hosts" := (GoAlloc (go.SliceType grove_ffi.Address) "hosts") in
    let: "paxosMe" := (GoAlloc grove_ffi.Address "paxosMe") in
    let: "me" := (GoAlloc grove_ffi.Address "me") in
    let: "fname" := (GoAlloc go.string "fname") in
    let: "s" := (GoAlloc (go.PointerType Server) (GoZeroVal (go.PointerType Server) #())) in
    let: "$r0" := (let: "$a0" := (![go.string] "fname") in
    let: "$a1" := (![grove_ffi.Address] "paxosMe") in
    let: "$a2" := (![go.SliceType grove_ffi.Address] "hosts") in
    let: "$a3" := (![go.SliceType grove_ffi.Address] "initconfig") in
    (FuncResolve makeServer [] #()) "$a0" "$a1" "$a2" "$a3") in
    do:  ("s" <-[go.PointerType Server] "$r0");;;
    let: "handlers" := (GoAlloc (go.MapType go.uint64 (go.FunctionType (go.Signature [go.SliceType go.byte; go.PointerType (go.SliceType go.byte)] false []))) (GoZeroVal (go.MapType go.uint64 (go.FunctionType (go.Signature [go.SliceType go.byte; go.PointerType (go.SliceType go.byte)] false []))) #())) in
    let: "$r0" := ((FuncResolve go.make1 [go.MapType go.uint64 (go.FunctionType (go.Signature [go.SliceType go.byte; go.PointerType (go.SliceType go.byte)] false []))] #()) #()) in
    do:  ("handlers" <-[go.MapType go.uint64 (go.FunctionType (go.Signature [go.SliceType go.byte; go.PointerType (go.SliceType go.byte)] false []))] "$r0");;;
    let: "$r0" := (MethodResolve (go.PointerType Server) "ReserveEpochAndGetConfig"%go (![go.PointerType Server] "s")) in
    do:  (map.insert go.uint64 (![go.MapType go.uint64 (go.FunctionType (go.Signature [go.SliceType go.byte; go.PointerType (go.SliceType go.byte)] false []))] "handlers") RPC_RESERVEEPOCH "$r0");;;
    let: "$r0" := (MethodResolve (go.PointerType Server) "GetConfig"%go (![go.PointerType Server] "s")) in
    do:  (map.insert go.uint64 (![go.MapType go.uint64 (go.FunctionType (go.Signature [go.SliceType go.byte; go.PointerType (go.SliceType go.byte)] false []))] "handlers") RPC_GETCONFIG "$r0");;;
    let: "$r0" := (MethodResolve (go.PointerType Server) "TryWriteConfig"%go (![go.PointerType Server] "s")) in
    do:  (map.insert go.uint64 (![go.MapType go.uint64 (go.FunctionType (go.Signature [go.SliceType go.byte; go.PointerType (go.SliceType go.byte)] false []))] "handlers") RPC_TRYWRITECONFIG "$r0");;;
    let: "$r0" := (MethodResolve (go.PointerType Server) "GetLease"%go (![go.PointerType Server] "s")) in
    do:  (map.insert go.uint64 (![go.MapType go.uint64 (go.FunctionType (go.Signature [go.SliceType go.byte; go.PointerType (go.SliceType go.byte)] false []))] "handlers") RPC_GETLEASE "$r0");;;
    let: "rs" := (GoAlloc (go.PointerType urpc.Server) (GoZeroVal (go.PointerType urpc.Server) #())) in
    let: "$r0" := (let: "$a0" := (![go.MapType go.uint64 (go.FunctionType (go.Signature [go.SliceType go.byte; go.PointerType (go.SliceType go.byte)] false []))] "handlers") in
    (FuncResolve urpc.MakeServer [] #()) "$a0") in
    do:  ("rs" <-[go.PointerType urpc.Server] "$r0");;;
    do:  (let: "$a0" := (![grove_ffi.Address] "me") in
    (MethodResolve (go.PointerType urpc.Server) "Serve"%go (![go.PointerType urpc.Server] "rs")) "$a0");;;
    return: (![go.PointerType Server] "s")).

#[global] Instance info' : PkgInfo pkg_id.configservice :=
{|
  pkg_imported_pkgs := [code.sync.pkg_id.sync; code.github_com.goose_lang.primitive.pkg_id.primitive; code.github_com.mit_pdos.gokv.grove_ffi.pkg_id.grove_ffi; code.github_com.mit_pdos.gokv.reconnectclient.pkg_id.reconnectclient; code.github_com.mit_pdos.gokv.vrsm.configservice.config_gk.pkg_id.config_gk; code.github_com.mit_pdos.gokv.vrsm.replica.err_gk.pkg_id.err_gk; code.github_com.tchajed.marshal.pkg_id.marshal; code.log.pkg_id.log; code.github_com.goose_lang.std.pkg_id.std; code.github_com.mit_pdos.gokv.urpc.pkg_id.urpc; code.github_com.mit_pdos.gokv.vrsm.paxos.pkg_id.paxos]
|}.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init pkg_id.configservice (λ: <>,
      exception_do (do:  (paxos.initialize' #());;;
      do:  (urpc.initialize' #());;;
      do:  (std.initialize' #());;;
      do:  (log.initialize' #());;;
      do:  (marshal.initialize' #());;;
      do:  (err_gk.initialize' #());;;
      do:  (config_gk.initialize' #());;;
      do:  (reconnectclient.initialize' #());;;
      do:  (grove_ffi.initialize' #());;;
      do:  (primitive.initialize' #());;;
      do:  (sync.initialize' #()))
      ).

Module Clerk.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  mu' : loc;
  cls' : slice.t;
  leader' : w64;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End Clerk.

Definition Clerk'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "mu"%go (go.PointerType sync.Mutex));
  (go.FieldDecl "cls"%go (go.SliceType (go.PointerType reconnectclient.ReconnectingClient)));
  (go.FieldDecl "leader"%go go.uint64)
].
Program Definition Clerk'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (Clerk'fds_unsealed).
Global Instance equals_unfold_Clerk {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Clerk'fds =→ Clerk'fds_unsealed.
Proof. rewrite /Clerk'fds seal_eq //. Qed.

Definition Clerkⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (Clerk'fds).

Class Clerk_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Clerk_type_repr  :: go.TypeReprUnderlying Clerkⁱᵐᵖˡ Clerk.t;
  #[global] Clerk_underlying :: (Clerk) <u (Clerkⁱᵐᵖˡ);
  #[global] Clerk_get_mu (x : Clerk.t) :: ⟦StructFieldGet (Clerkⁱᵐᵖˡ) "mu", #x⟧ ⤳[under] #x.(Clerk.mu');
  #[global] Clerk_set_mu (x : Clerk.t) y :: ⟦StructFieldSet (Clerkⁱᵐᵖˡ) "mu", (#x, #y)⟧ ⤳[under] #(x <|Clerk.mu' := y|>);
  #[global] Clerk_get_cls (x : Clerk.t) :: ⟦StructFieldGet (Clerkⁱᵐᵖˡ) "cls", #x⟧ ⤳[under] #x.(Clerk.cls');
  #[global] Clerk_set_cls (x : Clerk.t) y :: ⟦StructFieldSet (Clerkⁱᵐᵖˡ) "cls", (#x, #y)⟧ ⤳[under] #(x <|Clerk.cls' := y|>);
  #[global] Clerk_get_leader (x : Clerk.t) :: ⟦StructFieldGet (Clerkⁱᵐᵖˡ) "leader", #x⟧ ⤳[under] #x.(Clerk.leader');
  #[global] Clerk_set_leader (x : Clerk.t) y :: ⟦StructFieldSet (Clerkⁱᵐᵖˡ) "leader", (#x, #y)⟧ ⤳[under] #(x <|Clerk.leader' := y|>);
  #[global] Clerk'ptr_GetConfig_unfold :: MethodUnfold (go.PointerType (Clerk)) "GetConfig" (Clerk__GetConfigⁱᵐᵖˡ);
  #[global] Clerk'ptr_GetLease_unfold :: MethodUnfold (go.PointerType (Clerk)) "GetLease" (Clerk__GetLeaseⁱᵐᵖˡ);
  #[global] Clerk'ptr_ReserveEpochAndGetConfig_unfold :: MethodUnfold (go.PointerType (Clerk)) "ReserveEpochAndGetConfig" (Clerk__ReserveEpochAndGetConfigⁱᵐᵖˡ);
  #[global] Clerk'ptr_TryWriteConfig_unfold :: MethodUnfold (go.PointerType (Clerk)) "TryWriteConfig" (Clerk__TryWriteConfigⁱᵐᵖˡ);
}.

Module state.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  epoch' : w64;
  reservedEpoch' : w64;
  leaseExpiration' : w64;
  wantLeaseToExpire' : bool;
  config' : config_gk.S.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End state.

Definition state'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "epoch"%go go.uint64);
  (go.FieldDecl "reservedEpoch"%go go.uint64);
  (go.FieldDecl "leaseExpiration"%go go.uint64);
  (go.FieldDecl "wantLeaseToExpire"%go go.bool);
  (go.FieldDecl "config"%go config_gk.S)
].
Program Definition state'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (state'fds_unsealed).
Global Instance equals_unfold_state {ext : ffi_syntax} {go_gctx : GoGlobalContext} : state'fds =→ state'fds_unsealed.
Proof. rewrite /state'fds seal_eq //. Qed.

Definition stateⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (state'fds).

Class state_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] state_type_repr  :: go.TypeReprUnderlying stateⁱᵐᵖˡ state.t;
  #[global] state_underlying :: (state) <u (stateⁱᵐᵖˡ);
  #[global] state_get_epoch (x : state.t) :: ⟦StructFieldGet (stateⁱᵐᵖˡ) "epoch", #x⟧ ⤳[under] #x.(state.epoch');
  #[global] state_set_epoch (x : state.t) y :: ⟦StructFieldSet (stateⁱᵐᵖˡ) "epoch", (#x, #y)⟧ ⤳[under] #(x <|state.epoch' := y|>);
  #[global] state_get_reservedEpoch (x : state.t) :: ⟦StructFieldGet (stateⁱᵐᵖˡ) "reservedEpoch", #x⟧ ⤳[under] #x.(state.reservedEpoch');
  #[global] state_set_reservedEpoch (x : state.t) y :: ⟦StructFieldSet (stateⁱᵐᵖˡ) "reservedEpoch", (#x, #y)⟧ ⤳[under] #(x <|state.reservedEpoch' := y|>);
  #[global] state_get_leaseExpiration (x : state.t) :: ⟦StructFieldGet (stateⁱᵐᵖˡ) "leaseExpiration", #x⟧ ⤳[under] #x.(state.leaseExpiration');
  #[global] state_set_leaseExpiration (x : state.t) y :: ⟦StructFieldSet (stateⁱᵐᵖˡ) "leaseExpiration", (#x, #y)⟧ ⤳[under] #(x <|state.leaseExpiration' := y|>);
  #[global] state_get_wantLeaseToExpire (x : state.t) :: ⟦StructFieldGet (stateⁱᵐᵖˡ) "wantLeaseToExpire", #x⟧ ⤳[under] #x.(state.wantLeaseToExpire');
  #[global] state_set_wantLeaseToExpire (x : state.t) y :: ⟦StructFieldSet (stateⁱᵐᵖˡ) "wantLeaseToExpire", (#x, #y)⟧ ⤳[under] #(x <|state.wantLeaseToExpire' := y|>);
  #[global] state_get_config (x : state.t) :: ⟦StructFieldGet (stateⁱᵐᵖˡ) "config", #x⟧ ⤳[under] #x.(state.config');
  #[global] state_set_config (x : state.t) y :: ⟦StructFieldSet (stateⁱᵐᵖˡ) "config", (#x, #y)⟧ ⤳[under] #(x <|state.config' := y|>);
}.

Module Server.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  s' : loc;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End Server.

Definition Server'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "s"%go (go.PointerType paxos.Server))
].
Program Definition Server'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (Server'fds_unsealed).
Global Instance equals_unfold_Server {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Server'fds =→ Server'fds_unsealed.
Proof. rewrite /Server'fds seal_eq //. Qed.

Definition Serverⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (Server'fds).

Class Server_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Server_type_repr  :: go.TypeReprUnderlying Serverⁱᵐᵖˡ Server.t;
  #[global] Server_underlying :: (Server) <u (Serverⁱᵐᵖˡ);
  #[global] Server_get_s (x : Server.t) :: ⟦StructFieldGet (Serverⁱᵐᵖˡ) "s", #x⟧ ⤳[under] #x.(Server.s');
  #[global] Server_set_s (x : Server.t) y :: ⟦StructFieldSet (Serverⁱᵐᵖˡ) "s", (#x, #y)⟧ ⤳[under] #(x <|Server.s' := y|>);
  #[global] Server'ptr_GetConfig_unfold :: MethodUnfold (go.PointerType (Server)) "GetConfig" (Server__GetConfigⁱᵐᵖˡ);
  #[global] Server'ptr_GetLease_unfold :: MethodUnfold (go.PointerType (Server)) "GetLease" (Server__GetLeaseⁱᵐᵖˡ);
  #[global] Server'ptr_ReserveEpochAndGetConfig_unfold :: MethodUnfold (go.PointerType (Server)) "ReserveEpochAndGetConfig" (Server__ReserveEpochAndGetConfigⁱᵐᵖˡ);
  #[global] Server'ptr_TryWriteConfig_unfold :: MethodUnfold (go.PointerType (Server)) "TryWriteConfig" (Server__TryWriteConfigⁱᵐᵖˡ);
  #[global] Server'ptr_tryAcquire_unfold :: MethodUnfold (go.PointerType (Server)) "tryAcquire" (Server__tryAcquireⁱᵐᵖˡ);
}.

Class Assumptions `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Clerk_instance :: Clerk_Assumptions;
  #[global] state_instance :: state_Assumptions;
  #[global] Server_instance :: Server_Assumptions;
  #[global] MakeClerk_unfold :: FuncUnfold MakeClerk [] (MakeClerkⁱᵐᵖˡ);
  #[global] encodeState_unfold :: FuncUnfold encodeState [] (encodeStateⁱᵐᵖˡ);
  #[global] decodeState_unfold :: FuncUnfold decodeState [] (decodeStateⁱᵐᵖˡ);
  #[global] makeServer_unfold :: FuncUnfold makeServer [] (makeServerⁱᵐᵖˡ);
  #[global] StartServer_unfold :: FuncUnfold StartServer [] (StartServerⁱᵐᵖˡ);
  #[global] import_sync_Assumption :: sync.Assumptions;
  #[global] import_primitive_Assumption :: primitive.Assumptions;
  #[global] import_grove_ffi_Assumption :: grove_ffi.Assumptions;
  #[global] import_reconnectclient_Assumption :: reconnectclient.Assumptions;
  #[global] import_config_gk_Assumption :: config_gk.Assumptions;
  #[global] import_err_gk_Assumption :: err_gk.Assumptions;
  #[global] import_marshal_Assumption :: marshal.Assumptions;
  #[global] import_log_Assumption :: log.Assumptions;
  #[global] import_std_Assumption :: std.Assumptions;
  #[global] import_urpc_Assumption :: urpc.Assumptions;
  #[global] import_paxos_Assumption :: paxos.Assumptions;
}.
End configservice.
