(* autogenerated from github.com/mit-pdos/gokv/vrsm/configservice *)
From New.golang Require Import defn.
Require Export New.code.github_com.goose_lang.primitive.
Require Export New.code.github_com.goose_lang.std.
Require Export New.code.github_com.mit_pdos.gokv.grove_ffi.
Require Export New.code.github_com.mit_pdos.gokv.reconnectclient.
Require Export New.code.github_com.mit_pdos.gokv.urpc.
Require Export New.code.github_com.mit_pdos.gokv.vrsm.e.
Require Export New.code.github_com.mit_pdos.gokv.vrsm.paxos.
Require Export New.code.github_com.tchajed.marshal.
Require Export New.code.log.
Require Export New.code.sync.

Definition configservice : go_string := "github.com/mit-pdos/gokv/vrsm/configservice".

From New Require Import grove_prelude.
Module configservice.
Section code.


(* go: 0_marshal.go:8:6 *)
Definition EncodeConfig : val :=
  rec: "EncodeConfig" "config" :=
    exception_do (let: "config" := (mem.alloc "config") in
    let: "enc" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make3 #byteT #(W64 0) (#(W64 8) + (#(W64 8) * (s_to_w64 (let: "$a0" := (![#sliceT] "config") in
    slice.len "$a0"))))) in
    do:  ("enc" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "enc") in
    let: "$a1" := (s_to_w64 (let: "$a0" := (![#sliceT] "config") in
    slice.len "$a0")) in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("enc" <-[#sliceT] "$r0");;;
    let: "$range" := (![#sliceT] "config") in
    (let: "h" := (mem.alloc (type.zero_val #uint64T)) in
    slice.for_range #uint64T "$range" (λ: "$key" "$value",
      do:  ("h" <-[#uint64T] "$value");;;
      do:  "$key";;;
      let: "$r0" := (let: "$a0" := (![#sliceT] "enc") in
      let: "$a1" := (![#uint64T] "h") in
      (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
      do:  ("enc" <-[#sliceT] "$r0")));;;
    return: (![#sliceT] "enc")).

(* go: 0_marshal.go:17:6 *)
Definition DecodeConfig : val :=
  rec: "DecodeConfig" "enc_config" :=
    exception_do (let: "enc_config" := (mem.alloc "enc_config") in
    let: "enc" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "enc_config") in
    do:  ("enc" <-[#sliceT] "$r0");;;
    let: "configLen" := (mem.alloc (type.zero_val #uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "enc") in
    (func_call #marshal.marshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("configLen" <-[#uint64T] "$r0");;;
    do:  ("enc" <-[#sliceT] "$r1");;;
    let: "config" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make2 #uint64T (![#uint64T] "configLen")) in
    do:  ("config" <-[#sliceT] "$r0");;;
    let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (for: (λ: <>, (![#uint64T] "i") < (s_to_w64 (let: "$a0" := (![#sliceT] "config") in
    slice.len "$a0"))); (λ: <>, Skip) := λ: <>,
      let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "enc") in
      (func_call #marshal.marshal #"ReadInt"%go) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ((slice.elem_ref #uint64T (![#sliceT] "config") (![#uint64T] "i")) <-[#uint64T] "$r0");;;
      do:  ("enc" <-[#sliceT] "$r1");;;
      do:  ("i" <-[#uint64T] ((![#uint64T] "i") + #(W64 1))));;;
    return: (![#sliceT] "config")).

Definition Clerk : go_type := structT [
  "mu" :: ptrT;
  "cls" :: sliceT;
  "leader" :: uint64T
].

Definition RPC_RESERVEEPOCH : expr := #(W64 0).

Definition RPC_GETCONFIG : expr := #(W64 1).

Definition RPC_TRYWRITECONFIG : expr := #(W64 2).

Definition RPC_GETLEASE : expr := #(W64 3).

(* go: client.go:26:6 *)
Definition MakeClerk : val :=
  rec: "MakeClerk" "hosts" :=
    exception_do (let: "hosts" := (mem.alloc "hosts") in
    let: "cls" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make2 #ptrT #(W64 0)) in
    do:  ("cls" <-[#sliceT] "$r0");;;
    let: "$range" := (![#sliceT] "hosts") in
    (let: "host" := (mem.alloc (type.zero_val #uint64T)) in
    slice.for_range #uint64T "$range" (λ: "$key" "$value",
      do:  ("host" <-[#uint64T] "$value");;;
      do:  "$key";;;
      let: "$r0" := (let: "$a0" := (![#sliceT] "cls") in
      let: "$a1" := ((let: "$sl0" := (let: "$a0" := (![#uint64T] "host") in
      (func_call #reconnectclient.reconnectclient #"MakeReconnectingClient"%go) "$a0") in
      slice.literal #ptrT ["$sl0"])) in
      (slice.append #ptrT) "$a0" "$a1") in
      do:  ("cls" <-[#sliceT] "$r0")));;;
    return: (mem.alloc (let: "$cls" := (![#sliceT] "cls") in
     let: "$mu" := (mem.alloc (type.zero_val #sync.Mutex)) in
     struct.make #Clerk [{
       "mu" ::= "$mu";
       "cls" ::= "$cls";
       "leader" ::= type.zero_val #uint64T
     }]))).

(* go: client.go:34:18 *)
Definition Clerk__ReserveEpochAndGetConfig : val :=
  rec: "Clerk__ReserveEpochAndGetConfig" "ck" <> :=
    exception_do (let: "ck" := (mem.alloc "ck") in
    let: "reply" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #sliceT)) in
    do:  ("reply" <-[#ptrT] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref #Clerk #"mu"%go (![#ptrT] "ck")))) #());;;
      let: "l" := (mem.alloc (type.zero_val #uint64T)) in
      let: "$r0" := (![#uint64T] (struct.field_ref #Clerk #"leader"%go (![#ptrT] "ck"))) in
      do:  ("l" <-[#uint64T] "$r0");;;
      do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Clerk #"mu"%go (![#ptrT] "ck")))) #());;;
      let: "err" := (mem.alloc (type.zero_val #uint64T)) in
      let: "$r0" := (let: "$a0" := RPC_RESERVEEPOCH in
      let: "$a1" := (slice.make2 #byteT #(W64 0)) in
      let: "$a2" := (![#ptrT] "reply") in
      let: "$a3" := #(W64 100) in
      (method_call #reconnectclient #"ReconnectingClient'ptr" #"Call" (![#ptrT] (slice.elem_ref #ptrT (![#sliceT] (struct.field_ref #Clerk #"cls"%go (![#ptrT] "ck"))) (![#uint64T] "l")))) "$a0" "$a1" "$a2" "$a3") in
      do:  ("err" <-[#uint64T] "$r0");;;
      (if: (![#uint64T] "err") ≠ #(W64 0)
      then continue: #()
      else do:  #());;;
      let: "err2" := (mem.alloc (type.zero_val #uint64T)) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] (![#ptrT] "reply")) in
      (func_call #marshal.marshal #"ReadInt"%go) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("err2" <-[#uint64T] "$r0");;;
      do:  ((![#ptrT] "reply") <-[#sliceT] "$r1");;;
      (if: (![#uint64T] "err2") = e.NotLeader
      then
        do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref #Clerk #"mu"%go (![#ptrT] "ck")))) #());;;
        (if: (![#uint64T] "l") = (![#uint64T] (struct.field_ref #Clerk #"leader"%go (![#ptrT] "ck")))
        then
          let: "$r0" := (((![#uint64T] (struct.field_ref #Clerk #"leader"%go (![#ptrT] "ck"))) + #(W64 1)) `rem` (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref #Clerk #"cls"%go (![#ptrT] "ck"))) in
          slice.len "$a0"))) in
          do:  ((struct.field_ref #Clerk #"leader"%go (![#ptrT] "ck")) <-[#uint64T] "$r0")
        else do:  #());;;
        do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Clerk #"mu"%go (![#ptrT] "ck")))) #());;;
        continue: #()
      else do:  #());;;
      (if: (![#uint64T] "err2") = e.None
      then break: #()
      else do:  #()));;;
    let: "epoch" := (mem.alloc (type.zero_val #uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] (![#ptrT] "reply")) in
    (func_call #marshal.marshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("epoch" <-[#uint64T] "$r0");;;
    do:  ((![#ptrT] "reply") <-[#sliceT] "$r1");;;
    let: "config" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] (![#ptrT] "reply")) in
    (func_call #configservice.configservice #"DecodeConfig"%go) "$a0") in
    do:  ("config" <-[#sliceT] "$r0");;;
    return: (![#uint64T] "epoch", ![#sliceT] "config")).

(* go: client.go:67:18 *)
Definition Clerk__GetConfig : val :=
  rec: "Clerk__GetConfig" "ck" <> :=
    exception_do (let: "ck" := (mem.alloc "ck") in
    let: "reply" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #sliceT)) in
    do:  ("reply" <-[#ptrT] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "i" := (mem.alloc (type.zero_val #uint64T)) in
      let: "$r0" := (((func_call #primitive.primitive #"RandomUint64"%go) #()) `rem` (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref #Clerk #"cls"%go (![#ptrT] "ck"))) in
      slice.len "$a0"))) in
      do:  ("i" <-[#uint64T] "$r0");;;
      let: "err" := (mem.alloc (type.zero_val #uint64T)) in
      let: "$r0" := (let: "$a0" := RPC_GETCONFIG in
      let: "$a1" := (slice.make2 #byteT #(W64 0)) in
      let: "$a2" := (![#ptrT] "reply") in
      let: "$a3" := #(W64 100) in
      (method_call #reconnectclient #"ReconnectingClient'ptr" #"Call" (![#ptrT] (slice.elem_ref #ptrT (![#sliceT] (struct.field_ref #Clerk #"cls"%go (![#ptrT] "ck"))) (![#uint64T] "i")))) "$a0" "$a1" "$a2" "$a3") in
      do:  ("err" <-[#uint64T] "$r0");;;
      (if: (![#uint64T] "err") = #(W64 0)
      then break: #()
      else do:  #());;;
      continue: #());;;
    let: "config" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] (![#ptrT] "reply")) in
    (func_call #configservice.configservice #"DecodeConfig"%go) "$a0") in
    do:  ("config" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "config")).

(* go: client.go:81:18 *)
Definition Clerk__TryWriteConfig : val :=
  rec: "Clerk__TryWriteConfig" "ck" "epoch" "config" :=
    exception_do (let: "ck" := (mem.alloc "ck") in
    let: "config" := (mem.alloc "config") in
    let: "epoch" := (mem.alloc "epoch") in
    let: "reply" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #sliceT)) in
    do:  ("reply" <-[#ptrT] "$r0");;;
    let: "args" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make3 #byteT #(W64 0) (#(W64 8) + (#(W64 8) * (let: "$a0" := (![#sliceT] "config") in
    slice.len "$a0")))) in
    do:  ("args" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "args") in
    let: "$a1" := (![#uint64T] "epoch") in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("args" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "args") in
    let: "$a1" := (let: "$a0" := (![#sliceT] "config") in
    (func_call #configservice.configservice #"EncodeConfig"%go) "$a0") in
    (func_call #marshal.marshal #"WriteBytes"%go) "$a0" "$a1") in
    do:  ("args" <-[#sliceT] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref #Clerk #"mu"%go (![#ptrT] "ck")))) #());;;
      let: "l" := (mem.alloc (type.zero_val #uint64T)) in
      let: "$r0" := (![#uint64T] (struct.field_ref #Clerk #"leader"%go (![#ptrT] "ck"))) in
      do:  ("l" <-[#uint64T] "$r0");;;
      do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Clerk #"mu"%go (![#ptrT] "ck")))) #());;;
      let: "err" := (mem.alloc (type.zero_val #uint64T)) in
      let: "$r0" := (let: "$a0" := RPC_TRYWRITECONFIG in
      let: "$a1" := (![#sliceT] "args") in
      let: "$a2" := (![#ptrT] "reply") in
      let: "$a3" := #(W64 2000) in
      (method_call #reconnectclient #"ReconnectingClient'ptr" #"Call" (![#ptrT] (slice.elem_ref #ptrT (![#sliceT] (struct.field_ref #Clerk #"cls"%go (![#ptrT] "ck"))) (![#uint64T] "l")))) "$a0" "$a1" "$a2" "$a3") in
      do:  ("err" <-[#uint64T] "$r0");;;
      (if: (![#uint64T] "err") ≠ #(W64 0)
      then continue: #()
      else do:  #());;;
      let: "err2" := (mem.alloc (type.zero_val #uint64T)) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] (![#ptrT] "reply")) in
      (func_call #marshal.marshal #"ReadInt"%go) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("err2" <-[#uint64T] "$r0");;;
      do:  "$r1";;;
      (if: (![#uint64T] "err2") = e.NotLeader
      then
        do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref #Clerk #"mu"%go (![#ptrT] "ck")))) #());;;
        (if: (![#uint64T] "l") = (![#uint64T] (struct.field_ref #Clerk #"leader"%go (![#ptrT] "ck")))
        then
          let: "$r0" := (((![#uint64T] (struct.field_ref #Clerk #"leader"%go (![#ptrT] "ck"))) + #(W64 1)) `rem` (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref #Clerk #"cls"%go (![#ptrT] "ck"))) in
          slice.len "$a0"))) in
          do:  ((struct.field_ref #Clerk #"leader"%go (![#ptrT] "ck")) <-[#uint64T] "$r0")
        else do:  #());;;
        do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Clerk #"mu"%go (![#ptrT] "ck")))) #());;;
        continue: #()
      else break: #()));;;
    let: "err" := (mem.alloc (type.zero_val #uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] (![#ptrT] "reply")) in
    (func_call #marshal.marshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("err" <-[#uint64T] "$r0");;;
    do:  "$r1";;;
    return: (![#uint64T] "err")).

(* returns e.None if the lease was granted for the given epoch, and a conservative
   guess on when the lease expires.

   go: client.go:117:18 *)
Definition Clerk__GetLease : val :=
  rec: "Clerk__GetLease" "ck" "epoch" :=
    exception_do (let: "ck" := (mem.alloc "ck") in
    let: "epoch" := (mem.alloc "epoch") in
    let: "reply" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #sliceT)) in
    do:  ("reply" <-[#ptrT] "$r0");;;
    let: "args" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make3 #byteT #(W64 0) #(W64 8)) in
    do:  ("args" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "args") in
    let: "$a1" := (![#uint64T] "epoch") in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("args" <-[#sliceT] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref #Clerk #"mu"%go (![#ptrT] "ck")))) #());;;
      let: "l" := (mem.alloc (type.zero_val #uint64T)) in
      let: "$r0" := (![#uint64T] (struct.field_ref #Clerk #"leader"%go (![#ptrT] "ck"))) in
      do:  ("l" <-[#uint64T] "$r0");;;
      do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Clerk #"mu"%go (![#ptrT] "ck")))) #());;;
      let: "err" := (mem.alloc (type.zero_val #uint64T)) in
      let: "$r0" := (let: "$a0" := RPC_GETLEASE in
      let: "$a1" := (![#sliceT] "args") in
      let: "$a2" := (![#ptrT] "reply") in
      let: "$a3" := #(W64 100) in
      (method_call #reconnectclient #"ReconnectingClient'ptr" #"Call" (![#ptrT] (slice.elem_ref #ptrT (![#sliceT] (struct.field_ref #Clerk #"cls"%go (![#ptrT] "ck"))) (![#uint64T] "l")))) "$a0" "$a1" "$a2" "$a3") in
      do:  ("err" <-[#uint64T] "$r0");;;
      (if: (![#uint64T] "err") ≠ #(W64 0)
      then continue: #()
      else do:  #());;;
      let: "err2" := (mem.alloc (type.zero_val #uint64T)) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] (![#ptrT] "reply")) in
      (func_call #marshal.marshal #"ReadInt"%go) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("err2" <-[#uint64T] "$r0");;;
      do:  "$r1";;;
      (if: (![#uint64T] "err2") = e.NotLeader
      then
        do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref #Clerk #"mu"%go (![#ptrT] "ck")))) #());;;
        (if: (![#uint64T] "l") = (![#uint64T] (struct.field_ref #Clerk #"leader"%go (![#ptrT] "ck")))
        then
          let: "$r0" := (((![#uint64T] (struct.field_ref #Clerk #"leader"%go (![#ptrT] "ck"))) + #(W64 1)) `rem` (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref #Clerk #"cls"%go (![#ptrT] "ck"))) in
          slice.len "$a0"))) in
          do:  ((struct.field_ref #Clerk #"leader"%go (![#ptrT] "ck")) <-[#uint64T] "$r0")
        else do:  #());;;
        do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Clerk #"mu"%go (![#ptrT] "ck")))) #());;;
        continue: #()
      else break: #()));;;
    let: "enc" := (mem.alloc (type.zero_val #sliceT)) in
    let: "err2" := (mem.alloc (type.zero_val #uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] (![#ptrT] "reply")) in
    (func_call #marshal.marshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("err2" <-[#uint64T] "$r0");;;
    do:  ("enc" <-[#sliceT] "$r1");;;
    let: "leaseExpiration" := (mem.alloc (type.zero_val #uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "enc") in
    (func_call #marshal.marshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("leaseExpiration" <-[#uint64T] "$r0");;;
    do:  "$r1";;;
    return: (![#uint64T] "err2", ![#uint64T] "leaseExpiration")).

(* 1 second *)
Definition LeaseInterval : expr := #(W64 1000000000).

Definition state : go_type := structT [
  "epoch" :: uint64T;
  "reservedEpoch" :: uint64T;
  "leaseExpiration" :: uint64T;
  "wantLeaseToExpire" :: boolT;
  "config" :: sliceT
].

(* go: server.go:25:6 *)
Definition encodeState : val :=
  rec: "encodeState" "st" :=
    exception_do (let: "st" := (mem.alloc "st") in
    let: "e" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := #slice.nil in
    let: "$a1" := (![#uint64T] (struct.field_ref #state #"epoch"%go (![#ptrT] "st"))) in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("e" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "e") in
    let: "$a1" := (![#uint64T] (struct.field_ref #state #"reservedEpoch"%go (![#ptrT] "st"))) in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("e" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "e") in
    let: "$a1" := (![#uint64T] (struct.field_ref #state #"leaseExpiration"%go (![#ptrT] "st"))) in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("e" <-[#sliceT] "$r0");;;
    (if: ![#boolT] (struct.field_ref #state #"wantLeaseToExpire"%go (![#ptrT] "st"))
    then
      let: "$r0" := (let: "$a0" := (![#sliceT] "e") in
      let: "$a1" := #(W64 1) in
      (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
      do:  ("e" <-[#sliceT] "$r0")
    else
      let: "$r0" := (let: "$a0" := (![#sliceT] "e") in
      let: "$a1" := #(W64 0) in
      (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
      do:  ("e" <-[#sliceT] "$r0"));;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "e") in
    let: "$a1" := (let: "$a0" := (![#sliceT] (struct.field_ref #state #"config"%go (![#ptrT] "st"))) in
    (func_call #configservice.configservice #"EncodeConfig"%go) "$a0") in
    (func_call #marshal.marshal #"WriteBytes"%go) "$a0" "$a1") in
    do:  ("e" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "e")).

(* go: server.go:39:6 *)
Definition decodeState : val :=
  rec: "decodeState" "e" :=
    exception_do (let: "e" := (mem.alloc "e") in
    let: "st" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #state)) in
    do:  ("st" <-[#ptrT] "$r0");;;
    let: "e2" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "e") in
    do:  ("e2" <-[#sliceT] "$r0");;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "e2") in
    (func_call #marshal.marshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ((struct.field_ref #state #"epoch"%go (![#ptrT] "st")) <-[#uint64T] "$r0");;;
    do:  ("e2" <-[#sliceT] "$r1");;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "e2") in
    (func_call #marshal.marshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ((struct.field_ref #state #"reservedEpoch"%go (![#ptrT] "st")) <-[#uint64T] "$r0");;;
    do:  ("e2" <-[#sliceT] "$r1");;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "e2") in
    (func_call #marshal.marshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ((struct.field_ref #state #"leaseExpiration"%go (![#ptrT] "st")) <-[#uint64T] "$r0");;;
    do:  ("e2" <-[#sliceT] "$r1");;;
    let: "wantExp" := (mem.alloc (type.zero_val #uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "e2") in
    (func_call #marshal.marshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("wantExp" <-[#uint64T] "$r0");;;
    do:  ("e2" <-[#sliceT] "$r1");;;
    let: "$r0" := ((![#uint64T] "wantExp") = #(W64 1)) in
    do:  ((struct.field_ref #state #"wantLeaseToExpire"%go (![#ptrT] "st")) <-[#boolT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "e2") in
    (func_call #configservice.configservice #"DecodeConfig"%go) "$a0") in
    do:  ((struct.field_ref #state #"config"%go (![#ptrT] "st")) <-[#sliceT] "$r0");;;
    return: (![#ptrT] "st")).

Definition Server : go_type := structT [
  "s" :: ptrT
].

(* go: server.go:56:18 *)
Definition Server__tryAcquire : val :=
  rec: "Server__tryAcquire" "s" <> :=
    exception_do (let: "s" := (mem.alloc "s") in
    let: "relF" := (mem.alloc (type.zero_val #funcT)) in
    let: "e" := (mem.alloc (type.zero_val #ptrT)) in
    let: "err" := (mem.alloc (type.zero_val #paxos.Error)) in
    let: (("$ret0", "$ret1"), "$ret2") := ((method_call #paxos #"Server'ptr" #"TryAcquire" (![#ptrT] (struct.field_ref #Server #"s"%go (![#ptrT] "s")))) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("err" <-[#paxos.Error] "$r0");;;
    do:  ("e" <-[#ptrT] "$r1");;;
    do:  ("relF" <-[#funcT] "$r2");;;
    (if: (![#paxos.Error] "err") ≠ #(W64 0)
    then
      let: "p" := (mem.alloc (type.zero_val #ptrT)) in
      return: (#false, ![#ptrT] "p", #func.nil)
    else do:  #());;;
    let: "st" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] (![#ptrT] "e")) in
    (func_call #configservice.configservice #"decodeState"%go) "$a0") in
    do:  ("st" <-[#ptrT] "$r0");;;
    let: "releaseFn" := (mem.alloc (type.zero_val #funcT)) in
    let: "$r0" := (λ: <>,
      exception_do (let: "$r0" := (let: "$a0" := (![#ptrT] "st") in
      (func_call #configservice.configservice #"encodeState"%go) "$a0") in
      do:  ((![#ptrT] "e") <-[#sliceT] "$r0");;;
      return: (((![#funcT] "relF") #()) = #(W64 0)))
      ) in
    do:  ("releaseFn" <-[#funcT] "$r0");;;
    return: (#true, ![#ptrT] "st", ![#funcT] "releaseFn")).

(* go: server.go:70:18 *)
Definition Server__ReserveEpochAndGetConfig : val :=
  rec: "Server__ReserveEpochAndGetConfig" "s" "args" "reply" :=
    exception_do (let: "s" := (mem.alloc "s") in
    let: "reply" := (mem.alloc "reply") in
    let: "args" := (mem.alloc "args") in
    let: "$r0" := (let: "$a0" := #slice.nil in
    let: "$a1" := e.NotLeader in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ((![#ptrT] "reply") <-[#sliceT] "$r0");;;
    let: "tryReleaseFn" := (mem.alloc (type.zero_val #funcT)) in
    let: "st" := (mem.alloc (type.zero_val #ptrT)) in
    let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: (("$ret0", "$ret1"), "$ret2") := ((method_call #configservice.configservice #"Server'ptr" #"tryAcquire" (![#ptrT] "s")) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("ok" <-[#boolT] "$r0");;;
    do:  ("st" <-[#ptrT] "$r1");;;
    do:  ("tryReleaseFn" <-[#funcT] "$r2");;;
    (if: (~ (![#boolT] "ok"))
    then return: (#())
    else do:  #());;;
    let: "$r0" := (let: "$a0" := (![#uint64T] (struct.field_ref #state #"reservedEpoch"%go (![#ptrT] "st"))) in
    let: "$a1" := #(W64 1) in
    (func_call #std.std #"SumAssumeNoOverflow"%go) "$a0" "$a1") in
    do:  ((struct.field_ref #state #"reservedEpoch"%go (![#ptrT] "st")) <-[#uint64T] "$r0");;;
    let: "config" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] (struct.field_ref #state #"config"%go (![#ptrT] "st"))) in
    do:  ("config" <-[#sliceT] "$r0");;;
    let: "reservedEpoch" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (![#uint64T] (struct.field_ref #state #"reservedEpoch"%go (![#ptrT] "st"))) in
    do:  ("reservedEpoch" <-[#uint64T] "$r0");;;
    (if: (~ ((![#funcT] "tryReleaseFn") #()))
    then return: (#())
    else do:  #());;;
    let: "$r0" := (slice.make3 #byteT #(W64 0) (#(W64 (8 + 8)) + (#(W64 8) * (let: "$a0" := (![#sliceT] "config") in
    slice.len "$a0")))) in
    do:  ((![#ptrT] "reply") <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] (![#ptrT] "reply")) in
    let: "$a1" := e.None in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ((![#ptrT] "reply") <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] (![#ptrT] "reply")) in
    let: "$a1" := (![#uint64T] "reservedEpoch") in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ((![#ptrT] "reply") <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] (![#ptrT] "reply")) in
    let: "$a1" := (let: "$a0" := (![#sliceT] "config") in
    (func_call #configservice.configservice #"EncodeConfig"%go) "$a0") in
    (func_call #marshal.marshal #"WriteBytes"%go) "$a0" "$a1") in
    do:  ((![#ptrT] "reply") <-[#sliceT] "$r0")).

(* go: server.go:88:18 *)
Definition Server__GetConfig : val :=
  rec: "Server__GetConfig" "s" "args" "reply" :=
    exception_do (let: "s" := (mem.alloc "s") in
    let: "reply" := (mem.alloc "reply") in
    let: "args" := (mem.alloc "args") in
    let: "st" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := ((method_call #paxos #"Server'ptr" #"WeakRead" (![#ptrT] (struct.field_ref #Server #"s"%go (![#ptrT] "s")))) #()) in
    (func_call #configservice.configservice #"decodeState"%go) "$a0") in
    do:  ("st" <-[#ptrT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] (struct.field_ref #state #"config"%go (![#ptrT] "st"))) in
    (func_call #configservice.configservice #"EncodeConfig"%go) "$a0") in
    do:  ((![#ptrT] "reply") <-[#sliceT] "$r0")).

(* go: server.go:93:18 *)
Definition Server__TryWriteConfig : val :=
  rec: "Server__TryWriteConfig" "s" "args" "reply" :=
    exception_do (let: "s" := (mem.alloc "s") in
    let: "reply" := (mem.alloc "reply") in
    let: "args" := (mem.alloc "args") in
    let: "$r0" := (let: "$a0" := #slice.nil in
    let: "$a1" := e.NotLeader in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ((![#ptrT] "reply") <-[#sliceT] "$r0");;;
    let: "enc" := (mem.alloc (type.zero_val #sliceT)) in
    let: "epoch" := (mem.alloc (type.zero_val #uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "args") in
    (func_call #marshal.marshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("epoch" <-[#uint64T] "$r0");;;
    do:  ("enc" <-[#sliceT] "$r1");;;
    let: "config" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "enc") in
    (func_call #configservice.configservice #"DecodeConfig"%go) "$a0") in
    do:  ("config" <-[#sliceT] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "tryReleaseFn" := (mem.alloc (type.zero_val #funcT)) in
      let: "st" := (mem.alloc (type.zero_val #ptrT)) in
      let: "ok" := (mem.alloc (type.zero_val #boolT)) in
      let: (("$ret0", "$ret1"), "$ret2") := ((method_call #configservice.configservice #"Server'ptr" #"tryAcquire" (![#ptrT] "s")) #()) in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      let: "$r2" := "$ret2" in
      do:  ("ok" <-[#boolT] "$r0");;;
      do:  ("st" <-[#ptrT] "$r1");;;
      do:  ("tryReleaseFn" <-[#funcT] "$r2");;;
      (if: (~ (![#boolT] "ok"))
      then break: #()
      else do:  #());;;
      (if: (![#uint64T] "epoch") < (![#uint64T] (struct.field_ref #state #"reservedEpoch"%go (![#ptrT] "st")))
      then
        (if: (~ ((![#funcT] "tryReleaseFn") #()))
        then break: #()
        else do:  #());;;
        let: "$r0" := (let: "$a0" := #slice.nil in
        let: "$a1" := e.Stale in
        (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
        do:  ((![#ptrT] "reply") <-[#sliceT] "$r0");;;
        do:  (let: "$a0" := #"Stale: %d < %d"%go in
        let: "$a1" := ((let: "$sl0" := (interface.make #""%go #"uint64"%go (![#uint64T] "epoch")) in
        let: "$sl1" := (interface.make #""%go #"uint64"%go (![#uint64T] (struct.field_ref #state #"reservedEpoch"%go (![#ptrT] "st")))) in
        slice.literal #interfaceT ["$sl0"; "$sl1"])) in
        (func_call #log.log #"Printf"%go) "$a0" "$a1");;;
        break: #()
      else
        (if: (![#uint64T] "epoch") > (![#uint64T] (struct.field_ref #state #"epoch"%go (![#ptrT] "st")))
        then
          let: "l" := (mem.alloc (type.zero_val #uint64T)) in
          let: ("$ret0", "$ret1") := ((func_call #grove_ffi.grove_ffi #"GetTimeRange"%go) #()) in
          let: "$r0" := "$ret0" in
          let: "$r1" := "$ret1" in
          do:  ("l" <-[#uint64T] "$r0");;;
          do:  "$r1";;;
          (if: (![#uint64T] "l") ≥ (![#uint64T] (struct.field_ref #state #"leaseExpiration"%go (![#ptrT] "st")))
          then
            let: "$r0" := #false in
            do:  ((struct.field_ref #state #"wantLeaseToExpire"%go (![#ptrT] "st")) <-[#boolT] "$r0");;;
            let: "$r0" := (![#uint64T] "epoch") in
            do:  ((struct.field_ref #state #"epoch"%go (![#ptrT] "st")) <-[#uint64T] "$r0");;;
            let: "$r0" := (![#sliceT] "config") in
            do:  ((struct.field_ref #state #"config"%go (![#ptrT] "st")) <-[#sliceT] "$r0");;;
            (if: (~ ((![#funcT] "tryReleaseFn") #()))
            then break: #()
            else do:  #());;;
            do:  (let: "$a0" := ((let: "$sl0" := (interface.make #""%go #"string"%go #"New config is:"%go) in
            let: "$sl1" := (interface.make #"slice'"%go (![#sliceT] (struct.field_ref #state #"config"%go (![#ptrT] "st")))) in
            slice.literal #interfaceT ["$sl0"; "$sl1"])) in
            (func_call #log.log #"Println"%go) "$a0");;;
            let: "$r0" := (let: "$a0" := #slice.nil in
            let: "$a1" := e.None in
            (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
            do:  ((![#ptrT] "reply") <-[#sliceT] "$r0");;;
            break: #()
          else
            let: "$r0" := #true in
            do:  ((struct.field_ref #state #"wantLeaseToExpire"%go (![#ptrT] "st")) <-[#boolT] "$r0");;;
            let: "timeToSleep" := (mem.alloc (type.zero_val #uint64T)) in
            let: "$r0" := ((![#uint64T] (struct.field_ref #state #"leaseExpiration"%go (![#ptrT] "st"))) - (![#uint64T] "l")) in
            do:  ("timeToSleep" <-[#uint64T] "$r0");;;
            (if: (~ ((![#funcT] "tryReleaseFn") #()))
            then break: #()
            else do:  #());;;
            do:  (let: "$a0" := (![#uint64T] "timeToSleep") in
            (func_call #primitive.primitive #"Sleep"%go) "$a0");;;
            continue: #())
        else
          let: "$r0" := (![#sliceT] "config") in
          do:  ((struct.field_ref #state #"config"%go (![#ptrT] "st")) <-[#sliceT] "$r0");;;
          (if: (~ ((![#funcT] "tryReleaseFn") #()))
          then break: #()
          else do:  #());;;
          let: "$r0" := (let: "$a0" := #slice.nil in
          let: "$a1" := e.None in
          (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
          do:  ((![#ptrT] "reply") <-[#sliceT] "$r0");;;
          break: #())))).

(* go: server.go:145:18 *)
Definition Server__GetLease : val :=
  rec: "Server__GetLease" "s" "args" "reply" :=
    exception_do (let: "s" := (mem.alloc "s") in
    let: "reply" := (mem.alloc "reply") in
    let: "args" := (mem.alloc "args") in
    let: "$r0" := (let: "$a0" := #slice.nil in
    let: "$a1" := e.NotLeader in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ((![#ptrT] "reply") <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] (![#ptrT] "reply")) in
    let: "$a1" := #(W64 0) in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ((![#ptrT] "reply") <-[#sliceT] "$r0");;;
    let: "epoch" := (mem.alloc (type.zero_val #uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "args") in
    (func_call #marshal.marshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("epoch" <-[#uint64T] "$r0");;;
    do:  "$r1";;;
    let: "tryReleaseFn" := (mem.alloc (type.zero_val #funcT)) in
    let: "st" := (mem.alloc (type.zero_val #ptrT)) in
    let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: (("$ret0", "$ret1"), "$ret2") := ((method_call #configservice.configservice #"Server'ptr" #"tryAcquire" (![#ptrT] "s")) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("ok" <-[#boolT] "$r0");;;
    do:  ("st" <-[#ptrT] "$r1");;;
    do:  ("tryReleaseFn" <-[#funcT] "$r2");;;
    (if: (~ (![#boolT] "ok"))
    then return: (#())
    else do:  #());;;
    (if: ((![#uint64T] (struct.field_ref #state #"epoch"%go (![#ptrT] "st"))) ≠ (![#uint64T] "epoch")) || (![#boolT] (struct.field_ref #state #"wantLeaseToExpire"%go (![#ptrT] "st")))
    then
      do:  (let: "$a0" := ((let: "$sl0" := (interface.make #""%go #"string"%go #"Rejected lease request"%go) in
      let: "$sl1" := (interface.make #""%go #"uint64"%go (![#uint64T] "epoch")) in
      let: "$sl2" := (interface.make #""%go #"uint64"%go (![#uint64T] (struct.field_ref #state #"epoch"%go (![#ptrT] "st")))) in
      let: "$sl3" := (interface.make #""%go #"bool"%go (![#boolT] (struct.field_ref #state #"wantLeaseToExpire"%go (![#ptrT] "st")))) in
      slice.literal #interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"])) in
      (func_call #log.log #"Println"%go) "$a0");;;
      (if: (~ ((![#funcT] "tryReleaseFn") #()))
      then return: (#())
      else do:  #());;;
      let: "$r0" := (let: "$a0" := #slice.nil in
      let: "$a1" := e.Stale in
      (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
      do:  ((![#ptrT] "reply") <-[#sliceT] "$r0");;;
      let: "$r0" := (let: "$a0" := (![#sliceT] (![#ptrT] "reply")) in
      let: "$a1" := #(W64 0) in
      (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
      do:  ((![#ptrT] "reply") <-[#sliceT] "$r0");;;
      return: (#())
    else do:  #());;;
    let: "l" := (mem.alloc (type.zero_val #uint64T)) in
    let: ("$ret0", "$ret1") := ((func_call #grove_ffi.grove_ffi #"GetTimeRange"%go) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("l" <-[#uint64T] "$r0");;;
    do:  "$r1";;;
    let: "newLeaseExpiration" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := ((![#uint64T] "l") + LeaseInterval) in
    do:  ("newLeaseExpiration" <-[#uint64T] "$r0");;;
    (if: (![#uint64T] "newLeaseExpiration") > (![#uint64T] (struct.field_ref #state #"leaseExpiration"%go (![#ptrT] "st")))
    then
      let: "$r0" := (![#uint64T] "newLeaseExpiration") in
      do:  ((struct.field_ref #state #"leaseExpiration"%go (![#ptrT] "st")) <-[#uint64T] "$r0")
    else do:  #());;;
    (if: (~ ((![#funcT] "tryReleaseFn") #()))
    then return: (#())
    else do:  #());;;
    let: "$r0" := (let: "$a0" := #slice.nil in
    let: "$a1" := e.None in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ((![#ptrT] "reply") <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] (![#ptrT] "reply")) in
    let: "$a1" := (![#uint64T] "newLeaseExpiration") in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ((![#ptrT] "reply") <-[#sliceT] "$r0")).

(* go: server.go:177:6 *)
Definition makeServer : val :=
  rec: "makeServer" "fname" "paxosMe" "hosts" "initconfig" :=
    exception_do (let: "initconfig" := (mem.alloc "initconfig") in
    let: "hosts" := (mem.alloc "hosts") in
    let: "paxosMe" := (mem.alloc "paxosMe") in
    let: "fname" := (mem.alloc "fname") in
    let: "s" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #Server)) in
    do:  ("s" <-[#ptrT] "$r0");;;
    let: "initEnc" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (mem.alloc (let: "$config" := (![#sliceT] "initconfig") in
    struct.make #state [{
      "epoch" ::= type.zero_val #uint64T;
      "reservedEpoch" ::= type.zero_val #uint64T;
      "leaseExpiration" ::= type.zero_val #uint64T;
      "wantLeaseToExpire" ::= type.zero_val #boolT;
      "config" ::= "$config"
    }])) in
    (func_call #configservice.configservice #"encodeState"%go) "$a0") in
    do:  ("initEnc" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#stringT] "fname") in
    let: "$a1" := (![#sliceT] "initEnc") in
    let: "$a2" := (![#uint64T] "paxosMe") in
    let: "$a3" := (![#sliceT] "hosts") in
    (func_call #paxos.paxos #"StartServer"%go) "$a0" "$a1" "$a2" "$a3") in
    do:  ((struct.field_ref #Server #"s"%go (![#ptrT] "s")) <-[#ptrT] "$r0");;;
    return: (![#ptrT] "s")).

(* go: server.go:187:6 *)
Definition StartServer : val :=
  rec: "StartServer" "fname" "me" "paxosMe" "hosts" "initconfig" :=
    exception_do (let: "initconfig" := (mem.alloc "initconfig") in
    let: "hosts" := (mem.alloc "hosts") in
    let: "paxosMe" := (mem.alloc "paxosMe") in
    let: "me" := (mem.alloc "me") in
    let: "fname" := (mem.alloc "fname") in
    let: "s" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := (![#stringT] "fname") in
    let: "$a1" := (![#uint64T] "paxosMe") in
    let: "$a2" := (![#sliceT] "hosts") in
    let: "$a3" := (![#sliceT] "initconfig") in
    (func_call #configservice.configservice #"makeServer"%go) "$a0" "$a1" "$a2" "$a3") in
    do:  ("s" <-[#ptrT] "$r0");;;
    let: "handlers" := (mem.alloc (type.zero_val (type.mapT #uint64T #funcT))) in
    let: "$r0" := (map.make #uint64T #funcT) in
    do:  ("handlers" <-[type.mapT #uint64T #funcT] "$r0");;;
    let: "$r0" := (method_call #configservice.configservice #"Server'ptr" #"ReserveEpochAndGetConfig" (![#ptrT] "s")) in
    do:  (map.insert (![type.mapT #uint64T #funcT] "handlers") RPC_RESERVEEPOCH "$r0");;;
    let: "$r0" := (method_call #configservice.configservice #"Server'ptr" #"GetConfig" (![#ptrT] "s")) in
    do:  (map.insert (![type.mapT #uint64T #funcT] "handlers") RPC_GETCONFIG "$r0");;;
    let: "$r0" := (method_call #configservice.configservice #"Server'ptr" #"TryWriteConfig" (![#ptrT] "s")) in
    do:  (map.insert (![type.mapT #uint64T #funcT] "handlers") RPC_TRYWRITECONFIG "$r0");;;
    let: "$r0" := (method_call #configservice.configservice #"Server'ptr" #"GetLease" (![#ptrT] "s")) in
    do:  (map.insert (![type.mapT #uint64T #funcT] "handlers") RPC_GETLEASE "$r0");;;
    let: "rs" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := (![type.mapT #uint64T #funcT] "handlers") in
    (func_call #urpc.urpc #"MakeServer"%go) "$a0") in
    do:  ("rs" <-[#ptrT] "$r0");;;
    do:  (let: "$a0" := (![#uint64T] "me") in
    (method_call #urpc #"Server'ptr" #"Serve" (![#ptrT] "rs")) "$a0");;;
    return: (![#ptrT] "s")).

Definition vars' : list (go_string * go_type) := [].

Definition functions' : list (go_string * val) := [("EncodeConfig"%go, EncodeConfig); ("DecodeConfig"%go, DecodeConfig); ("MakeClerk"%go, MakeClerk); ("encodeState"%go, encodeState); ("decodeState"%go, decodeState); ("makeServer"%go, makeServer); ("StartServer"%go, StartServer)].

Definition msets' : list (go_string * (list (go_string * val))) := [("Clerk"%go, []); ("Clerk'ptr"%go, [("GetConfig"%go, Clerk__GetConfig); ("GetLease"%go, Clerk__GetLease); ("ReserveEpochAndGetConfig"%go, Clerk__ReserveEpochAndGetConfig); ("TryWriteConfig"%go, Clerk__TryWriteConfig)]); ("state"%go, []); ("state'ptr"%go, []); ("Server"%go, []); ("Server'ptr"%go, [("GetConfig"%go, Server__GetConfig); ("GetLease"%go, Server__GetLease); ("ReserveEpochAndGetConfig"%go, Server__ReserveEpochAndGetConfig); ("TryWriteConfig"%go, Server__TryWriteConfig); ("tryAcquire"%go, Server__tryAcquire)])].

#[global] Instance info' : PkgInfo configservice.configservice :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [grove_ffi.grove_ffi; marshal.marshal; sync.sync; primitive.primitive; reconnectclient.reconnectclient; e.e; log.log; std.std; urpc.urpc; paxos.paxos];
  |}.

Definition initialize' : val :=
  rec: "initialize'" <> :=
    globals.package_init configservice.configservice (λ: <>,
      exception_do (do:  paxos.initialize';;;
      do:  urpc.initialize';;;
      do:  std.initialize';;;
      do:  log.initialize';;;
      do:  e.initialize';;;
      do:  reconnectclient.initialize';;;
      do:  primitive.initialize';;;
      do:  sync.initialize';;;
      do:  marshal.initialize';;;
      do:  grove_ffi.initialize')
      ).

End code.
End configservice.
