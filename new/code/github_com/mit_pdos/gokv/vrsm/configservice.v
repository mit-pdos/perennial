(* autogenerated from github.com/mit-pdos/gokv/vrsm/configservice *)
Require Export New.code.github_com.goose_lang.primitive.
Require Export New.code.github_com.goose_lang.std.
Require Export New.code.github_com.mit_pdos.gokv.grove_ffi.
Require Export New.code.github_com.mit_pdos.gokv.reconnectclient.
Require Export New.code.github_com.mit_pdos.gokv.urpc.
Require Export New.code.github_com.mit_pdos.gokv.vrsm.configservice.config_gk.
Require Export New.code.github_com.mit_pdos.gokv.vrsm.paxos.
Require Export New.code.github_com.mit_pdos.gokv.vrsm.replica.err_gk.
Require Export New.code.github_com.tchajed.marshal.
Require Export New.code.log.
Require Export New.code.sync.

From New.golang Require Import defn.
Definition configservice : go_string := "github.com/mit-pdos/gokv/vrsm/configservice".

From New Require Import grove_prelude.
Module configservice.

Module Clerk. Definition id : go_string := "github.com/mit-pdos/gokv/vrsm/configservice.Clerk"%go. End Clerk.
Module state. Definition id : go_string := "github.com/mit-pdos/gokv/vrsm/configservice.state"%go. End state.
Module Server. Definition id : go_string := "github.com/mit-pdos/gokv/vrsm/configservice.Server"%go. End Server.

Section code.


Definition Clerk : go_type := structT [
  "mu" :: ptrT;
  "cls" :: sliceT;
  "leader" :: uint64T
].

Definition RPC_RESERVEEPOCH : expr := #(W64 0).

Definition RPC_GETCONFIG : expr := #(W64 1).

Definition RPC_TRYWRITECONFIG : expr := #(W64 2).

Definition RPC_GETLEASE : expr := #(W64 3).

Definition MakeClerk : go_string := "github.com/mit-pdos/gokv/vrsm/configservice.MakeClerk"%go.

(* go: client.go:27:6 *)
Definition MakeClerkⁱᵐᵖˡ : val :=
  λ: "hosts",
    exception_do (let: "hosts" := (mem.alloc "hosts") in
    let: "cls" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make2 #ptrT #(W64 0)) in
    do:  ("cls" <-[#sliceT] "$r0");;;
    let: "$range" := (![#sliceT] "hosts") in
    (let: "host" := (mem.alloc (type.zero_val #uint64T)) in
    slice.for_range #uint64T "$range" (λ: "$key" "$value",
      do:  ("host" <-[#uint64T] "$value");;;
      do:  "$key";;;
      let: "$r0" := (let: "$a0" := (![#sliceT] "cls") in
      let: "$a1" := ((let: "$sl0" := (let: "$a0" := (![#uint64T] "host") in
      (func_call #reconnectclient.MakeReconnectingClient) "$a0") in
      slice.literal #ptrT ["$sl0"])) in
      (slice.append #ptrT) "$a0" "$a1") in
      do:  ("cls" <-[#sliceT] "$r0")));;;
    return: (mem.alloc (let: "$cls" := (![#sliceT] "cls") in
     let: "$mu" := (mem.alloc (type.zero_val #sync.Mutex)) in
     struct.make #Clerk [{
       "mu" ::= "$mu";
       "cls" ::= "$cls";
       "leader" ::= type.zero_val #uint64T
     }]))).

(* go: client.go:35:18 *)
Definition Clerk__ReserveEpochAndGetConfigⁱᵐᵖˡ : val :=
  λ: "ck" <>,
    exception_do (let: "ck" := (mem.alloc "ck") in
    let: "reply" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #sliceT)) in
    do:  ("reply" <-[#ptrT] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] (struct.field_ref #Clerk #"mu"%go (![#ptrT] "ck")))) #());;;
      let: "l" := (mem.alloc (type.zero_val #uint64T)) in
      let: "$r0" := (![#uint64T] (struct.field_ref #Clerk #"leader"%go (![#ptrT] "ck"))) in
      do:  ("l" <-[#uint64T] "$r0");;;
      do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref #Clerk #"mu"%go (![#ptrT] "ck")))) #());;;
      let: "err" := (mem.alloc (type.zero_val #uint64T)) in
      let: "$r0" := (let: "$a0" := RPC_RESERVEEPOCH in
      let: "$a1" := (slice.make2 #byteT #(W64 0)) in
      let: "$a2" := (![#ptrT] "reply") in
      let: "$a3" := #(W64 100) in
      (method_call #(ptrT.id reconnectclient.ReconnectingClient.id) #"Call"%go (![#ptrT] (slice.elem_ref #ptrT (![#sliceT] (struct.field_ref #Clerk #"cls"%go (![#ptrT] "ck"))) (![#uint64T] "l")))) "$a0" "$a1" "$a2" "$a3") in
      do:  ("err" <-[#uint64T] "$r0");;;
      (if: (![#uint64T] "err") ≠ #(W64 0)
      then continue: #()
      else do:  #());;;
      let: "err2" := (mem.alloc (type.zero_val #err_gk.E)) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] (![#ptrT] "reply")) in
      (func_call #err_gk.Unmarshal) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("err2" <-[#err_gk.E] "$r0");;;
      do:  ((![#ptrT] "reply") <-[#sliceT] "$r1");;;
      (if: (![#err_gk.E] "err2") = err_gk.NotLeader
      then
        do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] (struct.field_ref #Clerk #"mu"%go (![#ptrT] "ck")))) #());;;
        (if: (![#uint64T] "l") = (![#uint64T] (struct.field_ref #Clerk #"leader"%go (![#ptrT] "ck")))
        then
          let: "$r0" := (((![#uint64T] (struct.field_ref #Clerk #"leader"%go (![#ptrT] "ck"))) + #(W64 1)) `rem` (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref #Clerk #"cls"%go (![#ptrT] "ck"))) in
          slice.len "$a0"))) in
          do:  ((struct.field_ref #Clerk #"leader"%go (![#ptrT] "ck")) <-[#uint64T] "$r0")
        else do:  #());;;
        do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref #Clerk #"mu"%go (![#ptrT] "ck")))) #());;;
        continue: #()
      else do:  #());;;
      (if: (![#err_gk.E] "err2") = err_gk.None
      then break: #()
      else do:  #()));;;
    let: "epoch" := (mem.alloc (type.zero_val #uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] (![#ptrT] "reply")) in
    (func_call #marshal.ReadInt) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("epoch" <-[#uint64T] "$r0");;;
    do:  ((![#ptrT] "reply") <-[#sliceT] "$r1");;;
    let: "config" := (mem.alloc (type.zero_val #config_gk.S)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] (![#ptrT] "reply")) in
    (func_call #config_gk.Unmarshal) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("config" <-[#config_gk.S] "$r0");;;
    do:  "$r1";;;
    return: (![#uint64T] "epoch", ![#config_gk.S] "config")).

(* go: client.go:68:18 *)
Definition Clerk__GetConfigⁱᵐᵖˡ : val :=
  λ: "ck" <>,
    exception_do (let: "ck" := (mem.alloc "ck") in
    let: "reply" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #sliceT)) in
    do:  ("reply" <-[#ptrT] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "i" := (mem.alloc (type.zero_val #uint64T)) in
      let: "$r0" := (((func_call #primitive.RandomUint64) #()) `rem` (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref #Clerk #"cls"%go (![#ptrT] "ck"))) in
      slice.len "$a0"))) in
      do:  ("i" <-[#uint64T] "$r0");;;
      let: "err" := (mem.alloc (type.zero_val #uint64T)) in
      let: "$r0" := (let: "$a0" := RPC_GETCONFIG in
      let: "$a1" := (slice.make2 #byteT #(W64 0)) in
      let: "$a2" := (![#ptrT] "reply") in
      let: "$a3" := #(W64 100) in
      (method_call #(ptrT.id reconnectclient.ReconnectingClient.id) #"Call"%go (![#ptrT] (slice.elem_ref #ptrT (![#sliceT] (struct.field_ref #Clerk #"cls"%go (![#ptrT] "ck"))) (![#uint64T] "i")))) "$a0" "$a1" "$a2" "$a3") in
      do:  ("err" <-[#uint64T] "$r0");;;
      (if: (![#uint64T] "err") = #(W64 0)
      then break: #()
      else do:  #());;;
      continue: #());;;
    let: "config" := (mem.alloc (type.zero_val #config_gk.S)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] (![#ptrT] "reply")) in
    (func_call #config_gk.Unmarshal) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("config" <-[#config_gk.S] "$r0");;;
    do:  "$r1";;;
    return: (![#config_gk.S] "config")).

(* go: client.go:82:18 *)
Definition Clerk__TryWriteConfigⁱᵐᵖˡ : val :=
  λ: "ck" "epoch" "config",
    exception_do (let: "ck" := (mem.alloc "ck") in
    let: "config" := (mem.alloc "config") in
    let: "epoch" := (mem.alloc "epoch") in
    let: "reply" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #sliceT)) in
    do:  ("reply" <-[#ptrT] "$r0");;;
    let: "args" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make3 #byteT #(W64 0) (#(W64 8) + (#(W64 8) * (let: "$a0" := (![#sliceT] (struct.field_ref #config_gk.S #"Addrs"%go "config")) in
    slice.len "$a0")))) in
    do:  ("args" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "args") in
    let: "$a1" := (![#uint64T] "epoch") in
    (func_call #marshal.WriteInt) "$a0" "$a1") in
    do:  ("args" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "args") in
    let: "$a1" := (![#config_gk.S] "config") in
    (func_call #config_gk.Marshal) "$a0" "$a1") in
    do:  ("args" <-[#sliceT] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] (struct.field_ref #Clerk #"mu"%go (![#ptrT] "ck")))) #());;;
      let: "l" := (mem.alloc (type.zero_val #uint64T)) in
      let: "$r0" := (![#uint64T] (struct.field_ref #Clerk #"leader"%go (![#ptrT] "ck"))) in
      do:  ("l" <-[#uint64T] "$r0");;;
      do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref #Clerk #"mu"%go (![#ptrT] "ck")))) #());;;
      let: "err" := (mem.alloc (type.zero_val #uint64T)) in
      let: "$r0" := (let: "$a0" := RPC_TRYWRITECONFIG in
      let: "$a1" := (![#sliceT] "args") in
      let: "$a2" := (![#ptrT] "reply") in
      let: "$a3" := #(W64 2000) in
      (method_call #(ptrT.id reconnectclient.ReconnectingClient.id) #"Call"%go (![#ptrT] (slice.elem_ref #ptrT (![#sliceT] (struct.field_ref #Clerk #"cls"%go (![#ptrT] "ck"))) (![#uint64T] "l")))) "$a0" "$a1" "$a2" "$a3") in
      do:  ("err" <-[#uint64T] "$r0");;;
      (if: (![#uint64T] "err") ≠ #(W64 0)
      then continue: #()
      else do:  #());;;
      let: "err2" := (mem.alloc (type.zero_val #err_gk.E)) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] (![#ptrT] "reply")) in
      (func_call #err_gk.Unmarshal) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("err2" <-[#err_gk.E] "$r0");;;
      do:  "$r1";;;
      (if: (![#err_gk.E] "err2") = err_gk.NotLeader
      then
        do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] (struct.field_ref #Clerk #"mu"%go (![#ptrT] "ck")))) #());;;
        (if: (![#uint64T] "l") = (![#uint64T] (struct.field_ref #Clerk #"leader"%go (![#ptrT] "ck")))
        then
          let: "$r0" := (((![#uint64T] (struct.field_ref #Clerk #"leader"%go (![#ptrT] "ck"))) + #(W64 1)) `rem` (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref #Clerk #"cls"%go (![#ptrT] "ck"))) in
          slice.len "$a0"))) in
          do:  ((struct.field_ref #Clerk #"leader"%go (![#ptrT] "ck")) <-[#uint64T] "$r0")
        else do:  #());;;
        do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref #Clerk #"mu"%go (![#ptrT] "ck")))) #());;;
        continue: #()
      else break: #()));;;
    let: "err" := (mem.alloc (type.zero_val #err_gk.E)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] (![#ptrT] "reply")) in
    (func_call #err_gk.Unmarshal) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("err" <-[#err_gk.E] "$r0");;;
    do:  "$r1";;;
    return: (![#err_gk.E] "err")).

(* returns e.None if the lease was granted for the given epoch, and a conservative
   guess on when the lease expires.

   go: client.go:118:18 *)
Definition Clerk__GetLeaseⁱᵐᵖˡ : val :=
  λ: "ck" "epoch",
    exception_do (let: "ck" := (mem.alloc "ck") in
    let: "epoch" := (mem.alloc "epoch") in
    let: "reply" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #sliceT)) in
    do:  ("reply" <-[#ptrT] "$r0");;;
    let: "args" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make3 #byteT #(W64 0) #(W64 8)) in
    do:  ("args" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "args") in
    let: "$a1" := (![#uint64T] "epoch") in
    (func_call #marshal.WriteInt) "$a0" "$a1") in
    do:  ("args" <-[#sliceT] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] (struct.field_ref #Clerk #"mu"%go (![#ptrT] "ck")))) #());;;
      let: "l" := (mem.alloc (type.zero_val #uint64T)) in
      let: "$r0" := (![#uint64T] (struct.field_ref #Clerk #"leader"%go (![#ptrT] "ck"))) in
      do:  ("l" <-[#uint64T] "$r0");;;
      do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref #Clerk #"mu"%go (![#ptrT] "ck")))) #());;;
      let: "err" := (mem.alloc (type.zero_val #uint64T)) in
      let: "$r0" := (let: "$a0" := RPC_GETLEASE in
      let: "$a1" := (![#sliceT] "args") in
      let: "$a2" := (![#ptrT] "reply") in
      let: "$a3" := #(W64 100) in
      (method_call #(ptrT.id reconnectclient.ReconnectingClient.id) #"Call"%go (![#ptrT] (slice.elem_ref #ptrT (![#sliceT] (struct.field_ref #Clerk #"cls"%go (![#ptrT] "ck"))) (![#uint64T] "l")))) "$a0" "$a1" "$a2" "$a3") in
      do:  ("err" <-[#uint64T] "$r0");;;
      (if: (![#uint64T] "err") ≠ #(W64 0)
      then continue: #()
      else do:  #());;;
      let: "err2" := (mem.alloc (type.zero_val #err_gk.E)) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] (![#ptrT] "reply")) in
      (func_call #err_gk.Unmarshal) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("err2" <-[#err_gk.E] "$r0");;;
      do:  "$r1";;;
      (if: (![#err_gk.E] "err2") = err_gk.NotLeader
      then
        do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] (struct.field_ref #Clerk #"mu"%go (![#ptrT] "ck")))) #());;;
        (if: (![#uint64T] "l") = (![#uint64T] (struct.field_ref #Clerk #"leader"%go (![#ptrT] "ck")))
        then
          let: "$r0" := (((![#uint64T] (struct.field_ref #Clerk #"leader"%go (![#ptrT] "ck"))) + #(W64 1)) `rem` (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref #Clerk #"cls"%go (![#ptrT] "ck"))) in
          slice.len "$a0"))) in
          do:  ((struct.field_ref #Clerk #"leader"%go (![#ptrT] "ck")) <-[#uint64T] "$r0")
        else do:  #());;;
        do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref #Clerk #"mu"%go (![#ptrT] "ck")))) #());;;
        continue: #()
      else break: #()));;;
    let: "enc" := (mem.alloc (type.zero_val #sliceT)) in
    let: "err2" := (mem.alloc (type.zero_val #err_gk.E)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] (![#ptrT] "reply")) in
    (func_call #err_gk.Unmarshal) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("err2" <-[#err_gk.E] "$r0");;;
    do:  ("enc" <-[#sliceT] "$r1");;;
    let: "leaseExpiration" := (mem.alloc (type.zero_val #uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "enc") in
    (func_call #marshal.ReadInt) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("leaseExpiration" <-[#uint64T] "$r0");;;
    do:  "$r1";;;
    return: (![#err_gk.E] "err2", ![#uint64T] "leaseExpiration")).

(* 1 second *)
Definition LeaseInterval : expr := #(W64 1000000000).

Definition state : go_type := structT [
  "epoch" :: uint64T;
  "reservedEpoch" :: uint64T;
  "leaseExpiration" :: uint64T;
  "wantLeaseToExpire" :: boolT;
  "config" :: config_gk.S
].

Definition encodeState : go_string := "github.com/mit-pdos/gokv/vrsm/configservice.encodeState"%go.

(* go: server.go:26:6 *)
Definition encodeStateⁱᵐᵖˡ : val :=
  λ: "st",
    exception_do (let: "st" := (mem.alloc "st") in
    let: "e" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := #slice.nil in
    let: "$a1" := (![#uint64T] (struct.field_ref #state #"epoch"%go (![#ptrT] "st"))) in
    (func_call #marshal.WriteInt) "$a0" "$a1") in
    do:  ("e" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "e") in
    let: "$a1" := (![#uint64T] (struct.field_ref #state #"reservedEpoch"%go (![#ptrT] "st"))) in
    (func_call #marshal.WriteInt) "$a0" "$a1") in
    do:  ("e" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "e") in
    let: "$a1" := (![#uint64T] (struct.field_ref #state #"leaseExpiration"%go (![#ptrT] "st"))) in
    (func_call #marshal.WriteInt) "$a0" "$a1") in
    do:  ("e" <-[#sliceT] "$r0");;;
    (if: ![#boolT] (struct.field_ref #state #"wantLeaseToExpire"%go (![#ptrT] "st"))
    then
      let: "$r0" := (let: "$a0" := (![#sliceT] "e") in
      let: "$a1" := #(W64 1) in
      (func_call #marshal.WriteInt) "$a0" "$a1") in
      do:  ("e" <-[#sliceT] "$r0")
    else
      let: "$r0" := (let: "$a0" := (![#sliceT] "e") in
      let: "$a1" := #(W64 0) in
      (func_call #marshal.WriteInt) "$a0" "$a1") in
      do:  ("e" <-[#sliceT] "$r0"));;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "e") in
    let: "$a1" := (![#config_gk.S] (struct.field_ref #state #"config"%go (![#ptrT] "st"))) in
    (func_call #config_gk.Marshal) "$a0" "$a1") in
    do:  ("e" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "e")).

Definition decodeState : go_string := "github.com/mit-pdos/gokv/vrsm/configservice.decodeState"%go.

(* go: server.go:40:6 *)
Definition decodeStateⁱᵐᵖˡ : val :=
  λ: "e",
    exception_do (let: "e" := (mem.alloc "e") in
    let: "st" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #state)) in
    do:  ("st" <-[#ptrT] "$r0");;;
    let: "e2" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "e") in
    do:  ("e2" <-[#sliceT] "$r0");;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "e2") in
    (func_call #marshal.ReadInt) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ((struct.field_ref #state #"epoch"%go (![#ptrT] "st")) <-[#uint64T] "$r0");;;
    do:  ("e2" <-[#sliceT] "$r1");;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "e2") in
    (func_call #marshal.ReadInt) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ((struct.field_ref #state #"reservedEpoch"%go (![#ptrT] "st")) <-[#uint64T] "$r0");;;
    do:  ("e2" <-[#sliceT] "$r1");;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "e2") in
    (func_call #marshal.ReadInt) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ((struct.field_ref #state #"leaseExpiration"%go (![#ptrT] "st")) <-[#uint64T] "$r0");;;
    do:  ("e2" <-[#sliceT] "$r1");;;
    let: "wantExp" := (mem.alloc (type.zero_val #uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "e2") in
    (func_call #marshal.ReadInt) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("wantExp" <-[#uint64T] "$r0");;;
    do:  ("e2" <-[#sliceT] "$r1");;;
    let: "$r0" := ((![#uint64T] "wantExp") = #(W64 1)) in
    do:  ((struct.field_ref #state #"wantLeaseToExpire"%go (![#ptrT] "st")) <-[#boolT] "$r0");;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "e2") in
    (func_call #config_gk.Unmarshal) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ((struct.field_ref #state #"config"%go (![#ptrT] "st")) <-[#config_gk.S] "$r0");;;
    do:  "$r1";;;
    return: (![#ptrT] "st")).

Definition Server : go_type := structT [
  "s" :: ptrT
].

(* go: server.go:57:18 *)
Definition Server__tryAcquireⁱᵐᵖˡ : val :=
  λ: "s" <>,
    exception_do (let: "s" := (mem.alloc "s") in
    let: "relF" := (mem.alloc (type.zero_val #funcT)) in
    let: "e" := (mem.alloc (type.zero_val #ptrT)) in
    let: "err" := (mem.alloc (type.zero_val #error_gk.E)) in
    let: (("$ret0", "$ret1"), "$ret2") := ((method_call #(ptrT.id paxos.Server.id) #"TryAcquire"%go (![#ptrT] (struct.field_ref #Server #"s"%go (![#ptrT] "s")))) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("err" <-[#error_gk.E] "$r0");;;
    do:  ("e" <-[#ptrT] "$r1");;;
    do:  ("relF" <-[#funcT] "$r2");;;
    (if: (![#error_gk.E] "err") ≠ #(W32 0)
    then
      let: "p" := (mem.alloc (type.zero_val #ptrT)) in
      return: (#false, ![#ptrT] "p", #func.nil)
    else do:  #());;;
    let: "st" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] (![#ptrT] "e")) in
    (func_call #decodeState) "$a0") in
    do:  ("st" <-[#ptrT] "$r0");;;
    let: "releaseFn" := (mem.alloc (type.zero_val #funcT)) in
    let: "$r0" := (λ: <>,
      exception_do (let: "$r0" := (let: "$a0" := (![#ptrT] "st") in
      (func_call #encodeState) "$a0") in
      do:  ((![#ptrT] "e") <-[#sliceT] "$r0");;;
      return: (((![#funcT] "relF") #()) = #(W32 0)))
      ) in
    do:  ("releaseFn" <-[#funcT] "$r0");;;
    return: (#true, ![#ptrT] "st", ![#funcT] "releaseFn")).

(* go: server.go:71:18 *)
Definition Server__ReserveEpochAndGetConfigⁱᵐᵖˡ : val :=
  λ: "s" "args" "reply",
    exception_do (let: "s" := (mem.alloc "s") in
    let: "reply" := (mem.alloc "reply") in
    let: "args" := (mem.alloc "args") in
    let: "$r0" := (let: "$a0" := (slice.make2 #byteT #(W64 0)) in
    let: "$a1" := err_gk.NotLeader in
    (func_call #err_gk.Marshal) "$a0" "$a1") in
    do:  ((![#ptrT] "reply") <-[#sliceT] "$r0");;;
    let: "tryReleaseFn" := (mem.alloc (type.zero_val #funcT)) in
    let: "st" := (mem.alloc (type.zero_val #ptrT)) in
    let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: (("$ret0", "$ret1"), "$ret2") := ((method_call #(ptrT.id Server.id) #"tryAcquire"%go (![#ptrT] "s")) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("ok" <-[#boolT] "$r0");;;
    do:  ("st" <-[#ptrT] "$r1");;;
    do:  ("tryReleaseFn" <-[#funcT] "$r2");;;
    (if: (~ (![#boolT] "ok"))
    then return: (#())
    else do:  #());;;
    let: "$r0" := (let: "$a0" := (![#uint64T] (struct.field_ref #state #"reservedEpoch"%go (![#ptrT] "st"))) in
    let: "$a1" := #(W64 1) in
    (func_call #std.SumAssumeNoOverflow) "$a0" "$a1") in
    do:  ((struct.field_ref #state #"reservedEpoch"%go (![#ptrT] "st")) <-[#uint64T] "$r0");;;
    let: "config" := (mem.alloc (type.zero_val #config_gk.S)) in
    let: "$r0" := (![#config_gk.S] (struct.field_ref #state #"config"%go (![#ptrT] "st"))) in
    do:  ("config" <-[#config_gk.S] "$r0");;;
    let: "reservedEpoch" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (![#uint64T] (struct.field_ref #state #"reservedEpoch"%go (![#ptrT] "st"))) in
    do:  ("reservedEpoch" <-[#uint64T] "$r0");;;
    (if: (~ ((![#funcT] "tryReleaseFn") #()))
    then return: (#())
    else do:  #());;;
    let: "$r0" := (slice.make3 #byteT #(W64 0) (#(W64 (8 + 8)) + (#(W64 8) * (let: "$a0" := (![#sliceT] (struct.field_ref #config_gk.S #"Addrs"%go "config")) in
    slice.len "$a0")))) in
    do:  ((![#ptrT] "reply") <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] (![#ptrT] "reply")) in
    let: "$a1" := err_gk.None in
    (func_call #err_gk.Marshal) "$a0" "$a1") in
    do:  ((![#ptrT] "reply") <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] (![#ptrT] "reply")) in
    let: "$a1" := (![#uint64T] "reservedEpoch") in
    (func_call #marshal.WriteInt) "$a0" "$a1") in
    do:  ((![#ptrT] "reply") <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] (![#ptrT] "reply")) in
    let: "$a1" := (![#config_gk.S] "config") in
    (func_call #config_gk.Marshal) "$a0" "$a1") in
    do:  ((![#ptrT] "reply") <-[#sliceT] "$r0");;;
    return: #()).

(* go: server.go:89:18 *)
Definition Server__GetConfigⁱᵐᵖˡ : val :=
  λ: "s" "args" "reply",
    exception_do (let: "s" := (mem.alloc "s") in
    let: "reply" := (mem.alloc "reply") in
    let: "args" := (mem.alloc "args") in
    let: "st" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := ((method_call #(ptrT.id paxos.Server.id) #"WeakRead"%go (![#ptrT] (struct.field_ref #Server #"s"%go (![#ptrT] "s")))) #()) in
    (func_call #decodeState) "$a0") in
    do:  ("st" <-[#ptrT] "$r0");;;
    let: "$r0" := (let: "$a0" := (slice.make2 #byteT #(W64 0)) in
    let: "$a1" := (![#config_gk.S] (struct.field_ref #state #"config"%go (![#ptrT] "st"))) in
    (func_call #config_gk.Marshal) "$a0" "$a1") in
    do:  ((![#ptrT] "reply") <-[#sliceT] "$r0");;;
    return: #()).

(* go: server.go:94:18 *)
Definition Server__TryWriteConfigⁱᵐᵖˡ : val :=
  λ: "s" "args" "reply",
    exception_do (let: "s" := (mem.alloc "s") in
    let: "reply" := (mem.alloc "reply") in
    let: "args" := (mem.alloc "args") in
    let: "$r0" := (let: "$a0" := (slice.make2 #byteT #(W64 0)) in
    let: "$a1" := err_gk.NotLeader in
    (func_call #err_gk.Marshal) "$a0" "$a1") in
    do:  ((![#ptrT] "reply") <-[#sliceT] "$r0");;;
    let: "enc" := (mem.alloc (type.zero_val #sliceT)) in
    let: "epoch" := (mem.alloc (type.zero_val #uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "args") in
    (func_call #marshal.ReadInt) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("epoch" <-[#uint64T] "$r0");;;
    do:  ("enc" <-[#sliceT] "$r1");;;
    let: "config" := (mem.alloc (type.zero_val #config_gk.S)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "enc") in
    (func_call #config_gk.Unmarshal) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("config" <-[#config_gk.S] "$r0");;;
    do:  "$r1";;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "tryReleaseFn" := (mem.alloc (type.zero_val #funcT)) in
      let: "st" := (mem.alloc (type.zero_val #ptrT)) in
      let: "ok" := (mem.alloc (type.zero_val #boolT)) in
      let: (("$ret0", "$ret1"), "$ret2") := ((method_call #(ptrT.id Server.id) #"tryAcquire"%go (![#ptrT] "s")) #()) in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      let: "$r2" := "$ret2" in
      do:  ("ok" <-[#boolT] "$r0");;;
      do:  ("st" <-[#ptrT] "$r1");;;
      do:  ("tryReleaseFn" <-[#funcT] "$r2");;;
      (if: (~ (![#boolT] "ok"))
      then break: #()
      else do:  #());;;
      (if: (![#uint64T] "epoch") < (![#uint64T] (struct.field_ref #state #"reservedEpoch"%go (![#ptrT] "st")))
      then
        (if: (~ ((![#funcT] "tryReleaseFn") #()))
        then break: #()
        else do:  #());;;
        let: "$r0" := (let: "$a0" := (slice.make2 #byteT #(W64 0)) in
        let: "$a1" := err_gk.Stale in
        (func_call #err_gk.Marshal) "$a0" "$a1") in
        do:  ((![#ptrT] "reply") <-[#sliceT] "$r0");;;
        do:  (let: "$a0" := #"Stale: %d < %d"%go in
        let: "$a1" := ((let: "$sl0" := (interface.make #uint64T.id (![#uint64T] "epoch")) in
        let: "$sl1" := (interface.make #uint64T.id (![#uint64T] (struct.field_ref #state #"reservedEpoch"%go (![#ptrT] "st")))) in
        slice.literal #interfaceT ["$sl0"; "$sl1"])) in
        (func_call #log.Printf) "$a0" "$a1");;;
        break: #()
      else
        (if: (![#uint64T] "epoch") > (![#uint64T] (struct.field_ref #state #"epoch"%go (![#ptrT] "st")))
        then
          let: "l" := (mem.alloc (type.zero_val #uint64T)) in
          let: ("$ret0", "$ret1") := ((func_call #grove_ffi.GetTimeRange) #()) in
          let: "$r0" := "$ret0" in
          let: "$r1" := "$ret1" in
          do:  ("l" <-[#uint64T] "$r0");;;
          do:  "$r1";;;
          (if: (![#uint64T] "l") ≥ (![#uint64T] (struct.field_ref #state #"leaseExpiration"%go (![#ptrT] "st")))
          then
            let: "$r0" := #false in
            do:  ((struct.field_ref #state #"wantLeaseToExpire"%go (![#ptrT] "st")) <-[#boolT] "$r0");;;
            let: "$r0" := (![#uint64T] "epoch") in
            do:  ((struct.field_ref #state #"epoch"%go (![#ptrT] "st")) <-[#uint64T] "$r0");;;
            let: "$r0" := (![#config_gk.S] "config") in
            do:  ((struct.field_ref #state #"config"%go (![#ptrT] "st")) <-[#config_gk.S] "$r0");;;
            (if: (~ ((![#funcT] "tryReleaseFn") #()))
            then break: #()
            else do:  #());;;
            do:  (let: "$a0" := ((let: "$sl0" := (interface.make #stringT.id #"New config is:"%go) in
            let: "$sl1" := (interface.make #config_gk.S.id (![#config_gk.S] (struct.field_ref #state #"config"%go (![#ptrT] "st")))) in
            slice.literal #interfaceT ["$sl0"; "$sl1"])) in
            (func_call #log.Println) "$a0");;;
            let: "$r0" := (let: "$a0" := (slice.make2 #byteT #(W64 0)) in
            let: "$a1" := err_gk.None in
            (func_call #err_gk.Marshal) "$a0" "$a1") in
            do:  ((![#ptrT] "reply") <-[#sliceT] "$r0");;;
            break: #()
          else
            let: "$r0" := #true in
            do:  ((struct.field_ref #state #"wantLeaseToExpire"%go (![#ptrT] "st")) <-[#boolT] "$r0");;;
            let: "timeToSleep" := (mem.alloc (type.zero_val #uint64T)) in
            let: "$r0" := ((![#uint64T] (struct.field_ref #state #"leaseExpiration"%go (![#ptrT] "st"))) - (![#uint64T] "l")) in
            do:  ("timeToSleep" <-[#uint64T] "$r0");;;
            (if: (~ ((![#funcT] "tryReleaseFn") #()))
            then break: #()
            else do:  #());;;
            do:  (let: "$a0" := (![#uint64T] "timeToSleep") in
            (func_call #primitive.Sleep) "$a0");;;
            continue: #())
        else
          let: "$r0" := (![#config_gk.S] "config") in
          do:  ((struct.field_ref #state #"config"%go (![#ptrT] "st")) <-[#config_gk.S] "$r0");;;
          (if: (~ ((![#funcT] "tryReleaseFn") #()))
          then break: #()
          else do:  #());;;
          let: "$r0" := (let: "$a0" := (slice.make2 #byteT #(W64 0)) in
          let: "$a1" := err_gk.None in
          (func_call #err_gk.Marshal) "$a0" "$a1") in
          do:  ((![#ptrT] "reply") <-[#sliceT] "$r0");;;
          break: #())));;;
    return: #()).

(* go: server.go:146:18 *)
Definition Server__GetLeaseⁱᵐᵖˡ : val :=
  λ: "s" "args" "reply",
    exception_do (let: "s" := (mem.alloc "s") in
    let: "reply" := (mem.alloc "reply") in
    let: "args" := (mem.alloc "args") in
    let: "$r0" := (let: "$a0" := (slice.make2 #byteT #(W64 0)) in
    let: "$a1" := err_gk.NotLeader in
    (func_call #err_gk.Marshal) "$a0" "$a1") in
    do:  ((![#ptrT] "reply") <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] (![#ptrT] "reply")) in
    let: "$a1" := #(W64 0) in
    (func_call #marshal.WriteInt) "$a0" "$a1") in
    do:  ((![#ptrT] "reply") <-[#sliceT] "$r0");;;
    let: "epoch" := (mem.alloc (type.zero_val #uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "args") in
    (func_call #marshal.ReadInt) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("epoch" <-[#uint64T] "$r0");;;
    do:  "$r1";;;
    let: "tryReleaseFn" := (mem.alloc (type.zero_val #funcT)) in
    let: "st" := (mem.alloc (type.zero_val #ptrT)) in
    let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: (("$ret0", "$ret1"), "$ret2") := ((method_call #(ptrT.id Server.id) #"tryAcquire"%go (![#ptrT] "s")) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("ok" <-[#boolT] "$r0");;;
    do:  ("st" <-[#ptrT] "$r1");;;
    do:  ("tryReleaseFn" <-[#funcT] "$r2");;;
    (if: (~ (![#boolT] "ok"))
    then return: (#())
    else do:  #());;;
    (if: ((![#uint64T] (struct.field_ref #state #"epoch"%go (![#ptrT] "st"))) ≠ (![#uint64T] "epoch")) || (![#boolT] (struct.field_ref #state #"wantLeaseToExpire"%go (![#ptrT] "st")))
    then
      do:  (let: "$a0" := ((let: "$sl0" := (interface.make #stringT.id #"Rejected lease request"%go) in
      let: "$sl1" := (interface.make #uint64T.id (![#uint64T] "epoch")) in
      let: "$sl2" := (interface.make #uint64T.id (![#uint64T] (struct.field_ref #state #"epoch"%go (![#ptrT] "st")))) in
      let: "$sl3" := (interface.make #boolT.id (![#boolT] (struct.field_ref #state #"wantLeaseToExpire"%go (![#ptrT] "st")))) in
      slice.literal #interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"])) in
      (func_call #log.Println) "$a0");;;
      (if: (~ ((![#funcT] "tryReleaseFn") #()))
      then return: (#())
      else do:  #());;;
      let: "$r0" := (let: "$a0" := (slice.make2 #byteT #(W64 0)) in
      let: "$a1" := err_gk.Stale in
      (func_call #err_gk.Marshal) "$a0" "$a1") in
      do:  ((![#ptrT] "reply") <-[#sliceT] "$r0");;;
      let: "$r0" := (let: "$a0" := (![#sliceT] (![#ptrT] "reply")) in
      let: "$a1" := #(W64 0) in
      (func_call #marshal.WriteInt) "$a0" "$a1") in
      do:  ((![#ptrT] "reply") <-[#sliceT] "$r0");;;
      return: (#())
    else do:  #());;;
    let: "l" := (mem.alloc (type.zero_val #uint64T)) in
    let: ("$ret0", "$ret1") := ((func_call #grove_ffi.GetTimeRange) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("l" <-[#uint64T] "$r0");;;
    do:  "$r1";;;
    let: "newLeaseExpiration" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := ((![#uint64T] "l") + LeaseInterval) in
    do:  ("newLeaseExpiration" <-[#uint64T] "$r0");;;
    (if: (![#uint64T] "newLeaseExpiration") > (![#uint64T] (struct.field_ref #state #"leaseExpiration"%go (![#ptrT] "st")))
    then
      let: "$r0" := (![#uint64T] "newLeaseExpiration") in
      do:  ((struct.field_ref #state #"leaseExpiration"%go (![#ptrT] "st")) <-[#uint64T] "$r0")
    else do:  #());;;
    (if: (~ ((![#funcT] "tryReleaseFn") #()))
    then return: (#())
    else do:  #());;;
    let: "$r0" := (let: "$a0" := (slice.make2 #byteT #(W64 0)) in
    let: "$a1" := err_gk.None in
    (func_call #err_gk.Marshal) "$a0" "$a1") in
    do:  ((![#ptrT] "reply") <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] (![#ptrT] "reply")) in
    let: "$a1" := (![#uint64T] "newLeaseExpiration") in
    (func_call #marshal.WriteInt) "$a0" "$a1") in
    do:  ((![#ptrT] "reply") <-[#sliceT] "$r0");;;
    return: #()).

Definition makeServer : go_string := "github.com/mit-pdos/gokv/vrsm/configservice.makeServer"%go.

(* go: server.go:178:6 *)
Definition makeServerⁱᵐᵖˡ : val :=
  λ: "fname" "paxosMe" "hosts" "initconfig",
    exception_do (let: "initconfig" := (mem.alloc "initconfig") in
    let: "hosts" := (mem.alloc "hosts") in
    let: "paxosMe" := (mem.alloc "paxosMe") in
    let: "fname" := (mem.alloc "fname") in
    let: "s" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #Server)) in
    do:  ("s" <-[#ptrT] "$r0");;;
    let: "initEnc" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (mem.alloc (let: "$config" := (let: "$Addrs" := (![#sliceT] "initconfig") in
    struct.make #config_gk.S [{
      "Addrs" ::= "$Addrs"
    }]) in
    struct.make #state [{
      "epoch" ::= type.zero_val #uint64T;
      "reservedEpoch" ::= type.zero_val #uint64T;
      "leaseExpiration" ::= type.zero_val #uint64T;
      "wantLeaseToExpire" ::= type.zero_val #boolT;
      "config" ::= "$config"
    }])) in
    (func_call #encodeState) "$a0") in
    do:  ("initEnc" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#stringT] "fname") in
    let: "$a1" := (![#sliceT] "initEnc") in
    let: "$a2" := (![#uint64T] "paxosMe") in
    let: "$a3" := (![#sliceT] "hosts") in
    (func_call #paxos.StartServer) "$a0" "$a1" "$a2" "$a3") in
    do:  ((struct.field_ref #Server #"s"%go (![#ptrT] "s")) <-[#ptrT] "$r0");;;
    return: (![#ptrT] "s")).

Definition StartServer : go_string := "github.com/mit-pdos/gokv/vrsm/configservice.StartServer"%go.

(* go: server.go:188:6 *)
Definition StartServerⁱᵐᵖˡ : val :=
  λ: "fname" "me" "paxosMe" "hosts" "initconfig",
    exception_do (let: "initconfig" := (mem.alloc "initconfig") in
    let: "hosts" := (mem.alloc "hosts") in
    let: "paxosMe" := (mem.alloc "paxosMe") in
    let: "me" := (mem.alloc "me") in
    let: "fname" := (mem.alloc "fname") in
    let: "s" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := (![#stringT] "fname") in
    let: "$a1" := (![#uint64T] "paxosMe") in
    let: "$a2" := (![#sliceT] "hosts") in
    let: "$a3" := (![#sliceT] "initconfig") in
    (func_call #makeServer) "$a0" "$a1" "$a2" "$a3") in
    do:  ("s" <-[#ptrT] "$r0");;;
    let: "handlers" := (mem.alloc (type.zero_val (type.mapT #uint64T #funcT))) in
    let: "$r0" := (map.make #uint64T #funcT) in
    do:  ("handlers" <-[type.mapT #uint64T #funcT] "$r0");;;
    let: "$r0" := (method_call #(ptrT.id Server.id) #"ReserveEpochAndGetConfig"%go (![#ptrT] "s")) in
    do:  (map.insert (![type.mapT #uint64T #funcT] "handlers") RPC_RESERVEEPOCH "$r0");;;
    let: "$r0" := (method_call #(ptrT.id Server.id) #"GetConfig"%go (![#ptrT] "s")) in
    do:  (map.insert (![type.mapT #uint64T #funcT] "handlers") RPC_GETCONFIG "$r0");;;
    let: "$r0" := (method_call #(ptrT.id Server.id) #"TryWriteConfig"%go (![#ptrT] "s")) in
    do:  (map.insert (![type.mapT #uint64T #funcT] "handlers") RPC_TRYWRITECONFIG "$r0");;;
    let: "$r0" := (method_call #(ptrT.id Server.id) #"GetLease"%go (![#ptrT] "s")) in
    do:  (map.insert (![type.mapT #uint64T #funcT] "handlers") RPC_GETLEASE "$r0");;;
    let: "rs" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := (![type.mapT #uint64T #funcT] "handlers") in
    (func_call #urpc.MakeServer) "$a0") in
    do:  ("rs" <-[#ptrT] "$r0");;;
    do:  (let: "$a0" := (![#uint64T] "me") in
    (method_call #(ptrT.id urpc.Server.id) #"Serve"%go (![#ptrT] "rs")) "$a0");;;
    return: (![#ptrT] "s")).

Definition vars' : list (go_string * go_type) := [].

Definition functions' : list (go_string * val) := [(MakeClerk, MakeClerkⁱᵐᵖˡ); (encodeState, encodeStateⁱᵐᵖˡ); (decodeState, decodeStateⁱᵐᵖˡ); (makeServer, makeServerⁱᵐᵖˡ); (StartServer, StartServerⁱᵐᵖˡ)].

Definition msets' : list (go_string * (list (go_string * val))) := [(Clerk.id, []); (ptrT.id Clerk.id, [("GetConfig"%go, Clerk__GetConfigⁱᵐᵖˡ); ("GetLease"%go, Clerk__GetLeaseⁱᵐᵖˡ); ("ReserveEpochAndGetConfig"%go, Clerk__ReserveEpochAndGetConfigⁱᵐᵖˡ); ("TryWriteConfig"%go, Clerk__TryWriteConfigⁱᵐᵖˡ)]); (state.id, []); (ptrT.id state.id, []); (Server.id, []); (ptrT.id Server.id, [("GetConfig"%go, Server__GetConfigⁱᵐᵖˡ); ("GetLease"%go, Server__GetLeaseⁱᵐᵖˡ); ("ReserveEpochAndGetConfig"%go, Server__ReserveEpochAndGetConfigⁱᵐᵖˡ); ("TryWriteConfig"%go, Server__TryWriteConfigⁱᵐᵖˡ); ("tryAcquire"%go, Server__tryAcquireⁱᵐᵖˡ)])].

#[global] Instance info' : PkgInfo configservice.configservice :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [code.sync.sync; code.github_com.goose_lang.primitive.primitive; code.github_com.mit_pdos.gokv.grove_ffi.grove_ffi; code.github_com.mit_pdos.gokv.reconnectclient.reconnectclient; code.github_com.mit_pdos.gokv.vrsm.configservice.config_gk.config_gk; code.github_com.mit_pdos.gokv.vrsm.replica.err_gk.err_gk; code.github_com.tchajed.marshal.marshal; code.log.log; code.github_com.goose_lang.std.std; code.github_com.mit_pdos.gokv.urpc.urpc; code.github_com.mit_pdos.gokv.vrsm.paxos.paxos];
  |}.

Definition initialize' : val :=
  λ: <>,
    package.init #configservice.configservice (λ: <>,
      exception_do (do:  (paxos.initialize' #());;;
      do:  (urpc.initialize' #());;;
      do:  (std.initialize' #());;;
      do:  (log.initialize' #());;;
      do:  (marshal.initialize' #());;;
      do:  (err_gk.initialize' #());;;
      do:  (config_gk.initialize' #());;;
      do:  (reconnectclient.initialize' #());;;
      do:  (grove_ffi.initialize' #());;;
      do:  (primitive.initialize' #());;;
      do:  (sync.initialize' #());;;
      do:  (package.alloc configservice.configservice #()))
      ).

End code.
End configservice.
