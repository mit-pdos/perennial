(* autogenerated from github.com/mit-pdos/gokv/vrsm/configservice *)
Require Export New.code.github_com.goose_lang.primitive.
Require Export New.code.github_com.goose_lang.std.
Require Export New.code.github_com.mit_pdos.gokv.grove_ffi.
Require Export New.code.github_com.mit_pdos.gokv.reconnectclient.
Require Export New.code.github_com.mit_pdos.gokv.urpc.
Require Export New.code.github_com.mit_pdos.gokv.vrsm.e.
Require Export New.code.github_com.mit_pdos.gokv.vrsm.paxos.
Require Export New.code.github_com.tchajed.marshal.
Require Export New.code.log.
Require Export New.code.sync.

From New.golang Require Import defn.
Definition configservice : go_string := "github.com/mit-pdos/gokv/vrsm/configservice".

From New Require Import grove_prelude.
Module configservice.

Module Clerk. Definition id : go_string := "github.com/mit-pdos/gokv/vrsm/configservice.Clerk"%go. End Clerk.
Module state. Definition id : go_string := "github.com/mit-pdos/gokv/vrsm/configservice.state"%go. End state.
Module Server. Definition id : go_string := "github.com/mit-pdos/gokv/vrsm/configservice.Server"%go. End Server.

Section code.


Definition EncodeConfig : go_string := "github.com/mit-pdos/gokv/vrsm/configservice.EncodeConfig"%go.

(* go: 0_marshal.go:8:6 *)
Definition EncodeConfigⁱᵐᵖˡ : val :=
  λ: "config",
    exception_do (let: "config" := (mem.alloc "config") in
    let: "enc" := (mem.alloc (type.zero_val sliceT)) in
    let: "$r0" := (slice.make3 byteT #(W64 0) (#(W64 8) + (#(W64 8) * (s_to_w64 (let: "$a0" := (![sliceT] "config") in
    slice.len "$a0"))))) in
    do:  ("enc" <-[sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT] "enc") in
    let: "$a1" := (s_to_w64 (let: "$a0" := (![sliceT] "config") in
    slice.len "$a0")) in
    (func_call #marshal.WriteInt) "$a0" "$a1") in
    do:  ("enc" <-[sliceT] "$r0");;;
    let: "$range" := (![sliceT] "config") in
    (let: "h" := (mem.alloc (type.zero_val uint64T)) in
    slice.for_range uint64T "$range" (λ: "$key" "$value",
      do:  ("h" <-[uint64T] "$value");;;
      do:  "$key";;;
      let: "$r0" := (let: "$a0" := (![sliceT] "enc") in
      let: "$a1" := (![uint64T] "h") in
      (func_call #marshal.WriteInt) "$a0" "$a1") in
      do:  ("enc" <-[sliceT] "$r0")));;;
    return: (![sliceT] "enc")).

Definition DecodeConfig : go_string := "github.com/mit-pdos/gokv/vrsm/configservice.DecodeConfig"%go.

(* go: 0_marshal.go:17:6 *)
Definition DecodeConfigⁱᵐᵖˡ : val :=
  λ: "enc_config",
    exception_do (let: "enc_config" := (mem.alloc "enc_config") in
    let: "enc" := (mem.alloc (type.zero_val sliceT)) in
    let: "$r0" := (![sliceT] "enc_config") in
    do:  ("enc" <-[sliceT] "$r0");;;
    let: "configLen" := (mem.alloc (type.zero_val uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![sliceT] "enc") in
    (func_call #marshal.ReadInt) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("configLen" <-[uint64T] "$r0");;;
    do:  ("enc" <-[sliceT] "$r1");;;
    let: "config" := (mem.alloc (type.zero_val sliceT)) in
    let: "$r0" := (slice.make2 uint64T (![uint64T] "configLen")) in
    do:  ("config" <-[sliceT] "$r0");;;
    let: "i" := (mem.alloc (type.zero_val uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[uint64T] "$r0");;;
    (for: (λ: <>, (![uint64T] "i") < (s_to_w64 (let: "$a0" := (![sliceT] "config") in
    slice.len "$a0"))); (λ: <>, #()) := λ: <>,
      let: ("$ret0", "$ret1") := (let: "$a0" := (![sliceT] "enc") in
      (func_call #marshal.ReadInt) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ((slice.elem_ref uint64T (![sliceT] "config") (![uint64T] "i")) <-[uint64T] "$r0");;;
      do:  ("enc" <-[sliceT] "$r1");;;
      do:  ("i" <-[uint64T] ((![uint64T] "i") + #(W64 1))));;;
    return: (![sliceT] "config")).

Definition Clerk : go_type := structT [
  "mu" :: ptrT;
  "cls" :: sliceT;
  "leader" :: uint64T
].
#[global] Typeclasses Opaque Clerk.
#[global] Opaque Clerk.

Definition RPC_RESERVEEPOCH : val := #(W64 0).

Definition RPC_GETCONFIG : val := #(W64 1).

Definition RPC_TRYWRITECONFIG : val := #(W64 2).

Definition RPC_GETLEASE : val := #(W64 3).

Definition MakeClerk : go_string := "github.com/mit-pdos/gokv/vrsm/configservice.MakeClerk"%go.

(* go: client.go:26:6 *)
Definition MakeClerkⁱᵐᵖˡ : val :=
  λ: "hosts",
    exception_do (let: "hosts" := (mem.alloc "hosts") in
    let: "cls" := (mem.alloc (type.zero_val sliceT)) in
    let: "$r0" := (slice.make2 ptrT #(W64 0)) in
    do:  ("cls" <-[sliceT] "$r0");;;
    let: "$range" := (![sliceT] "hosts") in
    (let: "host" := (mem.alloc (type.zero_val uint64T)) in
    slice.for_range uint64T "$range" (λ: "$key" "$value",
      do:  ("host" <-[uint64T] "$value");;;
      do:  "$key";;;
      let: "$r0" := (let: "$a0" := (![sliceT] "cls") in
      let: "$a1" := ((let: "$sl0" := (let: "$a0" := (![uint64T] "host") in
      (func_call #reconnectclient.MakeReconnectingClient) "$a0") in
      slice.literal ptrT ["$sl0"])) in
      (slice.append ptrT) "$a0" "$a1") in
      do:  ("cls" <-[sliceT] "$r0")));;;
    return: (mem.alloc (let: "$cls" := (![sliceT] "cls") in
     let: "$mu" := (mem.alloc (type.zero_val sync.Mutex)) in
     struct.make Clerk [{
       "mu" ::= "$mu";
       "cls" ::= "$cls";
       "leader" ::= type.zero_val uint64T
     }]))).

(* go: client.go:34:18 *)
Definition Clerk__ReserveEpochAndGetConfigⁱᵐᵖˡ : val :=
  λ: "ck" <>,
    exception_do (let: "ck" := (mem.alloc "ck") in
    let: "reply" := (mem.alloc (type.zero_val ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val sliceT)) in
    do:  ("reply" <-[ptrT] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![ptrT] (struct.field_ref ptrT #"mu"%go (![ptrT] "ck")))) #());;;
      let: "l" := (mem.alloc (type.zero_val uint64T)) in
      let: "$r0" := (![uint64T] (struct.field_ref ptrT #"leader"%go (![ptrT] "ck"))) in
      do:  ("l" <-[uint64T] "$r0");;;
      do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![ptrT] (struct.field_ref ptrT #"mu"%go (![ptrT] "ck")))) #());;;
      let: "err" := (mem.alloc (type.zero_val uint64T)) in
      let: "$r0" := (let: "$a0" := RPC_RESERVEEPOCH in
      let: "$a1" := (slice.make2 byteT #(W64 0)) in
      let: "$a2" := (![ptrT] "reply") in
      let: "$a3" := #(W64 100) in
      (method_call #(ptrT.id reconnectclient.ReconnectingClient.id) #"Call"%go (![ptrT] (slice.elem_ref ptrT (![sliceT] (struct.field_ref ptrT #"cls"%go (![ptrT] "ck"))) (![uint64T] "l")))) "$a0" "$a1" "$a2" "$a3") in
      do:  ("err" <-[uint64T] "$r0");;;
      (if: (![uint64T] "err") ≠ #(W64 0)
      then continue: #()
      else do:  #());;;
      let: "err2" := (mem.alloc (type.zero_val uint64T)) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![sliceT] (![ptrT] "reply")) in
      (func_call #marshal.ReadInt) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("err2" <-[uint64T] "$r0");;;
      do:  ((![ptrT] "reply") <-[sliceT] "$r1");;;
      (if: (![uint64T] "err2") = e.NotLeader
      then
        do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![ptrT] (struct.field_ref ptrT #"mu"%go (![ptrT] "ck")))) #());;;
        (if: (![uint64T] "l") = (![uint64T] (struct.field_ref ptrT #"leader"%go (![ptrT] "ck")))
        then
          let: "$r0" := (((![uint64T] (struct.field_ref ptrT #"leader"%go (![ptrT] "ck"))) + #(W64 1)) `rem` (s_to_w64 (let: "$a0" := (![sliceT] (struct.field_ref ptrT #"cls"%go (![ptrT] "ck"))) in
          slice.len "$a0"))) in
          do:  ((struct.field_ref ptrT #"leader"%go (![ptrT] "ck")) <-[uint64T] "$r0")
        else do:  #());;;
        do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![ptrT] (struct.field_ref ptrT #"mu"%go (![ptrT] "ck")))) #());;;
        continue: #()
      else do:  #());;;
      (if: (![uint64T] "err2") = e.None
      then break: #()
      else do:  #()));;;
    let: "epoch" := (mem.alloc (type.zero_val uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![sliceT] (![ptrT] "reply")) in
    (func_call #marshal.ReadInt) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("epoch" <-[uint64T] "$r0");;;
    do:  ((![ptrT] "reply") <-[sliceT] "$r1");;;
    let: "config" := (mem.alloc (type.zero_val sliceT)) in
    let: "$r0" := (let: "$a0" := (![sliceT] (![ptrT] "reply")) in
    (func_call #DecodeConfig) "$a0") in
    do:  ("config" <-[sliceT] "$r0");;;
    return: (![uint64T] "epoch", ![sliceT] "config")).

(* go: client.go:67:18 *)
Definition Clerk__GetConfigⁱᵐᵖˡ : val :=
  λ: "ck" <>,
    exception_do (let: "ck" := (mem.alloc "ck") in
    let: "reply" := (mem.alloc (type.zero_val ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val sliceT)) in
    do:  ("reply" <-[ptrT] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "i" := (mem.alloc (type.zero_val uint64T)) in
      let: "$r0" := (((func_call #primitive.RandomUint64) #()) `rem` (s_to_w64 (let: "$a0" := (![sliceT] (struct.field_ref ptrT #"cls"%go (![ptrT] "ck"))) in
      slice.len "$a0"))) in
      do:  ("i" <-[uint64T] "$r0");;;
      let: "err" := (mem.alloc (type.zero_val uint64T)) in
      let: "$r0" := (let: "$a0" := RPC_GETCONFIG in
      let: "$a1" := (slice.make2 byteT #(W64 0)) in
      let: "$a2" := (![ptrT] "reply") in
      let: "$a3" := #(W64 100) in
      (method_call #(ptrT.id reconnectclient.ReconnectingClient.id) #"Call"%go (![ptrT] (slice.elem_ref ptrT (![sliceT] (struct.field_ref ptrT #"cls"%go (![ptrT] "ck"))) (![uint64T] "i")))) "$a0" "$a1" "$a2" "$a3") in
      do:  ("err" <-[uint64T] "$r0");;;
      (if: (![uint64T] "err") = #(W64 0)
      then break: #()
      else do:  #());;;
      continue: #());;;
    let: "config" := (mem.alloc (type.zero_val sliceT)) in
    let: "$r0" := (let: "$a0" := (![sliceT] (![ptrT] "reply")) in
    (func_call #DecodeConfig) "$a0") in
    do:  ("config" <-[sliceT] "$r0");;;
    return: (![sliceT] "config")).

(* go: client.go:81:18 *)
Definition Clerk__TryWriteConfigⁱᵐᵖˡ : val :=
  λ: "ck" "epoch" "config",
    exception_do (let: "ck" := (mem.alloc "ck") in
    let: "config" := (mem.alloc "config") in
    let: "epoch" := (mem.alloc "epoch") in
    let: "reply" := (mem.alloc (type.zero_val ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val sliceT)) in
    do:  ("reply" <-[ptrT] "$r0");;;
    let: "args" := (mem.alloc (type.zero_val sliceT)) in
    let: "$r0" := (slice.make3 byteT #(W64 0) (#(W64 8) + (#(W64 8) * (let: "$a0" := (![sliceT] "config") in
    slice.len "$a0")))) in
    do:  ("args" <-[sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT] "args") in
    let: "$a1" := (![uint64T] "epoch") in
    (func_call #marshal.WriteInt) "$a0" "$a1") in
    do:  ("args" <-[sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT] "args") in
    let: "$a1" := (let: "$a0" := (![sliceT] "config") in
    (func_call #EncodeConfig) "$a0") in
    (func_call #marshal.WriteBytes) "$a0" "$a1") in
    do:  ("args" <-[sliceT] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![ptrT] (struct.field_ref ptrT #"mu"%go (![ptrT] "ck")))) #());;;
      let: "l" := (mem.alloc (type.zero_val uint64T)) in
      let: "$r0" := (![uint64T] (struct.field_ref ptrT #"leader"%go (![ptrT] "ck"))) in
      do:  ("l" <-[uint64T] "$r0");;;
      do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![ptrT] (struct.field_ref ptrT #"mu"%go (![ptrT] "ck")))) #());;;
      let: "err" := (mem.alloc (type.zero_val uint64T)) in
      let: "$r0" := (let: "$a0" := RPC_TRYWRITECONFIG in
      let: "$a1" := (![sliceT] "args") in
      let: "$a2" := (![ptrT] "reply") in
      let: "$a3" := #(W64 2000) in
      (method_call #(ptrT.id reconnectclient.ReconnectingClient.id) #"Call"%go (![ptrT] (slice.elem_ref ptrT (![sliceT] (struct.field_ref ptrT #"cls"%go (![ptrT] "ck"))) (![uint64T] "l")))) "$a0" "$a1" "$a2" "$a3") in
      do:  ("err" <-[uint64T] "$r0");;;
      (if: (![uint64T] "err") ≠ #(W64 0)
      then continue: #()
      else do:  #());;;
      let: "err2" := (mem.alloc (type.zero_val uint64T)) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![sliceT] (![ptrT] "reply")) in
      (func_call #marshal.ReadInt) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("err2" <-[uint64T] "$r0");;;
      do:  "$r1";;;
      (if: (![uint64T] "err2") = e.NotLeader
      then
        do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![ptrT] (struct.field_ref ptrT #"mu"%go (![ptrT] "ck")))) #());;;
        (if: (![uint64T] "l") = (![uint64T] (struct.field_ref ptrT #"leader"%go (![ptrT] "ck")))
        then
          let: "$r0" := (((![uint64T] (struct.field_ref ptrT #"leader"%go (![ptrT] "ck"))) + #(W64 1)) `rem` (s_to_w64 (let: "$a0" := (![sliceT] (struct.field_ref ptrT #"cls"%go (![ptrT] "ck"))) in
          slice.len "$a0"))) in
          do:  ((struct.field_ref ptrT #"leader"%go (![ptrT] "ck")) <-[uint64T] "$r0")
        else do:  #());;;
        do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![ptrT] (struct.field_ref ptrT #"mu"%go (![ptrT] "ck")))) #());;;
        continue: #()
      else break: #()));;;
    let: "err" := (mem.alloc (type.zero_val uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![sliceT] (![ptrT] "reply")) in
    (func_call #marshal.ReadInt) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("err" <-[uint64T] "$r0");;;
    do:  "$r1";;;
    return: (![uint64T] "err")).

(* returns e.None if the lease was granted for the given epoch, and a conservative
   guess on when the lease expires.

   go: client.go:117:18 *)
Definition Clerk__GetLeaseⁱᵐᵖˡ : val :=
  λ: "ck" "epoch",
    exception_do (let: "ck" := (mem.alloc "ck") in
    let: "epoch" := (mem.alloc "epoch") in
    let: "reply" := (mem.alloc (type.zero_val ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val sliceT)) in
    do:  ("reply" <-[ptrT] "$r0");;;
    let: "args" := (mem.alloc (type.zero_val sliceT)) in
    let: "$r0" := (slice.make3 byteT #(W64 0) #(W64 8)) in
    do:  ("args" <-[sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT] "args") in
    let: "$a1" := (![uint64T] "epoch") in
    (func_call #marshal.WriteInt) "$a0" "$a1") in
    do:  ("args" <-[sliceT] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![ptrT] (struct.field_ref ptrT #"mu"%go (![ptrT] "ck")))) #());;;
      let: "l" := (mem.alloc (type.zero_val uint64T)) in
      let: "$r0" := (![uint64T] (struct.field_ref ptrT #"leader"%go (![ptrT] "ck"))) in
      do:  ("l" <-[uint64T] "$r0");;;
      do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![ptrT] (struct.field_ref ptrT #"mu"%go (![ptrT] "ck")))) #());;;
      let: "err" := (mem.alloc (type.zero_val uint64T)) in
      let: "$r0" := (let: "$a0" := RPC_GETLEASE in
      let: "$a1" := (![sliceT] "args") in
      let: "$a2" := (![ptrT] "reply") in
      let: "$a3" := #(W64 100) in
      (method_call #(ptrT.id reconnectclient.ReconnectingClient.id) #"Call"%go (![ptrT] (slice.elem_ref ptrT (![sliceT] (struct.field_ref ptrT #"cls"%go (![ptrT] "ck"))) (![uint64T] "l")))) "$a0" "$a1" "$a2" "$a3") in
      do:  ("err" <-[uint64T] "$r0");;;
      (if: (![uint64T] "err") ≠ #(W64 0)
      then continue: #()
      else do:  #());;;
      let: "err2" := (mem.alloc (type.zero_val uint64T)) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![sliceT] (![ptrT] "reply")) in
      (func_call #marshal.ReadInt) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("err2" <-[uint64T] "$r0");;;
      do:  "$r1";;;
      (if: (![uint64T] "err2") = e.NotLeader
      then
        do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![ptrT] (struct.field_ref ptrT #"mu"%go (![ptrT] "ck")))) #());;;
        (if: (![uint64T] "l") = (![uint64T] (struct.field_ref ptrT #"leader"%go (![ptrT] "ck")))
        then
          let: "$r0" := (((![uint64T] (struct.field_ref ptrT #"leader"%go (![ptrT] "ck"))) + #(W64 1)) `rem` (s_to_w64 (let: "$a0" := (![sliceT] (struct.field_ref ptrT #"cls"%go (![ptrT] "ck"))) in
          slice.len "$a0"))) in
          do:  ((struct.field_ref ptrT #"leader"%go (![ptrT] "ck")) <-[uint64T] "$r0")
        else do:  #());;;
        do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![ptrT] (struct.field_ref ptrT #"mu"%go (![ptrT] "ck")))) #());;;
        continue: #()
      else break: #()));;;
    let: "enc" := (mem.alloc (type.zero_val sliceT)) in
    let: "err2" := (mem.alloc (type.zero_val uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![sliceT] (![ptrT] "reply")) in
    (func_call #marshal.ReadInt) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("err2" <-[uint64T] "$r0");;;
    do:  ("enc" <-[sliceT] "$r1");;;
    let: "leaseExpiration" := (mem.alloc (type.zero_val uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![sliceT] "enc") in
    (func_call #marshal.ReadInt) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("leaseExpiration" <-[uint64T] "$r0");;;
    do:  "$r1";;;
    return: (![uint64T] "err2", ![uint64T] "leaseExpiration")).

(* 1 second *)
Definition LeaseInterval : val := #(W64 1000000000).

Definition state : go_type := structT [
  "epoch" :: uint64T;
  "reservedEpoch" :: uint64T;
  "leaseExpiration" :: uint64T;
  "wantLeaseToExpire" :: boolT;
  "config" :: sliceT
].
#[global] Typeclasses Opaque state.
#[global] Opaque state.

Definition encodeState : go_string := "github.com/mit-pdos/gokv/vrsm/configservice.encodeState"%go.

(* go: server.go:25:6 *)
Definition encodeStateⁱᵐᵖˡ : val :=
  λ: "st",
    exception_do (let: "st" := (mem.alloc "st") in
    let: "e" := (mem.alloc (type.zero_val sliceT)) in
    let: "$r0" := (let: "$a0" := #slice.nil in
    let: "$a1" := (![uint64T] (struct.field_ref ptrT #"epoch"%go (![ptrT] "st"))) in
    (func_call #marshal.WriteInt) "$a0" "$a1") in
    do:  ("e" <-[sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT] "e") in
    let: "$a1" := (![uint64T] (struct.field_ref ptrT #"reservedEpoch"%go (![ptrT] "st"))) in
    (func_call #marshal.WriteInt) "$a0" "$a1") in
    do:  ("e" <-[sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT] "e") in
    let: "$a1" := (![uint64T] (struct.field_ref ptrT #"leaseExpiration"%go (![ptrT] "st"))) in
    (func_call #marshal.WriteInt) "$a0" "$a1") in
    do:  ("e" <-[sliceT] "$r0");;;
    (if: ![boolT] (struct.field_ref ptrT #"wantLeaseToExpire"%go (![ptrT] "st"))
    then
      let: "$r0" := (let: "$a0" := (![sliceT] "e") in
      let: "$a1" := #(W64 1) in
      (func_call #marshal.WriteInt) "$a0" "$a1") in
      do:  ("e" <-[sliceT] "$r0")
    else
      let: "$r0" := (let: "$a0" := (![sliceT] "e") in
      let: "$a1" := #(W64 0) in
      (func_call #marshal.WriteInt) "$a0" "$a1") in
      do:  ("e" <-[sliceT] "$r0"));;;
    let: "$r0" := (let: "$a0" := (![sliceT] "e") in
    let: "$a1" := (let: "$a0" := (![sliceT] (struct.field_ref ptrT #"config"%go (![ptrT] "st"))) in
    (func_call #EncodeConfig) "$a0") in
    (func_call #marshal.WriteBytes) "$a0" "$a1") in
    do:  ("e" <-[sliceT] "$r0");;;
    return: (![sliceT] "e")).

Definition decodeState : go_string := "github.com/mit-pdos/gokv/vrsm/configservice.decodeState"%go.

(* go: server.go:39:6 *)
Definition decodeStateⁱᵐᵖˡ : val :=
  λ: "e",
    exception_do (let: "e" := (mem.alloc "e") in
    let: "st" := (mem.alloc (type.zero_val ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val state)) in
    do:  ("st" <-[ptrT] "$r0");;;
    let: "e2" := (mem.alloc (type.zero_val sliceT)) in
    let: "$r0" := (![sliceT] "e") in
    do:  ("e2" <-[sliceT] "$r0");;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![sliceT] "e2") in
    (func_call #marshal.ReadInt) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ((struct.field_ref ptrT #"epoch"%go (![ptrT] "st")) <-[uint64T] "$r0");;;
    do:  ("e2" <-[sliceT] "$r1");;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![sliceT] "e2") in
    (func_call #marshal.ReadInt) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ((struct.field_ref ptrT #"reservedEpoch"%go (![ptrT] "st")) <-[uint64T] "$r0");;;
    do:  ("e2" <-[sliceT] "$r1");;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![sliceT] "e2") in
    (func_call #marshal.ReadInt) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ((struct.field_ref ptrT #"leaseExpiration"%go (![ptrT] "st")) <-[uint64T] "$r0");;;
    do:  ("e2" <-[sliceT] "$r1");;;
    let: "wantExp" := (mem.alloc (type.zero_val uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![sliceT] "e2") in
    (func_call #marshal.ReadInt) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("wantExp" <-[uint64T] "$r0");;;
    do:  ("e2" <-[sliceT] "$r1");;;
    let: "$r0" := ((![uint64T] "wantExp") = #(W64 1)) in
    do:  ((struct.field_ref ptrT #"wantLeaseToExpire"%go (![ptrT] "st")) <-[boolT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT] "e2") in
    (func_call #DecodeConfig) "$a0") in
    do:  ((struct.field_ref ptrT #"config"%go (![ptrT] "st")) <-[sliceT] "$r0");;;
    return: (![ptrT] "st")).

Definition Server : go_type := structT [
  "s" :: ptrT
].
#[global] Typeclasses Opaque Server.
#[global] Opaque Server.

(* go: server.go:56:18 *)
Definition Server__tryAcquireⁱᵐᵖˡ : val :=
  λ: "s" <>,
    exception_do (let: "s" := (mem.alloc "s") in
    let: "relF" := (mem.alloc (type.zero_val funcT)) in
    let: "e" := (mem.alloc (type.zero_val ptrT)) in
    let: "err" := (mem.alloc (type.zero_val paxos.Error)) in
    let: (("$ret0", "$ret1"), "$ret2") := ((method_call #(ptrT.id paxos.Server.id) #"TryAcquire"%go (![ptrT] (struct.field_ref ptrT #"s"%go (![ptrT] "s")))) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("err" <-[paxos.Error] "$r0");;;
    do:  ("e" <-[ptrT] "$r1");;;
    do:  ("relF" <-[funcT] "$r2");;;
    (if: (![paxos.Error] "err") ≠ #(W64 0)
    then
      let: "p" := (mem.alloc (type.zero_val ptrT)) in
      return: (#false, ![ptrT] "p", #func.nil)
    else do:  #());;;
    let: "st" := (mem.alloc (type.zero_val ptrT)) in
    let: "$r0" := (let: "$a0" := (![sliceT] (![ptrT] "e")) in
    (func_call #decodeState) "$a0") in
    do:  ("st" <-[ptrT] "$r0");;;
    let: "releaseFn" := (mem.alloc (type.zero_val funcT)) in
    let: "$r0" := (λ: <>,
      exception_do (let: "$r0" := (let: "$a0" := (![ptrT] "st") in
      (func_call #encodeState) "$a0") in
      do:  ((![ptrT] "e") <-[sliceT] "$r0");;;
      return: (((![funcT] "relF") #()) = #(W64 0)))
      ) in
    do:  ("releaseFn" <-[funcT] "$r0");;;
    return: (#true, ![ptrT] "st", ![funcT] "releaseFn")).

(* go: server.go:70:18 *)
Definition Server__ReserveEpochAndGetConfigⁱᵐᵖˡ : val :=
  λ: "s" "args" "reply",
    exception_do (let: "s" := (mem.alloc "s") in
    let: "reply" := (mem.alloc "reply") in
    let: "args" := (mem.alloc "args") in
    let: "$r0" := (let: "$a0" := #slice.nil in
    let: "$a1" := e.NotLeader in
    (func_call #marshal.WriteInt) "$a0" "$a1") in
    do:  ((![ptrT] "reply") <-[sliceT] "$r0");;;
    let: "tryReleaseFn" := (mem.alloc (type.zero_val funcT)) in
    let: "st" := (mem.alloc (type.zero_val ptrT)) in
    let: "ok" := (mem.alloc (type.zero_val boolT)) in
    let: (("$ret0", "$ret1"), "$ret2") := ((method_call #(ptrT.id Server.id) #"tryAcquire"%go (![ptrT] "s")) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("ok" <-[boolT] "$r0");;;
    do:  ("st" <-[ptrT] "$r1");;;
    do:  ("tryReleaseFn" <-[funcT] "$r2");;;
    (if: (~ (![boolT] "ok"))
    then return: (#())
    else do:  #());;;
    let: "$r0" := (let: "$a0" := (![uint64T] (struct.field_ref ptrT #"reservedEpoch"%go (![ptrT] "st"))) in
    let: "$a1" := #(W64 1) in
    (func_call #std.SumAssumeNoOverflow) "$a0" "$a1") in
    do:  ((struct.field_ref ptrT #"reservedEpoch"%go (![ptrT] "st")) <-[uint64T] "$r0");;;
    let: "config" := (mem.alloc (type.zero_val sliceT)) in
    let: "$r0" := (![sliceT] (struct.field_ref ptrT #"config"%go (![ptrT] "st"))) in
    do:  ("config" <-[sliceT] "$r0");;;
    let: "reservedEpoch" := (mem.alloc (type.zero_val uint64T)) in
    let: "$r0" := (![uint64T] (struct.field_ref ptrT #"reservedEpoch"%go (![ptrT] "st"))) in
    do:  ("reservedEpoch" <-[uint64T] "$r0");;;
    (if: (~ ((![funcT] "tryReleaseFn") #()))
    then return: (#())
    else do:  #());;;
    let: "$r0" := (slice.make3 byteT #(W64 0) (#(W64 (8 + 8)) + (#(W64 8) * (let: "$a0" := (![sliceT] "config") in
    slice.len "$a0")))) in
    do:  ((![ptrT] "reply") <-[sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT] (![ptrT] "reply")) in
    let: "$a1" := e.None in
    (func_call #marshal.WriteInt) "$a0" "$a1") in
    do:  ((![ptrT] "reply") <-[sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT] (![ptrT] "reply")) in
    let: "$a1" := (![uint64T] "reservedEpoch") in
    (func_call #marshal.WriteInt) "$a0" "$a1") in
    do:  ((![ptrT] "reply") <-[sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT] (![ptrT] "reply")) in
    let: "$a1" := (let: "$a0" := (![sliceT] "config") in
    (func_call #EncodeConfig) "$a0") in
    (func_call #marshal.WriteBytes) "$a0" "$a1") in
    do:  ((![ptrT] "reply") <-[sliceT] "$r0");;;
    return: #()).

(* go: server.go:88:18 *)
Definition Server__GetConfigⁱᵐᵖˡ : val :=
  λ: "s" "args" "reply",
    exception_do (let: "s" := (mem.alloc "s") in
    let: "reply" := (mem.alloc "reply") in
    let: "args" := (mem.alloc "args") in
    let: "st" := (mem.alloc (type.zero_val ptrT)) in
    let: "$r0" := (let: "$a0" := ((method_call #(ptrT.id paxos.Server.id) #"WeakRead"%go (![ptrT] (struct.field_ref ptrT #"s"%go (![ptrT] "s")))) #()) in
    (func_call #decodeState) "$a0") in
    do:  ("st" <-[ptrT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT] (struct.field_ref ptrT #"config"%go (![ptrT] "st"))) in
    (func_call #EncodeConfig) "$a0") in
    do:  ((![ptrT] "reply") <-[sliceT] "$r0");;;
    return: #()).

(* go: server.go:93:18 *)
Definition Server__TryWriteConfigⁱᵐᵖˡ : val :=
  λ: "s" "args" "reply",
    exception_do (let: "s" := (mem.alloc "s") in
    let: "reply" := (mem.alloc "reply") in
    let: "args" := (mem.alloc "args") in
    let: "$r0" := (let: "$a0" := #slice.nil in
    let: "$a1" := e.NotLeader in
    (func_call #marshal.WriteInt) "$a0" "$a1") in
    do:  ((![ptrT] "reply") <-[sliceT] "$r0");;;
    let: "enc" := (mem.alloc (type.zero_val sliceT)) in
    let: "epoch" := (mem.alloc (type.zero_val uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![sliceT] "args") in
    (func_call #marshal.ReadInt) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("epoch" <-[uint64T] "$r0");;;
    do:  ("enc" <-[sliceT] "$r1");;;
    let: "config" := (mem.alloc (type.zero_val sliceT)) in
    let: "$r0" := (let: "$a0" := (![sliceT] "enc") in
    (func_call #DecodeConfig) "$a0") in
    do:  ("config" <-[sliceT] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "tryReleaseFn" := (mem.alloc (type.zero_val funcT)) in
      let: "st" := (mem.alloc (type.zero_val ptrT)) in
      let: "ok" := (mem.alloc (type.zero_val boolT)) in
      let: (("$ret0", "$ret1"), "$ret2") := ((method_call #(ptrT.id Server.id) #"tryAcquire"%go (![ptrT] "s")) #()) in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      let: "$r2" := "$ret2" in
      do:  ("ok" <-[boolT] "$r0");;;
      do:  ("st" <-[ptrT] "$r1");;;
      do:  ("tryReleaseFn" <-[funcT] "$r2");;;
      (if: (~ (![boolT] "ok"))
      then break: #()
      else do:  #());;;
      (if: (![uint64T] "epoch") < (![uint64T] (struct.field_ref ptrT #"reservedEpoch"%go (![ptrT] "st")))
      then
        (if: (~ ((![funcT] "tryReleaseFn") #()))
        then break: #()
        else do:  #());;;
        let: "$r0" := (let: "$a0" := #slice.nil in
        let: "$a1" := e.Stale in
        (func_call #marshal.WriteInt) "$a0" "$a1") in
        do:  ((![ptrT] "reply") <-[sliceT] "$r0");;;
        do:  (let: "$a0" := #"Stale: %d < %d"%go in
        let: "$a1" := ((let: "$sl0" := (interface.make #uint64T.id (![uint64T] "epoch")) in
        let: "$sl1" := (interface.make #uint64T.id (![uint64T] (struct.field_ref ptrT #"reservedEpoch"%go (![ptrT] "st")))) in
        slice.literal interfaceT ["$sl0"; "$sl1"])) in
        (func_call #log.Printf) "$a0" "$a1");;;
        break: #()
      else
        (if: (![uint64T] "epoch") > (![uint64T] (struct.field_ref ptrT #"epoch"%go (![ptrT] "st")))
        then
          let: "l" := (mem.alloc (type.zero_val uint64T)) in
          let: ("$ret0", "$ret1") := ((func_call #grove_ffi.GetTimeRange) #()) in
          let: "$r0" := "$ret0" in
          let: "$r1" := "$ret1" in
          do:  ("l" <-[uint64T] "$r0");;;
          do:  "$r1";;;
          (if: (![uint64T] "l") ≥ (![uint64T] (struct.field_ref ptrT #"leaseExpiration"%go (![ptrT] "st")))
          then
            let: "$r0" := #false in
            do:  ((struct.field_ref ptrT #"wantLeaseToExpire"%go (![ptrT] "st")) <-[boolT] "$r0");;;
            let: "$r0" := (![uint64T] "epoch") in
            do:  ((struct.field_ref ptrT #"epoch"%go (![ptrT] "st")) <-[uint64T] "$r0");;;
            let: "$r0" := (![sliceT] "config") in
            do:  ((struct.field_ref ptrT #"config"%go (![ptrT] "st")) <-[sliceT] "$r0");;;
            (if: (~ ((![funcT] "tryReleaseFn") #()))
            then break: #()
            else do:  #());;;
            do:  (let: "$a0" := ((let: "$sl0" := (interface.make #stringT.id #"New config is:"%go) in
            let: "$sl1" := (interface.make #(sliceT.id uint64T.id) (![sliceT] (struct.field_ref ptrT #"config"%go (![ptrT] "st")))) in
            slice.literal interfaceT ["$sl0"; "$sl1"])) in
            (func_call #log.Println) "$a0");;;
            let: "$r0" := (let: "$a0" := #slice.nil in
            let: "$a1" := e.None in
            (func_call #marshal.WriteInt) "$a0" "$a1") in
            do:  ((![ptrT] "reply") <-[sliceT] "$r0");;;
            break: #()
          else
            let: "$r0" := #true in
            do:  ((struct.field_ref ptrT #"wantLeaseToExpire"%go (![ptrT] "st")) <-[boolT] "$r0");;;
            let: "timeToSleep" := (mem.alloc (type.zero_val uint64T)) in
            let: "$r0" := ((![uint64T] (struct.field_ref ptrT #"leaseExpiration"%go (![ptrT] "st"))) - (![uint64T] "l")) in
            do:  ("timeToSleep" <-[uint64T] "$r0");;;
            (if: (~ ((![funcT] "tryReleaseFn") #()))
            then break: #()
            else do:  #());;;
            do:  (let: "$a0" := (![uint64T] "timeToSleep") in
            (func_call #primitive.Sleep) "$a0");;;
            continue: #())
        else
          let: "$r0" := (![sliceT] "config") in
          do:  ((struct.field_ref ptrT #"config"%go (![ptrT] "st")) <-[sliceT] "$r0");;;
          (if: (~ ((![funcT] "tryReleaseFn") #()))
          then break: #()
          else do:  #());;;
          let: "$r0" := (let: "$a0" := #slice.nil in
          let: "$a1" := e.None in
          (func_call #marshal.WriteInt) "$a0" "$a1") in
          do:  ((![ptrT] "reply") <-[sliceT] "$r0");;;
          break: #())));;;
    return: #()).

(* go: server.go:145:18 *)
Definition Server__GetLeaseⁱᵐᵖˡ : val :=
  λ: "s" "args" "reply",
    exception_do (let: "s" := (mem.alloc "s") in
    let: "reply" := (mem.alloc "reply") in
    let: "args" := (mem.alloc "args") in
    let: "$r0" := (let: "$a0" := #slice.nil in
    let: "$a1" := e.NotLeader in
    (func_call #marshal.WriteInt) "$a0" "$a1") in
    do:  ((![ptrT] "reply") <-[sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT] (![ptrT] "reply")) in
    let: "$a1" := #(W64 0) in
    (func_call #marshal.WriteInt) "$a0" "$a1") in
    do:  ((![ptrT] "reply") <-[sliceT] "$r0");;;
    let: "epoch" := (mem.alloc (type.zero_val uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![sliceT] "args") in
    (func_call #marshal.ReadInt) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("epoch" <-[uint64T] "$r0");;;
    do:  "$r1";;;
    let: "tryReleaseFn" := (mem.alloc (type.zero_val funcT)) in
    let: "st" := (mem.alloc (type.zero_val ptrT)) in
    let: "ok" := (mem.alloc (type.zero_val boolT)) in
    let: (("$ret0", "$ret1"), "$ret2") := ((method_call #(ptrT.id Server.id) #"tryAcquire"%go (![ptrT] "s")) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("ok" <-[boolT] "$r0");;;
    do:  ("st" <-[ptrT] "$r1");;;
    do:  ("tryReleaseFn" <-[funcT] "$r2");;;
    (if: (~ (![boolT] "ok"))
    then return: (#())
    else do:  #());;;
    (if: ((![uint64T] (struct.field_ref ptrT #"epoch"%go (![ptrT] "st"))) ≠ (![uint64T] "epoch")) || (![boolT] (struct.field_ref ptrT #"wantLeaseToExpire"%go (![ptrT] "st")))
    then
      do:  (let: "$a0" := ((let: "$sl0" := (interface.make #stringT.id #"Rejected lease request"%go) in
      let: "$sl1" := (interface.make #uint64T.id (![uint64T] "epoch")) in
      let: "$sl2" := (interface.make #uint64T.id (![uint64T] (struct.field_ref ptrT #"epoch"%go (![ptrT] "st")))) in
      let: "$sl3" := (interface.make #boolT.id (![boolT] (struct.field_ref ptrT #"wantLeaseToExpire"%go (![ptrT] "st")))) in
      slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"])) in
      (func_call #log.Println) "$a0");;;
      (if: (~ ((![funcT] "tryReleaseFn") #()))
      then return: (#())
      else do:  #());;;
      let: "$r0" := (let: "$a0" := #slice.nil in
      let: "$a1" := e.Stale in
      (func_call #marshal.WriteInt) "$a0" "$a1") in
      do:  ((![ptrT] "reply") <-[sliceT] "$r0");;;
      let: "$r0" := (let: "$a0" := (![sliceT] (![ptrT] "reply")) in
      let: "$a1" := #(W64 0) in
      (func_call #marshal.WriteInt) "$a0" "$a1") in
      do:  ((![ptrT] "reply") <-[sliceT] "$r0");;;
      return: (#())
    else do:  #());;;
    let: "l" := (mem.alloc (type.zero_val uint64T)) in
    let: ("$ret0", "$ret1") := ((func_call #grove_ffi.GetTimeRange) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("l" <-[uint64T] "$r0");;;
    do:  "$r1";;;
    let: "newLeaseExpiration" := (mem.alloc (type.zero_val uint64T)) in
    let: "$r0" := ((![uint64T] "l") + LeaseInterval) in
    do:  ("newLeaseExpiration" <-[uint64T] "$r0");;;
    (if: (![uint64T] "newLeaseExpiration") > (![uint64T] (struct.field_ref ptrT #"leaseExpiration"%go (![ptrT] "st")))
    then
      let: "$r0" := (![uint64T] "newLeaseExpiration") in
      do:  ((struct.field_ref ptrT #"leaseExpiration"%go (![ptrT] "st")) <-[uint64T] "$r0")
    else do:  #());;;
    (if: (~ ((![funcT] "tryReleaseFn") #()))
    then return: (#())
    else do:  #());;;
    let: "$r0" := (let: "$a0" := #slice.nil in
    let: "$a1" := e.None in
    (func_call #marshal.WriteInt) "$a0" "$a1") in
    do:  ((![ptrT] "reply") <-[sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT] (![ptrT] "reply")) in
    let: "$a1" := (![uint64T] "newLeaseExpiration") in
    (func_call #marshal.WriteInt) "$a0" "$a1") in
    do:  ((![ptrT] "reply") <-[sliceT] "$r0");;;
    return: #()).

Definition makeServer : go_string := "github.com/mit-pdos/gokv/vrsm/configservice.makeServer"%go.

(* go: server.go:177:6 *)
Definition makeServerⁱᵐᵖˡ : val :=
  λ: "fname" "paxosMe" "hosts" "initconfig",
    exception_do (let: "initconfig" := (mem.alloc "initconfig") in
    let: "hosts" := (mem.alloc "hosts") in
    let: "paxosMe" := (mem.alloc "paxosMe") in
    let: "fname" := (mem.alloc "fname") in
    let: "s" := (mem.alloc (type.zero_val ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val Server)) in
    do:  ("s" <-[ptrT] "$r0");;;
    let: "initEnc" := (mem.alloc (type.zero_val sliceT)) in
    let: "$r0" := (let: "$a0" := (mem.alloc (let: "$config" := (![sliceT] "initconfig") in
    struct.make state [{
      "epoch" ::= type.zero_val uint64T;
      "reservedEpoch" ::= type.zero_val uint64T;
      "leaseExpiration" ::= type.zero_val uint64T;
      "wantLeaseToExpire" ::= type.zero_val boolT;
      "config" ::= "$config"
    }])) in
    (func_call #encodeState) "$a0") in
    do:  ("initEnc" <-[sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![stringT] "fname") in
    let: "$a1" := (![sliceT] "initEnc") in
    let: "$a2" := (![uint64T] "paxosMe") in
    let: "$a3" := (![sliceT] "hosts") in
    (func_call #paxos.StartServer) "$a0" "$a1" "$a2" "$a3") in
    do:  ((struct.field_ref ptrT #"s"%go (![ptrT] "s")) <-[ptrT] "$r0");;;
    return: (![ptrT] "s")).

Definition StartServer : go_string := "github.com/mit-pdos/gokv/vrsm/configservice.StartServer"%go.

(* go: server.go:187:6 *)
Definition StartServerⁱᵐᵖˡ : val :=
  λ: "fname" "me" "paxosMe" "hosts" "initconfig",
    exception_do (let: "initconfig" := (mem.alloc "initconfig") in
    let: "hosts" := (mem.alloc "hosts") in
    let: "paxosMe" := (mem.alloc "paxosMe") in
    let: "me" := (mem.alloc "me") in
    let: "fname" := (mem.alloc "fname") in
    let: "s" := (mem.alloc (type.zero_val ptrT)) in
    let: "$r0" := (let: "$a0" := (![stringT] "fname") in
    let: "$a1" := (![uint64T] "paxosMe") in
    let: "$a2" := (![sliceT] "hosts") in
    let: "$a3" := (![sliceT] "initconfig") in
    (func_call #makeServer) "$a0" "$a1" "$a2" "$a3") in
    do:  ("s" <-[ptrT] "$r0");;;
    let: "handlers" := (mem.alloc (type.zero_val (mapT uint64T funcT))) in
    let: "$r0" := (map.make uint64T funcT) in
    do:  ("handlers" <-[mapT uint64T funcT] "$r0");;;
    let: "$r0" := (method_call #(ptrT.id Server.id) #"ReserveEpochAndGetConfig"%go (![ptrT] "s")) in
    do:  (map.insert (![mapT uint64T funcT] "handlers") RPC_RESERVEEPOCH "$r0");;;
    let: "$r0" := (method_call #(ptrT.id Server.id) #"GetConfig"%go (![ptrT] "s")) in
    do:  (map.insert (![mapT uint64T funcT] "handlers") RPC_GETCONFIG "$r0");;;
    let: "$r0" := (method_call #(ptrT.id Server.id) #"TryWriteConfig"%go (![ptrT] "s")) in
    do:  (map.insert (![mapT uint64T funcT] "handlers") RPC_TRYWRITECONFIG "$r0");;;
    let: "$r0" := (method_call #(ptrT.id Server.id) #"GetLease"%go (![ptrT] "s")) in
    do:  (map.insert (![mapT uint64T funcT] "handlers") RPC_GETLEASE "$r0");;;
    let: "rs" := (mem.alloc (type.zero_val ptrT)) in
    let: "$r0" := (let: "$a0" := (![mapT uint64T funcT] "handlers") in
    (func_call #urpc.MakeServer) "$a0") in
    do:  ("rs" <-[ptrT] "$r0");;;
    do:  (let: "$a0" := (![uint64T] "me") in
    (method_call #(ptrT.id urpc.Server.id) #"Serve"%go (![ptrT] "rs")) "$a0");;;
    return: (![ptrT] "s")).

Definition vars' : list (go_string * go_type) := [].

Definition functions' : list (go_string * val) := [(EncodeConfig, EncodeConfigⁱᵐᵖˡ); (DecodeConfig, DecodeConfigⁱᵐᵖˡ); (MakeClerk, MakeClerkⁱᵐᵖˡ); (encodeState, encodeStateⁱᵐᵖˡ); (decodeState, decodeStateⁱᵐᵖˡ); (makeServer, makeServerⁱᵐᵖˡ); (StartServer, StartServerⁱᵐᵖˡ)].

Definition msets' : list (go_string * (list (go_string * val))) := [(Clerk.id, []); (ptrT.id Clerk.id, [("GetConfig"%go, Clerk__GetConfigⁱᵐᵖˡ); ("GetLease"%go, Clerk__GetLeaseⁱᵐᵖˡ); ("ReserveEpochAndGetConfig"%go, Clerk__ReserveEpochAndGetConfigⁱᵐᵖˡ); ("TryWriteConfig"%go, Clerk__TryWriteConfigⁱᵐᵖˡ)]); (state.id, []); (ptrT.id state.id, []); (Server.id, []); (ptrT.id Server.id, [("GetConfig"%go, Server__GetConfigⁱᵐᵖˡ); ("GetLease"%go, Server__GetLeaseⁱᵐᵖˡ); ("ReserveEpochAndGetConfig"%go, Server__ReserveEpochAndGetConfigⁱᵐᵖˡ); ("TryWriteConfig"%go, Server__TryWriteConfigⁱᵐᵖˡ); ("tryAcquire"%go, Server__tryAcquireⁱᵐᵖˡ)])].

#[global] Instance info' : PkgInfo configservice.configservice :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [code.github_com.mit_pdos.gokv.grove_ffi.grove_ffi; code.github_com.tchajed.marshal.marshal; code.sync.sync; code.github_com.goose_lang.primitive.primitive; code.github_com.mit_pdos.gokv.reconnectclient.reconnectclient; code.github_com.mit_pdos.gokv.vrsm.e.e; code.log.log; code.github_com.goose_lang.std.std; code.github_com.mit_pdos.gokv.urpc.urpc; code.github_com.mit_pdos.gokv.vrsm.paxos.paxos];
  |}.

Definition initialize' : val :=
  λ: <>,
    package.init #configservice.configservice (λ: <>,
      exception_do (do:  (paxos.initialize' #());;;
      do:  (urpc.initialize' #());;;
      do:  (std.initialize' #());;;
      do:  (log.initialize' #());;;
      do:  (e.initialize' #());;;
      do:  (reconnectclient.initialize' #());;;
      do:  (primitive.initialize' #());;;
      do:  (sync.initialize' #());;;
      do:  (marshal.initialize' #());;;
      do:  (grove_ffi.initialize' #());;;
      do:  (package.alloc configservice.configservice #()))
      ).

End code.
End configservice.
