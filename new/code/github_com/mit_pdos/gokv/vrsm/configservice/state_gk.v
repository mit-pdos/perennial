(* autogenerated from github.com/mit-pdos/gokv/vrsm/configservice/state_gk *)
Require Export New.code.github_com.tchajed.marshal.
From New.golang Require Import defn.
Module pkg_id.
Definition state_gk : go_string := "github.com/mit-pdos/gokv/vrsm/configservice/state_gk".

End pkg_id.
Export pkg_id.
Module state_gk.

Definition S {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/mit-pdos/gokv/vrsm/configservice/state_gk.S"%go [].

Definition Marshal {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/gokv/vrsm/configservice/state_gk.Marshal"%go.

Definition Unmarshal {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/gokv/vrsm/configservice/state_gk.Unmarshal"%go.

(* go: state_gk.go:20:6 *)
Definition Marshalⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "enc" "s",
    exception_do (let: "s" := (GoAlloc S "s") in
    let: "enc" := (GoAlloc (go.SliceType go.byte) "enc") in
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "enc") in
    let: "$a1" := (![go.uint64] (StructFieldRef S "Epoch"%go "s")) in
    (FuncResolve marshal.WriteInt [] #()) "$a0" "$a1") in
    do:  ("enc" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "enc") in
    let: "$a1" := (![go.uint64] (StructFieldRef S "ReservedEpoch"%go "s")) in
    (FuncResolve marshal.WriteInt [] #()) "$a0" "$a1") in
    do:  ("enc" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "enc") in
    let: "$a1" := (![go.uint64] (StructFieldRef S "LeaseExpiration"%go "s")) in
    (FuncResolve marshal.WriteInt [] #()) "$a0" "$a1") in
    do:  ("enc" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "enc") in
    let: "$a1" := (![go.bool] (StructFieldRef S "WantLeaseToExpire"%go "s")) in
    (FuncResolve marshal.WriteBool [] #()) "$a0" "$a1") in
    do:  ("enc" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "enc") in
    let: "$a1" := (Convert go.int go.uint64 (let: "$a0" := (![go.SliceType go.uint64] (StructFieldRef S "Config"%go "s")) in
    (FuncResolve go.len [go.SliceType go.uint64] #()) "$a0")) in
    (FuncResolve marshal.WriteInt [] #()) "$a0" "$a1") in
    do:  ("enc" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "enc") in
    let: "$a1" := (![go.SliceType go.uint64] (StructFieldRef S "Config"%go "s")) in
    let: "$a2" := (FuncResolve marshal.WriteInt [] #()) in
    (FuncResolve marshal.WriteSlice [go.uint64] #()) "$a0" "$a1" "$a2") in
    do:  ("enc" <-[go.SliceType go.byte] "$r0");;;
    return: (![go.SliceType go.byte] "enc")).

(* go: state_gk.go:32:6 *)
Definition Unmarshalⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s",
    exception_do (let: "s" := (GoAlloc (go.SliceType go.byte) "s") in
    let: "epoch" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] "s") in
    (FuncResolve marshal.ReadInt [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("epoch" <-[go.uint64] "$r0");;;
    do:  ("s" <-[go.SliceType go.byte] "$r1");;;
    let: "reservedEpoch" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] "s") in
    (FuncResolve marshal.ReadInt [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("reservedEpoch" <-[go.uint64] "$r0");;;
    do:  ("s" <-[go.SliceType go.byte] "$r1");;;
    let: "leaseExpiration" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] "s") in
    (FuncResolve marshal.ReadInt [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("leaseExpiration" <-[go.uint64] "$r0");;;
    do:  ("s" <-[go.SliceType go.byte] "$r1");;;
    let: "wantLeaseToExpire" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] "s") in
    (FuncResolve marshal.ReadBool [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("wantLeaseToExpire" <-[go.bool] "$r0");;;
    do:  ("s" <-[go.SliceType go.byte] "$r1");;;
    let: "configLen" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] "s") in
    (FuncResolve marshal.ReadInt [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("configLen" <-[go.uint64] "$r0");;;
    do:  ("s" <-[go.SliceType go.byte] "$r1");;;
    let: "config" := (GoAlloc (go.SliceType go.uint64) (GoZeroVal (go.SliceType go.uint64) #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] "s") in
    let: "$a1" := (![go.uint64] "configLen") in
    let: "$a2" := (FuncResolve marshal.ReadInt [] #()) in
    (FuncResolve marshal.ReadSlice [go.uint64] #()) "$a0" "$a1" "$a2") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("config" <-[go.SliceType go.uint64] "$r0");;;
    do:  ("s" <-[go.SliceType go.byte] "$r1");;;
    return: (CompositeLiteral S (LiteralValue [KeyedElement (Some (KeyField "Epoch"%go)) (ElementExpression go.uint64 (![go.uint64] "epoch")); KeyedElement (Some (KeyField "ReservedEpoch"%go)) (ElementExpression go.uint64 (![go.uint64] "reservedEpoch")); KeyedElement (Some (KeyField "LeaseExpiration"%go)) (ElementExpression go.uint64 (![go.uint64] "leaseExpiration")); KeyedElement (Some (KeyField "WantLeaseToExpire"%go)) (ElementExpression go.bool (![go.bool] "wantLeaseToExpire")); KeyedElement (Some (KeyField "Config"%go)) (ElementExpression (go.SliceType go.uint64) (![go.SliceType go.uint64] "config"))]), ![go.SliceType go.byte] "s")).

#[global] Instance info' : PkgInfo pkg_id.state_gk :=
{|
  pkg_imported_pkgs := [code.github_com.tchajed.marshal.pkg_id.marshal]
|}.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init pkg_id.state_gk (λ: <>,
      exception_do (do:  (marshal.initialize' #()))
      ).

Module S.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  Epoch' : w64;
  ReservedEpoch' : w64;
  LeaseExpiration' : w64;
  WantLeaseToExpire' : bool;
  Config' : slice.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End S.

Definition S'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "Epoch"%go go.uint64);
  (go.FieldDecl "ReservedEpoch"%go go.uint64);
  (go.FieldDecl "LeaseExpiration"%go go.uint64);
  (go.FieldDecl "WantLeaseToExpire"%go go.bool);
  (go.FieldDecl "Config"%go (go.SliceType go.uint64))
].
Program Definition S'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (S'fds_unsealed).
Global Instance equals_unfold_S {ext : ffi_syntax} {go_gctx : GoGlobalContext} : S'fds =→ S'fds_unsealed.
Proof. rewrite /S'fds seal_eq //. Qed.

Definition Sⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (S'fds).

Class S_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] S_type_repr  :: go.TypeReprUnderlying Sⁱᵐᵖˡ S.t;
  #[global] S_underlying :: (S) <u (Sⁱᵐᵖˡ);
  #[global] S_get_Epoch (x : S.t) :: ⟦StructFieldGet (Sⁱᵐᵖˡ) "Epoch", #x⟧ ⤳[under] #x.(S.Epoch');
  #[global] S_set_Epoch (x : S.t) y :: ⟦StructFieldSet (Sⁱᵐᵖˡ) "Epoch", (#x, #y)⟧ ⤳[under] #(x <|S.Epoch' := y|>);
  #[global] S_get_ReservedEpoch (x : S.t) :: ⟦StructFieldGet (Sⁱᵐᵖˡ) "ReservedEpoch", #x⟧ ⤳[under] #x.(S.ReservedEpoch');
  #[global] S_set_ReservedEpoch (x : S.t) y :: ⟦StructFieldSet (Sⁱᵐᵖˡ) "ReservedEpoch", (#x, #y)⟧ ⤳[under] #(x <|S.ReservedEpoch' := y|>);
  #[global] S_get_LeaseExpiration (x : S.t) :: ⟦StructFieldGet (Sⁱᵐᵖˡ) "LeaseExpiration", #x⟧ ⤳[under] #x.(S.LeaseExpiration');
  #[global] S_set_LeaseExpiration (x : S.t) y :: ⟦StructFieldSet (Sⁱᵐᵖˡ) "LeaseExpiration", (#x, #y)⟧ ⤳[under] #(x <|S.LeaseExpiration' := y|>);
  #[global] S_get_WantLeaseToExpire (x : S.t) :: ⟦StructFieldGet (Sⁱᵐᵖˡ) "WantLeaseToExpire", #x⟧ ⤳[under] #x.(S.WantLeaseToExpire');
  #[global] S_set_WantLeaseToExpire (x : S.t) y :: ⟦StructFieldSet (Sⁱᵐᵖˡ) "WantLeaseToExpire", (#x, #y)⟧ ⤳[under] #(x <|S.WantLeaseToExpire' := y|>);
  #[global] S_get_Config (x : S.t) :: ⟦StructFieldGet (Sⁱᵐᵖˡ) "Config", #x⟧ ⤳[under] #x.(S.Config');
  #[global] S_set_Config (x : S.t) y :: ⟦StructFieldSet (Sⁱᵐᵖˡ) "Config", (#x, #y)⟧ ⤳[under] #(x <|S.Config' := y|>);
}.

Class Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] S_instance :: S_Assumptions;
  #[global] Marshal_unfold :: FuncUnfold Marshal [] (Marshalⁱᵐᵖˡ);
  #[global] Unmarshal_unfold :: FuncUnfold Unmarshal [] (Unmarshalⁱᵐᵖˡ);
  #[global] import_marshal_Assumption :: marshal.Assumptions;
}.
End state_gk.
