(* autogenerated from github.com/mit-pdos/gokv/vrsm/reconfig *)
Require Export New.code.log.
Require Export New.code.sync.
Require Export New.code.github_com.goose_lang.primitive.
Require Export New.code.github_com.mit_pdos.gokv.grove_ffi.
Require Export New.code.github_com.mit_pdos.gokv.reconfig.replica.becomeprimaryargs_gk.
Require Export New.code.github_com.mit_pdos.gokv.reconfig.replica.configuration_gk.
Require Export New.code.github_com.mit_pdos.gokv.vrsm.configservice.
Require Export New.code.github_com.mit_pdos.gokv.vrsm.configservice.config_gk.
Require Export New.code.github_com.mit_pdos.gokv.vrsm.replica.
Require Export New.code.github_com.mit_pdos.gokv.vrsm.replica.err_gk.
Require Export New.code.github_com.mit_pdos.gokv.vrsm.replica.getstateargs_gk.
Require Export New.code.github_com.mit_pdos.gokv.vrsm.replica.setstateargs_gk.
From New.golang Require Import defn.
From New Require Import grove_prelude.
Module pkg_id.
Definition reconfig : go_string := "github.com/mit-pdos/gokv/vrsm/reconfig".

End pkg_id.
Export pkg_id.
Module reconfig.

Definition EnterNewConfig {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/gokv/vrsm/reconfig.EnterNewConfig"%go.

Definition InitializeSystem {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/gokv/vrsm/reconfig.InitializeSystem"%go.

(* go: admin.go:19:6 *)
Definition EnterNewConfigⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "configHosts" "servers",
    exception_do (let: "servers" := (GoAlloc (go.SliceType grove_ffi.Address) "servers") in
    let: "configHosts" := (GoAlloc (go.SliceType grove_ffi.Address) "configHosts") in
    (if: Convert go.untyped_bool go.bool ((let: "$a0" := (![go.SliceType grove_ffi.Address] "servers") in
    (FuncResolve go.len [go.SliceType grove_ffi.Address] #()) "$a0") =⟨go.int⟩ #(W64 0))
    then
      do:  (let: "$a0" := ((let: "$sl0" := (Convert go.string go.any #"Tried creating empty config"%go) in
      CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0")]))) in
      (FuncResolve log.Println [] #()) "$a0");;;
      return: (err_gk.EmptyConfig)
    else do:  #());;;
    let: "configCk" := (GoAlloc (go.PointerType configservice.Clerk) (GoZeroVal (go.PointerType configservice.Clerk) #())) in
    let: "$r0" := (let: "$a0" := (![go.SliceType grove_ffi.Address] "configHosts") in
    (FuncResolve configservice.MakeClerk [] #()) "$a0") in
    do:  ("configCk" <-[go.PointerType configservice.Clerk] "$r0");;;
    let: "conf" := (GoAlloc config_gk.S (GoZeroVal config_gk.S #())) in
    let: "epoch" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: ("$ret0", "$ret1") := ((MethodResolve (go.PointerType configservice.Clerk) "ReserveEpochAndGetConfig"%go (![go.PointerType configservice.Clerk] "configCk")) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("epoch" <-[go.uint64] "$r0");;;
    do:  ("conf" <-[config_gk.S] "$r1");;;
    let: "oldServers" := (GoAlloc (go.SliceType go.uint64) (GoZeroVal (go.SliceType go.uint64) #())) in
    let: "$r0" := (![go.SliceType go.uint64] (StructFieldRef config_gk.S "Addrs"%go "conf")) in
    do:  ("oldServers" <-[go.SliceType go.uint64] "$r0");;;
    do:  (let: "$a0" := #"Reserved %d"%go in
    let: "$a1" := ((let: "$sl0" := (Convert go.uint64 go.any (![go.uint64] "epoch")) in
    CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0")]))) in
    (FuncResolve log.Printf [] #()) "$a0" "$a1");;;
    let: "id" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := ((((FuncResolve primitive.RandomUint64 [] #()) #()) +⟨go.uint64⟩ #(W64 1)) %⟨go.uint64⟩ (Convert go.int go.uint64 (let: "$a0" := (![go.SliceType go.uint64] "oldServers") in
    (FuncResolve go.len [go.SliceType go.uint64] #()) "$a0"))) in
    do:  ("id" <-[go.uint64] "$r0");;;
    let: "oldClerk" := (GoAlloc (go.PointerType replica.Clerk) (GoZeroVal (go.PointerType replica.Clerk) #())) in
    let: "$r0" := (let: "$a0" := (![go.uint64] (IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "oldServers", Convert go.uint64 go.int (![go.uint64] "id")))) in
    (FuncResolve replica.MakeClerk [] #()) "$a0") in
    do:  ("oldClerk" <-[go.PointerType replica.Clerk] "$r0");;;
    let: "reply" := (GoAlloc (go.PointerType getstatereply_gk.S) (GoZeroVal (go.PointerType getstatereply_gk.S) #())) in
    let: "$r0" := (let: "$a0" := (GoAlloc getstateargs_gk.S (CompositeLiteral getstateargs_gk.S (LiteralValue [KeyedElement (Some (KeyField "Epoch"%go)) (ElementExpression go.uint64 (![go.uint64] "epoch"))]))) in
    (MethodResolve (go.PointerType replica.Clerk) "GetState"%go (![go.PointerType replica.Clerk] "oldClerk")) "$a0") in
    do:  ("reply" <-[go.PointerType getstatereply_gk.S] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![err_gk.E] (StructFieldRef getstatereply_gk.S "Err"%go (![go.PointerType getstatereply_gk.S] "reply"))) ≠⟨go.uint32⟩ err_gk.None')
    then
      do:  (let: "$a0" := #"Error while getting state and sealing in epoch %d"%go in
      let: "$a1" := ((let: "$sl0" := (Convert go.uint64 go.any (![go.uint64] "epoch")) in
      CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0")]))) in
      (FuncResolve log.Printf [] #()) "$a0" "$a1");;;
      return: (![err_gk.E] (StructFieldRef getstatereply_gk.S "Err"%go (![go.PointerType getstatereply_gk.S] "reply")))
    else do:  #());;;
    let: "clerks" := (GoAlloc (go.SliceType (go.PointerType replica.Clerk)) (GoZeroVal (go.SliceType (go.PointerType replica.Clerk)) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType (go.PointerType replica.Clerk)] #()) (let: "$a0" := (![go.SliceType grove_ffi.Address] "servers") in
    (FuncResolve go.len [go.SliceType grove_ffi.Address] #()) "$a0")) in
    do:  ("clerks" <-[go.SliceType (go.PointerType replica.Clerk)] "$r0");;;
    let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, (![go.uint64] "i") <⟨go.uint64⟩ (Convert go.int go.uint64 (let: "$a0" := (![go.SliceType (go.PointerType replica.Clerk)] "clerks") in
    (FuncResolve go.len [go.SliceType (go.PointerType replica.Clerk)] #()) "$a0"))); (λ: <>, #()) := λ: <>,
      let: "$r0" := (let: "$a0" := (![grove_ffi.Address] (IndexRef (go.SliceType grove_ffi.Address) (![go.SliceType grove_ffi.Address] "servers", Convert go.uint64 go.int (![go.uint64] "i")))) in
      (FuncResolve replica.MakeClerk [] #()) "$a0") in
      do:  ((IndexRef (go.SliceType (go.PointerType replica.Clerk)) (![go.SliceType (go.PointerType replica.Clerk)] "clerks", Convert go.uint64 go.int (![go.uint64] "i"))) <-[go.PointerType replica.Clerk] "$r0");;;
      do:  ("i" <-[go.uint64] ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 1))));;;
    let: "wg" := (GoAlloc (go.PointerType sync.WaitGroup) (GoZeroVal (go.PointerType sync.WaitGroup) #())) in
    let: "$r0" := (GoAlloc sync.WaitGroup (GoZeroVal sync.WaitGroup #())) in
    do:  ("wg" <-[go.PointerType sync.WaitGroup] "$r0");;;
    let: "errs" := (GoAlloc (go.SliceType err_gk.E) (GoZeroVal (go.SliceType err_gk.E) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType err_gk.E] #()) (let: "$a0" := (![go.SliceType (go.PointerType replica.Clerk)] "clerks") in
    (FuncResolve go.len [go.SliceType (go.PointerType replica.Clerk)] #()) "$a0")) in
    do:  ("errs" <-[go.SliceType err_gk.E] "$r0");;;
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, (![go.uint64] "i") <⟨go.uint64⟩ (Convert go.int go.uint64 (let: "$a0" := (![go.SliceType (go.PointerType replica.Clerk)] "clerks") in
    (FuncResolve go.len [go.SliceType (go.PointerType replica.Clerk)] #()) "$a0"))); (λ: <>, #()) := λ: <>,
      do:  (let: "$a0" := #(W64 1) in
      (MethodResolve (go.PointerType sync.WaitGroup) "Add"%go (![go.PointerType sync.WaitGroup] "wg")) "$a0");;;
      let: "clerk" := (GoAlloc (go.PointerType replica.Clerk) (GoZeroVal (go.PointerType replica.Clerk) #())) in
      let: "$r0" := (![go.PointerType replica.Clerk] (IndexRef (go.SliceType (go.PointerType replica.Clerk)) (![go.SliceType (go.PointerType replica.Clerk)] "clerks", Convert go.uint64 go.int (![go.uint64] "i")))) in
      do:  ("clerk" <-[go.PointerType replica.Clerk] "$r0");;;
      let: "locali" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: "$r0" := (![go.uint64] "i") in
      do:  ("locali" <-[go.uint64] "$r0");;;
      let: "$go" := (λ: <>,
        exception_do (let: "$r0" := (let: "$a0" := (GoAlloc setstateargs_gk.S (CompositeLiteral setstateargs_gk.S (LiteralValue [KeyedElement (Some (KeyField "Epoch"%go)) (ElementExpression go.uint64 (![go.uint64] "epoch")); KeyedElement (Some (KeyField "State"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] (StructFieldRef getstatereply_gk.S "State"%go (![go.PointerType getstatereply_gk.S] "reply")))); KeyedElement (Some (KeyField "NextIndex"%go)) (ElementExpression go.uint64 (![go.uint64] (StructFieldRef getstatereply_gk.S "NextIndex"%go (![go.PointerType getstatereply_gk.S] "reply")))); KeyedElement (Some (KeyField "CommittedNextIndex"%go)) (ElementExpression go.uint64 (![go.uint64] (StructFieldRef getstatereply_gk.S "CommittedNextIndex"%go (![go.PointerType getstatereply_gk.S] "reply"))))]))) in
        (MethodResolve (go.PointerType replica.Clerk) "SetState"%go (![go.PointerType replica.Clerk] "clerk")) "$a0") in
        do:  ((IndexRef (go.SliceType err_gk.E) (![go.SliceType err_gk.E] "errs", Convert go.uint64 go.int (![go.uint64] "locali"))) <-[err_gk.E] "$r0");;;
        do:  ((MethodResolve (go.PointerType sync.WaitGroup) "Done"%go (![go.PointerType sync.WaitGroup] "wg")) #());;;
        return: #())
        ) in
      do:  (Fork ("$go" #()));;;
      do:  ("i" <-[go.uint64] ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 1))));;;
    do:  ((MethodResolve (go.PointerType sync.WaitGroup) "Wait"%go (![go.PointerType sync.WaitGroup] "wg")) #());;;
    let: "err" := (GoAlloc err_gk.E (GoZeroVal err_gk.E #())) in
    let: "$r0" := err_gk.None' in
    do:  ("err" <-[err_gk.E] "$r0");;;
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, (![go.uint64] "i") <⟨go.uint64⟩ (Convert go.int go.uint64 (let: "$a0" := (![go.SliceType err_gk.E] "errs") in
    (FuncResolve go.len [go.SliceType err_gk.E] #()) "$a0"))); (λ: <>, #()) := λ: <>,
      let: "err2" := (GoAlloc err_gk.E (GoZeroVal err_gk.E #())) in
      let: "$r0" := (![err_gk.E] (IndexRef (go.SliceType err_gk.E) (![go.SliceType err_gk.E] "errs", Convert go.uint64 go.int (![go.uint64] "i")))) in
      do:  ("err2" <-[err_gk.E] "$r0");;;
      (if: Convert go.untyped_bool go.bool ((![err_gk.E] "err2") ≠⟨go.uint32⟩ err_gk.None')
      then
        let: "$r0" := (![err_gk.E] "err2") in
        do:  ("err" <-[err_gk.E] "$r0")
      else do:  #());;;
      do:  ("i" <-[go.uint64] ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 1))));;;
    (if: Convert go.untyped_bool go.bool ((![err_gk.E] "err") ≠⟨go.uint32⟩ err_gk.None')
    then
      do:  (let: "$a0" := ((let: "$sl0" := (Convert go.string go.any #"Error while setting state and entering new epoch"%go) in
      CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0")]))) in
      (FuncResolve log.Println [] #()) "$a0");;;
      return: (![err_gk.E] "err")
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool ((let: "$a0" := (![go.uint64] "epoch") in
    let: "$a1" := (CompositeLiteral config_gk.S (LiteralValue [KeyedElement (Some (KeyField "Addrs"%go)) (ElementExpression (go.SliceType grove_ffi.Address) (![go.SliceType grove_ffi.Address] "servers"))])) in
    (MethodResolve (go.PointerType configservice.Clerk) "TryWriteConfig"%go (![go.PointerType configservice.Clerk] "configCk")) "$a0" "$a1") ≠⟨go.uint32⟩ err_gk.None')
    then
      do:  (let: "$a0" := ((let: "$sl0" := (Convert go.string go.any #"Error while writing to config service"%go) in
      CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0")]))) in
      (FuncResolve log.Println [] #()) "$a0");;;
      return: (err_gk.Stale)
    else do:  #());;;
    do:  (let: "$a0" := (GoAlloc becomeprimaryargs_gk.S (CompositeLiteral becomeprimaryargs_gk.S (LiteralValue [KeyedElement (Some (KeyField "Epoch"%go)) (ElementExpression go.uint64 (![go.uint64] "epoch")); KeyedElement (Some (KeyField "Conf"%go)) (ElementExpression configuration_gk.S (CompositeLiteral configuration_gk.S (LiteralValue [KeyedElement (Some (KeyField "Replicas"%go)) (ElementExpression (go.SliceType grove_ffi.Address) (![go.SliceType grove_ffi.Address] "servers"))])))]))) in
    (MethodResolve (go.PointerType replica.Clerk) "BecomePrimary"%go (![go.PointerType replica.Clerk] (IndexRef (go.SliceType (go.PointerType replica.Clerk)) (![go.SliceType (go.PointerType replica.Clerk)] "clerks", #(W64 0))))) "$a0");;;
    return: (err_gk.None')).

(* go: init.go:10:6 *)
Definition InitializeSystemⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "configHosts" "servers",
    exception_do (let: "servers" := (GoAlloc (go.SliceType grove_ffi.Address) "servers") in
    let: "configHosts" := (GoAlloc (go.SliceType grove_ffi.Address) "configHosts") in
    let: "configCk" := (GoAlloc (go.PointerType configservice.Clerk) (GoZeroVal (go.PointerType configservice.Clerk) #())) in
    let: "$r0" := (let: "$a0" := (![go.SliceType grove_ffi.Address] "configHosts") in
    (FuncResolve configservice.MakeClerk [] #()) "$a0") in
    do:  ("configCk" <-[go.PointerType configservice.Clerk] "$r0");;;
    do:  (let: "$a0" := #(W64 0) in
    let: "$a1" := (CompositeLiteral config_gk.S (LiteralValue [KeyedElement (Some (KeyField "Addrs"%go)) (ElementExpression (go.SliceType grove_ffi.Address) (![go.SliceType grove_ffi.Address] "servers"))])) in
    (MethodResolve (go.PointerType configservice.Clerk) "TryWriteConfig"%go (![go.PointerType configservice.Clerk] "configCk")) "$a0" "$a1");;;
    return: (let: "$a0" := (![go.SliceType grove_ffi.Address] "configHosts") in
     let: "$a1" := (![go.SliceType grove_ffi.Address] "servers") in
     (FuncResolve EnterNewConfig [] #()) "$a0" "$a1")).

#[global] Instance info' : PkgInfo pkg_id.reconfig :=
{|
  pkg_imported_pkgs := [code.log.pkg_id.log; code.sync.pkg_id.sync; code.github_com.goose_lang.primitive.pkg_id.primitive; code.github_com.mit_pdos.gokv.grove_ffi.pkg_id.grove_ffi; code.github_com.mit_pdos.gokv.reconfig.replica.becomeprimaryargs_gk.pkg_id.becomeprimaryargs_gk; code.github_com.mit_pdos.gokv.reconfig.replica.configuration_gk.pkg_id.configuration_gk; code.github_com.mit_pdos.gokv.vrsm.configservice.pkg_id.configservice; code.github_com.mit_pdos.gokv.vrsm.configservice.config_gk.pkg_id.config_gk; code.github_com.mit_pdos.gokv.vrsm.replica.pkg_id.replica; code.github_com.mit_pdos.gokv.vrsm.replica.err_gk.pkg_id.err_gk; code.github_com.mit_pdos.gokv.vrsm.replica.getstateargs_gk.pkg_id.getstateargs_gk; code.github_com.mit_pdos.gokv.vrsm.replica.setstateargs_gk.pkg_id.setstateargs_gk]
|}.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init pkg_id.reconfig (λ: <>,
      exception_do (do:  (setstateargs_gk.initialize' #());;;
      do:  (getstateargs_gk.initialize' #());;;
      do:  (err_gk.initialize' #());;;
      do:  (replica.initialize' #());;;
      do:  (config_gk.initialize' #());;;
      do:  (configservice.initialize' #());;;
      do:  (configuration_gk.initialize' #());;;
      do:  (becomeprimaryargs_gk.initialize' #());;;
      do:  (grove_ffi.initialize' #());;;
      do:  (primitive.initialize' #());;;
      do:  (sync.initialize' #());;;
      do:  (log.initialize' #()))
      ).

Class Assumptions `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] EnterNewConfig_unfold :: FuncUnfold EnterNewConfig [] (EnterNewConfigⁱᵐᵖˡ);
  #[global] InitializeSystem_unfold :: FuncUnfold InitializeSystem [] (InitializeSystemⁱᵐᵖˡ);
  #[global] import_log_Assumption :: log.Assumptions;
  #[global] import_sync_Assumption :: sync.Assumptions;
  #[global] import_primitive_Assumption :: primitive.Assumptions;
  #[global] import_grove_ffi_Assumption :: grove_ffi.Assumptions;
  #[global] import_becomeprimaryargs_gk_Assumption :: becomeprimaryargs_gk.Assumptions;
  #[global] import_configuration_gk_Assumption :: configuration_gk.Assumptions;
  #[global] import_configservice_Assumption :: configservice.Assumptions;
  #[global] import_config_gk_Assumption :: config_gk.Assumptions;
  #[global] import_replica_Assumption :: replica.Assumptions;
  #[global] import_err_gk_Assumption :: err_gk.Assumptions;
  #[global] import_getstateargs_gk_Assumption :: getstateargs_gk.Assumptions;
  #[global] import_setstateargs_gk_Assumption :: setstateargs_gk.Assumptions;
}.
End reconfig.
