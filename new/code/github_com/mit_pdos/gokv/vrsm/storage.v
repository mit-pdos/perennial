(* autogenerated from github.com/mit-pdos/gokv/vrsm/storage *)
From New.golang Require Import defn.
Require Export New.code.github_com.goose_lang.std.
Require Export New.code.github_com.mit_pdos.gokv.aof.
Require Export New.code.github_com.mit_pdos.gokv.grove_ffi.
Require Export New.code.github_com.mit_pdos.gokv.vrsm.replica.
Require Export New.code.github_com.tchajed.marshal.

Definition storage : go_string := "github.com/mit-pdos/gokv/vrsm/storage".

From New Require Import grove_prelude.
Module storage.
Section code.


Definition InMemoryStateMachine : go_type := structT [
  "ApplyReadonly" :: funcT;
  "ApplyVolatile" :: funcT;
  "GetState" :: funcT;
  "SetState" :: funcT
].

Definition MAX_LOG_SIZE : expr := #(W64 (((64 * 1024) * 1024) * 1024)).

Definition StateMachine : go_type := structT [
  "fname" :: stringT;
  "logFile" :: ptrT;
  "logsize" :: uint64T;
  "sealed" :: boolT;
  "epoch" :: uint64T;
  "nextIndex" :: uint64T;
  "smMem" :: ptrT
].

(* FIXME: better name; this isn't the same as "MakeDurable"

   go: durlog.go:40:24 *)
Definition StateMachine__makeDurableWithSnap : val :=
  rec: "StateMachine__makeDurableWithSnap" "s" "snap" :=
    exception_do (let: "s" := (mem.alloc "s") in
    let: "snap" := (mem.alloc "snap") in
    let: "enc" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make3 #byteT #(W64 0) (((#(W64 8) + (let: "$a0" := (![#sliceT] "snap") in
    slice.len "$a0")) + #(W64 8)) + #(W64 8))) in
    do:  ("enc" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "enc") in
    let: "$a1" := (s_to_w64 (let: "$a0" := (![#sliceT] "snap") in
    slice.len "$a0")) in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("enc" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "enc") in
    let: "$a1" := (![#sliceT] "snap") in
    (func_call #marshal.marshal #"WriteBytes"%go) "$a0" "$a1") in
    do:  ("enc" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "enc") in
    let: "$a1" := (![#uint64T] (struct.field_ref #StateMachine #"epoch"%go (![#ptrT] "s"))) in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("enc" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "enc") in
    let: "$a1" := (![#uint64T] (struct.field_ref #StateMachine #"nextIndex"%go (![#ptrT] "s"))) in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("enc" <-[#sliceT] "$r0");;;
    (if: ![#boolT] (struct.field_ref #StateMachine #"sealed"%go (![#ptrT] "s"))
    then
      do:  (let: "$a0" := (![#sliceT] "enc") in
      let: "$a1" := (slice.make2 #byteT #(W64 1)) in
      (func_call #marshal.marshal #"WriteBytes"%go) "$a0" "$a1")
    else do:  #());;;
    do:  ((method_call #aof #"AppendOnlyFile'ptr" #"Close" (![#ptrT] (struct.field_ref #StateMachine #"logFile"%go (![#ptrT] "s")))) #());;;
    do:  (let: "$a0" := (![#stringT] (struct.field_ref #StateMachine #"fname"%go (![#ptrT] "s"))) in
    let: "$a1" := (![#sliceT] "enc") in
    (func_call #grove_ffi.grove_ffi #"FileWrite"%go) "$a0" "$a1");;;
    let: "$r0" := (let: "$a0" := (![#stringT] (struct.field_ref #StateMachine #"fname"%go (![#ptrT] "s"))) in
    (func_call #aof.aof #"CreateAppendOnlyFile"%go) "$a0") in
    do:  ((struct.field_ref #StateMachine #"logFile"%go (![#ptrT] "s")) <-[#ptrT] "$r0")).

(* XXX: this is not safe to run concurrently with apply()
   requires that the state machine is not sealed

   go: durlog.go:61:24 *)
Definition StateMachine__truncateAndMakeDurable : val :=
  rec: "StateMachine__truncateAndMakeDurable" "s" <> :=
    exception_do (let: "s" := (mem.alloc "s") in
    let: "snap" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := ((![#funcT] (struct.field_ref #InMemoryStateMachine #"GetState"%go (![#ptrT] (struct.field_ref #StateMachine #"smMem"%go (![#ptrT] "s"))))) #()) in
    do:  ("snap" <-[#sliceT] "$r0");;;
    do:  (let: "$a0" := (![#sliceT] "snap") in
    (method_call #storage.storage #"StateMachine'ptr" #"makeDurableWithSnap" (![#ptrT] "s")) "$a0")).

(* go: durlog.go:66:24 *)
Definition StateMachine__apply : val :=
  rec: "StateMachine__apply" "s" "op" :=
    exception_do (let: "s" := (mem.alloc "s") in
    let: "op" := (mem.alloc "op") in
    let: "ret" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "op") in
    (![#funcT] (struct.field_ref #InMemoryStateMachine #"ApplyVolatile"%go (![#ptrT] (struct.field_ref #StateMachine #"smMem"%go (![#ptrT] "s"))))) "$a0") in
    do:  ("ret" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#uint64T] (struct.field_ref #StateMachine #"nextIndex"%go (![#ptrT] "s"))) in
    let: "$a1" := #(W64 1) in
    (func_call #std.std #"SumAssumeNoOverflow"%go) "$a0" "$a1") in
    do:  ((struct.field_ref #StateMachine #"nextIndex"%go (![#ptrT] "s")) <-[#uint64T] "$r0");;;
    do:  ((struct.field_ref #StateMachine #"logsize"%go (![#ptrT] "s")) <-[#uint64T] ((![#uint64T] (struct.field_ref #StateMachine #"logsize"%go (![#ptrT] "s"))) + (s_to_w64 (let: "$a0" := (![#sliceT] "op") in
    slice.len "$a0"))));;;
    let: "opWithLen" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make3 #byteT #(W64 0) (#(W64 8) + (s_to_w64 (let: "$a0" := (![#sliceT] "op") in
    slice.len "$a0")))) in
    do:  ("opWithLen" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "opWithLen") in
    let: "$a1" := (s_to_w64 (let: "$a0" := (![#sliceT] "op") in
    slice.len "$a0")) in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("opWithLen" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "opWithLen") in
    let: "$a1" := (![#sliceT] "op") in
    (func_call #marshal.marshal #"WriteBytes"%go) "$a0" "$a1") in
    do:  ("opWithLen" <-[#sliceT] "$r0");;;
    let: "l" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "opWithLen") in
    (method_call #aof #"AppendOnlyFile'ptr" #"Append" (![#ptrT] (struct.field_ref #StateMachine #"logFile"%go (![#ptrT] "s")))) "$a0") in
    do:  ("l" <-[#uint64T] "$r0");;;
    let: "f" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (![#ptrT] (struct.field_ref #StateMachine #"logFile"%go (![#ptrT] "s"))) in
    do:  ("f" <-[#ptrT] "$r0");;;
    let: "waitFn" := (mem.alloc (type.zero_val #funcT)) in
    let: "$r0" := (Î»: <>,
      exception_do (do:  (let: "$a0" := (![#uint64T] "l") in
      (method_call #aof #"AppendOnlyFile'ptr" #"WaitAppend" (![#ptrT] "f")) "$a0"))
      ) in
    do:  ("waitFn" <-[#funcT] "$r0");;;
    return: (![#sliceT] "ret", ![#funcT] "waitFn")).

(* go: durlog.go:92:24 *)
Definition StateMachine__applyReadonly : val :=
  rec: "StateMachine__applyReadonly" "s" "op" :=
    exception_do (let: "s" := (mem.alloc "s") in
    let: "op" := (mem.alloc "op") in
    let: ("$ret0", "$ret1") := ((let: "$a0" := (![#sliceT] "op") in
    (![#funcT] (struct.field_ref #InMemoryStateMachine #"ApplyReadonly"%go (![#ptrT] (struct.field_ref #StateMachine #"smMem"%go (![#ptrT] "s"))))) "$a0")) in
    return: ("$ret0", "$ret1")).

(* TODO: make the nextIndex and epoch argument order consistent with replica.StateMachine

   go: durlog.go:97:24 *)
Definition StateMachine__setStateAndUnseal : val :=
  rec: "StateMachine__setStateAndUnseal" "s" "snap" "nextIndex" "epoch" :=
    exception_do (let: "s" := (mem.alloc "s") in
    let: "epoch" := (mem.alloc "epoch") in
    let: "nextIndex" := (mem.alloc "nextIndex") in
    let: "snap" := (mem.alloc "snap") in
    let: "$r0" := (![#uint64T] "epoch") in
    do:  ((struct.field_ref #StateMachine #"epoch"%go (![#ptrT] "s")) <-[#uint64T] "$r0");;;
    let: "$r0" := (![#uint64T] "nextIndex") in
    do:  ((struct.field_ref #StateMachine #"nextIndex"%go (![#ptrT] "s")) <-[#uint64T] "$r0");;;
    let: "$r0" := #false in
    do:  ((struct.field_ref #StateMachine #"sealed"%go (![#ptrT] "s")) <-[#boolT] "$r0");;;
    do:  (let: "$a0" := (![#sliceT] "snap") in
    let: "$a1" := (![#uint64T] "nextIndex") in
    (![#funcT] (struct.field_ref #InMemoryStateMachine #"SetState"%go (![#ptrT] (struct.field_ref #StateMachine #"smMem"%go (![#ptrT] "s"))))) "$a0" "$a1");;;
    do:  (let: "$a0" := (![#sliceT] "snap") in
    (method_call #storage.storage #"StateMachine'ptr" #"makeDurableWithSnap" (![#ptrT] "s")) "$a0")).

(* go: durlog.go:105:24 *)
Definition StateMachine__getStateAndSeal : val :=
  rec: "StateMachine__getStateAndSeal" "s" <> :=
    exception_do (let: "s" := (mem.alloc "s") in
    (if: (~ (![#boolT] (struct.field_ref #StateMachine #"sealed"%go (![#ptrT] "s"))))
    then
      let: "$r0" := #true in
      do:  ((struct.field_ref #StateMachine #"sealed"%go (![#ptrT] "s")) <-[#boolT] "$r0");;;
      let: "l" := (mem.alloc (type.zero_val #uint64T)) in
      let: "$r0" := (let: "$a0" := (slice.make2 #byteT #(W64 1)) in
      (method_call #aof #"AppendOnlyFile'ptr" #"Append" (![#ptrT] (struct.field_ref #StateMachine #"logFile"%go (![#ptrT] "s")))) "$a0") in
      do:  ("l" <-[#uint64T] "$r0");;;
      do:  (let: "$a0" := (![#uint64T] "l") in
      (method_call #aof #"AppendOnlyFile'ptr" #"WaitAppend" (![#ptrT] (struct.field_ref #StateMachine #"logFile"%go (![#ptrT] "s")))) "$a0")
    else do:  #());;;
    let: "snap" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := ((![#funcT] (struct.field_ref #InMemoryStateMachine #"GetState"%go (![#ptrT] (struct.field_ref #StateMachine #"smMem"%go (![#ptrT] "s"))))) #()) in
    do:  ("snap" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "snap")).

(* go: durlog.go:118:6 *)
Definition recoverStateMachine : val :=
  rec: "recoverStateMachine" "smMem" "fname" :=
    exception_do (let: "fname" := (mem.alloc "fname") in
    let: "smMem" := (mem.alloc "smMem") in
    let: "s" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (let: "$fname" := (![#stringT] "fname") in
    let: "$smMem" := (![#ptrT] "smMem") in
    struct.make #StateMachine [{
      "fname" ::= "$fname";
      "logFile" ::= type.zero_val #ptrT;
      "logsize" ::= type.zero_val #uint64T;
      "sealed" ::= type.zero_val #boolT;
      "epoch" ::= type.zero_val #uint64T;
      "nextIndex" ::= type.zero_val #uint64T;
      "smMem" ::= "$smMem"
    }])) in
    do:  ("s" <-[#ptrT] "$r0");;;
    let: "enc" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#stringT] (struct.field_ref #StateMachine #"fname"%go (![#ptrT] "s"))) in
    (func_call #grove_ffi.grove_ffi #"FileRead"%go) "$a0") in
    do:  ("enc" <-[#sliceT] "$r0");;;
    (if: (let: "$a0" := (![#sliceT] "enc") in
    slice.len "$a0") = #(W64 0)
    then
      let: "initState" := (mem.alloc (type.zero_val #sliceT)) in
      let: "$r0" := ((![#funcT] (struct.field_ref #InMemoryStateMachine #"GetState"%go (![#ptrT] "smMem"))) #()) in
      do:  ("initState" <-[#sliceT] "$r0");;;
      let: "initialContents" := (mem.alloc (type.zero_val #sliceT)) in
      let: "$r0" := (slice.make3 #byteT #(W64 0) (((#(W64 8) + (s_to_w64 (let: "$a0" := (![#sliceT] "initState") in
      slice.len "$a0"))) + #(W64 8)) + #(W64 8))) in
      do:  ("initialContents" <-[#sliceT] "$r0");;;
      let: "$r0" := (let: "$a0" := (![#sliceT] "initialContents") in
      let: "$a1" := (s_to_w64 (let: "$a0" := (![#sliceT] "initState") in
      slice.len "$a0")) in
      (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
      do:  ("initialContents" <-[#sliceT] "$r0");;;
      let: "$r0" := (let: "$a0" := (![#sliceT] "initialContents") in
      let: "$a1" := (![#sliceT] "initState") in
      (func_call #marshal.marshal #"WriteBytes"%go) "$a0" "$a1") in
      do:  ("initialContents" <-[#sliceT] "$r0");;;
      let: "$r0" := (let: "$a0" := (![#sliceT] "initialContents") in
      let: "$a1" := #(W64 0) in
      (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
      do:  ("initialContents" <-[#sliceT] "$r0");;;
      let: "$r0" := (let: "$a0" := (![#sliceT] "initialContents") in
      let: "$a1" := #(W64 0) in
      (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
      do:  ("initialContents" <-[#sliceT] "$r0");;;
      do:  (let: "$a0" := (![#stringT] (struct.field_ref #StateMachine #"fname"%go (![#ptrT] "s"))) in
      let: "$a1" := (![#sliceT] "initialContents") in
      (func_call #grove_ffi.grove_ffi #"FileWrite"%go) "$a0" "$a1");;;
      let: "$r0" := (let: "$a0" := (![#stringT] "fname") in
      (func_call #aof.aof #"CreateAppendOnlyFile"%go) "$a0") in
      do:  ((struct.field_ref #StateMachine #"logFile"%go (![#ptrT] "s")) <-[#ptrT] "$r0");;;
      return: (![#ptrT] "s")
    else do:  #());;;
    let: "$r0" := (let: "$a0" := (![#stringT] "fname") in
    (func_call #aof.aof #"CreateAppendOnlyFile"%go) "$a0") in
    do:  ((struct.field_ref #StateMachine #"logFile"%go (![#ptrT] "s")) <-[#ptrT] "$r0");;;
    let: "snapLen" := (mem.alloc (type.zero_val #uint64T)) in
    let: "snap" := (mem.alloc (type.zero_val #sliceT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "enc") in
    (func_call #marshal.marshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("snapLen" <-[#uint64T] "$r0");;;
    do:  ("enc" <-[#sliceT] "$r1");;;
    let: "$r0" := (let: "$s" := (![#sliceT] "enc") in
    slice.slice #byteT "$s" #(W64 0) (![#uint64T] "snapLen")) in
    do:  ("snap" <-[#sliceT] "$r0");;;
    let: "n" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "enc") in
    slice.len "$a0") in
    do:  ("n" <-[#intT] "$r0");;;
    let: "$r0" := (let: "$s" := (![#sliceT] "enc") in
    slice.slice #byteT "$s" (![#uint64T] "snapLen") (![#intT] "n")) in
    do:  ("enc" <-[#sliceT] "$r0");;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "enc") in
    (func_call #marshal.marshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ((struct.field_ref #StateMachine #"epoch"%go (![#ptrT] "s")) <-[#uint64T] "$r0");;;
    do:  ("enc" <-[#sliceT] "$r1");;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "enc") in
    (func_call #marshal.marshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ((struct.field_ref #StateMachine #"nextIndex"%go (![#ptrT] "s")) <-[#uint64T] "$r0");;;
    do:  ("enc" <-[#sliceT] "$r1");;;
    do:  (let: "$a0" := (![#sliceT] "snap") in
    let: "$a1" := (![#uint64T] (struct.field_ref #StateMachine #"nextIndex"%go (![#ptrT] "s"))) in
    (![#funcT] (struct.field_ref #InMemoryStateMachine #"SetState"%go (![#ptrT] (struct.field_ref #StateMachine #"smMem"%go (![#ptrT] "s"))))) "$a0" "$a1");;;
    (for: (Î»: <>, #true); (Î»: <>, Skip) := Î»: <>,
      (if: int_gt (let: "$a0" := (![#sliceT] "enc") in
      slice.len "$a0") #(W64 1)
      then
        let: "opLen" := (mem.alloc (type.zero_val #uint64T)) in
        let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "enc") in
        (func_call #marshal.marshal #"ReadInt"%go) "$a0") in
        let: "$r0" := "$ret0" in
        let: "$r1" := "$ret1" in
        do:  ("opLen" <-[#uint64T] "$r0");;;
        do:  ("enc" <-[#sliceT] "$r1");;;
        let: "op" := (mem.alloc (type.zero_val #sliceT)) in
        let: "$r0" := (let: "$s" := (![#sliceT] "enc") in
        slice.slice #byteT "$s" #(W64 0) (![#uint64T] "opLen")) in
        do:  ("op" <-[#sliceT] "$r0");;;
        let: "n" := (mem.alloc (type.zero_val #intT)) in
        let: "$r0" := (let: "$a0" := (![#sliceT] "enc") in
        slice.len "$a0") in
        do:  ("n" <-[#intT] "$r0");;;
        let: "$r0" := (let: "$s" := (![#sliceT] "enc") in
        slice.slice #byteT "$s" (![#uint64T] "opLen") (![#intT] "n")) in
        do:  ("enc" <-[#sliceT] "$r0");;;
        do:  (let: "$a0" := (![#sliceT] "op") in
        (![#funcT] (struct.field_ref #InMemoryStateMachine #"ApplyVolatile"%go (![#ptrT] (struct.field_ref #StateMachine #"smMem"%go (![#ptrT] "s"))))) "$a0");;;
        let: "$r0" := (let: "$a0" := (![#uint64T] (struct.field_ref #StateMachine #"nextIndex"%go (![#ptrT] "s"))) in
        let: "$a1" := #(W64 1) in
        (func_call #std.std #"SumAssumeNoOverflow"%go) "$a0" "$a1") in
        do:  ((struct.field_ref #StateMachine #"nextIndex"%go (![#ptrT] "s")) <-[#uint64T] "$r0")
      else break: #()));;;
    (if: int_gt (let: "$a0" := (![#sliceT] "enc") in
    slice.len "$a0") #(W64 0)
    then
      let: "$r0" := #true in
      do:  ((struct.field_ref #StateMachine #"sealed"%go (![#ptrT] "s")) <-[#boolT] "$r0")
    else do:  #());;;
    return: (![#ptrT] "s")).

(* XXX: putting this here because MakeServer takes nextIndex, epoch, and sealed
   as input, and the user of simplelog won't have access to the private fields
   index, epoch, etc.

   Maybe we should make those be a part of replica.StateMachine

   go: durlog.go:190:6 *)
Definition MakePbServer : val :=
  rec: "MakePbServer" "smMem" "fname" "confHosts" :=
    exception_do (let: "confHosts" := (mem.alloc "confHosts") in
    let: "fname" := (mem.alloc "fname") in
    let: "smMem" := (mem.alloc "smMem") in
    let: "s" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := (![#ptrT] "smMem") in
    let: "$a1" := (![#stringT] "fname") in
    (func_call #storage.storage #"recoverStateMachine"%go) "$a0" "$a1") in
    do:  ("s" <-[#ptrT] "$r0");;;
    let: "sm" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (let: "$StartApply" := (Î»: "op",
      exception_do (let: "op" := (mem.alloc "op") in
      let: ("$ret0", "$ret1") := ((let: "$a0" := (![#sliceT] "op") in
      (method_call #storage.storage #"StateMachine'ptr" #"apply" (![#ptrT] "s")) "$a0")) in
      return: ("$ret0", "$ret1"))
      ) in
    let: "$ApplyReadonly" := (Î»: "op",
      exception_do (let: "op" := (mem.alloc "op") in
      let: ("$ret0", "$ret1") := ((let: "$a0" := (![#sliceT] "op") in
      (method_call #storage.storage #"StateMachine'ptr" #"applyReadonly" (![#ptrT] "s")) "$a0")) in
      return: ("$ret0", "$ret1"))
      ) in
    let: "$SetStateAndUnseal" := (Î»: "snap" "nextIndex" "epoch",
      exception_do (let: "epoch" := (mem.alloc "epoch") in
      let: "nextIndex" := (mem.alloc "nextIndex") in
      let: "snap" := (mem.alloc "snap") in
      do:  (let: "$a0" := (![#sliceT] "snap") in
      let: "$a1" := (![#uint64T] "nextIndex") in
      let: "$a2" := (![#uint64T] "epoch") in
      (method_call #storage.storage #"StateMachine'ptr" #"setStateAndUnseal" (![#ptrT] "s")) "$a0" "$a1" "$a2"))
      ) in
    let: "$GetStateAndSeal" := (Î»: <>,
      exception_do (return: ((method_call #storage.storage #"StateMachine'ptr" #"getStateAndSeal" (![#ptrT] "s")) #()))
      ) in
    struct.make #replica.StateMachine [{
      "StartApply" ::= "$StartApply";
      "ApplyReadonly" ::= "$ApplyReadonly";
      "SetStateAndUnseal" ::= "$SetStateAndUnseal";
      "GetStateAndSeal" ::= "$GetStateAndSeal"
    }])) in
    do:  ("sm" <-[#ptrT] "$r0");;;
    return: (let: "$a0" := (![#ptrT] "sm") in
     let: "$a1" := (![#sliceT] "confHosts") in
     let: "$a2" := (![#uint64T] (struct.field_ref #StateMachine #"nextIndex"%go (![#ptrT] "s"))) in
     let: "$a3" := (![#uint64T] (struct.field_ref #StateMachine #"epoch"%go (![#ptrT] "s"))) in
     let: "$a4" := (![#boolT] (struct.field_ref #StateMachine #"sealed"%go (![#ptrT] "s"))) in
     (func_call #replica.replica #"MakeServer"%go) "$a0" "$a1" "$a2" "$a3" "$a4")).

Definition vars' : list (go_string * go_type) := [].

Definition functions' : list (go_string * val) := [("recoverStateMachine"%go, recoverStateMachine); ("MakePbServer"%go, MakePbServer)].

Definition msets' : list (go_string * (list (go_string * val))) := [("InMemoryStateMachine"%go, []); ("InMemoryStateMachine'ptr"%go, []); ("StateMachine"%go, []); ("StateMachine'ptr"%go, [("apply"%go, StateMachine__apply); ("applyReadonly"%go, StateMachine__applyReadonly); ("getStateAndSeal"%go, StateMachine__getStateAndSeal); ("makeDurableWithSnap"%go, StateMachine__makeDurableWithSnap); ("setStateAndUnseal"%go, StateMachine__setStateAndUnseal); ("truncateAndMakeDurable"%go, StateMachine__truncateAndMakeDurable)])].

#[global] Instance info' : PkgInfo storage.storage :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [std.std; aof.aof; grove_ffi.grove_ffi; replica.replica; marshal.marshal];
  |}.

Definition initialize' : val :=
  rec: "initialize'" <> :=
    globals.package_init storage.storage (Î»: <>,
      exception_do (do:  marshal.initialize';;;
      do:  replica.initialize';;;
      do:  grove_ffi.initialize';;;
      do:  aof.initialize';;;
      do:  std.initialize')
      ).

End code.
End storage.
