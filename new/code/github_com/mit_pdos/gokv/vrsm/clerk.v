(* autogenerated from github.com/mit-pdos/gokv/vrsm/clerk *)
From New.golang Require Import defn.
Require Export New.code.github_com.goose_lang.primitive.
Require Export New.code.github_com.mit_pdos.gokv.grove_ffi.
Require Export New.code.github_com.mit_pdos.gokv.trusted_proph.
Require Export New.code.github_com.mit_pdos.gokv.vrsm.configservice.
Require Export New.code.github_com.mit_pdos.gokv.vrsm.e.
Require Export New.code.github_com.mit_pdos.gokv.vrsm.replica.

Definition clerk : go_string := "github.com/mit-pdos/gokv/vrsm/clerk".

From New Require Import grove_prelude.
Module clerk.
Section code.


(* 1 second *)
Definition PreferenceRefreshTime : expr := #(W64 1000000000).

Definition Clerk : go_type := structT [
  "confCk" :: ptrT;
  "replicaClerks" :: sliceT;
  "preferredReplica" :: uint64T;
  "lastPreferenceRefresh" :: uint64T
].

(* go: clerk.go:23:6 *)
Definition makeClerks : val :=
  rec: "makeClerks" "servers" :=
    exception_do (let: "servers" := (mem.alloc "servers") in
    let: "clerks" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make2 #ptrT (let: "$a0" := (![#sliceT] "servers") in
    slice.len "$a0")) in
    do:  ("clerks" <-[#sliceT] "$r0");;;
    let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (for: (λ: <>, (![#uint64T] "i") < (s_to_w64 (let: "$a0" := (![#sliceT] "clerks") in
    slice.len "$a0"))); (λ: <>, Skip) := λ: <>,
      let: "$r0" := (let: "$a0" := (![#uint64T] (slice.elem_ref #uint64T (![#sliceT] "servers") (![#uint64T] "i"))) in
      (func_call #replica.replica #"MakeClerk"%go) "$a0") in
      do:  ((slice.elem_ref #ptrT (![#sliceT] "clerks") (![#uint64T] "i")) <-[#ptrT] "$r0");;;
      do:  ("i" <-[#uint64T] ((![#uint64T] "i") + #(W64 1))));;;
    return: (![#sliceT] "clerks")).

(* go: clerk.go:33:6 *)
Definition Make : val :=
  rec: "Make" "confHosts" :=
    exception_do (let: "confHosts" := (mem.alloc "confHosts") in
    let: "ck" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #Clerk)) in
    do:  ("ck" <-[#ptrT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "confHosts") in
    (func_call #configservice.configservice #"MakeClerk"%go) "$a0") in
    do:  ((struct.field_ref #Clerk #"confCk"%go (![#ptrT] "ck")) <-[#ptrT] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "config" := (mem.alloc (type.zero_val #sliceT)) in
      let: "$r0" := ((method_call #configservice #"Clerk'ptr" #"GetConfig" (![#ptrT] (struct.field_ref #Clerk #"confCk"%go (![#ptrT] "ck")))) #()) in
      do:  ("config" <-[#sliceT] "$r0");;;
      (if: (let: "$a0" := (![#sliceT] "config") in
      slice.len "$a0") = #(W64 0)
      then continue: #()
      else
        let: "$r0" := (let: "$a0" := (![#sliceT] "config") in
        (func_call #clerk.clerk #"makeClerks"%go) "$a0") in
        do:  ((struct.field_ref #Clerk #"replicaClerks"%go (![#ptrT] "ck")) <-[#sliceT] "$r0");;;
        break: #()));;;
    let: "$r0" := (((func_call #primitive.primitive #"RandomUint64"%go) #()) `rem` (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref #Clerk #"replicaClerks"%go (![#ptrT] "ck"))) in
    slice.len "$a0"))) in
    do:  ((struct.field_ref #Clerk #"preferredReplica"%go (![#ptrT] "ck")) <-[#uint64T] "$r0");;;
    let: ("$ret0", "$ret1") := ((func_call #grove_ffi.grove_ffi #"GetTimeRange"%go) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ((struct.field_ref #Clerk #"lastPreferenceRefresh"%go (![#ptrT] "ck")) <-[#uint64T] "$r0");;;
    do:  "$r1";;;
    return: (![#ptrT] "ck")).

(* will retry forever

   go: clerk.go:51:18 *)
Definition Clerk__Apply : val :=
  rec: "Clerk__Apply" "ck" "op" :=
    exception_do (let: "ck" := (mem.alloc "ck") in
    let: "op" := (mem.alloc "op") in
    let: "ret" := (mem.alloc (type.zero_val #sliceT)) in
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "err" := (mem.alloc (type.zero_val #uint64T)) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "op") in
      (method_call #replica #"Clerk'ptr" #"Apply" (![#ptrT] (slice.elem_ref #ptrT (![#sliceT] (struct.field_ref #Clerk #"replicaClerks"%go (![#ptrT] "ck"))) #(W64 0)))) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("err" <-[#uint64T] "$r0");;;
      do:  ("ret" <-[#sliceT] "$r1");;;
      (if: (![#uint64T] "err") = e.None
      then break: #()
      else
        do:  (let: "$a0" := (#(W64 100) * #(W64 1000000)) in
        (func_call #primitive.primitive #"Sleep"%go) "$a0");;;
        let: "config" := (mem.alloc (type.zero_val #sliceT)) in
        let: "$r0" := ((method_call #configservice #"Clerk'ptr" #"GetConfig" (![#ptrT] (struct.field_ref #Clerk #"confCk"%go (![#ptrT] "ck")))) #()) in
        do:  ("config" <-[#sliceT] "$r0");;;
        (if: int_gt (let: "$a0" := (![#sliceT] "config") in
        slice.len "$a0") #(W64 0)
        then
          let: "$r0" := (let: "$a0" := (![#sliceT] "config") in
          (func_call #clerk.clerk #"makeClerks"%go) "$a0") in
          do:  ((struct.field_ref #Clerk #"replicaClerks"%go (![#ptrT] "ck")) <-[#sliceT] "$r0")
        else do:  #());;;
        continue: #()));;;
    return: (![#sliceT] "ret")).

(* go: clerk.go:71:18 *)
Definition Clerk__maybeRefreshPreference : val :=
  rec: "Clerk__maybeRefreshPreference" "ck" <> :=
    exception_do (let: "ck" := (mem.alloc "ck") in
    let: "now" := (mem.alloc (type.zero_val #uint64T)) in
    let: ("$ret0", "$ret1") := ((func_call #grove_ffi.grove_ffi #"GetTimeRange"%go) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("now" <-[#uint64T] "$r0");;;
    do:  "$r1";;;
    (if: (![#uint64T] "now") > ((![#uint64T] (struct.field_ref #Clerk #"lastPreferenceRefresh"%go (![#ptrT] "ck"))) + PreferenceRefreshTime)
    then
      let: "$r0" := (((func_call #primitive.primitive #"RandomUint64"%go) #()) `rem` (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref #Clerk #"replicaClerks"%go (![#ptrT] "ck"))) in
      slice.len "$a0"))) in
      do:  ((struct.field_ref #Clerk #"preferredReplica"%go (![#ptrT] "ck")) <-[#uint64T] "$r0");;;
      let: ("$ret0", "$ret1") := ((func_call #grove_ffi.grove_ffi #"GetTimeRange"%go) #()) in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ((struct.field_ref #Clerk #"lastPreferenceRefresh"%go (![#ptrT] "ck")) <-[#uint64T] "$r0");;;
      do:  "$r1"
    else do:  #())).

(* go: clerk.go:79:18 *)
Definition Clerk__ApplyRo2 : val :=
  rec: "Clerk__ApplyRo2" "ck" "op" :=
    exception_do (let: "ck" := (mem.alloc "ck") in
    let: "op" := (mem.alloc "op") in
    let: "ret" := (mem.alloc (type.zero_val #sliceT)) in
    do:  ((method_call #clerk.clerk #"Clerk'ptr" #"maybeRefreshPreference" (![#ptrT] "ck")) #());;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "offset" := (mem.alloc (type.zero_val #uint64T)) in
      let: "$r0" := (![#uint64T] (struct.field_ref #Clerk #"preferredReplica"%go (![#ptrT] "ck"))) in
      do:  ("offset" <-[#uint64T] "$r0");;;
      let: "err" := (mem.alloc (type.zero_val #uint64T)) in
      let: "i" := (mem.alloc (type.zero_val #uint64T)) in
      (for: (λ: <>, (![#uint64T] "i") < (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref #Clerk #"replicaClerks"%go (![#ptrT] "ck"))) in
      slice.len "$a0"))); (λ: <>, Skip) := λ: <>,
        let: "k" := (mem.alloc (type.zero_val #uint64T)) in
        let: "$r0" := (((![#uint64T] "i") + (![#uint64T] "offset")) `rem` (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref #Clerk #"replicaClerks"%go (![#ptrT] "ck"))) in
        slice.len "$a0"))) in
        do:  ("k" <-[#uint64T] "$r0");;;
        let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "op") in
        (method_call #replica #"Clerk'ptr" #"ApplyRo" (![#ptrT] (slice.elem_ref #ptrT (![#sliceT] (struct.field_ref #Clerk #"replicaClerks"%go (![#ptrT] "ck"))) (![#uint64T] "k")))) "$a0") in
        let: "$r0" := "$ret0" in
        let: "$r1" := "$ret1" in
        do:  ("err" <-[#uint64T] "$r0");;;
        do:  ("ret" <-[#sliceT] "$r1");;;
        (if: (![#uint64T] "err") = e.None
        then
          let: "$r0" := (![#uint64T] "k") in
          do:  ((struct.field_ref #Clerk #"preferredReplica"%go (![#ptrT] "ck")) <-[#uint64T] "$r0");;;
          break: #()
        else do:  #());;;
        do:  ("i" <-[#uint64T] ((![#uint64T] "i") + #(W64 1)));;;
        let: ("$ret0", "$ret1") := ((func_call #grove_ffi.grove_ffi #"GetTimeRange"%go) #()) in
        let: "$r0" := "$ret0" in
        let: "$r1" := "$ret1" in
        do:  ((struct.field_ref #Clerk #"lastPreferenceRefresh"%go (![#ptrT] "ck")) <-[#uint64T] "$r0");;;
        do:  "$r1";;;
        continue: #());;;
      (if: (![#uint64T] "err") = e.None
      then break: #()
      else
        let: "timeToSleep" := (mem.alloc (type.zero_val #uint64T)) in
        let: "$r0" := (#(W64 5) + (((func_call #primitive.primitive #"RandomUint64"%go) #()) `rem` #(W64 10))) in
        do:  ("timeToSleep" <-[#uint64T] "$r0");;;
        do:  (let: "$a0" := ((![#uint64T] "timeToSleep") * #(W64 1000000)) in
        (func_call #primitive.primitive #"Sleep"%go) "$a0");;;
        let: "config" := (mem.alloc (type.zero_val #sliceT)) in
        let: "$r0" := ((method_call #configservice #"Clerk'ptr" #"GetConfig" (![#ptrT] (struct.field_ref #Clerk #"confCk"%go (![#ptrT] "ck")))) #()) in
        do:  ("config" <-[#sliceT] "$r0");;;
        (if: int_gt (let: "$a0" := (![#sliceT] "config") in
        slice.len "$a0") #(W64 0)
        then
          let: "$r0" := (let: "$a0" := (![#sliceT] "config") in
          (func_call #clerk.clerk #"makeClerks"%go) "$a0") in
          do:  ((struct.field_ref #Clerk #"replicaClerks"%go (![#ptrT] "ck")) <-[#sliceT] "$r0");;;
          let: ("$ret0", "$ret1") := ((func_call #grove_ffi.grove_ffi #"GetTimeRange"%go) #()) in
          let: "$r0" := "$ret0" in
          let: "$r1" := "$ret1" in
          do:  ((struct.field_ref #Clerk #"lastPreferenceRefresh"%go (![#ptrT] "ck")) <-[#uint64T] "$r0");;;
          do:  "$r1";;;
          let: "$r0" := (((func_call #primitive.primitive #"RandomUint64"%go) #()) `rem` (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref #Clerk #"replicaClerks"%go (![#ptrT] "ck"))) in
          slice.len "$a0"))) in
          do:  ((struct.field_ref #Clerk #"preferredReplica"%go (![#ptrT] "ck")) <-[#uint64T] "$r0")
        else do:  #());;;
        continue: #()));;;
    return: (![#sliceT] "ret")).

(* go: clerk.go:118:18 *)
Definition Clerk__ApplyRo : val :=
  rec: "Clerk__ApplyRo" "ck" "op" :=
    exception_do (let: "ck" := (mem.alloc "ck") in
    let: "op" := (mem.alloc "op") in
    let: "p" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := ((func_call #trusted_proph.trusted_proph #"NewProph"%go) #()) in
    do:  ("p" <-[#ptrT] "$r0");;;
    let: "v" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "op") in
    (method_call #clerk.clerk #"Clerk'ptr" #"ApplyRo2" (![#ptrT] "ck")) "$a0") in
    do:  ("v" <-[#sliceT] "$r0");;;
    do:  (let: "$a0" := (![#ptrT] "p") in
    let: "$a1" := (![#sliceT] "v") in
    (func_call #trusted_proph.trusted_proph #"ResolveBytes"%go) "$a0" "$a1");;;
    return: (![#sliceT] "v")).

Definition vars' : list (go_string * go_type) := [].

Definition functions' : list (go_string * val) := [("makeClerks"%go, makeClerks); ("Make"%go, Make)].

Definition msets' : list (go_string * (list (go_string * val))) := [("Clerk"%go, []); ("Clerk'ptr"%go, [("Apply"%go, Clerk__Apply); ("ApplyRo"%go, Clerk__ApplyRo); ("ApplyRo2"%go, Clerk__ApplyRo2); ("maybeRefreshPreference"%go, Clerk__maybeRefreshPreference)])].

#[global] Instance info' : PkgInfo clerk.clerk :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [primitive.primitive; grove_ffi.grove_ffi; trusted_proph.trusted_proph; configservice.configservice; e.e; replica.replica];
  |}.

Definition initialize' : val :=
  rec: "initialize'" <> :=
    globals.package_init clerk.clerk (λ: <>,
      exception_do (do:  replica.initialize';;;
      do:  e.initialize';;;
      do:  configservice.initialize';;;
      do:  trusted_proph.initialize';;;
      do:  grove_ffi.initialize';;;
      do:  primitive.initialize')
      ).

End code.
End clerk.
