(* autogenerated from github.com/mit-pdos/gokv/vrsm/replica *)
Require Export New.code.github_com.goose_lang.primitive.
Require Export New.code.github_com.goose_lang.std.
Require Export New.code.github_com.mit_pdos.gokv.grove_ffi.
Require Export New.code.github_com.mit_pdos.gokv.reconfig.replica.becomeprimaryargs_gk.
Require Export New.code.github_com.mit_pdos.gokv.reconnectclient.
Require Export New.code.github_com.mit_pdos.gokv.urpc.
Require Export New.code.github_com.mit_pdos.gokv.vrsm.configservice.
Require Export New.code.github_com.mit_pdos.gokv.vrsm.replica.applyasbackupargs_gk.
Require Export New.code.github_com.mit_pdos.gokv.vrsm.replica.applyreply_gk.
Require Export New.code.github_com.mit_pdos.gokv.vrsm.replica.becomeprimaryargs_gk.
Require Export New.code.github_com.mit_pdos.gokv.vrsm.replica.err_gk.
Require Export New.code.github_com.mit_pdos.gokv.vrsm.replica.getstateargs_gk.
Require Export New.code.github_com.mit_pdos.gokv.vrsm.replica.getstatereply_gk.
Require Export New.code.github_com.mit_pdos.gokv.vrsm.replica.increasecommitargs_gk.
Require Export New.code.github_com.mit_pdos.gokv.vrsm.replica.setstateargs_gk.
Require Export New.code.log.
Require Export New.code.sync.

From New.golang Require Import defn.
Definition replica : go_string := "github.com/mit-pdos/gokv/vrsm/replica".

From New Require Import grove_prelude.
Module replica.

Module Op. Definition id : go_string := sliceT.id byteT.id. End Op.
Module StateMachine. Definition id : go_string := "github.com/mit-pdos/gokv/vrsm/replica.StateMachine"%go. End StateMachine.
Module SyncStateMachine. Definition id : go_string := "github.com/mit-pdos/gokv/vrsm/replica.SyncStateMachine"%go. End SyncStateMachine.
Module Clerk. Definition id : go_string := "github.com/mit-pdos/gokv/vrsm/replica.Clerk"%go. End Clerk.
Module Server. Definition id : go_string := "github.com/mit-pdos/gokv/vrsm/replica.Server"%go. End Server.

Section code.


Definition Op : go_type := sliceT.
#[global] Typeclasses Opaque Op.
#[global] Opaque Op.

Definition StateMachine : go_type := structT [
  "StartApply" :: funcT;
  "ApplyReadonly" :: funcT;
  "SetStateAndUnseal" :: funcT;
  "GetStateAndSeal" :: funcT
].
#[global] Typeclasses Opaque StateMachine.
#[global] Opaque StateMachine.

Definition SyncStateMachine : go_type := structT [
  "Apply" :: funcT;
  "ApplyReadonly" :: funcT;
  "SetStateAndUnseal" :: funcT;
  "GetStateAndSeal" :: funcT
].
#[global] Typeclasses Opaque SyncStateMachine.
#[global] Opaque SyncStateMachine.

Definition Clerk : go_type := structT [
  "cl" :: ptrT
].
#[global] Typeclasses Opaque Clerk.
#[global] Opaque Clerk.

Definition RPC_APPLYASBACKUP : val := #(W64 0).

Definition RPC_SETSTATE : val := #(W64 1).

Definition RPC_GETSTATE : val := #(W64 2).

Definition RPC_BECOMEPRIMARY : val := #(W64 3).

Definition RPC_PRIMARYAPPLY : val := #(W64 4).

Definition RPC_ROPRIMARYAPPLY : val := #(W64 6).

Definition RPC_INCREASECOMMIT : val := #(W64 7).

Definition MakeClerk : go_string := "github.com/mit-pdos/gokv/vrsm/replica.MakeClerk"%go.

(* go: clerk.go:31:6 *)
Definition MakeClerkⁱᵐᵖˡ : val :=
  λ: "host",
    exception_do (let: "host" := (mem.alloc "host") in
    return: (mem.alloc (let: "$cl" := (let: "$a0" := (![#uint64T] "host") in
     (func_call #reconnectclient.MakeReconnectingClient) "$a0") in
     struct.make #Clerk [{
       "cl" ::= "$cl"
     }]))).

(* go: clerk.go:35:18 *)
Definition Clerk__ApplyAsBackupⁱᵐᵖˡ : val :=
  λ: "ck" "args",
    exception_do (let: "ck" := (mem.alloc "ck") in
    let: "args" := (mem.alloc "args") in
    let: "reply" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #sliceT)) in
    do:  ("reply" <-[#ptrT] "$r0");;;
    let: "err" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (let: "$a0" := RPC_APPLYASBACKUP in
    let: "$a1" := (let: "$a0" := (slice.make2 #byteT #(W64 0)) in
    let: "$a1" := (![#applyasbackupargs_gk.S] (![#ptrT] "args")) in
    (func_call #applyasbackupargs_gk.Marshal) "$a0" "$a1") in
    let: "$a2" := (![#ptrT] "reply") in
    let: "$a3" := #(W64 1000) in
    (method_call #(ptrT.id reconnectclient.ReconnectingClient.id) #"Call"%go (![#ptrT] (struct.field_ref #Clerk #"cl"%go (![#ptrT] "ck")))) "$a0" "$a1" "$a2" "$a3") in
    do:  ("err" <-[#uint64T] "$r0");;;
    (if: (![#uint64T] "err") ≠ #(W64 0)
    then return: (err_gk.Timeout)
    else
      let: "e" := (mem.alloc (type.zero_val #err_gk.E)) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] (![#ptrT] "reply")) in
      (func_call #err_gk.Unmarshal) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("e" <-[#err_gk.E] "$r0");;;
      do:  "$r1";;;
      return: (![#err_gk.E] "e"))).

(* go: clerk.go:46:18 *)
Definition Clerk__SetStateⁱᵐᵖˡ : val :=
  λ: "ck" "args",
    exception_do (let: "ck" := (mem.alloc "ck") in
    let: "args" := (mem.alloc "args") in
    let: "reply" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #sliceT)) in
    do:  ("reply" <-[#ptrT] "$r0");;;
    let: "err" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (let: "$a0" := RPC_SETSTATE in
    let: "$a1" := (let: "$a0" := (slice.make2 #byteT #(W64 0)) in
    let: "$a1" := (![#setstateargs_gk.S] (![#ptrT] "args")) in
    (func_call #setstateargs_gk.Marshal) "$a0" "$a1") in
    let: "$a2" := (![#ptrT] "reply") in
    let: "$a3" := #(W64 10000) in
    (method_call #(ptrT.id reconnectclient.ReconnectingClient.id) #"Call"%go (![#ptrT] (struct.field_ref #Clerk #"cl"%go (![#ptrT] "ck")))) "$a0" "$a1" "$a2" "$a3") in
    do:  ("err" <-[#uint64T] "$r0");;;
    (if: (![#uint64T] "err") ≠ #(W64 0)
    then return: (err_gk.Timeout)
    else
      let: "e" := (mem.alloc (type.zero_val #err_gk.E)) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] (![#ptrT] "reply")) in
      (func_call #err_gk.Unmarshal) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("e" <-[#err_gk.E] "$r0");;;
      do:  "$r1";;;
      return: (![#err_gk.E] "e"))).

(* go: clerk.go:57:18 *)
Definition Clerk__GetStateⁱᵐᵖˡ : val :=
  λ: "ck" "args",
    exception_do (let: "ck" := (mem.alloc "ck") in
    let: "args" := (mem.alloc "args") in
    let: "reply" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #sliceT)) in
    do:  ("reply" <-[#ptrT] "$r0");;;
    let: "err" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (let: "$a0" := RPC_GETSTATE in
    let: "$a1" := (let: "$a0" := (slice.make2 #byteT #(W64 0)) in
    let: "$a1" := (![#getstateargs_gk.S] (![#ptrT] "args")) in
    (func_call #getstateargs_gk.Marshal) "$a0" "$a1") in
    let: "$a2" := (![#ptrT] "reply") in
    let: "$a3" := #(W64 10000) in
    (method_call #(ptrT.id reconnectclient.ReconnectingClient.id) #"Call"%go (![#ptrT] (struct.field_ref #Clerk #"cl"%go (![#ptrT] "ck")))) "$a0" "$a1" "$a2" "$a3") in
    do:  ("err" <-[#uint64T] "$r0");;;
    (if: (![#uint64T] "err") ≠ #(W64 0)
    then
      return: (mem.alloc (let: "$Err" := err_gk.Timeout in
       struct.make #getstatereply_gk.S [{
         "Err" ::= "$Err";
         "NextIndex" ::= type.zero_val #uint64T;
         "CommittedNextIndex" ::= type.zero_val #uint64T;
         "State" ::= type.zero_val #sliceT
       }]))
    else
      let: "rep" := (mem.alloc (type.zero_val #getstatereply_gk.S)) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] (![#ptrT] "reply")) in
      (func_call #getstatereply_gk.Unmarshal) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("rep" <-[#getstatereply_gk.S] "$r0");;;
      do:  "$r1";;;
      return: ("rep"))).

(* go: clerk.go:70:18 *)
Definition Clerk__BecomePrimaryⁱᵐᵖˡ : val :=
  λ: "ck" "args",
    exception_do (let: "ck" := (mem.alloc "ck") in
    let: "args" := (mem.alloc "args") in
    let: "reply" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #sliceT)) in
    do:  ("reply" <-[#ptrT] "$r0");;;
    let: "err" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (let: "$a0" := RPC_BECOMEPRIMARY in
    let: "$a1" := (let: "$a0" := (slice.make2 #byteT #(W64 0)) in
    let: "$a1" := (![#becomeprimaryargs_gk.S] (![#ptrT] "args")) in
    (func_call #becomeprimaryargs_gk.Marshal) "$a0" "$a1") in
    let: "$a2" := (![#ptrT] "reply") in
    let: "$a3" := #(W64 100) in
    (method_call #(ptrT.id reconnectclient.ReconnectingClient.id) #"Call"%go (![#ptrT] (struct.field_ref #Clerk #"cl"%go (![#ptrT] "ck")))) "$a0" "$a1" "$a2" "$a3") in
    do:  ("err" <-[#uint64T] "$r0");;;
    (if: (![#uint64T] "err") ≠ #(W64 0)
    then return: (err_gk.Timeout)
    else
      let: "e" := (mem.alloc (type.zero_val #err_gk.E)) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] (![#ptrT] "reply")) in
      (func_call #err_gk.Unmarshal) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("e" <-[#err_gk.E] "$r0");;;
      do:  "$r1";;;
      return: (![#err_gk.E] "e"))).

(* go: clerk.go:81:18 *)
Definition Clerk__Applyⁱᵐᵖˡ : val :=
  λ: "ck" "op",
    exception_do (let: "ck" := (mem.alloc "ck") in
    let: "op" := (mem.alloc "op") in
    let: "reply" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #sliceT)) in
    do:  ("reply" <-[#ptrT] "$r0");;;
    let: "err" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (let: "$a0" := RPC_PRIMARYAPPLY in
    let: "$a1" := (![#sliceT] "op") in
    let: "$a2" := (![#ptrT] "reply") in
    let: "$a3" := #(W64 5000) in
    (method_call #(ptrT.id reconnectclient.ReconnectingClient.id) #"Call"%go (![#ptrT] (struct.field_ref #Clerk #"cl"%go (![#ptrT] "ck")))) "$a0" "$a1" "$a2" "$a3") in
    do:  ("err" <-[#uint64T] "$r0");;;
    (if: (![#uint64T] "err") = #(W64 0)
    then
      let: "r" := (mem.alloc (type.zero_val #applyreply_gk.S)) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] (![#ptrT] "reply")) in
      (func_call #applyreply_gk.Unmarshal) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("r" <-[#applyreply_gk.S] "$r0");;;
      do:  "$r1";;;
      return: (![#err_gk.E] (struct.field_ref #applyreply_gk.S #"Err"%go "r"), ![#sliceT] (struct.field_ref #applyreply_gk.S #"Reply"%go "r"))
    else return: (err_gk.Timeout, #slice.nil))).

(* go: clerk.go:92:18 *)
Definition Clerk__ApplyRoⁱᵐᵖˡ : val :=
  λ: "ck" "op",
    exception_do (let: "ck" := (mem.alloc "ck") in
    let: "op" := (mem.alloc "op") in
    let: "reply" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #sliceT)) in
    do:  ("reply" <-[#ptrT] "$r0");;;
    let: "err" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (let: "$a0" := RPC_ROPRIMARYAPPLY in
    let: "$a1" := (![#sliceT] "op") in
    let: "$a2" := (![#ptrT] "reply") in
    let: "$a3" := #(W64 1000) in
    (method_call #(ptrT.id reconnectclient.ReconnectingClient.id) #"Call"%go (![#ptrT] (struct.field_ref #Clerk #"cl"%go (![#ptrT] "ck")))) "$a0" "$a1" "$a2" "$a3") in
    do:  ("err" <-[#uint64T] "$r0");;;
    (if: (![#uint64T] "err") = #(W64 0)
    then
      let: "r" := (mem.alloc (type.zero_val #applyreply_gk.S)) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] (![#ptrT] "reply")) in
      (func_call #applyreply_gk.Unmarshal) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("r" <-[#applyreply_gk.S] "$r0");;;
      do:  "$r1";;;
      return: (![#err_gk.E] (struct.field_ref #applyreply_gk.S #"Err"%go "r"), ![#sliceT] (struct.field_ref #applyreply_gk.S #"Reply"%go "r"))
    else return: (err_gk.Timeout, #slice.nil))).

(* go: clerk.go:103:18 *)
Definition Clerk__IncreaseCommitIndexⁱᵐᵖˡ : val :=
  λ: "ck" "n",
    exception_do (let: "ck" := (mem.alloc "ck") in
    let: "n" := (mem.alloc "n") in
    return: (u_to_w32 (let: "$a0" := RPC_INCREASECOMMIT in
     let: "$a1" := (let: "$a0" := (slice.make2 #byteT #(W64 0)) in
     let: "$a1" := (let: "$V" := (![#uint64T] "n") in
     struct.make #increasecommitargs_gk.S [{
       "V" ::= "$V"
     }]) in
     (func_call #increasecommitargs_gk.Marshal) "$a0" "$a1") in
     let: "$a2" := (mem.alloc (type.zero_val #sliceT)) in
     let: "$a3" := #(W64 100) in
     (method_call #(ptrT.id reconnectclient.ReconnectingClient.id) #"Call"%go (![#ptrT] (struct.field_ref #Clerk #"cl"%go (![#ptrT] "ck")))) "$a0" "$a1" "$a2" "$a3"))).

Definition Server : go_type := structT [
  "mu" :: ptrT;
  "epoch" :: uint64T;
  "sealed" :: boolT;
  "sm" :: ptrT;
  "nextIndex" :: uint64T;
  "canBecomePrimary" :: boolT;
  "isPrimary" :: boolT;
  "clerks" :: sliceT;
  "isPrimary_cond" :: ptrT;
  "opAppliedConds" :: mapT uint64T ptrT;
  "leaseExpiration" :: uint64T;
  "leaseValid" :: boolT;
  "committedNextIndex" :: uint64T;
  "committedNextIndex_cond" :: ptrT;
  "confCk" :: ptrT
].
#[global] Typeclasses Opaque Server.
#[global] Opaque Server.

(* Applies the RO op immediately, but then waits for it to be committed before
   replying to client.

   go: server.go:52:18 *)
Definition Server__ApplyRoWaitForCommitⁱᵐᵖˡ : val :=
  λ: "s" "op",
    exception_do (let: "s" := (mem.alloc "s") in
    let: "op" := (mem.alloc "op") in
    let: "reply" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #applyreply_gk.S)) in
    do:  ("reply" <-[#ptrT] "$r0");;;
    let: "$r0" := #slice.nil in
    do:  ((struct.field_ref #applyreply_gk.S #"Reply"%go (![#ptrT] "reply")) <-[#sliceT] "$r0");;;
    let: "$r0" := err_gk.None in
    do:  ((struct.field_ref #applyreply_gk.S #"Err"%go (![#ptrT] "reply")) <-[#err_gk.E] "$r0");;;
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #());;;
    (if: (~ (![#boolT] (struct.field_ref #Server #"leaseValid"%go (![#ptrT] "s"))))
    then
      do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #());;;
      do:  (let: "$a0" := #"Lease invalid"%go in
      let: "$a1" := #slice.nil in
      (func_call #log.Printf) "$a0" "$a1");;;
      let: "$r0" := err_gk.LeaseExpired in
      do:  ((struct.field_ref #applyreply_gk.S #"Err"%go (![#ptrT] "reply")) <-[#err_gk.E] "$r0");;;
      return: (![#ptrT] "reply")
    else do:  #());;;
    (if: (((func_call #primitive.RandomUint64) #()) `rem` #(W64 10000)) = #(W64 0)
    then
      do:  (let: "$a0" := #"Server nextIndex=%d commitIndex=%d"%go in
      let: "$a1" := ((let: "$sl0" := (interface.make #uint64T.id (![#uint64T] (struct.field_ref #Server #"nextIndex"%go (![#ptrT] "s")))) in
      let: "$sl1" := (interface.make #uint64T.id (![#uint64T] (struct.field_ref #Server #"committedNextIndex"%go (![#ptrT] "s")))) in
      slice.literal #interfaceT ["$sl0"; "$sl1"])) in
      (func_call #log.Printf) "$a0" "$a1")
    else do:  #());;;
    let: "lastModifiedIndex" := (mem.alloc (type.zero_val #uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "op") in
    (![#funcT] (struct.field_ref #StateMachine #"ApplyReadonly"%go (![#ptrT] (struct.field_ref #Server #"sm"%go (![#ptrT] "s"))))) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("lastModifiedIndex" <-[#uint64T] "$r0");;;
    do:  ((struct.field_ref #applyreply_gk.S #"Reply"%go (![#ptrT] "reply")) <-[#sliceT] "$r1");;;
    let: "epoch" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (![#uint64T] (struct.field_ref #Server #"epoch"%go (![#ptrT] "s"))) in
    do:  ("epoch" <-[#uint64T] "$r0");;;
    let: "h" := (mem.alloc (type.zero_val #uint64T)) in
    let: ("$ret0", "$ret1") := ((func_call #grove_ffi.GetTimeRange) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  "$r0";;;
    do:  ("h" <-[#uint64T] "$r1");;;
    (if: (![#uint64T] (struct.field_ref #Server #"leaseExpiration"%go (![#ptrT] "s"))) ≤ (![#uint64T] "h")
    then
      do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #());;;
      do:  (let: "$a0" := #"Lease expired because %d < %d"%go in
      let: "$a1" := ((let: "$sl0" := (interface.make #uint64T.id (![#uint64T] (struct.field_ref #Server #"leaseExpiration"%go (![#ptrT] "s")))) in
      let: "$sl1" := (interface.make #uint64T.id (![#uint64T] "h")) in
      slice.literal #interfaceT ["$sl0"; "$sl1"])) in
      (func_call #log.Printf) "$a0" "$a1");;;
      let: "$r0" := err_gk.LeaseExpired in
      do:  ((struct.field_ref #applyreply_gk.S #"Err"%go (![#ptrT] "reply")) <-[#err_gk.E] "$r0");;;
      return: (![#ptrT] "reply")
    else do:  #());;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (if: (![#uint64T] (struct.field_ref #Server #"epoch"%go (![#ptrT] "s"))) ≠ (![#uint64T] "epoch")
      then
        let: "$r0" := err_gk.Stale in
        do:  ((struct.field_ref #applyreply_gk.S #"Err"%go (![#ptrT] "reply")) <-[#err_gk.E] "$r0");;;
        break: #()
      else
        (if: (![#uint64T] "lastModifiedIndex") ≤ (![#uint64T] (struct.field_ref #Server #"committedNextIndex"%go (![#ptrT] "s")))
        then
          let: "$r0" := err_gk.None in
          do:  ((struct.field_ref #applyreply_gk.S #"Err"%go (![#ptrT] "reply")) <-[#err_gk.E] "$r0");;;
          break: #()
        else
          do:  ((method_call #(ptrT.id sync.Cond.id) #"Wait"%go (![#ptrT] (struct.field_ref #Server #"committedNextIndex_cond"%go (![#ptrT] "s")))) #());;;
          continue: #())));;;
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #());;;
    return: (![#ptrT] "reply")).

(* precondition:
   is_epoch_lb epoch ∗ committed_by epoch log ∗ is_pb_log_lb log

   go: server.go:102:18 *)
Definition Server__IncreaseCommitIndexⁱᵐᵖˡ : val :=
  λ: "s" "newCommittedNextIndex",
    exception_do (let: "s" := (mem.alloc "s") in
    let: "newCommittedNextIndex" := (mem.alloc "newCommittedNextIndex") in
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #());;;
    (if: ((![#uint64T] "newCommittedNextIndex") > (![#uint64T] (struct.field_ref #Server #"committedNextIndex"%go (![#ptrT] "s")))) && ((![#uint64T] "newCommittedNextIndex") ≤ (![#uint64T] (struct.field_ref #Server #"nextIndex"%go (![#ptrT] "s"))))
    then
      let: "$r0" := (![#uint64T] "newCommittedNextIndex") in
      do:  ((struct.field_ref #Server #"committedNextIndex"%go (![#ptrT] "s")) <-[#uint64T] "$r0");;;
      do:  ((method_call #(ptrT.id sync.Cond.id) #"Broadcast"%go (![#ptrT] (struct.field_ref #Server #"committedNextIndex_cond"%go (![#ptrT] "s")))) #())
    else do:  #());;;
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #());;;
    return: #()).

(* called on the primary server to apply a new operation.

   go: server.go:113:18 *)
Definition Server__Applyⁱᵐᵖˡ : val :=
  λ: "s" "op",
    exception_do (let: "s" := (mem.alloc "s") in
    let: "op" := (mem.alloc "op") in
    let: "reply" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #applyreply_gk.S)) in
    do:  ("reply" <-[#ptrT] "$r0");;;
    let: "$r0" := #slice.nil in
    do:  ((struct.field_ref #applyreply_gk.S #"Reply"%go (![#ptrT] "reply")) <-[#sliceT] "$r0");;;
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #());;;
    (if: (~ (![#boolT] (struct.field_ref #Server #"isPrimary"%go (![#ptrT] "s"))))
    then
      do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #());;;
      let: "$r0" := err_gk.Stale in
      do:  ((struct.field_ref #applyreply_gk.S #"Err"%go (![#ptrT] "reply")) <-[#err_gk.E] "$r0");;;
      return: (![#ptrT] "reply")
    else do:  #());;;
    (if: ![#boolT] (struct.field_ref #Server #"sealed"%go (![#ptrT] "s"))
    then
      do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #());;;
      let: "$r0" := err_gk.Stale in
      do:  ((struct.field_ref #applyreply_gk.S #"Err"%go (![#ptrT] "reply")) <-[#err_gk.E] "$r0");;;
      return: (![#ptrT] "reply")
    else do:  #());;;
    let: "waitForDurable" := (mem.alloc (type.zero_val #funcT)) in
    let: "ret" := (mem.alloc (type.zero_val #sliceT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "op") in
    (![#funcT] (struct.field_ref #StateMachine #"StartApply"%go (![#ptrT] (struct.field_ref #Server #"sm"%go (![#ptrT] "s"))))) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("ret" <-[#sliceT] "$r0");;;
    do:  ("waitForDurable" <-[#funcT] "$r1");;;
    let: "$r0" := (![#sliceT] "ret") in
    do:  ((struct.field_ref #applyreply_gk.S #"Reply"%go (![#ptrT] "reply")) <-[#sliceT] "$r0");;;
    let: "opIndex" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (![#uint64T] (struct.field_ref #Server #"nextIndex"%go (![#ptrT] "s"))) in
    do:  ("opIndex" <-[#uint64T] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#uint64T] (struct.field_ref #Server #"nextIndex"%go (![#ptrT] "s"))) in
    let: "$a1" := #(W64 1) in
    (func_call #std.SumAssumeNoOverflow) "$a0" "$a1") in
    do:  ((struct.field_ref #Server #"nextIndex"%go (![#ptrT] "s")) <-[#uint64T] "$r0");;;
    let: "nextIndex" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (![#uint64T] (struct.field_ref #Server #"nextIndex"%go (![#ptrT] "s"))) in
    do:  ("nextIndex" <-[#uint64T] "$r0");;;
    let: "epoch" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (![#uint64T] (struct.field_ref #Server #"epoch"%go (![#ptrT] "s"))) in
    do:  ("epoch" <-[#uint64T] "$r0");;;
    let: "clerks" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] (struct.field_ref #Server #"clerks"%go (![#ptrT] "s"))) in
    do:  ("clerks" <-[#sliceT] "$r0");;;
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #());;;
    let: "wg" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #sync.WaitGroup)) in
    do:  ("wg" <-[#ptrT] "$r0");;;
    let: "args" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (let: "$Epoch" := (![#uint64T] "epoch") in
    let: "$Index" := (![#uint64T] "opIndex") in
    let: "$Op" := (![#sliceT] "op") in
    struct.make #applyasbackupargs_gk.S [{
      "Epoch" ::= "$Epoch";
      "Index" ::= "$Index";
      "Op" ::= "$Op"
    }])) in
    do:  ("args" <-[#ptrT] "$r0");;;
    let: "clerks_inner" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] (slice.elem_ref #sliceT (![#sliceT] "clerks") (((func_call #primitive.RandomUint64) #()) `rem` (s_to_w64 (let: "$a0" := (![#sliceT] "clerks") in
    slice.len "$a0"))))) in
    do:  ("clerks_inner" <-[#sliceT] "$r0");;;
    let: "errs" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make2 #err_gk.E (let: "$a0" := (![#sliceT] "clerks_inner") in
    slice.len "$a0")) in
    do:  ("errs" <-[#sliceT] "$r0");;;
    let: "$range" := (![#sliceT] "clerks_inner") in
    (let: "clerk" := (mem.alloc (type.zero_val #ptrT)) in
    let: "i" := (mem.alloc (type.zero_val #intT)) in
    slice.for_range #ptrT "$range" (λ: "$key" "$value",
      do:  ("clerk" <-[#ptrT] "$value");;;
      do:  ("i" <-[#intT] "$key");;;
      let: "clerk" := (mem.alloc (type.zero_val #ptrT)) in
      let: "$r0" := (![#ptrT] "clerk") in
      do:  ("clerk" <-[#ptrT] "$r0");;;
      let: "i" := (mem.alloc (type.zero_val #intT)) in
      let: "$r0" := (![#intT] "i") in
      do:  ("i" <-[#intT] "$r0");;;
      do:  (let: "$a0" := #(W64 1) in
      (method_call #(ptrT.id sync.WaitGroup.id) #"Add"%go (![#ptrT] "wg")) "$a0");;;
      let: "$go" := (λ: <>,
        exception_do ((for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
          let: "err" := (mem.alloc (type.zero_val #err_gk.E)) in
          let: "$r0" := (let: "$a0" := (![#ptrT] "args") in
          (method_call #(ptrT.id Clerk.id) #"ApplyAsBackup"%go (![#ptrT] "clerk")) "$a0") in
          do:  ("err" <-[#err_gk.E] "$r0");;;
          (if: ((![#err_gk.E] "err") = err_gk.OutOfOrder) || ((![#err_gk.E] "err") = err_gk.Timeout)
          then continue: #()
          else
            let: "$r0" := (![#err_gk.E] "err") in
            do:  ((slice.elem_ref #err_gk.E (![#sliceT] "errs") (![#intT] "i")) <-[#err_gk.E] "$r0");;;
            break: #()));;;
        do:  ((method_call #(ptrT.id sync.WaitGroup.id) #"Done"%go (![#ptrT] "wg")) #());;;
        return: #())
        ) in
      do:  (Fork ("$go" #()))));;;
    do:  ((method_call #(ptrT.id sync.WaitGroup.id) #"Wait"%go (![#ptrT] "wg")) #());;;
    do:  ((![#funcT] "waitForDurable") #());;;
    let: "err" := (mem.alloc (type.zero_val #err_gk.E)) in
    let: "$r0" := err_gk.None in
    do:  ("err" <-[#err_gk.E] "$r0");;;
    let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (for: (λ: <>, (![#uint64T] "i") < (s_to_w64 (let: "$a0" := (![#sliceT] "clerks_inner") in
    slice.len "$a0"))); (λ: <>, #()) := λ: <>,
      let: "err2" := (mem.alloc (type.zero_val #err_gk.E)) in
      let: "$r0" := (![#err_gk.E] (slice.elem_ref #err_gk.E (![#sliceT] "errs") (![#uint64T] "i"))) in
      do:  ("err2" <-[#err_gk.E] "$r0");;;
      (if: (![#err_gk.E] "err2") ≠ err_gk.None
      then
        let: "$r0" := (![#err_gk.E] "err2") in
        do:  ("err" <-[#err_gk.E] "$r0")
      else do:  #());;;
      do:  ("i" <-[#uint64T] ((![#uint64T] "i") + #(W64 1))));;;
    let: "$r0" := (![#err_gk.E] "err") in
    do:  ((struct.field_ref #applyreply_gk.S #"Err"%go (![#ptrT] "reply")) <-[#err_gk.E] "$r0");;;
    (if: (![#err_gk.E] "err") = err_gk.None
    then
      do:  (let: "$a0" := (![#uint64T] "nextIndex") in
      (method_call #(ptrT.id Server.id) #"IncreaseCommitIndex"%go (![#ptrT] "s")) "$a0")
    else
      do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #());;;
      (if: (![#uint64T] (struct.field_ref #Server #"epoch"%go (![#ptrT] "s"))) = (![#uint64T] "epoch")
      then
        let: "$r0" := #false in
        do:  ((struct.field_ref #Server #"isPrimary"%go (![#ptrT] "s")) <-[#boolT] "$r0")
      else do:  #());;;
      do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #()));;;
    return: (![#ptrT] "reply")).

(* go: server.go:210:18 *)
Definition Server__leaseRenewalThreadⁱᵐᵖˡ : val :=
  λ: "s" <>,
    exception_do (let: "s" := (mem.alloc "s") in
    let: "latestEpoch" := (mem.alloc (type.zero_val #uint64T)) in
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "leaseExpiration" := (mem.alloc (type.zero_val #uint64T)) in
      let: "leaseErr" := (mem.alloc (type.zero_val #err_gk.E)) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![#uint64T] "latestEpoch") in
      (method_call #(ptrT.id configservice.Clerk.id) #"GetLease"%go (![#ptrT] (struct.field_ref #Server #"confCk"%go (![#ptrT] "s")))) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("leaseErr" <-[#err_gk.E] "$r0");;;
      do:  ("leaseExpiration" <-[#uint64T] "$r1");;;
      do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #());;;
      (if: ((![#uint64T] (struct.field_ref #Server #"epoch"%go (![#ptrT] "s"))) = (![#uint64T] "latestEpoch")) && ((![#err_gk.E] "leaseErr") = err_gk.None)
      then
        let: "$r0" := (![#uint64T] "leaseExpiration") in
        do:  ((struct.field_ref #Server #"leaseExpiration"%go (![#ptrT] "s")) <-[#uint64T] "$r0");;;
        let: "$r0" := #true in
        do:  ((struct.field_ref #Server #"leaseValid"%go (![#ptrT] "s")) <-[#boolT] "$r0");;;
        do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #());;;
        do:  (let: "$a0" := (#(W64 250) * #(W64 1000000)) in
        (func_call #primitive.Sleep) "$a0")
      else
        (if: (![#uint64T] "latestEpoch") ≠ (![#uint64T] (struct.field_ref #Server #"epoch"%go (![#ptrT] "s")))
        then
          let: "$r0" := (![#uint64T] (struct.field_ref #Server #"epoch"%go (![#ptrT] "s"))) in
          do:  ("latestEpoch" <-[#uint64T] "$r0");;;
          do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #())
        else
          do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #());;;
          do:  (let: "$a0" := (#(W64 50) * #(W64 1000000)) in
          (func_call #primitive.Sleep) "$a0"))));;;
    return: #()).

(* go: server.go:235:18 *)
Definition Server__sendIncreaseCommitThreadⁱᵐᵖˡ : val :=
  λ: "s" <>,
    exception_do (let: "s" := (mem.alloc "s") in
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #());;;
      (for: (λ: <>, (~ (![#boolT] (struct.field_ref #Server #"isPrimary"%go (![#ptrT] "s")))) || ((let: "$a0" := (![#sliceT] (slice.elem_ref #sliceT (![#sliceT] (struct.field_ref #Server #"clerks"%go (![#ptrT] "s"))) #(W64 0))) in
      slice.len "$a0") = #(W64 0))); (λ: <>, #()) := λ: <>,
        do:  ((method_call #(ptrT.id sync.Cond.id) #"Wait"%go (![#ptrT] (struct.field_ref #Server #"isPrimary_cond"%go (![#ptrT] "s")))) #()));;;
      let: "newCommittedNextIndex" := (mem.alloc (type.zero_val #uint64T)) in
      let: "$r0" := (![#uint64T] (struct.field_ref #Server #"committedNextIndex"%go (![#ptrT] "s"))) in
      do:  ("newCommittedNextIndex" <-[#uint64T] "$r0");;;
      let: "clerks" := (mem.alloc (type.zero_val #sliceT)) in
      let: "$r0" := (![#sliceT] (struct.field_ref #Server #"clerks"%go (![#ptrT] "s"))) in
      do:  ("clerks" <-[#sliceT] "$r0");;;
      do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #());;;
      let: "clerks_inner" := (mem.alloc (type.zero_val #sliceT)) in
      let: "$r0" := (![#sliceT] (slice.elem_ref #sliceT (![#sliceT] "clerks") (((func_call #primitive.RandomUint64) #()) `rem` (s_to_w64 (let: "$a0" := (![#sliceT] "clerks") in
      slice.len "$a0"))))) in
      do:  ("clerks_inner" <-[#sliceT] "$r0");;;
      let: "wg" := (mem.alloc (type.zero_val #ptrT)) in
      let: "$r0" := (mem.alloc (type.zero_val #sync.WaitGroup)) in
      do:  ("wg" <-[#ptrT] "$r0");;;
      let: "$range" := (![#sliceT] "clerks_inner") in
      (let: "clerk" := (mem.alloc (type.zero_val #ptrT)) in
      slice.for_range #ptrT "$range" (λ: "$key" "$value",
        do:  ("clerk" <-[#ptrT] "$value");;;
        do:  "$key";;;
        let: "clerk" := (mem.alloc (type.zero_val #ptrT)) in
        let: "$r0" := (![#ptrT] "clerk") in
        do:  ("clerk" <-[#ptrT] "$r0");;;
        do:  (let: "$a0" := #(W64 1) in
        (method_call #(ptrT.id sync.WaitGroup.id) #"Add"%go (![#ptrT] "wg")) "$a0");;;
        let: "$go" := (λ: <>,
          exception_do ((for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
            let: "err" := (mem.alloc (type.zero_val #err_gk.E)) in
            let: "$r0" := (let: "$a0" := (![#uint64T] "newCommittedNextIndex") in
            (method_call #(ptrT.id Clerk.id) #"IncreaseCommitIndex"%go (![#ptrT] "clerk")) "$a0") in
            do:  ("err" <-[#err_gk.E] "$r0");;;
            (if: (![#err_gk.E] "err") = err_gk.None
            then break: #()
            else continue: #()));;;
          do:  ((method_call #(ptrT.id sync.WaitGroup.id) #"Done"%go (![#ptrT] "wg")) #());;;
          return: #())
          ) in
        do:  (Fork ("$go" #()))));;;
      do:  ((method_call #(ptrT.id sync.WaitGroup.id) #"Wait"%go (![#ptrT] "wg")) #());;;
      do:  (let: "$a0" := #(W64 5000000) in
      (func_call #primitive.Sleep) "$a0"));;;
    return: #()).

(* requires that we've already at least entered this epoch
   returns true iff stale

   go: server.go:279:18 *)
Definition Server__isEpochStaleⁱᵐᵖˡ : val :=
  λ: "s" "epoch",
    exception_do (let: "s" := (mem.alloc "s") in
    let: "epoch" := (mem.alloc "epoch") in
    return: ((![#uint64T] (struct.field_ref #Server #"epoch"%go (![#ptrT] "s"))) ≠ (![#uint64T] "epoch"))).

(* called on backup servers to apply an operation so it is replicated and
   can be considered committed by primary.

   go: server.go:285:18 *)
Definition Server__ApplyAsBackupⁱᵐᵖˡ : val :=
  λ: "s" "args",
    exception_do (let: "s" := (mem.alloc "s") in
    let: "args" := (mem.alloc "args") in
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #());;;
    (for: (λ: <>, (((![#uint64T] (struct.field_ref #applyasbackupargs_gk.S #"Index"%go (![#ptrT] "args"))) > (![#uint64T] (struct.field_ref #Server #"nextIndex"%go (![#ptrT] "s")))) && ((![#uint64T] (struct.field_ref #Server #"epoch"%go (![#ptrT] "s"))) = (![#uint64T] (struct.field_ref #applyasbackupargs_gk.S #"Epoch"%go (![#ptrT] "args"))))) && (~ (![#boolT] (struct.field_ref #Server #"sealed"%go (![#ptrT] "s"))))); (λ: <>, #()) := λ: <>,
      let: "ok" := (mem.alloc (type.zero_val #boolT)) in
      let: "cond" := (mem.alloc (type.zero_val #ptrT)) in
      let: ("$ret0", "$ret1") := (map.get (![type.mapT #uint64T #ptrT] (struct.field_ref #Server #"opAppliedConds"%go (![#ptrT] "s"))) (![#uint64T] (struct.field_ref #applyasbackupargs_gk.S #"Index"%go (![#ptrT] "args")))) in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("cond" <-[#ptrT] "$r0");;;
      do:  ("ok" <-[#boolT] "$r1");;;
      (if: (~ (![#boolT] "ok"))
      then
        let: "cond" := (mem.alloc (type.zero_val #ptrT)) in
        let: "$r0" := (let: "$a0" := (interface.make #(ptrT.id sync.Mutex.id) (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) in
        (func_call #sync.NewCond) "$a0") in
        do:  ("cond" <-[#ptrT] "$r0");;;
        let: "$r0" := (![#ptrT] "cond") in
        do:  (map.insert (![type.mapT #uint64T #ptrT] (struct.field_ref #Server #"opAppliedConds"%go (![#ptrT] "s"))) (![#uint64T] (struct.field_ref #applyasbackupargs_gk.S #"Index"%go (![#ptrT] "args"))) "$r0")
      else do:  ((method_call #(ptrT.id sync.Cond.id) #"Wait"%go (![#ptrT] "cond")) #())));;;
    (if: ![#boolT] (struct.field_ref #Server #"sealed"%go (![#ptrT] "s"))
    then
      do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #());;;
      return: (err_gk.Stale)
    else do:  #());;;
    (if: let: "$a0" := (![#uint64T] (struct.field_ref #applyasbackupargs_gk.S #"Epoch"%go (![#ptrT] "args"))) in
    (method_call #(ptrT.id Server.id) #"isEpochStale"%go (![#ptrT] "s")) "$a0"
    then
      do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #());;;
      return: (err_gk.Stale)
    else do:  #());;;
    (if: (![#uint64T] (struct.field_ref #applyasbackupargs_gk.S #"Index"%go (![#ptrT] "args"))) ≠ (![#uint64T] (struct.field_ref #Server #"nextIndex"%go (![#ptrT] "s")))
    then
      do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #());;;
      return: (err_gk.OutOfOrder)
    else do:  #());;;
    let: "waitFn" := (mem.alloc (type.zero_val #funcT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] (struct.field_ref #applyasbackupargs_gk.S #"Op"%go (![#ptrT] "args"))) in
    (![#funcT] (struct.field_ref #StateMachine #"StartApply"%go (![#ptrT] (struct.field_ref #Server #"sm"%go (![#ptrT] "s"))))) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  "$r0";;;
    do:  ("waitFn" <-[#funcT] "$r1");;;
    do:  ((struct.field_ref #Server #"nextIndex"%go (![#ptrT] "s")) <-[#uint64T] ((![#uint64T] (struct.field_ref #Server #"nextIndex"%go (![#ptrT] "s"))) + #(W64 1)));;;
    let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "cond" := (mem.alloc (type.zero_val #ptrT)) in
    let: ("$ret0", "$ret1") := (map.get (![type.mapT #uint64T #ptrT] (struct.field_ref #Server #"opAppliedConds"%go (![#ptrT] "s"))) (![#uint64T] (struct.field_ref #Server #"nextIndex"%go (![#ptrT] "s")))) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("cond" <-[#ptrT] "$r0");;;
    do:  ("ok" <-[#boolT] "$r1");;;
    (if: ![#boolT] "ok"
    then
      do:  ((method_call #(ptrT.id sync.Cond.id) #"Signal"%go (![#ptrT] "cond")) #());;;
      do:  (let: "$a0" := (![type.mapT #uint64T #ptrT] (struct.field_ref #Server #"opAppliedConds"%go (![#ptrT] "s"))) in
      let: "$a1" := (![#uint64T] (struct.field_ref #Server #"nextIndex"%go (![#ptrT] "s"))) in
      map.delete "$a0" "$a1")
    else do:  #());;;
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #());;;
    do:  ((![#funcT] "waitFn") #());;;
    return: (err_gk.None)).

(* go: server.go:346:18 *)
Definition Server__SetStateⁱᵐᵖˡ : val :=
  λ: "s" "args",
    exception_do (let: "s" := (mem.alloc "s") in
    let: "args" := (mem.alloc "args") in
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #());;;
    (if: (![#uint64T] (struct.field_ref #Server #"epoch"%go (![#ptrT] "s"))) > (![#uint64T] (struct.field_ref #setstateargs_gk.S #"Epoch"%go (![#ptrT] "args")))
    then
      do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #());;;
      return: (err_gk.Stale)
    else
      (if: (![#uint64T] (struct.field_ref #Server #"epoch"%go (![#ptrT] "s"))) = (![#uint64T] (struct.field_ref #setstateargs_gk.S #"Epoch"%go (![#ptrT] "args")))
      then
        do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #());;;
        return: (err_gk.None)
      else
        do:  (let: "$a0" := ((let: "$sl0" := (interface.make #stringT.id #"Entered new epoch"%go) in
        slice.literal #interfaceT ["$sl0"])) in
        (func_call #log.Print) "$a0");;;
        let: "$r0" := #false in
        do:  ((struct.field_ref #Server #"isPrimary"%go (![#ptrT] "s")) <-[#boolT] "$r0");;;
        let: "$r0" := #true in
        do:  ((struct.field_ref #Server #"canBecomePrimary"%go (![#ptrT] "s")) <-[#boolT] "$r0");;;
        let: "$r0" := (![#uint64T] (struct.field_ref #setstateargs_gk.S #"Epoch"%go (![#ptrT] "args"))) in
        do:  ((struct.field_ref #Server #"epoch"%go (![#ptrT] "s")) <-[#uint64T] "$r0");;;
        let: "$r0" := #false in
        do:  ((struct.field_ref #Server #"leaseValid"%go (![#ptrT] "s")) <-[#boolT] "$r0");;;
        let: "$r0" := #false in
        do:  ((struct.field_ref #Server #"sealed"%go (![#ptrT] "s")) <-[#boolT] "$r0");;;
        let: "$r0" := (![#uint64T] (struct.field_ref #setstateargs_gk.S #"NextIndex"%go (![#ptrT] "args"))) in
        do:  ((struct.field_ref #Server #"nextIndex"%go (![#ptrT] "s")) <-[#uint64T] "$r0");;;
        do:  (let: "$a0" := (![#sliceT] (struct.field_ref #setstateargs_gk.S #"State"%go (![#ptrT] "args"))) in
        let: "$a1" := (![#uint64T] (struct.field_ref #setstateargs_gk.S #"NextIndex"%go (![#ptrT] "args"))) in
        let: "$a2" := (![#uint64T] (struct.field_ref #setstateargs_gk.S #"Epoch"%go (![#ptrT] "args"))) in
        (![#funcT] (struct.field_ref #StateMachine #"SetStateAndUnseal"%go (![#ptrT] (struct.field_ref #Server #"sm"%go (![#ptrT] "s"))))) "$a0" "$a1" "$a2");;;
        let: "$range" := (![type.mapT #uint64T #ptrT] (struct.field_ref #Server #"opAppliedConds"%go (![#ptrT] "s"))) in
        (let: "cond" := (mem.alloc (type.zero_val #ptrT)) in
        map.for_range "$range" (λ: "$key" "value",
          do:  ("cond" <-[#ptrT] "$value");;;
          do:  "$key";;;
          do:  ((method_call #(ptrT.id sync.Cond.id) #"Signal"%go (![#ptrT] "cond")) #())));;;
        do:  ((method_call #(ptrT.id sync.Cond.id) #"Broadcast"%go (![#ptrT] (struct.field_ref #Server #"committedNextIndex_cond"%go (![#ptrT] "s")))) #());;;
        let: "$r0" := (map.make #uint64T #ptrT) in
        do:  ((struct.field_ref #Server #"opAppliedConds"%go (![#ptrT] "s")) <-[type.mapT #uint64T #ptrT] "$r0");;;
        do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #());;;
        do:  (let: "$a0" := (![#uint64T] (struct.field_ref #setstateargs_gk.S #"CommittedNextIndex"%go (![#ptrT] "args"))) in
        (method_call #(ptrT.id Server.id) #"IncreaseCommitIndex"%go (![#ptrT] "s")) "$a0");;;
        return: (err_gk.None)))).

(* XXX: probably should rename to GetStateAndSeal

   go: server.go:377:18 *)
Definition Server__GetStateⁱᵐᵖˡ : val :=
  λ: "s" "args",
    exception_do (let: "s" := (mem.alloc "s") in
    let: "args" := (mem.alloc "args") in
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #());;;
    (if: (![#uint64T] (struct.field_ref #getstateargs_gk.S #"Epoch"%go (![#ptrT] "args"))) < (![#uint64T] (struct.field_ref #Server #"epoch"%go (![#ptrT] "s")))
    then
      do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #());;;
      return: (mem.alloc (let: "$Err" := err_gk.Stale in
       let: "$State" := #slice.nil in
       struct.make #getstatereply_gk.S [{
         "Err" ::= "$Err";
         "NextIndex" ::= type.zero_val #uint64T;
         "CommittedNextIndex" ::= type.zero_val #uint64T;
         "State" ::= "$State"
       }]))
    else do:  #());;;
    let: "$r0" := #true in
    do:  ((struct.field_ref #Server #"sealed"%go (![#ptrT] "s")) <-[#boolT] "$r0");;;
    let: "ret" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := ((![#funcT] (struct.field_ref #StateMachine #"GetStateAndSeal"%go (![#ptrT] (struct.field_ref #Server #"sm"%go (![#ptrT] "s"))))) #()) in
    do:  ("ret" <-[#sliceT] "$r0");;;
    let: "nextIndex" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (![#uint64T] (struct.field_ref #Server #"nextIndex"%go (![#ptrT] "s"))) in
    do:  ("nextIndex" <-[#uint64T] "$r0");;;
    let: "committedNextIndex" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (![#uint64T] (struct.field_ref #Server #"committedNextIndex"%go (![#ptrT] "s"))) in
    do:  ("committedNextIndex" <-[#uint64T] "$r0");;;
    let: "$range" := (![type.mapT #uint64T #ptrT] (struct.field_ref #Server #"opAppliedConds"%go (![#ptrT] "s"))) in
    (let: "cond" := (mem.alloc (type.zero_val #ptrT)) in
    map.for_range "$range" (λ: "$key" "value",
      do:  ("cond" <-[#ptrT] "$value");;;
      do:  "$key";;;
      do:  ((method_call #(ptrT.id sync.Cond.id) #"Signal"%go (![#ptrT] "cond")) #())));;;
    let: "$r0" := (map.make #uint64T #ptrT) in
    do:  ((struct.field_ref #Server #"opAppliedConds"%go (![#ptrT] "s")) <-[type.mapT #uint64T #ptrT] "$r0");;;
    do:  ((method_call #(ptrT.id sync.Cond.id) #"Broadcast"%go (![#ptrT] (struct.field_ref #Server #"committedNextIndex_cond"%go (![#ptrT] "s")))) #());;;
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #());;;
    return: (mem.alloc (let: "$Err" := err_gk.None in
     let: "$State" := (![#sliceT] "ret") in
     let: "$NextIndex" := (![#uint64T] "nextIndex") in
     let: "$CommittedNextIndex" := (![#uint64T] "committedNextIndex") in
     struct.make #getstatereply_gk.S [{
       "Err" ::= "$Err";
       "NextIndex" ::= "$NextIndex";
       "CommittedNextIndex" ::= "$CommittedNextIndex";
       "State" ::= "$State"
     }]))).

(* go: server.go:400:18 *)
Definition Server__BecomePrimaryⁱᵐᵖˡ : val :=
  λ: "s" "args",
    exception_do (let: "s" := (mem.alloc "s") in
    let: "args" := (mem.alloc "args") in
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #());;;
    (if: ((![#uint64T] (struct.field_ref #becomeprimaryargs_gk.S #"Epoch"%go (![#ptrT] "args"))) ≠ (![#uint64T] (struct.field_ref #Server #"epoch"%go (![#ptrT] "s")))) || (~ (![#boolT] (struct.field_ref #Server #"canBecomePrimary"%go (![#ptrT] "s"))))
    then
      do:  (let: "$a0" := #"Wrong epoch in BecomePrimary request (in %d, got %d)"%go in
      let: "$a1" := ((let: "$sl0" := (interface.make #uint64T.id (![#uint64T] (struct.field_ref #Server #"epoch"%go (![#ptrT] "s")))) in
      let: "$sl1" := (interface.make #uint64T.id (![#uint64T] (struct.field_ref #becomeprimaryargs_gk.S #"Epoch"%go (![#ptrT] "args")))) in
      slice.literal #interfaceT ["$sl0"; "$sl1"])) in
      (func_call #log.Printf) "$a0" "$a1");;;
      do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #());;;
      return: (err_gk.Stale)
    else do:  #());;;
    do:  (let: "$a0" := ((let: "$sl0" := (interface.make #stringT.id #"Became Primary"%go) in
    slice.literal #interfaceT ["$sl0"])) in
    (func_call #log.Println) "$a0");;;
    let: "$r0" := #true in
    do:  ((struct.field_ref #Server #"isPrimary"%go (![#ptrT] "s")) <-[#boolT] "$r0");;;
    do:  ((method_call #(ptrT.id sync.Cond.id) #"Signal"%go (![#ptrT] (struct.field_ref #Server #"isPrimary_cond"%go (![#ptrT] "s")))) #());;;
    let: "$r0" := #false in
    do:  ((struct.field_ref #Server #"canBecomePrimary"%go (![#ptrT] "s")) <-[#boolT] "$r0");;;
    let: "numClerks" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 32) in
    do:  ("numClerks" <-[#uint64T] "$r0");;;
    let: "$r0" := (slice.make2 #sliceT (![#uint64T] "numClerks")) in
    do:  ((struct.field_ref #Server #"clerks"%go (![#ptrT] "s")) <-[#sliceT] "$r0");;;
    let: "j" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("j" <-[#uint64T] "$r0");;;
    (for: (λ: <>, (![#uint64T] "j") < (![#uint64T] "numClerks")); (λ: <>, #()) := λ: <>,
      let: "clerks" := (mem.alloc (type.zero_val #sliceT)) in
      let: "$r0" := (slice.make2 #ptrT ((let: "$a0" := (![#sliceT] (struct.field_ref #becomeprimaryargs_gk.S #"Replicas"%go (![#ptrT] "args"))) in
      slice.len "$a0") - #(W64 1))) in
      do:  ("clerks" <-[#sliceT] "$r0");;;
      let: "i" := (mem.alloc (type.zero_val #uint64T)) in
      let: "$r0" := #(W64 0) in
      do:  ("i" <-[#uint64T] "$r0");;;
      (for: (λ: <>, (![#uint64T] "i") < (s_to_w64 (let: "$a0" := (![#sliceT] "clerks") in
      slice.len "$a0"))); (λ: <>, #()) := λ: <>,
        let: "$r0" := (let: "$a0" := (![#uint64T] (slice.elem_ref #uint64T (![#sliceT] (struct.field_ref #becomeprimaryargs_gk.S #"Replicas"%go (![#ptrT] "args"))) ((![#uint64T] "i") + #(W64 1)))) in
        (func_call #MakeClerk) "$a0") in
        do:  ((slice.elem_ref #ptrT (![#sliceT] "clerks") (![#uint64T] "i")) <-[#ptrT] "$r0");;;
        do:  ("i" <-[#uint64T] ((![#uint64T] "i") + #(W64 1))));;;
      let: "$r0" := (![#sliceT] "clerks") in
      do:  ((slice.elem_ref #sliceT (![#sliceT] (struct.field_ref #Server #"clerks"%go (![#ptrT] "s"))) (![#uint64T] "j")) <-[#sliceT] "$r0");;;
      do:  ("j" <-[#uint64T] ((![#uint64T] "j") + #(W64 1))));;;
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #());;;
    return: (err_gk.None)).

Definition MakeServer : go_string := "github.com/mit-pdos/gokv/vrsm/replica.MakeServer"%go.

(* go: server.go:434:6 *)
Definition MakeServerⁱᵐᵖˡ : val :=
  λ: "sm" "confHosts" "nextIndex" "epoch" "sealed",
    exception_do (let: "sealed" := (mem.alloc "sealed") in
    let: "epoch" := (mem.alloc "epoch") in
    let: "nextIndex" := (mem.alloc "nextIndex") in
    let: "confHosts" := (mem.alloc "confHosts") in
    let: "sm" := (mem.alloc "sm") in
    let: "s" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #Server)) in
    do:  ("s" <-[#ptrT] "$r0");;;
    let: "$r0" := (mem.alloc (type.zero_val #sync.Mutex)) in
    do:  ((struct.field_ref #Server #"mu"%go (![#ptrT] "s")) <-[#ptrT] "$r0");;;
    let: "$r0" := (![#uint64T] "epoch") in
    do:  ((struct.field_ref #Server #"epoch"%go (![#ptrT] "s")) <-[#uint64T] "$r0");;;
    let: "$r0" := (![#boolT] "sealed") in
    do:  ((struct.field_ref #Server #"sealed"%go (![#ptrT] "s")) <-[#boolT] "$r0");;;
    let: "$r0" := (![#ptrT] "sm") in
    do:  ((struct.field_ref #Server #"sm"%go (![#ptrT] "s")) <-[#ptrT] "$r0");;;
    let: "$r0" := (![#uint64T] "nextIndex") in
    do:  ((struct.field_ref #Server #"nextIndex"%go (![#ptrT] "s")) <-[#uint64T] "$r0");;;
    let: "$r0" := #false in
    do:  ((struct.field_ref #Server #"isPrimary"%go (![#ptrT] "s")) <-[#boolT] "$r0");;;
    let: "$r0" := #false in
    do:  ((struct.field_ref #Server #"canBecomePrimary"%go (![#ptrT] "s")) <-[#boolT] "$r0");;;
    let: "$r0" := #false in
    do:  ((struct.field_ref #Server #"leaseValid"%go (![#ptrT] "s")) <-[#boolT] "$r0");;;
    let: "$r0" := #false in
    do:  ((struct.field_ref #Server #"canBecomePrimary"%go (![#ptrT] "s")) <-[#boolT] "$r0");;;
    let: "$r0" := (map.make #uint64T #ptrT) in
    do:  ((struct.field_ref #Server #"opAppliedConds"%go (![#ptrT] "s")) <-[type.mapT #uint64T #ptrT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "confHosts") in
    (func_call #configservice.MakeClerk) "$a0") in
    do:  ((struct.field_ref #Server #"confCk"%go (![#ptrT] "s")) <-[#ptrT] "$r0");;;
    let: "$r0" := (let: "$a0" := (interface.make #(ptrT.id sync.Mutex.id) (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) in
    (func_call #sync.NewCond) "$a0") in
    do:  ((struct.field_ref #Server #"committedNextIndex_cond"%go (![#ptrT] "s")) <-[#ptrT] "$r0");;;
    let: "$r0" := (let: "$a0" := (interface.make #(ptrT.id sync.Mutex.id) (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) in
    (func_call #sync.NewCond) "$a0") in
    do:  ((struct.field_ref #Server #"isPrimary_cond"%go (![#ptrT] "s")) <-[#ptrT] "$r0");;;
    return: (![#ptrT] "s")).

(* go: server.go:453:18 *)
Definition Server__Serveⁱᵐᵖˡ : val :=
  λ: "s" "me",
    exception_do (let: "s" := (mem.alloc "s") in
    let: "me" := (mem.alloc "me") in
    let: "handlers" := (mem.alloc (type.zero_val (type.mapT #uint64T #funcT))) in
    let: "$r0" := (map.make #uint64T #funcT) in
    do:  ("handlers" <-[type.mapT #uint64T #funcT] "$r0");;;
    let: "$r0" := (λ: "args" "reply",
      exception_do (let: "reply" := (mem.alloc "reply") in
      let: "args" := (mem.alloc "args") in
      let: "a" := (mem.alloc (type.zero_val #applyasbackupargs_gk.S)) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "args") in
      (func_call #applyasbackupargs_gk.Unmarshal) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("a" <-[#applyasbackupargs_gk.S] "$r0");;;
      do:  "$r1";;;
      let: "$r0" := (let: "$a0" := (slice.make2 #byteT #(W64 8)) in
      let: "$a1" := (let: "$a0" := "a" in
      (method_call #(ptrT.id Server.id) #"ApplyAsBackup"%go (![#ptrT] "s")) "$a0") in
      (func_call #err_gk.Marshal) "$a0" "$a1") in
      do:  ((![#ptrT] "reply") <-[#sliceT] "$r0");;;
      return: #())
      ) in
    do:  (map.insert (![type.mapT #uint64T #funcT] "handlers") RPC_APPLYASBACKUP "$r0");;;
    let: "$r0" := (λ: "args" "reply",
      exception_do (let: "reply" := (mem.alloc "reply") in
      let: "args" := (mem.alloc "args") in
      let: "a" := (mem.alloc (type.zero_val #setstateargs_gk.S)) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "args") in
      (func_call #setstateargs_gk.Unmarshal) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("a" <-[#setstateargs_gk.S] "$r0");;;
      do:  "$r1";;;
      let: "$r0" := (let: "$a0" := (slice.make2 #byteT #(W64 0)) in
      let: "$a1" := (let: "$a0" := "a" in
      (method_call #(ptrT.id Server.id) #"SetState"%go (![#ptrT] "s")) "$a0") in
      (func_call #err_gk.Marshal) "$a0" "$a1") in
      do:  ((![#ptrT] "reply") <-[#sliceT] "$r0");;;
      return: #())
      ) in
    do:  (map.insert (![type.mapT #uint64T #funcT] "handlers") RPC_SETSTATE "$r0");;;
    let: "$r0" := (λ: "args" "reply",
      exception_do (let: "reply" := (mem.alloc "reply") in
      let: "args" := (mem.alloc "args") in
      let: "a" := (mem.alloc (type.zero_val #getstateargs_gk.S)) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "args") in
      (func_call #getstateargs_gk.Unmarshal) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("a" <-[#getstateargs_gk.S] "$r0");;;
      do:  "$r1";;;
      let: "$r0" := (let: "$a0" := (slice.make2 #byteT #(W64 0)) in
      let: "$a1" := (![#getstatereply_gk.S] (let: "$a0" := "a" in
      (method_call #(ptrT.id Server.id) #"GetState"%go (![#ptrT] "s")) "$a0")) in
      (func_call #getstatereply_gk.Marshal) "$a0" "$a1") in
      do:  ((![#ptrT] "reply") <-[#sliceT] "$r0");;;
      return: #())
      ) in
    do:  (map.insert (![type.mapT #uint64T #funcT] "handlers") RPC_GETSTATE "$r0");;;
    let: "$r0" := (λ: "args" "reply",
      exception_do (let: "reply" := (mem.alloc "reply") in
      let: "args" := (mem.alloc "args") in
      let: "a" := (mem.alloc (type.zero_val #becomeprimaryargs_gk.S)) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "args") in
      (func_call #becomeprimaryargs_gk.Unmarshal) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("a" <-[#becomeprimaryargs_gk.S] "$r0");;;
      do:  "$r1";;;
      let: "$r0" := (let: "$a0" := (slice.make2 #byteT #(W64 0)) in
      let: "$a1" := (let: "$a0" := "a" in
      (method_call #(ptrT.id Server.id) #"BecomePrimary"%go (![#ptrT] "s")) "$a0") in
      (func_call #err_gk.Marshal) "$a0" "$a1") in
      do:  ((![#ptrT] "reply") <-[#sliceT] "$r0");;;
      return: #())
      ) in
    do:  (map.insert (![type.mapT #uint64T #funcT] "handlers") RPC_BECOMEPRIMARY "$r0");;;
    let: "$r0" := (λ: "args" "reply",
      exception_do (let: "reply" := (mem.alloc "reply") in
      let: "args" := (mem.alloc "args") in
      let: "$r0" := (let: "$a0" := (slice.make2 #byteT #(W64 0)) in
      let: "$a1" := (![#applyreply_gk.S] (let: "$a0" := (![#sliceT] "args") in
      (method_call #(ptrT.id Server.id) #"Apply"%go (![#ptrT] "s")) "$a0")) in
      (func_call #applyreply_gk.Marshal) "$a0" "$a1") in
      do:  ((![#ptrT] "reply") <-[#sliceT] "$r0");;;
      return: #())
      ) in
    do:  (map.insert (![type.mapT #uint64T #funcT] "handlers") RPC_PRIMARYAPPLY "$r0");;;
    let: "$r0" := (λ: "args" "reply",
      exception_do (let: "reply" := (mem.alloc "reply") in
      let: "args" := (mem.alloc "args") in
      let: "$r0" := (let: "$a0" := (slice.make2 #byteT #(W64 0)) in
      let: "$a1" := (![#applyreply_gk.S] (let: "$a0" := (![#sliceT] "args") in
      (method_call #(ptrT.id Server.id) #"ApplyRoWaitForCommit"%go (![#ptrT] "s")) "$a0")) in
      (func_call #applyreply_gk.Marshal) "$a0" "$a1") in
      do:  ((![#ptrT] "reply") <-[#sliceT] "$r0");;;
      return: #())
      ) in
    do:  (map.insert (![type.mapT #uint64T #funcT] "handlers") RPC_ROPRIMARYAPPLY "$r0");;;
    let: "$r0" := (λ: "args" "reply",
      exception_do (let: "reply" := (mem.alloc "reply") in
      let: "args" := (mem.alloc "args") in
      let: "ica" := (mem.alloc (type.zero_val #increasecommitargs_gk.S)) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "args") in
      (func_call #increasecommitargs_gk.Unmarshal) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("ica" <-[#increasecommitargs_gk.S] "$r0");;;
      do:  "$r1";;;
      do:  (let: "$a0" := (![#uint64T] (struct.field_ref #increasecommitargs_gk.S #"V"%go "ica")) in
      (method_call #(ptrT.id Server.id) #"IncreaseCommitIndex"%go (![#ptrT] "s")) "$a0");;;
      return: #())
      ) in
    do:  (map.insert (![type.mapT #uint64T #funcT] "handlers") RPC_INCREASECOMMIT "$r0");;;
    let: "rs" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := (![type.mapT #uint64T #funcT] "handlers") in
    (func_call #urpc.MakeServer) "$a0") in
    do:  ("rs" <-[#ptrT] "$r0");;;
    do:  (let: "$a0" := (![#uint64T] "me") in
    (method_call #(ptrT.id urpc.Server.id) #"Serve"%go (![#ptrT] "rs")) "$a0");;;
    let: "$go" := (λ: <>,
      exception_do (do:  ((method_call #(ptrT.id Server.id) #"leaseRenewalThread"%go (![#ptrT] "s")) #());;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    let: "$go" := (λ: <>,
      exception_do (do:  ((method_call #(ptrT.id Server.id) #"sendIncreaseCommitThread"%go (![#ptrT] "s")) #());;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    return: #()).

Definition vars' : list (go_string * go_type) := [].

Definition functions' : list (go_string * val) := [(MakeClerk, MakeClerkⁱᵐᵖˡ); (MakeServer, MakeServerⁱᵐᵖˡ)].

Definition msets' : list (go_string * (list (go_string * val))) := [(StateMachine.id, []); (ptrT.id StateMachine.id, []); (SyncStateMachine.id, []); (ptrT.id SyncStateMachine.id, []); (Clerk.id, []); (ptrT.id Clerk.id, [("Apply"%go, Clerk__Applyⁱᵐᵖˡ); ("ApplyAsBackup"%go, Clerk__ApplyAsBackupⁱᵐᵖˡ); ("ApplyRo"%go, Clerk__ApplyRoⁱᵐᵖˡ); ("BecomePrimary"%go, Clerk__BecomePrimaryⁱᵐᵖˡ); ("GetState"%go, Clerk__GetStateⁱᵐᵖˡ); ("IncreaseCommitIndex"%go, Clerk__IncreaseCommitIndexⁱᵐᵖˡ); ("SetState"%go, Clerk__SetStateⁱᵐᵖˡ)]); (Server.id, []); (ptrT.id Server.id, [("Apply"%go, Server__Applyⁱᵐᵖˡ); ("ApplyAsBackup"%go, Server__ApplyAsBackupⁱᵐᵖˡ); ("ApplyRoWaitForCommit"%go, Server__ApplyRoWaitForCommitⁱᵐᵖˡ); ("BecomePrimary"%go, Server__BecomePrimaryⁱᵐᵖˡ); ("GetState"%go, Server__GetStateⁱᵐᵖˡ); ("IncreaseCommitIndex"%go, Server__IncreaseCommitIndexⁱᵐᵖˡ); ("Serve"%go, Server__Serveⁱᵐᵖˡ); ("SetState"%go, Server__SetStateⁱᵐᵖˡ); ("isEpochStale"%go, Server__isEpochStaleⁱᵐᵖˡ); ("leaseRenewalThread"%go, Server__leaseRenewalThreadⁱᵐᵖˡ); ("sendIncreaseCommitThread"%go, Server__sendIncreaseCommitThreadⁱᵐᵖˡ)])].

#[global] Instance info' : PkgInfo replica.replica :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [code.github_com.mit_pdos.gokv.grove_ffi.grove_ffi; code.github_com.mit_pdos.gokv.reconfig.replica.becomeprimaryargs_gk.becomeprimaryargs_gk; code.github_com.mit_pdos.gokv.reconnectclient.reconnectclient; code.github_com.mit_pdos.gokv.vrsm.replica.applyasbackupargs_gk.applyasbackupargs_gk; code.github_com.mit_pdos.gokv.vrsm.replica.applyreply_gk.applyreply_gk; code.github_com.mit_pdos.gokv.vrsm.replica.err_gk.err_gk; code.github_com.mit_pdos.gokv.vrsm.replica.getstateargs_gk.getstateargs_gk; code.github_com.mit_pdos.gokv.vrsm.replica.getstatereply_gk.getstatereply_gk; code.github_com.mit_pdos.gokv.vrsm.replica.increasecommitargs_gk.increasecommitargs_gk; code.github_com.mit_pdos.gokv.vrsm.replica.setstateargs_gk.setstateargs_gk; code.log.log; code.sync.sync; code.github_com.goose_lang.primitive.primitive; code.github_com.goose_lang.std.std; code.github_com.mit_pdos.gokv.urpc.urpc; code.github_com.mit_pdos.gokv.vrsm.configservice.configservice];
  |}.

Definition initialize' : val :=
  λ: <>,
    package.init #replica.replica (λ: <>,
      exception_do (do:  (configservice.initialize' #());;;
      do:  (urpc.initialize' #());;;
      do:  (std.initialize' #());;;
      do:  (primitive.initialize' #());;;
      do:  (sync.initialize' #());;;
      do:  (log.initialize' #());;;
      do:  (setstateargs_gk.initialize' #());;;
      do:  (increasecommitargs_gk.initialize' #());;;
      do:  (getstatereply_gk.initialize' #());;;
      do:  (getstateargs_gk.initialize' #());;;
      do:  (err_gk.initialize' #());;;
      do:  (applyreply_gk.initialize' #());;;
      do:  (applyasbackupargs_gk.initialize' #());;;
      do:  (reconnectclient.initialize' #());;;
      do:  (becomeprimaryargs_gk.initialize' #());;;
      do:  (grove_ffi.initialize' #());;;
      do:  (package.alloc replica.replica #()))
      ).

End code.
End replica.
