(* autogenerated from github.com/mit-pdos/gokv/vrsm/replica *)
From New.golang Require Import defn.
Require Export New.code.github_com.goose_lang.primitive.
Require Export New.code.github_com.goose_lang.std.
Require Export New.code.github_com.mit_pdos.gokv.grove_ffi.
Require Export New.code.github_com.mit_pdos.gokv.reconnectclient.
Require Export New.code.github_com.mit_pdos.gokv.urpc.
Require Export New.code.github_com.mit_pdos.gokv.vrsm.configservice.
Require Export New.code.github_com.mit_pdos.gokv.vrsm.e.
Require Export New.code.github_com.tchajed.marshal.
Require Export New.code.log.
Require Export New.code.sync.

Definition replica : go_string := "github.com/mit-pdos/gokv/vrsm/replica".

From New Require Import grove_prelude.
Module replica.
Section code.


Definition Op : go_type := sliceT.

Definition ApplyAsBackupArgs : go_type := structT [
  "epoch" :: uint64T;
  "index" :: uint64T;
  "op" :: sliceT
].

(* go: 0_marshal.go:17:6 *)
Definition EncodeApplyAsBackupArgs : val :=
  rec: "EncodeApplyAsBackupArgs" "args" :=
    exception_do (let: "args" := (mem.alloc "args") in
    let: "enc" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make3 #byteT #(W64 0) (#(W64 (8 + 8)) + (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref #ApplyAsBackupArgs #"op"%go (![#ptrT] "args"))) in
    slice.len "$a0")))) in
    do:  ("enc" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "enc") in
    let: "$a1" := (![#uint64T] (struct.field_ref #ApplyAsBackupArgs #"epoch"%go (![#ptrT] "args"))) in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("enc" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "enc") in
    let: "$a1" := (![#uint64T] (struct.field_ref #ApplyAsBackupArgs #"index"%go (![#ptrT] "args"))) in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("enc" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "enc") in
    let: "$a1" := (![#sliceT] (struct.field_ref #ApplyAsBackupArgs #"op"%go (![#ptrT] "args"))) in
    (func_call #marshal.marshal #"WriteBytes"%go) "$a0" "$a1") in
    do:  ("enc" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "enc")).

(* go: 0_marshal.go:25:6 *)
Definition DecodeApplyAsBackupArgs : val :=
  rec: "DecodeApplyAsBackupArgs" "enc_args" :=
    exception_do (let: "enc_args" := (mem.alloc "enc_args") in
    let: "enc" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "enc_args") in
    do:  ("enc" <-[#sliceT] "$r0");;;
    let: "args" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #ApplyAsBackupArgs)) in
    do:  ("args" <-[#ptrT] "$r0");;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "enc") in
    (func_call #marshal.marshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ((struct.field_ref #ApplyAsBackupArgs #"epoch"%go (![#ptrT] "args")) <-[#uint64T] "$r0");;;
    do:  ("enc" <-[#sliceT] "$r1");;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "enc") in
    (func_call #marshal.marshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ((struct.field_ref #ApplyAsBackupArgs #"index"%go (![#ptrT] "args")) <-[#uint64T] "$r0");;;
    do:  ("enc" <-[#sliceT] "$r1");;;
    let: "$r0" := (![#sliceT] "enc") in
    do:  ((struct.field_ref #ApplyAsBackupArgs #"op"%go (![#ptrT] "args")) <-[#sliceT] "$r0");;;
    return: (![#ptrT] "args")).

Definition SetStateArgs : go_type := structT [
  "Epoch" :: uint64T;
  "NextIndex" :: uint64T;
  "CommittedNextIndex" :: uint64T;
  "State" :: sliceT
].

(* go: 0_marshal.go:41:6 *)
Definition EncodeSetStateArgs : val :=
  rec: "EncodeSetStateArgs" "args" :=
    exception_do (let: "args" := (mem.alloc "args") in
    let: "enc" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make3 #byteT #(W64 0) (#(W64 8) + (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref #SetStateArgs #"State"%go (![#ptrT] "args"))) in
    slice.len "$a0")))) in
    do:  ("enc" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "enc") in
    let: "$a1" := (![#uint64T] (struct.field_ref #SetStateArgs #"Epoch"%go (![#ptrT] "args"))) in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("enc" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "enc") in
    let: "$a1" := (![#uint64T] (struct.field_ref #SetStateArgs #"NextIndex"%go (![#ptrT] "args"))) in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("enc" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "enc") in
    let: "$a1" := (![#uint64T] (struct.field_ref #SetStateArgs #"CommittedNextIndex"%go (![#ptrT] "args"))) in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("enc" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "enc") in
    let: "$a1" := (![#sliceT] (struct.field_ref #SetStateArgs #"State"%go (![#ptrT] "args"))) in
    (func_call #marshal.marshal #"WriteBytes"%go) "$a0" "$a1") in
    do:  ("enc" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "enc")).

(* go: 0_marshal.go:50:6 *)
Definition DecodeSetStateArgs : val :=
  rec: "DecodeSetStateArgs" "enc_args" :=
    exception_do (let: "enc_args" := (mem.alloc "enc_args") in
    let: "enc" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "enc_args") in
    do:  ("enc" <-[#sliceT] "$r0");;;
    let: "args" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #SetStateArgs)) in
    do:  ("args" <-[#ptrT] "$r0");;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "enc") in
    (func_call #marshal.marshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ((struct.field_ref #SetStateArgs #"Epoch"%go (![#ptrT] "args")) <-[#uint64T] "$r0");;;
    do:  ("enc" <-[#sliceT] "$r1");;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "enc") in
    (func_call #marshal.marshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ((struct.field_ref #SetStateArgs #"NextIndex"%go (![#ptrT] "args")) <-[#uint64T] "$r0");;;
    do:  ("enc" <-[#sliceT] "$r1");;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "enc") in
    (func_call #marshal.marshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ((struct.field_ref #SetStateArgs #"CommittedNextIndex"%go (![#ptrT] "args")) <-[#uint64T] "$r0");;;
    do:  ("enc" <-[#sliceT] "$r1");;;
    let: "$r0" := (![#sliceT] "enc") in
    do:  ((struct.field_ref #SetStateArgs #"State"%go (![#ptrT] "args")) <-[#sliceT] "$r0");;;
    return: (![#ptrT] "args")).

Definition GetStateArgs : go_type := structT [
  "Epoch" :: uint64T
].

(* go: 0_marshal.go:64:6 *)
Definition EncodeGetStateArgs : val :=
  rec: "EncodeGetStateArgs" "args" :=
    exception_do (let: "args" := (mem.alloc "args") in
    let: "enc" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make3 #byteT #(W64 0) #(W64 8)) in
    do:  ("enc" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "enc") in
    let: "$a1" := (![#uint64T] (struct.field_ref #GetStateArgs #"Epoch"%go (![#ptrT] "args"))) in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("enc" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "enc")).

(* go: 0_marshal.go:70:6 *)
Definition DecodeGetStateArgs : val :=
  rec: "DecodeGetStateArgs" "enc" :=
    exception_do (let: "enc" := (mem.alloc "enc") in
    let: "args" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #GetStateArgs)) in
    do:  ("args" <-[#ptrT] "$r0");;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "enc") in
    (func_call #marshal.marshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ((struct.field_ref #GetStateArgs #"Epoch"%go (![#ptrT] "args")) <-[#uint64T] "$r0");;;
    do:  "$r1";;;
    return: (![#ptrT] "args")).

Definition GetStateReply : go_type := structT [
  "Err" :: uint64T;
  "NextIndex" :: uint64T;
  "CommittedNextIndex" :: uint64T;
  "State" :: sliceT
].

(* go: 0_marshal.go:83:6 *)
Definition EncodeGetStateReply : val :=
  rec: "EncodeGetStateReply" "reply" :=
    exception_do (let: "reply" := (mem.alloc "reply") in
    let: "enc" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make3 #byteT #(W64 0) (#(W64 8) + (let: "$a0" := (![#sliceT] (struct.field_ref #GetStateReply #"State"%go (![#ptrT] "reply"))) in
    slice.len "$a0"))) in
    do:  ("enc" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "enc") in
    let: "$a1" := (![#uint64T] (struct.field_ref #GetStateReply #"Err"%go (![#ptrT] "reply"))) in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("enc" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "enc") in
    let: "$a1" := (![#uint64T] (struct.field_ref #GetStateReply #"NextIndex"%go (![#ptrT] "reply"))) in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("enc" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "enc") in
    let: "$a1" := (![#uint64T] (struct.field_ref #GetStateReply #"CommittedNextIndex"%go (![#ptrT] "reply"))) in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("enc" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "enc") in
    let: "$a1" := (![#sliceT] (struct.field_ref #GetStateReply #"State"%go (![#ptrT] "reply"))) in
    (func_call #marshal.marshal #"WriteBytes"%go) "$a0" "$a1") in
    do:  ("enc" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "enc")).

(* go: 0_marshal.go:92:6 *)
Definition DecodeGetStateReply : val :=
  rec: "DecodeGetStateReply" "enc_reply" :=
    exception_do (let: "enc_reply" := (mem.alloc "enc_reply") in
    let: "enc" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "enc_reply") in
    do:  ("enc" <-[#sliceT] "$r0");;;
    let: "reply" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #GetStateReply)) in
    do:  ("reply" <-[#ptrT] "$r0");;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "enc") in
    (func_call #marshal.marshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ((struct.field_ref #GetStateReply #"Err"%go (![#ptrT] "reply")) <-[#uint64T] "$r0");;;
    do:  ("enc" <-[#sliceT] "$r1");;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "enc") in
    (func_call #marshal.marshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ((struct.field_ref #GetStateReply #"NextIndex"%go (![#ptrT] "reply")) <-[#uint64T] "$r0");;;
    do:  ("enc" <-[#sliceT] "$r1");;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "enc") in
    (func_call #marshal.marshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ((struct.field_ref #GetStateReply #"CommittedNextIndex"%go (![#ptrT] "reply")) <-[#uint64T] "$r0");;;
    do:  ("enc" <-[#sliceT] "$r1");;;
    let: "$r0" := (![#sliceT] "enc") in
    do:  ((struct.field_ref #GetStateReply #"State"%go (![#ptrT] "reply")) <-[#sliceT] "$r0");;;
    return: (![#ptrT] "reply")).

Definition BecomePrimaryArgs : go_type := structT [
  "Epoch" :: uint64T;
  "Replicas" :: sliceT
].

(* go: 0_marshal.go:107:6 *)
Definition EncodeBecomePrimaryArgs : val :=
  rec: "EncodeBecomePrimaryArgs" "args" :=
    exception_do (let: "args" := (mem.alloc "args") in
    let: "enc" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make3 #byteT #(W64 0) (#(W64 (8 + 8)) + (#(W64 8) * (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref #BecomePrimaryArgs #"Replicas"%go (![#ptrT] "args"))) in
    slice.len "$a0"))))) in
    do:  ("enc" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "enc") in
    let: "$a1" := (![#uint64T] (struct.field_ref #BecomePrimaryArgs #"Epoch"%go (![#ptrT] "args"))) in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("enc" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "enc") in
    let: "$a1" := (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref #BecomePrimaryArgs #"Replicas"%go (![#ptrT] "args"))) in
    slice.len "$a0")) in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("enc" <-[#sliceT] "$r0");;;
    let: "$range" := (![#sliceT] (struct.field_ref #BecomePrimaryArgs #"Replicas"%go (![#ptrT] "args"))) in
    (let: "h" := (mem.alloc (type.zero_val #uint64T)) in
    slice.for_range #uint64T "$range" (λ: "$key" "$value",
      do:  ("h" <-[#uint64T] "$value");;;
      do:  "$key";;;
      let: "$r0" := (let: "$a0" := (![#sliceT] "enc") in
      let: "$a1" := (![#uint64T] "h") in
      (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
      do:  ("enc" <-[#sliceT] "$r0")));;;
    return: (![#sliceT] "enc")).

(* go: 0_marshal.go:117:6 *)
Definition DecodeBecomePrimaryArgs : val :=
  rec: "DecodeBecomePrimaryArgs" "enc_args" :=
    exception_do (let: "enc_args" := (mem.alloc "enc_args") in
    let: "enc" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "enc_args") in
    do:  ("enc" <-[#sliceT] "$r0");;;
    let: "args" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #BecomePrimaryArgs)) in
    do:  ("args" <-[#ptrT] "$r0");;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "enc") in
    (func_call #marshal.marshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ((struct.field_ref #BecomePrimaryArgs #"Epoch"%go (![#ptrT] "args")) <-[#uint64T] "$r0");;;
    do:  ("enc" <-[#sliceT] "$r1");;;
    let: "replicasLen" := (mem.alloc (type.zero_val #uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "enc") in
    (func_call #marshal.marshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("replicasLen" <-[#uint64T] "$r0");;;
    do:  ("enc" <-[#sliceT] "$r1");;;
    let: "$r0" := (slice.make2 #uint64T (![#uint64T] "replicasLen")) in
    do:  ((struct.field_ref #BecomePrimaryArgs #"Replicas"%go (![#ptrT] "args")) <-[#sliceT] "$r0");;;
    let: "$range" := (![#sliceT] (struct.field_ref #BecomePrimaryArgs #"Replicas"%go (![#ptrT] "args"))) in
    (let: "i" := (mem.alloc (type.zero_val #intT)) in
    slice.for_range #uint64T "$range" (λ: "$key" "$value",
      do:  ("i" <-[#intT] "$key");;;
      let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "enc") in
      (func_call #marshal.marshal #"ReadInt"%go) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ((slice.elem_ref #uint64T (![#sliceT] (struct.field_ref #BecomePrimaryArgs #"Replicas"%go (![#ptrT] "args"))) (![#intT] "i")) <-[#uint64T] "$r0");;;
      do:  ("enc" <-[#sliceT] "$r1")));;;
    return: (![#ptrT] "args")).

Definition ApplyReply : go_type := structT [
  "Err" :: uint64T;
  "Reply" :: sliceT
].

(* go: 0_marshal.go:135:6 *)
Definition EncodeApplyReply : val :=
  rec: "EncodeApplyReply" "reply" :=
    exception_do (let: "reply" := (mem.alloc "reply") in
    let: "enc" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make3 #byteT #(W64 0) (#(W64 8) + (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref #ApplyReply #"Reply"%go (![#ptrT] "reply"))) in
    slice.len "$a0")))) in
    do:  ("enc" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "enc") in
    let: "$a1" := (![#uint64T] (struct.field_ref #ApplyReply #"Err"%go (![#ptrT] "reply"))) in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("enc" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "enc") in
    let: "$a1" := (![#sliceT] (struct.field_ref #ApplyReply #"Reply"%go (![#ptrT] "reply"))) in
    (func_call #marshal.marshal #"WriteBytes"%go) "$a0" "$a1") in
    do:  ("enc" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "enc")).

(* go: 0_marshal.go:142:6 *)
Definition DecodeApplyReply : val :=
  rec: "DecodeApplyReply" "enc_reply" :=
    exception_do (let: "enc_reply" := (mem.alloc "enc_reply") in
    let: "enc" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "enc_reply") in
    do:  ("enc" <-[#sliceT] "$r0");;;
    let: "reply" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #ApplyReply)) in
    do:  ("reply" <-[#ptrT] "$r0");;;
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "enc") in
    (func_call #marshal.marshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ((struct.field_ref #ApplyReply #"Err"%go (![#ptrT] "reply")) <-[#uint64T] "$r0");;;
    do:  ("enc" <-[#sliceT] "$r1");;;
    let: "$r0" := (![#sliceT] "enc") in
    do:  ((struct.field_ref #ApplyReply #"Reply"%go (![#ptrT] "reply")) <-[#sliceT] "$r0");;;
    return: (![#ptrT] "reply")).

Definition IncreaseCommitArgs : go_type := uint64T.

(* go: 0_marshal.go:153:6 *)
Definition EncodeIncreaseCommitArgs : val :=
  rec: "EncodeIncreaseCommitArgs" "args" :=
    exception_do (let: "args" := (mem.alloc "args") in
    return: (let: "$a0" := #slice.nil in
     let: "$a1" := (![#uint64T] "args") in
     (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1")).

(* go: 0_marshal.go:157:6 *)
Definition DecodeIncreaseCommitArgs : val :=
  rec: "DecodeIncreaseCommitArgs" "args" :=
    exception_do (let: "args" := (mem.alloc "args") in
    let: "a" := (mem.alloc (type.zero_val #uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "args") in
    (func_call #marshal.marshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("a" <-[#uint64T] "$r0");;;
    do:  "$r1";;;
    return: (![#uint64T] "a")).

Definition StateMachine : go_type := structT [
  "StartApply" :: funcT;
  "ApplyReadonly" :: funcT;
  "SetStateAndUnseal" :: funcT;
  "GetStateAndSeal" :: funcT
].

Definition SyncStateMachine : go_type := structT [
  "Apply" :: funcT;
  "ApplyReadonly" :: funcT;
  "SetStateAndUnseal" :: funcT;
  "GetStateAndSeal" :: funcT
].

Definition Clerk : go_type := structT [
  "cl" :: ptrT
].

Definition RPC_APPLYASBACKUP : expr := #(W64 0).

Definition RPC_SETSTATE : expr := #(W64 1).

Definition RPC_GETSTATE : expr := #(W64 2).

Definition RPC_BECOMEPRIMARY : expr := #(W64 3).

Definition RPC_PRIMARYAPPLY : expr := #(W64 4).

Definition RPC_ROPRIMARYAPPLY : expr := #(W64 6).

Definition RPC_INCREASECOMMIT : expr := #(W64 7).

(* go: clerk.go:24:6 *)
Definition MakeClerk : val :=
  rec: "MakeClerk" "host" :=
    exception_do (let: "host" := (mem.alloc "host") in
    return: (mem.alloc (let: "$cl" := (let: "$a0" := (![#uint64T] "host") in
     (func_call #reconnectclient.reconnectclient #"MakeReconnectingClient"%go) "$a0") in
     struct.make #Clerk [{
       "cl" ::= "$cl"
     }]))).

(* go: clerk.go:28:18 *)
Definition Clerk__ApplyAsBackup : val :=
  rec: "Clerk__ApplyAsBackup" "ck" "args" :=
    exception_do (let: "ck" := (mem.alloc "ck") in
    let: "args" := (mem.alloc "args") in
    let: "reply" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #sliceT)) in
    do:  ("reply" <-[#ptrT] "$r0");;;
    let: "err" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (let: "$a0" := RPC_APPLYASBACKUP in
    let: "$a1" := (let: "$a0" := (![#ptrT] "args") in
    (func_call #replica.replica #"EncodeApplyAsBackupArgs"%go) "$a0") in
    let: "$a2" := (![#ptrT] "reply") in
    let: "$a3" := #(W64 1000) in
    (method_call #reconnectclient #"ReconnectingClient'ptr" #"Call" (![#ptrT] (struct.field_ref #Clerk #"cl"%go (![#ptrT] "ck")))) "$a0" "$a1" "$a2" "$a3") in
    do:  ("err" <-[#uint64T] "$r0");;;
    (if: (![#uint64T] "err") ≠ #(W64 0)
    then return: (e.Timeout)
    else
      return: (let: "$a0" := (![#sliceT] (![#ptrT] "reply")) in
       (func_call #e.e #"DecodeError"%go) "$a0"))).

(* go: clerk.go:38:18 *)
Definition Clerk__SetState : val :=
  rec: "Clerk__SetState" "ck" "args" :=
    exception_do (let: "ck" := (mem.alloc "ck") in
    let: "args" := (mem.alloc "args") in
    let: "reply" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #sliceT)) in
    do:  ("reply" <-[#ptrT] "$r0");;;
    let: "err" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (let: "$a0" := RPC_SETSTATE in
    let: "$a1" := (let: "$a0" := (![#ptrT] "args") in
    (func_call #replica.replica #"EncodeSetStateArgs"%go) "$a0") in
    let: "$a2" := (![#ptrT] "reply") in
    let: "$a3" := #(W64 10000) in
    (method_call #reconnectclient #"ReconnectingClient'ptr" #"Call" (![#ptrT] (struct.field_ref #Clerk #"cl"%go (![#ptrT] "ck")))) "$a0" "$a1" "$a2" "$a3") in
    do:  ("err" <-[#uint64T] "$r0");;;
    (if: (![#uint64T] "err") ≠ #(W64 0)
    then return: (e.Timeout)
    else
      return: (let: "$a0" := (![#sliceT] (![#ptrT] "reply")) in
       (func_call #e.e #"DecodeError"%go) "$a0"))).

(* go: clerk.go:48:18 *)
Definition Clerk__GetState : val :=
  rec: "Clerk__GetState" "ck" "args" :=
    exception_do (let: "ck" := (mem.alloc "ck") in
    let: "args" := (mem.alloc "args") in
    let: "reply" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #sliceT)) in
    do:  ("reply" <-[#ptrT] "$r0");;;
    let: "err" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (let: "$a0" := RPC_GETSTATE in
    let: "$a1" := (let: "$a0" := (![#ptrT] "args") in
    (func_call #replica.replica #"EncodeGetStateArgs"%go) "$a0") in
    let: "$a2" := (![#ptrT] "reply") in
    let: "$a3" := #(W64 10000) in
    (method_call #reconnectclient #"ReconnectingClient'ptr" #"Call" (![#ptrT] (struct.field_ref #Clerk #"cl"%go (![#ptrT] "ck")))) "$a0" "$a1" "$a2" "$a3") in
    do:  ("err" <-[#uint64T] "$r0");;;
    (if: (![#uint64T] "err") ≠ #(W64 0)
    then
      return: (mem.alloc (let: "$Err" := e.Timeout in
       struct.make #GetStateReply [{
         "Err" ::= "$Err";
         "NextIndex" ::= type.zero_val #uint64T;
         "CommittedNextIndex" ::= type.zero_val #uint64T;
         "State" ::= type.zero_val #sliceT
       }]))
    else
      return: (let: "$a0" := (![#sliceT] (![#ptrT] "reply")) in
       (func_call #replica.replica #"DecodeGetStateReply"%go) "$a0"))).

(* go: clerk.go:60:18 *)
Definition Clerk__BecomePrimary : val :=
  rec: "Clerk__BecomePrimary" "ck" "args" :=
    exception_do (let: "ck" := (mem.alloc "ck") in
    let: "args" := (mem.alloc "args") in
    let: "reply" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #sliceT)) in
    do:  ("reply" <-[#ptrT] "$r0");;;
    let: "err" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (let: "$a0" := RPC_BECOMEPRIMARY in
    let: "$a1" := (let: "$a0" := (![#ptrT] "args") in
    (func_call #replica.replica #"EncodeBecomePrimaryArgs"%go) "$a0") in
    let: "$a2" := (![#ptrT] "reply") in
    let: "$a3" := #(W64 100) in
    (method_call #reconnectclient #"ReconnectingClient'ptr" #"Call" (![#ptrT] (struct.field_ref #Clerk #"cl"%go (![#ptrT] "ck")))) "$a0" "$a1" "$a2" "$a3") in
    do:  ("err" <-[#uint64T] "$r0");;;
    (if: (![#uint64T] "err") ≠ #(W64 0)
    then return: (e.Timeout)
    else
      return: (let: "$a0" := (![#sliceT] (![#ptrT] "reply")) in
       (func_call #e.e #"DecodeError"%go) "$a0"))).

(* go: clerk.go:70:18 *)
Definition Clerk__Apply : val :=
  rec: "Clerk__Apply" "ck" "op" :=
    exception_do (let: "ck" := (mem.alloc "ck") in
    let: "op" := (mem.alloc "op") in
    let: "reply" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #sliceT)) in
    do:  ("reply" <-[#ptrT] "$r0");;;
    let: "err" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (let: "$a0" := RPC_PRIMARYAPPLY in
    let: "$a1" := (![#sliceT] "op") in
    let: "$a2" := (![#ptrT] "reply") in
    let: "$a3" := #(W64 5000) in
    (method_call #reconnectclient #"ReconnectingClient'ptr" #"Call" (![#ptrT] (struct.field_ref #Clerk #"cl"%go (![#ptrT] "ck")))) "$a0" "$a1" "$a2" "$a3") in
    do:  ("err" <-[#uint64T] "$r0");;;
    (if: (![#uint64T] "err") = #(W64 0)
    then
      let: "r" := (mem.alloc (type.zero_val #ptrT)) in
      let: "$r0" := (let: "$a0" := (![#sliceT] (![#ptrT] "reply")) in
      (func_call #replica.replica #"DecodeApplyReply"%go) "$a0") in
      do:  ("r" <-[#ptrT] "$r0");;;
      return: (![#uint64T] (struct.field_ref #ApplyReply #"Err"%go (![#ptrT] "r")), ![#sliceT] (struct.field_ref #ApplyReply #"Reply"%go (![#ptrT] "r")))
    else return: (e.Timeout, #slice.nil))).

(* go: clerk.go:81:18 *)
Definition Clerk__ApplyRo : val :=
  rec: "Clerk__ApplyRo" "ck" "op" :=
    exception_do (let: "ck" := (mem.alloc "ck") in
    let: "op" := (mem.alloc "op") in
    let: "reply" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #sliceT)) in
    do:  ("reply" <-[#ptrT] "$r0");;;
    let: "err" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (let: "$a0" := RPC_ROPRIMARYAPPLY in
    let: "$a1" := (![#sliceT] "op") in
    let: "$a2" := (![#ptrT] "reply") in
    let: "$a3" := #(W64 1000) in
    (method_call #reconnectclient #"ReconnectingClient'ptr" #"Call" (![#ptrT] (struct.field_ref #Clerk #"cl"%go (![#ptrT] "ck")))) "$a0" "$a1" "$a2" "$a3") in
    do:  ("err" <-[#uint64T] "$r0");;;
    (if: (![#uint64T] "err") = #(W64 0)
    then
      let: "r" := (mem.alloc (type.zero_val #ptrT)) in
      let: "$r0" := (let: "$a0" := (![#sliceT] (![#ptrT] "reply")) in
      (func_call #replica.replica #"DecodeApplyReply"%go) "$a0") in
      do:  ("r" <-[#ptrT] "$r0");;;
      return: (![#uint64T] (struct.field_ref #ApplyReply #"Err"%go (![#ptrT] "r")), ![#sliceT] (struct.field_ref #ApplyReply #"Reply"%go (![#ptrT] "r")))
    else return: (e.Timeout, #slice.nil))).

(* go: clerk.go:92:18 *)
Definition Clerk__IncreaseCommitIndex : val :=
  rec: "Clerk__IncreaseCommitIndex" "ck" "n" :=
    exception_do (let: "ck" := (mem.alloc "ck") in
    let: "n" := (mem.alloc "n") in
    return: (let: "$a0" := RPC_INCREASECOMMIT in
     let: "$a1" := (let: "$a0" := (![#uint64T] "n") in
     (func_call #replica.replica #"EncodeIncreaseCommitArgs"%go) "$a0") in
     let: "$a2" := (mem.alloc (type.zero_val #sliceT)) in
     let: "$a3" := #(W64 100) in
     (method_call #reconnectclient #"ReconnectingClient'ptr" #"Call" (![#ptrT] (struct.field_ref #Clerk #"cl"%go (![#ptrT] "ck")))) "$a0" "$a1" "$a2" "$a3")).

Definition Server : go_type := structT [
  "mu" :: ptrT;
  "epoch" :: uint64T;
  "sealed" :: boolT;
  "sm" :: ptrT;
  "nextIndex" :: uint64T;
  "canBecomePrimary" :: boolT;
  "isPrimary" :: boolT;
  "clerks" :: sliceT;
  "isPrimary_cond" :: ptrT;
  "opAppliedConds" :: mapT uint64T ptrT;
  "leaseExpiration" :: uint64T;
  "leaseValid" :: boolT;
  "committedNextIndex" :: uint64T;
  "committedNextIndex_cond" :: ptrT;
  "confCk" :: ptrT
].

(* Applies the RO op immediately, but then waits for it to be committed before
   replying to client.

   go: server.go:45:18 *)
Definition Server__ApplyRoWaitForCommit : val :=
  rec: "Server__ApplyRoWaitForCommit" "s" "op" :=
    exception_do (let: "s" := (mem.alloc "s") in
    let: "op" := (mem.alloc "op") in
    let: "reply" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #ApplyReply)) in
    do:  ("reply" <-[#ptrT] "$r0");;;
    let: "$r0" := #slice.nil in
    do:  ((struct.field_ref #ApplyReply #"Reply"%go (![#ptrT] "reply")) <-[#sliceT] "$r0");;;
    let: "$r0" := e.None in
    do:  ((struct.field_ref #ApplyReply #"Err"%go (![#ptrT] "reply")) <-[#uint64T] "$r0");;;
    do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #());;;
    (if: (~ (![#boolT] (struct.field_ref #Server #"leaseValid"%go (![#ptrT] "s"))))
    then
      do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #());;;
      do:  (let: "$a0" := #"Lease invalid"%go in
      let: "$a1" := #slice.nil in
      (func_call #log.log #"Printf"%go) "$a0" "$a1");;;
      let: "$r0" := e.LeaseExpired in
      do:  ((struct.field_ref #ApplyReply #"Err"%go (![#ptrT] "reply")) <-[#uint64T] "$r0");;;
      return: (![#ptrT] "reply")
    else do:  #());;;
    (if: (((func_call #primitive.primitive #"RandomUint64"%go) #()) `rem` #(W64 10000)) = #(W64 0)
    then
      do:  (let: "$a0" := #"Server nextIndex=%d commitIndex=%d"%go in
      let: "$a1" := ((let: "$sl0" := (interface.make #""%go #"uint64"%go (![#uint64T] (struct.field_ref #Server #"nextIndex"%go (![#ptrT] "s")))) in
      let: "$sl1" := (interface.make #""%go #"uint64"%go (![#uint64T] (struct.field_ref #Server #"committedNextIndex"%go (![#ptrT] "s")))) in
      slice.literal #interfaceT ["$sl0"; "$sl1"])) in
      (func_call #log.log #"Printf"%go) "$a0" "$a1")
    else do:  #());;;
    let: "lastModifiedIndex" := (mem.alloc (type.zero_val #uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "op") in
    (![#funcT] (struct.field_ref #StateMachine #"ApplyReadonly"%go (![#ptrT] (struct.field_ref #Server #"sm"%go (![#ptrT] "s"))))) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("lastModifiedIndex" <-[#uint64T] "$r0");;;
    do:  ((struct.field_ref #ApplyReply #"Reply"%go (![#ptrT] "reply")) <-[#sliceT] "$r1");;;
    let: "epoch" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (![#uint64T] (struct.field_ref #Server #"epoch"%go (![#ptrT] "s"))) in
    do:  ("epoch" <-[#uint64T] "$r0");;;
    let: "h" := (mem.alloc (type.zero_val #uint64T)) in
    let: ("$ret0", "$ret1") := ((func_call #grove_ffi.grove_ffi #"GetTimeRange"%go) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  "$r0";;;
    do:  ("h" <-[#uint64T] "$r1");;;
    (if: (![#uint64T] (struct.field_ref #Server #"leaseExpiration"%go (![#ptrT] "s"))) ≤ (![#uint64T] "h")
    then
      do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #());;;
      do:  (let: "$a0" := #"Lease expired because %d < %d"%go in
      let: "$a1" := ((let: "$sl0" := (interface.make #""%go #"uint64"%go (![#uint64T] (struct.field_ref #Server #"leaseExpiration"%go (![#ptrT] "s")))) in
      let: "$sl1" := (interface.make #""%go #"uint64"%go (![#uint64T] "h")) in
      slice.literal #interfaceT ["$sl0"; "$sl1"])) in
      (func_call #log.log #"Printf"%go) "$a0" "$a1");;;
      let: "$r0" := e.LeaseExpired in
      do:  ((struct.field_ref #ApplyReply #"Err"%go (![#ptrT] "reply")) <-[#uint64T] "$r0");;;
      return: (![#ptrT] "reply")
    else do:  #());;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      (if: (![#uint64T] (struct.field_ref #Server #"epoch"%go (![#ptrT] "s"))) ≠ (![#uint64T] "epoch")
      then
        let: "$r0" := e.Stale in
        do:  ((struct.field_ref #ApplyReply #"Err"%go (![#ptrT] "reply")) <-[#uint64T] "$r0");;;
        break: #()
      else
        (if: (![#uint64T] "lastModifiedIndex") ≤ (![#uint64T] (struct.field_ref #Server #"committedNextIndex"%go (![#ptrT] "s")))
        then
          let: "$r0" := e.None in
          do:  ((struct.field_ref #ApplyReply #"Err"%go (![#ptrT] "reply")) <-[#uint64T] "$r0");;;
          break: #()
        else
          do:  ((method_call #sync #"Cond'ptr" #"Wait" (![#ptrT] (struct.field_ref #Server #"committedNextIndex_cond"%go (![#ptrT] "s")))) #());;;
          continue: #())));;;
    do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #());;;
    return: (![#ptrT] "reply")).

(* precondition:
   is_epoch_lb epoch ∗ committed_by epoch log ∗ is_pb_log_lb log

   go: server.go:95:18 *)
Definition Server__IncreaseCommitIndex : val :=
  rec: "Server__IncreaseCommitIndex" "s" "newCommittedNextIndex" :=
    exception_do (let: "s" := (mem.alloc "s") in
    let: "newCommittedNextIndex" := (mem.alloc "newCommittedNextIndex") in
    do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #());;;
    (if: ((![#uint64T] "newCommittedNextIndex") > (![#uint64T] (struct.field_ref #Server #"committedNextIndex"%go (![#ptrT] "s")))) && ((![#uint64T] "newCommittedNextIndex") ≤ (![#uint64T] (struct.field_ref #Server #"nextIndex"%go (![#ptrT] "s"))))
    then
      let: "$r0" := (![#uint64T] "newCommittedNextIndex") in
      do:  ((struct.field_ref #Server #"committedNextIndex"%go (![#ptrT] "s")) <-[#uint64T] "$r0");;;
      do:  ((method_call #sync #"Cond'ptr" #"Broadcast" (![#ptrT] (struct.field_ref #Server #"committedNextIndex_cond"%go (![#ptrT] "s")))) #())
    else do:  #());;;
    do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #())).

(* called on the primary server to apply a new operation.

   go: server.go:106:18 *)
Definition Server__Apply : val :=
  rec: "Server__Apply" "s" "op" :=
    exception_do (let: "s" := (mem.alloc "s") in
    let: "op" := (mem.alloc "op") in
    let: "reply" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #ApplyReply)) in
    do:  ("reply" <-[#ptrT] "$r0");;;
    let: "$r0" := #slice.nil in
    do:  ((struct.field_ref #ApplyReply #"Reply"%go (![#ptrT] "reply")) <-[#sliceT] "$r0");;;
    do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #());;;
    (if: (~ (![#boolT] (struct.field_ref #Server #"isPrimary"%go (![#ptrT] "s"))))
    then
      do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #());;;
      let: "$r0" := e.Stale in
      do:  ((struct.field_ref #ApplyReply #"Err"%go (![#ptrT] "reply")) <-[#uint64T] "$r0");;;
      return: (![#ptrT] "reply")
    else do:  #());;;
    (if: ![#boolT] (struct.field_ref #Server #"sealed"%go (![#ptrT] "s"))
    then
      do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #());;;
      let: "$r0" := e.Stale in
      do:  ((struct.field_ref #ApplyReply #"Err"%go (![#ptrT] "reply")) <-[#uint64T] "$r0");;;
      return: (![#ptrT] "reply")
    else do:  #());;;
    let: "waitForDurable" := (mem.alloc (type.zero_val #funcT)) in
    let: "ret" := (mem.alloc (type.zero_val #sliceT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "op") in
    (![#funcT] (struct.field_ref #StateMachine #"StartApply"%go (![#ptrT] (struct.field_ref #Server #"sm"%go (![#ptrT] "s"))))) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("ret" <-[#sliceT] "$r0");;;
    do:  ("waitForDurable" <-[#funcT] "$r1");;;
    let: "$r0" := (![#sliceT] "ret") in
    do:  ((struct.field_ref #ApplyReply #"Reply"%go (![#ptrT] "reply")) <-[#sliceT] "$r0");;;
    let: "opIndex" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (![#uint64T] (struct.field_ref #Server #"nextIndex"%go (![#ptrT] "s"))) in
    do:  ("opIndex" <-[#uint64T] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#uint64T] (struct.field_ref #Server #"nextIndex"%go (![#ptrT] "s"))) in
    let: "$a1" := #(W64 1) in
    (func_call #std.std #"SumAssumeNoOverflow"%go) "$a0" "$a1") in
    do:  ((struct.field_ref #Server #"nextIndex"%go (![#ptrT] "s")) <-[#uint64T] "$r0");;;
    let: "nextIndex" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (![#uint64T] (struct.field_ref #Server #"nextIndex"%go (![#ptrT] "s"))) in
    do:  ("nextIndex" <-[#uint64T] "$r0");;;
    let: "epoch" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (![#uint64T] (struct.field_ref #Server #"epoch"%go (![#ptrT] "s"))) in
    do:  ("epoch" <-[#uint64T] "$r0");;;
    let: "clerks" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] (struct.field_ref #Server #"clerks"%go (![#ptrT] "s"))) in
    do:  ("clerks" <-[#sliceT] "$r0");;;
    do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #());;;
    let: "wg" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #sync.WaitGroup)) in
    do:  ("wg" <-[#ptrT] "$r0");;;
    let: "args" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (let: "$epoch" := (![#uint64T] "epoch") in
    let: "$index" := (![#uint64T] "opIndex") in
    let: "$op" := (![#sliceT] "op") in
    struct.make #ApplyAsBackupArgs [{
      "epoch" ::= "$epoch";
      "index" ::= "$index";
      "op" ::= "$op"
    }])) in
    do:  ("args" <-[#ptrT] "$r0");;;
    let: "clerks_inner" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] (slice.elem_ref #sliceT (![#sliceT] "clerks") (((func_call #primitive.primitive #"RandomUint64"%go) #()) `rem` (s_to_w64 (let: "$a0" := (![#sliceT] "clerks") in
    slice.len "$a0"))))) in
    do:  ("clerks_inner" <-[#sliceT] "$r0");;;
    let: "errs" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make2 #uint64T (let: "$a0" := (![#sliceT] "clerks_inner") in
    slice.len "$a0")) in
    do:  ("errs" <-[#sliceT] "$r0");;;
    let: "$range" := (![#sliceT] "clerks_inner") in
    (let: "clerk" := (mem.alloc (type.zero_val #ptrT)) in
    let: "i" := (mem.alloc (type.zero_val #intT)) in
    slice.for_range #ptrT "$range" (λ: "$key" "$value",
      do:  ("clerk" <-[#ptrT] "$value");;;
      do:  ("i" <-[#intT] "$key");;;
      let: "clerk" := (mem.alloc (type.zero_val #ptrT)) in
      let: "$r0" := (![#ptrT] "clerk") in
      do:  ("clerk" <-[#ptrT] "$r0");;;
      let: "i" := (mem.alloc (type.zero_val #intT)) in
      let: "$r0" := (![#intT] "i") in
      do:  ("i" <-[#intT] "$r0");;;
      do:  (let: "$a0" := #(W64 1) in
      (method_call #sync #"WaitGroup'ptr" #"Add" (![#ptrT] "wg")) "$a0");;;
      let: "$go" := (λ: <>,
        exception_do ((for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
          let: "err" := (mem.alloc (type.zero_val #uint64T)) in
          let: "$r0" := (let: "$a0" := (![#ptrT] "args") in
          (method_call #replica.replica #"Clerk'ptr" #"ApplyAsBackup" (![#ptrT] "clerk")) "$a0") in
          do:  ("err" <-[#uint64T] "$r0");;;
          (if: ((![#uint64T] "err") = e.OutOfOrder) || ((![#uint64T] "err") = e.Timeout)
          then continue: #()
          else
            let: "$r0" := (![#uint64T] "err") in
            do:  ((slice.elem_ref #uint64T (![#sliceT] "errs") (![#intT] "i")) <-[#uint64T] "$r0");;;
            break: #()));;;
        do:  ((method_call #sync #"WaitGroup'ptr" #"Done" (![#ptrT] "wg")) #()))
        ) in
      do:  (Fork ("$go" #()))));;;
    do:  ((method_call #sync #"WaitGroup'ptr" #"Wait" (![#ptrT] "wg")) #());;;
    do:  ((![#funcT] "waitForDurable") #());;;
    let: "err" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := e.None in
    do:  ("err" <-[#uint64T] "$r0");;;
    let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (for: (λ: <>, (![#uint64T] "i") < (s_to_w64 (let: "$a0" := (![#sliceT] "clerks_inner") in
    slice.len "$a0"))); (λ: <>, Skip) := λ: <>,
      let: "err2" := (mem.alloc (type.zero_val #uint64T)) in
      let: "$r0" := (![#uint64T] (slice.elem_ref #uint64T (![#sliceT] "errs") (![#uint64T] "i"))) in
      do:  ("err2" <-[#uint64T] "$r0");;;
      (if: (![#uint64T] "err2") ≠ e.None
      then
        let: "$r0" := (![#uint64T] "err2") in
        do:  ("err" <-[#uint64T] "$r0")
      else do:  #());;;
      do:  ("i" <-[#uint64T] ((![#uint64T] "i") + #(W64 1))));;;
    let: "$r0" := (![#uint64T] "err") in
    do:  ((struct.field_ref #ApplyReply #"Err"%go (![#ptrT] "reply")) <-[#uint64T] "$r0");;;
    (if: (![#uint64T] "err") = e.None
    then
      do:  (let: "$a0" := (![#uint64T] "nextIndex") in
      (method_call #replica.replica #"Server'ptr" #"IncreaseCommitIndex" (![#ptrT] "s")) "$a0")
    else
      do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #());;;
      (if: (![#uint64T] (struct.field_ref #Server #"epoch"%go (![#ptrT] "s"))) = (![#uint64T] "epoch")
      then
        let: "$r0" := #false in
        do:  ((struct.field_ref #Server #"isPrimary"%go (![#ptrT] "s")) <-[#boolT] "$r0")
      else do:  #());;;
      do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #()));;;
    return: (![#ptrT] "reply")).

(* go: server.go:203:18 *)
Definition Server__leaseRenewalThread : val :=
  rec: "Server__leaseRenewalThread" "s" <> :=
    exception_do (let: "s" := (mem.alloc "s") in
    let: "latestEpoch" := (mem.alloc (type.zero_val #uint64T)) in
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "leaseExpiration" := (mem.alloc (type.zero_val #uint64T)) in
      let: "leaseErr" := (mem.alloc (type.zero_val #uint64T)) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![#uint64T] "latestEpoch") in
      (method_call #configservice #"Clerk'ptr" #"GetLease" (![#ptrT] (struct.field_ref #Server #"confCk"%go (![#ptrT] "s")))) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("leaseErr" <-[#uint64T] "$r0");;;
      do:  ("leaseExpiration" <-[#uint64T] "$r1");;;
      do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #());;;
      (if: ((![#uint64T] (struct.field_ref #Server #"epoch"%go (![#ptrT] "s"))) = (![#uint64T] "latestEpoch")) && ((![#uint64T] "leaseErr") = e.None)
      then
        let: "$r0" := (![#uint64T] "leaseExpiration") in
        do:  ((struct.field_ref #Server #"leaseExpiration"%go (![#ptrT] "s")) <-[#uint64T] "$r0");;;
        let: "$r0" := #true in
        do:  ((struct.field_ref #Server #"leaseValid"%go (![#ptrT] "s")) <-[#boolT] "$r0");;;
        do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #());;;
        do:  (let: "$a0" := (#(W64 250) * #(W64 1000000)) in
        (func_call #primitive.primitive #"Sleep"%go) "$a0")
      else
        (if: (![#uint64T] "latestEpoch") ≠ (![#uint64T] (struct.field_ref #Server #"epoch"%go (![#ptrT] "s")))
        then
          let: "$r0" := (![#uint64T] (struct.field_ref #Server #"epoch"%go (![#ptrT] "s"))) in
          do:  ("latestEpoch" <-[#uint64T] "$r0");;;
          do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #())
        else
          do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #());;;
          do:  (let: "$a0" := (#(W64 50) * #(W64 1000000)) in
          (func_call #primitive.primitive #"Sleep"%go) "$a0"))))).

(* go: server.go:228:18 *)
Definition Server__sendIncreaseCommitThread : val :=
  rec: "Server__sendIncreaseCommitThread" "s" <> :=
    exception_do (let: "s" := (mem.alloc "s") in
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #());;;
      (for: (λ: <>, (~ (![#boolT] (struct.field_ref #Server #"isPrimary"%go (![#ptrT] "s")))) || ((let: "$a0" := (![#sliceT] (slice.elem_ref #sliceT (![#sliceT] (struct.field_ref #Server #"clerks"%go (![#ptrT] "s"))) #(W64 0))) in
      slice.len "$a0") = #(W64 0))); (λ: <>, Skip) := λ: <>,
        do:  ((method_call #sync #"Cond'ptr" #"Wait" (![#ptrT] (struct.field_ref #Server #"isPrimary_cond"%go (![#ptrT] "s")))) #()));;;
      let: "newCommittedNextIndex" := (mem.alloc (type.zero_val #uint64T)) in
      let: "$r0" := (![#uint64T] (struct.field_ref #Server #"committedNextIndex"%go (![#ptrT] "s"))) in
      do:  ("newCommittedNextIndex" <-[#uint64T] "$r0");;;
      let: "clerks" := (mem.alloc (type.zero_val #sliceT)) in
      let: "$r0" := (![#sliceT] (struct.field_ref #Server #"clerks"%go (![#ptrT] "s"))) in
      do:  ("clerks" <-[#sliceT] "$r0");;;
      do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #());;;
      let: "clerks_inner" := (mem.alloc (type.zero_val #sliceT)) in
      let: "$r0" := (![#sliceT] (slice.elem_ref #sliceT (![#sliceT] "clerks") (((func_call #primitive.primitive #"RandomUint64"%go) #()) `rem` (s_to_w64 (let: "$a0" := (![#sliceT] "clerks") in
      slice.len "$a0"))))) in
      do:  ("clerks_inner" <-[#sliceT] "$r0");;;
      let: "wg" := (mem.alloc (type.zero_val #ptrT)) in
      let: "$r0" := (mem.alloc (type.zero_val #sync.WaitGroup)) in
      do:  ("wg" <-[#ptrT] "$r0");;;
      let: "$range" := (![#sliceT] "clerks_inner") in
      (let: "clerk" := (mem.alloc (type.zero_val #ptrT)) in
      slice.for_range #ptrT "$range" (λ: "$key" "$value",
        do:  ("clerk" <-[#ptrT] "$value");;;
        do:  "$key";;;
        let: "clerk" := (mem.alloc (type.zero_val #ptrT)) in
        let: "$r0" := (![#ptrT] "clerk") in
        do:  ("clerk" <-[#ptrT] "$r0");;;
        do:  (let: "$a0" := #(W64 1) in
        (method_call #sync #"WaitGroup'ptr" #"Add" (![#ptrT] "wg")) "$a0");;;
        let: "$go" := (λ: <>,
          exception_do ((for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
            let: "err" := (mem.alloc (type.zero_val #uint64T)) in
            let: "$r0" := (let: "$a0" := (![#uint64T] "newCommittedNextIndex") in
            (method_call #replica.replica #"Clerk'ptr" #"IncreaseCommitIndex" (![#ptrT] "clerk")) "$a0") in
            do:  ("err" <-[#uint64T] "$r0");;;
            (if: (![#uint64T] "err") = e.None
            then break: #()
            else continue: #()));;;
          do:  ((method_call #sync #"WaitGroup'ptr" #"Done" (![#ptrT] "wg")) #()))
          ) in
        do:  (Fork ("$go" #()))));;;
      do:  ((method_call #sync #"WaitGroup'ptr" #"Wait" (![#ptrT] "wg")) #());;;
      do:  (let: "$a0" := #(W64 5000000) in
      (func_call #primitive.primitive #"Sleep"%go) "$a0"))).

(* requires that we've already at least entered this epoch
   returns true iff stale

   go: server.go:272:18 *)
Definition Server__isEpochStale : val :=
  rec: "Server__isEpochStale" "s" "epoch" :=
    exception_do (let: "s" := (mem.alloc "s") in
    let: "epoch" := (mem.alloc "epoch") in
    return: ((![#uint64T] (struct.field_ref #Server #"epoch"%go (![#ptrT] "s"))) ≠ (![#uint64T] "epoch"))).

(* called on backup servers to apply an operation so it is replicated and
   can be considered committed by primary.

   go: server.go:278:18 *)
Definition Server__ApplyAsBackup : val :=
  rec: "Server__ApplyAsBackup" "s" "args" :=
    exception_do (let: "s" := (mem.alloc "s") in
    let: "args" := (mem.alloc "args") in
    do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #());;;
    (for: (λ: <>, (((![#uint64T] (struct.field_ref #ApplyAsBackupArgs #"index"%go (![#ptrT] "args"))) > (![#uint64T] (struct.field_ref #Server #"nextIndex"%go (![#ptrT] "s")))) && ((![#uint64T] (struct.field_ref #Server #"epoch"%go (![#ptrT] "s"))) = (![#uint64T] (struct.field_ref #ApplyAsBackupArgs #"epoch"%go (![#ptrT] "args"))))) && (~ (![#boolT] (struct.field_ref #Server #"sealed"%go (![#ptrT] "s"))))); (λ: <>, Skip) := λ: <>,
      let: "ok" := (mem.alloc (type.zero_val #boolT)) in
      let: "cond" := (mem.alloc (type.zero_val #ptrT)) in
      let: ("$ret0", "$ret1") := (map.get (![type.mapT #uint64T #ptrT] (struct.field_ref #Server #"opAppliedConds"%go (![#ptrT] "s"))) (![#uint64T] (struct.field_ref #ApplyAsBackupArgs #"index"%go (![#ptrT] "args")))) in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("cond" <-[#ptrT] "$r0");;;
      do:  ("ok" <-[#boolT] "$r1");;;
      (if: (~ (![#boolT] "ok"))
      then
        let: "cond" := (mem.alloc (type.zero_val #ptrT)) in
        let: "$r0" := (let: "$a0" := (interface.make #sync #"Mutex'ptr" (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) in
        (func_call #sync.sync #"NewCond"%go) "$a0") in
        do:  ("cond" <-[#ptrT] "$r0");;;
        let: "$r0" := (![#ptrT] "cond") in
        do:  (map.insert (![type.mapT #uint64T #ptrT] (struct.field_ref #Server #"opAppliedConds"%go (![#ptrT] "s"))) (![#uint64T] (struct.field_ref #ApplyAsBackupArgs #"index"%go (![#ptrT] "args"))) "$r0")
      else do:  ((method_call #sync #"Cond'ptr" #"Wait" (![#ptrT] "cond")) #())));;;
    (if: ![#boolT] (struct.field_ref #Server #"sealed"%go (![#ptrT] "s"))
    then
      do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #());;;
      return: (e.Stale)
    else do:  #());;;
    (if: let: "$a0" := (![#uint64T] (struct.field_ref #ApplyAsBackupArgs #"epoch"%go (![#ptrT] "args"))) in
    (method_call #replica.replica #"Server'ptr" #"isEpochStale" (![#ptrT] "s")) "$a0"
    then
      do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #());;;
      return: (e.Stale)
    else do:  #());;;
    (if: (![#uint64T] (struct.field_ref #ApplyAsBackupArgs #"index"%go (![#ptrT] "args"))) ≠ (![#uint64T] (struct.field_ref #Server #"nextIndex"%go (![#ptrT] "s")))
    then
      do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #());;;
      return: (e.OutOfOrder)
    else do:  #());;;
    let: "waitFn" := (mem.alloc (type.zero_val #funcT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] (struct.field_ref #ApplyAsBackupArgs #"op"%go (![#ptrT] "args"))) in
    (![#funcT] (struct.field_ref #StateMachine #"StartApply"%go (![#ptrT] (struct.field_ref #Server #"sm"%go (![#ptrT] "s"))))) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  "$r0";;;
    do:  ("waitFn" <-[#funcT] "$r1");;;
    do:  ((struct.field_ref #Server #"nextIndex"%go (![#ptrT] "s")) <-[#uint64T] ((![#uint64T] (struct.field_ref #Server #"nextIndex"%go (![#ptrT] "s"))) + #(W64 1)));;;
    let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "cond" := (mem.alloc (type.zero_val #ptrT)) in
    let: ("$ret0", "$ret1") := (map.get (![type.mapT #uint64T #ptrT] (struct.field_ref #Server #"opAppliedConds"%go (![#ptrT] "s"))) (![#uint64T] (struct.field_ref #Server #"nextIndex"%go (![#ptrT] "s")))) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("cond" <-[#ptrT] "$r0");;;
    do:  ("ok" <-[#boolT] "$r1");;;
    (if: ![#boolT] "ok"
    then
      do:  ((method_call #sync #"Cond'ptr" #"Signal" (![#ptrT] "cond")) #());;;
      do:  (let: "$a0" := (![type.mapT #uint64T #ptrT] (struct.field_ref #Server #"opAppliedConds"%go (![#ptrT] "s"))) in
      let: "$a1" := (![#uint64T] (struct.field_ref #Server #"nextIndex"%go (![#ptrT] "s"))) in
      map.delete "$a0" "$a1")
    else do:  #());;;
    do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #());;;
    do:  ((![#funcT] "waitFn") #());;;
    return: (e.None)).

(* go: server.go:339:18 *)
Definition Server__SetState : val :=
  rec: "Server__SetState" "s" "args" :=
    exception_do (let: "s" := (mem.alloc "s") in
    let: "args" := (mem.alloc "args") in
    do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #());;;
    (if: (![#uint64T] (struct.field_ref #Server #"epoch"%go (![#ptrT] "s"))) > (![#uint64T] (struct.field_ref #SetStateArgs #"Epoch"%go (![#ptrT] "args")))
    then
      do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #());;;
      return: (e.Stale)
    else
      (if: (![#uint64T] (struct.field_ref #Server #"epoch"%go (![#ptrT] "s"))) = (![#uint64T] (struct.field_ref #SetStateArgs #"Epoch"%go (![#ptrT] "args")))
      then
        do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #());;;
        return: (e.None)
      else
        do:  (let: "$a0" := ((let: "$sl0" := (interface.make #""%go #"string"%go #"Entered new epoch"%go) in
        slice.literal #interfaceT ["$sl0"])) in
        (func_call #log.log #"Print"%go) "$a0");;;
        let: "$r0" := #false in
        do:  ((struct.field_ref #Server #"isPrimary"%go (![#ptrT] "s")) <-[#boolT] "$r0");;;
        let: "$r0" := #true in
        do:  ((struct.field_ref #Server #"canBecomePrimary"%go (![#ptrT] "s")) <-[#boolT] "$r0");;;
        let: "$r0" := (![#uint64T] (struct.field_ref #SetStateArgs #"Epoch"%go (![#ptrT] "args"))) in
        do:  ((struct.field_ref #Server #"epoch"%go (![#ptrT] "s")) <-[#uint64T] "$r0");;;
        let: "$r0" := #false in
        do:  ((struct.field_ref #Server #"leaseValid"%go (![#ptrT] "s")) <-[#boolT] "$r0");;;
        let: "$r0" := #false in
        do:  ((struct.field_ref #Server #"sealed"%go (![#ptrT] "s")) <-[#boolT] "$r0");;;
        let: "$r0" := (![#uint64T] (struct.field_ref #SetStateArgs #"NextIndex"%go (![#ptrT] "args"))) in
        do:  ((struct.field_ref #Server #"nextIndex"%go (![#ptrT] "s")) <-[#uint64T] "$r0");;;
        do:  (let: "$a0" := (![#sliceT] (struct.field_ref #SetStateArgs #"State"%go (![#ptrT] "args"))) in
        let: "$a1" := (![#uint64T] (struct.field_ref #SetStateArgs #"NextIndex"%go (![#ptrT] "args"))) in
        let: "$a2" := (![#uint64T] (struct.field_ref #SetStateArgs #"Epoch"%go (![#ptrT] "args"))) in
        (![#funcT] (struct.field_ref #StateMachine #"SetStateAndUnseal"%go (![#ptrT] (struct.field_ref #Server #"sm"%go (![#ptrT] "s"))))) "$a0" "$a1" "$a2");;;
        let: "$range" := (![type.mapT #uint64T #ptrT] (struct.field_ref #Server #"opAppliedConds"%go (![#ptrT] "s"))) in
        (let: "cond" := (mem.alloc (type.zero_val #ptrT)) in
        map.for_range "$range" (λ: "$key" "value",
          do:  ("cond" <-[#ptrT] "$value");;;
          do:  "$key";;;
          do:  ((method_call #sync #"Cond'ptr" #"Signal" (![#ptrT] "cond")) #())));;;
        do:  ((method_call #sync #"Cond'ptr" #"Broadcast" (![#ptrT] (struct.field_ref #Server #"committedNextIndex_cond"%go (![#ptrT] "s")))) #());;;
        let: "$r0" := (map.make #uint64T #ptrT) in
        do:  ((struct.field_ref #Server #"opAppliedConds"%go (![#ptrT] "s")) <-[type.mapT #uint64T #ptrT] "$r0");;;
        do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #());;;
        do:  (let: "$a0" := (![#uint64T] (struct.field_ref #SetStateArgs #"CommittedNextIndex"%go (![#ptrT] "args"))) in
        (method_call #replica.replica #"Server'ptr" #"IncreaseCommitIndex" (![#ptrT] "s")) "$a0");;;
        return: (e.None)))).

(* XXX: probably should rename to GetStateAndSeal

   go: server.go:370:18 *)
Definition Server__GetState : val :=
  rec: "Server__GetState" "s" "args" :=
    exception_do (let: "s" := (mem.alloc "s") in
    let: "args" := (mem.alloc "args") in
    do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #());;;
    (if: (![#uint64T] (struct.field_ref #GetStateArgs #"Epoch"%go (![#ptrT] "args"))) < (![#uint64T] (struct.field_ref #Server #"epoch"%go (![#ptrT] "s")))
    then
      do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #());;;
      return: (mem.alloc (let: "$Err" := e.Stale in
       let: "$State" := #slice.nil in
       struct.make #GetStateReply [{
         "Err" ::= "$Err";
         "NextIndex" ::= type.zero_val #uint64T;
         "CommittedNextIndex" ::= type.zero_val #uint64T;
         "State" ::= "$State"
       }]))
    else do:  #());;;
    let: "$r0" := #true in
    do:  ((struct.field_ref #Server #"sealed"%go (![#ptrT] "s")) <-[#boolT] "$r0");;;
    let: "ret" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := ((![#funcT] (struct.field_ref #StateMachine #"GetStateAndSeal"%go (![#ptrT] (struct.field_ref #Server #"sm"%go (![#ptrT] "s"))))) #()) in
    do:  ("ret" <-[#sliceT] "$r0");;;
    let: "nextIndex" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (![#uint64T] (struct.field_ref #Server #"nextIndex"%go (![#ptrT] "s"))) in
    do:  ("nextIndex" <-[#uint64T] "$r0");;;
    let: "committedNextIndex" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (![#uint64T] (struct.field_ref #Server #"committedNextIndex"%go (![#ptrT] "s"))) in
    do:  ("committedNextIndex" <-[#uint64T] "$r0");;;
    let: "$range" := (![type.mapT #uint64T #ptrT] (struct.field_ref #Server #"opAppliedConds"%go (![#ptrT] "s"))) in
    (let: "cond" := (mem.alloc (type.zero_val #ptrT)) in
    map.for_range "$range" (λ: "$key" "value",
      do:  ("cond" <-[#ptrT] "$value");;;
      do:  "$key";;;
      do:  ((method_call #sync #"Cond'ptr" #"Signal" (![#ptrT] "cond")) #())));;;
    let: "$r0" := (map.make #uint64T #ptrT) in
    do:  ((struct.field_ref #Server #"opAppliedConds"%go (![#ptrT] "s")) <-[type.mapT #uint64T #ptrT] "$r0");;;
    do:  ((method_call #sync #"Cond'ptr" #"Broadcast" (![#ptrT] (struct.field_ref #Server #"committedNextIndex_cond"%go (![#ptrT] "s")))) #());;;
    do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #());;;
    return: (mem.alloc (let: "$Err" := e.None in
     let: "$State" := (![#sliceT] "ret") in
     let: "$NextIndex" := (![#uint64T] "nextIndex") in
     let: "$CommittedNextIndex" := (![#uint64T] "committedNextIndex") in
     struct.make #GetStateReply [{
       "Err" ::= "$Err";
       "NextIndex" ::= "$NextIndex";
       "CommittedNextIndex" ::= "$CommittedNextIndex";
       "State" ::= "$State"
     }]))).

(* go: server.go:393:18 *)
Definition Server__BecomePrimary : val :=
  rec: "Server__BecomePrimary" "s" "args" :=
    exception_do (let: "s" := (mem.alloc "s") in
    let: "args" := (mem.alloc "args") in
    do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #());;;
    (if: ((![#uint64T] (struct.field_ref #BecomePrimaryArgs #"Epoch"%go (![#ptrT] "args"))) ≠ (![#uint64T] (struct.field_ref #Server #"epoch"%go (![#ptrT] "s")))) || (~ (![#boolT] (struct.field_ref #Server #"canBecomePrimary"%go (![#ptrT] "s"))))
    then
      do:  (let: "$a0" := #"Wrong epoch in BecomePrimary request (in %d, got %d)"%go in
      let: "$a1" := ((let: "$sl0" := (interface.make #""%go #"uint64"%go (![#uint64T] (struct.field_ref #Server #"epoch"%go (![#ptrT] "s")))) in
      let: "$sl1" := (interface.make #""%go #"uint64"%go (![#uint64T] (struct.field_ref #BecomePrimaryArgs #"Epoch"%go (![#ptrT] "args")))) in
      slice.literal #interfaceT ["$sl0"; "$sl1"])) in
      (func_call #log.log #"Printf"%go) "$a0" "$a1");;;
      do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #());;;
      return: (e.Stale)
    else do:  #());;;
    do:  (let: "$a0" := ((let: "$sl0" := (interface.make #""%go #"string"%go #"Became Primary"%go) in
    slice.literal #interfaceT ["$sl0"])) in
    (func_call #log.log #"Println"%go) "$a0");;;
    let: "$r0" := #true in
    do:  ((struct.field_ref #Server #"isPrimary"%go (![#ptrT] "s")) <-[#boolT] "$r0");;;
    do:  ((method_call #sync #"Cond'ptr" #"Signal" (![#ptrT] (struct.field_ref #Server #"isPrimary_cond"%go (![#ptrT] "s")))) #());;;
    let: "$r0" := #false in
    do:  ((struct.field_ref #Server #"canBecomePrimary"%go (![#ptrT] "s")) <-[#boolT] "$r0");;;
    let: "numClerks" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 32) in
    do:  ("numClerks" <-[#uint64T] "$r0");;;
    let: "$r0" := (slice.make2 #sliceT (![#uint64T] "numClerks")) in
    do:  ((struct.field_ref #Server #"clerks"%go (![#ptrT] "s")) <-[#sliceT] "$r0");;;
    let: "j" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("j" <-[#uint64T] "$r0");;;
    (for: (λ: <>, (![#uint64T] "j") < (![#uint64T] "numClerks")); (λ: <>, Skip) := λ: <>,
      let: "clerks" := (mem.alloc (type.zero_val #sliceT)) in
      let: "$r0" := (slice.make2 #ptrT ((let: "$a0" := (![#sliceT] (struct.field_ref #BecomePrimaryArgs #"Replicas"%go (![#ptrT] "args"))) in
      slice.len "$a0") - #(W64 1))) in
      do:  ("clerks" <-[#sliceT] "$r0");;;
      let: "i" := (mem.alloc (type.zero_val #uint64T)) in
      let: "$r0" := #(W64 0) in
      do:  ("i" <-[#uint64T] "$r0");;;
      (for: (λ: <>, (![#uint64T] "i") < (s_to_w64 (let: "$a0" := (![#sliceT] "clerks") in
      slice.len "$a0"))); (λ: <>, Skip) := λ: <>,
        let: "$r0" := (let: "$a0" := (![#uint64T] (slice.elem_ref #uint64T (![#sliceT] (struct.field_ref #BecomePrimaryArgs #"Replicas"%go (![#ptrT] "args"))) ((![#uint64T] "i") + #(W64 1)))) in
        (func_call #replica.replica #"MakeClerk"%go) "$a0") in
        do:  ((slice.elem_ref #ptrT (![#sliceT] "clerks") (![#uint64T] "i")) <-[#ptrT] "$r0");;;
        do:  ("i" <-[#uint64T] ((![#uint64T] "i") + #(W64 1))));;;
      let: "$r0" := (![#sliceT] "clerks") in
      do:  ((slice.elem_ref #sliceT (![#sliceT] (struct.field_ref #Server #"clerks"%go (![#ptrT] "s"))) (![#uint64T] "j")) <-[#sliceT] "$r0");;;
      do:  ("j" <-[#uint64T] ((![#uint64T] "j") + #(W64 1))));;;
    do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) #());;;
    return: (e.None)).

(* go: server.go:427:6 *)
Definition MakeServer : val :=
  rec: "MakeServer" "sm" "confHosts" "nextIndex" "epoch" "sealed" :=
    exception_do (let: "sealed" := (mem.alloc "sealed") in
    let: "epoch" := (mem.alloc "epoch") in
    let: "nextIndex" := (mem.alloc "nextIndex") in
    let: "confHosts" := (mem.alloc "confHosts") in
    let: "sm" := (mem.alloc "sm") in
    let: "s" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #Server)) in
    do:  ("s" <-[#ptrT] "$r0");;;
    let: "$r0" := (mem.alloc (type.zero_val #sync.Mutex)) in
    do:  ((struct.field_ref #Server #"mu"%go (![#ptrT] "s")) <-[#ptrT] "$r0");;;
    let: "$r0" := (![#uint64T] "epoch") in
    do:  ((struct.field_ref #Server #"epoch"%go (![#ptrT] "s")) <-[#uint64T] "$r0");;;
    let: "$r0" := (![#boolT] "sealed") in
    do:  ((struct.field_ref #Server #"sealed"%go (![#ptrT] "s")) <-[#boolT] "$r0");;;
    let: "$r0" := (![#ptrT] "sm") in
    do:  ((struct.field_ref #Server #"sm"%go (![#ptrT] "s")) <-[#ptrT] "$r0");;;
    let: "$r0" := (![#uint64T] "nextIndex") in
    do:  ((struct.field_ref #Server #"nextIndex"%go (![#ptrT] "s")) <-[#uint64T] "$r0");;;
    let: "$r0" := #false in
    do:  ((struct.field_ref #Server #"isPrimary"%go (![#ptrT] "s")) <-[#boolT] "$r0");;;
    let: "$r0" := #false in
    do:  ((struct.field_ref #Server #"canBecomePrimary"%go (![#ptrT] "s")) <-[#boolT] "$r0");;;
    let: "$r0" := #false in
    do:  ((struct.field_ref #Server #"leaseValid"%go (![#ptrT] "s")) <-[#boolT] "$r0");;;
    let: "$r0" := #false in
    do:  ((struct.field_ref #Server #"canBecomePrimary"%go (![#ptrT] "s")) <-[#boolT] "$r0");;;
    let: "$r0" := (map.make #uint64T #ptrT) in
    do:  ((struct.field_ref #Server #"opAppliedConds"%go (![#ptrT] "s")) <-[type.mapT #uint64T #ptrT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] "confHosts") in
    (func_call #configservice.configservice #"MakeClerk"%go) "$a0") in
    do:  ((struct.field_ref #Server #"confCk"%go (![#ptrT] "s")) <-[#ptrT] "$r0");;;
    let: "$r0" := (let: "$a0" := (interface.make #sync #"Mutex'ptr" (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) in
    (func_call #sync.sync #"NewCond"%go) "$a0") in
    do:  ((struct.field_ref #Server #"committedNextIndex_cond"%go (![#ptrT] "s")) <-[#ptrT] "$r0");;;
    let: "$r0" := (let: "$a0" := (interface.make #sync #"Mutex'ptr" (![#ptrT] (struct.field_ref #Server #"mu"%go (![#ptrT] "s")))) in
    (func_call #sync.sync #"NewCond"%go) "$a0") in
    do:  ((struct.field_ref #Server #"isPrimary_cond"%go (![#ptrT] "s")) <-[#ptrT] "$r0");;;
    return: (![#ptrT] "s")).

(* go: server.go:446:18 *)
Definition Server__Serve : val :=
  rec: "Server__Serve" "s" "me" :=
    exception_do (let: "s" := (mem.alloc "s") in
    let: "me" := (mem.alloc "me") in
    let: "handlers" := (mem.alloc (type.zero_val (type.mapT #uint64T #funcT))) in
    let: "$r0" := (map.make #uint64T #funcT) in
    do:  ("handlers" <-[type.mapT #uint64T #funcT] "$r0");;;
    let: "$r0" := (λ: "args" "reply",
      exception_do (let: "reply" := (mem.alloc "reply") in
      let: "args" := (mem.alloc "args") in
      let: "$r0" := (let: "$a0" := (let: "$a0" := (let: "$a0" := (![#sliceT] "args") in
      (func_call #replica.replica #"DecodeApplyAsBackupArgs"%go) "$a0") in
      (method_call #replica.replica #"Server'ptr" #"ApplyAsBackup" (![#ptrT] "s")) "$a0") in
      (func_call #e.e #"EncodeError"%go) "$a0") in
      do:  ((![#ptrT] "reply") <-[#sliceT] "$r0"))
      ) in
    do:  (map.insert (![type.mapT #uint64T #funcT] "handlers") RPC_APPLYASBACKUP "$r0");;;
    let: "$r0" := (λ: "args" "reply",
      exception_do (let: "reply" := (mem.alloc "reply") in
      let: "args" := (mem.alloc "args") in
      let: "$r0" := (let: "$a0" := (let: "$a0" := (let: "$a0" := (![#sliceT] "args") in
      (func_call #replica.replica #"DecodeSetStateArgs"%go) "$a0") in
      (method_call #replica.replica #"Server'ptr" #"SetState" (![#ptrT] "s")) "$a0") in
      (func_call #e.e #"EncodeError"%go) "$a0") in
      do:  ((![#ptrT] "reply") <-[#sliceT] "$r0"))
      ) in
    do:  (map.insert (![type.mapT #uint64T #funcT] "handlers") RPC_SETSTATE "$r0");;;
    let: "$r0" := (λ: "args" "reply",
      exception_do (let: "reply" := (mem.alloc "reply") in
      let: "args" := (mem.alloc "args") in
      let: "$r0" := (let: "$a0" := (let: "$a0" := (let: "$a0" := (![#sliceT] "args") in
      (func_call #replica.replica #"DecodeGetStateArgs"%go) "$a0") in
      (method_call #replica.replica #"Server'ptr" #"GetState" (![#ptrT] "s")) "$a0") in
      (func_call #replica.replica #"EncodeGetStateReply"%go) "$a0") in
      do:  ((![#ptrT] "reply") <-[#sliceT] "$r0"))
      ) in
    do:  (map.insert (![type.mapT #uint64T #funcT] "handlers") RPC_GETSTATE "$r0");;;
    let: "$r0" := (λ: "args" "reply",
      exception_do (let: "reply" := (mem.alloc "reply") in
      let: "args" := (mem.alloc "args") in
      let: "$r0" := (let: "$a0" := (let: "$a0" := (let: "$a0" := (![#sliceT] "args") in
      (func_call #replica.replica #"DecodeBecomePrimaryArgs"%go) "$a0") in
      (method_call #replica.replica #"Server'ptr" #"BecomePrimary" (![#ptrT] "s")) "$a0") in
      (func_call #e.e #"EncodeError"%go) "$a0") in
      do:  ((![#ptrT] "reply") <-[#sliceT] "$r0"))
      ) in
    do:  (map.insert (![type.mapT #uint64T #funcT] "handlers") RPC_BECOMEPRIMARY "$r0");;;
    let: "$r0" := (λ: "args" "reply",
      exception_do (let: "reply" := (mem.alloc "reply") in
      let: "args" := (mem.alloc "args") in
      let: "$r0" := (let: "$a0" := (let: "$a0" := (![#sliceT] "args") in
      (method_call #replica.replica #"Server'ptr" #"Apply" (![#ptrT] "s")) "$a0") in
      (func_call #replica.replica #"EncodeApplyReply"%go) "$a0") in
      do:  ((![#ptrT] "reply") <-[#sliceT] "$r0"))
      ) in
    do:  (map.insert (![type.mapT #uint64T #funcT] "handlers") RPC_PRIMARYAPPLY "$r0");;;
    let: "$r0" := (λ: "args" "reply",
      exception_do (let: "reply" := (mem.alloc "reply") in
      let: "args" := (mem.alloc "args") in
      let: "$r0" := (let: "$a0" := (let: "$a0" := (![#sliceT] "args") in
      (method_call #replica.replica #"Server'ptr" #"ApplyRoWaitForCommit" (![#ptrT] "s")) "$a0") in
      (func_call #replica.replica #"EncodeApplyReply"%go) "$a0") in
      do:  ((![#ptrT] "reply") <-[#sliceT] "$r0"))
      ) in
    do:  (map.insert (![type.mapT #uint64T #funcT] "handlers") RPC_ROPRIMARYAPPLY "$r0");;;
    let: "$r0" := (λ: "args" "reply",
      exception_do (let: "reply" := (mem.alloc "reply") in
      let: "args" := (mem.alloc "args") in
      do:  (let: "$a0" := (let: "$a0" := (![#sliceT] "args") in
      (func_call #replica.replica #"DecodeIncreaseCommitArgs"%go) "$a0") in
      (method_call #replica.replica #"Server'ptr" #"IncreaseCommitIndex" (![#ptrT] "s")) "$a0"))
      ) in
    do:  (map.insert (![type.mapT #uint64T #funcT] "handlers") RPC_INCREASECOMMIT "$r0");;;
    let: "rs" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := (![type.mapT #uint64T #funcT] "handlers") in
    (func_call #urpc.urpc #"MakeServer"%go) "$a0") in
    do:  ("rs" <-[#ptrT] "$r0");;;
    do:  (let: "$a0" := (![#uint64T] "me") in
    (method_call #urpc #"Server'ptr" #"Serve" (![#ptrT] "rs")) "$a0");;;
    let: "$go" := (λ: <>,
      exception_do (do:  ((method_call #replica.replica #"Server'ptr" #"leaseRenewalThread" (![#ptrT] "s")) #()))
      ) in
    do:  (Fork ("$go" #()));;;
    let: "$go" := (λ: <>,
      exception_do (do:  ((method_call #replica.replica #"Server'ptr" #"sendIncreaseCommitThread" (![#ptrT] "s")) #()))
      ) in
    do:  (Fork ("$go" #()))).

Definition vars' : list (go_string * go_type) := [].

Definition functions' : list (go_string * val) := [("EncodeApplyAsBackupArgs"%go, EncodeApplyAsBackupArgs); ("DecodeApplyAsBackupArgs"%go, DecodeApplyAsBackupArgs); ("EncodeSetStateArgs"%go, EncodeSetStateArgs); ("DecodeSetStateArgs"%go, DecodeSetStateArgs); ("EncodeGetStateArgs"%go, EncodeGetStateArgs); ("DecodeGetStateArgs"%go, DecodeGetStateArgs); ("EncodeGetStateReply"%go, EncodeGetStateReply); ("DecodeGetStateReply"%go, DecodeGetStateReply); ("EncodeBecomePrimaryArgs"%go, EncodeBecomePrimaryArgs); ("DecodeBecomePrimaryArgs"%go, DecodeBecomePrimaryArgs); ("EncodeApplyReply"%go, EncodeApplyReply); ("DecodeApplyReply"%go, DecodeApplyReply); ("EncodeIncreaseCommitArgs"%go, EncodeIncreaseCommitArgs); ("DecodeIncreaseCommitArgs"%go, DecodeIncreaseCommitArgs); ("MakeClerk"%go, MakeClerk); ("MakeServer"%go, MakeServer)].

Definition msets' : list (go_string * (list (go_string * val))) := [("ApplyAsBackupArgs"%go, []); ("ApplyAsBackupArgs'ptr"%go, []); ("SetStateArgs"%go, []); ("SetStateArgs'ptr"%go, []); ("GetStateArgs"%go, []); ("GetStateArgs'ptr"%go, []); ("GetStateReply"%go, []); ("GetStateReply'ptr"%go, []); ("BecomePrimaryArgs"%go, []); ("BecomePrimaryArgs'ptr"%go, []); ("ApplyReply"%go, []); ("ApplyReply'ptr"%go, []); ("StateMachine"%go, []); ("StateMachine'ptr"%go, []); ("SyncStateMachine"%go, []); ("SyncStateMachine'ptr"%go, []); ("Clerk"%go, []); ("Clerk'ptr"%go, [("Apply"%go, Clerk__Apply); ("ApplyAsBackup"%go, Clerk__ApplyAsBackup); ("ApplyRo"%go, Clerk__ApplyRo); ("BecomePrimary"%go, Clerk__BecomePrimary); ("GetState"%go, Clerk__GetState); ("IncreaseCommitIndex"%go, Clerk__IncreaseCommitIndex); ("SetState"%go, Clerk__SetState)]); ("Server"%go, []); ("Server'ptr"%go, [("Apply"%go, Server__Apply); ("ApplyAsBackup"%go, Server__ApplyAsBackup); ("ApplyRoWaitForCommit"%go, Server__ApplyRoWaitForCommit); ("BecomePrimary"%go, Server__BecomePrimary); ("GetState"%go, Server__GetState); ("IncreaseCommitIndex"%go, Server__IncreaseCommitIndex); ("Serve"%go, Server__Serve); ("SetState"%go, Server__SetState); ("isEpochStale"%go, Server__isEpochStale); ("leaseRenewalThread"%go, Server__leaseRenewalThread); ("sendIncreaseCommitThread"%go, Server__sendIncreaseCommitThread)])].

#[global] Instance info' : PkgInfo replica.replica :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [grove_ffi.grove_ffi; e.e; marshal.marshal; reconnectclient.reconnectclient; log.log; sync.sync; primitive.primitive; std.std; urpc.urpc; configservice.configservice];
  |}.

Definition initialize' : val :=
  rec: "initialize'" <> :=
    globals.package_init replica.replica (λ: <>,
      exception_do (do:  configservice.initialize';;;
      do:  urpc.initialize';;;
      do:  std.initialize';;;
      do:  primitive.initialize';;;
      do:  sync.initialize';;;
      do:  log.initialize';;;
      do:  reconnectclient.initialize';;;
      do:  marshal.initialize';;;
      do:  e.initialize';;;
      do:  grove_ffi.initialize')
      ).

End code.
End replica.
