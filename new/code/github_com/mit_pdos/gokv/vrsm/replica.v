(* autogenerated from github.com/mit-pdos/gokv/vrsm/replica *)
Require Export New.code.github_com.mit_pdos.gokv.grove_ffi.
Require Export New.code.github_com.mit_pdos.gokv.reconfig.replica.becomeprimaryargs_gk.
Require Export New.code.github_com.mit_pdos.gokv.reconnectclient.
Require Export New.code.github_com.mit_pdos.gokv.vrsm.replica.applyasbackupargs_gk.
Require Export New.code.github_com.mit_pdos.gokv.vrsm.replica.applyreply_gk.
Require Export New.code.github_com.mit_pdos.gokv.vrsm.replica.err_gk.
Require Export New.code.github_com.mit_pdos.gokv.vrsm.replica.getstateargs_gk.
Require Export New.code.github_com.mit_pdos.gokv.vrsm.replica.getstatereply_gk.
Require Export New.code.github_com.mit_pdos.gokv.vrsm.replica.increasecommitargs_gk.
Require Export New.code.github_com.mit_pdos.gokv.vrsm.replica.setstateargs_gk.
Require Export New.code.log.
Require Export New.code.sync.
Require Export New.code.github_com.goose_lang.primitive.
Require Export New.code.github_com.goose_lang.std.
Require Export New.code.github_com.mit_pdos.gokv.urpc.
Require Export New.code.github_com.mit_pdos.gokv.vrsm.configservice.
Require Export New.code.github_com.mit_pdos.gokv.vrsm.replica.becomeprimaryargs_gk.
From New.golang Require Import defn.
From New Require Import grove_prelude.
Module pkg_id.
Definition replica : go_string := "github.com/mit-pdos/gokv/vrsm/replica".

End pkg_id.
Export pkg_id.
Module replica.

Definition StateMachine {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/mit-pdos/gokv/vrsm/replica.StateMachine"%go [].

Definition SyncStateMachine {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/mit-pdos/gokv/vrsm/replica.SyncStateMachine"%go [].

Definition Clerk {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/mit-pdos/gokv/vrsm/replica.Clerk"%go [].

Definition Server {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/mit-pdos/gokv/vrsm/replica.Server"%go [].

Definition Op {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.SliceType go.byte.

Definition RPC_APPLYASBACKUP {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 0).

Definition RPC_SETSTATE {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 1).

Definition RPC_GETSTATE {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 2).

Definition RPC_BECOMEPRIMARY {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 3).

Definition RPC_PRIMARYAPPLY {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 4).

Definition RPC_ROPRIMARYAPPLY {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 6).

Definition RPC_INCREASECOMMIT {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 7).

Definition MakeClerk {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/gokv/vrsm/replica.MakeClerk"%go.

Definition MakeServer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/gokv/vrsm/replica.MakeServer"%go.

(* go: clerk.go:31:6 *)
Definition MakeClerkⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "host",
    exception_do (let: "host" := (GoAlloc grove_ffi.Address "host") in
    return: (GoAlloc Clerk (CompositeLiteral Clerk (LiteralValue [KeyedElement (Some (KeyField "cl"%go)) (ElementExpression (go.PointerType reconnectclient.ReconnectingClient) (let: "$a0" := (![grove_ffi.Address] "host") in
      (FuncResolve reconnectclient.MakeReconnectingClient [] #()) "$a0"))])))).

(* go: clerk.go:35:18 *)
Definition Clerk__ApplyAsBackupⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "ck" "args",
    exception_do (let: "ck" := (GoAlloc (go.PointerType Clerk) "ck") in
    let: "args" := (GoAlloc (go.PointerType applyasbackupargs_gk.S) "args") in
    let: "reply" := (GoAlloc (go.PointerType (go.SliceType go.byte)) (GoZeroVal (go.PointerType (go.SliceType go.byte)) #())) in
    let: "$r0" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    do:  ("reply" <-[go.PointerType (go.SliceType go.byte)] "$r0");;;
    let: "err" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (let: "$a0" := RPC_APPLYASBACKUP in
    let: "$a1" := (let: "$a0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 0)) in
    let: "$a1" := (![applyasbackupargs_gk.S] (![go.PointerType applyasbackupargs_gk.S] "args")) in
    (FuncResolve applyasbackupargs_gk.Marshal [] #()) "$a0" "$a1") in
    let: "$a2" := (![go.PointerType (go.SliceType go.byte)] "reply") in
    let: "$a3" := #(W64 1000) in
    (MethodResolve (go.PointerType reconnectclient.ReconnectingClient) "Call"%go (![go.PointerType reconnectclient.ReconnectingClient] (StructFieldRef Clerk "cl"%go (![go.PointerType Clerk] "ck")))) "$a0" "$a1" "$a2" "$a3") in
    do:  ("err" <-[go.uint64] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "err") ≠⟨go.uint64⟩ #(W64 0))
    then return: (err_gk.Timeout)
    else
      let: "e" := (GoAlloc err_gk.E (GoZeroVal err_gk.E #())) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] (![go.PointerType (go.SliceType go.byte)] "reply")) in
      (FuncResolve err_gk.Unmarshal [] #()) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("e" <-[err_gk.E] "$r0");;;
      do:  "$r1";;;
      return: (![err_gk.E] "e"))).

(* go: clerk.go:46:18 *)
Definition Clerk__SetStateⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "ck" "args",
    exception_do (let: "ck" := (GoAlloc (go.PointerType Clerk) "ck") in
    let: "args" := (GoAlloc (go.PointerType setstateargs_gk.S) "args") in
    let: "reply" := (GoAlloc (go.PointerType (go.SliceType go.byte)) (GoZeroVal (go.PointerType (go.SliceType go.byte)) #())) in
    let: "$r0" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    do:  ("reply" <-[go.PointerType (go.SliceType go.byte)] "$r0");;;
    let: "err" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (let: "$a0" := RPC_SETSTATE in
    let: "$a1" := (let: "$a0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 0)) in
    let: "$a1" := (![setstateargs_gk.S] (![go.PointerType setstateargs_gk.S] "args")) in
    (FuncResolve setstateargs_gk.Marshal [] #()) "$a0" "$a1") in
    let: "$a2" := (![go.PointerType (go.SliceType go.byte)] "reply") in
    let: "$a3" := #(W64 10000) in
    (MethodResolve (go.PointerType reconnectclient.ReconnectingClient) "Call"%go (![go.PointerType reconnectclient.ReconnectingClient] (StructFieldRef Clerk "cl"%go (![go.PointerType Clerk] "ck")))) "$a0" "$a1" "$a2" "$a3") in
    do:  ("err" <-[go.uint64] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "err") ≠⟨go.uint64⟩ #(W64 0))
    then return: (err_gk.Timeout)
    else
      let: "e" := (GoAlloc err_gk.E (GoZeroVal err_gk.E #())) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] (![go.PointerType (go.SliceType go.byte)] "reply")) in
      (FuncResolve err_gk.Unmarshal [] #()) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("e" <-[err_gk.E] "$r0");;;
      do:  "$r1";;;
      return: (![err_gk.E] "e"))).

(* go: clerk.go:57:18 *)
Definition Clerk__GetStateⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "ck" "args",
    exception_do (let: "ck" := (GoAlloc (go.PointerType Clerk) "ck") in
    let: "args" := (GoAlloc (go.PointerType getstateargs_gk.S) "args") in
    let: "reply" := (GoAlloc (go.PointerType (go.SliceType go.byte)) (GoZeroVal (go.PointerType (go.SliceType go.byte)) #())) in
    let: "$r0" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    do:  ("reply" <-[go.PointerType (go.SliceType go.byte)] "$r0");;;
    let: "err" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (let: "$a0" := RPC_GETSTATE in
    let: "$a1" := (let: "$a0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 0)) in
    let: "$a1" := (![getstateargs_gk.S] (![go.PointerType getstateargs_gk.S] "args")) in
    (FuncResolve getstateargs_gk.Marshal [] #()) "$a0" "$a1") in
    let: "$a2" := (![go.PointerType (go.SliceType go.byte)] "reply") in
    let: "$a3" := #(W64 10000) in
    (MethodResolve (go.PointerType reconnectclient.ReconnectingClient) "Call"%go (![go.PointerType reconnectclient.ReconnectingClient] (StructFieldRef Clerk "cl"%go (![go.PointerType Clerk] "ck")))) "$a0" "$a1" "$a2" "$a3") in
    do:  ("err" <-[go.uint64] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "err") ≠⟨go.uint64⟩ #(W64 0))
    then return: (GoAlloc getstatereply_gk.S (CompositeLiteral getstatereply_gk.S (LiteralValue [KeyedElement (Some (KeyField "Err"%go)) (ElementExpression err_gk.E err_gk.Timeout)])))
    else
      let: "rep" := (GoAlloc getstatereply_gk.S (GoZeroVal getstatereply_gk.S #())) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] (![go.PointerType (go.SliceType go.byte)] "reply")) in
      (FuncResolve getstatereply_gk.Unmarshal [] #()) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("rep" <-[getstatereply_gk.S] "$r0");;;
      do:  "$r1";;;
      return: ("rep"))).

(* go: clerk.go:70:18 *)
Definition Clerk__BecomePrimaryⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "ck" "args",
    exception_do (let: "ck" := (GoAlloc (go.PointerType Clerk) "ck") in
    let: "args" := (GoAlloc (go.PointerType becomeprimaryargs_gk.S) "args") in
    let: "reply" := (GoAlloc (go.PointerType (go.SliceType go.byte)) (GoZeroVal (go.PointerType (go.SliceType go.byte)) #())) in
    let: "$r0" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    do:  ("reply" <-[go.PointerType (go.SliceType go.byte)] "$r0");;;
    let: "err" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (let: "$a0" := RPC_BECOMEPRIMARY in
    let: "$a1" := (let: "$a0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 0)) in
    let: "$a1" := (![becomeprimaryargs_gk.S] (![go.PointerType becomeprimaryargs_gk.S] "args")) in
    (FuncResolve becomeprimaryargs_gk.Marshal [] #()) "$a0" "$a1") in
    let: "$a2" := (![go.PointerType (go.SliceType go.byte)] "reply") in
    let: "$a3" := #(W64 100) in
    (MethodResolve (go.PointerType reconnectclient.ReconnectingClient) "Call"%go (![go.PointerType reconnectclient.ReconnectingClient] (StructFieldRef Clerk "cl"%go (![go.PointerType Clerk] "ck")))) "$a0" "$a1" "$a2" "$a3") in
    do:  ("err" <-[go.uint64] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "err") ≠⟨go.uint64⟩ #(W64 0))
    then return: (err_gk.Timeout)
    else
      let: "e" := (GoAlloc err_gk.E (GoZeroVal err_gk.E #())) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] (![go.PointerType (go.SliceType go.byte)] "reply")) in
      (FuncResolve err_gk.Unmarshal [] #()) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("e" <-[err_gk.E] "$r0");;;
      do:  "$r1";;;
      return: (![err_gk.E] "e"))).

(* go: clerk.go:81:18 *)
Definition Clerk__Applyⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "ck" "op",
    exception_do (let: "ck" := (GoAlloc (go.PointerType Clerk) "ck") in
    let: "op" := (GoAlloc (go.SliceType go.byte) "op") in
    let: "reply" := (GoAlloc (go.PointerType (go.SliceType go.byte)) (GoZeroVal (go.PointerType (go.SliceType go.byte)) #())) in
    let: "$r0" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    do:  ("reply" <-[go.PointerType (go.SliceType go.byte)] "$r0");;;
    let: "err" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (let: "$a0" := RPC_PRIMARYAPPLY in
    let: "$a1" := (![go.SliceType go.byte] "op") in
    let: "$a2" := (![go.PointerType (go.SliceType go.byte)] "reply") in
    let: "$a3" := #(W64 5000) in
    (MethodResolve (go.PointerType reconnectclient.ReconnectingClient) "Call"%go (![go.PointerType reconnectclient.ReconnectingClient] (StructFieldRef Clerk "cl"%go (![go.PointerType Clerk] "ck")))) "$a0" "$a1" "$a2" "$a3") in
    do:  ("err" <-[go.uint64] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "err") =⟨go.uint64⟩ #(W64 0))
    then
      let: "r" := (GoAlloc applyreply_gk.S (GoZeroVal applyreply_gk.S #())) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] (![go.PointerType (go.SliceType go.byte)] "reply")) in
      (FuncResolve applyreply_gk.Unmarshal [] #()) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("r" <-[applyreply_gk.S] "$r0");;;
      do:  "$r1";;;
      return: (![err_gk.E] (StructFieldRef applyreply_gk.S "Err"%go "r"), ![go.SliceType go.byte] (StructFieldRef applyreply_gk.S "Reply"%go "r"))
    else return: (err_gk.Timeout, Convert go.untyped_nil (go.SliceType go.byte) UntypedNil))).

(* go: clerk.go:92:18 *)
Definition Clerk__ApplyRoⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "ck" "op",
    exception_do (let: "ck" := (GoAlloc (go.PointerType Clerk) "ck") in
    let: "op" := (GoAlloc (go.SliceType go.byte) "op") in
    let: "reply" := (GoAlloc (go.PointerType (go.SliceType go.byte)) (GoZeroVal (go.PointerType (go.SliceType go.byte)) #())) in
    let: "$r0" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    do:  ("reply" <-[go.PointerType (go.SliceType go.byte)] "$r0");;;
    let: "err" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (let: "$a0" := RPC_ROPRIMARYAPPLY in
    let: "$a1" := (![go.SliceType go.byte] "op") in
    let: "$a2" := (![go.PointerType (go.SliceType go.byte)] "reply") in
    let: "$a3" := #(W64 1000) in
    (MethodResolve (go.PointerType reconnectclient.ReconnectingClient) "Call"%go (![go.PointerType reconnectclient.ReconnectingClient] (StructFieldRef Clerk "cl"%go (![go.PointerType Clerk] "ck")))) "$a0" "$a1" "$a2" "$a3") in
    do:  ("err" <-[go.uint64] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "err") =⟨go.uint64⟩ #(W64 0))
    then
      let: "r" := (GoAlloc applyreply_gk.S (GoZeroVal applyreply_gk.S #())) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] (![go.PointerType (go.SliceType go.byte)] "reply")) in
      (FuncResolve applyreply_gk.Unmarshal [] #()) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("r" <-[applyreply_gk.S] "$r0");;;
      do:  "$r1";;;
      return: (![err_gk.E] (StructFieldRef applyreply_gk.S "Err"%go "r"), ![go.SliceType go.byte] (StructFieldRef applyreply_gk.S "Reply"%go "r"))
    else return: (err_gk.Timeout, Convert go.untyped_nil (go.SliceType go.byte) UntypedNil))).

(* go: clerk.go:103:18 *)
Definition Clerk__IncreaseCommitIndexⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "ck" "n",
    exception_do (let: "ck" := (GoAlloc (go.PointerType Clerk) "ck") in
    let: "n" := (GoAlloc go.uint64 "n") in
    return: (Convert go.uint64 err_gk.E (let: "$a0" := RPC_INCREASECOMMIT in
     let: "$a1" := (let: "$a0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 0)) in
     let: "$a1" := (CompositeLiteral increasecommitargs_gk.S (LiteralValue [KeyedElement (Some (KeyField "V"%go)) (ElementExpression go.uint64 (![go.uint64] "n"))])) in
     (FuncResolve increasecommitargs_gk.Marshal [] #()) "$a0" "$a1") in
     let: "$a2" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
     let: "$a3" := #(W64 100) in
     (MethodResolve (go.PointerType reconnectclient.ReconnectingClient) "Call"%go (![go.PointerType reconnectclient.ReconnectingClient] (StructFieldRef Clerk "cl"%go (![go.PointerType Clerk] "ck")))) "$a0" "$a1" "$a2" "$a3"))).

(* Applies the RO op immediately, but then waits for it to be committed before
   replying to client.

   go: server.go:52:18 *)
Definition Server__ApplyRoWaitForCommitⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" "op",
    exception_do (let: "s" := (GoAlloc (go.PointerType Server) "s") in
    let: "op" := (GoAlloc Op "op") in
    let: "reply" := (GoAlloc (go.PointerType applyreply_gk.S) (GoZeroVal (go.PointerType applyreply_gk.S) #())) in
    let: "$r0" := (GoAlloc applyreply_gk.S (GoZeroVal applyreply_gk.S #())) in
    do:  ("reply" <-[go.PointerType applyreply_gk.S] "$r0");;;
    let: "$r0" := (Convert go.untyped_nil (go.SliceType go.byte) UntypedNil) in
    do:  ((StructFieldRef applyreply_gk.S "Reply"%go (![go.PointerType applyreply_gk.S] "reply")) <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := err_gk.None in
    do:  ((StructFieldRef applyreply_gk.S "Err"%go (![go.PointerType applyreply_gk.S] "reply")) <-[err_gk.E] "$r0");;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] (StructFieldRef Server "mu"%go (![go.PointerType Server] "s")))) #());;;
    (if: (~ (![go.bool] (StructFieldRef Server "leaseValid"%go (![go.PointerType Server] "s"))))
    then
      do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef Server "mu"%go (![go.PointerType Server] "s")))) #());;;
      do:  (let: "$a0" := #"Lease invalid"%go in
      let: "$a1" := #slice.nil in
      (FuncResolve log.Printf [] #()) "$a0" "$a1");;;
      let: "$r0" := err_gk.LeaseExpired in
      do:  ((StructFieldRef applyreply_gk.S "Err"%go (![go.PointerType applyreply_gk.S] "reply")) <-[err_gk.E] "$r0");;;
      return: (![go.PointerType applyreply_gk.S] "reply")
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool ((((FuncResolve primitive.RandomUint64 [] #()) #()) %⟨go.uint64⟩ #(W64 10000)) =⟨go.uint64⟩ #(W64 0))
    then
      do:  (let: "$a0" := #"Server nextIndex=%d commitIndex=%d"%go in
      let: "$a1" := ((let: "$sl0" := (Convert go.uint64 go.any (![go.uint64] (StructFieldRef Server "nextIndex"%go (![go.PointerType Server] "s")))) in
      let: "$sl1" := (Convert go.uint64 go.any (![go.uint64] (StructFieldRef Server "committedNextIndex"%go (![go.PointerType Server] "s")))) in
      CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0"); KeyedElement None (ElementExpression go.any "$sl1")]))) in
      (FuncResolve log.Printf [] #()) "$a0" "$a1")
    else do:  #());;;
    let: "lastModifiedIndex" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![Op] "op") in
    (![go.FunctionType (go.Signature [Op] false [go.uint64; go.SliceType go.byte])] (StructFieldRef StateMachine "ApplyReadonly"%go (![go.PointerType StateMachine] (StructFieldRef Server "sm"%go (![go.PointerType Server] "s"))))) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("lastModifiedIndex" <-[go.uint64] "$r0");;;
    do:  ((StructFieldRef applyreply_gk.S "Reply"%go (![go.PointerType applyreply_gk.S] "reply")) <-[go.SliceType go.byte] "$r1");;;
    let: "epoch" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (![go.uint64] (StructFieldRef Server "epoch"%go (![go.PointerType Server] "s"))) in
    do:  ("epoch" <-[go.uint64] "$r0");;;
    let: "h" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: ("$ret0", "$ret1") := ((FuncResolve grove_ffi.GetTimeRange [] #()) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  "$r0";;;
    do:  ("h" <-[go.uint64] "$r1");;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] (StructFieldRef Server "leaseExpiration"%go (![go.PointerType Server] "s"))) ≤⟨go.uint64⟩ (![go.uint64] "h"))
    then
      do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef Server "mu"%go (![go.PointerType Server] "s")))) #());;;
      do:  (let: "$a0" := #"Lease expired because %d < %d"%go in
      let: "$a1" := ((let: "$sl0" := (Convert go.uint64 go.any (![go.uint64] (StructFieldRef Server "leaseExpiration"%go (![go.PointerType Server] "s")))) in
      let: "$sl1" := (Convert go.uint64 go.any (![go.uint64] "h")) in
      CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0"); KeyedElement None (ElementExpression go.any "$sl1")]))) in
      (FuncResolve log.Printf [] #()) "$a0" "$a1");;;
      let: "$r0" := err_gk.LeaseExpired in
      do:  ((StructFieldRef applyreply_gk.S "Err"%go (![go.PointerType applyreply_gk.S] "reply")) <-[err_gk.E] "$r0");;;
      return: (![go.PointerType applyreply_gk.S] "reply")
    else do:  #());;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (if: Convert go.untyped_bool go.bool ((![go.uint64] (StructFieldRef Server "epoch"%go (![go.PointerType Server] "s"))) ≠⟨go.uint64⟩ (![go.uint64] "epoch"))
      then
        let: "$r0" := err_gk.Stale in
        do:  ((StructFieldRef applyreply_gk.S "Err"%go (![go.PointerType applyreply_gk.S] "reply")) <-[err_gk.E] "$r0");;;
        break: #()
      else
        (if: Convert go.untyped_bool go.bool ((![go.uint64] "lastModifiedIndex") ≤⟨go.uint64⟩ (![go.uint64] (StructFieldRef Server "committedNextIndex"%go (![go.PointerType Server] "s"))))
        then
          let: "$r0" := err_gk.None in
          do:  ((StructFieldRef applyreply_gk.S "Err"%go (![go.PointerType applyreply_gk.S] "reply")) <-[err_gk.E] "$r0");;;
          break: #()
        else
          do:  ((MethodResolve (go.PointerType sync.Cond) "Wait"%go (![go.PointerType sync.Cond] (StructFieldRef Server "committedNextIndex_cond"%go (![go.PointerType Server] "s")))) #());;;
          continue: #())));;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef Server "mu"%go (![go.PointerType Server] "s")))) #());;;
    return: (![go.PointerType applyreply_gk.S] "reply")).

(* precondition:
   is_epoch_lb epoch ∗ committed_by epoch log ∗ is_pb_log_lb log

   go: server.go:102:18 *)
Definition Server__IncreaseCommitIndexⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" "newCommittedNextIndex",
    exception_do (let: "s" := (GoAlloc (go.PointerType Server) "s") in
    let: "newCommittedNextIndex" := (GoAlloc go.uint64 "newCommittedNextIndex") in
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] (StructFieldRef Server "mu"%go (![go.PointerType Server] "s")))) #());;;
    (if: Convert go.untyped_bool go.bool (((![go.uint64] "newCommittedNextIndex") >⟨go.uint64⟩ (![go.uint64] (StructFieldRef Server "committedNextIndex"%go (![go.PointerType Server] "s")))) && ((![go.uint64] "newCommittedNextIndex") ≤⟨go.uint64⟩ (![go.uint64] (StructFieldRef Server "nextIndex"%go (![go.PointerType Server] "s")))))
    then
      let: "$r0" := (![go.uint64] "newCommittedNextIndex") in
      do:  ((StructFieldRef Server "committedNextIndex"%go (![go.PointerType Server] "s")) <-[go.uint64] "$r0");;;
      do:  ((MethodResolve (go.PointerType sync.Cond) "Broadcast"%go (![go.PointerType sync.Cond] (StructFieldRef Server "committedNextIndex_cond"%go (![go.PointerType Server] "s")))) #())
    else do:  #());;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef Server "mu"%go (![go.PointerType Server] "s")))) #());;;
    return: #()).

(* called on the primary server to apply a new operation.

   go: server.go:113:18 *)
Definition Server__Applyⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" "op",
    exception_do (let: "s" := (GoAlloc (go.PointerType Server) "s") in
    let: "op" := (GoAlloc Op "op") in
    let: "reply" := (GoAlloc (go.PointerType applyreply_gk.S) (GoZeroVal (go.PointerType applyreply_gk.S) #())) in
    let: "$r0" := (GoAlloc applyreply_gk.S (GoZeroVal applyreply_gk.S #())) in
    do:  ("reply" <-[go.PointerType applyreply_gk.S] "$r0");;;
    let: "$r0" := (Convert go.untyped_nil (go.SliceType go.byte) UntypedNil) in
    do:  ((StructFieldRef applyreply_gk.S "Reply"%go (![go.PointerType applyreply_gk.S] "reply")) <-[go.SliceType go.byte] "$r0");;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] (StructFieldRef Server "mu"%go (![go.PointerType Server] "s")))) #());;;
    (if: (~ (![go.bool] (StructFieldRef Server "isPrimary"%go (![go.PointerType Server] "s"))))
    then
      do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef Server "mu"%go (![go.PointerType Server] "s")))) #());;;
      let: "$r0" := err_gk.Stale in
      do:  ((StructFieldRef applyreply_gk.S "Err"%go (![go.PointerType applyreply_gk.S] "reply")) <-[err_gk.E] "$r0");;;
      return: (![go.PointerType applyreply_gk.S] "reply")
    else do:  #());;;
    (if: ![go.bool] (StructFieldRef Server "sealed"%go (![go.PointerType Server] "s"))
    then
      do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef Server "mu"%go (![go.PointerType Server] "s")))) #());;;
      let: "$r0" := err_gk.Stale in
      do:  ((StructFieldRef applyreply_gk.S "Err"%go (![go.PointerType applyreply_gk.S] "reply")) <-[err_gk.E] "$r0");;;
      return: (![go.PointerType applyreply_gk.S] "reply")
    else do:  #());;;
    let: "waitForDurable" := (GoAlloc (go.FunctionType (go.Signature [] false [])) (GoZeroVal (go.FunctionType (go.Signature [] false [])) #())) in
    let: "ret" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![Op] "op") in
    (![go.FunctionType (go.Signature [Op] false [go.SliceType go.byte; go.FunctionType (go.Signature [] false [])])] (StructFieldRef StateMachine "StartApply"%go (![go.PointerType StateMachine] (StructFieldRef Server "sm"%go (![go.PointerType Server] "s"))))) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("ret" <-[go.SliceType go.byte] "$r0");;;
    do:  ("waitForDurable" <-[go.FunctionType (go.Signature [] false [])] "$r1");;;
    let: "$r0" := (![go.SliceType go.byte] "ret") in
    do:  ((StructFieldRef applyreply_gk.S "Reply"%go (![go.PointerType applyreply_gk.S] "reply")) <-[go.SliceType go.byte] "$r0");;;
    let: "opIndex" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (![go.uint64] (StructFieldRef Server "nextIndex"%go (![go.PointerType Server] "s"))) in
    do:  ("opIndex" <-[go.uint64] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.uint64] (StructFieldRef Server "nextIndex"%go (![go.PointerType Server] "s"))) in
    let: "$a1" := #(W64 1) in
    (FuncResolve std.SumAssumeNoOverflow [] #()) "$a0" "$a1") in
    do:  ((StructFieldRef Server "nextIndex"%go (![go.PointerType Server] "s")) <-[go.uint64] "$r0");;;
    let: "nextIndex" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (![go.uint64] (StructFieldRef Server "nextIndex"%go (![go.PointerType Server] "s"))) in
    do:  ("nextIndex" <-[go.uint64] "$r0");;;
    let: "epoch" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (![go.uint64] (StructFieldRef Server "epoch"%go (![go.PointerType Server] "s"))) in
    do:  ("epoch" <-[go.uint64] "$r0");;;
    let: "clerks" := (GoAlloc (go.SliceType (go.SliceType (go.PointerType Clerk))) (GoZeroVal (go.SliceType (go.SliceType (go.PointerType Clerk))) #())) in
    let: "$r0" := (![go.SliceType (go.SliceType (go.PointerType Clerk))] (StructFieldRef Server "clerks"%go (![go.PointerType Server] "s"))) in
    do:  ("clerks" <-[go.SliceType (go.SliceType (go.PointerType Clerk))] "$r0");;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef Server "mu"%go (![go.PointerType Server] "s")))) #());;;
    let: "wg" := (GoAlloc (go.PointerType sync.WaitGroup) (GoZeroVal (go.PointerType sync.WaitGroup) #())) in
    let: "$r0" := (GoAlloc sync.WaitGroup (GoZeroVal sync.WaitGroup #())) in
    do:  ("wg" <-[go.PointerType sync.WaitGroup] "$r0");;;
    let: "args" := (GoAlloc (go.PointerType applyasbackupargs_gk.S) (GoZeroVal (go.PointerType applyasbackupargs_gk.S) #())) in
    let: "$r0" := (GoAlloc applyasbackupargs_gk.S (CompositeLiteral applyasbackupargs_gk.S (LiteralValue [KeyedElement (Some (KeyField "Epoch"%go)) (ElementExpression go.uint64 (![go.uint64] "epoch")); KeyedElement (Some (KeyField "Index"%go)) (ElementExpression go.uint64 (![go.uint64] "opIndex")); KeyedElement (Some (KeyField "Op"%go)) (ElementExpression Op (![Op] "op"))]))) in
    do:  ("args" <-[go.PointerType applyasbackupargs_gk.S] "$r0");;;
    let: "clerks_inner" := (GoAlloc (go.SliceType (go.PointerType Clerk)) (GoZeroVal (go.SliceType (go.PointerType Clerk)) #())) in
    let: "$r0" := (![go.SliceType (go.PointerType Clerk)] (IndexRef (go.SliceType (go.SliceType (go.PointerType Clerk))) (![go.SliceType (go.SliceType (go.PointerType Clerk))] "clerks", Convert go.uint64 go.int (((FuncResolve primitive.RandomUint64 [] #()) #()) %⟨go.uint64⟩ (Convert go.int go.uint64 (let: "$a0" := (![go.SliceType (go.SliceType (go.PointerType Clerk))] "clerks") in
     (FuncResolve go.len [go.SliceType (go.SliceType (go.PointerType Clerk))] #()) "$a0")))))) in
    do:  ("clerks_inner" <-[go.SliceType (go.PointerType Clerk)] "$r0");;;
    let: "errs" := (GoAlloc (go.SliceType err_gk.E) (GoZeroVal (go.SliceType err_gk.E) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType err_gk.E] #()) (let: "$a0" := (![go.SliceType (go.PointerType Clerk)] "clerks_inner") in
    (FuncResolve go.len [go.SliceType (go.PointerType Clerk)] #()) "$a0")) in
    do:  ("errs" <-[go.SliceType err_gk.E] "$r0");;;
    let: "$range" := (![go.SliceType (go.PointerType Clerk)] "clerks_inner") in
    (let: "clerk" := (GoAlloc (go.PointerType Clerk) (GoZeroVal (go.PointerType Clerk) #())) in
    let: "i" := (GoAlloc go.int (GoZeroVal go.int #())) in
    slice.for_range (go.PointerType Clerk) "$range" (λ: "$key" "$value",
      do:  ("clerk" <-[go.PointerType Clerk] "$value");;;
      do:  ("i" <-[go.int] "$key");;;
      let: "clerk" := (GoAlloc (go.PointerType Clerk) (GoZeroVal (go.PointerType Clerk) #())) in
      let: "$r0" := (![go.PointerType Clerk] "clerk") in
      do:  ("clerk" <-[go.PointerType Clerk] "$r0");;;
      let: "i" := (GoAlloc go.int (GoZeroVal go.int #())) in
      let: "$r0" := (![go.int] "i") in
      do:  ("i" <-[go.int] "$r0");;;
      do:  (let: "$a0" := #(W64 1) in
      (MethodResolve (go.PointerType sync.WaitGroup) "Add"%go (![go.PointerType sync.WaitGroup] "wg")) "$a0");;;
      let: "$go" := (λ: <>,
        exception_do ((for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
          let: "err" := (GoAlloc err_gk.E (GoZeroVal err_gk.E #())) in
          let: "$r0" := (let: "$a0" := (![go.PointerType applyasbackupargs_gk.S] "args") in
          (MethodResolve (go.PointerType Clerk) "ApplyAsBackup"%go (![go.PointerType Clerk] "clerk")) "$a0") in
          do:  ("err" <-[err_gk.E] "$r0");;;
          (if: Convert go.untyped_bool go.bool (((![err_gk.E] "err") =⟨go.uint32⟩ err_gk.OutOfOrder) || ((![err_gk.E] "err") =⟨go.uint32⟩ err_gk.Timeout))
          then continue: #()
          else
            let: "$r0" := (![err_gk.E] "err") in
            do:  ((IndexRef (go.SliceType err_gk.E) (![go.SliceType err_gk.E] "errs", ![go.int] "i")) <-[err_gk.E] "$r0");;;
            break: #()));;;
        do:  ((MethodResolve (go.PointerType sync.WaitGroup) "Done"%go (![go.PointerType sync.WaitGroup] "wg")) #());;;
        return: #())
        ) in
      do:  (Fork ("$go" #()))));;;
    do:  ((MethodResolve (go.PointerType sync.WaitGroup) "Wait"%go (![go.PointerType sync.WaitGroup] "wg")) #());;;
    do:  ((![go.FunctionType (go.Signature [] false [])] "waitForDurable") #());;;
    let: "err" := (GoAlloc err_gk.E (GoZeroVal err_gk.E #())) in
    let: "$r0" := err_gk.None in
    do:  ("err" <-[err_gk.E] "$r0");;;
    let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, (![go.uint64] "i") <⟨go.uint64⟩ (Convert go.int go.uint64 (let: "$a0" := (![go.SliceType (go.PointerType Clerk)] "clerks_inner") in
    (FuncResolve go.len [go.SliceType (go.PointerType Clerk)] #()) "$a0"))); (λ: <>, #()) := λ: <>,
      let: "err2" := (GoAlloc err_gk.E (GoZeroVal err_gk.E #())) in
      let: "$r0" := (![err_gk.E] (IndexRef (go.SliceType err_gk.E) (![go.SliceType err_gk.E] "errs", Convert go.uint64 go.int (![go.uint64] "i")))) in
      do:  ("err2" <-[err_gk.E] "$r0");;;
      (if: Convert go.untyped_bool go.bool ((![err_gk.E] "err2") ≠⟨go.uint32⟩ err_gk.None)
      then
        let: "$r0" := (![err_gk.E] "err2") in
        do:  ("err" <-[err_gk.E] "$r0")
      else do:  #());;;
      do:  ("i" <-[go.uint64] ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 1))));;;
    let: "$r0" := (![err_gk.E] "err") in
    do:  ((StructFieldRef applyreply_gk.S "Err"%go (![go.PointerType applyreply_gk.S] "reply")) <-[err_gk.E] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![err_gk.E] "err") =⟨go.uint32⟩ err_gk.None)
    then
      do:  (let: "$a0" := (![go.uint64] "nextIndex") in
      (MethodResolve (go.PointerType Server) "IncreaseCommitIndex"%go (![go.PointerType Server] "s")) "$a0")
    else
      do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] (StructFieldRef Server "mu"%go (![go.PointerType Server] "s")))) #());;;
      (if: Convert go.untyped_bool go.bool ((![go.uint64] (StructFieldRef Server "epoch"%go (![go.PointerType Server] "s"))) =⟨go.uint64⟩ (![go.uint64] "epoch"))
      then
        let: "$r0" := #false in
        do:  ((StructFieldRef Server "isPrimary"%go (![go.PointerType Server] "s")) <-[go.bool] "$r0")
      else do:  #());;;
      do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef Server "mu"%go (![go.PointerType Server] "s")))) #()));;;
    return: (![go.PointerType applyreply_gk.S] "reply")).

(* go: server.go:210:18 *)
Definition Server__leaseRenewalThreadⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" <>,
    exception_do (let: "s" := (GoAlloc (go.PointerType Server) "s") in
    let: "latestEpoch" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "leaseExpiration" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: "leaseErr" := (GoAlloc err_gk.E (GoZeroVal err_gk.E #())) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![go.uint64] "latestEpoch") in
      (MethodResolve (go.PointerType configservice.Clerk) "GetLease"%go (![go.PointerType configservice.Clerk] (StructFieldRef Server "confCk"%go (![go.PointerType Server] "s")))) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("leaseErr" <-[err_gk.E] "$r0");;;
      do:  ("leaseExpiration" <-[go.uint64] "$r1");;;
      do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] (StructFieldRef Server "mu"%go (![go.PointerType Server] "s")))) #());;;
      (if: Convert go.untyped_bool go.bool (((![go.uint64] (StructFieldRef Server "epoch"%go (![go.PointerType Server] "s"))) =⟨go.uint64⟩ (![go.uint64] "latestEpoch")) && ((![err_gk.E] "leaseErr") =⟨go.uint32⟩ err_gk.None))
      then
        let: "$r0" := (![go.uint64] "leaseExpiration") in
        do:  ((StructFieldRef Server "leaseExpiration"%go (![go.PointerType Server] "s")) <-[go.uint64] "$r0");;;
        let: "$r0" := #true in
        do:  ((StructFieldRef Server "leaseValid"%go (![go.PointerType Server] "s")) <-[go.bool] "$r0");;;
        do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef Server "mu"%go (![go.PointerType Server] "s")))) #());;;
        do:  (let: "$a0" := (#(W64 250) *⟨go.uint64⟩ #(W64 1000000)) in
        (FuncResolve primitive.Sleep [] #()) "$a0")
      else
        (if: Convert go.untyped_bool go.bool ((![go.uint64] "latestEpoch") ≠⟨go.uint64⟩ (![go.uint64] (StructFieldRef Server "epoch"%go (![go.PointerType Server] "s"))))
        then
          let: "$r0" := (![go.uint64] (StructFieldRef Server "epoch"%go (![go.PointerType Server] "s"))) in
          do:  ("latestEpoch" <-[go.uint64] "$r0");;;
          do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef Server "mu"%go (![go.PointerType Server] "s")))) #())
        else
          do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef Server "mu"%go (![go.PointerType Server] "s")))) #());;;
          do:  (let: "$a0" := (#(W64 50) *⟨go.uint64⟩ #(W64 1000000)) in
          (FuncResolve primitive.Sleep [] #()) "$a0"))));;;
    return: #()).

(* go: server.go:235:18 *)
Definition Server__sendIncreaseCommitThreadⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" <>,
    exception_do (let: "s" := (GoAlloc (go.PointerType Server) "s") in
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] (StructFieldRef Server "mu"%go (![go.PointerType Server] "s")))) #());;;
      (for: (λ: <>, (~ (![go.bool] (StructFieldRef Server "isPrimary"%go (![go.PointerType Server] "s")))) || ((let: "$a0" := (![go.SliceType (go.PointerType Clerk)] (IndexRef (go.SliceType (go.SliceType (go.PointerType Clerk))) (![go.SliceType (go.SliceType (go.PointerType Clerk))] (StructFieldRef Server "clerks"%go (![go.PointerType Server] "s")), #(W64 0)))) in
      (FuncResolve go.len [go.SliceType (go.PointerType Clerk)] #()) "$a0") =⟨go.int⟩ #(W64 0))); (λ: <>, #()) := λ: <>,
        do:  ((MethodResolve (go.PointerType sync.Cond) "Wait"%go (![go.PointerType sync.Cond] (StructFieldRef Server "isPrimary_cond"%go (![go.PointerType Server] "s")))) #()));;;
      let: "newCommittedNextIndex" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: "$r0" := (![go.uint64] (StructFieldRef Server "committedNextIndex"%go (![go.PointerType Server] "s"))) in
      do:  ("newCommittedNextIndex" <-[go.uint64] "$r0");;;
      let: "clerks" := (GoAlloc (go.SliceType (go.SliceType (go.PointerType Clerk))) (GoZeroVal (go.SliceType (go.SliceType (go.PointerType Clerk))) #())) in
      let: "$r0" := (![go.SliceType (go.SliceType (go.PointerType Clerk))] (StructFieldRef Server "clerks"%go (![go.PointerType Server] "s"))) in
      do:  ("clerks" <-[go.SliceType (go.SliceType (go.PointerType Clerk))] "$r0");;;
      do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef Server "mu"%go (![go.PointerType Server] "s")))) #());;;
      let: "clerks_inner" := (GoAlloc (go.SliceType (go.PointerType Clerk)) (GoZeroVal (go.SliceType (go.PointerType Clerk)) #())) in
      let: "$r0" := (![go.SliceType (go.PointerType Clerk)] (IndexRef (go.SliceType (go.SliceType (go.PointerType Clerk))) (![go.SliceType (go.SliceType (go.PointerType Clerk))] "clerks", Convert go.uint64 go.int (((FuncResolve primitive.RandomUint64 [] #()) #()) %⟨go.uint64⟩ (Convert go.int go.uint64 (let: "$a0" := (![go.SliceType (go.SliceType (go.PointerType Clerk))] "clerks") in
       (FuncResolve go.len [go.SliceType (go.SliceType (go.PointerType Clerk))] #()) "$a0")))))) in
      do:  ("clerks_inner" <-[go.SliceType (go.PointerType Clerk)] "$r0");;;
      let: "wg" := (GoAlloc (go.PointerType sync.WaitGroup) (GoZeroVal (go.PointerType sync.WaitGroup) #())) in
      let: "$r0" := (GoAlloc sync.WaitGroup (GoZeroVal sync.WaitGroup #())) in
      do:  ("wg" <-[go.PointerType sync.WaitGroup] "$r0");;;
      let: "$range" := (![go.SliceType (go.PointerType Clerk)] "clerks_inner") in
      (let: "clerk" := (GoAlloc (go.PointerType Clerk) (GoZeroVal (go.PointerType Clerk) #())) in
      slice.for_range (go.PointerType Clerk) "$range" (λ: "$key" "$value",
        do:  ("clerk" <-[go.PointerType Clerk] "$value");;;
        do:  "$key";;;
        let: "clerk" := (GoAlloc (go.PointerType Clerk) (GoZeroVal (go.PointerType Clerk) #())) in
        let: "$r0" := (![go.PointerType Clerk] "clerk") in
        do:  ("clerk" <-[go.PointerType Clerk] "$r0");;;
        do:  (let: "$a0" := #(W64 1) in
        (MethodResolve (go.PointerType sync.WaitGroup) "Add"%go (![go.PointerType sync.WaitGroup] "wg")) "$a0");;;
        let: "$go" := (λ: <>,
          exception_do ((for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
            let: "err" := (GoAlloc err_gk.E (GoZeroVal err_gk.E #())) in
            let: "$r0" := (let: "$a0" := (![go.uint64] "newCommittedNextIndex") in
            (MethodResolve (go.PointerType Clerk) "IncreaseCommitIndex"%go (![go.PointerType Clerk] "clerk")) "$a0") in
            do:  ("err" <-[err_gk.E] "$r0");;;
            (if: Convert go.untyped_bool go.bool ((![err_gk.E] "err") =⟨go.uint32⟩ err_gk.None)
            then break: #()
            else continue: #()));;;
          do:  ((MethodResolve (go.PointerType sync.WaitGroup) "Done"%go (![go.PointerType sync.WaitGroup] "wg")) #());;;
          return: #())
          ) in
        do:  (Fork ("$go" #()))));;;
      do:  ((MethodResolve (go.PointerType sync.WaitGroup) "Wait"%go (![go.PointerType sync.WaitGroup] "wg")) #());;;
      do:  (let: "$a0" := #(W64 5000000) in
      (FuncResolve primitive.Sleep [] #()) "$a0"));;;
    return: #()).

(* requires that we've already at least entered this epoch
   returns true iff stale

   go: server.go:279:18 *)
Definition Server__isEpochStaleⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" "epoch",
    exception_do (let: "s" := (GoAlloc (go.PointerType Server) "s") in
    let: "epoch" := (GoAlloc go.uint64 "epoch") in
    return: ((![go.uint64] (StructFieldRef Server "epoch"%go (![go.PointerType Server] "s"))) ≠⟨go.uint64⟩ (![go.uint64] "epoch"))).

(* called on backup servers to apply an operation so it is replicated and
   can be considered committed by primary.

   go: server.go:285:18 *)
Definition Server__ApplyAsBackupⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" "args",
    exception_do (let: "s" := (GoAlloc (go.PointerType Server) "s") in
    let: "args" := (GoAlloc (go.PointerType applyasbackupargs_gk.S) "args") in
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] (StructFieldRef Server "mu"%go (![go.PointerType Server] "s")))) #());;;
    (for: (λ: <>, (((![go.uint64] (StructFieldRef applyasbackupargs_gk.S "Index"%go (![go.PointerType applyasbackupargs_gk.S] "args"))) >⟨go.uint64⟩ (![go.uint64] (StructFieldRef Server "nextIndex"%go (![go.PointerType Server] "s")))) && ((![go.uint64] (StructFieldRef Server "epoch"%go (![go.PointerType Server] "s"))) =⟨go.uint64⟩ (![go.uint64] (StructFieldRef applyasbackupargs_gk.S "Epoch"%go (![go.PointerType applyasbackupargs_gk.S] "args"))))) && (~ (![go.bool] (StructFieldRef Server "sealed"%go (![go.PointerType Server] "s"))))); (λ: <>, #()) := λ: <>,
      let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
      let: "cond" := (GoAlloc (go.PointerType sync.Cond) (GoZeroVal (go.PointerType sync.Cond) #())) in
      let: ("$ret0", "$ret1") := (map.lookup2 go.uint64 (go.PointerType sync.Cond) (![go.MapType go.uint64 (go.PointerType sync.Cond)] (StructFieldRef Server "opAppliedConds"%go (![go.PointerType Server] "s"))) (![go.uint64] (StructFieldRef applyasbackupargs_gk.S "Index"%go (![go.PointerType applyasbackupargs_gk.S] "args")))) in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("cond" <-[go.PointerType sync.Cond] "$r0");;;
      do:  ("ok" <-[go.bool] "$r1");;;
      (if: (~ (![go.bool] "ok"))
      then
        let: "cond" := (GoAlloc (go.PointerType sync.Cond) (GoZeroVal (go.PointerType sync.Cond) #())) in
        let: "$r0" := (let: "$a0" := (Convert (go.PointerType sync.Mutex) sync.Locker (![go.PointerType sync.Mutex] (StructFieldRef Server "mu"%go (![go.PointerType Server] "s")))) in
        (FuncResolve sync.NewCond [] #()) "$a0") in
        do:  ("cond" <-[go.PointerType sync.Cond] "$r0");;;
        let: "$r0" := (![go.PointerType sync.Cond] "cond") in
        do:  (map.insert go.uint64 (![go.MapType go.uint64 (go.PointerType sync.Cond)] (StructFieldRef Server "opAppliedConds"%go (![go.PointerType Server] "s"))) (![go.uint64] (StructFieldRef applyasbackupargs_gk.S "Index"%go (![go.PointerType applyasbackupargs_gk.S] "args"))) "$r0")
      else do:  ((MethodResolve (go.PointerType sync.Cond) "Wait"%go (![go.PointerType sync.Cond] "cond")) #())));;;
    (if: ![go.bool] (StructFieldRef Server "sealed"%go (![go.PointerType Server] "s"))
    then
      do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef Server "mu"%go (![go.PointerType Server] "s")))) #());;;
      return: (err_gk.Stale)
    else do:  #());;;
    (if: let: "$a0" := (![go.uint64] (StructFieldRef applyasbackupargs_gk.S "Epoch"%go (![go.PointerType applyasbackupargs_gk.S] "args"))) in
    (MethodResolve (go.PointerType Server) "isEpochStale"%go (![go.PointerType Server] "s")) "$a0"
    then
      do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef Server "mu"%go (![go.PointerType Server] "s")))) #());;;
      return: (err_gk.Stale)
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] (StructFieldRef applyasbackupargs_gk.S "Index"%go (![go.PointerType applyasbackupargs_gk.S] "args"))) ≠⟨go.uint64⟩ (![go.uint64] (StructFieldRef Server "nextIndex"%go (![go.PointerType Server] "s"))))
    then
      do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef Server "mu"%go (![go.PointerType Server] "s")))) #());;;
      return: (err_gk.OutOfOrder)
    else do:  #());;;
    let: "waitFn" := (GoAlloc (go.FunctionType (go.Signature [] false [])) (GoZeroVal (go.FunctionType (go.Signature [] false [])) #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] (StructFieldRef applyasbackupargs_gk.S "Op"%go (![go.PointerType applyasbackupargs_gk.S] "args"))) in
    (![go.FunctionType (go.Signature [Op] false [go.SliceType go.byte; go.FunctionType (go.Signature [] false [])])] (StructFieldRef StateMachine "StartApply"%go (![go.PointerType StateMachine] (StructFieldRef Server "sm"%go (![go.PointerType Server] "s"))))) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  "$r0";;;
    do:  ("waitFn" <-[go.FunctionType (go.Signature [] false [])] "$r1");;;
    do:  ((StructFieldRef Server "nextIndex"%go (![go.PointerType Server] "s")) <-[go.uint64] ((![go.uint64] (StructFieldRef Server "nextIndex"%go (![go.PointerType Server] "s"))) +⟨go.uint64⟩ #(W64 1)));;;
    let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "cond" := (GoAlloc (go.PointerType sync.Cond) (GoZeroVal (go.PointerType sync.Cond) #())) in
    let: ("$ret0", "$ret1") := (map.lookup2 go.uint64 (go.PointerType sync.Cond) (![go.MapType go.uint64 (go.PointerType sync.Cond)] (StructFieldRef Server "opAppliedConds"%go (![go.PointerType Server] "s"))) (![go.uint64] (StructFieldRef Server "nextIndex"%go (![go.PointerType Server] "s")))) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("cond" <-[go.PointerType sync.Cond] "$r0");;;
    do:  ("ok" <-[go.bool] "$r1");;;
    (if: ![go.bool] "ok"
    then
      do:  ((MethodResolve (go.PointerType sync.Cond) "Signal"%go (![go.PointerType sync.Cond] "cond")) #());;;
      do:  (let: "$a0" := (![go.MapType go.uint64 (go.PointerType sync.Cond)] (StructFieldRef Server "opAppliedConds"%go (![go.PointerType Server] "s"))) in
      let: "$a1" := (![go.uint64] (StructFieldRef Server "nextIndex"%go (![go.PointerType Server] "s"))) in
      (FuncResolve go.delete [go.MapType go.uint64 (go.PointerType sync.Cond)] #()) "$a0" "$a1")
    else do:  #());;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef Server "mu"%go (![go.PointerType Server] "s")))) #());;;
    do:  ((![go.FunctionType (go.Signature [] false [])] "waitFn") #());;;
    return: (err_gk.None)).

(* go: server.go:346:18 *)
Definition Server__SetStateⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" "args",
    exception_do (let: "s" := (GoAlloc (go.PointerType Server) "s") in
    let: "args" := (GoAlloc (go.PointerType setstateargs_gk.S) "args") in
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] (StructFieldRef Server "mu"%go (![go.PointerType Server] "s")))) #());;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] (StructFieldRef Server "epoch"%go (![go.PointerType Server] "s"))) >⟨go.uint64⟩ (![go.uint64] (StructFieldRef setstateargs_gk.S "Epoch"%go (![go.PointerType setstateargs_gk.S] "args"))))
    then
      do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef Server "mu"%go (![go.PointerType Server] "s")))) #());;;
      return: (err_gk.Stale)
    else
      (if: Convert go.untyped_bool go.bool ((![go.uint64] (StructFieldRef Server "epoch"%go (![go.PointerType Server] "s"))) =⟨go.uint64⟩ (![go.uint64] (StructFieldRef setstateargs_gk.S "Epoch"%go (![go.PointerType setstateargs_gk.S] "args"))))
      then
        do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef Server "mu"%go (![go.PointerType Server] "s")))) #());;;
        return: (err_gk.None)
      else
        do:  (let: "$a0" := ((let: "$sl0" := (Convert go.string go.any #"Entered new epoch"%go) in
        CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0")]))) in
        (FuncResolve log.Print [] #()) "$a0");;;
        let: "$r0" := #false in
        do:  ((StructFieldRef Server "isPrimary"%go (![go.PointerType Server] "s")) <-[go.bool] "$r0");;;
        let: "$r0" := #true in
        do:  ((StructFieldRef Server "canBecomePrimary"%go (![go.PointerType Server] "s")) <-[go.bool] "$r0");;;
        let: "$r0" := (![go.uint64] (StructFieldRef setstateargs_gk.S "Epoch"%go (![go.PointerType setstateargs_gk.S] "args"))) in
        do:  ((StructFieldRef Server "epoch"%go (![go.PointerType Server] "s")) <-[go.uint64] "$r0");;;
        let: "$r0" := #false in
        do:  ((StructFieldRef Server "leaseValid"%go (![go.PointerType Server] "s")) <-[go.bool] "$r0");;;
        let: "$r0" := #false in
        do:  ((StructFieldRef Server "sealed"%go (![go.PointerType Server] "s")) <-[go.bool] "$r0");;;
        let: "$r0" := (![go.uint64] (StructFieldRef setstateargs_gk.S "NextIndex"%go (![go.PointerType setstateargs_gk.S] "args"))) in
        do:  ((StructFieldRef Server "nextIndex"%go (![go.PointerType Server] "s")) <-[go.uint64] "$r0");;;
        do:  (let: "$a0" := (![go.SliceType go.byte] (StructFieldRef setstateargs_gk.S "State"%go (![go.PointerType setstateargs_gk.S] "args"))) in
        let: "$a1" := (![go.uint64] (StructFieldRef setstateargs_gk.S "NextIndex"%go (![go.PointerType setstateargs_gk.S] "args"))) in
        let: "$a2" := (![go.uint64] (StructFieldRef setstateargs_gk.S "Epoch"%go (![go.PointerType setstateargs_gk.S] "args"))) in
        (![go.FunctionType (go.Signature [go.SliceType go.byte; go.uint64; go.uint64] false [])] (StructFieldRef StateMachine "SetStateAndUnseal"%go (![go.PointerType StateMachine] (StructFieldRef Server "sm"%go (![go.PointerType Server] "s"))))) "$a0" "$a1" "$a2");;;
        let: "$range" := (![go.MapType go.uint64 (go.PointerType sync.Cond)] (StructFieldRef Server "opAppliedConds"%go (![go.PointerType Server] "s"))) in
        (let: "cond" := (GoAlloc (go.PointerType sync.Cond) (GoZeroVal (go.PointerType sync.Cond) #())) in
        map.for_range go.uint64 (go.PointerType sync.Cond) "$range" (λ: "$key" "value",
          do:  ("cond" <-[go.PointerType sync.Cond] "$value");;;
          do:  "$key";;;
          do:  ((MethodResolve (go.PointerType sync.Cond) "Signal"%go (![go.PointerType sync.Cond] "cond")) #())));;;
        do:  ((MethodResolve (go.PointerType sync.Cond) "Broadcast"%go (![go.PointerType sync.Cond] (StructFieldRef Server "committedNextIndex_cond"%go (![go.PointerType Server] "s")))) #());;;
        let: "$r0" := ((FuncResolve go.make1 [go.MapType go.uint64 (go.PointerType sync.Cond)] #()) #()) in
        do:  ((StructFieldRef Server "opAppliedConds"%go (![go.PointerType Server] "s")) <-[go.MapType go.uint64 (go.PointerType sync.Cond)] "$r0");;;
        do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef Server "mu"%go (![go.PointerType Server] "s")))) #());;;
        do:  (let: "$a0" := (![go.uint64] (StructFieldRef setstateargs_gk.S "CommittedNextIndex"%go (![go.PointerType setstateargs_gk.S] "args"))) in
        (MethodResolve (go.PointerType Server) "IncreaseCommitIndex"%go (![go.PointerType Server] "s")) "$a0");;;
        return: (err_gk.None)))).

(* XXX: probably should rename to GetStateAndSeal

   go: server.go:377:18 *)
Definition Server__GetStateⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" "args",
    exception_do (let: "s" := (GoAlloc (go.PointerType Server) "s") in
    let: "args" := (GoAlloc (go.PointerType getstateargs_gk.S) "args") in
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] (StructFieldRef Server "mu"%go (![go.PointerType Server] "s")))) #());;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] (StructFieldRef getstateargs_gk.S "Epoch"%go (![go.PointerType getstateargs_gk.S] "args"))) <⟨go.uint64⟩ (![go.uint64] (StructFieldRef Server "epoch"%go (![go.PointerType Server] "s"))))
    then
      do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef Server "mu"%go (![go.PointerType Server] "s")))) #());;;
      return: (GoAlloc getstatereply_gk.S (CompositeLiteral getstatereply_gk.S (LiteralValue [KeyedElement (Some (KeyField "Err"%go)) (ElementExpression err_gk.E err_gk.Stale); KeyedElement (Some (KeyField "State"%go)) (ElementExpression go.untyped_nil UntypedNil)])))
    else do:  #());;;
    let: "$r0" := #true in
    do:  ((StructFieldRef Server "sealed"%go (![go.PointerType Server] "s")) <-[go.bool] "$r0");;;
    let: "ret" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := ((![go.FunctionType (go.Signature [] false [go.SliceType go.byte])] (StructFieldRef StateMachine "GetStateAndSeal"%go (![go.PointerType StateMachine] (StructFieldRef Server "sm"%go (![go.PointerType Server] "s"))))) #()) in
    do:  ("ret" <-[go.SliceType go.byte] "$r0");;;
    let: "nextIndex" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (![go.uint64] (StructFieldRef Server "nextIndex"%go (![go.PointerType Server] "s"))) in
    do:  ("nextIndex" <-[go.uint64] "$r0");;;
    let: "committedNextIndex" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (![go.uint64] (StructFieldRef Server "committedNextIndex"%go (![go.PointerType Server] "s"))) in
    do:  ("committedNextIndex" <-[go.uint64] "$r0");;;
    let: "$range" := (![go.MapType go.uint64 (go.PointerType sync.Cond)] (StructFieldRef Server "opAppliedConds"%go (![go.PointerType Server] "s"))) in
    (let: "cond" := (GoAlloc (go.PointerType sync.Cond) (GoZeroVal (go.PointerType sync.Cond) #())) in
    map.for_range go.uint64 (go.PointerType sync.Cond) "$range" (λ: "$key" "value",
      do:  ("cond" <-[go.PointerType sync.Cond] "$value");;;
      do:  "$key";;;
      do:  ((MethodResolve (go.PointerType sync.Cond) "Signal"%go (![go.PointerType sync.Cond] "cond")) #())));;;
    let: "$r0" := ((FuncResolve go.make1 [go.MapType go.uint64 (go.PointerType sync.Cond)] #()) #()) in
    do:  ((StructFieldRef Server "opAppliedConds"%go (![go.PointerType Server] "s")) <-[go.MapType go.uint64 (go.PointerType sync.Cond)] "$r0");;;
    do:  ((MethodResolve (go.PointerType sync.Cond) "Broadcast"%go (![go.PointerType sync.Cond] (StructFieldRef Server "committedNextIndex_cond"%go (![go.PointerType Server] "s")))) #());;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef Server "mu"%go (![go.PointerType Server] "s")))) #());;;
    return: (GoAlloc getstatereply_gk.S (CompositeLiteral getstatereply_gk.S (LiteralValue [KeyedElement (Some (KeyField "Err"%go)) (ElementExpression err_gk.E err_gk.None); KeyedElement (Some (KeyField "State"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] "ret")); KeyedElement (Some (KeyField "NextIndex"%go)) (ElementExpression go.uint64 (![go.uint64] "nextIndex")); KeyedElement (Some (KeyField "CommittedNextIndex"%go)) (ElementExpression go.uint64 (![go.uint64] "committedNextIndex"))])))).

(* go: server.go:400:18 *)
Definition Server__BecomePrimaryⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" "args",
    exception_do (let: "s" := (GoAlloc (go.PointerType Server) "s") in
    let: "args" := (GoAlloc (go.PointerType becomeprimaryargs_gk.S) "args") in
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] (StructFieldRef Server "mu"%go (![go.PointerType Server] "s")))) #());;;
    (if: ((![go.uint64] (StructFieldRef becomeprimaryargs_gk.S "Epoch"%go (![go.PointerType becomeprimaryargs_gk.S] "args"))) ≠⟨go.uint64⟩ (![go.uint64] (StructFieldRef Server "epoch"%go (![go.PointerType Server] "s")))) || (~ (![go.bool] (StructFieldRef Server "canBecomePrimary"%go (![go.PointerType Server] "s"))))
    then
      do:  (let: "$a0" := #"Wrong epoch in BecomePrimary request (in %d, got %d)"%go in
      let: "$a1" := ((let: "$sl0" := (Convert go.uint64 go.any (![go.uint64] (StructFieldRef Server "epoch"%go (![go.PointerType Server] "s")))) in
      let: "$sl1" := (Convert go.uint64 go.any (![go.uint64] (StructFieldRef becomeprimaryargs_gk.S "Epoch"%go (![go.PointerType becomeprimaryargs_gk.S] "args")))) in
      CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0"); KeyedElement None (ElementExpression go.any "$sl1")]))) in
      (FuncResolve log.Printf [] #()) "$a0" "$a1");;;
      do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef Server "mu"%go (![go.PointerType Server] "s")))) #());;;
      return: (err_gk.Stale)
    else do:  #());;;
    do:  (let: "$a0" := ((let: "$sl0" := (Convert go.string go.any #"Became Primary"%go) in
    CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0")]))) in
    (FuncResolve log.Println [] #()) "$a0");;;
    let: "$r0" := #true in
    do:  ((StructFieldRef Server "isPrimary"%go (![go.PointerType Server] "s")) <-[go.bool] "$r0");;;
    do:  ((MethodResolve (go.PointerType sync.Cond) "Signal"%go (![go.PointerType sync.Cond] (StructFieldRef Server "isPrimary_cond"%go (![go.PointerType Server] "s")))) #());;;
    let: "$r0" := #false in
    do:  ((StructFieldRef Server "canBecomePrimary"%go (![go.PointerType Server] "s")) <-[go.bool] "$r0");;;
    let: "numClerks" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 32) in
    do:  ("numClerks" <-[go.uint64] "$r0");;;
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType (go.SliceType (go.PointerType Clerk))] #()) (![go.uint64] "numClerks")) in
    do:  ((StructFieldRef Server "clerks"%go (![go.PointerType Server] "s")) <-[go.SliceType (go.SliceType (go.PointerType Clerk))] "$r0");;;
    let: "j" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("j" <-[go.uint64] "$r0");;;
    (for: (λ: <>, (![go.uint64] "j") <⟨go.uint64⟩ (![go.uint64] "numClerks")); (λ: <>, #()) := λ: <>,
      let: "clerks" := (GoAlloc (go.SliceType (go.PointerType Clerk)) (GoZeroVal (go.SliceType (go.PointerType Clerk)) #())) in
      let: "$r0" := ((FuncResolve go.make2 [go.SliceType (go.PointerType Clerk)] #()) ((let: "$a0" := (![go.SliceType go.uint64] (StructFieldRef becomeprimaryargs_gk.S "Replicas"%go (![go.PointerType becomeprimaryargs_gk.S] "args"))) in
      (FuncResolve go.len [go.SliceType go.uint64] #()) "$a0") -⟨go.int⟩ #(W64 1))) in
      do:  ("clerks" <-[go.SliceType (go.PointerType Clerk)] "$r0");;;
      let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: "$r0" := #(W64 0) in
      do:  ("i" <-[go.uint64] "$r0");;;
      (for: (λ: <>, (![go.uint64] "i") <⟨go.uint64⟩ (Convert go.int go.uint64 (let: "$a0" := (![go.SliceType (go.PointerType Clerk)] "clerks") in
      (FuncResolve go.len [go.SliceType (go.PointerType Clerk)] #()) "$a0"))); (λ: <>, #()) := λ: <>,
        let: "$r0" := (let: "$a0" := (![go.uint64] (IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] (StructFieldRef becomeprimaryargs_gk.S "Replicas"%go (![go.PointerType becomeprimaryargs_gk.S] "args")), Convert go.uint64 go.int ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 1))))) in
        (FuncResolve MakeClerk [] #()) "$a0") in
        do:  ((IndexRef (go.SliceType (go.PointerType Clerk)) (![go.SliceType (go.PointerType Clerk)] "clerks", Convert go.uint64 go.int (![go.uint64] "i"))) <-[go.PointerType Clerk] "$r0");;;
        do:  ("i" <-[go.uint64] ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 1))));;;
      let: "$r0" := (![go.SliceType (go.PointerType Clerk)] "clerks") in
      do:  ((IndexRef (go.SliceType (go.SliceType (go.PointerType Clerk))) (![go.SliceType (go.SliceType (go.PointerType Clerk))] (StructFieldRef Server "clerks"%go (![go.PointerType Server] "s")), Convert go.uint64 go.int (![go.uint64] "j"))) <-[go.SliceType (go.PointerType Clerk)] "$r0");;;
      do:  ("j" <-[go.uint64] ((![go.uint64] "j") +⟨go.uint64⟩ #(W64 1))));;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef Server "mu"%go (![go.PointerType Server] "s")))) #());;;
    return: (err_gk.None)).

(* go: server.go:434:6 *)
Definition MakeServerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "sm" "confHosts" "nextIndex" "epoch" "sealed",
    exception_do (let: "sealed" := (GoAlloc go.bool "sealed") in
    let: "epoch" := (GoAlloc go.uint64 "epoch") in
    let: "nextIndex" := (GoAlloc go.uint64 "nextIndex") in
    let: "confHosts" := (GoAlloc (go.SliceType grove_ffi.Address) "confHosts") in
    let: "sm" := (GoAlloc (go.PointerType StateMachine) "sm") in
    let: "s" := (GoAlloc (go.PointerType Server) (GoZeroVal (go.PointerType Server) #())) in
    let: "$r0" := (GoAlloc Server (GoZeroVal Server #())) in
    do:  ("s" <-[go.PointerType Server] "$r0");;;
    let: "$r0" := (GoAlloc sync.Mutex (GoZeroVal sync.Mutex #())) in
    do:  ((StructFieldRef Server "mu"%go (![go.PointerType Server] "s")) <-[go.PointerType sync.Mutex] "$r0");;;
    let: "$r0" := (![go.uint64] "epoch") in
    do:  ((StructFieldRef Server "epoch"%go (![go.PointerType Server] "s")) <-[go.uint64] "$r0");;;
    let: "$r0" := (![go.bool] "sealed") in
    do:  ((StructFieldRef Server "sealed"%go (![go.PointerType Server] "s")) <-[go.bool] "$r0");;;
    let: "$r0" := (![go.PointerType StateMachine] "sm") in
    do:  ((StructFieldRef Server "sm"%go (![go.PointerType Server] "s")) <-[go.PointerType StateMachine] "$r0");;;
    let: "$r0" := (![go.uint64] "nextIndex") in
    do:  ((StructFieldRef Server "nextIndex"%go (![go.PointerType Server] "s")) <-[go.uint64] "$r0");;;
    let: "$r0" := #false in
    do:  ((StructFieldRef Server "isPrimary"%go (![go.PointerType Server] "s")) <-[go.bool] "$r0");;;
    let: "$r0" := #false in
    do:  ((StructFieldRef Server "canBecomePrimary"%go (![go.PointerType Server] "s")) <-[go.bool] "$r0");;;
    let: "$r0" := #false in
    do:  ((StructFieldRef Server "leaseValid"%go (![go.PointerType Server] "s")) <-[go.bool] "$r0");;;
    let: "$r0" := #false in
    do:  ((StructFieldRef Server "canBecomePrimary"%go (![go.PointerType Server] "s")) <-[go.bool] "$r0");;;
    let: "$r0" := ((FuncResolve go.make1 [go.MapType go.uint64 (go.PointerType sync.Cond)] #()) #()) in
    do:  ((StructFieldRef Server "opAppliedConds"%go (![go.PointerType Server] "s")) <-[go.MapType go.uint64 (go.PointerType sync.Cond)] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType grove_ffi.Address] "confHosts") in
    (FuncResolve configservice.MakeClerk [] #()) "$a0") in
    do:  ((StructFieldRef Server "confCk"%go (![go.PointerType Server] "s")) <-[go.PointerType configservice.Clerk] "$r0");;;
    let: "$r0" := (let: "$a0" := (Convert (go.PointerType sync.Mutex) sync.Locker (![go.PointerType sync.Mutex] (StructFieldRef Server "mu"%go (![go.PointerType Server] "s")))) in
    (FuncResolve sync.NewCond [] #()) "$a0") in
    do:  ((StructFieldRef Server "committedNextIndex_cond"%go (![go.PointerType Server] "s")) <-[go.PointerType sync.Cond] "$r0");;;
    let: "$r0" := (let: "$a0" := (Convert (go.PointerType sync.Mutex) sync.Locker (![go.PointerType sync.Mutex] (StructFieldRef Server "mu"%go (![go.PointerType Server] "s")))) in
    (FuncResolve sync.NewCond [] #()) "$a0") in
    do:  ((StructFieldRef Server "isPrimary_cond"%go (![go.PointerType Server] "s")) <-[go.PointerType sync.Cond] "$r0");;;
    return: (![go.PointerType Server] "s")).

(* go: server.go:453:18 *)
Definition Server__Serveⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" "me",
    exception_do (let: "s" := (GoAlloc (go.PointerType Server) "s") in
    let: "me" := (GoAlloc grove_ffi.Address "me") in
    let: "handlers" := (GoAlloc (go.MapType go.uint64 (go.FunctionType (go.Signature [go.SliceType go.byte; go.PointerType (go.SliceType go.byte)] false []))) (GoZeroVal (go.MapType go.uint64 (go.FunctionType (go.Signature [go.SliceType go.byte; go.PointerType (go.SliceType go.byte)] false []))) #())) in
    let: "$r0" := ((FuncResolve go.make1 [go.MapType go.uint64 (go.FunctionType (go.Signature [go.SliceType go.byte; go.PointerType (go.SliceType go.byte)] false []))] #()) #()) in
    do:  ("handlers" <-[go.MapType go.uint64 (go.FunctionType (go.Signature [go.SliceType go.byte; go.PointerType (go.SliceType go.byte)] false []))] "$r0");;;
    let: "$r0" := (λ: "args" "reply",
      exception_do (let: "reply" := (GoAlloc (go.PointerType (go.SliceType go.byte)) "reply") in
      let: "args" := (GoAlloc (go.SliceType go.byte) "args") in
      let: "a" := (GoAlloc applyasbackupargs_gk.S (GoZeroVal applyasbackupargs_gk.S #())) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] "args") in
      (FuncResolve applyasbackupargs_gk.Unmarshal [] #()) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("a" <-[applyasbackupargs_gk.S] "$r0");;;
      do:  "$r1";;;
      let: "$r0" := (let: "$a0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 8)) in
      let: "$a1" := (let: "$a0" := "a" in
      (MethodResolve (go.PointerType Server) "ApplyAsBackup"%go (![go.PointerType Server] "s")) "$a0") in
      (FuncResolve err_gk.Marshal [] #()) "$a0" "$a1") in
      do:  ((![go.PointerType (go.SliceType go.byte)] "reply") <-[go.SliceType go.byte] "$r0");;;
      return: #())
      ) in
    do:  (map.insert go.uint64 (![go.MapType go.uint64 (go.FunctionType (go.Signature [go.SliceType go.byte; go.PointerType (go.SliceType go.byte)] false []))] "handlers") RPC_APPLYASBACKUP "$r0");;;
    let: "$r0" := (λ: "args" "reply",
      exception_do (let: "reply" := (GoAlloc (go.PointerType (go.SliceType go.byte)) "reply") in
      let: "args" := (GoAlloc (go.SliceType go.byte) "args") in
      let: "a" := (GoAlloc setstateargs_gk.S (GoZeroVal setstateargs_gk.S #())) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] "args") in
      (FuncResolve setstateargs_gk.Unmarshal [] #()) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("a" <-[setstateargs_gk.S] "$r0");;;
      do:  "$r1";;;
      let: "$r0" := (let: "$a0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 0)) in
      let: "$a1" := (let: "$a0" := "a" in
      (MethodResolve (go.PointerType Server) "SetState"%go (![go.PointerType Server] "s")) "$a0") in
      (FuncResolve err_gk.Marshal [] #()) "$a0" "$a1") in
      do:  ((![go.PointerType (go.SliceType go.byte)] "reply") <-[go.SliceType go.byte] "$r0");;;
      return: #())
      ) in
    do:  (map.insert go.uint64 (![go.MapType go.uint64 (go.FunctionType (go.Signature [go.SliceType go.byte; go.PointerType (go.SliceType go.byte)] false []))] "handlers") RPC_SETSTATE "$r0");;;
    let: "$r0" := (λ: "args" "reply",
      exception_do (let: "reply" := (GoAlloc (go.PointerType (go.SliceType go.byte)) "reply") in
      let: "args" := (GoAlloc (go.SliceType go.byte) "args") in
      let: "a" := (GoAlloc getstateargs_gk.S (GoZeroVal getstateargs_gk.S #())) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] "args") in
      (FuncResolve getstateargs_gk.Unmarshal [] #()) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("a" <-[getstateargs_gk.S] "$r0");;;
      do:  "$r1";;;
      let: "$r0" := (let: "$a0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 0)) in
      let: "$a1" := (![getstatereply_gk.S] (let: "$a0" := "a" in
      (MethodResolve (go.PointerType Server) "GetState"%go (![go.PointerType Server] "s")) "$a0")) in
      (FuncResolve getstatereply_gk.Marshal [] #()) "$a0" "$a1") in
      do:  ((![go.PointerType (go.SliceType go.byte)] "reply") <-[go.SliceType go.byte] "$r0");;;
      return: #())
      ) in
    do:  (map.insert go.uint64 (![go.MapType go.uint64 (go.FunctionType (go.Signature [go.SliceType go.byte; go.PointerType (go.SliceType go.byte)] false []))] "handlers") RPC_GETSTATE "$r0");;;
    let: "$r0" := (λ: "args" "reply",
      exception_do (let: "reply" := (GoAlloc (go.PointerType (go.SliceType go.byte)) "reply") in
      let: "args" := (GoAlloc (go.SliceType go.byte) "args") in
      let: "a" := (GoAlloc becomeprimaryargs_gk.S (GoZeroVal becomeprimaryargs_gk.S #())) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] "args") in
      (FuncResolve becomeprimaryargs_gk.Unmarshal [] #()) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("a" <-[becomeprimaryargs_gk.S] "$r0");;;
      do:  "$r1";;;
      let: "$r0" := (let: "$a0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 0)) in
      let: "$a1" := (let: "$a0" := "a" in
      (MethodResolve (go.PointerType Server) "BecomePrimary"%go (![go.PointerType Server] "s")) "$a0") in
      (FuncResolve err_gk.Marshal [] #()) "$a0" "$a1") in
      do:  ((![go.PointerType (go.SliceType go.byte)] "reply") <-[go.SliceType go.byte] "$r0");;;
      return: #())
      ) in
    do:  (map.insert go.uint64 (![go.MapType go.uint64 (go.FunctionType (go.Signature [go.SliceType go.byte; go.PointerType (go.SliceType go.byte)] false []))] "handlers") RPC_BECOMEPRIMARY "$r0");;;
    let: "$r0" := (λ: "args" "reply",
      exception_do (let: "reply" := (GoAlloc (go.PointerType (go.SliceType go.byte)) "reply") in
      let: "args" := (GoAlloc (go.SliceType go.byte) "args") in
      let: "$r0" := (let: "$a0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 0)) in
      let: "$a1" := (![applyreply_gk.S] (let: "$a0" := (![go.SliceType go.byte] "args") in
      (MethodResolve (go.PointerType Server) "Apply"%go (![go.PointerType Server] "s")) "$a0")) in
      (FuncResolve applyreply_gk.Marshal [] #()) "$a0" "$a1") in
      do:  ((![go.PointerType (go.SliceType go.byte)] "reply") <-[go.SliceType go.byte] "$r0");;;
      return: #())
      ) in
    do:  (map.insert go.uint64 (![go.MapType go.uint64 (go.FunctionType (go.Signature [go.SliceType go.byte; go.PointerType (go.SliceType go.byte)] false []))] "handlers") RPC_PRIMARYAPPLY "$r0");;;
    let: "$r0" := (λ: "args" "reply",
      exception_do (let: "reply" := (GoAlloc (go.PointerType (go.SliceType go.byte)) "reply") in
      let: "args" := (GoAlloc (go.SliceType go.byte) "args") in
      let: "$r0" := (let: "$a0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 0)) in
      let: "$a1" := (![applyreply_gk.S] (let: "$a0" := (![go.SliceType go.byte] "args") in
      (MethodResolve (go.PointerType Server) "ApplyRoWaitForCommit"%go (![go.PointerType Server] "s")) "$a0")) in
      (FuncResolve applyreply_gk.Marshal [] #()) "$a0" "$a1") in
      do:  ((![go.PointerType (go.SliceType go.byte)] "reply") <-[go.SliceType go.byte] "$r0");;;
      return: #())
      ) in
    do:  (map.insert go.uint64 (![go.MapType go.uint64 (go.FunctionType (go.Signature [go.SliceType go.byte; go.PointerType (go.SliceType go.byte)] false []))] "handlers") RPC_ROPRIMARYAPPLY "$r0");;;
    let: "$r0" := (λ: "args" "reply",
      exception_do (let: "reply" := (GoAlloc (go.PointerType (go.SliceType go.byte)) "reply") in
      let: "args" := (GoAlloc (go.SliceType go.byte) "args") in
      let: "ica" := (GoAlloc increasecommitargs_gk.S (GoZeroVal increasecommitargs_gk.S #())) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] "args") in
      (FuncResolve increasecommitargs_gk.Unmarshal [] #()) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("ica" <-[increasecommitargs_gk.S] "$r0");;;
      do:  "$r1";;;
      do:  (let: "$a0" := (![go.uint64] (StructFieldRef increasecommitargs_gk.S "V"%go "ica")) in
      (MethodResolve (go.PointerType Server) "IncreaseCommitIndex"%go (![go.PointerType Server] "s")) "$a0");;;
      return: #())
      ) in
    do:  (map.insert go.uint64 (![go.MapType go.uint64 (go.FunctionType (go.Signature [go.SliceType go.byte; go.PointerType (go.SliceType go.byte)] false []))] "handlers") RPC_INCREASECOMMIT "$r0");;;
    let: "rs" := (GoAlloc (go.PointerType urpc.Server) (GoZeroVal (go.PointerType urpc.Server) #())) in
    let: "$r0" := (let: "$a0" := (![go.MapType go.uint64 (go.FunctionType (go.Signature [go.SliceType go.byte; go.PointerType (go.SliceType go.byte)] false []))] "handlers") in
    (FuncResolve urpc.MakeServer [] #()) "$a0") in
    do:  ("rs" <-[go.PointerType urpc.Server] "$r0");;;
    do:  (let: "$a0" := (![grove_ffi.Address] "me") in
    (MethodResolve (go.PointerType urpc.Server) "Serve"%go (![go.PointerType urpc.Server] "rs")) "$a0");;;
    let: "$go" := (λ: <>,
      exception_do (do:  ((MethodResolve (go.PointerType Server) "leaseRenewalThread"%go (![go.PointerType Server] "s")) #());;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    let: "$go" := (λ: <>,
      exception_do (do:  ((MethodResolve (go.PointerType Server) "sendIncreaseCommitThread"%go (![go.PointerType Server] "s")) #());;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    return: #()).

#[global] Instance info' : PkgInfo pkg_id.replica :=
{|
  pkg_imported_pkgs := [code.github_com.mit_pdos.gokv.grove_ffi.pkg_id.grove_ffi; code.github_com.mit_pdos.gokv.reconfig.replica.becomeprimaryargs_gk.pkg_id.becomeprimaryargs_gk; code.github_com.mit_pdos.gokv.reconnectclient.pkg_id.reconnectclient; code.github_com.mit_pdos.gokv.vrsm.replica.applyasbackupargs_gk.pkg_id.applyasbackupargs_gk; code.github_com.mit_pdos.gokv.vrsm.replica.applyreply_gk.pkg_id.applyreply_gk; code.github_com.mit_pdos.gokv.vrsm.replica.err_gk.pkg_id.err_gk; code.github_com.mit_pdos.gokv.vrsm.replica.getstateargs_gk.pkg_id.getstateargs_gk; code.github_com.mit_pdos.gokv.vrsm.replica.getstatereply_gk.pkg_id.getstatereply_gk; code.github_com.mit_pdos.gokv.vrsm.replica.increasecommitargs_gk.pkg_id.increasecommitargs_gk; code.github_com.mit_pdos.gokv.vrsm.replica.setstateargs_gk.pkg_id.setstateargs_gk; code.log.pkg_id.log; code.sync.pkg_id.sync; code.github_com.goose_lang.primitive.pkg_id.primitive; code.github_com.goose_lang.std.pkg_id.std; code.github_com.mit_pdos.gokv.urpc.pkg_id.urpc; code.github_com.mit_pdos.gokv.vrsm.configservice.pkg_id.configservice; code.github_com.mit_pdos.gokv.vrsm.replica.becomeprimaryargs_gk.pkg_id.becomeprimaryargs_gk]
|}.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init pkg_id.replica (λ: <>,
      exception_do (do:  (becomeprimaryargs_gk.initialize' #());;;
      do:  (configservice.initialize' #());;;
      do:  (urpc.initialize' #());;;
      do:  (std.initialize' #());;;
      do:  (primitive.initialize' #());;;
      do:  (sync.initialize' #());;;
      do:  (log.initialize' #());;;
      do:  (setstateargs_gk.initialize' #());;;
      do:  (increasecommitargs_gk.initialize' #());;;
      do:  (getstatereply_gk.initialize' #());;;
      do:  (getstateargs_gk.initialize' #());;;
      do:  (err_gk.initialize' #());;;
      do:  (applyreply_gk.initialize' #());;;
      do:  (applyasbackupargs_gk.initialize' #());;;
      do:  (reconnectclient.initialize' #());;;
      do:  (becomeprimaryargs_gk.initialize' #());;;
      do:  (grove_ffi.initialize' #()))
      ).

Module StateMachine.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  StartApply' : func.t;
  ApplyReadonly' : func.t;
  SetStateAndUnseal' : func.t;
  GetStateAndSeal' : func.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End StateMachine.

Definition StateMachine'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "StartApply"%go (go.FunctionType (go.Signature [Op] false [go.SliceType go.byte; go.FunctionType (go.Signature [] false [])])));
  (go.FieldDecl "ApplyReadonly"%go (go.FunctionType (go.Signature [Op] false [go.uint64; go.SliceType go.byte])));
  (go.FieldDecl "SetStateAndUnseal"%go (go.FunctionType (go.Signature [go.SliceType go.byte; go.uint64; go.uint64] false [])));
  (go.FieldDecl "GetStateAndSeal"%go (go.FunctionType (go.Signature [] false [go.SliceType go.byte])))
].
Program Definition StateMachine'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (StateMachine'fds_unsealed).
Global Instance equals_unfold_StateMachine {ext : ffi_syntax} {go_gctx : GoGlobalContext} : StateMachine'fds =→ StateMachine'fds_unsealed.
Proof. rewrite /StateMachine'fds seal_eq //. Qed.

Definition StateMachineⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (StateMachine'fds).

Class StateMachine_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] StateMachine_type_repr  :: go.TypeReprUnderlying StateMachineⁱᵐᵖˡ StateMachine.t;
  #[global] StateMachine_underlying :: (StateMachine) <u (StateMachineⁱᵐᵖˡ);
  #[global] StateMachine_get_StartApply (x : StateMachine.t) :: ⟦StructFieldGet (StateMachineⁱᵐᵖˡ) "StartApply", #x⟧ ⤳[under] #x.(StateMachine.StartApply');
  #[global] StateMachine_set_StartApply (x : StateMachine.t) y :: ⟦StructFieldSet (StateMachineⁱᵐᵖˡ) "StartApply", (#x, #y)⟧ ⤳[under] #(x <|StateMachine.StartApply' := y|>);
  #[global] StateMachine_get_ApplyReadonly (x : StateMachine.t) :: ⟦StructFieldGet (StateMachineⁱᵐᵖˡ) "ApplyReadonly", #x⟧ ⤳[under] #x.(StateMachine.ApplyReadonly');
  #[global] StateMachine_set_ApplyReadonly (x : StateMachine.t) y :: ⟦StructFieldSet (StateMachineⁱᵐᵖˡ) "ApplyReadonly", (#x, #y)⟧ ⤳[under] #(x <|StateMachine.ApplyReadonly' := y|>);
  #[global] StateMachine_get_SetStateAndUnseal (x : StateMachine.t) :: ⟦StructFieldGet (StateMachineⁱᵐᵖˡ) "SetStateAndUnseal", #x⟧ ⤳[under] #x.(StateMachine.SetStateAndUnseal');
  #[global] StateMachine_set_SetStateAndUnseal (x : StateMachine.t) y :: ⟦StructFieldSet (StateMachineⁱᵐᵖˡ) "SetStateAndUnseal", (#x, #y)⟧ ⤳[under] #(x <|StateMachine.SetStateAndUnseal' := y|>);
  #[global] StateMachine_get_GetStateAndSeal (x : StateMachine.t) :: ⟦StructFieldGet (StateMachineⁱᵐᵖˡ) "GetStateAndSeal", #x⟧ ⤳[under] #x.(StateMachine.GetStateAndSeal');
  #[global] StateMachine_set_GetStateAndSeal (x : StateMachine.t) y :: ⟦StructFieldSet (StateMachineⁱᵐᵖˡ) "GetStateAndSeal", (#x, #y)⟧ ⤳[under] #(x <|StateMachine.GetStateAndSeal' := y|>);
}.

Module SyncStateMachine.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  Apply' : func.t;
  ApplyReadonly' : func.t;
  SetStateAndUnseal' : func.t;
  GetStateAndSeal' : func.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End SyncStateMachine.

Definition SyncStateMachine'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "Apply"%go (go.FunctionType (go.Signature [Op] false [go.SliceType go.byte])));
  (go.FieldDecl "ApplyReadonly"%go (go.FunctionType (go.Signature [Op] false [go.uint64; go.SliceType go.byte])));
  (go.FieldDecl "SetStateAndUnseal"%go (go.FunctionType (go.Signature [go.SliceType go.byte; go.uint64; go.uint64] false [])));
  (go.FieldDecl "GetStateAndSeal"%go (go.FunctionType (go.Signature [] false [go.SliceType go.byte])))
].
Program Definition SyncStateMachine'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (SyncStateMachine'fds_unsealed).
Global Instance equals_unfold_SyncStateMachine {ext : ffi_syntax} {go_gctx : GoGlobalContext} : SyncStateMachine'fds =→ SyncStateMachine'fds_unsealed.
Proof. rewrite /SyncStateMachine'fds seal_eq //. Qed.

Definition SyncStateMachineⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (SyncStateMachine'fds).

Class SyncStateMachine_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] SyncStateMachine_type_repr  :: go.TypeReprUnderlying SyncStateMachineⁱᵐᵖˡ SyncStateMachine.t;
  #[global] SyncStateMachine_underlying :: (SyncStateMachine) <u (SyncStateMachineⁱᵐᵖˡ);
  #[global] SyncStateMachine_get_Apply (x : SyncStateMachine.t) :: ⟦StructFieldGet (SyncStateMachineⁱᵐᵖˡ) "Apply", #x⟧ ⤳[under] #x.(SyncStateMachine.Apply');
  #[global] SyncStateMachine_set_Apply (x : SyncStateMachine.t) y :: ⟦StructFieldSet (SyncStateMachineⁱᵐᵖˡ) "Apply", (#x, #y)⟧ ⤳[under] #(x <|SyncStateMachine.Apply' := y|>);
  #[global] SyncStateMachine_get_ApplyReadonly (x : SyncStateMachine.t) :: ⟦StructFieldGet (SyncStateMachineⁱᵐᵖˡ) "ApplyReadonly", #x⟧ ⤳[under] #x.(SyncStateMachine.ApplyReadonly');
  #[global] SyncStateMachine_set_ApplyReadonly (x : SyncStateMachine.t) y :: ⟦StructFieldSet (SyncStateMachineⁱᵐᵖˡ) "ApplyReadonly", (#x, #y)⟧ ⤳[under] #(x <|SyncStateMachine.ApplyReadonly' := y|>);
  #[global] SyncStateMachine_get_SetStateAndUnseal (x : SyncStateMachine.t) :: ⟦StructFieldGet (SyncStateMachineⁱᵐᵖˡ) "SetStateAndUnseal", #x⟧ ⤳[under] #x.(SyncStateMachine.SetStateAndUnseal');
  #[global] SyncStateMachine_set_SetStateAndUnseal (x : SyncStateMachine.t) y :: ⟦StructFieldSet (SyncStateMachineⁱᵐᵖˡ) "SetStateAndUnseal", (#x, #y)⟧ ⤳[under] #(x <|SyncStateMachine.SetStateAndUnseal' := y|>);
  #[global] SyncStateMachine_get_GetStateAndSeal (x : SyncStateMachine.t) :: ⟦StructFieldGet (SyncStateMachineⁱᵐᵖˡ) "GetStateAndSeal", #x⟧ ⤳[under] #x.(SyncStateMachine.GetStateAndSeal');
  #[global] SyncStateMachine_set_GetStateAndSeal (x : SyncStateMachine.t) y :: ⟦StructFieldSet (SyncStateMachineⁱᵐᵖˡ) "GetStateAndSeal", (#x, #y)⟧ ⤳[under] #(x <|SyncStateMachine.GetStateAndSeal' := y|>);
}.

Module Clerk.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  cl' : loc;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End Clerk.

Definition Clerk'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "cl"%go (go.PointerType reconnectclient.ReconnectingClient))
].
Program Definition Clerk'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (Clerk'fds_unsealed).
Global Instance equals_unfold_Clerk {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Clerk'fds =→ Clerk'fds_unsealed.
Proof. rewrite /Clerk'fds seal_eq //. Qed.

Definition Clerkⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (Clerk'fds).

Class Clerk_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Clerk_type_repr  :: go.TypeReprUnderlying Clerkⁱᵐᵖˡ Clerk.t;
  #[global] Clerk_underlying :: (Clerk) <u (Clerkⁱᵐᵖˡ);
  #[global] Clerk_get_cl (x : Clerk.t) :: ⟦StructFieldGet (Clerkⁱᵐᵖˡ) "cl", #x⟧ ⤳[under] #x.(Clerk.cl');
  #[global] Clerk_set_cl (x : Clerk.t) y :: ⟦StructFieldSet (Clerkⁱᵐᵖˡ) "cl", (#x, #y)⟧ ⤳[under] #(x <|Clerk.cl' := y|>);
  #[global] Clerk'ptr_Apply_unfold :: MethodUnfold (go.PointerType (Clerk)) "Apply" (Clerk__Applyⁱᵐᵖˡ);
  #[global] Clerk'ptr_ApplyAsBackup_unfold :: MethodUnfold (go.PointerType (Clerk)) "ApplyAsBackup" (Clerk__ApplyAsBackupⁱᵐᵖˡ);
  #[global] Clerk'ptr_ApplyRo_unfold :: MethodUnfold (go.PointerType (Clerk)) "ApplyRo" (Clerk__ApplyRoⁱᵐᵖˡ);
  #[global] Clerk'ptr_BecomePrimary_unfold :: MethodUnfold (go.PointerType (Clerk)) "BecomePrimary" (Clerk__BecomePrimaryⁱᵐᵖˡ);
  #[global] Clerk'ptr_GetState_unfold :: MethodUnfold (go.PointerType (Clerk)) "GetState" (Clerk__GetStateⁱᵐᵖˡ);
  #[global] Clerk'ptr_IncreaseCommitIndex_unfold :: MethodUnfold (go.PointerType (Clerk)) "IncreaseCommitIndex" (Clerk__IncreaseCommitIndexⁱᵐᵖˡ);
  #[global] Clerk'ptr_SetState_unfold :: MethodUnfold (go.PointerType (Clerk)) "SetState" (Clerk__SetStateⁱᵐᵖˡ);
}.

Module Server.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  mu' : loc;
  epoch' : w64;
  sealed' : bool;
  sm' : loc;
  nextIndex' : w64;
  canBecomePrimary' : bool;
  isPrimary' : bool;
  clerks' : slice.t;
  isPrimary_cond' : loc;
  opAppliedConds' : map.t;
  leaseExpiration' : w64;
  leaseValid' : bool;
  committedNextIndex' : w64;
  committedNextIndex_cond' : loc;
  confCk' : loc;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End Server.

Definition Server'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "mu"%go (go.PointerType sync.Mutex));
  (go.FieldDecl "epoch"%go go.uint64);
  (go.FieldDecl "sealed"%go go.bool);
  (go.FieldDecl "sm"%go (go.PointerType StateMachine));
  (go.FieldDecl "nextIndex"%go go.uint64);
  (go.FieldDecl "canBecomePrimary"%go go.bool);
  (go.FieldDecl "isPrimary"%go go.bool);
  (go.FieldDecl "clerks"%go (go.SliceType (go.SliceType (go.PointerType Clerk))));
  (go.FieldDecl "isPrimary_cond"%go (go.PointerType sync.Cond));
  (go.FieldDecl "opAppliedConds"%go (go.MapType go.uint64 (go.PointerType sync.Cond)));
  (go.FieldDecl "leaseExpiration"%go go.uint64);
  (go.FieldDecl "leaseValid"%go go.bool);
  (go.FieldDecl "committedNextIndex"%go go.uint64);
  (go.FieldDecl "committedNextIndex_cond"%go (go.PointerType sync.Cond));
  (go.FieldDecl "confCk"%go (go.PointerType configservice.Clerk))
].
Program Definition Server'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (Server'fds_unsealed).
Global Instance equals_unfold_Server {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Server'fds =→ Server'fds_unsealed.
Proof. rewrite /Server'fds seal_eq //. Qed.

Definition Serverⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (Server'fds).

Class Server_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Server_type_repr  :: go.TypeReprUnderlying Serverⁱᵐᵖˡ Server.t;
  #[global] Server_underlying :: (Server) <u (Serverⁱᵐᵖˡ);
  #[global] Server_get_mu (x : Server.t) :: ⟦StructFieldGet (Serverⁱᵐᵖˡ) "mu", #x⟧ ⤳[under] #x.(Server.mu');
  #[global] Server_set_mu (x : Server.t) y :: ⟦StructFieldSet (Serverⁱᵐᵖˡ) "mu", (#x, #y)⟧ ⤳[under] #(x <|Server.mu' := y|>);
  #[global] Server_get_epoch (x : Server.t) :: ⟦StructFieldGet (Serverⁱᵐᵖˡ) "epoch", #x⟧ ⤳[under] #x.(Server.epoch');
  #[global] Server_set_epoch (x : Server.t) y :: ⟦StructFieldSet (Serverⁱᵐᵖˡ) "epoch", (#x, #y)⟧ ⤳[under] #(x <|Server.epoch' := y|>);
  #[global] Server_get_sealed (x : Server.t) :: ⟦StructFieldGet (Serverⁱᵐᵖˡ) "sealed", #x⟧ ⤳[under] #x.(Server.sealed');
  #[global] Server_set_sealed (x : Server.t) y :: ⟦StructFieldSet (Serverⁱᵐᵖˡ) "sealed", (#x, #y)⟧ ⤳[under] #(x <|Server.sealed' := y|>);
  #[global] Server_get_sm (x : Server.t) :: ⟦StructFieldGet (Serverⁱᵐᵖˡ) "sm", #x⟧ ⤳[under] #x.(Server.sm');
  #[global] Server_set_sm (x : Server.t) y :: ⟦StructFieldSet (Serverⁱᵐᵖˡ) "sm", (#x, #y)⟧ ⤳[under] #(x <|Server.sm' := y|>);
  #[global] Server_get_nextIndex (x : Server.t) :: ⟦StructFieldGet (Serverⁱᵐᵖˡ) "nextIndex", #x⟧ ⤳[under] #x.(Server.nextIndex');
  #[global] Server_set_nextIndex (x : Server.t) y :: ⟦StructFieldSet (Serverⁱᵐᵖˡ) "nextIndex", (#x, #y)⟧ ⤳[under] #(x <|Server.nextIndex' := y|>);
  #[global] Server_get_canBecomePrimary (x : Server.t) :: ⟦StructFieldGet (Serverⁱᵐᵖˡ) "canBecomePrimary", #x⟧ ⤳[under] #x.(Server.canBecomePrimary');
  #[global] Server_set_canBecomePrimary (x : Server.t) y :: ⟦StructFieldSet (Serverⁱᵐᵖˡ) "canBecomePrimary", (#x, #y)⟧ ⤳[under] #(x <|Server.canBecomePrimary' := y|>);
  #[global] Server_get_isPrimary (x : Server.t) :: ⟦StructFieldGet (Serverⁱᵐᵖˡ) "isPrimary", #x⟧ ⤳[under] #x.(Server.isPrimary');
  #[global] Server_set_isPrimary (x : Server.t) y :: ⟦StructFieldSet (Serverⁱᵐᵖˡ) "isPrimary", (#x, #y)⟧ ⤳[under] #(x <|Server.isPrimary' := y|>);
  #[global] Server_get_clerks (x : Server.t) :: ⟦StructFieldGet (Serverⁱᵐᵖˡ) "clerks", #x⟧ ⤳[under] #x.(Server.clerks');
  #[global] Server_set_clerks (x : Server.t) y :: ⟦StructFieldSet (Serverⁱᵐᵖˡ) "clerks", (#x, #y)⟧ ⤳[under] #(x <|Server.clerks' := y|>);
  #[global] Server_get_isPrimary_cond (x : Server.t) :: ⟦StructFieldGet (Serverⁱᵐᵖˡ) "isPrimary_cond", #x⟧ ⤳[under] #x.(Server.isPrimary_cond');
  #[global] Server_set_isPrimary_cond (x : Server.t) y :: ⟦StructFieldSet (Serverⁱᵐᵖˡ) "isPrimary_cond", (#x, #y)⟧ ⤳[under] #(x <|Server.isPrimary_cond' := y|>);
  #[global] Server_get_opAppliedConds (x : Server.t) :: ⟦StructFieldGet (Serverⁱᵐᵖˡ) "opAppliedConds", #x⟧ ⤳[under] #x.(Server.opAppliedConds');
  #[global] Server_set_opAppliedConds (x : Server.t) y :: ⟦StructFieldSet (Serverⁱᵐᵖˡ) "opAppliedConds", (#x, #y)⟧ ⤳[under] #(x <|Server.opAppliedConds' := y|>);
  #[global] Server_get_leaseExpiration (x : Server.t) :: ⟦StructFieldGet (Serverⁱᵐᵖˡ) "leaseExpiration", #x⟧ ⤳[under] #x.(Server.leaseExpiration');
  #[global] Server_set_leaseExpiration (x : Server.t) y :: ⟦StructFieldSet (Serverⁱᵐᵖˡ) "leaseExpiration", (#x, #y)⟧ ⤳[under] #(x <|Server.leaseExpiration' := y|>);
  #[global] Server_get_leaseValid (x : Server.t) :: ⟦StructFieldGet (Serverⁱᵐᵖˡ) "leaseValid", #x⟧ ⤳[under] #x.(Server.leaseValid');
  #[global] Server_set_leaseValid (x : Server.t) y :: ⟦StructFieldSet (Serverⁱᵐᵖˡ) "leaseValid", (#x, #y)⟧ ⤳[under] #(x <|Server.leaseValid' := y|>);
  #[global] Server_get_committedNextIndex (x : Server.t) :: ⟦StructFieldGet (Serverⁱᵐᵖˡ) "committedNextIndex", #x⟧ ⤳[under] #x.(Server.committedNextIndex');
  #[global] Server_set_committedNextIndex (x : Server.t) y :: ⟦StructFieldSet (Serverⁱᵐᵖˡ) "committedNextIndex", (#x, #y)⟧ ⤳[under] #(x <|Server.committedNextIndex' := y|>);
  #[global] Server_get_committedNextIndex_cond (x : Server.t) :: ⟦StructFieldGet (Serverⁱᵐᵖˡ) "committedNextIndex_cond", #x⟧ ⤳[under] #x.(Server.committedNextIndex_cond');
  #[global] Server_set_committedNextIndex_cond (x : Server.t) y :: ⟦StructFieldSet (Serverⁱᵐᵖˡ) "committedNextIndex_cond", (#x, #y)⟧ ⤳[under] #(x <|Server.committedNextIndex_cond' := y|>);
  #[global] Server_get_confCk (x : Server.t) :: ⟦StructFieldGet (Serverⁱᵐᵖˡ) "confCk", #x⟧ ⤳[under] #x.(Server.confCk');
  #[global] Server_set_confCk (x : Server.t) y :: ⟦StructFieldSet (Serverⁱᵐᵖˡ) "confCk", (#x, #y)⟧ ⤳[under] #(x <|Server.confCk' := y|>);
  #[global] Server'ptr_Apply_unfold :: MethodUnfold (go.PointerType (Server)) "Apply" (Server__Applyⁱᵐᵖˡ);
  #[global] Server'ptr_ApplyAsBackup_unfold :: MethodUnfold (go.PointerType (Server)) "ApplyAsBackup" (Server__ApplyAsBackupⁱᵐᵖˡ);
  #[global] Server'ptr_ApplyRoWaitForCommit_unfold :: MethodUnfold (go.PointerType (Server)) "ApplyRoWaitForCommit" (Server__ApplyRoWaitForCommitⁱᵐᵖˡ);
  #[global] Server'ptr_BecomePrimary_unfold :: MethodUnfold (go.PointerType (Server)) "BecomePrimary" (Server__BecomePrimaryⁱᵐᵖˡ);
  #[global] Server'ptr_GetState_unfold :: MethodUnfold (go.PointerType (Server)) "GetState" (Server__GetStateⁱᵐᵖˡ);
  #[global] Server'ptr_IncreaseCommitIndex_unfold :: MethodUnfold (go.PointerType (Server)) "IncreaseCommitIndex" (Server__IncreaseCommitIndexⁱᵐᵖˡ);
  #[global] Server'ptr_Serve_unfold :: MethodUnfold (go.PointerType (Server)) "Serve" (Server__Serveⁱᵐᵖˡ);
  #[global] Server'ptr_SetState_unfold :: MethodUnfold (go.PointerType (Server)) "SetState" (Server__SetStateⁱᵐᵖˡ);
  #[global] Server'ptr_isEpochStale_unfold :: MethodUnfold (go.PointerType (Server)) "isEpochStale" (Server__isEpochStaleⁱᵐᵖˡ);
  #[global] Server'ptr_leaseRenewalThread_unfold :: MethodUnfold (go.PointerType (Server)) "leaseRenewalThread" (Server__leaseRenewalThreadⁱᵐᵖˡ);
  #[global] Server'ptr_sendIncreaseCommitThread_unfold :: MethodUnfold (go.PointerType (Server)) "sendIncreaseCommitThread" (Server__sendIncreaseCommitThreadⁱᵐᵖˡ);
}.

Class Assumptions `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] StateMachine_instance :: StateMachine_Assumptions;
  #[global] SyncStateMachine_instance :: SyncStateMachine_Assumptions;
  #[global] Clerk_instance :: Clerk_Assumptions;
  #[global] Server_instance :: Server_Assumptions;
  #[global] MakeClerk_unfold :: FuncUnfold MakeClerk [] (MakeClerkⁱᵐᵖˡ);
  #[global] MakeServer_unfold :: FuncUnfold MakeServer [] (MakeServerⁱᵐᵖˡ);
  #[global] import_grove_ffi_Assumption :: grove_ffi.Assumptions;
  #[global] import_becomeprimaryargs_gk_Assumption :: becomeprimaryargs_gk.Assumptions;
  #[global] import_reconnectclient_Assumption :: reconnectclient.Assumptions;
  #[global] import_applyasbackupargs_gk_Assumption :: applyasbackupargs_gk.Assumptions;
  #[global] import_applyreply_gk_Assumption :: applyreply_gk.Assumptions;
  #[global] import_err_gk_Assumption :: err_gk.Assumptions;
  #[global] import_getstateargs_gk_Assumption :: getstateargs_gk.Assumptions;
  #[global] import_getstatereply_gk_Assumption :: getstatereply_gk.Assumptions;
  #[global] import_increasecommitargs_gk_Assumption :: increasecommitargs_gk.Assumptions;
  #[global] import_setstateargs_gk_Assumption :: setstateargs_gk.Assumptions;
  #[global] import_log_Assumption :: log.Assumptions;
  #[global] import_sync_Assumption :: sync.Assumptions;
  #[global] import_primitive_Assumption :: primitive.Assumptions;
  #[global] import_std_Assumption :: std.Assumptions;
  #[global] import_urpc_Assumption :: urpc.Assumptions;
  #[global] import_configservice_Assumption :: configservice.Assumptions;
  #[global] import_becomeprimaryargs_gk_Assumption :: becomeprimaryargs_gk.Assumptions;
}.
End replica.
