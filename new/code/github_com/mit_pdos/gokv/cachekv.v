(* autogenerated from github.com/mit-pdos/gokv/cachekv *)
Require Export New.code.github_com.mit_pdos.gokv.cachekv.cachevalue_gk.
Require Export New.code.github_com.mit_pdos.gokv.grove_ffi.
Require Export New.code.github_com.mit_pdos.gokv.kv.
Require Export New.code.sync.

From New.golang Require Import defn.
Definition cachekv : go_string := "github.com/mit-pdos/gokv/cachekv".

From New Require Import grove_prelude.
Module cachekv.

Module CacheKv. Definition id : go_string := "github.com/mit-pdos/gokv/cachekv.CacheKv"%go. End CacheKv.

Section code.


Definition CacheKv : go_type := structT [
  "kv" :: kv.KvCput;
  "mu" :: ptrT;
  "cache" :: mapT stringT cachevalue_gk.S
].

Definition max : go_string := "github.com/mit-pdos/gokv/cachekv.max"%go.

(* go: clerk.go:19:6 *)
Definition maxⁱᵐᵖˡ : val :=
  λ: "a" "b",
    exception_do (let: "b" := (mem.alloc "b") in
    let: "a" := (mem.alloc "a") in
    (if: (![#uint64T] "a") > (![#uint64T] "b")
    then return: (![#uint64T] "a")
    else do:  #());;;
    return: (![#uint64T] "b")).

Definition Make : go_string := "github.com/mit-pdos/gokv/cachekv.Make"%go.

(* go: clerk.go:26:6 *)
Definition Makeⁱᵐᵖˡ : val :=
  λ: "kv",
    exception_do (let: "kv" := (mem.alloc "kv") in
    return: (mem.alloc (let: "$kv" := (![#kv.KvCput] "kv") in
     let: "$mu" := (mem.alloc (type.zero_val #sync.Mutex)) in
     let: "$cache" := (map.make #stringT #cachevalue_gk.S) in
     struct.make #CacheKv [{
       "kv" ::= "$kv";
       "mu" ::= "$mu";
       "cache" ::= "$cache"
     }]))).

(* go: clerk.go:34:19 *)
Definition CacheKv__Getⁱᵐᵖˡ : val :=
  λ: "k" "key",
    exception_do (let: "k" := (mem.alloc "k") in
    let: "key" := (mem.alloc "key") in
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] (struct.field_ref #CacheKv #"mu"%go (![#ptrT] "k")))) #());;;
    let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "cv" := (mem.alloc (type.zero_val #cachevalue_gk.S)) in
    let: ("$ret0", "$ret1") := (map.get (![type.mapT #stringT #cachevalue_gk.S] (struct.field_ref #CacheKv #"cache"%go (![#ptrT] "k"))) (![#stringT] "key")) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("cv" <-[#cachevalue_gk.S] "$r0");;;
    do:  ("ok" <-[#boolT] "$r1");;;
    let: "high" := (mem.alloc (type.zero_val #uint64T)) in
    let: ("$ret0", "$ret1") := ((func_call #grove_ffi.GetTimeRange) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  "$r0";;;
    do:  ("high" <-[#uint64T] "$r1");;;
    (if: (![#boolT] "ok") && ((![#uint64T] "high") < (![#uint64T] (struct.field_ref #cachevalue_gk.S #"L"%go "cv")))
    then
      do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref #CacheKv #"mu"%go (![#ptrT] "k")))) #());;;
      return: (![#stringT] (struct.field_ref #cachevalue_gk.S #"V"%go "cv"))
    else do:  #());;;
    do:  (let: "$a0" := (![type.mapT #stringT #cachevalue_gk.S] (struct.field_ref #CacheKv #"cache"%go (![#ptrT] "k"))) in
    let: "$a1" := (![#stringT] "key") in
    map.delete "$a0" "$a1");;;
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref #CacheKv #"mu"%go (![#ptrT] "k")))) #());;;
    let: "ret" := (mem.alloc (type.zero_val #cachevalue_gk.S)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (string.to_bytes (let: "$a0" := (![#stringT] "key") in
    (interface.get #"Get"%go (![#kv.KvCput] (struct.field_ref #CacheKv #"kv"%go (![#ptrT] "k")))) "$a0")) in
    (func_call #cachevalue_gk.Unmarshal) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("ret" <-[#cachevalue_gk.S] "$r0");;;
    do:  "$r1";;;
    return: (![#stringT] (struct.field_ref #cachevalue_gk.S #"V"%go "ret"))).

(* go: clerk.go:49:19 *)
Definition CacheKv__GetAndCacheⁱᵐᵖˡ : val :=
  λ: "k" "key" "cachetime",
    exception_do (let: "k" := (mem.alloc "k") in
    let: "cachetime" := (mem.alloc "cachetime") in
    let: "key" := (mem.alloc "key") in
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "enc" := (mem.alloc (type.zero_val #stringT)) in
      let: "$r0" := (let: "$a0" := (![#stringT] "key") in
      (interface.get #"Get"%go (![#kv.KvCput] (struct.field_ref #CacheKv #"kv"%go (![#ptrT] "k")))) "$a0") in
      do:  ("enc" <-[#stringT] "$r0");;;
      let: "old" := (mem.alloc (type.zero_val #cachevalue_gk.S)) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (string.to_bytes (![#stringT] "enc")) in
      (func_call #cachevalue_gk.Unmarshal) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("old" <-[#cachevalue_gk.S] "$r0");;;
      do:  "$r1";;;
      let: "latest" := (mem.alloc (type.zero_val #uint64T)) in
      let: ("$ret0", "$ret1") := ((func_call #grove_ffi.GetTimeRange) #()) in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  "$r0";;;
      do:  ("latest" <-[#uint64T] "$r1");;;
      let: "newLeaseExpiration" := (mem.alloc (type.zero_val #uint64T)) in
      let: "$r0" := (let: "$a0" := ((![#uint64T] "latest") + (![#uint64T] "cachetime")) in
      let: "$a1" := (![#uint64T] (struct.field_ref #cachevalue_gk.S #"L"%go "old")) in
      (func_call #max) "$a0" "$a1") in
      do:  ("newLeaseExpiration" <-[#uint64T] "$r0");;;
      let: "resp" := (mem.alloc (type.zero_val #stringT)) in
      let: "$r0" := (let: "$a0" := (![#stringT] "key") in
      let: "$a1" := (![#stringT] "enc") in
      let: "$a2" := (string.from_bytes (let: "$a0" := (slice.make2 #byteT #(W64 0)) in
      let: "$a1" := (let: "$V" := (![#stringT] (struct.field_ref #cachevalue_gk.S #"V"%go "old")) in
      let: "$L" := (![#uint64T] "newLeaseExpiration") in
      struct.make #cachevalue_gk.S [{
        "V" ::= "$V";
        "L" ::= "$L"
      }]) in
      (func_call #cachevalue_gk.Marshal) "$a0" "$a1")) in
      (interface.get #"ConditionalPut"%go (![#kv.KvCput] (struct.field_ref #CacheKv #"kv"%go (![#ptrT] "k")))) "$a0" "$a1" "$a2") in
      do:  ("resp" <-[#stringT] "$r0");;;
      (if: (![#stringT] "resp") = #"ok"%go
      then
        do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] (struct.field_ref #CacheKv #"mu"%go (![#ptrT] "k")))) #());;;
        let: "$r0" := (let: "$V" := (![#stringT] (struct.field_ref #cachevalue_gk.S #"V"%go "old")) in
        let: "$L" := (![#uint64T] "newLeaseExpiration") in
        struct.make #cachevalue_gk.S [{
          "V" ::= "$V";
          "L" ::= "$L"
        }]) in
        do:  (map.insert (![type.mapT #stringT #cachevalue_gk.S] (struct.field_ref #CacheKv #"cache"%go (![#ptrT] "k"))) (![#stringT] "key") "$r0");;;
        break: #()
      else do:  #()));;;
    let: "ret" := (mem.alloc (type.zero_val #stringT)) in
    let: "$r0" := (struct.field_get #cachevalue_gk.S "V" (Fst (map.get (![type.mapT #stringT #cachevalue_gk.S] (struct.field_ref #CacheKv #"cache"%go (![#ptrT] "k"))) (![#stringT] "key")))) in
    do:  ("ret" <-[#stringT] "$r0");;;
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref #CacheKv #"mu"%go (![#ptrT] "k")))) #());;;
    return: (![#stringT] "ret")).

(* go: clerk.go:70:19 *)
Definition CacheKv__Putⁱᵐᵖˡ : val :=
  λ: "k" "key" "val",
    exception_do (let: "k" := (mem.alloc "k") in
    let: "val" := (mem.alloc "val") in
    let: "key" := (mem.alloc "key") in
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "enc" := (mem.alloc (type.zero_val #stringT)) in
      let: "$r0" := (let: "$a0" := (![#stringT] "key") in
      (interface.get #"Get"%go (![#kv.KvCput] (struct.field_ref #CacheKv #"kv"%go (![#ptrT] "k")))) "$a0") in
      do:  ("enc" <-[#stringT] "$r0");;;
      let: "cval" := (mem.alloc (type.zero_val #cachevalue_gk.S)) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (string.to_bytes (![#stringT] "enc")) in
      (func_call #cachevalue_gk.Unmarshal) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("cval" <-[#cachevalue_gk.S] "$r0");;;
      do:  "$r1";;;
      let: "leaseExpiration" := (mem.alloc (type.zero_val #uint64T)) in
      let: "$r0" := (![#uint64T] (struct.field_ref #cachevalue_gk.S #"L"%go "cval")) in
      do:  ("leaseExpiration" <-[#uint64T] "$r0");;;
      let: "earliest" := (mem.alloc (type.zero_val #uint64T)) in
      let: ("$ret0", "$ret1") := ((func_call #grove_ffi.GetTimeRange) #()) in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("earliest" <-[#uint64T] "$r0");;;
      do:  "$r1";;;
      (if: (![#uint64T] "leaseExpiration") > (![#uint64T] "earliest")
      then continue: #()
      else do:  #());;;
      let: "resp" := (mem.alloc (type.zero_val #stringT)) in
      let: "$r0" := (let: "$a0" := (![#stringT] "key") in
      let: "$a1" := (![#stringT] "enc") in
      let: "$a2" := (string.from_bytes (let: "$a0" := (slice.make2 #byteT #(W64 0)) in
      let: "$a1" := (let: "$V" := (![#stringT] "val") in
      let: "$L" := #(W64 0) in
      struct.make #cachevalue_gk.S [{
        "V" ::= "$V";
        "L" ::= "$L"
      }]) in
      (func_call #cachevalue_gk.Marshal) "$a0" "$a1")) in
      (interface.get #"ConditionalPut"%go (![#kv.KvCput] (struct.field_ref #CacheKv #"kv"%go (![#ptrT] "k")))) "$a0" "$a1" "$a2") in
      do:  ("resp" <-[#stringT] "$r0");;;
      (if: (![#stringT] "resp") = #"ok"%go
      then break: #()
      else do:  #()));;;
    return: #()).

Definition vars' : list (go_string * go_type) := [].

Definition functions' : list (go_string * val) := [(max, maxⁱᵐᵖˡ); (Make, Makeⁱᵐᵖˡ)].

Definition msets' : list (go_string * (list (go_string * val))) := [(CacheKv.id, []); (ptrT.id CacheKv.id, [("Get"%go, CacheKv__Getⁱᵐᵖˡ); ("GetAndCache"%go, CacheKv__GetAndCacheⁱᵐᵖˡ); ("Put"%go, CacheKv__Putⁱᵐᵖˡ)])].

#[global] Instance info' : PkgInfo cachekv.cachekv :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [code.sync.sync; code.github_com.mit_pdos.gokv.cachekv.cachevalue_gk.cachevalue_gk; code.github_com.mit_pdos.gokv.grove_ffi.grove_ffi; code.github_com.mit_pdos.gokv.kv.kv];
  |}.

Definition initialize' : val :=
  λ: <>,
    package.init #cachekv.cachekv (λ: <>,
      exception_do (do:  (kv.initialize' #());;;
      do:  (grove_ffi.initialize' #());;;
      do:  (cachevalue_gk.initialize' #());;;
      do:  (sync.initialize' #());;;
      do:  (package.alloc cachekv.cachekv #()))
      ).

End code.
End cachekv.
