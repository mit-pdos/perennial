(* autogenerated from github.com/mit-pdos/gokv/cachekv *)
Require Export New.code.sync.
Require Export New.code.github_com.mit_pdos.gokv.cachekv.cachevalue_gk.
Require Export New.code.github_com.mit_pdos.gokv.grove_ffi.
Require Export New.code.github_com.mit_pdos.gokv.kv.
From New.golang Require Import defn.
From New Require Import grove_prelude.
Module pkg_id.
Definition cachekv : go_string := "github.com/mit-pdos/gokv/cachekv".

End pkg_id.
Export pkg_id.
Module cachekv.

Definition CacheKv {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/mit-pdos/gokv/cachekv.CacheKv"%go [].

Definition max {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/gokv/cachekv.max"%go.

Definition Make {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/gokv/cachekv.Make"%go.

(* go: clerk.go:19:6 *)
Definition maxⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "a" "b",
    exception_do (let: "b" := (GoAlloc go.uint64 "b") in
    let: "a" := (GoAlloc go.uint64 "a") in
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "a") >⟨go.uint64⟩ (![go.uint64] "b"))
    then return: (![go.uint64] "a")
    else do:  #());;;
    return: (![go.uint64] "b")).

(* go: clerk.go:26:6 *)
Definition Makeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "kv",
    exception_do (let: "kv" := (GoAlloc kv.KvCput "kv") in
    return: (GoAlloc CacheKv (CompositeLiteral CacheKv (LiteralValue [KeyedElement (Some (KeyField "kv"%go)) (ElementExpression kv.KvCput (![kv.KvCput] "kv")); KeyedElement (Some (KeyField "mu"%go)) (ElementExpression (go.PointerType sync.Mutex) (GoAlloc sync.Mutex (GoZeroVal sync.Mutex #()))); KeyedElement (Some (KeyField "cache"%go)) (ElementExpression (go.MapType go.string cachevalue_gk.S) ((FuncResolve go.make1 [go.MapType go.string cachevalue_gk.S] #()) #()))])))).

(* go: clerk.go:34:19 *)
Definition CacheKv__Getⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "k" "key",
    exception_do (let: "k" := (GoAlloc (go.PointerType CacheKv) "k") in
    let: "key" := (GoAlloc go.string "key") in
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] (StructFieldRef CacheKv "mu"%go (![go.PointerType CacheKv] "k")))) #());;;
    let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "cv" := (GoAlloc cachevalue_gk.S (GoZeroVal cachevalue_gk.S #())) in
    let: ("$ret0", "$ret1") := (map.lookup2 go.string cachevalue_gk.S (![go.MapType go.string cachevalue_gk.S] (StructFieldRef CacheKv "cache"%go (![go.PointerType CacheKv] "k"))) (![go.string] "key")) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("cv" <-[cachevalue_gk.S] "$r0");;;
    do:  ("ok" <-[go.bool] "$r1");;;
    let: "high" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: ("$ret0", "$ret1") := ((FuncResolve grove_ffi.GetTimeRange [] #()) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  "$r0";;;
    do:  ("high" <-[go.uint64] "$r1");;;
    (if: (![go.bool] "ok") && ((![go.uint64] "high") <⟨go.uint64⟩ (![go.uint64] (StructFieldRef cachevalue_gk.S "L"%go "cv")))
    then
      do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef CacheKv "mu"%go (![go.PointerType CacheKv] "k")))) #());;;
      return: (![go.string] (StructFieldRef cachevalue_gk.S "V"%go "cv"))
    else do:  #());;;
    do:  (let: "$a0" := (![go.MapType go.string cachevalue_gk.S] (StructFieldRef CacheKv "cache"%go (![go.PointerType CacheKv] "k"))) in
    let: "$a1" := (![go.string] "key") in
    (FuncResolve go.delete [go.MapType go.string cachevalue_gk.S] #()) "$a0" "$a1");;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef CacheKv "mu"%go (![go.PointerType CacheKv] "k")))) #());;;
    let: "ret" := (GoAlloc cachevalue_gk.S (GoZeroVal cachevalue_gk.S #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (Convert go.string (go.SliceType go.byte) (let: "$a0" := (![go.string] "key") in
    (MethodResolve kv.KvCput "Get"%go (![kv.KvCput] (StructFieldRef CacheKv "kv"%go (![go.PointerType CacheKv] "k")))) "$a0")) in
    (FuncResolve cachevalue_gk.Unmarshal [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("ret" <-[cachevalue_gk.S] "$r0");;;
    do:  "$r1";;;
    return: (![go.string] (StructFieldRef cachevalue_gk.S "V"%go "ret"))).

(* go: clerk.go:49:19 *)
Definition CacheKv__GetAndCacheⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "k" "key" "cachetime",
    exception_do (let: "k" := (GoAlloc (go.PointerType CacheKv) "k") in
    let: "cachetime" := (GoAlloc go.uint64 "cachetime") in
    let: "key" := (GoAlloc go.string "key") in
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "enc" := (GoAlloc go.string (GoZeroVal go.string #())) in
      let: "$r0" := (let: "$a0" := (![go.string] "key") in
      (MethodResolve kv.KvCput "Get"%go (![kv.KvCput] (StructFieldRef CacheKv "kv"%go (![go.PointerType CacheKv] "k")))) "$a0") in
      do:  ("enc" <-[go.string] "$r0");;;
      let: "old" := (GoAlloc cachevalue_gk.S (GoZeroVal cachevalue_gk.S #())) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (Convert go.string (go.SliceType go.byte) (![go.string] "enc")) in
      (FuncResolve cachevalue_gk.Unmarshal [] #()) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("old" <-[cachevalue_gk.S] "$r0");;;
      do:  "$r1";;;
      let: "latest" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: ("$ret0", "$ret1") := ((FuncResolve grove_ffi.GetTimeRange [] #()) #()) in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  "$r0";;;
      do:  ("latest" <-[go.uint64] "$r1");;;
      let: "newLeaseExpiration" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: "$r0" := (let: "$a0" := ((![go.uint64] "latest") +⟨go.uint64⟩ (![go.uint64] "cachetime")) in
      let: "$a1" := (![go.uint64] (StructFieldRef cachevalue_gk.S "L"%go "old")) in
      (FuncResolve max [] #()) "$a0" "$a1") in
      do:  ("newLeaseExpiration" <-[go.uint64] "$r0");;;
      let: "resp" := (GoAlloc go.string (GoZeroVal go.string #())) in
      let: "$r0" := (let: "$a0" := (![go.string] "key") in
      let: "$a1" := (![go.string] "enc") in
      let: "$a2" := (Convert (go.SliceType go.byte) go.string (let: "$a0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 0)) in
      let: "$a1" := (CompositeLiteral cachevalue_gk.S (LiteralValue [KeyedElement (Some (KeyField "V"%go)) (ElementExpression go.string (![go.string] (StructFieldRef cachevalue_gk.S "V"%go "old"))); KeyedElement (Some (KeyField "L"%go)) (ElementExpression go.uint64 (![go.uint64] "newLeaseExpiration"))])) in
      (FuncResolve cachevalue_gk.Marshal [] #()) "$a0" "$a1")) in
      (MethodResolve kv.KvCput "ConditionalPut"%go (![kv.KvCput] (StructFieldRef CacheKv "kv"%go (![go.PointerType CacheKv] "k")))) "$a0" "$a1" "$a2") in
      do:  ("resp" <-[go.string] "$r0");;;
      (if: Convert go.untyped_bool go.bool ((![go.string] "resp") =⟨go.string⟩ #"ok"%go)
      then
        do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] (StructFieldRef CacheKv "mu"%go (![go.PointerType CacheKv] "k")))) #());;;
        let: "$r0" := (CompositeLiteral cachevalue_gk.S (LiteralValue [KeyedElement (Some (KeyField "V"%go)) (ElementExpression go.string (![go.string] (StructFieldRef cachevalue_gk.S "V"%go "old"))); KeyedElement (Some (KeyField "L"%go)) (ElementExpression go.uint64 (![go.uint64] "newLeaseExpiration"))])) in
        do:  (map.insert go.string (![go.MapType go.string cachevalue_gk.S] (StructFieldRef CacheKv "cache"%go (![go.PointerType CacheKv] "k"))) (![go.string] "key") "$r0");;;
        break: #()
      else do:  #()));;;
    let: "ret" := (GoAlloc go.string (GoZeroVal go.string #())) in
    let: "$r0" := (StructFieldGet cachevalue_gk.S "V" (map.lookup1 go.string cachevalue_gk.S (![go.MapType go.string cachevalue_gk.S] (StructFieldRef CacheKv "cache"%go (![go.PointerType CacheKv] "k"))) (![go.string] "key"))) in
    do:  ("ret" <-[go.string] "$r0");;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef CacheKv "mu"%go (![go.PointerType CacheKv] "k")))) #());;;
    return: (![go.string] "ret")).

(* go: clerk.go:70:19 *)
Definition CacheKv__Putⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "k" "key" "val",
    exception_do (let: "k" := (GoAlloc (go.PointerType CacheKv) "k") in
    let: "val" := (GoAlloc go.string "val") in
    let: "key" := (GoAlloc go.string "key") in
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "enc" := (GoAlloc go.string (GoZeroVal go.string #())) in
      let: "$r0" := (let: "$a0" := (![go.string] "key") in
      (MethodResolve kv.KvCput "Get"%go (![kv.KvCput] (StructFieldRef CacheKv "kv"%go (![go.PointerType CacheKv] "k")))) "$a0") in
      do:  ("enc" <-[go.string] "$r0");;;
      let: "cval" := (GoAlloc cachevalue_gk.S (GoZeroVal cachevalue_gk.S #())) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (Convert go.string (go.SliceType go.byte) (![go.string] "enc")) in
      (FuncResolve cachevalue_gk.Unmarshal [] #()) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("cval" <-[cachevalue_gk.S] "$r0");;;
      do:  "$r1";;;
      let: "leaseExpiration" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: "$r0" := (![go.uint64] (StructFieldRef cachevalue_gk.S "L"%go "cval")) in
      do:  ("leaseExpiration" <-[go.uint64] "$r0");;;
      let: "earliest" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: ("$ret0", "$ret1") := ((FuncResolve grove_ffi.GetTimeRange [] #()) #()) in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("earliest" <-[go.uint64] "$r0");;;
      do:  "$r1";;;
      (if: Convert go.untyped_bool go.bool ((![go.uint64] "leaseExpiration") >⟨go.uint64⟩ (![go.uint64] "earliest"))
      then continue: #()
      else do:  #());;;
      let: "resp" := (GoAlloc go.string (GoZeroVal go.string #())) in
      let: "$r0" := (let: "$a0" := (![go.string] "key") in
      let: "$a1" := (![go.string] "enc") in
      let: "$a2" := (Convert (go.SliceType go.byte) go.string (let: "$a0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 0)) in
      let: "$a1" := (CompositeLiteral cachevalue_gk.S (LiteralValue [KeyedElement (Some (KeyField "V"%go)) (ElementExpression go.string (![go.string] "val")); KeyedElement (Some (KeyField "L"%go)) (ElementExpression go.uint64 #(W64 0))])) in
      (FuncResolve cachevalue_gk.Marshal [] #()) "$a0" "$a1")) in
      (MethodResolve kv.KvCput "ConditionalPut"%go (![kv.KvCput] (StructFieldRef CacheKv "kv"%go (![go.PointerType CacheKv] "k")))) "$a0" "$a1" "$a2") in
      do:  ("resp" <-[go.string] "$r0");;;
      (if: Convert go.untyped_bool go.bool ((![go.string] "resp") =⟨go.string⟩ #"ok"%go)
      then break: #()
      else do:  #()));;;
    return: #()).

#[global] Instance info' : PkgInfo pkg_id.cachekv :=
{|
  pkg_imported_pkgs := [code.sync.pkg_id.sync; code.github_com.mit_pdos.gokv.cachekv.cachevalue_gk.pkg_id.cachevalue_gk; code.github_com.mit_pdos.gokv.grove_ffi.pkg_id.grove_ffi; code.github_com.mit_pdos.gokv.kv.pkg_id.kv]
|}.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init pkg_id.cachekv (λ: <>,
      exception_do (do:  (kv.initialize' #());;;
      do:  (grove_ffi.initialize' #());;;
      do:  (cachevalue_gk.initialize' #());;;
      do:  (sync.initialize' #()))
      ).

Module CacheKv.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  kv' : kv.KvCput.t;
  mu' : loc;
  cache' : loc;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End CacheKv.

Definition CacheKv'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "kv"%go kv.KvCput);
  (go.FieldDecl "mu"%go (go.PointerType sync.Mutex));
  (go.FieldDecl "cache"%go (go.MapType go.string cachevalue_gk.S))
].
Program Definition CacheKv'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (CacheKv'fds_unsealed).
Global Instance equals_unfold_CacheKv {ext : ffi_syntax} {go_gctx : GoGlobalContext} : CacheKv'fds =→ CacheKv'fds_unsealed.
Proof. rewrite /CacheKv'fds seal_eq //. Qed.

Definition CacheKvⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (CacheKv'fds).

Class CacheKv_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] CacheKv_type_repr  :: go.TypeReprUnderlying CacheKvⁱᵐᵖˡ CacheKv.t;
  #[global] CacheKv_underlying :: (CacheKv) <u (CacheKvⁱᵐᵖˡ);
  #[global] CacheKv_get_kv (x : CacheKv.t) :: ⟦StructFieldGet (CacheKvⁱᵐᵖˡ) "kv", #x⟧ ⤳[under] #x.(CacheKv.kv');
  #[global] CacheKv_set_kv (x : CacheKv.t) y :: ⟦StructFieldSet (CacheKvⁱᵐᵖˡ) "kv", (#x, #y)⟧ ⤳[under] #(x <|CacheKv.kv' := y|>);
  #[global] CacheKv_get_mu (x : CacheKv.t) :: ⟦StructFieldGet (CacheKvⁱᵐᵖˡ) "mu", #x⟧ ⤳[under] #x.(CacheKv.mu');
  #[global] CacheKv_set_mu (x : CacheKv.t) y :: ⟦StructFieldSet (CacheKvⁱᵐᵖˡ) "mu", (#x, #y)⟧ ⤳[under] #(x <|CacheKv.mu' := y|>);
  #[global] CacheKv_get_cache (x : CacheKv.t) :: ⟦StructFieldGet (CacheKvⁱᵐᵖˡ) "cache", #x⟧ ⤳[under] #x.(CacheKv.cache');
  #[global] CacheKv_set_cache (x : CacheKv.t) y :: ⟦StructFieldSet (CacheKvⁱᵐᵖˡ) "cache", (#x, #y)⟧ ⤳[under] #(x <|CacheKv.cache' := y|>);
  #[global] CacheKv'ptr_Get_unfold :: MethodUnfold (go.PointerType (CacheKv)) "Get" (CacheKv__Getⁱᵐᵖˡ);
  #[global] CacheKv'ptr_GetAndCache_unfold :: MethodUnfold (go.PointerType (CacheKv)) "GetAndCache" (CacheKv__GetAndCacheⁱᵐᵖˡ);
  #[global] CacheKv'ptr_Put_unfold :: MethodUnfold (go.PointerType (CacheKv)) "Put" (CacheKv__Putⁱᵐᵖˡ);
}.

Class Assumptions `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] CacheKv_instance :: CacheKv_Assumptions;
  #[global] max_unfold :: FuncUnfold max [] (maxⁱᵐᵖˡ);
  #[global] Make_unfold :: FuncUnfold Make [] (Makeⁱᵐᵖˡ);
  #[global] import_sync_Assumption :: sync.Assumptions;
  #[global] import_cachevalue_gk_Assumption :: cachevalue_gk.Assumptions;
  #[global] import_grove_ffi_Assumption :: grove_ffi.Assumptions;
  #[global] import_kv_Assumption :: kv.Assumptions;
}.
End cachekv.
