(* autogenerated from github.com/mit-pdos/gokv/bank *)
Require Export New.code.github_com.goose_lang.primitive.
Require Export New.code.github_com.mit_pdos.gokv.kv.
Require Export New.code.github_com.mit_pdos.gokv.lockservice.
Require Export New.code.github_com.tchajed.marshal.
From New.golang Require Import defn.
Module pkg_id.
Definition bank : go_string := "github.com/mit-pdos/gokv/bank".

End pkg_id.
Export pkg_id.
Module bank.

Definition BankClerk {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/mit-pdos/gokv/bank.BankClerk"%go [].

Definition BAL_TOTAL {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 1000).

Definition acquire_two_good {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/gokv/bank.acquire_two_good"%go.

Definition acquire_two {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/gokv/bank.acquire_two"%go.

Definition release_two {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/gokv/bank.release_two"%go.

Definition encodeInt {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/gokv/bank.encodeInt"%go.

Definition decodeInt {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/gokv/bank.decodeInt"%go.

Definition MakeBankClerkSlice {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/gokv/bank.MakeBankClerkSlice"%go.

Definition MakeBankClerk {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/gokv/bank.MakeBankClerk"%go.

(* go: bank.go:19:6 *)
Definition acquire_two_goodⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "lck" "l1" "l2",
    exception_do (let: "l2" := (GoAlloc go.string "l2") in
    let: "l1" := (GoAlloc go.string "l1") in
    let: "lck" := (GoAlloc (go.PointerType lockservice.LockClerk) "lck") in
    (if: Convert go.untyped_bool go.bool ((![go.string] "l1") <⟨go.string⟩ (![go.string] "l2"))
    then
      do:  (let: "$a0" := (![go.string] "l1") in
      (MethodResolve (go.PointerType lockservice.LockClerk) "Lock"%go (![go.PointerType lockservice.LockClerk] "lck")) "$a0");;;
      do:  (let: "$a0" := (![go.string] "l2") in
      (MethodResolve (go.PointerType lockservice.LockClerk) "Lock"%go (![go.PointerType lockservice.LockClerk] "lck")) "$a0")
    else
      do:  (let: "$a0" := (![go.string] "l2") in
      (MethodResolve (go.PointerType lockservice.LockClerk) "Lock"%go (![go.PointerType lockservice.LockClerk] "lck")) "$a0");;;
      do:  (let: "$a0" := (![go.string] "l1") in
      (MethodResolve (go.PointerType lockservice.LockClerk) "Lock"%go (![go.PointerType lockservice.LockClerk] "lck")) "$a0"));;;
    return: (#());;;
    return: #()).

(* go: bank.go:30:6 *)
Definition acquire_twoⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "lck" "l1" "l2",
    exception_do (let: "l2" := (GoAlloc go.string "l2") in
    let: "l1" := (GoAlloc go.string "l1") in
    let: "lck" := (GoAlloc (go.PointerType lockservice.LockClerk) "lck") in
    do:  (let: "$a0" := (![go.string] "l1") in
    (MethodResolve (go.PointerType lockservice.LockClerk) "Lock"%go (![go.PointerType lockservice.LockClerk] "lck")) "$a0");;;
    do:  (let: "$a0" := (![go.string] "l2") in
    (MethodResolve (go.PointerType lockservice.LockClerk) "Lock"%go (![go.PointerType lockservice.LockClerk] "lck")) "$a0");;;
    return: (#());;;
    return: #()).

(* go: bank.go:37:6 *)
Definition release_twoⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "lck" "l1" "l2",
    exception_do (let: "l2" := (GoAlloc go.string "l2") in
    let: "l1" := (GoAlloc go.string "l1") in
    let: "lck" := (GoAlloc (go.PointerType lockservice.LockClerk) "lck") in
    do:  (let: "$a0" := (![go.string] "l1") in
    (MethodResolve (go.PointerType lockservice.LockClerk) "Unlock"%go (![go.PointerType lockservice.LockClerk] "lck")) "$a0");;;
    do:  (let: "$a0" := (![go.string] "l2") in
    (MethodResolve (go.PointerType lockservice.LockClerk) "Unlock"%go (![go.PointerType lockservice.LockClerk] "lck")) "$a0");;;
    return: (#());;;
    return: #()).

(* go: bank.go:43:6 *)
Definition encodeIntⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "a",
    exception_do (let: "a" := (GoAlloc go.uint64 "a") in
    return: (Convert (go.SliceType go.byte) go.string (let: "$a0" := (Convert go.untyped_nil (go.SliceType go.byte) UntypedNil) in
     let: "$a1" := (![go.uint64] "a") in
     (FuncResolve marshal.WriteInt [] #()) "$a0" "$a1"))).

(* go: bank.go:47:6 *)
Definition decodeIntⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "a",
    exception_do (let: "a" := (GoAlloc go.string "a") in
    let: "v" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (Convert go.string (go.SliceType go.byte) (![go.string] "a")) in
    (FuncResolve marshal.ReadInt [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("v" <-[go.uint64] "$r0");;;
    do:  "$r1";;;
    return: (![go.uint64] "v")).

(* Requires that the account numbers are smaller than num_accounts
   If account balance in acc_from is at least amount, transfer amount to acc_to

   go: bank.go:54:23 *)
Definition BankClerk__transfer_internalⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "bck" "acc_from" "acc_to" "amount",
    exception_do (let: "bck" := (GoAlloc (go.PointerType BankClerk) "bck") in
    let: "amount" := (GoAlloc go.uint64 "amount") in
    let: "acc_to" := (GoAlloc go.string "acc_to") in
    let: "acc_from" := (GoAlloc go.string "acc_from") in
    do:  (let: "$a0" := (![go.PointerType lockservice.LockClerk] (StructFieldRef BankClerk "lck"%go (![go.PointerType BankClerk] "bck"))) in
    let: "$a1" := (![go.string] "acc_from") in
    let: "$a2" := (![go.string] "acc_to") in
    (FuncResolve acquire_two [] #()) "$a0" "$a1" "$a2");;;
    let: "old_amount" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (let: "$a0" := (let: "$a0" := (![go.string] "acc_from") in
    (MethodResolve kv.Kv "Get"%go (![kv.Kv] (StructFieldRef BankClerk "kvck"%go (![go.PointerType BankClerk] "bck")))) "$a0") in
    (FuncResolve decodeInt [] #()) "$a0") in
    do:  ("old_amount" <-[go.uint64] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "old_amount") ≥⟨go.uint64⟩ (![go.uint64] "amount"))
    then
      do:  (let: "$a0" := (![go.string] "acc_from") in
      let: "$a1" := (let: "$a0" := ((![go.uint64] "old_amount") -⟨go.uint64⟩ (![go.uint64] "amount")) in
      (FuncResolve encodeInt [] #()) "$a0") in
      (MethodResolve kv.Kv "Put"%go (![kv.Kv] (StructFieldRef BankClerk "kvck"%go (![go.PointerType BankClerk] "bck")))) "$a0" "$a1");;;
      do:  (let: "$a0" := (![go.string] "acc_to") in
      let: "$a1" := (let: "$a0" := ((let: "$a0" := (let: "$a0" := (![go.string] "acc_to") in
      (MethodResolve kv.Kv "Get"%go (![kv.Kv] (StructFieldRef BankClerk "kvck"%go (![go.PointerType BankClerk] "bck")))) "$a0") in
      (FuncResolve decodeInt [] #()) "$a0") +⟨go.uint64⟩ (![go.uint64] "amount")) in
      (FuncResolve encodeInt [] #()) "$a0") in
      (MethodResolve kv.Kv "Put"%go (![kv.Kv] (StructFieldRef BankClerk "kvck"%go (![go.PointerType BankClerk] "bck")))) "$a0" "$a1")
    else do:  #());;;
    do:  (let: "$a0" := (![go.PointerType lockservice.LockClerk] (StructFieldRef BankClerk "lck"%go (![go.PointerType BankClerk] "bck"))) in
    let: "$a1" := (![go.string] "acc_from") in
    let: "$a2" := (![go.string] "acc_to") in
    (FuncResolve release_two [] #()) "$a0" "$a1" "$a2");;;
    return: #()).

(* go: bank.go:65:23 *)
Definition BankClerk__SimpleTransferⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "bck" <>,
    exception_do (let: "bck" := (GoAlloc (go.PointerType BankClerk) "bck") in
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "src" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: "$r0" := ((FuncResolve primitive.RandomUint64 [] #()) #()) in
      do:  ("src" <-[go.uint64] "$r0");;;
      let: "dst" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: "$r0" := ((FuncResolve primitive.RandomUint64 [] #()) #()) in
      do:  ("dst" <-[go.uint64] "$r0");;;
      let: "amount" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: "$r0" := ((FuncResolve primitive.RandomUint64 [] #()) #()) in
      do:  ("amount" <-[go.uint64] "$r0");;;
      (if: Convert go.untyped_bool go.bool ((((![go.uint64] "src") <⟨go.uint64⟩ (Convert go.int go.uint64 (let: "$a0" := (![go.SliceType go.string] (StructFieldRef BankClerk "accts"%go (![go.PointerType BankClerk] "bck"))) in
      (FuncResolve go.len [go.SliceType go.string] #()) "$a0"))) && ((![go.uint64] "dst") <⟨go.uint64⟩ (Convert go.int go.uint64 (let: "$a0" := (![go.SliceType go.string] (StructFieldRef BankClerk "accts"%go (![go.PointerType BankClerk] "bck"))) in
      (FuncResolve go.len [go.SliceType go.string] #()) "$a0")))) && ((![go.uint64] "src") ≠⟨go.uint64⟩ (![go.uint64] "dst")))
      then
        do:  (let: "$a0" := (![go.string] (IndexRef (go.SliceType go.string) (![go.SliceType go.string] (StructFieldRef BankClerk "accts"%go (![go.PointerType BankClerk] "bck")), Convert go.uint64 go.int (![go.uint64] "src")))) in
        let: "$a1" := (![go.string] (IndexRef (go.SliceType go.string) (![go.SliceType go.string] (StructFieldRef BankClerk "accts"%go (![go.PointerType BankClerk] "bck")), Convert go.uint64 go.int (![go.uint64] "dst")))) in
        let: "$a2" := (![go.uint64] "amount") in
        (MethodResolve (go.PointerType BankClerk) "transfer_internal"%go (![go.PointerType BankClerk] "bck")) "$a0" "$a1" "$a2")
      else do:  #()));;;
    return: #()).

(* go: bank.go:76:23 *)
Definition BankClerk__get_totalⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "bck" <>,
    exception_do (let: "bck" := (GoAlloc (go.PointerType BankClerk) "bck") in
    let: "sum" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$range" := (![go.SliceType go.string] (StructFieldRef BankClerk "accts"%go (![go.PointerType BankClerk] "bck"))) in
    (let: "acct" := (GoAlloc go.string (GoZeroVal go.string #())) in
    slice.for_range go.string "$range" (λ: "$key" "$value",
      do:  ("acct" <-[go.string] "$value");;;
      do:  "$key";;;
      do:  (let: "$a0" := (![go.string] "acct") in
      (MethodResolve (go.PointerType lockservice.LockClerk) "Lock"%go (![go.PointerType lockservice.LockClerk] (StructFieldRef BankClerk "lck"%go (![go.PointerType BankClerk] "bck")))) "$a0");;;
      let: "$r0" := ((![go.uint64] "sum") +⟨go.uint64⟩ (let: "$a0" := (let: "$a0" := (![go.string] "acct") in
      (MethodResolve kv.Kv "Get"%go (![kv.Kv] (StructFieldRef BankClerk "kvck"%go (![go.PointerType BankClerk] "bck")))) "$a0") in
      (FuncResolve decodeInt [] #()) "$a0")) in
      do:  ("sum" <-[go.uint64] "$r0")));;;
    let: "$range" := (![go.SliceType go.string] (StructFieldRef BankClerk "accts"%go (![go.PointerType BankClerk] "bck"))) in
    (let: "acct" := (GoAlloc go.string (GoZeroVal go.string #())) in
    slice.for_range go.string "$range" (λ: "$key" "$value",
      do:  ("acct" <-[go.string] "$value");;;
      do:  "$key";;;
      do:  (let: "$a0" := (![go.string] "acct") in
      (MethodResolve (go.PointerType lockservice.LockClerk) "Unlock"%go (![go.PointerType lockservice.LockClerk] (StructFieldRef BankClerk "lck"%go (![go.PointerType BankClerk] "bck")))) "$a0")));;;
    return: (![go.uint64] "sum")).

(* go: bank.go:92:23 *)
Definition BankClerk__SimpleAuditⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "bck" <>,
    exception_do (let: "bck" := (GoAlloc (go.PointerType BankClerk) "bck") in
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (if: Convert go.untyped_bool go.bool (((MethodResolve (go.PointerType BankClerk) "get_total"%go (![go.PointerType BankClerk] "bck")) #()) ≠⟨go.uint64⟩ BAL_TOTAL)
      then
        do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"Balance total invariant violated"%go) in
        (FuncResolve go.panic [] #()) "$a0")
      else do:  #()));;;
    return: #()).

(* go: bank.go:100:6 *)
Definition MakeBankClerkSliceⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "lck" "kv" "init_flag" "accts",
    exception_do (let: "accts" := (GoAlloc (go.SliceType go.string) "accts") in
    let: "init_flag" := (GoAlloc go.string "init_flag") in
    let: "kv" := (GoAlloc kv.Kv "kv") in
    let: "lck" := (GoAlloc (go.PointerType lockservice.LockClerk) "lck") in
    let: "bck" := (GoAlloc (go.PointerType BankClerk) (GoZeroVal (go.PointerType BankClerk) #())) in
    let: "$r0" := (GoAlloc BankClerk (GoZeroVal BankClerk #())) in
    do:  ("bck" <-[go.PointerType BankClerk] "$r0");;;
    let: "$r0" := (![go.PointerType lockservice.LockClerk] "lck") in
    do:  ((StructFieldRef BankClerk "lck"%go (![go.PointerType BankClerk] "bck")) <-[go.PointerType lockservice.LockClerk] "$r0");;;
    let: "$r0" := (![kv.Kv] "kv") in
    do:  ((StructFieldRef BankClerk "kvck"%go (![go.PointerType BankClerk] "bck")) <-[kv.Kv] "$r0");;;
    let: "$r0" := (![go.SliceType go.string] "accts") in
    do:  ((StructFieldRef BankClerk "accts"%go (![go.PointerType BankClerk] "bck")) <-[go.SliceType go.string] "$r0");;;
    do:  (let: "$a0" := (![go.string] "init_flag") in
    (MethodResolve (go.PointerType lockservice.LockClerk) "Lock"%go (![go.PointerType lockservice.LockClerk] (StructFieldRef BankClerk "lck"%go (![go.PointerType BankClerk] "bck")))) "$a0");;;
    (if: Convert go.untyped_bool go.bool ((let: "$a0" := (![go.string] "init_flag") in
    (MethodResolve kv.Kv "Get"%go (![kv.Kv] (StructFieldRef BankClerk "kvck"%go (![go.PointerType BankClerk] "bck")))) "$a0") =⟨go.string⟩ #""%go)
    then
      do:  (let: "$a0" := (![go.string] (IndexRef (go.SliceType go.string) (![go.SliceType go.string] (StructFieldRef BankClerk "accts"%go (![go.PointerType BankClerk] "bck")), #(W64 0)))) in
      let: "$a1" := (let: "$a0" := BAL_TOTAL in
      (FuncResolve encodeInt [] #()) "$a0") in
      (MethodResolve kv.Kv "Put"%go (![kv.Kv] (StructFieldRef BankClerk "kvck"%go (![go.PointerType BankClerk] "bck")))) "$a0" "$a1");;;
      let: "$range" := (let: "$s" := (![go.SliceType go.string] (StructFieldRef BankClerk "accts"%go (![go.PointerType BankClerk] "bck"))) in
      Slice (go.SliceType go.string) ("$s", #(W64 1), FuncResolve go.len [go.SliceType go.string] #() (![go.SliceType go.string] (StructFieldRef BankClerk "accts"%go (![go.PointerType BankClerk] "bck"))))) in
      (let: "acct" := (GoAlloc go.string (GoZeroVal go.string #())) in
      slice.for_range go.string "$range" (λ: "$key" "$value",
        do:  ("acct" <-[go.string] "$value");;;
        do:  "$key";;;
        do:  (let: "$a0" := (![go.string] "acct") in
        let: "$a1" := (let: "$a0" := #(W64 0) in
        (FuncResolve encodeInt [] #()) "$a0") in
        (MethodResolve kv.Kv "Put"%go (![kv.Kv] (StructFieldRef BankClerk "kvck"%go (![go.PointerType BankClerk] "bck")))) "$a0" "$a1")));;;
      do:  (let: "$a0" := (![go.string] "init_flag") in
      let: "$a1" := #"1"%go in
      (MethodResolve kv.Kv "Put"%go (![kv.Kv] (StructFieldRef BankClerk "kvck"%go (![go.PointerType BankClerk] "bck")))) "$a0" "$a1")
    else do:  #());;;
    do:  (let: "$a0" := (![go.string] "init_flag") in
    (MethodResolve (go.PointerType lockservice.LockClerk) "Unlock"%go (![go.PointerType lockservice.LockClerk] (StructFieldRef BankClerk "lck"%go (![go.PointerType BankClerk] "bck")))) "$a0");;;
    return: (![go.PointerType BankClerk] "bck")).

(* go: bank.go:120:6 *)
Definition MakeBankClerkⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "lck" "kv" "init_flag" "acc1" "acc2",
    exception_do (let: "acc2" := (GoAlloc go.string "acc2") in
    let: "acc1" := (GoAlloc go.string "acc1") in
    let: "init_flag" := (GoAlloc go.string "init_flag") in
    let: "kv" := (GoAlloc kv.Kv "kv") in
    let: "lck" := (GoAlloc (go.PointerType lockservice.LockClerk) "lck") in
    let: "accts" := (GoAlloc (go.SliceType go.string) (GoZeroVal (go.SliceType go.string) #())) in
    let: "$r0" := (let: "$a0" := (![go.SliceType go.string] "accts") in
    let: "$a1" := ((let: "$sl0" := (![go.string] "acc1") in
    CompositeLiteral (go.SliceType go.string) (LiteralValue [KeyedElement None (ElementExpression go.string "$sl0")]))) in
    (FuncResolve go.append [go.SliceType go.string] #()) "$a0" "$a1") in
    do:  ("accts" <-[go.SliceType go.string] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.string] "accts") in
    let: "$a1" := ((let: "$sl0" := (![go.string] "acc2") in
    CompositeLiteral (go.SliceType go.string) (LiteralValue [KeyedElement None (ElementExpression go.string "$sl0")]))) in
    (FuncResolve go.append [go.SliceType go.string] #()) "$a0" "$a1") in
    do:  ("accts" <-[go.SliceType go.string] "$r0");;;
    return: (let: "$a0" := (![go.PointerType lockservice.LockClerk] "lck") in
     let: "$a1" := (![kv.Kv] "kv") in
     let: "$a2" := (![go.string] "init_flag") in
     let: "$a3" := (![go.SliceType go.string] "accts") in
     (FuncResolve MakeBankClerkSlice [] #()) "$a0" "$a1" "$a2" "$a3")).

#[global] Instance info' : PkgInfo pkg_id.bank :=
{|
  pkg_imported_pkgs := [code.github_com.goose_lang.primitive.pkg_id.primitive; code.github_com.mit_pdos.gokv.kv.pkg_id.kv; code.github_com.mit_pdos.gokv.lockservice.pkg_id.lockservice; code.github_com.tchajed.marshal.pkg_id.marshal]
|}.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init pkg_id.bank (λ: <>,
      exception_do (do:  (marshal.initialize' #());;;
      do:  (lockservice.initialize' #());;;
      do:  (kv.initialize' #());;;
      do:  (primitive.initialize' #()))
      ).

Module BankClerk.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  lck' : loc;
  kvck' : kv.Kv.t;
  accts' : slice.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End BankClerk.

Definition BankClerk'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "lck"%go (go.PointerType lockservice.LockClerk));
  (go.FieldDecl "kvck"%go kv.Kv);
  (go.FieldDecl "accts"%go (go.SliceType go.string))
].
Program Definition BankClerk'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (BankClerk'fds_unsealed).
Global Instance equals_unfold_BankClerk {ext : ffi_syntax} {go_gctx : GoGlobalContext} : BankClerk'fds =→ BankClerk'fds_unsealed.
Proof. rewrite /BankClerk'fds seal_eq //. Qed.

Definition BankClerkⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (BankClerk'fds).

Class BankClerk_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] BankClerk_type_repr  :: go.TypeReprUnderlying BankClerkⁱᵐᵖˡ BankClerk.t;
  #[global] BankClerk_underlying :: (BankClerk) <u (BankClerkⁱᵐᵖˡ);
  #[global] BankClerk_get_lck (x : BankClerk.t) :: ⟦StructFieldGet (BankClerkⁱᵐᵖˡ) "lck", #x⟧ ⤳[under] #x.(BankClerk.lck');
  #[global] BankClerk_set_lck (x : BankClerk.t) y :: ⟦StructFieldSet (BankClerkⁱᵐᵖˡ) "lck", (#x, #y)⟧ ⤳[under] #(x <|BankClerk.lck' := y|>);
  #[global] BankClerk_get_kvck (x : BankClerk.t) :: ⟦StructFieldGet (BankClerkⁱᵐᵖˡ) "kvck", #x⟧ ⤳[under] #x.(BankClerk.kvck');
  #[global] BankClerk_set_kvck (x : BankClerk.t) y :: ⟦StructFieldSet (BankClerkⁱᵐᵖˡ) "kvck", (#x, #y)⟧ ⤳[under] #(x <|BankClerk.kvck' := y|>);
  #[global] BankClerk_get_accts (x : BankClerk.t) :: ⟦StructFieldGet (BankClerkⁱᵐᵖˡ) "accts", #x⟧ ⤳[under] #x.(BankClerk.accts');
  #[global] BankClerk_set_accts (x : BankClerk.t) y :: ⟦StructFieldSet (BankClerkⁱᵐᵖˡ) "accts", (#x, #y)⟧ ⤳[under] #(x <|BankClerk.accts' := y|>);
  #[global] BankClerk'ptr_SimpleAudit_unfold :: MethodUnfold (go.PointerType (BankClerk)) "SimpleAudit" (BankClerk__SimpleAuditⁱᵐᵖˡ);
  #[global] BankClerk'ptr_SimpleTransfer_unfold :: MethodUnfold (go.PointerType (BankClerk)) "SimpleTransfer" (BankClerk__SimpleTransferⁱᵐᵖˡ);
  #[global] BankClerk'ptr_get_total_unfold :: MethodUnfold (go.PointerType (BankClerk)) "get_total" (BankClerk__get_totalⁱᵐᵖˡ);
  #[global] BankClerk'ptr_transfer_internal_unfold :: MethodUnfold (go.PointerType (BankClerk)) "transfer_internal" (BankClerk__transfer_internalⁱᵐᵖˡ);
}.

Class Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] BankClerk_instance :: BankClerk_Assumptions;
  #[global] acquire_two_good_unfold :: FuncUnfold acquire_two_good [] (acquire_two_goodⁱᵐᵖˡ);
  #[global] acquire_two_unfold :: FuncUnfold acquire_two [] (acquire_twoⁱᵐᵖˡ);
  #[global] release_two_unfold :: FuncUnfold release_two [] (release_twoⁱᵐᵖˡ);
  #[global] encodeInt_unfold :: FuncUnfold encodeInt [] (encodeIntⁱᵐᵖˡ);
  #[global] decodeInt_unfold :: FuncUnfold decodeInt [] (decodeIntⁱᵐᵖˡ);
  #[global] MakeBankClerkSlice_unfold :: FuncUnfold MakeBankClerkSlice [] (MakeBankClerkSliceⁱᵐᵖˡ);
  #[global] MakeBankClerk_unfold :: FuncUnfold MakeBankClerk [] (MakeBankClerkⁱᵐᵖˡ);
  #[global] import_primitive_Assumption :: primitive.Assumptions;
  #[global] import_kv_Assumption :: kv.Assumptions;
  #[global] import_lockservice_Assumption :: lockservice.Assumptions;
  #[global] import_marshal_Assumption :: marshal.Assumptions;
}.
End bank.
