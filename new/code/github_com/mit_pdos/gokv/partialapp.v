(* autogenerated from github.com/mit-pdos/gokv/partialapp *)
From New.golang Require Import defn.
Module pkg_id.
Definition main : go_string := "github.com/mit-pdos/gokv/partialapp".

End pkg_id.
Export pkg_id.
Module main.

Definition Foo {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/mit-pdos/gokv/partialapp.Foo"%go [].

Definition partiallyApplyMe {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/gokv/partialapp.partiallyApplyMe"%go.

Definition main {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/gokv/partialapp.main"%go.

(* go: examples.go:3:6 *)
Definition partiallyApplyMeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x" "y",
    exception_do (let: "y" := (GoAlloc go.int "y") in
    let: "x" := (GoAlloc go.string "x") in
    (if: Convert go.untyped_bool go.bool ((let: "$a0" := (![go.string] "x") in
    (FuncResolve go.len [go.string] #()) "$a0") ≠⟨go.int⟩ (![go.int] "y"))
    then
      do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"not allowed"%go) in
      (FuncResolve go.panic [] #()) "$a0")
    else do:  #());;;
    return: #()).

(* go: examples.go:11:14 *)
Definition Foo__someMethodⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "f" <>,
    exception_do (let: "f" := (GoAlloc Foo "f") in
    do:  #()).

(* go: examples.go:14:14 *)
Definition Foo__someMethodWithArgsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "f" "y" "z",
    exception_do (let: "f" := (GoAlloc Foo "f") in
    let: "z" := (GoAlloc go.int "z") in
    let: "y" := (GoAlloc go.string "y") in
    do:  (let: "$a0" := ((![Foo] "f") +⟨go.string⟩ (![go.string] "y")) in
    let: "$a1" := (![go.int] "z") in
    (FuncResolve partiallyApplyMe [] #()) "$a0" "$a1");;;
    return: #()).

(* go: examples.go:18:6 *)
Definition mainⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    with_defer: (let: "x" := (GoAlloc (go.FunctionType (go.Signature [go.string; go.int] false [])) (GoZeroVal (go.FunctionType (go.Signature [go.string; go.int] false [])) #())) in
    let: "$r0" := (FuncResolve partiallyApplyMe [] #()) in
    do:  ("x" <-[go.FunctionType (go.Signature [go.string; go.int] false [])] "$r0");;;
    do:  (let: "$a0" := #"blah"%go in
    let: "$a1" := #(W64 4) in
    (![go.FunctionType (go.Signature [go.string; go.int] false [])] "x") "$a0" "$a1");;;
    do:  (let: "$a0" := #"ok"%go in
    let: "$a1" := #(W64 2) in
    let: "$f" := (![go.FunctionType (go.Signature [go.string; go.int] false [])] "x") in
    "$defer" <-[deferType] (let: "$oldf" := (![deferType] "$defer") in
    (λ: <>,
      "$f" "$a0" "$a1";;
      "$oldf" #()
      )));;;
    do:  (let: "$a0" := #"abc"%go in
    let: "$a1" := #(W64 3) in
    let: "$f" := (FuncResolve partiallyApplyMe [] #()) in
    "$defer" <-[deferType] (let: "$oldf" := (![deferType] "$defer") in
    (λ: <>,
      "$f" "$a0" "$a1";;
      "$oldf" #()
      )));;;
    let: "f" := (GoAlloc Foo (GoZeroVal Foo #())) in
    let: "$r0" := #"a"%go in
    do:  ("f" <-[Foo] "$r0");;;
    do:  ((MethodResolve Foo "someMethod"%go (![Foo] "f")) #());;;
    let: "$r0" := (MethodResolve Foo "someMethodWithArgs"%go (![Foo] "f")) in
    do:  ("x" <-[go.FunctionType (go.Signature [go.string; go.int] false [])] "$r0");;;
    do:  (let: "$a0" := #"b"%go in
    let: "$a1" := #(W64 2) in
    (![go.FunctionType (go.Signature [go.string; go.int] false [])] "x") "$a0" "$a1");;;
    do:  (let: "$a0" := #"bc"%go in
    let: "$a1" := #(W64 3) in
    (MethodResolve Foo "someMethodWithArgs"%go (![Foo] "f")) "$a0" "$a1");;;
    return: #()).

#[global] Instance info' : PkgInfo pkg_id.main :=
{|
  pkg_imported_pkgs := []
|}.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init pkg_id.main (λ: <>,
      exception_do (do:  #())
      ).

Module Foo.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := go_string.
End def.
End Foo.

Definition Fooⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.string.

Class Foo_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Foo_underlying :: (Foo) <u (Fooⁱᵐᵖˡ);
  #[global] Foo_someMethod_unfold :: MethodUnfold (Foo) "someMethod" (Foo__someMethodⁱᵐᵖˡ);
  #[global] Foo_someMethodWithArgs_unfold :: MethodUnfold (Foo) "someMethodWithArgs" (Foo__someMethodWithArgsⁱᵐᵖˡ);
  #[global] Foo'ptr_someMethod_unfold :: MethodUnfold (go.PointerType (Foo)) "someMethod" (λ: "$r", MethodResolve (Foo) "someMethod" (![(Foo)] "$r"));
  #[global] Foo'ptr_someMethodWithArgs_unfold :: MethodUnfold (go.PointerType (Foo)) "someMethodWithArgs" (λ: "$r", MethodResolve (Foo) "someMethodWithArgs" (![(Foo)] "$r"));
}.

Class Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Foo_instance :: Foo_Assumptions;
  #[global] partiallyApplyMe_unfold :: FuncUnfold partiallyApplyMe [] (partiallyApplyMeⁱᵐᵖˡ);
  #[global] main_unfold :: FuncUnfold main [] (mainⁱᵐᵖˡ);
}.
End main.
