(* autogenerated from github.com/mit-pdos/gokv/lockservice *)
Require Export New.code.github_com.mit_pdos.gokv.kv.
From New.golang Require Import defn.
Module pkg_id.
Definition lockservice : go_string := "github.com/mit-pdos/gokv/lockservice".

End pkg_id.
Export pkg_id.
Module lockservice.

Definition LockClerk {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/mit-pdos/gokv/lockservice.LockClerk"%go [].

Definition MakeLockClerk {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/gokv/lockservice.MakeLockClerk"%go.

(* go: lock_clerk.go:11:22 *)
Definition LockClerk__Lockⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "ck" "key",
    exception_do (let: "ck" := (GoAlloc (go.PointerType LockClerk) "ck") in
    let: "key" := (GoAlloc go.string "key") in
    (for: (λ: <>, (let: "$a0" := (![go.string] "key") in
    let: "$a1" := #""%go in
    let: "$a2" := #"1"%go in
    (MethodResolve kv.KvCput "ConditionalPut"%go (![kv.KvCput] (StructFieldRef LockClerk "kv"%go (![go.PointerType LockClerk] "ck")))) "$a0" "$a1" "$a2") ≠⟨go.string⟩ #"ok"%go); (λ: <>, #()) := λ: <>,
      do:  #());;;
    return: #()).

(* go: lock_clerk.go:16:22 *)
Definition LockClerk__Unlockⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "ck" "key",
    exception_do (let: "ck" := (GoAlloc (go.PointerType LockClerk) "ck") in
    let: "key" := (GoAlloc go.string "key") in
    do:  (let: "$a0" := (![go.string] "key") in
    let: "$a1" := #""%go in
    (MethodResolve kv.KvCput "Put"%go (![kv.KvCput] (StructFieldRef LockClerk "kv"%go (![go.PointerType LockClerk] "ck")))) "$a0" "$a1");;;
    return: #()).

(* go: lock_clerk.go:20:6 *)
Definition MakeLockClerkⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "kv",
    exception_do (let: "kv" := (GoAlloc kv.KvCput "kv") in
    return: (GoAlloc LockClerk (CompositeLiteral LockClerk (LiteralValue [KeyedElement (Some (KeyField "kv"%go)) (ElementExpression kv.KvCput (![kv.KvCput] "kv"))])))).

#[global] Instance info' : PkgInfo pkg_id.lockservice :=
{|
  pkg_imported_pkgs := [code.github_com.mit_pdos.gokv.kv.pkg_id.kv]
|}.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init pkg_id.lockservice (λ: <>,
      exception_do (do:  (kv.initialize' #()))
      ).

Module LockClerk.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  kv' : kv.KvCput.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End LockClerk.

Definition LockClerk'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "kv"%go kv.KvCput)
].
Program Definition LockClerk'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (LockClerk'fds_unsealed).
Global Instance equals_unfold_LockClerk {ext : ffi_syntax} {go_gctx : GoGlobalContext} : LockClerk'fds =→ LockClerk'fds_unsealed.
Proof. rewrite /LockClerk'fds seal_eq //. Qed.

Definition LockClerkⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (LockClerk'fds).

Class LockClerk_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] LockClerk_type_repr  :: go.TypeReprUnderlying LockClerkⁱᵐᵖˡ LockClerk.t;
  #[global] LockClerk_underlying :: (LockClerk) <u (LockClerkⁱᵐᵖˡ);
  #[global] LockClerk_get_kv (x : LockClerk.t) :: ⟦StructFieldGet (LockClerkⁱᵐᵖˡ) "kv", #x⟧ ⤳[under] #x.(LockClerk.kv');
  #[global] LockClerk_set_kv (x : LockClerk.t) y :: ⟦StructFieldSet (LockClerkⁱᵐᵖˡ) "kv", (#x, #y)⟧ ⤳[under] #(x <|LockClerk.kv' := y|>);
  #[global] LockClerk'ptr_Lock_unfold :: MethodUnfold (go.PointerType (LockClerk)) "Lock" (LockClerk__Lockⁱᵐᵖˡ);
  #[global] LockClerk'ptr_Unlock_unfold :: MethodUnfold (go.PointerType (LockClerk)) "Unlock" (LockClerk__Unlockⁱᵐᵖˡ);
}.

Class Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] LockClerk_instance :: LockClerk_Assumptions;
  #[global] MakeLockClerk_unfold :: FuncUnfold MakeLockClerk [] (MakeLockClerkⁱᵐᵖˡ);
  #[global] import_kv_Assumption :: kv.Assumptions;
}.
End lockservice.
