(* autogenerated from github.com/mit-pdos/gokv/map_marshal *)
Require Export New.code.github_com.tchajed.marshal.
From New.golang Require Import defn.
Module pkg_id.
Definition map_marshal : go_string := "github.com/mit-pdos/gokv/map_marshal".

End pkg_id.
Export pkg_id.
Module map_marshal.

Definition EncodeMapU64ToU64 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/gokv/map_marshal.EncodeMapU64ToU64"%go.

Definition DecodeMapU64ToU64 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/gokv/map_marshal.DecodeMapU64ToU64"%go.

Definition EncodeMapU64ToBytes {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/gokv/map_marshal.EncodeMapU64ToBytes"%go.

Definition DecodeMapU64ToBytes {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/gokv/map_marshal.DecodeMapU64ToBytes"%go.

(* go: map_marshal.go:5:6 *)
Definition EncodeMapU64ToU64ⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "kvs",
    exception_do (let: "kvs" := (GoAlloc (go.MapType go.uint64 go.uint64) "kvs") in
    let: "enc" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 0)) in
    do:  ("enc" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "enc") in
    let: "$a1" := (Convert go.int go.uint64 (let: "$a0" := (![go.MapType go.uint64 go.uint64] "kvs") in
    (FuncResolve go.len [go.MapType go.uint64 go.uint64] #()) "$a0")) in
    (FuncResolve marshal.WriteInt [] #()) "$a0" "$a1") in
    do:  ("enc" <-[go.SliceType go.byte] "$r0");;;
    let: "$range" := (![go.MapType go.uint64 go.uint64] "kvs") in
    (let: "v" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "k" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    map.for_range go.uint64 go.uint64 "$range" (λ: "$key" "value",
      do:  ("v" <-[go.uint64] "$value");;;
      do:  ("k" <-[go.uint64] "$key");;;
      let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "enc") in
      let: "$a1" := (![go.uint64] "k") in
      (FuncResolve marshal.WriteInt [] #()) "$a0" "$a1") in
      do:  ("enc" <-[go.SliceType go.byte] "$r0");;;
      let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "enc") in
      let: "$a1" := (![go.uint64] "v") in
      (FuncResolve marshal.WriteInt [] #()) "$a0" "$a1") in
      do:  ("enc" <-[go.SliceType go.byte] "$r0")));;;
    return: (![go.SliceType go.byte] "enc")).

(* go: map_marshal.go:15:6 *)
Definition DecodeMapU64ToU64ⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "enc_in",
    exception_do (let: "enc_in" := (GoAlloc (go.SliceType go.byte) "enc_in") in
    let: "enc" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (![go.SliceType go.byte] "enc_in") in
    do:  ("enc" <-[go.SliceType go.byte] "$r0");;;
    let: "kvs" := (GoAlloc (go.MapType go.uint64 go.uint64) (GoZeroVal (go.MapType go.uint64 go.uint64) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.MapType go.uint64 go.uint64] #()) #(W64 0)) in
    do:  ("kvs" <-[go.MapType go.uint64 go.uint64] "$r0");;;
    let: "enc2" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "numEntries" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] "enc") in
    (FuncResolve marshal.ReadInt [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("numEntries" <-[go.uint64] "$r0");;;
    do:  ("enc2" <-[go.SliceType go.byte] "$r1");;;
    let: "$r0" := (![go.SliceType go.byte] "enc2") in
    do:  ("enc" <-[go.SliceType go.byte] "$r0");;;
    (let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, (![go.uint64] "i") <⟨go.uint64⟩ (![go.uint64] "numEntries")); (λ: <>, do:  ("i" <-[go.uint64] ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 1)))) := λ: <>,
      let: "key" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: "val" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] "enc") in
      (FuncResolve marshal.ReadInt [] #()) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("key" <-[go.uint64] "$r0");;;
      do:  ("enc" <-[go.SliceType go.byte] "$r1");;;
      let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] "enc") in
      (FuncResolve marshal.ReadInt [] #()) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("val" <-[go.uint64] "$r0");;;
      do:  ("enc" <-[go.SliceType go.byte] "$r1");;;
      let: "$r0" := (![go.uint64] "val") in
      do:  (map.insert go.uint64 (![go.MapType go.uint64 go.uint64] "kvs") (![go.uint64] "key") "$r0")));;;
    return: (![go.MapType go.uint64 go.uint64] "kvs", ![go.SliceType go.byte] "enc")).

(* go: map_marshal.go:31:6 *)
Definition EncodeMapU64ToBytesⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "kvs",
    exception_do (let: "kvs" := (GoAlloc (go.MapType go.uint64 (go.SliceType go.byte)) "kvs") in
    let: "enc" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 0)) in
    do:  ("enc" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "enc") in
    let: "$a1" := (Convert go.int go.uint64 (let: "$a0" := (![go.MapType go.uint64 (go.SliceType go.byte)] "kvs") in
    (FuncResolve go.len [go.MapType go.uint64 (go.SliceType go.byte)] #()) "$a0")) in
    (FuncResolve marshal.WriteInt [] #()) "$a0" "$a1") in
    do:  ("enc" <-[go.SliceType go.byte] "$r0");;;
    let: "$range" := (![go.MapType go.uint64 (go.SliceType go.byte)] "kvs") in
    (let: "v" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "k" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    map.for_range go.uint64 (go.SliceType go.byte) "$range" (λ: "$key" "value",
      do:  ("v" <-[go.SliceType go.byte] "$value");;;
      do:  ("k" <-[go.uint64] "$key");;;
      let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "enc") in
      let: "$a1" := (![go.uint64] "k") in
      (FuncResolve marshal.WriteInt [] #()) "$a0" "$a1") in
      do:  ("enc" <-[go.SliceType go.byte] "$r0");;;
      let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "enc") in
      let: "$a1" := (Convert go.int go.uint64 (let: "$a0" := (![go.SliceType go.byte] "v") in
      (FuncResolve go.len [go.SliceType go.byte] #()) "$a0")) in
      (FuncResolve marshal.WriteInt [] #()) "$a0" "$a1") in
      do:  ("enc" <-[go.SliceType go.byte] "$r0");;;
      let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "enc") in
      let: "$a1" := (![go.SliceType go.byte] "v") in
      (FuncResolve marshal.WriteBytes [] #()) "$a0" "$a1") in
      do:  ("enc" <-[go.SliceType go.byte] "$r0")));;;
    return: (![go.SliceType go.byte] "enc")).

(* go: map_marshal.go:42:6 *)
Definition DecodeMapU64ToBytesⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "enc_in",
    exception_do (let: "enc_in" := (GoAlloc (go.SliceType go.byte) "enc_in") in
    let: "enc" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (![go.SliceType go.byte] "enc_in") in
    do:  ("enc" <-[go.SliceType go.byte] "$r0");;;
    let: "kvs" := (GoAlloc (go.MapType go.uint64 (go.SliceType go.byte)) (GoZeroVal (go.MapType go.uint64 (go.SliceType go.byte)) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.MapType go.uint64 (go.SliceType go.byte)] #()) #(W64 0)) in
    do:  ("kvs" <-[go.MapType go.uint64 (go.SliceType go.byte)] "$r0");;;
    let: "enc2" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "numEntries" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] "enc") in
    (FuncResolve marshal.ReadInt [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("numEntries" <-[go.uint64] "$r0");;;
    do:  ("enc2" <-[go.SliceType go.byte] "$r1");;;
    let: "$r0" := (![go.SliceType go.byte] "enc2") in
    do:  ("enc" <-[go.SliceType go.byte] "$r0");;;
    (let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, (![go.uint64] "i") <⟨go.uint64⟩ (![go.uint64] "numEntries")); (λ: <>, do:  ("i" <-[go.uint64] ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 1)))) := λ: <>,
      let: "enc3" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
      let: "key" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] "enc") in
      (FuncResolve marshal.ReadInt [] #()) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("key" <-[go.uint64] "$r0");;;
      do:  ("enc3" <-[go.SliceType go.byte] "$r1");;;
      let: "enc4" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
      let: "valLen" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] "enc3") in
      (FuncResolve marshal.ReadInt [] #()) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("valLen" <-[go.uint64] "$r0");;;
      do:  ("enc4" <-[go.SliceType go.byte] "$r1");;;
      let: "enc5" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
      let: "val" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] "enc4") in
      let: "$a1" := (![go.uint64] "valLen") in
      (FuncResolve marshal.ReadBytesCopy [] #()) "$a0" "$a1") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("val" <-[go.SliceType go.byte] "$r0");;;
      do:  ("enc5" <-[go.SliceType go.byte] "$r1");;;
      let: "$r0" := (![go.SliceType go.byte] "enc5") in
      do:  ("enc" <-[go.SliceType go.byte] "$r0");;;
      let: "$r0" := (![go.SliceType go.byte] "val") in
      do:  (map.insert go.uint64 (![go.MapType go.uint64 (go.SliceType go.byte)] "kvs") (![go.uint64] "key") "$r0")));;;
    return: (![go.MapType go.uint64 (go.SliceType go.byte)] "kvs", ![go.SliceType go.byte] "enc")).

#[global] Instance info' : PkgInfo pkg_id.map_marshal :=
{|
  pkg_imported_pkgs := [code.github_com.tchajed.marshal.pkg_id.marshal]
|}.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init pkg_id.map_marshal (λ: <>,
      exception_do (do:  (marshal.initialize' #()))
      ).

Class Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] EncodeMapU64ToU64_unfold :: FuncUnfold EncodeMapU64ToU64 [] (EncodeMapU64ToU64ⁱᵐᵖˡ);
  #[global] DecodeMapU64ToU64_unfold :: FuncUnfold DecodeMapU64ToU64 [] (DecodeMapU64ToU64ⁱᵐᵖˡ);
  #[global] EncodeMapU64ToBytes_unfold :: FuncUnfold EncodeMapU64ToBytes [] (EncodeMapU64ToBytesⁱᵐᵖˡ);
  #[global] DecodeMapU64ToBytes_unfold :: FuncUnfold DecodeMapU64ToBytes [] (DecodeMapU64ToBytesⁱᵐᵖˡ);
  #[global] import_marshal_Assumption :: marshal.Assumptions;
}.
End map_marshal.
