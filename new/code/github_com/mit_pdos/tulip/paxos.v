(* autogenerated from github.com/mit-pdos/tulip/paxos *)
From New.golang Require Import defn.
Require Export New.code.fmt.
Require Export New.code.github_com.goose_lang.primitive.
Require Export New.code.github_com.mit_pdos.gokv.grove_ffi.
Require Export New.code.github_com.mit_pdos.tulip.params.
Require Export New.code.github_com.mit_pdos.tulip.quorum.
Require Export New.code.github_com.mit_pdos.tulip.util.
Require Export New.code.github_com.tchajed.marshal.
Require Export New.code.sync.

Definition paxos : go_string := "github.com/mit-pdos/tulip/paxos".

From New Require Import grove_prelude.
Module paxos.
Section code.


Definition Paxos : go_type := structT [
  "nidme" :: uint64T;
  "peers" :: sliceT;
  "addrm" :: mapT uint64T uint64T;
  "sc" :: uint64T;
  "fname" :: stringT;
  "mu" :: ptrT;
  "cv" :: ptrT;
  "hb" :: boolT;
  "termc" :: uint64T;
  "terml" :: uint64T;
  "log" :: sliceT;
  "lsnc" :: uint64T;
  "iscand" :: boolT;
  "isleader" :: boolT;
  "termp" :: uint64T;
  "entsp" :: sliceT;
  "respp" :: mapT uint64T boolT;
  "lsnpeers" :: mapT uint64T uint64T;
  "conns" :: mapT uint64T grove_ffi.Connection
].

Definition MAX_NODES : expr := #(W64 16).

(* go: paxos.go:135:18 *)
Definition Paxos__Submit : val :=
  rec: "Paxos__Submit" "px" "v" :=
    exception_do (let: "px" := (mem.alloc "px") in
    let: "v" := (mem.alloc "v") in
    do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref #Paxos #"mu"%go (![#ptrT] "px")))) #());;;
    (if: (~ ((method_call #paxos.paxos #"Paxos'ptr" #"leading" (![#ptrT] "px")) #()))
    then
      do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Paxos #"mu"%go (![#ptrT] "px")))) #());;;
      return: (#(W64 0), #(W64 0))
    else do:  #());;;
    let: "lsn" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref #Paxos #"log"%go (![#ptrT] "px"))) in
    slice.len "$a0")) in
    do:  ("lsn" <-[#uint64T] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] (struct.field_ref #Paxos #"log"%go (![#ptrT] "px"))) in
    let: "$a1" := ((let: "$sl0" := (![#stringT] "v") in
    slice.literal #stringT ["$sl0"])) in
    (slice.append #stringT) "$a0" "$a1") in
    do:  ((struct.field_ref #Paxos #"log"%go (![#ptrT] "px")) <-[#sliceT] "$r0");;;
    let: "term" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (![#uint64T] (struct.field_ref #Paxos #"termc"%go (![#ptrT] "px"))) in
    do:  ("term" <-[#uint64T] "$r0");;;
    do:  (let: "$a0" := (![#stringT] (struct.field_ref #Paxos #"fname"%go (![#ptrT] "px"))) in
    let: "$a1" := (![#stringT] "v") in
    (func_call #paxos.paxos #"logAppend"%go) "$a0" "$a1");;;
    do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Paxos #"mu"%go (![#ptrT] "px")))) #());;;
    do:  ((method_call #sync #"Cond'ptr" #"Broadcast" (![#ptrT] (struct.field_ref #Paxos #"cv"%go (![#ptrT] "px")))) #());;;
    return: (![#uint64T] "lsn", ![#uint64T] "term")).

(* go: paxos.go:163:18 *)
Definition Paxos__Lookup : val :=
  rec: "Paxos__Lookup" "px" "lsn" :=
    exception_do (let: "px" := (mem.alloc "px") in
    let: "lsn" := (mem.alloc "lsn") in
    do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref #Paxos #"mu"%go (![#ptrT] "px")))) #());;;
    (if: (![#uint64T] (struct.field_ref #Paxos #"lsnc"%go (![#ptrT] "px"))) ≤ (![#uint64T] "lsn")
    then
      do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Paxos #"mu"%go (![#ptrT] "px")))) #());;;
      return: (#""%go, #false)
    else do:  #());;;
    let: "v" := (mem.alloc (type.zero_val #stringT)) in
    let: "$r0" := (![#stringT] (slice.elem_ref #stringT (![#sliceT] (struct.field_ref #Paxos #"log"%go (![#ptrT] "px"))) (![#uint64T] "lsn"))) in
    do:  ("v" <-[#stringT] "$r0");;;
    do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Paxos #"mu"%go (![#ptrT] "px")))) #());;;
    return: (![#stringT] "v", #true)).

(* go: paxos.go:179:18 *)
Definition Paxos__WaitUntilSafe : val :=
  rec: "Paxos__WaitUntilSafe" "px" "lsn" "term" :=
    exception_do (let: "px" := (mem.alloc "px") in
    let: "term" := (mem.alloc "term") in
    let: "lsn" := (mem.alloc "lsn") in
    let: "safe" := (mem.alloc (type.zero_val #boolT)) in
    let: "nretry" := (mem.alloc (type.zero_val #uint64T)) in
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref #Paxos #"mu"%go (![#ptrT] "px")))) #());;;
      let: "termc" := (mem.alloc (type.zero_val #uint64T)) in
      let: "$r0" := ((method_call #paxos.paxos #"Paxos'ptr" #"gettermc" (![#ptrT] "px")) #()) in
      do:  ("termc" <-[#uint64T] "$r0");;;
      let: "lsnc" := (mem.alloc (type.zero_val #uint64T)) in
      let: "$r0" := ((method_call #paxos.paxos #"Paxos'ptr" #"getlsnc" (![#ptrT] "px")) #()) in
      do:  ("lsnc" <-[#uint64T] "$r0");;;
      do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Paxos #"mu"%go (![#ptrT] "px")))) #());;;
      (if: (![#uint64T] "term") ≠ (![#uint64T] "termc")
      then break: #()
      else do:  #());;;
      (if: (![#uint64T] "lsn") < (![#uint64T] "lsnc")
      then
        let: "$r0" := #true in
        do:  ("safe" <-[#boolT] "$r0");;;
        break: #()
      else do:  #());;;
      (if: (![#uint64T] "nretry") = params.N_RETRY_REPLICATED
      then break: #()
      else do:  #());;;
      do:  ("nretry" <-[#uint64T] ((![#uint64T] "nretry") + #(W64 1)));;;
      do:  (let: "$a0" := params.NS_REPLICATED_INTERVAL in
      (func_call #primitive.primitive #"Sleep"%go) "$a0"));;;
    return: (![#boolT] "safe")).

(* Return values:
   1. @term: New term in which this node attempts to be the leader.
   2. @lsn: LSN after which log entries whose committedness is yet known, and
   hence the content need to be resolved through the leader-election phase.

   go: paxos.go:222:18 *)
Definition Paxos__nominate : val :=
  rec: "Paxos__nominate" "px" <> :=
    exception_do (let: "px" := (mem.alloc "px") in
    let: "term" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (let: "$a0" := (![#uint64T] (struct.field_ref #Paxos #"termc"%go (![#ptrT] "px"))) in
    let: "$a1" := MAX_NODES in
    let: "$a2" := (![#uint64T] (struct.field_ref #Paxos #"nidme"%go (![#ptrT] "px"))) in
    (func_call #util.util #"NextAligned"%go) "$a0" "$a1" "$a2") in
    do:  ("term" <-[#uint64T] "$r0");;;
    let: "$r0" := (![#uint64T] "term") in
    do:  ((struct.field_ref #Paxos #"termc"%go (![#ptrT] "px")) <-[#uint64T] "$r0");;;
    let: "$r0" := #false in
    do:  ((struct.field_ref #Paxos #"isleader"%go (![#ptrT] "px")) <-[#boolT] "$r0");;;
    let: "lsn" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (![#uint64T] (struct.field_ref #Paxos #"lsnc"%go (![#ptrT] "px"))) in
    do:  ("lsn" <-[#uint64T] "$r0");;;
    let: "ents" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make2 #stringT ((s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref #Paxos #"log"%go (![#ptrT] "px"))) in
    slice.len "$a0")) - (![#uint64T] "lsn"))) in
    do:  ("ents" <-[#sliceT] "$r0");;;
    do:  (let: "$a0" := (![#sliceT] "ents") in
    let: "$a1" := (let: "$s" := (![#sliceT] (struct.field_ref #Paxos #"log"%go (![#ptrT] "px"))) in
    slice.slice #stringT "$s" (![#uint64T] "lsn") (slice.len "$s")) in
    (slice.copy #stringT) "$a0" "$a1");;;
    let: "$r0" := #true in
    do:  ((struct.field_ref #Paxos #"iscand"%go (![#ptrT] "px")) <-[#boolT] "$r0");;;
    let: "$r0" := (![#uint64T] (struct.field_ref #Paxos #"terml"%go (![#ptrT] "px"))) in
    do:  ((struct.field_ref #Paxos #"termp"%go (![#ptrT] "px")) <-[#uint64T] "$r0");;;
    let: "$r0" := (![#sliceT] "ents") in
    do:  ((struct.field_ref #Paxos #"entsp"%go (![#ptrT] "px")) <-[#sliceT] "$r0");;;
    let: "$r0" := (map.make #uint64T #boolT) in
    do:  ((struct.field_ref #Paxos #"respp"%go (![#ptrT] "px")) <-[type.mapT #uint64T #boolT] "$r0");;;
    let: "$r0" := #true in
    do:  (map.insert (![type.mapT #uint64T #boolT] (struct.field_ref #Paxos #"respp"%go (![#ptrT] "px"))) (![#uint64T] (struct.field_ref #Paxos #"nidme"%go (![#ptrT] "px"))) "$r0");;;
    do:  (let: "$a0" := #"[paxos %d] Become a candidate in %d.
    "%go in
    let: "$a1" := ((let: "$sl0" := (interface.make #""%go #"uint64"%go (![#uint64T] (struct.field_ref #Paxos #"nidme"%go (![#ptrT] "px")))) in
    let: "$sl1" := (interface.make #""%go #"uint64"%go (![#uint64T] (struct.field_ref #Paxos #"termc"%go (![#ptrT] "px")))) in
    slice.literal #interfaceT ["$sl0"; "$sl1"])) in
    (func_call #fmt.fmt #"Printf"%go) "$a0" "$a1");;;
    do:  (let: "$a0" := (![#stringT] (struct.field_ref #Paxos #"fname"%go (![#ptrT] "px"))) in
    let: "$a1" := (![#uint64T] "term") in
    (func_call #paxos.paxos #"logPrepare"%go) "$a0" "$a1");;;
    return: (![#uint64T] "term", ![#uint64T] "lsn")).

(* go: paxos.go:249:18 *)
Definition Paxos__stepdown : val :=
  rec: "Paxos__stepdown" "px" "term" :=
    exception_do (let: "px" := (mem.alloc "px") in
    let: "term" := (mem.alloc "term") in
    let: "$r0" := #false in
    do:  ((struct.field_ref #Paxos #"iscand"%go (![#ptrT] "px")) <-[#boolT] "$r0");;;
    let: "$r0" := #false in
    do:  ((struct.field_ref #Paxos #"isleader"%go (![#ptrT] "px")) <-[#boolT] "$r0");;;
    (if: (![#uint64T] (struct.field_ref #Paxos #"termc"%go (![#ptrT] "px"))) = (![#uint64T] "term")
    then return: (#())
    else do:  #());;;
    let: "$r0" := (![#uint64T] "term") in
    do:  ((struct.field_ref #Paxos #"termc"%go (![#ptrT] "px")) <-[#uint64T] "$r0");;;
    do:  (let: "$a0" := (![#stringT] (struct.field_ref #Paxos #"fname"%go (![#ptrT] "px"))) in
    let: "$a1" := (![#uint64T] "term") in
    (func_call #paxos.paxos #"logPrepare"%go) "$a0" "$a1")).

(* Argument:
   1. @lsn: LSN after which log entries whose committedness is yet known, and
   hence the content need to be resolved through the leader-election phase.

   Return values:
   1. @terml: Log term of this node (which is also the largest accepted term
   before @px.termc).
   2. @ents: All entries after @lsn.

   go: paxos.go:270:18 *)
Definition Paxos__prepare : val :=
  rec: "Paxos__prepare" "px" "lsn" :=
    exception_do (let: "px" := (mem.alloc "px") in
    let: "lsn" := (mem.alloc "lsn") in
    (if: (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref #Paxos #"log"%go (![#ptrT] "px"))) in
    slice.len "$a0")) ≤ (![#uint64T] "lsn")
    then return: (![#uint64T] (struct.field_ref #Paxos #"terml"%go (![#ptrT] "px")), slice.make2 #stringT #(W64 0))
    else do:  #());;;
    let: "ents" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make2 #stringT ((s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref #Paxos #"log"%go (![#ptrT] "px"))) in
    slice.len "$a0")) - (![#uint64T] "lsn"))) in
    do:  ("ents" <-[#sliceT] "$r0");;;
    do:  (let: "$a0" := (![#sliceT] "ents") in
    let: "$a1" := (let: "$s" := (![#sliceT] (struct.field_ref #Paxos #"log"%go (![#ptrT] "px"))) in
    slice.slice #stringT "$s" (![#uint64T] "lsn") (slice.len "$s")) in
    (slice.copy #stringT) "$a0" "$a1");;;
    return: (![#uint64T] (struct.field_ref #Paxos #"terml"%go (![#ptrT] "px")), ![#sliceT] "ents")).

(* go: paxos.go:280:18 *)
Definition Paxos__collect : val :=
  rec: "Paxos__collect" "px" "nid" "term" "ents" :=
    exception_do (let: "px" := (mem.alloc "px") in
    let: "ents" := (mem.alloc "ents") in
    let: "term" := (mem.alloc "term") in
    let: "nid" := (mem.alloc "nid") in
    let: "recved" := (mem.alloc (type.zero_val #boolT)) in
    let: ("$ret0", "$ret1") := (map.get (![type.mapT #uint64T #boolT] (struct.field_ref #Paxos #"respp"%go (![#ptrT] "px"))) (![#uint64T] "nid")) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  "$r0";;;
    do:  ("recved" <-[#boolT] "$r1");;;
    (if: ![#boolT] "recved"
    then return: (#())
    else do:  #());;;
    (if: (![#uint64T] "term") < (![#uint64T] (struct.field_ref #Paxos #"termp"%go (![#ptrT] "px")))
    then
      let: "$r0" := #true in
      do:  (map.insert (![type.mapT #uint64T #boolT] (struct.field_ref #Paxos #"respp"%go (![#ptrT] "px"))) (![#uint64T] "nid") "$r0");;;
      return: (#())
    else do:  #());;;
    (if: ((![#uint64T] "term") = (![#uint64T] (struct.field_ref #Paxos #"termp"%go (![#ptrT] "px")))) && ((s_to_w64 (let: "$a0" := (![#sliceT] "ents") in
    slice.len "$a0")) ≤ (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref #Paxos #"entsp"%go (![#ptrT] "px"))) in
    slice.len "$a0")))
    then
      let: "$r0" := #true in
      do:  (map.insert (![type.mapT #uint64T #boolT] (struct.field_ref #Paxos #"respp"%go (![#ptrT] "px"))) (![#uint64T] "nid") "$r0");;;
      return: (#())
    else do:  #());;;
    let: "$r0" := (![#uint64T] "term") in
    do:  ((struct.field_ref #Paxos #"termp"%go (![#ptrT] "px")) <-[#uint64T] "$r0");;;
    let: "$r0" := (![#sliceT] "ents") in
    do:  ((struct.field_ref #Paxos #"entsp"%go (![#ptrT] "px")) <-[#sliceT] "$r0");;;
    let: "$r0" := #true in
    do:  (map.insert (![type.mapT #uint64T #boolT] (struct.field_ref #Paxos #"respp"%go (![#ptrT] "px"))) (![#uint64T] "nid") "$r0")).

(* go: paxos.go:307:18 *)
Definition Paxos__ascend : val :=
  rec: "Paxos__ascend" "px" <> :=
    exception_do (let: "px" := (mem.alloc "px") in
    (if: (~ (let: "$a0" := (s_to_w64 (let: "$a0" := (![type.mapT #uint64T #boolT] (struct.field_ref #Paxos #"respp"%go (![#ptrT] "px"))) in
    map.len "$a0")) in
    (method_call #paxos.paxos #"Paxos'ptr" #"cquorum" (![#ptrT] "px")) "$a0"))
    then return: (#())
    else do:  #());;;
    let: "$r0" := (let: "$a0" := (let: "$s" := (![#sliceT] (struct.field_ref #Paxos #"log"%go (![#ptrT] "px"))) in
    slice.slice #stringT "$s" #(W64 0) (![#uint64T] (struct.field_ref #Paxos #"lsnc"%go (![#ptrT] "px")))) in
    let: "$a1" := (![#sliceT] (struct.field_ref #Paxos #"entsp"%go (![#ptrT] "px"))) in
    (slice.append #stringT) "$a0" "$a1") in
    do:  ((struct.field_ref #Paxos #"log"%go (![#ptrT] "px")) <-[#sliceT] "$r0");;;
    let: "$r0" := (![#uint64T] (struct.field_ref #Paxos #"termc"%go (![#ptrT] "px"))) in
    do:  ((struct.field_ref #Paxos #"terml"%go (![#ptrT] "px")) <-[#uint64T] "$r0");;;
    let: "$r0" := #false in
    do:  ((struct.field_ref #Paxos #"iscand"%go (![#ptrT] "px")) <-[#boolT] "$r0");;;
    let: "$r0" := #true in
    do:  ((struct.field_ref #Paxos #"isleader"%go (![#ptrT] "px")) <-[#boolT] "$r0");;;
    let: "$r0" := (map.make #uint64T #uint64T) in
    do:  ((struct.field_ref #Paxos #"lsnpeers"%go (![#ptrT] "px")) <-[type.mapT #uint64T #uint64T] "$r0");;;
    do:  (let: "$a0" := #"[paxos %d] Become a leader in %d.
    "%go in
    let: "$a1" := ((let: "$sl0" := (interface.make #""%go #"uint64"%go (![#uint64T] (struct.field_ref #Paxos #"nidme"%go (![#ptrT] "px")))) in
    let: "$sl1" := (interface.make #""%go #"uint64"%go (![#uint64T] (struct.field_ref #Paxos #"termc"%go (![#ptrT] "px")))) in
    slice.literal #interfaceT ["$sl0"; "$sl1"])) in
    (func_call #fmt.fmt #"Printf"%go) "$a0" "$a1");;;
    do:  (let: "$a0" := (![#stringT] (struct.field_ref #Paxos #"fname"%go (![#ptrT] "px"))) in
    let: "$a1" := (![#uint64T] (struct.field_ref #Paxos #"termc"%go (![#ptrT] "px"))) in
    let: "$a2" := (![#uint64T] (struct.field_ref #Paxos #"lsnc"%go (![#ptrT] "px"))) in
    let: "$a3" := (![#sliceT] (struct.field_ref #Paxos #"entsp"%go (![#ptrT] "px"))) in
    (func_call #paxos.paxos #"logAdvance"%go) "$a0" "$a1" "$a2" "$a3")).

(* go: paxos.go:331:18 *)
Definition Paxos__obtain : val :=
  rec: "Paxos__obtain" "px" "nid" :=
    exception_do (let: "px" := (mem.alloc "px") in
    let: "nid" := (mem.alloc "nid") in
    let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "lsne" := (mem.alloc (type.zero_val #uint64T)) in
    let: ("$ret0", "$ret1") := (map.get (![type.mapT #uint64T #uint64T] (struct.field_ref #Paxos #"lsnpeers"%go (![#ptrT] "px"))) (![#uint64T] "nid")) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("lsne" <-[#uint64T] "$r0");;;
    do:  ("ok" <-[#boolT] "$r1");;;
    (if: (~ (![#boolT] "ok"))
    then
      return: (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref #Paxos #"log"%go (![#ptrT] "px"))) in
       slice.len "$a0"), slice.make2 #stringT #(W64 0))
    else do:  #());;;
    let: "ents" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make2 #stringT ((s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref #Paxos #"log"%go (![#ptrT] "px"))) in
    slice.len "$a0")) - (![#uint64T] "lsne"))) in
    do:  ("ents" <-[#sliceT] "$r0");;;
    do:  (let: "$a0" := (![#sliceT] "ents") in
    let: "$a1" := (let: "$s" := (![#sliceT] (struct.field_ref #Paxos #"log"%go (![#ptrT] "px"))) in
    slice.slice #stringT "$s" (![#uint64T] "lsne") (slice.len "$s")) in
    (slice.copy #stringT) "$a0" "$a1");;;
    return: (![#uint64T] "lsne", ![#sliceT] "ents")).

(* Arguments:
   1. @lsn: LSN at which @ents start.
   2. @term: Term to which @ents belong.
   3. @ents: Log entries.

   Return values:
   1. @lsna: LSN up to which log consistency at term @term is established.

   go: paxos.go:354:18 *)
Definition Paxos__accept : val :=
  rec: "Paxos__accept" "px" "lsn" "term" "ents" :=
    exception_do (let: "px" := (mem.alloc "px") in
    let: "ents" := (mem.alloc "ents") in
    let: "term" := (mem.alloc "term") in
    let: "lsn" := (mem.alloc "lsn") in
    (if: (![#uint64T] "term") ≠ (![#uint64T] (struct.field_ref #Paxos #"terml"%go (![#ptrT] "px")))
    then
      (if: (![#uint64T] (struct.field_ref #Paxos #"lsnc"%go (![#ptrT] "px"))) ≠ (![#uint64T] "lsn")
      then return: (![#uint64T] (struct.field_ref #Paxos #"lsnc"%go (![#ptrT] "px")))
      else do:  #());;;
      let: "$r0" := (let: "$s" := (![#sliceT] (struct.field_ref #Paxos #"log"%go (![#ptrT] "px"))) in
      slice.slice #stringT "$s" #(W64 0) (![#uint64T] "lsn")) in
      do:  ((struct.field_ref #Paxos #"log"%go (![#ptrT] "px")) <-[#sliceT] "$r0");;;
      let: "$r0" := (let: "$a0" := (![#sliceT] (struct.field_ref #Paxos #"log"%go (![#ptrT] "px"))) in
      let: "$a1" := (![#sliceT] "ents") in
      (slice.append #stringT) "$a0" "$a1") in
      do:  ((struct.field_ref #Paxos #"log"%go (![#ptrT] "px")) <-[#sliceT] "$r0");;;
      let: "$r0" := (![#uint64T] "term") in
      do:  ((struct.field_ref #Paxos #"terml"%go (![#ptrT] "px")) <-[#uint64T] "$r0");;;
      let: "lsna" := (mem.alloc (type.zero_val #uint64T)) in
      let: "$r0" := (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref #Paxos #"log"%go (![#ptrT] "px"))) in
      slice.len "$a0")) in
      do:  ("lsna" <-[#uint64T] "$r0");;;
      do:  (let: "$a0" := (![#stringT] (struct.field_ref #Paxos #"fname"%go (![#ptrT] "px"))) in
      let: "$a1" := (![#uint64T] "term") in
      let: "$a2" := (![#uint64T] "lsn") in
      let: "$a3" := (![#sliceT] "ents") in
      (func_call #paxos.paxos #"logAdvance"%go) "$a0" "$a1" "$a2" "$a3");;;
      return: (![#uint64T] "lsna")
    else do:  #());;;
    let: "nents" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref #Paxos #"log"%go (![#ptrT] "px"))) in
    slice.len "$a0")) in
    do:  ("nents" <-[#uint64T] "$r0");;;
    (if: ((![#uint64T] "nents") < (![#uint64T] "lsn")) || (((![#uint64T] "lsn") + (s_to_w64 (let: "$a0" := (![#sliceT] "ents") in
    slice.len "$a0"))) ≤ (![#uint64T] "nents"))
    then return: (![#uint64T] "nents")
    else do:  #());;;
    let: "$r0" := (let: "$s" := (![#sliceT] (struct.field_ref #Paxos #"log"%go (![#ptrT] "px"))) in
    slice.slice #stringT "$s" #(W64 0) (![#uint64T] "lsn")) in
    do:  ((struct.field_ref #Paxos #"log"%go (![#ptrT] "px")) <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] (struct.field_ref #Paxos #"log"%go (![#ptrT] "px"))) in
    let: "$a1" := (![#sliceT] "ents") in
    (slice.append #stringT) "$a0" "$a1") in
    do:  ((struct.field_ref #Paxos #"log"%go (![#ptrT] "px")) <-[#sliceT] "$r0");;;
    let: "lsna" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref #Paxos #"log"%go (![#ptrT] "px"))) in
    slice.len "$a0")) in
    do:  ("lsna" <-[#uint64T] "$r0");;;
    do:  (let: "$a0" := (![#stringT] (struct.field_ref #Paxos #"fname"%go (![#ptrT] "px"))) in
    let: "$a1" := (![#uint64T] "lsn") in
    let: "$a2" := (![#sliceT] "ents") in
    (func_call #paxos.paxos #"logAccept"%go) "$a0" "$a1" "$a2");;;
    return: (![#uint64T] "lsna")).

(* @learn monotonically increase the commit LSN @px.lsnc in term @term to @lsn.

   go: paxos.go:403:18 *)
Definition Paxos__learn : val :=
  rec: "Paxos__learn" "px" "lsn" "term" :=
    exception_do (let: "px" := (mem.alloc "px") in
    let: "term" := (mem.alloc "term") in
    let: "lsn" := (mem.alloc "lsn") in
    (if: (![#uint64T] "term") ≠ (![#uint64T] (struct.field_ref #Paxos #"terml"%go (![#ptrT] "px")))
    then return: (#())
    else do:  #());;;
    do:  (let: "$a0" := (![#uint64T] "lsn") in
    (method_call #paxos.paxos #"Paxos'ptr" #"commit" (![#ptrT] "px")) "$a0")).

(* go: paxos.go:412:18 *)
Definition Paxos__forward : val :=
  rec: "Paxos__forward" "px" "nid" "lsn" :=
    exception_do (let: "px" := (mem.alloc "px") in
    let: "lsn" := (mem.alloc "lsn") in
    let: "nid" := (mem.alloc "nid") in
    let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "lsnpeer" := (mem.alloc (type.zero_val #uint64T)) in
    let: ("$ret0", "$ret1") := (map.get (![type.mapT #uint64T #uint64T] (struct.field_ref #Paxos #"lsnpeers"%go (![#ptrT] "px"))) (![#uint64T] "nid")) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("lsnpeer" <-[#uint64T] "$r0");;;
    do:  ("ok" <-[#boolT] "$r1");;;
    (if: (~ (![#boolT] "ok")) || ((![#uint64T] "lsnpeer") < (![#uint64T] "lsn"))
    then
      let: "$r0" := (![#uint64T] "lsn") in
      do:  (map.insert (![type.mapT #uint64T #uint64T] (struct.field_ref #Paxos #"lsnpeers"%go (![#ptrT] "px"))) (![#uint64T] "nid") "$r0");;;
      return: (#true)
    else do:  #());;;
    return: (#false)).

(* go: paxos.go:426:18 *)
Definition Paxos__push : val :=
  rec: "Paxos__push" "px" <> :=
    exception_do (let: "px" := (mem.alloc "px") in
    (if: (~ (let: "$a0" := ((s_to_w64 (let: "$a0" := (![type.mapT #uint64T #uint64T] (struct.field_ref #Paxos #"lsnpeers"%go (![#ptrT] "px"))) in
    map.len "$a0")) + #(W64 1)) in
    (method_call #paxos.paxos #"Paxos'ptr" #"cquorum" (![#ptrT] "px")) "$a0"))
    then return: (#(W64 0), #false)
    else do:  #());;;
    let: "lsns" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make3 #uint64T #(W64 0) (![#uint64T] (struct.field_ref #Paxos #"sc"%go (![#ptrT] "px")))) in
    do:  ("lsns" <-[#sliceT] "$r0");;;
    let: "$range" := (![type.mapT #uint64T #uint64T] (struct.field_ref #Paxos #"lsnpeers"%go (![#ptrT] "px"))) in
    (let: "lsn" := (mem.alloc (type.zero_val #uint64T)) in
    map.for_range "$range" (λ: "$key" "value",
      do:  ("lsn" <-[#uint64T] "$value");;;
      do:  "$key";;;
      let: "$r0" := (let: "$a0" := (![#sliceT] "lsns") in
      let: "$a1" := ((let: "$sl0" := (![#uint64T] "lsn") in
      slice.literal #uint64T ["$sl0"])) in
      (slice.append #uint64T) "$a0" "$a1") in
      do:  ("lsns" <-[#sliceT] "$r0")));;;
    do:  (let: "$a0" := (![#sliceT] "lsns") in
    (func_call #util.util #"Sort"%go) "$a0");;;
    let: "lsn" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (![#uint64T] (slice.elem_ref #uint64T (![#sliceT] "lsns") ((s_to_w64 (let: "$a0" := (![#sliceT] "lsns") in
    slice.len "$a0")) - ((![#uint64T] (struct.field_ref #Paxos #"sc"%go (![#ptrT] "px"))) `quot` #(W64 2))))) in
    do:  ("lsn" <-[#uint64T] "$r0");;;
    (if: (![#uint64T] "lsn") < (![#uint64T] (struct.field_ref #Paxos #"lsnc"%go (![#ptrT] "px")))
    then return: (#(W64 0), #false)
    else do:  #());;;
    return: (![#uint64T] "lsn", #true)).

(* go: paxos.go:456:18 *)
Definition Paxos__commit : val :=
  rec: "Paxos__commit" "px" "lsn" :=
    exception_do (let: "px" := (mem.alloc "px") in
    let: "lsn" := (mem.alloc "lsn") in
    (if: (![#uint64T] "lsn") ≤ (![#uint64T] (struct.field_ref #Paxos #"lsnc"%go (![#ptrT] "px")))
    then return: (#())
    else do:  #());;;
    (if: (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref #Paxos #"log"%go (![#ptrT] "px"))) in
    slice.len "$a0")) < (![#uint64T] "lsn")
    then
      let: "$r0" := (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref #Paxos #"log"%go (![#ptrT] "px"))) in
      slice.len "$a0")) in
      do:  ((struct.field_ref #Paxos #"lsnc"%go (![#ptrT] "px")) <-[#uint64T] "$r0");;;
      do:  (let: "$a0" := (![#stringT] (struct.field_ref #Paxos #"fname"%go (![#ptrT] "px"))) in
      let: "$a1" := (![#uint64T] (struct.field_ref #Paxos #"lsnc"%go (![#ptrT] "px"))) in
      (func_call #paxos.paxos #"logExpand"%go) "$a0" "$a1");;;
      return: (#())
    else do:  #());;;
    let: "$r0" := (![#uint64T] "lsn") in
    do:  ((struct.field_ref #Paxos #"lsnc"%go (![#ptrT] "px")) <-[#uint64T] "$r0");;;
    do:  (let: "$a0" := (![#stringT] (struct.field_ref #Paxos #"fname"%go (![#ptrT] "px"))) in
    let: "$a1" := (![#uint64T] "lsn") in
    (func_call #paxos.paxos #"logExpand"%go) "$a0" "$a1")).

(* go: paxos.go:480:18 *)
Definition Paxos__gttermc : val :=
  rec: "Paxos__gttermc" "px" "term" :=
    exception_do (let: "px" := (mem.alloc "px") in
    let: "term" := (mem.alloc "term") in
    return: ((![#uint64T] (struct.field_ref #Paxos #"termc"%go (![#ptrT] "px"))) < (![#uint64T] "term"))).

(* go: paxos.go:484:18 *)
Definition Paxos__lttermc : val :=
  rec: "Paxos__lttermc" "px" "term" :=
    exception_do (let: "px" := (mem.alloc "px") in
    let: "term" := (mem.alloc "term") in
    return: ((![#uint64T] "term") < (![#uint64T] (struct.field_ref #Paxos #"termc"%go (![#ptrT] "px"))))).

(* go: paxos.go:488:18 *)
Definition Paxos__latest : val :=
  rec: "Paxos__latest" "px" <> :=
    exception_do (let: "px" := (mem.alloc "px") in
    return: ((![#uint64T] (struct.field_ref #Paxos #"termc"%go (![#ptrT] "px"))) = (![#uint64T] (struct.field_ref #Paxos #"terml"%go (![#ptrT] "px"))))).

(* go: paxos.go:492:18 *)
Definition Paxos__gettermc : val :=
  rec: "Paxos__gettermc" "px" <> :=
    exception_do (let: "px" := (mem.alloc "px") in
    return: (![#uint64T] (struct.field_ref #Paxos #"termc"%go (![#ptrT] "px")))).

(* go: paxos.go:496:18 *)
Definition Paxos__getlsnc : val :=
  rec: "Paxos__getlsnc" "px" <> :=
    exception_do (let: "px" := (mem.alloc "px") in
    return: (![#uint64T] (struct.field_ref #Paxos #"lsnc"%go (![#ptrT] "px")))).

(* go: paxos.go:500:18 *)
Definition Paxos__nominated : val :=
  rec: "Paxos__nominated" "px" <> :=
    exception_do (let: "px" := (mem.alloc "px") in
    return: (![#boolT] (struct.field_ref #Paxos #"iscand"%go (![#ptrT] "px")))).

(* go: paxos.go:504:18 *)
Definition Paxos__leading : val :=
  rec: "Paxos__leading" "px" <> :=
    exception_do (let: "px" := (mem.alloc "px") in
    return: (![#boolT] (struct.field_ref #Paxos #"isleader"%go (![#ptrT] "px")))).

(* go: paxos.go:508:18 *)
Definition Paxos__resethb : val :=
  rec: "Paxos__resethb" "px" <> :=
    exception_do (let: "px" := (mem.alloc "px") in
    let: "$r0" := #false in
    do:  ((struct.field_ref #Paxos #"hb"%go (![#ptrT] "px")) <-[#boolT] "$r0")).

(* go: paxos.go:512:18 *)
Definition Paxos__heartbeat : val :=
  rec: "Paxos__heartbeat" "px" <> :=
    exception_do (let: "px" := (mem.alloc "px") in
    let: "$r0" := #true in
    do:  ((struct.field_ref #Paxos #"hb"%go (![#ptrT] "px")) <-[#boolT] "$r0")).

(* go: paxos.go:516:18 *)
Definition Paxos__heartbeated : val :=
  rec: "Paxos__heartbeated" "px" <> :=
    exception_do (let: "px" := (mem.alloc "px") in
    return: (![#boolT] (struct.field_ref #Paxos #"hb"%go (![#ptrT] "px")))).

(* go: paxos.go:520:18 *)
Definition Paxos__LeaderSession : val :=
  rec: "Paxos__LeaderSession" "px" <> :=
    exception_do (let: "px" := (mem.alloc "px") in
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref #Paxos #"mu"%go (![#ptrT] "px")))) #());;;
      do:  ((method_call #sync #"Cond'ptr" #"Wait" (![#ptrT] (struct.field_ref #Paxos #"cv"%go (![#ptrT] "px")))) #());;;
      (if: (~ ((method_call #paxos.paxos #"Paxos'ptr" #"leading" (![#ptrT] "px")) #()))
      then
        do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Paxos #"mu"%go (![#ptrT] "px")))) #());;;
        continue: #()
      else do:  #());;;
      let: "$range" := (![#sliceT] (struct.field_ref #Paxos #"peers"%go (![#ptrT] "px"))) in
      (let: "nidloop" := (mem.alloc (type.zero_val #intT)) in
      slice.for_range #uint64T "$range" (λ: "$key" "$value",
        do:  ("nidloop" <-[#uint64T] "$value");;;
        do:  "$key";;;
        let: "nid" := (mem.alloc (type.zero_val #uint64T)) in
        let: "$r0" := (![#uint64T] "nidloop") in
        do:  ("nid" <-[#uint64T] "$r0");;;
        let: "ents" := (mem.alloc (type.zero_val #sliceT)) in
        let: "lsne" := (mem.alloc (type.zero_val #uint64T)) in
        let: ("$ret0", "$ret1") := (let: "$a0" := (![#uint64T] "nid") in
        (method_call #paxos.paxos #"Paxos'ptr" #"obtain" (![#ptrT] "px")) "$a0") in
        let: "$r0" := "$ret0" in
        let: "$r1" := "$ret1" in
        do:  ("lsne" <-[#uint64T] "$r0");;;
        do:  ("ents" <-[#sliceT] "$r1");;;
        let: "termc" := (mem.alloc (type.zero_val #uint64T)) in
        let: "$r0" := ((method_call #paxos.paxos #"Paxos'ptr" #"gettermc" (![#ptrT] "px")) #()) in
        do:  ("termc" <-[#uint64T] "$r0");;;
        let: "lsnc" := (mem.alloc (type.zero_val #uint64T)) in
        let: "$r0" := ((method_call #paxos.paxos #"Paxos'ptr" #"getlsnc" (![#ptrT] "px")) #()) in
        do:  ("lsnc" <-[#uint64T] "$r0");;;
        let: "$go" := (λ: <>,
          exception_do (let: "data" := (mem.alloc (type.zero_val #sliceT)) in
          let: "$r0" := (let: "$a0" := (![#uint64T] "termc") in
          let: "$a1" := (![#uint64T] "lsnc") in
          let: "$a2" := (![#uint64T] "lsne") in
          let: "$a3" := (![#sliceT] "ents") in
          (func_call #paxos.paxos #"EncodeAcceptRequest"%go) "$a0" "$a1" "$a2" "$a3") in
          do:  ("data" <-[#sliceT] "$r0");;;
          do:  (let: "$a0" := (![#uint64T] "nid") in
          let: "$a1" := (![#sliceT] "data") in
          (method_call #paxos.paxos #"Paxos'ptr" #"Send" (![#ptrT] "px")) "$a0" "$a1"))
          ) in
        do:  (Fork ("$go" #()))));;;
      do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Paxos #"mu"%go (![#ptrT] "px")))) #()))).

(* go: paxos.go:550:18 *)
Definition Paxos__HeartbeatSession : val :=
  rec: "Paxos__HeartbeatSession" "px" <> :=
    exception_do (let: "px" := (mem.alloc "px") in
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      do:  (let: "$a0" := params.NS_HEARTBEAT_INTERVAL in
      (func_call #primitive.primitive #"Sleep"%go) "$a0");;;
      do:  ((method_call #sync #"Cond'ptr" #"Broadcast" (![#ptrT] (struct.field_ref #Paxos #"cv"%go (![#ptrT] "px")))) #()))).

(* go: paxos.go:557:18 *)
Definition Paxos__ElectionSession : val :=
  rec: "Paxos__ElectionSession" "px" <> :=
    exception_do (let: "px" := (mem.alloc "px") in
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "delta" := (mem.alloc (type.zero_val #uint64T)) in
      let: "$r0" := (((func_call #primitive.primitive #"RandomUint64"%go) #()) `rem` params.NS_ELECTION_TIMEOUT_DELTA) in
      do:  ("delta" <-[#uint64T] "$r0");;;
      do:  (let: "$a0" := (params.NS_ELECTION_TIMEOUT_BASE + (![#uint64T] "delta")) in
      (func_call #primitive.primitive #"Sleep"%go) "$a0");;;
      do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref #Paxos #"mu"%go (![#ptrT] "px")))) #());;;
      (if: (method_call #paxos.paxos #"Paxos'ptr" #"leading" (![#ptrT] "px")) #()
      then
        do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Paxos #"mu"%go (![#ptrT] "px")))) #());;;
        continue: #()
      else do:  #());;;
      (if: (method_call #paxos.paxos #"Paxos'ptr" #"heartbeated" (![#ptrT] "px")) #()
      then
        do:  ((method_call #paxos.paxos #"Paxos'ptr" #"resethb" (![#ptrT] "px")) #());;;
        do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Paxos #"mu"%go (![#ptrT] "px")))) #());;;
        continue: #()
      else do:  #());;;
      let: "termc" := (mem.alloc (type.zero_val #uint64T)) in
      let: "lsnc" := (mem.alloc (type.zero_val #uint64T)) in
      (if: (method_call #paxos.paxos #"Paxos'ptr" #"nominated" (![#ptrT] "px")) #()
      then
        let: "$r0" := ((method_call #paxos.paxos #"Paxos'ptr" #"gettermc" (![#ptrT] "px")) #()) in
        do:  ("termc" <-[#uint64T] "$r0");;;
        let: "$r0" := ((method_call #paxos.paxos #"Paxos'ptr" #"getlsnc" (![#ptrT] "px")) #()) in
        do:  ("lsnc" <-[#uint64T] "$r0")
      else
        let: ("$ret0", "$ret1") := ((method_call #paxos.paxos #"Paxos'ptr" #"nominate" (![#ptrT] "px")) #()) in
        let: "$r0" := "$ret0" in
        let: "$r1" := "$ret1" in
        do:  ("termc" <-[#uint64T] "$r0");;;
        do:  ("lsnc" <-[#uint64T] "$r1"));;;
      do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Paxos #"mu"%go (![#ptrT] "px")))) #());;;
      let: "$range" := (![#sliceT] (struct.field_ref #Paxos #"peers"%go (![#ptrT] "px"))) in
      (let: "nidloop" := (mem.alloc (type.zero_val #intT)) in
      slice.for_range #uint64T "$range" (λ: "$key" "$value",
        do:  ("nidloop" <-[#uint64T] "$value");;;
        do:  "$key";;;
        let: "nid" := (mem.alloc (type.zero_val #uint64T)) in
        let: "$r0" := (![#uint64T] "nidloop") in
        do:  ("nid" <-[#uint64T] "$r0");;;
        let: "$go" := (λ: <>,
          exception_do (let: "data" := (mem.alloc (type.zero_val #sliceT)) in
          let: "$r0" := (let: "$a0" := (![#uint64T] "termc") in
          let: "$a1" := (![#uint64T] "lsnc") in
          (func_call #paxos.paxos #"EncodePrepareRequest"%go) "$a0" "$a1") in
          do:  ("data" <-[#sliceT] "$r0");;;
          do:  (let: "$a0" := (![#uint64T] "nid") in
          let: "$a1" := (![#sliceT] "data") in
          (method_call #paxos.paxos #"Paxos'ptr" #"Send" (![#ptrT] "px")) "$a0" "$a1"))
          ) in
        do:  (Fork ("$go" #())))))).

Definition MSG_ACCEPT : expr := #(W64 1).

Definition PaxosResponse : go_type := structT [
  "Kind" :: uint64T;
  "NodeID" :: uint64T;
  "Term" :: uint64T;
  "EntriesTerm" :: uint64T;
  "Entries" :: sliceT;
  "MatchedLSN" :: uint64T
].

Definition MSG_PREPARE : expr := #(W64 0).

(* go: paxos.go:596:18 *)
Definition Paxos__ResponseSession : val :=
  rec: "Paxos__ResponseSession" "px" "nid" :=
    exception_do (let: "px" := (mem.alloc "px") in
    let: "nid" := (mem.alloc "nid") in
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "ok" := (mem.alloc (type.zero_val #boolT)) in
      let: "data" := (mem.alloc (type.zero_val #sliceT)) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![#uint64T] "nid") in
      (method_call #paxos.paxos #"Paxos'ptr" #"Receive" (![#ptrT] "px")) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("data" <-[#sliceT] "$r0");;;
      do:  ("ok" <-[#boolT] "$r1");;;
      (if: (~ (![#boolT] "ok"))
      then
        do:  (let: "$a0" := params.NS_RECONNECT in
        (func_call #primitive.primitive #"Sleep"%go) "$a0");;;
        continue: #()
      else do:  #());;;
      let: "resp" := (mem.alloc (type.zero_val #PaxosResponse)) in
      let: "$r0" := (let: "$a0" := (![#sliceT] "data") in
      (func_call #paxos.paxos #"DecodeResponse"%go) "$a0") in
      do:  ("resp" <-[#PaxosResponse] "$r0");;;
      let: "kind" := (mem.alloc (type.zero_val #uint64T)) in
      let: "$r0" := (![#uint64T] (struct.field_ref #PaxosResponse #"Kind"%go "resp")) in
      do:  ("kind" <-[#uint64T] "$r0");;;
      do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref #Paxos #"mu"%go (![#ptrT] "px")))) #());;;
      (if: let: "$a0" := (![#uint64T] (struct.field_ref #PaxosResponse #"Term"%go "resp")) in
      (method_call #paxos.paxos #"Paxos'ptr" #"lttermc" (![#ptrT] "px")) "$a0"
      then
        do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Paxos #"mu"%go (![#ptrT] "px")))) #());;;
        continue: #()
      else do:  #());;;
      (if: let: "$a0" := (![#uint64T] (struct.field_ref #PaxosResponse #"Term"%go "resp")) in
      (method_call #paxos.paxos #"Paxos'ptr" #"gttermc" (![#ptrT] "px")) "$a0"
      then
        do:  (let: "$a0" := (![#uint64T] (struct.field_ref #PaxosResponse #"Term"%go "resp")) in
        (method_call #paxos.paxos #"Paxos'ptr" #"stepdown" (![#ptrT] "px")) "$a0");;;
        do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Paxos #"mu"%go (![#ptrT] "px")))) #());;;
        continue: #()
      else do:  #());;;
      (if: (![#uint64T] "kind") = MSG_PREPARE
      then
        (if: (~ ((method_call #paxos.paxos #"Paxos'ptr" #"nominated" (![#ptrT] "px")) #()))
        then
          do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Paxos #"mu"%go (![#ptrT] "px")))) #());;;
          continue: #()
        else do:  #());;;
        do:  (let: "$a0" := (![#uint64T] (struct.field_ref #PaxosResponse #"NodeID"%go "resp")) in
        let: "$a1" := (![#uint64T] (struct.field_ref #PaxosResponse #"EntriesTerm"%go "resp")) in
        let: "$a2" := (![#sliceT] (struct.field_ref #PaxosResponse #"Entries"%go "resp")) in
        (method_call #paxos.paxos #"Paxos'ptr" #"collect" (![#ptrT] "px")) "$a0" "$a1" "$a2");;;
        do:  ((method_call #paxos.paxos #"Paxos'ptr" #"ascend" (![#ptrT] "px")) #());;;
        do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Paxos #"mu"%go (![#ptrT] "px")))) #())
      else
        (if: (![#uint64T] "kind") = MSG_ACCEPT
        then
          (if: (~ ((method_call #paxos.paxos #"Paxos'ptr" #"leading" (![#ptrT] "px")) #()))
          then
            do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Paxos #"mu"%go (![#ptrT] "px")))) #());;;
            continue: #()
          else do:  #());;;
          (if: (![#uint64T] (struct.field_ref #PaxosResponse #"NodeID"%go "resp")) = (![#uint64T] (struct.field_ref #Paxos #"nidme"%go (![#ptrT] "px")))
          then
            do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Paxos #"mu"%go (![#ptrT] "px")))) #());;;
            continue: #()
          else do:  #());;;
          let: "forwarded" := (mem.alloc (type.zero_val #boolT)) in
          let: "$r0" := (let: "$a0" := (![#uint64T] (struct.field_ref #PaxosResponse #"NodeID"%go "resp")) in
          let: "$a1" := (![#uint64T] (struct.field_ref #PaxosResponse #"MatchedLSN"%go "resp")) in
          (method_call #paxos.paxos #"Paxos'ptr" #"forward" (![#ptrT] "px")) "$a0" "$a1") in
          do:  ("forwarded" <-[#boolT] "$r0");;;
          (if: (~ (![#boolT] "forwarded"))
          then
            do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Paxos #"mu"%go (![#ptrT] "px")))) #());;;
            continue: #()
          else do:  #());;;
          let: "pushed" := (mem.alloc (type.zero_val #boolT)) in
          let: "lsnc" := (mem.alloc (type.zero_val #uint64T)) in
          let: ("$ret0", "$ret1") := ((method_call #paxos.paxos #"Paxos'ptr" #"push" (![#ptrT] "px")) #()) in
          let: "$r0" := "$ret0" in
          let: "$r1" := "$ret1" in
          do:  ("lsnc" <-[#uint64T] "$r0");;;
          do:  ("pushed" <-[#boolT] "$r1");;;
          (if: (~ (![#boolT] "pushed"))
          then
            do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Paxos #"mu"%go (![#ptrT] "px")))) #());;;
            continue: #()
          else do:  #());;;
          do:  (let: "$a0" := (![#uint64T] "lsnc") in
          (method_call #paxos.paxos #"Paxos'ptr" #"commit" (![#ptrT] "px")) "$a0");;;
          do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Paxos #"mu"%go (![#ptrT] "px")))) #())
        else do:  #())))).

Definition PaxosRequest : go_type := structT [
  "Kind" :: uint64T;
  "Term" :: uint64T;
  "CommittedLSN" :: uint64T;
  "EntriesLSN" :: uint64T;
  "Entries" :: sliceT
].

(* go: paxos.go:674:18 *)
Definition Paxos__RequestSession : val :=
  rec: "Paxos__RequestSession" "px" "conn" :=
    exception_do (let: "px" := (mem.alloc "px") in
    let: "conn" := (mem.alloc "conn") in
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "ret" := (mem.alloc (type.zero_val #grove_ffi.ReceiveRet)) in
      let: "$r0" := (let: "$a0" := (![#grove_ffi.Connection] "conn") in
      (func_call #grove_ffi.grove_ffi #"Receive"%go) "$a0") in
      do:  ("ret" <-[#grove_ffi.ReceiveRet] "$r0");;;
      (if: ![#boolT] (struct.field_ref #grove_ffi.ReceiveRet #"Err"%go "ret")
      then break: #()
      else do:  #());;;
      let: "req" := (mem.alloc (type.zero_val #PaxosRequest)) in
      let: "$r0" := (let: "$a0" := (![#sliceT] (struct.field_ref #grove_ffi.ReceiveRet #"Data"%go "ret")) in
      (func_call #paxos.paxos #"DecodeRequest"%go) "$a0") in
      do:  ("req" <-[#PaxosRequest] "$r0");;;
      let: "kind" := (mem.alloc (type.zero_val #uint64T)) in
      let: "$r0" := (![#uint64T] (struct.field_ref #PaxosRequest #"Kind"%go "req")) in
      do:  ("kind" <-[#uint64T] "$r0");;;
      do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref #Paxos #"mu"%go (![#ptrT] "px")))) #());;;
      (if: let: "$a0" := (![#uint64T] (struct.field_ref #PaxosRequest #"Term"%go "req")) in
      (method_call #paxos.paxos #"Paxos'ptr" #"lttermc" (![#ptrT] "px")) "$a0"
      then
        do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Paxos #"mu"%go (![#ptrT] "px")))) #());;;
        continue: #()
      else do:  #());;;
      do:  (let: "$a0" := (![#uint64T] (struct.field_ref #PaxosRequest #"Term"%go "req")) in
      (method_call #paxos.paxos #"Paxos'ptr" #"stepdown" (![#ptrT] "px")) "$a0");;;
      do:  ((method_call #paxos.paxos #"Paxos'ptr" #"heartbeat" (![#ptrT] "px")) #());;;
      let: "termc" := (mem.alloc (type.zero_val #uint64T)) in
      let: "$r0" := ((method_call #paxos.paxos #"Paxos'ptr" #"gettermc" (![#ptrT] "px")) #()) in
      do:  ("termc" <-[#uint64T] "$r0");;;
      (if: (![#uint64T] "kind") = MSG_PREPARE
      then
        (if: (method_call #paxos.paxos #"Paxos'ptr" #"latest" (![#ptrT] "px")) #()
        then
          do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Paxos #"mu"%go (![#ptrT] "px")))) #());;;
          continue: #()
        else do:  #());;;
        let: "ents" := (mem.alloc (type.zero_val #sliceT)) in
        let: "terml" := (mem.alloc (type.zero_val #uint64T)) in
        let: ("$ret0", "$ret1") := (let: "$a0" := (![#uint64T] (struct.field_ref #PaxosRequest #"CommittedLSN"%go "req")) in
        (method_call #paxos.paxos #"Paxos'ptr" #"prepare" (![#ptrT] "px")) "$a0") in
        let: "$r0" := "$ret0" in
        let: "$r1" := "$ret1" in
        do:  ("terml" <-[#uint64T] "$r0");;;
        do:  ("ents" <-[#sliceT] "$r1");;;
        do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Paxos #"mu"%go (![#ptrT] "px")))) #());;;
        let: "data" := (mem.alloc (type.zero_val #sliceT)) in
        let: "$r0" := (let: "$a0" := (![#uint64T] (struct.field_ref #Paxos #"nidme"%go (![#ptrT] "px"))) in
        let: "$a1" := (![#uint64T] "termc") in
        let: "$a2" := (![#uint64T] "terml") in
        let: "$a3" := (![#sliceT] "ents") in
        (func_call #paxos.paxos #"EncodePrepareResponse"%go) "$a0" "$a1" "$a2" "$a3") in
        do:  ("data" <-[#sliceT] "$r0");;;
        do:  (let: "$a0" := (![#grove_ffi.Connection] "conn") in
        let: "$a1" := (![#sliceT] "data") in
        (func_call #grove_ffi.grove_ffi #"Send"%go) "$a0" "$a1")
      else
        (if: (![#uint64T] "kind") = MSG_ACCEPT
        then
          let: "lsn" := (mem.alloc (type.zero_val #uint64T)) in
          let: "$r0" := (let: "$a0" := (![#uint64T] (struct.field_ref #PaxosRequest #"EntriesLSN"%go "req")) in
          let: "$a1" := (![#uint64T] (struct.field_ref #PaxosRequest #"Term"%go "req")) in
          let: "$a2" := (![#sliceT] (struct.field_ref #PaxosRequest #"Entries"%go "req")) in
          (method_call #paxos.paxos #"Paxos'ptr" #"accept" (![#ptrT] "px")) "$a0" "$a1" "$a2") in
          do:  ("lsn" <-[#uint64T] "$r0");;;
          do:  (let: "$a0" := (![#uint64T] (struct.field_ref #PaxosRequest #"CommittedLSN"%go "req")) in
          let: "$a1" := (![#uint64T] (struct.field_ref #PaxosRequest #"Term"%go "req")) in
          (method_call #paxos.paxos #"Paxos'ptr" #"learn" (![#ptrT] "px")) "$a0" "$a1");;;
          do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Paxos #"mu"%go (![#ptrT] "px")))) #());;;
          let: "data" := (mem.alloc (type.zero_val #sliceT)) in
          let: "$r0" := (let: "$a0" := (![#uint64T] (struct.field_ref #Paxos #"nidme"%go (![#ptrT] "px"))) in
          let: "$a1" := (![#uint64T] "termc") in
          let: "$a2" := (![#uint64T] "lsn") in
          (func_call #paxos.paxos #"EncodeAcceptResponse"%go) "$a0" "$a1" "$a2") in
          do:  ("data" <-[#sliceT] "$r0");;;
          do:  (let: "$a0" := (![#grove_ffi.Connection] "conn") in
          let: "$a1" := (![#sliceT] "data") in
          (func_call #grove_ffi.grove_ffi #"Send"%go) "$a0" "$a1")
        else do:  #())))).

(* go: paxos.go:731:18 *)
Definition Paxos__Serve : val :=
  rec: "Paxos__Serve" "px" <> :=
    exception_do (let: "px" := (mem.alloc "px") in
    let: "addrme" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (Fst (map.get (![type.mapT #uint64T #uint64T] (struct.field_ref #Paxos #"addrm"%go (![#ptrT] "px"))) (![#uint64T] (struct.field_ref #Paxos #"nidme"%go (![#ptrT] "px"))))) in
    do:  ("addrme" <-[#uint64T] "$r0");;;
    let: "ls" := (mem.alloc (type.zero_val #grove_ffi.Listener)) in
    let: "$r0" := (let: "$a0" := (![#uint64T] "addrme") in
    (func_call #grove_ffi.grove_ffi #"Listen"%go) "$a0") in
    do:  ("ls" <-[#grove_ffi.Listener] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "conn" := (mem.alloc (type.zero_val #grove_ffi.Connection)) in
      let: "$r0" := (let: "$a0" := (![#grove_ffi.Listener] "ls") in
      (func_call #grove_ffi.grove_ffi #"Accept"%go) "$a0") in
      do:  ("conn" <-[#grove_ffi.Connection] "$r0");;;
      let: "$go" := (λ: <>,
        exception_do (do:  (let: "$a0" := (![#grove_ffi.Connection] "conn") in
        (method_call #paxos.paxos #"Paxos'ptr" #"RequestSession" (![#ptrT] "px")) "$a0"))
        ) in
      do:  (Fork ("$go" #())))).

(* go: paxos.go:742:18 *)
Definition Paxos__GetConnection : val :=
  rec: "Paxos__GetConnection" "px" "nid" :=
    exception_do (let: "px" := (mem.alloc "px") in
    let: "nid" := (mem.alloc "nid") in
    do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref #Paxos #"mu"%go (![#ptrT] "px")))) #());;;
    let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "conn" := (mem.alloc (type.zero_val #grove_ffi.Connection)) in
    let: ("$ret0", "$ret1") := (map.get (![type.mapT #uint64T #grove_ffi.Connection] (struct.field_ref #Paxos #"conns"%go (![#ptrT] "px"))) (![#uint64T] "nid")) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("conn" <-[#grove_ffi.Connection] "$r0");;;
    do:  ("ok" <-[#boolT] "$r1");;;
    do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Paxos #"mu"%go (![#ptrT] "px")))) #());;;
    return: (![#grove_ffi.Connection] "conn", ![#boolT] "ok")).

(* go: paxos.go:749:18 *)
Definition Paxos__Connect : val :=
  rec: "Paxos__Connect" "px" "nid" :=
    exception_do (let: "px" := (mem.alloc "px") in
    let: "nid" := (mem.alloc "nid") in
    let: "addr" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (Fst (map.get (![type.mapT #uint64T #uint64T] (struct.field_ref #Paxos #"addrm"%go (![#ptrT] "px"))) (![#uint64T] "nid"))) in
    do:  ("addr" <-[#uint64T] "$r0");;;
    let: "ret" := (mem.alloc (type.zero_val #grove_ffi.ConnectRet)) in
    let: "$r0" := (let: "$a0" := (![#uint64T] "addr") in
    (func_call #grove_ffi.grove_ffi #"Connect"%go) "$a0") in
    do:  ("ret" <-[#grove_ffi.ConnectRet] "$r0");;;
    (if: (~ (![#boolT] (struct.field_ref #grove_ffi.ConnectRet #"Err"%go "ret")))
    then
      do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref #Paxos #"mu"%go (![#ptrT] "px")))) #());;;
      let: "$r0" := (![#grove_ffi.Connection] (struct.field_ref #grove_ffi.ConnectRet #"Connection"%go "ret")) in
      do:  (map.insert (![type.mapT #uint64T #grove_ffi.Connection] (struct.field_ref #Paxos #"conns"%go (![#ptrT] "px"))) (![#uint64T] "nid") "$r0");;;
      do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Paxos #"mu"%go (![#ptrT] "px")))) #());;;
      return: (#true)
    else do:  #());;;
    return: (#false)).

(* go: paxos.go:762:18 *)
Definition Paxos__ConnectAll : val :=
  rec: "Paxos__ConnectAll" "px" <> :=
    exception_do (let: "px" := (mem.alloc "px") in
    let: "$range" := (![#sliceT] (struct.field_ref #Paxos #"peers"%go (![#ptrT] "px"))) in
    (let: "nid" := (mem.alloc (type.zero_val #intT)) in
    slice.for_range #uint64T "$range" (λ: "$key" "$value",
      do:  ("nid" <-[#uint64T] "$value");;;
      do:  "$key";;;
      do:  (let: "$a0" := (![#uint64T] "nid") in
      (method_call #paxos.paxos #"Paxos'ptr" #"Connect" (![#ptrT] "px")) "$a0")))).

(* go: paxos.go:768:18 *)
Definition Paxos__Send : val :=
  rec: "Paxos__Send" "px" "nid" "data" :=
    exception_do (let: "px" := (mem.alloc "px") in
    let: "data" := (mem.alloc "data") in
    let: "nid" := (mem.alloc "nid") in
    let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "conn" := (mem.alloc (type.zero_val #grove_ffi.Connection)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#uint64T] "nid") in
    (method_call #paxos.paxos #"Paxos'ptr" #"GetConnection" (![#ptrT] "px")) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("conn" <-[#grove_ffi.Connection] "$r0");;;
    do:  ("ok" <-[#boolT] "$r1");;;
    (if: (~ (![#boolT] "ok"))
    then
      do:  (let: "$a0" := (![#uint64T] "nid") in
      (method_call #paxos.paxos #"Paxos'ptr" #"Connect" (![#ptrT] "px")) "$a0");;;
      return: (#())
    else do:  #());;;
    let: "err" := (mem.alloc (type.zero_val #boolT)) in
    let: "$r0" := (let: "$a0" := (![#grove_ffi.Connection] "conn") in
    let: "$a1" := (![#sliceT] "data") in
    (func_call #grove_ffi.grove_ffi #"Send"%go) "$a0" "$a1") in
    do:  ("err" <-[#boolT] "$r0");;;
    (if: ![#boolT] "err"
    then
      do:  (let: "$a0" := (![#uint64T] "nid") in
      (method_call #paxos.paxos #"Paxos'ptr" #"Connect" (![#ptrT] "px")) "$a0")
    else do:  #())).

(* go: paxos.go:781:18 *)
Definition Paxos__Receive : val :=
  rec: "Paxos__Receive" "px" "nid" :=
    exception_do (let: "px" := (mem.alloc "px") in
    let: "nid" := (mem.alloc "nid") in
    let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "conn" := (mem.alloc (type.zero_val #grove_ffi.Connection)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#uint64T] "nid") in
    (method_call #paxos.paxos #"Paxos'ptr" #"GetConnection" (![#ptrT] "px")) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("conn" <-[#grove_ffi.Connection] "$r0");;;
    do:  ("ok" <-[#boolT] "$r1");;;
    (if: (~ (![#boolT] "ok"))
    then
      do:  (let: "$a0" := (![#uint64T] "nid") in
      (method_call #paxos.paxos #"Paxos'ptr" #"Connect" (![#ptrT] "px")) "$a0");;;
      return: (#slice.nil, #false)
    else do:  #());;;
    let: "ret" := (mem.alloc (type.zero_val #grove_ffi.ReceiveRet)) in
    let: "$r0" := (let: "$a0" := (![#grove_ffi.Connection] "conn") in
    (func_call #grove_ffi.grove_ffi #"Receive"%go) "$a0") in
    do:  ("ret" <-[#grove_ffi.ReceiveRet] "$r0");;;
    (if: ![#boolT] (struct.field_ref #grove_ffi.ReceiveRet #"Err"%go "ret")
    then
      do:  (let: "$a0" := (![#uint64T] "nid") in
      (method_call #paxos.paxos #"Paxos'ptr" #"Connect" (![#ptrT] "px")) "$a0");;;
      return: (#slice.nil, #false)
    else do:  #());;;
    return: (![#sliceT] (struct.field_ref #grove_ffi.ReceiveRet #"Data"%go "ret"), #true)).

(* go: paxos.go:797:18 *)
Definition Paxos__cquorum : val :=
  rec: "Paxos__cquorum" "px" "n" :=
    exception_do (let: "px" := (mem.alloc "px") in
    let: "n" := (mem.alloc "n") in
    return: ((let: "$a0" := (![#uint64T] (struct.field_ref #Paxos #"sc"%go (![#ptrT] "px"))) in
     (func_call #quorum.quorum #"ClassicQuorum"%go) "$a0") ≤ (![#uint64T] "n"))).

(* go: paxos.go:801:18 *)
Definition Paxos__DumpState : val :=
  rec: "Paxos__DumpState" "px" <> :=
    exception_do (let: "px" := (mem.alloc "px") in
    do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref #Paxos #"mu"%go (![#ptrT] "px")))) #());;;
    do:  (let: "$a0" := #"Current term: %d
    "%go in
    let: "$a1" := ((let: "$sl0" := (interface.make #""%go #"uint64"%go (![#uint64T] (struct.field_ref #Paxos #"termc"%go (![#ptrT] "px")))) in
    slice.literal #interfaceT ["$sl0"])) in
    (func_call #fmt.fmt #"Printf"%go) "$a0" "$a1");;;
    do:  (let: "$a0" := #"Ledger term: %d
    "%go in
    let: "$a1" := ((let: "$sl0" := (interface.make #""%go #"uint64"%go (![#uint64T] (struct.field_ref #Paxos #"terml"%go (![#ptrT] "px")))) in
    slice.literal #interfaceT ["$sl0"])) in
    (func_call #fmt.fmt #"Printf"%go) "$a0" "$a1");;;
    do:  (let: "$a0" := #"Number of log entries: %d
    "%go in
    let: "$a1" := ((let: "$sl0" := (interface.make #""%go #"uint64"%go (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref #Paxos #"log"%go (![#ptrT] "px"))) in
    slice.len "$a0"))) in
    slice.literal #interfaceT ["$sl0"])) in
    (func_call #fmt.fmt #"Printf"%go) "$a0" "$a1");;;
    do:  (let: "$a0" := #"Committed LSN: %d
    "%go in
    let: "$a1" := ((let: "$sl0" := (interface.make #""%go #"uint64"%go (![#uint64T] (struct.field_ref #Paxos #"lsnc"%go (![#ptrT] "px")))) in
    slice.literal #interfaceT ["$sl0"])) in
    (func_call #fmt.fmt #"Printf"%go) "$a0" "$a1");;;
    do:  (let: "$a0" := #"Is candidate / leader: %t / %t
    "%go in
    let: "$a1" := ((let: "$sl0" := (interface.make #""%go #"bool"%go (![#boolT] (struct.field_ref #Paxos #"iscand"%go (![#ptrT] "px")))) in
    let: "$sl1" := (interface.make #""%go #"bool"%go (![#boolT] (struct.field_ref #Paxos #"isleader"%go (![#ptrT] "px")))) in
    slice.literal #interfaceT ["$sl0"; "$sl1"])) in
    (func_call #fmt.fmt #"Printf"%go) "$a0" "$a1");;;
    (if: ![#boolT] (struct.field_ref #Paxos #"iscand"%go (![#ptrT] "px"))
    then
      do:  (let: "$a0" := #"Candidate state:
      "%go in
      let: "$a1" := #slice.nil in
      (func_call #fmt.fmt #"Printf"%go) "$a0" "$a1");;;
      do:  (let: "$a0" := #"Largest term seen in prepare: %d
      "%go in
      let: "$a1" := ((let: "$sl0" := (interface.make #""%go #"uint64"%go (![#uint64T] (struct.field_ref #Paxos #"termp"%go (![#ptrT] "px")))) in
      slice.literal #interfaceT ["$sl0"])) in
      (func_call #fmt.fmt #"Printf"%go) "$a0" "$a1");;;
      do:  (let: "$a0" := #"Longest log after committed LSN in prepare: %d
      "%go in
      let: "$a1" := ((let: "$sl0" := (interface.make #""%go #"uint64"%go (![#uint64T] (struct.field_ref #Paxos #"termp"%go (![#ptrT] "px")))) in
      slice.literal #interfaceT ["$sl0"])) in
      (func_call #fmt.fmt #"Printf"%go) "$a0" "$a1");;;
      do:  (let: "$a0" := #"Number of votes granted: %d
      "%go in
      let: "$a1" := ((let: "$sl0" := (interface.make #""%go #"uint64"%go (s_to_w64 (let: "$a0" := (![type.mapT #uint64T #boolT] (struct.field_ref #Paxos #"respp"%go (![#ptrT] "px"))) in
      map.len "$a0"))) in
      slice.literal #interfaceT ["$sl0"])) in
      (func_call #fmt.fmt #"Printf"%go) "$a0" "$a1")
    else do:  #());;;
    (if: ![#boolT] (struct.field_ref #Paxos #"isleader"%go (![#ptrT] "px"))
    then
      do:  (let: "$a0" := #"Leader state:
      "%go in
      let: "$a1" := #slice.nil in
      (func_call #fmt.fmt #"Printf"%go) "$a0" "$a1");;;
      do:  (let: "$a0" := #"Match LSN for each peer:
      "%go in
      let: "$a1" := #slice.nil in
      (func_call #fmt.fmt #"Printf"%go) "$a0" "$a1");;;
      let: "$range" := (![type.mapT #uint64T #uint64T] (struct.field_ref #Paxos #"lsnpeers"%go (![#ptrT] "px"))) in
      (let: "lsnpeer" := (mem.alloc (type.zero_val #uint64T)) in
      let: "nid" := (mem.alloc (type.zero_val #uint64T)) in
      map.for_range "$range" (λ: "$key" "value",
        do:  ("lsnpeer" <-[#uint64T] "$value");;;
        do:  ("nid" <-[#uint64T] "$key");;;
        do:  (let: "$a0" := #"Peer %d -> %d
        "%go in
        let: "$a1" := ((let: "$sl0" := (interface.make #""%go #"uint64"%go (![#uint64T] "nid")) in
        let: "$sl1" := (interface.make #""%go #"uint64"%go (![#uint64T] "lsnpeer")) in
        slice.literal #interfaceT ["$sl0"; "$sl1"])) in
        (func_call #fmt.fmt #"Printf"%go) "$a0" "$a1")))
    else do:  #());;;
    do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Paxos #"mu"%go (![#ptrT] "px")))) #())).

(* go: paxos.go:824:18 *)
Definition Paxos__ForceElection : val :=
  rec: "Paxos__ForceElection" "px" <> :=
    exception_do (let: "px" := (mem.alloc "px") in
    do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref #Paxos #"mu"%go (![#ptrT] "px")))) #());;;
    let: "lsnc" := (mem.alloc (type.zero_val #uint64T)) in
    let: "termc" := (mem.alloc (type.zero_val #uint64T)) in
    let: ("$ret0", "$ret1") := ((method_call #paxos.paxos #"Paxos'ptr" #"nominate" (![#ptrT] "px")) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("termc" <-[#uint64T] "$r0");;;
    do:  ("lsnc" <-[#uint64T] "$r1");;;
    do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Paxos #"mu"%go (![#ptrT] "px")))) #());;;
    let: "$range" := (![#sliceT] (struct.field_ref #Paxos #"peers"%go (![#ptrT] "px"))) in
    (let: "nidloop" := (mem.alloc (type.zero_val #intT)) in
    slice.for_range #uint64T "$range" (λ: "$key" "$value",
      do:  ("nidloop" <-[#uint64T] "$value");;;
      do:  "$key";;;
      let: "nid" := (mem.alloc (type.zero_val #uint64T)) in
      let: "$r0" := (![#uint64T] "nidloop") in
      do:  ("nid" <-[#uint64T] "$r0");;;
      let: "$go" := (λ: <>,
        exception_do (let: "data" := (mem.alloc (type.zero_val #sliceT)) in
        let: "$r0" := (let: "$a0" := (![#uint64T] "termc") in
        let: "$a1" := (![#uint64T] "lsnc") in
        (func_call #paxos.paxos #"EncodePrepareRequest"%go) "$a0" "$a1") in
        do:  ("data" <-[#sliceT] "$r0");;;
        do:  (let: "$a0" := (![#uint64T] "nid") in
        let: "$a1" := (![#sliceT] "data") in
        (method_call #paxos.paxos #"Paxos'ptr" #"Send" (![#ptrT] "px")) "$a0" "$a1"))
        ) in
      do:  (Fork ("$go" #()))))).

(* go: paxos.go:838:6 *)
Definition mkPaxos : val :=
  rec: "mkPaxos" "nidme" "termc" "terml" "lsnc" "log" "addrm" "fname" :=
    exception_do (let: "fname" := (mem.alloc "fname") in
    let: "addrm" := (mem.alloc "addrm") in
    let: "log" := (mem.alloc "log") in
    let: "lsnc" := (mem.alloc "lsnc") in
    let: "terml" := (mem.alloc "terml") in
    let: "termc" := (mem.alloc "termc") in
    let: "nidme" := (mem.alloc "nidme") in
    let: "sc" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (s_to_w64 (let: "$a0" := (![type.mapT #uint64T #uint64T] "addrm") in
    map.len "$a0")) in
    do:  ("sc" <-[#uint64T] "$r0");;;
    let: "peers" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make3 #uint64T #(W64 0) ((![#uint64T] "sc") - #(W64 1))) in
    do:  ("peers" <-[#sliceT] "$r0");;;
    let: "$range" := (![type.mapT #uint64T #uint64T] "addrm") in
    (let: "nid" := (mem.alloc (type.zero_val #uint64T)) in
    map.for_range "$range" (λ: "$key" "value",
      do:  ("nid" <-[#uint64T] "$key");;;
      (if: (![#uint64T] "nid") ≠ (![#uint64T] "nidme")
      then
        let: "$r0" := (let: "$a0" := (![#sliceT] "peers") in
        let: "$a1" := ((let: "$sl0" := (![#uint64T] "nid") in
        slice.literal #uint64T ["$sl0"])) in
        (slice.append #uint64T) "$a0" "$a1") in
        do:  ("peers" <-[#sliceT] "$r0")
      else do:  #())));;;
    let: "mu" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #sync.Mutex)) in
    do:  ("mu" <-[#ptrT] "$r0");;;
    let: "cv" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := (interface.make #sync #"Mutex'ptr" (![#ptrT] "mu")) in
    (func_call #sync.sync #"NewCond"%go) "$a0") in
    do:  ("cv" <-[#ptrT] "$r0");;;
    let: "px" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (let: "$nidme" := (![#uint64T] "nidme") in
    let: "$peers" := (![#sliceT] "peers") in
    let: "$addrm" := (![type.mapT #uint64T #uint64T] "addrm") in
    let: "$sc" := (![#uint64T] "sc") in
    let: "$fname" := (![#stringT] "fname") in
    let: "$mu" := (![#ptrT] "mu") in
    let: "$cv" := (![#ptrT] "cv") in
    let: "$hb" := #false in
    let: "$termc" := (![#uint64T] "termc") in
    let: "$terml" := (![#uint64T] "terml") in
    let: "$log" := (![#sliceT] "log") in
    let: "$lsnc" := (![#uint64T] "lsnc") in
    let: "$iscand" := #false in
    let: "$isleader" := #false in
    let: "$conns" := (map.make #uint64T #grove_ffi.Connection) in
    struct.make #Paxos [{
      "nidme" ::= "$nidme";
      "peers" ::= "$peers";
      "addrm" ::= "$addrm";
      "sc" ::= "$sc";
      "fname" ::= "$fname";
      "mu" ::= "$mu";
      "cv" ::= "$cv";
      "hb" ::= "$hb";
      "termc" ::= "$termc";
      "terml" ::= "$terml";
      "log" ::= "$log";
      "lsnc" ::= "$lsnc";
      "iscand" ::= "$iscand";
      "isleader" ::= "$isleader";
      "termp" ::= type.zero_val #uint64T;
      "entsp" ::= type.zero_val #sliceT;
      "respp" ::= type.zero_val (type.mapT #uint64T #boolT);
      "lsnpeers" ::= type.zero_val (type.mapT #uint64T #uint64T);
      "conns" ::= "$conns"
    }])) in
    do:  ("px" <-[#ptrT] "$r0");;;
    return: (![#ptrT] "px")).

(* go: paxos.go:871:6 *)
Definition Start : val :=
  rec: "Start" "nidme" "addrm" "fname" :=
    exception_do (let: "fname" := (mem.alloc "fname") in
    let: "addrm" := (mem.alloc "addrm") in
    let: "nidme" := (mem.alloc "nidme") in
    do:  (let: "$a0" := (#(W64 1) < (s_to_w64 (let: "$a0" := (![type.mapT #uint64T #uint64T] "addrm") in
    map.len "$a0"))) in
    (func_call #primitive.primitive #"Assume"%go) "$a0");;;
    let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: ("$ret0", "$ret1") := (map.get (![type.mapT #uint64T #uint64T] "addrm") (![#uint64T] "nidme")) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  "$r0";;;
    do:  ("ok" <-[#boolT] "$r1");;;
    do:  (let: "$a0" := (![#boolT] "ok") in
    (func_call #primitive.primitive #"Assume"%go) "$a0");;;
    do:  (let: "$a0" := ((![#uint64T] "nidme") < MAX_NODES) in
    (func_call #primitive.primitive #"Assume"%go) "$a0");;;
    let: "log" := (mem.alloc (type.zero_val #sliceT)) in
    let: "lsnc" := (mem.alloc (type.zero_val #uint64T)) in
    let: "terml" := (mem.alloc (type.zero_val #uint64T)) in
    let: "termc" := (mem.alloc (type.zero_val #uint64T)) in
    let: ((("$ret0", "$ret1"), "$ret2"), "$ret3") := (let: "$a0" := (![#stringT] "fname") in
    (func_call #paxos.paxos #"resume"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    let: "$r3" := "$ret3" in
    do:  ("termc" <-[#uint64T] "$r0");;;
    do:  ("terml" <-[#uint64T] "$r1");;;
    do:  ("lsnc" <-[#uint64T] "$r2");;;
    do:  ("log" <-[#sliceT] "$r3");;;
    let: "px" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := (![#uint64T] "nidme") in
    let: "$a1" := (![#uint64T] "termc") in
    let: "$a2" := (![#uint64T] "terml") in
    let: "$a3" := (![#uint64T] "lsnc") in
    let: "$a4" := (![#sliceT] "log") in
    let: "$a5" := (![type.mapT #uint64T #uint64T] "addrm") in
    let: "$a6" := (![#stringT] "fname") in
    (func_call #paxos.paxos #"mkPaxos"%go) "$a0" "$a1" "$a2" "$a3" "$a4" "$a5" "$a6") in
    do:  ("px" <-[#ptrT] "$r0");;;
    let: "$go" := (λ: <>,
      exception_do (do:  ((method_call #paxos.paxos #"Paxos'ptr" #"Serve" (![#ptrT] "px")) #()))
      ) in
    do:  (Fork ("$go" #()));;;
    let: "$go" := (λ: <>,
      exception_do (do:  ((method_call #paxos.paxos #"Paxos'ptr" #"LeaderSession" (![#ptrT] "px")) #()))
      ) in
    do:  (Fork ("$go" #()));;;
    let: "$go" := (λ: <>,
      exception_do (do:  ((method_call #paxos.paxos #"Paxos'ptr" #"HeartbeatSession" (![#ptrT] "px")) #()))
      ) in
    do:  (Fork ("$go" #()));;;
    let: "$go" := (λ: <>,
      exception_do (do:  ((method_call #paxos.paxos #"Paxos'ptr" #"ElectionSession" (![#ptrT] "px")) #()))
      ) in
    do:  (Fork ("$go" #()));;;
    let: "$range" := (![#sliceT] (struct.field_ref #Paxos #"peers"%go (![#ptrT] "px"))) in
    (let: "nidloop" := (mem.alloc (type.zero_val #intT)) in
    slice.for_range #uint64T "$range" (λ: "$key" "$value",
      do:  ("nidloop" <-[#uint64T] "$value");;;
      do:  "$key";;;
      let: "nid" := (mem.alloc (type.zero_val #uint64T)) in
      let: "$r0" := (![#uint64T] "nidloop") in
      do:  ("nid" <-[#uint64T] "$r0");;;
      let: "$go" := (λ: <>,
        exception_do (do:  (let: "$a0" := (![#uint64T] "nid") in
        (method_call #paxos.paxos #"Paxos'ptr" #"ResponseSession" (![#ptrT] "px")) "$a0"))
        ) in
      do:  (Fork ("$go" #()))));;;
    return: (![#ptrT] "px")).

(* go: paxos.go:944:6 *)
Definition EncodePrepareRequest : val :=
  rec: "EncodePrepareRequest" "term" "lsnc" :=
    exception_do (let: "lsnc" := (mem.alloc "lsnc") in
    let: "term" := (mem.alloc "term") in
    let: "bs" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make3 #byteT #(W64 0) #(W64 24)) in
    do:  ("bs" <-[#sliceT] "$r0");;;
    let: "bs1" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "bs") in
    let: "$a1" := MSG_PREPARE in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("bs1" <-[#sliceT] "$r0");;;
    let: "bs2" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "bs1") in
    let: "$a1" := (![#uint64T] "term") in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("bs2" <-[#sliceT] "$r0");;;
    let: "data" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "bs2") in
    let: "$a1" := (![#uint64T] "lsnc") in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("data" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "data")).

(* go: paxos.go:954:6 *)
Definition DecodePrepareRequest : val :=
  rec: "DecodePrepareRequest" "bs" :=
    exception_do (let: "bs" := (mem.alloc "bs") in
    let: "bs1" := (mem.alloc (type.zero_val #sliceT)) in
    let: "term" := (mem.alloc (type.zero_val #uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "bs") in
    (func_call #marshal.marshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("term" <-[#uint64T] "$r0");;;
    do:  ("bs1" <-[#sliceT] "$r1");;;
    let: "lsnc" := (mem.alloc (type.zero_val #uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "bs1") in
    (func_call #marshal.marshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("lsnc" <-[#uint64T] "$r0");;;
    do:  "$r1";;;
    return: (let: "$Kind" := MSG_PREPARE in
     let: "$Term" := (![#uint64T] "term") in
     let: "$CommittedLSN" := (![#uint64T] "lsnc") in
     struct.make #PaxosRequest [{
       "Kind" ::= "$Kind";
       "Term" ::= "$Term";
       "CommittedLSN" ::= "$CommittedLSN";
       "EntriesLSN" ::= type.zero_val #uint64T;
       "Entries" ::= type.zero_val #sliceT
     }])).

(* go: paxos.go:965:6 *)
Definition EncodeAcceptRequest : val :=
  rec: "EncodeAcceptRequest" "term" "lsnc" "lsne" "ents" :=
    exception_do (let: "ents" := (mem.alloc "ents") in
    let: "lsne" := (mem.alloc "lsne") in
    let: "lsnc" := (mem.alloc "lsnc") in
    let: "term" := (mem.alloc "term") in
    let: "bs" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make3 #byteT #(W64 0) #(W64 64)) in
    do:  ("bs" <-[#sliceT] "$r0");;;
    let: "bs1" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "bs") in
    let: "$a1" := MSG_ACCEPT in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("bs1" <-[#sliceT] "$r0");;;
    let: "bs2" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "bs1") in
    let: "$a1" := (![#uint64T] "term") in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("bs2" <-[#sliceT] "$r0");;;
    let: "bs3" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "bs2") in
    let: "$a1" := (![#uint64T] "lsnc") in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("bs3" <-[#sliceT] "$r0");;;
    let: "bs4" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "bs3") in
    let: "$a1" := (![#uint64T] "lsne") in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("bs4" <-[#sliceT] "$r0");;;
    let: "data" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "bs4") in
    let: "$a1" := (![#sliceT] "ents") in
    (func_call #util.util #"EncodeStrings"%go) "$a0" "$a1") in
    do:  ("data" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "data")).

(* go: paxos.go:977:6 *)
Definition DecodeAcceptRequest : val :=
  rec: "DecodeAcceptRequest" "bs" :=
    exception_do (let: "bs" := (mem.alloc "bs") in
    let: "bs1" := (mem.alloc (type.zero_val #sliceT)) in
    let: "term" := (mem.alloc (type.zero_val #uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "bs") in
    (func_call #marshal.marshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("term" <-[#uint64T] "$r0");;;
    do:  ("bs1" <-[#sliceT] "$r1");;;
    let: "bs2" := (mem.alloc (type.zero_val #sliceT)) in
    let: "lsnc" := (mem.alloc (type.zero_val #uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "bs1") in
    (func_call #marshal.marshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("lsnc" <-[#uint64T] "$r0");;;
    do:  ("bs2" <-[#sliceT] "$r1");;;
    let: "bs3" := (mem.alloc (type.zero_val #sliceT)) in
    let: "lsne" := (mem.alloc (type.zero_val #uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "bs2") in
    (func_call #marshal.marshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("lsne" <-[#uint64T] "$r0");;;
    do:  ("bs3" <-[#sliceT] "$r1");;;
    let: "ents" := (mem.alloc (type.zero_val #sliceT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "bs3") in
    (func_call #util.util #"DecodeStrings"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("ents" <-[#sliceT] "$r0");;;
    do:  "$r1";;;
    return: (let: "$Kind" := MSG_ACCEPT in
     let: "$Term" := (![#uint64T] "term") in
     let: "$CommittedLSN" := (![#uint64T] "lsnc") in
     let: "$EntriesLSN" := (![#uint64T] "lsne") in
     let: "$Entries" := (![#sliceT] "ents") in
     struct.make #PaxosRequest [{
       "Kind" ::= "$Kind";
       "Term" ::= "$Term";
       "CommittedLSN" ::= "$CommittedLSN";
       "EntriesLSN" ::= "$EntriesLSN";
       "Entries" ::= "$Entries"
     }])).

(* go: paxos.go:992:6 *)
Definition EncodePrepareResponse : val :=
  rec: "EncodePrepareResponse" "nid" "term" "terma" "ents" :=
    exception_do (let: "ents" := (mem.alloc "ents") in
    let: "terma" := (mem.alloc "terma") in
    let: "term" := (mem.alloc "term") in
    let: "nid" := (mem.alloc "nid") in
    let: "bs" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make3 #byteT #(W64 0) #(W64 64)) in
    do:  ("bs" <-[#sliceT] "$r0");;;
    let: "bs1" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "bs") in
    let: "$a1" := MSG_PREPARE in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("bs1" <-[#sliceT] "$r0");;;
    let: "bs2" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "bs1") in
    let: "$a1" := (![#uint64T] "nid") in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("bs2" <-[#sliceT] "$r0");;;
    let: "bs3" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "bs2") in
    let: "$a1" := (![#uint64T] "term") in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("bs3" <-[#sliceT] "$r0");;;
    let: "bs4" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "bs3") in
    let: "$a1" := (![#uint64T] "terma") in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("bs4" <-[#sliceT] "$r0");;;
    let: "data" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "bs4") in
    let: "$a1" := (![#sliceT] "ents") in
    (func_call #util.util #"EncodeStrings"%go) "$a0" "$a1") in
    do:  ("data" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "data")).

(* go: paxos.go:1004:6 *)
Definition DecodePrepareResponse : val :=
  rec: "DecodePrepareResponse" "bs" :=
    exception_do (let: "bs" := (mem.alloc "bs") in
    let: "bs1" := (mem.alloc (type.zero_val #sliceT)) in
    let: "nid" := (mem.alloc (type.zero_val #uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "bs") in
    (func_call #marshal.marshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("nid" <-[#uint64T] "$r0");;;
    do:  ("bs1" <-[#sliceT] "$r1");;;
    let: "bs2" := (mem.alloc (type.zero_val #sliceT)) in
    let: "term" := (mem.alloc (type.zero_val #uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "bs1") in
    (func_call #marshal.marshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("term" <-[#uint64T] "$r0");;;
    do:  ("bs2" <-[#sliceT] "$r1");;;
    let: "bs3" := (mem.alloc (type.zero_val #sliceT)) in
    let: "terma" := (mem.alloc (type.zero_val #uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "bs2") in
    (func_call #marshal.marshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("terma" <-[#uint64T] "$r0");;;
    do:  ("bs3" <-[#sliceT] "$r1");;;
    let: "ents" := (mem.alloc (type.zero_val #sliceT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "bs3") in
    (func_call #util.util #"DecodeStrings"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("ents" <-[#sliceT] "$r0");;;
    do:  "$r1";;;
    return: (let: "$Kind" := MSG_PREPARE in
     let: "$NodeID" := (![#uint64T] "nid") in
     let: "$Term" := (![#uint64T] "term") in
     let: "$EntriesTerm" := (![#uint64T] "terma") in
     let: "$Entries" := (![#sliceT] "ents") in
     struct.make #PaxosResponse [{
       "Kind" ::= "$Kind";
       "NodeID" ::= "$NodeID";
       "Term" ::= "$Term";
       "EntriesTerm" ::= "$EntriesTerm";
       "Entries" ::= "$Entries";
       "MatchedLSN" ::= type.zero_val #uint64T
     }])).

(* go: paxos.go:1019:6 *)
Definition EncodeAcceptResponse : val :=
  rec: "EncodeAcceptResponse" "nid" "term" "lsn" :=
    exception_do (let: "lsn" := (mem.alloc "lsn") in
    let: "term" := (mem.alloc "term") in
    let: "nid" := (mem.alloc "nid") in
    let: "bs" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make3 #byteT #(W64 0) #(W64 32)) in
    do:  ("bs" <-[#sliceT] "$r0");;;
    let: "bs1" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "bs") in
    let: "$a1" := MSG_ACCEPT in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("bs1" <-[#sliceT] "$r0");;;
    let: "bs2" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "bs1") in
    let: "$a1" := (![#uint64T] "nid") in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("bs2" <-[#sliceT] "$r0");;;
    let: "bs3" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "bs2") in
    let: "$a1" := (![#uint64T] "term") in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("bs3" <-[#sliceT] "$r0");;;
    let: "data" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "bs3") in
    let: "$a1" := (![#uint64T] "lsn") in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("data" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "data")).

(* go: paxos.go:1030:6 *)
Definition DecodeAcceptResponse : val :=
  rec: "DecodeAcceptResponse" "bs" :=
    exception_do (let: "bs" := (mem.alloc "bs") in
    let: "bs1" := (mem.alloc (type.zero_val #sliceT)) in
    let: "nid" := (mem.alloc (type.zero_val #uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "bs") in
    (func_call #marshal.marshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("nid" <-[#uint64T] "$r0");;;
    do:  ("bs1" <-[#sliceT] "$r1");;;
    let: "bs2" := (mem.alloc (type.zero_val #sliceT)) in
    let: "term" := (mem.alloc (type.zero_val #uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "bs1") in
    (func_call #marshal.marshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("term" <-[#uint64T] "$r0");;;
    do:  ("bs2" <-[#sliceT] "$r1");;;
    let: "lsn" := (mem.alloc (type.zero_val #uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "bs2") in
    (func_call #marshal.marshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("lsn" <-[#uint64T] "$r0");;;
    do:  "$r1";;;
    return: (let: "$Kind" := MSG_ACCEPT in
     let: "$NodeID" := (![#uint64T] "nid") in
     let: "$Term" := (![#uint64T] "term") in
     let: "$MatchedLSN" := (![#uint64T] "lsn") in
     struct.make #PaxosResponse [{
       "Kind" ::= "$Kind";
       "NodeID" ::= "$NodeID";
       "Term" ::= "$Term";
       "EntriesTerm" ::= type.zero_val #uint64T;
       "Entries" ::= type.zero_val #sliceT;
       "MatchedLSN" ::= "$MatchedLSN"
     }])).

(* go: paxos.go:1043:6 *)
Definition DecodeRequest : val :=
  rec: "DecodeRequest" "bs" :=
    exception_do (let: "bs" := (mem.alloc "bs") in
    let: "data" := (mem.alloc (type.zero_val #sliceT)) in
    let: "kind" := (mem.alloc (type.zero_val #uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "bs") in
    (func_call #marshal.marshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("kind" <-[#uint64T] "$r0");;;
    do:  ("data" <-[#sliceT] "$r1");;;
    (if: (![#uint64T] "kind") = MSG_PREPARE
    then
      let: "req" := (mem.alloc (type.zero_val #PaxosRequest)) in
      let: "$r0" := (let: "$a0" := (![#sliceT] "data") in
      (func_call #paxos.paxos #"DecodePrepareRequest"%go) "$a0") in
      do:  ("req" <-[#PaxosRequest] "$r0");;;
      return: (![#PaxosRequest] "req")
    else do:  #());;;
    (if: (![#uint64T] "kind") = MSG_ACCEPT
    then
      let: "req" := (mem.alloc (type.zero_val #PaxosRequest)) in
      let: "$r0" := (let: "$a0" := (![#sliceT] "data") in
      (func_call #paxos.paxos #"DecodeAcceptRequest"%go) "$a0") in
      do:  ("req" <-[#PaxosRequest] "$r0");;;
      return: (![#PaxosRequest] "req")
    else do:  #());;;
    return: (struct.make #PaxosRequest [{
       "Kind" ::= type.zero_val #uint64T;
       "Term" ::= type.zero_val #uint64T;
       "CommittedLSN" ::= type.zero_val #uint64T;
       "EntriesLSN" ::= type.zero_val #uint64T;
       "Entries" ::= type.zero_val #sliceT
     }])).

(* go: paxos.go:1058:6 *)
Definition DecodeResponse : val :=
  rec: "DecodeResponse" "bs" :=
    exception_do (let: "bs" := (mem.alloc "bs") in
    let: "data" := (mem.alloc (type.zero_val #sliceT)) in
    let: "kind" := (mem.alloc (type.zero_val #uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "bs") in
    (func_call #marshal.marshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("kind" <-[#uint64T] "$r0");;;
    do:  ("data" <-[#sliceT] "$r1");;;
    (if: (![#uint64T] "kind") = MSG_PREPARE
    then
      let: "resp" := (mem.alloc (type.zero_val #PaxosResponse)) in
      let: "$r0" := (let: "$a0" := (![#sliceT] "data") in
      (func_call #paxos.paxos #"DecodePrepareResponse"%go) "$a0") in
      do:  ("resp" <-[#PaxosResponse] "$r0");;;
      return: (![#PaxosResponse] "resp")
    else do:  #());;;
    (if: (![#uint64T] "kind") = MSG_ACCEPT
    then
      let: "resp" := (mem.alloc (type.zero_val #PaxosResponse)) in
      let: "$r0" := (let: "$a0" := (![#sliceT] "data") in
      (func_call #paxos.paxos #"DecodeAcceptResponse"%go) "$a0") in
      do:  ("resp" <-[#PaxosResponse] "$r0");;;
      return: (![#PaxosResponse] "resp")
    else do:  #());;;
    return: (struct.make #PaxosResponse [{
       "Kind" ::= type.zero_val #uint64T;
       "NodeID" ::= type.zero_val #uint64T;
       "Term" ::= type.zero_val #uint64T;
       "EntriesTerm" ::= type.zero_val #uint64T;
       "Entries" ::= type.zero_val #sliceT;
       "MatchedLSN" ::= type.zero_val #uint64T
     }])).

Definition CMD_EXTEND : expr := #(W64 0).

Definition CMD_APPEND : expr := #(W64 1).

Definition CMD_PREPARE : expr := #(W64 2).

Definition CMD_ADVANCE : expr := #(W64 3).

Definition CMD_ACCEPT : expr := #(W64 4).

Definition CMD_EXPAND : expr := #(W64 5).

(* go: paxos.go:1086:6 *)
Definition logExtend : val :=
  rec: "logExtend" "fname" "ents" :=
    exception_do (let: "ents" := (mem.alloc "ents") in
    let: "fname" := (mem.alloc "fname") in
    let: "bs" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make3 #byteT #(W64 0) #(W64 64)) in
    do:  ("bs" <-[#sliceT] "$r0");;;
    let: "bs1" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "bs") in
    let: "$a1" := CMD_EXTEND in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("bs1" <-[#sliceT] "$r0");;;
    let: "bs2" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "bs1") in
    let: "$a1" := (![#sliceT] "ents") in
    (func_call #util.util #"EncodeStrings"%go) "$a0" "$a1") in
    do:  ("bs2" <-[#sliceT] "$r0");;;
    do:  (let: "$a0" := (![#stringT] "fname") in
    let: "$a1" := (![#sliceT] "bs2") in
    (func_call #grove_ffi.grove_ffi #"FileAppend"%go) "$a0" "$a1")).

(* go: paxos.go:1096:6 *)
Definition logAppend : val :=
  rec: "logAppend" "fname" "ent" :=
    exception_do (let: "ent" := (mem.alloc "ent") in
    let: "fname" := (mem.alloc "fname") in
    let: "bs" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make3 #byteT #(W64 0) #(W64 32)) in
    do:  ("bs" <-[#sliceT] "$r0");;;
    let: "bs1" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "bs") in
    let: "$a1" := CMD_APPEND in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("bs1" <-[#sliceT] "$r0");;;
    let: "bs2" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "bs1") in
    let: "$a1" := (![#stringT] "ent") in
    (func_call #util.util #"EncodeString"%go) "$a0" "$a1") in
    do:  ("bs2" <-[#sliceT] "$r0");;;
    do:  (let: "$a0" := (![#stringT] "fname") in
    let: "$a1" := (![#sliceT] "bs2") in
    (func_call #grove_ffi.grove_ffi #"FileAppend"%go) "$a0" "$a1")).

(* go: paxos.go:1105:6 *)
Definition logPrepare : val :=
  rec: "logPrepare" "fname" "term" :=
    exception_do (let: "term" := (mem.alloc "term") in
    let: "fname" := (mem.alloc "fname") in
    let: "bs" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make3 #byteT #(W64 0) #(W64 16)) in
    do:  ("bs" <-[#sliceT] "$r0");;;
    let: "bs1" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "bs") in
    let: "$a1" := CMD_PREPARE in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("bs1" <-[#sliceT] "$r0");;;
    let: "bs2" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "bs1") in
    let: "$a1" := (![#uint64T] "term") in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("bs2" <-[#sliceT] "$r0");;;
    do:  (let: "$a0" := (![#stringT] "fname") in
    let: "$a1" := (![#sliceT] "bs2") in
    (func_call #grove_ffi.grove_ffi #"FileAppend"%go) "$a0" "$a1")).

(* Note that we could have defined @logAdvance to take @ents only, since @term
   and @lsn can be determined directly from the state for the
   candidate. However, a similar transition also happens on followers, but @term
   and @lsn are passed through function arguments rather than from state. Given
   that advance is used only on failure cases, defining a single interface
   simplify things a bit without hurting too much of the performance.

   go: paxos.go:1120:6 *)
Definition logAdvance : val :=
  rec: "logAdvance" "fname" "term" "lsn" "ents" :=
    exception_do (let: "ents" := (mem.alloc "ents") in
    let: "lsn" := (mem.alloc "lsn") in
    let: "term" := (mem.alloc "term") in
    let: "fname" := (mem.alloc "fname") in
    let: "bs" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make3 #byteT #(W64 0) #(W64 64)) in
    do:  ("bs" <-[#sliceT] "$r0");;;
    let: "bs1" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "bs") in
    let: "$a1" := CMD_ADVANCE in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("bs1" <-[#sliceT] "$r0");;;
    let: "bs2" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "bs1") in
    let: "$a1" := (![#uint64T] "term") in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("bs2" <-[#sliceT] "$r0");;;
    let: "bs3" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "bs2") in
    let: "$a1" := (![#uint64T] "lsn") in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("bs3" <-[#sliceT] "$r0");;;
    let: "bs4" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "bs3") in
    let: "$a1" := (![#sliceT] "ents") in
    (func_call #util.util #"EncodeStrings"%go) "$a0" "$a1") in
    do:  ("bs4" <-[#sliceT] "$r0");;;
    do:  (let: "$a0" := (![#stringT] "fname") in
    let: "$a1" := (![#sliceT] "bs4") in
    (func_call #grove_ffi.grove_ffi #"FileAppend"%go) "$a0" "$a1")).

(* go: paxos.go:1131:6 *)
Definition logAccept : val :=
  rec: "logAccept" "fname" "lsn" "ents" :=
    exception_do (let: "ents" := (mem.alloc "ents") in
    let: "lsn" := (mem.alloc "lsn") in
    let: "fname" := (mem.alloc "fname") in
    let: "bs" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make3 #byteT #(W64 0) #(W64 64)) in
    do:  ("bs" <-[#sliceT] "$r0");;;
    let: "bs1" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "bs") in
    let: "$a1" := CMD_ACCEPT in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("bs1" <-[#sliceT] "$r0");;;
    let: "bs2" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "bs1") in
    let: "$a1" := (![#uint64T] "lsn") in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("bs2" <-[#sliceT] "$r0");;;
    let: "bs3" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "bs2") in
    let: "$a1" := (![#sliceT] "ents") in
    (func_call #util.util #"EncodeStrings"%go) "$a0" "$a1") in
    do:  ("bs3" <-[#sliceT] "$r0");;;
    do:  (let: "$a0" := (![#stringT] "fname") in
    let: "$a1" := (![#sliceT] "bs3") in
    (func_call #grove_ffi.grove_ffi #"FileAppend"%go) "$a0" "$a1")).

(* go: paxos.go:1141:6 *)
Definition logExpand : val :=
  rec: "logExpand" "fname" "lsn" :=
    exception_do (let: "lsn" := (mem.alloc "lsn") in
    let: "fname" := (mem.alloc "fname") in
    let: "bs" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make3 #byteT #(W64 0) #(W64 16)) in
    do:  ("bs" <-[#sliceT] "$r0");;;
    let: "bs1" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "bs") in
    let: "$a1" := CMD_EXPAND in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("bs1" <-[#sliceT] "$r0");;;
    let: "bs2" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "bs1") in
    let: "$a1" := (![#uint64T] "lsn") in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("bs2" <-[#sliceT] "$r0");;;
    do:  (let: "$a0" := (![#stringT] "fname") in
    let: "$a1" := (![#sliceT] "bs2") in
    (func_call #grove_ffi.grove_ffi #"FileAppend"%go) "$a0" "$a1")).

(* Read the underlying file and perform recovery to re-construct @termc, @terml,
   @lsnc, and @log.

   go: paxos.go:1152:6 *)
Definition resume : val :=
  rec: "resume" "fname" :=
    exception_do (let: "fname" := (mem.alloc "fname") in
    let: "termc" := (mem.alloc (type.zero_val #uint64T)) in
    let: "terml" := (mem.alloc (type.zero_val #uint64T)) in
    let: "lsnc" := (mem.alloc (type.zero_val #uint64T)) in
    let: "log" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make2 #stringT #(W64 0)) in
    do:  ("log" <-[#sliceT] "$r0");;;
    let: "data" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#stringT] "fname") in
    (func_call #grove_ffi.grove_ffi #"FileRead"%go) "$a0") in
    do:  ("data" <-[#sliceT] "$r0");;;
    (for: (λ: <>, #(W64 0) < (s_to_w64 (let: "$a0" := (![#sliceT] "data") in
    slice.len "$a0"))); (λ: <>, Skip) := λ: <>,
      let: "bs" := (mem.alloc (type.zero_val #sliceT)) in
      let: "kind" := (mem.alloc (type.zero_val #uint64T)) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "data") in
      (func_call #marshal.marshal #"ReadInt"%go) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("kind" <-[#uint64T] "$r0");;;
      do:  ("bs" <-[#sliceT] "$r1");;;
      (if: (![#uint64T] "kind") = CMD_EXTEND
      then
        let: "bs1" := (mem.alloc (type.zero_val #sliceT)) in
        let: "ents" := (mem.alloc (type.zero_val #sliceT)) in
        let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "bs") in
        (func_call #util.util #"DecodeStrings"%go) "$a0") in
        let: "$r0" := "$ret0" in
        let: "$r1" := "$ret1" in
        do:  ("ents" <-[#sliceT] "$r0");;;
        do:  ("bs1" <-[#sliceT] "$r1");;;
        let: "$r0" := (![#sliceT] "bs1") in
        do:  ("data" <-[#sliceT] "$r0");;;
        let: "$r0" := (let: "$a0" := (![#sliceT] "log") in
        let: "$a1" := (![#sliceT] "ents") in
        (slice.append #stringT) "$a0" "$a1") in
        do:  ("log" <-[#sliceT] "$r0")
      else
        (if: (![#uint64T] "kind") = CMD_APPEND
        then
          let: "bs1" := (mem.alloc (type.zero_val #sliceT)) in
          let: "ent" := (mem.alloc (type.zero_val #stringT)) in
          let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "bs") in
          (func_call #util.util #"DecodeString"%go) "$a0") in
          let: "$r0" := "$ret0" in
          let: "$r1" := "$ret1" in
          do:  ("ent" <-[#stringT] "$r0");;;
          do:  ("bs1" <-[#sliceT] "$r1");;;
          let: "$r0" := (![#sliceT] "bs1") in
          do:  ("data" <-[#sliceT] "$r0");;;
          let: "$r0" := (let: "$a0" := (![#sliceT] "log") in
          let: "$a1" := ((let: "$sl0" := (![#stringT] "ent") in
          slice.literal #stringT ["$sl0"])) in
          (slice.append #stringT) "$a0" "$a1") in
          do:  ("log" <-[#sliceT] "$r0")
        else
          (if: (![#uint64T] "kind") = CMD_PREPARE
          then
            let: "bs1" := (mem.alloc (type.zero_val #sliceT)) in
            let: "term" := (mem.alloc (type.zero_val #uint64T)) in
            let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "bs") in
            (func_call #marshal.marshal #"ReadInt"%go) "$a0") in
            let: "$r0" := "$ret0" in
            let: "$r1" := "$ret1" in
            do:  ("term" <-[#uint64T] "$r0");;;
            do:  ("bs1" <-[#sliceT] "$r1");;;
            let: "$r0" := (![#sliceT] "bs1") in
            do:  ("data" <-[#sliceT] "$r0");;;
            let: "$r0" := (![#uint64T] "term") in
            do:  ("termc" <-[#uint64T] "$r0")
          else
            (if: (![#uint64T] "kind") = CMD_ADVANCE
            then
              let: "bs1" := (mem.alloc (type.zero_val #sliceT)) in
              let: "term" := (mem.alloc (type.zero_val #uint64T)) in
              let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "bs") in
              (func_call #marshal.marshal #"ReadInt"%go) "$a0") in
              let: "$r0" := "$ret0" in
              let: "$r1" := "$ret1" in
              do:  ("term" <-[#uint64T] "$r0");;;
              do:  ("bs1" <-[#sliceT] "$r1");;;
              let: "bs2" := (mem.alloc (type.zero_val #sliceT)) in
              let: "lsn" := (mem.alloc (type.zero_val #uint64T)) in
              let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "bs1") in
              (func_call #marshal.marshal #"ReadInt"%go) "$a0") in
              let: "$r0" := "$ret0" in
              let: "$r1" := "$ret1" in
              do:  ("lsn" <-[#uint64T] "$r0");;;
              do:  ("bs2" <-[#sliceT] "$r1");;;
              let: "bs3" := (mem.alloc (type.zero_val #sliceT)) in
              let: "ents" := (mem.alloc (type.zero_val #sliceT)) in
              let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "bs2") in
              (func_call #util.util #"DecodeStrings"%go) "$a0") in
              let: "$r0" := "$ret0" in
              let: "$r1" := "$ret1" in
              do:  ("ents" <-[#sliceT] "$r0");;;
              do:  ("bs3" <-[#sliceT] "$r1");;;
              let: "$r0" := (![#sliceT] "bs3") in
              do:  ("data" <-[#sliceT] "$r0");;;
              let: "$r0" := (![#uint64T] "term") in
              do:  ("terml" <-[#uint64T] "$r0");;;
              let: "$r0" := (let: "$s" := (![#sliceT] "log") in
              slice.slice #stringT "$s" #(W64 0) (![#uint64T] "lsn")) in
              do:  ("log" <-[#sliceT] "$r0");;;
              let: "$r0" := (let: "$a0" := (![#sliceT] "log") in
              let: "$a1" := (![#sliceT] "ents") in
              (slice.append #stringT) "$a0" "$a1") in
              do:  ("log" <-[#sliceT] "$r0")
            else
              (if: (![#uint64T] "kind") = CMD_ACCEPT
              then
                let: "bs1" := (mem.alloc (type.zero_val #sliceT)) in
                let: "lsn" := (mem.alloc (type.zero_val #uint64T)) in
                let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "bs") in
                (func_call #marshal.marshal #"ReadInt"%go) "$a0") in
                let: "$r0" := "$ret0" in
                let: "$r1" := "$ret1" in
                do:  ("lsn" <-[#uint64T] "$r0");;;
                do:  ("bs1" <-[#sliceT] "$r1");;;
                let: "bs2" := (mem.alloc (type.zero_val #sliceT)) in
                let: "ents" := (mem.alloc (type.zero_val #sliceT)) in
                let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "bs1") in
                (func_call #util.util #"DecodeStrings"%go) "$a0") in
                let: "$r0" := "$ret0" in
                let: "$r1" := "$ret1" in
                do:  ("ents" <-[#sliceT] "$r0");;;
                do:  ("bs2" <-[#sliceT] "$r1");;;
                let: "$r0" := (![#sliceT] "bs2") in
                do:  ("data" <-[#sliceT] "$r0");;;
                let: "$r0" := (let: "$s" := (![#sliceT] "log") in
                slice.slice #stringT "$s" #(W64 0) (![#uint64T] "lsn")) in
                do:  ("log" <-[#sliceT] "$r0");;;
                let: "$r0" := (let: "$a0" := (![#sliceT] "log") in
                let: "$a1" := (![#sliceT] "ents") in
                (slice.append #stringT) "$a0" "$a1") in
                do:  ("log" <-[#sliceT] "$r0")
              else
                (if: (![#uint64T] "kind") = CMD_EXPAND
                then
                  let: "bs1" := (mem.alloc (type.zero_val #sliceT)) in
                  let: "lsn" := (mem.alloc (type.zero_val #uint64T)) in
                  let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "bs") in
                  (func_call #marshal.marshal #"ReadInt"%go) "$a0") in
                  let: "$r0" := "$ret0" in
                  let: "$r1" := "$ret1" in
                  do:  ("lsn" <-[#uint64T] "$r0");;;
                  do:  ("bs1" <-[#sliceT] "$r1");;;
                  let: "$r0" := (![#sliceT] "bs1") in
                  do:  ("data" <-[#sliceT] "$r0");;;
                  let: "$r0" := (![#uint64T] "lsn") in
                  do:  ("lsnc" <-[#uint64T] "$r0")
                else do:  #())))))));;;
    return: (![#uint64T] "termc", ![#uint64T] "terml", ![#uint64T] "lsnc", ![#sliceT] "log")).

Definition vars' : list (go_string * go_type) := [].

Definition functions' : list (go_string * val) := [("mkPaxos"%go, mkPaxos); ("Start"%go, Start); ("EncodePrepareRequest"%go, EncodePrepareRequest); ("DecodePrepareRequest"%go, DecodePrepareRequest); ("EncodeAcceptRequest"%go, EncodeAcceptRequest); ("DecodeAcceptRequest"%go, DecodeAcceptRequest); ("EncodePrepareResponse"%go, EncodePrepareResponse); ("DecodePrepareResponse"%go, DecodePrepareResponse); ("EncodeAcceptResponse"%go, EncodeAcceptResponse); ("DecodeAcceptResponse"%go, DecodeAcceptResponse); ("DecodeRequest"%go, DecodeRequest); ("DecodeResponse"%go, DecodeResponse); ("logExtend"%go, logExtend); ("logAppend"%go, logAppend); ("logPrepare"%go, logPrepare); ("logAdvance"%go, logAdvance); ("logAccept"%go, logAccept); ("logExpand"%go, logExpand); ("resume"%go, resume)].

Definition msets' : list (go_string * (list (go_string * val))) := [("Paxos"%go, []); ("Paxos'ptr"%go, [("Connect"%go, Paxos__Connect); ("ConnectAll"%go, Paxos__ConnectAll); ("DumpState"%go, Paxos__DumpState); ("ElectionSession"%go, Paxos__ElectionSession); ("ForceElection"%go, Paxos__ForceElection); ("GetConnection"%go, Paxos__GetConnection); ("HeartbeatSession"%go, Paxos__HeartbeatSession); ("LeaderSession"%go, Paxos__LeaderSession); ("Lookup"%go, Paxos__Lookup); ("Receive"%go, Paxos__Receive); ("RequestSession"%go, Paxos__RequestSession); ("ResponseSession"%go, Paxos__ResponseSession); ("Send"%go, Paxos__Send); ("Serve"%go, Paxos__Serve); ("Submit"%go, Paxos__Submit); ("WaitUntilSafe"%go, Paxos__WaitUntilSafe); ("accept"%go, Paxos__accept); ("ascend"%go, Paxos__ascend); ("collect"%go, Paxos__collect); ("commit"%go, Paxos__commit); ("cquorum"%go, Paxos__cquorum); ("forward"%go, Paxos__forward); ("getlsnc"%go, Paxos__getlsnc); ("gettermc"%go, Paxos__gettermc); ("gttermc"%go, Paxos__gttermc); ("heartbeat"%go, Paxos__heartbeat); ("heartbeated"%go, Paxos__heartbeated); ("latest"%go, Paxos__latest); ("leading"%go, Paxos__leading); ("learn"%go, Paxos__learn); ("lttermc"%go, Paxos__lttermc); ("nominate"%go, Paxos__nominate); ("nominated"%go, Paxos__nominated); ("obtain"%go, Paxos__obtain); ("prepare"%go, Paxos__prepare); ("push"%go, Paxos__push); ("resethb"%go, Paxos__resethb); ("stepdown"%go, Paxos__stepdown)]); ("PaxosRequest"%go, []); ("PaxosRequest'ptr"%go, []); ("PaxosResponse"%go, []); ("PaxosResponse'ptr"%go, [])].

#[global] Instance info' : PkgInfo paxos.paxos :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [fmt.fmt; sync.sync; primitive.primitive; grove_ffi.grove_ffi; params.params; quorum.quorum; util.util; marshal.marshal];
  |}.

Definition initialize' : val :=
  rec: "initialize'" <> :=
    globals.package_init paxos.paxos (λ: <>,
      exception_do (do:  marshal.initialize';;;
      do:  util.initialize';;;
      do:  quorum.initialize';;;
      do:  params.initialize';;;
      do:  grove_ffi.initialize';;;
      do:  primitive.initialize';;;
      do:  sync.initialize';;;
      do:  fmt.initialize')
      ).

End code.
End paxos.
