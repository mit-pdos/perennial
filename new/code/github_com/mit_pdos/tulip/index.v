(* autogenerated from github.com/mit-pdos/tulip/index *)
From New.golang Require Import defn.
Require Export New.code.github_com.mit_pdos.tulip.tuple.
Require Export New.code.sync.

Definition index : go_string := "github.com/mit-pdos/tulip/index".

From New Require Import grove_prelude.
Module index.
Section code.


Definition Index : go_type := structT [
  "mu" :: ptrT;
  "tplm" :: mapT stringT ptrT
].

(* go: index.go:13:19 *)
Definition Index__GetTuple : val :=
  rec: "Index__GetTuple" "idx" "key" :=
    exception_do (let: "idx" := (mem.alloc "idx") in
    let: "key" := (mem.alloc "key") in
    do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref #Index #"mu"%go (![#ptrT] "idx")))) #());;;
    let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "tpl" := (mem.alloc (type.zero_val #ptrT)) in
    let: ("$ret0", "$ret1") := (map.get (![type.mapT #stringT #ptrT] (struct.field_ref #Index #"tplm"%go (![#ptrT] "idx"))) (![#stringT] "key")) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("tpl" <-[#ptrT] "$r0");;;
    do:  ("ok" <-[#boolT] "$r1");;;
    (if: ![#boolT] "ok"
    then
      do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Index #"mu"%go (![#ptrT] "idx")))) #());;;
      return: (![#ptrT] "tpl")
    else do:  #());;;
    let: "tplnew" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := ((func_call #tuple.tuple #"MkTuple"%go) #()) in
    do:  ("tplnew" <-[#ptrT] "$r0");;;
    let: "$r0" := (![#ptrT] "tplnew") in
    do:  (map.insert (![type.mapT #stringT #ptrT] (struct.field_ref #Index #"tplm"%go (![#ptrT] "idx"))) (![#stringT] "key") "$r0");;;
    do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Index #"mu"%go (![#ptrT] "idx")))) #());;;
    return: (![#ptrT] "tplnew")).

(* go: index.go:30:6 *)
Definition MkIndex : val :=
  rec: "MkIndex" <> :=
    exception_do (let: "idx" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #Index)) in
    do:  ("idx" <-[#ptrT] "$r0");;;
    let: "$r0" := (mem.alloc (type.zero_val #sync.Mutex)) in
    do:  ((struct.field_ref #Index #"mu"%go (![#ptrT] "idx")) <-[#ptrT] "$r0");;;
    let: "$r0" := (map.make #stringT #ptrT) in
    do:  ((struct.field_ref #Index #"tplm"%go (![#ptrT] "idx")) <-[type.mapT #stringT #ptrT] "$r0");;;
    return: (![#ptrT] "idx")).

Definition vars' : list (go_string * go_type) := [].

Definition functions' : list (go_string * val) := [("MkIndex"%go, MkIndex)].

Definition msets' : list (go_string * (list (go_string * val))) := [("Index"%go, []); ("Index'ptr"%go, [("GetTuple"%go, Index__GetTuple)])].

#[global] Instance info' : PkgInfo index.index :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [sync.sync; tuple.tuple];
  |}.

Definition initialize' : val :=
  rec: "initialize'" <> :=
    globals.package_init index.index (Î»: <>,
      exception_do (do:  tuple.initialize';;;
      do:  sync.initialize')
      ).

End code.
End index.
