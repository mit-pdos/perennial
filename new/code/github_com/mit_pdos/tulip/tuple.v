(* autogenerated from github.com/mit-pdos/tulip/tuple *)
From New.golang Require Import defn.
Require Export New.code.github_com.mit_pdos.tulip.tulip.
Require Export New.code.sync.

Definition tuple : go_string := "github.com/mit-pdos/tulip/tuple".

From New Require Import grove_prelude.
Module tuple.
Section code.


Definition Tuple : go_type := structT [
  "mu" :: ptrT;
  "tssafe" :: uint64T;
  "vers" :: sliceT
].

(* Arguments:
   @ts: Index at which lookup of the abstract history is performed.

   Return values:
   @ver: If @ver.Timestamp = 0, then this is a fast-path read---the value at @ts
   has been determined to be @ver.Value. Otherwise, this is a slow-path read,
   the replica promises not to accept prepare requests from transactions that
   modifies this tuple and whose timestamp lies within @ver.Timestamp and @ts.

   @ok: @ver is meaningful iff @ok is true.

   go: tuple.go:51:21 *)
Definition Tuple__ReadVersion : val :=
  rec: "Tuple__ReadVersion" "tuple" "ts" :=
    exception_do (let: "tuple" := (mem.alloc "tuple") in
    let: "ts" := (mem.alloc "ts") in
    do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref #Tuple #"mu"%go (![#ptrT] "tuple")))) #());;;
    let: "slow" := (mem.alloc (type.zero_val #boolT)) in
    let: "ver" := (mem.alloc (type.zero_val #tulip.Version)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := ((![#uint64T] "ts") - #(W64 1)) in
    let: "$a1" := (![#sliceT] (struct.field_ref #Tuple #"vers"%go (![#ptrT] "tuple"))) in
    (func_call #tuple.tuple #"findVersion"%go) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("ver" <-[#tulip.Version] "$r0");;;
    do:  ("slow" <-[#boolT] "$r1");;;
    do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Tuple #"mu"%go (![#ptrT] "tuple")))) #());;;
    return: (![#tulip.Version] "ver", ![#boolT] "slow")).

(* @findVersion starts from the end of @vers and return the first version whose
   timestamp is less than or equal to @ts, and whether the returned version is
   the latest one. If the returned version is the latest one, the postcondition
   should say something about the length of the history.

   go: tuple.go:65:6 *)
Definition findVersion : val :=
  rec: "findVersion" "ts" "vers" :=
    exception_do (let: "vers" := (mem.alloc "vers") in
    let: "ts" := (mem.alloc "ts") in
    let: "ver" := (mem.alloc (type.zero_val #tulip.Version)) in
    let: "length" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (s_to_w64 (let: "$a0" := (![#sliceT] "vers") in
    slice.len "$a0")) in
    do:  ("length" <-[#uint64T] "$r0");;;
    let: "idx" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("idx" <-[#uint64T] "$r0");;;
    (for: (λ: <>, (![#uint64T] "idx") < (![#uint64T] "length")); (λ: <>, Skip) := λ: <>,
      let: "$r0" := (![#tulip.Version] (slice.elem_ref #tulip.Version (![#sliceT] "vers") (((![#uint64T] "length") - (![#uint64T] "idx")) - #(W64 1)))) in
      do:  ("ver" <-[#tulip.Version] "$r0");;;
      (if: (![#uint64T] (struct.field_ref #tulip.Version #"Timestamp"%go "ver")) ≤ (![#uint64T] "ts")
      then break: #()
      else do:  #());;;
      do:  ("idx" <-[#uint64T] ((![#uint64T] "idx") + #(W64 1))));;;
    return: (![#tulip.Version] "ver", ((![#uint64T] "idx") = #(W64 0)) && ((![#uint64T] "ts") ≠ (![#uint64T] (struct.field_ref #tulip.Version #"Timestamp"%go "ver"))))).

(* go: tuple.go:80:21 *)
Definition Tuple__AppendVersion : val :=
  rec: "Tuple__AppendVersion" "tuple" "ts" "value" :=
    exception_do (let: "tuple" := (mem.alloc "tuple") in
    let: "value" := (mem.alloc "value") in
    let: "ts" := (mem.alloc "ts") in
    do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref #Tuple #"mu"%go (![#ptrT] "tuple")))) #());;;
    let: "ver" := (mem.alloc (type.zero_val #tulip.Version)) in
    let: "$r0" := (let: "$Timestamp" := (![#uint64T] "ts") in
    let: "$Value" := (let: "$Present" := #true in
    let: "$Content" := (![#stringT] "value") in
    struct.make #tulip.Value [{
      "Present" ::= "$Present";
      "Content" ::= "$Content"
    }]) in
    struct.make #tulip.Version [{
      "Timestamp" ::= "$Timestamp";
      "Value" ::= "$Value"
    }]) in
    do:  ("ver" <-[#tulip.Version] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] (struct.field_ref #Tuple #"vers"%go (![#ptrT] "tuple"))) in
    let: "$a1" := ((let: "$sl0" := (![#tulip.Version] "ver") in
    slice.literal #tulip.Version ["$sl0"])) in
    (slice.append #tulip.Version) "$a0" "$a1") in
    do:  ((struct.field_ref #Tuple #"vers"%go (![#ptrT] "tuple")) <-[#sliceT] "$r0");;;
    do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Tuple #"mu"%go (![#ptrT] "tuple")))) #())).

(* go: tuple.go:96:21 *)
Definition Tuple__KillVersion : val :=
  rec: "Tuple__KillVersion" "tuple" "ts" :=
    exception_do (let: "tuple" := (mem.alloc "tuple") in
    let: "ts" := (mem.alloc "ts") in
    do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref #Tuple #"mu"%go (![#ptrT] "tuple")))) #());;;
    let: "ver" := (mem.alloc (type.zero_val #tulip.Version)) in
    let: "$r0" := (let: "$Timestamp" := (![#uint64T] "ts") in
    let: "$Value" := (let: "$Present" := #false in
    struct.make #tulip.Value [{
      "Present" ::= "$Present";
      "Content" ::= type.zero_val #stringT
    }]) in
    struct.make #tulip.Version [{
      "Timestamp" ::= "$Timestamp";
      "Value" ::= "$Value"
    }]) in
    do:  ("ver" <-[#tulip.Version] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] (struct.field_ref #Tuple #"vers"%go (![#ptrT] "tuple"))) in
    let: "$a1" := ((let: "$sl0" := (![#tulip.Version] "ver") in
    slice.literal #tulip.Version ["$sl0"])) in
    (slice.append #tulip.Version) "$a0" "$a1") in
    do:  ((struct.field_ref #Tuple #"vers"%go (![#ptrT] "tuple")) <-[#sliceT] "$r0");;;
    do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Tuple #"mu"%go (![#ptrT] "tuple")))) #())).

(* go: tuple.go:109:6 *)
Definition MkTuple : val :=
  rec: "MkTuple" <> :=
    exception_do (let: "tuple" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #Tuple)) in
    do:  ("tuple" <-[#ptrT] "$r0");;;
    let: "$r0" := (mem.alloc (type.zero_val #sync.Mutex)) in
    do:  ((struct.field_ref #Tuple #"mu"%go (![#ptrT] "tuple")) <-[#ptrT] "$r0");;;
    let: "vers" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make3 #tulip.Version #(W64 1) #(W64 1)) in
    do:  ("vers" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$Timestamp" := #(W64 0) in
    let: "$Value" := (let: "$Present" := #false in
    struct.make #tulip.Value [{
      "Present" ::= "$Present";
      "Content" ::= type.zero_val #stringT
    }]) in
    struct.make #tulip.Version [{
      "Timestamp" ::= "$Timestamp";
      "Value" ::= "$Value"
    }]) in
    do:  ((slice.elem_ref #tulip.Version (![#sliceT] "vers") #(W64 0)) <-[#tulip.Version] "$r0");;;
    let: "$r0" := (![#sliceT] "vers") in
    do:  ((struct.field_ref #Tuple #"vers"%go (![#ptrT] "tuple")) <-[#sliceT] "$r0");;;
    return: (![#ptrT] "tuple")).

Definition vars' : list (go_string * go_type) := [].

Definition functions' : list (go_string * val) := [("findVersion"%go, findVersion); ("MkTuple"%go, MkTuple)].

Definition msets' : list (go_string * (list (go_string * val))) := [("Tuple"%go, []); ("Tuple'ptr"%go, [("AppendVersion"%go, Tuple__AppendVersion); ("KillVersion"%go, Tuple__KillVersion); ("ReadVersion"%go, Tuple__ReadVersion)])].

#[global] Instance info' : PkgInfo tuple.tuple :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [sync.sync; tulip.tulip];
  |}.

Definition initialize' : val :=
  rec: "initialize'" <> :=
    globals.package_init tuple.tuple (λ: <>,
      exception_do (do:  tulip.initialize';;;
      do:  sync.initialize')
      ).

End code.
End tuple.
