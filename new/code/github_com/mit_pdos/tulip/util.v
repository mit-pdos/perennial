(* autogenerated from github.com/mit-pdos/tulip/util *)
From New.golang Require Import defn.
Require Export New.code.github_com.goose_lang.std.
Require Export New.code.github_com.mit_pdos.tulip.tulip.
Require Export New.code.github_com.tchajed.marshal.

Definition util : go_string := "github.com/mit-pdos/tulip/util".

From New Require Import grove_prelude.
Module util.
Section code.


(* go: util.go:9:6 *)
Definition NextAligned : val :=
  rec: "NextAligned" "current" "interval" "low" :=
    exception_do (let: "low" := (mem.alloc "low") in
    let: "interval" := (mem.alloc "interval") in
    let: "current" := (mem.alloc "current") in
    let: "delta" := (mem.alloc (type.zero_val #uint64T)) in
    let: "rem" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := ((![#uint64T] "current") `rem` (![#uint64T] "interval")) in
    do:  ("rem" <-[#uint64T] "$r0");;;
    (if: (![#uint64T] "rem") < (![#uint64T] "low")
    then
      let: "$r0" := ((![#uint64T] "low") - (![#uint64T] "rem")) in
      do:  ("delta" <-[#uint64T] "$r0")
    else
      let: "$r0" := (((![#uint64T] "interval") + (![#uint64T] "low")) - (![#uint64T] "rem")) in
      do:  ("delta" <-[#uint64T] "$r0"));;;
    return: (let: "$a0" := (![#uint64T] "current") in
     let: "$a1" := (![#uint64T] "delta") in
     (func_call #std.std #"SumAssumeNoOverflow"%go) "$a0" "$a1")).

(* go: util.go:22:6 *)
Definition swap : val :=
  rec: "swap" "ns" "i" "j" :=
    exception_do (let: "j" := (mem.alloc "j") in
    let: "i" := (mem.alloc "i") in
    let: "ns" := (mem.alloc "ns") in
    let: "tmp" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (![#uint64T] (slice.elem_ref #uint64T (![#sliceT] "ns") (![#uint64T] "i"))) in
    do:  ("tmp" <-[#uint64T] "$r0");;;
    let: "$r0" := (![#uint64T] (slice.elem_ref #uint64T (![#sliceT] "ns") (![#uint64T] "j"))) in
    do:  ((slice.elem_ref #uint64T (![#sliceT] "ns") (![#uint64T] "i")) <-[#uint64T] "$r0");;;
    let: "$r0" := (![#uint64T] "tmp") in
    do:  ((slice.elem_ref #uint64T (![#sliceT] "ns") (![#uint64T] "j")) <-[#uint64T] "$r0")).

(* go: util.go:28:6 *)
Definition Sort : val :=
  rec: "Sort" "ns" :=
    exception_do (let: "ns" := (mem.alloc "ns") in
    let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 1) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (for: (λ: <>, (![#uint64T] "i") < (s_to_w64 (let: "$a0" := (![#sliceT] "ns") in
    slice.len "$a0"))); (λ: <>, Skip) := λ: <>,
      let: "j" := (mem.alloc (type.zero_val #uint64T)) in
      let: "$r0" := (![#uint64T] "i") in
      do:  ("j" <-[#uint64T] "$r0");;;
      (for: (λ: <>, (![#uint64T] "j") > #(W64 0)); (λ: <>, Skip) := λ: <>,
        (if: (![#uint64T] (slice.elem_ref #uint64T (![#sliceT] "ns") ((![#uint64T] "j") - #(W64 1)))) ≤ (![#uint64T] (slice.elem_ref #uint64T (![#sliceT] "ns") (![#uint64T] "j")))
        then break: #()
        else do:  #());;;
        do:  (let: "$a0" := (![#sliceT] "ns") in
        let: "$a1" := ((![#uint64T] "j") - #(W64 1)) in
        let: "$a2" := (![#uint64T] "j") in
        (func_call #util.util #"swap"%go) "$a0" "$a1" "$a2");;;
        do:  ("j" <-[#uint64T] ((![#uint64T] "j") - #(W64 1))));;;
      do:  ("i" <-[#uint64T] ((![#uint64T] "i") + #(W64 1))))).

(* go: util.go:43:6 *)
Definition CountBoolMap : val :=
  rec: "CountBoolMap" "m" "b" :=
    exception_do (let: "b" := (mem.alloc "b") in
    let: "m" := (mem.alloc "m") in
    let: "n" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("n" <-[#uint64T] "$r0");;;
    let: "$range" := (![type.mapT #uint64T #boolT] "m") in
    (let: "v" := (mem.alloc (type.zero_val #uint64T)) in
    map.for_range "$range" (λ: "$key" "value",
      do:  ("v" <-[#boolT] "$value");;;
      do:  "$key";;;
      (if: (![#boolT] "v") = (![#boolT] "b")
      then
        let: "$r0" := (let: "$a0" := (![#uint64T] "n") in
        let: "$a1" := #(W64 1) in
        (func_call #std.std #"SumAssumeNoOverflow"%go) "$a0" "$a1") in
        do:  ("n" <-[#uint64T] "$r0")
      else do:  #())));;;
    return: (![#uint64T] "n")).

(* go: util.go:58:6 *)
Definition EncodeInts : val :=
  rec: "EncodeInts" "bs" "ns" :=
    exception_do (let: "ns" := (mem.alloc "ns") in
    let: "bs" := (mem.alloc "bs") in
    let: "data" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "bs") in
    let: "$a1" := (s_to_w64 (let: "$a0" := (![#sliceT] "ns") in
    slice.len "$a0")) in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("data" <-[#sliceT] "$r0");;;
    let: "$range" := (![#sliceT] "ns") in
    (let: "s" := (mem.alloc (type.zero_val #intT)) in
    slice.for_range #uint64T "$range" (λ: "$key" "$value",
      do:  ("s" <-[#uint64T] "$value");;;
      do:  "$key";;;
      let: "$r0" := (let: "$a0" := (![#sliceT] "data") in
      let: "$a1" := (![#uint64T] "s") in
      (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
      do:  ("data" <-[#sliceT] "$r0")));;;
    return: (![#sliceT] "data")).

(* go: util.go:68:6 *)
Definition DecodeInts : val :=
  rec: "DecodeInts" "bs" :=
    exception_do (let: "bs" := (mem.alloc "bs") in
    let: "bs1" := (mem.alloc (type.zero_val #sliceT)) in
    let: "n" := (mem.alloc (type.zero_val #uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "bs") in
    (func_call #marshal.marshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("n" <-[#uint64T] "$r0");;;
    do:  ("bs1" <-[#sliceT] "$r1");;;
    let: "data" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "bs1") in
    do:  ("data" <-[#sliceT] "$r0");;;
    let: "ents" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make3 #uint64T #(W64 0) (![#uint64T] "n")) in
    do:  ("ents" <-[#sliceT] "$r0");;;
    let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (for: (λ: <>, (![#uint64T] "i") < (![#uint64T] "n")); (λ: <>, Skip) := λ: <>,
      let: "bsloop" := (mem.alloc (type.zero_val #sliceT)) in
      let: "s" := (mem.alloc (type.zero_val #uint64T)) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "data") in
      (func_call #marshal.marshal #"ReadInt"%go) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("s" <-[#uint64T] "$r0");;;
      do:  ("bsloop" <-[#sliceT] "$r1");;;
      let: "$r0" := (let: "$a0" := (![#sliceT] "ents") in
      let: "$a1" := ((let: "$sl0" := (![#uint64T] "s") in
      slice.literal #uint64T ["$sl0"])) in
      (slice.append #uint64T) "$a0" "$a1") in
      do:  ("ents" <-[#sliceT] "$r0");;;
      let: "$r0" := (![#sliceT] "bsloop") in
      do:  ("data" <-[#sliceT] "$r0");;;
      do:  ("i" <-[#uint64T] ((![#uint64T] "i") + #(W64 1))));;;
    return: (![#sliceT] "ents", ![#sliceT] "data")).

(* go: util.go:85:6 *)
Definition EncodeString : val :=
  rec: "EncodeString" "bs" "str" :=
    exception_do (let: "str" := (mem.alloc "str") in
    let: "bs" := (mem.alloc "bs") in
    let: "bs1" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "bs") in
    let: "$a1" := (s_to_w64 (let: "$a0" := (![#stringT] "str") in
    StringLength "$a0")) in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("bs1" <-[#sliceT] "$r0");;;
    let: "data" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "bs1") in
    let: "$a1" := (string.to_bytes (![#stringT] "str")) in
    (func_call #marshal.marshal #"WriteBytes"%go) "$a0" "$a1") in
    do:  ("data" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "data")).

(* go: util.go:91:6 *)
Definition EncodeStrings : val :=
  rec: "EncodeStrings" "bs" "strs" :=
    exception_do (let: "strs" := (mem.alloc "strs") in
    let: "bs" := (mem.alloc "bs") in
    let: "data" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "bs") in
    let: "$a1" := (s_to_w64 (let: "$a0" := (![#sliceT] "strs") in
    slice.len "$a0")) in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("data" <-[#sliceT] "$r0");;;
    let: "$range" := (![#sliceT] "strs") in
    (let: "s" := (mem.alloc (type.zero_val #intT)) in
    slice.for_range #stringT "$range" (λ: "$key" "$value",
      do:  ("s" <-[#stringT] "$value");;;
      do:  "$key";;;
      let: "$r0" := (let: "$a0" := (![#sliceT] "data") in
      let: "$a1" := (![#stringT] "s") in
      (func_call #util.util #"EncodeString"%go) "$a0" "$a1") in
      do:  ("data" <-[#sliceT] "$r0")));;;
    return: (![#sliceT] "data")).

(* go: util.go:101:6 *)
Definition DecodeString : val :=
  rec: "DecodeString" "bs" :=
    exception_do (let: "bs" := (mem.alloc "bs") in
    let: "bs1" := (mem.alloc (type.zero_val #sliceT)) in
    let: "sz" := (mem.alloc (type.zero_val #uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "bs") in
    (func_call #marshal.marshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("sz" <-[#uint64T] "$r0");;;
    do:  ("bs1" <-[#sliceT] "$r1");;;
    let: "data" := (mem.alloc (type.zero_val #sliceT)) in
    let: "bsr" := (mem.alloc (type.zero_val #sliceT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "bs1") in
    let: "$a1" := (![#uint64T] "sz") in
    (func_call #marshal.marshal #"ReadBytes"%go) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("bsr" <-[#sliceT] "$r0");;;
    do:  ("data" <-[#sliceT] "$r1");;;
    return: (string.from_bytes (![#sliceT] "bsr"), ![#sliceT] "data")).

(* go: util.go:107:6 *)
Definition DecodeStrings : val :=
  rec: "DecodeStrings" "bs" :=
    exception_do (let: "bs" := (mem.alloc "bs") in
    let: "bs1" := (mem.alloc (type.zero_val #sliceT)) in
    let: "n" := (mem.alloc (type.zero_val #uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "bs") in
    (func_call #marshal.marshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("n" <-[#uint64T] "$r0");;;
    do:  ("bs1" <-[#sliceT] "$r1");;;
    let: "data" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "bs1") in
    do:  ("data" <-[#sliceT] "$r0");;;
    let: "ents" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make3 #stringT #(W64 0) (![#uint64T] "n")) in
    do:  ("ents" <-[#sliceT] "$r0");;;
    let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (for: (λ: <>, (![#uint64T] "i") < (![#uint64T] "n")); (λ: <>, Skip) := λ: <>,
      let: "bsloop" := (mem.alloc (type.zero_val #sliceT)) in
      let: "s" := (mem.alloc (type.zero_val #stringT)) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "data") in
      (func_call #util.util #"DecodeString"%go) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("s" <-[#stringT] "$r0");;;
      do:  ("bsloop" <-[#sliceT] "$r1");;;
      let: "$r0" := (let: "$a0" := (![#sliceT] "ents") in
      let: "$a1" := ((let: "$sl0" := (![#stringT] "s") in
      slice.literal #stringT ["$sl0"])) in
      (slice.append #stringT) "$a0" "$a1") in
      do:  ("ents" <-[#sliceT] "$r0");;;
      let: "$r0" := (![#sliceT] "bsloop") in
      do:  ("data" <-[#sliceT] "$r0");;;
      do:  ("i" <-[#uint64T] ((![#uint64T] "i") + #(W64 1))));;;
    return: (![#sliceT] "ents", ![#sliceT] "data")).

(* go: util.go:124:6 *)
Definition EncodePrepareProposal : val :=
  rec: "EncodePrepareProposal" "bs" "pp" :=
    exception_do (let: "pp" := (mem.alloc "pp") in
    let: "bs" := (mem.alloc "bs") in
    let: "bs1" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "bs") in
    let: "$a1" := (![#uint64T] (struct.field_ref #tulip.PrepareProposal #"Rank"%go "pp")) in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("bs1" <-[#sliceT] "$r0");;;
    let: "data" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "bs1") in
    let: "$a1" := (![#boolT] (struct.field_ref #tulip.PrepareProposal #"Prepared"%go "pp")) in
    (func_call #marshal.marshal #"WriteBool"%go) "$a0" "$a1") in
    do:  ("data" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "data")).

(* go: util.go:130:6 *)
Definition DecodePrepareProposal : val :=
  rec: "DecodePrepareProposal" "bs" :=
    exception_do (let: "bs" := (mem.alloc "bs") in
    let: "bs1" := (mem.alloc (type.zero_val #sliceT)) in
    let: "rank" := (mem.alloc (type.zero_val #uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "bs") in
    (func_call #marshal.marshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("rank" <-[#uint64T] "$r0");;;
    do:  ("bs1" <-[#sliceT] "$r1");;;
    let: "data" := (mem.alloc (type.zero_val #sliceT)) in
    let: "prepared" := (mem.alloc (type.zero_val #boolT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "bs1") in
    (func_call #marshal.marshal #"ReadBool"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("prepared" <-[#boolT] "$r0");;;
    do:  ("data" <-[#sliceT] "$r1");;;
    let: "pp" := (mem.alloc (type.zero_val #tulip.PrepareProposal)) in
    let: "$r0" := (let: "$Rank" := (![#uint64T] "rank") in
    let: "$Prepared" := (![#boolT] "prepared") in
    struct.make #tulip.PrepareProposal [{
      "Rank" ::= "$Rank";
      "Prepared" ::= "$Prepared"
    }]) in
    do:  ("pp" <-[#tulip.PrepareProposal] "$r0");;;
    return: (![#tulip.PrepareProposal] "pp", ![#sliceT] "data")).

(* go: util.go:140:6 *)
Definition EncodeValue : val :=
  rec: "EncodeValue" "bs" "v" :=
    exception_do (let: "v" := (mem.alloc "v") in
    let: "bs" := (mem.alloc "bs") in
    (if: (~ (![#boolT] (struct.field_ref #tulip.Value #"Present"%go "v")))
    then
      let: "data" := (mem.alloc (type.zero_val #sliceT)) in
      let: "$r0" := (let: "$a0" := (![#sliceT] "bs") in
      let: "$a1" := #false in
      (func_call #marshal.marshal #"WriteBool"%go) "$a0" "$a1") in
      do:  ("data" <-[#sliceT] "$r0");;;
      return: (![#sliceT] "data")
    else do:  #());;;
    let: "bs1" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "bs") in
    let: "$a1" := #true in
    (func_call #marshal.marshal #"WriteBool"%go) "$a0" "$a1") in
    do:  ("bs1" <-[#sliceT] "$r0");;;
    let: "data" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "bs1") in
    let: "$a1" := (![#stringT] (struct.field_ref #tulip.Value #"Content"%go "v")) in
    (func_call #util.util #"EncodeString"%go) "$a0" "$a1") in
    do:  ("data" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "data")).

(* go: util.go:151:6 *)
Definition DecodeValue : val :=
  rec: "DecodeValue" "bs" :=
    exception_do (let: "bs" := (mem.alloc "bs") in
    let: "bs1" := (mem.alloc (type.zero_val #sliceT)) in
    let: "b" := (mem.alloc (type.zero_val #boolT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "bs") in
    (func_call #marshal.marshal #"ReadBool"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("b" <-[#boolT] "$r0");;;
    do:  ("bs1" <-[#sliceT] "$r1");;;
    (if: (~ (![#boolT] "b"))
    then
      let: "v" := (mem.alloc (type.zero_val #tulip.Value)) in
      let: "$r0" := (let: "$Present" := #false in
      let: "$Content" := #""%go in
      struct.make #tulip.Value [{
        "Present" ::= "$Present";
        "Content" ::= "$Content"
      }]) in
      do:  ("v" <-[#tulip.Value] "$r0");;;
      return: (![#tulip.Value] "v", ![#sliceT] "bs1")
    else do:  #());;;
    let: "data" := (mem.alloc (type.zero_val #sliceT)) in
    let: "s" := (mem.alloc (type.zero_val #stringT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "bs1") in
    (func_call #util.util #"DecodeString"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("s" <-[#stringT] "$r0");;;
    do:  ("data" <-[#sliceT] "$r1");;;
    let: "v" := (mem.alloc (type.zero_val #tulip.Value)) in
    let: "$r0" := (let: "$Present" := #true in
    let: "$Content" := (![#stringT] "s") in
    struct.make #tulip.Value [{
      "Present" ::= "$Present";
      "Content" ::= "$Content"
    }]) in
    do:  ("v" <-[#tulip.Value] "$r0");;;
    return: (![#tulip.Value] "v", ![#sliceT] "data")).

(* go: util.go:170:6 *)
Definition EncodeVersion : val :=
  rec: "EncodeVersion" "bs" "x" :=
    exception_do (let: "x" := (mem.alloc "x") in
    let: "bs" := (mem.alloc "bs") in
    let: "bs1" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "bs") in
    let: "$a1" := (![#uint64T] (struct.field_ref #tulip.Version #"Timestamp"%go "x")) in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("bs1" <-[#sliceT] "$r0");;;
    let: "data" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "bs1") in
    let: "$a1" := (![#tulip.Value] (struct.field_ref #tulip.Version #"Value"%go "x")) in
    (func_call #util.util #"EncodeValue"%go) "$a0" "$a1") in
    do:  ("data" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "data")).

(* go: util.go:176:6 *)
Definition DecodeVersion : val :=
  rec: "DecodeVersion" "bs" :=
    exception_do (let: "bs" := (mem.alloc "bs") in
    let: "bs1" := (mem.alloc (type.zero_val #sliceT)) in
    let: "ts" := (mem.alloc (type.zero_val #uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "bs") in
    (func_call #marshal.marshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("ts" <-[#uint64T] "$r0");;;
    do:  ("bs1" <-[#sliceT] "$r1");;;
    let: "data" := (mem.alloc (type.zero_val #sliceT)) in
    let: "v" := (mem.alloc (type.zero_val #tulip.Value)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "bs1") in
    (func_call #util.util #"DecodeValue"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("v" <-[#tulip.Value] "$r0");;;
    do:  ("data" <-[#sliceT] "$r1");;;
    let: "x" := (mem.alloc (type.zero_val #tulip.Version)) in
    let: "$r0" := (let: "$Timestamp" := (![#uint64T] "ts") in
    let: "$Value" := (![#tulip.Value] "v") in
    struct.make #tulip.Version [{
      "Timestamp" ::= "$Timestamp";
      "Value" ::= "$Value"
    }]) in
    do:  ("x" <-[#tulip.Version] "$r0");;;
    return: (![#tulip.Version] "x", ![#sliceT] "data")).

(* go: util.go:186:6 *)
Definition EncodeWriteEntry : val :=
  rec: "EncodeWriteEntry" "bs" "x" :=
    exception_do (let: "x" := (mem.alloc "x") in
    let: "bs" := (mem.alloc "bs") in
    let: "bs1" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "bs") in
    let: "$a1" := (![#stringT] (struct.field_ref #tulip.WriteEntry #"Key"%go "x")) in
    (func_call #util.util #"EncodeString"%go) "$a0" "$a1") in
    do:  ("bs1" <-[#sliceT] "$r0");;;
    let: "data" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "bs1") in
    let: "$a1" := (![#tulip.Value] (struct.field_ref #tulip.WriteEntry #"Value"%go "x")) in
    (func_call #util.util #"EncodeValue"%go) "$a0" "$a1") in
    do:  ("data" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "data")).

(* go: util.go:192:6 *)
Definition DecodeWriteEntry : val :=
  rec: "DecodeWriteEntry" "bs" :=
    exception_do (let: "bs" := (mem.alloc "bs") in
    let: "bs1" := (mem.alloc (type.zero_val #sliceT)) in
    let: "k" := (mem.alloc (type.zero_val #stringT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "bs") in
    (func_call #util.util #"DecodeString"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("k" <-[#stringT] "$r0");;;
    do:  ("bs1" <-[#sliceT] "$r1");;;
    let: "data" := (mem.alloc (type.zero_val #sliceT)) in
    let: "v" := (mem.alloc (type.zero_val #tulip.Value)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "bs1") in
    (func_call #util.util #"DecodeValue"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("v" <-[#tulip.Value] "$r0");;;
    do:  ("data" <-[#sliceT] "$r1");;;
    let: "x" := (mem.alloc (type.zero_val #tulip.WriteEntry)) in
    let: "$r0" := (let: "$Key" := (![#stringT] "k") in
    let: "$Value" := (![#tulip.Value] "v") in
    struct.make #tulip.WriteEntry [{
      "Key" ::= "$Key";
      "Value" ::= "$Value"
    }]) in
    do:  ("x" <-[#tulip.WriteEntry] "$r0");;;
    return: (![#tulip.WriteEntry] "x", ![#sliceT] "data")).

(* go: util.go:202:6 *)
Definition EncodeKVMap : val :=
  rec: "EncodeKVMap" "bs" "m" :=
    exception_do (let: "m" := (mem.alloc "m") in
    let: "bs" := (mem.alloc "bs") in
    let: "data" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "bs") in
    let: "$a1" := (s_to_w64 (let: "$a0" := (![#tulip.KVMap] "m") in
    map.len "$a0")) in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("data" <-[#sliceT] "$r0");;;
    let: "$range" := (![#tulip.KVMap] "m") in
    (let: "v" := (mem.alloc (type.zero_val #stringT)) in
    let: "k" := (mem.alloc (type.zero_val #stringT)) in
    map.for_range "$range" (λ: "$key" "value",
      do:  ("v" <-[#tulip.Value] "$value");;;
      do:  ("k" <-[#stringT] "$key");;;
      let: "x" := (mem.alloc (type.zero_val #tulip.WriteEntry)) in
      let: "$r0" := (let: "$Key" := (![#stringT] "k") in
      let: "$Value" := (![#tulip.Value] "v") in
      struct.make #tulip.WriteEntry [{
        "Key" ::= "$Key";
        "Value" ::= "$Value"
      }]) in
      do:  ("x" <-[#tulip.WriteEntry] "$r0");;;
      let: "$r0" := (let: "$a0" := (![#sliceT] "data") in
      let: "$a1" := (![#tulip.WriteEntry] "x") in
      (func_call #util.util #"EncodeWriteEntry"%go) "$a0" "$a1") in
      do:  ("data" <-[#sliceT] "$r0")));;;
    return: (![#sliceT] "data")).

(* go: util.go:216:6 *)
Definition EncodeKVMapFromSlice : val :=
  rec: "EncodeKVMapFromSlice" "bs" "xs" :=
    exception_do (let: "xs" := (mem.alloc "xs") in
    let: "bs" := (mem.alloc "bs") in
    let: "data" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "bs") in
    let: "$a1" := (s_to_w64 (let: "$a0" := (![#sliceT] "xs") in
    slice.len "$a0")) in
    (func_call #marshal.marshal #"WriteInt"%go) "$a0" "$a1") in
    do:  ("data" <-[#sliceT] "$r0");;;
    let: "$range" := (![#sliceT] "xs") in
    (let: "x" := (mem.alloc (type.zero_val #intT)) in
    slice.for_range #tulip.WriteEntry "$range" (λ: "$key" "$value",
      do:  ("x" <-[#tulip.WriteEntry] "$value");;;
      do:  "$key";;;
      let: "$r0" := (let: "$a0" := (![#sliceT] "data") in
      let: "$a1" := (![#tulip.WriteEntry] "x") in
      (func_call #util.util #"EncodeWriteEntry"%go) "$a0" "$a1") in
      do:  ("data" <-[#sliceT] "$r0")));;;
    return: (![#sliceT] "data")).

(* go: util.go:226:6 *)
Definition DecodeKVMapIntoSlice : val :=
  rec: "DecodeKVMapIntoSlice" "bs" :=
    exception_do (let: "bs" := (mem.alloc "bs") in
    let: "bs1" := (mem.alloc (type.zero_val #sliceT)) in
    let: "n" := (mem.alloc (type.zero_val #uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "bs") in
    (func_call #marshal.marshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("n" <-[#uint64T] "$r0");;;
    do:  ("bs1" <-[#sliceT] "$r1");;;
    let: "data" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "bs1") in
    do:  ("data" <-[#sliceT] "$r0");;;
    let: "ents" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make3 #tulip.WriteEntry #(W64 0) (![#uint64T] "n")) in
    do:  ("ents" <-[#sliceT] "$r0");;;
    let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (for: (λ: <>, (![#uint64T] "i") < (![#uint64T] "n")); (λ: <>, Skip) := λ: <>,
      let: "bsloop" := (mem.alloc (type.zero_val #sliceT)) in
      let: "x" := (mem.alloc (type.zero_val #tulip.WriteEntry)) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "data") in
      (func_call #util.util #"DecodeWriteEntry"%go) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("x" <-[#tulip.WriteEntry] "$r0");;;
      do:  ("bsloop" <-[#sliceT] "$r1");;;
      let: "$r0" := (let: "$a0" := (![#sliceT] "ents") in
      let: "$a1" := ((let: "$sl0" := (![#tulip.WriteEntry] "x") in
      slice.literal #tulip.WriteEntry ["$sl0"])) in
      (slice.append #tulip.WriteEntry) "$a0" "$a1") in
      do:  ("ents" <-[#sliceT] "$r0");;;
      let: "$r0" := (![#sliceT] "bsloop") in
      do:  ("data" <-[#sliceT] "$r0");;;
      do:  ("i" <-[#uint64T] ((![#uint64T] "i") + #(W64 1))));;;
    return: (![#sliceT] "ents", ![#sliceT] "data")).

(* go: util.go:243:6 *)
Definition DecodeKVMap : val :=
  rec: "DecodeKVMap" "bs" :=
    exception_do (let: "bs" := (mem.alloc "bs") in
    let: "bs1" := (mem.alloc (type.zero_val #sliceT)) in
    let: "n" := (mem.alloc (type.zero_val #uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "bs") in
    (func_call #marshal.marshal #"ReadInt"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("n" <-[#uint64T] "$r0");;;
    do:  ("bs1" <-[#sliceT] "$r1");;;
    let: "data" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "bs1") in
    do:  ("data" <-[#sliceT] "$r0");;;
    let: "m" := (mem.alloc (type.zero_val (type.mapT #stringT #tulip.Value))) in
    let: "$r0" := (map.make #stringT #tulip.Value) in
    do:  ("m" <-[type.mapT #stringT #tulip.Value] "$r0");;;
    let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (for: (λ: <>, (![#uint64T] "i") < (![#uint64T] "n")); (λ: <>, Skip) := λ: <>,
      let: "bsloop" := (mem.alloc (type.zero_val #sliceT)) in
      let: "x" := (mem.alloc (type.zero_val #tulip.WriteEntry)) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "data") in
      (func_call #util.util #"DecodeWriteEntry"%go) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("x" <-[#tulip.WriteEntry] "$r0");;;
      do:  ("bsloop" <-[#sliceT] "$r1");;;
      let: "$r0" := (![#tulip.Value] (struct.field_ref #tulip.WriteEntry #"Value"%go "x")) in
      do:  (map.insert (![type.mapT #stringT #tulip.Value] "m") (![#stringT] (struct.field_ref #tulip.WriteEntry #"Key"%go "x")) "$r0");;;
      let: "$r0" := (![#sliceT] "bsloop") in
      do:  ("data" <-[#sliceT] "$r0");;;
      do:  ("i" <-[#uint64T] ((![#uint64T] "i") + #(W64 1))));;;
    return: (![type.mapT #stringT #tulip.Value] "m", ![#sliceT] "data")).

Definition vars' : list (go_string * go_type) := [].

Definition functions' : list (go_string * val) := [("NextAligned"%go, NextAligned); ("swap"%go, swap); ("Sort"%go, Sort); ("CountBoolMap"%go, CountBoolMap); ("EncodeInts"%go, EncodeInts); ("DecodeInts"%go, DecodeInts); ("EncodeString"%go, EncodeString); ("EncodeStrings"%go, EncodeStrings); ("DecodeString"%go, DecodeString); ("DecodeStrings"%go, DecodeStrings); ("EncodePrepareProposal"%go, EncodePrepareProposal); ("DecodePrepareProposal"%go, DecodePrepareProposal); ("EncodeValue"%go, EncodeValue); ("DecodeValue"%go, DecodeValue); ("EncodeVersion"%go, EncodeVersion); ("DecodeVersion"%go, DecodeVersion); ("EncodeWriteEntry"%go, EncodeWriteEntry); ("DecodeWriteEntry"%go, DecodeWriteEntry); ("EncodeKVMap"%go, EncodeKVMap); ("EncodeKVMapFromSlice"%go, EncodeKVMapFromSlice); ("DecodeKVMapIntoSlice"%go, DecodeKVMapIntoSlice); ("DecodeKVMap"%go, DecodeKVMap)].

Definition msets' : list (go_string * (list (go_string * val))) := [].

#[global] Instance info' : PkgInfo util.util :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [std.std; marshal.marshal; tulip.tulip];
  |}.

Definition initialize' : val :=
  rec: "initialize'" <> :=
    globals.package_init util.util (λ: <>,
      exception_do (do:  tulip.initialize';;;
      do:  marshal.initialize';;;
      do:  std.initialize')
      ).

End code.
End util.
