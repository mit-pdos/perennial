(* autogenerated from github.com/mit-pdos/go-liveness/ticketlock *)
Require Export New.code.sync.atomic.

From New.golang Require Import defn.
Require Export New.trusted_code.github_com.mit_pdos.go_liveness.ticketlock.
Import ticketlock.
Definition ticketlock : go_string := "github.com/mit-pdos/go-liveness/ticketlock".

Module ticketlock.

Module TicketLock. Definition id : go_string := "github.com/mit-pdos/go-liveness/ticketlock.TicketLock"%go. End TicketLock.

Section code.
Context `{ffi_syntax}.


Definition TicketLock : go_type := structT [
  "cur" :: atomic.Uint64;
  "next" :: atomic.Uint64
].

Definition New : go_string := "github.com/mit-pdos/go-liveness/ticketlock.New"%go.

(* go: lock.go:13:6 *)
Definition Newⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (let: "t" := (mem.alloc (type.zero_val #TicketLock)) in
    return: ("t")).

(* go: lock.go:18:22 *)
Definition TicketLock__Acquireⁱᵐᵖˡ : val :=
  λ: "t" <>,
    exception_do (let: "t" := (mem.alloc "t") in
    let: "my" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := ((let: "$a0" := #(W64 1) in
    (method_call #(ptrT.id atomic.Uint64.id) #"Add"%go (struct.field_ref #TicketLock #"next"%go (![#ptrT] "t"))) "$a0") - #(W64 1)) in
    do:  ("my" <-[#uint64T] "$r0");;;
    (for: (λ: <>, ((method_call #(ptrT.id atomic.Uint64.id) #"Load"%go (struct.field_ref #TicketLock #"cur"%go (![#ptrT] "t"))) #()) ≠ (![#uint64T] "my")); (λ: <>, #()) := λ: <>,
      do:  ((func_call #runtime.Gosched) #()));;;
    return: #()).

(* go: lock.go:28:22 *)
Definition TicketLock__Releaseⁱᵐᵖˡ : val :=
  λ: "t" <>,
    exception_do (let: "t" := (mem.alloc "t") in
    do:  (let: "$a0" := #(W64 1) in
    (method_call #(ptrT.id atomic.Uint64.id) #"Add"%go (struct.field_ref #TicketLock #"cur"%go (![#ptrT] "t"))) "$a0");;;
    return: #()).

Definition vars' : list (go_string * go_type) := [].

Definition functions' : list (go_string * val) := [(New, Newⁱᵐᵖˡ)].

Definition msets' : list (go_string * (list (go_string * val))) := [(TicketLock.id, []); (ptrT.id TicketLock.id, [("Acquire"%go, TicketLock__Acquireⁱᵐᵖˡ); ("Release"%go, TicketLock__Releaseⁱᵐᵖˡ)])].

#[global] Instance info' : PkgInfo ticketlock.ticketlock :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [code.sync.atomic.atomic];
  |}.

Definition initialize' : val :=
  λ: <>,
    package.init #ticketlock.ticketlock (λ: <>,
      exception_do (do:  (atomic.initialize' #());;;
      do:  (package.alloc ticketlock.ticketlock #()))
      ).

End code.
End ticketlock.
