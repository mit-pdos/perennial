(* autogenerated from github.com/mit-pdos/go-journal/wal *)
Require Export New.code.github_com.goose_lang.primitive.disk.
Require Export New.code.github_com.mit_pdos.go_journal.common.
Require Export New.code.github_com.tchajed.marshal.
Require Export New.code.github_com.mit_pdos.go_journal.util.
Require Export New.code.sync.
Require Export New.code.github_com.goose_lang.primitive.
From New.golang Require Import defn.
From New Require Import disk_prelude.
Module pkg_id.
Definition wal : go_string := "github.com/mit-pdos/go-journal/wal".

End pkg_id.
Export pkg_id.
Module wal.

Definition LogPosition {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/mit-pdos/go-journal/wal.LogPosition"%go [].

Definition Update {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/mit-pdos/go-journal/wal.Update"%go [].

Definition circularAppender {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/mit-pdos/go-journal/wal.circularAppender"%go [].

Definition sliding {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/mit-pdos/go-journal/wal.sliding"%go [].

Definition WalogState {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/mit-pdos/go-journal/wal.WalogState"%go [].

Definition Walog {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/mit-pdos/go-journal/wal.Walog"%go [].

(* space for the end position *)
Definition HDRMETA {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 8).

Definition HDRADDRS {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 511).

Definition LOGSZ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 511).

(* 2 for log header *)
Definition LOGDISKBLOCKS {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 513).

Definition LOGHDR {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 0).

Definition LOGHDR2 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 1).

Definition LOGSTART {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 2).

Definition MkBlockData {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/go-journal/wal.MkBlockData"%go.

Definition initCircular {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/go-journal/wal.initCircular"%go.

Definition decodeHdr1 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/go-journal/wal.decodeHdr1"%go.

Definition decodeHdr2 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/go-journal/wal.decodeHdr2"%go.

Definition recoverCircular {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/go-journal/wal.recoverCircular"%go.

Definition hdr2 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/go-journal/wal.hdr2"%go.

Definition Advance {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/go-journal/wal.Advance"%go.

Definition mkSliding {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/go-journal/wal.mkSliding"%go.

Definition absorbBufs {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/go-journal/wal.absorbBufs"%go.

Definition installBlocks {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/go-journal/wal.installBlocks"%go.

Definition mkLog {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/go-journal/wal.mkLog"%go.

Definition MkLog {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/go-journal/wal.MkLog"%go.

Definition doMemAppend {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/go-journal/wal.doMemAppend"%go.

Definition copyUpdateBlock {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/go-journal/wal.copyUpdateBlock"%go.

(* go: 0circular.go:18:6 *)
Definition MkBlockDataⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "bn" "blk",
    exception_do (let: "blk" := (GoAlloc disk.Block "blk") in
    let: "bn" := (GoAlloc common.Bnum "bn") in
    let: "b" := (GoAlloc Update (GoZeroVal Update #())) in
    let: "$r0" := (CompositeLiteral Update (LiteralValue [KeyedElement (Some (KeyField "Addr"%go)) (ElementExpression common.Bnum (![common.Bnum] "bn")); KeyedElement (Some (KeyField "Block"%go)) (ElementExpression disk.Block (![disk.Block] "blk"))])) in
    do:  ("b" <-[Update] "$r0");;;
    return: (![Update] "b")).

(* initCircular takes ownership of the circular log, which is the first
   LOGDISKBLOCKS of the disk.

   go: 0circular.go:29:6 *)
Definition initCircularⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "d",
    exception_do (let: "d" := (GoAlloc disk.Disk "d") in
    let: "b0" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) disk.BlockSize) in
    do:  ("b0" <-[go.SliceType go.byte] "$r0");;;
    do:  (let: "$a0" := LOGHDR in
    let: "$a1" := (![go.SliceType go.byte] "b0") in
    (MethodResolve disk.Disk "Write"%go (![disk.Disk] "d")) "$a0" "$a1");;;
    do:  (let: "$a0" := LOGHDR2 in
    let: "$a1" := (![go.SliceType go.byte] "b0") in
    (MethodResolve disk.Disk "Write"%go (![disk.Disk] "d")) "$a0" "$a1");;;
    let: "addrs" := (GoAlloc (go.SliceType go.uint64) (GoZeroVal (go.SliceType go.uint64) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType go.uint64] #()) HDRADDRS) in
    do:  ("addrs" <-[go.SliceType go.uint64] "$r0");;;
    return: (GoAlloc circularAppender (CompositeLiteral circularAppender (LiteralValue [KeyedElement (Some (KeyField "diskAddrs"%go)) (ElementExpression (go.SliceType go.uint64) (![go.SliceType go.uint64] "addrs"))])))).

(* decodeHdr1 decodes (end, start) from hdr1

   go: 0circular.go:40:6 *)
Definition decodeHdr1ⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "hdr1",
    exception_do (let: "hdr1" := (GoAlloc disk.Block "hdr1") in
    let: "dec1" := (GoAlloc marshal.Dec (GoZeroVal marshal.Dec #())) in
    let: "$r0" := (let: "$a0" := (![disk.Block] "hdr1") in
    (FuncResolve marshal.NewDec [] #()) "$a0") in
    do:  ("dec1" <-[marshal.Dec] "$r0");;;
    let: "end" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := ((MethodResolve marshal.Dec "GetInt"%go (![marshal.Dec] "dec1")) #()) in
    do:  ("end" <-[go.uint64] "$r0");;;
    let: "addrs" := (GoAlloc (go.SliceType go.uint64) (GoZeroVal (go.SliceType go.uint64) #())) in
    let: "$r0" := (let: "$a0" := HDRADDRS in
    (MethodResolve marshal.Dec "GetInts"%go (![marshal.Dec] "dec1")) "$a0") in
    do:  ("addrs" <-[go.SliceType go.uint64] "$r0");;;
    return: (![go.uint64] "end", ![go.SliceType go.uint64] "addrs")).

(* decodeHdr2 reads start from hdr2

   go: 0circular.go:48:6 *)
Definition decodeHdr2ⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "hdr2",
    exception_do (let: "hdr2" := (GoAlloc disk.Block "hdr2") in
    let: "dec2" := (GoAlloc marshal.Dec (GoZeroVal marshal.Dec #())) in
    let: "$r0" := (let: "$a0" := (![disk.Block] "hdr2") in
    (FuncResolve marshal.NewDec [] #()) "$a0") in
    do:  ("dec2" <-[marshal.Dec] "$r0");;;
    let: "start" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := ((MethodResolve marshal.Dec "GetInt"%go (![marshal.Dec] "dec2")) #()) in
    do:  ("start" <-[go.uint64] "$r0");;;
    return: (![go.uint64] "start")).

(* go: 0circular.go:54:6 *)
Definition recoverCircularⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "d",
    exception_do (let: "d" := (GoAlloc disk.Disk "d") in
    let: "hdr1" := (GoAlloc disk.Block (GoZeroVal disk.Block #())) in
    let: "$r0" := (let: "$a0" := LOGHDR in
    (MethodResolve disk.Disk "Read"%go (![disk.Disk] "d")) "$a0") in
    do:  ("hdr1" <-[disk.Block] "$r0");;;
    let: "hdr2" := (GoAlloc disk.Block (GoZeroVal disk.Block #())) in
    let: "$r0" := (let: "$a0" := LOGHDR2 in
    (MethodResolve disk.Disk "Read"%go (![disk.Disk] "d")) "$a0") in
    do:  ("hdr2" <-[disk.Block] "$r0");;;
    let: "addrs" := (GoAlloc (go.SliceType go.uint64) (GoZeroVal (go.SliceType go.uint64) #())) in
    let: "end" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![disk.Block] "hdr1") in
    (FuncResolve decodeHdr1 [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("end" <-[go.uint64] "$r0");;;
    do:  ("addrs" <-[go.SliceType go.uint64] "$r1");;;
    let: "start" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (let: "$a0" := (![disk.Block] "hdr2") in
    (FuncResolve decodeHdr2 [] #()) "$a0") in
    do:  ("start" <-[go.uint64] "$r0");;;
    let: "bufs" := (GoAlloc (go.SliceType Update) (GoZeroVal (go.SliceType Update) #())) in
    (let: "pos" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (![go.uint64] "start") in
    do:  ("pos" <-[go.uint64] "$r0");;;
    (for: (λ: <>, (![go.uint64] "pos") <⟨go.uint64⟩ (![go.uint64] "end")); (λ: <>, do:  ("pos" <-[go.uint64] ((![go.uint64] "pos") +⟨go.uint64⟩ #(W64 1)))) := λ: <>,
      let: "addr" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: "$r0" := (![go.uint64] (IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "addrs", Convert go.uint64 go.int ((![go.uint64] "pos") %⟨go.uint64⟩ LOGSZ)))) in
      do:  ("addr" <-[go.uint64] "$r0");;;
      let: "b" := (GoAlloc disk.Block (GoZeroVal disk.Block #())) in
      let: "$r0" := (let: "$a0" := (LOGSTART +⟨go.uint64⟩ ((![go.uint64] "pos") %⟨go.uint64⟩ LOGSZ)) in
      (MethodResolve disk.Disk "Read"%go (![disk.Disk] "d")) "$a0") in
      do:  ("b" <-[disk.Block] "$r0");;;
      let: "$r0" := (let: "$a0" := (![go.SliceType Update] "bufs") in
      let: "$a1" := ((let: "$sl0" := (CompositeLiteral Update (LiteralValue [KeyedElement (Some (KeyField "Addr"%go)) (ElementExpression go.uint64 (![go.uint64] "addr")); KeyedElement (Some (KeyField "Block"%go)) (ElementExpression disk.Block (![disk.Block] "b"))])) in
      CompositeLiteral (go.SliceType Update) (LiteralValue [KeyedElement None (ElementExpression Update "$sl0")]))) in
      (FuncResolve go.append [go.SliceType Update] #()) "$a0" "$a1") in
      do:  ("bufs" <-[go.SliceType Update] "$r0")));;;
    return: (GoAlloc circularAppender (CompositeLiteral circularAppender (LiteralValue [KeyedElement (Some (KeyField "diskAddrs"%go)) (ElementExpression (go.SliceType go.uint64) (![go.SliceType go.uint64] "addrs"))])), ![go.uint64] "start", ![go.uint64] "end", ![go.SliceType Update] "bufs")).

(* go: 0circular.go:70:28 *)
Definition circularAppender__hdr1ⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "c" "end",
    exception_do (let: "c" := (GoAlloc (go.PointerType circularAppender) "c") in
    let: "end" := (GoAlloc LogPosition "end") in
    let: "enc" := (GoAlloc marshal.Enc (GoZeroVal marshal.Enc #())) in
    let: "$r0" := (let: "$a0" := disk.BlockSize in
    (FuncResolve marshal.NewEnc [] #()) "$a0") in
    do:  ("enc" <-[marshal.Enc] "$r0");;;
    do:  (let: "$a0" := (![LogPosition] "end") in
    (MethodResolve marshal.Enc "PutInt"%go (![marshal.Enc] "enc")) "$a0");;;
    do:  (let: "$a0" := (![go.SliceType go.uint64] (StructFieldRef circularAppender "diskAddrs"%go (![go.PointerType circularAppender] "c"))) in
    (MethodResolve marshal.Enc "PutInts"%go (![marshal.Enc] "enc")) "$a0");;;
    return: ((MethodResolve marshal.Enc "Finish"%go (![marshal.Enc] "enc")) #())).

(* go: 0circular.go:77:6 *)
Definition hdr2ⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "start",
    exception_do (let: "start" := (GoAlloc LogPosition "start") in
    let: "enc" := (GoAlloc marshal.Enc (GoZeroVal marshal.Enc #())) in
    let: "$r0" := (let: "$a0" := disk.BlockSize in
    (FuncResolve marshal.NewEnc [] #()) "$a0") in
    do:  ("enc" <-[marshal.Enc] "$r0");;;
    do:  (let: "$a0" := (![LogPosition] "start") in
    (MethodResolve marshal.Enc "PutInt"%go (![marshal.Enc] "enc")) "$a0");;;
    return: ((MethodResolve marshal.Enc "Finish"%go (![marshal.Enc] "enc")) #())).

(* go: 0circular.go:83:28 *)
Definition circularAppender__logBlocksⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "c" "d" "end" "bufs",
    exception_do (let: "c" := (GoAlloc (go.PointerType circularAppender) "c") in
    let: "bufs" := (GoAlloc (go.SliceType Update) "bufs") in
    let: "end" := (GoAlloc LogPosition "end") in
    let: "d" := (GoAlloc disk.Disk "d") in
    let: "$range" := (![go.SliceType Update] "bufs") in
    (let: "buf" := (GoAlloc Update (GoZeroVal Update #())) in
    let: "i" := (GoAlloc go.int (GoZeroVal go.int #())) in
    slice.for_range Update "$range" (λ: "$key" "$value",
      do:  ("buf" <-[Update] "$value");;;
      do:  ("i" <-[go.int] "$key");;;
      let: "pos" := (GoAlloc LogPosition (GoZeroVal LogPosition #())) in
      let: "$r0" := ((![LogPosition] "end") +⟨go.uint64⟩ (Convert go.int LogPosition (![go.int] "i"))) in
      do:  ("pos" <-[LogPosition] "$r0");;;
      let: "blk" := (GoAlloc disk.Block (GoZeroVal disk.Block #())) in
      let: "$r0" := (![disk.Block] (StructFieldRef Update "Block"%go "buf")) in
      do:  ("blk" <-[disk.Block] "$r0");;;
      let: "blkno" := (GoAlloc common.Bnum (GoZeroVal common.Bnum #())) in
      let: "$r0" := (![common.Bnum] (StructFieldRef Update "Addr"%go "buf")) in
      do:  ("blkno" <-[common.Bnum] "$r0");;;
      do:  (let: "$a0" := #(W64 5) in
      let: "$a1" := #"logBlocks: %d to log block %d
      "%go in
      let: "$a2" := ((let: "$sl0" := (Convert common.Bnum (go.InterfaceType []) (![common.Bnum] "blkno")) in
      let: "$sl1" := (Convert LogPosition (go.InterfaceType []) (![LogPosition] "pos")) in
      CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1")]))) in
      (FuncResolve util.DPrintf [] #()) "$a0" "$a1" "$a2");;;
      do:  (let: "$a0" := (LOGSTART +⟨go.uint64⟩ ((![LogPosition] "pos") %⟨go.uint64⟩ LOGSZ)) in
      let: "$a1" := (![disk.Block] "blk") in
      (MethodResolve disk.Disk "Write"%go (![disk.Disk] "d")) "$a0" "$a1");;;
      let: "$r0" := (![common.Bnum] "blkno") in
      do:  ((IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] (StructFieldRef circularAppender "diskAddrs"%go (![go.PointerType circularAppender] "c")), Convert go.uint64 go.int ((![LogPosition] "pos") %⟨go.uint64⟩ LOGSZ))) <-[go.uint64] "$r0")));;;
    return: #()).

(* go: 0circular.go:95:28 *)
Definition circularAppender__Appendⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "c" "d" "end" "bufs",
    exception_do (let: "c" := (GoAlloc (go.PointerType circularAppender) "c") in
    let: "bufs" := (GoAlloc (go.SliceType Update) "bufs") in
    let: "end" := (GoAlloc LogPosition "end") in
    let: "d" := (GoAlloc disk.Disk "d") in
    do:  (let: "$a0" := (![disk.Disk] "d") in
    let: "$a1" := (![LogPosition] "end") in
    let: "$a2" := (![go.SliceType Update] "bufs") in
    (MethodResolve (go.PointerType circularAppender) "logBlocks"%go (![go.PointerType circularAppender] "c")) "$a0" "$a1" "$a2");;;
    do:  ((MethodResolve disk.Disk "Barrier"%go (![disk.Disk] "d")) #());;;
    let: "newEnd" := (GoAlloc LogPosition (GoZeroVal LogPosition #())) in
    let: "$r0" := ((![LogPosition] "end") +⟨go.uint64⟩ (Convert go.int LogPosition (let: "$a0" := (![go.SliceType Update] "bufs") in
    (FuncResolve go.len [go.SliceType Update] #()) "$a0"))) in
    do:  ("newEnd" <-[LogPosition] "$r0");;;
    let: "b" := (GoAlloc disk.Block (GoZeroVal disk.Block #())) in
    let: "$r0" := (let: "$a0" := (![LogPosition] "newEnd") in
    (MethodResolve (go.PointerType circularAppender) "hdr1"%go (![go.PointerType circularAppender] "c")) "$a0") in
    do:  ("b" <-[disk.Block] "$r0");;;
    do:  (let: "$a0" := LOGHDR in
    let: "$a1" := (![disk.Block] "b") in
    (MethodResolve disk.Disk "Write"%go (![disk.Disk] "d")) "$a0" "$a1");;;
    do:  ((MethodResolve disk.Disk "Barrier"%go (![disk.Disk] "d")) #());;;
    return: #()).

(* go: 0circular.go:105:6 *)
Definition Advanceⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "d" "newStart",
    exception_do (let: "newStart" := (GoAlloc LogPosition "newStart") in
    let: "d" := (GoAlloc disk.Disk "d") in
    let: "b" := (GoAlloc disk.Block (GoZeroVal disk.Block #())) in
    let: "$r0" := (let: "$a0" := (![LogPosition] "newStart") in
    (FuncResolve hdr2 [] #()) "$a0") in
    do:  ("b" <-[disk.Block] "$r0");;;
    do:  (let: "$a0" := LOGHDR2 in
    let: "$a1" := (![disk.Block] "b") in
    (MethodResolve disk.Disk "Write"%go (![disk.Disk] "d")) "$a0" "$a1");;;
    do:  ((MethodResolve disk.Disk "Barrier"%go (![disk.Disk] "d")) #());;;
    return: #()).

(* go: 0sliding.go:16:6 *)
Definition mkSlidingⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "log" "start",
    exception_do (let: "start" := (GoAlloc LogPosition "start") in
    let: "log" := (GoAlloc (go.SliceType Update) "log") in
    let: "addrPos" := (GoAlloc (go.MapType common.Bnum LogPosition) (GoZeroVal (go.MapType common.Bnum LogPosition) #())) in
    let: "$r0" := ((FuncResolve go.make1 [go.MapType common.Bnum LogPosition] #()) #()) in
    do:  ("addrPos" <-[go.MapType common.Bnum LogPosition] "$r0");;;
    let: "$range" := (![go.SliceType Update] "log") in
    (let: "buf" := (GoAlloc Update (GoZeroVal Update #())) in
    let: "i" := (GoAlloc go.int (GoZeroVal go.int #())) in
    slice.for_range Update "$range" (λ: "$key" "$value",
      do:  ("buf" <-[Update] "$value");;;
      do:  ("i" <-[go.int] "$key");;;
      let: "$r0" := ((![LogPosition] "start") +⟨go.uint64⟩ (Convert go.int LogPosition (![go.int] "i"))) in
      do:  (map.insert common.Bnum (![go.MapType common.Bnum LogPosition] "addrPos") (![common.Bnum] (StructFieldRef Update "Addr"%go "buf")) "$r0")));;;
    return: (GoAlloc sliding (CompositeLiteral sliding (LiteralValue [KeyedElement (Some (KeyField "log"%go)) (ElementExpression (go.SliceType Update) (![go.SliceType Update] "log")); KeyedElement (Some (KeyField "start"%go)) (ElementExpression LogPosition (![LogPosition] "start")); KeyedElement (Some (KeyField "mutable"%go)) (ElementExpression LogPosition ((![LogPosition] "start") +⟨go.uint64⟩ (Convert go.int LogPosition (let: "$a0" := (![go.SliceType Update] "log") in
      (FuncResolve go.len [go.SliceType Update] #()) "$a0")))); KeyedElement (Some (KeyField "addrPos"%go)) (ElementExpression (go.MapType common.Bnum LogPosition) (![go.MapType common.Bnum LogPosition] "addrPos"))])))).

(* go: 0sliding.go:29:19 *)
Definition sliding__endⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" <>,
    exception_do (let: "s" := (GoAlloc (go.PointerType sliding) "s") in
    return: ((![LogPosition] (StructFieldRef sliding "start"%go (![go.PointerType sliding] "s"))) +⟨go.uint64⟩ (Convert go.int LogPosition (let: "$a0" := (![go.SliceType Update] (StructFieldRef sliding "log"%go (![go.PointerType sliding] "s"))) in
     (FuncResolve go.len [go.SliceType Update] #()) "$a0")))).

(* go: 0sliding.go:33:19 *)
Definition sliding__getⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" "pos",
    exception_do (let: "s" := (GoAlloc (go.PointerType sliding) "s") in
    let: "pos" := (GoAlloc LogPosition "pos") in
    return: (![Update] (IndexRef (go.SliceType Update) (![go.SliceType Update] (StructFieldRef sliding "log"%go (![go.PointerType sliding] "s")), Convert LogPosition go.int ((![LogPosition] "pos") -⟨go.uint64⟩ (![LogPosition] (StructFieldRef sliding "start"%go (![go.PointerType sliding] "s")))))))).

(* go: 0sliding.go:37:19 *)
Definition sliding__posForAddrⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" "a",
    exception_do (let: "s" := (GoAlloc (go.PointerType sliding) "s") in
    let: "a" := (GoAlloc common.Bnum "a") in
    let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "pos" := (GoAlloc LogPosition (GoZeroVal LogPosition #())) in
    let: ("$ret0", "$ret1") := (map.lookup2 common.Bnum LogPosition (![go.MapType common.Bnum LogPosition] (StructFieldRef sliding "addrPos"%go (![go.PointerType sliding] "s"))) (![common.Bnum] "a")) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("pos" <-[LogPosition] "$r0");;;
    do:  ("ok" <-[go.bool] "$r1");;;
    return: (![LogPosition] "pos", ![go.bool] "ok")).

(* update does an in-place absorb of an update to u

   internal to sliding

   go: 0sliding.go:45:19 *)
Definition sliding__updateⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" "pos" "u",
    exception_do (let: "s" := (GoAlloc (go.PointerType sliding) "s") in
    let: "u" := (GoAlloc Update "u") in
    let: "pos" := (GoAlloc LogPosition "pos") in
    let: "$r0" := (![Update] "u") in
    do:  ((IndexRef (go.SliceType Update) (let: "$s" := (![go.SliceType Update] (StructFieldRef sliding "log"%go (![go.PointerType sliding] "s"))) in
     Slice (go.SliceType Update) ("$s", (![LogPosition] (StructFieldRef sliding "mutable"%go (![go.PointerType sliding] "s"))) -⟨go.uint64⟩ (![LogPosition] (StructFieldRef sliding "start"%go (![go.PointerType sliding] "s"))), FuncResolve go.len [go.SliceType Update] #() (![go.SliceType Update] (StructFieldRef sliding "log"%go (![go.PointerType sliding] "s")))), Convert LogPosition go.int ((![LogPosition] "pos") -⟨go.uint64⟩ (![LogPosition] (StructFieldRef sliding "mutable"%go (![go.PointerType sliding] "s")))))) <-[Update] "$r0");;;
    return: #()).

(* append writes an update that cannot be absorbed

   internal to sliding

   go: 0sliding.go:52:19 *)
Definition sliding__appendⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" "u",
    exception_do (let: "s" := (GoAlloc (go.PointerType sliding) "s") in
    let: "u" := (GoAlloc Update "u") in
    let: "pos" := (GoAlloc LogPosition (GoZeroVal LogPosition #())) in
    let: "$r0" := ((![LogPosition] (StructFieldRef sliding "start"%go (![go.PointerType sliding] "s"))) +⟨go.uint64⟩ (Convert go.int LogPosition (let: "$a0" := (![go.SliceType Update] (StructFieldRef sliding "log"%go (![go.PointerType sliding] "s"))) in
    (FuncResolve go.len [go.SliceType Update] #()) "$a0"))) in
    do:  ("pos" <-[LogPosition] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType Update] (StructFieldRef sliding "log"%go (![go.PointerType sliding] "s"))) in
    let: "$a1" := ((let: "$sl0" := (![Update] "u") in
    CompositeLiteral (go.SliceType Update) (LiteralValue [KeyedElement None (ElementExpression Update "$sl0")]))) in
    (FuncResolve go.append [go.SliceType Update] #()) "$a0" "$a1") in
    do:  ((StructFieldRef sliding "log"%go (![go.PointerType sliding] "s")) <-[go.SliceType Update] "$r0");;;
    let: "$r0" := (![LogPosition] "pos") in
    do:  (map.insert common.Bnum (![go.MapType common.Bnum LogPosition] (StructFieldRef sliding "addrPos"%go (![go.PointerType sliding] "s"))) (![common.Bnum] (StructFieldRef Update "Addr"%go "u")) "$r0");;;
    return: #()).

(* Absorbs writes in in-memory transactions (avoiding those that might be in
   the process of being logged or installed).

   Assumes caller holds memLock

   go: 0sliding.go:62:19 *)
Definition sliding__memWriteⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" "bufs",
    exception_do (let: "s" := (GoAlloc (go.PointerType sliding) "s") in
    let: "bufs" := (GoAlloc (go.SliceType Update) "bufs") in
    let: "pos" := (GoAlloc LogPosition (GoZeroVal LogPosition #())) in
    let: "$r0" := ((MethodResolve (go.PointerType sliding) "end"%go (![go.PointerType sliding] "s")) #()) in
    do:  ("pos" <-[LogPosition] "$r0");;;
    let: "$range" := (![go.SliceType Update] "bufs") in
    (let: "buf" := (GoAlloc Update (GoZeroVal Update #())) in
    slice.for_range Update "$range" (λ: "$key" "$value",
      do:  ("buf" <-[Update] "$value");;;
      do:  "$key";;;
      let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
      let: "oldpos" := (GoAlloc LogPosition (GoZeroVal LogPosition #())) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![common.Bnum] (StructFieldRef Update "Addr"%go "buf")) in
      (MethodResolve (go.PointerType sliding) "posForAddr"%go (![go.PointerType sliding] "s")) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("oldpos" <-[LogPosition] "$r0");;;
      do:  ("ok" <-[go.bool] "$r1");;;
      (if: (![go.bool] "ok") && ((![LogPosition] "oldpos") ≥⟨go.uint64⟩ (![LogPosition] (StructFieldRef sliding "mutable"%go (![go.PointerType sliding] "s"))))
      then
        do:  (let: "$a0" := #(W64 5) in
        let: "$a1" := #"memWrite: absorb %d pos %d old %d
        "%go in
        let: "$a2" := ((let: "$sl0" := (Convert common.Bnum (go.InterfaceType []) (![common.Bnum] (StructFieldRef Update "Addr"%go "buf"))) in
        let: "$sl1" := (Convert LogPosition (go.InterfaceType []) (![LogPosition] "pos")) in
        let: "$sl2" := (Convert LogPosition (go.InterfaceType []) (![LogPosition] "oldpos")) in
        CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl2")]))) in
        (FuncResolve util.DPrintf [] #()) "$a0" "$a1" "$a2");;;
        do:  (let: "$a0" := (![LogPosition] "oldpos") in
        let: "$a1" := (![Update] "buf") in
        (MethodResolve (go.PointerType sliding) "update"%go (![go.PointerType sliding] "s")) "$a0" "$a1")
      else
        (if: ![go.bool] "ok"
        then
          do:  (let: "$a0" := #(W64 5) in
          let: "$a1" := #"memLogMap: replace %d pos %d old %d
          "%go in
          let: "$a2" := ((let: "$sl0" := (Convert common.Bnum (go.InterfaceType []) (![common.Bnum] (StructFieldRef Update "Addr"%go "buf"))) in
          let: "$sl1" := (Convert LogPosition (go.InterfaceType []) (![LogPosition] "pos")) in
          let: "$sl2" := (Convert LogPosition (go.InterfaceType []) (![LogPosition] "oldpos")) in
          CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl2")]))) in
          (FuncResolve util.DPrintf [] #()) "$a0" "$a1" "$a2")
        else
          do:  (let: "$a0" := #(W64 5) in
          let: "$a1" := #"memLogMap: add %d pos %d
          "%go in
          let: "$a2" := ((let: "$sl0" := (Convert common.Bnum (go.InterfaceType []) (![common.Bnum] (StructFieldRef Update "Addr"%go "buf"))) in
          let: "$sl1" := (Convert LogPosition (go.InterfaceType []) (![LogPosition] "pos")) in
          CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1")]))) in
          (FuncResolve util.DPrintf [] #()) "$a0" "$a1" "$a2"));;;
        do:  (let: "$a0" := (![Update] "buf") in
        (MethodResolve (go.PointerType sliding) "append"%go (![go.PointerType sliding] "s")) "$a0");;;
        do:  ("pos" <-[LogPosition] ((![LogPosition] "pos") +⟨go.uint64⟩ #(W64 1))))));;;
    return: #()).

(* takeFrom takes the read-only updates from a logical start position to the
   current mutable boundary

   go: 0sliding.go:88:19 *)
Definition sliding__takeFromⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" "start",
    exception_do (let: "s" := (GoAlloc (go.PointerType sliding) "s") in
    let: "start" := (GoAlloc LogPosition "start") in
    return: (let: "$s" := (let: "$s" := (![go.SliceType Update] (StructFieldRef sliding "log"%go (![go.PointerType sliding] "s"))) in
     Slice (go.SliceType Update) ("$s", #(W64 0), (![LogPosition] (StructFieldRef sliding "mutable"%go (![go.PointerType sliding] "s"))) -⟨go.uint64⟩ (![LogPosition] (StructFieldRef sliding "start"%go (![go.PointerType sliding] "s"))))) in
     Slice (go.SliceType Update) ("$s", (![LogPosition] "start") -⟨go.uint64⟩ (![LogPosition] (StructFieldRef sliding "start"%go (![go.PointerType sliding] "s"))), FuncResolve go.len [go.SliceType Update] #() (let: "$s" := (![go.SliceType Update] (StructFieldRef sliding "log"%go (![go.PointerType sliding] "s"))) in
      Slice (go.SliceType Update) ("$s", #(W64 0), (![LogPosition] (StructFieldRef sliding "mutable"%go (![go.PointerType sliding] "s"))) -⟨go.uint64⟩ (![LogPosition] (StructFieldRef sliding "start"%go (![go.PointerType sliding] "s")))))))).

(* takeTill takes the read-only updates till a logical start position (which
   should be within the read-only region; that is, end <= s.mutable)

   go: 0sliding.go:94:19 *)
Definition sliding__takeTillⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" "end",
    exception_do (let: "s" := (GoAlloc (go.PointerType sliding) "s") in
    let: "end" := (GoAlloc LogPosition "end") in
    return: (let: "$s" := (let: "$s" := (![go.SliceType Update] (StructFieldRef sliding "log"%go (![go.PointerType sliding] "s"))) in
     Slice (go.SliceType Update) ("$s", #(W64 0), (![LogPosition] (StructFieldRef sliding "mutable"%go (![go.PointerType sliding] "s"))) -⟨go.uint64⟩ (![LogPosition] (StructFieldRef sliding "start"%go (![go.PointerType sliding] "s"))))) in
     Slice (go.SliceType Update) ("$s", #(W64 0), (![LogPosition] "end") -⟨go.uint64⟩ (![LogPosition] (StructFieldRef sliding "start"%go (![go.PointerType sliding] "s")))))).

(* go: 0sliding.go:98:19 *)
Definition sliding__intoMutableⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" <>,
    exception_do (let: "s" := (GoAlloc (go.PointerType sliding) "s") in
    return: (let: "$s" := (![go.SliceType Update] (StructFieldRef sliding "log"%go (![go.PointerType sliding] "s"))) in
     Slice (go.SliceType Update) ("$s", (![LogPosition] (StructFieldRef sliding "mutable"%go (![go.PointerType sliding] "s"))) -⟨go.uint64⟩ (![LogPosition] (StructFieldRef sliding "start"%go (![go.PointerType sliding] "s"))), FuncResolve go.len [go.SliceType Update] #() (![go.SliceType Update] (StructFieldRef sliding "log"%go (![go.PointerType sliding] "s")))))).

(* deleteFrom deletes read-only updates up to newStart,
   correctly updating the start position

   go: 0sliding.go:104:19 *)
Definition sliding__deleteFromⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" "newStart",
    exception_do (let: "s" := (GoAlloc (go.PointerType sliding) "s") in
    let: "newStart" := (GoAlloc LogPosition "newStart") in
    let: "start" := (GoAlloc LogPosition (GoZeroVal LogPosition #())) in
    let: "$r0" := (![LogPosition] (StructFieldRef sliding "start"%go (![go.PointerType sliding] "s"))) in
    do:  ("start" <-[LogPosition] "$r0");;;
    let: "$range" := (let: "$s" := (let: "$s" := (![go.SliceType Update] (StructFieldRef sliding "log"%go (![go.PointerType sliding] "s"))) in
    Slice (go.SliceType Update) ("$s", #(W64 0), (![LogPosition] (StructFieldRef sliding "mutable"%go (![go.PointerType sliding] "s"))) -⟨go.uint64⟩ (![LogPosition] "start"))) in
    Slice (go.SliceType Update) ("$s", #(W64 0), (![LogPosition] "newStart") -⟨go.uint64⟩ (![LogPosition] "start"))) in
    (let: "u" := (GoAlloc Update (GoZeroVal Update #())) in
    let: "i" := (GoAlloc go.int (GoZeroVal go.int #())) in
    slice.for_range Update "$range" (λ: "$key" "$value",
      do:  ("u" <-[Update] "$value");;;
      do:  ("i" <-[go.int] "$key");;;
      let: "pos" := (GoAlloc LogPosition (GoZeroVal LogPosition #())) in
      let: "$r0" := ((![LogPosition] "start") +⟨go.uint64⟩ (Convert go.int LogPosition (![go.int] "i"))) in
      do:  ("pos" <-[LogPosition] "$r0");;;
      let: "blkno" := (GoAlloc common.Bnum (GoZeroVal common.Bnum #())) in
      let: "$r0" := (![common.Bnum] (StructFieldRef Update "Addr"%go "u")) in
      do:  ("blkno" <-[common.Bnum] "$r0");;;
      let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
      let: "oldPos" := (GoAlloc LogPosition (GoZeroVal LogPosition #())) in
      let: ("$ret0", "$ret1") := (map.lookup2 common.Bnum LogPosition (![go.MapType common.Bnum LogPosition] (StructFieldRef sliding "addrPos"%go (![go.PointerType sliding] "s"))) (![common.Bnum] "blkno")) in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("oldPos" <-[LogPosition] "$r0");;;
      do:  ("ok" <-[go.bool] "$r1");;;
      (if: (![go.bool] "ok") && ((![LogPosition] "oldPos") ≤⟨go.uint64⟩ (![LogPosition] "pos"))
      then
        do:  (let: "$a0" := #(W64 5) in
        let: "$a1" := #"memLogMap: del %d %d
        "%go in
        let: "$a2" := ((let: "$sl0" := (Convert common.Bnum (go.InterfaceType []) (![common.Bnum] "blkno")) in
        let: "$sl1" := (Convert LogPosition (go.InterfaceType []) (![LogPosition] "oldPos")) in
        CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1")]))) in
        (FuncResolve util.DPrintf [] #()) "$a0" "$a1" "$a2");;;
        do:  (let: "$a0" := (![go.MapType common.Bnum LogPosition] (StructFieldRef sliding "addrPos"%go (![go.PointerType sliding] "s"))) in
        let: "$a1" := (![common.Bnum] "blkno") in
        (FuncResolve go.delete [go.MapType common.Bnum LogPosition] #()) "$a0" "$a1")
      else do:  #())));;;
    let: "$r0" := (let: "$s" := (![go.SliceType Update] (StructFieldRef sliding "log"%go (![go.PointerType sliding] "s"))) in
    Slice (go.SliceType Update) ("$s", (![LogPosition] "newStart") -⟨go.uint64⟩ (![LogPosition] "start"), FuncResolve go.len [go.SliceType Update] #() (![go.SliceType Update] (StructFieldRef sliding "log"%go (![go.PointerType sliding] "s"))))) in
    do:  ((StructFieldRef sliding "log"%go (![go.PointerType sliding] "s")) <-[go.SliceType Update] "$r0");;;
    let: "$r0" := (![LogPosition] "newStart") in
    do:  ((StructFieldRef sliding "start"%go (![go.PointerType sliding] "s")) <-[LogPosition] "$r0");;;
    return: #()).

(* go: 0sliding.go:119:19 *)
Definition sliding__clearMutableⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" <>,
    exception_do (let: "s" := (GoAlloc (go.PointerType sliding) "s") in
    let: "$r0" := ((MethodResolve (go.PointerType sliding) "end"%go (![go.PointerType sliding] "s")) #()) in
    do:  ((StructFieldRef sliding "mutable"%go (![go.PointerType sliding] "s")) <-[LogPosition] "$r0");;;
    return: #()).

(* go: 0waldefs.go:20:23 *)
Definition WalogState__memEndⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "st" <>,
    exception_do (let: "st" := (GoAlloc (go.PointerType WalogState) "st") in
    return: ((MethodResolve (go.PointerType sliding) "end"%go (![go.PointerType sliding] (StructFieldRef WalogState "memLog"%go (![go.PointerType WalogState] "st")))) #())).

(* go: 0waldefs.go:37:17 *)
Definition Walog__LogSzⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" <>,
    exception_do (let: "l" := (GoAlloc (go.PointerType Walog) "l") in
    return: (common.HDRADDRS)).

(* cutMemLog deletes from the memLog through installEnd, after these blocks have
   been installed. This transitions from a state where the on-disk install point
   is already at installEnd, but memStart < installEnd.

   Assumes caller holds memLock

   go: installer.go:14:23 *)
Definition WalogState__cutMemLogⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "st" "installEnd",
    exception_do (let: "st" := (GoAlloc (go.PointerType WalogState) "st") in
    let: "installEnd" := (GoAlloc LogPosition "installEnd") in
    do:  (let: "$a0" := (![LogPosition] "installEnd") in
    (MethodResolve (go.PointerType sliding) "deleteFrom"%go (![go.PointerType sliding] (StructFieldRef WalogState "memLog"%go (![go.PointerType WalogState] "st")))) "$a0");;;
    return: #()).

(* absorbBufs returns bufs' such that applyUpds(d, bufs') = applyUpds(d,
   bufs) and bufs' has unique addresses

   go: installer.go:20:6 *)
Definition absorbBufsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "bufs",
    exception_do (let: "bufs" := (GoAlloc (go.SliceType Update) "bufs") in
    let: "s" := (GoAlloc (go.PointerType sliding) (GoZeroVal (go.PointerType sliding) #())) in
    let: "$r0" := (let: "$a0" := (Convert go.untyped_nil (go.SliceType Update) UntypedNil) in
    let: "$a1" := #(W64 0) in
    (FuncResolve mkSliding [] #()) "$a0" "$a1") in
    do:  ("s" <-[go.PointerType sliding] "$r0");;;
    do:  (let: "$a0" := (![go.SliceType Update] "bufs") in
    (MethodResolve (go.PointerType sliding) "memWrite"%go (![go.PointerType sliding] "s")) "$a0");;;
    return: ((MethodResolve (go.PointerType sliding) "intoMutable"%go (![go.PointerType sliding] "s")) #())).

(* installBlocks installs the updates in bufs to the data region

   Does not hold the memLock. De-duplicates writes in bufs such that:
   (1) after installBlocks,
   the equivalent of applying bufs in order is accomplished
   (2) at all intermediate points,
   the data region either has the value from the old transaction or the new
   transaction (with all of bufs applied).

   go: installer.go:34:6 *)
Definition installBlocksⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "d" "bufs",
    exception_do (let: "bufs" := (GoAlloc (go.SliceType Update) "bufs") in
    let: "d" := (GoAlloc disk.Disk "d") in
    let: "$range" := (![go.SliceType Update] "bufs") in
    (let: "buf" := (GoAlloc Update (GoZeroVal Update #())) in
    let: "i" := (GoAlloc go.int (GoZeroVal go.int #())) in
    slice.for_range Update "$range" (λ: "$key" "$value",
      do:  ("buf" <-[Update] "$value");;;
      do:  ("i" <-[go.int] "$key");;;
      let: "blkno" := (GoAlloc common.Bnum (GoZeroVal common.Bnum #())) in
      let: "$r0" := (![common.Bnum] (StructFieldRef Update "Addr"%go "buf")) in
      do:  ("blkno" <-[common.Bnum] "$r0");;;
      let: "blk" := (GoAlloc disk.Block (GoZeroVal disk.Block #())) in
      let: "$r0" := (![disk.Block] (StructFieldRef Update "Block"%go "buf")) in
      do:  ("blk" <-[disk.Block] "$r0");;;
      do:  (let: "$a0" := #(W64 5) in
      let: "$a1" := #"installBlocks: write log block %d to %d
      "%go in
      let: "$a2" := ((let: "$sl0" := (Convert go.int (go.InterfaceType []) (![go.int] "i")) in
      let: "$sl1" := (Convert common.Bnum (go.InterfaceType []) (![common.Bnum] "blkno")) in
      CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1")]))) in
      (FuncResolve util.DPrintf [] #()) "$a0" "$a1" "$a2");;;
      do:  (let: "$a0" := (![common.Bnum] "blkno") in
      let: "$a1" := (![disk.Block] "blk") in
      (MethodResolve disk.Disk "Write"%go (![disk.Disk] "d")) "$a0" "$a1")));;;
    return: #()).

(* logInstall installs one on-disk transaction from the disk log to the data
   region.

   Returns (blkCount, installEnd)

   blkCount is the number of blocks installed (only used for liveness)

   installEnd is the new last position installed to the data region (only used
   for debugging)

   Installer holds memLock

   go: installer.go:54:17 *)
Definition Walog__logInstallⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" <>,
    exception_do (let: "l" := (GoAlloc (go.PointerType Walog) "l") in
    let: "installEnd" := (GoAlloc LogPosition (GoZeroVal LogPosition #())) in
    let: "$r0" := (![LogPosition] (StructFieldRef WalogState "diskEnd"%go (![go.PointerType WalogState] (StructFieldRef Walog "st"%go (![go.PointerType Walog] "l"))))) in
    do:  ("installEnd" <-[LogPosition] "$r0");;;
    let: "bufs" := (GoAlloc (go.SliceType Update) (GoZeroVal (go.SliceType Update) #())) in
    let: "$r0" := (let: "$a0" := (![LogPosition] "installEnd") in
    (MethodResolve (go.PointerType sliding) "takeTill"%go (![go.PointerType sliding] (StructFieldRef WalogState "memLog"%go (![go.PointerType WalogState] (StructFieldRef Walog "st"%go (![go.PointerType Walog] "l")))))) "$a0") in
    do:  ("bufs" <-[go.SliceType Update] "$r0");;;
    let: "numBufs" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (Convert go.int go.uint64 (let: "$a0" := (![go.SliceType Update] "bufs") in
    (FuncResolve go.len [go.SliceType Update] #()) "$a0")) in
    do:  ("numBufs" <-[go.uint64] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "numBufs") =⟨go.uint64⟩ #(W64 0))
    then return: (#(W64 0), ![LogPosition] "installEnd")
    else do:  #());;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef Walog "memLock"%go (![go.PointerType Walog] "l")))) #());;;
    do:  (let: "$a0" := #(W64 5) in
    let: "$a1" := #"logInstall up to %d
    "%go in
    let: "$a2" := ((let: "$sl0" := (Convert LogPosition (go.InterfaceType []) (![LogPosition] "installEnd")) in
    CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0")]))) in
    (FuncResolve util.DPrintf [] #()) "$a0" "$a1" "$a2");;;
    do:  (let: "$a0" := (![disk.Disk] (StructFieldRef Walog "d"%go (![go.PointerType Walog] "l"))) in
    let: "$a1" := (![go.SliceType Update] "bufs") in
    (FuncResolve installBlocks [] #()) "$a0" "$a1");;;
    do:  ((MethodResolve disk.Disk "Barrier"%go (![disk.Disk] (StructFieldRef Walog "d"%go (![go.PointerType Walog] "l")))) #());;;
    do:  (let: "$a0" := (![disk.Disk] (StructFieldRef Walog "d"%go (![go.PointerType Walog] "l"))) in
    let: "$a1" := (![LogPosition] "installEnd") in
    (FuncResolve Advance [] #()) "$a0" "$a1");;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] (StructFieldRef Walog "memLock"%go (![go.PointerType Walog] "l")))) #());;;
    do:  (let: "$a0" := (![LogPosition] "installEnd") in
    (MethodResolve (go.PointerType WalogState) "cutMemLog"%go (![go.PointerType WalogState] (StructFieldRef Walog "st"%go (![go.PointerType Walog] "l")))) "$a0");;;
    do:  ((MethodResolve (go.PointerType sync.Cond) "Broadcast"%go (![go.PointerType sync.Cond] (StructFieldRef Walog "condInstall"%go (![go.PointerType Walog] "l")))) #());;;
    return: (![go.uint64] "numBufs", ![LogPosition] "installEnd")).

(* installer installs blocks from the on-disk log to their home location.

   go: installer.go:77:17 *)
Definition Walog__installerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" <>,
    exception_do (let: "l" := (GoAlloc (go.PointerType Walog) "l") in
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] (StructFieldRef Walog "memLock"%go (![go.PointerType Walog] "l")))) #());;;
    do:  ((StructFieldRef WalogState "nthread"%go (![go.PointerType WalogState] (StructFieldRef Walog "st"%go (![go.PointerType Walog] "l")))) <-[go.uint64] ((![go.uint64] (StructFieldRef WalogState "nthread"%go (![go.PointerType WalogState] (StructFieldRef Walog "st"%go (![go.PointerType Walog] "l"))))) +⟨go.uint64⟩ #(W64 1)));;;
    (for: (λ: <>, (⟨go.bool⟩! (![go.bool] (StructFieldRef WalogState "shutdown"%go (![go.PointerType WalogState] (StructFieldRef Walog "st"%go (![go.PointerType Walog] "l"))))))); (λ: <>, #()) := λ: <>,
      let: "txn" := (GoAlloc LogPosition (GoZeroVal LogPosition #())) in
      let: "blkcount" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: ("$ret0", "$ret1") := ((MethodResolve (go.PointerType Walog) "logInstall"%go (![go.PointerType Walog] "l")) #()) in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("blkcount" <-[go.uint64] "$r0");;;
      do:  ("txn" <-[LogPosition] "$r1");;;
      (if: Convert go.untyped_bool go.bool ((![go.uint64] "blkcount") >⟨go.uint64⟩ #(W64 0))
      then
        do:  (let: "$a0" := #(W64 5) in
        let: "$a1" := #"Installed till txn %d
        "%go in
        let: "$a2" := ((let: "$sl0" := (Convert LogPosition (go.InterfaceType []) (![LogPosition] "txn")) in
        CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0")]))) in
        (FuncResolve util.DPrintf [] #()) "$a0" "$a1" "$a2")
      else do:  ((MethodResolve (go.PointerType sync.Cond) "Wait"%go (![go.PointerType sync.Cond] (StructFieldRef Walog "condInstall"%go (![go.PointerType Walog] "l")))) #())));;;
    do:  (let: "$a0" := #(W64 1) in
    let: "$a1" := #"installer: shutdown
    "%go in
    let: "$a2" := #slice.nil in
    (FuncResolve util.DPrintf [] #()) "$a0" "$a1" "$a2");;;
    do:  ((StructFieldRef WalogState "nthread"%go (![go.PointerType WalogState] (StructFieldRef Walog "st"%go (![go.PointerType Walog] "l")))) <-[go.uint64] ((![go.uint64] (StructFieldRef WalogState "nthread"%go (![go.PointerType WalogState] (StructFieldRef Walog "st"%go (![go.PointerType Walog] "l"))))) -⟨go.uint64⟩ #(W64 1)));;;
    do:  ((MethodResolve (go.PointerType sync.Cond) "Signal"%go (![go.PointerType sync.Cond] (StructFieldRef Walog "condShut"%go (![go.PointerType Walog] "l")))) #());;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef Walog "memLock"%go (![go.PointerType Walog] "l")))) #());;;
    return: #()).

(* Waits on the installer thread to free space in the log so everything
   logged fits on disk.

   establishes uint64(len(l.memLog)) <= LOGSZ

   go: logger.go:12:17 *)
Definition Walog__waitForSpaceⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" <>,
    exception_do (let: "l" := (GoAlloc (go.PointerType Walog) "l") in
    (for: (λ: <>, (Convert go.int go.uint64 (let: "$a0" := (![go.SliceType Update] (StructFieldRef sliding "log"%go (![go.PointerType sliding] (StructFieldRef WalogState "memLog"%go (![go.PointerType WalogState] (StructFieldRef Walog "st"%go (![go.PointerType Walog] "l"))))))) in
    (FuncResolve go.len [go.SliceType Update] #()) "$a0")) >⟨go.uint64⟩ LOGSZ); (λ: <>, #()) := λ: <>,
      do:  ((MethodResolve (go.PointerType sync.Cond) "Wait"%go (![go.PointerType sync.Cond] (StructFieldRef Walog "condInstall"%go (![go.PointerType Walog] "l")))) #()));;;
    return: #()).

(* go: logger.go:20:17 *)
Definition Walog__flushIfNeededⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" <>,
    exception_do (let: "l" := (GoAlloc (go.PointerType Walog) "l") in
    (if: ![go.bool] (StructFieldRef sliding "needFlush"%go (![go.PointerType sliding] (StructFieldRef WalogState "memLog"%go (![go.PointerType WalogState] (StructFieldRef Walog "st"%go (![go.PointerType Walog] "l"))))))
    then
      do:  ((MethodResolve (go.PointerType sliding) "clearMutable"%go (![go.PointerType sliding] (StructFieldRef WalogState "memLog"%go (![go.PointerType WalogState] (StructFieldRef Walog "st"%go (![go.PointerType Walog] "l")))))) #());;;
      let: "$r0" := #false in
      do:  ((StructFieldRef sliding "needFlush"%go (![go.PointerType sliding] (StructFieldRef WalogState "memLog"%go (![go.PointerType WalogState] (StructFieldRef Walog "st"%go (![go.PointerType Walog] "l")))))) <-[go.bool] "$r0")
    else do:  #());;;
    return: #()).

(* logAppend appends to the log, if it can find transactions to append.

   It grabs the new writes in memory and not on disk through l.nextDiskEnd; if
   there are any such writes, it commits them atomically.

   assumes caller holds memLock

   Returns true if it made progress (for liveness, not important for
   correctness).

   go: logger.go:36:17 *)
Definition Walog__logAppendⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" "circ",
    exception_do (let: "l" := (GoAlloc (go.PointerType Walog) "l") in
    let: "circ" := (GoAlloc (go.PointerType circularAppender) "circ") in
    do:  ((MethodResolve (go.PointerType Walog) "waitForSpace"%go (![go.PointerType Walog] "l")) #());;;
    do:  ((MethodResolve (go.PointerType Walog) "flushIfNeeded"%go (![go.PointerType Walog] "l")) #());;;
    let: "diskEnd" := (GoAlloc LogPosition (GoZeroVal LogPosition #())) in
    let: "$r0" := (![LogPosition] (StructFieldRef WalogState "diskEnd"%go (![go.PointerType WalogState] (StructFieldRef Walog "st"%go (![go.PointerType Walog] "l"))))) in
    do:  ("diskEnd" <-[LogPosition] "$r0");;;
    let: "newbufs" := (GoAlloc (go.SliceType Update) (GoZeroVal (go.SliceType Update) #())) in
    let: "$r0" := (let: "$a0" := (![LogPosition] "diskEnd") in
    (MethodResolve (go.PointerType sliding) "takeFrom"%go (![go.PointerType sliding] (StructFieldRef WalogState "memLog"%go (![go.PointerType WalogState] (StructFieldRef Walog "st"%go (![go.PointerType Walog] "l")))))) "$a0") in
    do:  ("newbufs" <-[go.SliceType Update] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((let: "$a0" := (![go.SliceType Update] "newbufs") in
    (FuncResolve go.len [go.SliceType Update] #()) "$a0") =⟨go.int⟩ #(W64 0))
    then return: (#false)
    else do:  #());;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef Walog "memLock"%go (![go.PointerType Walog] "l")))) #());;;
    do:  (let: "$a0" := (![disk.Disk] (StructFieldRef Walog "d"%go (![go.PointerType Walog] "l"))) in
    let: "$a1" := (![LogPosition] "diskEnd") in
    let: "$a2" := (![go.SliceType Update] "newbufs") in
    (MethodResolve (go.PointerType circularAppender) "Append"%go (![go.PointerType circularAppender] "circ")) "$a0" "$a1" "$a2");;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] (StructFieldRef Walog "memLock"%go (![go.PointerType Walog] "l")))) #());;;
    do:  ((FuncResolve primitive.Linearize [] #()) #());;;
    let: "$r0" := ((![LogPosition] "diskEnd") +⟨go.uint64⟩ (Convert go.int LogPosition (let: "$a0" := (![go.SliceType Update] "newbufs") in
    (FuncResolve go.len [go.SliceType Update] #()) "$a0"))) in
    do:  ((StructFieldRef WalogState "diskEnd"%go (![go.PointerType WalogState] (StructFieldRef Walog "st"%go (![go.PointerType Walog] "l")))) <-[LogPosition] "$r0");;;
    do:  ((MethodResolve (go.PointerType sync.Cond) "Broadcast"%go (![go.PointerType sync.Cond] (StructFieldRef Walog "condLogger"%go (![go.PointerType Walog] "l")))) #());;;
    do:  ((MethodResolve (go.PointerType sync.Cond) "Broadcast"%go (![go.PointerType sync.Cond] (StructFieldRef Walog "condInstall"%go (![go.PointerType Walog] "l")))) #());;;
    return: (#true)).

(* logger writes blocks from the in-memory log to the on-disk log

   Operates by continuously polling for in-memory transactions, driven by
   condLogger for scheduling

   go: logger.go:64:17 *)
Definition Walog__loggerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" "circ",
    exception_do (let: "l" := (GoAlloc (go.PointerType Walog) "l") in
    let: "circ" := (GoAlloc (go.PointerType circularAppender) "circ") in
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] (StructFieldRef Walog "memLock"%go (![go.PointerType Walog] "l")))) #());;;
    do:  ((StructFieldRef WalogState "nthread"%go (![go.PointerType WalogState] (StructFieldRef Walog "st"%go (![go.PointerType Walog] "l")))) <-[go.uint64] ((![go.uint64] (StructFieldRef WalogState "nthread"%go (![go.PointerType WalogState] (StructFieldRef Walog "st"%go (![go.PointerType Walog] "l"))))) +⟨go.uint64⟩ #(W64 1)));;;
    (for: (λ: <>, (⟨go.bool⟩! (![go.bool] (StructFieldRef WalogState "shutdown"%go (![go.PointerType WalogState] (StructFieldRef Walog "st"%go (![go.PointerType Walog] "l"))))))); (λ: <>, #()) := λ: <>,
      let: "progress" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
      let: "$r0" := (let: "$a0" := (![go.PointerType circularAppender] "circ") in
      (MethodResolve (go.PointerType Walog) "logAppend"%go (![go.PointerType Walog] "l")) "$a0") in
      do:  ("progress" <-[go.bool] "$r0");;;
      (if: (⟨go.bool⟩! (![go.bool] "progress"))
      then do:  ((MethodResolve (go.PointerType sync.Cond) "Wait"%go (![go.PointerType sync.Cond] (StructFieldRef Walog "condLogger"%go (![go.PointerType Walog] "l")))) #())
      else do:  #()));;;
    do:  (let: "$a0" := #(W64 1) in
    let: "$a1" := #"logger: shutdown
    "%go in
    let: "$a2" := #slice.nil in
    (FuncResolve util.DPrintf [] #()) "$a0" "$a1" "$a2");;;
    do:  ((StructFieldRef WalogState "nthread"%go (![go.PointerType WalogState] (StructFieldRef Walog "st"%go (![go.PointerType Walog] "l")))) <-[go.uint64] ((![go.uint64] (StructFieldRef WalogState "nthread"%go (![go.PointerType WalogState] (StructFieldRef Walog "st"%go (![go.PointerType Walog] "l"))))) -⟨go.uint64⟩ #(W64 1)));;;
    do:  ((MethodResolve (go.PointerType sync.Cond) "Signal"%go (![go.PointerType sync.Cond] (StructFieldRef Walog "condShut"%go (![go.PointerType Walog] "l")))) #());;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef Walog "memLock"%go (![go.PointerType Walog] "l")))) #());;;
    return: #()).

(* go: wal.go:14:6 *)
Definition mkLogⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "disk",
    exception_do (let: "disk" := (GoAlloc disk.Disk "disk") in
    let: "memLog" := (GoAlloc (go.SliceType Update) (GoZeroVal (go.SliceType Update) #())) in
    let: "end" := (GoAlloc LogPosition (GoZeroVal LogPosition #())) in
    let: "start" := (GoAlloc LogPosition (GoZeroVal LogPosition #())) in
    let: "circ" := (GoAlloc (go.PointerType circularAppender) (GoZeroVal (go.PointerType circularAppender) #())) in
    let: ((("$ret0", "$ret1"), "$ret2"), "$ret3") := (let: "$a0" := (![disk.Disk] "disk") in
    (FuncResolve recoverCircular [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    let: "$r3" := "$ret3" in
    do:  ("circ" <-[go.PointerType circularAppender] "$r0");;;
    do:  ("start" <-[LogPosition] "$r1");;;
    do:  ("end" <-[LogPosition] "$r2");;;
    do:  ("memLog" <-[go.SliceType Update] "$r3");;;
    let: "ml" := (GoAlloc (go.PointerType sync.Mutex) (GoZeroVal (go.PointerType sync.Mutex) #())) in
    let: "$r0" := (GoAlloc sync.Mutex (GoZeroVal sync.Mutex #())) in
    do:  ("ml" <-[go.PointerType sync.Mutex] "$r0");;;
    let: "st" := (GoAlloc (go.PointerType WalogState) (GoZeroVal (go.PointerType WalogState) #())) in
    let: "$r0" := (GoAlloc WalogState (CompositeLiteral WalogState (LiteralValue [KeyedElement (Some (KeyField "memLog"%go)) (ElementExpression (go.PointerType sliding) (let: "$a0" := (![go.SliceType Update] "memLog") in
     let: "$a1" := (![LogPosition] "start") in
     (FuncResolve mkSliding [] #()) "$a0" "$a1")); KeyedElement (Some (KeyField "diskEnd"%go)) (ElementExpression LogPosition (![LogPosition] "end")); KeyedElement (Some (KeyField "shutdown"%go)) (ElementExpression go.bool #false); KeyedElement (Some (KeyField "nthread"%go)) (ElementExpression go.uint64 #(W64 0))]))) in
    do:  ("st" <-[go.PointerType WalogState] "$r0");;;
    let: "l" := (GoAlloc (go.PointerType Walog) (GoZeroVal (go.PointerType Walog) #())) in
    let: "$r0" := (GoAlloc Walog (CompositeLiteral Walog (LiteralValue [KeyedElement (Some (KeyField "d"%go)) (ElementExpression disk.Disk (![disk.Disk] "disk")); KeyedElement (Some (KeyField "circ"%go)) (ElementExpression (go.PointerType circularAppender) (![go.PointerType circularAppender] "circ")); KeyedElement (Some (KeyField "memLock"%go)) (ElementExpression (go.PointerType sync.Mutex) (![go.PointerType sync.Mutex] "ml")); KeyedElement (Some (KeyField "st"%go)) (ElementExpression (go.PointerType WalogState) (![go.PointerType WalogState] "st")); KeyedElement (Some (KeyField "condLogger"%go)) (ElementExpression (go.PointerType sync.Cond) (let: "$a0" := (Convert (go.PointerType sync.Mutex) sync.Locker (![go.PointerType sync.Mutex] "ml")) in
     (FuncResolve sync.NewCond [] #()) "$a0")); KeyedElement (Some (KeyField "condInstall"%go)) (ElementExpression (go.PointerType sync.Cond) (let: "$a0" := (Convert (go.PointerType sync.Mutex) sync.Locker (![go.PointerType sync.Mutex] "ml")) in
     (FuncResolve sync.NewCond [] #()) "$a0")); KeyedElement (Some (KeyField "condShut"%go)) (ElementExpression (go.PointerType sync.Cond) (let: "$a0" := (Convert (go.PointerType sync.Mutex) sync.Locker (![go.PointerType sync.Mutex] "ml")) in
     (FuncResolve sync.NewCond [] #()) "$a0"))]))) in
    do:  ("l" <-[go.PointerType Walog] "$r0");;;
    do:  (let: "$a0" := #(W64 1) in
    let: "$a1" := #"mkLog: size %d
    "%go in
    let: "$a2" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) LOGSZ) in
    CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0")]))) in
    (FuncResolve util.DPrintf [] #()) "$a0" "$a1" "$a2");;;
    return: (![go.PointerType Walog] "l")).

(* go: wal.go:36:17 *)
Definition Walog__startBackgroundThreadsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" <>,
    exception_do (let: "l" := (GoAlloc (go.PointerType Walog) "l") in
    let: "$go" := (λ: <>,
      exception_do (do:  (let: "$a0" := (![go.PointerType circularAppender] (StructFieldRef Walog "circ"%go (![go.PointerType Walog] "l"))) in
      (MethodResolve (go.PointerType Walog) "logger"%go (![go.PointerType Walog] "l")) "$a0");;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    let: "$go" := (λ: <>,
      exception_do (do:  ((MethodResolve (go.PointerType Walog) "installer"%go (![go.PointerType Walog] "l")) #());;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    return: #()).

(* go: wal.go:41:6 *)
Definition MkLogⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "disk",
    exception_do (let: "disk" := (GoAlloc disk.Disk "disk") in
    let: "l" := (GoAlloc (go.PointerType Walog) (GoZeroVal (go.PointerType Walog) #())) in
    let: "$r0" := (let: "$a0" := (![disk.Disk] "disk") in
    (FuncResolve mkLog [] #()) "$a0") in
    do:  ("l" <-[go.PointerType Walog] "$r0");;;
    do:  ((MethodResolve (go.PointerType Walog) "startBackgroundThreads"%go (![go.PointerType Walog] "l")) #());;;
    return: (![go.PointerType Walog] "l")).

(* Assumes caller holds memLock

   go: wal.go:48:6 *)
Definition doMemAppendⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "memLog" "bufs",
    exception_do (let: "bufs" := (GoAlloc (go.SliceType Update) "bufs") in
    let: "memLog" := (GoAlloc (go.PointerType sliding) "memLog") in
    do:  (let: "$a0" := (![go.SliceType Update] "bufs") in
    (MethodResolve (go.PointerType sliding) "memWrite"%go (![go.PointerType sliding] "memLog")) "$a0");;;
    let: "txn" := (GoAlloc LogPosition (GoZeroVal LogPosition #())) in
    let: "$r0" := ((MethodResolve (go.PointerType sliding) "end"%go (![go.PointerType sliding] "memLog")) #()) in
    do:  ("txn" <-[LogPosition] "$r0");;;
    return: (![LogPosition] "txn")).

(* Grab all of the current transactions and record them for the next group commit (when the logger gets around to it).

   This is a separate function purely for verification purposes; the code isn't complicated but we have to manipulate
   some ghost state and justify this value of nextDiskEnd.

   Assumes caller holds memLock.

   go: wal.go:60:23 *)
Definition WalogState__endGroupTxnⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "st" <>,
    exception_do (let: "st" := (GoAlloc (go.PointerType WalogState) "st") in
    let: "$r0" := #true in
    do:  ((StructFieldRef sliding "needFlush"%go (![go.PointerType sliding] (StructFieldRef WalogState "memLog"%go (![go.PointerType WalogState] "st")))) <-[go.bool] "$r0");;;
    return: #()).

(* go: wal.go:68:6 *)
Definition copyUpdateBlockⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "u",
    exception_do (let: "u" := (GoAlloc Update "u") in
    return: (let: "$a0" := (![disk.Block] (StructFieldRef Update "Block"%go "u")) in
     (FuncResolve util.CloneByteSlice [] #()) "$a0")).

(* readMem implements ReadMem, assuming memLock is held

   go: wal.go:73:23 *)
Definition WalogState__readMemⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "st" "blkno",
    exception_do (let: "st" := (GoAlloc (go.PointerType WalogState) "st") in
    let: "blkno" := (GoAlloc common.Bnum "blkno") in
    let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "pos" := (GoAlloc LogPosition (GoZeroVal LogPosition #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![common.Bnum] "blkno") in
    (MethodResolve (go.PointerType sliding) "posForAddr"%go (![go.PointerType sliding] (StructFieldRef WalogState "memLog"%go (![go.PointerType WalogState] "st")))) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("pos" <-[LogPosition] "$r0");;;
    do:  ("ok" <-[go.bool] "$r1");;;
    (if: ![go.bool] "ok"
    then
      do:  (let: "$a0" := #(W64 5) in
      let: "$a1" := #"read memLogMap: read %d pos %d
      "%go in
      let: "$a2" := ((let: "$sl0" := (Convert common.Bnum (go.InterfaceType []) (![common.Bnum] "blkno")) in
      let: "$sl1" := (Convert LogPosition (go.InterfaceType []) (![LogPosition] "pos")) in
      CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1")]))) in
      (FuncResolve util.DPrintf [] #()) "$a0" "$a1" "$a2");;;
      let: "u" := (GoAlloc Update (GoZeroVal Update #())) in
      let: "$r0" := (let: "$a0" := (![LogPosition] "pos") in
      (MethodResolve (go.PointerType sliding) "get"%go (![go.PointerType sliding] (StructFieldRef WalogState "memLog"%go (![go.PointerType WalogState] "st")))) "$a0") in
      do:  ("u" <-[Update] "$r0");;;
      let: "blk" := (GoAlloc disk.Block (GoZeroVal disk.Block #())) in
      let: "$r0" := (let: "$a0" := (![Update] "u") in
      (FuncResolve copyUpdateBlock [] #()) "$a0") in
      do:  ("blk" <-[disk.Block] "$r0");;;
      return: (![disk.Block] "blk", #true)
    else do:  #());;;
    return: (Convert go.untyped_nil disk.Block UntypedNil, #false)).

(* Read from only the in-memory cached state (the unstable and logged parts of
   the wal).

   go: wal.go:86:17 *)
Definition Walog__ReadMemⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" "blkno",
    exception_do (let: "l" := (GoAlloc (go.PointerType Walog) "l") in
    let: "blkno" := (GoAlloc common.Bnum "blkno") in
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] (StructFieldRef Walog "memLock"%go (![go.PointerType Walog] "l")))) #());;;
    let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "blk" := (GoAlloc disk.Block (GoZeroVal disk.Block #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![common.Bnum] "blkno") in
    (MethodResolve (go.PointerType WalogState) "readMem"%go (![go.PointerType WalogState] (StructFieldRef Walog "st"%go (![go.PointerType Walog] "l")))) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("blk" <-[disk.Block] "$r0");;;
    do:  ("ok" <-[go.bool] "$r1");;;
    do:  ((FuncResolve primitive.Linearize [] #()) #());;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef Walog "memLock"%go (![go.PointerType Walog] "l")))) #());;;
    return: (![disk.Block] "blk", ![go.bool] "ok")).

(* Read from only the installed state (a subset of durable state).

   go: wal.go:95:17 *)
Definition Walog__ReadInstalledⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" "blkno",
    exception_do (let: "l" := (GoAlloc (go.PointerType Walog) "l") in
    let: "blkno" := (GoAlloc common.Bnum "blkno") in
    return: (let: "$a0" := (![common.Bnum] "blkno") in
     (MethodResolve disk.Disk "Read"%go (![disk.Disk] (StructFieldRef Walog "d"%go (![go.PointerType Walog] "l")))) "$a0")).

(* Read reads from the latest memory state, but does so in a
   difficult-to-linearize way (specifically, it is future-dependent when to
   linearize between the l.memLog.Unlock() and the eventual disk read, due to
   potential concurrent cache or disk writes).

   go: wal.go:103:17 *)
Definition Walog__Readⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" "blkno",
    exception_do (let: "l" := (GoAlloc (go.PointerType Walog) "l") in
    let: "blkno" := (GoAlloc common.Bnum "blkno") in
    let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "blk" := (GoAlloc disk.Block (GoZeroVal disk.Block #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![common.Bnum] "blkno") in
    (MethodResolve (go.PointerType Walog) "ReadMem"%go (![go.PointerType Walog] "l")) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("blk" <-[disk.Block] "$r0");;;
    do:  ("ok" <-[go.bool] "$r1");;;
    (if: ![go.bool] "ok"
    then return: (![disk.Block] "blk")
    else do:  #());;;
    return: (let: "$a0" := (![common.Bnum] "blkno") in
     (MethodResolve (go.PointerType Walog) "ReadInstalled"%go (![go.PointerType Walog] "l")) "$a0")).

(* go: wal.go:111:23 *)
Definition WalogState__updatesOverflowU64ⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "st" "newUpdates",
    exception_do (let: "st" := (GoAlloc (go.PointerType WalogState) "st") in
    let: "newUpdates" := (GoAlloc go.uint64 "newUpdates") in
    return: (let: "$a0" := ((MethodResolve (go.PointerType WalogState) "memEnd"%go (![go.PointerType WalogState] "st")) #()) in
     let: "$a1" := (![go.uint64] "newUpdates") in
     (FuncResolve util.SumOverflows [] #()) "$a0" "$a1")).

(* TODO: relate this calculation to the circular log free space

   go: wal.go:116:23 *)
Definition WalogState__memLogHasSpaceⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "st" "newUpdates",
    exception_do (let: "st" := (GoAlloc (go.PointerType WalogState) "st") in
    let: "newUpdates" := (GoAlloc go.uint64 "newUpdates") in
    let: "memSize" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (((MethodResolve (go.PointerType WalogState) "memEnd"%go (![go.PointerType WalogState] "st")) #()) -⟨go.uint64⟩ (![LogPosition] (StructFieldRef WalogState "diskEnd"%go (![go.PointerType WalogState] "st")))) in
    do:  ("memSize" <-[go.uint64] "$r0");;;
    (if: Convert go.untyped_bool go.bool (((![go.uint64] "memSize") +⟨go.uint64⟩ (![go.uint64] "newUpdates")) >⟨go.uint64⟩ LOGSZ)
    then return: (#false)
    else do:  #());;;
    return: (#true)).

(* Append to in-memory log.

   On success returns the pos for this append.

   On failure guaranteed to be idempotent (failure can only occur in principle,
   due overflowing 2^64 writes)

   go: wal.go:130:17 *)
Definition Walog__MemAppendⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" "bufs",
    exception_do (let: "l" := (GoAlloc (go.PointerType Walog) "l") in
    let: "bufs" := (GoAlloc (go.SliceType Update) "bufs") in
    (if: Convert go.untyped_bool go.bool ((Convert go.int go.uint64 (let: "$a0" := (![go.SliceType Update] "bufs") in
    (FuncResolve go.len [go.SliceType Update] #()) "$a0")) >⟨go.uint64⟩ LOGSZ)
    then return: (#(W64 0), #false)
    else do:  #());;;
    let: "txn" := (GoAlloc LogPosition (GoZeroVal LogPosition #())) in
    let: "$r0" := #(W64 0) in
    do:  ("txn" <-[LogPosition] "$r0");;;
    let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #true in
    do:  ("ok" <-[go.bool] "$r0");;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] (StructFieldRef Walog "memLock"%go (![go.PointerType Walog] "l")))) #());;;
    let: "st" := (GoAlloc (go.PointerType WalogState) (GoZeroVal (go.PointerType WalogState) #())) in
    let: "$r0" := (![go.PointerType WalogState] (StructFieldRef Walog "st"%go (![go.PointerType Walog] "l"))) in
    do:  ("st" <-[go.PointerType WalogState] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (if: let: "$a0" := (Convert go.int go.uint64 (let: "$a0" := (![go.SliceType Update] "bufs") in
      (FuncResolve go.len [go.SliceType Update] #()) "$a0")) in
      (MethodResolve (go.PointerType WalogState) "updatesOverflowU64"%go (![go.PointerType WalogState] "st")) "$a0"
      then
        let: "$r0" := #false in
        do:  ("ok" <-[go.bool] "$r0");;;
        break: #()
      else do:  #());;;
      (if: let: "$a0" := (Convert go.int go.uint64 (let: "$a0" := (![go.SliceType Update] "bufs") in
      (FuncResolve go.len [go.SliceType Update] #()) "$a0")) in
      (MethodResolve (go.PointerType WalogState) "memLogHasSpace"%go (![go.PointerType WalogState] "st")) "$a0"
      then
        let: "$r0" := (let: "$a0" := (![go.PointerType sliding] (StructFieldRef WalogState "memLog"%go (![go.PointerType WalogState] "st"))) in
        let: "$a1" := (![go.SliceType Update] "bufs") in
        (FuncResolve doMemAppend [] #()) "$a0" "$a1") in
        do:  ("txn" <-[LogPosition] "$r0");;;
        do:  ((FuncResolve primitive.Linearize [] #()) #());;;
        break: #()
      else do:  #());;;
      do:  (let: "$a0" := #(W64 5) in
      let: "$a1" := #"memAppend: log is full; try again"%go in
      let: "$a2" := #slice.nil in
      (FuncResolve util.DPrintf [] #()) "$a0" "$a1" "$a2");;;
      do:  ((MethodResolve (go.PointerType WalogState) "endGroupTxn"%go (![go.PointerType WalogState] "st")) #());;;
      do:  ((MethodResolve (go.PointerType sync.Cond) "Broadcast"%go (![go.PointerType sync.Cond] (StructFieldRef Walog "condLogger"%go (![go.PointerType Walog] "l")))) #());;;
      do:  ((MethodResolve (go.PointerType sync.Cond) "Wait"%go (![go.PointerType sync.Cond] (StructFieldRef Walog "condLogger"%go (![go.PointerType Walog] "l")))) #());;;
      continue: #());;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef Walog "memLock"%go (![go.PointerType Walog] "l")))) #());;;
    return: (![LogPosition] "txn", ![go.bool] "ok")).

(* Flush flushes a transaction pos (and all preceding transactions)

   The implementation waits until the logger has appended in-memory log up to
   txn to on-disk log.

   go: wal.go:164:17 *)
Definition Walog__Flushⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" "pos",
    exception_do (let: "l" := (GoAlloc (go.PointerType Walog) "l") in
    let: "pos" := (GoAlloc LogPosition "pos") in
    do:  (let: "$a0" := #(W64 2) in
    let: "$a1" := #"Flush: commit till txn %d
    "%go in
    let: "$a2" := ((let: "$sl0" := (Convert LogPosition (go.InterfaceType []) (![LogPosition] "pos")) in
    CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0")]))) in
    (FuncResolve util.DPrintf [] #()) "$a0" "$a1" "$a2");;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] (StructFieldRef Walog "memLock"%go (![go.PointerType Walog] "l")))) #());;;
    do:  ((MethodResolve (go.PointerType sync.Cond) "Broadcast"%go (![go.PointerType sync.Cond] (StructFieldRef Walog "condLogger"%go (![go.PointerType Walog] "l")))) #());;;
    (if: Convert go.untyped_bool go.bool ((![LogPosition] "pos") >⟨go.uint64⟩ (![LogPosition] (StructFieldRef sliding "mutable"%go (![go.PointerType sliding] (StructFieldRef WalogState "memLog"%go (![go.PointerType WalogState] (StructFieldRef Walog "st"%go (![go.PointerType Walog] "l"))))))))
    then do:  ((MethodResolve (go.PointerType WalogState) "endGroupTxn"%go (![go.PointerType WalogState] (StructFieldRef Walog "st"%go (![go.PointerType Walog] "l")))) #())
    else do:  #());;;
    (for: (λ: <>, (⟨go.bool⟩! ((![LogPosition] "pos") ≤⟨go.uint64⟩ (![LogPosition] (StructFieldRef WalogState "diskEnd"%go (![go.PointerType WalogState] (StructFieldRef Walog "st"%go (![go.PointerType Walog] "l")))))))); (λ: <>, #()) := λ: <>,
      do:  ((MethodResolve (go.PointerType sync.Cond) "Wait"%go (![go.PointerType sync.Cond] (StructFieldRef Walog "condLogger"%go (![go.PointerType Walog] "l")))) #()));;;
    do:  ((FuncResolve primitive.Linearize [] #()) #());;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef Walog "memLock"%go (![go.PointerType Walog] "l")))) #());;;
    return: #()).

(* Shutdown logger and installer

   go: wal.go:186:17 *)
Definition Walog__Shutdownⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" <>,
    exception_do (let: "l" := (GoAlloc (go.PointerType Walog) "l") in
    do:  (let: "$a0" := #(W64 1) in
    let: "$a1" := #"shutdown wal
    "%go in
    let: "$a2" := #slice.nil in
    (FuncResolve util.DPrintf [] #()) "$a0" "$a1" "$a2");;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] (StructFieldRef Walog "memLock"%go (![go.PointerType Walog] "l")))) #());;;
    let: "$r0" := #true in
    do:  ((StructFieldRef WalogState "shutdown"%go (![go.PointerType WalogState] (StructFieldRef Walog "st"%go (![go.PointerType Walog] "l")))) <-[go.bool] "$r0");;;
    do:  ((MethodResolve (go.PointerType sync.Cond) "Broadcast"%go (![go.PointerType sync.Cond] (StructFieldRef Walog "condLogger"%go (![go.PointerType Walog] "l")))) #());;;
    do:  ((MethodResolve (go.PointerType sync.Cond) "Broadcast"%go (![go.PointerType sync.Cond] (StructFieldRef Walog "condInstall"%go (![go.PointerType Walog] "l")))) #());;;
    (for: (λ: <>, (![go.uint64] (StructFieldRef WalogState "nthread"%go (![go.PointerType WalogState] (StructFieldRef Walog "st"%go (![go.PointerType Walog] "l"))))) >⟨go.uint64⟩ #(W64 0)); (λ: <>, #()) := λ: <>,
      do:  (let: "$a0" := #(W64 1) in
      let: "$a1" := #"wait for logger/installer"%go in
      let: "$a2" := #slice.nil in
      (FuncResolve util.DPrintf [] #()) "$a0" "$a1" "$a2");;;
      do:  ((MethodResolve (go.PointerType sync.Cond) "Wait"%go (![go.PointerType sync.Cond] (StructFieldRef Walog "condShut"%go (![go.PointerType Walog] "l")))) #()));;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef Walog "memLock"%go (![go.PointerType Walog] "l")))) #());;;
    do:  (let: "$a0" := #(W64 1) in
    let: "$a1" := #"wal done
    "%go in
    let: "$a2" := #slice.nil in
    (FuncResolve util.DPrintf [] #()) "$a0" "$a1" "$a2");;;
    return: #()).

#[global] Instance info' : PkgInfo pkg_id.wal :=
{|
  pkg_imported_pkgs := [code.github_com.goose_lang.primitive.disk.pkg_id.disk; code.github_com.mit_pdos.go_journal.common.pkg_id.common; code.github_com.tchajed.marshal.pkg_id.marshal; code.github_com.mit_pdos.go_journal.util.pkg_id.util; code.sync.pkg_id.sync; code.github_com.goose_lang.primitive.pkg_id.primitive]
|}.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init pkg_id.wal (λ: <>,
      exception_do (do:  (primitive.initialize' #());;;
      do:  (sync.initialize' #());;;
      do:  (util.initialize' #());;;
      do:  (marshal.initialize' #());;;
      do:  (common.initialize' #());;;
      do:  (disk.initialize' #()))
      ).

Module LogPosition.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := w64.
End def.
End LogPosition.

Definition LogPositionⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.uint64.

Class LogPosition_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] LogPosition_underlying :: (LogPosition) <u (LogPositionⁱᵐᵖˡ);
}.

Module Update.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  Addr' : w64;
  Block' : slice.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End Update.

Definition Update'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "Addr"%go common.Bnum);
  (go.FieldDecl "Block"%go disk.Block)
].
Program Definition Update'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (Update'fds_unsealed).
Global Instance equals_unfold_Update {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Update'fds =→ Update'fds_unsealed.
Proof. rewrite /Update'fds seal_eq //. Qed.

Definition Updateⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (Update'fds).

Class Update_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Update_type_repr  :: go.TypeReprUnderlying Updateⁱᵐᵖˡ Update.t;
  #[global] Update_underlying :: (Update) <u (Updateⁱᵐᵖˡ);
  #[global] Update_get_Addr (x : Update.t) :: ⟦StructFieldGet (Updateⁱᵐᵖˡ) "Addr", #x⟧ ⤳[under] #x.(Update.Addr');
  #[global] Update_set_Addr (x : Update.t) y :: ⟦StructFieldSet (Updateⁱᵐᵖˡ) "Addr", (#x, #y)⟧ ⤳[under] #(x <|Update.Addr' := y|>);
  #[global] Update_get_Block (x : Update.t) :: ⟦StructFieldGet (Updateⁱᵐᵖˡ) "Block", #x⟧ ⤳[under] #x.(Update.Block');
  #[global] Update_set_Block (x : Update.t) y :: ⟦StructFieldSet (Updateⁱᵐᵖˡ) "Block", (#x, #y)⟧ ⤳[under] #(x <|Update.Block' := y|>);
}.

Module circularAppender.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  diskAddrs' : slice.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End circularAppender.

Definition circularAppender'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "diskAddrs"%go (go.SliceType go.uint64))
].
Program Definition circularAppender'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (circularAppender'fds_unsealed).
Global Instance equals_unfold_circularAppender {ext : ffi_syntax} {go_gctx : GoGlobalContext} : circularAppender'fds =→ circularAppender'fds_unsealed.
Proof. rewrite /circularAppender'fds seal_eq //. Qed.

Definition circularAppenderⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (circularAppender'fds).

Class circularAppender_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] circularAppender_type_repr  :: go.TypeReprUnderlying circularAppenderⁱᵐᵖˡ circularAppender.t;
  #[global] circularAppender_underlying :: (circularAppender) <u (circularAppenderⁱᵐᵖˡ);
  #[global] circularAppender_get_diskAddrs (x : circularAppender.t) :: ⟦StructFieldGet (circularAppenderⁱᵐᵖˡ) "diskAddrs", #x⟧ ⤳[under] #x.(circularAppender.diskAddrs');
  #[global] circularAppender_set_diskAddrs (x : circularAppender.t) y :: ⟦StructFieldSet (circularAppenderⁱᵐᵖˡ) "diskAddrs", (#x, #y)⟧ ⤳[under] #(x <|circularAppender.diskAddrs' := y|>);
  #[global] circularAppender'ptr_Append_unfold :: MethodUnfold (go.PointerType (circularAppender)) "Append" (circularAppender__Appendⁱᵐᵖˡ);
  #[global] circularAppender'ptr_hdr1_unfold :: MethodUnfold (go.PointerType (circularAppender)) "hdr1" (circularAppender__hdr1ⁱᵐᵖˡ);
  #[global] circularAppender'ptr_logBlocks_unfold :: MethodUnfold (go.PointerType (circularAppender)) "logBlocks" (circularAppender__logBlocksⁱᵐᵖˡ);
}.

Module sliding.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  log' : slice.t;
  start' : wal.LogPosition.t;
  mutable' : wal.LogPosition.t;
  needFlush' : bool;
  addrPos' : map.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End sliding.

Definition sliding'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "log"%go (go.SliceType Update));
  (go.FieldDecl "start"%go LogPosition);
  (go.FieldDecl "mutable"%go LogPosition);
  (go.FieldDecl "needFlush"%go go.bool);
  (go.FieldDecl "addrPos"%go (go.MapType common.Bnum LogPosition))
].
Program Definition sliding'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (sliding'fds_unsealed).
Global Instance equals_unfold_sliding {ext : ffi_syntax} {go_gctx : GoGlobalContext} : sliding'fds =→ sliding'fds_unsealed.
Proof. rewrite /sliding'fds seal_eq //. Qed.

Definition slidingⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (sliding'fds).

Class sliding_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] sliding_type_repr  :: go.TypeReprUnderlying slidingⁱᵐᵖˡ sliding.t;
  #[global] sliding_underlying :: (sliding) <u (slidingⁱᵐᵖˡ);
  #[global] sliding_get_log (x : sliding.t) :: ⟦StructFieldGet (slidingⁱᵐᵖˡ) "log", #x⟧ ⤳[under] #x.(sliding.log');
  #[global] sliding_set_log (x : sliding.t) y :: ⟦StructFieldSet (slidingⁱᵐᵖˡ) "log", (#x, #y)⟧ ⤳[under] #(x <|sliding.log' := y|>);
  #[global] sliding_get_start (x : sliding.t) :: ⟦StructFieldGet (slidingⁱᵐᵖˡ) "start", #x⟧ ⤳[under] #x.(sliding.start');
  #[global] sliding_set_start (x : sliding.t) y :: ⟦StructFieldSet (slidingⁱᵐᵖˡ) "start", (#x, #y)⟧ ⤳[under] #(x <|sliding.start' := y|>);
  #[global] sliding_get_mutable (x : sliding.t) :: ⟦StructFieldGet (slidingⁱᵐᵖˡ) "mutable", #x⟧ ⤳[under] #x.(sliding.mutable');
  #[global] sliding_set_mutable (x : sliding.t) y :: ⟦StructFieldSet (slidingⁱᵐᵖˡ) "mutable", (#x, #y)⟧ ⤳[under] #(x <|sliding.mutable' := y|>);
  #[global] sliding_get_needFlush (x : sliding.t) :: ⟦StructFieldGet (slidingⁱᵐᵖˡ) "needFlush", #x⟧ ⤳[under] #x.(sliding.needFlush');
  #[global] sliding_set_needFlush (x : sliding.t) y :: ⟦StructFieldSet (slidingⁱᵐᵖˡ) "needFlush", (#x, #y)⟧ ⤳[under] #(x <|sliding.needFlush' := y|>);
  #[global] sliding_get_addrPos (x : sliding.t) :: ⟦StructFieldGet (slidingⁱᵐᵖˡ) "addrPos", #x⟧ ⤳[under] #x.(sliding.addrPos');
  #[global] sliding_set_addrPos (x : sliding.t) y :: ⟦StructFieldSet (slidingⁱᵐᵖˡ) "addrPos", (#x, #y)⟧ ⤳[under] #(x <|sliding.addrPos' := y|>);
  #[global] sliding'ptr_append_unfold :: MethodUnfold (go.PointerType (sliding)) "append" (sliding__appendⁱᵐᵖˡ);
  #[global] sliding'ptr_clearMutable_unfold :: MethodUnfold (go.PointerType (sliding)) "clearMutable" (sliding__clearMutableⁱᵐᵖˡ);
  #[global] sliding'ptr_deleteFrom_unfold :: MethodUnfold (go.PointerType (sliding)) "deleteFrom" (sliding__deleteFromⁱᵐᵖˡ);
  #[global] sliding'ptr_end_unfold :: MethodUnfold (go.PointerType (sliding)) "end" (sliding__endⁱᵐᵖˡ);
  #[global] sliding'ptr_get_unfold :: MethodUnfold (go.PointerType (sliding)) "get" (sliding__getⁱᵐᵖˡ);
  #[global] sliding'ptr_intoMutable_unfold :: MethodUnfold (go.PointerType (sliding)) "intoMutable" (sliding__intoMutableⁱᵐᵖˡ);
  #[global] sliding'ptr_memWrite_unfold :: MethodUnfold (go.PointerType (sliding)) "memWrite" (sliding__memWriteⁱᵐᵖˡ);
  #[global] sliding'ptr_posForAddr_unfold :: MethodUnfold (go.PointerType (sliding)) "posForAddr" (sliding__posForAddrⁱᵐᵖˡ);
  #[global] sliding'ptr_takeFrom_unfold :: MethodUnfold (go.PointerType (sliding)) "takeFrom" (sliding__takeFromⁱᵐᵖˡ);
  #[global] sliding'ptr_takeTill_unfold :: MethodUnfold (go.PointerType (sliding)) "takeTill" (sliding__takeTillⁱᵐᵖˡ);
  #[global] sliding'ptr_update_unfold :: MethodUnfold (go.PointerType (sliding)) "update" (sliding__updateⁱᵐᵖˡ);
}.

Module WalogState.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  memLog' : loc;
  diskEnd' : wal.LogPosition.t;
  shutdown' : bool;
  nthread' : w64;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End WalogState.

Definition WalogState'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "memLog"%go (go.PointerType sliding));
  (go.FieldDecl "diskEnd"%go LogPosition);
  (go.FieldDecl "shutdown"%go go.bool);
  (go.FieldDecl "nthread"%go go.uint64)
].
Program Definition WalogState'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (WalogState'fds_unsealed).
Global Instance equals_unfold_WalogState {ext : ffi_syntax} {go_gctx : GoGlobalContext} : WalogState'fds =→ WalogState'fds_unsealed.
Proof. rewrite /WalogState'fds seal_eq //. Qed.

Definition WalogStateⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (WalogState'fds).

Class WalogState_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] WalogState_type_repr  :: go.TypeReprUnderlying WalogStateⁱᵐᵖˡ WalogState.t;
  #[global] WalogState_underlying :: (WalogState) <u (WalogStateⁱᵐᵖˡ);
  #[global] WalogState_get_memLog (x : WalogState.t) :: ⟦StructFieldGet (WalogStateⁱᵐᵖˡ) "memLog", #x⟧ ⤳[under] #x.(WalogState.memLog');
  #[global] WalogState_set_memLog (x : WalogState.t) y :: ⟦StructFieldSet (WalogStateⁱᵐᵖˡ) "memLog", (#x, #y)⟧ ⤳[under] #(x <|WalogState.memLog' := y|>);
  #[global] WalogState_get_diskEnd (x : WalogState.t) :: ⟦StructFieldGet (WalogStateⁱᵐᵖˡ) "diskEnd", #x⟧ ⤳[under] #x.(WalogState.diskEnd');
  #[global] WalogState_set_diskEnd (x : WalogState.t) y :: ⟦StructFieldSet (WalogStateⁱᵐᵖˡ) "diskEnd", (#x, #y)⟧ ⤳[under] #(x <|WalogState.diskEnd' := y|>);
  #[global] WalogState_get_shutdown (x : WalogState.t) :: ⟦StructFieldGet (WalogStateⁱᵐᵖˡ) "shutdown", #x⟧ ⤳[under] #x.(WalogState.shutdown');
  #[global] WalogState_set_shutdown (x : WalogState.t) y :: ⟦StructFieldSet (WalogStateⁱᵐᵖˡ) "shutdown", (#x, #y)⟧ ⤳[under] #(x <|WalogState.shutdown' := y|>);
  #[global] WalogState_get_nthread (x : WalogState.t) :: ⟦StructFieldGet (WalogStateⁱᵐᵖˡ) "nthread", #x⟧ ⤳[under] #x.(WalogState.nthread');
  #[global] WalogState_set_nthread (x : WalogState.t) y :: ⟦StructFieldSet (WalogStateⁱᵐᵖˡ) "nthread", (#x, #y)⟧ ⤳[under] #(x <|WalogState.nthread' := y|>);
  #[global] WalogState'ptr_cutMemLog_unfold :: MethodUnfold (go.PointerType (WalogState)) "cutMemLog" (WalogState__cutMemLogⁱᵐᵖˡ);
  #[global] WalogState'ptr_endGroupTxn_unfold :: MethodUnfold (go.PointerType (WalogState)) "endGroupTxn" (WalogState__endGroupTxnⁱᵐᵖˡ);
  #[global] WalogState'ptr_memEnd_unfold :: MethodUnfold (go.PointerType (WalogState)) "memEnd" (WalogState__memEndⁱᵐᵖˡ);
  #[global] WalogState'ptr_memLogHasSpace_unfold :: MethodUnfold (go.PointerType (WalogState)) "memLogHasSpace" (WalogState__memLogHasSpaceⁱᵐᵖˡ);
  #[global] WalogState'ptr_readMem_unfold :: MethodUnfold (go.PointerType (WalogState)) "readMem" (WalogState__readMemⁱᵐᵖˡ);
  #[global] WalogState'ptr_updatesOverflowU64_unfold :: MethodUnfold (go.PointerType (WalogState)) "updatesOverflowU64" (WalogState__updatesOverflowU64ⁱᵐᵖˡ);
}.

Module Walog.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  memLock' : loc;
  d' : disk.Disk.t;
  circ' : loc;
  st' : loc;
  condLogger' : loc;
  condInstall' : loc;
  condShut' : loc;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End Walog.

Definition Walog'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "memLock"%go (go.PointerType sync.Mutex));
  (go.FieldDecl "d"%go disk.Disk);
  (go.FieldDecl "circ"%go (go.PointerType circularAppender));
  (go.FieldDecl "st"%go (go.PointerType WalogState));
  (go.FieldDecl "condLogger"%go (go.PointerType sync.Cond));
  (go.FieldDecl "condInstall"%go (go.PointerType sync.Cond));
  (go.FieldDecl "condShut"%go (go.PointerType sync.Cond))
].
Program Definition Walog'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (Walog'fds_unsealed).
Global Instance equals_unfold_Walog {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Walog'fds =→ Walog'fds_unsealed.
Proof. rewrite /Walog'fds seal_eq //. Qed.

Definition Walogⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (Walog'fds).

Class Walog_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Walog_type_repr  :: go.TypeReprUnderlying Walogⁱᵐᵖˡ Walog.t;
  #[global] Walog_underlying :: (Walog) <u (Walogⁱᵐᵖˡ);
  #[global] Walog_get_memLock (x : Walog.t) :: ⟦StructFieldGet (Walogⁱᵐᵖˡ) "memLock", #x⟧ ⤳[under] #x.(Walog.memLock');
  #[global] Walog_set_memLock (x : Walog.t) y :: ⟦StructFieldSet (Walogⁱᵐᵖˡ) "memLock", (#x, #y)⟧ ⤳[under] #(x <|Walog.memLock' := y|>);
  #[global] Walog_get_d (x : Walog.t) :: ⟦StructFieldGet (Walogⁱᵐᵖˡ) "d", #x⟧ ⤳[under] #x.(Walog.d');
  #[global] Walog_set_d (x : Walog.t) y :: ⟦StructFieldSet (Walogⁱᵐᵖˡ) "d", (#x, #y)⟧ ⤳[under] #(x <|Walog.d' := y|>);
  #[global] Walog_get_circ (x : Walog.t) :: ⟦StructFieldGet (Walogⁱᵐᵖˡ) "circ", #x⟧ ⤳[under] #x.(Walog.circ');
  #[global] Walog_set_circ (x : Walog.t) y :: ⟦StructFieldSet (Walogⁱᵐᵖˡ) "circ", (#x, #y)⟧ ⤳[under] #(x <|Walog.circ' := y|>);
  #[global] Walog_get_st (x : Walog.t) :: ⟦StructFieldGet (Walogⁱᵐᵖˡ) "st", #x⟧ ⤳[under] #x.(Walog.st');
  #[global] Walog_set_st (x : Walog.t) y :: ⟦StructFieldSet (Walogⁱᵐᵖˡ) "st", (#x, #y)⟧ ⤳[under] #(x <|Walog.st' := y|>);
  #[global] Walog_get_condLogger (x : Walog.t) :: ⟦StructFieldGet (Walogⁱᵐᵖˡ) "condLogger", #x⟧ ⤳[under] #x.(Walog.condLogger');
  #[global] Walog_set_condLogger (x : Walog.t) y :: ⟦StructFieldSet (Walogⁱᵐᵖˡ) "condLogger", (#x, #y)⟧ ⤳[under] #(x <|Walog.condLogger' := y|>);
  #[global] Walog_get_condInstall (x : Walog.t) :: ⟦StructFieldGet (Walogⁱᵐᵖˡ) "condInstall", #x⟧ ⤳[under] #x.(Walog.condInstall');
  #[global] Walog_set_condInstall (x : Walog.t) y :: ⟦StructFieldSet (Walogⁱᵐᵖˡ) "condInstall", (#x, #y)⟧ ⤳[under] #(x <|Walog.condInstall' := y|>);
  #[global] Walog_get_condShut (x : Walog.t) :: ⟦StructFieldGet (Walogⁱᵐᵖˡ) "condShut", #x⟧ ⤳[under] #x.(Walog.condShut');
  #[global] Walog_set_condShut (x : Walog.t) y :: ⟦StructFieldSet (Walogⁱᵐᵖˡ) "condShut", (#x, #y)⟧ ⤳[under] #(x <|Walog.condShut' := y|>);
  #[global] Walog'ptr_Flush_unfold :: MethodUnfold (go.PointerType (Walog)) "Flush" (Walog__Flushⁱᵐᵖˡ);
  #[global] Walog'ptr_LogSz_unfold :: MethodUnfold (go.PointerType (Walog)) "LogSz" (Walog__LogSzⁱᵐᵖˡ);
  #[global] Walog'ptr_MemAppend_unfold :: MethodUnfold (go.PointerType (Walog)) "MemAppend" (Walog__MemAppendⁱᵐᵖˡ);
  #[global] Walog'ptr_Read_unfold :: MethodUnfold (go.PointerType (Walog)) "Read" (Walog__Readⁱᵐᵖˡ);
  #[global] Walog'ptr_ReadInstalled_unfold :: MethodUnfold (go.PointerType (Walog)) "ReadInstalled" (Walog__ReadInstalledⁱᵐᵖˡ);
  #[global] Walog'ptr_ReadMem_unfold :: MethodUnfold (go.PointerType (Walog)) "ReadMem" (Walog__ReadMemⁱᵐᵖˡ);
  #[global] Walog'ptr_Shutdown_unfold :: MethodUnfold (go.PointerType (Walog)) "Shutdown" (Walog__Shutdownⁱᵐᵖˡ);
  #[global] Walog'ptr_flushIfNeeded_unfold :: MethodUnfold (go.PointerType (Walog)) "flushIfNeeded" (Walog__flushIfNeededⁱᵐᵖˡ);
  #[global] Walog'ptr_installer_unfold :: MethodUnfold (go.PointerType (Walog)) "installer" (Walog__installerⁱᵐᵖˡ);
  #[global] Walog'ptr_logAppend_unfold :: MethodUnfold (go.PointerType (Walog)) "logAppend" (Walog__logAppendⁱᵐᵖˡ);
  #[global] Walog'ptr_logInstall_unfold :: MethodUnfold (go.PointerType (Walog)) "logInstall" (Walog__logInstallⁱᵐᵖˡ);
  #[global] Walog'ptr_logger_unfold :: MethodUnfold (go.PointerType (Walog)) "logger" (Walog__loggerⁱᵐᵖˡ);
  #[global] Walog'ptr_startBackgroundThreads_unfold :: MethodUnfold (go.PointerType (Walog)) "startBackgroundThreads" (Walog__startBackgroundThreadsⁱᵐᵖˡ);
  #[global] Walog'ptr_waitForSpace_unfold :: MethodUnfold (go.PointerType (Walog)) "waitForSpace" (Walog__waitForSpaceⁱᵐᵖˡ);
}.

Class Assumptions `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] LogPosition_instance :: LogPosition_Assumptions;
  #[global] Update_instance :: Update_Assumptions;
  #[global] circularAppender_instance :: circularAppender_Assumptions;
  #[global] sliding_instance :: sliding_Assumptions;
  #[global] WalogState_instance :: WalogState_Assumptions;
  #[global] Walog_instance :: Walog_Assumptions;
  #[global] MkBlockData_unfold :: FuncUnfold MkBlockData [] (MkBlockDataⁱᵐᵖˡ);
  #[global] initCircular_unfold :: FuncUnfold initCircular [] (initCircularⁱᵐᵖˡ);
  #[global] decodeHdr1_unfold :: FuncUnfold decodeHdr1 [] (decodeHdr1ⁱᵐᵖˡ);
  #[global] decodeHdr2_unfold :: FuncUnfold decodeHdr2 [] (decodeHdr2ⁱᵐᵖˡ);
  #[global] recoverCircular_unfold :: FuncUnfold recoverCircular [] (recoverCircularⁱᵐᵖˡ);
  #[global] hdr2_unfold :: FuncUnfold hdr2 [] (hdr2ⁱᵐᵖˡ);
  #[global] Advance_unfold :: FuncUnfold Advance [] (Advanceⁱᵐᵖˡ);
  #[global] mkSliding_unfold :: FuncUnfold mkSliding [] (mkSlidingⁱᵐᵖˡ);
  #[global] absorbBufs_unfold :: FuncUnfold absorbBufs [] (absorbBufsⁱᵐᵖˡ);
  #[global] installBlocks_unfold :: FuncUnfold installBlocks [] (installBlocksⁱᵐᵖˡ);
  #[global] mkLog_unfold :: FuncUnfold mkLog [] (mkLogⁱᵐᵖˡ);
  #[global] MkLog_unfold :: FuncUnfold MkLog [] (MkLogⁱᵐᵖˡ);
  #[global] doMemAppend_unfold :: FuncUnfold doMemAppend [] (doMemAppendⁱᵐᵖˡ);
  #[global] copyUpdateBlock_unfold :: FuncUnfold copyUpdateBlock [] (copyUpdateBlockⁱᵐᵖˡ);
  #[global] import_disk_Assumption :: disk.Assumptions;
  #[global] import_common_Assumption :: common.Assumptions;
  #[global] import_marshal_Assumption :: marshal.Assumptions;
  #[global] import_util_Assumption :: util.Assumptions;
  #[global] import_sync_Assumption :: sync.Assumptions;
  #[global] import_primitive_Assumption :: primitive.Assumptions;
}.
End wal.
