(* autogenerated from github.com/mit-pdos/go-journal/wal *)
From New.golang Require Import defn.
Require Export New.code.github_com.goose_lang.primitive.
Require Export New.code.github_com.goose_lang.primitive.disk.
Require Export New.code.github_com.mit_pdos.go_journal.common.
Require Export New.code.github_com.mit_pdos.go_journal.util.
Require Export New.code.github_com.tchajed.marshal.
Require Export New.code.sync.

Definition wal : go_string := "github.com/mit-pdos/go-journal/wal".

From New Require Import disk_prelude.
Module wal.
Section code.


(* space for the end position *)
Definition HDRMETA : expr := #(W64 8).

Definition HDRADDRS : expr := (disk.BlockSize - HDRMETA) `quot` #(W64 8).

Definition LOGSZ : expr := HDRADDRS.

(* 2 for log header *)
Definition LOGDISKBLOCKS : expr := HDRADDRS + #(W64 2).

Definition LOGHDR : expr := #(W64 0).

Definition LOGHDR2 : expr := #(W64 1).

Definition LOGSTART : expr := #(W64 2).

Definition LogPosition : go_type := uint64T.

Definition Update : go_type := structT [
  "Addr" :: uint64T;
  "Block" :: sliceT
].

(* go: 0circular.go:18:6 *)
Definition MkBlockData : val :=
  rec: "MkBlockData" "bn" "blk" :=
    exception_do (let: "blk" := (mem.alloc "blk") in
    let: "bn" := (mem.alloc "bn") in
    let: "b" := (mem.alloc (type.zero_val #Update)) in
    let: "$r0" := (let: "$Addr" := (![#uint64T] "bn") in
    let: "$Block" := (![#sliceT] "blk") in
    struct.make #Update [{
      "Addr" ::= "$Addr";
      "Block" ::= "$Block"
    }]) in
    do:  ("b" <-[#Update] "$r0");;;
    return: (![#Update] "b")).

Definition circularAppender : go_type := structT [
  "diskAddrs" :: sliceT
].

(* initCircular takes ownership of the circular log, which is the first
   LOGDISKBLOCKS of the disk.

   go: 0circular.go:29:6 *)
Definition initCircular : val :=
  rec: "initCircular" "d" :=
    exception_do (let: "d" := (mem.alloc "d") in
    let: "b0" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make2 #byteT disk.BlockSize) in
    do:  ("b0" <-[#sliceT] "$r0");;;
    do:  (let: "$a0" := LOGHDR in
    let: "$a1" := (![#sliceT] "b0") in
    (interface.get #"Write"%go (![#disk.Disk] "d")) "$a0" "$a1");;;
    do:  (let: "$a0" := LOGHDR2 in
    let: "$a1" := (![#sliceT] "b0") in
    (interface.get #"Write"%go (![#disk.Disk] "d")) "$a0" "$a1");;;
    let: "addrs" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make2 #uint64T HDRADDRS) in
    do:  ("addrs" <-[#sliceT] "$r0");;;
    return: (mem.alloc (let: "$diskAddrs" := (![#sliceT] "addrs") in
     struct.make #circularAppender [{
       "diskAddrs" ::= "$diskAddrs"
     }]))).

(* decodeHdr1 decodes (end, start) from hdr1

   go: 0circular.go:40:6 *)
Definition decodeHdr1 : val :=
  rec: "decodeHdr1" "hdr1" :=
    exception_do (let: "hdr1" := (mem.alloc "hdr1") in
    let: "dec1" := (mem.alloc (type.zero_val #marshal.Dec)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "hdr1") in
    (func_call #marshal.marshal #"NewDec"%go) "$a0") in
    do:  ("dec1" <-[#marshal.Dec] "$r0");;;
    let: "end" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := ((method_call #marshal #"Dec" #"GetInt" (![#marshal.Dec] "dec1")) #()) in
    do:  ("end" <-[#uint64T] "$r0");;;
    let: "addrs" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := HDRADDRS in
    (method_call #marshal #"Dec" #"GetInts" (![#marshal.Dec] "dec1")) "$a0") in
    do:  ("addrs" <-[#sliceT] "$r0");;;
    return: (![#uint64T] "end", ![#sliceT] "addrs")).

(* decodeHdr2 reads start from hdr2

   go: 0circular.go:48:6 *)
Definition decodeHdr2 : val :=
  rec: "decodeHdr2" "hdr2" :=
    exception_do (let: "hdr2" := (mem.alloc "hdr2") in
    let: "dec2" := (mem.alloc (type.zero_val #marshal.Dec)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "hdr2") in
    (func_call #marshal.marshal #"NewDec"%go) "$a0") in
    do:  ("dec2" <-[#marshal.Dec] "$r0");;;
    let: "start" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := ((method_call #marshal #"Dec" #"GetInt" (![#marshal.Dec] "dec2")) #()) in
    do:  ("start" <-[#uint64T] "$r0");;;
    return: (![#uint64T] "start")).

(* go: 0circular.go:54:6 *)
Definition recoverCircular : val :=
  rec: "recoverCircular" "d" :=
    exception_do (let: "d" := (mem.alloc "d") in
    let: "hdr1" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := LOGHDR in
    (interface.get #"Read"%go (![#disk.Disk] "d")) "$a0") in
    do:  ("hdr1" <-[#sliceT] "$r0");;;
    let: "hdr2" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := LOGHDR2 in
    (interface.get #"Read"%go (![#disk.Disk] "d")) "$a0") in
    do:  ("hdr2" <-[#sliceT] "$r0");;;
    let: "addrs" := (mem.alloc (type.zero_val #sliceT)) in
    let: "end" := (mem.alloc (type.zero_val #uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "hdr1") in
    (func_call #wal.wal #"decodeHdr1"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("end" <-[#uint64T] "$r0");;;
    do:  ("addrs" <-[#sliceT] "$r1");;;
    let: "start" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "hdr2") in
    (func_call #wal.wal #"decodeHdr2"%go) "$a0") in
    do:  ("start" <-[#uint64T] "$r0");;;
    let: "bufs" := (mem.alloc (type.zero_val #sliceT)) in
    (let: "pos" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (![#uint64T] "start") in
    do:  ("pos" <-[#uint64T] "$r0");;;
    (for: (λ: <>, (![#uint64T] "pos") < (![#uint64T] "end")); (λ: <>, do:  ("pos" <-[#uint64T] ((![#uint64T] "pos") + #(W64 1)))) := λ: <>,
      let: "addr" := (mem.alloc (type.zero_val #uint64T)) in
      let: "$r0" := (![#uint64T] (slice.elem_ref #uint64T (![#sliceT] "addrs") ((![#uint64T] "pos") `rem` LOGSZ))) in
      do:  ("addr" <-[#uint64T] "$r0");;;
      let: "b" := (mem.alloc (type.zero_val #sliceT)) in
      let: "$r0" := (let: "$a0" := (LOGSTART + ((![#uint64T] "pos") `rem` LOGSZ)) in
      (interface.get #"Read"%go (![#disk.Disk] "d")) "$a0") in
      do:  ("b" <-[#sliceT] "$r0");;;
      let: "$r0" := (let: "$a0" := (![#sliceT] "bufs") in
      let: "$a1" := ((let: "$sl0" := (let: "$Addr" := (![#uint64T] "addr") in
      let: "$Block" := (![#sliceT] "b") in
      struct.make #Update [{
        "Addr" ::= "$Addr";
        "Block" ::= "$Block"
      }]) in
      slice.literal #Update ["$sl0"])) in
      (slice.append #Update) "$a0" "$a1") in
      do:  ("bufs" <-[#sliceT] "$r0")));;;
    return: (mem.alloc (let: "$diskAddrs" := (![#sliceT] "addrs") in
     struct.make #circularAppender [{
       "diskAddrs" ::= "$diskAddrs"
     }]), ![#uint64T] "start", ![#uint64T] "end", ![#sliceT] "bufs")).

(* go: 0circular.go:70:28 *)
Definition circularAppender__hdr1 : val :=
  rec: "circularAppender__hdr1" "c" "end" :=
    exception_do (let: "c" := (mem.alloc "c") in
    let: "end" := (mem.alloc "end") in
    let: "enc" := (mem.alloc (type.zero_val #marshal.Enc)) in
    let: "$r0" := (let: "$a0" := disk.BlockSize in
    (func_call #marshal.marshal #"NewEnc"%go) "$a0") in
    do:  ("enc" <-[#marshal.Enc] "$r0");;;
    do:  (let: "$a0" := (![#LogPosition] "end") in
    (method_call #marshal #"Enc" #"PutInt" (![#marshal.Enc] "enc")) "$a0");;;
    do:  (let: "$a0" := (![#sliceT] (struct.field_ref #circularAppender #"diskAddrs"%go (![#ptrT] "c"))) in
    (method_call #marshal #"Enc" #"PutInts" (![#marshal.Enc] "enc")) "$a0");;;
    return: ((method_call #marshal #"Enc" #"Finish" (![#marshal.Enc] "enc")) #())).

(* go: 0circular.go:77:6 *)
Definition hdr2 : val :=
  rec: "hdr2" "start" :=
    exception_do (let: "start" := (mem.alloc "start") in
    let: "enc" := (mem.alloc (type.zero_val #marshal.Enc)) in
    let: "$r0" := (let: "$a0" := disk.BlockSize in
    (func_call #marshal.marshal #"NewEnc"%go) "$a0") in
    do:  ("enc" <-[#marshal.Enc] "$r0");;;
    do:  (let: "$a0" := (![#LogPosition] "start") in
    (method_call #marshal #"Enc" #"PutInt" (![#marshal.Enc] "enc")) "$a0");;;
    return: ((method_call #marshal #"Enc" #"Finish" (![#marshal.Enc] "enc")) #())).

(* go: 0circular.go:83:28 *)
Definition circularAppender__logBlocks : val :=
  rec: "circularAppender__logBlocks" "c" "d" "end" "bufs" :=
    exception_do (let: "c" := (mem.alloc "c") in
    let: "bufs" := (mem.alloc "bufs") in
    let: "end" := (mem.alloc "end") in
    let: "d" := (mem.alloc "d") in
    let: "$range" := (![#sliceT] "bufs") in
    (let: "buf" := (mem.alloc (type.zero_val #Update)) in
    let: "i" := (mem.alloc (type.zero_val #intT)) in
    slice.for_range #Update "$range" (λ: "$key" "$value",
      do:  ("buf" <-[#Update] "$value");;;
      do:  ("i" <-[#intT] "$key");;;
      let: "pos" := (mem.alloc (type.zero_val #LogPosition)) in
      let: "$r0" := ((![#LogPosition] "end") + (s_to_w64 (![#intT] "i"))) in
      do:  ("pos" <-[#LogPosition] "$r0");;;
      let: "blk" := (mem.alloc (type.zero_val #sliceT)) in
      let: "$r0" := (![#sliceT] (struct.field_ref #Update #"Block"%go "buf")) in
      do:  ("blk" <-[#sliceT] "$r0");;;
      let: "blkno" := (mem.alloc (type.zero_val #uint64T)) in
      let: "$r0" := (![#uint64T] (struct.field_ref #Update #"Addr"%go "buf")) in
      do:  ("blkno" <-[#uint64T] "$r0");;;
      do:  (let: "$a0" := #(W64 5) in
      let: "$a1" := #"logBlocks: %d to log block %d
      "%go in
      let: "$a2" := ((let: "$sl0" := (interface.make #""%go #"uint64"%go (![#uint64T] "blkno")) in
      let: "$sl1" := (interface.make #wal.wal #"LogPosition" (![#LogPosition] "pos")) in
      slice.literal #interfaceT ["$sl0"; "$sl1"])) in
      (func_call #util.util #"DPrintf"%go) "$a0" "$a1" "$a2");;;
      do:  (let: "$a0" := (LOGSTART + ((![#LogPosition] "pos") `rem` LOGSZ)) in
      let: "$a1" := (![#sliceT] "blk") in
      (interface.get #"Write"%go (![#disk.Disk] "d")) "$a0" "$a1");;;
      let: "$r0" := (![#uint64T] "blkno") in
      do:  ((slice.elem_ref #uint64T (![#sliceT] (struct.field_ref #circularAppender #"diskAddrs"%go (![#ptrT] "c"))) ((![#LogPosition] "pos") `rem` LOGSZ)) <-[#uint64T] "$r0")));;;
    return: #()).

(* go: 0circular.go:95:28 *)
Definition circularAppender__Append : val :=
  rec: "circularAppender__Append" "c" "d" "end" "bufs" :=
    exception_do (let: "c" := (mem.alloc "c") in
    let: "bufs" := (mem.alloc "bufs") in
    let: "end" := (mem.alloc "end") in
    let: "d" := (mem.alloc "d") in
    do:  (let: "$a0" := (![#disk.Disk] "d") in
    let: "$a1" := (![#LogPosition] "end") in
    let: "$a2" := (![#sliceT] "bufs") in
    (method_call #wal.wal #"circularAppender'ptr" #"logBlocks" (![#ptrT] "c")) "$a0" "$a1" "$a2");;;
    do:  ((interface.get #"Barrier"%go (![#disk.Disk] "d")) #());;;
    let: "newEnd" := (mem.alloc (type.zero_val #LogPosition)) in
    let: "$r0" := ((![#LogPosition] "end") + (s_to_w64 (let: "$a0" := (![#sliceT] "bufs") in
    slice.len "$a0"))) in
    do:  ("newEnd" <-[#LogPosition] "$r0");;;
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#LogPosition] "newEnd") in
    (method_call #wal.wal #"circularAppender'ptr" #"hdr1" (![#ptrT] "c")) "$a0") in
    do:  ("b" <-[#sliceT] "$r0");;;
    do:  (let: "$a0" := LOGHDR in
    let: "$a1" := (![#sliceT] "b") in
    (interface.get #"Write"%go (![#disk.Disk] "d")) "$a0" "$a1");;;
    do:  ((interface.get #"Barrier"%go (![#disk.Disk] "d")) #());;;
    return: #()).

(* go: 0circular.go:105:6 *)
Definition Advance : val :=
  rec: "Advance" "d" "newStart" :=
    exception_do (let: "newStart" := (mem.alloc "newStart") in
    let: "d" := (mem.alloc "d") in
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#LogPosition] "newStart") in
    (func_call #wal.wal #"hdr2"%go) "$a0") in
    do:  ("b" <-[#sliceT] "$r0");;;
    do:  (let: "$a0" := LOGHDR2 in
    let: "$a1" := (![#sliceT] "b") in
    (interface.get #"Write"%go (![#disk.Disk] "d")) "$a0" "$a1");;;
    do:  ((interface.get #"Barrier"%go (![#disk.Disk] "d")) #());;;
    return: #()).

Definition sliding : go_type := structT [
  "log" :: sliceT;
  "start" :: LogPosition;
  "mutable" :: LogPosition;
  "needFlush" :: boolT;
  "addrPos" :: mapT uint64T LogPosition
].

(* go: 0sliding.go:16:6 *)
Definition mkSliding : val :=
  rec: "mkSliding" "log" "start" :=
    exception_do (let: "start" := (mem.alloc "start") in
    let: "log" := (mem.alloc "log") in
    let: "addrPos" := (mem.alloc (type.zero_val (type.mapT #uint64T #LogPosition))) in
    let: "$r0" := (map.make #uint64T #LogPosition) in
    do:  ("addrPos" <-[type.mapT #uint64T #LogPosition] "$r0");;;
    let: "$range" := (![#sliceT] "log") in
    (let: "buf" := (mem.alloc (type.zero_val #Update)) in
    let: "i" := (mem.alloc (type.zero_val #intT)) in
    slice.for_range #Update "$range" (λ: "$key" "$value",
      do:  ("buf" <-[#Update] "$value");;;
      do:  ("i" <-[#intT] "$key");;;
      let: "$r0" := ((![#LogPosition] "start") + (s_to_w64 (![#intT] "i"))) in
      do:  (map.insert (![type.mapT #uint64T #LogPosition] "addrPos") (![#uint64T] (struct.field_ref #Update #"Addr"%go "buf")) "$r0")));;;
    return: (mem.alloc (let: "$log" := (![#sliceT] "log") in
     let: "$start" := (![#LogPosition] "start") in
     let: "$mutable" := ((![#LogPosition] "start") + (s_to_w64 (let: "$a0" := (![#sliceT] "log") in
     slice.len "$a0"))) in
     let: "$addrPos" := (![type.mapT #uint64T #LogPosition] "addrPos") in
     struct.make #sliding [{
       "log" ::= "$log";
       "start" ::= "$start";
       "mutable" ::= "$mutable";
       "needFlush" ::= type.zero_val #boolT;
       "addrPos" ::= "$addrPos"
     }]))).

(* go: 0sliding.go:29:19 *)
Definition sliding__end : val :=
  rec: "sliding__end" "s" <> :=
    exception_do (let: "s" := (mem.alloc "s") in
    return: ((![#LogPosition] (struct.field_ref #sliding #"start"%go (![#ptrT] "s"))) + (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref #sliding #"log"%go (![#ptrT] "s"))) in
     slice.len "$a0")))).

(* go: 0sliding.go:33:19 *)
Definition sliding__get : val :=
  rec: "sliding__get" "s" "pos" :=
    exception_do (let: "s" := (mem.alloc "s") in
    let: "pos" := (mem.alloc "pos") in
    return: (![#Update] (slice.elem_ref #Update (![#sliceT] (struct.field_ref #sliding #"log"%go (![#ptrT] "s"))) ((![#LogPosition] "pos") - (![#LogPosition] (struct.field_ref #sliding #"start"%go (![#ptrT] "s"))))))).

(* go: 0sliding.go:37:19 *)
Definition sliding__posForAddr : val :=
  rec: "sliding__posForAddr" "s" "a" :=
    exception_do (let: "s" := (mem.alloc "s") in
    let: "a" := (mem.alloc "a") in
    let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "pos" := (mem.alloc (type.zero_val #LogPosition)) in
    let: ("$ret0", "$ret1") := (map.get (![type.mapT #uint64T #LogPosition] (struct.field_ref #sliding #"addrPos"%go (![#ptrT] "s"))) (![#uint64T] "a")) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("pos" <-[#LogPosition] "$r0");;;
    do:  ("ok" <-[#boolT] "$r1");;;
    return: (![#LogPosition] "pos", ![#boolT] "ok")).

(* update does an in-place absorb of an update to u

   internal to sliding

   go: 0sliding.go:45:19 *)
Definition sliding__update : val :=
  rec: "sliding__update" "s" "pos" "u" :=
    exception_do (let: "s" := (mem.alloc "s") in
    let: "u" := (mem.alloc "u") in
    let: "pos" := (mem.alloc "pos") in
    let: "$r0" := (![#Update] "u") in
    do:  ((slice.elem_ref #Update (let: "$s" := (![#sliceT] (struct.field_ref #sliding #"log"%go (![#ptrT] "s"))) in
    slice.slice #Update "$s" ((![#LogPosition] (struct.field_ref #sliding #"mutable"%go (![#ptrT] "s"))) - (![#LogPosition] (struct.field_ref #sliding #"start"%go (![#ptrT] "s")))) (slice.len "$s")) ((![#LogPosition] "pos") - (![#LogPosition] (struct.field_ref #sliding #"mutable"%go (![#ptrT] "s"))))) <-[#Update] "$r0");;;
    return: #()).

(* append writes an update that cannot be absorbed

   internal to sliding

   go: 0sliding.go:52:19 *)
Definition sliding__append : val :=
  rec: "sliding__append" "s" "u" :=
    exception_do (let: "s" := (mem.alloc "s") in
    let: "u" := (mem.alloc "u") in
    let: "pos" := (mem.alloc (type.zero_val #LogPosition)) in
    let: "$r0" := ((![#LogPosition] (struct.field_ref #sliding #"start"%go (![#ptrT] "s"))) + (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref #sliding #"log"%go (![#ptrT] "s"))) in
    slice.len "$a0"))) in
    do:  ("pos" <-[#LogPosition] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#sliceT] (struct.field_ref #sliding #"log"%go (![#ptrT] "s"))) in
    let: "$a1" := ((let: "$sl0" := (![#Update] "u") in
    slice.literal #Update ["$sl0"])) in
    (slice.append #Update) "$a0" "$a1") in
    do:  ((struct.field_ref #sliding #"log"%go (![#ptrT] "s")) <-[#sliceT] "$r0");;;
    let: "$r0" := (![#LogPosition] "pos") in
    do:  (map.insert (![type.mapT #uint64T #LogPosition] (struct.field_ref #sliding #"addrPos"%go (![#ptrT] "s"))) (![#uint64T] (struct.field_ref #Update #"Addr"%go "u")) "$r0");;;
    return: #()).

(* Absorbs writes in in-memory transactions (avoiding those that might be in
   the process of being logged or installed).

   Assumes caller holds memLock

   go: 0sliding.go:62:19 *)
Definition sliding__memWrite : val :=
  rec: "sliding__memWrite" "s" "bufs" :=
    exception_do (let: "s" := (mem.alloc "s") in
    let: "bufs" := (mem.alloc "bufs") in
    let: "pos" := (mem.alloc (type.zero_val #LogPosition)) in
    let: "$r0" := ((method_call #wal.wal #"sliding'ptr" #"end" (![#ptrT] "s")) #()) in
    do:  ("pos" <-[#LogPosition] "$r0");;;
    let: "$range" := (![#sliceT] "bufs") in
    (let: "buf" := (mem.alloc (type.zero_val #Update)) in
    slice.for_range #Update "$range" (λ: "$key" "$value",
      do:  ("buf" <-[#Update] "$value");;;
      do:  "$key";;;
      let: "ok" := (mem.alloc (type.zero_val #boolT)) in
      let: "oldpos" := (mem.alloc (type.zero_val #LogPosition)) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![#uint64T] (struct.field_ref #Update #"Addr"%go "buf")) in
      (method_call #wal.wal #"sliding'ptr" #"posForAddr" (![#ptrT] "s")) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("oldpos" <-[#LogPosition] "$r0");;;
      do:  ("ok" <-[#boolT] "$r1");;;
      (if: (![#boolT] "ok") && ((![#LogPosition] "oldpos") ≥ (![#LogPosition] (struct.field_ref #sliding #"mutable"%go (![#ptrT] "s"))))
      then
        do:  (let: "$a0" := #(W64 5) in
        let: "$a1" := #"memWrite: absorb %d pos %d old %d
        "%go in
        let: "$a2" := ((let: "$sl0" := (interface.make #""%go #"uint64"%go (![#uint64T] (struct.field_ref #Update #"Addr"%go "buf"))) in
        let: "$sl1" := (interface.make #wal.wal #"LogPosition" (![#LogPosition] "pos")) in
        let: "$sl2" := (interface.make #wal.wal #"LogPosition" (![#LogPosition] "oldpos")) in
        slice.literal #interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
        (func_call #util.util #"DPrintf"%go) "$a0" "$a1" "$a2");;;
        do:  (let: "$a0" := (![#LogPosition] "oldpos") in
        let: "$a1" := (![#Update] "buf") in
        (method_call #wal.wal #"sliding'ptr" #"update" (![#ptrT] "s")) "$a0" "$a1")
      else
        (if: ![#boolT] "ok"
        then
          do:  (let: "$a0" := #(W64 5) in
          let: "$a1" := #"memLogMap: replace %d pos %d old %d
          "%go in
          let: "$a2" := ((let: "$sl0" := (interface.make #""%go #"uint64"%go (![#uint64T] (struct.field_ref #Update #"Addr"%go "buf"))) in
          let: "$sl1" := (interface.make #wal.wal #"LogPosition" (![#LogPosition] "pos")) in
          let: "$sl2" := (interface.make #wal.wal #"LogPosition" (![#LogPosition] "oldpos")) in
          slice.literal #interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
          (func_call #util.util #"DPrintf"%go) "$a0" "$a1" "$a2")
        else
          do:  (let: "$a0" := #(W64 5) in
          let: "$a1" := #"memLogMap: add %d pos %d
          "%go in
          let: "$a2" := ((let: "$sl0" := (interface.make #""%go #"uint64"%go (![#uint64T] (struct.field_ref #Update #"Addr"%go "buf"))) in
          let: "$sl1" := (interface.make #wal.wal #"LogPosition" (![#LogPosition] "pos")) in
          slice.literal #interfaceT ["$sl0"; "$sl1"])) in
          (func_call #util.util #"DPrintf"%go) "$a0" "$a1" "$a2"));;;
        do:  (let: "$a0" := (![#Update] "buf") in
        (method_call #wal.wal #"sliding'ptr" #"append" (![#ptrT] "s")) "$a0");;;
        do:  ("pos" <-[#LogPosition] ((![#LogPosition] "pos") + #(W64 1))))));;;
    return: #()).

(* takeFrom takes the read-only updates from a logical start position to the
   current mutable boundary

   go: 0sliding.go:88:19 *)
Definition sliding__takeFrom : val :=
  rec: "sliding__takeFrom" "s" "start" :=
    exception_do (let: "s" := (mem.alloc "s") in
    let: "start" := (mem.alloc "start") in
    return: (let: "$s" := (let: "$s" := (![#sliceT] (struct.field_ref #sliding #"log"%go (![#ptrT] "s"))) in
     slice.slice #Update "$s" #(W64 0) ((![#LogPosition] (struct.field_ref #sliding #"mutable"%go (![#ptrT] "s"))) - (![#LogPosition] (struct.field_ref #sliding #"start"%go (![#ptrT] "s"))))) in
     slice.slice #Update "$s" ((![#LogPosition] "start") - (![#LogPosition] (struct.field_ref #sliding #"start"%go (![#ptrT] "s")))) (slice.len "$s"))).

(* takeTill takes the read-only updates till a logical start position (which
   should be within the read-only region; that is, end <= s.mutable)

   go: 0sliding.go:94:19 *)
Definition sliding__takeTill : val :=
  rec: "sliding__takeTill" "s" "end" :=
    exception_do (let: "s" := (mem.alloc "s") in
    let: "end" := (mem.alloc "end") in
    return: (let: "$s" := (let: "$s" := (![#sliceT] (struct.field_ref #sliding #"log"%go (![#ptrT] "s"))) in
     slice.slice #Update "$s" #(W64 0) ((![#LogPosition] (struct.field_ref #sliding #"mutable"%go (![#ptrT] "s"))) - (![#LogPosition] (struct.field_ref #sliding #"start"%go (![#ptrT] "s"))))) in
     slice.slice #Update "$s" #(W64 0) ((![#LogPosition] "end") - (![#LogPosition] (struct.field_ref #sliding #"start"%go (![#ptrT] "s")))))).

(* go: 0sliding.go:98:19 *)
Definition sliding__intoMutable : val :=
  rec: "sliding__intoMutable" "s" <> :=
    exception_do (let: "s" := (mem.alloc "s") in
    return: (let: "$s" := (![#sliceT] (struct.field_ref #sliding #"log"%go (![#ptrT] "s"))) in
     slice.slice #Update "$s" ((![#LogPosition] (struct.field_ref #sliding #"mutable"%go (![#ptrT] "s"))) - (![#LogPosition] (struct.field_ref #sliding #"start"%go (![#ptrT] "s")))) (slice.len "$s"))).

(* deleteFrom deletes read-only updates up to newStart,
   correctly updating the start position

   go: 0sliding.go:104:19 *)
Definition sliding__deleteFrom : val :=
  rec: "sliding__deleteFrom" "s" "newStart" :=
    exception_do (let: "s" := (mem.alloc "s") in
    let: "newStart" := (mem.alloc "newStart") in
    let: "start" := (mem.alloc (type.zero_val #LogPosition)) in
    let: "$r0" := (![#LogPosition] (struct.field_ref #sliding #"start"%go (![#ptrT] "s"))) in
    do:  ("start" <-[#LogPosition] "$r0");;;
    let: "$range" := (let: "$s" := (let: "$s" := (![#sliceT] (struct.field_ref #sliding #"log"%go (![#ptrT] "s"))) in
    slice.slice #Update "$s" #(W64 0) ((![#LogPosition] (struct.field_ref #sliding #"mutable"%go (![#ptrT] "s"))) - (![#LogPosition] "start"))) in
    slice.slice #Update "$s" #(W64 0) ((![#LogPosition] "newStart") - (![#LogPosition] "start"))) in
    (let: "u" := (mem.alloc (type.zero_val #Update)) in
    let: "i" := (mem.alloc (type.zero_val #intT)) in
    slice.for_range #Update "$range" (λ: "$key" "$value",
      do:  ("u" <-[#Update] "$value");;;
      do:  ("i" <-[#intT] "$key");;;
      let: "pos" := (mem.alloc (type.zero_val #LogPosition)) in
      let: "$r0" := ((![#LogPosition] "start") + (s_to_w64 (![#intT] "i"))) in
      do:  ("pos" <-[#LogPosition] "$r0");;;
      let: "blkno" := (mem.alloc (type.zero_val #uint64T)) in
      let: "$r0" := (![#uint64T] (struct.field_ref #Update #"Addr"%go "u")) in
      do:  ("blkno" <-[#uint64T] "$r0");;;
      let: "ok" := (mem.alloc (type.zero_val #boolT)) in
      let: "oldPos" := (mem.alloc (type.zero_val #LogPosition)) in
      let: ("$ret0", "$ret1") := (map.get (![type.mapT #uint64T #LogPosition] (struct.field_ref #sliding #"addrPos"%go (![#ptrT] "s"))) (![#uint64T] "blkno")) in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("oldPos" <-[#LogPosition] "$r0");;;
      do:  ("ok" <-[#boolT] "$r1");;;
      (if: (![#boolT] "ok") && ((![#LogPosition] "oldPos") ≤ (![#LogPosition] "pos"))
      then
        do:  (let: "$a0" := #(W64 5) in
        let: "$a1" := #"memLogMap: del %d %d
        "%go in
        let: "$a2" := ((let: "$sl0" := (interface.make #""%go #"uint64"%go (![#uint64T] "blkno")) in
        let: "$sl1" := (interface.make #wal.wal #"LogPosition" (![#LogPosition] "oldPos")) in
        slice.literal #interfaceT ["$sl0"; "$sl1"])) in
        (func_call #util.util #"DPrintf"%go) "$a0" "$a1" "$a2");;;
        do:  (let: "$a0" := (![type.mapT #uint64T #LogPosition] (struct.field_ref #sliding #"addrPos"%go (![#ptrT] "s"))) in
        let: "$a1" := (![#uint64T] "blkno") in
        map.delete "$a0" "$a1")
      else do:  #())));;;
    let: "$r0" := (let: "$s" := (![#sliceT] (struct.field_ref #sliding #"log"%go (![#ptrT] "s"))) in
    slice.slice #Update "$s" ((![#LogPosition] "newStart") - (![#LogPosition] "start")) (slice.len "$s")) in
    do:  ((struct.field_ref #sliding #"log"%go (![#ptrT] "s")) <-[#sliceT] "$r0");;;
    let: "$r0" := (![#LogPosition] "newStart") in
    do:  ((struct.field_ref #sliding #"start"%go (![#ptrT] "s")) <-[#LogPosition] "$r0");;;
    return: #()).

(* go: 0sliding.go:119:19 *)
Definition sliding__clearMutable : val :=
  rec: "sliding__clearMutable" "s" <> :=
    exception_do (let: "s" := (mem.alloc "s") in
    let: "$r0" := ((method_call #wal.wal #"sliding'ptr" #"end" (![#ptrT] "s")) #()) in
    do:  ((struct.field_ref #sliding #"mutable"%go (![#ptrT] "s")) <-[#LogPosition] "$r0");;;
    return: #()).

Definition WalogState : go_type := structT [
  "memLog" :: ptrT;
  "diskEnd" :: LogPosition;
  "shutdown" :: boolT;
  "nthread" :: uint64T
].

(* go: 0waldefs.go:20:23 *)
Definition WalogState__memEnd : val :=
  rec: "WalogState__memEnd" "st" <> :=
    exception_do (let: "st" := (mem.alloc "st") in
    return: ((method_call #wal.wal #"sliding'ptr" #"end" (![#ptrT] (struct.field_ref #WalogState #"memLog"%go (![#ptrT] "st")))) #())).

Definition Walog : go_type := structT [
  "memLock" :: ptrT;
  "d" :: disk.Disk;
  "circ" :: ptrT;
  "st" :: ptrT;
  "condLogger" :: ptrT;
  "condInstall" :: ptrT;
  "condShut" :: ptrT
].

(* go: 0waldefs.go:37:17 *)
Definition Walog__LogSz : val :=
  rec: "Walog__LogSz" "l" <> :=
    exception_do (let: "l" := (mem.alloc "l") in
    return: (common.HDRADDRS)).

(* cutMemLog deletes from the memLog through installEnd, after these blocks have
   been installed. This transitions from a state where the on-disk install point
   is already at installEnd, but memStart < installEnd.

   Assumes caller holds memLock

   go: installer.go:14:23 *)
Definition WalogState__cutMemLog : val :=
  rec: "WalogState__cutMemLog" "st" "installEnd" :=
    exception_do (let: "st" := (mem.alloc "st") in
    let: "installEnd" := (mem.alloc "installEnd") in
    do:  (let: "$a0" := (![#LogPosition] "installEnd") in
    (method_call #wal.wal #"sliding'ptr" #"deleteFrom" (![#ptrT] (struct.field_ref #WalogState #"memLog"%go (![#ptrT] "st")))) "$a0");;;
    return: #()).

(* absorbBufs returns bufs' such that applyUpds(d, bufs') = applyUpds(d,
   bufs) and bufs' has unique addresses

   go: installer.go:20:6 *)
Definition absorbBufs : val :=
  rec: "absorbBufs" "bufs" :=
    exception_do (let: "bufs" := (mem.alloc "bufs") in
    let: "s" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := #slice.nil in
    let: "$a1" := #(W64 0) in
    (func_call #wal.wal #"mkSliding"%go) "$a0" "$a1") in
    do:  ("s" <-[#ptrT] "$r0");;;
    do:  (let: "$a0" := (![#sliceT] "bufs") in
    (method_call #wal.wal #"sliding'ptr" #"memWrite" (![#ptrT] "s")) "$a0");;;
    return: ((method_call #wal.wal #"sliding'ptr" #"intoMutable" (![#ptrT] "s")) #())).

(* installBlocks installs the updates in bufs to the data region

   Does not hold the memLock. De-duplicates writes in bufs such that:
   (1) after installBlocks,
   the equivalent of applying bufs in order is accomplished
   (2) at all intermediate points,
   the data region either has the value from the old transaction or the new
   transaction (with all of bufs applied).

   go: installer.go:34:6 *)
Definition installBlocks : val :=
  rec: "installBlocks" "d" "bufs" :=
    exception_do (let: "bufs" := (mem.alloc "bufs") in
    let: "d" := (mem.alloc "d") in
    let: "$range" := (![#sliceT] "bufs") in
    (let: "buf" := (mem.alloc (type.zero_val #Update)) in
    let: "i" := (mem.alloc (type.zero_val #intT)) in
    slice.for_range #Update "$range" (λ: "$key" "$value",
      do:  ("buf" <-[#Update] "$value");;;
      do:  ("i" <-[#intT] "$key");;;
      let: "blkno" := (mem.alloc (type.zero_val #uint64T)) in
      let: "$r0" := (![#uint64T] (struct.field_ref #Update #"Addr"%go "buf")) in
      do:  ("blkno" <-[#uint64T] "$r0");;;
      let: "blk" := (mem.alloc (type.zero_val #sliceT)) in
      let: "$r0" := (![#sliceT] (struct.field_ref #Update #"Block"%go "buf")) in
      do:  ("blk" <-[#sliceT] "$r0");;;
      do:  (let: "$a0" := #(W64 5) in
      let: "$a1" := #"installBlocks: write log block %d to %d
      "%go in
      let: "$a2" := ((let: "$sl0" := (interface.make #""%go #"int"%go (![#intT] "i")) in
      let: "$sl1" := (interface.make #""%go #"uint64"%go (![#uint64T] "blkno")) in
      slice.literal #interfaceT ["$sl0"; "$sl1"])) in
      (func_call #util.util #"DPrintf"%go) "$a0" "$a1" "$a2");;;
      do:  (let: "$a0" := (![#uint64T] "blkno") in
      let: "$a1" := (![#sliceT] "blk") in
      (interface.get #"Write"%go (![#disk.Disk] "d")) "$a0" "$a1")));;;
    return: #()).

(* logInstall installs one on-disk transaction from the disk log to the data
   region.

   Returns (blkCount, installEnd)

   blkCount is the number of blocks installed (only used for liveness)

   installEnd is the new last position installed to the data region (only used
   for debugging)

   Installer holds memLock

   go: installer.go:54:17 *)
Definition Walog__logInstall : val :=
  rec: "Walog__logInstall" "l" <> :=
    exception_do (let: "l" := (mem.alloc "l") in
    let: "installEnd" := (mem.alloc (type.zero_val #LogPosition)) in
    let: "$r0" := (![#LogPosition] (struct.field_ref #WalogState #"diskEnd"%go (![#ptrT] (struct.field_ref #Walog #"st"%go (![#ptrT] "l"))))) in
    do:  ("installEnd" <-[#LogPosition] "$r0");;;
    let: "bufs" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#LogPosition] "installEnd") in
    (method_call #wal.wal #"sliding'ptr" #"takeTill" (![#ptrT] (struct.field_ref #WalogState #"memLog"%go (![#ptrT] (struct.field_ref #Walog #"st"%go (![#ptrT] "l")))))) "$a0") in
    do:  ("bufs" <-[#sliceT] "$r0");;;
    let: "numBufs" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (s_to_w64 (let: "$a0" := (![#sliceT] "bufs") in
    slice.len "$a0")) in
    do:  ("numBufs" <-[#uint64T] "$r0");;;
    (if: (![#uint64T] "numBufs") = #(W64 0)
    then return: (#(W64 0), ![#LogPosition] "installEnd")
    else do:  #());;;
    do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Walog #"memLock"%go (![#ptrT] "l")))) #());;;
    do:  (let: "$a0" := #(W64 5) in
    let: "$a1" := #"logInstall up to %d
    "%go in
    let: "$a2" := ((let: "$sl0" := (interface.make #wal.wal #"LogPosition" (![#LogPosition] "installEnd")) in
    slice.literal #interfaceT ["$sl0"])) in
    (func_call #util.util #"DPrintf"%go) "$a0" "$a1" "$a2");;;
    do:  (let: "$a0" := (![#disk.Disk] (struct.field_ref #Walog #"d"%go (![#ptrT] "l"))) in
    let: "$a1" := (![#sliceT] "bufs") in
    (func_call #wal.wal #"installBlocks"%go) "$a0" "$a1");;;
    do:  ((interface.get #"Barrier"%go (![#disk.Disk] (struct.field_ref #Walog #"d"%go (![#ptrT] "l")))) #());;;
    do:  (let: "$a0" := (![#disk.Disk] (struct.field_ref #Walog #"d"%go (![#ptrT] "l"))) in
    let: "$a1" := (![#LogPosition] "installEnd") in
    (func_call #wal.wal #"Advance"%go) "$a0" "$a1");;;
    do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref #Walog #"memLock"%go (![#ptrT] "l")))) #());;;
    do:  (let: "$a0" := (![#LogPosition] "installEnd") in
    (method_call #wal.wal #"WalogState'ptr" #"cutMemLog" (![#ptrT] (struct.field_ref #Walog #"st"%go (![#ptrT] "l")))) "$a0");;;
    do:  ((method_call #sync #"Cond'ptr" #"Broadcast" (![#ptrT] (struct.field_ref #Walog #"condInstall"%go (![#ptrT] "l")))) #());;;
    return: (![#uint64T] "numBufs", ![#LogPosition] "installEnd")).

(* installer installs blocks from the on-disk log to their home location.

   go: installer.go:77:17 *)
Definition Walog__installer : val :=
  rec: "Walog__installer" "l" <> :=
    exception_do (let: "l" := (mem.alloc "l") in
    do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref #Walog #"memLock"%go (![#ptrT] "l")))) #());;;
    do:  ((struct.field_ref #WalogState #"nthread"%go (![#ptrT] (struct.field_ref #Walog #"st"%go (![#ptrT] "l")))) <-[#uint64T] ((![#uint64T] (struct.field_ref #WalogState #"nthread"%go (![#ptrT] (struct.field_ref #Walog #"st"%go (![#ptrT] "l"))))) + #(W64 1)));;;
    (for: (λ: <>, (~ (![#boolT] (struct.field_ref #WalogState #"shutdown"%go (![#ptrT] (struct.field_ref #Walog #"st"%go (![#ptrT] "l"))))))); (λ: <>, Skip) := λ: <>,
      let: "txn" := (mem.alloc (type.zero_val #LogPosition)) in
      let: "blkcount" := (mem.alloc (type.zero_val #uint64T)) in
      let: ("$ret0", "$ret1") := ((method_call #wal.wal #"Walog'ptr" #"logInstall" (![#ptrT] "l")) #()) in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("blkcount" <-[#uint64T] "$r0");;;
      do:  ("txn" <-[#LogPosition] "$r1");;;
      (if: (![#uint64T] "blkcount") > #(W64 0)
      then
        do:  (let: "$a0" := #(W64 5) in
        let: "$a1" := #"Installed till txn %d
        "%go in
        let: "$a2" := ((let: "$sl0" := (interface.make #wal.wal #"LogPosition" (![#LogPosition] "txn")) in
        slice.literal #interfaceT ["$sl0"])) in
        (func_call #util.util #"DPrintf"%go) "$a0" "$a1" "$a2")
      else do:  ((method_call #sync #"Cond'ptr" #"Wait" (![#ptrT] (struct.field_ref #Walog #"condInstall"%go (![#ptrT] "l")))) #())));;;
    do:  (let: "$a0" := #(W64 1) in
    let: "$a1" := #"installer: shutdown
    "%go in
    let: "$a2" := #slice.nil in
    (func_call #util.util #"DPrintf"%go) "$a0" "$a1" "$a2");;;
    do:  ((struct.field_ref #WalogState #"nthread"%go (![#ptrT] (struct.field_ref #Walog #"st"%go (![#ptrT] "l")))) <-[#uint64T] ((![#uint64T] (struct.field_ref #WalogState #"nthread"%go (![#ptrT] (struct.field_ref #Walog #"st"%go (![#ptrT] "l"))))) - #(W64 1)));;;
    do:  ((method_call #sync #"Cond'ptr" #"Signal" (![#ptrT] (struct.field_ref #Walog #"condShut"%go (![#ptrT] "l")))) #());;;
    do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Walog #"memLock"%go (![#ptrT] "l")))) #());;;
    return: #()).

(* Waits on the installer thread to free space in the log so everything
   logged fits on disk.

   establishes uint64(len(l.memLog)) <= LOGSZ

   go: logger.go:12:17 *)
Definition Walog__waitForSpace : val :=
  rec: "Walog__waitForSpace" "l" <> :=
    exception_do (let: "l" := (mem.alloc "l") in
    (for: (λ: <>, (s_to_w64 (let: "$a0" := (![#sliceT] (struct.field_ref #sliding #"log"%go (![#ptrT] (struct.field_ref #WalogState #"memLog"%go (![#ptrT] (struct.field_ref #Walog #"st"%go (![#ptrT] "l"))))))) in
    slice.len "$a0")) > LOGSZ); (λ: <>, Skip) := λ: <>,
      do:  ((method_call #sync #"Cond'ptr" #"Wait" (![#ptrT] (struct.field_ref #Walog #"condInstall"%go (![#ptrT] "l")))) #()));;;
    return: #()).

(* go: logger.go:20:17 *)
Definition Walog__flushIfNeeded : val :=
  rec: "Walog__flushIfNeeded" "l" <> :=
    exception_do (let: "l" := (mem.alloc "l") in
    (if: ![#boolT] (struct.field_ref #sliding #"needFlush"%go (![#ptrT] (struct.field_ref #WalogState #"memLog"%go (![#ptrT] (struct.field_ref #Walog #"st"%go (![#ptrT] "l"))))))
    then
      do:  ((method_call #wal.wal #"sliding'ptr" #"clearMutable" (![#ptrT] (struct.field_ref #WalogState #"memLog"%go (![#ptrT] (struct.field_ref #Walog #"st"%go (![#ptrT] "l")))))) #());;;
      let: "$r0" := #false in
      do:  ((struct.field_ref #sliding #"needFlush"%go (![#ptrT] (struct.field_ref #WalogState #"memLog"%go (![#ptrT] (struct.field_ref #Walog #"st"%go (![#ptrT] "l")))))) <-[#boolT] "$r0")
    else do:  #());;;
    return: #()).

(* logAppend appends to the log, if it can find transactions to append.

   It grabs the new writes in memory and not on disk through l.nextDiskEnd; if
   there are any such writes, it commits them atomically.

   assumes caller holds memLock

   Returns true if it made progress (for liveness, not important for
   correctness).

   go: logger.go:36:17 *)
Definition Walog__logAppend : val :=
  rec: "Walog__logAppend" "l" "circ" :=
    exception_do (let: "l" := (mem.alloc "l") in
    let: "circ" := (mem.alloc "circ") in
    do:  ((method_call #wal.wal #"Walog'ptr" #"waitForSpace" (![#ptrT] "l")) #());;;
    do:  ((method_call #wal.wal #"Walog'ptr" #"flushIfNeeded" (![#ptrT] "l")) #());;;
    let: "diskEnd" := (mem.alloc (type.zero_val #LogPosition)) in
    let: "$r0" := (![#LogPosition] (struct.field_ref #WalogState #"diskEnd"%go (![#ptrT] (struct.field_ref #Walog #"st"%go (![#ptrT] "l"))))) in
    do:  ("diskEnd" <-[#LogPosition] "$r0");;;
    let: "newbufs" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#LogPosition] "diskEnd") in
    (method_call #wal.wal #"sliding'ptr" #"takeFrom" (![#ptrT] (struct.field_ref #WalogState #"memLog"%go (![#ptrT] (struct.field_ref #Walog #"st"%go (![#ptrT] "l")))))) "$a0") in
    do:  ("newbufs" <-[#sliceT] "$r0");;;
    (if: (let: "$a0" := (![#sliceT] "newbufs") in
    slice.len "$a0") = #(W64 0)
    then return: (#false)
    else do:  #());;;
    do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Walog #"memLock"%go (![#ptrT] "l")))) #());;;
    do:  (let: "$a0" := (![#disk.Disk] (struct.field_ref #Walog #"d"%go (![#ptrT] "l"))) in
    let: "$a1" := (![#LogPosition] "diskEnd") in
    let: "$a2" := (![#sliceT] "newbufs") in
    (method_call #wal.wal #"circularAppender'ptr" #"Append" (![#ptrT] "circ")) "$a0" "$a1" "$a2");;;
    do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref #Walog #"memLock"%go (![#ptrT] "l")))) #());;;
    do:  ((func_call #primitive.primitive #"Linearize"%go) #());;;
    let: "$r0" := ((![#LogPosition] "diskEnd") + (s_to_w64 (let: "$a0" := (![#sliceT] "newbufs") in
    slice.len "$a0"))) in
    do:  ((struct.field_ref #WalogState #"diskEnd"%go (![#ptrT] (struct.field_ref #Walog #"st"%go (![#ptrT] "l")))) <-[#LogPosition] "$r0");;;
    do:  ((method_call #sync #"Cond'ptr" #"Broadcast" (![#ptrT] (struct.field_ref #Walog #"condLogger"%go (![#ptrT] "l")))) #());;;
    do:  ((method_call #sync #"Cond'ptr" #"Broadcast" (![#ptrT] (struct.field_ref #Walog #"condInstall"%go (![#ptrT] "l")))) #());;;
    return: (#true)).

(* logger writes blocks from the in-memory log to the on-disk log

   Operates by continuously polling for in-memory transactions, driven by
   condLogger for scheduling

   go: logger.go:64:17 *)
Definition Walog__logger : val :=
  rec: "Walog__logger" "l" "circ" :=
    exception_do (let: "l" := (mem.alloc "l") in
    let: "circ" := (mem.alloc "circ") in
    do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref #Walog #"memLock"%go (![#ptrT] "l")))) #());;;
    do:  ((struct.field_ref #WalogState #"nthread"%go (![#ptrT] (struct.field_ref #Walog #"st"%go (![#ptrT] "l")))) <-[#uint64T] ((![#uint64T] (struct.field_ref #WalogState #"nthread"%go (![#ptrT] (struct.field_ref #Walog #"st"%go (![#ptrT] "l"))))) + #(W64 1)));;;
    (for: (λ: <>, (~ (![#boolT] (struct.field_ref #WalogState #"shutdown"%go (![#ptrT] (struct.field_ref #Walog #"st"%go (![#ptrT] "l"))))))); (λ: <>, Skip) := λ: <>,
      let: "progress" := (mem.alloc (type.zero_val #boolT)) in
      let: "$r0" := (let: "$a0" := (![#ptrT] "circ") in
      (method_call #wal.wal #"Walog'ptr" #"logAppend" (![#ptrT] "l")) "$a0") in
      do:  ("progress" <-[#boolT] "$r0");;;
      (if: (~ (![#boolT] "progress"))
      then do:  ((method_call #sync #"Cond'ptr" #"Wait" (![#ptrT] (struct.field_ref #Walog #"condLogger"%go (![#ptrT] "l")))) #())
      else do:  #()));;;
    do:  (let: "$a0" := #(W64 1) in
    let: "$a1" := #"logger: shutdown
    "%go in
    let: "$a2" := #slice.nil in
    (func_call #util.util #"DPrintf"%go) "$a0" "$a1" "$a2");;;
    do:  ((struct.field_ref #WalogState #"nthread"%go (![#ptrT] (struct.field_ref #Walog #"st"%go (![#ptrT] "l")))) <-[#uint64T] ((![#uint64T] (struct.field_ref #WalogState #"nthread"%go (![#ptrT] (struct.field_ref #Walog #"st"%go (![#ptrT] "l"))))) - #(W64 1)));;;
    do:  ((method_call #sync #"Cond'ptr" #"Signal" (![#ptrT] (struct.field_ref #Walog #"condShut"%go (![#ptrT] "l")))) #());;;
    do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Walog #"memLock"%go (![#ptrT] "l")))) #());;;
    return: #()).

(* go: wal.go:14:6 *)
Definition mkLog : val :=
  rec: "mkLog" "disk" :=
    exception_do (let: "disk" := (mem.alloc "disk") in
    let: "memLog" := (mem.alloc (type.zero_val #sliceT)) in
    let: "end" := (mem.alloc (type.zero_val #LogPosition)) in
    let: "start" := (mem.alloc (type.zero_val #LogPosition)) in
    let: "circ" := (mem.alloc (type.zero_val #ptrT)) in
    let: ((("$ret0", "$ret1"), "$ret2"), "$ret3") := (let: "$a0" := (![#disk.Disk] "disk") in
    (func_call #wal.wal #"recoverCircular"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    let: "$r3" := "$ret3" in
    do:  ("circ" <-[#ptrT] "$r0");;;
    do:  ("start" <-[#LogPosition] "$r1");;;
    do:  ("end" <-[#LogPosition] "$r2");;;
    do:  ("memLog" <-[#sliceT] "$r3");;;
    let: "ml" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (type.zero_val #sync.Mutex)) in
    do:  ("ml" <-[#ptrT] "$r0");;;
    let: "st" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (let: "$memLog" := (let: "$a0" := (![#sliceT] "memLog") in
    let: "$a1" := (![#LogPosition] "start") in
    (func_call #wal.wal #"mkSliding"%go) "$a0" "$a1") in
    let: "$diskEnd" := (![#LogPosition] "end") in
    let: "$shutdown" := #false in
    let: "$nthread" := #(W64 0) in
    struct.make #WalogState [{
      "memLog" ::= "$memLog";
      "diskEnd" ::= "$diskEnd";
      "shutdown" ::= "$shutdown";
      "nthread" ::= "$nthread"
    }])) in
    do:  ("st" <-[#ptrT] "$r0");;;
    let: "l" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (let: "$d" := (![#disk.Disk] "disk") in
    let: "$circ" := (![#ptrT] "circ") in
    let: "$memLock" := (![#ptrT] "ml") in
    let: "$st" := (![#ptrT] "st") in
    let: "$condLogger" := (let: "$a0" := (interface.make #sync #"Mutex'ptr" (![#ptrT] "ml")) in
    (func_call #sync.sync #"NewCond"%go) "$a0") in
    let: "$condInstall" := (let: "$a0" := (interface.make #sync #"Mutex'ptr" (![#ptrT] "ml")) in
    (func_call #sync.sync #"NewCond"%go) "$a0") in
    let: "$condShut" := (let: "$a0" := (interface.make #sync #"Mutex'ptr" (![#ptrT] "ml")) in
    (func_call #sync.sync #"NewCond"%go) "$a0") in
    struct.make #Walog [{
      "memLock" ::= "$memLock";
      "d" ::= "$d";
      "circ" ::= "$circ";
      "st" ::= "$st";
      "condLogger" ::= "$condLogger";
      "condInstall" ::= "$condInstall";
      "condShut" ::= "$condShut"
    }])) in
    do:  ("l" <-[#ptrT] "$r0");;;
    do:  (let: "$a0" := #(W64 1) in
    let: "$a1" := #"mkLog: size %d
    "%go in
    let: "$a2" := ((let: "$sl0" := (interface.make #""%go #"uint64"%go LOGSZ) in
    slice.literal #interfaceT ["$sl0"])) in
    (func_call #util.util #"DPrintf"%go) "$a0" "$a1" "$a2");;;
    return: (![#ptrT] "l")).

(* go: wal.go:36:17 *)
Definition Walog__startBackgroundThreads : val :=
  rec: "Walog__startBackgroundThreads" "l" <> :=
    exception_do (let: "l" := (mem.alloc "l") in
    let: "$go" := (λ: <>,
      exception_do (do:  (let: "$a0" := (![#ptrT] (struct.field_ref #Walog #"circ"%go (![#ptrT] "l"))) in
      (method_call #wal.wal #"Walog'ptr" #"logger" (![#ptrT] "l")) "$a0");;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    let: "$go" := (λ: <>,
      exception_do (do:  ((method_call #wal.wal #"Walog'ptr" #"installer" (![#ptrT] "l")) #());;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    return: #()).

(* go: wal.go:41:6 *)
Definition MkLog : val :=
  rec: "MkLog" "disk" :=
    exception_do (let: "disk" := (mem.alloc "disk") in
    let: "l" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := (![#disk.Disk] "disk") in
    (func_call #wal.wal #"mkLog"%go) "$a0") in
    do:  ("l" <-[#ptrT] "$r0");;;
    do:  ((method_call #wal.wal #"Walog'ptr" #"startBackgroundThreads" (![#ptrT] "l")) #());;;
    return: (![#ptrT] "l")).

(* Assumes caller holds memLock

   go: wal.go:48:6 *)
Definition doMemAppend : val :=
  rec: "doMemAppend" "memLog" "bufs" :=
    exception_do (let: "bufs" := (mem.alloc "bufs") in
    let: "memLog" := (mem.alloc "memLog") in
    do:  (let: "$a0" := (![#sliceT] "bufs") in
    (method_call #wal.wal #"sliding'ptr" #"memWrite" (![#ptrT] "memLog")) "$a0");;;
    let: "txn" := (mem.alloc (type.zero_val #LogPosition)) in
    let: "$r0" := ((method_call #wal.wal #"sliding'ptr" #"end" (![#ptrT] "memLog")) #()) in
    do:  ("txn" <-[#LogPosition] "$r0");;;
    return: (![#LogPosition] "txn")).

(* Grab all of the current transactions and record them for the next group commit (when the logger gets around to it).

   This is a separate function purely for verification purposes; the code isn't complicated but we have to manipulate
   some ghost state and justify this value of nextDiskEnd.

   Assumes caller holds memLock.

   go: wal.go:60:23 *)
Definition WalogState__endGroupTxn : val :=
  rec: "WalogState__endGroupTxn" "st" <> :=
    exception_do (let: "st" := (mem.alloc "st") in
    let: "$r0" := #true in
    do:  ((struct.field_ref #sliding #"needFlush"%go (![#ptrT] (struct.field_ref #WalogState #"memLog"%go (![#ptrT] "st")))) <-[#boolT] "$r0");;;
    return: #()).

(* go: wal.go:68:6 *)
Definition copyUpdateBlock : val :=
  rec: "copyUpdateBlock" "u" :=
    exception_do (let: "u" := (mem.alloc "u") in
    return: (let: "$a0" := (![#sliceT] (struct.field_ref #Update #"Block"%go "u")) in
     (func_call #util.util #"CloneByteSlice"%go) "$a0")).

(* readMem implements ReadMem, assuming memLock is held

   go: wal.go:73:23 *)
Definition WalogState__readMem : val :=
  rec: "WalogState__readMem" "st" "blkno" :=
    exception_do (let: "st" := (mem.alloc "st") in
    let: "blkno" := (mem.alloc "blkno") in
    let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "pos" := (mem.alloc (type.zero_val #LogPosition)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#uint64T] "blkno") in
    (method_call #wal.wal #"sliding'ptr" #"posForAddr" (![#ptrT] (struct.field_ref #WalogState #"memLog"%go (![#ptrT] "st")))) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("pos" <-[#LogPosition] "$r0");;;
    do:  ("ok" <-[#boolT] "$r1");;;
    (if: ![#boolT] "ok"
    then
      do:  (let: "$a0" := #(W64 5) in
      let: "$a1" := #"read memLogMap: read %d pos %d
      "%go in
      let: "$a2" := ((let: "$sl0" := (interface.make #""%go #"uint64"%go (![#uint64T] "blkno")) in
      let: "$sl1" := (interface.make #wal.wal #"LogPosition" (![#LogPosition] "pos")) in
      slice.literal #interfaceT ["$sl0"; "$sl1"])) in
      (func_call #util.util #"DPrintf"%go) "$a0" "$a1" "$a2");;;
      let: "u" := (mem.alloc (type.zero_val #Update)) in
      let: "$r0" := (let: "$a0" := (![#LogPosition] "pos") in
      (method_call #wal.wal #"sliding'ptr" #"get" (![#ptrT] (struct.field_ref #WalogState #"memLog"%go (![#ptrT] "st")))) "$a0") in
      do:  ("u" <-[#Update] "$r0");;;
      let: "blk" := (mem.alloc (type.zero_val #sliceT)) in
      let: "$r0" := (let: "$a0" := (![#Update] "u") in
      (func_call #wal.wal #"copyUpdateBlock"%go) "$a0") in
      do:  ("blk" <-[#sliceT] "$r0");;;
      return: (![#sliceT] "blk", #true)
    else do:  #());;;
    return: (#slice.nil, #false)).

(* Read from only the in-memory cached state (the unstable and logged parts of
   the wal).

   go: wal.go:86:17 *)
Definition Walog__ReadMem : val :=
  rec: "Walog__ReadMem" "l" "blkno" :=
    exception_do (let: "l" := (mem.alloc "l") in
    let: "blkno" := (mem.alloc "blkno") in
    do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref #Walog #"memLock"%go (![#ptrT] "l")))) #());;;
    let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "blk" := (mem.alloc (type.zero_val #sliceT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#uint64T] "blkno") in
    (method_call #wal.wal #"WalogState'ptr" #"readMem" (![#ptrT] (struct.field_ref #Walog #"st"%go (![#ptrT] "l")))) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("blk" <-[#sliceT] "$r0");;;
    do:  ("ok" <-[#boolT] "$r1");;;
    do:  ((func_call #primitive.primitive #"Linearize"%go) #());;;
    do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Walog #"memLock"%go (![#ptrT] "l")))) #());;;
    return: (![#sliceT] "blk", ![#boolT] "ok")).

(* Read from only the installed state (a subset of durable state).

   go: wal.go:95:17 *)
Definition Walog__ReadInstalled : val :=
  rec: "Walog__ReadInstalled" "l" "blkno" :=
    exception_do (let: "l" := (mem.alloc "l") in
    let: "blkno" := (mem.alloc "blkno") in
    return: (let: "$a0" := (![#uint64T] "blkno") in
     (interface.get #"Read"%go (![#disk.Disk] (struct.field_ref #Walog #"d"%go (![#ptrT] "l")))) "$a0")).

(* Read reads from the latest memory state, but does so in a
   difficult-to-linearize way (specifically, it is future-dependent when to
   linearize between the l.memLog.Unlock() and the eventual disk read, due to
   potential concurrent cache or disk writes).

   go: wal.go:103:17 *)
Definition Walog__Read : val :=
  rec: "Walog__Read" "l" "blkno" :=
    exception_do (let: "l" := (mem.alloc "l") in
    let: "blkno" := (mem.alloc "blkno") in
    let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "blk" := (mem.alloc (type.zero_val #sliceT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#uint64T] "blkno") in
    (method_call #wal.wal #"Walog'ptr" #"ReadMem" (![#ptrT] "l")) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("blk" <-[#sliceT] "$r0");;;
    do:  ("ok" <-[#boolT] "$r1");;;
    (if: ![#boolT] "ok"
    then return: (![#sliceT] "blk")
    else do:  #());;;
    return: (let: "$a0" := (![#uint64T] "blkno") in
     (method_call #wal.wal #"Walog'ptr" #"ReadInstalled" (![#ptrT] "l")) "$a0")).

(* go: wal.go:111:23 *)
Definition WalogState__updatesOverflowU64 : val :=
  rec: "WalogState__updatesOverflowU64" "st" "newUpdates" :=
    exception_do (let: "st" := (mem.alloc "st") in
    let: "newUpdates" := (mem.alloc "newUpdates") in
    return: (let: "$a0" := ((method_call #wal.wal #"WalogState'ptr" #"memEnd" (![#ptrT] "st")) #()) in
     let: "$a1" := (![#uint64T] "newUpdates") in
     (func_call #util.util #"SumOverflows"%go) "$a0" "$a1")).

(* TODO: relate this calculation to the circular log free space

   go: wal.go:116:23 *)
Definition WalogState__memLogHasSpace : val :=
  rec: "WalogState__memLogHasSpace" "st" "newUpdates" :=
    exception_do (let: "st" := (mem.alloc "st") in
    let: "newUpdates" := (mem.alloc "newUpdates") in
    let: "memSize" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (((method_call #wal.wal #"WalogState'ptr" #"memEnd" (![#ptrT] "st")) #()) - (![#LogPosition] (struct.field_ref #WalogState #"diskEnd"%go (![#ptrT] "st")))) in
    do:  ("memSize" <-[#uint64T] "$r0");;;
    (if: ((![#uint64T] "memSize") + (![#uint64T] "newUpdates")) > LOGSZ
    then return: (#false)
    else do:  #());;;
    return: (#true)).

(* Append to in-memory log.

   On success returns the pos for this append.

   On failure guaranteed to be idempotent (failure can only occur in principle,
   due overflowing 2^64 writes)

   go: wal.go:130:17 *)
Definition Walog__MemAppend : val :=
  rec: "Walog__MemAppend" "l" "bufs" :=
    exception_do (let: "l" := (mem.alloc "l") in
    let: "bufs" := (mem.alloc "bufs") in
    (if: (s_to_w64 (let: "$a0" := (![#sliceT] "bufs") in
    slice.len "$a0")) > LOGSZ
    then return: (#(W64 0), #false)
    else do:  #());;;
    let: "txn" := (mem.alloc (type.zero_val #LogPosition)) in
    let: "$r0" := #(W64 0) in
    do:  ("txn" <-[#LogPosition] "$r0");;;
    let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "$r0" := #true in
    do:  ("ok" <-[#boolT] "$r0");;;
    do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref #Walog #"memLock"%go (![#ptrT] "l")))) #());;;
    let: "st" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (![#ptrT] (struct.field_ref #Walog #"st"%go (![#ptrT] "l"))) in
    do:  ("st" <-[#ptrT] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      (if: let: "$a0" := (s_to_w64 (let: "$a0" := (![#sliceT] "bufs") in
      slice.len "$a0")) in
      (method_call #wal.wal #"WalogState'ptr" #"updatesOverflowU64" (![#ptrT] "st")) "$a0"
      then
        let: "$r0" := #false in
        do:  ("ok" <-[#boolT] "$r0");;;
        break: #()
      else do:  #());;;
      (if: let: "$a0" := (s_to_w64 (let: "$a0" := (![#sliceT] "bufs") in
      slice.len "$a0")) in
      (method_call #wal.wal #"WalogState'ptr" #"memLogHasSpace" (![#ptrT] "st")) "$a0"
      then
        let: "$r0" := (let: "$a0" := (![#ptrT] (struct.field_ref #WalogState #"memLog"%go (![#ptrT] "st"))) in
        let: "$a1" := (![#sliceT] "bufs") in
        (func_call #wal.wal #"doMemAppend"%go) "$a0" "$a1") in
        do:  ("txn" <-[#LogPosition] "$r0");;;
        do:  ((func_call #primitive.primitive #"Linearize"%go) #());;;
        break: #()
      else do:  #());;;
      do:  (let: "$a0" := #(W64 5) in
      let: "$a1" := #"memAppend: log is full; try again"%go in
      let: "$a2" := #slice.nil in
      (func_call #util.util #"DPrintf"%go) "$a0" "$a1" "$a2");;;
      do:  ((method_call #wal.wal #"WalogState'ptr" #"endGroupTxn" (![#ptrT] "st")) #());;;
      do:  ((method_call #sync #"Cond'ptr" #"Broadcast" (![#ptrT] (struct.field_ref #Walog #"condLogger"%go (![#ptrT] "l")))) #());;;
      do:  ((method_call #sync #"Cond'ptr" #"Wait" (![#ptrT] (struct.field_ref #Walog #"condLogger"%go (![#ptrT] "l")))) #());;;
      continue: #());;;
    do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Walog #"memLock"%go (![#ptrT] "l")))) #());;;
    return: (![#LogPosition] "txn", ![#boolT] "ok")).

(* Flush flushes a transaction pos (and all preceding transactions)

   The implementation waits until the logger has appended in-memory log up to
   txn to on-disk log.

   go: wal.go:164:17 *)
Definition Walog__Flush : val :=
  rec: "Walog__Flush" "l" "pos" :=
    exception_do (let: "l" := (mem.alloc "l") in
    let: "pos" := (mem.alloc "pos") in
    do:  (let: "$a0" := #(W64 2) in
    let: "$a1" := #"Flush: commit till txn %d
    "%go in
    let: "$a2" := ((let: "$sl0" := (interface.make #wal.wal #"LogPosition" (![#LogPosition] "pos")) in
    slice.literal #interfaceT ["$sl0"])) in
    (func_call #util.util #"DPrintf"%go) "$a0" "$a1" "$a2");;;
    do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref #Walog #"memLock"%go (![#ptrT] "l")))) #());;;
    do:  ((method_call #sync #"Cond'ptr" #"Broadcast" (![#ptrT] (struct.field_ref #Walog #"condLogger"%go (![#ptrT] "l")))) #());;;
    (if: (![#LogPosition] "pos") > (![#LogPosition] (struct.field_ref #sliding #"mutable"%go (![#ptrT] (struct.field_ref #WalogState #"memLog"%go (![#ptrT] (struct.field_ref #Walog #"st"%go (![#ptrT] "l")))))))
    then do:  ((method_call #wal.wal #"WalogState'ptr" #"endGroupTxn" (![#ptrT] (struct.field_ref #Walog #"st"%go (![#ptrT] "l")))) #())
    else do:  #());;;
    (for: (λ: <>, (~ ((![#LogPosition] "pos") ≤ (![#LogPosition] (struct.field_ref #WalogState #"diskEnd"%go (![#ptrT] (struct.field_ref #Walog #"st"%go (![#ptrT] "l")))))))); (λ: <>, Skip) := λ: <>,
      do:  ((method_call #sync #"Cond'ptr" #"Wait" (![#ptrT] (struct.field_ref #Walog #"condLogger"%go (![#ptrT] "l")))) #()));;;
    do:  ((func_call #primitive.primitive #"Linearize"%go) #());;;
    do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Walog #"memLock"%go (![#ptrT] "l")))) #());;;
    return: #()).

(* Shutdown logger and installer

   go: wal.go:186:17 *)
Definition Walog__Shutdown : val :=
  rec: "Walog__Shutdown" "l" <> :=
    exception_do (let: "l" := (mem.alloc "l") in
    do:  (let: "$a0" := #(W64 1) in
    let: "$a1" := #"shutdown wal
    "%go in
    let: "$a2" := #slice.nil in
    (func_call #util.util #"DPrintf"%go) "$a0" "$a1" "$a2");;;
    do:  ((method_call #sync #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref #Walog #"memLock"%go (![#ptrT] "l")))) #());;;
    let: "$r0" := #true in
    do:  ((struct.field_ref #WalogState #"shutdown"%go (![#ptrT] (struct.field_ref #Walog #"st"%go (![#ptrT] "l")))) <-[#boolT] "$r0");;;
    do:  ((method_call #sync #"Cond'ptr" #"Broadcast" (![#ptrT] (struct.field_ref #Walog #"condLogger"%go (![#ptrT] "l")))) #());;;
    do:  ((method_call #sync #"Cond'ptr" #"Broadcast" (![#ptrT] (struct.field_ref #Walog #"condInstall"%go (![#ptrT] "l")))) #());;;
    (for: (λ: <>, (![#uint64T] (struct.field_ref #WalogState #"nthread"%go (![#ptrT] (struct.field_ref #Walog #"st"%go (![#ptrT] "l"))))) > #(W64 0)); (λ: <>, Skip) := λ: <>,
      do:  (let: "$a0" := #(W64 1) in
      let: "$a1" := #"wait for logger/installer"%go in
      let: "$a2" := #slice.nil in
      (func_call #util.util #"DPrintf"%go) "$a0" "$a1" "$a2");;;
      do:  ((method_call #sync #"Cond'ptr" #"Wait" (![#ptrT] (struct.field_ref #Walog #"condShut"%go (![#ptrT] "l")))) #()));;;
    do:  ((method_call #sync #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #Walog #"memLock"%go (![#ptrT] "l")))) #());;;
    do:  (let: "$a0" := #(W64 1) in
    let: "$a1" := #"wal done
    "%go in
    let: "$a2" := #slice.nil in
    (func_call #util.util #"DPrintf"%go) "$a0" "$a1" "$a2");;;
    return: #()).

Definition vars' : list (go_string * go_type) := [].

Definition functions' : list (go_string * val) := [("MkBlockData"%go, MkBlockData); ("initCircular"%go, initCircular); ("decodeHdr1"%go, decodeHdr1); ("decodeHdr2"%go, decodeHdr2); ("recoverCircular"%go, recoverCircular); ("hdr2"%go, hdr2); ("Advance"%go, Advance); ("mkSliding"%go, mkSliding); ("absorbBufs"%go, absorbBufs); ("installBlocks"%go, installBlocks); ("mkLog"%go, mkLog); ("MkLog"%go, MkLog); ("doMemAppend"%go, doMemAppend); ("copyUpdateBlock"%go, copyUpdateBlock)].

Definition msets' : list (go_string * (list (go_string * val))) := [("LogPosition"%go, []); ("LogPosition'ptr"%go, []); ("Update"%go, []); ("Update'ptr"%go, []); ("circularAppender"%go, []); ("circularAppender'ptr"%go, [("Append"%go, circularAppender__Append); ("hdr1"%go, circularAppender__hdr1); ("logBlocks"%go, circularAppender__logBlocks)]); ("sliding"%go, []); ("sliding'ptr"%go, [("append"%go, sliding__append); ("clearMutable"%go, sliding__clearMutable); ("deleteFrom"%go, sliding__deleteFrom); ("end"%go, sliding__end); ("get"%go, sliding__get); ("intoMutable"%go, sliding__intoMutable); ("memWrite"%go, sliding__memWrite); ("posForAddr"%go, sliding__posForAddr); ("takeFrom"%go, sliding__takeFrom); ("takeTill"%go, sliding__takeTill); ("update"%go, sliding__update)]); ("WalogState"%go, []); ("WalogState'ptr"%go, [("cutMemLog"%go, WalogState__cutMemLog); ("endGroupTxn"%go, WalogState__endGroupTxn); ("memEnd"%go, WalogState__memEnd); ("memLogHasSpace"%go, WalogState__memLogHasSpace); ("readMem"%go, WalogState__readMem); ("updatesOverflowU64"%go, WalogState__updatesOverflowU64)]); ("Walog"%go, []); ("Walog'ptr"%go, [("Flush"%go, Walog__Flush); ("LogSz"%go, Walog__LogSz); ("MemAppend"%go, Walog__MemAppend); ("Read"%go, Walog__Read); ("ReadInstalled"%go, Walog__ReadInstalled); ("ReadMem"%go, Walog__ReadMem); ("Shutdown"%go, Walog__Shutdown); ("flushIfNeeded"%go, Walog__flushIfNeeded); ("installer"%go, Walog__installer); ("logAppend"%go, Walog__logAppend); ("logInstall"%go, Walog__logInstall); ("logger"%go, Walog__logger); ("startBackgroundThreads"%go, Walog__startBackgroundThreads); ("waitForSpace"%go, Walog__waitForSpace)])].

#[global] Instance info' : PkgInfo wal.wal :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [disk.disk; common.common; marshal.marshal; util.util; sync.sync; primitive.primitive];
  |}.

Definition initialize' : val :=
  rec: "initialize'" <> :=
    globals.package_init wal.wal (λ: <>,
      exception_do (do:  primitive.initialize';;;
      do:  sync.initialize';;;
      do:  util.initialize';;;
      do:  marshal.initialize';;;
      do:  common.initialize';;;
      do:  disk.initialize')
      ).

End code.
End wal.
