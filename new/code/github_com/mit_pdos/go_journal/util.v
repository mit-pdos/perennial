(* autogenerated from github.com/mit-pdos/go-journal/util *)
From New.golang Require Import defn.
Require Export New.code.log.

Definition util : go_string := "github.com/mit-pdos/go-journal/util".

Module util.
Section code.
Context `{ffi_syntax}.


(* go: util.go:9:6 *)
Definition DPrintf : val :=
  rec: "DPrintf" "level" "format" "a" :=
    exception_do (let: "a" := (mem.alloc "a") in
    let: "format" := (mem.alloc "format") in
    let: "level" := (mem.alloc "level") in
    (if: (![#uint64T] "level") ≤ (![#uint64T] (globals.get #util.util #"Debug"%go))
    then
      do:  (let: "$a0" := (![#stringT] "format") in
      let: "$a1" := (![#sliceT] "a") in
      (func_call #log.log #"Printf"%go) "$a0" "$a1")
    else do:  #())).

(* go: util.go:15:6 *)
Definition RoundUp : val :=
  rec: "RoundUp" "n" "sz" :=
    exception_do (let: "sz" := (mem.alloc "sz") in
    let: "n" := (mem.alloc "n") in
    return: ((((![#uint64T] "n") + (![#uint64T] "sz")) - #(W64 1)) `quot` (![#uint64T] "sz"))).

(* go: util.go:19:6 *)
Definition Min : val :=
  rec: "Min" "n" "m" :=
    exception_do (let: "m" := (mem.alloc "m") in
    let: "n" := (mem.alloc "n") in
    (if: (![#uint64T] "n") < (![#uint64T] "m")
    then return: (![#uint64T] "n")
    else return: (![#uint64T] "m"))).

(* returns n+m>=2^64 (if it were computed at infinite precision)

   go: util.go:28:6 *)
Definition SumOverflows : val :=
  rec: "SumOverflows" "n" "m" :=
    exception_do (let: "m" := (mem.alloc "m") in
    let: "n" := (mem.alloc "n") in
    return: (((![#uint64T] "n") + (![#uint64T] "m")) < (![#uint64T] "n"))).

(* go: util.go:32:6 *)
Definition SumOverflows32 : val :=
  rec: "SumOverflows32" "n" "m" :=
    exception_do (let: "m" := (mem.alloc "m") in
    let: "n" := (mem.alloc "n") in
    return: (((![#uint32T] "n") + (![#uint32T] "m")) < (![#uint32T] "n"))).

(* go: util.go:36:6 *)
Definition CloneByteSlice : val :=
  rec: "CloneByteSlice" "s" :=
    exception_do (let: "s" := (mem.alloc "s") in
    let: "s2" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make2 #byteT (let: "$a0" := (![#sliceT] "s") in
    slice.len "$a0")) in
    do:  ("s2" <-[#sliceT] "$r0");;;
    do:  (let: "$a0" := (![#sliceT] "s2") in
    let: "$a1" := (![#sliceT] "s") in
    (slice.copy #byteT) "$a0" "$a1");;;
    return: (![#sliceT] "s2")).

Definition vars' : list (go_string * go_type) := [("Debug"%go, uint64T)].

Definition functions' : list (go_string * val) := [("DPrintf"%go, DPrintf); ("RoundUp"%go, RoundUp); ("Min"%go, Min); ("SumOverflows"%go, SumOverflows); ("SumOverflows32"%go, SumOverflows32); ("CloneByteSlice"%go, CloneByteSlice)].

Definition msets' : list (go_string * (list (go_string * val))) := [].

#[global] Instance info' : PkgInfo util.util :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [log.log];
  |}.

Definition initialize' : val :=
  rec: "initialize'" <> :=
    globals.package_init util.util (λ: <>,
      exception_do (do:  log.initialize';;;
      let: "$r0" := #(W64 0) in
      do:  ((globals.get #util.util #"Debug"%go) <-[#uint64T] "$r0"))
      ).

End code.
End util.
