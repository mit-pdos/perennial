(* autogenerated from github.com/mit-pdos/go-journal/util *)
Require Export New.code.log.
From New.golang Require Import defn.
Module pkg_id.
Definition util : go_string := "github.com/mit-pdos/go-journal/util".

End pkg_id.
Export pkg_id.
Module util.

Definition Debug {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/go-journal/util.Debug"%go.

Definition DPrintf {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/go-journal/util.DPrintf"%go.

Definition RoundUp {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/go-journal/util.RoundUp"%go.

Definition Min {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/go-journal/util.Min"%go.

Definition SumOverflows {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/go-journal/util.SumOverflows"%go.

Definition SumOverflows32 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/go-journal/util.SumOverflows32"%go.

Definition CloneByteSlice {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/go-journal/util.CloneByteSlice"%go.

(* go: util.go:9:6 *)
Definition DPrintfⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "level" "format" "a",
    exception_do (let: "a" := (GoAlloc (go.SliceType (go.InterfaceType [])) "a") in
    let: "format" := (GoAlloc go.string "format") in
    let: "level" := (GoAlloc go.uint64 "level") in
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "level") ≤⟨go.uint64⟩ (![go.uint64] (GlobalVarAddr Debug #())))
    then
      do:  (let: "$a0" := (![go.string] "format") in
      let: "$a1" := (![go.SliceType (go.InterfaceType [])] "a") in
      (FuncResolve log.Printf [] #()) "$a0" "$a1")
    else do:  #());;;
    return: #()).

(* go: util.go:15:6 *)
Definition RoundUpⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "n" "sz",
    exception_do (let: "sz" := (GoAlloc go.uint64 "sz") in
    let: "n" := (GoAlloc go.uint64 "n") in
    return: ((((![go.uint64] "n") +⟨go.uint64⟩ (![go.uint64] "sz")) -⟨go.uint64⟩ #(W64 1)) /⟨go.uint64⟩ (![go.uint64] "sz"))).

(* go: util.go:19:6 *)
Definition Minⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "n" "m",
    exception_do (let: "m" := (GoAlloc go.uint64 "m") in
    let: "n" := (GoAlloc go.uint64 "n") in
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "n") <⟨go.uint64⟩ (![go.uint64] "m"))
    then return: (![go.uint64] "n")
    else return: (![go.uint64] "m"))).

(* returns n+m>=2^64 (if it were computed at infinite precision)

   go: util.go:28:6 *)
Definition SumOverflowsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "n" "m",
    exception_do (let: "m" := (GoAlloc go.uint64 "m") in
    let: "n" := (GoAlloc go.uint64 "n") in
    return: (((![go.uint64] "n") +⟨go.uint64⟩ (![go.uint64] "m")) <⟨go.uint64⟩ (![go.uint64] "n"))).

(* go: util.go:32:6 *)
Definition SumOverflows32ⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "n" "m",
    exception_do (let: "m" := (GoAlloc go.uint32 "m") in
    let: "n" := (GoAlloc go.uint32 "n") in
    return: (((![go.uint32] "n") +⟨go.uint32⟩ (![go.uint32] "m")) <⟨go.uint32⟩ (![go.uint32] "n"))).

(* go: util.go:36:6 *)
Definition CloneByteSliceⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s",
    exception_do (let: "s" := (GoAlloc (go.SliceType go.byte) "s") in
    let: "s2" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) (let: "$a0" := (![go.SliceType go.byte] "s") in
    (FuncResolve go.len [go.SliceType go.byte] #()) "$a0")) in
    do:  ("s2" <-[go.SliceType go.byte] "$r0");;;
    do:  (let: "$a0" := (![go.SliceType go.byte] "s2") in
    let: "$a1" := (![go.SliceType go.byte] "s") in
    (FuncResolve go.copy [go.SliceType go.byte] #()) "$a0" "$a1");;;
    return: (![go.SliceType go.byte] "s2")).

#[global] Instance info' : PkgInfo pkg_id.util :=
{|
  pkg_imported_pkgs := [code.log.pkg_id.log]
|}.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init pkg_id.util (λ: <>,
      exception_do (do:  (go.GlobalAlloc Debug go.uint64 #());;;
      do:  (log.initialize' #());;;
      let: "$r0" := #(W64 0) in
      do:  ((GlobalVarAddr Debug #()) <-[go.uint64] "$r0"))
      ).

Class Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] DPrintf_unfold :: FuncUnfold DPrintf [] (DPrintfⁱᵐᵖˡ);
  #[global] RoundUp_unfold :: FuncUnfold RoundUp [] (RoundUpⁱᵐᵖˡ);
  #[global] Min_unfold :: FuncUnfold Min [] (Minⁱᵐᵖˡ);
  #[global] SumOverflows_unfold :: FuncUnfold SumOverflows [] (SumOverflowsⁱᵐᵖˡ);
  #[global] SumOverflows32_unfold :: FuncUnfold SumOverflows32 [] (SumOverflows32ⁱᵐᵖˡ);
  #[global] CloneByteSlice_unfold :: FuncUnfold CloneByteSlice [] (CloneByteSliceⁱᵐᵖˡ);
  #[global] import_log_Assumption :: log.Assumptions;
}.
End util.
