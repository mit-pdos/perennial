(* autogenerated from github.com/mit-pdos/go-journal/alloc *)
Require Export New.code.sync.
From New.golang Require Import defn.
Module pkg_id.
Definition alloc : go_string := "github.com/mit-pdos/go-journal/alloc".

End pkg_id.
Export pkg_id.
Module alloc.

Definition Alloc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/mit-pdos/go-journal/alloc.Alloc"%go [].

Definition MkAlloc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/go-journal/alloc.MkAlloc"%go.

Definition MkMaxAlloc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/go-journal/alloc.MkMaxAlloc"%go.

Definition popCnt {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/go-journal/alloc.popCnt"%go.

(* MkAlloc initializes with a bitmap.

   0 bits correspond to free numbers and 1 bits correspond to in-use numbers.

   go: alloc.go:18:6 *)
Definition MkAllocⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "bitmap",
    exception_do (let: "bitmap" := (GoAlloc (go.SliceType go.byte) "bitmap") in
    let: "a" := (GoAlloc (go.PointerType Alloc) (GoZeroVal (go.PointerType Alloc) #())) in
    let: "$r0" := (GoAlloc Alloc (CompositeLiteral Alloc (LiteralValue [KeyedElement (Some (KeyField "mu"%go)) (ElementExpression (go.PointerType sync.Mutex) (GoAlloc sync.Mutex (GoZeroVal sync.Mutex #()))); KeyedElement (Some (KeyField "next"%go)) (ElementExpression go.uint64 #(W64 0)); KeyedElement (Some (KeyField "bitmap"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] "bitmap"))]))) in
    do:  ("a" <-[go.PointerType Alloc] "$r0");;;
    return: (![go.PointerType Alloc] "a")).

(* go: alloc.go:27:17 *)
Definition Alloc__MarkUsedⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "a" "bn",
    exception_do (let: "a" := (GoAlloc (go.PointerType Alloc) "a") in
    let: "bn" := (GoAlloc go.uint64 "bn") in
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] (StructFieldRef Alloc "mu"%go (![go.PointerType Alloc] "a")))) #());;;
    let: "byte" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := ((![go.uint64] "bn") /⟨go.uint64⟩ #(W64 8)) in
    do:  ("byte" <-[go.uint64] "$r0");;;
    let: "bit" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := ((![go.uint64] "bn") %⟨go.uint64⟩ #(W64 8)) in
    do:  ("bit" <-[go.uint64] "$r0");;;
    let: "$r0" := ((![go.byte] (IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] (StructFieldRef Alloc "bitmap"%go (![go.PointerType Alloc] "a")), Convert go.uint64 go.int (![go.uint64] "byte")))) |⟨go.byte⟩ (#(W8 1) <<⟨go.byte⟩ (Convert go.uint64 go.byte (![go.uint64] "bit")))) in
    do:  ((IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] (StructFieldRef Alloc "bitmap"%go (![go.PointerType Alloc] "a")), Convert go.uint64 go.int (![go.uint64] "byte"))) <-[go.byte] "$r0");;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef Alloc "mu"%go (![go.PointerType Alloc] "a")))) #());;;
    return: #()).

(* MkMaxAlloc initializes an allocator to be fully free with a range of (0,
   max).

   Requires 0 < max and max % 8 == 0.

   go: alloc.go:39:6 *)
Definition MkMaxAllocⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "max",
    exception_do (let: "max" := (GoAlloc go.uint64 "max") in
    (if: Convert go.untyped_bool go.bool (⟨go.bool⟩! ((#(W64 0) <⟨go.uint64⟩ (![go.uint64] "max")) && (((![go.uint64] "max") %⟨go.uint64⟩ #(W64 8)) =⟨go.uint64⟩ #(W64 0))))
    then
      do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"invalid max, must be at least 0 and divisible by 8"%go) in
      (FuncResolve go.panic [] #()) "$a0")
    else do:  #());;;
    let: "bitmap" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) ((![go.uint64] "max") /⟨go.uint64⟩ #(W64 8))) in
    do:  ("bitmap" <-[go.SliceType go.byte] "$r0");;;
    let: "a" := (GoAlloc (go.PointerType Alloc) (GoZeroVal (go.PointerType Alloc) #())) in
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "bitmap") in
    (FuncResolve MkAlloc [] #()) "$a0") in
    do:  ("a" <-[go.PointerType Alloc] "$r0");;;
    do:  (let: "$a0" := #(W64 0) in
    (MethodResolve (go.PointerType Alloc) "MarkUsed"%go (![go.PointerType Alloc] "a")) "$a0");;;
    return: (![go.PointerType Alloc] "a")).

(* go: alloc.go:49:17 *)
Definition Alloc__incNextⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "a" <>,
    exception_do (let: "a" := (GoAlloc (go.PointerType Alloc) "a") in
    let: "$r0" := ((![go.uint64] (StructFieldRef Alloc "next"%go (![go.PointerType Alloc] "a"))) +⟨go.uint64⟩ #(W64 1)) in
    do:  ((StructFieldRef Alloc "next"%go (![go.PointerType Alloc] "a")) <-[go.uint64] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] (StructFieldRef Alloc "next"%go (![go.PointerType Alloc] "a"))) ≥⟨go.uint64⟩ (Convert go.int go.uint64 ((let: "$a0" := (![go.SliceType go.byte] (StructFieldRef Alloc "bitmap"%go (![go.PointerType Alloc] "a"))) in
    (FuncResolve go.len [go.SliceType go.byte] #()) "$a0") *⟨go.int⟩ #(W64 8))))
    then
      let: "$r0" := #(W64 0) in
      do:  ((StructFieldRef Alloc "next"%go (![go.PointerType Alloc] "a")) <-[go.uint64] "$r0")
    else do:  #());;;
    return: (![go.uint64] (StructFieldRef Alloc "next"%go (![go.PointerType Alloc] "a")))).

(* Returns a free number in the bitmap

   go: alloc.go:58:17 *)
Definition Alloc__allocBitⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "a" <>,
    exception_do (let: "a" := (GoAlloc (go.PointerType Alloc) "a") in
    let: "num" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] (StructFieldRef Alloc "mu"%go (![go.PointerType Alloc] "a")))) #());;;
    let: "$r0" := ((MethodResolve (go.PointerType Alloc) "incNext"%go (![go.PointerType Alloc] "a")) #()) in
    do:  ("num" <-[go.uint64] "$r0");;;
    let: "start" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (![go.uint64] "num") in
    do:  ("start" <-[go.uint64] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "bit" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: "$r0" := ((![go.uint64] "num") %⟨go.uint64⟩ #(W64 8)) in
      do:  ("bit" <-[go.uint64] "$r0");;;
      let: "byte" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: "$r0" := ((![go.uint64] "num") /⟨go.uint64⟩ #(W64 8)) in
      do:  ("byte" <-[go.uint64] "$r0");;;
      (if: Convert go.untyped_bool go.bool (((![go.byte] (IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] (StructFieldRef Alloc "bitmap"%go (![go.PointerType Alloc] "a")), Convert go.uint64 go.int (![go.uint64] "byte")))) &⟨go.byte⟩ (#(W8 1) <<⟨go.byte⟩ (Convert go.uint64 go.byte (![go.uint64] "bit")))) =⟨go.byte⟩ #(W8 0))
      then
        let: "$r0" := ((![go.byte] (IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] (StructFieldRef Alloc "bitmap"%go (![go.PointerType Alloc] "a")), Convert go.uint64 go.int (![go.uint64] "byte")))) |⟨go.byte⟩ (#(W8 1) <<⟨go.byte⟩ (Convert go.uint64 go.byte (![go.uint64] "bit")))) in
        do:  ((IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] (StructFieldRef Alloc "bitmap"%go (![go.PointerType Alloc] "a")), Convert go.uint64 go.int (![go.uint64] "byte"))) <-[go.byte] "$r0");;;
        break: #()
      else do:  #());;;
      let: "$r0" := ((MethodResolve (go.PointerType Alloc) "incNext"%go (![go.PointerType Alloc] "a")) #()) in
      do:  ("num" <-[go.uint64] "$r0");;;
      (if: Convert go.untyped_bool go.bool ((![go.uint64] "num") =⟨go.uint64⟩ (![go.uint64] "start"))
      then
        let: "$r0" := #(W64 0) in
        do:  ("num" <-[go.uint64] "$r0");;;
        break: #()
      else do:  #());;;
      continue: #());;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef Alloc "mu"%go (![go.PointerType Alloc] "a")))) #());;;
    return: (![go.uint64] "num")).

(* go: alloc.go:82:17 *)
Definition Alloc__freeBitⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "a" "bn",
    exception_do (let: "a" := (GoAlloc (go.PointerType Alloc) "a") in
    let: "bn" := (GoAlloc go.uint64 "bn") in
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] (StructFieldRef Alloc "mu"%go (![go.PointerType Alloc] "a")))) #());;;
    let: "byte" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := ((![go.uint64] "bn") /⟨go.uint64⟩ #(W64 8)) in
    do:  ("byte" <-[go.uint64] "$r0");;;
    let: "bit" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := ((![go.uint64] "bn") %⟨go.uint64⟩ #(W64 8)) in
    do:  ("bit" <-[go.uint64] "$r0");;;
    let: "$r0" := ((![go.byte] (IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] (StructFieldRef Alloc "bitmap"%go (![go.PointerType Alloc] "a")), Convert go.uint64 go.int (![go.uint64] "byte")))) &⟨go.byte⟩ (⟨go.bool⟩! (#(W8 1) <<⟨go.byte⟩ (Convert go.uint64 go.byte (![go.uint64] "bit"))))) in
    do:  ((IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] (StructFieldRef Alloc "bitmap"%go (![go.PointerType Alloc] "a")), Convert go.uint64 go.int (![go.uint64] "byte"))) <-[go.byte] "$r0");;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef Alloc "mu"%go (![go.PointerType Alloc] "a")))) #());;;
    return: #()).

(* go: alloc.go:90:17 *)
Definition Alloc__AllocNumⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "a" <>,
    exception_do (let: "a" := (GoAlloc (go.PointerType Alloc) "a") in
    let: "num" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := ((MethodResolve (go.PointerType Alloc) "allocBit"%go (![go.PointerType Alloc] "a")) #()) in
    do:  ("num" <-[go.uint64] "$r0");;;
    return: (![go.uint64] "num")).

(* go: alloc.go:95:17 *)
Definition Alloc__FreeNumⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "a" "num",
    exception_do (let: "a" := (GoAlloc (go.PointerType Alloc) "a") in
    let: "num" := (GoAlloc go.uint64 "num") in
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "num") =⟨go.uint64⟩ #(W64 0))
    then
      do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"FreeNum"%go) in
      (FuncResolve go.panic [] #()) "$a0")
    else do:  #());;;
    do:  (let: "$a0" := (![go.uint64] "num") in
    (MethodResolve (go.PointerType Alloc) "freeBit"%go (![go.PointerType Alloc] "a")) "$a0");;;
    return: #()).

(* go: alloc.go:102:6 *)
Definition popCntⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "b",
    exception_do (let: "b" := (GoAlloc go.byte "b") in
    let: "count" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "x" := (GoAlloc go.byte (GoZeroVal go.byte #())) in
    let: "$r0" := (![go.byte] "b") in
    do:  ("x" <-[go.byte] "$r0");;;
    (let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, (![go.uint64] "i") <⟨go.uint64⟩ #(W64 8)); (λ: <>, do:  ("i" <-[go.uint64] ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 1)))) := λ: <>,
      do:  ("count" <-[go.uint64] ((![go.uint64] "count") +⟨go.uint64⟩ (Convert go.byte go.uint64 ((![go.byte] "x") &⟨go.byte⟩ #(W8 1)))));;;
      let: "$r0" := ((![go.byte] "x") >>⟨go.byte⟩ (Convert go.untyped_int go.byte #1)) in
      do:  ("x" <-[go.byte] "$r0")));;;
    return: (![go.uint64] "count")).

(* go: alloc.go:112:17 *)
Definition Alloc__NumFreeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "a" <>,
    exception_do (let: "a" := (GoAlloc (go.PointerType Alloc) "a") in
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] (StructFieldRef Alloc "mu"%go (![go.PointerType Alloc] "a")))) #());;;
    let: "total" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (#(W64 8) *⟨go.uint64⟩ (Convert go.int go.uint64 (let: "$a0" := (![go.SliceType go.byte] (StructFieldRef Alloc "bitmap"%go (![go.PointerType Alloc] "a"))) in
    (FuncResolve go.len [go.SliceType go.byte] #()) "$a0"))) in
    do:  ("total" <-[go.uint64] "$r0");;;
    let: "count" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$range" := (![go.SliceType go.byte] (StructFieldRef Alloc "bitmap"%go (![go.PointerType Alloc] "a"))) in
    (let: "b" := (GoAlloc go.byte (GoZeroVal go.byte #())) in
    slice.for_range go.byte "$range" (λ: "$key" "$value",
      do:  ("b" <-[go.byte] "$value");;;
      do:  "$key";;;
      do:  ("count" <-[go.uint64] ((![go.uint64] "count") +⟨go.uint64⟩ (let: "$a0" := (![go.byte] "b") in
      (FuncResolve popCnt [] #()) "$a0")))));;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef Alloc "mu"%go (![go.PointerType Alloc] "a")))) #());;;
    return: ((![go.uint64] "total") -⟨go.uint64⟩ (![go.uint64] "count"))).

#[global] Instance info' : PkgInfo pkg_id.alloc :=
{|
  pkg_imported_pkgs := [code.sync.pkg_id.sync]
|}.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init pkg_id.alloc (λ: <>,
      exception_do (do:  (sync.initialize' #()))
      ).

Module Alloc.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  mu' : loc;
  next' : w64;
  bitmap' : slice.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End Alloc.

Definition Alloc'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "mu"%go (go.PointerType sync.Mutex));
  (go.FieldDecl "next"%go go.uint64);
  (go.FieldDecl "bitmap"%go (go.SliceType go.byte))
].
Program Definition Alloc'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (Alloc'fds_unsealed).
Global Instance equals_unfold_Alloc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Alloc'fds =→ Alloc'fds_unsealed.
Proof. rewrite /Alloc'fds seal_eq //. Qed.

Definition Allocⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (Alloc'fds).

Class Alloc_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Alloc_type_repr  :: go.TypeReprUnderlying Allocⁱᵐᵖˡ Alloc.t;
  #[global] Alloc_underlying :: (Alloc) <u (Allocⁱᵐᵖˡ);
  #[global] Alloc_get_mu (x : Alloc.t) :: ⟦StructFieldGet (Allocⁱᵐᵖˡ) "mu", #x⟧ ⤳[under] #x.(Alloc.mu');
  #[global] Alloc_set_mu (x : Alloc.t) y :: ⟦StructFieldSet (Allocⁱᵐᵖˡ) "mu", (#x, #y)⟧ ⤳[under] #(x <|Alloc.mu' := y|>);
  #[global] Alloc_get_next (x : Alloc.t) :: ⟦StructFieldGet (Allocⁱᵐᵖˡ) "next", #x⟧ ⤳[under] #x.(Alloc.next');
  #[global] Alloc_set_next (x : Alloc.t) y :: ⟦StructFieldSet (Allocⁱᵐᵖˡ) "next", (#x, #y)⟧ ⤳[under] #(x <|Alloc.next' := y|>);
  #[global] Alloc_get_bitmap (x : Alloc.t) :: ⟦StructFieldGet (Allocⁱᵐᵖˡ) "bitmap", #x⟧ ⤳[under] #x.(Alloc.bitmap');
  #[global] Alloc_set_bitmap (x : Alloc.t) y :: ⟦StructFieldSet (Allocⁱᵐᵖˡ) "bitmap", (#x, #y)⟧ ⤳[under] #(x <|Alloc.bitmap' := y|>);
  #[global] Alloc'ptr_AllocNum_unfold :: MethodUnfold (go.PointerType (Alloc)) "AllocNum" (Alloc__AllocNumⁱᵐᵖˡ);
  #[global] Alloc'ptr_FreeNum_unfold :: MethodUnfold (go.PointerType (Alloc)) "FreeNum" (Alloc__FreeNumⁱᵐᵖˡ);
  #[global] Alloc'ptr_MarkUsed_unfold :: MethodUnfold (go.PointerType (Alloc)) "MarkUsed" (Alloc__MarkUsedⁱᵐᵖˡ);
  #[global] Alloc'ptr_NumFree_unfold :: MethodUnfold (go.PointerType (Alloc)) "NumFree" (Alloc__NumFreeⁱᵐᵖˡ);
  #[global] Alloc'ptr_allocBit_unfold :: MethodUnfold (go.PointerType (Alloc)) "allocBit" (Alloc__allocBitⁱᵐᵖˡ);
  #[global] Alloc'ptr_freeBit_unfold :: MethodUnfold (go.PointerType (Alloc)) "freeBit" (Alloc__freeBitⁱᵐᵖˡ);
  #[global] Alloc'ptr_incNext_unfold :: MethodUnfold (go.PointerType (Alloc)) "incNext" (Alloc__incNextⁱᵐᵖˡ);
}.

Class Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Alloc_instance :: Alloc_Assumptions;
  #[global] MkAlloc_unfold :: FuncUnfold MkAlloc [] (MkAllocⁱᵐᵖˡ);
  #[global] MkMaxAlloc_unfold :: FuncUnfold MkMaxAlloc [] (MkMaxAllocⁱᵐᵖˡ);
  #[global] popCnt_unfold :: FuncUnfold popCnt [] (popCntⁱᵐᵖˡ);
  #[global] import_sync_Assumption :: sync.Assumptions;
}.
End alloc.
