(* autogenerated from github.com/mit-pdos/go-journal/buf *)
Require Export New.code.github_com.goose_lang.primitive.disk.
Require Export New.code.github_com.tchajed.marshal.
Require Export New.code.github_com.mit_pdos.go_journal.addr.
Require Export New.code.github_com.mit_pdos.go_journal.common.
Require Export New.code.github_com.mit_pdos.go_journal.util.
From New.golang Require Import defn.
From New Require Import disk_prelude.
Module pkg_id.
Definition buf : go_string := "github.com/mit-pdos/go-journal/buf".

End pkg_id.
Export pkg_id.
Module buf.

Definition Buf {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/mit-pdos/go-journal/buf.Buf"%go [].

Definition BufMap {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/mit-pdos/go-journal/buf.BufMap"%go [].

Definition MkBuf {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/go-journal/buf.MkBuf"%go.

Definition MkBufLoad {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/go-journal/buf.MkBufLoad"%go.

Definition installOneBit {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/go-journal/buf.installOneBit"%go.

Definition installBit {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/go-journal/buf.installBit"%go.

Definition installBytes {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/go-journal/buf.installBytes"%go.

Definition MkBufMap {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/go-journal/buf.MkBufMap"%go.

(* go: buf.go:21:6 *)
Definition MkBufⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "addr" "sz" "data",
    exception_do (let: "data" := (GoAlloc (go.SliceType go.byte) "data") in
    let: "sz" := (GoAlloc go.uint64 "sz") in
    let: "addr" := (GoAlloc addr.Addr "addr") in
    let: "b" := (GoAlloc (go.PointerType Buf) (GoZeroVal (go.PointerType Buf) #())) in
    let: "$r0" := (GoAlloc Buf (CompositeLiteral Buf (LiteralValue [KeyedElement (Some (KeyField "Addr"%go)) (ElementExpression addr.Addr (![addr.Addr] "addr")); KeyedElement (Some (KeyField "Sz"%go)) (ElementExpression go.uint64 (![go.uint64] "sz")); KeyedElement (Some (KeyField "Data"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] "data")); KeyedElement (Some (KeyField "dirty"%go)) (ElementExpression go.bool #false)]))) in
    do:  ("b" <-[go.PointerType Buf] "$r0");;;
    return: (![go.PointerType Buf] "b")).

(* Load the bits of a disk block into a new buf, as specified by addr

   go: buf.go:32:6 *)
Definition MkBufLoadⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "addr" "sz" "blk",
    exception_do (let: "blk" := (GoAlloc disk.Block "blk") in
    let: "sz" := (GoAlloc go.uint64 "sz") in
    let: "addr" := (GoAlloc addr.Addr "addr") in
    let: "bytefirst" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := ((![go.uint64] (StructFieldRef addr.Addr "Off"%go "addr")) /⟨go.uint64⟩ #(W64 8)) in
    do:  ("bytefirst" <-[go.uint64] "$r0");;;
    let: "bytelast" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := ((((![go.uint64] (StructFieldRef addr.Addr "Off"%go "addr")) +⟨go.uint64⟩ (![go.uint64] "sz")) -⟨go.uint64⟩ #(W64 1)) /⟨go.uint64⟩ #(W64 8)) in
    do:  ("bytelast" <-[go.uint64] "$r0");;;
    let: "data" := (GoAlloc disk.Block (GoZeroVal disk.Block #())) in
    let: "$r0" := (let: "$s" := (![disk.Block] "blk") in
    Slice disk.Block ("$s", ![go.uint64] "bytefirst", (![go.uint64] "bytelast") +⟨go.uint64⟩ #(W64 1))) in
    do:  ("data" <-[disk.Block] "$r0");;;
    let: "b" := (GoAlloc (go.PointerType Buf) (GoZeroVal (go.PointerType Buf) #())) in
    let: "$r0" := (GoAlloc Buf (CompositeLiteral Buf (LiteralValue [KeyedElement (Some (KeyField "Addr"%go)) (ElementExpression addr.Addr (![addr.Addr] "addr")); KeyedElement (Some (KeyField "Sz"%go)) (ElementExpression go.uint64 (![go.uint64] "sz")); KeyedElement (Some (KeyField "Data"%go)) (ElementExpression disk.Block (![disk.Block] "data")); KeyedElement (Some (KeyField "dirty"%go)) (ElementExpression go.bool #false)]))) in
    do:  ("b" <-[go.PointerType Buf] "$r0");;;
    return: (![go.PointerType Buf] "b")).

(* Install 1 bit from src into dst, at offset bit. return new dst.

   go: buf.go:46:6 *)
Definition installOneBitⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "src" "dst" "bit",
    exception_do (let: "bit" := (GoAlloc go.uint64 "bit") in
    let: "dst" := (GoAlloc go.byte "dst") in
    let: "src" := (GoAlloc go.byte "src") in
    let: "new" := (GoAlloc go.byte (GoZeroVal go.byte #())) in
    let: "$r0" := (![go.byte] "dst") in
    do:  ("new" <-[go.byte] "$r0");;;
    (if: Convert go.untyped_bool go.bool (((![go.byte] "src") &⟨go.byte⟩ (#(W8 1) <<⟨go.byte⟩ (Convert go.uint64 go.byte (![go.uint64] "bit")))) ≠⟨go.byte⟩ ((![go.byte] "dst") &⟨go.byte⟩ (#(W8 1) <<⟨go.byte⟩ (Convert go.uint64 go.byte (![go.uint64] "bit")))))
    then
      (if: Convert go.untyped_bool go.bool (((![go.byte] "src") &⟨go.byte⟩ (#(W8 1) <<⟨go.byte⟩ (Convert go.uint64 go.byte (![go.uint64] "bit")))) =⟨go.byte⟩ #(W8 0))
      then
        let: "$r0" := ((![go.byte] "new") &⟨go.byte⟩ (~ (#(W8 1) <<⟨go.byte⟩ (Convert go.uint64 go.byte (![go.uint64] "bit"))))) in
        do:  ("new" <-[go.byte] "$r0")
      else
        let: "$r0" := ((![go.byte] "new") |⟨go.byte⟩ (#(W8 1) <<⟨go.byte⟩ (Convert go.uint64 go.byte (![go.uint64] "bit")))) in
        do:  ("new" <-[go.byte] "$r0"))
    else do:  #());;;
    return: (![go.byte] "new")).

(* Install bit from src to dst, at dstoff in destination. dstoff is in bits.

   go: buf.go:61:6 *)
Definition installBitⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "src" "dst" "dstoff",
    exception_do (let: "dstoff" := (GoAlloc go.uint64 "dstoff") in
    let: "dst" := (GoAlloc (go.SliceType go.byte) "dst") in
    let: "src" := (GoAlloc (go.SliceType go.byte) "src") in
    let: "dstbyte" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := ((![go.uint64] "dstoff") /⟨go.uint64⟩ #(W64 8)) in
    do:  ("dstbyte" <-[go.uint64] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.byte] (IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "src", #(W64 0)))) in
    let: "$a1" := (![go.byte] (IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "dst", Convert go.uint64 go.int (![go.uint64] "dstbyte")))) in
    let: "$a2" := ((![go.uint64] "dstoff") %⟨go.uint64⟩ #(W64 8)) in
    (FuncResolve installOneBit [] #()) "$a0" "$a1" "$a2") in
    do:  ((IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "dst", Convert go.uint64 go.int (![go.uint64] "dstbyte"))) <-[go.byte] "$r0");;;
    return: #()).

(* Install bytes from src to dst.

   go: buf.go:67:6 *)
Definition installBytesⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "src" "dst" "dstoff" "nbit",
    exception_do (let: "nbit" := (GoAlloc go.uint64 "nbit") in
    let: "dstoff" := (GoAlloc go.uint64 "dstoff") in
    let: "dst" := (GoAlloc (go.SliceType go.byte) "dst") in
    let: "src" := (GoAlloc (go.SliceType go.byte) "src") in
    let: "sz" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := ((![go.uint64] "nbit") /⟨go.uint64⟩ #(W64 8)) in
    do:  ("sz" <-[go.uint64] "$r0");;;
    do:  (let: "$a0" := (let: "$s" := (![go.SliceType go.byte] "dst") in
    Slice (go.SliceType go.byte) ("$s", (![go.uint64] "dstoff") /⟨go.uint64⟩ #(W64 8), FuncResolve go.len [go.SliceType go.byte] #() (![go.SliceType go.byte] "dst"))) in
    let: "$a1" := (let: "$s" := (![go.SliceType go.byte] "src") in
    Slice (go.SliceType go.byte) ("$s", #(W64 0), ![go.uint64] "sz")) in
    (FuncResolve go.copy [go.SliceType go.byte] #()) "$a0" "$a1");;;
    return: (#());;;
    return: #()).

(* Install the bits from buf into blk.  Two cases: a bit or an inode

   go: buf.go:76:17 *)
Definition Buf__Installⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "buf" "blk",
    exception_do (let: "buf" := (GoAlloc (go.PointerType Buf) "buf") in
    let: "blk" := (GoAlloc disk.Block "blk") in
    do:  (let: "$a0" := #(W64 5) in
    let: "$a1" := #"%v: install
    "%go in
    let: "$a2" := ((let: "$sl0" := (Convert addr.Addr (go.InterfaceType []) (![addr.Addr] (StructFieldRef Buf "Addr"%go (![go.PointerType Buf] "buf")))) in
    CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0")]))) in
    (FuncResolve util.DPrintf [] #()) "$a0" "$a1" "$a2");;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] (StructFieldRef Buf "Sz"%go (![go.PointerType Buf] "buf"))) =⟨go.uint64⟩ #(W64 1))
    then
      do:  (let: "$a0" := (![go.SliceType go.byte] (StructFieldRef Buf "Data"%go (![go.PointerType Buf] "buf"))) in
      let: "$a1" := (![disk.Block] "blk") in
      let: "$a2" := (![go.uint64] (StructFieldRef addr.Addr "Off"%go (StructFieldRef Buf "Addr"%go (![go.PointerType Buf] "buf")))) in
      (FuncResolve installBit [] #()) "$a0" "$a1" "$a2")
    else
      (if: Convert go.untyped_bool go.bool ((((![go.uint64] (StructFieldRef Buf "Sz"%go (![go.PointerType Buf] "buf"))) %⟨go.uint64⟩ #(W64 8)) =⟨go.uint64⟩ #(W64 0)) && (((![go.uint64] (StructFieldRef addr.Addr "Off"%go (StructFieldRef Buf "Addr"%go (![go.PointerType Buf] "buf")))) %⟨go.uint64⟩ #(W64 8)) =⟨go.uint64⟩ #(W64 0)))
      then
        do:  (let: "$a0" := (![go.SliceType go.byte] (StructFieldRef Buf "Data"%go (![go.PointerType Buf] "buf"))) in
        let: "$a1" := (![disk.Block] "blk") in
        let: "$a2" := (![go.uint64] (StructFieldRef addr.Addr "Off"%go (StructFieldRef Buf "Addr"%go (![go.PointerType Buf] "buf")))) in
        let: "$a3" := (![go.uint64] (StructFieldRef Buf "Sz"%go (![go.PointerType Buf] "buf"))) in
        (FuncResolve installBytes [] #()) "$a0" "$a1" "$a2" "$a3")
      else
        do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"Install unsupported
        "%go) in
        (FuncResolve go.panic [] #()) "$a0")));;;
    do:  (let: "$a0" := #(W64 20) in
    let: "$a1" := #"install -> %v
    "%go in
    let: "$a2" := ((let: "$sl0" := (Convert disk.Block (go.InterfaceType []) (![disk.Block] "blk")) in
    CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0")]))) in
    (FuncResolve util.DPrintf [] #()) "$a0" "$a1" "$a2");;;
    return: #()).

(* go: buf.go:88:17 *)
Definition Buf__IsDirtyⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "buf" <>,
    exception_do (let: "buf" := (GoAlloc (go.PointerType Buf) "buf") in
    return: (![go.bool] (StructFieldRef Buf "dirty"%go (![go.PointerType Buf] "buf")))).

(* go: buf.go:92:17 *)
Definition Buf__SetDirtyⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "buf" <>,
    exception_do (let: "buf" := (GoAlloc (go.PointerType Buf) "buf") in
    let: "$r0" := #true in
    do:  ((StructFieldRef Buf "dirty"%go (![go.PointerType Buf] "buf")) <-[go.bool] "$r0");;;
    return: #()).

(* go: buf.go:96:17 *)
Definition Buf__WriteDirectⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "buf" "d",
    exception_do (let: "buf" := (GoAlloc (go.PointerType Buf) "buf") in
    let: "d" := (GoAlloc disk.Disk "d") in
    do:  ((MethodResolve (go.PointerType Buf) "SetDirty"%go (![go.PointerType Buf] "buf")) #());;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] (StructFieldRef Buf "Sz"%go (![go.PointerType Buf] "buf"))) =⟨go.uint64⟩ disk.BlockSize)
    then
      do:  (let: "$a0" := (![common.Bnum] (StructFieldRef addr.Addr "Blkno"%go (StructFieldRef Buf "Addr"%go (![go.PointerType Buf] "buf")))) in
      let: "$a1" := (![go.SliceType go.byte] (StructFieldRef Buf "Data"%go (![go.PointerType Buf] "buf"))) in
      (MethodResolve disk.Disk "Write"%go (![disk.Disk] "d")) "$a0" "$a1")
    else
      let: "blk" := (GoAlloc disk.Block (GoZeroVal disk.Block #())) in
      let: "$r0" := (let: "$a0" := (![common.Bnum] (StructFieldRef addr.Addr "Blkno"%go (StructFieldRef Buf "Addr"%go (![go.PointerType Buf] "buf")))) in
      (MethodResolve disk.Disk "Read"%go (![disk.Disk] "d")) "$a0") in
      do:  ("blk" <-[disk.Block] "$r0");;;
      do:  (let: "$a0" := (![disk.Block] "blk") in
      (MethodResolve (go.PointerType Buf) "Install"%go (![go.PointerType Buf] "buf")) "$a0");;;
      do:  (let: "$a0" := (![common.Bnum] (StructFieldRef addr.Addr "Blkno"%go (StructFieldRef Buf "Addr"%go (![go.PointerType Buf] "buf")))) in
      let: "$a1" := (![disk.Block] "blk") in
      (MethodResolve disk.Disk "Write"%go (![disk.Disk] "d")) "$a0" "$a1"));;;
    return: #()).

(* go: buf.go:107:17 *)
Definition Buf__BnumGetⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "buf" "off",
    exception_do (let: "buf" := (GoAlloc (go.PointerType Buf) "buf") in
    let: "off" := (GoAlloc go.uint64 "off") in
    let: "dec" := (GoAlloc marshal.Dec (GoZeroVal marshal.Dec #())) in
    let: "$r0" := (let: "$a0" := (let: "$s" := (![go.SliceType go.byte] (StructFieldRef Buf "Data"%go (![go.PointerType Buf] "buf"))) in
    Slice (go.SliceType go.byte) ("$s", ![go.uint64] "off", (![go.uint64] "off") +⟨go.uint64⟩ #(W64 8))) in
    (FuncResolve marshal.NewDec [] #()) "$a0") in
    do:  ("dec" <-[marshal.Dec] "$r0");;;
    return: ((MethodResolve marshal.Dec "GetInt"%go (![marshal.Dec] "dec")) #())).

(* go: buf.go:112:17 *)
Definition Buf__BnumPutⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "buf" "off" "v",
    exception_do (let: "buf" := (GoAlloc (go.PointerType Buf) "buf") in
    let: "v" := (GoAlloc common.Bnum "v") in
    let: "off" := (GoAlloc go.uint64 "off") in
    let: "enc" := (GoAlloc marshal.Enc (GoZeroVal marshal.Enc #())) in
    let: "$r0" := (let: "$a0" := #(W64 8) in
    (FuncResolve marshal.NewEnc [] #()) "$a0") in
    do:  ("enc" <-[marshal.Enc] "$r0");;;
    do:  (let: "$a0" := (![common.Bnum] "v") in
    (MethodResolve marshal.Enc "PutInt"%go (![marshal.Enc] "enc")) "$a0");;;
    do:  (let: "$a0" := (let: "$s" := (![go.SliceType go.byte] (StructFieldRef Buf "Data"%go (![go.PointerType Buf] "buf"))) in
    Slice (go.SliceType go.byte) ("$s", ![go.uint64] "off", (![go.uint64] "off") +⟨go.uint64⟩ #(W64 8))) in
    let: "$a1" := ((MethodResolve marshal.Enc "Finish"%go (![marshal.Enc] "enc")) #()) in
    (FuncResolve go.copy [go.SliceType go.byte] #()) "$a0" "$a1");;;
    do:  ((MethodResolve (go.PointerType Buf) "SetDirty"%go (![go.PointerType Buf] "buf")) #());;;
    return: #()).

(* go: bufmap.go:15:6 *)
Definition MkBufMapⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "a" := (GoAlloc (go.PointerType BufMap) (GoZeroVal (go.PointerType BufMap) #())) in
    let: "$r0" := (GoAlloc BufMap (CompositeLiteral BufMap (LiteralValue [KeyedElement (Some (KeyField "addrs"%go)) (ElementExpression (go.MapType go.uint64 (go.PointerType Buf)) ((FuncResolve go.make1 [go.MapType go.uint64 (go.PointerType Buf)] #()) #()))]))) in
    do:  ("a" <-[go.PointerType BufMap] "$r0");;;
    return: (![go.PointerType BufMap] "a")).

(* go: bufmap.go:22:21 *)
Definition BufMap__Insertⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "bmap" "buf",
    exception_do (let: "bmap" := (GoAlloc (go.PointerType BufMap) "bmap") in
    let: "buf" := (GoAlloc (go.PointerType Buf) "buf") in
    let: "$r0" := (![go.PointerType Buf] "buf") in
    do:  (map.insert go.uint64 (![go.MapType go.uint64 (go.PointerType Buf)] (StructFieldRef BufMap "addrs"%go (![go.PointerType BufMap] "bmap"))) ((MethodResolve addr.Addr "Flatid"%go (![addr.Addr] (StructFieldRef Buf "Addr"%go (![go.PointerType Buf] "buf")))) #()) "$r0");;;
    return: #()).

(* go: bufmap.go:26:21 *)
Definition BufMap__Lookupⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "bmap" "addr",
    exception_do (let: "bmap" := (GoAlloc (go.PointerType BufMap) "bmap") in
    let: "addr" := (GoAlloc addr.Addr "addr") in
    return: (map.lookup1 go.uint64 (go.PointerType Buf) (![go.MapType go.uint64 (go.PointerType Buf)] (StructFieldRef BufMap "addrs"%go (![go.PointerType BufMap] "bmap"))) ((MethodResolve addr.Addr "Flatid"%go (![addr.Addr] "addr")) #()))).

(* go: bufmap.go:30:21 *)
Definition BufMap__Delⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "bmap" "addr",
    exception_do (let: "bmap" := (GoAlloc (go.PointerType BufMap) "bmap") in
    let: "addr" := (GoAlloc addr.Addr "addr") in
    do:  (let: "$a0" := (![go.MapType go.uint64 (go.PointerType Buf)] (StructFieldRef BufMap "addrs"%go (![go.PointerType BufMap] "bmap"))) in
    let: "$a1" := ((MethodResolve addr.Addr "Flatid"%go (![addr.Addr] "addr")) #()) in
    (FuncResolve go.delete [go.MapType go.uint64 (go.PointerType Buf)] #()) "$a0" "$a1");;;
    return: #()).

(* go: bufmap.go:34:21 *)
Definition BufMap__Ndirtyⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "bmap" <>,
    exception_do (let: "bmap" := (GoAlloc (go.PointerType BufMap) "bmap") in
    let: "$r0" := (Convert go.int go.uint64 (let: "$a0" := (![go.MapType go.uint64 (go.PointerType Buf)] (StructFieldRef BufMap "addrs"%go (![go.PointerType BufMap] "bmap"))) in
    (FuncResolve go.len [go.MapType go.uint64 (go.PointerType Buf)] #()) "$a0")) in
    do:  "$r0";;;
    let: "n" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("n" <-[go.uint64] "$r0");;;
    let: "$range" := (![go.MapType go.uint64 (go.PointerType Buf)] (StructFieldRef BufMap "addrs"%go (![go.PointerType BufMap] "bmap"))) in
    (let: "buf" := (GoAlloc (go.PointerType Buf) (GoZeroVal (go.PointerType Buf) #())) in
    map.for_range go.uint64 (go.PointerType Buf) "$range" (λ: "$key" "value",
      do:  ("buf" <-[go.PointerType Buf] "$value");;;
      do:  "$key";;;
      (if: ![go.bool] (StructFieldRef Buf "dirty"%go (![go.PointerType Buf] "buf"))
      then do:  ("n" <-[go.uint64] ((![go.uint64] "n") +⟨go.uint64⟩ #(W64 1)))
      else do:  #())));;;
    return: (![go.uint64] "n")).

(* go: bufmap.go:46:21 *)
Definition BufMap__DirtyBufsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "bmap" <>,
    exception_do (let: "bmap" := (GoAlloc (go.PointerType BufMap) "bmap") in
    let: "bufs" := (GoAlloc (go.SliceType (go.PointerType Buf)) (GoZeroVal (go.SliceType (go.PointerType Buf)) #())) in
    let: "$range" := (![go.MapType go.uint64 (go.PointerType Buf)] (StructFieldRef BufMap "addrs"%go (![go.PointerType BufMap] "bmap"))) in
    (let: "buf" := (GoAlloc (go.PointerType Buf) (GoZeroVal (go.PointerType Buf) #())) in
    map.for_range go.uint64 (go.PointerType Buf) "$range" (λ: "$key" "value",
      do:  ("buf" <-[go.PointerType Buf] "$value");;;
      do:  "$key";;;
      (if: ![go.bool] (StructFieldRef Buf "dirty"%go (![go.PointerType Buf] "buf"))
      then
        let: "$r0" := (let: "$a0" := (![go.SliceType (go.PointerType Buf)] "bufs") in
        let: "$a1" := ((let: "$sl0" := (![go.PointerType Buf] "buf") in
        CompositeLiteral (go.SliceType (go.PointerType Buf)) (LiteralValue [KeyedElement None (ElementExpression (go.PointerType Buf) "$sl0")]))) in
        (FuncResolve go.append [go.SliceType (go.PointerType Buf)] #()) "$a0" "$a1") in
        do:  ("bufs" <-[go.SliceType (go.PointerType Buf)] "$r0")
      else do:  #())));;;
    return: (![go.SliceType (go.PointerType Buf)] "bufs")).

#[global] Instance info' : PkgInfo pkg_id.buf :=
{|
  pkg_imported_pkgs := [code.github_com.goose_lang.primitive.disk.pkg_id.disk; code.github_com.tchajed.marshal.pkg_id.marshal; code.github_com.mit_pdos.go_journal.addr.pkg_id.addr; code.github_com.mit_pdos.go_journal.common.pkg_id.common; code.github_com.mit_pdos.go_journal.util.pkg_id.util]
|}.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init pkg_id.buf (λ: <>,
      exception_do (do:  (util.initialize' #());;;
      do:  (common.initialize' #());;;
      do:  (addr.initialize' #());;;
      do:  (marshal.initialize' #());;;
      do:  (disk.initialize' #()))
      ).

Module Buf.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  Addr' : addr.Addr.t;
  Sz' : w64;
  Data' : slice.t;
  dirty' : bool;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End Buf.

Definition Buf'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "Addr"%go addr.Addr);
  (go.FieldDecl "Sz"%go go.uint64);
  (go.FieldDecl "Data"%go (go.SliceType go.byte));
  (go.FieldDecl "dirty"%go go.bool)
].
Program Definition Buf'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (Buf'fds_unsealed).
Global Instance equals_unfold_Buf {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Buf'fds =→ Buf'fds_unsealed.
Proof. rewrite /Buf'fds seal_eq //. Qed.

Definition Bufⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (Buf'fds).

Class Buf_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Buf_type_repr  :: go.TypeReprUnderlying Bufⁱᵐᵖˡ Buf.t;
  #[global] Buf_underlying :: (Buf) <u (Bufⁱᵐᵖˡ);
  #[global] Buf_get_Addr (x : Buf.t) :: ⟦StructFieldGet (Bufⁱᵐᵖˡ) "Addr", #x⟧ ⤳[under] #x.(Buf.Addr');
  #[global] Buf_set_Addr (x : Buf.t) y :: ⟦StructFieldSet (Bufⁱᵐᵖˡ) "Addr", (#x, #y)⟧ ⤳[under] #(x <|Buf.Addr' := y|>);
  #[global] Buf_get_Sz (x : Buf.t) :: ⟦StructFieldGet (Bufⁱᵐᵖˡ) "Sz", #x⟧ ⤳[under] #x.(Buf.Sz');
  #[global] Buf_set_Sz (x : Buf.t) y :: ⟦StructFieldSet (Bufⁱᵐᵖˡ) "Sz", (#x, #y)⟧ ⤳[under] #(x <|Buf.Sz' := y|>);
  #[global] Buf_get_Data (x : Buf.t) :: ⟦StructFieldGet (Bufⁱᵐᵖˡ) "Data", #x⟧ ⤳[under] #x.(Buf.Data');
  #[global] Buf_set_Data (x : Buf.t) y :: ⟦StructFieldSet (Bufⁱᵐᵖˡ) "Data", (#x, #y)⟧ ⤳[under] #(x <|Buf.Data' := y|>);
  #[global] Buf_get_dirty (x : Buf.t) :: ⟦StructFieldGet (Bufⁱᵐᵖˡ) "dirty", #x⟧ ⤳[under] #x.(Buf.dirty');
  #[global] Buf_set_dirty (x : Buf.t) y :: ⟦StructFieldSet (Bufⁱᵐᵖˡ) "dirty", (#x, #y)⟧ ⤳[under] #(x <|Buf.dirty' := y|>);
  #[global] Buf'ptr_BnumGet_unfold :: MethodUnfold (go.PointerType (Buf)) "BnumGet" (Buf__BnumGetⁱᵐᵖˡ);
  #[global] Buf'ptr_BnumPut_unfold :: MethodUnfold (go.PointerType (Buf)) "BnumPut" (Buf__BnumPutⁱᵐᵖˡ);
  #[global] Buf'ptr_Install_unfold :: MethodUnfold (go.PointerType (Buf)) "Install" (Buf__Installⁱᵐᵖˡ);
  #[global] Buf'ptr_IsDirty_unfold :: MethodUnfold (go.PointerType (Buf)) "IsDirty" (Buf__IsDirtyⁱᵐᵖˡ);
  #[global] Buf'ptr_SetDirty_unfold :: MethodUnfold (go.PointerType (Buf)) "SetDirty" (Buf__SetDirtyⁱᵐᵖˡ);
  #[global] Buf'ptr_WriteDirect_unfold :: MethodUnfold (go.PointerType (Buf)) "WriteDirect" (Buf__WriteDirectⁱᵐᵖˡ);
}.

Module BufMap.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  addrs' : map.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End BufMap.

Definition BufMap'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "addrs"%go (go.MapType go.uint64 (go.PointerType Buf)))
].
Program Definition BufMap'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (BufMap'fds_unsealed).
Global Instance equals_unfold_BufMap {ext : ffi_syntax} {go_gctx : GoGlobalContext} : BufMap'fds =→ BufMap'fds_unsealed.
Proof. rewrite /BufMap'fds seal_eq //. Qed.

Definition BufMapⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (BufMap'fds).

Class BufMap_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] BufMap_type_repr  :: go.TypeReprUnderlying BufMapⁱᵐᵖˡ BufMap.t;
  #[global] BufMap_underlying :: (BufMap) <u (BufMapⁱᵐᵖˡ);
  #[global] BufMap_get_addrs (x : BufMap.t) :: ⟦StructFieldGet (BufMapⁱᵐᵖˡ) "addrs", #x⟧ ⤳[under] #x.(BufMap.addrs');
  #[global] BufMap_set_addrs (x : BufMap.t) y :: ⟦StructFieldSet (BufMapⁱᵐᵖˡ) "addrs", (#x, #y)⟧ ⤳[under] #(x <|BufMap.addrs' := y|>);
  #[global] BufMap'ptr_Del_unfold :: MethodUnfold (go.PointerType (BufMap)) "Del" (BufMap__Delⁱᵐᵖˡ);
  #[global] BufMap'ptr_DirtyBufs_unfold :: MethodUnfold (go.PointerType (BufMap)) "DirtyBufs" (BufMap__DirtyBufsⁱᵐᵖˡ);
  #[global] BufMap'ptr_Insert_unfold :: MethodUnfold (go.PointerType (BufMap)) "Insert" (BufMap__Insertⁱᵐᵖˡ);
  #[global] BufMap'ptr_Lookup_unfold :: MethodUnfold (go.PointerType (BufMap)) "Lookup" (BufMap__Lookupⁱᵐᵖˡ);
  #[global] BufMap'ptr_Ndirty_unfold :: MethodUnfold (go.PointerType (BufMap)) "Ndirty" (BufMap__Ndirtyⁱᵐᵖˡ);
}.

Class Assumptions `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Buf_instance :: Buf_Assumptions;
  #[global] BufMap_instance :: BufMap_Assumptions;
  #[global] MkBuf_unfold :: FuncUnfold MkBuf [] (MkBufⁱᵐᵖˡ);
  #[global] MkBufLoad_unfold :: FuncUnfold MkBufLoad [] (MkBufLoadⁱᵐᵖˡ);
  #[global] installOneBit_unfold :: FuncUnfold installOneBit [] (installOneBitⁱᵐᵖˡ);
  #[global] installBit_unfold :: FuncUnfold installBit [] (installBitⁱᵐᵖˡ);
  #[global] installBytes_unfold :: FuncUnfold installBytes [] (installBytesⁱᵐᵖˡ);
  #[global] MkBufMap_unfold :: FuncUnfold MkBufMap [] (MkBufMapⁱᵐᵖˡ);
  #[global] import_disk_Assumption :: disk.Assumptions;
  #[global] import_marshal_Assumption :: marshal.Assumptions;
  #[global] import_addr_Assumption :: addr.Assumptions;
  #[global] import_common_Assumption :: common.Assumptions;
  #[global] import_util_Assumption :: util.Assumptions;
}.
End buf.
