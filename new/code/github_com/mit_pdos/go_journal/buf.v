(* autogenerated from github.com/mit-pdos/go-journal/buf *)
From New.golang Require Import defn.
Require Export New.code.github_com.goose_lang.primitive.disk.
Require Export New.code.github_com.mit_pdos.go_journal.addr.
Require Export New.code.github_com.mit_pdos.go_journal.common.
Require Export New.code.github_com.mit_pdos.go_journal.util.
Require Export New.code.github_com.tchajed.marshal.

Definition buf : go_string := "github.com/mit-pdos/go-journal/buf".

From New Require Import disk_prelude.
Module buf.
Section code.


Definition Buf : go_type := structT [
  "Addr" :: addr.Addr;
  "Sz" :: uint64T;
  "Data" :: sliceT;
  "dirty" :: boolT
].

(* go: buf.go:21:6 *)
Definition MkBuf : val :=
  rec: "MkBuf" "addr" "sz" "data" :=
    exception_do (let: "data" := (mem.alloc "data") in
    let: "sz" := (mem.alloc "sz") in
    let: "addr" := (mem.alloc "addr") in
    let: "b" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (let: "$Addr" := (![#addr.Addr] "addr") in
    let: "$Sz" := (![#uint64T] "sz") in
    let: "$Data" := (![#sliceT] "data") in
    let: "$dirty" := #false in
    struct.make #Buf [{
      "Addr" ::= "$Addr";
      "Sz" ::= "$Sz";
      "Data" ::= "$Data";
      "dirty" ::= "$dirty"
    }])) in
    do:  ("b" <-[#ptrT] "$r0");;;
    return: (![#ptrT] "b")).

(* Load the bits of a disk block into a new buf, as specified by addr

   go: buf.go:32:6 *)
Definition MkBufLoad : val :=
  rec: "MkBufLoad" "addr" "sz" "blk" :=
    exception_do (let: "blk" := (mem.alloc "blk") in
    let: "sz" := (mem.alloc "sz") in
    let: "addr" := (mem.alloc "addr") in
    let: "bytefirst" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := ((![#uint64T] (struct.field_ref #addr.Addr #"Off"%go "addr")) `quot` #(W64 8)) in
    do:  ("bytefirst" <-[#uint64T] "$r0");;;
    let: "bytelast" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := ((((![#uint64T] (struct.field_ref #addr.Addr #"Off"%go "addr")) + (![#uint64T] "sz")) - #(W64 1)) `quot` #(W64 8)) in
    do:  ("bytelast" <-[#uint64T] "$r0");;;
    let: "data" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$s" := (![#sliceT] "blk") in
    slice.slice #byteT "$s" (![#uint64T] "bytefirst") ((![#uint64T] "bytelast") + #(W64 1))) in
    do:  ("data" <-[#sliceT] "$r0");;;
    let: "b" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (let: "$Addr" := (![#addr.Addr] "addr") in
    let: "$Sz" := (![#uint64T] "sz") in
    let: "$Data" := (![#sliceT] "data") in
    let: "$dirty" := #false in
    struct.make #Buf [{
      "Addr" ::= "$Addr";
      "Sz" ::= "$Sz";
      "Data" ::= "$Data";
      "dirty" ::= "$dirty"
    }])) in
    do:  ("b" <-[#ptrT] "$r0");;;
    return: (![#ptrT] "b")).

(* Install 1 bit from src into dst, at offset bit. return new dst.

   go: buf.go:46:6 *)
Definition installOneBit : val :=
  rec: "installOneBit" "src" "dst" "bit" :=
    exception_do (let: "bit" := (mem.alloc "bit") in
    let: "dst" := (mem.alloc "dst") in
    let: "src" := (mem.alloc "src") in
    let: "new" := (mem.alloc (type.zero_val #byteT)) in
    let: "$r0" := (![#byteT] "dst") in
    do:  ("new" <-[#byteT] "$r0");;;
    (if: ((![#byteT] "src") `and` (#(W8 1) ≪ (u_to_w8 (![#uint64T] "bit")))) ≠ ((![#byteT] "dst") `and` (#(W8 1) ≪ (u_to_w8 (![#uint64T] "bit"))))
    then
      (if: ((![#byteT] "src") `and` (#(W8 1) ≪ (u_to_w8 (![#uint64T] "bit")))) = #(W8 0)
      then
        let: "$r0" := ((![#byteT] "new") `and` (~ (#(W8 1) ≪ (u_to_w8 (![#uint64T] "bit"))))) in
        do:  ("new" <-[#byteT] "$r0")
      else
        let: "$r0" := ((![#byteT] "new") `or` (#(W8 1) ≪ (u_to_w8 (![#uint64T] "bit")))) in
        do:  ("new" <-[#byteT] "$r0"))
    else do:  #());;;
    return: (![#byteT] "new")).

(* Install bit from src to dst, at dstoff in destination. dstoff is in bits.

   go: buf.go:61:6 *)
Definition installBit : val :=
  rec: "installBit" "src" "dst" "dstoff" :=
    exception_do (let: "dstoff" := (mem.alloc "dstoff") in
    let: "dst" := (mem.alloc "dst") in
    let: "src" := (mem.alloc "src") in
    let: "dstbyte" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := ((![#uint64T] "dstoff") `quot` #(W64 8)) in
    do:  ("dstbyte" <-[#uint64T] "$r0");;;
    let: "$r0" := (let: "$a0" := (![#byteT] (slice.elem_ref #byteT (![#sliceT] "src") #(W64 0))) in
    let: "$a1" := (![#byteT] (slice.elem_ref #byteT (![#sliceT] "dst") (![#uint64T] "dstbyte"))) in
    let: "$a2" := ((![#uint64T] "dstoff") `rem` #(W64 8)) in
    (func_call #buf.buf #"installOneBit"%go) "$a0" "$a1" "$a2") in
    do:  ((slice.elem_ref #byteT (![#sliceT] "dst") (![#uint64T] "dstbyte")) <-[#byteT] "$r0")).

(* Install bytes from src to dst.

   go: buf.go:67:6 *)
Definition installBytes : val :=
  rec: "installBytes" "src" "dst" "dstoff" "nbit" :=
    exception_do (let: "nbit" := (mem.alloc "nbit") in
    let: "dstoff" := (mem.alloc "dstoff") in
    let: "dst" := (mem.alloc "dst") in
    let: "src" := (mem.alloc "src") in
    let: "sz" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := ((![#uint64T] "nbit") `quot` #(W64 8)) in
    do:  ("sz" <-[#uint64T] "$r0");;;
    do:  (let: "$a0" := (let: "$s" := (![#sliceT] "dst") in
    slice.slice #byteT "$s" ((![#uint64T] "dstoff") `quot` #(W64 8)) (slice.len "$s")) in
    let: "$a1" := (let: "$s" := (![#sliceT] "src") in
    slice.slice #byteT "$s" #(W64 0) (![#uint64T] "sz")) in
    (slice.copy #byteT) "$a0" "$a1");;;
    return: (#())).

(* Install the bits from buf into blk.  Two cases: a bit or an inode

   go: buf.go:76:17 *)
Definition Buf__Install : val :=
  rec: "Buf__Install" "buf" "blk" :=
    exception_do (let: "buf" := (mem.alloc "buf") in
    let: "blk" := (mem.alloc "blk") in
    do:  (let: "$a0" := #(W64 5) in
    let: "$a1" := #"%v: install
    "%go in
    let: "$a2" := ((let: "$sl0" := (interface.make #addr #"Addr" (![#addr.Addr] (struct.field_ref #Buf #"Addr"%go (![#ptrT] "buf")))) in
    slice.literal #interfaceT ["$sl0"])) in
    (func_call #util.util #"DPrintf"%go) "$a0" "$a1" "$a2");;;
    (if: (![#uint64T] (struct.field_ref #Buf #"Sz"%go (![#ptrT] "buf"))) = #(W64 1)
    then
      do:  (let: "$a0" := (![#sliceT] (struct.field_ref #Buf #"Data"%go (![#ptrT] "buf"))) in
      let: "$a1" := (![#sliceT] "blk") in
      let: "$a2" := (![#uint64T] (struct.field_ref #addr.Addr #"Off"%go (struct.field_ref #Buf #"Addr"%go (![#ptrT] "buf")))) in
      (func_call #buf.buf #"installBit"%go) "$a0" "$a1" "$a2")
    else
      (if: (((![#uint64T] (struct.field_ref #Buf #"Sz"%go (![#ptrT] "buf"))) `rem` #(W64 8)) = #(W64 0)) && (((![#uint64T] (struct.field_ref #addr.Addr #"Off"%go (struct.field_ref #Buf #"Addr"%go (![#ptrT] "buf")))) `rem` #(W64 8)) = #(W64 0))
      then
        do:  (let: "$a0" := (![#sliceT] (struct.field_ref #Buf #"Data"%go (![#ptrT] "buf"))) in
        let: "$a1" := (![#sliceT] "blk") in
        let: "$a2" := (![#uint64T] (struct.field_ref #addr.Addr #"Off"%go (struct.field_ref #Buf #"Addr"%go (![#ptrT] "buf")))) in
        let: "$a3" := (![#uint64T] (struct.field_ref #Buf #"Sz"%go (![#ptrT] "buf"))) in
        (func_call #buf.buf #"installBytes"%go) "$a0" "$a1" "$a2" "$a3")
      else
        do:  (let: "$a0" := (interface.make #""%go #"string"%go #"Install unsupported
        "%go) in
        Panic "$a0")));;;
    do:  (let: "$a0" := #(W64 20) in
    let: "$a1" := #"install -> %v
    "%go in
    let: "$a2" := ((let: "$sl0" := (interface.make #"slice'"%go (![#sliceT] "blk")) in
    slice.literal #interfaceT ["$sl0"])) in
    (func_call #util.util #"DPrintf"%go) "$a0" "$a1" "$a2")).

(* go: buf.go:88:17 *)
Definition Buf__IsDirty : val :=
  rec: "Buf__IsDirty" "buf" <> :=
    exception_do (let: "buf" := (mem.alloc "buf") in
    return: (![#boolT] (struct.field_ref #Buf #"dirty"%go (![#ptrT] "buf")))).

(* go: buf.go:92:17 *)
Definition Buf__SetDirty : val :=
  rec: "Buf__SetDirty" "buf" <> :=
    exception_do (let: "buf" := (mem.alloc "buf") in
    let: "$r0" := #true in
    do:  ((struct.field_ref #Buf #"dirty"%go (![#ptrT] "buf")) <-[#boolT] "$r0")).

(* go: buf.go:96:17 *)
Definition Buf__WriteDirect : val :=
  rec: "Buf__WriteDirect" "buf" "d" :=
    exception_do (let: "buf" := (mem.alloc "buf") in
    let: "d" := (mem.alloc "d") in
    do:  ((method_call #buf.buf #"Buf'ptr" #"SetDirty" (![#ptrT] "buf")) #());;;
    (if: (![#uint64T] (struct.field_ref #Buf #"Sz"%go (![#ptrT] "buf"))) = disk.BlockSize
    then
      do:  (let: "$a0" := (![#uint64T] (struct.field_ref #addr.Addr #"Blkno"%go (struct.field_ref #Buf #"Addr"%go (![#ptrT] "buf")))) in
      let: "$a1" := (![#sliceT] (struct.field_ref #Buf #"Data"%go (![#ptrT] "buf"))) in
      (interface.get #"Write"%go (![#disk.Disk] "d")) "$a0" "$a1")
    else
      let: "blk" := (mem.alloc (type.zero_val #sliceT)) in
      let: "$r0" := (let: "$a0" := (![#uint64T] (struct.field_ref #addr.Addr #"Blkno"%go (struct.field_ref #Buf #"Addr"%go (![#ptrT] "buf")))) in
      (interface.get #"Read"%go (![#disk.Disk] "d")) "$a0") in
      do:  ("blk" <-[#sliceT] "$r0");;;
      do:  (let: "$a0" := (![#sliceT] "blk") in
      (method_call #buf.buf #"Buf'ptr" #"Install" (![#ptrT] "buf")) "$a0");;;
      do:  (let: "$a0" := (![#uint64T] (struct.field_ref #addr.Addr #"Blkno"%go (struct.field_ref #Buf #"Addr"%go (![#ptrT] "buf")))) in
      let: "$a1" := (![#sliceT] "blk") in
      (interface.get #"Write"%go (![#disk.Disk] "d")) "$a0" "$a1"))).

(* go: buf.go:107:17 *)
Definition Buf__BnumGet : val :=
  rec: "Buf__BnumGet" "buf" "off" :=
    exception_do (let: "buf" := (mem.alloc "buf") in
    let: "off" := (mem.alloc "off") in
    let: "dec" := (mem.alloc (type.zero_val #marshal.Dec)) in
    let: "$r0" := (let: "$a0" := (let: "$s" := (![#sliceT] (struct.field_ref #Buf #"Data"%go (![#ptrT] "buf"))) in
    slice.slice #byteT "$s" (![#uint64T] "off") ((![#uint64T] "off") + #(W64 8))) in
    (func_call #marshal.marshal #"NewDec"%go) "$a0") in
    do:  ("dec" <-[#marshal.Dec] "$r0");;;
    return: ((method_call #marshal #"Dec" #"GetInt" (![#marshal.Dec] "dec")) #())).

(* go: buf.go:112:17 *)
Definition Buf__BnumPut : val :=
  rec: "Buf__BnumPut" "buf" "off" "v" :=
    exception_do (let: "buf" := (mem.alloc "buf") in
    let: "v" := (mem.alloc "v") in
    let: "off" := (mem.alloc "off") in
    let: "enc" := (mem.alloc (type.zero_val #marshal.Enc)) in
    let: "$r0" := (let: "$a0" := #(W64 8) in
    (func_call #marshal.marshal #"NewEnc"%go) "$a0") in
    do:  ("enc" <-[#marshal.Enc] "$r0");;;
    do:  (let: "$a0" := (![#uint64T] "v") in
    (method_call #marshal #"Enc" #"PutInt" (![#marshal.Enc] "enc")) "$a0");;;
    do:  (let: "$a0" := (let: "$s" := (![#sliceT] (struct.field_ref #Buf #"Data"%go (![#ptrT] "buf"))) in
    slice.slice #byteT "$s" (![#uint64T] "off") ((![#uint64T] "off") + #(W64 8))) in
    let: "$a1" := ((method_call #marshal #"Enc" #"Finish" (![#marshal.Enc] "enc")) #()) in
    (slice.copy #byteT) "$a0" "$a1");;;
    do:  ((method_call #buf.buf #"Buf'ptr" #"SetDirty" (![#ptrT] "buf")) #())).

Definition BufMap : go_type := structT [
  "addrs" :: mapT uint64T ptrT
].

(* go: bufmap.go:15:6 *)
Definition MkBufMap : val :=
  rec: "MkBufMap" <> :=
    exception_do (let: "a" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (let: "$addrs" := (map.make #uint64T #ptrT) in
    struct.make #BufMap [{
      "addrs" ::= "$addrs"
    }])) in
    do:  ("a" <-[#ptrT] "$r0");;;
    return: (![#ptrT] "a")).

(* go: bufmap.go:22:21 *)
Definition BufMap__Insert : val :=
  rec: "BufMap__Insert" "bmap" "buf" :=
    exception_do (let: "bmap" := (mem.alloc "bmap") in
    let: "buf" := (mem.alloc "buf") in
    let: "$r0" := (![#ptrT] "buf") in
    do:  (map.insert (![type.mapT #uint64T #ptrT] (struct.field_ref #BufMap #"addrs"%go (![#ptrT] "bmap"))) ((method_call #addr #"Addr" #"Flatid" (![#addr.Addr] (struct.field_ref #Buf #"Addr"%go (![#ptrT] "buf")))) #()) "$r0")).

(* go: bufmap.go:26:21 *)
Definition BufMap__Lookup : val :=
  rec: "BufMap__Lookup" "bmap" "addr" :=
    exception_do (let: "bmap" := (mem.alloc "bmap") in
    let: "addr" := (mem.alloc "addr") in
    return: (Fst (map.get (![type.mapT #uint64T #ptrT] (struct.field_ref #BufMap #"addrs"%go (![#ptrT] "bmap"))) ((method_call #addr #"Addr" #"Flatid" (![#addr.Addr] "addr")) #())))).

(* go: bufmap.go:30:21 *)
Definition BufMap__Del : val :=
  rec: "BufMap__Del" "bmap" "addr" :=
    exception_do (let: "bmap" := (mem.alloc "bmap") in
    let: "addr" := (mem.alloc "addr") in
    do:  (let: "$a0" := (![type.mapT #uint64T #ptrT] (struct.field_ref #BufMap #"addrs"%go (![#ptrT] "bmap"))) in
    let: "$a1" := ((method_call #addr #"Addr" #"Flatid" (![#addr.Addr] "addr")) #()) in
    map.delete "$a0" "$a1")).

(* go: bufmap.go:34:21 *)
Definition BufMap__Ndirty : val :=
  rec: "BufMap__Ndirty" "bmap" <> :=
    exception_do (let: "bmap" := (mem.alloc "bmap") in
    let: "$r0" := (s_to_w64 (let: "$a0" := (![type.mapT #uint64T #ptrT] (struct.field_ref #BufMap #"addrs"%go (![#ptrT] "bmap"))) in
    map.len "$a0")) in
    do:  "$r0";;;
    let: "n" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("n" <-[#uint64T] "$r0");;;
    let: "$range" := (![type.mapT #uint64T #ptrT] (struct.field_ref #BufMap #"addrs"%go (![#ptrT] "bmap"))) in
    (let: "buf" := (mem.alloc (type.zero_val #ptrT)) in
    map.for_range "$range" (λ: "$key" "value",
      do:  ("buf" <-[#ptrT] "$value");;;
      do:  "$key";;;
      (if: ![#boolT] (struct.field_ref #Buf #"dirty"%go (![#ptrT] "buf"))
      then do:  ("n" <-[#uint64T] ((![#uint64T] "n") + #(W64 1)))
      else do:  #())));;;
    return: (![#uint64T] "n")).

(* go: bufmap.go:46:21 *)
Definition BufMap__DirtyBufs : val :=
  rec: "BufMap__DirtyBufs" "bmap" <> :=
    exception_do (let: "bmap" := (mem.alloc "bmap") in
    let: "bufs" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$range" := (![type.mapT #uint64T #ptrT] (struct.field_ref #BufMap #"addrs"%go (![#ptrT] "bmap"))) in
    (let: "buf" := (mem.alloc (type.zero_val #ptrT)) in
    map.for_range "$range" (λ: "$key" "value",
      do:  ("buf" <-[#ptrT] "$value");;;
      do:  "$key";;;
      (if: ![#boolT] (struct.field_ref #Buf #"dirty"%go (![#ptrT] "buf"))
      then
        let: "$r0" := (let: "$a0" := (![#sliceT] "bufs") in
        let: "$a1" := ((let: "$sl0" := (![#ptrT] "buf") in
        slice.literal #ptrT ["$sl0"])) in
        (slice.append #ptrT) "$a0" "$a1") in
        do:  ("bufs" <-[#sliceT] "$r0")
      else do:  #())));;;
    return: (![#sliceT] "bufs")).

Definition vars' : list (go_string * go_type) := [].

Definition functions' : list (go_string * val) := [("MkBuf"%go, MkBuf); ("MkBufLoad"%go, MkBufLoad); ("installOneBit"%go, installOneBit); ("installBit"%go, installBit); ("installBytes"%go, installBytes); ("MkBufMap"%go, MkBufMap)].

Definition msets' : list (go_string * (list (go_string * val))) := [("Buf"%go, []); ("Buf'ptr"%go, [("BnumGet"%go, Buf__BnumGet); ("BnumPut"%go, Buf__BnumPut); ("Install"%go, Buf__Install); ("IsDirty"%go, Buf__IsDirty); ("SetDirty"%go, Buf__SetDirty); ("WriteDirect"%go, Buf__WriteDirect)]); ("BufMap"%go, []); ("BufMap'ptr"%go, [("Del"%go, BufMap__Del); ("DirtyBufs"%go, BufMap__DirtyBufs); ("Insert"%go, BufMap__Insert); ("Lookup"%go, BufMap__Lookup); ("Ndirty"%go, BufMap__Ndirty)])].

#[global] Instance info' : PkgInfo buf.buf :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [disk.disk; marshal.marshal; addr.addr; common.common; util.util];
  |}.

Definition initialize' : val :=
  rec: "initialize'" <> :=
    globals.package_init buf.buf (λ: <>,
      exception_do (do:  util.initialize';;;
      do:  common.initialize';;;
      do:  addr.initialize';;;
      do:  marshal.initialize';;;
      do:  disk.initialize')
      ).

End code.
End buf.
