(* autogenerated from github.com/mit-pdos/go-journal/txn *)
From New.golang Require Import defn.
Require Export New.code.github_com.goose_lang.primitive.disk.
Require Export New.code.github_com.mit_pdos.go_journal.addr.
Require Export New.code.github_com.mit_pdos.go_journal.jrnl.
Require Export New.code.github_com.mit_pdos.go_journal.lockmap.
Require Export New.code.github_com.mit_pdos.go_journal.obj.
Require Export New.code.github_com.mit_pdos.go_journal.util.

Definition txn : go_string := "github.com/mit-pdos/go-journal/txn".

From New Require Import disk_prelude.
Module txn.
Section code.


Definition Log : go_type := structT [
  "log" :: ptrT;
  "locks" :: ptrT
].

Definition Txn : go_type := structT [
  "buftxn" :: ptrT;
  "locks" :: ptrT;
  "acquired" :: mapT uint64T boolT
].

(* go: txn.go:29:6 *)
Definition Init : val :=
  rec: "Init" "d" :=
    exception_do (let: "d" := (mem.alloc "d") in
    let: "twophasePre" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (let: "$log" := (let: "$a0" := (![#disk.Disk] "d") in
    (func_call #obj.obj #"MkLog"%go) "$a0") in
    let: "$locks" := ((func_call #lockmap.lockmap #"MkLockMap"%go) #()) in
    struct.make #Log [{
      "log" ::= "$log";
      "locks" ::= "$locks"
    }])) in
    do:  ("twophasePre" <-[#ptrT] "$r0");;;
    return: (![#ptrT] "twophasePre")).

(* Start a local transaction with no writes from a global Log.

   go: txn.go:38:6 *)
Definition Begin : val :=
  rec: "Begin" "tsys" :=
    exception_do (let: "tsys" := (mem.alloc "tsys") in
    let: "trans" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (let: "$buftxn" := (let: "$a0" := (![#ptrT] (struct.field_ref #Log #"log"%go (![#ptrT] "tsys"))) in
    (func_call #jrnl.jrnl #"Begin"%go) "$a0") in
    let: "$locks" := (![#ptrT] (struct.field_ref #Log #"locks"%go (![#ptrT] "tsys"))) in
    let: "$acquired" := (map.make #uint64T #boolT) in
    struct.make #Txn [{
      "buftxn" ::= "$buftxn";
      "locks" ::= "$locks";
      "acquired" ::= "$acquired"
    }])) in
    do:  ("trans" <-[#ptrT] "$r0");;;
    do:  (let: "$a0" := #(W64 5) in
    let: "$a1" := #"tp Begin: %v
    "%go in
    let: "$a2" := ((let: "$sl0" := (interface.make #txn.txn #"Txn'ptr" (![#ptrT] "trans")) in
    slice.literal #interfaceT ["$sl0"])) in
    (func_call #util.util #"DPrintf"%go) "$a0" "$a1" "$a2");;;
    return: (![#ptrT] "trans")).

(* go: txn.go:48:18 *)
Definition Log__Flush : val :=
  rec: "Log__Flush" "tsys" <> :=
    exception_do (let: "tsys" := (mem.alloc "tsys") in
    do:  ((method_call #obj #"Log'ptr" #"Flush" (![#ptrT] (struct.field_ref #Log #"log"%go (![#ptrT] "tsys")))) #())).

(* go: txn.go:52:17 *)
Definition Txn__acquireNoCheck : val :=
  rec: "Txn__acquireNoCheck" "txn" "addr" :=
    exception_do (let: "txn" := (mem.alloc "txn") in
    let: "addr" := (mem.alloc "addr") in
    let: "flatAddr" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := ((method_call #addr #"Addr" #"Flatid" (![#addr.Addr] "addr")) #()) in
    do:  ("flatAddr" <-[#uint64T] "$r0");;;
    do:  (let: "$a0" := (![#uint64T] "flatAddr") in
    (method_call #lockmap #"LockMap'ptr" #"Acquire" (![#ptrT] (struct.field_ref #Txn #"locks"%go (![#ptrT] "txn")))) "$a0");;;
    let: "$r0" := #true in
    do:  (map.insert (![type.mapT #uint64T #boolT] (struct.field_ref #Txn #"acquired"%go (![#ptrT] "txn"))) (![#uint64T] "flatAddr") "$r0")).

(* go: txn.go:58:17 *)
Definition Txn__isAlreadyAcquired : val :=
  rec: "Txn__isAlreadyAcquired" "txn" "addr" :=
    exception_do (let: "txn" := (mem.alloc "txn") in
    let: "addr" := (mem.alloc "addr") in
    let: "flatAddr" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := ((method_call #addr #"Addr" #"Flatid" (![#addr.Addr] "addr")) #()) in
    do:  ("flatAddr" <-[#uint64T] "$r0");;;
    return: (Fst (map.get (![type.mapT #uint64T #boolT] (struct.field_ref #Txn #"acquired"%go (![#ptrT] "txn"))) (![#uint64T] "flatAddr")))).

(* go: txn.go:63:17 *)
Definition Txn__Acquire : val :=
  rec: "Txn__Acquire" "txn" "addr" :=
    exception_do (let: "txn" := (mem.alloc "txn") in
    let: "addr" := (mem.alloc "addr") in
    let: "already_acquired" := (mem.alloc (type.zero_val #boolT)) in
    let: "$r0" := (let: "$a0" := (![#addr.Addr] "addr") in
    (method_call #txn.txn #"Txn'ptr" #"isAlreadyAcquired" (![#ptrT] "txn")) "$a0") in
    do:  ("already_acquired" <-[#boolT] "$r0");;;
    (if: (~ (![#boolT] "already_acquired"))
    then
      do:  (let: "$a0" := (![#addr.Addr] "addr") in
      (method_call #txn.txn #"Txn'ptr" #"acquireNoCheck" (![#ptrT] "txn")) "$a0")
    else do:  #())).

(* go: txn.go:70:17 *)
Definition Txn__ReleaseAll : val :=
  rec: "Txn__ReleaseAll" "txn" <> :=
    exception_do (let: "txn" := (mem.alloc "txn") in
    let: "$range" := (![type.mapT #uint64T #boolT] (struct.field_ref #Txn #"acquired"%go (![#ptrT] "txn"))) in
    (let: "flatAddr" := (mem.alloc (type.zero_val #uint64T)) in
    map.for_range "$range" (λ: "$key" "value",
      do:  ("flatAddr" <-[#uint64T] "$key");;;
      do:  (let: "$a0" := (![#uint64T] "flatAddr") in
      (method_call #lockmap #"LockMap'ptr" #"Release" (![#ptrT] (struct.field_ref #Txn #"locks"%go (![#ptrT] "txn")))) "$a0")))).

(* go: txn.go:76:17 *)
Definition Txn__readBufNoAcquire : val :=
  rec: "Txn__readBufNoAcquire" "txn" "addr" "sz" :=
    exception_do (let: "txn" := (mem.alloc "txn") in
    let: "sz" := (mem.alloc "sz") in
    let: "addr" := (mem.alloc "addr") in
    let: "s" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] (struct.field_ref #buf.Buf #"Data"%go (let: "$a0" := (![#addr.Addr] "addr") in
    let: "$a1" := (![#uint64T] "sz") in
    (method_call #jrnl #"Op'ptr" #"ReadBuf" (![#ptrT] (struct.field_ref #Txn #"buftxn"%go (![#ptrT] "txn")))) "$a0" "$a1"))) in
    (func_call #util.util #"CloneByteSlice"%go) "$a0") in
    do:  ("s" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "s")).

(* go: txn.go:85:17 *)
Definition Txn__ReadBuf : val :=
  rec: "Txn__ReadBuf" "txn" "addr" "sz" :=
    exception_do (let: "txn" := (mem.alloc "txn") in
    let: "sz" := (mem.alloc "sz") in
    let: "addr" := (mem.alloc "addr") in
    do:  (let: "$a0" := (![#addr.Addr] "addr") in
    (method_call #txn.txn #"Txn'ptr" #"Acquire" (![#ptrT] "txn")) "$a0");;;
    return: (let: "$a0" := (![#addr.Addr] "addr") in
     let: "$a1" := (![#uint64T] "sz") in
     (method_call #txn.txn #"Txn'ptr" #"readBufNoAcquire" (![#ptrT] "txn")) "$a0" "$a1")).

(* OverWrite writes an object to addr

   go: txn.go:91:17 *)
Definition Txn__OverWrite : val :=
  rec: "Txn__OverWrite" "txn" "addr" "sz" "data" :=
    exception_do (let: "txn" := (mem.alloc "txn") in
    let: "data" := (mem.alloc "data") in
    let: "sz" := (mem.alloc "sz") in
    let: "addr" := (mem.alloc "addr") in
    do:  (let: "$a0" := (![#addr.Addr] "addr") in
    (method_call #txn.txn #"Txn'ptr" #"Acquire" (![#ptrT] "txn")) "$a0");;;
    do:  (let: "$a0" := (![#addr.Addr] "addr") in
    let: "$a1" := (![#uint64T] "sz") in
    let: "$a2" := (![#sliceT] "data") in
    (method_call #jrnl #"Op'ptr" #"OverWrite" (![#ptrT] (struct.field_ref #Txn #"buftxn"%go (![#ptrT] "txn")))) "$a0" "$a1" "$a2")).

(* go: txn.go:96:17 *)
Definition Txn__ReadBufBit : val :=
  rec: "Txn__ReadBufBit" "txn" "addr" :=
    exception_do (let: "txn" := (mem.alloc "txn") in
    let: "addr" := (mem.alloc "addr") in
    let: "dataByte" := (mem.alloc (type.zero_val #byteT)) in
    let: "$r0" := (![#byteT] (slice.elem_ref #byteT (let: "$a0" := (![#addr.Addr] "addr") in
    let: "$a1" := #(W64 1) in
    (method_call #txn.txn #"Txn'ptr" #"ReadBuf" (![#ptrT] "txn")) "$a0" "$a1") #(W64 0))) in
    do:  ("dataByte" <-[#byteT] "$r0");;;
    return: (#(W8 1) = (((![#byteT] "dataByte") ≫ (u_to_w8 ((![#uint64T] (struct.field_ref #addr.Addr #"Off"%go "addr")) `rem` #(W64 8)))) `and` #(W8 1)))).

(* go: txn.go:101:6 *)
Definition bitToByte : val :=
  rec: "bitToByte" "off" "data" :=
    exception_do (let: "data" := (mem.alloc "data") in
    let: "off" := (mem.alloc "off") in
    (if: ![#boolT] "data"
    then return: (#(W8 1) ≪ (u_to_w8 (![#uint64T] "off")))
    else return: (#(W8 0)))).

(* go: txn.go:109:17 *)
Definition Txn__OverWriteBit : val :=
  rec: "Txn__OverWriteBit" "txn" "addr" "data" :=
    exception_do (let: "txn" := (mem.alloc "txn") in
    let: "data" := (mem.alloc "data") in
    let: "addr" := (mem.alloc "addr") in
    let: "dataBytes" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make2 #byteT #(W64 1)) in
    do:  ("dataBytes" <-[#sliceT] "$r0");;;
    let: "$r0" := (let: "$a0" := ((![#uint64T] (struct.field_ref #addr.Addr #"Off"%go "addr")) `rem` #(W64 8)) in
    let: "$a1" := (![#boolT] "data") in
    (func_call #txn.txn #"bitToByte"%go) "$a0" "$a1") in
    do:  ((slice.elem_ref #byteT (![#sliceT] "dataBytes") #(W64 0)) <-[#byteT] "$r0");;;
    do:  (let: "$a0" := (![#addr.Addr] "addr") in
    let: "$a1" := #(W64 1) in
    let: "$a2" := (![#sliceT] "dataBytes") in
    (method_call #txn.txn #"Txn'ptr" #"OverWrite" (![#ptrT] "txn")) "$a0" "$a1" "$a2")).

(* NDirty reports an upper bound on the size of this transaction when committed.

   TODO: number of locks acquired also bounds size of transaction

   The caller cannot rely on any particular properties of this function for
   safety.

   go: txn.go:121:17 *)
Definition Txn__NDirty : val :=
  rec: "Txn__NDirty" "txn" <> :=
    exception_do (let: "txn" := (mem.alloc "txn") in
    return: ((method_call #jrnl #"Op'ptr" #"NDirty" (![#ptrT] (struct.field_ref #Txn #"buftxn"%go (![#ptrT] "txn")))) #())).

(* go: txn.go:125:17 *)
Definition Txn__commitNoRelease : val :=
  rec: "Txn__commitNoRelease" "txn" "wait" :=
    exception_do (let: "txn" := (mem.alloc "txn") in
    let: "wait" := (mem.alloc "wait") in
    do:  (let: "$a0" := #(W64 5) in
    let: "$a1" := #"tp Commit %p
    "%go in
    let: "$a2" := ((let: "$sl0" := (interface.make #txn.txn #"Txn'ptr" (![#ptrT] "txn")) in
    slice.literal #interfaceT ["$sl0"])) in
    (func_call #util.util #"DPrintf"%go) "$a0" "$a1" "$a2");;;
    return: (let: "$a0" := (![#boolT] "wait") in
     (method_call #jrnl #"Op'ptr" #"CommitWait" (![#ptrT] (struct.field_ref #Txn #"buftxn"%go (![#ptrT] "txn")))) "$a0")).

(* go: txn.go:130:17 *)
Definition Txn__Commit : val :=
  rec: "Txn__Commit" "txn" "wait" :=
    exception_do (let: "txn" := (mem.alloc "txn") in
    let: "wait" := (mem.alloc "wait") in
    let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "$r0" := (let: "$a0" := (![#boolT] "wait") in
    (method_call #txn.txn #"Txn'ptr" #"commitNoRelease" (![#ptrT] "txn")) "$a0") in
    do:  ("ok" <-[#boolT] "$r0");;;
    do:  ((method_call #txn.txn #"Txn'ptr" #"ReleaseAll" (![#ptrT] "txn")) #());;;
    return: (![#boolT] "ok")).

Definition vars' : list (go_string * go_type) := [].

Definition functions' : list (go_string * val) := [("Init"%go, Init); ("Begin"%go, Begin); ("bitToByte"%go, bitToByte)].

Definition msets' : list (go_string * (list (go_string * val))) := [("Log"%go, []); ("Log'ptr"%go, [("Flush"%go, Log__Flush)]); ("Txn"%go, []); ("Txn'ptr"%go, [("Acquire"%go, Txn__Acquire); ("Commit"%go, Txn__Commit); ("NDirty"%go, Txn__NDirty); ("OverWrite"%go, Txn__OverWrite); ("OverWriteBit"%go, Txn__OverWriteBit); ("ReadBuf"%go, Txn__ReadBuf); ("ReadBufBit"%go, Txn__ReadBufBit); ("ReleaseAll"%go, Txn__ReleaseAll); ("acquireNoCheck"%go, Txn__acquireNoCheck); ("commitNoRelease"%go, Txn__commitNoRelease); ("isAlreadyAcquired"%go, Txn__isAlreadyAcquired); ("readBufNoAcquire"%go, Txn__readBufNoAcquire)])].

#[global] Instance info' : PkgInfo txn.txn :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [disk.disk; addr.addr; jrnl.jrnl; lockmap.lockmap; obj.obj; util.util];
  |}.

Definition initialize' : val :=
  rec: "initialize'" <> :=
    globals.package_init txn.txn (λ: <>,
      exception_do (do:  util.initialize';;;
      do:  obj.initialize';;;
      do:  lockmap.initialize';;;
      do:  jrnl.initialize';;;
      do:  addr.initialize';;;
      do:  disk.initialize')
      ).

End code.
End txn.
