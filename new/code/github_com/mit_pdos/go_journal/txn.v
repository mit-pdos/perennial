(* autogenerated from github.com/mit-pdos/go-journal/txn *)
Require Export New.code.github_com.goose_lang.primitive.disk.
Require Export New.code.github_com.mit_pdos.go_journal.addr.
Require Export New.code.github_com.mit_pdos.go_journal.jrnl.
Require Export New.code.github_com.mit_pdos.go_journal.lockmap.
Require Export New.code.github_com.mit_pdos.go_journal.obj.
Require Export New.code.github_com.mit_pdos.go_journal.util.
From New.golang Require Import defn.
From New Require Import disk_prelude.
Module pkg_id.
Definition txn : go_string := "github.com/mit-pdos/go-journal/txn".

End pkg_id.
Export pkg_id.
Module txn.

Definition Log {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/mit-pdos/go-journal/txn.Log"%go [].

Definition Txn {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/mit-pdos/go-journal/txn.Txn"%go [].

Definition Init {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/go-journal/txn.Init"%go.

Definition Begin {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/go-journal/txn.Begin"%go.

Definition bitToByte {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/go-journal/txn.bitToByte"%go.

(* go: txn.go:29:6 *)
Definition Initⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "d",
    exception_do (let: "d" := (GoAlloc disk.Disk "d") in
    let: "twophasePre" := (GoAlloc (go.PointerType Log) (GoZeroVal (go.PointerType Log) #())) in
    let: "$r0" := (GoAlloc Log (CompositeLiteral Log (LiteralValue [KeyedElement (Some (KeyField "log"%go)) (ElementExpression (go.PointerType obj.Log) (let: "$a0" := (![disk.Disk] "d") in
     (FuncResolve obj.MkLog [] #()) "$a0")); KeyedElement (Some (KeyField "locks"%go)) (ElementExpression (go.PointerType lockmap.LockMap) ((FuncResolve lockmap.MkLockMap [] #()) #()))]))) in
    do:  ("twophasePre" <-[go.PointerType Log] "$r0");;;
    return: (![go.PointerType Log] "twophasePre")).

(* Start a local transaction with no writes from a global Log.

   go: txn.go:38:6 *)
Definition Beginⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "tsys",
    exception_do (let: "tsys" := (GoAlloc (go.PointerType Log) "tsys") in
    let: "trans" := (GoAlloc (go.PointerType Txn) (GoZeroVal (go.PointerType Txn) #())) in
    let: "$r0" := (GoAlloc Txn (CompositeLiteral Txn (LiteralValue [KeyedElement (Some (KeyField "buftxn"%go)) (ElementExpression (go.PointerType jrnl.Op) (let: "$a0" := (![go.PointerType obj.Log] (StructFieldRef Log "log"%go (![go.PointerType Log] "tsys"))) in
     (FuncResolve jrnl.Begin [] #()) "$a0")); KeyedElement (Some (KeyField "locks"%go)) (ElementExpression (go.PointerType lockmap.LockMap) (![go.PointerType lockmap.LockMap] (StructFieldRef Log "locks"%go (![go.PointerType Log] "tsys")))); KeyedElement (Some (KeyField "acquired"%go)) (ElementExpression (go.MapType go.uint64 go.bool) ((FuncResolve go.make1 [go.MapType go.uint64 go.bool] #()) #()))]))) in
    do:  ("trans" <-[go.PointerType Txn] "$r0");;;
    do:  (let: "$a0" := #(W64 5) in
    let: "$a1" := #"tp Begin: %v
    "%go in
    let: "$a2" := ((let: "$sl0" := (Convert (go.PointerType Txn) (go.InterfaceType []) (![go.PointerType Txn] "trans")) in
    CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0")]))) in
    (FuncResolve util.DPrintf [] #()) "$a0" "$a1" "$a2");;;
    return: (![go.PointerType Txn] "trans")).

(* go: txn.go:48:18 *)
Definition Log__Flushⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "tsys" <>,
    exception_do (let: "tsys" := (GoAlloc (go.PointerType Log) "tsys") in
    do:  ((MethodResolve (go.PointerType obj.Log) "Flush"%go (![go.PointerType obj.Log] (StructFieldRef Log "log"%go (![go.PointerType Log] "tsys")))) #());;;
    return: #()).

(* go: txn.go:52:17 *)
Definition Txn__acquireNoCheckⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "txn" "addr",
    exception_do (let: "txn" := (GoAlloc (go.PointerType Txn) "txn") in
    let: "addr" := (GoAlloc addr.Addr "addr") in
    let: "flatAddr" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := ((MethodResolve addr.Addr "Flatid"%go (![addr.Addr] "addr")) #()) in
    do:  ("flatAddr" <-[go.uint64] "$r0");;;
    do:  (let: "$a0" := (![go.uint64] "flatAddr") in
    (MethodResolve (go.PointerType lockmap.LockMap) "Acquire"%go (![go.PointerType lockmap.LockMap] (StructFieldRef Txn "locks"%go (![go.PointerType Txn] "txn")))) "$a0");;;
    let: "$r0" := #true in
    do:  (map.insert go.uint64 (![go.MapType go.uint64 go.bool] (StructFieldRef Txn "acquired"%go (![go.PointerType Txn] "txn"))) (![go.uint64] "flatAddr") "$r0");;;
    return: #()).

(* go: txn.go:58:17 *)
Definition Txn__isAlreadyAcquiredⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "txn" "addr",
    exception_do (let: "txn" := (GoAlloc (go.PointerType Txn) "txn") in
    let: "addr" := (GoAlloc addr.Addr "addr") in
    let: "flatAddr" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := ((MethodResolve addr.Addr "Flatid"%go (![addr.Addr] "addr")) #()) in
    do:  ("flatAddr" <-[go.uint64] "$r0");;;
    return: (map.lookup1 go.uint64 go.bool (![go.MapType go.uint64 go.bool] (StructFieldRef Txn "acquired"%go (![go.PointerType Txn] "txn"))) (![go.uint64] "flatAddr"))).

(* go: txn.go:63:17 *)
Definition Txn__Acquireⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "txn" "addr",
    exception_do (let: "txn" := (GoAlloc (go.PointerType Txn) "txn") in
    let: "addr" := (GoAlloc addr.Addr "addr") in
    let: "already_acquired" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := (let: "$a0" := (![addr.Addr] "addr") in
    (MethodResolve (go.PointerType Txn) "isAlreadyAcquired"%go (![go.PointerType Txn] "txn")) "$a0") in
    do:  ("already_acquired" <-[go.bool] "$r0");;;
    (if: (~ (![go.bool] "already_acquired"))
    then
      do:  (let: "$a0" := (![addr.Addr] "addr") in
      (MethodResolve (go.PointerType Txn) "acquireNoCheck"%go (![go.PointerType Txn] "txn")) "$a0")
    else do:  #());;;
    return: #()).

(* go: txn.go:70:17 *)
Definition Txn__ReleaseAllⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "txn" <>,
    exception_do (let: "txn" := (GoAlloc (go.PointerType Txn) "txn") in
    let: "$range" := (![go.MapType go.uint64 go.bool] (StructFieldRef Txn "acquired"%go (![go.PointerType Txn] "txn"))) in
    (let: "flatAddr" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    map.for_range go.uint64 go.bool "$range" (λ: "$key" "value",
      do:  ("flatAddr" <-[go.uint64] "$key");;;
      do:  (let: "$a0" := (![go.uint64] "flatAddr") in
      (MethodResolve (go.PointerType lockmap.LockMap) "Release"%go (![go.PointerType lockmap.LockMap] (StructFieldRef Txn "locks"%go (![go.PointerType Txn] "txn")))) "$a0")));;;
    return: #()).

(* go: txn.go:76:17 *)
Definition Txn__readBufNoAcquireⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "txn" "addr" "sz",
    exception_do (let: "txn" := (GoAlloc (go.PointerType Txn) "txn") in
    let: "sz" := (GoAlloc go.uint64 "sz") in
    let: "addr" := (GoAlloc addr.Addr "addr") in
    let: "s" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] (StructFieldRef buf.Buf "Data"%go (let: "$a0" := (![addr.Addr] "addr") in
    let: "$a1" := (![go.uint64] "sz") in
    (MethodResolve (go.PointerType jrnl.Op) "ReadBuf"%go (![go.PointerType jrnl.Op] (StructFieldRef Txn "buftxn"%go (![go.PointerType Txn] "txn")))) "$a0" "$a1"))) in
    (FuncResolve util.CloneByteSlice [] #()) "$a0") in
    do:  ("s" <-[go.SliceType go.byte] "$r0");;;
    return: (![go.SliceType go.byte] "s")).

(* go: txn.go:85:17 *)
Definition Txn__ReadBufⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "txn" "addr" "sz",
    exception_do (let: "txn" := (GoAlloc (go.PointerType Txn) "txn") in
    let: "sz" := (GoAlloc go.uint64 "sz") in
    let: "addr" := (GoAlloc addr.Addr "addr") in
    do:  (let: "$a0" := (![addr.Addr] "addr") in
    (MethodResolve (go.PointerType Txn) "Acquire"%go (![go.PointerType Txn] "txn")) "$a0");;;
    return: (let: "$a0" := (![addr.Addr] "addr") in
     let: "$a1" := (![go.uint64] "sz") in
     (MethodResolve (go.PointerType Txn) "readBufNoAcquire"%go (![go.PointerType Txn] "txn")) "$a0" "$a1")).

(* OverWrite writes an object to addr

   go: txn.go:91:17 *)
Definition Txn__OverWriteⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "txn" "addr" "sz" "data",
    exception_do (let: "txn" := (GoAlloc (go.PointerType Txn) "txn") in
    let: "data" := (GoAlloc (go.SliceType go.byte) "data") in
    let: "sz" := (GoAlloc go.uint64 "sz") in
    let: "addr" := (GoAlloc addr.Addr "addr") in
    do:  (let: "$a0" := (![addr.Addr] "addr") in
    (MethodResolve (go.PointerType Txn) "Acquire"%go (![go.PointerType Txn] "txn")) "$a0");;;
    do:  (let: "$a0" := (![addr.Addr] "addr") in
    let: "$a1" := (![go.uint64] "sz") in
    let: "$a2" := (![go.SliceType go.byte] "data") in
    (MethodResolve (go.PointerType jrnl.Op) "OverWrite"%go (![go.PointerType jrnl.Op] (StructFieldRef Txn "buftxn"%go (![go.PointerType Txn] "txn")))) "$a0" "$a1" "$a2");;;
    return: #()).

(* go: txn.go:96:17 *)
Definition Txn__ReadBufBitⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "txn" "addr",
    exception_do (let: "txn" := (GoAlloc (go.PointerType Txn) "txn") in
    let: "addr" := (GoAlloc addr.Addr "addr") in
    let: "dataByte" := (GoAlloc go.byte (GoZeroVal go.byte #())) in
    let: "$r0" := (![go.byte] (IndexRef (go.SliceType go.byte) (let: "$a0" := (![addr.Addr] "addr") in
     let: "$a1" := #(W64 1) in
     (MethodResolve (go.PointerType Txn) "ReadBuf"%go (![go.PointerType Txn] "txn")) "$a0" "$a1", #(W64 0)))) in
    do:  ("dataByte" <-[go.byte] "$r0");;;
    return: (#(W8 1) =⟨go.byte⟩ (((![go.byte] "dataByte") >>⟨go.byte⟩ (Convert go.uint64 go.byte ((![go.uint64] (StructFieldRef addr.Addr "Off"%go "addr")) %⟨go.uint64⟩ #(W64 8)))) &⟨go.byte⟩ #(W8 1)))).

(* go: txn.go:101:6 *)
Definition bitToByteⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "off" "data",
    exception_do (let: "data" := (GoAlloc go.bool "data") in
    let: "off" := (GoAlloc go.uint64 "off") in
    (if: ![go.bool] "data"
    then return: (#(W8 1) <<⟨go.byte⟩ (Convert go.uint64 go.byte (![go.uint64] "off")))
    else return: (#(W8 0)))).

(* go: txn.go:109:17 *)
Definition Txn__OverWriteBitⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "txn" "addr" "data",
    exception_do (let: "txn" := (GoAlloc (go.PointerType Txn) "txn") in
    let: "data" := (GoAlloc go.bool "data") in
    let: "addr" := (GoAlloc addr.Addr "addr") in
    let: "dataBytes" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) #(W64 1)) in
    do:  ("dataBytes" <-[go.SliceType go.byte] "$r0");;;
    let: "$r0" := (let: "$a0" := ((![go.uint64] (StructFieldRef addr.Addr "Off"%go "addr")) %⟨go.uint64⟩ #(W64 8)) in
    let: "$a1" := (![go.bool] "data") in
    (FuncResolve bitToByte [] #()) "$a0" "$a1") in
    do:  ((IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "dataBytes", #(W64 0))) <-[go.byte] "$r0");;;
    do:  (let: "$a0" := (![addr.Addr] "addr") in
    let: "$a1" := #(W64 1) in
    let: "$a2" := (![go.SliceType go.byte] "dataBytes") in
    (MethodResolve (go.PointerType Txn) "OverWrite"%go (![go.PointerType Txn] "txn")) "$a0" "$a1" "$a2");;;
    return: #()).

(* NDirty reports an upper bound on the size of this transaction when committed.

   TODO: number of locks acquired also bounds size of transaction

   The caller cannot rely on any particular properties of this function for
   safety.

   go: txn.go:121:17 *)
Definition Txn__NDirtyⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "txn" <>,
    exception_do (let: "txn" := (GoAlloc (go.PointerType Txn) "txn") in
    return: ((MethodResolve (go.PointerType jrnl.Op) "NDirty"%go (![go.PointerType jrnl.Op] (StructFieldRef Txn "buftxn"%go (![go.PointerType Txn] "txn")))) #())).

(* go: txn.go:125:17 *)
Definition Txn__commitNoReleaseⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "txn" "wait",
    exception_do (let: "txn" := (GoAlloc (go.PointerType Txn) "txn") in
    let: "wait" := (GoAlloc go.bool "wait") in
    do:  (let: "$a0" := #(W64 5) in
    let: "$a1" := #"tp Commit %p
    "%go in
    let: "$a2" := ((let: "$sl0" := (Convert (go.PointerType Txn) (go.InterfaceType []) (![go.PointerType Txn] "txn")) in
    CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0")]))) in
    (FuncResolve util.DPrintf [] #()) "$a0" "$a1" "$a2");;;
    return: (let: "$a0" := (![go.bool] "wait") in
     (MethodResolve (go.PointerType jrnl.Op) "CommitWait"%go (![go.PointerType jrnl.Op] (StructFieldRef Txn "buftxn"%go (![go.PointerType Txn] "txn")))) "$a0")).

(* go: txn.go:130:17 *)
Definition Txn__Commitⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "txn" "wait",
    exception_do (let: "txn" := (GoAlloc (go.PointerType Txn) "txn") in
    let: "wait" := (GoAlloc go.bool "wait") in
    let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := (let: "$a0" := (![go.bool] "wait") in
    (MethodResolve (go.PointerType Txn) "commitNoRelease"%go (![go.PointerType Txn] "txn")) "$a0") in
    do:  ("ok" <-[go.bool] "$r0");;;
    do:  ((MethodResolve (go.PointerType Txn) "ReleaseAll"%go (![go.PointerType Txn] "txn")) #());;;
    return: (![go.bool] "ok")).

#[global] Instance info' : PkgInfo pkg_id.txn :=
{|
  pkg_imported_pkgs := [code.github_com.goose_lang.primitive.disk.pkg_id.disk; code.github_com.mit_pdos.go_journal.addr.pkg_id.addr; code.github_com.mit_pdos.go_journal.jrnl.pkg_id.jrnl; code.github_com.mit_pdos.go_journal.lockmap.pkg_id.lockmap; code.github_com.mit_pdos.go_journal.obj.pkg_id.obj; code.github_com.mit_pdos.go_journal.util.pkg_id.util]
|}.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init pkg_id.txn (λ: <>,
      exception_do (do:  (util.initialize' #());;;
      do:  (obj.initialize' #());;;
      do:  (lockmap.initialize' #());;;
      do:  (jrnl.initialize' #());;;
      do:  (addr.initialize' #());;;
      do:  (disk.initialize' #()))
      ).

Module Log.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  log' : loc;
  locks' : loc;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End Log.

Definition Log'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "log"%go (go.PointerType obj.Log));
  (go.FieldDecl "locks"%go (go.PointerType lockmap.LockMap))
].
Program Definition Log'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (Log'fds_unsealed).
Global Instance equals_unfold_Log {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Log'fds =→ Log'fds_unsealed.
Proof. rewrite /Log'fds seal_eq //. Qed.

Definition Logⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (Log'fds).

Class Log_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Log_type_repr  :: go.TypeReprUnderlying Logⁱᵐᵖˡ Log.t;
  #[global] Log_underlying :: (Log) <u (Logⁱᵐᵖˡ);
  #[global] Log_get_log (x : Log.t) :: ⟦StructFieldGet (Logⁱᵐᵖˡ) "log", #x⟧ ⤳[under] #x.(Log.log');
  #[global] Log_set_log (x : Log.t) y :: ⟦StructFieldSet (Logⁱᵐᵖˡ) "log", (#x, #y)⟧ ⤳[under] #(x <|Log.log' := y|>);
  #[global] Log_get_locks (x : Log.t) :: ⟦StructFieldGet (Logⁱᵐᵖˡ) "locks", #x⟧ ⤳[under] #x.(Log.locks');
  #[global] Log_set_locks (x : Log.t) y :: ⟦StructFieldSet (Logⁱᵐᵖˡ) "locks", (#x, #y)⟧ ⤳[under] #(x <|Log.locks' := y|>);
  #[global] Log'ptr_Flush_unfold :: MethodUnfold (go.PointerType (Log)) "Flush" (Log__Flushⁱᵐᵖˡ);
}.

Module Txn.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  buftxn' : loc;
  locks' : loc;
  acquired' : map.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End Txn.

Definition Txn'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "buftxn"%go (go.PointerType jrnl.Op));
  (go.FieldDecl "locks"%go (go.PointerType lockmap.LockMap));
  (go.FieldDecl "acquired"%go (go.MapType go.uint64 go.bool))
].
Program Definition Txn'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (Txn'fds_unsealed).
Global Instance equals_unfold_Txn {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Txn'fds =→ Txn'fds_unsealed.
Proof. rewrite /Txn'fds seal_eq //. Qed.

Definition Txnⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (Txn'fds).

Class Txn_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Txn_type_repr  :: go.TypeReprUnderlying Txnⁱᵐᵖˡ Txn.t;
  #[global] Txn_underlying :: (Txn) <u (Txnⁱᵐᵖˡ);
  #[global] Txn_get_buftxn (x : Txn.t) :: ⟦StructFieldGet (Txnⁱᵐᵖˡ) "buftxn", #x⟧ ⤳[under] #x.(Txn.buftxn');
  #[global] Txn_set_buftxn (x : Txn.t) y :: ⟦StructFieldSet (Txnⁱᵐᵖˡ) "buftxn", (#x, #y)⟧ ⤳[under] #(x <|Txn.buftxn' := y|>);
  #[global] Txn_get_locks (x : Txn.t) :: ⟦StructFieldGet (Txnⁱᵐᵖˡ) "locks", #x⟧ ⤳[under] #x.(Txn.locks');
  #[global] Txn_set_locks (x : Txn.t) y :: ⟦StructFieldSet (Txnⁱᵐᵖˡ) "locks", (#x, #y)⟧ ⤳[under] #(x <|Txn.locks' := y|>);
  #[global] Txn_get_acquired (x : Txn.t) :: ⟦StructFieldGet (Txnⁱᵐᵖˡ) "acquired", #x⟧ ⤳[under] #x.(Txn.acquired');
  #[global] Txn_set_acquired (x : Txn.t) y :: ⟦StructFieldSet (Txnⁱᵐᵖˡ) "acquired", (#x, #y)⟧ ⤳[under] #(x <|Txn.acquired' := y|>);
  #[global] Txn'ptr_Acquire_unfold :: MethodUnfold (go.PointerType (Txn)) "Acquire" (Txn__Acquireⁱᵐᵖˡ);
  #[global] Txn'ptr_Commit_unfold :: MethodUnfold (go.PointerType (Txn)) "Commit" (Txn__Commitⁱᵐᵖˡ);
  #[global] Txn'ptr_NDirty_unfold :: MethodUnfold (go.PointerType (Txn)) "NDirty" (Txn__NDirtyⁱᵐᵖˡ);
  #[global] Txn'ptr_OverWrite_unfold :: MethodUnfold (go.PointerType (Txn)) "OverWrite" (Txn__OverWriteⁱᵐᵖˡ);
  #[global] Txn'ptr_OverWriteBit_unfold :: MethodUnfold (go.PointerType (Txn)) "OverWriteBit" (Txn__OverWriteBitⁱᵐᵖˡ);
  #[global] Txn'ptr_ReadBuf_unfold :: MethodUnfold (go.PointerType (Txn)) "ReadBuf" (Txn__ReadBufⁱᵐᵖˡ);
  #[global] Txn'ptr_ReadBufBit_unfold :: MethodUnfold (go.PointerType (Txn)) "ReadBufBit" (Txn__ReadBufBitⁱᵐᵖˡ);
  #[global] Txn'ptr_ReleaseAll_unfold :: MethodUnfold (go.PointerType (Txn)) "ReleaseAll" (Txn__ReleaseAllⁱᵐᵖˡ);
  #[global] Txn'ptr_acquireNoCheck_unfold :: MethodUnfold (go.PointerType (Txn)) "acquireNoCheck" (Txn__acquireNoCheckⁱᵐᵖˡ);
  #[global] Txn'ptr_commitNoRelease_unfold :: MethodUnfold (go.PointerType (Txn)) "commitNoRelease" (Txn__commitNoReleaseⁱᵐᵖˡ);
  #[global] Txn'ptr_isAlreadyAcquired_unfold :: MethodUnfold (go.PointerType (Txn)) "isAlreadyAcquired" (Txn__isAlreadyAcquiredⁱᵐᵖˡ);
  #[global] Txn'ptr_readBufNoAcquire_unfold :: MethodUnfold (go.PointerType (Txn)) "readBufNoAcquire" (Txn__readBufNoAcquireⁱᵐᵖˡ);
}.

Class Assumptions `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Log_instance :: Log_Assumptions;
  #[global] Txn_instance :: Txn_Assumptions;
  #[global] Init_unfold :: FuncUnfold Init [] (Initⁱᵐᵖˡ);
  #[global] Begin_unfold :: FuncUnfold Begin [] (Beginⁱᵐᵖˡ);
  #[global] bitToByte_unfold :: FuncUnfold bitToByte [] (bitToByteⁱᵐᵖˡ);
  #[global] import_disk_Assumption :: disk.Assumptions;
  #[global] import_addr_Assumption :: addr.Assumptions;
  #[global] import_jrnl_Assumption :: jrnl.Assumptions;
  #[global] import_lockmap_Assumption :: lockmap.Assumptions;
  #[global] import_obj_Assumption :: obj.Assumptions;
  #[global] import_util_Assumption :: util.Assumptions;
}.
End txn.
