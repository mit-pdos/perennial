(* autogenerated from github.com/mit-pdos/go-journal/jrnl_replication *)
Require Export New.code.sync.
Require Export New.code.github_com.goose_lang.primitive.disk.
Require Export New.code.github_com.mit_pdos.go_journal.addr.
Require Export New.code.github_com.mit_pdos.go_journal.common.
Require Export New.code.github_com.mit_pdos.go_journal.jrnl.
Require Export New.code.github_com.mit_pdos.go_journal.obj.
Require Export New.code.github_com.mit_pdos.go_journal.util.
From New.golang Require Import defn.
From New Require Import disk_prelude.
Module pkg_id.
Definition replicated_block : go_string := "github.com/mit-pdos/go-journal/jrnl_replication".

End pkg_id.
Export pkg_id.
Module replicated_block.

Definition RepBlock {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/mit-pdos/go-journal/jrnl_replication.RepBlock"%go [].

Definition Open {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/go-journal/jrnl_replication.Open"%go.

(* go: jrnl_replication.go:23:6 *)
Definition Openⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "txn" "a",
    exception_do (let: "a" := (GoAlloc common.Bnum "a") in
    let: "txn" := (GoAlloc (go.PointerType obj.Log) "txn") in
    return: (GoAlloc RepBlock (let: "$v0" := (![go.PointerType obj.Log] "txn") in
     let: "$v1" := (GoAlloc sync.Mutex (GoZeroVal sync.Mutex #())) in
     let: "$v2" := (let: "$a0" := (![common.Bnum] "a") in
     let: "$a1" := #(W64 0) in
     (FuncResolve addr.MkAddr [] #()) "$a0" "$a1") in
     let: "$v3" := (let: "$a0" := ((![common.Bnum] "a") +⟨go.uint64⟩ #(W64 1)) in
     let: "$a1" := #(W64 0) in
     (FuncResolve addr.MkAddr [] #()) "$a0" "$a1") in
     CompositeLiteral RepBlock (LiteralValue [KeyedElement (Some (KeyField "txn"%go)) (ElementExpression (go.PointerType obj.Log) "$v0"); KeyedElement (Some (KeyField "m"%go)) (ElementExpression (go.PointerType sync.Mutex) "$v1"); KeyedElement (Some (KeyField "a0"%go)) (ElementExpression addr.Addr "$v2"); KeyedElement (Some (KeyField "a1"%go)) (ElementExpression addr.Addr "$v3")])))).

(* can fail in principle if CommitWait fails,
   but that's really impossible since it's an empty transaction

   go: jrnl_replication.go:34:21 *)
Definition RepBlock__Readⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "rb" <>,
    exception_do (let: "rb" := (GoAlloc (go.PointerType RepBlock) "rb") in
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] (StructFieldRef RepBlock "m"%go (![go.PointerType RepBlock] "rb")))) #());;;
    let: "tx" := (GoAlloc (go.PointerType jrnl.Op) (GoZeroVal (go.PointerType jrnl.Op) #())) in
    let: "$r0" := (let: "$a0" := (![go.PointerType obj.Log] (StructFieldRef RepBlock "txn"%go (![go.PointerType RepBlock] "rb"))) in
    (FuncResolve jrnl.Begin [] #()) "$a0") in
    do:  ("tx" <-[go.PointerType jrnl.Op] "$r0");;;
    let: "buf" := (GoAlloc (go.PointerType buf.Buf) (GoZeroVal (go.PointerType buf.Buf) #())) in
    let: "$r0" := (let: "$a0" := (![addr.Addr] (StructFieldRef RepBlock "a0"%go (![go.PointerType RepBlock] "rb"))) in
    let: "$a1" := (#(W64 8) *⟨go.uint64⟩ disk.BlockSize) in
    (MethodResolve (go.PointerType jrnl.Op) "ReadBuf"%go (![go.PointerType jrnl.Op] "tx")) "$a0" "$a1") in
    do:  ("buf" <-[go.PointerType buf.Buf] "$r0");;;
    let: "b" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] (StructFieldRef buf.Buf "Data"%go (![go.PointerType buf.Buf] "buf"))) in
    (FuncResolve util.CloneByteSlice [] #()) "$a0") in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := (let: "$a0" := #true in
    (MethodResolve (go.PointerType jrnl.Op) "CommitWait"%go (![go.PointerType jrnl.Op] "tx")) "$a0") in
    do:  ("ok" <-[go.bool] "$r0");;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef RepBlock "m"%go (![go.PointerType RepBlock] "rb")))) #());;;
    return: (![go.SliceType go.byte] "b", ![go.bool] "ok")).

(* go: jrnl_replication.go:45:21 *)
Definition RepBlock__Writeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "rb" "b",
    exception_do (let: "rb" := (GoAlloc (go.PointerType RepBlock) "rb") in
    let: "b" := (GoAlloc disk.Block "b") in
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] (StructFieldRef RepBlock "m"%go (![go.PointerType RepBlock] "rb")))) #());;;
    let: "tx" := (GoAlloc (go.PointerType jrnl.Op) (GoZeroVal (go.PointerType jrnl.Op) #())) in
    let: "$r0" := (let: "$a0" := (![go.PointerType obj.Log] (StructFieldRef RepBlock "txn"%go (![go.PointerType RepBlock] "rb"))) in
    (FuncResolve jrnl.Begin [] #()) "$a0") in
    do:  ("tx" <-[go.PointerType jrnl.Op] "$r0");;;
    do:  (let: "$a0" := (![addr.Addr] (StructFieldRef RepBlock "a0"%go (![go.PointerType RepBlock] "rb"))) in
    let: "$a1" := (#(W64 8) *⟨go.uint64⟩ disk.BlockSize) in
    let: "$a2" := (![disk.Block] "b") in
    (MethodResolve (go.PointerType jrnl.Op) "OverWrite"%go (![go.PointerType jrnl.Op] "tx")) "$a0" "$a1" "$a2");;;
    do:  (let: "$a0" := (![addr.Addr] (StructFieldRef RepBlock "a1"%go (![go.PointerType RepBlock] "rb"))) in
    let: "$a1" := (#(W64 8) *⟨go.uint64⟩ disk.BlockSize) in
    let: "$a2" := (![disk.Block] "b") in
    (MethodResolve (go.PointerType jrnl.Op) "OverWrite"%go (![go.PointerType jrnl.Op] "tx")) "$a0" "$a1" "$a2");;;
    let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := (let: "$a0" := #true in
    (MethodResolve (go.PointerType jrnl.Op) "CommitWait"%go (![go.PointerType jrnl.Op] "tx")) "$a0") in
    do:  ("ok" <-[go.bool] "$r0");;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef RepBlock "m"%go (![go.PointerType RepBlock] "rb")))) #());;;
    return: (![go.bool] "ok")).

#[global] Instance info' : PkgInfo pkg_id.replicated_block :=
{|
  pkg_imported_pkgs := [code.sync.pkg_id.sync; code.github_com.goose_lang.primitive.disk.pkg_id.disk; code.github_com.mit_pdos.go_journal.addr.pkg_id.addr; code.github_com.mit_pdos.go_journal.common.pkg_id.common; code.github_com.mit_pdos.go_journal.jrnl.pkg_id.jrnl; code.github_com.mit_pdos.go_journal.obj.pkg_id.obj; code.github_com.mit_pdos.go_journal.util.pkg_id.util]
|}.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init pkg_id.replicated_block (λ: <>,
      exception_do (do:  (util.initialize' #());;;
      do:  (obj.initialize' #());;;
      do:  (jrnl.initialize' #());;;
      do:  (common.initialize' #());;;
      do:  (addr.initialize' #());;;
      do:  (disk.initialize' #());;;
      do:  (sync.initialize' #()))
      ).

Module RepBlock.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  txn' : loc;
  m' : loc;
  a0' : addr.Addr.t;
  a1' : addr.Addr.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End RepBlock.

Definition RepBlock'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "txn"%go (go.PointerType obj.Log));
  (go.FieldDecl "m"%go (go.PointerType sync.Mutex));
  (go.FieldDecl "a0"%go addr.Addr);
  (go.FieldDecl "a1"%go addr.Addr)
].
Program Definition RepBlock'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (RepBlock'fds_unsealed).
Global Instance equals_unfold_RepBlock {ext : ffi_syntax} {go_gctx : GoGlobalContext} : RepBlock'fds =→ RepBlock'fds_unsealed.
Proof. rewrite /RepBlock'fds seal_eq //. Qed.

Definition RepBlockⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (RepBlock'fds).

Class RepBlock_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] RepBlock_type_repr  :: go.TypeReprUnderlying RepBlockⁱᵐᵖˡ RepBlock.t;
  #[global] RepBlock_underlying :: (RepBlock) <u (RepBlockⁱᵐᵖˡ);
  #[global] RepBlock_get_txn (x : RepBlock.t) :: ⟦StructFieldGet (RepBlockⁱᵐᵖˡ) "txn", #x⟧ ⤳[under] #x.(RepBlock.txn');
  #[global] RepBlock_set_txn (x : RepBlock.t) y :: ⟦StructFieldSet (RepBlockⁱᵐᵖˡ) "txn", (#x, #y)⟧ ⤳[under] #(x <|RepBlock.txn' := y|>);
  #[global] RepBlock_get_m (x : RepBlock.t) :: ⟦StructFieldGet (RepBlockⁱᵐᵖˡ) "m", #x⟧ ⤳[under] #x.(RepBlock.m');
  #[global] RepBlock_set_m (x : RepBlock.t) y :: ⟦StructFieldSet (RepBlockⁱᵐᵖˡ) "m", (#x, #y)⟧ ⤳[under] #(x <|RepBlock.m' := y|>);
  #[global] RepBlock_get_a0 (x : RepBlock.t) :: ⟦StructFieldGet (RepBlockⁱᵐᵖˡ) "a0", #x⟧ ⤳[under] #x.(RepBlock.a0');
  #[global] RepBlock_set_a0 (x : RepBlock.t) y :: ⟦StructFieldSet (RepBlockⁱᵐᵖˡ) "a0", (#x, #y)⟧ ⤳[under] #(x <|RepBlock.a0' := y|>);
  #[global] RepBlock_get_a1 (x : RepBlock.t) :: ⟦StructFieldGet (RepBlockⁱᵐᵖˡ) "a1", #x⟧ ⤳[under] #x.(RepBlock.a1');
  #[global] RepBlock_set_a1 (x : RepBlock.t) y :: ⟦StructFieldSet (RepBlockⁱᵐᵖˡ) "a1", (#x, #y)⟧ ⤳[under] #(x <|RepBlock.a1' := y|>);
  #[global] RepBlock'ptr_Read_unfold :: MethodUnfold (go.PointerType (RepBlock)) "Read" (RepBlock__Readⁱᵐᵖˡ);
  #[global] RepBlock'ptr_Write_unfold :: MethodUnfold (go.PointerType (RepBlock)) "Write" (RepBlock__Writeⁱᵐᵖˡ);
}.

Class Assumptions `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] RepBlock_instance :: RepBlock_Assumptions;
  #[global] Open_unfold :: FuncUnfold Open [] (Openⁱᵐᵖˡ);
  #[global] import_sync_Assumption :: sync.Assumptions;
  #[global] import_disk_Assumption :: disk.Assumptions;
  #[global] import_addr_Assumption :: addr.Assumptions;
  #[global] import_common_Assumption :: common.Assumptions;
  #[global] import_jrnl_Assumption :: jrnl.Assumptions;
  #[global] import_obj_Assumption :: obj.Assumptions;
  #[global] import_util_Assumption :: util.Assumptions;
}.
End replicated_block.
