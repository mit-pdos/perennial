(* autogenerated from github.com/mit-pdos/go-journal/jrnl_replication *)
Require Export New.code.github_com.goose_lang.primitive.disk.
Require Export New.code.github_com.mit_pdos.go_journal.addr.
Require Export New.code.github_com.mit_pdos.go_journal.common.
Require Export New.code.github_com.mit_pdos.go_journal.jrnl.
Require Export New.code.github_com.mit_pdos.go_journal.obj.
Require Export New.code.github_com.mit_pdos.go_journal.util.
Require Export New.code.sync.

From New.golang Require Import defn.
Definition replicated_block : go_string := "github.com/mit-pdos/go-journal/jrnl_replication".

From New Require Import disk_prelude.
Module replicated_block.

Module RepBlock. Definition id : go_string := "github.com/mit-pdos/go-journal/jrnl_replication.RepBlock"%go. End RepBlock.

Section code.


Definition RepBlock : go_type := structT [
  "txn" :: ptrT;
  "m" :: ptrT;
  "a0" :: addr.Addr;
  "a1" :: addr.Addr
].
#[global] Typeclasses Opaque RepBlock.
#[global] Opaque RepBlock.

Definition Open : go_string := "github.com/mit-pdos/go-journal/jrnl_replication.Open"%go.

(* go: jrnl_replication.go:23:6 *)
Definition Openⁱᵐᵖˡ : val :=
  λ: "txn" "a",
    exception_do (let: "a" := (mem.alloc "a") in
    let: "txn" := (mem.alloc "txn") in
    return: (mem.alloc (let: "$txn" := (![#ptrT] "txn") in
     let: "$m" := (mem.alloc (type.zero_val #sync.Mutex)) in
     let: "$a0" := (let: "$a0" := (![#uint64T] "a") in
     let: "$a1" := #(W64 0) in
     (func_call #addr.MkAddr) "$a0" "$a1") in
     let: "$a1" := (let: "$a0" := ((![#uint64T] "a") + #(W64 1)) in
     let: "$a1" := #(W64 0) in
     (func_call #addr.MkAddr) "$a0" "$a1") in
     struct.make #RepBlock [{
       "txn" ::= "$txn";
       "m" ::= "$m";
       "a0" ::= "$a0";
       "a1" ::= "$a1"
     }]))).

(* can fail in principle if CommitWait fails,
   but that's really impossible since it's an empty transaction

   go: jrnl_replication.go:34:21 *)
Definition RepBlock__Readⁱᵐᵖˡ : val :=
  λ: "rb" <>,
    exception_do (let: "rb" := (mem.alloc "rb") in
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] (struct.field_ref #RepBlock #"m"%go (![#ptrT] "rb")))) #());;;
    let: "tx" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := (![#ptrT] (struct.field_ref #RepBlock #"txn"%go (![#ptrT] "rb"))) in
    (func_call #jrnl.Begin) "$a0") in
    do:  ("tx" <-[#ptrT] "$r0");;;
    let: "buf" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := (![#addr.Addr] (struct.field_ref #RepBlock #"a0"%go (![#ptrT] "rb"))) in
    let: "$a1" := (#(W64 8) * disk.BlockSize) in
    (method_call #(ptrT.id jrnl.Op.id) #"ReadBuf"%go (![#ptrT] "tx")) "$a0" "$a1") in
    do:  ("buf" <-[#ptrT] "$r0");;;
    let: "b" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] (struct.field_ref #buf.Buf #"Data"%go (![#ptrT] "buf"))) in
    (func_call #util.CloneByteSlice) "$a0") in
    do:  ("b" <-[#sliceT] "$r0");;;
    let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "$r0" := (let: "$a0" := #true in
    (method_call #(ptrT.id jrnl.Op.id) #"CommitWait"%go (![#ptrT] "tx")) "$a0") in
    do:  ("ok" <-[#boolT] "$r0");;;
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref #RepBlock #"m"%go (![#ptrT] "rb")))) #());;;
    return: (![#sliceT] "b", ![#boolT] "ok")).

(* go: jrnl_replication.go:45:21 *)
Definition RepBlock__Writeⁱᵐᵖˡ : val :=
  λ: "rb" "b",
    exception_do (let: "rb" := (mem.alloc "rb") in
    let: "b" := (mem.alloc "b") in
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] (struct.field_ref #RepBlock #"m"%go (![#ptrT] "rb")))) #());;;
    let: "tx" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := (![#ptrT] (struct.field_ref #RepBlock #"txn"%go (![#ptrT] "rb"))) in
    (func_call #jrnl.Begin) "$a0") in
    do:  ("tx" <-[#ptrT] "$r0");;;
    do:  (let: "$a0" := (![#addr.Addr] (struct.field_ref #RepBlock #"a0"%go (![#ptrT] "rb"))) in
    let: "$a1" := (#(W64 8) * disk.BlockSize) in
    let: "$a2" := (![#sliceT] "b") in
    (method_call #(ptrT.id jrnl.Op.id) #"OverWrite"%go (![#ptrT] "tx")) "$a0" "$a1" "$a2");;;
    do:  (let: "$a0" := (![#addr.Addr] (struct.field_ref #RepBlock #"a1"%go (![#ptrT] "rb"))) in
    let: "$a1" := (#(W64 8) * disk.BlockSize) in
    let: "$a2" := (![#sliceT] "b") in
    (method_call #(ptrT.id jrnl.Op.id) #"OverWrite"%go (![#ptrT] "tx")) "$a0" "$a1" "$a2");;;
    let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "$r0" := (let: "$a0" := #true in
    (method_call #(ptrT.id jrnl.Op.id) #"CommitWait"%go (![#ptrT] "tx")) "$a0") in
    do:  ("ok" <-[#boolT] "$r0");;;
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref #RepBlock #"m"%go (![#ptrT] "rb")))) #());;;
    return: (![#boolT] "ok")).

Definition vars' : list (go_string * go_type) := [].

Definition functions' : list (go_string * val) := [(Open, Openⁱᵐᵖˡ)].

Definition msets' : list (go_string * (list (go_string * val))) := [(RepBlock.id, []); (ptrT.id RepBlock.id, [("Read"%go, RepBlock__Readⁱᵐᵖˡ); ("Write"%go, RepBlock__Writeⁱᵐᵖˡ)])].

#[global] Instance info' : PkgInfo jrnl_replication.replicated_block :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [code.sync.sync; code.github_com.goose_lang.primitive.disk.disk; code.github_com.mit_pdos.go_journal.addr.addr; code.github_com.mit_pdos.go_journal.common.common; code.github_com.mit_pdos.go_journal.jrnl.jrnl; code.github_com.mit_pdos.go_journal.obj.obj; code.github_com.mit_pdos.go_journal.util.util];
  |}.

Definition initialize' : val :=
  λ: <>,
    package.init #jrnl_replication.replicated_block (λ: <>,
      exception_do (do:  (util.initialize' #());;;
      do:  (obj.initialize' #());;;
      do:  (jrnl.initialize' #());;;
      do:  (common.initialize' #());;;
      do:  (addr.initialize' #());;;
      do:  (disk.initialize' #());;;
      do:  (sync.initialize' #());;;
      do:  (package.alloc jrnl_replication.replicated_block #()))
      ).

End code.
End replicated_block.
