(* autogenerated from github.com/mit-pdos/go-journal/jrnl *)
From New.golang Require Import defn.
Require Export New.code.github_com.mit_pdos.go_journal.addr.
Require Export New.code.github_com.mit_pdos.go_journal.buf.
Require Export New.code.github_com.mit_pdos.go_journal.obj.
Require Export New.code.github_com.mit_pdos.go_journal.util.

Definition jrnl : go_string := "github.com/mit-pdos/go-journal/jrnl".

From New Require Import disk_prelude.
Module jrnl.
Section code.


Definition LogBlocks : expr := #(W64 511).

Definition LogBytes : expr := #(W64 (4096 * 511)).

Definition Op : go_type := structT [
  "log" :: ptrT;
  "bufs" :: ptrT
].

(* Begin starts a local journal operation with no writes from a global object
   manager.

   go: jrnl.go:60:6 *)
Definition Begin : val :=
  rec: "Begin" "log" :=
    exception_do (let: "log" := (mem.alloc "log") in
    let: "trans" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (let: "$log" := (![#ptrT] "log") in
    let: "$bufs" := ((func_call #buf.buf #"MkBufMap"%go) #()) in
    struct.make #Op [{
      "log" ::= "$log";
      "bufs" ::= "$bufs"
    }])) in
    do:  ("trans" <-[#ptrT] "$r0");;;
    do:  (let: "$a0" := #(W64 3) in
    let: "$a1" := #"Begin: %v
    "%go in
    let: "$a2" := ((let: "$sl0" := (interface.make #jrnl.jrnl #"Op'ptr" (![#ptrT] "trans")) in
    slice.literal #interfaceT ["$sl0"])) in
    (func_call #util.util #"DPrintf"%go) "$a0" "$a1" "$a2");;;
    return: (![#ptrT] "trans")).

(* go: jrnl.go:69:15 *)
Definition Op__ReadBuf : val :=
  rec: "Op__ReadBuf" "op" "addr" "sz" :=
    exception_do (let: "op" := (mem.alloc "op") in
    let: "sz" := (mem.alloc "sz") in
    let: "addr" := (mem.alloc "addr") in
    let: "b" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := (![#addr.Addr] "addr") in
    (method_call #buf #"BufMap'ptr" #"Lookup" (![#ptrT] (struct.field_ref #Op #"bufs"%go (![#ptrT] "op")))) "$a0") in
    do:  ("b" <-[#ptrT] "$r0");;;
    (if: (![#ptrT] "b") = #null
    then
      let: "buf" := (mem.alloc (type.zero_val #ptrT)) in
      let: "$r0" := (let: "$a0" := (![#addr.Addr] "addr") in
      let: "$a1" := (![#uint64T] "sz") in
      (method_call #obj #"Log'ptr" #"Load" (![#ptrT] (struct.field_ref #Op #"log"%go (![#ptrT] "op")))) "$a0" "$a1") in
      do:  ("buf" <-[#ptrT] "$r0");;;
      do:  (let: "$a0" := (![#ptrT] "buf") in
      (method_call #buf #"BufMap'ptr" #"Insert" (![#ptrT] (struct.field_ref #Op #"bufs"%go (![#ptrT] "op")))) "$a0");;;
      return: (let: "$a0" := (![#addr.Addr] "addr") in
       (method_call #buf #"BufMap'ptr" #"Lookup" (![#ptrT] (struct.field_ref #Op #"bufs"%go (![#ptrT] "op")))) "$a0")
    else do:  #());;;
    return: (![#ptrT] "b")).

(* OverWrite writes an object to addr

   go: jrnl.go:80:15 *)
Definition Op__OverWrite : val :=
  rec: "Op__OverWrite" "op" "addr" "sz" "data" :=
    exception_do (let: "op" := (mem.alloc "op") in
    let: "data" := (mem.alloc "data") in
    let: "sz" := (mem.alloc "sz") in
    let: "addr" := (mem.alloc "addr") in
    let: "b" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := (![#addr.Addr] "addr") in
    (method_call #buf #"BufMap'ptr" #"Lookup" (![#ptrT] (struct.field_ref #Op #"bufs"%go (![#ptrT] "op")))) "$a0") in
    do:  ("b" <-[#ptrT] "$r0");;;
    (if: (![#ptrT] "b") = #null
    then
      let: "$r0" := (let: "$a0" := (![#addr.Addr] "addr") in
      let: "$a1" := (![#uint64T] "sz") in
      let: "$a2" := (![#sliceT] "data") in
      (func_call #buf.buf #"MkBuf"%go) "$a0" "$a1" "$a2") in
      do:  ("b" <-[#ptrT] "$r0");;;
      do:  ((method_call #buf #"Buf'ptr" #"SetDirty" (![#ptrT] "b")) #());;;
      do:  (let: "$a0" := (![#ptrT] "b") in
      (method_call #buf #"BufMap'ptr" #"Insert" (![#ptrT] (struct.field_ref #Op #"bufs"%go (![#ptrT] "op")))) "$a0")
    else
      (if: (![#uint64T] "sz") ≠ (![#uint64T] (struct.field_ref #buf.Buf #"Sz"%go (![#ptrT] "b")))
      then
        do:  (let: "$a0" := (interface.make #""%go #"string"%go #"overwrite"%go) in
        Panic "$a0")
      else do:  #());;;
      let: "$r0" := (![#sliceT] "data") in
      do:  ((struct.field_ref #buf.Buf #"Data"%go (![#ptrT] "b")) <-[#sliceT] "$r0");;;
      do:  ((method_call #buf #"Buf'ptr" #"SetDirty" (![#ptrT] "b")) #()))).

(* NDirty reports an upper bound on the size of this transaction when committed.

   The caller cannot rely on any particular properties of this function for
   safety.

   go: jrnl.go:99:15 *)
Definition Op__NDirty : val :=
  rec: "Op__NDirty" "op" <> :=
    exception_do (let: "op" := (mem.alloc "op") in
    return: ((method_call #buf #"BufMap'ptr" #"Ndirty" (![#ptrT] (struct.field_ref #Op #"bufs"%go (![#ptrT] "op")))) #())).

(* CommitWait commits the writes in the transaction to disk.

   If CommitWait returns false, the transaction failed and had no logical effect.
   This can happen, for example, if the transaction is too big to fit in the
   on-disk journal.

   wait=true is a synchronous commit, which is durable as soon as CommitWait
   returns.

   wait=false is an asynchronous commit, which can be made durable later with
   Flush.

   go: jrnl.go:114:15 *)
Definition Op__CommitWait : val :=
  rec: "Op__CommitWait" "op" "wait" :=
    exception_do (let: "op" := (mem.alloc "op") in
    let: "wait" := (mem.alloc "wait") in
    do:  (let: "$a0" := #(W64 3) in
    let: "$a1" := #"Commit %p w %v
    "%go in
    let: "$a2" := ((let: "$sl0" := (interface.make #jrnl.jrnl #"Op'ptr" (![#ptrT] "op")) in
    let: "$sl1" := (interface.make #""%go #"bool"%go (![#boolT] "wait")) in
    slice.literal #interfaceT ["$sl0"; "$sl1"])) in
    (func_call #util.util #"DPrintf"%go) "$a0" "$a1" "$a2");;;
    let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "$r0" := (let: "$a0" := ((method_call #buf #"BufMap'ptr" #"DirtyBufs" (![#ptrT] (struct.field_ref #Op #"bufs"%go (![#ptrT] "op")))) #()) in
    let: "$a1" := (![#boolT] "wait") in
    (method_call #obj #"Log'ptr" #"CommitWait" (![#ptrT] (struct.field_ref #Op #"log"%go (![#ptrT] "op")))) "$a0" "$a1") in
    do:  ("ok" <-[#boolT] "$r0");;;
    return: (![#boolT] "ok")).

Definition vars' : list (go_string * go_type) := [].

Definition functions' : list (go_string * val) := [("Begin"%go, Begin)].

Definition msets' : list (go_string * (list (go_string * val))) := [("Op"%go, []); ("Op'ptr"%go, [("CommitWait"%go, Op__CommitWait); ("NDirty"%go, Op__NDirty); ("OverWrite"%go, Op__OverWrite); ("ReadBuf"%go, Op__ReadBuf)])].

#[global] Instance info' : PkgInfo jrnl.jrnl :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [addr.addr; buf.buf; obj.obj; util.util];
  |}.

Definition initialize' : val :=
  rec: "initialize'" <> :=
    globals.package_init jrnl.jrnl (λ: <>,
      exception_do (do:  util.initialize';;;
      do:  obj.initialize';;;
      do:  buf.initialize';;;
      do:  addr.initialize')
      ).

End code.
End jrnl.
