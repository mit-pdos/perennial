(* autogenerated from github.com/mit-pdos/go-journal/jrnl *)
Require Export New.code.github_com.mit_pdos.go_journal.addr.
Require Export New.code.github_com.mit_pdos.go_journal.buf.
Require Export New.code.github_com.mit_pdos.go_journal.obj.
Require Export New.code.github_com.mit_pdos.go_journal.util.
From New.golang Require Import defn.
From New Require Import disk_prelude.
Module pkg_id.
Definition jrnl : go_string := "github.com/mit-pdos/go-journal/jrnl".

End pkg_id.
Export pkg_id.
Module jrnl.

Definition Op {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/mit-pdos/go-journal/jrnl.Op"%go [].

Definition LogBlocks {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 511).

Definition LogBytes {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 2093056).

Definition Begin {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/go-journal/jrnl.Begin"%go.

(* Begin starts a local journal operation with no writes from a global object
   manager.

   go: jrnl.go:60:6 *)
Definition Beginⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "log",
    exception_do (let: "log" := (GoAlloc (go.PointerType obj.Log) "log") in
    let: "trans" := (GoAlloc (go.PointerType Op) (GoZeroVal (go.PointerType Op) #())) in
    let: "$r0" := (GoAlloc Op (let: "$v0" := (![go.PointerType obj.Log] "log") in
    let: "$v1" := ((FuncResolve buf.MkBufMap [] #()) #()) in
    CompositeLiteral Op (LiteralValue [KeyedElement (Some (KeyField "log"%go)) (ElementExpression (go.PointerType obj.Log) "$v0"); KeyedElement (Some (KeyField "bufs"%go)) (ElementExpression (go.PointerType buf.BufMap) "$v1")]))) in
    do:  ("trans" <-[go.PointerType Op] "$r0");;;
    do:  (let: "$a0" := #(W64 3) in
    let: "$a1" := #"Begin: %v
    "%go in
    let: "$a2" := ((let: "$sl0" := (Convert (go.PointerType Op) (go.InterfaceType []) (![go.PointerType Op] "trans")) in
    CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0")]))) in
    (FuncResolve util.DPrintf [] #()) "$a0" "$a1" "$a2");;;
    return: (![go.PointerType Op] "trans")).

(* go: jrnl.go:69:15 *)
Definition Op__ReadBufⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "op" "addr" "sz",
    exception_do (let: "op" := (GoAlloc (go.PointerType Op) "op") in
    let: "sz" := (GoAlloc go.uint64 "sz") in
    let: "addr" := (GoAlloc addr.Addr "addr") in
    let: "b" := (GoAlloc (go.PointerType buf.Buf) (GoZeroVal (go.PointerType buf.Buf) #())) in
    let: "$r0" := (let: "$a0" := (![addr.Addr] "addr") in
    (MethodResolve (go.PointerType buf.BufMap) "Lookup"%go (![go.PointerType buf.BufMap] (StructFieldRef Op "bufs"%go (![go.PointerType Op] "op")))) "$a0") in
    do:  ("b" <-[go.PointerType buf.Buf] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.PointerType buf.Buf] "b") =⟨go.PointerType buf.Buf⟩ (Convert go.untyped_nil (go.PointerType buf.Buf) UntypedNil))
    then
      let: "buf" := (GoAlloc (go.PointerType buf.Buf) (GoZeroVal (go.PointerType buf.Buf) #())) in
      let: "$r0" := (let: "$a0" := (![addr.Addr] "addr") in
      let: "$a1" := (![go.uint64] "sz") in
      (MethodResolve (go.PointerType obj.Log) "Load"%go (![go.PointerType obj.Log] (StructFieldRef Op "log"%go (![go.PointerType Op] "op")))) "$a0" "$a1") in
      do:  ("buf" <-[go.PointerType buf.Buf] "$r0");;;
      do:  (let: "$a0" := (![go.PointerType buf.Buf] "buf") in
      (MethodResolve (go.PointerType buf.BufMap) "Insert"%go (![go.PointerType buf.BufMap] (StructFieldRef Op "bufs"%go (![go.PointerType Op] "op")))) "$a0");;;
      return: (let: "$a0" := (![addr.Addr] "addr") in
       (MethodResolve (go.PointerType buf.BufMap) "Lookup"%go (![go.PointerType buf.BufMap] (StructFieldRef Op "bufs"%go (![go.PointerType Op] "op")))) "$a0")
    else do:  #());;;
    return: (![go.PointerType buf.Buf] "b")).

(* OverWrite writes an object to addr

   go: jrnl.go:80:15 *)
Definition Op__OverWriteⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "op" "addr" "sz" "data",
    exception_do (let: "op" := (GoAlloc (go.PointerType Op) "op") in
    let: "data" := (GoAlloc (go.SliceType go.byte) "data") in
    let: "sz" := (GoAlloc go.uint64 "sz") in
    let: "addr" := (GoAlloc addr.Addr "addr") in
    let: "b" := (GoAlloc (go.PointerType buf.Buf) (GoZeroVal (go.PointerType buf.Buf) #())) in
    let: "$r0" := (let: "$a0" := (![addr.Addr] "addr") in
    (MethodResolve (go.PointerType buf.BufMap) "Lookup"%go (![go.PointerType buf.BufMap] (StructFieldRef Op "bufs"%go (![go.PointerType Op] "op")))) "$a0") in
    do:  ("b" <-[go.PointerType buf.Buf] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.PointerType buf.Buf] "b") =⟨go.PointerType buf.Buf⟩ (Convert go.untyped_nil (go.PointerType buf.Buf) UntypedNil))
    then
      let: "$r0" := (let: "$a0" := (![addr.Addr] "addr") in
      let: "$a1" := (![go.uint64] "sz") in
      let: "$a2" := (![go.SliceType go.byte] "data") in
      (FuncResolve buf.MkBuf [] #()) "$a0" "$a1" "$a2") in
      do:  ("b" <-[go.PointerType buf.Buf] "$r0");;;
      do:  ((MethodResolve (go.PointerType buf.Buf) "SetDirty"%go (![go.PointerType buf.Buf] "b")) #());;;
      do:  (let: "$a0" := (![go.PointerType buf.Buf] "b") in
      (MethodResolve (go.PointerType buf.BufMap) "Insert"%go (![go.PointerType buf.BufMap] (StructFieldRef Op "bufs"%go (![go.PointerType Op] "op")))) "$a0")
    else
      (if: Convert go.untyped_bool go.bool ((![go.uint64] "sz") ≠⟨go.uint64⟩ (![go.uint64] (StructFieldRef buf.Buf "Sz"%go (![go.PointerType buf.Buf] "b"))))
      then
        do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"overwrite"%go) in
        (FuncResolve go.panic [] #()) "$a0")
      else do:  #());;;
      let: "$r0" := (![go.SliceType go.byte] "data") in
      do:  ((StructFieldRef buf.Buf "Data"%go (![go.PointerType buf.Buf] "b")) <-[go.SliceType go.byte] "$r0");;;
      do:  ((MethodResolve (go.PointerType buf.Buf) "SetDirty"%go (![go.PointerType buf.Buf] "b")) #()));;;
    return: #()).

(* NDirty reports an upper bound on the size of this transaction when committed.

   The caller cannot rely on any particular properties of this function for
   safety.

   go: jrnl.go:99:15 *)
Definition Op__NDirtyⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "op" <>,
    exception_do (let: "op" := (GoAlloc (go.PointerType Op) "op") in
    return: ((MethodResolve (go.PointerType buf.BufMap) "Ndirty"%go (![go.PointerType buf.BufMap] (StructFieldRef Op "bufs"%go (![go.PointerType Op] "op")))) #())).

(* CommitWait commits the writes in the transaction to disk.

   If CommitWait returns false, the transaction failed and had no logical effect.
   This can happen, for example, if the transaction is too big to fit in the
   on-disk journal.

   wait=true is a synchronous commit, which is durable as soon as CommitWait
   returns.

   wait=false is an asynchronous commit, which can be made durable later with
   Flush.

   go: jrnl.go:114:15 *)
Definition Op__CommitWaitⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "op" "wait",
    exception_do (let: "op" := (GoAlloc (go.PointerType Op) "op") in
    let: "wait" := (GoAlloc go.bool "wait") in
    do:  (let: "$a0" := #(W64 3) in
    let: "$a1" := #"Commit %p w %v
    "%go in
    let: "$a2" := ((let: "$sl0" := (Convert (go.PointerType Op) (go.InterfaceType []) (![go.PointerType Op] "op")) in
    let: "$sl1" := (Convert go.bool (go.InterfaceType []) (![go.bool] "wait")) in
    CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1")]))) in
    (FuncResolve util.DPrintf [] #()) "$a0" "$a1" "$a2");;;
    let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := (let: "$a0" := ((MethodResolve (go.PointerType buf.BufMap) "DirtyBufs"%go (![go.PointerType buf.BufMap] (StructFieldRef Op "bufs"%go (![go.PointerType Op] "op")))) #()) in
    let: "$a1" := (![go.bool] "wait") in
    (MethodResolve (go.PointerType obj.Log) "CommitWait"%go (![go.PointerType obj.Log] (StructFieldRef Op "log"%go (![go.PointerType Op] "op")))) "$a0" "$a1") in
    do:  ("ok" <-[go.bool] "$r0");;;
    return: (![go.bool] "ok")).

#[global] Instance info' : PkgInfo pkg_id.jrnl :=
{|
  pkg_imported_pkgs := [code.github_com.mit_pdos.go_journal.addr.pkg_id.addr; code.github_com.mit_pdos.go_journal.buf.pkg_id.buf; code.github_com.mit_pdos.go_journal.obj.pkg_id.obj; code.github_com.mit_pdos.go_journal.util.pkg_id.util]
|}.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init pkg_id.jrnl (λ: <>,
      exception_do (do:  (util.initialize' #());;;
      do:  (obj.initialize' #());;;
      do:  (buf.initialize' #());;;
      do:  (addr.initialize' #()))
      ).

Module Op.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  log' : loc;
  bufs' : loc;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End Op.

Definition Op'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "log"%go (go.PointerType obj.Log));
  (go.FieldDecl "bufs"%go (go.PointerType buf.BufMap))
].
Program Definition Op'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (Op'fds_unsealed).
Global Instance equals_unfold_Op {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Op'fds =→ Op'fds_unsealed.
Proof. rewrite /Op'fds seal_eq //. Qed.

Definition Opⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (Op'fds).

Class Op_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Op_type_repr  :: go.TypeReprUnderlying Opⁱᵐᵖˡ Op.t;
  #[global] Op_underlying :: (Op) <u (Opⁱᵐᵖˡ);
  #[global] Op_get_log (x : Op.t) :: ⟦StructFieldGet (Opⁱᵐᵖˡ) "log", #x⟧ ⤳[under] #x.(Op.log');
  #[global] Op_set_log (x : Op.t) y :: ⟦StructFieldSet (Opⁱᵐᵖˡ) "log", (#x, #y)⟧ ⤳[under] #(x <|Op.log' := y|>);
  #[global] Op_get_bufs (x : Op.t) :: ⟦StructFieldGet (Opⁱᵐᵖˡ) "bufs", #x⟧ ⤳[under] #x.(Op.bufs');
  #[global] Op_set_bufs (x : Op.t) y :: ⟦StructFieldSet (Opⁱᵐᵖˡ) "bufs", (#x, #y)⟧ ⤳[under] #(x <|Op.bufs' := y|>);
  #[global] Op'ptr_CommitWait_unfold :: MethodUnfold (go.PointerType (Op)) "CommitWait" (Op__CommitWaitⁱᵐᵖˡ);
  #[global] Op'ptr_NDirty_unfold :: MethodUnfold (go.PointerType (Op)) "NDirty" (Op__NDirtyⁱᵐᵖˡ);
  #[global] Op'ptr_OverWrite_unfold :: MethodUnfold (go.PointerType (Op)) "OverWrite" (Op__OverWriteⁱᵐᵖˡ);
  #[global] Op'ptr_ReadBuf_unfold :: MethodUnfold (go.PointerType (Op)) "ReadBuf" (Op__ReadBufⁱᵐᵖˡ);
}.

Class Assumptions `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Op_instance :: Op_Assumptions;
  #[global] Begin_unfold :: FuncUnfold Begin [] (Beginⁱᵐᵖˡ);
  #[global] import_addr_Assumption :: addr.Assumptions;
  #[global] import_buf_Assumption :: buf.Assumptions;
  #[global] import_obj_Assumption :: obj.Assumptions;
  #[global] import_util_Assumption :: util.Assumptions;
}.
End jrnl.
