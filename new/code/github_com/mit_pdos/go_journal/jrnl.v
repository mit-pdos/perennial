(* autogenerated from github.com/mit-pdos/go-journal/jrnl *)
Require Export New.code.github_com.mit_pdos.go_journal.addr.
Require Export New.code.github_com.mit_pdos.go_journal.buf.
Require Export New.code.github_com.mit_pdos.go_journal.obj.
Require Export New.code.github_com.mit_pdos.go_journal.util.

From New.golang Require Import defn.
Definition jrnl : go_string := "github.com/mit-pdos/go-journal/jrnl".

From New Require Import disk_prelude.
Module jrnl.

Module Op. Definition id : go_string := "github.com/mit-pdos/go-journal/jrnl.Op"%go. End Op.

Section code.


Definition LogBlocks : val := #(W64 511).

Definition LogBytes : val := #(W64 2093056).

Definition Op : go_type := structT [
  "log" :: ptrT;
  "bufs" :: ptrT
].
#[global] Typeclasses Opaque Op.
#[global] Opaque Op.

Definition Begin : go_string := "github.com/mit-pdos/go-journal/jrnl.Begin"%go.

(* Begin starts a local journal operation with no writes from a global object
   manager.

   go: jrnl.go:60:6 *)
Definition Beginⁱᵐᵖˡ : val :=
  λ: "log",
    exception_do (let: "log" := (mem.alloc "log") in
    let: "trans" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (let: "$log" := (![#ptrT] "log") in
    let: "$bufs" := ((func_call #buf.MkBufMap) #()) in
    struct.make #Op [{
      "log" ::= "$log";
      "bufs" ::= "$bufs"
    }])) in
    do:  ("trans" <-[#ptrT] "$r0");;;
    do:  (let: "$a0" := #(W64 3) in
    let: "$a1" := #"Begin: %v
    "%go in
    let: "$a2" := ((let: "$sl0" := (interface.make #(ptrT.id Op.id) (![#ptrT] "trans")) in
    slice.literal #interfaceT ["$sl0"])) in
    (func_call #util.DPrintf) "$a0" "$a1" "$a2");;;
    return: (![#ptrT] "trans")).

(* go: jrnl.go:69:15 *)
Definition Op__ReadBufⁱᵐᵖˡ : val :=
  λ: "op" "addr" "sz",
    exception_do (let: "op" := (mem.alloc "op") in
    let: "sz" := (mem.alloc "sz") in
    let: "addr" := (mem.alloc "addr") in
    let: "b" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := (![#addr.Addr] "addr") in
    (method_call #(ptrT.id buf.BufMap.id) #"Lookup"%go (![#ptrT] (struct.field_ref #Op #"bufs"%go (![#ptrT] "op")))) "$a0") in
    do:  ("b" <-[#ptrT] "$r0");;;
    (if: (![#ptrT] "b") = #null
    then
      let: "buf" := (mem.alloc (type.zero_val #ptrT)) in
      let: "$r0" := (let: "$a0" := (![#addr.Addr] "addr") in
      let: "$a1" := (![#uint64T] "sz") in
      (method_call #(ptrT.id obj.Log.id) #"Load"%go (![#ptrT] (struct.field_ref #Op #"log"%go (![#ptrT] "op")))) "$a0" "$a1") in
      do:  ("buf" <-[#ptrT] "$r0");;;
      do:  (let: "$a0" := (![#ptrT] "buf") in
      (method_call #(ptrT.id buf.BufMap.id) #"Insert"%go (![#ptrT] (struct.field_ref #Op #"bufs"%go (![#ptrT] "op")))) "$a0");;;
      return: (let: "$a0" := (![#addr.Addr] "addr") in
       (method_call #(ptrT.id buf.BufMap.id) #"Lookup"%go (![#ptrT] (struct.field_ref #Op #"bufs"%go (![#ptrT] "op")))) "$a0")
    else do:  #());;;
    return: (![#ptrT] "b")).

(* OverWrite writes an object to addr

   go: jrnl.go:80:15 *)
Definition Op__OverWriteⁱᵐᵖˡ : val :=
  λ: "op" "addr" "sz" "data",
    exception_do (let: "op" := (mem.alloc "op") in
    let: "data" := (mem.alloc "data") in
    let: "sz" := (mem.alloc "sz") in
    let: "addr" := (mem.alloc "addr") in
    let: "b" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := (![#addr.Addr] "addr") in
    (method_call #(ptrT.id buf.BufMap.id) #"Lookup"%go (![#ptrT] (struct.field_ref #Op #"bufs"%go (![#ptrT] "op")))) "$a0") in
    do:  ("b" <-[#ptrT] "$r0");;;
    (if: (![#ptrT] "b") = #null
    then
      let: "$r0" := (let: "$a0" := (![#addr.Addr] "addr") in
      let: "$a1" := (![#uint64T] "sz") in
      let: "$a2" := (![#sliceT] "data") in
      (func_call #buf.MkBuf) "$a0" "$a1" "$a2") in
      do:  ("b" <-[#ptrT] "$r0");;;
      do:  ((method_call #(ptrT.id buf.Buf.id) #"SetDirty"%go (![#ptrT] "b")) #());;;
      do:  (let: "$a0" := (![#ptrT] "b") in
      (method_call #(ptrT.id buf.BufMap.id) #"Insert"%go (![#ptrT] (struct.field_ref #Op #"bufs"%go (![#ptrT] "op")))) "$a0")
    else
      (if: (![#uint64T] "sz") ≠ (![#uint64T] (struct.field_ref #buf.Buf #"Sz"%go (![#ptrT] "b")))
      then
        do:  (let: "$a0" := (interface.make #stringT.id #"overwrite"%go) in
        Panic "$a0")
      else do:  #());;;
      let: "$r0" := (![#sliceT] "data") in
      do:  ((struct.field_ref #buf.Buf #"Data"%go (![#ptrT] "b")) <-[#sliceT] "$r0");;;
      do:  ((method_call #(ptrT.id buf.Buf.id) #"SetDirty"%go (![#ptrT] "b")) #()));;;
    return: #()).

(* NDirty reports an upper bound on the size of this transaction when committed.

   The caller cannot rely on any particular properties of this function for
   safety.

   go: jrnl.go:99:15 *)
Definition Op__NDirtyⁱᵐᵖˡ : val :=
  λ: "op" <>,
    exception_do (let: "op" := (mem.alloc "op") in
    return: ((method_call #(ptrT.id buf.BufMap.id) #"Ndirty"%go (![#ptrT] (struct.field_ref #Op #"bufs"%go (![#ptrT] "op")))) #())).

(* CommitWait commits the writes in the transaction to disk.

   If CommitWait returns false, the transaction failed and had no logical effect.
   This can happen, for example, if the transaction is too big to fit in the
   on-disk journal.

   wait=true is a synchronous commit, which is durable as soon as CommitWait
   returns.

   wait=false is an asynchronous commit, which can be made durable later with
   Flush.

   go: jrnl.go:114:15 *)
Definition Op__CommitWaitⁱᵐᵖˡ : val :=
  λ: "op" "wait",
    exception_do (let: "op" := (mem.alloc "op") in
    let: "wait" := (mem.alloc "wait") in
    do:  (let: "$a0" := #(W64 3) in
    let: "$a1" := #"Commit %p w %v
    "%go in
    let: "$a2" := ((let: "$sl0" := (interface.make #(ptrT.id Op.id) (![#ptrT] "op")) in
    let: "$sl1" := (interface.make #boolT.id (![#boolT] "wait")) in
    slice.literal #interfaceT ["$sl0"; "$sl1"])) in
    (func_call #util.DPrintf) "$a0" "$a1" "$a2");;;
    let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "$r0" := (let: "$a0" := ((method_call #(ptrT.id buf.BufMap.id) #"DirtyBufs"%go (![#ptrT] (struct.field_ref #Op #"bufs"%go (![#ptrT] "op")))) #()) in
    let: "$a1" := (![#boolT] "wait") in
    (method_call #(ptrT.id obj.Log.id) #"CommitWait"%go (![#ptrT] (struct.field_ref #Op #"log"%go (![#ptrT] "op")))) "$a0" "$a1") in
    do:  ("ok" <-[#boolT] "$r0");;;
    return: (![#boolT] "ok")).

Definition vars' : list (go_string * go_type) := [].

Definition functions' : list (go_string * val) := [(Begin, Beginⁱᵐᵖˡ)].

Definition msets' : list (go_string * (list (go_string * val))) := [(Op.id, []); (ptrT.id Op.id, [("CommitWait"%go, Op__CommitWaitⁱᵐᵖˡ); ("NDirty"%go, Op__NDirtyⁱᵐᵖˡ); ("OverWrite"%go, Op__OverWriteⁱᵐᵖˡ); ("ReadBuf"%go, Op__ReadBufⁱᵐᵖˡ)])].

#[global] Instance info' : PkgInfo jrnl.jrnl :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [code.github_com.mit_pdos.go_journal.addr.addr; code.github_com.mit_pdos.go_journal.buf.buf; code.github_com.mit_pdos.go_journal.obj.obj; code.github_com.mit_pdos.go_journal.util.util];
  |}.

Definition initialize' : val :=
  λ: <>,
    package.init #jrnl.jrnl (λ: <>,
      exception_do (do:  (util.initialize' #());;;
      do:  (obj.initialize' #());;;
      do:  (buf.initialize' #());;;
      do:  (addr.initialize' #());;;
      do:  (package.alloc jrnl.jrnl #()))
      ).

End code.
End jrnl.
