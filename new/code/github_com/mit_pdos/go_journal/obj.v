(* autogenerated from github.com/mit-pdos/go-journal/obj *)
Require Export New.code.github_com.goose_lang.primitive.disk.
Require Export New.code.github_com.mit_pdos.go_journal.addr.
Require Export New.code.github_com.mit_pdos.go_journal.buf.
Require Export New.code.github_com.mit_pdos.go_journal.common.
Require Export New.code.github_com.mit_pdos.go_journal.util.
Require Export New.code.github_com.mit_pdos.go_journal.wal.
Require Export New.code.sync.
From New.golang Require Import defn.
From New Require Import disk_prelude.
Module pkg_id.
Definition obj : go_string := "github.com/mit-pdos/go-journal/obj".

End pkg_id.
Export pkg_id.
Module obj.

Definition Log {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/mit-pdos/go-journal/obj.Log"%go [].

Definition MkLog {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/go-journal/obj.MkLog"%go.

(* MkLog recovers the object logging system
   (or initializes from an all-zero disk).

   go: obj.go:29:6 *)
Definition MkLogⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "d",
    exception_do (let: "d" := (GoAlloc disk.Disk "d") in
    let: "log" := (GoAlloc (go.PointerType Log) (GoZeroVal (go.PointerType Log) #())) in
    let: "$r0" := (GoAlloc Log (CompositeLiteral Log (LiteralValue [KeyedElement (Some (KeyField "mu"%go)) (ElementExpression (go.PointerType sync.Mutex) (GoAlloc sync.Mutex (GoZeroVal sync.Mutex #()))); KeyedElement (Some (KeyField "log"%go)) (ElementExpression (go.PointerType wal.Walog) (let: "$a0" := (![disk.Disk] "d") in
     (FuncResolve wal.MkLog [] #()) "$a0")); KeyedElement (Some (KeyField "pos"%go)) (ElementExpression wal.LogPosition #(W64 0))]))) in
    do:  ("log" <-[go.PointerType Log] "$r0");;;
    return: (![go.PointerType Log] "log")).

(* Read a disk object into buf

   go: obj.go:39:15 *)
Definition Log__Loadⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" "addr" "sz",
    exception_do (let: "l" := (GoAlloc (go.PointerType Log) "l") in
    let: "sz" := (GoAlloc go.uint64 "sz") in
    let: "addr" := (GoAlloc addr.Addr "addr") in
    let: "blk" := (GoAlloc disk.Block (GoZeroVal disk.Block #())) in
    let: "$r0" := (let: "$a0" := (![common.Bnum] (StructFieldRef addr.Addr "Blkno"%go "addr")) in
    (MethodResolve (go.PointerType wal.Walog) "Read"%go (![go.PointerType wal.Walog] (StructFieldRef Log "log"%go (![go.PointerType Log] "l")))) "$a0") in
    do:  ("blk" <-[disk.Block] "$r0");;;
    let: "b" := (GoAlloc (go.PointerType buf.Buf) (GoZeroVal (go.PointerType buf.Buf) #())) in
    let: "$r0" := (let: "$a0" := (![addr.Addr] "addr") in
    let: "$a1" := (![go.uint64] "sz") in
    let: "$a2" := (![disk.Block] "blk") in
    (FuncResolve buf.MkBufLoad [] #()) "$a0" "$a1" "$a2") in
    do:  ("b" <-[go.PointerType buf.Buf] "$r0");;;
    return: (![go.PointerType buf.Buf] "b")).

(* Installs bufs into their blocks and returns the blocks.
   A buf may only partially update a disk block and several bufs may
   apply to the same disk block. Assume caller holds commit lock.

   go: obj.go:48:15 *)
Definition Log__installBufsMapⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" "bufs",
    exception_do (let: "l" := (GoAlloc (go.PointerType Log) "l") in
    let: "bufs" := (GoAlloc (go.SliceType (go.PointerType buf.Buf)) "bufs") in
    let: "blks" := (GoAlloc (go.MapType common.Bnum (go.SliceType go.byte)) (GoZeroVal (go.MapType common.Bnum (go.SliceType go.byte)) #())) in
    let: "$r0" := ((FuncResolve go.make1 [go.MapType common.Bnum (go.SliceType go.byte)] #()) #()) in
    do:  ("blks" <-[go.MapType common.Bnum (go.SliceType go.byte)] "$r0");;;
    let: "$range" := (![go.SliceType (go.PointerType buf.Buf)] "bufs") in
    (let: "b" := (GoAlloc (go.PointerType buf.Buf) (GoZeroVal (go.PointerType buf.Buf) #())) in
    slice.for_range (go.PointerType buf.Buf) "$range" (λ: "$key" "$value",
      do:  ("b" <-[go.PointerType buf.Buf] "$value");;;
      do:  "$key";;;
      (if: Convert go.untyped_bool go.bool ((![go.uint64] (StructFieldRef buf.Buf "Sz"%go (![go.PointerType buf.Buf] "b"))) =⟨go.uint64⟩ common.NBITBLOCK)
      then
        let: "$r0" := (![go.SliceType go.byte] (StructFieldRef buf.Buf "Data"%go (![go.PointerType buf.Buf] "b"))) in
        do:  (map.insert common.Bnum (![go.MapType common.Bnum (go.SliceType go.byte)] "blks") (![common.Bnum] (StructFieldRef addr.Addr "Blkno"%go (StructFieldRef buf.Buf "Addr"%go (![go.PointerType buf.Buf] "b")))) "$r0")
      else
        let: "blk" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
        let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
        let: "mapblk" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
        let: ("$ret0", "$ret1") := (map.lookup2 common.Bnum (go.SliceType go.byte) (![go.MapType common.Bnum (go.SliceType go.byte)] "blks") (![common.Bnum] (StructFieldRef addr.Addr "Blkno"%go (StructFieldRef buf.Buf "Addr"%go (![go.PointerType buf.Buf] "b"))))) in
        let: "$r0" := "$ret0" in
        let: "$r1" := "$ret1" in
        do:  ("mapblk" <-[go.SliceType go.byte] "$r0");;;
        do:  ("ok" <-[go.bool] "$r1");;;
        (if: ![go.bool] "ok"
        then
          let: "$r0" := (![go.SliceType go.byte] "mapblk") in
          do:  ("blk" <-[go.SliceType go.byte] "$r0")
        else
          let: "$r0" := (let: "$a0" := (![common.Bnum] (StructFieldRef addr.Addr "Blkno"%go (StructFieldRef buf.Buf "Addr"%go (![go.PointerType buf.Buf] "b")))) in
          (MethodResolve (go.PointerType wal.Walog) "Read"%go (![go.PointerType wal.Walog] (StructFieldRef Log "log"%go (![go.PointerType Log] "l")))) "$a0") in
          do:  ("blk" <-[go.SliceType go.byte] "$r0");;;
          let: "$r0" := (![go.SliceType go.byte] "blk") in
          do:  (map.insert common.Bnum (![go.MapType common.Bnum (go.SliceType go.byte)] "blks") (![common.Bnum] (StructFieldRef addr.Addr "Blkno"%go (StructFieldRef buf.Buf "Addr"%go (![go.PointerType buf.Buf] "b")))) "$r0"));;;
        do:  (let: "$a0" := (![go.SliceType go.byte] "blk") in
        (MethodResolve (go.PointerType buf.Buf) "Install"%go (![go.PointerType buf.Buf] "b")) "$a0"))));;;
    return: (![go.MapType common.Bnum (go.SliceType go.byte)] "blks")).

(* go: obj.go:70:15 *)
Definition Log__installBufsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" "bufs",
    exception_do (let: "l" := (GoAlloc (go.PointerType Log) "l") in
    let: "bufs" := (GoAlloc (go.SliceType (go.PointerType buf.Buf)) "bufs") in
    let: "bufmap" := (GoAlloc (go.MapType common.Bnum (go.SliceType go.byte)) (GoZeroVal (go.MapType common.Bnum (go.SliceType go.byte)) #())) in
    let: "$r0" := (let: "$a0" := (![go.SliceType (go.PointerType buf.Buf)] "bufs") in
    (MethodResolve (go.PointerType Log) "installBufsMap"%go (![go.PointerType Log] "l")) "$a0") in
    do:  ("bufmap" <-[go.MapType common.Bnum (go.SliceType go.byte)] "$r0");;;
    let: "blks" := (GoAlloc (go.SliceType wal.Update) (GoZeroVal (go.SliceType wal.Update) #())) in
    let: "$r0" := ((FuncResolve go.make3 [go.SliceType wal.Update] #()) #(W64 0) (let: "$a0" := (![go.MapType common.Bnum (go.SliceType go.byte)] "bufmap") in
    (FuncResolve go.len [go.MapType common.Bnum (go.SliceType go.byte)] #()) "$a0")) in
    do:  ("blks" <-[go.SliceType wal.Update] "$r0");;;
    let: "$range" := (![go.MapType common.Bnum (go.SliceType go.byte)] "bufmap") in
    (let: "data" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "blkno" := (GoAlloc common.Bnum (GoZeroVal common.Bnum #())) in
    map.for_range common.Bnum (go.SliceType go.byte) "$range" (λ: "$key" "value",
      do:  ("data" <-[go.SliceType go.byte] "$value");;;
      do:  ("blkno" <-[common.Bnum] "$key");;;
      let: "$r0" := (let: "$a0" := (![go.SliceType wal.Update] "blks") in
      let: "$a1" := ((let: "$sl0" := (let: "$a0" := (![common.Bnum] "blkno") in
      let: "$a1" := (![go.SliceType go.byte] "data") in
      (FuncResolve wal.MkBlockData [] #()) "$a0" "$a1") in
      CompositeLiteral (go.SliceType wal.Update) (LiteralValue [KeyedElement None (ElementExpression wal.Update "$sl0")]))) in
      (FuncResolve go.append [go.SliceType wal.Update] #()) "$a0" "$a1") in
      do:  ("blks" <-[go.SliceType wal.Update] "$r0")));;;
    return: (![go.SliceType wal.Update] "blks")).

(* Acquires the commit log, installs the buffers into their
   blocks, and appends the blocks to the in-memory log.

   go: obj.go:81:15 *)
Definition Log__doCommitⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" "bufs",
    exception_do (let: "l" := (GoAlloc (go.PointerType Log) "l") in
    let: "bufs" := (GoAlloc (go.SliceType (go.PointerType buf.Buf)) "bufs") in
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] (StructFieldRef Log "mu"%go (![go.PointerType Log] "l")))) #());;;
    let: "blks" := (GoAlloc (go.SliceType wal.Update) (GoZeroVal (go.SliceType wal.Update) #())) in
    let: "$r0" := (let: "$a0" := (![go.SliceType (go.PointerType buf.Buf)] "bufs") in
    (MethodResolve (go.PointerType Log) "installBufs"%go (![go.PointerType Log] "l")) "$a0") in
    do:  ("blks" <-[go.SliceType wal.Update] "$r0");;;
    do:  (let: "$a0" := #(W64 3) in
    let: "$a1" := #"doCommit: %v bufs
    "%go in
    let: "$a2" := ((let: "$sl0" := (Convert go.int (go.InterfaceType []) (let: "$a0" := (![go.SliceType wal.Update] "blks") in
    (FuncResolve go.len [go.SliceType wal.Update] #()) "$a0")) in
    CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0")]))) in
    (FuncResolve util.DPrintf [] #()) "$a0" "$a1" "$a2");;;
    let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "n" := (GoAlloc wal.LogPosition (GoZeroVal wal.LogPosition #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType wal.Update] "blks") in
    (MethodResolve (go.PointerType wal.Walog) "MemAppend"%go (![go.PointerType wal.Walog] (StructFieldRef Log "log"%go (![go.PointerType Log] "l")))) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("n" <-[wal.LogPosition] "$r0");;;
    do:  ("ok" <-[go.bool] "$r1");;;
    let: "$r0" := (![wal.LogPosition] "n") in
    do:  ((StructFieldRef Log "pos"%go (![go.PointerType Log] "l")) <-[wal.LogPosition] "$r0");;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef Log "mu"%go (![go.PointerType Log] "l")))) #());;;
    return: (![wal.LogPosition] "n", ![go.bool] "ok")).

(* Commit dirty bufs of the transaction into the log, and perhaps wait.

   go: obj.go:98:15 *)
Definition Log__CommitWaitⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" "bufs" "wait",
    exception_do (let: "l" := (GoAlloc (go.PointerType Log) "l") in
    let: "wait" := (GoAlloc go.bool "wait") in
    let: "bufs" := (GoAlloc (go.SliceType (go.PointerType buf.Buf)) "bufs") in
    let: "commit" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #true in
    do:  ("commit" <-[go.bool] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((let: "$a0" := (![go.SliceType (go.PointerType buf.Buf)] "bufs") in
    (FuncResolve go.len [go.SliceType (go.PointerType buf.Buf)] #()) "$a0") >⟨go.int⟩ #(W64 0))
    then
      let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
      let: "n" := (GoAlloc wal.LogPosition (GoZeroVal wal.LogPosition #())) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType (go.PointerType buf.Buf)] "bufs") in
      (MethodResolve (go.PointerType Log) "doCommit"%go (![go.PointerType Log] "l")) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("n" <-[wal.LogPosition] "$r0");;;
      do:  ("ok" <-[go.bool] "$r1");;;
      (if: (~ (![go.bool] "ok"))
      then
        do:  (let: "$a0" := #(W64 10) in
        let: "$a1" := #"memappend failed; log is too small
        "%go in
        let: "$a2" := #slice.nil in
        (FuncResolve util.DPrintf [] #()) "$a0" "$a1" "$a2");;;
        let: "$r0" := #false in
        do:  ("commit" <-[go.bool] "$r0")
      else
        (if: ![go.bool] "wait"
        then
          do:  (let: "$a0" := (![wal.LogPosition] "n") in
          (MethodResolve (go.PointerType wal.Walog) "Flush"%go (![go.PointerType wal.Walog] (StructFieldRef Log "log"%go (![go.PointerType Log] "l")))) "$a0")
        else do:  #()))
    else
      do:  (let: "$a0" := #(W64 5) in
      let: "$a1" := #"commit read-only trans
      "%go in
      let: "$a2" := #slice.nil in
      (FuncResolve util.DPrintf [] #()) "$a0" "$a1" "$a2"));;;
    return: (![go.bool] "commit")).

(* NOTE: this is coarse-grained and unattached to the transaction ID

   go: obj.go:117:15 *)
Definition Log__Flushⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" <>,
    exception_do (let: "l" := (GoAlloc (go.PointerType Log) "l") in
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] (StructFieldRef Log "mu"%go (![go.PointerType Log] "l")))) #());;;
    let: "pos" := (GoAlloc wal.LogPosition (GoZeroVal wal.LogPosition #())) in
    let: "$r0" := (![wal.LogPosition] (StructFieldRef Log "pos"%go (![go.PointerType Log] "l"))) in
    do:  ("pos" <-[wal.LogPosition] "$r0");;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef Log "mu"%go (![go.PointerType Log] "l")))) #());;;
    do:  (let: "$a0" := (![wal.LogPosition] "pos") in
    (MethodResolve (go.PointerType wal.Walog) "Flush"%go (![go.PointerType wal.Walog] (StructFieldRef Log "log"%go (![go.PointerType Log] "l")))) "$a0");;;
    return: (#true)).

(* LogSz returns 511 (the size of the wal log)

   go: obj.go:127:15 *)
Definition Log__LogSzⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" <>,
    exception_do (let: "l" := (GoAlloc (go.PointerType Log) "l") in
    return: (wal.LOGSZ)).

(* go: obj.go:131:15 *)
Definition Log__Shutdownⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" <>,
    exception_do (let: "l" := (GoAlloc (go.PointerType Log) "l") in
    do:  ((MethodResolve (go.PointerType wal.Walog) "Shutdown"%go (![go.PointerType wal.Walog] (StructFieldRef Log "log"%go (![go.PointerType Log] "l")))) #());;;
    return: #()).

#[global] Instance info' : PkgInfo pkg_id.obj :=
{|
  pkg_imported_pkgs := [code.github_com.goose_lang.primitive.disk.pkg_id.disk; code.github_com.mit_pdos.go_journal.addr.pkg_id.addr; code.github_com.mit_pdos.go_journal.buf.pkg_id.buf; code.github_com.mit_pdos.go_journal.common.pkg_id.common; code.github_com.mit_pdos.go_journal.util.pkg_id.util; code.github_com.mit_pdos.go_journal.wal.pkg_id.wal; code.sync.pkg_id.sync]
|}.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init pkg_id.obj (λ: <>,
      exception_do (do:  (sync.initialize' #());;;
      do:  (wal.initialize' #());;;
      do:  (util.initialize' #());;;
      do:  (common.initialize' #());;;
      do:  (buf.initialize' #());;;
      do:  (addr.initialize' #());;;
      do:  (disk.initialize' #()))
      ).

Module Log.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  mu' : loc;
  log' : loc;
  pos' : wal.LogPosition.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End Log.

Definition Log'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "mu"%go (go.PointerType sync.Mutex));
  (go.FieldDecl "log"%go (go.PointerType wal.Walog));
  (go.FieldDecl "pos"%go wal.LogPosition)
].
Program Definition Log'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (Log'fds_unsealed).
Global Instance equals_unfold_Log {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Log'fds =→ Log'fds_unsealed.
Proof. rewrite /Log'fds seal_eq //. Qed.

Definition Logⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (Log'fds).

Class Log_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Log_type_repr  :: go.TypeReprUnderlying Logⁱᵐᵖˡ Log.t;
  #[global] Log_underlying :: (Log) <u (Logⁱᵐᵖˡ);
  #[global] Log_get_mu (x : Log.t) :: ⟦StructFieldGet (Logⁱᵐᵖˡ) "mu", #x⟧ ⤳[under] #x.(Log.mu');
  #[global] Log_set_mu (x : Log.t) y :: ⟦StructFieldSet (Logⁱᵐᵖˡ) "mu", (#x, #y)⟧ ⤳[under] #(x <|Log.mu' := y|>);
  #[global] Log_get_log (x : Log.t) :: ⟦StructFieldGet (Logⁱᵐᵖˡ) "log", #x⟧ ⤳[under] #x.(Log.log');
  #[global] Log_set_log (x : Log.t) y :: ⟦StructFieldSet (Logⁱᵐᵖˡ) "log", (#x, #y)⟧ ⤳[under] #(x <|Log.log' := y|>);
  #[global] Log_get_pos (x : Log.t) :: ⟦StructFieldGet (Logⁱᵐᵖˡ) "pos", #x⟧ ⤳[under] #x.(Log.pos');
  #[global] Log_set_pos (x : Log.t) y :: ⟦StructFieldSet (Logⁱᵐᵖˡ) "pos", (#x, #y)⟧ ⤳[under] #(x <|Log.pos' := y|>);
  #[global] Log'ptr_CommitWait_unfold :: MethodUnfold (go.PointerType (Log)) "CommitWait" (Log__CommitWaitⁱᵐᵖˡ);
  #[global] Log'ptr_Flush_unfold :: MethodUnfold (go.PointerType (Log)) "Flush" (Log__Flushⁱᵐᵖˡ);
  #[global] Log'ptr_Load_unfold :: MethodUnfold (go.PointerType (Log)) "Load" (Log__Loadⁱᵐᵖˡ);
  #[global] Log'ptr_LogSz_unfold :: MethodUnfold (go.PointerType (Log)) "LogSz" (Log__LogSzⁱᵐᵖˡ);
  #[global] Log'ptr_Shutdown_unfold :: MethodUnfold (go.PointerType (Log)) "Shutdown" (Log__Shutdownⁱᵐᵖˡ);
  #[global] Log'ptr_doCommit_unfold :: MethodUnfold (go.PointerType (Log)) "doCommit" (Log__doCommitⁱᵐᵖˡ);
  #[global] Log'ptr_installBufs_unfold :: MethodUnfold (go.PointerType (Log)) "installBufs" (Log__installBufsⁱᵐᵖˡ);
  #[global] Log'ptr_installBufsMap_unfold :: MethodUnfold (go.PointerType (Log)) "installBufsMap" (Log__installBufsMapⁱᵐᵖˡ);
}.

Class Assumptions `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Log_instance :: Log_Assumptions;
  #[global] MkLog_unfold :: FuncUnfold MkLog [] (MkLogⁱᵐᵖˡ);
  #[global] import_disk_Assumption :: disk.Assumptions;
  #[global] import_addr_Assumption :: addr.Assumptions;
  #[global] import_buf_Assumption :: buf.Assumptions;
  #[global] import_common_Assumption :: common.Assumptions;
  #[global] import_util_Assumption :: util.Assumptions;
  #[global] import_wal_Assumption :: wal.Assumptions;
  #[global] import_sync_Assumption :: sync.Assumptions;
}.
End obj.
