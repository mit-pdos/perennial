(* autogenerated from github.com/mit-pdos/go-journal/obj *)
Require Export New.code.github_com.goose_lang.primitive.disk.
Require Export New.code.github_com.mit_pdos.go_journal.addr.
Require Export New.code.github_com.mit_pdos.go_journal.buf.
Require Export New.code.github_com.mit_pdos.go_journal.common.
Require Export New.code.github_com.mit_pdos.go_journal.util.
Require Export New.code.github_com.mit_pdos.go_journal.wal.
Require Export New.code.sync.

From New.golang Require Import defn.
Definition obj : go_string := "github.com/mit-pdos/go-journal/obj".

From New Require Import disk_prelude.
Module obj.

Module Log. Definition id : go_string := "github.com/mit-pdos/go-journal/obj.Log"%go. End Log.

Section code.


Definition Log : go_type := structT [
  "mu" :: ptrT;
  "log" :: ptrT;
  "pos" :: wal.LogPosition
].

Definition MkLog : go_string := "github.com/mit-pdos/go-journal/obj.MkLog"%go.

(* MkLog recovers the object logging system
   (or initializes from an all-zero disk).

   go: obj.go:29:6 *)
Definition MkLogⁱᵐᵖˡ : val :=
  λ: "d",
    exception_do (let: "d" := (mem.alloc "d") in
    let: "log" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (let: "$mu" := (mem.alloc (type.zero_val #sync.Mutex)) in
    let: "$log" := (let: "$a0" := (![#disk.Disk] "d") in
    (func_call #wal.MkLog) "$a0") in
    let: "$pos" := #(W64 0) in
    struct.make #Log [{
      "mu" ::= "$mu";
      "log" ::= "$log";
      "pos" ::= "$pos"
    }])) in
    do:  ("log" <-[#ptrT] "$r0");;;
    return: (![#ptrT] "log")).

(* Read a disk object into buf

   go: obj.go:39:15 *)
Definition Log__Loadⁱᵐᵖˡ : val :=
  λ: "l" "addr" "sz",
    exception_do (let: "l" := (mem.alloc "l") in
    let: "sz" := (mem.alloc "sz") in
    let: "addr" := (mem.alloc "addr") in
    let: "blk" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#uint64T] (struct.field_ref #addr.Addr #"Blkno"%go "addr")) in
    (method_call #(ptrT.id wal.Walog.id) #"Read"%go (![#ptrT] (struct.field_ref #Log #"log"%go (![#ptrT] "l")))) "$a0") in
    do:  ("blk" <-[#sliceT] "$r0");;;
    let: "b" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := (![#addr.Addr] "addr") in
    let: "$a1" := (![#uint64T] "sz") in
    let: "$a2" := (![#sliceT] "blk") in
    (func_call #buf.MkBufLoad) "$a0" "$a1" "$a2") in
    do:  ("b" <-[#ptrT] "$r0");;;
    return: (![#ptrT] "b")).

(* Installs bufs into their blocks and returns the blocks.
   A buf may only partially update a disk block and several bufs may
   apply to the same disk block. Assume caller holds commit lock.

   go: obj.go:48:15 *)
Definition Log__installBufsMapⁱᵐᵖˡ : val :=
  λ: "l" "bufs",
    exception_do (let: "l" := (mem.alloc "l") in
    let: "bufs" := (mem.alloc "bufs") in
    let: "blks" := (mem.alloc (type.zero_val (type.mapT #uint64T #sliceT))) in
    let: "$r0" := (map.make #uint64T #sliceT) in
    do:  ("blks" <-[type.mapT #uint64T #sliceT] "$r0");;;
    let: "$range" := (![#sliceT] "bufs") in
    (let: "b" := (mem.alloc (type.zero_val #ptrT)) in
    slice.for_range #ptrT "$range" (λ: "$key" "$value",
      do:  ("b" <-[#ptrT] "$value");;;
      do:  "$key";;;
      (if: (![#uint64T] (struct.field_ref #buf.Buf #"Sz"%go (![#ptrT] "b"))) = common.NBITBLOCK
      then
        let: "$r0" := (![#sliceT] (struct.field_ref #buf.Buf #"Data"%go (![#ptrT] "b"))) in
        do:  (map.insert (![type.mapT #uint64T #sliceT] "blks") (![#uint64T] (struct.field_ref #addr.Addr #"Blkno"%go (struct.field_ref #buf.Buf #"Addr"%go (![#ptrT] "b")))) "$r0")
      else
        let: "blk" := (mem.alloc (type.zero_val #sliceT)) in
        let: "ok" := (mem.alloc (type.zero_val #boolT)) in
        let: "mapblk" := (mem.alloc (type.zero_val #sliceT)) in
        let: ("$ret0", "$ret1") := (map.get (![type.mapT #uint64T #sliceT] "blks") (![#uint64T] (struct.field_ref #addr.Addr #"Blkno"%go (struct.field_ref #buf.Buf #"Addr"%go (![#ptrT] "b"))))) in
        let: "$r0" := "$ret0" in
        let: "$r1" := "$ret1" in
        do:  ("mapblk" <-[#sliceT] "$r0");;;
        do:  ("ok" <-[#boolT] "$r1");;;
        (if: ![#boolT] "ok"
        then
          let: "$r0" := (![#sliceT] "mapblk") in
          do:  ("blk" <-[#sliceT] "$r0")
        else
          let: "$r0" := (let: "$a0" := (![#uint64T] (struct.field_ref #addr.Addr #"Blkno"%go (struct.field_ref #buf.Buf #"Addr"%go (![#ptrT] "b")))) in
          (method_call #(ptrT.id wal.Walog.id) #"Read"%go (![#ptrT] (struct.field_ref #Log #"log"%go (![#ptrT] "l")))) "$a0") in
          do:  ("blk" <-[#sliceT] "$r0");;;
          let: "$r0" := (![#sliceT] "blk") in
          do:  (map.insert (![type.mapT #uint64T #sliceT] "blks") (![#uint64T] (struct.field_ref #addr.Addr #"Blkno"%go (struct.field_ref #buf.Buf #"Addr"%go (![#ptrT] "b")))) "$r0"));;;
        do:  (let: "$a0" := (![#sliceT] "blk") in
        (method_call #(ptrT.id buf.Buf.id) #"Install"%go (![#ptrT] "b")) "$a0"))));;;
    return: (![type.mapT #uint64T #sliceT] "blks")).

(* go: obj.go:70:15 *)
Definition Log__installBufsⁱᵐᵖˡ : val :=
  λ: "l" "bufs",
    exception_do (let: "l" := (mem.alloc "l") in
    let: "bufs" := (mem.alloc "bufs") in
    let: "bufmap" := (mem.alloc (type.zero_val (type.mapT #uint64T #sliceT))) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "bufs") in
    (method_call #(ptrT.id Log.id) #"installBufsMap"%go (![#ptrT] "l")) "$a0") in
    do:  ("bufmap" <-[type.mapT #uint64T #sliceT] "$r0");;;
    let: "blks" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make3 #wal.Update #(W64 0) (let: "$a0" := (![type.mapT #uint64T #sliceT] "bufmap") in
    map.len "$a0")) in
    do:  ("blks" <-[#sliceT] "$r0");;;
    let: "$range" := (![type.mapT #uint64T #sliceT] "bufmap") in
    (let: "data" := (mem.alloc (type.zero_val #sliceT)) in
    let: "blkno" := (mem.alloc (type.zero_val #uint64T)) in
    map.for_range "$range" (λ: "$key" "value",
      do:  ("data" <-[#sliceT] "$value");;;
      do:  ("blkno" <-[#uint64T] "$key");;;
      let: "$r0" := (let: "$a0" := (![#sliceT] "blks") in
      let: "$a1" := ((let: "$sl0" := (let: "$a0" := (![#uint64T] "blkno") in
      let: "$a1" := (![#sliceT] "data") in
      (func_call #wal.MkBlockData) "$a0" "$a1") in
      slice.literal #wal.Update ["$sl0"])) in
      (slice.append #wal.Update) "$a0" "$a1") in
      do:  ("blks" <-[#sliceT] "$r0")));;;
    return: (![#sliceT] "blks")).

(* Acquires the commit log, installs the buffers into their
   blocks, and appends the blocks to the in-memory log.

   go: obj.go:81:15 *)
Definition Log__doCommitⁱᵐᵖˡ : val :=
  λ: "l" "bufs",
    exception_do (let: "l" := (mem.alloc "l") in
    let: "bufs" := (mem.alloc "bufs") in
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] (struct.field_ref #Log #"mu"%go (![#ptrT] "l")))) #());;;
    let: "blks" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "bufs") in
    (method_call #(ptrT.id Log.id) #"installBufs"%go (![#ptrT] "l")) "$a0") in
    do:  ("blks" <-[#sliceT] "$r0");;;
    do:  (let: "$a0" := #(W64 3) in
    let: "$a1" := #"doCommit: %v bufs
    "%go in
    let: "$a2" := ((let: "$sl0" := (interface.make #intT.id (let: "$a0" := (![#sliceT] "blks") in
    slice.len "$a0")) in
    slice.literal #interfaceT ["$sl0"])) in
    (func_call #util.DPrintf) "$a0" "$a1" "$a2");;;
    let: "ok" := (mem.alloc (type.zero_val #boolT)) in
    let: "n" := (mem.alloc (type.zero_val #wal.LogPosition)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "blks") in
    (method_call #(ptrT.id wal.Walog.id) #"MemAppend"%go (![#ptrT] (struct.field_ref #Log #"log"%go (![#ptrT] "l")))) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("n" <-[#wal.LogPosition] "$r0");;;
    do:  ("ok" <-[#boolT] "$r1");;;
    let: "$r0" := (![#wal.LogPosition] "n") in
    do:  ((struct.field_ref #Log #"pos"%go (![#ptrT] "l")) <-[#wal.LogPosition] "$r0");;;
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref #Log #"mu"%go (![#ptrT] "l")))) #());;;
    return: (![#wal.LogPosition] "n", ![#boolT] "ok")).

(* Commit dirty bufs of the transaction into the log, and perhaps wait.

   go: obj.go:98:15 *)
Definition Log__CommitWaitⁱᵐᵖˡ : val :=
  λ: "l" "bufs" "wait",
    exception_do (let: "l" := (mem.alloc "l") in
    let: "wait" := (mem.alloc "wait") in
    let: "bufs" := (mem.alloc "bufs") in
    let: "commit" := (mem.alloc (type.zero_val #boolT)) in
    let: "$r0" := #true in
    do:  ("commit" <-[#boolT] "$r0");;;
    (if: int_gt (let: "$a0" := (![#sliceT] "bufs") in
    slice.len "$a0") #(W64 0)
    then
      let: "ok" := (mem.alloc (type.zero_val #boolT)) in
      let: "n" := (mem.alloc (type.zero_val #wal.LogPosition)) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "bufs") in
      (method_call #(ptrT.id Log.id) #"doCommit"%go (![#ptrT] "l")) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("n" <-[#wal.LogPosition] "$r0");;;
      do:  ("ok" <-[#boolT] "$r1");;;
      (if: (~ (![#boolT] "ok"))
      then
        do:  (let: "$a0" := #(W64 10) in
        let: "$a1" := #"memappend failed; log is too small
        "%go in
        let: "$a2" := #slice.nil in
        (func_call #util.DPrintf) "$a0" "$a1" "$a2");;;
        let: "$r0" := #false in
        do:  ("commit" <-[#boolT] "$r0")
      else
        (if: ![#boolT] "wait"
        then
          do:  (let: "$a0" := (![#wal.LogPosition] "n") in
          (method_call #(ptrT.id wal.Walog.id) #"Flush"%go (![#ptrT] (struct.field_ref #Log #"log"%go (![#ptrT] "l")))) "$a0")
        else do:  #()))
    else
      do:  (let: "$a0" := #(W64 5) in
      let: "$a1" := #"commit read-only trans
      "%go in
      let: "$a2" := #slice.nil in
      (func_call #util.DPrintf) "$a0" "$a1" "$a2"));;;
    return: (![#boolT] "commit")).

(* NOTE: this is coarse-grained and unattached to the transaction ID

   go: obj.go:117:15 *)
Definition Log__Flushⁱᵐᵖˡ : val :=
  λ: "l" <>,
    exception_do (let: "l" := (mem.alloc "l") in
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (![#ptrT] (struct.field_ref #Log #"mu"%go (![#ptrT] "l")))) #());;;
    let: "pos" := (mem.alloc (type.zero_val #wal.LogPosition)) in
    let: "$r0" := (![#wal.LogPosition] (struct.field_ref #Log #"pos"%go (![#ptrT] "l"))) in
    do:  ("pos" <-[#wal.LogPosition] "$r0");;;
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (![#ptrT] (struct.field_ref #Log #"mu"%go (![#ptrT] "l")))) #());;;
    do:  (let: "$a0" := (![#wal.LogPosition] "pos") in
    (method_call #(ptrT.id wal.Walog.id) #"Flush"%go (![#ptrT] (struct.field_ref #Log #"log"%go (![#ptrT] "l")))) "$a0");;;
    return: (#true)).

(* LogSz returns 511 (the size of the wal log)

   go: obj.go:127:15 *)
Definition Log__LogSzⁱᵐᵖˡ : val :=
  λ: "l" <>,
    exception_do (let: "l" := (mem.alloc "l") in
    return: (wal.LOGSZ)).

(* go: obj.go:131:15 *)
Definition Log__Shutdownⁱᵐᵖˡ : val :=
  λ: "l" <>,
    exception_do (let: "l" := (mem.alloc "l") in
    do:  ((method_call #(ptrT.id wal.Walog.id) #"Shutdown"%go (![#ptrT] (struct.field_ref #Log #"log"%go (![#ptrT] "l")))) #());;;
    return: #()).

Definition vars' : list (go_string * go_type) := [].

Definition functions' : list (go_string * val) := [(MkLog, MkLogⁱᵐᵖˡ)].

Definition msets' : list (go_string * (list (go_string * val))) := [(Log.id, []); (ptrT.id Log.id, [("CommitWait"%go, Log__CommitWaitⁱᵐᵖˡ); ("Flush"%go, Log__Flushⁱᵐᵖˡ); ("Load"%go, Log__Loadⁱᵐᵖˡ); ("LogSz"%go, Log__LogSzⁱᵐᵖˡ); ("Shutdown"%go, Log__Shutdownⁱᵐᵖˡ); ("doCommit"%go, Log__doCommitⁱᵐᵖˡ); ("installBufs"%go, Log__installBufsⁱᵐᵖˡ); ("installBufsMap"%go, Log__installBufsMapⁱᵐᵖˡ)])].

#[global] Instance info' : PkgInfo obj.obj :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [disk.disk; addr.addr; buf.buf; common.common; util.util; wal.wal; sync.sync];
  |}.

Definition initialize' : val :=
  λ: <>,
    package.init #obj.obj (λ: <>,
      exception_do (do:  (sync.initialize' #());;;
      do:  (wal.initialize' #());;;
      do:  (util.initialize' #());;;
      do:  (common.initialize' #());;;
      do:  (buf.initialize' #());;;
      do:  (addr.initialize' #());;;
      do:  (disk.initialize' #());;;
      do:  (package.alloc obj.obj #()))
      ).

End code.
End obj.
