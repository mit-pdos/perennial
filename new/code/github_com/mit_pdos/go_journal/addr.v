(* autogenerated from github.com/mit-pdos/go-journal/addr *)
From New.golang Require Import defn.
Require Export New.code.github_com.goose_lang.primitive.disk.
Require Export New.code.github_com.mit_pdos.go_journal.common.

Definition addr : go_string := "github.com/mit-pdos/go-journal/addr".

From New Require Import disk_prelude.
Module addr.
Section code.


Definition Addr : go_type := structT [
  "Blkno" :: uint64T;
  "Off" :: uint64T
].

(* go: addr.go:19:15 *)
Definition Addr__Flatid : val :=
  rec: "Addr__Flatid" "a" <> :=
    exception_do (let: "a" := (mem.alloc "a") in
    return: (((![#uint64T] (struct.field_ref #Addr #"Blkno"%go "a")) * (disk.BlockSize * #(W64 8))) + (![#uint64T] (struct.field_ref #Addr #"Off"%go "a")))).

(* go: addr.go:23:6 *)
Definition MkAddr : val :=
  rec: "MkAddr" "blkno" "off" :=
    exception_do (let: "off" := (mem.alloc "off") in
    let: "blkno" := (mem.alloc "blkno") in
    return: (let: "$Blkno" := (![#uint64T] "blkno") in
     let: "$Off" := (![#uint64T] "off") in
     struct.make #Addr [{
       "Blkno" ::= "$Blkno";
       "Off" ::= "$Off"
     }])).

(* go: addr.go:27:6 *)
Definition MkBitAddr : val :=
  rec: "MkBitAddr" "start" "n" :=
    exception_do (let: "n" := (mem.alloc "n") in
    let: "start" := (mem.alloc "start") in
    let: "bit" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := ((![#uint64T] "n") `rem` common.NBITBLOCK) in
    do:  ("bit" <-[#uint64T] "$r0");;;
    let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := ((![#uint64T] "n") `quot` common.NBITBLOCK) in
    do:  ("i" <-[#uint64T] "$r0");;;
    let: "addr" := (mem.alloc (type.zero_val #Addr)) in
    let: "$r0" := (let: "$a0" := ((![#uint64T] "start") + (![#uint64T] "i")) in
    let: "$a1" := (![#uint64T] "bit") in
    (func_call #addr.addr #"MkAddr"%go) "$a0" "$a1") in
    do:  ("addr" <-[#Addr] "$r0");;;
    return: (![#Addr] "addr")).

Definition vars' : list (go_string * go_type) := [].

Definition functions' : list (go_string * val) := [("MkAddr"%go, MkAddr); ("MkBitAddr"%go, MkBitAddr)].

Definition msets' : list (go_string * (list (go_string * val))) := [("Addr"%go, [("Flatid"%go, Addr__Flatid)]); ("Addr'ptr"%go, [("Flatid"%go, (λ: "$recvAddr",
                 method_call #addr.addr #"Addr" #"Flatid" (![#Addr] "$recvAddr")
                 )%V)])].

#[global] Instance info' : PkgInfo addr.addr :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [disk.disk; common.common];
  |}.

Definition initialize' : val :=
  rec: "initialize'" <> :=
    globals.package_init addr.addr (λ: <>,
      exception_do (do:  common.initialize';;;
      do:  disk.initialize')
      ).

End code.
End addr.
