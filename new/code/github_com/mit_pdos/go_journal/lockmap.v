(* autogenerated from github.com/mit-pdos/go-journal/lockmap *)
Require Export New.code.sync.
From New.golang Require Import defn.
Module pkg_id.
Definition lockmap : go_string := "github.com/mit-pdos/go-journal/lockmap".

End pkg_id.
Export pkg_id.
Module lockmap.

Definition lockState {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/mit-pdos/go-journal/lockmap.lockState"%go [].

Definition lockShard {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/mit-pdos/go-journal/lockmap.lockShard"%go [].

Definition LockMap {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/mit-pdos/go-journal/lockmap.LockMap"%go [].

Definition NSHARD {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 65537).

Definition mkLockShard {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/go-journal/lockmap.mkLockShard"%go.

Definition MkLockMap {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/mit-pdos/go-journal/lockmap.MkLockMap"%go.

(* go: lock.go:30:6 *)
Definition mkLockShardⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "state" := (GoAlloc (go.MapType go.uint64 (go.PointerType lockState)) (GoZeroVal (go.MapType go.uint64 (go.PointerType lockState)) #())) in
    let: "$r0" := ((FuncResolve go.make1 [go.MapType go.uint64 (go.PointerType lockState)] #()) #()) in
    do:  ("state" <-[go.MapType go.uint64 (go.PointerType lockState)] "$r0");;;
    let: "mu" := (GoAlloc (go.PointerType sync.Mutex) (GoZeroVal (go.PointerType sync.Mutex) #())) in
    let: "$r0" := (GoAlloc sync.Mutex (GoZeroVal sync.Mutex #())) in
    do:  ("mu" <-[go.PointerType sync.Mutex] "$r0");;;
    let: "a" := (GoAlloc (go.PointerType lockShard) (GoZeroVal (go.PointerType lockShard) #())) in
    let: "$r0" := (GoAlloc lockShard (let: "$v0" := (![go.PointerType sync.Mutex] "mu") in
    let: "$v1" := (![go.MapType go.uint64 (go.PointerType lockState)] "state") in
    CompositeLiteral lockShard (LiteralValue [KeyedElement (Some (KeyField "mu"%go)) (ElementExpression (go.PointerType sync.Mutex) "$v0"); KeyedElement (Some (KeyField "state"%go)) (ElementExpression (go.MapType go.uint64 (go.PointerType lockState)) "$v1")]))) in
    do:  ("a" <-[go.PointerType lockShard] "$r0");;;
    return: (![go.PointerType lockShard] "a")).

(* go: lock.go:40:24 *)
Definition lockShard__acquireⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "lmap" "addr",
    exception_do (let: "lmap" := (GoAlloc (go.PointerType lockShard) "lmap") in
    let: "addr" := (GoAlloc go.uint64 "addr") in
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] (StructFieldRef lockShard "mu"%go (![go.PointerType lockShard] "lmap")))) #());;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "state" := (GoAlloc (go.PointerType lockState) (GoZeroVal (go.PointerType lockState) #())) in
      let: "ok1" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
      let: "state1" := (GoAlloc (go.PointerType lockState) (GoZeroVal (go.PointerType lockState) #())) in
      let: ("$ret0", "$ret1") := (map.lookup2 go.uint64 (go.PointerType lockState) (![go.MapType go.uint64 (go.PointerType lockState)] (StructFieldRef lockShard "state"%go (![go.PointerType lockShard] "lmap"))) (![go.uint64] "addr")) in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("state1" <-[go.PointerType lockState] "$r0");;;
      do:  ("ok1" <-[go.bool] "$r1");;;
      (if: ![go.bool] "ok1"
      then
        let: "$r0" := (![go.PointerType lockState] "state1") in
        do:  ("state" <-[go.PointerType lockState] "$r0")
      else
        let: "$r0" := (GoAlloc lockState (let: "$v0" := #false in
        let: "$v1" := (let: "$a0" := (Convert (go.PointerType sync.Mutex) sync.Locker (![go.PointerType sync.Mutex] (StructFieldRef lockShard "mu"%go (![go.PointerType lockShard] "lmap")))) in
        (FuncResolve sync.NewCond [] #()) "$a0") in
        let: "$v2" := #(W64 0) in
        CompositeLiteral lockState (LiteralValue [KeyedElement (Some (KeyField "held"%go)) (ElementExpression go.bool "$v0"); KeyedElement (Some (KeyField "cond"%go)) (ElementExpression (go.PointerType sync.Cond) "$v1"); KeyedElement (Some (KeyField "waiters"%go)) (ElementExpression go.uint64 "$v2")]))) in
        do:  ("state" <-[go.PointerType lockState] "$r0");;;
        let: "$r0" := (![go.PointerType lockState] "state") in
        do:  (map.insert go.uint64 (![go.MapType go.uint64 (go.PointerType lockState)] (StructFieldRef lockShard "state"%go (![go.PointerType lockShard] "lmap"))) (![go.uint64] "addr") "$r0"));;;
      let: "acquired" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
      (if: (⟨go.bool⟩! (![go.bool] (StructFieldRef lockState "held"%go (![go.PointerType lockState] "state"))))
      then
        let: "$r0" := #true in
        do:  ((StructFieldRef lockState "held"%go (![go.PointerType lockState] "state")) <-[go.bool] "$r0");;;
        let: "$r0" := #true in
        do:  ("acquired" <-[go.bool] "$r0")
      else
        do:  ((StructFieldRef lockState "waiters"%go (![go.PointerType lockState] "state")) <-[go.uint64] ((![go.uint64] (StructFieldRef lockState "waiters"%go (![go.PointerType lockState] "state"))) +⟨go.uint64⟩ #(W64 1)));;;
        do:  ((MethodResolve (go.PointerType sync.Cond) "Wait"%go (![go.PointerType sync.Cond] (StructFieldRef lockState "cond"%go (![go.PointerType lockState] "state")))) #());;;
        let: "ok2" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
        let: "state2" := (GoAlloc (go.PointerType lockState) (GoZeroVal (go.PointerType lockState) #())) in
        let: ("$ret0", "$ret1") := (map.lookup2 go.uint64 (go.PointerType lockState) (![go.MapType go.uint64 (go.PointerType lockState)] (StructFieldRef lockShard "state"%go (![go.PointerType lockShard] "lmap"))) (![go.uint64] "addr")) in
        let: "$r0" := "$ret0" in
        let: "$r1" := "$ret1" in
        do:  ("state2" <-[go.PointerType lockState] "$r0");;;
        do:  ("ok2" <-[go.bool] "$r1");;;
        (if: ![go.bool] "ok2"
        then do:  ((StructFieldRef lockState "waiters"%go (![go.PointerType lockState] "state2")) <-[go.uint64] ((![go.uint64] (StructFieldRef lockState "waiters"%go (![go.PointerType lockState] "state2"))) -⟨go.uint64⟩ #(W64 1)))
        else do:  #()));;;
      (if: ![go.bool] "acquired"
      then break: #()
      else do:  #());;;
      continue: #());;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef lockShard "mu"%go (![go.PointerType lockShard] "lmap")))) #());;;
    return: #()).

(* go: lock.go:81:24 *)
Definition lockShard__releaseⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "lmap" "addr",
    exception_do (let: "lmap" := (GoAlloc (go.PointerType lockShard) "lmap") in
    let: "addr" := (GoAlloc go.uint64 "addr") in
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (![go.PointerType sync.Mutex] (StructFieldRef lockShard "mu"%go (![go.PointerType lockShard] "lmap")))) #());;;
    let: "state" := (GoAlloc (go.PointerType lockState) (GoZeroVal (go.PointerType lockState) #())) in
    let: "$r0" := (map.lookup1 go.uint64 (go.PointerType lockState) (![go.MapType go.uint64 (go.PointerType lockState)] (StructFieldRef lockShard "state"%go (![go.PointerType lockShard] "lmap"))) (![go.uint64] "addr")) in
    do:  ("state" <-[go.PointerType lockState] "$r0");;;
    let: "$r0" := #false in
    do:  ((StructFieldRef lockState "held"%go (![go.PointerType lockState] "state")) <-[go.bool] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] (StructFieldRef lockState "waiters"%go (![go.PointerType lockState] "state"))) >⟨go.uint64⟩ #(W64 0))
    then do:  ((MethodResolve (go.PointerType sync.Cond) "Signal"%go (![go.PointerType sync.Cond] (StructFieldRef lockState "cond"%go (![go.PointerType lockState] "state")))) #())
    else
      do:  (let: "$a0" := (![go.MapType go.uint64 (go.PointerType lockState)] (StructFieldRef lockShard "state"%go (![go.PointerType lockShard] "lmap"))) in
      let: "$a1" := (![go.uint64] "addr") in
      (FuncResolve go.delete [go.MapType go.uint64 (go.PointerType lockState)] #()) "$a0" "$a1"));;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (![go.PointerType sync.Mutex] (StructFieldRef lockShard "mu"%go (![go.PointerType lockShard] "lmap")))) #());;;
    return: #()).

(* go: lock.go:99:6 *)
Definition MkLockMapⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "shards" := (GoAlloc (go.SliceType (go.PointerType lockShard)) (GoZeroVal (go.SliceType (go.PointerType lockShard)) #())) in
    (let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, (![go.uint64] "i") <⟨go.uint64⟩ NSHARD); (λ: <>, do:  ("i" <-[go.uint64] ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 1)))) := λ: <>,
      let: "$r0" := (let: "$a0" := (![go.SliceType (go.PointerType lockShard)] "shards") in
      let: "$a1" := ((let: "$sl0" := ((FuncResolve mkLockShard [] #()) #()) in
      CompositeLiteral (go.SliceType (go.PointerType lockShard)) (LiteralValue [KeyedElement None (ElementExpression (go.PointerType lockShard) "$sl0")]))) in
      (FuncResolve go.append [go.SliceType (go.PointerType lockShard)] #()) "$a0" "$a1") in
      do:  ("shards" <-[go.SliceType (go.PointerType lockShard)] "$r0")));;;
    let: "a" := (GoAlloc (go.PointerType LockMap) (GoZeroVal (go.PointerType LockMap) #())) in
    let: "$r0" := (GoAlloc LockMap (let: "$v0" := (![go.SliceType (go.PointerType lockShard)] "shards") in
    CompositeLiteral LockMap (LiteralValue [KeyedElement (Some (KeyField "shards"%go)) (ElementExpression (go.SliceType (go.PointerType lockShard)) "$v0")]))) in
    do:  ("a" <-[go.PointerType LockMap] "$r0");;;
    return: (![go.PointerType LockMap] "a")).

(* go: lock.go:110:22 *)
Definition LockMap__Acquireⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "lmap" "flataddr",
    exception_do (let: "lmap" := (GoAlloc (go.PointerType LockMap) "lmap") in
    let: "flataddr" := (GoAlloc go.uint64 "flataddr") in
    let: "shard" := (GoAlloc (go.PointerType lockShard) (GoZeroVal (go.PointerType lockShard) #())) in
    let: "$r0" := (![go.PointerType lockShard] (IndexRef (go.SliceType (go.PointerType lockShard)) (![go.SliceType (go.PointerType lockShard)] (StructFieldRef LockMap "shards"%go (![go.PointerType LockMap] "lmap")), Convert go.uint64 go.int ((![go.uint64] "flataddr") %⟨go.uint64⟩ NSHARD)))) in
    do:  ("shard" <-[go.PointerType lockShard] "$r0");;;
    do:  (let: "$a0" := (![go.uint64] "flataddr") in
    (MethodResolve (go.PointerType lockShard) "acquire"%go (![go.PointerType lockShard] "shard")) "$a0");;;
    return: #()).

(* go: lock.go:115:22 *)
Definition LockMap__Releaseⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "lmap" "flataddr",
    exception_do (let: "lmap" := (GoAlloc (go.PointerType LockMap) "lmap") in
    let: "flataddr" := (GoAlloc go.uint64 "flataddr") in
    let: "shard" := (GoAlloc (go.PointerType lockShard) (GoZeroVal (go.PointerType lockShard) #())) in
    let: "$r0" := (![go.PointerType lockShard] (IndexRef (go.SliceType (go.PointerType lockShard)) (![go.SliceType (go.PointerType lockShard)] (StructFieldRef LockMap "shards"%go (![go.PointerType LockMap] "lmap")), Convert go.uint64 go.int ((![go.uint64] "flataddr") %⟨go.uint64⟩ NSHARD)))) in
    do:  ("shard" <-[go.PointerType lockShard] "$r0");;;
    do:  (let: "$a0" := (![go.uint64] "flataddr") in
    (MethodResolve (go.PointerType lockShard) "release"%go (![go.PointerType lockShard] "shard")) "$a0");;;
    return: #()).

#[global] Instance info' : PkgInfo pkg_id.lockmap :=
{|
  pkg_imported_pkgs := [code.sync.pkg_id.sync]
|}.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init pkg_id.lockmap (λ: <>,
      exception_do (do:  (sync.initialize' #()))
      ).

Module lockState.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  held' : bool;
  cond' : loc;
  waiters' : w64;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End lockState.

Definition lockState'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "held"%go go.bool);
  (go.FieldDecl "cond"%go (go.PointerType sync.Cond));
  (go.FieldDecl "waiters"%go go.uint64)
].
Program Definition lockState'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (lockState'fds_unsealed).
Global Instance equals_unfold_lockState {ext : ffi_syntax} {go_gctx : GoGlobalContext} : lockState'fds =→ lockState'fds_unsealed.
Proof. rewrite /lockState'fds seal_eq //. Qed.

Definition lockStateⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (lockState'fds).

Class lockState_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] lockState_type_repr  :: go.TypeReprUnderlying lockStateⁱᵐᵖˡ lockState.t;
  #[global] lockState_underlying :: (lockState) <u (lockStateⁱᵐᵖˡ);
  #[global] lockState_get_held (x : lockState.t) :: ⟦StructFieldGet (lockStateⁱᵐᵖˡ) "held", #x⟧ ⤳[under] #x.(lockState.held');
  #[global] lockState_set_held (x : lockState.t) y :: ⟦StructFieldSet (lockStateⁱᵐᵖˡ) "held", (#x, #y)⟧ ⤳[under] #(x <|lockState.held' := y|>);
  #[global] lockState_get_cond (x : lockState.t) :: ⟦StructFieldGet (lockStateⁱᵐᵖˡ) "cond", #x⟧ ⤳[under] #x.(lockState.cond');
  #[global] lockState_set_cond (x : lockState.t) y :: ⟦StructFieldSet (lockStateⁱᵐᵖˡ) "cond", (#x, #y)⟧ ⤳[under] #(x <|lockState.cond' := y|>);
  #[global] lockState_get_waiters (x : lockState.t) :: ⟦StructFieldGet (lockStateⁱᵐᵖˡ) "waiters", #x⟧ ⤳[under] #x.(lockState.waiters');
  #[global] lockState_set_waiters (x : lockState.t) y :: ⟦StructFieldSet (lockStateⁱᵐᵖˡ) "waiters", (#x, #y)⟧ ⤳[under] #(x <|lockState.waiters' := y|>);
}.

Module lockShard.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  mu' : loc;
  state' : map.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End lockShard.

Definition lockShard'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "mu"%go (go.PointerType sync.Mutex));
  (go.FieldDecl "state"%go (go.MapType go.uint64 (go.PointerType lockState)))
].
Program Definition lockShard'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (lockShard'fds_unsealed).
Global Instance equals_unfold_lockShard {ext : ffi_syntax} {go_gctx : GoGlobalContext} : lockShard'fds =→ lockShard'fds_unsealed.
Proof. rewrite /lockShard'fds seal_eq //. Qed.

Definition lockShardⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (lockShard'fds).

Class lockShard_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] lockShard_type_repr  :: go.TypeReprUnderlying lockShardⁱᵐᵖˡ lockShard.t;
  #[global] lockShard_underlying :: (lockShard) <u (lockShardⁱᵐᵖˡ);
  #[global] lockShard_get_mu (x : lockShard.t) :: ⟦StructFieldGet (lockShardⁱᵐᵖˡ) "mu", #x⟧ ⤳[under] #x.(lockShard.mu');
  #[global] lockShard_set_mu (x : lockShard.t) y :: ⟦StructFieldSet (lockShardⁱᵐᵖˡ) "mu", (#x, #y)⟧ ⤳[under] #(x <|lockShard.mu' := y|>);
  #[global] lockShard_get_state (x : lockShard.t) :: ⟦StructFieldGet (lockShardⁱᵐᵖˡ) "state", #x⟧ ⤳[under] #x.(lockShard.state');
  #[global] lockShard_set_state (x : lockShard.t) y :: ⟦StructFieldSet (lockShardⁱᵐᵖˡ) "state", (#x, #y)⟧ ⤳[under] #(x <|lockShard.state' := y|>);
  #[global] lockShard'ptr_acquire_unfold :: MethodUnfold (go.PointerType (lockShard)) "acquire" (lockShard__acquireⁱᵐᵖˡ);
  #[global] lockShard'ptr_release_unfold :: MethodUnfold (go.PointerType (lockShard)) "release" (lockShard__releaseⁱᵐᵖˡ);
}.

Module LockMap.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  shards' : slice.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End LockMap.

Definition LockMap'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "shards"%go (go.SliceType (go.PointerType lockShard)))
].
Program Definition LockMap'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (LockMap'fds_unsealed).
Global Instance equals_unfold_LockMap {ext : ffi_syntax} {go_gctx : GoGlobalContext} : LockMap'fds =→ LockMap'fds_unsealed.
Proof. rewrite /LockMap'fds seal_eq //. Qed.

Definition LockMapⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (LockMap'fds).

Class LockMap_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] LockMap_type_repr  :: go.TypeReprUnderlying LockMapⁱᵐᵖˡ LockMap.t;
  #[global] LockMap_underlying :: (LockMap) <u (LockMapⁱᵐᵖˡ);
  #[global] LockMap_get_shards (x : LockMap.t) :: ⟦StructFieldGet (LockMapⁱᵐᵖˡ) "shards", #x⟧ ⤳[under] #x.(LockMap.shards');
  #[global] LockMap_set_shards (x : LockMap.t) y :: ⟦StructFieldSet (LockMapⁱᵐᵖˡ) "shards", (#x, #y)⟧ ⤳[under] #(x <|LockMap.shards' := y|>);
  #[global] LockMap'ptr_Acquire_unfold :: MethodUnfold (go.PointerType (LockMap)) "Acquire" (LockMap__Acquireⁱᵐᵖˡ);
  #[global] LockMap'ptr_Release_unfold :: MethodUnfold (go.PointerType (LockMap)) "Release" (LockMap__Releaseⁱᵐᵖˡ);
}.

Class Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] lockState_instance :: lockState_Assumptions;
  #[global] lockShard_instance :: lockShard_Assumptions;
  #[global] LockMap_instance :: LockMap_Assumptions;
  #[global] mkLockShard_unfold :: FuncUnfold mkLockShard [] (mkLockShardⁱᵐᵖˡ);
  #[global] MkLockMap_unfold :: FuncUnfold MkLockMap [] (MkLockMapⁱᵐᵖˡ);
  #[global] import_sync_Assumption :: sync.Assumptions;
}.
End lockmap.
