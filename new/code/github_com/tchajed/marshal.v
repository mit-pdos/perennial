(* autogenerated from github.com/tchajed/marshal *)
Require Export New.code.github_com.goose_lang.primitive.
Require Export New.code.github_com.goose_lang.std.

From New.golang Require Import defn.
Definition marshal : go_string := "github.com/tchajed/marshal".

Module marshal.

Module Enc. Definition id : go_string := "github.com/tchajed/marshal.Enc"%go. End Enc.
Module Dec. Definition id : go_string := "github.com/tchajed/marshal.Dec"%go. End Dec.

Section code.
Context `{ffi_syntax}.


Definition Enc : go_type := structT [
  "b" :: sliceT;
  "off" :: ptrT
].

Definition NewEncFromSlice : go_string := "github.com/tchajed/marshal.NewEncFromSlice"%go.

Axiom NewEncFromSliceⁱᵐᵖˡ : val.

Definition NewEnc : go_string := "github.com/tchajed/marshal.NewEnc"%go.

Axiom NewEncⁱᵐᵖˡ : val.

Axiom Enc__PutIntⁱᵐᵖˡ : val.

Axiom Enc__PutInt32ⁱᵐᵖˡ : val.

Axiom Enc__PutIntsⁱᵐᵖˡ : val.

Axiom Enc__PutBytesⁱᵐᵖˡ : val.

Definition bool2byte : go_string := "github.com/tchajed/marshal.bool2byte"%go.

Axiom bool2byteⁱᵐᵖˡ : val.

Axiom Enc__PutBoolⁱᵐᵖˡ : val.

Axiom Enc__Finishⁱᵐᵖˡ : val.

Definition Dec : go_type := structT [
  "b" :: sliceT;
  "off" :: ptrT
].

Definition NewDec : go_string := "github.com/tchajed/marshal.NewDec"%go.

Axiom NewDecⁱᵐᵖˡ : val.

Axiom Dec__GetIntⁱᵐᵖˡ : val.

Axiom Dec__GetInt32ⁱᵐᵖˡ : val.

Axiom Dec__GetIntsⁱᵐᵖˡ : val.

Axiom Dec__GetBytesⁱᵐᵖˡ : val.

Axiom Dec__GetBoolⁱᵐᵖˡ : val.

Definition compute_new_cap : go_string := "github.com/tchajed/marshal.compute_new_cap"%go.

(* go: stateless.go:8:6 *)
Definition compute_new_capⁱᵐᵖˡ : val :=
  λ: "old_cap" "min_cap",
    exception_do (let: "min_cap" := (mem.alloc "min_cap") in
    let: "old_cap" := (mem.alloc "old_cap") in
    let: "new_cap" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := ((![#uint64T] "old_cap") * #(W64 2)) in
    do:  ("new_cap" <-[#uint64T] "$r0");;;
    (if: (![#uint64T] "new_cap") < (![#uint64T] "min_cap")
    then
      let: "$r0" := (![#uint64T] "min_cap") in
      do:  ("new_cap" <-[#uint64T] "$r0")
    else do:  #());;;
    return: (![#uint64T] "new_cap")).

Definition reserve : go_string := "github.com/tchajed/marshal.reserve"%go.

(* Grow a slice to have at least `additional` unused bytes in the capacity.
   Runtime-check against overflow.

   go: stateless.go:19:6 *)
Definition reserveⁱᵐᵖˡ : val :=
  λ: "b" "additional",
    exception_do (let: "additional" := (mem.alloc "additional") in
    let: "b" := (mem.alloc "b") in
    let: "min_cap" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (let: "$a0" := (s_to_w64 (let: "$a0" := (![#sliceT] "b") in
    slice.len "$a0")) in
    let: "$a1" := (![#uint64T] "additional") in
    (func_call #std.SumAssumeNoOverflow) "$a0" "$a1") in
    do:  ("min_cap" <-[#uint64T] "$r0");;;
    (if: (s_to_w64 (let: "$a0" := (![#sliceT] "b") in
    slice.cap "$a0")) < (![#uint64T] "min_cap")
    then
      let: "new_cap" := (mem.alloc (type.zero_val #uint64T)) in
      let: "$r0" := (let: "$a0" := (s_to_w64 (let: "$a0" := (![#sliceT] "b") in
      slice.cap "$a0")) in
      let: "$a1" := (![#uint64T] "min_cap") in
      (func_call #compute_new_cap) "$a0" "$a1") in
      do:  ("new_cap" <-[#uint64T] "$r0");;;
      let: "dest" := (mem.alloc (type.zero_val #sliceT)) in
      let: "$r0" := (slice.make3 #byteT (let: "$a0" := (![#sliceT] "b") in
      slice.len "$a0") (![#uint64T] "new_cap")) in
      do:  ("dest" <-[#sliceT] "$r0");;;
      do:  (let: "$a0" := (![#sliceT] "dest") in
      let: "$a1" := (![#sliceT] "b") in
      (slice.copy #byteT) "$a0" "$a1");;;
      return: (![#sliceT] "dest")
    else return: (![#sliceT] "b"))).

Definition ReadInt : go_string := "github.com/tchajed/marshal.ReadInt"%go.

(* go: stateless.go:40:6 *)
Definition ReadIntⁱᵐᵖˡ : val :=
  λ: "b",
    exception_do (let: "b" := (mem.alloc "b") in
    let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    (func_call #primitive.UInt64Get) "$a0") in
    do:  ("i" <-[#uint64T] "$r0");;;
    return: (![#uint64T] "i", let: "$s" := (![#sliceT] "b") in
     slice.slice #byteT "$s" #(W64 8) (slice.len "$s"))).

Definition ReadInt32 : go_string := "github.com/tchajed/marshal.ReadInt32"%go.

(* go: stateless.go:45:6 *)
Definition ReadInt32ⁱᵐᵖˡ : val :=
  λ: "b",
    exception_do (let: "b" := (mem.alloc "b") in
    let: "i" := (mem.alloc (type.zero_val #uint32T)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    (func_call #primitive.UInt32Get) "$a0") in
    do:  ("i" <-[#uint32T] "$r0");;;
    return: (![#uint32T] "i", let: "$s" := (![#sliceT] "b") in
     slice.slice #byteT "$s" #(W64 4) (slice.len "$s"))).

Definition ReadInts : go_string := "github.com/tchajed/marshal.ReadInts"%go.

Axiom ReadIntsⁱᵐᵖˡ : val.

Definition ReadBytes : go_string := "github.com/tchajed/marshal.ReadBytes"%go.

(* ReadBytes reads `l` bytes from b and returns (bs, rest)

   go: stateless.go:62:6 *)
Definition ReadBytesⁱᵐᵖˡ : val :=
  λ: "b" "l",
    exception_do (let: "l" := (mem.alloc "l") in
    let: "b" := (mem.alloc "b") in
    let: "s" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$s" := (![#sliceT] "b") in
    slice.slice #byteT "$s" #(W64 0) (![#uint64T] "l")) in
    do:  ("s" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "s", let: "$s" := (![#sliceT] "b") in
     slice.slice #byteT "$s" (![#uint64T] "l") (slice.len "$s"))).

Definition ReadBytesCopy : go_string := "github.com/tchajed/marshal.ReadBytesCopy"%go.

(* Like ReadBytes, but avoids keeping the source slice [b] alive.

   go: stateless.go:68:6 *)
Definition ReadBytesCopyⁱᵐᵖˡ : val :=
  λ: "b" "l",
    exception_do (let: "l" := (mem.alloc "l") in
    let: "b" := (mem.alloc "b") in
    let: "s" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make2 #byteT (![#uint64T] "l")) in
    do:  ("s" <-[#sliceT] "$r0");;;
    do:  (let: "$a0" := (![#sliceT] "s") in
    let: "$a1" := (let: "$s" := (![#sliceT] "b") in
    slice.slice #byteT "$s" #(W64 0) (![#uint64T] "l")) in
    (slice.copy #byteT) "$a0" "$a1");;;
    return: (![#sliceT] "s", let: "$s" := (![#sliceT] "b") in
     slice.slice #byteT "$s" (![#uint64T] "l") (slice.len "$s"))).

Definition ReadBool : go_string := "github.com/tchajed/marshal.ReadBool"%go.

(* go: stateless.go:74:6 *)
Definition ReadBoolⁱᵐᵖˡ : val :=
  λ: "b",
    exception_do (let: "b" := (mem.alloc "b") in
    let: "x" := (mem.alloc (type.zero_val #boolT)) in
    let: "$r0" := ((![#byteT] (slice.elem_ref #byteT (![#sliceT] "b") #(W64 0))) ≠ #(W8 0)) in
    do:  ("x" <-[#boolT] "$r0");;;
    return: (![#boolT] "x", let: "$s" := (![#sliceT] "b") in
     slice.slice #byteT "$s" #(W64 1) (slice.len "$s"))).

Definition ReadLenPrefixedBytes : go_string := "github.com/tchajed/marshal.ReadLenPrefixedBytes"%go.

(* go: stateless.go:79:6 *)
Definition ReadLenPrefixedBytesⁱᵐᵖˡ : val :=
  λ: "b",
    exception_do (let: "b" := (mem.alloc "b") in
    let: "b2" := (mem.alloc (type.zero_val #sliceT)) in
    let: "l" := (mem.alloc (type.zero_val #uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "b") in
    (func_call #ReadInt) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("l" <-[#uint64T] "$r0");;;
    do:  ("b2" <-[#sliceT] "$r1");;;
    let: "b3" := (mem.alloc (type.zero_val #sliceT)) in
    let: "bs" := (mem.alloc (type.zero_val #sliceT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "b2") in
    let: "$a1" := (![#uint64T] "l") in
    (func_call #ReadBytes) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("bs" <-[#sliceT] "$r0");;;
    do:  ("b3" <-[#sliceT] "$r1");;;
    return: (![#sliceT] "bs", ![#sliceT] "b3")).

Definition WriteInt : go_string := "github.com/tchajed/marshal.WriteInt"%go.

(* WriteInt appends i in little-endian format to b, returning the new slice.

   go: stateless.go:88:6 *)
Definition WriteIntⁱᵐᵖˡ : val :=
  λ: "b" "i",
    exception_do (let: "i" := (mem.alloc "i") in
    let: "b" := (mem.alloc "b") in
    let: "b2" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := #(W64 8) in
    (func_call #reserve) "$a0" "$a1") in
    do:  ("b2" <-[#sliceT] "$r0");;;
    let: "off" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "b2") in
    slice.len "$a0") in
    do:  ("off" <-[#intT] "$r0");;;
    let: "b3" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$s" := (![#sliceT] "b2") in
    slice.slice #byteT "$s" #(W64 0) ((![#intT] "off") + #(W64 8))) in
    do:  ("b3" <-[#sliceT] "$r0");;;
    do:  (let: "$a0" := (let: "$s" := (![#sliceT] "b3") in
    slice.slice #byteT "$s" (![#intT] "off") (slice.len "$s")) in
    let: "$a1" := (![#uint64T] "i") in
    (func_call #primitive.UInt64Put) "$a0" "$a1");;;
    return: (![#sliceT] "b3")).

Definition WriteInt32 : go_string := "github.com/tchajed/marshal.WriteInt32"%go.

(* WriteInt32 appends 32-bit integer i in little-endian format to b, returning the new slice.

   go: stateless.go:98:6 *)
Definition WriteInt32ⁱᵐᵖˡ : val :=
  λ: "b" "i",
    exception_do (let: "i" := (mem.alloc "i") in
    let: "b" := (mem.alloc "b") in
    let: "b2" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := #(W64 4) in
    (func_call #reserve) "$a0" "$a1") in
    do:  ("b2" <-[#sliceT] "$r0");;;
    let: "off" := (mem.alloc (type.zero_val #intT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "b2") in
    slice.len "$a0") in
    do:  ("off" <-[#intT] "$r0");;;
    let: "b3" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$s" := (![#sliceT] "b2") in
    slice.slice #byteT "$s" #(W64 0) ((![#intT] "off") + #(W64 4))) in
    do:  ("b3" <-[#sliceT] "$r0");;;
    do:  (let: "$a0" := (let: "$s" := (![#sliceT] "b3") in
    slice.slice #byteT "$s" (![#intT] "off") (slice.len "$s")) in
    let: "$a1" := (![#uint32T] "i") in
    (func_call #primitive.UInt32Put) "$a0" "$a1");;;
    return: (![#sliceT] "b3")).

Definition WriteBytes : go_string := "github.com/tchajed/marshal.WriteBytes"%go.

(* Append data to b, returning the new slice.

   go: stateless.go:107:6 *)
Definition WriteBytesⁱᵐᵖˡ : val :=
  λ: "b" "data",
    exception_do (let: "data" := (mem.alloc "data") in
    let: "b" := (mem.alloc "b") in
    return: (let: "$a0" := (![#sliceT] "b") in
     let: "$a1" := (![#sliceT] "data") in
     (slice.append #byteT) "$a0" "$a1")).

Definition WriteInts : go_string := "github.com/tchajed/marshal.WriteInts"%go.

Axiom WriteIntsⁱᵐᵖˡ : val.

Definition WriteBool : go_string := "github.com/tchajed/marshal.WriteBool"%go.

(* go: stateless.go:119:6 *)
Definition WriteBoolⁱᵐᵖˡ : val :=
  λ: "b" "x",
    exception_do (let: "x" := (mem.alloc "x") in
    let: "b" := (mem.alloc "b") in
    (if: ![#boolT] "x"
    then
      return: (let: "$a0" := (![#sliceT] "b") in
       let: "$a1" := ((let: "$sl0" := #(W8 1) in
       slice.literal #byteT ["$sl0"])) in
       (slice.append #byteT) "$a0" "$a1")
    else
      return: (let: "$a0" := (![#sliceT] "b") in
       let: "$a1" := ((let: "$sl0" := #(W8 0) in
       slice.literal #byteT ["$sl0"])) in
       (slice.append #byteT) "$a0" "$a1"))).

Definition WriteLenPrefixedBytes : go_string := "github.com/tchajed/marshal.WriteLenPrefixedBytes"%go.

(* go: stateless.go:127:6 *)
Definition WriteLenPrefixedBytesⁱᵐᵖˡ : val :=
  λ: "b" "bs",
    exception_do (let: "bs" := (mem.alloc "bs") in
    let: "b" := (mem.alloc "b") in
    let: "b2" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (s_to_w64 (let: "$a0" := (![#sliceT] "bs") in
    slice.len "$a0")) in
    (func_call #WriteInt) "$a0" "$a1") in
    do:  ("b2" <-[#sliceT] "$r0");;;
    return: (let: "$a0" := (![#sliceT] "b2") in
     let: "$a1" := (![#sliceT] "bs") in
     (func_call #WriteBytes) "$a0" "$a1")).

Definition ReadSlice : go_string := "github.com/tchajed/marshal.ReadSlice"%go.

(* go: stateless_slice.go:3:6 *)
Definition ReadSliceⁱᵐᵖˡ : val :=
  λ: "T" "b" "count" "readOne",
    exception_do (let: "readOne" := (mem.alloc "readOne") in
    let: "count" := (mem.alloc "count") in
    let: "b" := (mem.alloc "b") in
    let: "b2" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "b") in
    do:  ("b2" <-[#sliceT] "$r0");;;
    let: "xs" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := #slice.nil in
    do:  ("xs" <-[#sliceT] "$r0");;;
    (let: "i" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[#uint64T] "$r0");;;
    (for: (λ: <>, (![#uint64T] "i") < (![#uint64T] "count")); (λ: <>, do:  ("i" <-[#uint64T] ((![#uint64T] "i") + #(W64 1)))) := λ: <>,
      let: "bNew" := (mem.alloc (type.zero_val #sliceT)) in
      let: "xNew" := (mem.alloc (type.zero_val "T")) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "b2") in
      (![#funcT] "readOne") "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("xNew" <-["T"] "$r0");;;
      do:  ("bNew" <-[#sliceT] "$r1");;;
      let: "$r0" := (let: "$a0" := (![#sliceT] "xs") in
      let: "$a1" := ((let: "$sl0" := (!["T"] "xNew") in
      slice.literal "T" ["$sl0"])) in
      (slice.append "T") "$a0" "$a1") in
      do:  ("xs" <-[#sliceT] "$r0");;;
      let: "$r0" := (![#sliceT] "bNew") in
      do:  ("b2" <-[#sliceT] "$r0")));;;
    return: (![#sliceT] "xs", ![#sliceT] "b2")).

Definition ReadSliceLenPrefix : go_string := "github.com/tchajed/marshal.ReadSliceLenPrefix"%go.

(* go: stateless_slice.go:14:6 *)
Definition ReadSliceLenPrefixⁱᵐᵖˡ : val :=
  λ: "T" "b" "readOne",
    exception_do (let: "readOne" := (mem.alloc "readOne") in
    let: "b" := (mem.alloc "b") in
    let: "b2" := (mem.alloc (type.zero_val #sliceT)) in
    let: "count" := (mem.alloc (type.zero_val #uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#sliceT] "b") in
    (func_call #ReadInt) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("count" <-[#uint64T] "$r0");;;
    do:  ("b2" <-[#sliceT] "$r1");;;
    let: ("$ret0", "$ret1") := ((let: "$a0" := (![#sliceT] "b2") in
    let: "$a1" := (![#uint64T] "count") in
    let: "$a2" := (![#funcT] "readOne") in
    ((func_call #ReadSlice) "T") "$a0" "$a1" "$a2")) in
    return: ("$ret0", "$ret1")).

Definition WriteSlice : go_string := "github.com/tchajed/marshal.WriteSlice"%go.

(* go: stateless_slice.go:19:6 *)
Definition WriteSliceⁱᵐᵖˡ : val :=
  λ: "T" "b" "xs" "writeOne",
    exception_do (let: "writeOne" := (mem.alloc "writeOne") in
    let: "xs" := (mem.alloc "xs") in
    let: "b" := (mem.alloc "b") in
    let: "b2" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] "b") in
    do:  ("b2" <-[#sliceT] "$r0");;;
    let: "$range" := (![#sliceT] "xs") in
    (let: "x" := (mem.alloc (type.zero_val "T")) in
    slice.for_range "T" "$range" (λ: "$key" "$value",
      do:  ("x" <-["T"] "$value");;;
      do:  "$key";;;
      let: "$r0" := (let: "$a0" := (![#sliceT] "b2") in
      let: "$a1" := (!["T"] "x") in
      (![#funcT] "writeOne") "$a0" "$a1") in
      do:  ("b2" <-[#sliceT] "$r0")));;;
    return: (![#sliceT] "b2")).

Definition WriteSliceLenPrefix : go_string := "github.com/tchajed/marshal.WriteSliceLenPrefix"%go.

(* go: stateless_slice.go:27:6 *)
Definition WriteSliceLenPrefixⁱᵐᵖˡ : val :=
  λ: "T" "b" "xs" "writeOne",
    exception_do (let: "writeOne" := (mem.alloc "writeOne") in
    let: "xs" := (mem.alloc "xs") in
    let: "b" := (mem.alloc "b") in
    let: "b2" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "b") in
    let: "$a1" := (s_to_w64 (let: "$a0" := (![#sliceT] "xs") in
    slice.len "$a0")) in
    (func_call #WriteInt) "$a0" "$a1") in
    do:  ("b2" <-[#sliceT] "$r0");;;
    let: "b3" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "b2") in
    let: "$a1" := (![#sliceT] "xs") in
    let: "$a2" := (![#funcT] "writeOne") in
    ((func_call #WriteSlice) "T") "$a0" "$a1" "$a2") in
    do:  ("b3" <-[#sliceT] "$r0");;;
    return: (![#sliceT] "b3")).

Definition vars' : list (go_string * go_type) := [].

Definition functions' : list (go_string * val) := [(NewEncFromSlice, NewEncFromSliceⁱᵐᵖˡ); (NewEnc, NewEncⁱᵐᵖˡ); (bool2byte, bool2byteⁱᵐᵖˡ); (NewDec, NewDecⁱᵐᵖˡ); (compute_new_cap, compute_new_capⁱᵐᵖˡ); (reserve, reserveⁱᵐᵖˡ); (ReadInt, ReadIntⁱᵐᵖˡ); (ReadInt32, ReadInt32ⁱᵐᵖˡ); (ReadInts, ReadIntsⁱᵐᵖˡ); (ReadBytes, ReadBytesⁱᵐᵖˡ); (ReadBytesCopy, ReadBytesCopyⁱᵐᵖˡ); (ReadBool, ReadBoolⁱᵐᵖˡ); (ReadLenPrefixedBytes, ReadLenPrefixedBytesⁱᵐᵖˡ); (WriteInt, WriteIntⁱᵐᵖˡ); (WriteInt32, WriteInt32ⁱᵐᵖˡ); (WriteBytes, WriteBytesⁱᵐᵖˡ); (WriteInts, WriteIntsⁱᵐᵖˡ); (WriteBool, WriteBoolⁱᵐᵖˡ); (WriteLenPrefixedBytes, WriteLenPrefixedBytesⁱᵐᵖˡ); (ReadSlice, ReadSliceⁱᵐᵖˡ); (ReadSliceLenPrefix, ReadSliceLenPrefixⁱᵐᵖˡ); (WriteSlice, WriteSliceⁱᵐᵖˡ); (WriteSliceLenPrefix, WriteSliceLenPrefixⁱᵐᵖˡ)].

Definition msets' : list (go_string * (list (go_string * val))) := [(Enc.id, [("Finish"%go, Enc__Finishⁱᵐᵖˡ); ("PutBool"%go, Enc__PutBoolⁱᵐᵖˡ); ("PutBytes"%go, Enc__PutBytesⁱᵐᵖˡ); ("PutInt"%go, Enc__PutIntⁱᵐᵖˡ); ("PutInt32"%go, Enc__PutInt32ⁱᵐᵖˡ); ("PutInts"%go, Enc__PutIntsⁱᵐᵖˡ)]); (ptrT.id Enc.id, [("Finish"%go, (λ: "$r",
                 method_call #Enc.id #"Finish"%go (![#Enc] "$r")
                 )%V); ("PutBool"%go, (λ: "$r",
                 method_call #Enc.id #"PutBool"%go (![#Enc] "$r")
                 )%V); ("PutBytes"%go, (λ: "$r",
                 method_call #Enc.id #"PutBytes"%go (![#Enc] "$r")
                 )%V); ("PutInt"%go, (λ: "$r",
                 method_call #Enc.id #"PutInt"%go (![#Enc] "$r")
                 )%V); ("PutInt32"%go, (λ: "$r",
                 method_call #Enc.id #"PutInt32"%go (![#Enc] "$r")
                 )%V); ("PutInts"%go, (λ: "$r",
                 method_call #Enc.id #"PutInts"%go (![#Enc] "$r")
                 )%V)]); (Dec.id, [("GetBool"%go, Dec__GetBoolⁱᵐᵖˡ); ("GetBytes"%go, Dec__GetBytesⁱᵐᵖˡ); ("GetInt"%go, Dec__GetIntⁱᵐᵖˡ); ("GetInt32"%go, Dec__GetInt32ⁱᵐᵖˡ); ("GetInts"%go, Dec__GetIntsⁱᵐᵖˡ)]); (ptrT.id Dec.id, [("GetBool"%go, (λ: "$r",
                 method_call #Dec.id #"GetBool"%go (![#Dec] "$r")
                 )%V); ("GetBytes"%go, (λ: "$r",
                 method_call #Dec.id #"GetBytes"%go (![#Dec] "$r")
                 )%V); ("GetInt"%go, (λ: "$r",
                 method_call #Dec.id #"GetInt"%go (![#Dec] "$r")
                 )%V); ("GetInt32"%go, (λ: "$r",
                 method_call #Dec.id #"GetInt32"%go (![#Dec] "$r")
                 )%V); ("GetInts"%go, (λ: "$r",
                 method_call #Dec.id #"GetInts"%go (![#Dec] "$r")
                 )%V)])].

#[global] Instance info' : PkgInfo marshal.marshal :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [github_com.goose_lang.primitive.primitive; github_com.goose_lang.std.std];
  |}.

Axiom _'init : val.

Definition initialize' : val :=
  λ: <>,
    package.init #marshal.marshal (λ: <>,
      exception_do (do:  (std.initialize' #());;;
      do:  (primitive.initialize' #());;;
      do:  (package.alloc marshal.marshal #()))
      ).

End code.
End marshal.
