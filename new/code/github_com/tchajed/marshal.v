(* autogenerated from github.com/tchajed/marshal *)
Require Export New.code.encoding.binary.
Require Export New.code.github_com.goose_lang.std.
From New.golang Require Import defn.
Module pkg_id.
Definition marshal : go_string := "github.com/tchajed/marshal".

End pkg_id.
Export pkg_id.
Module marshal.

Definition Enc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/tchajed/marshal.Enc"%go [].

Definition Dec {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "github.com/tchajed/marshal.Dec"%go [].

Definition NewEncFromSlice {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/tchajed/marshal.NewEncFromSlice"%go.

Definition NewEnc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/tchajed/marshal.NewEnc"%go.

Definition bool2byte {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/tchajed/marshal.bool2byte"%go.

Definition NewDec {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/tchajed/marshal.NewDec"%go.

Definition compute_new_cap {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/tchajed/marshal.compute_new_cap"%go.

Definition reserve {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/tchajed/marshal.reserve"%go.

Definition ReadInt {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/tchajed/marshal.ReadInt"%go.

Definition ReadInt32 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/tchajed/marshal.ReadInt32"%go.

Definition ReadInts {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/tchajed/marshal.ReadInts"%go.

Definition ReadBytes {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/tchajed/marshal.ReadBytes"%go.

Definition ReadBytesCopy {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/tchajed/marshal.ReadBytesCopy"%go.

Definition ReadBool {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/tchajed/marshal.ReadBool"%go.

Definition ReadLenPrefixedBytes {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/tchajed/marshal.ReadLenPrefixedBytes"%go.

Definition WriteInt {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/tchajed/marshal.WriteInt"%go.

Definition WriteInt32 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/tchajed/marshal.WriteInt32"%go.

Definition WriteBytes {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/tchajed/marshal.WriteBytes"%go.

Definition WriteInts {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/tchajed/marshal.WriteInts"%go.

Definition WriteBool {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/tchajed/marshal.WriteBool"%go.

Definition WriteLenPrefixedBytes {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/tchajed/marshal.WriteLenPrefixedBytes"%go.

Definition ReadSlice {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/tchajed/marshal.ReadSlice"%go.

Definition ReadSliceLenPrefix {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/tchajed/marshal.ReadSliceLenPrefix"%go.

Definition WriteSlice {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/tchajed/marshal.WriteSlice"%go.

Definition WriteSliceLenPrefix {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "github.com/tchajed/marshal.WriteSliceLenPrefix"%go.

(* go: stateless.go:8:6 *)
Definition compute_new_capⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "old_cap" "min_cap",
    exception_do (let: "min_cap" := (GoAlloc go.uint64 "min_cap") in
    let: "old_cap" := (GoAlloc go.uint64 "old_cap") in
    let: "new_cap" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := ((![go.uint64] "old_cap") *⟨go.uint64⟩ #(W64 2)) in
    do:  ("new_cap" <-[go.uint64] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "new_cap") <⟨go.uint64⟩ (![go.uint64] "min_cap"))
    then
      let: "$r0" := (![go.uint64] "min_cap") in
      do:  ("new_cap" <-[go.uint64] "$r0")
    else do:  #());;;
    return: (![go.uint64] "new_cap")).

(* Grow a slice to have at least `additional` unused bytes in the capacity.
   Runtime-check against overflow.

   go: stateless.go:19:6 *)
Definition reserveⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "b" "additional",
    exception_do (let: "additional" := (GoAlloc go.uint64 "additional") in
    let: "b" := (GoAlloc (go.SliceType go.byte) "b") in
    let: "min_cap" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (let: "$a0" := (Convert go.int go.uint64 (let: "$a0" := (![go.SliceType go.byte] "b") in
    (FuncResolve go.len [go.SliceType go.byte] #()) "$a0")) in
    let: "$a1" := (![go.uint64] "additional") in
    (FuncResolve std.SumAssumeNoOverflow [] #()) "$a0" "$a1") in
    do:  ("min_cap" <-[go.uint64] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((Convert go.int go.uint64 (let: "$a0" := (![go.SliceType go.byte] "b") in
    (FuncResolve go.cap [go.SliceType go.byte] #()) "$a0")) <⟨go.uint64⟩ (![go.uint64] "min_cap"))
    then
      let: "new_cap" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: "$r0" := (let: "$a0" := (Convert go.int go.uint64 (let: "$a0" := (![go.SliceType go.byte] "b") in
      (FuncResolve go.cap [go.SliceType go.byte] #()) "$a0")) in
      let: "$a1" := (![go.uint64] "min_cap") in
      (FuncResolve compute_new_cap [] #()) "$a0" "$a1") in
      do:  ("new_cap" <-[go.uint64] "$r0");;;
      let: "dest" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
      let: "$r0" := ((FuncResolve go.make3 [go.SliceType go.byte] #()) (let: "$a0" := (![go.SliceType go.byte] "b") in
      (FuncResolve go.len [go.SliceType go.byte] #()) "$a0") (![go.uint64] "new_cap")) in
      do:  ("dest" <-[go.SliceType go.byte] "$r0");;;
      do:  (let: "$a0" := (![go.SliceType go.byte] "dest") in
      let: "$a1" := (![go.SliceType go.byte] "b") in
      (FuncResolve go.copy [go.SliceType go.byte] #()) "$a0" "$a1");;;
      return: (![go.SliceType go.byte] "dest")
    else return: (![go.SliceType go.byte] "b"))).

(* go: stateless.go:40:6 *)
Definition ReadIntⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "b",
    exception_do (let: "b" := (GoAlloc (go.SliceType go.byte) "b") in
    let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    (MethodResolve binary.littleEndian "Uint64"%go (![binary.littleEndian] (GlobalVarAddr binary.LittleEndian #()))) "$a0") in
    do:  ("i" <-[go.uint64] "$r0");;;
    return: (![go.uint64] "i", let: "$s" := (![go.SliceType go.byte] "b") in
     Slice (go.SliceType go.byte) ("$s", #(W64 8), FuncResolve go.len [go.SliceType go.byte] #() (![go.SliceType go.byte] "b")))).

(* go: stateless.go:45:6 *)
Definition ReadInt32ⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "b",
    exception_do (let: "b" := (GoAlloc (go.SliceType go.byte) "b") in
    let: "i" := (GoAlloc go.uint32 (GoZeroVal go.uint32 #())) in
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    (MethodResolve binary.littleEndian "Uint32"%go (![binary.littleEndian] (GlobalVarAddr binary.LittleEndian #()))) "$a0") in
    do:  ("i" <-[go.uint32] "$r0");;;
    return: (![go.uint32] "i", let: "$s" := (![go.SliceType go.byte] "b") in
     Slice (go.SliceType go.byte) ("$s", #(W64 4), FuncResolve go.len [go.SliceType go.byte] #() (![go.SliceType go.byte] "b")))).

(* ReadBytes reads `l` bytes from b and returns (bs, rest)

   go: stateless.go:62:6 *)
Definition ReadBytesⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "b" "l",
    exception_do (let: "l" := (GoAlloc go.uint64 "l") in
    let: "b" := (GoAlloc (go.SliceType go.byte) "b") in
    let: "s" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (let: "$s" := (![go.SliceType go.byte] "b") in
    Slice (go.SliceType go.byte) ("$s", #(W64 0), ![go.uint64] "l")) in
    do:  ("s" <-[go.SliceType go.byte] "$r0");;;
    return: (![go.SliceType go.byte] "s", let: "$s" := (![go.SliceType go.byte] "b") in
     Slice (go.SliceType go.byte) ("$s", ![go.uint64] "l", FuncResolve go.len [go.SliceType go.byte] #() (![go.SliceType go.byte] "b")))).

(* Like ReadBytes, but avoids keeping the source slice [b] alive.

   go: stateless.go:68:6 *)
Definition ReadBytesCopyⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "b" "l",
    exception_do (let: "l" := (GoAlloc go.uint64 "l") in
    let: "b" := (GoAlloc (go.SliceType go.byte) "b") in
    let: "s" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) (![go.uint64] "l")) in
    do:  ("s" <-[go.SliceType go.byte] "$r0");;;
    do:  (let: "$a0" := (![go.SliceType go.byte] "s") in
    let: "$a1" := (let: "$s" := (![go.SliceType go.byte] "b") in
    Slice (go.SliceType go.byte) ("$s", #(W64 0), ![go.uint64] "l")) in
    (FuncResolve go.copy [go.SliceType go.byte] #()) "$a0" "$a1");;;
    return: (![go.SliceType go.byte] "s", let: "$s" := (![go.SliceType go.byte] "b") in
     Slice (go.SliceType go.byte) ("$s", ![go.uint64] "l", FuncResolve go.len [go.SliceType go.byte] #() (![go.SliceType go.byte] "b")))).

(* go: stateless.go:74:6 *)
Definition ReadBoolⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "b",
    exception_do (let: "b" := (GoAlloc (go.SliceType go.byte) "b") in
    let: "x" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := ((![go.byte] (IndexRef (go.SliceType go.byte) (![go.SliceType go.byte] "b", #(W64 0)))) ≠⟨go.byte⟩ #(W8 0)) in
    do:  ("x" <-[go.bool] "$r0");;;
    return: (![go.bool] "x", let: "$s" := (![go.SliceType go.byte] "b") in
     Slice (go.SliceType go.byte) ("$s", #(W64 1), FuncResolve go.len [go.SliceType go.byte] #() (![go.SliceType go.byte] "b")))).

(* go: stateless.go:79:6 *)
Definition ReadLenPrefixedBytesⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "b",
    exception_do (let: "b" := (GoAlloc (go.SliceType go.byte) "b") in
    let: "b2" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "l" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] "b") in
    (FuncResolve ReadInt [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("l" <-[go.uint64] "$r0");;;
    do:  ("b2" <-[go.SliceType go.byte] "$r1");;;
    let: "b3" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "bs" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] "b2") in
    let: "$a1" := (![go.uint64] "l") in
    (FuncResolve ReadBytes [] #()) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("bs" <-[go.SliceType go.byte] "$r0");;;
    do:  ("b3" <-[go.SliceType go.byte] "$r1");;;
    return: (![go.SliceType go.byte] "bs", ![go.SliceType go.byte] "b3")).

(* WriteInt appends i in little-endian format to b, returning the new slice.

   go: stateless.go:88:6 *)
Definition WriteIntⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "b" "i",
    exception_do (let: "i" := (GoAlloc go.uint64 "i") in
    let: "b" := (GoAlloc (go.SliceType go.byte) "b") in
    let: "b2" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := #(W64 8) in
    (FuncResolve reserve [] #()) "$a0" "$a1") in
    do:  ("b2" <-[go.SliceType go.byte] "$r0");;;
    let: "off" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b2") in
    (FuncResolve go.len [go.SliceType go.byte] #()) "$a0") in
    do:  ("off" <-[go.int] "$r0");;;
    let: "b3" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (let: "$s" := (![go.SliceType go.byte] "b2") in
    Slice (go.SliceType go.byte) ("$s", #(W64 0), (![go.int] "off") +⟨go.int⟩ #(W64 8))) in
    do:  ("b3" <-[go.SliceType go.byte] "$r0");;;
    do:  (let: "$a0" := (let: "$s" := (![go.SliceType go.byte] "b3") in
    Slice (go.SliceType go.byte) ("$s", ![go.int] "off", FuncResolve go.len [go.SliceType go.byte] #() (![go.SliceType go.byte] "b3"))) in
    let: "$a1" := (![go.uint64] "i") in
    (MethodResolve binary.littleEndian "PutUint64"%go (![binary.littleEndian] (GlobalVarAddr binary.LittleEndian #()))) "$a0" "$a1");;;
    return: (![go.SliceType go.byte] "b3")).

(* WriteInt32 appends 32-bit integer i in little-endian format to b, returning the new slice.

   go: stateless.go:98:6 *)
Definition WriteInt32ⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "b" "i",
    exception_do (let: "i" := (GoAlloc go.uint32 "i") in
    let: "b" := (GoAlloc (go.SliceType go.byte) "b") in
    let: "b2" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := #(W64 4) in
    (FuncResolve reserve [] #()) "$a0" "$a1") in
    do:  ("b2" <-[go.SliceType go.byte] "$r0");;;
    let: "off" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b2") in
    (FuncResolve go.len [go.SliceType go.byte] #()) "$a0") in
    do:  ("off" <-[go.int] "$r0");;;
    let: "b3" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (let: "$s" := (![go.SliceType go.byte] "b2") in
    Slice (go.SliceType go.byte) ("$s", #(W64 0), (![go.int] "off") +⟨go.int⟩ #(W64 4))) in
    do:  ("b3" <-[go.SliceType go.byte] "$r0");;;
    do:  (let: "$a0" := (let: "$s" := (![go.SliceType go.byte] "b3") in
    Slice (go.SliceType go.byte) ("$s", ![go.int] "off", FuncResolve go.len [go.SliceType go.byte] #() (![go.SliceType go.byte] "b3"))) in
    let: "$a1" := (![go.uint32] "i") in
    (MethodResolve binary.littleEndian "PutUint32"%go (![binary.littleEndian] (GlobalVarAddr binary.LittleEndian #()))) "$a0" "$a1");;;
    return: (![go.SliceType go.byte] "b3")).

(* Append data to b, returning the new slice.

   go: stateless.go:107:6 *)
Definition WriteBytesⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "b" "data",
    exception_do (let: "data" := (GoAlloc (go.SliceType go.byte) "data") in
    let: "b" := (GoAlloc (go.SliceType go.byte) "b") in
    return: (let: "$a0" := (![go.SliceType go.byte] "b") in
     let: "$a1" := (![go.SliceType go.byte] "data") in
     (FuncResolve go.append [go.SliceType go.byte] #()) "$a0" "$a1")).

(* go: stateless.go:119:6 *)
Definition WriteBoolⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "b" "x",
    exception_do (let: "x" := (GoAlloc go.bool "x") in
    let: "b" := (GoAlloc (go.SliceType go.byte) "b") in
    (if: ![go.bool] "x"
    then
      return: (let: "$a0" := (![go.SliceType go.byte] "b") in
       let: "$a1" := ((let: "$sl0" := #(W8 1) in
       CompositeLiteral (go.SliceType go.byte) (LiteralValue [KeyedElement None (ElementExpression go.byte "$sl0")]))) in
       (FuncResolve go.append [go.SliceType go.byte] #()) "$a0" "$a1")
    else
      return: (let: "$a0" := (![go.SliceType go.byte] "b") in
       let: "$a1" := ((let: "$sl0" := #(W8 0) in
       CompositeLiteral (go.SliceType go.byte) (LiteralValue [KeyedElement None (ElementExpression go.byte "$sl0")]))) in
       (FuncResolve go.append [go.SliceType go.byte] #()) "$a0" "$a1"))).

(* go: stateless.go:127:6 *)
Definition WriteLenPrefixedBytesⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "b" "bs",
    exception_do (let: "bs" := (GoAlloc (go.SliceType go.byte) "bs") in
    let: "b" := (GoAlloc (go.SliceType go.byte) "b") in
    let: "b2" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (Convert go.int go.uint64 (let: "$a0" := (![go.SliceType go.byte] "bs") in
    (FuncResolve go.len [go.SliceType go.byte] #()) "$a0")) in
    (FuncResolve WriteInt [] #()) "$a0" "$a1") in
    do:  ("b2" <-[go.SliceType go.byte] "$r0");;;
    return: (let: "$a0" := (![go.SliceType go.byte] "b2") in
     let: "$a1" := (![go.SliceType go.byte] "bs") in
     (FuncResolve WriteBytes [] #()) "$a0" "$a1")).

(* go: stateless_slice.go:3:6 *)
Definition ReadSliceⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} (T : go.type) : val :=
  λ: "b" "count" "readOne",
    exception_do (let: "readOne" := (GoAlloc (go.FunctionType (go.Signature [go.SliceType go.byte] false [T; go.SliceType go.byte])) "readOne") in
    let: "count" := (GoAlloc go.uint64 "count") in
    let: "b" := (GoAlloc (go.SliceType go.byte) "b") in
    let: "b2" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (![go.SliceType go.byte] "b") in
    do:  ("b2" <-[go.SliceType go.byte] "$r0");;;
    let: "xs" := (GoAlloc (go.SliceType T) (GoZeroVal (go.SliceType T) #())) in
    let: "$r0" := (CompositeLiteral (go.SliceType T) (LiteralValue [])) in
    do:  ("xs" <-[go.SliceType T] "$r0");;;
    (let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.uint64] "$r0");;;
    (for: (λ: <>, (![go.uint64] "i") <⟨go.uint64⟩ (![go.uint64] "count")); (λ: <>, do:  ("i" <-[go.uint64] ((![go.uint64] "i") +⟨go.uint64⟩ #(W64 1)))) := λ: <>,
      let: "bNew" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
      let: "xNew" := (GoAlloc T (GoZeroVal T #())) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] "b2") in
      (![go.FunctionType (go.Signature [go.SliceType go.byte] false [T; go.SliceType go.byte])] "readOne") "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("xNew" <-[T] "$r0");;;
      do:  ("bNew" <-[go.SliceType go.byte] "$r1");;;
      let: "$r0" := (let: "$a0" := (![go.SliceType T] "xs") in
      let: "$a1" := ((let: "$sl0" := (![T] "xNew") in
      CompositeLiteral (go.SliceType T) (LiteralValue [KeyedElement None (ElementExpression T "$sl0")]))) in
      (FuncResolve go.append [go.SliceType T] #()) "$a0" "$a1") in
      do:  ("xs" <-[go.SliceType T] "$r0");;;
      let: "$r0" := (![go.SliceType go.byte] "bNew") in
      do:  ("b2" <-[go.SliceType go.byte] "$r0")));;;
    return: (![go.SliceType T] "xs", ![go.SliceType go.byte] "b2")).

(* go: stateless_slice.go:14:6 *)
Definition ReadSliceLenPrefixⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} (T : go.type) : val :=
  λ: "b" "readOne",
    exception_do (let: "readOne" := (GoAlloc (go.FunctionType (go.Signature [go.SliceType go.byte] false [T; go.SliceType go.byte])) "readOne") in
    let: "b" := (GoAlloc (go.SliceType go.byte) "b") in
    let: "b2" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "count" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType go.byte] "b") in
    (FuncResolve ReadInt [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("count" <-[go.uint64] "$r0");;;
    do:  ("b2" <-[go.SliceType go.byte] "$r1");;;
    let: ("$ret0", "$ret1") := ((let: "$a0" := (![go.SliceType go.byte] "b2") in
    let: "$a1" := (![go.uint64] "count") in
    let: "$a2" := (![go.FunctionType (go.Signature [go.SliceType go.byte] false [T; go.SliceType go.byte])] "readOne") in
    (FuncResolve ReadSlice [T] #()) "$a0" "$a1" "$a2")) in
    return: ("$ret0", "$ret1")).

(* go: stateless_slice.go:19:6 *)
Definition WriteSliceⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} (T : go.type) : val :=
  λ: "b" "xs" "writeOne",
    exception_do (let: "writeOne" := (GoAlloc (go.FunctionType (go.Signature [go.SliceType go.byte; T] false [go.SliceType go.byte])) "writeOne") in
    let: "xs" := (GoAlloc (go.SliceType T) "xs") in
    let: "b" := (GoAlloc (go.SliceType go.byte) "b") in
    let: "b2" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (![go.SliceType go.byte] "b") in
    do:  ("b2" <-[go.SliceType go.byte] "$r0");;;
    let: "$range" := (![go.SliceType T] "xs") in
    (let: "x" := (GoAlloc T (GoZeroVal T #())) in
    slice.for_range T "$range" (λ: "$key" "$value",
      do:  ("x" <-[T] "$value");;;
      do:  "$key";;;
      let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b2") in
      let: "$a1" := (![T] "x") in
      (![go.FunctionType (go.Signature [go.SliceType go.byte; T] false [go.SliceType go.byte])] "writeOne") "$a0" "$a1") in
      do:  ("b2" <-[go.SliceType go.byte] "$r0")));;;
    return: (![go.SliceType go.byte] "b2")).

(* go: stateless_slice.go:27:6 *)
Definition WriteSliceLenPrefixⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} (T : go.type) : val :=
  λ: "b" "xs" "writeOne",
    exception_do (let: "writeOne" := (GoAlloc (go.FunctionType (go.Signature [go.SliceType go.byte; T] false [go.SliceType go.byte])) "writeOne") in
    let: "xs" := (GoAlloc (go.SliceType T) "xs") in
    let: "b" := (GoAlloc (go.SliceType go.byte) "b") in
    let: "b2" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b") in
    let: "$a1" := (Convert go.int go.uint64 (let: "$a0" := (![go.SliceType T] "xs") in
    (FuncResolve go.len [go.SliceType T] #()) "$a0")) in
    (FuncResolve WriteInt [] #()) "$a0" "$a1") in
    do:  ("b2" <-[go.SliceType go.byte] "$r0");;;
    let: "b3" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] "b2") in
    let: "$a1" := (![go.SliceType T] "xs") in
    let: "$a2" := (![go.FunctionType (go.Signature [go.SliceType go.byte; T] false [go.SliceType go.byte])] "writeOne") in
    (FuncResolve WriteSlice [T] #()) "$a0" "$a1" "$a2") in
    do:  ("b3" <-[go.SliceType go.byte] "$r0");;;
    return: (![go.SliceType go.byte] "b3")).

#[global] Instance info' : PkgInfo pkg_id.marshal :=
{|
  pkg_imported_pkgs := [code.encoding.binary.pkg_id.binary; code.github_com.goose_lang.std.pkg_id.std]
|}.

Axiom _'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init pkg_id.marshal (λ: <>,
      exception_do (do:  (std.initialize' #());;;
      do:  (binary.initialize' #()))
      ).

Module Enc.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  b' : slice.t;
  off' : loc;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End Enc.

Definition Enc'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "b"%go (go.SliceType go.byte));
  (go.FieldDecl "off"%go (go.PointerType go.uint64))
].
Program Definition Enc'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (Enc'fds_unsealed).
Global Instance equals_unfold_Enc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Enc'fds =→ Enc'fds_unsealed.
Proof. rewrite /Enc'fds seal_eq //. Qed.

Definition Encⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (Enc'fds).

Class Enc_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Enc_type_repr  :: go.TypeReprUnderlying Encⁱᵐᵖˡ Enc.t;
  #[global] Enc_underlying :: (Enc) <u (Encⁱᵐᵖˡ);
  #[global] Enc_get_b (x : Enc.t) :: ⟦StructFieldGet (Encⁱᵐᵖˡ) "b", #x⟧ ⤳[under] #x.(Enc.b');
  #[global] Enc_set_b (x : Enc.t) y :: ⟦StructFieldSet (Encⁱᵐᵖˡ) "b", (#x, #y)⟧ ⤳[under] #(x <|Enc.b' := y|>);
  #[global] Enc_get_off (x : Enc.t) :: ⟦StructFieldGet (Encⁱᵐᵖˡ) "off", #x⟧ ⤳[under] #x.(Enc.off');
  #[global] Enc_set_off (x : Enc.t) y :: ⟦StructFieldSet (Encⁱᵐᵖˡ) "off", (#x, #y)⟧ ⤳[under] #(x <|Enc.off' := y|>);
}.

Module Dec.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  b' : slice.t;
  off' : loc;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End Dec.

Definition Dec'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "b"%go (go.SliceType go.byte));
  (go.FieldDecl "off"%go (go.PointerType go.uint64))
].
Program Definition Dec'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (Dec'fds_unsealed).
Global Instance equals_unfold_Dec {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Dec'fds =→ Dec'fds_unsealed.
Proof. rewrite /Dec'fds seal_eq //. Qed.

Definition Decⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (Dec'fds).

Class Dec_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Dec_type_repr  :: go.TypeReprUnderlying Decⁱᵐᵖˡ Dec.t;
  #[global] Dec_underlying :: (Dec) <u (Decⁱᵐᵖˡ);
  #[global] Dec_get_b (x : Dec.t) :: ⟦StructFieldGet (Decⁱᵐᵖˡ) "b", #x⟧ ⤳[under] #x.(Dec.b');
  #[global] Dec_set_b (x : Dec.t) y :: ⟦StructFieldSet (Decⁱᵐᵖˡ) "b", (#x, #y)⟧ ⤳[under] #(x <|Dec.b' := y|>);
  #[global] Dec_get_off (x : Dec.t) :: ⟦StructFieldGet (Decⁱᵐᵖˡ) "off", #x⟧ ⤳[under] #x.(Dec.off');
  #[global] Dec_set_off (x : Dec.t) y :: ⟦StructFieldSet (Decⁱᵐᵖˡ) "off", (#x, #y)⟧ ⤳[under] #(x <|Dec.off' := y|>);
}.

Class Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Enc_instance :: Enc_Assumptions;
  #[global] Dec_instance :: Dec_Assumptions;
  #[global] compute_new_cap_unfold :: FuncUnfold compute_new_cap [] (compute_new_capⁱᵐᵖˡ);
  #[global] reserve_unfold :: FuncUnfold reserve [] (reserveⁱᵐᵖˡ);
  #[global] ReadInt_unfold :: FuncUnfold ReadInt [] (ReadIntⁱᵐᵖˡ);
  #[global] ReadInt32_unfold :: FuncUnfold ReadInt32 [] (ReadInt32ⁱᵐᵖˡ);
  #[global] ReadBytes_unfold :: FuncUnfold ReadBytes [] (ReadBytesⁱᵐᵖˡ);
  #[global] ReadBytesCopy_unfold :: FuncUnfold ReadBytesCopy [] (ReadBytesCopyⁱᵐᵖˡ);
  #[global] ReadBool_unfold :: FuncUnfold ReadBool [] (ReadBoolⁱᵐᵖˡ);
  #[global] ReadLenPrefixedBytes_unfold :: FuncUnfold ReadLenPrefixedBytes [] (ReadLenPrefixedBytesⁱᵐᵖˡ);
  #[global] WriteInt_unfold :: FuncUnfold WriteInt [] (WriteIntⁱᵐᵖˡ);
  #[global] WriteInt32_unfold :: FuncUnfold WriteInt32 [] (WriteInt32ⁱᵐᵖˡ);
  #[global] WriteBytes_unfold :: FuncUnfold WriteBytes [] (WriteBytesⁱᵐᵖˡ);
  #[global] WriteBool_unfold :: FuncUnfold WriteBool [] (WriteBoolⁱᵐᵖˡ);
  #[global] WriteLenPrefixedBytes_unfold :: FuncUnfold WriteLenPrefixedBytes [] (WriteLenPrefixedBytesⁱᵐᵖˡ);
  #[global] ReadSlice_unfold T :: FuncUnfold ReadSlice [T] (ReadSliceⁱᵐᵖˡ T);
  #[global] ReadSliceLenPrefix_unfold T :: FuncUnfold ReadSliceLenPrefix [T] (ReadSliceLenPrefixⁱᵐᵖˡ T);
  #[global] WriteSlice_unfold T :: FuncUnfold WriteSlice [T] (WriteSliceⁱᵐᵖˡ T);
  #[global] WriteSliceLenPrefix_unfold T :: FuncUnfold WriteSliceLenPrefix [T] (WriteSliceLenPrefixⁱᵐᵖˡ T);
  #[global] import_binary_Assumption :: binary.Assumptions;
  #[global] import_std_Assumption :: std.Assumptions;
}.
End marshal.
