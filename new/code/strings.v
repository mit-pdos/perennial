(* autogenerated from strings *)

From New.golang Require Import defn.
Definition strings : go_string := "strings".

Module strings.

Definition Builder : go.type := go.Named "strings.Builder"%go [].

Definition Builderⁱᵐᵖˡ : go.type := go.StructType [
  (go.FieldDecl "addr"%go (go.PointerType Builder));
  (go.FieldDecl "buf"%go (go.SliceType go.byte))
].

Module Builder.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  addr : loc;
  buf : slice.t;
}.
#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _)|}.
#[global] Instance settable : Settable t :=
  settable! mk <addr; buf>.
End def.

#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End Builder.

Class Builder_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Builder_zero_val  :: go.GoZeroValEq Builder Builder.t;
  #[global] Builder_underlying :: go.Underlying (Builder) (Builderⁱᵐᵖˡ);
  #[global] Builder_get_addr (x : Builder.t) :: go.IsGoStepPureDet (StructFieldGet (Builder) "addr") #x #x.(Builder.addr);
  #[global] Builder_set_addr (x : Builder.t) y :: go.IsGoStepPureDet (StructFieldSet (Builder) "addr") (#x, #y) #(x <|Builder.addr := y|>);
  #[global] Builder_get_buf (x : Builder.t) :: go.IsGoStepPureDet (StructFieldGet (Builder) "buf") #x #x.(Builder.buf);
  #[global] Builder_set_buf (x : Builder.t) y :: go.IsGoStepPureDet (StructFieldSet (Builder) "buf") (#x, #y) #(x <|Builder.buf := y|>);
}.

Definition Clone {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.Clone"%go.

Definition Compare {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.Compare"%go.

Definition Lines {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.Lines"%go.

Definition splitSeq {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.splitSeq"%go.

Definition SplitSeq {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.SplitSeq"%go.

Definition SplitAfterSeq {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.SplitAfterSeq"%go.

Definition FieldsSeq {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.FieldsSeq"%go.

Definition FieldsFuncSeq {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.FieldsFuncSeq"%go.

Axiom Readerⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Definition NewReader {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.NewReader"%go.

Axiom Replacerⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom replacerⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Definition NewReplacer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.NewReplacer"%go.

Axiom trieNodeⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom genericReplacerⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Definition makeGenericReplacer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.makeGenericReplacer"%go.

Axiom appendSliceWriterⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom stringWriterⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Definition getStringWriter {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.getStringWriter"%go.

Axiom singleStringReplacerⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Definition makeSingleStringReplacer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.makeSingleStringReplacer"%go.

Axiom byteReplacerⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom byteStringReplacerⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom countCutOff : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, Z.

Axiom stringFinderⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Definition makeStringFinder {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.makeStringFinder"%go.

Definition longestCommonSuffix {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.longestCommonSuffix"%go.

Axiom maxInt : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition explode {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.explode"%go.

Definition Count {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.Count"%go.

Definition Contains {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.Contains"%go.

Definition ContainsAny {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.ContainsAny"%go.

Definition ContainsRune {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.ContainsRune"%go.

Definition ContainsFunc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.ContainsFunc"%go.

Definition LastIndex {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.LastIndex"%go.

Definition IndexByte {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.IndexByte"%go.

Definition IndexRune {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.IndexRune"%go.

Definition IndexAny {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.IndexAny"%go.

Definition LastIndexAny {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.LastIndexAny"%go.

Definition LastIndexByte {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.LastIndexByte"%go.

Definition genSplit {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.genSplit"%go.

Definition SplitN {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.SplitN"%go.

Definition SplitAfterN {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.SplitAfterN"%go.

Definition Split {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.Split"%go.

Definition SplitAfter {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.SplitAfter"%go.

Definition asciiSpace {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.asciiSpace"%go.

Axiom asciiSpace'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition Fields {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.Fields"%go.

Definition FieldsFunc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.FieldsFunc"%go.

Definition Join {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.Join"%go.

Definition HasPrefix {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.HasPrefix"%go.

Definition HasSuffix {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.HasSuffix"%go.

Definition Map {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.Map"%go.

Axiom repeatedSpaces : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go_string.

Axiom repeatedDashes : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go_string.

Axiom repeatedZeroes : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go_string.

Axiom repeatedEquals : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go_string.

Axiom repeatedTabs : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go_string.

Definition Repeat {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.Repeat"%go.

Definition ToUpper {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.ToUpper"%go.

Definition ToLower {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.ToLower"%go.

Definition ToTitle {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.ToTitle"%go.

Definition ToUpperSpecial {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.ToUpperSpecial"%go.

Definition ToLowerSpecial {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.ToLowerSpecial"%go.

Definition ToTitleSpecial {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.ToTitleSpecial"%go.

Definition ToValidUTF8 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.ToValidUTF8"%go.

Definition isSeparator {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.isSeparator"%go.

Definition Title {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.Title"%go.

Definition TrimLeftFunc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.TrimLeftFunc"%go.

Definition TrimRightFunc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.TrimRightFunc"%go.

Definition TrimFunc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.TrimFunc"%go.

Definition IndexFunc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.IndexFunc"%go.

Definition LastIndexFunc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.LastIndexFunc"%go.

Definition indexFunc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.indexFunc"%go.

Definition lastIndexFunc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.lastIndexFunc"%go.

Axiom asciiSetⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Definition makeASCIISet {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.makeASCIISet"%go.

Definition Trim {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.Trim"%go.

Definition TrimLeft {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.TrimLeft"%go.

Definition trimLeftByte {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.trimLeftByte"%go.

Definition trimLeftASCII {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.trimLeftASCII"%go.

Definition trimLeftUnicode {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.trimLeftUnicode"%go.

Definition TrimRight {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.TrimRight"%go.

Definition trimRightByte {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.trimRightByte"%go.

Definition trimRightASCII {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.trimRightASCII"%go.

Definition trimRightUnicode {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.trimRightUnicode"%go.

Definition TrimSpace {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.TrimSpace"%go.

Definition TrimPrefix {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.TrimPrefix"%go.

Definition TrimSuffix {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.TrimSuffix"%go.

Definition Replace {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.Replace"%go.

Definition ReplaceAll {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.ReplaceAll"%go.

Definition EqualFold {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.EqualFold"%go.

Definition Index {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.Index"%go.

Definition Cut {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.Cut"%go.

Definition CutPrefix {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.CutPrefix"%go.

Definition CutSuffix {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "strings.CutSuffix"%go.

#[global] Instance info' : PkgInfo strings.strings := 
{|
  pkg_imported_pkgs := []
|}.

Axiom _'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init strings.strings (λ: <>,
      exception_do (do:  (asciiSpace'init #()))
      ).

Class Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Builder_instance :: Builder_Assumptions;
}.
End strings.
