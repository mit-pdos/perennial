(* autogenerated from go.etcd.io/etcd/client/v3 *)
From New.golang Require Import defn.
Require Export New.code.go_etcd_io.etcd.api.v3.etcdserverpb.
Require Export New.code.go_etcd_io.etcd.api.v3.mvccpb.

Module Client. Definition id : go_string := "go.etcd.io/etcd/client/v3.Client"%go. End Client.
Module Cluster. Definition id : go_string := "go.etcd.io/etcd/client/v3.Cluster"%go. End Cluster.
Module Cmp. Definition id : go_string := "go.etcd.io/etcd/client/v3.Cmp"%go. End Cmp.
Module PutResponse. Definition id : go_string := "go.etcd.io/etcd/client/v3.PutResponse"%go. End PutResponse.
Module GetResponse. Definition id : go_string := "go.etcd.io/etcd/client/v3.GetResponse"%go. End GetResponse.
Module DeleteResponse. Definition id : go_string := "go.etcd.io/etcd/client/v3.DeleteResponse"%go. End DeleteResponse.
Module TxnResponse. Definition id : go_string := "go.etcd.io/etcd/client/v3.TxnResponse"%go. End TxnResponse.
Module KV. Definition id : go_string := "go.etcd.io/etcd/client/v3.KV"%go. End KV.
Module OpResponse. Definition id : go_string := "go.etcd.io/etcd/client/v3.OpResponse"%go. End OpResponse.
Module LeaseID. Definition id : go_string := "go.etcd.io/etcd/client/v3.LeaseID"%go. End LeaseID.
Module LeaseGrantResponse. Definition id : go_string := "go.etcd.io/etcd/client/v3.LeaseGrantResponse"%go. End LeaseGrantResponse.
Module Lease. Definition id : go_string := "go.etcd.io/etcd/client/v3.Lease"%go. End Lease.
Module opType. Definition id : go_string := "go.etcd.io/etcd/client/v3.opType"%go. End opType.
Module Op. Definition id : go_string := "go.etcd.io/etcd/client/v3.Op"%go. End Op.
Module OpOption. Definition id : go_string := "go.etcd.io/etcd/client/v3.OpOption"%go. End OpOption.
Module LeaseOp. Definition id : go_string := "go.etcd.io/etcd/client/v3.LeaseOp"%go. End LeaseOp.
Module LeaseOption. Definition id : go_string := "go.etcd.io/etcd/client/v3.LeaseOption"%go. End LeaseOption.
Module SortTarget. Definition id : go_string := "go.etcd.io/etcd/client/v3.SortTarget"%go. End SortTarget.
Module SortOrder. Definition id : go_string := "go.etcd.io/etcd/client/v3.SortOrder"%go. End SortOrder.
Module SortOption. Definition id : go_string := "go.etcd.io/etcd/client/v3.SortOption"%go. End SortOption.
Module Txn. Definition id : go_string := "go.etcd.io/etcd/client/v3.Txn"%go. End Txn.
Module Event. Definition id : go_string := "go.etcd.io/etcd/client/v3.Event"%go. End Event.
Module WatchChan. Definition id : go_string := "go.etcd.io/etcd/client/v3.WatchChan"%go. End WatchChan.
Module Watcher. Definition id : go_string := "go.etcd.io/etcd/client/v3.Watcher"%go. End Watcher.
Module WatchResponse. Definition id : go_string := "go.etcd.io/etcd/client/v3.WatchResponse"%go. End WatchResponse.

Definition clientv3 : go_string := "go.etcd.io/etcd/client/v3".

Module clientv3.
Section code.
Context `{ffi_syntax}.


Definition NewAuth : go_string := "go.etcd.io/etcd/client/v3.NewAuth"%go.

Definition NewAuthFromAuthClient : go_string := "go.etcd.io/etcd/client/v3.NewAuthFromAuthClient"%go.

Definition StrToPermissionType : go_string := "go.etcd.io/etcd/client/v3.StrToPermissionType"%go.

Definition ErrNoAvailableEndpoints : go_string := "go.etcd.io/etcd/client/v3.ErrNoAvailableEndpoints"%go.

Axiom ErrNoAvailableEndpoints'init : val.

Definition ErrOldCluster : go_string := "go.etcd.io/etcd/client/v3.ErrOldCluster"%go.

Axiom ErrOldCluster'init : val.

Axiom Client : go_type.

Definition New : go_string := "go.etcd.io/etcd/client/v3.New"%go.

Definition NewCtxClient : go_string := "go.etcd.io/etcd/client/v3.NewCtxClient"%go.

Definition NewFromURL : go_string := "go.etcd.io/etcd/client/v3.NewFromURL"%go.

Definition NewFromURLs : go_string := "go.etcd.io/etcd/client/v3.NewFromURLs"%go.

Definition WithZapLogger : go_string := "go.etcd.io/etcd/client/v3.WithZapLogger"%go.

(* WithZapLogger is a NewCtxClient option that overrides the logger

   go: client.go:119:6 *)
Definition WithZapLoggerⁱᵐᵖˡ : val :=
  λ: "lg",
    exception_do (let: "lg" := (mem.alloc "lg") in
    return: ((λ: "c",
       exception_do (let: "c" := (mem.alloc "c") in
       let: "$r0" := (![#ptrT] "lg") in
       do:  ((struct.field_ref #Client #"lg"%go (![#ptrT] "c")) <-[#ptrT] "$r0");;;
       return: #())
       ))).

Definition authority : go_string := "go.etcd.io/etcd/client/v3.authority"%go.

Definition newClient : go_string := "go.etcd.io/etcd/client/v3.newClient"%go.

Definition minSupportedVersion : go_string := "go.etcd.io/etcd/client/v3.minSupportedVersion"%go.

Definition isHaltErr : go_string := "go.etcd.io/etcd/client/v3.isHaltErr"%go.

Definition isUnavailableErr : go_string := "go.etcd.io/etcd/client/v3.isUnavailableErr"%go.

Definition ContextError : go_string := "go.etcd.io/etcd/client/v3.ContextError"%go.

Definition canceledByCaller : go_string := "go.etcd.io/etcd/client/v3.canceledByCaller"%go.

Definition IsConnCanceled : go_string := "go.etcd.io/etcd/client/v3.IsConnCanceled"%go.

Definition Cluster : go_type := interfaceT.

Definition NewCluster : go_string := "go.etcd.io/etcd/client/v3.NewCluster"%go.

Definition NewClusterFromClusterClient : go_string := "go.etcd.io/etcd/client/v3.NewClusterFromClusterClient"%go.

Definition OpCompact : go_string := "go.etcd.io/etcd/client/v3.OpCompact"%go.

Definition WithCompactPhysical : go_string := "go.etcd.io/etcd/client/v3.WithCompactPhysical"%go.

Definition Cmp : go_type := etcdserverpb.Compare.

Definition Compare : go_string := "go.etcd.io/etcd/client/v3.Compare"%go.

Definition Value : go_string := "go.etcd.io/etcd/client/v3.Value"%go.

Definition Version : go_string := "go.etcd.io/etcd/client/v3.Version"%go.

Definition CreateRevision : go_string := "go.etcd.io/etcd/client/v3.CreateRevision"%go.

Definition ModRevision : go_string := "go.etcd.io/etcd/client/v3.ModRevision"%go.

Definition LeaseValue : go_string := "go.etcd.io/etcd/client/v3.LeaseValue"%go.

Definition mustInt64 : go_string := "go.etcd.io/etcd/client/v3.mustInt64"%go.

Definition mustInt64orLeaseID : go_string := "go.etcd.io/etcd/client/v3.mustInt64orLeaseID"%go.

Definition NewClientConfig : go_string := "go.etcd.io/etcd/client/v3.NewClientConfig"%go.

Definition newTLSConfig : go_string := "go.etcd.io/etcd/client/v3.newTLSConfig"%go.

Definition WithRequireLeader : go_string := "go.etcd.io/etcd/client/v3.WithRequireLeader"%go.

Definition withVersion : go_string := "go.etcd.io/etcd/client/v3.withVersion"%go.

Definition PutResponse : go_type := etcdserverpb.PutResponse.

Definition GetResponse : go_type := etcdserverpb.RangeResponse.

Definition DeleteResponse : go_type := etcdserverpb.DeleteRangeResponse.

Definition TxnResponse : go_type := etcdserverpb.TxnResponse.

Definition KV : go_type := interfaceT.

Definition OpResponse : go_type := structT [
  "put" :: ptrT;
  "get" :: ptrT;
  "del" :: ptrT;
  "txn" :: ptrT
].

Definition NewKV : go_string := "go.etcd.io/etcd/client/v3.NewKV"%go.

Definition NewKVFromKVClient : go_string := "go.etcd.io/etcd/client/v3.NewKVFromKVClient"%go.

Definition LeaseID : go_type := int64T.

Definition LeaseGrantResponse : go_type := structT [
  "ResponseHeader" :: ptrT;
  "ID" :: LeaseID;
  "TTL" :: int64T;
  "Error" :: stringT
].

Definition NoLease : expr := #(W64 0).

Definition LeaseResponseChSize : go_string := "go.etcd.io/etcd/client/v3.LeaseResponseChSize"%go.

Axiom LeaseResponseChSize'init : val.

Definition Lease : go_type := interfaceT.

Definition NewLease : go_string := "go.etcd.io/etcd/client/v3.NewLease"%go.

Definition NewLeaseFromLeaseClient : go_string := "go.etcd.io/etcd/client/v3.NewLeaseFromLeaseClient"%go.

Definition init : go_string := "go.etcd.io/etcd/client/v3.init"%go.

Definition SetLogger : go_string := "go.etcd.io/etcd/client/v3.SetLogger"%go.

Definition etcdClientDebugLevel : go_string := "go.etcd.io/etcd/client/v3.etcdClientDebugLevel"%go.

Definition NewMaintenance : go_string := "go.etcd.io/etcd/client/v3.NewMaintenance"%go.

Definition NewMaintenanceFromMaintenanceClient : go_string := "go.etcd.io/etcd/client/v3.NewMaintenanceFromMaintenanceClient"%go.

Definition opType : go_type := intT.

Definition tRange : expr := #(W64 1).

Definition tPut : expr := #(W64 2).

Definition tDeleteRange : expr := #(W64 3).

Definition tTxn : expr := #(W64 4).

Definition noPrefixEnd : go_string := "go.etcd.io/etcd/client/v3.noPrefixEnd"%go.

Axiom noPrefixEnd'init : val.

Definition Op : go_type := structT [
  "t" :: opType;
  "key" :: sliceT;
  "end" :: sliceT;
  "limit" :: int64T;
  "sort" :: ptrT;
  "serializable" :: boolT;
  "keysOnly" :: boolT;
  "countOnly" :: boolT;
  "minModRev" :: int64T;
  "maxModRev" :: int64T;
  "minCreateRev" :: int64T;
  "maxCreateRev" :: int64T;
  "rev" :: int64T;
  "prevKV" :: boolT;
  "fragment" :: boolT;
  "ignoreValue" :: boolT;
  "ignoreLease" :: boolT;
  "progressNotify" :: boolT;
  "createdNotify" :: boolT;
  "filterPut" :: boolT;
  "filterDelete" :: boolT;
  "val" :: sliceT;
  "leaseID" :: LeaseID;
  "cmps" :: sliceT;
  "thenOps" :: sliceT;
  "elseOps" :: sliceT;
  "isOptsWithFromKey" :: boolT;
  "isOptsWithPrefix" :: boolT
].

(* IsTxn returns true if the "Op" type is transaction.

   go: op.go:88:14 *)
Definition Op__IsTxnⁱᵐᵖˡ : val :=
  λ: "op" <>,
    exception_do (let: "op" := (mem.alloc "op") in
    return: ((![#opType] (struct.field_ref #Op #"t"%go "op")) = tTxn)).

(* Txn returns the comparison(if) operations, "then" operations, and "else" operations.

   go: op.go:93:14 *)
Definition Op__Txnⁱᵐᵖˡ : val :=
  λ: "op" <>,
    exception_do (let: "op" := (mem.alloc "op") in
    return: (![#sliceT] (struct.field_ref #Op #"cmps"%go "op"), ![#sliceT] (struct.field_ref #Op #"thenOps"%go "op"), ![#sliceT] (struct.field_ref #Op #"elseOps"%go "op"))).

(* KeyBytes returns the byte slice holding the Op's key.

   go: op.go:98:14 *)
Definition Op__KeyBytesⁱᵐᵖˡ : val :=
  λ: "op" <>,
    exception_do (let: "op" := (mem.alloc "op") in
    return: (![#sliceT] (struct.field_ref #Op #"key"%go "op"))).

(* WithKeyBytes sets the byte slice for the Op's key.

   go: op.go:101:15 *)
Definition Op__WithKeyBytesⁱᵐᵖˡ : val :=
  λ: "op" "key",
    exception_do (let: "op" := (mem.alloc "op") in
    let: "key" := (mem.alloc "key") in
    let: "$r0" := (![#sliceT] "key") in
    do:  ((struct.field_ref #Op #"key"%go (![#ptrT] "op")) <-[#sliceT] "$r0");;;
    return: #()).

(* RangeBytes returns the byte slice holding with the Op's range end, if any.

   go: op.go:104:14 *)
Definition Op__RangeBytesⁱᵐᵖˡ : val :=
  λ: "op" <>,
    exception_do (let: "op" := (mem.alloc "op") in
    return: (![#sliceT] (struct.field_ref #Op #"end"%go "op"))).

(* Rev returns the requested revision, if any.

   go: op.go:107:14 *)
Definition Op__Revⁱᵐᵖˡ : val :=
  λ: "op" <>,
    exception_do (let: "op" := (mem.alloc "op") in
    return: (![#int64T] (struct.field_ref #Op #"rev"%go "op"))).

(* IsPut returns true iff the operation is a Put.

   go: op.go:110:14 *)
Definition Op__IsPutⁱᵐᵖˡ : val :=
  λ: "op" <>,
    exception_do (let: "op" := (mem.alloc "op") in
    return: ((![#opType] (struct.field_ref #Op #"t"%go "op")) = tPut)).

(* IsGet returns true iff the operation is a Get.

   go: op.go:113:14 *)
Definition Op__IsGetⁱᵐᵖˡ : val :=
  λ: "op" <>,
    exception_do (let: "op" := (mem.alloc "op") in
    return: ((![#opType] (struct.field_ref #Op #"t"%go "op")) = tRange)).

(* IsDelete returns true iff the operation is a Delete.

   go: op.go:116:14 *)
Definition Op__IsDeleteⁱᵐᵖˡ : val :=
  λ: "op" <>,
    exception_do (let: "op" := (mem.alloc "op") in
    return: ((![#opType] (struct.field_ref #Op #"t"%go "op")) = tDeleteRange)).

(* IsSerializable returns true if the serializable field is true.

   go: op.go:119:14 *)
Definition Op__IsSerializableⁱᵐᵖˡ : val :=
  λ: "op" <>,
    exception_do (let: "op" := (mem.alloc "op") in
    return: (![#boolT] (struct.field_ref #Op #"serializable"%go "op"))).

(* IsKeysOnly returns whether keysOnly is set.

   go: op.go:122:14 *)
Definition Op__IsKeysOnlyⁱᵐᵖˡ : val :=
  λ: "op" <>,
    exception_do (let: "op" := (mem.alloc "op") in
    return: (![#boolT] (struct.field_ref #Op #"keysOnly"%go "op"))).

(* IsCountOnly returns whether countOnly is set.

   go: op.go:125:14 *)
Definition Op__IsCountOnlyⁱᵐᵖˡ : val :=
  λ: "op" <>,
    exception_do (let: "op" := (mem.alloc "op") in
    return: (![#boolT] (struct.field_ref #Op #"countOnly"%go "op"))).

(* go: op.go:127:14 *)
Definition Op__IsOptsWithFromKeyⁱᵐᵖˡ : val :=
  λ: "op" <>,
    exception_do (let: "op" := (mem.alloc "op") in
    return: (![#boolT] (struct.field_ref #Op #"isOptsWithFromKey"%go "op"))).

(* go: op.go:129:14 *)
Definition Op__IsOptsWithPrefixⁱᵐᵖˡ : val :=
  λ: "op" <>,
    exception_do (let: "op" := (mem.alloc "op") in
    return: (![#boolT] (struct.field_ref #Op #"isOptsWithPrefix"%go "op"))).

(* MinModRev returns the operation's minimum modify revision.

   go: op.go:132:14 *)
Definition Op__MinModRevⁱᵐᵖˡ : val :=
  λ: "op" <>,
    exception_do (let: "op" := (mem.alloc "op") in
    return: (![#int64T] (struct.field_ref #Op #"minModRev"%go "op"))).

(* MaxModRev returns the operation's maximum modify revision.

   go: op.go:135:14 *)
Definition Op__MaxModRevⁱᵐᵖˡ : val :=
  λ: "op" <>,
    exception_do (let: "op" := (mem.alloc "op") in
    return: (![#int64T] (struct.field_ref #Op #"maxModRev"%go "op"))).

(* MinCreateRev returns the operation's minimum create revision.

   go: op.go:138:14 *)
Definition Op__MinCreateRevⁱᵐᵖˡ : val :=
  λ: "op" <>,
    exception_do (let: "op" := (mem.alloc "op") in
    return: (![#int64T] (struct.field_ref #Op #"minCreateRev"%go "op"))).

(* MaxCreateRev returns the operation's maximum create revision.

   go: op.go:141:14 *)
Definition Op__MaxCreateRevⁱᵐᵖˡ : val :=
  λ: "op" <>,
    exception_do (let: "op" := (mem.alloc "op") in
    return: (![#int64T] (struct.field_ref #Op #"maxCreateRev"%go "op"))).

(* WithRangeBytes sets the byte slice for the Op's range end.

   go: op.go:144:15 *)
Definition Op__WithRangeBytesⁱᵐᵖˡ : val :=
  λ: "op" "end",
    exception_do (let: "op" := (mem.alloc "op") in
    let: "end" := (mem.alloc "end") in
    let: "$r0" := (![#sliceT] "end") in
    do:  ((struct.field_ref #Op #"end"%go (![#ptrT] "op")) <-[#sliceT] "$r0");;;
    return: #()).

(* ValueBytes returns the byte slice holding the Op's value, if any.

   go: op.go:147:14 *)
Definition Op__ValueBytesⁱᵐᵖˡ : val :=
  λ: "op" <>,
    exception_do (let: "op" := (mem.alloc "op") in
    return: (![#sliceT] (struct.field_ref #Op #"val"%go "op"))).

(* WithValueBytes sets the byte slice for the Op's value.

   go: op.go:150:15 *)
Definition Op__WithValueBytesⁱᵐᵖˡ : val :=
  λ: "op" "v",
    exception_do (let: "op" := (mem.alloc "op") in
    let: "v" := (mem.alloc "v") in
    let: "$r0" := (![#sliceT] "v") in
    do:  ((struct.field_ref #Op #"val"%go (![#ptrT] "op")) <-[#sliceT] "$r0");;;
    return: #()).

Definition SortTarget : go_type := intT.

Definition SortOrder : go_type := intT.

Definition SortOption : go_type := structT [
  "Target" :: SortTarget;
  "Order" :: SortOrder
].

(* go: op.go:152:14 *)
Definition Op__toRangeRequestⁱᵐᵖˡ : val :=
  λ: "op" <>,
    exception_do (let: "op" := (mem.alloc "op") in
    (if: (![#opType] (struct.field_ref #Op #"t"%go "op")) ≠ tRange
    then
      do:  (let: "$a0" := (interface.make #stringT.id #"op.t != tRange"%go) in
      Panic "$a0")
    else do:  #());;;
    let: "r" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (let: "$Key" := (![#sliceT] (struct.field_ref #Op #"key"%go "op")) in
    let: "$RangeEnd" := (![#sliceT] (struct.field_ref #Op #"end"%go "op")) in
    let: "$Limit" := (![#int64T] (struct.field_ref #Op #"limit"%go "op")) in
    let: "$Revision" := (![#int64T] (struct.field_ref #Op #"rev"%go "op")) in
    let: "$Serializable" := (![#boolT] (struct.field_ref #Op #"serializable"%go "op")) in
    let: "$KeysOnly" := (![#boolT] (struct.field_ref #Op #"keysOnly"%go "op")) in
    let: "$CountOnly" := (![#boolT] (struct.field_ref #Op #"countOnly"%go "op")) in
    let: "$MinModRevision" := (![#int64T] (struct.field_ref #Op #"minModRev"%go "op")) in
    let: "$MaxModRevision" := (![#int64T] (struct.field_ref #Op #"maxModRev"%go "op")) in
    let: "$MinCreateRevision" := (![#int64T] (struct.field_ref #Op #"minCreateRev"%go "op")) in
    let: "$MaxCreateRevision" := (![#int64T] (struct.field_ref #Op #"maxCreateRev"%go "op")) in
    struct.make #etcdserverpb.RangeRequest [{
      "Key" ::= "$Key";
      "RangeEnd" ::= "$RangeEnd";
      "Limit" ::= "$Limit";
      "Revision" ::= "$Revision";
      "SortOrder" ::= type.zero_val #etcdserverpb.RangeRequest_SortOrder;
      "SortTarget" ::= type.zero_val #etcdserverpb.RangeRequest_SortTarget;
      "Serializable" ::= "$Serializable";
      "KeysOnly" ::= "$KeysOnly";
      "CountOnly" ::= "$CountOnly";
      "MinModRevision" ::= "$MinModRevision";
      "MaxModRevision" ::= "$MaxModRevision";
      "MinCreateRevision" ::= "$MinCreateRevision";
      "MaxCreateRevision" ::= "$MaxCreateRevision";
      "XXX_NoUnkeyedLiteral" ::= type.zero_val (type.structT [
      ]);
      "XXX_unrecognized" ::= type.zero_val #sliceT;
      "XXX_sizecache" ::= type.zero_val #int32T
    }])) in
    do:  ("r" <-[#ptrT] "$r0");;;
    (if: (![#ptrT] (struct.field_ref #Op #"sort"%go "op")) ≠ #null
    then
      let: "$r0" := (s_to_w32 (![#SortOrder] (struct.field_ref #SortOption #"Order"%go (![#ptrT] (struct.field_ref #Op #"sort"%go "op"))))) in
      do:  ((struct.field_ref #etcdserverpb.RangeRequest #"SortOrder"%go (![#ptrT] "r")) <-[#etcdserverpb.RangeRequest_SortOrder] "$r0");;;
      let: "$r0" := (s_to_w32 (![#SortTarget] (struct.field_ref #SortOption #"Target"%go (![#ptrT] (struct.field_ref #Op #"sort"%go "op"))))) in
      do:  ((struct.field_ref #etcdserverpb.RangeRequest #"SortTarget"%go (![#ptrT] "r")) <-[#etcdserverpb.RangeRequest_SortTarget] "$r0")
    else do:  #());;;
    return: (![#ptrT] "r")).

(* go: op.go:176:14 *)
Definition Op__toTxnRequestⁱᵐᵖˡ : val :=
  λ: "op" <>,
    exception_do (let: "op" := (mem.alloc "op") in
    let: "thenOps" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make2 #ptrT (let: "$a0" := (![#sliceT] (struct.field_ref #Op #"thenOps"%go "op")) in
    slice.len "$a0")) in
    do:  ("thenOps" <-[#sliceT] "$r0");;;
    let: "$range" := (![#sliceT] (struct.field_ref #Op #"thenOps"%go "op")) in
    (let: "tOp" := (mem.alloc (type.zero_val #Op)) in
    let: "i" := (mem.alloc (type.zero_val #intT)) in
    slice.for_range #Op "$range" (λ: "$key" "$value",
      do:  ("tOp" <-[#Op] "$value");;;
      do:  ("i" <-[#intT] "$key");;;
      let: "$r0" := ((method_call #Op.id #"toRequestOp"%go (![#Op] "tOp")) #()) in
      do:  ((slice.elem_ref #ptrT (![#sliceT] "thenOps") (![#intT] "i")) <-[#ptrT] "$r0")));;;
    let: "elseOps" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make2 #ptrT (let: "$a0" := (![#sliceT] (struct.field_ref #Op #"elseOps"%go "op")) in
    slice.len "$a0")) in
    do:  ("elseOps" <-[#sliceT] "$r0");;;
    let: "$range" := (![#sliceT] (struct.field_ref #Op #"elseOps"%go "op")) in
    (let: "eOp" := (mem.alloc (type.zero_val #Op)) in
    let: "i" := (mem.alloc (type.zero_val #intT)) in
    slice.for_range #Op "$range" (λ: "$key" "$value",
      do:  ("eOp" <-[#Op] "$value");;;
      do:  ("i" <-[#intT] "$key");;;
      let: "$r0" := ((method_call #Op.id #"toRequestOp"%go (![#Op] "eOp")) #()) in
      do:  ((slice.elem_ref #ptrT (![#sliceT] "elseOps") (![#intT] "i")) <-[#ptrT] "$r0")));;;
    let: "cmps" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make2 #ptrT (let: "$a0" := (![#sliceT] (struct.field_ref #Op #"cmps"%go "op")) in
    slice.len "$a0")) in
    do:  ("cmps" <-[#sliceT] "$r0");;;
    let: "$range" := (![#sliceT] (struct.field_ref #Op #"cmps"%go "op")) in
    (let: "i" := (mem.alloc (type.zero_val #intT)) in
    slice.for_range #Cmp "$range" (λ: "$key" "$value",
      do:  ("i" <-[#intT] "$key");;;
      let: "$r0" := (slice.elem_ref #Cmp (![#sliceT] (struct.field_ref #Op #"cmps"%go "op")) (![#intT] "i")) in
      do:  ((slice.elem_ref #ptrT (![#sliceT] "cmps") (![#intT] "i")) <-[#ptrT] "$r0")));;;
    return: (mem.alloc (let: "$Compare" := (![#sliceT] "cmps") in
     let: "$Success" := (![#sliceT] "thenOps") in
     let: "$Failure" := (![#sliceT] "elseOps") in
     struct.make #etcdserverpb.TxnRequest [{
       "Compare" ::= "$Compare";
       "Success" ::= "$Success";
       "Failure" ::= "$Failure";
       "XXX_NoUnkeyedLiteral" ::= type.zero_val (type.structT [
       ]);
       "XXX_unrecognized" ::= type.zero_val #sliceT;
       "XXX_sizecache" ::= type.zero_val #int32T
     }]))).

(* go: op.go:192:14 *)
Definition Op__toRequestOpⁱᵐᵖˡ : val :=
  λ: "op" <>,
    exception_do (let: "op" := (mem.alloc "op") in
    let: "$sw" := (![#opType] (struct.field_ref #Op #"t"%go "op")) in
    (if: "$sw" = tRange
    then
      return: (mem.alloc (let: "$Request" := (interface.make #(ptrT.id etcdserverpb.RequestOp_RequestRange.id) (mem.alloc (let: "$RequestRange" := ((method_call #Op.id #"toRangeRequest"%go (![#Op] "op")) #()) in
       struct.make #etcdserverpb.RequestOp_RequestRange [{
         "RequestRange" ::= "$RequestRange"
       }]))) in
       struct.make #etcdserverpb.RequestOp [{
         "Request" ::= "$Request";
         "XXX_NoUnkeyedLiteral" ::= type.zero_val (type.structT [
         ]);
         "XXX_unrecognized" ::= type.zero_val #sliceT;
         "XXX_sizecache" ::= type.zero_val #int32T
       }]))
    else
      (if: "$sw" = tPut
      then
        let: "r" := (mem.alloc (type.zero_val #ptrT)) in
        let: "$r0" := (mem.alloc (let: "$Key" := (![#sliceT] (struct.field_ref #Op #"key"%go "op")) in
        let: "$Value" := (![#sliceT] (struct.field_ref #Op #"val"%go "op")) in
        let: "$Lease" := (![#LeaseID] (struct.field_ref #Op #"leaseID"%go "op")) in
        let: "$PrevKv" := (![#boolT] (struct.field_ref #Op #"prevKV"%go "op")) in
        let: "$IgnoreValue" := (![#boolT] (struct.field_ref #Op #"ignoreValue"%go "op")) in
        let: "$IgnoreLease" := (![#boolT] (struct.field_ref #Op #"ignoreLease"%go "op")) in
        struct.make #etcdserverpb.PutRequest [{
          "Key" ::= "$Key";
          "Value" ::= "$Value";
          "Lease" ::= "$Lease";
          "PrevKv" ::= "$PrevKv";
          "IgnoreValue" ::= "$IgnoreValue";
          "IgnoreLease" ::= "$IgnoreLease";
          "XXX_NoUnkeyedLiteral" ::= type.zero_val (type.structT [
          ]);
          "XXX_unrecognized" ::= type.zero_val #sliceT;
          "XXX_sizecache" ::= type.zero_val #int32T
        }])) in
        do:  ("r" <-[#ptrT] "$r0");;;
        return: (mem.alloc (let: "$Request" := (interface.make #(ptrT.id etcdserverpb.RequestOp_RequestPut.id) (mem.alloc (let: "$RequestPut" := (![#ptrT] "r") in
         struct.make #etcdserverpb.RequestOp_RequestPut [{
           "RequestPut" ::= "$RequestPut"
         }]))) in
         struct.make #etcdserverpb.RequestOp [{
           "Request" ::= "$Request";
           "XXX_NoUnkeyedLiteral" ::= type.zero_val (type.structT [
           ]);
           "XXX_unrecognized" ::= type.zero_val #sliceT;
           "XXX_sizecache" ::= type.zero_val #int32T
         }]))
      else
        (if: "$sw" = tDeleteRange
        then
          let: "r" := (mem.alloc (type.zero_val #ptrT)) in
          let: "$r0" := (mem.alloc (let: "$Key" := (![#sliceT] (struct.field_ref #Op #"key"%go "op")) in
          let: "$RangeEnd" := (![#sliceT] (struct.field_ref #Op #"end"%go "op")) in
          let: "$PrevKv" := (![#boolT] (struct.field_ref #Op #"prevKV"%go "op")) in
          struct.make #etcdserverpb.DeleteRangeRequest [{
            "Key" ::= "$Key";
            "RangeEnd" ::= "$RangeEnd";
            "PrevKv" ::= "$PrevKv";
            "XXX_NoUnkeyedLiteral" ::= type.zero_val (type.structT [
            ]);
            "XXX_unrecognized" ::= type.zero_val #sliceT;
            "XXX_sizecache" ::= type.zero_val #int32T
          }])) in
          do:  ("r" <-[#ptrT] "$r0");;;
          return: (mem.alloc (let: "$Request" := (interface.make #(ptrT.id etcdserverpb.RequestOp_RequestDeleteRange.id) (mem.alloc (let: "$RequestDeleteRange" := (![#ptrT] "r") in
           struct.make #etcdserverpb.RequestOp_RequestDeleteRange [{
             "RequestDeleteRange" ::= "$RequestDeleteRange"
           }]))) in
           struct.make #etcdserverpb.RequestOp [{
             "Request" ::= "$Request";
             "XXX_NoUnkeyedLiteral" ::= type.zero_val (type.structT [
             ]);
             "XXX_unrecognized" ::= type.zero_val #sliceT;
             "XXX_sizecache" ::= type.zero_val #int32T
           }]))
        else
          (if: "$sw" = tTxn
          then
            return: (mem.alloc (let: "$Request" := (interface.make #(ptrT.id etcdserverpb.RequestOp_RequestTxn.id) (mem.alloc (let: "$RequestTxn" := ((method_call #Op.id #"toTxnRequest"%go (![#Op] "op")) #()) in
             struct.make #etcdserverpb.RequestOp_RequestTxn [{
               "RequestTxn" ::= "$RequestTxn"
             }]))) in
             struct.make #etcdserverpb.RequestOp [{
               "Request" ::= "$Request";
               "XXX_NoUnkeyedLiteral" ::= type.zero_val (type.structT [
               ]);
               "XXX_unrecognized" ::= type.zero_val #sliceT;
               "XXX_sizecache" ::= type.zero_val #int32T
             }]))
          else
            do:  (let: "$a0" := (interface.make #stringT.id #"Unknown Op"%go) in
            Panic "$a0")))))).

(* go: op.go:209:14 *)
Definition Op__isWriteⁱᵐᵖˡ : val :=
  λ: "op" <>,
    exception_do (let: "op" := (mem.alloc "op") in
    (if: (![#opType] (struct.field_ref #Op #"t"%go "op")) = tTxn
    then
      let: "$range" := (![#sliceT] (struct.field_ref #Op #"thenOps"%go "op")) in
      (let: "tOp" := (mem.alloc (type.zero_val #Op)) in
      slice.for_range #Op "$range" (λ: "$key" "$value",
        do:  ("tOp" <-[#Op] "$value");;;
        do:  "$key";;;
        (if: (method_call #Op.id #"isWrite"%go (![#Op] "tOp")) #()
        then return: (#true)
        else do:  #())));;;
      let: "$range" := (![#sliceT] (struct.field_ref #Op #"elseOps"%go "op")) in
      (let: "tOp" := (mem.alloc (type.zero_val #Op)) in
      slice.for_range #Op "$range" (λ: "$key" "$value",
        do:  ("tOp" <-[#Op] "$value");;;
        do:  "$key";;;
        (if: (method_call #Op.id #"isWrite"%go (![#Op] "tOp")) #()
        then return: (#true)
        else do:  #())));;;
      return: (#false)
    else do:  #());;;
    return: ((![#opType] (struct.field_ref #Op #"t"%go "op")) ≠ tRange)).

Definition NewOp : go_string := "go.etcd.io/etcd/client/v3.NewOp"%go.

Definition OpGet : go_string := "go.etcd.io/etcd/client/v3.OpGet"%go.

Definition IsOptsWithPrefix : go_string := "go.etcd.io/etcd/client/v3.IsOptsWithPrefix"%go.

Definition IsOptsWithFromKey : go_string := "go.etcd.io/etcd/client/v3.IsOptsWithFromKey"%go.

(* OpGet returns "get" operation based on given key and operation options.

   go: op.go:231:6 *)
Definition OpGetⁱᵐᵖˡ : val :=
  λ: "key" "opts",
    exception_do (let: "opts" := (mem.alloc "opts") in
    let: "key" := (mem.alloc "key") in
    (if: (let: "$a0" := (![#sliceT] "opts") in
    (func_call #IsOptsWithPrefix) "$a0") && (let: "$a0" := (![#sliceT] "opts") in
    (func_call #IsOptsWithFromKey) "$a0")
    then
      do:  (let: "$a0" := (interface.make #stringT.id #"`WithPrefix` and `WithFromKey` cannot be set at the same time, choose one"%go) in
      Panic "$a0")
    else do:  #());;;
    let: "ret" := (mem.alloc (type.zero_val #Op)) in
    let: "$r0" := (let: "$t" := tRange in
    let: "$key" := (string.to_bytes (![#stringT] "key")) in
    struct.make #Op [{
      "t" ::= "$t";
      "key" ::= "$key";
      "end" ::= type.zero_val #sliceT;
      "limit" ::= type.zero_val #int64T;
      "sort" ::= type.zero_val #ptrT;
      "serializable" ::= type.zero_val #boolT;
      "keysOnly" ::= type.zero_val #boolT;
      "countOnly" ::= type.zero_val #boolT;
      "minModRev" ::= type.zero_val #int64T;
      "maxModRev" ::= type.zero_val #int64T;
      "minCreateRev" ::= type.zero_val #int64T;
      "maxCreateRev" ::= type.zero_val #int64T;
      "rev" ::= type.zero_val #int64T;
      "prevKV" ::= type.zero_val #boolT;
      "fragment" ::= type.zero_val #boolT;
      "ignoreValue" ::= type.zero_val #boolT;
      "ignoreLease" ::= type.zero_val #boolT;
      "progressNotify" ::= type.zero_val #boolT;
      "createdNotify" ::= type.zero_val #boolT;
      "filterPut" ::= type.zero_val #boolT;
      "filterDelete" ::= type.zero_val #boolT;
      "val" ::= type.zero_val #sliceT;
      "leaseID" ::= type.zero_val #LeaseID;
      "cmps" ::= type.zero_val #sliceT;
      "thenOps" ::= type.zero_val #sliceT;
      "elseOps" ::= type.zero_val #sliceT;
      "isOptsWithFromKey" ::= type.zero_val #boolT;
      "isOptsWithPrefix" ::= type.zero_val #boolT
    }]) in
    do:  ("ret" <-[#Op] "$r0");;;
    do:  (let: "$a0" := (![#sliceT] "opts") in
    (method_call #(ptrT.id Op.id) #"applyOpts"%go "ret") "$a0");;;
    return: (![#Op] "ret")).

Definition OpDelete : go_string := "go.etcd.io/etcd/client/v3.OpDelete"%go.

(* OpDelete returns "delete" operation based on given key and operation options.

   go: op.go:242:6 *)
Definition OpDeleteⁱᵐᵖˡ : val :=
  λ: "key" "opts",
    exception_do (let: "opts" := (mem.alloc "opts") in
    let: "key" := (mem.alloc "key") in
    (if: (let: "$a0" := (![#sliceT] "opts") in
    (func_call #IsOptsWithPrefix) "$a0") && (let: "$a0" := (![#sliceT] "opts") in
    (func_call #IsOptsWithFromKey) "$a0")
    then
      do:  (let: "$a0" := (interface.make #stringT.id #"`WithPrefix` and `WithFromKey` cannot be set at the same time, choose one"%go) in
      Panic "$a0")
    else do:  #());;;
    let: "ret" := (mem.alloc (type.zero_val #Op)) in
    let: "$r0" := (let: "$t" := tDeleteRange in
    let: "$key" := (string.to_bytes (![#stringT] "key")) in
    struct.make #Op [{
      "t" ::= "$t";
      "key" ::= "$key";
      "end" ::= type.zero_val #sliceT;
      "limit" ::= type.zero_val #int64T;
      "sort" ::= type.zero_val #ptrT;
      "serializable" ::= type.zero_val #boolT;
      "keysOnly" ::= type.zero_val #boolT;
      "countOnly" ::= type.zero_val #boolT;
      "minModRev" ::= type.zero_val #int64T;
      "maxModRev" ::= type.zero_val #int64T;
      "minCreateRev" ::= type.zero_val #int64T;
      "maxCreateRev" ::= type.zero_val #int64T;
      "rev" ::= type.zero_val #int64T;
      "prevKV" ::= type.zero_val #boolT;
      "fragment" ::= type.zero_val #boolT;
      "ignoreValue" ::= type.zero_val #boolT;
      "ignoreLease" ::= type.zero_val #boolT;
      "progressNotify" ::= type.zero_val #boolT;
      "createdNotify" ::= type.zero_val #boolT;
      "filterPut" ::= type.zero_val #boolT;
      "filterDelete" ::= type.zero_val #boolT;
      "val" ::= type.zero_val #sliceT;
      "leaseID" ::= type.zero_val #LeaseID;
      "cmps" ::= type.zero_val #sliceT;
      "thenOps" ::= type.zero_val #sliceT;
      "elseOps" ::= type.zero_val #sliceT;
      "isOptsWithFromKey" ::= type.zero_val #boolT;
      "isOptsWithPrefix" ::= type.zero_val #boolT
    }]) in
    do:  ("ret" <-[#Op] "$r0");;;
    do:  (let: "$a0" := (![#sliceT] "opts") in
    (method_call #(ptrT.id Op.id) #"applyOpts"%go "ret") "$a0");;;
    let: "$sw" := #true in
    (if: "$sw" = ((![#LeaseID] (struct.field_ref #Op #"leaseID"%go "ret")) ≠ #(W64 0))
    then
      do:  (let: "$a0" := (interface.make #stringT.id #"unexpected lease in delete"%go) in
      Panic "$a0")
    else
      (if: "$sw" = ((![#int64T] (struct.field_ref #Op #"limit"%go "ret")) ≠ #(W64 0))
      then
        do:  (let: "$a0" := (interface.make #stringT.id #"unexpected limit in delete"%go) in
        Panic "$a0")
      else
        (if: "$sw" = ((![#int64T] (struct.field_ref #Op #"rev"%go "ret")) ≠ #(W64 0))
        then
          do:  (let: "$a0" := (interface.make #stringT.id #"unexpected revision in delete"%go) in
          Panic "$a0")
        else
          (if: "$sw" = ((![#ptrT] (struct.field_ref #Op #"sort"%go "ret")) ≠ #null)
          then
            do:  (let: "$a0" := (interface.make #stringT.id #"unexpected sort in delete"%go) in
            Panic "$a0")
          else
            (if: "$sw" = (![#boolT] (struct.field_ref #Op #"serializable"%go "ret"))
            then
              do:  (let: "$a0" := (interface.make #stringT.id #"unexpected serializable in delete"%go) in
              Panic "$a0")
            else
              (if: "$sw" = (![#boolT] (struct.field_ref #Op #"countOnly"%go "ret"))
              then
                do:  (let: "$a0" := (interface.make #stringT.id #"unexpected countOnly in delete"%go) in
                Panic "$a0")
              else
                (if: ("$sw" = ((![#int64T] (struct.field_ref #Op #"maxModRev"%go "ret")) ≠ #(W64 0))) || ("$sw" = ((![#int64T] (struct.field_ref #Op #"minModRev"%go "ret")) ≠ #(W64 0)))
                then
                  do:  (let: "$a0" := (interface.make #stringT.id #"unexpected mod revision filter in delete"%go) in
                  Panic "$a0")
                else
                  (if: ("$sw" = ((![#int64T] (struct.field_ref #Op #"maxCreateRev"%go "ret")) ≠ #(W64 0))) || ("$sw" = ((![#int64T] (struct.field_ref #Op #"minCreateRev"%go "ret")) ≠ #(W64 0)))
                  then
                    do:  (let: "$a0" := (interface.make #stringT.id #"unexpected create revision filter in delete"%go) in
                    Panic "$a0")
                  else
                    (if: ("$sw" = (![#boolT] (struct.field_ref #Op #"filterPut"%go "ret"))) || ("$sw" = (![#boolT] (struct.field_ref #Op #"filterDelete"%go "ret")))
                    then
                      do:  (let: "$a0" := (interface.make #stringT.id #"unexpected filter in delete"%go) in
                      Panic "$a0")
                    else
                      (if: "$sw" = (![#boolT] (struct.field_ref #Op #"createdNotify"%go "ret"))
                      then
                        do:  (let: "$a0" := (interface.make #stringT.id #"unexpected createdNotify in delete"%go) in
                        Panic "$a0")
                      else do:  #()))))))))));;;
    return: (![#Op] "ret")).

Definition OpPut : go_string := "go.etcd.io/etcd/client/v3.OpPut"%go.

(* OpPut returns "put" operation based on given key-value and operation options.

   go: op.go:275:6 *)
Definition OpPutⁱᵐᵖˡ : val :=
  λ: "key" "val" "opts",
    exception_do (let: "opts" := (mem.alloc "opts") in
    let: "val" := (mem.alloc "val") in
    let: "key" := (mem.alloc "key") in
    let: "ret" := (mem.alloc (type.zero_val #Op)) in
    let: "$r0" := (let: "$t" := tPut in
    let: "$key" := (string.to_bytes (![#stringT] "key")) in
    let: "$val" := (string.to_bytes (![#stringT] "val")) in
    struct.make #Op [{
      "t" ::= "$t";
      "key" ::= "$key";
      "end" ::= type.zero_val #sliceT;
      "limit" ::= type.zero_val #int64T;
      "sort" ::= type.zero_val #ptrT;
      "serializable" ::= type.zero_val #boolT;
      "keysOnly" ::= type.zero_val #boolT;
      "countOnly" ::= type.zero_val #boolT;
      "minModRev" ::= type.zero_val #int64T;
      "maxModRev" ::= type.zero_val #int64T;
      "minCreateRev" ::= type.zero_val #int64T;
      "maxCreateRev" ::= type.zero_val #int64T;
      "rev" ::= type.zero_val #int64T;
      "prevKV" ::= type.zero_val #boolT;
      "fragment" ::= type.zero_val #boolT;
      "ignoreValue" ::= type.zero_val #boolT;
      "ignoreLease" ::= type.zero_val #boolT;
      "progressNotify" ::= type.zero_val #boolT;
      "createdNotify" ::= type.zero_val #boolT;
      "filterPut" ::= type.zero_val #boolT;
      "filterDelete" ::= type.zero_val #boolT;
      "val" ::= "$val";
      "leaseID" ::= type.zero_val #LeaseID;
      "cmps" ::= type.zero_val #sliceT;
      "thenOps" ::= type.zero_val #sliceT;
      "elseOps" ::= type.zero_val #sliceT;
      "isOptsWithFromKey" ::= type.zero_val #boolT;
      "isOptsWithPrefix" ::= type.zero_val #boolT
    }]) in
    do:  ("ret" <-[#Op] "$r0");;;
    do:  (let: "$a0" := (![#sliceT] "opts") in
    (method_call #(ptrT.id Op.id) #"applyOpts"%go "ret") "$a0");;;
    let: "$sw" := #true in
    (if: "$sw" = ((![#sliceT] (struct.field_ref #Op #"end"%go "ret")) ≠ #slice.nil)
    then
      do:  (let: "$a0" := (interface.make #stringT.id #"unexpected range in put"%go) in
      Panic "$a0")
    else
      (if: "$sw" = ((![#int64T] (struct.field_ref #Op #"limit"%go "ret")) ≠ #(W64 0))
      then
        do:  (let: "$a0" := (interface.make #stringT.id #"unexpected limit in put"%go) in
        Panic "$a0")
      else
        (if: "$sw" = ((![#int64T] (struct.field_ref #Op #"rev"%go "ret")) ≠ #(W64 0))
        then
          do:  (let: "$a0" := (interface.make #stringT.id #"unexpected revision in put"%go) in
          Panic "$a0")
        else
          (if: "$sw" = ((![#ptrT] (struct.field_ref #Op #"sort"%go "ret")) ≠ #null)
          then
            do:  (let: "$a0" := (interface.make #stringT.id #"unexpected sort in put"%go) in
            Panic "$a0")
          else
            (if: "$sw" = (![#boolT] (struct.field_ref #Op #"serializable"%go "ret"))
            then
              do:  (let: "$a0" := (interface.make #stringT.id #"unexpected serializable in put"%go) in
              Panic "$a0")
            else
              (if: "$sw" = (![#boolT] (struct.field_ref #Op #"countOnly"%go "ret"))
              then
                do:  (let: "$a0" := (interface.make #stringT.id #"unexpected countOnly in put"%go) in
                Panic "$a0")
              else
                (if: ("$sw" = ((![#int64T] (struct.field_ref #Op #"maxModRev"%go "ret")) ≠ #(W64 0))) || ("$sw" = ((![#int64T] (struct.field_ref #Op #"minModRev"%go "ret")) ≠ #(W64 0)))
                then
                  do:  (let: "$a0" := (interface.make #stringT.id #"unexpected mod revision filter in put"%go) in
                  Panic "$a0")
                else
                  (if: ("$sw" = ((![#int64T] (struct.field_ref #Op #"maxCreateRev"%go "ret")) ≠ #(W64 0))) || ("$sw" = ((![#int64T] (struct.field_ref #Op #"minCreateRev"%go "ret")) ≠ #(W64 0)))
                  then
                    do:  (let: "$a0" := (interface.make #stringT.id #"unexpected create revision filter in put"%go) in
                    Panic "$a0")
                  else
                    (if: ("$sw" = (![#boolT] (struct.field_ref #Op #"filterPut"%go "ret"))) || ("$sw" = (![#boolT] (struct.field_ref #Op #"filterDelete"%go "ret")))
                    then
                      do:  (let: "$a0" := (interface.make #stringT.id #"unexpected filter in put"%go) in
                      Panic "$a0")
                    else
                      (if: "$sw" = (![#boolT] (struct.field_ref #Op #"createdNotify"%go "ret"))
                      then
                        do:  (let: "$a0" := (interface.make #stringT.id #"unexpected createdNotify in put"%go) in
                        Panic "$a0")
                      else do:  #()))))))))));;;
    return: (![#Op] "ret")).

Definition OpTxn : go_string := "go.etcd.io/etcd/client/v3.OpTxn"%go.

(* OpTxn returns "txn" operation based on given transaction conditions.

   go: op.go:304:6 *)
Definition OpTxnⁱᵐᵖˡ : val :=
  λ: "cmps" "thenOps" "elseOps",
    exception_do (let: "elseOps" := (mem.alloc "elseOps") in
    let: "thenOps" := (mem.alloc "thenOps") in
    let: "cmps" := (mem.alloc "cmps") in
    return: (let: "$t" := tTxn in
     let: "$cmps" := (![#sliceT] "cmps") in
     let: "$thenOps" := (![#sliceT] "thenOps") in
     let: "$elseOps" := (![#sliceT] "elseOps") in
     struct.make #Op [{
       "t" ::= "$t";
       "key" ::= type.zero_val #sliceT;
       "end" ::= type.zero_val #sliceT;
       "limit" ::= type.zero_val #int64T;
       "sort" ::= type.zero_val #ptrT;
       "serializable" ::= type.zero_val #boolT;
       "keysOnly" ::= type.zero_val #boolT;
       "countOnly" ::= type.zero_val #boolT;
       "minModRev" ::= type.zero_val #int64T;
       "maxModRev" ::= type.zero_val #int64T;
       "minCreateRev" ::= type.zero_val #int64T;
       "maxCreateRev" ::= type.zero_val #int64T;
       "rev" ::= type.zero_val #int64T;
       "prevKV" ::= type.zero_val #boolT;
       "fragment" ::= type.zero_val #boolT;
       "ignoreValue" ::= type.zero_val #boolT;
       "ignoreLease" ::= type.zero_val #boolT;
       "progressNotify" ::= type.zero_val #boolT;
       "createdNotify" ::= type.zero_val #boolT;
       "filterPut" ::= type.zero_val #boolT;
       "filterDelete" ::= type.zero_val #boolT;
       "val" ::= type.zero_val #sliceT;
       "leaseID" ::= type.zero_val #LeaseID;
       "cmps" ::= "$cmps";
       "thenOps" ::= "$thenOps";
       "elseOps" ::= "$elseOps";
       "isOptsWithFromKey" ::= type.zero_val #boolT;
       "isOptsWithPrefix" ::= type.zero_val #boolT
     }])).

Definition opWatch : go_string := "go.etcd.io/etcd/client/v3.opWatch"%go.

Definition OpOption : go_type := funcT.

(* go: op.go:330:15 *)
Definition Op__applyOptsⁱᵐᵖˡ : val :=
  λ: "op" "opts",
    exception_do (let: "op" := (mem.alloc "op") in
    let: "opts" := (mem.alloc "opts") in
    let: "$range" := (![#sliceT] "opts") in
    (let: "opt" := (mem.alloc (type.zero_val #OpOption)) in
    slice.for_range #OpOption "$range" (λ: "$key" "$value",
      do:  ("opt" <-[#OpOption] "$value");;;
      do:  "$key";;;
      do:  (let: "$a0" := (![#ptrT] "op") in
      (![#OpOption] "opt") "$a0")));;;
    return: #()).

Definition WithLease : go_string := "go.etcd.io/etcd/client/v3.WithLease"%go.

(* WithLease attaches a lease ID to a key in 'Put' request.

   go: op.go:340:6 *)
Definition WithLeaseⁱᵐᵖˡ : val :=
  λ: "leaseID",
    exception_do (let: "leaseID" := (mem.alloc "leaseID") in
    return: ((λ: "op",
       exception_do (let: "op" := (mem.alloc "op") in
       let: "$r0" := (![#LeaseID] "leaseID") in
       do:  ((struct.field_ref #Op #"leaseID"%go (![#ptrT] "op")) <-[#LeaseID] "$r0");;;
       return: #())
       ))).

Definition WithLimit : go_string := "go.etcd.io/etcd/client/v3.WithLimit"%go.

(* WithLimit limits the number of results to return from 'Get' request.
   If WithLimit is given a 0 limit, it is treated as no limit.

   go: op.go:346:6 *)
Definition WithLimitⁱᵐᵖˡ : val :=
  λ: "n",
    exception_do (let: "n" := (mem.alloc "n") in
    return: ((λ: "op",
       exception_do (let: "op" := (mem.alloc "op") in
       let: "$r0" := (![#int64T] "n") in
       do:  ((struct.field_ref #Op #"limit"%go (![#ptrT] "op")) <-[#int64T] "$r0");;;
       return: #())
       ))).

Definition WithRev : go_string := "go.etcd.io/etcd/client/v3.WithRev"%go.

(* WithRev specifies the store revision for 'Get' request.
   Or the start revision of 'Watch' request.

   go: op.go:350:6 *)
Definition WithRevⁱᵐᵖˡ : val :=
  λ: "rev",
    exception_do (let: "rev" := (mem.alloc "rev") in
    return: ((λ: "op",
       exception_do (let: "op" := (mem.alloc "op") in
       let: "$r0" := (![#int64T] "rev") in
       do:  ((struct.field_ref #Op #"rev"%go (![#ptrT] "op")) <-[#int64T] "$r0");;;
       return: #())
       ))).

Definition WithSort : go_string := "go.etcd.io/etcd/client/v3.WithSort"%go.

Definition SortByKey : expr := #(W64 0).

Definition SortAscend : expr := #(W64 1).

Definition SortNone : expr := #(W64 0).

(* WithSort specifies the ordering in 'Get' request. It requires
   'WithRange' and/or 'WithPrefix' to be specified too.
   'target' specifies the target to sort by: key, version, revisions, value.
   'order' can be either 'SortNone', 'SortAscend', 'SortDescend'.

   go: op.go:356:6 *)
Definition WithSortⁱᵐᵖˡ : val :=
  λ: "target" "order",
    exception_do (let: "order" := (mem.alloc "order") in
    let: "target" := (mem.alloc "target") in
    return: ((λ: "op",
       exception_do (let: "op" := (mem.alloc "op") in
       (if: ((![#SortTarget] "target") = SortByKey) && ((![#SortOrder] "order") = SortAscend)
       then
         let: "$r0" := SortNone in
         do:  ("order" <-[#SortOrder] "$r0")
       else do:  #());;;
       let: "$r0" := (mem.alloc (struct.make #SortOption [{
         "Target" ::= ![#SortTarget] "target";
         "Order" ::= ![#SortOrder] "order"
       }])) in
       do:  ((struct.field_ref #Op #"sort"%go (![#ptrT] "op")) <-[#ptrT] "$r0");;;
       return: #())
       ))).

Definition GetPrefixRangeEnd : go_string := "go.etcd.io/etcd/client/v3.GetPrefixRangeEnd"%go.

Definition getPrefix : go_string := "go.etcd.io/etcd/client/v3.getPrefix"%go.

Definition WithPrefix : go_string := "go.etcd.io/etcd/client/v3.WithPrefix"%go.

(* WithPrefix enables 'Get', 'Delete', or 'Watch' requests to operate
   on the keys with matching prefix. For example, 'Get(foo, WithPrefix())'
   can return 'foo1', 'foo2', and so on.

   go: op.go:394:6 *)
Definition WithPrefixⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: ((λ: "op",
       exception_do (let: "op" := (mem.alloc "op") in
       let: "$r0" := #true in
       do:  ((struct.field_ref #Op #"isOptsWithPrefix"%go (![#ptrT] "op")) <-[#boolT] "$r0");;;
       (if: (let: "$a0" := (![#sliceT] (struct.field_ref #Op #"key"%go (![#ptrT] "op"))) in
       slice.len "$a0") = #(W64 0)
       then
         let: "$r0" := ((let: "$sl0" := #(W8 0) in
         slice.literal #byteT ["$sl0"])) in
         let: "$r1" := ((let: "$sl0" := #(W8 0) in
         slice.literal #byteT ["$sl0"])) in
         do:  ((struct.field_ref #Op #"key"%go (![#ptrT] "op")) <-[#sliceT] "$r0");;;
         do:  ((struct.field_ref #Op #"end"%go (![#ptrT] "op")) <-[#sliceT] "$r1");;;
         return: (#())
       else do:  #());;;
       let: "$r0" := (let: "$a0" := (![#sliceT] (struct.field_ref #Op #"key"%go (![#ptrT] "op"))) in
       (func_call #getPrefix) "$a0") in
       do:  ((struct.field_ref #Op #"end"%go (![#ptrT] "op")) <-[#sliceT] "$r0");;;
       return: #())
       ))).

Definition WithRange : go_string := "go.etcd.io/etcd/client/v3.WithRange"%go.

(* WithRange specifies the range of 'Get', 'Delete', 'Watch' requests.
   For example, 'Get' requests with 'WithRange(end)' returns
   the keys in the range [key, end).
   endKey must be lexicographically greater than start key.

   go: op.go:409:6 *)
Definition WithRangeⁱᵐᵖˡ : val :=
  λ: "endKey",
    exception_do (let: "endKey" := (mem.alloc "endKey") in
    return: ((λ: "op",
       exception_do (let: "op" := (mem.alloc "op") in
       let: "$r0" := (string.to_bytes (![#stringT] "endKey")) in
       do:  ((struct.field_ref #Op #"end"%go (![#ptrT] "op")) <-[#sliceT] "$r0");;;
       return: #())
       ))).

Definition WithFromKey : go_string := "go.etcd.io/etcd/client/v3.WithFromKey"%go.

(* WithFromKey specifies the range of 'Get', 'Delete', 'Watch' requests
   to be equal or greater than the key in the argument.

   go: op.go:415:6 *)
Definition WithFromKeyⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: ((λ: "op",
       exception_do (let: "op" := (mem.alloc "op") in
       (if: (let: "$a0" := (![#sliceT] (struct.field_ref #Op #"key"%go (![#ptrT] "op"))) in
       slice.len "$a0") = #(W64 0)
       then
         let: "$r0" := ((let: "$sl0" := #(W8 0) in
         slice.literal #byteT ["$sl0"])) in
         do:  ((struct.field_ref #Op #"key"%go (![#ptrT] "op")) <-[#sliceT] "$r0")
       else do:  #());;;
       let: "$r0" := (string.to_bytes #" "%go) in
       do:  ((struct.field_ref #Op #"end"%go (![#ptrT] "op")) <-[#sliceT] "$r0");;;
       let: "$r0" := #true in
       do:  ((struct.field_ref #Op #"isOptsWithFromKey"%go (![#ptrT] "op")) <-[#boolT] "$r0");;;
       return: #())
       ))).

Definition WithSerializable : go_string := "go.etcd.io/etcd/client/v3.WithSerializable"%go.

(* WithSerializable makes `Get` and `MemberList` requests serializable.
   By default, they are linearizable. Serializable requests are better
   for lower latency requirement, but users should be aware that they
   could get stale data with serializable requests.

   In some situations users may want to use serializable requests. For
   example, when adding a new member to a one-node cluster, it's reasonable
   and safe to use serializable request before the new added member gets
   started.

   go: op.go:434:6 *)
Definition WithSerializableⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: ((λ: "op",
       exception_do (let: "op" := (mem.alloc "op") in
       let: "$r0" := #true in
       do:  ((struct.field_ref #Op #"serializable"%go (![#ptrT] "op")) <-[#boolT] "$r0");;;
       return: #())
       ))).

Definition WithKeysOnly : go_string := "go.etcd.io/etcd/client/v3.WithKeysOnly"%go.

(* WithKeysOnly makes the 'Get' request return only the keys and the corresponding
   values will be omitted.

   go: op.go:440:6 *)
Definition WithKeysOnlyⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: ((λ: "op",
       exception_do (let: "op" := (mem.alloc "op") in
       let: "$r0" := #true in
       do:  ((struct.field_ref #Op #"keysOnly"%go (![#ptrT] "op")) <-[#boolT] "$r0");;;
       return: #())
       ))).

Definition WithCountOnly : go_string := "go.etcd.io/etcd/client/v3.WithCountOnly"%go.

(* WithCountOnly makes the 'Get' request return only the count of keys.

   go: op.go:445:6 *)
Definition WithCountOnlyⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: ((λ: "op",
       exception_do (let: "op" := (mem.alloc "op") in
       let: "$r0" := #true in
       do:  ((struct.field_ref #Op #"countOnly"%go (![#ptrT] "op")) <-[#boolT] "$r0");;;
       return: #())
       ))).

Definition WithMinModRev : go_string := "go.etcd.io/etcd/client/v3.WithMinModRev"%go.

(* WithMinModRev filters out keys for Get with modification revisions less than the given revision.

   go: op.go:450:6 *)
Definition WithMinModRevⁱᵐᵖˡ : val :=
  λ: "rev",
    exception_do (let: "rev" := (mem.alloc "rev") in
    return: ((λ: "op",
       exception_do (let: "op" := (mem.alloc "op") in
       let: "$r0" := (![#int64T] "rev") in
       do:  ((struct.field_ref #Op #"minModRev"%go (![#ptrT] "op")) <-[#int64T] "$r0");;;
       return: #())
       ))).

Definition WithMaxModRev : go_string := "go.etcd.io/etcd/client/v3.WithMaxModRev"%go.

(* WithMaxModRev filters out keys for Get with modification revisions greater than the given revision.

   go: op.go:453:6 *)
Definition WithMaxModRevⁱᵐᵖˡ : val :=
  λ: "rev",
    exception_do (let: "rev" := (mem.alloc "rev") in
    return: ((λ: "op",
       exception_do (let: "op" := (mem.alloc "op") in
       let: "$r0" := (![#int64T] "rev") in
       do:  ((struct.field_ref #Op #"maxModRev"%go (![#ptrT] "op")) <-[#int64T] "$r0");;;
       return: #())
       ))).

Definition WithMinCreateRev : go_string := "go.etcd.io/etcd/client/v3.WithMinCreateRev"%go.

(* WithMinCreateRev filters out keys for Get with creation revisions less than the given revision.

   go: op.go:456:6 *)
Definition WithMinCreateRevⁱᵐᵖˡ : val :=
  λ: "rev",
    exception_do (let: "rev" := (mem.alloc "rev") in
    return: ((λ: "op",
       exception_do (let: "op" := (mem.alloc "op") in
       let: "$r0" := (![#int64T] "rev") in
       do:  ((struct.field_ref #Op #"minCreateRev"%go (![#ptrT] "op")) <-[#int64T] "$r0");;;
       return: #())
       ))).

Definition WithMaxCreateRev : go_string := "go.etcd.io/etcd/client/v3.WithMaxCreateRev"%go.

(* WithMaxCreateRev filters out keys for Get with creation revisions greater than the given revision.

   go: op.go:459:6 *)
Definition WithMaxCreateRevⁱᵐᵖˡ : val :=
  λ: "rev",
    exception_do (let: "rev" := (mem.alloc "rev") in
    return: ((λ: "op",
       exception_do (let: "op" := (mem.alloc "op") in
       let: "$r0" := (![#int64T] "rev") in
       do:  ((struct.field_ref #Op #"maxCreateRev"%go (![#ptrT] "op")) <-[#int64T] "$r0");;;
       return: #())
       ))).

Definition WithFirstCreate : go_string := "go.etcd.io/etcd/client/v3.WithFirstCreate"%go.

Definition withTop : go_string := "go.etcd.io/etcd/client/v3.withTop"%go.

Definition SortByCreateRevision : expr := #(W64 2).

(* WithFirstCreate gets the key with the oldest creation revision in the request range.

   go: op.go:462:6 *)
Definition WithFirstCreateⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (let: "$a0" := SortByCreateRevision in
     let: "$a1" := SortAscend in
     (func_call #withTop) "$a0" "$a1")).

Definition WithLastCreate : go_string := "go.etcd.io/etcd/client/v3.WithLastCreate"%go.

Definition SortDescend : expr := #(W64 2).

(* WithLastCreate gets the key with the latest creation revision in the request range.

   go: op.go:465:6 *)
Definition WithLastCreateⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (let: "$a0" := SortByCreateRevision in
     let: "$a1" := SortDescend in
     (func_call #withTop) "$a0" "$a1")).

Definition WithFirstKey : go_string := "go.etcd.io/etcd/client/v3.WithFirstKey"%go.

(* WithFirstKey gets the lexically first key in the request range.

   go: op.go:468:6 *)
Definition WithFirstKeyⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (let: "$a0" := SortByKey in
     let: "$a1" := SortAscend in
     (func_call #withTop) "$a0" "$a1")).

Definition WithLastKey : go_string := "go.etcd.io/etcd/client/v3.WithLastKey"%go.

(* WithLastKey gets the lexically last key in the request range.

   go: op.go:471:6 *)
Definition WithLastKeyⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (let: "$a0" := SortByKey in
     let: "$a1" := SortDescend in
     (func_call #withTop) "$a0" "$a1")).

Definition WithFirstRev : go_string := "go.etcd.io/etcd/client/v3.WithFirstRev"%go.

Definition SortByModRevision : expr := #(W64 3).

(* WithFirstRev gets the key with the oldest modification revision in the request range.

   go: op.go:474:6 *)
Definition WithFirstRevⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (let: "$a0" := SortByModRevision in
     let: "$a1" := SortAscend in
     (func_call #withTop) "$a0" "$a1")).

Definition WithLastRev : go_string := "go.etcd.io/etcd/client/v3.WithLastRev"%go.

(* WithLastRev gets the key with the latest modification revision in the request range.

   go: op.go:477:6 *)
Definition WithLastRevⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: (let: "$a0" := SortByModRevision in
     let: "$a1" := SortDescend in
     (func_call #withTop) "$a0" "$a1")).

Definition WithProgressNotify : go_string := "go.etcd.io/etcd/client/v3.WithProgressNotify"%go.

(* WithProgressNotify makes watch server send periodic progress updates
   every 10 minutes when there is no incoming events.
   Progress updates have zero events in WatchResponse.

   go: op.go:487:6 *)
Definition WithProgressNotifyⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: ((λ: "op",
       exception_do (let: "op" := (mem.alloc "op") in
       let: "$r0" := #true in
       do:  ((struct.field_ref #Op #"progressNotify"%go (![#ptrT] "op")) <-[#boolT] "$r0");;;
       return: #())
       ))).

Definition WithCreatedNotify : go_string := "go.etcd.io/etcd/client/v3.WithCreatedNotify"%go.

(* WithCreatedNotify makes watch server sends the created event.

   go: op.go:494:6 *)
Definition WithCreatedNotifyⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: ((λ: "op",
       exception_do (let: "op" := (mem.alloc "op") in
       let: "$r0" := #true in
       do:  ((struct.field_ref #Op #"createdNotify"%go (![#ptrT] "op")) <-[#boolT] "$r0");;;
       return: #())
       ))).

Definition WithFilterPut : go_string := "go.etcd.io/etcd/client/v3.WithFilterPut"%go.

(* WithFilterPut discards PUT events from the watcher.

   go: op.go:501:6 *)
Definition WithFilterPutⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: ((λ: "op",
       exception_do (let: "op" := (mem.alloc "op") in
       let: "$r0" := #true in
       do:  ((struct.field_ref #Op #"filterPut"%go (![#ptrT] "op")) <-[#boolT] "$r0");;;
       return: #())
       ))).

Definition WithFilterDelete : go_string := "go.etcd.io/etcd/client/v3.WithFilterDelete"%go.

(* WithFilterDelete discards DELETE events from the watcher.

   go: op.go:506:6 *)
Definition WithFilterDeleteⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: ((λ: "op",
       exception_do (let: "op" := (mem.alloc "op") in
       let: "$r0" := #true in
       do:  ((struct.field_ref #Op #"filterDelete"%go (![#ptrT] "op")) <-[#boolT] "$r0");;;
       return: #())
       ))).

Definition WithPrevKV : go_string := "go.etcd.io/etcd/client/v3.WithPrevKV"%go.

(* WithPrevKV gets the previous key-value pair before the event happens. If the previous KV is already compacted,
   nothing will be returned.

   go: op.go:512:6 *)
Definition WithPrevKVⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: ((λ: "op",
       exception_do (let: "op" := (mem.alloc "op") in
       let: "$r0" := #true in
       do:  ((struct.field_ref #Op #"prevKV"%go (![#ptrT] "op")) <-[#boolT] "$r0");;;
       return: #())
       ))).

Definition WithFragment : go_string := "go.etcd.io/etcd/client/v3.WithFragment"%go.

(* WithFragment to receive raw watch response with fragmentation.
   Fragmentation is disabled by default. If fragmentation is enabled,
   etcd watch server will split watch response before sending to clients
   when the total size of watch events exceed server-side request limit.
   The default server-side request limit is 1.5 MiB, which can be configured
   as "--max-request-bytes" flag value + gRPC-overhead 512 bytes.
   See "etcdserver/api/v3rpc/watch.go" for more details.

   go: op.go:525:6 *)
Definition WithFragmentⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: ((λ: "op",
       exception_do (let: "op" := (mem.alloc "op") in
       let: "$r0" := #true in
       do:  ((struct.field_ref #Op #"fragment"%go (![#ptrT] "op")) <-[#boolT] "$r0");;;
       return: #())
       ))).

Definition WithIgnoreValue : go_string := "go.etcd.io/etcd/client/v3.WithIgnoreValue"%go.

(* WithIgnoreValue updates the key using its current value.
   This option can not be combined with non-empty values.
   Returns an error if the key does not exist.

   go: op.go:532:6 *)
Definition WithIgnoreValueⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: ((λ: "op",
       exception_do (let: "op" := (mem.alloc "op") in
       let: "$r0" := #true in
       do:  ((struct.field_ref #Op #"ignoreValue"%go (![#ptrT] "op")) <-[#boolT] "$r0");;;
       return: #())
       ))).

Definition WithIgnoreLease : go_string := "go.etcd.io/etcd/client/v3.WithIgnoreLease"%go.

(* WithIgnoreLease updates the key using its current lease.
   This option can not be combined with WithLease.
   Returns an error if the key does not exist.

   go: op.go:541:6 *)
Definition WithIgnoreLeaseⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: ((λ: "op",
       exception_do (let: "op" := (mem.alloc "op") in
       let: "$r0" := #true in
       do:  ((struct.field_ref #Op #"ignoreLease"%go (![#ptrT] "op")) <-[#boolT] "$r0");;;
       return: #())
       ))).

Definition LeaseOp : go_type := structT [
  "id" :: LeaseID;
  "attachedKeys" :: boolT
].

Definition LeaseOption : go_type := funcT.

Definition WithAttachedKeys : go_string := "go.etcd.io/etcd/client/v3.WithAttachedKeys"%go.

(* WithAttachedKeys makes TimeToLive list the keys attached to the given lease ID.

   go: op.go:565:6 *)
Definition WithAttachedKeysⁱᵐᵖˡ : val :=
  λ: <>,
    exception_do (return: ((λ: "op",
       exception_do (let: "op" := (mem.alloc "op") in
       let: "$r0" := #true in
       do:  ((struct.field_ref #LeaseOp #"attachedKeys"%go (![#ptrT] "op")) <-[#boolT] "$r0");;;
       return: #())
       ))).

Definition toLeaseTimeToLiveRequest : go_string := "go.etcd.io/etcd/client/v3.toLeaseTimeToLiveRequest"%go.

(* go: op.go:595:14 *)
Definition Op__IsSortOptionValidⁱᵐᵖˡ : val :=
  λ: "op" <>,
    exception_do (let: "op" := (mem.alloc "op") in
    (if: (![#ptrT] (struct.field_ref #Op #"sort"%go "op")) ≠ #null
    then
      let: "sortOrder" := (mem.alloc (type.zero_val #int32T)) in
      let: "$r0" := (s_to_w32 (![#SortOrder] (struct.field_ref #SortOption #"Order"%go (![#ptrT] (struct.field_ref #Op #"sort"%go "op"))))) in
      do:  ("sortOrder" <-[#int32T] "$r0");;;
      let: "sortTarget" := (mem.alloc (type.zero_val #int32T)) in
      let: "$r0" := (s_to_w32 (![#SortTarget] (struct.field_ref #SortOption #"Target"%go (![#ptrT] (struct.field_ref #Op #"sort"%go "op"))))) in
      do:  ("sortTarget" <-[#int32T] "$r0");;;
      (let: "ok" := (mem.alloc (type.zero_val #boolT)) in
      let: ("$ret0", "$ret1") := (map.get (![type.mapT #int32T #stringT] (globals.get #etcdserverpb.RangeRequest_SortOrder_name)) (![#int32T] "sortOrder")) in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  "$r0";;;
      do:  ("ok" <-[#boolT] "$r1");;;
      (if: (~ (![#boolT] "ok"))
      then return: (#false)
      else do:  #()));;;
      (let: "ok" := (mem.alloc (type.zero_val #boolT)) in
      let: ("$ret0", "$ret1") := (map.get (![type.mapT #int32T #stringT] (globals.get #etcdserverpb.RangeRequest_SortTarget_name)) (![#int32T] "sortTarget")) in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  "$r0";;;
      do:  ("ok" <-[#boolT] "$r1");;;
      (if: (~ (![#boolT] "ok"))
      then return: (#false)
      else do:  #()))
    else do:  #());;;
    return: (#true)).

Definition defaultWaitForReady : go_string := "go.etcd.io/etcd/client/v3.defaultWaitForReady"%go.

Axiom defaultWaitForReady'init : val.

Definition defaultMaxCallSendMsgSize : go_string := "go.etcd.io/etcd/client/v3.defaultMaxCallSendMsgSize"%go.

Axiom defaultMaxCallSendMsgSize'init : val.

Definition defaultMaxCallRecvMsgSize : go_string := "go.etcd.io/etcd/client/v3.defaultMaxCallRecvMsgSize"%go.

Axiom defaultMaxCallRecvMsgSize'init : val.

Definition defaultUnaryMaxRetries : go_string := "go.etcd.io/etcd/client/v3.defaultUnaryMaxRetries"%go.

Axiom defaultUnaryMaxRetries'init : val.

Definition defaultStreamMaxRetries : go_string := "go.etcd.io/etcd/client/v3.defaultStreamMaxRetries"%go.

Axiom defaultStreamMaxRetries'init : val.

Definition defaultBackoffWaitBetween : go_string := "go.etcd.io/etcd/client/v3.defaultBackoffWaitBetween"%go.

Axiom defaultBackoffWaitBetween'init : val.

Definition defaultBackoffJitterFraction : go_string := "go.etcd.io/etcd/client/v3.defaultBackoffJitterFraction"%go.

Axiom defaultBackoffJitterFraction'init : val.

Definition defaultCallOpts : go_string := "go.etcd.io/etcd/client/v3.defaultCallOpts"%go.

Axiom defaultCallOpts'init : val.

Definition isSafeRetryImmutableRPC : go_string := "go.etcd.io/etcd/client/v3.isSafeRetryImmutableRPC"%go.

Definition isSafeRetryMutableRPC : go_string := "go.etcd.io/etcd/client/v3.isSafeRetryMutableRPC"%go.

Definition RetryKVClient : go_string := "go.etcd.io/etcd/client/v3.RetryKVClient"%go.

Definition RetryLeaseClient : go_string := "go.etcd.io/etcd/client/v3.RetryLeaseClient"%go.

Definition RetryClusterClient : go_string := "go.etcd.io/etcd/client/v3.RetryClusterClient"%go.

Definition RetryMaintenanceClient : go_string := "go.etcd.io/etcd/client/v3.RetryMaintenanceClient"%go.

Definition RetryAuthClient : go_string := "go.etcd.io/etcd/client/v3.RetryAuthClient"%go.

Definition waitRetryBackoff : go_string := "go.etcd.io/etcd/client/v3.waitRetryBackoff"%go.

Definition isSafeRetry : go_string := "go.etcd.io/etcd/client/v3.isSafeRetry"%go.

Definition isContextError : go_string := "go.etcd.io/etcd/client/v3.isContextError"%go.

Definition contextErrToGRPCErr : go_string := "go.etcd.io/etcd/client/v3.contextErrToGRPCErr"%go.

Definition defaultOptions : go_string := "go.etcd.io/etcd/client/v3.defaultOptions"%go.

Axiom defaultOptions'init : val.

Definition withRepeatablePolicy : go_string := "go.etcd.io/etcd/client/v3.withRepeatablePolicy"%go.

Definition withMax : go_string := "go.etcd.io/etcd/client/v3.withMax"%go.

Definition withBackoff : go_string := "go.etcd.io/etcd/client/v3.withBackoff"%go.

Definition reuseOrNewWithCallOptions : go_string := "go.etcd.io/etcd/client/v3.reuseOrNewWithCallOptions"%go.

Definition filterCallOptions : go_string := "go.etcd.io/etcd/client/v3.filterCallOptions"%go.

Definition backoffLinearWithJitter : go_string := "go.etcd.io/etcd/client/v3.backoffLinearWithJitter"%go.

Definition SortByVersion : expr := #(W64 1).

Definition SortByValue : expr := #(W64 4).

Definition Txn : go_type := interfaceT.

Definition jitterUp : go_string := "go.etcd.io/etcd/client/v3.jitterUp"%go.

Definition EventTypeDelete : expr := #(W32 1).

Definition Event : go_type := mvccpb.Event.

Definition WatchResponse : go_type := structT [
  "Header" :: etcdserverpb.ResponseHeader;
  "Events" :: sliceT;
  "CompactRevision" :: int64T;
  "Canceled" :: boolT;
  "Created" :: boolT;
  "closeErr" :: error;
  "cancelReason" :: stringT
].

Definition WatchChan : go_type := chanT WatchResponse.

Definition Watcher : go_type := interfaceT.

Definition NewWatcher : go_string := "go.etcd.io/etcd/client/v3.NewWatcher"%go.

Definition NewWatchFromWatchClient : go_string := "go.etcd.io/etcd/client/v3.NewWatchFromWatchClient"%go.

Definition valCtxCh : go_string := "go.etcd.io/etcd/client/v3.valCtxCh"%go.

Axiom valCtxCh'init : val.

Definition zeroTime : go_string := "go.etcd.io/etcd/client/v3.zeroTime"%go.

Axiom zeroTime'init : val.

Definition maxBackoff : go_string := "go.etcd.io/etcd/client/v3.maxBackoff"%go.

Axiom maxBackoff'init : val.

Definition streamKeyFromCtx : go_string := "go.etcd.io/etcd/client/v3.streamKeyFromCtx"%go.

Definition vars' : list (go_string * go_type) := [].

Definition functions' : list (go_string * val) := [(WithZapLogger, WithZapLoggerⁱᵐᵖˡ); (OpGet, OpGetⁱᵐᵖˡ); (OpDelete, OpDeleteⁱᵐᵖˡ); (OpPut, OpPutⁱᵐᵖˡ); (OpTxn, OpTxnⁱᵐᵖˡ); (WithLease, WithLeaseⁱᵐᵖˡ); (WithLimit, WithLimitⁱᵐᵖˡ); (WithRev, WithRevⁱᵐᵖˡ); (WithSort, WithSortⁱᵐᵖˡ); (WithPrefix, WithPrefixⁱᵐᵖˡ); (WithRange, WithRangeⁱᵐᵖˡ); (WithFromKey, WithFromKeyⁱᵐᵖˡ); (WithSerializable, WithSerializableⁱᵐᵖˡ); (WithKeysOnly, WithKeysOnlyⁱᵐᵖˡ); (WithCountOnly, WithCountOnlyⁱᵐᵖˡ); (WithMinModRev, WithMinModRevⁱᵐᵖˡ); (WithMaxModRev, WithMaxModRevⁱᵐᵖˡ); (WithMinCreateRev, WithMinCreateRevⁱᵐᵖˡ); (WithMaxCreateRev, WithMaxCreateRevⁱᵐᵖˡ); (WithFirstCreate, WithFirstCreateⁱᵐᵖˡ); (WithLastCreate, WithLastCreateⁱᵐᵖˡ); (WithFirstKey, WithFirstKeyⁱᵐᵖˡ); (WithLastKey, WithLastKeyⁱᵐᵖˡ); (WithFirstRev, WithFirstRevⁱᵐᵖˡ); (WithLastRev, WithLastRevⁱᵐᵖˡ); (WithProgressNotify, WithProgressNotifyⁱᵐᵖˡ); (WithCreatedNotify, WithCreatedNotifyⁱᵐᵖˡ); (WithFilterPut, WithFilterPutⁱᵐᵖˡ); (WithFilterDelete, WithFilterDeleteⁱᵐᵖˡ); (WithPrevKV, WithPrevKVⁱᵐᵖˡ); (WithFragment, WithFragmentⁱᵐᵖˡ); (WithIgnoreValue, WithIgnoreValueⁱᵐᵖˡ); (WithIgnoreLease, WithIgnoreLeaseⁱᵐᵖˡ); (WithAttachedKeys, WithAttachedKeysⁱᵐᵖˡ)].

Definition msets' : list (go_string * (list (go_string * val))) := [(Client.id, []); (ptrT.id Client.id, []); (Cmp.id, []); (ptrT.id Cmp.id, []); (PutResponse.id, []); (ptrT.id PutResponse.id, []); (GetResponse.id, []); (ptrT.id GetResponse.id, []); (DeleteResponse.id, []); (ptrT.id DeleteResponse.id, []); (TxnResponse.id, []); (ptrT.id TxnResponse.id, []); (OpResponse.id, []); (ptrT.id OpResponse.id, []); (LeaseID.id, []); (ptrT.id LeaseID.id, []); (LeaseGrantResponse.id, []); (ptrT.id LeaseGrantResponse.id, []); (opType.id, []); (ptrT.id opType.id, []); (Op.id, [("IsCountOnly"%go, Op__IsCountOnlyⁱᵐᵖˡ); ("IsDelete"%go, Op__IsDeleteⁱᵐᵖˡ); ("IsGet"%go, Op__IsGetⁱᵐᵖˡ); ("IsKeysOnly"%go, Op__IsKeysOnlyⁱᵐᵖˡ); ("IsOptsWithFromKey"%go, Op__IsOptsWithFromKeyⁱᵐᵖˡ); ("IsOptsWithPrefix"%go, Op__IsOptsWithPrefixⁱᵐᵖˡ); ("IsPut"%go, Op__IsPutⁱᵐᵖˡ); ("IsSerializable"%go, Op__IsSerializableⁱᵐᵖˡ); ("IsSortOptionValid"%go, Op__IsSortOptionValidⁱᵐᵖˡ); ("IsTxn"%go, Op__IsTxnⁱᵐᵖˡ); ("KeyBytes"%go, Op__KeyBytesⁱᵐᵖˡ); ("MaxCreateRev"%go, Op__MaxCreateRevⁱᵐᵖˡ); ("MaxModRev"%go, Op__MaxModRevⁱᵐᵖˡ); ("MinCreateRev"%go, Op__MinCreateRevⁱᵐᵖˡ); ("MinModRev"%go, Op__MinModRevⁱᵐᵖˡ); ("RangeBytes"%go, Op__RangeBytesⁱᵐᵖˡ); ("Rev"%go, Op__Revⁱᵐᵖˡ); ("Txn"%go, Op__Txnⁱᵐᵖˡ); ("ValueBytes"%go, Op__ValueBytesⁱᵐᵖˡ); ("isWrite"%go, Op__isWriteⁱᵐᵖˡ); ("toRangeRequest"%go, Op__toRangeRequestⁱᵐᵖˡ); ("toRequestOp"%go, Op__toRequestOpⁱᵐᵖˡ); ("toTxnRequest"%go, Op__toTxnRequestⁱᵐᵖˡ)]); (ptrT.id Op.id, [("IsCountOnly"%go, (λ: "$recvAddr",
                 method_call #v3.clientv3 #"Op" #"IsCountOnly" (![#Op] "$recvAddr")
                 )%V); ("IsDelete"%go, (λ: "$recvAddr",
                 method_call #v3.clientv3 #"Op" #"IsDelete" (![#Op] "$recvAddr")
                 )%V); ("IsGet"%go, (λ: "$recvAddr",
                 method_call #v3.clientv3 #"Op" #"IsGet" (![#Op] "$recvAddr")
                 )%V); ("IsKeysOnly"%go, (λ: "$recvAddr",
                 method_call #v3.clientv3 #"Op" #"IsKeysOnly" (![#Op] "$recvAddr")
                 )%V); ("IsOptsWithFromKey"%go, (λ: "$recvAddr",
                 method_call #v3.clientv3 #"Op" #"IsOptsWithFromKey" (![#Op] "$recvAddr")
                 )%V); ("IsOptsWithPrefix"%go, (λ: "$recvAddr",
                 method_call #v3.clientv3 #"Op" #"IsOptsWithPrefix" (![#Op] "$recvAddr")
                 )%V); ("IsPut"%go, (λ: "$recvAddr",
                 method_call #v3.clientv3 #"Op" #"IsPut" (![#Op] "$recvAddr")
                 )%V); ("IsSerializable"%go, (λ: "$recvAddr",
                 method_call #v3.clientv3 #"Op" #"IsSerializable" (![#Op] "$recvAddr")
                 )%V); ("IsSortOptionValid"%go, (λ: "$recvAddr",
                 method_call #v3.clientv3 #"Op" #"IsSortOptionValid" (![#Op] "$recvAddr")
                 )%V); ("IsTxn"%go, (λ: "$recvAddr",
                 method_call #v3.clientv3 #"Op" #"IsTxn" (![#Op] "$recvAddr")
                 )%V); ("KeyBytes"%go, (λ: "$recvAddr",
                 method_call #v3.clientv3 #"Op" #"KeyBytes" (![#Op] "$recvAddr")
                 )%V); ("MaxCreateRev"%go, (λ: "$recvAddr",
                 method_call #v3.clientv3 #"Op" #"MaxCreateRev" (![#Op] "$recvAddr")
                 )%V); ("MaxModRev"%go, (λ: "$recvAddr",
                 method_call #v3.clientv3 #"Op" #"MaxModRev" (![#Op] "$recvAddr")
                 )%V); ("MinCreateRev"%go, (λ: "$recvAddr",
                 method_call #v3.clientv3 #"Op" #"MinCreateRev" (![#Op] "$recvAddr")
                 )%V); ("MinModRev"%go, (λ: "$recvAddr",
                 method_call #v3.clientv3 #"Op" #"MinModRev" (![#Op] "$recvAddr")
                 )%V); ("RangeBytes"%go, (λ: "$recvAddr",
                 method_call #v3.clientv3 #"Op" #"RangeBytes" (![#Op] "$recvAddr")
                 )%V); ("Rev"%go, (λ: "$recvAddr",
                 method_call #v3.clientv3 #"Op" #"Rev" (![#Op] "$recvAddr")
                 )%V); ("Txn"%go, (λ: "$recvAddr",
                 method_call #v3.clientv3 #"Op" #"Txn" (![#Op] "$recvAddr")
                 )%V); ("ValueBytes"%go, (λ: "$recvAddr",
                 method_call #v3.clientv3 #"Op" #"ValueBytes" (![#Op] "$recvAddr")
                 )%V); ("WithKeyBytes"%go, Op__WithKeyBytesⁱᵐᵖˡ); ("WithRangeBytes"%go, Op__WithRangeBytesⁱᵐᵖˡ); ("WithValueBytes"%go, Op__WithValueBytesⁱᵐᵖˡ); ("applyOpts"%go, Op__applyOptsⁱᵐᵖˡ); ("isWrite"%go, (λ: "$recvAddr",
                 method_call #v3.clientv3 #"Op" #"isWrite" (![#Op] "$recvAddr")
                 )%V); ("toRangeRequest"%go, (λ: "$recvAddr",
                 method_call #v3.clientv3 #"Op" #"toRangeRequest" (![#Op] "$recvAddr")
                 )%V); ("toRequestOp"%go, (λ: "$recvAddr",
                 method_call #v3.clientv3 #"Op" #"toRequestOp" (![#Op] "$recvAddr")
                 )%V); ("toTxnRequest"%go, (λ: "$recvAddr",
                 method_call #v3.clientv3 #"Op" #"toTxnRequest" (![#Op] "$recvAddr")
                 )%V)]); (OpOption.id, []); (ptrT.id OpOption.id, []); (LeaseOp.id, []); (ptrT.id LeaseOp.id, []); (LeaseOption.id, []); (ptrT.id LeaseOption.id, []); (SortTarget.id, []); (ptrT.id SortTarget.id, []); (SortOrder.id, []); (ptrT.id SortOrder.id, []); (SortOption.id, []); (ptrT.id SortOption.id, []); (Event.id, []); (ptrT.id Event.id, []); (WatchChan.id, []); (ptrT.id WatchChan.id, []); (WatchResponse.id, []); (ptrT.id WatchResponse.id, [])].

#[global] Instance info' : PkgInfo v3.clientv3 :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [etcdserverpb.etcdserverpb; mvccpb.mvccpb];
  |}.

Axiom _'init : val.

Definition initialize' : val :=
  λ: <>,
    package.init #v3.clientv3 (λ: <>,
      exception_do (do:  (mvccpb.initialize' #());;;
      do:  (etcdserverpb.initialize' #());;;
      do:  (package.alloc v3.clientv3 #());;;
      do:  (ErrNoAvailableEndpoints'init #());;;
      do:  (ErrOldCluster'init #());;;
      do:  (LeaseResponseChSize'init #());;;
      do:  (noPrefixEnd'init #());;;
      do:  (defaultWaitForReady'init #());;;
      do:  (defaultMaxCallSendMsgSize'init #());;;
      do:  (defaultMaxCallRecvMsgSize'init #());;;
      do:  (defaultUnaryMaxRetries'init #());;;
      do:  (defaultStreamMaxRetries'init #());;;
      do:  (defaultBackoffWaitBetween'init #());;;
      do:  (defaultBackoffJitterFraction'init #());;;
      do:  (defaultCallOpts'init #());;;
      do:  (defaultOptions'init #());;;
      do:  (valCtxCh'init #());;;
      do:  (zeroTime'init #());;;
      do:  (maxBackoff'init #()))
      ).

End code.
End clientv3.
