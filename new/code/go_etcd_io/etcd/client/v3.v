(* autogenerated from go.etcd.io/etcd/client/v3 *)
Require Export New.code.context.
Require Export New.code.go_etcd_io.etcd.api.v3.etcdserverpb.
Require Export New.code.go_uber_org.zap.
Require Export New.code.go_etcd_io.etcd.api.v3.mvccpb.
From New.golang Require Import defn.
Module pkg_id.
Definition clientv3 : go_string := "go.etcd.io/etcd/client/v3".

End pkg_id.
Export pkg_id.
Module clientv3.

Definition AuthEnableResponse {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.AuthEnableResponse"%go [].

Definition AuthDisableResponse {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.AuthDisableResponse"%go [].

Definition AuthStatusResponse {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.AuthStatusResponse"%go [].

Definition AuthenticateResponse {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.AuthenticateResponse"%go [].

Definition AuthUserAddResponse {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.AuthUserAddResponse"%go [].

Definition AuthUserDeleteResponse {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.AuthUserDeleteResponse"%go [].

Definition AuthUserChangePasswordResponse {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.AuthUserChangePasswordResponse"%go [].

Definition AuthUserGrantRoleResponse {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.AuthUserGrantRoleResponse"%go [].

Definition AuthUserGetResponse {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.AuthUserGetResponse"%go [].

Definition AuthUserRevokeRoleResponse {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.AuthUserRevokeRoleResponse"%go [].

Definition AuthRoleAddResponse {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.AuthRoleAddResponse"%go [].

Definition AuthRoleGrantPermissionResponse {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.AuthRoleGrantPermissionResponse"%go [].

Definition AuthRoleGetResponse {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.AuthRoleGetResponse"%go [].

Definition AuthRoleRevokePermissionResponse {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.AuthRoleRevokePermissionResponse"%go [].

Definition AuthRoleDeleteResponse {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.AuthRoleDeleteResponse"%go [].

Definition AuthUserListResponse {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.AuthUserListResponse"%go [].

Definition AuthRoleListResponse {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.AuthRoleListResponse"%go [].

Definition PermissionType {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.PermissionType"%go [].

Definition Permission {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.Permission"%go [].

Definition UserAddOptions {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.UserAddOptions"%go [].

Definition Auth {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.Auth"%go [].

Definition authClient {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.authClient"%go [].

Definition Client {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.Client"%go [].

Definition Option {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.Option"%go [].

Definition Member {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.Member"%go [].

Definition MemberListResponse {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.MemberListResponse"%go [].

Definition MemberAddResponse {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.MemberAddResponse"%go [].

Definition MemberRemoveResponse {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.MemberRemoveResponse"%go [].

Definition MemberUpdateResponse {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.MemberUpdateResponse"%go [].

Definition MemberPromoteResponse {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.MemberPromoteResponse"%go [].

Definition Cluster {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.Cluster"%go [].

Definition cluster {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.cluster"%go [].

Definition CompactOp {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.CompactOp"%go [].

Definition CompactOption {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.CompactOption"%go [].

Definition CompareTarget {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.CompareTarget"%go [].

Definition CompareResult {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.CompareResult"%go [].

Definition Cmp {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.Cmp"%go [].

Definition Config {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.Config"%go [].

Definition ConfigSpec {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.ConfigSpec"%go [].

Definition SecureConfig {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.SecureConfig"%go [].

Definition AuthConfig {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.AuthConfig"%go [].

Definition CompactResponse {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.CompactResponse"%go [].

Definition PutResponse {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.PutResponse"%go [].

Definition GetResponse {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.GetResponse"%go [].

Definition DeleteResponse {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.DeleteResponse"%go [].

Definition TxnResponse {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.TxnResponse"%go [].

Definition KV {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.KV"%go [].

Definition OpResponse {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.OpResponse"%go [].

Definition kv {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.kv"%go [].

Definition LeaseRevokeResponse {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.LeaseRevokeResponse"%go [].

Definition LeaseID {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.LeaseID"%go [].

Definition LeaseGrantResponse {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.LeaseGrantResponse"%go [].

Definition LeaseKeepAliveResponse {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.LeaseKeepAliveResponse"%go [].

Definition LeaseTimeToLiveResponse {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.LeaseTimeToLiveResponse"%go [].

Definition LeaseStatus {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.LeaseStatus"%go [].

Definition LeaseLeasesResponse {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.LeaseLeasesResponse"%go [].

Definition ErrKeepAliveHalted {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.ErrKeepAliveHalted"%go [].

Definition Lease {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.Lease"%go [].

Definition lessor {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.lessor"%go [].

Definition keepAlive {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.keepAlive"%go [].

Definition keepAliveCtxKey {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.keepAliveCtxKey"%go [].

Definition DefragmentResponse {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.DefragmentResponse"%go [].

Definition AlarmResponse {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.AlarmResponse"%go [].

Definition AlarmMember {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.AlarmMember"%go [].

Definition StatusResponse {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.StatusResponse"%go [].

Definition HashKVResponse {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.HashKVResponse"%go [].

Definition MoveLeaderResponse {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.MoveLeaderResponse"%go [].

Definition DowngradeResponse {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.DowngradeResponse"%go [].

Definition DowngradeAction {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.DowngradeAction"%go [].

Definition Maintenance {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.Maintenance"%go [].

Definition SnapshotResponse {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.SnapshotResponse"%go [].

Definition maintenance {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.maintenance"%go [].

Definition snapshotReadCloser {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.snapshotReadCloser"%go [].

Definition opType {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.opType"%go [].

Definition Op {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.Op"%go [].

Definition OpOption {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.OpOption"%go [].

Definition LeaseOp {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.LeaseOp"%go [].

Definition LeaseOption {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.LeaseOption"%go [].

Definition retryPolicy {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.retryPolicy"%go [].

Definition retryKVClient {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.retryKVClient"%go [].

Definition retryLeaseClient {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.retryLeaseClient"%go [].

Definition retryClusterClient {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.retryClusterClient"%go [].

Definition retryMaintenanceClient {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.retryMaintenanceClient"%go [].

Definition retryAuthClient {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.retryAuthClient"%go [].

Definition serverStreamingRetryingStream {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.serverStreamingRetryingStream"%go [].

Definition backoffFunc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.backoffFunc"%go [].

Definition options {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.options"%go [].

Definition retryOption {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.retryOption"%go [].

Definition SortTarget {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.SortTarget"%go [].

Definition SortOrder {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.SortOrder"%go [].

Definition SortOption {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.SortOption"%go [].

Definition Txn {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.Txn"%go [].

Definition txn {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.txn"%go [].

Definition Event {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.Event"%go [].

Definition WatchChan {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.WatchChan"%go [].

Definition Watcher {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.Watcher"%go [].

Definition WatchResponse {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.WatchResponse"%go [].

Definition watcher {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.watcher"%go [].

Definition watchGRPCStream {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.watchGRPCStream"%go [].

Definition watchStreamRequest {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.watchStreamRequest"%go [].

Definition watchRequest {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.watchRequest"%go [].

Definition progressRequest {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.progressRequest"%go [].

Definition watcherStream {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.watcherStream"%go [].

Definition valCtx {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3.valCtx"%go [].

Axiom AuthEnableResponseⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom AuthDisableResponseⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom AuthStatusResponseⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom AuthenticateResponseⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom AuthUserAddResponseⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom AuthUserDeleteResponseⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom AuthUserChangePasswordResponseⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom AuthUserGrantRoleResponseⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom AuthUserGetResponseⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom AuthUserRevokeRoleResponseⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom AuthRoleAddResponseⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom AuthRoleGrantPermissionResponseⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom AuthRoleGetResponseⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom AuthRoleRevokePermissionResponseⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom AuthRoleDeleteResponseⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom AuthUserListResponseⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom AuthRoleListResponseⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom PermissionTypeⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom Permissionⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom UserAddOptionsⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom Authⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom authClientⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom Clientⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom Optionⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom Memberⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom MemberListResponseⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom MemberAddResponseⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom MemberRemoveResponseⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom MemberUpdateResponseⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom MemberPromoteResponseⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom clusterⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom CompactOpⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom CompactOptionⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom CompareTargetⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom CompareResultⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom Configⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom ConfigSpecⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom SecureConfigⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom AuthConfigⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom CompactResponseⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom kvⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom LeaseRevokeResponseⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom LeaseKeepAliveResponseⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom LeaseTimeToLiveResponseⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom LeaseStatusⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom LeaseLeasesResponseⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom ErrKeepAliveHaltedⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom lessorⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom keepAliveⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom keepAliveCtxKeyⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom DefragmentResponseⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom AlarmResponseⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom AlarmMemberⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom StatusResponseⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom HashKVResponseⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom MoveLeaderResponseⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom DowngradeResponseⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom DowngradeActionⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom Maintenanceⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom SnapshotResponseⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom maintenanceⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom snapshotReadCloserⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom retryPolicyⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom retryKVClientⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom retryLeaseClientⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom retryClusterClientⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom retryMaintenanceClientⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom retryAuthClientⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom serverStreamingRetryingStreamⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom backoffFuncⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom optionsⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom retryOptionⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom txnⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom watcherⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom watchGRPCStreamⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom watchStreamRequestⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom watchRequestⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom progressRequestⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom watcherStreamⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom valCtxⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom PermRead : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom PermWrite : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom PermReadWrite : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom CompareVersion : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom CompareCreated : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom CompareModified : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom CompareValue : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom defaultTTL : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition NoLease {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 0).

Axiom retryConnWait : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom DowngradeValidate : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom DowngradeEnable : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom DowngradeCancel : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition tRange {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 1).

Definition tPut {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 2).

Definition tDeleteRange {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 3).

Definition tTxn {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 4).

Axiom MaxLeaseTTL : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom repeatable : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom nonRepeatable : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition SortNone {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 0).

Definition SortAscend {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 1).

Definition SortDescend {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 2).

Definition SortByKey {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 0).

Definition SortByVersion {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 1).

Definition SortByCreateRevision {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 2).

Definition SortByModRevision {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 3).

Definition SortByValue {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 4).

Definition EventTypeDelete {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W32 1).

Axiom EventTypePut : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom closeSendErrTimeout : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom AutoWatchID : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom InvalidWatchID : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition ErrNoAvailableEndpoints {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.ErrNoAvailableEndpoints"%go.

Axiom ErrNoAvailableEndpoints'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition ErrOldCluster {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.ErrOldCluster"%go.

Axiom ErrOldCluster'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition LeaseResponseChSize {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.LeaseResponseChSize"%go.

Axiom LeaseResponseChSize'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition noPrefixEnd {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.noPrefixEnd"%go.

Axiom noPrefixEnd'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition defaultWaitForReady {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.defaultWaitForReady"%go.

Axiom defaultWaitForReady'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition defaultMaxCallSendMsgSize {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.defaultMaxCallSendMsgSize"%go.

Axiom defaultMaxCallSendMsgSize'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition defaultMaxCallRecvMsgSize {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.defaultMaxCallRecvMsgSize"%go.

Axiom defaultMaxCallRecvMsgSize'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition defaultUnaryMaxRetries {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.defaultUnaryMaxRetries"%go.

Axiom defaultUnaryMaxRetries'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition defaultStreamMaxRetries {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.defaultStreamMaxRetries"%go.

Axiom defaultStreamMaxRetries'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition defaultBackoffWaitBetween {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.defaultBackoffWaitBetween"%go.

Axiom defaultBackoffWaitBetween'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition defaultBackoffJitterFraction {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.defaultBackoffJitterFraction"%go.

Axiom defaultBackoffJitterFraction'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition defaultCallOpts {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.defaultCallOpts"%go.

Axiom defaultCallOpts'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition defaultOptions {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.defaultOptions"%go.

Axiom defaultOptions'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition valCtxCh {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.valCtxCh"%go.

Axiom valCtxCh'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition zeroTime {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.zeroTime"%go.

Axiom zeroTime'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition maxBackoff {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.maxBackoff"%go.

Axiom maxBackoff'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition NewAuth {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.NewAuth"%go.

Definition NewAuthFromAuthClient {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.NewAuthFromAuthClient"%go.

Definition StrToPermissionType {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.StrToPermissionType"%go.

Definition New {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.New"%go.

Definition NewCtxClient {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.NewCtxClient"%go.

Definition NewFromURL {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.NewFromURL"%go.

Definition NewFromURLs {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.NewFromURLs"%go.

Definition WithZapLogger {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.WithZapLogger"%go.

Definition authority {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.authority"%go.

Definition newClient {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.newClient"%go.

Definition minSupportedVersion {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.minSupportedVersion"%go.

Definition isHaltErr {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.isHaltErr"%go.

Definition isUnavailableErr {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.isUnavailableErr"%go.

Definition ContextError {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.ContextError"%go.

Definition canceledByCaller {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.canceledByCaller"%go.

Definition IsConnCanceled {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.IsConnCanceled"%go.

Definition NewCluster {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.NewCluster"%go.

Definition NewClusterFromClusterClient {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.NewClusterFromClusterClient"%go.

Definition OpCompact {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.OpCompact"%go.

Definition WithCompactPhysical {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.WithCompactPhysical"%go.

Definition Compare {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.Compare"%go.

Definition Value {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.Value"%go.

Definition Version {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.Version"%go.

Definition CreateRevision {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.CreateRevision"%go.

Definition ModRevision {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.ModRevision"%go.

Definition LeaseValue {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.LeaseValue"%go.

Definition mustInt64 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.mustInt64"%go.

Definition mustInt64orLeaseID {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.mustInt64orLeaseID"%go.

Definition NewClientConfig {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.NewClientConfig"%go.

Definition newTLSConfig {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.newTLSConfig"%go.

Definition WithRequireLeader {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.WithRequireLeader"%go.

Definition withVersion {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.withVersion"%go.

Definition NewKV {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.NewKV"%go.

Definition NewKVFromKVClient {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.NewKVFromKVClient"%go.

Definition NewLease {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.NewLease"%go.

Definition NewLeaseFromLeaseClient {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.NewLeaseFromLeaseClient"%go.

Definition SetLogger {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.SetLogger"%go.

Definition etcdClientDebugLevel {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.etcdClientDebugLevel"%go.

Definition NewMaintenance {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.NewMaintenance"%go.

Definition NewMaintenanceFromMaintenanceClient {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.NewMaintenanceFromMaintenanceClient"%go.

Definition NewOp {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.NewOp"%go.

Definition OpGet {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.OpGet"%go.

Definition OpDelete {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.OpDelete"%go.

Definition OpPut {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.OpPut"%go.

Definition OpTxn {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.OpTxn"%go.

Definition opWatch {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.opWatch"%go.

Definition WithLease {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.WithLease"%go.

Definition WithLimit {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.WithLimit"%go.

Definition WithRev {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.WithRev"%go.

Definition WithSort {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.WithSort"%go.

Definition GetPrefixRangeEnd {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.GetPrefixRangeEnd"%go.

Definition getPrefix {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.getPrefix"%go.

Definition WithPrefix {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.WithPrefix"%go.

Definition WithRange {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.WithRange"%go.

Definition WithFromKey {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.WithFromKey"%go.

Definition WithSerializable {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.WithSerializable"%go.

Definition WithKeysOnly {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.WithKeysOnly"%go.

Definition WithCountOnly {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.WithCountOnly"%go.

Definition WithMinModRev {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.WithMinModRev"%go.

Definition WithMaxModRev {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.WithMaxModRev"%go.

Definition WithMinCreateRev {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.WithMinCreateRev"%go.

Definition WithMaxCreateRev {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.WithMaxCreateRev"%go.

Definition WithFirstCreate {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.WithFirstCreate"%go.

Definition WithLastCreate {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.WithLastCreate"%go.

Definition WithFirstKey {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.WithFirstKey"%go.

Definition WithLastKey {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.WithLastKey"%go.

Definition WithFirstRev {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.WithFirstRev"%go.

Definition WithLastRev {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.WithLastRev"%go.

Definition withTop {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.withTop"%go.

Definition WithProgressNotify {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.WithProgressNotify"%go.

Definition WithCreatedNotify {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.WithCreatedNotify"%go.

Definition WithFilterPut {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.WithFilterPut"%go.

Definition WithFilterDelete {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.WithFilterDelete"%go.

Definition WithPrevKV {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.WithPrevKV"%go.

Definition WithFragment {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.WithFragment"%go.

Definition WithIgnoreValue {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.WithIgnoreValue"%go.

Definition WithIgnoreLease {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.WithIgnoreLease"%go.

Definition WithAttachedKeys {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.WithAttachedKeys"%go.

Definition toLeaseTimeToLiveRequest {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.toLeaseTimeToLiveRequest"%go.

Definition IsOptsWithPrefix {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.IsOptsWithPrefix"%go.

Definition IsOptsWithFromKey {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.IsOptsWithFromKey"%go.

Definition isSafeRetryImmutableRPC {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.isSafeRetryImmutableRPC"%go.

Definition isSafeRetryMutableRPC {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.isSafeRetryMutableRPC"%go.

Definition RetryKVClient {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.RetryKVClient"%go.

Definition RetryLeaseClient {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.RetryLeaseClient"%go.

Definition RetryClusterClient {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.RetryClusterClient"%go.

Definition RetryMaintenanceClient {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.RetryMaintenanceClient"%go.

Definition RetryAuthClient {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.RetryAuthClient"%go.

Definition waitRetryBackoff {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.waitRetryBackoff"%go.

Definition isSafeRetry {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.isSafeRetry"%go.

Definition isContextError {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.isContextError"%go.

Definition contextErrToGRPCErr {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.contextErrToGRPCErr"%go.

Definition withRepeatablePolicy {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.withRepeatablePolicy"%go.

Definition withMax {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.withMax"%go.

Definition withBackoff {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.withBackoff"%go.

Definition reuseOrNewWithCallOptions {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.reuseOrNewWithCallOptions"%go.

Definition filterCallOptions {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.filterCallOptions"%go.

Definition backoffLinearWithJitter {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.backoffLinearWithJitter"%go.

Definition jitterUp {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.jitterUp"%go.

Definition NewWatcher {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.NewWatcher"%go.

Definition NewWatchFromWatchClient {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.NewWatchFromWatchClient"%go.

Definition streamKeyFromCtx {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3.streamKeyFromCtx"%go.

(* WithZapLogger is a NewCtxClient option that overrides the logger

   go: client.go:119:6 *)
Definition WithZapLoggerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "lg",
    exception_do (let: "lg" := (GoAlloc (go.PointerType zap.Logger) "lg") in
    return: ((λ: "c",
       exception_do (let: "c" := (GoAlloc (go.PointerType Client) "c") in
       let: "$r0" := (![go.PointerType zap.Logger] "lg") in
       do:  ((StructFieldRef Client "lg"%go (![go.PointerType Client] "c")) <-[go.PointerType zap.Logger] "$r0");;;
       return: #())
       ))).

(* IsTxn returns true if the "Op" type is transaction.

   go: op.go:88:14 *)
Definition Op__IsTxnⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "op" <>,
    exception_do (let: "op" := (GoAlloc Op "op") in
    return: ((![opType] (StructFieldRef Op "t"%go "op")) =⟨go.int⟩ tTxn)).

(* Txn returns the comparison(if) operations, "then" operations, and "else" operations.

   go: op.go:93:14 *)
Definition Op__Txnⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "op" <>,
    exception_do (let: "op" := (GoAlloc Op "op") in
    return: (![go.SliceType Cmp] (StructFieldRef Op "cmps"%go "op"), ![go.SliceType Op] (StructFieldRef Op "thenOps"%go "op"), ![go.SliceType Op] (StructFieldRef Op "elseOps"%go "op"))).

(* KeyBytes returns the byte slice holding the Op's key.

   go: op.go:98:14 *)
Definition Op__KeyBytesⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "op" <>,
    exception_do (let: "op" := (GoAlloc Op "op") in
    return: (![go.SliceType go.byte] (StructFieldRef Op "key"%go "op"))).

(* WithKeyBytes sets the byte slice for the Op's key.

   go: op.go:101:15 *)
Definition Op__WithKeyBytesⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "op" "key",
    exception_do (let: "op" := (GoAlloc (go.PointerType Op) "op") in
    let: "key" := (GoAlloc (go.SliceType go.byte) "key") in
    let: "$r0" := (![go.SliceType go.byte] "key") in
    do:  ((StructFieldRef Op "key"%go (![go.PointerType Op] "op")) <-[go.SliceType go.byte] "$r0");;;
    return: #()).

(* RangeBytes returns the byte slice holding with the Op's range end, if any.

   go: op.go:104:14 *)
Definition Op__RangeBytesⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "op" <>,
    exception_do (let: "op" := (GoAlloc Op "op") in
    return: (![go.SliceType go.byte] (StructFieldRef Op "end"%go "op"))).

(* Rev returns the requested revision, if any.

   go: op.go:107:14 *)
Definition Op__Revⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "op" <>,
    exception_do (let: "op" := (GoAlloc Op "op") in
    return: (![go.int64] (StructFieldRef Op "rev"%go "op"))).

(* IsPut returns true iff the operation is a Put.

   go: op.go:110:14 *)
Definition Op__IsPutⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "op" <>,
    exception_do (let: "op" := (GoAlloc Op "op") in
    return: ((![opType] (StructFieldRef Op "t"%go "op")) =⟨go.int⟩ tPut)).

(* IsGet returns true iff the operation is a Get.

   go: op.go:113:14 *)
Definition Op__IsGetⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "op" <>,
    exception_do (let: "op" := (GoAlloc Op "op") in
    return: ((![opType] (StructFieldRef Op "t"%go "op")) =⟨go.int⟩ tRange)).

(* IsDelete returns true iff the operation is a Delete.

   go: op.go:116:14 *)
Definition Op__IsDeleteⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "op" <>,
    exception_do (let: "op" := (GoAlloc Op "op") in
    return: ((![opType] (StructFieldRef Op "t"%go "op")) =⟨go.int⟩ tDeleteRange)).

(* IsSerializable returns true if the serializable field is true.

   go: op.go:119:14 *)
Definition Op__IsSerializableⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "op" <>,
    exception_do (let: "op" := (GoAlloc Op "op") in
    return: (![go.bool] (StructFieldRef Op "serializable"%go "op"))).

(* IsKeysOnly returns whether keysOnly is set.

   go: op.go:122:14 *)
Definition Op__IsKeysOnlyⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "op" <>,
    exception_do (let: "op" := (GoAlloc Op "op") in
    return: (![go.bool] (StructFieldRef Op "keysOnly"%go "op"))).

(* IsCountOnly returns whether countOnly is set.

   go: op.go:125:14 *)
Definition Op__IsCountOnlyⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "op" <>,
    exception_do (let: "op" := (GoAlloc Op "op") in
    return: (![go.bool] (StructFieldRef Op "countOnly"%go "op"))).

(* go: op.go:127:14 *)
Definition Op__IsOptsWithFromKeyⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "op" <>,
    exception_do (let: "op" := (GoAlloc Op "op") in
    return: (![go.bool] (StructFieldRef Op "isOptsWithFromKey"%go "op"))).

(* go: op.go:129:14 *)
Definition Op__IsOptsWithPrefixⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "op" <>,
    exception_do (let: "op" := (GoAlloc Op "op") in
    return: (![go.bool] (StructFieldRef Op "isOptsWithPrefix"%go "op"))).

(* MinModRev returns the operation's minimum modify revision.

   go: op.go:132:14 *)
Definition Op__MinModRevⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "op" <>,
    exception_do (let: "op" := (GoAlloc Op "op") in
    return: (![go.int64] (StructFieldRef Op "minModRev"%go "op"))).

(* MaxModRev returns the operation's maximum modify revision.

   go: op.go:135:14 *)
Definition Op__MaxModRevⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "op" <>,
    exception_do (let: "op" := (GoAlloc Op "op") in
    return: (![go.int64] (StructFieldRef Op "maxModRev"%go "op"))).

(* MinCreateRev returns the operation's minimum create revision.

   go: op.go:138:14 *)
Definition Op__MinCreateRevⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "op" <>,
    exception_do (let: "op" := (GoAlloc Op "op") in
    return: (![go.int64] (StructFieldRef Op "minCreateRev"%go "op"))).

(* MaxCreateRev returns the operation's maximum create revision.

   go: op.go:141:14 *)
Definition Op__MaxCreateRevⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "op" <>,
    exception_do (let: "op" := (GoAlloc Op "op") in
    return: (![go.int64] (StructFieldRef Op "maxCreateRev"%go "op"))).

(* WithRangeBytes sets the byte slice for the Op's range end.

   go: op.go:144:15 *)
Definition Op__WithRangeBytesⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "op" "end",
    exception_do (let: "op" := (GoAlloc (go.PointerType Op) "op") in
    let: "end" := (GoAlloc (go.SliceType go.byte) "end") in
    let: "$r0" := (![go.SliceType go.byte] "end") in
    do:  ((StructFieldRef Op "end"%go (![go.PointerType Op] "op")) <-[go.SliceType go.byte] "$r0");;;
    return: #()).

(* ValueBytes returns the byte slice holding the Op's value, if any.

   go: op.go:147:14 *)
Definition Op__ValueBytesⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "op" <>,
    exception_do (let: "op" := (GoAlloc Op "op") in
    return: (![go.SliceType go.byte] (StructFieldRef Op "val"%go "op"))).

(* WithValueBytes sets the byte slice for the Op's value.

   go: op.go:150:15 *)
Definition Op__WithValueBytesⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "op" "v",
    exception_do (let: "op" := (GoAlloc (go.PointerType Op) "op") in
    let: "v" := (GoAlloc (go.SliceType go.byte) "v") in
    let: "$r0" := (![go.SliceType go.byte] "v") in
    do:  ((StructFieldRef Op "val"%go (![go.PointerType Op] "op")) <-[go.SliceType go.byte] "$r0");;;
    return: #()).

(* go: op.go:152:14 *)
Definition Op__toRangeRequestⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "op" <>,
    exception_do (let: "op" := (GoAlloc Op "op") in
    (if: Convert go.untyped_bool go.bool ((![opType] (StructFieldRef Op "t"%go "op")) ≠⟨go.int⟩ tRange)
    then
      do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"op.t != tRange"%go) in
      (FuncResolve go.panic [] #()) "$a0")
    else do:  #());;;
    let: "r" := (GoAlloc (go.PointerType etcdserverpb.RangeRequest) (GoZeroVal (go.PointerType etcdserverpb.RangeRequest) #())) in
    let: "$r0" := (GoAlloc etcdserverpb.RangeRequest (CompositeLiteral etcdserverpb.RangeRequest (LiteralValue [KeyedElement (Some (KeyField "Key"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] (StructFieldRef Op "key"%go "op"))); KeyedElement (Some (KeyField "RangeEnd"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] (StructFieldRef Op "end"%go "op"))); KeyedElement (Some (KeyField "Limit"%go)) (ElementExpression go.int64 (![go.int64] (StructFieldRef Op "limit"%go "op"))); KeyedElement (Some (KeyField "Revision"%go)) (ElementExpression go.int64 (![go.int64] (StructFieldRef Op "rev"%go "op"))); KeyedElement (Some (KeyField "Serializable"%go)) (ElementExpression go.bool (![go.bool] (StructFieldRef Op "serializable"%go "op"))); KeyedElement (Some (KeyField "KeysOnly"%go)) (ElementExpression go.bool (![go.bool] (StructFieldRef Op "keysOnly"%go "op"))); KeyedElement (Some (KeyField "CountOnly"%go)) (ElementExpression go.bool (![go.bool] (StructFieldRef Op "countOnly"%go "op"))); KeyedElement (Some (KeyField "MinModRevision"%go)) (ElementExpression go.int64 (![go.int64] (StructFieldRef Op "minModRev"%go "op"))); KeyedElement (Some (KeyField "MaxModRevision"%go)) (ElementExpression go.int64 (![go.int64] (StructFieldRef Op "maxModRev"%go "op"))); KeyedElement (Some (KeyField "MinCreateRevision"%go)) (ElementExpression go.int64 (![go.int64] (StructFieldRef Op "minCreateRev"%go "op"))); KeyedElement (Some (KeyField "MaxCreateRevision"%go)) (ElementExpression go.int64 (![go.int64] (StructFieldRef Op "maxCreateRev"%go "op")))]))) in
    do:  ("r" <-[go.PointerType etcdserverpb.RangeRequest] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.PointerType SortOption] (StructFieldRef Op "sort"%go "op")) ≠⟨go.PointerType SortOption⟩ (Convert go.untyped_nil (go.PointerType SortOption) UntypedNil))
    then
      let: "$r0" := (Convert SortOrder etcdserverpb.RangeRequest_SortOrder (![SortOrder] (StructFieldRef SortOption "Order"%go (![go.PointerType SortOption] (StructFieldRef Op "sort"%go "op"))))) in
      do:  ((StructFieldRef etcdserverpb.RangeRequest "SortOrder"%go (![go.PointerType etcdserverpb.RangeRequest] "r")) <-[etcdserverpb.RangeRequest_SortOrder] "$r0");;;
      let: "$r0" := (Convert SortTarget etcdserverpb.RangeRequest_SortTarget (![SortTarget] (StructFieldRef SortOption "Target"%go (![go.PointerType SortOption] (StructFieldRef Op "sort"%go "op"))))) in
      do:  ((StructFieldRef etcdserverpb.RangeRequest "SortTarget"%go (![go.PointerType etcdserverpb.RangeRequest] "r")) <-[etcdserverpb.RangeRequest_SortTarget] "$r0")
    else do:  #());;;
    return: (![go.PointerType etcdserverpb.RangeRequest] "r")).

(* go: op.go:176:14 *)
Definition Op__toTxnRequestⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "op" <>,
    exception_do (let: "op" := (GoAlloc Op "op") in
    let: "thenOps" := (GoAlloc (go.SliceType (go.PointerType etcdserverpb.RequestOp)) (GoZeroVal (go.SliceType (go.PointerType etcdserverpb.RequestOp)) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType (go.PointerType etcdserverpb.RequestOp)] #()) (let: "$a0" := (![go.SliceType Op] (StructFieldRef Op "thenOps"%go "op")) in
    (FuncResolve go.len [go.SliceType Op] #()) "$a0")) in
    do:  ("thenOps" <-[go.SliceType (go.PointerType etcdserverpb.RequestOp)] "$r0");;;
    let: "$range" := (![go.SliceType Op] (StructFieldRef Op "thenOps"%go "op")) in
    (let: "tOp" := (GoAlloc Op (GoZeroVal Op #())) in
    let: "i" := (GoAlloc go.int (GoZeroVal go.int #())) in
    slice.for_range Op "$range" (λ: "$key" "$value",
      do:  ("tOp" <-[Op] "$value");;;
      do:  ("i" <-[go.int] "$key");;;
      let: "$r0" := ((MethodResolve Op "toRequestOp"%go (![Op] "tOp")) #()) in
      do:  ((IndexRef (go.SliceType (go.PointerType etcdserverpb.RequestOp)) (![go.SliceType (go.PointerType etcdserverpb.RequestOp)] "thenOps", ![go.int] "i")) <-[go.PointerType etcdserverpb.RequestOp] "$r0")));;;
    let: "elseOps" := (GoAlloc (go.SliceType (go.PointerType etcdserverpb.RequestOp)) (GoZeroVal (go.SliceType (go.PointerType etcdserverpb.RequestOp)) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType (go.PointerType etcdserverpb.RequestOp)] #()) (let: "$a0" := (![go.SliceType Op] (StructFieldRef Op "elseOps"%go "op")) in
    (FuncResolve go.len [go.SliceType Op] #()) "$a0")) in
    do:  ("elseOps" <-[go.SliceType (go.PointerType etcdserverpb.RequestOp)] "$r0");;;
    let: "$range" := (![go.SliceType Op] (StructFieldRef Op "elseOps"%go "op")) in
    (let: "eOp" := (GoAlloc Op (GoZeroVal Op #())) in
    let: "i" := (GoAlloc go.int (GoZeroVal go.int #())) in
    slice.for_range Op "$range" (λ: "$key" "$value",
      do:  ("eOp" <-[Op] "$value");;;
      do:  ("i" <-[go.int] "$key");;;
      let: "$r0" := ((MethodResolve Op "toRequestOp"%go (![Op] "eOp")) #()) in
      do:  ((IndexRef (go.SliceType (go.PointerType etcdserverpb.RequestOp)) (![go.SliceType (go.PointerType etcdserverpb.RequestOp)] "elseOps", ![go.int] "i")) <-[go.PointerType etcdserverpb.RequestOp] "$r0")));;;
    let: "cmps" := (GoAlloc (go.SliceType (go.PointerType etcdserverpb.Compare)) (GoZeroVal (go.SliceType (go.PointerType etcdserverpb.Compare)) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType (go.PointerType etcdserverpb.Compare)] #()) (let: "$a0" := (![go.SliceType Cmp] (StructFieldRef Op "cmps"%go "op")) in
    (FuncResolve go.len [go.SliceType Cmp] #()) "$a0")) in
    do:  ("cmps" <-[go.SliceType (go.PointerType etcdserverpb.Compare)] "$r0");;;
    let: "$range" := (![go.SliceType Cmp] (StructFieldRef Op "cmps"%go "op")) in
    (let: "i" := (GoAlloc go.int (GoZeroVal go.int #())) in
    slice.for_range Cmp "$range" (λ: "$key" "$value",
      do:  ("i" <-[go.int] "$key");;;
      let: "$r0" := (Convert (go.PointerType Cmp) (go.PointerType etcdserverpb.Compare) (IndexRef Cmp (![go.SliceType Cmp] (StructFieldRef Op "cmps"%go "op"), ![go.int] "i"))) in
      do:  ((IndexRef (go.SliceType (go.PointerType etcdserverpb.Compare)) (![go.SliceType (go.PointerType etcdserverpb.Compare)] "cmps", ![go.int] "i")) <-[go.PointerType etcdserverpb.Compare] "$r0")));;;
    return: (GoAlloc etcdserverpb.TxnRequest (CompositeLiteral etcdserverpb.TxnRequest (LiteralValue [KeyedElement (Some (KeyField "Compare"%go)) (ElementExpression (go.SliceType (go.PointerType etcdserverpb.Compare)) (![go.SliceType (go.PointerType etcdserverpb.Compare)] "cmps")); KeyedElement (Some (KeyField "Success"%go)) (ElementExpression (go.SliceType (go.PointerType etcdserverpb.RequestOp)) (![go.SliceType (go.PointerType etcdserverpb.RequestOp)] "thenOps")); KeyedElement (Some (KeyField "Failure"%go)) (ElementExpression (go.SliceType (go.PointerType etcdserverpb.RequestOp)) (![go.SliceType (go.PointerType etcdserverpb.RequestOp)] "elseOps"))])))).

(* go: op.go:192:14 *)
Definition Op__toRequestOpⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "op" <>,
    exception_do (let: "op" := (GoAlloc Op "op") in
    let: "$sw" := (![opType] (StructFieldRef Op "t"%go "op")) in
    (if: "$sw" =⟨opType⟩ tRange
    then return: (GoAlloc etcdserverpb.RequestOp (CompositeLiteral etcdserverpb.RequestOp (LiteralValue [KeyedElement (Some (KeyField "Request"%go)) (ElementExpression (go.PointerType etcdserverpb.RequestOp_RequestRange) (GoAlloc etcdserverpb.RequestOp_RequestRange (CompositeLiteral etcdserverpb.RequestOp_RequestRange (LiteralValue [KeyedElement (Some (KeyField "RequestRange"%go)) (ElementExpression (go.PointerType etcdserverpb.RangeRequest) ((MethodResolve Op "toRangeRequest"%go (![Op] "op")) #()))]))))])))
    else
      (if: "$sw" =⟨opType⟩ tPut
      then
        let: "r" := (GoAlloc (go.PointerType etcdserverpb.PutRequest) (GoZeroVal (go.PointerType etcdserverpb.PutRequest) #())) in
        let: "$r0" := (GoAlloc etcdserverpb.PutRequest (CompositeLiteral etcdserverpb.PutRequest (LiteralValue [KeyedElement (Some (KeyField "Key"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] (StructFieldRef Op "key"%go "op"))); KeyedElement (Some (KeyField "Value"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] (StructFieldRef Op "val"%go "op"))); KeyedElement (Some (KeyField "Lease"%go)) (ElementExpression go.int64 (![LeaseID] (StructFieldRef Op "leaseID"%go "op"))); KeyedElement (Some (KeyField "PrevKv"%go)) (ElementExpression go.bool (![go.bool] (StructFieldRef Op "prevKV"%go "op"))); KeyedElement (Some (KeyField "IgnoreValue"%go)) (ElementExpression go.bool (![go.bool] (StructFieldRef Op "ignoreValue"%go "op"))); KeyedElement (Some (KeyField "IgnoreLease"%go)) (ElementExpression go.bool (![go.bool] (StructFieldRef Op "ignoreLease"%go "op")))]))) in
        do:  ("r" <-[go.PointerType etcdserverpb.PutRequest] "$r0");;;
        return: (GoAlloc etcdserverpb.RequestOp (CompositeLiteral etcdserverpb.RequestOp (LiteralValue [KeyedElement (Some (KeyField "Request"%go)) (ElementExpression (go.PointerType etcdserverpb.RequestOp_RequestPut) (GoAlloc etcdserverpb.RequestOp_RequestPut (CompositeLiteral etcdserverpb.RequestOp_RequestPut (LiteralValue [KeyedElement (Some (KeyField "RequestPut"%go)) (ElementExpression (go.PointerType etcdserverpb.PutRequest) (![go.PointerType etcdserverpb.PutRequest] "r"))]))))])))
      else
        (if: "$sw" =⟨opType⟩ tDeleteRange
        then
          let: "r" := (GoAlloc (go.PointerType etcdserverpb.DeleteRangeRequest) (GoZeroVal (go.PointerType etcdserverpb.DeleteRangeRequest) #())) in
          let: "$r0" := (GoAlloc etcdserverpb.DeleteRangeRequest (CompositeLiteral etcdserverpb.DeleteRangeRequest (LiteralValue [KeyedElement (Some (KeyField "Key"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] (StructFieldRef Op "key"%go "op"))); KeyedElement (Some (KeyField "RangeEnd"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] (StructFieldRef Op "end"%go "op"))); KeyedElement (Some (KeyField "PrevKv"%go)) (ElementExpression go.bool (![go.bool] (StructFieldRef Op "prevKV"%go "op")))]))) in
          do:  ("r" <-[go.PointerType etcdserverpb.DeleteRangeRequest] "$r0");;;
          return: (GoAlloc etcdserverpb.RequestOp (CompositeLiteral etcdserverpb.RequestOp (LiteralValue [KeyedElement (Some (KeyField "Request"%go)) (ElementExpression (go.PointerType etcdserverpb.RequestOp_RequestDeleteRange) (GoAlloc etcdserverpb.RequestOp_RequestDeleteRange (CompositeLiteral etcdserverpb.RequestOp_RequestDeleteRange (LiteralValue [KeyedElement (Some (KeyField "RequestDeleteRange"%go)) (ElementExpression (go.PointerType etcdserverpb.DeleteRangeRequest) (![go.PointerType etcdserverpb.DeleteRangeRequest] "r"))]))))])))
        else
          (if: "$sw" =⟨opType⟩ tTxn
          then return: (GoAlloc etcdserverpb.RequestOp (CompositeLiteral etcdserverpb.RequestOp (LiteralValue [KeyedElement (Some (KeyField "Request"%go)) (ElementExpression (go.PointerType etcdserverpb.RequestOp_RequestTxn) (GoAlloc etcdserverpb.RequestOp_RequestTxn (CompositeLiteral etcdserverpb.RequestOp_RequestTxn (LiteralValue [KeyedElement (Some (KeyField "RequestTxn"%go)) (ElementExpression (go.PointerType etcdserverpb.TxnRequest) ((MethodResolve Op "toTxnRequest"%go (![Op] "op")) #()))]))))])))
          else
            do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"Unknown Op"%go) in
            (FuncResolve go.panic [] #()) "$a0")))))).

(* go: op.go:209:14 *)
Definition Op__isWriteⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "op" <>,
    exception_do (let: "op" := (GoAlloc Op "op") in
    (if: Convert go.untyped_bool go.bool ((![opType] (StructFieldRef Op "t"%go "op")) =⟨go.int⟩ tTxn)
    then
      let: "$range" := (![go.SliceType Op] (StructFieldRef Op "thenOps"%go "op")) in
      (let: "tOp" := (GoAlloc Op (GoZeroVal Op #())) in
      slice.for_range Op "$range" (λ: "$key" "$value",
        do:  ("tOp" <-[Op] "$value");;;
        do:  "$key";;;
        (if: (MethodResolve Op "isWrite"%go (![Op] "tOp")) #()
        then return: (#true)
        else do:  #())));;;
      let: "$range" := (![go.SliceType Op] (StructFieldRef Op "elseOps"%go "op")) in
      (let: "tOp" := (GoAlloc Op (GoZeroVal Op #())) in
      slice.for_range Op "$range" (λ: "$key" "$value",
        do:  ("tOp" <-[Op] "$value");;;
        do:  "$key";;;
        (if: (MethodResolve Op "isWrite"%go (![Op] "tOp")) #()
        then return: (#true)
        else do:  #())));;;
      return: (#false)
    else do:  #());;;
    return: ((![opType] (StructFieldRef Op "t"%go "op")) ≠⟨go.int⟩ tRange)).

(* OpGet returns "get" operation based on given key and operation options.

   go: op.go:231:6 *)
Definition OpGetⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "key" "opts",
    exception_do (let: "opts" := (GoAlloc (go.SliceType OpOption) "opts") in
    let: "key" := (GoAlloc go.string "key") in
    (if: (let: "$a0" := (![go.SliceType OpOption] "opts") in
    (FuncResolve IsOptsWithPrefix [] #()) "$a0") && (let: "$a0" := (![go.SliceType OpOption] "opts") in
    (FuncResolve IsOptsWithFromKey [] #()) "$a0")
    then
      do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"`WithPrefix` and `WithFromKey` cannot be set at the same time, choose one"%go) in
      (FuncResolve go.panic [] #()) "$a0")
    else do:  #());;;
    let: "ret" := (GoAlloc Op (GoZeroVal Op #())) in
    let: "$r0" := (CompositeLiteral Op (LiteralValue [KeyedElement (Some (KeyField "t"%go)) (ElementExpression opType tRange); KeyedElement (Some (KeyField "key"%go)) (ElementExpression (go.SliceType go.byte) (Convert go.string (go.SliceType go.byte) (![go.string] "key")))])) in
    do:  ("ret" <-[Op] "$r0");;;
    do:  (let: "$a0" := (![go.SliceType OpOption] "opts") in
    (MethodResolve (go.PointerType Op) "applyOpts"%go "ret") "$a0");;;
    return: (![Op] "ret")).

(* OpDelete returns "delete" operation based on given key and operation options.

   go: op.go:242:6 *)
Definition OpDeleteⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "key" "opts",
    exception_do (let: "opts" := (GoAlloc (go.SliceType OpOption) "opts") in
    let: "key" := (GoAlloc go.string "key") in
    (if: (let: "$a0" := (![go.SliceType OpOption] "opts") in
    (FuncResolve IsOptsWithPrefix [] #()) "$a0") && (let: "$a0" := (![go.SliceType OpOption] "opts") in
    (FuncResolve IsOptsWithFromKey [] #()) "$a0")
    then
      do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"`WithPrefix` and `WithFromKey` cannot be set at the same time, choose one"%go) in
      (FuncResolve go.panic [] #()) "$a0")
    else do:  #());;;
    let: "ret" := (GoAlloc Op (GoZeroVal Op #())) in
    let: "$r0" := (CompositeLiteral Op (LiteralValue [KeyedElement (Some (KeyField "t"%go)) (ElementExpression opType tDeleteRange); KeyedElement (Some (KeyField "key"%go)) (ElementExpression (go.SliceType go.byte) (Convert go.string (go.SliceType go.byte) (![go.string] "key")))])) in
    do:  ("ret" <-[Op] "$r0");;;
    do:  (let: "$a0" := (![go.SliceType OpOption] "opts") in
    (MethodResolve (go.PointerType Op) "applyOpts"%go "ret") "$a0");;;
    let: "$sw" := #true in
    (if: "$sw" =⟨go.bool⟩ ((![LeaseID] (StructFieldRef Op "leaseID"%go "ret")) ≠⟨go.int64⟩ #(W64 0))
    then
      do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"unexpected lease in delete"%go) in
      (FuncResolve go.panic [] #()) "$a0")
    else
      (if: "$sw" =⟨go.bool⟩ ((![go.int64] (StructFieldRef Op "limit"%go "ret")) ≠⟨go.int64⟩ #(W64 0))
      then
        do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"unexpected limit in delete"%go) in
        (FuncResolve go.panic [] #()) "$a0")
      else
        (if: "$sw" =⟨go.bool⟩ ((![go.int64] (StructFieldRef Op "rev"%go "ret")) ≠⟨go.int64⟩ #(W64 0))
        then
          do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"unexpected revision in delete"%go) in
          (FuncResolve go.panic [] #()) "$a0")
        else
          (if: "$sw" =⟨go.bool⟩ ((![go.PointerType SortOption] (StructFieldRef Op "sort"%go "ret")) ≠⟨go.PointerType SortOption⟩ (Convert go.untyped_nil (go.PointerType SortOption) UntypedNil))
          then
            do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"unexpected sort in delete"%go) in
            (FuncResolve go.panic [] #()) "$a0")
          else
            (if: "$sw" =⟨go.bool⟩ (![go.bool] (StructFieldRef Op "serializable"%go "ret"))
            then
              do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"unexpected serializable in delete"%go) in
              (FuncResolve go.panic [] #()) "$a0")
            else
              (if: "$sw" =⟨go.bool⟩ (![go.bool] (StructFieldRef Op "countOnly"%go "ret"))
              then
                do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"unexpected countOnly in delete"%go) in
                (FuncResolve go.panic [] #()) "$a0")
              else
                (if: ("$sw" =⟨go.bool⟩ ((![go.int64] (StructFieldRef Op "maxModRev"%go "ret")) ≠⟨go.int64⟩ #(W64 0))) || ("$sw" =⟨go.bool⟩ ((![go.int64] (StructFieldRef Op "minModRev"%go "ret")) ≠⟨go.int64⟩ #(W64 0)))
                then
                  do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"unexpected mod revision filter in delete"%go) in
                  (FuncResolve go.panic [] #()) "$a0")
                else
                  (if: ("$sw" =⟨go.bool⟩ ((![go.int64] (StructFieldRef Op "maxCreateRev"%go "ret")) ≠⟨go.int64⟩ #(W64 0))) || ("$sw" =⟨go.bool⟩ ((![go.int64] (StructFieldRef Op "minCreateRev"%go "ret")) ≠⟨go.int64⟩ #(W64 0)))
                  then
                    do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"unexpected create revision filter in delete"%go) in
                    (FuncResolve go.panic [] #()) "$a0")
                  else
                    (if: ("$sw" =⟨go.bool⟩ (![go.bool] (StructFieldRef Op "filterPut"%go "ret"))) || ("$sw" =⟨go.bool⟩ (![go.bool] (StructFieldRef Op "filterDelete"%go "ret")))
                    then
                      do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"unexpected filter in delete"%go) in
                      (FuncResolve go.panic [] #()) "$a0")
                    else
                      (if: "$sw" =⟨go.bool⟩ (![go.bool] (StructFieldRef Op "createdNotify"%go "ret"))
                      then
                        do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"unexpected createdNotify in delete"%go) in
                        (FuncResolve go.panic [] #()) "$a0")
                      else do:  #()))))))))));;;
    return: (![Op] "ret")).

(* OpPut returns "put" operation based on given key-value and operation options.

   go: op.go:275:6 *)
Definition OpPutⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "key" "val" "opts",
    exception_do (let: "opts" := (GoAlloc (go.SliceType OpOption) "opts") in
    let: "val" := (GoAlloc go.string "val") in
    let: "key" := (GoAlloc go.string "key") in
    let: "ret" := (GoAlloc Op (GoZeroVal Op #())) in
    let: "$r0" := (CompositeLiteral Op (LiteralValue [KeyedElement (Some (KeyField "t"%go)) (ElementExpression opType tPut); KeyedElement (Some (KeyField "key"%go)) (ElementExpression (go.SliceType go.byte) (Convert go.string (go.SliceType go.byte) (![go.string] "key"))); KeyedElement (Some (KeyField "val"%go)) (ElementExpression (go.SliceType go.byte) (Convert go.string (go.SliceType go.byte) (![go.string] "val")))])) in
    do:  ("ret" <-[Op] "$r0");;;
    do:  (let: "$a0" := (![go.SliceType OpOption] "opts") in
    (MethodResolve (go.PointerType Op) "applyOpts"%go "ret") "$a0");;;
    let: "$sw" := #true in
    (if: "$sw" =⟨go.bool⟩ ((![go.SliceType go.byte] (StructFieldRef Op "end"%go "ret")) ≠⟨go.SliceType go.byte⟩ (Convert go.untyped_nil (go.SliceType go.byte) UntypedNil))
    then
      do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"unexpected range in put"%go) in
      (FuncResolve go.panic [] #()) "$a0")
    else
      (if: "$sw" =⟨go.bool⟩ ((![go.int64] (StructFieldRef Op "limit"%go "ret")) ≠⟨go.int64⟩ #(W64 0))
      then
        do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"unexpected limit in put"%go) in
        (FuncResolve go.panic [] #()) "$a0")
      else
        (if: "$sw" =⟨go.bool⟩ ((![go.int64] (StructFieldRef Op "rev"%go "ret")) ≠⟨go.int64⟩ #(W64 0))
        then
          do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"unexpected revision in put"%go) in
          (FuncResolve go.panic [] #()) "$a0")
        else
          (if: "$sw" =⟨go.bool⟩ ((![go.PointerType SortOption] (StructFieldRef Op "sort"%go "ret")) ≠⟨go.PointerType SortOption⟩ (Convert go.untyped_nil (go.PointerType SortOption) UntypedNil))
          then
            do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"unexpected sort in put"%go) in
            (FuncResolve go.panic [] #()) "$a0")
          else
            (if: "$sw" =⟨go.bool⟩ (![go.bool] (StructFieldRef Op "serializable"%go "ret"))
            then
              do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"unexpected serializable in put"%go) in
              (FuncResolve go.panic [] #()) "$a0")
            else
              (if: "$sw" =⟨go.bool⟩ (![go.bool] (StructFieldRef Op "countOnly"%go "ret"))
              then
                do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"unexpected countOnly in put"%go) in
                (FuncResolve go.panic [] #()) "$a0")
              else
                (if: ("$sw" =⟨go.bool⟩ ((![go.int64] (StructFieldRef Op "maxModRev"%go "ret")) ≠⟨go.int64⟩ #(W64 0))) || ("$sw" =⟨go.bool⟩ ((![go.int64] (StructFieldRef Op "minModRev"%go "ret")) ≠⟨go.int64⟩ #(W64 0)))
                then
                  do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"unexpected mod revision filter in put"%go) in
                  (FuncResolve go.panic [] #()) "$a0")
                else
                  (if: ("$sw" =⟨go.bool⟩ ((![go.int64] (StructFieldRef Op "maxCreateRev"%go "ret")) ≠⟨go.int64⟩ #(W64 0))) || ("$sw" =⟨go.bool⟩ ((![go.int64] (StructFieldRef Op "minCreateRev"%go "ret")) ≠⟨go.int64⟩ #(W64 0)))
                  then
                    do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"unexpected create revision filter in put"%go) in
                    (FuncResolve go.panic [] #()) "$a0")
                  else
                    (if: ("$sw" =⟨go.bool⟩ (![go.bool] (StructFieldRef Op "filterPut"%go "ret"))) || ("$sw" =⟨go.bool⟩ (![go.bool] (StructFieldRef Op "filterDelete"%go "ret")))
                    then
                      do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"unexpected filter in put"%go) in
                      (FuncResolve go.panic [] #()) "$a0")
                    else
                      (if: "$sw" =⟨go.bool⟩ (![go.bool] (StructFieldRef Op "createdNotify"%go "ret"))
                      then
                        do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"unexpected createdNotify in put"%go) in
                        (FuncResolve go.panic [] #()) "$a0")
                      else do:  #()))))))))));;;
    return: (![Op] "ret")).

(* OpTxn returns "txn" operation based on given transaction conditions.

   go: op.go:304:6 *)
Definition OpTxnⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "cmps" "thenOps" "elseOps",
    exception_do (let: "elseOps" := (GoAlloc (go.SliceType Op) "elseOps") in
    let: "thenOps" := (GoAlloc (go.SliceType Op) "thenOps") in
    let: "cmps" := (GoAlloc (go.SliceType Cmp) "cmps") in
    return: (CompositeLiteral Op (LiteralValue [KeyedElement (Some (KeyField "t"%go)) (ElementExpression opType tTxn); KeyedElement (Some (KeyField "cmps"%go)) (ElementExpression (go.SliceType Cmp) (![go.SliceType Cmp] "cmps")); KeyedElement (Some (KeyField "thenOps"%go)) (ElementExpression (go.SliceType Op) (![go.SliceType Op] "thenOps")); KeyedElement (Some (KeyField "elseOps"%go)) (ElementExpression (go.SliceType Op) (![go.SliceType Op] "elseOps"))]))).

(* go: op.go:330:15 *)
Definition Op__applyOptsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "op" "opts",
    exception_do (let: "op" := (GoAlloc (go.PointerType Op) "op") in
    let: "opts" := (GoAlloc (go.SliceType OpOption) "opts") in
    let: "$range" := (![go.SliceType OpOption] "opts") in
    (let: "opt" := (GoAlloc OpOption (GoZeroVal OpOption #())) in
    slice.for_range OpOption "$range" (λ: "$key" "$value",
      do:  ("opt" <-[OpOption] "$value");;;
      do:  "$key";;;
      do:  (let: "$a0" := (![go.PointerType Op] "op") in
      (![OpOption] "opt") "$a0")));;;
    return: #()).

(* WithLease attaches a lease ID to a key in 'Put' request.

   go: op.go:340:6 *)
Definition WithLeaseⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "leaseID",
    exception_do (let: "leaseID" := (GoAlloc LeaseID "leaseID") in
    return: ((λ: "op",
       exception_do (let: "op" := (GoAlloc (go.PointerType Op) "op") in
       let: "$r0" := (![LeaseID] "leaseID") in
       do:  ((StructFieldRef Op "leaseID"%go (![go.PointerType Op] "op")) <-[LeaseID] "$r0");;;
       return: #())
       ))).

(* WithLimit limits the number of results to return from 'Get' request.
   If WithLimit is given a 0 limit, it is treated as no limit.

   go: op.go:346:6 *)
Definition WithLimitⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "n",
    exception_do (let: "n" := (GoAlloc go.int64 "n") in
    return: ((λ: "op",
       exception_do (let: "op" := (GoAlloc (go.PointerType Op) "op") in
       let: "$r0" := (![go.int64] "n") in
       do:  ((StructFieldRef Op "limit"%go (![go.PointerType Op] "op")) <-[go.int64] "$r0");;;
       return: #())
       ))).

(* WithRev specifies the store revision for 'Get' request.
   Or the start revision of 'Watch' request.

   go: op.go:350:6 *)
Definition WithRevⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "rev",
    exception_do (let: "rev" := (GoAlloc go.int64 "rev") in
    return: ((λ: "op",
       exception_do (let: "op" := (GoAlloc (go.PointerType Op) "op") in
       let: "$r0" := (![go.int64] "rev") in
       do:  ((StructFieldRef Op "rev"%go (![go.PointerType Op] "op")) <-[go.int64] "$r0");;;
       return: #())
       ))).

(* WithSort specifies the ordering in 'Get' request. It requires
   'WithRange' and/or 'WithPrefix' to be specified too.
   'target' specifies the target to sort by: key, version, revisions, value.
   'order' can be either 'SortNone', 'SortAscend', 'SortDescend'.

   go: op.go:356:6 *)
Definition WithSortⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "target" "order",
    exception_do (let: "order" := (GoAlloc SortOrder "order") in
    let: "target" := (GoAlloc SortTarget "target") in
    return: ((λ: "op",
       exception_do (let: "op" := (GoAlloc (go.PointerType Op) "op") in
       (if: Convert go.untyped_bool go.bool (((![SortTarget] "target") =⟨go.int⟩ SortByKey) && ((![SortOrder] "order") =⟨go.int⟩ SortAscend))
       then
         let: "$r0" := SortNone in
         do:  ("order" <-[SortOrder] "$r0")
       else do:  #());;;
       let: "$r0" := (GoAlloc SortOption (CompositeLiteral SortOption (LiteralValue [KeyedElement None (ElementExpression SortTarget (![SortTarget] "target")); KeyedElement None (ElementExpression SortOrder (![SortOrder] "order"))]))) in
       do:  ((StructFieldRef Op "sort"%go (![go.PointerType Op] "op")) <-[go.PointerType SortOption] "$r0");;;
       return: #())
       ))).

(* WithPrefix enables 'Get', 'Delete', or 'Watch' requests to operate
   on the keys with matching prefix. For example, 'Get(foo, WithPrefix())'
   can return 'foo1', 'foo2', and so on.

   go: op.go:394:6 *)
Definition WithPrefixⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: ((λ: "op",
       exception_do (let: "op" := (GoAlloc (go.PointerType Op) "op") in
       let: "$r0" := #true in
       do:  ((StructFieldRef Op "isOptsWithPrefix"%go (![go.PointerType Op] "op")) <-[go.bool] "$r0");;;
       (if: Convert go.untyped_bool go.bool ((let: "$a0" := (![go.SliceType go.byte] (StructFieldRef Op "key"%go (![go.PointerType Op] "op"))) in
       (FuncResolve go.len [go.SliceType go.byte] #()) "$a0") =⟨go.int⟩ #(W64 0))
       then
         let: "$r0" := (CompositeLiteral (go.SliceType go.byte) (LiteralValue [KeyedElement None (ElementExpression go.byte #(W8 0))])) in
         let: "$r1" := (CompositeLiteral (go.SliceType go.byte) (LiteralValue [KeyedElement None (ElementExpression go.byte #(W8 0))])) in
         do:  ((StructFieldRef Op "key"%go (![go.PointerType Op] "op")) <-[go.SliceType go.byte] "$r0");;;
         do:  ((StructFieldRef Op "end"%go (![go.PointerType Op] "op")) <-[go.SliceType go.byte] "$r1");;;
         return: (#())
       else do:  #());;;
       let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] (StructFieldRef Op "key"%go (![go.PointerType Op] "op"))) in
       (FuncResolve getPrefix [] #()) "$a0") in
       do:  ((StructFieldRef Op "end"%go (![go.PointerType Op] "op")) <-[go.SliceType go.byte] "$r0");;;
       return: #())
       ))).

(* WithRange specifies the range of 'Get', 'Delete', 'Watch' requests.
   For example, 'Get' requests with 'WithRange(end)' returns
   the keys in the range [key, end).
   endKey must be lexicographically greater than start key.

   go: op.go:409:6 *)
Definition WithRangeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "endKey",
    exception_do (let: "endKey" := (GoAlloc go.string "endKey") in
    return: ((λ: "op",
       exception_do (let: "op" := (GoAlloc (go.PointerType Op) "op") in
       let: "$r0" := (Convert go.string (go.SliceType go.byte) (![go.string] "endKey")) in
       do:  ((StructFieldRef Op "end"%go (![go.PointerType Op] "op")) <-[go.SliceType go.byte] "$r0");;;
       return: #())
       ))).

(* WithFromKey specifies the range of 'Get', 'Delete', 'Watch' requests
   to be equal or greater than the key in the argument.

   go: op.go:415:6 *)
Definition WithFromKeyⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: ((λ: "op",
       exception_do (let: "op" := (GoAlloc (go.PointerType Op) "op") in
       (if: Convert go.untyped_bool go.bool ((let: "$a0" := (![go.SliceType go.byte] (StructFieldRef Op "key"%go (![go.PointerType Op] "op"))) in
       (FuncResolve go.len [go.SliceType go.byte] #()) "$a0") =⟨go.int⟩ #(W64 0))
       then
         let: "$r0" := (CompositeLiteral (go.SliceType go.byte) (LiteralValue [KeyedElement None (ElementExpression go.byte #(W8 0))])) in
         do:  ((StructFieldRef Op "key"%go (![go.PointerType Op] "op")) <-[go.SliceType go.byte] "$r0")
       else do:  #());;;
       let: "$r0" := (Convert go.string (go.SliceType go.byte) #" "%go) in
       do:  ((StructFieldRef Op "end"%go (![go.PointerType Op] "op")) <-[go.SliceType go.byte] "$r0");;;
       let: "$r0" := #true in
       do:  ((StructFieldRef Op "isOptsWithFromKey"%go (![go.PointerType Op] "op")) <-[go.bool] "$r0");;;
       return: #())
       ))).

(* WithSerializable makes `Get` and `MemberList` requests serializable.
   By default, they are linearizable. Serializable requests are better
   for lower latency requirement, but users should be aware that they
   could get stale data with serializable requests.

   In some situations users may want to use serializable requests. For
   example, when adding a new member to a one-node cluster, it's reasonable
   and safe to use serializable request before the new added member gets
   started.

   go: op.go:434:6 *)
Definition WithSerializableⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: ((λ: "op",
       exception_do (let: "op" := (GoAlloc (go.PointerType Op) "op") in
       let: "$r0" := #true in
       do:  ((StructFieldRef Op "serializable"%go (![go.PointerType Op] "op")) <-[go.bool] "$r0");;;
       return: #())
       ))).

(* WithKeysOnly makes the 'Get' request return only the keys and the corresponding
   values will be omitted.

   go: op.go:440:6 *)
Definition WithKeysOnlyⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: ((λ: "op",
       exception_do (let: "op" := (GoAlloc (go.PointerType Op) "op") in
       let: "$r0" := #true in
       do:  ((StructFieldRef Op "keysOnly"%go (![go.PointerType Op] "op")) <-[go.bool] "$r0");;;
       return: #())
       ))).

(* WithCountOnly makes the 'Get' request return only the count of keys.

   go: op.go:445:6 *)
Definition WithCountOnlyⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: ((λ: "op",
       exception_do (let: "op" := (GoAlloc (go.PointerType Op) "op") in
       let: "$r0" := #true in
       do:  ((StructFieldRef Op "countOnly"%go (![go.PointerType Op] "op")) <-[go.bool] "$r0");;;
       return: #())
       ))).

(* WithMinModRev filters out keys for Get with modification revisions less than the given revision.

   go: op.go:450:6 *)
Definition WithMinModRevⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "rev",
    exception_do (let: "rev" := (GoAlloc go.int64 "rev") in
    return: ((λ: "op",
       exception_do (let: "op" := (GoAlloc (go.PointerType Op) "op") in
       let: "$r0" := (![go.int64] "rev") in
       do:  ((StructFieldRef Op "minModRev"%go (![go.PointerType Op] "op")) <-[go.int64] "$r0");;;
       return: #())
       ))).

(* WithMaxModRev filters out keys for Get with modification revisions greater than the given revision.

   go: op.go:453:6 *)
Definition WithMaxModRevⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "rev",
    exception_do (let: "rev" := (GoAlloc go.int64 "rev") in
    return: ((λ: "op",
       exception_do (let: "op" := (GoAlloc (go.PointerType Op) "op") in
       let: "$r0" := (![go.int64] "rev") in
       do:  ((StructFieldRef Op "maxModRev"%go (![go.PointerType Op] "op")) <-[go.int64] "$r0");;;
       return: #())
       ))).

(* WithMinCreateRev filters out keys for Get with creation revisions less than the given revision.

   go: op.go:456:6 *)
Definition WithMinCreateRevⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "rev",
    exception_do (let: "rev" := (GoAlloc go.int64 "rev") in
    return: ((λ: "op",
       exception_do (let: "op" := (GoAlloc (go.PointerType Op) "op") in
       let: "$r0" := (![go.int64] "rev") in
       do:  ((StructFieldRef Op "minCreateRev"%go (![go.PointerType Op] "op")) <-[go.int64] "$r0");;;
       return: #())
       ))).

(* WithMaxCreateRev filters out keys for Get with creation revisions greater than the given revision.

   go: op.go:459:6 *)
Definition WithMaxCreateRevⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "rev",
    exception_do (let: "rev" := (GoAlloc go.int64 "rev") in
    return: ((λ: "op",
       exception_do (let: "op" := (GoAlloc (go.PointerType Op) "op") in
       let: "$r0" := (![go.int64] "rev") in
       do:  ((StructFieldRef Op "maxCreateRev"%go (![go.PointerType Op] "op")) <-[go.int64] "$r0");;;
       return: #())
       ))).

(* WithFirstCreate gets the key with the oldest creation revision in the request range.

   go: op.go:462:6 *)
Definition WithFirstCreateⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (let: "$a0" := SortByCreateRevision in
     let: "$a1" := SortAscend in
     (FuncResolve withTop [] #()) "$a0" "$a1")).

(* WithLastCreate gets the key with the latest creation revision in the request range.

   go: op.go:465:6 *)
Definition WithLastCreateⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (let: "$a0" := SortByCreateRevision in
     let: "$a1" := SortDescend in
     (FuncResolve withTop [] #()) "$a0" "$a1")).

(* WithFirstKey gets the lexically first key in the request range.

   go: op.go:468:6 *)
Definition WithFirstKeyⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (let: "$a0" := SortByKey in
     let: "$a1" := SortAscend in
     (FuncResolve withTop [] #()) "$a0" "$a1")).

(* WithLastKey gets the lexically last key in the request range.

   go: op.go:471:6 *)
Definition WithLastKeyⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (let: "$a0" := SortByKey in
     let: "$a1" := SortDescend in
     (FuncResolve withTop [] #()) "$a0" "$a1")).

(* WithFirstRev gets the key with the oldest modification revision in the request range.

   go: op.go:474:6 *)
Definition WithFirstRevⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (let: "$a0" := SortByModRevision in
     let: "$a1" := SortAscend in
     (FuncResolve withTop [] #()) "$a0" "$a1")).

(* WithLastRev gets the key with the latest modification revision in the request range.

   go: op.go:477:6 *)
Definition WithLastRevⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (let: "$a0" := SortByModRevision in
     let: "$a1" := SortDescend in
     (FuncResolve withTop [] #()) "$a0" "$a1")).

(* WithProgressNotify makes watch server send periodic progress updates
   every 10 minutes when there is no incoming events.
   Progress updates have zero events in WatchResponse.

   go: op.go:487:6 *)
Definition WithProgressNotifyⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: ((λ: "op",
       exception_do (let: "op" := (GoAlloc (go.PointerType Op) "op") in
       let: "$r0" := #true in
       do:  ((StructFieldRef Op "progressNotify"%go (![go.PointerType Op] "op")) <-[go.bool] "$r0");;;
       return: #())
       ))).

(* WithCreatedNotify makes watch server sends the created event.

   go: op.go:494:6 *)
Definition WithCreatedNotifyⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: ((λ: "op",
       exception_do (let: "op" := (GoAlloc (go.PointerType Op) "op") in
       let: "$r0" := #true in
       do:  ((StructFieldRef Op "createdNotify"%go (![go.PointerType Op] "op")) <-[go.bool] "$r0");;;
       return: #())
       ))).

(* WithFilterPut discards PUT events from the watcher.

   go: op.go:501:6 *)
Definition WithFilterPutⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: ((λ: "op",
       exception_do (let: "op" := (GoAlloc (go.PointerType Op) "op") in
       let: "$r0" := #true in
       do:  ((StructFieldRef Op "filterPut"%go (![go.PointerType Op] "op")) <-[go.bool] "$r0");;;
       return: #())
       ))).

(* WithFilterDelete discards DELETE events from the watcher.

   go: op.go:506:6 *)
Definition WithFilterDeleteⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: ((λ: "op",
       exception_do (let: "op" := (GoAlloc (go.PointerType Op) "op") in
       let: "$r0" := #true in
       do:  ((StructFieldRef Op "filterDelete"%go (![go.PointerType Op] "op")) <-[go.bool] "$r0");;;
       return: #())
       ))).

(* WithPrevKV gets the previous key-value pair before the event happens. If the previous KV is already compacted,
   nothing will be returned.

   go: op.go:512:6 *)
Definition WithPrevKVⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: ((λ: "op",
       exception_do (let: "op" := (GoAlloc (go.PointerType Op) "op") in
       let: "$r0" := #true in
       do:  ((StructFieldRef Op "prevKV"%go (![go.PointerType Op] "op")) <-[go.bool] "$r0");;;
       return: #())
       ))).

(* WithFragment to receive raw watch response with fragmentation.
   Fragmentation is disabled by default. If fragmentation is enabled,
   etcd watch server will split watch response before sending to clients
   when the total size of watch events exceed server-side request limit.
   The default server-side request limit is 1.5 MiB, which can be configured
   as "--max-request-bytes" flag value + gRPC-overhead 512 bytes.
   See "etcdserver/api/v3rpc/watch.go" for more details.

   go: op.go:525:6 *)
Definition WithFragmentⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: ((λ: "op",
       exception_do (let: "op" := (GoAlloc (go.PointerType Op) "op") in
       let: "$r0" := #true in
       do:  ((StructFieldRef Op "fragment"%go (![go.PointerType Op] "op")) <-[go.bool] "$r0");;;
       return: #())
       ))).

(* WithIgnoreValue updates the key using its current value.
   This option can not be combined with non-empty values.
   Returns an error if the key does not exist.

   go: op.go:532:6 *)
Definition WithIgnoreValueⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: ((λ: "op",
       exception_do (let: "op" := (GoAlloc (go.PointerType Op) "op") in
       let: "$r0" := #true in
       do:  ((StructFieldRef Op "ignoreValue"%go (![go.PointerType Op] "op")) <-[go.bool] "$r0");;;
       return: #())
       ))).

(* WithIgnoreLease updates the key using its current lease.
   This option can not be combined with WithLease.
   Returns an error if the key does not exist.

   go: op.go:541:6 *)
Definition WithIgnoreLeaseⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: ((λ: "op",
       exception_do (let: "op" := (GoAlloc (go.PointerType Op) "op") in
       let: "$r0" := #true in
       do:  ((StructFieldRef Op "ignoreLease"%go (![go.PointerType Op] "op")) <-[go.bool] "$r0");;;
       return: #())
       ))).

(* WithAttachedKeys makes TimeToLive list the keys attached to the given lease ID.

   go: op.go:565:6 *)
Definition WithAttachedKeysⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: ((λ: "op",
       exception_do (let: "op" := (GoAlloc (go.PointerType LeaseOp) "op") in
       let: "$r0" := #true in
       do:  ((StructFieldRef LeaseOp "attachedKeys"%go (![go.PointerType LeaseOp] "op")) <-[go.bool] "$r0");;;
       return: #())
       ))).

(* go: op.go:595:14 *)
Definition Op__IsSortOptionValidⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "op" <>,
    exception_do (let: "op" := (GoAlloc Op "op") in
    (if: Convert go.untyped_bool go.bool ((![go.PointerType SortOption] (StructFieldRef Op "sort"%go "op")) ≠⟨go.PointerType SortOption⟩ (Convert go.untyped_nil (go.PointerType SortOption) UntypedNil))
    then
      let: "sortOrder" := (GoAlloc go.int32 (GoZeroVal go.int32 #())) in
      let: "$r0" := (Convert SortOrder go.int32 (![SortOrder] (StructFieldRef SortOption "Order"%go (![go.PointerType SortOption] (StructFieldRef Op "sort"%go "op"))))) in
      do:  ("sortOrder" <-[go.int32] "$r0");;;
      let: "sortTarget" := (GoAlloc go.int32 (GoZeroVal go.int32 #())) in
      let: "$r0" := (Convert SortTarget go.int32 (![SortTarget] (StructFieldRef SortOption "Target"%go (![go.PointerType SortOption] (StructFieldRef Op "sort"%go "op"))))) in
      do:  ("sortTarget" <-[go.int32] "$r0");;;
      (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
      let: ("$ret0", "$ret1") := (map.lookup2 go.int32 go.string (![go.MapType go.int32 go.string] (GlobalVarAddr etcdserverpb.RangeRequest_SortOrder_name #())) (![go.int32] "sortOrder")) in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  "$r0";;;
      do:  ("ok" <-[go.bool] "$r1");;;
      (if: (⟨go.bool⟩! (![go.bool] "ok"))
      then return: (#false)
      else do:  #()));;;
      (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
      let: ("$ret0", "$ret1") := (map.lookup2 go.int32 go.string (![go.MapType go.int32 go.string] (GlobalVarAddr etcdserverpb.RangeRequest_SortTarget_name #())) (![go.int32] "sortTarget")) in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  "$r0";;;
      do:  ("ok" <-[go.bool] "$r1");;;
      (if: (⟨go.bool⟩! (![go.bool] "ok"))
      then return: (#false)
      else do:  #()))
    else do:  #());;;
    return: (#true)).

#[global] Instance info' : PkgInfo pkg_id.clientv3 :=
{|
  pkg_imported_pkgs := [code.context.pkg_id.context; code.go_etcd_io.etcd.api.v3.etcdserverpb.pkg_id.etcdserverpb; code.go_uber_org.zap.pkg_id.zap; code.go_etcd_io.etcd.api.v3.mvccpb.pkg_id.mvccpb]
|}.

Axiom _'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init pkg_id.clientv3 (λ: <>,
      exception_do (do:  (mvccpb.initialize' #());;;
      do:  (zap.initialize' #());;;
      do:  (etcdserverpb.initialize' #());;;
      do:  (context.initialize' #());;;
      do:  (ErrNoAvailableEndpoints'init #());;;
      do:  (ErrOldCluster'init #());;;
      do:  (LeaseResponseChSize'init #());;;
      do:  (noPrefixEnd'init #());;;
      do:  (defaultWaitForReady'init #());;;
      do:  (defaultMaxCallSendMsgSize'init #());;;
      do:  (defaultMaxCallRecvMsgSize'init #());;;
      do:  (defaultUnaryMaxRetries'init #());;;
      do:  (defaultStreamMaxRetries'init #());;;
      do:  (defaultBackoffWaitBetween'init #());;;
      do:  (defaultBackoffJitterFraction'init #());;;
      do:  (defaultCallOpts'init #());;;
      do:  (defaultOptions'init #());;;
      do:  (valCtxCh'init #());;;
      do:  (zeroTime'init #());;;
      do:  (maxBackoff'init #()))
      ).

Module AuthEnableResponse.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End AuthEnableResponse.

Class AuthEnableResponse_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] AuthEnableResponse_type_repr  :: go.TypeReprUnderlying AuthEnableResponseⁱᵐᵖˡ AuthEnableResponse.t;
  #[global] AuthEnableResponse_underlying :: (AuthEnableResponse) <u (AuthEnableResponseⁱᵐᵖˡ);
  #[global] AuthEnableResponseⁱᵐᵖˡ_underlying :: (AuthEnableResponseⁱᵐᵖˡ) ↓u (AuthEnableResponseⁱᵐᵖˡ);
}.

Module AuthDisableResponse.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End AuthDisableResponse.

Class AuthDisableResponse_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] AuthDisableResponse_type_repr  :: go.TypeReprUnderlying AuthDisableResponseⁱᵐᵖˡ AuthDisableResponse.t;
  #[global] AuthDisableResponse_underlying :: (AuthDisableResponse) <u (AuthDisableResponseⁱᵐᵖˡ);
  #[global] AuthDisableResponseⁱᵐᵖˡ_underlying :: (AuthDisableResponseⁱᵐᵖˡ) ↓u (AuthDisableResponseⁱᵐᵖˡ);
}.

Module AuthStatusResponse.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End AuthStatusResponse.

Class AuthStatusResponse_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] AuthStatusResponse_type_repr  :: go.TypeReprUnderlying AuthStatusResponseⁱᵐᵖˡ AuthStatusResponse.t;
  #[global] AuthStatusResponse_underlying :: (AuthStatusResponse) <u (AuthStatusResponseⁱᵐᵖˡ);
  #[global] AuthStatusResponseⁱᵐᵖˡ_underlying :: (AuthStatusResponseⁱᵐᵖˡ) ↓u (AuthStatusResponseⁱᵐᵖˡ);
}.

Module AuthenticateResponse.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End AuthenticateResponse.

Class AuthenticateResponse_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] AuthenticateResponse_type_repr  :: go.TypeReprUnderlying AuthenticateResponseⁱᵐᵖˡ AuthenticateResponse.t;
  #[global] AuthenticateResponse_underlying :: (AuthenticateResponse) <u (AuthenticateResponseⁱᵐᵖˡ);
  #[global] AuthenticateResponseⁱᵐᵖˡ_underlying :: (AuthenticateResponseⁱᵐᵖˡ) ↓u (AuthenticateResponseⁱᵐᵖˡ);
}.

Module AuthUserAddResponse.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End AuthUserAddResponse.

Class AuthUserAddResponse_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] AuthUserAddResponse_type_repr  :: go.TypeReprUnderlying AuthUserAddResponseⁱᵐᵖˡ AuthUserAddResponse.t;
  #[global] AuthUserAddResponse_underlying :: (AuthUserAddResponse) <u (AuthUserAddResponseⁱᵐᵖˡ);
  #[global] AuthUserAddResponseⁱᵐᵖˡ_underlying :: (AuthUserAddResponseⁱᵐᵖˡ) ↓u (AuthUserAddResponseⁱᵐᵖˡ);
}.

Module AuthUserDeleteResponse.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End AuthUserDeleteResponse.

Class AuthUserDeleteResponse_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] AuthUserDeleteResponse_type_repr  :: go.TypeReprUnderlying AuthUserDeleteResponseⁱᵐᵖˡ AuthUserDeleteResponse.t;
  #[global] AuthUserDeleteResponse_underlying :: (AuthUserDeleteResponse) <u (AuthUserDeleteResponseⁱᵐᵖˡ);
  #[global] AuthUserDeleteResponseⁱᵐᵖˡ_underlying :: (AuthUserDeleteResponseⁱᵐᵖˡ) ↓u (AuthUserDeleteResponseⁱᵐᵖˡ);
}.

Module AuthUserChangePasswordResponse.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End AuthUserChangePasswordResponse.

Class AuthUserChangePasswordResponse_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] AuthUserChangePasswordResponse_type_repr  :: go.TypeReprUnderlying AuthUserChangePasswordResponseⁱᵐᵖˡ AuthUserChangePasswordResponse.t;
  #[global] AuthUserChangePasswordResponse_underlying :: (AuthUserChangePasswordResponse) <u (AuthUserChangePasswordResponseⁱᵐᵖˡ);
  #[global] AuthUserChangePasswordResponseⁱᵐᵖˡ_underlying :: (AuthUserChangePasswordResponseⁱᵐᵖˡ) ↓u (AuthUserChangePasswordResponseⁱᵐᵖˡ);
}.

Module AuthUserGrantRoleResponse.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End AuthUserGrantRoleResponse.

Class AuthUserGrantRoleResponse_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] AuthUserGrantRoleResponse_type_repr  :: go.TypeReprUnderlying AuthUserGrantRoleResponseⁱᵐᵖˡ AuthUserGrantRoleResponse.t;
  #[global] AuthUserGrantRoleResponse_underlying :: (AuthUserGrantRoleResponse) <u (AuthUserGrantRoleResponseⁱᵐᵖˡ);
  #[global] AuthUserGrantRoleResponseⁱᵐᵖˡ_underlying :: (AuthUserGrantRoleResponseⁱᵐᵖˡ) ↓u (AuthUserGrantRoleResponseⁱᵐᵖˡ);
}.

Module AuthUserGetResponse.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End AuthUserGetResponse.

Class AuthUserGetResponse_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] AuthUserGetResponse_type_repr  :: go.TypeReprUnderlying AuthUserGetResponseⁱᵐᵖˡ AuthUserGetResponse.t;
  #[global] AuthUserGetResponse_underlying :: (AuthUserGetResponse) <u (AuthUserGetResponseⁱᵐᵖˡ);
  #[global] AuthUserGetResponseⁱᵐᵖˡ_underlying :: (AuthUserGetResponseⁱᵐᵖˡ) ↓u (AuthUserGetResponseⁱᵐᵖˡ);
}.

Module AuthUserRevokeRoleResponse.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End AuthUserRevokeRoleResponse.

Class AuthUserRevokeRoleResponse_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] AuthUserRevokeRoleResponse_type_repr  :: go.TypeReprUnderlying AuthUserRevokeRoleResponseⁱᵐᵖˡ AuthUserRevokeRoleResponse.t;
  #[global] AuthUserRevokeRoleResponse_underlying :: (AuthUserRevokeRoleResponse) <u (AuthUserRevokeRoleResponseⁱᵐᵖˡ);
  #[global] AuthUserRevokeRoleResponseⁱᵐᵖˡ_underlying :: (AuthUserRevokeRoleResponseⁱᵐᵖˡ) ↓u (AuthUserRevokeRoleResponseⁱᵐᵖˡ);
}.

Module AuthRoleAddResponse.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End AuthRoleAddResponse.

Class AuthRoleAddResponse_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] AuthRoleAddResponse_type_repr  :: go.TypeReprUnderlying AuthRoleAddResponseⁱᵐᵖˡ AuthRoleAddResponse.t;
  #[global] AuthRoleAddResponse_underlying :: (AuthRoleAddResponse) <u (AuthRoleAddResponseⁱᵐᵖˡ);
  #[global] AuthRoleAddResponseⁱᵐᵖˡ_underlying :: (AuthRoleAddResponseⁱᵐᵖˡ) ↓u (AuthRoleAddResponseⁱᵐᵖˡ);
}.

Module AuthRoleGrantPermissionResponse.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End AuthRoleGrantPermissionResponse.

Class AuthRoleGrantPermissionResponse_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] AuthRoleGrantPermissionResponse_type_repr  :: go.TypeReprUnderlying AuthRoleGrantPermissionResponseⁱᵐᵖˡ AuthRoleGrantPermissionResponse.t;
  #[global] AuthRoleGrantPermissionResponse_underlying :: (AuthRoleGrantPermissionResponse) <u (AuthRoleGrantPermissionResponseⁱᵐᵖˡ);
  #[global] AuthRoleGrantPermissionResponseⁱᵐᵖˡ_underlying :: (AuthRoleGrantPermissionResponseⁱᵐᵖˡ) ↓u (AuthRoleGrantPermissionResponseⁱᵐᵖˡ);
}.

Module AuthRoleGetResponse.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End AuthRoleGetResponse.

Class AuthRoleGetResponse_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] AuthRoleGetResponse_type_repr  :: go.TypeReprUnderlying AuthRoleGetResponseⁱᵐᵖˡ AuthRoleGetResponse.t;
  #[global] AuthRoleGetResponse_underlying :: (AuthRoleGetResponse) <u (AuthRoleGetResponseⁱᵐᵖˡ);
  #[global] AuthRoleGetResponseⁱᵐᵖˡ_underlying :: (AuthRoleGetResponseⁱᵐᵖˡ) ↓u (AuthRoleGetResponseⁱᵐᵖˡ);
}.

Module AuthRoleRevokePermissionResponse.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End AuthRoleRevokePermissionResponse.

Class AuthRoleRevokePermissionResponse_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] AuthRoleRevokePermissionResponse_type_repr  :: go.TypeReprUnderlying AuthRoleRevokePermissionResponseⁱᵐᵖˡ AuthRoleRevokePermissionResponse.t;
  #[global] AuthRoleRevokePermissionResponse_underlying :: (AuthRoleRevokePermissionResponse) <u (AuthRoleRevokePermissionResponseⁱᵐᵖˡ);
  #[global] AuthRoleRevokePermissionResponseⁱᵐᵖˡ_underlying :: (AuthRoleRevokePermissionResponseⁱᵐᵖˡ) ↓u (AuthRoleRevokePermissionResponseⁱᵐᵖˡ);
}.

Module AuthRoleDeleteResponse.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End AuthRoleDeleteResponse.

Class AuthRoleDeleteResponse_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] AuthRoleDeleteResponse_type_repr  :: go.TypeReprUnderlying AuthRoleDeleteResponseⁱᵐᵖˡ AuthRoleDeleteResponse.t;
  #[global] AuthRoleDeleteResponse_underlying :: (AuthRoleDeleteResponse) <u (AuthRoleDeleteResponseⁱᵐᵖˡ);
  #[global] AuthRoleDeleteResponseⁱᵐᵖˡ_underlying :: (AuthRoleDeleteResponseⁱᵐᵖˡ) ↓u (AuthRoleDeleteResponseⁱᵐᵖˡ);
}.

Module AuthUserListResponse.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End AuthUserListResponse.

Class AuthUserListResponse_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] AuthUserListResponse_type_repr  :: go.TypeReprUnderlying AuthUserListResponseⁱᵐᵖˡ AuthUserListResponse.t;
  #[global] AuthUserListResponse_underlying :: (AuthUserListResponse) <u (AuthUserListResponseⁱᵐᵖˡ);
  #[global] AuthUserListResponseⁱᵐᵖˡ_underlying :: (AuthUserListResponseⁱᵐᵖˡ) ↓u (AuthUserListResponseⁱᵐᵖˡ);
}.

Module AuthRoleListResponse.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End AuthRoleListResponse.

Class AuthRoleListResponse_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] AuthRoleListResponse_type_repr  :: go.TypeReprUnderlying AuthRoleListResponseⁱᵐᵖˡ AuthRoleListResponse.t;
  #[global] AuthRoleListResponse_underlying :: (AuthRoleListResponse) <u (AuthRoleListResponseⁱᵐᵖˡ);
  #[global] AuthRoleListResponseⁱᵐᵖˡ_underlying :: (AuthRoleListResponseⁱᵐᵖˡ) ↓u (AuthRoleListResponseⁱᵐᵖˡ);
}.

Module PermissionType.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End PermissionType.

Class PermissionType_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] PermissionType_type_repr  :: go.TypeReprUnderlying PermissionTypeⁱᵐᵖˡ PermissionType.t;
  #[global] PermissionType_underlying :: (PermissionType) <u (PermissionTypeⁱᵐᵖˡ);
  #[global] PermissionTypeⁱᵐᵖˡ_underlying :: (PermissionTypeⁱᵐᵖˡ) ↓u (PermissionTypeⁱᵐᵖˡ);
}.

Module Permission.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End Permission.

Class Permission_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Permission_type_repr  :: go.TypeReprUnderlying Permissionⁱᵐᵖˡ Permission.t;
  #[global] Permission_underlying :: (Permission) <u (Permissionⁱᵐᵖˡ);
  #[global] Permissionⁱᵐᵖˡ_underlying :: (Permissionⁱᵐᵖˡ) ↓u (Permissionⁱᵐᵖˡ);
}.

Module UserAddOptions.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End UserAddOptions.

Class UserAddOptions_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] UserAddOptions_type_repr  :: go.TypeReprUnderlying UserAddOptionsⁱᵐᵖˡ UserAddOptions.t;
  #[global] UserAddOptions_underlying :: (UserAddOptions) <u (UserAddOptionsⁱᵐᵖˡ);
  #[global] UserAddOptionsⁱᵐᵖˡ_underlying :: (UserAddOptionsⁱᵐᵖˡ) ↓u (UserAddOptionsⁱᵐᵖˡ);
}.

Module Auth.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End Auth.

Class Auth_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Auth_type_repr  :: go.TypeReprUnderlying Authⁱᵐᵖˡ Auth.t;
  #[global] Auth_underlying :: (Auth) <u (Authⁱᵐᵖˡ);
  #[global] Authⁱᵐᵖˡ_underlying :: (Authⁱᵐᵖˡ) ↓u (Authⁱᵐᵖˡ);
}.

Module authClient.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End authClient.

Class authClient_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] authClient_type_repr  :: go.TypeReprUnderlying authClientⁱᵐᵖˡ authClient.t;
  #[global] authClient_underlying :: (authClient) <u (authClientⁱᵐᵖˡ);
  #[global] authClientⁱᵐᵖˡ_underlying :: (authClientⁱᵐᵖˡ) ↓u (authClientⁱᵐᵖˡ);
}.

Module Client.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End Client.

Class Client_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Client_type_repr  :: go.TypeReprUnderlying Clientⁱᵐᵖˡ Client.t;
  #[global] Client_underlying :: (Client) <u (Clientⁱᵐᵖˡ);
  #[global] Clientⁱᵐᵖˡ_underlying :: (Clientⁱᵐᵖˡ) ↓u (Clientⁱᵐᵖˡ);
}.

Module Option.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End Option.

Class Option_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Option_type_repr  :: go.TypeReprUnderlying Optionⁱᵐᵖˡ Option.t;
  #[global] Option_underlying :: (Option) <u (Optionⁱᵐᵖˡ);
  #[global] Optionⁱᵐᵖˡ_underlying :: (Optionⁱᵐᵖˡ) ↓u (Optionⁱᵐᵖˡ);
}.

Module Member.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End Member.

Class Member_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Member_type_repr  :: go.TypeReprUnderlying Memberⁱᵐᵖˡ Member.t;
  #[global] Member_underlying :: (Member) <u (Memberⁱᵐᵖˡ);
  #[global] Memberⁱᵐᵖˡ_underlying :: (Memberⁱᵐᵖˡ) ↓u (Memberⁱᵐᵖˡ);
}.

Module MemberListResponse.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End MemberListResponse.

Class MemberListResponse_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] MemberListResponse_type_repr  :: go.TypeReprUnderlying MemberListResponseⁱᵐᵖˡ MemberListResponse.t;
  #[global] MemberListResponse_underlying :: (MemberListResponse) <u (MemberListResponseⁱᵐᵖˡ);
  #[global] MemberListResponseⁱᵐᵖˡ_underlying :: (MemberListResponseⁱᵐᵖˡ) ↓u (MemberListResponseⁱᵐᵖˡ);
}.

Module MemberAddResponse.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End MemberAddResponse.

Class MemberAddResponse_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] MemberAddResponse_type_repr  :: go.TypeReprUnderlying MemberAddResponseⁱᵐᵖˡ MemberAddResponse.t;
  #[global] MemberAddResponse_underlying :: (MemberAddResponse) <u (MemberAddResponseⁱᵐᵖˡ);
  #[global] MemberAddResponseⁱᵐᵖˡ_underlying :: (MemberAddResponseⁱᵐᵖˡ) ↓u (MemberAddResponseⁱᵐᵖˡ);
}.

Module MemberRemoveResponse.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End MemberRemoveResponse.

Class MemberRemoveResponse_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] MemberRemoveResponse_type_repr  :: go.TypeReprUnderlying MemberRemoveResponseⁱᵐᵖˡ MemberRemoveResponse.t;
  #[global] MemberRemoveResponse_underlying :: (MemberRemoveResponse) <u (MemberRemoveResponseⁱᵐᵖˡ);
  #[global] MemberRemoveResponseⁱᵐᵖˡ_underlying :: (MemberRemoveResponseⁱᵐᵖˡ) ↓u (MemberRemoveResponseⁱᵐᵖˡ);
}.

Module MemberUpdateResponse.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End MemberUpdateResponse.

Class MemberUpdateResponse_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] MemberUpdateResponse_type_repr  :: go.TypeReprUnderlying MemberUpdateResponseⁱᵐᵖˡ MemberUpdateResponse.t;
  #[global] MemberUpdateResponse_underlying :: (MemberUpdateResponse) <u (MemberUpdateResponseⁱᵐᵖˡ);
  #[global] MemberUpdateResponseⁱᵐᵖˡ_underlying :: (MemberUpdateResponseⁱᵐᵖˡ) ↓u (MemberUpdateResponseⁱᵐᵖˡ);
}.

Module MemberPromoteResponse.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End MemberPromoteResponse.

Class MemberPromoteResponse_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] MemberPromoteResponse_type_repr  :: go.TypeReprUnderlying MemberPromoteResponseⁱᵐᵖˡ MemberPromoteResponse.t;
  #[global] MemberPromoteResponse_underlying :: (MemberPromoteResponse) <u (MemberPromoteResponseⁱᵐᵖˡ);
  #[global] MemberPromoteResponseⁱᵐᵖˡ_underlying :: (MemberPromoteResponseⁱᵐᵖˡ) ↓u (MemberPromoteResponseⁱᵐᵖˡ);
}.

Module Cluster.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := interface.t.
End def.
End Cluster.

Definition Clusterⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.InterfaceType [go.MethodElem "MemberAdd"%go (go.Signature [context.Context; go.SliceType go.string] false [go.PointerType MemberAddResponse; go.error]); go.MethodElem "MemberAddAsLearner"%go (go.Signature [context.Context; go.SliceType go.string] false [go.PointerType MemberAddResponse; go.error]); go.MethodElem "MemberList"%go (go.Signature [context.Context; go.SliceType OpOption] true [go.PointerType MemberListResponse; go.error]); go.MethodElem "MemberPromote"%go (go.Signature [context.Context; go.uint64] false [go.PointerType MemberPromoteResponse; go.error]); go.MethodElem "MemberRemove"%go (go.Signature [context.Context; go.uint64] false [go.PointerType MemberRemoveResponse; go.error]); go.MethodElem "MemberUpdate"%go (go.Signature [context.Context; go.uint64; go.SliceType go.string] false [go.PointerType MemberUpdateResponse; go.error])].

Class Cluster_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Cluster_underlying :: (Cluster) <u (Clusterⁱᵐᵖˡ);
}.

Module cluster.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End cluster.

Class cluster_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] cluster_type_repr  :: go.TypeReprUnderlying clusterⁱᵐᵖˡ cluster.t;
  #[global] cluster_underlying :: (cluster) <u (clusterⁱᵐᵖˡ);
  #[global] clusterⁱᵐᵖˡ_underlying :: (clusterⁱᵐᵖˡ) ↓u (clusterⁱᵐᵖˡ);
}.

Module CompactOp.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End CompactOp.

Class CompactOp_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] CompactOp_type_repr  :: go.TypeReprUnderlying CompactOpⁱᵐᵖˡ CompactOp.t;
  #[global] CompactOp_underlying :: (CompactOp) <u (CompactOpⁱᵐᵖˡ);
  #[global] CompactOpⁱᵐᵖˡ_underlying :: (CompactOpⁱᵐᵖˡ) ↓u (CompactOpⁱᵐᵖˡ);
}.

Module CompactOption.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End CompactOption.

Class CompactOption_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] CompactOption_type_repr  :: go.TypeReprUnderlying CompactOptionⁱᵐᵖˡ CompactOption.t;
  #[global] CompactOption_underlying :: (CompactOption) <u (CompactOptionⁱᵐᵖˡ);
  #[global] CompactOptionⁱᵐᵖˡ_underlying :: (CompactOptionⁱᵐᵖˡ) ↓u (CompactOptionⁱᵐᵖˡ);
}.

Module CompareTarget.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End CompareTarget.

Class CompareTarget_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] CompareTarget_type_repr  :: go.TypeReprUnderlying CompareTargetⁱᵐᵖˡ CompareTarget.t;
  #[global] CompareTarget_underlying :: (CompareTarget) <u (CompareTargetⁱᵐᵖˡ);
  #[global] CompareTargetⁱᵐᵖˡ_underlying :: (CompareTargetⁱᵐᵖˡ) ↓u (CompareTargetⁱᵐᵖˡ);
}.

Module CompareResult.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End CompareResult.

Class CompareResult_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] CompareResult_type_repr  :: go.TypeReprUnderlying CompareResultⁱᵐᵖˡ CompareResult.t;
  #[global] CompareResult_underlying :: (CompareResult) <u (CompareResultⁱᵐᵖˡ);
  #[global] CompareResultⁱᵐᵖˡ_underlying :: (CompareResultⁱᵐᵖˡ) ↓u (CompareResultⁱᵐᵖˡ);
}.

Module Cmp.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := etcdserverpb.Compare.t.
End def.
End Cmp.

Definition Cmpⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := etcdserverpb.Compare.

Class Cmp_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Cmp_underlying :: (Cmp) <u (Cmpⁱᵐᵖˡ);
}.

Module Config.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End Config.

Class Config_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Config_type_repr  :: go.TypeReprUnderlying Configⁱᵐᵖˡ Config.t;
  #[global] Config_underlying :: (Config) <u (Configⁱᵐᵖˡ);
  #[global] Configⁱᵐᵖˡ_underlying :: (Configⁱᵐᵖˡ) ↓u (Configⁱᵐᵖˡ);
}.

Module ConfigSpec.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End ConfigSpec.

Class ConfigSpec_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] ConfigSpec_type_repr  :: go.TypeReprUnderlying ConfigSpecⁱᵐᵖˡ ConfigSpec.t;
  #[global] ConfigSpec_underlying :: (ConfigSpec) <u (ConfigSpecⁱᵐᵖˡ);
  #[global] ConfigSpecⁱᵐᵖˡ_underlying :: (ConfigSpecⁱᵐᵖˡ) ↓u (ConfigSpecⁱᵐᵖˡ);
}.

Module SecureConfig.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End SecureConfig.

Class SecureConfig_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] SecureConfig_type_repr  :: go.TypeReprUnderlying SecureConfigⁱᵐᵖˡ SecureConfig.t;
  #[global] SecureConfig_underlying :: (SecureConfig) <u (SecureConfigⁱᵐᵖˡ);
  #[global] SecureConfigⁱᵐᵖˡ_underlying :: (SecureConfigⁱᵐᵖˡ) ↓u (SecureConfigⁱᵐᵖˡ);
}.

Module AuthConfig.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End AuthConfig.

Class AuthConfig_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] AuthConfig_type_repr  :: go.TypeReprUnderlying AuthConfigⁱᵐᵖˡ AuthConfig.t;
  #[global] AuthConfig_underlying :: (AuthConfig) <u (AuthConfigⁱᵐᵖˡ);
  #[global] AuthConfigⁱᵐᵖˡ_underlying :: (AuthConfigⁱᵐᵖˡ) ↓u (AuthConfigⁱᵐᵖˡ);
}.

Module CompactResponse.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End CompactResponse.

Class CompactResponse_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] CompactResponse_type_repr  :: go.TypeReprUnderlying CompactResponseⁱᵐᵖˡ CompactResponse.t;
  #[global] CompactResponse_underlying :: (CompactResponse) <u (CompactResponseⁱᵐᵖˡ);
  #[global] CompactResponseⁱᵐᵖˡ_underlying :: (CompactResponseⁱᵐᵖˡ) ↓u (CompactResponseⁱᵐᵖˡ);
}.

Module PutResponse.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := etcdserverpb.PutResponse.t.
End def.
End PutResponse.

Definition PutResponseⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := etcdserverpb.PutResponse.

Class PutResponse_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] PutResponse_underlying :: (PutResponse) <u (PutResponseⁱᵐᵖˡ);
}.

Module GetResponse.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := etcdserverpb.RangeResponse.t.
End def.
End GetResponse.

Definition GetResponseⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := etcdserverpb.RangeResponse.

Class GetResponse_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] GetResponse_underlying :: (GetResponse) <u (GetResponseⁱᵐᵖˡ);
}.

Module DeleteResponse.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := etcdserverpb.DeleteRangeResponse.t.
End def.
End DeleteResponse.

Definition DeleteResponseⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := etcdserverpb.DeleteRangeResponse.

Class DeleteResponse_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] DeleteResponse_underlying :: (DeleteResponse) <u (DeleteResponseⁱᵐᵖˡ);
}.

Module TxnResponse.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := etcdserverpb.TxnResponse.t.
End def.
End TxnResponse.

Definition TxnResponseⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := etcdserverpb.TxnResponse.

Class TxnResponse_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] TxnResponse_underlying :: (TxnResponse) <u (TxnResponseⁱᵐᵖˡ);
}.

Module KV.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := interface.t.
End def.
End KV.

Definition KVⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.InterfaceType [go.MethodElem "Compact"%go (go.Signature [context.Context; go.int64; go.SliceType CompactOption] true [go.PointerType CompactResponse; go.error]); go.MethodElem "Delete"%go (go.Signature [context.Context; go.string; go.SliceType OpOption] true [go.PointerType DeleteResponse; go.error]); go.MethodElem "Do"%go (go.Signature [context.Context; Op] false [OpResponse; go.error]); go.MethodElem "Get"%go (go.Signature [context.Context; go.string; go.SliceType OpOption] true [go.PointerType GetResponse; go.error]); go.MethodElem "Put"%go (go.Signature [context.Context; go.string; go.string; go.SliceType OpOption] true [go.PointerType PutResponse; go.error]); go.MethodElem "Txn"%go (go.Signature [context.Context] false [Txn])].

Class KV_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] KV_underlying :: (KV) <u (KVⁱᵐᵖˡ);
}.

Module OpResponse.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  put' : loc;
  get' : loc;
  del' : loc;
  txn' : loc;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End OpResponse.

Definition OpResponse'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "put"%go (go.PointerType PutResponse));
  (go.FieldDecl "get"%go (go.PointerType GetResponse));
  (go.FieldDecl "del"%go (go.PointerType DeleteResponse));
  (go.FieldDecl "txn"%go (go.PointerType TxnResponse))
].
Program Definition OpResponse'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (OpResponse'fds_unsealed).
Global Instance equals_unfold_OpResponse {ext : ffi_syntax} {go_gctx : GoGlobalContext} : OpResponse'fds =→ OpResponse'fds_unsealed.
Proof. rewrite /OpResponse'fds seal_eq //. Qed.

Definition OpResponseⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (OpResponse'fds).

Class OpResponse_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] OpResponse_type_repr  :: go.TypeReprUnderlying OpResponseⁱᵐᵖˡ OpResponse.t;
  #[global] OpResponse_underlying :: (OpResponse) <u (OpResponseⁱᵐᵖˡ);
  #[global] OpResponse_get_put (x : OpResponse.t) :: ⟦StructFieldGet (OpResponseⁱᵐᵖˡ) "put", #x⟧ ⤳[under] #x.(OpResponse.put');
  #[global] OpResponse_set_put (x : OpResponse.t) y :: ⟦StructFieldSet (OpResponseⁱᵐᵖˡ) "put", (#x, #y)⟧ ⤳[under] #(x <|OpResponse.put' := y|>);
  #[global] OpResponse_get_get (x : OpResponse.t) :: ⟦StructFieldGet (OpResponseⁱᵐᵖˡ) "get", #x⟧ ⤳[under] #x.(OpResponse.get');
  #[global] OpResponse_set_get (x : OpResponse.t) y :: ⟦StructFieldSet (OpResponseⁱᵐᵖˡ) "get", (#x, #y)⟧ ⤳[under] #(x <|OpResponse.get' := y|>);
  #[global] OpResponse_get_del (x : OpResponse.t) :: ⟦StructFieldGet (OpResponseⁱᵐᵖˡ) "del", #x⟧ ⤳[under] #x.(OpResponse.del');
  #[global] OpResponse_set_del (x : OpResponse.t) y :: ⟦StructFieldSet (OpResponseⁱᵐᵖˡ) "del", (#x, #y)⟧ ⤳[under] #(x <|OpResponse.del' := y|>);
  #[global] OpResponse_get_txn (x : OpResponse.t) :: ⟦StructFieldGet (OpResponseⁱᵐᵖˡ) "txn", #x⟧ ⤳[under] #x.(OpResponse.txn');
  #[global] OpResponse_set_txn (x : OpResponse.t) y :: ⟦StructFieldSet (OpResponseⁱᵐᵖˡ) "txn", (#x, #y)⟧ ⤳[under] #(x <|OpResponse.txn' := y|>);
}.

Module kv.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End kv.

Class kv_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] kv_type_repr  :: go.TypeReprUnderlying kvⁱᵐᵖˡ kv.t;
  #[global] kv_underlying :: (kv) <u (kvⁱᵐᵖˡ);
  #[global] kvⁱᵐᵖˡ_underlying :: (kvⁱᵐᵖˡ) ↓u (kvⁱᵐᵖˡ);
}.

Module LeaseRevokeResponse.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End LeaseRevokeResponse.

Class LeaseRevokeResponse_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] LeaseRevokeResponse_type_repr  :: go.TypeReprUnderlying LeaseRevokeResponseⁱᵐᵖˡ LeaseRevokeResponse.t;
  #[global] LeaseRevokeResponse_underlying :: (LeaseRevokeResponse) <u (LeaseRevokeResponseⁱᵐᵖˡ);
  #[global] LeaseRevokeResponseⁱᵐᵖˡ_underlying :: (LeaseRevokeResponseⁱᵐᵖˡ) ↓u (LeaseRevokeResponseⁱᵐᵖˡ);
}.

Module LeaseID.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := w64.
End def.
End LeaseID.

Definition LeaseIDⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.int64.

Class LeaseID_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] LeaseID_underlying :: (LeaseID) <u (LeaseIDⁱᵐᵖˡ);
}.

Module LeaseGrantResponse.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  ResponseHeader' : loc;
  ID' : clientv3.LeaseID.t;
  TTL' : w64;
  Error' : go_string;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End LeaseGrantResponse.

Definition LeaseGrantResponse'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.EmbeddedField "ResponseHeader"%go (go.PointerType etcdserverpb.ResponseHeader));
  (go.FieldDecl "ID"%go LeaseID);
  (go.FieldDecl "TTL"%go go.int64);
  (go.FieldDecl "Error"%go go.string)
].
Program Definition LeaseGrantResponse'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (LeaseGrantResponse'fds_unsealed).
Global Instance equals_unfold_LeaseGrantResponse {ext : ffi_syntax} {go_gctx : GoGlobalContext} : LeaseGrantResponse'fds =→ LeaseGrantResponse'fds_unsealed.
Proof. rewrite /LeaseGrantResponse'fds seal_eq //. Qed.

Definition LeaseGrantResponseⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (LeaseGrantResponse'fds).

Class LeaseGrantResponse_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] LeaseGrantResponse_type_repr  :: go.TypeReprUnderlying LeaseGrantResponseⁱᵐᵖˡ LeaseGrantResponse.t;
  #[global] LeaseGrantResponse_underlying :: (LeaseGrantResponse) <u (LeaseGrantResponseⁱᵐᵖˡ);
  #[global] LeaseGrantResponse_get_ResponseHeader (x : LeaseGrantResponse.t) :: ⟦StructFieldGet (LeaseGrantResponseⁱᵐᵖˡ) "ResponseHeader", #x⟧ ⤳[under] #x.(LeaseGrantResponse.ResponseHeader');
  #[global] LeaseGrantResponse_set_ResponseHeader (x : LeaseGrantResponse.t) y :: ⟦StructFieldSet (LeaseGrantResponseⁱᵐᵖˡ) "ResponseHeader", (#x, #y)⟧ ⤳[under] #(x <|LeaseGrantResponse.ResponseHeader' := y|>);
  #[global] LeaseGrantResponse_get_ID (x : LeaseGrantResponse.t) :: ⟦StructFieldGet (LeaseGrantResponseⁱᵐᵖˡ) "ID", #x⟧ ⤳[under] #x.(LeaseGrantResponse.ID');
  #[global] LeaseGrantResponse_set_ID (x : LeaseGrantResponse.t) y :: ⟦StructFieldSet (LeaseGrantResponseⁱᵐᵖˡ) "ID", (#x, #y)⟧ ⤳[under] #(x <|LeaseGrantResponse.ID' := y|>);
  #[global] LeaseGrantResponse_get_TTL (x : LeaseGrantResponse.t) :: ⟦StructFieldGet (LeaseGrantResponseⁱᵐᵖˡ) "TTL", #x⟧ ⤳[under] #x.(LeaseGrantResponse.TTL');
  #[global] LeaseGrantResponse_set_TTL (x : LeaseGrantResponse.t) y :: ⟦StructFieldSet (LeaseGrantResponseⁱᵐᵖˡ) "TTL", (#x, #y)⟧ ⤳[under] #(x <|LeaseGrantResponse.TTL' := y|>);
  #[global] LeaseGrantResponse_get_Error (x : LeaseGrantResponse.t) :: ⟦StructFieldGet (LeaseGrantResponseⁱᵐᵖˡ) "Error", #x⟧ ⤳[under] #x.(LeaseGrantResponse.Error');
  #[global] LeaseGrantResponse_set_Error (x : LeaseGrantResponse.t) y :: ⟦StructFieldSet (LeaseGrantResponseⁱᵐᵖˡ) "Error", (#x, #y)⟧ ⤳[under] #(x <|LeaseGrantResponse.Error' := y|>);
}.

Module LeaseKeepAliveResponse.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End LeaseKeepAliveResponse.

Class LeaseKeepAliveResponse_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] LeaseKeepAliveResponse_type_repr  :: go.TypeReprUnderlying LeaseKeepAliveResponseⁱᵐᵖˡ LeaseKeepAliveResponse.t;
  #[global] LeaseKeepAliveResponse_underlying :: (LeaseKeepAliveResponse) <u (LeaseKeepAliveResponseⁱᵐᵖˡ);
  #[global] LeaseKeepAliveResponseⁱᵐᵖˡ_underlying :: (LeaseKeepAliveResponseⁱᵐᵖˡ) ↓u (LeaseKeepAliveResponseⁱᵐᵖˡ);
}.

Module LeaseTimeToLiveResponse.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End LeaseTimeToLiveResponse.

Class LeaseTimeToLiveResponse_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] LeaseTimeToLiveResponse_type_repr  :: go.TypeReprUnderlying LeaseTimeToLiveResponseⁱᵐᵖˡ LeaseTimeToLiveResponse.t;
  #[global] LeaseTimeToLiveResponse_underlying :: (LeaseTimeToLiveResponse) <u (LeaseTimeToLiveResponseⁱᵐᵖˡ);
  #[global] LeaseTimeToLiveResponseⁱᵐᵖˡ_underlying :: (LeaseTimeToLiveResponseⁱᵐᵖˡ) ↓u (LeaseTimeToLiveResponseⁱᵐᵖˡ);
}.

Module LeaseStatus.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End LeaseStatus.

Class LeaseStatus_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] LeaseStatus_type_repr  :: go.TypeReprUnderlying LeaseStatusⁱᵐᵖˡ LeaseStatus.t;
  #[global] LeaseStatus_underlying :: (LeaseStatus) <u (LeaseStatusⁱᵐᵖˡ);
  #[global] LeaseStatusⁱᵐᵖˡ_underlying :: (LeaseStatusⁱᵐᵖˡ) ↓u (LeaseStatusⁱᵐᵖˡ);
}.

Module LeaseLeasesResponse.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End LeaseLeasesResponse.

Class LeaseLeasesResponse_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] LeaseLeasesResponse_type_repr  :: go.TypeReprUnderlying LeaseLeasesResponseⁱᵐᵖˡ LeaseLeasesResponse.t;
  #[global] LeaseLeasesResponse_underlying :: (LeaseLeasesResponse) <u (LeaseLeasesResponseⁱᵐᵖˡ);
  #[global] LeaseLeasesResponseⁱᵐᵖˡ_underlying :: (LeaseLeasesResponseⁱᵐᵖˡ) ↓u (LeaseLeasesResponseⁱᵐᵖˡ);
}.

Module ErrKeepAliveHalted.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End ErrKeepAliveHalted.

Class ErrKeepAliveHalted_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] ErrKeepAliveHalted_type_repr  :: go.TypeReprUnderlying ErrKeepAliveHaltedⁱᵐᵖˡ ErrKeepAliveHalted.t;
  #[global] ErrKeepAliveHalted_underlying :: (ErrKeepAliveHalted) <u (ErrKeepAliveHaltedⁱᵐᵖˡ);
  #[global] ErrKeepAliveHaltedⁱᵐᵖˡ_underlying :: (ErrKeepAliveHaltedⁱᵐᵖˡ) ↓u (ErrKeepAliveHaltedⁱᵐᵖˡ);
}.

Module Lease.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := interface.t.
End def.
End Lease.

Definition Leaseⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.InterfaceType [go.MethodElem "Close"%go (go.Signature [] false [go.error]); go.MethodElem "Grant"%go (go.Signature [context.Context; go.int64] false [go.PointerType LeaseGrantResponse; go.error]); go.MethodElem "KeepAlive"%go (go.Signature [context.Context; LeaseID] false [go.ChannelType go.recvonly (go.PointerType LeaseKeepAliveResponse); go.error]); go.MethodElem "KeepAliveOnce"%go (go.Signature [context.Context; LeaseID] false [go.PointerType LeaseKeepAliveResponse; go.error]); go.MethodElem "Leases"%go (go.Signature [context.Context] false [go.PointerType LeaseLeasesResponse; go.error]); go.MethodElem "Revoke"%go (go.Signature [context.Context; LeaseID] false [go.PointerType LeaseRevokeResponse; go.error]); go.MethodElem "TimeToLive"%go (go.Signature [context.Context; LeaseID; go.SliceType LeaseOption] true [go.PointerType LeaseTimeToLiveResponse; go.error])].

Class Lease_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Lease_underlying :: (Lease) <u (Leaseⁱᵐᵖˡ);
}.

Module lessor.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End lessor.

Class lessor_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] lessor_type_repr  :: go.TypeReprUnderlying lessorⁱᵐᵖˡ lessor.t;
  #[global] lessor_underlying :: (lessor) <u (lessorⁱᵐᵖˡ);
  #[global] lessorⁱᵐᵖˡ_underlying :: (lessorⁱᵐᵖˡ) ↓u (lessorⁱᵐᵖˡ);
}.

Module keepAlive.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End keepAlive.

Class keepAlive_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] keepAlive_type_repr  :: go.TypeReprUnderlying keepAliveⁱᵐᵖˡ keepAlive.t;
  #[global] keepAlive_underlying :: (keepAlive) <u (keepAliveⁱᵐᵖˡ);
  #[global] keepAliveⁱᵐᵖˡ_underlying :: (keepAliveⁱᵐᵖˡ) ↓u (keepAliveⁱᵐᵖˡ);
}.

Module keepAliveCtxKey.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End keepAliveCtxKey.

Class keepAliveCtxKey_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] keepAliveCtxKey_type_repr  :: go.TypeReprUnderlying keepAliveCtxKeyⁱᵐᵖˡ keepAliveCtxKey.t;
  #[global] keepAliveCtxKey_underlying :: (keepAliveCtxKey) <u (keepAliveCtxKeyⁱᵐᵖˡ);
  #[global] keepAliveCtxKeyⁱᵐᵖˡ_underlying :: (keepAliveCtxKeyⁱᵐᵖˡ) ↓u (keepAliveCtxKeyⁱᵐᵖˡ);
}.

Module DefragmentResponse.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End DefragmentResponse.

Class DefragmentResponse_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] DefragmentResponse_type_repr  :: go.TypeReprUnderlying DefragmentResponseⁱᵐᵖˡ DefragmentResponse.t;
  #[global] DefragmentResponse_underlying :: (DefragmentResponse) <u (DefragmentResponseⁱᵐᵖˡ);
  #[global] DefragmentResponseⁱᵐᵖˡ_underlying :: (DefragmentResponseⁱᵐᵖˡ) ↓u (DefragmentResponseⁱᵐᵖˡ);
}.

Module AlarmResponse.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End AlarmResponse.

Class AlarmResponse_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] AlarmResponse_type_repr  :: go.TypeReprUnderlying AlarmResponseⁱᵐᵖˡ AlarmResponse.t;
  #[global] AlarmResponse_underlying :: (AlarmResponse) <u (AlarmResponseⁱᵐᵖˡ);
  #[global] AlarmResponseⁱᵐᵖˡ_underlying :: (AlarmResponseⁱᵐᵖˡ) ↓u (AlarmResponseⁱᵐᵖˡ);
}.

Module AlarmMember.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End AlarmMember.

Class AlarmMember_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] AlarmMember_type_repr  :: go.TypeReprUnderlying AlarmMemberⁱᵐᵖˡ AlarmMember.t;
  #[global] AlarmMember_underlying :: (AlarmMember) <u (AlarmMemberⁱᵐᵖˡ);
  #[global] AlarmMemberⁱᵐᵖˡ_underlying :: (AlarmMemberⁱᵐᵖˡ) ↓u (AlarmMemberⁱᵐᵖˡ);
}.

Module StatusResponse.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End StatusResponse.

Class StatusResponse_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] StatusResponse_type_repr  :: go.TypeReprUnderlying StatusResponseⁱᵐᵖˡ StatusResponse.t;
  #[global] StatusResponse_underlying :: (StatusResponse) <u (StatusResponseⁱᵐᵖˡ);
  #[global] StatusResponseⁱᵐᵖˡ_underlying :: (StatusResponseⁱᵐᵖˡ) ↓u (StatusResponseⁱᵐᵖˡ);
}.

Module HashKVResponse.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End HashKVResponse.

Class HashKVResponse_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] HashKVResponse_type_repr  :: go.TypeReprUnderlying HashKVResponseⁱᵐᵖˡ HashKVResponse.t;
  #[global] HashKVResponse_underlying :: (HashKVResponse) <u (HashKVResponseⁱᵐᵖˡ);
  #[global] HashKVResponseⁱᵐᵖˡ_underlying :: (HashKVResponseⁱᵐᵖˡ) ↓u (HashKVResponseⁱᵐᵖˡ);
}.

Module MoveLeaderResponse.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End MoveLeaderResponse.

Class MoveLeaderResponse_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] MoveLeaderResponse_type_repr  :: go.TypeReprUnderlying MoveLeaderResponseⁱᵐᵖˡ MoveLeaderResponse.t;
  #[global] MoveLeaderResponse_underlying :: (MoveLeaderResponse) <u (MoveLeaderResponseⁱᵐᵖˡ);
  #[global] MoveLeaderResponseⁱᵐᵖˡ_underlying :: (MoveLeaderResponseⁱᵐᵖˡ) ↓u (MoveLeaderResponseⁱᵐᵖˡ);
}.

Module DowngradeResponse.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End DowngradeResponse.

Class DowngradeResponse_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] DowngradeResponse_type_repr  :: go.TypeReprUnderlying DowngradeResponseⁱᵐᵖˡ DowngradeResponse.t;
  #[global] DowngradeResponse_underlying :: (DowngradeResponse) <u (DowngradeResponseⁱᵐᵖˡ);
  #[global] DowngradeResponseⁱᵐᵖˡ_underlying :: (DowngradeResponseⁱᵐᵖˡ) ↓u (DowngradeResponseⁱᵐᵖˡ);
}.

Module DowngradeAction.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End DowngradeAction.

Class DowngradeAction_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] DowngradeAction_type_repr  :: go.TypeReprUnderlying DowngradeActionⁱᵐᵖˡ DowngradeAction.t;
  #[global] DowngradeAction_underlying :: (DowngradeAction) <u (DowngradeActionⁱᵐᵖˡ);
  #[global] DowngradeActionⁱᵐᵖˡ_underlying :: (DowngradeActionⁱᵐᵖˡ) ↓u (DowngradeActionⁱᵐᵖˡ);
}.

Module Maintenance.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End Maintenance.

Class Maintenance_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Maintenance_type_repr  :: go.TypeReprUnderlying Maintenanceⁱᵐᵖˡ Maintenance.t;
  #[global] Maintenance_underlying :: (Maintenance) <u (Maintenanceⁱᵐᵖˡ);
  #[global] Maintenanceⁱᵐᵖˡ_underlying :: (Maintenanceⁱᵐᵖˡ) ↓u (Maintenanceⁱᵐᵖˡ);
}.

Module SnapshotResponse.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End SnapshotResponse.

Class SnapshotResponse_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] SnapshotResponse_type_repr  :: go.TypeReprUnderlying SnapshotResponseⁱᵐᵖˡ SnapshotResponse.t;
  #[global] SnapshotResponse_underlying :: (SnapshotResponse) <u (SnapshotResponseⁱᵐᵖˡ);
  #[global] SnapshotResponseⁱᵐᵖˡ_underlying :: (SnapshotResponseⁱᵐᵖˡ) ↓u (SnapshotResponseⁱᵐᵖˡ);
}.

Module maintenance.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End maintenance.

Class maintenance_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] maintenance_type_repr  :: go.TypeReprUnderlying maintenanceⁱᵐᵖˡ maintenance.t;
  #[global] maintenance_underlying :: (maintenance) <u (maintenanceⁱᵐᵖˡ);
  #[global] maintenanceⁱᵐᵖˡ_underlying :: (maintenanceⁱᵐᵖˡ) ↓u (maintenanceⁱᵐᵖˡ);
}.

Module snapshotReadCloser.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End snapshotReadCloser.

Class snapshotReadCloser_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] snapshotReadCloser_type_repr  :: go.TypeReprUnderlying snapshotReadCloserⁱᵐᵖˡ snapshotReadCloser.t;
  #[global] snapshotReadCloser_underlying :: (snapshotReadCloser) <u (snapshotReadCloserⁱᵐᵖˡ);
  #[global] snapshotReadCloserⁱᵐᵖˡ_underlying :: (snapshotReadCloserⁱᵐᵖˡ) ↓u (snapshotReadCloserⁱᵐᵖˡ);
}.

Module opType.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := w64.
End def.
End opType.

Definition opTypeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.int.

Class opType_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] opType_underlying :: (opType) <u (opTypeⁱᵐᵖˡ);
}.

Module Op.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  t' : clientv3.opType.t;
  key' : slice.t;
  end' : slice.t;
  limit' : w64;
  sort' : loc;
  serializable' : bool;
  keysOnly' : bool;
  countOnly' : bool;
  minModRev' : w64;
  maxModRev' : w64;
  minCreateRev' : w64;
  maxCreateRev' : w64;
  rev' : w64;
  prevKV' : bool;
  fragment' : bool;
  ignoreValue' : bool;
  ignoreLease' : bool;
  progressNotify' : bool;
  createdNotify' : bool;
  filterPut' : bool;
  filterDelete' : bool;
  val' : slice.t;
  leaseID' : clientv3.LeaseID.t;
  cmps' : slice.t;
  thenOps' : slice.t;
  elseOps' : slice.t;
  isOptsWithFromKey' : bool;
  isOptsWithPrefix' : bool;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End Op.

Definition Op'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "t"%go opType);
  (go.FieldDecl "key"%go (go.SliceType go.byte));
  (go.FieldDecl "end"%go (go.SliceType go.byte));
  (go.FieldDecl "limit"%go go.int64);
  (go.FieldDecl "sort"%go (go.PointerType SortOption));
  (go.FieldDecl "serializable"%go go.bool);
  (go.FieldDecl "keysOnly"%go go.bool);
  (go.FieldDecl "countOnly"%go go.bool);
  (go.FieldDecl "minModRev"%go go.int64);
  (go.FieldDecl "maxModRev"%go go.int64);
  (go.FieldDecl "minCreateRev"%go go.int64);
  (go.FieldDecl "maxCreateRev"%go go.int64);
  (go.FieldDecl "rev"%go go.int64);
  (go.FieldDecl "prevKV"%go go.bool);
  (go.FieldDecl "fragment"%go go.bool);
  (go.FieldDecl "ignoreValue"%go go.bool);
  (go.FieldDecl "ignoreLease"%go go.bool);
  (go.FieldDecl "progressNotify"%go go.bool);
  (go.FieldDecl "createdNotify"%go go.bool);
  (go.FieldDecl "filterPut"%go go.bool);
  (go.FieldDecl "filterDelete"%go go.bool);
  (go.FieldDecl "val"%go (go.SliceType go.byte));
  (go.FieldDecl "leaseID"%go LeaseID);
  (go.FieldDecl "cmps"%go (go.SliceType Cmp));
  (go.FieldDecl "thenOps"%go (go.SliceType Op));
  (go.FieldDecl "elseOps"%go (go.SliceType Op));
  (go.FieldDecl "isOptsWithFromKey"%go go.bool);
  (go.FieldDecl "isOptsWithPrefix"%go go.bool)
].
Program Definition Op'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (Op'fds_unsealed).
Global Instance equals_unfold_Op {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Op'fds =→ Op'fds_unsealed.
Proof. rewrite /Op'fds seal_eq //. Qed.

Definition Opⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (Op'fds).

Class Op_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Op_type_repr  :: go.TypeReprUnderlying Opⁱᵐᵖˡ Op.t;
  #[global] Op_underlying :: (Op) <u (Opⁱᵐᵖˡ);
  #[global] Op_get_t (x : Op.t) :: ⟦StructFieldGet (Opⁱᵐᵖˡ) "t", #x⟧ ⤳[under] #x.(Op.t');
  #[global] Op_set_t (x : Op.t) y :: ⟦StructFieldSet (Opⁱᵐᵖˡ) "t", (#x, #y)⟧ ⤳[under] #(x <|Op.t' := y|>);
  #[global] Op_get_key (x : Op.t) :: ⟦StructFieldGet (Opⁱᵐᵖˡ) "key", #x⟧ ⤳[under] #x.(Op.key');
  #[global] Op_set_key (x : Op.t) y :: ⟦StructFieldSet (Opⁱᵐᵖˡ) "key", (#x, #y)⟧ ⤳[under] #(x <|Op.key' := y|>);
  #[global] Op_get_end (x : Op.t) :: ⟦StructFieldGet (Opⁱᵐᵖˡ) "end", #x⟧ ⤳[under] #x.(Op.end');
  #[global] Op_set_end (x : Op.t) y :: ⟦StructFieldSet (Opⁱᵐᵖˡ) "end", (#x, #y)⟧ ⤳[under] #(x <|Op.end' := y|>);
  #[global] Op_get_limit (x : Op.t) :: ⟦StructFieldGet (Opⁱᵐᵖˡ) "limit", #x⟧ ⤳[under] #x.(Op.limit');
  #[global] Op_set_limit (x : Op.t) y :: ⟦StructFieldSet (Opⁱᵐᵖˡ) "limit", (#x, #y)⟧ ⤳[under] #(x <|Op.limit' := y|>);
  #[global] Op_get_sort (x : Op.t) :: ⟦StructFieldGet (Opⁱᵐᵖˡ) "sort", #x⟧ ⤳[under] #x.(Op.sort');
  #[global] Op_set_sort (x : Op.t) y :: ⟦StructFieldSet (Opⁱᵐᵖˡ) "sort", (#x, #y)⟧ ⤳[under] #(x <|Op.sort' := y|>);
  #[global] Op_get_serializable (x : Op.t) :: ⟦StructFieldGet (Opⁱᵐᵖˡ) "serializable", #x⟧ ⤳[under] #x.(Op.serializable');
  #[global] Op_set_serializable (x : Op.t) y :: ⟦StructFieldSet (Opⁱᵐᵖˡ) "serializable", (#x, #y)⟧ ⤳[under] #(x <|Op.serializable' := y|>);
  #[global] Op_get_keysOnly (x : Op.t) :: ⟦StructFieldGet (Opⁱᵐᵖˡ) "keysOnly", #x⟧ ⤳[under] #x.(Op.keysOnly');
  #[global] Op_set_keysOnly (x : Op.t) y :: ⟦StructFieldSet (Opⁱᵐᵖˡ) "keysOnly", (#x, #y)⟧ ⤳[under] #(x <|Op.keysOnly' := y|>);
  #[global] Op_get_countOnly (x : Op.t) :: ⟦StructFieldGet (Opⁱᵐᵖˡ) "countOnly", #x⟧ ⤳[under] #x.(Op.countOnly');
  #[global] Op_set_countOnly (x : Op.t) y :: ⟦StructFieldSet (Opⁱᵐᵖˡ) "countOnly", (#x, #y)⟧ ⤳[under] #(x <|Op.countOnly' := y|>);
  #[global] Op_get_minModRev (x : Op.t) :: ⟦StructFieldGet (Opⁱᵐᵖˡ) "minModRev", #x⟧ ⤳[under] #x.(Op.minModRev');
  #[global] Op_set_minModRev (x : Op.t) y :: ⟦StructFieldSet (Opⁱᵐᵖˡ) "minModRev", (#x, #y)⟧ ⤳[under] #(x <|Op.minModRev' := y|>);
  #[global] Op_get_maxModRev (x : Op.t) :: ⟦StructFieldGet (Opⁱᵐᵖˡ) "maxModRev", #x⟧ ⤳[under] #x.(Op.maxModRev');
  #[global] Op_set_maxModRev (x : Op.t) y :: ⟦StructFieldSet (Opⁱᵐᵖˡ) "maxModRev", (#x, #y)⟧ ⤳[under] #(x <|Op.maxModRev' := y|>);
  #[global] Op_get_minCreateRev (x : Op.t) :: ⟦StructFieldGet (Opⁱᵐᵖˡ) "minCreateRev", #x⟧ ⤳[under] #x.(Op.minCreateRev');
  #[global] Op_set_minCreateRev (x : Op.t) y :: ⟦StructFieldSet (Opⁱᵐᵖˡ) "minCreateRev", (#x, #y)⟧ ⤳[under] #(x <|Op.minCreateRev' := y|>);
  #[global] Op_get_maxCreateRev (x : Op.t) :: ⟦StructFieldGet (Opⁱᵐᵖˡ) "maxCreateRev", #x⟧ ⤳[under] #x.(Op.maxCreateRev');
  #[global] Op_set_maxCreateRev (x : Op.t) y :: ⟦StructFieldSet (Opⁱᵐᵖˡ) "maxCreateRev", (#x, #y)⟧ ⤳[under] #(x <|Op.maxCreateRev' := y|>);
  #[global] Op_get_rev (x : Op.t) :: ⟦StructFieldGet (Opⁱᵐᵖˡ) "rev", #x⟧ ⤳[under] #x.(Op.rev');
  #[global] Op_set_rev (x : Op.t) y :: ⟦StructFieldSet (Opⁱᵐᵖˡ) "rev", (#x, #y)⟧ ⤳[under] #(x <|Op.rev' := y|>);
  #[global] Op_get_prevKV (x : Op.t) :: ⟦StructFieldGet (Opⁱᵐᵖˡ) "prevKV", #x⟧ ⤳[under] #x.(Op.prevKV');
  #[global] Op_set_prevKV (x : Op.t) y :: ⟦StructFieldSet (Opⁱᵐᵖˡ) "prevKV", (#x, #y)⟧ ⤳[under] #(x <|Op.prevKV' := y|>);
  #[global] Op_get_fragment (x : Op.t) :: ⟦StructFieldGet (Opⁱᵐᵖˡ) "fragment", #x⟧ ⤳[under] #x.(Op.fragment');
  #[global] Op_set_fragment (x : Op.t) y :: ⟦StructFieldSet (Opⁱᵐᵖˡ) "fragment", (#x, #y)⟧ ⤳[under] #(x <|Op.fragment' := y|>);
  #[global] Op_get_ignoreValue (x : Op.t) :: ⟦StructFieldGet (Opⁱᵐᵖˡ) "ignoreValue", #x⟧ ⤳[under] #x.(Op.ignoreValue');
  #[global] Op_set_ignoreValue (x : Op.t) y :: ⟦StructFieldSet (Opⁱᵐᵖˡ) "ignoreValue", (#x, #y)⟧ ⤳[under] #(x <|Op.ignoreValue' := y|>);
  #[global] Op_get_ignoreLease (x : Op.t) :: ⟦StructFieldGet (Opⁱᵐᵖˡ) "ignoreLease", #x⟧ ⤳[under] #x.(Op.ignoreLease');
  #[global] Op_set_ignoreLease (x : Op.t) y :: ⟦StructFieldSet (Opⁱᵐᵖˡ) "ignoreLease", (#x, #y)⟧ ⤳[under] #(x <|Op.ignoreLease' := y|>);
  #[global] Op_get_progressNotify (x : Op.t) :: ⟦StructFieldGet (Opⁱᵐᵖˡ) "progressNotify", #x⟧ ⤳[under] #x.(Op.progressNotify');
  #[global] Op_set_progressNotify (x : Op.t) y :: ⟦StructFieldSet (Opⁱᵐᵖˡ) "progressNotify", (#x, #y)⟧ ⤳[under] #(x <|Op.progressNotify' := y|>);
  #[global] Op_get_createdNotify (x : Op.t) :: ⟦StructFieldGet (Opⁱᵐᵖˡ) "createdNotify", #x⟧ ⤳[under] #x.(Op.createdNotify');
  #[global] Op_set_createdNotify (x : Op.t) y :: ⟦StructFieldSet (Opⁱᵐᵖˡ) "createdNotify", (#x, #y)⟧ ⤳[under] #(x <|Op.createdNotify' := y|>);
  #[global] Op_get_filterPut (x : Op.t) :: ⟦StructFieldGet (Opⁱᵐᵖˡ) "filterPut", #x⟧ ⤳[under] #x.(Op.filterPut');
  #[global] Op_set_filterPut (x : Op.t) y :: ⟦StructFieldSet (Opⁱᵐᵖˡ) "filterPut", (#x, #y)⟧ ⤳[under] #(x <|Op.filterPut' := y|>);
  #[global] Op_get_filterDelete (x : Op.t) :: ⟦StructFieldGet (Opⁱᵐᵖˡ) "filterDelete", #x⟧ ⤳[under] #x.(Op.filterDelete');
  #[global] Op_set_filterDelete (x : Op.t) y :: ⟦StructFieldSet (Opⁱᵐᵖˡ) "filterDelete", (#x, #y)⟧ ⤳[under] #(x <|Op.filterDelete' := y|>);
  #[global] Op_get_val (x : Op.t) :: ⟦StructFieldGet (Opⁱᵐᵖˡ) "val", #x⟧ ⤳[under] #x.(Op.val');
  #[global] Op_set_val (x : Op.t) y :: ⟦StructFieldSet (Opⁱᵐᵖˡ) "val", (#x, #y)⟧ ⤳[under] #(x <|Op.val' := y|>);
  #[global] Op_get_leaseID (x : Op.t) :: ⟦StructFieldGet (Opⁱᵐᵖˡ) "leaseID", #x⟧ ⤳[under] #x.(Op.leaseID');
  #[global] Op_set_leaseID (x : Op.t) y :: ⟦StructFieldSet (Opⁱᵐᵖˡ) "leaseID", (#x, #y)⟧ ⤳[under] #(x <|Op.leaseID' := y|>);
  #[global] Op_get_cmps (x : Op.t) :: ⟦StructFieldGet (Opⁱᵐᵖˡ) "cmps", #x⟧ ⤳[under] #x.(Op.cmps');
  #[global] Op_set_cmps (x : Op.t) y :: ⟦StructFieldSet (Opⁱᵐᵖˡ) "cmps", (#x, #y)⟧ ⤳[under] #(x <|Op.cmps' := y|>);
  #[global] Op_get_thenOps (x : Op.t) :: ⟦StructFieldGet (Opⁱᵐᵖˡ) "thenOps", #x⟧ ⤳[under] #x.(Op.thenOps');
  #[global] Op_set_thenOps (x : Op.t) y :: ⟦StructFieldSet (Opⁱᵐᵖˡ) "thenOps", (#x, #y)⟧ ⤳[under] #(x <|Op.thenOps' := y|>);
  #[global] Op_get_elseOps (x : Op.t) :: ⟦StructFieldGet (Opⁱᵐᵖˡ) "elseOps", #x⟧ ⤳[under] #x.(Op.elseOps');
  #[global] Op_set_elseOps (x : Op.t) y :: ⟦StructFieldSet (Opⁱᵐᵖˡ) "elseOps", (#x, #y)⟧ ⤳[under] #(x <|Op.elseOps' := y|>);
  #[global] Op_get_isOptsWithFromKey (x : Op.t) :: ⟦StructFieldGet (Opⁱᵐᵖˡ) "isOptsWithFromKey", #x⟧ ⤳[under] #x.(Op.isOptsWithFromKey');
  #[global] Op_set_isOptsWithFromKey (x : Op.t) y :: ⟦StructFieldSet (Opⁱᵐᵖˡ) "isOptsWithFromKey", (#x, #y)⟧ ⤳[under] #(x <|Op.isOptsWithFromKey' := y|>);
  #[global] Op_get_isOptsWithPrefix (x : Op.t) :: ⟦StructFieldGet (Opⁱᵐᵖˡ) "isOptsWithPrefix", #x⟧ ⤳[under] #x.(Op.isOptsWithPrefix');
  #[global] Op_set_isOptsWithPrefix (x : Op.t) y :: ⟦StructFieldSet (Opⁱᵐᵖˡ) "isOptsWithPrefix", (#x, #y)⟧ ⤳[under] #(x <|Op.isOptsWithPrefix' := y|>);
  #[global] Op_IsCountOnly_unfold :: MethodUnfold (Op) "IsCountOnly" (Op__IsCountOnlyⁱᵐᵖˡ);
  #[global] Op_IsDelete_unfold :: MethodUnfold (Op) "IsDelete" (Op__IsDeleteⁱᵐᵖˡ);
  #[global] Op_IsGet_unfold :: MethodUnfold (Op) "IsGet" (Op__IsGetⁱᵐᵖˡ);
  #[global] Op_IsKeysOnly_unfold :: MethodUnfold (Op) "IsKeysOnly" (Op__IsKeysOnlyⁱᵐᵖˡ);
  #[global] Op_IsOptsWithFromKey_unfold :: MethodUnfold (Op) "IsOptsWithFromKey" (Op__IsOptsWithFromKeyⁱᵐᵖˡ);
  #[global] Op_IsOptsWithPrefix_unfold :: MethodUnfold (Op) "IsOptsWithPrefix" (Op__IsOptsWithPrefixⁱᵐᵖˡ);
  #[global] Op_IsPut_unfold :: MethodUnfold (Op) "IsPut" (Op__IsPutⁱᵐᵖˡ);
  #[global] Op_IsSerializable_unfold :: MethodUnfold (Op) "IsSerializable" (Op__IsSerializableⁱᵐᵖˡ);
  #[global] Op_IsSortOptionValid_unfold :: MethodUnfold (Op) "IsSortOptionValid" (Op__IsSortOptionValidⁱᵐᵖˡ);
  #[global] Op_IsTxn_unfold :: MethodUnfold (Op) "IsTxn" (Op__IsTxnⁱᵐᵖˡ);
  #[global] Op_KeyBytes_unfold :: MethodUnfold (Op) "KeyBytes" (Op__KeyBytesⁱᵐᵖˡ);
  #[global] Op_MaxCreateRev_unfold :: MethodUnfold (Op) "MaxCreateRev" (Op__MaxCreateRevⁱᵐᵖˡ);
  #[global] Op_MaxModRev_unfold :: MethodUnfold (Op) "MaxModRev" (Op__MaxModRevⁱᵐᵖˡ);
  #[global] Op_MinCreateRev_unfold :: MethodUnfold (Op) "MinCreateRev" (Op__MinCreateRevⁱᵐᵖˡ);
  #[global] Op_MinModRev_unfold :: MethodUnfold (Op) "MinModRev" (Op__MinModRevⁱᵐᵖˡ);
  #[global] Op_RangeBytes_unfold :: MethodUnfold (Op) "RangeBytes" (Op__RangeBytesⁱᵐᵖˡ);
  #[global] Op_Rev_unfold :: MethodUnfold (Op) "Rev" (Op__Revⁱᵐᵖˡ);
  #[global] Op_Txn_unfold :: MethodUnfold (Op) "Txn" (Op__Txnⁱᵐᵖˡ);
  #[global] Op_ValueBytes_unfold :: MethodUnfold (Op) "ValueBytes" (Op__ValueBytesⁱᵐᵖˡ);
  #[global] Op_isWrite_unfold :: MethodUnfold (Op) "isWrite" (Op__isWriteⁱᵐᵖˡ);
  #[global] Op_toRangeRequest_unfold :: MethodUnfold (Op) "toRangeRequest" (Op__toRangeRequestⁱᵐᵖˡ);
  #[global] Op_toRequestOp_unfold :: MethodUnfold (Op) "toRequestOp" (Op__toRequestOpⁱᵐᵖˡ);
  #[global] Op_toTxnRequest_unfold :: MethodUnfold (Op) "toTxnRequest" (Op__toTxnRequestⁱᵐᵖˡ);
  #[global] Op'ptr_IsCountOnly_unfold :: MethodUnfold (go.PointerType (Op)) "IsCountOnly" (λ: "$r", MethodResolve (Op) "IsCountOnly" (![(Op)] "$r"));
  #[global] Op'ptr_IsDelete_unfold :: MethodUnfold (go.PointerType (Op)) "IsDelete" (λ: "$r", MethodResolve (Op) "IsDelete" (![(Op)] "$r"));
  #[global] Op'ptr_IsGet_unfold :: MethodUnfold (go.PointerType (Op)) "IsGet" (λ: "$r", MethodResolve (Op) "IsGet" (![(Op)] "$r"));
  #[global] Op'ptr_IsKeysOnly_unfold :: MethodUnfold (go.PointerType (Op)) "IsKeysOnly" (λ: "$r", MethodResolve (Op) "IsKeysOnly" (![(Op)] "$r"));
  #[global] Op'ptr_IsOptsWithFromKey_unfold :: MethodUnfold (go.PointerType (Op)) "IsOptsWithFromKey" (λ: "$r", MethodResolve (Op) "IsOptsWithFromKey" (![(Op)] "$r"));
  #[global] Op'ptr_IsOptsWithPrefix_unfold :: MethodUnfold (go.PointerType (Op)) "IsOptsWithPrefix" (λ: "$r", MethodResolve (Op) "IsOptsWithPrefix" (![(Op)] "$r"));
  #[global] Op'ptr_IsPut_unfold :: MethodUnfold (go.PointerType (Op)) "IsPut" (λ: "$r", MethodResolve (Op) "IsPut" (![(Op)] "$r"));
  #[global] Op'ptr_IsSerializable_unfold :: MethodUnfold (go.PointerType (Op)) "IsSerializable" (λ: "$r", MethodResolve (Op) "IsSerializable" (![(Op)] "$r"));
  #[global] Op'ptr_IsSortOptionValid_unfold :: MethodUnfold (go.PointerType (Op)) "IsSortOptionValid" (λ: "$r", MethodResolve (Op) "IsSortOptionValid" (![(Op)] "$r"));
  #[global] Op'ptr_IsTxn_unfold :: MethodUnfold (go.PointerType (Op)) "IsTxn" (λ: "$r", MethodResolve (Op) "IsTxn" (![(Op)] "$r"));
  #[global] Op'ptr_KeyBytes_unfold :: MethodUnfold (go.PointerType (Op)) "KeyBytes" (λ: "$r", MethodResolve (Op) "KeyBytes" (![(Op)] "$r"));
  #[global] Op'ptr_MaxCreateRev_unfold :: MethodUnfold (go.PointerType (Op)) "MaxCreateRev" (λ: "$r", MethodResolve (Op) "MaxCreateRev" (![(Op)] "$r"));
  #[global] Op'ptr_MaxModRev_unfold :: MethodUnfold (go.PointerType (Op)) "MaxModRev" (λ: "$r", MethodResolve (Op) "MaxModRev" (![(Op)] "$r"));
  #[global] Op'ptr_MinCreateRev_unfold :: MethodUnfold (go.PointerType (Op)) "MinCreateRev" (λ: "$r", MethodResolve (Op) "MinCreateRev" (![(Op)] "$r"));
  #[global] Op'ptr_MinModRev_unfold :: MethodUnfold (go.PointerType (Op)) "MinModRev" (λ: "$r", MethodResolve (Op) "MinModRev" (![(Op)] "$r"));
  #[global] Op'ptr_RangeBytes_unfold :: MethodUnfold (go.PointerType (Op)) "RangeBytes" (λ: "$r", MethodResolve (Op) "RangeBytes" (![(Op)] "$r"));
  #[global] Op'ptr_Rev_unfold :: MethodUnfold (go.PointerType (Op)) "Rev" (λ: "$r", MethodResolve (Op) "Rev" (![(Op)] "$r"));
  #[global] Op'ptr_Txn_unfold :: MethodUnfold (go.PointerType (Op)) "Txn" (λ: "$r", MethodResolve (Op) "Txn" (![(Op)] "$r"));
  #[global] Op'ptr_ValueBytes_unfold :: MethodUnfold (go.PointerType (Op)) "ValueBytes" (λ: "$r", MethodResolve (Op) "ValueBytes" (![(Op)] "$r"));
  #[global] Op'ptr_WithKeyBytes_unfold :: MethodUnfold (go.PointerType (Op)) "WithKeyBytes" (Op__WithKeyBytesⁱᵐᵖˡ);
  #[global] Op'ptr_WithRangeBytes_unfold :: MethodUnfold (go.PointerType (Op)) "WithRangeBytes" (Op__WithRangeBytesⁱᵐᵖˡ);
  #[global] Op'ptr_WithValueBytes_unfold :: MethodUnfold (go.PointerType (Op)) "WithValueBytes" (Op__WithValueBytesⁱᵐᵖˡ);
  #[global] Op'ptr_applyOpts_unfold :: MethodUnfold (go.PointerType (Op)) "applyOpts" (Op__applyOptsⁱᵐᵖˡ);
  #[global] Op'ptr_isWrite_unfold :: MethodUnfold (go.PointerType (Op)) "isWrite" (λ: "$r", MethodResolve (Op) "isWrite" (![(Op)] "$r"));
  #[global] Op'ptr_toRangeRequest_unfold :: MethodUnfold (go.PointerType (Op)) "toRangeRequest" (λ: "$r", MethodResolve (Op) "toRangeRequest" (![(Op)] "$r"));
  #[global] Op'ptr_toRequestOp_unfold :: MethodUnfold (go.PointerType (Op)) "toRequestOp" (λ: "$r", MethodResolve (Op) "toRequestOp" (![(Op)] "$r"));
  #[global] Op'ptr_toTxnRequest_unfold :: MethodUnfold (go.PointerType (Op)) "toTxnRequest" (λ: "$r", MethodResolve (Op) "toTxnRequest" (![(Op)] "$r"));
}.

Module OpOption.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := func.t.
End def.
End OpOption.

Definition OpOptionⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.FunctionType (go.Signature [go.PointerType Op] false []).

Class OpOption_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] OpOption_underlying :: (OpOption) <u (OpOptionⁱᵐᵖˡ);
}.

Module LeaseOp.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  id' : clientv3.LeaseID.t;
  attachedKeys' : bool;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End LeaseOp.

Definition LeaseOp'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "id"%go LeaseID);
  (go.FieldDecl "attachedKeys"%go go.bool)
].
Program Definition LeaseOp'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (LeaseOp'fds_unsealed).
Global Instance equals_unfold_LeaseOp {ext : ffi_syntax} {go_gctx : GoGlobalContext} : LeaseOp'fds =→ LeaseOp'fds_unsealed.
Proof. rewrite /LeaseOp'fds seal_eq //. Qed.

Definition LeaseOpⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (LeaseOp'fds).

Class LeaseOp_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] LeaseOp_type_repr  :: go.TypeReprUnderlying LeaseOpⁱᵐᵖˡ LeaseOp.t;
  #[global] LeaseOp_underlying :: (LeaseOp) <u (LeaseOpⁱᵐᵖˡ);
  #[global] LeaseOp_get_id (x : LeaseOp.t) :: ⟦StructFieldGet (LeaseOpⁱᵐᵖˡ) "id", #x⟧ ⤳[under] #x.(LeaseOp.id');
  #[global] LeaseOp_set_id (x : LeaseOp.t) y :: ⟦StructFieldSet (LeaseOpⁱᵐᵖˡ) "id", (#x, #y)⟧ ⤳[under] #(x <|LeaseOp.id' := y|>);
  #[global] LeaseOp_get_attachedKeys (x : LeaseOp.t) :: ⟦StructFieldGet (LeaseOpⁱᵐᵖˡ) "attachedKeys", #x⟧ ⤳[under] #x.(LeaseOp.attachedKeys');
  #[global] LeaseOp_set_attachedKeys (x : LeaseOp.t) y :: ⟦StructFieldSet (LeaseOpⁱᵐᵖˡ) "attachedKeys", (#x, #y)⟧ ⤳[under] #(x <|LeaseOp.attachedKeys' := y|>);
}.

Module LeaseOption.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := func.t.
End def.
End LeaseOption.

Definition LeaseOptionⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.FunctionType (go.Signature [go.PointerType LeaseOp] false []).

Class LeaseOption_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] LeaseOption_underlying :: (LeaseOption) <u (LeaseOptionⁱᵐᵖˡ);
}.

Module retryPolicy.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End retryPolicy.

Class retryPolicy_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] retryPolicy_type_repr  :: go.TypeReprUnderlying retryPolicyⁱᵐᵖˡ retryPolicy.t;
  #[global] retryPolicy_underlying :: (retryPolicy) <u (retryPolicyⁱᵐᵖˡ);
  #[global] retryPolicyⁱᵐᵖˡ_underlying :: (retryPolicyⁱᵐᵖˡ) ↓u (retryPolicyⁱᵐᵖˡ);
}.

Module retryKVClient.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End retryKVClient.

Class retryKVClient_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] retryKVClient_type_repr  :: go.TypeReprUnderlying retryKVClientⁱᵐᵖˡ retryKVClient.t;
  #[global] retryKVClient_underlying :: (retryKVClient) <u (retryKVClientⁱᵐᵖˡ);
  #[global] retryKVClientⁱᵐᵖˡ_underlying :: (retryKVClientⁱᵐᵖˡ) ↓u (retryKVClientⁱᵐᵖˡ);
}.

Module retryLeaseClient.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End retryLeaseClient.

Class retryLeaseClient_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] retryLeaseClient_type_repr  :: go.TypeReprUnderlying retryLeaseClientⁱᵐᵖˡ retryLeaseClient.t;
  #[global] retryLeaseClient_underlying :: (retryLeaseClient) <u (retryLeaseClientⁱᵐᵖˡ);
  #[global] retryLeaseClientⁱᵐᵖˡ_underlying :: (retryLeaseClientⁱᵐᵖˡ) ↓u (retryLeaseClientⁱᵐᵖˡ);
}.

Module retryClusterClient.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End retryClusterClient.

Class retryClusterClient_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] retryClusterClient_type_repr  :: go.TypeReprUnderlying retryClusterClientⁱᵐᵖˡ retryClusterClient.t;
  #[global] retryClusterClient_underlying :: (retryClusterClient) <u (retryClusterClientⁱᵐᵖˡ);
  #[global] retryClusterClientⁱᵐᵖˡ_underlying :: (retryClusterClientⁱᵐᵖˡ) ↓u (retryClusterClientⁱᵐᵖˡ);
}.

Module retryMaintenanceClient.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End retryMaintenanceClient.

Class retryMaintenanceClient_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] retryMaintenanceClient_type_repr  :: go.TypeReprUnderlying retryMaintenanceClientⁱᵐᵖˡ retryMaintenanceClient.t;
  #[global] retryMaintenanceClient_underlying :: (retryMaintenanceClient) <u (retryMaintenanceClientⁱᵐᵖˡ);
  #[global] retryMaintenanceClientⁱᵐᵖˡ_underlying :: (retryMaintenanceClientⁱᵐᵖˡ) ↓u (retryMaintenanceClientⁱᵐᵖˡ);
}.

Module retryAuthClient.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End retryAuthClient.

Class retryAuthClient_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] retryAuthClient_type_repr  :: go.TypeReprUnderlying retryAuthClientⁱᵐᵖˡ retryAuthClient.t;
  #[global] retryAuthClient_underlying :: (retryAuthClient) <u (retryAuthClientⁱᵐᵖˡ);
  #[global] retryAuthClientⁱᵐᵖˡ_underlying :: (retryAuthClientⁱᵐᵖˡ) ↓u (retryAuthClientⁱᵐᵖˡ);
}.

Module serverStreamingRetryingStream.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End serverStreamingRetryingStream.

Class serverStreamingRetryingStream_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] serverStreamingRetryingStream_type_repr  :: go.TypeReprUnderlying serverStreamingRetryingStreamⁱᵐᵖˡ serverStreamingRetryingStream.t;
  #[global] serverStreamingRetryingStream_underlying :: (serverStreamingRetryingStream) <u (serverStreamingRetryingStreamⁱᵐᵖˡ);
  #[global] serverStreamingRetryingStreamⁱᵐᵖˡ_underlying :: (serverStreamingRetryingStreamⁱᵐᵖˡ) ↓u (serverStreamingRetryingStreamⁱᵐᵖˡ);
}.

Module backoffFunc.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End backoffFunc.

Class backoffFunc_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] backoffFunc_type_repr  :: go.TypeReprUnderlying backoffFuncⁱᵐᵖˡ backoffFunc.t;
  #[global] backoffFunc_underlying :: (backoffFunc) <u (backoffFuncⁱᵐᵖˡ);
  #[global] backoffFuncⁱᵐᵖˡ_underlying :: (backoffFuncⁱᵐᵖˡ) ↓u (backoffFuncⁱᵐᵖˡ);
}.

Module options.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End options.

Class options_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] options_type_repr  :: go.TypeReprUnderlying optionsⁱᵐᵖˡ options.t;
  #[global] options_underlying :: (options) <u (optionsⁱᵐᵖˡ);
  #[global] optionsⁱᵐᵖˡ_underlying :: (optionsⁱᵐᵖˡ) ↓u (optionsⁱᵐᵖˡ);
}.

Module retryOption.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End retryOption.

Class retryOption_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] retryOption_type_repr  :: go.TypeReprUnderlying retryOptionⁱᵐᵖˡ retryOption.t;
  #[global] retryOption_underlying :: (retryOption) <u (retryOptionⁱᵐᵖˡ);
  #[global] retryOptionⁱᵐᵖˡ_underlying :: (retryOptionⁱᵐᵖˡ) ↓u (retryOptionⁱᵐᵖˡ);
}.

Module SortTarget.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := w64.
End def.
End SortTarget.

Definition SortTargetⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.int.

Class SortTarget_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] SortTarget_underlying :: (SortTarget) <u (SortTargetⁱᵐᵖˡ);
}.

Module SortOrder.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := w64.
End def.
End SortOrder.

Definition SortOrderⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.int.

Class SortOrder_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] SortOrder_underlying :: (SortOrder) <u (SortOrderⁱᵐᵖˡ);
}.

Module SortOption.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  Target' : clientv3.SortTarget.t;
  Order' : clientv3.SortOrder.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End SortOption.

Definition SortOption'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "Target"%go SortTarget);
  (go.FieldDecl "Order"%go SortOrder)
].
Program Definition SortOption'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (SortOption'fds_unsealed).
Global Instance equals_unfold_SortOption {ext : ffi_syntax} {go_gctx : GoGlobalContext} : SortOption'fds =→ SortOption'fds_unsealed.
Proof. rewrite /SortOption'fds seal_eq //. Qed.

Definition SortOptionⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (SortOption'fds).

Class SortOption_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] SortOption_type_repr  :: go.TypeReprUnderlying SortOptionⁱᵐᵖˡ SortOption.t;
  #[global] SortOption_underlying :: (SortOption) <u (SortOptionⁱᵐᵖˡ);
  #[global] SortOption_get_Target (x : SortOption.t) :: ⟦StructFieldGet (SortOptionⁱᵐᵖˡ) "Target", #x⟧ ⤳[under] #x.(SortOption.Target');
  #[global] SortOption_set_Target (x : SortOption.t) y :: ⟦StructFieldSet (SortOptionⁱᵐᵖˡ) "Target", (#x, #y)⟧ ⤳[under] #(x <|SortOption.Target' := y|>);
  #[global] SortOption_get_Order (x : SortOption.t) :: ⟦StructFieldGet (SortOptionⁱᵐᵖˡ) "Order", #x⟧ ⤳[under] #x.(SortOption.Order');
  #[global] SortOption_set_Order (x : SortOption.t) y :: ⟦StructFieldSet (SortOptionⁱᵐᵖˡ) "Order", (#x, #y)⟧ ⤳[under] #(x <|SortOption.Order' := y|>);
}.

Module Txn.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := interface.t.
End def.
End Txn.

Definition Txnⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.InterfaceType [go.MethodElem "Commit"%go (go.Signature [] false [go.PointerType TxnResponse; go.error]); go.MethodElem "Else"%go (go.Signature [go.SliceType Op] true [Txn]); go.MethodElem "If"%go (go.Signature [go.SliceType Cmp] true [Txn]); go.MethodElem "Then"%go (go.Signature [go.SliceType Op] true [Txn])].

Class Txn_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Txn_underlying :: (Txn) <u (Txnⁱᵐᵖˡ);
}.

Module txn.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End txn.

Class txn_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] txn_type_repr  :: go.TypeReprUnderlying txnⁱᵐᵖˡ txn.t;
  #[global] txn_underlying :: (txn) <u (txnⁱᵐᵖˡ);
  #[global] txnⁱᵐᵖˡ_underlying :: (txnⁱᵐᵖˡ) ↓u (txnⁱᵐᵖˡ);
}.

Module Event.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := mvccpb.Event.t.
End def.
End Event.

Definition Eventⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := mvccpb.Event.

Class Event_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Event_underlying :: (Event) <u (Eventⁱᵐᵖˡ);
}.

Module WatchChan.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := chan.t.
End def.
End WatchChan.

Definition WatchChanⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.ChannelType go.recvonly WatchResponse.

Class WatchChan_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] WatchChan_underlying :: (WatchChan) <u (WatchChanⁱᵐᵖˡ);
}.

Module Watcher.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := interface.t.
End def.
End Watcher.

Definition Watcherⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.InterfaceType [go.MethodElem "Close"%go (go.Signature [] false [go.error]); go.MethodElem "RequestProgress"%go (go.Signature [context.Context] false [go.error]); go.MethodElem "Watch"%go (go.Signature [context.Context; go.string; go.SliceType OpOption] true [WatchChan])].

Class Watcher_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Watcher_underlying :: (Watcher) <u (Watcherⁱᵐᵖˡ);
}.

Module WatchResponse.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  Header' : etcdserverpb.ResponseHeader.t;
  Events' : slice.t;
  CompactRevision' : w64;
  Canceled' : bool;
  Created' : bool;
  closeErr' : error.t;
  cancelReason' : go_string;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End WatchResponse.

Definition WatchResponse'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "Header"%go etcdserverpb.ResponseHeader);
  (go.FieldDecl "Events"%go (go.SliceType (go.PointerType Event)));
  (go.FieldDecl "CompactRevision"%go go.int64);
  (go.FieldDecl "Canceled"%go go.bool);
  (go.FieldDecl "Created"%go go.bool);
  (go.FieldDecl "closeErr"%go go.error);
  (go.FieldDecl "cancelReason"%go go.string)
].
Program Definition WatchResponse'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (WatchResponse'fds_unsealed).
Global Instance equals_unfold_WatchResponse {ext : ffi_syntax} {go_gctx : GoGlobalContext} : WatchResponse'fds =→ WatchResponse'fds_unsealed.
Proof. rewrite /WatchResponse'fds seal_eq //. Qed.

Definition WatchResponseⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (WatchResponse'fds).

Class WatchResponse_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] WatchResponse_type_repr  :: go.TypeReprUnderlying WatchResponseⁱᵐᵖˡ WatchResponse.t;
  #[global] WatchResponse_underlying :: (WatchResponse) <u (WatchResponseⁱᵐᵖˡ);
  #[global] WatchResponse_get_Header (x : WatchResponse.t) :: ⟦StructFieldGet (WatchResponseⁱᵐᵖˡ) "Header", #x⟧ ⤳[under] #x.(WatchResponse.Header');
  #[global] WatchResponse_set_Header (x : WatchResponse.t) y :: ⟦StructFieldSet (WatchResponseⁱᵐᵖˡ) "Header", (#x, #y)⟧ ⤳[under] #(x <|WatchResponse.Header' := y|>);
  #[global] WatchResponse_get_Events (x : WatchResponse.t) :: ⟦StructFieldGet (WatchResponseⁱᵐᵖˡ) "Events", #x⟧ ⤳[under] #x.(WatchResponse.Events');
  #[global] WatchResponse_set_Events (x : WatchResponse.t) y :: ⟦StructFieldSet (WatchResponseⁱᵐᵖˡ) "Events", (#x, #y)⟧ ⤳[under] #(x <|WatchResponse.Events' := y|>);
  #[global] WatchResponse_get_CompactRevision (x : WatchResponse.t) :: ⟦StructFieldGet (WatchResponseⁱᵐᵖˡ) "CompactRevision", #x⟧ ⤳[under] #x.(WatchResponse.CompactRevision');
  #[global] WatchResponse_set_CompactRevision (x : WatchResponse.t) y :: ⟦StructFieldSet (WatchResponseⁱᵐᵖˡ) "CompactRevision", (#x, #y)⟧ ⤳[under] #(x <|WatchResponse.CompactRevision' := y|>);
  #[global] WatchResponse_get_Canceled (x : WatchResponse.t) :: ⟦StructFieldGet (WatchResponseⁱᵐᵖˡ) "Canceled", #x⟧ ⤳[under] #x.(WatchResponse.Canceled');
  #[global] WatchResponse_set_Canceled (x : WatchResponse.t) y :: ⟦StructFieldSet (WatchResponseⁱᵐᵖˡ) "Canceled", (#x, #y)⟧ ⤳[under] #(x <|WatchResponse.Canceled' := y|>);
  #[global] WatchResponse_get_Created (x : WatchResponse.t) :: ⟦StructFieldGet (WatchResponseⁱᵐᵖˡ) "Created", #x⟧ ⤳[under] #x.(WatchResponse.Created');
  #[global] WatchResponse_set_Created (x : WatchResponse.t) y :: ⟦StructFieldSet (WatchResponseⁱᵐᵖˡ) "Created", (#x, #y)⟧ ⤳[under] #(x <|WatchResponse.Created' := y|>);
  #[global] WatchResponse_get_closeErr (x : WatchResponse.t) :: ⟦StructFieldGet (WatchResponseⁱᵐᵖˡ) "closeErr", #x⟧ ⤳[under] #x.(WatchResponse.closeErr');
  #[global] WatchResponse_set_closeErr (x : WatchResponse.t) y :: ⟦StructFieldSet (WatchResponseⁱᵐᵖˡ) "closeErr", (#x, #y)⟧ ⤳[under] #(x <|WatchResponse.closeErr' := y|>);
  #[global] WatchResponse_get_cancelReason (x : WatchResponse.t) :: ⟦StructFieldGet (WatchResponseⁱᵐᵖˡ) "cancelReason", #x⟧ ⤳[under] #x.(WatchResponse.cancelReason');
  #[global] WatchResponse_set_cancelReason (x : WatchResponse.t) y :: ⟦StructFieldSet (WatchResponseⁱᵐᵖˡ) "cancelReason", (#x, #y)⟧ ⤳[under] #(x <|WatchResponse.cancelReason' := y|>);
}.

Module watcher.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End watcher.

Class watcher_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] watcher_type_repr  :: go.TypeReprUnderlying watcherⁱᵐᵖˡ watcher.t;
  #[global] watcher_underlying :: (watcher) <u (watcherⁱᵐᵖˡ);
  #[global] watcherⁱᵐᵖˡ_underlying :: (watcherⁱᵐᵖˡ) ↓u (watcherⁱᵐᵖˡ);
}.

Module watchGRPCStream.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End watchGRPCStream.

Class watchGRPCStream_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] watchGRPCStream_type_repr  :: go.TypeReprUnderlying watchGRPCStreamⁱᵐᵖˡ watchGRPCStream.t;
  #[global] watchGRPCStream_underlying :: (watchGRPCStream) <u (watchGRPCStreamⁱᵐᵖˡ);
  #[global] watchGRPCStreamⁱᵐᵖˡ_underlying :: (watchGRPCStreamⁱᵐᵖˡ) ↓u (watchGRPCStreamⁱᵐᵖˡ);
}.

Module watchStreamRequest.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End watchStreamRequest.

Class watchStreamRequest_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] watchStreamRequest_type_repr  :: go.TypeReprUnderlying watchStreamRequestⁱᵐᵖˡ watchStreamRequest.t;
  #[global] watchStreamRequest_underlying :: (watchStreamRequest) <u (watchStreamRequestⁱᵐᵖˡ);
  #[global] watchStreamRequestⁱᵐᵖˡ_underlying :: (watchStreamRequestⁱᵐᵖˡ) ↓u (watchStreamRequestⁱᵐᵖˡ);
}.

Module watchRequest.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End watchRequest.

Class watchRequest_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] watchRequest_type_repr  :: go.TypeReprUnderlying watchRequestⁱᵐᵖˡ watchRequest.t;
  #[global] watchRequest_underlying :: (watchRequest) <u (watchRequestⁱᵐᵖˡ);
  #[global] watchRequestⁱᵐᵖˡ_underlying :: (watchRequestⁱᵐᵖˡ) ↓u (watchRequestⁱᵐᵖˡ);
}.

Module progressRequest.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End progressRequest.

Class progressRequest_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] progressRequest_type_repr  :: go.TypeReprUnderlying progressRequestⁱᵐᵖˡ progressRequest.t;
  #[global] progressRequest_underlying :: (progressRequest) <u (progressRequestⁱᵐᵖˡ);
  #[global] progressRequestⁱᵐᵖˡ_underlying :: (progressRequestⁱᵐᵖˡ) ↓u (progressRequestⁱᵐᵖˡ);
}.

Module watcherStream.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End watcherStream.

Class watcherStream_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] watcherStream_type_repr  :: go.TypeReprUnderlying watcherStreamⁱᵐᵖˡ watcherStream.t;
  #[global] watcherStream_underlying :: (watcherStream) <u (watcherStreamⁱᵐᵖˡ);
  #[global] watcherStreamⁱᵐᵖˡ_underlying :: (watcherStreamⁱᵐᵖˡ) ↓u (watcherStreamⁱᵐᵖˡ);
}.

Module valCtx.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End valCtx.

Class valCtx_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] valCtx_type_repr  :: go.TypeReprUnderlying valCtxⁱᵐᵖˡ valCtx.t;
  #[global] valCtx_underlying :: (valCtx) <u (valCtxⁱᵐᵖˡ);
  #[global] valCtxⁱᵐᵖˡ_underlying :: (valCtxⁱᵐᵖˡ) ↓u (valCtxⁱᵐᵖˡ);
}.

Class Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] AuthEnableResponse_instance :: AuthEnableResponse_Assumptions;
  #[global] AuthDisableResponse_instance :: AuthDisableResponse_Assumptions;
  #[global] AuthStatusResponse_instance :: AuthStatusResponse_Assumptions;
  #[global] AuthenticateResponse_instance :: AuthenticateResponse_Assumptions;
  #[global] AuthUserAddResponse_instance :: AuthUserAddResponse_Assumptions;
  #[global] AuthUserDeleteResponse_instance :: AuthUserDeleteResponse_Assumptions;
  #[global] AuthUserChangePasswordResponse_instance :: AuthUserChangePasswordResponse_Assumptions;
  #[global] AuthUserGrantRoleResponse_instance :: AuthUserGrantRoleResponse_Assumptions;
  #[global] AuthUserGetResponse_instance :: AuthUserGetResponse_Assumptions;
  #[global] AuthUserRevokeRoleResponse_instance :: AuthUserRevokeRoleResponse_Assumptions;
  #[global] AuthRoleAddResponse_instance :: AuthRoleAddResponse_Assumptions;
  #[global] AuthRoleGrantPermissionResponse_instance :: AuthRoleGrantPermissionResponse_Assumptions;
  #[global] AuthRoleGetResponse_instance :: AuthRoleGetResponse_Assumptions;
  #[global] AuthRoleRevokePermissionResponse_instance :: AuthRoleRevokePermissionResponse_Assumptions;
  #[global] AuthRoleDeleteResponse_instance :: AuthRoleDeleteResponse_Assumptions;
  #[global] AuthUserListResponse_instance :: AuthUserListResponse_Assumptions;
  #[global] AuthRoleListResponse_instance :: AuthRoleListResponse_Assumptions;
  #[global] PermissionType_instance :: PermissionType_Assumptions;
  #[global] Permission_instance :: Permission_Assumptions;
  #[global] UserAddOptions_instance :: UserAddOptions_Assumptions;
  #[global] Auth_instance :: Auth_Assumptions;
  #[global] authClient_instance :: authClient_Assumptions;
  #[global] Client_instance :: Client_Assumptions;
  #[global] Option_instance :: Option_Assumptions;
  #[global] Member_instance :: Member_Assumptions;
  #[global] MemberListResponse_instance :: MemberListResponse_Assumptions;
  #[global] MemberAddResponse_instance :: MemberAddResponse_Assumptions;
  #[global] MemberRemoveResponse_instance :: MemberRemoveResponse_Assumptions;
  #[global] MemberUpdateResponse_instance :: MemberUpdateResponse_Assumptions;
  #[global] MemberPromoteResponse_instance :: MemberPromoteResponse_Assumptions;
  #[global] Cluster_instance :: Cluster_Assumptions;
  #[global] cluster_instance :: cluster_Assumptions;
  #[global] CompactOp_instance :: CompactOp_Assumptions;
  #[global] CompactOption_instance :: CompactOption_Assumptions;
  #[global] CompareTarget_instance :: CompareTarget_Assumptions;
  #[global] CompareResult_instance :: CompareResult_Assumptions;
  #[global] Cmp_instance :: Cmp_Assumptions;
  #[global] Config_instance :: Config_Assumptions;
  #[global] ConfigSpec_instance :: ConfigSpec_Assumptions;
  #[global] SecureConfig_instance :: SecureConfig_Assumptions;
  #[global] AuthConfig_instance :: AuthConfig_Assumptions;
  #[global] CompactResponse_instance :: CompactResponse_Assumptions;
  #[global] PutResponse_instance :: PutResponse_Assumptions;
  #[global] GetResponse_instance :: GetResponse_Assumptions;
  #[global] DeleteResponse_instance :: DeleteResponse_Assumptions;
  #[global] TxnResponse_instance :: TxnResponse_Assumptions;
  #[global] KV_instance :: KV_Assumptions;
  #[global] OpResponse_instance :: OpResponse_Assumptions;
  #[global] kv_instance :: kv_Assumptions;
  #[global] LeaseRevokeResponse_instance :: LeaseRevokeResponse_Assumptions;
  #[global] LeaseID_instance :: LeaseID_Assumptions;
  #[global] LeaseGrantResponse_instance :: LeaseGrantResponse_Assumptions;
  #[global] LeaseKeepAliveResponse_instance :: LeaseKeepAliveResponse_Assumptions;
  #[global] LeaseTimeToLiveResponse_instance :: LeaseTimeToLiveResponse_Assumptions;
  #[global] LeaseStatus_instance :: LeaseStatus_Assumptions;
  #[global] LeaseLeasesResponse_instance :: LeaseLeasesResponse_Assumptions;
  #[global] ErrKeepAliveHalted_instance :: ErrKeepAliveHalted_Assumptions;
  #[global] Lease_instance :: Lease_Assumptions;
  #[global] lessor_instance :: lessor_Assumptions;
  #[global] keepAlive_instance :: keepAlive_Assumptions;
  #[global] keepAliveCtxKey_instance :: keepAliveCtxKey_Assumptions;
  #[global] DefragmentResponse_instance :: DefragmentResponse_Assumptions;
  #[global] AlarmResponse_instance :: AlarmResponse_Assumptions;
  #[global] AlarmMember_instance :: AlarmMember_Assumptions;
  #[global] StatusResponse_instance :: StatusResponse_Assumptions;
  #[global] HashKVResponse_instance :: HashKVResponse_Assumptions;
  #[global] MoveLeaderResponse_instance :: MoveLeaderResponse_Assumptions;
  #[global] DowngradeResponse_instance :: DowngradeResponse_Assumptions;
  #[global] DowngradeAction_instance :: DowngradeAction_Assumptions;
  #[global] Maintenance_instance :: Maintenance_Assumptions;
  #[global] SnapshotResponse_instance :: SnapshotResponse_Assumptions;
  #[global] maintenance_instance :: maintenance_Assumptions;
  #[global] snapshotReadCloser_instance :: snapshotReadCloser_Assumptions;
  #[global] opType_instance :: opType_Assumptions;
  #[global] Op_instance :: Op_Assumptions;
  #[global] OpOption_instance :: OpOption_Assumptions;
  #[global] LeaseOp_instance :: LeaseOp_Assumptions;
  #[global] LeaseOption_instance :: LeaseOption_Assumptions;
  #[global] retryPolicy_instance :: retryPolicy_Assumptions;
  #[global] retryKVClient_instance :: retryKVClient_Assumptions;
  #[global] retryLeaseClient_instance :: retryLeaseClient_Assumptions;
  #[global] retryClusterClient_instance :: retryClusterClient_Assumptions;
  #[global] retryMaintenanceClient_instance :: retryMaintenanceClient_Assumptions;
  #[global] retryAuthClient_instance :: retryAuthClient_Assumptions;
  #[global] serverStreamingRetryingStream_instance :: serverStreamingRetryingStream_Assumptions;
  #[global] backoffFunc_instance :: backoffFunc_Assumptions;
  #[global] options_instance :: options_Assumptions;
  #[global] retryOption_instance :: retryOption_Assumptions;
  #[global] SortTarget_instance :: SortTarget_Assumptions;
  #[global] SortOrder_instance :: SortOrder_Assumptions;
  #[global] SortOption_instance :: SortOption_Assumptions;
  #[global] Txn_instance :: Txn_Assumptions;
  #[global] txn_instance :: txn_Assumptions;
  #[global] Event_instance :: Event_Assumptions;
  #[global] WatchChan_instance :: WatchChan_Assumptions;
  #[global] Watcher_instance :: Watcher_Assumptions;
  #[global] WatchResponse_instance :: WatchResponse_Assumptions;
  #[global] watcher_instance :: watcher_Assumptions;
  #[global] watchGRPCStream_instance :: watchGRPCStream_Assumptions;
  #[global] watchStreamRequest_instance :: watchStreamRequest_Assumptions;
  #[global] watchRequest_instance :: watchRequest_Assumptions;
  #[global] progressRequest_instance :: progressRequest_Assumptions;
  #[global] watcherStream_instance :: watcherStream_Assumptions;
  #[global] valCtx_instance :: valCtx_Assumptions;
  #[global] WithZapLogger_unfold :: FuncUnfold WithZapLogger [] (WithZapLoggerⁱᵐᵖˡ);
  #[global] OpGet_unfold :: FuncUnfold OpGet [] (OpGetⁱᵐᵖˡ);
  #[global] OpDelete_unfold :: FuncUnfold OpDelete [] (OpDeleteⁱᵐᵖˡ);
  #[global] OpPut_unfold :: FuncUnfold OpPut [] (OpPutⁱᵐᵖˡ);
  #[global] OpTxn_unfold :: FuncUnfold OpTxn [] (OpTxnⁱᵐᵖˡ);
  #[global] WithLease_unfold :: FuncUnfold WithLease [] (WithLeaseⁱᵐᵖˡ);
  #[global] WithLimit_unfold :: FuncUnfold WithLimit [] (WithLimitⁱᵐᵖˡ);
  #[global] WithRev_unfold :: FuncUnfold WithRev [] (WithRevⁱᵐᵖˡ);
  #[global] WithSort_unfold :: FuncUnfold WithSort [] (WithSortⁱᵐᵖˡ);
  #[global] WithPrefix_unfold :: FuncUnfold WithPrefix [] (WithPrefixⁱᵐᵖˡ);
  #[global] WithRange_unfold :: FuncUnfold WithRange [] (WithRangeⁱᵐᵖˡ);
  #[global] WithFromKey_unfold :: FuncUnfold WithFromKey [] (WithFromKeyⁱᵐᵖˡ);
  #[global] WithSerializable_unfold :: FuncUnfold WithSerializable [] (WithSerializableⁱᵐᵖˡ);
  #[global] WithKeysOnly_unfold :: FuncUnfold WithKeysOnly [] (WithKeysOnlyⁱᵐᵖˡ);
  #[global] WithCountOnly_unfold :: FuncUnfold WithCountOnly [] (WithCountOnlyⁱᵐᵖˡ);
  #[global] WithMinModRev_unfold :: FuncUnfold WithMinModRev [] (WithMinModRevⁱᵐᵖˡ);
  #[global] WithMaxModRev_unfold :: FuncUnfold WithMaxModRev [] (WithMaxModRevⁱᵐᵖˡ);
  #[global] WithMinCreateRev_unfold :: FuncUnfold WithMinCreateRev [] (WithMinCreateRevⁱᵐᵖˡ);
  #[global] WithMaxCreateRev_unfold :: FuncUnfold WithMaxCreateRev [] (WithMaxCreateRevⁱᵐᵖˡ);
  #[global] WithFirstCreate_unfold :: FuncUnfold WithFirstCreate [] (WithFirstCreateⁱᵐᵖˡ);
  #[global] WithLastCreate_unfold :: FuncUnfold WithLastCreate [] (WithLastCreateⁱᵐᵖˡ);
  #[global] WithFirstKey_unfold :: FuncUnfold WithFirstKey [] (WithFirstKeyⁱᵐᵖˡ);
  #[global] WithLastKey_unfold :: FuncUnfold WithLastKey [] (WithLastKeyⁱᵐᵖˡ);
  #[global] WithFirstRev_unfold :: FuncUnfold WithFirstRev [] (WithFirstRevⁱᵐᵖˡ);
  #[global] WithLastRev_unfold :: FuncUnfold WithLastRev [] (WithLastRevⁱᵐᵖˡ);
  #[global] WithProgressNotify_unfold :: FuncUnfold WithProgressNotify [] (WithProgressNotifyⁱᵐᵖˡ);
  #[global] WithCreatedNotify_unfold :: FuncUnfold WithCreatedNotify [] (WithCreatedNotifyⁱᵐᵖˡ);
  #[global] WithFilterPut_unfold :: FuncUnfold WithFilterPut [] (WithFilterPutⁱᵐᵖˡ);
  #[global] WithFilterDelete_unfold :: FuncUnfold WithFilterDelete [] (WithFilterDeleteⁱᵐᵖˡ);
  #[global] WithPrevKV_unfold :: FuncUnfold WithPrevKV [] (WithPrevKVⁱᵐᵖˡ);
  #[global] WithFragment_unfold :: FuncUnfold WithFragment [] (WithFragmentⁱᵐᵖˡ);
  #[global] WithIgnoreValue_unfold :: FuncUnfold WithIgnoreValue [] (WithIgnoreValueⁱᵐᵖˡ);
  #[global] WithIgnoreLease_unfold :: FuncUnfold WithIgnoreLease [] (WithIgnoreLeaseⁱᵐᵖˡ);
  #[global] WithAttachedKeys_unfold :: FuncUnfold WithAttachedKeys [] (WithAttachedKeysⁱᵐᵖˡ);
  #[global] import_context_Assumption :: context.Assumptions;
  #[global] import_etcdserverpb_Assumption :: etcdserverpb.Assumptions;
  #[global] import_zap_Assumption :: zap.Assumptions;
  #[global] import_mvccpb_Assumption :: mvccpb.Assumptions;
}.
End clientv3.
