(* autogenerated from go.etcd.io/etcd/client/v3/leasing *)
Require Export New.code.context.
Require Export New.code.strings.
Require Export New.code.sync.
Require Export New.code.time.
Require Export New.code.go_etcd_io.etcd.api.v3.etcdserverpb.
Require Export New.code.go_etcd_io.etcd.api.v3.mvccpb.
Require Export New.code.go_etcd_io.etcd.client.v3.
Require Export New.code.errors.
Require Export New.code.google_golang_org.grpc.codes.
Require Export New.code.google_golang_org.grpc.status.
Require Export New.code.go_etcd_io.etcd.api.v3.v3rpc.rpctypes.
Require Export New.code.go_etcd_io.etcd.client.v3.concurrency.
Require Export New.code.bytes.
From New.golang Require Import defn.
Module pkg_id.
Definition leasing : go_string := "go.etcd.io/etcd/client/v3/leasing".

End pkg_id.
Export pkg_id.
Module leasing.

Definition leaseCache {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3/leasing.leaseCache"%go [].

#[global] Opaque leaseCache.

Definition leaseKey {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3/leasing.leaseKey"%go [].

#[global] Opaque leaseKey.

Definition leasingKV {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3/leasing.leasingKV"%go [].

#[global] Opaque leasingKV.

Definition txnLeasing {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/client/v3/leasing.txnLeasing"%go [].

#[global] Opaque txnLeasing.

Definition revokeBackoff {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 2000000000).

Definition closedCh {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3/leasing.closedCh"%go.

Definition inRange {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3/leasing.inRange"%go.

Definition isBadOp {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3/leasing.isBadOp"%go.

Definition NewKV {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3/leasing.NewKV"%go.

Definition compareInt64 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3/leasing.compareInt64"%go.

Definition evalCmp {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3/leasing.evalCmp"%go.

Definition gatherOps {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3/leasing.gatherOps"%go.

Definition gatherResponseOps {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3/leasing.gatherResponseOps"%go.

Definition copyHeader {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3/leasing.copyHeader"%go.

Definition closeAll {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/client/v3/leasing.closeAll"%go.

(* go: cache.go:44:23 *)
Definition leaseCache__Revⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "lc" "key",
    with_defer: (let: "lc" := (GoAlloc (go.PointerType leaseCache) "lc") in
    let: "key" := (GoAlloc go.string "key") in
    do:  ((MethodResolve (go.PointerType sync.RWMutex) "RLock"%go (StructFieldRef leaseCache "mu"%go (![go.PointerType leaseCache] "lc"))) #());;;
    do:  (let: "$f" := (MethodResolve (go.PointerType sync.RWMutex) "RUnlock"%go (StructFieldRef leaseCache "mu"%go (![go.PointerType leaseCache] "lc"))) in
    "$defer" <-[deferType] (let: "$oldf" := (![deferType] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    (let: "li" := (GoAlloc (go.PointerType leaseKey) (GoZeroVal (go.PointerType leaseKey) #())) in
    let: "$r0" := (map.lookup1 go.string (go.PointerType leaseKey) (![go.MapType go.string (go.PointerType leaseKey)] (StructFieldRef leaseCache "entries"%go (![go.PointerType leaseCache] "lc"))) (![go.string] "key")) in
    do:  ("li" <-[go.PointerType leaseKey] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.PointerType leaseKey] "li") ≠⟨go.PointerType leaseKey⟩ (Convert go.untyped_nil (go.PointerType leaseKey) UntypedNil))
    then return: (![go.int64] (StructFieldRef leaseKey "rev"%go (![go.PointerType leaseKey] "li")))
    else do:  #()));;;
    return: (#(W64 0))).

(* go: cache.go:53:23 *)
Definition leaseCache__Lockⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "lc" "key",
    with_defer: (let: "lc" := (GoAlloc (go.PointerType leaseCache) "lc") in
    let: "key" := (GoAlloc go.string "key") in
    do:  ((MethodResolve (go.PointerType sync.RWMutex) "Lock"%go (StructFieldRef leaseCache "mu"%go (![go.PointerType leaseCache] "lc"))) #());;;
    do:  (let: "$f" := (MethodResolve (go.PointerType sync.RWMutex) "Unlock"%go (StructFieldRef leaseCache "mu"%go (![go.PointerType leaseCache] "lc"))) in
    "$defer" <-[deferType] (let: "$oldf" := (![deferType] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    (let: "li" := (GoAlloc (go.PointerType leaseKey) (GoZeroVal (go.PointerType leaseKey) #())) in
    let: "$r0" := (map.lookup1 go.string (go.PointerType leaseKey) (![go.MapType go.string (go.PointerType leaseKey)] (StructFieldRef leaseCache "entries"%go (![go.PointerType leaseCache] "lc"))) (![go.string] "key")) in
    do:  ("li" <-[go.PointerType leaseKey] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.PointerType leaseKey] "li") ≠⟨go.PointerType leaseKey⟩ (Convert go.untyped_nil (go.PointerType leaseKey) UntypedNil))
    then
      let: "$r0" := ((FuncResolve go.make1 [go.ChannelType go.sendrecv (go.StructType [

       ])] #()) #()) in
      do:  ((StructFieldRef leaseKey "waitc"%go (![go.PointerType leaseKey] "li")) <-[go.ChannelType go.sendrecv (go.StructType [

      ])] "$r0");;;
      return: (Convert (go.ChannelType go.sendrecv (go.StructType [

       ])) (go.ChannelType go.sendonly (go.StructType [

       ])) (![go.ChannelType go.sendrecv (go.StructType [

       ])] (StructFieldRef leaseKey "waitc"%go (![go.PointerType leaseKey] "li"))), ![go.int64] (StructFieldRef leaseKey "rev"%go (![go.PointerType leaseKey] "li")))
    else do:  #()));;;
    return: (Convert go.untyped_nil (go.ChannelType go.sendonly (go.StructType [

     ])) UntypedNil, #(W64 0))).

(* go: cache.go:63:23 *)
Definition leaseCache__LockRangeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "lc" "begin" "end",
    with_defer: (let: "ret" := (GoAlloc (go.SliceType (go.ChannelType go.sendonly (go.StructType [

    ]))) (GoZeroVal (go.SliceType (go.ChannelType go.sendonly (go.StructType [

    ]))) #())) in
    let: "lc" := (GoAlloc (go.PointerType leaseCache) "lc") in
    let: "end" := (GoAlloc go.string "end") in
    let: "begin" := (GoAlloc go.string "begin") in
    do:  ((MethodResolve (go.PointerType sync.RWMutex) "Lock"%go (StructFieldRef leaseCache "mu"%go (![go.PointerType leaseCache] "lc"))) #());;;
    do:  (let: "$f" := (MethodResolve (go.PointerType sync.RWMutex) "Unlock"%go (StructFieldRef leaseCache "mu"%go (![go.PointerType leaseCache] "lc"))) in
    "$defer" <-[deferType] (let: "$oldf" := (![deferType] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    let: "$range" := (![go.MapType go.string (go.PointerType leaseKey)] (StructFieldRef leaseCache "entries"%go (![go.PointerType leaseCache] "lc"))) in
    (let: "li" := (GoAlloc (go.PointerType leaseKey) (GoZeroVal (go.PointerType leaseKey) #())) in
    let: "k" := (GoAlloc go.string (GoZeroVal go.string #())) in
    map.for_range go.string (go.PointerType leaseKey) "$range" (λ: "$key" "value",
      do:  ("li" <-[go.PointerType leaseKey] "$value");;;
      do:  ("k" <-[go.string] "$key");;;
      (if: let: "$a0" := (![go.string] "k") in
      let: "$a1" := (![go.string] "begin") in
      let: "$a2" := (![go.string] "end") in
      (FuncResolve inRange [] #()) "$a0" "$a1" "$a2"
      then
        let: "$r0" := ((FuncResolve go.make1 [go.ChannelType go.sendrecv (go.StructType [

         ])] #()) #()) in
        do:  ((StructFieldRef leaseKey "waitc"%go (![go.PointerType leaseKey] "li")) <-[go.ChannelType go.sendrecv (go.StructType [

        ])] "$r0");;;
        let: "$r0" := (let: "$a0" := (![go.SliceType (go.ChannelType go.sendonly (go.StructType [

        ]))] "ret") in
        let: "$a1" := ((let: "$sl0" := (Convert (go.ChannelType go.sendrecv (go.StructType [

        ])) (go.ChannelType go.sendonly (go.StructType [

        ])) (![go.ChannelType go.sendrecv (go.StructType [

        ])] (StructFieldRef leaseKey "waitc"%go (![go.PointerType leaseKey] "li")))) in
        CompositeLiteral (go.SliceType (go.ChannelType go.sendonly (go.StructType [

        ]))) (LiteralValue [KeyedElement None (ElementExpression (go.ChannelType go.sendonly (go.StructType [

         ])) "$sl0")]))) in
        (FuncResolve go.append [go.SliceType (go.ChannelType go.sendonly (go.StructType [

         ]))] #()) "$a0" "$a1") in
        do:  ("ret" <-[go.SliceType (go.ChannelType go.sendonly (go.StructType [

        ]))] "$r0")
      else do:  #())));;;
    return: (![go.SliceType (go.ChannelType go.sendonly (go.StructType [

     ]))] "ret")).

(* go: cache.go:75:6 *)
Definition inRangeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "k" "begin" "end",
    exception_do (let: "end" := (GoAlloc go.string "end") in
    let: "begin" := (GoAlloc go.string "begin") in
    let: "k" := (GoAlloc go.string "k") in
    (if: Convert go.untyped_bool go.bool ((let: "$a0" := (![go.string] "k") in
    let: "$a1" := (![go.string] "begin") in
    (FuncResolve strings.Compare [] #()) "$a0" "$a1") <⟨go.int⟩ #(W64 0))
    then return: (#false)
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool (((![go.string] "end") ≠⟨go.string⟩ #" "%go) && ((let: "$a0" := (![go.string] "k") in
    let: "$a1" := (![go.string] "end") in
    (FuncResolve strings.Compare [] #()) "$a0" "$a1") ≥⟨go.int⟩ #(W64 0)))
    then return: (#false)
    else do:  #());;;
    return: (#true)).

(* go: cache.go:85:23 *)
Definition leaseCache__LockWriteOpsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "lc" "ops",
    exception_do (let: "ret" := (GoAlloc (go.SliceType (go.ChannelType go.sendonly (go.StructType [

    ]))) (GoZeroVal (go.SliceType (go.ChannelType go.sendonly (go.StructType [

    ]))) #())) in
    let: "lc" := (GoAlloc (go.PointerType leaseCache) "lc") in
    let: "ops" := (GoAlloc (go.SliceType clientv3.Op) "ops") in
    let: "$range" := (![go.SliceType clientv3.Op] "ops") in
    (let: "op" := (GoAlloc clientv3.Op (GoZeroVal clientv3.Op #())) in
    slice.for_range clientv3.Op "$range" (λ: "$key" "$value",
      do:  ("op" <-[clientv3.Op] "$value");;;
      do:  "$key";;;
      (if: (MethodResolve (go.PointerType clientv3.Op) "IsGet"%go "op") #()
      then continue: #()
      else do:  #());;;
      let: "key" := (GoAlloc go.string (GoZeroVal go.string #())) in
      let: "$r0" := (Convert (go.SliceType go.byte) go.string ((MethodResolve (go.PointerType clientv3.Op) "KeyBytes"%go "op") #())) in
      do:  ("key" <-[go.string] "$r0");;;
      (let: "end" := (GoAlloc go.string (GoZeroVal go.string #())) in
      let: "$r0" := (Convert (go.SliceType go.byte) go.string ((MethodResolve (go.PointerType clientv3.Op) "RangeBytes"%go "op") #())) in
      do:  ("end" <-[go.string] "$r0");;;
      (if: Convert go.untyped_bool go.bool ((![go.string] "end") =⟨go.string⟩ #""%go)
      then
        (let: "wc" := (GoAlloc (go.ChannelType go.sendonly (go.StructType [

        ])) (GoZeroVal (go.ChannelType go.sendonly (go.StructType [

        ])) #())) in
        let: ("$ret0", "$ret1") := (let: "$a0" := (![go.string] "key") in
        (MethodResolve (go.PointerType leaseCache) "Lock"%go (![go.PointerType leaseCache] "lc")) "$a0") in
        let: "$r0" := "$ret0" in
        let: "$r1" := "$ret1" in
        do:  ("wc" <-[go.ChannelType go.sendonly (go.StructType [

        ])] "$r0");;;
        do:  "$r1";;;
        (if: Convert go.untyped_bool go.bool ((![go.ChannelType go.sendonly (go.StructType [

        ])] "wc") ≠⟨go.ChannelType go.sendonly (go.StructType [

        ])⟩ (Convert go.untyped_nil (go.ChannelType go.sendonly (go.StructType [

        ])) UntypedNil))
        then
          let: "$r0" := (let: "$a0" := (![go.SliceType (go.ChannelType go.sendonly (go.StructType [

          ]))] "ret") in
          let: "$a1" := ((let: "$sl0" := (![go.ChannelType go.sendonly (go.StructType [

          ])] "wc") in
          CompositeLiteral (go.SliceType (go.ChannelType go.sendonly (go.StructType [

          ]))) (LiteralValue [KeyedElement None (ElementExpression (go.ChannelType go.sendonly (go.StructType [

           ])) "$sl0")]))) in
          (FuncResolve go.append [go.SliceType (go.ChannelType go.sendonly (go.StructType [

           ]))] #()) "$a0" "$a1") in
          do:  ("ret" <-[go.SliceType (go.ChannelType go.sendonly (go.StructType [

          ]))] "$r0")
        else do:  #()))
      else
        let: "$range" := (![go.MapType go.string (go.PointerType leaseKey)] (StructFieldRef leaseCache "entries"%go (![go.PointerType leaseCache] "lc"))) in
        (let: "k" := (GoAlloc go.string (GoZeroVal go.string #())) in
        map.for_range go.string (go.PointerType leaseKey) "$range" (λ: "$key" "value",
          do:  ("k" <-[go.string] "$key");;;
          (if: (⟨go.bool⟩! (let: "$a0" := (![go.string] "k") in
          let: "$a1" := (![go.string] "key") in
          let: "$a2" := (![go.string] "end") in
          (FuncResolve inRange [] #()) "$a0" "$a1" "$a2"))
          then continue: #()
          else do:  #());;;
          (let: "wc" := (GoAlloc (go.ChannelType go.sendonly (go.StructType [

          ])) (GoZeroVal (go.ChannelType go.sendonly (go.StructType [

          ])) #())) in
          let: ("$ret0", "$ret1") := (let: "$a0" := (![go.string] "k") in
          (MethodResolve (go.PointerType leaseCache) "Lock"%go (![go.PointerType leaseCache] "lc")) "$a0") in
          let: "$r0" := "$ret0" in
          let: "$r1" := "$ret1" in
          do:  ("wc" <-[go.ChannelType go.sendonly (go.StructType [

          ])] "$r0");;;
          do:  "$r1";;;
          (if: Convert go.untyped_bool go.bool ((![go.ChannelType go.sendonly (go.StructType [

          ])] "wc") ≠⟨go.ChannelType go.sendonly (go.StructType [

          ])⟩ (Convert go.untyped_nil (go.ChannelType go.sendonly (go.StructType [

          ])) UntypedNil))
          then
            let: "$r0" := (let: "$a0" := (![go.SliceType (go.ChannelType go.sendonly (go.StructType [

            ]))] "ret") in
            let: "$a1" := ((let: "$sl0" := (![go.ChannelType go.sendonly (go.StructType [

            ])] "wc") in
            CompositeLiteral (go.SliceType (go.ChannelType go.sendonly (go.StructType [

            ]))) (LiteralValue [KeyedElement None (ElementExpression (go.ChannelType go.sendonly (go.StructType [

             ])) "$sl0")]))) in
            (FuncResolve go.append [go.SliceType (go.ChannelType go.sendonly (go.StructType [

             ]))] #()) "$a0" "$a1") in
            do:  ("ret" <-[go.SliceType (go.ChannelType go.sendonly (go.StructType [

            ]))] "$r0")
          else do:  #()))))))));;;
    return: (![go.SliceType (go.ChannelType go.sendonly (go.StructType [

     ]))] "ret")).

(* go: cache.go:109:23 *)
Definition leaseCache__NotifyOpsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "lc" "ops",
    exception_do (let: "wcs" := (GoAlloc (go.SliceType (go.ChannelType go.recvonly (go.StructType [

    ]))) (GoZeroVal (go.SliceType (go.ChannelType go.recvonly (go.StructType [

    ]))) #())) in
    let: "lc" := (GoAlloc (go.PointerType leaseCache) "lc") in
    let: "ops" := (GoAlloc (go.SliceType clientv3.Op) "ops") in
    let: "$range" := (![go.SliceType clientv3.Op] "ops") in
    (let: "op" := (GoAlloc clientv3.Op (GoZeroVal clientv3.Op #())) in
    slice.for_range clientv3.Op "$range" (λ: "$key" "$value",
      do:  ("op" <-[clientv3.Op] "$value");;;
      do:  "$key";;;
      (if: (MethodResolve (go.PointerType clientv3.Op) "IsGet"%go "op") #()
      then
        (let: "wc" := (GoAlloc (go.ChannelType go.recvonly (go.StructType [

        ])) (GoZeroVal (go.ChannelType go.recvonly (go.StructType [

        ])) #())) in
        let: ("$ret0", "$ret1") := (let: "$a0" := (Convert (go.SliceType go.byte) go.string ((MethodResolve (go.PointerType clientv3.Op) "KeyBytes"%go "op") #())) in
        (MethodResolve (go.PointerType leaseCache) "notify"%go (![go.PointerType leaseCache] "lc")) "$a0") in
        let: "$r0" := "$ret0" in
        let: "$r1" := "$ret1" in
        do:  "$r0";;;
        do:  ("wc" <-[go.ChannelType go.recvonly (go.StructType [

        ])] "$r1");;;
        (if: Convert go.untyped_bool go.bool ((![go.ChannelType go.recvonly (go.StructType [

        ])] "wc") ≠⟨go.ChannelType go.recvonly (go.StructType [

        ])⟩ (Convert go.untyped_nil (go.ChannelType go.recvonly (go.StructType [

        ])) UntypedNil))
        then
          let: "$r0" := (let: "$a0" := (![go.SliceType (go.ChannelType go.recvonly (go.StructType [

          ]))] "wcs") in
          let: "$a1" := ((let: "$sl0" := (![go.ChannelType go.recvonly (go.StructType [

          ])] "wc") in
          CompositeLiteral (go.SliceType (go.ChannelType go.recvonly (go.StructType [

          ]))) (LiteralValue [KeyedElement None (ElementExpression (go.ChannelType go.recvonly (go.StructType [

           ])) "$sl0")]))) in
          (FuncResolve go.append [go.SliceType (go.ChannelType go.recvonly (go.StructType [

           ]))] #()) "$a0" "$a1") in
          do:  ("wcs" <-[go.SliceType (go.ChannelType go.recvonly (go.StructType [

          ]))] "$r0")
        else do:  #()))
      else do:  #())));;;
    return: (![go.SliceType (go.ChannelType go.recvonly (go.StructType [

     ]))] "wcs")).

(* go: cache.go:120:23 *)
Definition leaseCache__MayAcquireⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "lc" "key",
    exception_do (let: "lc" := (GoAlloc (go.PointerType leaseCache) "lc") in
    let: "key" := (GoAlloc go.string "key") in
    do:  ((MethodResolve (go.PointerType sync.RWMutex) "RLock"%go (StructFieldRef leaseCache "mu"%go (![go.PointerType leaseCache] "lc"))) #());;;
    let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "lr" := (GoAlloc time.Time (GoZeroVal time.Time #())) in
    let: ("$ret0", "$ret1") := (map.lookup2 go.string time.Time (![go.MapType go.string time.Time] (StructFieldRef leaseCache "revokes"%go (![go.PointerType leaseCache] "lc"))) (![go.string] "key")) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("lr" <-[time.Time] "$r0");;;
    do:  ("ok" <-[go.bool] "$r1");;;
    do:  ((MethodResolve (go.PointerType sync.RWMutex) "RUnlock"%go (StructFieldRef leaseCache "mu"%go (![go.PointerType leaseCache] "lc"))) #());;;
    return: ((⟨go.bool⟩! (![go.bool] "ok")) || ((let: "$a0" := (![time.Time] "lr") in
     (FuncResolve time.Since [] #()) "$a0") >⟨time.Duration⟩ revokeBackoff))).

(* go: cache.go:127:23 *)
Definition leaseCache__Addⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "lc" "key" "resp" "op",
    exception_do (let: "lc" := (GoAlloc (go.PointerType leaseCache) "lc") in
    let: "op" := (GoAlloc clientv3.Op "op") in
    let: "resp" := (GoAlloc (go.PointerType clientv3.GetResponse) "resp") in
    let: "key" := (GoAlloc go.string "key") in
    let: "lk" := (GoAlloc (go.PointerType leaseKey) (GoZeroVal (go.PointerType leaseKey) #())) in
    let: "$r0" := (GoAlloc leaseKey (let: "$v0" := (![go.PointerType clientv3.GetResponse] "resp") in
    let: "$v1" := (![go.int64] (StructFieldRef etcdserverpb.ResponseHeader "Revision"%go (![go.PointerType etcdserverpb.ResponseHeader] (StructFieldRef clientv3.GetResponse "Header"%go (![go.PointerType clientv3.GetResponse] "resp"))))) in
    let: "$v2" := (![go.ChannelType go.sendrecv (go.StructType [

    ])] (GlobalVarAddr closedCh #())) in
    CompositeLiteral leaseKey (LiteralValue [KeyedElement None (ElementExpression (go.PointerType clientv3.GetResponse) "$v0"); KeyedElement None (ElementExpression go.int64 "$v1"); KeyedElement None (ElementExpression (go.ChannelType go.sendrecv (go.StructType [

     ])) "$v2")]))) in
    do:  ("lk" <-[go.PointerType leaseKey] "$r0");;;
    do:  ((MethodResolve (go.PointerType sync.RWMutex) "Lock"%go (StructFieldRef leaseCache "mu"%go (![go.PointerType leaseCache] "lc"))) #());;;
    (if: Convert go.untyped_bool go.bool (((![go.PointerType etcdserverpb.ResponseHeader] (StructFieldRef leaseCache "header"%go (![go.PointerType leaseCache] "lc"))) =⟨go.PointerType etcdserverpb.ResponseHeader⟩ (Convert go.untyped_nil (go.PointerType etcdserverpb.ResponseHeader) UntypedNil)) || ((![go.int64] (StructFieldRef etcdserverpb.ResponseHeader "Revision"%go (![go.PointerType etcdserverpb.ResponseHeader] (StructFieldRef leaseCache "header"%go (![go.PointerType leaseCache] "lc"))))) <⟨go.int64⟩ (![go.int64] (StructFieldRef etcdserverpb.ResponseHeader "Revision"%go (![go.PointerType etcdserverpb.ResponseHeader] (StructFieldRef clientv3.GetResponse "Header"%go (![go.PointerType clientv3.GetResponse] "resp")))))))
    then
      let: "$r0" := (![go.PointerType etcdserverpb.ResponseHeader] (StructFieldRef clientv3.GetResponse "Header"%go (![go.PointerType clientv3.GetResponse] "resp"))) in
      do:  ((StructFieldRef leaseCache "header"%go (![go.PointerType leaseCache] "lc")) <-[go.PointerType etcdserverpb.ResponseHeader] "$r0")
    else do:  #());;;
    let: "$r0" := (![go.PointerType leaseKey] "lk") in
    do:  (map.insert go.string (![go.MapType go.string (go.PointerType leaseKey)] (StructFieldRef leaseCache "entries"%go (![go.PointerType leaseCache] "lc"))) (![go.string] "key") "$r0");;;
    let: "ret" := (GoAlloc (go.PointerType clientv3.GetResponse) (GoZeroVal (go.PointerType clientv3.GetResponse) #())) in
    let: "$r0" := (let: "$a0" := (![clientv3.Op] "op") in
    (MethodResolve (go.PointerType leaseKey) "get"%go (![go.PointerType leaseKey] "lk")) "$a0") in
    do:  ("ret" <-[go.PointerType clientv3.GetResponse] "$r0");;;
    do:  ((MethodResolve (go.PointerType sync.RWMutex) "Unlock"%go (StructFieldRef leaseCache "mu"%go (![go.PointerType leaseCache] "lc"))) #());;;
    return: (![go.PointerType clientv3.GetResponse] "ret")).

(* go: cache.go:139:23 *)
Definition leaseCache__Updateⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "lc" "key" "val" "respHeader",
    exception_do (let: "lc" := (GoAlloc (go.PointerType leaseCache) "lc") in
    let: "respHeader" := (GoAlloc (go.PointerType etcdserverpb.ResponseHeader) "respHeader") in
    let: "val" := (GoAlloc (go.SliceType go.byte) "val") in
    let: "key" := (GoAlloc (go.SliceType go.byte) "key") in
    let: "li" := (GoAlloc (go.PointerType leaseKey) (GoZeroVal (go.PointerType leaseKey) #())) in
    let: "$r0" := (map.lookup1 go.string (go.PointerType leaseKey) (![go.MapType go.string (go.PointerType leaseKey)] (StructFieldRef leaseCache "entries"%go (![go.PointerType leaseCache] "lc"))) (Convert (go.SliceType go.byte) go.string (![go.SliceType go.byte] "key"))) in
    do:  ("li" <-[go.PointerType leaseKey] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.PointerType leaseKey] "li") =⟨go.PointerType leaseKey⟩ (Convert go.untyped_nil (go.PointerType leaseKey) UntypedNil))
    then return: (#())
    else do:  #());;;
    let: "cacheResp" := (GoAlloc (go.PointerType clientv3.GetResponse) (GoZeroVal (go.PointerType clientv3.GetResponse) #())) in
    let: "$r0" := (![go.PointerType clientv3.GetResponse] (StructFieldRef leaseKey "response"%go (![go.PointerType leaseKey] "li"))) in
    do:  ("cacheResp" <-[go.PointerType clientv3.GetResponse] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((let: "$a0" := (![go.SliceType (go.PointerType mvccpb.KeyValue)] (StructFieldRef clientv3.GetResponse "Kvs"%go (![go.PointerType clientv3.GetResponse] "cacheResp"))) in
    (FuncResolve go.len [go.SliceType (go.PointerType mvccpb.KeyValue)] #()) "$a0") =⟨go.int⟩ #(W64 0))
    then
      let: "kv" := (GoAlloc (go.PointerType mvccpb.KeyValue) (GoZeroVal (go.PointerType mvccpb.KeyValue) #())) in
      let: "$r0" := (GoAlloc mvccpb.KeyValue (let: "$v0" := (![go.SliceType go.byte] "key") in
      let: "$v1" := (![go.int64] (StructFieldRef etcdserverpb.ResponseHeader "Revision"%go (![go.PointerType etcdserverpb.ResponseHeader] "respHeader"))) in
      CompositeLiteral mvccpb.KeyValue (LiteralValue [KeyedElement (Some (KeyField "Key"%go)) (ElementExpression (go.SliceType go.byte) "$v0"); KeyedElement (Some (KeyField "CreateRevision"%go)) (ElementExpression go.int64 "$v1")]))) in
      do:  ("kv" <-[go.PointerType mvccpb.KeyValue] "$r0");;;
      let: "$r0" := (let: "$a0" := (![go.SliceType (go.PointerType mvccpb.KeyValue)] (StructFieldRef clientv3.GetResponse "Kvs"%go (![go.PointerType clientv3.GetResponse] "cacheResp"))) in
      let: "$a1" := ((let: "$sl0" := (![go.PointerType mvccpb.KeyValue] "kv") in
      CompositeLiteral (go.SliceType (go.PointerType mvccpb.KeyValue)) (LiteralValue [KeyedElement None (ElementExpression (go.PointerType mvccpb.KeyValue) "$sl0")]))) in
      (FuncResolve go.append [go.SliceType (go.PointerType mvccpb.KeyValue)] #()) "$a0" "$a1") in
      do:  ((StructFieldRef clientv3.GetResponse "Kvs"%go (![go.PointerType clientv3.GetResponse] "cacheResp")) <-[go.SliceType (go.PointerType mvccpb.KeyValue)] "$r0");;;
      let: "$r0" := #(W64 1) in
      do:  ((StructFieldRef clientv3.GetResponse "Count"%go (![go.PointerType clientv3.GetResponse] "cacheResp")) <-[go.int64] "$r0")
    else do:  #());;;
    do:  ((StructFieldRef mvccpb.KeyValue "Version"%go (![go.PointerType mvccpb.KeyValue] (IndexRef (go.SliceType (go.PointerType mvccpb.KeyValue)) (![go.SliceType (go.PointerType mvccpb.KeyValue)] (StructFieldRef clientv3.GetResponse "Kvs"%go (![go.PointerType clientv3.GetResponse] "cacheResp")), #(W64 0))))) <-[go.int64] ((![go.int64] (StructFieldRef mvccpb.KeyValue "Version"%go (![go.PointerType mvccpb.KeyValue] (IndexRef (go.SliceType (go.PointerType mvccpb.KeyValue)) (![go.SliceType (go.PointerType mvccpb.KeyValue)] (StructFieldRef clientv3.GetResponse "Kvs"%go (![go.PointerType clientv3.GetResponse] "cacheResp")), #(W64 0)))))) +⟨go.int64⟩ #(W64 1)));;;
    (if: Convert go.untyped_bool go.bool ((![go.int64] (StructFieldRef mvccpb.KeyValue "ModRevision"%go (![go.PointerType mvccpb.KeyValue] (IndexRef (go.SliceType (go.PointerType mvccpb.KeyValue)) (![go.SliceType (go.PointerType mvccpb.KeyValue)] (StructFieldRef clientv3.GetResponse "Kvs"%go (![go.PointerType clientv3.GetResponse] "cacheResp")), #(W64 0)))))) <⟨go.int64⟩ (![go.int64] (StructFieldRef etcdserverpb.ResponseHeader "Revision"%go (![go.PointerType etcdserverpb.ResponseHeader] "respHeader"))))
    then
      let: "$r0" := (![go.PointerType etcdserverpb.ResponseHeader] "respHeader") in
      do:  ((StructFieldRef clientv3.GetResponse "Header"%go (![go.PointerType clientv3.GetResponse] "cacheResp")) <-[go.PointerType etcdserverpb.ResponseHeader] "$r0");;;
      let: "$r0" := (![go.int64] (StructFieldRef etcdserverpb.ResponseHeader "Revision"%go (![go.PointerType etcdserverpb.ResponseHeader] "respHeader"))) in
      do:  ((StructFieldRef mvccpb.KeyValue "ModRevision"%go (![go.PointerType mvccpb.KeyValue] (IndexRef (go.SliceType (go.PointerType mvccpb.KeyValue)) (![go.SliceType (go.PointerType mvccpb.KeyValue)] (StructFieldRef clientv3.GetResponse "Kvs"%go (![go.PointerType clientv3.GetResponse] "cacheResp")), #(W64 0))))) <-[go.int64] "$r0");;;
      let: "$r0" := (![go.SliceType go.byte] "val") in
      do:  ((StructFieldRef mvccpb.KeyValue "Value"%go (![go.PointerType mvccpb.KeyValue] (IndexRef (go.SliceType (go.PointerType mvccpb.KeyValue)) (![go.SliceType (go.PointerType mvccpb.KeyValue)] (StructFieldRef clientv3.GetResponse "Kvs"%go (![go.PointerType clientv3.GetResponse] "cacheResp")), #(W64 0))))) <-[go.SliceType go.byte] "$r0")
    else do:  #());;;
    return: #()).

(* go: cache.go:161:23 *)
Definition leaseCache__Deleteⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "lc" "key" "hdr",
    with_defer: (let: "lc" := (GoAlloc (go.PointerType leaseCache) "lc") in
    let: "hdr" := (GoAlloc (go.PointerType etcdserverpb.ResponseHeader) "hdr") in
    let: "key" := (GoAlloc go.string "key") in
    do:  ((MethodResolve (go.PointerType sync.RWMutex) "Lock"%go (StructFieldRef leaseCache "mu"%go (![go.PointerType leaseCache] "lc"))) #());;;
    do:  (let: "$f" := (MethodResolve (go.PointerType sync.RWMutex) "Unlock"%go (StructFieldRef leaseCache "mu"%go (![go.PointerType leaseCache] "lc"))) in
    "$defer" <-[deferType] (let: "$oldf" := (![deferType] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    do:  (let: "$a0" := (![go.string] "key") in
    let: "$a1" := (![go.PointerType etcdserverpb.ResponseHeader] "hdr") in
    (MethodResolve (go.PointerType leaseCache) "delete"%go (![go.PointerType leaseCache] "lc")) "$a0" "$a1");;;
    return: #()).

(* go: cache.go:167:23 *)
Definition leaseCache__deleteⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "lc" "key" "hdr",
    exception_do (let: "lc" := (GoAlloc (go.PointerType leaseCache) "lc") in
    let: "hdr" := (GoAlloc (go.PointerType etcdserverpb.ResponseHeader) "hdr") in
    let: "key" := (GoAlloc go.string "key") in
    (let: "li" := (GoAlloc (go.PointerType leaseKey) (GoZeroVal (go.PointerType leaseKey) #())) in
    let: "$r0" := (map.lookup1 go.string (go.PointerType leaseKey) (![go.MapType go.string (go.PointerType leaseKey)] (StructFieldRef leaseCache "entries"%go (![go.PointerType leaseCache] "lc"))) (![go.string] "key")) in
    do:  ("li" <-[go.PointerType leaseKey] "$r0");;;
    (if: Convert go.untyped_bool go.bool (((![go.PointerType leaseKey] "li") ≠⟨go.PointerType leaseKey⟩ (Convert go.untyped_nil (go.PointerType leaseKey) UntypedNil)) && ((![go.int64] (StructFieldRef etcdserverpb.ResponseHeader "Revision"%go (![go.PointerType etcdserverpb.ResponseHeader] "hdr"))) ≥⟨go.int64⟩ (![go.int64] (StructFieldRef etcdserverpb.ResponseHeader "Revision"%go (![go.PointerType etcdserverpb.ResponseHeader] (StructFieldRef clientv3.GetResponse "Header"%go (![go.PointerType clientv3.GetResponse] (StructFieldRef leaseKey "response"%go (![go.PointerType leaseKey] "li")))))))))
    then
      let: "$r0" := (Convert go.untyped_nil (go.SliceType (go.PointerType mvccpb.KeyValue)) UntypedNil) in
      do:  ((StructFieldRef clientv3.GetResponse "Kvs"%go (![go.PointerType clientv3.GetResponse] (StructFieldRef leaseKey "response"%go (![go.PointerType leaseKey] "li")))) <-[go.SliceType (go.PointerType mvccpb.KeyValue)] "$r0");;;
      let: "$r0" := (let: "$a0" := (![go.PointerType etcdserverpb.ResponseHeader] "hdr") in
      (FuncResolve copyHeader [] #()) "$a0") in
      do:  ((StructFieldRef clientv3.GetResponse "Header"%go (![go.PointerType clientv3.GetResponse] (StructFieldRef leaseKey "response"%go (![go.PointerType leaseKey] "li")))) <-[go.PointerType etcdserverpb.ResponseHeader] "$r0")
    else do:  #()));;;
    return: #()).

(* go: cache.go:174:23 *)
Definition leaseCache__Evictⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "lc" "key",
    with_defer: (let: "rev" := (GoAlloc go.int64 (GoZeroVal go.int64 #())) in
    let: "lc" := (GoAlloc (go.PointerType leaseCache) "lc") in
    let: "key" := (GoAlloc go.string "key") in
    do:  ((MethodResolve (go.PointerType sync.RWMutex) "Lock"%go (StructFieldRef leaseCache "mu"%go (![go.PointerType leaseCache] "lc"))) #());;;
    do:  (let: "$f" := (MethodResolve (go.PointerType sync.RWMutex) "Unlock"%go (StructFieldRef leaseCache "mu"%go (![go.PointerType leaseCache] "lc"))) in
    "$defer" <-[deferType] (let: "$oldf" := (![deferType] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    (let: "li" := (GoAlloc (go.PointerType leaseKey) (GoZeroVal (go.PointerType leaseKey) #())) in
    let: "$r0" := (map.lookup1 go.string (go.PointerType leaseKey) (![go.MapType go.string (go.PointerType leaseKey)] (StructFieldRef leaseCache "entries"%go (![go.PointerType leaseCache] "lc"))) (![go.string] "key")) in
    do:  ("li" <-[go.PointerType leaseKey] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.PointerType leaseKey] "li") ≠⟨go.PointerType leaseKey⟩ (Convert go.untyped_nil (go.PointerType leaseKey) UntypedNil))
    then
      let: "$r0" := (![go.int64] (StructFieldRef leaseKey "rev"%go (![go.PointerType leaseKey] "li"))) in
      do:  ("rev" <-[go.int64] "$r0");;;
      do:  (let: "$a0" := (![go.MapType go.string (go.PointerType leaseKey)] (StructFieldRef leaseCache "entries"%go (![go.PointerType leaseCache] "lc"))) in
      let: "$a1" := (![go.string] "key") in
      (FuncResolve go.delete [go.MapType go.string (go.PointerType leaseKey)] #()) "$a0" "$a1");;;
      let: "$r0" := ((FuncResolve time.Now [] #()) #()) in
      do:  (map.insert go.string (![go.MapType go.string time.Time] (StructFieldRef leaseCache "revokes"%go (![go.PointerType leaseCache] "lc"))) (![go.string] "key") "$r0")
    else do:  #()));;;
    return: (![go.int64] "rev")).

(* go: cache.go:185:23 *)
Definition leaseCache__EvictRangeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "lc" "key" "end",
    with_defer: (let: "lc" := (GoAlloc (go.PointerType leaseCache) "lc") in
    let: "end" := (GoAlloc go.string "end") in
    let: "key" := (GoAlloc go.string "key") in
    do:  ((MethodResolve (go.PointerType sync.RWMutex) "Lock"%go (StructFieldRef leaseCache "mu"%go (![go.PointerType leaseCache] "lc"))) #());;;
    do:  (let: "$f" := (MethodResolve (go.PointerType sync.RWMutex) "Unlock"%go (StructFieldRef leaseCache "mu"%go (![go.PointerType leaseCache] "lc"))) in
    "$defer" <-[deferType] (let: "$oldf" := (![deferType] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    let: "$range" := (![go.MapType go.string (go.PointerType leaseKey)] (StructFieldRef leaseCache "entries"%go (![go.PointerType leaseCache] "lc"))) in
    (let: "k" := (GoAlloc go.string (GoZeroVal go.string #())) in
    map.for_range go.string (go.PointerType leaseKey) "$range" (λ: "$key" "value",
      do:  ("k" <-[go.string] "$key");;;
      (if: let: "$a0" := (![go.string] "k") in
      let: "$a1" := (![go.string] "key") in
      let: "$a2" := (![go.string] "end") in
      (FuncResolve inRange [] #()) "$a0" "$a1" "$a2"
      then
        do:  (let: "$a0" := (![go.MapType go.string (go.PointerType leaseKey)] (StructFieldRef leaseCache "entries"%go (![go.PointerType leaseCache] "lc"))) in
        let: "$a1" := (![go.string] "key") in
        (FuncResolve go.delete [go.MapType go.string (go.PointerType leaseKey)] #()) "$a0" "$a1");;;
        let: "$r0" := ((FuncResolve time.Now [] #()) #()) in
        do:  (map.insert go.string (![go.MapType go.string time.Time] (StructFieldRef leaseCache "revokes"%go (![go.PointerType leaseCache] "lc"))) (![go.string] "key") "$r0")
      else do:  #())));;;
    return: #()).

(* go: cache.go:196:6 *)
Definition isBadOpⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "op",
    exception_do (let: "op" := (GoAlloc clientv3.Op "op") in
    return: ((((MethodResolve (go.PointerType clientv3.Op) "Rev"%go "op") #()) >⟨go.int64⟩ #(W64 0)) || ((let: "$a0" := ((MethodResolve (go.PointerType clientv3.Op) "RangeBytes"%go "op") #()) in
     (FuncResolve go.len [go.SliceType go.byte] #()) "$a0") >⟨go.int⟩ #(W64 0)))).

(* go: cache.go:198:23 *)
Definition leaseCache__Getⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "lc" "ctx" "op",
    exception_do (let: "lc" := (GoAlloc (go.PointerType leaseCache) "lc") in
    let: "op" := (GoAlloc clientv3.Op "op") in
    let: "ctx" := (GoAlloc context.Context "ctx") in
    (if: let: "$a0" := (![clientv3.Op] "op") in
    (FuncResolve isBadOp [] #()) "$a0"
    then return: (Convert go.untyped_nil (go.PointerType clientv3.GetResponse) UntypedNil, #false)
    else do:  #());;;
    let: "key" := (GoAlloc go.string (GoZeroVal go.string #())) in
    let: "$r0" := (Convert (go.SliceType go.byte) go.string ((MethodResolve (go.PointerType clientv3.Op) "KeyBytes"%go "op") #())) in
    do:  ("key" <-[go.string] "$r0");;;
    let: "wc" := (GoAlloc (go.ChannelType go.recvonly (go.StructType [

    ])) (GoZeroVal (go.ChannelType go.recvonly (go.StructType [

    ])) #())) in
    let: "li" := (GoAlloc (go.PointerType leaseKey) (GoZeroVal (go.PointerType leaseKey) #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.string] "key") in
    (MethodResolve (go.PointerType leaseCache) "notify"%go (![go.PointerType leaseCache] "lc")) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("li" <-[go.PointerType leaseKey] "$r0");;;
    do:  ("wc" <-[go.ChannelType go.recvonly (go.StructType [

    ])] "$r1");;;
    (if: Convert go.untyped_bool go.bool ((![go.PointerType leaseKey] "li") =⟨go.PointerType leaseKey⟩ (Convert go.untyped_nil (go.PointerType leaseKey) UntypedNil))
    then return: (Convert go.untyped_nil (go.PointerType clientv3.GetResponse) UntypedNil, #true)
    else do:  #());;;
    let: "$ch0" := (![go.ChannelType go.recvonly (go.StructType [

    ])] "wc") in
    let: "$ch1" := ((MethodResolve context.Context "Done"%go (![context.Context] "ctx")) #()) in
    SelectStmt (SelectStmtClauses None [(CommClause (RecvCase (go.StructType [

    ]) "$ch0") (do:  #())); (CommClause (RecvCase (go.StructType [

    ]) "$ch1") (return: (Convert go.untyped_nil (go.PointerType clientv3.GetResponse) UntypedNil, #true)))]);;;
    do:  ((MethodResolve (go.PointerType sync.RWMutex) "RLock"%go (StructFieldRef leaseCache "mu"%go (![go.PointerType leaseCache] "lc"))) #());;;
    let: "lk" := (GoAlloc leaseKey (GoZeroVal leaseKey #())) in
    let: "$r0" := (![leaseKey] (![go.PointerType leaseKey] "li")) in
    do:  ("lk" <-[leaseKey] "$r0");;;
    let: "ret" := (GoAlloc (go.PointerType clientv3.GetResponse) (GoZeroVal (go.PointerType clientv3.GetResponse) #())) in
    let: "$r0" := (let: "$a0" := (![clientv3.Op] "op") in
    (MethodResolve (go.PointerType leaseKey) "get"%go "lk") "$a0") in
    do:  ("ret" <-[go.PointerType clientv3.GetResponse] "$r0");;;
    do:  ((MethodResolve (go.PointerType sync.RWMutex) "RUnlock"%go (StructFieldRef leaseCache "mu"%go (![go.PointerType leaseCache] "lc"))) #());;;
    return: (![go.PointerType clientv3.GetResponse] "ret", #true)).

(* go: cache.go:219:21 *)
Definition leaseKey__getⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "lk" "op",
    exception_do (let: "lk" := (GoAlloc (go.PointerType leaseKey) "lk") in
    let: "op" := (GoAlloc clientv3.Op "op") in
    let: "ret" := (GoAlloc clientv3.GetResponse (GoZeroVal clientv3.GetResponse #())) in
    let: "$r0" := (![clientv3.GetResponse] (![go.PointerType clientv3.GetResponse] (StructFieldRef leaseKey "response"%go (![go.PointerType leaseKey] "lk")))) in
    do:  ("ret" <-[clientv3.GetResponse] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.PointerType etcdserverpb.ResponseHeader] (StructFieldRef clientv3.GetResponse "Header"%go "ret")) in
    (FuncResolve copyHeader [] #()) "$a0") in
    do:  ((StructFieldRef clientv3.GetResponse "Header"%go "ret") <-[go.PointerType etcdserverpb.ResponseHeader] "$r0");;;
    let: "empty" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := (((let: "$a0" := (![go.SliceType (go.PointerType mvccpb.KeyValue)] (StructFieldRef clientv3.GetResponse "Kvs"%go "ret")) in
    (FuncResolve go.len [go.SliceType (go.PointerType mvccpb.KeyValue)] #()) "$a0") =⟨go.int⟩ #(W64 0)) || ((MethodResolve (go.PointerType clientv3.Op) "IsCountOnly"%go "op") #())) in
    do:  ("empty" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "empty") || (((MethodResolve (go.PointerType clientv3.Op) "MinModRev"%go "op") #()) >⟨go.int64⟩ (![go.int64] (StructFieldRef mvccpb.KeyValue "ModRevision"%go (![go.PointerType mvccpb.KeyValue] (IndexRef (go.SliceType (go.PointerType mvccpb.KeyValue)) (![go.SliceType (go.PointerType mvccpb.KeyValue)] (StructFieldRef clientv3.GetResponse "Kvs"%go "ret"), #(W64 0)))))))) in
    do:  ("empty" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "empty") || ((((MethodResolve (go.PointerType clientv3.Op) "MaxModRev"%go "op") #()) ≠⟨go.int64⟩ #(W64 0)) && (((MethodResolve (go.PointerType clientv3.Op) "MaxModRev"%go "op") #()) <⟨go.int64⟩ (![go.int64] (StructFieldRef mvccpb.KeyValue "ModRevision"%go (![go.PointerType mvccpb.KeyValue] (IndexRef (go.SliceType (go.PointerType mvccpb.KeyValue)) (![go.SliceType (go.PointerType mvccpb.KeyValue)] (StructFieldRef clientv3.GetResponse "Kvs"%go "ret"), #(W64 0))))))))) in
    do:  ("empty" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "empty") || (((MethodResolve (go.PointerType clientv3.Op) "MinCreateRev"%go "op") #()) >⟨go.int64⟩ (![go.int64] (StructFieldRef mvccpb.KeyValue "CreateRevision"%go (![go.PointerType mvccpb.KeyValue] (IndexRef (go.SliceType (go.PointerType mvccpb.KeyValue)) (![go.SliceType (go.PointerType mvccpb.KeyValue)] (StructFieldRef clientv3.GetResponse "Kvs"%go "ret"), #(W64 0)))))))) in
    do:  ("empty" <-[go.bool] "$r0");;;
    let: "$r0" := ((![go.bool] "empty") || ((((MethodResolve (go.PointerType clientv3.Op) "MaxCreateRev"%go "op") #()) ≠⟨go.int64⟩ #(W64 0)) && (((MethodResolve (go.PointerType clientv3.Op) "MaxCreateRev"%go "op") #()) <⟨go.int64⟩ (![go.int64] (StructFieldRef mvccpb.KeyValue "CreateRevision"%go (![go.PointerType mvccpb.KeyValue] (IndexRef (go.SliceType (go.PointerType mvccpb.KeyValue)) (![go.SliceType (go.PointerType mvccpb.KeyValue)] (StructFieldRef clientv3.GetResponse "Kvs"%go "ret"), #(W64 0))))))))) in
    do:  ("empty" <-[go.bool] "$r0");;;
    (if: ![go.bool] "empty"
    then
      let: "$r0" := (Convert go.untyped_nil (go.SliceType (go.PointerType mvccpb.KeyValue)) UntypedNil) in
      do:  ((StructFieldRef clientv3.GetResponse "Kvs"%go "ret") <-[go.SliceType (go.PointerType mvccpb.KeyValue)] "$r0")
    else
      let: "kv" := (GoAlloc mvccpb.KeyValue (GoZeroVal mvccpb.KeyValue #())) in
      let: "$r0" := (![mvccpb.KeyValue] (![go.PointerType mvccpb.KeyValue] (IndexRef (go.SliceType (go.PointerType mvccpb.KeyValue)) (![go.SliceType (go.PointerType mvccpb.KeyValue)] (StructFieldRef clientv3.GetResponse "Kvs"%go "ret"), #(W64 0))))) in
      do:  ("kv" <-[mvccpb.KeyValue] "$r0");;;
      let: "$r0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) (let: "$a0" := (![go.SliceType go.byte] (StructFieldRef mvccpb.KeyValue "Key"%go "kv")) in
      (FuncResolve go.len [go.SliceType go.byte] #()) "$a0")) in
      do:  ((StructFieldRef mvccpb.KeyValue "Key"%go "kv") <-[go.SliceType go.byte] "$r0");;;
      do:  (let: "$a0" := (![go.SliceType go.byte] (StructFieldRef mvccpb.KeyValue "Key"%go "kv")) in
      let: "$a1" := (![go.SliceType go.byte] (StructFieldRef mvccpb.KeyValue "Key"%go (![go.PointerType mvccpb.KeyValue] (IndexRef (go.SliceType (go.PointerType mvccpb.KeyValue)) (![go.SliceType (go.PointerType mvccpb.KeyValue)] (StructFieldRef clientv3.GetResponse "Kvs"%go "ret"), #(W64 0)))))) in
      (FuncResolve go.copy [go.SliceType go.byte] #()) "$a0" "$a1");;;
      (if: (⟨go.bool⟩! ((MethodResolve (go.PointerType clientv3.Op) "IsKeysOnly"%go "op") #()))
      then
        let: "$r0" := ((FuncResolve go.make2 [go.SliceType go.byte] #()) (let: "$a0" := (![go.SliceType go.byte] (StructFieldRef mvccpb.KeyValue "Value"%go "kv")) in
        (FuncResolve go.len [go.SliceType go.byte] #()) "$a0")) in
        do:  ((StructFieldRef mvccpb.KeyValue "Value"%go "kv") <-[go.SliceType go.byte] "$r0");;;
        do:  (let: "$a0" := (![go.SliceType go.byte] (StructFieldRef mvccpb.KeyValue "Value"%go "kv")) in
        let: "$a1" := (![go.SliceType go.byte] (StructFieldRef mvccpb.KeyValue "Value"%go (![go.PointerType mvccpb.KeyValue] (IndexRef (go.SliceType (go.PointerType mvccpb.KeyValue)) (![go.SliceType (go.PointerType mvccpb.KeyValue)] (StructFieldRef clientv3.GetResponse "Kvs"%go "ret"), #(W64 0)))))) in
        (FuncResolve go.copy [go.SliceType go.byte] #()) "$a0" "$a1")
      else do:  #());;;
      let: "$r0" := (let: "$v0" := "kv" in
      CompositeLiteral (go.SliceType (go.PointerType mvccpb.KeyValue)) (LiteralValue [KeyedElement None (ElementExpression (go.PointerType mvccpb.KeyValue) "$v0")])) in
      do:  ((StructFieldRef clientv3.GetResponse "Kvs"%go "ret") <-[go.SliceType (go.PointerType mvccpb.KeyValue)] "$r0"));;;
    return: ("ret")).

(* go: cache.go:242:23 *)
Definition leaseCache__notifyⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "lc" "key",
    with_defer: (let: "lc" := (GoAlloc (go.PointerType leaseCache) "lc") in
    let: "key" := (GoAlloc go.string "key") in
    do:  ((MethodResolve (go.PointerType sync.RWMutex) "RLock"%go (StructFieldRef leaseCache "mu"%go (![go.PointerType leaseCache] "lc"))) #());;;
    do:  (let: "$f" := (MethodResolve (go.PointerType sync.RWMutex) "RUnlock"%go (StructFieldRef leaseCache "mu"%go (![go.PointerType leaseCache] "lc"))) in
    "$defer" <-[deferType] (let: "$oldf" := (![deferType] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    (let: "li" := (GoAlloc (go.PointerType leaseKey) (GoZeroVal (go.PointerType leaseKey) #())) in
    let: "$r0" := (map.lookup1 go.string (go.PointerType leaseKey) (![go.MapType go.string (go.PointerType leaseKey)] (StructFieldRef leaseCache "entries"%go (![go.PointerType leaseCache] "lc"))) (![go.string] "key")) in
    do:  ("li" <-[go.PointerType leaseKey] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.PointerType leaseKey] "li") ≠⟨go.PointerType leaseKey⟩ (Convert go.untyped_nil (go.PointerType leaseKey) UntypedNil))
    then
      return: (![go.PointerType leaseKey] "li", Convert (go.ChannelType go.sendrecv (go.StructType [

       ])) (go.ChannelType go.recvonly (go.StructType [

       ])) (![go.ChannelType go.sendrecv (go.StructType [

       ])] (StructFieldRef leaseKey "waitc"%go (![go.PointerType leaseKey] "li"))))
    else do:  #()));;;
    return: (Convert go.untyped_nil (go.PointerType leaseKey) UntypedNil, Convert go.untyped_nil (go.ChannelType go.recvonly (go.StructType [

     ])) UntypedNil)).

(* go: cache.go:251:23 *)
Definition leaseCache__clearOldRevokesⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "lc" "ctx",
    exception_do (let: "lc" := (GoAlloc (go.PointerType leaseCache) "lc") in
    let: "ctx" := (GoAlloc context.Context "ctx") in
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "$ch0" := ((MethodResolve context.Context "Done"%go (![context.Context] "ctx")) #()) in
      let: "$ch1" := (let: "$a0" := time.Second in
      (FuncResolve time.After [] #()) "$a0") in
      SelectStmt (SelectStmtClauses None [(CommClause (RecvCase (go.StructType [

      ]) "$ch0") (return: (#()))); (CommClause (RecvCase time.Time "$ch1") (do:  ((MethodResolve (go.PointerType sync.RWMutex) "Lock"%go (StructFieldRef leaseCache "mu"%go (![go.PointerType leaseCache] "lc"))) #());;;
      let: "$range" := (![go.MapType go.string time.Time] (StructFieldRef leaseCache "revokes"%go (![go.PointerType leaseCache] "lc"))) in
      (let: "lr" := (GoAlloc time.Time (GoZeroVal time.Time #())) in
      let: "k" := (GoAlloc go.string (GoZeroVal go.string #())) in
      map.for_range go.string time.Time "$range" (λ: "$key" "value",
        do:  ("lr" <-[time.Time] "$value");;;
        do:  ("k" <-[go.string] "$key");;;
        (if: Convert go.untyped_bool go.bool ((let: "$a0" := (let: "$a0" := revokeBackoff in
        (MethodResolve (go.PointerType time.Time) "Add"%go "lr") "$a0") in
        (FuncResolve time.Since [] #()) "$a0") >⟨time.Duration⟩ #(W64 0))
        then
          do:  (let: "$a0" := (![go.MapType go.string time.Time] (StructFieldRef leaseCache "revokes"%go (![go.PointerType leaseCache] "lc"))) in
          let: "$a1" := (![go.string] "k") in
          (FuncResolve go.delete [go.MapType go.string time.Time] #()) "$a0" "$a1")
        else do:  #())));;;
      do:  ((MethodResolve (go.PointerType sync.RWMutex) "Unlock"%go (StructFieldRef leaseCache "mu"%go (![go.PointerType leaseCache] "lc"))) #())))]));;;
    return: #()).

(* go: cache.go:268:23 *)
Definition leaseCache__evalCmpⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "lc" "cmps",
    exception_do (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "cmpVal" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "lc" := (GoAlloc (go.PointerType leaseCache) "lc") in
    let: "cmps" := (GoAlloc (go.SliceType clientv3.Cmp) "cmps") in
    let: "$range" := (![go.SliceType clientv3.Cmp] "cmps") in
    (let: "cmp" := (GoAlloc clientv3.Cmp (GoZeroVal clientv3.Cmp #())) in
    slice.for_range clientv3.Cmp "$range" (λ: "$key" "$value",
      do:  ("cmp" <-[clientv3.Cmp] "$value");;;
      do:  "$key";;;
      (if: Convert go.untyped_bool go.bool ((let: "$a0" := (![go.SliceType go.byte] (StructFieldRef clientv3.Cmp "RangeEnd"%go "cmp")) in
      (FuncResolve go.len [go.SliceType go.byte] #()) "$a0") >⟨go.int⟩ #(W64 0))
      then return: (#false, #false)
      else do:  #());;;
      let: "lk" := (GoAlloc (go.PointerType leaseKey) (GoZeroVal (go.PointerType leaseKey) #())) in
      let: "$r0" := (map.lookup1 go.string (go.PointerType leaseKey) (![go.MapType go.string (go.PointerType leaseKey)] (StructFieldRef leaseCache "entries"%go (![go.PointerType leaseCache] "lc"))) (Convert (go.SliceType go.byte) go.string (![go.SliceType go.byte] (StructFieldRef clientv3.Cmp "Key"%go "cmp")))) in
      do:  ("lk" <-[go.PointerType leaseKey] "$r0");;;
      (if: Convert go.untyped_bool go.bool ((![go.PointerType leaseKey] "lk") =⟨go.PointerType leaseKey⟩ (Convert go.untyped_nil (go.PointerType leaseKey) UntypedNil))
      then return: (#false, #false)
      else do:  #());;;
      (if: (⟨go.bool⟩! (let: "$a0" := (![go.PointerType clientv3.GetResponse] (StructFieldRef leaseKey "response"%go (![go.PointerType leaseKey] "lk"))) in
      let: "$a1" := (![clientv3.Cmp] "cmp") in
      (FuncResolve evalCmp [] #()) "$a0" "$a1"))
      then return: (#false, #true)
      else do:  #())));;;
    return: (#true, #true)).

(* go: cache.go:284:23 *)
Definition leaseCache__evalOpsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "lc" "ops",
    exception_do (let: "lc" := (GoAlloc (go.PointerType leaseCache) "lc") in
    let: "ops" := (GoAlloc (go.SliceType clientv3.Op) "ops") in
    let: "resps" := (GoAlloc (go.SliceType (go.PointerType etcdserverpb.ResponseOp)) (GoZeroVal (go.SliceType (go.PointerType etcdserverpb.ResponseOp)) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType (go.PointerType etcdserverpb.ResponseOp)] #()) (let: "$a0" := (![go.SliceType clientv3.Op] "ops") in
    (FuncResolve go.len [go.SliceType clientv3.Op] #()) "$a0")) in
    do:  ("resps" <-[go.SliceType (go.PointerType etcdserverpb.ResponseOp)] "$r0");;;
    let: "$range" := (![go.SliceType clientv3.Op] "ops") in
    (let: "op" := (GoAlloc clientv3.Op (GoZeroVal clientv3.Op #())) in
    let: "i" := (GoAlloc go.int (GoZeroVal go.int #())) in
    slice.for_range clientv3.Op "$range" (λ: "$key" "$value",
      do:  ("op" <-[clientv3.Op] "$value");;;
      do:  ("i" <-[go.int] "$key");;;
      (if: (⟨go.bool⟩! ((MethodResolve (go.PointerType clientv3.Op) "IsGet"%go "op") #())) || (let: "$a0" := (![clientv3.Op] "op") in
      (FuncResolve isBadOp [] #()) "$a0")
      then return: (Convert go.untyped_nil (go.SliceType (go.PointerType etcdserverpb.ResponseOp)) UntypedNil, #false)
      else do:  #());;;
      let: "lk" := (GoAlloc (go.PointerType leaseKey) (GoZeroVal (go.PointerType leaseKey) #())) in
      let: "$r0" := (map.lookup1 go.string (go.PointerType leaseKey) (![go.MapType go.string (go.PointerType leaseKey)] (StructFieldRef leaseCache "entries"%go (![go.PointerType leaseCache] "lc"))) (Convert (go.SliceType go.byte) go.string ((MethodResolve (go.PointerType clientv3.Op) "KeyBytes"%go "op") #()))) in
      do:  ("lk" <-[go.PointerType leaseKey] "$r0");;;
      (if: Convert go.untyped_bool go.bool ((![go.PointerType leaseKey] "lk") =⟨go.PointerType leaseKey⟩ (Convert go.untyped_nil (go.PointerType leaseKey) UntypedNil))
      then return: (Convert go.untyped_nil (go.SliceType (go.PointerType etcdserverpb.ResponseOp)) UntypedNil, #false)
      else do:  #());;;
      let: "resp" := (GoAlloc (go.PointerType clientv3.GetResponse) (GoZeroVal (go.PointerType clientv3.GetResponse) #())) in
      let: "$r0" := (let: "$a0" := (![clientv3.Op] "op") in
      (MethodResolve (go.PointerType leaseKey) "get"%go (![go.PointerType leaseKey] "lk")) "$a0") in
      do:  ("resp" <-[go.PointerType clientv3.GetResponse] "$r0");;;
      (if: Convert go.untyped_bool go.bool ((![go.PointerType clientv3.GetResponse] "resp") =⟨go.PointerType clientv3.GetResponse⟩ (Convert go.untyped_nil (go.PointerType clientv3.GetResponse) UntypedNil))
      then return: (Convert go.untyped_nil (go.SliceType (go.PointerType etcdserverpb.ResponseOp)) UntypedNil, #false)
      else do:  #());;;
      let: "$r0" := (GoAlloc etcdserverpb.ResponseOp (let: "$v0" := (GoAlloc etcdserverpb.ResponseOp_ResponseRange (let: "$v0" := (Convert (go.PointerType clientv3.GetResponse) (go.PointerType etcdserverpb.RangeResponse) (![go.PointerType clientv3.GetResponse] "resp")) in
      CompositeLiteral etcdserverpb.ResponseOp_ResponseRange (LiteralValue [KeyedElement (Some (KeyField "ResponseRange"%go)) (ElementExpression (go.PointerType etcdserverpb.RangeResponse) "$v0")]))) in
      CompositeLiteral etcdserverpb.ResponseOp (LiteralValue [KeyedElement (Some (KeyField "Response"%go)) (ElementExpression (go.PointerType etcdserverpb.ResponseOp_ResponseRange) "$v0")]))) in
      do:  ((IndexRef (go.SliceType (go.PointerType etcdserverpb.ResponseOp)) (![go.SliceType (go.PointerType etcdserverpb.ResponseOp)] "resps", ![go.int] "i")) <-[go.PointerType etcdserverpb.ResponseOp] "$r0")));;;
    return: (![go.SliceType (go.PointerType etcdserverpb.ResponseOp)] "resps", #true)).

(* NewKV wraps a KV instance so that all requests are wired through a leasing protocol.

   go: kv.go:57:6 *)
Definition NewKVⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "cl" "pfx" "opts",
    exception_do (let: "opts" := (GoAlloc (go.SliceType concurrency.SessionOption) "opts") in
    let: "pfx" := (GoAlloc go.string "pfx") in
    let: "cl" := (GoAlloc (go.PointerType clientv3.Client) "cl") in
    let: "cancel" := (GoAlloc context.CancelFunc (GoZeroVal context.CancelFunc #())) in
    let: "cctx" := (GoAlloc context.Context (GoZeroVal context.Context #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := ((MethodResolve (go.PointerType clientv3.Client) "Ctx"%go (![go.PointerType clientv3.Client] "cl")) #()) in
    (FuncResolve context.WithCancel [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("cctx" <-[context.Context] "$r0");;;
    do:  ("cancel" <-[context.CancelFunc] "$r1");;;
    let: "lkv" := (GoAlloc (go.PointerType leasingKV) (GoZeroVal (go.PointerType leasingKV) #())) in
    let: "$r0" := (GoAlloc leasingKV (let: "$v0" := (![go.PointerType clientv3.Client] "cl") in
    let: "$v1" := (![clientv3.KV] (StructFieldRef clientv3.Client "KV"%go (![go.PointerType clientv3.Client] "cl"))) in
    let: "$v2" := (![go.string] "pfx") in
    let: "$v3" := (let: "$v0" := ((FuncResolve go.make1 [go.MapType go.string time.Time] #()) #()) in
    CompositeLiteral leaseCache (LiteralValue [KeyedElement (Some (KeyField "revokes"%go)) (ElementExpression (go.MapType go.string time.Time) "$v0")])) in
    let: "$v4" := (![context.Context] "cctx") in
    let: "$v5" := (![context.CancelFunc] "cancel") in
    let: "$v6" := (![go.SliceType concurrency.SessionOption] "opts") in
    let: "$v7" := ((FuncResolve go.make1 [go.ChannelType go.sendrecv (go.StructType [

     ])] #()) #()) in
    CompositeLiteral leasingKV (LiteralValue [KeyedElement (Some (KeyField "cl"%go)) (ElementExpression (go.PointerType clientv3.Client) "$v0"); KeyedElement (Some (KeyField "kv"%go)) (ElementExpression clientv3.KV "$v1"); KeyedElement (Some (KeyField "pfx"%go)) (ElementExpression go.string "$v2"); KeyedElement (Some (KeyField "leases"%go)) (ElementExpression leaseCache "$v3"); KeyedElement (Some (KeyField "ctx"%go)) (ElementExpression context.Context "$v4"); KeyedElement (Some (KeyField "cancel"%go)) (ElementExpression context.CancelFunc "$v5"); KeyedElement (Some (KeyField "sessionOpts"%go)) (ElementExpression (go.SliceType concurrency.SessionOption) "$v6"); KeyedElement (Some (KeyField "sessionc"%go)) (ElementExpression (go.ChannelType go.sendrecv (go.StructType [

     ])) "$v7")]))) in
    do:  ("lkv" <-[go.PointerType leasingKV] "$r0");;;
    do:  (let: "$a0" := #(W64 2) in
    (MethodResolve (go.PointerType sync.WaitGroup) "Add"%go (StructFieldRef leasingKV "wg"%go (![go.PointerType leasingKV] "lkv"))) "$a0");;;
    let: "$go" := (λ: <>,
      with_defer: (do:  (let: "$f" := (MethodResolve (go.PointerType sync.WaitGroup) "Done"%go (StructFieldRef leasingKV "wg"%go (![go.PointerType leasingKV] "lkv"))) in
      "$defer" <-[deferType] (let: "$oldf" := (![deferType] "$defer") in
      (λ: <>,
        "$f" #();;
        "$oldf" #()
        )));;;
      do:  ((MethodResolve (go.PointerType leasingKV) "monitorSession"%go (![go.PointerType leasingKV] "lkv")) #());;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    let: "$go" := (λ: <>,
      with_defer: (do:  (let: "$f" := (MethodResolve (go.PointerType sync.WaitGroup) "Done"%go (StructFieldRef leasingKV "wg"%go (![go.PointerType leasingKV] "lkv"))) in
      "$defer" <-[deferType] (let: "$oldf" := (![deferType] "$defer") in
      (λ: <>,
        "$f" #();;
        "$oldf" #()
        )));;;
      do:  (let: "$a0" := (![context.Context] "cctx") in
      (MethodResolve (go.PointerType leaseCache) "clearOldRevokes"%go (StructFieldRef leasingKV "leases"%go (![go.PointerType leasingKV] "lkv"))) "$a0");;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    return: (Convert (go.PointerType leasingKV) clientv3.KV (![go.PointerType leasingKV] "lkv"), MethodResolve (go.PointerType leasingKV) "Close"%go (![go.PointerType leasingKV] "lkv"), let: "$a0" := (![context.Context] "cctx") in
     (MethodResolve (go.PointerType leasingKV) "waitSession"%go (![go.PointerType leasingKV] "lkv")) "$a0")).

(* go: kv.go:81:23 *)
Definition leasingKV__Closeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "lkv" <>,
    exception_do (let: "lkv" := (GoAlloc (go.PointerType leasingKV) "lkv") in
    do:  ((![context.CancelFunc] (StructFieldRef leasingKV "cancel"%go (![go.PointerType leasingKV] "lkv"))) #());;;
    do:  ((MethodResolve (go.PointerType sync.WaitGroup) "Wait"%go (StructFieldRef leasingKV "wg"%go (![go.PointerType leasingKV] "lkv"))) #());;;
    return: #()).

(* go: kv.go:86:23 *)
Definition leasingKV__Getⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "lkv" "ctx" "key" "opts",
    exception_do (let: "lkv" := (GoAlloc (go.PointerType leasingKV) "lkv") in
    let: "opts" := (GoAlloc (go.SliceType clientv3.OpOption) "opts") in
    let: "key" := (GoAlloc go.string "key") in
    let: "ctx" := (GoAlloc context.Context "ctx") in
    let: ("$ret0", "$ret1") := ((let: "$a0" := (![context.Context] "ctx") in
    let: "$a1" := (let: "$a0" := (![go.string] "key") in
    let: "$a1" := (![go.SliceType clientv3.OpOption] "opts") in
    (FuncResolve clientv3.OpGet [] #()) "$a0" "$a1") in
    (MethodResolve (go.PointerType leasingKV) "get"%go (![go.PointerType leasingKV] "lkv")) "$a0" "$a1")) in
    return: ("$ret0", "$ret1")).

(* go: kv.go:90:23 *)
Definition leasingKV__Putⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "lkv" "ctx" "key" "val" "opts",
    exception_do (let: "lkv" := (GoAlloc (go.PointerType leasingKV) "lkv") in
    let: "opts" := (GoAlloc (go.SliceType clientv3.OpOption) "opts") in
    let: "val" := (GoAlloc go.string "val") in
    let: "key" := (GoAlloc go.string "key") in
    let: "ctx" := (GoAlloc context.Context "ctx") in
    let: ("$ret0", "$ret1") := ((let: "$a0" := (![context.Context] "ctx") in
    let: "$a1" := (let: "$a0" := (![go.string] "key") in
    let: "$a1" := (![go.string] "val") in
    let: "$a2" := (![go.SliceType clientv3.OpOption] "opts") in
    (FuncResolve clientv3.OpPut [] #()) "$a0" "$a1" "$a2") in
    (MethodResolve (go.PointerType leasingKV) "put"%go (![go.PointerType leasingKV] "lkv")) "$a0" "$a1")) in
    return: ("$ret0", "$ret1")).

(* go: kv.go:94:23 *)
Definition leasingKV__Deleteⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "lkv" "ctx" "key" "opts",
    exception_do (let: "lkv" := (GoAlloc (go.PointerType leasingKV) "lkv") in
    let: "opts" := (GoAlloc (go.SliceType clientv3.OpOption) "opts") in
    let: "key" := (GoAlloc go.string "key") in
    let: "ctx" := (GoAlloc context.Context "ctx") in
    let: ("$ret0", "$ret1") := ((let: "$a0" := (![context.Context] "ctx") in
    let: "$a1" := (let: "$a0" := (![go.string] "key") in
    let: "$a1" := (![go.SliceType clientv3.OpOption] "opts") in
    (FuncResolve clientv3.OpDelete [] #()) "$a0" "$a1") in
    (MethodResolve (go.PointerType leasingKV) "delete"%go (![go.PointerType leasingKV] "lkv")) "$a0" "$a1")) in
    return: ("$ret0", "$ret1")).

(* go: kv.go:98:23 *)
Definition leasingKV__Doⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "lkv" "ctx" "op",
    exception_do (let: "lkv" := (GoAlloc (go.PointerType leasingKV) "lkv") in
    let: "op" := (GoAlloc clientv3.Op "op") in
    let: "ctx" := (GoAlloc context.Context "ctx") in
    let: "$sw" := #true in
    (if: "$sw" =⟨go.bool⟩ ((MethodResolve (go.PointerType clientv3.Op) "IsGet"%go "op") #())
    then
      let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
      let: "resp" := (GoAlloc (go.PointerType clientv3.GetResponse) (GoZeroVal (go.PointerType clientv3.GetResponse) #())) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![context.Context] "ctx") in
      let: "$a1" := (![clientv3.Op] "op") in
      (MethodResolve (go.PointerType leasingKV) "get"%go (![go.PointerType leasingKV] "lkv")) "$a0" "$a1") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("resp" <-[go.PointerType clientv3.GetResponse] "$r0");;;
      do:  ("err" <-[go.error] "$r1");;;
      return: ((MethodResolve (go.PointerType clientv3.GetResponse) "OpResponse"%go (![go.PointerType clientv3.GetResponse] "resp")) #(), ![go.error] "err")
    else
      (if: "$sw" =⟨go.bool⟩ ((MethodResolve (go.PointerType clientv3.Op) "IsPut"%go "op") #())
      then
        let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
        let: "resp" := (GoAlloc (go.PointerType clientv3.PutResponse) (GoZeroVal (go.PointerType clientv3.PutResponse) #())) in
        let: ("$ret0", "$ret1") := (let: "$a0" := (![context.Context] "ctx") in
        let: "$a1" := (![clientv3.Op] "op") in
        (MethodResolve (go.PointerType leasingKV) "put"%go (![go.PointerType leasingKV] "lkv")) "$a0" "$a1") in
        let: "$r0" := "$ret0" in
        let: "$r1" := "$ret1" in
        do:  ("resp" <-[go.PointerType clientv3.PutResponse] "$r0");;;
        do:  ("err" <-[go.error] "$r1");;;
        return: ((MethodResolve (go.PointerType clientv3.PutResponse) "OpResponse"%go (![go.PointerType clientv3.PutResponse] "resp")) #(), ![go.error] "err")
      else
        (if: "$sw" =⟨go.bool⟩ ((MethodResolve (go.PointerType clientv3.Op) "IsDelete"%go "op") #())
        then
          let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
          let: "resp" := (GoAlloc (go.PointerType clientv3.DeleteResponse) (GoZeroVal (go.PointerType clientv3.DeleteResponse) #())) in
          let: ("$ret0", "$ret1") := (let: "$a0" := (![context.Context] "ctx") in
          let: "$a1" := (![clientv3.Op] "op") in
          (MethodResolve (go.PointerType leasingKV) "delete"%go (![go.PointerType leasingKV] "lkv")) "$a0" "$a1") in
          let: "$r0" := "$ret0" in
          let: "$r1" := "$ret1" in
          do:  ("resp" <-[go.PointerType clientv3.DeleteResponse] "$r0");;;
          do:  ("err" <-[go.error] "$r1");;;
          return: ((MethodResolve (go.PointerType clientv3.DeleteResponse) "OpResponse"%go (![go.PointerType clientv3.DeleteResponse] "resp")) #(), ![go.error] "err")
        else
          (if: "$sw" =⟨go.bool⟩ ((MethodResolve (go.PointerType clientv3.Op) "IsTxn"%go "op") #())
          then
            let: "elseOps" := (GoAlloc (go.SliceType clientv3.Op) (GoZeroVal (go.SliceType clientv3.Op) #())) in
            let: "thenOps" := (GoAlloc (go.SliceType clientv3.Op) (GoZeroVal (go.SliceType clientv3.Op) #())) in
            let: "cmps" := (GoAlloc (go.SliceType clientv3.Cmp) (GoZeroVal (go.SliceType clientv3.Cmp) #())) in
            let: (("$ret0", "$ret1"), "$ret2") := ((MethodResolve (go.PointerType clientv3.Op) "Txn"%go "op") #()) in
            let: "$r0" := "$ret0" in
            let: "$r1" := "$ret1" in
            let: "$r2" := "$ret2" in
            do:  ("cmps" <-[go.SliceType clientv3.Cmp] "$r0");;;
            do:  ("thenOps" <-[go.SliceType clientv3.Op] "$r1");;;
            do:  ("elseOps" <-[go.SliceType clientv3.Op] "$r2");;;
            let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
            let: "resp" := (GoAlloc (go.PointerType clientv3.TxnResponse) (GoZeroVal (go.PointerType clientv3.TxnResponse) #())) in
            let: ("$ret0", "$ret1") := ((MethodResolve clientv3.Txn "Commit"%go (let: "$a0" := (![go.SliceType clientv3.Op] "elseOps") in
            (MethodResolve clientv3.Txn "Else"%go (let: "$a0" := (![go.SliceType clientv3.Op] "thenOps") in
            (MethodResolve clientv3.Txn "Then"%go (let: "$a0" := (![go.SliceType clientv3.Cmp] "cmps") in
            (MethodResolve clientv3.Txn "If"%go (let: "$a0" := (![context.Context] "ctx") in
            (MethodResolve (go.PointerType leasingKV) "Txn"%go (![go.PointerType leasingKV] "lkv")) "$a0")) "$a0")) "$a0")) "$a0")) #()) in
            let: "$r0" := "$ret0" in
            let: "$r1" := "$ret1" in
            do:  ("resp" <-[go.PointerType clientv3.TxnResponse] "$r0");;;
            do:  ("err" <-[go.error] "$r1");;;
            return: ((MethodResolve (go.PointerType clientv3.TxnResponse) "OpResponse"%go (![go.PointerType clientv3.TxnResponse] "resp")) #(), ![go.error] "err")
          else do:  #()))));;;
    return: (CompositeLiteral clientv3.OpResponse (LiteralValue []), Convert go.untyped_nil go.error UntypedNil)).

(* go: kv.go:117:23 *)
Definition leasingKV__Compactⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "lkv" "ctx" "rev" "opts",
    exception_do (let: "lkv" := (GoAlloc (go.PointerType leasingKV) "lkv") in
    let: "opts" := (GoAlloc (go.SliceType clientv3.CompactOption) "opts") in
    let: "rev" := (GoAlloc go.int64 "rev") in
    let: "ctx" := (GoAlloc context.Context "ctx") in
    let: ("$ret0", "$ret1") := ((let: "$a0" := (![context.Context] "ctx") in
    let: "$a1" := (![go.int64] "rev") in
    let: "$a2" := (![go.SliceType clientv3.CompactOption] "opts") in
    (MethodResolve clientv3.KV "Compact"%go (![clientv3.KV] (StructFieldRef leasingKV "kv"%go (![go.PointerType leasingKV] "lkv")))) "$a0" "$a1" "$a2")) in
    return: ("$ret0", "$ret1")).

(* go: kv.go:121:23 *)
Definition leasingKV__Txnⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "lkv" "ctx",
    exception_do (let: "lkv" := (GoAlloc (go.PointerType leasingKV) "lkv") in
    let: "ctx" := (GoAlloc context.Context "ctx") in
    return: (Convert (go.PointerType txnLeasing) clientv3.Txn (GoAlloc txnLeasing (let: "$v0" := (let: "$a0" := (![context.Context] "ctx") in
     (MethodResolve clientv3.KV "Txn"%go (![clientv3.KV] (StructFieldRef leasingKV "kv"%go (![go.PointerType leasingKV] "lkv")))) "$a0") in
     let: "$v1" := (![go.PointerType leasingKV] "lkv") in
     let: "$v2" := (![context.Context] "ctx") in
     CompositeLiteral txnLeasing (LiteralValue [KeyedElement (Some (KeyField "Txn"%go)) (ElementExpression clientv3.Txn "$v0"); KeyedElement (Some (KeyField "lkv"%go)) (ElementExpression (go.PointerType leasingKV) "$v1"); KeyedElement (Some (KeyField "ctx"%go)) (ElementExpression context.Context "$v2")]))))).

(* go: kv.go:125:23 *)
Definition leasingKV__monitorSessionⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "lkv" <>,
    exception_do (let: "lkv" := (GoAlloc (go.PointerType leasingKV) "lkv") in
    (for: (λ: <>, ((MethodResolve context.Context "Err"%go (![context.Context] (StructFieldRef leasingKV "ctx"%go (![go.PointerType leasingKV] "lkv")))) #()) =⟨go.error⟩ (Convert go.untyped_nil go.error UntypedNil)); (λ: <>, #()) := λ: <>,
      (if: Convert go.untyped_bool go.bool ((![go.PointerType concurrency.Session] (StructFieldRef leasingKV "session"%go (![go.PointerType leasingKV] "lkv"))) ≠⟨go.PointerType concurrency.Session⟩ (Convert go.untyped_nil (go.PointerType concurrency.Session) UntypedNil))
      then
        let: "$ch0" := ((MethodResolve (go.PointerType concurrency.Session) "Done"%go (![go.PointerType concurrency.Session] (StructFieldRef leasingKV "session"%go (![go.PointerType leasingKV] "lkv")))) #()) in
        let: "$ch1" := ((MethodResolve context.Context "Done"%go (![context.Context] (StructFieldRef leasingKV "ctx"%go (![go.PointerType leasingKV] "lkv")))) #()) in
        SelectStmt (SelectStmtClauses None [(CommClause (RecvCase (go.StructType [

        ]) "$ch0") (do:  #())); (CommClause (RecvCase (go.StructType [

        ]) "$ch1") (return: (#())))])
      else do:  #());;;
      do:  ((MethodResolve (go.PointerType sync.RWMutex) "Lock"%go (StructFieldRef leaseCache "mu"%go (StructFieldRef leasingKV "leases"%go (![go.PointerType leasingKV] "lkv")))) #());;;
      let: "$ch0" := (![go.ChannelType go.sendrecv (go.StructType [

      ])] (StructFieldRef leasingKV "sessionc"%go (![go.PointerType leasingKV] "lkv"))) in
      SelectStmt (SelectStmtClauses (Some (do:  #())) [(CommClause (RecvCase (go.StructType [

      ]) "$ch0") (let: "$r0" := ((FuncResolve go.make1 [go.ChannelType go.sendrecv (go.StructType [

       ])] #()) #()) in
      do:  ((StructFieldRef leasingKV "sessionc"%go (![go.PointerType leasingKV] "lkv")) <-[go.ChannelType go.sendrecv (go.StructType [

      ])] "$r0")))]);;;
      let: "$r0" := ((FuncResolve go.make1 [go.MapType go.string (go.PointerType leaseKey)] #()) #()) in
      do:  ((StructFieldRef leaseCache "entries"%go (StructFieldRef leasingKV "leases"%go (![go.PointerType leasingKV] "lkv"))) <-[go.MapType go.string (go.PointerType leaseKey)] "$r0");;;
      do:  ((MethodResolve (go.PointerType sync.RWMutex) "Unlock"%go (StructFieldRef leaseCache "mu"%go (StructFieldRef leasingKV "leases"%go (![go.PointerType leasingKV] "lkv")))) #());;;
      let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
      let: "s" := (GoAlloc (go.PointerType concurrency.Session) (GoZeroVal (go.PointerType concurrency.Session) #())) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![go.PointerType clientv3.Client] (StructFieldRef leasingKV "cl"%go (![go.PointerType leasingKV] "lkv"))) in
      let: "$a1" := (![go.SliceType concurrency.SessionOption] (StructFieldRef leasingKV "sessionOpts"%go (![go.PointerType leasingKV] "lkv"))) in
      (FuncResolve concurrency.NewSession [] #()) "$a0" "$a1") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("s" <-[go.PointerType concurrency.Session] "$r0");;;
      do:  ("err" <-[go.error] "$r1");;;
      (if: Convert go.untyped_bool go.bool ((![go.error] "err") ≠⟨go.error⟩ (Convert go.untyped_nil go.error UntypedNil))
      then continue: #()
      else do:  #());;;
      do:  ((MethodResolve (go.PointerType sync.RWMutex) "Lock"%go (StructFieldRef leaseCache "mu"%go (StructFieldRef leasingKV "leases"%go (![go.PointerType leasingKV] "lkv")))) #());;;
      let: "$r0" := (![go.PointerType concurrency.Session] "s") in
      do:  ((StructFieldRef leasingKV "session"%go (![go.PointerType leasingKV] "lkv")) <-[go.PointerType concurrency.Session] "$r0");;;
      do:  (let: "$a0" := (![go.ChannelType go.sendrecv (go.StructType [

      ])] (StructFieldRef leasingKV "sessionc"%go (![go.PointerType leasingKV] "lkv"))) in
      (FuncResolve go.close [go.ChannelType go.sendrecv (go.StructType [

       ])] #()) "$a0");;;
      do:  ((MethodResolve (go.PointerType sync.RWMutex) "Unlock"%go (StructFieldRef leaseCache "mu"%go (StructFieldRef leasingKV "leases"%go (![go.PointerType leasingKV] "lkv")))) #()));;;
    return: #()).

(* go: kv.go:155:23 *)
Definition leasingKV__monitorLeaseⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "lkv" "ctx" "key" "rev",
    with_defer: (let: "lkv" := (GoAlloc (go.PointerType leasingKV) "lkv") in
    let: "rev" := (GoAlloc go.int64 "rev") in
    let: "key" := (GoAlloc go.string "key") in
    let: "ctx" := (GoAlloc context.Context "ctx") in
    let: "cancel" := (GoAlloc context.CancelFunc (GoZeroVal context.CancelFunc #())) in
    let: "cctx" := (GoAlloc context.Context (GoZeroVal context.Context #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![context.Context] (StructFieldRef leasingKV "ctx"%go (![go.PointerType leasingKV] "lkv"))) in
    (FuncResolve context.WithCancel [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("cctx" <-[context.Context] "$r0");;;
    do:  ("cancel" <-[context.CancelFunc] "$r1");;;
    do:  (let: "$f" := (![context.CancelFunc] "cancel") in
    "$defer" <-[deferType] (let: "$oldf" := (![deferType] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    (for: (λ: <>, ((MethodResolve context.Context "Err"%go (![context.Context] "cctx")) #()) =⟨go.error⟩ (Convert go.untyped_nil go.error UntypedNil)); (λ: <>, #()) := λ: <>,
      (if: Convert go.untyped_bool go.bool ((![go.int64] "rev") =⟨go.int64⟩ #(W64 0))
      then
        let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
        let: "resp" := (GoAlloc (go.PointerType clientv3.GetResponse) (GoZeroVal (go.PointerType clientv3.GetResponse) #())) in
        let: ("$ret0", "$ret1") := (let: "$a0" := (![context.Context] "ctx") in
        let: "$a1" := ((![go.string] (StructFieldRef leasingKV "pfx"%go (![go.PointerType leasingKV] "lkv"))) +⟨go.string⟩ (![go.string] "key")) in
        let: "$a2" := #slice.nil in
        (MethodResolve clientv3.KV "Get"%go (![clientv3.KV] (StructFieldRef leasingKV "kv"%go (![go.PointerType leasingKV] "lkv")))) "$a0" "$a1" "$a2") in
        let: "$r0" := "$ret0" in
        let: "$r1" := "$ret1" in
        do:  ("resp" <-[go.PointerType clientv3.GetResponse] "$r0");;;
        do:  ("err" <-[go.error] "$r1");;;
        (if: Convert go.untyped_bool go.bool ((![go.error] "err") ≠⟨go.error⟩ (Convert go.untyped_nil go.error UntypedNil))
        then continue: #()
        else do:  #());;;
        let: "$r0" := (![go.int64] (StructFieldRef etcdserverpb.ResponseHeader "Revision"%go (![go.PointerType etcdserverpb.ResponseHeader] (StructFieldRef clientv3.GetResponse "Header"%go (![go.PointerType clientv3.GetResponse] "resp"))))) in
        do:  ("rev" <-[go.int64] "$r0");;;
        (if: Convert go.untyped_bool go.bool (((let: "$a0" := (![go.SliceType (go.PointerType mvccpb.KeyValue)] (StructFieldRef clientv3.GetResponse "Kvs"%go (![go.PointerType clientv3.GetResponse] "resp"))) in
        (FuncResolve go.len [go.SliceType (go.PointerType mvccpb.KeyValue)] #()) "$a0") =⟨go.int⟩ #(W64 0)) || ((Convert (go.SliceType go.byte) go.string (![go.SliceType go.byte] (StructFieldRef mvccpb.KeyValue "Value"%go (![go.PointerType mvccpb.KeyValue] (IndexRef (go.SliceType (go.PointerType mvccpb.KeyValue)) (![go.SliceType (go.PointerType mvccpb.KeyValue)] (StructFieldRef clientv3.GetResponse "Kvs"%go (![go.PointerType clientv3.GetResponse] "resp")), #(W64 0))))))) =⟨go.string⟩ #"REVOKE"%go))
        then
          do:  (let: "$a0" := (![context.Context] "cctx") in
          let: "$a1" := (![go.string] "key") in
          let: "$a2" := (![go.int64] "rev") in
          (MethodResolve (go.PointerType leasingKV) "rescind"%go (![go.PointerType leasingKV] "lkv")) "$a0" "$a1" "$a2");;;
          return: (#())
        else do:  #())
      else do:  #());;;
      let: "wch" := (GoAlloc clientv3.WatchChan (GoZeroVal clientv3.WatchChan #())) in
      let: "$r0" := (let: "$a0" := (![context.Context] "cctx") in
      let: "$a1" := ((![go.string] (StructFieldRef leasingKV "pfx"%go (![go.PointerType leasingKV] "lkv"))) +⟨go.string⟩ (![go.string] "key")) in
      let: "$a2" := ((let: "$sl0" := (let: "$a0" := ((![go.int64] "rev") +⟨go.int64⟩ #(W64 1)) in
      (FuncResolve clientv3.WithRev [] #()) "$a0") in
      CompositeLiteral (go.SliceType clientv3.OpOption) (LiteralValue [KeyedElement None (ElementExpression clientv3.OpOption "$sl0")]))) in
      (MethodResolve (go.PointerType clientv3.Client) "Watch"%go (![go.PointerType clientv3.Client] (StructFieldRef leasingKV "cl"%go (![go.PointerType leasingKV] "lkv")))) "$a0" "$a1" "$a2") in
      do:  ("wch" <-[clientv3.WatchChan] "$r0");;;
      let: "$range" := (![clientv3.WatchChan] "wch") in
      (let: "resp" := (GoAlloc clientv3.WatchResponse (GoZeroVal clientv3.WatchResponse #())) in
      chan.for_range clientv3.WatchResponse "$range" (λ: "$key",
        do:  ("resp" <-[clientv3.WatchResponse] "$key");;;
        let: "$range" := (![go.SliceType (go.PointerType clientv3.Event)] (StructFieldRef clientv3.WatchResponse "Events"%go "resp")) in
        (let: "ev" := (GoAlloc (go.PointerType clientv3.Event) (GoZeroVal (go.PointerType clientv3.Event) #())) in
        slice.for_range (go.PointerType clientv3.Event) "$range" (λ: "$key" "$value",
          do:  ("ev" <-[go.PointerType clientv3.Event] "$value");;;
          do:  "$key";;;
          (if: Convert go.untyped_bool go.bool ((Convert (go.SliceType go.byte) go.string (![go.SliceType go.byte] (StructFieldRef mvccpb.KeyValue "Value"%go (![go.PointerType mvccpb.KeyValue] (StructFieldRef clientv3.Event "Kv"%go (![go.PointerType clientv3.Event] "ev")))))) ≠⟨go.string⟩ #"REVOKE"%go)
          then continue: #()
          else do:  #());;;
          (if: Convert go.untyped_bool go.bool ((![go.int64] (StructFieldRef mvccpb.KeyValue "Lease"%go (![go.PointerType mvccpb.KeyValue] (StructFieldRef clientv3.Event "Kv"%go (![go.PointerType clientv3.Event] "ev"))))) =⟨clientv3.LeaseID⟩ ((MethodResolve (go.PointerType leasingKV) "leaseID"%go (![go.PointerType leasingKV] "lkv")) #()))
          then
            do:  (let: "$a0" := (![context.Context] "cctx") in
            let: "$a1" := (![go.string] "key") in
            let: "$a2" := (![go.int64] (StructFieldRef mvccpb.KeyValue "ModRevision"%go (![go.PointerType mvccpb.KeyValue] (StructFieldRef clientv3.Event "Kv"%go (![go.PointerType clientv3.Event] "ev"))))) in
            (MethodResolve (go.PointerType leasingKV) "rescind"%go (![go.PointerType leasingKV] "lkv")) "$a0" "$a1" "$a2")
          else do:  #());;;
          return: (#())))));;;
      let: "$r0" := #(W64 0) in
      do:  ("rev" <-[go.int64] "$r0"));;;
    return: #()).

(* rescind releases a lease from this client.

   go: kv.go:187:23 *)
Definition leasingKV__rescindⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "lkv" "ctx" "key" "rev",
    exception_do (let: "lkv" := (GoAlloc (go.PointerType leasingKV) "lkv") in
    let: "rev" := (GoAlloc go.int64 "rev") in
    let: "key" := (GoAlloc go.string "key") in
    let: "ctx" := (GoAlloc context.Context "ctx") in
    (if: Convert go.untyped_bool go.bool ((let: "$a0" := (![go.string] "key") in
    (MethodResolve (go.PointerType leaseCache) "Evict"%go (StructFieldRef leasingKV "leases"%go (![go.PointerType leasingKV] "lkv"))) "$a0") >⟨go.int64⟩ (![go.int64] "rev"))
    then return: (#())
    else do:  #());;;
    let: "cmp" := (GoAlloc clientv3.Cmp (GoZeroVal clientv3.Cmp #())) in
    let: "$r0" := (let: "$a0" := (let: "$a0" := ((![go.string] (StructFieldRef leasingKV "pfx"%go (![go.PointerType leasingKV] "lkv"))) +⟨go.string⟩ (![go.string] "key")) in
    (FuncResolve clientv3.CreateRevision [] #()) "$a0") in
    let: "$a1" := #"<"%go in
    let: "$a2" := (Convert go.int64 go.any (![go.int64] "rev")) in
    (FuncResolve clientv3.Compare [] #()) "$a0" "$a1" "$a2") in
    do:  ("cmp" <-[clientv3.Cmp] "$r0");;;
    let: "op" := (GoAlloc clientv3.Op (GoZeroVal clientv3.Op #())) in
    let: "$r0" := (let: "$a0" := ((![go.string] (StructFieldRef leasingKV "pfx"%go (![go.PointerType leasingKV] "lkv"))) +⟨go.string⟩ (![go.string] "key")) in
    let: "$a1" := #slice.nil in
    (FuncResolve clientv3.OpDelete [] #()) "$a0" "$a1") in
    do:  ("op" <-[clientv3.Op] "$r0");;;
    (for: (λ: <>, ((MethodResolve context.Context "Err"%go (![context.Context] "ctx")) #()) =⟨go.error⟩ (Convert go.untyped_nil go.error UntypedNil)); (λ: <>, #()) := λ: <>,
      (let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
      let: ("$ret0", "$ret1") := ((MethodResolve clientv3.Txn "Commit"%go (let: "$a0" := ((let: "$sl0" := (![clientv3.Op] "op") in
      CompositeLiteral (go.SliceType clientv3.Op) (LiteralValue [KeyedElement None (ElementExpression clientv3.Op "$sl0")]))) in
      (MethodResolve clientv3.Txn "Then"%go (let: "$a0" := ((let: "$sl0" := (![clientv3.Cmp] "cmp") in
      CompositeLiteral (go.SliceType clientv3.Cmp) (LiteralValue [KeyedElement None (ElementExpression clientv3.Cmp "$sl0")]))) in
      (MethodResolve clientv3.Txn "If"%go (let: "$a0" := (![context.Context] "ctx") in
      (MethodResolve clientv3.KV "Txn"%go (![clientv3.KV] (StructFieldRef leasingKV "kv"%go (![go.PointerType leasingKV] "lkv")))) "$a0")) "$a0")) "$a0")) #()) in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  "$r0";;;
      do:  ("err" <-[go.error] "$r1");;;
      (if: Convert go.untyped_bool go.bool ((![go.error] "err") =⟨go.error⟩ (Convert go.untyped_nil go.error UntypedNil))
      then return: (#())
      else do:  #())));;;
    return: #()).

(* go: kv.go:200:23 *)
Definition leasingKV__waitRescindⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "lkv" "ctx" "key" "rev",
    with_defer: (let: "lkv" := (GoAlloc (go.PointerType leasingKV) "lkv") in
    let: "rev" := (GoAlloc go.int64 "rev") in
    let: "key" := (GoAlloc go.string "key") in
    let: "ctx" := (GoAlloc context.Context "ctx") in
    let: "cancel" := (GoAlloc context.CancelFunc (GoZeroVal context.CancelFunc #())) in
    let: "cctx" := (GoAlloc context.Context (GoZeroVal context.Context #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![context.Context] "ctx") in
    (FuncResolve context.WithCancel [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("cctx" <-[context.Context] "$r0");;;
    do:  ("cancel" <-[context.CancelFunc] "$r1");;;
    do:  (let: "$f" := (![context.CancelFunc] "cancel") in
    "$defer" <-[deferType] (let: "$oldf" := (![deferType] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    let: "wch" := (GoAlloc clientv3.WatchChan (GoZeroVal clientv3.WatchChan #())) in
    let: "$r0" := (let: "$a0" := (![context.Context] "cctx") in
    let: "$a1" := ((![go.string] (StructFieldRef leasingKV "pfx"%go (![go.PointerType leasingKV] "lkv"))) +⟨go.string⟩ (![go.string] "key")) in
    let: "$a2" := ((let: "$sl0" := (let: "$a0" := ((![go.int64] "rev") +⟨go.int64⟩ #(W64 1)) in
    (FuncResolve clientv3.WithRev [] #()) "$a0") in
    CompositeLiteral (go.SliceType clientv3.OpOption) (LiteralValue [KeyedElement None (ElementExpression clientv3.OpOption "$sl0")]))) in
    (MethodResolve (go.PointerType clientv3.Client) "Watch"%go (![go.PointerType clientv3.Client] (StructFieldRef leasingKV "cl"%go (![go.PointerType leasingKV] "lkv")))) "$a0" "$a1" "$a2") in
    do:  ("wch" <-[clientv3.WatchChan] "$r0");;;
    let: "$range" := (![clientv3.WatchChan] "wch") in
    (let: "resp" := (GoAlloc clientv3.WatchResponse (GoZeroVal clientv3.WatchResponse #())) in
    chan.for_range clientv3.WatchResponse "$range" (λ: "$key",
      do:  ("resp" <-[clientv3.WatchResponse] "$key");;;
      let: "$range" := (![go.SliceType (go.PointerType clientv3.Event)] (StructFieldRef clientv3.WatchResponse "Events"%go "resp")) in
      (let: "ev" := (GoAlloc (go.PointerType clientv3.Event) (GoZeroVal (go.PointerType clientv3.Event) #())) in
      slice.for_range (go.PointerType clientv3.Event) "$range" (λ: "$key" "$value",
        do:  ("ev" <-[go.PointerType clientv3.Event] "$value");;;
        do:  "$key";;;
        (if: Convert go.untyped_bool go.bool ((![mvccpb.Event_EventType] (StructFieldRef clientv3.Event "Type"%go (![go.PointerType clientv3.Event] "ev"))) =⟨mvccpb.Event_EventType⟩ clientv3.EventTypeDelete)
        then return: ((MethodResolve context.Context "Err"%go (![context.Context] "ctx")) #())
        else do:  #())))));;;
    return: ((MethodResolve context.Context "Err"%go (![context.Context] "ctx")) #())).

(* go: kv.go:214:23 *)
Definition leasingKV__tryModifyOpⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "lkv" "ctx" "op",
    exception_do (let: "lkv" := (GoAlloc (go.PointerType leasingKV) "lkv") in
    let: "op" := (GoAlloc clientv3.Op "op") in
    let: "ctx" := (GoAlloc context.Context "ctx") in
    let: "key" := (GoAlloc go.string (GoZeroVal go.string #())) in
    let: "$r0" := (Convert (go.SliceType go.byte) go.string ((MethodResolve (go.PointerType clientv3.Op) "KeyBytes"%go "op") #())) in
    do:  ("key" <-[go.string] "$r0");;;
    let: "rev" := (GoAlloc go.int64 (GoZeroVal go.int64 #())) in
    let: "wc" := (GoAlloc (go.ChannelType go.sendonly (go.StructType [

    ])) (GoZeroVal (go.ChannelType go.sendonly (go.StructType [

    ])) #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.string] "key") in
    (MethodResolve (go.PointerType leaseCache) "Lock"%go (StructFieldRef leasingKV "leases"%go (![go.PointerType leasingKV] "lkv"))) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("wc" <-[go.ChannelType go.sendonly (go.StructType [

    ])] "$r0");;;
    do:  ("rev" <-[go.int64] "$r1");;;
    let: "cmp" := (GoAlloc clientv3.Cmp (GoZeroVal clientv3.Cmp #())) in
    let: "$r0" := (let: "$a0" := (let: "$a0" := ((![go.string] (StructFieldRef leasingKV "pfx"%go (![go.PointerType leasingKV] "lkv"))) +⟨go.string⟩ (![go.string] "key")) in
    (FuncResolve clientv3.CreateRevision [] #()) "$a0") in
    let: "$a1" := #"<"%go in
    let: "$a2" := (Convert go.int64 go.any ((![go.int64] "rev") +⟨go.int64⟩ #(W64 1))) in
    (FuncResolve clientv3.Compare [] #()) "$a0" "$a1" "$a2") in
    do:  ("cmp" <-[clientv3.Cmp] "$r0");;;
    let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
    let: "resp" := (GoAlloc (go.PointerType clientv3.TxnResponse) (GoZeroVal (go.PointerType clientv3.TxnResponse) #())) in
    let: ("$ret0", "$ret1") := ((MethodResolve clientv3.Txn "Commit"%go (let: "$a0" := ((let: "$sl0" := (![clientv3.Op] "op") in
    CompositeLiteral (go.SliceType clientv3.Op) (LiteralValue [KeyedElement None (ElementExpression clientv3.Op "$sl0")]))) in
    (MethodResolve clientv3.Txn "Then"%go (let: "$a0" := ((let: "$sl0" := (![clientv3.Cmp] "cmp") in
    CompositeLiteral (go.SliceType clientv3.Cmp) (LiteralValue [KeyedElement None (ElementExpression clientv3.Cmp "$sl0")]))) in
    (MethodResolve clientv3.Txn "If"%go (let: "$a0" := (![context.Context] "ctx") in
    (MethodResolve clientv3.KV "Txn"%go (![clientv3.KV] (StructFieldRef leasingKV "kv"%go (![go.PointerType leasingKV] "lkv")))) "$a0")) "$a0")) "$a0")) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("resp" <-[go.PointerType clientv3.TxnResponse] "$r0");;;
    do:  ("err" <-[go.error] "$r1");;;
    let: "$sw" := #true in
    (if: "$sw" =⟨go.bool⟩ ((![go.error] "err") ≠⟨go.error⟩ (Convert go.untyped_nil go.error UntypedNil))
    then
      do:  (let: "$a0" := (![go.string] "key") in
      (MethodResolve (go.PointerType leaseCache) "Evict"%go (StructFieldRef leasingKV "leases"%go (![go.PointerType leasingKV] "lkv"))) "$a0");;;
      (if: Convert go.untyped_bool go.bool ((![go.ChannelType go.sendonly (go.StructType [

      ])] "wc") ≠⟨go.ChannelType go.sendonly (go.StructType [

      ])⟩ (Convert go.untyped_nil (go.ChannelType go.sendonly (go.StructType [

      ])) UntypedNil))
      then
        do:  (let: "$a0" := (![go.ChannelType go.sendonly (go.StructType [

        ])] "wc") in
        (FuncResolve go.close [go.ChannelType go.sendonly (go.StructType [

         ])] #()) "$a0")
      else do:  #());;;
      return: (Convert go.untyped_nil (go.PointerType clientv3.TxnResponse) UntypedNil, Convert go.untyped_nil (go.ChannelType go.sendonly (go.StructType [

       ])) UntypedNil, ![go.error] "err")
    else
      (if: "$sw" =⟨go.bool⟩ (⟨go.bool⟩! (![go.bool] (StructFieldRef clientv3.TxnResponse "Succeeded"%go (![go.PointerType clientv3.TxnResponse] "resp"))))
      then
        (if: Convert go.untyped_bool go.bool ((![go.ChannelType go.sendonly (go.StructType [

        ])] "wc") ≠⟨go.ChannelType go.sendonly (go.StructType [

        ])⟩ (Convert go.untyped_nil (go.ChannelType go.sendonly (go.StructType [

        ])) UntypedNil))
        then
          do:  (let: "$a0" := (![go.ChannelType go.sendonly (go.StructType [

          ])] "wc") in
          (FuncResolve go.close [go.ChannelType go.sendonly (go.StructType [

           ])] #()) "$a0")
        else do:  #());;;
        return: (Convert go.untyped_nil (go.PointerType clientv3.TxnResponse) UntypedNil, Convert go.untyped_nil (go.ChannelType go.sendonly (go.StructType [

         ])) UntypedNil, ![go.error] "err")
      else do:  #()));;;
    return: (![go.PointerType clientv3.TxnResponse] "resp", ![go.ChannelType go.sendonly (go.StructType [

     ])] "wc", Convert go.untyped_nil go.error UntypedNil)).

(* go: kv.go:236:23 *)
Definition leasingKV__putⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "lkv" "ctx" "op",
    exception_do (let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
    let: "pr" := (GoAlloc (go.PointerType clientv3.PutResponse) (GoZeroVal (go.PointerType clientv3.PutResponse) #())) in
    let: "lkv" := (GoAlloc (go.PointerType leasingKV) "lkv") in
    let: "op" := (GoAlloc clientv3.Op "op") in
    let: "ctx" := (GoAlloc context.Context "ctx") in
    (let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
    let: "$r0" := (let: "$a0" := (![context.Context] "ctx") in
    (MethodResolve (go.PointerType leasingKV) "waitSession"%go (![go.PointerType leasingKV] "lkv")) "$a0") in
    do:  ("err" <-[go.error] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.error] "err") ≠⟨go.error⟩ (Convert go.untyped_nil go.error UntypedNil))
    then return: (Convert go.untyped_nil (go.PointerType clientv3.PutResponse) UntypedNil, ![go.error] "err")
    else do:  #()));;;
    (for: (λ: <>, ((MethodResolve context.Context "Err"%go (![context.Context] "ctx")) #()) =⟨go.error⟩ (Convert go.untyped_nil go.error UntypedNil)); (λ: <>, #()) := λ: <>,
      let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
      let: "wc" := (GoAlloc (go.ChannelType go.sendonly (go.StructType [

      ])) (GoZeroVal (go.ChannelType go.sendonly (go.StructType [

      ])) #())) in
      let: "resp" := (GoAlloc (go.PointerType clientv3.TxnResponse) (GoZeroVal (go.PointerType clientv3.TxnResponse) #())) in
      let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![context.Context] "ctx") in
      let: "$a1" := (![clientv3.Op] "op") in
      (MethodResolve (go.PointerType leasingKV) "tryModifyOp"%go (![go.PointerType leasingKV] "lkv")) "$a0" "$a1") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      let: "$r2" := "$ret2" in
      do:  ("resp" <-[go.PointerType clientv3.TxnResponse] "$r0");;;
      do:  ("wc" <-[go.ChannelType go.sendonly (go.StructType [

      ])] "$r1");;;
      do:  ("err" <-[go.error] "$r2");;;
      (if: Convert go.untyped_bool go.bool (((![go.error] "err") ≠⟨go.error⟩ (Convert go.untyped_nil go.error UntypedNil)) || ((![go.ChannelType go.sendonly (go.StructType [

      ])] "wc") =⟨go.ChannelType go.sendonly (go.StructType [

      ])⟩ (Convert go.untyped_nil (go.ChannelType go.sendonly (go.StructType [

      ])) UntypedNil)))
      then
        let: ("$ret0", "$ret1") := (let: "$a0" := (![context.Context] "ctx") in
        let: "$a1" := (Convert (go.SliceType go.byte) go.string ((MethodResolve (go.PointerType clientv3.Op) "KeyBytes"%go "op") #())) in
        let: "$a2" := (![clientv3.Op] "op") in
        (MethodResolve (go.PointerType leasingKV) "revoke"%go (![go.PointerType leasingKV] "lkv")) "$a0" "$a1" "$a2") in
        let: "$r0" := "$ret0" in
        let: "$r1" := "$ret1" in
        do:  ("resp" <-[go.PointerType clientv3.TxnResponse] "$r0");;;
        do:  ("err" <-[go.error] "$r1")
      else do:  #());;;
      (if: Convert go.untyped_bool go.bool ((![go.error] "err") ≠⟨go.error⟩ (Convert go.untyped_nil go.error UntypedNil))
      then return: (Convert go.untyped_nil (go.PointerType clientv3.PutResponse) UntypedNil, ![go.error] "err")
      else do:  #());;;
      (if: ![go.bool] (StructFieldRef clientv3.TxnResponse "Succeeded"%go (![go.PointerType clientv3.TxnResponse] "resp"))
      then
        do:  ((MethodResolve (go.PointerType sync.RWMutex) "Lock"%go (StructFieldRef leaseCache "mu"%go (StructFieldRef leasingKV "leases"%go (![go.PointerType leasingKV] "lkv")))) #());;;
        do:  (let: "$a0" := ((MethodResolve (go.PointerType clientv3.Op) "KeyBytes"%go "op") #()) in
        let: "$a1" := ((MethodResolve (go.PointerType clientv3.Op) "ValueBytes"%go "op") #()) in
        let: "$a2" := (![go.PointerType etcdserverpb.ResponseHeader] (StructFieldRef clientv3.TxnResponse "Header"%go (![go.PointerType clientv3.TxnResponse] "resp"))) in
        (MethodResolve (go.PointerType leaseCache) "Update"%go (StructFieldRef leasingKV "leases"%go (![go.PointerType leasingKV] "lkv"))) "$a0" "$a1" "$a2");;;
        do:  ((MethodResolve (go.PointerType sync.RWMutex) "Unlock"%go (StructFieldRef leaseCache "mu"%go (StructFieldRef leasingKV "leases"%go (![go.PointerType leasingKV] "lkv")))) #());;;
        let: "$r0" := (Convert (go.PointerType etcdserverpb.PutResponse) (go.PointerType clientv3.PutResponse) ((MethodResolve (go.PointerType etcdserverpb.ResponseOp) "GetResponsePut"%go (![go.PointerType etcdserverpb.ResponseOp] (IndexRef (go.SliceType (go.PointerType etcdserverpb.ResponseOp)) (![go.SliceType (go.PointerType etcdserverpb.ResponseOp)] (StructFieldRef clientv3.TxnResponse "Responses"%go (![go.PointerType clientv3.TxnResponse] "resp")), #(W64 0))))) #())) in
        do:  ("pr" <-[go.PointerType clientv3.PutResponse] "$r0");;;
        let: "$r0" := (![go.PointerType etcdserverpb.ResponseHeader] (StructFieldRef clientv3.TxnResponse "Header"%go (![go.PointerType clientv3.TxnResponse] "resp"))) in
        do:  ((StructFieldRef clientv3.PutResponse "Header"%go (![go.PointerType clientv3.PutResponse] "pr")) <-[go.PointerType etcdserverpb.ResponseHeader] "$r0")
      else do:  #());;;
      (if: Convert go.untyped_bool go.bool ((![go.ChannelType go.sendonly (go.StructType [

      ])] "wc") ≠⟨go.ChannelType go.sendonly (go.StructType [

      ])⟩ (Convert go.untyped_nil (go.ChannelType go.sendonly (go.StructType [

      ])) UntypedNil))
      then
        do:  (let: "$a0" := (![go.ChannelType go.sendonly (go.StructType [

        ])] "wc") in
        (FuncResolve go.close [go.ChannelType go.sendonly (go.StructType [

         ])] #()) "$a0")
      else do:  #());;;
      (if: ![go.bool] (StructFieldRef clientv3.TxnResponse "Succeeded"%go (![go.PointerType clientv3.TxnResponse] "resp"))
      then return: (![go.PointerType clientv3.PutResponse] "pr", Convert go.untyped_nil go.error UntypedNil)
      else do:  #()));;;
    return: (Convert go.untyped_nil (go.PointerType clientv3.PutResponse) UntypedNil, (MethodResolve context.Context "Err"%go (![context.Context] "ctx")) #())).

(* go: kv.go:265:23 *)
Definition leasingKV__acquireⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "lkv" "ctx" "key" "op",
    exception_do (let: "lkv" := (GoAlloc (go.PointerType leasingKV) "lkv") in
    let: "op" := (GoAlloc clientv3.Op "op") in
    let: "key" := (GoAlloc go.string "key") in
    let: "ctx" := (GoAlloc context.Context "ctx") in
    (for: (λ: <>, ((MethodResolve context.Context "Err"%go (![context.Context] "ctx")) #()) =⟨go.error⟩ (Convert go.untyped_nil go.error UntypedNil)); (λ: <>, #()) := λ: <>,
      (let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
      let: "$r0" := (let: "$a0" := (![context.Context] "ctx") in
      (MethodResolve (go.PointerType leasingKV) "waitSession"%go (![go.PointerType leasingKV] "lkv")) "$a0") in
      do:  ("err" <-[go.error] "$r0");;;
      (if: Convert go.untyped_bool go.bool ((![go.error] "err") ≠⟨go.error⟩ (Convert go.untyped_nil go.error UntypedNil))
      then return: (Convert go.untyped_nil (go.PointerType clientv3.TxnResponse) UntypedNil, ![go.error] "err")
      else do:  #()));;;
      let: "lcmp" := (GoAlloc clientv3.Cmp (GoZeroVal clientv3.Cmp #())) in
      let: "$r0" := (let: "$v0" := (Convert go.string (go.SliceType go.byte) (![go.string] "key")) in
      let: "$v1" := etcdserverpb.Compare_LEASE in
      CompositeLiteral clientv3.Cmp (LiteralValue [KeyedElement (Some (KeyField "Key"%go)) (ElementExpression (go.SliceType go.byte) "$v0"); KeyedElement (Some (KeyField "Target"%go)) (ElementExpression etcdserverpb.Compare_CompareTarget "$v1")])) in
      do:  ("lcmp" <-[clientv3.Cmp] "$r0");;;
      let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
      let: "resp" := (GoAlloc (go.PointerType clientv3.TxnResponse) (GoZeroVal (go.PointerType clientv3.TxnResponse) #())) in
      let: ("$ret0", "$ret1") := ((MethodResolve clientv3.Txn "Commit"%go (let: "$a0" := ((let: "$sl0" := (![clientv3.Op] "op") in
      let: "$sl1" := (let: "$a0" := ((![go.string] (StructFieldRef leasingKV "pfx"%go (![go.PointerType leasingKV] "lkv"))) +⟨go.string⟩ (![go.string] "key")) in
      let: "$a1" := #slice.nil in
      (FuncResolve clientv3.OpGet [] #()) "$a0" "$a1") in
      CompositeLiteral (go.SliceType clientv3.Op) (LiteralValue [KeyedElement None (ElementExpression clientv3.Op "$sl0"); KeyedElement None (ElementExpression clientv3.Op "$sl1")]))) in
      (MethodResolve clientv3.Txn "Else"%go (let: "$a0" := ((let: "$sl0" := (![clientv3.Op] "op") in
      let: "$sl1" := (let: "$a0" := ((![go.string] (StructFieldRef leasingKV "pfx"%go (![go.PointerType leasingKV] "lkv"))) +⟨go.string⟩ (![go.string] "key")) in
      let: "$a1" := #""%go in
      let: "$a2" := ((let: "$sl0" := (let: "$a0" := ((MethodResolve (go.PointerType leasingKV) "leaseID"%go (![go.PointerType leasingKV] "lkv")) #()) in
      (FuncResolve clientv3.WithLease [] #()) "$a0") in
      CompositeLiteral (go.SliceType clientv3.OpOption) (LiteralValue [KeyedElement None (ElementExpression clientv3.OpOption "$sl0")]))) in
      (FuncResolve clientv3.OpPut [] #()) "$a0" "$a1" "$a2") in
      CompositeLiteral (go.SliceType clientv3.Op) (LiteralValue [KeyedElement None (ElementExpression clientv3.Op "$sl0"); KeyedElement None (ElementExpression clientv3.Op "$sl1")]))) in
      (MethodResolve clientv3.Txn "Then"%go (let: "$a0" := ((let: "$sl0" := (let: "$a0" := (let: "$a0" := ((![go.string] (StructFieldRef leasingKV "pfx"%go (![go.PointerType leasingKV] "lkv"))) +⟨go.string⟩ (![go.string] "key")) in
      (FuncResolve clientv3.CreateRevision [] #()) "$a0") in
      let: "$a1" := #"="%go in
      let: "$a2" := (Convert go.int go.any #(W64 0)) in
      (FuncResolve clientv3.Compare [] #()) "$a0" "$a1" "$a2") in
      let: "$sl1" := (let: "$a0" := (![clientv3.Cmp] "lcmp") in
      let: "$a1" := #"="%go in
      let: "$a2" := (Convert go.int go.any #(W64 0)) in
      (FuncResolve clientv3.Compare [] #()) "$a0" "$a1" "$a2") in
      CompositeLiteral (go.SliceType clientv3.Cmp) (LiteralValue [KeyedElement None (ElementExpression clientv3.Cmp "$sl0"); KeyedElement None (ElementExpression clientv3.Cmp "$sl1")]))) in
      (MethodResolve clientv3.Txn "If"%go (let: "$a0" := (![context.Context] "ctx") in
      (MethodResolve clientv3.KV "Txn"%go (![clientv3.KV] (StructFieldRef leasingKV "kv"%go (![go.PointerType leasingKV] "lkv")))) "$a0")) "$a0")) "$a0")) "$a0")) #()) in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("resp" <-[go.PointerType clientv3.TxnResponse] "$r0");;;
      do:  ("err" <-[go.error] "$r1");;;
      (if: Convert go.untyped_bool go.bool ((![go.error] "err") =⟨go.error⟩ (Convert go.untyped_nil go.error UntypedNil))
      then
        (if: (⟨go.bool⟩! (![go.bool] (StructFieldRef clientv3.TxnResponse "Succeeded"%go (![go.PointerType clientv3.TxnResponse] "resp"))))
        then
          let: "kvs" := (GoAlloc (go.SliceType (go.PointerType mvccpb.KeyValue)) (GoZeroVal (go.SliceType (go.PointerType mvccpb.KeyValue)) #())) in
          let: "$r0" := (![go.SliceType (go.PointerType mvccpb.KeyValue)] (StructFieldRef etcdserverpb.RangeResponse "Kvs"%go ((MethodResolve (go.PointerType etcdserverpb.ResponseOp) "GetResponseRange"%go (![go.PointerType etcdserverpb.ResponseOp] (IndexRef (go.SliceType (go.PointerType etcdserverpb.ResponseOp)) (![go.SliceType (go.PointerType etcdserverpb.ResponseOp)] (StructFieldRef clientv3.TxnResponse "Responses"%go (![go.PointerType clientv3.TxnResponse] "resp")), #(W64 1))))) #()))) in
          do:  ("kvs" <-[go.SliceType (go.PointerType mvccpb.KeyValue)] "$r0");;;
          let: "$r0" := (((let: "$a0" := (![go.SliceType (go.PointerType mvccpb.KeyValue)] "kvs") in
          (FuncResolve go.len [go.SliceType (go.PointerType mvccpb.KeyValue)] #()) "$a0") >⟨go.int⟩ #(W64 0)) && ((![go.int64] (StructFieldRef mvccpb.KeyValue "Lease"%go (![go.PointerType mvccpb.KeyValue] (IndexRef (go.SliceType (go.PointerType mvccpb.KeyValue)) (![go.SliceType (go.PointerType mvccpb.KeyValue)] "kvs", #(W64 0)))))) =⟨clientv3.LeaseID⟩ ((MethodResolve (go.PointerType leasingKV) "leaseID"%go (![go.PointerType leasingKV] "lkv")) #()))) in
          do:  ((StructFieldRef clientv3.TxnResponse "Succeeded"%go (![go.PointerType clientv3.TxnResponse] "resp")) <-[go.bool] "$r0")
        else do:  #());;;
        return: (![go.PointerType clientv3.TxnResponse] "resp", Convert go.untyped_nil go.error UntypedNil)
      else do:  #());;;
      let: "serverErr" := (GoAlloc rpctypes.EtcdError (GoZeroVal rpctypes.EtcdError #())) in
      (if: let: "$a0" := (![go.error] "err") in
      let: "$a1" := (Convert (go.PointerType rpctypes.EtcdError) go.any "serverErr") in
      (FuncResolve errors.As [] #()) "$a0" "$a1"
      then return: (Convert go.untyped_nil (go.PointerType clientv3.TxnResponse) UntypedNil, ![go.error] "err")
      else do:  #());;;
      (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
      let: "ev" := (GoAlloc (go.PointerType status.Status) (GoZeroVal (go.PointerType status.Status) #())) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![go.error] "err") in
      (FuncResolve status.FromError [] #()) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("ev" <-[go.PointerType status.Status] "$r0");;;
      do:  ("ok" <-[go.bool] "$r1");;;
      (if: (![go.bool] "ok") && (((MethodResolve (go.PointerType status.Status) "Code"%go (![go.PointerType status.Status] "ev")) #()) ≠⟨codes.Code⟩ codes.Unavailable)
      then return: (Convert go.untyped_nil (go.PointerType clientv3.TxnResponse) UntypedNil, ![go.error] "err")
      else do:  #())));;;
    return: (Convert go.untyped_nil (go.PointerType clientv3.TxnResponse) UntypedNil, (MethodResolve context.Context "Err"%go (![context.Context] "ctx")) #())).

(* go: kv.go:301:23 *)
Definition leasingKV__getⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "lkv" "ctx" "op",
    exception_do (let: "lkv" := (GoAlloc (go.PointerType leasingKV) "lkv") in
    let: "op" := (GoAlloc clientv3.Op "op") in
    let: "ctx" := (GoAlloc context.Context "ctx") in
    let: "do" := (GoAlloc (go.FunctionType (go.Signature [] false [go.PointerType clientv3.GetResponse; go.error])) (GoZeroVal (go.FunctionType (go.Signature [] false [go.PointerType clientv3.GetResponse; go.error])) #())) in
    let: "$r0" := (λ: <>,
      exception_do (let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
      let: "r" := (GoAlloc clientv3.OpResponse (GoZeroVal clientv3.OpResponse #())) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![context.Context] "ctx") in
      let: "$a1" := (![clientv3.Op] "op") in
      (MethodResolve clientv3.KV "Do"%go (![clientv3.KV] (StructFieldRef leasingKV "kv"%go (![go.PointerType leasingKV] "lkv")))) "$a0" "$a1") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("r" <-[clientv3.OpResponse] "$r0");;;
      do:  ("err" <-[go.error] "$r1");;;
      return: ((MethodResolve (go.PointerType clientv3.OpResponse) "Get"%go "r") #(), ![go.error] "err"))
      ) in
    do:  ("do" <-[go.FunctionType (go.Signature [] false [go.PointerType clientv3.GetResponse; go.error])] "$r0");;;
    (if: (⟨go.bool⟩! ((MethodResolve (go.PointerType leasingKV) "readySession"%go (![go.PointerType leasingKV] "lkv")) #()))
    then
      let: ("$ret0", "$ret1") := (((![go.FunctionType (go.Signature [] false [go.PointerType clientv3.GetResponse; go.error])] "do") #())) in
      return: ("$ret0", "$ret1")
    else do:  #());;;
    (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "resp" := (GoAlloc (go.PointerType clientv3.GetResponse) (GoZeroVal (go.PointerType clientv3.GetResponse) #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![context.Context] "ctx") in
    let: "$a1" := (![clientv3.Op] "op") in
    (MethodResolve (go.PointerType leaseCache) "Get"%go (StructFieldRef leasingKV "leases"%go (![go.PointerType leasingKV] "lkv"))) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("resp" <-[go.PointerType clientv3.GetResponse] "$r0");;;
    do:  ("ok" <-[go.bool] "$r1");;;
    (if: Convert go.untyped_bool go.bool ((![go.PointerType clientv3.GetResponse] "resp") ≠⟨go.PointerType clientv3.GetResponse⟩ (Convert go.untyped_nil (go.PointerType clientv3.GetResponse) UntypedNil))
    then return: (![go.PointerType clientv3.GetResponse] "resp", Convert go.untyped_nil go.error UntypedNil)
    else
      (if: (⟨go.bool⟩! (![go.bool] "ok")) || ((MethodResolve (go.PointerType clientv3.Op) "IsSerializable"%go "op") #())
      then
        let: ("$ret0", "$ret1") := (((![go.FunctionType (go.Signature [] false [go.PointerType clientv3.GetResponse; go.error])] "do") #())) in
        return: ("$ret0", "$ret1")
      else do:  #())));;;
    let: "key" := (GoAlloc go.string (GoZeroVal go.string #())) in
    let: "$r0" := (Convert (go.SliceType go.byte) go.string ((MethodResolve (go.PointerType clientv3.Op) "KeyBytes"%go "op") #())) in
    do:  ("key" <-[go.string] "$r0");;;
    (if: (⟨go.bool⟩! (let: "$a0" := (![go.string] "key") in
    (MethodResolve (go.PointerType leaseCache) "MayAcquire"%go (StructFieldRef leasingKV "leases"%go (![go.PointerType leasingKV] "lkv"))) "$a0"))
    then
      let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
      let: "resp" := (GoAlloc clientv3.OpResponse (GoZeroVal clientv3.OpResponse #())) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![context.Context] "ctx") in
      let: "$a1" := (![clientv3.Op] "op") in
      (MethodResolve clientv3.KV "Do"%go (![clientv3.KV] (StructFieldRef leasingKV "kv"%go (![go.PointerType leasingKV] "lkv")))) "$a0" "$a1") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("resp" <-[clientv3.OpResponse] "$r0");;;
      do:  ("err" <-[go.error] "$r1");;;
      return: ((MethodResolve (go.PointerType clientv3.OpResponse) "Get"%go "resp") #(), ![go.error] "err")
    else do:  #());;;
    let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
    let: "resp" := (GoAlloc (go.PointerType clientv3.TxnResponse) (GoZeroVal (go.PointerType clientv3.TxnResponse) #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![context.Context] "ctx") in
    let: "$a1" := (![go.string] "key") in
    let: "$a2" := (let: "$a0" := (![go.string] "key") in
    let: "$a1" := #slice.nil in
    (FuncResolve clientv3.OpGet [] #()) "$a0" "$a1") in
    (MethodResolve (go.PointerType leasingKV) "acquire"%go (![go.PointerType leasingKV] "lkv")) "$a0" "$a1" "$a2") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("resp" <-[go.PointerType clientv3.TxnResponse] "$r0");;;
    do:  ("err" <-[go.error] "$r1");;;
    (if: Convert go.untyped_bool go.bool ((![go.error] "err") ≠⟨go.error⟩ (Convert go.untyped_nil go.error UntypedNil))
    then return: (Convert go.untyped_nil (go.PointerType clientv3.GetResponse) UntypedNil, ![go.error] "err")
    else do:  #());;;
    let: "getResp" := (GoAlloc (go.PointerType clientv3.GetResponse) (GoZeroVal (go.PointerType clientv3.GetResponse) #())) in
    let: "$r0" := (Convert (go.PointerType etcdserverpb.RangeResponse) (go.PointerType clientv3.GetResponse) ((MethodResolve (go.PointerType etcdserverpb.ResponseOp) "GetResponseRange"%go (![go.PointerType etcdserverpb.ResponseOp] (IndexRef (go.SliceType (go.PointerType etcdserverpb.ResponseOp)) (![go.SliceType (go.PointerType etcdserverpb.ResponseOp)] (StructFieldRef clientv3.TxnResponse "Responses"%go (![go.PointerType clientv3.TxnResponse] "resp")), #(W64 0))))) #())) in
    do:  ("getResp" <-[go.PointerType clientv3.GetResponse] "$r0");;;
    let: "$r0" := (![go.PointerType etcdserverpb.ResponseHeader] (StructFieldRef clientv3.TxnResponse "Header"%go (![go.PointerType clientv3.TxnResponse] "resp"))) in
    do:  ((StructFieldRef clientv3.GetResponse "Header"%go (![go.PointerType clientv3.GetResponse] "getResp")) <-[go.PointerType etcdserverpb.ResponseHeader] "$r0");;;
    (if: ![go.bool] (StructFieldRef clientv3.TxnResponse "Succeeded"%go (![go.PointerType clientv3.TxnResponse] "resp"))
    then
      let: "$r0" := (let: "$a0" := (![go.string] "key") in
      let: "$a1" := (![go.PointerType clientv3.GetResponse] "getResp") in
      let: "$a2" := (![clientv3.Op] "op") in
      (MethodResolve (go.PointerType leaseCache) "Add"%go (StructFieldRef leasingKV "leases"%go (![go.PointerType leasingKV] "lkv"))) "$a0" "$a1" "$a2") in
      do:  ("getResp" <-[go.PointerType clientv3.GetResponse] "$r0");;;
      do:  (let: "$a0" := #(W64 1) in
      (MethodResolve (go.PointerType sync.WaitGroup) "Add"%go (StructFieldRef leasingKV "wg"%go (![go.PointerType leasingKV] "lkv"))) "$a0");;;
      let: "$go" := (λ: <>,
        with_defer: (do:  (let: "$f" := (MethodResolve (go.PointerType sync.WaitGroup) "Done"%go (StructFieldRef leasingKV "wg"%go (![go.PointerType leasingKV] "lkv"))) in
        "$defer" <-[deferType] (let: "$oldf" := (![deferType] "$defer") in
        (λ: <>,
          "$f" #();;
          "$oldf" #()
          )));;;
        do:  (let: "$a0" := (![context.Context] "ctx") in
        let: "$a1" := (![go.string] "key") in
        let: "$a2" := (![go.int64] (StructFieldRef etcdserverpb.ResponseHeader "Revision"%go (![go.PointerType etcdserverpb.ResponseHeader] (StructFieldRef clientv3.TxnResponse "Header"%go (![go.PointerType clientv3.TxnResponse] "resp"))))) in
        (MethodResolve (go.PointerType leasingKV) "monitorLease"%go (![go.PointerType leasingKV] "lkv")) "$a0" "$a1" "$a2");;;
        return: #())
        ) in
      do:  (Fork ("$go" #()))
    else do:  #());;;
    return: (![go.PointerType clientv3.GetResponse] "getResp", Convert go.untyped_nil go.error UntypedNil)).

(* go: kv.go:340:23 *)
Definition leasingKV__deleteRangeRPCⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "lkv" "ctx" "maxLeaseRev" "key" "end",
    exception_do (let: "lkv" := (GoAlloc (go.PointerType leasingKV) "lkv") in
    let: "end" := (GoAlloc go.string "end") in
    let: "key" := (GoAlloc go.string "key") in
    let: "maxLeaseRev" := (GoAlloc go.int64 "maxLeaseRev") in
    let: "ctx" := (GoAlloc context.Context "ctx") in
    let: "lend" := (GoAlloc go.string (GoZeroVal go.string #())) in
    let: "lkey" := (GoAlloc go.string (GoZeroVal go.string #())) in
    let: "$r0" := ((![go.string] (StructFieldRef leasingKV "pfx"%go (![go.PointerType leasingKV] "lkv"))) +⟨go.string⟩ (![go.string] "key")) in
    let: "$r1" := ((![go.string] (StructFieldRef leasingKV "pfx"%go (![go.PointerType leasingKV] "lkv"))) +⟨go.string⟩ (![go.string] "end")) in
    do:  ("lkey" <-[go.string] "$r0");;;
    do:  ("lend" <-[go.string] "$r1");;;
    let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
    let: "resp" := (GoAlloc (go.PointerType clientv3.TxnResponse) (GoZeroVal (go.PointerType clientv3.TxnResponse) #())) in
    let: ("$ret0", "$ret1") := ((MethodResolve clientv3.Txn "Commit"%go (let: "$a0" := ((let: "$sl0" := (let: "$a0" := (![go.string] "key") in
    let: "$a1" := ((let: "$sl0" := (let: "$a0" := (![go.string] "end") in
    (FuncResolve clientv3.WithRange [] #()) "$a0") in
    let: "$sl1" := ((FuncResolve clientv3.WithKeysOnly [] #()) #()) in
    CompositeLiteral (go.SliceType clientv3.OpOption) (LiteralValue [KeyedElement None (ElementExpression clientv3.OpOption "$sl0"); KeyedElement None (ElementExpression clientv3.OpOption "$sl1")]))) in
    (FuncResolve clientv3.OpGet [] #()) "$a0" "$a1") in
    let: "$sl1" := (let: "$a0" := (![go.string] "key") in
    let: "$a1" := ((let: "$sl0" := (let: "$a0" := (![go.string] "end") in
    (FuncResolve clientv3.WithRange [] #()) "$a0") in
    CompositeLiteral (go.SliceType clientv3.OpOption) (LiteralValue [KeyedElement None (ElementExpression clientv3.OpOption "$sl0")]))) in
    (FuncResolve clientv3.OpDelete [] #()) "$a0" "$a1") in
    CompositeLiteral (go.SliceType clientv3.Op) (LiteralValue [KeyedElement None (ElementExpression clientv3.Op "$sl0"); KeyedElement None (ElementExpression clientv3.Op "$sl1")]))) in
    (MethodResolve clientv3.Txn "Then"%go (let: "$a0" := ((let: "$sl0" := (let: "$a0" := (let: "$a0" := (![go.string] "lend") in
    (MethodResolve clientv3.Cmp "WithRange"%go (let: "$a0" := (![go.string] "lkey") in
    (FuncResolve clientv3.CreateRevision [] #()) "$a0")) "$a0") in
    let: "$a1" := #"<"%go in
    let: "$a2" := (Convert go.int64 go.any ((![go.int64] "maxLeaseRev") +⟨go.int64⟩ #(W64 1))) in
    (FuncResolve clientv3.Compare [] #()) "$a0" "$a1" "$a2") in
    CompositeLiteral (go.SliceType clientv3.Cmp) (LiteralValue [KeyedElement None (ElementExpression clientv3.Cmp "$sl0")]))) in
    (MethodResolve clientv3.Txn "If"%go (let: "$a0" := (![context.Context] "ctx") in
    (MethodResolve clientv3.KV "Txn"%go (![clientv3.KV] (StructFieldRef leasingKV "kv"%go (![go.PointerType leasingKV] "lkv")))) "$a0")) "$a0")) "$a0")) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("resp" <-[go.PointerType clientv3.TxnResponse] "$r0");;;
    do:  ("err" <-[go.error] "$r1");;;
    (if: Convert go.untyped_bool go.bool ((![go.error] "err") ≠⟨go.error⟩ (Convert go.untyped_nil go.error UntypedNil))
    then
      do:  (let: "$a0" := (![go.string] "key") in
      let: "$a1" := (![go.string] "end") in
      (MethodResolve (go.PointerType leaseCache) "EvictRange"%go (StructFieldRef leasingKV "leases"%go (![go.PointerType leasingKV] "lkv"))) "$a0" "$a1");;;
      return: (Convert go.untyped_nil (go.PointerType clientv3.DeleteResponse) UntypedNil, ![go.error] "err")
    else do:  #());;;
    (if: (⟨go.bool⟩! (![go.bool] (StructFieldRef clientv3.TxnResponse "Succeeded"%go (![go.PointerType clientv3.TxnResponse] "resp"))))
    then return: (Convert go.untyped_nil (go.PointerType clientv3.DeleteResponse) UntypedNil, Convert go.untyped_nil go.error UntypedNil)
    else do:  #());;;
    let: "$range" := (![go.SliceType (go.PointerType mvccpb.KeyValue)] (StructFieldRef etcdserverpb.RangeResponse "Kvs"%go ((MethodResolve (go.PointerType etcdserverpb.ResponseOp) "GetResponseRange"%go (![go.PointerType etcdserverpb.ResponseOp] (IndexRef (go.SliceType (go.PointerType etcdserverpb.ResponseOp)) (![go.SliceType (go.PointerType etcdserverpb.ResponseOp)] (StructFieldRef clientv3.TxnResponse "Responses"%go (![go.PointerType clientv3.TxnResponse] "resp")), #(W64 0))))) #()))) in
    (let: "kv" := (GoAlloc (go.PointerType mvccpb.KeyValue) (GoZeroVal (go.PointerType mvccpb.KeyValue) #())) in
    slice.for_range (go.PointerType mvccpb.KeyValue) "$range" (λ: "$key" "$value",
      do:  ("kv" <-[go.PointerType mvccpb.KeyValue] "$value");;;
      do:  "$key";;;
      do:  (let: "$a0" := (Convert (go.SliceType go.byte) go.string (![go.SliceType go.byte] (StructFieldRef mvccpb.KeyValue "Key"%go (![go.PointerType mvccpb.KeyValue] "kv")))) in
      let: "$a1" := (![go.PointerType etcdserverpb.ResponseHeader] (StructFieldRef clientv3.TxnResponse "Header"%go (![go.PointerType clientv3.TxnResponse] "resp"))) in
      (MethodResolve (go.PointerType leaseCache) "Delete"%go (StructFieldRef leasingKV "leases"%go (![go.PointerType leasingKV] "lkv"))) "$a0" "$a1")));;;
    let: "delResp" := (GoAlloc (go.PointerType clientv3.DeleteResponse) (GoZeroVal (go.PointerType clientv3.DeleteResponse) #())) in
    let: "$r0" := (Convert (go.PointerType etcdserverpb.DeleteRangeResponse) (go.PointerType clientv3.DeleteResponse) ((MethodResolve (go.PointerType etcdserverpb.ResponseOp) "GetResponseDeleteRange"%go (![go.PointerType etcdserverpb.ResponseOp] (IndexRef (go.SliceType (go.PointerType etcdserverpb.ResponseOp)) (![go.SliceType (go.PointerType etcdserverpb.ResponseOp)] (StructFieldRef clientv3.TxnResponse "Responses"%go (![go.PointerType clientv3.TxnResponse] "resp")), #(W64 1))))) #())) in
    do:  ("delResp" <-[go.PointerType clientv3.DeleteResponse] "$r0");;;
    let: "$r0" := (![go.PointerType etcdserverpb.ResponseHeader] (StructFieldRef clientv3.TxnResponse "Header"%go (![go.PointerType clientv3.TxnResponse] "resp"))) in
    do:  ((StructFieldRef clientv3.DeleteResponse "Header"%go (![go.PointerType clientv3.DeleteResponse] "delResp")) <-[go.PointerType etcdserverpb.ResponseHeader] "$r0");;;
    return: (![go.PointerType clientv3.DeleteResponse] "delResp", Convert go.untyped_nil go.error UntypedNil)).

(* go: kv.go:363:23 *)
Definition leasingKV__deleteRangeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "lkv" "ctx" "op",
    exception_do (let: "lkv" := (GoAlloc (go.PointerType leasingKV) "lkv") in
    let: "op" := (GoAlloc clientv3.Op "op") in
    let: "ctx" := (GoAlloc context.Context "ctx") in
    let: "end" := (GoAlloc go.string (GoZeroVal go.string #())) in
    let: "key" := (GoAlloc go.string (GoZeroVal go.string #())) in
    let: "$r0" := (Convert (go.SliceType go.byte) go.string ((MethodResolve (go.PointerType clientv3.Op) "KeyBytes"%go "op") #())) in
    let: "$r1" := (Convert (go.SliceType go.byte) go.string ((MethodResolve (go.PointerType clientv3.Op) "RangeBytes"%go "op") #())) in
    do:  ("key" <-[go.string] "$r0");;;
    do:  ("end" <-[go.string] "$r1");;;
    (for: (λ: <>, ((MethodResolve context.Context "Err"%go (![context.Context] "ctx")) #()) =⟨go.error⟩ (Convert go.untyped_nil go.error UntypedNil)); (λ: <>, #()) := λ: <>,
      let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
      let: "maxLeaseRev" := (GoAlloc go.int64 (GoZeroVal go.int64 #())) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![context.Context] "ctx") in
      let: "$a1" := (![go.string] "key") in
      let: "$a2" := (![go.string] "end") in
      (MethodResolve (go.PointerType leasingKV) "revokeRange"%go (![go.PointerType leasingKV] "lkv")) "$a0" "$a1" "$a2") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("maxLeaseRev" <-[go.int64] "$r0");;;
      do:  ("err" <-[go.error] "$r1");;;
      (if: Convert go.untyped_bool go.bool ((![go.error] "err") ≠⟨go.error⟩ (Convert go.untyped_nil go.error UntypedNil))
      then return: (Convert go.untyped_nil (go.PointerType clientv3.DeleteResponse) UntypedNil, ![go.error] "err")
      else do:  #());;;
      let: "wcs" := (GoAlloc (go.SliceType (go.ChannelType go.sendonly (go.StructType [

      ]))) (GoZeroVal (go.SliceType (go.ChannelType go.sendonly (go.StructType [

      ]))) #())) in
      let: "$r0" := (let: "$a0" := (![go.string] "key") in
      let: "$a1" := (![go.string] "end") in
      (MethodResolve (go.PointerType leaseCache) "LockRange"%go (StructFieldRef leasingKV "leases"%go (![go.PointerType leasingKV] "lkv"))) "$a0" "$a1") in
      do:  ("wcs" <-[go.SliceType (go.ChannelType go.sendonly (go.StructType [

      ]))] "$r0");;;
      let: "delResp" := (GoAlloc (go.PointerType clientv3.DeleteResponse) (GoZeroVal (go.PointerType clientv3.DeleteResponse) #())) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![context.Context] "ctx") in
      let: "$a1" := (![go.int64] "maxLeaseRev") in
      let: "$a2" := (![go.string] "key") in
      let: "$a3" := (![go.string] "end") in
      (MethodResolve (go.PointerType leasingKV) "deleteRangeRPC"%go (![go.PointerType leasingKV] "lkv")) "$a0" "$a1" "$a2" "$a3") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("delResp" <-[go.PointerType clientv3.DeleteResponse] "$r0");;;
      do:  ("err" <-[go.error] "$r1");;;
      do:  (let: "$a0" := (![go.SliceType (go.ChannelType go.sendonly (go.StructType [

      ]))] "wcs") in
      (FuncResolve closeAll [] #()) "$a0");;;
      (if: Convert go.untyped_bool go.bool (((![go.error] "err") ≠⟨go.error⟩ (Convert go.untyped_nil go.error UntypedNil)) || ((![go.PointerType clientv3.DeleteResponse] "delResp") ≠⟨go.PointerType clientv3.DeleteResponse⟩ (Convert go.untyped_nil (go.PointerType clientv3.DeleteResponse) UntypedNil)))
      then return: (![go.PointerType clientv3.DeleteResponse] "delResp", ![go.error] "err")
      else do:  #()));;;
    return: (Convert go.untyped_nil (go.PointerType clientv3.DeleteResponse) UntypedNil, (MethodResolve context.Context "Err"%go (![context.Context] "ctx")) #())).

(* go: kv.go:380:23 *)
Definition leasingKV__deleteⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "lkv" "ctx" "op",
    exception_do (let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
    let: "dr" := (GoAlloc (go.PointerType clientv3.DeleteResponse) (GoZeroVal (go.PointerType clientv3.DeleteResponse) #())) in
    let: "lkv" := (GoAlloc (go.PointerType leasingKV) "lkv") in
    let: "op" := (GoAlloc clientv3.Op "op") in
    let: "ctx" := (GoAlloc context.Context "ctx") in
    (let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
    let: "$r0" := (let: "$a0" := (![context.Context] "ctx") in
    (MethodResolve (go.PointerType leasingKV) "waitSession"%go (![go.PointerType leasingKV] "lkv")) "$a0") in
    do:  ("err" <-[go.error] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.error] "err") ≠⟨go.error⟩ (Convert go.untyped_nil go.error UntypedNil))
    then return: (Convert go.untyped_nil (go.PointerType clientv3.DeleteResponse) UntypedNil, ![go.error] "err")
    else do:  #()));;;
    (if: Convert go.untyped_bool go.bool ((let: "$a0" := ((MethodResolve (go.PointerType clientv3.Op) "RangeBytes"%go "op") #()) in
    (FuncResolve go.len [go.SliceType go.byte] #()) "$a0") >⟨go.int⟩ #(W64 0))
    then
      let: ("$ret0", "$ret1") := ((let: "$a0" := (![context.Context] "ctx") in
      let: "$a1" := (![clientv3.Op] "op") in
      (MethodResolve (go.PointerType leasingKV) "deleteRange"%go (![go.PointerType leasingKV] "lkv")) "$a0" "$a1")) in
      return: ("$ret0", "$ret1")
    else do:  #());;;
    let: "key" := (GoAlloc go.string (GoZeroVal go.string #())) in
    let: "$r0" := (Convert (go.SliceType go.byte) go.string ((MethodResolve (go.PointerType clientv3.Op) "KeyBytes"%go "op") #())) in
    do:  ("key" <-[go.string] "$r0");;;
    (for: (λ: <>, ((MethodResolve context.Context "Err"%go (![context.Context] "ctx")) #()) =⟨go.error⟩ (Convert go.untyped_nil go.error UntypedNil)); (λ: <>, #()) := λ: <>,
      let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
      let: "wc" := (GoAlloc (go.ChannelType go.sendonly (go.StructType [

      ])) (GoZeroVal (go.ChannelType go.sendonly (go.StructType [

      ])) #())) in
      let: "resp" := (GoAlloc (go.PointerType clientv3.TxnResponse) (GoZeroVal (go.PointerType clientv3.TxnResponse) #())) in
      let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![context.Context] "ctx") in
      let: "$a1" := (![clientv3.Op] "op") in
      (MethodResolve (go.PointerType leasingKV) "tryModifyOp"%go (![go.PointerType leasingKV] "lkv")) "$a0" "$a1") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      let: "$r2" := "$ret2" in
      do:  ("resp" <-[go.PointerType clientv3.TxnResponse] "$r0");;;
      do:  ("wc" <-[go.ChannelType go.sendonly (go.StructType [

      ])] "$r1");;;
      do:  ("err" <-[go.error] "$r2");;;
      (if: Convert go.untyped_bool go.bool (((![go.error] "err") ≠⟨go.error⟩ (Convert go.untyped_nil go.error UntypedNil)) || ((![go.ChannelType go.sendonly (go.StructType [

      ])] "wc") =⟨go.ChannelType go.sendonly (go.StructType [

      ])⟩ (Convert go.untyped_nil (go.ChannelType go.sendonly (go.StructType [

      ])) UntypedNil)))
      then
        let: ("$ret0", "$ret1") := (let: "$a0" := (![context.Context] "ctx") in
        let: "$a1" := (![go.string] "key") in
        let: "$a2" := (![clientv3.Op] "op") in
        (MethodResolve (go.PointerType leasingKV) "revoke"%go (![go.PointerType leasingKV] "lkv")) "$a0" "$a1" "$a2") in
        let: "$r0" := "$ret0" in
        let: "$r1" := "$ret1" in
        do:  ("resp" <-[go.PointerType clientv3.TxnResponse] "$r0");;;
        do:  ("err" <-[go.error] "$r1")
      else do:  #());;;
      (if: Convert go.untyped_bool go.bool ((![go.error] "err") ≠⟨go.error⟩ (Convert go.untyped_nil go.error UntypedNil))
      then
        do:  (let: "$a0" := (![go.string] "key") in
        (MethodResolve (go.PointerType leaseCache) "Evict"%go (StructFieldRef leasingKV "leases"%go (![go.PointerType leasingKV] "lkv"))) "$a0");;;
        return: (Convert go.untyped_nil (go.PointerType clientv3.DeleteResponse) UntypedNil, ![go.error] "err")
      else do:  #());;;
      (if: ![go.bool] (StructFieldRef clientv3.TxnResponse "Succeeded"%go (![go.PointerType clientv3.TxnResponse] "resp"))
      then
        let: "$r0" := (Convert (go.PointerType etcdserverpb.DeleteRangeResponse) (go.PointerType clientv3.DeleteResponse) ((MethodResolve (go.PointerType etcdserverpb.ResponseOp) "GetResponseDeleteRange"%go (![go.PointerType etcdserverpb.ResponseOp] (IndexRef (go.SliceType (go.PointerType etcdserverpb.ResponseOp)) (![go.SliceType (go.PointerType etcdserverpb.ResponseOp)] (StructFieldRef clientv3.TxnResponse "Responses"%go (![go.PointerType clientv3.TxnResponse] "resp")), #(W64 0))))) #())) in
        do:  ("dr" <-[go.PointerType clientv3.DeleteResponse] "$r0");;;
        let: "$r0" := (![go.PointerType etcdserverpb.ResponseHeader] (StructFieldRef clientv3.TxnResponse "Header"%go (![go.PointerType clientv3.TxnResponse] "resp"))) in
        do:  ((StructFieldRef clientv3.DeleteResponse "Header"%go (![go.PointerType clientv3.DeleteResponse] "dr")) <-[go.PointerType etcdserverpb.ResponseHeader] "$r0");;;
        do:  (let: "$a0" := (![go.string] "key") in
        let: "$a1" := (![go.PointerType etcdserverpb.ResponseHeader] (StructFieldRef clientv3.DeleteResponse "Header"%go (![go.PointerType clientv3.DeleteResponse] "dr"))) in
        (MethodResolve (go.PointerType leaseCache) "Delete"%go (StructFieldRef leasingKV "leases"%go (![go.PointerType leasingKV] "lkv"))) "$a0" "$a1")
      else do:  #());;;
      (if: Convert go.untyped_bool go.bool ((![go.ChannelType go.sendonly (go.StructType [

      ])] "wc") ≠⟨go.ChannelType go.sendonly (go.StructType [

      ])⟩ (Convert go.untyped_nil (go.ChannelType go.sendonly (go.StructType [

      ])) UntypedNil))
      then
        do:  (let: "$a0" := (![go.ChannelType go.sendonly (go.StructType [

        ])] "wc") in
        (FuncResolve go.close [go.ChannelType go.sendonly (go.StructType [

         ])] #()) "$a0")
      else do:  #());;;
      (if: ![go.bool] (StructFieldRef clientv3.TxnResponse "Succeeded"%go (![go.PointerType clientv3.TxnResponse] "resp"))
      then return: (![go.PointerType clientv3.DeleteResponse] "dr", Convert go.untyped_nil go.error UntypedNil)
      else do:  #()));;;
    return: (Convert go.untyped_nil (go.PointerType clientv3.DeleteResponse) UntypedNil, (MethodResolve context.Context "Err"%go (![context.Context] "ctx")) #())).

(* go: kv.go:413:23 *)
Definition leasingKV__revokeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "lkv" "ctx" "key" "op",
    exception_do (let: "lkv" := (GoAlloc (go.PointerType leasingKV) "lkv") in
    let: "op" := (GoAlloc clientv3.Op "op") in
    let: "key" := (GoAlloc go.string "key") in
    let: "ctx" := (GoAlloc context.Context "ctx") in
    let: "rev" := (GoAlloc go.int64 (GoZeroVal go.int64 #())) in
    let: "$r0" := (let: "$a0" := (![go.string] "key") in
    (MethodResolve (go.PointerType leaseCache) "Rev"%go (StructFieldRef leasingKV "leases"%go (![go.PointerType leasingKV] "lkv"))) "$a0") in
    do:  ("rev" <-[go.int64] "$r0");;;
    let: "txn" := (GoAlloc clientv3.Txn (GoZeroVal clientv3.Txn #())) in
    let: "$r0" := (let: "$a0" := ((let: "$sl0" := (![clientv3.Op] "op") in
    CompositeLiteral (go.SliceType clientv3.Op) (LiteralValue [KeyedElement None (ElementExpression clientv3.Op "$sl0")]))) in
    (MethodResolve clientv3.Txn "Then"%go (let: "$a0" := ((let: "$sl0" := (let: "$a0" := (let: "$a0" := ((![go.string] (StructFieldRef leasingKV "pfx"%go (![go.PointerType leasingKV] "lkv"))) +⟨go.string⟩ (![go.string] "key")) in
    (FuncResolve clientv3.CreateRevision [] #()) "$a0") in
    let: "$a1" := #"<"%go in
    let: "$a2" := (Convert go.int64 go.any ((![go.int64] "rev") +⟨go.int64⟩ #(W64 1))) in
    (FuncResolve clientv3.Compare [] #()) "$a0" "$a1" "$a2") in
    CompositeLiteral (go.SliceType clientv3.Cmp) (LiteralValue [KeyedElement None (ElementExpression clientv3.Cmp "$sl0")]))) in
    (MethodResolve clientv3.Txn "If"%go (let: "$a0" := (![context.Context] "ctx") in
    (MethodResolve clientv3.KV "Txn"%go (![clientv3.KV] (StructFieldRef leasingKV "kv"%go (![go.PointerType leasingKV] "lkv")))) "$a0")) "$a0")) "$a0") in
    do:  ("txn" <-[clientv3.Txn] "$r0");;;
    let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
    let: "resp" := (GoAlloc (go.PointerType clientv3.TxnResponse) (GoZeroVal (go.PointerType clientv3.TxnResponse) #())) in
    let: ("$ret0", "$ret1") := ((MethodResolve clientv3.Txn "Commit"%go (let: "$a0" := ((let: "$sl0" := (let: "$a0" := ((![go.string] (StructFieldRef leasingKV "pfx"%go (![go.PointerType leasingKV] "lkv"))) +⟨go.string⟩ (![go.string] "key")) in
    let: "$a1" := #"REVOKE"%go in
    let: "$a2" := ((let: "$sl0" := ((FuncResolve clientv3.WithIgnoreLease [] #()) #()) in
    CompositeLiteral (go.SliceType clientv3.OpOption) (LiteralValue [KeyedElement None (ElementExpression clientv3.OpOption "$sl0")]))) in
    (FuncResolve clientv3.OpPut [] #()) "$a0" "$a1" "$a2") in
    CompositeLiteral (go.SliceType clientv3.Op) (LiteralValue [KeyedElement None (ElementExpression clientv3.Op "$sl0")]))) in
    (MethodResolve clientv3.Txn "Else"%go (![clientv3.Txn] "txn")) "$a0")) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("resp" <-[go.PointerType clientv3.TxnResponse] "$r0");;;
    do:  ("err" <-[go.error] "$r1");;;
    (if: ((![go.error] "err") ≠⟨go.error⟩ (Convert go.untyped_nil go.error UntypedNil)) || (![go.bool] (StructFieldRef clientv3.TxnResponse "Succeeded"%go (![go.PointerType clientv3.TxnResponse] "resp")))
    then return: (![go.PointerType clientv3.TxnResponse] "resp", ![go.error] "err")
    else do:  #());;;
    return: (![go.PointerType clientv3.TxnResponse] "resp", let: "$a0" := (![context.Context] "ctx") in
     let: "$a1" := (![go.string] "key") in
     let: "$a2" := (![go.int64] (StructFieldRef etcdserverpb.ResponseHeader "Revision"%go (![go.PointerType etcdserverpb.ResponseHeader] (StructFieldRef clientv3.TxnResponse "Header"%go (![go.PointerType clientv3.TxnResponse] "resp"))))) in
     (MethodResolve (go.PointerType leasingKV) "waitRescind"%go (![go.PointerType leasingKV] "lkv")) "$a0" "$a1" "$a2")).

(* go: kv.go:423:23 *)
Definition leasingKV__revokeRangeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "lkv" "ctx" "begin" "end",
    exception_do (let: "lkv" := (GoAlloc (go.PointerType leasingKV) "lkv") in
    let: "end" := (GoAlloc go.string "end") in
    let: "begin" := (GoAlloc go.string "begin") in
    let: "ctx" := (GoAlloc context.Context "ctx") in
    let: "lend" := (GoAlloc go.string (GoZeroVal go.string #())) in
    let: "lkey" := (GoAlloc go.string (GoZeroVal go.string #())) in
    let: "$r0" := ((![go.string] (StructFieldRef leasingKV "pfx"%go (![go.PointerType leasingKV] "lkv"))) +⟨go.string⟩ (![go.string] "begin")) in
    let: "$r1" := #""%go in
    do:  ("lkey" <-[go.string] "$r0");;;
    do:  ("lend" <-[go.string] "$r1");;;
    (if: Convert go.untyped_bool go.bool ((let: "$a0" := (![go.string] "end") in
    (FuncResolve go.len [go.string] #()) "$a0") >⟨go.int⟩ #(W64 0))
    then
      let: "$r0" := ((![go.string] (StructFieldRef leasingKV "pfx"%go (![go.PointerType leasingKV] "lkv"))) +⟨go.string⟩ (![go.string] "end")) in
      do:  ("lend" <-[go.string] "$r0")
    else do:  #());;;
    let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
    let: "leaseKeys" := (GoAlloc (go.PointerType clientv3.GetResponse) (GoZeroVal (go.PointerType clientv3.GetResponse) #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![context.Context] "ctx") in
    let: "$a1" := (![go.string] "lkey") in
    let: "$a2" := ((let: "$sl0" := (let: "$a0" := (![go.string] "lend") in
    (FuncResolve clientv3.WithRange [] #()) "$a0") in
    CompositeLiteral (go.SliceType clientv3.OpOption) (LiteralValue [KeyedElement None (ElementExpression clientv3.OpOption "$sl0")]))) in
    (MethodResolve clientv3.KV "Get"%go (![clientv3.KV] (StructFieldRef leasingKV "kv"%go (![go.PointerType leasingKV] "lkv")))) "$a0" "$a1" "$a2") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("leaseKeys" <-[go.PointerType clientv3.GetResponse] "$r0");;;
    do:  ("err" <-[go.error] "$r1");;;
    (if: Convert go.untyped_bool go.bool ((![go.error] "err") ≠⟨go.error⟩ (Convert go.untyped_nil go.error UntypedNil))
    then return: (#(W64 0), ![go.error] "err")
    else do:  #());;;
    let: ("$ret0", "$ret1") := ((let: "$a0" := (![context.Context] "ctx") in
    let: "$a1" := (![go.SliceType (go.PointerType mvccpb.KeyValue)] (StructFieldRef clientv3.GetResponse "Kvs"%go (![go.PointerType clientv3.GetResponse] "leaseKeys"))) in
    (MethodResolve (go.PointerType leasingKV) "revokeLeaseKvs"%go (![go.PointerType leasingKV] "lkv")) "$a0" "$a1")) in
    return: ("$ret0", "$ret1")).

(* go: kv.go:435:23 *)
Definition leasingKV__revokeLeaseKvsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "lkv" "ctx" "kvs",
    exception_do (let: "lkv" := (GoAlloc (go.PointerType leasingKV) "lkv") in
    let: "kvs" := (GoAlloc (go.SliceType (go.PointerType mvccpb.KeyValue)) "kvs") in
    let: "ctx" := (GoAlloc context.Context "ctx") in
    let: "maxLeaseRev" := (GoAlloc go.int64 (GoZeroVal go.int64 #())) in
    let: "$r0" := #(W64 0) in
    do:  ("maxLeaseRev" <-[go.int64] "$r0");;;
    let: "$range" := (![go.SliceType (go.PointerType mvccpb.KeyValue)] "kvs") in
    (let: "kv" := (GoAlloc (go.PointerType mvccpb.KeyValue) (GoZeroVal (go.PointerType mvccpb.KeyValue) #())) in
    slice.for_range (go.PointerType mvccpb.KeyValue) "$range" (λ: "$key" "$value",
      do:  ("kv" <-[go.PointerType mvccpb.KeyValue] "$value");;;
      do:  "$key";;;
      (let: "rev" := (GoAlloc go.int64 (GoZeroVal go.int64 #())) in
      let: "$r0" := (![go.int64] (StructFieldRef mvccpb.KeyValue "CreateRevision"%go (![go.PointerType mvccpb.KeyValue] "kv"))) in
      do:  ("rev" <-[go.int64] "$r0");;;
      (if: Convert go.untyped_bool go.bool ((![go.int64] "rev") >⟨go.int64⟩ (![go.int64] "maxLeaseRev"))
      then
        let: "$r0" := (![go.int64] "rev") in
        do:  ("maxLeaseRev" <-[go.int64] "$r0")
      else do:  #()));;;
      (if: Convert go.untyped_bool go.bool ((![go.int64] (StructFieldRef mvccpb.KeyValue "Lease"%go (![go.PointerType mvccpb.KeyValue] "kv"))) =⟨clientv3.LeaseID⟩ ((MethodResolve (go.PointerType leasingKV) "leaseID"%go (![go.PointerType leasingKV] "lkv")) #()))
      then continue: #()
      else do:  #());;;
      let: "key" := (GoAlloc go.string (GoZeroVal go.string #())) in
      let: "$r0" := (let: "$a0" := (Convert (go.SliceType go.byte) go.string (![go.SliceType go.byte] (StructFieldRef mvccpb.KeyValue "Key"%go (![go.PointerType mvccpb.KeyValue] "kv")))) in
      let: "$a1" := (![go.string] (StructFieldRef leasingKV "pfx"%go (![go.PointerType leasingKV] "lkv"))) in
      (FuncResolve strings.TrimPrefix [] #()) "$a0" "$a1") in
      do:  ("key" <-[go.string] "$r0");;;
      (let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![context.Context] "ctx") in
      let: "$a1" := (![go.string] "key") in
      let: "$a2" := (let: "$a0" := (![go.string] "key") in
      let: "$a1" := #slice.nil in
      (FuncResolve clientv3.OpGet [] #()) "$a0" "$a1") in
      (MethodResolve (go.PointerType leasingKV) "revoke"%go (![go.PointerType leasingKV] "lkv")) "$a0" "$a1" "$a2") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  "$r0";;;
      do:  ("err" <-[go.error] "$r1");;;
      (if: Convert go.untyped_bool go.bool ((![go.error] "err") ≠⟨go.error⟩ (Convert go.untyped_nil go.error UntypedNil))
      then return: (#(W64 0), ![go.error] "err")
      else do:  #()))));;;
    return: (![go.int64] "maxLeaseRev", Convert go.untyped_nil go.error UntypedNil)).

(* go: kv.go:453:23 *)
Definition leasingKV__waitSessionⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "lkv" "ctx",
    exception_do (let: "lkv" := (GoAlloc (go.PointerType leasingKV) "lkv") in
    let: "ctx" := (GoAlloc context.Context "ctx") in
    do:  ((MethodResolve (go.PointerType sync.RWMutex) "RLock"%go (StructFieldRef leaseCache "mu"%go (StructFieldRef leasingKV "leases"%go (![go.PointerType leasingKV] "lkv")))) #());;;
    let: "sessionc" := (GoAlloc (go.ChannelType go.sendrecv (go.StructType [

    ])) (GoZeroVal (go.ChannelType go.sendrecv (go.StructType [

    ])) #())) in
    let: "$r0" := (![go.ChannelType go.sendrecv (go.StructType [

    ])] (StructFieldRef leasingKV "sessionc"%go (![go.PointerType leasingKV] "lkv"))) in
    do:  ("sessionc" <-[go.ChannelType go.sendrecv (go.StructType [

    ])] "$r0");;;
    do:  ((MethodResolve (go.PointerType sync.RWMutex) "RUnlock"%go (StructFieldRef leaseCache "mu"%go (StructFieldRef leasingKV "leases"%go (![go.PointerType leasingKV] "lkv")))) #());;;
    let: "$ch0" := (![go.ChannelType go.sendrecv (go.StructType [

    ])] "sessionc") in
    let: "$ch1" := ((MethodResolve context.Context "Done"%go (![context.Context] (StructFieldRef leasingKV "ctx"%go (![go.PointerType leasingKV] "lkv")))) #()) in
    let: "$ch2" := ((MethodResolve context.Context "Done"%go (![context.Context] "ctx")) #()) in
    SelectStmt (SelectStmtClauses None [(CommClause (RecvCase (go.StructType [

    ]) "$ch0") (return: (Convert go.untyped_nil go.error UntypedNil))); (CommClause (RecvCase (go.StructType [

    ]) "$ch1") (return: ((MethodResolve context.Context "Err"%go (![context.Context] (StructFieldRef leasingKV "ctx"%go (![go.PointerType leasingKV] "lkv")))) #()))); (CommClause (RecvCase (go.StructType [

    ]) "$ch2") (return: ((MethodResolve context.Context "Err"%go (![context.Context] "ctx")) #())))])).

(* go: kv.go:467:23 *)
Definition leasingKV__readySessionⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "lkv" <>,
    with_defer: (let: "lkv" := (GoAlloc (go.PointerType leasingKV) "lkv") in
    do:  ((MethodResolve (go.PointerType sync.RWMutex) "RLock"%go (StructFieldRef leaseCache "mu"%go (StructFieldRef leasingKV "leases"%go (![go.PointerType leasingKV] "lkv")))) #());;;
    do:  (let: "$f" := (MethodResolve (go.PointerType sync.RWMutex) "RUnlock"%go (StructFieldRef leaseCache "mu"%go (StructFieldRef leasingKV "leases"%go (![go.PointerType leasingKV] "lkv")))) in
    "$defer" <-[deferType] (let: "$oldf" := (![deferType] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    (if: Convert go.untyped_bool go.bool ((![go.PointerType concurrency.Session] (StructFieldRef leasingKV "session"%go (![go.PointerType leasingKV] "lkv"))) =⟨go.PointerType concurrency.Session⟩ (Convert go.untyped_nil (go.PointerType concurrency.Session) UntypedNil))
    then return: (#false)
    else do:  #());;;
    let: "$ch0" := ((MethodResolve (go.PointerType concurrency.Session) "Done"%go (![go.PointerType concurrency.Session] (StructFieldRef leasingKV "session"%go (![go.PointerType leasingKV] "lkv")))) #()) in
    SelectStmt (SelectStmtClauses (Some (return: (#true))) [(CommClause (RecvCase (go.StructType [

    ]) "$ch0") (do:  #()))]);;;
    return: (#false)).

(* go: kv.go:481:23 *)
Definition leasingKV__leaseIDⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "lkv" <>,
    with_defer: (let: "lkv" := (GoAlloc (go.PointerType leasingKV) "lkv") in
    do:  ((MethodResolve (go.PointerType sync.RWMutex) "RLock"%go (StructFieldRef leaseCache "mu"%go (StructFieldRef leasingKV "leases"%go (![go.PointerType leasingKV] "lkv")))) #());;;
    do:  (let: "$f" := (MethodResolve (go.PointerType sync.RWMutex) "RUnlock"%go (StructFieldRef leaseCache "mu"%go (StructFieldRef leasingKV "leases"%go (![go.PointerType leasingKV] "lkv")))) in
    "$defer" <-[deferType] (let: "$oldf" := (![deferType] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    return: ((MethodResolve (go.PointerType concurrency.Session) "Lease"%go (![go.PointerType concurrency.Session] (StructFieldRef leasingKV "session"%go (![go.PointerType leasingKV] "lkv")))) #())).

(* go: txn.go:34:24 *)
Definition txnLeasing__Ifⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "txn" "cs",
    exception_do (let: "txn" := (GoAlloc (go.PointerType txnLeasing) "txn") in
    let: "cs" := (GoAlloc (go.SliceType clientv3.Cmp) "cs") in
    let: "$r0" := (let: "$a0" := (![go.SliceType clientv3.Cmp] (StructFieldRef txnLeasing "cs"%go (![go.PointerType txnLeasing] "txn"))) in
    let: "$a1" := (![go.SliceType clientv3.Cmp] "cs") in
    (FuncResolve go.append [go.SliceType clientv3.Cmp] #()) "$a0" "$a1") in
    do:  ((StructFieldRef txnLeasing "cs"%go (![go.PointerType txnLeasing] "txn")) <-[go.SliceType clientv3.Cmp] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType clientv3.Cmp] "cs") in
    (MethodResolve clientv3.Txn "If"%go (![clientv3.Txn] (StructFieldRef txnLeasing "Txn"%go (![go.PointerType txnLeasing] "txn")))) "$a0") in
    do:  ((StructFieldRef txnLeasing "Txn"%go (![go.PointerType txnLeasing] "txn")) <-[clientv3.Txn] "$r0");;;
    return: (Convert (go.PointerType txnLeasing) clientv3.Txn (![go.PointerType txnLeasing] "txn"))).

(* go: txn.go:40:24 *)
Definition txnLeasing__Thenⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "txn" "ops",
    exception_do (let: "txn" := (GoAlloc (go.PointerType txnLeasing) "txn") in
    let: "ops" := (GoAlloc (go.SliceType clientv3.Op) "ops") in
    let: "$r0" := (let: "$a0" := (![go.SliceType clientv3.Op] (StructFieldRef txnLeasing "opst"%go (![go.PointerType txnLeasing] "txn"))) in
    let: "$a1" := (![go.SliceType clientv3.Op] "ops") in
    (FuncResolve go.append [go.SliceType clientv3.Op] #()) "$a0" "$a1") in
    do:  ((StructFieldRef txnLeasing "opst"%go (![go.PointerType txnLeasing] "txn")) <-[go.SliceType clientv3.Op] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType clientv3.Op] "ops") in
    (MethodResolve clientv3.Txn "Then"%go (![clientv3.Txn] (StructFieldRef txnLeasing "Txn"%go (![go.PointerType txnLeasing] "txn")))) "$a0") in
    do:  ((StructFieldRef txnLeasing "Txn"%go (![go.PointerType txnLeasing] "txn")) <-[clientv3.Txn] "$r0");;;
    return: (Convert (go.PointerType txnLeasing) clientv3.Txn (![go.PointerType txnLeasing] "txn"))).

(* go: txn.go:46:24 *)
Definition txnLeasing__Elseⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "txn" "ops",
    exception_do (let: "txn" := (GoAlloc (go.PointerType txnLeasing) "txn") in
    let: "ops" := (GoAlloc (go.SliceType clientv3.Op) "ops") in
    let: "$r0" := (let: "$a0" := (![go.SliceType clientv3.Op] (StructFieldRef txnLeasing "opse"%go (![go.PointerType txnLeasing] "txn"))) in
    let: "$a1" := (![go.SliceType clientv3.Op] "ops") in
    (FuncResolve go.append [go.SliceType clientv3.Op] #()) "$a0" "$a1") in
    do:  ((StructFieldRef txnLeasing "opse"%go (![go.PointerType txnLeasing] "txn")) <-[go.SliceType clientv3.Op] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType clientv3.Op] "ops") in
    (MethodResolve clientv3.Txn "Else"%go (![clientv3.Txn] (StructFieldRef txnLeasing "Txn"%go (![go.PointerType txnLeasing] "txn")))) "$a0") in
    do:  ((StructFieldRef txnLeasing "Txn"%go (![go.PointerType txnLeasing] "txn")) <-[clientv3.Txn] "$r0");;;
    return: (Convert (go.PointerType txnLeasing) clientv3.Txn (![go.PointerType txnLeasing] "txn"))).

(* go: txn.go:52:24 *)
Definition txnLeasing__Commitⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "txn" <>,
    exception_do (let: "txn" := (GoAlloc (go.PointerType txnLeasing) "txn") in
    (let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
    let: "resp" := (GoAlloc (go.PointerType clientv3.TxnResponse) (GoZeroVal (go.PointerType clientv3.TxnResponse) #())) in
    let: ("$ret0", "$ret1") := ((MethodResolve (go.PointerType txnLeasing) "eval"%go (![go.PointerType txnLeasing] "txn")) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("resp" <-[go.PointerType clientv3.TxnResponse] "$r0");;;
    do:  ("err" <-[go.error] "$r1");;;
    (if: Convert go.untyped_bool go.bool (((![go.PointerType clientv3.TxnResponse] "resp") ≠⟨go.PointerType clientv3.TxnResponse⟩ (Convert go.untyped_nil (go.PointerType clientv3.TxnResponse) UntypedNil)) || ((![go.error] "err") ≠⟨go.error⟩ (Convert go.untyped_nil go.error UntypedNil)))
    then return: (![go.PointerType clientv3.TxnResponse] "resp", ![go.error] "err")
    else do:  #()));;;
    let: ("$ret0", "$ret1") := (((MethodResolve (go.PointerType txnLeasing) "serverTxn"%go (![go.PointerType txnLeasing] "txn")) #())) in
    return: ("$ret0", "$ret1")).

(* go: txn.go:59:24 *)
Definition txnLeasing__evalⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "txn" <>,
    with_defer: (let: "txn" := (GoAlloc (go.PointerType txnLeasing) "txn") in
    let: "elseOps" := (GoAlloc (go.SliceType clientv3.Op) (GoZeroVal (go.SliceType clientv3.Op) #())) in
    let: "thenOps" := (GoAlloc (go.SliceType clientv3.Op) (GoZeroVal (go.SliceType clientv3.Op) #())) in
    let: "$r0" := (let: "$a0" := (![go.SliceType clientv3.Op] (StructFieldRef txnLeasing "opst"%go (![go.PointerType txnLeasing] "txn"))) in
    (FuncResolve gatherOps [] #()) "$a0") in
    let: "$r1" := (let: "$a0" := (![go.SliceType clientv3.Op] (StructFieldRef txnLeasing "opse"%go (![go.PointerType txnLeasing] "txn"))) in
    (FuncResolve gatherOps [] #()) "$a0") in
    do:  ("thenOps" <-[go.SliceType clientv3.Op] "$r0");;;
    do:  ("elseOps" <-[go.SliceType clientv3.Op] "$r1");;;
    let: "ops" := (GoAlloc (go.SliceType clientv3.Op) (GoZeroVal (go.SliceType clientv3.Op) #())) in
    let: "$r0" := ((FuncResolve go.make3 [go.SliceType clientv3.Op] #()) #(W64 0) ((let: "$a0" := (![go.SliceType clientv3.Op] "thenOps") in
    (FuncResolve go.len [go.SliceType clientv3.Op] #()) "$a0") +⟨go.int⟩ (let: "$a0" := (![go.SliceType clientv3.Op] "elseOps") in
    (FuncResolve go.len [go.SliceType clientv3.Op] #()) "$a0"))) in
    do:  ("ops" <-[go.SliceType clientv3.Op] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType clientv3.Op] "ops") in
    let: "$a1" := (![go.SliceType clientv3.Op] "thenOps") in
    (FuncResolve go.append [go.SliceType clientv3.Op] #()) "$a0" "$a1") in
    do:  ("ops" <-[go.SliceType clientv3.Op] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType clientv3.Op] "ops") in
    let: "$a1" := (![go.SliceType clientv3.Op] "elseOps") in
    (FuncResolve go.append [go.SliceType clientv3.Op] #()) "$a0" "$a1") in
    do:  ("ops" <-[go.SliceType clientv3.Op] "$r0");;;
    let: "$range" := (let: "$a0" := (![go.SliceType clientv3.Op] "ops") in
    (MethodResolve (go.PointerType leaseCache) "NotifyOps"%go (StructFieldRef leasingKV "leases"%go (![go.PointerType leasingKV] (StructFieldRef txnLeasing "lkv"%go (![go.PointerType txnLeasing] "txn"))))) "$a0") in
    (let: "ch" := (GoAlloc (go.ChannelType go.recvonly (go.StructType [

    ])) (GoZeroVal (go.ChannelType go.recvonly (go.StructType [

    ])) #())) in
    slice.for_range (go.ChannelType go.recvonly (go.StructType [

    ])) "$range" (λ: "$key" "$value",
      do:  ("ch" <-[go.ChannelType go.recvonly (go.StructType [

      ])] "$value");;;
      do:  "$key";;;
      let: "$ch0" := (![go.ChannelType go.recvonly (go.StructType [

      ])] "ch") in
      let: "$ch1" := ((MethodResolve context.Context "Done"%go (![context.Context] (StructFieldRef txnLeasing "ctx"%go (![go.PointerType txnLeasing] "txn")))) #()) in
      SelectStmt (SelectStmtClauses None [(CommClause (RecvCase (go.StructType [

      ]) "$ch0") (do:  #())); (CommClause (RecvCase (go.StructType [

      ]) "$ch1") (return: (Convert go.untyped_nil (go.PointerType clientv3.TxnResponse) UntypedNil, (MethodResolve context.Context "Err"%go (![context.Context] (StructFieldRef txnLeasing "ctx"%go (![go.PointerType txnLeasing] "txn")))) #())))])));;;
    do:  ((MethodResolve (go.PointerType sync.RWMutex) "RLock"%go (StructFieldRef leaseCache "mu"%go (StructFieldRef leasingKV "leases"%go (![go.PointerType leasingKV] (StructFieldRef txnLeasing "lkv"%go (![go.PointerType txnLeasing] "txn")))))) #());;;
    do:  (let: "$f" := (MethodResolve (go.PointerType sync.RWMutex) "RUnlock"%go (StructFieldRef leaseCache "mu"%go (StructFieldRef leasingKV "leases"%go (![go.PointerType leasingKV] (StructFieldRef txnLeasing "lkv"%go (![go.PointerType txnLeasing] "txn")))))) in
    "$defer" <-[deferType] (let: "$oldf" := (![deferType] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "succeeded" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType clientv3.Cmp] (StructFieldRef txnLeasing "cs"%go (![go.PointerType txnLeasing] "txn"))) in
    (MethodResolve (go.PointerType leaseCache) "evalCmp"%go (StructFieldRef leasingKV "leases"%go (![go.PointerType leasingKV] (StructFieldRef txnLeasing "lkv"%go (![go.PointerType txnLeasing] "txn"))))) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("succeeded" <-[go.bool] "$r0");;;
    do:  ("ok" <-[go.bool] "$r1");;;
    (if: (⟨go.bool⟩! (![go.bool] "ok")) || ((![go.PointerType etcdserverpb.ResponseHeader] (StructFieldRef leaseCache "header"%go (StructFieldRef leasingKV "leases"%go (![go.PointerType leasingKV] (StructFieldRef txnLeasing "lkv"%go (![go.PointerType txnLeasing] "txn")))))) =⟨go.PointerType etcdserverpb.ResponseHeader⟩ (Convert go.untyped_nil (go.PointerType etcdserverpb.ResponseHeader) UntypedNil))
    then return: (Convert go.untyped_nil (go.PointerType clientv3.TxnResponse) UntypedNil, Convert go.untyped_nil go.error UntypedNil)
    else do:  #());;;
    (let: "$r0" := (![go.SliceType clientv3.Op] (StructFieldRef txnLeasing "opst"%go (![go.PointerType txnLeasing] "txn"))) in
    do:  ("ops" <-[go.SliceType clientv3.Op] "$r0");;;
    (if: (⟨go.bool⟩! (![go.bool] "succeeded"))
    then
      let: "$r0" := (![go.SliceType clientv3.Op] (StructFieldRef txnLeasing "opse"%go (![go.PointerType txnLeasing] "txn"))) in
      do:  ("ops" <-[go.SliceType clientv3.Op] "$r0")
    else do:  #()));;;
    let: "resps" := (GoAlloc (go.SliceType (go.PointerType etcdserverpb.ResponseOp)) (GoZeroVal (go.SliceType (go.PointerType etcdserverpb.ResponseOp)) #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType clientv3.Op] "ops") in
    (MethodResolve (go.PointerType leaseCache) "evalOps"%go (StructFieldRef leasingKV "leases"%go (![go.PointerType leasingKV] (StructFieldRef txnLeasing "lkv"%go (![go.PointerType txnLeasing] "txn"))))) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("resps" <-[go.SliceType (go.PointerType etcdserverpb.ResponseOp)] "$r0");;;
    do:  ("ok" <-[go.bool] "$r1");;;
    (if: (⟨go.bool⟩! (![go.bool] "ok"))
    then return: (Convert go.untyped_nil (go.PointerType clientv3.TxnResponse) UntypedNil, Convert go.untyped_nil go.error UntypedNil)
    else do:  #());;;
    return: (GoAlloc clientv3.TxnResponse (let: "$v0" := (let: "$a0" := (![go.PointerType etcdserverpb.ResponseHeader] (StructFieldRef leaseCache "header"%go (StructFieldRef leasingKV "leases"%go (![go.PointerType leasingKV] (StructFieldRef txnLeasing "lkv"%go (![go.PointerType txnLeasing] "txn")))))) in
     (FuncResolve copyHeader [] #()) "$a0") in
     let: "$v1" := (![go.bool] "succeeded") in
     let: "$v2" := (![go.SliceType (go.PointerType etcdserverpb.ResponseOp)] "resps") in
     CompositeLiteral clientv3.TxnResponse (LiteralValue [KeyedElement (Some (KeyField "Header"%go)) (ElementExpression (go.PointerType etcdserverpb.ResponseHeader) "$v0"); KeyedElement (Some (KeyField "Succeeded"%go)) (ElementExpression go.bool "$v1"); KeyedElement (Some (KeyField "Responses"%go)) (ElementExpression (go.SliceType (go.PointerType etcdserverpb.ResponseOp)) "$v2")])), Convert go.untyped_nil go.error UntypedNil)).

(* fallback computes the ops to fetch all possible conflicting
   leasing keys for a list of ops.

   go: txn.go:93:24 *)
Definition txnLeasing__fallbackⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "txn" "ops",
    exception_do (let: "fbOps" := (GoAlloc (go.SliceType clientv3.Op) (GoZeroVal (go.SliceType clientv3.Op) #())) in
    let: "txn" := (GoAlloc (go.PointerType txnLeasing) "txn") in
    let: "ops" := (GoAlloc (go.SliceType clientv3.Op) "ops") in
    let: "$range" := (![go.SliceType clientv3.Op] "ops") in
    (let: "op" := (GoAlloc clientv3.Op (GoZeroVal clientv3.Op #())) in
    slice.for_range clientv3.Op "$range" (λ: "$key" "$value",
      do:  ("op" <-[clientv3.Op] "$value");;;
      do:  "$key";;;
      (if: (MethodResolve (go.PointerType clientv3.Op) "IsGet"%go "op") #()
      then continue: #()
      else do:  #());;;
      let: "lend" := (GoAlloc go.string (GoZeroVal go.string #())) in
      let: "lkey" := (GoAlloc go.string (GoZeroVal go.string #())) in
      let: "$r0" := ((![go.string] (StructFieldRef leasingKV "pfx"%go (![go.PointerType leasingKV] (StructFieldRef txnLeasing "lkv"%go (![go.PointerType txnLeasing] "txn"))))) +⟨go.string⟩ (Convert (go.SliceType go.byte) go.string ((MethodResolve (go.PointerType clientv3.Op) "KeyBytes"%go "op") #()))) in
      let: "$r1" := #""%go in
      do:  ("lkey" <-[go.string] "$r0");;;
      do:  ("lend" <-[go.string] "$r1");;;
      (if: Convert go.untyped_bool go.bool ((let: "$a0" := ((MethodResolve (go.PointerType clientv3.Op) "RangeBytes"%go "op") #()) in
      (FuncResolve go.len [go.SliceType go.byte] #()) "$a0") >⟨go.int⟩ #(W64 0))
      then
        let: "$r0" := ((![go.string] (StructFieldRef leasingKV "pfx"%go (![go.PointerType leasingKV] (StructFieldRef txnLeasing "lkv"%go (![go.PointerType txnLeasing] "txn"))))) +⟨go.string⟩ (Convert (go.SliceType go.byte) go.string ((MethodResolve (go.PointerType clientv3.Op) "RangeBytes"%go "op") #()))) in
        do:  ("lend" <-[go.string] "$r0")
      else do:  #());;;
      let: "$r0" := (let: "$a0" := (![go.SliceType clientv3.Op] "fbOps") in
      let: "$a1" := ((let: "$sl0" := (let: "$a0" := (![go.string] "lkey") in
      let: "$a1" := ((let: "$sl0" := (let: "$a0" := (![go.string] "lend") in
      (FuncResolve clientv3.WithRange [] #()) "$a0") in
      CompositeLiteral (go.SliceType clientv3.OpOption) (LiteralValue [KeyedElement None (ElementExpression clientv3.OpOption "$sl0")]))) in
      (FuncResolve clientv3.OpGet [] #()) "$a0" "$a1") in
      CompositeLiteral (go.SliceType clientv3.Op) (LiteralValue [KeyedElement None (ElementExpression clientv3.Op "$sl0")]))) in
      (FuncResolve go.append [go.SliceType clientv3.Op] #()) "$a0" "$a1") in
      do:  ("fbOps" <-[go.SliceType clientv3.Op] "$r0")));;;
    return: (![go.SliceType clientv3.Op] "fbOps")).

(* go: txn.go:107:24 *)
Definition txnLeasing__guardKeysⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "txn" "ops",
    exception_do (let: "cmps" := (GoAlloc (go.SliceType clientv3.Cmp) (GoZeroVal (go.SliceType clientv3.Cmp) #())) in
    let: "txn" := (GoAlloc (go.PointerType txnLeasing) "txn") in
    let: "ops" := (GoAlloc (go.SliceType clientv3.Op) "ops") in
    let: "seen" := (GoAlloc (go.MapType go.string go.bool) (GoZeroVal (go.MapType go.string go.bool) #())) in
    let: "$r0" := ((FuncResolve go.make1 [go.MapType go.string go.bool] #()) #()) in
    do:  ("seen" <-[go.MapType go.string go.bool] "$r0");;;
    let: "$range" := (![go.SliceType clientv3.Op] "ops") in
    (let: "op" := (GoAlloc clientv3.Op (GoZeroVal clientv3.Op #())) in
    slice.for_range clientv3.Op "$range" (λ: "$key" "$value",
      do:  ("op" <-[clientv3.Op] "$value");;;
      do:  "$key";;;
      let: "key" := (GoAlloc go.string (GoZeroVal go.string #())) in
      let: "$r0" := (Convert (go.SliceType go.byte) go.string ((MethodResolve (go.PointerType clientv3.Op) "KeyBytes"%go "op") #())) in
      do:  ("key" <-[go.string] "$r0");;;
      (if: (((MethodResolve (go.PointerType clientv3.Op) "IsGet"%go "op") #()) || ((let: "$a0" := ((MethodResolve (go.PointerType clientv3.Op) "RangeBytes"%go "op") #()) in
      (FuncResolve go.len [go.SliceType go.byte] #()) "$a0") ≠⟨go.int⟩ #(W64 0))) || (map.lookup1 go.string go.bool (![go.MapType go.string go.bool] "seen") (![go.string] "key"))
      then continue: #()
      else do:  #());;;
      let: "rev" := (GoAlloc go.int64 (GoZeroVal go.int64 #())) in
      let: "$r0" := (let: "$a0" := (![go.string] "key") in
      (MethodResolve (go.PointerType leaseCache) "Rev"%go (StructFieldRef leasingKV "leases"%go (![go.PointerType leasingKV] (StructFieldRef txnLeasing "lkv"%go (![go.PointerType txnLeasing] "txn"))))) "$a0") in
      do:  ("rev" <-[go.int64] "$r0");;;
      let: "$r0" := (let: "$a0" := (![go.SliceType clientv3.Cmp] "cmps") in
      let: "$a1" := ((let: "$sl0" := (let: "$a0" := (let: "$a0" := ((![go.string] (StructFieldRef leasingKV "pfx"%go (![go.PointerType leasingKV] (StructFieldRef txnLeasing "lkv"%go (![go.PointerType txnLeasing] "txn"))))) +⟨go.string⟩ (![go.string] "key")) in
      (FuncResolve clientv3.CreateRevision [] #()) "$a0") in
      let: "$a1" := #"<"%go in
      let: "$a2" := (Convert go.int64 go.any ((![go.int64] "rev") +⟨go.int64⟩ #(W64 1))) in
      (FuncResolve clientv3.Compare [] #()) "$a0" "$a1" "$a2") in
      CompositeLiteral (go.SliceType clientv3.Cmp) (LiteralValue [KeyedElement None (ElementExpression clientv3.Cmp "$sl0")]))) in
      (FuncResolve go.append [go.SliceType clientv3.Cmp] #()) "$a0" "$a1") in
      do:  ("cmps" <-[go.SliceType clientv3.Cmp] "$r0");;;
      let: "$r0" := #true in
      do:  (map.insert go.string (![go.MapType go.string go.bool] "seen") (![go.string] "key") "$r0")));;;
    return: (![go.SliceType clientv3.Cmp] "cmps")).

(* go: txn.go:121:24 *)
Definition txnLeasing__guardRangesⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "txn" "ops",
    exception_do (let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
    let: "cmps" := (GoAlloc (go.SliceType clientv3.Cmp) (GoZeroVal (go.SliceType clientv3.Cmp) #())) in
    let: "txn" := (GoAlloc (go.PointerType txnLeasing) "txn") in
    let: "ops" := (GoAlloc (go.SliceType clientv3.Op) "ops") in
    let: "$range" := (![go.SliceType clientv3.Op] "ops") in
    (let: "op" := (GoAlloc clientv3.Op (GoZeroVal clientv3.Op #())) in
    slice.for_range clientv3.Op "$range" (λ: "$key" "$value",
      do:  ("op" <-[clientv3.Op] "$value");;;
      do:  "$key";;;
      (if: ((MethodResolve (go.PointerType clientv3.Op) "IsGet"%go "op") #()) || ((let: "$a0" := ((MethodResolve (go.PointerType clientv3.Op) "RangeBytes"%go "op") #()) in
      (FuncResolve go.len [go.SliceType go.byte] #()) "$a0") =⟨go.int⟩ #(W64 0))
      then continue: #()
      else do:  #());;;
      let: "end" := (GoAlloc go.string (GoZeroVal go.string #())) in
      let: "key" := (GoAlloc go.string (GoZeroVal go.string #())) in
      let: "$r0" := (Convert (go.SliceType go.byte) go.string ((MethodResolve (go.PointerType clientv3.Op) "KeyBytes"%go "op") #())) in
      let: "$r1" := (Convert (go.SliceType go.byte) go.string ((MethodResolve (go.PointerType clientv3.Op) "RangeBytes"%go "op") #())) in
      do:  ("key" <-[go.string] "$r0");;;
      do:  ("end" <-[go.string] "$r1");;;
      let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
      let: "maxRevLK" := (GoAlloc go.int64 (GoZeroVal go.int64 #())) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![context.Context] (StructFieldRef txnLeasing "ctx"%go (![go.PointerType txnLeasing] "txn"))) in
      let: "$a1" := (![go.string] "key") in
      let: "$a2" := (![go.string] "end") in
      (MethodResolve (go.PointerType leasingKV) "revokeRange"%go (![go.PointerType leasingKV] (StructFieldRef txnLeasing "lkv"%go (![go.PointerType txnLeasing] "txn")))) "$a0" "$a1" "$a2") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("maxRevLK" <-[go.int64] "$r0");;;
      do:  ("err" <-[go.error] "$r1");;;
      (if: Convert go.untyped_bool go.bool ((![go.error] "err") ≠⟨go.error⟩ (Convert go.untyped_nil go.error UntypedNil))
      then return: (Convert go.untyped_nil (go.SliceType clientv3.Cmp) UntypedNil, ![go.error] "err")
      else do:  #());;;
      let: "opts" := (GoAlloc (go.SliceType clientv3.OpOption) (GoZeroVal (go.SliceType clientv3.OpOption) #())) in
      let: "$r0" := (let: "$a0" := ((FuncResolve clientv3.WithLastRev [] #()) #()) in
      let: "$a1" := ((let: "$sl0" := (let: "$a0" := (![go.string] "end") in
      (FuncResolve clientv3.WithRange [] #()) "$a0") in
      CompositeLiteral (go.SliceType clientv3.OpOption) (LiteralValue [KeyedElement None (ElementExpression clientv3.OpOption "$sl0")]))) in
      (FuncResolve go.append [go.SliceType clientv3.OpOption] #()) "$a0" "$a1") in
      do:  ("opts" <-[go.SliceType clientv3.OpOption] "$r0");;;
      let: "getResp" := (GoAlloc (go.PointerType clientv3.GetResponse) (GoZeroVal (go.PointerType clientv3.GetResponse) #())) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![context.Context] (StructFieldRef txnLeasing "ctx"%go (![go.PointerType txnLeasing] "txn"))) in
      let: "$a1" := (![go.string] "key") in
      let: "$a2" := (![go.SliceType clientv3.OpOption] "opts") in
      (MethodResolve clientv3.KV "Get"%go (![clientv3.KV] (StructFieldRef leasingKV "kv"%go (![go.PointerType leasingKV] (StructFieldRef txnLeasing "lkv"%go (![go.PointerType txnLeasing] "txn")))))) "$a0" "$a1" "$a2") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("getResp" <-[go.PointerType clientv3.GetResponse] "$r0");;;
      do:  ("err" <-[go.error] "$r1");;;
      (if: Convert go.untyped_bool go.bool ((![go.error] "err") ≠⟨go.error⟩ (Convert go.untyped_nil go.error UntypedNil))
      then return: (Convert go.untyped_nil (go.SliceType clientv3.Cmp) UntypedNil, ![go.error] "err")
      else do:  #());;;
      let: "maxModRev" := (GoAlloc go.int64 (GoZeroVal go.int64 #())) in
      let: "$r0" := #(W64 0) in
      do:  ("maxModRev" <-[go.int64] "$r0");;;
      (if: Convert go.untyped_bool go.bool ((let: "$a0" := (![go.SliceType (go.PointerType mvccpb.KeyValue)] (StructFieldRef clientv3.GetResponse "Kvs"%go (![go.PointerType clientv3.GetResponse] "getResp"))) in
      (FuncResolve go.len [go.SliceType (go.PointerType mvccpb.KeyValue)] #()) "$a0") >⟨go.int⟩ #(W64 0))
      then
        let: "$r0" := (![go.int64] (StructFieldRef mvccpb.KeyValue "ModRevision"%go (![go.PointerType mvccpb.KeyValue] (IndexRef (go.SliceType (go.PointerType mvccpb.KeyValue)) (![go.SliceType (go.PointerType mvccpb.KeyValue)] (StructFieldRef clientv3.GetResponse "Kvs"%go (![go.PointerType clientv3.GetResponse] "getResp")), #(W64 0)))))) in
        do:  ("maxModRev" <-[go.int64] "$r0")
      else do:  #());;;
      let: "noKeyUpdate" := (GoAlloc clientv3.Cmp (GoZeroVal clientv3.Cmp #())) in
      let: "$r0" := (let: "$a0" := (let: "$a0" := (![go.string] "end") in
      (MethodResolve clientv3.Cmp "WithRange"%go (let: "$a0" := (![go.string] "key") in
      (FuncResolve clientv3.ModRevision [] #()) "$a0")) "$a0") in
      let: "$a1" := #"<"%go in
      let: "$a2" := (Convert go.int64 go.any ((![go.int64] "maxModRev") +⟨go.int64⟩ #(W64 1))) in
      (FuncResolve clientv3.Compare [] #()) "$a0" "$a1" "$a2") in
      do:  ("noKeyUpdate" <-[clientv3.Cmp] "$r0");;;
      let: "noLeaseUpdate" := (GoAlloc clientv3.Cmp (GoZeroVal clientv3.Cmp #())) in
      let: "$r0" := (let: "$a0" := (let: "$a0" := ((![go.string] (StructFieldRef leasingKV "pfx"%go (![go.PointerType leasingKV] (StructFieldRef txnLeasing "lkv"%go (![go.PointerType txnLeasing] "txn"))))) +⟨go.string⟩ (![go.string] "end")) in
      (MethodResolve clientv3.Cmp "WithRange"%go (let: "$a0" := ((![go.string] (StructFieldRef leasingKV "pfx"%go (![go.PointerType leasingKV] (StructFieldRef txnLeasing "lkv"%go (![go.PointerType txnLeasing] "txn"))))) +⟨go.string⟩ (![go.string] "key")) in
      (FuncResolve clientv3.CreateRevision [] #()) "$a0")) "$a0") in
      let: "$a1" := #"<"%go in
      let: "$a2" := (Convert go.int64 go.any ((![go.int64] "maxRevLK") +⟨go.int64⟩ #(W64 1))) in
      (FuncResolve clientv3.Compare [] #()) "$a0" "$a1" "$a2") in
      do:  ("noLeaseUpdate" <-[clientv3.Cmp] "$r0");;;
      let: "$r0" := (let: "$a0" := (![go.SliceType clientv3.Cmp] "cmps") in
      let: "$a1" := ((let: "$sl0" := (![clientv3.Cmp] "noKeyUpdate") in
      let: "$sl1" := (![clientv3.Cmp] "noLeaseUpdate") in
      CompositeLiteral (go.SliceType clientv3.Cmp) (LiteralValue [KeyedElement None (ElementExpression clientv3.Cmp "$sl0"); KeyedElement None (ElementExpression clientv3.Cmp "$sl1")]))) in
      (FuncResolve go.append [go.SliceType clientv3.Cmp] #()) "$a0" "$a1") in
      do:  ("cmps" <-[go.SliceType clientv3.Cmp] "$r0")));;;
    return: (![go.SliceType clientv3.Cmp] "cmps", Convert go.untyped_nil go.error UntypedNil)).

(* go: txn.go:153:24 *)
Definition txnLeasing__guardⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "txn" "ops",
    exception_do (let: "txn" := (GoAlloc (go.PointerType txnLeasing) "txn") in
    let: "ops" := (GoAlloc (go.SliceType clientv3.Op) "ops") in
    let: "cmps" := (GoAlloc (go.SliceType clientv3.Cmp) (GoZeroVal (go.SliceType clientv3.Cmp) #())) in
    let: "$r0" := (let: "$a0" := (![go.SliceType clientv3.Op] "ops") in
    (MethodResolve (go.PointerType txnLeasing) "guardKeys"%go (![go.PointerType txnLeasing] "txn")) "$a0") in
    do:  ("cmps" <-[go.SliceType clientv3.Cmp] "$r0");;;
    let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
    let: "rangeCmps" := (GoAlloc (go.SliceType clientv3.Cmp) (GoZeroVal (go.SliceType clientv3.Cmp) #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType clientv3.Op] "ops") in
    (MethodResolve (go.PointerType txnLeasing) "guardRanges"%go (![go.PointerType txnLeasing] "txn")) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("rangeCmps" <-[go.SliceType clientv3.Cmp] "$r0");;;
    do:  ("err" <-[go.error] "$r1");;;
    return: (let: "$a0" := (![go.SliceType clientv3.Cmp] "cmps") in
     let: "$a1" := (![go.SliceType clientv3.Cmp] "rangeCmps") in
     (FuncResolve go.append [go.SliceType clientv3.Cmp] #()) "$a0" "$a1", ![go.error] "err")).

(* go: txn.go:159:24 *)
Definition txnLeasing__commitToCacheⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "txn" "txnResp" "userTxn",
    exception_do (let: "txn" := (GoAlloc (go.PointerType txnLeasing) "txn") in
    let: "userTxn" := (GoAlloc clientv3.Op "userTxn") in
    let: "txnResp" := (GoAlloc (go.PointerType etcdserverpb.TxnResponse) "txnResp") in
    let: "ops" := (GoAlloc (go.SliceType clientv3.Op) (GoZeroVal (go.SliceType clientv3.Op) #())) in
    let: "$r0" := (let: "$a0" := (![go.SliceType (go.PointerType etcdserverpb.ResponseOp)] (StructFieldRef etcdserverpb.TxnResponse "Responses"%go (![go.PointerType etcdserverpb.TxnResponse] "txnResp"))) in
    let: "$a1" := (let: "$v0" := (![clientv3.Op] "userTxn") in
    CompositeLiteral (go.SliceType clientv3.Op) (LiteralValue [KeyedElement None (ElementExpression clientv3.Op "$v0")])) in
    (FuncResolve gatherResponseOps [] #()) "$a0" "$a1") in
    do:  ("ops" <-[go.SliceType clientv3.Op] "$r0");;;
    do:  ((MethodResolve (go.PointerType sync.RWMutex) "Lock"%go (StructFieldRef leaseCache "mu"%go (StructFieldRef leasingKV "leases"%go (![go.PointerType leasingKV] (StructFieldRef txnLeasing "lkv"%go (![go.PointerType txnLeasing] "txn")))))) #());;;
    let: "$range" := (![go.SliceType clientv3.Op] "ops") in
    (let: "op" := (GoAlloc clientv3.Op (GoZeroVal clientv3.Op #())) in
    slice.for_range clientv3.Op "$range" (λ: "$key" "$value",
      do:  ("op" <-[clientv3.Op] "$value");;;
      do:  "$key";;;
      let: "key" := (GoAlloc go.string (GoZeroVal go.string #())) in
      let: "$r0" := (Convert (go.SliceType go.byte) go.string ((MethodResolve (go.PointerType clientv3.Op) "KeyBytes"%go "op") #())) in
      do:  ("key" <-[go.string] "$r0");;;
      (if: ((MethodResolve (go.PointerType clientv3.Op) "IsDelete"%go "op") #()) && ((let: "$a0" := ((MethodResolve (go.PointerType clientv3.Op) "RangeBytes"%go "op") #()) in
      (FuncResolve go.len [go.SliceType go.byte] #()) "$a0") >⟨go.int⟩ #(W64 0))
      then
        let: "end" := (GoAlloc go.string (GoZeroVal go.string #())) in
        let: "$r0" := (Convert (go.SliceType go.byte) go.string ((MethodResolve (go.PointerType clientv3.Op) "RangeBytes"%go "op") #())) in
        do:  ("end" <-[go.string] "$r0");;;
        let: "$range" := (![go.MapType go.string (go.PointerType leaseKey)] (StructFieldRef leaseCache "entries"%go (StructFieldRef leasingKV "leases"%go (![go.PointerType leasingKV] (StructFieldRef txnLeasing "lkv"%go (![go.PointerType txnLeasing] "txn")))))) in
        (let: "k" := (GoAlloc go.string (GoZeroVal go.string #())) in
        map.for_range go.string (go.PointerType leaseKey) "$range" (λ: "$key" "value",
          do:  ("k" <-[go.string] "$key");;;
          (if: let: "$a0" := (![go.string] "k") in
          let: "$a1" := (![go.string] "key") in
          let: "$a2" := (![go.string] "end") in
          (FuncResolve inRange [] #()) "$a0" "$a1" "$a2"
          then
            do:  (let: "$a0" := (![go.string] "k") in
            let: "$a1" := (![go.PointerType etcdserverpb.ResponseHeader] (StructFieldRef etcdserverpb.TxnResponse "Header"%go (![go.PointerType etcdserverpb.TxnResponse] "txnResp"))) in
            (MethodResolve (go.PointerType leaseCache) "delete"%go (StructFieldRef leasingKV "leases"%go (![go.PointerType leasingKV] (StructFieldRef txnLeasing "lkv"%go (![go.PointerType txnLeasing] "txn"))))) "$a0" "$a1")
          else do:  #())))
      else
        (if: (MethodResolve (go.PointerType clientv3.Op) "IsDelete"%go "op") #()
        then
          do:  (let: "$a0" := (![go.string] "key") in
          let: "$a1" := (![go.PointerType etcdserverpb.ResponseHeader] (StructFieldRef etcdserverpb.TxnResponse "Header"%go (![go.PointerType etcdserverpb.TxnResponse] "txnResp"))) in
          (MethodResolve (go.PointerType leaseCache) "delete"%go (StructFieldRef leasingKV "leases"%go (![go.PointerType leasingKV] (StructFieldRef txnLeasing "lkv"%go (![go.PointerType txnLeasing] "txn"))))) "$a0" "$a1")
        else do:  #()));;;
      (if: (MethodResolve (go.PointerType clientv3.Op) "IsPut"%go "op") #()
      then
        do:  (let: "$a0" := ((MethodResolve (go.PointerType clientv3.Op) "KeyBytes"%go "op") #()) in
        let: "$a1" := ((MethodResolve (go.PointerType clientv3.Op) "ValueBytes"%go "op") #()) in
        let: "$a2" := (![go.PointerType etcdserverpb.ResponseHeader] (StructFieldRef etcdserverpb.TxnResponse "Header"%go (![go.PointerType etcdserverpb.TxnResponse] "txnResp"))) in
        (MethodResolve (go.PointerType leaseCache) "Update"%go (StructFieldRef leasingKV "leases"%go (![go.PointerType leasingKV] (StructFieldRef txnLeasing "lkv"%go (![go.PointerType txnLeasing] "txn"))))) "$a0" "$a1" "$a2")
      else do:  #())));;;
    do:  ((MethodResolve (go.PointerType sync.RWMutex) "Unlock"%go (StructFieldRef leaseCache "mu"%go (StructFieldRef leasingKV "leases"%go (![go.PointerType leasingKV] (StructFieldRef txnLeasing "lkv"%go (![go.PointerType txnLeasing] "txn")))))) #());;;
    return: #()).

(* go: txn.go:181:24 *)
Definition txnLeasing__revokeFallbackⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "txn" "fbResps",
    exception_do (let: "txn" := (GoAlloc (go.PointerType txnLeasing) "txn") in
    let: "fbResps" := (GoAlloc (go.SliceType (go.PointerType etcdserverpb.ResponseOp)) "fbResps") in
    let: "$range" := (![go.SliceType (go.PointerType etcdserverpb.ResponseOp)] "fbResps") in
    (let: "resp" := (GoAlloc (go.PointerType etcdserverpb.ResponseOp) (GoZeroVal (go.PointerType etcdserverpb.ResponseOp) #())) in
    slice.for_range (go.PointerType etcdserverpb.ResponseOp) "$range" (λ: "$key" "$value",
      do:  ("resp" <-[go.PointerType etcdserverpb.ResponseOp] "$value");;;
      do:  "$key";;;
      let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![context.Context] (StructFieldRef txnLeasing "ctx"%go (![go.PointerType txnLeasing] "txn"))) in
      let: "$a1" := (![go.SliceType (go.PointerType mvccpb.KeyValue)] (StructFieldRef etcdserverpb.RangeResponse "Kvs"%go ((MethodResolve (go.PointerType etcdserverpb.ResponseOp) "GetResponseRange"%go (![go.PointerType etcdserverpb.ResponseOp] "resp")) #()))) in
      (MethodResolve (go.PointerType leasingKV) "revokeLeaseKvs"%go (![go.PointerType leasingKV] (StructFieldRef txnLeasing "lkv"%go (![go.PointerType txnLeasing] "txn")))) "$a0" "$a1") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  "$r0";;;
      do:  ("err" <-[go.error] "$r1");;;
      (if: Convert go.untyped_bool go.bool ((![go.error] "err") ≠⟨go.error⟩ (Convert go.untyped_nil go.error UntypedNil))
      then return: (![go.error] "err")
      else do:  #())));;;
    return: (Convert go.untyped_nil go.error UntypedNil)).

(* go: txn.go:191:24 *)
Definition txnLeasing__serverTxnⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "txn" <>,
    with_defer: (let: "txn" := (GoAlloc (go.PointerType txnLeasing) "txn") in
    (let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
    let: "$r0" := (let: "$a0" := (![context.Context] (StructFieldRef txnLeasing "ctx"%go (![go.PointerType txnLeasing] "txn"))) in
    (MethodResolve (go.PointerType leasingKV) "waitSession"%go (![go.PointerType leasingKV] (StructFieldRef txnLeasing "lkv"%go (![go.PointerType txnLeasing] "txn")))) "$a0") in
    do:  ("err" <-[go.error] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.error] "err") ≠⟨go.error⟩ (Convert go.untyped_nil go.error UntypedNil))
    then return: (Convert go.untyped_nil (go.PointerType clientv3.TxnResponse) UntypedNil, ![go.error] "err")
    else do:  #()));;;
    let: "userOps" := (GoAlloc (go.SliceType clientv3.Op) (GoZeroVal (go.SliceType clientv3.Op) #())) in
    let: "$r0" := (let: "$a0" := (let: "$a0" := (![go.SliceType clientv3.Op] (StructFieldRef txnLeasing "opst"%go (![go.PointerType txnLeasing] "txn"))) in
    let: "$a1" := (![go.SliceType clientv3.Op] (StructFieldRef txnLeasing "opse"%go (![go.PointerType txnLeasing] "txn"))) in
    (FuncResolve go.append [go.SliceType clientv3.Op] #()) "$a0" "$a1") in
    (FuncResolve gatherOps [] #()) "$a0") in
    do:  ("userOps" <-[go.SliceType clientv3.Op] "$r0");;;
    let: "userTxn" := (GoAlloc clientv3.Op (GoZeroVal clientv3.Op #())) in
    let: "$r0" := (let: "$a0" := (![go.SliceType clientv3.Cmp] (StructFieldRef txnLeasing "cs"%go (![go.PointerType txnLeasing] "txn"))) in
    let: "$a1" := (![go.SliceType clientv3.Op] (StructFieldRef txnLeasing "opst"%go (![go.PointerType txnLeasing] "txn"))) in
    let: "$a2" := (![go.SliceType clientv3.Op] (StructFieldRef txnLeasing "opse"%go (![go.PointerType txnLeasing] "txn"))) in
    (FuncResolve clientv3.OpTxn [] #()) "$a0" "$a1" "$a2") in
    do:  ("userTxn" <-[clientv3.Op] "$r0");;;
    let: "fbOps" := (GoAlloc (go.SliceType clientv3.Op) (GoZeroVal (go.SliceType clientv3.Op) #())) in
    let: "$r0" := (let: "$a0" := (![go.SliceType clientv3.Op] "userOps") in
    (MethodResolve (go.PointerType txnLeasing) "fallback"%go (![go.PointerType txnLeasing] "txn")) "$a0") in
    do:  ("fbOps" <-[go.SliceType clientv3.Op] "$r0");;;
    do:  (let: "$a0" := (let: "$a0" := (![go.SliceType clientv3.Op] "userOps") in
    (MethodResolve (go.PointerType leaseCache) "LockWriteOps"%go (StructFieldRef leasingKV "leases"%go (![go.PointerType leasingKV] (StructFieldRef txnLeasing "lkv"%go (![go.PointerType txnLeasing] "txn"))))) "$a0") in
    let: "$f" := (FuncResolve closeAll [] #()) in
    "$defer" <-[deferType] (let: "$oldf" := (![deferType] "$defer") in
    (λ: <>,
      "$f" "$a0";;
      "$oldf" #()
      )));;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
      let: "cmps" := (GoAlloc (go.SliceType clientv3.Cmp) (GoZeroVal (go.SliceType clientv3.Cmp) #())) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![go.SliceType clientv3.Op] "userOps") in
      (MethodResolve (go.PointerType txnLeasing) "guard"%go (![go.PointerType txnLeasing] "txn")) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("cmps" <-[go.SliceType clientv3.Cmp] "$r0");;;
      do:  ("err" <-[go.error] "$r1");;;
      (if: Convert go.untyped_bool go.bool ((![go.error] "err") ≠⟨go.error⟩ (Convert go.untyped_nil go.error UntypedNil))
      then return: (Convert go.untyped_nil (go.PointerType clientv3.TxnResponse) UntypedNil, ![go.error] "err")
      else do:  #());;;
      let: "resp" := (GoAlloc (go.PointerType clientv3.TxnResponse) (GoZeroVal (go.PointerType clientv3.TxnResponse) #())) in
      let: ("$ret0", "$ret1") := ((MethodResolve clientv3.Txn "Commit"%go (let: "$a0" := (![go.SliceType clientv3.Op] "fbOps") in
      (MethodResolve clientv3.Txn "Else"%go (let: "$a0" := ((let: "$sl0" := (![clientv3.Op] "userTxn") in
      CompositeLiteral (go.SliceType clientv3.Op) (LiteralValue [KeyedElement None (ElementExpression clientv3.Op "$sl0")]))) in
      (MethodResolve clientv3.Txn "Then"%go (let: "$a0" := (![go.SliceType clientv3.Cmp] "cmps") in
      (MethodResolve clientv3.Txn "If"%go (let: "$a0" := (![context.Context] (StructFieldRef txnLeasing "ctx"%go (![go.PointerType txnLeasing] "txn"))) in
      (MethodResolve clientv3.KV "Txn"%go (![clientv3.KV] (StructFieldRef leasingKV "kv"%go (![go.PointerType leasingKV] (StructFieldRef txnLeasing "lkv"%go (![go.PointerType txnLeasing] "txn")))))) "$a0")) "$a0")) "$a0")) "$a0")) #()) in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("resp" <-[go.PointerType clientv3.TxnResponse] "$r0");;;
      do:  ("err" <-[go.error] "$r1");;;
      (if: Convert go.untyped_bool go.bool ((![go.error] "err") ≠⟨go.error⟩ (Convert go.untyped_nil go.error UntypedNil))
      then
        let: "$range" := (![go.SliceType clientv3.Cmp] "cmps") in
        (let: "cmp" := (GoAlloc clientv3.Cmp (GoZeroVal clientv3.Cmp #())) in
        slice.for_range clientv3.Cmp "$range" (λ: "$key" "$value",
          do:  ("cmp" <-[clientv3.Cmp] "$value");;;
          do:  "$key";;;
          do:  (let: "$a0" := (let: "$a0" := (Convert (go.SliceType go.byte) go.string (![go.SliceType go.byte] (StructFieldRef clientv3.Cmp "Key"%go "cmp"))) in
          let: "$a1" := (![go.string] (StructFieldRef leasingKV "pfx"%go (![go.PointerType leasingKV] (StructFieldRef txnLeasing "lkv"%go (![go.PointerType txnLeasing] "txn"))))) in
          (FuncResolve strings.TrimPrefix [] #()) "$a0" "$a1") in
          (MethodResolve (go.PointerType leaseCache) "Evict"%go (StructFieldRef leasingKV "leases"%go (![go.PointerType leasingKV] (StructFieldRef txnLeasing "lkv"%go (![go.PointerType txnLeasing] "txn"))))) "$a0")));;;
        return: (Convert go.untyped_nil (go.PointerType clientv3.TxnResponse) UntypedNil, ![go.error] "err")
      else do:  #());;;
      (if: ![go.bool] (StructFieldRef clientv3.TxnResponse "Succeeded"%go (![go.PointerType clientv3.TxnResponse] "resp"))
      then
        do:  (let: "$a0" := (Convert (go.PointerType clientv3.TxnResponse) (go.PointerType etcdserverpb.TxnResponse) (![go.PointerType clientv3.TxnResponse] "resp")) in
        let: "$a1" := (![clientv3.Op] "userTxn") in
        (MethodResolve (go.PointerType txnLeasing) "commitToCache"%go (![go.PointerType txnLeasing] "txn")) "$a0" "$a1");;;
        let: "userResp" := (GoAlloc (go.PointerType etcdserverpb.TxnResponse) (GoZeroVal (go.PointerType etcdserverpb.TxnResponse) #())) in
        let: "$r0" := ((MethodResolve (go.PointerType etcdserverpb.ResponseOp) "GetResponseTxn"%go (![go.PointerType etcdserverpb.ResponseOp] (IndexRef (go.SliceType (go.PointerType etcdserverpb.ResponseOp)) (![go.SliceType (go.PointerType etcdserverpb.ResponseOp)] (StructFieldRef clientv3.TxnResponse "Responses"%go (![go.PointerType clientv3.TxnResponse] "resp")), #(W64 0))))) #()) in
        do:  ("userResp" <-[go.PointerType etcdserverpb.TxnResponse] "$r0");;;
        let: "$r0" := (![go.PointerType etcdserverpb.ResponseHeader] (StructFieldRef clientv3.TxnResponse "Header"%go (![go.PointerType clientv3.TxnResponse] "resp"))) in
        do:  ((StructFieldRef etcdserverpb.TxnResponse "Header"%go (![go.PointerType etcdserverpb.TxnResponse] "userResp")) <-[go.PointerType etcdserverpb.ResponseHeader] "$r0");;;
        return: (Convert (go.PointerType etcdserverpb.TxnResponse) (go.PointerType clientv3.TxnResponse) (![go.PointerType etcdserverpb.TxnResponse] "userResp"), Convert go.untyped_nil go.error UntypedNil)
      else do:  #());;;
      (let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
      let: "$r0" := (let: "$a0" := (![go.SliceType (go.PointerType etcdserverpb.ResponseOp)] (StructFieldRef clientv3.TxnResponse "Responses"%go (![go.PointerType clientv3.TxnResponse] "resp"))) in
      (MethodResolve (go.PointerType txnLeasing) "revokeFallback"%go (![go.PointerType txnLeasing] "txn")) "$a0") in
      do:  ("err" <-[go.error] "$r0");;;
      (if: Convert go.untyped_bool go.bool ((![go.error] "err") ≠⟨go.error⟩ (Convert go.untyped_nil go.error UntypedNil))
      then return: (Convert go.untyped_nil (go.PointerType clientv3.TxnResponse) UntypedNil, ![go.error] "err")
      else do:  #())))).

(* go: util.go:24:6 *)
Definition compareInt64ⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "a" "b",
    exception_do (let: "b" := (GoAlloc go.int64 "b") in
    let: "a" := (GoAlloc go.int64 "a") in
    let: "$sw" := #true in
    (if: "$sw" =⟨go.bool⟩ ((![go.int64] "a") <⟨go.int64⟩ (![go.int64] "b"))
    then return: (Convert go.untyped_int go.int (⟨go.untyped_int⟩- #1))
    else
      (if: "$sw" =⟨go.bool⟩ ((![go.int64] "a") >⟨go.int64⟩ (![go.int64] "b"))
      then return: (#(W64 1))
      else return: (#(W64 0))))).

(* go: util.go:35:6 *)
Definition evalCmpⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "resp" "tcmp",
    exception_do (let: "tcmp" := (GoAlloc clientv3.Cmp "tcmp") in
    let: "resp" := (GoAlloc (go.PointerType clientv3.GetResponse) "resp") in
    let: "result" := (GoAlloc go.int (GoZeroVal go.int #())) in
    (if: Convert go.untyped_bool go.bool ((let: "$a0" := (![go.SliceType (go.PointerType mvccpb.KeyValue)] (StructFieldRef clientv3.GetResponse "Kvs"%go (![go.PointerType clientv3.GetResponse] "resp"))) in
    (FuncResolve go.len [go.SliceType (go.PointerType mvccpb.KeyValue)] #()) "$a0") ≠⟨go.int⟩ #(W64 0))
    then
      let: "kv" := (GoAlloc (go.PointerType mvccpb.KeyValue) (GoZeroVal (go.PointerType mvccpb.KeyValue) #())) in
      let: "$r0" := (![go.PointerType mvccpb.KeyValue] (IndexRef (go.SliceType (go.PointerType mvccpb.KeyValue)) (![go.SliceType (go.PointerType mvccpb.KeyValue)] (StructFieldRef clientv3.GetResponse "Kvs"%go (![go.PointerType clientv3.GetResponse] "resp")), #(W64 0)))) in
      do:  ("kv" <-[go.PointerType mvccpb.KeyValue] "$r0");;;
      let: "$sw" := (![etcdserverpb.Compare_CompareTarget] (StructFieldRef clientv3.Cmp "Target"%go "tcmp")) in
      (if: "$sw" =⟨etcdserverpb.Compare_CompareTarget⟩ etcdserverpb.Compare_VALUE
      then
        (let: "tv" := (GoAlloc (go.PointerType etcdserverpb.Compare_Value) (GoZeroVal (go.PointerType etcdserverpb.Compare_Value) #())) in
        let: ("$ret0", "$ret1") := (TypeAssert2 (go.PointerType etcdserverpb.Compare_Value) (![etcdserverpb.isCompare_TargetUnion] (StructFieldRef clientv3.Cmp "TargetUnion"%go "tcmp"))) in
        let: "$r0" := "$ret0" in
        let: "$r1" := "$ret1" in
        do:  ("tv" <-[go.PointerType etcdserverpb.Compare_Value] "$r0");;;
        do:  "$r1";;;
        (if: Convert go.untyped_bool go.bool ((![go.PointerType etcdserverpb.Compare_Value] "tv") ≠⟨go.PointerType etcdserverpb.Compare_Value⟩ (Convert go.untyped_nil (go.PointerType etcdserverpb.Compare_Value) UntypedNil))
        then
          let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] (StructFieldRef mvccpb.KeyValue "Value"%go (![go.PointerType mvccpb.KeyValue] "kv"))) in
          let: "$a1" := (![go.SliceType go.byte] (StructFieldRef etcdserverpb.Compare_Value "Value"%go (![go.PointerType etcdserverpb.Compare_Value] "tv"))) in
          (FuncResolve bytes.Compare [] #()) "$a0" "$a1") in
          do:  ("result" <-[go.int] "$r0")
        else do:  #()))
      else
        (if: "$sw" =⟨etcdserverpb.Compare_CompareTarget⟩ etcdserverpb.Compare_CREATE
        then
          (let: "tv" := (GoAlloc (go.PointerType etcdserverpb.Compare_CreateRevision) (GoZeroVal (go.PointerType etcdserverpb.Compare_CreateRevision) #())) in
          let: ("$ret0", "$ret1") := (TypeAssert2 (go.PointerType etcdserverpb.Compare_CreateRevision) (![etcdserverpb.isCompare_TargetUnion] (StructFieldRef clientv3.Cmp "TargetUnion"%go "tcmp"))) in
          let: "$r0" := "$ret0" in
          let: "$r1" := "$ret1" in
          do:  ("tv" <-[go.PointerType etcdserverpb.Compare_CreateRevision] "$r0");;;
          do:  "$r1";;;
          (if: Convert go.untyped_bool go.bool ((![go.PointerType etcdserverpb.Compare_CreateRevision] "tv") ≠⟨go.PointerType etcdserverpb.Compare_CreateRevision⟩ (Convert go.untyped_nil (go.PointerType etcdserverpb.Compare_CreateRevision) UntypedNil))
          then
            let: "$r0" := (let: "$a0" := (![go.int64] (StructFieldRef mvccpb.KeyValue "CreateRevision"%go (![go.PointerType mvccpb.KeyValue] "kv"))) in
            let: "$a1" := (![go.int64] (StructFieldRef etcdserverpb.Compare_CreateRevision "CreateRevision"%go (![go.PointerType etcdserverpb.Compare_CreateRevision] "tv"))) in
            (FuncResolve compareInt64 [] #()) "$a0" "$a1") in
            do:  ("result" <-[go.int] "$r0")
          else do:  #()))
        else
          (if: "$sw" =⟨etcdserverpb.Compare_CompareTarget⟩ etcdserverpb.Compare_MOD
          then
            (let: "tv" := (GoAlloc (go.PointerType etcdserverpb.Compare_ModRevision) (GoZeroVal (go.PointerType etcdserverpb.Compare_ModRevision) #())) in
            let: ("$ret0", "$ret1") := (TypeAssert2 (go.PointerType etcdserverpb.Compare_ModRevision) (![etcdserverpb.isCompare_TargetUnion] (StructFieldRef clientv3.Cmp "TargetUnion"%go "tcmp"))) in
            let: "$r0" := "$ret0" in
            let: "$r1" := "$ret1" in
            do:  ("tv" <-[go.PointerType etcdserverpb.Compare_ModRevision] "$r0");;;
            do:  "$r1";;;
            (if: Convert go.untyped_bool go.bool ((![go.PointerType etcdserverpb.Compare_ModRevision] "tv") ≠⟨go.PointerType etcdserverpb.Compare_ModRevision⟩ (Convert go.untyped_nil (go.PointerType etcdserverpb.Compare_ModRevision) UntypedNil))
            then
              let: "$r0" := (let: "$a0" := (![go.int64] (StructFieldRef mvccpb.KeyValue "ModRevision"%go (![go.PointerType mvccpb.KeyValue] "kv"))) in
              let: "$a1" := (![go.int64] (StructFieldRef etcdserverpb.Compare_ModRevision "ModRevision"%go (![go.PointerType etcdserverpb.Compare_ModRevision] "tv"))) in
              (FuncResolve compareInt64 [] #()) "$a0" "$a1") in
              do:  ("result" <-[go.int] "$r0")
            else do:  #()))
          else
            (if: "$sw" =⟨etcdserverpb.Compare_CompareTarget⟩ etcdserverpb.Compare_VERSION
            then
              (let: "tv" := (GoAlloc (go.PointerType etcdserverpb.Compare_Version) (GoZeroVal (go.PointerType etcdserverpb.Compare_Version) #())) in
              let: ("$ret0", "$ret1") := (TypeAssert2 (go.PointerType etcdserverpb.Compare_Version) (![etcdserverpb.isCompare_TargetUnion] (StructFieldRef clientv3.Cmp "TargetUnion"%go "tcmp"))) in
              let: "$r0" := "$ret0" in
              let: "$r1" := "$ret1" in
              do:  ("tv" <-[go.PointerType etcdserverpb.Compare_Version] "$r0");;;
              do:  "$r1";;;
              (if: Convert go.untyped_bool go.bool ((![go.PointerType etcdserverpb.Compare_Version] "tv") ≠⟨go.PointerType etcdserverpb.Compare_Version⟩ (Convert go.untyped_nil (go.PointerType etcdserverpb.Compare_Version) UntypedNil))
              then
                let: "$r0" := (let: "$a0" := (![go.int64] (StructFieldRef mvccpb.KeyValue "Version"%go (![go.PointerType mvccpb.KeyValue] "kv"))) in
                let: "$a1" := (![go.int64] (StructFieldRef etcdserverpb.Compare_Version "Version"%go (![go.PointerType etcdserverpb.Compare_Version] "tv"))) in
                (FuncResolve compareInt64 [] #()) "$a0" "$a1") in
                do:  ("result" <-[go.int] "$r0")
              else do:  #()))
            else do:  #()))))
    else do:  #());;;
    let: "$sw" := (![etcdserverpb.Compare_CompareResult] (StructFieldRef clientv3.Cmp "Result"%go "tcmp")) in
    (if: "$sw" =⟨etcdserverpb.Compare_CompareResult⟩ etcdserverpb.Compare_EQUAL
    then return: ((![go.int] "result") =⟨go.int⟩ #(W64 0))
    else
      (if: "$sw" =⟨etcdserverpb.Compare_CompareResult⟩ etcdserverpb.Compare_NOT_EQUAL
      then return: ((![go.int] "result") ≠⟨go.int⟩ #(W64 0))
      else
        (if: "$sw" =⟨etcdserverpb.Compare_CompareResult⟩ etcdserverpb.Compare_GREATER
        then return: ((![go.int] "result") >⟨go.int⟩ #(W64 0))
        else
          (if: "$sw" =⟨etcdserverpb.Compare_CompareResult⟩ etcdserverpb.Compare_LESS
          then return: ((![go.int] "result") <⟨go.int⟩ #(W64 0))
          else do:  #()))));;;
    return: (#true)).

(* go: util.go:71:6 *)
Definition gatherOpsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "ops",
    exception_do (let: "ret" := (GoAlloc (go.SliceType clientv3.Op) (GoZeroVal (go.SliceType clientv3.Op) #())) in
    let: "ops" := (GoAlloc (go.SliceType clientv3.Op) "ops") in
    let: "$range" := (![go.SliceType clientv3.Op] "ops") in
    (let: "op" := (GoAlloc clientv3.Op (GoZeroVal clientv3.Op #())) in
    slice.for_range clientv3.Op "$range" (λ: "$key" "$value",
      do:  ("op" <-[clientv3.Op] "$value");;;
      do:  "$key";;;
      (if: (⟨go.bool⟩! ((MethodResolve (go.PointerType clientv3.Op) "IsTxn"%go "op") #()))
      then
        let: "$r0" := (let: "$a0" := (![go.SliceType clientv3.Op] "ret") in
        let: "$a1" := ((let: "$sl0" := (![clientv3.Op] "op") in
        CompositeLiteral (go.SliceType clientv3.Op) (LiteralValue [KeyedElement None (ElementExpression clientv3.Op "$sl0")]))) in
        (FuncResolve go.append [go.SliceType clientv3.Op] #()) "$a0" "$a1") in
        do:  ("ret" <-[go.SliceType clientv3.Op] "$r0");;;
        continue: #()
      else do:  #());;;
      let: "elseOps" := (GoAlloc (go.SliceType clientv3.Op) (GoZeroVal (go.SliceType clientv3.Op) #())) in
      let: "thenOps" := (GoAlloc (go.SliceType clientv3.Op) (GoZeroVal (go.SliceType clientv3.Op) #())) in
      let: (("$ret0", "$ret1"), "$ret2") := ((MethodResolve (go.PointerType clientv3.Op) "Txn"%go "op") #()) in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      let: "$r2" := "$ret2" in
      do:  "$r0";;;
      do:  ("thenOps" <-[go.SliceType clientv3.Op] "$r1");;;
      do:  ("elseOps" <-[go.SliceType clientv3.Op] "$r2");;;
      let: "$r0" := (let: "$a0" := (![go.SliceType clientv3.Op] "ret") in
      let: "$a1" := (let: "$a0" := (let: "$a0" := (![go.SliceType clientv3.Op] "thenOps") in
      let: "$a1" := (![go.SliceType clientv3.Op] "elseOps") in
      (FuncResolve go.append [go.SliceType clientv3.Op] #()) "$a0" "$a1") in
      (FuncResolve gatherOps [] #()) "$a0") in
      (FuncResolve go.append [go.SliceType clientv3.Op] #()) "$a0" "$a1") in
      do:  ("ret" <-[go.SliceType clientv3.Op] "$r0")));;;
    return: (![go.SliceType clientv3.Op] "ret")).

(* go: util.go:83:6 *)
Definition gatherResponseOpsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "resp" "ops",
    exception_do (let: "ret" := (GoAlloc (go.SliceType clientv3.Op) (GoZeroVal (go.SliceType clientv3.Op) #())) in
    let: "ops" := (GoAlloc (go.SliceType clientv3.Op) "ops") in
    let: "resp" := (GoAlloc (go.SliceType (go.PointerType etcdserverpb.ResponseOp)) "resp") in
    let: "$range" := (![go.SliceType clientv3.Op] "ops") in
    (let: "op" := (GoAlloc clientv3.Op (GoZeroVal clientv3.Op #())) in
    let: "i" := (GoAlloc go.int (GoZeroVal go.int #())) in
    slice.for_range clientv3.Op "$range" (λ: "$key" "$value",
      do:  ("op" <-[clientv3.Op] "$value");;;
      do:  ("i" <-[go.int] "$key");;;
      (if: (⟨go.bool⟩! ((MethodResolve (go.PointerType clientv3.Op) "IsTxn"%go "op") #()))
      then
        let: "$r0" := (let: "$a0" := (![go.SliceType clientv3.Op] "ret") in
        let: "$a1" := ((let: "$sl0" := (![clientv3.Op] "op") in
        CompositeLiteral (go.SliceType clientv3.Op) (LiteralValue [KeyedElement None (ElementExpression clientv3.Op "$sl0")]))) in
        (FuncResolve go.append [go.SliceType clientv3.Op] #()) "$a0" "$a1") in
        do:  ("ret" <-[go.SliceType clientv3.Op] "$r0");;;
        continue: #()
      else do:  #());;;
      let: "elseOps" := (GoAlloc (go.SliceType clientv3.Op) (GoZeroVal (go.SliceType clientv3.Op) #())) in
      let: "thenOps" := (GoAlloc (go.SliceType clientv3.Op) (GoZeroVal (go.SliceType clientv3.Op) #())) in
      let: (("$ret0", "$ret1"), "$ret2") := ((MethodResolve (go.PointerType clientv3.Op) "Txn"%go "op") #()) in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      let: "$r2" := "$ret2" in
      do:  "$r0";;;
      do:  ("thenOps" <-[go.SliceType clientv3.Op] "$r1");;;
      do:  ("elseOps" <-[go.SliceType clientv3.Op] "$r2");;;
      (let: "txnResp" := (GoAlloc (go.PointerType etcdserverpb.TxnResponse) (GoZeroVal (go.PointerType etcdserverpb.TxnResponse) #())) in
      let: "$r0" := ((MethodResolve (go.PointerType etcdserverpb.ResponseOp) "GetResponseTxn"%go (![go.PointerType etcdserverpb.ResponseOp] (IndexRef (go.SliceType (go.PointerType etcdserverpb.ResponseOp)) (![go.SliceType (go.PointerType etcdserverpb.ResponseOp)] "resp", ![go.int] "i")))) #()) in
      do:  ("txnResp" <-[go.PointerType etcdserverpb.TxnResponse] "$r0");;;
      (if: ![go.bool] (StructFieldRef etcdserverpb.TxnResponse "Succeeded"%go (![go.PointerType etcdserverpb.TxnResponse] "txnResp"))
      then
        let: "$r0" := (let: "$a0" := (![go.SliceType clientv3.Op] "ret") in
        let: "$a1" := (let: "$a0" := (![go.SliceType (go.PointerType etcdserverpb.ResponseOp)] (StructFieldRef etcdserverpb.TxnResponse "Responses"%go (![go.PointerType etcdserverpb.TxnResponse] "txnResp"))) in
        let: "$a1" := (![go.SliceType clientv3.Op] "thenOps") in
        (FuncResolve gatherResponseOps [] #()) "$a0" "$a1") in
        (FuncResolve go.append [go.SliceType clientv3.Op] #()) "$a0" "$a1") in
        do:  ("ret" <-[go.SliceType clientv3.Op] "$r0")
      else
        let: "$r0" := (let: "$a0" := (![go.SliceType clientv3.Op] "ret") in
        let: "$a1" := (let: "$a0" := (![go.SliceType (go.PointerType etcdserverpb.ResponseOp)] (StructFieldRef etcdserverpb.TxnResponse "Responses"%go (![go.PointerType etcdserverpb.TxnResponse] "txnResp"))) in
        let: "$a1" := (![go.SliceType clientv3.Op] "elseOps") in
        (FuncResolve gatherResponseOps [] #()) "$a0" "$a1") in
        (FuncResolve go.append [go.SliceType clientv3.Op] #()) "$a0" "$a1") in
        do:  ("ret" <-[go.SliceType clientv3.Op] "$r0")))));;;
    return: (![go.SliceType clientv3.Op] "ret")).

(* go: util.go:99:6 *)
Definition copyHeaderⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "hdr",
    exception_do (let: "hdr" := (GoAlloc (go.PointerType etcdserverpb.ResponseHeader) "hdr") in
    let: "h" := (GoAlloc etcdserverpb.ResponseHeader (GoZeroVal etcdserverpb.ResponseHeader #())) in
    let: "$r0" := (![etcdserverpb.ResponseHeader] (![go.PointerType etcdserverpb.ResponseHeader] "hdr")) in
    do:  ("h" <-[etcdserverpb.ResponseHeader] "$r0");;;
    return: ("h")).

(* go: util.go:104:6 *)
Definition closeAllⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "chs",
    exception_do (let: "chs" := (GoAlloc (go.SliceType (go.ChannelType go.sendonly (go.StructType [

    ]))) "chs") in
    let: "$range" := (![go.SliceType (go.ChannelType go.sendonly (go.StructType [

    ]))] "chs") in
    (let: "ch" := (GoAlloc (go.ChannelType go.sendonly (go.StructType [

    ])) (GoZeroVal (go.ChannelType go.sendonly (go.StructType [

    ])) #())) in
    slice.for_range (go.ChannelType go.sendonly (go.StructType [

    ])) "$range" (λ: "$key" "$value",
      do:  ("ch" <-[go.ChannelType go.sendonly (go.StructType [

      ])] "$value");;;
      do:  "$key";;;
      do:  (let: "$a0" := (![go.ChannelType go.sendonly (go.StructType [

      ])] "ch") in
      (FuncResolve go.close [go.ChannelType go.sendonly (go.StructType [

       ])] #()) "$a0")));;;
    return: #()).

#[global] Instance info' : PkgInfo pkg_id.leasing :=
{|
  pkg_imported_pkgs := [code.context.pkg_id.context; code.strings.pkg_id.strings; code.sync.pkg_id.sync; code.time.pkg_id.time; code.go_etcd_io.etcd.api.v3.etcdserverpb.pkg_id.etcdserverpb; code.go_etcd_io.etcd.api.v3.mvccpb.pkg_id.mvccpb; code.go_etcd_io.etcd.client.v3.pkg_id.clientv3; code.errors.pkg_id.errors; code.google_golang_org.grpc.codes.pkg_id.codes; code.google_golang_org.grpc.status.pkg_id.status; code.go_etcd_io.etcd.api.v3.v3rpc.rpctypes.pkg_id.rpctypes; code.go_etcd_io.etcd.client.v3.concurrency.pkg_id.concurrency; code.bytes.pkg_id.bytes]
|}.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init pkg_id.leasing (λ: <>,
      exception_do (do:  (go.GlobalAlloc closedCh (go.ChannelType go.sendrecv (go.StructType [

      ])) #());;;
      do:  (bytes.initialize' #());;;
      do:  (concurrency.initialize' #());;;
      do:  (rpctypes.initialize' #());;;
      do:  (status.initialize' #());;;
      do:  (codes.initialize' #());;;
      do:  (errors.initialize' #());;;
      do:  (clientv3.initialize' #());;;
      do:  (mvccpb.initialize' #());;;
      do:  (etcdserverpb.initialize' #());;;
      do:  (time.initialize' #());;;
      do:  (sync.initialize' #());;;
      do:  (strings.initialize' #());;;
      do:  (context.initialize' #());;;
      do:  ((λ: <>,
        exception_do (let: "$r0" := ((FuncResolve go.make1 [go.ChannelType go.sendrecv (go.StructType [

         ])] #()) #()) in
        do:  ((GlobalVarAddr closedCh #()) <-[go.ChannelType go.sendrecv (go.StructType [

        ])] "$r0");;;
        do:  (let: "$a0" := (![go.ChannelType go.sendrecv (go.StructType [

        ])] (GlobalVarAddr closedCh #())) in
        (FuncResolve go.close [go.ChannelType go.sendrecv (go.StructType [

         ])] #()) "$a0");;;
        return: #())
        ) #()))
      ).

Module leaseCache.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  mu' : sync.RWMutex.t;
  entries' : map.t;
  revokes' : map.t;
  header' : loc;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End leaseCache.

Definition leaseCache'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "mu"%go sync.RWMutex);
  (go.FieldDecl "entries"%go (go.MapType go.string (go.PointerType leaseKey)));
  (go.FieldDecl "revokes"%go (go.MapType go.string time.Time));
  (go.FieldDecl "header"%go (go.PointerType etcdserverpb.ResponseHeader))
].
Program Definition leaseCache'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (leaseCache'fds_unsealed).
Global Instance equals_unfold_leaseCache {ext : ffi_syntax} {go_gctx : GoGlobalContext} : leaseCache'fds =→ leaseCache'fds_unsealed.
Proof. rewrite /leaseCache'fds seal_eq //. Qed.

Definition leaseCacheⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (leaseCache'fds).

Class leaseCache_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] leaseCache_type_repr  :: go.TypeReprUnderlying leaseCacheⁱᵐᵖˡ leaseCache.t;
  #[global] leaseCache_underlying :: (leaseCache) <u (leaseCacheⁱᵐᵖˡ);
  #[global] leaseCache_get_mu (x : leaseCache.t) :: ⟦StructFieldGet (leaseCacheⁱᵐᵖˡ) "mu", #x⟧ ⤳[under] #x.(leaseCache.mu');
  #[global] leaseCache_set_mu (x : leaseCache.t) y :: ⟦StructFieldSet (leaseCacheⁱᵐᵖˡ) "mu", (#x, #y)⟧ ⤳[under] #(x <|leaseCache.mu' := y|>);
  #[global] leaseCache_get_entries (x : leaseCache.t) :: ⟦StructFieldGet (leaseCacheⁱᵐᵖˡ) "entries", #x⟧ ⤳[under] #x.(leaseCache.entries');
  #[global] leaseCache_set_entries (x : leaseCache.t) y :: ⟦StructFieldSet (leaseCacheⁱᵐᵖˡ) "entries", (#x, #y)⟧ ⤳[under] #(x <|leaseCache.entries' := y|>);
  #[global] leaseCache_get_revokes (x : leaseCache.t) :: ⟦StructFieldGet (leaseCacheⁱᵐᵖˡ) "revokes", #x⟧ ⤳[under] #x.(leaseCache.revokes');
  #[global] leaseCache_set_revokes (x : leaseCache.t) y :: ⟦StructFieldSet (leaseCacheⁱᵐᵖˡ) "revokes", (#x, #y)⟧ ⤳[under] #(x <|leaseCache.revokes' := y|>);
  #[global] leaseCache_get_header (x : leaseCache.t) :: ⟦StructFieldGet (leaseCacheⁱᵐᵖˡ) "header", #x⟧ ⤳[under] #x.(leaseCache.header');
  #[global] leaseCache_set_header (x : leaseCache.t) y :: ⟦StructFieldSet (leaseCacheⁱᵐᵖˡ) "header", (#x, #y)⟧ ⤳[under] #(x <|leaseCache.header' := y|>);
  #[global] leaseCache'ptr_Add_unfold :: MethodUnfold (go.PointerType (leaseCache)) "Add" (leaseCache__Addⁱᵐᵖˡ);
  #[global] leaseCache'ptr_Delete_unfold :: MethodUnfold (go.PointerType (leaseCache)) "Delete" (leaseCache__Deleteⁱᵐᵖˡ);
  #[global] leaseCache'ptr_Evict_unfold :: MethodUnfold (go.PointerType (leaseCache)) "Evict" (leaseCache__Evictⁱᵐᵖˡ);
  #[global] leaseCache'ptr_EvictRange_unfold :: MethodUnfold (go.PointerType (leaseCache)) "EvictRange" (leaseCache__EvictRangeⁱᵐᵖˡ);
  #[global] leaseCache'ptr_Get_unfold :: MethodUnfold (go.PointerType (leaseCache)) "Get" (leaseCache__Getⁱᵐᵖˡ);
  #[global] leaseCache'ptr_Lock_unfold :: MethodUnfold (go.PointerType (leaseCache)) "Lock" (leaseCache__Lockⁱᵐᵖˡ);
  #[global] leaseCache'ptr_LockRange_unfold :: MethodUnfold (go.PointerType (leaseCache)) "LockRange" (leaseCache__LockRangeⁱᵐᵖˡ);
  #[global] leaseCache'ptr_LockWriteOps_unfold :: MethodUnfold (go.PointerType (leaseCache)) "LockWriteOps" (leaseCache__LockWriteOpsⁱᵐᵖˡ);
  #[global] leaseCache'ptr_MayAcquire_unfold :: MethodUnfold (go.PointerType (leaseCache)) "MayAcquire" (leaseCache__MayAcquireⁱᵐᵖˡ);
  #[global] leaseCache'ptr_NotifyOps_unfold :: MethodUnfold (go.PointerType (leaseCache)) "NotifyOps" (leaseCache__NotifyOpsⁱᵐᵖˡ);
  #[global] leaseCache'ptr_Rev_unfold :: MethodUnfold (go.PointerType (leaseCache)) "Rev" (leaseCache__Revⁱᵐᵖˡ);
  #[global] leaseCache'ptr_Update_unfold :: MethodUnfold (go.PointerType (leaseCache)) "Update" (leaseCache__Updateⁱᵐᵖˡ);
  #[global] leaseCache'ptr_clearOldRevokes_unfold :: MethodUnfold (go.PointerType (leaseCache)) "clearOldRevokes" (leaseCache__clearOldRevokesⁱᵐᵖˡ);
  #[global] leaseCache'ptr_delete_unfold :: MethodUnfold (go.PointerType (leaseCache)) "delete" (leaseCache__deleteⁱᵐᵖˡ);
  #[global] leaseCache'ptr_evalCmp_unfold :: MethodUnfold (go.PointerType (leaseCache)) "evalCmp" (leaseCache__evalCmpⁱᵐᵖˡ);
  #[global] leaseCache'ptr_evalOps_unfold :: MethodUnfold (go.PointerType (leaseCache)) "evalOps" (leaseCache__evalOpsⁱᵐᵖˡ);
  #[global] leaseCache'ptr_notify_unfold :: MethodUnfold (go.PointerType (leaseCache)) "notify" (leaseCache__notifyⁱᵐᵖˡ);
}.

Module leaseKey.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  response' : loc;
  rev' : w64;
  waitc' : chan.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End leaseKey.

Definition leaseKey'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "response"%go (go.PointerType clientv3.GetResponse));
  (go.FieldDecl "rev"%go go.int64);
  (go.FieldDecl "waitc"%go (go.ChannelType go.sendrecv (go.StructType [

  ])))
].
Program Definition leaseKey'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (leaseKey'fds_unsealed).
Global Instance equals_unfold_leaseKey {ext : ffi_syntax} {go_gctx : GoGlobalContext} : leaseKey'fds =→ leaseKey'fds_unsealed.
Proof. rewrite /leaseKey'fds seal_eq //. Qed.

Definition leaseKeyⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (leaseKey'fds).

Class leaseKey_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] leaseKey_type_repr  :: go.TypeReprUnderlying leaseKeyⁱᵐᵖˡ leaseKey.t;
  #[global] leaseKey_underlying :: (leaseKey) <u (leaseKeyⁱᵐᵖˡ);
  #[global] leaseKey_get_response (x : leaseKey.t) :: ⟦StructFieldGet (leaseKeyⁱᵐᵖˡ) "response", #x⟧ ⤳[under] #x.(leaseKey.response');
  #[global] leaseKey_set_response (x : leaseKey.t) y :: ⟦StructFieldSet (leaseKeyⁱᵐᵖˡ) "response", (#x, #y)⟧ ⤳[under] #(x <|leaseKey.response' := y|>);
  #[global] leaseKey_get_rev (x : leaseKey.t) :: ⟦StructFieldGet (leaseKeyⁱᵐᵖˡ) "rev", #x⟧ ⤳[under] #x.(leaseKey.rev');
  #[global] leaseKey_set_rev (x : leaseKey.t) y :: ⟦StructFieldSet (leaseKeyⁱᵐᵖˡ) "rev", (#x, #y)⟧ ⤳[under] #(x <|leaseKey.rev' := y|>);
  #[global] leaseKey_get_waitc (x : leaseKey.t) :: ⟦StructFieldGet (leaseKeyⁱᵐᵖˡ) "waitc", #x⟧ ⤳[under] #x.(leaseKey.waitc');
  #[global] leaseKey_set_waitc (x : leaseKey.t) y :: ⟦StructFieldSet (leaseKeyⁱᵐᵖˡ) "waitc", (#x, #y)⟧ ⤳[under] #(x <|leaseKey.waitc' := y|>);
  #[global] leaseKey'ptr_get_unfold :: MethodUnfold (go.PointerType (leaseKey)) "get" (leaseKey__getⁱᵐᵖˡ);
}.

Module leasingKV.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  cl' : loc;
  kv' : clientv3.KV.t;
  pfx' : go_string;
  leases' : leasing.leaseCache.t;
  ctx' : context.Context.t;
  cancel' : context.CancelFunc.t;
  wg' : sync.WaitGroup.t;
  sessionOpts' : slice.t;
  session' : loc;
  sessionc' : chan.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End leasingKV.

Definition leasingKV'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "cl"%go (go.PointerType clientv3.Client));
  (go.FieldDecl "kv"%go clientv3.KV);
  (go.FieldDecl "pfx"%go go.string);
  (go.FieldDecl "leases"%go leaseCache);
  (go.FieldDecl "ctx"%go context.Context);
  (go.FieldDecl "cancel"%go context.CancelFunc);
  (go.FieldDecl "wg"%go sync.WaitGroup);
  (go.FieldDecl "sessionOpts"%go (go.SliceType concurrency.SessionOption));
  (go.FieldDecl "session"%go (go.PointerType concurrency.Session));
  (go.FieldDecl "sessionc"%go (go.ChannelType go.sendrecv (go.StructType [

  ])))
].
Program Definition leasingKV'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (leasingKV'fds_unsealed).
Global Instance equals_unfold_leasingKV {ext : ffi_syntax} {go_gctx : GoGlobalContext} : leasingKV'fds =→ leasingKV'fds_unsealed.
Proof. rewrite /leasingKV'fds seal_eq //. Qed.

Definition leasingKVⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (leasingKV'fds).

Class leasingKV_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] leasingKV_type_repr  :: go.TypeReprUnderlying leasingKVⁱᵐᵖˡ leasingKV.t;
  #[global] leasingKV_underlying :: (leasingKV) <u (leasingKVⁱᵐᵖˡ);
  #[global] leasingKV_get_cl (x : leasingKV.t) :: ⟦StructFieldGet (leasingKVⁱᵐᵖˡ) "cl", #x⟧ ⤳[under] #x.(leasingKV.cl');
  #[global] leasingKV_set_cl (x : leasingKV.t) y :: ⟦StructFieldSet (leasingKVⁱᵐᵖˡ) "cl", (#x, #y)⟧ ⤳[under] #(x <|leasingKV.cl' := y|>);
  #[global] leasingKV_get_kv (x : leasingKV.t) :: ⟦StructFieldGet (leasingKVⁱᵐᵖˡ) "kv", #x⟧ ⤳[under] #x.(leasingKV.kv');
  #[global] leasingKV_set_kv (x : leasingKV.t) y :: ⟦StructFieldSet (leasingKVⁱᵐᵖˡ) "kv", (#x, #y)⟧ ⤳[under] #(x <|leasingKV.kv' := y|>);
  #[global] leasingKV_get_pfx (x : leasingKV.t) :: ⟦StructFieldGet (leasingKVⁱᵐᵖˡ) "pfx", #x⟧ ⤳[under] #x.(leasingKV.pfx');
  #[global] leasingKV_set_pfx (x : leasingKV.t) y :: ⟦StructFieldSet (leasingKVⁱᵐᵖˡ) "pfx", (#x, #y)⟧ ⤳[under] #(x <|leasingKV.pfx' := y|>);
  #[global] leasingKV_get_leases (x : leasingKV.t) :: ⟦StructFieldGet (leasingKVⁱᵐᵖˡ) "leases", #x⟧ ⤳[under] #x.(leasingKV.leases');
  #[global] leasingKV_set_leases (x : leasingKV.t) y :: ⟦StructFieldSet (leasingKVⁱᵐᵖˡ) "leases", (#x, #y)⟧ ⤳[under] #(x <|leasingKV.leases' := y|>);
  #[global] leasingKV_get_ctx (x : leasingKV.t) :: ⟦StructFieldGet (leasingKVⁱᵐᵖˡ) "ctx", #x⟧ ⤳[under] #x.(leasingKV.ctx');
  #[global] leasingKV_set_ctx (x : leasingKV.t) y :: ⟦StructFieldSet (leasingKVⁱᵐᵖˡ) "ctx", (#x, #y)⟧ ⤳[under] #(x <|leasingKV.ctx' := y|>);
  #[global] leasingKV_get_cancel (x : leasingKV.t) :: ⟦StructFieldGet (leasingKVⁱᵐᵖˡ) "cancel", #x⟧ ⤳[under] #x.(leasingKV.cancel');
  #[global] leasingKV_set_cancel (x : leasingKV.t) y :: ⟦StructFieldSet (leasingKVⁱᵐᵖˡ) "cancel", (#x, #y)⟧ ⤳[under] #(x <|leasingKV.cancel' := y|>);
  #[global] leasingKV_get_wg (x : leasingKV.t) :: ⟦StructFieldGet (leasingKVⁱᵐᵖˡ) "wg", #x⟧ ⤳[under] #x.(leasingKV.wg');
  #[global] leasingKV_set_wg (x : leasingKV.t) y :: ⟦StructFieldSet (leasingKVⁱᵐᵖˡ) "wg", (#x, #y)⟧ ⤳[under] #(x <|leasingKV.wg' := y|>);
  #[global] leasingKV_get_sessionOpts (x : leasingKV.t) :: ⟦StructFieldGet (leasingKVⁱᵐᵖˡ) "sessionOpts", #x⟧ ⤳[under] #x.(leasingKV.sessionOpts');
  #[global] leasingKV_set_sessionOpts (x : leasingKV.t) y :: ⟦StructFieldSet (leasingKVⁱᵐᵖˡ) "sessionOpts", (#x, #y)⟧ ⤳[under] #(x <|leasingKV.sessionOpts' := y|>);
  #[global] leasingKV_get_session (x : leasingKV.t) :: ⟦StructFieldGet (leasingKVⁱᵐᵖˡ) "session", #x⟧ ⤳[under] #x.(leasingKV.session');
  #[global] leasingKV_set_session (x : leasingKV.t) y :: ⟦StructFieldSet (leasingKVⁱᵐᵖˡ) "session", (#x, #y)⟧ ⤳[under] #(x <|leasingKV.session' := y|>);
  #[global] leasingKV_get_sessionc (x : leasingKV.t) :: ⟦StructFieldGet (leasingKVⁱᵐᵖˡ) "sessionc", #x⟧ ⤳[under] #x.(leasingKV.sessionc');
  #[global] leasingKV_set_sessionc (x : leasingKV.t) y :: ⟦StructFieldSet (leasingKVⁱᵐᵖˡ) "sessionc", (#x, #y)⟧ ⤳[under] #(x <|leasingKV.sessionc' := y|>);
  #[global] leasingKV'ptr_Close_unfold :: MethodUnfold (go.PointerType (leasingKV)) "Close" (leasingKV__Closeⁱᵐᵖˡ);
  #[global] leasingKV'ptr_Compact_unfold :: MethodUnfold (go.PointerType (leasingKV)) "Compact" (leasingKV__Compactⁱᵐᵖˡ);
  #[global] leasingKV'ptr_Delete_unfold :: MethodUnfold (go.PointerType (leasingKV)) "Delete" (leasingKV__Deleteⁱᵐᵖˡ);
  #[global] leasingKV'ptr_Do_unfold :: MethodUnfold (go.PointerType (leasingKV)) "Do" (leasingKV__Doⁱᵐᵖˡ);
  #[global] leasingKV'ptr_Get_unfold :: MethodUnfold (go.PointerType (leasingKV)) "Get" (leasingKV__Getⁱᵐᵖˡ);
  #[global] leasingKV'ptr_Put_unfold :: MethodUnfold (go.PointerType (leasingKV)) "Put" (leasingKV__Putⁱᵐᵖˡ);
  #[global] leasingKV'ptr_Txn_unfold :: MethodUnfold (go.PointerType (leasingKV)) "Txn" (leasingKV__Txnⁱᵐᵖˡ);
  #[global] leasingKV'ptr_acquire_unfold :: MethodUnfold (go.PointerType (leasingKV)) "acquire" (leasingKV__acquireⁱᵐᵖˡ);
  #[global] leasingKV'ptr_delete_unfold :: MethodUnfold (go.PointerType (leasingKV)) "delete" (leasingKV__deleteⁱᵐᵖˡ);
  #[global] leasingKV'ptr_deleteRange_unfold :: MethodUnfold (go.PointerType (leasingKV)) "deleteRange" (leasingKV__deleteRangeⁱᵐᵖˡ);
  #[global] leasingKV'ptr_deleteRangeRPC_unfold :: MethodUnfold (go.PointerType (leasingKV)) "deleteRangeRPC" (leasingKV__deleteRangeRPCⁱᵐᵖˡ);
  #[global] leasingKV'ptr_get_unfold :: MethodUnfold (go.PointerType (leasingKV)) "get" (leasingKV__getⁱᵐᵖˡ);
  #[global] leasingKV'ptr_leaseID_unfold :: MethodUnfold (go.PointerType (leasingKV)) "leaseID" (leasingKV__leaseIDⁱᵐᵖˡ);
  #[global] leasingKV'ptr_monitorLease_unfold :: MethodUnfold (go.PointerType (leasingKV)) "monitorLease" (leasingKV__monitorLeaseⁱᵐᵖˡ);
  #[global] leasingKV'ptr_monitorSession_unfold :: MethodUnfold (go.PointerType (leasingKV)) "monitorSession" (leasingKV__monitorSessionⁱᵐᵖˡ);
  #[global] leasingKV'ptr_put_unfold :: MethodUnfold (go.PointerType (leasingKV)) "put" (leasingKV__putⁱᵐᵖˡ);
  #[global] leasingKV'ptr_readySession_unfold :: MethodUnfold (go.PointerType (leasingKV)) "readySession" (leasingKV__readySessionⁱᵐᵖˡ);
  #[global] leasingKV'ptr_rescind_unfold :: MethodUnfold (go.PointerType (leasingKV)) "rescind" (leasingKV__rescindⁱᵐᵖˡ);
  #[global] leasingKV'ptr_revoke_unfold :: MethodUnfold (go.PointerType (leasingKV)) "revoke" (leasingKV__revokeⁱᵐᵖˡ);
  #[global] leasingKV'ptr_revokeLeaseKvs_unfold :: MethodUnfold (go.PointerType (leasingKV)) "revokeLeaseKvs" (leasingKV__revokeLeaseKvsⁱᵐᵖˡ);
  #[global] leasingKV'ptr_revokeRange_unfold :: MethodUnfold (go.PointerType (leasingKV)) "revokeRange" (leasingKV__revokeRangeⁱᵐᵖˡ);
  #[global] leasingKV'ptr_tryModifyOp_unfold :: MethodUnfold (go.PointerType (leasingKV)) "tryModifyOp" (leasingKV__tryModifyOpⁱᵐᵖˡ);
  #[global] leasingKV'ptr_waitRescind_unfold :: MethodUnfold (go.PointerType (leasingKV)) "waitRescind" (leasingKV__waitRescindⁱᵐᵖˡ);
  #[global] leasingKV'ptr_waitSession_unfold :: MethodUnfold (go.PointerType (leasingKV)) "waitSession" (leasingKV__waitSessionⁱᵐᵖˡ);
}.

Module txnLeasing.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  Txn' : clientv3.Txn.t;
  lkv' : loc;
  ctx' : context.Context.t;
  cs' : slice.t;
  opst' : slice.t;
  opse' : slice.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End txnLeasing.

Definition txnLeasing'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.EmbeddedField "Txn"%go clientv3.Txn);
  (go.FieldDecl "lkv"%go (go.PointerType leasingKV));
  (go.FieldDecl "ctx"%go context.Context);
  (go.FieldDecl "cs"%go (go.SliceType clientv3.Cmp));
  (go.FieldDecl "opst"%go (go.SliceType clientv3.Op));
  (go.FieldDecl "opse"%go (go.SliceType clientv3.Op))
].
Program Definition txnLeasing'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (txnLeasing'fds_unsealed).
Global Instance equals_unfold_txnLeasing {ext : ffi_syntax} {go_gctx : GoGlobalContext} : txnLeasing'fds =→ txnLeasing'fds_unsealed.
Proof. rewrite /txnLeasing'fds seal_eq //. Qed.

Definition txnLeasingⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (txnLeasing'fds).

Class txnLeasing_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] txnLeasing_type_repr  :: go.TypeReprUnderlying txnLeasingⁱᵐᵖˡ txnLeasing.t;
  #[global] txnLeasing_underlying :: (txnLeasing) <u (txnLeasingⁱᵐᵖˡ);
  #[global] txnLeasing_get_Txn (x : txnLeasing.t) :: ⟦StructFieldGet (txnLeasingⁱᵐᵖˡ) "Txn", #x⟧ ⤳[under] #x.(txnLeasing.Txn');
  #[global] txnLeasing_set_Txn (x : txnLeasing.t) y :: ⟦StructFieldSet (txnLeasingⁱᵐᵖˡ) "Txn", (#x, #y)⟧ ⤳[under] #(x <|txnLeasing.Txn' := y|>);
  #[global] txnLeasing_get_lkv (x : txnLeasing.t) :: ⟦StructFieldGet (txnLeasingⁱᵐᵖˡ) "lkv", #x⟧ ⤳[under] #x.(txnLeasing.lkv');
  #[global] txnLeasing_set_lkv (x : txnLeasing.t) y :: ⟦StructFieldSet (txnLeasingⁱᵐᵖˡ) "lkv", (#x, #y)⟧ ⤳[under] #(x <|txnLeasing.lkv' := y|>);
  #[global] txnLeasing_get_ctx (x : txnLeasing.t) :: ⟦StructFieldGet (txnLeasingⁱᵐᵖˡ) "ctx", #x⟧ ⤳[under] #x.(txnLeasing.ctx');
  #[global] txnLeasing_set_ctx (x : txnLeasing.t) y :: ⟦StructFieldSet (txnLeasingⁱᵐᵖˡ) "ctx", (#x, #y)⟧ ⤳[under] #(x <|txnLeasing.ctx' := y|>);
  #[global] txnLeasing_get_cs (x : txnLeasing.t) :: ⟦StructFieldGet (txnLeasingⁱᵐᵖˡ) "cs", #x⟧ ⤳[under] #x.(txnLeasing.cs');
  #[global] txnLeasing_set_cs (x : txnLeasing.t) y :: ⟦StructFieldSet (txnLeasingⁱᵐᵖˡ) "cs", (#x, #y)⟧ ⤳[under] #(x <|txnLeasing.cs' := y|>);
  #[global] txnLeasing_get_opst (x : txnLeasing.t) :: ⟦StructFieldGet (txnLeasingⁱᵐᵖˡ) "opst", #x⟧ ⤳[under] #x.(txnLeasing.opst');
  #[global] txnLeasing_set_opst (x : txnLeasing.t) y :: ⟦StructFieldSet (txnLeasingⁱᵐᵖˡ) "opst", (#x, #y)⟧ ⤳[under] #(x <|txnLeasing.opst' := y|>);
  #[global] txnLeasing_get_opse (x : txnLeasing.t) :: ⟦StructFieldGet (txnLeasingⁱᵐᵖˡ) "opse", #x⟧ ⤳[under] #x.(txnLeasing.opse');
  #[global] txnLeasing_set_opse (x : txnLeasing.t) y :: ⟦StructFieldSet (txnLeasingⁱᵐᵖˡ) "opse", (#x, #y)⟧ ⤳[under] #(x <|txnLeasing.opse' := y|>);
  #[global] txnLeasing'ptr_Commit_unfold :: MethodUnfold (go.PointerType (txnLeasing)) "Commit" (txnLeasing__Commitⁱᵐᵖˡ);
  #[global] txnLeasing'ptr_Else_unfold :: MethodUnfold (go.PointerType (txnLeasing)) "Else" (txnLeasing__Elseⁱᵐᵖˡ);
  #[global] txnLeasing'ptr_If_unfold :: MethodUnfold (go.PointerType (txnLeasing)) "If" (txnLeasing__Ifⁱᵐᵖˡ);
  #[global] txnLeasing'ptr_Then_unfold :: MethodUnfold (go.PointerType (txnLeasing)) "Then" (txnLeasing__Thenⁱᵐᵖˡ);
  #[global] txnLeasing'ptr_commitToCache_unfold :: MethodUnfold (go.PointerType (txnLeasing)) "commitToCache" (txnLeasing__commitToCacheⁱᵐᵖˡ);
  #[global] txnLeasing'ptr_eval_unfold :: MethodUnfold (go.PointerType (txnLeasing)) "eval" (txnLeasing__evalⁱᵐᵖˡ);
  #[global] txnLeasing'ptr_fallback_unfold :: MethodUnfold (go.PointerType (txnLeasing)) "fallback" (txnLeasing__fallbackⁱᵐᵖˡ);
  #[global] txnLeasing'ptr_guard_unfold :: MethodUnfold (go.PointerType (txnLeasing)) "guard" (txnLeasing__guardⁱᵐᵖˡ);
  #[global] txnLeasing'ptr_guardKeys_unfold :: MethodUnfold (go.PointerType (txnLeasing)) "guardKeys" (txnLeasing__guardKeysⁱᵐᵖˡ);
  #[global] txnLeasing'ptr_guardRanges_unfold :: MethodUnfold (go.PointerType (txnLeasing)) "guardRanges" (txnLeasing__guardRangesⁱᵐᵖˡ);
  #[global] txnLeasing'ptr_revokeFallback_unfold :: MethodUnfold (go.PointerType (txnLeasing)) "revokeFallback" (txnLeasing__revokeFallbackⁱᵐᵖˡ);
  #[global] txnLeasing'ptr_serverTxn_unfold :: MethodUnfold (go.PointerType (txnLeasing)) "serverTxn" (txnLeasing__serverTxnⁱᵐᵖˡ);
}.

Class Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] leaseCache_instance :: leaseCache_Assumptions;
  #[global] leaseKey_instance :: leaseKey_Assumptions;
  #[global] leasingKV_instance :: leasingKV_Assumptions;
  #[global] txnLeasing_instance :: txnLeasing_Assumptions;
  #[global] inRange_unfold :: FuncUnfold inRange [] (inRangeⁱᵐᵖˡ);
  #[global] isBadOp_unfold :: FuncUnfold isBadOp [] (isBadOpⁱᵐᵖˡ);
  #[global] NewKV_unfold :: FuncUnfold NewKV [] (NewKVⁱᵐᵖˡ);
  #[global] compareInt64_unfold :: FuncUnfold compareInt64 [] (compareInt64ⁱᵐᵖˡ);
  #[global] evalCmp_unfold :: FuncUnfold evalCmp [] (evalCmpⁱᵐᵖˡ);
  #[global] gatherOps_unfold :: FuncUnfold gatherOps [] (gatherOpsⁱᵐᵖˡ);
  #[global] gatherResponseOps_unfold :: FuncUnfold gatherResponseOps [] (gatherResponseOpsⁱᵐᵖˡ);
  #[global] copyHeader_unfold :: FuncUnfold copyHeader [] (copyHeaderⁱᵐᵖˡ);
  #[global] closeAll_unfold :: FuncUnfold closeAll [] (closeAllⁱᵐᵖˡ);
  #[global] import_context_Assumption :: context.Assumptions;
  #[global] import_strings_Assumption :: strings.Assumptions;
  #[global] import_sync_Assumption :: sync.Assumptions;
  #[global] import_time_Assumption :: time.Assumptions;
  #[global] import_etcdserverpb_Assumption :: etcdserverpb.Assumptions;
  #[global] import_mvccpb_Assumption :: mvccpb.Assumptions;
  #[global] import_clientv3_Assumption :: clientv3.Assumptions;
  #[global] import_errors_Assumption :: errors.Assumptions;
  #[global] import_codes_Assumption :: codes.Assumptions;
  #[global] import_status_Assumption :: status.Assumptions;
  #[global] import_rpctypes_Assumption :: rpctypes.Assumptions;
  #[global] import_concurrency_Assumption :: concurrency.Assumptions;
  #[global] import_bytes_Assumption :: bytes.Assumptions;
}.
End leasing.
