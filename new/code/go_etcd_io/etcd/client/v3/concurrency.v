(* autogenerated from go.etcd.io/etcd/client/v3/concurrency *)
From New.golang Require Import defn.
Require Export New.code.context.
Require Export New.code.errors.
Require Export New.code.fmt.
Require Export New.code.go_etcd_io.etcd.api.v3.etcdserverpb.
Require Export New.code.go_etcd_io.etcd.api.v3.mvccpb.
Require Export New.code.go_etcd_io.etcd.client.v3.
Require Export New.code.go_uber_org.zap.
Require Export New.code.math.
Require Export New.code.strings.
Require Export New.code.sync.
Require Export New.code.time.

Definition concurrency : go_string := "go.etcd.io/etcd/client/v3/concurrency".

Module concurrency.
Section code.
Context `{ffi_syntax}.


Definition ErrElectionNotLeader : go_string := "go.etcd.io/etcd/client/v3/concurrency.ErrElectionNotLeader"%go.

Definition ErrElectionNoLeader : go_string := "go.etcd.io/etcd/client/v3/concurrency.ErrElectionNoLeader"%go.

Definition Election : go_type := structT [
  "session" :: ptrT;
  "keyPrefix" :: stringT;
  "leaderKey" :: stringT;
  "leaderRev" :: int64T;
  "leaderSession" :: ptrT;
  "hdr" :: ptrT
].

Definition Electionⁱᵈ : go_string := "go.etcd.io/etcd/client/v3/concurrency.Election"%go.

Definition NewElection : go_string := "go.etcd.io/etcd/client/v3/concurrency.NewElection"%go.

(* NewElection returns a new election on a given key prefix.

   go: election.go:44:6 *)
Definition NewElectionⁱᵐᵖˡ : val :=
  λ: "s" "pfx",
    exception_do (let: "pfx" := (mem.alloc "pfx") in
    let: "s" := (mem.alloc "s") in
    return: (mem.alloc (let: "$session" := (![#ptrT] "s") in
     let: "$keyPrefix" := ((![#stringT] "pfx") + #"/"%go) in
     struct.make #Election [{
       "session" ::= "$session";
       "keyPrefix" ::= "$keyPrefix";
       "leaderKey" ::= type.zero_val #stringT;
       "leaderRev" ::= type.zero_val #int64T;
       "leaderSession" ::= type.zero_val #ptrT;
       "hdr" ::= type.zero_val #ptrT
     }]))).

Definition ResumeElection : go_string := "go.etcd.io/etcd/client/v3/concurrency.ResumeElection"%go.

(* ResumeElection initializes an election with a known leader.

   go: election.go:49:6 *)
Definition ResumeElectionⁱᵐᵖˡ : val :=
  λ: "s" "pfx" "leaderKey" "leaderRev",
    exception_do (let: "leaderRev" := (mem.alloc "leaderRev") in
    let: "leaderKey" := (mem.alloc "leaderKey") in
    let: "pfx" := (mem.alloc "pfx") in
    let: "s" := (mem.alloc "s") in
    return: (mem.alloc (let: "$keyPrefix" := (![#stringT] "pfx") in
     let: "$session" := (![#ptrT] "s") in
     let: "$leaderKey" := (![#stringT] "leaderKey") in
     let: "$leaderRev" := (![#int64T] "leaderRev") in
     let: "$leaderSession" := (![#ptrT] "s") in
     struct.make #Election [{
       "session" ::= "$session";
       "keyPrefix" ::= "$keyPrefix";
       "leaderKey" ::= "$leaderKey";
       "leaderRev" ::= "$leaderRev";
       "leaderSession" ::= "$leaderSession";
       "hdr" ::= type.zero_val #ptrT
     }]))).

Definition waitDeletes : go_string := "go.etcd.io/etcd/client/v3/concurrency.waitDeletes"%go.

Definition Session : go_type := structT [
  "client" :: ptrT;
  "opts" :: ptrT;
  "id" :: clientv3.LeaseID;
  "ctx" :: context.Context;
  "cancel" :: context.CancelFunc;
  "donec" :: chanT (structT [
  ])
].

(* Campaign puts a value as eligible for the election on the prefix
   key.
   Multiple sessions can participate in the election for the
   same prefix, but only one can be the leader at a time.

   If the context is 'context.TODO()/context.Background()', the Campaign
   will continue to be blocked for other keys to be deleted, unless server
   returns a non-recoverable error (e.g. ErrCompacted).
   Otherwise, until the context is not cancelled or timed-out, Campaign will
   continue to be blocked until it becomes the leader.

   go: election.go:69:20 *)
Definition Election__Campaignⁱᵐᵖˡ : val :=
  λ: "e" "ctx" "val",
    exception_do (let: "e" := (mem.alloc "e") in
    let: "val" := (mem.alloc "val") in
    let: "ctx" := (mem.alloc "ctx") in
    let: "s" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (![#ptrT] (struct.field_ref #Election #"session"%go (![#ptrT] "e"))) in
    do:  ("s" <-[#ptrT] "$r0");;;
    let: "client" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := ((method_call #concurrency.concurrency #"Session'ptr" #"Client" (![#ptrT] (struct.field_ref #Election #"session"%go (![#ptrT] "e")))) #()) in
    do:  ("client" <-[#ptrT] "$r0");;;
    let: "k" := (mem.alloc (type.zero_val #stringT)) in
    let: "$r0" := (let: "$a0" := #"%s%x"%go in
    let: "$a1" := ((let: "$sl0" := (interface.make #stringTⁱᵈ (![#stringT] (struct.field_ref #Election #"keyPrefix"%go (![#ptrT] "e")))) in
    let: "$sl1" := (interface.make #clientv3.LeaseIDⁱᵈ ((method_call #concurrency.concurrency #"Session'ptr" #"Lease" (![#ptrT] "s")) #())) in
    slice.literal #interfaceT ["$sl0"; "$sl1"])) in
    (func_call #fmt.Sprintf) "$a0" "$a1") in
    do:  ("k" <-[#stringT] "$r0");;;
    let: "txn" := (mem.alloc (type.zero_val #clientv3.Txn)) in
    let: "$r0" := (let: "$a0" := ((let: "$sl0" := (let: "$a0" := (let: "$a0" := (![#stringT] "k") in
    (func_call #clientv3.CreateRevision) "$a0") in
    let: "$a1" := #"="%go in
    let: "$a2" := (interface.make #intTⁱᵈ #(W64 0)) in
    (func_call #clientv3.Compare) "$a0" "$a1" "$a2") in
    slice.literal #clientv3.Cmp ["$sl0"])) in
    (interface.get #"If"%go (let: "$a0" := (![#context.Context] "ctx") in
    (method_call #clientv3 #"Client'ptr" #"Txn" (![#ptrT] "client")) "$a0")) "$a0") in
    do:  ("txn" <-[#clientv3.Txn] "$r0");;;
    let: "$r0" := (let: "$a0" := ((let: "$sl0" := (let: "$a0" := (![#stringT] "k") in
    let: "$a1" := (![#stringT] "val") in
    let: "$a2" := ((let: "$sl0" := (let: "$a0" := ((method_call #concurrency.concurrency #"Session'ptr" #"Lease" (![#ptrT] "s")) #()) in
    (func_call #clientv3.WithLease) "$a0") in
    slice.literal #clientv3.OpOption ["$sl0"])) in
    (func_call #clientv3.OpPut) "$a0" "$a1" "$a2") in
    slice.literal #clientv3.Op ["$sl0"])) in
    (interface.get #"Then"%go (![#clientv3.Txn] "txn")) "$a0") in
    do:  ("txn" <-[#clientv3.Txn] "$r0");;;
    let: "$r0" := (let: "$a0" := ((let: "$sl0" := (let: "$a0" := (![#stringT] "k") in
    let: "$a1" := #slice.nil in
    (func_call #clientv3.OpGet) "$a0" "$a1") in
    slice.literal #clientv3.Op ["$sl0"])) in
    (interface.get #"Else"%go (![#clientv3.Txn] "txn")) "$a0") in
    do:  ("txn" <-[#clientv3.Txn] "$r0");;;
    let: "err" := (mem.alloc (type.zero_val #error)) in
    let: "resp" := (mem.alloc (type.zero_val #ptrT)) in
    let: ("$ret0", "$ret1") := ((interface.get #"Commit"%go (![#clientv3.Txn] "txn")) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("resp" <-[#ptrT] "$r0");;;
    do:  ("err" <-[#error] "$r1");;;
    (if: (~ (interface.eq (![#error] "err") #interface.nil))
    then return: (![#error] "err")
    else do:  #());;;
    let: "$r0" := (![#stringT] "k") in
    let: "$r1" := (![#int64T] (struct.field_ref #etcdserverpb.ResponseHeader #"Revision"%go (![#ptrT] (struct.field_ref #clientv3.TxnResponse #"Header"%go (![#ptrT] "resp"))))) in
    let: "$r2" := (![#ptrT] "s") in
    do:  ((struct.field_ref #Election #"leaderKey"%go (![#ptrT] "e")) <-[#stringT] "$r0");;;
    do:  ((struct.field_ref #Election #"leaderRev"%go (![#ptrT] "e")) <-[#int64T] "$r1");;;
    do:  ((struct.field_ref #Election #"leaderSession"%go (![#ptrT] "e")) <-[#ptrT] "$r2");;;
    (if: (~ (![#boolT] (struct.field_ref #clientv3.TxnResponse #"Succeeded"%go (![#ptrT] "resp"))))
    then
      let: "kv" := (mem.alloc (type.zero_val #ptrT)) in
      let: "$r0" := (![#ptrT] (slice.elem_ref #ptrT (![#sliceT] (struct.field_ref #etcdserverpb.RangeResponse #"Kvs"%go ((method_call #etcdserverpb #"ResponseOp'ptr" #"GetResponseRange" (![#ptrT] (slice.elem_ref #ptrT (![#sliceT] (struct.field_ref #clientv3.TxnResponse #"Responses"%go (![#ptrT] "resp"))) #(W64 0)))) #()))) #(W64 0))) in
      do:  ("kv" <-[#ptrT] "$r0");;;
      let: "$r0" := (![#int64T] (struct.field_ref #mvccpb.KeyValue #"CreateRevision"%go (![#ptrT] "kv"))) in
      do:  ((struct.field_ref #Election #"leaderRev"%go (![#ptrT] "e")) <-[#int64T] "$r0");;;
      (if: (string.from_bytes (![#sliceT] (struct.field_ref #mvccpb.KeyValue #"Value"%go (![#ptrT] "kv")))) ≠ (![#stringT] "val")
      then
        (let: "$r0" := (let: "$a0" := (![#context.Context] "ctx") in
        let: "$a1" := (![#stringT] "val") in
        (method_call #concurrency.concurrency #"Election'ptr" #"Proclaim" (![#ptrT] "e")) "$a0" "$a1") in
        do:  ("err" <-[#error] "$r0");;;
        (if: (~ (interface.eq (![#error] "err") #interface.nil))
        then
          do:  (let: "$a0" := (![#context.Context] "ctx") in
          (method_call #concurrency.concurrency #"Election'ptr" #"Resign" (![#ptrT] "e")) "$a0");;;
          return: (![#error] "err")
        else do:  #()))
      else do:  #())
    else do:  #());;;
    let: "$r0" := (let: "$a0" := (![#context.Context] "ctx") in
    let: "$a1" := (![#ptrT] "client") in
    let: "$a2" := (![#stringT] (struct.field_ref #Election #"keyPrefix"%go (![#ptrT] "e"))) in
    let: "$a3" := ((![#int64T] (struct.field_ref #Election #"leaderRev"%go (![#ptrT] "e"))) - #(W64 1)) in
    (func_call #waitDeletes) "$a0" "$a1" "$a2" "$a3") in
    do:  ("err" <-[#error] "$r0");;;
    (if: (~ (interface.eq (![#error] "err") #interface.nil))
    then
      chan.select [chan.select_receive ((interface.get #"Done"%go (![#context.Context] "ctx")) #()) (λ: "$recvVal",
         do:  (let: "$a0" := ((method_call #clientv3 #"Client'ptr" #"Ctx" (![#ptrT] "client")) #()) in
         (method_call #concurrency.concurrency #"Election'ptr" #"Resign" (![#ptrT] "e")) "$a0")
         )] (chan.select_default (λ: <>,
        let: "$r0" := #null in
        do:  ((struct.field_ref #Election #"leaderSession"%go (![#ptrT] "e")) <-[#ptrT] "$r0")
        ));;;
      return: (![#error] "err")
    else do:  #());;;
    let: "$r0" := (![#ptrT] (struct.field_ref #clientv3.TxnResponse #"Header"%go (![#ptrT] "resp"))) in
    do:  ((struct.field_ref #Election #"hdr"%go (![#ptrT] "e")) <-[#ptrT] "$r0");;;
    return: (#interface.nil)).

(* Proclaim lets the leader announce a new value without another election.

   go: election.go:110:20 *)
Definition Election__Proclaimⁱᵐᵖˡ : val :=
  λ: "e" "ctx" "val",
    exception_do (let: "e" := (mem.alloc "e") in
    let: "val" := (mem.alloc "val") in
    let: "ctx" := (mem.alloc "ctx") in
    (if: (![#ptrT] (struct.field_ref #Election #"leaderSession"%go (![#ptrT] "e"))) = #null
    then return: (![#error] (globals.get #ErrElectionNotLeader))
    else do:  #());;;
    let: "client" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := ((method_call #concurrency.concurrency #"Session'ptr" #"Client" (![#ptrT] (struct.field_ref #Election #"session"%go (![#ptrT] "e")))) #()) in
    do:  ("client" <-[#ptrT] "$r0");;;
    let: "cmp" := (mem.alloc (type.zero_val #clientv3.Cmp)) in
    let: "$r0" := (let: "$a0" := (let: "$a0" := (![#stringT] (struct.field_ref #Election #"leaderKey"%go (![#ptrT] "e"))) in
    (func_call #clientv3.CreateRevision) "$a0") in
    let: "$a1" := #"="%go in
    let: "$a2" := (interface.make #int64Tⁱᵈ (![#int64T] (struct.field_ref #Election #"leaderRev"%go (![#ptrT] "e")))) in
    (func_call #clientv3.Compare) "$a0" "$a1" "$a2") in
    do:  ("cmp" <-[#clientv3.Cmp] "$r0");;;
    let: "txn" := (mem.alloc (type.zero_val #clientv3.Txn)) in
    let: "$r0" := (let: "$a0" := ((let: "$sl0" := (![#clientv3.Cmp] "cmp") in
    slice.literal #clientv3.Cmp ["$sl0"])) in
    (interface.get #"If"%go (let: "$a0" := (![#context.Context] "ctx") in
    (method_call #clientv3 #"Client'ptr" #"Txn" (![#ptrT] "client")) "$a0")) "$a0") in
    do:  ("txn" <-[#clientv3.Txn] "$r0");;;
    let: "$r0" := (let: "$a0" := ((let: "$sl0" := (let: "$a0" := (![#stringT] (struct.field_ref #Election #"leaderKey"%go (![#ptrT] "e"))) in
    let: "$a1" := (![#stringT] "val") in
    let: "$a2" := ((let: "$sl0" := (let: "$a0" := ((method_call #concurrency.concurrency #"Session'ptr" #"Lease" (![#ptrT] (struct.field_ref #Election #"leaderSession"%go (![#ptrT] "e")))) #()) in
    (func_call #clientv3.WithLease) "$a0") in
    slice.literal #clientv3.OpOption ["$sl0"])) in
    (func_call #clientv3.OpPut) "$a0" "$a1" "$a2") in
    slice.literal #clientv3.Op ["$sl0"])) in
    (interface.get #"Then"%go (![#clientv3.Txn] "txn")) "$a0") in
    do:  ("txn" <-[#clientv3.Txn] "$r0");;;
    let: "terr" := (mem.alloc (type.zero_val #error)) in
    let: "tresp" := (mem.alloc (type.zero_val #ptrT)) in
    let: ("$ret0", "$ret1") := ((interface.get #"Commit"%go (![#clientv3.Txn] "txn")) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("tresp" <-[#ptrT] "$r0");;;
    do:  ("terr" <-[#error] "$r1");;;
    (if: (~ (interface.eq (![#error] "terr") #interface.nil))
    then return: (![#error] "terr")
    else do:  #());;;
    (if: (~ (![#boolT] (struct.field_ref #clientv3.TxnResponse #"Succeeded"%go (![#ptrT] "tresp"))))
    then
      let: "$r0" := #""%go in
      do:  ((struct.field_ref #Election #"leaderKey"%go (![#ptrT] "e")) <-[#stringT] "$r0");;;
      return: (![#error] (globals.get #ErrElectionNotLeader))
    else do:  #());;;
    let: "$r0" := (![#ptrT] (struct.field_ref #clientv3.TxnResponse #"Header"%go (![#ptrT] "tresp"))) in
    do:  ((struct.field_ref #Election #"hdr"%go (![#ptrT] "e")) <-[#ptrT] "$r0");;;
    return: (#interface.nil)).

(* Resign lets a leader start a new election.

   go: election.go:132:20 *)
Definition Election__Resignⁱᵐᵖˡ : val :=
  λ: "e" "ctx",
    exception_do (let: "err" := (mem.alloc (type.zero_val #error)) in
    let: "e" := (mem.alloc "e") in
    let: "ctx" := (mem.alloc "ctx") in
    (if: (![#ptrT] (struct.field_ref #Election #"leaderSession"%go (![#ptrT] "e"))) = #null
    then return: (#interface.nil)
    else do:  #());;;
    let: "client" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := ((method_call #concurrency.concurrency #"Session'ptr" #"Client" (![#ptrT] (struct.field_ref #Election #"session"%go (![#ptrT] "e")))) #()) in
    do:  ("client" <-[#ptrT] "$r0");;;
    let: "cmp" := (mem.alloc (type.zero_val #clientv3.Cmp)) in
    let: "$r0" := (let: "$a0" := (let: "$a0" := (![#stringT] (struct.field_ref #Election #"leaderKey"%go (![#ptrT] "e"))) in
    (func_call #clientv3.CreateRevision) "$a0") in
    let: "$a1" := #"="%go in
    let: "$a2" := (interface.make #int64Tⁱᵈ (![#int64T] (struct.field_ref #Election #"leaderRev"%go (![#ptrT] "e")))) in
    (func_call #clientv3.Compare) "$a0" "$a1" "$a2") in
    do:  ("cmp" <-[#clientv3.Cmp] "$r0");;;
    let: "resp" := (mem.alloc (type.zero_val #ptrT)) in
    let: ("$ret0", "$ret1") := ((interface.get #"Commit"%go (let: "$a0" := ((let: "$sl0" := (let: "$a0" := (![#stringT] (struct.field_ref #Election #"leaderKey"%go (![#ptrT] "e"))) in
    let: "$a1" := #slice.nil in
    (func_call #clientv3.OpDelete) "$a0" "$a1") in
    slice.literal #clientv3.Op ["$sl0"])) in
    (interface.get #"Then"%go (let: "$a0" := ((let: "$sl0" := (![#clientv3.Cmp] "cmp") in
    slice.literal #clientv3.Cmp ["$sl0"])) in
    (interface.get #"If"%go (let: "$a0" := (![#context.Context] "ctx") in
    (method_call #clientv3 #"Client'ptr" #"Txn" (![#ptrT] "client")) "$a0")) "$a0")) "$a0")) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("resp" <-[#ptrT] "$r0");;;
    do:  ("err" <-[#error] "$r1");;;
    (if: interface.eq (![#error] "err") #interface.nil
    then
      let: "$r0" := (![#ptrT] (struct.field_ref #clientv3.TxnResponse #"Header"%go (![#ptrT] "resp"))) in
      do:  ((struct.field_ref #Election #"hdr"%go (![#ptrT] "e")) <-[#ptrT] "$r0")
    else do:  #());;;
    let: "$r0" := #""%go in
    do:  ((struct.field_ref #Election #"leaderKey"%go (![#ptrT] "e")) <-[#stringT] "$r0");;;
    let: "$r0" := #null in
    do:  ((struct.field_ref #Election #"leaderSession"%go (![#ptrT] "e")) <-[#ptrT] "$r0");;;
    return: (![#error] "err")).

(* Leader returns the leader value for the current election.

   go: election.go:148:20 *)
Definition Election__Leaderⁱᵐᵖˡ : val :=
  λ: "e" "ctx",
    exception_do (let: "e" := (mem.alloc "e") in
    let: "ctx" := (mem.alloc "ctx") in
    let: "client" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := ((method_call #concurrency.concurrency #"Session'ptr" #"Client" (![#ptrT] (struct.field_ref #Election #"session"%go (![#ptrT] "e")))) #()) in
    do:  ("client" <-[#ptrT] "$r0");;;
    let: "err" := (mem.alloc (type.zero_val #error)) in
    let: "resp" := (mem.alloc (type.zero_val #ptrT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#context.Context] "ctx") in
    let: "$a1" := (![#stringT] (struct.field_ref #Election #"keyPrefix"%go (![#ptrT] "e"))) in
    let: "$a2" := ((func_call #clientv3.WithFirstCreate) #()) in
    (method_call #clientv3 #"Client'ptr" #"Get" (![#ptrT] "client")) "$a0" "$a1" "$a2") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("resp" <-[#ptrT] "$r0");;;
    do:  ("err" <-[#error] "$r1");;;
    (if: (~ (interface.eq (![#error] "err") #interface.nil))
    then return: (#null, ![#error] "err")
    else
      (if: (let: "$a0" := (![#sliceT] (struct.field_ref #clientv3.GetResponse #"Kvs"%go (![#ptrT] "resp"))) in
      slice.len "$a0") = #(W64 0)
      then return: (#null, ![#error] (globals.get #ErrElectionNoLeader))
      else do:  #()));;;
    return: (![#ptrT] "resp", #interface.nil)).

(* Observe returns a channel that reliably observes ordered leader proposals
   as GetResponse values on every current elected leader key. It will not
   necessarily fetch all historical leader updates, but will always post the
   most recent leader value.

   The channel closes when the context is canceled or the underlying watcher
   is otherwise disrupted.

   go: election.go:167:20 *)
Definition Election__Observeⁱᵐᵖˡ : val :=
  λ: "e" "ctx",
    exception_do (let: "e" := (mem.alloc "e") in
    let: "ctx" := (mem.alloc "ctx") in
    let: "retc" := (mem.alloc (type.zero_val (type.chanT #clientv3.GetResponse))) in
    let: "$r0" := (chan.make #clientv3.GetResponse #(W64 0)) in
    do:  ("retc" <-[type.chanT #clientv3.GetResponse] "$r0");;;
    let: "$a0" := (![#context.Context] "ctx") in
    let: "$a1" := (![type.chanT #clientv3.GetResponse] "retc") in
    let: "$go" := (method_call #concurrency.concurrency #"Election'ptr" #"observe" (![#ptrT] "e")) in
    do:  (Fork ("$go" "a0" "a1"));;;
    return: (![type.chanT #clientv3.GetResponse] "retc")).

(* go: election.go:173:20 *)
Definition Election__observeⁱᵐᵖˡ : val :=
  λ: "e" "ctx" "ch",
    with_defer: (let: "e" := (mem.alloc "e") in
    let: "ch" := (mem.alloc "ch") in
    let: "ctx" := (mem.alloc "ctx") in
    let: "client" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := ((method_call #concurrency.concurrency #"Session'ptr" #"Client" (![#ptrT] (struct.field_ref #Election #"session"%go (![#ptrT] "e")))) #()) in
    do:  ("client" <-[#ptrT] "$r0");;;
    do:  (let: "$a0" := (![type.chanT #clientv3.GetResponse] "ch") in
    let: "$f" := chan.close in
    "$defer" <-[#funcT] (let: "$oldf" := (![#funcT] "$defer") in
    (λ: <>,
      "$f" "$a0";;
      "$oldf" #()
      )));;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "err" := (mem.alloc (type.zero_val #error)) in
      let: "resp" := (mem.alloc (type.zero_val #ptrT)) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![#context.Context] "ctx") in
      let: "$a1" := (![#stringT] (struct.field_ref #Election #"keyPrefix"%go (![#ptrT] "e"))) in
      let: "$a2" := ((func_call #clientv3.WithFirstCreate) #()) in
      (method_call #clientv3 #"Client'ptr" #"Get" (![#ptrT] "client")) "$a0" "$a1" "$a2") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("resp" <-[#ptrT] "$r0");;;
      do:  ("err" <-[#error] "$r1");;;
      (if: (~ (interface.eq (![#error] "err") #interface.nil))
      then return: (#())
      else do:  #());;;
      let: "kv" := (mem.alloc (type.zero_val #ptrT)) in
      let: "hdr" := (mem.alloc (type.zero_val #ptrT)) in
      (if: (let: "$a0" := (![#sliceT] (struct.field_ref #clientv3.GetResponse #"Kvs"%go (![#ptrT] "resp"))) in
      slice.len "$a0") = #(W64 0)
      then
        let: "cancel" := (mem.alloc (type.zero_val #context.CancelFunc)) in
        let: "cctx" := (mem.alloc (type.zero_val #context.Context)) in
        let: ("$ret0", "$ret1") := (let: "$a0" := (![#context.Context] "ctx") in
        (func_call #context.WithCancel) "$a0") in
        let: "$r0" := "$ret0" in
        let: "$r1" := "$ret1" in
        do:  ("cctx" <-[#context.Context] "$r0");;;
        do:  ("cancel" <-[#context.CancelFunc] "$r1");;;
        let: "opts" := (mem.alloc (type.zero_val #sliceT)) in
        let: "$r0" := ((let: "$sl0" := (let: "$a0" := (![#int64T] (struct.field_ref #etcdserverpb.ResponseHeader #"Revision"%go (![#ptrT] (struct.field_ref #clientv3.GetResponse #"Header"%go (![#ptrT] "resp"))))) in
        (func_call #clientv3.WithRev) "$a0") in
        let: "$sl1" := ((func_call #clientv3.WithPrefix) #()) in
        slice.literal #clientv3.OpOption ["$sl0"; "$sl1"])) in
        do:  ("opts" <-[#sliceT] "$r0");;;
        let: "wch" := (mem.alloc (type.zero_val #clientv3.WatchChan)) in
        let: "$r0" := (let: "$a0" := (![#context.Context] "cctx") in
        let: "$a1" := (![#stringT] (struct.field_ref #Election #"keyPrefix"%go (![#ptrT] "e"))) in
        let: "$a2" := (![#sliceT] "opts") in
        (method_call #clientv3 #"Client'ptr" #"Watch" (![#ptrT] "client")) "$a0" "$a1" "$a2") in
        do:  ("wch" <-[#clientv3.WatchChan] "$r0");;;
        (for: (λ: <>, (![#ptrT] "kv") = #null); (λ: <>, #()) := λ: <>,
          let: "ok" := (mem.alloc (type.zero_val #boolT)) in
          let: "wr" := (mem.alloc (type.zero_val #clientv3.WatchResponse)) in
          let: ("$ret0", "$ret1") := (chan.receive (![#clientv3.WatchChan] "wch")) in
          let: "$r0" := "$ret0" in
          let: "$r1" := "$ret1" in
          do:  ("wr" <-[#clientv3.WatchResponse] "$r0");;;
          do:  ("ok" <-[#boolT] "$r1");;;
          (if: (~ (![#boolT] "ok")) || (~ (interface.eq ((method_call #clientv3 #"WatchResponse'ptr" #"Err" "wr") #()) #interface.nil))
          then
            do:  ((![#context.CancelFunc] "cancel") #());;;
            return: (#())
          else do:  #());;;
          let: "$range" := (![#sliceT] (struct.field_ref #clientv3.WatchResponse #"Events"%go "wr")) in
          (let: "ev" := (mem.alloc (type.zero_val #ptrT)) in
          slice.for_range #ptrT "$range" (λ: "$key" "$value",
            do:  ("ev" <-[#ptrT] "$value");;;
            do:  "$key";;;
            (if: (![#mvccpb.Event_EventType] (struct.field_ref #clientv3.Event #"Type"%go (![#ptrT] "ev"))) = mvccpb.PUT
            then
              let: "$r0" := (struct.field_ref #clientv3.WatchResponse #"Header"%go "wr") in
              let: "$r1" := (![#ptrT] (struct.field_ref #clientv3.Event #"Kv"%go (![#ptrT] "ev"))) in
              do:  ("hdr" <-[#ptrT] "$r0");;;
              do:  ("kv" <-[#ptrT] "$r1");;;
              let: "$r0" := (![#int64T] (struct.field_ref #mvccpb.KeyValue #"ModRevision"%go (![#ptrT] "kv"))) in
              do:  ((struct.field_ref #etcdserverpb.ResponseHeader #"Revision"%go (![#ptrT] "hdr")) <-[#int64T] "$r0");;;
              break: #()
            else do:  #()))));;;
        do:  ((![#context.CancelFunc] "cancel") #())
      else
        let: "$r0" := (![#ptrT] (struct.field_ref #clientv3.GetResponse #"Header"%go (![#ptrT] "resp"))) in
        let: "$r1" := (![#ptrT] (slice.elem_ref #ptrT (![#sliceT] (struct.field_ref #clientv3.GetResponse #"Kvs"%go (![#ptrT] "resp"))) #(W64 0))) in
        do:  ("hdr" <-[#ptrT] "$r0");;;
        do:  ("kv" <-[#ptrT] "$r1"));;;
      chan.select [chan.select_send (let: "$Header" := (![#ptrT] "hdr") in
       let: "$Kvs" := ((let: "$sl0" := (![#ptrT] "kv") in
       slice.literal #ptrT ["$sl0"])) in
       struct.make #clientv3.GetResponse [{
         "Header" ::= "$Header";
         "Kvs" ::= "$Kvs";
         "More" ::= type.zero_val #boolT;
         "Count" ::= type.zero_val #int64T;
         "XXX_NoUnkeyedLiteral" ::= type.zero_val (type.structT [
         ]);
         "XXX_unrecognized" ::= type.zero_val #sliceT;
         "XXX_sizecache" ::= type.zero_val #int32T
       }]) (![type.chanT #clientv3.GetResponse] "ch") (λ: <>,
         do:  #()
         ); chan.select_receive ((interface.get #"Done"%go (![#context.Context] "ctx")) #()) (λ: "$recvVal",
         return: (#())
         )] chan.select_no_default;;;
      let: "cancel" := (mem.alloc (type.zero_val #context.CancelFunc)) in
      let: "cctx" := (mem.alloc (type.zero_val #context.Context)) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![#context.Context] "ctx") in
      (func_call #context.WithCancel) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("cctx" <-[#context.Context] "$r0");;;
      do:  ("cancel" <-[#context.CancelFunc] "$r1");;;
      let: "wch" := (mem.alloc (type.zero_val #clientv3.WatchChan)) in
      let: "$r0" := (let: "$a0" := (![#context.Context] "cctx") in
      let: "$a1" := (string.from_bytes (![#sliceT] (struct.field_ref #mvccpb.KeyValue #"Key"%go (![#ptrT] "kv")))) in
      let: "$a2" := ((let: "$sl0" := (let: "$a0" := ((![#int64T] (struct.field_ref #etcdserverpb.ResponseHeader #"Revision"%go (![#ptrT] "hdr"))) + #(W64 1)) in
      (func_call #clientv3.WithRev) "$a0") in
      slice.literal #clientv3.OpOption ["$sl0"])) in
      (method_call #clientv3 #"Client'ptr" #"Watch" (![#ptrT] "client")) "$a0" "$a1" "$a2") in
      do:  ("wch" <-[#clientv3.WatchChan] "$r0");;;
      let: "keyDeleted" := (mem.alloc (type.zero_val #boolT)) in
      let: "$r0" := #false in
      do:  ("keyDeleted" <-[#boolT] "$r0");;;
      (for: (λ: <>, (~ (![#boolT] "keyDeleted"))); (λ: <>, #()) := λ: <>,
        let: "ok" := (mem.alloc (type.zero_val #boolT)) in
        let: "wr" := (mem.alloc (type.zero_val #clientv3.WatchResponse)) in
        let: ("$ret0", "$ret1") := (chan.receive (![#clientv3.WatchChan] "wch")) in
        let: "$r0" := "$ret0" in
        let: "$r1" := "$ret1" in
        do:  ("wr" <-[#clientv3.WatchResponse] "$r0");;;
        do:  ("ok" <-[#boolT] "$r1");;;
        (if: (~ (![#boolT] "ok"))
        then
          do:  ((![#context.CancelFunc] "cancel") #());;;
          return: (#())
        else do:  #());;;
        let: "$range" := (![#sliceT] (struct.field_ref #clientv3.WatchResponse #"Events"%go "wr")) in
        (let: "ev" := (mem.alloc (type.zero_val #ptrT)) in
        slice.for_range #ptrT "$range" (λ: "$key" "$value",
          do:  ("ev" <-[#ptrT] "$value");;;
          do:  "$key";;;
          (if: (![#mvccpb.Event_EventType] (struct.field_ref #clientv3.Event #"Type"%go (![#ptrT] "ev"))) = mvccpb.DELETE
          then
            let: "$r0" := #true in
            do:  ("keyDeleted" <-[#boolT] "$r0");;;
            break: #()
          else do:  #());;;
          let: "$r0" := (struct.field_ref #clientv3.WatchResponse #"Header"%go "wr") in
          do:  ((struct.field_ref #clientv3.GetResponse #"Header"%go (![#ptrT] "resp")) <-[#ptrT] "$r0");;;
          let: "$r0" := ((let: "$sl0" := (![#ptrT] (struct.field_ref #clientv3.Event #"Kv"%go (![#ptrT] "ev"))) in
          slice.literal #ptrT ["$sl0"])) in
          do:  ((struct.field_ref #clientv3.GetResponse #"Kvs"%go (![#ptrT] "resp")) <-[#sliceT] "$r0");;;
          chan.select [chan.select_send (![#clientv3.GetResponse] (![#ptrT] "resp")) (![type.chanT #clientv3.GetResponse] "ch") (λ: <>,
             do:  #()
             ); chan.select_receive ((interface.get #"Done"%go (![#context.Context] "cctx")) #()) (λ: "$recvVal",
             do:  ((![#context.CancelFunc] "cancel") #());;;
             return: (#())
             )] chan.select_no_default)));;;
      do:  ((![#context.CancelFunc] "cancel") #()));;;
    return: #()).

(* Key returns the leader key if elected, empty string otherwise.

   go: election.go:248:20 *)
Definition Election__Keyⁱᵐᵖˡ : val :=
  λ: "e" <>,
    exception_do (let: "e" := (mem.alloc "e") in
    return: (![#stringT] (struct.field_ref #Election #"leaderKey"%go (![#ptrT] "e")))).

(* Rev returns the leader key's creation revision, if elected.

   go: election.go:251:20 *)
Definition Election__Revⁱᵐᵖˡ : val :=
  λ: "e" <>,
    exception_do (let: "e" := (mem.alloc "e") in
    return: (![#int64T] (struct.field_ref #Election #"leaderRev"%go (![#ptrT] "e")))).

(* Header is the response header from the last successful election proposal.

   go: election.go:254:20 *)
Definition Election__Headerⁱᵐᵖˡ : val :=
  λ: "e" <>,
    exception_do (let: "e" := (mem.alloc "e") in
    return: (![#ptrT] (struct.field_ref #Election #"hdr"%go (![#ptrT] "e")))).

Definition waitDelete : go_string := "go.etcd.io/etcd/client/v3/concurrency.waitDelete"%go.

(* go: key.go:25:6 *)
Definition waitDeleteⁱᵐᵖˡ : val :=
  λ: "ctx" "client" "key" "rev",
    with_defer: (let: "rev" := (mem.alloc "rev") in
    let: "key" := (mem.alloc "key") in
    let: "client" := (mem.alloc "client") in
    let: "ctx" := (mem.alloc "ctx") in
    let: "cancel" := (mem.alloc (type.zero_val #context.CancelFunc)) in
    let: "cctx" := (mem.alloc (type.zero_val #context.Context)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#context.Context] "ctx") in
    (func_call #context.WithCancel) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("cctx" <-[#context.Context] "$r0");;;
    do:  ("cancel" <-[#context.CancelFunc] "$r1");;;
    do:  (let: "$f" := (![#context.CancelFunc] "cancel") in
    "$defer" <-[#funcT] (let: "$oldf" := (![#funcT] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    let: "wr" := (mem.alloc (type.zero_val #clientv3.WatchResponse)) in
    let: "wch" := (mem.alloc (type.zero_val #clientv3.WatchChan)) in
    let: "$r0" := (let: "$a0" := (![#context.Context] "cctx") in
    let: "$a1" := (![#stringT] "key") in
    let: "$a2" := ((let: "$sl0" := (let: "$a0" := (![#int64T] "rev") in
    (func_call #clientv3.WithRev) "$a0") in
    slice.literal #clientv3.OpOption ["$sl0"])) in
    (method_call #clientv3 #"Client'ptr" #"Watch" (![#ptrT] "client")) "$a0" "$a1" "$a2") in
    do:  ("wch" <-[#clientv3.WatchChan] "$r0");;;
    let: "$range" := (![#clientv3.WatchChan] "wch") in
    chan.for_range "$range" (λ: "$key",
      do:  ("wr" <-[#clientv3.WatchResponse] "$key");;;
      let: "$range" := (![#sliceT] (struct.field_ref #clientv3.WatchResponse #"Events"%go "wr")) in
      (let: "ev" := (mem.alloc (type.zero_val #ptrT)) in
      slice.for_range #ptrT "$range" (λ: "$key" "$value",
        do:  ("ev" <-[#ptrT] "$value");;;
        do:  "$key";;;
        (if: (![#mvccpb.Event_EventType] (struct.field_ref #clientv3.Event #"Type"%go (![#ptrT] "ev"))) = mvccpb.DELETE
        then return: (#interface.nil)
        else do:  #()))));;;
    (let: "err" := (mem.alloc (type.zero_val #error)) in
    let: "$r0" := ((method_call #clientv3 #"WatchResponse'ptr" #"Err" "wr") #()) in
    do:  ("err" <-[#error] "$r0");;;
    (if: (~ (interface.eq (![#error] "err") #interface.nil))
    then return: (![#error] "err")
    else do:  #()));;;
    (let: "err" := (mem.alloc (type.zero_val #error)) in
    let: "$r0" := ((interface.get #"Err"%go (![#context.Context] "ctx")) #()) in
    do:  ("err" <-[#error] "$r0");;;
    (if: (~ (interface.eq (![#error] "err") #interface.nil))
    then return: (![#error] "err")
    else do:  #()));;;
    return: (let: "$a0" := #"lost watcher waiting for delete"%go in
     (func_call #errors.New) "$a0")).

(* waitDeletes efficiently waits until all keys matching the prefix and no greater
   than the create revision are deleted.

   go: key.go:49:6 *)
Definition waitDeletesⁱᵐᵖˡ : val :=
  λ: "ctx" "client" "pfx" "maxCreateRev",
    exception_do (let: "maxCreateRev" := (mem.alloc "maxCreateRev") in
    let: "pfx" := (mem.alloc "pfx") in
    let: "client" := (mem.alloc "client") in
    let: "ctx" := (mem.alloc "ctx") in
    let: "getOpts" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := ((func_call #clientv3.WithLastCreate) #()) in
    let: "$a1" := ((let: "$sl0" := (let: "$a0" := (![#int64T] "maxCreateRev") in
    (func_call #clientv3.WithMaxCreateRev) "$a0") in
    slice.literal #clientv3.OpOption ["$sl0"])) in
    (slice.append #clientv3.OpOption) "$a0" "$a1") in
    do:  ("getOpts" <-[#sliceT] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      let: "err" := (mem.alloc (type.zero_val #error)) in
      let: "resp" := (mem.alloc (type.zero_val #ptrT)) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![#context.Context] "ctx") in
      let: "$a1" := (![#stringT] "pfx") in
      let: "$a2" := (![#sliceT] "getOpts") in
      (method_call #clientv3 #"Client'ptr" #"Get" (![#ptrT] "client")) "$a0" "$a1" "$a2") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("resp" <-[#ptrT] "$r0");;;
      do:  ("err" <-[#error] "$r1");;;
      (if: (~ (interface.eq (![#error] "err") #interface.nil))
      then return: (![#error] "err")
      else do:  #());;;
      (if: (let: "$a0" := (![#sliceT] (struct.field_ref #clientv3.GetResponse #"Kvs"%go (![#ptrT] "resp"))) in
      slice.len "$a0") = #(W64 0)
      then return: (#interface.nil)
      else do:  #());;;
      let: "lastKey" := (mem.alloc (type.zero_val #stringT)) in
      let: "$r0" := (string.from_bytes (![#sliceT] (struct.field_ref #mvccpb.KeyValue #"Key"%go (![#ptrT] (slice.elem_ref #ptrT (![#sliceT] (struct.field_ref #clientv3.GetResponse #"Kvs"%go (![#ptrT] "resp"))) #(W64 0)))))) in
      do:  ("lastKey" <-[#stringT] "$r0");;;
      (let: "$r0" := (let: "$a0" := (![#context.Context] "ctx") in
      let: "$a1" := (![#ptrT] "client") in
      let: "$a2" := (![#stringT] "lastKey") in
      let: "$a3" := (![#int64T] (struct.field_ref #etcdserverpb.ResponseHeader #"Revision"%go (![#ptrT] (struct.field_ref #clientv3.GetResponse #"Header"%go (![#ptrT] "resp"))))) in
      (func_call #waitDelete) "$a0" "$a1" "$a2" "$a3") in
      do:  ("err" <-[#error] "$r0");;;
      (if: (~ (interface.eq (![#error] "err") #interface.nil))
      then return: (![#error] "err")
      else do:  #())))).

Definition ErrLocked : go_string := "go.etcd.io/etcd/client/v3/concurrency.ErrLocked"%go.

Definition ErrSessionExpired : go_string := "go.etcd.io/etcd/client/v3/concurrency.ErrSessionExpired"%go.

Definition ErrLockReleased : go_string := "go.etcd.io/etcd/client/v3/concurrency.ErrLockReleased"%go.

Definition Mutex : go_type := structT [
  "s" :: ptrT;
  "pfx" :: stringT;
  "myKey" :: stringT;
  "myRev" :: int64T;
  "hdr" :: ptrT
].

Definition Mutexⁱᵈ : go_string := "go.etcd.io/etcd/client/v3/concurrency.Mutex"%go.

Definition NewMutex : go_string := "go.etcd.io/etcd/client/v3/concurrency.NewMutex"%go.

(* go: mutex.go:45:6 *)
Definition NewMutexⁱᵐᵖˡ : val :=
  λ: "s" "pfx",
    exception_do (let: "pfx" := (mem.alloc "pfx") in
    let: "s" := (mem.alloc "s") in
    return: (mem.alloc (struct.make #Mutex [{
       "s" ::= ![#ptrT] "s";
       "pfx" ::= (![#stringT] "pfx") + #"/"%go;
       "myKey" ::= #""%go;
       "myRev" ::= #(W64 (- 1));
       "hdr" ::= #null
     }]))).

(* TryLock locks the mutex if not already locked by another session.
   If lock is held by another session, return immediately after attempting necessary cleanup
   The ctx argument is used for the sending/receiving Txn RPC.

   go: mutex.go:52:17 *)
Definition Mutex__TryLockⁱᵐᵖˡ : val :=
  λ: "m" "ctx",
    exception_do (let: "m" := (mem.alloc "m") in
    let: "ctx" := (mem.alloc "ctx") in
    let: "err" := (mem.alloc (type.zero_val #error)) in
    let: "resp" := (mem.alloc (type.zero_val #ptrT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#context.Context] "ctx") in
    (method_call #concurrency.concurrency #"Mutex'ptr" #"tryAcquire" (![#ptrT] "m")) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("resp" <-[#ptrT] "$r0");;;
    do:  ("err" <-[#error] "$r1");;;
    (if: (~ (interface.eq (![#error] "err") #interface.nil))
    then return: (![#error] "err")
    else do:  #());;;
    let: "ownerKey" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] (struct.field_ref #etcdserverpb.RangeResponse #"Kvs"%go ((method_call #etcdserverpb #"ResponseOp'ptr" #"GetResponseRange" (![#ptrT] (slice.elem_ref #ptrT (![#sliceT] (struct.field_ref #clientv3.TxnResponse #"Responses"%go (![#ptrT] "resp"))) #(W64 1)))) #()))) in
    do:  ("ownerKey" <-[#sliceT] "$r0");;;
    (if: ((let: "$a0" := (![#sliceT] "ownerKey") in
    slice.len "$a0") = #(W64 0)) || ((![#int64T] (struct.field_ref #mvccpb.KeyValue #"CreateRevision"%go (![#ptrT] (slice.elem_ref #ptrT (![#sliceT] "ownerKey") #(W64 0))))) = (![#int64T] (struct.field_ref #Mutex #"myRev"%go (![#ptrT] "m"))))
    then
      let: "$r0" := (![#ptrT] (struct.field_ref #clientv3.TxnResponse #"Header"%go (![#ptrT] "resp"))) in
      do:  ((struct.field_ref #Mutex #"hdr"%go (![#ptrT] "m")) <-[#ptrT] "$r0");;;
      return: (#interface.nil)
    else do:  #());;;
    let: "client" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := ((method_call #concurrency.concurrency #"Session'ptr" #"Client" (![#ptrT] (struct.field_ref #Mutex #"s"%go (![#ptrT] "m")))) #()) in
    do:  ("client" <-[#ptrT] "$r0");;;
    (let: "err" := (mem.alloc (type.zero_val #error)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#context.Context] "ctx") in
    let: "$a1" := (![#stringT] (struct.field_ref #Mutex #"myKey"%go (![#ptrT] "m"))) in
    let: "$a2" := #slice.nil in
    (method_call #clientv3 #"Client'ptr" #"Delete" (![#ptrT] "client")) "$a0" "$a1" "$a2") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  "$r0";;;
    do:  ("err" <-[#error] "$r1");;;
    (if: (~ (interface.eq (![#error] "err") #interface.nil))
    then return: (![#error] "err")
    else do:  #()));;;
    let: "$r0" := #" "%go in
    do:  ((struct.field_ref #Mutex #"myKey"%go (![#ptrT] "m")) <-[#stringT] "$r0");;;
    let: "$r0" := #(W64 (- 1)) in
    do:  ((struct.field_ref #Mutex #"myRev"%go (![#ptrT] "m")) <-[#int64T] "$r0");;;
    return: (![#error] (globals.get #ErrLocked))).

(* Lock locks the mutex with a cancelable context. If the context is canceled
   while trying to acquire the lock, the mutex tries to clean its stale lock entry.

   go: mutex.go:75:17 *)
Definition Mutex__Lockⁱᵐᵖˡ : val :=
  λ: "m" "ctx",
    exception_do (let: "m" := (mem.alloc "m") in
    let: "ctx" := (mem.alloc "ctx") in
    let: "err" := (mem.alloc (type.zero_val #error)) in
    let: "resp" := (mem.alloc (type.zero_val #ptrT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#context.Context] "ctx") in
    (method_call #concurrency.concurrency #"Mutex'ptr" #"tryAcquire" (![#ptrT] "m")) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("resp" <-[#ptrT] "$r0");;;
    do:  ("err" <-[#error] "$r1");;;
    (if: (~ (interface.eq (![#error] "err") #interface.nil))
    then return: (![#error] "err")
    else do:  #());;;
    let: "ownerKey" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] (struct.field_ref #etcdserverpb.RangeResponse #"Kvs"%go ((method_call #etcdserverpb #"ResponseOp'ptr" #"GetResponseRange" (![#ptrT] (slice.elem_ref #ptrT (![#sliceT] (struct.field_ref #clientv3.TxnResponse #"Responses"%go (![#ptrT] "resp"))) #(W64 1)))) #()))) in
    do:  ("ownerKey" <-[#sliceT] "$r0");;;
    (if: ((let: "$a0" := (![#sliceT] "ownerKey") in
    slice.len "$a0") = #(W64 0)) || ((![#int64T] (struct.field_ref #mvccpb.KeyValue #"CreateRevision"%go (![#ptrT] (slice.elem_ref #ptrT (![#sliceT] "ownerKey") #(W64 0))))) = (![#int64T] (struct.field_ref #Mutex #"myRev"%go (![#ptrT] "m"))))
    then
      let: "$r0" := (![#ptrT] (struct.field_ref #clientv3.TxnResponse #"Header"%go (![#ptrT] "resp"))) in
      do:  ((struct.field_ref #Mutex #"hdr"%go (![#ptrT] "m")) <-[#ptrT] "$r0");;;
      return: (#interface.nil)
    else do:  #());;;
    let: "client" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := ((method_call #concurrency.concurrency #"Session'ptr" #"Client" (![#ptrT] (struct.field_ref #Mutex #"s"%go (![#ptrT] "m")))) #()) in
    do:  ("client" <-[#ptrT] "$r0");;;
    let: "werr" := (mem.alloc (type.zero_val #error)) in
    let: "$r0" := (let: "$a0" := (![#context.Context] "ctx") in
    let: "$a1" := (![#ptrT] "client") in
    let: "$a2" := (![#stringT] (struct.field_ref #Mutex #"pfx"%go (![#ptrT] "m"))) in
    let: "$a3" := ((![#int64T] (struct.field_ref #Mutex #"myRev"%go (![#ptrT] "m"))) - #(W64 1)) in
    (func_call #waitDeletes) "$a0" "$a1" "$a2" "$a3") in
    do:  ("werr" <-[#error] "$r0");;;
    (if: (~ (interface.eq (![#error] "werr") #interface.nil))
    then
      do:  (let: "$a0" := ((method_call #clientv3 #"Client'ptr" #"Ctx" (![#ptrT] "client")) #()) in
      (method_call #concurrency.concurrency #"Mutex'ptr" #"Unlock" (![#ptrT] "m")) "$a0");;;
      return: (![#error] "werr")
    else do:  #());;;
    let: "gresp" := (mem.alloc (type.zero_val #ptrT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#context.Context] "ctx") in
    let: "$a1" := (![#stringT] (struct.field_ref #Mutex #"myKey"%go (![#ptrT] "m"))) in
    let: "$a2" := #slice.nil in
    (method_call #clientv3 #"Client'ptr" #"Get" (![#ptrT] "client")) "$a0" "$a1" "$a2") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("gresp" <-[#ptrT] "$r0");;;
    do:  ("werr" <-[#error] "$r1");;;
    (if: (~ (interface.eq (![#error] "werr") #interface.nil))
    then
      do:  (let: "$a0" := ((method_call #clientv3 #"Client'ptr" #"Ctx" (![#ptrT] "client")) #()) in
      (method_call #concurrency.concurrency #"Mutex'ptr" #"Unlock" (![#ptrT] "m")) "$a0");;;
      return: (![#error] "werr")
    else do:  #());;;
    (if: (let: "$a0" := (![#sliceT] (struct.field_ref #clientv3.GetResponse #"Kvs"%go (![#ptrT] "gresp"))) in
    slice.len "$a0") = #(W64 0)
    then return: (![#error] (globals.get #ErrSessionExpired))
    else do:  #());;;
    let: "$r0" := (![#ptrT] (struct.field_ref #clientv3.GetResponse #"Header"%go (![#ptrT] "gresp"))) in
    do:  ((struct.field_ref #Mutex #"hdr"%go (![#ptrT] "m")) <-[#ptrT] "$r0");;;
    return: (#interface.nil)).

(* go: mutex.go:111:17 *)
Definition Mutex__tryAcquireⁱᵐᵖˡ : val :=
  λ: "m" "ctx",
    exception_do (let: "m" := (mem.alloc "m") in
    let: "ctx" := (mem.alloc "ctx") in
    let: "s" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (![#ptrT] (struct.field_ref #Mutex #"s"%go (![#ptrT] "m"))) in
    do:  ("s" <-[#ptrT] "$r0");;;
    let: "client" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := ((method_call #concurrency.concurrency #"Session'ptr" #"Client" (![#ptrT] (struct.field_ref #Mutex #"s"%go (![#ptrT] "m")))) #()) in
    do:  ("client" <-[#ptrT] "$r0");;;
    let: "$r0" := (let: "$a0" := #"%s%x"%go in
    let: "$a1" := ((let: "$sl0" := (interface.make #stringTⁱᵈ (![#stringT] (struct.field_ref #Mutex #"pfx"%go (![#ptrT] "m")))) in
    let: "$sl1" := (interface.make #clientv3.LeaseIDⁱᵈ ((method_call #concurrency.concurrency #"Session'ptr" #"Lease" (![#ptrT] "s")) #())) in
    slice.literal #interfaceT ["$sl0"; "$sl1"])) in
    (func_call #fmt.Sprintf) "$a0" "$a1") in
    do:  ((struct.field_ref #Mutex #"myKey"%go (![#ptrT] "m")) <-[#stringT] "$r0");;;
    let: "cmp" := (mem.alloc (type.zero_val #clientv3.Cmp)) in
    let: "$r0" := (let: "$a0" := (let: "$a0" := (![#stringT] (struct.field_ref #Mutex #"myKey"%go (![#ptrT] "m"))) in
    (func_call #clientv3.CreateRevision) "$a0") in
    let: "$a1" := #"="%go in
    let: "$a2" := (interface.make #intTⁱᵈ #(W64 0)) in
    (func_call #clientv3.Compare) "$a0" "$a1" "$a2") in
    do:  ("cmp" <-[#clientv3.Cmp] "$r0");;;
    let: "put" := (mem.alloc (type.zero_val #clientv3.Op)) in
    let: "$r0" := (let: "$a0" := (![#stringT] (struct.field_ref #Mutex #"myKey"%go (![#ptrT] "m"))) in
    let: "$a1" := #""%go in
    let: "$a2" := ((let: "$sl0" := (let: "$a0" := ((method_call #concurrency.concurrency #"Session'ptr" #"Lease" (![#ptrT] "s")) #()) in
    (func_call #clientv3.WithLease) "$a0") in
    slice.literal #clientv3.OpOption ["$sl0"])) in
    (func_call #clientv3.OpPut) "$a0" "$a1" "$a2") in
    do:  ("put" <-[#clientv3.Op] "$r0");;;
    let: "get" := (mem.alloc (type.zero_val #clientv3.Op)) in
    let: "$r0" := (let: "$a0" := (![#stringT] (struct.field_ref #Mutex #"myKey"%go (![#ptrT] "m"))) in
    let: "$a1" := #slice.nil in
    (func_call #clientv3.OpGet) "$a0" "$a1") in
    do:  ("get" <-[#clientv3.Op] "$r0");;;
    let: "getOwner" := (mem.alloc (type.zero_val #clientv3.Op)) in
    let: "$r0" := (let: "$a0" := (![#stringT] (struct.field_ref #Mutex #"pfx"%go (![#ptrT] "m"))) in
    let: "$a1" := ((func_call #clientv3.WithFirstCreate) #()) in
    (func_call #clientv3.OpGet) "$a0" "$a1") in
    do:  ("getOwner" <-[#clientv3.Op] "$r0");;;
    let: "err" := (mem.alloc (type.zero_val #error)) in
    let: "resp" := (mem.alloc (type.zero_val #ptrT)) in
    let: ("$ret0", "$ret1") := ((interface.get #"Commit"%go (let: "$a0" := ((let: "$sl0" := (![#clientv3.Op] "get") in
    let: "$sl1" := (![#clientv3.Op] "getOwner") in
    slice.literal #clientv3.Op ["$sl0"; "$sl1"])) in
    (interface.get #"Else"%go (let: "$a0" := ((let: "$sl0" := (![#clientv3.Op] "put") in
    let: "$sl1" := (![#clientv3.Op] "getOwner") in
    slice.literal #clientv3.Op ["$sl0"; "$sl1"])) in
    (interface.get #"Then"%go (let: "$a0" := ((let: "$sl0" := (![#clientv3.Cmp] "cmp") in
    slice.literal #clientv3.Cmp ["$sl0"])) in
    (interface.get #"If"%go (let: "$a0" := (![#context.Context] "ctx") in
    (method_call #clientv3 #"Client'ptr" #"Txn" (![#ptrT] "client")) "$a0")) "$a0")) "$a0")) "$a0")) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("resp" <-[#ptrT] "$r0");;;
    do:  ("err" <-[#error] "$r1");;;
    (if: (~ (interface.eq (![#error] "err") #interface.nil))
    then return: (#null, ![#error] "err")
    else do:  #());;;
    let: "$r0" := (![#int64T] (struct.field_ref #etcdserverpb.ResponseHeader #"Revision"%go (![#ptrT] (struct.field_ref #clientv3.TxnResponse #"Header"%go (![#ptrT] "resp"))))) in
    do:  ((struct.field_ref #Mutex #"myRev"%go (![#ptrT] "m")) <-[#int64T] "$r0");;;
    (if: (~ (![#boolT] (struct.field_ref #clientv3.TxnResponse #"Succeeded"%go (![#ptrT] "resp"))))
    then
      let: "$r0" := (![#int64T] (struct.field_ref #mvccpb.KeyValue #"CreateRevision"%go (![#ptrT] (slice.elem_ref #ptrT (![#sliceT] (struct.field_ref #etcdserverpb.RangeResponse #"Kvs"%go ((method_call #etcdserverpb #"ResponseOp'ptr" #"GetResponseRange" (![#ptrT] (slice.elem_ref #ptrT (![#sliceT] (struct.field_ref #clientv3.TxnResponse #"Responses"%go (![#ptrT] "resp"))) #(W64 0)))) #()))) #(W64 0))))) in
      do:  ((struct.field_ref #Mutex #"myRev"%go (![#ptrT] "m")) <-[#int64T] "$r0")
    else do:  #());;;
    return: (![#ptrT] "resp", #interface.nil)).

(* go: mutex.go:134:17 *)
Definition Mutex__Unlockⁱᵐᵖˡ : val :=
  λ: "m" "ctx",
    exception_do (let: "m" := (mem.alloc "m") in
    let: "ctx" := (mem.alloc "ctx") in
    (if: (((![#stringT] (struct.field_ref #Mutex #"myKey"%go (![#ptrT] "m"))) = #""%go) || (int_leq (![#int64T] (struct.field_ref #Mutex #"myRev"%go (![#ptrT] "m"))) #(W64 0))) || ((![#stringT] (struct.field_ref #Mutex #"myKey"%go (![#ptrT] "m"))) = #" "%go)
    then return: (![#error] (globals.get #ErrLockReleased))
    else do:  #());;;
    (if: (~ (let: "$a0" := (![#stringT] (struct.field_ref #Mutex #"myKey"%go (![#ptrT] "m"))) in
    let: "$a1" := (![#stringT] (struct.field_ref #Mutex #"pfx"%go (![#ptrT] "m"))) in
    (func_call #strings.HasPrefix) "$a0" "$a1"))
    then
      return: (let: "$a0" := #"invalid key %q, it should have prefix %q"%go in
       let: "$a1" := ((let: "$sl0" := (interface.make #stringTⁱᵈ (![#stringT] (struct.field_ref #Mutex #"myKey"%go (![#ptrT] "m")))) in
       let: "$sl1" := (interface.make #stringTⁱᵈ (![#stringT] (struct.field_ref #Mutex #"pfx"%go (![#ptrT] "m")))) in
       slice.literal #interfaceT ["$sl0"; "$sl1"])) in
       (func_call #fmt.Errorf) "$a0" "$a1")
    else do:  #());;;
    let: "client" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := ((method_call #concurrency.concurrency #"Session'ptr" #"Client" (![#ptrT] (struct.field_ref #Mutex #"s"%go (![#ptrT] "m")))) #()) in
    do:  ("client" <-[#ptrT] "$r0");;;
    (let: "err" := (mem.alloc (type.zero_val #error)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#context.Context] "ctx") in
    let: "$a1" := (![#stringT] (struct.field_ref #Mutex #"myKey"%go (![#ptrT] "m"))) in
    let: "$a2" := #slice.nil in
    (method_call #clientv3 #"Client'ptr" #"Delete" (![#ptrT] "client")) "$a0" "$a1" "$a2") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  "$r0";;;
    do:  ("err" <-[#error] "$r1");;;
    (if: (~ (interface.eq (![#error] "err") #interface.nil))
    then return: (![#error] "err")
    else do:  #()));;;
    let: "$r0" := #" "%go in
    do:  ((struct.field_ref #Mutex #"myKey"%go (![#ptrT] "m")) <-[#stringT] "$r0");;;
    let: "$r0" := #(W64 (- 1)) in
    do:  ((struct.field_ref #Mutex #"myRev"%go (![#ptrT] "m")) <-[#int64T] "$r0");;;
    return: (#interface.nil)).

(* go: mutex.go:152:17 *)
Definition Mutex__IsOwnerⁱᵐᵖˡ : val :=
  λ: "m" <>,
    exception_do (let: "m" := (mem.alloc "m") in
    return: (let: "$a0" := (let: "$a0" := (![#stringT] (struct.field_ref #Mutex #"myKey"%go (![#ptrT] "m"))) in
     (func_call #clientv3.CreateRevision) "$a0") in
     let: "$a1" := #"="%go in
     let: "$a2" := (interface.make #int64Tⁱᵈ (![#int64T] (struct.field_ref #Mutex #"myRev"%go (![#ptrT] "m")))) in
     (func_call #clientv3.Compare) "$a0" "$a1" "$a2")).

(* go: mutex.go:156:17 *)
Definition Mutex__Keyⁱᵐᵖˡ : val :=
  λ: "m" <>,
    exception_do (let: "m" := (mem.alloc "m") in
    return: (![#stringT] (struct.field_ref #Mutex #"myKey"%go (![#ptrT] "m")))).

(* Header is the response header received from etcd on acquiring the lock.

   go: mutex.go:159:17 *)
Definition Mutex__Headerⁱᵐᵖˡ : val :=
  λ: "m" <>,
    exception_do (let: "m" := (mem.alloc "m") in
    return: (![#ptrT] (struct.field_ref #Mutex #"hdr"%go (![#ptrT] "m")))).

Definition lockerMutex : go_type := structT [
  "Mutex" :: ptrT
].

Definition lockerMutexⁱᵈ : go_string := "go.etcd.io/etcd/client/v3/concurrency.lockerMutex"%go.

(* go: mutex.go:163:24 *)
Definition lockerMutex__Lockⁱᵐᵖˡ : val :=
  λ: "lm" <>,
    exception_do (let: "lm" := (mem.alloc "lm") in
    let: "client" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := ((method_call #concurrency.concurrency #"Session'ptr" #"Client" (![#ptrT] (struct.field_ref #Mutex #"s"%go (![#ptrT] (struct.field_ref #lockerMutex #"Mutex"%go (![#ptrT] "lm")))))) #()) in
    do:  ("client" <-[#ptrT] "$r0");;;
    (let: "err" := (mem.alloc (type.zero_val #error)) in
    let: "$r0" := (let: "$a0" := ((method_call #clientv3 #"Client'ptr" #"Ctx" (![#ptrT] "client")) #()) in
    (method_call #concurrency.concurrency #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref #lockerMutex #"Mutex"%go (![#ptrT] "lm")))) "$a0") in
    do:  ("err" <-[#error] "$r0");;;
    (if: (~ (interface.eq (![#error] "err") #interface.nil))
    then
      do:  (let: "$a0" := (![#error] "err") in
      Panic "$a0")
    else do:  #()));;;
    return: #()).

(* go: mutex.go:170:24 *)
Definition lockerMutex__Unlockⁱᵐᵖˡ : val :=
  λ: "lm" <>,
    exception_do (let: "lm" := (mem.alloc "lm") in
    let: "client" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := ((method_call #concurrency.concurrency #"Session'ptr" #"Client" (![#ptrT] (struct.field_ref #Mutex #"s"%go (![#ptrT] (struct.field_ref #lockerMutex #"Mutex"%go (![#ptrT] "lm")))))) #()) in
    do:  ("client" <-[#ptrT] "$r0");;;
    (let: "err" := (mem.alloc (type.zero_val #error)) in
    let: "$r0" := (let: "$a0" := ((method_call #clientv3 #"Client'ptr" #"Ctx" (![#ptrT] "client")) #()) in
    (method_call #concurrency.concurrency #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #lockerMutex #"Mutex"%go (![#ptrT] "lm")))) "$a0") in
    do:  ("err" <-[#error] "$r0");;;
    (if: (~ (interface.eq (![#error] "err") #interface.nil))
    then
      do:  (let: "$a0" := (![#error] "err") in
      Panic "$a0")
    else do:  #()));;;
    return: #()).

Definition NewLocker : go_string := "go.etcd.io/etcd/client/v3/concurrency.NewLocker"%go.

(* NewLocker creates a sync.Locker backed by an etcd mutex.

   go: mutex.go:178:6 *)
Definition NewLockerⁱᵐᵖˡ : val :=
  λ: "s" "pfx",
    exception_do (let: "pfx" := (mem.alloc "pfx") in
    let: "s" := (mem.alloc "s") in
    return: (interface.make #(ptrTⁱᵈ lockerMutexⁱᵈ) (mem.alloc (struct.make #lockerMutex [{
       "Mutex" ::= let: "$a0" := (![#ptrT] "s") in
       let: "$a1" := (![#stringT] "pfx") in
       (func_call #NewMutex) "$a0" "$a1"
     }])))).

Definition defaultSessionTTL : Z := 60.

Definition Sessionⁱᵈ : go_string := "go.etcd.io/etcd/client/v3/concurrency.Session"%go.

Definition NewSession : go_string := "go.etcd.io/etcd/client/v3/concurrency.NewSession"%go.

Definition sessionOptions : go_type := structT [
  "ttl" :: intT;
  "leaseID" :: clientv3.LeaseID;
  "ctx" :: context.Context
].

Definition SessionOption : go_type := funcT.

(* NewSession gets the leased session for a client.

   go: session.go:41:6 *)
Definition NewSessionⁱᵐᵖˡ : val :=
  λ: "client" "opts",
    exception_do (let: "opts" := (mem.alloc "opts") in
    let: "client" := (mem.alloc "client") in
    let: "lg" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := ((method_call #clientv3 #"Client'ptr" #"GetLogger" (![#ptrT] "client")) #()) in
    do:  ("lg" <-[#ptrT] "$r0");;;
    let: "ops" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (let: "$ttl" := #(W64 defaultSessionTTL) in
    let: "$ctx" := ((method_call #clientv3 #"Client'ptr" #"Ctx" (![#ptrT] "client")) #()) in
    struct.make #sessionOptions [{
      "ttl" ::= "$ttl";
      "leaseID" ::= type.zero_val #clientv3.LeaseID;
      "ctx" ::= "$ctx"
    }])) in
    do:  ("ops" <-[#ptrT] "$r0");;;
    let: "$range" := (![#sliceT] "opts") in
    (let: "opt" := (mem.alloc (type.zero_val #SessionOption)) in
    slice.for_range #SessionOption "$range" (λ: "$key" "$value",
      do:  ("opt" <-[#SessionOption] "$value");;;
      do:  "$key";;;
      do:  (let: "$a0" := (![#ptrT] "ops") in
      let: "$a1" := (![#ptrT] "lg") in
      (![#SessionOption] "opt") "$a0" "$a1")));;;
    let: "id" := (mem.alloc (type.zero_val #clientv3.LeaseID)) in
    let: "$r0" := (![#clientv3.LeaseID] (struct.field_ref #sessionOptions #"leaseID"%go (![#ptrT] "ops"))) in
    do:  ("id" <-[#clientv3.LeaseID] "$r0");;;
    (if: (![#clientv3.LeaseID] "id") = clientv3.NoLease
    then
      let: "err" := (mem.alloc (type.zero_val #error)) in
      let: "resp" := (mem.alloc (type.zero_val #ptrT)) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![#context.Context] (struct.field_ref #sessionOptions #"ctx"%go (![#ptrT] "ops"))) in
      let: "$a1" := (s_to_w64 (![#intT] (struct.field_ref #sessionOptions #"ttl"%go (![#ptrT] "ops")))) in
      (method_call #clientv3 #"Client'ptr" #"Grant" (![#ptrT] "client")) "$a0" "$a1") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("resp" <-[#ptrT] "$r0");;;
      do:  ("err" <-[#error] "$r1");;;
      (if: (~ (interface.eq (![#error] "err") #interface.nil))
      then return: (#null, ![#error] "err")
      else do:  #());;;
      let: "$r0" := (![#clientv3.LeaseID] (struct.field_ref #clientv3.LeaseGrantResponse #"ID"%go (![#ptrT] "resp"))) in
      do:  ("id" <-[#clientv3.LeaseID] "$r0")
    else do:  #());;;
    let: "cancel" := (mem.alloc (type.zero_val #context.CancelFunc)) in
    let: "ctx" := (mem.alloc (type.zero_val #context.Context)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#context.Context] (struct.field_ref #sessionOptions #"ctx"%go (![#ptrT] "ops"))) in
    (func_call #context.WithCancel) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("ctx" <-[#context.Context] "$r0");;;
    do:  ("cancel" <-[#context.CancelFunc] "$r1");;;
    let: "err" := (mem.alloc (type.zero_val #error)) in
    let: "keepAlive" := (mem.alloc (type.zero_val (type.chanT #ptrT))) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#context.Context] "ctx") in
    let: "$a1" := (![#clientv3.LeaseID] "id") in
    (method_call #clientv3 #"Client'ptr" #"KeepAlive" (![#ptrT] "client")) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("keepAlive" <-[type.chanT #ptrT] "$r0");;;
    do:  ("err" <-[#error] "$r1");;;
    (if: (~ (interface.eq (![#error] "err") #interface.nil)) || ((![type.chanT #ptrT] "keepAlive") = #null)
    then
      do:  ((![#context.CancelFunc] "cancel") #());;;
      return: (#null, ![#error] "err")
    else do:  #());;;
    let: "donec" := (mem.alloc (type.zero_val (type.chanT (type.structT [
    ])))) in
    let: "$r0" := (chan.make (type.structT [
    ]) #(W64 0)) in
    do:  ("donec" <-[type.chanT (type.structT [
    ])] "$r0");;;
    let: "s" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (let: "$client" := (![#ptrT] "client") in
    let: "$opts" := (![#ptrT] "ops") in
    let: "$id" := (![#clientv3.LeaseID] "id") in
    let: "$ctx" := (![#context.Context] "ctx") in
    let: "$cancel" := (![#context.CancelFunc] "cancel") in
    let: "$donec" := (![type.chanT (type.structT [
    ])] "donec") in
    struct.make #Session [{
      "client" ::= "$client";
      "opts" ::= "$opts";
      "id" ::= "$id";
      "ctx" ::= "$ctx";
      "cancel" ::= "$cancel";
      "donec" ::= "$donec"
    }])) in
    do:  ("s" <-[#ptrT] "$r0");;;
    let: "$go" := (λ: <>,
      with_defer: (do:  (let: "$f" := (λ: <>,
        exception_do (do:  (let: "$a0" := (![type.chanT (type.structT [
        ])] "donec") in
        chan.close "$a0");;;
        do:  ((![#context.CancelFunc] "cancel") #());;;
        return: #())
        ) in
      "$defer" <-[#funcT] (let: "$oldf" := (![#funcT] "$defer") in
      (λ: <>,
        "$f" #();;
        "$oldf" #()
        )));;;
      let: "$range" := (![type.chanT #ptrT] "keepAlive") in
      chan.for_range "$range" (λ: "$key",
        do:  #());;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    return: (![#ptrT] "s", #interface.nil)).

(* Client is the etcd client that is attached to the session.

   go: session.go:82:19 *)
Definition Session__Clientⁱᵐᵖˡ : val :=
  λ: "s" <>,
    exception_do (let: "s" := (mem.alloc "s") in
    return: (![#ptrT] (struct.field_ref #Session #"client"%go (![#ptrT] "s")))).

(* Lease is the lease ID for keys bound to the session.

   go: session.go:87:19 *)
Definition Session__Leaseⁱᵐᵖˡ : val :=
  λ: "s" <>,
    exception_do (let: "s" := (mem.alloc "s") in
    return: (![#clientv3.LeaseID] (struct.field_ref #Session #"id"%go (![#ptrT] "s")))).

(* Ctx is the context attached to the session, it is canceled when the lease is orphaned, expires, or
   is otherwise no longer being refreshed.

   go: session.go:91:19 *)
Definition Session__Ctxⁱᵐᵖˡ : val :=
  λ: "s" <>,
    exception_do (let: "s" := (mem.alloc "s") in
    return: (![#context.Context] (struct.field_ref #Session #"ctx"%go (![#ptrT] "s")))).

(* Done returns a channel that closes when the lease is orphaned, expires, or
   is otherwise no longer being refreshed.

   go: session.go:97:19 *)
Definition Session__Doneⁱᵐᵖˡ : val :=
  λ: "s" <>,
    exception_do (let: "s" := (mem.alloc "s") in
    return: (![type.chanT (type.structT [
     ])] (struct.field_ref #Session #"donec"%go (![#ptrT] "s")))).

(* Orphan ends the refresh for the session lease. This is useful
   in case the state of the client connection is indeterminate (revoke
   would fail) or when transferring lease ownership.

   go: session.go:102:19 *)
Definition Session__Orphanⁱᵐᵖˡ : val :=
  λ: "s" <>,
    exception_do (let: "s" := (mem.alloc "s") in
    do:  ((![#context.CancelFunc] (struct.field_ref #Session #"cancel"%go (![#ptrT] "s"))) #());;;
    do:  (Fst (chan.receive (![type.chanT (type.structT [
    ])] (struct.field_ref #Session #"donec"%go (![#ptrT] "s")))));;;
    return: #()).

(* Close orphans the session and revokes the session lease.

   go: session.go:108:19 *)
Definition Session__Closeⁱᵐᵖˡ : val :=
  λ: "s" <>,
    exception_do (let: "s" := (mem.alloc "s") in
    do:  ((method_call #concurrency.concurrency #"Session'ptr" #"Orphan" (![#ptrT] "s")) #());;;
    let: "cancel" := (mem.alloc (type.zero_val #context.CancelFunc)) in
    let: "ctx" := (mem.alloc (type.zero_val #context.Context)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#context.Context] (struct.field_ref #sessionOptions #"ctx"%go (![#ptrT] (struct.field_ref #Session #"opts"%go (![#ptrT] "s"))))) in
    let: "$a1" := ((s_to_w64 (![#intT] (struct.field_ref #sessionOptions #"ttl"%go (![#ptrT] (struct.field_ref #Session #"opts"%go (![#ptrT] "s")))))) * time.Second) in
    (func_call #context.WithTimeout) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("ctx" <-[#context.Context] "$r0");;;
    do:  ("cancel" <-[#context.CancelFunc] "$r1");;;
    let: "err" := (mem.alloc (type.zero_val #error)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#context.Context] "ctx") in
    let: "$a1" := (![#clientv3.LeaseID] (struct.field_ref #Session #"id"%go (![#ptrT] "s"))) in
    (method_call #clientv3 #"Client'ptr" #"Revoke" (![#ptrT] (struct.field_ref #Session #"client"%go (![#ptrT] "s")))) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  "$r0";;;
    do:  ("err" <-[#error] "$r1");;;
    do:  ((![#context.CancelFunc] "cancel") #());;;
    return: (![#error] "err")).

Definition sessionOptionsⁱᵈ : go_string := "go.etcd.io/etcd/client/v3/concurrency.sessionOptions"%go.

Definition SessionOptionⁱᵈ : go_string := "go.etcd.io/etcd/client/v3/concurrency.SessionOption"%go.

Definition WithTTL : go_string := "go.etcd.io/etcd/client/v3/concurrency.WithTTL"%go.

(* WithTTL configures the session's TTL in seconds.
   If TTL is <= 0, the default 60 seconds TTL will be used.

   go: session.go:128:6 *)
Definition WithTTLⁱᵐᵖˡ : val :=
  λ: "ttl",
    exception_do (let: "ttl" := (mem.alloc "ttl") in
    return: ((λ: "so" "lg",
       exception_do (let: "lg" := (mem.alloc "lg") in
       let: "so" := (mem.alloc "so") in
       (if: int_gt (![#intT] "ttl") #(W64 0)
       then
         let: "$r0" := (![#intT] "ttl") in
         do:  ((struct.field_ref #sessionOptions #"ttl"%go (![#ptrT] "so")) <-[#intT] "$r0")
       else
         do:  (let: "$a0" := #"WithTTL(): TTL should be > 0, preserving current TTL"%go in
         let: "$a1" := ((let: "$sl0" := (let: "$a0" := #"current-session-ttl"%go in
         let: "$a1" := (s_to_w64 (![#intT] (struct.field_ref #sessionOptions #"ttl"%go (![#ptrT] "so")))) in
         (func_call #zap.Int64) "$a0" "$a1") in
         slice.literal #zapcore.Field ["$sl0"])) in
         (method_call #zap #"Logger'ptr" #"Warn" (![#ptrT] "lg")) "$a0" "$a1"));;;
       return: #())
       ))).

Definition WithLease : go_string := "go.etcd.io/etcd/client/v3/concurrency.WithLease"%go.

(* WithLease specifies the existing leaseID to be used for the session.
   This is useful in process restart scenario, for example, to reclaim
   leadership from an election prior to restart.

   go: session.go:141:6 *)
Definition WithLeaseⁱᵐᵖˡ : val :=
  λ: "leaseID",
    exception_do (let: "leaseID" := (mem.alloc "leaseID") in
    return: ((λ: "so" <>,
       exception_do (let: "so" := (mem.alloc "so") in
       let: "$r0" := (![#clientv3.LeaseID] "leaseID") in
       do:  ((struct.field_ref #sessionOptions #"leaseID"%go (![#ptrT] "so")) <-[#clientv3.LeaseID] "$r0");;;
       return: #())
       ))).

Definition WithContext : go_string := "go.etcd.io/etcd/client/v3/concurrency.WithContext"%go.

(* WithContext assigns a context to the session instead of defaulting to
   using the client context. This is useful for canceling NewSession and
   Close operations immediately without having to close the client. If the
   context is canceled before Close() completes, the session's lease will be
   abandoned and left to expire instead of being revoked.

   go: session.go:152:6 *)
Definition WithContextⁱᵐᵖˡ : val :=
  λ: "ctx",
    exception_do (let: "ctx" := (mem.alloc "ctx") in
    return: ((λ: "so" <>,
       exception_do (let: "so" := (mem.alloc "so") in
       let: "$r0" := (![#context.Context] "ctx") in
       do:  ((struct.field_ref #sessionOptions #"ctx"%go (![#ptrT] "so")) <-[#context.Context] "$r0");;;
       return: #())
       ))).

Definition STM : go_type := interfaceT.

Definition STMⁱᵈ : go_string := "go.etcd.io/etcd/client/v3/concurrency.STM"%go.

Definition Isolation : go_type := intT.

Definition Isolationⁱᵈ : go_string := "go.etcd.io/etcd/client/v3/concurrency.Isolation"%go.

Definition SerializableSnapshot : expr := #(W64 0).

Definition Serializable : expr := #(W64 1).

Definition RepeatableReads : expr := #(W64 2).

Definition ReadCommitted : expr := #(W64 3).

Definition stmError : go_type := structT [
  "err" :: error
].

Definition stmErrorⁱᵈ : go_string := "go.etcd.io/etcd/client/v3/concurrency.stmError"%go.

Definition stmOptions : go_type := structT [
  "iso" :: Isolation;
  "ctx" :: context.Context;
  "prefetch" :: sliceT
].

Definition stmOptionsⁱᵈ : go_string := "go.etcd.io/etcd/client/v3/concurrency.stmOptions"%go.

Definition stmOption : go_type := funcT.

Definition stmOptionⁱᵈ : go_string := "go.etcd.io/etcd/client/v3/concurrency.stmOption"%go.

Definition WithIsolation : go_string := "go.etcd.io/etcd/client/v3/concurrency.WithIsolation"%go.

(* WithIsolation specifies the transaction isolation level.

   go: stm.go:71:6 *)
Definition WithIsolationⁱᵐᵖˡ : val :=
  λ: "lvl",
    exception_do (let: "lvl" := (mem.alloc "lvl") in
    return: ((λ: "so",
       exception_do (let: "so" := (mem.alloc "so") in
       let: "$r0" := (![#Isolation] "lvl") in
       do:  ((struct.field_ref #stmOptions #"iso"%go (![#ptrT] "so")) <-[#Isolation] "$r0");;;
       return: #())
       ))).

Definition WithAbortContext : go_string := "go.etcd.io/etcd/client/v3/concurrency.WithAbortContext"%go.

(* WithAbortContext specifies the context for permanently aborting the transaction.

   go: stm.go:76:6 *)
Definition WithAbortContextⁱᵐᵖˡ : val :=
  λ: "ctx",
    exception_do (let: "ctx" := (mem.alloc "ctx") in
    return: ((λ: "so",
       exception_do (let: "so" := (mem.alloc "so") in
       let: "$r0" := (![#context.Context] "ctx") in
       do:  ((struct.field_ref #stmOptions #"ctx"%go (![#ptrT] "so")) <-[#context.Context] "$r0");;;
       return: #())
       ))).

Definition WithPrefetch : go_string := "go.etcd.io/etcd/client/v3/concurrency.WithPrefetch"%go.

(* WithPrefetch is a hint to prefetch a list of keys before trying to apply.
   If an STM transaction will unconditionally fetch a set of keys, prefetching
   those keys will save the round-trip cost from requesting each key one by one
   with Get().

   go: stm.go:84:6 *)
Definition WithPrefetchⁱᵐᵖˡ : val :=
  λ: "keys",
    exception_do (let: "keys" := (mem.alloc "keys") in
    return: ((λ: "so",
       exception_do (let: "so" := (mem.alloc "so") in
       let: "$r0" := (let: "$a0" := (![#sliceT] (struct.field_ref #stmOptions #"prefetch"%go (![#ptrT] "so"))) in
       let: "$a1" := (![#sliceT] "keys") in
       (slice.append #stringT) "$a0" "$a1") in
       do:  ((struct.field_ref #stmOptions #"prefetch"%go (![#ptrT] "so")) <-[#sliceT] "$r0");;;
       return: #())
       ))).

Definition NewSTM : go_string := "go.etcd.io/etcd/client/v3/concurrency.NewSTM"%go.

Definition runSTM : go_string := "go.etcd.io/etcd/client/v3/concurrency.runSTM"%go.

Definition mkSTM : go_string := "go.etcd.io/etcd/client/v3/concurrency.mkSTM"%go.

(* NewSTM initiates a new STM instance, using serializable snapshot isolation by default.

   go: stm.go:89:6 *)
Definition NewSTMⁱᵐᵖˡ : val :=
  λ: "c" "apply" "so",
    exception_do (let: "so" := (mem.alloc "so") in
    let: "apply" := (mem.alloc "apply") in
    let: "c" := (mem.alloc "c") in
    let: "opts" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (let: "$ctx" := ((method_call #clientv3 #"Client'ptr" #"Ctx" (![#ptrT] "c")) #()) in
    struct.make #stmOptions [{
      "iso" ::= type.zero_val #Isolation;
      "ctx" ::= "$ctx";
      "prefetch" ::= type.zero_val #sliceT
    }])) in
    do:  ("opts" <-[#ptrT] "$r0");;;
    let: "$range" := (![#sliceT] "so") in
    (let: "f" := (mem.alloc (type.zero_val #stmOption)) in
    slice.for_range #stmOption "$range" (λ: "$key" "$value",
      do:  ("f" <-[#stmOption] "$value");;;
      do:  "$key";;;
      do:  (let: "$a0" := (![#ptrT] "opts") in
      (![#stmOption] "f") "$a0")));;;
    (if: (let: "$a0" := (![#sliceT] (struct.field_ref #stmOptions #"prefetch"%go (![#ptrT] "opts"))) in
    slice.len "$a0") ≠ #(W64 0)
    then
      let: "f" := (mem.alloc (type.zero_val #funcT)) in
      let: "$r0" := (![#funcT] "apply") in
      do:  ("f" <-[#funcT] "$r0");;;
      let: "$r0" := (λ: "s",
        exception_do (let: "s" := (mem.alloc "s") in
        do:  (let: "$a0" := (![#sliceT] (struct.field_ref #stmOptions #"prefetch"%go (![#ptrT] "opts"))) in
        (interface.get #"Get"%go (![#STM] "s")) "$a0");;;
        return: (let: "$a0" := (![#STM] "s") in
         (![#funcT] "f") "$a0"))
        ) in
      do:  ("apply" <-[#funcT] "$r0")
    else do:  #());;;
    let: ("$ret0", "$ret1") := ((let: "$a0" := (let: "$a0" := (![#ptrT] "c") in
    let: "$a1" := (![#ptrT] "opts") in
    (func_call #mkSTM) "$a0" "$a1") in
    let: "$a1" := (![#funcT] "apply") in
    (func_call #runSTM) "$a0" "$a1")) in
    return: ("$ret0", "$ret1")).

Definition stmⁱᵈ : go_string := "go.etcd.io/etcd/client/v3/concurrency.stm"%go.

Definition readSet : go_type := mapT stringT ptrT.

Definition stmPut : go_type := structT [
  "val" :: stringT;
  "op" :: clientv3.Op
].

Definition writeSet : go_type := mapT stringT stmPut.

Definition stm : go_type := structT [
  "client" :: ptrT;
  "ctx" :: context.Context;
  "rset" :: readSet;
  "wset" :: writeSet;
  "getOpts" :: sliceT;
  "conflicts" :: funcT
].

Definition stmSerializableⁱᵈ : go_string := "go.etcd.io/etcd/client/v3/concurrency.stmSerializable"%go.

Definition stmSerializable : go_type := structT [
  "stm" :: stm;
  "prefetch" :: mapT stringT ptrT
].

(* go: stm.go:104:6 *)
Definition mkSTMⁱᵐᵖˡ : val :=
  λ: "c" "opts",
    exception_do (let: "opts" := (mem.alloc "opts") in
    let: "c" := (mem.alloc "c") in
    let: "$sw" := (![#Isolation] (struct.field_ref #stmOptions #"iso"%go (![#ptrT] "opts"))) in
    (if: "$sw" = SerializableSnapshot
    then
      let: "s" := (mem.alloc (type.zero_val #ptrT)) in
      let: "$r0" := (mem.alloc (let: "$stm" := (let: "$client" := (![#ptrT] "c") in
      let: "$ctx" := (![#context.Context] (struct.field_ref #stmOptions #"ctx"%go (![#ptrT] "opts"))) in
      struct.make #stm [{
        "client" ::= "$client";
        "ctx" ::= "$ctx";
        "rset" ::= type.zero_val #readSet;
        "wset" ::= type.zero_val #writeSet;
        "getOpts" ::= type.zero_val #sliceT;
        "conflicts" ::= type.zero_val #funcT
      }]) in
      let: "$prefetch" := (map.make #stringT #ptrT) in
      struct.make #stmSerializable [{
        "stm" ::= "$stm";
        "prefetch" ::= "$prefetch"
      }])) in
      do:  ("s" <-[#ptrT] "$r0");;;
      let: "$r0" := (λ: <>,
        exception_do (return: (let: "$a0" := ((method_call #concurrency.concurrency #"readSet" #"cmps" (![#readSet] (struct.field_ref #stm #"rset"%go (struct.field_ref #stmSerializable #"stm"%go (![#ptrT] "s"))))) #()) in
         let: "$a1" := (let: "$a0" := (((method_call #concurrency.concurrency #"readSet" #"first" (![#readSet] (struct.field_ref #stm #"rset"%go (struct.field_ref #stmSerializable #"stm"%go (![#ptrT] "s"))))) #()) + #(W64 1)) in
         (method_call #concurrency.concurrency #"writeSet" #"cmps" (![#writeSet] (struct.field_ref #stm #"wset"%go (struct.field_ref #stmSerializable #"stm"%go (![#ptrT] "s"))))) "$a0") in
         (slice.append #clientv3.Cmp) "$a0" "$a1"))
        ) in
      do:  ((struct.field_ref #stm #"conflicts"%go (struct.field_ref #stmSerializable #"stm"%go (![#ptrT] "s"))) <-[#funcT] "$r0");;;
      return: (interface.make #(ptrTⁱᵈ stmSerializableⁱᵈ) (![#ptrT] "s"))
    else
      (if: "$sw" = Serializable
      then
        let: "s" := (mem.alloc (type.zero_val #ptrT)) in
        let: "$r0" := (mem.alloc (let: "$stm" := (let: "$client" := (![#ptrT] "c") in
        let: "$ctx" := (![#context.Context] (struct.field_ref #stmOptions #"ctx"%go (![#ptrT] "opts"))) in
        struct.make #stm [{
          "client" ::= "$client";
          "ctx" ::= "$ctx";
          "rset" ::= type.zero_val #readSet;
          "wset" ::= type.zero_val #writeSet;
          "getOpts" ::= type.zero_val #sliceT;
          "conflicts" ::= type.zero_val #funcT
        }]) in
        let: "$prefetch" := (map.make #stringT #ptrT) in
        struct.make #stmSerializable [{
          "stm" ::= "$stm";
          "prefetch" ::= "$prefetch"
        }])) in
        do:  ("s" <-[#ptrT] "$r0");;;
        let: "$r0" := (λ: <>,
          exception_do (return: ((method_call #concurrency.concurrency #"readSet" #"cmps" (![#readSet] (struct.field_ref #stm #"rset"%go (struct.field_ref #stmSerializable #"stm"%go (![#ptrT] "s"))))) #()))
          ) in
        do:  ((struct.field_ref #stm #"conflicts"%go (struct.field_ref #stmSerializable #"stm"%go (![#ptrT] "s"))) <-[#funcT] "$r0");;;
        return: (interface.make #(ptrTⁱᵈ stmSerializableⁱᵈ) (![#ptrT] "s"))
      else
        (if: "$sw" = RepeatableReads
        then
          let: "s" := (mem.alloc (type.zero_val #ptrT)) in
          let: "$r0" := (mem.alloc (let: "$client" := (![#ptrT] "c") in
          let: "$ctx" := (![#context.Context] (struct.field_ref #stmOptions #"ctx"%go (![#ptrT] "opts"))) in
          let: "$getOpts" := ((let: "$sl0" := ((func_call #clientv3.WithSerializable) #()) in
          slice.literal #clientv3.OpOption ["$sl0"])) in
          struct.make #stm [{
            "client" ::= "$client";
            "ctx" ::= "$ctx";
            "rset" ::= type.zero_val #readSet;
            "wset" ::= type.zero_val #writeSet;
            "getOpts" ::= "$getOpts";
            "conflicts" ::= type.zero_val #funcT
          }])) in
          do:  ("s" <-[#ptrT] "$r0");;;
          let: "$r0" := (λ: <>,
            exception_do (return: ((method_call #concurrency.concurrency #"readSet" #"cmps" (![#readSet] (struct.field_ref #stm #"rset"%go (![#ptrT] "s")))) #()))
            ) in
          do:  ((struct.field_ref #stm #"conflicts"%go (![#ptrT] "s")) <-[#funcT] "$r0");;;
          return: (interface.make #(ptrTⁱᵈ stmⁱᵈ) (![#ptrT] "s"))
        else
          (if: "$sw" = ReadCommitted
          then
            let: "s" := (mem.alloc (type.zero_val #ptrT)) in
            let: "$r0" := (mem.alloc (let: "$client" := (![#ptrT] "c") in
            let: "$ctx" := (![#context.Context] (struct.field_ref #stmOptions #"ctx"%go (![#ptrT] "opts"))) in
            let: "$getOpts" := ((let: "$sl0" := ((func_call #clientv3.WithSerializable) #()) in
            slice.literal #clientv3.OpOption ["$sl0"])) in
            struct.make #stm [{
              "client" ::= "$client";
              "ctx" ::= "$ctx";
              "rset" ::= type.zero_val #readSet;
              "wset" ::= type.zero_val #writeSet;
              "getOpts" ::= "$getOpts";
              "conflicts" ::= type.zero_val #funcT
            }])) in
            do:  ("s" <-[#ptrT] "$r0");;;
            let: "$r0" := (λ: <>,
              exception_do (return: (#slice.nil))
              ) in
            do:  ((struct.field_ref #stm #"conflicts"%go (![#ptrT] "s")) <-[#funcT] "$r0");;;
            return: (interface.make #(ptrTⁱᵈ stmⁱᵈ) (![#ptrT] "s"))
          else
            do:  (let: "$a0" := (interface.make #stringTⁱᵈ #"unsupported stm"%go) in
            Panic "$a0")))))).

Definition stmResponse : go_type := structT [
  "resp" :: ptrT;
  "err" :: error
].

Definition stmResponseⁱᵈ : go_string := "go.etcd.io/etcd/client/v3/concurrency.stmResponse"%go.

(* go: stm.go:140:6 *)
Definition runSTMⁱᵐᵖˡ : val :=
  λ: "s" "apply",
    exception_do (let: "apply" := (mem.alloc "apply") in
    let: "s" := (mem.alloc "s") in
    let: "outc" := (mem.alloc (type.zero_val (type.chanT #stmResponse))) in
    let: "$r0" := (chan.make #stmResponse #(W64 1)) in
    do:  ("outc" <-[type.chanT #stmResponse] "$r0");;;
    let: "$go" := (λ: <>,
      with_defer: (do:  (let: "$f" := (λ: <>,
        exception_do ((let: "r" := (mem.alloc (type.zero_val #interfaceT)) in
        let: "$r0" := (recover #()) in
        do:  ("r" <-[#interfaceT] "$r0");;;
        (if: (~ (interface.eq (![#interfaceT] "r") #interface.nil))
        then
          let: "ok" := (mem.alloc (type.zero_val #boolT)) in
          let: "e" := (mem.alloc (type.zero_val #stmError)) in
          let: ("$ret0", "$ret1") := (interface.checked_type_assert #stmError (![#interfaceT] "r") #stmErrorⁱᵈ) in
          let: "$r0" := "$ret0" in
          let: "$r1" := "$ret1" in
          do:  ("e" <-[#stmError] "$r0");;;
          do:  ("ok" <-[#boolT] "$r1");;;
          (if: (~ (![#boolT] "ok"))
          then
            do:  (let: "$a0" := (![#interfaceT] "r") in
            Panic "$a0")
          else do:  #());;;
          do:  (let: "$chan" := (![type.chanT #stmResponse] "outc") in
          let: "$v" := (struct.make #stmResponse [{
            "resp" ::= #null;
            "err" ::= ![#error] (struct.field_ref #stmError #"err"%go "e")
          }]) in
          chan.send "$chan" "$v")
        else do:  #()));;;
        return: #())
        ) in
      "$defer" <-[#funcT] (let: "$oldf" := (![#funcT] "$defer") in
      (λ: <>,
        "$f" #();;
        "$oldf" #()
        )));;;
      let: "out" := (mem.alloc (type.zero_val #stmResponse)) in
      (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
        do:  ((interface.get #"reset"%go (![#STM] "s")) #());;;
        (let: "$r0" := (let: "$a0" := (![#STM] "s") in
        (![#funcT] "apply") "$a0") in
        do:  ((struct.field_ref #stmResponse #"err"%go "out") <-[#error] "$r0");;;
        (if: (~ (interface.eq (![#error] (struct.field_ref #stmResponse #"err"%go "out")) #interface.nil))
        then break: #()
        else do:  #()));;;
        (let: "$r0" := ((interface.get #"commit"%go (![#STM] "s")) #()) in
        do:  ((struct.field_ref #stmResponse #"resp"%go "out") <-[#ptrT] "$r0");;;
        (if: (![#ptrT] (struct.field_ref #stmResponse #"resp"%go "out")) ≠ #null
        then break: #()
        else do:  #())));;;
      do:  (let: "$chan" := (![type.chanT #stmResponse] "outc") in
      let: "$v" := (![#stmResponse] "out") in
      chan.send "$chan" "$v");;;
      return: #())
      ) in
    do:  (Fork ("$go" #()));;;
    let: "r" := (mem.alloc (type.zero_val #stmResponse)) in
    let: "$r0" := (Fst (chan.receive (![type.chanT #stmResponse] "outc"))) in
    do:  ("r" <-[#stmResponse] "$r0");;;
    return: (![#ptrT] (struct.field_ref #stmResponse #"resp"%go "r"), ![#error] (struct.field_ref #stmResponse #"err"%go "r"))).

Definition stmPutⁱᵈ : go_string := "go.etcd.io/etcd/client/v3/concurrency.stmPut"%go.

Definition readSetⁱᵈ : go_string := "go.etcd.io/etcd/client/v3/concurrency.readSet"%go.

(* go: stm.go:190:19 *)
Definition readSet__addⁱᵐᵖˡ : val :=
  λ: "rs" "keys" "txnresp",
    exception_do (let: "rs" := (mem.alloc "rs") in
    let: "txnresp" := (mem.alloc "txnresp") in
    let: "keys" := (mem.alloc "keys") in
    let: "$range" := (![#sliceT] (struct.field_ref #clientv3.TxnResponse #"Responses"%go (![#ptrT] "txnresp"))) in
    (let: "resp" := (mem.alloc (type.zero_val #ptrT)) in
    let: "i" := (mem.alloc (type.zero_val #intT)) in
    slice.for_range #ptrT "$range" (λ: "$key" "$value",
      do:  ("resp" <-[#ptrT] "$value");;;
      do:  ("i" <-[#intT] "$key");;;
      let: "$r0" := ((method_call #etcdserverpb #"ResponseOp'ptr" #"GetResponseRange" (![#ptrT] "resp")) #()) in
      do:  (map.insert (![#readSet] "rs") (![#stringT] (slice.elem_ref #stringT (![#sliceT] "keys") (![#intT] "i"))) "$r0")));;;
    return: #()).

(* first returns the store revision from the first fetch

   go: stm.go:197:19 *)
Definition readSet__firstⁱᵐᵖˡ : val :=
  λ: "rs" <>,
    exception_do (let: "rs" := (mem.alloc "rs") in
    let: "ret" := (mem.alloc (type.zero_val #int64T)) in
    let: "$r0" := #(W64 (math.MaxInt64 - 1)) in
    do:  ("ret" <-[#int64T] "$r0");;;
    let: "$range" := (![#readSet] "rs") in
    (let: "resp" := (mem.alloc (type.zero_val #ptrT)) in
    map.for_range "$range" (λ: "$key" "value",
      do:  ("resp" <-[#ptrT] "$value");;;
      do:  "$key";;;
      (let: "rev" := (mem.alloc (type.zero_val #int64T)) in
      let: "$r0" := (![#int64T] (struct.field_ref #etcdserverpb.ResponseHeader #"Revision"%go (![#ptrT] (struct.field_ref #clientv3.GetResponse #"Header"%go (![#ptrT] "resp"))))) in
      do:  ("rev" <-[#int64T] "$r0");;;
      (if: int_lt (![#int64T] "rev") (![#int64T] "ret")
      then
        let: "$r0" := (![#int64T] "rev") in
        do:  ("ret" <-[#int64T] "$r0")
      else do:  #()))));;;
    return: (![#int64T] "ret")).

Definition isKeyCurrent : go_string := "go.etcd.io/etcd/client/v3/concurrency.isKeyCurrent"%go.

(* cmps guards the txn from updates to read set

   go: stm.go:208:19 *)
Definition readSet__cmpsⁱᵐᵖˡ : val :=
  λ: "rs" <>,
    exception_do (let: "rs" := (mem.alloc "rs") in
    let: "cmps" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make3 #clientv3.Cmp #(W64 0) (let: "$a0" := (![#readSet] "rs") in
    map.len "$a0")) in
    do:  ("cmps" <-[#sliceT] "$r0");;;
    let: "$range" := (![#readSet] "rs") in
    (let: "rk" := (mem.alloc (type.zero_val #ptrT)) in
    let: "k" := (mem.alloc (type.zero_val #stringT)) in
    map.for_range "$range" (λ: "$key" "value",
      do:  ("rk" <-[#ptrT] "$value");;;
      do:  ("k" <-[#stringT] "$key");;;
      let: "$r0" := (let: "$a0" := (![#sliceT] "cmps") in
      let: "$a1" := ((let: "$sl0" := (let: "$a0" := (![#stringT] "k") in
      let: "$a1" := (![#ptrT] "rk") in
      (func_call #isKeyCurrent) "$a0" "$a1") in
      slice.literal #clientv3.Cmp ["$sl0"])) in
      (slice.append #clientv3.Cmp) "$a0" "$a1") in
      do:  ("cmps" <-[#sliceT] "$r0")));;;
    return: (![#sliceT] "cmps")).

Definition writeSetⁱᵈ : go_string := "go.etcd.io/etcd/client/v3/concurrency.writeSet"%go.

(* go: stm.go:218:20 *)
Definition writeSet__getⁱᵐᵖˡ : val :=
  λ: "ws" "keys",
    exception_do (let: "ws" := (mem.alloc "ws") in
    let: "keys" := (mem.alloc "keys") in
    let: "$range" := (![#sliceT] "keys") in
    (let: "key" := (mem.alloc (type.zero_val #stringT)) in
    slice.for_range #stringT "$range" (λ: "$key" "$value",
      do:  ("key" <-[#stringT] "$value");;;
      do:  "$key";;;
      (let: "ok" := (mem.alloc (type.zero_val #boolT)) in
      let: "wv" := (mem.alloc (type.zero_val #stmPut)) in
      let: ("$ret0", "$ret1") := (map.get (![#writeSet] "ws") (![#stringT] "key")) in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("wv" <-[#stmPut] "$r0");;;
      do:  ("ok" <-[#boolT] "$r1");;;
      (if: ![#boolT] "ok"
      then return: ("wv")
      else do:  #()))));;;
    return: (#null)).

(* cmps returns a cmp list testing no writes have happened past rev

   go: stm.go:228:20 *)
Definition writeSet__cmpsⁱᵐᵖˡ : val :=
  λ: "ws" "rev",
    exception_do (let: "ws" := (mem.alloc "ws") in
    let: "rev" := (mem.alloc "rev") in
    let: "cmps" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make3 #clientv3.Cmp #(W64 0) (let: "$a0" := (![#writeSet] "ws") in
    map.len "$a0")) in
    do:  ("cmps" <-[#sliceT] "$r0");;;
    let: "$range" := (![#writeSet] "ws") in
    (let: "key" := (mem.alloc (type.zero_val #stringT)) in
    map.for_range "$range" (λ: "$key" "value",
      do:  ("key" <-[#stringT] "$key");;;
      let: "$r0" := (let: "$a0" := (![#sliceT] "cmps") in
      let: "$a1" := ((let: "$sl0" := (let: "$a0" := (let: "$a0" := (![#stringT] "key") in
      (func_call #clientv3.ModRevision) "$a0") in
      let: "$a1" := #"<"%go in
      let: "$a2" := (interface.make #int64Tⁱᵈ (![#int64T] "rev")) in
      (func_call #clientv3.Compare) "$a0" "$a1" "$a2") in
      slice.literal #clientv3.Cmp ["$sl0"])) in
      (slice.append #clientv3.Cmp) "$a0" "$a1") in
      do:  ("cmps" <-[#sliceT] "$r0")));;;
    return: (![#sliceT] "cmps")).

(* puts is the list of ops for all pending writes

   go: stm.go:237:20 *)
Definition writeSet__putsⁱᵐᵖˡ : val :=
  λ: "ws" <>,
    exception_do (let: "ws" := (mem.alloc "ws") in
    let: "puts" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make3 #clientv3.Op #(W64 0) (let: "$a0" := (![#writeSet] "ws") in
    map.len "$a0")) in
    do:  ("puts" <-[#sliceT] "$r0");;;
    let: "$range" := (![#writeSet] "ws") in
    (let: "v" := (mem.alloc (type.zero_val #stmPut)) in
    map.for_range "$range" (λ: "$key" "value",
      do:  ("v" <-[#stmPut] "$value");;;
      do:  "$key";;;
      let: "$r0" := (let: "$a0" := (![#sliceT] "puts") in
      let: "$a1" := ((let: "$sl0" := (![#clientv3.Op] (struct.field_ref #stmPut #"op"%go "v")) in
      slice.literal #clientv3.Op ["$sl0"])) in
      (slice.append #clientv3.Op) "$a0" "$a1") in
      do:  ("puts" <-[#sliceT] "$r0")));;;
    return: (![#sliceT] "puts")).

Definition respToValue : go_string := "go.etcd.io/etcd/client/v3/concurrency.respToValue"%go.

(* go: stm.go:245:15 *)
Definition stm__Getⁱᵐᵖˡ : val :=
  λ: "s" "keys",
    exception_do (let: "s" := (mem.alloc "s") in
    let: "keys" := (mem.alloc "keys") in
    (let: "wv" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "keys") in
    (method_call #concurrency.concurrency #"writeSet" #"get" (![#writeSet] (struct.field_ref #stm #"wset"%go (![#ptrT] "s")))) "$a0") in
    do:  ("wv" <-[#ptrT] "$r0");;;
    (if: (![#ptrT] "wv") ≠ #null
    then return: (![#stringT] (struct.field_ref #stmPut #"val"%go (![#ptrT] "wv")))
    else do:  #()));;;
    return: (let: "$a0" := (let: "$a0" := (![#sliceT] "keys") in
     (method_call #concurrency.concurrency #"stm'ptr" #"fetch" (![#ptrT] "s")) "$a0") in
     (func_call #respToValue) "$a0")).

(* go: stm.go:252:15 *)
Definition stm__Putⁱᵐᵖˡ : val :=
  λ: "s" "key" "val" "opts",
    exception_do (let: "s" := (mem.alloc "s") in
    let: "opts" := (mem.alloc "opts") in
    let: "val" := (mem.alloc "val") in
    let: "key" := (mem.alloc "key") in
    let: "$r0" := (struct.make #stmPut [{
      "val" ::= ![#stringT] "val";
      "op" ::= let: "$a0" := (![#stringT] "key") in
      let: "$a1" := (![#stringT] "val") in
      let: "$a2" := (![#sliceT] "opts") in
      (func_call #clientv3.OpPut) "$a0" "$a1" "$a2"
    }]) in
    do:  (map.insert (![#writeSet] (struct.field_ref #stm #"wset"%go (![#ptrT] "s"))) (![#stringT] "key") "$r0");;;
    return: #()).

(* go: stm.go:256:15 *)
Definition stm__Delⁱᵐᵖˡ : val :=
  λ: "s" "key",
    exception_do (let: "s" := (mem.alloc "s") in
    let: "key" := (mem.alloc "key") in
    let: "$r0" := (struct.make #stmPut [{
      "val" ::= #""%go;
      "op" ::= let: "$a0" := (![#stringT] "key") in
      let: "$a1" := #slice.nil in
      (func_call #clientv3.OpDelete) "$a0" "$a1"
    }]) in
    do:  (map.insert (![#writeSet] (struct.field_ref #stm #"wset"%go (![#ptrT] "s"))) (![#stringT] "key") "$r0");;;
    return: #()).

(* go: stm.go:258:15 *)
Definition stm__Revⁱᵐᵖˡ : val :=
  λ: "s" "key",
    exception_do (let: "s" := (mem.alloc "s") in
    let: "key" := (mem.alloc "key") in
    (let: "resp" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := ((let: "$sl0" := (![#stringT] "key") in
    slice.literal #stringT ["$sl0"])) in
    (method_call #concurrency.concurrency #"stm'ptr" #"fetch" (![#ptrT] "s")) "$a0") in
    do:  ("resp" <-[#ptrT] "$r0");;;
    (if: ((![#ptrT] "resp") ≠ #null) && ((let: "$a0" := (![#sliceT] (struct.field_ref #clientv3.GetResponse #"Kvs"%go (![#ptrT] "resp"))) in
    slice.len "$a0") ≠ #(W64 0))
    then return: (![#int64T] (struct.field_ref #mvccpb.KeyValue #"ModRevision"%go (![#ptrT] (slice.elem_ref #ptrT (![#sliceT] (struct.field_ref #clientv3.GetResponse #"Kvs"%go (![#ptrT] "resp"))) #(W64 0)))))
    else do:  #()));;;
    return: (#(W64 0))).

(* go: stm.go:265:15 *)
Definition stm__commitⁱᵐᵖˡ : val :=
  λ: "s" <>,
    exception_do (let: "s" := (mem.alloc "s") in
    let: "err" := (mem.alloc (type.zero_val #error)) in
    let: "txnresp" := (mem.alloc (type.zero_val #ptrT)) in
    let: ("$ret0", "$ret1") := ((interface.get #"Commit"%go (let: "$a0" := ((method_call #concurrency.concurrency #"writeSet" #"puts" (![#writeSet] (struct.field_ref #stm #"wset"%go (![#ptrT] "s")))) #()) in
    (interface.get #"Then"%go (let: "$a0" := ((![#funcT] (struct.field_ref #stm #"conflicts"%go (![#ptrT] "s"))) #()) in
    (interface.get #"If"%go (let: "$a0" := (![#context.Context] (struct.field_ref #stm #"ctx"%go (![#ptrT] "s"))) in
    (method_call #clientv3 #"Client'ptr" #"Txn" (![#ptrT] (struct.field_ref #stm #"client"%go (![#ptrT] "s")))) "$a0")) "$a0")) "$a0")) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("txnresp" <-[#ptrT] "$r0");;;
    do:  ("err" <-[#error] "$r1");;;
    (if: (~ (interface.eq (![#error] "err") #interface.nil))
    then
      do:  (let: "$a0" := (interface.make #stmErrorⁱᵈ (struct.make #stmError [{
        "err" ::= ![#error] "err"
      }])) in
      Panic "$a0")
    else do:  #());;;
    (if: ![#boolT] (struct.field_ref #clientv3.TxnResponse #"Succeeded"%go (![#ptrT] "txnresp"))
    then return: (![#ptrT] "txnresp")
    else do:  #());;;
    return: (#null)).

(* go: stm.go:276:15 *)
Definition stm__fetchⁱᵐᵖˡ : val :=
  λ: "s" "keys",
    exception_do (let: "s" := (mem.alloc "s") in
    let: "keys" := (mem.alloc "keys") in
    (if: (let: "$a0" := (![#sliceT] "keys") in
    slice.len "$a0") = #(W64 0)
    then return: (#null)
    else do:  #());;;
    let: "ops" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make2 #clientv3.Op (let: "$a0" := (![#sliceT] "keys") in
    slice.len "$a0")) in
    do:  ("ops" <-[#sliceT] "$r0");;;
    let: "$range" := (![#sliceT] "keys") in
    (let: "key" := (mem.alloc (type.zero_val #stringT)) in
    let: "i" := (mem.alloc (type.zero_val #intT)) in
    slice.for_range #stringT "$range" (λ: "$key" "$value",
      do:  ("key" <-[#stringT] "$value");;;
      do:  ("i" <-[#intT] "$key");;;
      (let: "ok" := (mem.alloc (type.zero_val #boolT)) in
      let: "resp" := (mem.alloc (type.zero_val #ptrT)) in
      let: ("$ret0", "$ret1") := (map.get (![#readSet] (struct.field_ref #stm #"rset"%go (![#ptrT] "s"))) (![#stringT] "key")) in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("resp" <-[#ptrT] "$r0");;;
      do:  ("ok" <-[#boolT] "$r1");;;
      (if: ![#boolT] "ok"
      then return: (![#ptrT] "resp")
      else do:  #()));;;
      let: "$r0" := (let: "$a0" := (![#stringT] "key") in
      let: "$a1" := (![#sliceT] (struct.field_ref #stm #"getOpts"%go (![#ptrT] "s"))) in
      (func_call #clientv3.OpGet) "$a0" "$a1") in
      do:  ((slice.elem_ref #clientv3.Op (![#sliceT] "ops") (![#intT] "i")) <-[#clientv3.Op] "$r0")));;;
    let: "err" := (mem.alloc (type.zero_val #error)) in
    let: "txnresp" := (mem.alloc (type.zero_val #ptrT)) in
    let: ("$ret0", "$ret1") := ((interface.get #"Commit"%go (let: "$a0" := (![#sliceT] "ops") in
    (interface.get #"Then"%go (let: "$a0" := (![#context.Context] (struct.field_ref #stm #"ctx"%go (![#ptrT] "s"))) in
    (method_call #clientv3 #"Client'ptr" #"Txn" (![#ptrT] (struct.field_ref #stm #"client"%go (![#ptrT] "s")))) "$a0")) "$a0")) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("txnresp" <-[#ptrT] "$r0");;;
    do:  ("err" <-[#error] "$r1");;;
    (if: (~ (interface.eq (![#error] "err") #interface.nil))
    then
      do:  (let: "$a0" := (interface.make #stmErrorⁱᵈ (struct.make #stmError [{
        "err" ::= ![#error] "err"
      }])) in
      Panic "$a0")
    else do:  #());;;
    do:  (let: "$a0" := (![#sliceT] "keys") in
    let: "$a1" := (![#ptrT] "txnresp") in
    (method_call #concurrency.concurrency #"readSet" #"add" (![#readSet] (struct.field_ref #stm #"rset"%go (![#ptrT] "s")))) "$a0" "$a1");;;
    return: ((method_call #etcdserverpb #"ResponseOp'ptr" #"GetResponseRange" (![#ptrT] (slice.elem_ref #ptrT (![#sliceT] (struct.field_ref #clientv3.TxnResponse #"Responses"%go (![#ptrT] "txnresp"))) #(W64 0)))) #())).

(* go: stm.go:295:15 *)
Definition stm__resetⁱᵐᵖˡ : val :=
  λ: "s" <>,
    exception_do (let: "s" := (mem.alloc "s") in
    let: "$r0" := (map.make #stringT #ptrT) in
    do:  ((struct.field_ref #stm #"rset"%go (![#ptrT] "s")) <-[#readSet] "$r0");;;
    let: "$r0" := (map.make #stringT #stmPut) in
    do:  ((struct.field_ref #stm #"wset"%go (![#ptrT] "s")) <-[#writeSet] "$r0");;;
    return: #()).

(* go: stm.go:305:27 *)
Definition stmSerializable__Getⁱᵐᵖˡ : val :=
  λ: "s" "keys",
    exception_do (let: "s" := (mem.alloc "s") in
    let: "keys" := (mem.alloc "keys") in
    (if: (let: "$a0" := (![#sliceT] "keys") in
    slice.len "$a0") = #(W64 0)
    then return: (#""%go)
    else do:  #());;;
    (let: "wv" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "keys") in
    (method_call #concurrency.concurrency #"writeSet" #"get" (![#writeSet] (struct.field_ref #stm #"wset"%go (struct.field_ref #stmSerializable #"stm"%go (![#ptrT] "s"))))) "$a0") in
    do:  ("wv" <-[#ptrT] "$r0");;;
    (if: (![#ptrT] "wv") ≠ #null
    then return: (![#stringT] (struct.field_ref #stmPut #"val"%go (![#ptrT] "wv")))
    else do:  #()));;;
    let: "firstRead" := (mem.alloc (type.zero_val #boolT)) in
    let: "$r0" := ((let: "$a0" := (![#readSet] (struct.field_ref #stm #"rset"%go (struct.field_ref #stmSerializable #"stm"%go (![#ptrT] "s")))) in
    map.len "$a0") = #(W64 0)) in
    do:  ("firstRead" <-[#boolT] "$r0");;;
    let: "$range" := (![#sliceT] "keys") in
    (let: "key" := (mem.alloc (type.zero_val #stringT)) in
    slice.for_range #stringT "$range" (λ: "$key" "$value",
      do:  ("key" <-[#stringT] "$value");;;
      do:  "$key";;;
      (let: "ok" := (mem.alloc (type.zero_val #boolT)) in
      let: "resp" := (mem.alloc (type.zero_val #ptrT)) in
      let: ("$ret0", "$ret1") := (map.get (![type.mapT #stringT #ptrT] (struct.field_ref #stmSerializable #"prefetch"%go (![#ptrT] "s"))) (![#stringT] "key")) in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("resp" <-[#ptrT] "$r0");;;
      do:  ("ok" <-[#boolT] "$r1");;;
      (if: ![#boolT] "ok"
      then
        do:  (let: "$a0" := (![type.mapT #stringT #ptrT] (struct.field_ref #stmSerializable #"prefetch"%go (![#ptrT] "s"))) in
        let: "$a1" := (![#stringT] "key") in
        map.delete "$a0" "$a1");;;
        let: "$r0" := (![#ptrT] "resp") in
        do:  (map.insert (![#readSet] (struct.field_ref #stm #"rset"%go (struct.field_ref #stmSerializable #"stm"%go (![#ptrT] "s")))) (![#stringT] "key") "$r0")
      else do:  #()))));;;
    let: "resp" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "keys") in
    (method_call #concurrency.concurrency #"stm'ptr" #"fetch" (struct.field_ref #stmSerializable #"stm"%go (![#ptrT] "s"))) "$a0") in
    do:  ("resp" <-[#ptrT] "$r0");;;
    (if: ![#boolT] "firstRead"
    then
      let: "$r0" := ((let: "$sl0" := (let: "$a0" := (![#int64T] (struct.field_ref #etcdserverpb.ResponseHeader #"Revision"%go (![#ptrT] (struct.field_ref #clientv3.GetResponse #"Header"%go (![#ptrT] "resp"))))) in
      (func_call #clientv3.WithRev) "$a0") in
      let: "$sl1" := ((func_call #clientv3.WithSerializable) #()) in
      slice.literal #clientv3.OpOption ["$sl0"; "$sl1"])) in
      do:  ((struct.field_ref #stm #"getOpts"%go (struct.field_ref #stmSerializable #"stm"%go (![#ptrT] "s"))) <-[#sliceT] "$r0")
    else do:  #());;;
    return: (let: "$a0" := (![#ptrT] "resp") in
     (func_call #respToValue) "$a0")).

(* go: stm.go:331:27 *)
Definition stmSerializable__Revⁱᵐᵖˡ : val :=
  λ: "s" "key",
    exception_do (let: "s" := (mem.alloc "s") in
    let: "key" := (mem.alloc "key") in
    do:  (let: "$a0" := ((let: "$sl0" := (![#stringT] "key") in
    slice.literal #stringT ["$sl0"])) in
    (method_call #concurrency.concurrency #"stmSerializable'ptr" #"Get" (![#ptrT] "s")) "$a0");;;
    return: (let: "$a0" := (![#stringT] "key") in
     (method_call #concurrency.concurrency #"stm'ptr" #"Rev" (struct.field_ref #stmSerializable #"stm"%go (![#ptrT] "s"))) "$a0")).

(* go: stm.go:336:27 *)
Definition stmSerializable__getsⁱᵐᵖˡ : val :=
  λ: "s" <>,
    exception_do (let: "s" := (mem.alloc "s") in
    let: "keys" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make3 #stringT #(W64 0) (let: "$a0" := (![#readSet] (struct.field_ref #stm #"rset"%go (struct.field_ref #stmSerializable #"stm"%go (![#ptrT] "s")))) in
    map.len "$a0")) in
    do:  ("keys" <-[#sliceT] "$r0");;;
    let: "ops" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make3 #clientv3.Op #(W64 0) (let: "$a0" := (![#readSet] (struct.field_ref #stm #"rset"%go (struct.field_ref #stmSerializable #"stm"%go (![#ptrT] "s")))) in
    map.len "$a0")) in
    do:  ("ops" <-[#sliceT] "$r0");;;
    let: "$range" := (![#readSet] (struct.field_ref #stm #"rset"%go (struct.field_ref #stmSerializable #"stm"%go (![#ptrT] "s")))) in
    (let: "k" := (mem.alloc (type.zero_val #stringT)) in
    map.for_range "$range" (λ: "$key" "value",
      do:  ("k" <-[#stringT] "$key");;;
      let: "$r0" := (let: "$a0" := (![#sliceT] "keys") in
      let: "$a1" := ((let: "$sl0" := (![#stringT] "k") in
      slice.literal #stringT ["$sl0"])) in
      (slice.append #stringT) "$a0" "$a1") in
      do:  ("keys" <-[#sliceT] "$r0");;;
      let: "$r0" := (let: "$a0" := (![#sliceT] "ops") in
      let: "$a1" := ((let: "$sl0" := (let: "$a0" := (![#stringT] "k") in
      let: "$a1" := #slice.nil in
      (func_call #clientv3.OpGet) "$a0" "$a1") in
      slice.literal #clientv3.Op ["$sl0"])) in
      (slice.append #clientv3.Op) "$a0" "$a1") in
      do:  ("ops" <-[#sliceT] "$r0")));;;
    return: (![#sliceT] "keys", ![#sliceT] "ops")).

(* go: stm.go:346:27 *)
Definition stmSerializable__commitⁱᵐᵖˡ : val :=
  λ: "s" <>,
    exception_do (let: "s" := (mem.alloc "s") in
    let: "getops" := (mem.alloc (type.zero_val #sliceT)) in
    let: "keys" := (mem.alloc (type.zero_val #sliceT)) in
    let: ("$ret0", "$ret1") := ((method_call #concurrency.concurrency #"stmSerializable'ptr" #"gets" (![#ptrT] "s")) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("keys" <-[#sliceT] "$r0");;;
    do:  ("getops" <-[#sliceT] "$r1");;;
    let: "txn" := (mem.alloc (type.zero_val #clientv3.Txn)) in
    let: "$r0" := (let: "$a0" := ((method_call #concurrency.concurrency #"writeSet" #"puts" (![#writeSet] (struct.field_ref #stm #"wset"%go (struct.field_ref #stmSerializable #"stm"%go (![#ptrT] "s"))))) #()) in
    (interface.get #"Then"%go (let: "$a0" := ((![#funcT] (struct.field_ref #stm #"conflicts"%go (struct.field_ref #stmSerializable #"stm"%go (![#ptrT] "s")))) #()) in
    (interface.get #"If"%go (let: "$a0" := (![#context.Context] (struct.field_ref #stm #"ctx"%go (struct.field_ref #stmSerializable #"stm"%go (![#ptrT] "s")))) in
    (method_call #clientv3 #"Client'ptr" #"Txn" (![#ptrT] (struct.field_ref #stm #"client"%go (struct.field_ref #stmSerializable #"stm"%go (![#ptrT] "s"))))) "$a0")) "$a0")) "$a0") in
    do:  ("txn" <-[#clientv3.Txn] "$r0");;;
    let: "err" := (mem.alloc (type.zero_val #error)) in
    let: "txnresp" := (mem.alloc (type.zero_val #ptrT)) in
    let: ("$ret0", "$ret1") := ((interface.get #"Commit"%go (let: "$a0" := (![#sliceT] "getops") in
    (interface.get #"Else"%go (![#clientv3.Txn] "txn")) "$a0")) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("txnresp" <-[#ptrT] "$r0");;;
    do:  ("err" <-[#error] "$r1");;;
    (if: (~ (interface.eq (![#error] "err") #interface.nil))
    then
      do:  (let: "$a0" := (interface.make #stmErrorⁱᵈ (struct.make #stmError [{
        "err" ::= ![#error] "err"
      }])) in
      Panic "$a0")
    else do:  #());;;
    (if: ![#boolT] (struct.field_ref #clientv3.TxnResponse #"Succeeded"%go (![#ptrT] "txnresp"))
    then return: (![#ptrT] "txnresp")
    else do:  #());;;
    do:  (let: "$a0" := (![#sliceT] "keys") in
    let: "$a1" := (![#ptrT] "txnresp") in
    (method_call #concurrency.concurrency #"readSet" #"add" (![#readSet] (struct.field_ref #stm #"rset"%go (struct.field_ref #stmSerializable #"stm"%go (![#ptrT] "s"))))) "$a0" "$a1");;;
    let: "$r0" := (![#readSet] (struct.field_ref #stm #"rset"%go (struct.field_ref #stmSerializable #"stm"%go (![#ptrT] "s")))) in
    do:  ((struct.field_ref #stmSerializable #"prefetch"%go (![#ptrT] "s")) <-[type.mapT #stringT #ptrT] "$r0");;;
    let: "$r0" := #slice.nil in
    do:  ((struct.field_ref #stm #"getOpts"%go (struct.field_ref #stmSerializable #"stm"%go (![#ptrT] "s"))) <-[#sliceT] "$r0");;;
    return: (#null)).

(* go: stm.go:364:6 *)
Definition isKeyCurrentⁱᵐᵖˡ : val :=
  λ: "k" "r",
    exception_do (let: "r" := (mem.alloc "r") in
    let: "k" := (mem.alloc "k") in
    (if: (let: "$a0" := (![#sliceT] (struct.field_ref #clientv3.GetResponse #"Kvs"%go (![#ptrT] "r"))) in
    slice.len "$a0") ≠ #(W64 0)
    then
      return: (let: "$a0" := (let: "$a0" := (![#stringT] "k") in
       (func_call #clientv3.ModRevision) "$a0") in
       let: "$a1" := #"="%go in
       let: "$a2" := (interface.make #int64Tⁱᵈ (![#int64T] (struct.field_ref #mvccpb.KeyValue #"ModRevision"%go (![#ptrT] (slice.elem_ref #ptrT (![#sliceT] (struct.field_ref #clientv3.GetResponse #"Kvs"%go (![#ptrT] "r"))) #(W64 0)))))) in
       (func_call #clientv3.Compare) "$a0" "$a1" "$a2")
    else do:  #());;;
    return: (let: "$a0" := (let: "$a0" := (![#stringT] "k") in
     (func_call #clientv3.ModRevision) "$a0") in
     let: "$a1" := #"="%go in
     let: "$a2" := (interface.make #intTⁱᵈ #(W64 0)) in
     (func_call #clientv3.Compare) "$a0" "$a1" "$a2")).

(* go: stm.go:371:6 *)
Definition respToValueⁱᵐᵖˡ : val :=
  λ: "resp",
    exception_do (let: "resp" := (mem.alloc "resp") in
    (if: ((![#ptrT] "resp") = #null) || ((let: "$a0" := (![#sliceT] (struct.field_ref #clientv3.GetResponse #"Kvs"%go (![#ptrT] "resp"))) in
    slice.len "$a0") = #(W64 0))
    then return: (#""%go)
    else do:  #());;;
    return: (string.from_bytes (![#sliceT] (struct.field_ref #mvccpb.KeyValue #"Value"%go (![#ptrT] (slice.elem_ref #ptrT (![#sliceT] (struct.field_ref #clientv3.GetResponse #"Kvs"%go (![#ptrT] "resp"))) #(W64 0))))))).

Definition NewSTMRepeatable : go_string := "go.etcd.io/etcd/client/v3/concurrency.NewSTMRepeatable"%go.

(* NewSTMRepeatable is deprecated.

   go: stm.go:379:6 *)
Definition NewSTMRepeatableⁱᵐᵖˡ : val :=
  λ: "ctx" "c" "apply",
    exception_do (let: "apply" := (mem.alloc "apply") in
    let: "c" := (mem.alloc "c") in
    let: "ctx" := (mem.alloc "ctx") in
    let: ("$ret0", "$ret1") := ((let: "$a0" := (![#ptrT] "c") in
    let: "$a1" := (![#funcT] "apply") in
    let: "$a2" := ((let: "$sl0" := (let: "$a0" := (![#context.Context] "ctx") in
    (func_call #WithAbortContext) "$a0") in
    let: "$sl1" := (let: "$a0" := RepeatableReads in
    (func_call #WithIsolation) "$a0") in
    slice.literal #stmOption ["$sl0"; "$sl1"])) in
    (func_call #NewSTM) "$a0" "$a1" "$a2")) in
    return: ("$ret0", "$ret1")).

Definition NewSTMSerializable : go_string := "go.etcd.io/etcd/client/v3/concurrency.NewSTMSerializable"%go.

(* NewSTMSerializable is deprecated.

   go: stm.go:384:6 *)
Definition NewSTMSerializableⁱᵐᵖˡ : val :=
  λ: "ctx" "c" "apply",
    exception_do (let: "apply" := (mem.alloc "apply") in
    let: "c" := (mem.alloc "c") in
    let: "ctx" := (mem.alloc "ctx") in
    let: ("$ret0", "$ret1") := ((let: "$a0" := (![#ptrT] "c") in
    let: "$a1" := (![#funcT] "apply") in
    let: "$a2" := ((let: "$sl0" := (let: "$a0" := (![#context.Context] "ctx") in
    (func_call #WithAbortContext) "$a0") in
    let: "$sl1" := (let: "$a0" := Serializable in
    (func_call #WithIsolation) "$a0") in
    slice.literal #stmOption ["$sl0"; "$sl1"])) in
    (func_call #NewSTM) "$a0" "$a1" "$a2")) in
    return: ("$ret0", "$ret1")).

Definition NewSTMReadCommitted : go_string := "go.etcd.io/etcd/client/v3/concurrency.NewSTMReadCommitted"%go.

(* NewSTMReadCommitted is deprecated.

   go: stm.go:389:6 *)
Definition NewSTMReadCommittedⁱᵐᵖˡ : val :=
  λ: "ctx" "c" "apply",
    exception_do (let: "apply" := (mem.alloc "apply") in
    let: "c" := (mem.alloc "c") in
    let: "ctx" := (mem.alloc "ctx") in
    let: ("$ret0", "$ret1") := ((let: "$a0" := (![#ptrT] "c") in
    let: "$a1" := (![#funcT] "apply") in
    let: "$a2" := ((let: "$sl0" := (let: "$a0" := (![#context.Context] "ctx") in
    (func_call #WithAbortContext) "$a0") in
    let: "$sl1" := (let: "$a0" := ReadCommitted in
    (func_call #WithIsolation) "$a0") in
    slice.literal #stmOption ["$sl0"; "$sl1"])) in
    (func_call #NewSTM) "$a0" "$a1" "$a2")) in
    return: ("$ret0", "$ret1")).

Definition vars' : list (go_string * go_type) := [(ErrElectionNotLeader, error); (ErrElectionNoLeader, error); (ErrLocked, error); (ErrSessionExpired, error); (ErrLockReleased, error)].

Definition functions' : list (go_string * val) := [(NewElection, NewElectionⁱᵐᵖˡ); (ResumeElection, ResumeElectionⁱᵐᵖˡ); (waitDelete, waitDeleteⁱᵐᵖˡ); (waitDeletes, waitDeletesⁱᵐᵖˡ); (NewMutex, NewMutexⁱᵐᵖˡ); (NewLocker, NewLockerⁱᵐᵖˡ); (NewSession, NewSessionⁱᵐᵖˡ); (WithTTL, WithTTLⁱᵐᵖˡ); (WithLease, WithLeaseⁱᵐᵖˡ); (WithContext, WithContextⁱᵐᵖˡ); (WithIsolation, WithIsolationⁱᵐᵖˡ); (WithAbortContext, WithAbortContextⁱᵐᵖˡ); (WithPrefetch, WithPrefetchⁱᵐᵖˡ); (NewSTM, NewSTMⁱᵐᵖˡ); (mkSTM, mkSTMⁱᵐᵖˡ); (runSTM, runSTMⁱᵐᵖˡ); (isKeyCurrent, isKeyCurrentⁱᵐᵖˡ); (respToValue, respToValueⁱᵐᵖˡ); (NewSTMRepeatable, NewSTMRepeatableⁱᵐᵖˡ); (NewSTMSerializable, NewSTMSerializableⁱᵐᵖˡ); (NewSTMReadCommitted, NewSTMReadCommittedⁱᵐᵖˡ)].

Definition msets' : list (go_string * (list (go_string * val))) := [("Election"%go, []); ("Election'ptr"%go, [("Campaign"%go, Election__Campaignⁱᵐᵖˡ); ("Header"%go, Election__Headerⁱᵐᵖˡ); ("Key"%go, Election__Keyⁱᵐᵖˡ); ("Leader"%go, Election__Leaderⁱᵐᵖˡ); ("Observe"%go, Election__Observeⁱᵐᵖˡ); ("Proclaim"%go, Election__Proclaimⁱᵐᵖˡ); ("Resign"%go, Election__Resignⁱᵐᵖˡ); ("Rev"%go, Election__Revⁱᵐᵖˡ); ("observe"%go, Election__observeⁱᵐᵖˡ)]); ("Mutex"%go, []); ("Mutex'ptr"%go, [("Header"%go, Mutex__Headerⁱᵐᵖˡ); ("IsOwner"%go, Mutex__IsOwnerⁱᵐᵖˡ); ("Key"%go, Mutex__Keyⁱᵐᵖˡ); ("Lock"%go, Mutex__Lockⁱᵐᵖˡ); ("TryLock"%go, Mutex__TryLockⁱᵐᵖˡ); ("Unlock"%go, Mutex__Unlockⁱᵐᵖˡ); ("tryAcquire"%go, Mutex__tryAcquireⁱᵐᵖˡ)]); ("lockerMutex"%go, [("Header"%go, (λ: "$recv",
                 method_call #concurrency.concurrency #"Mutex'ptr" #"Header" (struct.field_get #lockerMutex "Mutex" "$recv")
                 )%V); ("IsOwner"%go, (λ: "$recv",
                 method_call #concurrency.concurrency #"Mutex'ptr" #"IsOwner" (struct.field_get #lockerMutex "Mutex" "$recv")
                 )%V); ("Key"%go, (λ: "$recv",
                 method_call #concurrency.concurrency #"Mutex'ptr" #"Key" (struct.field_get #lockerMutex "Mutex" "$recv")
                 )%V); ("TryLock"%go, (λ: "$recv",
                 method_call #concurrency.concurrency #"Mutex'ptr" #"TryLock" (struct.field_get #lockerMutex "Mutex" "$recv")
                 )%V); ("tryAcquire"%go, (λ: "$recv",
                 method_call #concurrency.concurrency #"Mutex'ptr" #"tryAcquire" (struct.field_get #lockerMutex "Mutex" "$recv")
                 )%V)]); ("lockerMutex'ptr"%go, [("Header"%go, (λ: "$recvAddr",
                 method_call #concurrency.concurrency #"Mutex'ptr" #"Header" (![#ptrT] (struct.field_ref #lockerMutex #"Mutex"%go "$recvAddr"))
                 )%V); ("IsOwner"%go, (λ: "$recvAddr",
                 method_call #concurrency.concurrency #"Mutex'ptr" #"IsOwner" (![#ptrT] (struct.field_ref #lockerMutex #"Mutex"%go "$recvAddr"))
                 )%V); ("Key"%go, (λ: "$recvAddr",
                 method_call #concurrency.concurrency #"Mutex'ptr" #"Key" (![#ptrT] (struct.field_ref #lockerMutex #"Mutex"%go "$recvAddr"))
                 )%V); ("Lock"%go, lockerMutex__Lockⁱᵐᵖˡ); ("TryLock"%go, (λ: "$recvAddr",
                 method_call #concurrency.concurrency #"Mutex'ptr" #"TryLock" (![#ptrT] (struct.field_ref #lockerMutex #"Mutex"%go "$recvAddr"))
                 )%V); ("Unlock"%go, lockerMutex__Unlockⁱᵐᵖˡ); ("tryAcquire"%go, (λ: "$recvAddr",
                 method_call #concurrency.concurrency #"Mutex'ptr" #"tryAcquire" (![#ptrT] (struct.field_ref #lockerMutex #"Mutex"%go "$recvAddr"))
                 )%V)]); ("Session"%go, []); ("Session'ptr"%go, [("Client"%go, Session__Clientⁱᵐᵖˡ); ("Close"%go, Session__Closeⁱᵐᵖˡ); ("Ctx"%go, Session__Ctxⁱᵐᵖˡ); ("Done"%go, Session__Doneⁱᵐᵖˡ); ("Lease"%go, Session__Leaseⁱᵐᵖˡ); ("Orphan"%go, Session__Orphanⁱᵐᵖˡ)]); ("sessionOptions"%go, []); ("sessionOptions'ptr"%go, []); ("SessionOption"%go, []); ("SessionOption'ptr"%go, []); ("Isolation"%go, []); ("Isolation'ptr"%go, []); ("stmError"%go, []); ("stmError'ptr"%go, []); ("stmOptions"%go, []); ("stmOptions'ptr"%go, []); ("stmOption"%go, []); ("stmOption'ptr"%go, []); ("stmResponse"%go, []); ("stmResponse'ptr"%go, []); ("stm"%go, []); ("stm'ptr"%go, [("Del"%go, stm__Delⁱᵐᵖˡ); ("Get"%go, stm__Getⁱᵐᵖˡ); ("Put"%go, stm__Putⁱᵐᵖˡ); ("Rev"%go, stm__Revⁱᵐᵖˡ); ("commit"%go, stm__commitⁱᵐᵖˡ); ("fetch"%go, stm__fetchⁱᵐᵖˡ); ("reset"%go, stm__resetⁱᵐᵖˡ)]); ("stmPut"%go, []); ("stmPut'ptr"%go, []); ("readSet"%go, [("add"%go, readSet__addⁱᵐᵖˡ); ("cmps"%go, readSet__cmpsⁱᵐᵖˡ); ("first"%go, readSet__firstⁱᵐᵖˡ)]); ("readSet'ptr"%go, [("add"%go, (λ: "$recvAddr",
                 method_call #concurrency.concurrency #"readSet" #"add" (![#readSet] "$recvAddr")
                 )%V); ("cmps"%go, (λ: "$recvAddr",
                 method_call #concurrency.concurrency #"readSet" #"cmps" (![#readSet] "$recvAddr")
                 )%V); ("first"%go, (λ: "$recvAddr",
                 method_call #concurrency.concurrency #"readSet" #"first" (![#readSet] "$recvAddr")
                 )%V)]); ("writeSet"%go, [("cmps"%go, writeSet__cmpsⁱᵐᵖˡ); ("get"%go, writeSet__getⁱᵐᵖˡ); ("puts"%go, writeSet__putsⁱᵐᵖˡ)]); ("writeSet'ptr"%go, [("cmps"%go, (λ: "$recvAddr",
                 method_call #concurrency.concurrency #"writeSet" #"cmps" (![#writeSet] "$recvAddr")
                 )%V); ("get"%go, (λ: "$recvAddr",
                 method_call #concurrency.concurrency #"writeSet" #"get" (![#writeSet] "$recvAddr")
                 )%V); ("puts"%go, (λ: "$recvAddr",
                 method_call #concurrency.concurrency #"writeSet" #"puts" (![#writeSet] "$recvAddr")
                 )%V)]); ("stmSerializable"%go, []); ("stmSerializable'ptr"%go, [("Del"%go, (λ: "$recvAddr",
                 method_call #concurrency.concurrency #"stm'ptr" #"Del" (struct.field_ref #stmSerializable #"stm"%go "$recvAddr")
                 )%V); ("Get"%go, stmSerializable__Getⁱᵐᵖˡ); ("Put"%go, (λ: "$recvAddr",
                 method_call #concurrency.concurrency #"stm'ptr" #"Put" (struct.field_ref #stmSerializable #"stm"%go "$recvAddr")
                 )%V); ("Rev"%go, stmSerializable__Revⁱᵐᵖˡ); ("commit"%go, stmSerializable__commitⁱᵐᵖˡ); ("fetch"%go, (λ: "$recvAddr",
                 method_call #concurrency.concurrency #"stm'ptr" #"fetch" (struct.field_ref #stmSerializable #"stm"%go "$recvAddr")
                 )%V); ("gets"%go, stmSerializable__getsⁱᵐᵖˡ); ("reset"%go, (λ: "$recvAddr",
                 method_call #concurrency.concurrency #"stm'ptr" #"reset" (struct.field_ref #stmSerializable #"stm"%go "$recvAddr")
                 )%V)])].

#[global] Instance info' : PkgInfo concurrency.concurrency :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [context.context; errors.errors; fmt.fmt; etcdserverpb.etcdserverpb; mvccpb.mvccpb; v3.clientv3; strings.strings; sync.sync; time.time; zap.zap; math.math];
  |}.

Definition initialize' : val :=
  λ: <>,
    package.init #concurrency.concurrency (λ: <>,
      exception_do (do:  (math.initialize' #());;;
      do:  (zap.initialize' #());;;
      do:  (time.initialize' #());;;
      do:  (sync.initialize' #());;;
      do:  (strings.initialize' #());;;
      do:  (clientv3.initialize' #());;;
      do:  (mvccpb.initialize' #());;;
      do:  (etcdserverpb.initialize' #());;;
      do:  (fmt.initialize' #());;;
      do:  (errors.initialize' #());;;
      do:  (context.initialize' #());;;
      do:  (package.alloc concurrency.concurrency #());;;
      let: "$r0" := (let: "$a0" := #"election: not leader"%go in
      (func_call #errors.New) "$a0") in
      do:  ((globals.get #ErrElectionNotLeader) <-[#error] "$r0");;;
      let: "$r0" := (let: "$a0" := #"election: no leader"%go in
      (func_call #errors.New) "$a0") in
      do:  ((globals.get #ErrElectionNoLeader) <-[#error] "$r0");;;
      let: "$r0" := (let: "$a0" := #"mutex: Locked by another session"%go in
      (func_call #errors.New) "$a0") in
      do:  ((globals.get #ErrLocked) <-[#error] "$r0");;;
      let: "$r0" := (let: "$a0" := #"mutex: session is expired"%go in
      (func_call #errors.New) "$a0") in
      do:  ((globals.get #ErrSessionExpired) <-[#error] "$r0");;;
      let: "$r0" := (let: "$a0" := #"mutex: lock has already been released"%go in
      (func_call #errors.New) "$a0") in
      do:  ((globals.get #ErrLockReleased) <-[#error] "$r0"))
      ).

End code.
End concurrency.
