(* autogenerated from go.etcd.io/etcd/client/v3/concurrency *)
From New.golang Require Import defn.
Require Export New.code.context.
Require Export New.code.errors.
Require Export New.code.fmt.
Require Export New.code.go_etcd_io.etcd.api.v3.etcdserverpb.
Require Export New.code.go_etcd_io.etcd.api.v3.mvccpb.
Require Export New.code.go_etcd_io.etcd.client.v3.
Require Export New.code.go_uber_org.zap.
Require Export New.code.math.
Require Export New.code.strings.
Require Export New.code.sync.
Require Export New.code.time.

Definition concurrency : go_string := "go.etcd.io/etcd/client/v3/concurrency".

Module concurrency.
Section code.
Context `{ffi_syntax}.


Definition Election : go_type := structT [
  "session" :: ptrT;
  "keyPrefix" :: stringT;
  "leaderKey" :: stringT;
  "leaderRev" :: int64T;
  "leaderSession" :: ptrT;
  "hdr" :: ptrT
].

(* NewElection returns a new election on a given key prefix.

   go: election.go:44:6 *)
Definition NewElection : val :=
  rec: "NewElection" "s" "pfx" :=
    exception_do (let: "pfx" := (mem.alloc "pfx") in
    let: "s" := (mem.alloc "s") in
    return: (mem.alloc (let: "$session" := (![#ptrT] "s") in
     let: "$keyPrefix" := ((![#stringT] "pfx") + #"/"%go) in
     struct.make #Election [{
       "session" ::= "$session";
       "keyPrefix" ::= "$keyPrefix";
       "leaderKey" ::= type.zero_val #stringT;
       "leaderRev" ::= type.zero_val #int64T;
       "leaderSession" ::= type.zero_val #ptrT;
       "hdr" ::= type.zero_val #ptrT
     }]))).

(* ResumeElection initializes an election with a known leader.

   go: election.go:49:6 *)
Definition ResumeElection : val :=
  rec: "ResumeElection" "s" "pfx" "leaderKey" "leaderRev" :=
    exception_do (let: "leaderRev" := (mem.alloc "leaderRev") in
    let: "leaderKey" := (mem.alloc "leaderKey") in
    let: "pfx" := (mem.alloc "pfx") in
    let: "s" := (mem.alloc "s") in
    return: (mem.alloc (let: "$keyPrefix" := (![#stringT] "pfx") in
     let: "$session" := (![#ptrT] "s") in
     let: "$leaderKey" := (![#stringT] "leaderKey") in
     let: "$leaderRev" := (![#int64T] "leaderRev") in
     let: "$leaderSession" := (![#ptrT] "s") in
     struct.make #Election [{
       "session" ::= "$session";
       "keyPrefix" ::= "$keyPrefix";
       "leaderKey" ::= "$leaderKey";
       "leaderRev" ::= "$leaderRev";
       "leaderSession" ::= "$leaderSession";
       "hdr" ::= type.zero_val #ptrT
     }]))).

Definition Session : go_type := structT [
  "client" :: ptrT;
  "opts" :: ptrT;
  "id" :: clientv3.LeaseID;
  "ctx" :: context.Context;
  "cancel" :: context.CancelFunc;
  "donec" :: chanT (structT [
  ])
].

(* Campaign puts a value as eligible for the election on the prefix
   key.
   Multiple sessions can participate in the election for the
   same prefix, but only one can be the leader at a time.

   If the context is 'context.TODO()/context.Background()', the Campaign
   will continue to be blocked for other keys to be deleted, unless server
   returns a non-recoverable error (e.g. ErrCompacted).
   Otherwise, until the context is not cancelled or timed-out, Campaign will
   continue to be blocked until it becomes the leader.

   go: election.go:69:20 *)
Definition Election__Campaign : val :=
  rec: "Election__Campaign" "e" "ctx" "val" :=
    exception_do (let: "e" := (mem.alloc "e") in
    let: "val" := (mem.alloc "val") in
    let: "ctx" := (mem.alloc "ctx") in
    let: "s" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (![#ptrT] (struct.field_ref #Election #"session"%go (![#ptrT] "e"))) in
    do:  ("s" <-[#ptrT] "$r0");;;
    let: "client" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := ((method_call #concurrency.concurrency #"Session'ptr" #"Client" (![#ptrT] (struct.field_ref #Election #"session"%go (![#ptrT] "e")))) #()) in
    do:  ("client" <-[#ptrT] "$r0");;;
    let: "k" := (mem.alloc (type.zero_val #stringT)) in
    let: "$r0" := (let: "$a0" := #"%s%x"%go in
    let: "$a1" := ((let: "$sl0" := (interface.make #""%go #"string"%go (![#stringT] (struct.field_ref #Election #"keyPrefix"%go (![#ptrT] "e")))) in
    let: "$sl1" := (interface.make #clientv3 #"LeaseID" ((method_call #concurrency.concurrency #"Session'ptr" #"Lease" (![#ptrT] "s")) #())) in
    slice.literal #interfaceT ["$sl0"; "$sl1"])) in
    (func_call #fmt.fmt #"Sprintf"%go) "$a0" "$a1") in
    do:  ("k" <-[#stringT] "$r0");;;
    let: "txn" := (mem.alloc (type.zero_val #clientv3.Txn)) in
    let: "$r0" := (let: "$a0" := ((let: "$sl0" := (let: "$a0" := (let: "$a0" := (![#stringT] "k") in
    (func_call #v3.clientv3 #"CreateRevision"%go) "$a0") in
    let: "$a1" := #"="%go in
    let: "$a2" := (interface.make #""%go #"int"%go #(W64 0)) in
    (func_call #v3.clientv3 #"Compare"%go) "$a0" "$a1" "$a2") in
    slice.literal #clientv3.Cmp ["$sl0"])) in
    (interface.get #"If"%go (let: "$a0" := (![#context.Context] "ctx") in
    (method_call #clientv3 #"Client'ptr" #"Txn" (![#ptrT] "client")) "$a0")) "$a0") in
    do:  ("txn" <-[#clientv3.Txn] "$r0");;;
    let: "$r0" := (let: "$a0" := ((let: "$sl0" := (let: "$a0" := (![#stringT] "k") in
    let: "$a1" := (![#stringT] "val") in
    let: "$a2" := ((let: "$sl0" := (let: "$a0" := ((method_call #concurrency.concurrency #"Session'ptr" #"Lease" (![#ptrT] "s")) #()) in
    (func_call #v3.clientv3 #"WithLease"%go) "$a0") in
    slice.literal #clientv3.OpOption ["$sl0"])) in
    (func_call #v3.clientv3 #"OpPut"%go) "$a0" "$a1" "$a2") in
    slice.literal #clientv3.Op ["$sl0"])) in
    (interface.get #"Then"%go (![#clientv3.Txn] "txn")) "$a0") in
    do:  ("txn" <-[#clientv3.Txn] "$r0");;;
    let: "$r0" := (let: "$a0" := ((let: "$sl0" := (let: "$a0" := (![#stringT] "k") in
    let: "$a1" := #slice.nil in
    (func_call #v3.clientv3 #"OpGet"%go) "$a0" "$a1") in
    slice.literal #clientv3.Op ["$sl0"])) in
    (interface.get #"Else"%go (![#clientv3.Txn] "txn")) "$a0") in
    do:  ("txn" <-[#clientv3.Txn] "$r0");;;
    let: "err" := (mem.alloc (type.zero_val #error)) in
    let: "resp" := (mem.alloc (type.zero_val #ptrT)) in
    let: ("$ret0", "$ret1") := ((interface.get #"Commit"%go (![#clientv3.Txn] "txn")) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("resp" <-[#ptrT] "$r0");;;
    do:  ("err" <-[#error] "$r1");;;
    (if: (~ (interface.eq (![#error] "err") #interface.nil))
    then return: (![#error] "err")
    else do:  #());;;
    let: "$r0" := (![#stringT] "k") in
    let: "$r1" := (![#int64T] (struct.field_ref #etcdserverpb.ResponseHeader #"Revision"%go (![#ptrT] (struct.field_ref #clientv3.TxnResponse #"Header"%go (![#ptrT] "resp"))))) in
    let: "$r2" := (![#ptrT] "s") in
    do:  ((struct.field_ref #Election #"leaderKey"%go (![#ptrT] "e")) <-[#stringT] "$r0");;;
    do:  ((struct.field_ref #Election #"leaderRev"%go (![#ptrT] "e")) <-[#int64T] "$r1");;;
    do:  ((struct.field_ref #Election #"leaderSession"%go (![#ptrT] "e")) <-[#ptrT] "$r2");;;
    (if: (~ (![#boolT] (struct.field_ref #clientv3.TxnResponse #"Succeeded"%go (![#ptrT] "resp"))))
    then
      let: "kv" := (mem.alloc (type.zero_val #ptrT)) in
      let: "$r0" := (![#ptrT] (slice.elem_ref #ptrT (![#sliceT] (struct.field_ref #etcdserverpb.RangeResponse #"Kvs"%go ((method_call #etcdserverpb #"ResponseOp'ptr" #"GetResponseRange" (![#ptrT] (slice.elem_ref #ptrT (![#sliceT] (struct.field_ref #clientv3.TxnResponse #"Responses"%go (![#ptrT] "resp"))) #(W64 0)))) #()))) #(W64 0))) in
      do:  ("kv" <-[#ptrT] "$r0");;;
      let: "$r0" := (![#int64T] (struct.field_ref #mvccpb.KeyValue #"CreateRevision"%go (![#ptrT] "kv"))) in
      do:  ((struct.field_ref #Election #"leaderRev"%go (![#ptrT] "e")) <-[#int64T] "$r0");;;
      (if: (string.from_bytes (![#sliceT] (struct.field_ref #mvccpb.KeyValue #"Value"%go (![#ptrT] "kv")))) ≠ (![#stringT] "val")
      then
        (let: "$r0" := (let: "$a0" := (![#context.Context] "ctx") in
        let: "$a1" := (![#stringT] "val") in
        (method_call #concurrency.concurrency #"Election'ptr" #"Proclaim" (![#ptrT] "e")) "$a0" "$a1") in
        do:  ("err" <-[#error] "$r0");;;
        (if: (~ (interface.eq (![#error] "err") #interface.nil))
        then
          do:  (let: "$a0" := (![#context.Context] "ctx") in
          (method_call #concurrency.concurrency #"Election'ptr" #"Resign" (![#ptrT] "e")) "$a0");;;
          return: (![#error] "err")
        else do:  #()))
      else do:  #())
    else do:  #());;;
    let: "$r0" := (let: "$a0" := (![#context.Context] "ctx") in
    let: "$a1" := (![#ptrT] "client") in
    let: "$a2" := (![#stringT] (struct.field_ref #Election #"keyPrefix"%go (![#ptrT] "e"))) in
    let: "$a3" := ((![#int64T] (struct.field_ref #Election #"leaderRev"%go (![#ptrT] "e"))) - #(W64 1)) in
    (func_call #concurrency.concurrency #"waitDeletes"%go) "$a0" "$a1" "$a2" "$a3") in
    do:  ("err" <-[#error] "$r0");;;
    (if: (~ (interface.eq (![#error] "err") #interface.nil))
    then
      chan.select [chan.select_receive ((interface.get #"Done"%go (![#context.Context] "ctx")) #()) (λ: "$recvVal",
         do:  (let: "$a0" := ((method_call #clientv3 #"Client'ptr" #"Ctx" (![#ptrT] "client")) #()) in
         (method_call #concurrency.concurrency #"Election'ptr" #"Resign" (![#ptrT] "e")) "$a0")
         )] (chan.select_default (λ: <>,
        let: "$r0" := #null in
        do:  ((struct.field_ref #Election #"leaderSession"%go (![#ptrT] "e")) <-[#ptrT] "$r0")
        ));;;
      return: (![#error] "err")
    else do:  #());;;
    let: "$r0" := (![#ptrT] (struct.field_ref #clientv3.TxnResponse #"Header"%go (![#ptrT] "resp"))) in
    do:  ((struct.field_ref #Election #"hdr"%go (![#ptrT] "e")) <-[#ptrT] "$r0");;;
    return: (#interface.nil)).

(* Proclaim lets the leader announce a new value without another election.

   go: election.go:110:20 *)
Definition Election__Proclaim : val :=
  rec: "Election__Proclaim" "e" "ctx" "val" :=
    exception_do (let: "e" := (mem.alloc "e") in
    let: "val" := (mem.alloc "val") in
    let: "ctx" := (mem.alloc "ctx") in
    (if: (![#ptrT] (struct.field_ref #Election #"leaderSession"%go (![#ptrT] "e"))) = #null
    then return: (![#error] (globals.get #concurrency.concurrency #"ErrElectionNotLeader"%go))
    else do:  #());;;
    let: "client" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := ((method_call #concurrency.concurrency #"Session'ptr" #"Client" (![#ptrT] (struct.field_ref #Election #"session"%go (![#ptrT] "e")))) #()) in
    do:  ("client" <-[#ptrT] "$r0");;;
    let: "cmp" := (mem.alloc (type.zero_val #clientv3.Cmp)) in
    let: "$r0" := (let: "$a0" := (let: "$a0" := (![#stringT] (struct.field_ref #Election #"leaderKey"%go (![#ptrT] "e"))) in
    (func_call #v3.clientv3 #"CreateRevision"%go) "$a0") in
    let: "$a1" := #"="%go in
    let: "$a2" := (interface.make #""%go #"int64"%go (![#int64T] (struct.field_ref #Election #"leaderRev"%go (![#ptrT] "e")))) in
    (func_call #v3.clientv3 #"Compare"%go) "$a0" "$a1" "$a2") in
    do:  ("cmp" <-[#clientv3.Cmp] "$r0");;;
    let: "txn" := (mem.alloc (type.zero_val #clientv3.Txn)) in
    let: "$r0" := (let: "$a0" := ((let: "$sl0" := (![#clientv3.Cmp] "cmp") in
    slice.literal #clientv3.Cmp ["$sl0"])) in
    (interface.get #"If"%go (let: "$a0" := (![#context.Context] "ctx") in
    (method_call #clientv3 #"Client'ptr" #"Txn" (![#ptrT] "client")) "$a0")) "$a0") in
    do:  ("txn" <-[#clientv3.Txn] "$r0");;;
    let: "$r0" := (let: "$a0" := ((let: "$sl0" := (let: "$a0" := (![#stringT] (struct.field_ref #Election #"leaderKey"%go (![#ptrT] "e"))) in
    let: "$a1" := (![#stringT] "val") in
    let: "$a2" := ((let: "$sl0" := (let: "$a0" := ((method_call #concurrency.concurrency #"Session'ptr" #"Lease" (![#ptrT] (struct.field_ref #Election #"leaderSession"%go (![#ptrT] "e")))) #()) in
    (func_call #v3.clientv3 #"WithLease"%go) "$a0") in
    slice.literal #clientv3.OpOption ["$sl0"])) in
    (func_call #v3.clientv3 #"OpPut"%go) "$a0" "$a1" "$a2") in
    slice.literal #clientv3.Op ["$sl0"])) in
    (interface.get #"Then"%go (![#clientv3.Txn] "txn")) "$a0") in
    do:  ("txn" <-[#clientv3.Txn] "$r0");;;
    let: "terr" := (mem.alloc (type.zero_val #error)) in
    let: "tresp" := (mem.alloc (type.zero_val #ptrT)) in
    let: ("$ret0", "$ret1") := ((interface.get #"Commit"%go (![#clientv3.Txn] "txn")) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("tresp" <-[#ptrT] "$r0");;;
    do:  ("terr" <-[#error] "$r1");;;
    (if: (~ (interface.eq (![#error] "terr") #interface.nil))
    then return: (![#error] "terr")
    else do:  #());;;
    (if: (~ (![#boolT] (struct.field_ref #clientv3.TxnResponse #"Succeeded"%go (![#ptrT] "tresp"))))
    then
      let: "$r0" := #""%go in
      do:  ((struct.field_ref #Election #"leaderKey"%go (![#ptrT] "e")) <-[#stringT] "$r0");;;
      return: (![#error] (globals.get #concurrency.concurrency #"ErrElectionNotLeader"%go))
    else do:  #());;;
    let: "$r0" := (![#ptrT] (struct.field_ref #clientv3.TxnResponse #"Header"%go (![#ptrT] "tresp"))) in
    do:  ((struct.field_ref #Election #"hdr"%go (![#ptrT] "e")) <-[#ptrT] "$r0");;;
    return: (#interface.nil)).

(* Resign lets a leader start a new election.

   go: election.go:132:20 *)
Definition Election__Resign : val :=
  rec: "Election__Resign" "e" "ctx" :=
    exception_do (let: "err" := (mem.alloc (type.zero_val #error)) in
    let: "e" := (mem.alloc "e") in
    let: "ctx" := (mem.alloc "ctx") in
    (if: (![#ptrT] (struct.field_ref #Election #"leaderSession"%go (![#ptrT] "e"))) = #null
    then return: (#interface.nil)
    else do:  #());;;
    let: "client" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := ((method_call #concurrency.concurrency #"Session'ptr" #"Client" (![#ptrT] (struct.field_ref #Election #"session"%go (![#ptrT] "e")))) #()) in
    do:  ("client" <-[#ptrT] "$r0");;;
    let: "cmp" := (mem.alloc (type.zero_val #clientv3.Cmp)) in
    let: "$r0" := (let: "$a0" := (let: "$a0" := (![#stringT] (struct.field_ref #Election #"leaderKey"%go (![#ptrT] "e"))) in
    (func_call #v3.clientv3 #"CreateRevision"%go) "$a0") in
    let: "$a1" := #"="%go in
    let: "$a2" := (interface.make #""%go #"int64"%go (![#int64T] (struct.field_ref #Election #"leaderRev"%go (![#ptrT] "e")))) in
    (func_call #v3.clientv3 #"Compare"%go) "$a0" "$a1" "$a2") in
    do:  ("cmp" <-[#clientv3.Cmp] "$r0");;;
    let: "resp" := (mem.alloc (type.zero_val #ptrT)) in
    let: ("$ret0", "$ret1") := ((interface.get #"Commit"%go (let: "$a0" := ((let: "$sl0" := (let: "$a0" := (![#stringT] (struct.field_ref #Election #"leaderKey"%go (![#ptrT] "e"))) in
    let: "$a1" := #slice.nil in
    (func_call #v3.clientv3 #"OpDelete"%go) "$a0" "$a1") in
    slice.literal #clientv3.Op ["$sl0"])) in
    (interface.get #"Then"%go (let: "$a0" := ((let: "$sl0" := (![#clientv3.Cmp] "cmp") in
    slice.literal #clientv3.Cmp ["$sl0"])) in
    (interface.get #"If"%go (let: "$a0" := (![#context.Context] "ctx") in
    (method_call #clientv3 #"Client'ptr" #"Txn" (![#ptrT] "client")) "$a0")) "$a0")) "$a0")) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("resp" <-[#ptrT] "$r0");;;
    do:  ("err" <-[#error] "$r1");;;
    (if: interface.eq (![#error] "err") #interface.nil
    then
      let: "$r0" := (![#ptrT] (struct.field_ref #clientv3.TxnResponse #"Header"%go (![#ptrT] "resp"))) in
      do:  ((struct.field_ref #Election #"hdr"%go (![#ptrT] "e")) <-[#ptrT] "$r0")
    else do:  #());;;
    let: "$r0" := #""%go in
    do:  ((struct.field_ref #Election #"leaderKey"%go (![#ptrT] "e")) <-[#stringT] "$r0");;;
    let: "$r0" := #null in
    do:  ((struct.field_ref #Election #"leaderSession"%go (![#ptrT] "e")) <-[#ptrT] "$r0");;;
    return: (![#error] "err")).

(* Leader returns the leader value for the current election.

   go: election.go:148:20 *)
Definition Election__Leader : val :=
  rec: "Election__Leader" "e" "ctx" :=
    exception_do (let: "e" := (mem.alloc "e") in
    let: "ctx" := (mem.alloc "ctx") in
    let: "client" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := ((method_call #concurrency.concurrency #"Session'ptr" #"Client" (![#ptrT] (struct.field_ref #Election #"session"%go (![#ptrT] "e")))) #()) in
    do:  ("client" <-[#ptrT] "$r0");;;
    let: "err" := (mem.alloc (type.zero_val #error)) in
    let: "resp" := (mem.alloc (type.zero_val #ptrT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#context.Context] "ctx") in
    let: "$a1" := (![#stringT] (struct.field_ref #Election #"keyPrefix"%go (![#ptrT] "e"))) in
    let: "$a2" := ((func_call #v3.clientv3 #"WithFirstCreate"%go) #()) in
    (method_call #clientv3 #"Client'ptr" #"Get" (![#ptrT] "client")) "$a0" "$a1" "$a2") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("resp" <-[#ptrT] "$r0");;;
    do:  ("err" <-[#error] "$r1");;;
    (if: (~ (interface.eq (![#error] "err") #interface.nil))
    then return: (#null, ![#error] "err")
    else
      (if: (let: "$a0" := (![#sliceT] (struct.field_ref #clientv3.GetResponse #"Kvs"%go (![#ptrT] "resp"))) in
      slice.len "$a0") = #(W64 0)
      then return: (#null, ![#error] (globals.get #concurrency.concurrency #"ErrElectionNoLeader"%go))
      else do:  #()));;;
    return: (![#ptrT] "resp", #interface.nil)).

(* Observe returns a channel that reliably observes ordered leader proposals
   as GetResponse values on every current elected leader key. It will not
   necessarily fetch all historical leader updates, but will always post the
   most recent leader value.

   The channel closes when the context is canceled or the underlying watcher
   is otherwise disrupted.

   go: election.go:167:20 *)
Definition Election__Observe : val :=
  rec: "Election__Observe" "e" "ctx" :=
    exception_do (let: "e" := (mem.alloc "e") in
    let: "ctx" := (mem.alloc "ctx") in
    let: "retc" := (mem.alloc (type.zero_val (type.chanT #clientv3.GetResponse))) in
    let: "$r0" := (chan.make #clientv3.GetResponse #(W64 0)) in
    do:  ("retc" <-[type.chanT #clientv3.GetResponse] "$r0");;;
    let: "$a0" := (![#context.Context] "ctx") in
    let: "$a1" := (![type.chanT #clientv3.GetResponse] "retc") in
    let: "$go" := (method_call #concurrency.concurrency #"Election'ptr" #"observe" (![#ptrT] "e")) in
    do:  (Fork ("$go" "a0" "a1"));;;
    return: (![type.chanT #clientv3.GetResponse] "retc")).

(* go: election.go:173:20 *)
Definition Election__observe : val :=
  rec: "Election__observe" "e" "ctx" "ch" :=
    with_defer: (let: "e" := (mem.alloc "e") in
    let: "ch" := (mem.alloc "ch") in
    let: "ctx" := (mem.alloc "ctx") in
    let: "client" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := ((method_call #concurrency.concurrency #"Session'ptr" #"Client" (![#ptrT] (struct.field_ref #Election #"session"%go (![#ptrT] "e")))) #()) in
    do:  ("client" <-[#ptrT] "$r0");;;
    do:  (let: "$a0" := (![type.chanT #clientv3.GetResponse] "ch") in
    let: "$f" := chan.close in
    "$defer" <-[#funcT] (let: "$oldf" := (![#funcT] "$defer") in
    (λ: <>,
      "$f" "$a0";;
      "$oldf" #()
      )));;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "err" := (mem.alloc (type.zero_val #error)) in
      let: "resp" := (mem.alloc (type.zero_val #ptrT)) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![#context.Context] "ctx") in
      let: "$a1" := (![#stringT] (struct.field_ref #Election #"keyPrefix"%go (![#ptrT] "e"))) in
      let: "$a2" := ((func_call #v3.clientv3 #"WithFirstCreate"%go) #()) in
      (method_call #clientv3 #"Client'ptr" #"Get" (![#ptrT] "client")) "$a0" "$a1" "$a2") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("resp" <-[#ptrT] "$r0");;;
      do:  ("err" <-[#error] "$r1");;;
      (if: (~ (interface.eq (![#error] "err") #interface.nil))
      then return: (#())
      else do:  #());;;
      let: "kv" := (mem.alloc (type.zero_val #ptrT)) in
      let: "hdr" := (mem.alloc (type.zero_val #ptrT)) in
      (if: (let: "$a0" := (![#sliceT] (struct.field_ref #clientv3.GetResponse #"Kvs"%go (![#ptrT] "resp"))) in
      slice.len "$a0") = #(W64 0)
      then
        let: "cancel" := (mem.alloc (type.zero_val #context.CancelFunc)) in
        let: "cctx" := (mem.alloc (type.zero_val #context.Context)) in
        let: ("$ret0", "$ret1") := (let: "$a0" := (![#context.Context] "ctx") in
        (func_call #context.context #"WithCancel"%go) "$a0") in
        let: "$r0" := "$ret0" in
        let: "$r1" := "$ret1" in
        do:  ("cctx" <-[#context.Context] "$r0");;;
        do:  ("cancel" <-[#context.CancelFunc] "$r1");;;
        let: "opts" := (mem.alloc (type.zero_val #sliceT)) in
        let: "$r0" := ((let: "$sl0" := (let: "$a0" := (![#int64T] (struct.field_ref #etcdserverpb.ResponseHeader #"Revision"%go (![#ptrT] (struct.field_ref #clientv3.GetResponse #"Header"%go (![#ptrT] "resp"))))) in
        (func_call #v3.clientv3 #"WithRev"%go) "$a0") in
        let: "$sl1" := ((func_call #v3.clientv3 #"WithPrefix"%go) #()) in
        slice.literal #clientv3.OpOption ["$sl0"; "$sl1"])) in
        do:  ("opts" <-[#sliceT] "$r0");;;
        let: "wch" := (mem.alloc (type.zero_val #clientv3.WatchChan)) in
        let: "$r0" := (let: "$a0" := (![#context.Context] "cctx") in
        let: "$a1" := (![#stringT] (struct.field_ref #Election #"keyPrefix"%go (![#ptrT] "e"))) in
        let: "$a2" := (![#sliceT] "opts") in
        (method_call #clientv3 #"Client'ptr" #"Watch" (![#ptrT] "client")) "$a0" "$a1" "$a2") in
        do:  ("wch" <-[#clientv3.WatchChan] "$r0");;;
        (for: (λ: <>, (![#ptrT] "kv") = #null); (λ: <>, Skip) := λ: <>,
          let: "ok" := (mem.alloc (type.zero_val #boolT)) in
          let: "wr" := (mem.alloc (type.zero_val #clientv3.WatchResponse)) in
          let: ("$ret0", "$ret1") := (chan.receive (![#clientv3.WatchChan] "wch")) in
          let: "$r0" := "$ret0" in
          let: "$r1" := "$ret1" in
          do:  ("wr" <-[#clientv3.WatchResponse] "$r0");;;
          do:  ("ok" <-[#boolT] "$r1");;;
          (if: (~ (![#boolT] "ok")) || (~ (interface.eq ((method_call #clientv3 #"WatchResponse'ptr" #"Err" "wr") #()) #interface.nil))
          then
            do:  ((![#context.CancelFunc] "cancel") #());;;
            return: (#())
          else do:  #());;;
          let: "$range" := (![#sliceT] (struct.field_ref #clientv3.WatchResponse #"Events"%go "wr")) in
          (let: "ev" := (mem.alloc (type.zero_val #ptrT)) in
          slice.for_range #ptrT "$range" (λ: "$key" "$value",
            do:  ("ev" <-[#ptrT] "$value");;;
            do:  "$key";;;
            (if: (![#mvccpb.Event_EventType] (struct.field_ref #clientv3.Event #"Type"%go (![#ptrT] "ev"))) = mvccpb.PUT
            then
              let: "$r0" := (struct.field_ref #clientv3.WatchResponse #"Header"%go "wr") in
              let: "$r1" := (![#ptrT] (struct.field_ref #clientv3.Event #"Kv"%go (![#ptrT] "ev"))) in
              do:  ("hdr" <-[#ptrT] "$r0");;;
              do:  ("kv" <-[#ptrT] "$r1");;;
              let: "$r0" := (![#int64T] (struct.field_ref #mvccpb.KeyValue #"ModRevision"%go (![#ptrT] "kv"))) in
              do:  ((struct.field_ref #etcdserverpb.ResponseHeader #"Revision"%go (![#ptrT] "hdr")) <-[#int64T] "$r0");;;
              break: #()
            else do:  #()))));;;
        do:  ((![#context.CancelFunc] "cancel") #())
      else
        let: "$r0" := (![#ptrT] (struct.field_ref #clientv3.GetResponse #"Header"%go (![#ptrT] "resp"))) in
        let: "$r1" := (![#ptrT] (slice.elem_ref #ptrT (![#sliceT] (struct.field_ref #clientv3.GetResponse #"Kvs"%go (![#ptrT] "resp"))) #(W64 0))) in
        do:  ("hdr" <-[#ptrT] "$r0");;;
        do:  ("kv" <-[#ptrT] "$r1"));;;
      chan.select [chan.select_send (let: "$Header" := (![#ptrT] "hdr") in
       let: "$Kvs" := ((let: "$sl0" := (![#ptrT] "kv") in
       slice.literal #ptrT ["$sl0"])) in
       struct.make #clientv3.GetResponse [{
         "Header" ::= "$Header";
         "Kvs" ::= "$Kvs";
         "More" ::= type.zero_val #boolT;
         "Count" ::= type.zero_val #int64T;
         "XXX_NoUnkeyedLiteral" ::= type.zero_val (type.structT [
         ]);
         "XXX_unrecognized" ::= type.zero_val #sliceT;
         "XXX_sizecache" ::= type.zero_val #int32T
       }]) (![type.chanT #clientv3.GetResponse] "ch") (λ: <>,
         do:  #()
         ); chan.select_receive ((interface.get #"Done"%go (![#context.Context] "ctx")) #()) (λ: "$recvVal",
         return: (#())
         )] chan.select_no_default;;;
      let: "cancel" := (mem.alloc (type.zero_val #context.CancelFunc)) in
      let: "cctx" := (mem.alloc (type.zero_val #context.Context)) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![#context.Context] "ctx") in
      (func_call #context.context #"WithCancel"%go) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("cctx" <-[#context.Context] "$r0");;;
      do:  ("cancel" <-[#context.CancelFunc] "$r1");;;
      let: "wch" := (mem.alloc (type.zero_val #clientv3.WatchChan)) in
      let: "$r0" := (let: "$a0" := (![#context.Context] "cctx") in
      let: "$a1" := (string.from_bytes (![#sliceT] (struct.field_ref #mvccpb.KeyValue #"Key"%go (![#ptrT] "kv")))) in
      let: "$a2" := ((let: "$sl0" := (let: "$a0" := ((![#int64T] (struct.field_ref #etcdserverpb.ResponseHeader #"Revision"%go (![#ptrT] "hdr"))) + #(W64 1)) in
      (func_call #v3.clientv3 #"WithRev"%go) "$a0") in
      slice.literal #clientv3.OpOption ["$sl0"])) in
      (method_call #clientv3 #"Client'ptr" #"Watch" (![#ptrT] "client")) "$a0" "$a1" "$a2") in
      do:  ("wch" <-[#clientv3.WatchChan] "$r0");;;
      let: "keyDeleted" := (mem.alloc (type.zero_val #boolT)) in
      let: "$r0" := #false in
      do:  ("keyDeleted" <-[#boolT] "$r0");;;
      (for: (λ: <>, (~ (![#boolT] "keyDeleted"))); (λ: <>, Skip) := λ: <>,
        let: "ok" := (mem.alloc (type.zero_val #boolT)) in
        let: "wr" := (mem.alloc (type.zero_val #clientv3.WatchResponse)) in
        let: ("$ret0", "$ret1") := (chan.receive (![#clientv3.WatchChan] "wch")) in
        let: "$r0" := "$ret0" in
        let: "$r1" := "$ret1" in
        do:  ("wr" <-[#clientv3.WatchResponse] "$r0");;;
        do:  ("ok" <-[#boolT] "$r1");;;
        (if: (~ (![#boolT] "ok"))
        then
          do:  ((![#context.CancelFunc] "cancel") #());;;
          return: (#())
        else do:  #());;;
        let: "$range" := (![#sliceT] (struct.field_ref #clientv3.WatchResponse #"Events"%go "wr")) in
        (let: "ev" := (mem.alloc (type.zero_val #ptrT)) in
        slice.for_range #ptrT "$range" (λ: "$key" "$value",
          do:  ("ev" <-[#ptrT] "$value");;;
          do:  "$key";;;
          (if: (![#mvccpb.Event_EventType] (struct.field_ref #clientv3.Event #"Type"%go (![#ptrT] "ev"))) = mvccpb.DELETE
          then
            let: "$r0" := #true in
            do:  ("keyDeleted" <-[#boolT] "$r0");;;
            break: #()
          else do:  #());;;
          let: "$r0" := (struct.field_ref #clientv3.WatchResponse #"Header"%go "wr") in
          do:  ((struct.field_ref #clientv3.GetResponse #"Header"%go (![#ptrT] "resp")) <-[#ptrT] "$r0");;;
          let: "$r0" := ((let: "$sl0" := (![#ptrT] (struct.field_ref #clientv3.Event #"Kv"%go (![#ptrT] "ev"))) in
          slice.literal #ptrT ["$sl0"])) in
          do:  ((struct.field_ref #clientv3.GetResponse #"Kvs"%go (![#ptrT] "resp")) <-[#sliceT] "$r0");;;
          chan.select [chan.select_send (![#clientv3.GetResponse] (![#ptrT] "resp")) (![type.chanT #clientv3.GetResponse] "ch") (λ: <>,
             do:  #()
             ); chan.select_receive ((interface.get #"Done"%go (![#context.Context] "cctx")) #()) (λ: "$recvVal",
             do:  ((![#context.CancelFunc] "cancel") #());;;
             return: (#())
             )] chan.select_no_default)));;;
      do:  ((![#context.CancelFunc] "cancel") #()))).

(* Key returns the leader key if elected, empty string otherwise.

   go: election.go:248:20 *)
Definition Election__Key : val :=
  rec: "Election__Key" "e" <> :=
    exception_do (let: "e" := (mem.alloc "e") in
    return: (![#stringT] (struct.field_ref #Election #"leaderKey"%go (![#ptrT] "e")))).

(* Rev returns the leader key's creation revision, if elected.

   go: election.go:251:20 *)
Definition Election__Rev : val :=
  rec: "Election__Rev" "e" <> :=
    exception_do (let: "e" := (mem.alloc "e") in
    return: (![#int64T] (struct.field_ref #Election #"leaderRev"%go (![#ptrT] "e")))).

(* Header is the response header from the last successful election proposal.

   go: election.go:254:20 *)
Definition Election__Header : val :=
  rec: "Election__Header" "e" <> :=
    exception_do (let: "e" := (mem.alloc "e") in
    return: (![#ptrT] (struct.field_ref #Election #"hdr"%go (![#ptrT] "e")))).

(* go: key.go:25:6 *)
Definition waitDelete : val :=
  rec: "waitDelete" "ctx" "client" "key" "rev" :=
    with_defer: (let: "rev" := (mem.alloc "rev") in
    let: "key" := (mem.alloc "key") in
    let: "client" := (mem.alloc "client") in
    let: "ctx" := (mem.alloc "ctx") in
    let: "cancel" := (mem.alloc (type.zero_val #context.CancelFunc)) in
    let: "cctx" := (mem.alloc (type.zero_val #context.Context)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#context.Context] "ctx") in
    (func_call #context.context #"WithCancel"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("cctx" <-[#context.Context] "$r0");;;
    do:  ("cancel" <-[#context.CancelFunc] "$r1");;;
    do:  (let: "$f" := (![#context.CancelFunc] "cancel") in
    "$defer" <-[#funcT] (let: "$oldf" := (![#funcT] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    let: "wr" := (mem.alloc (type.zero_val #clientv3.WatchResponse)) in
    let: "wch" := (mem.alloc (type.zero_val #clientv3.WatchChan)) in
    let: "$r0" := (let: "$a0" := (![#context.Context] "cctx") in
    let: "$a1" := (![#stringT] "key") in
    let: "$a2" := ((let: "$sl0" := (let: "$a0" := (![#int64T] "rev") in
    (func_call #v3.clientv3 #"WithRev"%go) "$a0") in
    slice.literal #clientv3.OpOption ["$sl0"])) in
    (method_call #clientv3 #"Client'ptr" #"Watch" (![#ptrT] "client")) "$a0" "$a1" "$a2") in
    do:  ("wch" <-[#clientv3.WatchChan] "$r0");;;
    let: "$range" := (![#clientv3.WatchChan] "wch") in
    chan.for_range "$range" (λ: "$key",
      do:  ("wr" <-[#clientv3.WatchResponse] "$key");;;
      let: "$range" := (![#sliceT] (struct.field_ref #clientv3.WatchResponse #"Events"%go "wr")) in
      (let: "ev" := (mem.alloc (type.zero_val #ptrT)) in
      slice.for_range #ptrT "$range" (λ: "$key" "$value",
        do:  ("ev" <-[#ptrT] "$value");;;
        do:  "$key";;;
        (if: (![#mvccpb.Event_EventType] (struct.field_ref #clientv3.Event #"Type"%go (![#ptrT] "ev"))) = mvccpb.DELETE
        then return: (#interface.nil)
        else do:  #()))));;;
    (let: "err" := (mem.alloc (type.zero_val #error)) in
    let: "$r0" := ((method_call #clientv3 #"WatchResponse'ptr" #"Err" "wr") #()) in
    do:  ("err" <-[#error] "$r0");;;
    (if: (~ (interface.eq (![#error] "err") #interface.nil))
    then return: (![#error] "err")
    else do:  #()));;;
    (let: "err" := (mem.alloc (type.zero_val #error)) in
    let: "$r0" := ((interface.get #"Err"%go (![#context.Context] "ctx")) #()) in
    do:  ("err" <-[#error] "$r0");;;
    (if: (~ (interface.eq (![#error] "err") #interface.nil))
    then return: (![#error] "err")
    else do:  #()));;;
    return: (let: "$a0" := #"lost watcher waiting for delete"%go in
     (func_call #errors.errors #"New"%go) "$a0")).

(* waitDeletes efficiently waits until all keys matching the prefix and no greater
   than the create revision are deleted.

   go: key.go:49:6 *)
Definition waitDeletes : val :=
  rec: "waitDeletes" "ctx" "client" "pfx" "maxCreateRev" :=
    exception_do (let: "maxCreateRev" := (mem.alloc "maxCreateRev") in
    let: "pfx" := (mem.alloc "pfx") in
    let: "client" := (mem.alloc "client") in
    let: "ctx" := (mem.alloc "ctx") in
    let: "getOpts" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (let: "$a0" := ((func_call #v3.clientv3 #"WithLastCreate"%go) #()) in
    let: "$a1" := ((let: "$sl0" := (let: "$a0" := (![#int64T] "maxCreateRev") in
    (func_call #v3.clientv3 #"WithMaxCreateRev"%go) "$a0") in
    slice.literal #clientv3.OpOption ["$sl0"])) in
    (slice.append #clientv3.OpOption) "$a0" "$a1") in
    do:  ("getOpts" <-[#sliceT] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "err" := (mem.alloc (type.zero_val #error)) in
      let: "resp" := (mem.alloc (type.zero_val #ptrT)) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![#context.Context] "ctx") in
      let: "$a1" := (![#stringT] "pfx") in
      let: "$a2" := (![#sliceT] "getOpts") in
      (method_call #clientv3 #"Client'ptr" #"Get" (![#ptrT] "client")) "$a0" "$a1" "$a2") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("resp" <-[#ptrT] "$r0");;;
      do:  ("err" <-[#error] "$r1");;;
      (if: (~ (interface.eq (![#error] "err") #interface.nil))
      then return: (![#error] "err")
      else do:  #());;;
      (if: (let: "$a0" := (![#sliceT] (struct.field_ref #clientv3.GetResponse #"Kvs"%go (![#ptrT] "resp"))) in
      slice.len "$a0") = #(W64 0)
      then return: (#interface.nil)
      else do:  #());;;
      let: "lastKey" := (mem.alloc (type.zero_val #stringT)) in
      let: "$r0" := (string.from_bytes (![#sliceT] (struct.field_ref #mvccpb.KeyValue #"Key"%go (![#ptrT] (slice.elem_ref #ptrT (![#sliceT] (struct.field_ref #clientv3.GetResponse #"Kvs"%go (![#ptrT] "resp"))) #(W64 0)))))) in
      do:  ("lastKey" <-[#stringT] "$r0");;;
      (let: "$r0" := (let: "$a0" := (![#context.Context] "ctx") in
      let: "$a1" := (![#ptrT] "client") in
      let: "$a2" := (![#stringT] "lastKey") in
      let: "$a3" := (![#int64T] (struct.field_ref #etcdserverpb.ResponseHeader #"Revision"%go (![#ptrT] (struct.field_ref #clientv3.GetResponse #"Header"%go (![#ptrT] "resp"))))) in
      (func_call #concurrency.concurrency #"waitDelete"%go) "$a0" "$a1" "$a2" "$a3") in
      do:  ("err" <-[#error] "$r0");;;
      (if: (~ (interface.eq (![#error] "err") #interface.nil))
      then return: (![#error] "err")
      else do:  #())))).

Definition Mutex : go_type := structT [
  "s" :: ptrT;
  "pfx" :: stringT;
  "myKey" :: stringT;
  "myRev" :: int64T;
  "hdr" :: ptrT
].

(* go: mutex.go:45:6 *)
Definition NewMutex : val :=
  rec: "NewMutex" "s" "pfx" :=
    exception_do (let: "pfx" := (mem.alloc "pfx") in
    let: "s" := (mem.alloc "s") in
    return: (mem.alloc (struct.make #Mutex [{
       "s" ::= ![#ptrT] "s";
       "pfx" ::= (![#stringT] "pfx") + #"/"%go;
       "myKey" ::= #""%go;
       "myRev" ::= #(W64 (- 1));
       "hdr" ::= #null
     }]))).

(* TryLock locks the mutex if not already locked by another session.
   If lock is held by another session, return immediately after attempting necessary cleanup
   The ctx argument is used for the sending/receiving Txn RPC.

   go: mutex.go:52:17 *)
Definition Mutex__TryLock : val :=
  rec: "Mutex__TryLock" "m" "ctx" :=
    exception_do (let: "m" := (mem.alloc "m") in
    let: "ctx" := (mem.alloc "ctx") in
    let: "err" := (mem.alloc (type.zero_val #error)) in
    let: "resp" := (mem.alloc (type.zero_val #ptrT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#context.Context] "ctx") in
    (method_call #concurrency.concurrency #"Mutex'ptr" #"tryAcquire" (![#ptrT] "m")) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("resp" <-[#ptrT] "$r0");;;
    do:  ("err" <-[#error] "$r1");;;
    (if: (~ (interface.eq (![#error] "err") #interface.nil))
    then return: (![#error] "err")
    else do:  #());;;
    let: "ownerKey" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] (struct.field_ref #etcdserverpb.RangeResponse #"Kvs"%go ((method_call #etcdserverpb #"ResponseOp'ptr" #"GetResponseRange" (![#ptrT] (slice.elem_ref #ptrT (![#sliceT] (struct.field_ref #clientv3.TxnResponse #"Responses"%go (![#ptrT] "resp"))) #(W64 1)))) #()))) in
    do:  ("ownerKey" <-[#sliceT] "$r0");;;
    (if: ((let: "$a0" := (![#sliceT] "ownerKey") in
    slice.len "$a0") = #(W64 0)) || ((![#int64T] (struct.field_ref #mvccpb.KeyValue #"CreateRevision"%go (![#ptrT] (slice.elem_ref #ptrT (![#sliceT] "ownerKey") #(W64 0))))) = (![#int64T] (struct.field_ref #Mutex #"myRev"%go (![#ptrT] "m"))))
    then
      let: "$r0" := (![#ptrT] (struct.field_ref #clientv3.TxnResponse #"Header"%go (![#ptrT] "resp"))) in
      do:  ((struct.field_ref #Mutex #"hdr"%go (![#ptrT] "m")) <-[#ptrT] "$r0");;;
      return: (#interface.nil)
    else do:  #());;;
    let: "client" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := ((method_call #concurrency.concurrency #"Session'ptr" #"Client" (![#ptrT] (struct.field_ref #Mutex #"s"%go (![#ptrT] "m")))) #()) in
    do:  ("client" <-[#ptrT] "$r0");;;
    (let: "err" := (mem.alloc (type.zero_val #error)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#context.Context] "ctx") in
    let: "$a1" := (![#stringT] (struct.field_ref #Mutex #"myKey"%go (![#ptrT] "m"))) in
    let: "$a2" := #slice.nil in
    (method_call #clientv3 #"Client'ptr" #"Delete" (![#ptrT] "client")) "$a0" "$a1" "$a2") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  "$r0";;;
    do:  ("err" <-[#error] "$r1");;;
    (if: (~ (interface.eq (![#error] "err") #interface.nil))
    then return: (![#error] "err")
    else do:  #()));;;
    let: "$r0" := #" "%go in
    do:  ((struct.field_ref #Mutex #"myKey"%go (![#ptrT] "m")) <-[#stringT] "$r0");;;
    let: "$r0" := #(W64 (- 1)) in
    do:  ((struct.field_ref #Mutex #"myRev"%go (![#ptrT] "m")) <-[#int64T] "$r0");;;
    return: (![#error] (globals.get #concurrency.concurrency #"ErrLocked"%go))).

(* Lock locks the mutex with a cancelable context. If the context is canceled
   while trying to acquire the lock, the mutex tries to clean its stale lock entry.

   go: mutex.go:75:17 *)
Definition Mutex__Lock : val :=
  rec: "Mutex__Lock" "m" "ctx" :=
    exception_do (let: "m" := (mem.alloc "m") in
    let: "ctx" := (mem.alloc "ctx") in
    let: "err" := (mem.alloc (type.zero_val #error)) in
    let: "resp" := (mem.alloc (type.zero_val #ptrT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#context.Context] "ctx") in
    (method_call #concurrency.concurrency #"Mutex'ptr" #"tryAcquire" (![#ptrT] "m")) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("resp" <-[#ptrT] "$r0");;;
    do:  ("err" <-[#error] "$r1");;;
    (if: (~ (interface.eq (![#error] "err") #interface.nil))
    then return: (![#error] "err")
    else do:  #());;;
    let: "ownerKey" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (![#sliceT] (struct.field_ref #etcdserverpb.RangeResponse #"Kvs"%go ((method_call #etcdserverpb #"ResponseOp'ptr" #"GetResponseRange" (![#ptrT] (slice.elem_ref #ptrT (![#sliceT] (struct.field_ref #clientv3.TxnResponse #"Responses"%go (![#ptrT] "resp"))) #(W64 1)))) #()))) in
    do:  ("ownerKey" <-[#sliceT] "$r0");;;
    (if: ((let: "$a0" := (![#sliceT] "ownerKey") in
    slice.len "$a0") = #(W64 0)) || ((![#int64T] (struct.field_ref #mvccpb.KeyValue #"CreateRevision"%go (![#ptrT] (slice.elem_ref #ptrT (![#sliceT] "ownerKey") #(W64 0))))) = (![#int64T] (struct.field_ref #Mutex #"myRev"%go (![#ptrT] "m"))))
    then
      let: "$r0" := (![#ptrT] (struct.field_ref #clientv3.TxnResponse #"Header"%go (![#ptrT] "resp"))) in
      do:  ((struct.field_ref #Mutex #"hdr"%go (![#ptrT] "m")) <-[#ptrT] "$r0");;;
      return: (#interface.nil)
    else do:  #());;;
    let: "client" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := ((method_call #concurrency.concurrency #"Session'ptr" #"Client" (![#ptrT] (struct.field_ref #Mutex #"s"%go (![#ptrT] "m")))) #()) in
    do:  ("client" <-[#ptrT] "$r0");;;
    let: "werr" := (mem.alloc (type.zero_val #error)) in
    let: "$r0" := (let: "$a0" := (![#context.Context] "ctx") in
    let: "$a1" := (![#ptrT] "client") in
    let: "$a2" := (![#stringT] (struct.field_ref #Mutex #"pfx"%go (![#ptrT] "m"))) in
    let: "$a3" := ((![#int64T] (struct.field_ref #Mutex #"myRev"%go (![#ptrT] "m"))) - #(W64 1)) in
    (func_call #concurrency.concurrency #"waitDeletes"%go) "$a0" "$a1" "$a2" "$a3") in
    do:  ("werr" <-[#error] "$r0");;;
    (if: (~ (interface.eq (![#error] "werr") #interface.nil))
    then
      do:  (let: "$a0" := ((method_call #clientv3 #"Client'ptr" #"Ctx" (![#ptrT] "client")) #()) in
      (method_call #concurrency.concurrency #"Mutex'ptr" #"Unlock" (![#ptrT] "m")) "$a0");;;
      return: (![#error] "werr")
    else do:  #());;;
    let: "gresp" := (mem.alloc (type.zero_val #ptrT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#context.Context] "ctx") in
    let: "$a1" := (![#stringT] (struct.field_ref #Mutex #"myKey"%go (![#ptrT] "m"))) in
    let: "$a2" := #slice.nil in
    (method_call #clientv3 #"Client'ptr" #"Get" (![#ptrT] "client")) "$a0" "$a1" "$a2") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("gresp" <-[#ptrT] "$r0");;;
    do:  ("werr" <-[#error] "$r1");;;
    (if: (~ (interface.eq (![#error] "werr") #interface.nil))
    then
      do:  (let: "$a0" := ((method_call #clientv3 #"Client'ptr" #"Ctx" (![#ptrT] "client")) #()) in
      (method_call #concurrency.concurrency #"Mutex'ptr" #"Unlock" (![#ptrT] "m")) "$a0");;;
      return: (![#error] "werr")
    else do:  #());;;
    (if: (let: "$a0" := (![#sliceT] (struct.field_ref #clientv3.GetResponse #"Kvs"%go (![#ptrT] "gresp"))) in
    slice.len "$a0") = #(W64 0)
    then return: (![#error] (globals.get #concurrency.concurrency #"ErrSessionExpired"%go))
    else do:  #());;;
    let: "$r0" := (![#ptrT] (struct.field_ref #clientv3.GetResponse #"Header"%go (![#ptrT] "gresp"))) in
    do:  ((struct.field_ref #Mutex #"hdr"%go (![#ptrT] "m")) <-[#ptrT] "$r0");;;
    return: (#interface.nil)).

(* go: mutex.go:111:17 *)
Definition Mutex__tryAcquire : val :=
  rec: "Mutex__tryAcquire" "m" "ctx" :=
    exception_do (let: "m" := (mem.alloc "m") in
    let: "ctx" := (mem.alloc "ctx") in
    let: "s" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (![#ptrT] (struct.field_ref #Mutex #"s"%go (![#ptrT] "m"))) in
    do:  ("s" <-[#ptrT] "$r0");;;
    let: "client" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := ((method_call #concurrency.concurrency #"Session'ptr" #"Client" (![#ptrT] (struct.field_ref #Mutex #"s"%go (![#ptrT] "m")))) #()) in
    do:  ("client" <-[#ptrT] "$r0");;;
    let: "$r0" := (let: "$a0" := #"%s%x"%go in
    let: "$a1" := ((let: "$sl0" := (interface.make #""%go #"string"%go (![#stringT] (struct.field_ref #Mutex #"pfx"%go (![#ptrT] "m")))) in
    let: "$sl1" := (interface.make #clientv3 #"LeaseID" ((method_call #concurrency.concurrency #"Session'ptr" #"Lease" (![#ptrT] "s")) #())) in
    slice.literal #interfaceT ["$sl0"; "$sl1"])) in
    (func_call #fmt.fmt #"Sprintf"%go) "$a0" "$a1") in
    do:  ((struct.field_ref #Mutex #"myKey"%go (![#ptrT] "m")) <-[#stringT] "$r0");;;
    let: "cmp" := (mem.alloc (type.zero_val #clientv3.Cmp)) in
    let: "$r0" := (let: "$a0" := (let: "$a0" := (![#stringT] (struct.field_ref #Mutex #"myKey"%go (![#ptrT] "m"))) in
    (func_call #v3.clientv3 #"CreateRevision"%go) "$a0") in
    let: "$a1" := #"="%go in
    let: "$a2" := (interface.make #""%go #"int"%go #(W64 0)) in
    (func_call #v3.clientv3 #"Compare"%go) "$a0" "$a1" "$a2") in
    do:  ("cmp" <-[#clientv3.Cmp] "$r0");;;
    let: "put" := (mem.alloc (type.zero_val #clientv3.Op)) in
    let: "$r0" := (let: "$a0" := (![#stringT] (struct.field_ref #Mutex #"myKey"%go (![#ptrT] "m"))) in
    let: "$a1" := #""%go in
    let: "$a2" := ((let: "$sl0" := (let: "$a0" := ((method_call #concurrency.concurrency #"Session'ptr" #"Lease" (![#ptrT] "s")) #()) in
    (func_call #v3.clientv3 #"WithLease"%go) "$a0") in
    slice.literal #clientv3.OpOption ["$sl0"])) in
    (func_call #v3.clientv3 #"OpPut"%go) "$a0" "$a1" "$a2") in
    do:  ("put" <-[#clientv3.Op] "$r0");;;
    let: "get" := (mem.alloc (type.zero_val #clientv3.Op)) in
    let: "$r0" := (let: "$a0" := (![#stringT] (struct.field_ref #Mutex #"myKey"%go (![#ptrT] "m"))) in
    let: "$a1" := #slice.nil in
    (func_call #v3.clientv3 #"OpGet"%go) "$a0" "$a1") in
    do:  ("get" <-[#clientv3.Op] "$r0");;;
    let: "getOwner" := (mem.alloc (type.zero_val #clientv3.Op)) in
    let: "$r0" := (let: "$a0" := (![#stringT] (struct.field_ref #Mutex #"pfx"%go (![#ptrT] "m"))) in
    let: "$a1" := ((func_call #v3.clientv3 #"WithFirstCreate"%go) #()) in
    (func_call #v3.clientv3 #"OpGet"%go) "$a0" "$a1") in
    do:  ("getOwner" <-[#clientv3.Op] "$r0");;;
    let: "err" := (mem.alloc (type.zero_val #error)) in
    let: "resp" := (mem.alloc (type.zero_val #ptrT)) in
    let: ("$ret0", "$ret1") := ((interface.get #"Commit"%go (let: "$a0" := ((let: "$sl0" := (![#clientv3.Op] "get") in
    let: "$sl1" := (![#clientv3.Op] "getOwner") in
    slice.literal #clientv3.Op ["$sl0"; "$sl1"])) in
    (interface.get #"Else"%go (let: "$a0" := ((let: "$sl0" := (![#clientv3.Op] "put") in
    let: "$sl1" := (![#clientv3.Op] "getOwner") in
    slice.literal #clientv3.Op ["$sl0"; "$sl1"])) in
    (interface.get #"Then"%go (let: "$a0" := ((let: "$sl0" := (![#clientv3.Cmp] "cmp") in
    slice.literal #clientv3.Cmp ["$sl0"])) in
    (interface.get #"If"%go (let: "$a0" := (![#context.Context] "ctx") in
    (method_call #clientv3 #"Client'ptr" #"Txn" (![#ptrT] "client")) "$a0")) "$a0")) "$a0")) "$a0")) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("resp" <-[#ptrT] "$r0");;;
    do:  ("err" <-[#error] "$r1");;;
    (if: (~ (interface.eq (![#error] "err") #interface.nil))
    then return: (#null, ![#error] "err")
    else do:  #());;;
    let: "$r0" := (![#int64T] (struct.field_ref #etcdserverpb.ResponseHeader #"Revision"%go (![#ptrT] (struct.field_ref #clientv3.TxnResponse #"Header"%go (![#ptrT] "resp"))))) in
    do:  ((struct.field_ref #Mutex #"myRev"%go (![#ptrT] "m")) <-[#int64T] "$r0");;;
    (if: (~ (![#boolT] (struct.field_ref #clientv3.TxnResponse #"Succeeded"%go (![#ptrT] "resp"))))
    then
      let: "$r0" := (![#int64T] (struct.field_ref #mvccpb.KeyValue #"CreateRevision"%go (![#ptrT] (slice.elem_ref #ptrT (![#sliceT] (struct.field_ref #etcdserverpb.RangeResponse #"Kvs"%go ((method_call #etcdserverpb #"ResponseOp'ptr" #"GetResponseRange" (![#ptrT] (slice.elem_ref #ptrT (![#sliceT] (struct.field_ref #clientv3.TxnResponse #"Responses"%go (![#ptrT] "resp"))) #(W64 0)))) #()))) #(W64 0))))) in
      do:  ((struct.field_ref #Mutex #"myRev"%go (![#ptrT] "m")) <-[#int64T] "$r0")
    else do:  #());;;
    return: (![#ptrT] "resp", #interface.nil)).

(* go: mutex.go:134:17 *)
Definition Mutex__Unlock : val :=
  rec: "Mutex__Unlock" "m" "ctx" :=
    exception_do (let: "m" := (mem.alloc "m") in
    let: "ctx" := (mem.alloc "ctx") in
    (if: (((![#stringT] (struct.field_ref #Mutex #"myKey"%go (![#ptrT] "m"))) = #""%go) || (int_leq (![#int64T] (struct.field_ref #Mutex #"myRev"%go (![#ptrT] "m"))) #(W64 0))) || ((![#stringT] (struct.field_ref #Mutex #"myKey"%go (![#ptrT] "m"))) = #" "%go)
    then return: (![#error] (globals.get #concurrency.concurrency #"ErrLockReleased"%go))
    else do:  #());;;
    (if: (~ (let: "$a0" := (![#stringT] (struct.field_ref #Mutex #"myKey"%go (![#ptrT] "m"))) in
    let: "$a1" := (![#stringT] (struct.field_ref #Mutex #"pfx"%go (![#ptrT] "m"))) in
    (func_call #strings.strings #"HasPrefix"%go) "$a0" "$a1"))
    then
      return: (let: "$a0" := #"invalid key %q, it should have prefix %q"%go in
       let: "$a1" := ((let: "$sl0" := (interface.make #""%go #"string"%go (![#stringT] (struct.field_ref #Mutex #"myKey"%go (![#ptrT] "m")))) in
       let: "$sl1" := (interface.make #""%go #"string"%go (![#stringT] (struct.field_ref #Mutex #"pfx"%go (![#ptrT] "m")))) in
       slice.literal #interfaceT ["$sl0"; "$sl1"])) in
       (func_call #fmt.fmt #"Errorf"%go) "$a0" "$a1")
    else do:  #());;;
    let: "client" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := ((method_call #concurrency.concurrency #"Session'ptr" #"Client" (![#ptrT] (struct.field_ref #Mutex #"s"%go (![#ptrT] "m")))) #()) in
    do:  ("client" <-[#ptrT] "$r0");;;
    (let: "err" := (mem.alloc (type.zero_val #error)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#context.Context] "ctx") in
    let: "$a1" := (![#stringT] (struct.field_ref #Mutex #"myKey"%go (![#ptrT] "m"))) in
    let: "$a2" := #slice.nil in
    (method_call #clientv3 #"Client'ptr" #"Delete" (![#ptrT] "client")) "$a0" "$a1" "$a2") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  "$r0";;;
    do:  ("err" <-[#error] "$r1");;;
    (if: (~ (interface.eq (![#error] "err") #interface.nil))
    then return: (![#error] "err")
    else do:  #()));;;
    let: "$r0" := #" "%go in
    do:  ((struct.field_ref #Mutex #"myKey"%go (![#ptrT] "m")) <-[#stringT] "$r0");;;
    let: "$r0" := #(W64 (- 1)) in
    do:  ((struct.field_ref #Mutex #"myRev"%go (![#ptrT] "m")) <-[#int64T] "$r0");;;
    return: (#interface.nil)).

(* go: mutex.go:152:17 *)
Definition Mutex__IsOwner : val :=
  rec: "Mutex__IsOwner" "m" <> :=
    exception_do (let: "m" := (mem.alloc "m") in
    return: (let: "$a0" := (let: "$a0" := (![#stringT] (struct.field_ref #Mutex #"myKey"%go (![#ptrT] "m"))) in
     (func_call #v3.clientv3 #"CreateRevision"%go) "$a0") in
     let: "$a1" := #"="%go in
     let: "$a2" := (interface.make #""%go #"int64"%go (![#int64T] (struct.field_ref #Mutex #"myRev"%go (![#ptrT] "m")))) in
     (func_call #v3.clientv3 #"Compare"%go) "$a0" "$a1" "$a2")).

(* go: mutex.go:156:17 *)
Definition Mutex__Key : val :=
  rec: "Mutex__Key" "m" <> :=
    exception_do (let: "m" := (mem.alloc "m") in
    return: (![#stringT] (struct.field_ref #Mutex #"myKey"%go (![#ptrT] "m")))).

(* Header is the response header received from etcd on acquiring the lock.

   go: mutex.go:159:17 *)
Definition Mutex__Header : val :=
  rec: "Mutex__Header" "m" <> :=
    exception_do (let: "m" := (mem.alloc "m") in
    return: (![#ptrT] (struct.field_ref #Mutex #"hdr"%go (![#ptrT] "m")))).

Definition lockerMutex : go_type := structT [
  "Mutex" :: ptrT
].

(* go: mutex.go:163:24 *)
Definition lockerMutex__Lock : val :=
  rec: "lockerMutex__Lock" "lm" <> :=
    exception_do (let: "lm" := (mem.alloc "lm") in
    let: "client" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := ((method_call #concurrency.concurrency #"Session'ptr" #"Client" (![#ptrT] (struct.field_ref #Mutex #"s"%go (![#ptrT] (struct.field_ref #lockerMutex #"Mutex"%go (![#ptrT] "lm")))))) #()) in
    do:  ("client" <-[#ptrT] "$r0");;;
    (let: "err" := (mem.alloc (type.zero_val #error)) in
    let: "$r0" := (let: "$a0" := ((method_call #clientv3 #"Client'ptr" #"Ctx" (![#ptrT] "client")) #()) in
    (method_call #concurrency.concurrency #"Mutex'ptr" #"Lock" (![#ptrT] (struct.field_ref #lockerMutex #"Mutex"%go (![#ptrT] "lm")))) "$a0") in
    do:  ("err" <-[#error] "$r0");;;
    (if: (~ (interface.eq (![#error] "err") #interface.nil))
    then
      do:  (let: "$a0" := (![#error] "err") in
      Panic "$a0")
    else do:  #()))).

(* go: mutex.go:170:24 *)
Definition lockerMutex__Unlock : val :=
  rec: "lockerMutex__Unlock" "lm" <> :=
    exception_do (let: "lm" := (mem.alloc "lm") in
    let: "client" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := ((method_call #concurrency.concurrency #"Session'ptr" #"Client" (![#ptrT] (struct.field_ref #Mutex #"s"%go (![#ptrT] (struct.field_ref #lockerMutex #"Mutex"%go (![#ptrT] "lm")))))) #()) in
    do:  ("client" <-[#ptrT] "$r0");;;
    (let: "err" := (mem.alloc (type.zero_val #error)) in
    let: "$r0" := (let: "$a0" := ((method_call #clientv3 #"Client'ptr" #"Ctx" (![#ptrT] "client")) #()) in
    (method_call #concurrency.concurrency #"Mutex'ptr" #"Unlock" (![#ptrT] (struct.field_ref #lockerMutex #"Mutex"%go (![#ptrT] "lm")))) "$a0") in
    do:  ("err" <-[#error] "$r0");;;
    (if: (~ (interface.eq (![#error] "err") #interface.nil))
    then
      do:  (let: "$a0" := (![#error] "err") in
      Panic "$a0")
    else do:  #()))).

(* NewLocker creates a sync.Locker backed by an etcd mutex.

   go: mutex.go:178:6 *)
Definition NewLocker : val :=
  rec: "NewLocker" "s" "pfx" :=
    exception_do (let: "pfx" := (mem.alloc "pfx") in
    let: "s" := (mem.alloc "s") in
    return: (interface.make #concurrency.concurrency #"lockerMutex'ptr" (mem.alloc (struct.make #lockerMutex [{
       "Mutex" ::= let: "$a0" := (![#ptrT] "s") in
       let: "$a1" := (![#stringT] "pfx") in
       (func_call #concurrency.concurrency #"NewMutex"%go) "$a0" "$a1"
     }])))).

Definition defaultSessionTTL : Z := 60.

Definition sessionOptions : go_type := structT [
  "ttl" :: intT;
  "leaseID" :: clientv3.LeaseID;
  "ctx" :: context.Context
].

Definition SessionOption : go_type := funcT.

(* NewSession gets the leased session for a client.

   go: session.go:41:6 *)
Definition NewSession : val :=
  rec: "NewSession" "client" "opts" :=
    exception_do (let: "opts" := (mem.alloc "opts") in
    let: "client" := (mem.alloc "client") in
    let: "lg" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := ((method_call #clientv3 #"Client'ptr" #"GetLogger" (![#ptrT] "client")) #()) in
    do:  ("lg" <-[#ptrT] "$r0");;;
    let: "ops" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (let: "$ttl" := #(W64 defaultSessionTTL) in
    let: "$ctx" := ((method_call #clientv3 #"Client'ptr" #"Ctx" (![#ptrT] "client")) #()) in
    struct.make #sessionOptions [{
      "ttl" ::= "$ttl";
      "leaseID" ::= type.zero_val #clientv3.LeaseID;
      "ctx" ::= "$ctx"
    }])) in
    do:  ("ops" <-[#ptrT] "$r0");;;
    let: "$range" := (![#sliceT] "opts") in
    (let: "opt" := (mem.alloc (type.zero_val #SessionOption)) in
    slice.for_range #SessionOption "$range" (λ: "$key" "$value",
      do:  ("opt" <-[#SessionOption] "$value");;;
      do:  "$key";;;
      do:  (let: "$a0" := (![#ptrT] "ops") in
      let: "$a1" := (![#ptrT] "lg") in
      (![#SessionOption] "opt") "$a0" "$a1")));;;
    let: "id" := (mem.alloc (type.zero_val #clientv3.LeaseID)) in
    let: "$r0" := (![#clientv3.LeaseID] (struct.field_ref #sessionOptions #"leaseID"%go (![#ptrT] "ops"))) in
    do:  ("id" <-[#clientv3.LeaseID] "$r0");;;
    (if: (![#clientv3.LeaseID] "id") = clientv3.NoLease
    then
      let: "err" := (mem.alloc (type.zero_val #error)) in
      let: "resp" := (mem.alloc (type.zero_val #ptrT)) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![#context.Context] (struct.field_ref #sessionOptions #"ctx"%go (![#ptrT] "ops"))) in
      let: "$a1" := (s_to_w64 (![#intT] (struct.field_ref #sessionOptions #"ttl"%go (![#ptrT] "ops")))) in
      (method_call #clientv3 #"Client'ptr" #"Grant" (![#ptrT] "client")) "$a0" "$a1") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("resp" <-[#ptrT] "$r0");;;
      do:  ("err" <-[#error] "$r1");;;
      (if: (~ (interface.eq (![#error] "err") #interface.nil))
      then return: (#null, ![#error] "err")
      else do:  #());;;
      let: "$r0" := (![#clientv3.LeaseID] (struct.field_ref #clientv3.LeaseGrantResponse #"ID"%go (![#ptrT] "resp"))) in
      do:  ("id" <-[#clientv3.LeaseID] "$r0")
    else do:  #());;;
    let: "cancel" := (mem.alloc (type.zero_val #context.CancelFunc)) in
    let: "ctx" := (mem.alloc (type.zero_val #context.Context)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#context.Context] (struct.field_ref #sessionOptions #"ctx"%go (![#ptrT] "ops"))) in
    (func_call #context.context #"WithCancel"%go) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("ctx" <-[#context.Context] "$r0");;;
    do:  ("cancel" <-[#context.CancelFunc] "$r1");;;
    let: "err" := (mem.alloc (type.zero_val #error)) in
    let: "keepAlive" := (mem.alloc (type.zero_val (type.chanT #ptrT))) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#context.Context] "ctx") in
    let: "$a1" := (![#clientv3.LeaseID] "id") in
    (method_call #clientv3 #"Client'ptr" #"KeepAlive" (![#ptrT] "client")) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("keepAlive" <-[type.chanT #ptrT] "$r0");;;
    do:  ("err" <-[#error] "$r1");;;
    (if: (~ (interface.eq (![#error] "err") #interface.nil)) || ((![type.chanT #ptrT] "keepAlive") = #null)
    then
      do:  ((![#context.CancelFunc] "cancel") #());;;
      return: (#null, ![#error] "err")
    else do:  #());;;
    let: "donec" := (mem.alloc (type.zero_val (type.chanT (type.structT [
    ])))) in
    let: "$r0" := (chan.make (type.structT [
    ]) #(W64 0)) in
    do:  ("donec" <-[type.chanT (type.structT [
    ])] "$r0");;;
    let: "s" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (let: "$client" := (![#ptrT] "client") in
    let: "$opts" := (![#ptrT] "ops") in
    let: "$id" := (![#clientv3.LeaseID] "id") in
    let: "$ctx" := (![#context.Context] "ctx") in
    let: "$cancel" := (![#context.CancelFunc] "cancel") in
    let: "$donec" := (![type.chanT (type.structT [
    ])] "donec") in
    struct.make #Session [{
      "client" ::= "$client";
      "opts" ::= "$opts";
      "id" ::= "$id";
      "ctx" ::= "$ctx";
      "cancel" ::= "$cancel";
      "donec" ::= "$donec"
    }])) in
    do:  ("s" <-[#ptrT] "$r0");;;
    let: "$go" := (λ: <>,
      with_defer: (do:  (let: "$f" := (λ: <>,
        exception_do (do:  (let: "$a0" := (![type.chanT (type.structT [
        ])] "donec") in
        chan.close "$a0");;;
        do:  ((![#context.CancelFunc] "cancel") #()))
        ) in
      "$defer" <-[#funcT] (let: "$oldf" := (![#funcT] "$defer") in
      (λ: <>,
        "$f" #();;
        "$oldf" #()
        )));;;
      let: "$range" := (![type.chanT #ptrT] "keepAlive") in
      chan.for_range "$range" (λ: "$key",
        do:  #()))
      ) in
    do:  (Fork ("$go" #()));;;
    return: (![#ptrT] "s", #interface.nil)).

(* Client is the etcd client that is attached to the session.

   go: session.go:82:19 *)
Definition Session__Client : val :=
  rec: "Session__Client" "s" <> :=
    exception_do (let: "s" := (mem.alloc "s") in
    return: (![#ptrT] (struct.field_ref #Session #"client"%go (![#ptrT] "s")))).

(* Lease is the lease ID for keys bound to the session.

   go: session.go:87:19 *)
Definition Session__Lease : val :=
  rec: "Session__Lease" "s" <> :=
    exception_do (let: "s" := (mem.alloc "s") in
    return: (![#clientv3.LeaseID] (struct.field_ref #Session #"id"%go (![#ptrT] "s")))).

(* Ctx is the context attached to the session, it is canceled when the lease is orphaned, expires, or
   is otherwise no longer being refreshed.

   go: session.go:91:19 *)
Definition Session__Ctx : val :=
  rec: "Session__Ctx" "s" <> :=
    exception_do (let: "s" := (mem.alloc "s") in
    return: (![#context.Context] (struct.field_ref #Session #"ctx"%go (![#ptrT] "s")))).

(* Done returns a channel that closes when the lease is orphaned, expires, or
   is otherwise no longer being refreshed.

   go: session.go:97:19 *)
Definition Session__Done : val :=
  rec: "Session__Done" "s" <> :=
    exception_do (let: "s" := (mem.alloc "s") in
    return: (![type.chanT (type.structT [
     ])] (struct.field_ref #Session #"donec"%go (![#ptrT] "s")))).

(* Orphan ends the refresh for the session lease. This is useful
   in case the state of the client connection is indeterminate (revoke
   would fail) or when transferring lease ownership.

   go: session.go:102:19 *)
Definition Session__Orphan : val :=
  rec: "Session__Orphan" "s" <> :=
    exception_do (let: "s" := (mem.alloc "s") in
    do:  ((![#context.CancelFunc] (struct.field_ref #Session #"cancel"%go (![#ptrT] "s"))) #());;;
    do:  (Fst (chan.receive (![type.chanT (type.structT [
    ])] (struct.field_ref #Session #"donec"%go (![#ptrT] "s")))))).

(* Close orphans the session and revokes the session lease.

   go: session.go:108:19 *)
Definition Session__Close : val :=
  rec: "Session__Close" "s" <> :=
    exception_do (let: "s" := (mem.alloc "s") in
    do:  ((method_call #concurrency.concurrency #"Session'ptr" #"Orphan" (![#ptrT] "s")) #());;;
    let: "cancel" := (mem.alloc (type.zero_val #context.CancelFunc)) in
    let: "ctx" := (mem.alloc (type.zero_val #context.Context)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#context.Context] (struct.field_ref #sessionOptions #"ctx"%go (![#ptrT] (struct.field_ref #Session #"opts"%go (![#ptrT] "s"))))) in
    let: "$a1" := ((s_to_w64 (![#intT] (struct.field_ref #sessionOptions #"ttl"%go (![#ptrT] (struct.field_ref #Session #"opts"%go (![#ptrT] "s")))))) * time.Second) in
    (func_call #context.context #"WithTimeout"%go) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("ctx" <-[#context.Context] "$r0");;;
    do:  ("cancel" <-[#context.CancelFunc] "$r1");;;
    let: "err" := (mem.alloc (type.zero_val #error)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![#context.Context] "ctx") in
    let: "$a1" := (![#clientv3.LeaseID] (struct.field_ref #Session #"id"%go (![#ptrT] "s"))) in
    (method_call #clientv3 #"Client'ptr" #"Revoke" (![#ptrT] (struct.field_ref #Session #"client"%go (![#ptrT] "s")))) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  "$r0";;;
    do:  ("err" <-[#error] "$r1");;;
    do:  ((![#context.CancelFunc] "cancel") #());;;
    return: (![#error] "err")).

(* WithTTL configures the session's TTL in seconds.
   If TTL is <= 0, the default 60 seconds TTL will be used.

   go: session.go:128:6 *)
Definition WithTTL : val :=
  rec: "WithTTL" "ttl" :=
    exception_do (let: "ttl" := (mem.alloc "ttl") in
    return: ((λ: "so" "lg",
       exception_do (let: "lg" := (mem.alloc "lg") in
       let: "so" := (mem.alloc "so") in
       (if: int_gt (![#intT] "ttl") #(W64 0)
       then
         let: "$r0" := (![#intT] "ttl") in
         do:  ((struct.field_ref #sessionOptions #"ttl"%go (![#ptrT] "so")) <-[#intT] "$r0")
       else
         do:  (let: "$a0" := #"WithTTL(): TTL should be > 0, preserving current TTL"%go in
         let: "$a1" := ((let: "$sl0" := (let: "$a0" := #"current-session-ttl"%go in
         let: "$a1" := (s_to_w64 (![#intT] (struct.field_ref #sessionOptions #"ttl"%go (![#ptrT] "so")))) in
         (func_call #zap.zap #"Int64"%go) "$a0" "$a1") in
         slice.literal #zapcore.Field ["$sl0"])) in
         (method_call #zap #"Logger'ptr" #"Warn" (![#ptrT] "lg")) "$a0" "$a1")))
       ))).

(* WithLease specifies the existing leaseID to be used for the session.
   This is useful in process restart scenario, for example, to reclaim
   leadership from an election prior to restart.

   go: session.go:141:6 *)
Definition WithLease : val :=
  rec: "WithLease" "leaseID" :=
    exception_do (let: "leaseID" := (mem.alloc "leaseID") in
    return: ((λ: "so" <>,
       exception_do (let: "so" := (mem.alloc "so") in
       let: "$r0" := (![#clientv3.LeaseID] "leaseID") in
       do:  ((struct.field_ref #sessionOptions #"leaseID"%go (![#ptrT] "so")) <-[#clientv3.LeaseID] "$r0"))
       ))).

(* WithContext assigns a context to the session instead of defaulting to
   using the client context. This is useful for canceling NewSession and
   Close operations immediately without having to close the client. If the
   context is canceled before Close() completes, the session's lease will be
   abandoned and left to expire instead of being revoked.

   go: session.go:152:6 *)
Definition WithContext : val :=
  rec: "WithContext" "ctx" :=
    exception_do (let: "ctx" := (mem.alloc "ctx") in
    return: ((λ: "so" <>,
       exception_do (let: "so" := (mem.alloc "so") in
       let: "$r0" := (![#context.Context] "ctx") in
       do:  ((struct.field_ref #sessionOptions #"ctx"%go (![#ptrT] "so")) <-[#context.Context] "$r0"))
       ))).

Definition STM : go_type := interfaceT.

Definition Isolation : go_type := intT.

Definition SerializableSnapshot : expr := #(W64 0).

Definition Serializable : expr := #(W64 1).

Definition RepeatableReads : expr := #(W64 2).

Definition ReadCommitted : expr := #(W64 3).

Definition stmError : go_type := structT [
  "err" :: error
].

Definition stmOptions : go_type := structT [
  "iso" :: Isolation;
  "ctx" :: context.Context;
  "prefetch" :: sliceT
].

Definition stmOption : go_type := funcT.

(* WithIsolation specifies the transaction isolation level.

   go: stm.go:71:6 *)
Definition WithIsolation : val :=
  rec: "WithIsolation" "lvl" :=
    exception_do (let: "lvl" := (mem.alloc "lvl") in
    return: ((λ: "so",
       exception_do (let: "so" := (mem.alloc "so") in
       let: "$r0" := (![#Isolation] "lvl") in
       do:  ((struct.field_ref #stmOptions #"iso"%go (![#ptrT] "so")) <-[#Isolation] "$r0"))
       ))).

(* WithAbortContext specifies the context for permanently aborting the transaction.

   go: stm.go:76:6 *)
Definition WithAbortContext : val :=
  rec: "WithAbortContext" "ctx" :=
    exception_do (let: "ctx" := (mem.alloc "ctx") in
    return: ((λ: "so",
       exception_do (let: "so" := (mem.alloc "so") in
       let: "$r0" := (![#context.Context] "ctx") in
       do:  ((struct.field_ref #stmOptions #"ctx"%go (![#ptrT] "so")) <-[#context.Context] "$r0"))
       ))).

(* WithPrefetch is a hint to prefetch a list of keys before trying to apply.
   If an STM transaction will unconditionally fetch a set of keys, prefetching
   those keys will save the round-trip cost from requesting each key one by one
   with Get().

   go: stm.go:84:6 *)
Definition WithPrefetch : val :=
  rec: "WithPrefetch" "keys" :=
    exception_do (let: "keys" := (mem.alloc "keys") in
    return: ((λ: "so",
       exception_do (let: "so" := (mem.alloc "so") in
       let: "$r0" := (let: "$a0" := (![#sliceT] (struct.field_ref #stmOptions #"prefetch"%go (![#ptrT] "so"))) in
       let: "$a1" := (![#sliceT] "keys") in
       (slice.append #stringT) "$a0" "$a1") in
       do:  ((struct.field_ref #stmOptions #"prefetch"%go (![#ptrT] "so")) <-[#sliceT] "$r0"))
       ))).

(* NewSTM initiates a new STM instance, using serializable snapshot isolation by default.

   go: stm.go:89:6 *)
Definition NewSTM : val :=
  rec: "NewSTM" "c" "apply" "so" :=
    exception_do (let: "so" := (mem.alloc "so") in
    let: "apply" := (mem.alloc "apply") in
    let: "c" := (mem.alloc "c") in
    let: "opts" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (mem.alloc (let: "$ctx" := ((method_call #clientv3 #"Client'ptr" #"Ctx" (![#ptrT] "c")) #()) in
    struct.make #stmOptions [{
      "iso" ::= type.zero_val #Isolation;
      "ctx" ::= "$ctx";
      "prefetch" ::= type.zero_val #sliceT
    }])) in
    do:  ("opts" <-[#ptrT] "$r0");;;
    let: "$range" := (![#sliceT] "so") in
    (let: "f" := (mem.alloc (type.zero_val #stmOption)) in
    slice.for_range #stmOption "$range" (λ: "$key" "$value",
      do:  ("f" <-[#stmOption] "$value");;;
      do:  "$key";;;
      do:  (let: "$a0" := (![#ptrT] "opts") in
      (![#stmOption] "f") "$a0")));;;
    (if: (let: "$a0" := (![#sliceT] (struct.field_ref #stmOptions #"prefetch"%go (![#ptrT] "opts"))) in
    slice.len "$a0") ≠ #(W64 0)
    then
      let: "f" := (mem.alloc (type.zero_val #funcT)) in
      let: "$r0" := (![#funcT] "apply") in
      do:  ("f" <-[#funcT] "$r0");;;
      let: "$r0" := (λ: "s",
        exception_do (let: "s" := (mem.alloc "s") in
        do:  (let: "$a0" := (![#sliceT] (struct.field_ref #stmOptions #"prefetch"%go (![#ptrT] "opts"))) in
        (interface.get #"Get"%go (![#STM] "s")) "$a0");;;
        return: (let: "$a0" := (![#STM] "s") in
         (![#funcT] "f") "$a0"))
        ) in
      do:  ("apply" <-[#funcT] "$r0")
    else do:  #());;;
    let: ("$ret0", "$ret1") := ((let: "$a0" := (let: "$a0" := (![#ptrT] "c") in
    let: "$a1" := (![#ptrT] "opts") in
    (func_call #concurrency.concurrency #"mkSTM"%go) "$a0" "$a1") in
    let: "$a1" := (![#funcT] "apply") in
    (func_call #concurrency.concurrency #"runSTM"%go) "$a0" "$a1")) in
    return: ("$ret0", "$ret1")).

Definition readSet : go_type := mapT stringT ptrT.

Definition stmPut : go_type := structT [
  "val" :: stringT;
  "op" :: clientv3.Op
].

Definition writeSet : go_type := mapT stringT stmPut.

Definition stm : go_type := structT [
  "client" :: ptrT;
  "ctx" :: context.Context;
  "rset" :: readSet;
  "wset" :: writeSet;
  "getOpts" :: sliceT;
  "conflicts" :: funcT
].

Definition stmSerializable : go_type := structT [
  "stm" :: stm;
  "prefetch" :: mapT stringT ptrT
].

(* go: stm.go:104:6 *)
Definition mkSTM : val :=
  rec: "mkSTM" "c" "opts" :=
    exception_do (let: "opts" := (mem.alloc "opts") in
    let: "c" := (mem.alloc "c") in
    let: "$sw" := (![#Isolation] (struct.field_ref #stmOptions #"iso"%go (![#ptrT] "opts"))) in
    (if: "$sw" = SerializableSnapshot
    then
      let: "s" := (mem.alloc (type.zero_val #ptrT)) in
      let: "$r0" := (mem.alloc (let: "$stm" := (let: "$client" := (![#ptrT] "c") in
      let: "$ctx" := (![#context.Context] (struct.field_ref #stmOptions #"ctx"%go (![#ptrT] "opts"))) in
      struct.make #stm [{
        "client" ::= "$client";
        "ctx" ::= "$ctx";
        "rset" ::= type.zero_val #readSet;
        "wset" ::= type.zero_val #writeSet;
        "getOpts" ::= type.zero_val #sliceT;
        "conflicts" ::= type.zero_val #funcT
      }]) in
      let: "$prefetch" := (map.make #stringT #ptrT) in
      struct.make #stmSerializable [{
        "stm" ::= "$stm";
        "prefetch" ::= "$prefetch"
      }])) in
      do:  ("s" <-[#ptrT] "$r0");;;
      let: "$r0" := (λ: <>,
        exception_do (return: (let: "$a0" := ((method_call #concurrency.concurrency #"readSet" #"cmps" (![#readSet] (struct.field_ref #stm #"rset"%go (struct.field_ref #stmSerializable #"stm"%go (![#ptrT] "s"))))) #()) in
         let: "$a1" := (let: "$a0" := (((method_call #concurrency.concurrency #"readSet" #"first" (![#readSet] (struct.field_ref #stm #"rset"%go (struct.field_ref #stmSerializable #"stm"%go (![#ptrT] "s"))))) #()) + #(W64 1)) in
         (method_call #concurrency.concurrency #"writeSet" #"cmps" (![#writeSet] (struct.field_ref #stm #"wset"%go (struct.field_ref #stmSerializable #"stm"%go (![#ptrT] "s"))))) "$a0") in
         (slice.append #clientv3.Cmp) "$a0" "$a1"))
        ) in
      do:  ((struct.field_ref #stm #"conflicts"%go (struct.field_ref #stmSerializable #"stm"%go (![#ptrT] "s"))) <-[#funcT] "$r0");;;
      return: (interface.make #concurrency.concurrency #"stmSerializable'ptr" (![#ptrT] "s"))
    else
      (if: "$sw" = Serializable
      then
        let: "s" := (mem.alloc (type.zero_val #ptrT)) in
        let: "$r0" := (mem.alloc (let: "$stm" := (let: "$client" := (![#ptrT] "c") in
        let: "$ctx" := (![#context.Context] (struct.field_ref #stmOptions #"ctx"%go (![#ptrT] "opts"))) in
        struct.make #stm [{
          "client" ::= "$client";
          "ctx" ::= "$ctx";
          "rset" ::= type.zero_val #readSet;
          "wset" ::= type.zero_val #writeSet;
          "getOpts" ::= type.zero_val #sliceT;
          "conflicts" ::= type.zero_val #funcT
        }]) in
        let: "$prefetch" := (map.make #stringT #ptrT) in
        struct.make #stmSerializable [{
          "stm" ::= "$stm";
          "prefetch" ::= "$prefetch"
        }])) in
        do:  ("s" <-[#ptrT] "$r0");;;
        let: "$r0" := (λ: <>,
          exception_do (return: ((method_call #concurrency.concurrency #"readSet" #"cmps" (![#readSet] (struct.field_ref #stm #"rset"%go (struct.field_ref #stmSerializable #"stm"%go (![#ptrT] "s"))))) #()))
          ) in
        do:  ((struct.field_ref #stm #"conflicts"%go (struct.field_ref #stmSerializable #"stm"%go (![#ptrT] "s"))) <-[#funcT] "$r0");;;
        return: (interface.make #concurrency.concurrency #"stmSerializable'ptr" (![#ptrT] "s"))
      else
        (if: "$sw" = RepeatableReads
        then
          let: "s" := (mem.alloc (type.zero_val #ptrT)) in
          let: "$r0" := (mem.alloc (let: "$client" := (![#ptrT] "c") in
          let: "$ctx" := (![#context.Context] (struct.field_ref #stmOptions #"ctx"%go (![#ptrT] "opts"))) in
          let: "$getOpts" := ((let: "$sl0" := ((func_call #v3.clientv3 #"WithSerializable"%go) #()) in
          slice.literal #clientv3.OpOption ["$sl0"])) in
          struct.make #stm [{
            "client" ::= "$client";
            "ctx" ::= "$ctx";
            "rset" ::= type.zero_val #readSet;
            "wset" ::= type.zero_val #writeSet;
            "getOpts" ::= "$getOpts";
            "conflicts" ::= type.zero_val #funcT
          }])) in
          do:  ("s" <-[#ptrT] "$r0");;;
          let: "$r0" := (λ: <>,
            exception_do (return: ((method_call #concurrency.concurrency #"readSet" #"cmps" (![#readSet] (struct.field_ref #stm #"rset"%go (![#ptrT] "s")))) #()))
            ) in
          do:  ((struct.field_ref #stm #"conflicts"%go (![#ptrT] "s")) <-[#funcT] "$r0");;;
          return: (interface.make #concurrency.concurrency #"stm'ptr" (![#ptrT] "s"))
        else
          (if: "$sw" = ReadCommitted
          then
            let: "s" := (mem.alloc (type.zero_val #ptrT)) in
            let: "$r0" := (mem.alloc (let: "$client" := (![#ptrT] "c") in
            let: "$ctx" := (![#context.Context] (struct.field_ref #stmOptions #"ctx"%go (![#ptrT] "opts"))) in
            let: "$getOpts" := ((let: "$sl0" := ((func_call #v3.clientv3 #"WithSerializable"%go) #()) in
            slice.literal #clientv3.OpOption ["$sl0"])) in
            struct.make #stm [{
              "client" ::= "$client";
              "ctx" ::= "$ctx";
              "rset" ::= type.zero_val #readSet;
              "wset" ::= type.zero_val #writeSet;
              "getOpts" ::= "$getOpts";
              "conflicts" ::= type.zero_val #funcT
            }])) in
            do:  ("s" <-[#ptrT] "$r0");;;
            let: "$r0" := (λ: <>,
              exception_do (return: (#slice.nil))
              ) in
            do:  ((struct.field_ref #stm #"conflicts"%go (![#ptrT] "s")) <-[#funcT] "$r0");;;
            return: (interface.make #concurrency.concurrency #"stm'ptr" (![#ptrT] "s"))
          else
            do:  (let: "$a0" := (interface.make #""%go #"string"%go #"unsupported stm"%go) in
            Panic "$a0")))))).

Definition stmResponse : go_type := structT [
  "resp" :: ptrT;
  "err" :: error
].

(* go: stm.go:140:6 *)
Definition runSTM : val :=
  rec: "runSTM" "s" "apply" :=
    exception_do (let: "apply" := (mem.alloc "apply") in
    let: "s" := (mem.alloc "s") in
    let: "outc" := (mem.alloc (type.zero_val (type.chanT #stmResponse))) in
    let: "$r0" := (chan.make #stmResponse #(W64 1)) in
    do:  ("outc" <-[type.chanT #stmResponse] "$r0");;;
    let: "$go" := (λ: <>,
      with_defer: (do:  (let: "$f" := (λ: <>,
        exception_do ((let: "r" := (mem.alloc (type.zero_val #interfaceT)) in
        let: "$r0" := (recover #()) in
        do:  ("r" <-[#interfaceT] "$r0");;;
        (if: (~ (interface.eq (![#interfaceT] "r") #interface.nil))
        then
          let: "ok" := (mem.alloc (type.zero_val #boolT)) in
          let: "e" := (mem.alloc (type.zero_val #stmError)) in
          let: ("$ret0", "$ret1") := (![#interfaceT] "r") in
          let: "$r0" := "$ret0" in
          let: "$r1" := "$ret1" in
          do:  ("e" <-[#stmError] "$r0");;;
          do:  ("ok" <-[#boolT] "$r1");;;
          (if: (~ (![#boolT] "ok"))
          then
            do:  (let: "$a0" := (![#interfaceT] "r") in
            Panic "$a0")
          else do:  #());;;
          do:  (let: "$chan" := (![type.chanT #stmResponse] "outc") in
          let: "$v" := (struct.make #stmResponse [{
            "resp" ::= #null;
            "err" ::= ![#error] (struct.field_ref #stmError #"err"%go "e")
          }]) in
          chan.send "$chan" "$v")
        else do:  #())))
        ) in
      "$defer" <-[#funcT] (let: "$oldf" := (![#funcT] "$defer") in
      (λ: <>,
        "$f" #();;
        "$oldf" #()
        )));;;
      let: "out" := (mem.alloc (type.zero_val #stmResponse)) in
      (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
        do:  ((interface.get #"reset"%go (![#STM] "s")) #());;;
        (let: "$r0" := (let: "$a0" := (![#STM] "s") in
        (![#funcT] "apply") "$a0") in
        do:  ((struct.field_ref #stmResponse #"err"%go "out") <-[#error] "$r0");;;
        (if: (~ (interface.eq (![#error] (struct.field_ref #stmResponse #"err"%go "out")) #interface.nil))
        then break: #()
        else do:  #()));;;
        (let: "$r0" := ((interface.get #"commit"%go (![#STM] "s")) #()) in
        do:  ((struct.field_ref #stmResponse #"resp"%go "out") <-[#ptrT] "$r0");;;
        (if: (![#ptrT] (struct.field_ref #stmResponse #"resp"%go "out")) ≠ #null
        then break: #()
        else do:  #())));;;
      do:  (let: "$chan" := (![type.chanT #stmResponse] "outc") in
      let: "$v" := (![#stmResponse] "out") in
      chan.send "$chan" "$v"))
      ) in
    do:  (Fork ("$go" #()));;;
    let: "r" := (mem.alloc (type.zero_val #stmResponse)) in
    let: "$r0" := (Fst (chan.receive (![type.chanT #stmResponse] "outc"))) in
    do:  ("r" <-[#stmResponse] "$r0");;;
    return: (![#ptrT] (struct.field_ref #stmResponse #"resp"%go "r"), ![#error] (struct.field_ref #stmResponse #"err"%go "r"))).

(* go: stm.go:190:19 *)
Definition readSet__add : val :=
  rec: "readSet__add" "rs" "keys" "txnresp" :=
    exception_do (let: "rs" := (mem.alloc "rs") in
    let: "txnresp" := (mem.alloc "txnresp") in
    let: "keys" := (mem.alloc "keys") in
    let: "$range" := (![#sliceT] (struct.field_ref #clientv3.TxnResponse #"Responses"%go (![#ptrT] "txnresp"))) in
    (let: "resp" := (mem.alloc (type.zero_val #ptrT)) in
    let: "i" := (mem.alloc (type.zero_val #intT)) in
    slice.for_range #ptrT "$range" (λ: "$key" "$value",
      do:  ("resp" <-[#ptrT] "$value");;;
      do:  ("i" <-[#intT] "$key");;;
      let: "$r0" := ((method_call #etcdserverpb #"ResponseOp'ptr" #"GetResponseRange" (![#ptrT] "resp")) #()) in
      do:  (map.insert (![#readSet] "rs") (![#stringT] (slice.elem_ref #stringT (![#sliceT] "keys") (![#intT] "i"))) "$r0")))).

(* first returns the store revision from the first fetch

   go: stm.go:197:19 *)
Definition readSet__first : val :=
  rec: "readSet__first" "rs" <> :=
    exception_do (let: "rs" := (mem.alloc "rs") in
    let: "ret" := (mem.alloc (type.zero_val #int64T)) in
    let: "$r0" := #(W64 (math.MaxInt64 - 1)) in
    do:  ("ret" <-[#int64T] "$r0");;;
    let: "$range" := (![#readSet] "rs") in
    (let: "resp" := (mem.alloc (type.zero_val #ptrT)) in
    map.for_range "$range" (λ: "$key" "value",
      do:  ("resp" <-[#ptrT] "$value");;;
      do:  "$key";;;
      (let: "rev" := (mem.alloc (type.zero_val #int64T)) in
      let: "$r0" := (![#int64T] (struct.field_ref #etcdserverpb.ResponseHeader #"Revision"%go (![#ptrT] (struct.field_ref #clientv3.GetResponse #"Header"%go (![#ptrT] "resp"))))) in
      do:  ("rev" <-[#int64T] "$r0");;;
      (if: int_lt (![#int64T] "rev") (![#int64T] "ret")
      then
        let: "$r0" := (![#int64T] "rev") in
        do:  ("ret" <-[#int64T] "$r0")
      else do:  #()))));;;
    return: (![#int64T] "ret")).

(* cmps guards the txn from updates to read set

   go: stm.go:208:19 *)
Definition readSet__cmps : val :=
  rec: "readSet__cmps" "rs" <> :=
    exception_do (let: "rs" := (mem.alloc "rs") in
    let: "cmps" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make3 #clientv3.Cmp #(W64 0) (let: "$a0" := (![#readSet] "rs") in
    map.len "$a0")) in
    do:  ("cmps" <-[#sliceT] "$r0");;;
    let: "$range" := (![#readSet] "rs") in
    (let: "rk" := (mem.alloc (type.zero_val #ptrT)) in
    let: "k" := (mem.alloc (type.zero_val #stringT)) in
    map.for_range "$range" (λ: "$key" "value",
      do:  ("rk" <-[#ptrT] "$value");;;
      do:  ("k" <-[#stringT] "$key");;;
      let: "$r0" := (let: "$a0" := (![#sliceT] "cmps") in
      let: "$a1" := ((let: "$sl0" := (let: "$a0" := (![#stringT] "k") in
      let: "$a1" := (![#ptrT] "rk") in
      (func_call #concurrency.concurrency #"isKeyCurrent"%go) "$a0" "$a1") in
      slice.literal #clientv3.Cmp ["$sl0"])) in
      (slice.append #clientv3.Cmp) "$a0" "$a1") in
      do:  ("cmps" <-[#sliceT] "$r0")));;;
    return: (![#sliceT] "cmps")).

(* go: stm.go:218:20 *)
Definition writeSet__get : val :=
  rec: "writeSet__get" "ws" "keys" :=
    exception_do (let: "ws" := (mem.alloc "ws") in
    let: "keys" := (mem.alloc "keys") in
    let: "$range" := (![#sliceT] "keys") in
    (let: "key" := (mem.alloc (type.zero_val #stringT)) in
    slice.for_range #stringT "$range" (λ: "$key" "$value",
      do:  ("key" <-[#stringT] "$value");;;
      do:  "$key";;;
      (let: "ok" := (mem.alloc (type.zero_val #boolT)) in
      let: "wv" := (mem.alloc (type.zero_val #stmPut)) in
      let: ("$ret0", "$ret1") := (map.get (![#writeSet] "ws") (![#stringT] "key")) in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("wv" <-[#stmPut] "$r0");;;
      do:  ("ok" <-[#boolT] "$r1");;;
      (if: ![#boolT] "ok"
      then return: ("wv")
      else do:  #()))));;;
    return: (#null)).

(* cmps returns a cmp list testing no writes have happened past rev

   go: stm.go:228:20 *)
Definition writeSet__cmps : val :=
  rec: "writeSet__cmps" "ws" "rev" :=
    exception_do (let: "ws" := (mem.alloc "ws") in
    let: "rev" := (mem.alloc "rev") in
    let: "cmps" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make3 #clientv3.Cmp #(W64 0) (let: "$a0" := (![#writeSet] "ws") in
    map.len "$a0")) in
    do:  ("cmps" <-[#sliceT] "$r0");;;
    let: "$range" := (![#writeSet] "ws") in
    (let: "key" := (mem.alloc (type.zero_val #stringT)) in
    map.for_range "$range" (λ: "$key" "value",
      do:  ("key" <-[#stringT] "$key");;;
      let: "$r0" := (let: "$a0" := (![#sliceT] "cmps") in
      let: "$a1" := ((let: "$sl0" := (let: "$a0" := (let: "$a0" := (![#stringT] "key") in
      (func_call #v3.clientv3 #"ModRevision"%go) "$a0") in
      let: "$a1" := #"<"%go in
      let: "$a2" := (interface.make #""%go #"int64"%go (![#int64T] "rev")) in
      (func_call #v3.clientv3 #"Compare"%go) "$a0" "$a1" "$a2") in
      slice.literal #clientv3.Cmp ["$sl0"])) in
      (slice.append #clientv3.Cmp) "$a0" "$a1") in
      do:  ("cmps" <-[#sliceT] "$r0")));;;
    return: (![#sliceT] "cmps")).

(* puts is the list of ops for all pending writes

   go: stm.go:237:20 *)
Definition writeSet__puts : val :=
  rec: "writeSet__puts" "ws" <> :=
    exception_do (let: "ws" := (mem.alloc "ws") in
    let: "puts" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make3 #clientv3.Op #(W64 0) (let: "$a0" := (![#writeSet] "ws") in
    map.len "$a0")) in
    do:  ("puts" <-[#sliceT] "$r0");;;
    let: "$range" := (![#writeSet] "ws") in
    (let: "v" := (mem.alloc (type.zero_val #stmPut)) in
    map.for_range "$range" (λ: "$key" "value",
      do:  ("v" <-[#stmPut] "$value");;;
      do:  "$key";;;
      let: "$r0" := (let: "$a0" := (![#sliceT] "puts") in
      let: "$a1" := ((let: "$sl0" := (![#clientv3.Op] (struct.field_ref #stmPut #"op"%go "v")) in
      slice.literal #clientv3.Op ["$sl0"])) in
      (slice.append #clientv3.Op) "$a0" "$a1") in
      do:  ("puts" <-[#sliceT] "$r0")));;;
    return: (![#sliceT] "puts")).

(* go: stm.go:245:15 *)
Definition stm__Get : val :=
  rec: "stm__Get" "s" "keys" :=
    exception_do (let: "s" := (mem.alloc "s") in
    let: "keys" := (mem.alloc "keys") in
    (let: "wv" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "keys") in
    (method_call #concurrency.concurrency #"writeSet" #"get" (![#writeSet] (struct.field_ref #stm #"wset"%go (![#ptrT] "s")))) "$a0") in
    do:  ("wv" <-[#ptrT] "$r0");;;
    (if: (![#ptrT] "wv") ≠ #null
    then return: (![#stringT] (struct.field_ref #stmPut #"val"%go (![#ptrT] "wv")))
    else do:  #()));;;
    return: (let: "$a0" := (let: "$a0" := (![#sliceT] "keys") in
     (method_call #concurrency.concurrency #"stm'ptr" #"fetch" (![#ptrT] "s")) "$a0") in
     (func_call #concurrency.concurrency #"respToValue"%go) "$a0")).

(* go: stm.go:252:15 *)
Definition stm__Put : val :=
  rec: "stm__Put" "s" "key" "val" "opts" :=
    exception_do (let: "s" := (mem.alloc "s") in
    let: "opts" := (mem.alloc "opts") in
    let: "val" := (mem.alloc "val") in
    let: "key" := (mem.alloc "key") in
    let: "$r0" := (struct.make #stmPut [{
      "val" ::= ![#stringT] "val";
      "op" ::= let: "$a0" := (![#stringT] "key") in
      let: "$a1" := (![#stringT] "val") in
      let: "$a2" := (![#sliceT] "opts") in
      (func_call #v3.clientv3 #"OpPut"%go) "$a0" "$a1" "$a2"
    }]) in
    do:  (map.insert (![#writeSet] (struct.field_ref #stm #"wset"%go (![#ptrT] "s"))) (![#stringT] "key") "$r0")).

(* go: stm.go:256:15 *)
Definition stm__Del : val :=
  rec: "stm__Del" "s" "key" :=
    exception_do (let: "s" := (mem.alloc "s") in
    let: "key" := (mem.alloc "key") in
    let: "$r0" := (struct.make #stmPut [{
      "val" ::= #""%go;
      "op" ::= let: "$a0" := (![#stringT] "key") in
      let: "$a1" := #slice.nil in
      (func_call #v3.clientv3 #"OpDelete"%go) "$a0" "$a1"
    }]) in
    do:  (map.insert (![#writeSet] (struct.field_ref #stm #"wset"%go (![#ptrT] "s"))) (![#stringT] "key") "$r0")).

(* go: stm.go:258:15 *)
Definition stm__Rev : val :=
  rec: "stm__Rev" "s" "key" :=
    exception_do (let: "s" := (mem.alloc "s") in
    let: "key" := (mem.alloc "key") in
    (let: "resp" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := ((let: "$sl0" := (![#stringT] "key") in
    slice.literal #stringT ["$sl0"])) in
    (method_call #concurrency.concurrency #"stm'ptr" #"fetch" (![#ptrT] "s")) "$a0") in
    do:  ("resp" <-[#ptrT] "$r0");;;
    (if: ((![#ptrT] "resp") ≠ #null) && ((let: "$a0" := (![#sliceT] (struct.field_ref #clientv3.GetResponse #"Kvs"%go (![#ptrT] "resp"))) in
    slice.len "$a0") ≠ #(W64 0))
    then return: (![#int64T] (struct.field_ref #mvccpb.KeyValue #"ModRevision"%go (![#ptrT] (slice.elem_ref #ptrT (![#sliceT] (struct.field_ref #clientv3.GetResponse #"Kvs"%go (![#ptrT] "resp"))) #(W64 0)))))
    else do:  #()));;;
    return: (#(W64 0))).

(* go: stm.go:265:15 *)
Definition stm__commit : val :=
  rec: "stm__commit" "s" <> :=
    exception_do (let: "s" := (mem.alloc "s") in
    let: "err" := (mem.alloc (type.zero_val #error)) in
    let: "txnresp" := (mem.alloc (type.zero_val #ptrT)) in
    let: ("$ret0", "$ret1") := ((interface.get #"Commit"%go (let: "$a0" := ((method_call #concurrency.concurrency #"writeSet" #"puts" (![#writeSet] (struct.field_ref #stm #"wset"%go (![#ptrT] "s")))) #()) in
    (interface.get #"Then"%go (let: "$a0" := ((![#funcT] (struct.field_ref #stm #"conflicts"%go (![#ptrT] "s"))) #()) in
    (interface.get #"If"%go (let: "$a0" := (![#context.Context] (struct.field_ref #stm #"ctx"%go (![#ptrT] "s"))) in
    (method_call #clientv3 #"Client'ptr" #"Txn" (![#ptrT] (struct.field_ref #stm #"client"%go (![#ptrT] "s")))) "$a0")) "$a0")) "$a0")) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("txnresp" <-[#ptrT] "$r0");;;
    do:  ("err" <-[#error] "$r1");;;
    (if: (~ (interface.eq (![#error] "err") #interface.nil))
    then
      do:  (let: "$a0" := (interface.make #concurrency.concurrency #"stmError" (struct.make #stmError [{
        "err" ::= ![#error] "err"
      }])) in
      Panic "$a0")
    else do:  #());;;
    (if: ![#boolT] (struct.field_ref #clientv3.TxnResponse #"Succeeded"%go (![#ptrT] "txnresp"))
    then return: (![#ptrT] "txnresp")
    else do:  #());;;
    return: (#null)).

(* go: stm.go:276:15 *)
Definition stm__fetch : val :=
  rec: "stm__fetch" "s" "keys" :=
    exception_do (let: "s" := (mem.alloc "s") in
    let: "keys" := (mem.alloc "keys") in
    (if: (let: "$a0" := (![#sliceT] "keys") in
    slice.len "$a0") = #(W64 0)
    then return: (#null)
    else do:  #());;;
    let: "ops" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make2 #clientv3.Op (let: "$a0" := (![#sliceT] "keys") in
    slice.len "$a0")) in
    do:  ("ops" <-[#sliceT] "$r0");;;
    let: "$range" := (![#sliceT] "keys") in
    (let: "key" := (mem.alloc (type.zero_val #stringT)) in
    let: "i" := (mem.alloc (type.zero_val #intT)) in
    slice.for_range #stringT "$range" (λ: "$key" "$value",
      do:  ("key" <-[#stringT] "$value");;;
      do:  ("i" <-[#intT] "$key");;;
      (let: "ok" := (mem.alloc (type.zero_val #boolT)) in
      let: "resp" := (mem.alloc (type.zero_val #ptrT)) in
      let: ("$ret0", "$ret1") := (map.get (![#readSet] (struct.field_ref #stm #"rset"%go (![#ptrT] "s"))) (![#stringT] "key")) in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("resp" <-[#ptrT] "$r0");;;
      do:  ("ok" <-[#boolT] "$r1");;;
      (if: ![#boolT] "ok"
      then return: (![#ptrT] "resp")
      else do:  #()));;;
      let: "$r0" := (let: "$a0" := (![#stringT] "key") in
      let: "$a1" := (![#sliceT] (struct.field_ref #stm #"getOpts"%go (![#ptrT] "s"))) in
      (func_call #v3.clientv3 #"OpGet"%go) "$a0" "$a1") in
      do:  ((slice.elem_ref #clientv3.Op (![#sliceT] "ops") (![#intT] "i")) <-[#clientv3.Op] "$r0")));;;
    let: "err" := (mem.alloc (type.zero_val #error)) in
    let: "txnresp" := (mem.alloc (type.zero_val #ptrT)) in
    let: ("$ret0", "$ret1") := ((interface.get #"Commit"%go (let: "$a0" := (![#sliceT] "ops") in
    (interface.get #"Then"%go (let: "$a0" := (![#context.Context] (struct.field_ref #stm #"ctx"%go (![#ptrT] "s"))) in
    (method_call #clientv3 #"Client'ptr" #"Txn" (![#ptrT] (struct.field_ref #stm #"client"%go (![#ptrT] "s")))) "$a0")) "$a0")) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("txnresp" <-[#ptrT] "$r0");;;
    do:  ("err" <-[#error] "$r1");;;
    (if: (~ (interface.eq (![#error] "err") #interface.nil))
    then
      do:  (let: "$a0" := (interface.make #concurrency.concurrency #"stmError" (struct.make #stmError [{
        "err" ::= ![#error] "err"
      }])) in
      Panic "$a0")
    else do:  #());;;
    do:  (let: "$a0" := (![#sliceT] "keys") in
    let: "$a1" := (![#ptrT] "txnresp") in
    (method_call #concurrency.concurrency #"readSet" #"add" (![#readSet] (struct.field_ref #stm #"rset"%go (![#ptrT] "s")))) "$a0" "$a1");;;
    return: ((method_call #etcdserverpb #"ResponseOp'ptr" #"GetResponseRange" (![#ptrT] (slice.elem_ref #ptrT (![#sliceT] (struct.field_ref #clientv3.TxnResponse #"Responses"%go (![#ptrT] "txnresp"))) #(W64 0)))) #())).

(* go: stm.go:295:15 *)
Definition stm__reset : val :=
  rec: "stm__reset" "s" <> :=
    exception_do (let: "s" := (mem.alloc "s") in
    let: "$r0" := (map.make #stringT #ptrT) in
    do:  ((struct.field_ref #stm #"rset"%go (![#ptrT] "s")) <-[#readSet] "$r0");;;
    let: "$r0" := (map.make #stringT #stmPut) in
    do:  ((struct.field_ref #stm #"wset"%go (![#ptrT] "s")) <-[#writeSet] "$r0")).

(* go: stm.go:305:27 *)
Definition stmSerializable__Get : val :=
  rec: "stmSerializable__Get" "s" "keys" :=
    exception_do (let: "s" := (mem.alloc "s") in
    let: "keys" := (mem.alloc "keys") in
    (if: (let: "$a0" := (![#sliceT] "keys") in
    slice.len "$a0") = #(W64 0)
    then return: (#""%go)
    else do:  #());;;
    (let: "wv" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "keys") in
    (method_call #concurrency.concurrency #"writeSet" #"get" (![#writeSet] (struct.field_ref #stm #"wset"%go (struct.field_ref #stmSerializable #"stm"%go (![#ptrT] "s"))))) "$a0") in
    do:  ("wv" <-[#ptrT] "$r0");;;
    (if: (![#ptrT] "wv") ≠ #null
    then return: (![#stringT] (struct.field_ref #stmPut #"val"%go (![#ptrT] "wv")))
    else do:  #()));;;
    let: "firstRead" := (mem.alloc (type.zero_val #boolT)) in
    let: "$r0" := ((let: "$a0" := (![#readSet] (struct.field_ref #stm #"rset"%go (struct.field_ref #stmSerializable #"stm"%go (![#ptrT] "s")))) in
    map.len "$a0") = #(W64 0)) in
    do:  ("firstRead" <-[#boolT] "$r0");;;
    let: "$range" := (![#sliceT] "keys") in
    (let: "key" := (mem.alloc (type.zero_val #stringT)) in
    slice.for_range #stringT "$range" (λ: "$key" "$value",
      do:  ("key" <-[#stringT] "$value");;;
      do:  "$key";;;
      (let: "ok" := (mem.alloc (type.zero_val #boolT)) in
      let: "resp" := (mem.alloc (type.zero_val #ptrT)) in
      let: ("$ret0", "$ret1") := (map.get (![type.mapT #stringT #ptrT] (struct.field_ref #stmSerializable #"prefetch"%go (![#ptrT] "s"))) (![#stringT] "key")) in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("resp" <-[#ptrT] "$r0");;;
      do:  ("ok" <-[#boolT] "$r1");;;
      (if: ![#boolT] "ok"
      then
        do:  (let: "$a0" := (![type.mapT #stringT #ptrT] (struct.field_ref #stmSerializable #"prefetch"%go (![#ptrT] "s"))) in
        let: "$a1" := (![#stringT] "key") in
        map.delete "$a0" "$a1");;;
        let: "$r0" := (![#ptrT] "resp") in
        do:  (map.insert (![#readSet] (struct.field_ref #stm #"rset"%go (struct.field_ref #stmSerializable #"stm"%go (![#ptrT] "s")))) (![#stringT] "key") "$r0")
      else do:  #()))));;;
    let: "resp" := (mem.alloc (type.zero_val #ptrT)) in
    let: "$r0" := (let: "$a0" := (![#sliceT] "keys") in
    (method_call #concurrency.concurrency #"stm'ptr" #"fetch" (struct.field_ref #stmSerializable #"stm"%go (![#ptrT] "s"))) "$a0") in
    do:  ("resp" <-[#ptrT] "$r0");;;
    (if: ![#boolT] "firstRead"
    then
      let: "$r0" := ((let: "$sl0" := (let: "$a0" := (![#int64T] (struct.field_ref #etcdserverpb.ResponseHeader #"Revision"%go (![#ptrT] (struct.field_ref #clientv3.GetResponse #"Header"%go (![#ptrT] "resp"))))) in
      (func_call #v3.clientv3 #"WithRev"%go) "$a0") in
      let: "$sl1" := ((func_call #v3.clientv3 #"WithSerializable"%go) #()) in
      slice.literal #clientv3.OpOption ["$sl0"; "$sl1"])) in
      do:  ((struct.field_ref #stm #"getOpts"%go (struct.field_ref #stmSerializable #"stm"%go (![#ptrT] "s"))) <-[#sliceT] "$r0")
    else do:  #());;;
    return: (let: "$a0" := (![#ptrT] "resp") in
     (func_call #concurrency.concurrency #"respToValue"%go) "$a0")).

(* go: stm.go:331:27 *)
Definition stmSerializable__Rev : val :=
  rec: "stmSerializable__Rev" "s" "key" :=
    exception_do (let: "s" := (mem.alloc "s") in
    let: "key" := (mem.alloc "key") in
    do:  (let: "$a0" := ((let: "$sl0" := (![#stringT] "key") in
    slice.literal #stringT ["$sl0"])) in
    (method_call #concurrency.concurrency #"stmSerializable'ptr" #"Get" (![#ptrT] "s")) "$a0");;;
    return: (let: "$a0" := (![#stringT] "key") in
     (method_call #concurrency.concurrency #"stm'ptr" #"Rev" (struct.field_ref #stmSerializable #"stm"%go (![#ptrT] "s"))) "$a0")).

(* go: stm.go:336:27 *)
Definition stmSerializable__gets : val :=
  rec: "stmSerializable__gets" "s" <> :=
    exception_do (let: "s" := (mem.alloc "s") in
    let: "keys" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make3 #stringT #(W64 0) (let: "$a0" := (![#readSet] (struct.field_ref #stm #"rset"%go (struct.field_ref #stmSerializable #"stm"%go (![#ptrT] "s")))) in
    map.len "$a0")) in
    do:  ("keys" <-[#sliceT] "$r0");;;
    let: "ops" := (mem.alloc (type.zero_val #sliceT)) in
    let: "$r0" := (slice.make3 #clientv3.Op #(W64 0) (let: "$a0" := (![#readSet] (struct.field_ref #stm #"rset"%go (struct.field_ref #stmSerializable #"stm"%go (![#ptrT] "s")))) in
    map.len "$a0")) in
    do:  ("ops" <-[#sliceT] "$r0");;;
    let: "$range" := (![#readSet] (struct.field_ref #stm #"rset"%go (struct.field_ref #stmSerializable #"stm"%go (![#ptrT] "s")))) in
    (let: "k" := (mem.alloc (type.zero_val #stringT)) in
    map.for_range "$range" (λ: "$key" "value",
      do:  ("k" <-[#stringT] "$key");;;
      let: "$r0" := (let: "$a0" := (![#sliceT] "keys") in
      let: "$a1" := ((let: "$sl0" := (![#stringT] "k") in
      slice.literal #stringT ["$sl0"])) in
      (slice.append #stringT) "$a0" "$a1") in
      do:  ("keys" <-[#sliceT] "$r0");;;
      let: "$r0" := (let: "$a0" := (![#sliceT] "ops") in
      let: "$a1" := ((let: "$sl0" := (let: "$a0" := (![#stringT] "k") in
      let: "$a1" := #slice.nil in
      (func_call #v3.clientv3 #"OpGet"%go) "$a0" "$a1") in
      slice.literal #clientv3.Op ["$sl0"])) in
      (slice.append #clientv3.Op) "$a0" "$a1") in
      do:  ("ops" <-[#sliceT] "$r0")));;;
    return: (![#sliceT] "keys", ![#sliceT] "ops")).

(* go: stm.go:346:27 *)
Definition stmSerializable__commit : val :=
  rec: "stmSerializable__commit" "s" <> :=
    exception_do (let: "s" := (mem.alloc "s") in
    let: "getops" := (mem.alloc (type.zero_val #sliceT)) in
    let: "keys" := (mem.alloc (type.zero_val #sliceT)) in
    let: ("$ret0", "$ret1") := ((method_call #concurrency.concurrency #"stmSerializable'ptr" #"gets" (![#ptrT] "s")) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("keys" <-[#sliceT] "$r0");;;
    do:  ("getops" <-[#sliceT] "$r1");;;
    let: "txn" := (mem.alloc (type.zero_val #clientv3.Txn)) in
    let: "$r0" := (let: "$a0" := ((method_call #concurrency.concurrency #"writeSet" #"puts" (![#writeSet] (struct.field_ref #stm #"wset"%go (struct.field_ref #stmSerializable #"stm"%go (![#ptrT] "s"))))) #()) in
    (interface.get #"Then"%go (let: "$a0" := ((![#funcT] (struct.field_ref #stm #"conflicts"%go (struct.field_ref #stmSerializable #"stm"%go (![#ptrT] "s")))) #()) in
    (interface.get #"If"%go (let: "$a0" := (![#context.Context] (struct.field_ref #stm #"ctx"%go (struct.field_ref #stmSerializable #"stm"%go (![#ptrT] "s")))) in
    (method_call #clientv3 #"Client'ptr" #"Txn" (![#ptrT] (struct.field_ref #stm #"client"%go (struct.field_ref #stmSerializable #"stm"%go (![#ptrT] "s"))))) "$a0")) "$a0")) "$a0") in
    do:  ("txn" <-[#clientv3.Txn] "$r0");;;
    let: "err" := (mem.alloc (type.zero_val #error)) in
    let: "txnresp" := (mem.alloc (type.zero_val #ptrT)) in
    let: ("$ret0", "$ret1") := ((interface.get #"Commit"%go (let: "$a0" := (![#sliceT] "getops") in
    (interface.get #"Else"%go (![#clientv3.Txn] "txn")) "$a0")) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("txnresp" <-[#ptrT] "$r0");;;
    do:  ("err" <-[#error] "$r1");;;
    (if: (~ (interface.eq (![#error] "err") #interface.nil))
    then
      do:  (let: "$a0" := (interface.make #concurrency.concurrency #"stmError" (struct.make #stmError [{
        "err" ::= ![#error] "err"
      }])) in
      Panic "$a0")
    else do:  #());;;
    (if: ![#boolT] (struct.field_ref #clientv3.TxnResponse #"Succeeded"%go (![#ptrT] "txnresp"))
    then return: (![#ptrT] "txnresp")
    else do:  #());;;
    do:  (let: "$a0" := (![#sliceT] "keys") in
    let: "$a1" := (![#ptrT] "txnresp") in
    (method_call #concurrency.concurrency #"readSet" #"add" (![#readSet] (struct.field_ref #stm #"rset"%go (struct.field_ref #stmSerializable #"stm"%go (![#ptrT] "s"))))) "$a0" "$a1");;;
    let: "$r0" := (![#readSet] (struct.field_ref #stm #"rset"%go (struct.field_ref #stmSerializable #"stm"%go (![#ptrT] "s")))) in
    do:  ((struct.field_ref #stmSerializable #"prefetch"%go (![#ptrT] "s")) <-[type.mapT #stringT #ptrT] "$r0");;;
    let: "$r0" := #slice.nil in
    do:  ((struct.field_ref #stm #"getOpts"%go (struct.field_ref #stmSerializable #"stm"%go (![#ptrT] "s"))) <-[#sliceT] "$r0");;;
    return: (#null)).

(* go: stm.go:364:6 *)
Definition isKeyCurrent : val :=
  rec: "isKeyCurrent" "k" "r" :=
    exception_do (let: "r" := (mem.alloc "r") in
    let: "k" := (mem.alloc "k") in
    (if: (let: "$a0" := (![#sliceT] (struct.field_ref #clientv3.GetResponse #"Kvs"%go (![#ptrT] "r"))) in
    slice.len "$a0") ≠ #(W64 0)
    then
      return: (let: "$a0" := (let: "$a0" := (![#stringT] "k") in
       (func_call #v3.clientv3 #"ModRevision"%go) "$a0") in
       let: "$a1" := #"="%go in
       let: "$a2" := (interface.make #""%go #"int64"%go (![#int64T] (struct.field_ref #mvccpb.KeyValue #"ModRevision"%go (![#ptrT] (slice.elem_ref #ptrT (![#sliceT] (struct.field_ref #clientv3.GetResponse #"Kvs"%go (![#ptrT] "r"))) #(W64 0)))))) in
       (func_call #v3.clientv3 #"Compare"%go) "$a0" "$a1" "$a2")
    else do:  #());;;
    return: (let: "$a0" := (let: "$a0" := (![#stringT] "k") in
     (func_call #v3.clientv3 #"ModRevision"%go) "$a0") in
     let: "$a1" := #"="%go in
     let: "$a2" := (interface.make #""%go #"int"%go #(W64 0)) in
     (func_call #v3.clientv3 #"Compare"%go) "$a0" "$a1" "$a2")).

(* go: stm.go:371:6 *)
Definition respToValue : val :=
  rec: "respToValue" "resp" :=
    exception_do (let: "resp" := (mem.alloc "resp") in
    (if: ((![#ptrT] "resp") = #null) || ((let: "$a0" := (![#sliceT] (struct.field_ref #clientv3.GetResponse #"Kvs"%go (![#ptrT] "resp"))) in
    slice.len "$a0") = #(W64 0))
    then return: (#""%go)
    else do:  #());;;
    return: (string.from_bytes (![#sliceT] (struct.field_ref #mvccpb.KeyValue #"Value"%go (![#ptrT] (slice.elem_ref #ptrT (![#sliceT] (struct.field_ref #clientv3.GetResponse #"Kvs"%go (![#ptrT] "resp"))) #(W64 0))))))).

(* NewSTMRepeatable is deprecated.

   go: stm.go:379:6 *)
Definition NewSTMRepeatable : val :=
  rec: "NewSTMRepeatable" "ctx" "c" "apply" :=
    exception_do (let: "apply" := (mem.alloc "apply") in
    let: "c" := (mem.alloc "c") in
    let: "ctx" := (mem.alloc "ctx") in
    let: ("$ret0", "$ret1") := ((let: "$a0" := (![#ptrT] "c") in
    let: "$a1" := (![#funcT] "apply") in
    let: "$a2" := ((let: "$sl0" := (let: "$a0" := (![#context.Context] "ctx") in
    (func_call #concurrency.concurrency #"WithAbortContext"%go) "$a0") in
    let: "$sl1" := (let: "$a0" := RepeatableReads in
    (func_call #concurrency.concurrency #"WithIsolation"%go) "$a0") in
    slice.literal #stmOption ["$sl0"; "$sl1"])) in
    (func_call #concurrency.concurrency #"NewSTM"%go) "$a0" "$a1" "$a2")) in
    return: ("$ret0", "$ret1")).

(* NewSTMSerializable is deprecated.

   go: stm.go:384:6 *)
Definition NewSTMSerializable : val :=
  rec: "NewSTMSerializable" "ctx" "c" "apply" :=
    exception_do (let: "apply" := (mem.alloc "apply") in
    let: "c" := (mem.alloc "c") in
    let: "ctx" := (mem.alloc "ctx") in
    let: ("$ret0", "$ret1") := ((let: "$a0" := (![#ptrT] "c") in
    let: "$a1" := (![#funcT] "apply") in
    let: "$a2" := ((let: "$sl0" := (let: "$a0" := (![#context.Context] "ctx") in
    (func_call #concurrency.concurrency #"WithAbortContext"%go) "$a0") in
    let: "$sl1" := (let: "$a0" := Serializable in
    (func_call #concurrency.concurrency #"WithIsolation"%go) "$a0") in
    slice.literal #stmOption ["$sl0"; "$sl1"])) in
    (func_call #concurrency.concurrency #"NewSTM"%go) "$a0" "$a1" "$a2")) in
    return: ("$ret0", "$ret1")).

(* NewSTMReadCommitted is deprecated.

   go: stm.go:389:6 *)
Definition NewSTMReadCommitted : val :=
  rec: "NewSTMReadCommitted" "ctx" "c" "apply" :=
    exception_do (let: "apply" := (mem.alloc "apply") in
    let: "c" := (mem.alloc "c") in
    let: "ctx" := (mem.alloc "ctx") in
    let: ("$ret0", "$ret1") := ((let: "$a0" := (![#ptrT] "c") in
    let: "$a1" := (![#funcT] "apply") in
    let: "$a2" := ((let: "$sl0" := (let: "$a0" := (![#context.Context] "ctx") in
    (func_call #concurrency.concurrency #"WithAbortContext"%go) "$a0") in
    let: "$sl1" := (let: "$a0" := ReadCommitted in
    (func_call #concurrency.concurrency #"WithIsolation"%go) "$a0") in
    slice.literal #stmOption ["$sl0"; "$sl1"])) in
    (func_call #concurrency.concurrency #"NewSTM"%go) "$a0" "$a1" "$a2")) in
    return: ("$ret0", "$ret1")).

Definition vars' : list (go_string * go_type) := [("ErrElectionNotLeader"%go, error); ("ErrElectionNoLeader"%go, error); ("ErrLocked"%go, error); ("ErrSessionExpired"%go, error); ("ErrLockReleased"%go, error)].

Definition functions' : list (go_string * val) := [("NewElection"%go, NewElection); ("ResumeElection"%go, ResumeElection); ("waitDelete"%go, waitDelete); ("waitDeletes"%go, waitDeletes); ("NewMutex"%go, NewMutex); ("NewLocker"%go, NewLocker); ("NewSession"%go, NewSession); ("WithTTL"%go, WithTTL); ("WithLease"%go, WithLease); ("WithContext"%go, WithContext); ("WithIsolation"%go, WithIsolation); ("WithAbortContext"%go, WithAbortContext); ("WithPrefetch"%go, WithPrefetch); ("NewSTM"%go, NewSTM); ("mkSTM"%go, mkSTM); ("runSTM"%go, runSTM); ("isKeyCurrent"%go, isKeyCurrent); ("respToValue"%go, respToValue); ("NewSTMRepeatable"%go, NewSTMRepeatable); ("NewSTMSerializable"%go, NewSTMSerializable); ("NewSTMReadCommitted"%go, NewSTMReadCommitted)].

Definition msets' : list (go_string * (list (go_string * val))) := [("Election"%go, []); ("Election'ptr"%go, [("Campaign"%go, Election__Campaign); ("Header"%go, Election__Header); ("Key"%go, Election__Key); ("Leader"%go, Election__Leader); ("Observe"%go, Election__Observe); ("Proclaim"%go, Election__Proclaim); ("Resign"%go, Election__Resign); ("Rev"%go, Election__Rev); ("observe"%go, Election__observe)]); ("Mutex"%go, []); ("Mutex'ptr"%go, [("Header"%go, Mutex__Header); ("IsOwner"%go, Mutex__IsOwner); ("Key"%go, Mutex__Key); ("Lock"%go, Mutex__Lock); ("TryLock"%go, Mutex__TryLock); ("Unlock"%go, Mutex__Unlock); ("tryAcquire"%go, Mutex__tryAcquire)]); ("lockerMutex"%go, [("Header"%go, (λ: "$recv",
                 method_call #concurrency.concurrency #"Mutex'ptr" #"Header" (struct.field_get #lockerMutex "Mutex" "$recv")
                 )%V); ("IsOwner"%go, (λ: "$recv",
                 method_call #concurrency.concurrency #"Mutex'ptr" #"IsOwner" (struct.field_get #lockerMutex "Mutex" "$recv")
                 )%V); ("Key"%go, (λ: "$recv",
                 method_call #concurrency.concurrency #"Mutex'ptr" #"Key" (struct.field_get #lockerMutex "Mutex" "$recv")
                 )%V); ("TryLock"%go, (λ: "$recv",
                 method_call #concurrency.concurrency #"Mutex'ptr" #"TryLock" (struct.field_get #lockerMutex "Mutex" "$recv")
                 )%V); ("tryAcquire"%go, (λ: "$recv",
                 method_call #concurrency.concurrency #"Mutex'ptr" #"tryAcquire" (struct.field_get #lockerMutex "Mutex" "$recv")
                 )%V)]); ("lockerMutex'ptr"%go, [("Header"%go, (λ: "$recvAddr",
                 method_call #concurrency.concurrency #"Mutex'ptr" #"Header" (![#ptrT] (struct.field_ref #lockerMutex #"Mutex"%go "$recvAddr"))
                 )%V); ("IsOwner"%go, (λ: "$recvAddr",
                 method_call #concurrency.concurrency #"Mutex'ptr" #"IsOwner" (![#ptrT] (struct.field_ref #lockerMutex #"Mutex"%go "$recvAddr"))
                 )%V); ("Key"%go, (λ: "$recvAddr",
                 method_call #concurrency.concurrency #"Mutex'ptr" #"Key" (![#ptrT] (struct.field_ref #lockerMutex #"Mutex"%go "$recvAddr"))
                 )%V); ("Lock"%go, lockerMutex__Lock); ("TryLock"%go, (λ: "$recvAddr",
                 method_call #concurrency.concurrency #"Mutex'ptr" #"TryLock" (![#ptrT] (struct.field_ref #lockerMutex #"Mutex"%go "$recvAddr"))
                 )%V); ("Unlock"%go, lockerMutex__Unlock); ("tryAcquire"%go, (λ: "$recvAddr",
                 method_call #concurrency.concurrency #"Mutex'ptr" #"tryAcquire" (![#ptrT] (struct.field_ref #lockerMutex #"Mutex"%go "$recvAddr"))
                 )%V)]); ("Session"%go, []); ("Session'ptr"%go, [("Client"%go, Session__Client); ("Close"%go, Session__Close); ("Ctx"%go, Session__Ctx); ("Done"%go, Session__Done); ("Lease"%go, Session__Lease); ("Orphan"%go, Session__Orphan)]); ("sessionOptions"%go, []); ("sessionOptions'ptr"%go, []); ("SessionOption"%go, []); ("SessionOption'ptr"%go, []); ("Isolation"%go, []); ("Isolation'ptr"%go, []); ("stmError"%go, []); ("stmError'ptr"%go, []); ("stmOptions"%go, []); ("stmOptions'ptr"%go, []); ("stmOption"%go, []); ("stmOption'ptr"%go, []); ("stmResponse"%go, []); ("stmResponse'ptr"%go, []); ("stm"%go, []); ("stm'ptr"%go, [("Del"%go, stm__Del); ("Get"%go, stm__Get); ("Put"%go, stm__Put); ("Rev"%go, stm__Rev); ("commit"%go, stm__commit); ("fetch"%go, stm__fetch); ("reset"%go, stm__reset)]); ("stmPut"%go, []); ("stmPut'ptr"%go, []); ("readSet"%go, [("add"%go, readSet__add); ("cmps"%go, readSet__cmps); ("first"%go, readSet__first)]); ("readSet'ptr"%go, [("add"%go, (λ: "$recvAddr",
                 method_call #concurrency.concurrency #"readSet" #"add" (![#readSet] "$recvAddr")
                 )%V); ("cmps"%go, (λ: "$recvAddr",
                 method_call #concurrency.concurrency #"readSet" #"cmps" (![#readSet] "$recvAddr")
                 )%V); ("first"%go, (λ: "$recvAddr",
                 method_call #concurrency.concurrency #"readSet" #"first" (![#readSet] "$recvAddr")
                 )%V)]); ("writeSet"%go, [("cmps"%go, writeSet__cmps); ("get"%go, writeSet__get); ("puts"%go, writeSet__puts)]); ("writeSet'ptr"%go, [("cmps"%go, (λ: "$recvAddr",
                 method_call #concurrency.concurrency #"writeSet" #"cmps" (![#writeSet] "$recvAddr")
                 )%V); ("get"%go, (λ: "$recvAddr",
                 method_call #concurrency.concurrency #"writeSet" #"get" (![#writeSet] "$recvAddr")
                 )%V); ("puts"%go, (λ: "$recvAddr",
                 method_call #concurrency.concurrency #"writeSet" #"puts" (![#writeSet] "$recvAddr")
                 )%V)]); ("stmSerializable"%go, []); ("stmSerializable'ptr"%go, [("Del"%go, (λ: "$recvAddr",
                 method_call #concurrency.concurrency #"stm'ptr" #"Del" (struct.field_ref #stmSerializable #"stm"%go "$recvAddr")
                 )%V); ("Get"%go, stmSerializable__Get); ("Put"%go, (λ: "$recvAddr",
                 method_call #concurrency.concurrency #"stm'ptr" #"Put" (struct.field_ref #stmSerializable #"stm"%go "$recvAddr")
                 )%V); ("Rev"%go, stmSerializable__Rev); ("commit"%go, stmSerializable__commit); ("fetch"%go, (λ: "$recvAddr",
                 method_call #concurrency.concurrency #"stm'ptr" #"fetch" (struct.field_ref #stmSerializable #"stm"%go "$recvAddr")
                 )%V); ("gets"%go, stmSerializable__gets); ("reset"%go, (λ: "$recvAddr",
                 method_call #concurrency.concurrency #"stm'ptr" #"reset" (struct.field_ref #stmSerializable #"stm"%go "$recvAddr")
                 )%V)])].

#[global] Instance info' : PkgInfo concurrency.concurrency :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [context.context; errors.errors; fmt.fmt; etcdserverpb.etcdserverpb; mvccpb.mvccpb; v3.clientv3; strings.strings; sync.sync; time.time; zap.zap; math.math];
  |}.

Definition initialize' : val :=
  rec: "initialize'" <> :=
    globals.package_init concurrency.concurrency (λ: <>,
      exception_do (do:  math.initialize';;;
      do:  zap.initialize';;;
      do:  time.initialize';;;
      do:  sync.initialize';;;
      do:  strings.initialize';;;
      do:  clientv3.initialize';;;
      do:  mvccpb.initialize';;;
      do:  etcdserverpb.initialize';;;
      do:  fmt.initialize';;;
      do:  errors.initialize';;;
      do:  context.initialize';;;
      let: "$r0" := (let: "$a0" := #"election: not leader"%go in
      (func_call #errors.errors #"New"%go) "$a0") in
      do:  ((globals.get #concurrency.concurrency #"ErrElectionNotLeader"%go) <-[#error] "$r0");;;
      let: "$r0" := (let: "$a0" := #"election: no leader"%go in
      (func_call #errors.errors #"New"%go) "$a0") in
      do:  ((globals.get #concurrency.concurrency #"ErrElectionNoLeader"%go) <-[#error] "$r0");;;
      let: "$r0" := (let: "$a0" := #"mutex: Locked by another session"%go in
      (func_call #errors.errors #"New"%go) "$a0") in
      do:  ((globals.get #concurrency.concurrency #"ErrLocked"%go) <-[#error] "$r0");;;
      let: "$r0" := (let: "$a0" := #"mutex: session is expired"%go in
      (func_call #errors.errors #"New"%go) "$a0") in
      do:  ((globals.get #concurrency.concurrency #"ErrSessionExpired"%go) <-[#error] "$r0");;;
      let: "$r0" := (let: "$a0" := #"mutex: lock has already been released"%go in
      (func_call #errors.errors #"New"%go) "$a0") in
      do:  ((globals.get #concurrency.concurrency #"ErrLockReleased"%go) <-[#error] "$r0"))
      ).

End code.
End concurrency.
