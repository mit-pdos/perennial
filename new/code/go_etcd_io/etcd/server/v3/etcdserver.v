(* autogenerated from go.etcd.io/etcd/server/v3/etcdserver *)
Require Export New.code.context.
Require Export New.code.go_etcd_io.etcd.api.v3.etcdserverpb.
Require Export New.code.time.
Require Export New.code.go_etcd_io.etcd.server.v3.config.
Require Export New.code.go_etcd_io.etcd.server.v3.etcdserver.errors.
Require Export New.code.go_etcd_io.raft.v3.
Require Export New.code.github_com.prometheus.client_golang.prometheus.
Require Export New.code.go_etcd_io.etcd.pkg.v3.idutil.
Require Export New.code.go_etcd_io.etcd.pkg.v3.traceutil.
Require Export New.code.go_etcd_io.etcd.pkg.v3.wait.
Require Export New.code.go_etcd_io.etcd.server.v3.auth.
Require Export New.code.go_etcd_io.etcd.server.v3.etcdserver.apply.
Require Export New.code.github_com.gogo.protobuf.proto.
From New.golang Require Import defn.
Module pkg_id.
Definition etcdserver : go_string := "go.etcd.io/etcd/server/v3/etcdserver".

End pkg_id.
Export pkg_id.
Module etcdserver.

Definition serverVersionAdapter {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/server/v3/etcdserver.serverVersionAdapter"%go [].

Definition bootstrappedServer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/server/v3/etcdserver.bootstrappedServer"%go [].

Definition bootstrappedStorage {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/server/v3/etcdserver.bootstrappedStorage"%go [].

Definition bootstrappedBackend {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/server/v3/etcdserver.bootstrappedBackend"%go [].

Definition bootstrappedCluster {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/server/v3/etcdserver.bootstrappedCluster"%go [].

Definition bootstrappedRaft {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/server/v3/etcdserver.bootstrappedRaft"%go [].

Definition snapshotMetadata {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/server/v3/etcdserver.snapshotMetadata"%go [].

Definition bootstrappedWAL {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/server/v3/etcdserver.bootstrappedWAL"%go [].

Definition CorruptionChecker {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/server/v3/etcdserver.CorruptionChecker"%go [].

Definition corruptionChecker {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/server/v3/etcdserver.corruptionChecker"%go [].

Definition Hasher {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/server/v3/etcdserver.Hasher"%go [].

Definition hasherAdapter {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/server/v3/etcdserver.hasherAdapter"%go [].

Definition peerInfo {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/server/v3/etcdserver.peerInfo"%go [].

Definition peerHashKVResp {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/server/v3/etcdserver.peerHashKVResp"%go [].

Definition hashKVHandler {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/server/v3/etcdserver.hashKVHandler"%go [].

Definition toApply {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/server/v3/etcdserver.toApply"%go [].

Definition raftNode {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/server/v3/etcdserver.raftNode"%go [].

Definition raftNodeConfig {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/server/v3/etcdserver.raftNodeConfig"%go [].

Definition Response {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/server/v3/etcdserver.Response"%go [].

Definition ServerV2 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/server/v3/etcdserver.ServerV2"%go [].

Definition ServerV3 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/server/v3/etcdserver.ServerV3"%go [].

Definition Server {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/server/v3/etcdserver.Server"%go [].

Definition EtcdServer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/server/v3/etcdserver.EtcdServer"%go [].

Definition ServerPeer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/server/v3/etcdserver.ServerPeer"%go [].

Definition ServerPeerV2 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/server/v3/etcdserver.ServerPeerV2"%go [].

Definition downgradeEnabledHandler {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/server/v3/etcdserver.downgradeEnabledHandler"%go [].

Definition etcdProgress {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/server/v3/etcdserver.etcdProgress"%go [].

Definition raftReadyHandler {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/server/v3/etcdserver.raftReadyHandler"%go [].

Definition confChangeResponse {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/server/v3/etcdserver.confChangeResponse"%go [].

Definition AccessController {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/server/v3/etcdserver.AccessController"%go [].

Definition notifier {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/server/v3/etcdserver.notifier"%go [].

Definition panicAlternativeStringer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/server/v3/etcdserver.panicAlternativeStringer"%go [].

Definition RequestV2 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/server/v3/etcdserver.RequestV2"%go [].

Definition RaftKV {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/server/v3/etcdserver.RaftKV"%go [].

Definition Lessor {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/server/v3/etcdserver.Lessor"%go [].

Definition Authenticator {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/server/v3/etcdserver.Authenticator"%go [].

Definition zapRaftLogger {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/server/v3/etcdserver.zapRaftLogger"%go [].

Axiom serverVersionAdapterⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom bootstrappedServerⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom bootstrappedStorageⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom bootstrappedBackendⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom bootstrappedClusterⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom bootstrappedRaftⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom snapshotMetadataⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom bootstrappedWALⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom CorruptionCheckerⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom corruptionCheckerⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom Hasherⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom hasherAdapterⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom peerInfoⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom peerHashKVRespⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom hashKVHandlerⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom toApplyⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom raftNodeⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom raftNodeConfigⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom Responseⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom ServerV2ⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom ServerV3ⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom Serverⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom EtcdServerⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom ServerPeerⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom ServerPeerV2ⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom downgradeEnabledHandlerⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom etcdProgressⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom raftReadyHandlerⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom confChangeResponseⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom AccessControllerⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom notifierⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom panicAlternativeStringerⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom RequestV2ⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom RaftKVⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom Lessorⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom Authenticatorⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom zapRaftLoggerⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom PeerHashKVPath : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom maxSizePerMsg : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom maxInflightMsgs : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom DefaultSnapshotCount : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom DefaultSnapshotCatchUpEntries : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom StoreClusterPrefix : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom StoreKeysPrefix : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom HealthInterval : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom purgeFileInterval : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom maxInFlightMsgSnap : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom releaseDelayAfterSnapshot : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom maxPendingRevokes : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom recommendedMaxRequestBytes : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom readyPercentThreshold : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom DowngradeEnabledPath : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom memorySnapshotCount : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom maxGapBetweenApplyAndCommitIndex : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom traceThreshold : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom readIndexRetryTime : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom applyTimeout : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition hasLeader {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.hasLeader"%go.

Axiom hasLeader'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition isLeader {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.isLeader"%go.

Axiom isLeader'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition leaderChanges {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.leaderChanges"%go.

Axiom leaderChanges'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition learnerPromoteFailed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.learnerPromoteFailed"%go.

Axiom learnerPromoteFailed'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition learnerPromoteSucceed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.learnerPromoteSucceed"%go.

Axiom learnerPromoteSucceed'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition heartbeatSendFailures {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.heartbeatSendFailures"%go.

Axiom heartbeatSendFailures'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition applySnapshotInProgress {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.applySnapshotInProgress"%go.

Axiom applySnapshotInProgress'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition proposalsCommitted {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.proposalsCommitted"%go.

Axiom proposalsCommitted'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition proposalsApplied {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.proposalsApplied"%go.

Axiom proposalsApplied'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition proposalsPending {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.proposalsPending"%go.

Axiom proposalsPending'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition proposalsFailed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.proposalsFailed"%go.

Axiom proposalsFailed'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition slowReadIndex {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.slowReadIndex"%go.

Axiom slowReadIndex'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition readIndexFailed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.readIndexFailed"%go.

Axiom readIndexFailed'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition leaseExpired {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.leaseExpired"%go.

Axiom leaseExpired'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition currentVersion {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.currentVersion"%go.

Axiom currentVersion'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition currentGoVersion {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.currentGoVersion"%go.

Axiom currentGoVersion'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition serverID {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.serverID"%go.

Axiom serverID'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition fdUsed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.fdUsed"%go.

Axiom fdUsed'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition fdLimit {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.fdLimit"%go.

Axiom fdLimit'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition raftStatusMu {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.raftStatusMu"%go.

Definition raftStatus {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.raftStatus"%go.

Definition monitorVersionInterval {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.monitorVersionInterval"%go.

Axiom monitorVersionInterval'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition recommendedMaxRequestBytesString {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.recommendedMaxRequestBytesString"%go.

Axiom recommendedMaxRequestBytesString'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition storeMemberAttributeRegexp {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.storeMemberAttributeRegexp"%go.

Axiom storeMemberAttributeRegexp'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition NewServerVersionAdapter {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.NewServerVersionAdapter"%go.

Definition v2ToV3Request {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.v2ToV3Request"%go.

Definition bootstrap {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.bootstrap"%go.

Definition bootstrapStorage {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.bootstrapStorage"%go.

Definition bootstrapSnapshot {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.bootstrapSnapshot"%go.

Definition bootstrapBackend {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.bootstrapBackend"%go.

Definition maybeDefragBackend {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.maybeDefragBackend"%go.

Definition bootstrapCluster {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.bootstrapCluster"%go.

Definition bootstrapExistingClusterNoWAL {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.bootstrapExistingClusterNoWAL"%go.

Definition bootstrapNewClusterNoWAL {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.bootstrapNewClusterNoWAL"%go.

Definition bootstrapClusterWithWAL {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.bootstrapClusterWithWAL"%go.

Definition recoverSnapshot {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.recoverSnapshot"%go.

Definition bootstrapRaft {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.bootstrapRaft"%go.

Definition bootstrapRaftFromCluster {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.bootstrapRaftFromCluster"%go.

Definition bootstrapRaftFromWAL {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.bootstrapRaftFromWAL"%go.

Definition raftConfig {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.raftConfig"%go.

Definition bootstrapWALFromSnapshot {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.bootstrapWALFromSnapshot"%go.

Definition openWALFromSnapshot {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.openWALFromSnapshot"%go.

Definition bootstrapNewWAL {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.bootstrapNewWAL"%go.

Definition isMemberBootstrapped {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.isMemberBootstrapped"%go.

Definition GetClusterFromRemotePeers {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.GetClusterFromRemotePeers"%go.

Definition getClusterFromRemotePeers {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.getClusterFromRemotePeers"%go.

Definition getRemotePeerURLs {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.getRemotePeerURLs"%go.

Definition getMembersVersions {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.getMembersVersions"%go.

Definition allowedVersionRange {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.allowedVersionRange"%go.

Definition isCompatibleWithCluster {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.isCompatibleWithCluster"%go.

Definition isCompatibleWithVers {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.isCompatibleWithVers"%go.

Definition getVersion {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.getVersion"%go.

Definition promoteMemberHTTP {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.promoteMemberHTTP"%go.

Definition getDowngradeEnabledFromRemotePeers {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.getDowngradeEnabledFromRemotePeers"%go.

Definition getDowngradeEnabled {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.getDowngradeEnabled"%go.

Definition convertToClusterVersion {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.convertToClusterVersion"%go.

Definition GetMembershipInfoInV2Format {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.GetMembershipInfoInV2Format"%go.

Definition newCorruptionChecker {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.newCorruptionChecker"%go.

Definition HashByRev {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.HashByRev"%go.

Definition monitorFileDescriptor {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.monitorFileDescriptor"%go.

Definition newRaftNode {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.newRaftNode"%go.

Definition updateCommittedIndex {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.updateCommittedIndex"%go.

Definition NewServer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.NewServer"%go.

Definition tickToDur {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.tickToDur"%go.

Definition verifySnapshotIndex {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.verifySnapshotIndex"%go.

Definition verifyConsistentIndexIsLatest {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.verifyConsistentIndexIsLatest"%go.

Definition noSideEffect {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.noSideEffect"%go.

Definition removeNeedlessRangeReqs {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.removeNeedlessRangeReqs"%go.

Definition NewAccessController {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.NewAccessController"%go.

Definition newSnapshotReaderCloser {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.newSnapshotReaderCloser"%go.

Definition isConnectedToQuorumSince {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.isConnectedToQuorumSince"%go.

Definition isConnectedSince {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.isConnectedSince"%go.

Definition isConnectedFullySince {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.isConnectedFullySince"%go.

Definition numConnectedSince {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.numConnectedSince"%go.

Definition longestConnected {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.longestConnected"%go.

Definition newNotifier {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.newNotifier"%go.

Definition isStopped {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.isStopped"%go.

Definition uint64ToBigEndianBytes {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.uint64ToBigEndianBytes"%go.

Definition NewRaftLogger {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.NewRaftLogger"%go.

Definition NewRaftLoggerZap {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.NewRaftLoggerZap"%go.

Definition NewRaftLoggerFromZapCore {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver.NewRaftLoggerFromZapCore"%go.

(* go: v3_server.go:143:22 *)
Definition EtcdServer__Putⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" "ctx" "r",
    exception_do (let: "s" := (GoAlloc (go.PointerType EtcdServer) "s") in
    let: "r" := (GoAlloc (go.PointerType etcdserverpb.PutRequest) "r") in
    let: "ctx" := (GoAlloc context.Context "ctx") in
    let: "$r0" := (let: "$a0" := (![context.Context] "ctx") in
    let: "$a1" := (Convert traceutil.StartTimeKey go.any (CompositeLiteral traceutil.StartTimeKey (LiteralValue []))) in
    let: "$a2" := (Convert time.Time go.any ((FuncResolve time.Now [] #()) #())) in
    (FuncResolve context.WithValue [] #()) "$a0" "$a1" "$a2") in
    do:  ("ctx" <-[context.Context] "$r0");;;
    let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
    let: "resp" := (GoAlloc proto.Message (GoZeroVal proto.Message #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![context.Context] "ctx") in
    let: "$a1" := (CompositeLiteral etcdserverpb.InternalRaftRequest (LiteralValue [KeyedElement (Some (KeyField "Put"%go)) (ElementExpression (go.PointerType etcdserverpb.PutRequest) (![go.PointerType etcdserverpb.PutRequest] "r"))])) in
    (MethodResolve (go.PointerType EtcdServer) "raftRequest"%go (![go.PointerType EtcdServer] "s")) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("resp" <-[proto.Message] "$r0");;;
    do:  ("err" <-[go.error] "$r1");;;
    (if: Convert go.untyped_bool go.bool ((![go.error] "err") ≠⟨go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]⟩ (Convert go.untyped_nil (go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]) UntypedNil))
    then return: (Convert go.untyped_nil (go.PointerType etcdserverpb.PutResponse) UntypedNil, ![go.error] "err")
    else do:  #());;;
    return: (TypeAssert (go.PointerType etcdserverpb.PutResponse) (![proto.Message] "resp"), Convert go.untyped_nil go.error UntypedNil)).

(* go: v3_server.go:738:22 *)
Definition EtcdServer__processInternalRaftRequestOnceⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" "ctx" "r",
    with_defer: (let: "s" := (GoAlloc (go.PointerType EtcdServer) "s") in
    let: "r" := (GoAlloc etcdserverpb.InternalRaftRequest "r") in
    let: "ctx" := (GoAlloc context.Context "ctx") in
    let: "ai" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := ((MethodResolve (go.PointerType EtcdServer) "getAppliedIndex"%go (![go.PointerType EtcdServer] "s")) #()) in
    do:  ("ai" <-[go.uint64] "$r0");;;
    let: "ci" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := ((MethodResolve (go.PointerType EtcdServer) "getCommittedIndex"%go (![go.PointerType EtcdServer] "s")) #()) in
    do:  ("ci" <-[go.uint64] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "ci") >⟨go.uint64⟩ ((![go.uint64] "ai") +⟨go.uint64⟩ (Convert go.untyped_int go.uint64 maxGapBetweenApplyAndCommitIndex)))
    then return: (Convert go.untyped_nil (go.PointerType apply.Result) UntypedNil, ![go.error] (GlobalVarAddr errors.ErrTooManyRequests #()))
    else do:  #());;;
    let: "$r0" := (GoAlloc etcdserverpb.RequestHeader (CompositeLiteral etcdserverpb.RequestHeader (LiteralValue [KeyedElement (Some (KeyField "ID"%go)) (ElementExpression go.uint64 ((MethodResolve (go.PointerType idutil.Generator) "Next"%go (![go.PointerType idutil.Generator] (StructFieldRef EtcdServer "reqIDGen"%go (![go.PointerType EtcdServer] "s")))) #()))]))) in
    do:  ((StructFieldRef etcdserverpb.InternalRaftRequest "Header"%go "r") <-[go.PointerType etcdserverpb.RequestHeader] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.PointerType etcdserverpb.InternalAuthenticateRequest] (StructFieldRef etcdserverpb.InternalRaftRequest "Authenticate"%go "r")) =⟨go.PointerType etcdserverpb.InternalAuthenticateRequest⟩ (Convert go.untyped_nil (go.PointerType etcdserverpb.InternalAuthenticateRequest) UntypedNil))
    then
      let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
      let: "authInfo" := (GoAlloc (go.PointerType auth.AuthInfo) (GoZeroVal (go.PointerType auth.AuthInfo) #())) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![context.Context] "ctx") in
      (MethodResolve (go.PointerType EtcdServer) "AuthInfoFromCtx"%go (![go.PointerType EtcdServer] "s")) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("authInfo" <-[go.PointerType auth.AuthInfo] "$r0");;;
      do:  ("err" <-[go.error] "$r1");;;
      (if: Convert go.untyped_bool go.bool ((![go.error] "err") ≠⟨go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]⟩ (Convert go.untyped_nil (go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]) UntypedNil))
      then return: (Convert go.untyped_nil (go.PointerType apply.Result) UntypedNil, ![go.error] "err")
      else do:  #());;;
      (if: Convert go.untyped_bool go.bool ((![go.PointerType auth.AuthInfo] "authInfo") ≠⟨go.PointerType auth.AuthInfo⟩ (Convert go.untyped_nil (go.PointerType auth.AuthInfo) UntypedNil))
      then
        let: "$r0" := (![go.string] (StructFieldRef auth.AuthInfo "Username"%go (![go.PointerType auth.AuthInfo] "authInfo"))) in
        do:  ((StructFieldRef etcdserverpb.RequestHeader "Username"%go (![go.PointerType etcdserverpb.RequestHeader] (StructFieldRef etcdserverpb.InternalRaftRequest "Header"%go "r"))) <-[go.string] "$r0");;;
        let: "$r0" := (![go.uint64] (StructFieldRef auth.AuthInfo "Revision"%go (![go.PointerType auth.AuthInfo] "authInfo"))) in
        do:  ((StructFieldRef etcdserverpb.RequestHeader "AuthRevision"%go (![go.PointerType etcdserverpb.RequestHeader] (StructFieldRef etcdserverpb.InternalRaftRequest "Header"%go "r"))) <-[go.uint64] "$r0")
      else do:  #())
    else do:  #());;;
    let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
    let: "data" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: ("$ret0", "$ret1") := ((MethodResolve (go.PointerType etcdserverpb.InternalRaftRequest) "Marshal"%go "r") #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("data" <-[go.SliceType go.byte] "$r0");;;
    do:  ("err" <-[go.error] "$r1");;;
    (if: Convert go.untyped_bool go.bool ((![go.error] "err") ≠⟨go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]⟩ (Convert go.untyped_nil (go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]) UntypedNil))
    then return: (Convert go.untyped_nil (go.PointerType apply.Result) UntypedNil, ![go.error] "err")
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool ((let: "$a0" := (![go.SliceType go.byte] "data") in
    (FuncResolve go.len [go.SliceType go.byte] #()) "$a0") >⟨go.int⟩ (Convert go.uint go.int (![go.uint] (StructFieldRef config.ServerConfig "MaxRequestBytes"%go (StructFieldRef EtcdServer "Cfg"%go (![go.PointerType EtcdServer] "s"))))))
    then return: (Convert go.untyped_nil (go.PointerType apply.Result) UntypedNil, ![go.error] (GlobalVarAddr errors.ErrRequestTooLarge #()))
    else do:  #());;;
    let: "id" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (![go.uint64] (StructFieldRef etcdserverpb.InternalRaftRequest "ID"%go "r")) in
    do:  ("id" <-[go.uint64] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "id") =⟨go.uint64⟩ #(W64 0))
    then
      let: "$r0" := (![go.uint64] (StructFieldRef etcdserverpb.RequestHeader "ID"%go (![go.PointerType etcdserverpb.RequestHeader] (StructFieldRef etcdserverpb.InternalRaftRequest "Header"%go "r")))) in
      do:  ("id" <-[go.uint64] "$r0")
    else do:  #());;;
    let: "ch" := (GoAlloc (go.ChannelType go.recvonly go.any) (GoZeroVal (go.ChannelType go.recvonly go.any) #())) in
    let: "$r0" := (let: "$a0" := (![go.uint64] "id") in
    (MethodResolve wait.Wait "Register"%go (![wait.Wait] (StructFieldRef EtcdServer "w"%go (![go.PointerType EtcdServer] "s")))) "$a0") in
    do:  ("ch" <-[go.ChannelType go.recvonly go.any] "$r0");;;
    let: "cancel" := (GoAlloc context.CancelFunc (GoZeroVal context.CancelFunc #())) in
    let: "cctx" := (GoAlloc context.Context (GoZeroVal context.Context #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![context.Context] "ctx") in
    let: "$a1" := ((MethodResolve (go.PointerType config.ServerConfig) "ReqTimeout"%go (StructFieldRef EtcdServer "Cfg"%go (![go.PointerType EtcdServer] "s"))) #()) in
    (FuncResolve context.WithTimeout [] #()) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("cctx" <-[context.Context] "$r0");;;
    do:  ("cancel" <-[context.CancelFunc] "$r1");;;
    do:  (let: "$f" := (![context.CancelFunc] "cancel") in
    "$defer" <-[deferType] (let: "$oldf" := (![deferType] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    let: "start" := (GoAlloc time.Time (GoZeroVal time.Time #())) in
    let: "$r0" := ((FuncResolve time.Now [] #()) #()) in
    do:  ("start" <-[time.Time] "$r0");;;
    let: "$r0" := (let: "$a0" := (![context.Context] "cctx") in
    let: "$a1" := (![go.SliceType go.byte] "data") in
    (MethodResolve raftNode "Propose"%go (![raftNode] (StructFieldRef EtcdServer "r"%go (![go.PointerType EtcdServer] "s")))) "$a0" "$a1") in
    do:  ("err" <-[go.error] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.error] "err") ≠⟨go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]⟩ (Convert go.untyped_nil (go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]) UntypedNil))
    then
      do:  ((MethodResolve prometheus.Counter "Inc"%go (![prometheus.Counter] (GlobalVarAddr proposalsFailed #()))) #());;;
      do:  (let: "$a0" := (![go.uint64] "id") in
      let: "$a1" := (Convert go.untyped_nil go.any UntypedNil) in
      (MethodResolve wait.Wait "Trigger"%go (![wait.Wait] (StructFieldRef EtcdServer "w"%go (![go.PointerType EtcdServer] "s")))) "$a0" "$a1");;;
      return: (Convert go.untyped_nil (go.PointerType apply.Result) UntypedNil, ![go.error] "err")
    else do:  #());;;
    do:  ((MethodResolve prometheus.Gauge "Inc"%go (![prometheus.Gauge] (GlobalVarAddr proposalsPending #()))) #());;;
    do:  (let: "$f" := (MethodResolve prometheus.Gauge "Dec"%go (![prometheus.Gauge] (GlobalVarAddr proposalsPending #()))) in
    "$defer" <-[deferType] (let: "$oldf" := (![deferType] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    SelectStmt (SelectStmtClauses None [(CommClause (RecvCase go.any (![go.ChannelType go.recvonly go.any] "ch")) (λ: "$recvVal",
      let: "x" := (GoAlloc go.any (GoZeroVal go.any #())) in
      let: "$r0" := (Fst "$recvVal") in
      do:  ("x" <-[go.any] "$r0");;;
      return: (TypeAssert (go.PointerType apply.Result) (![go.any] "x"), Convert go.untyped_nil go.error UntypedNil)
      )); (CommClause (RecvCase (go.StructType [

    ]) ((MethodResolve context.Context "Done"%go (![context.Context] "cctx")) #())) (λ: "$recvVal",
      do:  ((MethodResolve prometheus.Counter "Inc"%go (![prometheus.Counter] (GlobalVarAddr proposalsFailed #()))) #());;;
      do:  (let: "$a0" := (![go.uint64] "id") in
      let: "$a1" := (Convert go.untyped_nil go.any UntypedNil) in
      (MethodResolve wait.Wait "Trigger"%go (![wait.Wait] (StructFieldRef EtcdServer "w"%go (![go.PointerType EtcdServer] "s")))) "$a0" "$a1");;;
      return: (Convert go.untyped_nil (go.PointerType apply.Result) UntypedNil, let: "$a0" := ((MethodResolve context.Context "Err"%go (![context.Context] "cctx")) #()) in
       let: "$a1" := (![time.Time] "start") in
       (MethodResolve (go.PointerType EtcdServer) "parseProposeCtxErr"%go (![go.PointerType EtcdServer] "s")) "$a0" "$a1")
      )); (CommClause (RecvCase (go.StructType [

    ]) (![go.ChannelType go.sendrecv (go.StructType [

    ])] (StructFieldRef EtcdServer "done"%go (![go.PointerType EtcdServer] "s")))) (λ: "$recvVal",
      return: (Convert go.untyped_nil (go.PointerType apply.Result) UntypedNil, ![go.error] (GlobalVarAddr errors.ErrStopped #()))
      ))])).

#[global] Instance info' : PkgInfo pkg_id.etcdserver :=
{|
  pkg_imported_pkgs := [code.context.pkg_id.context; code.go_etcd_io.etcd.api.v3.etcdserverpb.pkg_id.etcdserverpb; code.time.pkg_id.time; code.go_etcd_io.etcd.server.v3.config.pkg_id.config; code.go_etcd_io.etcd.server.v3.etcdserver.errors.pkg_id.errors; code.go_etcd_io.raft.v3.pkg_id.raft; code.github_com.prometheus.client_golang.prometheus.pkg_id.prometheus; code.go_etcd_io.etcd.pkg.v3.idutil.pkg_id.idutil; code.go_etcd_io.etcd.pkg.v3.traceutil.pkg_id.traceutil; code.go_etcd_io.etcd.pkg.v3.wait.pkg_id.wait; code.go_etcd_io.etcd.server.v3.auth.pkg_id.auth; code.go_etcd_io.etcd.server.v3.etcdserver.apply.pkg_id.apply; code.github_com.gogo.protobuf.proto.pkg_id.proto]
|}.

Axiom _'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init pkg_id.etcdserver (λ: <>,
      exception_do (do:  (proto.initialize' #());;;
      do:  (apply.initialize' #());;;
      do:  (auth.initialize' #());;;
      do:  (wait.initialize' #());;;
      do:  (traceutil.initialize' #());;;
      do:  (idutil.initialize' #());;;
      do:  (prometheus.initialize' #());;;
      do:  (raft.initialize' #());;;
      do:  (errors.initialize' #());;;
      do:  (config.initialize' #());;;
      do:  (time.initialize' #());;;
      do:  (etcdserverpb.initialize' #());;;
      do:  (context.initialize' #());;;
      do:  (_'init #());;;
      do:  (hasLeader'init #());;;
      do:  (isLeader'init #());;;
      do:  (leaderChanges'init #());;;
      do:  (learnerPromoteFailed'init #());;;
      do:  (learnerPromoteSucceed'init #());;;
      do:  (heartbeatSendFailures'init #());;;
      do:  (applySnapshotInProgress'init #());;;
      do:  (proposalsCommitted'init #());;;
      do:  (proposalsApplied'init #());;;
      do:  (proposalsPending'init #());;;
      do:  (proposalsFailed'init #());;;
      do:  (slowReadIndex'init #());;;
      do:  (readIndexFailed'init #());;;
      do:  (leaseExpired'init #());;;
      do:  (currentVersion'init #());;;
      do:  (currentGoVersion'init #());;;
      do:  (serverID'init #());;;
      do:  (fdUsed'init #());;;
      do:  (fdLimit'init #());;;
      do:  (monitorVersionInterval'init #());;;
      do:  (recommendedMaxRequestBytesString'init #());;;
      do:  (storeMemberAttributeRegexp'init #()))
      ).

Module serverVersionAdapter.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End serverVersionAdapter.

Class serverVersionAdapter_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] serverVersionAdapter_type_repr  :: go.TypeReprUnderlying serverVersionAdapterⁱᵐᵖˡ serverVersionAdapter.t;
  #[global] serverVersionAdapter_underlying :: (serverVersionAdapter) <u (serverVersionAdapterⁱᵐᵖˡ);
  #[global] serverVersionAdapterⁱᵐᵖˡ_underlying :: (serverVersionAdapterⁱᵐᵖˡ) ↓u (serverVersionAdapterⁱᵐᵖˡ);
}.

Module bootstrappedServer.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End bootstrappedServer.

Class bootstrappedServer_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] bootstrappedServer_type_repr  :: go.TypeReprUnderlying bootstrappedServerⁱᵐᵖˡ bootstrappedServer.t;
  #[global] bootstrappedServer_underlying :: (bootstrappedServer) <u (bootstrappedServerⁱᵐᵖˡ);
  #[global] bootstrappedServerⁱᵐᵖˡ_underlying :: (bootstrappedServerⁱᵐᵖˡ) ↓u (bootstrappedServerⁱᵐᵖˡ);
}.

Module bootstrappedStorage.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End bootstrappedStorage.

Class bootstrappedStorage_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] bootstrappedStorage_type_repr  :: go.TypeReprUnderlying bootstrappedStorageⁱᵐᵖˡ bootstrappedStorage.t;
  #[global] bootstrappedStorage_underlying :: (bootstrappedStorage) <u (bootstrappedStorageⁱᵐᵖˡ);
  #[global] bootstrappedStorageⁱᵐᵖˡ_underlying :: (bootstrappedStorageⁱᵐᵖˡ) ↓u (bootstrappedStorageⁱᵐᵖˡ);
}.

Module bootstrappedBackend.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End bootstrappedBackend.

Class bootstrappedBackend_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] bootstrappedBackend_type_repr  :: go.TypeReprUnderlying bootstrappedBackendⁱᵐᵖˡ bootstrappedBackend.t;
  #[global] bootstrappedBackend_underlying :: (bootstrappedBackend) <u (bootstrappedBackendⁱᵐᵖˡ);
  #[global] bootstrappedBackendⁱᵐᵖˡ_underlying :: (bootstrappedBackendⁱᵐᵖˡ) ↓u (bootstrappedBackendⁱᵐᵖˡ);
}.

Module bootstrappedCluster.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End bootstrappedCluster.

Class bootstrappedCluster_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] bootstrappedCluster_type_repr  :: go.TypeReprUnderlying bootstrappedClusterⁱᵐᵖˡ bootstrappedCluster.t;
  #[global] bootstrappedCluster_underlying :: (bootstrappedCluster) <u (bootstrappedClusterⁱᵐᵖˡ);
  #[global] bootstrappedClusterⁱᵐᵖˡ_underlying :: (bootstrappedClusterⁱᵐᵖˡ) ↓u (bootstrappedClusterⁱᵐᵖˡ);
}.

Module bootstrappedRaft.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End bootstrappedRaft.

Class bootstrappedRaft_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] bootstrappedRaft_type_repr  :: go.TypeReprUnderlying bootstrappedRaftⁱᵐᵖˡ bootstrappedRaft.t;
  #[global] bootstrappedRaft_underlying :: (bootstrappedRaft) <u (bootstrappedRaftⁱᵐᵖˡ);
  #[global] bootstrappedRaftⁱᵐᵖˡ_underlying :: (bootstrappedRaftⁱᵐᵖˡ) ↓u (bootstrappedRaftⁱᵐᵖˡ);
}.

Module snapshotMetadata.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End snapshotMetadata.

Class snapshotMetadata_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] snapshotMetadata_type_repr  :: go.TypeReprUnderlying snapshotMetadataⁱᵐᵖˡ snapshotMetadata.t;
  #[global] snapshotMetadata_underlying :: (snapshotMetadata) <u (snapshotMetadataⁱᵐᵖˡ);
  #[global] snapshotMetadataⁱᵐᵖˡ_underlying :: (snapshotMetadataⁱᵐᵖˡ) ↓u (snapshotMetadataⁱᵐᵖˡ);
}.

Module bootstrappedWAL.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End bootstrappedWAL.

Class bootstrappedWAL_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] bootstrappedWAL_type_repr  :: go.TypeReprUnderlying bootstrappedWALⁱᵐᵖˡ bootstrappedWAL.t;
  #[global] bootstrappedWAL_underlying :: (bootstrappedWAL) <u (bootstrappedWALⁱᵐᵖˡ);
  #[global] bootstrappedWALⁱᵐᵖˡ_underlying :: (bootstrappedWALⁱᵐᵖˡ) ↓u (bootstrappedWALⁱᵐᵖˡ);
}.

Module CorruptionChecker.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End CorruptionChecker.

Class CorruptionChecker_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] CorruptionChecker_type_repr  :: go.TypeReprUnderlying CorruptionCheckerⁱᵐᵖˡ CorruptionChecker.t;
  #[global] CorruptionChecker_underlying :: (CorruptionChecker) <u (CorruptionCheckerⁱᵐᵖˡ);
  #[global] CorruptionCheckerⁱᵐᵖˡ_underlying :: (CorruptionCheckerⁱᵐᵖˡ) ↓u (CorruptionCheckerⁱᵐᵖˡ);
}.

Module corruptionChecker.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End corruptionChecker.

Class corruptionChecker_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] corruptionChecker_type_repr  :: go.TypeReprUnderlying corruptionCheckerⁱᵐᵖˡ corruptionChecker.t;
  #[global] corruptionChecker_underlying :: (corruptionChecker) <u (corruptionCheckerⁱᵐᵖˡ);
  #[global] corruptionCheckerⁱᵐᵖˡ_underlying :: (corruptionCheckerⁱᵐᵖˡ) ↓u (corruptionCheckerⁱᵐᵖˡ);
}.

Module Hasher.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End Hasher.

Class Hasher_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Hasher_type_repr  :: go.TypeReprUnderlying Hasherⁱᵐᵖˡ Hasher.t;
  #[global] Hasher_underlying :: (Hasher) <u (Hasherⁱᵐᵖˡ);
  #[global] Hasherⁱᵐᵖˡ_underlying :: (Hasherⁱᵐᵖˡ) ↓u (Hasherⁱᵐᵖˡ);
}.

Module hasherAdapter.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End hasherAdapter.

Class hasherAdapter_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] hasherAdapter_type_repr  :: go.TypeReprUnderlying hasherAdapterⁱᵐᵖˡ hasherAdapter.t;
  #[global] hasherAdapter_underlying :: (hasherAdapter) <u (hasherAdapterⁱᵐᵖˡ);
  #[global] hasherAdapterⁱᵐᵖˡ_underlying :: (hasherAdapterⁱᵐᵖˡ) ↓u (hasherAdapterⁱᵐᵖˡ);
}.

Module peerInfo.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End peerInfo.

Class peerInfo_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] peerInfo_type_repr  :: go.TypeReprUnderlying peerInfoⁱᵐᵖˡ peerInfo.t;
  #[global] peerInfo_underlying :: (peerInfo) <u (peerInfoⁱᵐᵖˡ);
  #[global] peerInfoⁱᵐᵖˡ_underlying :: (peerInfoⁱᵐᵖˡ) ↓u (peerInfoⁱᵐᵖˡ);
}.

Module peerHashKVResp.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End peerHashKVResp.

Class peerHashKVResp_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] peerHashKVResp_type_repr  :: go.TypeReprUnderlying peerHashKVRespⁱᵐᵖˡ peerHashKVResp.t;
  #[global] peerHashKVResp_underlying :: (peerHashKVResp) <u (peerHashKVRespⁱᵐᵖˡ);
  #[global] peerHashKVRespⁱᵐᵖˡ_underlying :: (peerHashKVRespⁱᵐᵖˡ) ↓u (peerHashKVRespⁱᵐᵖˡ);
}.

Module hashKVHandler.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End hashKVHandler.

Class hashKVHandler_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] hashKVHandler_type_repr  :: go.TypeReprUnderlying hashKVHandlerⁱᵐᵖˡ hashKVHandler.t;
  #[global] hashKVHandler_underlying :: (hashKVHandler) <u (hashKVHandlerⁱᵐᵖˡ);
  #[global] hashKVHandlerⁱᵐᵖˡ_underlying :: (hashKVHandlerⁱᵐᵖˡ) ↓u (hashKVHandlerⁱᵐᵖˡ);
}.

Module toApply.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End toApply.

Class toApply_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] toApply_type_repr  :: go.TypeReprUnderlying toApplyⁱᵐᵖˡ toApply.t;
  #[global] toApply_underlying :: (toApply) <u (toApplyⁱᵐᵖˡ);
  #[global] toApplyⁱᵐᵖˡ_underlying :: (toApplyⁱᵐᵖˡ) ↓u (toApplyⁱᵐᵖˡ);
}.

Module raftNode.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End raftNode.

Class raftNode_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] raftNode_type_repr  :: go.TypeReprUnderlying raftNodeⁱᵐᵖˡ raftNode.t;
  #[global] raftNode_underlying :: (raftNode) <u (raftNodeⁱᵐᵖˡ);
  #[global] raftNodeⁱᵐᵖˡ_underlying :: (raftNodeⁱᵐᵖˡ) ↓u (raftNodeⁱᵐᵖˡ);
}.

Module raftNodeConfig.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End raftNodeConfig.

Class raftNodeConfig_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] raftNodeConfig_type_repr  :: go.TypeReprUnderlying raftNodeConfigⁱᵐᵖˡ raftNodeConfig.t;
  #[global] raftNodeConfig_underlying :: (raftNodeConfig) <u (raftNodeConfigⁱᵐᵖˡ);
  #[global] raftNodeConfigⁱᵐᵖˡ_underlying :: (raftNodeConfigⁱᵐᵖˡ) ↓u (raftNodeConfigⁱᵐᵖˡ);
}.

Module Response.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End Response.

Class Response_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Response_type_repr  :: go.TypeReprUnderlying Responseⁱᵐᵖˡ Response.t;
  #[global] Response_underlying :: (Response) <u (Responseⁱᵐᵖˡ);
  #[global] Responseⁱᵐᵖˡ_underlying :: (Responseⁱᵐᵖˡ) ↓u (Responseⁱᵐᵖˡ);
}.

Module ServerV2.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End ServerV2.

Class ServerV2_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] ServerV2_type_repr  :: go.TypeReprUnderlying ServerV2ⁱᵐᵖˡ ServerV2.t;
  #[global] ServerV2_underlying :: (ServerV2) <u (ServerV2ⁱᵐᵖˡ);
  #[global] ServerV2ⁱᵐᵖˡ_underlying :: (ServerV2ⁱᵐᵖˡ) ↓u (ServerV2ⁱᵐᵖˡ);
}.

Module ServerV3.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End ServerV3.

Class ServerV3_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] ServerV3_type_repr  :: go.TypeReprUnderlying ServerV3ⁱᵐᵖˡ ServerV3.t;
  #[global] ServerV3_underlying :: (ServerV3) <u (ServerV3ⁱᵐᵖˡ);
  #[global] ServerV3ⁱᵐᵖˡ_underlying :: (ServerV3ⁱᵐᵖˡ) ↓u (ServerV3ⁱᵐᵖˡ);
}.

Module Server.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End Server.

Class Server_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Server_type_repr  :: go.TypeReprUnderlying Serverⁱᵐᵖˡ Server.t;
  #[global] Server_underlying :: (Server) <u (Serverⁱᵐᵖˡ);
  #[global] Serverⁱᵐᵖˡ_underlying :: (Serverⁱᵐᵖˡ) ↓u (Serverⁱᵐᵖˡ);
}.

Module EtcdServer.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End EtcdServer.

Class EtcdServer_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] EtcdServer_type_repr  :: go.TypeReprUnderlying EtcdServerⁱᵐᵖˡ EtcdServer.t;
  #[global] EtcdServer_underlying :: (EtcdServer) <u (EtcdServerⁱᵐᵖˡ);
  #[global] EtcdServerⁱᵐᵖˡ_underlying :: (EtcdServerⁱᵐᵖˡ) ↓u (EtcdServerⁱᵐᵖˡ);
  #[global] EtcdServer'ptr_Put_unfold :: MethodUnfold (go.PointerType (EtcdServer)) "Put" (EtcdServer__Putⁱᵐᵖˡ);
  #[global] EtcdServer'ptr_processInternalRaftRequestOnce_unfold :: MethodUnfold (go.PointerType (EtcdServer)) "processInternalRaftRequestOnce" (EtcdServer__processInternalRaftRequestOnceⁱᵐᵖˡ);
}.

Module ServerPeer.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End ServerPeer.

Class ServerPeer_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] ServerPeer_type_repr  :: go.TypeReprUnderlying ServerPeerⁱᵐᵖˡ ServerPeer.t;
  #[global] ServerPeer_underlying :: (ServerPeer) <u (ServerPeerⁱᵐᵖˡ);
  #[global] ServerPeerⁱᵐᵖˡ_underlying :: (ServerPeerⁱᵐᵖˡ) ↓u (ServerPeerⁱᵐᵖˡ);
}.

Module ServerPeerV2.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End ServerPeerV2.

Class ServerPeerV2_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] ServerPeerV2_type_repr  :: go.TypeReprUnderlying ServerPeerV2ⁱᵐᵖˡ ServerPeerV2.t;
  #[global] ServerPeerV2_underlying :: (ServerPeerV2) <u (ServerPeerV2ⁱᵐᵖˡ);
  #[global] ServerPeerV2ⁱᵐᵖˡ_underlying :: (ServerPeerV2ⁱᵐᵖˡ) ↓u (ServerPeerV2ⁱᵐᵖˡ);
}.

Module downgradeEnabledHandler.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End downgradeEnabledHandler.

Class downgradeEnabledHandler_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] downgradeEnabledHandler_type_repr  :: go.TypeReprUnderlying downgradeEnabledHandlerⁱᵐᵖˡ downgradeEnabledHandler.t;
  #[global] downgradeEnabledHandler_underlying :: (downgradeEnabledHandler) <u (downgradeEnabledHandlerⁱᵐᵖˡ);
  #[global] downgradeEnabledHandlerⁱᵐᵖˡ_underlying :: (downgradeEnabledHandlerⁱᵐᵖˡ) ↓u (downgradeEnabledHandlerⁱᵐᵖˡ);
}.

Module etcdProgress.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End etcdProgress.

Class etcdProgress_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] etcdProgress_type_repr  :: go.TypeReprUnderlying etcdProgressⁱᵐᵖˡ etcdProgress.t;
  #[global] etcdProgress_underlying :: (etcdProgress) <u (etcdProgressⁱᵐᵖˡ);
  #[global] etcdProgressⁱᵐᵖˡ_underlying :: (etcdProgressⁱᵐᵖˡ) ↓u (etcdProgressⁱᵐᵖˡ);
}.

Module raftReadyHandler.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End raftReadyHandler.

Class raftReadyHandler_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] raftReadyHandler_type_repr  :: go.TypeReprUnderlying raftReadyHandlerⁱᵐᵖˡ raftReadyHandler.t;
  #[global] raftReadyHandler_underlying :: (raftReadyHandler) <u (raftReadyHandlerⁱᵐᵖˡ);
  #[global] raftReadyHandlerⁱᵐᵖˡ_underlying :: (raftReadyHandlerⁱᵐᵖˡ) ↓u (raftReadyHandlerⁱᵐᵖˡ);
}.

Module confChangeResponse.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End confChangeResponse.

Class confChangeResponse_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] confChangeResponse_type_repr  :: go.TypeReprUnderlying confChangeResponseⁱᵐᵖˡ confChangeResponse.t;
  #[global] confChangeResponse_underlying :: (confChangeResponse) <u (confChangeResponseⁱᵐᵖˡ);
  #[global] confChangeResponseⁱᵐᵖˡ_underlying :: (confChangeResponseⁱᵐᵖˡ) ↓u (confChangeResponseⁱᵐᵖˡ);
}.

Module AccessController.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End AccessController.

Class AccessController_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] AccessController_type_repr  :: go.TypeReprUnderlying AccessControllerⁱᵐᵖˡ AccessController.t;
  #[global] AccessController_underlying :: (AccessController) <u (AccessControllerⁱᵐᵖˡ);
  #[global] AccessControllerⁱᵐᵖˡ_underlying :: (AccessControllerⁱᵐᵖˡ) ↓u (AccessControllerⁱᵐᵖˡ);
}.

Module notifier.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End notifier.

Class notifier_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] notifier_type_repr  :: go.TypeReprUnderlying notifierⁱᵐᵖˡ notifier.t;
  #[global] notifier_underlying :: (notifier) <u (notifierⁱᵐᵖˡ);
  #[global] notifierⁱᵐᵖˡ_underlying :: (notifierⁱᵐᵖˡ) ↓u (notifierⁱᵐᵖˡ);
}.

Module panicAlternativeStringer.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End panicAlternativeStringer.

Class panicAlternativeStringer_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] panicAlternativeStringer_type_repr  :: go.TypeReprUnderlying panicAlternativeStringerⁱᵐᵖˡ panicAlternativeStringer.t;
  #[global] panicAlternativeStringer_underlying :: (panicAlternativeStringer) <u (panicAlternativeStringerⁱᵐᵖˡ);
  #[global] panicAlternativeStringerⁱᵐᵖˡ_underlying :: (panicAlternativeStringerⁱᵐᵖˡ) ↓u (panicAlternativeStringerⁱᵐᵖˡ);
}.

Module RequestV2.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End RequestV2.

Class RequestV2_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] RequestV2_type_repr  :: go.TypeReprUnderlying RequestV2ⁱᵐᵖˡ RequestV2.t;
  #[global] RequestV2_underlying :: (RequestV2) <u (RequestV2ⁱᵐᵖˡ);
  #[global] RequestV2ⁱᵐᵖˡ_underlying :: (RequestV2ⁱᵐᵖˡ) ↓u (RequestV2ⁱᵐᵖˡ);
}.

Module RaftKV.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End RaftKV.

Class RaftKV_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] RaftKV_type_repr  :: go.TypeReprUnderlying RaftKVⁱᵐᵖˡ RaftKV.t;
  #[global] RaftKV_underlying :: (RaftKV) <u (RaftKVⁱᵐᵖˡ);
  #[global] RaftKVⁱᵐᵖˡ_underlying :: (RaftKVⁱᵐᵖˡ) ↓u (RaftKVⁱᵐᵖˡ);
}.

Module Lessor.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End Lessor.

Class Lessor_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Lessor_type_repr  :: go.TypeReprUnderlying Lessorⁱᵐᵖˡ Lessor.t;
  #[global] Lessor_underlying :: (Lessor) <u (Lessorⁱᵐᵖˡ);
  #[global] Lessorⁱᵐᵖˡ_underlying :: (Lessorⁱᵐᵖˡ) ↓u (Lessorⁱᵐᵖˡ);
}.

Module Authenticator.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End Authenticator.

Class Authenticator_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Authenticator_type_repr  :: go.TypeReprUnderlying Authenticatorⁱᵐᵖˡ Authenticator.t;
  #[global] Authenticator_underlying :: (Authenticator) <u (Authenticatorⁱᵐᵖˡ);
  #[global] Authenticatorⁱᵐᵖˡ_underlying :: (Authenticatorⁱᵐᵖˡ) ↓u (Authenticatorⁱᵐᵖˡ);
}.

Module zapRaftLogger.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End zapRaftLogger.

Class zapRaftLogger_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] zapRaftLogger_type_repr  :: go.TypeReprUnderlying zapRaftLoggerⁱᵐᵖˡ zapRaftLogger.t;
  #[global] zapRaftLogger_underlying :: (zapRaftLogger) <u (zapRaftLoggerⁱᵐᵖˡ);
  #[global] zapRaftLoggerⁱᵐᵖˡ_underlying :: (zapRaftLoggerⁱᵐᵖˡ) ↓u (zapRaftLoggerⁱᵐᵖˡ);
}.

Class Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] serverVersionAdapter_instance :: serverVersionAdapter_Assumptions;
  #[global] bootstrappedServer_instance :: bootstrappedServer_Assumptions;
  #[global] bootstrappedStorage_instance :: bootstrappedStorage_Assumptions;
  #[global] bootstrappedBackend_instance :: bootstrappedBackend_Assumptions;
  #[global] bootstrappedCluster_instance :: bootstrappedCluster_Assumptions;
  #[global] bootstrappedRaft_instance :: bootstrappedRaft_Assumptions;
  #[global] snapshotMetadata_instance :: snapshotMetadata_Assumptions;
  #[global] bootstrappedWAL_instance :: bootstrappedWAL_Assumptions;
  #[global] CorruptionChecker_instance :: CorruptionChecker_Assumptions;
  #[global] corruptionChecker_instance :: corruptionChecker_Assumptions;
  #[global] Hasher_instance :: Hasher_Assumptions;
  #[global] hasherAdapter_instance :: hasherAdapter_Assumptions;
  #[global] peerInfo_instance :: peerInfo_Assumptions;
  #[global] peerHashKVResp_instance :: peerHashKVResp_Assumptions;
  #[global] hashKVHandler_instance :: hashKVHandler_Assumptions;
  #[global] toApply_instance :: toApply_Assumptions;
  #[global] raftNode_instance :: raftNode_Assumptions;
  #[global] raftNodeConfig_instance :: raftNodeConfig_Assumptions;
  #[global] Response_instance :: Response_Assumptions;
  #[global] ServerV2_instance :: ServerV2_Assumptions;
  #[global] ServerV3_instance :: ServerV3_Assumptions;
  #[global] Server_instance :: Server_Assumptions;
  #[global] EtcdServer_instance :: EtcdServer_Assumptions;
  #[global] ServerPeer_instance :: ServerPeer_Assumptions;
  #[global] ServerPeerV2_instance :: ServerPeerV2_Assumptions;
  #[global] downgradeEnabledHandler_instance :: downgradeEnabledHandler_Assumptions;
  #[global] etcdProgress_instance :: etcdProgress_Assumptions;
  #[global] raftReadyHandler_instance :: raftReadyHandler_Assumptions;
  #[global] confChangeResponse_instance :: confChangeResponse_Assumptions;
  #[global] AccessController_instance :: AccessController_Assumptions;
  #[global] notifier_instance :: notifier_Assumptions;
  #[global] panicAlternativeStringer_instance :: panicAlternativeStringer_Assumptions;
  #[global] RequestV2_instance :: RequestV2_Assumptions;
  #[global] RaftKV_instance :: RaftKV_Assumptions;
  #[global] Lessor_instance :: Lessor_Assumptions;
  #[global] Authenticator_instance :: Authenticator_Assumptions;
  #[global] zapRaftLogger_instance :: zapRaftLogger_Assumptions;
  #[global] import_context_Assumption :: context.Assumptions;
  #[global] import_etcdserverpb_Assumption :: etcdserverpb.Assumptions;
  #[global] import_time_Assumption :: time.Assumptions;
  #[global] import_config_Assumption :: config.Assumptions;
  #[global] import_errors_Assumption :: errors.Assumptions;
  #[global] import_raft_Assumption :: raft.Assumptions;
  #[global] import_prometheus_Assumption :: prometheus.Assumptions;
  #[global] import_idutil_Assumption :: idutil.Assumptions;
  #[global] import_traceutil_Assumption :: traceutil.Assumptions;
  #[global] import_wait_Assumption :: wait.Assumptions;
  #[global] import_auth_Assumption :: auth.Assumptions;
  #[global] import_apply_Assumption :: apply.Assumptions;
  #[global] import_proto_Assumption :: proto.Assumptions;
}.
End etcdserver.
