(* autogenerated from go.etcd.io/etcd/server/v3/etcdserver/cindex *)
Require Export New.code.go_etcd_io.etcd.server.v3.storage.backend.
Require Export New.code.go_etcd_io.etcd.server.v3.storage.schema.
Require Export New.code.sync.
Require Export New.code.sync.atomic.

From New.golang Require Import defn.
Definition cindex : go_string := "go.etcd.io/etcd/server/v3/etcdserver/cindex".

Module cindex.

Module Backend. Definition id : go_string := "go.etcd.io/etcd/server/v3/etcdserver/cindex.Backend"%go. End Backend.
Module ConsistentIndexer. Definition id : go_string := "go.etcd.io/etcd/server/v3/etcdserver/cindex.ConsistentIndexer"%go. End ConsistentIndexer.
Module consistentIndex. Definition id : go_string := "go.etcd.io/etcd/server/v3/etcdserver/cindex.consistentIndex"%go. End consistentIndex.
Module fakeConsistentIndex. Definition id : go_string := "go.etcd.io/etcd/server/v3/etcdserver/cindex.fakeConsistentIndex"%go. End fakeConsistentIndex.

Section code.
Context `{ffi_syntax}.


Definition Backend : go_type := interfaceT.
#[global] Typeclasses Opaque Backend.
#[global] Opaque Backend.

Definition ConsistentIndexer : go_type := interfaceT.
#[global] Typeclasses Opaque ConsistentIndexer.
#[global] Opaque ConsistentIndexer.

Definition consistentIndex : go_type := structT [
  "consistentIndex" :: uint64T;
  "term" :: uint64T;
  "applyingIndex" :: uint64T;
  "applyingTerm" :: uint64T;
  "be" :: Backend;
  "mutex" :: sync.Mutex
].
#[global] Typeclasses Opaque consistentIndex.
#[global] Opaque consistentIndex.

Definition NewConsistentIndex : go_string := "go.etcd.io/etcd/server/v3/etcdserver/cindex.NewConsistentIndex"%go.

(* NewConsistentIndex creates a new consistent index.
   If `be` is nil, it must be set (SetBackend) before first access using `ConsistentIndex()`.

   go: cindex.go:86:6 *)
Definition NewConsistentIndexⁱᵐᵖˡ : val :=
  λ: "be",
    exception_do (let: "be" := (mem.alloc "be") in
    return: (interface.make #(ptrT.id consistentIndex.id) (mem.alloc (let: "$be" := (![#Backend] "be") in
     struct.make #consistentIndex [{
       "consistentIndex" ::= type.zero_val #uint64T;
       "term" ::= type.zero_val #uint64T;
       "applyingIndex" ::= type.zero_val #uint64T;
       "applyingTerm" ::= type.zero_val #uint64T;
       "be" ::= "$be";
       "mutex" ::= type.zero_val #sync.Mutex
     }])))).

(* go: cindex.go:90:28 *)
Definition consistentIndex__ConsistentIndexⁱᵐᵖˡ : val :=
  λ: "ci" <>,
    with_defer: (let: "ci" := (mem.alloc "ci") in
    (let: "index" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (let: "$a0" := (struct.field_ref #consistentIndex #"consistentIndex"%go (![#ptrT] "ci")) in
    (func_call #atomic.LoadUint64) "$a0") in
    do:  ("index" <-[#uint64T] "$r0");;;
    (if: (![#uint64T] "index") > #(W64 0)
    then return: (![#uint64T] "index")
    else do:  #()));;;
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (struct.field_ref #consistentIndex #"mutex"%go (![#ptrT] "ci"))) #());;;
    do:  (let: "$f" := (method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (struct.field_ref #consistentIndex #"mutex"%go (![#ptrT] "ci"))) in
    "$defer" <-[#funcT] (let: "$oldf" := (![#funcT] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    let: "term" := (mem.alloc (type.zero_val #uint64T)) in
    let: "v" := (mem.alloc (type.zero_val #uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := ((interface.get #"ReadTx"%go (![#Backend] (struct.field_ref #consistentIndex #"be"%go (![#ptrT] "ci")))) #()) in
    (func_call #schema.ReadConsistentIndex) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("v" <-[#uint64T] "$r0");;;
    do:  ("term" <-[#uint64T] "$r1");;;
    do:  (let: "$a0" := (![#uint64T] "v") in
    let: "$a1" := (![#uint64T] "term") in
    (method_call #(ptrT.id consistentIndex.id) #"SetConsistentIndex"%go (![#ptrT] "ci")) "$a0" "$a1");;;
    return: (![#uint64T] "v")).

(* go: cindex.go:102:28 *)
Definition consistentIndex__UnsafeConsistentIndexⁱᵐᵖˡ : val :=
  λ: "ci" <>,
    exception_do (let: "ci" := (mem.alloc "ci") in
    (let: "index" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (let: "$a0" := (struct.field_ref #consistentIndex #"consistentIndex"%go (![#ptrT] "ci")) in
    (func_call #atomic.LoadUint64) "$a0") in
    do:  ("index" <-[#uint64T] "$r0");;;
    (if: (![#uint64T] "index") > #(W64 0)
    then return: (![#uint64T] "index")
    else do:  #()));;;
    let: "term" := (mem.alloc (type.zero_val #uint64T)) in
    let: "v" := (mem.alloc (type.zero_val #uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := ((interface.get #"ReadTx"%go (![#Backend] (struct.field_ref #consistentIndex #"be"%go (![#ptrT] "ci")))) #()) in
    (func_call #schema.UnsafeReadConsistentIndex) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("v" <-[#uint64T] "$r0");;;
    do:  ("term" <-[#uint64T] "$r1");;;
    do:  (let: "$a0" := (![#uint64T] "v") in
    let: "$a1" := (![#uint64T] "term") in
    (method_call #(ptrT.id consistentIndex.id) #"SetConsistentIndex"%go (![#ptrT] "ci")) "$a0" "$a1");;;
    return: (![#uint64T] "v")).

(* go: cindex.go:112:28 *)
Definition consistentIndex__SetConsistentIndexⁱᵐᵖˡ : val :=
  λ: "ci" "v" "term",
    exception_do (let: "ci" := (mem.alloc "ci") in
    let: "term" := (mem.alloc "term") in
    let: "v" := (mem.alloc "v") in
    do:  (let: "$a0" := (struct.field_ref #consistentIndex #"consistentIndex"%go (![#ptrT] "ci")) in
    let: "$a1" := (![#uint64T] "v") in
    (func_call #atomic.StoreUint64) "$a0" "$a1");;;
    do:  (let: "$a0" := (struct.field_ref #consistentIndex #"term"%go (![#ptrT] "ci")) in
    let: "$a1" := (![#uint64T] "term") in
    (func_call #atomic.StoreUint64) "$a0" "$a1");;;
    return: #()).

(* go: cindex.go:117:28 *)
Definition consistentIndex__UnsafeSaveⁱᵐᵖˡ : val :=
  λ: "ci" "tx",
    exception_do (let: "ci" := (mem.alloc "ci") in
    let: "tx" := (mem.alloc "tx") in
    let: "index" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (let: "$a0" := (struct.field_ref #consistentIndex #"consistentIndex"%go (![#ptrT] "ci")) in
    (func_call #atomic.LoadUint64) "$a0") in
    do:  ("index" <-[#uint64T] "$r0");;;
    let: "term" := (mem.alloc (type.zero_val #uint64T)) in
    let: "$r0" := (let: "$a0" := (struct.field_ref #consistentIndex #"term"%go (![#ptrT] "ci")) in
    (func_call #atomic.LoadUint64) "$a0") in
    do:  ("term" <-[#uint64T] "$r0");;;
    do:  (let: "$a0" := (![#backend.UnsafeReadWriter] "tx") in
    let: "$a1" := (![#uint64T] "index") in
    let: "$a2" := (![#uint64T] "term") in
    (func_call #schema.UnsafeUpdateConsistentIndex) "$a0" "$a1" "$a2");;;
    return: #()).

(* go: cindex.go:123:28 *)
Definition consistentIndex__SetBackendⁱᵐᵖˡ : val :=
  λ: "ci" "be",
    with_defer: (let: "ci" := (mem.alloc "ci") in
    let: "be" := (mem.alloc "be") in
    do:  ((method_call #(ptrT.id sync.Mutex.id) #"Lock"%go (struct.field_ref #consistentIndex #"mutex"%go (![#ptrT] "ci"))) #());;;
    do:  (let: "$f" := (method_call #(ptrT.id sync.Mutex.id) #"Unlock"%go (struct.field_ref #consistentIndex #"mutex"%go (![#ptrT] "ci"))) in
    "$defer" <-[#funcT] (let: "$oldf" := (![#funcT] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    let: "$r0" := (![#Backend] "be") in
    do:  ((struct.field_ref #consistentIndex #"be"%go (![#ptrT] "ci")) <-[#Backend] "$r0");;;
    do:  (let: "$a0" := #(W64 0) in
    let: "$a1" := #(W64 0) in
    (method_call #(ptrT.id consistentIndex.id) #"SetConsistentIndex"%go (![#ptrT] "ci")) "$a0" "$a1");;;
    return: #()).

(* go: cindex.go:131:28 *)
Definition consistentIndex__ConsistentApplyingIndexⁱᵐᵖˡ : val :=
  λ: "ci" <>,
    exception_do (let: "ci" := (mem.alloc "ci") in
    return: (let: "$a0" := (struct.field_ref #consistentIndex #"applyingIndex"%go (![#ptrT] "ci")) in
     (func_call #atomic.LoadUint64) "$a0", let: "$a0" := (struct.field_ref #consistentIndex #"applyingTerm"%go (![#ptrT] "ci")) in
     (func_call #atomic.LoadUint64) "$a0")).

(* go: cindex.go:135:28 *)
Definition consistentIndex__SetConsistentApplyingIndexⁱᵐᵖˡ : val :=
  λ: "ci" "v" "term",
    exception_do (let: "ci" := (mem.alloc "ci") in
    let: "term" := (mem.alloc "term") in
    let: "v" := (mem.alloc "v") in
    do:  (let: "$a0" := (struct.field_ref #consistentIndex #"applyingIndex"%go (![#ptrT] "ci")) in
    let: "$a1" := (![#uint64T] "v") in
    (func_call #atomic.StoreUint64) "$a0" "$a1");;;
    do:  (let: "$a0" := (struct.field_ref #consistentIndex #"applyingTerm"%go (![#ptrT] "ci")) in
    let: "$a1" := (![#uint64T] "term") in
    (func_call #atomic.StoreUint64) "$a0" "$a1");;;
    return: #()).

Definition NewFakeConsistentIndex : go_string := "go.etcd.io/etcd/server/v3/etcdserver/cindex.NewFakeConsistentIndex"%go.

Definition fakeConsistentIndex : go_type := structT [
  "index" :: uint64T;
  "term" :: uint64T
].
#[global] Typeclasses Opaque fakeConsistentIndex.
#[global] Opaque fakeConsistentIndex.

(* go: cindex.go:140:6 *)
Definition NewFakeConsistentIndexⁱᵐᵖˡ : val :=
  λ: "index",
    exception_do (let: "index" := (mem.alloc "index") in
    return: (interface.make #(ptrT.id fakeConsistentIndex.id) (mem.alloc (let: "$index" := (![#uint64T] "index") in
     struct.make #fakeConsistentIndex [{
       "index" ::= "$index";
       "term" ::= type.zero_val #uint64T
     }])))).

(* go: cindex.go:149:31 *)
Definition fakeConsistentIndex__ConsistentIndexⁱᵐᵖˡ : val :=
  λ: "f" <>,
    exception_do (let: "f" := (mem.alloc "f") in
    return: (let: "$a0" := (struct.field_ref #fakeConsistentIndex #"index"%go (![#ptrT] "f")) in
     (func_call #atomic.LoadUint64) "$a0")).

(* go: cindex.go:153:31 *)
Definition fakeConsistentIndex__ConsistentApplyingIndexⁱᵐᵖˡ : val :=
  λ: "f" <>,
    exception_do (let: "f" := (mem.alloc "f") in
    return: (let: "$a0" := (struct.field_ref #fakeConsistentIndex #"index"%go (![#ptrT] "f")) in
     (func_call #atomic.LoadUint64) "$a0", let: "$a0" := (struct.field_ref #fakeConsistentIndex #"term"%go (![#ptrT] "f")) in
     (func_call #atomic.LoadUint64) "$a0")).

(* go: cindex.go:157:31 *)
Definition fakeConsistentIndex__UnsafeConsistentIndexⁱᵐᵖˡ : val :=
  λ: "f" <>,
    exception_do (let: "f" := (mem.alloc "f") in
    return: (let: "$a0" := (struct.field_ref #fakeConsistentIndex #"index"%go (![#ptrT] "f")) in
     (func_call #atomic.LoadUint64) "$a0")).

(* go: cindex.go:161:31 *)
Definition fakeConsistentIndex__SetConsistentIndexⁱᵐᵖˡ : val :=
  λ: "f" "index" "term",
    exception_do (let: "f" := (mem.alloc "f") in
    let: "term" := (mem.alloc "term") in
    let: "index" := (mem.alloc "index") in
    do:  (let: "$a0" := (struct.field_ref #fakeConsistentIndex #"index"%go (![#ptrT] "f")) in
    let: "$a1" := (![#uint64T] "index") in
    (func_call #atomic.StoreUint64) "$a0" "$a1");;;
    do:  (let: "$a0" := (struct.field_ref #fakeConsistentIndex #"term"%go (![#ptrT] "f")) in
    let: "$a1" := (![#uint64T] "term") in
    (func_call #atomic.StoreUint64) "$a0" "$a1");;;
    return: #()).

(* go: cindex.go:166:31 *)
Definition fakeConsistentIndex__SetConsistentApplyingIndexⁱᵐᵖˡ : val :=
  λ: "f" "index" "term",
    exception_do (let: "f" := (mem.alloc "f") in
    let: "term" := (mem.alloc "term") in
    let: "index" := (mem.alloc "index") in
    do:  (let: "$a0" := (struct.field_ref #fakeConsistentIndex #"index"%go (![#ptrT] "f")) in
    let: "$a1" := (![#uint64T] "index") in
    (func_call #atomic.StoreUint64) "$a0" "$a1");;;
    do:  (let: "$a0" := (struct.field_ref #fakeConsistentIndex #"term"%go (![#ptrT] "f")) in
    let: "$a1" := (![#uint64T] "term") in
    (func_call #atomic.StoreUint64) "$a0" "$a1");;;
    return: #()).

(* go: cindex.go:171:31 *)
Definition fakeConsistentIndex__UnsafeSaveⁱᵐᵖˡ : val :=
  λ: "f" <>,
    exception_do (let: "f" := (mem.alloc "f") in
    do:  #()).

(* go: cindex.go:172:31 *)
Definition fakeConsistentIndex__SetBackendⁱᵐᵖˡ : val :=
  λ: "f" <>,
    exception_do (let: "f" := (mem.alloc "f") in
    do:  #()).

Definition UpdateConsistentIndexForce : go_string := "go.etcd.io/etcd/server/v3/etcdserver/cindex.UpdateConsistentIndexForce"%go.

(* go: cindex.go:174:6 *)
Definition UpdateConsistentIndexForceⁱᵐᵖˡ : val :=
  λ: "tx" "index" "term",
    with_defer: (let: "term" := (mem.alloc "term") in
    let: "index" := (mem.alloc "index") in
    let: "tx" := (mem.alloc "tx") in
    do:  ((interface.get #"LockOutsideApply"%go (![#backend.BatchTx] "tx")) #());;;
    do:  (let: "$f" := (interface.get #"Unlock"%go (![#backend.BatchTx] "tx")) in
    "$defer" <-[#funcT] (let: "$oldf" := (![#funcT] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    do:  (let: "$a0" := (![#backend.BatchTx] "tx") in
    let: "$a1" := (![#uint64T] "index") in
    let: "$a2" := (![#uint64T] "term") in
    (func_call #schema.UnsafeUpdateConsistentIndexForce) "$a0" "$a1" "$a2");;;
    return: #()).

Definition vars' : list (go_string * go_type) := [].

Definition functions' : list (go_string * val) := [(NewConsistentIndex, NewConsistentIndexⁱᵐᵖˡ); (NewFakeConsistentIndex, NewFakeConsistentIndexⁱᵐᵖˡ); (UpdateConsistentIndexForce, UpdateConsistentIndexForceⁱᵐᵖˡ)].

Definition msets' : list (go_string * (list (go_string * val))) := [(consistentIndex.id, []); (ptrT.id consistentIndex.id, [("ConsistentApplyingIndex"%go, consistentIndex__ConsistentApplyingIndexⁱᵐᵖˡ); ("ConsistentIndex"%go, consistentIndex__ConsistentIndexⁱᵐᵖˡ); ("SetBackend"%go, consistentIndex__SetBackendⁱᵐᵖˡ); ("SetConsistentApplyingIndex"%go, consistentIndex__SetConsistentApplyingIndexⁱᵐᵖˡ); ("SetConsistentIndex"%go, consistentIndex__SetConsistentIndexⁱᵐᵖˡ); ("UnsafeConsistentIndex"%go, consistentIndex__UnsafeConsistentIndexⁱᵐᵖˡ); ("UnsafeSave"%go, consistentIndex__UnsafeSaveⁱᵐᵖˡ)]); (fakeConsistentIndex.id, []); (ptrT.id fakeConsistentIndex.id, [("ConsistentApplyingIndex"%go, fakeConsistentIndex__ConsistentApplyingIndexⁱᵐᵖˡ); ("ConsistentIndex"%go, fakeConsistentIndex__ConsistentIndexⁱᵐᵖˡ); ("SetBackend"%go, fakeConsistentIndex__SetBackendⁱᵐᵖˡ); ("SetConsistentApplyingIndex"%go, fakeConsistentIndex__SetConsistentApplyingIndexⁱᵐᵖˡ); ("SetConsistentIndex"%go, fakeConsistentIndex__SetConsistentIndexⁱᵐᵖˡ); ("UnsafeConsistentIndex"%go, fakeConsistentIndex__UnsafeConsistentIndexⁱᵐᵖˡ); ("UnsafeSave"%go, fakeConsistentIndex__UnsafeSaveⁱᵐᵖˡ)])].

#[global] Instance info' : PkgInfo cindex.cindex :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [code.sync.sync; code.sync.atomic.atomic; code.go_etcd_io.etcd.server.v3.storage.backend.backend; code.go_etcd_io.etcd.server.v3.storage.schema.schema];
  |}.

Definition initialize' : val :=
  λ: <>,
    package.init #cindex.cindex (λ: <>,
      exception_do (do:  (schema.initialize' #());;;
      do:  (backend.initialize' #());;;
      do:  (atomic.initialize' #());;;
      do:  (sync.initialize' #());;;
      do:  (package.alloc cindex.cindex #()))
      ).

End code.
End cindex.
