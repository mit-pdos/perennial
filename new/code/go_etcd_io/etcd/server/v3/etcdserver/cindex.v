(* autogenerated from go.etcd.io/etcd/server/v3/etcdserver/cindex *)
Require Export New.code.sync.
Require Export New.code.sync.atomic.
Require Export New.code.go_etcd_io.etcd.server.v3.storage.backend.
Require Export New.code.go_etcd_io.etcd.server.v3.storage.schema.
From New.golang Require Import defn.
Module pkg_id.
Definition cindex : go_string := "go.etcd.io/etcd/server/v3/etcdserver/cindex".

End pkg_id.
Export pkg_id.
Module cindex.

Definition Backend {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/server/v3/etcdserver/cindex.Backend"%go [].

#[global] Opaque Backend.

Definition ConsistentIndexer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/server/v3/etcdserver/cindex.ConsistentIndexer"%go [].

#[global] Opaque ConsistentIndexer.

Definition consistentIndex {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/server/v3/etcdserver/cindex.consistentIndex"%go [].

#[global] Opaque consistentIndex.

Definition fakeConsistentIndex {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/server/v3/etcdserver/cindex.fakeConsistentIndex"%go [].

#[global] Opaque fakeConsistentIndex.

Definition NewConsistentIndex {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver/cindex.NewConsistentIndex"%go.

Definition NewFakeConsistentIndex {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver/cindex.NewFakeConsistentIndex"%go.

Definition UpdateConsistentIndexForce {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/server/v3/etcdserver/cindex.UpdateConsistentIndexForce"%go.

(* NewConsistentIndex creates a new consistent index.
   If `be` is nil, it must be set (SetBackend) before first access using `ConsistentIndex()`.

   go: cindex.go:86:6 *)
Definition NewConsistentIndexⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "be",
    exception_do (let: "be" := (GoAlloc Backend "be") in
    return: (Convert (go.PointerType consistentIndex) ConsistentIndexer (GoAlloc consistentIndex (let: "$v0" := (![Backend] "be") in
     CompositeLiteral consistentIndex (LiteralValue [KeyedElement (Some (KeyField "be"%go)) (ElementExpression Backend "$v0")]))))).

(* go: cindex.go:90:28 *)
Definition consistentIndex__ConsistentIndexⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "ci" <>,
    with_defer: (let: "ci" := (GoAlloc (go.PointerType consistentIndex) "ci") in
    (let: "index" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (let: "$a0" := (StructFieldRef consistentIndex "consistentIndex"%go (![go.PointerType consistentIndex] "ci")) in
    (FuncResolve atomic.LoadUint64 [] #()) "$a0") in
    do:  ("index" <-[go.uint64] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "index") >⟨go.uint64⟩ #(W64 0))
    then return: (![go.uint64] "index")
    else do:  #()));;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (StructFieldRef consistentIndex "mutex"%go (![go.PointerType consistentIndex] "ci"))) #());;;
    do:  (let: "$f" := (MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (StructFieldRef consistentIndex "mutex"%go (![go.PointerType consistentIndex] "ci"))) in
    "$defer" <-[deferType] (let: "$oldf" := (![deferType] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    let: "term" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "v" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := ((MethodResolve Backend "ReadTx"%go (![Backend] (StructFieldRef consistentIndex "be"%go (![go.PointerType consistentIndex] "ci")))) #()) in
    (FuncResolve schema.ReadConsistentIndex [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("v" <-[go.uint64] "$r0");;;
    do:  ("term" <-[go.uint64] "$r1");;;
    do:  (let: "$a0" := (![go.uint64] "v") in
    let: "$a1" := (![go.uint64] "term") in
    (MethodResolve (go.PointerType consistentIndex) "SetConsistentIndex"%go (![go.PointerType consistentIndex] "ci")) "$a0" "$a1");;;
    return: (![go.uint64] "v")).

(* go: cindex.go:102:28 *)
Definition consistentIndex__UnsafeConsistentIndexⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "ci" <>,
    exception_do (let: "ci" := (GoAlloc (go.PointerType consistentIndex) "ci") in
    (let: "index" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (let: "$a0" := (StructFieldRef consistentIndex "consistentIndex"%go (![go.PointerType consistentIndex] "ci")) in
    (FuncResolve atomic.LoadUint64 [] #()) "$a0") in
    do:  ("index" <-[go.uint64] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "index") >⟨go.uint64⟩ #(W64 0))
    then return: (![go.uint64] "index")
    else do:  #()));;;
    let: "term" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "v" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (Convert backend.ReadTx backend.UnsafeReader ((MethodResolve Backend "ReadTx"%go (![Backend] (StructFieldRef consistentIndex "be"%go (![go.PointerType consistentIndex] "ci")))) #())) in
    (FuncResolve schema.UnsafeReadConsistentIndex [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("v" <-[go.uint64] "$r0");;;
    do:  ("term" <-[go.uint64] "$r1");;;
    do:  (let: "$a0" := (![go.uint64] "v") in
    let: "$a1" := (![go.uint64] "term") in
    (MethodResolve (go.PointerType consistentIndex) "SetConsistentIndex"%go (![go.PointerType consistentIndex] "ci")) "$a0" "$a1");;;
    return: (![go.uint64] "v")).

(* go: cindex.go:112:28 *)
Definition consistentIndex__SetConsistentIndexⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "ci" "v" "term",
    exception_do (let: "ci" := (GoAlloc (go.PointerType consistentIndex) "ci") in
    let: "term" := (GoAlloc go.uint64 "term") in
    let: "v" := (GoAlloc go.uint64 "v") in
    do:  (let: "$a0" := (StructFieldRef consistentIndex "consistentIndex"%go (![go.PointerType consistentIndex] "ci")) in
    let: "$a1" := (![go.uint64] "v") in
    (FuncResolve atomic.StoreUint64 [] #()) "$a0" "$a1");;;
    do:  (let: "$a0" := (StructFieldRef consistentIndex "term"%go (![go.PointerType consistentIndex] "ci")) in
    let: "$a1" := (![go.uint64] "term") in
    (FuncResolve atomic.StoreUint64 [] #()) "$a0" "$a1");;;
    return: #()).

(* go: cindex.go:117:28 *)
Definition consistentIndex__UnsafeSaveⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "ci" "tx",
    exception_do (let: "ci" := (GoAlloc (go.PointerType consistentIndex) "ci") in
    let: "tx" := (GoAlloc backend.UnsafeReadWriter "tx") in
    let: "index" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (let: "$a0" := (StructFieldRef consistentIndex "consistentIndex"%go (![go.PointerType consistentIndex] "ci")) in
    (FuncResolve atomic.LoadUint64 [] #()) "$a0") in
    do:  ("index" <-[go.uint64] "$r0");;;
    let: "term" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (let: "$a0" := (StructFieldRef consistentIndex "term"%go (![go.PointerType consistentIndex] "ci")) in
    (FuncResolve atomic.LoadUint64 [] #()) "$a0") in
    do:  ("term" <-[go.uint64] "$r0");;;
    do:  (let: "$a0" := (![backend.UnsafeReadWriter] "tx") in
    let: "$a1" := (![go.uint64] "index") in
    let: "$a2" := (![go.uint64] "term") in
    (FuncResolve schema.UnsafeUpdateConsistentIndex [] #()) "$a0" "$a1" "$a2");;;
    return: #()).

(* go: cindex.go:123:28 *)
Definition consistentIndex__SetBackendⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "ci" "be",
    with_defer: (let: "ci" := (GoAlloc (go.PointerType consistentIndex) "ci") in
    let: "be" := (GoAlloc Backend "be") in
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (StructFieldRef consistentIndex "mutex"%go (![go.PointerType consistentIndex] "ci"))) #());;;
    do:  (let: "$f" := (MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (StructFieldRef consistentIndex "mutex"%go (![go.PointerType consistentIndex] "ci"))) in
    "$defer" <-[deferType] (let: "$oldf" := (![deferType] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    let: "$r0" := (![Backend] "be") in
    do:  ((StructFieldRef consistentIndex "be"%go (![go.PointerType consistentIndex] "ci")) <-[Backend] "$r0");;;
    do:  (let: "$a0" := #(W64 0) in
    let: "$a1" := #(W64 0) in
    (MethodResolve (go.PointerType consistentIndex) "SetConsistentIndex"%go (![go.PointerType consistentIndex] "ci")) "$a0" "$a1");;;
    return: #()).

(* go: cindex.go:131:28 *)
Definition consistentIndex__ConsistentApplyingIndexⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "ci" <>,
    exception_do (let: "ci" := (GoAlloc (go.PointerType consistentIndex) "ci") in
    return: (let: "$a0" := (StructFieldRef consistentIndex "applyingIndex"%go (![go.PointerType consistentIndex] "ci")) in
     (FuncResolve atomic.LoadUint64 [] #()) "$a0", let: "$a0" := (StructFieldRef consistentIndex "applyingTerm"%go (![go.PointerType consistentIndex] "ci")) in
     (FuncResolve atomic.LoadUint64 [] #()) "$a0")).

(* go: cindex.go:135:28 *)
Definition consistentIndex__SetConsistentApplyingIndexⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "ci" "v" "term",
    exception_do (let: "ci" := (GoAlloc (go.PointerType consistentIndex) "ci") in
    let: "term" := (GoAlloc go.uint64 "term") in
    let: "v" := (GoAlloc go.uint64 "v") in
    do:  (let: "$a0" := (StructFieldRef consistentIndex "applyingIndex"%go (![go.PointerType consistentIndex] "ci")) in
    let: "$a1" := (![go.uint64] "v") in
    (FuncResolve atomic.StoreUint64 [] #()) "$a0" "$a1");;;
    do:  (let: "$a0" := (StructFieldRef consistentIndex "applyingTerm"%go (![go.PointerType consistentIndex] "ci")) in
    let: "$a1" := (![go.uint64] "term") in
    (FuncResolve atomic.StoreUint64 [] #()) "$a0" "$a1");;;
    return: #()).

(* go: cindex.go:140:6 *)
Definition NewFakeConsistentIndexⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "index",
    exception_do (let: "index" := (GoAlloc go.uint64 "index") in
    return: (Convert (go.PointerType fakeConsistentIndex) ConsistentIndexer (GoAlloc fakeConsistentIndex (let: "$v0" := (![go.uint64] "index") in
     CompositeLiteral fakeConsistentIndex (LiteralValue [KeyedElement (Some (KeyField "index"%go)) (ElementExpression go.uint64 "$v0")]))))).

(* go: cindex.go:149:31 *)
Definition fakeConsistentIndex__ConsistentIndexⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "f" <>,
    exception_do (let: "f" := (GoAlloc (go.PointerType fakeConsistentIndex) "f") in
    return: (let: "$a0" := (StructFieldRef fakeConsistentIndex "index"%go (![go.PointerType fakeConsistentIndex] "f")) in
     (FuncResolve atomic.LoadUint64 [] #()) "$a0")).

(* go: cindex.go:153:31 *)
Definition fakeConsistentIndex__ConsistentApplyingIndexⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "f" <>,
    exception_do (let: "f" := (GoAlloc (go.PointerType fakeConsistentIndex) "f") in
    return: (let: "$a0" := (StructFieldRef fakeConsistentIndex "index"%go (![go.PointerType fakeConsistentIndex] "f")) in
     (FuncResolve atomic.LoadUint64 [] #()) "$a0", let: "$a0" := (StructFieldRef fakeConsistentIndex "term"%go (![go.PointerType fakeConsistentIndex] "f")) in
     (FuncResolve atomic.LoadUint64 [] #()) "$a0")).

(* go: cindex.go:157:31 *)
Definition fakeConsistentIndex__UnsafeConsistentIndexⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "f" <>,
    exception_do (let: "f" := (GoAlloc (go.PointerType fakeConsistentIndex) "f") in
    return: (let: "$a0" := (StructFieldRef fakeConsistentIndex "index"%go (![go.PointerType fakeConsistentIndex] "f")) in
     (FuncResolve atomic.LoadUint64 [] #()) "$a0")).

(* go: cindex.go:161:31 *)
Definition fakeConsistentIndex__SetConsistentIndexⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "f" "index" "term",
    exception_do (let: "f" := (GoAlloc (go.PointerType fakeConsistentIndex) "f") in
    let: "term" := (GoAlloc go.uint64 "term") in
    let: "index" := (GoAlloc go.uint64 "index") in
    do:  (let: "$a0" := (StructFieldRef fakeConsistentIndex "index"%go (![go.PointerType fakeConsistentIndex] "f")) in
    let: "$a1" := (![go.uint64] "index") in
    (FuncResolve atomic.StoreUint64 [] #()) "$a0" "$a1");;;
    do:  (let: "$a0" := (StructFieldRef fakeConsistentIndex "term"%go (![go.PointerType fakeConsistentIndex] "f")) in
    let: "$a1" := (![go.uint64] "term") in
    (FuncResolve atomic.StoreUint64 [] #()) "$a0" "$a1");;;
    return: #()).

(* go: cindex.go:166:31 *)
Definition fakeConsistentIndex__SetConsistentApplyingIndexⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "f" "index" "term",
    exception_do (let: "f" := (GoAlloc (go.PointerType fakeConsistentIndex) "f") in
    let: "term" := (GoAlloc go.uint64 "term") in
    let: "index" := (GoAlloc go.uint64 "index") in
    do:  (let: "$a0" := (StructFieldRef fakeConsistentIndex "index"%go (![go.PointerType fakeConsistentIndex] "f")) in
    let: "$a1" := (![go.uint64] "index") in
    (FuncResolve atomic.StoreUint64 [] #()) "$a0" "$a1");;;
    do:  (let: "$a0" := (StructFieldRef fakeConsistentIndex "term"%go (![go.PointerType fakeConsistentIndex] "f")) in
    let: "$a1" := (![go.uint64] "term") in
    (FuncResolve atomic.StoreUint64 [] #()) "$a0" "$a1");;;
    return: #()).

(* go: cindex.go:171:31 *)
Definition fakeConsistentIndex__UnsafeSaveⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "f" <>,
    exception_do (let: "f" := (GoAlloc (go.PointerType fakeConsistentIndex) "f") in
    do:  #()).

(* go: cindex.go:172:31 *)
Definition fakeConsistentIndex__SetBackendⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "f" <>,
    exception_do (let: "f" := (GoAlloc (go.PointerType fakeConsistentIndex) "f") in
    do:  #()).

(* go: cindex.go:174:6 *)
Definition UpdateConsistentIndexForceⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "tx" "index" "term",
    with_defer: (let: "term" := (GoAlloc go.uint64 "term") in
    let: "index" := (GoAlloc go.uint64 "index") in
    let: "tx" := (GoAlloc backend.BatchTx "tx") in
    do:  ((MethodResolve backend.BatchTx "LockOutsideApply"%go (![backend.BatchTx] "tx")) #());;;
    do:  (let: "$f" := (MethodResolve backend.BatchTx "Unlock"%go (![backend.BatchTx] "tx")) in
    "$defer" <-[deferType] (let: "$oldf" := (![deferType] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    do:  (let: "$a0" := (Convert backend.BatchTx backend.UnsafeReadWriter (![backend.BatchTx] "tx")) in
    let: "$a1" := (![go.uint64] "index") in
    let: "$a2" := (![go.uint64] "term") in
    (FuncResolve schema.UnsafeUpdateConsistentIndexForce [] #()) "$a0" "$a1" "$a2");;;
    return: #()).

#[global] Instance info' : PkgInfo pkg_id.cindex :=
{|
  pkg_imported_pkgs := [code.sync.pkg_id.sync; code.sync.atomic.pkg_id.atomic; code.go_etcd_io.etcd.server.v3.storage.backend.pkg_id.backend; code.go_etcd_io.etcd.server.v3.storage.schema.pkg_id.schema]
|}.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init pkg_id.cindex (λ: <>,
      exception_do (do:  (schema.initialize' #());;;
      do:  (backend.initialize' #());;;
      do:  (atomic.initialize' #());;;
      do:  (sync.initialize' #()))
      ).

Module Backend.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := interface.t.
End def.
End Backend.

Definition Backendⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.InterfaceType [go.MethodElem "ReadTx"%go (go.Signature [] false [backend.ReadTx])].

Class Backend_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Backend_underlying :: (Backend) <u (Backendⁱᵐᵖˡ);
}.

Module ConsistentIndexer.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := interface.t.
End def.
End ConsistentIndexer.

Definition ConsistentIndexerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.InterfaceType [go.MethodElem "ConsistentApplyingIndex"%go (go.Signature [] false [go.uint64; go.uint64]); go.MethodElem "ConsistentIndex"%go (go.Signature [] false [go.uint64]); go.MethodElem "SetBackend"%go (go.Signature [Backend] false []); go.MethodElem "SetConsistentApplyingIndex"%go (go.Signature [go.uint64; go.uint64] false []); go.MethodElem "SetConsistentIndex"%go (go.Signature [go.uint64; go.uint64] false []); go.MethodElem "UnsafeConsistentIndex"%go (go.Signature [] false [go.uint64]); go.MethodElem "UnsafeSave"%go (go.Signature [backend.UnsafeReadWriter] false [])].

Class ConsistentIndexer_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] ConsistentIndexer_underlying :: (ConsistentIndexer) <u (ConsistentIndexerⁱᵐᵖˡ);
}.

Module consistentIndex.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  consistentIndex' : w64;
  term' : w64;
  applyingIndex' : w64;
  applyingTerm' : w64;
  be' : cindex.Backend.t;
  mutex' : sync.Mutex.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End consistentIndex.

Definition consistentIndex'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "consistentIndex"%go go.uint64);
  (go.FieldDecl "term"%go go.uint64);
  (go.FieldDecl "applyingIndex"%go go.uint64);
  (go.FieldDecl "applyingTerm"%go go.uint64);
  (go.FieldDecl "be"%go Backend);
  (go.FieldDecl "mutex"%go sync.Mutex)
].
Program Definition consistentIndex'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (consistentIndex'fds_unsealed).
Global Instance equals_unfold_consistentIndex {ext : ffi_syntax} {go_gctx : GoGlobalContext} : consistentIndex'fds =→ consistentIndex'fds_unsealed.
Proof. rewrite /consistentIndex'fds seal_eq //. Qed.

Definition consistentIndexⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (consistentIndex'fds).

Class consistentIndex_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] consistentIndex_type_repr  :: go.TypeReprUnderlying consistentIndexⁱᵐᵖˡ consistentIndex.t;
  #[global] consistentIndex_underlying :: (consistentIndex) <u (consistentIndexⁱᵐᵖˡ);
  #[global] consistentIndex_get_consistentIndex (x : consistentIndex.t) :: ⟦StructFieldGet (consistentIndexⁱᵐᵖˡ) "consistentIndex", #x⟧ ⤳[under] #x.(consistentIndex.consistentIndex');
  #[global] consistentIndex_set_consistentIndex (x : consistentIndex.t) y :: ⟦StructFieldSet (consistentIndexⁱᵐᵖˡ) "consistentIndex", (#x, #y)⟧ ⤳[under] #(x <|consistentIndex.consistentIndex' := y|>);
  #[global] consistentIndex_get_term (x : consistentIndex.t) :: ⟦StructFieldGet (consistentIndexⁱᵐᵖˡ) "term", #x⟧ ⤳[under] #x.(consistentIndex.term');
  #[global] consistentIndex_set_term (x : consistentIndex.t) y :: ⟦StructFieldSet (consistentIndexⁱᵐᵖˡ) "term", (#x, #y)⟧ ⤳[under] #(x <|consistentIndex.term' := y|>);
  #[global] consistentIndex_get_applyingIndex (x : consistentIndex.t) :: ⟦StructFieldGet (consistentIndexⁱᵐᵖˡ) "applyingIndex", #x⟧ ⤳[under] #x.(consistentIndex.applyingIndex');
  #[global] consistentIndex_set_applyingIndex (x : consistentIndex.t) y :: ⟦StructFieldSet (consistentIndexⁱᵐᵖˡ) "applyingIndex", (#x, #y)⟧ ⤳[under] #(x <|consistentIndex.applyingIndex' := y|>);
  #[global] consistentIndex_get_applyingTerm (x : consistentIndex.t) :: ⟦StructFieldGet (consistentIndexⁱᵐᵖˡ) "applyingTerm", #x⟧ ⤳[under] #x.(consistentIndex.applyingTerm');
  #[global] consistentIndex_set_applyingTerm (x : consistentIndex.t) y :: ⟦StructFieldSet (consistentIndexⁱᵐᵖˡ) "applyingTerm", (#x, #y)⟧ ⤳[under] #(x <|consistentIndex.applyingTerm' := y|>);
  #[global] consistentIndex_get_be (x : consistentIndex.t) :: ⟦StructFieldGet (consistentIndexⁱᵐᵖˡ) "be", #x⟧ ⤳[under] #x.(consistentIndex.be');
  #[global] consistentIndex_set_be (x : consistentIndex.t) y :: ⟦StructFieldSet (consistentIndexⁱᵐᵖˡ) "be", (#x, #y)⟧ ⤳[under] #(x <|consistentIndex.be' := y|>);
  #[global] consistentIndex_get_mutex (x : consistentIndex.t) :: ⟦StructFieldGet (consistentIndexⁱᵐᵖˡ) "mutex", #x⟧ ⤳[under] #x.(consistentIndex.mutex');
  #[global] consistentIndex_set_mutex (x : consistentIndex.t) y :: ⟦StructFieldSet (consistentIndexⁱᵐᵖˡ) "mutex", (#x, #y)⟧ ⤳[under] #(x <|consistentIndex.mutex' := y|>);
  #[global] consistentIndex'ptr_ConsistentApplyingIndex_unfold :: MethodUnfold (go.PointerType (consistentIndex)) "ConsistentApplyingIndex" (consistentIndex__ConsistentApplyingIndexⁱᵐᵖˡ);
  #[global] consistentIndex'ptr_ConsistentIndex_unfold :: MethodUnfold (go.PointerType (consistentIndex)) "ConsistentIndex" (consistentIndex__ConsistentIndexⁱᵐᵖˡ);
  #[global] consistentIndex'ptr_SetBackend_unfold :: MethodUnfold (go.PointerType (consistentIndex)) "SetBackend" (consistentIndex__SetBackendⁱᵐᵖˡ);
  #[global] consistentIndex'ptr_SetConsistentApplyingIndex_unfold :: MethodUnfold (go.PointerType (consistentIndex)) "SetConsistentApplyingIndex" (consistentIndex__SetConsistentApplyingIndexⁱᵐᵖˡ);
  #[global] consistentIndex'ptr_SetConsistentIndex_unfold :: MethodUnfold (go.PointerType (consistentIndex)) "SetConsistentIndex" (consistentIndex__SetConsistentIndexⁱᵐᵖˡ);
  #[global] consistentIndex'ptr_UnsafeConsistentIndex_unfold :: MethodUnfold (go.PointerType (consistentIndex)) "UnsafeConsistentIndex" (consistentIndex__UnsafeConsistentIndexⁱᵐᵖˡ);
  #[global] consistentIndex'ptr_UnsafeSave_unfold :: MethodUnfold (go.PointerType (consistentIndex)) "UnsafeSave" (consistentIndex__UnsafeSaveⁱᵐᵖˡ);
}.

Module fakeConsistentIndex.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  index' : w64;
  term' : w64;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End fakeConsistentIndex.

Definition fakeConsistentIndex'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "index"%go go.uint64);
  (go.FieldDecl "term"%go go.uint64)
].
Program Definition fakeConsistentIndex'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (fakeConsistentIndex'fds_unsealed).
Global Instance equals_unfold_fakeConsistentIndex {ext : ffi_syntax} {go_gctx : GoGlobalContext} : fakeConsistentIndex'fds =→ fakeConsistentIndex'fds_unsealed.
Proof. rewrite /fakeConsistentIndex'fds seal_eq //. Qed.

Definition fakeConsistentIndexⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (fakeConsistentIndex'fds).

Class fakeConsistentIndex_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] fakeConsistentIndex_type_repr  :: go.TypeReprUnderlying fakeConsistentIndexⁱᵐᵖˡ fakeConsistentIndex.t;
  #[global] fakeConsistentIndex_underlying :: (fakeConsistentIndex) <u (fakeConsistentIndexⁱᵐᵖˡ);
  #[global] fakeConsistentIndex_get_index (x : fakeConsistentIndex.t) :: ⟦StructFieldGet (fakeConsistentIndexⁱᵐᵖˡ) "index", #x⟧ ⤳[under] #x.(fakeConsistentIndex.index');
  #[global] fakeConsistentIndex_set_index (x : fakeConsistentIndex.t) y :: ⟦StructFieldSet (fakeConsistentIndexⁱᵐᵖˡ) "index", (#x, #y)⟧ ⤳[under] #(x <|fakeConsistentIndex.index' := y|>);
  #[global] fakeConsistentIndex_get_term (x : fakeConsistentIndex.t) :: ⟦StructFieldGet (fakeConsistentIndexⁱᵐᵖˡ) "term", #x⟧ ⤳[under] #x.(fakeConsistentIndex.term');
  #[global] fakeConsistentIndex_set_term (x : fakeConsistentIndex.t) y :: ⟦StructFieldSet (fakeConsistentIndexⁱᵐᵖˡ) "term", (#x, #y)⟧ ⤳[under] #(x <|fakeConsistentIndex.term' := y|>);
  #[global] fakeConsistentIndex'ptr_ConsistentApplyingIndex_unfold :: MethodUnfold (go.PointerType (fakeConsistentIndex)) "ConsistentApplyingIndex" (fakeConsistentIndex__ConsistentApplyingIndexⁱᵐᵖˡ);
  #[global] fakeConsistentIndex'ptr_ConsistentIndex_unfold :: MethodUnfold (go.PointerType (fakeConsistentIndex)) "ConsistentIndex" (fakeConsistentIndex__ConsistentIndexⁱᵐᵖˡ);
  #[global] fakeConsistentIndex'ptr_SetBackend_unfold :: MethodUnfold (go.PointerType (fakeConsistentIndex)) "SetBackend" (fakeConsistentIndex__SetBackendⁱᵐᵖˡ);
  #[global] fakeConsistentIndex'ptr_SetConsistentApplyingIndex_unfold :: MethodUnfold (go.PointerType (fakeConsistentIndex)) "SetConsistentApplyingIndex" (fakeConsistentIndex__SetConsistentApplyingIndexⁱᵐᵖˡ);
  #[global] fakeConsistentIndex'ptr_SetConsistentIndex_unfold :: MethodUnfold (go.PointerType (fakeConsistentIndex)) "SetConsistentIndex" (fakeConsistentIndex__SetConsistentIndexⁱᵐᵖˡ);
  #[global] fakeConsistentIndex'ptr_UnsafeConsistentIndex_unfold :: MethodUnfold (go.PointerType (fakeConsistentIndex)) "UnsafeConsistentIndex" (fakeConsistentIndex__UnsafeConsistentIndexⁱᵐᵖˡ);
  #[global] fakeConsistentIndex'ptr_UnsafeSave_unfold :: MethodUnfold (go.PointerType (fakeConsistentIndex)) "UnsafeSave" (fakeConsistentIndex__UnsafeSaveⁱᵐᵖˡ);
}.

Class Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Backend_instance :: Backend_Assumptions;
  #[global] ConsistentIndexer_instance :: ConsistentIndexer_Assumptions;
  #[global] consistentIndex_instance :: consistentIndex_Assumptions;
  #[global] fakeConsistentIndex_instance :: fakeConsistentIndex_Assumptions;
  #[global] NewConsistentIndex_unfold :: FuncUnfold NewConsistentIndex [] (NewConsistentIndexⁱᵐᵖˡ);
  #[global] NewFakeConsistentIndex_unfold :: FuncUnfold NewFakeConsistentIndex [] (NewFakeConsistentIndexⁱᵐᵖˡ);
  #[global] UpdateConsistentIndexForce_unfold :: FuncUnfold UpdateConsistentIndexForce [] (UpdateConsistentIndexForceⁱᵐᵖˡ);
  #[global] import_sync_Assumption :: sync.Assumptions;
  #[global] import_atomic_Assumption :: atomic.Assumptions;
  #[global] import_backend_Assumption :: backend.Assumptions;
  #[global] import_schema_Assumption :: schema.Assumptions;
}.
End cindex.
