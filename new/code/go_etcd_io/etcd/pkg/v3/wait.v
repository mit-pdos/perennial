(* autogenerated from go.etcd.io/etcd/pkg/v3/wait *)
Require Export New.code.log.
Require Export New.code.sync.
From New.golang Require Import defn.
Module pkg_id.
Definition wait : go_string := "go.etcd.io/etcd/pkg/v3/wait".

End pkg_id.
Export pkg_id.
Module wait.

Definition Wait {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/pkg/v3/wait.Wait"%go [].

Definition list' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/pkg/v3/wait.list"%go [].

Definition listElement {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/pkg/v3/wait.listElement"%go [].

Definition waitWithResponse {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/pkg/v3/wait.waitWithResponse"%go [].

Definition WaitTime {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/pkg/v3/wait.WaitTime"%go [].

Definition timeList {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/pkg/v3/wait.timeList"%go [].

Definition defaultListElementLength {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #64.

Definition closec {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/pkg/v3/wait.closec"%go.

Definition New {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/pkg/v3/wait.New"%go.

Definition NewWithResponse {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/pkg/v3/wait.NewWithResponse"%go.

Definition NewTimeList {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/pkg/v3/wait.NewTimeList"%go.

(* New creates a Wait.

   go: wait.go:53:6 *)
Definition Newⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (let: "res" := (GoAlloc list' (GoZeroVal list' #())) in
    let: "$r0" := (CompositeLiteral list' (LiteralValue [KeyedElement (Some (KeyField "e"%go)) (ElementExpression (go.SliceType listElement) ((FuncResolve go.make2 [go.SliceType listElement] #()) (Convert go.untyped_int go.int defaultListElementLength)))])) in
    do:  ("res" <-[list'] "$r0");;;
    (let: "i" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.int] "$r0");;;
    (for: (λ: <>, (![go.int] "i") <⟨go.int⟩ (let: "$a0" := (![go.SliceType listElement] (StructFieldRef list' "e"%go "res")) in
    (FuncResolve go.len [go.SliceType listElement] #()) "$a0")); (λ: <>, do:  ("i" <-[go.int] ((![go.int] "i") +⟨go.int⟩ #(W64 1)))) := λ: <>,
      let: "$r0" := ((FuncResolve go.make1 [go.MapType go.uint64 (go.ChannelType go.sendrecv go.any)] #()) #()) in
      do:  ((StructFieldRef listElement "m"%go (IndexRef (go.SliceType listElement) (![go.SliceType listElement] (StructFieldRef list' "e"%go "res"), ![go.int] "i"))) <-[go.MapType go.uint64 (go.ChannelType go.sendrecv go.any)] "$r0")));;;
    return: (Convert (go.PointerType list') Wait "res")).

(* go: wait.go:63:16 *)
Definition list__Registerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "w" "id",
    with_defer: (let: "w" := (GoAlloc (go.PointerType list') "w") in
    let: "id" := (GoAlloc go.uint64 "id") in
    let: "idx" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := ((![go.uint64] "id") %⟨go.uint64⟩ (Convert go.untyped_int go.uint64 defaultListElementLength)) in
    do:  ("idx" <-[go.uint64] "$r0");;;
    let: "newCh" := (GoAlloc (go.ChannelType go.sendrecv go.any) (GoZeroVal (go.ChannelType go.sendrecv go.any) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.ChannelType go.sendrecv go.any] #()) #(W64 1)) in
    do:  ("newCh" <-[go.ChannelType go.sendrecv go.any] "$r0");;;
    do:  ((MethodResolve (go.PointerType sync.RWMutex) "Lock"%go (StructFieldRef listElement "l"%go (IndexRef (go.SliceType listElement) (![go.SliceType listElement] (StructFieldRef list' "e"%go (![go.PointerType list'] "w")), Convert go.uint64 go.int (![go.uint64] "idx"))))) #());;;
    do:  (let: "$f" := (MethodResolve (go.PointerType sync.RWMutex) "Unlock"%go (StructFieldRef listElement "l"%go (IndexRef (go.SliceType listElement) (![go.SliceType listElement] (StructFieldRef list' "e"%go (![go.PointerType list'] "w")), Convert go.uint64 go.int (![go.uint64] "idx"))))) in
    "$defer" <-[deferType] (let: "$oldf" := (![deferType] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: ("$ret0", "$ret1") := (map.lookup2 go.uint64 (go.ChannelType go.sendrecv go.any) (![go.MapType go.uint64 (go.ChannelType go.sendrecv go.any)] (StructFieldRef listElement "m"%go (IndexRef (go.SliceType listElement) (![go.SliceType listElement] (StructFieldRef list' "e"%go (![go.PointerType list'] "w")), Convert go.uint64 go.int (![go.uint64] "idx"))))) (![go.uint64] "id")) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  "$r0";;;
    do:  ("ok" <-[go.bool] "$r1");;;
    (if: (~ (![go.bool] "ok"))
    then
      let: "$r0" := (![go.ChannelType go.sendrecv go.any] "newCh") in
      do:  (map.insert go.uint64 (![go.MapType go.uint64 (go.ChannelType go.sendrecv go.any)] (StructFieldRef listElement "m"%go (IndexRef (go.SliceType listElement) (![go.SliceType listElement] (StructFieldRef list' "e"%go (![go.PointerType list'] "w")), Convert go.uint64 go.int (![go.uint64] "idx"))))) (![go.uint64] "id") "$r0")
    else
      do:  (let: "$a0" := #"dup id %x"%go in
      let: "$a1" := ((let: "$sl0" := (Convert go.uint64 go.any (![go.uint64] "id")) in
      CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0")]))) in
      (FuncResolve log.Panicf [] #()) "$a0" "$a1")));;;
    return: (Convert (go.ChannelType go.sendrecv go.any) (go.ChannelType go.recvonly go.any) (![go.ChannelType go.sendrecv go.any] "newCh"))).

(* go: wait.go:76:16 *)
Definition list__Triggerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "w" "id" "x",
    exception_do (let: "w" := (GoAlloc (go.PointerType list') "w") in
    let: "x" := (GoAlloc go.any "x") in
    let: "id" := (GoAlloc go.uint64 "id") in
    let: "idx" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := ((![go.uint64] "id") %⟨go.uint64⟩ (Convert go.untyped_int go.uint64 defaultListElementLength)) in
    do:  ("idx" <-[go.uint64] "$r0");;;
    do:  ((MethodResolve (go.PointerType sync.RWMutex) "Lock"%go (StructFieldRef listElement "l"%go (IndexRef (go.SliceType listElement) (![go.SliceType listElement] (StructFieldRef list' "e"%go (![go.PointerType list'] "w")), Convert go.uint64 go.int (![go.uint64] "idx"))))) #());;;
    let: "ch" := (GoAlloc (go.ChannelType go.sendrecv go.any) (GoZeroVal (go.ChannelType go.sendrecv go.any) #())) in
    let: "$r0" := (map.lookup1 go.uint64 (go.ChannelType go.sendrecv go.any) (![go.MapType go.uint64 (go.ChannelType go.sendrecv go.any)] (StructFieldRef listElement "m"%go (IndexRef (go.SliceType listElement) (![go.SliceType listElement] (StructFieldRef list' "e"%go (![go.PointerType list'] "w")), Convert go.uint64 go.int (![go.uint64] "idx"))))) (![go.uint64] "id")) in
    do:  ("ch" <-[go.ChannelType go.sendrecv go.any] "$r0");;;
    do:  (let: "$a0" := (![go.MapType go.uint64 (go.ChannelType go.sendrecv go.any)] (StructFieldRef listElement "m"%go (IndexRef (go.SliceType listElement) (![go.SliceType listElement] (StructFieldRef list' "e"%go (![go.PointerType list'] "w")), Convert go.uint64 go.int (![go.uint64] "idx"))))) in
    let: "$a1" := (![go.uint64] "id") in
    (FuncResolve go.delete [go.MapType go.uint64 (go.ChannelType go.sendrecv go.any)] #()) "$a0" "$a1");;;
    do:  ((MethodResolve (go.PointerType sync.RWMutex) "Unlock"%go (StructFieldRef listElement "l"%go (IndexRef (go.SliceType listElement) (![go.SliceType listElement] (StructFieldRef list' "e"%go (![go.PointerType list'] "w")), Convert go.uint64 go.int (![go.uint64] "idx"))))) #());;;
    (if: Convert go.untyped_bool go.bool ((![go.ChannelType go.sendrecv go.any] "ch") ≠⟨go.ChannelType go.sendrecv go.any⟩ (Convert go.untyped_nil (go.ChannelType go.sendrecv go.any) UntypedNil))
    then
      do:  (let: "$chan" := (![go.ChannelType go.sendrecv go.any] "ch") in
      let: "$v" := (![go.any] "x") in
      chan.send go.any "$chan" "$v");;;
      do:  (let: "$a0" := (![go.ChannelType go.sendrecv go.any] "ch") in
      (FuncResolve go.close [go.ChannelType go.sendrecv go.any] #()) "$a0")
    else do:  #());;;
    return: #()).

(* go: wait.go:88:16 *)
Definition list__IsRegisteredⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "w" "id",
    with_defer: (let: "w" := (GoAlloc (go.PointerType list') "w") in
    let: "id" := (GoAlloc go.uint64 "id") in
    let: "idx" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := ((![go.uint64] "id") %⟨go.uint64⟩ (Convert go.untyped_int go.uint64 defaultListElementLength)) in
    do:  ("idx" <-[go.uint64] "$r0");;;
    do:  ((MethodResolve (go.PointerType sync.RWMutex) "RLock"%go (StructFieldRef listElement "l"%go (IndexRef (go.SliceType listElement) (![go.SliceType listElement] (StructFieldRef list' "e"%go (![go.PointerType list'] "w")), Convert go.uint64 go.int (![go.uint64] "idx"))))) #());;;
    do:  (let: "$f" := (MethodResolve (go.PointerType sync.RWMutex) "RUnlock"%go (StructFieldRef listElement "l"%go (IndexRef (go.SliceType listElement) (![go.SliceType listElement] (StructFieldRef list' "e"%go (![go.PointerType list'] "w")), Convert go.uint64 go.int (![go.uint64] "idx"))))) in
    "$defer" <-[deferType] (let: "$oldf" := (![deferType] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: ("$ret0", "$ret1") := (map.lookup2 go.uint64 (go.ChannelType go.sendrecv go.any) (![go.MapType go.uint64 (go.ChannelType go.sendrecv go.any)] (StructFieldRef listElement "m"%go (IndexRef (go.SliceType listElement) (![go.SliceType listElement] (StructFieldRef list' "e"%go (![go.PointerType list'] "w")), Convert go.uint64 go.int (![go.uint64] "idx"))))) (![go.uint64] "id")) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  "$r0";;;
    do:  ("ok" <-[go.bool] "$r1");;;
    return: (![go.bool] "ok")).

(* go: wait.go:100:6 *)
Definition NewWithResponseⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "ch",
    exception_do (let: "ch" := (GoAlloc (go.ChannelType go.recvonly go.any) "ch") in
    return: (Convert (go.PointerType waitWithResponse) Wait (GoAlloc waitWithResponse (CompositeLiteral waitWithResponse (LiteralValue [KeyedElement (Some (KeyField "ch"%go)) (ElementExpression (go.ChannelType go.recvonly go.any) (![go.ChannelType go.recvonly go.any] "ch"))]))))).

(* go: wait.go:104:28 *)
Definition waitWithResponse__Registerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "w" "id",
    exception_do (let: "w" := (GoAlloc (go.PointerType waitWithResponse) "w") in
    let: "id" := (GoAlloc go.uint64 "id") in
    return: (![go.ChannelType go.recvonly go.any] (StructFieldRef waitWithResponse "ch"%go (![go.PointerType waitWithResponse] "w")))).

(* go: wait.go:107:28 *)
Definition waitWithResponse__Triggerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "w" "id" "x",
    exception_do (let: "w" := (GoAlloc (go.PointerType waitWithResponse) "w") in
    let: "x" := (GoAlloc go.any "x") in
    let: "id" := (GoAlloc go.uint64 "id") in
    do:  #()).

(* go: wait.go:108:28 *)
Definition waitWithResponse__IsRegisteredⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "w" "id",
    exception_do (let: "w" := (GoAlloc (go.PointerType waitWithResponse) "w") in
    let: "id" := (GoAlloc go.uint64 "id") in
    do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"waitWithResponse.IsRegistered() shouldn't be called"%go) in
    (FuncResolve go.panic [] #()) "$a0")).

(* go: wait_time.go:38:6 *)
Definition NewTimeListⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (GoAlloc timeList (CompositeLiteral timeList (LiteralValue [KeyedElement (Some (KeyField "m"%go)) (ElementExpression (go.MapType go.uint64 (go.ChannelType go.sendrecv (go.StructType [

      ]))) ((FuncResolve go.make1 [go.MapType go.uint64 (go.ChannelType go.sendrecv (go.StructType [

       ]))] #()) #()))])))).

(* go: wait_time.go:42:21 *)
Definition timeList__Waitⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "tl" "deadline",
    with_defer: (let: "tl" := (GoAlloc (go.PointerType timeList) "tl") in
    let: "deadline" := (GoAlloc go.uint64 "deadline") in
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (StructFieldRef timeList "l"%go (![go.PointerType timeList] "tl"))) #());;;
    do:  (let: "$f" := (MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (StructFieldRef timeList "l"%go (![go.PointerType timeList] "tl"))) in
    "$defer" <-[deferType] (let: "$oldf" := (![deferType] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] (StructFieldRef timeList "lastTriggerDeadline"%go (![go.PointerType timeList] "tl"))) ≥⟨go.uint64⟩ (![go.uint64] "deadline"))
    then
      return: (Convert (go.ChannelType go.sendrecv (go.StructType [

       ])) (go.ChannelType go.recvonly (go.StructType [

       ])) (![go.ChannelType go.sendrecv (go.StructType [

       ])] (GlobalVarAddr closec #())))
    else do:  #());;;
    let: "ch" := (GoAlloc (go.ChannelType go.sendrecv (go.StructType [

    ])) (GoZeroVal (go.ChannelType go.sendrecv (go.StructType [

    ])) #())) in
    let: "$r0" := (map.lookup1 go.uint64 (go.ChannelType go.sendrecv (go.StructType [

    ])) (![go.MapType go.uint64 (go.ChannelType go.sendrecv (go.StructType [

    ]))] (StructFieldRef timeList "m"%go (![go.PointerType timeList] "tl"))) (![go.uint64] "deadline")) in
    do:  ("ch" <-[go.ChannelType go.sendrecv (go.StructType [

    ])] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.ChannelType go.sendrecv (go.StructType [

    ])] "ch") =⟨go.ChannelType go.sendrecv (go.StructType [

    ])⟩ (Convert go.untyped_nil (go.ChannelType go.sendrecv (go.StructType [

    ])) UntypedNil))
    then
      let: "$r0" := ((FuncResolve go.make1 [go.ChannelType go.sendrecv (go.StructType [

       ])] #()) #()) in
      do:  ("ch" <-[go.ChannelType go.sendrecv (go.StructType [

      ])] "$r0");;;
      let: "$r0" := (![go.ChannelType go.sendrecv (go.StructType [

      ])] "ch") in
      do:  (map.insert go.uint64 (![go.MapType go.uint64 (go.ChannelType go.sendrecv (go.StructType [

      ]))] (StructFieldRef timeList "m"%go (![go.PointerType timeList] "tl"))) (![go.uint64] "deadline") "$r0")
    else do:  #());;;
    return: (Convert (go.ChannelType go.sendrecv (go.StructType [

     ])) (go.ChannelType go.recvonly (go.StructType [

     ])) (![go.ChannelType go.sendrecv (go.StructType [

     ])] "ch"))).

(* go: wait_time.go:56:21 *)
Definition timeList__Triggerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "tl" "deadline",
    with_defer: (let: "tl" := (GoAlloc (go.PointerType timeList) "tl") in
    let: "deadline" := (GoAlloc go.uint64 "deadline") in
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (StructFieldRef timeList "l"%go (![go.PointerType timeList] "tl"))) #());;;
    do:  (let: "$f" := (MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (StructFieldRef timeList "l"%go (![go.PointerType timeList] "tl"))) in
    "$defer" <-[deferType] (let: "$oldf" := (![deferType] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    let: "$r0" := (![go.uint64] "deadline") in
    do:  ((StructFieldRef timeList "lastTriggerDeadline"%go (![go.PointerType timeList] "tl")) <-[go.uint64] "$r0");;;
    let: "$range" := (![go.MapType go.uint64 (go.ChannelType go.sendrecv (go.StructType [

    ]))] (StructFieldRef timeList "m"%go (![go.PointerType timeList] "tl"))) in
    (let: "ch" := (GoAlloc (go.ChannelType go.sendrecv (go.StructType [

    ])) (GoZeroVal (go.ChannelType go.sendrecv (go.StructType [

    ])) #())) in
    let: "t" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    map.for_range go.uint64 (go.ChannelType go.sendrecv (go.StructType [

    ])) "$range" (λ: "$key" "value",
      do:  ("ch" <-[go.ChannelType go.sendrecv (go.StructType [

      ])] "$value");;;
      do:  ("t" <-[go.uint64] "$key");;;
      (if: Convert go.untyped_bool go.bool ((![go.uint64] "t") ≤⟨go.uint64⟩ (![go.uint64] "deadline"))
      then
        do:  (let: "$a0" := (![go.MapType go.uint64 (go.ChannelType go.sendrecv (go.StructType [

        ]))] (StructFieldRef timeList "m"%go (![go.PointerType timeList] "tl"))) in
        let: "$a1" := (![go.uint64] "t") in
        (FuncResolve go.delete [go.MapType go.uint64 (go.ChannelType go.sendrecv (go.StructType [

         ]))] #()) "$a0" "$a1");;;
        do:  (let: "$a0" := (![go.ChannelType go.sendrecv (go.StructType [

        ])] "ch") in
        (FuncResolve go.close [go.ChannelType go.sendrecv (go.StructType [

         ])] #()) "$a0")
      else do:  #())));;;
    return: #()).

#[global] Instance info' : PkgInfo pkg_id.wait :=
{|
  pkg_imported_pkgs := [code.log.pkg_id.log; code.sync.pkg_id.sync]
|}.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init pkg_id.wait (λ: <>,
      exception_do (do:  (go.GlobalAlloc closec (go.ChannelType go.sendrecv (go.StructType [

      ])) #());;;
      do:  (sync.initialize' #());;;
      do:  (log.initialize' #());;;
      do:  ((λ: <>,
        exception_do (let: "$r0" := ((FuncResolve go.make1 [go.ChannelType go.sendrecv (go.StructType [

         ])] #()) #()) in
        do:  ((GlobalVarAddr closec #()) <-[go.ChannelType go.sendrecv (go.StructType [

        ])] "$r0");;;
        do:  (let: "$a0" := (![go.ChannelType go.sendrecv (go.StructType [

        ])] (GlobalVarAddr closec #())) in
        (FuncResolve go.close [go.ChannelType go.sendrecv (go.StructType [

         ])] #()) "$a0");;;
        return: #())
        ) #()))
      ).

Module Wait.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := interface.t.
End def.
End Wait.

Definition Waitⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.InterfaceType [go.MethodElem "IsRegistered"%go (go.Signature [go.uint64] false [go.bool]); go.MethodElem "Register"%go (go.Signature [go.uint64] false [go.ChannelType go.recvonly go.any]); go.MethodElem "Trigger"%go (go.Signature [go.uint64; go.any] false [])].

Class Wait_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Wait_underlying :: (Wait) <u (Waitⁱᵐᵖˡ);
}.

Module list'.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  e' : slice.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End list'.

Definition list'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "e"%go (go.SliceType listElement))
].
Program Definition list'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (list'fds_unsealed).
Global Instance equals_unfold_list {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list'fds =→ list'fds_unsealed.
Proof. rewrite /list'fds seal_eq //. Qed.

Definition list'ⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (list'fds).

Class list_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] list_type_repr  :: go.TypeReprUnderlying list'ⁱᵐᵖˡ list'.t;
  #[global] list_underlying :: (list') <u (list'ⁱᵐᵖˡ);
  #[global] list_get_e (x : list'.t) :: ⟦StructFieldGet (list'ⁱᵐᵖˡ) "e", #x⟧ ⤳[under] #x.(list'.e');
  #[global] list_set_e (x : list'.t) y :: ⟦StructFieldSet (list'ⁱᵐᵖˡ) "e", (#x, #y)⟧ ⤳[under] #(x <|list'.e' := y|>);
  #[global] list'ptr_IsRegistered_unfold :: MethodUnfold (go.PointerType (list')) "IsRegistered" (list__IsRegisteredⁱᵐᵖˡ);
  #[global] list'ptr_Register_unfold :: MethodUnfold (go.PointerType (list')) "Register" (list__Registerⁱᵐᵖˡ);
  #[global] list'ptr_Trigger_unfold :: MethodUnfold (go.PointerType (list')) "Trigger" (list__Triggerⁱᵐᵖˡ);
}.

Module listElement.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  l' : sync.RWMutex.t;
  m' : loc;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End listElement.

Definition listElement'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "l"%go sync.RWMutex);
  (go.FieldDecl "m"%go (go.MapType go.uint64 (go.ChannelType go.sendrecv go.any)))
].
Program Definition listElement'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (listElement'fds_unsealed).
Global Instance equals_unfold_listElement {ext : ffi_syntax} {go_gctx : GoGlobalContext} : listElement'fds =→ listElement'fds_unsealed.
Proof. rewrite /listElement'fds seal_eq //. Qed.

Definition listElementⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (listElement'fds).

Class listElement_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] listElement_type_repr  :: go.TypeReprUnderlying listElementⁱᵐᵖˡ listElement.t;
  #[global] listElement_underlying :: (listElement) <u (listElementⁱᵐᵖˡ);
  #[global] listElement_get_l (x : listElement.t) :: ⟦StructFieldGet (listElementⁱᵐᵖˡ) "l", #x⟧ ⤳[under] #x.(listElement.l');
  #[global] listElement_set_l (x : listElement.t) y :: ⟦StructFieldSet (listElementⁱᵐᵖˡ) "l", (#x, #y)⟧ ⤳[under] #(x <|listElement.l' := y|>);
  #[global] listElement_get_m (x : listElement.t) :: ⟦StructFieldGet (listElementⁱᵐᵖˡ) "m", #x⟧ ⤳[under] #x.(listElement.m');
  #[global] listElement_set_m (x : listElement.t) y :: ⟦StructFieldSet (listElementⁱᵐᵖˡ) "m", (#x, #y)⟧ ⤳[under] #(x <|listElement.m' := y|>);
}.

Module waitWithResponse.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  ch' : loc;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End waitWithResponse.

Definition waitWithResponse'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "ch"%go (go.ChannelType go.recvonly go.any))
].
Program Definition waitWithResponse'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (waitWithResponse'fds_unsealed).
Global Instance equals_unfold_waitWithResponse {ext : ffi_syntax} {go_gctx : GoGlobalContext} : waitWithResponse'fds =→ waitWithResponse'fds_unsealed.
Proof. rewrite /waitWithResponse'fds seal_eq //. Qed.

Definition waitWithResponseⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (waitWithResponse'fds).

Class waitWithResponse_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] waitWithResponse_type_repr  :: go.TypeReprUnderlying waitWithResponseⁱᵐᵖˡ waitWithResponse.t;
  #[global] waitWithResponse_underlying :: (waitWithResponse) <u (waitWithResponseⁱᵐᵖˡ);
  #[global] waitWithResponse_get_ch (x : waitWithResponse.t) :: ⟦StructFieldGet (waitWithResponseⁱᵐᵖˡ) "ch", #x⟧ ⤳[under] #x.(waitWithResponse.ch');
  #[global] waitWithResponse_set_ch (x : waitWithResponse.t) y :: ⟦StructFieldSet (waitWithResponseⁱᵐᵖˡ) "ch", (#x, #y)⟧ ⤳[under] #(x <|waitWithResponse.ch' := y|>);
  #[global] waitWithResponse'ptr_IsRegistered_unfold :: MethodUnfold (go.PointerType (waitWithResponse)) "IsRegistered" (waitWithResponse__IsRegisteredⁱᵐᵖˡ);
  #[global] waitWithResponse'ptr_Register_unfold :: MethodUnfold (go.PointerType (waitWithResponse)) "Register" (waitWithResponse__Registerⁱᵐᵖˡ);
  #[global] waitWithResponse'ptr_Trigger_unfold :: MethodUnfold (go.PointerType (waitWithResponse)) "Trigger" (waitWithResponse__Triggerⁱᵐᵖˡ);
}.

Module WaitTime.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := interface.t.
End def.
End WaitTime.

Definition WaitTimeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.InterfaceType [go.MethodElem "Trigger"%go (go.Signature [go.uint64] false []); go.MethodElem "Wait"%go (go.Signature [go.uint64] false [go.ChannelType go.recvonly (go.StructType [

  ])])].

Class WaitTime_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] WaitTime_underlying :: (WaitTime) <u (WaitTimeⁱᵐᵖˡ);
}.

Module timeList.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  l' : sync.Mutex.t;
  lastTriggerDeadline' : w64;
  m' : loc;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End timeList.

Definition timeList'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "l"%go sync.Mutex);
  (go.FieldDecl "lastTriggerDeadline"%go go.uint64);
  (go.FieldDecl "m"%go (go.MapType go.uint64 (go.ChannelType go.sendrecv (go.StructType [

  ]))))
].
Program Definition timeList'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (timeList'fds_unsealed).
Global Instance equals_unfold_timeList {ext : ffi_syntax} {go_gctx : GoGlobalContext} : timeList'fds =→ timeList'fds_unsealed.
Proof. rewrite /timeList'fds seal_eq //. Qed.

Definition timeListⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (timeList'fds).

Class timeList_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] timeList_type_repr  :: go.TypeReprUnderlying timeListⁱᵐᵖˡ timeList.t;
  #[global] timeList_underlying :: (timeList) <u (timeListⁱᵐᵖˡ);
  #[global] timeList_get_l (x : timeList.t) :: ⟦StructFieldGet (timeListⁱᵐᵖˡ) "l", #x⟧ ⤳[under] #x.(timeList.l');
  #[global] timeList_set_l (x : timeList.t) y :: ⟦StructFieldSet (timeListⁱᵐᵖˡ) "l", (#x, #y)⟧ ⤳[under] #(x <|timeList.l' := y|>);
  #[global] timeList_get_lastTriggerDeadline (x : timeList.t) :: ⟦StructFieldGet (timeListⁱᵐᵖˡ) "lastTriggerDeadline", #x⟧ ⤳[under] #x.(timeList.lastTriggerDeadline');
  #[global] timeList_set_lastTriggerDeadline (x : timeList.t) y :: ⟦StructFieldSet (timeListⁱᵐᵖˡ) "lastTriggerDeadline", (#x, #y)⟧ ⤳[under] #(x <|timeList.lastTriggerDeadline' := y|>);
  #[global] timeList_get_m (x : timeList.t) :: ⟦StructFieldGet (timeListⁱᵐᵖˡ) "m", #x⟧ ⤳[under] #x.(timeList.m');
  #[global] timeList_set_m (x : timeList.t) y :: ⟦StructFieldSet (timeListⁱᵐᵖˡ) "m", (#x, #y)⟧ ⤳[under] #(x <|timeList.m' := y|>);
  #[global] timeList'ptr_Trigger_unfold :: MethodUnfold (go.PointerType (timeList)) "Trigger" (timeList__Triggerⁱᵐᵖˡ);
  #[global] timeList'ptr_Wait_unfold :: MethodUnfold (go.PointerType (timeList)) "Wait" (timeList__Waitⁱᵐᵖˡ);
}.

Class Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Wait_instance :: Wait_Assumptions;
  #[global] list_instance :: list_Assumptions;
  #[global] listElement_instance :: listElement_Assumptions;
  #[global] waitWithResponse_instance :: waitWithResponse_Assumptions;
  #[global] WaitTime_instance :: WaitTime_Assumptions;
  #[global] timeList_instance :: timeList_Assumptions;
  #[global] New_unfold :: FuncUnfold New [] (Newⁱᵐᵖˡ);
  #[global] NewWithResponse_unfold :: FuncUnfold NewWithResponse [] (NewWithResponseⁱᵐᵖˡ);
  #[global] NewTimeList_unfold :: FuncUnfold NewTimeList [] (NewTimeListⁱᵐᵖˡ);
  #[global] import_log_Assumption :: log.Assumptions;
  #[global] import_sync_Assumption :: sync.Assumptions;
}.
End wait.
