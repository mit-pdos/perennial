(* autogenerated from go.etcd.io/etcd/pkg/v3/idutil *)
Require Export New.code.math.
Require Export New.code.sync.atomic.
Require Export New.code.time.

From New.golang Require Import defn.
Definition idutil : go_string := "go.etcd.io/etcd/pkg/v3/idutil".

Module idutil.

Module Generator. Definition id : go_string := "go.etcd.io/etcd/pkg/v3/idutil.Generator"%go. End Generator.

Section code.
Context `{ffi_syntax}.


Definition tsLen : Z := 40.

Definition cntLen : Z := 8.

Definition suffixLen : Z := 48.

Definition Generator : go_type := structT [
  "prefix" :: uint64T;
  "suffix" :: uint64T
].
#[global] Typeclasses Opaque Generator.
#[global] Opaque Generator.

Definition NewGenerator : go_string := "go.etcd.io/etcd/pkg/v3/idutil.NewGenerator"%go.

Definition lowbit : go_string := "go.etcd.io/etcd/pkg/v3/idutil.lowbit"%go.

(* go: id.go:56:6 *)
Definition NewGeneratorⁱᵐᵖˡ : val :=
  λ: "memberID" "now",
    exception_do (let: "now" := (mem.alloc "now") in
    let: "memberID" := (mem.alloc "memberID") in
    let: "prefix" := (mem.alloc (type.zero_val uint64T)) in
    let: "$r0" := ((u_to_w64 (![uint16T] "memberID")) ≪ #(W64 suffixLen)) in
    do:  ("prefix" <-[uint64T] "$r0");;;
    let: "unixMilli" := (mem.alloc (type.zero_val uint64T)) in
    let: "$r0" := ((s_to_w64 ((method_call #(ptrT.id time.Time.id) #"UnixNano"%go "now") #())) `quot` (s_to_w64 (time.Millisecond `quots` time.Nanosecond))) in
    do:  ("unixMilli" <-[uint64T] "$r0");;;
    let: "suffix" := (mem.alloc (type.zero_val uint64T)) in
    let: "$r0" := ((let: "$a0" := (![uint64T] "unixMilli") in
    let: "$a1" := #(W64 tsLen) in
    (func_call #lowbit) "$a0" "$a1") ≪ #(W64 cntLen)) in
    do:  ("suffix" <-[uint64T] "$r0");;;
    return: (mem.alloc (let: "$prefix" := (![uint64T] "prefix") in
     let: "$suffix" := (![uint64T] "suffix") in
     struct.make Generator [{
       "prefix" ::= "$prefix";
       "suffix" ::= "$suffix"
     }]))).

(* Next generates a id that is unique.

   go: id.go:67:21 *)
Definition Generator__Nextⁱᵐᵖˡ : val :=
  λ: "g" <>,
    exception_do (let: "g" := (mem.alloc "g") in
    let: "suffix" := (mem.alloc (type.zero_val uint64T)) in
    let: "$r0" := (let: "$a0" := (struct.field_ref ptrT #"suffix"%go (![ptrT] "g")) in
    let: "$a1" := #(W64 1) in
    (func_call #atomic.AddUint64) "$a0" "$a1") in
    do:  ("suffix" <-[uint64T] "$r0");;;
    let: "id" := (mem.alloc (type.zero_val uint64T)) in
    let: "$r0" := ((![uint64T] (struct.field_ref ptrT #"prefix"%go (![ptrT] "g"))) `or` (let: "$a0" := (![uint64T] "suffix") in
    let: "$a1" := #(W64 suffixLen) in
    (func_call #lowbit) "$a0" "$a1")) in
    do:  ("id" <-[uint64T] "$r0");;;
    return: (![uint64T] "id")).

(* go: id.go:73:6 *)
Definition lowbitⁱᵐᵖˡ : val :=
  λ: "x" "n",
    exception_do (let: "n" := (mem.alloc "n") in
    let: "x" := (mem.alloc "x") in
    return: ((![uint64T] "x") `and` (#(W64 math.MaxUint64) ≫ (u_to_w64 (#(W64 64) - (![uintT] "n")))))).

Definition vars' : list (go_string * go_type) := [].

Definition functions' : list (go_string * val) := [(NewGenerator, NewGeneratorⁱᵐᵖˡ); (lowbit, lowbitⁱᵐᵖˡ)].

Definition msets' : list (go_string * (list (go_string * val))) := [(Generator.id, []); (ptrT.id Generator.id, [("Next"%go, Generator__Nextⁱᵐᵖˡ)])].

#[global] Instance info' : PkgInfo idutil.idutil :=
  {|
    pkg_vars := vars';
    pkg_functions := functions';
    pkg_msets := msets';
    pkg_imported_pkgs := [code.math.math; code.sync.atomic.atomic; code.time.time];
  |}.

Definition initialize' : val :=
  λ: <>,
    package.init #idutil.idutil (λ: <>,
      exception_do (do:  (time.initialize' #());;;
      do:  (atomic.initialize' #());;;
      do:  (math.initialize' #());;;
      do:  (package.alloc idutil.idutil #()))
      ).

End code.
End idutil.
