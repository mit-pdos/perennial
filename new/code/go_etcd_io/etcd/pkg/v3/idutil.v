(* autogenerated from go.etcd.io/etcd/pkg/v3/idutil *)
Require Export New.code.math.
Require Export New.code.sync.atomic.
Require Export New.code.time.
From New.golang Require Import defn.
Module pkg_id.
Definition idutil : go_string := "go.etcd.io/etcd/pkg/v3/idutil".

End pkg_id.
Export pkg_id.
Module idutil.

Definition Generator {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/etcd/pkg/v3/idutil.Generator"%go [].

Definition tsLen {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #40.

Definition cntLen {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #8.

Definition suffixLen {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #48.

Definition NewGenerator {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/pkg/v3/idutil.NewGenerator"%go.

Definition lowbit {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/etcd/pkg/v3/idutil.lowbit"%go.

(* go: id.go:56:6 *)
Definition NewGeneratorⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "memberID" "now",
    exception_do (let: "now" := (GoAlloc time.Time "now") in
    let: "memberID" := (GoAlloc go.uint16 "memberID") in
    let: "prefix" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := ((Convert go.uint16 go.uint64 (![go.uint16] "memberID")) <<⟨go.uint64⟩ (Convert go.untyped_int go.uint64 suffixLen)) in
    do:  ("prefix" <-[go.uint64] "$r0");;;
    let: "unixMilli" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := ((Convert go.int64 go.uint64 ((MethodResolve time.Time "UnixNano"%go (![time.Time] "now")) #())) /⟨go.uint64⟩ (Convert time.Duration go.uint64 (time.Millisecond /⟨go.int64⟩ time.Nanosecond))) in
    do:  ("unixMilli" <-[go.uint64] "$r0");;;
    let: "suffix" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := ((let: "$a0" := (![go.uint64] "unixMilli") in
    let: "$a1" := (Convert go.untyped_int go.uint tsLen) in
    (FuncResolve lowbit [] #()) "$a0" "$a1") <<⟨go.uint64⟩ (Convert go.untyped_int go.uint64 cntLen)) in
    do:  ("suffix" <-[go.uint64] "$r0");;;
    return: (GoAlloc Generator (let: "$v0" := (![go.uint64] "prefix") in
     let: "$v1" := (![go.uint64] "suffix") in
     CompositeLiteral Generator (LiteralValue [KeyedElement (Some (KeyField "prefix"%go)) (ElementExpression go.uint64 "$v0"); KeyedElement (Some (KeyField "suffix"%go)) (ElementExpression go.uint64 "$v1")])))).

(* Next generates a id that is unique.

   go: id.go:67:21 *)
Definition Generator__Nextⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "g" <>,
    exception_do (let: "g" := (GoAlloc (go.PointerType Generator) "g") in
    let: "suffix" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (let: "$a0" := (StructFieldRef Generator "suffix"%go (![go.PointerType Generator] "g")) in
    let: "$a1" := #(W64 1) in
    (FuncResolve atomic.AddUint64 [] #()) "$a0" "$a1") in
    do:  ("suffix" <-[go.uint64] "$r0");;;
    let: "id" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := ((![go.uint64] (StructFieldRef Generator "prefix"%go (![go.PointerType Generator] "g"))) |⟨go.uint64⟩ (let: "$a0" := (![go.uint64] "suffix") in
    let: "$a1" := (Convert go.untyped_int go.uint suffixLen) in
    (FuncResolve lowbit [] #()) "$a0" "$a1")) in
    do:  ("id" <-[go.uint64] "$r0");;;
    return: (![go.uint64] "id")).

(* go: id.go:73:6 *)
Definition lowbitⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "x" "n",
    exception_do (let: "n" := (GoAlloc go.uint "n") in
    let: "x" := (GoAlloc go.uint64 "x") in
    return: ((![go.uint64] "x") &⟨go.uint64⟩ ((Convert go.untyped_int go.uint64 math.MaxUint64) >>⟨go.uint64⟩ (Convert go.uint go.uint64 (#(W64 64) -⟨go.uint⟩ (![go.uint] "n")))))).

#[global] Instance info' : PkgInfo pkg_id.idutil :=
{|
  pkg_imported_pkgs := [code.math.pkg_id.math; code.sync.atomic.pkg_id.atomic; code.time.pkg_id.time]
|}.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init pkg_id.idutil (λ: <>,
      exception_do (do:  (time.initialize' #());;;
      do:  (atomic.initialize' #());;;
      do:  (math.initialize' #()))
      ).

Module Generator.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  prefix' : w64;
  suffix' : w64;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End Generator.

Definition Generator'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "prefix"%go go.uint64);
  (go.FieldDecl "suffix"%go go.uint64)
].
Program Definition Generator'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (Generator'fds_unsealed).
Global Instance equals_unfold_Generator {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Generator'fds =→ Generator'fds_unsealed.
Proof. rewrite /Generator'fds seal_eq //. Qed.

Definition Generatorⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (Generator'fds).

Class Generator_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Generator_type_repr  :: go.TypeReprUnderlying Generatorⁱᵐᵖˡ Generator.t;
  #[global] Generator_underlying :: (Generator) <u (Generatorⁱᵐᵖˡ);
  #[global] Generator_get_prefix (x : Generator.t) :: ⟦StructFieldGet (Generatorⁱᵐᵖˡ) "prefix", #x⟧ ⤳[under] #x.(Generator.prefix');
  #[global] Generator_set_prefix (x : Generator.t) y :: ⟦StructFieldSet (Generatorⁱᵐᵖˡ) "prefix", (#x, #y)⟧ ⤳[under] #(x <|Generator.prefix' := y|>);
  #[global] Generator_get_suffix (x : Generator.t) :: ⟦StructFieldGet (Generatorⁱᵐᵖˡ) "suffix", #x⟧ ⤳[under] #x.(Generator.suffix');
  #[global] Generator_set_suffix (x : Generator.t) y :: ⟦StructFieldSet (Generatorⁱᵐᵖˡ) "suffix", (#x, #y)⟧ ⤳[under] #(x <|Generator.suffix' := y|>);
  #[global] Generator'ptr_Next_unfold :: MethodUnfold (go.PointerType (Generator)) "Next" (Generator__Nextⁱᵐᵖˡ);
}.

Class Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Generator_instance :: Generator_Assumptions;
  #[global] NewGenerator_unfold :: FuncUnfold NewGenerator [] (NewGeneratorⁱᵐᵖˡ);
  #[global] lowbit_unfold :: FuncUnfold lowbit [] (lowbitⁱᵐᵖˡ);
  #[global] import_math_Assumption :: math.Assumptions;
  #[global] import_atomic_Assumption :: atomic.Assumptions;
  #[global] import_time_Assumption :: time.Assumptions;
}.
End idutil.
