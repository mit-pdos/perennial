(* autogenerated from go.etcd.io/raft/v3 *)
Require Export New.code.errors.
Require Export New.code.go_etcd_io.raft.v3.raftpb.
Require Export New.code.fmt.
Require Export New.code.io.
Require Export New.code.log.
Require Export New.code.os.
Require Export New.code.sync.
Require Export New.code.context.
Require Export New.code.bytes.
Require Export New.code.crypto.rand.
Require Export New.code.math.
Require Export New.code.math.big.
Require Export New.code.strings.
Require Export New.code.go_etcd_io.raft.v3.confchange.
Require Export New.code.go_etcd_io.raft.v3.quorum.
Require Export New.code.go_etcd_io.raft.v3.quorum.slices.
Require Export New.code.go_etcd_io.raft.v3.tracker.
From New.golang Require Import defn.
Module pkg_id.
Definition raft : go_string := "go.etcd.io/raft/v3".

End pkg_id.
Export pkg_id.
Module raft.

Definition raftLog {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/raft/v3.raftLog"%go [].

Definition unstable {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/raft/v3.unstable"%go [].

Definition Logger {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/raft/v3.Logger"%go [].

Definition DefaultLogger {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/raft/v3.DefaultLogger"%go [].

Definition SnapshotStatus {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/raft/v3.SnapshotStatus"%go [].

Definition SoftState {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/raft/v3.SoftState"%go [].

Definition Ready {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/raft/v3.Ready"%go [].

Definition Node {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/raft/v3.Node"%go [].

Definition Peer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/raft/v3.Peer"%go [].

Definition msgWithResult {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/raft/v3.msgWithResult"%go [].

Definition node {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/raft/v3.node"%go [].

Definition ReadOnlyOption {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/raft/v3.ReadOnlyOption"%go [].

Definition lockedRand {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/raft/v3.lockedRand"%go [].

Definition CampaignType {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/raft/v3.CampaignType"%go [].

Definition StateType {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/raft/v3.StateType"%go [].

Definition Config {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/raft/v3.Config"%go [].

Definition raft {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/raft/v3.raft"%go [].

Definition stepFunc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/raft/v3.stepFunc"%go [].

Definition RawNode {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/raft/v3.RawNode"%go [].

Definition ProgressType {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/raft/v3.ProgressType"%go [].

Definition ReadState {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/raft/v3.ReadState"%go [].

Definition readIndexStatus {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/raft/v3.readIndexStatus"%go [].

Definition readOnly {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/raft/v3.readOnly"%go [].

Definition TraceLogger {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/raft/v3.TraceLogger"%go [].

Definition TracingEvent {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/raft/v3.TracingEvent"%go [].

Definition Status {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/raft/v3.Status"%go [].

Definition BasicStatus {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/raft/v3.BasicStatus"%go [].

Definition Storage {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/raft/v3.Storage"%go [].

Definition inMemStorageCallStats {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/raft/v3.inMemStorageCallStats"%go [].

Definition MemoryStorage {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/raft/v3.MemoryStorage"%go [].

Definition entryID {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/raft/v3.entryID"%go [].

Definition logSlice {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/raft/v3.logSlice"%go [].

Definition EntryFormatter {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/raft/v3.EntryFormatter"%go [].

Definition entryEncodingSize {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/raft/v3.entryEncodingSize"%go [].

Definition entryPayloadSize {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/raft/v3.entryPayloadSize"%go [].

Definition lenMultiple {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #2.

Definition calldepth {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #2.

Definition SnapshotFinish {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 1).

Definition SnapshotFailure {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 2).

Definition None {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 0).

Definition LocalAppendThread {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 18446744073709551615).

Definition LocalApplyThread {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 18446744073709551614).

Definition StateFollower {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 0).

Definition StateCandidate {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 1).

Definition StateLeader {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 2).

Definition StatePreCandidate {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 3).

Definition numStates {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 4).

Definition ReadOnlySafe {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 0).

Definition ReadOnlyLeaseBased {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 1).

Definition campaignPreElection {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #"CampaignPreElection"%go.

Definition campaignElection {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #"CampaignElection"%go.

Definition campaignTransfer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #"CampaignTransfer"%go.

Definition noLimit {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #18446744073709551615.

Definition ProgressTypePeer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W8 0).

Definition ProgressTypeLearner {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W8 1).

Definition StateTraceDeployed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #false.

Definition defaultLogger {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.defaultLogger"%go.

Definition discardLogger {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.discardLogger"%go.

Definition raftLoggerMu {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.raftLoggerMu"%go.

Definition raftLogger {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.raftLogger"%go.

Definition emptyState {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.emptyState"%go.

Definition ErrStopped {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.ErrStopped"%go.

Definition ErrProposalDropped {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.ErrProposalDropped"%go.

Definition globalRand {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.globalRand"%go.

Definition stmap {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.stmap"%go.

Definition errBreak {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.errBreak"%go.

Definition ErrStepLocalMsg {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.ErrStepLocalMsg"%go.

Definition ErrStepPeerNotFound {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.ErrStepPeerNotFound"%go.

Definition ErrCompacted {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.ErrCompacted"%go.

Definition ErrSnapOutOfDate {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.ErrSnapOutOfDate"%go.

Definition ErrUnavailable {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.ErrUnavailable"%go.

Definition ErrSnapshotTemporarilyUnavailable {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.ErrSnapshotTemporarilyUnavailable"%go.

Definition isLocalMsg {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.isLocalMsg"%go.

Definition isResponseMsg {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.isResponseMsg"%go.

Definition newLog {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.newLog"%go.

Definition newLogWithSize {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.newLogWithSize"%go.

Definition SetLogger {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.SetLogger"%go.

Definition ResetDefaultLogger {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.ResetDefaultLogger"%go.

Definition getLogger {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.getLogger"%go.

Definition header {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.header"%go.

Definition isHardStateEqual {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.isHardStateEqual"%go.

Definition IsEmptyHardState {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.IsEmptyHardState"%go.

Definition IsEmptySnap {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.IsEmptySnap"%go.

Definition setupNode {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.setupNode"%go.

Definition StartNode {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.StartNode"%go.

Definition RestartNode {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.RestartNode"%go.

Definition newNode {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.newNode"%go.

Definition confChangeToMsg {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.confChangeToMsg"%go.

Definition newRaft {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.newRaft"%go.

Definition stepLeader {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.stepLeader"%go.

Definition stepCandidate {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.stepCandidate"%go.

Definition stepFollower {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.stepFollower"%go.

Definition logSliceFromMsgApp {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.logSliceFromMsgApp"%go.

Definition releasePendingReadIndexMessages {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.releasePendingReadIndexMessages"%go.

Definition sendMsgReadIndexResponse {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.sendMsgReadIndexResponse"%go.

Definition NewRawNode {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.NewRawNode"%go.

Definition MustSync {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.MustSync"%go.

Definition needStorageAppendMsg {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.needStorageAppendMsg"%go.

Definition needStorageAppendRespMsg {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.needStorageAppendRespMsg"%go.

Definition newStorageAppendMsg {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.newStorageAppendMsg"%go.

Definition newStorageAppendRespMsg {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.newStorageAppendRespMsg"%go.

Definition needStorageApplyMsg {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.needStorageApplyMsg"%go.

Definition needStorageApplyRespMsg {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.needStorageApplyRespMsg"%go.

Definition newStorageApplyMsg {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.newStorageApplyMsg"%go.

Definition newStorageApplyRespMsg {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.newStorageApplyRespMsg"%go.

Definition newReadOnly {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.newReadOnly"%go.

Definition traceInitState {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.traceInitState"%go.

Definition traceReady {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.traceReady"%go.

Definition traceCommit {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.traceCommit"%go.

Definition traceReplicate {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.traceReplicate"%go.

Definition traceBecomeFollower {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.traceBecomeFollower"%go.

Definition traceBecomeCandidate {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.traceBecomeCandidate"%go.

Definition traceBecomeLeader {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.traceBecomeLeader"%go.

Definition traceChangeConfEvent {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.traceChangeConfEvent"%go.

Definition traceConfChangeEvent {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.traceConfChangeEvent"%go.

Definition traceSendMessage {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.traceSendMessage"%go.

Definition traceReceiveMessage {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.traceReceiveMessage"%go.

Definition getProgressCopy {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.getProgressCopy"%go.

Definition getBasicStatus {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.getBasicStatus"%go.

Definition getStatus {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.getStatus"%go.

Definition NewMemoryStorage {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.NewMemoryStorage"%go.

Definition pbEntryID {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.pbEntryID"%go.

Definition isMsgInArray {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.isMsgInArray"%go.

Definition IsLocalMsg {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.IsLocalMsg"%go.

Definition IsResponseMsg {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.IsResponseMsg"%go.

Definition IsLocalMsgTarget {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.IsLocalMsgTarget"%go.

Definition voteRespMsgType {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.voteRespMsgType"%go.

Definition DescribeHardState {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.DescribeHardState"%go.

Definition DescribeSoftState {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.DescribeSoftState"%go.

Definition DescribeConfState {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.DescribeConfState"%go.

Definition DescribeSnapshot {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.DescribeSnapshot"%go.

Definition DescribeReady {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.DescribeReady"%go.

Definition DescribeMessage {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.DescribeMessage"%go.

Definition describeMessageWithIndent {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.describeMessageWithIndent"%go.

Definition describeTarget {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.describeTarget"%go.

Definition DescribeEntry {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.DescribeEntry"%go.

Definition DescribeEntries {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.DescribeEntries"%go.

Definition entsSize {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.entsSize"%go.

Definition limitSize {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.limitSize"%go.

Definition payloadSize {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.payloadSize"%go.

Definition payloadsSize {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.payloadsSize"%go.

Definition assertConfStatesEquivalent {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.assertConfStatesEquivalent"%go.

Definition extend {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3.extend"%go.

(* Bootstrap initializes the RawNode for first use by appending configuration
   changes for the supplied peers. This method returns an error if the Storage
   is nonempty.

   It is recommended that instead of calling this method, applications bootstrap
   their state manually by setting up a Storage that has a first index > 1 and
   which stores the desired ConfState as its InitialState.

   go: bootstrap.go:30:20 *)
Definition RawNode__Bootstrapⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "rn" "peers",
    exception_do (let: "rn" := (GoAlloc (go.PointerType RawNode) "rn") in
    let: "peers" := (GoAlloc (go.SliceType Peer) "peers") in
    (if: Convert go.untyped_bool go.bool ((let: "$a0" := (![go.SliceType Peer] "peers") in
    (FuncResolve go.len [go.SliceType Peer] #()) "$a0") =⟨go.int⟩ #(W64 0))
    then
      return: (let: "$a0" := #"must provide at least one peer to Bootstrap"%go in
       (FuncResolve errors.New [] #()) "$a0")
    else do:  #());;;
    let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
    let: "lastIndex" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: ("$ret0", "$ret1") := ((MethodResolve Storage "LastIndex"%go (![Storage] (StructFieldRef raftLog "storage"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] (StructFieldRef RawNode "raft"%go (![go.PointerType RawNode] "rn")))))))) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("lastIndex" <-[go.uint64] "$r0");;;
    do:  ("err" <-[go.error] "$r1");;;
    (if: Convert go.untyped_bool go.bool ((![go.error] "err") ≠⟨go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]⟩ (Convert go.untyped_nil (go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]) UntypedNil))
    then return: (![go.error] "err")
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "lastIndex") ≠⟨go.uint64⟩ #(W64 0))
    then
      return: (let: "$a0" := #"can't bootstrap a nonempty Storage"%go in
       (FuncResolve errors.New [] #()) "$a0")
    else do:  #());;;
    let: "$r0" := (![raftpb.HardState] (GlobalVarAddr emptyState #())) in
    do:  ((StructFieldRef RawNode "prevHardSt"%go (![go.PointerType RawNode] "rn")) <-[raftpb.HardState] "$r0");;;
    do:  (let: "$a0" := #(W64 1) in
    let: "$a1" := None in
    (MethodResolve (go.PointerType raft) "becomeFollower"%go (![go.PointerType raft] (StructFieldRef RawNode "raft"%go (![go.PointerType RawNode] "rn")))) "$a0" "$a1");;;
    let: "ents" := (GoAlloc (go.SliceType raftpb.Entry) (GoZeroVal (go.SliceType raftpb.Entry) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType raftpb.Entry] #()) (let: "$a0" := (![go.SliceType Peer] "peers") in
    (FuncResolve go.len [go.SliceType Peer] #()) "$a0")) in
    do:  ("ents" <-[go.SliceType raftpb.Entry] "$r0");;;
    let: "$range" := (![go.SliceType Peer] "peers") in
    (let: "peer" := (GoAlloc Peer (GoZeroVal Peer #())) in
    let: "i" := (GoAlloc go.int (GoZeroVal go.int #())) in
    slice.for_range Peer "$range" (λ: "$key" "$value",
      do:  ("peer" <-[Peer] "$value");;;
      do:  ("i" <-[go.int] "$key");;;
      let: "cc" := (GoAlloc raftpb.ConfChange (GoZeroVal raftpb.ConfChange #())) in
      let: "$r0" := (CompositeLiteral raftpb.ConfChange (LiteralValue [KeyedElement (Some (KeyField "Type"%go)) (ElementExpression raftpb.ConfChangeType raftpb.ConfChangeAddNode); KeyedElement (Some (KeyField "NodeID"%go)) (ElementExpression go.uint64 (![go.uint64] (StructFieldRef Peer "ID"%go "peer"))); KeyedElement (Some (KeyField "Context"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] (StructFieldRef Peer "Context"%go "peer")))])) in
      do:  ("cc" <-[raftpb.ConfChange] "$r0");;;
      let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
      let: "data" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
      let: ("$ret0", "$ret1") := ((MethodResolve (go.PointerType raftpb.ConfChange) "Marshal"%go "cc") #()) in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("data" <-[go.SliceType go.byte] "$r0");;;
      do:  ("err" <-[go.error] "$r1");;;
      (if: Convert go.untyped_bool go.bool ((![go.error] "err") ≠⟨go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]⟩ (Convert go.untyped_nil (go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]) UntypedNil))
      then return: (![go.error] "err")
      else do:  #());;;
      let: "$r0" := (CompositeLiteral raftpb.Entry (LiteralValue [KeyedElement (Some (KeyField "Type"%go)) (ElementExpression raftpb.EntryType raftpb.EntryConfChange); KeyedElement (Some (KeyField "Term"%go)) (ElementExpression go.uint64 #(W64 1)); KeyedElement (Some (KeyField "Index"%go)) (ElementExpression go.uint64 (Convert go.int go.uint64 ((![go.int] "i") +⟨go.int⟩ #(W64 1)))); KeyedElement (Some (KeyField "Data"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] "data"))])) in
      do:  ((IndexRef (go.SliceType raftpb.Entry) (![go.SliceType raftpb.Entry] "ents", ![go.int] "i")) <-[raftpb.Entry] "$r0")));;;
    do:  (let: "$a0" := (![go.SliceType raftpb.Entry] "ents") in
    (MethodResolve (go.PointerType raftLog) "append"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] (StructFieldRef RawNode "raft"%go (![go.PointerType RawNode] "rn")))))) "$a0");;;
    let: "$r0" := (Convert go.int go.uint64 (let: "$a0" := (![go.SliceType raftpb.Entry] "ents") in
    (FuncResolve go.len [go.SliceType raftpb.Entry] #()) "$a0")) in
    do:  ((StructFieldRef raftLog "committed"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] (StructFieldRef RawNode "raft"%go (![go.PointerType RawNode] "rn")))))) <-[go.uint64] "$r0");;;
    let: "$range" := (![go.SliceType Peer] "peers") in
    (let: "peer" := (GoAlloc Peer (GoZeroVal Peer #())) in
    slice.for_range Peer "$range" (λ: "$key" "$value",
      do:  ("peer" <-[Peer] "$value");;;
      do:  "$key";;;
      do:  (let: "$a0" := ((MethodResolve raftpb.ConfChange "AsV2"%go (CompositeLiteral raftpb.ConfChange (LiteralValue [KeyedElement (Some (KeyField "NodeID"%go)) (ElementExpression go.uint64 (![go.uint64] (StructFieldRef Peer "ID"%go "peer"))); KeyedElement (Some (KeyField "Type"%go)) (ElementExpression raftpb.ConfChangeType raftpb.ConfChangeAddNode)]))) #()) in
      (MethodResolve (go.PointerType raft) "applyConfChange"%go (![go.PointerType raft] (StructFieldRef RawNode "raft"%go (![go.PointerType RawNode] "rn")))) "$a0")));;;
    return: (Convert go.untyped_nil go.error UntypedNil)).

(* newLog returns log using the given storage and default options. It
   recovers the log to the state that it just commits and applies the
   latest snapshot.

   go: log.go:67:6 *)
Definition newLogⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "storage" "logger",
    exception_do (let: "logger" := (GoAlloc Logger "logger") in
    let: "storage" := (GoAlloc Storage "storage") in
    return: (let: "$a0" := (![Storage] "storage") in
     let: "$a1" := (![Logger] "logger") in
     let: "$a2" := (Convert go.untyped_int entryEncodingSize noLimit) in
     (FuncResolve newLogWithSize [] #()) "$a0" "$a1" "$a2")).

(* newLogWithSize returns a log using the given storage and max
   message size.

   go: log.go:73:6 *)
Definition newLogWithSizeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "storage" "logger" "maxApplyingEntsSize",
    exception_do (let: "maxApplyingEntsSize" := (GoAlloc entryEncodingSize "maxApplyingEntsSize") in
    let: "logger" := (GoAlloc Logger "logger") in
    let: "storage" := (GoAlloc Storage "storage") in
    let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
    let: "firstIndex" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: ("$ret0", "$ret1") := ((MethodResolve Storage "FirstIndex"%go (![Storage] "storage")) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("firstIndex" <-[go.uint64] "$r0");;;
    do:  ("err" <-[go.error] "$r1");;;
    (if: Convert go.untyped_bool go.bool ((![go.error] "err") ≠⟨go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]⟩ (Convert go.untyped_nil (go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]) UntypedNil))
    then
      do:  (let: "$a0" := (Convert go.error (go.InterfaceType []) (![go.error] "err")) in
      (FuncResolve go.panic [] #()) "$a0")
    else do:  #());;;
    let: "lastIndex" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: ("$ret0", "$ret1") := ((MethodResolve Storage "LastIndex"%go (![Storage] "storage")) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("lastIndex" <-[go.uint64] "$r0");;;
    do:  ("err" <-[go.error] "$r1");;;
    (if: Convert go.untyped_bool go.bool ((![go.error] "err") ≠⟨go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]⟩ (Convert go.untyped_nil (go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]) UntypedNil))
    then
      do:  (let: "$a0" := (Convert go.error (go.InterfaceType []) (![go.error] "err")) in
      (FuncResolve go.panic [] #()) "$a0")
    else do:  #());;;
    return: (GoAlloc raftLog (CompositeLiteral raftLog (LiteralValue [KeyedElement (Some (KeyField "storage"%go)) (ElementExpression Storage (![Storage] "storage")); KeyedElement (Some (KeyField "unstable"%go)) (ElementExpression unstable (CompositeLiteral unstable (LiteralValue [KeyedElement (Some (KeyField "offset"%go)) (ElementExpression go.uint64 ((![go.uint64] "lastIndex") +⟨go.uint64⟩ #(W64 1))); KeyedElement (Some (KeyField "offsetInProgress"%go)) (ElementExpression go.uint64 ((![go.uint64] "lastIndex") +⟨go.uint64⟩ #(W64 1))); KeyedElement (Some (KeyField "logger"%go)) (ElementExpression Logger (![Logger] "logger"))]))); KeyedElement (Some (KeyField "maxApplyingEntsSize"%go)) (ElementExpression entryEncodingSize (![entryEncodingSize] "maxApplyingEntsSize")); KeyedElement (Some (KeyField "committed"%go)) (ElementExpression go.uint64 ((![go.uint64] "firstIndex") -⟨go.uint64⟩ #(W64 1))); KeyedElement (Some (KeyField "applying"%go)) (ElementExpression go.uint64 ((![go.uint64] "firstIndex") -⟨go.uint64⟩ #(W64 1))); KeyedElement (Some (KeyField "applied"%go)) (ElementExpression go.uint64 ((![go.uint64] "firstIndex") -⟨go.uint64⟩ #(W64 1))); KeyedElement (Some (KeyField "logger"%go)) (ElementExpression Logger (![Logger] "logger"))])))).

(* go: log.go:100:19 *)
Definition raftLog__Stringⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" <>,
    exception_do (let: "l" := (GoAlloc (go.PointerType raftLog) "l") in
    return: (let: "$a0" := #"committed=%d, applied=%d, applying=%d, unstable.offset=%d, unstable.offsetInProgress=%d, len(unstable.Entries)=%d"%go in
     let: "$a1" := ((let: "$sl0" := (Convert go.uint64 go.any (![go.uint64] (StructFieldRef raftLog "committed"%go (![go.PointerType raftLog] "l")))) in
     let: "$sl1" := (Convert go.uint64 go.any (![go.uint64] (StructFieldRef raftLog "applied"%go (![go.PointerType raftLog] "l")))) in
     let: "$sl2" := (Convert go.uint64 go.any (![go.uint64] (StructFieldRef raftLog "applying"%go (![go.PointerType raftLog] "l")))) in
     let: "$sl3" := (Convert go.uint64 go.any (![go.uint64] (StructFieldRef unstable "offset"%go (StructFieldRef raftLog "unstable"%go (![go.PointerType raftLog] "l"))))) in
     let: "$sl4" := (Convert go.uint64 go.any (![go.uint64] (StructFieldRef unstable "offsetInProgress"%go (StructFieldRef raftLog "unstable"%go (![go.PointerType raftLog] "l"))))) in
     let: "$sl5" := (Convert go.int go.any (let: "$a0" := (![go.SliceType raftpb.Entry] (StructFieldRef unstable "entries"%go (StructFieldRef raftLog "unstable"%go (![go.PointerType raftLog] "l")))) in
     (FuncResolve go.len [go.SliceType raftpb.Entry] #()) "$a0")) in
     CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0"); KeyedElement None (ElementExpression go.any "$sl1"); KeyedElement None (ElementExpression go.any "$sl2"); KeyedElement None (ElementExpression go.any "$sl3"); KeyedElement None (ElementExpression go.any "$sl4"); KeyedElement None (ElementExpression go.any "$sl5")]))) in
     (FuncResolve fmt.Sprintf [] #()) "$a0" "$a1")).

(* maybeAppend returns (0, false) if the entries cannot be appended. Otherwise,
   it returns (last index of new entries, true).

   go: log.go:107:19 *)
Definition raftLog__maybeAppendⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" "a" "committed",
    exception_do (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "lastnewi" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "l" := (GoAlloc (go.PointerType raftLog) "l") in
    let: "committed" := (GoAlloc go.uint64 "committed") in
    let: "a" := (GoAlloc logSlice "a") in
    (if: (~ (let: "$a0" := (![entryID] (StructFieldRef logSlice "prev"%go "a")) in
    (MethodResolve (go.PointerType raftLog) "matchTerm"%go (![go.PointerType raftLog] "l")) "$a0"))
    then return: (#(W64 0), #false)
    else do:  #());;;
    let: "$r0" := ((![go.uint64] (StructFieldRef entryID "index"%go (StructFieldRef logSlice "prev"%go "a"))) +⟨go.uint64⟩ (Convert go.int go.uint64 (let: "$a0" := (![go.SliceType raftpb.Entry] (StructFieldRef logSlice "entries"%go "a")) in
    (FuncResolve go.len [go.SliceType raftpb.Entry] #()) "$a0"))) in
    do:  ("lastnewi" <-[go.uint64] "$r0");;;
    let: "ci" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (let: "$a0" := (![go.SliceType raftpb.Entry] (StructFieldRef logSlice "entries"%go "a")) in
    (MethodResolve (go.PointerType raftLog) "findConflict"%go (![go.PointerType raftLog] "l")) "$a0") in
    do:  ("ci" <-[go.uint64] "$r0");;;
    let: "$sw" := #true in
    (if: "$sw" =⟨go.bool⟩ ((![go.uint64] "ci") =⟨go.uint64⟩ #(W64 0))
    then do:  #()
    else
      (if: "$sw" =⟨go.bool⟩ ((![go.uint64] "ci") ≤⟨go.uint64⟩ (![go.uint64] (StructFieldRef raftLog "committed"%go (![go.PointerType raftLog] "l"))))
      then
        do:  (let: "$a0" := #"entry %d conflict with committed entry [committed(%d)]"%go in
        let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] "ci")) in
        let: "$sl1" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raftLog "committed"%go (![go.PointerType raftLog] "l")))) in
        CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1")]))) in
        (MethodResolve Logger "Panicf"%go (![Logger] (StructFieldRef raftLog "logger"%go (![go.PointerType raftLog] "l")))) "$a0" "$a1")
      else
        let: "offset" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
        let: "$r0" := ((![go.uint64] (StructFieldRef entryID "index"%go (StructFieldRef logSlice "prev"%go "a"))) +⟨go.uint64⟩ #(W64 1)) in
        do:  ("offset" <-[go.uint64] "$r0");;;
        (if: Convert go.untyped_bool go.bool (((![go.uint64] "ci") -⟨go.uint64⟩ (![go.uint64] "offset")) >⟨go.uint64⟩ (Convert go.int go.uint64 (let: "$a0" := (![go.SliceType raftpb.Entry] (StructFieldRef logSlice "entries"%go "a")) in
        (FuncResolve go.len [go.SliceType raftpb.Entry] #()) "$a0")))
        then
          do:  (let: "$a0" := #"index, %d, is out of range [%d]"%go in
          let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) ((![go.uint64] "ci") -⟨go.uint64⟩ (![go.uint64] "offset"))) in
          let: "$sl1" := (Convert go.int (go.InterfaceType []) (let: "$a0" := (![go.SliceType raftpb.Entry] (StructFieldRef logSlice "entries"%go "a")) in
          (FuncResolve go.len [go.SliceType raftpb.Entry] #()) "$a0")) in
          CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1")]))) in
          (MethodResolve Logger "Panicf"%go (![Logger] (StructFieldRef raftLog "logger"%go (![go.PointerType raftLog] "l")))) "$a0" "$a1")
        else do:  #());;;
        do:  (let: "$a0" := (let: "$s" := (![go.SliceType raftpb.Entry] (StructFieldRef logSlice "entries"%go "a")) in
        Slice (go.SliceType raftpb.Entry) ("$s", (![go.uint64] "ci") -⟨go.uint64⟩ (![go.uint64] "offset"), FuncResolve go.len [go.SliceType raftpb.Entry] #() (![go.SliceType raftpb.Entry] (StructFieldRef logSlice "entries"%go "a")))) in
        (MethodResolve (go.PointerType raftLog) "append"%go (![go.PointerType raftLog] "l")) "$a0")));;;
    do:  (let: "$a0" := (let: "$a0" := (![go.uint64] "committed") in
    let: "$a1" := (![go.uint64] "lastnewi") in
    (FuncResolve go.min [go.uint64; go.uint64] #()) "$a0" "$a1") in
    (MethodResolve (go.PointerType raftLog) "commitTo"%go (![go.PointerType raftLog] "l")) "$a0");;;
    return: (![go.uint64] "lastnewi", #true)).

(* go: log.go:131:19 *)
Definition raftLog__appendⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" "ents",
    exception_do (let: "l" := (GoAlloc (go.PointerType raftLog) "l") in
    let: "ents" := (GoAlloc (go.SliceType raftpb.Entry) "ents") in
    (if: Convert go.untyped_bool go.bool ((let: "$a0" := (![go.SliceType raftpb.Entry] "ents") in
    (FuncResolve go.len [go.SliceType raftpb.Entry] #()) "$a0") =⟨go.int⟩ #(W64 0))
    then return: ((MethodResolve (go.PointerType raftLog) "lastIndex"%go (![go.PointerType raftLog] "l")) #())
    else do:  #());;;
    (let: "after" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := ((![go.uint64] (StructFieldRef raftpb.Entry "Index"%go (IndexRef (go.SliceType raftpb.Entry) (![go.SliceType raftpb.Entry] "ents", #(W64 0))))) -⟨go.uint64⟩ #(W64 1)) in
    do:  ("after" <-[go.uint64] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "after") <⟨go.uint64⟩ (![go.uint64] (StructFieldRef raftLog "committed"%go (![go.PointerType raftLog] "l"))))
    then
      do:  (let: "$a0" := #"after(%d) is out of range [committed(%d)]"%go in
      let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] "after")) in
      let: "$sl1" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raftLog "committed"%go (![go.PointerType raftLog] "l")))) in
      CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1")]))) in
      (MethodResolve Logger "Panicf"%go (![Logger] (StructFieldRef raftLog "logger"%go (![go.PointerType raftLog] "l")))) "$a0" "$a1")
    else do:  #()));;;
    do:  (let: "$a0" := (![go.SliceType raftpb.Entry] "ents") in
    (MethodResolve (go.PointerType unstable) "truncateAndAppend"%go (StructFieldRef raftLog "unstable"%go (![go.PointerType raftLog] "l"))) "$a0");;;
    return: ((MethodResolve (go.PointerType raftLog) "lastIndex"%go (![go.PointerType raftLog] "l")) #())).

(* findConflict finds the index of the conflict.
   It returns the first pair of conflicting entries between the existing
   entries and the given entries, if there are any.
   If there is no conflicting entries, and the existing entries contains
   all the given entries, zero will be returned.
   If there is no conflicting entries, but the given entries contains new
   entries, the index of the first new entry will be returned.
   An entry is considered to be conflicting if it has the same index but
   a different term.
   The index of the given entries MUST be continuously increasing.

   go: log.go:152:19 *)
Definition raftLog__findConflictⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" "ents",
    exception_do (let: "l" := (GoAlloc (go.PointerType raftLog) "l") in
    let: "ents" := (GoAlloc (go.SliceType raftpb.Entry) "ents") in
    let: "$range" := (![go.SliceType raftpb.Entry] "ents") in
    (let: "i" := (GoAlloc go.int (GoZeroVal go.int #())) in
    slice.for_range raftpb.Entry "$range" (λ: "$key" "$value",
      do:  ("i" <-[go.int] "$key");;;
      (let: "id" := (GoAlloc entryID (GoZeroVal entryID #())) in
      let: "$r0" := (let: "$a0" := (IndexRef raftpb.Entry (![go.SliceType raftpb.Entry] "ents", ![go.int] "i")) in
      (FuncResolve pbEntryID [] #()) "$a0") in
      do:  ("id" <-[entryID] "$r0");;;
      (if: (~ (let: "$a0" := (![entryID] "id") in
      (MethodResolve (go.PointerType raftLog) "matchTerm"%go (![go.PointerType raftLog] "l")) "$a0"))
      then
        (if: Convert go.untyped_bool go.bool ((![go.uint64] (StructFieldRef entryID "index"%go "id")) ≤⟨go.uint64⟩ ((MethodResolve (go.PointerType raftLog) "lastIndex"%go (![go.PointerType raftLog] "l")) #()))
        then
          do:  (let: "$a0" := #"found conflict at index %d [existing term: %d, conflicting term: %d]"%go in
          let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef entryID "index"%go "id"))) in
          let: "$sl1" := (Convert go.uint64 (go.InterfaceType []) (let: ("$ret0", "$ret1") := ((let: "$a0" := (![go.uint64] (StructFieldRef entryID "index"%go "id")) in
          (MethodResolve (go.PointerType raftLog) "term"%go (![go.PointerType raftLog] "l")) "$a0")) in
          let: "$a0" := "$ret0" in
          let: "$a1" := "$ret1" in
          (MethodResolve (go.PointerType raftLog) "zeroTermOnOutOfBounds"%go (![go.PointerType raftLog] "l")) "$a0" "$a1")) in
          let: "$sl2" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef entryID "term"%go "id"))) in
          CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl2")]))) in
          (MethodResolve Logger "Infof"%go (![Logger] (StructFieldRef raftLog "logger"%go (![go.PointerType raftLog] "l")))) "$a0" "$a1")
        else do:  #());;;
        return: (![go.uint64] (StructFieldRef entryID "index"%go "id"))
      else do:  #()))));;;
    return: (#(W64 0))).

(* findConflictByTerm returns a best guess on where this log ends matching
   another log, given that the only information known about the other log is the
   (index, term) of its single entry.

   Specifically, the first returned value is the max guessIndex <= index, such
   that term(guessIndex) <= term or term(guessIndex) is not known (because this
   index is compacted or not yet stored).

   The second returned value is the term(guessIndex), or 0 if it is unknown.

   This function is used by a follower and leader to resolve log conflicts after
   an unsuccessful append to a follower, and ultimately restore the steady flow
   of appends.

   go: log.go:180:19 *)
Definition raftLog__findConflictByTermⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" "index" "term",
    exception_do (let: "l" := (GoAlloc (go.PointerType raftLog) "l") in
    let: "term" := (GoAlloc go.uint64 "term") in
    let: "index" := (GoAlloc go.uint64 "index") in
    (for: (λ: <>, (![go.uint64] "index") >⟨go.uint64⟩ #(W64 0)); (λ: <>, do:  ("index" <-[go.uint64] ((![go.uint64] "index") -⟨go.uint64⟩ #(W64 1)))) := λ: <>,
      (let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
      let: "ourTerm" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![go.uint64] "index") in
      (MethodResolve (go.PointerType raftLog) "term"%go (![go.PointerType raftLog] "l")) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("ourTerm" <-[go.uint64] "$r0");;;
      do:  ("err" <-[go.error] "$r1");;;
      (if: Convert go.untyped_bool go.bool ((![go.error] "err") ≠⟨go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]⟩ (Convert go.untyped_nil (go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]) UntypedNil))
      then return: (![go.uint64] "index", #(W64 0))
      else
        (if: Convert go.untyped_bool go.bool ((![go.uint64] "ourTerm") ≤⟨go.uint64⟩ (![go.uint64] "term"))
        then return: (![go.uint64] "index", ![go.uint64] "ourTerm")
        else do:  #()))));;;
    return: (#(W64 0), #(W64 0))).

(* nextUnstableEnts returns all entries that are available to be written to the
   local stable log and are not already in-progress.

   go: log.go:196:19 *)
Definition raftLog__nextUnstableEntsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" <>,
    exception_do (let: "l" := (GoAlloc (go.PointerType raftLog) "l") in
    return: ((MethodResolve (go.PointerType unstable) "nextEntries"%go (StructFieldRef raftLog "unstable"%go (![go.PointerType raftLog] "l"))) #())).

(* hasNextUnstableEnts returns if there are any entries that are available to be
   written to the local stable log and are not already in-progress.

   go: log.go:202:19 *)
Definition raftLog__hasNextUnstableEntsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" <>,
    exception_do (let: "l" := (GoAlloc (go.PointerType raftLog) "l") in
    return: ((let: "$a0" := ((MethodResolve (go.PointerType raftLog) "nextUnstableEnts"%go (![go.PointerType raftLog] "l")) #()) in
     (FuncResolve go.len [go.SliceType raftpb.Entry] #()) "$a0") >⟨go.int⟩ #(W64 0))).

(* hasNextOrInProgressUnstableEnts returns if there are any entries that are
   available to be written to the local stable log or in the process of being
   written to the local stable log.

   go: log.go:209:19 *)
Definition raftLog__hasNextOrInProgressUnstableEntsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" <>,
    exception_do (let: "l" := (GoAlloc (go.PointerType raftLog) "l") in
    return: ((let: "$a0" := (![go.SliceType raftpb.Entry] (StructFieldRef unstable "entries"%go (StructFieldRef raftLog "unstable"%go (![go.PointerType raftLog] "l")))) in
     (FuncResolve go.len [go.SliceType raftpb.Entry] #()) "$a0") >⟨go.int⟩ #(W64 0))).

(* nextCommittedEnts returns all the available entries for execution.
   Entries can be committed even when the local raft instance has not durably
   appended them to the local raft log yet. If allowUnstable is true, committed
   entries from the unstable log may be returned; otherwise, only entries known
   to reside locally on stable storage will be returned.

   go: log.go:218:19 *)
Definition raftLog__nextCommittedEntsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" "allowUnstable",
    exception_do (let: "ents" := (GoAlloc (go.SliceType raftpb.Entry) (GoZeroVal (go.SliceType raftpb.Entry) #())) in
    let: "l" := (GoAlloc (go.PointerType raftLog) "l") in
    let: "allowUnstable" := (GoAlloc go.bool "allowUnstable") in
    (if: ![go.bool] (StructFieldRef raftLog "applyingEntsPaused"%go (![go.PointerType raftLog] "l"))
    then return: (Convert go.untyped_nil (go.SliceType raftpb.Entry) UntypedNil)
    else do:  #());;;
    (if: (MethodResolve (go.PointerType raftLog) "hasNextOrInProgressSnapshot"%go (![go.PointerType raftLog] "l")) #()
    then return: (Convert go.untyped_nil (go.SliceType raftpb.Entry) UntypedNil)
    else do:  #());;;
    let: "hi" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "lo" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := ((![go.uint64] (StructFieldRef raftLog "applying"%go (![go.PointerType raftLog] "l"))) +⟨go.uint64⟩ #(W64 1)) in
    let: "$r1" := ((let: "$a0" := (![go.bool] "allowUnstable") in
    (MethodResolve (go.PointerType raftLog) "maxAppliableIndex"%go (![go.PointerType raftLog] "l")) "$a0") +⟨go.uint64⟩ #(W64 1)) in
    do:  ("lo" <-[go.uint64] "$r0");;;
    do:  ("hi" <-[go.uint64] "$r1");;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "lo") ≥⟨go.uint64⟩ (![go.uint64] "hi"))
    then return: (Convert go.untyped_nil (go.SliceType raftpb.Entry) UntypedNil)
    else do:  #());;;
    let: "maxSize" := (GoAlloc entryEncodingSize (GoZeroVal entryEncodingSize #())) in
    let: "$r0" := ((![entryEncodingSize] (StructFieldRef raftLog "maxApplyingEntsSize"%go (![go.PointerType raftLog] "l"))) -⟨go.uint64⟩ (![entryEncodingSize] (StructFieldRef raftLog "applyingEntsSize"%go (![go.PointerType raftLog] "l")))) in
    do:  ("maxSize" <-[entryEncodingSize] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![entryEncodingSize] "maxSize") ≤⟨go.uint64⟩ #(W64 0))
    then
      do:  (let: "$a0" := #"applying entry size (%d-%d)=%d not positive"%go in
      let: "$a1" := ((let: "$sl0" := (Convert entryEncodingSize (go.InterfaceType []) (![entryEncodingSize] (StructFieldRef raftLog "maxApplyingEntsSize"%go (![go.PointerType raftLog] "l")))) in
      let: "$sl1" := (Convert entryEncodingSize (go.InterfaceType []) (![entryEncodingSize] (StructFieldRef raftLog "applyingEntsSize"%go (![go.PointerType raftLog] "l")))) in
      let: "$sl2" := (Convert entryEncodingSize (go.InterfaceType []) (![entryEncodingSize] "maxSize")) in
      CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl2")]))) in
      (MethodResolve Logger "Panicf"%go (![Logger] (StructFieldRef raftLog "logger"%go (![go.PointerType raftLog] "l")))) "$a0" "$a1")
    else do:  #());;;
    let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.uint64] "lo") in
    let: "$a1" := (![go.uint64] "hi") in
    let: "$a2" := (![entryEncodingSize] "maxSize") in
    (MethodResolve (go.PointerType raftLog) "slice"%go (![go.PointerType raftLog] "l")) "$a0" "$a1" "$a2") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("ents" <-[go.SliceType raftpb.Entry] "$r0");;;
    do:  ("err" <-[go.error] "$r1");;;
    (if: Convert go.untyped_bool go.bool ((![go.error] "err") ≠⟨go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]⟩ (Convert go.untyped_nil (go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]) UntypedNil))
    then
      do:  (let: "$a0" := #"unexpected error when getting unapplied entries (%v)"%go in
      let: "$a1" := ((let: "$sl0" := (Convert go.error (go.InterfaceType []) (![go.error] "err")) in
      CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0")]))) in
      (MethodResolve Logger "Panicf"%go (![Logger] (StructFieldRef raftLog "logger"%go (![go.PointerType raftLog] "l")))) "$a0" "$a1")
    else do:  #());;;
    return: (![go.SliceType raftpb.Entry] "ents")).

(* hasNextCommittedEnts returns if there is any available entries for execution.
   This is a fast check without heavy raftLog.slice() in nextCommittedEnts().

   go: log.go:246:19 *)
Definition raftLog__hasNextCommittedEntsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" "allowUnstable",
    exception_do (let: "l" := (GoAlloc (go.PointerType raftLog) "l") in
    let: "allowUnstable" := (GoAlloc go.bool "allowUnstable") in
    (if: ![go.bool] (StructFieldRef raftLog "applyingEntsPaused"%go (![go.PointerType raftLog] "l"))
    then return: (#false)
    else do:  #());;;
    (if: (MethodResolve (go.PointerType raftLog) "hasNextOrInProgressSnapshot"%go (![go.PointerType raftLog] "l")) #()
    then return: (#false)
    else do:  #());;;
    let: "hi" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "lo" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := ((![go.uint64] (StructFieldRef raftLog "applying"%go (![go.PointerType raftLog] "l"))) +⟨go.uint64⟩ #(W64 1)) in
    let: "$r1" := ((let: "$a0" := (![go.bool] "allowUnstable") in
    (MethodResolve (go.PointerType raftLog) "maxAppliableIndex"%go (![go.PointerType raftLog] "l")) "$a0") +⟨go.uint64⟩ #(W64 1)) in
    do:  ("lo" <-[go.uint64] "$r0");;;
    do:  ("hi" <-[go.uint64] "$r1");;;
    return: ((![go.uint64] "lo") <⟨go.uint64⟩ (![go.uint64] "hi"))).

(* maxAppliableIndex returns the maximum committed index that can be applied.
   If allowUnstable is true, committed entries from the unstable log can be
   applied; otherwise, only entries known to reside locally on stable storage
   can be applied.

   go: log.go:265:19 *)
Definition raftLog__maxAppliableIndexⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" "allowUnstable",
    exception_do (let: "l" := (GoAlloc (go.PointerType raftLog) "l") in
    let: "allowUnstable" := (GoAlloc go.bool "allowUnstable") in
    let: "hi" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (![go.uint64] (StructFieldRef raftLog "committed"%go (![go.PointerType raftLog] "l"))) in
    do:  ("hi" <-[go.uint64] "$r0");;;
    (if: (~ (![go.bool] "allowUnstable"))
    then
      let: "$r0" := (let: "$a0" := (![go.uint64] "hi") in
      let: "$a1" := ((![go.uint64] (StructFieldRef unstable "offset"%go (StructFieldRef raftLog "unstable"%go (![go.PointerType raftLog] "l")))) -⟨go.uint64⟩ #(W64 1)) in
      (FuncResolve go.min [go.uint64; go.uint64] #()) "$a0" "$a1") in
      do:  ("hi" <-[go.uint64] "$r0")
    else do:  #());;;
    return: (![go.uint64] "hi")).

(* nextUnstableSnapshot returns the snapshot, if present, that is available to
   be applied to the local storage and is not already in-progress.

   go: log.go:275:19 *)
Definition raftLog__nextUnstableSnapshotⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" <>,
    exception_do (let: "l" := (GoAlloc (go.PointerType raftLog) "l") in
    return: ((MethodResolve (go.PointerType unstable) "nextSnapshot"%go (StructFieldRef raftLog "unstable"%go (![go.PointerType raftLog] "l"))) #())).

(* hasNextUnstableSnapshot returns if there is a snapshot that is available to
   be applied to the local storage and is not already in-progress.

   go: log.go:281:19 *)
Definition raftLog__hasNextUnstableSnapshotⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" <>,
    exception_do (let: "l" := (GoAlloc (go.PointerType raftLog) "l") in
    return: (((MethodResolve (go.PointerType unstable) "nextSnapshot"%go (StructFieldRef raftLog "unstable"%go (![go.PointerType raftLog] "l"))) #()) ≠⟨go.PointerType raftpb.Snapshot⟩ (Convert go.untyped_nil (go.PointerType raftpb.Snapshot) UntypedNil))).

(* hasNextOrInProgressSnapshot returns if there is pending snapshot waiting for
   applying or in the process of being applied.

   go: log.go:287:19 *)
Definition raftLog__hasNextOrInProgressSnapshotⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" <>,
    exception_do (let: "l" := (GoAlloc (go.PointerType raftLog) "l") in
    return: ((![go.PointerType raftpb.Snapshot] (StructFieldRef unstable "snapshot"%go (StructFieldRef raftLog "unstable"%go (![go.PointerType raftLog] "l")))) ≠⟨go.PointerType raftpb.Snapshot⟩ (Convert go.untyped_nil (go.PointerType raftpb.Snapshot) UntypedNil))).

(* go: log.go:291:19 *)
Definition raftLog__snapshotⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" <>,
    exception_do (let: "l" := (GoAlloc (go.PointerType raftLog) "l") in
    (if: Convert go.untyped_bool go.bool ((![go.PointerType raftpb.Snapshot] (StructFieldRef unstable "snapshot"%go (StructFieldRef raftLog "unstable"%go (![go.PointerType raftLog] "l")))) ≠⟨go.PointerType raftpb.Snapshot⟩ (Convert go.untyped_nil (go.PointerType raftpb.Snapshot) UntypedNil))
    then return: (![raftpb.Snapshot] (![go.PointerType raftpb.Snapshot] (StructFieldRef unstable "snapshot"%go (StructFieldRef raftLog "unstable"%go (![go.PointerType raftLog] "l")))), Convert go.untyped_nil go.error UntypedNil)
    else do:  #());;;
    let: ("$ret0", "$ret1") := (((MethodResolve Storage "Snapshot"%go (![Storage] (StructFieldRef raftLog "storage"%go (![go.PointerType raftLog] "l")))) #())) in
    return: ("$ret0", "$ret1")).

(* go: log.go:298:19 *)
Definition raftLog__firstIndexⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" <>,
    exception_do (let: "l" := (GoAlloc (go.PointerType raftLog) "l") in
    (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: ("$ret0", "$ret1") := ((MethodResolve (go.PointerType unstable) "maybeFirstIndex"%go (StructFieldRef raftLog "unstable"%go (![go.PointerType raftLog] "l"))) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("i" <-[go.uint64] "$r0");;;
    do:  ("ok" <-[go.bool] "$r1");;;
    (if: ![go.bool] "ok"
    then return: (![go.uint64] "i")
    else do:  #()));;;
    let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
    let: "index" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: ("$ret0", "$ret1") := ((MethodResolve Storage "FirstIndex"%go (![Storage] (StructFieldRef raftLog "storage"%go (![go.PointerType raftLog] "l")))) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("index" <-[go.uint64] "$r0");;;
    do:  ("err" <-[go.error] "$r1");;;
    (if: Convert go.untyped_bool go.bool ((![go.error] "err") ≠⟨go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]⟩ (Convert go.untyped_nil (go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]) UntypedNil))
    then
      do:  (let: "$a0" := (Convert go.error (go.InterfaceType []) (![go.error] "err")) in
      (FuncResolve go.panic [] #()) "$a0")
    else do:  #());;;
    return: (![go.uint64] "index")).

(* go: log.go:309:19 *)
Definition raftLog__lastIndexⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" <>,
    exception_do (let: "l" := (GoAlloc (go.PointerType raftLog) "l") in
    (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: ("$ret0", "$ret1") := ((MethodResolve (go.PointerType unstable) "maybeLastIndex"%go (StructFieldRef raftLog "unstable"%go (![go.PointerType raftLog] "l"))) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("i" <-[go.uint64] "$r0");;;
    do:  ("ok" <-[go.bool] "$r1");;;
    (if: ![go.bool] "ok"
    then return: (![go.uint64] "i")
    else do:  #()));;;
    let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
    let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: ("$ret0", "$ret1") := ((MethodResolve Storage "LastIndex"%go (![Storage] (StructFieldRef raftLog "storage"%go (![go.PointerType raftLog] "l")))) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("i" <-[go.uint64] "$r0");;;
    do:  ("err" <-[go.error] "$r1");;;
    (if: Convert go.untyped_bool go.bool ((![go.error] "err") ≠⟨go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]⟩ (Convert go.untyped_nil (go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]) UntypedNil))
    then
      do:  (let: "$a0" := (Convert go.error (go.InterfaceType []) (![go.error] "err")) in
      (FuncResolve go.panic [] #()) "$a0")
    else do:  #());;;
    return: (![go.uint64] "i")).

(* go: log.go:320:19 *)
Definition raftLog__commitToⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" "tocommit",
    exception_do (let: "l" := (GoAlloc (go.PointerType raftLog) "l") in
    let: "tocommit" := (GoAlloc go.uint64 "tocommit") in
    (if: Convert go.untyped_bool go.bool ((![go.uint64] (StructFieldRef raftLog "committed"%go (![go.PointerType raftLog] "l"))) <⟨go.uint64⟩ (![go.uint64] "tocommit"))
    then
      (if: Convert go.untyped_bool go.bool (((MethodResolve (go.PointerType raftLog) "lastIndex"%go (![go.PointerType raftLog] "l")) #()) <⟨go.uint64⟩ (![go.uint64] "tocommit"))
      then
        do:  (let: "$a0" := #"tocommit(%d) is out of range [lastIndex(%d)]. Was the raft log corrupted, truncated, or lost?"%go in
        let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] "tocommit")) in
        let: "$sl1" := (Convert go.uint64 (go.InterfaceType []) ((MethodResolve (go.PointerType raftLog) "lastIndex"%go (![go.PointerType raftLog] "l")) #())) in
        CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1")]))) in
        (MethodResolve Logger "Panicf"%go (![Logger] (StructFieldRef raftLog "logger"%go (![go.PointerType raftLog] "l")))) "$a0" "$a1")
      else do:  #());;;
      let: "$r0" := (![go.uint64] "tocommit") in
      do:  ((StructFieldRef raftLog "committed"%go (![go.PointerType raftLog] "l")) <-[go.uint64] "$r0")
    else do:  #());;;
    return: #()).

(* go: log.go:330:19 *)
Definition raftLog__appliedToⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" "i" "size",
    exception_do (let: "l" := (GoAlloc (go.PointerType raftLog) "l") in
    let: "size" := (GoAlloc entryEncodingSize "size") in
    let: "i" := (GoAlloc go.uint64 "i") in
    (if: Convert go.untyped_bool go.bool (((![go.uint64] (StructFieldRef raftLog "committed"%go (![go.PointerType raftLog] "l"))) <⟨go.uint64⟩ (![go.uint64] "i")) || ((![go.uint64] "i") <⟨go.uint64⟩ (![go.uint64] (StructFieldRef raftLog "applied"%go (![go.PointerType raftLog] "l")))))
    then
      do:  (let: "$a0" := #"applied(%d) is out of range [prevApplied(%d), committed(%d)]"%go in
      let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] "i")) in
      let: "$sl1" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raftLog "applied"%go (![go.PointerType raftLog] "l")))) in
      let: "$sl2" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raftLog "committed"%go (![go.PointerType raftLog] "l")))) in
      CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl2")]))) in
      (MethodResolve Logger "Panicf"%go (![Logger] (StructFieldRef raftLog "logger"%go (![go.PointerType raftLog] "l")))) "$a0" "$a1")
    else do:  #());;;
    let: "$r0" := (![go.uint64] "i") in
    do:  ((StructFieldRef raftLog "applied"%go (![go.PointerType raftLog] "l")) <-[go.uint64] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.uint64] (StructFieldRef raftLog "applying"%go (![go.PointerType raftLog] "l"))) in
    let: "$a1" := (![go.uint64] "i") in
    (FuncResolve go.max [go.uint64; go.uint64] #()) "$a0" "$a1") in
    do:  ((StructFieldRef raftLog "applying"%go (![go.PointerType raftLog] "l")) <-[go.uint64] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![entryEncodingSize] (StructFieldRef raftLog "applyingEntsSize"%go (![go.PointerType raftLog] "l"))) >⟨go.uint64⟩ (![entryEncodingSize] "size"))
    then do:  ((StructFieldRef raftLog "applyingEntsSize"%go (![go.PointerType raftLog] "l")) <-[entryEncodingSize] ((![entryEncodingSize] (StructFieldRef raftLog "applyingEntsSize"%go (![go.PointerType raftLog] "l"))) -⟨go.uint64⟩ (![entryEncodingSize] "size")))
    else
      let: "$r0" := #(W64 0) in
      do:  ((StructFieldRef raftLog "applyingEntsSize"%go (![go.PointerType raftLog] "l")) <-[entryEncodingSize] "$r0"));;;
    let: "$r0" := ((![entryEncodingSize] (StructFieldRef raftLog "applyingEntsSize"%go (![go.PointerType raftLog] "l"))) ≥⟨go.uint64⟩ (![entryEncodingSize] (StructFieldRef raftLog "maxApplyingEntsSize"%go (![go.PointerType raftLog] "l")))) in
    do:  ((StructFieldRef raftLog "applyingEntsPaused"%go (![go.PointerType raftLog] "l")) <-[go.bool] "$r0");;;
    return: #()).

(* go: log.go:345:19 *)
Definition raftLog__acceptApplyingⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" "i" "size" "allowUnstable",
    exception_do (let: "l" := (GoAlloc (go.PointerType raftLog) "l") in
    let: "allowUnstable" := (GoAlloc go.bool "allowUnstable") in
    let: "size" := (GoAlloc entryEncodingSize "size") in
    let: "i" := (GoAlloc go.uint64 "i") in
    (if: Convert go.untyped_bool go.bool ((![go.uint64] (StructFieldRef raftLog "committed"%go (![go.PointerType raftLog] "l"))) <⟨go.uint64⟩ (![go.uint64] "i"))
    then
      do:  (let: "$a0" := #"applying(%d) is out of range [prevApplying(%d), committed(%d)]"%go in
      let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] "i")) in
      let: "$sl1" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raftLog "applying"%go (![go.PointerType raftLog] "l")))) in
      let: "$sl2" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raftLog "committed"%go (![go.PointerType raftLog] "l")))) in
      CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl2")]))) in
      (MethodResolve Logger "Panicf"%go (![Logger] (StructFieldRef raftLog "logger"%go (![go.PointerType raftLog] "l")))) "$a0" "$a1")
    else do:  #());;;
    let: "$r0" := (![go.uint64] "i") in
    do:  ((StructFieldRef raftLog "applying"%go (![go.PointerType raftLog] "l")) <-[go.uint64] "$r0");;;
    do:  ((StructFieldRef raftLog "applyingEntsSize"%go (![go.PointerType raftLog] "l")) <-[entryEncodingSize] ((![entryEncodingSize] (StructFieldRef raftLog "applyingEntsSize"%go (![go.PointerType raftLog] "l"))) +⟨go.uint64⟩ (![entryEncodingSize] "size")));;;
    let: "$r0" := (((![entryEncodingSize] (StructFieldRef raftLog "applyingEntsSize"%go (![go.PointerType raftLog] "l"))) ≥⟨go.uint64⟩ (![entryEncodingSize] (StructFieldRef raftLog "maxApplyingEntsSize"%go (![go.PointerType raftLog] "l")))) || ((![go.uint64] "i") <⟨go.uint64⟩ (let: "$a0" := (![go.bool] "allowUnstable") in
    (MethodResolve (go.PointerType raftLog) "maxAppliableIndex"%go (![go.PointerType raftLog] "l")) "$a0"))) in
    do:  ((StructFieldRef raftLog "applyingEntsPaused"%go (![go.PointerType raftLog] "l")) <-[go.bool] "$r0");;;
    return: #()).

(* go: log.go:365:19 *)
Definition raftLog__stableToⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" "id",
    exception_do (let: "l" := (GoAlloc (go.PointerType raftLog) "l") in
    let: "id" := (GoAlloc entryID "id") in
    do:  (let: "$a0" := (![entryID] "id") in
    (MethodResolve (go.PointerType unstable) "stableTo"%go (StructFieldRef raftLog "unstable"%go (![go.PointerType raftLog] "l"))) "$a0");;;
    return: #()).

(* go: log.go:367:19 *)
Definition raftLog__stableSnapToⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" "i",
    exception_do (let: "l" := (GoAlloc (go.PointerType raftLog) "l") in
    let: "i" := (GoAlloc go.uint64 "i") in
    do:  (let: "$a0" := (![go.uint64] "i") in
    (MethodResolve (go.PointerType unstable) "stableSnapTo"%go (StructFieldRef raftLog "unstable"%go (![go.PointerType raftLog] "l"))) "$a0");;;
    return: #()).

(* acceptUnstable indicates that the application has started persisting the
   unstable entries in storage, and that the current unstable entries are thus
   to be marked as being in-progress, to avoid returning them with future calls
   to Ready().

   go: log.go:373:19 *)
Definition raftLog__acceptUnstableⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" <>,
    exception_do (let: "l" := (GoAlloc (go.PointerType raftLog) "l") in
    do:  ((MethodResolve (go.PointerType unstable) "acceptInProgress"%go (StructFieldRef raftLog "unstable"%go (![go.PointerType raftLog] "l"))) #());;;
    return: #()).

(* lastEntryID returns the ID of the last entry in the log.

   go: log.go:376:19 *)
Definition raftLog__lastEntryIDⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" <>,
    exception_do (let: "l" := (GoAlloc (go.PointerType raftLog) "l") in
    let: "index" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := ((MethodResolve (go.PointerType raftLog) "lastIndex"%go (![go.PointerType raftLog] "l")) #()) in
    do:  ("index" <-[go.uint64] "$r0");;;
    let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
    let: "t" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.uint64] "index") in
    (MethodResolve (go.PointerType raftLog) "term"%go (![go.PointerType raftLog] "l")) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("t" <-[go.uint64] "$r0");;;
    do:  ("err" <-[go.error] "$r1");;;
    (if: Convert go.untyped_bool go.bool ((![go.error] "err") ≠⟨go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]⟩ (Convert go.untyped_nil (go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]) UntypedNil))
    then
      do:  (let: "$a0" := #"unexpected error when getting the last term at %d: %v"%go in
      let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] "index")) in
      let: "$sl1" := (Convert go.error (go.InterfaceType []) (![go.error] "err")) in
      CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1")]))) in
      (MethodResolve Logger "Panicf"%go (![Logger] (StructFieldRef raftLog "logger"%go (![go.PointerType raftLog] "l")))) "$a0" "$a1")
    else do:  #());;;
    return: (CompositeLiteral entryID (LiteralValue [KeyedElement (Some (KeyField "term"%go)) (ElementExpression go.uint64 (![go.uint64] "t")); KeyedElement (Some (KeyField "index"%go)) (ElementExpression go.uint64 (![go.uint64] "index"))]))).

(* go: log.go:385:19 *)
Definition raftLog__termⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" "i",
    exception_do (let: "l" := (GoAlloc (go.PointerType raftLog) "l") in
    let: "i" := (GoAlloc go.uint64 "i") in
    (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "t" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.uint64] "i") in
    (MethodResolve (go.PointerType unstable) "maybeTerm"%go (StructFieldRef raftLog "unstable"%go (![go.PointerType raftLog] "l"))) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("t" <-[go.uint64] "$r0");;;
    do:  ("ok" <-[go.bool] "$r1");;;
    (if: ![go.bool] "ok"
    then return: (![go.uint64] "t", Convert go.untyped_nil go.error UntypedNil)
    else do:  #()));;;
    (if: Convert go.untyped_bool go.bool (((![go.uint64] "i") +⟨go.uint64⟩ #(W64 1)) <⟨go.uint64⟩ ((MethodResolve (go.PointerType raftLog) "firstIndex"%go (![go.PointerType raftLog] "l")) #()))
    then return: (#(W64 0), ![go.error] (GlobalVarAddr ErrCompacted #()))
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "i") >⟨go.uint64⟩ ((MethodResolve (go.PointerType raftLog) "lastIndex"%go (![go.PointerType raftLog] "l")) #()))
    then return: (#(W64 0), ![go.error] (GlobalVarAddr ErrUnavailable #()))
    else do:  #());;;
    let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
    let: "t" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.uint64] "i") in
    (MethodResolve Storage "Term"%go (![Storage] (StructFieldRef raftLog "storage"%go (![go.PointerType raftLog] "l")))) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("t" <-[go.uint64] "$r0");;;
    do:  ("err" <-[go.error] "$r1");;;
    (if: Convert go.untyped_bool go.bool ((![go.error] "err") =⟨go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]⟩ (Convert go.untyped_nil (go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]) UntypedNil))
    then return: (![go.uint64] "t", Convert go.untyped_nil go.error UntypedNil)
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool (((![go.error] "err") =⟨go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]⟩ (![go.error] (GlobalVarAddr ErrCompacted #()))) || ((![go.error] "err") =⟨go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]⟩ (![go.error] (GlobalVarAddr ErrUnavailable #()))))
    then return: (#(W64 0), ![go.error] "err")
    else do:  #());;;
    do:  (let: "$a0" := (Convert go.error (go.InterfaceType []) (![go.error] "err")) in
    (FuncResolve go.panic [] #()) "$a0")).

(* go: log.go:413:19 *)
Definition raftLog__entriesⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" "i" "maxSize",
    exception_do (let: "l" := (GoAlloc (go.PointerType raftLog) "l") in
    let: "maxSize" := (GoAlloc entryEncodingSize "maxSize") in
    let: "i" := (GoAlloc go.uint64 "i") in
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "i") >⟨go.uint64⟩ ((MethodResolve (go.PointerType raftLog) "lastIndex"%go (![go.PointerType raftLog] "l")) #()))
    then return: (Convert go.untyped_nil (go.SliceType raftpb.Entry) UntypedNil, Convert go.untyped_nil go.error UntypedNil)
    else do:  #());;;
    let: ("$ret0", "$ret1") := ((let: "$a0" := (![go.uint64] "i") in
    let: "$a1" := (((MethodResolve (go.PointerType raftLog) "lastIndex"%go (![go.PointerType raftLog] "l")) #()) +⟨go.uint64⟩ #(W64 1)) in
    let: "$a2" := (![entryEncodingSize] "maxSize") in
    (MethodResolve (go.PointerType raftLog) "slice"%go (![go.PointerType raftLog] "l")) "$a0" "$a1" "$a2")) in
    return: ("$ret0", "$ret1")).

(* allEntries returns all entries in the log.

   go: log.go:421:19 *)
Definition raftLog__allEntriesⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" <>,
    exception_do (let: "l" := (GoAlloc (go.PointerType raftLog) "l") in
    let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
    let: "ents" := (GoAlloc (go.SliceType raftpb.Entry) (GoZeroVal (go.SliceType raftpb.Entry) #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := ((MethodResolve (go.PointerType raftLog) "firstIndex"%go (![go.PointerType raftLog] "l")) #()) in
    let: "$a1" := (Convert go.untyped_int entryEncodingSize noLimit) in
    (MethodResolve (go.PointerType raftLog) "entries"%go (![go.PointerType raftLog] "l")) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("ents" <-[go.SliceType raftpb.Entry] "$r0");;;
    do:  ("err" <-[go.error] "$r1");;;
    (if: Convert go.untyped_bool go.bool ((![go.error] "err") =⟨go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]⟩ (Convert go.untyped_nil (go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]) UntypedNil))
    then return: (![go.SliceType raftpb.Entry] "ents")
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool ((![go.error] "err") =⟨go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]⟩ (![go.error] (GlobalVarAddr ErrCompacted #())))
    then return: ((MethodResolve (go.PointerType raftLog) "allEntries"%go (![go.PointerType raftLog] "l")) #())
    else do:  #());;;
    do:  (let: "$a0" := (Convert go.error (go.InterfaceType []) (![go.error] "err")) in
    (FuncResolve go.panic [] #()) "$a0")).

(* isUpToDate determines if a log with the given last entry is more up-to-date
   by comparing the index and term of the last entries in the existing logs.

   If the logs have last entries with different terms, then the log with the
   later term is more up-to-date. If the logs end with the same term, then
   whichever log has the larger lastIndex is more up-to-date. If the logs are
   the same, the given log is up-to-date.

   go: log.go:440:19 *)
Definition raftLog__isUpToDateⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" "their",
    exception_do (let: "l" := (GoAlloc (go.PointerType raftLog) "l") in
    let: "their" := (GoAlloc entryID "their") in
    let: "our" := (GoAlloc entryID (GoZeroVal entryID #())) in
    let: "$r0" := ((MethodResolve (go.PointerType raftLog) "lastEntryID"%go (![go.PointerType raftLog] "l")) #()) in
    do:  ("our" <-[entryID] "$r0");;;
    return: (((![go.uint64] (StructFieldRef entryID "term"%go "their")) >⟨go.uint64⟩ (![go.uint64] (StructFieldRef entryID "term"%go "our"))) || (((![go.uint64] (StructFieldRef entryID "term"%go "their")) =⟨go.uint64⟩ (![go.uint64] (StructFieldRef entryID "term"%go "our"))) && ((![go.uint64] (StructFieldRef entryID "index"%go "their")) ≥⟨go.uint64⟩ (![go.uint64] (StructFieldRef entryID "index"%go "our")))))).

(* go: log.go:445:19 *)
Definition raftLog__matchTermⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" "id",
    exception_do (let: "l" := (GoAlloc (go.PointerType raftLog) "l") in
    let: "id" := (GoAlloc entryID "id") in
    let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
    let: "t" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.uint64] (StructFieldRef entryID "index"%go "id")) in
    (MethodResolve (go.PointerType raftLog) "term"%go (![go.PointerType raftLog] "l")) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("t" <-[go.uint64] "$r0");;;
    do:  ("err" <-[go.error] "$r1");;;
    (if: Convert go.untyped_bool go.bool ((![go.error] "err") ≠⟨go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]⟩ (Convert go.untyped_nil (go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]) UntypedNil))
    then return: (#false)
    else do:  #());;;
    return: ((![go.uint64] "t") =⟨go.uint64⟩ (![go.uint64] (StructFieldRef entryID "term"%go "id")))).

(* go: log.go:453:19 *)
Definition raftLog__maybeCommitⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" "at",
    exception_do (let: "l" := (GoAlloc (go.PointerType raftLog) "l") in
    let: "at" := (GoAlloc entryID "at") in
    (if: (((![go.uint64] (StructFieldRef entryID "term"%go "at")) ≠⟨go.uint64⟩ #(W64 0)) && ((![go.uint64] (StructFieldRef entryID "index"%go "at")) >⟨go.uint64⟩ (![go.uint64] (StructFieldRef raftLog "committed"%go (![go.PointerType raftLog] "l"))))) && (let: "$a0" := (![entryID] "at") in
    (MethodResolve (go.PointerType raftLog) "matchTerm"%go (![go.PointerType raftLog] "l")) "$a0")
    then
      do:  (let: "$a0" := (![go.uint64] (StructFieldRef entryID "index"%go "at")) in
      (MethodResolve (go.PointerType raftLog) "commitTo"%go (![go.PointerType raftLog] "l")) "$a0");;;
      return: (#true)
    else do:  #());;;
    return: (#false)).

(* go: log.go:464:19 *)
Definition raftLog__restoreⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" "s",
    exception_do (let: "l" := (GoAlloc (go.PointerType raftLog) "l") in
    let: "s" := (GoAlloc raftpb.Snapshot "s") in
    do:  (let: "$a0" := #"log [%s] starts to restore snapshot [index: %d, term: %d]"%go in
    let: "$a1" := ((let: "$sl0" := (Convert (go.PointerType raftLog) (go.InterfaceType []) (![go.PointerType raftLog] "l")) in
    let: "$sl1" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raftpb.SnapshotMetadata "Index"%go (StructFieldRef raftpb.Snapshot "Metadata"%go "s")))) in
    let: "$sl2" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raftpb.SnapshotMetadata "Term"%go (StructFieldRef raftpb.Snapshot "Metadata"%go "s")))) in
    CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl2")]))) in
    (MethodResolve Logger "Infof"%go (![Logger] (StructFieldRef raftLog "logger"%go (![go.PointerType raftLog] "l")))) "$a0" "$a1");;;
    let: "$r0" := (![go.uint64] (StructFieldRef raftpb.SnapshotMetadata "Index"%go (StructFieldRef raftpb.Snapshot "Metadata"%go "s"))) in
    do:  ((StructFieldRef raftLog "committed"%go (![go.PointerType raftLog] "l")) <-[go.uint64] "$r0");;;
    do:  (let: "$a0" := (![raftpb.Snapshot] "s") in
    (MethodResolve (go.PointerType unstable) "restore"%go (StructFieldRef raftLog "unstable"%go (![go.PointerType raftLog] "l"))) "$a0");;;
    return: #()).

(* scan visits all log entries in the [lo, hi) range, returning them via the
   given callback. The callback can be invoked multiple times, with consecutive
   sub-ranges of the requested range. Returns up to pageSize bytes worth of
   entries at a time. May return more if a single entry size exceeds the limit.

   The entries in [lo, hi) must exist, otherwise scan() eventually returns an
   error (possibly after passing some entries through the callback).

   If the callback returns an error, scan terminates and returns this error
   immediately. This can be used to stop the scan early ("break" the loop).

   go: log.go:480:19 *)
Definition raftLog__scanⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" "lo" "hi" "pageSize" "v",
    exception_do (let: "l" := (GoAlloc (go.PointerType raftLog) "l") in
    let: "v" := (GoAlloc (go.FunctionType (go.Signature [go.SliceType raftpb.Entry] false [go.error])) "v") in
    let: "pageSize" := (GoAlloc entryEncodingSize "pageSize") in
    let: "hi" := (GoAlloc go.uint64 "hi") in
    let: "lo" := (GoAlloc go.uint64 "lo") in
    (for: (λ: <>, (![go.uint64] "lo") <⟨go.uint64⟩ (![go.uint64] "hi")); (λ: <>, #()) := λ: <>,
      let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
      let: "ents" := (GoAlloc (go.SliceType raftpb.Entry) (GoZeroVal (go.SliceType raftpb.Entry) #())) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![go.uint64] "lo") in
      let: "$a1" := (![go.uint64] "hi") in
      let: "$a2" := (![entryEncodingSize] "pageSize") in
      (MethodResolve (go.PointerType raftLog) "slice"%go (![go.PointerType raftLog] "l")) "$a0" "$a1" "$a2") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("ents" <-[go.SliceType raftpb.Entry] "$r0");;;
      do:  ("err" <-[go.error] "$r1");;;
      (if: Convert go.untyped_bool go.bool ((![go.error] "err") ≠⟨go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]⟩ (Convert go.untyped_nil (go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]) UntypedNil))
      then return: (![go.error] "err")
      else
        (if: Convert go.untyped_bool go.bool ((let: "$a0" := (![go.SliceType raftpb.Entry] "ents") in
        (FuncResolve go.len [go.SliceType raftpb.Entry] #()) "$a0") =⟨go.int⟩ #(W64 0))
        then
          return: (let: "$a0" := #"got 0 entries in [%d, %d)"%go in
           let: "$a1" := ((let: "$sl0" := (Convert go.uint64 go.any (![go.uint64] "lo")) in
           let: "$sl1" := (Convert go.uint64 go.any (![go.uint64] "hi")) in
           CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0"); KeyedElement None (ElementExpression go.any "$sl1")]))) in
           (FuncResolve fmt.Errorf [] #()) "$a0" "$a1")
        else do:  #()));;;
      (let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
      let: "$r0" := (let: "$a0" := (![go.SliceType raftpb.Entry] "ents") in
      (![go.FunctionType (go.Signature [go.SliceType raftpb.Entry] false [go.error])] "v") "$a0") in
      do:  ("err" <-[go.error] "$r0");;;
      (if: Convert go.untyped_bool go.bool ((![go.error] "err") ≠⟨go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]⟩ (Convert go.untyped_nil (go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]) UntypedNil))
      then return: (![go.error] "err")
      else do:  #()));;;
      do:  ("lo" <-[go.uint64] ((![go.uint64] "lo") +⟨go.uint64⟩ (Convert go.int go.uint64 (let: "$a0" := (![go.SliceType raftpb.Entry] "ents") in
      (FuncResolve go.len [go.SliceType raftpb.Entry] #()) "$a0")))));;;
    return: (Convert go.untyped_nil go.error UntypedNil)).

(* slice returns a slice of log entries from lo through hi-1, inclusive.

   go: log.go:497:19 *)
Definition raftLog__sliceⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" "lo" "hi" "maxSize",
    exception_do (let: "l" := (GoAlloc (go.PointerType raftLog) "l") in
    let: "maxSize" := (GoAlloc entryEncodingSize "maxSize") in
    let: "hi" := (GoAlloc go.uint64 "hi") in
    let: "lo" := (GoAlloc go.uint64 "lo") in
    (let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
    let: "$r0" := (let: "$a0" := (![go.uint64] "lo") in
    let: "$a1" := (![go.uint64] "hi") in
    (MethodResolve (go.PointerType raftLog) "mustCheckOutOfBounds"%go (![go.PointerType raftLog] "l")) "$a0" "$a1") in
    do:  ("err" <-[go.error] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.error] "err") ≠⟨go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]⟩ (Convert go.untyped_nil (go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]) UntypedNil))
    then return: (Convert go.untyped_nil (go.SliceType raftpb.Entry) UntypedNil, ![go.error] "err")
    else do:  #()));;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "lo") =⟨go.uint64⟩ (![go.uint64] "hi"))
    then return: (Convert go.untyped_nil (go.SliceType raftpb.Entry) UntypedNil, Convert go.untyped_nil go.error UntypedNil)
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "lo") ≥⟨go.uint64⟩ (![go.uint64] (StructFieldRef unstable "offset"%go (StructFieldRef raftLog "unstable"%go (![go.PointerType raftLog] "l")))))
    then
      let: "ents" := (GoAlloc (go.SliceType raftpb.Entry) (GoZeroVal (go.SliceType raftpb.Entry) #())) in
      let: "$r0" := (let: "$a0" := (let: "$a0" := (![go.uint64] "lo") in
      let: "$a1" := (![go.uint64] "hi") in
      (MethodResolve (go.PointerType unstable) "slice"%go (StructFieldRef raftLog "unstable"%go (![go.PointerType raftLog] "l"))) "$a0" "$a1") in
      let: "$a1" := (![entryEncodingSize] "maxSize") in
      (FuncResolve limitSize [] #()) "$a0" "$a1") in
      do:  ("ents" <-[go.SliceType raftpb.Entry] "$r0");;;
      return: (let: "$s" := (![go.SliceType raftpb.Entry] "ents") in
       FullSlice (go.SliceType raftpb.Entry) ("$s", #(W64 0), let: "$a0" := (![go.SliceType raftpb.Entry] "ents") in
        (FuncResolve go.len [go.SliceType raftpb.Entry] #()) "$a0", let: "$a0" := (![go.SliceType raftpb.Entry] "ents") in
        (FuncResolve go.len [go.SliceType raftpb.Entry] #()) "$a0"), Convert go.untyped_nil go.error UntypedNil)
    else do:  #());;;
    let: "cut" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (let: "$a0" := (![go.uint64] "hi") in
    let: "$a1" := (![go.uint64] (StructFieldRef unstable "offset"%go (StructFieldRef raftLog "unstable"%go (![go.PointerType raftLog] "l")))) in
    (FuncResolve go.min [go.uint64; go.uint64] #()) "$a0" "$a1") in
    do:  ("cut" <-[go.uint64] "$r0");;;
    let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
    let: "ents" := (GoAlloc (go.SliceType raftpb.Entry) (GoZeroVal (go.SliceType raftpb.Entry) #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.uint64] "lo") in
    let: "$a1" := (![go.uint64] "cut") in
    let: "$a2" := (![entryEncodingSize] "maxSize") in
    (MethodResolve Storage "Entries"%go (![Storage] (StructFieldRef raftLog "storage"%go (![go.PointerType raftLog] "l")))) "$a0" "$a1" "$a2") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("ents" <-[go.SliceType raftpb.Entry] "$r0");;;
    do:  ("err" <-[go.error] "$r1");;;
    (if: Convert go.untyped_bool go.bool ((![go.error] "err") =⟨go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]⟩ (![go.error] (GlobalVarAddr ErrCompacted #())))
    then return: (Convert go.untyped_nil (go.SliceType raftpb.Entry) UntypedNil, ![go.error] "err")
    else
      (if: Convert go.untyped_bool go.bool ((![go.error] "err") =⟨go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]⟩ (![go.error] (GlobalVarAddr ErrUnavailable #())))
      then
        do:  (let: "$a0" := #"entries[%d:%d) is unavailable from storage"%go in
        let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] "lo")) in
        let: "$sl1" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] "cut")) in
        CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1")]))) in
        (MethodResolve Logger "Panicf"%go (![Logger] (StructFieldRef raftLog "logger"%go (![go.PointerType raftLog] "l")))) "$a0" "$a1")
      else
        (if: Convert go.untyped_bool go.bool ((![go.error] "err") ≠⟨go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]⟩ (Convert go.untyped_nil (go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]) UntypedNil))
        then
          do:  (let: "$a0" := (Convert go.error (go.InterfaceType []) (![go.error] "err")) in
          (FuncResolve go.panic [] #()) "$a0")
        else do:  #())));;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "hi") ≤⟨go.uint64⟩ (![go.uint64] (StructFieldRef unstable "offset"%go (StructFieldRef raftLog "unstable"%go (![go.PointerType raftLog] "l")))))
    then return: (![go.SliceType raftpb.Entry] "ents", Convert go.untyped_nil go.error UntypedNil)
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool ((Convert go.int go.uint64 (let: "$a0" := (![go.SliceType raftpb.Entry] "ents") in
    (FuncResolve go.len [go.SliceType raftpb.Entry] #()) "$a0")) <⟨go.uint64⟩ ((![go.uint64] "cut") -⟨go.uint64⟩ (![go.uint64] "lo")))
    then return: (![go.SliceType raftpb.Entry] "ents", Convert go.untyped_nil go.error UntypedNil)
    else do:  #());;;
    let: "size" := (GoAlloc entryEncodingSize (GoZeroVal entryEncodingSize #())) in
    let: "$r0" := (let: "$a0" := (![go.SliceType raftpb.Entry] "ents") in
    (FuncResolve entsSize [] #()) "$a0") in
    do:  ("size" <-[entryEncodingSize] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![entryEncodingSize] "size") ≥⟨go.uint64⟩ (![entryEncodingSize] "maxSize"))
    then return: (![go.SliceType raftpb.Entry] "ents", Convert go.untyped_nil go.error UntypedNil)
    else do:  #());;;
    let: "unstable" := (GoAlloc (go.SliceType raftpb.Entry) (GoZeroVal (go.SliceType raftpb.Entry) #())) in
    let: "$r0" := (let: "$a0" := (let: "$a0" := (![go.uint64] (StructFieldRef unstable "offset"%go (StructFieldRef raftLog "unstable"%go (![go.PointerType raftLog] "l")))) in
    let: "$a1" := (![go.uint64] "hi") in
    (MethodResolve (go.PointerType unstable) "slice"%go (StructFieldRef raftLog "unstable"%go (![go.PointerType raftLog] "l"))) "$a0" "$a1") in
    let: "$a1" := ((![entryEncodingSize] "maxSize") -⟨go.uint64⟩ (![entryEncodingSize] "size")) in
    (FuncResolve limitSize [] #()) "$a0" "$a1") in
    do:  ("unstable" <-[go.SliceType raftpb.Entry] "$r0");;;
    (if: Convert go.untyped_bool go.bool (((let: "$a0" := (![go.SliceType raftpb.Entry] "unstable") in
    (FuncResolve go.len [go.SliceType raftpb.Entry] #()) "$a0") =⟨go.int⟩ #(W64 1)) && (((![entryEncodingSize] "size") +⟨go.uint64⟩ (let: "$a0" := (![go.SliceType raftpb.Entry] "unstable") in
    (FuncResolve entsSize [] #()) "$a0")) >⟨go.uint64⟩ (![entryEncodingSize] "maxSize")))
    then return: (![go.SliceType raftpb.Entry] "ents", Convert go.untyped_nil go.error UntypedNil)
    else do:  #());;;
    return: (let: "$a0" := (![go.SliceType raftpb.Entry] "ents") in
     let: "$a1" := (![go.SliceType raftpb.Entry] "unstable") in
     (FuncResolve extend [] #()) "$a0" "$a1", Convert go.untyped_nil go.error UntypedNil)).

(* l.firstIndex <= lo <= hi <= l.firstIndex + len(l.entries)

   go: log.go:549:19 *)
Definition raftLog__mustCheckOutOfBoundsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" "lo" "hi",
    exception_do (let: "l" := (GoAlloc (go.PointerType raftLog) "l") in
    let: "hi" := (GoAlloc go.uint64 "hi") in
    let: "lo" := (GoAlloc go.uint64 "lo") in
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "lo") >⟨go.uint64⟩ (![go.uint64] "hi"))
    then
      do:  (let: "$a0" := #"invalid slice %d > %d"%go in
      let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] "lo")) in
      let: "$sl1" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] "hi")) in
      CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1")]))) in
      (MethodResolve Logger "Panicf"%go (![Logger] (StructFieldRef raftLog "logger"%go (![go.PointerType raftLog] "l")))) "$a0" "$a1")
    else do:  #());;;
    let: "fi" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := ((MethodResolve (go.PointerType raftLog) "firstIndex"%go (![go.PointerType raftLog] "l")) #()) in
    do:  ("fi" <-[go.uint64] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "lo") <⟨go.uint64⟩ (![go.uint64] "fi"))
    then return: (![go.error] (GlobalVarAddr ErrCompacted #()))
    else do:  #());;;
    let: "length" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := ((((MethodResolve (go.PointerType raftLog) "lastIndex"%go (![go.PointerType raftLog] "l")) #()) +⟨go.uint64⟩ #(W64 1)) -⟨go.uint64⟩ (![go.uint64] "fi")) in
    do:  ("length" <-[go.uint64] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "hi") >⟨go.uint64⟩ ((![go.uint64] "fi") +⟨go.uint64⟩ (![go.uint64] "length")))
    then
      do:  (let: "$a0" := #"slice[%d,%d) out of bound [%d,%d]"%go in
      let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] "lo")) in
      let: "$sl1" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] "hi")) in
      let: "$sl2" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] "fi")) in
      let: "$sl3" := (Convert go.uint64 (go.InterfaceType []) ((MethodResolve (go.PointerType raftLog) "lastIndex"%go (![go.PointerType raftLog] "l")) #())) in
      CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl2"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl3")]))) in
      (MethodResolve Logger "Panicf"%go (![Logger] (StructFieldRef raftLog "logger"%go (![go.PointerType raftLog] "l")))) "$a0" "$a1")
    else do:  #());;;
    return: (Convert go.untyped_nil go.error UntypedNil)).

(* go: log.go:565:19 *)
Definition raftLog__zeroTermOnOutOfBoundsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" "t" "err",
    exception_do (let: "l" := (GoAlloc (go.PointerType raftLog) "l") in
    let: "err" := (GoAlloc go.error "err") in
    let: "t" := (GoAlloc go.uint64 "t") in
    (if: Convert go.untyped_bool go.bool ((![go.error] "err") =⟨go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]⟩ (Convert go.untyped_nil (go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]) UntypedNil))
    then return: (![go.uint64] "t")
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool (((![go.error] "err") =⟨go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]⟩ (![go.error] (GlobalVarAddr ErrCompacted #()))) || ((![go.error] "err") =⟨go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]⟩ (![go.error] (GlobalVarAddr ErrUnavailable #()))))
    then return: (#(W64 0))
    else do:  #());;;
    do:  (let: "$a0" := #"unexpected error (%v)"%go in
    let: "$a1" := ((let: "$sl0" := (Convert go.error (go.InterfaceType []) (![go.error] "err")) in
    CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0")]))) in
    (MethodResolve Logger "Panicf"%go (![Logger] (StructFieldRef raftLog "logger"%go (![go.PointerType raftLog] "l")))) "$a0" "$a1");;;
    return: (#(W64 0))).

(* maybeFirstIndex returns the index of the first possible entry in entries
   if it has a snapshot.

   go: log_unstable.go:54:20 *)
Definition unstable__maybeFirstIndexⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "u" <>,
    exception_do (let: "u" := (GoAlloc (go.PointerType unstable) "u") in
    (if: Convert go.untyped_bool go.bool ((![go.PointerType raftpb.Snapshot] (StructFieldRef unstable "snapshot"%go (![go.PointerType unstable] "u"))) ≠⟨go.PointerType raftpb.Snapshot⟩ (Convert go.untyped_nil (go.PointerType raftpb.Snapshot) UntypedNil))
    then return: ((![go.uint64] (StructFieldRef raftpb.SnapshotMetadata "Index"%go (StructFieldRef raftpb.Snapshot "Metadata"%go (![go.PointerType raftpb.Snapshot] (StructFieldRef unstable "snapshot"%go (![go.PointerType unstable] "u")))))) +⟨go.uint64⟩ #(W64 1), #true)
    else do:  #());;;
    return: (#(W64 0), #false)).

(* maybeLastIndex returns the last index if it has at least one
   unstable entry or snapshot.

   go: log_unstable.go:63:20 *)
Definition unstable__maybeLastIndexⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "u" <>,
    exception_do (let: "u" := (GoAlloc (go.PointerType unstable) "u") in
    (let: "l" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := (let: "$a0" := (![go.SliceType raftpb.Entry] (StructFieldRef unstable "entries"%go (![go.PointerType unstable] "u"))) in
    (FuncResolve go.len [go.SliceType raftpb.Entry] #()) "$a0") in
    do:  ("l" <-[go.int] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.int] "l") ≠⟨go.int⟩ #(W64 0))
    then return: (((![go.uint64] (StructFieldRef unstable "offset"%go (![go.PointerType unstable] "u"))) +⟨go.uint64⟩ (Convert go.int go.uint64 (![go.int] "l"))) -⟨go.uint64⟩ #(W64 1), #true)
    else do:  #()));;;
    (if: Convert go.untyped_bool go.bool ((![go.PointerType raftpb.Snapshot] (StructFieldRef unstable "snapshot"%go (![go.PointerType unstable] "u"))) ≠⟨go.PointerType raftpb.Snapshot⟩ (Convert go.untyped_nil (go.PointerType raftpb.Snapshot) UntypedNil))
    then return: (![go.uint64] (StructFieldRef raftpb.SnapshotMetadata "Index"%go (StructFieldRef raftpb.Snapshot "Metadata"%go (![go.PointerType raftpb.Snapshot] (StructFieldRef unstable "snapshot"%go (![go.PointerType unstable] "u"))))), #true)
    else do:  #());;;
    return: (#(W64 0), #false)).

(* maybeTerm returns the term of the entry at index i, if there
   is any.

   go: log_unstable.go:75:20 *)
Definition unstable__maybeTermⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "u" "i",
    exception_do (let: "u" := (GoAlloc (go.PointerType unstable) "u") in
    let: "i" := (GoAlloc go.uint64 "i") in
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "i") <⟨go.uint64⟩ (![go.uint64] (StructFieldRef unstable "offset"%go (![go.PointerType unstable] "u"))))
    then
      (if: Convert go.untyped_bool go.bool (((![go.PointerType raftpb.Snapshot] (StructFieldRef unstable "snapshot"%go (![go.PointerType unstable] "u"))) ≠⟨go.PointerType raftpb.Snapshot⟩ (Convert go.untyped_nil (go.PointerType raftpb.Snapshot) UntypedNil)) && ((![go.uint64] (StructFieldRef raftpb.SnapshotMetadata "Index"%go (StructFieldRef raftpb.Snapshot "Metadata"%go (![go.PointerType raftpb.Snapshot] (StructFieldRef unstable "snapshot"%go (![go.PointerType unstable] "u")))))) =⟨go.uint64⟩ (![go.uint64] "i")))
      then return: (![go.uint64] (StructFieldRef raftpb.SnapshotMetadata "Term"%go (StructFieldRef raftpb.Snapshot "Metadata"%go (![go.PointerType raftpb.Snapshot] (StructFieldRef unstable "snapshot"%go (![go.PointerType unstable] "u"))))), #true)
      else do:  #());;;
      return: (#(W64 0), #false)
    else do:  #());;;
    let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "last" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: ("$ret0", "$ret1") := ((MethodResolve (go.PointerType unstable) "maybeLastIndex"%go (![go.PointerType unstable] "u")) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("last" <-[go.uint64] "$r0");;;
    do:  ("ok" <-[go.bool] "$r1");;;
    (if: (~ (![go.bool] "ok"))
    then return: (#(W64 0), #false)
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "i") >⟨go.uint64⟩ (![go.uint64] "last"))
    then return: (#(W64 0), #false)
    else do:  #());;;
    return: (![go.uint64] (StructFieldRef raftpb.Entry "Term"%go (IndexRef (go.SliceType raftpb.Entry) (![go.SliceType raftpb.Entry] (StructFieldRef unstable "entries"%go (![go.PointerType unstable] "u")), Convert go.uint64 go.int ((![go.uint64] "i") -⟨go.uint64⟩ (![go.uint64] (StructFieldRef unstable "offset"%go (![go.PointerType unstable] "u"))))))), #true)).

(* nextEntries returns the unstable entries that are not already in the process
   of being written to storage.

   go: log_unstable.go:96:20 *)
Definition unstable__nextEntriesⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "u" <>,
    exception_do (let: "u" := (GoAlloc (go.PointerType unstable) "u") in
    let: "inProgress" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := (Convert go.uint64 go.int ((![go.uint64] (StructFieldRef unstable "offsetInProgress"%go (![go.PointerType unstable] "u"))) -⟨go.uint64⟩ (![go.uint64] (StructFieldRef unstable "offset"%go (![go.PointerType unstable] "u"))))) in
    do:  ("inProgress" <-[go.int] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((let: "$a0" := (![go.SliceType raftpb.Entry] (StructFieldRef unstable "entries"%go (![go.PointerType unstable] "u"))) in
    (FuncResolve go.len [go.SliceType raftpb.Entry] #()) "$a0") =⟨go.int⟩ (![go.int] "inProgress"))
    then return: (Convert go.untyped_nil (go.SliceType raftpb.Entry) UntypedNil)
    else do:  #());;;
    return: (let: "$s" := (![go.SliceType raftpb.Entry] (StructFieldRef unstable "entries"%go (![go.PointerType unstable] "u"))) in
     Slice (go.SliceType raftpb.Entry) ("$s", ![go.int] "inProgress", FuncResolve go.len [go.SliceType raftpb.Entry] #() (![go.SliceType raftpb.Entry] (StructFieldRef unstable "entries"%go (![go.PointerType unstable] "u")))))).

(* nextSnapshot returns the unstable snapshot, if one exists that is not already
   in the process of being written to storage.

   go: log_unstable.go:106:20 *)
Definition unstable__nextSnapshotⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "u" <>,
    exception_do (let: "u" := (GoAlloc (go.PointerType unstable) "u") in
    (if: ((![go.PointerType raftpb.Snapshot] (StructFieldRef unstable "snapshot"%go (![go.PointerType unstable] "u"))) =⟨go.PointerType raftpb.Snapshot⟩ (Convert go.untyped_nil (go.PointerType raftpb.Snapshot) UntypedNil)) || (![go.bool] (StructFieldRef unstable "snapshotInProgress"%go (![go.PointerType unstable] "u")))
    then return: (Convert go.untyped_nil (go.PointerType raftpb.Snapshot) UntypedNil)
    else do:  #());;;
    return: (![go.PointerType raftpb.Snapshot] (StructFieldRef unstable "snapshot"%go (![go.PointerType unstable] "u")))).

(* acceptInProgress marks all entries and the snapshot, if any, in the unstable
   as having begun the process of being written to storage. The entries/snapshot
   will no longer be returned from nextEntries/nextSnapshot. However, new
   entries/snapshots added after a call to acceptInProgress will be returned
   from those methods, until the next call to acceptInProgress.

   go: log_unstable.go:118:20 *)
Definition unstable__acceptInProgressⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "u" <>,
    exception_do (let: "u" := (GoAlloc (go.PointerType unstable) "u") in
    (if: Convert go.untyped_bool go.bool ((let: "$a0" := (![go.SliceType raftpb.Entry] (StructFieldRef unstable "entries"%go (![go.PointerType unstable] "u"))) in
    (FuncResolve go.len [go.SliceType raftpb.Entry] #()) "$a0") >⟨go.int⟩ #(W64 0))
    then
      let: "$r0" := ((![go.uint64] (StructFieldRef raftpb.Entry "Index"%go (IndexRef (go.SliceType raftpb.Entry) (![go.SliceType raftpb.Entry] (StructFieldRef unstable "entries"%go (![go.PointerType unstable] "u")), (let: "$a0" := (![go.SliceType raftpb.Entry] (StructFieldRef unstable "entries"%go (![go.PointerType unstable] "u"))) in
       (FuncResolve go.len [go.SliceType raftpb.Entry] #()) "$a0") -⟨go.int⟩ #(W64 1))))) +⟨go.uint64⟩ #(W64 1)) in
      do:  ((StructFieldRef unstable "offsetInProgress"%go (![go.PointerType unstable] "u")) <-[go.uint64] "$r0")
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool ((![go.PointerType raftpb.Snapshot] (StructFieldRef unstable "snapshot"%go (![go.PointerType unstable] "u"))) ≠⟨go.PointerType raftpb.Snapshot⟩ (Convert go.untyped_nil (go.PointerType raftpb.Snapshot) UntypedNil))
    then
      let: "$r0" := #true in
      do:  ((StructFieldRef unstable "snapshotInProgress"%go (![go.PointerType unstable] "u")) <-[go.bool] "$r0")
    else do:  #());;;
    return: #()).

(* stableTo marks entries up to the entry with the specified (index, term) as
   being successfully written to stable storage.

   The method should only be called when the caller can attest that the entries
   can not be overwritten by an in-progress log append. See the related comment
   in newStorageAppendRespMsg.

   go: log_unstable.go:134:20 *)
Definition unstable__stableToⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "u" "id",
    exception_do (let: "u" := (GoAlloc (go.PointerType unstable) "u") in
    let: "id" := (GoAlloc entryID "id") in
    let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "gt" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.uint64] (StructFieldRef entryID "index"%go "id")) in
    (MethodResolve (go.PointerType unstable) "maybeTerm"%go (![go.PointerType unstable] "u")) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("gt" <-[go.uint64] "$r0");;;
    do:  ("ok" <-[go.bool] "$r1");;;
    (if: (~ (![go.bool] "ok"))
    then
      do:  (let: "$a0" := #"entry at index %d missing from unstable log; ignoring"%go in
      let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef entryID "index"%go "id"))) in
      CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0")]))) in
      (MethodResolve Logger "Infof"%go (![Logger] (StructFieldRef unstable "logger"%go (![go.PointerType unstable] "u")))) "$a0" "$a1");;;
      return: (#())
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] (StructFieldRef entryID "index"%go "id")) <⟨go.uint64⟩ (![go.uint64] (StructFieldRef unstable "offset"%go (![go.PointerType unstable] "u"))))
    then
      do:  (let: "$a0" := #"entry at index %d matched unstable snapshot; ignoring"%go in
      let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef entryID "index"%go "id"))) in
      CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0")]))) in
      (MethodResolve Logger "Infof"%go (![Logger] (StructFieldRef unstable "logger"%go (![go.PointerType unstable] "u")))) "$a0" "$a1");;;
      return: (#())
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "gt") ≠⟨go.uint64⟩ (![go.uint64] (StructFieldRef entryID "term"%go "id")))
    then
      do:  (let: "$a0" := #"entry at (index,term)=(%d,%d) mismatched with entry at (%d,%d) in unstable log; ignoring"%go in
      let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef entryID "index"%go "id"))) in
      let: "$sl1" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef entryID "term"%go "id"))) in
      let: "$sl2" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef entryID "index"%go "id"))) in
      let: "$sl3" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] "gt")) in
      CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl2"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl3")]))) in
      (MethodResolve Logger "Infof"%go (![Logger] (StructFieldRef unstable "logger"%go (![go.PointerType unstable] "u")))) "$a0" "$a1");;;
      return: (#())
    else do:  #());;;
    let: "num" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := (Convert go.uint64 go.int (((![go.uint64] (StructFieldRef entryID "index"%go "id")) +⟨go.uint64⟩ #(W64 1)) -⟨go.uint64⟩ (![go.uint64] (StructFieldRef unstable "offset"%go (![go.PointerType unstable] "u"))))) in
    do:  ("num" <-[go.int] "$r0");;;
    let: "$r0" := (let: "$s" := (![go.SliceType raftpb.Entry] (StructFieldRef unstable "entries"%go (![go.PointerType unstable] "u"))) in
    Slice (go.SliceType raftpb.Entry) ("$s", ![go.int] "num", FuncResolve go.len [go.SliceType raftpb.Entry] #() (![go.SliceType raftpb.Entry] (StructFieldRef unstable "entries"%go (![go.PointerType unstable] "u"))))) in
    do:  ((StructFieldRef unstable "entries"%go (![go.PointerType unstable] "u")) <-[go.SliceType raftpb.Entry] "$r0");;;
    let: "$r0" := ((![go.uint64] (StructFieldRef entryID "index"%go "id")) +⟨go.uint64⟩ #(W64 1)) in
    do:  ((StructFieldRef unstable "offset"%go (![go.PointerType unstable] "u")) <-[go.uint64] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.uint64] (StructFieldRef unstable "offsetInProgress"%go (![go.PointerType unstable] "u"))) in
    let: "$a1" := (![go.uint64] (StructFieldRef unstable "offset"%go (![go.PointerType unstable] "u"))) in
    (FuncResolve go.max [go.uint64; go.uint64] #()) "$a0" "$a1") in
    do:  ((StructFieldRef unstable "offsetInProgress"%go (![go.PointerType unstable] "u")) <-[go.uint64] "$r0");;;
    do:  ((MethodResolve (go.PointerType unstable) "shrinkEntriesArray"%go (![go.PointerType unstable] "u")) #());;;
    return: #()).

(* go: log_unstable.go:168:20 *)
Definition unstable__shrinkEntriesArrayⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "u" <>,
    exception_do (let: "u" := (GoAlloc (go.PointerType unstable) "u") in
    (if: Convert go.untyped_bool go.bool ((let: "$a0" := (![go.SliceType raftpb.Entry] (StructFieldRef unstable "entries"%go (![go.PointerType unstable] "u"))) in
    (FuncResolve go.len [go.SliceType raftpb.Entry] #()) "$a0") =⟨go.int⟩ #(W64 0))
    then
      let: "$r0" := (Convert go.untyped_nil (go.SliceType raftpb.Entry) UntypedNil) in
      do:  ((StructFieldRef unstable "entries"%go (![go.PointerType unstable] "u")) <-[go.SliceType raftpb.Entry] "$r0")
    else
      (if: Convert go.untyped_bool go.bool (((let: "$a0" := (![go.SliceType raftpb.Entry] (StructFieldRef unstable "entries"%go (![go.PointerType unstable] "u"))) in
      (FuncResolve go.len [go.SliceType raftpb.Entry] #()) "$a0") *⟨go.int⟩ (Convert go.untyped_int go.int lenMultiple)) <⟨go.int⟩ (let: "$a0" := (![go.SliceType raftpb.Entry] (StructFieldRef unstable "entries"%go (![go.PointerType unstable] "u"))) in
      (FuncResolve go.cap [go.SliceType raftpb.Entry] #()) "$a0"))
      then
        let: "newEntries" := (GoAlloc (go.SliceType raftpb.Entry) (GoZeroVal (go.SliceType raftpb.Entry) #())) in
        let: "$r0" := ((FuncResolve go.make2 [go.SliceType raftpb.Entry] #()) (let: "$a0" := (![go.SliceType raftpb.Entry] (StructFieldRef unstable "entries"%go (![go.PointerType unstable] "u"))) in
        (FuncResolve go.len [go.SliceType raftpb.Entry] #()) "$a0")) in
        do:  ("newEntries" <-[go.SliceType raftpb.Entry] "$r0");;;
        do:  (let: "$a0" := (![go.SliceType raftpb.Entry] "newEntries") in
        let: "$a1" := (![go.SliceType raftpb.Entry] (StructFieldRef unstable "entries"%go (![go.PointerType unstable] "u"))) in
        (FuncResolve go.copy [go.SliceType raftpb.Entry] #()) "$a0" "$a1");;;
        let: "$r0" := (![go.SliceType raftpb.Entry] "newEntries") in
        do:  ((StructFieldRef unstable "entries"%go (![go.PointerType unstable] "u")) <-[go.SliceType raftpb.Entry] "$r0")
      else do:  #()));;;
    return: #()).

(* go: log_unstable.go:182:20 *)
Definition unstable__stableSnapToⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "u" "i",
    exception_do (let: "u" := (GoAlloc (go.PointerType unstable) "u") in
    let: "i" := (GoAlloc go.uint64 "i") in
    (if: Convert go.untyped_bool go.bool (((![go.PointerType raftpb.Snapshot] (StructFieldRef unstable "snapshot"%go (![go.PointerType unstable] "u"))) ≠⟨go.PointerType raftpb.Snapshot⟩ (Convert go.untyped_nil (go.PointerType raftpb.Snapshot) UntypedNil)) && ((![go.uint64] (StructFieldRef raftpb.SnapshotMetadata "Index"%go (StructFieldRef raftpb.Snapshot "Metadata"%go (![go.PointerType raftpb.Snapshot] (StructFieldRef unstable "snapshot"%go (![go.PointerType unstable] "u")))))) =⟨go.uint64⟩ (![go.uint64] "i")))
    then
      let: "$r0" := (Convert go.untyped_nil (go.PointerType raftpb.Snapshot) UntypedNil) in
      do:  ((StructFieldRef unstable "snapshot"%go (![go.PointerType unstable] "u")) <-[go.PointerType raftpb.Snapshot] "$r0");;;
      let: "$r0" := #false in
      do:  ((StructFieldRef unstable "snapshotInProgress"%go (![go.PointerType unstable] "u")) <-[go.bool] "$r0")
    else do:  #());;;
    return: #()).

(* go: log_unstable.go:189:20 *)
Definition unstable__restoreⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "u" "s",
    exception_do (let: "u" := (GoAlloc (go.PointerType unstable) "u") in
    let: "s" := (GoAlloc raftpb.Snapshot "s") in
    let: "$r0" := ((![go.uint64] (StructFieldRef raftpb.SnapshotMetadata "Index"%go (StructFieldRef raftpb.Snapshot "Metadata"%go "s"))) +⟨go.uint64⟩ #(W64 1)) in
    do:  ((StructFieldRef unstable "offset"%go (![go.PointerType unstable] "u")) <-[go.uint64] "$r0");;;
    let: "$r0" := (![go.uint64] (StructFieldRef unstable "offset"%go (![go.PointerType unstable] "u"))) in
    do:  ((StructFieldRef unstable "offsetInProgress"%go (![go.PointerType unstable] "u")) <-[go.uint64] "$r0");;;
    let: "$r0" := (Convert go.untyped_nil (go.SliceType raftpb.Entry) UntypedNil) in
    do:  ((StructFieldRef unstable "entries"%go (![go.PointerType unstable] "u")) <-[go.SliceType raftpb.Entry] "$r0");;;
    let: "$r0" := "s" in
    do:  ((StructFieldRef unstable "snapshot"%go (![go.PointerType unstable] "u")) <-[go.PointerType raftpb.Snapshot] "$r0");;;
    let: "$r0" := #false in
    do:  ((StructFieldRef unstable "snapshotInProgress"%go (![go.PointerType unstable] "u")) <-[go.bool] "$r0");;;
    return: #()).

(* go: log_unstable.go:197:20 *)
Definition unstable__truncateAndAppendⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "u" "ents",
    exception_do (let: "u" := (GoAlloc (go.PointerType unstable) "u") in
    let: "ents" := (GoAlloc (go.SliceType raftpb.Entry) "ents") in
    let: "fromIndex" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (![go.uint64] (StructFieldRef raftpb.Entry "Index"%go (IndexRef (go.SliceType raftpb.Entry) (![go.SliceType raftpb.Entry] "ents", #(W64 0))))) in
    do:  ("fromIndex" <-[go.uint64] "$r0");;;
    let: "$sw" := #true in
    (if: "$sw" =⟨go.bool⟩ ((![go.uint64] "fromIndex") =⟨go.uint64⟩ ((![go.uint64] (StructFieldRef unstable "offset"%go (![go.PointerType unstable] "u"))) +⟨go.uint64⟩ (Convert go.int go.uint64 (let: "$a0" := (![go.SliceType raftpb.Entry] (StructFieldRef unstable "entries"%go (![go.PointerType unstable] "u"))) in
    (FuncResolve go.len [go.SliceType raftpb.Entry] #()) "$a0"))))
    then
      let: "$r0" := (let: "$a0" := (![go.SliceType raftpb.Entry] (StructFieldRef unstable "entries"%go (![go.PointerType unstable] "u"))) in
      let: "$a1" := (![go.SliceType raftpb.Entry] "ents") in
      (FuncResolve go.append [go.SliceType raftpb.Entry] #()) "$a0" "$a1") in
      do:  ((StructFieldRef unstable "entries"%go (![go.PointerType unstable] "u")) <-[go.SliceType raftpb.Entry] "$r0")
    else
      (if: "$sw" =⟨go.bool⟩ ((![go.uint64] "fromIndex") ≤⟨go.uint64⟩ (![go.uint64] (StructFieldRef unstable "offset"%go (![go.PointerType unstable] "u"))))
      then
        do:  (let: "$a0" := #"replace the unstable entries from index %d"%go in
        let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] "fromIndex")) in
        CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0")]))) in
        (MethodResolve Logger "Infof"%go (![Logger] (StructFieldRef unstable "logger"%go (![go.PointerType unstable] "u")))) "$a0" "$a1");;;
        let: "$r0" := (![go.SliceType raftpb.Entry] "ents") in
        do:  ((StructFieldRef unstable "entries"%go (![go.PointerType unstable] "u")) <-[go.SliceType raftpb.Entry] "$r0");;;
        let: "$r0" := (![go.uint64] "fromIndex") in
        do:  ((StructFieldRef unstable "offset"%go (![go.PointerType unstable] "u")) <-[go.uint64] "$r0");;;
        let: "$r0" := (![go.uint64] (StructFieldRef unstable "offset"%go (![go.PointerType unstable] "u"))) in
        do:  ((StructFieldRef unstable "offsetInProgress"%go (![go.PointerType unstable] "u")) <-[go.uint64] "$r0")
      else
        do:  (let: "$a0" := #"truncate the unstable entries before index %d"%go in
        let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] "fromIndex")) in
        CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0")]))) in
        (MethodResolve Logger "Infof"%go (![Logger] (StructFieldRef unstable "logger"%go (![go.PointerType unstable] "u")))) "$a0" "$a1");;;
        let: "keep" := (GoAlloc (go.SliceType raftpb.Entry) (GoZeroVal (go.SliceType raftpb.Entry) #())) in
        let: "$r0" := (let: "$a0" := (![go.uint64] (StructFieldRef unstable "offset"%go (![go.PointerType unstable] "u"))) in
        let: "$a1" := (![go.uint64] "fromIndex") in
        (MethodResolve (go.PointerType unstable) "slice"%go (![go.PointerType unstable] "u")) "$a0" "$a1") in
        do:  ("keep" <-[go.SliceType raftpb.Entry] "$r0");;;
        let: "$r0" := (let: "$a0" := (![go.SliceType raftpb.Entry] "keep") in
        let: "$a1" := (![go.SliceType raftpb.Entry] "ents") in
        (FuncResolve go.append [go.SliceType raftpb.Entry] #()) "$a0" "$a1") in
        do:  ((StructFieldRef unstable "entries"%go (![go.PointerType unstable] "u")) <-[go.SliceType raftpb.Entry] "$r0");;;
        let: "$r0" := (let: "$a0" := (![go.uint64] (StructFieldRef unstable "offsetInProgress"%go (![go.PointerType unstable] "u"))) in
        let: "$a1" := (![go.uint64] "fromIndex") in
        (FuncResolve go.min [go.uint64; go.uint64] #()) "$a0" "$a1") in
        do:  ((StructFieldRef unstable "offsetInProgress"%go (![go.PointerType unstable] "u")) <-[go.uint64] "$r0")));;;
    return: #()).

(* slice returns the entries from the unstable log with indexes in the range
   [lo, hi). The entire range must be stored in the unstable log or the method
   will panic. The returned slice can be appended to, but the entries in it must
   not be changed because they are still shared with unstable.

   TODO(pavelkalinnikov): this, and similar []pb.Entry slices, may bubble up all
   the way to the application code through Ready struct. Protect other slices
   similarly, and document how the client can use them.

   go: log_unstable.go:229:20 *)
Definition unstable__sliceⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "u" "lo" "hi",
    exception_do (let: "u" := (GoAlloc (go.PointerType unstable) "u") in
    let: "hi" := (GoAlloc go.uint64 "hi") in
    let: "lo" := (GoAlloc go.uint64 "lo") in
    do:  (let: "$a0" := (![go.uint64] "lo") in
    let: "$a1" := (![go.uint64] "hi") in
    (MethodResolve (go.PointerType unstable) "mustCheckOutOfBounds"%go (![go.PointerType unstable] "u")) "$a0" "$a1");;;
    return: (let: "$s" := (![go.SliceType raftpb.Entry] (StructFieldRef unstable "entries"%go (![go.PointerType unstable] "u"))) in
     FullSlice (go.SliceType raftpb.Entry) ("$s", (![go.uint64] "lo") -⟨go.uint64⟩ (![go.uint64] (StructFieldRef unstable "offset"%go (![go.PointerType unstable] "u"))), (![go.uint64] "hi") -⟨go.uint64⟩ (![go.uint64] (StructFieldRef unstable "offset"%go (![go.PointerType unstable] "u"))), (![go.uint64] "hi") -⟨go.uint64⟩ (![go.uint64] (StructFieldRef unstable "offset"%go (![go.PointerType unstable] "u")))))).

(* u.offset <= lo <= hi <= u.offset+len(u.entries)

   go: log_unstable.go:238:20 *)
Definition unstable__mustCheckOutOfBoundsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "u" "lo" "hi",
    exception_do (let: "u" := (GoAlloc (go.PointerType unstable) "u") in
    let: "hi" := (GoAlloc go.uint64 "hi") in
    let: "lo" := (GoAlloc go.uint64 "lo") in
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "lo") >⟨go.uint64⟩ (![go.uint64] "hi"))
    then
      do:  (let: "$a0" := #"invalid unstable.slice %d > %d"%go in
      let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] "lo")) in
      let: "$sl1" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] "hi")) in
      CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1")]))) in
      (MethodResolve Logger "Panicf"%go (![Logger] (StructFieldRef unstable "logger"%go (![go.PointerType unstable] "u")))) "$a0" "$a1")
    else do:  #());;;
    let: "upper" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := ((![go.uint64] (StructFieldRef unstable "offset"%go (![go.PointerType unstable] "u"))) +⟨go.uint64⟩ (Convert go.int go.uint64 (let: "$a0" := (![go.SliceType raftpb.Entry] (StructFieldRef unstable "entries"%go (![go.PointerType unstable] "u"))) in
    (FuncResolve go.len [go.SliceType raftpb.Entry] #()) "$a0"))) in
    do:  ("upper" <-[go.uint64] "$r0");;;
    (if: Convert go.untyped_bool go.bool (((![go.uint64] "lo") <⟨go.uint64⟩ (![go.uint64] (StructFieldRef unstable "offset"%go (![go.PointerType unstable] "u")))) || ((![go.uint64] "hi") >⟨go.uint64⟩ (![go.uint64] "upper")))
    then
      do:  (let: "$a0" := #"unstable.slice[%d,%d) out of bound [%d,%d]"%go in
      let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] "lo")) in
      let: "$sl1" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] "hi")) in
      let: "$sl2" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef unstable "offset"%go (![go.PointerType unstable] "u")))) in
      let: "$sl3" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] "upper")) in
      CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl2"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl3")]))) in
      (MethodResolve Logger "Panicf"%go (![Logger] (StructFieldRef unstable "logger"%go (![go.PointerType unstable] "u")))) "$a0" "$a1")
    else do:  #());;;
    return: #()).

(* go: logger.go:45:6 *)
Definition SetLoggerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l",
    exception_do (let: "l" := (GoAlloc Logger "l") in
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (GlobalVarAddr raftLoggerMu #())) #());;;
    let: "$r0" := (![Logger] "l") in
    do:  ((GlobalVarAddr raftLogger #()) <-[Logger] "$r0");;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (GlobalVarAddr raftLoggerMu #())) #());;;
    return: #()).

(* go: logger.go:51:6 *)
Definition ResetDefaultLoggerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (do:  (let: "$a0" := (Convert (go.PointerType DefaultLogger) Logger (![go.PointerType DefaultLogger] (GlobalVarAddr defaultLogger #()))) in
    (FuncResolve SetLogger [] #()) "$a0");;;
    return: #()).

(* go: logger.go:55:6 *)
Definition getLoggerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    with_defer: (do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (GlobalVarAddr raftLoggerMu #())) #());;;
    do:  (let: "$f" := (MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (GlobalVarAddr raftLoggerMu #())) in
    "$defer" <-[deferType] (let: "$oldf" := (![deferType] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    return: (![Logger] (GlobalVarAddr raftLogger #()))).

(* go: logger.go:78:25 *)
Definition DefaultLogger__EnableTimestampsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" <>,
    exception_do (let: "l" := (GoAlloc (go.PointerType DefaultLogger) "l") in
    do:  (let: "$a0" := ((((MethodResolve (go.PointerType DefaultLogger) "Flags"%go (![go.PointerType DefaultLogger] "l")) #()) |⟨go.int⟩ (Convert go.untyped_int go.int log.Ldate)) |⟨go.int⟩ (Convert go.untyped_int go.int log.Ltime)) in
    (MethodResolve (go.PointerType DefaultLogger) "SetFlags"%go (![go.PointerType DefaultLogger] "l")) "$a0");;;
    return: #()).

(* go: logger.go:82:25 *)
Definition DefaultLogger__EnableDebugⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" <>,
    exception_do (let: "l" := (GoAlloc (go.PointerType DefaultLogger) "l") in
    let: "$r0" := #true in
    do:  ((StructFieldRef DefaultLogger "debug"%go (![go.PointerType DefaultLogger] "l")) <-[go.bool] "$r0");;;
    return: #()).

(* go: logger.go:86:25 *)
Definition DefaultLogger__Debugⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" "v",
    exception_do (let: "l" := (GoAlloc (go.PointerType DefaultLogger) "l") in
    let: "v" := (GoAlloc (go.SliceType (go.InterfaceType [])) "v") in
    (if: ![go.bool] (StructFieldRef DefaultLogger "debug"%go (![go.PointerType DefaultLogger] "l"))
    then
      do:  (let: "$a0" := (Convert go.untyped_int go.int calldepth) in
      let: "$a1" := (let: "$a0" := #"DEBUG"%go in
      let: "$a1" := (let: "$a0" := (![go.SliceType (go.InterfaceType [])] "v") in
      (FuncResolve fmt.Sprint [] #()) "$a0") in
      (FuncResolve header [] #()) "$a0" "$a1") in
      (MethodResolve (go.PointerType DefaultLogger) "Output"%go (![go.PointerType DefaultLogger] "l")) "$a0" "$a1")
    else do:  #());;;
    return: #()).

(* go: logger.go:92:25 *)
Definition DefaultLogger__Debugfⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" "format" "v",
    exception_do (let: "l" := (GoAlloc (go.PointerType DefaultLogger) "l") in
    let: "v" := (GoAlloc (go.SliceType (go.InterfaceType [])) "v") in
    let: "format" := (GoAlloc go.string "format") in
    (if: ![go.bool] (StructFieldRef DefaultLogger "debug"%go (![go.PointerType DefaultLogger] "l"))
    then
      do:  (let: "$a0" := (Convert go.untyped_int go.int calldepth) in
      let: "$a1" := (let: "$a0" := #"DEBUG"%go in
      let: "$a1" := (let: "$a0" := (![go.string] "format") in
      let: "$a1" := (![go.SliceType (go.InterfaceType [])] "v") in
      (FuncResolve fmt.Sprintf [] #()) "$a0" "$a1") in
      (FuncResolve header [] #()) "$a0" "$a1") in
      (MethodResolve (go.PointerType DefaultLogger) "Output"%go (![go.PointerType DefaultLogger] "l")) "$a0" "$a1")
    else do:  #());;;
    return: #()).

(* go: logger.go:98:25 *)
Definition DefaultLogger__Infoⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" "v",
    exception_do (let: "l" := (GoAlloc (go.PointerType DefaultLogger) "l") in
    let: "v" := (GoAlloc (go.SliceType (go.InterfaceType [])) "v") in
    do:  (let: "$a0" := (Convert go.untyped_int go.int calldepth) in
    let: "$a1" := (let: "$a0" := #"INFO"%go in
    let: "$a1" := (let: "$a0" := (![go.SliceType (go.InterfaceType [])] "v") in
    (FuncResolve fmt.Sprint [] #()) "$a0") in
    (FuncResolve header [] #()) "$a0" "$a1") in
    (MethodResolve (go.PointerType DefaultLogger) "Output"%go (![go.PointerType DefaultLogger] "l")) "$a0" "$a1");;;
    return: #()).

(* go: logger.go:102:25 *)
Definition DefaultLogger__Infofⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" "format" "v",
    exception_do (let: "l" := (GoAlloc (go.PointerType DefaultLogger) "l") in
    let: "v" := (GoAlloc (go.SliceType (go.InterfaceType [])) "v") in
    let: "format" := (GoAlloc go.string "format") in
    do:  (let: "$a0" := (Convert go.untyped_int go.int calldepth) in
    let: "$a1" := (let: "$a0" := #"INFO"%go in
    let: "$a1" := (let: "$a0" := (![go.string] "format") in
    let: "$a1" := (![go.SliceType (go.InterfaceType [])] "v") in
    (FuncResolve fmt.Sprintf [] #()) "$a0" "$a1") in
    (FuncResolve header [] #()) "$a0" "$a1") in
    (MethodResolve (go.PointerType DefaultLogger) "Output"%go (![go.PointerType DefaultLogger] "l")) "$a0" "$a1");;;
    return: #()).

(* go: logger.go:106:25 *)
Definition DefaultLogger__Errorⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" "v",
    exception_do (let: "l" := (GoAlloc (go.PointerType DefaultLogger) "l") in
    let: "v" := (GoAlloc (go.SliceType (go.InterfaceType [])) "v") in
    do:  (let: "$a0" := (Convert go.untyped_int go.int calldepth) in
    let: "$a1" := (let: "$a0" := #"ERROR"%go in
    let: "$a1" := (let: "$a0" := (![go.SliceType (go.InterfaceType [])] "v") in
    (FuncResolve fmt.Sprint [] #()) "$a0") in
    (FuncResolve header [] #()) "$a0" "$a1") in
    (MethodResolve (go.PointerType DefaultLogger) "Output"%go (![go.PointerType DefaultLogger] "l")) "$a0" "$a1");;;
    return: #()).

(* go: logger.go:110:25 *)
Definition DefaultLogger__Errorfⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" "format" "v",
    exception_do (let: "l" := (GoAlloc (go.PointerType DefaultLogger) "l") in
    let: "v" := (GoAlloc (go.SliceType (go.InterfaceType [])) "v") in
    let: "format" := (GoAlloc go.string "format") in
    do:  (let: "$a0" := (Convert go.untyped_int go.int calldepth) in
    let: "$a1" := (let: "$a0" := #"ERROR"%go in
    let: "$a1" := (let: "$a0" := (![go.string] "format") in
    let: "$a1" := (![go.SliceType (go.InterfaceType [])] "v") in
    (FuncResolve fmt.Sprintf [] #()) "$a0" "$a1") in
    (FuncResolve header [] #()) "$a0" "$a1") in
    (MethodResolve (go.PointerType DefaultLogger) "Output"%go (![go.PointerType DefaultLogger] "l")) "$a0" "$a1");;;
    return: #()).

(* go: logger.go:114:25 *)
Definition DefaultLogger__Warningⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" "v",
    exception_do (let: "l" := (GoAlloc (go.PointerType DefaultLogger) "l") in
    let: "v" := (GoAlloc (go.SliceType (go.InterfaceType [])) "v") in
    do:  (let: "$a0" := (Convert go.untyped_int go.int calldepth) in
    let: "$a1" := (let: "$a0" := #"WARN"%go in
    let: "$a1" := (let: "$a0" := (![go.SliceType (go.InterfaceType [])] "v") in
    (FuncResolve fmt.Sprint [] #()) "$a0") in
    (FuncResolve header [] #()) "$a0" "$a1") in
    (MethodResolve (go.PointerType DefaultLogger) "Output"%go (![go.PointerType DefaultLogger] "l")) "$a0" "$a1");;;
    return: #()).

(* go: logger.go:118:25 *)
Definition DefaultLogger__Warningfⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" "format" "v",
    exception_do (let: "l" := (GoAlloc (go.PointerType DefaultLogger) "l") in
    let: "v" := (GoAlloc (go.SliceType (go.InterfaceType [])) "v") in
    let: "format" := (GoAlloc go.string "format") in
    do:  (let: "$a0" := (Convert go.untyped_int go.int calldepth) in
    let: "$a1" := (let: "$a0" := #"WARN"%go in
    let: "$a1" := (let: "$a0" := (![go.string] "format") in
    let: "$a1" := (![go.SliceType (go.InterfaceType [])] "v") in
    (FuncResolve fmt.Sprintf [] #()) "$a0" "$a1") in
    (FuncResolve header [] #()) "$a0" "$a1") in
    (MethodResolve (go.PointerType DefaultLogger) "Output"%go (![go.PointerType DefaultLogger] "l")) "$a0" "$a1");;;
    return: #()).

(* go: logger.go:122:25 *)
Definition DefaultLogger__Fatalⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" "v",
    exception_do (let: "l" := (GoAlloc (go.PointerType DefaultLogger) "l") in
    let: "v" := (GoAlloc (go.SliceType (go.InterfaceType [])) "v") in
    do:  (let: "$a0" := (Convert go.untyped_int go.int calldepth) in
    let: "$a1" := (let: "$a0" := #"FATAL"%go in
    let: "$a1" := (let: "$a0" := (![go.SliceType (go.InterfaceType [])] "v") in
    (FuncResolve fmt.Sprint [] #()) "$a0") in
    (FuncResolve header [] #()) "$a0" "$a1") in
    (MethodResolve (go.PointerType DefaultLogger) "Output"%go (![go.PointerType DefaultLogger] "l")) "$a0" "$a1");;;
    do:  (let: "$a0" := #(W64 1) in
    (FuncResolve os.Exit [] #()) "$a0");;;
    return: #()).

(* go: logger.go:127:25 *)
Definition DefaultLogger__Fatalfⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" "format" "v",
    exception_do (let: "l" := (GoAlloc (go.PointerType DefaultLogger) "l") in
    let: "v" := (GoAlloc (go.SliceType (go.InterfaceType [])) "v") in
    let: "format" := (GoAlloc go.string "format") in
    do:  (let: "$a0" := (Convert go.untyped_int go.int calldepth) in
    let: "$a1" := (let: "$a0" := #"FATAL"%go in
    let: "$a1" := (let: "$a0" := (![go.string] "format") in
    let: "$a1" := (![go.SliceType (go.InterfaceType [])] "v") in
    (FuncResolve fmt.Sprintf [] #()) "$a0" "$a1") in
    (FuncResolve header [] #()) "$a0" "$a1") in
    (MethodResolve (go.PointerType DefaultLogger) "Output"%go (![go.PointerType DefaultLogger] "l")) "$a0" "$a1");;;
    do:  (let: "$a0" := #(W64 1) in
    (FuncResolve os.Exit [] #()) "$a0");;;
    return: #()).

(* go: logger.go:132:25 *)
Definition DefaultLogger__Panicⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" "v",
    exception_do (let: "l" := (GoAlloc (go.PointerType DefaultLogger) "l") in
    let: "v" := (GoAlloc (go.SliceType (go.InterfaceType [])) "v") in
    do:  (let: "$a0" := (![go.SliceType (go.InterfaceType [])] "v") in
    (MethodResolve (go.PointerType log.Logger) "Panic"%go (![go.PointerType log.Logger] (StructFieldRef DefaultLogger "Logger"%go (![go.PointerType DefaultLogger] "l")))) "$a0");;;
    return: #()).

(* go: logger.go:136:25 *)
Definition DefaultLogger__Panicfⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" "format" "v",
    exception_do (let: "l" := (GoAlloc (go.PointerType DefaultLogger) "l") in
    let: "v" := (GoAlloc (go.SliceType (go.InterfaceType [])) "v") in
    let: "format" := (GoAlloc go.string "format") in
    do:  (let: "$a0" := (![go.string] "format") in
    let: "$a1" := (![go.SliceType (go.InterfaceType [])] "v") in
    (MethodResolve (go.PointerType log.Logger) "Panicf"%go (![go.PointerType log.Logger] (StructFieldRef DefaultLogger "Logger"%go (![go.PointerType DefaultLogger] "l")))) "$a0" "$a1");;;
    return: #()).

(* go: logger.go:140:6 *)
Definition headerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "lvl" "msg",
    exception_do (let: "msg" := (GoAlloc go.string "msg") in
    let: "lvl" := (GoAlloc go.string "lvl") in
    return: (let: "$a0" := #"%s: %s"%go in
     let: "$a1" := ((let: "$sl0" := (Convert go.string go.any (![go.string] "lvl")) in
     let: "$sl1" := (Convert go.string go.any (![go.string] "msg")) in
     CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0"); KeyedElement None (ElementExpression go.any "$sl1")]))) in
     (FuncResolve fmt.Sprintf [] #()) "$a0" "$a1")).

(* go: node.go:45:21 *)
Definition SoftState__equalⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "a" "b",
    exception_do (let: "a" := (GoAlloc (go.PointerType SoftState) "a") in
    let: "b" := (GoAlloc (go.PointerType SoftState) "b") in
    return: (((![go.uint64] (StructFieldRef SoftState "Lead"%go (![go.PointerType SoftState] "a"))) =⟨go.uint64⟩ (![go.uint64] (StructFieldRef SoftState "Lead"%go (![go.PointerType SoftState] "b")))) && ((![StateType] (StructFieldRef SoftState "RaftState"%go (![go.PointerType SoftState] "a"))) =⟨go.uint64⟩ (![StateType] (StructFieldRef SoftState "RaftState"%go (![go.PointerType SoftState] "b")))))).

(* go: node.go:117:6 *)
Definition isHardStateEqualⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "a" "b",
    exception_do (let: "b" := (GoAlloc raftpb.HardState "b") in
    let: "a" := (GoAlloc raftpb.HardState "a") in
    return: ((((![go.uint64] (StructFieldRef raftpb.HardState "Term"%go "a")) =⟨go.uint64⟩ (![go.uint64] (StructFieldRef raftpb.HardState "Term"%go "b"))) && ((![go.uint64] (StructFieldRef raftpb.HardState "Vote"%go "a")) =⟨go.uint64⟩ (![go.uint64] (StructFieldRef raftpb.HardState "Vote"%go "b")))) && ((![go.uint64] (StructFieldRef raftpb.HardState "Commit"%go "a")) =⟨go.uint64⟩ (![go.uint64] (StructFieldRef raftpb.HardState "Commit"%go "b"))))).

(* IsEmptyHardState returns true if the given HardState is empty.

   go: node.go:122:6 *)
Definition IsEmptyHardStateⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "st",
    exception_do (let: "st" := (GoAlloc raftpb.HardState "st") in
    return: (let: "$a0" := (![raftpb.HardState] "st") in
     let: "$a1" := (![raftpb.HardState] (GlobalVarAddr emptyState #())) in
     (FuncResolve isHardStateEqual [] #()) "$a0" "$a1")).

(* IsEmptySnap returns true if the given Snapshot is empty.

   go: node.go:127:6 *)
Definition IsEmptySnapⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "sp",
    exception_do (let: "sp" := (GoAlloc raftpb.Snapshot "sp") in
    return: ((![go.uint64] (StructFieldRef raftpb.SnapshotMetadata "Index"%go (StructFieldRef raftpb.Snapshot "Metadata"%go "sp"))) =⟨go.uint64⟩ #(W64 0))).

(* go: node.go:250:6 *)
Definition setupNodeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "c" "peers",
    exception_do (let: "peers" := (GoAlloc (go.SliceType Peer) "peers") in
    let: "c" := (GoAlloc (go.PointerType Config) "c") in
    (if: Convert go.untyped_bool go.bool ((let: "$a0" := (![go.SliceType Peer] "peers") in
    (FuncResolve go.len [go.SliceType Peer] #()) "$a0") =⟨go.int⟩ #(W64 0))
    then
      do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"no peers given; use RestartNode instead"%go) in
      (FuncResolve go.panic [] #()) "$a0")
    else do:  #());;;
    let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
    let: "rn" := (GoAlloc (go.PointerType RawNode) (GoZeroVal (go.PointerType RawNode) #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.PointerType Config] "c") in
    (FuncResolve NewRawNode [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("rn" <-[go.PointerType RawNode] "$r0");;;
    do:  ("err" <-[go.error] "$r1");;;
    (if: Convert go.untyped_bool go.bool ((![go.error] "err") ≠⟨go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]⟩ (Convert go.untyped_nil (go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]) UntypedNil))
    then
      do:  (let: "$a0" := (Convert go.error (go.InterfaceType []) (![go.error] "err")) in
      (FuncResolve go.panic [] #()) "$a0")
    else do:  #());;;
    let: "$r0" := (let: "$a0" := (![go.SliceType Peer] "peers") in
    (MethodResolve (go.PointerType RawNode) "Bootstrap"%go (![go.PointerType RawNode] "rn")) "$a0") in
    do:  ("err" <-[go.error] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.error] "err") ≠⟨go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]⟩ (Convert go.untyped_nil (go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]) UntypedNil))
    then
      do:  (let: "$a0" := #"error occurred during starting a new node: %v"%go in
      let: "$a1" := ((let: "$sl0" := (Convert go.error (go.InterfaceType []) (![go.error] "err")) in
      CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0")]))) in
      (MethodResolve Logger "Warningf"%go (![Logger] (StructFieldRef Config "Logger"%go (![go.PointerType Config] "c")))) "$a0" "$a1")
    else do:  #());;;
    let: "n" := (GoAlloc node (GoZeroVal node #())) in
    let: "$r0" := (let: "$a0" := (![go.PointerType RawNode] "rn") in
    (FuncResolve newNode [] #()) "$a0") in
    do:  ("n" <-[node] "$r0");;;
    return: ("n")).

(* StartNode returns a new Node given configuration and a list of raft peers.
   It appends a ConfChangeAddNode entry for each given peer to the initial log.

   Peers must not be zero length; call RestartNode in that case.

   go: node.go:271:6 *)
Definition StartNodeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "c" "peers",
    exception_do (let: "peers" := (GoAlloc (go.SliceType Peer) "peers") in
    let: "c" := (GoAlloc (go.PointerType Config) "c") in
    let: "n" := (GoAlloc (go.PointerType node) (GoZeroVal (go.PointerType node) #())) in
    let: "$r0" := (let: "$a0" := (![go.PointerType Config] "c") in
    let: "$a1" := (![go.SliceType Peer] "peers") in
    (FuncResolve setupNode [] #()) "$a0" "$a1") in
    do:  ("n" <-[go.PointerType node] "$r0");;;
    let: "$go" := (MethodResolve (go.PointerType node) "run"%go (![go.PointerType node] "n")) in
    do:  (Fork ("$go" #()));;;
    return: (Convert (go.PointerType node) Node (![go.PointerType node] "n"))).

(* RestartNode is similar to StartNode but does not take a list of peers.
   The current membership of the cluster will be restored from the Storage.
   If the caller has an existing state machine, pass in the last log index that
   has been applied to it; otherwise use zero.

   go: node.go:281:6 *)
Definition RestartNodeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "c",
    exception_do (let: "c" := (GoAlloc (go.PointerType Config) "c") in
    let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
    let: "rn" := (GoAlloc (go.PointerType RawNode) (GoZeroVal (go.PointerType RawNode) #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.PointerType Config] "c") in
    (FuncResolve NewRawNode [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("rn" <-[go.PointerType RawNode] "$r0");;;
    do:  ("err" <-[go.error] "$r1");;;
    (if: Convert go.untyped_bool go.bool ((![go.error] "err") ≠⟨go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]⟩ (Convert go.untyped_nil (go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]) UntypedNil))
    then
      do:  (let: "$a0" := (Convert go.error (go.InterfaceType []) (![go.error] "err")) in
      (FuncResolve go.panic [] #()) "$a0")
    else do:  #());;;
    let: "n" := (GoAlloc node (GoZeroVal node #())) in
    let: "$r0" := (let: "$a0" := (![go.PointerType RawNode] "rn") in
    (FuncResolve newNode [] #()) "$a0") in
    do:  ("n" <-[node] "$r0");;;
    let: "$go" := (MethodResolve (go.PointerType node) "run"%go "n") in
    do:  (Fork ("$go" #()));;;
    return: (Convert (go.PointerType node) Node "n")).

(* go: node.go:312:6 *)
Definition newNodeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "rn",
    exception_do (let: "rn" := (GoAlloc (go.PointerType RawNode) "rn") in
    return: (CompositeLiteral node (LiteralValue [KeyedElement (Some (KeyField "propc"%go)) (ElementExpression (go.ChannelType go.sendrecv msgWithResult) ((FuncResolve go.make1 [go.ChannelType go.sendrecv msgWithResult] #()) #())); KeyedElement (Some (KeyField "recvc"%go)) (ElementExpression (go.ChannelType go.sendrecv raftpb.Message) ((FuncResolve go.make1 [go.ChannelType go.sendrecv raftpb.Message] #()) #())); KeyedElement (Some (KeyField "confc"%go)) (ElementExpression (go.ChannelType go.sendrecv raftpb.ConfChangeV2) ((FuncResolve go.make1 [go.ChannelType go.sendrecv raftpb.ConfChangeV2] #()) #())); KeyedElement (Some (KeyField "confstatec"%go)) (ElementExpression (go.ChannelType go.sendrecv raftpb.ConfState) ((FuncResolve go.make1 [go.ChannelType go.sendrecv raftpb.ConfState] #()) #())); KeyedElement (Some (KeyField "readyc"%go)) (ElementExpression (go.ChannelType go.sendrecv Ready) ((FuncResolve go.make1 [go.ChannelType go.sendrecv Ready] #()) #())); KeyedElement (Some (KeyField "advancec"%go)) (ElementExpression (go.ChannelType go.sendrecv (go.StructType [

      ])) ((FuncResolve go.make1 [go.ChannelType go.sendrecv (go.StructType [

       ])] #()) #())); KeyedElement (Some (KeyField "tickc"%go)) (ElementExpression (go.ChannelType go.sendrecv (go.StructType [

      ])) ((FuncResolve go.make2 [go.ChannelType go.sendrecv (go.StructType [

       ])] #()) #(W64 128))); KeyedElement (Some (KeyField "done"%go)) (ElementExpression (go.ChannelType go.sendrecv (go.StructType [

      ])) ((FuncResolve go.make1 [go.ChannelType go.sendrecv (go.StructType [

       ])] #()) #())); KeyedElement (Some (KeyField "stop"%go)) (ElementExpression (go.ChannelType go.sendrecv (go.StructType [

      ])) ((FuncResolve go.make1 [go.ChannelType go.sendrecv (go.StructType [

       ])] #()) #())); KeyedElement (Some (KeyField "status"%go)) (ElementExpression (go.ChannelType go.sendrecv (go.ChannelType go.sendrecv Status)) ((FuncResolve go.make1 [go.ChannelType go.sendrecv (go.ChannelType go.sendrecv Status)] #()) #())); KeyedElement (Some (KeyField "rn"%go)) (ElementExpression (go.PointerType RawNode) (![go.PointerType RawNode] "rn"))]))).

(* go: node.go:331:16 *)
Definition node__Stopⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "n" <>,
    exception_do (let: "n" := (GoAlloc (go.PointerType node) "n") in
    SelectStmt (SelectStmtClauses None [(CommClause (SendCase (go.StructType [

    ]) (![go.ChannelType go.sendrecv (go.StructType [

    ])] (StructFieldRef node "stop"%go (![go.PointerType node] "n"))) (CompositeLiteral (go.StructType [

    ]) (LiteralValue []))) (λ: <>,
      do:  #()
      )); (CommClause (RecvCase (go.StructType [

    ]) (![go.ChannelType go.sendrecv (go.StructType [

    ])] (StructFieldRef node "done"%go (![go.PointerType node] "n")))) (λ: "$recvVal",
      return: (#())
      ))]);;;
    do:  (Fst (chan.receive (go.StructType [

    ]) (![go.ChannelType go.sendrecv (go.StructType [

    ])] (StructFieldRef node "done"%go (![go.PointerType node] "n")))));;;
    return: #()).

(* go: node.go:343:16 *)
Definition node__runⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "n" <>,
    exception_do (let: "n" := (GoAlloc (go.PointerType node) "n") in
    let: "propc" := (GoAlloc (go.ChannelType go.sendrecv msgWithResult) (GoZeroVal (go.ChannelType go.sendrecv msgWithResult) #())) in
    let: "readyc" := (GoAlloc (go.ChannelType go.sendrecv Ready) (GoZeroVal (go.ChannelType go.sendrecv Ready) #())) in
    let: "advancec" := (GoAlloc (go.ChannelType go.sendrecv (go.StructType [

    ])) (GoZeroVal (go.ChannelType go.sendrecv (go.StructType [

    ])) #())) in
    let: "rd" := (GoAlloc Ready (GoZeroVal Ready #())) in
    let: "r" := (GoAlloc (go.PointerType raft) (GoZeroVal (go.PointerType raft) #())) in
    let: "$r0" := (![go.PointerType raft] (StructFieldRef RawNode "raft"%go (![go.PointerType RawNode] (StructFieldRef node "rn"%go (![go.PointerType node] "n"))))) in
    do:  ("r" <-[go.PointerType raft] "$r0");;;
    let: "lead" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := None in
    do:  ("lead" <-[go.uint64] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, #()) := λ: <>,
      (if: ((![go.ChannelType go.sendrecv (go.StructType [

      ])] "advancec") =⟨go.ChannelType go.sendrecv (go.StructType [

      ])⟩ (Convert go.untyped_nil (go.ChannelType go.sendrecv (go.StructType [

      ])) UntypedNil)) && ((MethodResolve (go.PointerType RawNode) "HasReady"%go (![go.PointerType RawNode] (StructFieldRef node "rn"%go (![go.PointerType node] "n")))) #())
      then
        let: "$r0" := ((MethodResolve (go.PointerType RawNode) "readyWithoutAccept"%go (![go.PointerType RawNode] (StructFieldRef node "rn"%go (![go.PointerType node] "n")))) #()) in
        do:  ("rd" <-[Ready] "$r0");;;
        let: "$r0" := (![go.ChannelType go.sendrecv Ready] (StructFieldRef node "readyc"%go (![go.PointerType node] "n"))) in
        do:  ("readyc" <-[go.ChannelType go.sendrecv Ready] "$r0")
      else do:  #());;;
      (if: Convert go.untyped_bool go.bool ((![go.uint64] "lead") ≠⟨go.uint64⟩ (![go.uint64] (StructFieldRef raft "lead"%go (![go.PointerType raft] "r"))))
      then
        (if: (MethodResolve (go.PointerType raft) "hasLeader"%go (![go.PointerType raft] "r")) #()
        then
          (if: Convert go.untyped_bool go.bool ((![go.uint64] "lead") =⟨go.uint64⟩ None)
          then
            do:  (let: "$a0" := #"raft.node: %x elected leader %x at term %d"%go in
            let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))) in
            let: "$sl1" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "lead"%go (![go.PointerType raft] "r")))) in
            let: "$sl2" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "Term"%go (![go.PointerType raft] "r")))) in
            CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl2")]))) in
            (MethodResolve Logger "Infof"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0" "$a1")
          else
            do:  (let: "$a0" := #"raft.node: %x changed leader from %x to %x at term %d"%go in
            let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))) in
            let: "$sl1" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] "lead")) in
            let: "$sl2" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "lead"%go (![go.PointerType raft] "r")))) in
            let: "$sl3" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "Term"%go (![go.PointerType raft] "r")))) in
            CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl2"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl3")]))) in
            (MethodResolve Logger "Infof"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0" "$a1"));;;
          let: "$r0" := (![go.ChannelType go.sendrecv msgWithResult] (StructFieldRef node "propc"%go (![go.PointerType node] "n"))) in
          do:  ("propc" <-[go.ChannelType go.sendrecv msgWithResult] "$r0")
        else
          do:  (let: "$a0" := #"raft.node: %x lost leader %x at term %d"%go in
          let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))) in
          let: "$sl1" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] "lead")) in
          let: "$sl2" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "Term"%go (![go.PointerType raft] "r")))) in
          CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl2")]))) in
          (MethodResolve Logger "Infof"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0" "$a1");;;
          let: "$r0" := (Convert go.untyped_nil (go.ChannelType go.sendrecv msgWithResult) UntypedNil) in
          do:  ("propc" <-[go.ChannelType go.sendrecv msgWithResult] "$r0"));;;
        let: "$r0" := (![go.uint64] (StructFieldRef raft "lead"%go (![go.PointerType raft] "r"))) in
        do:  ("lead" <-[go.uint64] "$r0")
      else do:  #());;;
      SelectStmt (SelectStmtClauses None [(CommClause (RecvCase msgWithResult (![go.ChannelType go.sendrecv msgWithResult] "propc")) (λ: "$recvVal",
        let: "pm" := (GoAlloc msgWithResult (GoZeroVal msgWithResult #())) in
        let: "$r0" := (Fst "$recvVal") in
        do:  ("pm" <-[msgWithResult] "$r0");;;
        let: "m" := (GoAlloc raftpb.Message (GoZeroVal raftpb.Message #())) in
        let: "$r0" := (![raftpb.Message] (StructFieldRef msgWithResult "m"%go "pm")) in
        do:  ("m" <-[raftpb.Message] "$r0");;;
        let: "$r0" := (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r"))) in
        do:  ((StructFieldRef raftpb.Message "From"%go "m") <-[go.uint64] "$r0");;;
        let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
        let: "$r0" := (let: "$a0" := (![raftpb.Message] "m") in
        (MethodResolve (go.PointerType raft) "Step"%go (![go.PointerType raft] "r")) "$a0") in
        do:  ("err" <-[go.error] "$r0");;;
        (if: Convert go.untyped_bool go.bool ((![go.ChannelType go.sendrecv go.error] (StructFieldRef msgWithResult "result"%go "pm")) ≠⟨go.ChannelType go.sendrecv go.error⟩ (Convert go.untyped_nil (go.ChannelType go.sendrecv go.error) UntypedNil))
        then
          do:  (let: "$chan" := (![go.ChannelType go.sendrecv go.error] (StructFieldRef msgWithResult "result"%go "pm")) in
          let: "$v" := (![go.error] "err") in
          chan.send go.error "$chan" "$v");;;
          do:  (let: "$a0" := (![go.ChannelType go.sendrecv go.error] (StructFieldRef msgWithResult "result"%go "pm")) in
          (FuncResolve go.close [go.ChannelType go.sendrecv go.error] #()) "$a0")
        else do:  #())
        )); (CommClause (RecvCase raftpb.Message (![go.ChannelType go.sendrecv raftpb.Message] (StructFieldRef node "recvc"%go (![go.PointerType node] "n")))) (λ: "$recvVal",
        let: "m" := (GoAlloc raftpb.Message (GoZeroVal raftpb.Message #())) in
        let: "$r0" := (Fst "$recvVal") in
        do:  ("m" <-[raftpb.Message] "$r0");;;
        (if: ((let: "$a0" := (![raftpb.MessageType] (StructFieldRef raftpb.Message "Type"%go "m")) in
        (FuncResolve IsResponseMsg [] #()) "$a0") && (~ (let: "$a0" := (![go.uint64] (StructFieldRef raftpb.Message "From"%go "m")) in
        (FuncResolve IsLocalMsgTarget [] #()) "$a0"))) && ((map.lookup1 go.uint64 (go.PointerType tracker.Progress) (![tracker.ProgressMap] (StructFieldRef tracker.ProgressTracker "Progress"%go (StructFieldRef raft "trk"%go (![go.PointerType raft] "r")))) (![go.uint64] (StructFieldRef raftpb.Message "From"%go "m"))) =⟨go.PointerType tracker.Progress⟩ (Convert go.untyped_nil (go.PointerType tracker.Progress) UntypedNil))
        then break: #()
        else do:  #());;;
        do:  (let: "$a0" := (![raftpb.Message] "m") in
        (MethodResolve (go.PointerType raft) "Step"%go (![go.PointerType raft] "r")) "$a0")
        )); (CommClause (RecvCase raftpb.ConfChangeV2 (![go.ChannelType go.sendrecv raftpb.ConfChangeV2] (StructFieldRef node "confc"%go (![go.PointerType node] "n")))) (λ: "$recvVal",
        let: "cc" := (GoAlloc raftpb.ConfChangeV2 (GoZeroVal raftpb.ConfChangeV2 #())) in
        let: "$r0" := (Fst "$recvVal") in
        do:  ("cc" <-[raftpb.ConfChangeV2] "$r0");;;
        let: "okBefore" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
        let: ("$ret0", "$ret1") := (map.lookup2 go.uint64 (go.PointerType tracker.Progress) (![tracker.ProgressMap] (StructFieldRef tracker.ProgressTracker "Progress"%go (StructFieldRef raft "trk"%go (![go.PointerType raft] "r")))) (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))) in
        let: "$r0" := "$ret0" in
        let: "$r1" := "$ret1" in
        do:  "$r0";;;
        do:  ("okBefore" <-[go.bool] "$r1");;;
        let: "cs" := (GoAlloc raftpb.ConfState (GoZeroVal raftpb.ConfState #())) in
        let: "$r0" := (let: "$a0" := (![raftpb.ConfChangeV2] "cc") in
        (MethodResolve (go.PointerType raft) "applyConfChange"%go (![go.PointerType raft] "r")) "$a0") in
        do:  ("cs" <-[raftpb.ConfState] "$r0");;;
        (let: "okAfter" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
        let: ("$ret0", "$ret1") := (map.lookup2 go.uint64 (go.PointerType tracker.Progress) (![tracker.ProgressMap] (StructFieldRef tracker.ProgressTracker "Progress"%go (StructFieldRef raft "trk"%go (![go.PointerType raft] "r")))) (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))) in
        let: "$r0" := "$ret0" in
        let: "$r1" := "$ret1" in
        do:  "$r0";;;
        do:  ("okAfter" <-[go.bool] "$r1");;;
        (if: (![go.bool] "okBefore") && (~ (![go.bool] "okAfter"))
        then
          let: "found" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
          let: "$range" := (CompositeLiteral (go.SliceType (go.SliceType go.uint64)) (LiteralValue [KeyedElement None (ElementExpression (go.SliceType go.uint64) (![go.SliceType go.uint64] (StructFieldRef raftpb.ConfState "Voters"%go "cs"))); KeyedElement None (ElementExpression (go.SliceType go.uint64) (![go.SliceType go.uint64] (StructFieldRef raftpb.ConfState "VotersOutgoing"%go "cs")))])) in
          (let: "sl" := (GoAlloc (go.SliceType go.uint64) (GoZeroVal (go.SliceType go.uint64) #())) in
          slice.for_range (go.SliceType go.uint64) "$range" (λ: "$key" "$value",
            do:  ("sl" <-[go.SliceType go.uint64] "$value");;;
            do:  "$key";;;
            let: "$range" := (![go.SliceType go.uint64] "sl") in
            (let: "id" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
            slice.for_range go.uint64 "$range" (λ: "$key" "$value",
              do:  ("id" <-[go.uint64] "$value");;;
              do:  "$key";;;
              (if: Convert go.untyped_bool go.bool ((![go.uint64] "id") =⟨go.uint64⟩ (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r"))))
              then
                let: "$r0" := #true in
                do:  ("found" <-[go.bool] "$r0");;;
                break: #()
              else do:  #())));;;
            (if: ![go.bool] "found"
            then break: #()
            else do:  #())));;;
          (if: (~ (![go.bool] "found"))
          then
            let: "$r0" := (Convert go.untyped_nil (go.ChannelType go.sendrecv msgWithResult) UntypedNil) in
            do:  ("propc" <-[go.ChannelType go.sendrecv msgWithResult] "$r0")
          else do:  #())
        else do:  #()));;;
        SelectStmt (SelectStmtClauses None [(CommClause (SendCase raftpb.ConfState (![go.ChannelType go.sendrecv raftpb.ConfState] (StructFieldRef node "confstatec"%go (![go.PointerType node] "n"))) (![raftpb.ConfState] "cs")) (λ: <>,
          do:  #()
          )); (CommClause (RecvCase (go.StructType [

        ]) (![go.ChannelType go.sendrecv (go.StructType [

        ])] (StructFieldRef node "done"%go (![go.PointerType node] "n")))) (λ: "$recvVal",
          do:  #()
          ))])
        )); (CommClause (RecvCase (go.StructType [

      ]) (![go.ChannelType go.sendrecv (go.StructType [

      ])] (StructFieldRef node "tickc"%go (![go.PointerType node] "n")))) (λ: "$recvVal",
        do:  ((MethodResolve (go.PointerType RawNode) "Tick"%go (![go.PointerType RawNode] (StructFieldRef node "rn"%go (![go.PointerType node] "n")))) #())
        )); (CommClause (SendCase Ready (![go.ChannelType go.sendrecv Ready] "readyc") (![Ready] "rd")) (λ: <>,
        do:  (let: "$a0" := (![Ready] "rd") in
        (MethodResolve (go.PointerType RawNode) "acceptReady"%go (![go.PointerType RawNode] (StructFieldRef node "rn"%go (![go.PointerType node] "n")))) "$a0");;;
        (if: (~ (![go.bool] (StructFieldRef RawNode "asyncStorageWrites"%go (![go.PointerType RawNode] (StructFieldRef node "rn"%go (![go.PointerType node] "n"))))))
        then
          let: "$r0" := (![go.ChannelType go.sendrecv (go.StructType [

          ])] (StructFieldRef node "advancec"%go (![go.PointerType node] "n"))) in
          do:  ("advancec" <-[go.ChannelType go.sendrecv (go.StructType [

          ])] "$r0")
        else
          let: "$r0" := (CompositeLiteral Ready (LiteralValue [])) in
          do:  ("rd" <-[Ready] "$r0"));;;
        let: "$r0" := (Convert go.untyped_nil (go.ChannelType go.sendrecv Ready) UntypedNil) in
        do:  ("readyc" <-[go.ChannelType go.sendrecv Ready] "$r0")
        )); (CommClause (RecvCase (go.StructType [

      ]) (![go.ChannelType go.sendrecv (go.StructType [

      ])] "advancec")) (λ: "$recvVal",
        do:  (let: "$a0" := (![Ready] "rd") in
        (MethodResolve (go.PointerType RawNode) "Advance"%go (![go.PointerType RawNode] (StructFieldRef node "rn"%go (![go.PointerType node] "n")))) "$a0");;;
        let: "$r0" := (CompositeLiteral Ready (LiteralValue [])) in
        do:  ("rd" <-[Ready] "$r0");;;
        let: "$r0" := (Convert go.untyped_nil (go.ChannelType go.sendrecv (go.StructType [

        ])) UntypedNil) in
        do:  ("advancec" <-[go.ChannelType go.sendrecv (go.StructType [

        ])] "$r0")
        )); (CommClause (RecvCase (go.ChannelType go.sendrecv Status) (![go.ChannelType go.sendrecv (go.ChannelType go.sendrecv Status)] (StructFieldRef node "status"%go (![go.PointerType node] "n")))) (λ: "$recvVal",
        let: "c" := (GoAlloc (go.ChannelType go.sendrecv Status) (GoZeroVal (go.ChannelType go.sendrecv Status) #())) in
        let: "$r0" := (Fst "$recvVal") in
        do:  ("c" <-[go.ChannelType go.sendrecv Status] "$r0");;;
        do:  (let: "$chan" := (![go.ChannelType go.sendrecv Status] "c") in
        let: "$v" := (let: "$a0" := (![go.PointerType raft] "r") in
        (FuncResolve getStatus [] #()) "$a0") in
        chan.send Status "$chan" "$v")
        )); (CommClause (RecvCase (go.StructType [

      ]) (![go.ChannelType go.sendrecv (go.StructType [

      ])] (StructFieldRef node "stop"%go (![go.PointerType node] "n")))) (λ: "$recvVal",
        do:  (let: "$a0" := (![go.ChannelType go.sendrecv (go.StructType [

        ])] (StructFieldRef node "done"%go (![go.PointerType node] "n"))) in
        (FuncResolve go.close [go.ChannelType go.sendrecv (go.StructType [

         ])] #()) "$a0");;;
        return: (#())
        ))]));;;
    return: #()).

(* Tick increments the internal logical clock for this Node. Election timeouts
   and heartbeat timeouts are in units of ticks.

   go: node.go:458:16 *)
Definition node__Tickⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "n" <>,
    exception_do (let: "n" := (GoAlloc (go.PointerType node) "n") in
    SelectStmt (SelectStmtClauses (Some (λ: <>,
      do:  (let: "$a0" := #"%x A tick missed to fire. Node blocks too long!"%go in
      let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] (StructFieldRef RawNode "raft"%go (![go.PointerType RawNode] (StructFieldRef node "rn"%go (![go.PointerType node] "n")))))))) in
      CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0")]))) in
      (MethodResolve Logger "Warningf"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] (StructFieldRef RawNode "raft"%go (![go.PointerType RawNode] (StructFieldRef node "rn"%go (![go.PointerType node] "n")))))))) "$a0" "$a1")
      )) [(CommClause (SendCase (go.StructType [

    ]) (![go.ChannelType go.sendrecv (go.StructType [

    ])] (StructFieldRef node "tickc"%go (![go.PointerType node] "n"))) (CompositeLiteral (go.StructType [

    ]) (LiteralValue []))) (λ: <>,
      do:  #()
      )); (CommClause (RecvCase (go.StructType [

    ]) (![go.ChannelType go.sendrecv (go.StructType [

    ])] (StructFieldRef node "done"%go (![go.PointerType node] "n")))) (λ: "$recvVal",
      do:  #()
      ))]);;;
    return: #()).

(* go: node.go:467:16 *)
Definition node__Campaignⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "n" "ctx",
    exception_do (let: "n" := (GoAlloc (go.PointerType node) "n") in
    let: "ctx" := (GoAlloc context.Context "ctx") in
    return: (let: "$a0" := (![context.Context] "ctx") in
     let: "$a1" := (CompositeLiteral raftpb.Message (LiteralValue [KeyedElement (Some (KeyField "Type"%go)) (ElementExpression raftpb.MessageType raftpb.MsgHup)])) in
     (MethodResolve (go.PointerType node) "step"%go (![go.PointerType node] "n")) "$a0" "$a1")).

(* go: node.go:469:16 *)
Definition node__Proposeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "n" "ctx" "data",
    exception_do (let: "n" := (GoAlloc (go.PointerType node) "n") in
    let: "data" := (GoAlloc (go.SliceType go.byte) "data") in
    let: "ctx" := (GoAlloc context.Context "ctx") in
    return: (let: "$a0" := (![context.Context] "ctx") in
     let: "$a1" := (CompositeLiteral raftpb.Message (LiteralValue [KeyedElement (Some (KeyField "Type"%go)) (ElementExpression raftpb.MessageType raftpb.MsgProp); KeyedElement (Some (KeyField "Entries"%go)) (ElementExpression (go.SliceType raftpb.Entry) (CompositeLiteral (go.SliceType raftpb.Entry) (LiteralValue [KeyedElement None (ElementLiteralValue [KeyedElement (Some (KeyField "Data"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] "data"))])])))])) in
     (MethodResolve (go.PointerType node) "stepWait"%go (![go.PointerType node] "n")) "$a0" "$a1")).

(* go: node.go:473:16 *)
Definition node__Stepⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "n" "ctx" "m",
    exception_do (let: "n" := (GoAlloc (go.PointerType node) "n") in
    let: "m" := (GoAlloc raftpb.Message "m") in
    let: "ctx" := (GoAlloc context.Context "ctx") in
    (if: (let: "$a0" := (![raftpb.MessageType] (StructFieldRef raftpb.Message "Type"%go "m")) in
    (FuncResolve IsLocalMsg [] #()) "$a0") && (~ (let: "$a0" := (![go.uint64] (StructFieldRef raftpb.Message "From"%go "m")) in
    (FuncResolve IsLocalMsgTarget [] #()) "$a0"))
    then return: (Convert go.untyped_nil go.error UntypedNil)
    else do:  #());;;
    return: (let: "$a0" := (![context.Context] "ctx") in
     let: "$a1" := (![raftpb.Message] "m") in
     (MethodResolve (go.PointerType node) "step"%go (![go.PointerType node] "n")) "$a0" "$a1")).

(* go: node.go:482:6 *)
Definition confChangeToMsgⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "c",
    exception_do (let: "c" := (GoAlloc raftpb.ConfChangeI "c") in
    let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
    let: "data" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: "typ" := (GoAlloc raftpb.EntryType (GoZeroVal raftpb.EntryType #())) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![raftpb.ConfChangeI] "c") in
    (FuncResolve raftpb.MarshalConfChange [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("typ" <-[raftpb.EntryType] "$r0");;;
    do:  ("data" <-[go.SliceType go.byte] "$r1");;;
    do:  ("err" <-[go.error] "$r2");;;
    (if: Convert go.untyped_bool go.bool ((![go.error] "err") ≠⟨go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]⟩ (Convert go.untyped_nil (go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]) UntypedNil))
    then return: (CompositeLiteral raftpb.Message (LiteralValue []), ![go.error] "err")
    else do:  #());;;
    return: (CompositeLiteral raftpb.Message (LiteralValue [KeyedElement (Some (KeyField "Type"%go)) (ElementExpression raftpb.MessageType raftpb.MsgProp); KeyedElement (Some (KeyField "Entries"%go)) (ElementExpression (go.SliceType raftpb.Entry) (CompositeLiteral (go.SliceType raftpb.Entry) (LiteralValue [KeyedElement None (ElementLiteralValue [KeyedElement (Some (KeyField "Type"%go)) (ElementExpression raftpb.EntryType (![raftpb.EntryType] "typ")); KeyedElement (Some (KeyField "Data"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] "data"))])])))]), Convert go.untyped_nil go.error UntypedNil)).

(* go: node.go:490:16 *)
Definition node__ProposeConfChangeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "n" "ctx" "cc",
    exception_do (let: "n" := (GoAlloc (go.PointerType node) "n") in
    let: "cc" := (GoAlloc raftpb.ConfChangeI "cc") in
    let: "ctx" := (GoAlloc context.Context "ctx") in
    let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
    let: "msg" := (GoAlloc raftpb.Message (GoZeroVal raftpb.Message #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![raftpb.ConfChangeI] "cc") in
    (FuncResolve confChangeToMsg [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("msg" <-[raftpb.Message] "$r0");;;
    do:  ("err" <-[go.error] "$r1");;;
    (if: Convert go.untyped_bool go.bool ((![go.error] "err") ≠⟨go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]⟩ (Convert go.untyped_nil (go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]) UntypedNil))
    then return: (![go.error] "err")
    else do:  #());;;
    return: (let: "$a0" := (![context.Context] "ctx") in
     let: "$a1" := (![raftpb.Message] "msg") in
     (MethodResolve (go.PointerType node) "Step"%go (![go.PointerType node] "n")) "$a0" "$a1")).

(* go: node.go:498:16 *)
Definition node__stepⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "n" "ctx" "m",
    exception_do (let: "n" := (GoAlloc (go.PointerType node) "n") in
    let: "m" := (GoAlloc raftpb.Message "m") in
    let: "ctx" := (GoAlloc context.Context "ctx") in
    return: (let: "$a0" := (![context.Context] "ctx") in
     let: "$a1" := (![raftpb.Message] "m") in
     let: "$a2" := #false in
     (MethodResolve (go.PointerType node) "stepWithWaitOption"%go (![go.PointerType node] "n")) "$a0" "$a1" "$a2")).

(* go: node.go:502:16 *)
Definition node__stepWaitⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "n" "ctx" "m",
    exception_do (let: "n" := (GoAlloc (go.PointerType node) "n") in
    let: "m" := (GoAlloc raftpb.Message "m") in
    let: "ctx" := (GoAlloc context.Context "ctx") in
    return: (let: "$a0" := (![context.Context] "ctx") in
     let: "$a1" := (![raftpb.Message] "m") in
     let: "$a2" := #true in
     (MethodResolve (go.PointerType node) "stepWithWaitOption"%go (![go.PointerType node] "n")) "$a0" "$a1" "$a2")).

(* Step advances the state machine using msgs. The ctx.Err() will be returned,
   if any.

   go: node.go:508:16 *)
Definition node__stepWithWaitOptionⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "n" "ctx" "m" "wait",
    exception_do (let: "n" := (GoAlloc (go.PointerType node) "n") in
    let: "wait" := (GoAlloc go.bool "wait") in
    let: "m" := (GoAlloc raftpb.Message "m") in
    let: "ctx" := (GoAlloc context.Context "ctx") in
    (if: Convert go.untyped_bool go.bool ((![raftpb.MessageType] (StructFieldRef raftpb.Message "Type"%go "m")) ≠⟨go.int32⟩ raftpb.MsgProp)
    then
      SelectStmt (SelectStmtClauses None [(CommClause (SendCase raftpb.Message (![go.ChannelType go.sendrecv raftpb.Message] (StructFieldRef node "recvc"%go (![go.PointerType node] "n"))) (![raftpb.Message] "m")) (λ: <>,
        return: (Convert go.untyped_nil go.error UntypedNil)
        )); (CommClause (RecvCase (go.StructType [

      ]) ((MethodResolve context.Context "Done"%go (![context.Context] "ctx")) #())) (λ: "$recvVal",
        return: ((MethodResolve context.Context "Err"%go (![context.Context] "ctx")) #())
        )); (CommClause (RecvCase (go.StructType [

      ]) (![go.ChannelType go.sendrecv (go.StructType [

      ])] (StructFieldRef node "done"%go (![go.PointerType node] "n")))) (λ: "$recvVal",
        return: (![go.error] (GlobalVarAddr ErrStopped #()))
        ))])
    else do:  #());;;
    let: "ch" := (GoAlloc (go.ChannelType go.sendrecv msgWithResult) (GoZeroVal (go.ChannelType go.sendrecv msgWithResult) #())) in
    let: "$r0" := (![go.ChannelType go.sendrecv msgWithResult] (StructFieldRef node "propc"%go (![go.PointerType node] "n"))) in
    do:  ("ch" <-[go.ChannelType go.sendrecv msgWithResult] "$r0");;;
    let: "pm" := (GoAlloc msgWithResult (GoZeroVal msgWithResult #())) in
    let: "$r0" := (CompositeLiteral msgWithResult (LiteralValue [KeyedElement (Some (KeyField "m"%go)) (ElementExpression raftpb.Message (![raftpb.Message] "m"))])) in
    do:  ("pm" <-[msgWithResult] "$r0");;;
    (if: ![go.bool] "wait"
    then
      let: "$r0" := ((FuncResolve go.make2 [go.ChannelType go.sendrecv go.error] #()) #(W64 1)) in
      do:  ((StructFieldRef msgWithResult "result"%go "pm") <-[go.ChannelType go.sendrecv go.error] "$r0")
    else do:  #());;;
    SelectStmt (SelectStmtClauses None [(CommClause (SendCase msgWithResult (![go.ChannelType go.sendrecv msgWithResult] "ch") (![msgWithResult] "pm")) (λ: <>,
      (if: (~ (![go.bool] "wait"))
      then return: (Convert go.untyped_nil go.error UntypedNil)
      else do:  #())
      )); (CommClause (RecvCase (go.StructType [

    ]) ((MethodResolve context.Context "Done"%go (![context.Context] "ctx")) #())) (λ: "$recvVal",
      return: ((MethodResolve context.Context "Err"%go (![context.Context] "ctx")) #())
      )); (CommClause (RecvCase (go.StructType [

    ]) (![go.ChannelType go.sendrecv (go.StructType [

    ])] (StructFieldRef node "done"%go (![go.PointerType node] "n")))) (λ: "$recvVal",
      return: (![go.error] (GlobalVarAddr ErrStopped #()))
      ))]);;;
    SelectStmt (SelectStmtClauses None [(CommClause (RecvCase go.error (![go.ChannelType go.sendrecv go.error] (StructFieldRef msgWithResult "result"%go "pm"))) (λ: "$recvVal",
      let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
      let: "$r0" := (Fst "$recvVal") in
      do:  ("err" <-[go.error] "$r0");;;
      (if: Convert go.untyped_bool go.bool ((![go.error] "err") ≠⟨go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]⟩ (Convert go.untyped_nil (go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]) UntypedNil))
      then return: (![go.error] "err")
      else do:  #())
      )); (CommClause (RecvCase (go.StructType [

    ]) ((MethodResolve context.Context "Done"%go (![context.Context] "ctx")) #())) (λ: "$recvVal",
      return: ((MethodResolve context.Context "Err"%go (![context.Context] "ctx")) #())
      )); (CommClause (RecvCase (go.StructType [

    ]) (![go.ChannelType go.sendrecv (go.StructType [

    ])] (StructFieldRef node "done"%go (![go.PointerType node] "n")))) (λ: "$recvVal",
      return: (![go.error] (GlobalVarAddr ErrStopped #()))
      ))]);;;
    return: (Convert go.untyped_nil go.error UntypedNil)).

(* go: node.go:547:16 *)
Definition node__Readyⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "n" <>,
    exception_do (let: "n" := (GoAlloc (go.PointerType node) "n") in
    return: (Convert (go.ChannelType go.sendrecv Ready) (go.ChannelType go.recvonly Ready) (![go.ChannelType go.sendrecv Ready] (StructFieldRef node "readyc"%go (![go.PointerType node] "n"))))).

(* go: node.go:549:16 *)
Definition node__Advanceⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "n" <>,
    exception_do (let: "n" := (GoAlloc (go.PointerType node) "n") in
    SelectStmt (SelectStmtClauses None [(CommClause (SendCase (go.StructType [

    ]) (![go.ChannelType go.sendrecv (go.StructType [

    ])] (StructFieldRef node "advancec"%go (![go.PointerType node] "n"))) (CompositeLiteral (go.StructType [

    ]) (LiteralValue []))) (λ: <>,
      do:  #()
      )); (CommClause (RecvCase (go.StructType [

    ]) (![go.ChannelType go.sendrecv (go.StructType [

    ])] (StructFieldRef node "done"%go (![go.PointerType node] "n")))) (λ: "$recvVal",
      do:  #()
      ))]);;;
    return: #()).

(* go: node.go:556:16 *)
Definition node__ApplyConfChangeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "n" "cc",
    exception_do (let: "n" := (GoAlloc (go.PointerType node) "n") in
    let: "cc" := (GoAlloc raftpb.ConfChangeI "cc") in
    let: "cs" := (GoAlloc raftpb.ConfState (GoZeroVal raftpb.ConfState #())) in
    SelectStmt (SelectStmtClauses None [(CommClause (SendCase raftpb.ConfChangeV2 (![go.ChannelType go.sendrecv raftpb.ConfChangeV2] (StructFieldRef node "confc"%go (![go.PointerType node] "n"))) ((MethodResolve raftpb.ConfChangeI "AsV2"%go (![raftpb.ConfChangeI] "cc")) #())) (λ: <>,
      do:  #()
      )); (CommClause (RecvCase (go.StructType [

    ]) (![go.ChannelType go.sendrecv (go.StructType [

    ])] (StructFieldRef node "done"%go (![go.PointerType node] "n")))) (λ: "$recvVal",
      do:  #()
      ))]);;;
    SelectStmt (SelectStmtClauses None [(CommClause (RecvCase raftpb.ConfState (![go.ChannelType go.sendrecv raftpb.ConfState] (StructFieldRef node "confstatec"%go (![go.PointerType node] "n")))) (λ: "$recvVal",
      let: "$r0" := (Fst "$recvVal") in
      do:  ("cs" <-[raftpb.ConfState] "$r0");;;
      do:  #()
      )); (CommClause (RecvCase (go.StructType [

    ]) (![go.ChannelType go.sendrecv (go.StructType [

    ])] (StructFieldRef node "done"%go (![go.PointerType node] "n")))) (λ: "$recvVal",
      do:  #()
      ))]);;;
    return: ("cs")).

(* go: node.go:569:16 *)
Definition node__Statusⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "n" <>,
    exception_do (let: "n" := (GoAlloc (go.PointerType node) "n") in
    let: "c" := (GoAlloc (go.ChannelType go.sendrecv Status) (GoZeroVal (go.ChannelType go.sendrecv Status) #())) in
    let: "$r0" := ((FuncResolve go.make1 [go.ChannelType go.sendrecv Status] #()) #()) in
    do:  ("c" <-[go.ChannelType go.sendrecv Status] "$r0");;;
    SelectStmt (SelectStmtClauses None [(CommClause (SendCase (go.ChannelType go.sendrecv Status) (![go.ChannelType go.sendrecv (go.ChannelType go.sendrecv Status)] (StructFieldRef node "status"%go (![go.PointerType node] "n"))) (![go.ChannelType go.sendrecv Status] "c")) (λ: <>,
      return: (Fst (chan.receive Status (![go.ChannelType go.sendrecv Status] "c")))
      )); (CommClause (RecvCase (go.StructType [

    ]) (![go.ChannelType go.sendrecv (go.StructType [

    ])] (StructFieldRef node "done"%go (![go.PointerType node] "n")))) (λ: "$recvVal",
      return: (CompositeLiteral Status (LiteralValue []))
      ))])).

(* go: node.go:579:16 *)
Definition node__ReportUnreachableⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "n" "id",
    exception_do (let: "n" := (GoAlloc (go.PointerType node) "n") in
    let: "id" := (GoAlloc go.uint64 "id") in
    SelectStmt (SelectStmtClauses None [(CommClause (SendCase raftpb.Message (![go.ChannelType go.sendrecv raftpb.Message] (StructFieldRef node "recvc"%go (![go.PointerType node] "n"))) (CompositeLiteral raftpb.Message (LiteralValue [KeyedElement (Some (KeyField "Type"%go)) (ElementExpression raftpb.MessageType raftpb.MsgUnreachable); KeyedElement (Some (KeyField "From"%go)) (ElementExpression go.uint64 (![go.uint64] "id"))]))) (λ: <>,
      do:  #()
      )); (CommClause (RecvCase (go.StructType [

    ]) (![go.ChannelType go.sendrecv (go.StructType [

    ])] (StructFieldRef node "done"%go (![go.PointerType node] "n")))) (λ: "$recvVal",
      do:  #()
      ))]);;;
    return: #()).

(* go: node.go:586:16 *)
Definition node__ReportSnapshotⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "n" "id" "status",
    exception_do (let: "n" := (GoAlloc (go.PointerType node) "n") in
    let: "status" := (GoAlloc SnapshotStatus "status") in
    let: "id" := (GoAlloc go.uint64 "id") in
    let: "rej" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := ((![SnapshotStatus] "status") =⟨go.int⟩ SnapshotFailure) in
    do:  ("rej" <-[go.bool] "$r0");;;
    SelectStmt (SelectStmtClauses None [(CommClause (SendCase raftpb.Message (![go.ChannelType go.sendrecv raftpb.Message] (StructFieldRef node "recvc"%go (![go.PointerType node] "n"))) (CompositeLiteral raftpb.Message (LiteralValue [KeyedElement (Some (KeyField "Type"%go)) (ElementExpression raftpb.MessageType raftpb.MsgSnapStatus); KeyedElement (Some (KeyField "From"%go)) (ElementExpression go.uint64 (![go.uint64] "id")); KeyedElement (Some (KeyField "Reject"%go)) (ElementExpression go.bool (![go.bool] "rej"))]))) (λ: <>,
      do:  #()
      )); (CommClause (RecvCase (go.StructType [

    ]) (![go.ChannelType go.sendrecv (go.StructType [

    ])] (StructFieldRef node "done"%go (![go.PointerType node] "n")))) (λ: "$recvVal",
      do:  #()
      ))]);;;
    return: #()).

(* go: node.go:595:16 *)
Definition node__TransferLeadershipⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "n" "ctx" "lead" "transferee",
    exception_do (let: "n" := (GoAlloc (go.PointerType node) "n") in
    let: "transferee" := (GoAlloc go.uint64 "transferee") in
    let: "lead" := (GoAlloc go.uint64 "lead") in
    let: "ctx" := (GoAlloc context.Context "ctx") in
    SelectStmt (SelectStmtClauses None [(CommClause (SendCase raftpb.Message (![go.ChannelType go.sendrecv raftpb.Message] (StructFieldRef node "recvc"%go (![go.PointerType node] "n"))) (CompositeLiteral raftpb.Message (LiteralValue [KeyedElement (Some (KeyField "Type"%go)) (ElementExpression raftpb.MessageType raftpb.MsgTransferLeader); KeyedElement (Some (KeyField "From"%go)) (ElementExpression go.uint64 (![go.uint64] "transferee")); KeyedElement (Some (KeyField "To"%go)) (ElementExpression go.uint64 (![go.uint64] "lead"))]))) (λ: <>,
      do:  #()
      )); (CommClause (RecvCase (go.StructType [

    ]) (![go.ChannelType go.sendrecv (go.StructType [

    ])] (StructFieldRef node "done"%go (![go.PointerType node] "n")))) (λ: "$recvVal",
      do:  #()
      )); (CommClause (RecvCase (go.StructType [

    ]) ((MethodResolve context.Context "Done"%go (![context.Context] "ctx")) #())) (λ: "$recvVal",
      do:  #()
      ))]);;;
    return: #()).

(* go: node.go:604:16 *)
Definition node__ForgetLeaderⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "n" "ctx",
    exception_do (let: "n" := (GoAlloc (go.PointerType node) "n") in
    let: "ctx" := (GoAlloc context.Context "ctx") in
    return: (let: "$a0" := (![context.Context] "ctx") in
     let: "$a1" := (CompositeLiteral raftpb.Message (LiteralValue [KeyedElement (Some (KeyField "Type"%go)) (ElementExpression raftpb.MessageType raftpb.MsgForgetLeader)])) in
     (MethodResolve (go.PointerType node) "step"%go (![go.PointerType node] "n")) "$a0" "$a1")).

(* go: node.go:608:16 *)
Definition node__ReadIndexⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "n" "ctx" "rctx",
    exception_do (let: "n" := (GoAlloc (go.PointerType node) "n") in
    let: "rctx" := (GoAlloc (go.SliceType go.byte) "rctx") in
    let: "ctx" := (GoAlloc context.Context "ctx") in
    return: (let: "$a0" := (![context.Context] "ctx") in
     let: "$a1" := (CompositeLiteral raftpb.Message (LiteralValue [KeyedElement (Some (KeyField "Type"%go)) (ElementExpression raftpb.MessageType raftpb.MsgReadIndex); KeyedElement (Some (KeyField "Entries"%go)) (ElementExpression (go.SliceType raftpb.Entry) (CompositeLiteral (go.SliceType raftpb.Entry) (LiteralValue [KeyedElement None (ElementLiteralValue [KeyedElement (Some (KeyField "Data"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] "rctx"))])])))])) in
     (MethodResolve (go.PointerType node) "step"%go (![go.PointerType node] "n")) "$a0" "$a1")).

(* go: raft.go:95:22 *)
Definition lockedRand__Intnⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "r" "n",
    exception_do (let: "r" := (GoAlloc (go.PointerType lockedRand) "r") in
    let: "n" := (GoAlloc go.int "n") in
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Lock"%go (StructFieldRef lockedRand "mu"%go (![go.PointerType lockedRand] "r"))) #());;;
    let: "v" := (GoAlloc (go.PointerType big.Int) (GoZeroVal (go.PointerType big.Int) #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![io.Reader] (GlobalVarAddr rand.Reader #())) in
    let: "$a1" := (let: "$a0" := (Convert go.int go.int64 (![go.int] "n")) in
    (FuncResolve big.NewInt [] #()) "$a0") in
    (FuncResolve rand.Int [] #()) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("v" <-[go.PointerType big.Int] "$r0");;;
    do:  "$r1";;;
    do:  ((MethodResolve (go.PointerType sync.Mutex) "Unlock"%go (StructFieldRef lockedRand "mu"%go (![go.PointerType lockedRand] "r"))) #());;;
    return: (Convert go.int64 go.int ((MethodResolve (go.PointerType big.Int) "Int64"%go (![go.PointerType big.Int] "v")) #()))).

(* go: raft.go:119:21 *)
Definition StateType__Stringⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "st" <>,
    exception_do (let: "st" := (GoAlloc StateType "st") in
    return: (![go.string] (IndexRef (go.ArrayType 4 go.string) (![go.ArrayType 4 go.string] (GlobalVarAddr stmap #()), Convert StateType go.int (![StateType] "st"))))).

(* go: raft.go:291:18 *)
Definition Config__validateⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "c" <>,
    exception_do (let: "c" := (GoAlloc (go.PointerType Config) "c") in
    (if: Convert go.untyped_bool go.bool ((![go.uint64] (StructFieldRef Config "ID"%go (![go.PointerType Config] "c"))) =⟨go.uint64⟩ None)
    then
      return: (let: "$a0" := #"cannot use none as id"%go in
       (FuncResolve errors.New [] #()) "$a0")
    else do:  #());;;
    (if: let: "$a0" := (![go.uint64] (StructFieldRef Config "ID"%go (![go.PointerType Config] "c"))) in
    (FuncResolve IsLocalMsgTarget [] #()) "$a0"
    then
      return: (let: "$a0" := #"cannot use local target as id"%go in
       (FuncResolve errors.New [] #()) "$a0")
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool ((![go.int] (StructFieldRef Config "HeartbeatTick"%go (![go.PointerType Config] "c"))) ≤⟨go.int⟩ #(W64 0))
    then
      return: (let: "$a0" := #"heartbeat tick must be greater than 0"%go in
       (FuncResolve errors.New [] #()) "$a0")
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool ((![go.int] (StructFieldRef Config "ElectionTick"%go (![go.PointerType Config] "c"))) ≤⟨go.int⟩ (![go.int] (StructFieldRef Config "HeartbeatTick"%go (![go.PointerType Config] "c"))))
    then
      return: (let: "$a0" := #"election tick must be greater than heartbeat tick"%go in
       (FuncResolve errors.New [] #()) "$a0")
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool ((![Storage] (StructFieldRef Config "Storage"%go (![go.PointerType Config] "c"))) =⟨go.InterfaceType [go.MethodElem "Entries"%go (go.Signature [go.uint64; go.uint64; go.uint64] false [go.SliceType raftpb.Entry; go.error]); go.MethodElem "FirstIndex"%go (go.Signature [] false [go.uint64; go.error]); go.MethodElem "InitialState"%go (go.Signature [] false [raftpb.HardState; raftpb.ConfState; go.error]); go.MethodElem "LastIndex"%go (go.Signature [] false [go.uint64; go.error]); go.MethodElem "Snapshot"%go (go.Signature [] false [raftpb.Snapshot; go.error]); go.MethodElem "Term"%go (go.Signature [go.uint64] false [go.uint64; go.error])]⟩ (Convert go.untyped_nil (go.InterfaceType [go.MethodElem "Entries"%go (go.Signature [go.uint64; go.uint64; go.uint64] false [go.SliceType raftpb.Entry; go.error]); go.MethodElem "FirstIndex"%go (go.Signature [] false [go.uint64; go.error]); go.MethodElem "InitialState"%go (go.Signature [] false [raftpb.HardState; raftpb.ConfState; go.error]); go.MethodElem "LastIndex"%go (go.Signature [] false [go.uint64; go.error]); go.MethodElem "Snapshot"%go (go.Signature [] false [raftpb.Snapshot; go.error]); go.MethodElem "Term"%go (go.Signature [go.uint64] false [go.uint64; go.error])]) UntypedNil))
    then
      return: (let: "$a0" := #"storage cannot be nil"%go in
       (FuncResolve errors.New [] #()) "$a0")
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] (StructFieldRef Config "MaxUncommittedEntriesSize"%go (![go.PointerType Config] "c"))) =⟨go.uint64⟩ #(W64 0))
    then
      let: "$r0" := (Convert go.untyped_int go.uint64 noLimit) in
      do:  ((StructFieldRef Config "MaxUncommittedEntriesSize"%go (![go.PointerType Config] "c")) <-[go.uint64] "$r0")
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] (StructFieldRef Config "MaxCommittedSizePerReady"%go (![go.PointerType Config] "c"))) =⟨go.uint64⟩ #(W64 0))
    then
      let: "$r0" := (![go.uint64] (StructFieldRef Config "MaxSizePerMsg"%go (![go.PointerType Config] "c"))) in
      do:  ((StructFieldRef Config "MaxCommittedSizePerReady"%go (![go.PointerType Config] "c")) <-[go.uint64] "$r0")
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool ((![go.int] (StructFieldRef Config "MaxInflightMsgs"%go (![go.PointerType Config] "c"))) ≤⟨go.int⟩ #(W64 0))
    then
      return: (let: "$a0" := #"max inflight messages must be greater than 0"%go in
       (FuncResolve errors.New [] #()) "$a0")
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] (StructFieldRef Config "MaxInflightBytes"%go (![go.PointerType Config] "c"))) =⟨go.uint64⟩ #(W64 0))
    then
      let: "$r0" := (Convert go.untyped_int go.uint64 noLimit) in
      do:  ((StructFieldRef Config "MaxInflightBytes"%go (![go.PointerType Config] "c")) <-[go.uint64] "$r0")
    else
      (if: Convert go.untyped_bool go.bool ((![go.uint64] (StructFieldRef Config "MaxInflightBytes"%go (![go.PointerType Config] "c"))) <⟨go.uint64⟩ (![go.uint64] (StructFieldRef Config "MaxSizePerMsg"%go (![go.PointerType Config] "c"))))
      then
        return: (let: "$a0" := #"max inflight bytes must be >= max message size"%go in
         (FuncResolve errors.New [] #()) "$a0")
      else do:  #()));;;
    (if: Convert go.untyped_bool go.bool ((![Logger] (StructFieldRef Config "Logger"%go (![go.PointerType Config] "c"))) =⟨go.InterfaceType [go.MethodElem "Debug"%go (go.Signature [go.SliceType (go.InterfaceType [])] true []); go.MethodElem "Debugf"%go (go.Signature [go.string; go.SliceType (go.InterfaceType [])] true []); go.MethodElem "Error"%go (go.Signature [go.SliceType (go.InterfaceType [])] true []); go.MethodElem "Errorf"%go (go.Signature [go.string; go.SliceType (go.InterfaceType [])] true []); go.MethodElem "Fatal"%go (go.Signature [go.SliceType (go.InterfaceType [])] true []); go.MethodElem "Fatalf"%go (go.Signature [go.string; go.SliceType (go.InterfaceType [])] true []); go.MethodElem "Info"%go (go.Signature [go.SliceType (go.InterfaceType [])] true []); go.MethodElem "Infof"%go (go.Signature [go.string; go.SliceType (go.InterfaceType [])] true []); go.MethodElem "Panic"%go (go.Signature [go.SliceType (go.InterfaceType [])] true []); go.MethodElem "Panicf"%go (go.Signature [go.string; go.SliceType (go.InterfaceType [])] true []); go.MethodElem "Warning"%go (go.Signature [go.SliceType (go.InterfaceType [])] true []); go.MethodElem "Warningf"%go (go.Signature [go.string; go.SliceType (go.InterfaceType [])] true [])]⟩ (Convert go.untyped_nil (go.InterfaceType [go.MethodElem "Debug"%go (go.Signature [go.SliceType (go.InterfaceType [])] true []); go.MethodElem "Debugf"%go (go.Signature [go.string; go.SliceType (go.InterfaceType [])] true []); go.MethodElem "Error"%go (go.Signature [go.SliceType (go.InterfaceType [])] true []); go.MethodElem "Errorf"%go (go.Signature [go.string; go.SliceType (go.InterfaceType [])] true []); go.MethodElem "Fatal"%go (go.Signature [go.SliceType (go.InterfaceType [])] true []); go.MethodElem "Fatalf"%go (go.Signature [go.string; go.SliceType (go.InterfaceType [])] true []); go.MethodElem "Info"%go (go.Signature [go.SliceType (go.InterfaceType [])] true []); go.MethodElem "Infof"%go (go.Signature [go.string; go.SliceType (go.InterfaceType [])] true []); go.MethodElem "Panic"%go (go.Signature [go.SliceType (go.InterfaceType [])] true []); go.MethodElem "Panicf"%go (go.Signature [go.string; go.SliceType (go.InterfaceType [])] true []); go.MethodElem "Warning"%go (go.Signature [go.SliceType (go.InterfaceType [])] true []); go.MethodElem "Warningf"%go (go.Signature [go.string; go.SliceType (go.InterfaceType [])] true [])]) UntypedNil))
    then
      let: "$r0" := ((FuncResolve getLogger [] #()) #()) in
      do:  ((StructFieldRef Config "Logger"%go (![go.PointerType Config] "c")) <-[Logger] "$r0")
    else do:  #());;;
    (if: ((![ReadOnlyOption] (StructFieldRef Config "ReadOnlyOption"%go (![go.PointerType Config] "c"))) =⟨go.int⟩ ReadOnlyLeaseBased) && (~ (![go.bool] (StructFieldRef Config "CheckQuorum"%go (![go.PointerType Config] "c"))))
    then
      return: (let: "$a0" := #"CheckQuorum must be enabled when ReadOnlyOption is ReadOnlyLeaseBased"%go in
       (FuncResolve errors.New [] #()) "$a0")
    else do:  #());;;
    return: (Convert go.untyped_nil go.error UntypedNil)).

(* go: raft.go:437:6 *)
Definition newRaftⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "c",
    exception_do (let: "c" := (GoAlloc (go.PointerType Config) "c") in
    (let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
    let: "$r0" := ((MethodResolve (go.PointerType Config) "validate"%go (![go.PointerType Config] "c")) #()) in
    do:  ("err" <-[go.error] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.error] "err") ≠⟨go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]⟩ (Convert go.untyped_nil (go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]) UntypedNil))
    then
      do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) ((MethodResolve go.error "Error"%go (![go.error] "err")) #())) in
      (FuncResolve go.panic [] #()) "$a0")
    else do:  #()));;;
    let: "raftlog" := (GoAlloc (go.PointerType raftLog) (GoZeroVal (go.PointerType raftLog) #())) in
    let: "$r0" := (let: "$a0" := (![Storage] (StructFieldRef Config "Storage"%go (![go.PointerType Config] "c"))) in
    let: "$a1" := (![Logger] (StructFieldRef Config "Logger"%go (![go.PointerType Config] "c"))) in
    let: "$a2" := (![go.uint64] (StructFieldRef Config "MaxCommittedSizePerReady"%go (![go.PointerType Config] "c"))) in
    (FuncResolve newLogWithSize [] #()) "$a0" "$a1" "$a2") in
    do:  ("raftlog" <-[go.PointerType raftLog] "$r0");;;
    let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
    let: "cs" := (GoAlloc raftpb.ConfState (GoZeroVal raftpb.ConfState #())) in
    let: "hs" := (GoAlloc raftpb.HardState (GoZeroVal raftpb.HardState #())) in
    let: (("$ret0", "$ret1"), "$ret2") := ((MethodResolve Storage "InitialState"%go (![Storage] (StructFieldRef Config "Storage"%go (![go.PointerType Config] "c")))) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("hs" <-[raftpb.HardState] "$r0");;;
    do:  ("cs" <-[raftpb.ConfState] "$r1");;;
    do:  ("err" <-[go.error] "$r2");;;
    (if: Convert go.untyped_bool go.bool ((![go.error] "err") ≠⟨go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]⟩ (Convert go.untyped_nil (go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]) UntypedNil))
    then
      do:  (let: "$a0" := (Convert go.error (go.InterfaceType []) (![go.error] "err")) in
      (FuncResolve go.panic [] #()) "$a0")
    else do:  #());;;
    let: "r" := (GoAlloc (go.PointerType raft) (GoZeroVal (go.PointerType raft) #())) in
    let: "$r0" := (GoAlloc raft (CompositeLiteral raft (LiteralValue [KeyedElement (Some (KeyField "id"%go)) (ElementExpression go.uint64 (![go.uint64] (StructFieldRef Config "ID"%go (![go.PointerType Config] "c")))); KeyedElement (Some (KeyField "lead"%go)) (ElementExpression go.uint64 None); KeyedElement (Some (KeyField "isLearner"%go)) (ElementExpression go.bool #false); KeyedElement (Some (KeyField "raftLog"%go)) (ElementExpression (go.PointerType raftLog) (![go.PointerType raftLog] "raftlog")); KeyedElement (Some (KeyField "maxMsgSize"%go)) (ElementExpression entryEncodingSize (![go.uint64] (StructFieldRef Config "MaxSizePerMsg"%go (![go.PointerType Config] "c")))); KeyedElement (Some (KeyField "maxUncommittedSize"%go)) (ElementExpression entryPayloadSize (![go.uint64] (StructFieldRef Config "MaxUncommittedEntriesSize"%go (![go.PointerType Config] "c")))); KeyedElement (Some (KeyField "trk"%go)) (ElementExpression tracker.ProgressTracker (let: "$a0" := (![go.int] (StructFieldRef Config "MaxInflightMsgs"%go (![go.PointerType Config] "c"))) in
     let: "$a1" := (![go.uint64] (StructFieldRef Config "MaxInflightBytes"%go (![go.PointerType Config] "c"))) in
     (FuncResolve tracker.MakeProgressTracker [] #()) "$a0" "$a1")); KeyedElement (Some (KeyField "electionTimeout"%go)) (ElementExpression go.int (![go.int] (StructFieldRef Config "ElectionTick"%go (![go.PointerType Config] "c")))); KeyedElement (Some (KeyField "heartbeatTimeout"%go)) (ElementExpression go.int (![go.int] (StructFieldRef Config "HeartbeatTick"%go (![go.PointerType Config] "c")))); KeyedElement (Some (KeyField "logger"%go)) (ElementExpression Logger (![Logger] (StructFieldRef Config "Logger"%go (![go.PointerType Config] "c")))); KeyedElement (Some (KeyField "checkQuorum"%go)) (ElementExpression go.bool (![go.bool] (StructFieldRef Config "CheckQuorum"%go (![go.PointerType Config] "c")))); KeyedElement (Some (KeyField "preVote"%go)) (ElementExpression go.bool (![go.bool] (StructFieldRef Config "PreVote"%go (![go.PointerType Config] "c")))); KeyedElement (Some (KeyField "readOnly"%go)) (ElementExpression (go.PointerType readOnly) (let: "$a0" := (![ReadOnlyOption] (StructFieldRef Config "ReadOnlyOption"%go (![go.PointerType Config] "c"))) in
     (FuncResolve newReadOnly [] #()) "$a0")); KeyedElement (Some (KeyField "disableProposalForwarding"%go)) (ElementExpression go.bool (![go.bool] (StructFieldRef Config "DisableProposalForwarding"%go (![go.PointerType Config] "c")))); KeyedElement (Some (KeyField "disableConfChangeValidation"%go)) (ElementExpression go.bool (![go.bool] (StructFieldRef Config "DisableConfChangeValidation"%go (![go.PointerType Config] "c")))); KeyedElement (Some (KeyField "stepDownOnRemoval"%go)) (ElementExpression go.bool (![go.bool] (StructFieldRef Config "StepDownOnRemoval"%go (![go.PointerType Config] "c")))); KeyedElement (Some (KeyField "traceLogger"%go)) (ElementExpression TraceLogger (![TraceLogger] (StructFieldRef Config "TraceLogger"%go (![go.PointerType Config] "c"))))]))) in
    do:  ("r" <-[go.PointerType raft] "$r0");;;
    do:  (let: "$a0" := (![go.PointerType raft] "r") in
    (FuncResolve traceInitState [] #()) "$a0");;;
    let: "lastID" := (GoAlloc entryID (GoZeroVal entryID #())) in
    let: "$r0" := ((MethodResolve (go.PointerType raftLog) "lastEntryID"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r")))) #()) in
    do:  ("lastID" <-[entryID] "$r0");;;
    let: "trk" := (GoAlloc tracker.ProgressMap (GoZeroVal tracker.ProgressMap #())) in
    let: "cfg" := (GoAlloc tracker.Config (GoZeroVal tracker.Config #())) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (CompositeLiteral confchange.Changer (LiteralValue [KeyedElement (Some (KeyField "Tracker"%go)) (ElementExpression tracker.ProgressTracker (![tracker.ProgressTracker] (StructFieldRef raft "trk"%go (![go.PointerType raft] "r")))); KeyedElement (Some (KeyField "LastIndex"%go)) (ElementExpression go.uint64 (![go.uint64] (StructFieldRef entryID "index"%go "lastID")))])) in
    let: "$a1" := (![raftpb.ConfState] "cs") in
    (FuncResolve confchange.Restore [] #()) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("cfg" <-[tracker.Config] "$r0");;;
    do:  ("trk" <-[tracker.ProgressMap] "$r1");;;
    do:  ("err" <-[go.error] "$r2");;;
    (if: Convert go.untyped_bool go.bool ((![go.error] "err") ≠⟨go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]⟩ (Convert go.untyped_nil (go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]) UntypedNil))
    then
      do:  (let: "$a0" := (Convert go.error (go.InterfaceType []) (![go.error] "err")) in
      (FuncResolve go.panic [] #()) "$a0")
    else do:  #());;;
    do:  (let: "$a0" := (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r"))) in
    let: "$a1" := (![raftpb.ConfState] "cs") in
    let: "$a2" := (let: "$a0" := (![tracker.Config] "cfg") in
    let: "$a1" := (![tracker.ProgressMap] "trk") in
    (MethodResolve (go.PointerType raft) "switchToConfig"%go (![go.PointerType raft] "r")) "$a0" "$a1") in
    (FuncResolve assertConfStatesEquivalent [] #()) "$a0" "$a1" "$a2");;;
    (if: (~ (let: "$a0" := (![raftpb.HardState] "hs") in
    (FuncResolve IsEmptyHardState [] #()) "$a0"))
    then
      do:  (let: "$a0" := (![raftpb.HardState] "hs") in
      (MethodResolve (go.PointerType raft) "loadState"%go (![go.PointerType raft] "r")) "$a0")
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] (StructFieldRef Config "Applied"%go (![go.PointerType Config] "c"))) >⟨go.uint64⟩ #(W64 0))
    then
      do:  (let: "$a0" := (![go.uint64] (StructFieldRef Config "Applied"%go (![go.PointerType Config] "c"))) in
      let: "$a1" := #(W64 0) in
      (MethodResolve (go.PointerType raftLog) "appliedTo"%go (![go.PointerType raftLog] "raftlog")) "$a0" "$a1")
    else do:  #());;;
    do:  (let: "$a0" := (![go.uint64] (StructFieldRef raft "Term"%go (![go.PointerType raft] "r"))) in
    let: "$a1" := None in
    (MethodResolve (go.PointerType raft) "becomeFollower"%go (![go.PointerType raft] "r")) "$a0" "$a1");;;
    let: "nodesStrs" := (GoAlloc (go.SliceType go.string) (GoZeroVal (go.SliceType go.string) #())) in
    let: "$range" := ((MethodResolve (go.PointerType tracker.ProgressTracker) "VoterNodes"%go (StructFieldRef raft "trk"%go (![go.PointerType raft] "r"))) #()) in
    (let: "n" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    slice.for_range go.uint64 "$range" (λ: "$key" "$value",
      do:  ("n" <-[go.uint64] "$value");;;
      do:  "$key";;;
      let: "$r0" := (let: "$a0" := (![go.SliceType go.string] "nodesStrs") in
      let: "$a1" := ((let: "$sl0" := (let: "$a0" := #"%x"%go in
      let: "$a1" := ((let: "$sl0" := (Convert go.uint64 go.any (![go.uint64] "n")) in
      CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0")]))) in
      (FuncResolve fmt.Sprintf [] #()) "$a0" "$a1") in
      CompositeLiteral (go.SliceType go.string) (LiteralValue [KeyedElement None (ElementExpression go.string "$sl0")]))) in
      (FuncResolve go.append [go.SliceType go.string] #()) "$a0" "$a1") in
      do:  ("nodesStrs" <-[go.SliceType go.string] "$r0")));;;
    do:  (let: "$a0" := #"newRaft %x [peers: [%s], term: %d, commit: %d, applied: %d, lastindex: %d, lastterm: %d]"%go in
    let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))) in
    let: "$sl1" := (Convert go.string (go.InterfaceType []) (let: "$a0" := (![go.SliceType go.string] "nodesStrs") in
    let: "$a1" := #","%go in
    (FuncResolve strings.Join [] #()) "$a0" "$a1")) in
    let: "$sl2" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "Term"%go (![go.PointerType raft] "r")))) in
    let: "$sl3" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raftLog "committed"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r")))))) in
    let: "$sl4" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raftLog "applied"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r")))))) in
    let: "$sl5" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef entryID "index"%go "lastID"))) in
    let: "$sl6" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef entryID "term"%go "lastID"))) in
    CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl2"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl3"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl4"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl5"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl6")]))) in
    (MethodResolve Logger "Infof"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0" "$a1");;;
    return: (![go.PointerType raft] "r")).

(* go: raft.go:498:16 *)
Definition raft__hasLeaderⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "r" <>,
    exception_do (let: "r" := (GoAlloc (go.PointerType raft) "r") in
    return: ((![go.uint64] (StructFieldRef raft "lead"%go (![go.PointerType raft] "r"))) ≠⟨go.uint64⟩ None)).

(* go: raft.go:500:16 *)
Definition raft__softStateⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "r" <>,
    exception_do (let: "r" := (GoAlloc (go.PointerType raft) "r") in
    return: (CompositeLiteral SoftState (LiteralValue [KeyedElement (Some (KeyField "Lead"%go)) (ElementExpression go.uint64 (![go.uint64] (StructFieldRef raft "lead"%go (![go.PointerType raft] "r")))); KeyedElement (Some (KeyField "RaftState"%go)) (ElementExpression StateType (![StateType] (StructFieldRef raft "state"%go (![go.PointerType raft] "r"))))]))).

(* go: raft.go:502:16 *)
Definition raft__hardStateⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "r" <>,
    exception_do (let: "r" := (GoAlloc (go.PointerType raft) "r") in
    return: (CompositeLiteral raftpb.HardState (LiteralValue [KeyedElement (Some (KeyField "Term"%go)) (ElementExpression go.uint64 (![go.uint64] (StructFieldRef raft "Term"%go (![go.PointerType raft] "r")))); KeyedElement (Some (KeyField "Vote"%go)) (ElementExpression go.uint64 (![go.uint64] (StructFieldRef raft "Vote"%go (![go.PointerType raft] "r")))); KeyedElement (Some (KeyField "Commit"%go)) (ElementExpression go.uint64 (![go.uint64] (StructFieldRef raftLog "committed"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r"))))))]))).

(* send schedules persisting state to a stable storage and AFTER that
   sending the message (as part of next Ready message processing).

   go: raft.go:512:16 *)
Definition raft__sendⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "r" "m",
    exception_do (let: "r" := (GoAlloc (go.PointerType raft) "r") in
    let: "m" := (GoAlloc raftpb.Message "m") in
    (if: Convert go.untyped_bool go.bool ((![go.uint64] (StructFieldRef raftpb.Message "From"%go "m")) =⟨go.uint64⟩ None)
    then
      let: "$r0" := (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r"))) in
      do:  ((StructFieldRef raftpb.Message "From"%go "m") <-[go.uint64] "$r0")
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool (((((![raftpb.MessageType] (StructFieldRef raftpb.Message "Type"%go "m")) =⟨go.int32⟩ raftpb.MsgVote) || ((![raftpb.MessageType] (StructFieldRef raftpb.Message "Type"%go "m")) =⟨go.int32⟩ raftpb.MsgVoteResp)) || ((![raftpb.MessageType] (StructFieldRef raftpb.Message "Type"%go "m")) =⟨go.int32⟩ raftpb.MsgPreVote)) || ((![raftpb.MessageType] (StructFieldRef raftpb.Message "Type"%go "m")) =⟨go.int32⟩ raftpb.MsgPreVoteResp))
    then
      (if: Convert go.untyped_bool go.bool ((![go.uint64] (StructFieldRef raftpb.Message "Term"%go "m")) =⟨go.uint64⟩ #(W64 0))
      then
        do:  (let: "$a0" := #"term should be set when sending %s"%go in
        let: "$a1" := ((let: "$sl0" := (Convert raftpb.MessageType (go.InterfaceType []) (![raftpb.MessageType] (StructFieldRef raftpb.Message "Type"%go "m"))) in
        CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0")]))) in
        (MethodResolve Logger "Panicf"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0" "$a1")
      else do:  #())
    else
      (if: Convert go.untyped_bool go.bool ((![go.uint64] (StructFieldRef raftpb.Message "Term"%go "m")) ≠⟨go.uint64⟩ #(W64 0))
      then
        do:  (let: "$a0" := #"term should not be set when sending %s (was %d)"%go in
        let: "$a1" := ((let: "$sl0" := (Convert raftpb.MessageType (go.InterfaceType []) (![raftpb.MessageType] (StructFieldRef raftpb.Message "Type"%go "m"))) in
        let: "$sl1" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raftpb.Message "Term"%go "m"))) in
        CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1")]))) in
        (MethodResolve Logger "Panicf"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0" "$a1")
      else do:  #());;;
      (if: Convert go.untyped_bool go.bool (((![raftpb.MessageType] (StructFieldRef raftpb.Message "Type"%go "m")) ≠⟨go.int32⟩ raftpb.MsgProp) && ((![raftpb.MessageType] (StructFieldRef raftpb.Message "Type"%go "m")) ≠⟨go.int32⟩ raftpb.MsgReadIndex))
      then
        let: "$r0" := (![go.uint64] (StructFieldRef raft "Term"%go (![go.PointerType raft] "r"))) in
        do:  ((StructFieldRef raftpb.Message "Term"%go "m") <-[go.uint64] "$r0")
      else do:  #()));;;
    (if: Convert go.untyped_bool go.bool ((((![raftpb.MessageType] (StructFieldRef raftpb.Message "Type"%go "m")) =⟨go.int32⟩ raftpb.MsgAppResp) || ((![raftpb.MessageType] (StructFieldRef raftpb.Message "Type"%go "m")) =⟨go.int32⟩ raftpb.MsgVoteResp)) || ((![raftpb.MessageType] (StructFieldRef raftpb.Message "Type"%go "m")) =⟨go.int32⟩ raftpb.MsgPreVoteResp))
    then
      let: "$r0" := (let: "$a0" := (![go.SliceType raftpb.Message] (StructFieldRef raft "msgsAfterAppend"%go (![go.PointerType raft] "r"))) in
      let: "$a1" := ((let: "$sl0" := (![raftpb.Message] "m") in
      CompositeLiteral (go.SliceType raftpb.Message) (LiteralValue [KeyedElement None (ElementExpression raftpb.Message "$sl0")]))) in
      (FuncResolve go.append [go.SliceType raftpb.Message] #()) "$a0" "$a1") in
      do:  ((StructFieldRef raft "msgsAfterAppend"%go (![go.PointerType raft] "r")) <-[go.SliceType raftpb.Message] "$r0");;;
      do:  (let: "$a0" := (![go.PointerType raft] "r") in
      let: "$a1" := "m" in
      (FuncResolve traceSendMessage [] #()) "$a0" "$a1")
    else
      (if: Convert go.untyped_bool go.bool ((![go.uint64] (StructFieldRef raftpb.Message "To"%go "m")) =⟨go.uint64⟩ (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r"))))
      then
        do:  (let: "$a0" := #"message should not be self-addressed when sending %s"%go in
        let: "$a1" := ((let: "$sl0" := (Convert raftpb.MessageType (go.InterfaceType []) (![raftpb.MessageType] (StructFieldRef raftpb.Message "Type"%go "m"))) in
        CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0")]))) in
        (MethodResolve Logger "Panicf"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0" "$a1")
      else do:  #());;;
      let: "$r0" := (let: "$a0" := (![go.SliceType raftpb.Message] (StructFieldRef raft "msgs"%go (![go.PointerType raft] "r"))) in
      let: "$a1" := ((let: "$sl0" := (![raftpb.Message] "m") in
      CompositeLiteral (go.SliceType raftpb.Message) (LiteralValue [KeyedElement None (ElementExpression raftpb.Message "$sl0")]))) in
      (FuncResolve go.append [go.SliceType raftpb.Message] #()) "$a0" "$a1") in
      do:  ((StructFieldRef raft "msgs"%go (![go.PointerType raft] "r")) <-[go.SliceType raftpb.Message] "$r0");;;
      do:  (let: "$a0" := (![go.PointerType raft] "r") in
      let: "$a1" := "m" in
      (FuncResolve traceSendMessage [] #()) "$a0" "$a1"));;;
    return: #()).

(* sendAppend sends an append RPC with new entries (if any) and the
   current commit index to the given peer.

   go: raft.go:603:16 *)
Definition raft__sendAppendⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "r" "to",
    exception_do (let: "r" := (GoAlloc (go.PointerType raft) "r") in
    let: "to" := (GoAlloc go.uint64 "to") in
    do:  (let: "$a0" := (![go.uint64] "to") in
    let: "$a1" := #true in
    (MethodResolve (go.PointerType raft) "maybeSendAppend"%go (![go.PointerType raft] "r")) "$a0" "$a1");;;
    return: #()).

(* maybeSendAppend sends an append RPC with new entries to the given peer,
   if necessary. Returns true if a message was sent. The sendIfEmpty
   argument controls whether messages with no entries will be sent
   ("empty" messages are useful to convey updated Commit indexes, but
   are undesirable when we're sending multiple messages in a batch).

   TODO(pav-kv): make invocation of maybeSendAppend stateless. The Progress
   struct contains all the state necessary for deciding whether to send a
   message.

   go: raft.go:616:16 *)
Definition raft__maybeSendAppendⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "r" "to" "sendIfEmpty",
    exception_do (let: "r" := (GoAlloc (go.PointerType raft) "r") in
    let: "sendIfEmpty" := (GoAlloc go.bool "sendIfEmpty") in
    let: "to" := (GoAlloc go.uint64 "to") in
    let: "pr" := (GoAlloc (go.PointerType tracker.Progress) (GoZeroVal (go.PointerType tracker.Progress) #())) in
    let: "$r0" := (map.lookup1 go.uint64 (go.PointerType tracker.Progress) (![tracker.ProgressMap] (StructFieldRef tracker.ProgressTracker "Progress"%go (StructFieldRef raft "trk"%go (![go.PointerType raft] "r")))) (![go.uint64] "to")) in
    do:  ("pr" <-[go.PointerType tracker.Progress] "$r0");;;
    (if: (MethodResolve (go.PointerType tracker.Progress) "IsPaused"%go (![go.PointerType tracker.Progress] "pr")) #()
    then return: (#false)
    else do:  #());;;
    let: "prevIndex" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := ((![go.uint64] (StructFieldRef tracker.Progress "Next"%go (![go.PointerType tracker.Progress] "pr"))) -⟨go.uint64⟩ #(W64 1)) in
    do:  ("prevIndex" <-[go.uint64] "$r0");;;
    let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
    let: "prevTerm" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.uint64] "prevIndex") in
    (MethodResolve (go.PointerType raftLog) "term"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r")))) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("prevTerm" <-[go.uint64] "$r0");;;
    do:  ("err" <-[go.error] "$r1");;;
    (if: Convert go.untyped_bool go.bool ((![go.error] "err") ≠⟨go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]⟩ (Convert go.untyped_nil (go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]) UntypedNil))
    then
      return: (let: "$a0" := (![go.uint64] "to") in
       let: "$a1" := (![go.PointerType tracker.Progress] "pr") in
       (MethodResolve (go.PointerType raft) "maybeSendSnapshot"%go (![go.PointerType raft] "r")) "$a0" "$a1")
    else do:  #());;;
    let: "ents" := (GoAlloc (go.SliceType raftpb.Entry) (GoZeroVal (go.SliceType raftpb.Entry) #())) in
    (if: ((![tracker.StateType] (StructFieldRef tracker.Progress "State"%go (![go.PointerType tracker.Progress] "pr"))) ≠⟨go.uint64⟩ tracker.StateReplicate) || (~ ((MethodResolve (go.PointerType tracker.Inflights) "Full"%go (![go.PointerType tracker.Inflights] (StructFieldRef tracker.Progress "Inflights"%go (![go.PointerType tracker.Progress] "pr")))) #()))
    then
      let: ("$ret0", "$ret1") := (let: "$a0" := (![go.uint64] (StructFieldRef tracker.Progress "Next"%go (![go.PointerType tracker.Progress] "pr"))) in
      let: "$a1" := (![entryEncodingSize] (StructFieldRef raft "maxMsgSize"%go (![go.PointerType raft] "r"))) in
      (MethodResolve (go.PointerType raftLog) "entries"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r")))) "$a0" "$a1") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("ents" <-[go.SliceType raftpb.Entry] "$r0");;;
      do:  ("err" <-[go.error] "$r1")
    else do:  #());;;
    (if: ((let: "$a0" := (![go.SliceType raftpb.Entry] "ents") in
    (FuncResolve go.len [go.SliceType raftpb.Entry] #()) "$a0") =⟨go.int⟩ #(W64 0)) && (~ (![go.bool] "sendIfEmpty"))
    then return: (#false)
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool ((![go.error] "err") ≠⟨go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]⟩ (Convert go.untyped_nil (go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]) UntypedNil))
    then
      return: (let: "$a0" := (![go.uint64] "to") in
       let: "$a1" := (![go.PointerType tracker.Progress] "pr") in
       (MethodResolve (go.PointerType raft) "maybeSendSnapshot"%go (![go.PointerType raft] "r")) "$a0" "$a1")
    else do:  #());;;
    do:  (let: "$a0" := (CompositeLiteral raftpb.Message (LiteralValue [KeyedElement (Some (KeyField "To"%go)) (ElementExpression go.uint64 (![go.uint64] "to")); KeyedElement (Some (KeyField "Type"%go)) (ElementExpression raftpb.MessageType raftpb.MsgApp); KeyedElement (Some (KeyField "Index"%go)) (ElementExpression go.uint64 (![go.uint64] "prevIndex")); KeyedElement (Some (KeyField "LogTerm"%go)) (ElementExpression go.uint64 (![go.uint64] "prevTerm")); KeyedElement (Some (KeyField "Entries"%go)) (ElementExpression (go.SliceType raftpb.Entry) (![go.SliceType raftpb.Entry] "ents")); KeyedElement (Some (KeyField "Commit"%go)) (ElementExpression go.uint64 (![go.uint64] (StructFieldRef raftLog "committed"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r"))))))])) in
    (MethodResolve (go.PointerType raft) "send"%go (![go.PointerType raft] "r")) "$a0");;;
    do:  (let: "$a0" := (let: "$a0" := (![go.SliceType raftpb.Entry] "ents") in
    (FuncResolve go.len [go.SliceType raftpb.Entry] #()) "$a0") in
    let: "$a1" := (let: "$a0" := (![go.SliceType raftpb.Entry] "ents") in
    (FuncResolve payloadsSize [] #()) "$a0") in
    (MethodResolve (go.PointerType tracker.Progress) "SentEntries"%go (![go.PointerType tracker.Progress] "pr")) "$a0" "$a1");;;
    do:  (let: "$a0" := (![go.uint64] (StructFieldRef raftLog "committed"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r"))))) in
    (MethodResolve (go.PointerType tracker.Progress) "SentCommit"%go (![go.PointerType tracker.Progress] "pr")) "$a0");;;
    return: (#true)).

(* maybeSendSnapshot fetches a snapshot from Storage, and sends it to the given
   node. Returns true iff the snapshot message has been emitted successfully.

   go: raft.go:664:16 *)
Definition raft__maybeSendSnapshotⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "r" "to" "pr",
    exception_do (let: "r" := (GoAlloc (go.PointerType raft) "r") in
    let: "pr" := (GoAlloc (go.PointerType tracker.Progress) "pr") in
    let: "to" := (GoAlloc go.uint64 "to") in
    (if: (~ (![go.bool] (StructFieldRef tracker.Progress "RecentActive"%go (![go.PointerType tracker.Progress] "pr"))))
    then
      do:  (let: "$a0" := #"ignore sending snapshot to %x since it is not recently active"%go in
      let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] "to")) in
      CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0")]))) in
      (MethodResolve Logger "Debugf"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0" "$a1");;;
      return: (#false)
    else do:  #());;;
    let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
    let: "snapshot" := (GoAlloc raftpb.Snapshot (GoZeroVal raftpb.Snapshot #())) in
    let: ("$ret0", "$ret1") := ((MethodResolve (go.PointerType raftLog) "snapshot"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r")))) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("snapshot" <-[raftpb.Snapshot] "$r0");;;
    do:  ("err" <-[go.error] "$r1");;;
    (if: Convert go.untyped_bool go.bool ((![go.error] "err") ≠⟨go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]⟩ (Convert go.untyped_nil (go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]) UntypedNil))
    then
      (if: Convert go.untyped_bool go.bool ((![go.error] "err") =⟨go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]⟩ (![go.error] (GlobalVarAddr ErrSnapshotTemporarilyUnavailable #())))
      then
        do:  (let: "$a0" := #"%x failed to send snapshot to %x because snapshot is temporarily unavailable"%go in
        let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))) in
        let: "$sl1" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] "to")) in
        CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1")]))) in
        (MethodResolve Logger "Debugf"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0" "$a1");;;
        return: (#false)
      else do:  #());;;
      do:  (let: "$a0" := (Convert go.error (go.InterfaceType []) (![go.error] "err")) in
      (FuncResolve go.panic [] #()) "$a0")
    else do:  #());;;
    (if: let: "$a0" := (![raftpb.Snapshot] "snapshot") in
    (FuncResolve IsEmptySnap [] #()) "$a0"
    then
      do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"need non-empty snapshot"%go) in
      (FuncResolve go.panic [] #()) "$a0")
    else do:  #());;;
    let: "sterm" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "sindex" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (![go.uint64] (StructFieldRef raftpb.SnapshotMetadata "Index"%go (StructFieldRef raftpb.Snapshot "Metadata"%go "snapshot"))) in
    let: "$r1" := (![go.uint64] (StructFieldRef raftpb.SnapshotMetadata "Term"%go (StructFieldRef raftpb.Snapshot "Metadata"%go "snapshot"))) in
    do:  ("sindex" <-[go.uint64] "$r0");;;
    do:  ("sterm" <-[go.uint64] "$r1");;;
    do:  (let: "$a0" := #"%x [firstindex: %d, commit: %d] sent snapshot[index: %d, term: %d] to %x [%s]"%go in
    let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))) in
    let: "$sl1" := (Convert go.uint64 (go.InterfaceType []) ((MethodResolve (go.PointerType raftLog) "firstIndex"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r")))) #())) in
    let: "$sl2" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raftLog "committed"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r")))))) in
    let: "$sl3" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] "sindex")) in
    let: "$sl4" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] "sterm")) in
    let: "$sl5" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] "to")) in
    let: "$sl6" := (Convert (go.PointerType tracker.Progress) (go.InterfaceType []) (![go.PointerType tracker.Progress] "pr")) in
    CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl2"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl3"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl4"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl5"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl6")]))) in
    (MethodResolve Logger "Debugf"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0" "$a1");;;
    do:  (let: "$a0" := (![go.uint64] "sindex") in
    (MethodResolve (go.PointerType tracker.Progress) "BecomeSnapshot"%go (![go.PointerType tracker.Progress] "pr")) "$a0");;;
    do:  (let: "$a0" := #"%x paused sending replication messages to %x [%s]"%go in
    let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))) in
    let: "$sl1" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] "to")) in
    let: "$sl2" := (Convert (go.PointerType tracker.Progress) (go.InterfaceType []) (![go.PointerType tracker.Progress] "pr")) in
    CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl2")]))) in
    (MethodResolve Logger "Debugf"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0" "$a1");;;
    do:  (let: "$a0" := (CompositeLiteral raftpb.Message (LiteralValue [KeyedElement (Some (KeyField "To"%go)) (ElementExpression go.uint64 (![go.uint64] "to")); KeyedElement (Some (KeyField "Type"%go)) (ElementExpression raftpb.MessageType raftpb.MsgSnap); KeyedElement (Some (KeyField "Snapshot"%go)) (ElementExpression (go.PointerType raftpb.Snapshot) "snapshot")])) in
    (MethodResolve (go.PointerType raft) "send"%go (![go.PointerType raft] "r")) "$a0");;;
    return: (#true)).

(* sendHeartbeat sends a heartbeat RPC to the given peer.

   go: raft.go:692:16 *)
Definition raft__sendHeartbeatⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "r" "to" "ctx",
    exception_do (let: "r" := (GoAlloc (go.PointerType raft) "r") in
    let: "ctx" := (GoAlloc (go.SliceType go.byte) "ctx") in
    let: "to" := (GoAlloc go.uint64 "to") in
    let: "pr" := (GoAlloc (go.PointerType tracker.Progress) (GoZeroVal (go.PointerType tracker.Progress) #())) in
    let: "$r0" := (map.lookup1 go.uint64 (go.PointerType tracker.Progress) (![tracker.ProgressMap] (StructFieldRef tracker.ProgressTracker "Progress"%go (StructFieldRef raft "trk"%go (![go.PointerType raft] "r")))) (![go.uint64] "to")) in
    do:  ("pr" <-[go.PointerType tracker.Progress] "$r0");;;
    let: "commit" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (let: "$a0" := (![go.uint64] (StructFieldRef tracker.Progress "Match"%go (![go.PointerType tracker.Progress] "pr"))) in
    let: "$a1" := (![go.uint64] (StructFieldRef raftLog "committed"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r"))))) in
    (FuncResolve go.min [go.uint64; go.uint64] #()) "$a0" "$a1") in
    do:  ("commit" <-[go.uint64] "$r0");;;
    do:  (let: "$a0" := (CompositeLiteral raftpb.Message (LiteralValue [KeyedElement (Some (KeyField "To"%go)) (ElementExpression go.uint64 (![go.uint64] "to")); KeyedElement (Some (KeyField "Type"%go)) (ElementExpression raftpb.MessageType raftpb.MsgHeartbeat); KeyedElement (Some (KeyField "Commit"%go)) (ElementExpression go.uint64 (![go.uint64] "commit")); KeyedElement (Some (KeyField "Context"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] "ctx"))])) in
    (MethodResolve (go.PointerType raft) "send"%go (![go.PointerType raft] "r")) "$a0");;;
    do:  (let: "$a0" := (![go.uint64] "commit") in
    (MethodResolve (go.PointerType tracker.Progress) "SentCommit"%go (![go.PointerType tracker.Progress] "pr")) "$a0");;;
    return: #()).

(* bcastAppend sends RPC, with entries to all peers that are not up-to-date
   according to the progress recorded in r.trk.

   go: raft.go:712:16 *)
Definition raft__bcastAppendⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "r" <>,
    exception_do (let: "r" := (GoAlloc (go.PointerType raft) "r") in
    do:  (let: "$a0" := (λ: "id" <>,
      exception_do (let: "id" := (GoAlloc go.uint64 "id") in
      (if: Convert go.untyped_bool go.bool ((![go.uint64] "id") =⟨go.uint64⟩ (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r"))))
      then return: (#())
      else do:  #());;;
      do:  (let: "$a0" := (![go.uint64] "id") in
      (MethodResolve (go.PointerType raft) "sendAppend"%go (![go.PointerType raft] "r")) "$a0");;;
      return: #())
      ) in
    (MethodResolve (go.PointerType tracker.ProgressTracker) "Visit"%go (StructFieldRef raft "trk"%go (![go.PointerType raft] "r"))) "$a0");;;
    return: #()).

(* bcastHeartbeat sends RPC, without entries to all the peers.

   go: raft.go:722:16 *)
Definition raft__bcastHeartbeatⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "r" <>,
    exception_do (let: "r" := (GoAlloc (go.PointerType raft) "r") in
    let: "lastCtx" := (GoAlloc go.string (GoZeroVal go.string #())) in
    let: "$r0" := ((MethodResolve (go.PointerType readOnly) "lastPendingRequestCtx"%go (![go.PointerType readOnly] (StructFieldRef raft "readOnly"%go (![go.PointerType raft] "r")))) #()) in
    do:  ("lastCtx" <-[go.string] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((let: "$a0" := (![go.string] "lastCtx") in
    (FuncResolve go.len [go.string] #()) "$a0") =⟨go.int⟩ #(W64 0))
    then
      do:  (let: "$a0" := (Convert go.untyped_nil (go.SliceType go.byte) UntypedNil) in
      (MethodResolve (go.PointerType raft) "bcastHeartbeatWithCtx"%go (![go.PointerType raft] "r")) "$a0")
    else
      do:  (let: "$a0" := (Convert go.string (go.SliceType go.byte) (![go.string] "lastCtx")) in
      (MethodResolve (go.PointerType raft) "bcastHeartbeatWithCtx"%go (![go.PointerType raft] "r")) "$a0"));;;
    return: #()).

(* go: raft.go:731:16 *)
Definition raft__bcastHeartbeatWithCtxⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "r" "ctx",
    exception_do (let: "r" := (GoAlloc (go.PointerType raft) "r") in
    let: "ctx" := (GoAlloc (go.SliceType go.byte) "ctx") in
    do:  (let: "$a0" := (λ: "id" <>,
      exception_do (let: "id" := (GoAlloc go.uint64 "id") in
      (if: Convert go.untyped_bool go.bool ((![go.uint64] "id") =⟨go.uint64⟩ (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r"))))
      then return: (#())
      else do:  #());;;
      do:  (let: "$a0" := (![go.uint64] "id") in
      let: "$a1" := (![go.SliceType go.byte] "ctx") in
      (MethodResolve (go.PointerType raft) "sendHeartbeat"%go (![go.PointerType raft] "r")) "$a0" "$a1");;;
      return: #())
      ) in
    (MethodResolve (go.PointerType tracker.ProgressTracker) "Visit"%go (StructFieldRef raft "trk"%go (![go.PointerType raft] "r"))) "$a0");;;
    return: #()).

(* go: raft.go:740:16 *)
Definition raft__appliedToⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "r" "index" "size",
    exception_do (let: "r" := (GoAlloc (go.PointerType raft) "r") in
    let: "size" := (GoAlloc entryEncodingSize "size") in
    let: "index" := (GoAlloc go.uint64 "index") in
    let: "oldApplied" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (![go.uint64] (StructFieldRef raftLog "applied"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r"))))) in
    do:  ("oldApplied" <-[go.uint64] "$r0");;;
    let: "newApplied" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (let: "$a0" := (![go.uint64] "index") in
    let: "$a1" := (![go.uint64] "oldApplied") in
    (FuncResolve go.max [go.uint64; go.uint64] #()) "$a0" "$a1") in
    do:  ("newApplied" <-[go.uint64] "$r0");;;
    do:  (let: "$a0" := (![go.uint64] "newApplied") in
    let: "$a1" := (![entryEncodingSize] "size") in
    (MethodResolve (go.PointerType raftLog) "appliedTo"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r")))) "$a0" "$a1");;;
    (if: ((![go.bool] (StructFieldRef tracker.Config "AutoLeave"%go (StructFieldRef tracker.ProgressTracker "Config"%go (StructFieldRef raft "trk"%go (![go.PointerType raft] "r"))))) && ((![go.uint64] "newApplied") ≥⟨go.uint64⟩ (![go.uint64] (StructFieldRef raft "pendingConfIndex"%go (![go.PointerType raft] "r"))))) && ((![StateType] (StructFieldRef raft "state"%go (![go.PointerType raft] "r"))) =⟨go.uint64⟩ StateLeader)
    then
      let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
      let: "m" := (GoAlloc raftpb.Message (GoZeroVal raftpb.Message #())) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (Convert go.untyped_nil raftpb.ConfChangeI UntypedNil) in
      (FuncResolve confChangeToMsg [] #()) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("m" <-[raftpb.Message] "$r0");;;
      do:  ("err" <-[go.error] "$r1");;;
      (if: Convert go.untyped_bool go.bool ((![go.error] "err") ≠⟨go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]⟩ (Convert go.untyped_nil (go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]) UntypedNil))
      then
        do:  (let: "$a0" := (Convert go.error (go.InterfaceType []) (![go.error] "err")) in
        (FuncResolve go.panic [] #()) "$a0")
      else do:  #());;;
      (let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
      let: "$r0" := (let: "$a0" := (![raftpb.Message] "m") in
      (MethodResolve (go.PointerType raft) "Step"%go (![go.PointerType raft] "r")) "$a0") in
      do:  ("err" <-[go.error] "$r0");;;
      (if: Convert go.untyped_bool go.bool ((![go.error] "err") ≠⟨go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]⟩ (Convert go.untyped_nil (go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]) UntypedNil))
      then
        do:  (let: "$a0" := #"not initiating automatic transition out of joint configuration %s: %v"%go in
        let: "$a1" := ((let: "$sl0" := (Convert tracker.Config (go.InterfaceType []) (![tracker.Config] (StructFieldRef tracker.ProgressTracker "Config"%go (StructFieldRef raft "trk"%go (![go.PointerType raft] "r"))))) in
        let: "$sl1" := (Convert go.error (go.InterfaceType []) (![go.error] "err")) in
        CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1")]))) in
        (MethodResolve Logger "Debugf"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0" "$a1")
      else
        do:  (let: "$a0" := #"initiating automatic transition out of joint configuration %s"%go in
        let: "$a1" := ((let: "$sl0" := (Convert tracker.Config (go.InterfaceType []) (![tracker.Config] (StructFieldRef tracker.ProgressTracker "Config"%go (StructFieldRef raft "trk"%go (![go.PointerType raft] "r"))))) in
        CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0")]))) in
        (MethodResolve Logger "Infof"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0" "$a1")))
    else do:  #());;;
    return: #()).

(* go: raft.go:769:16 *)
Definition raft__appliedSnapⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "r" "snap",
    exception_do (let: "r" := (GoAlloc (go.PointerType raft) "r") in
    let: "snap" := (GoAlloc (go.PointerType raftpb.Snapshot) "snap") in
    let: "index" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (![go.uint64] (StructFieldRef raftpb.SnapshotMetadata "Index"%go (StructFieldRef raftpb.Snapshot "Metadata"%go (![go.PointerType raftpb.Snapshot] "snap")))) in
    do:  ("index" <-[go.uint64] "$r0");;;
    do:  (let: "$a0" := (![go.uint64] "index") in
    (MethodResolve (go.PointerType raftLog) "stableSnapTo"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r")))) "$a0");;;
    do:  (let: "$a0" := (![go.uint64] "index") in
    let: "$a1" := #(W64 0) in
    (MethodResolve (go.PointerType raft) "appliedTo"%go (![go.PointerType raft] "r")) "$a0" "$a1");;;
    return: #()).

(* maybeCommit attempts to advance the commit index. Returns true if the commit
   index changed (in which case the caller should call r.bcastAppend). This can
   only be called in StateLeader.

   go: raft.go:778:16 *)
Definition raft__maybeCommitⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "r" <>,
    with_defer: (let: "r" := (GoAlloc (go.PointerType raft) "r") in
    do:  (let: "$a0" := (![go.PointerType raft] "r") in
    let: "$f" := (FuncResolve traceCommit [] #()) in
    "$defer" <-[deferType] (let: "$oldf" := (![deferType] "$defer") in
    (λ: <>,
      "$f" "$a0";;
      "$oldf" #()
      )));;;
    return: (let: "$a0" := (CompositeLiteral entryID (LiteralValue [KeyedElement (Some (KeyField "term"%go)) (ElementExpression go.uint64 (![go.uint64] (StructFieldRef raft "Term"%go (![go.PointerType raft] "r")))); KeyedElement (Some (KeyField "index"%go)) (ElementExpression go.uint64 ((MethodResolve (go.PointerType tracker.ProgressTracker) "Committed"%go (StructFieldRef raft "trk"%go (![go.PointerType raft] "r"))) #()))])) in
     (MethodResolve (go.PointerType raftLog) "maybeCommit"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r")))) "$a0")).

(* go: raft.go:784:16 *)
Definition raft__resetⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "r" "term",
    exception_do (let: "r" := (GoAlloc (go.PointerType raft) "r") in
    let: "term" := (GoAlloc go.uint64 "term") in
    (if: Convert go.untyped_bool go.bool ((![go.uint64] (StructFieldRef raft "Term"%go (![go.PointerType raft] "r"))) ≠⟨go.uint64⟩ (![go.uint64] "term"))
    then
      let: "$r0" := (![go.uint64] "term") in
      do:  ((StructFieldRef raft "Term"%go (![go.PointerType raft] "r")) <-[go.uint64] "$r0");;;
      let: "$r0" := None in
      do:  ((StructFieldRef raft "Vote"%go (![go.PointerType raft] "r")) <-[go.uint64] "$r0")
    else do:  #());;;
    let: "$r0" := None in
    do:  ((StructFieldRef raft "lead"%go (![go.PointerType raft] "r")) <-[go.uint64] "$r0");;;
    let: "$r0" := #(W64 0) in
    do:  ((StructFieldRef raft "electionElapsed"%go (![go.PointerType raft] "r")) <-[go.int] "$r0");;;
    let: "$r0" := #(W64 0) in
    do:  ((StructFieldRef raft "heartbeatElapsed"%go (![go.PointerType raft] "r")) <-[go.int] "$r0");;;
    do:  ((MethodResolve (go.PointerType raft) "resetRandomizedElectionTimeout"%go (![go.PointerType raft] "r")) #());;;
    do:  ((MethodResolve (go.PointerType raft) "abortLeaderTransfer"%go (![go.PointerType raft] "r")) #());;;
    do:  ((MethodResolve (go.PointerType tracker.ProgressTracker) "ResetVotes"%go (StructFieldRef raft "trk"%go (![go.PointerType raft] "r"))) #());;;
    do:  (let: "$a0" := (λ: "id" "pr",
      exception_do (let: "pr" := (GoAlloc (go.PointerType tracker.Progress) "pr") in
      let: "id" := (GoAlloc go.uint64 "id") in
      let: "$r0" := (CompositeLiteral tracker.Progress (LiteralValue [KeyedElement (Some (KeyField "Match"%go)) (ElementExpression go.uint64 #(W64 0)); KeyedElement (Some (KeyField "Next"%go)) (ElementExpression go.uint64 (((MethodResolve (go.PointerType raftLog) "lastIndex"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r")))) #()) +⟨go.uint64⟩ #(W64 1))); KeyedElement (Some (KeyField "Inflights"%go)) (ElementExpression (go.PointerType tracker.Inflights) (let: "$a0" := (![go.int] (StructFieldRef tracker.ProgressTracker "MaxInflight"%go (StructFieldRef raft "trk"%go (![go.PointerType raft] "r")))) in
       let: "$a1" := (![go.uint64] (StructFieldRef tracker.ProgressTracker "MaxInflightBytes"%go (StructFieldRef raft "trk"%go (![go.PointerType raft] "r")))) in
       (FuncResolve tracker.NewInflights [] #()) "$a0" "$a1")); KeyedElement (Some (KeyField "IsLearner"%go)) (ElementExpression go.bool (![go.bool] (StructFieldRef tracker.Progress "IsLearner"%go (![go.PointerType tracker.Progress] "pr"))))])) in
      do:  ((![go.PointerType tracker.Progress] "pr") <-[tracker.Progress] "$r0");;;
      (if: Convert go.untyped_bool go.bool ((![go.uint64] "id") =⟨go.uint64⟩ (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r"))))
      then
        let: "$r0" := ((MethodResolve (go.PointerType raftLog) "lastIndex"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r")))) #()) in
        do:  ((StructFieldRef tracker.Progress "Match"%go (![go.PointerType tracker.Progress] "pr")) <-[go.uint64] "$r0")
      else do:  #());;;
      return: #())
      ) in
    (MethodResolve (go.PointerType tracker.ProgressTracker) "Visit"%go (StructFieldRef raft "trk"%go (![go.PointerType raft] "r"))) "$a0");;;
    let: "$r0" := #(W64 0) in
    do:  ((StructFieldRef raft "pendingConfIndex"%go (![go.PointerType raft] "r")) <-[go.uint64] "$r0");;;
    let: "$r0" := #(W64 0) in
    do:  ((StructFieldRef raft "uncommittedSize"%go (![go.PointerType raft] "r")) <-[entryPayloadSize] "$r0");;;
    let: "$r0" := (let: "$a0" := (![ReadOnlyOption] (StructFieldRef readOnly "option"%go (![go.PointerType readOnly] (StructFieldRef raft "readOnly"%go (![go.PointerType raft] "r"))))) in
    (FuncResolve newReadOnly [] #()) "$a0") in
    do:  ((StructFieldRef raft "readOnly"%go (![go.PointerType raft] "r")) <-[go.PointerType readOnly] "$r0");;;
    return: #()).

(* go: raft.go:815:16 *)
Definition raft__appendEntryⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "r" "es",
    exception_do (let: "accepted" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "r" := (GoAlloc (go.PointerType raft) "r") in
    let: "es" := (GoAlloc (go.SliceType raftpb.Entry) "es") in
    let: "li" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := ((MethodResolve (go.PointerType raftLog) "lastIndex"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r")))) #()) in
    do:  ("li" <-[go.uint64] "$r0");;;
    let: "$range" := (![go.SliceType raftpb.Entry] "es") in
    (let: "i" := (GoAlloc go.int (GoZeroVal go.int #())) in
    slice.for_range raftpb.Entry "$range" (λ: "$key" "$value",
      do:  ("i" <-[go.int] "$key");;;
      let: "$r0" := (![go.uint64] (StructFieldRef raft "Term"%go (![go.PointerType raft] "r"))) in
      do:  ((StructFieldRef raftpb.Entry "Term"%go (IndexRef (go.SliceType raftpb.Entry) (![go.SliceType raftpb.Entry] "es", ![go.int] "i"))) <-[go.uint64] "$r0");;;
      let: "$r0" := (((![go.uint64] "li") +⟨go.uint64⟩ #(W64 1)) +⟨go.uint64⟩ (Convert go.int go.uint64 (![go.int] "i"))) in
      do:  ((StructFieldRef raftpb.Entry "Index"%go (IndexRef (go.SliceType raftpb.Entry) (![go.SliceType raftpb.Entry] "es", ![go.int] "i"))) <-[go.uint64] "$r0")));;;
    (if: (~ (let: "$a0" := (![go.SliceType raftpb.Entry] "es") in
    (MethodResolve (go.PointerType raft) "increaseUncommittedSize"%go (![go.PointerType raft] "r")) "$a0"))
    then
      do:  (let: "$a0" := #"%x appending new entries to log would exceed uncommitted entry size limit; dropping proposal"%go in
      let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))) in
      CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0")]))) in
      (MethodResolve Logger "Warningf"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0" "$a1");;;
      return: (#false)
    else do:  #());;;
    do:  (let: "$a0" := (![go.PointerType raft] "r") in
    let: "$a1" := (![go.SliceType raftpb.Entry] "es") in
    (FuncResolve traceReplicate [] #()) "$a0" "$a1");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType raftpb.Entry] "es") in
    (MethodResolve (go.PointerType raftLog) "append"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r")))) "$a0") in
    do:  ("li" <-[go.uint64] "$r0");;;
    do:  (let: "$a0" := (CompositeLiteral raftpb.Message (LiteralValue [KeyedElement (Some (KeyField "To"%go)) (ElementExpression go.uint64 (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))); KeyedElement (Some (KeyField "Type"%go)) (ElementExpression raftpb.MessageType raftpb.MsgAppResp); KeyedElement (Some (KeyField "Index"%go)) (ElementExpression go.uint64 (![go.uint64] "li"))])) in
    (MethodResolve (go.PointerType raft) "send"%go (![go.PointerType raft] "r")) "$a0");;;
    return: (#true)).

(* tickElection is run by followers and candidates after r.electionTimeout.

   go: raft.go:850:16 *)
Definition raft__tickElectionⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "r" <>,
    exception_do (let: "r" := (GoAlloc (go.PointerType raft) "r") in
    do:  ((StructFieldRef raft "electionElapsed"%go (![go.PointerType raft] "r")) <-[go.int] ((![go.int] (StructFieldRef raft "electionElapsed"%go (![go.PointerType raft] "r"))) +⟨go.int⟩ #(W64 1)));;;
    (if: ((MethodResolve (go.PointerType raft) "promotable"%go (![go.PointerType raft] "r")) #()) && ((MethodResolve (go.PointerType raft) "pastElectionTimeout"%go (![go.PointerType raft] "r")) #())
    then
      let: "$r0" := #(W64 0) in
      do:  ((StructFieldRef raft "electionElapsed"%go (![go.PointerType raft] "r")) <-[go.int] "$r0");;;
      (let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
      let: "$r0" := (let: "$a0" := (CompositeLiteral raftpb.Message (LiteralValue [KeyedElement (Some (KeyField "From"%go)) (ElementExpression go.uint64 (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))); KeyedElement (Some (KeyField "Type"%go)) (ElementExpression raftpb.MessageType raftpb.MsgHup)])) in
      (MethodResolve (go.PointerType raft) "Step"%go (![go.PointerType raft] "r")) "$a0") in
      do:  ("err" <-[go.error] "$r0");;;
      (if: Convert go.untyped_bool go.bool ((![go.error] "err") ≠⟨go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]⟩ (Convert go.untyped_nil (go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]) UntypedNil))
      then
        do:  (let: "$a0" := #"error occurred during election: %v"%go in
        let: "$a1" := ((let: "$sl0" := (Convert go.error (go.InterfaceType []) (![go.error] "err")) in
        CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0")]))) in
        (MethodResolve Logger "Debugf"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0" "$a1")
      else do:  #()))
    else do:  #());;;
    return: #()).

(* tickHeartbeat is run by leaders to send a MsgBeat after r.heartbeatTimeout.

   go: raft.go:862:16 *)
Definition raft__tickHeartbeatⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "r" <>,
    exception_do (let: "r" := (GoAlloc (go.PointerType raft) "r") in
    do:  ((StructFieldRef raft "heartbeatElapsed"%go (![go.PointerType raft] "r")) <-[go.int] ((![go.int] (StructFieldRef raft "heartbeatElapsed"%go (![go.PointerType raft] "r"))) +⟨go.int⟩ #(W64 1)));;;
    do:  ((StructFieldRef raft "electionElapsed"%go (![go.PointerType raft] "r")) <-[go.int] ((![go.int] (StructFieldRef raft "electionElapsed"%go (![go.PointerType raft] "r"))) +⟨go.int⟩ #(W64 1)));;;
    (if: Convert go.untyped_bool go.bool ((![go.int] (StructFieldRef raft "electionElapsed"%go (![go.PointerType raft] "r"))) ≥⟨go.int⟩ (![go.int] (StructFieldRef raft "electionTimeout"%go (![go.PointerType raft] "r"))))
    then
      let: "$r0" := #(W64 0) in
      do:  ((StructFieldRef raft "electionElapsed"%go (![go.PointerType raft] "r")) <-[go.int] "$r0");;;
      (if: ![go.bool] (StructFieldRef raft "checkQuorum"%go (![go.PointerType raft] "r"))
      then
        (let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
        let: "$r0" := (let: "$a0" := (CompositeLiteral raftpb.Message (LiteralValue [KeyedElement (Some (KeyField "From"%go)) (ElementExpression go.uint64 (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))); KeyedElement (Some (KeyField "Type"%go)) (ElementExpression raftpb.MessageType raftpb.MsgCheckQuorum)])) in
        (MethodResolve (go.PointerType raft) "Step"%go (![go.PointerType raft] "r")) "$a0") in
        do:  ("err" <-[go.error] "$r0");;;
        (if: Convert go.untyped_bool go.bool ((![go.error] "err") ≠⟨go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]⟩ (Convert go.untyped_nil (go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]) UntypedNil))
        then
          do:  (let: "$a0" := #"error occurred during checking sending heartbeat: %v"%go in
          let: "$a1" := ((let: "$sl0" := (Convert go.error (go.InterfaceType []) (![go.error] "err")) in
          CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0")]))) in
          (MethodResolve Logger "Debugf"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0" "$a1")
        else do:  #()))
      else do:  #());;;
      (if: Convert go.untyped_bool go.bool (((![StateType] (StructFieldRef raft "state"%go (![go.PointerType raft] "r"))) =⟨go.uint64⟩ StateLeader) && ((![go.uint64] (StructFieldRef raft "leadTransferee"%go (![go.PointerType raft] "r"))) ≠⟨go.uint64⟩ None))
      then do:  ((MethodResolve (go.PointerType raft) "abortLeaderTransfer"%go (![go.PointerType raft] "r")) #())
      else do:  #())
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool ((![StateType] (StructFieldRef raft "state"%go (![go.PointerType raft] "r"))) ≠⟨go.uint64⟩ StateLeader)
    then return: (#())
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool ((![go.int] (StructFieldRef raft "heartbeatElapsed"%go (![go.PointerType raft] "r"))) ≥⟨go.int⟩ (![go.int] (StructFieldRef raft "heartbeatTimeout"%go (![go.PointerType raft] "r"))))
    then
      let: "$r0" := #(W64 0) in
      do:  ((StructFieldRef raft "heartbeatElapsed"%go (![go.PointerType raft] "r")) <-[go.int] "$r0");;;
      (let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
      let: "$r0" := (let: "$a0" := (CompositeLiteral raftpb.Message (LiteralValue [KeyedElement (Some (KeyField "From"%go)) (ElementExpression go.uint64 (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))); KeyedElement (Some (KeyField "Type"%go)) (ElementExpression raftpb.MessageType raftpb.MsgBeat)])) in
      (MethodResolve (go.PointerType raft) "Step"%go (![go.PointerType raft] "r")) "$a0") in
      do:  ("err" <-[go.error] "$r0");;;
      (if: Convert go.untyped_bool go.bool ((![go.error] "err") ≠⟨go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]⟩ (Convert go.untyped_nil (go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]) UntypedNil))
      then
        do:  (let: "$a0" := #"error occurred during checking sending heartbeat: %v"%go in
        let: "$a1" := ((let: "$sl0" := (Convert go.error (go.InterfaceType []) (![go.error] "err")) in
        CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0")]))) in
        (MethodResolve Logger "Debugf"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0" "$a1")
      else do:  #()))
    else do:  #());;;
    return: #()).

(* go: raft.go:891:16 *)
Definition raft__becomeFollowerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "r" "term" "lead",
    exception_do (let: "r" := (GoAlloc (go.PointerType raft) "r") in
    let: "lead" := (GoAlloc go.uint64 "lead") in
    let: "term" := (GoAlloc go.uint64 "term") in
    let: "$r0" := (FuncResolve stepFollower [] #()) in
    do:  ((StructFieldRef raft "step"%go (![go.PointerType raft] "r")) <-[stepFunc] "$r0");;;
    do:  (let: "$a0" := (![go.uint64] "term") in
    (MethodResolve (go.PointerType raft) "reset"%go (![go.PointerType raft] "r")) "$a0");;;
    let: "$r0" := (MethodResolve (go.PointerType raft) "tickElection"%go (![go.PointerType raft] "r")) in
    do:  ((StructFieldRef raft "tick"%go (![go.PointerType raft] "r")) <-[go.FunctionType (go.Signature [] false [])] "$r0");;;
    let: "$r0" := (![go.uint64] "lead") in
    do:  ((StructFieldRef raft "lead"%go (![go.PointerType raft] "r")) <-[go.uint64] "$r0");;;
    let: "$r0" := StateFollower in
    do:  ((StructFieldRef raft "state"%go (![go.PointerType raft] "r")) <-[StateType] "$r0");;;
    do:  (let: "$a0" := #"%x became follower at term %d"%go in
    let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))) in
    let: "$sl1" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "Term"%go (![go.PointerType raft] "r")))) in
    CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1")]))) in
    (MethodResolve Logger "Infof"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0" "$a1");;;
    do:  (let: "$a0" := (![go.PointerType raft] "r") in
    (FuncResolve traceBecomeFollower [] #()) "$a0");;;
    return: #()).

(* go: raft.go:902:16 *)
Definition raft__becomeCandidateⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "r" <>,
    exception_do (let: "r" := (GoAlloc (go.PointerType raft) "r") in
    (if: Convert go.untyped_bool go.bool ((![StateType] (StructFieldRef raft "state"%go (![go.PointerType raft] "r"))) =⟨go.uint64⟩ StateLeader)
    then
      do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"invalid transition [leader -> candidate]"%go) in
      (FuncResolve go.panic [] #()) "$a0")
    else do:  #());;;
    let: "$r0" := (FuncResolve stepCandidate [] #()) in
    do:  ((StructFieldRef raft "step"%go (![go.PointerType raft] "r")) <-[stepFunc] "$r0");;;
    do:  (let: "$a0" := ((![go.uint64] (StructFieldRef raft "Term"%go (![go.PointerType raft] "r"))) +⟨go.uint64⟩ #(W64 1)) in
    (MethodResolve (go.PointerType raft) "reset"%go (![go.PointerType raft] "r")) "$a0");;;
    let: "$r0" := (MethodResolve (go.PointerType raft) "tickElection"%go (![go.PointerType raft] "r")) in
    do:  ((StructFieldRef raft "tick"%go (![go.PointerType raft] "r")) <-[go.FunctionType (go.Signature [] false [])] "$r0");;;
    let: "$r0" := (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r"))) in
    do:  ((StructFieldRef raft "Vote"%go (![go.PointerType raft] "r")) <-[go.uint64] "$r0");;;
    let: "$r0" := StateCandidate in
    do:  ((StructFieldRef raft "state"%go (![go.PointerType raft] "r")) <-[StateType] "$r0");;;
    do:  (let: "$a0" := #"%x became candidate at term %d"%go in
    let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))) in
    let: "$sl1" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "Term"%go (![go.PointerType raft] "r")))) in
    CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1")]))) in
    (MethodResolve Logger "Infof"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0" "$a1");;;
    do:  (let: "$a0" := (![go.PointerType raft] "r") in
    (FuncResolve traceBecomeCandidate [] #()) "$a0");;;
    return: #()).

(* go: raft.go:917:16 *)
Definition raft__becomePreCandidateⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "r" <>,
    exception_do (let: "r" := (GoAlloc (go.PointerType raft) "r") in
    (if: Convert go.untyped_bool go.bool ((![StateType] (StructFieldRef raft "state"%go (![go.PointerType raft] "r"))) =⟨go.uint64⟩ StateLeader)
    then
      do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"invalid transition [leader -> pre-candidate]"%go) in
      (FuncResolve go.panic [] #()) "$a0")
    else do:  #());;;
    let: "$r0" := (FuncResolve stepCandidate [] #()) in
    do:  ((StructFieldRef raft "step"%go (![go.PointerType raft] "r")) <-[stepFunc] "$r0");;;
    do:  ((MethodResolve (go.PointerType tracker.ProgressTracker) "ResetVotes"%go (StructFieldRef raft "trk"%go (![go.PointerType raft] "r"))) #());;;
    let: "$r0" := (MethodResolve (go.PointerType raft) "tickElection"%go (![go.PointerType raft] "r")) in
    do:  ((StructFieldRef raft "tick"%go (![go.PointerType raft] "r")) <-[go.FunctionType (go.Signature [] false [])] "$r0");;;
    let: "$r0" := None in
    do:  ((StructFieldRef raft "lead"%go (![go.PointerType raft] "r")) <-[go.uint64] "$r0");;;
    let: "$r0" := StatePreCandidate in
    do:  ((StructFieldRef raft "state"%go (![go.PointerType raft] "r")) <-[StateType] "$r0");;;
    do:  (let: "$a0" := #"%x became pre-candidate at term %d"%go in
    let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))) in
    let: "$sl1" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "Term"%go (![go.PointerType raft] "r")))) in
    CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1")]))) in
    (MethodResolve Logger "Infof"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0" "$a1");;;
    return: #()).

(* go: raft.go:933:16 *)
Definition raft__becomeLeaderⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "r" <>,
    exception_do (let: "r" := (GoAlloc (go.PointerType raft) "r") in
    (if: Convert go.untyped_bool go.bool ((![StateType] (StructFieldRef raft "state"%go (![go.PointerType raft] "r"))) =⟨go.uint64⟩ StateFollower)
    then
      do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"invalid transition [follower -> leader]"%go) in
      (FuncResolve go.panic [] #()) "$a0")
    else do:  #());;;
    let: "$r0" := (FuncResolve stepLeader [] #()) in
    do:  ((StructFieldRef raft "step"%go (![go.PointerType raft] "r")) <-[stepFunc] "$r0");;;
    do:  (let: "$a0" := (![go.uint64] (StructFieldRef raft "Term"%go (![go.PointerType raft] "r"))) in
    (MethodResolve (go.PointerType raft) "reset"%go (![go.PointerType raft] "r")) "$a0");;;
    let: "$r0" := (MethodResolve (go.PointerType raft) "tickHeartbeat"%go (![go.PointerType raft] "r")) in
    do:  ((StructFieldRef raft "tick"%go (![go.PointerType raft] "r")) <-[go.FunctionType (go.Signature [] false [])] "$r0");;;
    let: "$r0" := (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r"))) in
    do:  ((StructFieldRef raft "lead"%go (![go.PointerType raft] "r")) <-[go.uint64] "$r0");;;
    let: "$r0" := StateLeader in
    do:  ((StructFieldRef raft "state"%go (![go.PointerType raft] "r")) <-[StateType] "$r0");;;
    let: "pr" := (GoAlloc (go.PointerType tracker.Progress) (GoZeroVal (go.PointerType tracker.Progress) #())) in
    let: "$r0" := (map.lookup1 go.uint64 (go.PointerType tracker.Progress) (![tracker.ProgressMap] (StructFieldRef tracker.ProgressTracker "Progress"%go (StructFieldRef raft "trk"%go (![go.PointerType raft] "r")))) (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))) in
    do:  ("pr" <-[go.PointerType tracker.Progress] "$r0");;;
    do:  ((MethodResolve (go.PointerType tracker.Progress) "BecomeReplicate"%go (![go.PointerType tracker.Progress] "pr")) #());;;
    let: "$r0" := #true in
    do:  ((StructFieldRef tracker.Progress "RecentActive"%go (![go.PointerType tracker.Progress] "pr")) <-[go.bool] "$r0");;;
    let: "$r0" := ((MethodResolve (go.PointerType raftLog) "lastIndex"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r")))) #()) in
    do:  ((StructFieldRef raft "pendingConfIndex"%go (![go.PointerType raft] "r")) <-[go.uint64] "$r0");;;
    do:  (let: "$a0" := (![go.PointerType raft] "r") in
    (FuncResolve traceBecomeLeader [] #()) "$a0");;;
    let: "emptyEnt" := (GoAlloc raftpb.Entry (GoZeroVal raftpb.Entry #())) in
    let: "$r0" := (CompositeLiteral raftpb.Entry (LiteralValue [KeyedElement (Some (KeyField "Data"%go)) (ElementExpression go.untyped_nil UntypedNil)])) in
    do:  ("emptyEnt" <-[raftpb.Entry] "$r0");;;
    (if: (~ (let: "$a0" := ((let: "$sl0" := (![raftpb.Entry] "emptyEnt") in
    CompositeLiteral (go.SliceType raftpb.Entry) (LiteralValue [KeyedElement None (ElementExpression raftpb.Entry "$sl0")]))) in
    (MethodResolve (go.PointerType raft) "appendEntry"%go (![go.PointerType raft] "r")) "$a0"))
    then
      do:  (let: "$a0" := ((let: "$sl0" := (Convert go.string (go.InterfaceType []) #"empty entry was dropped"%go) in
      CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0")]))) in
      (MethodResolve Logger "Panic"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0")
    else do:  #());;;
    do:  (let: "$a0" := #"%x became leader at term %d"%go in
    let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))) in
    let: "$sl1" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "Term"%go (![go.PointerType raft] "r")))) in
    CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1")]))) in
    (MethodResolve Logger "Infof"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0" "$a1");;;
    return: #()).

(* go: raft.go:973:16 *)
Definition raft__hupⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "r" "t",
    exception_do (let: "r" := (GoAlloc (go.PointerType raft) "r") in
    let: "t" := (GoAlloc CampaignType "t") in
    (if: Convert go.untyped_bool go.bool ((![StateType] (StructFieldRef raft "state"%go (![go.PointerType raft] "r"))) =⟨go.uint64⟩ StateLeader)
    then
      do:  (let: "$a0" := #"%x ignoring MsgHup because already leader"%go in
      let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))) in
      CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0")]))) in
      (MethodResolve Logger "Debugf"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0" "$a1");;;
      return: (#())
    else do:  #());;;
    (if: (~ ((MethodResolve (go.PointerType raft) "promotable"%go (![go.PointerType raft] "r")) #()))
    then
      do:  (let: "$a0" := #"%x is unpromotable and can not campaign"%go in
      let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))) in
      CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0")]))) in
      (MethodResolve Logger "Warningf"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0" "$a1");;;
      return: (#())
    else do:  #());;;
    (if: (MethodResolve (go.PointerType raft) "hasUnappliedConfChanges"%go (![go.PointerType raft] "r")) #()
    then
      do:  (let: "$a0" := #"%x cannot campaign at term %d since there are still pending configuration changes to apply"%go in
      let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))) in
      let: "$sl1" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "Term"%go (![go.PointerType raft] "r")))) in
      CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1")]))) in
      (MethodResolve Logger "Warningf"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0" "$a1");;;
      return: (#())
    else do:  #());;;
    do:  (let: "$a0" := #"%x is starting a new election at term %d"%go in
    let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))) in
    let: "$sl1" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "Term"%go (![go.PointerType raft] "r")))) in
    CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1")]))) in
    (MethodResolve Logger "Infof"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0" "$a1");;;
    do:  (let: "$a0" := (![CampaignType] "t") in
    (MethodResolve (go.PointerType raft) "campaign"%go (![go.PointerType raft] "r")) "$a0");;;
    return: #()).

(* go: raft.go:995:16 *)
Definition raft__hasUnappliedConfChangesⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "r" <>,
    exception_do (let: "r" := (GoAlloc (go.PointerType raft) "r") in
    (if: Convert go.untyped_bool go.bool ((![go.uint64] (StructFieldRef raftLog "applied"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r"))))) ≥⟨go.uint64⟩ (![go.uint64] (StructFieldRef raftLog "committed"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r"))))))
    then return: (#false)
    else do:  #());;;
    let: "found" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #false in
    do:  ("found" <-[go.bool] "$r0");;;
    let: "hi" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "lo" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := ((![go.uint64] (StructFieldRef raftLog "applied"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r"))))) +⟨go.uint64⟩ #(W64 1)) in
    let: "$r1" := ((![go.uint64] (StructFieldRef raftLog "committed"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r"))))) +⟨go.uint64⟩ #(W64 1)) in
    do:  ("lo" <-[go.uint64] "$r0");;;
    do:  ("hi" <-[go.uint64] "$r1");;;
    let: "pageSize" := (GoAlloc entryEncodingSize (GoZeroVal entryEncodingSize #())) in
    let: "$r0" := (![entryEncodingSize] (StructFieldRef raftLog "maxApplyingEntsSize"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r"))))) in
    do:  ("pageSize" <-[entryEncodingSize] "$r0");;;
    (let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
    let: "$r0" := (let: "$a0" := (![go.uint64] "lo") in
    let: "$a1" := (![go.uint64] "hi") in
    let: "$a2" := (![entryEncodingSize] "pageSize") in
    let: "$a3" := (λ: "ents",
      exception_do (let: "ents" := (GoAlloc (go.SliceType raftpb.Entry) "ents") in
      let: "$range" := (![go.SliceType raftpb.Entry] "ents") in
      (let: "i" := (GoAlloc go.int (GoZeroVal go.int #())) in
      slice.for_range raftpb.Entry "$range" (λ: "$key" "$value",
        do:  ("i" <-[go.int] "$key");;;
        (if: Convert go.untyped_bool go.bool (((![raftpb.EntryType] (StructFieldRef raftpb.Entry "Type"%go (IndexRef (go.SliceType raftpb.Entry) (![go.SliceType raftpb.Entry] "ents", ![go.int] "i")))) =⟨go.int32⟩ raftpb.EntryConfChange) || ((![raftpb.EntryType] (StructFieldRef raftpb.Entry "Type"%go (IndexRef (go.SliceType raftpb.Entry) (![go.SliceType raftpb.Entry] "ents", ![go.int] "i")))) =⟨go.int32⟩ raftpb.EntryConfChangeV2))
        then
          let: "$r0" := #true in
          do:  ("found" <-[go.bool] "$r0");;;
          return: (![go.error] (GlobalVarAddr errBreak #()))
        else do:  #())));;;
      return: (Convert go.untyped_nil go.error UntypedNil))
      ) in
    (MethodResolve (go.PointerType raftLog) "scan"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r")))) "$a0" "$a1" "$a2" "$a3") in
    do:  ("err" <-[go.error] "$r0");;;
    (if: Convert go.untyped_bool go.bool (((![go.error] "err") ≠⟨go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]⟩ (Convert go.untyped_nil (go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]) UntypedNil)) && ((![go.error] "err") ≠⟨go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]⟩ (![go.error] (GlobalVarAddr errBreak #()))))
    then
      do:  (let: "$a0" := #"error scanning unapplied entries [%d, %d): %v"%go in
      let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] "lo")) in
      let: "$sl1" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] "hi")) in
      let: "$sl2" := (Convert go.error (go.InterfaceType []) (![go.error] "err")) in
      CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl2")]))) in
      (MethodResolve Logger "Panicf"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0" "$a1")
    else do:  #()));;;
    return: (![go.bool] "found")).

(* campaign transitions the raft instance to candidate state. This must only be
   called after verifying that this is a legitimate transition.

   go: raft.go:1025:16 *)
Definition raft__campaignⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "r" "t",
    exception_do (let: "r" := (GoAlloc (go.PointerType raft) "r") in
    let: "t" := (GoAlloc CampaignType "t") in
    (if: (~ ((MethodResolve (go.PointerType raft) "promotable"%go (![go.PointerType raft] "r")) #()))
    then
      do:  (let: "$a0" := #"%x is unpromotable; campaign() should have been called"%go in
      let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))) in
      CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0")]))) in
      (MethodResolve Logger "Warningf"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0" "$a1")
    else do:  #());;;
    let: "term" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "voteMsg" := (GoAlloc raftpb.MessageType (GoZeroVal raftpb.MessageType #())) in
    (if: Convert go.untyped_bool go.bool ((![CampaignType] "t") =⟨go.string⟩ campaignPreElection)
    then
      do:  ((MethodResolve (go.PointerType raft) "becomePreCandidate"%go (![go.PointerType raft] "r")) #());;;
      let: "$r0" := raftpb.MsgPreVote in
      do:  ("voteMsg" <-[raftpb.MessageType] "$r0");;;
      let: "$r0" := ((![go.uint64] (StructFieldRef raft "Term"%go (![go.PointerType raft] "r"))) +⟨go.uint64⟩ #(W64 1)) in
      do:  ("term" <-[go.uint64] "$r0")
    else
      do:  ((MethodResolve (go.PointerType raft) "becomeCandidate"%go (![go.PointerType raft] "r")) #());;;
      let: "$r0" := raftpb.MsgVote in
      do:  ("voteMsg" <-[raftpb.MessageType] "$r0");;;
      let: "$r0" := (![go.uint64] (StructFieldRef raft "Term"%go (![go.PointerType raft] "r"))) in
      do:  ("term" <-[go.uint64] "$r0"));;;
    let: "ids" := (GoAlloc (go.SliceType go.uint64) (GoZeroVal (go.SliceType go.uint64) #())) in
    let: "idMap" := (GoAlloc (go.MapType go.uint64 (go.StructType [

    ])) (GoZeroVal (go.MapType go.uint64 (go.StructType [

    ])) #())) in
    let: "$r0" := ((MethodResolve quorum.JointConfig "IDs"%go (![quorum.JointConfig] (StructFieldRef tracker.Config "Voters"%go (StructFieldRef tracker.ProgressTracker "Config"%go (StructFieldRef raft "trk"%go (![go.PointerType raft] "r")))))) #()) in
    do:  ("idMap" <-[go.MapType go.uint64 (go.StructType [

    ])] "$r0");;;
    let: "$r0" := ((FuncResolve go.make3 [go.SliceType go.uint64] #()) #(W64 0) (let: "$a0" := (![go.MapType go.uint64 (go.StructType [

    ])] "idMap") in
    (FuncResolve go.len [go.MapType go.uint64 (go.StructType [

     ])] #()) "$a0")) in
    do:  ("ids" <-[go.SliceType go.uint64] "$r0");;;
    let: "$range" := (![go.MapType go.uint64 (go.StructType [

    ])] "idMap") in
    (let: "id" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    map.for_range go.uint64 (go.StructType [

    ]) "$range" (λ: "$key" "value",
      do:  ("id" <-[go.uint64] "$key");;;
      let: "$r0" := (let: "$a0" := (![go.SliceType go.uint64] "ids") in
      let: "$a1" := ((let: "$sl0" := (![go.uint64] "id") in
      CompositeLiteral (go.SliceType go.uint64) (LiteralValue [KeyedElement None (ElementExpression go.uint64 "$sl0")]))) in
      (FuncResolve go.append [go.SliceType go.uint64] #()) "$a0" "$a1") in
      do:  ("ids" <-[go.SliceType go.uint64] "$r0")));;;
    do:  (let: "$a0" := (![go.SliceType go.uint64] "ids") in
    (FuncResolve slices.SortUint64 [] #()) "$a0");;;
    let: "$range" := (![go.SliceType go.uint64] "ids") in
    (let: "id" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    slice.for_range go.uint64 "$range" (λ: "$key" "$value",
      do:  ("id" <-[go.uint64] "$value");;;
      do:  "$key";;;
      (if: Convert go.untyped_bool go.bool ((![go.uint64] "id") =⟨go.uint64⟩ (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r"))))
      then
        do:  (let: "$a0" := (CompositeLiteral raftpb.Message (LiteralValue [KeyedElement (Some (KeyField "To"%go)) (ElementExpression go.uint64 (![go.uint64] "id")); KeyedElement (Some (KeyField "Term"%go)) (ElementExpression go.uint64 (![go.uint64] "term")); KeyedElement (Some (KeyField "Type"%go)) (ElementExpression raftpb.MessageType (let: "$a0" := (![raftpb.MessageType] "voteMsg") in
         (FuncResolve voteRespMsgType [] #()) "$a0"))])) in
        (MethodResolve (go.PointerType raft) "send"%go (![go.PointerType raft] "r")) "$a0");;;
        continue: #()
      else do:  #());;;
      let: "last" := (GoAlloc entryID (GoZeroVal entryID #())) in
      let: "$r0" := ((MethodResolve (go.PointerType raftLog) "lastEntryID"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r")))) #()) in
      do:  ("last" <-[entryID] "$r0");;;
      do:  (let: "$a0" := #"%x [logterm: %d, index: %d] sent %s request to %x at term %d"%go in
      let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))) in
      let: "$sl1" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef entryID "term"%go "last"))) in
      let: "$sl2" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef entryID "index"%go "last"))) in
      let: "$sl3" := (Convert raftpb.MessageType (go.InterfaceType []) (![raftpb.MessageType] "voteMsg")) in
      let: "$sl4" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] "id")) in
      let: "$sl5" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "Term"%go (![go.PointerType raft] "r")))) in
      CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl2"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl3"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl4"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl5")]))) in
      (MethodResolve Logger "Infof"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0" "$a1");;;
      let: "ctx" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
      (if: Convert go.untyped_bool go.bool ((![CampaignType] "t") =⟨go.string⟩ campaignTransfer)
      then
        let: "$r0" := (Convert CampaignType (go.SliceType go.byte) (![CampaignType] "t")) in
        do:  ("ctx" <-[go.SliceType go.byte] "$r0")
      else do:  #());;;
      do:  (let: "$a0" := (CompositeLiteral raftpb.Message (LiteralValue [KeyedElement (Some (KeyField "To"%go)) (ElementExpression go.uint64 (![go.uint64] "id")); KeyedElement (Some (KeyField "Term"%go)) (ElementExpression go.uint64 (![go.uint64] "term")); KeyedElement (Some (KeyField "Type"%go)) (ElementExpression raftpb.MessageType (![raftpb.MessageType] "voteMsg")); KeyedElement (Some (KeyField "Index"%go)) (ElementExpression go.uint64 (![go.uint64] (StructFieldRef entryID "index"%go "last"))); KeyedElement (Some (KeyField "LogTerm"%go)) (ElementExpression go.uint64 (![go.uint64] (StructFieldRef entryID "term"%go "last"))); KeyedElement (Some (KeyField "Context"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] "ctx"))])) in
      (MethodResolve (go.PointerType raft) "send"%go (![go.PointerType raft] "r")) "$a0")));;;
    return: #()).

(* go: raft.go:1075:16 *)
Definition raft__pollⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "r" "id" "t" "v",
    exception_do (let: "result" := (GoAlloc quorum.VoteResult (GoZeroVal quorum.VoteResult #())) in
    let: "rejected" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "granted" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "r" := (GoAlloc (go.PointerType raft) "r") in
    let: "v" := (GoAlloc go.bool "v") in
    let: "t" := (GoAlloc raftpb.MessageType "t") in
    let: "id" := (GoAlloc go.uint64 "id") in
    (if: ![go.bool] "v"
    then
      do:  (let: "$a0" := #"%x received %s from %x at term %d"%go in
      let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))) in
      let: "$sl1" := (Convert raftpb.MessageType (go.InterfaceType []) (![raftpb.MessageType] "t")) in
      let: "$sl2" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] "id")) in
      let: "$sl3" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "Term"%go (![go.PointerType raft] "r")))) in
      CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl2"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl3")]))) in
      (MethodResolve Logger "Infof"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0" "$a1")
    else
      do:  (let: "$a0" := #"%x received %s rejection from %x at term %d"%go in
      let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))) in
      let: "$sl1" := (Convert raftpb.MessageType (go.InterfaceType []) (![raftpb.MessageType] "t")) in
      let: "$sl2" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] "id")) in
      let: "$sl3" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "Term"%go (![go.PointerType raft] "r")))) in
      CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl2"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl3")]))) in
      (MethodResolve Logger "Infof"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0" "$a1"));;;
    do:  (let: "$a0" := (![go.uint64] "id") in
    let: "$a1" := (![go.bool] "v") in
    (MethodResolve (go.PointerType tracker.ProgressTracker) "RecordVote"%go (StructFieldRef raft "trk"%go (![go.PointerType raft] "r"))) "$a0" "$a1");;;
    let: (("$ret0", "$ret1"), "$ret2") := (((MethodResolve (go.PointerType tracker.ProgressTracker) "TallyVotes"%go (StructFieldRef raft "trk"%go (![go.PointerType raft] "r"))) #())) in
    return: ("$ret0", "$ret1", "$ret2")).

(* go: raft.go:1085:16 *)
Definition raft__Stepⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "r" "m",
    exception_do (let: "r" := (GoAlloc (go.PointerType raft) "r") in
    let: "m" := (GoAlloc raftpb.Message "m") in
    do:  (let: "$a0" := (![go.PointerType raft] "r") in
    let: "$a1" := "m" in
    (FuncResolve traceReceiveMessage [] #()) "$a0" "$a1");;;
    let: "$sw" := #true in
    (if: "$sw" =⟨go.bool⟩ ((![go.uint64] (StructFieldRef raftpb.Message "Term"%go "m")) =⟨go.uint64⟩ #(W64 0))
    then do:  #()
    else
      (if: "$sw" =⟨go.bool⟩ ((![go.uint64] (StructFieldRef raftpb.Message "Term"%go "m")) >⟨go.uint64⟩ (![go.uint64] (StructFieldRef raft "Term"%go (![go.PointerType raft] "r"))))
      then
        (if: Convert go.untyped_bool go.bool (((![raftpb.MessageType] (StructFieldRef raftpb.Message "Type"%go "m")) =⟨go.int32⟩ raftpb.MsgVote) || ((![raftpb.MessageType] (StructFieldRef raftpb.Message "Type"%go "m")) =⟨go.int32⟩ raftpb.MsgPreVote))
        then
          let: "force" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
          let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] (StructFieldRef raftpb.Message "Context"%go "m")) in
          let: "$a1" := (Convert CampaignType (go.SliceType go.byte) campaignTransfer) in
          (FuncResolve bytes.Equal [] #()) "$a0" "$a1") in
          do:  ("force" <-[go.bool] "$r0");;;
          let: "inLease" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
          let: "$r0" := (((![go.bool] (StructFieldRef raft "checkQuorum"%go (![go.PointerType raft] "r"))) && ((![go.uint64] (StructFieldRef raft "lead"%go (![go.PointerType raft] "r"))) ≠⟨go.uint64⟩ None)) && ((![go.int] (StructFieldRef raft "electionElapsed"%go (![go.PointerType raft] "r"))) <⟨go.int⟩ (![go.int] (StructFieldRef raft "electionTimeout"%go (![go.PointerType raft] "r"))))) in
          do:  ("inLease" <-[go.bool] "$r0");;;
          (if: (~ (![go.bool] "force")) && (![go.bool] "inLease")
          then
            let: "last" := (GoAlloc entryID (GoZeroVal entryID #())) in
            let: "$r0" := ((MethodResolve (go.PointerType raftLog) "lastEntryID"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r")))) #()) in
            do:  ("last" <-[entryID] "$r0");;;
            do:  (let: "$a0" := #"%x [logterm: %d, index: %d, vote: %x] ignored %s from %x [logterm: %d, index: %d] at term %d: lease is not expired (remaining ticks: %d)"%go in
            let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))) in
            let: "$sl1" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef entryID "term"%go "last"))) in
            let: "$sl2" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef entryID "index"%go "last"))) in
            let: "$sl3" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "Vote"%go (![go.PointerType raft] "r")))) in
            let: "$sl4" := (Convert raftpb.MessageType (go.InterfaceType []) (![raftpb.MessageType] (StructFieldRef raftpb.Message "Type"%go "m"))) in
            let: "$sl5" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raftpb.Message "From"%go "m"))) in
            let: "$sl6" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raftpb.Message "LogTerm"%go "m"))) in
            let: "$sl7" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raftpb.Message "Index"%go "m"))) in
            let: "$sl8" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "Term"%go (![go.PointerType raft] "r")))) in
            let: "$sl9" := (Convert go.int (go.InterfaceType []) ((![go.int] (StructFieldRef raft "electionTimeout"%go (![go.PointerType raft] "r"))) -⟨go.int⟩ (![go.int] (StructFieldRef raft "electionElapsed"%go (![go.PointerType raft] "r"))))) in
            CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl2"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl3"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl4"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl5"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl6"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl7"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl8"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl9")]))) in
            (MethodResolve Logger "Infof"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0" "$a1");;;
            return: (Convert go.untyped_nil go.error UntypedNil)
          else do:  #())
        else do:  #());;;
        let: "$sw" := #true in
        (if: "$sw" =⟨go.bool⟩ ((![raftpb.MessageType] (StructFieldRef raftpb.Message "Type"%go "m")) =⟨go.int32⟩ raftpb.MsgPreVote)
        then do:  #()
        else
          (if: "$sw" =⟨go.bool⟩ (((![raftpb.MessageType] (StructFieldRef raftpb.Message "Type"%go "m")) =⟨go.int32⟩ raftpb.MsgPreVoteResp) && (~ (![go.bool] (StructFieldRef raftpb.Message "Reject"%go "m"))))
          then do:  #()
          else
            do:  (let: "$a0" := #"%x [term: %d] received a %s message with higher term from %x [term: %d]"%go in
            let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))) in
            let: "$sl1" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "Term"%go (![go.PointerType raft] "r")))) in
            let: "$sl2" := (Convert raftpb.MessageType (go.InterfaceType []) (![raftpb.MessageType] (StructFieldRef raftpb.Message "Type"%go "m"))) in
            let: "$sl3" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raftpb.Message "From"%go "m"))) in
            let: "$sl4" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raftpb.Message "Term"%go "m"))) in
            CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl2"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl3"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl4")]))) in
            (MethodResolve Logger "Infof"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0" "$a1");;;
            (if: Convert go.untyped_bool go.bool ((((![raftpb.MessageType] (StructFieldRef raftpb.Message "Type"%go "m")) =⟨go.int32⟩ raftpb.MsgApp) || ((![raftpb.MessageType] (StructFieldRef raftpb.Message "Type"%go "m")) =⟨go.int32⟩ raftpb.MsgHeartbeat)) || ((![raftpb.MessageType] (StructFieldRef raftpb.Message "Type"%go "m")) =⟨go.int32⟩ raftpb.MsgSnap))
            then
              do:  (let: "$a0" := (![go.uint64] (StructFieldRef raftpb.Message "Term"%go "m")) in
              let: "$a1" := (![go.uint64] (StructFieldRef raftpb.Message "From"%go "m")) in
              (MethodResolve (go.PointerType raft) "becomeFollower"%go (![go.PointerType raft] "r")) "$a0" "$a1")
            else
              do:  (let: "$a0" := (![go.uint64] (StructFieldRef raftpb.Message "Term"%go "m")) in
              let: "$a1" := None in
              (MethodResolve (go.PointerType raft) "becomeFollower"%go (![go.PointerType raft] "r")) "$a0" "$a1"))))
      else
        (if: "$sw" =⟨go.bool⟩ ((![go.uint64] (StructFieldRef raftpb.Message "Term"%go "m")) <⟨go.uint64⟩ (![go.uint64] (StructFieldRef raft "Term"%go (![go.PointerType raft] "r"))))
        then
          (if: ((![go.bool] (StructFieldRef raft "checkQuorum"%go (![go.PointerType raft] "r"))) || (![go.bool] (StructFieldRef raft "preVote"%go (![go.PointerType raft] "r")))) && (((![raftpb.MessageType] (StructFieldRef raftpb.Message "Type"%go "m")) =⟨go.int32⟩ raftpb.MsgHeartbeat) || ((![raftpb.MessageType] (StructFieldRef raftpb.Message "Type"%go "m")) =⟨go.int32⟩ raftpb.MsgApp))
          then
            do:  (let: "$a0" := (CompositeLiteral raftpb.Message (LiteralValue [KeyedElement (Some (KeyField "To"%go)) (ElementExpression go.uint64 (![go.uint64] (StructFieldRef raftpb.Message "From"%go "m"))); KeyedElement (Some (KeyField "Type"%go)) (ElementExpression raftpb.MessageType raftpb.MsgAppResp)])) in
            (MethodResolve (go.PointerType raft) "send"%go (![go.PointerType raft] "r")) "$a0")
          else
            (if: Convert go.untyped_bool go.bool ((![raftpb.MessageType] (StructFieldRef raftpb.Message "Type"%go "m")) =⟨go.int32⟩ raftpb.MsgPreVote)
            then
              let: "last" := (GoAlloc entryID (GoZeroVal entryID #())) in
              let: "$r0" := ((MethodResolve (go.PointerType raftLog) "lastEntryID"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r")))) #()) in
              do:  ("last" <-[entryID] "$r0");;;
              do:  (let: "$a0" := #"%x [logterm: %d, index: %d, vote: %x] rejected %s from %x [logterm: %d, index: %d] at term %d"%go in
              let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))) in
              let: "$sl1" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef entryID "term"%go "last"))) in
              let: "$sl2" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef entryID "index"%go "last"))) in
              let: "$sl3" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "Vote"%go (![go.PointerType raft] "r")))) in
              let: "$sl4" := (Convert raftpb.MessageType (go.InterfaceType []) (![raftpb.MessageType] (StructFieldRef raftpb.Message "Type"%go "m"))) in
              let: "$sl5" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raftpb.Message "From"%go "m"))) in
              let: "$sl6" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raftpb.Message "LogTerm"%go "m"))) in
              let: "$sl7" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raftpb.Message "Index"%go "m"))) in
              let: "$sl8" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "Term"%go (![go.PointerType raft] "r")))) in
              CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl2"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl3"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl4"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl5"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl6"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl7"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl8")]))) in
              (MethodResolve Logger "Infof"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0" "$a1");;;
              do:  (let: "$a0" := (CompositeLiteral raftpb.Message (LiteralValue [KeyedElement (Some (KeyField "To"%go)) (ElementExpression go.uint64 (![go.uint64] (StructFieldRef raftpb.Message "From"%go "m"))); KeyedElement (Some (KeyField "Term"%go)) (ElementExpression go.uint64 (![go.uint64] (StructFieldRef raft "Term"%go (![go.PointerType raft] "r")))); KeyedElement (Some (KeyField "Type"%go)) (ElementExpression raftpb.MessageType raftpb.MsgPreVoteResp); KeyedElement (Some (KeyField "Reject"%go)) (ElementExpression go.bool #true)])) in
              (MethodResolve (go.PointerType raft) "send"%go (![go.PointerType raft] "r")) "$a0")
            else
              (if: Convert go.untyped_bool go.bool ((![raftpb.MessageType] (StructFieldRef raftpb.Message "Type"%go "m")) =⟨go.int32⟩ raftpb.MsgStorageAppendResp)
              then
                (if: Convert go.untyped_bool go.bool ((![go.uint64] (StructFieldRef raftpb.Message "Index"%go "m")) ≠⟨go.uint64⟩ #(W64 0))
                then
                  do:  (let: "$a0" := #"%x [term: %d] ignored entry appends from a %s message with lower term [term: %d]"%go in
                  let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))) in
                  let: "$sl1" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "Term"%go (![go.PointerType raft] "r")))) in
                  let: "$sl2" := (Convert raftpb.MessageType (go.InterfaceType []) (![raftpb.MessageType] (StructFieldRef raftpb.Message "Type"%go "m"))) in
                  let: "$sl3" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raftpb.Message "Term"%go "m"))) in
                  CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl2"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl3")]))) in
                  (MethodResolve Logger "Infof"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0" "$a1")
                else do:  #());;;
                (if: Convert go.untyped_bool go.bool ((![go.PointerType raftpb.Snapshot] (StructFieldRef raftpb.Message "Snapshot"%go "m")) ≠⟨go.PointerType raftpb.Snapshot⟩ (Convert go.untyped_nil (go.PointerType raftpb.Snapshot) UntypedNil))
                then
                  do:  (let: "$a0" := (![go.PointerType raftpb.Snapshot] (StructFieldRef raftpb.Message "Snapshot"%go "m")) in
                  (MethodResolve (go.PointerType raft) "appliedSnap"%go (![go.PointerType raft] "r")) "$a0")
                else do:  #())
              else
                do:  (let: "$a0" := #"%x [term: %d] ignored a %s message with lower term from %x [term: %d]"%go in
                let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))) in
                let: "$sl1" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "Term"%go (![go.PointerType raft] "r")))) in
                let: "$sl2" := (Convert raftpb.MessageType (go.InterfaceType []) (![raftpb.MessageType] (StructFieldRef raftpb.Message "Type"%go "m"))) in
                let: "$sl3" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raftpb.Message "From"%go "m"))) in
                let: "$sl4" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raftpb.Message "Term"%go "m"))) in
                CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl2"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl3"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl4")]))) in
                (MethodResolve Logger "Infof"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0" "$a1"))));;;
          return: (Convert go.untyped_nil go.error UntypedNil)
        else do:  #())));;;
    let: "$sw" := (![raftpb.MessageType] (StructFieldRef raftpb.Message "Type"%go "m")) in
    (if: "$sw" =⟨raftpb.MessageType⟩ raftpb.MsgHup
    then
      (if: ![go.bool] (StructFieldRef raft "preVote"%go (![go.PointerType raft] "r"))
      then
        do:  (let: "$a0" := campaignPreElection in
        (MethodResolve (go.PointerType raft) "hup"%go (![go.PointerType raft] "r")) "$a0")
      else
        do:  (let: "$a0" := campaignElection in
        (MethodResolve (go.PointerType raft) "hup"%go (![go.PointerType raft] "r")) "$a0"))
    else
      (if: "$sw" =⟨raftpb.MessageType⟩ raftpb.MsgStorageAppendResp
      then
        (if: Convert go.untyped_bool go.bool ((![go.uint64] (StructFieldRef raftpb.Message "Index"%go "m")) ≠⟨go.uint64⟩ #(W64 0))
        then
          do:  (let: "$a0" := (CompositeLiteral entryID (LiteralValue [KeyedElement (Some (KeyField "term"%go)) (ElementExpression go.uint64 (![go.uint64] (StructFieldRef raftpb.Message "LogTerm"%go "m"))); KeyedElement (Some (KeyField "index"%go)) (ElementExpression go.uint64 (![go.uint64] (StructFieldRef raftpb.Message "Index"%go "m")))])) in
          (MethodResolve (go.PointerType raftLog) "stableTo"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r")))) "$a0")
        else do:  #());;;
        (if: Convert go.untyped_bool go.bool ((![go.PointerType raftpb.Snapshot] (StructFieldRef raftpb.Message "Snapshot"%go "m")) ≠⟨go.PointerType raftpb.Snapshot⟩ (Convert go.untyped_nil (go.PointerType raftpb.Snapshot) UntypedNil))
        then
          do:  (let: "$a0" := (![go.PointerType raftpb.Snapshot] (StructFieldRef raftpb.Message "Snapshot"%go "m")) in
          (MethodResolve (go.PointerType raft) "appliedSnap"%go (![go.PointerType raft] "r")) "$a0")
        else do:  #())
      else
        (if: "$sw" =⟨raftpb.MessageType⟩ raftpb.MsgStorageApplyResp
        then
          (if: Convert go.untyped_bool go.bool ((let: "$a0" := (![go.SliceType raftpb.Entry] (StructFieldRef raftpb.Message "Entries"%go "m")) in
          (FuncResolve go.len [go.SliceType raftpb.Entry] #()) "$a0") >⟨go.int⟩ #(W64 0))
          then
            let: "index" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
            let: "$r0" := (![go.uint64] (StructFieldRef raftpb.Entry "Index"%go (IndexRef (go.SliceType raftpb.Entry) (![go.SliceType raftpb.Entry] (StructFieldRef raftpb.Message "Entries"%go "m"), (let: "$a0" := (![go.SliceType raftpb.Entry] (StructFieldRef raftpb.Message "Entries"%go "m")) in
             (FuncResolve go.len [go.SliceType raftpb.Entry] #()) "$a0") -⟨go.int⟩ #(W64 1))))) in
            do:  ("index" <-[go.uint64] "$r0");;;
            do:  (let: "$a0" := (![go.uint64] "index") in
            let: "$a1" := (let: "$a0" := (![go.SliceType raftpb.Entry] (StructFieldRef raftpb.Message "Entries"%go "m")) in
            (FuncResolve entsSize [] #()) "$a0") in
            (MethodResolve (go.PointerType raft) "appliedTo"%go (![go.PointerType raft] "r")) "$a0" "$a1");;;
            do:  (let: "$a0" := (let: "$a0" := (![go.SliceType raftpb.Entry] (StructFieldRef raftpb.Message "Entries"%go "m")) in
            (FuncResolve payloadsSize [] #()) "$a0") in
            (MethodResolve (go.PointerType raft) "reduceUncommittedSize"%go (![go.PointerType raft] "r")) "$a0")
          else do:  #())
        else
          (if: ("$sw" =⟨raftpb.MessageType⟩ raftpb.MsgPreVote) || ("$sw" =⟨raftpb.MessageType⟩ raftpb.MsgVote)
          then
            let: "canVote" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
            let: "$r0" := ((((![go.uint64] (StructFieldRef raft "Vote"%go (![go.PointerType raft] "r"))) =⟨go.uint64⟩ (![go.uint64] (StructFieldRef raftpb.Message "From"%go "m"))) || (((![go.uint64] (StructFieldRef raft "Vote"%go (![go.PointerType raft] "r"))) =⟨go.uint64⟩ None) && ((![go.uint64] (StructFieldRef raft "lead"%go (![go.PointerType raft] "r"))) =⟨go.uint64⟩ None))) || (((![raftpb.MessageType] (StructFieldRef raftpb.Message "Type"%go "m")) =⟨go.int32⟩ raftpb.MsgPreVote) && ((![go.uint64] (StructFieldRef raftpb.Message "Term"%go "m")) >⟨go.uint64⟩ (![go.uint64] (StructFieldRef raft "Term"%go (![go.PointerType raft] "r")))))) in
            do:  ("canVote" <-[go.bool] "$r0");;;
            let: "lastID" := (GoAlloc entryID (GoZeroVal entryID #())) in
            let: "$r0" := ((MethodResolve (go.PointerType raftLog) "lastEntryID"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r")))) #()) in
            do:  ("lastID" <-[entryID] "$r0");;;
            let: "candLastID" := (GoAlloc entryID (GoZeroVal entryID #())) in
            let: "$r0" := (CompositeLiteral entryID (LiteralValue [KeyedElement (Some (KeyField "term"%go)) (ElementExpression go.uint64 (![go.uint64] (StructFieldRef raftpb.Message "LogTerm"%go "m"))); KeyedElement (Some (KeyField "index"%go)) (ElementExpression go.uint64 (![go.uint64] (StructFieldRef raftpb.Message "Index"%go "m")))])) in
            do:  ("candLastID" <-[entryID] "$r0");;;
            (if: (![go.bool] "canVote") && (let: "$a0" := (![entryID] "candLastID") in
            (MethodResolve (go.PointerType raftLog) "isUpToDate"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r")))) "$a0")
            then
              do:  (let: "$a0" := #"%x [logterm: %d, index: %d, vote: %x] cast %s for %x [logterm: %d, index: %d] at term %d"%go in
              let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))) in
              let: "$sl1" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef entryID "term"%go "lastID"))) in
              let: "$sl2" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef entryID "index"%go "lastID"))) in
              let: "$sl3" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "Vote"%go (![go.PointerType raft] "r")))) in
              let: "$sl4" := (Convert raftpb.MessageType (go.InterfaceType []) (![raftpb.MessageType] (StructFieldRef raftpb.Message "Type"%go "m"))) in
              let: "$sl5" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raftpb.Message "From"%go "m"))) in
              let: "$sl6" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef entryID "term"%go "candLastID"))) in
              let: "$sl7" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef entryID "index"%go "candLastID"))) in
              let: "$sl8" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "Term"%go (![go.PointerType raft] "r")))) in
              CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl2"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl3"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl4"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl5"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl6"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl7"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl8")]))) in
              (MethodResolve Logger "Infof"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0" "$a1");;;
              do:  (let: "$a0" := (CompositeLiteral raftpb.Message (LiteralValue [KeyedElement (Some (KeyField "To"%go)) (ElementExpression go.uint64 (![go.uint64] (StructFieldRef raftpb.Message "From"%go "m"))); KeyedElement (Some (KeyField "Term"%go)) (ElementExpression go.uint64 (![go.uint64] (StructFieldRef raftpb.Message "Term"%go "m"))); KeyedElement (Some (KeyField "Type"%go)) (ElementExpression raftpb.MessageType (let: "$a0" := (![raftpb.MessageType] (StructFieldRef raftpb.Message "Type"%go "m")) in
               (FuncResolve voteRespMsgType [] #()) "$a0"))])) in
              (MethodResolve (go.PointerType raft) "send"%go (![go.PointerType raft] "r")) "$a0");;;
              (if: Convert go.untyped_bool go.bool ((![raftpb.MessageType] (StructFieldRef raftpb.Message "Type"%go "m")) =⟨go.int32⟩ raftpb.MsgVote)
              then
                let: "$r0" := #(W64 0) in
                do:  ((StructFieldRef raft "electionElapsed"%go (![go.PointerType raft] "r")) <-[go.int] "$r0");;;
                let: "$r0" := (![go.uint64] (StructFieldRef raftpb.Message "From"%go "m")) in
                do:  ((StructFieldRef raft "Vote"%go (![go.PointerType raft] "r")) <-[go.uint64] "$r0")
              else do:  #())
            else
              do:  (let: "$a0" := #"%x [logterm: %d, index: %d, vote: %x] rejected %s from %x [logterm: %d, index: %d] at term %d"%go in
              let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))) in
              let: "$sl1" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef entryID "term"%go "lastID"))) in
              let: "$sl2" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef entryID "index"%go "lastID"))) in
              let: "$sl3" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "Vote"%go (![go.PointerType raft] "r")))) in
              let: "$sl4" := (Convert raftpb.MessageType (go.InterfaceType []) (![raftpb.MessageType] (StructFieldRef raftpb.Message "Type"%go "m"))) in
              let: "$sl5" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raftpb.Message "From"%go "m"))) in
              let: "$sl6" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef entryID "term"%go "candLastID"))) in
              let: "$sl7" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef entryID "index"%go "candLastID"))) in
              let: "$sl8" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "Term"%go (![go.PointerType raft] "r")))) in
              CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl2"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl3"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl4"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl5"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl6"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl7"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl8")]))) in
              (MethodResolve Logger "Infof"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0" "$a1");;;
              do:  (let: "$a0" := (CompositeLiteral raftpb.Message (LiteralValue [KeyedElement (Some (KeyField "To"%go)) (ElementExpression go.uint64 (![go.uint64] (StructFieldRef raftpb.Message "From"%go "m"))); KeyedElement (Some (KeyField "Term"%go)) (ElementExpression go.uint64 (![go.uint64] (StructFieldRef raft "Term"%go (![go.PointerType raft] "r")))); KeyedElement (Some (KeyField "Type"%go)) (ElementExpression raftpb.MessageType (let: "$a0" := (![raftpb.MessageType] (StructFieldRef raftpb.Message "Type"%go "m")) in
               (FuncResolve voteRespMsgType [] #()) "$a0")); KeyedElement (Some (KeyField "Reject"%go)) (ElementExpression go.bool #true)])) in
              (MethodResolve (go.PointerType raft) "send"%go (![go.PointerType raft] "r")) "$a0"))
          else
            let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
            let: "$r0" := (let: "$a0" := (![go.PointerType raft] "r") in
            let: "$a1" := (![raftpb.Message] "m") in
            (![stepFunc] (StructFieldRef raft "step"%go (![go.PointerType raft] "r"))) "$a0" "$a1") in
            do:  ("err" <-[go.error] "$r0");;;
            (if: Convert go.untyped_bool go.bool ((![go.error] "err") ≠⟨go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]⟩ (Convert go.untyped_nil (go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]) UntypedNil))
            then return: (![go.error] "err")
            else do:  #())))));;;
    return: (Convert go.untyped_nil go.error UntypedNil)).

(* go: raft.go:1267:6 *)
Definition stepLeaderⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "r" "m",
    exception_do (let: "m" := (GoAlloc raftpb.Message "m") in
    let: "r" := (GoAlloc (go.PointerType raft) "r") in
    let: "$sw" := (![raftpb.MessageType] (StructFieldRef raftpb.Message "Type"%go "m")) in
    (if: "$sw" =⟨raftpb.MessageType⟩ raftpb.MsgBeat
    then
      do:  ((MethodResolve (go.PointerType raft) "bcastHeartbeat"%go (![go.PointerType raft] "r")) #());;;
      return: (Convert go.untyped_nil go.error UntypedNil)
    else
      (if: "$sw" =⟨raftpb.MessageType⟩ raftpb.MsgCheckQuorum
      then
        (if: (~ ((MethodResolve (go.PointerType tracker.ProgressTracker) "QuorumActive"%go (StructFieldRef raft "trk"%go (![go.PointerType raft] "r"))) #()))
        then
          do:  (let: "$a0" := #"%x stepped down to follower since quorum is not active"%go in
          let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))) in
          CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0")]))) in
          (MethodResolve Logger "Warningf"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0" "$a1");;;
          do:  (let: "$a0" := (![go.uint64] (StructFieldRef raft "Term"%go (![go.PointerType raft] "r"))) in
          let: "$a1" := None in
          (MethodResolve (go.PointerType raft) "becomeFollower"%go (![go.PointerType raft] "r")) "$a0" "$a1")
        else do:  #());;;
        do:  (let: "$a0" := (λ: "id" "pr",
          exception_do (let: "pr" := (GoAlloc (go.PointerType tracker.Progress) "pr") in
          let: "id" := (GoAlloc go.uint64 "id") in
          (if: Convert go.untyped_bool go.bool ((![go.uint64] "id") ≠⟨go.uint64⟩ (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r"))))
          then
            let: "$r0" := #false in
            do:  ((StructFieldRef tracker.Progress "RecentActive"%go (![go.PointerType tracker.Progress] "pr")) <-[go.bool] "$r0")
          else do:  #());;;
          return: #())
          ) in
        (MethodResolve (go.PointerType tracker.ProgressTracker) "Visit"%go (StructFieldRef raft "trk"%go (![go.PointerType raft] "r"))) "$a0");;;
        return: (Convert go.untyped_nil go.error UntypedNil)
      else
        (if: "$sw" =⟨raftpb.MessageType⟩ raftpb.MsgProp
        then
          (if: Convert go.untyped_bool go.bool ((let: "$a0" := (![go.SliceType raftpb.Entry] (StructFieldRef raftpb.Message "Entries"%go "m")) in
          (FuncResolve go.len [go.SliceType raftpb.Entry] #()) "$a0") =⟨go.int⟩ #(W64 0))
          then
            do:  (let: "$a0" := #"%x stepped empty MsgProp"%go in
            let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))) in
            CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0")]))) in
            (MethodResolve Logger "Panicf"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0" "$a1")
          else do:  #());;;
          (if: Convert go.untyped_bool go.bool ((map.lookup1 go.uint64 (go.PointerType tracker.Progress) (![tracker.ProgressMap] (StructFieldRef tracker.ProgressTracker "Progress"%go (StructFieldRef raft "trk"%go (![go.PointerType raft] "r")))) (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))) =⟨go.PointerType tracker.Progress⟩ (Convert go.untyped_nil (go.PointerType tracker.Progress) UntypedNil))
          then return: (![go.error] (GlobalVarAddr ErrProposalDropped #()))
          else do:  #());;;
          (if: Convert go.untyped_bool go.bool ((![go.uint64] (StructFieldRef raft "leadTransferee"%go (![go.PointerType raft] "r"))) ≠⟨go.uint64⟩ None)
          then
            do:  (let: "$a0" := #"%x [term %d] transfer leadership to %x is in progress; dropping proposal"%go in
            let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))) in
            let: "$sl1" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "Term"%go (![go.PointerType raft] "r")))) in
            let: "$sl2" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "leadTransferee"%go (![go.PointerType raft] "r")))) in
            CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl2")]))) in
            (MethodResolve Logger "Debugf"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0" "$a1");;;
            return: (![go.error] (GlobalVarAddr ErrProposalDropped #()))
          else do:  #());;;
          let: "$range" := (![go.SliceType raftpb.Entry] (StructFieldRef raftpb.Message "Entries"%go "m")) in
          (let: "i" := (GoAlloc go.int (GoZeroVal go.int #())) in
          slice.for_range raftpb.Entry "$range" (λ: "$key" "$value",
            do:  ("i" <-[go.int] "$key");;;
            let: "e" := (GoAlloc (go.PointerType raftpb.Entry) (GoZeroVal (go.PointerType raftpb.Entry) #())) in
            let: "$r0" := (IndexRef raftpb.Entry (![go.SliceType raftpb.Entry] (StructFieldRef raftpb.Message "Entries"%go "m"), ![go.int] "i")) in
            do:  ("e" <-[go.PointerType raftpb.Entry] "$r0");;;
            let: "cc" := (GoAlloc raftpb.ConfChangeI (GoZeroVal raftpb.ConfChangeI #())) in
            (if: Convert go.untyped_bool go.bool ((![raftpb.EntryType] (StructFieldRef raftpb.Entry "Type"%go (![go.PointerType raftpb.Entry] "e"))) =⟨go.int32⟩ raftpb.EntryConfChange)
            then
              let: "ccc" := (GoAlloc raftpb.ConfChange (GoZeroVal raftpb.ConfChange #())) in
              (let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
              let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] (StructFieldRef raftpb.Entry "Data"%go (![go.PointerType raftpb.Entry] "e"))) in
              (MethodResolve (go.PointerType raftpb.ConfChange) "Unmarshal"%go "ccc") "$a0") in
              do:  ("err" <-[go.error] "$r0");;;
              (if: Convert go.untyped_bool go.bool ((![go.error] "err") ≠⟨go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]⟩ (Convert go.untyped_nil (go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]) UntypedNil))
              then
                do:  (let: "$a0" := (Convert go.error (go.InterfaceType []) (![go.error] "err")) in
                (FuncResolve go.panic [] #()) "$a0")
              else do:  #()));;;
              let: "$r0" := (Convert raftpb.ConfChange raftpb.ConfChangeI (![raftpb.ConfChange] "ccc")) in
              do:  ("cc" <-[raftpb.ConfChangeI] "$r0")
            else
              (if: Convert go.untyped_bool go.bool ((![raftpb.EntryType] (StructFieldRef raftpb.Entry "Type"%go (![go.PointerType raftpb.Entry] "e"))) =⟨go.int32⟩ raftpb.EntryConfChangeV2)
              then
                let: "ccc" := (GoAlloc raftpb.ConfChangeV2 (GoZeroVal raftpb.ConfChangeV2 #())) in
                (let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
                let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] (StructFieldRef raftpb.Entry "Data"%go (![go.PointerType raftpb.Entry] "e"))) in
                (MethodResolve (go.PointerType raftpb.ConfChangeV2) "Unmarshal"%go "ccc") "$a0") in
                do:  ("err" <-[go.error] "$r0");;;
                (if: Convert go.untyped_bool go.bool ((![go.error] "err") ≠⟨go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]⟩ (Convert go.untyped_nil (go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]) UntypedNil))
                then
                  do:  (let: "$a0" := (Convert go.error (go.InterfaceType []) (![go.error] "err")) in
                  (FuncResolve go.panic [] #()) "$a0")
                else do:  #()));;;
                let: "$r0" := (Convert raftpb.ConfChangeV2 raftpb.ConfChangeI (![raftpb.ConfChangeV2] "ccc")) in
                do:  ("cc" <-[raftpb.ConfChangeI] "$r0")
              else do:  #()));;;
            (if: Convert go.untyped_bool go.bool ((![raftpb.ConfChangeI] "cc") ≠⟨go.InterfaceType [go.MethodElem "AsV1"%go (go.Signature [] false [raftpb.ConfChange; go.bool]); go.MethodElem "AsV2"%go (go.Signature [] false [raftpb.ConfChangeV2])]⟩ (Convert go.untyped_nil (go.InterfaceType [go.MethodElem "AsV1"%go (go.Signature [] false [raftpb.ConfChange; go.bool]); go.MethodElem "AsV2"%go (go.Signature [] false [raftpb.ConfChangeV2])]) UntypedNil))
            then
              let: "alreadyPending" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
              let: "$r0" := ((![go.uint64] (StructFieldRef raft "pendingConfIndex"%go (![go.PointerType raft] "r"))) >⟨go.uint64⟩ (![go.uint64] (StructFieldRef raftLog "applied"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r")))))) in
              do:  ("alreadyPending" <-[go.bool] "$r0");;;
              let: "alreadyJoint" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
              let: "$r0" := ((let: "$a0" := (![quorum.MajorityConfig] (IndexRef quorum.JointConfig (![quorum.JointConfig] (StructFieldRef tracker.Config "Voters"%go (StructFieldRef tracker.ProgressTracker "Config"%go (StructFieldRef raft "trk"%go (![go.PointerType raft] "r")))), #(W64 1)))) in
              (FuncResolve go.len [quorum.MajorityConfig] #()) "$a0") >⟨go.int⟩ #(W64 0)) in
              do:  ("alreadyJoint" <-[go.bool] "$r0");;;
              let: "wantsLeaveJoint" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
              let: "$r0" := ((let: "$a0" := (StructFieldGet raftpb.ConfChangeV2 "Changes" ((MethodResolve raftpb.ConfChangeI "AsV2"%go (![raftpb.ConfChangeI] "cc")) #())) in
              (FuncResolve go.len [go.SliceType raftpb.ConfChangeSingle] #()) "$a0") =⟨go.int⟩ #(W64 0)) in
              do:  ("wantsLeaveJoint" <-[go.bool] "$r0");;;
              let: "failedCheck" := (GoAlloc go.string (GoZeroVal go.string #())) in
              (if: ![go.bool] "alreadyPending"
              then
                let: "$r0" := (let: "$a0" := #"possible unapplied conf change at index %d (applied to %d)"%go in
                let: "$a1" := ((let: "$sl0" := (Convert go.uint64 go.any (![go.uint64] (StructFieldRef raft "pendingConfIndex"%go (![go.PointerType raft] "r")))) in
                let: "$sl1" := (Convert go.uint64 go.any (![go.uint64] (StructFieldRef raftLog "applied"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r")))))) in
                CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0"); KeyedElement None (ElementExpression go.any "$sl1")]))) in
                (FuncResolve fmt.Sprintf [] #()) "$a0" "$a1") in
                do:  ("failedCheck" <-[go.string] "$r0")
              else
                (if: (![go.bool] "alreadyJoint") && (~ (![go.bool] "wantsLeaveJoint"))
                then
                  let: "$r0" := #"must transition out of joint config first"%go in
                  do:  ("failedCheck" <-[go.string] "$r0")
                else
                  (if: (~ (![go.bool] "alreadyJoint")) && (![go.bool] "wantsLeaveJoint")
                  then
                    let: "$r0" := #"not in joint state; refusing empty conf change"%go in
                    do:  ("failedCheck" <-[go.string] "$r0")
                  else do:  #())));;;
              (if: ((![go.string] "failedCheck") ≠⟨go.string⟩ #""%go) && (~ (![go.bool] (StructFieldRef raft "disableConfChangeValidation"%go (![go.PointerType raft] "r"))))
              then
                do:  (let: "$a0" := #"%x ignoring conf change %v at config %s: %s"%go in
                let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))) in
                let: "$sl1" := (Convert raftpb.ConfChangeI (go.InterfaceType []) (![raftpb.ConfChangeI] "cc")) in
                let: "$sl2" := (Convert tracker.Config (go.InterfaceType []) (![tracker.Config] (StructFieldRef tracker.ProgressTracker "Config"%go (StructFieldRef raft "trk"%go (![go.PointerType raft] "r"))))) in
                let: "$sl3" := (Convert go.string (go.InterfaceType []) (![go.string] "failedCheck")) in
                CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl2"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl3")]))) in
                (MethodResolve Logger "Infof"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0" "$a1");;;
                let: "$r0" := (CompositeLiteral raftpb.Entry (LiteralValue [KeyedElement (Some (KeyField "Type"%go)) (ElementExpression raftpb.EntryType raftpb.EntryNormal)])) in
                do:  ((IndexRef (go.SliceType raftpb.Entry) (![go.SliceType raftpb.Entry] (StructFieldRef raftpb.Message "Entries"%go "m"), ![go.int] "i")) <-[raftpb.Entry] "$r0")
              else
                let: "$r0" := ((((MethodResolve (go.PointerType raftLog) "lastIndex"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r")))) #()) +⟨go.uint64⟩ (Convert go.int go.uint64 (![go.int] "i"))) +⟨go.uint64⟩ #(W64 1)) in
                do:  ((StructFieldRef raft "pendingConfIndex"%go (![go.PointerType raft] "r")) <-[go.uint64] "$r0");;;
                do:  (let: "$a0" := (![raftpb.ConfChangeI] "cc") in
                let: "$a1" := (![go.PointerType raft] "r") in
                (FuncResolve traceChangeConfEvent [] #()) "$a0" "$a1"))
            else do:  #())));;;
          (if: (~ (let: "$a0" := (![go.SliceType raftpb.Entry] (StructFieldRef raftpb.Message "Entries"%go "m")) in
          (MethodResolve (go.PointerType raft) "appendEntry"%go (![go.PointerType raft] "r")) "$a0"))
          then return: (![go.error] (GlobalVarAddr ErrProposalDropped #()))
          else do:  #());;;
          do:  ((MethodResolve (go.PointerType raft) "bcastAppend"%go (![go.PointerType raft] "r")) #());;;
          return: (Convert go.untyped_nil go.error UntypedNil)
        else
          (if: "$sw" =⟨raftpb.MessageType⟩ raftpb.MsgReadIndex
          then
            (if: (MethodResolve (go.PointerType tracker.ProgressTracker) "IsSingleton"%go (StructFieldRef raft "trk"%go (![go.PointerType raft] "r"))) #()
            then
              (let: "resp" := (GoAlloc raftpb.Message (GoZeroVal raftpb.Message #())) in
              let: "$r0" := (let: "$a0" := (![raftpb.Message] "m") in
              let: "$a1" := (![go.uint64] (StructFieldRef raftLog "committed"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r"))))) in
              (MethodResolve (go.PointerType raft) "responseToReadIndexReq"%go (![go.PointerType raft] "r")) "$a0" "$a1") in
              do:  ("resp" <-[raftpb.Message] "$r0");;;
              (if: Convert go.untyped_bool go.bool ((![go.uint64] (StructFieldRef raftpb.Message "To"%go "resp")) ≠⟨go.uint64⟩ None)
              then
                do:  (let: "$a0" := (![raftpb.Message] "resp") in
                (MethodResolve (go.PointerType raft) "send"%go (![go.PointerType raft] "r")) "$a0")
              else do:  #()));;;
              return: (Convert go.untyped_nil go.error UntypedNil)
            else do:  #());;;
            (if: (~ ((MethodResolve (go.PointerType raft) "committedEntryInCurrentTerm"%go (![go.PointerType raft] "r")) #()))
            then
              let: "$r0" := (let: "$a0" := (![go.SliceType raftpb.Message] (StructFieldRef raft "pendingReadIndexMessages"%go (![go.PointerType raft] "r"))) in
              let: "$a1" := ((let: "$sl0" := (![raftpb.Message] "m") in
              CompositeLiteral (go.SliceType raftpb.Message) (LiteralValue [KeyedElement None (ElementExpression raftpb.Message "$sl0")]))) in
              (FuncResolve go.append [go.SliceType raftpb.Message] #()) "$a0" "$a1") in
              do:  ((StructFieldRef raft "pendingReadIndexMessages"%go (![go.PointerType raft] "r")) <-[go.SliceType raftpb.Message] "$r0");;;
              return: (Convert go.untyped_nil go.error UntypedNil)
            else do:  #());;;
            do:  (let: "$a0" := (![go.PointerType raft] "r") in
            let: "$a1" := (![raftpb.Message] "m") in
            (FuncResolve sendMsgReadIndexResponse [] #()) "$a0" "$a1");;;
            return: (Convert go.untyped_nil go.error UntypedNil)
          else
            (if: "$sw" =⟨raftpb.MessageType⟩ raftpb.MsgForgetLeader
            then return: (Convert go.untyped_nil go.error UntypedNil)
            else do:  #())))));;;
    let: "pr" := (GoAlloc (go.PointerType tracker.Progress) (GoZeroVal (go.PointerType tracker.Progress) #())) in
    let: "$r0" := (map.lookup1 go.uint64 (go.PointerType tracker.Progress) (![tracker.ProgressMap] (StructFieldRef tracker.ProgressTracker "Progress"%go (StructFieldRef raft "trk"%go (![go.PointerType raft] "r")))) (![go.uint64] (StructFieldRef raftpb.Message "From"%go "m"))) in
    do:  ("pr" <-[go.PointerType tracker.Progress] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.PointerType tracker.Progress] "pr") =⟨go.PointerType tracker.Progress⟩ (Convert go.untyped_nil (go.PointerType tracker.Progress) UntypedNil))
    then
      do:  (let: "$a0" := #"%x no progress available for %x"%go in
      let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))) in
      let: "$sl1" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raftpb.Message "From"%go "m"))) in
      CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1")]))) in
      (MethodResolve Logger "Debugf"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0" "$a1");;;
      return: (Convert go.untyped_nil go.error UntypedNil)
    else do:  #());;;
    let: "$sw" := (![raftpb.MessageType] (StructFieldRef raftpb.Message "Type"%go "m")) in
    (if: "$sw" =⟨raftpb.MessageType⟩ raftpb.MsgAppResp
    then
      let: "$r0" := #true in
      do:  ((StructFieldRef tracker.Progress "RecentActive"%go (![go.PointerType tracker.Progress] "pr")) <-[go.bool] "$r0");;;
      (if: ![go.bool] (StructFieldRef raftpb.Message "Reject"%go "m")
      then
        do:  (let: "$a0" := #"%x received MsgAppResp(rejected, hint: (index %d, term %d)) from %x for index %d"%go in
        let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))) in
        let: "$sl1" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raftpb.Message "RejectHint"%go "m"))) in
        let: "$sl2" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raftpb.Message "LogTerm"%go "m"))) in
        let: "$sl3" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raftpb.Message "From"%go "m"))) in
        let: "$sl4" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raftpb.Message "Index"%go "m"))) in
        CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl2"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl3"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl4")]))) in
        (MethodResolve Logger "Debugf"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0" "$a1");;;
        let: "nextProbeIdx" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
        let: "$r0" := (![go.uint64] (StructFieldRef raftpb.Message "RejectHint"%go "m")) in
        do:  ("nextProbeIdx" <-[go.uint64] "$r0");;;
        (if: Convert go.untyped_bool go.bool ((![go.uint64] (StructFieldRef raftpb.Message "LogTerm"%go "m")) >⟨go.uint64⟩ #(W64 0))
        then
          let: ("$ret0", "$ret1") := (let: "$a0" := (![go.uint64] (StructFieldRef raftpb.Message "RejectHint"%go "m")) in
          let: "$a1" := (![go.uint64] (StructFieldRef raftpb.Message "LogTerm"%go "m")) in
          (MethodResolve (go.PointerType raftLog) "findConflictByTerm"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r")))) "$a0" "$a1") in
          let: "$r0" := "$ret0" in
          let: "$r1" := "$ret1" in
          do:  ("nextProbeIdx" <-[go.uint64] "$r0");;;
          do:  "$r1"
        else do:  #());;;
        (if: let: "$a0" := (![go.uint64] (StructFieldRef raftpb.Message "Index"%go "m")) in
        let: "$a1" := (![go.uint64] "nextProbeIdx") in
        (MethodResolve (go.PointerType tracker.Progress) "MaybeDecrTo"%go (![go.PointerType tracker.Progress] "pr")) "$a0" "$a1"
        then
          do:  (let: "$a0" := #"%x decreased progress of %x to [%s]"%go in
          let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))) in
          let: "$sl1" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raftpb.Message "From"%go "m"))) in
          let: "$sl2" := (Convert (go.PointerType tracker.Progress) (go.InterfaceType []) (![go.PointerType tracker.Progress] "pr")) in
          CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl2")]))) in
          (MethodResolve Logger "Debugf"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0" "$a1");;;
          (if: Convert go.untyped_bool go.bool ((![tracker.StateType] (StructFieldRef tracker.Progress "State"%go (![go.PointerType tracker.Progress] "pr"))) =⟨go.uint64⟩ tracker.StateReplicate)
          then do:  ((MethodResolve (go.PointerType tracker.Progress) "BecomeProbe"%go (![go.PointerType tracker.Progress] "pr")) #())
          else do:  #());;;
          do:  (let: "$a0" := (![go.uint64] (StructFieldRef raftpb.Message "From"%go "m")) in
          (MethodResolve (go.PointerType raft) "sendAppend"%go (![go.PointerType raft] "r")) "$a0")
        else do:  #())
      else
        (if: (let: "$a0" := (![go.uint64] (StructFieldRef raftpb.Message "Index"%go "m")) in
        (MethodResolve (go.PointerType tracker.Progress) "MaybeUpdate"%go (![go.PointerType tracker.Progress] "pr")) "$a0") || (((![go.uint64] (StructFieldRef tracker.Progress "Match"%go (![go.PointerType tracker.Progress] "pr"))) =⟨go.uint64⟩ (![go.uint64] (StructFieldRef raftpb.Message "Index"%go "m"))) && ((![tracker.StateType] (StructFieldRef tracker.Progress "State"%go (![go.PointerType tracker.Progress] "pr"))) =⟨go.uint64⟩ tracker.StateProbe))
        then
          let: "$sw" := #true in
          (if: "$sw" =⟨go.bool⟩ ((![tracker.StateType] (StructFieldRef tracker.Progress "State"%go (![go.PointerType tracker.Progress] "pr"))) =⟨go.uint64⟩ tracker.StateProbe)
          then do:  ((MethodResolve (go.PointerType tracker.Progress) "BecomeReplicate"%go (![go.PointerType tracker.Progress] "pr")) #())
          else
            (if: "$sw" =⟨go.bool⟩ (((![tracker.StateType] (StructFieldRef tracker.Progress "State"%go (![go.PointerType tracker.Progress] "pr"))) =⟨go.uint64⟩ tracker.StateSnapshot) && (((![go.uint64] (StructFieldRef tracker.Progress "Match"%go (![go.PointerType tracker.Progress] "pr"))) +⟨go.uint64⟩ #(W64 1)) ≥⟨go.uint64⟩ ((MethodResolve (go.PointerType raftLog) "firstIndex"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r")))) #())))
            then
              do:  (let: "$a0" := #"%x recovered from needing snapshot, resumed sending replication messages to %x [%s]"%go in
              let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))) in
              let: "$sl1" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raftpb.Message "From"%go "m"))) in
              let: "$sl2" := (Convert (go.PointerType tracker.Progress) (go.InterfaceType []) (![go.PointerType tracker.Progress] "pr")) in
              CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl2")]))) in
              (MethodResolve Logger "Debugf"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0" "$a1");;;
              do:  ((MethodResolve (go.PointerType tracker.Progress) "BecomeProbe"%go (![go.PointerType tracker.Progress] "pr")) #());;;
              do:  ((MethodResolve (go.PointerType tracker.Progress) "BecomeReplicate"%go (![go.PointerType tracker.Progress] "pr")) #())
            else
              (if: "$sw" =⟨go.bool⟩ ((![tracker.StateType] (StructFieldRef tracker.Progress "State"%go (![go.PointerType tracker.Progress] "pr"))) =⟨go.uint64⟩ tracker.StateReplicate)
              then
                do:  (let: "$a0" := (![go.uint64] (StructFieldRef raftpb.Message "Index"%go "m")) in
                (MethodResolve (go.PointerType tracker.Inflights) "FreeLE"%go (![go.PointerType tracker.Inflights] (StructFieldRef tracker.Progress "Inflights"%go (![go.PointerType tracker.Progress] "pr")))) "$a0")
              else do:  #())));;;
          (if: (MethodResolve (go.PointerType raft) "maybeCommit"%go (![go.PointerType raft] "r")) #()
          then
            do:  (let: "$a0" := (![go.PointerType raft] "r") in
            (FuncResolve releasePendingReadIndexMessages [] #()) "$a0");;;
            do:  ((MethodResolve (go.PointerType raft) "bcastAppend"%go (![go.PointerType raft] "r")) #())
          else
            (if: ((![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r"))) ≠⟨go.uint64⟩ (![go.uint64] (StructFieldRef raftpb.Message "From"%go "m"))) && (let: "$a0" := (![go.uint64] (StructFieldRef raftLog "committed"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r"))))) in
            (MethodResolve (go.PointerType tracker.Progress) "CanBumpCommit"%go (![go.PointerType tracker.Progress] "pr")) "$a0")
            then
              do:  (let: "$a0" := (![go.uint64] (StructFieldRef raftpb.Message "From"%go "m")) in
              (MethodResolve (go.PointerType raft) "sendAppend"%go (![go.PointerType raft] "r")) "$a0")
            else do:  #()));;;
          (if: Convert go.untyped_bool go.bool ((![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r"))) ≠⟨go.uint64⟩ (![go.uint64] (StructFieldRef raftpb.Message "From"%go "m")))
          then
            (for: (λ: <>, let: "$a0" := (![go.uint64] (StructFieldRef raftpb.Message "From"%go "m")) in
            let: "$a1" := #false in
            (MethodResolve (go.PointerType raft) "maybeSendAppend"%go (![go.PointerType raft] "r")) "$a0" "$a1"); (λ: <>, #()) := λ: <>,
              do:  #())
          else do:  #());;;
          (if: Convert go.untyped_bool go.bool (((![go.uint64] (StructFieldRef raftpb.Message "From"%go "m")) =⟨go.uint64⟩ (![go.uint64] (StructFieldRef raft "leadTransferee"%go (![go.PointerType raft] "r")))) && ((![go.uint64] (StructFieldRef tracker.Progress "Match"%go (![go.PointerType tracker.Progress] "pr"))) =⟨go.uint64⟩ ((MethodResolve (go.PointerType raftLog) "lastIndex"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r")))) #())))
          then
            do:  (let: "$a0" := #"%x sent MsgTimeoutNow to %x after received MsgAppResp"%go in
            let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))) in
            let: "$sl1" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raftpb.Message "From"%go "m"))) in
            CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1")]))) in
            (MethodResolve Logger "Infof"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0" "$a1");;;
            do:  (let: "$a0" := (![go.uint64] (StructFieldRef raftpb.Message "From"%go "m")) in
            (MethodResolve (go.PointerType raft) "sendTimeoutNow"%go (![go.PointerType raft] "r")) "$a0")
          else do:  #())
        else do:  #()))
    else
      (if: "$sw" =⟨raftpb.MessageType⟩ raftpb.MsgHeartbeatResp
      then
        let: "$r0" := #true in
        do:  ((StructFieldRef tracker.Progress "RecentActive"%go (![go.PointerType tracker.Progress] "pr")) <-[go.bool] "$r0");;;
        let: "$r0" := #false in
        do:  ((StructFieldRef tracker.Progress "MsgAppFlowPaused"%go (![go.PointerType tracker.Progress] "pr")) <-[go.bool] "$r0");;;
        (if: Convert go.untyped_bool go.bool (((![go.uint64] (StructFieldRef tracker.Progress "Match"%go (![go.PointerType tracker.Progress] "pr"))) <⟨go.uint64⟩ ((MethodResolve (go.PointerType raftLog) "lastIndex"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r")))) #())) || ((![tracker.StateType] (StructFieldRef tracker.Progress "State"%go (![go.PointerType tracker.Progress] "pr"))) =⟨go.uint64⟩ tracker.StateProbe))
        then
          do:  (let: "$a0" := (![go.uint64] (StructFieldRef raftpb.Message "From"%go "m")) in
          (MethodResolve (go.PointerType raft) "sendAppend"%go (![go.PointerType raft] "r")) "$a0")
        else do:  #());;;
        (if: Convert go.untyped_bool go.bool (((![ReadOnlyOption] (StructFieldRef readOnly "option"%go (![go.PointerType readOnly] (StructFieldRef raft "readOnly"%go (![go.PointerType raft] "r"))))) ≠⟨go.int⟩ ReadOnlySafe) || ((let: "$a0" := (![go.SliceType go.byte] (StructFieldRef raftpb.Message "Context"%go "m")) in
        (FuncResolve go.len [go.SliceType go.byte] #()) "$a0") =⟨go.int⟩ #(W64 0)))
        then return: (Convert go.untyped_nil go.error UntypedNil)
        else do:  #());;;
        (if: Convert go.untyped_bool go.bool ((let: "$a0" := (let: "$a0" := (![go.uint64] (StructFieldRef raftpb.Message "From"%go "m")) in
        let: "$a1" := (![go.SliceType go.byte] (StructFieldRef raftpb.Message "Context"%go "m")) in
        (MethodResolve (go.PointerType readOnly) "recvAck"%go (![go.PointerType readOnly] (StructFieldRef raft "readOnly"%go (![go.PointerType raft] "r")))) "$a0" "$a1") in
        (MethodResolve quorum.JointConfig "VoteResult"%go (![quorum.JointConfig] (StructFieldRef tracker.Config "Voters"%go (StructFieldRef tracker.ProgressTracker "Config"%go (StructFieldRef raft "trk"%go (![go.PointerType raft] "r")))))) "$a0") ≠⟨go.uint8⟩ quorum.VoteWon)
        then return: (Convert go.untyped_nil go.error UntypedNil)
        else do:  #());;;
        let: "rss" := (GoAlloc (go.SliceType (go.PointerType readIndexStatus)) (GoZeroVal (go.SliceType (go.PointerType readIndexStatus)) #())) in
        let: "$r0" := (let: "$a0" := (![raftpb.Message] "m") in
        (MethodResolve (go.PointerType readOnly) "advance"%go (![go.PointerType readOnly] (StructFieldRef raft "readOnly"%go (![go.PointerType raft] "r")))) "$a0") in
        do:  ("rss" <-[go.SliceType (go.PointerType readIndexStatus)] "$r0");;;
        let: "$range" := (![go.SliceType (go.PointerType readIndexStatus)] "rss") in
        (let: "rs" := (GoAlloc (go.PointerType readIndexStatus) (GoZeroVal (go.PointerType readIndexStatus) #())) in
        slice.for_range (go.PointerType readIndexStatus) "$range" (λ: "$key" "$value",
          do:  ("rs" <-[go.PointerType readIndexStatus] "$value");;;
          do:  "$key";;;
          (let: "resp" := (GoAlloc raftpb.Message (GoZeroVal raftpb.Message #())) in
          let: "$r0" := (let: "$a0" := (![raftpb.Message] (StructFieldRef readIndexStatus "req"%go (![go.PointerType readIndexStatus] "rs"))) in
          let: "$a1" := (![go.uint64] (StructFieldRef readIndexStatus "index"%go (![go.PointerType readIndexStatus] "rs"))) in
          (MethodResolve (go.PointerType raft) "responseToReadIndexReq"%go (![go.PointerType raft] "r")) "$a0" "$a1") in
          do:  ("resp" <-[raftpb.Message] "$r0");;;
          (if: Convert go.untyped_bool go.bool ((![go.uint64] (StructFieldRef raftpb.Message "To"%go "resp")) ≠⟨go.uint64⟩ None)
          then
            do:  (let: "$a0" := (![raftpb.Message] "resp") in
            (MethodResolve (go.PointerType raft) "send"%go (![go.PointerType raft] "r")) "$a0")
          else do:  #()))))
      else
        (if: "$sw" =⟨raftpb.MessageType⟩ raftpb.MsgSnapStatus
        then
          (if: Convert go.untyped_bool go.bool ((![tracker.StateType] (StructFieldRef tracker.Progress "State"%go (![go.PointerType tracker.Progress] "pr"))) ≠⟨go.uint64⟩ tracker.StateSnapshot)
          then return: (Convert go.untyped_nil go.error UntypedNil)
          else do:  #());;;
          (if: (~ (![go.bool] (StructFieldRef raftpb.Message "Reject"%go "m")))
          then
            do:  ((MethodResolve (go.PointerType tracker.Progress) "BecomeProbe"%go (![go.PointerType tracker.Progress] "pr")) #());;;
            do:  (let: "$a0" := #"%x snapshot succeeded, resumed sending replication messages to %x [%s]"%go in
            let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))) in
            let: "$sl1" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raftpb.Message "From"%go "m"))) in
            let: "$sl2" := (Convert (go.PointerType tracker.Progress) (go.InterfaceType []) (![go.PointerType tracker.Progress] "pr")) in
            CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl2")]))) in
            (MethodResolve Logger "Debugf"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0" "$a1")
          else
            let: "$r0" := #(W64 0) in
            do:  ((StructFieldRef tracker.Progress "PendingSnapshot"%go (![go.PointerType tracker.Progress] "pr")) <-[go.uint64] "$r0");;;
            do:  ((MethodResolve (go.PointerType tracker.Progress) "BecomeProbe"%go (![go.PointerType tracker.Progress] "pr")) #());;;
            do:  (let: "$a0" := #"%x snapshot failed, resumed sending replication messages to %x [%s]"%go in
            let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))) in
            let: "$sl1" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raftpb.Message "From"%go "m"))) in
            let: "$sl2" := (Convert (go.PointerType tracker.Progress) (go.InterfaceType []) (![go.PointerType tracker.Progress] "pr")) in
            CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl2")]))) in
            (MethodResolve Logger "Debugf"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0" "$a1"));;;
          let: "$r0" := #true in
          do:  ((StructFieldRef tracker.Progress "MsgAppFlowPaused"%go (![go.PointerType tracker.Progress] "pr")) <-[go.bool] "$r0")
        else
          (if: "$sw" =⟨raftpb.MessageType⟩ raftpb.MsgUnreachable
          then
            (if: Convert go.untyped_bool go.bool ((![tracker.StateType] (StructFieldRef tracker.Progress "State"%go (![go.PointerType tracker.Progress] "pr"))) =⟨go.uint64⟩ tracker.StateReplicate)
            then do:  ((MethodResolve (go.PointerType tracker.Progress) "BecomeProbe"%go (![go.PointerType tracker.Progress] "pr")) #())
            else do:  #());;;
            do:  (let: "$a0" := #"%x failed to send message to %x because it is unreachable [%s]"%go in
            let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))) in
            let: "$sl1" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raftpb.Message "From"%go "m"))) in
            let: "$sl2" := (Convert (go.PointerType tracker.Progress) (go.InterfaceType []) (![go.PointerType tracker.Progress] "pr")) in
            CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl2")]))) in
            (MethodResolve Logger "Debugf"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0" "$a1")
          else
            (if: "$sw" =⟨raftpb.MessageType⟩ raftpb.MsgTransferLeader
            then
              (if: ![go.bool] (StructFieldRef tracker.Progress "IsLearner"%go (![go.PointerType tracker.Progress] "pr"))
              then
                do:  (let: "$a0" := #"%x is learner. Ignored transferring leadership"%go in
                let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))) in
                CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0")]))) in
                (MethodResolve Logger "Debugf"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0" "$a1");;;
                return: (Convert go.untyped_nil go.error UntypedNil)
              else do:  #());;;
              let: "leadTransferee" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
              let: "$r0" := (![go.uint64] (StructFieldRef raftpb.Message "From"%go "m")) in
              do:  ("leadTransferee" <-[go.uint64] "$r0");;;
              let: "lastLeadTransferee" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
              let: "$r0" := (![go.uint64] (StructFieldRef raft "leadTransferee"%go (![go.PointerType raft] "r"))) in
              do:  ("lastLeadTransferee" <-[go.uint64] "$r0");;;
              (if: Convert go.untyped_bool go.bool ((![go.uint64] "lastLeadTransferee") ≠⟨go.uint64⟩ None)
              then
                (if: Convert go.untyped_bool go.bool ((![go.uint64] "lastLeadTransferee") =⟨go.uint64⟩ (![go.uint64] "leadTransferee"))
                then
                  do:  (let: "$a0" := #"%x [term %d] transfer leadership to %x is in progress, ignores request to same node %x"%go in
                  let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))) in
                  let: "$sl1" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "Term"%go (![go.PointerType raft] "r")))) in
                  let: "$sl2" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] "leadTransferee")) in
                  let: "$sl3" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] "leadTransferee")) in
                  CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl2"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl3")]))) in
                  (MethodResolve Logger "Infof"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0" "$a1");;;
                  return: (Convert go.untyped_nil go.error UntypedNil)
                else do:  #());;;
                do:  ((MethodResolve (go.PointerType raft) "abortLeaderTransfer"%go (![go.PointerType raft] "r")) #());;;
                do:  (let: "$a0" := #"%x [term %d] abort previous transferring leadership to %x"%go in
                let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))) in
                let: "$sl1" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "Term"%go (![go.PointerType raft] "r")))) in
                let: "$sl2" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] "lastLeadTransferee")) in
                CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl2")]))) in
                (MethodResolve Logger "Infof"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0" "$a1")
              else do:  #());;;
              (if: Convert go.untyped_bool go.bool ((![go.uint64] "leadTransferee") =⟨go.uint64⟩ (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r"))))
              then
                do:  (let: "$a0" := #"%x is already leader. Ignored transferring leadership to self"%go in
                let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))) in
                CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0")]))) in
                (MethodResolve Logger "Debugf"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0" "$a1");;;
                return: (Convert go.untyped_nil go.error UntypedNil)
              else do:  #());;;
              do:  (let: "$a0" := #"%x [term %d] starts to transfer leadership to %x"%go in
              let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))) in
              let: "$sl1" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "Term"%go (![go.PointerType raft] "r")))) in
              let: "$sl2" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] "leadTransferee")) in
              CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl2")]))) in
              (MethodResolve Logger "Infof"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0" "$a1");;;
              let: "$r0" := #(W64 0) in
              do:  ((StructFieldRef raft "electionElapsed"%go (![go.PointerType raft] "r")) <-[go.int] "$r0");;;
              let: "$r0" := (![go.uint64] "leadTransferee") in
              do:  ((StructFieldRef raft "leadTransferee"%go (![go.PointerType raft] "r")) <-[go.uint64] "$r0");;;
              (if: Convert go.untyped_bool go.bool ((![go.uint64] (StructFieldRef tracker.Progress "Match"%go (![go.PointerType tracker.Progress] "pr"))) =⟨go.uint64⟩ ((MethodResolve (go.PointerType raftLog) "lastIndex"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r")))) #()))
              then
                do:  (let: "$a0" := (![go.uint64] "leadTransferee") in
                (MethodResolve (go.PointerType raft) "sendTimeoutNow"%go (![go.PointerType raft] "r")) "$a0");;;
                do:  (let: "$a0" := #"%x sends MsgTimeoutNow to %x immediately as %x already has up-to-date log"%go in
                let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))) in
                let: "$sl1" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] "leadTransferee")) in
                let: "$sl2" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] "leadTransferee")) in
                CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl2")]))) in
                (MethodResolve Logger "Infof"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0" "$a1")
              else
                do:  (let: "$a0" := (![go.uint64] "leadTransferee") in
                (MethodResolve (go.PointerType raft) "sendAppend"%go (![go.PointerType raft] "r")) "$a0"))
            else do:  #())))));;;
    return: (Convert go.untyped_nil go.error UntypedNil)).

(* stepCandidate is shared by StateCandidate and StatePreCandidate; the difference is
   whether they respond to MsgVoteResp or MsgPreVoteResp.

   go: raft.go:1668:6 *)
Definition stepCandidateⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "r" "m",
    exception_do (let: "m" := (GoAlloc raftpb.Message "m") in
    let: "r" := (GoAlloc (go.PointerType raft) "r") in
    let: "myVoteRespType" := (GoAlloc raftpb.MessageType (GoZeroVal raftpb.MessageType #())) in
    (if: Convert go.untyped_bool go.bool ((![StateType] (StructFieldRef raft "state"%go (![go.PointerType raft] "r"))) =⟨go.uint64⟩ StatePreCandidate)
    then
      let: "$r0" := raftpb.MsgPreVoteResp in
      do:  ("myVoteRespType" <-[raftpb.MessageType] "$r0")
    else
      let: "$r0" := raftpb.MsgVoteResp in
      do:  ("myVoteRespType" <-[raftpb.MessageType] "$r0"));;;
    let: "$sw" := (![raftpb.MessageType] (StructFieldRef raftpb.Message "Type"%go "m")) in
    (if: "$sw" =⟨raftpb.MessageType⟩ raftpb.MsgProp
    then
      do:  (let: "$a0" := #"%x no leader at term %d; dropping proposal"%go in
      let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))) in
      let: "$sl1" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "Term"%go (![go.PointerType raft] "r")))) in
      CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1")]))) in
      (MethodResolve Logger "Infof"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0" "$a1");;;
      return: (![go.error] (GlobalVarAddr ErrProposalDropped #()))
    else
      (if: "$sw" =⟨raftpb.MessageType⟩ raftpb.MsgApp
      then
        do:  (let: "$a0" := (![go.uint64] (StructFieldRef raftpb.Message "Term"%go "m")) in
        let: "$a1" := (![go.uint64] (StructFieldRef raftpb.Message "From"%go "m")) in
        (MethodResolve (go.PointerType raft) "becomeFollower"%go (![go.PointerType raft] "r")) "$a0" "$a1");;;
        do:  (let: "$a0" := (![raftpb.Message] "m") in
        (MethodResolve (go.PointerType raft) "handleAppendEntries"%go (![go.PointerType raft] "r")) "$a0")
      else
        (if: "$sw" =⟨raftpb.MessageType⟩ raftpb.MsgHeartbeat
        then
          do:  (let: "$a0" := (![go.uint64] (StructFieldRef raftpb.Message "Term"%go "m")) in
          let: "$a1" := (![go.uint64] (StructFieldRef raftpb.Message "From"%go "m")) in
          (MethodResolve (go.PointerType raft) "becomeFollower"%go (![go.PointerType raft] "r")) "$a0" "$a1");;;
          do:  (let: "$a0" := (![raftpb.Message] "m") in
          (MethodResolve (go.PointerType raft) "handleHeartbeat"%go (![go.PointerType raft] "r")) "$a0")
        else
          (if: "$sw" =⟨raftpb.MessageType⟩ raftpb.MsgSnap
          then
            do:  (let: "$a0" := (![go.uint64] (StructFieldRef raftpb.Message "Term"%go "m")) in
            let: "$a1" := (![go.uint64] (StructFieldRef raftpb.Message "From"%go "m")) in
            (MethodResolve (go.PointerType raft) "becomeFollower"%go (![go.PointerType raft] "r")) "$a0" "$a1");;;
            do:  (let: "$a0" := (![raftpb.Message] "m") in
            (MethodResolve (go.PointerType raft) "handleSnapshot"%go (![go.PointerType raft] "r")) "$a0")
          else
            (if: "$sw" =⟨raftpb.MessageType⟩ (![raftpb.MessageType] "myVoteRespType")
            then
              let: "res" := (GoAlloc quorum.VoteResult (GoZeroVal quorum.VoteResult #())) in
              let: "rj" := (GoAlloc go.int (GoZeroVal go.int #())) in
              let: "gr" := (GoAlloc go.int (GoZeroVal go.int #())) in
              let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![go.uint64] (StructFieldRef raftpb.Message "From"%go "m")) in
              let: "$a1" := (![raftpb.MessageType] (StructFieldRef raftpb.Message "Type"%go "m")) in
              let: "$a2" := (~ (![go.bool] (StructFieldRef raftpb.Message "Reject"%go "m"))) in
              (MethodResolve (go.PointerType raft) "poll"%go (![go.PointerType raft] "r")) "$a0" "$a1" "$a2") in
              let: "$r0" := "$ret0" in
              let: "$r1" := "$ret1" in
              let: "$r2" := "$ret2" in
              do:  ("gr" <-[go.int] "$r0");;;
              do:  ("rj" <-[go.int] "$r1");;;
              do:  ("res" <-[quorum.VoteResult] "$r2");;;
              do:  (let: "$a0" := #"%x has received %d %s votes and %d vote rejections"%go in
              let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))) in
              let: "$sl1" := (Convert go.int (go.InterfaceType []) (![go.int] "gr")) in
              let: "$sl2" := (Convert raftpb.MessageType (go.InterfaceType []) (![raftpb.MessageType] (StructFieldRef raftpb.Message "Type"%go "m"))) in
              let: "$sl3" := (Convert go.int (go.InterfaceType []) (![go.int] "rj")) in
              CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl2"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl3")]))) in
              (MethodResolve Logger "Infof"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0" "$a1");;;
              let: "$sw" := (![quorum.VoteResult] "res") in
              (if: "$sw" =⟨quorum.VoteResult⟩ quorum.VoteWon
              then
                (if: Convert go.untyped_bool go.bool ((![StateType] (StructFieldRef raft "state"%go (![go.PointerType raft] "r"))) =⟨go.uint64⟩ StatePreCandidate)
                then
                  do:  (let: "$a0" := campaignElection in
                  (MethodResolve (go.PointerType raft) "campaign"%go (![go.PointerType raft] "r")) "$a0")
                else
                  do:  ((MethodResolve (go.PointerType raft) "becomeLeader"%go (![go.PointerType raft] "r")) #());;;
                  do:  ((MethodResolve (go.PointerType raft) "bcastAppend"%go (![go.PointerType raft] "r")) #()))
              else
                (if: "$sw" =⟨quorum.VoteResult⟩ quorum.VoteLost
                then
                  do:  (let: "$a0" := (![go.uint64] (StructFieldRef raft "Term"%go (![go.PointerType raft] "r"))) in
                  let: "$a1" := None in
                  (MethodResolve (go.PointerType raft) "becomeFollower"%go (![go.PointerType raft] "r")) "$a0" "$a1")
                else do:  #()))
            else
              (if: "$sw" =⟨raftpb.MessageType⟩ raftpb.MsgTimeoutNow
              then
                do:  (let: "$a0" := #"%x [term %d state %v] ignored MsgTimeoutNow from %x"%go in
                let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))) in
                let: "$sl1" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "Term"%go (![go.PointerType raft] "r")))) in
                let: "$sl2" := (Convert StateType (go.InterfaceType []) (![StateType] (StructFieldRef raft "state"%go (![go.PointerType raft] "r")))) in
                let: "$sl3" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raftpb.Message "From"%go "m"))) in
                CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl2"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl3")]))) in
                (MethodResolve Logger "Debugf"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0" "$a1")
              else do:  #()))))));;;
    return: (Convert go.untyped_nil go.error UntypedNil)).

(* go: raft.go:1713:6 *)
Definition stepFollowerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "r" "m",
    exception_do (let: "m" := (GoAlloc raftpb.Message "m") in
    let: "r" := (GoAlloc (go.PointerType raft) "r") in
    let: "$sw" := (![raftpb.MessageType] (StructFieldRef raftpb.Message "Type"%go "m")) in
    (if: "$sw" =⟨raftpb.MessageType⟩ raftpb.MsgProp
    then
      (if: Convert go.untyped_bool go.bool ((![go.uint64] (StructFieldRef raft "lead"%go (![go.PointerType raft] "r"))) =⟨go.uint64⟩ None)
      then
        do:  (let: "$a0" := #"%x no leader at term %d; dropping proposal"%go in
        let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))) in
        let: "$sl1" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "Term"%go (![go.PointerType raft] "r")))) in
        CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1")]))) in
        (MethodResolve Logger "Infof"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0" "$a1");;;
        return: (![go.error] (GlobalVarAddr ErrProposalDropped #()))
      else
        (if: ![go.bool] (StructFieldRef raft "disableProposalForwarding"%go (![go.PointerType raft] "r"))
        then
          do:  (let: "$a0" := #"%x not forwarding to leader %x at term %d; dropping proposal"%go in
          let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))) in
          let: "$sl1" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "lead"%go (![go.PointerType raft] "r")))) in
          let: "$sl2" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "Term"%go (![go.PointerType raft] "r")))) in
          CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl2")]))) in
          (MethodResolve Logger "Infof"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0" "$a1");;;
          return: (![go.error] (GlobalVarAddr ErrProposalDropped #()))
        else do:  #()));;;
      let: "$r0" := (![go.uint64] (StructFieldRef raft "lead"%go (![go.PointerType raft] "r"))) in
      do:  ((StructFieldRef raftpb.Message "To"%go "m") <-[go.uint64] "$r0");;;
      do:  (let: "$a0" := (![raftpb.Message] "m") in
      (MethodResolve (go.PointerType raft) "send"%go (![go.PointerType raft] "r")) "$a0")
    else
      (if: "$sw" =⟨raftpb.MessageType⟩ raftpb.MsgApp
      then
        let: "$r0" := #(W64 0) in
        do:  ((StructFieldRef raft "electionElapsed"%go (![go.PointerType raft] "r")) <-[go.int] "$r0");;;
        let: "$r0" := (![go.uint64] (StructFieldRef raftpb.Message "From"%go "m")) in
        do:  ((StructFieldRef raft "lead"%go (![go.PointerType raft] "r")) <-[go.uint64] "$r0");;;
        do:  (let: "$a0" := (![raftpb.Message] "m") in
        (MethodResolve (go.PointerType raft) "handleAppendEntries"%go (![go.PointerType raft] "r")) "$a0")
      else
        (if: "$sw" =⟨raftpb.MessageType⟩ raftpb.MsgHeartbeat
        then
          let: "$r0" := #(W64 0) in
          do:  ((StructFieldRef raft "electionElapsed"%go (![go.PointerType raft] "r")) <-[go.int] "$r0");;;
          let: "$r0" := (![go.uint64] (StructFieldRef raftpb.Message "From"%go "m")) in
          do:  ((StructFieldRef raft "lead"%go (![go.PointerType raft] "r")) <-[go.uint64] "$r0");;;
          do:  (let: "$a0" := (![raftpb.Message] "m") in
          (MethodResolve (go.PointerType raft) "handleHeartbeat"%go (![go.PointerType raft] "r")) "$a0")
        else
          (if: "$sw" =⟨raftpb.MessageType⟩ raftpb.MsgSnap
          then
            let: "$r0" := #(W64 0) in
            do:  ((StructFieldRef raft "electionElapsed"%go (![go.PointerType raft] "r")) <-[go.int] "$r0");;;
            let: "$r0" := (![go.uint64] (StructFieldRef raftpb.Message "From"%go "m")) in
            do:  ((StructFieldRef raft "lead"%go (![go.PointerType raft] "r")) <-[go.uint64] "$r0");;;
            do:  (let: "$a0" := (![raftpb.Message] "m") in
            (MethodResolve (go.PointerType raft) "handleSnapshot"%go (![go.PointerType raft] "r")) "$a0")
          else
            (if: "$sw" =⟨raftpb.MessageType⟩ raftpb.MsgTransferLeader
            then
              (if: Convert go.untyped_bool go.bool ((![go.uint64] (StructFieldRef raft "lead"%go (![go.PointerType raft] "r"))) =⟨go.uint64⟩ None)
              then
                do:  (let: "$a0" := #"%x no leader at term %d; dropping leader transfer msg"%go in
                let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))) in
                let: "$sl1" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "Term"%go (![go.PointerType raft] "r")))) in
                CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1")]))) in
                (MethodResolve Logger "Infof"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0" "$a1");;;
                return: (Convert go.untyped_nil go.error UntypedNil)
              else do:  #());;;
              let: "$r0" := (![go.uint64] (StructFieldRef raft "lead"%go (![go.PointerType raft] "r"))) in
              do:  ((StructFieldRef raftpb.Message "To"%go "m") <-[go.uint64] "$r0");;;
              do:  (let: "$a0" := (![raftpb.Message] "m") in
              (MethodResolve (go.PointerType raft) "send"%go (![go.PointerType raft] "r")) "$a0")
            else
              (if: "$sw" =⟨raftpb.MessageType⟩ raftpb.MsgForgetLeader
              then
                (if: Convert go.untyped_bool go.bool ((![ReadOnlyOption] (StructFieldRef readOnly "option"%go (![go.PointerType readOnly] (StructFieldRef raft "readOnly"%go (![go.PointerType raft] "r"))))) =⟨go.int⟩ ReadOnlyLeaseBased)
                then
                  do:  (let: "$a0" := ((let: "$sl0" := (Convert go.string (go.InterfaceType []) #"ignoring MsgForgetLeader due to ReadOnlyLeaseBased"%go) in
                  CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0")]))) in
                  (MethodResolve Logger "Error"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0");;;
                  return: (Convert go.untyped_nil go.error UntypedNil)
                else do:  #());;;
                (if: Convert go.untyped_bool go.bool ((![go.uint64] (StructFieldRef raft "lead"%go (![go.PointerType raft] "r"))) ≠⟨go.uint64⟩ None)
                then
                  do:  (let: "$a0" := #"%x forgetting leader %x at term %d"%go in
                  let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))) in
                  let: "$sl1" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "lead"%go (![go.PointerType raft] "r")))) in
                  let: "$sl2" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "Term"%go (![go.PointerType raft] "r")))) in
                  CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl2")]))) in
                  (MethodResolve Logger "Infof"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0" "$a1");;;
                  let: "$r0" := None in
                  do:  ((StructFieldRef raft "lead"%go (![go.PointerType raft] "r")) <-[go.uint64] "$r0")
                else do:  #())
              else
                (if: "$sw" =⟨raftpb.MessageType⟩ raftpb.MsgTimeoutNow
                then
                  do:  (let: "$a0" := #"%x [term %d] received MsgTimeoutNow from %x and starts an election to get leadership."%go in
                  let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))) in
                  let: "$sl1" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "Term"%go (![go.PointerType raft] "r")))) in
                  let: "$sl2" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raftpb.Message "From"%go "m"))) in
                  CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl2")]))) in
                  (MethodResolve Logger "Infof"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0" "$a1");;;
                  do:  (let: "$a0" := campaignTransfer in
                  (MethodResolve (go.PointerType raft) "hup"%go (![go.PointerType raft] "r")) "$a0")
                else
                  (if: "$sw" =⟨raftpb.MessageType⟩ raftpb.MsgReadIndex
                  then
                    (if: Convert go.untyped_bool go.bool ((![go.uint64] (StructFieldRef raft "lead"%go (![go.PointerType raft] "r"))) =⟨go.uint64⟩ None)
                    then
                      do:  (let: "$a0" := #"%x no leader at term %d; dropping index reading msg"%go in
                      let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))) in
                      let: "$sl1" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "Term"%go (![go.PointerType raft] "r")))) in
                      CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1")]))) in
                      (MethodResolve Logger "Infof"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0" "$a1");;;
                      return: (Convert go.untyped_nil go.error UntypedNil)
                    else do:  #());;;
                    let: "$r0" := (![go.uint64] (StructFieldRef raft "lead"%go (![go.PointerType raft] "r"))) in
                    do:  ((StructFieldRef raftpb.Message "To"%go "m") <-[go.uint64] "$r0");;;
                    do:  (let: "$a0" := (![raftpb.Message] "m") in
                    (MethodResolve (go.PointerType raft) "send"%go (![go.PointerType raft] "r")) "$a0")
                  else
                    (if: "$sw" =⟨raftpb.MessageType⟩ raftpb.MsgReadIndexResp
                    then
                      (if: Convert go.untyped_bool go.bool ((let: "$a0" := (![go.SliceType raftpb.Entry] (StructFieldRef raftpb.Message "Entries"%go "m")) in
                      (FuncResolve go.len [go.SliceType raftpb.Entry] #()) "$a0") ≠⟨go.int⟩ #(W64 1))
                      then
                        do:  (let: "$a0" := #"%x invalid format of MsgReadIndexResp from %x, entries count: %d"%go in
                        let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))) in
                        let: "$sl1" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raftpb.Message "From"%go "m"))) in
                        let: "$sl2" := (Convert go.int (go.InterfaceType []) (let: "$a0" := (![go.SliceType raftpb.Entry] (StructFieldRef raftpb.Message "Entries"%go "m")) in
                        (FuncResolve go.len [go.SliceType raftpb.Entry] #()) "$a0")) in
                        CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl2")]))) in
                        (MethodResolve Logger "Errorf"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0" "$a1");;;
                        return: (Convert go.untyped_nil go.error UntypedNil)
                      else do:  #());;;
                      let: "$r0" := (let: "$a0" := (![go.SliceType ReadState] (StructFieldRef raft "readStates"%go (![go.PointerType raft] "r"))) in
                      let: "$a1" := ((let: "$sl0" := (CompositeLiteral ReadState (LiteralValue [KeyedElement (Some (KeyField "Index"%go)) (ElementExpression go.uint64 (![go.uint64] (StructFieldRef raftpb.Message "Index"%go "m"))); KeyedElement (Some (KeyField "RequestCtx"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] (StructFieldRef raftpb.Entry "Data"%go (IndexRef (go.SliceType raftpb.Entry) (![go.SliceType raftpb.Entry] (StructFieldRef raftpb.Message "Entries"%go "m"), #(W64 0))))))])) in
                      CompositeLiteral (go.SliceType ReadState) (LiteralValue [KeyedElement None (ElementExpression ReadState "$sl0")]))) in
                      (FuncResolve go.append [go.SliceType ReadState] #()) "$a0" "$a1") in
                      do:  ((StructFieldRef raft "readStates"%go (![go.PointerType raft] "r")) <-[go.SliceType ReadState] "$r0")
                    else do:  #())))))))));;;
    return: (Convert go.untyped_nil go.error UntypedNil)).

(* logSliceFromMsgApp extracts the appended logSlice from a MsgApp message.

   go: raft.go:1777:6 *)
Definition logSliceFromMsgAppⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "m",
    exception_do (let: "m" := (GoAlloc (go.PointerType raftpb.Message) "m") in
    return: (CompositeLiteral logSlice (LiteralValue [KeyedElement (Some (KeyField "term"%go)) (ElementExpression go.uint64 (![go.uint64] (StructFieldRef raftpb.Message "Term"%go (![go.PointerType raftpb.Message] "m")))); KeyedElement (Some (KeyField "prev"%go)) (ElementExpression entryID (CompositeLiteral entryID (LiteralValue [KeyedElement (Some (KeyField "term"%go)) (ElementExpression go.uint64 (![go.uint64] (StructFieldRef raftpb.Message "LogTerm"%go (![go.PointerType raftpb.Message] "m")))); KeyedElement (Some (KeyField "index"%go)) (ElementExpression go.uint64 (![go.uint64] (StructFieldRef raftpb.Message "Index"%go (![go.PointerType raftpb.Message] "m"))))]))); KeyedElement (Some (KeyField "entries"%go)) (ElementExpression (go.SliceType raftpb.Entry) (![go.SliceType raftpb.Entry] (StructFieldRef raftpb.Message "Entries"%go (![go.PointerType raftpb.Message] "m"))))]))).

(* go: raft.go:1786:16 *)
Definition raft__handleAppendEntriesⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "r" "m",
    exception_do (let: "r" := (GoAlloc (go.PointerType raft) "r") in
    let: "m" := (GoAlloc raftpb.Message "m") in
    let: "a" := (GoAlloc logSlice (GoZeroVal logSlice #())) in
    let: "$r0" := (let: "$a0" := "m" in
    (FuncResolve logSliceFromMsgApp [] #()) "$a0") in
    do:  ("a" <-[logSlice] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] (StructFieldRef entryID "index"%go (StructFieldRef logSlice "prev"%go "a"))) <⟨go.uint64⟩ (![go.uint64] (StructFieldRef raftLog "committed"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r"))))))
    then
      do:  (let: "$a0" := (CompositeLiteral raftpb.Message (LiteralValue [KeyedElement (Some (KeyField "To"%go)) (ElementExpression go.uint64 (![go.uint64] (StructFieldRef raftpb.Message "From"%go "m"))); KeyedElement (Some (KeyField "Type"%go)) (ElementExpression raftpb.MessageType raftpb.MsgAppResp); KeyedElement (Some (KeyField "Index"%go)) (ElementExpression go.uint64 (![go.uint64] (StructFieldRef raftLog "committed"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r"))))))])) in
      (MethodResolve (go.PointerType raft) "send"%go (![go.PointerType raft] "r")) "$a0");;;
      return: (#())
    else do:  #());;;
    (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "mlastIndex" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![logSlice] "a") in
    let: "$a1" := (![go.uint64] (StructFieldRef raftpb.Message "Commit"%go "m")) in
    (MethodResolve (go.PointerType raftLog) "maybeAppend"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r")))) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("mlastIndex" <-[go.uint64] "$r0");;;
    do:  ("ok" <-[go.bool] "$r1");;;
    (if: ![go.bool] "ok"
    then
      do:  (let: "$a0" := (CompositeLiteral raftpb.Message (LiteralValue [KeyedElement (Some (KeyField "To"%go)) (ElementExpression go.uint64 (![go.uint64] (StructFieldRef raftpb.Message "From"%go "m"))); KeyedElement (Some (KeyField "Type"%go)) (ElementExpression raftpb.MessageType raftpb.MsgAppResp); KeyedElement (Some (KeyField "Index"%go)) (ElementExpression go.uint64 (![go.uint64] "mlastIndex"))])) in
      (MethodResolve (go.PointerType raft) "send"%go (![go.PointerType raft] "r")) "$a0");;;
      return: (#())
    else do:  #()));;;
    do:  (let: "$a0" := #"%x [logterm: %d, index: %d] rejected MsgApp [logterm: %d, index: %d] from %x"%go in
    let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))) in
    let: "$sl1" := (Convert go.uint64 (go.InterfaceType []) (let: ("$ret0", "$ret1") := ((let: "$a0" := (![go.uint64] (StructFieldRef raftpb.Message "Index"%go "m")) in
    (MethodResolve (go.PointerType raftLog) "term"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r")))) "$a0")) in
    let: "$a0" := "$ret0" in
    let: "$a1" := "$ret1" in
    (MethodResolve (go.PointerType raftLog) "zeroTermOnOutOfBounds"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r")))) "$a0" "$a1")) in
    let: "$sl2" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raftpb.Message "Index"%go "m"))) in
    let: "$sl3" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raftpb.Message "LogTerm"%go "m"))) in
    let: "$sl4" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raftpb.Message "Index"%go "m"))) in
    let: "$sl5" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raftpb.Message "From"%go "m"))) in
    CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl2"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl3"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl4"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl5")]))) in
    (MethodResolve Logger "Debugf"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0" "$a1");;;
    let: "hintIndex" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (let: "$a0" := (![go.uint64] (StructFieldRef raftpb.Message "Index"%go "m")) in
    let: "$a1" := ((MethodResolve (go.PointerType raftLog) "lastIndex"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r")))) #()) in
    (FuncResolve go.min [go.uint64; go.uint64] #()) "$a0" "$a1") in
    do:  ("hintIndex" <-[go.uint64] "$r0");;;
    let: "hintTerm" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![go.uint64] "hintIndex") in
    let: "$a1" := (![go.uint64] (StructFieldRef raftpb.Message "LogTerm"%go "m")) in
    (MethodResolve (go.PointerType raftLog) "findConflictByTerm"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r")))) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("hintIndex" <-[go.uint64] "$r0");;;
    do:  ("hintTerm" <-[go.uint64] "$r1");;;
    do:  (let: "$a0" := (CompositeLiteral raftpb.Message (LiteralValue [KeyedElement (Some (KeyField "To"%go)) (ElementExpression go.uint64 (![go.uint64] (StructFieldRef raftpb.Message "From"%go "m"))); KeyedElement (Some (KeyField "Type"%go)) (ElementExpression raftpb.MessageType raftpb.MsgAppResp); KeyedElement (Some (KeyField "Index"%go)) (ElementExpression go.uint64 (![go.uint64] (StructFieldRef raftpb.Message "Index"%go "m"))); KeyedElement (Some (KeyField "Reject"%go)) (ElementExpression go.bool #true); KeyedElement (Some (KeyField "RejectHint"%go)) (ElementExpression go.uint64 (![go.uint64] "hintIndex")); KeyedElement (Some (KeyField "LogTerm"%go)) (ElementExpression go.uint64 (![go.uint64] "hintTerm"))])) in
    (MethodResolve (go.PointerType raft) "send"%go (![go.PointerType raft] "r")) "$a0");;;
    return: #()).

(* go: raft.go:1830:16 *)
Definition raft__handleHeartbeatⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "r" "m",
    exception_do (let: "r" := (GoAlloc (go.PointerType raft) "r") in
    let: "m" := (GoAlloc raftpb.Message "m") in
    do:  (let: "$a0" := (![go.uint64] (StructFieldRef raftpb.Message "Commit"%go "m")) in
    (MethodResolve (go.PointerType raftLog) "commitTo"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r")))) "$a0");;;
    do:  (let: "$a0" := (CompositeLiteral raftpb.Message (LiteralValue [KeyedElement (Some (KeyField "To"%go)) (ElementExpression go.uint64 (![go.uint64] (StructFieldRef raftpb.Message "From"%go "m"))); KeyedElement (Some (KeyField "Type"%go)) (ElementExpression raftpb.MessageType raftpb.MsgHeartbeatResp); KeyedElement (Some (KeyField "Context"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] (StructFieldRef raftpb.Message "Context"%go "m")))])) in
    (MethodResolve (go.PointerType raft) "send"%go (![go.PointerType raft] "r")) "$a0");;;
    return: #()).

(* go: raft.go:1835:16 *)
Definition raft__handleSnapshotⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "r" "m",
    exception_do (let: "r" := (GoAlloc (go.PointerType raft) "r") in
    let: "m" := (GoAlloc raftpb.Message "m") in
    let: "s" := (GoAlloc raftpb.Snapshot (GoZeroVal raftpb.Snapshot #())) in
    (if: Convert go.untyped_bool go.bool ((![go.PointerType raftpb.Snapshot] (StructFieldRef raftpb.Message "Snapshot"%go "m")) ≠⟨go.PointerType raftpb.Snapshot⟩ (Convert go.untyped_nil (go.PointerType raftpb.Snapshot) UntypedNil))
    then
      let: "$r0" := (![raftpb.Snapshot] (![go.PointerType raftpb.Snapshot] (StructFieldRef raftpb.Message "Snapshot"%go "m"))) in
      do:  ("s" <-[raftpb.Snapshot] "$r0")
    else do:  #());;;
    let: "sterm" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "sindex" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (![go.uint64] (StructFieldRef raftpb.SnapshotMetadata "Index"%go (StructFieldRef raftpb.Snapshot "Metadata"%go "s"))) in
    let: "$r1" := (![go.uint64] (StructFieldRef raftpb.SnapshotMetadata "Term"%go (StructFieldRef raftpb.Snapshot "Metadata"%go "s"))) in
    do:  ("sindex" <-[go.uint64] "$r0");;;
    do:  ("sterm" <-[go.uint64] "$r1");;;
    (if: let: "$a0" := (![raftpb.Snapshot] "s") in
    (MethodResolve (go.PointerType raft) "restore"%go (![go.PointerType raft] "r")) "$a0"
    then
      do:  (let: "$a0" := #"%x [commit: %d] restored snapshot [index: %d, term: %d]"%go in
      let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))) in
      let: "$sl1" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raftLog "committed"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r")))))) in
      let: "$sl2" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] "sindex")) in
      let: "$sl3" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] "sterm")) in
      CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl2"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl3")]))) in
      (MethodResolve Logger "Infof"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0" "$a1");;;
      do:  (let: "$a0" := (CompositeLiteral raftpb.Message (LiteralValue [KeyedElement (Some (KeyField "To"%go)) (ElementExpression go.uint64 (![go.uint64] (StructFieldRef raftpb.Message "From"%go "m"))); KeyedElement (Some (KeyField "Type"%go)) (ElementExpression raftpb.MessageType raftpb.MsgAppResp); KeyedElement (Some (KeyField "Index"%go)) (ElementExpression go.uint64 ((MethodResolve (go.PointerType raftLog) "lastIndex"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r")))) #()))])) in
      (MethodResolve (go.PointerType raft) "send"%go (![go.PointerType raft] "r")) "$a0")
    else
      do:  (let: "$a0" := #"%x [commit: %d] ignored snapshot [index: %d, term: %d]"%go in
      let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))) in
      let: "$sl1" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raftLog "committed"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r")))))) in
      let: "$sl2" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] "sindex")) in
      let: "$sl3" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] "sterm")) in
      CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl2"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl3")]))) in
      (MethodResolve Logger "Infof"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0" "$a1");;;
      do:  (let: "$a0" := (CompositeLiteral raftpb.Message (LiteralValue [KeyedElement (Some (KeyField "To"%go)) (ElementExpression go.uint64 (![go.uint64] (StructFieldRef raftpb.Message "From"%go "m"))); KeyedElement (Some (KeyField "Type"%go)) (ElementExpression raftpb.MessageType raftpb.MsgAppResp); KeyedElement (Some (KeyField "Index"%go)) (ElementExpression go.uint64 (![go.uint64] (StructFieldRef raftLog "committed"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r"))))))])) in
      (MethodResolve (go.PointerType raft) "send"%go (![go.PointerType raft] "r")) "$a0"));;;
    return: #()).

(* restore recovers the state machine from a snapshot. It restores the log and the
   configuration of state machine. If this method returns false, the snapshot was
   ignored, either because it was obsolete or because of an error.

   go: raft.go:1857:16 *)
Definition raft__restoreⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "r" "s",
    exception_do (let: "r" := (GoAlloc (go.PointerType raft) "r") in
    let: "s" := (GoAlloc raftpb.Snapshot "s") in
    (if: Convert go.untyped_bool go.bool ((![go.uint64] (StructFieldRef raftpb.SnapshotMetadata "Index"%go (StructFieldRef raftpb.Snapshot "Metadata"%go "s"))) ≤⟨go.uint64⟩ (![go.uint64] (StructFieldRef raftLog "committed"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r"))))))
    then return: (#false)
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool ((![StateType] (StructFieldRef raft "state"%go (![go.PointerType raft] "r"))) ≠⟨go.uint64⟩ StateFollower)
    then
      do:  (let: "$a0" := #"%x attempted to restore snapshot as leader; should never happen"%go in
      let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))) in
      CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0")]))) in
      (MethodResolve Logger "Warningf"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0" "$a1");;;
      do:  (let: "$a0" := ((![go.uint64] (StructFieldRef raft "Term"%go (![go.PointerType raft] "r"))) +⟨go.uint64⟩ #(W64 1)) in
      let: "$a1" := None in
      (MethodResolve (go.PointerType raft) "becomeFollower"%go (![go.PointerType raft] "r")) "$a0" "$a1");;;
      return: (#false)
    else do:  #());;;
    let: "found" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := #false in
    do:  ("found" <-[go.bool] "$r0");;;
    let: "cs" := (GoAlloc raftpb.ConfState (GoZeroVal raftpb.ConfState #())) in
    let: "$r0" := (![raftpb.ConfState] (StructFieldRef raftpb.SnapshotMetadata "ConfState"%go (StructFieldRef raftpb.Snapshot "Metadata"%go "s"))) in
    do:  ("cs" <-[raftpb.ConfState] "$r0");;;
    let: "$range" := (CompositeLiteral (go.SliceType (go.SliceType go.uint64)) (LiteralValue [KeyedElement None (ElementExpression (go.SliceType go.uint64) (![go.SliceType go.uint64] (StructFieldRef raftpb.ConfState "Voters"%go "cs"))); KeyedElement None (ElementExpression (go.SliceType go.uint64) (![go.SliceType go.uint64] (StructFieldRef raftpb.ConfState "Learners"%go "cs"))); KeyedElement None (ElementExpression (go.SliceType go.uint64) (![go.SliceType go.uint64] (StructFieldRef raftpb.ConfState "VotersOutgoing"%go "cs")))])) in
    (let: "set" := (GoAlloc (go.SliceType go.uint64) (GoZeroVal (go.SliceType go.uint64) #())) in
    slice.for_range (go.SliceType go.uint64) "$range" (λ: "$key" "$value",
      do:  ("set" <-[go.SliceType go.uint64] "$value");;;
      do:  "$key";;;
      let: "$range" := (![go.SliceType go.uint64] "set") in
      (let: "id" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      slice.for_range go.uint64 "$range" (λ: "$key" "$value",
        do:  ("id" <-[go.uint64] "$value");;;
        do:  "$key";;;
        (if: Convert go.untyped_bool go.bool ((![go.uint64] "id") =⟨go.uint64⟩ (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r"))))
        then
          let: "$r0" := #true in
          do:  ("found" <-[go.bool] "$r0");;;
          break: #()
        else do:  #())));;;
      (if: ![go.bool] "found"
      then break: #()
      else do:  #())));;;
    (if: (~ (![go.bool] "found"))
    then
      do:  (let: "$a0" := #"%x attempted to restore snapshot but it is not in the ConfState %v; should never happen"%go in
      let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))) in
      let: "$sl1" := (Convert raftpb.ConfState (go.InterfaceType []) (![raftpb.ConfState] "cs")) in
      CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1")]))) in
      (MethodResolve Logger "Warningf"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0" "$a1");;;
      return: (#false)
    else do:  #());;;
    let: "id" := (GoAlloc entryID (GoZeroVal entryID #())) in
    let: "$r0" := (CompositeLiteral entryID (LiteralValue [KeyedElement (Some (KeyField "term"%go)) (ElementExpression go.uint64 (![go.uint64] (StructFieldRef raftpb.SnapshotMetadata "Term"%go (StructFieldRef raftpb.Snapshot "Metadata"%go "s")))); KeyedElement (Some (KeyField "index"%go)) (ElementExpression go.uint64 (![go.uint64] (StructFieldRef raftpb.SnapshotMetadata "Index"%go (StructFieldRef raftpb.Snapshot "Metadata"%go "s"))))])) in
    do:  ("id" <-[entryID] "$r0");;;
    (if: let: "$a0" := (![entryID] "id") in
    (MethodResolve (go.PointerType raftLog) "matchTerm"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r")))) "$a0"
    then
      let: "last" := (GoAlloc entryID (GoZeroVal entryID #())) in
      let: "$r0" := ((MethodResolve (go.PointerType raftLog) "lastEntryID"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r")))) #()) in
      do:  ("last" <-[entryID] "$r0");;;
      do:  (let: "$a0" := #"%x [commit: %d, lastindex: %d, lastterm: %d] fast-forwarded commit to snapshot [index: %d, term: %d]"%go in
      let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))) in
      let: "$sl1" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raftLog "committed"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r")))))) in
      let: "$sl2" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef entryID "index"%go "last"))) in
      let: "$sl3" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef entryID "term"%go "last"))) in
      let: "$sl4" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef entryID "index"%go "id"))) in
      let: "$sl5" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef entryID "term"%go "id"))) in
      CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl2"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl3"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl4"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl5")]))) in
      (MethodResolve Logger "Infof"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0" "$a1");;;
      do:  (let: "$a0" := (![go.uint64] (StructFieldRef raftpb.SnapshotMetadata "Index"%go (StructFieldRef raftpb.Snapshot "Metadata"%go "s"))) in
      (MethodResolve (go.PointerType raftLog) "commitTo"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r")))) "$a0");;;
      return: (#false)
    else do:  #());;;
    do:  (let: "$a0" := (![raftpb.Snapshot] "s") in
    (MethodResolve (go.PointerType raftLog) "restore"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r")))) "$a0");;;
    let: "$r0" := (let: "$a0" := (![go.int] (StructFieldRef tracker.ProgressTracker "MaxInflight"%go (StructFieldRef raft "trk"%go (![go.PointerType raft] "r")))) in
    let: "$a1" := (![go.uint64] (StructFieldRef tracker.ProgressTracker "MaxInflightBytes"%go (StructFieldRef raft "trk"%go (![go.PointerType raft] "r")))) in
    (FuncResolve tracker.MakeProgressTracker [] #()) "$a0" "$a1") in
    do:  ((StructFieldRef raft "trk"%go (![go.PointerType raft] "r")) <-[tracker.ProgressTracker] "$r0");;;
    let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
    let: "trk" := (GoAlloc tracker.ProgressMap (GoZeroVal tracker.ProgressMap #())) in
    let: "cfg" := (GoAlloc tracker.Config (GoZeroVal tracker.Config #())) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (CompositeLiteral confchange.Changer (LiteralValue [KeyedElement (Some (KeyField "Tracker"%go)) (ElementExpression tracker.ProgressTracker (![tracker.ProgressTracker] (StructFieldRef raft "trk"%go (![go.PointerType raft] "r")))); KeyedElement (Some (KeyField "LastIndex"%go)) (ElementExpression go.uint64 ((MethodResolve (go.PointerType raftLog) "lastIndex"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r")))) #()))])) in
    let: "$a1" := (![raftpb.ConfState] "cs") in
    (FuncResolve confchange.Restore [] #()) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("cfg" <-[tracker.Config] "$r0");;;
    do:  ("trk" <-[tracker.ProgressMap] "$r1");;;
    do:  ("err" <-[go.error] "$r2");;;
    (if: Convert go.untyped_bool go.bool ((![go.error] "err") ≠⟨go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]⟩ (Convert go.untyped_nil (go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]) UntypedNil))
    then
      do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) (let: "$a0" := #"unable to restore config %+v: %s"%go in
      let: "$a1" := ((let: "$sl0" := (Convert raftpb.ConfState go.any (![raftpb.ConfState] "cs")) in
      let: "$sl1" := (Convert go.error go.any (![go.error] "err")) in
      CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0"); KeyedElement None (ElementExpression go.any "$sl1")]))) in
      (FuncResolve fmt.Sprintf [] #()) "$a0" "$a1")) in
      (FuncResolve go.panic [] #()) "$a0")
    else do:  #());;;
    do:  (let: "$a0" := (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r"))) in
    let: "$a1" := (![raftpb.ConfState] "cs") in
    let: "$a2" := (let: "$a0" := (![tracker.Config] "cfg") in
    let: "$a1" := (![tracker.ProgressMap] "trk") in
    (MethodResolve (go.PointerType raft) "switchToConfig"%go (![go.PointerType raft] "r")) "$a0" "$a1") in
    (FuncResolve assertConfStatesEquivalent [] #()) "$a0" "$a1" "$a2");;;
    let: "last" := (GoAlloc entryID (GoZeroVal entryID #())) in
    let: "$r0" := ((MethodResolve (go.PointerType raftLog) "lastEntryID"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r")))) #()) in
    do:  ("last" <-[entryID] "$r0");;;
    do:  (let: "$a0" := #"%x [commit: %d, lastindex: %d, lastterm: %d] restored snapshot [index: %d, term: %d]"%go in
    let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))) in
    let: "$sl1" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raftLog "committed"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r")))))) in
    let: "$sl2" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef entryID "index"%go "last"))) in
    let: "$sl3" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef entryID "term"%go "last"))) in
    let: "$sl4" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef entryID "index"%go "id"))) in
    let: "$sl5" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef entryID "term"%go "id"))) in
    CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl2"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl3"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl4"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl5")]))) in
    (MethodResolve Logger "Infof"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0" "$a1");;;
    return: (#true)).

(* promotable indicates whether state machine can be promoted to leader,
   which is true when its own id is in progress list.

   go: raft.go:1942:16 *)
Definition raft__promotableⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "r" <>,
    exception_do (let: "r" := (GoAlloc (go.PointerType raft) "r") in
    let: "pr" := (GoAlloc (go.PointerType tracker.Progress) (GoZeroVal (go.PointerType tracker.Progress) #())) in
    let: "$r0" := (map.lookup1 go.uint64 (go.PointerType tracker.Progress) (![tracker.ProgressMap] (StructFieldRef tracker.ProgressTracker "Progress"%go (StructFieldRef raft "trk"%go (![go.PointerType raft] "r")))) (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))) in
    do:  ("pr" <-[go.PointerType tracker.Progress] "$r0");;;
    return: ((((![go.PointerType tracker.Progress] "pr") ≠⟨go.PointerType tracker.Progress⟩ (Convert go.untyped_nil (go.PointerType tracker.Progress) UntypedNil)) && (~ (![go.bool] (StructFieldRef tracker.Progress "IsLearner"%go (![go.PointerType tracker.Progress] "pr"))))) && (~ ((MethodResolve (go.PointerType raftLog) "hasNextOrInProgressSnapshot"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r")))) #())))).

(* go: raft.go:1947:16 *)
Definition raft__applyConfChangeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "r" "cc",
    exception_do (let: "r" := (GoAlloc (go.PointerType raft) "r") in
    let: "cc" := (GoAlloc raftpb.ConfChangeV2 "cc") in
    let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
    let: "trk" := (GoAlloc tracker.ProgressMap (GoZeroVal tracker.ProgressMap #())) in
    let: "cfg" := (GoAlloc tracker.Config (GoZeroVal tracker.Config #())) in
    let: (("$ret0", "$ret1"), "$ret2") := ((λ: <>,
      exception_do (let: "changer" := (GoAlloc confchange.Changer (GoZeroVal confchange.Changer #())) in
      let: "$r0" := (CompositeLiteral confchange.Changer (LiteralValue [KeyedElement (Some (KeyField "Tracker"%go)) (ElementExpression tracker.ProgressTracker (![tracker.ProgressTracker] (StructFieldRef raft "trk"%go (![go.PointerType raft] "r")))); KeyedElement (Some (KeyField "LastIndex"%go)) (ElementExpression go.uint64 ((MethodResolve (go.PointerType raftLog) "lastIndex"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r")))) #()))])) in
      do:  ("changer" <-[confchange.Changer] "$r0");;;
      (if: (MethodResolve raftpb.ConfChangeV2 "LeaveJoint"%go (![raftpb.ConfChangeV2] "cc")) #()
      then
        let: (("$ret0", "$ret1"), "$ret2") := (((MethodResolve confchange.Changer "LeaveJoint"%go (![confchange.Changer] "changer")) #())) in
        return: ("$ret0", "$ret1", "$ret2")
      else
        (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
        let: "autoLeave" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
        let: ("$ret0", "$ret1") := ((MethodResolve raftpb.ConfChangeV2 "EnterJoint"%go (![raftpb.ConfChangeV2] "cc")) #()) in
        let: "$r0" := "$ret0" in
        let: "$r1" := "$ret1" in
        do:  ("autoLeave" <-[go.bool] "$r0");;;
        do:  ("ok" <-[go.bool] "$r1");;;
        (if: ![go.bool] "ok"
        then
          let: (("$ret0", "$ret1"), "$ret2") := ((let: "$a0" := (![go.bool] "autoLeave") in
          let: "$a1" := (![go.SliceType raftpb.ConfChangeSingle] (StructFieldRef raftpb.ConfChangeV2 "Changes"%go "cc")) in
          (MethodResolve confchange.Changer "EnterJoint"%go (![confchange.Changer] "changer")) "$a0" "$a1")) in
          return: ("$ret0", "$ret1", "$ret2")
        else do:  #())));;;
      let: (("$ret0", "$ret1"), "$ret2") := ((let: "$a0" := (![go.SliceType raftpb.ConfChangeSingle] (StructFieldRef raftpb.ConfChangeV2 "Changes"%go "cc")) in
      (MethodResolve confchange.Changer "Simple"%go (![confchange.Changer] "changer")) "$a0")) in
      return: ("$ret0", "$ret1", "$ret2"))
      ) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("cfg" <-[tracker.Config] "$r0");;;
    do:  ("trk" <-[tracker.ProgressMap] "$r1");;;
    do:  ("err" <-[go.error] "$r2");;;
    (if: Convert go.untyped_bool go.bool ((![go.error] "err") ≠⟨go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]⟩ (Convert go.untyped_nil (go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]) UntypedNil))
    then
      do:  (let: "$a0" := (Convert go.error (go.InterfaceType []) (![go.error] "err")) in
      (FuncResolve go.panic [] #()) "$a0")
    else do:  #());;;
    return: (let: "$a0" := (![tracker.Config] "cfg") in
     let: "$a1" := (![tracker.ProgressMap] "trk") in
     (MethodResolve (go.PointerType raft) "switchToConfig"%go (![go.PointerType raft] "r")) "$a0" "$a1")).

(* switchToConfig reconfigures this node to use the provided configuration. It
   updates the in-memory state and, when necessary, carries out additional
   actions such as reacting to the removal of nodes or changed quorum
   requirements.

   The inputs usually result from restoring a ConfState or applying a ConfChange.

   go: raft.go:1975:16 *)
Definition raft__switchToConfigⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "r" "cfg" "trk",
    exception_do (let: "r" := (GoAlloc (go.PointerType raft) "r") in
    let: "trk" := (GoAlloc tracker.ProgressMap "trk") in
    let: "cfg" := (GoAlloc tracker.Config "cfg") in
    do:  (let: "$a0" := (![tracker.Config] "cfg") in
    let: "$a1" := (![go.PointerType raft] "r") in
    (FuncResolve traceConfChangeEvent [] #()) "$a0" "$a1");;;
    let: "$r0" := (![tracker.Config] "cfg") in
    do:  ((StructFieldRef tracker.ProgressTracker "Config"%go (StructFieldRef raft "trk"%go (![go.PointerType raft] "r"))) <-[tracker.Config] "$r0");;;
    let: "$r0" := (![tracker.ProgressMap] "trk") in
    do:  ((StructFieldRef tracker.ProgressTracker "Progress"%go (StructFieldRef raft "trk"%go (![go.PointerType raft] "r"))) <-[tracker.ProgressMap] "$r0");;;
    do:  (let: "$a0" := #"%x switched to configuration %s"%go in
    let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))) in
    let: "$sl1" := (Convert tracker.Config (go.InterfaceType []) (![tracker.Config] (StructFieldRef tracker.ProgressTracker "Config"%go (StructFieldRef raft "trk"%go (![go.PointerType raft] "r"))))) in
    CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1")]))) in
    (MethodResolve Logger "Infof"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0" "$a1");;;
    let: "cs" := (GoAlloc raftpb.ConfState (GoZeroVal raftpb.ConfState #())) in
    let: "$r0" := ((MethodResolve (go.PointerType tracker.ProgressTracker) "ConfState"%go (StructFieldRef raft "trk"%go (![go.PointerType raft] "r"))) #()) in
    do:  ("cs" <-[raftpb.ConfState] "$r0");;;
    let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "pr" := (GoAlloc (go.PointerType tracker.Progress) (GoZeroVal (go.PointerType tracker.Progress) #())) in
    let: ("$ret0", "$ret1") := (map.lookup2 go.uint64 (go.PointerType tracker.Progress) (![tracker.ProgressMap] (StructFieldRef tracker.ProgressTracker "Progress"%go (StructFieldRef raft "trk"%go (![go.PointerType raft] "r")))) (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("pr" <-[go.PointerType tracker.Progress] "$r0");;;
    do:  ("ok" <-[go.bool] "$r1");;;
    let: "$r0" := ((![go.bool] "ok") && (![go.bool] (StructFieldRef tracker.Progress "IsLearner"%go (![go.PointerType tracker.Progress] "pr")))) in
    do:  ((StructFieldRef raft "isLearner"%go (![go.PointerType raft] "r")) <-[go.bool] "$r0");;;
    (if: ((~ (![go.bool] "ok")) || (![go.bool] (StructFieldRef raft "isLearner"%go (![go.PointerType raft] "r")))) && ((![StateType] (StructFieldRef raft "state"%go (![go.PointerType raft] "r"))) =⟨go.uint64⟩ StateLeader)
    then
      (if: ![go.bool] (StructFieldRef raft "stepDownOnRemoval"%go (![go.PointerType raft] "r"))
      then
        do:  (let: "$a0" := (![go.uint64] (StructFieldRef raft "Term"%go (![go.PointerType raft] "r"))) in
        let: "$a1" := None in
        (MethodResolve (go.PointerType raft) "becomeFollower"%go (![go.PointerType raft] "r")) "$a0" "$a1")
      else do:  #());;;
      return: (![raftpb.ConfState] "cs")
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool (((![StateType] (StructFieldRef raft "state"%go (![go.PointerType raft] "r"))) ≠⟨go.uint64⟩ StateLeader) || ((let: "$a0" := (![go.SliceType go.uint64] (StructFieldRef raftpb.ConfState "Voters"%go "cs")) in
    (FuncResolve go.len [go.SliceType go.uint64] #()) "$a0") =⟨go.int⟩ #(W64 0)))
    then return: (![raftpb.ConfState] "cs")
    else do:  #());;;
    (if: (MethodResolve (go.PointerType raft) "maybeCommit"%go (![go.PointerType raft] "r")) #()
    then do:  ((MethodResolve (go.PointerType raft) "bcastAppend"%go (![go.PointerType raft] "r")) #())
    else
      do:  (let: "$a0" := (λ: "id" <>,
        exception_do (let: "id" := (GoAlloc go.uint64 "id") in
        (if: Convert go.untyped_bool go.bool ((![go.uint64] "id") =⟨go.uint64⟩ (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r"))))
        then return: (#())
        else do:  #());;;
        do:  (let: "$a0" := (![go.uint64] "id") in
        let: "$a1" := #false in
        (MethodResolve (go.PointerType raft) "maybeSendAppend"%go (![go.PointerType raft] "r")) "$a0" "$a1");;;
        return: #())
        ) in
      (MethodResolve (go.PointerType tracker.ProgressTracker) "Visit"%go (StructFieldRef raft "trk"%go (![go.PointerType raft] "r"))) "$a0"));;;
    (let: "tOK" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: ("$ret0", "$ret1") := (map.lookup2 go.uint64 (go.StructType [

    ]) ((MethodResolve quorum.JointConfig "IDs"%go (![quorum.JointConfig] (StructFieldRef tracker.Config "Voters"%go (StructFieldRef tracker.ProgressTracker "Config"%go (StructFieldRef raft "trk"%go (![go.PointerType raft] "r")))))) #()) (![go.uint64] (StructFieldRef raft "leadTransferee"%go (![go.PointerType raft] "r")))) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  "$r0";;;
    do:  ("tOK" <-[go.bool] "$r1");;;
    (if: (~ (![go.bool] "tOK")) && ((![go.uint64] (StructFieldRef raft "leadTransferee"%go (![go.PointerType raft] "r"))) ≠⟨go.uint64⟩ #(W64 0))
    then do:  ((MethodResolve (go.PointerType raft) "abortLeaderTransfer"%go (![go.PointerType raft] "r")) #())
    else do:  #()));;;
    return: (![raftpb.ConfState] "cs")).

(* go: raft.go:2033:16 *)
Definition raft__loadStateⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "r" "state",
    exception_do (let: "r" := (GoAlloc (go.PointerType raft) "r") in
    let: "state" := (GoAlloc raftpb.HardState "state") in
    (if: Convert go.untyped_bool go.bool (((![go.uint64] (StructFieldRef raftpb.HardState "Commit"%go "state")) <⟨go.uint64⟩ (![go.uint64] (StructFieldRef raftLog "committed"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r")))))) || ((![go.uint64] (StructFieldRef raftpb.HardState "Commit"%go "state")) >⟨go.uint64⟩ ((MethodResolve (go.PointerType raftLog) "lastIndex"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r")))) #())))
    then
      do:  (let: "$a0" := #"%x state.commit %d is out of range [%d, %d]"%go in
      let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))) in
      let: "$sl1" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raftpb.HardState "Commit"%go "state"))) in
      let: "$sl2" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raftLog "committed"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r")))))) in
      let: "$sl3" := (Convert go.uint64 (go.InterfaceType []) ((MethodResolve (go.PointerType raftLog) "lastIndex"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r")))) #())) in
      CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl2"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl3")]))) in
      (MethodResolve Logger "Panicf"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0" "$a1")
    else do:  #());;;
    let: "$r0" := (![go.uint64] (StructFieldRef raftpb.HardState "Commit"%go "state")) in
    do:  ((StructFieldRef raftLog "committed"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r")))) <-[go.uint64] "$r0");;;
    let: "$r0" := (![go.uint64] (StructFieldRef raftpb.HardState "Term"%go "state")) in
    do:  ((StructFieldRef raft "Term"%go (![go.PointerType raft] "r")) <-[go.uint64] "$r0");;;
    let: "$r0" := (![go.uint64] (StructFieldRef raftpb.HardState "Vote"%go "state")) in
    do:  ((StructFieldRef raft "Vote"%go (![go.PointerType raft] "r")) <-[go.uint64] "$r0");;;
    return: #()).

(* pastElectionTimeout returns true if r.electionElapsed is greater
   than or equal to the randomized election timeout in
   [electiontimeout, 2 * electiontimeout - 1].

   go: raft.go:2045:16 *)
Definition raft__pastElectionTimeoutⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "r" <>,
    exception_do (let: "r" := (GoAlloc (go.PointerType raft) "r") in
    return: ((![go.int] (StructFieldRef raft "electionElapsed"%go (![go.PointerType raft] "r"))) ≥⟨go.int⟩ (![go.int] (StructFieldRef raft "randomizedElectionTimeout"%go (![go.PointerType raft] "r"))))).

(* go: raft.go:2049:16 *)
Definition raft__resetRandomizedElectionTimeoutⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "r" <>,
    exception_do (let: "r" := (GoAlloc (go.PointerType raft) "r") in
    let: "$r0" := ((![go.int] (StructFieldRef raft "electionTimeout"%go (![go.PointerType raft] "r"))) +⟨go.int⟩ (let: "$a0" := (![go.int] (StructFieldRef raft "electionTimeout"%go (![go.PointerType raft] "r"))) in
    (MethodResolve (go.PointerType lockedRand) "Intn"%go (![go.PointerType lockedRand] (GlobalVarAddr globalRand #()))) "$a0")) in
    do:  ((StructFieldRef raft "randomizedElectionTimeout"%go (![go.PointerType raft] "r")) <-[go.int] "$r0");;;
    return: #()).

(* go: raft.go:2053:16 *)
Definition raft__sendTimeoutNowⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "r" "to",
    exception_do (let: "r" := (GoAlloc (go.PointerType raft) "r") in
    let: "to" := (GoAlloc go.uint64 "to") in
    do:  (let: "$a0" := (CompositeLiteral raftpb.Message (LiteralValue [KeyedElement (Some (KeyField "To"%go)) (ElementExpression go.uint64 (![go.uint64] "to")); KeyedElement (Some (KeyField "Type"%go)) (ElementExpression raftpb.MessageType raftpb.MsgTimeoutNow)])) in
    (MethodResolve (go.PointerType raft) "send"%go (![go.PointerType raft] "r")) "$a0");;;
    return: #()).

(* go: raft.go:2057:16 *)
Definition raft__abortLeaderTransferⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "r" <>,
    exception_do (let: "r" := (GoAlloc (go.PointerType raft) "r") in
    let: "$r0" := None in
    do:  ((StructFieldRef raft "leadTransferee"%go (![go.PointerType raft] "r")) <-[go.uint64] "$r0");;;
    return: #()).

(* committedEntryInCurrentTerm return true if the peer has committed an entry in its term.

   go: raft.go:2062:16 *)
Definition raft__committedEntryInCurrentTermⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "r" <>,
    exception_do (let: "r" := (GoAlloc (go.PointerType raft) "r") in
    return: ((let: ("$ret0", "$ret1") := ((let: "$a0" := (![go.uint64] (StructFieldRef raftLog "committed"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r"))))) in
     (MethodResolve (go.PointerType raftLog) "term"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r")))) "$a0")) in
     let: "$a0" := "$ret0" in
     let: "$a1" := "$ret1" in
     (MethodResolve (go.PointerType raftLog) "zeroTermOnOutOfBounds"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r")))) "$a0" "$a1") =⟨go.uint64⟩ (![go.uint64] (StructFieldRef raft "Term"%go (![go.PointerType raft] "r"))))).

(* responseToReadIndexReq constructs a response for `req`. If `req` comes from the peer
   itself, a blank value will be returned.

   go: raft.go:2070:16 *)
Definition raft__responseToReadIndexReqⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "r" "req" "readIndex",
    exception_do (let: "r" := (GoAlloc (go.PointerType raft) "r") in
    let: "readIndex" := (GoAlloc go.uint64 "readIndex") in
    let: "req" := (GoAlloc raftpb.Message "req") in
    (if: Convert go.untyped_bool go.bool (((![go.uint64] (StructFieldRef raftpb.Message "From"%go "req")) =⟨go.uint64⟩ None) || ((![go.uint64] (StructFieldRef raftpb.Message "From"%go "req")) =⟨go.uint64⟩ (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))))
    then
      let: "$r0" := (let: "$a0" := (![go.SliceType ReadState] (StructFieldRef raft "readStates"%go (![go.PointerType raft] "r"))) in
      let: "$a1" := ((let: "$sl0" := (CompositeLiteral ReadState (LiteralValue [KeyedElement (Some (KeyField "Index"%go)) (ElementExpression go.uint64 (![go.uint64] "readIndex")); KeyedElement (Some (KeyField "RequestCtx"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] (StructFieldRef raftpb.Entry "Data"%go (IndexRef (go.SliceType raftpb.Entry) (![go.SliceType raftpb.Entry] (StructFieldRef raftpb.Message "Entries"%go "req"), #(W64 0))))))])) in
      CompositeLiteral (go.SliceType ReadState) (LiteralValue [KeyedElement None (ElementExpression ReadState "$sl0")]))) in
      (FuncResolve go.append [go.SliceType ReadState] #()) "$a0" "$a1") in
      do:  ((StructFieldRef raft "readStates"%go (![go.PointerType raft] "r")) <-[go.SliceType ReadState] "$r0");;;
      return: (CompositeLiteral raftpb.Message (LiteralValue []))
    else do:  #());;;
    return: (CompositeLiteral raftpb.Message (LiteralValue [KeyedElement (Some (KeyField "Type"%go)) (ElementExpression raftpb.MessageType raftpb.MsgReadIndexResp); KeyedElement (Some (KeyField "To"%go)) (ElementExpression go.uint64 (![go.uint64] (StructFieldRef raftpb.Message "From"%go "req"))); KeyedElement (Some (KeyField "Index"%go)) (ElementExpression go.uint64 (![go.uint64] "readIndex")); KeyedElement (Some (KeyField "Entries"%go)) (ElementExpression (go.SliceType raftpb.Entry) (![go.SliceType raftpb.Entry] (StructFieldRef raftpb.Message "Entries"%go "req")))]))).

(* increaseUncommittedSize computes the size of the proposed entries and
   determines whether they would push leader over its maxUncommittedSize limit.
   If the new entries would exceed the limit, the method returns false. If not,
   the increase in uncommitted entry size is recorded and the method returns
   true.

   Empty payloads are never refused. This is used both for appending an empty
   entry at a new leader's term, as well as leaving a joint configuration.

   go: raft.go:2094:16 *)
Definition raft__increaseUncommittedSizeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "r" "ents",
    exception_do (let: "r" := (GoAlloc (go.PointerType raft) "r") in
    let: "ents" := (GoAlloc (go.SliceType raftpb.Entry) "ents") in
    let: "s" := (GoAlloc entryPayloadSize (GoZeroVal entryPayloadSize #())) in
    let: "$r0" := (let: "$a0" := (![go.SliceType raftpb.Entry] "ents") in
    (FuncResolve payloadsSize [] #()) "$a0") in
    do:  ("s" <-[entryPayloadSize] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((((![entryPayloadSize] (StructFieldRef raft "uncommittedSize"%go (![go.PointerType raft] "r"))) >⟨go.uint64⟩ #(W64 0)) && ((![entryPayloadSize] "s") >⟨go.uint64⟩ #(W64 0))) && (((![entryPayloadSize] (StructFieldRef raft "uncommittedSize"%go (![go.PointerType raft] "r"))) +⟨go.uint64⟩ (![entryPayloadSize] "s")) >⟨go.uint64⟩ (![entryPayloadSize] (StructFieldRef raft "maxUncommittedSize"%go (![go.PointerType raft] "r")))))
    then return: (#false)
    else do:  #());;;
    do:  ((StructFieldRef raft "uncommittedSize"%go (![go.PointerType raft] "r")) <-[entryPayloadSize] ((![entryPayloadSize] (StructFieldRef raft "uncommittedSize"%go (![go.PointerType raft] "r"))) +⟨go.uint64⟩ (![entryPayloadSize] "s")));;;
    return: (#true)).

(* reduceUncommittedSize accounts for the newly committed entries by decreasing
   the uncommitted entry size limit.

   go: raft.go:2112:16 *)
Definition raft__reduceUncommittedSizeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "r" "s",
    exception_do (let: "r" := (GoAlloc (go.PointerType raft) "r") in
    let: "s" := (GoAlloc entryPayloadSize "s") in
    (if: Convert go.untyped_bool go.bool ((![entryPayloadSize] "s") >⟨go.uint64⟩ (![entryPayloadSize] (StructFieldRef raft "uncommittedSize"%go (![go.PointerType raft] "r"))))
    then
      let: "$r0" := #(W64 0) in
      do:  ((StructFieldRef raft "uncommittedSize"%go (![go.PointerType raft] "r")) <-[entryPayloadSize] "$r0")
    else do:  ((StructFieldRef raft "uncommittedSize"%go (![go.PointerType raft] "r")) <-[entryPayloadSize] ((![entryPayloadSize] (StructFieldRef raft "uncommittedSize"%go (![go.PointerType raft] "r"))) -⟨go.uint64⟩ (![entryPayloadSize] "s"))));;;
    return: #()).

(* go: raft.go:2123:6 *)
Definition releasePendingReadIndexMessagesⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "r",
    exception_do (let: "r" := (GoAlloc (go.PointerType raft) "r") in
    (if: Convert go.untyped_bool go.bool ((let: "$a0" := (![go.SliceType raftpb.Message] (StructFieldRef raft "pendingReadIndexMessages"%go (![go.PointerType raft] "r"))) in
    (FuncResolve go.len [go.SliceType raftpb.Message] #()) "$a0") =⟨go.int⟩ #(W64 0))
    then return: (#())
    else do:  #());;;
    (if: (~ ((MethodResolve (go.PointerType raft) "committedEntryInCurrentTerm"%go (![go.PointerType raft] "r")) #()))
    then
      do:  (let: "$a0" := ((let: "$sl0" := (Convert go.string (go.InterfaceType []) #"pending MsgReadIndex should be released only after first commit in current term"%go) in
      CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0")]))) in
      (MethodResolve Logger "Error"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] "r")))) "$a0");;;
      return: (#())
    else do:  #());;;
    let: "msgs" := (GoAlloc (go.SliceType raftpb.Message) (GoZeroVal (go.SliceType raftpb.Message) #())) in
    let: "$r0" := (![go.SliceType raftpb.Message] (StructFieldRef raft "pendingReadIndexMessages"%go (![go.PointerType raft] "r"))) in
    do:  ("msgs" <-[go.SliceType raftpb.Message] "$r0");;;
    let: "$r0" := (Convert go.untyped_nil (go.SliceType raftpb.Message) UntypedNil) in
    do:  ((StructFieldRef raft "pendingReadIndexMessages"%go (![go.PointerType raft] "r")) <-[go.SliceType raftpb.Message] "$r0");;;
    let: "$range" := (![go.SliceType raftpb.Message] "msgs") in
    (let: "m" := (GoAlloc raftpb.Message (GoZeroVal raftpb.Message #())) in
    slice.for_range raftpb.Message "$range" (λ: "$key" "$value",
      do:  ("m" <-[raftpb.Message] "$value");;;
      do:  "$key";;;
      do:  (let: "$a0" := (![go.PointerType raft] "r") in
      let: "$a1" := (![raftpb.Message] "m") in
      (FuncResolve sendMsgReadIndexResponse [] #()) "$a0" "$a1")));;;
    return: #()).

(* go: raft.go:2142:6 *)
Definition sendMsgReadIndexResponseⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "r" "m",
    exception_do (let: "m" := (GoAlloc raftpb.Message "m") in
    let: "r" := (GoAlloc (go.PointerType raft) "r") in
    let: "$sw" := (![ReadOnlyOption] (StructFieldRef readOnly "option"%go (![go.PointerType readOnly] (StructFieldRef raft "readOnly"%go (![go.PointerType raft] "r"))))) in
    (if: "$sw" =⟨ReadOnlyOption⟩ ReadOnlySafe
    then
      do:  (let: "$a0" := (![go.uint64] (StructFieldRef raftLog "committed"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r"))))) in
      let: "$a1" := (![raftpb.Message] "m") in
      (MethodResolve (go.PointerType readOnly) "addRequest"%go (![go.PointerType readOnly] (StructFieldRef raft "readOnly"%go (![go.PointerType raft] "r")))) "$a0" "$a1");;;
      do:  (let: "$a0" := (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r"))) in
      let: "$a1" := (![go.SliceType go.byte] (StructFieldRef raftpb.Entry "Data"%go (IndexRef (go.SliceType raftpb.Entry) (![go.SliceType raftpb.Entry] (StructFieldRef raftpb.Message "Entries"%go "m"), #(W64 0))))) in
      (MethodResolve (go.PointerType readOnly) "recvAck"%go (![go.PointerType readOnly] (StructFieldRef raft "readOnly"%go (![go.PointerType raft] "r")))) "$a0" "$a1");;;
      do:  (let: "$a0" := (![go.SliceType go.byte] (StructFieldRef raftpb.Entry "Data"%go (IndexRef (go.SliceType raftpb.Entry) (![go.SliceType raftpb.Entry] (StructFieldRef raftpb.Message "Entries"%go "m"), #(W64 0))))) in
      (MethodResolve (go.PointerType raft) "bcastHeartbeatWithCtx"%go (![go.PointerType raft] "r")) "$a0")
    else
      (if: "$sw" =⟨ReadOnlyOption⟩ ReadOnlyLeaseBased
      then
        (let: "resp" := (GoAlloc raftpb.Message (GoZeroVal raftpb.Message #())) in
        let: "$r0" := (let: "$a0" := (![raftpb.Message] "m") in
        let: "$a1" := (![go.uint64] (StructFieldRef raftLog "committed"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r"))))) in
        (MethodResolve (go.PointerType raft) "responseToReadIndexReq"%go (![go.PointerType raft] "r")) "$a0" "$a1") in
        do:  ("resp" <-[raftpb.Message] "$r0");;;
        (if: Convert go.untyped_bool go.bool ((![go.uint64] (StructFieldRef raftpb.Message "To"%go "resp")) ≠⟨go.uint64⟩ None)
        then
          do:  (let: "$a0" := (![raftpb.Message] "resp") in
          (MethodResolve (go.PointerType raft) "send"%go (![go.PointerType raft] "r")) "$a0")
        else do:  #()))
      else do:  #()));;;
    return: #()).

(* NewRawNode instantiates a RawNode from the given configuration.

   See Bootstrap() for bootstrapping an initial state; this replaces the former
   'peers' argument to this method (with identical behavior). However, It is
   recommended that instead of calling Bootstrap, applications bootstrap their
   state manually by setting up a Storage that has a first index > 1 and which
   stores the desired ConfState as its InitialState.

   go: rawnode.go:51:6 *)
Definition NewRawNodeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "config",
    exception_do (let: "config" := (GoAlloc (go.PointerType Config) "config") in
    let: "r" := (GoAlloc (go.PointerType raft) (GoZeroVal (go.PointerType raft) #())) in
    let: "$r0" := (let: "$a0" := (![go.PointerType Config] "config") in
    (FuncResolve newRaft [] #()) "$a0") in
    do:  ("r" <-[go.PointerType raft] "$r0");;;
    let: "rn" := (GoAlloc (go.PointerType RawNode) (GoZeroVal (go.PointerType RawNode) #())) in
    let: "$r0" := (GoAlloc RawNode (CompositeLiteral RawNode (LiteralValue [KeyedElement (Some (KeyField "raft"%go)) (ElementExpression (go.PointerType raft) (![go.PointerType raft] "r"))]))) in
    do:  ("rn" <-[go.PointerType RawNode] "$r0");;;
    let: "$r0" := (![go.bool] (StructFieldRef Config "AsyncStorageWrites"%go (![go.PointerType Config] "config"))) in
    do:  ((StructFieldRef RawNode "asyncStorageWrites"%go (![go.PointerType RawNode] "rn")) <-[go.bool] "$r0");;;
    let: "ss" := (GoAlloc SoftState (GoZeroVal SoftState #())) in
    let: "$r0" := ((MethodResolve (go.PointerType raft) "softState"%go (![go.PointerType raft] "r")) #()) in
    do:  ("ss" <-[SoftState] "$r0");;;
    let: "$r0" := "ss" in
    do:  ((StructFieldRef RawNode "prevSoftSt"%go (![go.PointerType RawNode] "rn")) <-[go.PointerType SoftState] "$r0");;;
    let: "$r0" := ((MethodResolve (go.PointerType raft) "hardState"%go (![go.PointerType raft] "r")) #()) in
    do:  ((StructFieldRef RawNode "prevHardSt"%go (![go.PointerType RawNode] "rn")) <-[raftpb.HardState] "$r0");;;
    return: (![go.PointerType RawNode] "rn", Convert go.untyped_nil go.error UntypedNil)).

(* Tick advances the internal logical clock by a single tick.

   go: rawnode.go:64:20 *)
Definition RawNode__Tickⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "rn" <>,
    exception_do (let: "rn" := (GoAlloc (go.PointerType RawNode) "rn") in
    do:  ((![go.FunctionType (go.Signature [] false [])] (StructFieldRef raft "tick"%go (![go.PointerType raft] (StructFieldRef RawNode "raft"%go (![go.PointerType RawNode] "rn"))))) #());;;
    return: #()).

(* TickQuiesced advances the internal logical clock by a single tick without
   performing any other state machine processing. It allows the caller to avoid
   periodic heartbeats and elections when all of the peers in a Raft group are
   known to be at the same state. Expected usage is to periodically invoke Tick
   or TickQuiesced depending on whether the group is "active" or "quiesced".

   WARNING: Be very careful about using this method as it subverts the Raft
   state machine. You should probably be using Tick instead.

   DEPRECATED: This method will be removed in a future release.

   go: rawnode.go:78:20 *)
Definition RawNode__TickQuiescedⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "rn" <>,
    exception_do (let: "rn" := (GoAlloc (go.PointerType RawNode) "rn") in
    do:  ((StructFieldRef raft "electionElapsed"%go (![go.PointerType raft] (StructFieldRef RawNode "raft"%go (![go.PointerType RawNode] "rn")))) <-[go.int] ((![go.int] (StructFieldRef raft "electionElapsed"%go (![go.PointerType raft] (StructFieldRef RawNode "raft"%go (![go.PointerType RawNode] "rn"))))) +⟨go.int⟩ #(W64 1)));;;
    return: #()).

(* Campaign causes this RawNode to transition to candidate state.

   go: rawnode.go:83:20 *)
Definition RawNode__Campaignⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "rn" <>,
    exception_do (let: "rn" := (GoAlloc (go.PointerType RawNode) "rn") in
    return: (let: "$a0" := (CompositeLiteral raftpb.Message (LiteralValue [KeyedElement (Some (KeyField "Type"%go)) (ElementExpression raftpb.MessageType raftpb.MsgHup)])) in
     (MethodResolve (go.PointerType raft) "Step"%go (![go.PointerType raft] (StructFieldRef RawNode "raft"%go (![go.PointerType RawNode] "rn")))) "$a0")).

(* Propose proposes data be appended to the raft log.

   go: rawnode.go:90:20 *)
Definition RawNode__Proposeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "rn" "data",
    exception_do (let: "rn" := (GoAlloc (go.PointerType RawNode) "rn") in
    let: "data" := (GoAlloc (go.SliceType go.byte) "data") in
    return: (let: "$a0" := (CompositeLiteral raftpb.Message (LiteralValue [KeyedElement (Some (KeyField "Type"%go)) (ElementExpression raftpb.MessageType raftpb.MsgProp); KeyedElement (Some (KeyField "From"%go)) (ElementExpression go.uint64 (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] (StructFieldRef RawNode "raft"%go (![go.PointerType RawNode] "rn")))))); KeyedElement (Some (KeyField "Entries"%go)) (ElementExpression (go.SliceType raftpb.Entry) (CompositeLiteral (go.SliceType raftpb.Entry) (LiteralValue [KeyedElement None (ElementLiteralValue [KeyedElement (Some (KeyField "Data"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] "data"))])])))])) in
     (MethodResolve (go.PointerType raft) "Step"%go (![go.PointerType raft] (StructFieldRef RawNode "raft"%go (![go.PointerType RawNode] "rn")))) "$a0")).

(* ProposeConfChange proposes a config change. See (Node).ProposeConfChange for
   details.

   go: rawnode.go:101:20 *)
Definition RawNode__ProposeConfChangeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "rn" "cc",
    exception_do (let: "rn" := (GoAlloc (go.PointerType RawNode) "rn") in
    let: "cc" := (GoAlloc raftpb.ConfChangeI "cc") in
    let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
    let: "m" := (GoAlloc raftpb.Message (GoZeroVal raftpb.Message #())) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![raftpb.ConfChangeI] "cc") in
    (FuncResolve confChangeToMsg [] #()) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("m" <-[raftpb.Message] "$r0");;;
    do:  ("err" <-[go.error] "$r1");;;
    (if: Convert go.untyped_bool go.bool ((![go.error] "err") ≠⟨go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]⟩ (Convert go.untyped_nil (go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]) UntypedNil))
    then return: (![go.error] "err")
    else do:  #());;;
    return: (let: "$a0" := (![raftpb.Message] "m") in
     (MethodResolve (go.PointerType raft) "Step"%go (![go.PointerType raft] (StructFieldRef RawNode "raft"%go (![go.PointerType RawNode] "rn")))) "$a0")).

(* ApplyConfChange applies a config change to the local node. The app must call
   this when it applies a configuration change, except when it decides to reject
   the configuration change, in which case no call must take place.

   go: rawnode.go:112:20 *)
Definition RawNode__ApplyConfChangeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "rn" "cc",
    exception_do (let: "rn" := (GoAlloc (go.PointerType RawNode) "rn") in
    let: "cc" := (GoAlloc raftpb.ConfChangeI "cc") in
    let: "cs" := (GoAlloc raftpb.ConfState (GoZeroVal raftpb.ConfState #())) in
    let: "$r0" := (let: "$a0" := ((MethodResolve raftpb.ConfChangeI "AsV2"%go (![raftpb.ConfChangeI] "cc")) #()) in
    (MethodResolve (go.PointerType raft) "applyConfChange"%go (![go.PointerType raft] (StructFieldRef RawNode "raft"%go (![go.PointerType RawNode] "rn")))) "$a0") in
    do:  ("cs" <-[raftpb.ConfState] "$r0");;;
    return: ("cs")).

(* Step advances the state machine using the given message.

   go: rawnode.go:118:20 *)
Definition RawNode__Stepⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "rn" "m",
    exception_do (let: "rn" := (GoAlloc (go.PointerType RawNode) "rn") in
    let: "m" := (GoAlloc raftpb.Message "m") in
    (if: (let: "$a0" := (![raftpb.MessageType] (StructFieldRef raftpb.Message "Type"%go "m")) in
    (FuncResolve IsLocalMsg [] #()) "$a0") && (~ (let: "$a0" := (![go.uint64] (StructFieldRef raftpb.Message "From"%go "m")) in
    (FuncResolve IsLocalMsgTarget [] #()) "$a0"))
    then return: (![go.error] (GlobalVarAddr ErrStepLocalMsg #()))
    else do:  #());;;
    (if: ((let: "$a0" := (![raftpb.MessageType] (StructFieldRef raftpb.Message "Type"%go "m")) in
    (FuncResolve IsResponseMsg [] #()) "$a0") && (~ (let: "$a0" := (![go.uint64] (StructFieldRef raftpb.Message "From"%go "m")) in
    (FuncResolve IsLocalMsgTarget [] #()) "$a0"))) && ((map.lookup1 go.uint64 (go.PointerType tracker.Progress) (![tracker.ProgressMap] (StructFieldRef tracker.ProgressTracker "Progress"%go (StructFieldRef raft "trk"%go (![go.PointerType raft] (StructFieldRef RawNode "raft"%go (![go.PointerType RawNode] "rn")))))) (![go.uint64] (StructFieldRef raftpb.Message "From"%go "m"))) =⟨go.PointerType tracker.Progress⟩ (Convert go.untyped_nil (go.PointerType tracker.Progress) UntypedNil))
    then return: (![go.error] (GlobalVarAddr ErrStepPeerNotFound #()))
    else do:  #());;;
    return: (let: "$a0" := (![raftpb.Message] "m") in
     (MethodResolve (go.PointerType raft) "Step"%go (![go.PointerType raft] (StructFieldRef RawNode "raft"%go (![go.PointerType RawNode] "rn")))) "$a0")).

(* Ready returns the outstanding work that the application needs to handle. This
   includes appending and applying entries or a snapshot, updating the HardState,
   and sending messages. The returned Ready() *must* be handled and subsequently
   passed back via Advance().

   go: rawnode.go:133:20 *)
Definition RawNode__Readyⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "rn" <>,
    exception_do (let: "rn" := (GoAlloc (go.PointerType RawNode) "rn") in
    let: "rd" := (GoAlloc Ready (GoZeroVal Ready #())) in
    let: "$r0" := ((MethodResolve (go.PointerType RawNode) "readyWithoutAccept"%go (![go.PointerType RawNode] "rn")) #()) in
    do:  ("rd" <-[Ready] "$r0");;;
    do:  (let: "$a0" := (![Ready] "rd") in
    (MethodResolve (go.PointerType RawNode) "acceptReady"%go (![go.PointerType RawNode] "rn")) "$a0");;;
    return: (![Ready] "rd")).

(* readyWithoutAccept returns a Ready. This is a read-only operation, i.e. there
   is no obligation that the Ready must be handled.

   go: rawnode.go:141:20 *)
Definition RawNode__readyWithoutAcceptⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "rn" <>,
    exception_do (let: "rn" := (GoAlloc (go.PointerType RawNode) "rn") in
    let: "r" := (GoAlloc (go.PointerType raft) (GoZeroVal (go.PointerType raft) #())) in
    let: "$r0" := (![go.PointerType raft] (StructFieldRef RawNode "raft"%go (![go.PointerType RawNode] "rn"))) in
    do:  ("r" <-[go.PointerType raft] "$r0");;;
    let: "rd" := (GoAlloc Ready (GoZeroVal Ready #())) in
    let: "$r0" := (CompositeLiteral Ready (LiteralValue [KeyedElement (Some (KeyField "Entries"%go)) (ElementExpression (go.SliceType raftpb.Entry) ((MethodResolve (go.PointerType raftLog) "nextUnstableEnts"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r")))) #())); KeyedElement (Some (KeyField "CommittedEntries"%go)) (ElementExpression (go.SliceType raftpb.Entry) (let: "$a0" := ((MethodResolve (go.PointerType RawNode) "applyUnstableEntries"%go (![go.PointerType RawNode] "rn")) #()) in
     (MethodResolve (go.PointerType raftLog) "nextCommittedEnts"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r")))) "$a0")); KeyedElement (Some (KeyField "Messages"%go)) (ElementExpression (go.SliceType raftpb.Message) (![go.SliceType raftpb.Message] (StructFieldRef raft "msgs"%go (![go.PointerType raft] "r"))))])) in
    do:  ("rd" <-[Ready] "$r0");;;
    (let: "softSt" := (GoAlloc SoftState (GoZeroVal SoftState #())) in
    let: "$r0" := ((MethodResolve (go.PointerType raft) "softState"%go (![go.PointerType raft] "r")) #()) in
    do:  ("softSt" <-[SoftState] "$r0");;;
    (if: (~ (let: "$a0" := (![go.PointerType SoftState] (StructFieldRef RawNode "prevSoftSt"%go (![go.PointerType RawNode] "rn"))) in
    (MethodResolve (go.PointerType SoftState) "equal"%go "softSt") "$a0"))
    then
      let: "escapingSoftSt" := (GoAlloc SoftState (GoZeroVal SoftState #())) in
      let: "$r0" := (![SoftState] "softSt") in
      do:  ("escapingSoftSt" <-[SoftState] "$r0");;;
      let: "$r0" := "escapingSoftSt" in
      do:  ((StructFieldRef Ready "SoftState"%go "rd") <-[go.PointerType SoftState] "$r0")
    else do:  #()));;;
    (let: "hardSt" := (GoAlloc raftpb.HardState (GoZeroVal raftpb.HardState #())) in
    let: "$r0" := ((MethodResolve (go.PointerType raft) "hardState"%go (![go.PointerType raft] "r")) #()) in
    do:  ("hardSt" <-[raftpb.HardState] "$r0");;;
    (if: (~ (let: "$a0" := (![raftpb.HardState] "hardSt") in
    let: "$a1" := (![raftpb.HardState] (StructFieldRef RawNode "prevHardSt"%go (![go.PointerType RawNode] "rn"))) in
    (FuncResolve isHardStateEqual [] #()) "$a0" "$a1"))
    then
      let: "$r0" := (![raftpb.HardState] "hardSt") in
      do:  ((StructFieldRef Ready "HardState"%go "rd") <-[raftpb.HardState] "$r0")
    else do:  #()));;;
    (if: (MethodResolve (go.PointerType raftLog) "hasNextUnstableSnapshot"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r")))) #()
    then
      let: "$r0" := (![raftpb.Snapshot] ((MethodResolve (go.PointerType raftLog) "nextUnstableSnapshot"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r")))) #())) in
      do:  ((StructFieldRef Ready "Snapshot"%go "rd") <-[raftpb.Snapshot] "$r0")
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool ((let: "$a0" := (![go.SliceType ReadState] (StructFieldRef raft "readStates"%go (![go.PointerType raft] "r"))) in
    (FuncResolve go.len [go.SliceType ReadState] #()) "$a0") ≠⟨go.int⟩ #(W64 0))
    then
      let: "$r0" := (![go.SliceType ReadState] (StructFieldRef raft "readStates"%go (![go.PointerType raft] "r"))) in
      do:  ((StructFieldRef Ready "ReadStates"%go "rd") <-[go.SliceType ReadState] "$r0")
    else do:  #());;;
    let: "$r0" := (let: "$a0" := ((MethodResolve (go.PointerType raft) "hardState"%go (![go.PointerType raft] "r")) #()) in
    let: "$a1" := (![raftpb.HardState] (StructFieldRef RawNode "prevHardSt"%go (![go.PointerType RawNode] "rn"))) in
    let: "$a2" := (let: "$a0" := (![go.SliceType raftpb.Entry] (StructFieldRef Ready "Entries"%go "rd")) in
    (FuncResolve go.len [go.SliceType raftpb.Entry] #()) "$a0") in
    (FuncResolve MustSync [] #()) "$a0" "$a1" "$a2") in
    do:  ((StructFieldRef Ready "MustSync"%go "rd") <-[go.bool] "$r0");;;
    (if: ![go.bool] (StructFieldRef RawNode "asyncStorageWrites"%go (![go.PointerType RawNode] "rn"))
    then
      (if: let: "$a0" := (![go.PointerType raft] "r") in
      let: "$a1" := (![Ready] "rd") in
      (FuncResolve needStorageAppendMsg [] #()) "$a0" "$a1"
      then
        let: "m" := (GoAlloc raftpb.Message (GoZeroVal raftpb.Message #())) in
        let: "$r0" := (let: "$a0" := (![go.PointerType raft] "r") in
        let: "$a1" := (![Ready] "rd") in
        (FuncResolve newStorageAppendMsg [] #()) "$a0" "$a1") in
        do:  ("m" <-[raftpb.Message] "$r0");;;
        let: "$r0" := (let: "$a0" := (![go.SliceType raftpb.Message] (StructFieldRef Ready "Messages"%go "rd")) in
        let: "$a1" := ((let: "$sl0" := (![raftpb.Message] "m") in
        CompositeLiteral (go.SliceType raftpb.Message) (LiteralValue [KeyedElement None (ElementExpression raftpb.Message "$sl0")]))) in
        (FuncResolve go.append [go.SliceType raftpb.Message] #()) "$a0" "$a1") in
        do:  ((StructFieldRef Ready "Messages"%go "rd") <-[go.SliceType raftpb.Message] "$r0")
      else do:  #());;;
      (if: let: "$a0" := (![Ready] "rd") in
      (FuncResolve needStorageApplyMsg [] #()) "$a0"
      then
        let: "m" := (GoAlloc raftpb.Message (GoZeroVal raftpb.Message #())) in
        let: "$r0" := (let: "$a0" := (![go.PointerType raft] "r") in
        let: "$a1" := (![Ready] "rd") in
        (FuncResolve newStorageApplyMsg [] #()) "$a0" "$a1") in
        do:  ("m" <-[raftpb.Message] "$r0");;;
        let: "$r0" := (let: "$a0" := (![go.SliceType raftpb.Message] (StructFieldRef Ready "Messages"%go "rd")) in
        let: "$a1" := ((let: "$sl0" := (![raftpb.Message] "m") in
        CompositeLiteral (go.SliceType raftpb.Message) (LiteralValue [KeyedElement None (ElementExpression raftpb.Message "$sl0")]))) in
        (FuncResolve go.append [go.SliceType raftpb.Message] #()) "$a0" "$a1") in
        do:  ((StructFieldRef Ready "Messages"%go "rd") <-[go.SliceType raftpb.Message] "$r0")
      else do:  #())
    else
      let: "$range" := (![go.SliceType raftpb.Message] (StructFieldRef raft "msgsAfterAppend"%go (![go.PointerType raft] "r"))) in
      (let: "m" := (GoAlloc raftpb.Message (GoZeroVal raftpb.Message #())) in
      slice.for_range raftpb.Message "$range" (λ: "$key" "$value",
        do:  ("m" <-[raftpb.Message] "$value");;;
        do:  "$key";;;
        (if: Convert go.untyped_bool go.bool ((![go.uint64] (StructFieldRef raftpb.Message "To"%go "m")) ≠⟨go.uint64⟩ (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r"))))
        then
          let: "$r0" := (let: "$a0" := (![go.SliceType raftpb.Message] (StructFieldRef Ready "Messages"%go "rd")) in
          let: "$a1" := ((let: "$sl0" := (![raftpb.Message] "m") in
          CompositeLiteral (go.SliceType raftpb.Message) (LiteralValue [KeyedElement None (ElementExpression raftpb.Message "$sl0")]))) in
          (FuncResolve go.append [go.SliceType raftpb.Message] #()) "$a0" "$a1") in
          do:  ((StructFieldRef Ready "Messages"%go "rd") <-[go.SliceType raftpb.Message] "$r0")
        else do:  #()))));;;
    return: (![Ready] "rd")).

(* MustSync returns true if the hard state and count of Raft entries indicate
   that a synchronous write to persistent storage is required.

   go: rawnode.go:193:6 *)
Definition MustSyncⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "st" "prevst" "entsnum",
    exception_do (let: "entsnum" := (GoAlloc go.int "entsnum") in
    let: "prevst" := (GoAlloc raftpb.HardState "prevst") in
    let: "st" := (GoAlloc raftpb.HardState "st") in
    return: ((((![go.int] "entsnum") ≠⟨go.int⟩ #(W64 0)) || ((![go.uint64] (StructFieldRef raftpb.HardState "Vote"%go "st")) ≠⟨go.uint64⟩ (![go.uint64] (StructFieldRef raftpb.HardState "Vote"%go "prevst")))) || ((![go.uint64] (StructFieldRef raftpb.HardState "Term"%go "st")) ≠⟨go.uint64⟩ (![go.uint64] (StructFieldRef raftpb.HardState "Term"%go "prevst"))))).

(* go: rawnode.go:202:6 *)
Definition needStorageAppendMsgⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "r" "rd",
    exception_do (let: "rd" := (GoAlloc Ready "rd") in
    let: "r" := (GoAlloc (go.PointerType raft) "r") in
    return: (((((let: "$a0" := (![go.SliceType raftpb.Entry] (StructFieldRef Ready "Entries"%go "rd")) in
     (FuncResolve go.len [go.SliceType raftpb.Entry] #()) "$a0") >⟨go.int⟩ #(W64 0)) || (~ (let: "$a0" := (![raftpb.HardState] (StructFieldRef Ready "HardState"%go "rd")) in
     (FuncResolve IsEmptyHardState [] #()) "$a0"))) || (~ (let: "$a0" := (![raftpb.Snapshot] (StructFieldRef Ready "Snapshot"%go "rd")) in
     (FuncResolve IsEmptySnap [] #()) "$a0"))) || ((let: "$a0" := (![go.SliceType raftpb.Message] (StructFieldRef raft "msgsAfterAppend"%go (![go.PointerType raft] "r"))) in
     (FuncResolve go.len [go.SliceType raftpb.Message] #()) "$a0") >⟨go.int⟩ #(W64 0)))).

(* go: rawnode.go:212:6 *)
Definition needStorageAppendRespMsgⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "r" "rd",
    exception_do (let: "rd" := (GoAlloc Ready "rd") in
    let: "r" := (GoAlloc (go.PointerType raft) "r") in
    return: (((MethodResolve (go.PointerType raftLog) "hasNextOrInProgressUnstableEnts"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r")))) #()) || (~ (let: "$a0" := (![raftpb.Snapshot] (StructFieldRef Ready "Snapshot"%go "rd")) in
     (FuncResolve IsEmptySnap [] #()) "$a0")))).

(* newStorageAppendMsg creates the message that should be sent to the local
   append thread to instruct it to append log entries, write an updated hard
   state, and apply a snapshot. The message also carries a set of responses
   that should be delivered after the rest of the message is processed. Used
   with AsyncStorageWrites.

   go: rawnode.go:225:6 *)
Definition newStorageAppendMsgⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "r" "rd",
    exception_do (let: "rd" := (GoAlloc Ready "rd") in
    let: "r" := (GoAlloc (go.PointerType raft) "r") in
    let: "m" := (GoAlloc raftpb.Message (GoZeroVal raftpb.Message #())) in
    let: "$r0" := (CompositeLiteral raftpb.Message (LiteralValue [KeyedElement (Some (KeyField "Type"%go)) (ElementExpression raftpb.MessageType raftpb.MsgStorageAppend); KeyedElement (Some (KeyField "To"%go)) (ElementExpression go.uint64 LocalAppendThread); KeyedElement (Some (KeyField "From"%go)) (ElementExpression go.uint64 (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))); KeyedElement (Some (KeyField "Entries"%go)) (ElementExpression (go.SliceType raftpb.Entry) (![go.SliceType raftpb.Entry] (StructFieldRef Ready "Entries"%go "rd")))])) in
    do:  ("m" <-[raftpb.Message] "$r0");;;
    (if: (~ (let: "$a0" := (![raftpb.HardState] (StructFieldRef Ready "HardState"%go "rd")) in
    (FuncResolve IsEmptyHardState [] #()) "$a0"))
    then
      let: "$r0" := (![go.uint64] (StructFieldRef raftpb.HardState "Term"%go (StructFieldRef Ready "HardState"%go "rd"))) in
      do:  ((StructFieldRef raftpb.Message "Term"%go "m") <-[go.uint64] "$r0");;;
      let: "$r0" := (![go.uint64] (StructFieldRef raftpb.HardState "Vote"%go (StructFieldRef Ready "HardState"%go "rd"))) in
      do:  ((StructFieldRef raftpb.Message "Vote"%go "m") <-[go.uint64] "$r0");;;
      let: "$r0" := (![go.uint64] (StructFieldRef raftpb.HardState "Commit"%go (StructFieldRef Ready "HardState"%go "rd"))) in
      do:  ((StructFieldRef raftpb.Message "Commit"%go "m") <-[go.uint64] "$r0")
    else do:  #());;;
    (if: (~ (let: "$a0" := (![raftpb.Snapshot] (StructFieldRef Ready "Snapshot"%go "rd")) in
    (FuncResolve IsEmptySnap [] #()) "$a0"))
    then
      let: "snap" := (GoAlloc raftpb.Snapshot (GoZeroVal raftpb.Snapshot #())) in
      let: "$r0" := (![raftpb.Snapshot] (StructFieldRef Ready "Snapshot"%go "rd")) in
      do:  ("snap" <-[raftpb.Snapshot] "$r0");;;
      let: "$r0" := "snap" in
      do:  ((StructFieldRef raftpb.Message "Snapshot"%go "m") <-[go.PointerType raftpb.Snapshot] "$r0")
    else do:  #());;;
    let: "$r0" := (![go.SliceType raftpb.Message] (StructFieldRef raft "msgsAfterAppend"%go (![go.PointerType raft] "r"))) in
    do:  ((StructFieldRef raftpb.Message "Responses"%go "m") <-[go.SliceType raftpb.Message] "$r0");;;
    (if: let: "$a0" := (![go.PointerType raft] "r") in
    let: "$a1" := (![Ready] "rd") in
    (FuncResolve needStorageAppendRespMsg [] #()) "$a0" "$a1"
    then
      let: "$r0" := (let: "$a0" := (![go.SliceType raftpb.Message] (StructFieldRef raftpb.Message "Responses"%go "m")) in
      let: "$a1" := ((let: "$sl0" := (let: "$a0" := (![go.PointerType raft] "r") in
      let: "$a1" := (![Ready] "rd") in
      (FuncResolve newStorageAppendRespMsg [] #()) "$a0" "$a1") in
      CompositeLiteral (go.SliceType raftpb.Message) (LiteralValue [KeyedElement None (ElementExpression raftpb.Message "$sl0")]))) in
      (FuncResolve go.append [go.SliceType raftpb.Message] #()) "$a0" "$a1") in
      do:  ((StructFieldRef raftpb.Message "Responses"%go "m") <-[go.SliceType raftpb.Message] "$r0")
    else do:  #());;;
    return: (![raftpb.Message] "m")).

(* newStorageAppendRespMsg creates the message that should be returned to node
   after the unstable log entries, hard state, and snapshot in the current Ready
   (along with those in all prior Ready structs) have been saved to stable
   storage.

   go: rawnode.go:268:6 *)
Definition newStorageAppendRespMsgⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "r" "rd",
    exception_do (let: "rd" := (GoAlloc Ready "rd") in
    let: "r" := (GoAlloc (go.PointerType raft) "r") in
    let: "m" := (GoAlloc raftpb.Message (GoZeroVal raftpb.Message #())) in
    let: "$r0" := (CompositeLiteral raftpb.Message (LiteralValue [KeyedElement (Some (KeyField "Type"%go)) (ElementExpression raftpb.MessageType raftpb.MsgStorageAppendResp); KeyedElement (Some (KeyField "To"%go)) (ElementExpression go.uint64 (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))); KeyedElement (Some (KeyField "From"%go)) (ElementExpression go.uint64 LocalAppendThread); KeyedElement (Some (KeyField "Term"%go)) (ElementExpression go.uint64 (![go.uint64] (StructFieldRef raft "Term"%go (![go.PointerType raft] "r"))))])) in
    do:  ("m" <-[raftpb.Message] "$r0");;;
    (if: (MethodResolve (go.PointerType raftLog) "hasNextOrInProgressUnstableEnts"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r")))) #()
    then
      let: "last" := (GoAlloc entryID (GoZeroVal entryID #())) in
      let: "$r0" := ((MethodResolve (go.PointerType raftLog) "lastEntryID"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r")))) #()) in
      do:  ("last" <-[entryID] "$r0");;;
      let: "$r0" := (![go.uint64] (StructFieldRef entryID "index"%go "last")) in
      do:  ((StructFieldRef raftpb.Message "Index"%go "m") <-[go.uint64] "$r0");;;
      let: "$r0" := (![go.uint64] (StructFieldRef entryID "term"%go "last")) in
      do:  ((StructFieldRef raftpb.Message "LogTerm"%go "m") <-[go.uint64] "$r0")
    else do:  #());;;
    (if: (~ (let: "$a0" := (![raftpb.Snapshot] (StructFieldRef Ready "Snapshot"%go "rd")) in
    (FuncResolve IsEmptySnap [] #()) "$a0"))
    then
      let: "snap" := (GoAlloc raftpb.Snapshot (GoZeroVal raftpb.Snapshot #())) in
      let: "$r0" := (![raftpb.Snapshot] (StructFieldRef Ready "Snapshot"%go "rd")) in
      do:  ("snap" <-[raftpb.Snapshot] "$r0");;;
      let: "$r0" := "snap" in
      do:  ((StructFieldRef raftpb.Message "Snapshot"%go "m") <-[go.PointerType raftpb.Snapshot] "$r0")
    else do:  #());;;
    return: (![raftpb.Message] "m")).

(* go: rawnode.go:368:6 *)
Definition needStorageApplyMsgⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "rd",
    exception_do (let: "rd" := (GoAlloc Ready "rd") in
    return: ((let: "$a0" := (![go.SliceType raftpb.Entry] (StructFieldRef Ready "CommittedEntries"%go "rd")) in
     (FuncResolve go.len [go.SliceType raftpb.Entry] #()) "$a0") >⟨go.int⟩ #(W64 0))).

(* go: rawnode.go:369:6 *)
Definition needStorageApplyRespMsgⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "rd",
    exception_do (let: "rd" := (GoAlloc Ready "rd") in
    return: (let: "$a0" := (![Ready] "rd") in
     (FuncResolve needStorageApplyMsg [] #()) "$a0")).

(* newStorageApplyMsg creates the message that should be sent to the local
   apply thread to instruct it to apply committed log entries. The message
   also carries a response that should be delivered after the rest of the
   message is processed. Used with AsyncStorageWrites.

   go: rawnode.go:375:6 *)
Definition newStorageApplyMsgⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "r" "rd",
    exception_do (let: "rd" := (GoAlloc Ready "rd") in
    let: "r" := (GoAlloc (go.PointerType raft) "r") in
    let: "ents" := (GoAlloc (go.SliceType raftpb.Entry) (GoZeroVal (go.SliceType raftpb.Entry) #())) in
    let: "$r0" := (![go.SliceType raftpb.Entry] (StructFieldRef Ready "CommittedEntries"%go "rd")) in
    do:  ("ents" <-[go.SliceType raftpb.Entry] "$r0");;;
    return: (CompositeLiteral raftpb.Message (LiteralValue [KeyedElement (Some (KeyField "Type"%go)) (ElementExpression raftpb.MessageType raftpb.MsgStorageApply); KeyedElement (Some (KeyField "To"%go)) (ElementExpression go.uint64 LocalApplyThread); KeyedElement (Some (KeyField "From"%go)) (ElementExpression go.uint64 (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))); KeyedElement (Some (KeyField "Term"%go)) (ElementExpression go.uint64 #(W64 0)); KeyedElement (Some (KeyField "Entries"%go)) (ElementExpression (go.SliceType raftpb.Entry) (![go.SliceType raftpb.Entry] "ents")); KeyedElement (Some (KeyField "Responses"%go)) (ElementExpression (go.SliceType raftpb.Message) (CompositeLiteral (go.SliceType raftpb.Message) (LiteralValue [KeyedElement None (ElementExpression raftpb.Message (let: "$a0" := (![go.PointerType raft] "r") in
       let: "$a1" := (![go.SliceType raftpb.Entry] "ents") in
       (FuncResolve newStorageApplyRespMsg [] #()) "$a0" "$a1"))])))]))).

(* newStorageApplyRespMsg creates the message that should be returned to node
   after the committed entries in the current Ready (along with those in all
   prior Ready structs) have been applied to the local state machine.

   go: rawnode.go:392:6 *)
Definition newStorageApplyRespMsgⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "r" "ents",
    exception_do (let: "ents" := (GoAlloc (go.SliceType raftpb.Entry) "ents") in
    let: "r" := (GoAlloc (go.PointerType raft) "r") in
    return: (CompositeLiteral raftpb.Message (LiteralValue [KeyedElement (Some (KeyField "Type"%go)) (ElementExpression raftpb.MessageType raftpb.MsgStorageApplyResp); KeyedElement (Some (KeyField "To"%go)) (ElementExpression go.uint64 (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))); KeyedElement (Some (KeyField "From"%go)) (ElementExpression go.uint64 LocalApplyThread); KeyedElement (Some (KeyField "Term"%go)) (ElementExpression go.uint64 #(W64 0)); KeyedElement (Some (KeyField "Entries"%go)) (ElementExpression (go.SliceType raftpb.Entry) (![go.SliceType raftpb.Entry] "ents"))]))).

(* acceptReady is called when the consumer of the RawNode has decided to go
   ahead and handle a Ready. Nothing must alter the state of the RawNode between
   this call and the prior call to Ready().

   go: rawnode.go:405:20 *)
Definition RawNode__acceptReadyⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "rn" "rd",
    exception_do (let: "rn" := (GoAlloc (go.PointerType RawNode) "rn") in
    let: "rd" := (GoAlloc Ready "rd") in
    (if: Convert go.untyped_bool go.bool ((![go.PointerType SoftState] (StructFieldRef Ready "SoftState"%go "rd")) ≠⟨go.PointerType SoftState⟩ (Convert go.untyped_nil (go.PointerType SoftState) UntypedNil))
    then
      let: "$r0" := (![go.PointerType SoftState] (StructFieldRef Ready "SoftState"%go "rd")) in
      do:  ((StructFieldRef RawNode "prevSoftSt"%go (![go.PointerType RawNode] "rn")) <-[go.PointerType SoftState] "$r0")
    else do:  #());;;
    (if: (~ (let: "$a0" := (![raftpb.HardState] (StructFieldRef Ready "HardState"%go "rd")) in
    (FuncResolve IsEmptyHardState [] #()) "$a0"))
    then
      let: "$r0" := (![raftpb.HardState] (StructFieldRef Ready "HardState"%go "rd")) in
      do:  ((StructFieldRef RawNode "prevHardSt"%go (![go.PointerType RawNode] "rn")) <-[raftpb.HardState] "$r0")
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool ((let: "$a0" := (![go.SliceType ReadState] (StructFieldRef Ready "ReadStates"%go "rd")) in
    (FuncResolve go.len [go.SliceType ReadState] #()) "$a0") ≠⟨go.int⟩ #(W64 0))
    then
      let: "$r0" := (Convert go.untyped_nil (go.SliceType ReadState) UntypedNil) in
      do:  ((StructFieldRef raft "readStates"%go (![go.PointerType raft] (StructFieldRef RawNode "raft"%go (![go.PointerType RawNode] "rn")))) <-[go.SliceType ReadState] "$r0")
    else do:  #());;;
    (if: (~ (![go.bool] (StructFieldRef RawNode "asyncStorageWrites"%go (![go.PointerType RawNode] "rn"))))
    then
      (if: Convert go.untyped_bool go.bool ((let: "$a0" := (![go.SliceType raftpb.Message] (StructFieldRef RawNode "stepsOnAdvance"%go (![go.PointerType RawNode] "rn"))) in
      (FuncResolve go.len [go.SliceType raftpb.Message] #()) "$a0") ≠⟨go.int⟩ #(W64 0))
      then
        do:  (let: "$a0" := #"two accepted Ready structs without call to Advance"%go in
        let: "$a1" := #slice.nil in
        (MethodResolve Logger "Panicf"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] (StructFieldRef RawNode "raft"%go (![go.PointerType RawNode] "rn")))))) "$a0" "$a1")
      else do:  #());;;
      let: "$range" := (![go.SliceType raftpb.Message] (StructFieldRef raft "msgsAfterAppend"%go (![go.PointerType raft] (StructFieldRef RawNode "raft"%go (![go.PointerType RawNode] "rn"))))) in
      (let: "m" := (GoAlloc raftpb.Message (GoZeroVal raftpb.Message #())) in
      slice.for_range raftpb.Message "$range" (λ: "$key" "$value",
        do:  ("m" <-[raftpb.Message] "$value");;;
        do:  "$key";;;
        (if: Convert go.untyped_bool go.bool ((![go.uint64] (StructFieldRef raftpb.Message "To"%go "m")) =⟨go.uint64⟩ (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] (StructFieldRef RawNode "raft"%go (![go.PointerType RawNode] "rn"))))))
        then
          let: "$r0" := (let: "$a0" := (![go.SliceType raftpb.Message] (StructFieldRef RawNode "stepsOnAdvance"%go (![go.PointerType RawNode] "rn"))) in
          let: "$a1" := ((let: "$sl0" := (![raftpb.Message] "m") in
          CompositeLiteral (go.SliceType raftpb.Message) (LiteralValue [KeyedElement None (ElementExpression raftpb.Message "$sl0")]))) in
          (FuncResolve go.append [go.SliceType raftpb.Message] #()) "$a0" "$a1") in
          do:  ((StructFieldRef RawNode "stepsOnAdvance"%go (![go.PointerType RawNode] "rn")) <-[go.SliceType raftpb.Message] "$r0")
        else do:  #())));;;
      (if: let: "$a0" := (![go.PointerType raft] (StructFieldRef RawNode "raft"%go (![go.PointerType RawNode] "rn"))) in
      let: "$a1" := (![Ready] "rd") in
      (FuncResolve needStorageAppendRespMsg [] #()) "$a0" "$a1"
      then
        let: "m" := (GoAlloc raftpb.Message (GoZeroVal raftpb.Message #())) in
        let: "$r0" := (let: "$a0" := (![go.PointerType raft] (StructFieldRef RawNode "raft"%go (![go.PointerType RawNode] "rn"))) in
        let: "$a1" := (![Ready] "rd") in
        (FuncResolve newStorageAppendRespMsg [] #()) "$a0" "$a1") in
        do:  ("m" <-[raftpb.Message] "$r0");;;
        let: "$r0" := (let: "$a0" := (![go.SliceType raftpb.Message] (StructFieldRef RawNode "stepsOnAdvance"%go (![go.PointerType RawNode] "rn"))) in
        let: "$a1" := ((let: "$sl0" := (![raftpb.Message] "m") in
        CompositeLiteral (go.SliceType raftpb.Message) (LiteralValue [KeyedElement None (ElementExpression raftpb.Message "$sl0")]))) in
        (FuncResolve go.append [go.SliceType raftpb.Message] #()) "$a0" "$a1") in
        do:  ((StructFieldRef RawNode "stepsOnAdvance"%go (![go.PointerType RawNode] "rn")) <-[go.SliceType raftpb.Message] "$r0")
      else do:  #());;;
      (if: let: "$a0" := (![Ready] "rd") in
      (FuncResolve needStorageApplyRespMsg [] #()) "$a0"
      then
        let: "m" := (GoAlloc raftpb.Message (GoZeroVal raftpb.Message #())) in
        let: "$r0" := (let: "$a0" := (![go.PointerType raft] (StructFieldRef RawNode "raft"%go (![go.PointerType RawNode] "rn"))) in
        let: "$a1" := (![go.SliceType raftpb.Entry] (StructFieldRef Ready "CommittedEntries"%go "rd")) in
        (FuncResolve newStorageApplyRespMsg [] #()) "$a0" "$a1") in
        do:  ("m" <-[raftpb.Message] "$r0");;;
        let: "$r0" := (let: "$a0" := (![go.SliceType raftpb.Message] (StructFieldRef RawNode "stepsOnAdvance"%go (![go.PointerType RawNode] "rn"))) in
        let: "$a1" := ((let: "$sl0" := (![raftpb.Message] "m") in
        CompositeLiteral (go.SliceType raftpb.Message) (LiteralValue [KeyedElement None (ElementExpression raftpb.Message "$sl0")]))) in
        (FuncResolve go.append [go.SliceType raftpb.Message] #()) "$a0" "$a1") in
        do:  ((StructFieldRef RawNode "stepsOnAdvance"%go (![go.PointerType RawNode] "rn")) <-[go.SliceType raftpb.Message] "$r0")
      else do:  #())
    else do:  #());;;
    let: "$r0" := (Convert go.untyped_nil (go.SliceType raftpb.Message) UntypedNil) in
    do:  ((StructFieldRef raft "msgs"%go (![go.PointerType raft] (StructFieldRef RawNode "raft"%go (![go.PointerType RawNode] "rn")))) <-[go.SliceType raftpb.Message] "$r0");;;
    let: "$r0" := (Convert go.untyped_nil (go.SliceType raftpb.Message) UntypedNil) in
    do:  ((StructFieldRef raft "msgsAfterAppend"%go (![go.PointerType raft] (StructFieldRef RawNode "raft"%go (![go.PointerType RawNode] "rn")))) <-[go.SliceType raftpb.Message] "$r0");;;
    do:  ((MethodResolve (go.PointerType raftLog) "acceptUnstable"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] (StructFieldRef RawNode "raft"%go (![go.PointerType RawNode] "rn")))))) #());;;
    (if: Convert go.untyped_bool go.bool ((let: "$a0" := (![go.SliceType raftpb.Entry] (StructFieldRef Ready "CommittedEntries"%go "rd")) in
    (FuncResolve go.len [go.SliceType raftpb.Entry] #()) "$a0") >⟨go.int⟩ #(W64 0))
    then
      let: "ents" := (GoAlloc (go.SliceType raftpb.Entry) (GoZeroVal (go.SliceType raftpb.Entry) #())) in
      let: "$r0" := (![go.SliceType raftpb.Entry] (StructFieldRef Ready "CommittedEntries"%go "rd")) in
      do:  ("ents" <-[go.SliceType raftpb.Entry] "$r0");;;
      let: "index" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: "$r0" := (![go.uint64] (StructFieldRef raftpb.Entry "Index"%go (IndexRef (go.SliceType raftpb.Entry) (![go.SliceType raftpb.Entry] "ents", (let: "$a0" := (![go.SliceType raftpb.Entry] "ents") in
       (FuncResolve go.len [go.SliceType raftpb.Entry] #()) "$a0") -⟨go.int⟩ #(W64 1))))) in
      do:  ("index" <-[go.uint64] "$r0");;;
      do:  (let: "$a0" := (![go.uint64] "index") in
      let: "$a1" := (let: "$a0" := (![go.SliceType raftpb.Entry] "ents") in
      (FuncResolve entsSize [] #()) "$a0") in
      let: "$a2" := ((MethodResolve (go.PointerType RawNode) "applyUnstableEntries"%go (![go.PointerType RawNode] "rn")) #()) in
      (MethodResolve (go.PointerType raftLog) "acceptApplying"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] (StructFieldRef RawNode "raft"%go (![go.PointerType RawNode] "rn")))))) "$a0" "$a1" "$a2")
    else do:  #());;;
    do:  (let: "$a0" := (![go.PointerType raft] (StructFieldRef RawNode "raft"%go (![go.PointerType RawNode] "rn"))) in
    (FuncResolve traceReady [] #()) "$a0");;;
    return: #()).

(* applyUnstableEntries returns whether entries are allowed to be applied once
   they are known to be committed but before they have been written locally to
   stable storage.

   go: rawnode.go:448:20 *)
Definition RawNode__applyUnstableEntriesⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "rn" <>,
    exception_do (let: "rn" := (GoAlloc (go.PointerType RawNode) "rn") in
    return: ((~ (![go.bool] (StructFieldRef RawNode "asyncStorageWrites"%go (![go.PointerType RawNode] "rn")))))).

(* HasReady called when RawNode user need to check if any Ready pending.

   go: rawnode.go:453:20 *)
Definition RawNode__HasReadyⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "rn" <>,
    exception_do (let: "rn" := (GoAlloc (go.PointerType RawNode) "rn") in
    let: "r" := (GoAlloc (go.PointerType raft) (GoZeroVal (go.PointerType raft) #())) in
    let: "$r0" := (![go.PointerType raft] (StructFieldRef RawNode "raft"%go (![go.PointerType RawNode] "rn"))) in
    do:  ("r" <-[go.PointerType raft] "$r0");;;
    (let: "softSt" := (GoAlloc SoftState (GoZeroVal SoftState #())) in
    let: "$r0" := ((MethodResolve (go.PointerType raft) "softState"%go (![go.PointerType raft] "r")) #()) in
    do:  ("softSt" <-[SoftState] "$r0");;;
    (if: (~ (let: "$a0" := (![go.PointerType SoftState] (StructFieldRef RawNode "prevSoftSt"%go (![go.PointerType RawNode] "rn"))) in
    (MethodResolve (go.PointerType SoftState) "equal"%go "softSt") "$a0"))
    then return: (#true)
    else do:  #()));;;
    (let: "hardSt" := (GoAlloc raftpb.HardState (GoZeroVal raftpb.HardState #())) in
    let: "$r0" := ((MethodResolve (go.PointerType raft) "hardState"%go (![go.PointerType raft] "r")) #()) in
    do:  ("hardSt" <-[raftpb.HardState] "$r0");;;
    (if: (~ (let: "$a0" := (![raftpb.HardState] "hardSt") in
    (FuncResolve IsEmptyHardState [] #()) "$a0")) && (~ (let: "$a0" := (![raftpb.HardState] "hardSt") in
    let: "$a1" := (![raftpb.HardState] (StructFieldRef RawNode "prevHardSt"%go (![go.PointerType RawNode] "rn"))) in
    (FuncResolve isHardStateEqual [] #()) "$a0" "$a1"))
    then return: (#true)
    else do:  #()));;;
    (if: (MethodResolve (go.PointerType raftLog) "hasNextUnstableSnapshot"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r")))) #()
    then return: (#true)
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool (((let: "$a0" := (![go.SliceType raftpb.Message] (StructFieldRef raft "msgs"%go (![go.PointerType raft] "r"))) in
    (FuncResolve go.len [go.SliceType raftpb.Message] #()) "$a0") >⟨go.int⟩ #(W64 0)) || ((let: "$a0" := (![go.SliceType raftpb.Message] (StructFieldRef raft "msgsAfterAppend"%go (![go.PointerType raft] "r"))) in
    (FuncResolve go.len [go.SliceType raftpb.Message] #()) "$a0") >⟨go.int⟩ #(W64 0)))
    then return: (#true)
    else do:  #());;;
    (if: ((MethodResolve (go.PointerType raftLog) "hasNextUnstableEnts"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r")))) #()) || (let: "$a0" := ((MethodResolve (go.PointerType RawNode) "applyUnstableEntries"%go (![go.PointerType RawNode] "rn")) #()) in
    (MethodResolve (go.PointerType raftLog) "hasNextCommittedEnts"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r")))) "$a0")
    then return: (#true)
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool ((let: "$a0" := (![go.SliceType ReadState] (StructFieldRef raft "readStates"%go (![go.PointerType raft] "r"))) in
    (FuncResolve go.len [go.SliceType ReadState] #()) "$a0") ≠⟨go.int⟩ #(W64 0))
    then return: (#true)
    else do:  #());;;
    return: (#false)).

(* Advance notifies the RawNode that the application has applied and saved progress in the
   last Ready results.

   NOTE: Advance must not be called when using AsyncStorageWrites. Response messages from
   the local append and apply threads take its place.

   go: rawnode.go:482:20 *)
Definition RawNode__Advanceⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "rn" <>,
    exception_do (let: "rn" := (GoAlloc (go.PointerType RawNode) "rn") in
    (if: ![go.bool] (StructFieldRef RawNode "asyncStorageWrites"%go (![go.PointerType RawNode] "rn"))
    then
      do:  (let: "$a0" := #"Advance must not be called when using AsyncStorageWrites"%go in
      let: "$a1" := #slice.nil in
      (MethodResolve Logger "Panicf"%go (![Logger] (StructFieldRef raft "logger"%go (![go.PointerType raft] (StructFieldRef RawNode "raft"%go (![go.PointerType RawNode] "rn")))))) "$a0" "$a1")
    else do:  #());;;
    let: "$range" := (![go.SliceType raftpb.Message] (StructFieldRef RawNode "stepsOnAdvance"%go (![go.PointerType RawNode] "rn"))) in
    (let: "m" := (GoAlloc raftpb.Message (GoZeroVal raftpb.Message #())) in
    let: "i" := (GoAlloc go.int (GoZeroVal go.int #())) in
    slice.for_range raftpb.Message "$range" (λ: "$key" "$value",
      do:  ("m" <-[raftpb.Message] "$value");;;
      do:  ("i" <-[go.int] "$key");;;
      let: "$r0" := (let: "$a0" := (![raftpb.Message] "m") in
      (MethodResolve (go.PointerType raft) "Step"%go (![go.PointerType raft] (StructFieldRef RawNode "raft"%go (![go.PointerType RawNode] "rn")))) "$a0") in
      do:  "$r0";;;
      let: "$r0" := (CompositeLiteral raftpb.Message (LiteralValue [])) in
      do:  ((IndexRef (go.SliceType raftpb.Message) (![go.SliceType raftpb.Message] (StructFieldRef RawNode "stepsOnAdvance"%go (![go.PointerType RawNode] "rn")), ![go.int] "i")) <-[raftpb.Message] "$r0")));;;
    let: "$r0" := (let: "$s" := (![go.SliceType raftpb.Message] (StructFieldRef RawNode "stepsOnAdvance"%go (![go.PointerType RawNode] "rn"))) in
    Slice (go.SliceType raftpb.Message) ("$s", #(W64 0), #(W64 0))) in
    do:  ((StructFieldRef RawNode "stepsOnAdvance"%go (![go.PointerType RawNode] "rn")) <-[go.SliceType raftpb.Message] "$r0");;;
    return: #()).

(* Status returns the current status of the given group. This allocates, see
   BasicStatus and WithProgress for allocation-friendlier choices.

   go: rawnode.go:498:20 *)
Definition RawNode__Statusⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "rn" <>,
    exception_do (let: "rn" := (GoAlloc (go.PointerType RawNode) "rn") in
    let: "status" := (GoAlloc Status (GoZeroVal Status #())) in
    let: "$r0" := (let: "$a0" := (![go.PointerType raft] (StructFieldRef RawNode "raft"%go (![go.PointerType RawNode] "rn"))) in
    (FuncResolve getStatus [] #()) "$a0") in
    do:  ("status" <-[Status] "$r0");;;
    return: (![Status] "status")).

(* BasicStatus returns a BasicStatus. Notably this does not contain the
   Progress map; see WithProgress for an allocation-free way to inspect it.

   go: rawnode.go:505:20 *)
Definition RawNode__BasicStatusⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "rn" <>,
    exception_do (let: "rn" := (GoAlloc (go.PointerType RawNode) "rn") in
    return: (let: "$a0" := (![go.PointerType raft] (StructFieldRef RawNode "raft"%go (![go.PointerType RawNode] "rn"))) in
     (FuncResolve getBasicStatus [] #()) "$a0")).

(* WithProgress is a helper to introspect the Progress for this node and its
   peers.

   go: rawnode.go:521:20 *)
Definition RawNode__WithProgressⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "rn" "visitor",
    exception_do (let: "rn" := (GoAlloc (go.PointerType RawNode) "rn") in
    let: "visitor" := (GoAlloc (go.FunctionType (go.Signature [go.uint64; ProgressType; tracker.Progress] false [])) "visitor") in
    do:  (let: "$a0" := (λ: "id" "pr",
      exception_do (let: "pr" := (GoAlloc (go.PointerType tracker.Progress) "pr") in
      let: "id" := (GoAlloc go.uint64 "id") in
      let: "typ" := (GoAlloc ProgressType (GoZeroVal ProgressType #())) in
      let: "$r0" := ProgressTypePeer in
      do:  ("typ" <-[ProgressType] "$r0");;;
      (if: ![go.bool] (StructFieldRef tracker.Progress "IsLearner"%go (![go.PointerType tracker.Progress] "pr"))
      then
        let: "$r0" := ProgressTypeLearner in
        do:  ("typ" <-[ProgressType] "$r0")
      else do:  #());;;
      let: "p" := (GoAlloc tracker.Progress (GoZeroVal tracker.Progress #())) in
      let: "$r0" := (![tracker.Progress] (![go.PointerType tracker.Progress] "pr")) in
      do:  ("p" <-[tracker.Progress] "$r0");;;
      let: "$r0" := (Convert go.untyped_nil (go.PointerType tracker.Inflights) UntypedNil) in
      do:  ((StructFieldRef tracker.Progress "Inflights"%go "p") <-[go.PointerType tracker.Inflights] "$r0");;;
      do:  (let: "$a0" := (![go.uint64] "id") in
      let: "$a1" := (![ProgressType] "typ") in
      let: "$a2" := (![tracker.Progress] "p") in
      (![go.FunctionType (go.Signature [go.uint64; ProgressType; tracker.Progress] false [])] "visitor") "$a0" "$a1" "$a2");;;
      return: #())
      ) in
    (MethodResolve (go.PointerType tracker.ProgressTracker) "Visit"%go (StructFieldRef raft "trk"%go (![go.PointerType raft] (StructFieldRef RawNode "raft"%go (![go.PointerType RawNode] "rn"))))) "$a0");;;
    return: #()).

(* ReportUnreachable reports the given node is not reachable for the last send.

   go: rawnode.go:534:20 *)
Definition RawNode__ReportUnreachableⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "rn" "id",
    exception_do (let: "rn" := (GoAlloc (go.PointerType RawNode) "rn") in
    let: "id" := (GoAlloc go.uint64 "id") in
    let: "$r0" := (let: "$a0" := (CompositeLiteral raftpb.Message (LiteralValue [KeyedElement (Some (KeyField "Type"%go)) (ElementExpression raftpb.MessageType raftpb.MsgUnreachable); KeyedElement (Some (KeyField "From"%go)) (ElementExpression go.uint64 (![go.uint64] "id"))])) in
    (MethodResolve (go.PointerType raft) "Step"%go (![go.PointerType raft] (StructFieldRef RawNode "raft"%go (![go.PointerType RawNode] "rn")))) "$a0") in
    do:  "$r0";;;
    return: #()).

(* ReportSnapshot reports the status of the sent snapshot.

   go: rawnode.go:539:20 *)
Definition RawNode__ReportSnapshotⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "rn" "id" "status",
    exception_do (let: "rn" := (GoAlloc (go.PointerType RawNode) "rn") in
    let: "status" := (GoAlloc SnapshotStatus "status") in
    let: "id" := (GoAlloc go.uint64 "id") in
    let: "rej" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "$r0" := ((![SnapshotStatus] "status") =⟨go.int⟩ SnapshotFailure) in
    do:  ("rej" <-[go.bool] "$r0");;;
    let: "$r0" := (let: "$a0" := (CompositeLiteral raftpb.Message (LiteralValue [KeyedElement (Some (KeyField "Type"%go)) (ElementExpression raftpb.MessageType raftpb.MsgSnapStatus); KeyedElement (Some (KeyField "From"%go)) (ElementExpression go.uint64 (![go.uint64] "id")); KeyedElement (Some (KeyField "Reject"%go)) (ElementExpression go.bool (![go.bool] "rej"))])) in
    (MethodResolve (go.PointerType raft) "Step"%go (![go.PointerType raft] (StructFieldRef RawNode "raft"%go (![go.PointerType RawNode] "rn")))) "$a0") in
    do:  "$r0";;;
    return: #()).

(* TransferLeader tries to transfer leadership to the given transferee.

   go: rawnode.go:546:20 *)
Definition RawNode__TransferLeaderⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "rn" "transferee",
    exception_do (let: "rn" := (GoAlloc (go.PointerType RawNode) "rn") in
    let: "transferee" := (GoAlloc go.uint64 "transferee") in
    let: "$r0" := (let: "$a0" := (CompositeLiteral raftpb.Message (LiteralValue [KeyedElement (Some (KeyField "Type"%go)) (ElementExpression raftpb.MessageType raftpb.MsgTransferLeader); KeyedElement (Some (KeyField "From"%go)) (ElementExpression go.uint64 (![go.uint64] "transferee"))])) in
    (MethodResolve (go.PointerType raft) "Step"%go (![go.PointerType raft] (StructFieldRef RawNode "raft"%go (![go.PointerType RawNode] "rn")))) "$a0") in
    do:  "$r0";;;
    return: #()).

(* ForgetLeader forgets a follower's current leader, changing it to None.
   See (Node).ForgetLeader for details.

   go: rawnode.go:552:20 *)
Definition RawNode__ForgetLeaderⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "rn" <>,
    exception_do (let: "rn" := (GoAlloc (go.PointerType RawNode) "rn") in
    return: (let: "$a0" := (CompositeLiteral raftpb.Message (LiteralValue [KeyedElement (Some (KeyField "Type"%go)) (ElementExpression raftpb.MessageType raftpb.MsgForgetLeader)])) in
     (MethodResolve (go.PointerType raft) "Step"%go (![go.PointerType raft] (StructFieldRef RawNode "raft"%go (![go.PointerType RawNode] "rn")))) "$a0")).

(* ReadIndex requests a read state. The read state will be set in ready.
   Read State has a read index. Once the application advances further than the read
   index, any linearizable read requests issued before the read request can be
   processed safely. The read state will have the same rctx attached.

   go: rawnode.go:560:20 *)
Definition RawNode__ReadIndexⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "rn" "rctx",
    exception_do (let: "rn" := (GoAlloc (go.PointerType RawNode) "rn") in
    let: "rctx" := (GoAlloc (go.SliceType go.byte) "rctx") in
    let: "$r0" := (let: "$a0" := (CompositeLiteral raftpb.Message (LiteralValue [KeyedElement (Some (KeyField "Type"%go)) (ElementExpression raftpb.MessageType raftpb.MsgReadIndex); KeyedElement (Some (KeyField "Entries"%go)) (ElementExpression (go.SliceType raftpb.Entry) (CompositeLiteral (go.SliceType raftpb.Entry) (LiteralValue [KeyedElement None (ElementLiteralValue [KeyedElement (Some (KeyField "Data"%go)) (ElementExpression (go.SliceType go.byte) (![go.SliceType go.byte] "rctx"))])])))])) in
    (MethodResolve (go.PointerType raft) "Step"%go (![go.PointerType raft] (StructFieldRef RawNode "raft"%go (![go.PointerType RawNode] "rn")))) "$a0") in
    do:  "$r0";;;
    return: #()).

(* go: read_only.go:45:6 *)
Definition newReadOnlyⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "option",
    exception_do (let: "option" := (GoAlloc ReadOnlyOption "option") in
    return: (GoAlloc readOnly (CompositeLiteral readOnly (LiteralValue [KeyedElement (Some (KeyField "option"%go)) (ElementExpression ReadOnlyOption (![ReadOnlyOption] "option")); KeyedElement (Some (KeyField "pendingReadIndex"%go)) (ElementExpression (go.MapType go.string (go.PointerType readIndexStatus)) ((FuncResolve go.make1 [go.MapType go.string (go.PointerType readIndexStatus)] #()) #()))])))).

(* addRequest adds a read only request into readonly struct.
   `index` is the commit index of the raft state machine when it received
   the read only request.
   `m` is the original read only request message from the local or remote node.

   go: read_only.go:56:21 *)
Definition readOnly__addRequestⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "ro" "index" "m",
    exception_do (let: "ro" := (GoAlloc (go.PointerType readOnly) "ro") in
    let: "m" := (GoAlloc raftpb.Message "m") in
    let: "index" := (GoAlloc go.uint64 "index") in
    let: "s" := (GoAlloc go.string (GoZeroVal go.string #())) in
    let: "$r0" := (Convert (go.SliceType go.byte) go.string (![go.SliceType go.byte] (StructFieldRef raftpb.Entry "Data"%go (IndexRef (go.SliceType raftpb.Entry) (![go.SliceType raftpb.Entry] (StructFieldRef raftpb.Message "Entries"%go "m"), #(W64 0)))))) in
    do:  ("s" <-[go.string] "$r0");;;
    (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: ("$ret0", "$ret1") := (map.lookup2 go.string (go.PointerType readIndexStatus) (![go.MapType go.string (go.PointerType readIndexStatus)] (StructFieldRef readOnly "pendingReadIndex"%go (![go.PointerType readOnly] "ro"))) (![go.string] "s")) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  "$r0";;;
    do:  ("ok" <-[go.bool] "$r1");;;
    (if: ![go.bool] "ok"
    then return: (#())
    else do:  #()));;;
    let: "$r0" := (GoAlloc readIndexStatus (CompositeLiteral readIndexStatus (LiteralValue [KeyedElement (Some (KeyField "index"%go)) (ElementExpression go.uint64 (![go.uint64] "index")); KeyedElement (Some (KeyField "req"%go)) (ElementExpression raftpb.Message (![raftpb.Message] "m")); KeyedElement (Some (KeyField "acks"%go)) (ElementExpression (go.MapType go.uint64 go.bool) ((FuncResolve go.make1 [go.MapType go.uint64 go.bool] #()) #()))]))) in
    do:  (map.insert go.string (![go.MapType go.string (go.PointerType readIndexStatus)] (StructFieldRef readOnly "pendingReadIndex"%go (![go.PointerType readOnly] "ro"))) (![go.string] "s") "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType go.string] (StructFieldRef readOnly "readIndexQueue"%go (![go.PointerType readOnly] "ro"))) in
    let: "$a1" := ((let: "$sl0" := (![go.string] "s") in
    CompositeLiteral (go.SliceType go.string) (LiteralValue [KeyedElement None (ElementExpression go.string "$sl0")]))) in
    (FuncResolve go.append [go.SliceType go.string] #()) "$a0" "$a1") in
    do:  ((StructFieldRef readOnly "readIndexQueue"%go (![go.PointerType readOnly] "ro")) <-[go.SliceType go.string] "$r0");;;
    return: #()).

(* recvAck notifies the readonly struct that the raft state machine received
   an acknowledgment of the heartbeat that attached with the read only request
   context.

   go: read_only.go:68:21 *)
Definition readOnly__recvAckⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "ro" "id" "context",
    exception_do (let: "ro" := (GoAlloc (go.PointerType readOnly) "ro") in
    let: "context" := (GoAlloc (go.SliceType go.byte) "context") in
    let: "id" := (GoAlloc go.uint64 "id") in
    let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "rs" := (GoAlloc (go.PointerType readIndexStatus) (GoZeroVal (go.PointerType readIndexStatus) #())) in
    let: ("$ret0", "$ret1") := (map.lookup2 go.string (go.PointerType readIndexStatus) (![go.MapType go.string (go.PointerType readIndexStatus)] (StructFieldRef readOnly "pendingReadIndex"%go (![go.PointerType readOnly] "ro"))) (Convert (go.SliceType go.byte) go.string (![go.SliceType go.byte] "context"))) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("rs" <-[go.PointerType readIndexStatus] "$r0");;;
    do:  ("ok" <-[go.bool] "$r1");;;
    (if: (~ (![go.bool] "ok"))
    then return: (Convert go.untyped_nil (go.MapType go.uint64 go.bool) UntypedNil)
    else do:  #());;;
    let: "$r0" := #true in
    do:  (map.insert go.uint64 (![go.MapType go.uint64 go.bool] (StructFieldRef readIndexStatus "acks"%go (![go.PointerType readIndexStatus] "rs"))) (![go.uint64] "id") "$r0");;;
    return: (![go.MapType go.uint64 go.bool] (StructFieldRef readIndexStatus "acks"%go (![go.PointerType readIndexStatus] "rs")))).

(* advance advances the read only request queue kept by the readonly struct.
   It dequeues the requests until it finds the read only request that has
   the same context as the given `m`.

   go: read_only.go:81:21 *)
Definition readOnly__advanceⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "ro" "m",
    exception_do (let: "ro" := (GoAlloc (go.PointerType readOnly) "ro") in
    let: "m" := (GoAlloc raftpb.Message "m") in
    let: "found" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "i" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "ctx" := (GoAlloc go.string (GoZeroVal go.string #())) in
    let: "$r0" := (Convert (go.SliceType go.byte) go.string (![go.SliceType go.byte] (StructFieldRef raftpb.Message "Context"%go "m"))) in
    do:  ("ctx" <-[go.string] "$r0");;;
    let: "rss" := (GoAlloc (go.SliceType (go.PointerType readIndexStatus)) (GoZeroVal (go.SliceType (go.PointerType readIndexStatus)) #())) in
    let: "$range" := (![go.SliceType go.string] (StructFieldRef readOnly "readIndexQueue"%go (![go.PointerType readOnly] "ro"))) in
    (let: "okctx" := (GoAlloc go.string (GoZeroVal go.string #())) in
    slice.for_range go.string "$range" (λ: "$key" "$value",
      do:  ("okctx" <-[go.string] "$value");;;
      do:  "$key";;;
      do:  ("i" <-[go.int] ((![go.int] "i") +⟨go.int⟩ #(W64 1)));;;
      let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
      let: "rs" := (GoAlloc (go.PointerType readIndexStatus) (GoZeroVal (go.PointerType readIndexStatus) #())) in
      let: ("$ret0", "$ret1") := (map.lookup2 go.string (go.PointerType readIndexStatus) (![go.MapType go.string (go.PointerType readIndexStatus)] (StructFieldRef readOnly "pendingReadIndex"%go (![go.PointerType readOnly] "ro"))) (![go.string] "okctx")) in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("rs" <-[go.PointerType readIndexStatus] "$r0");;;
      do:  ("ok" <-[go.bool] "$r1");;;
      (if: (~ (![go.bool] "ok"))
      then
        do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"cannot find corresponding read state from pending map"%go) in
        (FuncResolve go.panic [] #()) "$a0")
      else do:  #());;;
      let: "$r0" := (let: "$a0" := (![go.SliceType (go.PointerType readIndexStatus)] "rss") in
      let: "$a1" := ((let: "$sl0" := (![go.PointerType readIndexStatus] "rs") in
      CompositeLiteral (go.SliceType (go.PointerType readIndexStatus)) (LiteralValue [KeyedElement None (ElementExpression (go.PointerType readIndexStatus) "$sl0")]))) in
      (FuncResolve go.append [go.SliceType (go.PointerType readIndexStatus)] #()) "$a0" "$a1") in
      do:  ("rss" <-[go.SliceType (go.PointerType readIndexStatus)] "$r0");;;
      (if: Convert go.untyped_bool go.bool ((![go.string] "okctx") =⟨go.string⟩ (![go.string] "ctx"))
      then
        let: "$r0" := #true in
        do:  ("found" <-[go.bool] "$r0");;;
        break: #()
      else do:  #())));;;
    (if: ![go.bool] "found"
    then
      let: "$r0" := (let: "$s" := (![go.SliceType go.string] (StructFieldRef readOnly "readIndexQueue"%go (![go.PointerType readOnly] "ro"))) in
      Slice (go.SliceType go.string) ("$s", ![go.int] "i", FuncResolve go.len [go.SliceType go.string] #() (![go.SliceType go.string] (StructFieldRef readOnly "readIndexQueue"%go (![go.PointerType readOnly] "ro"))))) in
      do:  ((StructFieldRef readOnly "readIndexQueue"%go (![go.PointerType readOnly] "ro")) <-[go.SliceType go.string] "$r0");;;
      let: "$range" := (![go.SliceType (go.PointerType readIndexStatus)] "rss") in
      (let: "rs" := (GoAlloc (go.PointerType readIndexStatus) (GoZeroVal (go.PointerType readIndexStatus) #())) in
      slice.for_range (go.PointerType readIndexStatus) "$range" (λ: "$key" "$value",
        do:  ("rs" <-[go.PointerType readIndexStatus] "$value");;;
        do:  "$key";;;
        do:  (let: "$a0" := (![go.MapType go.string (go.PointerType readIndexStatus)] (StructFieldRef readOnly "pendingReadIndex"%go (![go.PointerType readOnly] "ro"))) in
        let: "$a1" := (Convert (go.SliceType go.byte) go.string (![go.SliceType go.byte] (StructFieldRef raftpb.Entry "Data"%go (IndexRef (go.SliceType raftpb.Entry) (![go.SliceType raftpb.Entry] (StructFieldRef raftpb.Message "Entries"%go (StructFieldRef readIndexStatus "req"%go (![go.PointerType readIndexStatus] "rs"))), #(W64 0)))))) in
        (FuncResolve go.delete [go.MapType go.string (go.PointerType readIndexStatus)] #()) "$a0" "$a1")));;;
      return: (![go.SliceType (go.PointerType readIndexStatus)] "rss")
    else do:  #());;;
    return: (Convert go.untyped_nil (go.SliceType (go.PointerType readIndexStatus)) UntypedNil)).

(* lastPendingRequestCtx returns the context of the last pending read only
   request in readonly struct.

   go: read_only.go:116:21 *)
Definition readOnly__lastPendingRequestCtxⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "ro" <>,
    exception_do (let: "ro" := (GoAlloc (go.PointerType readOnly) "ro") in
    (if: Convert go.untyped_bool go.bool ((let: "$a0" := (![go.SliceType go.string] (StructFieldRef readOnly "readIndexQueue"%go (![go.PointerType readOnly] "ro"))) in
    (FuncResolve go.len [go.SliceType go.string] #()) "$a0") =⟨go.int⟩ #(W64 0))
    then return: (#""%go)
    else do:  #());;;
    return: (![go.string] (IndexRef (go.SliceType go.string) (![go.SliceType go.string] (StructFieldRef readOnly "readIndexQueue"%go (![go.PointerType readOnly] "ro")), (let: "$a0" := (![go.SliceType go.string] (StructFieldRef readOnly "readIndexQueue"%go (![go.PointerType readOnly] "ro"))) in
      (FuncResolve go.len [go.SliceType go.string] #()) "$a0") -⟨go.int⟩ #(W64 1))))).

(* go: state_trace_nop.go:30:6 *)
Definition traceInitStateⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (do:  #()).

(* go: state_trace_nop.go:32:6 *)
Definition traceReadyⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (do:  #()).

(* go: state_trace_nop.go:34:6 *)
Definition traceCommitⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (do:  #()).

(* go: state_trace_nop.go:36:6 *)
Definition traceReplicateⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <> <>,
    exception_do (do:  #()).

(* go: state_trace_nop.go:38:6 *)
Definition traceBecomeFollowerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (do:  #()).

(* go: state_trace_nop.go:40:6 *)
Definition traceBecomeCandidateⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (do:  #()).

(* go: state_trace_nop.go:42:6 *)
Definition traceBecomeLeaderⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (do:  #()).

(* go: state_trace_nop.go:44:6 *)
Definition traceChangeConfEventⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <> <>,
    exception_do (do:  #()).

(* go: state_trace_nop.go:46:6 *)
Definition traceConfChangeEventⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <> <>,
    exception_do (do:  #()).

(* go: state_trace_nop.go:48:6 *)
Definition traceSendMessageⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <> <>,
    exception_do (do:  #()).

(* go: state_trace_nop.go:50:6 *)
Definition traceReceiveMessageⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <> <>,
    exception_do (do:  #()).

(* go: status.go:44:6 *)
Definition getProgressCopyⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "r",
    exception_do (let: "r" := (GoAlloc (go.PointerType raft) "r") in
    let: "m" := (GoAlloc (go.MapType go.uint64 tracker.Progress) (GoZeroVal (go.MapType go.uint64 tracker.Progress) #())) in
    let: "$r0" := ((FuncResolve go.make1 [go.MapType go.uint64 tracker.Progress] #()) #()) in
    do:  ("m" <-[go.MapType go.uint64 tracker.Progress] "$r0");;;
    do:  (let: "$a0" := (λ: "id" "pr",
      exception_do (let: "pr" := (GoAlloc (go.PointerType tracker.Progress) "pr") in
      let: "id" := (GoAlloc go.uint64 "id") in
      let: "p" := (GoAlloc tracker.Progress (GoZeroVal tracker.Progress #())) in
      let: "$r0" := (![tracker.Progress] (![go.PointerType tracker.Progress] "pr")) in
      do:  ("p" <-[tracker.Progress] "$r0");;;
      let: "$r0" := ((MethodResolve (go.PointerType tracker.Inflights) "Clone"%go (![go.PointerType tracker.Inflights] (StructFieldRef tracker.Progress "Inflights"%go (![go.PointerType tracker.Progress] "pr")))) #()) in
      do:  ((StructFieldRef tracker.Progress "Inflights"%go "p") <-[go.PointerType tracker.Inflights] "$r0");;;
      let: "$r0" := (Convert go.untyped_nil (go.PointerType tracker.Progress) UntypedNil) in
      do:  ("pr" <-[go.PointerType tracker.Progress] "$r0");;;
      let: "$r0" := (![tracker.Progress] "p") in
      do:  (map.insert go.uint64 (![go.MapType go.uint64 tracker.Progress] "m") (![go.uint64] "id") "$r0");;;
      return: #())
      ) in
    (MethodResolve (go.PointerType tracker.ProgressTracker) "Visit"%go (StructFieldRef raft "trk"%go (![go.PointerType raft] "r"))) "$a0");;;
    return: (![go.MapType go.uint64 tracker.Progress] "m")).

(* go: status.go:56:6 *)
Definition getBasicStatusⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "r",
    exception_do (let: "r" := (GoAlloc (go.PointerType raft) "r") in
    let: "s" := (GoAlloc BasicStatus (GoZeroVal BasicStatus #())) in
    let: "$r0" := (CompositeLiteral BasicStatus (LiteralValue [KeyedElement (Some (KeyField "ID"%go)) (ElementExpression go.uint64 (![go.uint64] (StructFieldRef raft "id"%go (![go.PointerType raft] "r")))); KeyedElement (Some (KeyField "LeadTransferee"%go)) (ElementExpression go.uint64 (![go.uint64] (StructFieldRef raft "leadTransferee"%go (![go.PointerType raft] "r"))))])) in
    do:  ("s" <-[BasicStatus] "$r0");;;
    let: "$r0" := ((MethodResolve (go.PointerType raft) "hardState"%go (![go.PointerType raft] "r")) #()) in
    do:  ((StructFieldRef BasicStatus "HardState"%go "s") <-[raftpb.HardState] "$r0");;;
    let: "$r0" := ((MethodResolve (go.PointerType raft) "softState"%go (![go.PointerType raft] "r")) #()) in
    do:  ((StructFieldRef BasicStatus "SoftState"%go "s") <-[SoftState] "$r0");;;
    let: "$r0" := (![go.uint64] (StructFieldRef raftLog "applied"%go (![go.PointerType raftLog] (StructFieldRef raft "raftLog"%go (![go.PointerType raft] "r"))))) in
    do:  ((StructFieldRef BasicStatus "Applied"%go "s") <-[go.uint64] "$r0");;;
    return: (![BasicStatus] "s")).

(* getStatus gets a copy of the current raft status.

   go: status.go:68:6 *)
Definition getStatusⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "r",
    exception_do (let: "r" := (GoAlloc (go.PointerType raft) "r") in
    let: "s" := (GoAlloc Status (GoZeroVal Status #())) in
    let: "$r0" := (let: "$a0" := (![go.PointerType raft] "r") in
    (FuncResolve getBasicStatus [] #()) "$a0") in
    do:  ((StructFieldRef Status "BasicStatus"%go "s") <-[BasicStatus] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![StateType] (StructFieldRef SoftState "RaftState"%go (StructFieldRef BasicStatus "SoftState"%go (StructFieldRef Status "BasicStatus"%go "s")))) =⟨go.uint64⟩ StateLeader)
    then
      let: "$r0" := (let: "$a0" := (![go.PointerType raft] "r") in
      (FuncResolve getProgressCopy [] #()) "$a0") in
      do:  ((StructFieldRef Status "Progress"%go "s") <-[go.MapType go.uint64 tracker.Progress] "$r0")
    else do:  #());;;
    let: "$r0" := ((MethodResolve (go.PointerType tracker.Config) "Clone"%go (StructFieldRef tracker.ProgressTracker "Config"%go (StructFieldRef raft "trk"%go (![go.PointerType raft] "r")))) #()) in
    do:  ((StructFieldRef Status "Config"%go "s") <-[tracker.Config] "$r0");;;
    return: (![Status] "s")).

(* MarshalJSON translates the raft status into JSON.
   TODO: try to simplify this by introducing ID type into raft

   go: status.go:80:17 *)
Definition Status__MarshalJSONⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" <>,
    exception_do (let: "s" := (GoAlloc Status "s") in
    let: "j" := (GoAlloc go.string (GoZeroVal go.string #())) in
    let: "$r0" := (let: "$a0" := #"{""id"":""%x"",""term"":%d,""vote"":""%x"",""commit"":%d,""lead"":""%x"",""raftState"":%q,""applied"":%d,""progress"":{"%go in
    let: "$a1" := ((let: "$sl0" := (Convert go.uint64 go.any (![go.uint64] (StructFieldRef BasicStatus "ID"%go (StructFieldRef Status "BasicStatus"%go "s")))) in
    let: "$sl1" := (Convert go.uint64 go.any (![go.uint64] (StructFieldRef raftpb.HardState "Term"%go (StructFieldRef BasicStatus "HardState"%go (StructFieldRef Status "BasicStatus"%go "s"))))) in
    let: "$sl2" := (Convert go.uint64 go.any (![go.uint64] (StructFieldRef raftpb.HardState "Vote"%go (StructFieldRef BasicStatus "HardState"%go (StructFieldRef Status "BasicStatus"%go "s"))))) in
    let: "$sl3" := (Convert go.uint64 go.any (![go.uint64] (StructFieldRef raftpb.HardState "Commit"%go (StructFieldRef BasicStatus "HardState"%go (StructFieldRef Status "BasicStatus"%go "s"))))) in
    let: "$sl4" := (Convert go.uint64 go.any (![go.uint64] (StructFieldRef SoftState "Lead"%go (StructFieldRef BasicStatus "SoftState"%go (StructFieldRef Status "BasicStatus"%go "s"))))) in
    let: "$sl5" := (Convert StateType go.any (![StateType] (StructFieldRef SoftState "RaftState"%go (StructFieldRef BasicStatus "SoftState"%go (StructFieldRef Status "BasicStatus"%go "s"))))) in
    let: "$sl6" := (Convert go.uint64 go.any (![go.uint64] (StructFieldRef BasicStatus "Applied"%go (StructFieldRef Status "BasicStatus"%go "s")))) in
    CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0"); KeyedElement None (ElementExpression go.any "$sl1"); KeyedElement None (ElementExpression go.any "$sl2"); KeyedElement None (ElementExpression go.any "$sl3"); KeyedElement None (ElementExpression go.any "$sl4"); KeyedElement None (ElementExpression go.any "$sl5"); KeyedElement None (ElementExpression go.any "$sl6")]))) in
    (FuncResolve fmt.Sprintf [] #()) "$a0" "$a1") in
    do:  ("j" <-[go.string] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((let: "$a0" := (![go.MapType go.uint64 tracker.Progress] (StructFieldRef Status "Progress"%go "s")) in
    (FuncResolve go.len [go.MapType go.uint64 tracker.Progress] #()) "$a0") =⟨go.int⟩ #(W64 0))
    then do:  ("j" <-[go.string] ((![go.string] "j") +⟨go.string⟩ #"},"%go))
    else
      let: "$range" := (![go.MapType go.uint64 tracker.Progress] (StructFieldRef Status "Progress"%go "s")) in
      (let: "v" := (GoAlloc tracker.Progress (GoZeroVal tracker.Progress #())) in
      let: "k" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      map.for_range go.uint64 tracker.Progress "$range" (λ: "$key" "value",
        do:  ("v" <-[tracker.Progress] "$value");;;
        do:  ("k" <-[go.uint64] "$key");;;
        let: "subj" := (GoAlloc go.string (GoZeroVal go.string #())) in
        let: "$r0" := (let: "$a0" := #"""%x"":{""match"":%d,""next"":%d,""state"":%q},"%go in
        let: "$a1" := ((let: "$sl0" := (Convert go.uint64 go.any (![go.uint64] "k")) in
        let: "$sl1" := (Convert go.uint64 go.any (![go.uint64] (StructFieldRef tracker.Progress "Match"%go "v"))) in
        let: "$sl2" := (Convert go.uint64 go.any (![go.uint64] (StructFieldRef tracker.Progress "Next"%go "v"))) in
        let: "$sl3" := (Convert tracker.StateType go.any (![tracker.StateType] (StructFieldRef tracker.Progress "State"%go "v"))) in
        CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0"); KeyedElement None (ElementExpression go.any "$sl1"); KeyedElement None (ElementExpression go.any "$sl2"); KeyedElement None (ElementExpression go.any "$sl3")]))) in
        (FuncResolve fmt.Sprintf [] #()) "$a0" "$a1") in
        do:  ("subj" <-[go.string] "$r0");;;
        do:  ("j" <-[go.string] ((![go.string] "j") +⟨go.string⟩ (![go.string] "subj")))));;;
      let: "$r0" := ((Convert (go.SliceType go.byte) go.string (let: "$s" := (Convert go.string (go.SliceType go.byte) (![go.string] "j")) in
      Slice (go.SliceType go.byte) ("$s", #(W64 0), (let: "$a0" := (![go.string] "j") in
       (FuncResolve go.len [go.string] #()) "$a0") -⟨go.int⟩ #(W64 1)))) +⟨go.string⟩ #"},"%go) in
      do:  ("j" <-[go.string] "$r0"));;;
    do:  ("j" <-[go.string] ((![go.string] "j") +⟨go.string⟩ (let: "$a0" := #"""leadtransferee"":""%x""}"%go in
    let: "$a1" := ((let: "$sl0" := (Convert go.uint64 go.any (![go.uint64] (StructFieldRef BasicStatus "LeadTransferee"%go (StructFieldRef Status "BasicStatus"%go "s")))) in
    CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0")]))) in
    (FuncResolve fmt.Sprintf [] #()) "$a0" "$a1")));;;
    return: (Convert go.string (go.SliceType go.byte) (![go.string] "j"), Convert go.untyped_nil go.error UntypedNil)).

(* go: status.go:99:17 *)
Definition Status__Stringⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" <>,
    exception_do (let: "s" := (GoAlloc Status "s") in
    let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
    let: "b" := (GoAlloc (go.SliceType go.byte) (GoZeroVal (go.SliceType go.byte) #())) in
    let: ("$ret0", "$ret1") := ((MethodResolve Status "MarshalJSON"%go (![Status] "s")) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("b" <-[go.SliceType go.byte] "$r0");;;
    do:  ("err" <-[go.error] "$r1");;;
    (if: Convert go.untyped_bool go.bool ((![go.error] "err") ≠⟨go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]⟩ (Convert go.untyped_nil (go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]) UntypedNil))
    then
      do:  (let: "$a0" := #"unexpected error: %v"%go in
      let: "$a1" := ((let: "$sl0" := (Convert go.error (go.InterfaceType []) (![go.error] "err")) in
      CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0")]))) in
      (MethodResolve Logger "Panicf"%go ((FuncResolve getLogger [] #()) #())) "$a0" "$a1")
    else do:  #());;;
    return: (Convert (go.SliceType go.byte) go.string (![go.SliceType go.byte] "b"))).

(* NewMemoryStorage creates an empty MemoryStorage.

   go: storage.go:113:6 *)
Definition NewMemoryStorageⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    exception_do (return: (GoAlloc MemoryStorage (CompositeLiteral MemoryStorage (LiteralValue [KeyedElement (Some (KeyField "ents"%go)) (ElementExpression (go.SliceType raftpb.Entry) ((FuncResolve go.make2 [go.SliceType raftpb.Entry] #()) #(W64 1)))])))).

(* InitialState implements the Storage interface.

   go: storage.go:121:26 *)
Definition MemoryStorage__InitialStateⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "ms" <>,
    exception_do (let: "ms" := (GoAlloc (go.PointerType MemoryStorage) "ms") in
    do:  ((StructFieldRef inMemStorageCallStats "initialState"%go (StructFieldRef MemoryStorage "callStats"%go (![go.PointerType MemoryStorage] "ms"))) <-[go.int] ((![go.int] (StructFieldRef inMemStorageCallStats "initialState"%go (StructFieldRef MemoryStorage "callStats"%go (![go.PointerType MemoryStorage] "ms")))) +⟨go.int⟩ #(W64 1)));;;
    return: (![raftpb.HardState] (StructFieldRef MemoryStorage "hardState"%go (![go.PointerType MemoryStorage] "ms")), ![raftpb.ConfState] (StructFieldRef raftpb.SnapshotMetadata "ConfState"%go (StructFieldRef raftpb.Snapshot "Metadata"%go (StructFieldRef MemoryStorage "snapshot"%go (![go.PointerType MemoryStorage] "ms")))), Convert go.untyped_nil go.error UntypedNil)).

(* SetHardState saves the current HardState.

   go: storage.go:127:26 *)
Definition MemoryStorage__SetHardStateⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "ms" "st",
    with_defer: (let: "ms" := (GoAlloc (go.PointerType MemoryStorage) "ms") in
    let: "st" := (GoAlloc raftpb.HardState "st") in
    do:  ((MethodResolve (go.PointerType MemoryStorage) "Lock"%go (![go.PointerType MemoryStorage] "ms")) #());;;
    do:  (let: "$f" := (MethodResolve (go.PointerType MemoryStorage) "Unlock"%go (![go.PointerType MemoryStorage] "ms")) in
    "$defer" <-[deferType] (let: "$oldf" := (![deferType] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    let: "$r0" := (![raftpb.HardState] "st") in
    do:  ((StructFieldRef MemoryStorage "hardState"%go (![go.PointerType MemoryStorage] "ms")) <-[raftpb.HardState] "$r0");;;
    return: (Convert go.untyped_nil go.error UntypedNil)).

(* Entries implements the Storage interface.

   go: storage.go:135:26 *)
Definition MemoryStorage__Entriesⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "ms" "lo" "hi" "maxSize",
    with_defer: (let: "ms" := (GoAlloc (go.PointerType MemoryStorage) "ms") in
    let: "maxSize" := (GoAlloc go.uint64 "maxSize") in
    let: "hi" := (GoAlloc go.uint64 "hi") in
    let: "lo" := (GoAlloc go.uint64 "lo") in
    do:  ((MethodResolve (go.PointerType MemoryStorage) "Lock"%go (![go.PointerType MemoryStorage] "ms")) #());;;
    do:  (let: "$f" := (MethodResolve (go.PointerType MemoryStorage) "Unlock"%go (![go.PointerType MemoryStorage] "ms")) in
    "$defer" <-[deferType] (let: "$oldf" := (![deferType] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    do:  ((StructFieldRef inMemStorageCallStats "entries"%go (StructFieldRef MemoryStorage "callStats"%go (![go.PointerType MemoryStorage] "ms"))) <-[go.int] ((![go.int] (StructFieldRef inMemStorageCallStats "entries"%go (StructFieldRef MemoryStorage "callStats"%go (![go.PointerType MemoryStorage] "ms")))) +⟨go.int⟩ #(W64 1)));;;
    let: "offset" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (![go.uint64] (StructFieldRef raftpb.Entry "Index"%go (IndexRef (go.SliceType raftpb.Entry) (![go.SliceType raftpb.Entry] (StructFieldRef MemoryStorage "ents"%go (![go.PointerType MemoryStorage] "ms")), #(W64 0))))) in
    do:  ("offset" <-[go.uint64] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "lo") ≤⟨go.uint64⟩ (![go.uint64] "offset"))
    then return: (Convert go.untyped_nil (go.SliceType raftpb.Entry) UntypedNil, ![go.error] (GlobalVarAddr ErrCompacted #()))
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "hi") >⟨go.uint64⟩ (((MethodResolve (go.PointerType MemoryStorage) "lastIndex"%go (![go.PointerType MemoryStorage] "ms")) #()) +⟨go.uint64⟩ #(W64 1)))
    then
      do:  (let: "$a0" := #"entries' hi(%d) is out of bound lastindex(%d)"%go in
      let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] "hi")) in
      let: "$sl1" := (Convert go.uint64 (go.InterfaceType []) ((MethodResolve (go.PointerType MemoryStorage) "lastIndex"%go (![go.PointerType MemoryStorage] "ms")) #())) in
      CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1")]))) in
      (MethodResolve Logger "Panicf"%go ((FuncResolve getLogger [] #()) #())) "$a0" "$a1")
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool ((let: "$a0" := (![go.SliceType raftpb.Entry] (StructFieldRef MemoryStorage "ents"%go (![go.PointerType MemoryStorage] "ms"))) in
    (FuncResolve go.len [go.SliceType raftpb.Entry] #()) "$a0") =⟨go.int⟩ #(W64 1))
    then return: (Convert go.untyped_nil (go.SliceType raftpb.Entry) UntypedNil, ![go.error] (GlobalVarAddr ErrUnavailable #()))
    else do:  #());;;
    let: "ents" := (GoAlloc (go.SliceType raftpb.Entry) (GoZeroVal (go.SliceType raftpb.Entry) #())) in
    let: "$r0" := (let: "$a0" := (let: "$s" := (![go.SliceType raftpb.Entry] (StructFieldRef MemoryStorage "ents"%go (![go.PointerType MemoryStorage] "ms"))) in
    Slice (go.SliceType raftpb.Entry) ("$s", (![go.uint64] "lo") -⟨go.uint64⟩ (![go.uint64] "offset"), (![go.uint64] "hi") -⟨go.uint64⟩ (![go.uint64] "offset"))) in
    let: "$a1" := (![go.uint64] "maxSize") in
    (FuncResolve limitSize [] #()) "$a0" "$a1") in
    do:  ("ents" <-[go.SliceType raftpb.Entry] "$r0");;;
    return: (let: "$s" := (![go.SliceType raftpb.Entry] "ents") in
     FullSlice (go.SliceType raftpb.Entry) ("$s", #(W64 0), let: "$a0" := (![go.SliceType raftpb.Entry] "ents") in
      (FuncResolve go.len [go.SliceType raftpb.Entry] #()) "$a0", let: "$a0" := (![go.SliceType raftpb.Entry] "ents") in
      (FuncResolve go.len [go.SliceType raftpb.Entry] #()) "$a0"), Convert go.untyped_nil go.error UntypedNil)).

(* Term implements the Storage interface.

   go: storage.go:159:26 *)
Definition MemoryStorage__Termⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "ms" "i",
    with_defer: (let: "ms" := (GoAlloc (go.PointerType MemoryStorage) "ms") in
    let: "i" := (GoAlloc go.uint64 "i") in
    do:  ((MethodResolve (go.PointerType MemoryStorage) "Lock"%go (![go.PointerType MemoryStorage] "ms")) #());;;
    do:  (let: "$f" := (MethodResolve (go.PointerType MemoryStorage) "Unlock"%go (![go.PointerType MemoryStorage] "ms")) in
    "$defer" <-[deferType] (let: "$oldf" := (![deferType] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    do:  ((StructFieldRef inMemStorageCallStats "term"%go (StructFieldRef MemoryStorage "callStats"%go (![go.PointerType MemoryStorage] "ms"))) <-[go.int] ((![go.int] (StructFieldRef inMemStorageCallStats "term"%go (StructFieldRef MemoryStorage "callStats"%go (![go.PointerType MemoryStorage] "ms")))) +⟨go.int⟩ #(W64 1)));;;
    let: "offset" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (![go.uint64] (StructFieldRef raftpb.Entry "Index"%go (IndexRef (go.SliceType raftpb.Entry) (![go.SliceType raftpb.Entry] (StructFieldRef MemoryStorage "ents"%go (![go.PointerType MemoryStorage] "ms")), #(W64 0))))) in
    do:  ("offset" <-[go.uint64] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "i") <⟨go.uint64⟩ (![go.uint64] "offset"))
    then return: (#(W64 0), ![go.error] (GlobalVarAddr ErrCompacted #()))
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool ((Convert go.uint64 go.int ((![go.uint64] "i") -⟨go.uint64⟩ (![go.uint64] "offset"))) ≥⟨go.int⟩ (let: "$a0" := (![go.SliceType raftpb.Entry] (StructFieldRef MemoryStorage "ents"%go (![go.PointerType MemoryStorage] "ms"))) in
    (FuncResolve go.len [go.SliceType raftpb.Entry] #()) "$a0"))
    then return: (#(W64 0), ![go.error] (GlobalVarAddr ErrUnavailable #()))
    else do:  #());;;
    return: (![go.uint64] (StructFieldRef raftpb.Entry "Term"%go (IndexRef (go.SliceType raftpb.Entry) (![go.SliceType raftpb.Entry] (StructFieldRef MemoryStorage "ents"%go (![go.PointerType MemoryStorage] "ms")), Convert go.uint64 go.int ((![go.uint64] "i") -⟨go.uint64⟩ (![go.uint64] "offset"))))), Convert go.untyped_nil go.error UntypedNil)).

(* LastIndex implements the Storage interface.

   go: storage.go:174:26 *)
Definition MemoryStorage__LastIndexⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "ms" <>,
    with_defer: (let: "ms" := (GoAlloc (go.PointerType MemoryStorage) "ms") in
    do:  ((MethodResolve (go.PointerType MemoryStorage) "Lock"%go (![go.PointerType MemoryStorage] "ms")) #());;;
    do:  (let: "$f" := (MethodResolve (go.PointerType MemoryStorage) "Unlock"%go (![go.PointerType MemoryStorage] "ms")) in
    "$defer" <-[deferType] (let: "$oldf" := (![deferType] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    do:  ((StructFieldRef inMemStorageCallStats "lastIndex"%go (StructFieldRef MemoryStorage "callStats"%go (![go.PointerType MemoryStorage] "ms"))) <-[go.int] ((![go.int] (StructFieldRef inMemStorageCallStats "lastIndex"%go (StructFieldRef MemoryStorage "callStats"%go (![go.PointerType MemoryStorage] "ms")))) +⟨go.int⟩ #(W64 1)));;;
    return: ((MethodResolve (go.PointerType MemoryStorage) "lastIndex"%go (![go.PointerType MemoryStorage] "ms")) #(), Convert go.untyped_nil go.error UntypedNil)).

(* go: storage.go:181:26 *)
Definition MemoryStorage__lastIndexⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "ms" <>,
    exception_do (let: "ms" := (GoAlloc (go.PointerType MemoryStorage) "ms") in
    return: (((![go.uint64] (StructFieldRef raftpb.Entry "Index"%go (IndexRef (go.SliceType raftpb.Entry) (![go.SliceType raftpb.Entry] (StructFieldRef MemoryStorage "ents"%go (![go.PointerType MemoryStorage] "ms")), #(W64 0))))) +⟨go.uint64⟩ (Convert go.int go.uint64 (let: "$a0" := (![go.SliceType raftpb.Entry] (StructFieldRef MemoryStorage "ents"%go (![go.PointerType MemoryStorage] "ms"))) in
     (FuncResolve go.len [go.SliceType raftpb.Entry] #()) "$a0"))) -⟨go.uint64⟩ #(W64 1))).

(* FirstIndex implements the Storage interface.

   go: storage.go:186:26 *)
Definition MemoryStorage__FirstIndexⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "ms" <>,
    with_defer: (let: "ms" := (GoAlloc (go.PointerType MemoryStorage) "ms") in
    do:  ((MethodResolve (go.PointerType MemoryStorage) "Lock"%go (![go.PointerType MemoryStorage] "ms")) #());;;
    do:  (let: "$f" := (MethodResolve (go.PointerType MemoryStorage) "Unlock"%go (![go.PointerType MemoryStorage] "ms")) in
    "$defer" <-[deferType] (let: "$oldf" := (![deferType] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    do:  ((StructFieldRef inMemStorageCallStats "firstIndex"%go (StructFieldRef MemoryStorage "callStats"%go (![go.PointerType MemoryStorage] "ms"))) <-[go.int] ((![go.int] (StructFieldRef inMemStorageCallStats "firstIndex"%go (StructFieldRef MemoryStorage "callStats"%go (![go.PointerType MemoryStorage] "ms")))) +⟨go.int⟩ #(W64 1)));;;
    return: ((MethodResolve (go.PointerType MemoryStorage) "firstIndex"%go (![go.PointerType MemoryStorage] "ms")) #(), Convert go.untyped_nil go.error UntypedNil)).

(* go: storage.go:193:26 *)
Definition MemoryStorage__firstIndexⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "ms" <>,
    exception_do (let: "ms" := (GoAlloc (go.PointerType MemoryStorage) "ms") in
    return: ((![go.uint64] (StructFieldRef raftpb.Entry "Index"%go (IndexRef (go.SliceType raftpb.Entry) (![go.SliceType raftpb.Entry] (StructFieldRef MemoryStorage "ents"%go (![go.PointerType MemoryStorage] "ms")), #(W64 0))))) +⟨go.uint64⟩ #(W64 1))).

(* Snapshot implements the Storage interface.

   go: storage.go:198:26 *)
Definition MemoryStorage__Snapshotⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "ms" <>,
    with_defer: (let: "ms" := (GoAlloc (go.PointerType MemoryStorage) "ms") in
    do:  ((MethodResolve (go.PointerType MemoryStorage) "Lock"%go (![go.PointerType MemoryStorage] "ms")) #());;;
    do:  (let: "$f" := (MethodResolve (go.PointerType MemoryStorage) "Unlock"%go (![go.PointerType MemoryStorage] "ms")) in
    "$defer" <-[deferType] (let: "$oldf" := (![deferType] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    do:  ((StructFieldRef inMemStorageCallStats "snapshot"%go (StructFieldRef MemoryStorage "callStats"%go (![go.PointerType MemoryStorage] "ms"))) <-[go.int] ((![go.int] (StructFieldRef inMemStorageCallStats "snapshot"%go (StructFieldRef MemoryStorage "callStats"%go (![go.PointerType MemoryStorage] "ms")))) +⟨go.int⟩ #(W64 1)));;;
    return: (![raftpb.Snapshot] (StructFieldRef MemoryStorage "snapshot"%go (![go.PointerType MemoryStorage] "ms")), Convert go.untyped_nil go.error UntypedNil)).

(* ApplySnapshot overwrites the contents of this Storage object with
   those of the given snapshot.

   go: storage.go:207:26 *)
Definition MemoryStorage__ApplySnapshotⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "ms" "snap",
    with_defer: (let: "ms" := (GoAlloc (go.PointerType MemoryStorage) "ms") in
    let: "snap" := (GoAlloc raftpb.Snapshot "snap") in
    do:  ((MethodResolve (go.PointerType MemoryStorage) "Lock"%go (![go.PointerType MemoryStorage] "ms")) #());;;
    do:  (let: "$f" := (MethodResolve (go.PointerType MemoryStorage) "Unlock"%go (![go.PointerType MemoryStorage] "ms")) in
    "$defer" <-[deferType] (let: "$oldf" := (![deferType] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    let: "msIndex" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (![go.uint64] (StructFieldRef raftpb.SnapshotMetadata "Index"%go (StructFieldRef raftpb.Snapshot "Metadata"%go (StructFieldRef MemoryStorage "snapshot"%go (![go.PointerType MemoryStorage] "ms"))))) in
    do:  ("msIndex" <-[go.uint64] "$r0");;;
    let: "snapIndex" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (![go.uint64] (StructFieldRef raftpb.SnapshotMetadata "Index"%go (StructFieldRef raftpb.Snapshot "Metadata"%go "snap"))) in
    do:  ("snapIndex" <-[go.uint64] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "msIndex") ≥⟨go.uint64⟩ (![go.uint64] "snapIndex"))
    then return: (![go.error] (GlobalVarAddr ErrSnapOutOfDate #()))
    else do:  #());;;
    let: "$r0" := (![raftpb.Snapshot] "snap") in
    do:  ((StructFieldRef MemoryStorage "snapshot"%go (![go.PointerType MemoryStorage] "ms")) <-[raftpb.Snapshot] "$r0");;;
    let: "$r0" := (CompositeLiteral (go.SliceType raftpb.Entry) (LiteralValue [KeyedElement None (ElementLiteralValue [KeyedElement (Some (KeyField "Term"%go)) (ElementExpression go.uint64 (![go.uint64] (StructFieldRef raftpb.SnapshotMetadata "Term"%go (StructFieldRef raftpb.Snapshot "Metadata"%go "snap")))); KeyedElement (Some (KeyField "Index"%go)) (ElementExpression go.uint64 (![go.uint64] (StructFieldRef raftpb.SnapshotMetadata "Index"%go (StructFieldRef raftpb.Snapshot "Metadata"%go "snap"))))])])) in
    do:  ((StructFieldRef MemoryStorage "ents"%go (![go.PointerType MemoryStorage] "ms")) <-[go.SliceType raftpb.Entry] "$r0");;;
    return: (Convert go.untyped_nil go.error UntypedNil)).

(* CreateSnapshot makes a snapshot which can be retrieved with Snapshot() and
   can be used to reconstruct the state at that point.
   If any configuration changes have been made since the last compaction,
   the result of the last ApplyConfChange must be passed in.

   go: storage.go:227:26 *)
Definition MemoryStorage__CreateSnapshotⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "ms" "i" "cs" "data",
    with_defer: (let: "ms" := (GoAlloc (go.PointerType MemoryStorage) "ms") in
    let: "data" := (GoAlloc (go.SliceType go.byte) "data") in
    let: "cs" := (GoAlloc (go.PointerType raftpb.ConfState) "cs") in
    let: "i" := (GoAlloc go.uint64 "i") in
    do:  ((MethodResolve (go.PointerType MemoryStorage) "Lock"%go (![go.PointerType MemoryStorage] "ms")) #());;;
    do:  (let: "$f" := (MethodResolve (go.PointerType MemoryStorage) "Unlock"%go (![go.PointerType MemoryStorage] "ms")) in
    "$defer" <-[deferType] (let: "$oldf" := (![deferType] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "i") ≤⟨go.uint64⟩ (![go.uint64] (StructFieldRef raftpb.SnapshotMetadata "Index"%go (StructFieldRef raftpb.Snapshot "Metadata"%go (StructFieldRef MemoryStorage "snapshot"%go (![go.PointerType MemoryStorage] "ms"))))))
    then return: (CompositeLiteral raftpb.Snapshot (LiteralValue []), ![go.error] (GlobalVarAddr ErrSnapOutOfDate #()))
    else do:  #());;;
    let: "offset" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (![go.uint64] (StructFieldRef raftpb.Entry "Index"%go (IndexRef (go.SliceType raftpb.Entry) (![go.SliceType raftpb.Entry] (StructFieldRef MemoryStorage "ents"%go (![go.PointerType MemoryStorage] "ms")), #(W64 0))))) in
    do:  ("offset" <-[go.uint64] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "i") >⟨go.uint64⟩ ((MethodResolve (go.PointerType MemoryStorage) "lastIndex"%go (![go.PointerType MemoryStorage] "ms")) #()))
    then
      do:  (let: "$a0" := #"snapshot %d is out of bound lastindex(%d)"%go in
      let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] "i")) in
      let: "$sl1" := (Convert go.uint64 (go.InterfaceType []) ((MethodResolve (go.PointerType MemoryStorage) "lastIndex"%go (![go.PointerType MemoryStorage] "ms")) #())) in
      CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1")]))) in
      (MethodResolve Logger "Panicf"%go ((FuncResolve getLogger [] #()) #())) "$a0" "$a1")
    else do:  #());;;
    let: "$r0" := (![go.uint64] "i") in
    do:  ((StructFieldRef raftpb.SnapshotMetadata "Index"%go (StructFieldRef raftpb.Snapshot "Metadata"%go (StructFieldRef MemoryStorage "snapshot"%go (![go.PointerType MemoryStorage] "ms")))) <-[go.uint64] "$r0");;;
    let: "$r0" := (![go.uint64] (StructFieldRef raftpb.Entry "Term"%go (IndexRef (go.SliceType raftpb.Entry) (![go.SliceType raftpb.Entry] (StructFieldRef MemoryStorage "ents"%go (![go.PointerType MemoryStorage] "ms")), Convert go.uint64 go.int ((![go.uint64] "i") -⟨go.uint64⟩ (![go.uint64] "offset")))))) in
    do:  ((StructFieldRef raftpb.SnapshotMetadata "Term"%go (StructFieldRef raftpb.Snapshot "Metadata"%go (StructFieldRef MemoryStorage "snapshot"%go (![go.PointerType MemoryStorage] "ms")))) <-[go.uint64] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.PointerType raftpb.ConfState] "cs") ≠⟨go.PointerType raftpb.ConfState⟩ (Convert go.untyped_nil (go.PointerType raftpb.ConfState) UntypedNil))
    then
      let: "$r0" := (![raftpb.ConfState] (![go.PointerType raftpb.ConfState] "cs")) in
      do:  ((StructFieldRef raftpb.SnapshotMetadata "ConfState"%go (StructFieldRef raftpb.Snapshot "Metadata"%go (StructFieldRef MemoryStorage "snapshot"%go (![go.PointerType MemoryStorage] "ms")))) <-[raftpb.ConfState] "$r0")
    else do:  #());;;
    let: "$r0" := (![go.SliceType go.byte] "data") in
    do:  ((StructFieldRef raftpb.Snapshot "Data"%go (StructFieldRef MemoryStorage "snapshot"%go (![go.PointerType MemoryStorage] "ms"))) <-[go.SliceType go.byte] "$r0");;;
    return: (![raftpb.Snapshot] (StructFieldRef MemoryStorage "snapshot"%go (![go.PointerType MemoryStorage] "ms")), Convert go.untyped_nil go.error UntypedNil)).

(* Compact discards all log entries prior to compactIndex.
   It is the application's responsibility to not attempt to compact an index
   greater than raftLog.applied.

   go: storage.go:251:26 *)
Definition MemoryStorage__Compactⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "ms" "compactIndex",
    with_defer: (let: "ms" := (GoAlloc (go.PointerType MemoryStorage) "ms") in
    let: "compactIndex" := (GoAlloc go.uint64 "compactIndex") in
    do:  ((MethodResolve (go.PointerType MemoryStorage) "Lock"%go (![go.PointerType MemoryStorage] "ms")) #());;;
    do:  (let: "$f" := (MethodResolve (go.PointerType MemoryStorage) "Unlock"%go (![go.PointerType MemoryStorage] "ms")) in
    "$defer" <-[deferType] (let: "$oldf" := (![deferType] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    let: "offset" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (![go.uint64] (StructFieldRef raftpb.Entry "Index"%go (IndexRef (go.SliceType raftpb.Entry) (![go.SliceType raftpb.Entry] (StructFieldRef MemoryStorage "ents"%go (![go.PointerType MemoryStorage] "ms")), #(W64 0))))) in
    do:  ("offset" <-[go.uint64] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "compactIndex") ≤⟨go.uint64⟩ (![go.uint64] "offset"))
    then return: (![go.error] (GlobalVarAddr ErrCompacted #()))
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "compactIndex") >⟨go.uint64⟩ ((MethodResolve (go.PointerType MemoryStorage) "lastIndex"%go (![go.PointerType MemoryStorage] "ms")) #()))
    then
      do:  (let: "$a0" := #"compact %d is out of bound lastindex(%d)"%go in
      let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] "compactIndex")) in
      let: "$sl1" := (Convert go.uint64 (go.InterfaceType []) ((MethodResolve (go.PointerType MemoryStorage) "lastIndex"%go (![go.PointerType MemoryStorage] "ms")) #())) in
      CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1")]))) in
      (MethodResolve Logger "Panicf"%go ((FuncResolve getLogger [] #()) #())) "$a0" "$a1")
    else do:  #());;;
    let: "i" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := ((![go.uint64] "compactIndex") -⟨go.uint64⟩ (![go.uint64] "offset")) in
    do:  ("i" <-[go.uint64] "$r0");;;
    let: "ents" := (GoAlloc (go.SliceType raftpb.Entry) (GoZeroVal (go.SliceType raftpb.Entry) #())) in
    let: "$r0" := ((FuncResolve go.make3 [go.SliceType raftpb.Entry] #()) #(W64 1) ((Convert go.int go.uint64 (let: "$a0" := (![go.SliceType raftpb.Entry] (StructFieldRef MemoryStorage "ents"%go (![go.PointerType MemoryStorage] "ms"))) in
    (FuncResolve go.len [go.SliceType raftpb.Entry] #()) "$a0")) -⟨go.uint64⟩ (![go.uint64] "i"))) in
    do:  ("ents" <-[go.SliceType raftpb.Entry] "$r0");;;
    let: "$r0" := (![go.uint64] (StructFieldRef raftpb.Entry "Index"%go (IndexRef (go.SliceType raftpb.Entry) (![go.SliceType raftpb.Entry] (StructFieldRef MemoryStorage "ents"%go (![go.PointerType MemoryStorage] "ms")), Convert go.uint64 go.int (![go.uint64] "i"))))) in
    do:  ((StructFieldRef raftpb.Entry "Index"%go (IndexRef (go.SliceType raftpb.Entry) (![go.SliceType raftpb.Entry] "ents", #(W64 0)))) <-[go.uint64] "$r0");;;
    let: "$r0" := (![go.uint64] (StructFieldRef raftpb.Entry "Term"%go (IndexRef (go.SliceType raftpb.Entry) (![go.SliceType raftpb.Entry] (StructFieldRef MemoryStorage "ents"%go (![go.PointerType MemoryStorage] "ms")), Convert go.uint64 go.int (![go.uint64] "i"))))) in
    do:  ((StructFieldRef raftpb.Entry "Term"%go (IndexRef (go.SliceType raftpb.Entry) (![go.SliceType raftpb.Entry] "ents", #(W64 0)))) <-[go.uint64] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.SliceType raftpb.Entry] "ents") in
    let: "$a1" := (let: "$s" := (![go.SliceType raftpb.Entry] (StructFieldRef MemoryStorage "ents"%go (![go.PointerType MemoryStorage] "ms"))) in
    Slice (go.SliceType raftpb.Entry) ("$s", (![go.uint64] "i") +⟨go.uint64⟩ #(W64 1), FuncResolve go.len [go.SliceType raftpb.Entry] #() (![go.SliceType raftpb.Entry] (StructFieldRef MemoryStorage "ents"%go (![go.PointerType MemoryStorage] "ms"))))) in
    (FuncResolve go.append [go.SliceType raftpb.Entry] #()) "$a0" "$a1") in
    do:  ("ents" <-[go.SliceType raftpb.Entry] "$r0");;;
    let: "$r0" := (![go.SliceType raftpb.Entry] "ents") in
    do:  ((StructFieldRef MemoryStorage "ents"%go (![go.PointerType MemoryStorage] "ms")) <-[go.SliceType raftpb.Entry] "$r0");;;
    return: (Convert go.untyped_nil go.error UntypedNil)).

(* Append the new entries to storage.
   TODO (xiangli): ensure the entries are continuous and
   entries[0].Index > ms.entries[0].Index

   go: storage.go:277:26 *)
Definition MemoryStorage__Appendⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "ms" "entries",
    with_defer: (let: "ms" := (GoAlloc (go.PointerType MemoryStorage) "ms") in
    let: "entries" := (GoAlloc (go.SliceType raftpb.Entry) "entries") in
    (if: Convert go.untyped_bool go.bool ((let: "$a0" := (![go.SliceType raftpb.Entry] "entries") in
    (FuncResolve go.len [go.SliceType raftpb.Entry] #()) "$a0") =⟨go.int⟩ #(W64 0))
    then return: (Convert go.untyped_nil go.error UntypedNil)
    else do:  #());;;
    do:  ((MethodResolve (go.PointerType MemoryStorage) "Lock"%go (![go.PointerType MemoryStorage] "ms")) #());;;
    do:  (let: "$f" := (MethodResolve (go.PointerType MemoryStorage) "Unlock"%go (![go.PointerType MemoryStorage] "ms")) in
    "$defer" <-[deferType] (let: "$oldf" := (![deferType] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    let: "first" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := ((MethodResolve (go.PointerType MemoryStorage) "firstIndex"%go (![go.PointerType MemoryStorage] "ms")) #()) in
    do:  ("first" <-[go.uint64] "$r0");;;
    let: "last" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := (((![go.uint64] (StructFieldRef raftpb.Entry "Index"%go (IndexRef (go.SliceType raftpb.Entry) (![go.SliceType raftpb.Entry] "entries", #(W64 0))))) +⟨go.uint64⟩ (Convert go.int go.uint64 (let: "$a0" := (![go.SliceType raftpb.Entry] "entries") in
    (FuncResolve go.len [go.SliceType raftpb.Entry] #()) "$a0"))) -⟨go.uint64⟩ #(W64 1)) in
    do:  ("last" <-[go.uint64] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "last") <⟨go.uint64⟩ (![go.uint64] "first"))
    then return: (Convert go.untyped_nil go.error UntypedNil)
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "first") >⟨go.uint64⟩ (![go.uint64] (StructFieldRef raftpb.Entry "Index"%go (IndexRef (go.SliceType raftpb.Entry) (![go.SliceType raftpb.Entry] "entries", #(W64 0))))))
    then
      let: "$r0" := (let: "$s" := (![go.SliceType raftpb.Entry] "entries") in
      Slice (go.SliceType raftpb.Entry) ("$s", (![go.uint64] "first") -⟨go.uint64⟩ (![go.uint64] (StructFieldRef raftpb.Entry "Index"%go (IndexRef (go.SliceType raftpb.Entry) (![go.SliceType raftpb.Entry] "entries", #(W64 0))))), FuncResolve go.len [go.SliceType raftpb.Entry] #() (![go.SliceType raftpb.Entry] "entries"))) in
      do:  ("entries" <-[go.SliceType raftpb.Entry] "$r0")
    else do:  #());;;
    let: "offset" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    let: "$r0" := ((![go.uint64] (StructFieldRef raftpb.Entry "Index"%go (IndexRef (go.SliceType raftpb.Entry) (![go.SliceType raftpb.Entry] "entries", #(W64 0))))) -⟨go.uint64⟩ (![go.uint64] (StructFieldRef raftpb.Entry "Index"%go (IndexRef (go.SliceType raftpb.Entry) (![go.SliceType raftpb.Entry] (StructFieldRef MemoryStorage "ents"%go (![go.PointerType MemoryStorage] "ms")), #(W64 0)))))) in
    do:  ("offset" <-[go.uint64] "$r0");;;
    let: "$sw" := #true in
    (if: "$sw" =⟨go.bool⟩ ((Convert go.int go.uint64 (let: "$a0" := (![go.SliceType raftpb.Entry] (StructFieldRef MemoryStorage "ents"%go (![go.PointerType MemoryStorage] "ms"))) in
    (FuncResolve go.len [go.SliceType raftpb.Entry] #()) "$a0")) >⟨go.uint64⟩ (![go.uint64] "offset"))
    then
      let: "$r0" := (let: "$a0" := (let: "$s" := (![go.SliceType raftpb.Entry] (StructFieldRef MemoryStorage "ents"%go (![go.PointerType MemoryStorage] "ms"))) in
      FullSlice (go.SliceType raftpb.Entry) ("$s", #(W64 0), ![go.uint64] "offset", ![go.uint64] "offset")) in
      let: "$a1" := (![go.SliceType raftpb.Entry] "entries") in
      (FuncResolve go.append [go.SliceType raftpb.Entry] #()) "$a0" "$a1") in
      do:  ((StructFieldRef MemoryStorage "ents"%go (![go.PointerType MemoryStorage] "ms")) <-[go.SliceType raftpb.Entry] "$r0")
    else
      (if: "$sw" =⟨go.bool⟩ ((Convert go.int go.uint64 (let: "$a0" := (![go.SliceType raftpb.Entry] (StructFieldRef MemoryStorage "ents"%go (![go.PointerType MemoryStorage] "ms"))) in
      (FuncResolve go.len [go.SliceType raftpb.Entry] #()) "$a0")) =⟨go.uint64⟩ (![go.uint64] "offset"))
      then
        let: "$r0" := (let: "$a0" := (![go.SliceType raftpb.Entry] (StructFieldRef MemoryStorage "ents"%go (![go.PointerType MemoryStorage] "ms"))) in
        let: "$a1" := (![go.SliceType raftpb.Entry] "entries") in
        (FuncResolve go.append [go.SliceType raftpb.Entry] #()) "$a0" "$a1") in
        do:  ((StructFieldRef MemoryStorage "ents"%go (![go.PointerType MemoryStorage] "ms")) <-[go.SliceType raftpb.Entry] "$r0")
      else
        do:  (let: "$a0" := #"missing log entry [last: %d, append at: %d]"%go in
        let: "$a1" := ((let: "$sl0" := (Convert go.uint64 (go.InterfaceType []) ((MethodResolve (go.PointerType MemoryStorage) "lastIndex"%go (![go.PointerType MemoryStorage] "ms")) #())) in
        let: "$sl1" := (Convert go.uint64 (go.InterfaceType []) (![go.uint64] (StructFieldRef raftpb.Entry "Index"%go (IndexRef (go.SliceType raftpb.Entry) (![go.SliceType raftpb.Entry] "entries", #(W64 0)))))) in
        CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0"); KeyedElement None (ElementExpression (go.InterfaceType []) "$sl1")]))) in
        (MethodResolve Logger "Panicf"%go ((FuncResolve getLogger [] #()) #())) "$a0" "$a1")));;;
    return: (Convert go.untyped_nil go.error UntypedNil)).

(* pbEntryID returns the ID of the given pb.Entry.

   go: types.go:34:6 *)
Definition pbEntryIDⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "entry",
    exception_do (let: "entry" := (GoAlloc (go.PointerType raftpb.Entry) "entry") in
    return: (CompositeLiteral entryID (LiteralValue [KeyedElement (Some (KeyField "term"%go)) (ElementExpression go.uint64 (![go.uint64] (StructFieldRef raftpb.Entry "Term"%go (![go.PointerType raftpb.Entry] "entry")))); KeyedElement (Some (KeyField "index"%go)) (ElementExpression go.uint64 (![go.uint64] (StructFieldRef raftpb.Entry "Index"%go (![go.PointerType raftpb.Entry] "entry"))))]))).

(* lastIndex returns the index of the last entry in this log slice. Returns
   prev.index if there are no entries.

   go: types.go:78:19 *)
Definition logSlice__lastIndexⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" <>,
    exception_do (let: "s" := (GoAlloc logSlice "s") in
    return: ((![go.uint64] (StructFieldRef entryID "index"%go (StructFieldRef logSlice "prev"%go "s"))) +⟨go.uint64⟩ (Convert go.int go.uint64 (let: "$a0" := (![go.SliceType raftpb.Entry] (StructFieldRef logSlice "entries"%go "s")) in
     (FuncResolve go.len [go.SliceType raftpb.Entry] #()) "$a0")))).

(* lastEntryID returns the ID of the last entry in this log slice, or prev if
   there are no entries.

   go: types.go:84:19 *)
Definition logSlice__lastEntryIDⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" <>,
    exception_do (let: "s" := (GoAlloc logSlice "s") in
    (let: "ln" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := (let: "$a0" := (![go.SliceType raftpb.Entry] (StructFieldRef logSlice "entries"%go "s")) in
    (FuncResolve go.len [go.SliceType raftpb.Entry] #()) "$a0") in
    do:  ("ln" <-[go.int] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.int] "ln") ≠⟨go.int⟩ #(W64 0))
    then
      return: (let: "$a0" := (IndexRef raftpb.Entry (![go.SliceType raftpb.Entry] (StructFieldRef logSlice "entries"%go "s"), (![go.int] "ln") -⟨go.int⟩ #(W64 1))) in
       (FuncResolve pbEntryID [] #()) "$a0")
    else do:  #()));;;
    return: (![entryID] (StructFieldRef logSlice "prev"%go "s"))).

(* valid returns nil iff the logSlice is a well-formed log slice. See logSlice
   comment for details on what constitutes a valid raft log slice.

   go: types.go:93:19 *)
Definition logSlice__validⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "s" <>,
    exception_do (let: "s" := (GoAlloc logSlice "s") in
    let: "prev" := (GoAlloc entryID (GoZeroVal entryID #())) in
    let: "$r0" := (![entryID] (StructFieldRef logSlice "prev"%go "s")) in
    do:  ("prev" <-[entryID] "$r0");;;
    let: "$range" := (![go.SliceType raftpb.Entry] (StructFieldRef logSlice "entries"%go "s")) in
    (let: "i" := (GoAlloc go.int (GoZeroVal go.int #())) in
    slice.for_range raftpb.Entry "$range" (λ: "$key" "$value",
      do:  ("i" <-[go.int] "$key");;;
      let: "id" := (GoAlloc entryID (GoZeroVal entryID #())) in
      let: "$r0" := (let: "$a0" := (IndexRef raftpb.Entry (![go.SliceType raftpb.Entry] (StructFieldRef logSlice "entries"%go "s"), ![go.int] "i")) in
      (FuncResolve pbEntryID [] #()) "$a0") in
      do:  ("id" <-[entryID] "$r0");;;
      (if: Convert go.untyped_bool go.bool (((![go.uint64] (StructFieldRef entryID "term"%go "id")) <⟨go.uint64⟩ (![go.uint64] (StructFieldRef entryID "term"%go "prev"))) || ((![go.uint64] (StructFieldRef entryID "index"%go "id")) ≠⟨go.uint64⟩ ((![go.uint64] (StructFieldRef entryID "index"%go "prev")) +⟨go.uint64⟩ #(W64 1))))
      then
        return: (let: "$a0" := #"leader term %d: entries %+v and %+v not consistent"%go in
         let: "$a1" := ((let: "$sl0" := (Convert go.uint64 go.any (![go.uint64] (StructFieldRef logSlice "term"%go "s"))) in
         let: "$sl1" := (Convert entryID go.any (![entryID] "prev")) in
         let: "$sl2" := (Convert entryID go.any (![entryID] "id")) in
         CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0"); KeyedElement None (ElementExpression go.any "$sl1"); KeyedElement None (ElementExpression go.any "$sl2")]))) in
         (FuncResolve fmt.Errorf [] #()) "$a0" "$a1")
      else do:  #());;;
      let: "$r0" := (![entryID] "id") in
      do:  ("prev" <-[entryID] "$r0")));;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] (StructFieldRef logSlice "term"%go "s")) <⟨go.uint64⟩ (![go.uint64] (StructFieldRef entryID "term"%go "prev")))
    then
      return: (let: "$a0" := #"leader term %d: entry %+v has a newer term"%go in
       let: "$a1" := ((let: "$sl0" := (Convert go.uint64 go.any (![go.uint64] (StructFieldRef logSlice "term"%go "s"))) in
       let: "$sl1" := (Convert entryID go.any (![entryID] "prev")) in
       CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0"); KeyedElement None (ElementExpression go.any "$sl1")]))) in
       (FuncResolve fmt.Errorf [] #()) "$a0" "$a1")
    else do:  #());;;
    return: (Convert go.untyped_nil go.error UntypedNil)).

(* go: util.go:25:21 *)
Definition StateType__MarshalJSONⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "st" <>,
    exception_do (let: "st" := (GoAlloc StateType "st") in
    return: (Convert go.string (go.SliceType go.byte) (let: "$a0" := #"%q"%go in
     let: "$a1" := ((let: "$sl0" := (Convert go.string go.any ((MethodResolve StateType "String"%go (![StateType] "st")) #())) in
     CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0")]))) in
     (FuncResolve fmt.Sprintf [] #()) "$a0" "$a1"), Convert go.untyped_nil go.error UntypedNil)).

(* go: util.go:52:6 *)
Definition isMsgInArrayⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "msgt" "arr",
    exception_do (let: "arr" := (GoAlloc (go.SliceType go.bool) "arr") in
    let: "msgt" := (GoAlloc raftpb.MessageType "msgt") in
    let: "i" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := (Convert raftpb.MessageType go.int (![raftpb.MessageType] "msgt")) in
    do:  ("i" <-[go.int] "$r0");;;
    return: (((![go.int] "i") <⟨go.int⟩ (let: "$a0" := (![go.SliceType go.bool] "arr") in
     (FuncResolve go.len [go.SliceType go.bool] #()) "$a0")) && (![go.bool] (IndexRef (go.SliceType go.bool) (![go.SliceType go.bool] "arr", ![go.int] "i"))))).

(* go: util.go:57:6 *)
Definition IsLocalMsgⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "msgt",
    exception_do (let: "msgt" := (GoAlloc raftpb.MessageType "msgt") in
    return: (let: "$a0" := (![raftpb.MessageType] "msgt") in
     let: "$a1" := (let: "$s" := (![go.ArrayType 23 go.bool] (GlobalVarAddr isLocalMsg #())) in
     Slice (go.ArrayType 23 go.bool) ("$s", #(W64 0), FuncResolve go.len [go.ArrayType 23 go.bool] #() (![go.ArrayType 23 go.bool] (GlobalVarAddr isLocalMsg #())))) in
     (FuncResolve isMsgInArray [] #()) "$a0" "$a1")).

(* go: util.go:61:6 *)
Definition IsResponseMsgⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "msgt",
    exception_do (let: "msgt" := (GoAlloc raftpb.MessageType "msgt") in
    return: (let: "$a0" := (![raftpb.MessageType] "msgt") in
     let: "$a1" := (let: "$s" := (![go.ArrayType 23 go.bool] (GlobalVarAddr isResponseMsg #())) in
     Slice (go.ArrayType 23 go.bool) ("$s", #(W64 0), FuncResolve go.len [go.ArrayType 23 go.bool] #() (![go.ArrayType 23 go.bool] (GlobalVarAddr isResponseMsg #())))) in
     (FuncResolve isMsgInArray [] #()) "$a0" "$a1")).

(* go: util.go:65:6 *)
Definition IsLocalMsgTargetⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "id",
    exception_do (let: "id" := (GoAlloc go.uint64 "id") in
    return: (((![go.uint64] "id") =⟨go.uint64⟩ LocalAppendThread) || ((![go.uint64] "id") =⟨go.uint64⟩ LocalApplyThread))).

(* voteResponseType maps vote and prevote message types to their corresponding responses.

   go: util.go:70:6 *)
Definition voteRespMsgTypeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "msgt",
    exception_do (let: "msgt" := (GoAlloc raftpb.MessageType "msgt") in
    let: "$sw" := (![raftpb.MessageType] "msgt") in
    (if: "$sw" =⟨raftpb.MessageType⟩ raftpb.MsgVote
    then return: (raftpb.MsgVoteResp)
    else
      (if: "$sw" =⟨raftpb.MessageType⟩ raftpb.MsgPreVote
      then return: (raftpb.MsgPreVoteResp)
      else
        do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) (let: "$a0" := #"not a vote message: %s"%go in
        let: "$a1" := ((let: "$sl0" := (Convert raftpb.MessageType go.any (![raftpb.MessageType] "msgt")) in
        CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0")]))) in
        (FuncResolve fmt.Sprintf [] #()) "$a0" "$a1")) in
        (FuncResolve go.panic [] #()) "$a0")))).

(* go: util.go:81:6 *)
Definition DescribeHardStateⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "hs",
    exception_do (let: "hs" := (GoAlloc raftpb.HardState "hs") in
    let: "buf" := (GoAlloc strings.Builder (GoZeroVal strings.Builder #())) in
    do:  (let: "$a0" := (Convert (go.PointerType strings.Builder) io.Writer "buf") in
    let: "$a1" := #"Term:%d"%go in
    let: "$a2" := ((let: "$sl0" := (Convert go.uint64 go.any (![go.uint64] (StructFieldRef raftpb.HardState "Term"%go "hs"))) in
    CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0")]))) in
    (FuncResolve fmt.Fprintf [] #()) "$a0" "$a1" "$a2");;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] (StructFieldRef raftpb.HardState "Vote"%go "hs")) ≠⟨go.uint64⟩ #(W64 0))
    then
      do:  (let: "$a0" := (Convert (go.PointerType strings.Builder) io.Writer "buf") in
      let: "$a1" := #" Vote:%d"%go in
      let: "$a2" := ((let: "$sl0" := (Convert go.uint64 go.any (![go.uint64] (StructFieldRef raftpb.HardState "Vote"%go "hs"))) in
      CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0")]))) in
      (FuncResolve fmt.Fprintf [] #()) "$a0" "$a1" "$a2")
    else do:  #());;;
    do:  (let: "$a0" := (Convert (go.PointerType strings.Builder) io.Writer "buf") in
    let: "$a1" := #" Commit:%d"%go in
    let: "$a2" := ((let: "$sl0" := (Convert go.uint64 go.any (![go.uint64] (StructFieldRef raftpb.HardState "Commit"%go "hs"))) in
    CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0")]))) in
    (FuncResolve fmt.Fprintf [] #()) "$a0" "$a1" "$a2");;;
    return: ((MethodResolve (go.PointerType strings.Builder) "String"%go "buf") #())).

(* go: util.go:91:6 *)
Definition DescribeSoftStateⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "ss",
    exception_do (let: "ss" := (GoAlloc SoftState "ss") in
    return: (let: "$a0" := #"Lead:%d State:%s"%go in
     let: "$a1" := ((let: "$sl0" := (Convert go.uint64 go.any (![go.uint64] (StructFieldRef SoftState "Lead"%go "ss"))) in
     let: "$sl1" := (Convert StateType go.any (![StateType] (StructFieldRef SoftState "RaftState"%go "ss"))) in
     CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0"); KeyedElement None (ElementExpression go.any "$sl1")]))) in
     (FuncResolve fmt.Sprintf [] #()) "$a0" "$a1")).

(* go: util.go:95:6 *)
Definition DescribeConfStateⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "state",
    exception_do (let: "state" := (GoAlloc raftpb.ConfState "state") in
    return: (let: "$a0" := #"Voters:%v VotersOutgoing:%v Learners:%v LearnersNext:%v AutoLeave:%v"%go in
     let: "$a1" := ((let: "$sl0" := (Convert (go.SliceType go.uint64) go.any (![go.SliceType go.uint64] (StructFieldRef raftpb.ConfState "Voters"%go "state"))) in
     let: "$sl1" := (Convert (go.SliceType go.uint64) go.any (![go.SliceType go.uint64] (StructFieldRef raftpb.ConfState "VotersOutgoing"%go "state"))) in
     let: "$sl2" := (Convert (go.SliceType go.uint64) go.any (![go.SliceType go.uint64] (StructFieldRef raftpb.ConfState "Learners"%go "state"))) in
     let: "$sl3" := (Convert (go.SliceType go.uint64) go.any (![go.SliceType go.uint64] (StructFieldRef raftpb.ConfState "LearnersNext"%go "state"))) in
     let: "$sl4" := (Convert go.bool go.any (![go.bool] (StructFieldRef raftpb.ConfState "AutoLeave"%go "state"))) in
     CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0"); KeyedElement None (ElementExpression go.any "$sl1"); KeyedElement None (ElementExpression go.any "$sl2"); KeyedElement None (ElementExpression go.any "$sl3"); KeyedElement None (ElementExpression go.any "$sl4")]))) in
     (FuncResolve fmt.Sprintf [] #()) "$a0" "$a1")).

(* go: util.go:102:6 *)
Definition DescribeSnapshotⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "snap",
    exception_do (let: "snap" := (GoAlloc raftpb.Snapshot "snap") in
    let: "m" := (GoAlloc raftpb.SnapshotMetadata (GoZeroVal raftpb.SnapshotMetadata #())) in
    let: "$r0" := (![raftpb.SnapshotMetadata] (StructFieldRef raftpb.Snapshot "Metadata"%go "snap")) in
    do:  ("m" <-[raftpb.SnapshotMetadata] "$r0");;;
    return: (let: "$a0" := #"Index:%d Term:%d ConfState:%s"%go in
     let: "$a1" := ((let: "$sl0" := (Convert go.uint64 go.any (![go.uint64] (StructFieldRef raftpb.SnapshotMetadata "Index"%go "m"))) in
     let: "$sl1" := (Convert go.uint64 go.any (![go.uint64] (StructFieldRef raftpb.SnapshotMetadata "Term"%go "m"))) in
     let: "$sl2" := (Convert go.string go.any (let: "$a0" := (![raftpb.ConfState] (StructFieldRef raftpb.SnapshotMetadata "ConfState"%go "m")) in
     (FuncResolve DescribeConfState [] #()) "$a0")) in
     CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0"); KeyedElement None (ElementExpression go.any "$sl1"); KeyedElement None (ElementExpression go.any "$sl2")]))) in
     (FuncResolve fmt.Sprintf [] #()) "$a0" "$a1")).

(* go: util.go:107:6 *)
Definition DescribeReadyⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "rd" "f",
    exception_do (let: "f" := (GoAlloc EntryFormatter "f") in
    let: "rd" := (GoAlloc Ready "rd") in
    let: "buf" := (GoAlloc strings.Builder (GoZeroVal strings.Builder #())) in
    (if: Convert go.untyped_bool go.bool ((![go.PointerType SoftState] (StructFieldRef Ready "SoftState"%go "rd")) ≠⟨go.PointerType SoftState⟩ (Convert go.untyped_nil (go.PointerType SoftState) UntypedNil))
    then
      do:  (let: "$a0" := (Convert (go.PointerType strings.Builder) io.Writer "buf") in
      let: "$a1" := ((let: "$sl0" := (Convert go.string go.any (let: "$a0" := (![SoftState] (![go.PointerType SoftState] (StructFieldRef Ready "SoftState"%go "rd"))) in
      (FuncResolve DescribeSoftState [] #()) "$a0")) in
      CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0")]))) in
      (FuncResolve fmt.Fprint [] #()) "$a0" "$a1");;;
      do:  (let: "$a0" := #(W8 10) in
      (MethodResolve (go.PointerType strings.Builder) "WriteByte"%go "buf") "$a0")
    else do:  #());;;
    (if: (~ (let: "$a0" := (![raftpb.HardState] (StructFieldRef Ready "HardState"%go "rd")) in
    (FuncResolve IsEmptyHardState [] #()) "$a0"))
    then
      do:  (let: "$a0" := (Convert (go.PointerType strings.Builder) io.Writer "buf") in
      let: "$a1" := #"HardState %s"%go in
      let: "$a2" := ((let: "$sl0" := (Convert go.string go.any (let: "$a0" := (![raftpb.HardState] (StructFieldRef Ready "HardState"%go "rd")) in
      (FuncResolve DescribeHardState [] #()) "$a0")) in
      CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0")]))) in
      (FuncResolve fmt.Fprintf [] #()) "$a0" "$a1" "$a2");;;
      do:  (let: "$a0" := #(W8 10) in
      (MethodResolve (go.PointerType strings.Builder) "WriteByte"%go "buf") "$a0")
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool ((let: "$a0" := (![go.SliceType ReadState] (StructFieldRef Ready "ReadStates"%go "rd")) in
    (FuncResolve go.len [go.SliceType ReadState] #()) "$a0") >⟨go.int⟩ #(W64 0))
    then
      do:  (let: "$a0" := (Convert (go.PointerType strings.Builder) io.Writer "buf") in
      let: "$a1" := #"ReadStates %v
      "%go in
      let: "$a2" := ((let: "$sl0" := (Convert (go.SliceType ReadState) go.any (![go.SliceType ReadState] (StructFieldRef Ready "ReadStates"%go "rd"))) in
      CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0")]))) in
      (FuncResolve fmt.Fprintf [] #()) "$a0" "$a1" "$a2")
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool ((let: "$a0" := (![go.SliceType raftpb.Entry] (StructFieldRef Ready "Entries"%go "rd")) in
    (FuncResolve go.len [go.SliceType raftpb.Entry] #()) "$a0") >⟨go.int⟩ #(W64 0))
    then
      do:  (let: "$a0" := #"Entries:
      "%go in
      (MethodResolve (go.PointerType strings.Builder) "WriteString"%go "buf") "$a0");;;
      do:  (let: "$a0" := (Convert (go.PointerType strings.Builder) io.Writer "buf") in
      let: "$a1" := ((let: "$sl0" := (Convert go.string go.any (let: "$a0" := (![go.SliceType raftpb.Entry] (StructFieldRef Ready "Entries"%go "rd")) in
      let: "$a1" := (![EntryFormatter] "f") in
      (FuncResolve DescribeEntries [] #()) "$a0" "$a1")) in
      CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0")]))) in
      (FuncResolve fmt.Fprint [] #()) "$a0" "$a1")
    else do:  #());;;
    (if: (~ (let: "$a0" := (![raftpb.Snapshot] (StructFieldRef Ready "Snapshot"%go "rd")) in
    (FuncResolve IsEmptySnap [] #()) "$a0"))
    then
      do:  (let: "$a0" := (Convert (go.PointerType strings.Builder) io.Writer "buf") in
      let: "$a1" := #"Snapshot %s
      "%go in
      let: "$a2" := ((let: "$sl0" := (Convert go.string go.any (let: "$a0" := (![raftpb.Snapshot] (StructFieldRef Ready "Snapshot"%go "rd")) in
      (FuncResolve DescribeSnapshot [] #()) "$a0")) in
      CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0")]))) in
      (FuncResolve fmt.Fprintf [] #()) "$a0" "$a1" "$a2")
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool ((let: "$a0" := (![go.SliceType raftpb.Entry] (StructFieldRef Ready "CommittedEntries"%go "rd")) in
    (FuncResolve go.len [go.SliceType raftpb.Entry] #()) "$a0") >⟨go.int⟩ #(W64 0))
    then
      do:  (let: "$a0" := #"CommittedEntries:
      "%go in
      (MethodResolve (go.PointerType strings.Builder) "WriteString"%go "buf") "$a0");;;
      do:  (let: "$a0" := (Convert (go.PointerType strings.Builder) io.Writer "buf") in
      let: "$a1" := ((let: "$sl0" := (Convert go.string go.any (let: "$a0" := (![go.SliceType raftpb.Entry] (StructFieldRef Ready "CommittedEntries"%go "rd")) in
      let: "$a1" := (![EntryFormatter] "f") in
      (FuncResolve DescribeEntries [] #()) "$a0" "$a1")) in
      CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0")]))) in
      (FuncResolve fmt.Fprint [] #()) "$a0" "$a1")
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool ((let: "$a0" := (![go.SliceType raftpb.Message] (StructFieldRef Ready "Messages"%go "rd")) in
    (FuncResolve go.len [go.SliceType raftpb.Message] #()) "$a0") >⟨go.int⟩ #(W64 0))
    then
      do:  (let: "$a0" := #"Messages:
      "%go in
      (MethodResolve (go.PointerType strings.Builder) "WriteString"%go "buf") "$a0");;;
      let: "$range" := (![go.SliceType raftpb.Message] (StructFieldRef Ready "Messages"%go "rd")) in
      (let: "msg" := (GoAlloc raftpb.Message (GoZeroVal raftpb.Message #())) in
      slice.for_range raftpb.Message "$range" (λ: "$key" "$value",
        do:  ("msg" <-[raftpb.Message] "$value");;;
        do:  "$key";;;
        do:  (let: "$a0" := (Convert (go.PointerType strings.Builder) io.Writer "buf") in
        let: "$a1" := ((let: "$sl0" := (Convert go.string go.any (let: "$a0" := (![raftpb.Message] "msg") in
        let: "$a1" := (![EntryFormatter] "f") in
        (FuncResolve DescribeMessage [] #()) "$a0" "$a1")) in
        CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0")]))) in
        (FuncResolve fmt.Fprint [] #()) "$a0" "$a1");;;
        do:  (let: "$a0" := #(W8 10) in
        (MethodResolve (go.PointerType strings.Builder) "WriteByte"%go "buf") "$a0")))
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool (((MethodResolve (go.PointerType strings.Builder) "Len"%go "buf") #()) >⟨go.int⟩ #(W64 0))
    then
      return: (let: "$a0" := #"Ready MustSync=%t:
       %s"%go in
       let: "$a1" := ((let: "$sl0" := (Convert go.bool go.any (![go.bool] (StructFieldRef Ready "MustSync"%go "rd"))) in
       let: "$sl1" := (Convert go.string go.any ((MethodResolve (go.PointerType strings.Builder) "String"%go "buf") #())) in
       CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0"); KeyedElement None (ElementExpression go.any "$sl1")]))) in
       (FuncResolve fmt.Sprintf [] #()) "$a0" "$a1")
    else do:  #());;;
    return: (#"<empty Ready>"%go)).

(* DescribeMessage returns a concise human-readable description of a
   Message for debugging.

   go: util.go:150:6 *)
Definition DescribeMessageⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "m" "f",
    exception_do (let: "f" := (GoAlloc EntryFormatter "f") in
    let: "m" := (GoAlloc raftpb.Message "m") in
    return: (let: "$a0" := #""%go in
     let: "$a1" := (![raftpb.Message] "m") in
     let: "$a2" := (![EntryFormatter] "f") in
     (FuncResolve describeMessageWithIndent [] #()) "$a0" "$a1" "$a2")).

(* go: util.go:154:6 *)
Definition describeMessageWithIndentⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "indent" "m" "f",
    exception_do (let: "f" := (GoAlloc EntryFormatter "f") in
    let: "m" := (GoAlloc raftpb.Message "m") in
    let: "indent" := (GoAlloc go.string "indent") in
    let: "buf" := (GoAlloc bytes.Buffer (GoZeroVal bytes.Buffer #())) in
    do:  (let: "$a0" := (Convert (go.PointerType bytes.Buffer) io.Writer "buf") in
    let: "$a1" := #"%s%s->%s %v Term:%d Log:%d/%d"%go in
    let: "$a2" := ((let: "$sl0" := (Convert go.string go.any (![go.string] "indent")) in
    let: "$sl1" := (Convert go.string go.any (let: "$a0" := (![go.uint64] (StructFieldRef raftpb.Message "From"%go "m")) in
    (FuncResolve describeTarget [] #()) "$a0")) in
    let: "$sl2" := (Convert go.string go.any (let: "$a0" := (![go.uint64] (StructFieldRef raftpb.Message "To"%go "m")) in
    (FuncResolve describeTarget [] #()) "$a0")) in
    let: "$sl3" := (Convert raftpb.MessageType go.any (![raftpb.MessageType] (StructFieldRef raftpb.Message "Type"%go "m"))) in
    let: "$sl4" := (Convert go.uint64 go.any (![go.uint64] (StructFieldRef raftpb.Message "Term"%go "m"))) in
    let: "$sl5" := (Convert go.uint64 go.any (![go.uint64] (StructFieldRef raftpb.Message "LogTerm"%go "m"))) in
    let: "$sl6" := (Convert go.uint64 go.any (![go.uint64] (StructFieldRef raftpb.Message "Index"%go "m"))) in
    CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0"); KeyedElement None (ElementExpression go.any "$sl1"); KeyedElement None (ElementExpression go.any "$sl2"); KeyedElement None (ElementExpression go.any "$sl3"); KeyedElement None (ElementExpression go.any "$sl4"); KeyedElement None (ElementExpression go.any "$sl5"); KeyedElement None (ElementExpression go.any "$sl6")]))) in
    (FuncResolve fmt.Fprintf [] #()) "$a0" "$a1" "$a2");;;
    (if: ![go.bool] (StructFieldRef raftpb.Message "Reject"%go "m")
    then
      do:  (let: "$a0" := (Convert (go.PointerType bytes.Buffer) io.Writer "buf") in
      let: "$a1" := #" Rejected (Hint: %d)"%go in
      let: "$a2" := ((let: "$sl0" := (Convert go.uint64 go.any (![go.uint64] (StructFieldRef raftpb.Message "RejectHint"%go "m"))) in
      CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0")]))) in
      (FuncResolve fmt.Fprintf [] #()) "$a0" "$a1" "$a2")
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] (StructFieldRef raftpb.Message "Commit"%go "m")) ≠⟨go.uint64⟩ #(W64 0))
    then
      do:  (let: "$a0" := (Convert (go.PointerType bytes.Buffer) io.Writer "buf") in
      let: "$a1" := #" Commit:%d"%go in
      let: "$a2" := ((let: "$sl0" := (Convert go.uint64 go.any (![go.uint64] (StructFieldRef raftpb.Message "Commit"%go "m"))) in
      CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0")]))) in
      (FuncResolve fmt.Fprintf [] #()) "$a0" "$a1" "$a2")
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] (StructFieldRef raftpb.Message "Vote"%go "m")) ≠⟨go.uint64⟩ #(W64 0))
    then
      do:  (let: "$a0" := (Convert (go.PointerType bytes.Buffer) io.Writer "buf") in
      let: "$a1" := #" Vote:%d"%go in
      let: "$a2" := ((let: "$sl0" := (Convert go.uint64 go.any (![go.uint64] (StructFieldRef raftpb.Message "Vote"%go "m"))) in
      CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0")]))) in
      (FuncResolve fmt.Fprintf [] #()) "$a0" "$a1" "$a2")
    else do:  #());;;
    (let: "ln" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := (let: "$a0" := (![go.SliceType raftpb.Entry] (StructFieldRef raftpb.Message "Entries"%go "m")) in
    (FuncResolve go.len [go.SliceType raftpb.Entry] #()) "$a0") in
    do:  ("ln" <-[go.int] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.int] "ln") =⟨go.int⟩ #(W64 1))
    then
      do:  (let: "$a0" := (Convert (go.PointerType bytes.Buffer) io.Writer "buf") in
      let: "$a1" := #" Entries:[%s]"%go in
      let: "$a2" := ((let: "$sl0" := (Convert go.string go.any (let: "$a0" := (![raftpb.Entry] (IndexRef (go.SliceType raftpb.Entry) (![go.SliceType raftpb.Entry] (StructFieldRef raftpb.Message "Entries"%go "m"), #(W64 0)))) in
      let: "$a1" := (![EntryFormatter] "f") in
      (FuncResolve DescribeEntry [] #()) "$a0" "$a1")) in
      CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0")]))) in
      (FuncResolve fmt.Fprintf [] #()) "$a0" "$a1" "$a2")
    else
      (if: Convert go.untyped_bool go.bool ((![go.int] "ln") >⟨go.int⟩ #(W64 1))
      then
        do:  (let: "$a0" := (Convert (go.PointerType bytes.Buffer) io.Writer "buf") in
        let: "$a1" := ((let: "$sl0" := (Convert go.string go.any #" Entries:["%go) in
        CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0")]))) in
        (FuncResolve fmt.Fprint [] #()) "$a0" "$a1");;;
        let: "$range" := (![go.SliceType raftpb.Entry] (StructFieldRef raftpb.Message "Entries"%go "m")) in
        (let: "e" := (GoAlloc raftpb.Entry (GoZeroVal raftpb.Entry #())) in
        slice.for_range raftpb.Entry "$range" (λ: "$key" "$value",
          do:  ("e" <-[raftpb.Entry] "$value");;;
          do:  "$key";;;
          do:  (let: "$a0" := (Convert (go.PointerType bytes.Buffer) io.Writer "buf") in
          let: "$a1" := #"
          %s  "%go in
          let: "$a2" := ((let: "$sl0" := (Convert go.string go.any (![go.string] "indent")) in
          CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0")]))) in
          (FuncResolve fmt.Fprintf [] #()) "$a0" "$a1" "$a2");;;
          do:  (let: "$a0" := (let: "$a0" := (![raftpb.Entry] "e") in
          let: "$a1" := (![EntryFormatter] "f") in
          (FuncResolve DescribeEntry [] #()) "$a0" "$a1") in
          (MethodResolve (go.PointerType bytes.Buffer) "WriteString"%go "buf") "$a0")));;;
        do:  (let: "$a0" := (Convert (go.PointerType bytes.Buffer) io.Writer "buf") in
        let: "$a1" := #"
        %s]"%go in
        let: "$a2" := ((let: "$sl0" := (Convert go.string go.any (![go.string] "indent")) in
        CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0")]))) in
        (FuncResolve fmt.Fprintf [] #()) "$a0" "$a1" "$a2")
      else do:  #())));;;
    (let: "s" := (GoAlloc (go.PointerType raftpb.Snapshot) (GoZeroVal (go.PointerType raftpb.Snapshot) #())) in
    let: "$r0" := (![go.PointerType raftpb.Snapshot] (StructFieldRef raftpb.Message "Snapshot"%go "m")) in
    do:  ("s" <-[go.PointerType raftpb.Snapshot] "$r0");;;
    (if: ((![go.PointerType raftpb.Snapshot] "s") ≠⟨go.PointerType raftpb.Snapshot⟩ (Convert go.untyped_nil (go.PointerType raftpb.Snapshot) UntypedNil)) && (~ (let: "$a0" := (![raftpb.Snapshot] (![go.PointerType raftpb.Snapshot] "s")) in
    (FuncResolve IsEmptySnap [] #()) "$a0"))
    then
      do:  (let: "$a0" := (Convert (go.PointerType bytes.Buffer) io.Writer "buf") in
      let: "$a1" := #"
      %s  Snapshot: %s"%go in
      let: "$a2" := ((let: "$sl0" := (Convert go.string go.any (![go.string] "indent")) in
      let: "$sl1" := (Convert go.string go.any (let: "$a0" := (![raftpb.Snapshot] (![go.PointerType raftpb.Snapshot] "s")) in
      (FuncResolve DescribeSnapshot [] #()) "$a0")) in
      CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0"); KeyedElement None (ElementExpression go.any "$sl1")]))) in
      (FuncResolve fmt.Fprintf [] #()) "$a0" "$a1" "$a2")
    else do:  #()));;;
    (if: Convert go.untyped_bool go.bool ((let: "$a0" := (![go.SliceType raftpb.Message] (StructFieldRef raftpb.Message "Responses"%go "m")) in
    (FuncResolve go.len [go.SliceType raftpb.Message] #()) "$a0") >⟨go.int⟩ #(W64 0))
    then
      do:  (let: "$a0" := (Convert (go.PointerType bytes.Buffer) io.Writer "buf") in
      let: "$a1" := #" Responses:["%go in
      let: "$a2" := #slice.nil in
      (FuncResolve fmt.Fprintf [] #()) "$a0" "$a1" "$a2");;;
      let: "$range" := (![go.SliceType raftpb.Message] (StructFieldRef raftpb.Message "Responses"%go "m")) in
      (let: "m" := (GoAlloc raftpb.Message (GoZeroVal raftpb.Message #())) in
      slice.for_range raftpb.Message "$range" (λ: "$key" "$value",
        do:  ("m" <-[raftpb.Message] "$value");;;
        do:  "$key";;;
        do:  (let: "$a0" := #"
        "%go in
        (MethodResolve (go.PointerType bytes.Buffer) "WriteString"%go "buf") "$a0");;;
        do:  (let: "$a0" := (let: "$a0" := ((![go.string] "indent") +⟨go.string⟩ #"  "%go) in
        let: "$a1" := (![raftpb.Message] "m") in
        let: "$a2" := (![EntryFormatter] "f") in
        (FuncResolve describeMessageWithIndent [] #()) "$a0" "$a1" "$a2") in
        (MethodResolve (go.PointerType bytes.Buffer) "WriteString"%go "buf") "$a0")));;;
      do:  (let: "$a0" := (Convert (go.PointerType bytes.Buffer) io.Writer "buf") in
      let: "$a1" := #"
      %s]"%go in
      let: "$a2" := ((let: "$sl0" := (Convert go.string go.any (![go.string] "indent")) in
      CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0")]))) in
      (FuncResolve fmt.Fprintf [] #()) "$a0" "$a1" "$a2")
    else do:  #());;;
    return: ((MethodResolve (go.PointerType bytes.Buffer) "String"%go "buf") #())).

(* go: util.go:191:6 *)
Definition describeTargetⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "id",
    exception_do (let: "id" := (GoAlloc go.uint64 "id") in
    let: "$sw" := (![go.uint64] "id") in
    (if: "$sw" =⟨go.uint64⟩ None
    then return: (#"None"%go)
    else
      (if: "$sw" =⟨go.uint64⟩ LocalAppendThread
      then return: (#"AppendThread"%go)
      else
        (if: "$sw" =⟨go.uint64⟩ LocalApplyThread
        then return: (#"ApplyThread"%go)
        else
          return: (let: "$a0" := #"%x"%go in
           let: "$a1" := ((let: "$sl0" := (Convert go.uint64 go.any (![go.uint64] "id")) in
           CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0")]))) in
           (FuncResolve fmt.Sprintf [] #()) "$a0" "$a1"))))).

(* DescribeEntry returns a concise human-readable description of an
   Entry for debugging.

   go: util.go:206:6 *)
Definition DescribeEntryⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "e" "f",
    exception_do (let: "f" := (GoAlloc EntryFormatter "f") in
    let: "e" := (GoAlloc raftpb.Entry "e") in
    (if: Convert go.untyped_bool go.bool ((![EntryFormatter] "f") =⟨go.FunctionType (go.Signature [go.SliceType go.byte] false [go.string])⟩ (Convert go.untyped_nil (go.FunctionType (go.Signature [go.SliceType go.byte] false [go.string])) UntypedNil))
    then
      let: "$r0" := (λ: "data",
        exception_do (let: "data" := (GoAlloc (go.SliceType go.byte) "data") in
        return: (let: "$a0" := #"%q"%go in
         let: "$a1" := ((let: "$sl0" := (Convert (go.SliceType go.byte) go.any (![go.SliceType go.byte] "data")) in
         CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0")]))) in
         (FuncResolve fmt.Sprintf [] #()) "$a0" "$a1"))
        ) in
      do:  ("f" <-[EntryFormatter] "$r0")
    else do:  #());;;
    let: "formatConfChange" := (GoAlloc (go.FunctionType (go.Signature [raftpb.ConfChangeI] false [go.string])) (GoZeroVal (go.FunctionType (go.Signature [raftpb.ConfChangeI] false [go.string])) #())) in
    let: "$r0" := (λ: "cc",
      exception_do (let: "cc" := (GoAlloc raftpb.ConfChangeI "cc") in
      return: (let: "$a0" := (StructFieldGet raftpb.ConfChangeV2 "Changes" ((MethodResolve raftpb.ConfChangeI "AsV2"%go (![raftpb.ConfChangeI] "cc")) #())) in
       (FuncResolve raftpb.ConfChangesToString [] #()) "$a0"))
      ) in
    do:  ("formatConfChange" <-[go.FunctionType (go.Signature [raftpb.ConfChangeI] false [go.string])] "$r0");;;
    let: "formatted" := (GoAlloc go.string (GoZeroVal go.string #())) in
    let: "$sw" := (![raftpb.EntryType] (StructFieldRef raftpb.Entry "Type"%go "e")) in
    (if: "$sw" =⟨raftpb.EntryType⟩ raftpb.EntryNormal
    then
      let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] (StructFieldRef raftpb.Entry "Data"%go "e")) in
      (![EntryFormatter] "f") "$a0") in
      do:  ("formatted" <-[go.string] "$r0")
    else
      (if: "$sw" =⟨raftpb.EntryType⟩ raftpb.EntryConfChange
      then
        let: "cc" := (GoAlloc raftpb.ConfChange (GoZeroVal raftpb.ConfChange #())) in
        (let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
        let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] (StructFieldRef raftpb.Entry "Data"%go "e")) in
        (MethodResolve (go.PointerType raftpb.ConfChange) "Unmarshal"%go "cc") "$a0") in
        do:  ("err" <-[go.error] "$r0");;;
        (if: Convert go.untyped_bool go.bool ((![go.error] "err") ≠⟨go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]⟩ (Convert go.untyped_nil (go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]) UntypedNil))
        then
          let: "$r0" := ((MethodResolve go.error "Error"%go (![go.error] "err")) #()) in
          do:  ("formatted" <-[go.string] "$r0")
        else
          let: "$r0" := (let: "$a0" := (Convert raftpb.ConfChange raftpb.ConfChangeI (![raftpb.ConfChange] "cc")) in
          (![go.FunctionType (go.Signature [raftpb.ConfChangeI] false [go.string])] "formatConfChange") "$a0") in
          do:  ("formatted" <-[go.string] "$r0")))
      else
        (if: "$sw" =⟨raftpb.EntryType⟩ raftpb.EntryConfChangeV2
        then
          let: "cc" := (GoAlloc raftpb.ConfChangeV2 (GoZeroVal raftpb.ConfChangeV2 #())) in
          (let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
          let: "$r0" := (let: "$a0" := (![go.SliceType go.byte] (StructFieldRef raftpb.Entry "Data"%go "e")) in
          (MethodResolve (go.PointerType raftpb.ConfChangeV2) "Unmarshal"%go "cc") "$a0") in
          do:  ("err" <-[go.error] "$r0");;;
          (if: Convert go.untyped_bool go.bool ((![go.error] "err") ≠⟨go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]⟩ (Convert go.untyped_nil (go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]) UntypedNil))
          then
            let: "$r0" := ((MethodResolve go.error "Error"%go (![go.error] "err")) #()) in
            do:  ("formatted" <-[go.string] "$r0")
          else
            let: "$r0" := (let: "$a0" := (Convert raftpb.ConfChangeV2 raftpb.ConfChangeI (![raftpb.ConfChangeV2] "cc")) in
            (![go.FunctionType (go.Signature [raftpb.ConfChangeI] false [go.string])] "formatConfChange") "$a0") in
            do:  ("formatted" <-[go.string] "$r0")))
        else do:  #())));;;
    (if: Convert go.untyped_bool go.bool ((![go.string] "formatted") ≠⟨go.string⟩ #""%go)
    then
      let: "$r0" := (#" "%go +⟨go.string⟩ (![go.string] "formatted")) in
      do:  ("formatted" <-[go.string] "$r0")
    else do:  #());;;
    return: (let: "$a0" := #"%d/%d %s%s"%go in
     let: "$a1" := ((let: "$sl0" := (Convert go.uint64 go.any (![go.uint64] (StructFieldRef raftpb.Entry "Term"%go "e"))) in
     let: "$sl1" := (Convert go.uint64 go.any (![go.uint64] (StructFieldRef raftpb.Entry "Index"%go "e"))) in
     let: "$sl2" := (Convert raftpb.EntryType go.any (![raftpb.EntryType] (StructFieldRef raftpb.Entry "Type"%go "e"))) in
     let: "$sl3" := (Convert go.string go.any (![go.string] "formatted")) in
     CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0"); KeyedElement None (ElementExpression go.any "$sl1"); KeyedElement None (ElementExpression go.any "$sl2"); KeyedElement None (ElementExpression go.any "$sl3")]))) in
     (FuncResolve fmt.Sprintf [] #()) "$a0" "$a1")).

(* DescribeEntries calls DescribeEntry for each Entry, adding a newline to
   each.

   go: util.go:244:6 *)
Definition DescribeEntriesⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "ents" "f",
    exception_do (let: "f" := (GoAlloc EntryFormatter "f") in
    let: "ents" := (GoAlloc (go.SliceType raftpb.Entry) "ents") in
    let: "buf" := (GoAlloc bytes.Buffer (GoZeroVal bytes.Buffer #())) in
    let: "$range" := (![go.SliceType raftpb.Entry] "ents") in
    (let: "e" := (GoAlloc raftpb.Entry (GoZeroVal raftpb.Entry #())) in
    slice.for_range raftpb.Entry "$range" (λ: "$key" "$value",
      do:  ("e" <-[raftpb.Entry] "$value");;;
      do:  "$key";;;
      let: ("$ret0", "$ret1") := (let: "$a0" := ((let: "$a0" := (![raftpb.Entry] "e") in
      let: "$a1" := (![EntryFormatter] "f") in
      (FuncResolve DescribeEntry [] #()) "$a0" "$a1") +⟨go.string⟩ #"
      "%go) in
      (MethodResolve (go.PointerType bytes.Buffer) "WriteString"%go "buf") "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  "$r0";;;
      do:  "$r1"));;;
    return: ((MethodResolve (go.PointerType bytes.Buffer) "String"%go "buf") #())).

(* go: util.go:256:6 *)
Definition entsSizeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "ents",
    exception_do (let: "ents" := (GoAlloc (go.SliceType raftpb.Entry) "ents") in
    let: "size" := (GoAlloc entryEncodingSize (GoZeroVal entryEncodingSize #())) in
    let: "$range" := (![go.SliceType raftpb.Entry] "ents") in
    (let: "ent" := (GoAlloc raftpb.Entry (GoZeroVal raftpb.Entry #())) in
    slice.for_range raftpb.Entry "$range" (λ: "$key" "$value",
      do:  ("ent" <-[raftpb.Entry] "$value");;;
      do:  "$key";;;
      do:  ("size" <-[entryEncodingSize] ((![entryEncodingSize] "size") +⟨go.uint64⟩ (Convert go.int entryEncodingSize ((MethodResolve (go.PointerType raftpb.Entry) "Size"%go "ent") #()))))));;;
    return: (![entryEncodingSize] "size")).

(* limitSize returns the longest prefix of the given entries slice, such that
   its total byte size does not exceed maxSize. Always returns a non-empty slice
   if the input is non-empty, so, as an exception, if the size of the first
   entry exceeds maxSize, a non-empty slice with just this entry is returned.

   go: util.go:268:6 *)
Definition limitSizeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "ents" "maxSize",
    exception_do (let: "maxSize" := (GoAlloc entryEncodingSize "maxSize") in
    let: "ents" := (GoAlloc (go.SliceType raftpb.Entry) "ents") in
    (if: Convert go.untyped_bool go.bool ((let: "$a0" := (![go.SliceType raftpb.Entry] "ents") in
    (FuncResolve go.len [go.SliceType raftpb.Entry] #()) "$a0") =⟨go.int⟩ #(W64 0))
    then return: (![go.SliceType raftpb.Entry] "ents")
    else do:  #());;;
    let: "size" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := ((MethodResolve (go.PointerType raftpb.Entry) "Size"%go (IndexRef (go.SliceType raftpb.Entry) (![go.SliceType raftpb.Entry] "ents", #(W64 0)))) #()) in
    do:  ("size" <-[go.int] "$r0");;;
    (let: "limit" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := #(W64 1) in
    do:  ("limit" <-[go.int] "$r0");;;
    (for: (λ: <>, (![go.int] "limit") <⟨go.int⟩ (let: "$a0" := (![go.SliceType raftpb.Entry] "ents") in
    (FuncResolve go.len [go.SliceType raftpb.Entry] #()) "$a0")); (λ: <>, do:  ("limit" <-[go.int] ((![go.int] "limit") +⟨go.int⟩ #(W64 1)))) := λ: <>,
      do:  ("size" <-[go.int] ((![go.int] "size") +⟨go.int⟩ ((MethodResolve (go.PointerType raftpb.Entry) "Size"%go (IndexRef (go.SliceType raftpb.Entry) (![go.SliceType raftpb.Entry] "ents", ![go.int] "limit"))) #())));;;
      (if: Convert go.untyped_bool go.bool ((Convert go.int entryEncodingSize (![go.int] "size")) >⟨go.uint64⟩ (![entryEncodingSize] "maxSize"))
      then
        return: (let: "$s" := (![go.SliceType raftpb.Entry] "ents") in
         Slice (go.SliceType raftpb.Entry) ("$s", #(W64 0), ![go.int] "limit"))
      else do:  #())));;;
    return: (![go.SliceType raftpb.Entry] "ents")).

(* payloadSize is the size of the payload of the provided entry.

   go: util.go:289:6 *)
Definition payloadSizeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "e",
    exception_do (let: "e" := (GoAlloc raftpb.Entry "e") in
    return: (Convert go.int entryPayloadSize (let: "$a0" := (![go.SliceType go.byte] (StructFieldRef raftpb.Entry "Data"%go "e")) in
     (FuncResolve go.len [go.SliceType go.byte] #()) "$a0"))).

(* payloadsSize is the size of the payloads of the provided entries.

   go: util.go:294:6 *)
Definition payloadsSizeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "ents",
    exception_do (let: "ents" := (GoAlloc (go.SliceType raftpb.Entry) "ents") in
    let: "s" := (GoAlloc entryPayloadSize (GoZeroVal entryPayloadSize #())) in
    let: "$range" := (![go.SliceType raftpb.Entry] "ents") in
    (let: "e" := (GoAlloc raftpb.Entry (GoZeroVal raftpb.Entry #())) in
    slice.for_range raftpb.Entry "$range" (λ: "$key" "$value",
      do:  ("e" <-[raftpb.Entry] "$value");;;
      do:  "$key";;;
      do:  ("s" <-[entryPayloadSize] ((![entryPayloadSize] "s") +⟨go.uint64⟩ (let: "$a0" := (![raftpb.Entry] "e") in
      (FuncResolve payloadSize [] #()) "$a0")))));;;
    return: (![entryPayloadSize] "s")).

(* go: util.go:302:6 *)
Definition assertConfStatesEquivalentⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" "cs1" "cs2",
    exception_do (let: "cs2" := (GoAlloc raftpb.ConfState "cs2") in
    let: "cs1" := (GoAlloc raftpb.ConfState "cs1") in
    let: "l" := (GoAlloc Logger "l") in
    let: "err" := (GoAlloc go.error (GoZeroVal go.error #())) in
    let: "$r0" := (let: "$a0" := (![raftpb.ConfState] "cs2") in
    (MethodResolve raftpb.ConfState "Equivalent"%go (![raftpb.ConfState] "cs1")) "$a0") in
    do:  ("err" <-[go.error] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.error] "err") =⟨go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]⟩ (Convert go.untyped_nil (go.InterfaceType [go.MethodElem "Error"%go (go.Signature [] false [go.string])]) UntypedNil))
    then return: (#())
    else do:  #());;;
    do:  (let: "$a0" := ((let: "$sl0" := (Convert go.error (go.InterfaceType []) (![go.error] "err")) in
    CompositeLiteral (go.SliceType (go.InterfaceType [])) (LiteralValue [KeyedElement None (ElementExpression (go.InterfaceType []) "$sl0")]))) in
    (MethodResolve Logger "Panic"%go (![Logger] "l")) "$a0");;;
    return: #()).

(* extend appends vals to the given dst slice. It differs from the standard
   slice append only in the way it allocates memory. If cap(dst) is not enough
   for appending the values, precisely size len(dst)+len(vals) is allocated.

   Use this instead of standard append in situations when this is the last
   append to dst, so there is no sense in allocating more than needed.

   go: util.go:316:6 *)
Definition extendⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "dst" "vals",
    exception_do (let: "vals" := (GoAlloc (go.SliceType raftpb.Entry) "vals") in
    let: "dst" := (GoAlloc (go.SliceType raftpb.Entry) "dst") in
    let: "need" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := ((let: "$a0" := (![go.SliceType raftpb.Entry] "dst") in
    (FuncResolve go.len [go.SliceType raftpb.Entry] #()) "$a0") +⟨go.int⟩ (let: "$a0" := (![go.SliceType raftpb.Entry] "vals") in
    (FuncResolve go.len [go.SliceType raftpb.Entry] #()) "$a0")) in
    do:  ("need" <-[go.int] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.int] "need") ≤⟨go.int⟩ (let: "$a0" := (![go.SliceType raftpb.Entry] "dst") in
    (FuncResolve go.cap [go.SliceType raftpb.Entry] #()) "$a0"))
    then
      return: (let: "$a0" := (![go.SliceType raftpb.Entry] "dst") in
       let: "$a1" := (![go.SliceType raftpb.Entry] "vals") in
       (FuncResolve go.append [go.SliceType raftpb.Entry] #()) "$a0" "$a1")
    else do:  #());;;
    let: "buf" := (GoAlloc (go.SliceType raftpb.Entry) (GoZeroVal (go.SliceType raftpb.Entry) #())) in
    let: "$r0" := ((FuncResolve go.make3 [go.SliceType raftpb.Entry] #()) (![go.int] "need") (![go.int] "need")) in
    do:  ("buf" <-[go.SliceType raftpb.Entry] "$r0");;;
    do:  (let: "$a0" := (![go.SliceType raftpb.Entry] "buf") in
    let: "$a1" := (![go.SliceType raftpb.Entry] "dst") in
    (FuncResolve go.copy [go.SliceType raftpb.Entry] #()) "$a0" "$a1");;;
    do:  (let: "$a0" := (let: "$s" := (![go.SliceType raftpb.Entry] "buf") in
    Slice (go.SliceType raftpb.Entry) ("$s", let: "$a0" := (![go.SliceType raftpb.Entry] "dst") in
     (FuncResolve go.len [go.SliceType raftpb.Entry] #()) "$a0", FuncResolve go.len [go.SliceType raftpb.Entry] #() (![go.SliceType raftpb.Entry] "buf"))) in
    let: "$a1" := (![go.SliceType raftpb.Entry] "vals") in
    (FuncResolve go.copy [go.SliceType raftpb.Entry] #()) "$a0" "$a1");;;
    return: (![go.SliceType raftpb.Entry] "buf")).

#[global] Instance info' : PkgInfo pkg_id.raft :=
{|
  pkg_imported_pkgs := [code.errors.pkg_id.errors; code.go_etcd_io.raft.v3.raftpb.pkg_id.raftpb; code.fmt.pkg_id.fmt; code.io.pkg_id.io; code.log.pkg_id.log; code.os.pkg_id.os; code.sync.pkg_id.sync; code.context.pkg_id.context; code.bytes.pkg_id.bytes; code.crypto.rand.pkg_id.rand; code.math.pkg_id.math; code.math.big.pkg_id.big; code.strings.pkg_id.strings; code.go_etcd_io.raft.v3.confchange.pkg_id.confchange; code.go_etcd_io.raft.v3.quorum.pkg_id.quorum; code.go_etcd_io.raft.v3.quorum.slices.pkg_id.slices; code.go_etcd_io.raft.v3.tracker.pkg_id.tracker]
|}.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init pkg_id.raft (λ: <>,
      exception_do (do:  (go.GlobalAlloc isResponseMsg (go.ArrayType 23 go.bool) #());;;
      do:  (go.GlobalAlloc isLocalMsg (go.ArrayType 23 go.bool) #());;;
      do:  (go.GlobalAlloc ErrSnapshotTemporarilyUnavailable go.error #());;;
      do:  (go.GlobalAlloc ErrUnavailable go.error #());;;
      do:  (go.GlobalAlloc ErrSnapOutOfDate go.error #());;;
      do:  (go.GlobalAlloc ErrCompacted go.error #());;;
      do:  (go.GlobalAlloc ErrStepPeerNotFound go.error #());;;
      do:  (go.GlobalAlloc ErrStepLocalMsg go.error #());;;
      do:  (go.GlobalAlloc errBreak go.error #());;;
      do:  (go.GlobalAlloc stmap (go.ArrayType 4 go.string) #());;;
      do:  (go.GlobalAlloc globalRand (go.PointerType lockedRand) #());;;
      do:  (go.GlobalAlloc ErrProposalDropped go.error #());;;
      do:  (go.GlobalAlloc ErrStopped go.error #());;;
      do:  (go.GlobalAlloc emptyState raftpb.HardState #());;;
      do:  (go.GlobalAlloc raftLogger Logger #());;;
      do:  (go.GlobalAlloc raftLoggerMu sync.Mutex #());;;
      do:  (go.GlobalAlloc discardLogger (go.PointerType DefaultLogger) #());;;
      do:  (go.GlobalAlloc defaultLogger (go.PointerType DefaultLogger) #());;;
      do:  (tracker.initialize' #());;;
      do:  (slices.initialize' #());;;
      do:  (quorum.initialize' #());;;
      do:  (confchange.initialize' #());;;
      do:  (strings.initialize' #());;;
      do:  (big.initialize' #());;;
      do:  (math.initialize' #());;;
      do:  (rand.initialize' #());;;
      do:  (bytes.initialize' #());;;
      do:  (context.initialize' #());;;
      do:  (sync.initialize' #());;;
      do:  (os.initialize' #());;;
      do:  (log.initialize' #());;;
      do:  (io.initialize' #());;;
      do:  (fmt.initialize' #());;;
      do:  (raftpb.initialize' #());;;
      do:  (errors.initialize' #());;;
      let: "$r0" := (GoAlloc DefaultLogger (CompositeLiteral DefaultLogger (LiteralValue [KeyedElement (Some (KeyField "Logger"%go)) (ElementExpression (go.PointerType log.Logger) (let: "$a0" := (Convert (go.PointerType os.File) io.Writer (![go.PointerType os.File] (GlobalVarAddr os.Stderr #()))) in
       let: "$a1" := #"raft"%go in
       let: "$a2" := (Convert go.untyped_int go.int log.LstdFlags) in
       (FuncResolve log.New [] #()) "$a0" "$a1" "$a2"))]))) in
      do:  ((GlobalVarAddr defaultLogger #()) <-[go.PointerType DefaultLogger] "$r0");;;
      let: "$r0" := (GoAlloc DefaultLogger (CompositeLiteral DefaultLogger (LiteralValue [KeyedElement (Some (KeyField "Logger"%go)) (ElementExpression (go.PointerType log.Logger) (let: "$a0" := (![io.Writer] (GlobalVarAddr io.Discard #())) in
       let: "$a1" := #""%go in
       let: "$a2" := #(W64 0) in
       (FuncResolve log.New [] #()) "$a0" "$a1" "$a2"))]))) in
      do:  ((GlobalVarAddr discardLogger #()) <-[go.PointerType DefaultLogger] "$r0");;;
      let: "$r0" := (Convert (go.PointerType DefaultLogger) Logger (![go.PointerType DefaultLogger] (GlobalVarAddr defaultLogger #()))) in
      do:  ((GlobalVarAddr raftLogger #()) <-[Logger] "$r0");;;
      let: "$r0" := (CompositeLiteral raftpb.HardState (LiteralValue [])) in
      do:  ((GlobalVarAddr emptyState #()) <-[raftpb.HardState] "$r0");;;
      let: "$r0" := (let: "$a0" := #"raft: stopped"%go in
      (FuncResolve errors.New [] #()) "$a0") in
      do:  ((GlobalVarAddr ErrStopped #()) <-[go.error] "$r0");;;
      let: "$r0" := (let: "$a0" := #"raft proposal dropped"%go in
      (FuncResolve errors.New [] #()) "$a0") in
      do:  ((GlobalVarAddr ErrProposalDropped #()) <-[go.error] "$r0");;;
      let: "$r0" := (GoAlloc lockedRand (CompositeLiteral lockedRand (LiteralValue []))) in
      do:  ((GlobalVarAddr globalRand #()) <-[go.PointerType lockedRand] "$r0");;;
      let: "$r0" := (CompositeLiteral (go.ArrayType 4 go.string) (LiteralValue [KeyedElement None (ElementExpression go.string #"StateFollower"%go); KeyedElement None (ElementExpression go.string #"StateCandidate"%go); KeyedElement None (ElementExpression go.string #"StateLeader"%go); KeyedElement None (ElementExpression go.string #"StatePreCandidate"%go)])) in
      do:  ((GlobalVarAddr stmap #()) <-[go.ArrayType 4 go.string] "$r0");;;
      let: "$r0" := (let: "$a0" := #"break"%go in
      (FuncResolve errors.New [] #()) "$a0") in
      do:  ((GlobalVarAddr errBreak #()) <-[go.error] "$r0");;;
      let: "$r0" := (let: "$a0" := #"raft: cannot step raft local message"%go in
      (FuncResolve errors.New [] #()) "$a0") in
      do:  ((GlobalVarAddr ErrStepLocalMsg #()) <-[go.error] "$r0");;;
      let: "$r0" := (let: "$a0" := #"raft: cannot step as peer not found"%go in
      (FuncResolve errors.New [] #()) "$a0") in
      do:  ((GlobalVarAddr ErrStepPeerNotFound #()) <-[go.error] "$r0");;;
      let: "$r0" := (let: "$a0" := #"requested index is unavailable due to compaction"%go in
      (FuncResolve errors.New [] #()) "$a0") in
      do:  ((GlobalVarAddr ErrCompacted #()) <-[go.error] "$r0");;;
      let: "$r0" := (let: "$a0" := #"requested index is older than the existing snapshot"%go in
      (FuncResolve errors.New [] #()) "$a0") in
      do:  ((GlobalVarAddr ErrSnapOutOfDate #()) <-[go.error] "$r0");;;
      let: "$r0" := (let: "$a0" := #"requested entry at index is unavailable"%go in
      (FuncResolve errors.New [] #()) "$a0") in
      do:  ((GlobalVarAddr ErrUnavailable #()) <-[go.error] "$r0");;;
      let: "$r0" := (let: "$a0" := #"snapshot is temporarily unavailable"%go in
      (FuncResolve errors.New [] #()) "$a0") in
      do:  ((GlobalVarAddr ErrSnapshotTemporarilyUnavailable #()) <-[go.error] "$r0");;;
      let: "$r0" := (CompositeLiteral (go.ArrayType 23 go.bool) (LiteralValue [KeyedElement (Some (KeyExpression raftpb.MessageType raftpb.MsgHup)) (ElementExpression go.bool #true); KeyedElement (Some (KeyExpression raftpb.MessageType raftpb.MsgBeat)) (ElementExpression go.bool #true); KeyedElement (Some (KeyExpression raftpb.MessageType raftpb.MsgUnreachable)) (ElementExpression go.bool #true); KeyedElement (Some (KeyExpression raftpb.MessageType raftpb.MsgSnapStatus)) (ElementExpression go.bool #true); KeyedElement (Some (KeyExpression raftpb.MessageType raftpb.MsgCheckQuorum)) (ElementExpression go.bool #true); KeyedElement (Some (KeyExpression raftpb.MessageType raftpb.MsgStorageAppend)) (ElementExpression go.bool #true); KeyedElement (Some (KeyExpression raftpb.MessageType raftpb.MsgStorageAppendResp)) (ElementExpression go.bool #true); KeyedElement (Some (KeyExpression raftpb.MessageType raftpb.MsgStorageApply)) (ElementExpression go.bool #true); KeyedElement (Some (KeyExpression raftpb.MessageType raftpb.MsgStorageApplyResp)) (ElementExpression go.bool #true)])) in
      do:  ((GlobalVarAddr isLocalMsg #()) <-[go.ArrayType 23 go.bool] "$r0");;;
      let: "$r0" := (CompositeLiteral (go.ArrayType 23 go.bool) (LiteralValue [KeyedElement (Some (KeyExpression raftpb.MessageType raftpb.MsgAppResp)) (ElementExpression go.bool #true); KeyedElement (Some (KeyExpression raftpb.MessageType raftpb.MsgVoteResp)) (ElementExpression go.bool #true); KeyedElement (Some (KeyExpression raftpb.MessageType raftpb.MsgHeartbeatResp)) (ElementExpression go.bool #true); KeyedElement (Some (KeyExpression raftpb.MessageType raftpb.MsgUnreachable)) (ElementExpression go.bool #true); KeyedElement (Some (KeyExpression raftpb.MessageType raftpb.MsgReadIndexResp)) (ElementExpression go.bool #true); KeyedElement (Some (KeyExpression raftpb.MessageType raftpb.MsgPreVoteResp)) (ElementExpression go.bool #true); KeyedElement (Some (KeyExpression raftpb.MessageType raftpb.MsgStorageAppendResp)) (ElementExpression go.bool #true); KeyedElement (Some (KeyExpression raftpb.MessageType raftpb.MsgStorageApplyResp)) (ElementExpression go.bool #true)])) in
      do:  ((GlobalVarAddr isResponseMsg #()) <-[go.ArrayType 23 go.bool] "$r0"))
      ).

Module Storage.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := interface.t.
End def.
End Storage.

Definition Storageⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.InterfaceType [go.MethodElem "Entries"%go (go.Signature [go.uint64; go.uint64; go.uint64] false [go.SliceType raftpb.Entry; go.error]); go.MethodElem "FirstIndex"%go (go.Signature [] false [go.uint64; go.error]); go.MethodElem "InitialState"%go (go.Signature [] false [raftpb.HardState; raftpb.ConfState; go.error]); go.MethodElem "LastIndex"%go (go.Signature [] false [go.uint64; go.error]); go.MethodElem "Snapshot"%go (go.Signature [] false [raftpb.Snapshot; go.error]); go.MethodElem "Term"%go (go.Signature [go.uint64] false [go.uint64; go.error])].

Class Storage_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Storage_underlying :: (Storage) <u (Storageⁱᵐᵖˡ);
}.

Module Logger.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := interface.t.
End def.
End Logger.

Definition Loggerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.InterfaceType [go.MethodElem "Debug"%go (go.Signature [go.SliceType (go.InterfaceType [])] true []); go.MethodElem "Debugf"%go (go.Signature [go.string; go.SliceType (go.InterfaceType [])] true []); go.MethodElem "Error"%go (go.Signature [go.SliceType (go.InterfaceType [])] true []); go.MethodElem "Errorf"%go (go.Signature [go.string; go.SliceType (go.InterfaceType [])] true []); go.MethodElem "Fatal"%go (go.Signature [go.SliceType (go.InterfaceType [])] true []); go.MethodElem "Fatalf"%go (go.Signature [go.string; go.SliceType (go.InterfaceType [])] true []); go.MethodElem "Info"%go (go.Signature [go.SliceType (go.InterfaceType [])] true []); go.MethodElem "Infof"%go (go.Signature [go.string; go.SliceType (go.InterfaceType [])] true []); go.MethodElem "Panic"%go (go.Signature [go.SliceType (go.InterfaceType [])] true []); go.MethodElem "Panicf"%go (go.Signature [go.string; go.SliceType (go.InterfaceType [])] true []); go.MethodElem "Warning"%go (go.Signature [go.SliceType (go.InterfaceType [])] true []); go.MethodElem "Warningf"%go (go.Signature [go.string; go.SliceType (go.InterfaceType [])] true [])].

Class Logger_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Logger_underlying :: (Logger) <u (Loggerⁱᵐᵖˡ);
}.

Module unstable.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  snapshot' : loc;
  entries' : slice.t;
  offset' : w64;
  snapshotInProgress' : bool;
  offsetInProgress' : w64;
  logger' : raft.Logger.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End unstable.

Definition unstable'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "snapshot"%go (go.PointerType raftpb.Snapshot));
  (go.FieldDecl "entries"%go (go.SliceType raftpb.Entry));
  (go.FieldDecl "offset"%go go.uint64);
  (go.FieldDecl "snapshotInProgress"%go go.bool);
  (go.FieldDecl "offsetInProgress"%go go.uint64);
  (go.FieldDecl "logger"%go Logger)
].
Program Definition unstable'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (unstable'fds_unsealed).
Global Instance equals_unfold_unstable {ext : ffi_syntax} {go_gctx : GoGlobalContext} : unstable'fds =→ unstable'fds_unsealed.
Proof. rewrite /unstable'fds seal_eq //. Qed.

Definition unstableⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (unstable'fds).

Class unstable_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] unstable_type_repr  :: go.TypeReprUnderlying unstableⁱᵐᵖˡ unstable.t;
  #[global] unstable_underlying :: (unstable) <u (unstableⁱᵐᵖˡ);
  #[global] unstable_get_snapshot (x : unstable.t) :: ⟦StructFieldGet (unstableⁱᵐᵖˡ) "snapshot", #x⟧ ⤳[under] #x.(unstable.snapshot');
  #[global] unstable_set_snapshot (x : unstable.t) y :: ⟦StructFieldSet (unstableⁱᵐᵖˡ) "snapshot", (#x, #y)⟧ ⤳[under] #(x <|unstable.snapshot' := y|>);
  #[global] unstable_get_entries (x : unstable.t) :: ⟦StructFieldGet (unstableⁱᵐᵖˡ) "entries", #x⟧ ⤳[under] #x.(unstable.entries');
  #[global] unstable_set_entries (x : unstable.t) y :: ⟦StructFieldSet (unstableⁱᵐᵖˡ) "entries", (#x, #y)⟧ ⤳[under] #(x <|unstable.entries' := y|>);
  #[global] unstable_get_offset (x : unstable.t) :: ⟦StructFieldGet (unstableⁱᵐᵖˡ) "offset", #x⟧ ⤳[under] #x.(unstable.offset');
  #[global] unstable_set_offset (x : unstable.t) y :: ⟦StructFieldSet (unstableⁱᵐᵖˡ) "offset", (#x, #y)⟧ ⤳[under] #(x <|unstable.offset' := y|>);
  #[global] unstable_get_snapshotInProgress (x : unstable.t) :: ⟦StructFieldGet (unstableⁱᵐᵖˡ) "snapshotInProgress", #x⟧ ⤳[under] #x.(unstable.snapshotInProgress');
  #[global] unstable_set_snapshotInProgress (x : unstable.t) y :: ⟦StructFieldSet (unstableⁱᵐᵖˡ) "snapshotInProgress", (#x, #y)⟧ ⤳[under] #(x <|unstable.snapshotInProgress' := y|>);
  #[global] unstable_get_offsetInProgress (x : unstable.t) :: ⟦StructFieldGet (unstableⁱᵐᵖˡ) "offsetInProgress", #x⟧ ⤳[under] #x.(unstable.offsetInProgress');
  #[global] unstable_set_offsetInProgress (x : unstable.t) y :: ⟦StructFieldSet (unstableⁱᵐᵖˡ) "offsetInProgress", (#x, #y)⟧ ⤳[under] #(x <|unstable.offsetInProgress' := y|>);
  #[global] unstable_get_logger (x : unstable.t) :: ⟦StructFieldGet (unstableⁱᵐᵖˡ) "logger", #x⟧ ⤳[under] #x.(unstable.logger');
  #[global] unstable_set_logger (x : unstable.t) y :: ⟦StructFieldSet (unstableⁱᵐᵖˡ) "logger", (#x, #y)⟧ ⤳[under] #(x <|unstable.logger' := y|>);
  #[global] unstable'ptr_acceptInProgress_unfold :: MethodUnfold (go.PointerType (unstable)) "acceptInProgress" (unstable__acceptInProgressⁱᵐᵖˡ);
  #[global] unstable'ptr_maybeFirstIndex_unfold :: MethodUnfold (go.PointerType (unstable)) "maybeFirstIndex" (unstable__maybeFirstIndexⁱᵐᵖˡ);
  #[global] unstable'ptr_maybeLastIndex_unfold :: MethodUnfold (go.PointerType (unstable)) "maybeLastIndex" (unstable__maybeLastIndexⁱᵐᵖˡ);
  #[global] unstable'ptr_maybeTerm_unfold :: MethodUnfold (go.PointerType (unstable)) "maybeTerm" (unstable__maybeTermⁱᵐᵖˡ);
  #[global] unstable'ptr_mustCheckOutOfBounds_unfold :: MethodUnfold (go.PointerType (unstable)) "mustCheckOutOfBounds" (unstable__mustCheckOutOfBoundsⁱᵐᵖˡ);
  #[global] unstable'ptr_nextEntries_unfold :: MethodUnfold (go.PointerType (unstable)) "nextEntries" (unstable__nextEntriesⁱᵐᵖˡ);
  #[global] unstable'ptr_nextSnapshot_unfold :: MethodUnfold (go.PointerType (unstable)) "nextSnapshot" (unstable__nextSnapshotⁱᵐᵖˡ);
  #[global] unstable'ptr_restore_unfold :: MethodUnfold (go.PointerType (unstable)) "restore" (unstable__restoreⁱᵐᵖˡ);
  #[global] unstable'ptr_shrinkEntriesArray_unfold :: MethodUnfold (go.PointerType (unstable)) "shrinkEntriesArray" (unstable__shrinkEntriesArrayⁱᵐᵖˡ);
  #[global] unstable'ptr_slice_unfold :: MethodUnfold (go.PointerType (unstable)) "slice" (unstable__sliceⁱᵐᵖˡ);
  #[global] unstable'ptr_stableSnapTo_unfold :: MethodUnfold (go.PointerType (unstable)) "stableSnapTo" (unstable__stableSnapToⁱᵐᵖˡ);
  #[global] unstable'ptr_stableTo_unfold :: MethodUnfold (go.PointerType (unstable)) "stableTo" (unstable__stableToⁱᵐᵖˡ);
  #[global] unstable'ptr_truncateAndAppend_unfold :: MethodUnfold (go.PointerType (unstable)) "truncateAndAppend" (unstable__truncateAndAppendⁱᵐᵖˡ);
}.

Module entryEncodingSize.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := w64.
End def.
End entryEncodingSize.

Definition entryEncodingSizeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.uint64.

Class entryEncodingSize_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] entryEncodingSize_underlying :: (entryEncodingSize) <u (entryEncodingSizeⁱᵐᵖˡ);
}.

Module raftLog.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  storage' : raft.Storage.t;
  unstable' : raft.unstable.t;
  committed' : w64;
  applying' : w64;
  applied' : w64;
  logger' : raft.Logger.t;
  maxApplyingEntsSize' : raft.entryEncodingSize.t;
  applyingEntsSize' : raft.entryEncodingSize.t;
  applyingEntsPaused' : bool;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End raftLog.

Definition raftLog'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "storage"%go Storage);
  (go.FieldDecl "unstable"%go unstable);
  (go.FieldDecl "committed"%go go.uint64);
  (go.FieldDecl "applying"%go go.uint64);
  (go.FieldDecl "applied"%go go.uint64);
  (go.FieldDecl "logger"%go Logger);
  (go.FieldDecl "maxApplyingEntsSize"%go entryEncodingSize);
  (go.FieldDecl "applyingEntsSize"%go entryEncodingSize);
  (go.FieldDecl "applyingEntsPaused"%go go.bool)
].
Program Definition raftLog'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (raftLog'fds_unsealed).
Global Instance equals_unfold_raftLog {ext : ffi_syntax} {go_gctx : GoGlobalContext} : raftLog'fds =→ raftLog'fds_unsealed.
Proof. rewrite /raftLog'fds seal_eq //. Qed.

Definition raftLogⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (raftLog'fds).

Class raftLog_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] raftLog_type_repr  :: go.TypeReprUnderlying raftLogⁱᵐᵖˡ raftLog.t;
  #[global] raftLog_underlying :: (raftLog) <u (raftLogⁱᵐᵖˡ);
  #[global] raftLog_get_storage (x : raftLog.t) :: ⟦StructFieldGet (raftLogⁱᵐᵖˡ) "storage", #x⟧ ⤳[under] #x.(raftLog.storage');
  #[global] raftLog_set_storage (x : raftLog.t) y :: ⟦StructFieldSet (raftLogⁱᵐᵖˡ) "storage", (#x, #y)⟧ ⤳[under] #(x <|raftLog.storage' := y|>);
  #[global] raftLog_get_unstable (x : raftLog.t) :: ⟦StructFieldGet (raftLogⁱᵐᵖˡ) "unstable", #x⟧ ⤳[under] #x.(raftLog.unstable');
  #[global] raftLog_set_unstable (x : raftLog.t) y :: ⟦StructFieldSet (raftLogⁱᵐᵖˡ) "unstable", (#x, #y)⟧ ⤳[under] #(x <|raftLog.unstable' := y|>);
  #[global] raftLog_get_committed (x : raftLog.t) :: ⟦StructFieldGet (raftLogⁱᵐᵖˡ) "committed", #x⟧ ⤳[under] #x.(raftLog.committed');
  #[global] raftLog_set_committed (x : raftLog.t) y :: ⟦StructFieldSet (raftLogⁱᵐᵖˡ) "committed", (#x, #y)⟧ ⤳[under] #(x <|raftLog.committed' := y|>);
  #[global] raftLog_get_applying (x : raftLog.t) :: ⟦StructFieldGet (raftLogⁱᵐᵖˡ) "applying", #x⟧ ⤳[under] #x.(raftLog.applying');
  #[global] raftLog_set_applying (x : raftLog.t) y :: ⟦StructFieldSet (raftLogⁱᵐᵖˡ) "applying", (#x, #y)⟧ ⤳[under] #(x <|raftLog.applying' := y|>);
  #[global] raftLog_get_applied (x : raftLog.t) :: ⟦StructFieldGet (raftLogⁱᵐᵖˡ) "applied", #x⟧ ⤳[under] #x.(raftLog.applied');
  #[global] raftLog_set_applied (x : raftLog.t) y :: ⟦StructFieldSet (raftLogⁱᵐᵖˡ) "applied", (#x, #y)⟧ ⤳[under] #(x <|raftLog.applied' := y|>);
  #[global] raftLog_get_logger (x : raftLog.t) :: ⟦StructFieldGet (raftLogⁱᵐᵖˡ) "logger", #x⟧ ⤳[under] #x.(raftLog.logger');
  #[global] raftLog_set_logger (x : raftLog.t) y :: ⟦StructFieldSet (raftLogⁱᵐᵖˡ) "logger", (#x, #y)⟧ ⤳[under] #(x <|raftLog.logger' := y|>);
  #[global] raftLog_get_maxApplyingEntsSize (x : raftLog.t) :: ⟦StructFieldGet (raftLogⁱᵐᵖˡ) "maxApplyingEntsSize", #x⟧ ⤳[under] #x.(raftLog.maxApplyingEntsSize');
  #[global] raftLog_set_maxApplyingEntsSize (x : raftLog.t) y :: ⟦StructFieldSet (raftLogⁱᵐᵖˡ) "maxApplyingEntsSize", (#x, #y)⟧ ⤳[under] #(x <|raftLog.maxApplyingEntsSize' := y|>);
  #[global] raftLog_get_applyingEntsSize (x : raftLog.t) :: ⟦StructFieldGet (raftLogⁱᵐᵖˡ) "applyingEntsSize", #x⟧ ⤳[under] #x.(raftLog.applyingEntsSize');
  #[global] raftLog_set_applyingEntsSize (x : raftLog.t) y :: ⟦StructFieldSet (raftLogⁱᵐᵖˡ) "applyingEntsSize", (#x, #y)⟧ ⤳[under] #(x <|raftLog.applyingEntsSize' := y|>);
  #[global] raftLog_get_applyingEntsPaused (x : raftLog.t) :: ⟦StructFieldGet (raftLogⁱᵐᵖˡ) "applyingEntsPaused", #x⟧ ⤳[under] #x.(raftLog.applyingEntsPaused');
  #[global] raftLog_set_applyingEntsPaused (x : raftLog.t) y :: ⟦StructFieldSet (raftLogⁱᵐᵖˡ) "applyingEntsPaused", (#x, #y)⟧ ⤳[under] #(x <|raftLog.applyingEntsPaused' := y|>);
  #[global] raftLog'ptr_String_unfold :: MethodUnfold (go.PointerType (raftLog)) "String" (raftLog__Stringⁱᵐᵖˡ);
  #[global] raftLog'ptr_acceptApplying_unfold :: MethodUnfold (go.PointerType (raftLog)) "acceptApplying" (raftLog__acceptApplyingⁱᵐᵖˡ);
  #[global] raftLog'ptr_acceptUnstable_unfold :: MethodUnfold (go.PointerType (raftLog)) "acceptUnstable" (raftLog__acceptUnstableⁱᵐᵖˡ);
  #[global] raftLog'ptr_allEntries_unfold :: MethodUnfold (go.PointerType (raftLog)) "allEntries" (raftLog__allEntriesⁱᵐᵖˡ);
  #[global] raftLog'ptr_append_unfold :: MethodUnfold (go.PointerType (raftLog)) "append" (raftLog__appendⁱᵐᵖˡ);
  #[global] raftLog'ptr_appliedTo_unfold :: MethodUnfold (go.PointerType (raftLog)) "appliedTo" (raftLog__appliedToⁱᵐᵖˡ);
  #[global] raftLog'ptr_commitTo_unfold :: MethodUnfold (go.PointerType (raftLog)) "commitTo" (raftLog__commitToⁱᵐᵖˡ);
  #[global] raftLog'ptr_entries_unfold :: MethodUnfold (go.PointerType (raftLog)) "entries" (raftLog__entriesⁱᵐᵖˡ);
  #[global] raftLog'ptr_findConflict_unfold :: MethodUnfold (go.PointerType (raftLog)) "findConflict" (raftLog__findConflictⁱᵐᵖˡ);
  #[global] raftLog'ptr_findConflictByTerm_unfold :: MethodUnfold (go.PointerType (raftLog)) "findConflictByTerm" (raftLog__findConflictByTermⁱᵐᵖˡ);
  #[global] raftLog'ptr_firstIndex_unfold :: MethodUnfold (go.PointerType (raftLog)) "firstIndex" (raftLog__firstIndexⁱᵐᵖˡ);
  #[global] raftLog'ptr_hasNextCommittedEnts_unfold :: MethodUnfold (go.PointerType (raftLog)) "hasNextCommittedEnts" (raftLog__hasNextCommittedEntsⁱᵐᵖˡ);
  #[global] raftLog'ptr_hasNextOrInProgressSnapshot_unfold :: MethodUnfold (go.PointerType (raftLog)) "hasNextOrInProgressSnapshot" (raftLog__hasNextOrInProgressSnapshotⁱᵐᵖˡ);
  #[global] raftLog'ptr_hasNextOrInProgressUnstableEnts_unfold :: MethodUnfold (go.PointerType (raftLog)) "hasNextOrInProgressUnstableEnts" (raftLog__hasNextOrInProgressUnstableEntsⁱᵐᵖˡ);
  #[global] raftLog'ptr_hasNextUnstableEnts_unfold :: MethodUnfold (go.PointerType (raftLog)) "hasNextUnstableEnts" (raftLog__hasNextUnstableEntsⁱᵐᵖˡ);
  #[global] raftLog'ptr_hasNextUnstableSnapshot_unfold :: MethodUnfold (go.PointerType (raftLog)) "hasNextUnstableSnapshot" (raftLog__hasNextUnstableSnapshotⁱᵐᵖˡ);
  #[global] raftLog'ptr_isUpToDate_unfold :: MethodUnfold (go.PointerType (raftLog)) "isUpToDate" (raftLog__isUpToDateⁱᵐᵖˡ);
  #[global] raftLog'ptr_lastEntryID_unfold :: MethodUnfold (go.PointerType (raftLog)) "lastEntryID" (raftLog__lastEntryIDⁱᵐᵖˡ);
  #[global] raftLog'ptr_lastIndex_unfold :: MethodUnfold (go.PointerType (raftLog)) "lastIndex" (raftLog__lastIndexⁱᵐᵖˡ);
  #[global] raftLog'ptr_matchTerm_unfold :: MethodUnfold (go.PointerType (raftLog)) "matchTerm" (raftLog__matchTermⁱᵐᵖˡ);
  #[global] raftLog'ptr_maxAppliableIndex_unfold :: MethodUnfold (go.PointerType (raftLog)) "maxAppliableIndex" (raftLog__maxAppliableIndexⁱᵐᵖˡ);
  #[global] raftLog'ptr_maybeAppend_unfold :: MethodUnfold (go.PointerType (raftLog)) "maybeAppend" (raftLog__maybeAppendⁱᵐᵖˡ);
  #[global] raftLog'ptr_maybeCommit_unfold :: MethodUnfold (go.PointerType (raftLog)) "maybeCommit" (raftLog__maybeCommitⁱᵐᵖˡ);
  #[global] raftLog'ptr_mustCheckOutOfBounds_unfold :: MethodUnfold (go.PointerType (raftLog)) "mustCheckOutOfBounds" (raftLog__mustCheckOutOfBoundsⁱᵐᵖˡ);
  #[global] raftLog'ptr_nextCommittedEnts_unfold :: MethodUnfold (go.PointerType (raftLog)) "nextCommittedEnts" (raftLog__nextCommittedEntsⁱᵐᵖˡ);
  #[global] raftLog'ptr_nextUnstableEnts_unfold :: MethodUnfold (go.PointerType (raftLog)) "nextUnstableEnts" (raftLog__nextUnstableEntsⁱᵐᵖˡ);
  #[global] raftLog'ptr_nextUnstableSnapshot_unfold :: MethodUnfold (go.PointerType (raftLog)) "nextUnstableSnapshot" (raftLog__nextUnstableSnapshotⁱᵐᵖˡ);
  #[global] raftLog'ptr_restore_unfold :: MethodUnfold (go.PointerType (raftLog)) "restore" (raftLog__restoreⁱᵐᵖˡ);
  #[global] raftLog'ptr_scan_unfold :: MethodUnfold (go.PointerType (raftLog)) "scan" (raftLog__scanⁱᵐᵖˡ);
  #[global] raftLog'ptr_slice_unfold :: MethodUnfold (go.PointerType (raftLog)) "slice" (raftLog__sliceⁱᵐᵖˡ);
  #[global] raftLog'ptr_snapshot_unfold :: MethodUnfold (go.PointerType (raftLog)) "snapshot" (raftLog__snapshotⁱᵐᵖˡ);
  #[global] raftLog'ptr_stableSnapTo_unfold :: MethodUnfold (go.PointerType (raftLog)) "stableSnapTo" (raftLog__stableSnapToⁱᵐᵖˡ);
  #[global] raftLog'ptr_stableTo_unfold :: MethodUnfold (go.PointerType (raftLog)) "stableTo" (raftLog__stableToⁱᵐᵖˡ);
  #[global] raftLog'ptr_term_unfold :: MethodUnfold (go.PointerType (raftLog)) "term" (raftLog__termⁱᵐᵖˡ);
  #[global] raftLog'ptr_zeroTermOnOutOfBounds_unfold :: MethodUnfold (go.PointerType (raftLog)) "zeroTermOnOutOfBounds" (raftLog__zeroTermOnOutOfBoundsⁱᵐᵖˡ);
}.

Module DefaultLogger.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  Logger' : loc;
  debug' : bool;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End DefaultLogger.

Definition DefaultLogger'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.EmbeddedField "Logger"%go (go.PointerType log.Logger));
  (go.FieldDecl "debug"%go go.bool)
].
Program Definition DefaultLogger'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (DefaultLogger'fds_unsealed).
Global Instance equals_unfold_DefaultLogger {ext : ffi_syntax} {go_gctx : GoGlobalContext} : DefaultLogger'fds =→ DefaultLogger'fds_unsealed.
Proof. rewrite /DefaultLogger'fds seal_eq //. Qed.

Definition DefaultLoggerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (DefaultLogger'fds).

Class DefaultLogger_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] DefaultLogger_type_repr  :: go.TypeReprUnderlying DefaultLoggerⁱᵐᵖˡ DefaultLogger.t;
  #[global] DefaultLogger_underlying :: (DefaultLogger) <u (DefaultLoggerⁱᵐᵖˡ);
  #[global] DefaultLogger_get_Logger (x : DefaultLogger.t) :: ⟦StructFieldGet (DefaultLoggerⁱᵐᵖˡ) "Logger", #x⟧ ⤳[under] #x.(DefaultLogger.Logger');
  #[global] DefaultLogger_set_Logger (x : DefaultLogger.t) y :: ⟦StructFieldSet (DefaultLoggerⁱᵐᵖˡ) "Logger", (#x, #y)⟧ ⤳[under] #(x <|DefaultLogger.Logger' := y|>);
  #[global] DefaultLogger_get_debug (x : DefaultLogger.t) :: ⟦StructFieldGet (DefaultLoggerⁱᵐᵖˡ) "debug", #x⟧ ⤳[under] #x.(DefaultLogger.debug');
  #[global] DefaultLogger_set_debug (x : DefaultLogger.t) y :: ⟦StructFieldSet (DefaultLoggerⁱᵐᵖˡ) "debug", (#x, #y)⟧ ⤳[under] #(x <|DefaultLogger.debug' := y|>);
  #[global] DefaultLogger_Fatalln_unfold :: MethodUnfold (DefaultLogger) "Fatalln" (λ: "$r", MethodResolve (go.PointerType log.Logger) "Fatalln" (StructFieldGet (DefaultLogger) "Logger" "$r" ))%V;
  #[global] DefaultLogger_Flags_unfold :: MethodUnfold (DefaultLogger) "Flags" (λ: "$r", MethodResolve (go.PointerType log.Logger) "Flags" (StructFieldGet (DefaultLogger) "Logger" "$r" ))%V;
  #[global] DefaultLogger_Output_unfold :: MethodUnfold (DefaultLogger) "Output" (λ: "$r", MethodResolve (go.PointerType log.Logger) "Output" (StructFieldGet (DefaultLogger) "Logger" "$r" ))%V;
  #[global] DefaultLogger_Panicln_unfold :: MethodUnfold (DefaultLogger) "Panicln" (λ: "$r", MethodResolve (go.PointerType log.Logger) "Panicln" (StructFieldGet (DefaultLogger) "Logger" "$r" ))%V;
  #[global] DefaultLogger_Prefix_unfold :: MethodUnfold (DefaultLogger) "Prefix" (λ: "$r", MethodResolve (go.PointerType log.Logger) "Prefix" (StructFieldGet (DefaultLogger) "Logger" "$r" ))%V;
  #[global] DefaultLogger_Print_unfold :: MethodUnfold (DefaultLogger) "Print" (λ: "$r", MethodResolve (go.PointerType log.Logger) "Print" (StructFieldGet (DefaultLogger) "Logger" "$r" ))%V;
  #[global] DefaultLogger_Printf_unfold :: MethodUnfold (DefaultLogger) "Printf" (λ: "$r", MethodResolve (go.PointerType log.Logger) "Printf" (StructFieldGet (DefaultLogger) "Logger" "$r" ))%V;
  #[global] DefaultLogger_Println_unfold :: MethodUnfold (DefaultLogger) "Println" (λ: "$r", MethodResolve (go.PointerType log.Logger) "Println" (StructFieldGet (DefaultLogger) "Logger" "$r" ))%V;
  #[global] DefaultLogger_SetFlags_unfold :: MethodUnfold (DefaultLogger) "SetFlags" (λ: "$r", MethodResolve (go.PointerType log.Logger) "SetFlags" (StructFieldGet (DefaultLogger) "Logger" "$r" ))%V;
  #[global] DefaultLogger_SetOutput_unfold :: MethodUnfold (DefaultLogger) "SetOutput" (λ: "$r", MethodResolve (go.PointerType log.Logger) "SetOutput" (StructFieldGet (DefaultLogger) "Logger" "$r" ))%V;
  #[global] DefaultLogger_SetPrefix_unfold :: MethodUnfold (DefaultLogger) "SetPrefix" (λ: "$r", MethodResolve (go.PointerType log.Logger) "SetPrefix" (StructFieldGet (DefaultLogger) "Logger" "$r" ))%V;
  #[global] DefaultLogger_Writer_unfold :: MethodUnfold (DefaultLogger) "Writer" (λ: "$r", MethodResolve (go.PointerType log.Logger) "Writer" (StructFieldGet (DefaultLogger) "Logger" "$r" ))%V;
  #[global] DefaultLogger_output_unfold :: MethodUnfold (DefaultLogger) "output" (λ: "$r", MethodResolve (go.PointerType log.Logger) "output" (StructFieldGet (DefaultLogger) "Logger" "$r" ))%V;
  #[global] DefaultLogger'ptr_Debug_unfold :: MethodUnfold (go.PointerType (DefaultLogger)) "Debug" (DefaultLogger__Debugⁱᵐᵖˡ);
  #[global] DefaultLogger'ptr_Debugf_unfold :: MethodUnfold (go.PointerType (DefaultLogger)) "Debugf" (DefaultLogger__Debugfⁱᵐᵖˡ);
  #[global] DefaultLogger'ptr_EnableDebug_unfold :: MethodUnfold (go.PointerType (DefaultLogger)) "EnableDebug" (DefaultLogger__EnableDebugⁱᵐᵖˡ);
  #[global] DefaultLogger'ptr_EnableTimestamps_unfold :: MethodUnfold (go.PointerType (DefaultLogger)) "EnableTimestamps" (DefaultLogger__EnableTimestampsⁱᵐᵖˡ);
  #[global] DefaultLogger'ptr_Error_unfold :: MethodUnfold (go.PointerType (DefaultLogger)) "Error" (DefaultLogger__Errorⁱᵐᵖˡ);
  #[global] DefaultLogger'ptr_Errorf_unfold :: MethodUnfold (go.PointerType (DefaultLogger)) "Errorf" (DefaultLogger__Errorfⁱᵐᵖˡ);
  #[global] DefaultLogger'ptr_Fatal_unfold :: MethodUnfold (go.PointerType (DefaultLogger)) "Fatal" (DefaultLogger__Fatalⁱᵐᵖˡ);
  #[global] DefaultLogger'ptr_Fatalf_unfold :: MethodUnfold (go.PointerType (DefaultLogger)) "Fatalf" (DefaultLogger__Fatalfⁱᵐᵖˡ);
  #[global] DefaultLogger'ptr_Fatalln_unfold :: MethodUnfold (go.PointerType (DefaultLogger)) "Fatalln" (λ: "$r", MethodResolve (go.PointerType log.Logger) "Fatalln" (![go.PointerType log.Logger] (StructFieldRef DefaultLogger "Logger"%go "$r")));
  #[global] DefaultLogger'ptr_Flags_unfold :: MethodUnfold (go.PointerType (DefaultLogger)) "Flags" (λ: "$r", MethodResolve (go.PointerType log.Logger) "Flags" (![go.PointerType log.Logger] (StructFieldRef DefaultLogger "Logger"%go "$r")));
  #[global] DefaultLogger'ptr_Info_unfold :: MethodUnfold (go.PointerType (DefaultLogger)) "Info" (DefaultLogger__Infoⁱᵐᵖˡ);
  #[global] DefaultLogger'ptr_Infof_unfold :: MethodUnfold (go.PointerType (DefaultLogger)) "Infof" (DefaultLogger__Infofⁱᵐᵖˡ);
  #[global] DefaultLogger'ptr_Output_unfold :: MethodUnfold (go.PointerType (DefaultLogger)) "Output" (λ: "$r", MethodResolve (go.PointerType log.Logger) "Output" (![go.PointerType log.Logger] (StructFieldRef DefaultLogger "Logger"%go "$r")));
  #[global] DefaultLogger'ptr_Panic_unfold :: MethodUnfold (go.PointerType (DefaultLogger)) "Panic" (DefaultLogger__Panicⁱᵐᵖˡ);
  #[global] DefaultLogger'ptr_Panicf_unfold :: MethodUnfold (go.PointerType (DefaultLogger)) "Panicf" (DefaultLogger__Panicfⁱᵐᵖˡ);
  #[global] DefaultLogger'ptr_Panicln_unfold :: MethodUnfold (go.PointerType (DefaultLogger)) "Panicln" (λ: "$r", MethodResolve (go.PointerType log.Logger) "Panicln" (![go.PointerType log.Logger] (StructFieldRef DefaultLogger "Logger"%go "$r")));
  #[global] DefaultLogger'ptr_Prefix_unfold :: MethodUnfold (go.PointerType (DefaultLogger)) "Prefix" (λ: "$r", MethodResolve (go.PointerType log.Logger) "Prefix" (![go.PointerType log.Logger] (StructFieldRef DefaultLogger "Logger"%go "$r")));
  #[global] DefaultLogger'ptr_Print_unfold :: MethodUnfold (go.PointerType (DefaultLogger)) "Print" (λ: "$r", MethodResolve (go.PointerType log.Logger) "Print" (![go.PointerType log.Logger] (StructFieldRef DefaultLogger "Logger"%go "$r")));
  #[global] DefaultLogger'ptr_Printf_unfold :: MethodUnfold (go.PointerType (DefaultLogger)) "Printf" (λ: "$r", MethodResolve (go.PointerType log.Logger) "Printf" (![go.PointerType log.Logger] (StructFieldRef DefaultLogger "Logger"%go "$r")));
  #[global] DefaultLogger'ptr_Println_unfold :: MethodUnfold (go.PointerType (DefaultLogger)) "Println" (λ: "$r", MethodResolve (go.PointerType log.Logger) "Println" (![go.PointerType log.Logger] (StructFieldRef DefaultLogger "Logger"%go "$r")));
  #[global] DefaultLogger'ptr_SetFlags_unfold :: MethodUnfold (go.PointerType (DefaultLogger)) "SetFlags" (λ: "$r", MethodResolve (go.PointerType log.Logger) "SetFlags" (![go.PointerType log.Logger] (StructFieldRef DefaultLogger "Logger"%go "$r")));
  #[global] DefaultLogger'ptr_SetOutput_unfold :: MethodUnfold (go.PointerType (DefaultLogger)) "SetOutput" (λ: "$r", MethodResolve (go.PointerType log.Logger) "SetOutput" (![go.PointerType log.Logger] (StructFieldRef DefaultLogger "Logger"%go "$r")));
  #[global] DefaultLogger'ptr_SetPrefix_unfold :: MethodUnfold (go.PointerType (DefaultLogger)) "SetPrefix" (λ: "$r", MethodResolve (go.PointerType log.Logger) "SetPrefix" (![go.PointerType log.Logger] (StructFieldRef DefaultLogger "Logger"%go "$r")));
  #[global] DefaultLogger'ptr_Warning_unfold :: MethodUnfold (go.PointerType (DefaultLogger)) "Warning" (DefaultLogger__Warningⁱᵐᵖˡ);
  #[global] DefaultLogger'ptr_Warningf_unfold :: MethodUnfold (go.PointerType (DefaultLogger)) "Warningf" (DefaultLogger__Warningfⁱᵐᵖˡ);
  #[global] DefaultLogger'ptr_Writer_unfold :: MethodUnfold (go.PointerType (DefaultLogger)) "Writer" (λ: "$r", MethodResolve (go.PointerType log.Logger) "Writer" (![go.PointerType log.Logger] (StructFieldRef DefaultLogger "Logger"%go "$r")));
  #[global] DefaultLogger'ptr_output_unfold :: MethodUnfold (go.PointerType (DefaultLogger)) "output" (λ: "$r", MethodResolve (go.PointerType log.Logger) "output" (![go.PointerType log.Logger] (StructFieldRef DefaultLogger "Logger"%go "$r")));
}.

Module SnapshotStatus.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := w64.
End def.
End SnapshotStatus.

Definition SnapshotStatusⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.int.

Class SnapshotStatus_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] SnapshotStatus_underlying :: (SnapshotStatus) <u (SnapshotStatusⁱᵐᵖˡ);
}.

Module StateType.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := w64.
End def.
End StateType.

Definition StateTypeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.uint64.

Class StateType_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] StateType_underlying :: (StateType) <u (StateTypeⁱᵐᵖˡ);
  #[global] StateType_MarshalJSON_unfold :: MethodUnfold (StateType) "MarshalJSON" (StateType__MarshalJSONⁱᵐᵖˡ);
  #[global] StateType_String_unfold :: MethodUnfold (StateType) "String" (StateType__Stringⁱᵐᵖˡ);
  #[global] StateType'ptr_MarshalJSON_unfold :: MethodUnfold (go.PointerType (StateType)) "MarshalJSON" (λ: "$r", MethodResolve (StateType) "MarshalJSON" (![(StateType)] "$r"));
  #[global] StateType'ptr_String_unfold :: MethodUnfold (go.PointerType (StateType)) "String" (λ: "$r", MethodResolve (StateType) "String" (![(StateType)] "$r"));
}.

Module SoftState.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  Lead' : w64;
  RaftState' : raft.StateType.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End SoftState.

Definition SoftState'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "Lead"%go go.uint64);
  (go.FieldDecl "RaftState"%go StateType)
].
Program Definition SoftState'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (SoftState'fds_unsealed).
Global Instance equals_unfold_SoftState {ext : ffi_syntax} {go_gctx : GoGlobalContext} : SoftState'fds =→ SoftState'fds_unsealed.
Proof. rewrite /SoftState'fds seal_eq //. Qed.

Definition SoftStateⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (SoftState'fds).

Class SoftState_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] SoftState_type_repr  :: go.TypeReprUnderlying SoftStateⁱᵐᵖˡ SoftState.t;
  #[global] SoftState_underlying :: (SoftState) <u (SoftStateⁱᵐᵖˡ);
  #[global] SoftState_get_Lead (x : SoftState.t) :: ⟦StructFieldGet (SoftStateⁱᵐᵖˡ) "Lead", #x⟧ ⤳[under] #x.(SoftState.Lead');
  #[global] SoftState_set_Lead (x : SoftState.t) y :: ⟦StructFieldSet (SoftStateⁱᵐᵖˡ) "Lead", (#x, #y)⟧ ⤳[under] #(x <|SoftState.Lead' := y|>);
  #[global] SoftState_get_RaftState (x : SoftState.t) :: ⟦StructFieldGet (SoftStateⁱᵐᵖˡ) "RaftState", #x⟧ ⤳[under] #x.(SoftState.RaftState');
  #[global] SoftState_set_RaftState (x : SoftState.t) y :: ⟦StructFieldSet (SoftStateⁱᵐᵖˡ) "RaftState", (#x, #y)⟧ ⤳[under] #(x <|SoftState.RaftState' := y|>);
  #[global] SoftState'ptr_equal_unfold :: MethodUnfold (go.PointerType (SoftState)) "equal" (SoftState__equalⁱᵐᵖˡ);
}.

Module Ready.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  SoftState' : loc;
  HardState' : raftpb.HardState.t;
  ReadStates' : slice.t;
  Entries' : slice.t;
  Snapshot' : raftpb.Snapshot.t;
  CommittedEntries' : slice.t;
  Messages' : slice.t;
  MustSync' : bool;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End Ready.

Definition Ready'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.EmbeddedField "SoftState"%go (go.PointerType SoftState));
  (go.EmbeddedField "HardState"%go raftpb.HardState);
  (go.FieldDecl "ReadStates"%go (go.SliceType ReadState));
  (go.FieldDecl "Entries"%go (go.SliceType raftpb.Entry));
  (go.FieldDecl "Snapshot"%go raftpb.Snapshot);
  (go.FieldDecl "CommittedEntries"%go (go.SliceType raftpb.Entry));
  (go.FieldDecl "Messages"%go (go.SliceType raftpb.Message));
  (go.FieldDecl "MustSync"%go go.bool)
].
Program Definition Ready'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (Ready'fds_unsealed).
Global Instance equals_unfold_Ready {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Ready'fds =→ Ready'fds_unsealed.
Proof. rewrite /Ready'fds seal_eq //. Qed.

Definition Readyⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (Ready'fds).

Class Ready_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Ready_type_repr  :: go.TypeReprUnderlying Readyⁱᵐᵖˡ Ready.t;
  #[global] Ready_underlying :: (Ready) <u (Readyⁱᵐᵖˡ);
  #[global] Ready_get_SoftState (x : Ready.t) :: ⟦StructFieldGet (Readyⁱᵐᵖˡ) "SoftState", #x⟧ ⤳[under] #x.(Ready.SoftState');
  #[global] Ready_set_SoftState (x : Ready.t) y :: ⟦StructFieldSet (Readyⁱᵐᵖˡ) "SoftState", (#x, #y)⟧ ⤳[under] #(x <|Ready.SoftState' := y|>);
  #[global] Ready_get_HardState (x : Ready.t) :: ⟦StructFieldGet (Readyⁱᵐᵖˡ) "HardState", #x⟧ ⤳[under] #x.(Ready.HardState');
  #[global] Ready_set_HardState (x : Ready.t) y :: ⟦StructFieldSet (Readyⁱᵐᵖˡ) "HardState", (#x, #y)⟧ ⤳[under] #(x <|Ready.HardState' := y|>);
  #[global] Ready_get_ReadStates (x : Ready.t) :: ⟦StructFieldGet (Readyⁱᵐᵖˡ) "ReadStates", #x⟧ ⤳[under] #x.(Ready.ReadStates');
  #[global] Ready_set_ReadStates (x : Ready.t) y :: ⟦StructFieldSet (Readyⁱᵐᵖˡ) "ReadStates", (#x, #y)⟧ ⤳[under] #(x <|Ready.ReadStates' := y|>);
  #[global] Ready_get_Entries (x : Ready.t) :: ⟦StructFieldGet (Readyⁱᵐᵖˡ) "Entries", #x⟧ ⤳[under] #x.(Ready.Entries');
  #[global] Ready_set_Entries (x : Ready.t) y :: ⟦StructFieldSet (Readyⁱᵐᵖˡ) "Entries", (#x, #y)⟧ ⤳[under] #(x <|Ready.Entries' := y|>);
  #[global] Ready_get_Snapshot (x : Ready.t) :: ⟦StructFieldGet (Readyⁱᵐᵖˡ) "Snapshot", #x⟧ ⤳[under] #x.(Ready.Snapshot');
  #[global] Ready_set_Snapshot (x : Ready.t) y :: ⟦StructFieldSet (Readyⁱᵐᵖˡ) "Snapshot", (#x, #y)⟧ ⤳[under] #(x <|Ready.Snapshot' := y|>);
  #[global] Ready_get_CommittedEntries (x : Ready.t) :: ⟦StructFieldGet (Readyⁱᵐᵖˡ) "CommittedEntries", #x⟧ ⤳[under] #x.(Ready.CommittedEntries');
  #[global] Ready_set_CommittedEntries (x : Ready.t) y :: ⟦StructFieldSet (Readyⁱᵐᵖˡ) "CommittedEntries", (#x, #y)⟧ ⤳[under] #(x <|Ready.CommittedEntries' := y|>);
  #[global] Ready_get_Messages (x : Ready.t) :: ⟦StructFieldGet (Readyⁱᵐᵖˡ) "Messages", #x⟧ ⤳[under] #x.(Ready.Messages');
  #[global] Ready_set_Messages (x : Ready.t) y :: ⟦StructFieldSet (Readyⁱᵐᵖˡ) "Messages", (#x, #y)⟧ ⤳[under] #(x <|Ready.Messages' := y|>);
  #[global] Ready_get_MustSync (x : Ready.t) :: ⟦StructFieldGet (Readyⁱᵐᵖˡ) "MustSync", #x⟧ ⤳[under] #x.(Ready.MustSync');
  #[global] Ready_set_MustSync (x : Ready.t) y :: ⟦StructFieldSet (Readyⁱᵐᵖˡ) "MustSync", (#x, #y)⟧ ⤳[under] #(x <|Ready.MustSync' := y|>);
  #[global] Ready_equal_unfold :: MethodUnfold (Ready) "equal" (λ: "$r", MethodResolve (go.PointerType SoftState) "equal" (StructFieldGet (Ready) "SoftState" "$r" ))%V;
  #[global] Ready'ptr_Descriptor_unfold :: MethodUnfold (go.PointerType (Ready)) "Descriptor" (λ: "$r", MethodResolve (go.PointerType raftpb.HardState) "Descriptor" (StructFieldRef Ready "HardState"%go "$r"));
  #[global] Ready'ptr_Marshal_unfold :: MethodUnfold (go.PointerType (Ready)) "Marshal" (λ: "$r", MethodResolve (go.PointerType raftpb.HardState) "Marshal" (StructFieldRef Ready "HardState"%go "$r"));
  #[global] Ready'ptr_MarshalTo_unfold :: MethodUnfold (go.PointerType (Ready)) "MarshalTo" (λ: "$r", MethodResolve (go.PointerType raftpb.HardState) "MarshalTo" (StructFieldRef Ready "HardState"%go "$r"));
  #[global] Ready'ptr_MarshalToSizedBuffer_unfold :: MethodUnfold (go.PointerType (Ready)) "MarshalToSizedBuffer" (λ: "$r", MethodResolve (go.PointerType raftpb.HardState) "MarshalToSizedBuffer" (StructFieldRef Ready "HardState"%go "$r"));
  #[global] Ready'ptr_ProtoMessage_unfold :: MethodUnfold (go.PointerType (Ready)) "ProtoMessage" (λ: "$r", MethodResolve (go.PointerType raftpb.HardState) "ProtoMessage" (StructFieldRef Ready "HardState"%go "$r"));
  #[global] Ready'ptr_Reset_unfold :: MethodUnfold (go.PointerType (Ready)) "Reset" (λ: "$r", MethodResolve (go.PointerType raftpb.HardState) "Reset" (StructFieldRef Ready "HardState"%go "$r"));
  #[global] Ready'ptr_Size_unfold :: MethodUnfold (go.PointerType (Ready)) "Size" (λ: "$r", MethodResolve (go.PointerType raftpb.HardState) "Size" (StructFieldRef Ready "HardState"%go "$r"));
  #[global] Ready'ptr_String_unfold :: MethodUnfold (go.PointerType (Ready)) "String" (λ: "$r", MethodResolve (go.PointerType raftpb.HardState) "String" (StructFieldRef Ready "HardState"%go "$r"));
  #[global] Ready'ptr_Unmarshal_unfold :: MethodUnfold (go.PointerType (Ready)) "Unmarshal" (λ: "$r", MethodResolve (go.PointerType raftpb.HardState) "Unmarshal" (StructFieldRef Ready "HardState"%go "$r"));
  #[global] Ready'ptr_XXX_DiscardUnknown_unfold :: MethodUnfold (go.PointerType (Ready)) "XXX_DiscardUnknown" (λ: "$r", MethodResolve (go.PointerType raftpb.HardState) "XXX_DiscardUnknown" (StructFieldRef Ready "HardState"%go "$r"));
  #[global] Ready'ptr_XXX_Marshal_unfold :: MethodUnfold (go.PointerType (Ready)) "XXX_Marshal" (λ: "$r", MethodResolve (go.PointerType raftpb.HardState) "XXX_Marshal" (StructFieldRef Ready "HardState"%go "$r"));
  #[global] Ready'ptr_XXX_Merge_unfold :: MethodUnfold (go.PointerType (Ready)) "XXX_Merge" (λ: "$r", MethodResolve (go.PointerType raftpb.HardState) "XXX_Merge" (StructFieldRef Ready "HardState"%go "$r"));
  #[global] Ready'ptr_XXX_Size_unfold :: MethodUnfold (go.PointerType (Ready)) "XXX_Size" (λ: "$r", MethodResolve (go.PointerType raftpb.HardState) "XXX_Size" (StructFieldRef Ready "HardState"%go "$r"));
  #[global] Ready'ptr_XXX_Unmarshal_unfold :: MethodUnfold (go.PointerType (Ready)) "XXX_Unmarshal" (λ: "$r", MethodResolve (go.PointerType raftpb.HardState) "XXX_Unmarshal" (StructFieldRef Ready "HardState"%go "$r"));
  #[global] Ready'ptr_equal_unfold :: MethodUnfold (go.PointerType (Ready)) "equal" (λ: "$r", MethodResolve (go.PointerType SoftState) "equal" (![go.PointerType SoftState] (StructFieldRef Ready "SoftState"%go "$r")));
}.

Module Node.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := interface.t.
End def.
End Node.

Definition Nodeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.InterfaceType [go.MethodElem "Advance"%go (go.Signature [] false []); go.MethodElem "ApplyConfChange"%go (go.Signature [raftpb.ConfChangeI] false [go.PointerType raftpb.ConfState]); go.MethodElem "Campaign"%go (go.Signature [context.Context] false [go.error]); go.MethodElem "ForgetLeader"%go (go.Signature [context.Context] false [go.error]); go.MethodElem "Propose"%go (go.Signature [context.Context; go.SliceType go.byte] false [go.error]); go.MethodElem "ProposeConfChange"%go (go.Signature [context.Context; raftpb.ConfChangeI] false [go.error]); go.MethodElem "ReadIndex"%go (go.Signature [context.Context; go.SliceType go.byte] false [go.error]); go.MethodElem "Ready"%go (go.Signature [] false [go.ChannelType go.recvonly Ready]); go.MethodElem "ReportSnapshot"%go (go.Signature [go.uint64; SnapshotStatus] false []); go.MethodElem "ReportUnreachable"%go (go.Signature [go.uint64] false []); go.MethodElem "Status"%go (go.Signature [] false [Status]); go.MethodElem "Step"%go (go.Signature [context.Context; raftpb.Message] false [go.error]); go.MethodElem "Stop"%go (go.Signature [] false []); go.MethodElem "Tick"%go (go.Signature [] false []); go.MethodElem "TransferLeadership"%go (go.Signature [context.Context; go.uint64; go.uint64] false [])].

Class Node_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Node_underlying :: (Node) <u (Nodeⁱᵐᵖˡ);
}.

Module Peer.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  ID' : w64;
  Context' : slice.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End Peer.

Definition Peer'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "ID"%go go.uint64);
  (go.FieldDecl "Context"%go (go.SliceType go.byte))
].
Program Definition Peer'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (Peer'fds_unsealed).
Global Instance equals_unfold_Peer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Peer'fds =→ Peer'fds_unsealed.
Proof. rewrite /Peer'fds seal_eq //. Qed.

Definition Peerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (Peer'fds).

Class Peer_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Peer_type_repr  :: go.TypeReprUnderlying Peerⁱᵐᵖˡ Peer.t;
  #[global] Peer_underlying :: (Peer) <u (Peerⁱᵐᵖˡ);
  #[global] Peer_get_ID (x : Peer.t) :: ⟦StructFieldGet (Peerⁱᵐᵖˡ) "ID", #x⟧ ⤳[under] #x.(Peer.ID');
  #[global] Peer_set_ID (x : Peer.t) y :: ⟦StructFieldSet (Peerⁱᵐᵖˡ) "ID", (#x, #y)⟧ ⤳[under] #(x <|Peer.ID' := y|>);
  #[global] Peer_get_Context (x : Peer.t) :: ⟦StructFieldGet (Peerⁱᵐᵖˡ) "Context", #x⟧ ⤳[under] #x.(Peer.Context');
  #[global] Peer_set_Context (x : Peer.t) y :: ⟦StructFieldSet (Peerⁱᵐᵖˡ) "Context", (#x, #y)⟧ ⤳[under] #(x <|Peer.Context' := y|>);
}.

Module msgWithResult.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  m' : raftpb.Message.t;
  result' : loc;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End msgWithResult.

Definition msgWithResult'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "m"%go raftpb.Message);
  (go.FieldDecl "result"%go (go.ChannelType go.sendrecv go.error))
].
Program Definition msgWithResult'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (msgWithResult'fds_unsealed).
Global Instance equals_unfold_msgWithResult {ext : ffi_syntax} {go_gctx : GoGlobalContext} : msgWithResult'fds =→ msgWithResult'fds_unsealed.
Proof. rewrite /msgWithResult'fds seal_eq //. Qed.

Definition msgWithResultⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (msgWithResult'fds).

Class msgWithResult_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] msgWithResult_type_repr  :: go.TypeReprUnderlying msgWithResultⁱᵐᵖˡ msgWithResult.t;
  #[global] msgWithResult_underlying :: (msgWithResult) <u (msgWithResultⁱᵐᵖˡ);
  #[global] msgWithResult_get_m (x : msgWithResult.t) :: ⟦StructFieldGet (msgWithResultⁱᵐᵖˡ) "m", #x⟧ ⤳[under] #x.(msgWithResult.m');
  #[global] msgWithResult_set_m (x : msgWithResult.t) y :: ⟦StructFieldSet (msgWithResultⁱᵐᵖˡ) "m", (#x, #y)⟧ ⤳[under] #(x <|msgWithResult.m' := y|>);
  #[global] msgWithResult_get_result (x : msgWithResult.t) :: ⟦StructFieldGet (msgWithResultⁱᵐᵖˡ) "result", #x⟧ ⤳[under] #x.(msgWithResult.result');
  #[global] msgWithResult_set_result (x : msgWithResult.t) y :: ⟦StructFieldSet (msgWithResultⁱᵐᵖˡ) "result", (#x, #y)⟧ ⤳[under] #(x <|msgWithResult.result' := y|>);
}.

Module node.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  propc' : loc;
  recvc' : loc;
  confc' : loc;
  confstatec' : loc;
  readyc' : loc;
  advancec' : loc;
  tickc' : loc;
  done' : loc;
  stop' : loc;
  status' : loc;
  rn' : loc;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End node.

Definition node'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "propc"%go (go.ChannelType go.sendrecv msgWithResult));
  (go.FieldDecl "recvc"%go (go.ChannelType go.sendrecv raftpb.Message));
  (go.FieldDecl "confc"%go (go.ChannelType go.sendrecv raftpb.ConfChangeV2));
  (go.FieldDecl "confstatec"%go (go.ChannelType go.sendrecv raftpb.ConfState));
  (go.FieldDecl "readyc"%go (go.ChannelType go.sendrecv Ready));
  (go.FieldDecl "advancec"%go (go.ChannelType go.sendrecv (go.StructType [

  ])));
  (go.FieldDecl "tickc"%go (go.ChannelType go.sendrecv (go.StructType [

  ])));
  (go.FieldDecl "done"%go (go.ChannelType go.sendrecv (go.StructType [

  ])));
  (go.FieldDecl "stop"%go (go.ChannelType go.sendrecv (go.StructType [

  ])));
  (go.FieldDecl "status"%go (go.ChannelType go.sendrecv (go.ChannelType go.sendrecv Status)));
  (go.FieldDecl "rn"%go (go.PointerType RawNode))
].
Program Definition node'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (node'fds_unsealed).
Global Instance equals_unfold_node {ext : ffi_syntax} {go_gctx : GoGlobalContext} : node'fds =→ node'fds_unsealed.
Proof. rewrite /node'fds seal_eq //. Qed.

Definition nodeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (node'fds).

Class node_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] node_type_repr  :: go.TypeReprUnderlying nodeⁱᵐᵖˡ node.t;
  #[global] node_underlying :: (node) <u (nodeⁱᵐᵖˡ);
  #[global] node_get_propc (x : node.t) :: ⟦StructFieldGet (nodeⁱᵐᵖˡ) "propc", #x⟧ ⤳[under] #x.(node.propc');
  #[global] node_set_propc (x : node.t) y :: ⟦StructFieldSet (nodeⁱᵐᵖˡ) "propc", (#x, #y)⟧ ⤳[under] #(x <|node.propc' := y|>);
  #[global] node_get_recvc (x : node.t) :: ⟦StructFieldGet (nodeⁱᵐᵖˡ) "recvc", #x⟧ ⤳[under] #x.(node.recvc');
  #[global] node_set_recvc (x : node.t) y :: ⟦StructFieldSet (nodeⁱᵐᵖˡ) "recvc", (#x, #y)⟧ ⤳[under] #(x <|node.recvc' := y|>);
  #[global] node_get_confc (x : node.t) :: ⟦StructFieldGet (nodeⁱᵐᵖˡ) "confc", #x⟧ ⤳[under] #x.(node.confc');
  #[global] node_set_confc (x : node.t) y :: ⟦StructFieldSet (nodeⁱᵐᵖˡ) "confc", (#x, #y)⟧ ⤳[under] #(x <|node.confc' := y|>);
  #[global] node_get_confstatec (x : node.t) :: ⟦StructFieldGet (nodeⁱᵐᵖˡ) "confstatec", #x⟧ ⤳[under] #x.(node.confstatec');
  #[global] node_set_confstatec (x : node.t) y :: ⟦StructFieldSet (nodeⁱᵐᵖˡ) "confstatec", (#x, #y)⟧ ⤳[under] #(x <|node.confstatec' := y|>);
  #[global] node_get_readyc (x : node.t) :: ⟦StructFieldGet (nodeⁱᵐᵖˡ) "readyc", #x⟧ ⤳[under] #x.(node.readyc');
  #[global] node_set_readyc (x : node.t) y :: ⟦StructFieldSet (nodeⁱᵐᵖˡ) "readyc", (#x, #y)⟧ ⤳[under] #(x <|node.readyc' := y|>);
  #[global] node_get_advancec (x : node.t) :: ⟦StructFieldGet (nodeⁱᵐᵖˡ) "advancec", #x⟧ ⤳[under] #x.(node.advancec');
  #[global] node_set_advancec (x : node.t) y :: ⟦StructFieldSet (nodeⁱᵐᵖˡ) "advancec", (#x, #y)⟧ ⤳[under] #(x <|node.advancec' := y|>);
  #[global] node_get_tickc (x : node.t) :: ⟦StructFieldGet (nodeⁱᵐᵖˡ) "tickc", #x⟧ ⤳[under] #x.(node.tickc');
  #[global] node_set_tickc (x : node.t) y :: ⟦StructFieldSet (nodeⁱᵐᵖˡ) "tickc", (#x, #y)⟧ ⤳[under] #(x <|node.tickc' := y|>);
  #[global] node_get_done (x : node.t) :: ⟦StructFieldGet (nodeⁱᵐᵖˡ) "done", #x⟧ ⤳[under] #x.(node.done');
  #[global] node_set_done (x : node.t) y :: ⟦StructFieldSet (nodeⁱᵐᵖˡ) "done", (#x, #y)⟧ ⤳[under] #(x <|node.done' := y|>);
  #[global] node_get_stop (x : node.t) :: ⟦StructFieldGet (nodeⁱᵐᵖˡ) "stop", #x⟧ ⤳[under] #x.(node.stop');
  #[global] node_set_stop (x : node.t) y :: ⟦StructFieldSet (nodeⁱᵐᵖˡ) "stop", (#x, #y)⟧ ⤳[under] #(x <|node.stop' := y|>);
  #[global] node_get_status (x : node.t) :: ⟦StructFieldGet (nodeⁱᵐᵖˡ) "status", #x⟧ ⤳[under] #x.(node.status');
  #[global] node_set_status (x : node.t) y :: ⟦StructFieldSet (nodeⁱᵐᵖˡ) "status", (#x, #y)⟧ ⤳[under] #(x <|node.status' := y|>);
  #[global] node_get_rn (x : node.t) :: ⟦StructFieldGet (nodeⁱᵐᵖˡ) "rn", #x⟧ ⤳[under] #x.(node.rn');
  #[global] node_set_rn (x : node.t) y :: ⟦StructFieldSet (nodeⁱᵐᵖˡ) "rn", (#x, #y)⟧ ⤳[under] #(x <|node.rn' := y|>);
  #[global] node'ptr_Advance_unfold :: MethodUnfold (go.PointerType (node)) "Advance" (node__Advanceⁱᵐᵖˡ);
  #[global] node'ptr_ApplyConfChange_unfold :: MethodUnfold (go.PointerType (node)) "ApplyConfChange" (node__ApplyConfChangeⁱᵐᵖˡ);
  #[global] node'ptr_Campaign_unfold :: MethodUnfold (go.PointerType (node)) "Campaign" (node__Campaignⁱᵐᵖˡ);
  #[global] node'ptr_ForgetLeader_unfold :: MethodUnfold (go.PointerType (node)) "ForgetLeader" (node__ForgetLeaderⁱᵐᵖˡ);
  #[global] node'ptr_Propose_unfold :: MethodUnfold (go.PointerType (node)) "Propose" (node__Proposeⁱᵐᵖˡ);
  #[global] node'ptr_ProposeConfChange_unfold :: MethodUnfold (go.PointerType (node)) "ProposeConfChange" (node__ProposeConfChangeⁱᵐᵖˡ);
  #[global] node'ptr_ReadIndex_unfold :: MethodUnfold (go.PointerType (node)) "ReadIndex" (node__ReadIndexⁱᵐᵖˡ);
  #[global] node'ptr_Ready_unfold :: MethodUnfold (go.PointerType (node)) "Ready" (node__Readyⁱᵐᵖˡ);
  #[global] node'ptr_ReportSnapshot_unfold :: MethodUnfold (go.PointerType (node)) "ReportSnapshot" (node__ReportSnapshotⁱᵐᵖˡ);
  #[global] node'ptr_ReportUnreachable_unfold :: MethodUnfold (go.PointerType (node)) "ReportUnreachable" (node__ReportUnreachableⁱᵐᵖˡ);
  #[global] node'ptr_Status_unfold :: MethodUnfold (go.PointerType (node)) "Status" (node__Statusⁱᵐᵖˡ);
  #[global] node'ptr_Step_unfold :: MethodUnfold (go.PointerType (node)) "Step" (node__Stepⁱᵐᵖˡ);
  #[global] node'ptr_Stop_unfold :: MethodUnfold (go.PointerType (node)) "Stop" (node__Stopⁱᵐᵖˡ);
  #[global] node'ptr_Tick_unfold :: MethodUnfold (go.PointerType (node)) "Tick" (node__Tickⁱᵐᵖˡ);
  #[global] node'ptr_TransferLeadership_unfold :: MethodUnfold (go.PointerType (node)) "TransferLeadership" (node__TransferLeadershipⁱᵐᵖˡ);
  #[global] node'ptr_run_unfold :: MethodUnfold (go.PointerType (node)) "run" (node__runⁱᵐᵖˡ);
  #[global] node'ptr_step_unfold :: MethodUnfold (go.PointerType (node)) "step" (node__stepⁱᵐᵖˡ);
  #[global] node'ptr_stepWait_unfold :: MethodUnfold (go.PointerType (node)) "stepWait" (node__stepWaitⁱᵐᵖˡ);
  #[global] node'ptr_stepWithWaitOption_unfold :: MethodUnfold (go.PointerType (node)) "stepWithWaitOption" (node__stepWithWaitOptionⁱᵐᵖˡ);
}.

Module ReadOnlyOption.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := w64.
End def.
End ReadOnlyOption.

Definition ReadOnlyOptionⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.int.

Class ReadOnlyOption_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] ReadOnlyOption_underlying :: (ReadOnlyOption) <u (ReadOnlyOptionⁱᵐᵖˡ);
}.

Module lockedRand.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  mu' : sync.Mutex.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End lockedRand.

Definition lockedRand'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "mu"%go sync.Mutex)
].
Program Definition lockedRand'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (lockedRand'fds_unsealed).
Global Instance equals_unfold_lockedRand {ext : ffi_syntax} {go_gctx : GoGlobalContext} : lockedRand'fds =→ lockedRand'fds_unsealed.
Proof. rewrite /lockedRand'fds seal_eq //. Qed.

Definition lockedRandⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (lockedRand'fds).

Class lockedRand_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] lockedRand_type_repr  :: go.TypeReprUnderlying lockedRandⁱᵐᵖˡ lockedRand.t;
  #[global] lockedRand_underlying :: (lockedRand) <u (lockedRandⁱᵐᵖˡ);
  #[global] lockedRand_get_mu (x : lockedRand.t) :: ⟦StructFieldGet (lockedRandⁱᵐᵖˡ) "mu", #x⟧ ⤳[under] #x.(lockedRand.mu');
  #[global] lockedRand_set_mu (x : lockedRand.t) y :: ⟦StructFieldSet (lockedRandⁱᵐᵖˡ) "mu", (#x, #y)⟧ ⤳[under] #(x <|lockedRand.mu' := y|>);
  #[global] lockedRand'ptr_Intn_unfold :: MethodUnfold (go.PointerType (lockedRand)) "Intn" (lockedRand__Intnⁱᵐᵖˡ);
}.

Module CampaignType.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := go_string.
End def.
End CampaignType.

Definition CampaignTypeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.string.

Class CampaignType_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] CampaignType_underlying :: (CampaignType) <u (CampaignTypeⁱᵐᵖˡ);
}.

Module TraceLogger.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := interface.t.
End def.
End TraceLogger.

Definition TraceLoggerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.InterfaceType [].

Class TraceLogger_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] TraceLogger_underlying :: (TraceLogger) <u (TraceLoggerⁱᵐᵖˡ);
}.

Module Config.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  ID' : w64;
  ElectionTick' : w64;
  HeartbeatTick' : w64;
  Storage' : raft.Storage.t;
  Applied' : w64;
  AsyncStorageWrites' : bool;
  MaxSizePerMsg' : w64;
  MaxCommittedSizePerReady' : w64;
  MaxUncommittedEntriesSize' : w64;
  MaxInflightMsgs' : w64;
  MaxInflightBytes' : w64;
  CheckQuorum' : bool;
  PreVote' : bool;
  ReadOnlyOption' : raft.ReadOnlyOption.t;
  Logger' : raft.Logger.t;
  DisableProposalForwarding' : bool;
  DisableConfChangeValidation' : bool;
  StepDownOnRemoval' : bool;
  TraceLogger' : raft.TraceLogger.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End Config.

Definition Config'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "ID"%go go.uint64);
  (go.FieldDecl "ElectionTick"%go go.int);
  (go.FieldDecl "HeartbeatTick"%go go.int);
  (go.FieldDecl "Storage"%go Storage);
  (go.FieldDecl "Applied"%go go.uint64);
  (go.FieldDecl "AsyncStorageWrites"%go go.bool);
  (go.FieldDecl "MaxSizePerMsg"%go go.uint64);
  (go.FieldDecl "MaxCommittedSizePerReady"%go go.uint64);
  (go.FieldDecl "MaxUncommittedEntriesSize"%go go.uint64);
  (go.FieldDecl "MaxInflightMsgs"%go go.int);
  (go.FieldDecl "MaxInflightBytes"%go go.uint64);
  (go.FieldDecl "CheckQuorum"%go go.bool);
  (go.FieldDecl "PreVote"%go go.bool);
  (go.FieldDecl "ReadOnlyOption"%go ReadOnlyOption);
  (go.FieldDecl "Logger"%go Logger);
  (go.FieldDecl "DisableProposalForwarding"%go go.bool);
  (go.FieldDecl "DisableConfChangeValidation"%go go.bool);
  (go.FieldDecl "StepDownOnRemoval"%go go.bool);
  (go.FieldDecl "TraceLogger"%go TraceLogger)
].
Program Definition Config'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (Config'fds_unsealed).
Global Instance equals_unfold_Config {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Config'fds =→ Config'fds_unsealed.
Proof. rewrite /Config'fds seal_eq //. Qed.

Definition Configⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (Config'fds).

Class Config_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Config_type_repr  :: go.TypeReprUnderlying Configⁱᵐᵖˡ Config.t;
  #[global] Config_underlying :: (Config) <u (Configⁱᵐᵖˡ);
  #[global] Config_get_ID (x : Config.t) :: ⟦StructFieldGet (Configⁱᵐᵖˡ) "ID", #x⟧ ⤳[under] #x.(Config.ID');
  #[global] Config_set_ID (x : Config.t) y :: ⟦StructFieldSet (Configⁱᵐᵖˡ) "ID", (#x, #y)⟧ ⤳[under] #(x <|Config.ID' := y|>);
  #[global] Config_get_ElectionTick (x : Config.t) :: ⟦StructFieldGet (Configⁱᵐᵖˡ) "ElectionTick", #x⟧ ⤳[under] #x.(Config.ElectionTick');
  #[global] Config_set_ElectionTick (x : Config.t) y :: ⟦StructFieldSet (Configⁱᵐᵖˡ) "ElectionTick", (#x, #y)⟧ ⤳[under] #(x <|Config.ElectionTick' := y|>);
  #[global] Config_get_HeartbeatTick (x : Config.t) :: ⟦StructFieldGet (Configⁱᵐᵖˡ) "HeartbeatTick", #x⟧ ⤳[under] #x.(Config.HeartbeatTick');
  #[global] Config_set_HeartbeatTick (x : Config.t) y :: ⟦StructFieldSet (Configⁱᵐᵖˡ) "HeartbeatTick", (#x, #y)⟧ ⤳[under] #(x <|Config.HeartbeatTick' := y|>);
  #[global] Config_get_Storage (x : Config.t) :: ⟦StructFieldGet (Configⁱᵐᵖˡ) "Storage", #x⟧ ⤳[under] #x.(Config.Storage');
  #[global] Config_set_Storage (x : Config.t) y :: ⟦StructFieldSet (Configⁱᵐᵖˡ) "Storage", (#x, #y)⟧ ⤳[under] #(x <|Config.Storage' := y|>);
  #[global] Config_get_Applied (x : Config.t) :: ⟦StructFieldGet (Configⁱᵐᵖˡ) "Applied", #x⟧ ⤳[under] #x.(Config.Applied');
  #[global] Config_set_Applied (x : Config.t) y :: ⟦StructFieldSet (Configⁱᵐᵖˡ) "Applied", (#x, #y)⟧ ⤳[under] #(x <|Config.Applied' := y|>);
  #[global] Config_get_AsyncStorageWrites (x : Config.t) :: ⟦StructFieldGet (Configⁱᵐᵖˡ) "AsyncStorageWrites", #x⟧ ⤳[under] #x.(Config.AsyncStorageWrites');
  #[global] Config_set_AsyncStorageWrites (x : Config.t) y :: ⟦StructFieldSet (Configⁱᵐᵖˡ) "AsyncStorageWrites", (#x, #y)⟧ ⤳[under] #(x <|Config.AsyncStorageWrites' := y|>);
  #[global] Config_get_MaxSizePerMsg (x : Config.t) :: ⟦StructFieldGet (Configⁱᵐᵖˡ) "MaxSizePerMsg", #x⟧ ⤳[under] #x.(Config.MaxSizePerMsg');
  #[global] Config_set_MaxSizePerMsg (x : Config.t) y :: ⟦StructFieldSet (Configⁱᵐᵖˡ) "MaxSizePerMsg", (#x, #y)⟧ ⤳[under] #(x <|Config.MaxSizePerMsg' := y|>);
  #[global] Config_get_MaxCommittedSizePerReady (x : Config.t) :: ⟦StructFieldGet (Configⁱᵐᵖˡ) "MaxCommittedSizePerReady", #x⟧ ⤳[under] #x.(Config.MaxCommittedSizePerReady');
  #[global] Config_set_MaxCommittedSizePerReady (x : Config.t) y :: ⟦StructFieldSet (Configⁱᵐᵖˡ) "MaxCommittedSizePerReady", (#x, #y)⟧ ⤳[under] #(x <|Config.MaxCommittedSizePerReady' := y|>);
  #[global] Config_get_MaxUncommittedEntriesSize (x : Config.t) :: ⟦StructFieldGet (Configⁱᵐᵖˡ) "MaxUncommittedEntriesSize", #x⟧ ⤳[under] #x.(Config.MaxUncommittedEntriesSize');
  #[global] Config_set_MaxUncommittedEntriesSize (x : Config.t) y :: ⟦StructFieldSet (Configⁱᵐᵖˡ) "MaxUncommittedEntriesSize", (#x, #y)⟧ ⤳[under] #(x <|Config.MaxUncommittedEntriesSize' := y|>);
  #[global] Config_get_MaxInflightMsgs (x : Config.t) :: ⟦StructFieldGet (Configⁱᵐᵖˡ) "MaxInflightMsgs", #x⟧ ⤳[under] #x.(Config.MaxInflightMsgs');
  #[global] Config_set_MaxInflightMsgs (x : Config.t) y :: ⟦StructFieldSet (Configⁱᵐᵖˡ) "MaxInflightMsgs", (#x, #y)⟧ ⤳[under] #(x <|Config.MaxInflightMsgs' := y|>);
  #[global] Config_get_MaxInflightBytes (x : Config.t) :: ⟦StructFieldGet (Configⁱᵐᵖˡ) "MaxInflightBytes", #x⟧ ⤳[under] #x.(Config.MaxInflightBytes');
  #[global] Config_set_MaxInflightBytes (x : Config.t) y :: ⟦StructFieldSet (Configⁱᵐᵖˡ) "MaxInflightBytes", (#x, #y)⟧ ⤳[under] #(x <|Config.MaxInflightBytes' := y|>);
  #[global] Config_get_CheckQuorum (x : Config.t) :: ⟦StructFieldGet (Configⁱᵐᵖˡ) "CheckQuorum", #x⟧ ⤳[under] #x.(Config.CheckQuorum');
  #[global] Config_set_CheckQuorum (x : Config.t) y :: ⟦StructFieldSet (Configⁱᵐᵖˡ) "CheckQuorum", (#x, #y)⟧ ⤳[under] #(x <|Config.CheckQuorum' := y|>);
  #[global] Config_get_PreVote (x : Config.t) :: ⟦StructFieldGet (Configⁱᵐᵖˡ) "PreVote", #x⟧ ⤳[under] #x.(Config.PreVote');
  #[global] Config_set_PreVote (x : Config.t) y :: ⟦StructFieldSet (Configⁱᵐᵖˡ) "PreVote", (#x, #y)⟧ ⤳[under] #(x <|Config.PreVote' := y|>);
  #[global] Config_get_ReadOnlyOption (x : Config.t) :: ⟦StructFieldGet (Configⁱᵐᵖˡ) "ReadOnlyOption", #x⟧ ⤳[under] #x.(Config.ReadOnlyOption');
  #[global] Config_set_ReadOnlyOption (x : Config.t) y :: ⟦StructFieldSet (Configⁱᵐᵖˡ) "ReadOnlyOption", (#x, #y)⟧ ⤳[under] #(x <|Config.ReadOnlyOption' := y|>);
  #[global] Config_get_Logger (x : Config.t) :: ⟦StructFieldGet (Configⁱᵐᵖˡ) "Logger", #x⟧ ⤳[under] #x.(Config.Logger');
  #[global] Config_set_Logger (x : Config.t) y :: ⟦StructFieldSet (Configⁱᵐᵖˡ) "Logger", (#x, #y)⟧ ⤳[under] #(x <|Config.Logger' := y|>);
  #[global] Config_get_DisableProposalForwarding (x : Config.t) :: ⟦StructFieldGet (Configⁱᵐᵖˡ) "DisableProposalForwarding", #x⟧ ⤳[under] #x.(Config.DisableProposalForwarding');
  #[global] Config_set_DisableProposalForwarding (x : Config.t) y :: ⟦StructFieldSet (Configⁱᵐᵖˡ) "DisableProposalForwarding", (#x, #y)⟧ ⤳[under] #(x <|Config.DisableProposalForwarding' := y|>);
  #[global] Config_get_DisableConfChangeValidation (x : Config.t) :: ⟦StructFieldGet (Configⁱᵐᵖˡ) "DisableConfChangeValidation", #x⟧ ⤳[under] #x.(Config.DisableConfChangeValidation');
  #[global] Config_set_DisableConfChangeValidation (x : Config.t) y :: ⟦StructFieldSet (Configⁱᵐᵖˡ) "DisableConfChangeValidation", (#x, #y)⟧ ⤳[under] #(x <|Config.DisableConfChangeValidation' := y|>);
  #[global] Config_get_StepDownOnRemoval (x : Config.t) :: ⟦StructFieldGet (Configⁱᵐᵖˡ) "StepDownOnRemoval", #x⟧ ⤳[under] #x.(Config.StepDownOnRemoval');
  #[global] Config_set_StepDownOnRemoval (x : Config.t) y :: ⟦StructFieldSet (Configⁱᵐᵖˡ) "StepDownOnRemoval", (#x, #y)⟧ ⤳[under] #(x <|Config.StepDownOnRemoval' := y|>);
  #[global] Config_get_TraceLogger (x : Config.t) :: ⟦StructFieldGet (Configⁱᵐᵖˡ) "TraceLogger", #x⟧ ⤳[under] #x.(Config.TraceLogger');
  #[global] Config_set_TraceLogger (x : Config.t) y :: ⟦StructFieldSet (Configⁱᵐᵖˡ) "TraceLogger", (#x, #y)⟧ ⤳[under] #(x <|Config.TraceLogger' := y|>);
  #[global] Config'ptr_validate_unfold :: MethodUnfold (go.PointerType (Config)) "validate" (Config__validateⁱᵐᵖˡ);
}.

Module entryPayloadSize.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := w64.
End def.
End entryPayloadSize.

Definition entryPayloadSizeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.uint64.

Class entryPayloadSize_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] entryPayloadSize_underlying :: (entryPayloadSize) <u (entryPayloadSizeⁱᵐᵖˡ);
}.

Module stepFunc.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := func.t.
End def.
End stepFunc.

Definition stepFuncⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.FunctionType (go.Signature [go.PointerType raft; raftpb.Message] false [go.error]).

Class stepFunc_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] stepFunc_underlying :: (stepFunc) <u (stepFuncⁱᵐᵖˡ);
}.

Module raft.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  id' : w64;
  Term' : w64;
  Vote' : w64;
  readStates' : slice.t;
  raftLog' : loc;
  maxMsgSize' : raft.entryEncodingSize.t;
  maxUncommittedSize' : raft.entryPayloadSize.t;
  trk' : tracker.ProgressTracker.t;
  state' : raft.StateType.t;
  isLearner' : bool;
  msgs' : slice.t;
  msgsAfterAppend' : slice.t;
  lead' : w64;
  leadTransferee' : w64;
  pendingConfIndex' : w64;
  disableConfChangeValidation' : bool;
  uncommittedSize' : raft.entryPayloadSize.t;
  readOnly' : loc;
  electionElapsed' : w64;
  heartbeatElapsed' : w64;
  checkQuorum' : bool;
  preVote' : bool;
  heartbeatTimeout' : w64;
  electionTimeout' : w64;
  randomizedElectionTimeout' : w64;
  disableProposalForwarding' : bool;
  stepDownOnRemoval' : bool;
  tick' : func.t;
  step' : raft.stepFunc.t;
  logger' : raft.Logger.t;
  pendingReadIndexMessages' : slice.t;
  traceLogger' : raft.TraceLogger.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End raft.

Definition raft'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "id"%go go.uint64);
  (go.FieldDecl "Term"%go go.uint64);
  (go.FieldDecl "Vote"%go go.uint64);
  (go.FieldDecl "readStates"%go (go.SliceType ReadState));
  (go.FieldDecl "raftLog"%go (go.PointerType raftLog));
  (go.FieldDecl "maxMsgSize"%go entryEncodingSize);
  (go.FieldDecl "maxUncommittedSize"%go entryPayloadSize);
  (go.FieldDecl "trk"%go tracker.ProgressTracker);
  (go.FieldDecl "state"%go StateType);
  (go.FieldDecl "isLearner"%go go.bool);
  (go.FieldDecl "msgs"%go (go.SliceType raftpb.Message));
  (go.FieldDecl "msgsAfterAppend"%go (go.SliceType raftpb.Message));
  (go.FieldDecl "lead"%go go.uint64);
  (go.FieldDecl "leadTransferee"%go go.uint64);
  (go.FieldDecl "pendingConfIndex"%go go.uint64);
  (go.FieldDecl "disableConfChangeValidation"%go go.bool);
  (go.FieldDecl "uncommittedSize"%go entryPayloadSize);
  (go.FieldDecl "readOnly"%go (go.PointerType readOnly));
  (go.FieldDecl "electionElapsed"%go go.int);
  (go.FieldDecl "heartbeatElapsed"%go go.int);
  (go.FieldDecl "checkQuorum"%go go.bool);
  (go.FieldDecl "preVote"%go go.bool);
  (go.FieldDecl "heartbeatTimeout"%go go.int);
  (go.FieldDecl "electionTimeout"%go go.int);
  (go.FieldDecl "randomizedElectionTimeout"%go go.int);
  (go.FieldDecl "disableProposalForwarding"%go go.bool);
  (go.FieldDecl "stepDownOnRemoval"%go go.bool);
  (go.FieldDecl "tick"%go (go.FunctionType (go.Signature [] false [])));
  (go.FieldDecl "step"%go stepFunc);
  (go.FieldDecl "logger"%go Logger);
  (go.FieldDecl "pendingReadIndexMessages"%go (go.SliceType raftpb.Message));
  (go.FieldDecl "traceLogger"%go TraceLogger)
].
Program Definition raft'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (raft'fds_unsealed).
Global Instance equals_unfold_raft {ext : ffi_syntax} {go_gctx : GoGlobalContext} : raft'fds =→ raft'fds_unsealed.
Proof. rewrite /raft'fds seal_eq //. Qed.

Definition raftⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (raft'fds).

Class raft_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] raft_type_repr  :: go.TypeReprUnderlying raftⁱᵐᵖˡ raft.t;
  #[global] raft_underlying :: (raft) <u (raftⁱᵐᵖˡ);
  #[global] raft_get_id (x : raft.t) :: ⟦StructFieldGet (raftⁱᵐᵖˡ) "id", #x⟧ ⤳[under] #x.(raft.id');
  #[global] raft_set_id (x : raft.t) y :: ⟦StructFieldSet (raftⁱᵐᵖˡ) "id", (#x, #y)⟧ ⤳[under] #(x <|raft.id' := y|>);
  #[global] raft_get_Term (x : raft.t) :: ⟦StructFieldGet (raftⁱᵐᵖˡ) "Term", #x⟧ ⤳[under] #x.(raft.Term');
  #[global] raft_set_Term (x : raft.t) y :: ⟦StructFieldSet (raftⁱᵐᵖˡ) "Term", (#x, #y)⟧ ⤳[under] #(x <|raft.Term' := y|>);
  #[global] raft_get_Vote (x : raft.t) :: ⟦StructFieldGet (raftⁱᵐᵖˡ) "Vote", #x⟧ ⤳[under] #x.(raft.Vote');
  #[global] raft_set_Vote (x : raft.t) y :: ⟦StructFieldSet (raftⁱᵐᵖˡ) "Vote", (#x, #y)⟧ ⤳[under] #(x <|raft.Vote' := y|>);
  #[global] raft_get_readStates (x : raft.t) :: ⟦StructFieldGet (raftⁱᵐᵖˡ) "readStates", #x⟧ ⤳[under] #x.(raft.readStates');
  #[global] raft_set_readStates (x : raft.t) y :: ⟦StructFieldSet (raftⁱᵐᵖˡ) "readStates", (#x, #y)⟧ ⤳[under] #(x <|raft.readStates' := y|>);
  #[global] raft_get_raftLog (x : raft.t) :: ⟦StructFieldGet (raftⁱᵐᵖˡ) "raftLog", #x⟧ ⤳[under] #x.(raft.raftLog');
  #[global] raft_set_raftLog (x : raft.t) y :: ⟦StructFieldSet (raftⁱᵐᵖˡ) "raftLog", (#x, #y)⟧ ⤳[under] #(x <|raft.raftLog' := y|>);
  #[global] raft_get_maxMsgSize (x : raft.t) :: ⟦StructFieldGet (raftⁱᵐᵖˡ) "maxMsgSize", #x⟧ ⤳[under] #x.(raft.maxMsgSize');
  #[global] raft_set_maxMsgSize (x : raft.t) y :: ⟦StructFieldSet (raftⁱᵐᵖˡ) "maxMsgSize", (#x, #y)⟧ ⤳[under] #(x <|raft.maxMsgSize' := y|>);
  #[global] raft_get_maxUncommittedSize (x : raft.t) :: ⟦StructFieldGet (raftⁱᵐᵖˡ) "maxUncommittedSize", #x⟧ ⤳[under] #x.(raft.maxUncommittedSize');
  #[global] raft_set_maxUncommittedSize (x : raft.t) y :: ⟦StructFieldSet (raftⁱᵐᵖˡ) "maxUncommittedSize", (#x, #y)⟧ ⤳[under] #(x <|raft.maxUncommittedSize' := y|>);
  #[global] raft_get_trk (x : raft.t) :: ⟦StructFieldGet (raftⁱᵐᵖˡ) "trk", #x⟧ ⤳[under] #x.(raft.trk');
  #[global] raft_set_trk (x : raft.t) y :: ⟦StructFieldSet (raftⁱᵐᵖˡ) "trk", (#x, #y)⟧ ⤳[under] #(x <|raft.trk' := y|>);
  #[global] raft_get_state (x : raft.t) :: ⟦StructFieldGet (raftⁱᵐᵖˡ) "state", #x⟧ ⤳[under] #x.(raft.state');
  #[global] raft_set_state (x : raft.t) y :: ⟦StructFieldSet (raftⁱᵐᵖˡ) "state", (#x, #y)⟧ ⤳[under] #(x <|raft.state' := y|>);
  #[global] raft_get_isLearner (x : raft.t) :: ⟦StructFieldGet (raftⁱᵐᵖˡ) "isLearner", #x⟧ ⤳[under] #x.(raft.isLearner');
  #[global] raft_set_isLearner (x : raft.t) y :: ⟦StructFieldSet (raftⁱᵐᵖˡ) "isLearner", (#x, #y)⟧ ⤳[under] #(x <|raft.isLearner' := y|>);
  #[global] raft_get_msgs (x : raft.t) :: ⟦StructFieldGet (raftⁱᵐᵖˡ) "msgs", #x⟧ ⤳[under] #x.(raft.msgs');
  #[global] raft_set_msgs (x : raft.t) y :: ⟦StructFieldSet (raftⁱᵐᵖˡ) "msgs", (#x, #y)⟧ ⤳[under] #(x <|raft.msgs' := y|>);
  #[global] raft_get_msgsAfterAppend (x : raft.t) :: ⟦StructFieldGet (raftⁱᵐᵖˡ) "msgsAfterAppend", #x⟧ ⤳[under] #x.(raft.msgsAfterAppend');
  #[global] raft_set_msgsAfterAppend (x : raft.t) y :: ⟦StructFieldSet (raftⁱᵐᵖˡ) "msgsAfterAppend", (#x, #y)⟧ ⤳[under] #(x <|raft.msgsAfterAppend' := y|>);
  #[global] raft_get_lead (x : raft.t) :: ⟦StructFieldGet (raftⁱᵐᵖˡ) "lead", #x⟧ ⤳[under] #x.(raft.lead');
  #[global] raft_set_lead (x : raft.t) y :: ⟦StructFieldSet (raftⁱᵐᵖˡ) "lead", (#x, #y)⟧ ⤳[under] #(x <|raft.lead' := y|>);
  #[global] raft_get_leadTransferee (x : raft.t) :: ⟦StructFieldGet (raftⁱᵐᵖˡ) "leadTransferee", #x⟧ ⤳[under] #x.(raft.leadTransferee');
  #[global] raft_set_leadTransferee (x : raft.t) y :: ⟦StructFieldSet (raftⁱᵐᵖˡ) "leadTransferee", (#x, #y)⟧ ⤳[under] #(x <|raft.leadTransferee' := y|>);
  #[global] raft_get_pendingConfIndex (x : raft.t) :: ⟦StructFieldGet (raftⁱᵐᵖˡ) "pendingConfIndex", #x⟧ ⤳[under] #x.(raft.pendingConfIndex');
  #[global] raft_set_pendingConfIndex (x : raft.t) y :: ⟦StructFieldSet (raftⁱᵐᵖˡ) "pendingConfIndex", (#x, #y)⟧ ⤳[under] #(x <|raft.pendingConfIndex' := y|>);
  #[global] raft_get_disableConfChangeValidation (x : raft.t) :: ⟦StructFieldGet (raftⁱᵐᵖˡ) "disableConfChangeValidation", #x⟧ ⤳[under] #x.(raft.disableConfChangeValidation');
  #[global] raft_set_disableConfChangeValidation (x : raft.t) y :: ⟦StructFieldSet (raftⁱᵐᵖˡ) "disableConfChangeValidation", (#x, #y)⟧ ⤳[under] #(x <|raft.disableConfChangeValidation' := y|>);
  #[global] raft_get_uncommittedSize (x : raft.t) :: ⟦StructFieldGet (raftⁱᵐᵖˡ) "uncommittedSize", #x⟧ ⤳[under] #x.(raft.uncommittedSize');
  #[global] raft_set_uncommittedSize (x : raft.t) y :: ⟦StructFieldSet (raftⁱᵐᵖˡ) "uncommittedSize", (#x, #y)⟧ ⤳[under] #(x <|raft.uncommittedSize' := y|>);
  #[global] raft_get_readOnly (x : raft.t) :: ⟦StructFieldGet (raftⁱᵐᵖˡ) "readOnly", #x⟧ ⤳[under] #x.(raft.readOnly');
  #[global] raft_set_readOnly (x : raft.t) y :: ⟦StructFieldSet (raftⁱᵐᵖˡ) "readOnly", (#x, #y)⟧ ⤳[under] #(x <|raft.readOnly' := y|>);
  #[global] raft_get_electionElapsed (x : raft.t) :: ⟦StructFieldGet (raftⁱᵐᵖˡ) "electionElapsed", #x⟧ ⤳[under] #x.(raft.electionElapsed');
  #[global] raft_set_electionElapsed (x : raft.t) y :: ⟦StructFieldSet (raftⁱᵐᵖˡ) "electionElapsed", (#x, #y)⟧ ⤳[under] #(x <|raft.electionElapsed' := y|>);
  #[global] raft_get_heartbeatElapsed (x : raft.t) :: ⟦StructFieldGet (raftⁱᵐᵖˡ) "heartbeatElapsed", #x⟧ ⤳[under] #x.(raft.heartbeatElapsed');
  #[global] raft_set_heartbeatElapsed (x : raft.t) y :: ⟦StructFieldSet (raftⁱᵐᵖˡ) "heartbeatElapsed", (#x, #y)⟧ ⤳[under] #(x <|raft.heartbeatElapsed' := y|>);
  #[global] raft_get_checkQuorum (x : raft.t) :: ⟦StructFieldGet (raftⁱᵐᵖˡ) "checkQuorum", #x⟧ ⤳[under] #x.(raft.checkQuorum');
  #[global] raft_set_checkQuorum (x : raft.t) y :: ⟦StructFieldSet (raftⁱᵐᵖˡ) "checkQuorum", (#x, #y)⟧ ⤳[under] #(x <|raft.checkQuorum' := y|>);
  #[global] raft_get_preVote (x : raft.t) :: ⟦StructFieldGet (raftⁱᵐᵖˡ) "preVote", #x⟧ ⤳[under] #x.(raft.preVote');
  #[global] raft_set_preVote (x : raft.t) y :: ⟦StructFieldSet (raftⁱᵐᵖˡ) "preVote", (#x, #y)⟧ ⤳[under] #(x <|raft.preVote' := y|>);
  #[global] raft_get_heartbeatTimeout (x : raft.t) :: ⟦StructFieldGet (raftⁱᵐᵖˡ) "heartbeatTimeout", #x⟧ ⤳[under] #x.(raft.heartbeatTimeout');
  #[global] raft_set_heartbeatTimeout (x : raft.t) y :: ⟦StructFieldSet (raftⁱᵐᵖˡ) "heartbeatTimeout", (#x, #y)⟧ ⤳[under] #(x <|raft.heartbeatTimeout' := y|>);
  #[global] raft_get_electionTimeout (x : raft.t) :: ⟦StructFieldGet (raftⁱᵐᵖˡ) "electionTimeout", #x⟧ ⤳[under] #x.(raft.electionTimeout');
  #[global] raft_set_electionTimeout (x : raft.t) y :: ⟦StructFieldSet (raftⁱᵐᵖˡ) "electionTimeout", (#x, #y)⟧ ⤳[under] #(x <|raft.electionTimeout' := y|>);
  #[global] raft_get_randomizedElectionTimeout (x : raft.t) :: ⟦StructFieldGet (raftⁱᵐᵖˡ) "randomizedElectionTimeout", #x⟧ ⤳[under] #x.(raft.randomizedElectionTimeout');
  #[global] raft_set_randomizedElectionTimeout (x : raft.t) y :: ⟦StructFieldSet (raftⁱᵐᵖˡ) "randomizedElectionTimeout", (#x, #y)⟧ ⤳[under] #(x <|raft.randomizedElectionTimeout' := y|>);
  #[global] raft_get_disableProposalForwarding (x : raft.t) :: ⟦StructFieldGet (raftⁱᵐᵖˡ) "disableProposalForwarding", #x⟧ ⤳[under] #x.(raft.disableProposalForwarding');
  #[global] raft_set_disableProposalForwarding (x : raft.t) y :: ⟦StructFieldSet (raftⁱᵐᵖˡ) "disableProposalForwarding", (#x, #y)⟧ ⤳[under] #(x <|raft.disableProposalForwarding' := y|>);
  #[global] raft_get_stepDownOnRemoval (x : raft.t) :: ⟦StructFieldGet (raftⁱᵐᵖˡ) "stepDownOnRemoval", #x⟧ ⤳[under] #x.(raft.stepDownOnRemoval');
  #[global] raft_set_stepDownOnRemoval (x : raft.t) y :: ⟦StructFieldSet (raftⁱᵐᵖˡ) "stepDownOnRemoval", (#x, #y)⟧ ⤳[under] #(x <|raft.stepDownOnRemoval' := y|>);
  #[global] raft_get_tick (x : raft.t) :: ⟦StructFieldGet (raftⁱᵐᵖˡ) "tick", #x⟧ ⤳[under] #x.(raft.tick');
  #[global] raft_set_tick (x : raft.t) y :: ⟦StructFieldSet (raftⁱᵐᵖˡ) "tick", (#x, #y)⟧ ⤳[under] #(x <|raft.tick' := y|>);
  #[global] raft_get_step (x : raft.t) :: ⟦StructFieldGet (raftⁱᵐᵖˡ) "step", #x⟧ ⤳[under] #x.(raft.step');
  #[global] raft_set_step (x : raft.t) y :: ⟦StructFieldSet (raftⁱᵐᵖˡ) "step", (#x, #y)⟧ ⤳[under] #(x <|raft.step' := y|>);
  #[global] raft_get_logger (x : raft.t) :: ⟦StructFieldGet (raftⁱᵐᵖˡ) "logger", #x⟧ ⤳[under] #x.(raft.logger');
  #[global] raft_set_logger (x : raft.t) y :: ⟦StructFieldSet (raftⁱᵐᵖˡ) "logger", (#x, #y)⟧ ⤳[under] #(x <|raft.logger' := y|>);
  #[global] raft_get_pendingReadIndexMessages (x : raft.t) :: ⟦StructFieldGet (raftⁱᵐᵖˡ) "pendingReadIndexMessages", #x⟧ ⤳[under] #x.(raft.pendingReadIndexMessages');
  #[global] raft_set_pendingReadIndexMessages (x : raft.t) y :: ⟦StructFieldSet (raftⁱᵐᵖˡ) "pendingReadIndexMessages", (#x, #y)⟧ ⤳[under] #(x <|raft.pendingReadIndexMessages' := y|>);
  #[global] raft_get_traceLogger (x : raft.t) :: ⟦StructFieldGet (raftⁱᵐᵖˡ) "traceLogger", #x⟧ ⤳[under] #x.(raft.traceLogger');
  #[global] raft_set_traceLogger (x : raft.t) y :: ⟦StructFieldSet (raftⁱᵐᵖˡ) "traceLogger", (#x, #y)⟧ ⤳[under] #(x <|raft.traceLogger' := y|>);
  #[global] raft'ptr_Step_unfold :: MethodUnfold (go.PointerType (raft)) "Step" (raft__Stepⁱᵐᵖˡ);
  #[global] raft'ptr_abortLeaderTransfer_unfold :: MethodUnfold (go.PointerType (raft)) "abortLeaderTransfer" (raft__abortLeaderTransferⁱᵐᵖˡ);
  #[global] raft'ptr_appendEntry_unfold :: MethodUnfold (go.PointerType (raft)) "appendEntry" (raft__appendEntryⁱᵐᵖˡ);
  #[global] raft'ptr_appliedSnap_unfold :: MethodUnfold (go.PointerType (raft)) "appliedSnap" (raft__appliedSnapⁱᵐᵖˡ);
  #[global] raft'ptr_appliedTo_unfold :: MethodUnfold (go.PointerType (raft)) "appliedTo" (raft__appliedToⁱᵐᵖˡ);
  #[global] raft'ptr_applyConfChange_unfold :: MethodUnfold (go.PointerType (raft)) "applyConfChange" (raft__applyConfChangeⁱᵐᵖˡ);
  #[global] raft'ptr_bcastAppend_unfold :: MethodUnfold (go.PointerType (raft)) "bcastAppend" (raft__bcastAppendⁱᵐᵖˡ);
  #[global] raft'ptr_bcastHeartbeat_unfold :: MethodUnfold (go.PointerType (raft)) "bcastHeartbeat" (raft__bcastHeartbeatⁱᵐᵖˡ);
  #[global] raft'ptr_bcastHeartbeatWithCtx_unfold :: MethodUnfold (go.PointerType (raft)) "bcastHeartbeatWithCtx" (raft__bcastHeartbeatWithCtxⁱᵐᵖˡ);
  #[global] raft'ptr_becomeCandidate_unfold :: MethodUnfold (go.PointerType (raft)) "becomeCandidate" (raft__becomeCandidateⁱᵐᵖˡ);
  #[global] raft'ptr_becomeFollower_unfold :: MethodUnfold (go.PointerType (raft)) "becomeFollower" (raft__becomeFollowerⁱᵐᵖˡ);
  #[global] raft'ptr_becomeLeader_unfold :: MethodUnfold (go.PointerType (raft)) "becomeLeader" (raft__becomeLeaderⁱᵐᵖˡ);
  #[global] raft'ptr_becomePreCandidate_unfold :: MethodUnfold (go.PointerType (raft)) "becomePreCandidate" (raft__becomePreCandidateⁱᵐᵖˡ);
  #[global] raft'ptr_campaign_unfold :: MethodUnfold (go.PointerType (raft)) "campaign" (raft__campaignⁱᵐᵖˡ);
  #[global] raft'ptr_committedEntryInCurrentTerm_unfold :: MethodUnfold (go.PointerType (raft)) "committedEntryInCurrentTerm" (raft__committedEntryInCurrentTermⁱᵐᵖˡ);
  #[global] raft'ptr_handleAppendEntries_unfold :: MethodUnfold (go.PointerType (raft)) "handleAppendEntries" (raft__handleAppendEntriesⁱᵐᵖˡ);
  #[global] raft'ptr_handleHeartbeat_unfold :: MethodUnfold (go.PointerType (raft)) "handleHeartbeat" (raft__handleHeartbeatⁱᵐᵖˡ);
  #[global] raft'ptr_handleSnapshot_unfold :: MethodUnfold (go.PointerType (raft)) "handleSnapshot" (raft__handleSnapshotⁱᵐᵖˡ);
  #[global] raft'ptr_hardState_unfold :: MethodUnfold (go.PointerType (raft)) "hardState" (raft__hardStateⁱᵐᵖˡ);
  #[global] raft'ptr_hasLeader_unfold :: MethodUnfold (go.PointerType (raft)) "hasLeader" (raft__hasLeaderⁱᵐᵖˡ);
  #[global] raft'ptr_hasUnappliedConfChanges_unfold :: MethodUnfold (go.PointerType (raft)) "hasUnappliedConfChanges" (raft__hasUnappliedConfChangesⁱᵐᵖˡ);
  #[global] raft'ptr_hup_unfold :: MethodUnfold (go.PointerType (raft)) "hup" (raft__hupⁱᵐᵖˡ);
  #[global] raft'ptr_increaseUncommittedSize_unfold :: MethodUnfold (go.PointerType (raft)) "increaseUncommittedSize" (raft__increaseUncommittedSizeⁱᵐᵖˡ);
  #[global] raft'ptr_loadState_unfold :: MethodUnfold (go.PointerType (raft)) "loadState" (raft__loadStateⁱᵐᵖˡ);
  #[global] raft'ptr_maybeCommit_unfold :: MethodUnfold (go.PointerType (raft)) "maybeCommit" (raft__maybeCommitⁱᵐᵖˡ);
  #[global] raft'ptr_maybeSendAppend_unfold :: MethodUnfold (go.PointerType (raft)) "maybeSendAppend" (raft__maybeSendAppendⁱᵐᵖˡ);
  #[global] raft'ptr_maybeSendSnapshot_unfold :: MethodUnfold (go.PointerType (raft)) "maybeSendSnapshot" (raft__maybeSendSnapshotⁱᵐᵖˡ);
  #[global] raft'ptr_pastElectionTimeout_unfold :: MethodUnfold (go.PointerType (raft)) "pastElectionTimeout" (raft__pastElectionTimeoutⁱᵐᵖˡ);
  #[global] raft'ptr_poll_unfold :: MethodUnfold (go.PointerType (raft)) "poll" (raft__pollⁱᵐᵖˡ);
  #[global] raft'ptr_promotable_unfold :: MethodUnfold (go.PointerType (raft)) "promotable" (raft__promotableⁱᵐᵖˡ);
  #[global] raft'ptr_reduceUncommittedSize_unfold :: MethodUnfold (go.PointerType (raft)) "reduceUncommittedSize" (raft__reduceUncommittedSizeⁱᵐᵖˡ);
  #[global] raft'ptr_reset_unfold :: MethodUnfold (go.PointerType (raft)) "reset" (raft__resetⁱᵐᵖˡ);
  #[global] raft'ptr_resetRandomizedElectionTimeout_unfold :: MethodUnfold (go.PointerType (raft)) "resetRandomizedElectionTimeout" (raft__resetRandomizedElectionTimeoutⁱᵐᵖˡ);
  #[global] raft'ptr_responseToReadIndexReq_unfold :: MethodUnfold (go.PointerType (raft)) "responseToReadIndexReq" (raft__responseToReadIndexReqⁱᵐᵖˡ);
  #[global] raft'ptr_restore_unfold :: MethodUnfold (go.PointerType (raft)) "restore" (raft__restoreⁱᵐᵖˡ);
  #[global] raft'ptr_send_unfold :: MethodUnfold (go.PointerType (raft)) "send" (raft__sendⁱᵐᵖˡ);
  #[global] raft'ptr_sendAppend_unfold :: MethodUnfold (go.PointerType (raft)) "sendAppend" (raft__sendAppendⁱᵐᵖˡ);
  #[global] raft'ptr_sendHeartbeat_unfold :: MethodUnfold (go.PointerType (raft)) "sendHeartbeat" (raft__sendHeartbeatⁱᵐᵖˡ);
  #[global] raft'ptr_sendTimeoutNow_unfold :: MethodUnfold (go.PointerType (raft)) "sendTimeoutNow" (raft__sendTimeoutNowⁱᵐᵖˡ);
  #[global] raft'ptr_softState_unfold :: MethodUnfold (go.PointerType (raft)) "softState" (raft__softStateⁱᵐᵖˡ);
  #[global] raft'ptr_switchToConfig_unfold :: MethodUnfold (go.PointerType (raft)) "switchToConfig" (raft__switchToConfigⁱᵐᵖˡ);
  #[global] raft'ptr_tickElection_unfold :: MethodUnfold (go.PointerType (raft)) "tickElection" (raft__tickElectionⁱᵐᵖˡ);
  #[global] raft'ptr_tickHeartbeat_unfold :: MethodUnfold (go.PointerType (raft)) "tickHeartbeat" (raft__tickHeartbeatⁱᵐᵖˡ);
}.

Module RawNode.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  raft' : loc;
  asyncStorageWrites' : bool;
  prevSoftSt' : loc;
  prevHardSt' : raftpb.HardState.t;
  stepsOnAdvance' : slice.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End RawNode.

Definition RawNode'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "raft"%go (go.PointerType raft));
  (go.FieldDecl "asyncStorageWrites"%go go.bool);
  (go.FieldDecl "prevSoftSt"%go (go.PointerType SoftState));
  (go.FieldDecl "prevHardSt"%go raftpb.HardState);
  (go.FieldDecl "stepsOnAdvance"%go (go.SliceType raftpb.Message))
].
Program Definition RawNode'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (RawNode'fds_unsealed).
Global Instance equals_unfold_RawNode {ext : ffi_syntax} {go_gctx : GoGlobalContext} : RawNode'fds =→ RawNode'fds_unsealed.
Proof. rewrite /RawNode'fds seal_eq //. Qed.

Definition RawNodeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (RawNode'fds).

Class RawNode_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] RawNode_type_repr  :: go.TypeReprUnderlying RawNodeⁱᵐᵖˡ RawNode.t;
  #[global] RawNode_underlying :: (RawNode) <u (RawNodeⁱᵐᵖˡ);
  #[global] RawNode_get_raft (x : RawNode.t) :: ⟦StructFieldGet (RawNodeⁱᵐᵖˡ) "raft", #x⟧ ⤳[under] #x.(RawNode.raft');
  #[global] RawNode_set_raft (x : RawNode.t) y :: ⟦StructFieldSet (RawNodeⁱᵐᵖˡ) "raft", (#x, #y)⟧ ⤳[under] #(x <|RawNode.raft' := y|>);
  #[global] RawNode_get_asyncStorageWrites (x : RawNode.t) :: ⟦StructFieldGet (RawNodeⁱᵐᵖˡ) "asyncStorageWrites", #x⟧ ⤳[under] #x.(RawNode.asyncStorageWrites');
  #[global] RawNode_set_asyncStorageWrites (x : RawNode.t) y :: ⟦StructFieldSet (RawNodeⁱᵐᵖˡ) "asyncStorageWrites", (#x, #y)⟧ ⤳[under] #(x <|RawNode.asyncStorageWrites' := y|>);
  #[global] RawNode_get_prevSoftSt (x : RawNode.t) :: ⟦StructFieldGet (RawNodeⁱᵐᵖˡ) "prevSoftSt", #x⟧ ⤳[under] #x.(RawNode.prevSoftSt');
  #[global] RawNode_set_prevSoftSt (x : RawNode.t) y :: ⟦StructFieldSet (RawNodeⁱᵐᵖˡ) "prevSoftSt", (#x, #y)⟧ ⤳[under] #(x <|RawNode.prevSoftSt' := y|>);
  #[global] RawNode_get_prevHardSt (x : RawNode.t) :: ⟦StructFieldGet (RawNodeⁱᵐᵖˡ) "prevHardSt", #x⟧ ⤳[under] #x.(RawNode.prevHardSt');
  #[global] RawNode_set_prevHardSt (x : RawNode.t) y :: ⟦StructFieldSet (RawNodeⁱᵐᵖˡ) "prevHardSt", (#x, #y)⟧ ⤳[under] #(x <|RawNode.prevHardSt' := y|>);
  #[global] RawNode_get_stepsOnAdvance (x : RawNode.t) :: ⟦StructFieldGet (RawNodeⁱᵐᵖˡ) "stepsOnAdvance", #x⟧ ⤳[under] #x.(RawNode.stepsOnAdvance');
  #[global] RawNode_set_stepsOnAdvance (x : RawNode.t) y :: ⟦StructFieldSet (RawNodeⁱᵐᵖˡ) "stepsOnAdvance", (#x, #y)⟧ ⤳[under] #(x <|RawNode.stepsOnAdvance' := y|>);
  #[global] RawNode'ptr_Advance_unfold :: MethodUnfold (go.PointerType (RawNode)) "Advance" (RawNode__Advanceⁱᵐᵖˡ);
  #[global] RawNode'ptr_ApplyConfChange_unfold :: MethodUnfold (go.PointerType (RawNode)) "ApplyConfChange" (RawNode__ApplyConfChangeⁱᵐᵖˡ);
  #[global] RawNode'ptr_BasicStatus_unfold :: MethodUnfold (go.PointerType (RawNode)) "BasicStatus" (RawNode__BasicStatusⁱᵐᵖˡ);
  #[global] RawNode'ptr_Bootstrap_unfold :: MethodUnfold (go.PointerType (RawNode)) "Bootstrap" (RawNode__Bootstrapⁱᵐᵖˡ);
  #[global] RawNode'ptr_Campaign_unfold :: MethodUnfold (go.PointerType (RawNode)) "Campaign" (RawNode__Campaignⁱᵐᵖˡ);
  #[global] RawNode'ptr_ForgetLeader_unfold :: MethodUnfold (go.PointerType (RawNode)) "ForgetLeader" (RawNode__ForgetLeaderⁱᵐᵖˡ);
  #[global] RawNode'ptr_HasReady_unfold :: MethodUnfold (go.PointerType (RawNode)) "HasReady" (RawNode__HasReadyⁱᵐᵖˡ);
  #[global] RawNode'ptr_Propose_unfold :: MethodUnfold (go.PointerType (RawNode)) "Propose" (RawNode__Proposeⁱᵐᵖˡ);
  #[global] RawNode'ptr_ProposeConfChange_unfold :: MethodUnfold (go.PointerType (RawNode)) "ProposeConfChange" (RawNode__ProposeConfChangeⁱᵐᵖˡ);
  #[global] RawNode'ptr_ReadIndex_unfold :: MethodUnfold (go.PointerType (RawNode)) "ReadIndex" (RawNode__ReadIndexⁱᵐᵖˡ);
  #[global] RawNode'ptr_Ready_unfold :: MethodUnfold (go.PointerType (RawNode)) "Ready" (RawNode__Readyⁱᵐᵖˡ);
  #[global] RawNode'ptr_ReportSnapshot_unfold :: MethodUnfold (go.PointerType (RawNode)) "ReportSnapshot" (RawNode__ReportSnapshotⁱᵐᵖˡ);
  #[global] RawNode'ptr_ReportUnreachable_unfold :: MethodUnfold (go.PointerType (RawNode)) "ReportUnreachable" (RawNode__ReportUnreachableⁱᵐᵖˡ);
  #[global] RawNode'ptr_Status_unfold :: MethodUnfold (go.PointerType (RawNode)) "Status" (RawNode__Statusⁱᵐᵖˡ);
  #[global] RawNode'ptr_Step_unfold :: MethodUnfold (go.PointerType (RawNode)) "Step" (RawNode__Stepⁱᵐᵖˡ);
  #[global] RawNode'ptr_Tick_unfold :: MethodUnfold (go.PointerType (RawNode)) "Tick" (RawNode__Tickⁱᵐᵖˡ);
  #[global] RawNode'ptr_TickQuiesced_unfold :: MethodUnfold (go.PointerType (RawNode)) "TickQuiesced" (RawNode__TickQuiescedⁱᵐᵖˡ);
  #[global] RawNode'ptr_TransferLeader_unfold :: MethodUnfold (go.PointerType (RawNode)) "TransferLeader" (RawNode__TransferLeaderⁱᵐᵖˡ);
  #[global] RawNode'ptr_WithProgress_unfold :: MethodUnfold (go.PointerType (RawNode)) "WithProgress" (RawNode__WithProgressⁱᵐᵖˡ);
  #[global] RawNode'ptr_acceptReady_unfold :: MethodUnfold (go.PointerType (RawNode)) "acceptReady" (RawNode__acceptReadyⁱᵐᵖˡ);
  #[global] RawNode'ptr_applyUnstableEntries_unfold :: MethodUnfold (go.PointerType (RawNode)) "applyUnstableEntries" (RawNode__applyUnstableEntriesⁱᵐᵖˡ);
  #[global] RawNode'ptr_readyWithoutAccept_unfold :: MethodUnfold (go.PointerType (RawNode)) "readyWithoutAccept" (RawNode__readyWithoutAcceptⁱᵐᵖˡ);
}.

Module ProgressType.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := w8.
End def.
End ProgressType.

Definition ProgressTypeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.byte.

Class ProgressType_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] ProgressType_underlying :: (ProgressType) <u (ProgressTypeⁱᵐᵖˡ);
}.

Module ReadState.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  Index' : w64;
  RequestCtx' : slice.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End ReadState.

Definition ReadState'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "Index"%go go.uint64);
  (go.FieldDecl "RequestCtx"%go (go.SliceType go.byte))
].
Program Definition ReadState'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (ReadState'fds_unsealed).
Global Instance equals_unfold_ReadState {ext : ffi_syntax} {go_gctx : GoGlobalContext} : ReadState'fds =→ ReadState'fds_unsealed.
Proof. rewrite /ReadState'fds seal_eq //. Qed.

Definition ReadStateⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (ReadState'fds).

Class ReadState_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] ReadState_type_repr  :: go.TypeReprUnderlying ReadStateⁱᵐᵖˡ ReadState.t;
  #[global] ReadState_underlying :: (ReadState) <u (ReadStateⁱᵐᵖˡ);
  #[global] ReadState_get_Index (x : ReadState.t) :: ⟦StructFieldGet (ReadStateⁱᵐᵖˡ) "Index", #x⟧ ⤳[under] #x.(ReadState.Index');
  #[global] ReadState_set_Index (x : ReadState.t) y :: ⟦StructFieldSet (ReadStateⁱᵐᵖˡ) "Index", (#x, #y)⟧ ⤳[under] #(x <|ReadState.Index' := y|>);
  #[global] ReadState_get_RequestCtx (x : ReadState.t) :: ⟦StructFieldGet (ReadStateⁱᵐᵖˡ) "RequestCtx", #x⟧ ⤳[under] #x.(ReadState.RequestCtx');
  #[global] ReadState_set_RequestCtx (x : ReadState.t) y :: ⟦StructFieldSet (ReadStateⁱᵐᵖˡ) "RequestCtx", (#x, #y)⟧ ⤳[under] #(x <|ReadState.RequestCtx' := y|>);
}.

Module readIndexStatus.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  req' : raftpb.Message.t;
  index' : w64;
  acks' : loc;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End readIndexStatus.

Definition readIndexStatus'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "req"%go raftpb.Message);
  (go.FieldDecl "index"%go go.uint64);
  (go.FieldDecl "acks"%go (go.MapType go.uint64 go.bool))
].
Program Definition readIndexStatus'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (readIndexStatus'fds_unsealed).
Global Instance equals_unfold_readIndexStatus {ext : ffi_syntax} {go_gctx : GoGlobalContext} : readIndexStatus'fds =→ readIndexStatus'fds_unsealed.
Proof. rewrite /readIndexStatus'fds seal_eq //. Qed.

Definition readIndexStatusⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (readIndexStatus'fds).

Class readIndexStatus_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] readIndexStatus_type_repr  :: go.TypeReprUnderlying readIndexStatusⁱᵐᵖˡ readIndexStatus.t;
  #[global] readIndexStatus_underlying :: (readIndexStatus) <u (readIndexStatusⁱᵐᵖˡ);
  #[global] readIndexStatus_get_req (x : readIndexStatus.t) :: ⟦StructFieldGet (readIndexStatusⁱᵐᵖˡ) "req", #x⟧ ⤳[under] #x.(readIndexStatus.req');
  #[global] readIndexStatus_set_req (x : readIndexStatus.t) y :: ⟦StructFieldSet (readIndexStatusⁱᵐᵖˡ) "req", (#x, #y)⟧ ⤳[under] #(x <|readIndexStatus.req' := y|>);
  #[global] readIndexStatus_get_index (x : readIndexStatus.t) :: ⟦StructFieldGet (readIndexStatusⁱᵐᵖˡ) "index", #x⟧ ⤳[under] #x.(readIndexStatus.index');
  #[global] readIndexStatus_set_index (x : readIndexStatus.t) y :: ⟦StructFieldSet (readIndexStatusⁱᵐᵖˡ) "index", (#x, #y)⟧ ⤳[under] #(x <|readIndexStatus.index' := y|>);
  #[global] readIndexStatus_get_acks (x : readIndexStatus.t) :: ⟦StructFieldGet (readIndexStatusⁱᵐᵖˡ) "acks", #x⟧ ⤳[under] #x.(readIndexStatus.acks');
  #[global] readIndexStatus_set_acks (x : readIndexStatus.t) y :: ⟦StructFieldSet (readIndexStatusⁱᵐᵖˡ) "acks", (#x, #y)⟧ ⤳[under] #(x <|readIndexStatus.acks' := y|>);
}.

Module readOnly.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  option' : raft.ReadOnlyOption.t;
  pendingReadIndex' : loc;
  readIndexQueue' : slice.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End readOnly.

Definition readOnly'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "option"%go ReadOnlyOption);
  (go.FieldDecl "pendingReadIndex"%go (go.MapType go.string (go.PointerType readIndexStatus)));
  (go.FieldDecl "readIndexQueue"%go (go.SliceType go.string))
].
Program Definition readOnly'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (readOnly'fds_unsealed).
Global Instance equals_unfold_readOnly {ext : ffi_syntax} {go_gctx : GoGlobalContext} : readOnly'fds =→ readOnly'fds_unsealed.
Proof. rewrite /readOnly'fds seal_eq //. Qed.

Definition readOnlyⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (readOnly'fds).

Class readOnly_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] readOnly_type_repr  :: go.TypeReprUnderlying readOnlyⁱᵐᵖˡ readOnly.t;
  #[global] readOnly_underlying :: (readOnly) <u (readOnlyⁱᵐᵖˡ);
  #[global] readOnly_get_option (x : readOnly.t) :: ⟦StructFieldGet (readOnlyⁱᵐᵖˡ) "option", #x⟧ ⤳[under] #x.(readOnly.option');
  #[global] readOnly_set_option (x : readOnly.t) y :: ⟦StructFieldSet (readOnlyⁱᵐᵖˡ) "option", (#x, #y)⟧ ⤳[under] #(x <|readOnly.option' := y|>);
  #[global] readOnly_get_pendingReadIndex (x : readOnly.t) :: ⟦StructFieldGet (readOnlyⁱᵐᵖˡ) "pendingReadIndex", #x⟧ ⤳[under] #x.(readOnly.pendingReadIndex');
  #[global] readOnly_set_pendingReadIndex (x : readOnly.t) y :: ⟦StructFieldSet (readOnlyⁱᵐᵖˡ) "pendingReadIndex", (#x, #y)⟧ ⤳[under] #(x <|readOnly.pendingReadIndex' := y|>);
  #[global] readOnly_get_readIndexQueue (x : readOnly.t) :: ⟦StructFieldGet (readOnlyⁱᵐᵖˡ) "readIndexQueue", #x⟧ ⤳[under] #x.(readOnly.readIndexQueue');
  #[global] readOnly_set_readIndexQueue (x : readOnly.t) y :: ⟦StructFieldSet (readOnlyⁱᵐᵖˡ) "readIndexQueue", (#x, #y)⟧ ⤳[under] #(x <|readOnly.readIndexQueue' := y|>);
  #[global] readOnly'ptr_addRequest_unfold :: MethodUnfold (go.PointerType (readOnly)) "addRequest" (readOnly__addRequestⁱᵐᵖˡ);
  #[global] readOnly'ptr_advance_unfold :: MethodUnfold (go.PointerType (readOnly)) "advance" (readOnly__advanceⁱᵐᵖˡ);
  #[global] readOnly'ptr_lastPendingRequestCtx_unfold :: MethodUnfold (go.PointerType (readOnly)) "lastPendingRequestCtx" (readOnly__lastPendingRequestCtxⁱᵐᵖˡ);
  #[global] readOnly'ptr_recvAck_unfold :: MethodUnfold (go.PointerType (readOnly)) "recvAck" (readOnly__recvAckⁱᵐᵖˡ);
}.

Module TracingEvent.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End TracingEvent.

Definition TracingEvent'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [

].
Program Definition TracingEvent'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (TracingEvent'fds_unsealed).
Global Instance equals_unfold_TracingEvent {ext : ffi_syntax} {go_gctx : GoGlobalContext} : TracingEvent'fds =→ TracingEvent'fds_unsealed.
Proof. rewrite /TracingEvent'fds seal_eq //. Qed.

Definition TracingEventⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (TracingEvent'fds).

Class TracingEvent_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] TracingEvent_type_repr  :: go.TypeReprUnderlying TracingEventⁱᵐᵖˡ TracingEvent.t;
  #[global] TracingEvent_underlying :: (TracingEvent) <u (TracingEventⁱᵐᵖˡ);
}.

Module BasicStatus.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  ID' : w64;
  HardState' : raftpb.HardState.t;
  SoftState' : raft.SoftState.t;
  Applied' : w64;
  LeadTransferee' : w64;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End BasicStatus.

Definition BasicStatus'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "ID"%go go.uint64);
  (go.EmbeddedField "HardState"%go raftpb.HardState);
  (go.EmbeddedField "SoftState"%go SoftState);
  (go.FieldDecl "Applied"%go go.uint64);
  (go.FieldDecl "LeadTransferee"%go go.uint64)
].
Program Definition BasicStatus'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (BasicStatus'fds_unsealed).
Global Instance equals_unfold_BasicStatus {ext : ffi_syntax} {go_gctx : GoGlobalContext} : BasicStatus'fds =→ BasicStatus'fds_unsealed.
Proof. rewrite /BasicStatus'fds seal_eq //. Qed.

Definition BasicStatusⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (BasicStatus'fds).

Class BasicStatus_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] BasicStatus_type_repr  :: go.TypeReprUnderlying BasicStatusⁱᵐᵖˡ BasicStatus.t;
  #[global] BasicStatus_underlying :: (BasicStatus) <u (BasicStatusⁱᵐᵖˡ);
  #[global] BasicStatus_get_ID (x : BasicStatus.t) :: ⟦StructFieldGet (BasicStatusⁱᵐᵖˡ) "ID", #x⟧ ⤳[under] #x.(BasicStatus.ID');
  #[global] BasicStatus_set_ID (x : BasicStatus.t) y :: ⟦StructFieldSet (BasicStatusⁱᵐᵖˡ) "ID", (#x, #y)⟧ ⤳[under] #(x <|BasicStatus.ID' := y|>);
  #[global] BasicStatus_get_HardState (x : BasicStatus.t) :: ⟦StructFieldGet (BasicStatusⁱᵐᵖˡ) "HardState", #x⟧ ⤳[under] #x.(BasicStatus.HardState');
  #[global] BasicStatus_set_HardState (x : BasicStatus.t) y :: ⟦StructFieldSet (BasicStatusⁱᵐᵖˡ) "HardState", (#x, #y)⟧ ⤳[under] #(x <|BasicStatus.HardState' := y|>);
  #[global] BasicStatus_get_SoftState (x : BasicStatus.t) :: ⟦StructFieldGet (BasicStatusⁱᵐᵖˡ) "SoftState", #x⟧ ⤳[under] #x.(BasicStatus.SoftState');
  #[global] BasicStatus_set_SoftState (x : BasicStatus.t) y :: ⟦StructFieldSet (BasicStatusⁱᵐᵖˡ) "SoftState", (#x, #y)⟧ ⤳[under] #(x <|BasicStatus.SoftState' := y|>);
  #[global] BasicStatus_get_Applied (x : BasicStatus.t) :: ⟦StructFieldGet (BasicStatusⁱᵐᵖˡ) "Applied", #x⟧ ⤳[under] #x.(BasicStatus.Applied');
  #[global] BasicStatus_set_Applied (x : BasicStatus.t) y :: ⟦StructFieldSet (BasicStatusⁱᵐᵖˡ) "Applied", (#x, #y)⟧ ⤳[under] #(x <|BasicStatus.Applied' := y|>);
  #[global] BasicStatus_get_LeadTransferee (x : BasicStatus.t) :: ⟦StructFieldGet (BasicStatusⁱᵐᵖˡ) "LeadTransferee", #x⟧ ⤳[under] #x.(BasicStatus.LeadTransferee');
  #[global] BasicStatus_set_LeadTransferee (x : BasicStatus.t) y :: ⟦StructFieldSet (BasicStatusⁱᵐᵖˡ) "LeadTransferee", (#x, #y)⟧ ⤳[under] #(x <|BasicStatus.LeadTransferee' := y|>);
  #[global] BasicStatus'ptr_Descriptor_unfold :: MethodUnfold (go.PointerType (BasicStatus)) "Descriptor" (λ: "$r", MethodResolve (go.PointerType raftpb.HardState) "Descriptor" (StructFieldRef BasicStatus "HardState"%go "$r"));
  #[global] BasicStatus'ptr_Marshal_unfold :: MethodUnfold (go.PointerType (BasicStatus)) "Marshal" (λ: "$r", MethodResolve (go.PointerType raftpb.HardState) "Marshal" (StructFieldRef BasicStatus "HardState"%go "$r"));
  #[global] BasicStatus'ptr_MarshalTo_unfold :: MethodUnfold (go.PointerType (BasicStatus)) "MarshalTo" (λ: "$r", MethodResolve (go.PointerType raftpb.HardState) "MarshalTo" (StructFieldRef BasicStatus "HardState"%go "$r"));
  #[global] BasicStatus'ptr_MarshalToSizedBuffer_unfold :: MethodUnfold (go.PointerType (BasicStatus)) "MarshalToSizedBuffer" (λ: "$r", MethodResolve (go.PointerType raftpb.HardState) "MarshalToSizedBuffer" (StructFieldRef BasicStatus "HardState"%go "$r"));
  #[global] BasicStatus'ptr_ProtoMessage_unfold :: MethodUnfold (go.PointerType (BasicStatus)) "ProtoMessage" (λ: "$r", MethodResolve (go.PointerType raftpb.HardState) "ProtoMessage" (StructFieldRef BasicStatus "HardState"%go "$r"));
  #[global] BasicStatus'ptr_Reset_unfold :: MethodUnfold (go.PointerType (BasicStatus)) "Reset" (λ: "$r", MethodResolve (go.PointerType raftpb.HardState) "Reset" (StructFieldRef BasicStatus "HardState"%go "$r"));
  #[global] BasicStatus'ptr_Size_unfold :: MethodUnfold (go.PointerType (BasicStatus)) "Size" (λ: "$r", MethodResolve (go.PointerType raftpb.HardState) "Size" (StructFieldRef BasicStatus "HardState"%go "$r"));
  #[global] BasicStatus'ptr_String_unfold :: MethodUnfold (go.PointerType (BasicStatus)) "String" (λ: "$r", MethodResolve (go.PointerType raftpb.HardState) "String" (StructFieldRef BasicStatus "HardState"%go "$r"));
  #[global] BasicStatus'ptr_Unmarshal_unfold :: MethodUnfold (go.PointerType (BasicStatus)) "Unmarshal" (λ: "$r", MethodResolve (go.PointerType raftpb.HardState) "Unmarshal" (StructFieldRef BasicStatus "HardState"%go "$r"));
  #[global] BasicStatus'ptr_XXX_DiscardUnknown_unfold :: MethodUnfold (go.PointerType (BasicStatus)) "XXX_DiscardUnknown" (λ: "$r", MethodResolve (go.PointerType raftpb.HardState) "XXX_DiscardUnknown" (StructFieldRef BasicStatus "HardState"%go "$r"));
  #[global] BasicStatus'ptr_XXX_Marshal_unfold :: MethodUnfold (go.PointerType (BasicStatus)) "XXX_Marshal" (λ: "$r", MethodResolve (go.PointerType raftpb.HardState) "XXX_Marshal" (StructFieldRef BasicStatus "HardState"%go "$r"));
  #[global] BasicStatus'ptr_XXX_Merge_unfold :: MethodUnfold (go.PointerType (BasicStatus)) "XXX_Merge" (λ: "$r", MethodResolve (go.PointerType raftpb.HardState) "XXX_Merge" (StructFieldRef BasicStatus "HardState"%go "$r"));
  #[global] BasicStatus'ptr_XXX_Size_unfold :: MethodUnfold (go.PointerType (BasicStatus)) "XXX_Size" (λ: "$r", MethodResolve (go.PointerType raftpb.HardState) "XXX_Size" (StructFieldRef BasicStatus "HardState"%go "$r"));
  #[global] BasicStatus'ptr_XXX_Unmarshal_unfold :: MethodUnfold (go.PointerType (BasicStatus)) "XXX_Unmarshal" (λ: "$r", MethodResolve (go.PointerType raftpb.HardState) "XXX_Unmarshal" (StructFieldRef BasicStatus "HardState"%go "$r"));
  #[global] BasicStatus'ptr_equal_unfold :: MethodUnfold (go.PointerType (BasicStatus)) "equal" (λ: "$r", MethodResolve (go.PointerType SoftState) "equal" (StructFieldRef BasicStatus "SoftState"%go "$r"));
}.

Module Status.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  BasicStatus' : raft.BasicStatus.t;
  Config' : tracker.Config.t;
  Progress' : loc;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End Status.

Definition Status'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.EmbeddedField "BasicStatus"%go BasicStatus);
  (go.FieldDecl "Config"%go tracker.Config);
  (go.FieldDecl "Progress"%go (go.MapType go.uint64 tracker.Progress))
].
Program Definition Status'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (Status'fds_unsealed).
Global Instance equals_unfold_Status {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Status'fds =→ Status'fds_unsealed.
Proof. rewrite /Status'fds seal_eq //. Qed.

Definition Statusⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (Status'fds).

Class Status_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Status_type_repr  :: go.TypeReprUnderlying Statusⁱᵐᵖˡ Status.t;
  #[global] Status_underlying :: (Status) <u (Statusⁱᵐᵖˡ);
  #[global] Status_get_BasicStatus (x : Status.t) :: ⟦StructFieldGet (Statusⁱᵐᵖˡ) "BasicStatus", #x⟧ ⤳[under] #x.(Status.BasicStatus');
  #[global] Status_set_BasicStatus (x : Status.t) y :: ⟦StructFieldSet (Statusⁱᵐᵖˡ) "BasicStatus", (#x, #y)⟧ ⤳[under] #(x <|Status.BasicStatus' := y|>);
  #[global] Status_get_Config (x : Status.t) :: ⟦StructFieldGet (Statusⁱᵐᵖˡ) "Config", #x⟧ ⤳[under] #x.(Status.Config');
  #[global] Status_set_Config (x : Status.t) y :: ⟦StructFieldSet (Statusⁱᵐᵖˡ) "Config", (#x, #y)⟧ ⤳[under] #(x <|Status.Config' := y|>);
  #[global] Status_get_Progress (x : Status.t) :: ⟦StructFieldGet (Statusⁱᵐᵖˡ) "Progress", #x⟧ ⤳[under] #x.(Status.Progress');
  #[global] Status_set_Progress (x : Status.t) y :: ⟦StructFieldSet (Statusⁱᵐᵖˡ) "Progress", (#x, #y)⟧ ⤳[under] #(x <|Status.Progress' := y|>);
  #[global] Status_MarshalJSON_unfold :: MethodUnfold (Status) "MarshalJSON" (Status__MarshalJSONⁱᵐᵖˡ);
  #[global] Status_String_unfold :: MethodUnfold (Status) "String" (Status__Stringⁱᵐᵖˡ);
  #[global] Status'ptr_Descriptor_unfold :: MethodUnfold (go.PointerType (Status)) "Descriptor" (λ: "$r", MethodResolve (go.PointerType BasicStatus) "Descriptor" (StructFieldRef Status "BasicStatus"%go "$r"));
  #[global] Status'ptr_Marshal_unfold :: MethodUnfold (go.PointerType (Status)) "Marshal" (λ: "$r", MethodResolve (go.PointerType BasicStatus) "Marshal" (StructFieldRef Status "BasicStatus"%go "$r"));
  #[global] Status'ptr_MarshalJSON_unfold :: MethodUnfold (go.PointerType (Status)) "MarshalJSON" (λ: "$r", MethodResolve (Status) "MarshalJSON" (![(Status)] "$r"));
  #[global] Status'ptr_MarshalTo_unfold :: MethodUnfold (go.PointerType (Status)) "MarshalTo" (λ: "$r", MethodResolve (go.PointerType BasicStatus) "MarshalTo" (StructFieldRef Status "BasicStatus"%go "$r"));
  #[global] Status'ptr_MarshalToSizedBuffer_unfold :: MethodUnfold (go.PointerType (Status)) "MarshalToSizedBuffer" (λ: "$r", MethodResolve (go.PointerType BasicStatus) "MarshalToSizedBuffer" (StructFieldRef Status "BasicStatus"%go "$r"));
  #[global] Status'ptr_ProtoMessage_unfold :: MethodUnfold (go.PointerType (Status)) "ProtoMessage" (λ: "$r", MethodResolve (go.PointerType BasicStatus) "ProtoMessage" (StructFieldRef Status "BasicStatus"%go "$r"));
  #[global] Status'ptr_Reset_unfold :: MethodUnfold (go.PointerType (Status)) "Reset" (λ: "$r", MethodResolve (go.PointerType BasicStatus) "Reset" (StructFieldRef Status "BasicStatus"%go "$r"));
  #[global] Status'ptr_Size_unfold :: MethodUnfold (go.PointerType (Status)) "Size" (λ: "$r", MethodResolve (go.PointerType BasicStatus) "Size" (StructFieldRef Status "BasicStatus"%go "$r"));
  #[global] Status'ptr_String_unfold :: MethodUnfold (go.PointerType (Status)) "String" (λ: "$r", MethodResolve (Status) "String" (![(Status)] "$r"));
  #[global] Status'ptr_Unmarshal_unfold :: MethodUnfold (go.PointerType (Status)) "Unmarshal" (λ: "$r", MethodResolve (go.PointerType BasicStatus) "Unmarshal" (StructFieldRef Status "BasicStatus"%go "$r"));
  #[global] Status'ptr_XXX_DiscardUnknown_unfold :: MethodUnfold (go.PointerType (Status)) "XXX_DiscardUnknown" (λ: "$r", MethodResolve (go.PointerType BasicStatus) "XXX_DiscardUnknown" (StructFieldRef Status "BasicStatus"%go "$r"));
  #[global] Status'ptr_XXX_Marshal_unfold :: MethodUnfold (go.PointerType (Status)) "XXX_Marshal" (λ: "$r", MethodResolve (go.PointerType BasicStatus) "XXX_Marshal" (StructFieldRef Status "BasicStatus"%go "$r"));
  #[global] Status'ptr_XXX_Merge_unfold :: MethodUnfold (go.PointerType (Status)) "XXX_Merge" (λ: "$r", MethodResolve (go.PointerType BasicStatus) "XXX_Merge" (StructFieldRef Status "BasicStatus"%go "$r"));
  #[global] Status'ptr_XXX_Size_unfold :: MethodUnfold (go.PointerType (Status)) "XXX_Size" (λ: "$r", MethodResolve (go.PointerType BasicStatus) "XXX_Size" (StructFieldRef Status "BasicStatus"%go "$r"));
  #[global] Status'ptr_XXX_Unmarshal_unfold :: MethodUnfold (go.PointerType (Status)) "XXX_Unmarshal" (λ: "$r", MethodResolve (go.PointerType BasicStatus) "XXX_Unmarshal" (StructFieldRef Status "BasicStatus"%go "$r"));
  #[global] Status'ptr_equal_unfold :: MethodUnfold (go.PointerType (Status)) "equal" (λ: "$r", MethodResolve (go.PointerType BasicStatus) "equal" (StructFieldRef Status "BasicStatus"%go "$r"));
}.

Module inMemStorageCallStats.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  initialState' : w64;
  firstIndex' : w64;
  lastIndex' : w64;
  entries' : w64;
  term' : w64;
  snapshot' : w64;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End inMemStorageCallStats.

Definition inMemStorageCallStats'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "initialState"%go go.int);
  (go.FieldDecl "firstIndex"%go go.int);
  (go.FieldDecl "lastIndex"%go go.int);
  (go.FieldDecl "entries"%go go.int);
  (go.FieldDecl "term"%go go.int);
  (go.FieldDecl "snapshot"%go go.int)
].
Program Definition inMemStorageCallStats'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (inMemStorageCallStats'fds_unsealed).
Global Instance equals_unfold_inMemStorageCallStats {ext : ffi_syntax} {go_gctx : GoGlobalContext} : inMemStorageCallStats'fds =→ inMemStorageCallStats'fds_unsealed.
Proof. rewrite /inMemStorageCallStats'fds seal_eq //. Qed.

Definition inMemStorageCallStatsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (inMemStorageCallStats'fds).

Class inMemStorageCallStats_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] inMemStorageCallStats_type_repr  :: go.TypeReprUnderlying inMemStorageCallStatsⁱᵐᵖˡ inMemStorageCallStats.t;
  #[global] inMemStorageCallStats_underlying :: (inMemStorageCallStats) <u (inMemStorageCallStatsⁱᵐᵖˡ);
  #[global] inMemStorageCallStats_get_initialState (x : inMemStorageCallStats.t) :: ⟦StructFieldGet (inMemStorageCallStatsⁱᵐᵖˡ) "initialState", #x⟧ ⤳[under] #x.(inMemStorageCallStats.initialState');
  #[global] inMemStorageCallStats_set_initialState (x : inMemStorageCallStats.t) y :: ⟦StructFieldSet (inMemStorageCallStatsⁱᵐᵖˡ) "initialState", (#x, #y)⟧ ⤳[under] #(x <|inMemStorageCallStats.initialState' := y|>);
  #[global] inMemStorageCallStats_get_firstIndex (x : inMemStorageCallStats.t) :: ⟦StructFieldGet (inMemStorageCallStatsⁱᵐᵖˡ) "firstIndex", #x⟧ ⤳[under] #x.(inMemStorageCallStats.firstIndex');
  #[global] inMemStorageCallStats_set_firstIndex (x : inMemStorageCallStats.t) y :: ⟦StructFieldSet (inMemStorageCallStatsⁱᵐᵖˡ) "firstIndex", (#x, #y)⟧ ⤳[under] #(x <|inMemStorageCallStats.firstIndex' := y|>);
  #[global] inMemStorageCallStats_get_lastIndex (x : inMemStorageCallStats.t) :: ⟦StructFieldGet (inMemStorageCallStatsⁱᵐᵖˡ) "lastIndex", #x⟧ ⤳[under] #x.(inMemStorageCallStats.lastIndex');
  #[global] inMemStorageCallStats_set_lastIndex (x : inMemStorageCallStats.t) y :: ⟦StructFieldSet (inMemStorageCallStatsⁱᵐᵖˡ) "lastIndex", (#x, #y)⟧ ⤳[under] #(x <|inMemStorageCallStats.lastIndex' := y|>);
  #[global] inMemStorageCallStats_get_entries (x : inMemStorageCallStats.t) :: ⟦StructFieldGet (inMemStorageCallStatsⁱᵐᵖˡ) "entries", #x⟧ ⤳[under] #x.(inMemStorageCallStats.entries');
  #[global] inMemStorageCallStats_set_entries (x : inMemStorageCallStats.t) y :: ⟦StructFieldSet (inMemStorageCallStatsⁱᵐᵖˡ) "entries", (#x, #y)⟧ ⤳[under] #(x <|inMemStorageCallStats.entries' := y|>);
  #[global] inMemStorageCallStats_get_term (x : inMemStorageCallStats.t) :: ⟦StructFieldGet (inMemStorageCallStatsⁱᵐᵖˡ) "term", #x⟧ ⤳[under] #x.(inMemStorageCallStats.term');
  #[global] inMemStorageCallStats_set_term (x : inMemStorageCallStats.t) y :: ⟦StructFieldSet (inMemStorageCallStatsⁱᵐᵖˡ) "term", (#x, #y)⟧ ⤳[under] #(x <|inMemStorageCallStats.term' := y|>);
  #[global] inMemStorageCallStats_get_snapshot (x : inMemStorageCallStats.t) :: ⟦StructFieldGet (inMemStorageCallStatsⁱᵐᵖˡ) "snapshot", #x⟧ ⤳[under] #x.(inMemStorageCallStats.snapshot');
  #[global] inMemStorageCallStats_set_snapshot (x : inMemStorageCallStats.t) y :: ⟦StructFieldSet (inMemStorageCallStatsⁱᵐᵖˡ) "snapshot", (#x, #y)⟧ ⤳[under] #(x <|inMemStorageCallStats.snapshot' := y|>);
}.

Module MemoryStorage.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  Mutex' : sync.Mutex.t;
  hardState' : raftpb.HardState.t;
  snapshot' : raftpb.Snapshot.t;
  ents' : slice.t;
  callStats' : raft.inMemStorageCallStats.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End MemoryStorage.

Definition MemoryStorage'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.EmbeddedField "Mutex"%go sync.Mutex);
  (go.FieldDecl "hardState"%go raftpb.HardState);
  (go.FieldDecl "snapshot"%go raftpb.Snapshot);
  (go.FieldDecl "ents"%go (go.SliceType raftpb.Entry));
  (go.FieldDecl "callStats"%go inMemStorageCallStats)
].
Program Definition MemoryStorage'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (MemoryStorage'fds_unsealed).
Global Instance equals_unfold_MemoryStorage {ext : ffi_syntax} {go_gctx : GoGlobalContext} : MemoryStorage'fds =→ MemoryStorage'fds_unsealed.
Proof. rewrite /MemoryStorage'fds seal_eq //. Qed.

Definition MemoryStorageⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (MemoryStorage'fds).

Class MemoryStorage_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] MemoryStorage_type_repr  :: go.TypeReprUnderlying MemoryStorageⁱᵐᵖˡ MemoryStorage.t;
  #[global] MemoryStorage_underlying :: (MemoryStorage) <u (MemoryStorageⁱᵐᵖˡ);
  #[global] MemoryStorage_get_Mutex (x : MemoryStorage.t) :: ⟦StructFieldGet (MemoryStorageⁱᵐᵖˡ) "Mutex", #x⟧ ⤳[under] #x.(MemoryStorage.Mutex');
  #[global] MemoryStorage_set_Mutex (x : MemoryStorage.t) y :: ⟦StructFieldSet (MemoryStorageⁱᵐᵖˡ) "Mutex", (#x, #y)⟧ ⤳[under] #(x <|MemoryStorage.Mutex' := y|>);
  #[global] MemoryStorage_get_hardState (x : MemoryStorage.t) :: ⟦StructFieldGet (MemoryStorageⁱᵐᵖˡ) "hardState", #x⟧ ⤳[under] #x.(MemoryStorage.hardState');
  #[global] MemoryStorage_set_hardState (x : MemoryStorage.t) y :: ⟦StructFieldSet (MemoryStorageⁱᵐᵖˡ) "hardState", (#x, #y)⟧ ⤳[under] #(x <|MemoryStorage.hardState' := y|>);
  #[global] MemoryStorage_get_snapshot (x : MemoryStorage.t) :: ⟦StructFieldGet (MemoryStorageⁱᵐᵖˡ) "snapshot", #x⟧ ⤳[under] #x.(MemoryStorage.snapshot');
  #[global] MemoryStorage_set_snapshot (x : MemoryStorage.t) y :: ⟦StructFieldSet (MemoryStorageⁱᵐᵖˡ) "snapshot", (#x, #y)⟧ ⤳[under] #(x <|MemoryStorage.snapshot' := y|>);
  #[global] MemoryStorage_get_ents (x : MemoryStorage.t) :: ⟦StructFieldGet (MemoryStorageⁱᵐᵖˡ) "ents", #x⟧ ⤳[under] #x.(MemoryStorage.ents');
  #[global] MemoryStorage_set_ents (x : MemoryStorage.t) y :: ⟦StructFieldSet (MemoryStorageⁱᵐᵖˡ) "ents", (#x, #y)⟧ ⤳[under] #(x <|MemoryStorage.ents' := y|>);
  #[global] MemoryStorage_get_callStats (x : MemoryStorage.t) :: ⟦StructFieldGet (MemoryStorageⁱᵐᵖˡ) "callStats", #x⟧ ⤳[under] #x.(MemoryStorage.callStats');
  #[global] MemoryStorage_set_callStats (x : MemoryStorage.t) y :: ⟦StructFieldSet (MemoryStorageⁱᵐᵖˡ) "callStats", (#x, #y)⟧ ⤳[under] #(x <|MemoryStorage.callStats' := y|>);
  #[global] MemoryStorage'ptr_Append_unfold :: MethodUnfold (go.PointerType (MemoryStorage)) "Append" (MemoryStorage__Appendⁱᵐᵖˡ);
  #[global] MemoryStorage'ptr_ApplySnapshot_unfold :: MethodUnfold (go.PointerType (MemoryStorage)) "ApplySnapshot" (MemoryStorage__ApplySnapshotⁱᵐᵖˡ);
  #[global] MemoryStorage'ptr_Compact_unfold :: MethodUnfold (go.PointerType (MemoryStorage)) "Compact" (MemoryStorage__Compactⁱᵐᵖˡ);
  #[global] MemoryStorage'ptr_CreateSnapshot_unfold :: MethodUnfold (go.PointerType (MemoryStorage)) "CreateSnapshot" (MemoryStorage__CreateSnapshotⁱᵐᵖˡ);
  #[global] MemoryStorage'ptr_Entries_unfold :: MethodUnfold (go.PointerType (MemoryStorage)) "Entries" (MemoryStorage__Entriesⁱᵐᵖˡ);
  #[global] MemoryStorage'ptr_FirstIndex_unfold :: MethodUnfold (go.PointerType (MemoryStorage)) "FirstIndex" (MemoryStorage__FirstIndexⁱᵐᵖˡ);
  #[global] MemoryStorage'ptr_InitialState_unfold :: MethodUnfold (go.PointerType (MemoryStorage)) "InitialState" (MemoryStorage__InitialStateⁱᵐᵖˡ);
  #[global] MemoryStorage'ptr_LastIndex_unfold :: MethodUnfold (go.PointerType (MemoryStorage)) "LastIndex" (MemoryStorage__LastIndexⁱᵐᵖˡ);
  #[global] MemoryStorage'ptr_Lock_unfold :: MethodUnfold (go.PointerType (MemoryStorage)) "Lock" (λ: "$r", MethodResolve (go.PointerType sync.Mutex) "Lock" (StructFieldRef MemoryStorage "Mutex"%go "$r"));
  #[global] MemoryStorage'ptr_SetHardState_unfold :: MethodUnfold (go.PointerType (MemoryStorage)) "SetHardState" (MemoryStorage__SetHardStateⁱᵐᵖˡ);
  #[global] MemoryStorage'ptr_Snapshot_unfold :: MethodUnfold (go.PointerType (MemoryStorage)) "Snapshot" (MemoryStorage__Snapshotⁱᵐᵖˡ);
  #[global] MemoryStorage'ptr_Term_unfold :: MethodUnfold (go.PointerType (MemoryStorage)) "Term" (MemoryStorage__Termⁱᵐᵖˡ);
  #[global] MemoryStorage'ptr_TryLock_unfold :: MethodUnfold (go.PointerType (MemoryStorage)) "TryLock" (λ: "$r", MethodResolve (go.PointerType sync.Mutex) "TryLock" (StructFieldRef MemoryStorage "Mutex"%go "$r"));
  #[global] MemoryStorage'ptr_Unlock_unfold :: MethodUnfold (go.PointerType (MemoryStorage)) "Unlock" (λ: "$r", MethodResolve (go.PointerType sync.Mutex) "Unlock" (StructFieldRef MemoryStorage "Mutex"%go "$r"));
  #[global] MemoryStorage'ptr_firstIndex_unfold :: MethodUnfold (go.PointerType (MemoryStorage)) "firstIndex" (MemoryStorage__firstIndexⁱᵐᵖˡ);
  #[global] MemoryStorage'ptr_lastIndex_unfold :: MethodUnfold (go.PointerType (MemoryStorage)) "lastIndex" (MemoryStorage__lastIndexⁱᵐᵖˡ);
}.

Module entryID.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  term' : w64;
  index' : w64;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End entryID.

Definition entryID'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "term"%go go.uint64);
  (go.FieldDecl "index"%go go.uint64)
].
Program Definition entryID'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (entryID'fds_unsealed).
Global Instance equals_unfold_entryID {ext : ffi_syntax} {go_gctx : GoGlobalContext} : entryID'fds =→ entryID'fds_unsealed.
Proof. rewrite /entryID'fds seal_eq //. Qed.

Definition entryIDⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (entryID'fds).

Class entryID_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] entryID_type_repr  :: go.TypeReprUnderlying entryIDⁱᵐᵖˡ entryID.t;
  #[global] entryID_underlying :: (entryID) <u (entryIDⁱᵐᵖˡ);
  #[global] entryID_get_term (x : entryID.t) :: ⟦StructFieldGet (entryIDⁱᵐᵖˡ) "term", #x⟧ ⤳[under] #x.(entryID.term');
  #[global] entryID_set_term (x : entryID.t) y :: ⟦StructFieldSet (entryIDⁱᵐᵖˡ) "term", (#x, #y)⟧ ⤳[under] #(x <|entryID.term' := y|>);
  #[global] entryID_get_index (x : entryID.t) :: ⟦StructFieldGet (entryIDⁱᵐᵖˡ) "index", #x⟧ ⤳[under] #x.(entryID.index');
  #[global] entryID_set_index (x : entryID.t) y :: ⟦StructFieldSet (entryIDⁱᵐᵖˡ) "index", (#x, #y)⟧ ⤳[under] #(x <|entryID.index' := y|>);
}.

Module logSlice.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  term' : w64;
  prev' : raft.entryID.t;
  entries' : slice.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End logSlice.

Definition logSlice'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "term"%go go.uint64);
  (go.FieldDecl "prev"%go entryID);
  (go.FieldDecl "entries"%go (go.SliceType raftpb.Entry))
].
Program Definition logSlice'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (logSlice'fds_unsealed).
Global Instance equals_unfold_logSlice {ext : ffi_syntax} {go_gctx : GoGlobalContext} : logSlice'fds =→ logSlice'fds_unsealed.
Proof. rewrite /logSlice'fds seal_eq //. Qed.

Definition logSliceⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (logSlice'fds).

Class logSlice_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] logSlice_type_repr  :: go.TypeReprUnderlying logSliceⁱᵐᵖˡ logSlice.t;
  #[global] logSlice_underlying :: (logSlice) <u (logSliceⁱᵐᵖˡ);
  #[global] logSlice_get_term (x : logSlice.t) :: ⟦StructFieldGet (logSliceⁱᵐᵖˡ) "term", #x⟧ ⤳[under] #x.(logSlice.term');
  #[global] logSlice_set_term (x : logSlice.t) y :: ⟦StructFieldSet (logSliceⁱᵐᵖˡ) "term", (#x, #y)⟧ ⤳[under] #(x <|logSlice.term' := y|>);
  #[global] logSlice_get_prev (x : logSlice.t) :: ⟦StructFieldGet (logSliceⁱᵐᵖˡ) "prev", #x⟧ ⤳[under] #x.(logSlice.prev');
  #[global] logSlice_set_prev (x : logSlice.t) y :: ⟦StructFieldSet (logSliceⁱᵐᵖˡ) "prev", (#x, #y)⟧ ⤳[under] #(x <|logSlice.prev' := y|>);
  #[global] logSlice_get_entries (x : logSlice.t) :: ⟦StructFieldGet (logSliceⁱᵐᵖˡ) "entries", #x⟧ ⤳[under] #x.(logSlice.entries');
  #[global] logSlice_set_entries (x : logSlice.t) y :: ⟦StructFieldSet (logSliceⁱᵐᵖˡ) "entries", (#x, #y)⟧ ⤳[under] #(x <|logSlice.entries' := y|>);
  #[global] logSlice_lastEntryID_unfold :: MethodUnfold (logSlice) "lastEntryID" (logSlice__lastEntryIDⁱᵐᵖˡ);
  #[global] logSlice_lastIndex_unfold :: MethodUnfold (logSlice) "lastIndex" (logSlice__lastIndexⁱᵐᵖˡ);
  #[global] logSlice_valid_unfold :: MethodUnfold (logSlice) "valid" (logSlice__validⁱᵐᵖˡ);
  #[global] logSlice'ptr_lastEntryID_unfold :: MethodUnfold (go.PointerType (logSlice)) "lastEntryID" (λ: "$r", MethodResolve (logSlice) "lastEntryID" (![(logSlice)] "$r"));
  #[global] logSlice'ptr_lastIndex_unfold :: MethodUnfold (go.PointerType (logSlice)) "lastIndex" (λ: "$r", MethodResolve (logSlice) "lastIndex" (![(logSlice)] "$r"));
  #[global] logSlice'ptr_valid_unfold :: MethodUnfold (go.PointerType (logSlice)) "valid" (λ: "$r", MethodResolve (logSlice) "valid" (![(logSlice)] "$r"));
}.

Module EntryFormatter.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := func.t.
End def.
End EntryFormatter.

Definition EntryFormatterⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.FunctionType (go.Signature [go.SliceType go.byte] false [go.string]).

Class EntryFormatter_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] EntryFormatter_underlying :: (EntryFormatter) <u (EntryFormatterⁱᵐᵖˡ);
}.

Class Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] raftLog_instance :: raftLog_Assumptions;
  #[global] unstable_instance :: unstable_Assumptions;
  #[global] Logger_instance :: Logger_Assumptions;
  #[global] DefaultLogger_instance :: DefaultLogger_Assumptions;
  #[global] SnapshotStatus_instance :: SnapshotStatus_Assumptions;
  #[global] SoftState_instance :: SoftState_Assumptions;
  #[global] Ready_instance :: Ready_Assumptions;
  #[global] Node_instance :: Node_Assumptions;
  #[global] Peer_instance :: Peer_Assumptions;
  #[global] msgWithResult_instance :: msgWithResult_Assumptions;
  #[global] node_instance :: node_Assumptions;
  #[global] ReadOnlyOption_instance :: ReadOnlyOption_Assumptions;
  #[global] lockedRand_instance :: lockedRand_Assumptions;
  #[global] CampaignType_instance :: CampaignType_Assumptions;
  #[global] StateType_instance :: StateType_Assumptions;
  #[global] Config_instance :: Config_Assumptions;
  #[global] raft_instance :: raft_Assumptions;
  #[global] stepFunc_instance :: stepFunc_Assumptions;
  #[global] RawNode_instance :: RawNode_Assumptions;
  #[global] ProgressType_instance :: ProgressType_Assumptions;
  #[global] ReadState_instance :: ReadState_Assumptions;
  #[global] readIndexStatus_instance :: readIndexStatus_Assumptions;
  #[global] readOnly_instance :: readOnly_Assumptions;
  #[global] TraceLogger_instance :: TraceLogger_Assumptions;
  #[global] TracingEvent_instance :: TracingEvent_Assumptions;
  #[global] Status_instance :: Status_Assumptions;
  #[global] BasicStatus_instance :: BasicStatus_Assumptions;
  #[global] Storage_instance :: Storage_Assumptions;
  #[global] inMemStorageCallStats_instance :: inMemStorageCallStats_Assumptions;
  #[global] MemoryStorage_instance :: MemoryStorage_Assumptions;
  #[global] entryID_instance :: entryID_Assumptions;
  #[global] logSlice_instance :: logSlice_Assumptions;
  #[global] EntryFormatter_instance :: EntryFormatter_Assumptions;
  #[global] entryEncodingSize_instance :: entryEncodingSize_Assumptions;
  #[global] entryPayloadSize_instance :: entryPayloadSize_Assumptions;
  #[global] newLog_unfold :: FuncUnfold newLog [] (newLogⁱᵐᵖˡ);
  #[global] newLogWithSize_unfold :: FuncUnfold newLogWithSize [] (newLogWithSizeⁱᵐᵖˡ);
  #[global] SetLogger_unfold :: FuncUnfold SetLogger [] (SetLoggerⁱᵐᵖˡ);
  #[global] ResetDefaultLogger_unfold :: FuncUnfold ResetDefaultLogger [] (ResetDefaultLoggerⁱᵐᵖˡ);
  #[global] getLogger_unfold :: FuncUnfold getLogger [] (getLoggerⁱᵐᵖˡ);
  #[global] header_unfold :: FuncUnfold header [] (headerⁱᵐᵖˡ);
  #[global] isHardStateEqual_unfold :: FuncUnfold isHardStateEqual [] (isHardStateEqualⁱᵐᵖˡ);
  #[global] IsEmptyHardState_unfold :: FuncUnfold IsEmptyHardState [] (IsEmptyHardStateⁱᵐᵖˡ);
  #[global] IsEmptySnap_unfold :: FuncUnfold IsEmptySnap [] (IsEmptySnapⁱᵐᵖˡ);
  #[global] setupNode_unfold :: FuncUnfold setupNode [] (setupNodeⁱᵐᵖˡ);
  #[global] StartNode_unfold :: FuncUnfold StartNode [] (StartNodeⁱᵐᵖˡ);
  #[global] RestartNode_unfold :: FuncUnfold RestartNode [] (RestartNodeⁱᵐᵖˡ);
  #[global] newNode_unfold :: FuncUnfold newNode [] (newNodeⁱᵐᵖˡ);
  #[global] confChangeToMsg_unfold :: FuncUnfold confChangeToMsg [] (confChangeToMsgⁱᵐᵖˡ);
  #[global] newRaft_unfold :: FuncUnfold newRaft [] (newRaftⁱᵐᵖˡ);
  #[global] stepLeader_unfold :: FuncUnfold stepLeader [] (stepLeaderⁱᵐᵖˡ);
  #[global] stepCandidate_unfold :: FuncUnfold stepCandidate [] (stepCandidateⁱᵐᵖˡ);
  #[global] stepFollower_unfold :: FuncUnfold stepFollower [] (stepFollowerⁱᵐᵖˡ);
  #[global] logSliceFromMsgApp_unfold :: FuncUnfold logSliceFromMsgApp [] (logSliceFromMsgAppⁱᵐᵖˡ);
  #[global] releasePendingReadIndexMessages_unfold :: FuncUnfold releasePendingReadIndexMessages [] (releasePendingReadIndexMessagesⁱᵐᵖˡ);
  #[global] sendMsgReadIndexResponse_unfold :: FuncUnfold sendMsgReadIndexResponse [] (sendMsgReadIndexResponseⁱᵐᵖˡ);
  #[global] NewRawNode_unfold :: FuncUnfold NewRawNode [] (NewRawNodeⁱᵐᵖˡ);
  #[global] MustSync_unfold :: FuncUnfold MustSync [] (MustSyncⁱᵐᵖˡ);
  #[global] needStorageAppendMsg_unfold :: FuncUnfold needStorageAppendMsg [] (needStorageAppendMsgⁱᵐᵖˡ);
  #[global] needStorageAppendRespMsg_unfold :: FuncUnfold needStorageAppendRespMsg [] (needStorageAppendRespMsgⁱᵐᵖˡ);
  #[global] newStorageAppendMsg_unfold :: FuncUnfold newStorageAppendMsg [] (newStorageAppendMsgⁱᵐᵖˡ);
  #[global] newStorageAppendRespMsg_unfold :: FuncUnfold newStorageAppendRespMsg [] (newStorageAppendRespMsgⁱᵐᵖˡ);
  #[global] needStorageApplyMsg_unfold :: FuncUnfold needStorageApplyMsg [] (needStorageApplyMsgⁱᵐᵖˡ);
  #[global] needStorageApplyRespMsg_unfold :: FuncUnfold needStorageApplyRespMsg [] (needStorageApplyRespMsgⁱᵐᵖˡ);
  #[global] newStorageApplyMsg_unfold :: FuncUnfold newStorageApplyMsg [] (newStorageApplyMsgⁱᵐᵖˡ);
  #[global] newStorageApplyRespMsg_unfold :: FuncUnfold newStorageApplyRespMsg [] (newStorageApplyRespMsgⁱᵐᵖˡ);
  #[global] newReadOnly_unfold :: FuncUnfold newReadOnly [] (newReadOnlyⁱᵐᵖˡ);
  #[global] traceInitState_unfold :: FuncUnfold traceInitState [] (traceInitStateⁱᵐᵖˡ);
  #[global] traceReady_unfold :: FuncUnfold traceReady [] (traceReadyⁱᵐᵖˡ);
  #[global] traceCommit_unfold :: FuncUnfold traceCommit [] (traceCommitⁱᵐᵖˡ);
  #[global] traceReplicate_unfold :: FuncUnfold traceReplicate [] (traceReplicateⁱᵐᵖˡ);
  #[global] traceBecomeFollower_unfold :: FuncUnfold traceBecomeFollower [] (traceBecomeFollowerⁱᵐᵖˡ);
  #[global] traceBecomeCandidate_unfold :: FuncUnfold traceBecomeCandidate [] (traceBecomeCandidateⁱᵐᵖˡ);
  #[global] traceBecomeLeader_unfold :: FuncUnfold traceBecomeLeader [] (traceBecomeLeaderⁱᵐᵖˡ);
  #[global] traceChangeConfEvent_unfold :: FuncUnfold traceChangeConfEvent [] (traceChangeConfEventⁱᵐᵖˡ);
  #[global] traceConfChangeEvent_unfold :: FuncUnfold traceConfChangeEvent [] (traceConfChangeEventⁱᵐᵖˡ);
  #[global] traceSendMessage_unfold :: FuncUnfold traceSendMessage [] (traceSendMessageⁱᵐᵖˡ);
  #[global] traceReceiveMessage_unfold :: FuncUnfold traceReceiveMessage [] (traceReceiveMessageⁱᵐᵖˡ);
  #[global] getProgressCopy_unfold :: FuncUnfold getProgressCopy [] (getProgressCopyⁱᵐᵖˡ);
  #[global] getBasicStatus_unfold :: FuncUnfold getBasicStatus [] (getBasicStatusⁱᵐᵖˡ);
  #[global] getStatus_unfold :: FuncUnfold getStatus [] (getStatusⁱᵐᵖˡ);
  #[global] NewMemoryStorage_unfold :: FuncUnfold NewMemoryStorage [] (NewMemoryStorageⁱᵐᵖˡ);
  #[global] pbEntryID_unfold :: FuncUnfold pbEntryID [] (pbEntryIDⁱᵐᵖˡ);
  #[global] isMsgInArray_unfold :: FuncUnfold isMsgInArray [] (isMsgInArrayⁱᵐᵖˡ);
  #[global] IsLocalMsg_unfold :: FuncUnfold IsLocalMsg [] (IsLocalMsgⁱᵐᵖˡ);
  #[global] IsResponseMsg_unfold :: FuncUnfold IsResponseMsg [] (IsResponseMsgⁱᵐᵖˡ);
  #[global] IsLocalMsgTarget_unfold :: FuncUnfold IsLocalMsgTarget [] (IsLocalMsgTargetⁱᵐᵖˡ);
  #[global] voteRespMsgType_unfold :: FuncUnfold voteRespMsgType [] (voteRespMsgTypeⁱᵐᵖˡ);
  #[global] DescribeHardState_unfold :: FuncUnfold DescribeHardState [] (DescribeHardStateⁱᵐᵖˡ);
  #[global] DescribeSoftState_unfold :: FuncUnfold DescribeSoftState [] (DescribeSoftStateⁱᵐᵖˡ);
  #[global] DescribeConfState_unfold :: FuncUnfold DescribeConfState [] (DescribeConfStateⁱᵐᵖˡ);
  #[global] DescribeSnapshot_unfold :: FuncUnfold DescribeSnapshot [] (DescribeSnapshotⁱᵐᵖˡ);
  #[global] DescribeReady_unfold :: FuncUnfold DescribeReady [] (DescribeReadyⁱᵐᵖˡ);
  #[global] DescribeMessage_unfold :: FuncUnfold DescribeMessage [] (DescribeMessageⁱᵐᵖˡ);
  #[global] describeMessageWithIndent_unfold :: FuncUnfold describeMessageWithIndent [] (describeMessageWithIndentⁱᵐᵖˡ);
  #[global] describeTarget_unfold :: FuncUnfold describeTarget [] (describeTargetⁱᵐᵖˡ);
  #[global] DescribeEntry_unfold :: FuncUnfold DescribeEntry [] (DescribeEntryⁱᵐᵖˡ);
  #[global] DescribeEntries_unfold :: FuncUnfold DescribeEntries [] (DescribeEntriesⁱᵐᵖˡ);
  #[global] entsSize_unfold :: FuncUnfold entsSize [] (entsSizeⁱᵐᵖˡ);
  #[global] limitSize_unfold :: FuncUnfold limitSize [] (limitSizeⁱᵐᵖˡ);
  #[global] payloadSize_unfold :: FuncUnfold payloadSize [] (payloadSizeⁱᵐᵖˡ);
  #[global] payloadsSize_unfold :: FuncUnfold payloadsSize [] (payloadsSizeⁱᵐᵖˡ);
  #[global] assertConfStatesEquivalent_unfold :: FuncUnfold assertConfStatesEquivalent [] (assertConfStatesEquivalentⁱᵐᵖˡ);
  #[global] extend_unfold :: FuncUnfold extend [] (extendⁱᵐᵖˡ);
  #[global] import_errors_Assumption :: errors.Assumptions;
  #[global] import_pb_Assumption :: pb.Assumptions;
  #[global] import_fmt_Assumption :: fmt.Assumptions;
  #[global] import_io_Assumption :: io.Assumptions;
  #[global] import_log_Assumption :: log.Assumptions;
  #[global] import_os_Assumption :: os.Assumptions;
  #[global] import_sync_Assumption :: sync.Assumptions;
  #[global] import_context_Assumption :: context.Assumptions;
  #[global] import_bytes_Assumption :: bytes.Assumptions;
  #[global] import_rand_Assumption :: rand.Assumptions;
  #[global] import_math_Assumption :: math.Assumptions;
  #[global] import_big_Assumption :: big.Assumptions;
  #[global] import_strings_Assumption :: strings.Assumptions;
  #[global] import_confchange_Assumption :: confchange.Assumptions;
  #[global] import_quorum_Assumption :: quorum.Assumptions;
  #[global] import_slices_Assumption :: slices.Assumptions;
  #[global] import_tracker_Assumption :: tracker.Assumptions;
}.
End raft.
