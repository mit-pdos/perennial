(* autogenerated from go.etcd.io/raft/v3 *)
From New.golang Require Import defn.
From New.code Require bytes.
From New.code Require context.
From New.code Require crypto.rand.
From New.code Require errors.
From New.code Require fmt.
From New.code Require go_etcd_io.raft.v3.confchange.
From New.code Require go_etcd_io.raft.v3.quorum.
From New.code Require go_etcd_io.raft.v3.raftpb.
From New.code Require go_etcd_io.raft.v3.tracker.
From New.code Require io.
From New.code Require log.
From New.code Require math.
From New.code Require math.big.
From New.code Require os.
From New.code Require sort.
From New.code Require strings.
From New.code Require sync.

Section code.
Context `{ffi_syntax}.

Definition Peer : go_type := structT [
  "ID" :: uint64T;
  "Context" :: sliceT byteT
]%struct.

Definition RawNode : go_type := structT [
  "raft" :: ptrT;
  "asyncStorageWrites" :: boolT;
  "prevSoftSt" :: ptrT;
  "prevHardSt" :: raftpb.HardState;
  "stepsOnAdvance" :: sliceT raftpb.Message
]%struct.

Definition ReadState : go_type := structT [
  "Index" :: uint64T;
  "RequestCtx" :: sliceT byteT
]%struct.

Definition entryEncodingSize : go_type := uint64T.

Definition entryPayloadSize : go_type := uint64T.

Definition StateType : go_type := uint64T.

Definition stepFunc : go_type := funcT.

Definition Logger : go_type := interfaceT.

Definition TraceLogger : go_type := interfaceT.

Definition raft : go_type := structT [
  "id" :: uint64T;
  "Term" :: uint64T;
  "Vote" :: uint64T;
  "readStates" :: sliceT ReadState;
  "raftLog" :: ptrT;
  "maxMsgSize" :: entryEncodingSize;
  "maxUncommittedSize" :: entryPayloadSize;
  "trk" :: tracker.ProgressTracker;
  "state" :: StateType;
  "isLearner" :: boolT;
  "msgs" :: sliceT raftpb.Message;
  "msgsAfterAppend" :: sliceT raftpb.Message;
  "lead" :: uint64T;
  "leadTransferee" :: uint64T;
  "pendingConfIndex" :: uint64T;
  "disableConfChangeValidation" :: boolT;
  "uncommittedSize" :: entryPayloadSize;
  "readOnly" :: ptrT;
  "electionElapsed" :: intT;
  "heartbeatElapsed" :: intT;
  "checkQuorum" :: boolT;
  "preVote" :: boolT;
  "heartbeatTimeout" :: intT;
  "electionTimeout" :: intT;
  "randomizedElectionTimeout" :: intT;
  "disableProposalForwarding" :: boolT;
  "stepDownOnRemoval" :: boolT;
  "tick" :: funcT;
  "step" :: stepFunc;
  "logger" :: Logger;
  "pendingReadIndexMessages" :: sliceT raftpb.Message;
  "traceLogger" :: TraceLogger
]%struct.

Definition None : expr := #(W64 0).

(* go: raft.go:2059:16 *)
Definition raft__abortLeaderTransfer : val :=
  rec: "raft__abortLeaderTransfer" "r" <> :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "$r0" := None in
    do:  ((struct.field_ref raft "leadTransferee" (![ptrT] "r")) <-[uint64T] "$r0")).

Definition Storage : go_type := interfaceT.

Definition unstable : go_type := structT [
  "snapshot" :: ptrT;
  "entries" :: sliceT raftpb.Entry;
  "offset" :: uint64T;
  "snapshotInProgress" :: boolT;
  "offsetInProgress" :: uint64T;
  "logger" :: Logger
]%struct.

Definition raftLog : go_type := structT [
  "storage" :: Storage;
  "unstable" :: unstable;
  "committed" :: uint64T;
  "applying" :: uint64T;
  "applied" :: uint64T;
  "logger" :: Logger;
  "maxApplyingEntsSize" :: entryEncodingSize;
  "applyingEntsSize" :: entryEncodingSize;
  "applyingEntsPaused" :: boolT
]%struct.

(* payloadSize is the size of the payload of the provided entry.

   go: util.go:289:6 *)
Definition payloadSize : val :=
  rec: "payloadSize" "e" :=
    exception_do (let: "e" := (ref_ty raftpb.Entry "e") in
    return: (let: "$a0" := (![sliceT byteT] (struct.field_ref raftpb.Entry "Data" "e")) in
     slice.len "$a0")).

(* payloadsSize is the size of the payloads of the provided entries.

   go: util.go:294:6 *)
Definition payloadsSize : val :=
  rec: "payloadsSize" "ents" :=
    exception_do (let: "ents" := (ref_ty (sliceT raftpb.Entry) "ents") in
    let: "s" := (ref_ty entryPayloadSize (zero_val entryPayloadSize)) in
    do:  (let: "$range" := (![sliceT raftpb.Entry] "ents") in
    slice.for_range raftpb.Entry "$range" (λ: <> "e",
      let: "e" := ref_ty raftpb.Entry "e" in
      do:  ("s" <-[entryPayloadSize] ((![entryPayloadSize] "s") + (let: "$a0" := (![raftpb.Entry] "e") in
      payloadSize "$a0")))));;;
    return: (![entryPayloadSize] "s")).

(* go: state_trace_nop.go:48:6 *)
Definition traceSendMessage : val :=
  rec: "traceSendMessage" "" "" :=
    exception_do (let: "" := (ref_ty ptrT "") in
    let: "" := (ref_ty ptrT "") in
    do:  #()).

(* send schedules persisting state to a stable storage and AFTER that
   sending the message (as part of next Ready message processing).

   go: raft.go:512:16 *)
Definition raft__send : val :=
  rec: "raft__send" "r" "m" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "m" := (ref_ty raftpb.Message "m") in
    (if: (![uint64T] (struct.field_ref raftpb.Message "From" "m")) = None
    then
      let: "$r0" := (![uint64T] (struct.field_ref raft "id" (![ptrT] "r"))) in
      do:  ((struct.field_ref raftpb.Message "From" "m") <-[uint64T] "$r0")
    else do:  #());;;
    (if: ((((![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) = raftpb.MsgVote) || ((![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) = raftpb.MsgVoteResp)) || ((![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) = raftpb.MsgPreVote)) || ((![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) = raftpb.MsgPreVoteResp)
    then
      (if: (![uint64T] (struct.field_ref raftpb.Message "Term" "m")) = #(W64 0)
      then
        do:  (let: "$a0" := #(str "term should be set when sending %s") in
        let: "$a1" := ((let: "$sl0" := (interface.make raftpb.MessageType__mset (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m"))) in
        slice.literal interfaceT ["$sl0"])) in
        (interface.get "Panicf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1")
      else do:  #())
    else
      (if: (![uint64T] (struct.field_ref raftpb.Message "Term" "m")) ≠ #(W64 0)
      then
        do:  (let: "$a0" := #(str "term should not be set when sending %s (was %d)") in
        let: "$a1" := ((let: "$sl0" := (interface.make raftpb.MessageType__mset (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m"))) in
        let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "Term" "m"))) in
        slice.literal interfaceT ["$sl0"; "$sl1"])) in
        (interface.get "Panicf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1")
      else do:  #());;;
      (if: ((![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) ≠ raftpb.MsgProp) && ((![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) ≠ raftpb.MsgReadIndex)
      then
        let: "$r0" := (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r"))) in
        do:  ((struct.field_ref raftpb.Message "Term" "m") <-[uint64T] "$r0")
      else do:  #()));;;
    (if: (((![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) = raftpb.MsgAppResp) || ((![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) = raftpb.MsgVoteResp)) || ((![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) = raftpb.MsgPreVoteResp)
    then
      let: "$r0" := (let: "$a0" := (![sliceT raftpb.Message] (struct.field_ref raft "msgsAfterAppend" (![ptrT] "r"))) in
      let: "$a1" := ((let: "$sl0" := (![raftpb.Message] "m") in
      slice.literal raftpb.Message ["$sl0"])) in
      (slice.append (sliceT raftpb.Message)) "$a0" "$a1") in
      do:  ((struct.field_ref raft "msgsAfterAppend" (![ptrT] "r")) <-[sliceT raftpb.Message] "$r0");;;
      do:  (let: "$a0" := (![ptrT] "r") in
      let: "$a1" := "m" in
      traceSendMessage "$a0" "$a1")
    else
      (if: (![uint64T] (struct.field_ref raftpb.Message "To" "m")) = (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))
      then
        do:  (let: "$a0" := #(str "message should not be self-addressed when sending %s") in
        let: "$a1" := ((let: "$sl0" := (interface.make raftpb.MessageType__mset (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m"))) in
        slice.literal interfaceT ["$sl0"])) in
        (interface.get "Panicf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1")
      else do:  #());;;
      let: "$r0" := (let: "$a0" := (![sliceT raftpb.Message] (struct.field_ref raft "msgs" (![ptrT] "r"))) in
      let: "$a1" := ((let: "$sl0" := (![raftpb.Message] "m") in
      slice.literal raftpb.Message ["$sl0"])) in
      (slice.append (sliceT raftpb.Message)) "$a0" "$a1") in
      do:  ((struct.field_ref raft "msgs" (![ptrT] "r")) <-[sliceT raftpb.Message] "$r0");;;
      do:  (let: "$a0" := (![ptrT] "r") in
      let: "$a1" := "m" in
      traceSendMessage "$a0" "$a1"))).

(* maybeFirstIndex returns the index of the first possible entry in entries
   if it has a snapshot.

   go: log_unstable.go:54:20 *)
Definition unstable__maybeFirstIndex : val :=
  rec: "unstable__maybeFirstIndex" "u" <> :=
    exception_do (let: "u" := (ref_ty ptrT "u") in
    (if: (![ptrT] (struct.field_ref unstable "snapshot" (![ptrT] "u"))) ≠ #null
    then return: ((![uint64T] (struct.field_ref raftpb.SnapshotMetadata "Index" (struct.field_ref raftpb.Snapshot "Metadata" (![ptrT] (struct.field_ref unstable "snapshot" (![ptrT] "u")))))) + #(W64 1), #true)
    else do:  #());;;
    return: (#(W64 0), #false)).

(* go: log.go:300:19 *)
Definition raftLog__firstIndex : val :=
  rec: "raftLog__firstIndex" "l" <> :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    (let: "ok" := (ref_ty boolT (zero_val boolT)) in
    let: "i" := (ref_ty uint64T (zero_val uint64T)) in
    let: ("$ret0", "$ret1") := ((unstable__maybeFirstIndex (struct.field_ref raftLog "unstable" (![ptrT] "l"))) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("i" <-[uint64T] "$r0");;;
    do:  ("ok" <-[boolT] "$r1");;;
    (if: ![boolT] "ok"
    then return: (![uint64T] "i")
    else do:  #()));;;
    let: "err" := (ref_ty error (zero_val error)) in
    let: "index" := (ref_ty uint64T (zero_val uint64T)) in
    let: ("$ret0", "$ret1") := ((interface.get "FirstIndex" (![Storage] (struct.field_ref raftLog "storage" (![ptrT] "l")))) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("index" <-[uint64T] "$r0");;;
    do:  ("err" <-[error] "$r1");;;
    (if: (![error] "err") ≠ (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
    then
      do:  (let: "$a0" := (interface.make error__mset (![error] "err")) in
      Panic "$a0")
    else do:  #());;;
    return: (![uint64T] "index")).

(* IsEmptySnap returns true if the given Snapshot is empty.

   go: node.go:127:6 *)
Definition IsEmptySnap : val :=
  rec: "IsEmptySnap" "sp" :=
    exception_do (let: "sp" := (ref_ty raftpb.Snapshot "sp") in
    return: ((![uint64T] (struct.field_ref raftpb.SnapshotMetadata "Index" (struct.field_ref raftpb.Snapshot "Metadata" "sp"))) = #(W64 0))).

(* go: log.go:293:19 *)
Definition raftLog__snapshot : val :=
  rec: "raftLog__snapshot" "l" <> :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    (if: (![ptrT] (struct.field_ref unstable "snapshot" (struct.field_ref raftLog "unstable" (![ptrT] "l")))) ≠ #null
    then return: (![raftpb.Snapshot] (![ptrT] (struct.field_ref unstable "snapshot" (struct.field_ref raftLog "unstable" (![ptrT] "l")))), interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
    else do:  #());;;
    let: ("$ret0", "$ret1") := (((interface.get "Snapshot" (![Storage] (struct.field_ref raftLog "storage" (![ptrT] "l")))) #())) in
    return: ("$ret0", "$ret1")).

(* maybeSendSnapshot fetches a snapshot from Storage, and sends it to the given
   node. Returns true iff the snapshot message has been emitted successfully.

   go: raft.go:664:16 *)
Definition raft__maybeSendSnapshot : val :=
  rec: "raft__maybeSendSnapshot" "r" "to" "pr" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "pr" := (ref_ty ptrT "pr") in
    let: "to" := (ref_ty uint64T "to") in
    (if: (~ (![boolT] (struct.field_ref tracker.Progress "RecentActive" (![ptrT] "pr"))))
    then
      do:  (let: "$a0" := #(str "ignore sending snapshot to %x since it is not recently active") in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] "to")) in
      slice.literal interfaceT ["$sl0"])) in
      (interface.get "Debugf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
      return: (#false)
    else do:  #());;;
    let: "err" := (ref_ty error (zero_val error)) in
    let: "snapshot" := (ref_ty raftpb.Snapshot (zero_val raftpb.Snapshot)) in
    let: ("$ret0", "$ret1") := ((raftLog__snapshot (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("snapshot" <-[raftpb.Snapshot] "$r0");;;
    do:  ("err" <-[error] "$r1");;;
    (if: (![error] "err") ≠ (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
    then
      (if: (![error] "err") = (![error] "ErrSnapshotTemporarilyUnavailable")
      then
        do:  (let: "$a0" := #(str "%x failed to send snapshot to %x because snapshot is temporarily unavailable") in
        let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
        let: "$sl1" := (interface.make uint64__mset (![uint64T] "to")) in
        slice.literal interfaceT ["$sl0"; "$sl1"])) in
        (interface.get "Debugf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
        return: (#false)
      else do:  #());;;
      do:  (let: "$a0" := (interface.make error__mset (![error] "err")) in
      Panic "$a0")
    else do:  #());;;
    (if: let: "$a0" := (![raftpb.Snapshot] "snapshot") in
    IsEmptySnap "$a0"
    then
      do:  (let: "$a0" := (interface.make string__mset #(str "need non-empty snapshot")) in
      Panic "$a0")
    else do:  #());;;
    let: "sterm" := (ref_ty uint64T (zero_val uint64T)) in
    let: "sindex" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (![uint64T] (struct.field_ref raftpb.SnapshotMetadata "Index" (struct.field_ref raftpb.Snapshot "Metadata" "snapshot"))) in
    let: "$r1" := (![uint64T] (struct.field_ref raftpb.SnapshotMetadata "Term" (struct.field_ref raftpb.Snapshot "Metadata" "snapshot"))) in
    do:  ("sindex" <-[uint64T] "$r0");;;
    do:  ("sterm" <-[uint64T] "$r1");;;
    do:  (let: "$a0" := #(str "%x [firstindex: %d, commit: %d] sent snapshot[index: %d, term: %d] to %x [%s]") in
    let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
    let: "$sl1" := (interface.make uint64__mset ((raftLog__firstIndex (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #())) in
    let: "$sl2" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))))) in
    let: "$sl3" := (interface.make uint64__mset (![uint64T] "sindex")) in
    let: "$sl4" := (interface.make uint64__mset (![uint64T] "sterm")) in
    let: "$sl5" := (interface.make uint64__mset (![uint64T] "to")) in
    let: "$sl6" := (interface.make tracker.Progress__mset_ptr (![ptrT] "pr")) in
    slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"; "$sl4"; "$sl5"; "$sl6"])) in
    (interface.get "Debugf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
    do:  (let: "$a0" := (![uint64T] "sindex") in
    (tracker.Progress__BecomeSnapshot (![ptrT] "pr")) "$a0");;;
    do:  (let: "$a0" := #(str "%x paused sending replication messages to %x [%s]") in
    let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
    let: "$sl1" := (interface.make uint64__mset (![uint64T] "to")) in
    let: "$sl2" := (interface.make tracker.Progress__mset_ptr (![ptrT] "pr")) in
    slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
    (interface.get "Debugf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
    do:  (let: "$a0" := (struct.make raftpb.Message [{
      "To" ::= ![uint64T] "to";
      "Type" ::= raftpb.MsgSnap;
      "Snapshot" ::= "snapshot"
    }]) in
    (raft__send (![ptrT] "r")) "$a0");;;
    return: (#true)).

(* extend appends vals to the given dst slice. It differs from the standard
   slice append only in the way it allocates memory. If cap(dst) is not enough
   for appending the values, precisely size len(dst)+len(vals) is allocated.

   Use this instead of standard append in situations when this is the last
   append to dst, so there is no sense in allocating more than needed.

   go: util.go:316:6 *)
Definition extend : val :=
  rec: "extend" "dst" "vals" :=
    exception_do (let: "vals" := (ref_ty (sliceT raftpb.Entry) "vals") in
    let: "dst" := (ref_ty (sliceT raftpb.Entry) "dst") in
    let: "need" := (ref_ty intT (zero_val intT)) in
    let: "$r0" := ((let: "$a0" := (![sliceT raftpb.Entry] "dst") in
    slice.len "$a0") + (let: "$a0" := (![sliceT raftpb.Entry] "vals") in
    slice.len "$a0")) in
    do:  ("need" <-[intT] "$r0");;;
    (if: int_leq (![intT] "need") (let: "$a0" := (![sliceT raftpb.Entry] "dst") in
    slice.cap "$a0")
    then
      return: (let: "$a0" := (![sliceT raftpb.Entry] "dst") in
       let: "$a1" := (![sliceT raftpb.Entry] "vals") in
       (slice.append (sliceT raftpb.Entry)) "$a0" "$a1")
    else do:  #());;;
    let: "buf" := (ref_ty (sliceT raftpb.Entry) (zero_val (sliceT raftpb.Entry))) in
    let: "$r0" := (slice.make3 raftpb.Entry (![intT] "need") (![intT] "need")) in
    do:  ("buf" <-[sliceT raftpb.Entry] "$r0");;;
    do:  (let: "$a0" := (![sliceT raftpb.Entry] "buf") in
    let: "$a1" := (![sliceT raftpb.Entry] "dst") in
    (slice.copy raftpb.Entry) "$a0" "$a1");;;
    do:  (let: "$a0" := (let: "$s" := (![sliceT raftpb.Entry] "buf") in
    slice.slice raftpb.Entry "$s" (let: "$a0" := (![sliceT raftpb.Entry] "dst") in
    slice.len "$a0") (slice.len "$s")) in
    let: "$a1" := (![sliceT raftpb.Entry] "vals") in
    (slice.copy raftpb.Entry) "$a0" "$a1");;;
    return: (![sliceT raftpb.Entry] "buf")).

(* go: util.go:256:6 *)
Definition entsSize : val :=
  rec: "entsSize" "ents" :=
    exception_do (let: "ents" := (ref_ty (sliceT raftpb.Entry) "ents") in
    let: "size" := (ref_ty entryEncodingSize (zero_val entryEncodingSize)) in
    do:  (let: "$range" := (![sliceT raftpb.Entry] "ents") in
    slice.for_range raftpb.Entry "$range" (λ: <> "ent",
      let: "ent" := ref_ty raftpb.Entry "ent" in
      do:  ("size" <-[entryEncodingSize] ((![entryEncodingSize] "size") + ((raftpb.Entry__Size "ent") #())))));;;
    return: (![entryEncodingSize] "size")).

(* limitSize returns the longest prefix of the given entries slice, such that
   its total byte size does not exceed maxSize. Always returns a non-empty slice
   if the input is non-empty, so, as an exception, if the size of the first
   entry exceeds maxSize, a non-empty slice with just this entry is returned.

   go: util.go:268:6 *)
Definition limitSize : val :=
  rec: "limitSize" "ents" "maxSize" :=
    exception_do (let: "maxSize" := (ref_ty entryEncodingSize "maxSize") in
    let: "ents" := (ref_ty (sliceT raftpb.Entry) "ents") in
    (if: (let: "$a0" := (![sliceT raftpb.Entry] "ents") in
    slice.len "$a0") = #(W64 0)
    then return: (![sliceT raftpb.Entry] "ents")
    else do:  #());;;
    let: "size" := (ref_ty intT (zero_val intT)) in
    let: "$r0" := ((raftpb.Entry__Size (slice.elem_ref raftpb.Entry (![sliceT raftpb.Entry] "ents") #(W64 0))) #()) in
    do:  ("size" <-[intT] "$r0");;;
    (let: "limit" := (ref_ty intT (zero_val intT)) in
    let: "$r0" := #(W64 1) in
    do:  ("limit" <-[intT] "$r0");;;
    (for: (λ: <>, int_lt (![intT] "limit") (let: "$a0" := (![sliceT raftpb.Entry] "ents") in
    slice.len "$a0")); (λ: <>, do:  ("limit" <-[intT] ((![intT] "limit") + #(W64 1)))) := λ: <>,
      do:  ("size" <-[intT] ((![intT] "size") + ((raftpb.Entry__Size (slice.elem_ref raftpb.Entry (![sliceT raftpb.Entry] "ents") (![intT] "limit"))) #())));;;
      (if: (![intT] "size") > (![entryEncodingSize] "maxSize")
      then
        return: (let: "$s" := (![sliceT raftpb.Entry] "ents") in
         slice.slice raftpb.Entry "$s" #(W64 0) (![intT] "limit"))
      else do:  #())));;;
    return: (![sliceT raftpb.Entry] "ents")).

(* u.offset <= lo <= hi <= u.offset+len(u.entries)

   go: log_unstable.go:238:20 *)
Definition unstable__mustCheckOutOfBounds : val :=
  rec: "unstable__mustCheckOutOfBounds" "u" "lo" "hi" :=
    exception_do (let: "u" := (ref_ty ptrT "u") in
    let: "hi" := (ref_ty uint64T "hi") in
    let: "lo" := (ref_ty uint64T "lo") in
    (if: (![uint64T] "lo") > (![uint64T] "hi")
    then
      do:  (let: "$a0" := #(str "invalid unstable.slice %d > %d") in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] "lo")) in
      let: "$sl1" := (interface.make uint64__mset (![uint64T] "hi")) in
      slice.literal interfaceT ["$sl0"; "$sl1"])) in
      (interface.get "Panicf" (![Logger] (struct.field_ref unstable "logger" (![ptrT] "u")))) "$a0" "$a1")
    else do:  #());;;
    let: "upper" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := ((![uint64T] (struct.field_ref unstable "offset" (![ptrT] "u"))) + (let: "$a0" := (![sliceT raftpb.Entry] (struct.field_ref unstable "entries" (![ptrT] "u"))) in
    slice.len "$a0")) in
    do:  ("upper" <-[uint64T] "$r0");;;
    (if: ((![uint64T] "lo") < (![uint64T] (struct.field_ref unstable "offset" (![ptrT] "u")))) || ((![uint64T] "hi") > (![uint64T] "upper"))
    then
      do:  (let: "$a0" := #(str "unstable.slice[%d,%d) out of bound [%d,%d]") in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] "lo")) in
      let: "$sl1" := (interface.make uint64__mset (![uint64T] "hi")) in
      let: "$sl2" := (interface.make uint64__mset (![uint64T] (struct.field_ref unstable "offset" (![ptrT] "u")))) in
      let: "$sl3" := (interface.make uint64__mset (![uint64T] "upper")) in
      slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"])) in
      (interface.get "Panicf" (![Logger] (struct.field_ref unstable "logger" (![ptrT] "u")))) "$a0" "$a1")
    else do:  #())).

(* slice returns the entries from the unstable log with indexes in the range
   [lo, hi). The entire range must be stored in the unstable log or the method
   will panic. The returned slice can be appended to, but the entries in it must
   not be changed because they are still shared with unstable.

   TODO(pavelkalinnikov): this, and similar []raftpb.Entry slices, may bubble up all
   the way to the application code through Ready struct. Protect other slices
   similarly, and document how the client can use them.

   go: log_unstable.go:229:20 *)
Definition unstable__slice : val :=
  rec: "unstable__slice" "u" "lo" "hi" :=
    exception_do (let: "u" := (ref_ty ptrT "u") in
    let: "hi" := (ref_ty uint64T "hi") in
    let: "lo" := (ref_ty uint64T "lo") in
    do:  (let: "$a0" := (![uint64T] "lo") in
    let: "$a1" := (![uint64T] "hi") in
    (unstable__mustCheckOutOfBounds (![ptrT] "u")) "$a0" "$a1");;;
    return: (let: "$s" := (![sliceT raftpb.Entry] (struct.field_ref unstable "entries" (![ptrT] "u"))) in
     slice.full_slice raftpb.Entry "$s" ((![uint64T] "lo") - (![uint64T] (struct.field_ref unstable "offset" (![ptrT] "u")))) ((![uint64T] "hi") - (![uint64T] (struct.field_ref unstable "offset" (![ptrT] "u")))) ((![uint64T] "hi") - (![uint64T] (struct.field_ref unstable "offset" (![ptrT] "u")))))).

(* maybeLastIndex returns the last index if it has at least one
   unstable entry or snapshot.

   go: log_unstable.go:63:20 *)
Definition unstable__maybeLastIndex : val :=
  rec: "unstable__maybeLastIndex" "u" <> :=
    exception_do (let: "u" := (ref_ty ptrT "u") in
    (let: "l" := (ref_ty intT (zero_val intT)) in
    let: "$r0" := (let: "$a0" := (![sliceT raftpb.Entry] (struct.field_ref unstable "entries" (![ptrT] "u"))) in
    slice.len "$a0") in
    do:  ("l" <-[intT] "$r0");;;
    (if: (![intT] "l") ≠ #(W64 0)
    then return: (((![uint64T] (struct.field_ref unstable "offset" (![ptrT] "u"))) + (![intT] "l")) - #(W64 1), #true)
    else do:  #()));;;
    (if: (![ptrT] (struct.field_ref unstable "snapshot" (![ptrT] "u"))) ≠ #null
    then return: (![uint64T] (struct.field_ref raftpb.SnapshotMetadata "Index" (struct.field_ref raftpb.Snapshot "Metadata" (![ptrT] (struct.field_ref unstable "snapshot" (![ptrT] "u"))))), #true)
    else do:  #());;;
    return: (#(W64 0), #false)).

(* go: log.go:311:19 *)
Definition raftLog__lastIndex : val :=
  rec: "raftLog__lastIndex" "l" <> :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    (let: "ok" := (ref_ty boolT (zero_val boolT)) in
    let: "i" := (ref_ty uint64T (zero_val uint64T)) in
    let: ("$ret0", "$ret1") := ((unstable__maybeLastIndex (struct.field_ref raftLog "unstable" (![ptrT] "l"))) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("i" <-[uint64T] "$r0");;;
    do:  ("ok" <-[boolT] "$r1");;;
    (if: ![boolT] "ok"
    then return: (![uint64T] "i")
    else do:  #()));;;
    let: "err" := (ref_ty error (zero_val error)) in
    let: "i" := (ref_ty uint64T (zero_val uint64T)) in
    let: ("$ret0", "$ret1") := ((interface.get "LastIndex" (![Storage] (struct.field_ref raftLog "storage" (![ptrT] "l")))) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("i" <-[uint64T] "$r0");;;
    do:  ("err" <-[error] "$r1");;;
    (if: (![error] "err") ≠ (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
    then
      do:  (let: "$a0" := (interface.make error__mset (![error] "err")) in
      Panic "$a0")
    else do:  #());;;
    return: (![uint64T] "i")).

(* l.firstIndex <= lo <= hi <= l.firstIndex + len(l.entries)

   go: log.go:551:19 *)
Definition raftLog__mustCheckOutOfBounds : val :=
  rec: "raftLog__mustCheckOutOfBounds" "l" "lo" "hi" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "hi" := (ref_ty uint64T "hi") in
    let: "lo" := (ref_ty uint64T "lo") in
    (if: (![uint64T] "lo") > (![uint64T] "hi")
    then
      do:  (let: "$a0" := #(str "invalid slice %d > %d") in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] "lo")) in
      let: "$sl1" := (interface.make uint64__mset (![uint64T] "hi")) in
      slice.literal interfaceT ["$sl0"; "$sl1"])) in
      (interface.get "Panicf" (![Logger] (struct.field_ref raftLog "logger" (![ptrT] "l")))) "$a0" "$a1")
    else do:  #());;;
    let: "fi" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := ((raftLog__firstIndex (![ptrT] "l")) #()) in
    do:  ("fi" <-[uint64T] "$r0");;;
    (if: (![uint64T] "lo") < (![uint64T] "fi")
    then return: (![error] "ErrCompacted")
    else do:  #());;;
    let: "length" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := ((((raftLog__lastIndex (![ptrT] "l")) #()) + #(W64 1)) - (![uint64T] "fi")) in
    do:  ("length" <-[uint64T] "$r0");;;
    (if: (![uint64T] "hi") > ((![uint64T] "fi") + (![uint64T] "length"))
    then
      do:  (let: "$a0" := #(str "slice[%d,%d) out of bound [%d,%d]") in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] "lo")) in
      let: "$sl1" := (interface.make uint64__mset (![uint64T] "hi")) in
      let: "$sl2" := (interface.make uint64__mset (![uint64T] "fi")) in
      let: "$sl3" := (interface.make uint64__mset ((raftLog__lastIndex (![ptrT] "l")) #())) in
      slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"])) in
      (interface.get "Panicf" (![Logger] (struct.field_ref raftLog "logger" (![ptrT] "l")))) "$a0" "$a1")
    else do:  #());;;
    return: (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)).

(* slice returns a slice of log entries from lo through hi-1, inclusive.

   go: log.go:499:19 *)
Definition raftLog__slice : val :=
  rec: "raftLog__slice" "l" "lo" "hi" "maxSize" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "maxSize" := (ref_ty entryEncodingSize "maxSize") in
    let: "hi" := (ref_ty uint64T "hi") in
    let: "lo" := (ref_ty uint64T "lo") in
    (let: "err" := (ref_ty error (zero_val error)) in
    let: "$r0" := (let: "$a0" := (![uint64T] "lo") in
    let: "$a1" := (![uint64T] "hi") in
    (raftLog__mustCheckOutOfBounds (![ptrT] "l")) "$a0" "$a1") in
    do:  ("err" <-[error] "$r0");;;
    (if: (![error] "err") ≠ (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
    then return: (slice.nil, ![error] "err")
    else do:  #()));;;
    (if: (![uint64T] "lo") = (![uint64T] "hi")
    then return: (slice.nil, interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
    else do:  #());;;
    (if: (![uint64T] "lo") ≥ (![uint64T] (struct.field_ref unstable "offset" (struct.field_ref raftLog "unstable" (![ptrT] "l"))))
    then
      let: "ents" := (ref_ty (sliceT raftpb.Entry) (zero_val (sliceT raftpb.Entry))) in
      let: "$r0" := (let: "$a0" := (let: "$a0" := (![uint64T] "lo") in
      let: "$a1" := (![uint64T] "hi") in
      (unstable__slice (struct.field_ref raftLog "unstable" (![ptrT] "l"))) "$a0" "$a1") in
      let: "$a1" := (![entryEncodingSize] "maxSize") in
      limitSize "$a0" "$a1") in
      do:  ("ents" <-[sliceT raftpb.Entry] "$r0");;;
      return: (let: "$s" := (![sliceT raftpb.Entry] "ents") in
       slice.full_slice raftpb.Entry "$s" #(W64 0) (let: "$a0" := (![sliceT raftpb.Entry] "ents") in
       slice.len "$a0") (let: "$a0" := (![sliceT raftpb.Entry] "ents") in
       slice.len "$a0"), interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
    else do:  #());;;
    let: "cut" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (let: "$a0" := (![uint64T] "hi") in
    let: "$a1" := (![uint64T] (struct.field_ref unstable "offset" (struct.field_ref raftLog "unstable" (![ptrT] "l")))) in
    (minUint64 2) "$a0" "$a1") in
    do:  ("cut" <-[uint64T] "$r0");;;
    let: "err" := (ref_ty error (zero_val error)) in
    let: "ents" := (ref_ty (sliceT raftpb.Entry) (zero_val (sliceT raftpb.Entry))) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![uint64T] "lo") in
    let: "$a1" := (![uint64T] "cut") in
    let: "$a2" := (![entryEncodingSize] "maxSize") in
    (interface.get "Entries" (![Storage] (struct.field_ref raftLog "storage" (![ptrT] "l")))) "$a0" "$a1" "$a2") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("ents" <-[sliceT raftpb.Entry] "$r0");;;
    do:  ("err" <-[error] "$r1");;;
    (if: (![error] "err") = (![error] "ErrCompacted")
    then return: (slice.nil, ![error] "err")
    else
      (if: (![error] "err") = (![error] "ErrUnavailable")
      then
        do:  (let: "$a0" := #(str "entries[%d:%d) is unavailable from storage") in
        let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] "lo")) in
        let: "$sl1" := (interface.make uint64__mset (![uint64T] "cut")) in
        slice.literal interfaceT ["$sl0"; "$sl1"])) in
        (interface.get "Panicf" (![Logger] (struct.field_ref raftLog "logger" (![ptrT] "l")))) "$a0" "$a1")
      else
        (if: (![error] "err") ≠ (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
        then
          do:  (let: "$a0" := (interface.make error__mset (![error] "err")) in
          Panic "$a0")
        else do:  #())));;;
    (if: (![uint64T] "hi") ≤ (![uint64T] (struct.field_ref unstable "offset" (struct.field_ref raftLog "unstable" (![ptrT] "l"))))
    then return: (![sliceT raftpb.Entry] "ents", interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
    else do:  #());;;
    (if: (let: "$a0" := (![sliceT raftpb.Entry] "ents") in
    slice.len "$a0") < ((![uint64T] "cut") - (![uint64T] "lo"))
    then return: (![sliceT raftpb.Entry] "ents", interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
    else do:  #());;;
    let: "size" := (ref_ty entryEncodingSize (zero_val entryEncodingSize)) in
    let: "$r0" := (let: "$a0" := (![sliceT raftpb.Entry] "ents") in
    entsSize "$a0") in
    do:  ("size" <-[entryEncodingSize] "$r0");;;
    (if: (![entryEncodingSize] "size") ≥ (![entryEncodingSize] "maxSize")
    then return: (![sliceT raftpb.Entry] "ents", interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
    else do:  #());;;
    let: "unstable" := (ref_ty (sliceT raftpb.Entry) (zero_val (sliceT raftpb.Entry))) in
    let: "$r0" := (let: "$a0" := (let: "$a0" := (![uint64T] (struct.field_ref unstable "offset" (struct.field_ref raftLog "unstable" (![ptrT] "l")))) in
    let: "$a1" := (![uint64T] "hi") in
    (unstable__slice (struct.field_ref raftLog "unstable" (![ptrT] "l"))) "$a0" "$a1") in
    let: "$a1" := ((![entryEncodingSize] "maxSize") - (![entryEncodingSize] "size")) in
    limitSize "$a0" "$a1") in
    do:  ("unstable" <-[sliceT raftpb.Entry] "$r0");;;
    (if: ((let: "$a0" := (![sliceT raftpb.Entry] "unstable") in
    slice.len "$a0") = #(W64 1)) && (((![entryEncodingSize] "size") + (let: "$a0" := (![sliceT raftpb.Entry] "unstable") in
    entsSize "$a0")) > (![entryEncodingSize] "maxSize"))
    then return: (![sliceT raftpb.Entry] "ents", interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
    else do:  #());;;
    return: (let: "$a0" := (![sliceT raftpb.Entry] "ents") in
     let: "$a1" := (![sliceT raftpb.Entry] "unstable") in
     extend "$a0" "$a1", interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)).

(* go: log.go:415:19 *)
Definition raftLog__entries : val :=
  rec: "raftLog__entries" "l" "i" "maxSize" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "maxSize" := (ref_ty entryEncodingSize "maxSize") in
    let: "i" := (ref_ty uint64T "i") in
    (if: (![uint64T] "i") > ((raftLog__lastIndex (![ptrT] "l")) #())
    then return: (slice.nil, interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
    else do:  #());;;
    let: ("$ret0", "$ret1") := ((let: "$a0" := (![uint64T] "i") in
    let: "$a1" := (((raftLog__lastIndex (![ptrT] "l")) #()) + #(W64 1)) in
    let: "$a2" := (![entryEncodingSize] "maxSize") in
    (raftLog__slice (![ptrT] "l")) "$a0" "$a1" "$a2")) in
    return: ("$ret0", "$ret1")).

(* maybeTerm returns the term of the entry at index i, if there
   is any.

   go: log_unstable.go:75:20 *)
Definition unstable__maybeTerm : val :=
  rec: "unstable__maybeTerm" "u" "i" :=
    exception_do (let: "u" := (ref_ty ptrT "u") in
    let: "i" := (ref_ty uint64T "i") in
    (if: (![uint64T] "i") < (![uint64T] (struct.field_ref unstable "offset" (![ptrT] "u")))
    then
      (if: ((![ptrT] (struct.field_ref unstable "snapshot" (![ptrT] "u"))) ≠ #null) && ((![uint64T] (struct.field_ref raftpb.SnapshotMetadata "Index" (struct.field_ref raftpb.Snapshot "Metadata" (![ptrT] (struct.field_ref unstable "snapshot" (![ptrT] "u")))))) = (![uint64T] "i"))
      then return: (![uint64T] (struct.field_ref raftpb.SnapshotMetadata "Term" (struct.field_ref raftpb.Snapshot "Metadata" (![ptrT] (struct.field_ref unstable "snapshot" (![ptrT] "u"))))), #true)
      else do:  #());;;
      return: (#(W64 0), #false)
    else do:  #());;;
    let: "ok" := (ref_ty boolT (zero_val boolT)) in
    let: "last" := (ref_ty uint64T (zero_val uint64T)) in
    let: ("$ret0", "$ret1") := ((unstable__maybeLastIndex (![ptrT] "u")) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("last" <-[uint64T] "$r0");;;
    do:  ("ok" <-[boolT] "$r1");;;
    (if: (~ (![boolT] "ok"))
    then return: (#(W64 0), #false)
    else do:  #());;;
    (if: (![uint64T] "i") > (![uint64T] "last")
    then return: (#(W64 0), #false)
    else do:  #());;;
    return: (![uint64T] (struct.field_ref raftpb.Entry "Term" (slice.elem_ref raftpb.Entry (![sliceT raftpb.Entry] (struct.field_ref unstable "entries" (![ptrT] "u"))) ((![uint64T] "i") - (![uint64T] (struct.field_ref unstable "offset" (![ptrT] "u")))))), #true)).

(* go: log.go:387:19 *)
Definition raftLog__term : val :=
  rec: "raftLog__term" "l" "i" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "i" := (ref_ty uint64T "i") in
    (let: "ok" := (ref_ty boolT (zero_val boolT)) in
    let: "t" := (ref_ty uint64T (zero_val uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![uint64T] "i") in
    (unstable__maybeTerm (struct.field_ref raftLog "unstable" (![ptrT] "l"))) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("t" <-[uint64T] "$r0");;;
    do:  ("ok" <-[boolT] "$r1");;;
    (if: ![boolT] "ok"
    then return: (![uint64T] "t", interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
    else do:  #()));;;
    (if: ((![uint64T] "i") + #(W64 1)) < ((raftLog__firstIndex (![ptrT] "l")) #())
    then return: (#(W64 0), ![error] "ErrCompacted")
    else do:  #());;;
    (if: (![uint64T] "i") > ((raftLog__lastIndex (![ptrT] "l")) #())
    then return: (#(W64 0), ![error] "ErrUnavailable")
    else do:  #());;;
    let: "err" := (ref_ty error (zero_val error)) in
    let: "t" := (ref_ty uint64T (zero_val uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![uint64T] "i") in
    (interface.get "Term" (![Storage] (struct.field_ref raftLog "storage" (![ptrT] "l")))) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("t" <-[uint64T] "$r0");;;
    do:  ("err" <-[error] "$r1");;;
    (if: (![error] "err") = (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
    then return: (![uint64T] "t", interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
    else do:  #());;;
    (if: ((![error] "err") = (![error] "ErrCompacted")) || ((![error] "err") = (![error] "ErrUnavailable"))
    then return: (#(W64 0), ![error] "err")
    else do:  #());;;
    do:  (let: "$a0" := (interface.make error__mset (![error] "err")) in
    Panic "$a0")).

(* maybeSendAppend sends an append RPC with new entries to the given peer,
   if necessary. Returns true if a message was sent. The sendIfEmpty
   argument controls whether messages with no entries will be sent
   ("empty" messages are useful to convey updated Commit indexes, but
   are undesirable when we're sending multiple messages in a batch).

   TODO(pav-kv): make invocation of maybeSendAppend stateless. The Progress
   struct contains all the state necessary for deciding whether to send a
   message.

   go: raft.go:616:16 *)
Definition raft__maybeSendAppend : val :=
  rec: "raft__maybeSendAppend" "r" "to" "sendIfEmpty" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "sendIfEmpty" := (ref_ty boolT "sendIfEmpty") in
    let: "to" := (ref_ty uint64T "to") in
    let: "pr" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (Fst (map.get (![tracker.ProgressMap] (struct.field_ref tracker.ProgressTracker "Progress" (struct.field_ref raft "trk" (![ptrT] "r")))) (![uint64T] "to"))) in
    do:  ("pr" <-[ptrT] "$r0");;;
    (if: (tracker.Progress__IsPaused (![ptrT] "pr")) #()
    then return: (#false)
    else do:  #());;;
    let: "prevIndex" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := ((![uint64T] (struct.field_ref tracker.Progress "Next" (![ptrT] "pr"))) - #(W64 1)) in
    do:  ("prevIndex" <-[uint64T] "$r0");;;
    let: "err" := (ref_ty error (zero_val error)) in
    let: "prevTerm" := (ref_ty uint64T (zero_val uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![uint64T] "prevIndex") in
    (raftLog__term (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("prevTerm" <-[uint64T] "$r0");;;
    do:  ("err" <-[error] "$r1");;;
    (if: (![error] "err") ≠ (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
    then
      return: (let: "$a0" := (![uint64T] "to") in
       let: "$a1" := (![ptrT] "pr") in
       (raft__maybeSendSnapshot (![ptrT] "r")) "$a0" "$a1")
    else do:  #());;;
    let: "ents" := (ref_ty (sliceT raftpb.Entry) (zero_val (sliceT raftpb.Entry))) in
    (if: ((![tracker.StateType] (struct.field_ref tracker.Progress "State" (![ptrT] "pr"))) ≠ tracker.StateReplicate) || (~ ((tracker.Inflights__Full (![ptrT] (struct.field_ref tracker.Progress "Inflights" (![ptrT] "pr")))) #()))
    then
      let: ("$ret0", "$ret1") := (let: "$a0" := (![uint64T] (struct.field_ref tracker.Progress "Next" (![ptrT] "pr"))) in
      let: "$a1" := (![entryEncodingSize] (struct.field_ref raft "maxMsgSize" (![ptrT] "r"))) in
      (raftLog__entries (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) "$a0" "$a1") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("ents" <-[sliceT raftpb.Entry] "$r0");;;
      do:  ("err" <-[error] "$r1")
    else do:  #());;;
    (if: ((let: "$a0" := (![sliceT raftpb.Entry] "ents") in
    slice.len "$a0") = #(W64 0)) && (~ (![boolT] "sendIfEmpty"))
    then return: (#false)
    else do:  #());;;
    (if: (![error] "err") ≠ (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
    then
      return: (let: "$a0" := (![uint64T] "to") in
       let: "$a1" := (![ptrT] "pr") in
       (raft__maybeSendSnapshot (![ptrT] "r")) "$a0" "$a1")
    else do:  #());;;
    do:  (let: "$a0" := (struct.make raftpb.Message [{
      "To" ::= ![uint64T] "to";
      "Type" ::= raftpb.MsgApp;
      "Index" ::= ![uint64T] "prevIndex";
      "LogTerm" ::= ![uint64T] "prevTerm";
      "Entries" ::= ![sliceT raftpb.Entry] "ents";
      "Commit" ::= ![uint64T] (struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r"))))
    }]) in
    (raft__send (![ptrT] "r")) "$a0");;;
    do:  (let: "$a0" := (let: "$a0" := (![sliceT raftpb.Entry] "ents") in
    slice.len "$a0") in
    let: "$a1" := (let: "$a0" := (![sliceT raftpb.Entry] "ents") in
    payloadsSize "$a0") in
    (tracker.Progress__SentEntries (![ptrT] "pr")) "$a0" "$a1");;;
    do:  (let: "$a0" := (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r"))))) in
    (tracker.Progress__SentCommit (![ptrT] "pr")) "$a0");;;
    return: (#true)).

Definition entryID : go_type := structT [
  "term" :: uint64T;
  "index" :: uint64T
]%struct.

(* go: log.go:447:19 *)
Definition raftLog__matchTerm : val :=
  rec: "raftLog__matchTerm" "l" "id" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "id" := (ref_ty entryID "id") in
    let: "err" := (ref_ty error (zero_val error)) in
    let: "t" := (ref_ty uint64T (zero_val uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![uint64T] (struct.field_ref entryID "index" "id")) in
    (raftLog__term (![ptrT] "l")) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("t" <-[uint64T] "$r0");;;
    do:  ("err" <-[error] "$r1");;;
    (if: (![error] "err") ≠ (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
    then return: (#false)
    else do:  #());;;
    return: ((![uint64T] "t") = (![uint64T] (struct.field_ref entryID "term" "id")))).

(* go: log.go:322:19 *)
Definition raftLog__commitTo : val :=
  rec: "raftLog__commitTo" "l" "tocommit" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "tocommit" := (ref_ty uint64T "tocommit") in
    (if: (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] "l"))) < (![uint64T] "tocommit")
    then
      (if: ((raftLog__lastIndex (![ptrT] "l")) #()) < (![uint64T] "tocommit")
      then
        do:  (let: "$a0" := #(str "tocommit(%d) is out of range [lastIndex(%d)]. Was the raft log corrupted, truncated, or lost?") in
        let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] "tocommit")) in
        let: "$sl1" := (interface.make uint64__mset ((raftLog__lastIndex (![ptrT] "l")) #())) in
        slice.literal interfaceT ["$sl0"; "$sl1"])) in
        (interface.get "Panicf" (![Logger] (struct.field_ref raftLog "logger" (![ptrT] "l")))) "$a0" "$a1")
      else do:  #());;;
      let: "$r0" := (![uint64T] "tocommit") in
      do:  ((struct.field_ref raftLog "committed" (![ptrT] "l")) <-[uint64T] "$r0")
    else do:  #())).

(* go: log.go:455:19 *)
Definition raftLog__maybeCommit : val :=
  rec: "raftLog__maybeCommit" "l" "at" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "at" := (ref_ty entryID "at") in
    (if: (((![uint64T] (struct.field_ref entryID "term" "at")) ≠ #(W64 0)) && ((![uint64T] (struct.field_ref entryID "index" "at")) > (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] "l"))))) && (let: "$a0" := (![entryID] "at") in
    (raftLog__matchTerm (![ptrT] "l")) "$a0")
    then
      do:  (let: "$a0" := (![uint64T] (struct.field_ref entryID "index" "at")) in
      (raftLog__commitTo (![ptrT] "l")) "$a0");;;
      return: (#true)
    else do:  #());;;
    return: (#false)).

(* go: state_trace_nop.go:34:6 *)
Definition traceCommit : val :=
  rec: "traceCommit" "" :=
    exception_do (let: "" := (ref_ty ptrT "") in
    do:  #()).

(* maybeCommit attempts to advance the commit index. Returns true if the commit
   index changed (in which case the caller should call r.bcastAppend). This can
   only be called in StateLeader.

   go: raft.go:778:16 *)
Definition raft__maybeCommit : val :=
  rec: "raft__maybeCommit" "r" <> :=
    with_defer: (let: "r" := (ref_ty ptrT "r") in
    do:  (let: "$a0" := (![ptrT] "r") in
    let: "$f" := traceCommit in
    "$defer" <-[funcT] (let: "$oldf" := (![funcT] "$defer") in
    (λ: <>,
      "$f" "a0";;
      "$oldf" #()
      )));;;
    return: (let: "$a0" := (struct.make entryID [{
       "term" ::= ![uint64T] (struct.field_ref raft "Term" (![ptrT] "r"));
       "index" ::= (tracker.ProgressTracker__Committed (struct.field_ref raft "trk" (![ptrT] "r"))) #()
     }]) in
     (raftLog__maybeCommit (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) "$a0")).

(* sendAppend sends an append RPC with new entries (if any) and the
   current commit index to the given peer.

   go: raft.go:603:16 *)
Definition raft__sendAppend : val :=
  rec: "raft__sendAppend" "r" "to" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "to" := (ref_ty uint64T "to") in
    do:  (let: "$a0" := (![uint64T] "to") in
    let: "$a1" := #true in
    (raft__maybeSendAppend (![ptrT] "r")) "$a0" "$a1")).

(* bcastAppend sends RPC, with entries to all peers that are not up-to-date
   according to the progress recorded in r.trk.

   go: raft.go:712:16 *)
Definition raft__bcastAppend : val :=
  rec: "raft__bcastAppend" "r" <> :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    do:  (let: "$a0" := (λ: "id" <>,
      exception_do (let: <> := (ref_ty ptrT "_") in
      let: "id" := (ref_ty uint64T "id") in
      (if: (![uint64T] "id") = (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))
      then return: (#())
      else do:  #());;;
      do:  (let: "$a0" := (![uint64T] "id") in
      (raft__sendAppend (![ptrT] "r")) "$a0"))
      ) in
    (tracker.ProgressTracker__Visit (struct.field_ref raft "trk" (![ptrT] "r"))) "$a0")).

Definition StateLeader : expr := #(W64 2).

(* go: state_trace_nop.go:38:6 *)
Definition traceBecomeFollower : val :=
  rec: "traceBecomeFollower" "" :=
    exception_do (let: "" := (ref_ty ptrT "") in
    do:  #()).

Definition StateFollower : expr := #(W64 0).

(* hasNextOrInProgressSnapshot returns if there is pending snapshot waiting for
   applying or in the process of being applied.

   go: log.go:289:19 *)
Definition raftLog__hasNextOrInProgressSnapshot : val :=
  rec: "raftLog__hasNextOrInProgressSnapshot" "l" <> :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    return: ((![ptrT] (struct.field_ref unstable "snapshot" (struct.field_ref raftLog "unstable" (![ptrT] "l")))) ≠ #null)).

(* promotable indicates whether state machine can be promoted to leader,
   which is true when its own id is in progress list.

   go: raft.go:1944:16 *)
Definition raft__promotable : val :=
  rec: "raft__promotable" "r" <> :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "pr" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (Fst (map.get (![tracker.ProgressMap] (struct.field_ref tracker.ProgressTracker "Progress" (struct.field_ref raft "trk" (![ptrT] "r")))) (![uint64T] (struct.field_ref raft "id" (![ptrT] "r"))))) in
    do:  ("pr" <-[ptrT] "$r0");;;
    return: ((((![ptrT] "pr") ≠ #null) && (~ (![boolT] (struct.field_ref tracker.Progress "IsLearner" (![ptrT] "pr"))))) && (~ ((raftLog__hasNextOrInProgressSnapshot (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #())))).

(* pastElectionTimeout returns true if r.electionElapsed is greater
   than or equal to the randomized election timeout in
   [electiontimeout, 2 * electiontimeout - 1].

   go: raft.go:2047:16 *)
Definition raft__pastElectionTimeout : val :=
  rec: "raft__pastElectionTimeout" "r" <> :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    return: (int_geq (![intT] (struct.field_ref raft "electionElapsed" (![ptrT] "r"))) (![intT] (struct.field_ref raft "randomizedElectionTimeout" (![ptrT] "r"))))).

(* voteResponseType maps vote and prevote message types to their corresponding responses.

   go: util.go:70:6 *)
Definition voteRespMsgType : val :=
  rec: "voteRespMsgType" "msgt" :=
    exception_do (let: "msgt" := (ref_ty raftpb.MessageType "msgt") in
    let: "$sw" := (![raftpb.MessageType] "msgt") in
    (if: "$sw" = raftpb.MsgVote
    then return: (raftpb.MsgVoteResp)
    else
      (if: "$sw" = raftpb.MsgPreVote
      then return: (raftpb.MsgPreVoteResp)
      else
        do:  (let: "$a0" := (interface.make string__mset (let: "$a0" := #(str "not a vote message: %s") in
        let: "$a1" := ((let: "$sl0" := (interface.make raftpb.MessageType__mset (![raftpb.MessageType] "msgt")) in
        slice.literal interfaceT ["$sl0"])) in
        fmt.Sprintf "$a0" "$a1")) in
        Panic "$a0")))).

(* lastEntryID returns the ID of the last entry in the log.

   go: log.go:378:19 *)
Definition raftLog__lastEntryID : val :=
  rec: "raftLog__lastEntryID" "l" <> :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "index" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := ((raftLog__lastIndex (![ptrT] "l")) #()) in
    do:  ("index" <-[uint64T] "$r0");;;
    let: "err" := (ref_ty error (zero_val error)) in
    let: "t" := (ref_ty uint64T (zero_val uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![uint64T] "index") in
    (raftLog__term (![ptrT] "l")) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("t" <-[uint64T] "$r0");;;
    do:  ("err" <-[error] "$r1");;;
    (if: (![error] "err") ≠ (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
    then
      do:  (let: "$a0" := #(str "unexpected error when getting the last term at %d: %v") in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] "index")) in
      let: "$sl1" := (interface.make error__mset (![error] "err")) in
      slice.literal interfaceT ["$sl0"; "$sl1"])) in
      (interface.get "Panicf" (![Logger] (struct.field_ref raftLog "logger" (![ptrT] "l")))) "$a0" "$a1")
    else do:  #());;;
    return: (struct.make entryID [{
       "term" ::= ![uint64T] "t";
       "index" ::= ![uint64T] "index"
     }])).

(* isUpToDate determines if a log with the given last entry is more up-to-date
   by comparing the index and term of the last entries in the existing logs.

   If the logs have last entries with different terms, then the log with the
   later term is more up-to-date. If the logs end with the same term, then
   whichever log has the larger lastIndex is more up-to-date. If the logs are
   the same, the given log is up-to-date.

   go: log.go:442:19 *)
Definition raftLog__isUpToDate : val :=
  rec: "raftLog__isUpToDate" "l" "their" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "their" := (ref_ty entryID "their") in
    let: "our" := (ref_ty entryID (zero_val entryID)) in
    let: "$r0" := ((raftLog__lastEntryID (![ptrT] "l")) #()) in
    do:  ("our" <-[entryID] "$r0");;;
    return: (((![uint64T] (struct.field_ref entryID "term" "their")) > (![uint64T] (struct.field_ref entryID "term" "our"))) || (((![uint64T] (struct.field_ref entryID "term" "their")) = (![uint64T] (struct.field_ref entryID "term" "our"))) && ((![uint64T] (struct.field_ref entryID "index" "their")) ≥ (![uint64T] (struct.field_ref entryID "index" "our")))))).

(* reduceUncommittedSize accounts for the newly committed entries by decreasing
   the uncommitted entry size limit.

   go: raft.go:2114:16 *)
Definition raft__reduceUncommittedSize : val :=
  rec: "raft__reduceUncommittedSize" "r" "s" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "s" := (ref_ty entryPayloadSize "s") in
    (if: (![entryPayloadSize] "s") > (![entryPayloadSize] (struct.field_ref raft "uncommittedSize" (![ptrT] "r")))
    then
      let: "$r0" := #(W64 0) in
      do:  ((struct.field_ref raft "uncommittedSize" (![ptrT] "r")) <-[entryPayloadSize] "$r0")
    else do:  ((struct.field_ref raft "uncommittedSize" (![ptrT] "r")) <-[entryPayloadSize] ((![entryPayloadSize] (struct.field_ref raft "uncommittedSize" (![ptrT] "r"))) - (![entryPayloadSize] "s"))))).

(* go: raft.go:1087:16 *)
Definition raft__Step : val :=
  rec: "raft__Step" "r" "m" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "m" := (ref_ty raftpb.Message "m") in
    do:  (let: "$a0" := (![ptrT] "r") in
    let: "$a1" := "m" in
    traceReceiveMessage "$a0" "$a1");;;
    let: "$sw" := #true in
    (if: "$sw" = ((![uint64T] (struct.field_ref raftpb.Message "Term" "m")) = #(W64 0))
    then do:  #()
    else
      (if: "$sw" = ((![uint64T] (struct.field_ref raftpb.Message "Term" "m")) > (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r"))))
      then
        (if: ((![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) = raftpb.MsgVote) || ((![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) = raftpb.MsgPreVote)
        then
          let: "force" := (ref_ty boolT (zero_val boolT)) in
          let: "$r0" := (let: "$a0" := (![sliceT byteT] (struct.field_ref raftpb.Message "Context" "m")) in
          let: "$a1" := (string.to_bytes campaignTransfer) in
          bytes.Equal "$a0" "$a1") in
          do:  ("force" <-[boolT] "$r0");;;
          let: "inLease" := (ref_ty boolT (zero_val boolT)) in
          let: "$r0" := (((![boolT] (struct.field_ref raft "checkQuorum" (![ptrT] "r"))) && ((![uint64T] (struct.field_ref raft "lead" (![ptrT] "r"))) ≠ None)) && (int_lt (![intT] (struct.field_ref raft "electionElapsed" (![ptrT] "r"))) (![intT] (struct.field_ref raft "electionTimeout" (![ptrT] "r"))))) in
          do:  ("inLease" <-[boolT] "$r0");;;
          (if: (~ (![boolT] "force")) && (![boolT] "inLease")
          then
            let: "last" := (ref_ty entryID (zero_val entryID)) in
            let: "$r0" := ((raftLog__lastEntryID (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()) in
            do:  ("last" <-[entryID] "$r0");;;
            do:  (let: "$a0" := #(str "%x [logterm: %d, index: %d, vote: %x] ignored %s from %x [logterm: %d, index: %d] at term %d: lease is not expired (remaining ticks: %d)") in
            let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
            let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref entryID "term" "last"))) in
            let: "$sl2" := (interface.make uint64__mset (![uint64T] (struct.field_ref entryID "index" "last"))) in
            let: "$sl3" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "Vote" (![ptrT] "r")))) in
            let: "$sl4" := (interface.make raftpb.MessageType__mset (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m"))) in
            let: "$sl5" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "From" "m"))) in
            let: "$sl6" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "LogTerm" "m"))) in
            let: "$sl7" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "Index" "m"))) in
            let: "$sl8" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
            let: "$sl9" := (interface.make int__mset ((![intT] (struct.field_ref raft "electionTimeout" (![ptrT] "r"))) - (![intT] (struct.field_ref raft "electionElapsed" (![ptrT] "r"))))) in
            slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"; "$sl4"; "$sl5"; "$sl6"; "$sl7"; "$sl8"; "$sl9"])) in
            (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
            return: (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
          else do:  #())
        else do:  #());;;
        let: "$sw" := #true in
        (if: "$sw" = ((![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) = raftpb.MsgPreVote)
        then do:  #()
        else
          (if: "$sw" = (((![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) = raftpb.MsgPreVoteResp) && (~ (![boolT] (struct.field_ref raftpb.Message "Reject" "m"))))
          then do:  #()
          else
            do:  (let: "$a0" := #(str "%x [term: %d] received a %s message with higher term from %x [term: %d]") in
            let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
            let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
            let: "$sl2" := (interface.make raftpb.MessageType__mset (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m"))) in
            let: "$sl3" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "From" "m"))) in
            let: "$sl4" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "Term" "m"))) in
            slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"; "$sl4"])) in
            (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
            (if: (((![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) = raftpb.MsgApp) || ((![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) = raftpb.MsgHeartbeat)) || ((![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) = raftpb.MsgSnap)
            then
              do:  (let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "Term" "m")) in
              let: "$a1" := (![uint64T] (struct.field_ref raftpb.Message "From" "m")) in
              (raft__becomeFollower (![ptrT] "r")) "$a0" "$a1")
            else
              do:  (let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "Term" "m")) in
              let: "$a1" := None in
              (raft__becomeFollower (![ptrT] "r")) "$a0" "$a1"))))
      else
        (if: "$sw" = ((![uint64T] (struct.field_ref raftpb.Message "Term" "m")) < (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r"))))
        then
          (if: ((![boolT] (struct.field_ref raft "checkQuorum" (![ptrT] "r"))) || (![boolT] (struct.field_ref raft "preVote" (![ptrT] "r")))) && (((![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) = raftpb.MsgHeartbeat) || ((![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) = raftpb.MsgApp))
          then
            do:  (let: "$a0" := (struct.make raftpb.Message [{
              "To" ::= ![uint64T] (struct.field_ref raftpb.Message "From" "m");
              "Type" ::= raftpb.MsgAppResp
            }]) in
            (raft__send (![ptrT] "r")) "$a0")
          else
            (if: (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) = raftpb.MsgPreVote
            then
              let: "last" := (ref_ty entryID (zero_val entryID)) in
              let: "$r0" := ((raftLog__lastEntryID (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()) in
              do:  ("last" <-[entryID] "$r0");;;
              do:  (let: "$a0" := #(str "%x [logterm: %d, index: %d, vote: %x] rejected %s from %x [logterm: %d, index: %d] at term %d") in
              let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
              let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref entryID "term" "last"))) in
              let: "$sl2" := (interface.make uint64__mset (![uint64T] (struct.field_ref entryID "index" "last"))) in
              let: "$sl3" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "Vote" (![ptrT] "r")))) in
              let: "$sl4" := (interface.make raftpb.MessageType__mset (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m"))) in
              let: "$sl5" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "From" "m"))) in
              let: "$sl6" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "LogTerm" "m"))) in
              let: "$sl7" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "Index" "m"))) in
              let: "$sl8" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
              slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"; "$sl4"; "$sl5"; "$sl6"; "$sl7"; "$sl8"])) in
              (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
              do:  (let: "$a0" := (struct.make raftpb.Message [{
                "To" ::= ![uint64T] (struct.field_ref raftpb.Message "From" "m");
                "Term" ::= ![uint64T] (struct.field_ref raft "Term" (![ptrT] "r"));
                "Type" ::= raftpb.MsgPreVoteResp;
                "Reject" ::= #true
              }]) in
              (raft__send (![ptrT] "r")) "$a0")
            else
              (if: (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) = raftpb.MsgStorageAppendResp
              then
                (if: (![uint64T] (struct.field_ref raftpb.Message "Index" "m")) ≠ #(W64 0)
                then
                  do:  (let: "$a0" := #(str "%x [term: %d] ignored entry appends from a %s message with lower term [term: %d]") in
                  let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
                  let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
                  let: "$sl2" := (interface.make raftpb.MessageType__mset (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m"))) in
                  let: "$sl3" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "Term" "m"))) in
                  slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"])) in
                  (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1")
                else do:  #());;;
                (if: (![ptrT] (struct.field_ref raftpb.Message "Snapshot" "m")) ≠ #null
                then
                  do:  (let: "$a0" := (![ptrT] (struct.field_ref raftpb.Message "Snapshot" "m")) in
                  (raft__appliedSnap (![ptrT] "r")) "$a0")
                else do:  #())
              else
                do:  (let: "$a0" := #(str "%x [term: %d] ignored a %s message with lower term from %x [term: %d]") in
                let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
                let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
                let: "$sl2" := (interface.make raftpb.MessageType__mset (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m"))) in
                let: "$sl3" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "From" "m"))) in
                let: "$sl4" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "Term" "m"))) in
                slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"; "$sl4"])) in
                (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1"))));;;
          return: (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
        else #())));;;
    let: "$sw" := (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) in
    (if: "$sw" = raftpb.MsgHup
    then
      (if: ![boolT] (struct.field_ref raft "preVote" (![ptrT] "r"))
      then
        do:  (let: "$a0" := campaignPreElection in
        (raft__hup (![ptrT] "r")) "$a0")
      else
        do:  (let: "$a0" := campaignElection in
        (raft__hup (![ptrT] "r")) "$a0"))
    else
      (if: "$sw" = raftpb.MsgStorageAppendResp
      then
        (if: (![uint64T] (struct.field_ref raftpb.Message "Index" "m")) ≠ #(W64 0)
        then
          do:  (let: "$a0" := (struct.make entryID [{
            "term" ::= ![uint64T] (struct.field_ref raftpb.Message "LogTerm" "m");
            "index" ::= ![uint64T] (struct.field_ref raftpb.Message "Index" "m")
          }]) in
          (raftLog__stableTo (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) "$a0")
        else do:  #());;;
        (if: (![ptrT] (struct.field_ref raftpb.Message "Snapshot" "m")) ≠ #null
        then
          do:  (let: "$a0" := (![ptrT] (struct.field_ref raftpb.Message "Snapshot" "m")) in
          (raft__appliedSnap (![ptrT] "r")) "$a0")
        else do:  #())
      else
        (if: "$sw" = raftpb.MsgStorageApplyResp
        then
          (if: int_gt (let: "$a0" := (![sliceT raftpb.Entry] (struct.field_ref raftpb.Message "Entries" "m")) in
          slice.len "$a0") #(W64 0)
          then
            let: "index" := (ref_ty uint64T (zero_val uint64T)) in
            let: "$r0" := (![uint64T] (struct.field_ref raftpb.Entry "Index" (slice.elem_ref raftpb.Entry (![sliceT raftpb.Entry] (struct.field_ref raftpb.Message "Entries" "m")) ((let: "$a0" := (![sliceT raftpb.Entry] (struct.field_ref raftpb.Message "Entries" "m")) in
            slice.len "$a0") - #(W64 1))))) in
            do:  ("index" <-[uint64T] "$r0");;;
            do:  (let: "$a0" := (![uint64T] "index") in
            let: "$a1" := (let: "$a0" := (![sliceT raftpb.Entry] (struct.field_ref raftpb.Message "Entries" "m")) in
            entsSize "$a0") in
            (raft__appliedTo (![ptrT] "r")) "$a0" "$a1");;;
            do:  (let: "$a0" := (let: "$a0" := (![sliceT raftpb.Entry] (struct.field_ref raftpb.Message "Entries" "m")) in
            payloadsSize "$a0") in
            (raft__reduceUncommittedSize (![ptrT] "r")) "$a0")
          else do:  #())
        else
          (if: ("$sw" = raftpb.MsgPreVote) || ("$sw" = raftpb.MsgVote)
          then
            let: "canVote" := (ref_ty boolT (zero_val boolT)) in
            let: "$r0" := ((((![uint64T] (struct.field_ref raft "Vote" (![ptrT] "r"))) = (![uint64T] (struct.field_ref raftpb.Message "From" "m"))) || (((![uint64T] (struct.field_ref raft "Vote" (![ptrT] "r"))) = None) && ((![uint64T] (struct.field_ref raft "lead" (![ptrT] "r"))) = None))) || (((![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) = raftpb.MsgPreVote) && ((![uint64T] (struct.field_ref raftpb.Message "Term" "m")) > (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))))) in
            do:  ("canVote" <-[boolT] "$r0");;;
            let: "lastID" := (ref_ty entryID (zero_val entryID)) in
            let: "$r0" := ((raftLog__lastEntryID (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()) in
            do:  ("lastID" <-[entryID] "$r0");;;
            let: "candLastID" := (ref_ty entryID (zero_val entryID)) in
            let: "$r0" := (struct.make entryID [{
              "term" ::= ![uint64T] (struct.field_ref raftpb.Message "LogTerm" "m");
              "index" ::= ![uint64T] (struct.field_ref raftpb.Message "Index" "m")
            }]) in
            do:  ("candLastID" <-[entryID] "$r0");;;
            (if: (![boolT] "canVote") && (let: "$a0" := (![entryID] "candLastID") in
            (raftLog__isUpToDate (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) "$a0")
            then
              do:  (let: "$a0" := #(str "%x [logterm: %d, index: %d, vote: %x] cast %s for %x [logterm: %d, index: %d] at term %d") in
              let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
              let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref entryID "term" "lastID"))) in
              let: "$sl2" := (interface.make uint64__mset (![uint64T] (struct.field_ref entryID "index" "lastID"))) in
              let: "$sl3" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "Vote" (![ptrT] "r")))) in
              let: "$sl4" := (interface.make raftpb.MessageType__mset (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m"))) in
              let: "$sl5" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "From" "m"))) in
              let: "$sl6" := (interface.make uint64__mset (![uint64T] (struct.field_ref entryID "term" "candLastID"))) in
              let: "$sl7" := (interface.make uint64__mset (![uint64T] (struct.field_ref entryID "index" "candLastID"))) in
              let: "$sl8" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
              slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"; "$sl4"; "$sl5"; "$sl6"; "$sl7"; "$sl8"])) in
              (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
              do:  (let: "$a0" := (struct.make raftpb.Message [{
                "To" ::= ![uint64T] (struct.field_ref raftpb.Message "From" "m");
                "Term" ::= ![uint64T] (struct.field_ref raftpb.Message "Term" "m");
                "Type" ::= let: "$a0" := (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) in
                voteRespMsgType "$a0"
              }]) in
              (raft__send (![ptrT] "r")) "$a0");;;
              (if: (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) = raftpb.MsgVote
              then
                let: "$r0" := #(W64 0) in
                do:  ((struct.field_ref raft "electionElapsed" (![ptrT] "r")) <-[intT] "$r0");;;
                let: "$r0" := (![uint64T] (struct.field_ref raftpb.Message "From" "m")) in
                do:  ((struct.field_ref raft "Vote" (![ptrT] "r")) <-[uint64T] "$r0")
              else do:  #())
            else
              do:  (let: "$a0" := #(str "%x [logterm: %d, index: %d, vote: %x] rejected %s from %x [logterm: %d, index: %d] at term %d") in
              let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
              let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref entryID "term" "lastID"))) in
              let: "$sl2" := (interface.make uint64__mset (![uint64T] (struct.field_ref entryID "index" "lastID"))) in
              let: "$sl3" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "Vote" (![ptrT] "r")))) in
              let: "$sl4" := (interface.make raftpb.MessageType__mset (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m"))) in
              let: "$sl5" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "From" "m"))) in
              let: "$sl6" := (interface.make uint64__mset (![uint64T] (struct.field_ref entryID "term" "candLastID"))) in
              let: "$sl7" := (interface.make uint64__mset (![uint64T] (struct.field_ref entryID "index" "candLastID"))) in
              let: "$sl8" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
              slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"; "$sl4"; "$sl5"; "$sl6"; "$sl7"; "$sl8"])) in
              (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
              do:  (let: "$a0" := (struct.make raftpb.Message [{
                "To" ::= ![uint64T] (struct.field_ref raftpb.Message "From" "m");
                "Term" ::= ![uint64T] (struct.field_ref raft "Term" (![ptrT] "r"));
                "Type" ::= let: "$a0" := (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) in
                voteRespMsgType "$a0";
                "Reject" ::= #true
              }]) in
              (raft__send (![ptrT] "r")) "$a0"))
          else
            let: "err" := (ref_ty error (zero_val error)) in
            let: "$r0" := (let: "$a0" := (![ptrT] "r") in
            let: "$a1" := (![raftpb.Message] "m") in
            (![stepFunc] (struct.field_ref raft "step" (![ptrT] "r"))) "$a0" "$a1") in
            do:  ("err" <-[error] "$r0");;;
            (if: (![error] "err") ≠ (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
            then return: (![error] "err")
            else do:  #())))));;;
    return: (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)).

(* go: node.go:484:6 *)
Definition confChangeToMsg : val :=
  rec: "confChangeToMsg" "c" :=
    exception_do (let: "c" := (ref_ty raftpb.ConfChangeI "c") in
    let: "err" := (ref_ty error (zero_val error)) in
    let: "data" := (ref_ty (sliceT byteT) (zero_val (sliceT byteT))) in
    let: "typ" := (ref_ty raftpb.EntryType (zero_val raftpb.EntryType)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![raftpb.ConfChangeI] "c") in
    raftpb.MarshalConfChange "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("typ" <-[raftpb.EntryType] "$r0");;;
    do:  ("data" <-[sliceT byteT] "$r1");;;
    do:  ("err" <-[error] "$r2");;;
    (if: (![error] "err") ≠ (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
    then
      return: (struct.make raftpb.Message [{
       }], ![error] "err")
    else do:  #());;;
    return: (struct.make raftpb.Message [{
       "Type" ::= raftpb.MsgProp;
       "Entries" ::= (let: "$sl0" := (struct.make raftpb.Entry [{
         "Type" ::= ![raftpb.EntryType] "typ";
         "Data" ::= ![sliceT byteT] "data"
       }]) in
       slice.literal raftpb.Entry ["$sl0"])
     }], interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)).

(* go: log.go:332:19 *)
Definition raftLog__appliedTo : val :=
  rec: "raftLog__appliedTo" "l" "i" "size" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "size" := (ref_ty entryEncodingSize "size") in
    let: "i" := (ref_ty uint64T "i") in
    (if: ((![uint64T] (struct.field_ref raftLog "committed" (![ptrT] "l"))) < (![uint64T] "i")) || ((![uint64T] "i") < (![uint64T] (struct.field_ref raftLog "applied" (![ptrT] "l"))))
    then
      do:  (let: "$a0" := #(str "applied(%d) is out of range [prevApplied(%d), committed(%d)]") in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] "i")) in
      let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftLog "applied" (![ptrT] "l")))) in
      let: "$sl2" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] "l")))) in
      slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
      (interface.get "Panicf" (![Logger] (struct.field_ref raftLog "logger" (![ptrT] "l")))) "$a0" "$a1")
    else do:  #());;;
    let: "$r0" := (![uint64T] "i") in
    do:  ((struct.field_ref raftLog "applied" (![ptrT] "l")) <-[uint64T] "$r0");;;
    let: "$r0" := (let: "$a0" := (![uint64T] (struct.field_ref raftLog "applying" (![ptrT] "l"))) in
    let: "$a1" := (![uint64T] "i") in
    (maxUint64 2) "$a0" "$a1") in
    do:  ((struct.field_ref raftLog "applying" (![ptrT] "l")) <-[uint64T] "$r0");;;
    (if: (![entryEncodingSize] (struct.field_ref raftLog "applyingEntsSize" (![ptrT] "l"))) > (![entryEncodingSize] "size")
    then do:  ((struct.field_ref raftLog "applyingEntsSize" (![ptrT] "l")) <-[entryEncodingSize] ((![entryEncodingSize] (struct.field_ref raftLog "applyingEntsSize" (![ptrT] "l"))) - (![entryEncodingSize] "size")))
    else
      let: "$r0" := #(W64 0) in
      do:  ((struct.field_ref raftLog "applyingEntsSize" (![ptrT] "l")) <-[entryEncodingSize] "$r0"));;;
    let: "$r0" := ((![entryEncodingSize] (struct.field_ref raftLog "applyingEntsSize" (![ptrT] "l"))) ≥ (![entryEncodingSize] (struct.field_ref raftLog "maxApplyingEntsSize" (![ptrT] "l")))) in
    do:  ((struct.field_ref raftLog "applyingEntsPaused" (![ptrT] "l")) <-[boolT] "$r0")).

(* go: raft.go:740:16 *)
Definition raft__appliedTo : val :=
  rec: "raft__appliedTo" "r" "index" "size" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "size" := (ref_ty entryEncodingSize "size") in
    let: "index" := (ref_ty uint64T "index") in
    let: "oldApplied" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (![uint64T] (struct.field_ref raftLog "applied" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r"))))) in
    do:  ("oldApplied" <-[uint64T] "$r0");;;
    let: "newApplied" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (let: "$a0" := (![uint64T] "index") in
    let: "$a1" := (![uint64T] "oldApplied") in
    (maxUint64 2) "$a0" "$a1") in
    do:  ("newApplied" <-[uint64T] "$r0");;;
    do:  (let: "$a0" := (![uint64T] "newApplied") in
    let: "$a1" := (![entryEncodingSize] "size") in
    (raftLog__appliedTo (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) "$a0" "$a1");;;
    (if: ((![boolT] (struct.field_ref tracker.Config "AutoLeave" (struct.field_ref tracker.ProgressTracker "Config" (struct.field_ref raft "trk" (![ptrT] "r"))))) && ((![uint64T] "newApplied") ≥ (![uint64T] (struct.field_ref raft "pendingConfIndex" (![ptrT] "r"))))) && ((![StateType] (struct.field_ref raft "state" (![ptrT] "r"))) = StateLeader)
    then
      let: "err" := (ref_ty error (zero_val error)) in
      let: "m" := (ref_ty raftpb.Message (zero_val raftpb.Message)) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion) in
      confChangeToMsg "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("m" <-[raftpb.Message] "$r0");;;
      do:  ("err" <-[error] "$r1");;;
      (if: (![error] "err") ≠ (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
      then
        do:  (let: "$a0" := (interface.make error__mset (![error] "err")) in
        Panic "$a0")
      else do:  #());;;
      (let: "err" := (ref_ty error (zero_val error)) in
      let: "$r0" := (let: "$a0" := (![raftpb.Message] "m") in
      (raft__Step (![ptrT] "r")) "$a0") in
      do:  ("err" <-[error] "$r0");;;
      (if: (![error] "err") ≠ (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
      then
        do:  (let: "$a0" := #(str "not initiating automatic transition out of joint configuration %s: %v") in
        let: "$a1" := ((let: "$sl0" := (interface.make tracker.Config__mset (![tracker.Config] (struct.field_ref tracker.ProgressTracker "Config" (struct.field_ref raft "trk" (![ptrT] "r"))))) in
        let: "$sl1" := (interface.make error__mset (![error] "err")) in
        slice.literal interfaceT ["$sl0"; "$sl1"])) in
        (interface.get "Debugf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1")
      else
        do:  (let: "$a0" := #(str "initiating automatic transition out of joint configuration %s") in
        let: "$a1" := ((let: "$sl0" := (interface.make tracker.Config__mset (![tracker.Config] (struct.field_ref tracker.ProgressTracker "Config" (struct.field_ref raft "trk" (![ptrT] "r"))))) in
        slice.literal interfaceT ["$sl0"])) in
        (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1")))
    else do:  #())).

(* go: log_unstable.go:182:20 *)
Definition unstable__stableSnapTo : val :=
  rec: "unstable__stableSnapTo" "u" "i" :=
    exception_do (let: "u" := (ref_ty ptrT "u") in
    let: "i" := (ref_ty uint64T "i") in
    (if: ((![ptrT] (struct.field_ref unstable "snapshot" (![ptrT] "u"))) ≠ #null) && ((![uint64T] (struct.field_ref raftpb.SnapshotMetadata "Index" (struct.field_ref raftpb.Snapshot "Metadata" (![ptrT] (struct.field_ref unstable "snapshot" (![ptrT] "u")))))) = (![uint64T] "i"))
    then
      let: "$r0" := #null in
      do:  ((struct.field_ref unstable "snapshot" (![ptrT] "u")) <-[ptrT] "$r0");;;
      let: "$r0" := #false in
      do:  ((struct.field_ref unstable "snapshotInProgress" (![ptrT] "u")) <-[boolT] "$r0")
    else do:  #())).

(* go: log.go:369:19 *)
Definition raftLog__stableSnapTo : val :=
  rec: "raftLog__stableSnapTo" "l" "i" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "i" := (ref_ty uint64T "i") in
    do:  (let: "$a0" := (![uint64T] "i") in
    (unstable__stableSnapTo (struct.field_ref raftLog "unstable" (![ptrT] "l"))) "$a0")).

(* go: raft.go:769:16 *)
Definition raft__appliedSnap : val :=
  rec: "raft__appliedSnap" "r" "snap" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "snap" := (ref_ty ptrT "snap") in
    let: "index" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (![uint64T] (struct.field_ref raftpb.SnapshotMetadata "Index" (struct.field_ref raftpb.Snapshot "Metadata" (![ptrT] "snap")))) in
    do:  ("index" <-[uint64T] "$r0");;;
    do:  (let: "$a0" := (![uint64T] "index") in
    (raftLog__stableSnapTo (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) "$a0");;;
    do:  (let: "$a0" := (![uint64T] "index") in
    let: "$a1" := #(W64 0) in
    (raft__appliedTo (![ptrT] "r")) "$a0" "$a1")).

Definition lenMultiple : Z := 2.

(* go: log_unstable.go:168:20 *)
Definition unstable__shrinkEntriesArray : val :=
  rec: "unstable__shrinkEntriesArray" "u" <> :=
    exception_do (let: "u" := (ref_ty ptrT "u") in
    (if: (let: "$a0" := (![sliceT raftpb.Entry] (struct.field_ref unstable "entries" (![ptrT] "u"))) in
    slice.len "$a0") = #(W64 0)
    then
      let: "$r0" := slice.nil in
      do:  ((struct.field_ref unstable "entries" (![ptrT] "u")) <-[sliceT raftpb.Entry] "$r0")
    else
      (if: int_lt ((let: "$a0" := (![sliceT raftpb.Entry] (struct.field_ref unstable "entries" (![ptrT] "u"))) in
      slice.len "$a0") * #(W64 lenMultiple)) (let: "$a0" := (![sliceT raftpb.Entry] (struct.field_ref unstable "entries" (![ptrT] "u"))) in
      slice.cap "$a0")
      then
        let: "newEntries" := (ref_ty (sliceT raftpb.Entry) (zero_val (sliceT raftpb.Entry))) in
        let: "$r0" := (slice.make2 raftpb.Entry (let: "$a0" := (![sliceT raftpb.Entry] (struct.field_ref unstable "entries" (![ptrT] "u"))) in
        slice.len "$a0")) in
        do:  ("newEntries" <-[sliceT raftpb.Entry] "$r0");;;
        do:  (let: "$a0" := (![sliceT raftpb.Entry] "newEntries") in
        let: "$a1" := (![sliceT raftpb.Entry] (struct.field_ref unstable "entries" (![ptrT] "u"))) in
        (slice.copy raftpb.Entry) "$a0" "$a1");;;
        let: "$r0" := (![sliceT raftpb.Entry] "newEntries") in
        do:  ((struct.field_ref unstable "entries" (![ptrT] "u")) <-[sliceT raftpb.Entry] "$r0")
      else do:  #()))).

(* stableTo marks entries up to the entry with the specified (index, term) as
   being successfully written to stable storage.

   The method should only be called when the caller can attest that the entries
   can not be overwritten by an in-progress log append. See the related comment
   in newStorageAppendRespMsg.

   go: log_unstable.go:134:20 *)
Definition unstable__stableTo : val :=
  rec: "unstable__stableTo" "u" "id" :=
    exception_do (let: "u" := (ref_ty ptrT "u") in
    let: "id" := (ref_ty entryID "id") in
    let: "ok" := (ref_ty boolT (zero_val boolT)) in
    let: "gt" := (ref_ty uint64T (zero_val uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![uint64T] (struct.field_ref entryID "index" "id")) in
    (unstable__maybeTerm (![ptrT] "u")) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("gt" <-[uint64T] "$r0");;;
    do:  ("ok" <-[boolT] "$r1");;;
    (if: (~ (![boolT] "ok"))
    then
      do:  (let: "$a0" := #(str "entry at index %d missing from unstable log; ignoring") in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref entryID "index" "id"))) in
      slice.literal interfaceT ["$sl0"])) in
      (interface.get "Infof" (![Logger] (struct.field_ref unstable "logger" (![ptrT] "u")))) "$a0" "$a1");;;
      return: (#())
    else do:  #());;;
    (if: (![uint64T] (struct.field_ref entryID "index" "id")) < (![uint64T] (struct.field_ref unstable "offset" (![ptrT] "u")))
    then
      do:  (let: "$a0" := #(str "entry at index %d matched unstable snapshot; ignoring") in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref entryID "index" "id"))) in
      slice.literal interfaceT ["$sl0"])) in
      (interface.get "Infof" (![Logger] (struct.field_ref unstable "logger" (![ptrT] "u")))) "$a0" "$a1");;;
      return: (#())
    else do:  #());;;
    (if: (![uint64T] "gt") ≠ (![uint64T] (struct.field_ref entryID "term" "id"))
    then
      do:  (let: "$a0" := ("entry at (index,term)=(%d,%d) mismatched with " + "entry at (%d,%d) in unstable log; ignoring") in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref entryID "index" "id"))) in
      let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref entryID "term" "id"))) in
      let: "$sl2" := (interface.make uint64__mset (![uint64T] (struct.field_ref entryID "index" "id"))) in
      let: "$sl3" := (interface.make uint64__mset (![uint64T] "gt")) in
      slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"])) in
      (interface.get "Infof" (![Logger] (struct.field_ref unstable "logger" (![ptrT] "u")))) "$a0" "$a1");;;
      return: (#())
    else do:  #());;;
    let: "num" := (ref_ty intT (zero_val intT)) in
    let: "$r0" := (((![uint64T] (struct.field_ref entryID "index" "id")) + #(W64 1)) - (![uint64T] (struct.field_ref unstable "offset" (![ptrT] "u")))) in
    do:  ("num" <-[intT] "$r0");;;
    let: "$r0" := (let: "$s" := (![sliceT raftpb.Entry] (struct.field_ref unstable "entries" (![ptrT] "u"))) in
    slice.slice raftpb.Entry "$s" (![intT] "num") (slice.len "$s")) in
    do:  ((struct.field_ref unstable "entries" (![ptrT] "u")) <-[sliceT raftpb.Entry] "$r0");;;
    let: "$r0" := ((![uint64T] (struct.field_ref entryID "index" "id")) + #(W64 1)) in
    do:  ((struct.field_ref unstable "offset" (![ptrT] "u")) <-[uint64T] "$r0");;;
    let: "$r0" := (let: "$a0" := (![uint64T] (struct.field_ref unstable "offsetInProgress" (![ptrT] "u"))) in
    let: "$a1" := (![uint64T] (struct.field_ref unstable "offset" (![ptrT] "u"))) in
    (maxUint64 2) "$a0" "$a1") in
    do:  ((struct.field_ref unstable "offsetInProgress" (![ptrT] "u")) <-[uint64T] "$r0");;;
    do:  ((unstable__shrinkEntriesArray (![ptrT] "u")) #())).

(* go: log.go:367:19 *)
Definition raftLog__stableTo : val :=
  rec: "raftLog__stableTo" "l" "id" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "id" := (ref_ty entryID "id") in
    do:  (let: "$a0" := (![entryID] "id") in
    (unstable__stableTo (struct.field_ref raftLog "unstable" (![ptrT] "l"))) "$a0")).

Definition CampaignType : go_type := stringT.

Definition campaignTransfer : expr := #(str "CampaignTransfer").

(* go: state_trace_nop.go:40:6 *)
Definition traceBecomeCandidate : val :=
  rec: "traceBecomeCandidate" "" :=
    exception_do (let: "" := (ref_ty ptrT "") in
    do:  #()).

Definition StateCandidate : expr := #(W64 1).

(* tickElection is run by followers and candidates after r.electionTimeout.

   go: raft.go:851:16 *)
Definition raft__tickElection : val :=
  rec: "raft__tickElection" "r" <> :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    do:  ((struct.field_ref raft "electionElapsed" (![ptrT] "r")) <-[intT] ((![intT] (struct.field_ref raft "electionElapsed" (![ptrT] "r"))) + #(W64 1)));;;
    (if: ((raft__promotable (![ptrT] "r")) #()) && ((raft__pastElectionTimeout (![ptrT] "r")) #())
    then
      let: "$r0" := #(W64 0) in
      do:  ((struct.field_ref raft "electionElapsed" (![ptrT] "r")) <-[intT] "$r0");;;
      (let: "err" := (ref_ty error (zero_val error)) in
      let: "$r0" := (let: "$a0" := (struct.make raftpb.Message [{
        "From" ::= ![uint64T] (struct.field_ref raft "id" (![ptrT] "r"));
        "Type" ::= raftpb.MsgHup
      }]) in
      (raft__Step (![ptrT] "r")) "$a0") in
      do:  ("err" <-[error] "$r0");;;
      (if: (![error] "err") ≠ (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
      then
        do:  (let: "$a0" := #(str "error occurred during election: %v") in
        let: "$a1" := ((let: "$sl0" := (interface.make error__mset (![error] "err")) in
        slice.literal interfaceT ["$sl0"])) in
        (interface.get "Debugf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1")
      else do:  #()))
    else do:  #())).

Definition ReadOnlyOption : go_type := intT.

Definition readOnly : go_type := structT [
  "option" :: ReadOnlyOption;
  "pendingReadIndex" :: mapT stringT ptrT;
  "readIndexQueue" :: sliceT stringT
]%struct.

(* go: read_only.go:45:6 *)
Definition newReadOnly : val :=
  rec: "newReadOnly" "option" :=
    exception_do (let: "option" := (ref_ty ReadOnlyOption "option") in
    return: (ref_ty readOnly (struct.make readOnly [{
       "option" ::= ![ReadOnlyOption] "option";
       "pendingReadIndex" ::= map.make stringT ptrT #()
     }]))).

Definition lockedRand : go_type := structT [
  "mu" :: sync.Mutex
]%struct.

(* go: raft.go:95:22 *)
Definition lockedRand__Intn : val :=
  rec: "lockedRand__Intn" "r" "n" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "n" := (ref_ty intT "n") in
    do:  ((sync.Mutex__Lock (struct.field_ref lockedRand "mu" (![ptrT] "r"))) #());;;
    let: <> := (ref_ty error (zero_val error)) in
    let: "v" := (ref_ty ptrT (zero_val ptrT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := rand.Reader in
    let: "$a1" := (let: "$a0" := (![intT] "n") in
    big.NewInt "$a0") in
    rand.Int "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("v" <-[ptrT] "$r0");;;
    do:  "$r1";;;
    do:  ((sync.Mutex__Unlock (struct.field_ref lockedRand "mu" (![ptrT] "r"))) #());;;
    return: ((big.Int__Int64 (![ptrT] "v")) #())).

(* go: raft.go:2051:16 *)
Definition raft__resetRandomizedElectionTimeout : val :=
  rec: "raft__resetRandomizedElectionTimeout" "r" <> :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "$r0" := ((![intT] (struct.field_ref raft "electionTimeout" (![ptrT] "r"))) + (let: "$a0" := (![intT] (struct.field_ref raft "electionTimeout" (![ptrT] "r"))) in
    (lockedRand__Intn (![ptrT] "globalRand")) "$a0")) in
    do:  ((struct.field_ref raft "randomizedElectionTimeout" (![ptrT] "r")) <-[intT] "$r0")).

(* go: raft.go:784:16 *)
Definition raft__reset : val :=
  rec: "raft__reset" "r" "term" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "term" := (ref_ty uint64T "term") in
    (if: (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r"))) ≠ (![uint64T] "term")
    then
      let: "$r0" := (![uint64T] "term") in
      do:  ((struct.field_ref raft "Term" (![ptrT] "r")) <-[uint64T] "$r0");;;
      let: "$r0" := None in
      do:  ((struct.field_ref raft "Vote" (![ptrT] "r")) <-[uint64T] "$r0")
    else do:  #());;;
    let: "$r0" := None in
    do:  ((struct.field_ref raft "lead" (![ptrT] "r")) <-[uint64T] "$r0");;;
    let: "$r0" := #(W64 0) in
    do:  ((struct.field_ref raft "electionElapsed" (![ptrT] "r")) <-[intT] "$r0");;;
    let: "$r0" := #(W64 0) in
    do:  ((struct.field_ref raft "heartbeatElapsed" (![ptrT] "r")) <-[intT] "$r0");;;
    do:  ((raft__resetRandomizedElectionTimeout (![ptrT] "r")) #());;;
    do:  ((raft__abortLeaderTransfer (![ptrT] "r")) #());;;
    do:  ((tracker.ProgressTracker__ResetVotes (struct.field_ref raft "trk" (![ptrT] "r"))) #());;;
    do:  (let: "$a0" := (λ: "id" "pr",
      exception_do (let: "pr" := (ref_ty ptrT "pr") in
      let: "id" := (ref_ty uint64T "id") in
      let: "$r0" := (struct.make tracker.Progress [{
        "Match" ::= #(W64 0);
        "Next" ::= ((raftLog__lastIndex (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()) + #(W64 1);
        "Inflights" ::= let: "$a0" := (![intT] (struct.field_ref tracker.ProgressTracker "MaxInflight" (struct.field_ref raft "trk" (![ptrT] "r")))) in
        let: "$a1" := (![uint64T] (struct.field_ref tracker.ProgressTracker "MaxInflightBytes" (struct.field_ref raft "trk" (![ptrT] "r")))) in
        tracker.NewInflights "$a0" "$a1";
        "IsLearner" ::= ![boolT] (struct.field_ref tracker.Progress "IsLearner" (![ptrT] "pr"))
      }]) in
      do:  ((![ptrT] "pr") <-[tracker.Progress] "$r0");;;
      (if: (![uint64T] "id") = (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))
      then
        let: "$r0" := ((raftLog__lastIndex (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()) in
        do:  ((struct.field_ref tracker.Progress "Match" (![ptrT] "pr")) <-[uint64T] "$r0")
      else do:  #()))
      ) in
    (tracker.ProgressTracker__Visit (struct.field_ref raft "trk" (![ptrT] "r"))) "$a0");;;
    let: "$r0" := #(W64 0) in
    do:  ((struct.field_ref raft "pendingConfIndex" (![ptrT] "r")) <-[uint64T] "$r0");;;
    let: "$r0" := #(W64 0) in
    do:  ((struct.field_ref raft "uncommittedSize" (![ptrT] "r")) <-[entryPayloadSize] "$r0");;;
    let: "$r0" := (let: "$a0" := (![ReadOnlyOption] (struct.field_ref readOnly "option" (![ptrT] (struct.field_ref raft "readOnly" (![ptrT] "r"))))) in
    newReadOnly "$a0") in
    do:  ((struct.field_ref raft "readOnly" (![ptrT] "r")) <-[ptrT] "$r0")).

(* go: raft.go:119:21 *)
Definition StateType__String : val :=
  rec: "StateType__String" "st" <> :=
    exception_do (let: "st" := (ref_ty StateType "st") in
    return: (![stringT] (array.elem_ref stringT (![arrayT 4 stringT] "stmap") (![StateType] "st")))).

(* go: util.go:25:21 *)
Definition StateType__MarshalJSON : val :=
  rec: "StateType__MarshalJSON" "st" <> :=
    exception_do (let: "st" := (ref_ty StateType "st") in
    return: (string.to_bytes (let: "$a0" := #(str "%q") in
     let: "$a1" := ((let: "$sl0" := (interface.make string__mset ((StateType__String (![StateType] "st")) #())) in
     slice.literal interfaceT ["$sl0"])) in
     fmt.Sprintf "$a0" "$a1"), interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)).

Definition StateType__mset : list (string * val) := [
  ("MarshalJSON", StateType__MarshalJSON%V);
  ("String", StateType__String%V)
].

(* go: raft.go:892:16 *)
Definition raft__becomeFollower : val :=
  rec: "raft__becomeFollower" "r" "term" "lead" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "lead" := (ref_ty uint64T "lead") in
    let: "term" := (ref_ty uint64T "term") in
    let: "$r0" := stepFollower in
    do:  ((struct.field_ref raft "step" (![ptrT] "r")) <-[stepFunc] "$r0");;;
    do:  (let: "$a0" := (![uint64T] "term") in
    (raft__reset (![ptrT] "r")) "$a0");;;
    let: "$r0" := (raft__tickElection (![ptrT] "r")) in
    do:  ((struct.field_ref raft "tick" (![ptrT] "r")) <-[funcT] "$r0");;;
    let: "$r0" := (![uint64T] "lead") in
    do:  ((struct.field_ref raft "lead" (![ptrT] "r")) <-[uint64T] "$r0");;;
    let: "$r0" := StateFollower in
    do:  ((struct.field_ref raft "state" (![ptrT] "r")) <-[StateType] "$r0");;;
    do:  (let: "$a0" := #(str "%x became follower at term %d") in
    let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
    let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
    slice.literal interfaceT ["$sl0"; "$sl1"])) in
    (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
    do:  (let: "$a0" := (![ptrT] "r") in
    traceBecomeFollower "$a0")).

(* go: log_unstable.go:197:20 *)
Definition unstable__truncateAndAppend : val :=
  rec: "unstable__truncateAndAppend" "u" "ents" :=
    exception_do (let: "u" := (ref_ty ptrT "u") in
    let: "ents" := (ref_ty (sliceT raftpb.Entry) "ents") in
    let: "fromIndex" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (![uint64T] (struct.field_ref raftpb.Entry "Index" (slice.elem_ref raftpb.Entry (![sliceT raftpb.Entry] "ents") #(W64 0)))) in
    do:  ("fromIndex" <-[uint64T] "$r0");;;
    let: "$sw" := #true in
    (if: "$sw" = ((![uint64T] "fromIndex") = ((![uint64T] (struct.field_ref unstable "offset" (![ptrT] "u"))) + (let: "$a0" := (![sliceT raftpb.Entry] (struct.field_ref unstable "entries" (![ptrT] "u"))) in
    slice.len "$a0")))
    then
      let: "$r0" := (let: "$a0" := (![sliceT raftpb.Entry] (struct.field_ref unstable "entries" (![ptrT] "u"))) in
      let: "$a1" := (![sliceT raftpb.Entry] "ents") in
      (slice.append (sliceT raftpb.Entry)) "$a0" "$a1") in
      do:  ((struct.field_ref unstable "entries" (![ptrT] "u")) <-[sliceT raftpb.Entry] "$r0")
    else
      (if: "$sw" = ((![uint64T] "fromIndex") ≤ (![uint64T] (struct.field_ref unstable "offset" (![ptrT] "u"))))
      then
        do:  (let: "$a0" := #(str "replace the unstable entries from index %d") in
        let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] "fromIndex")) in
        slice.literal interfaceT ["$sl0"])) in
        (interface.get "Infof" (![Logger] (struct.field_ref unstable "logger" (![ptrT] "u")))) "$a0" "$a1");;;
        let: "$r0" := (![sliceT raftpb.Entry] "ents") in
        do:  ((struct.field_ref unstable "entries" (![ptrT] "u")) <-[sliceT raftpb.Entry] "$r0");;;
        let: "$r0" := (![uint64T] "fromIndex") in
        do:  ((struct.field_ref unstable "offset" (![ptrT] "u")) <-[uint64T] "$r0");;;
        let: "$r0" := (![uint64T] (struct.field_ref unstable "offset" (![ptrT] "u"))) in
        do:  ((struct.field_ref unstable "offsetInProgress" (![ptrT] "u")) <-[uint64T] "$r0")
      else
        do:  (let: "$a0" := #(str "truncate the unstable entries before index %d") in
        let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] "fromIndex")) in
        slice.literal interfaceT ["$sl0"])) in
        (interface.get "Infof" (![Logger] (struct.field_ref unstable "logger" (![ptrT] "u")))) "$a0" "$a1");;;
        let: "keep" := (ref_ty (sliceT raftpb.Entry) (zero_val (sliceT raftpb.Entry))) in
        let: "$r0" := (let: "$a0" := (![uint64T] (struct.field_ref unstable "offset" (![ptrT] "u"))) in
        let: "$a1" := (![uint64T] "fromIndex") in
        (unstable__slice (![ptrT] "u")) "$a0" "$a1") in
        do:  ("keep" <-[sliceT raftpb.Entry] "$r0");;;
        let: "$r0" := (let: "$a0" := (![sliceT raftpb.Entry] "keep") in
        let: "$a1" := (![sliceT raftpb.Entry] "ents") in
        (slice.append (sliceT raftpb.Entry)) "$a0" "$a1") in
        do:  ((struct.field_ref unstable "entries" (![ptrT] "u")) <-[sliceT raftpb.Entry] "$r0");;;
        let: "$r0" := (let: "$a0" := (![uint64T] (struct.field_ref unstable "offsetInProgress" (![ptrT] "u"))) in
        let: "$a1" := (![uint64T] "fromIndex") in
        (minUint64 2) "$a0" "$a1") in
        do:  ((struct.field_ref unstable "offsetInProgress" (![ptrT] "u")) <-[uint64T] "$r0")))).

(* go: log.go:132:19 *)
Definition raftLog__append : val :=
  rec: "raftLog__append" "l" "ents" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "ents" := (ref_ty (sliceT raftpb.Entry) "ents") in
    (if: (let: "$a0" := (![sliceT raftpb.Entry] "ents") in
    slice.len "$a0") = #(W64 0)
    then return: ((raftLog__lastIndex (![ptrT] "l")) #())
    else do:  #());;;
    (let: "after" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := ((![uint64T] (struct.field_ref raftpb.Entry "Index" (slice.elem_ref raftpb.Entry (![sliceT raftpb.Entry] "ents") #(W64 0)))) - #(W64 1)) in
    do:  ("after" <-[uint64T] "$r0");;;
    (if: (![uint64T] "after") < (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] "l")))
    then
      do:  (let: "$a0" := #(str "after(%d) is out of range [committed(%d)]") in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] "after")) in
      let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] "l")))) in
      slice.literal interfaceT ["$sl0"; "$sl1"])) in
      (interface.get "Panicf" (![Logger] (struct.field_ref raftLog "logger" (![ptrT] "l")))) "$a0" "$a1")
    else do:  #()));;;
    do:  (let: "$a0" := (![sliceT raftpb.Entry] "ents") in
    (unstable__truncateAndAppend (struct.field_ref raftLog "unstable" (![ptrT] "l"))) "$a0");;;
    return: ((raftLog__lastIndex (![ptrT] "l")) #())).

(* go: state_trace_nop.go:36:6 *)
Definition traceReplicate : val :=
  rec: "traceReplicate" "" "" :=
    exception_do (let: "" := (ref_ty (sliceT raftpb.Entry) "") in
    let: "" := (ref_ty ptrT "") in
    do:  #()).

(* increaseUncommittedSize computes the size of the proposed entries and
   determines whether they would push leader over its maxUncommittedSize limit.
   If the new entries would exceed the limit, the method returns false. If not,
   the increase in uncommitted entry size is recorded and the method returns
   true.

   Empty payloads are never refused. This is used both for appending an empty
   entry at a new leader's term, as well as leaving a joint configuration.

   go: raft.go:2096:16 *)
Definition raft__increaseUncommittedSize : val :=
  rec: "raft__increaseUncommittedSize" "r" "ents" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "ents" := (ref_ty (sliceT raftpb.Entry) "ents") in
    let: "s" := (ref_ty entryPayloadSize (zero_val entryPayloadSize)) in
    let: "$r0" := (let: "$a0" := (![sliceT raftpb.Entry] "ents") in
    payloadsSize "$a0") in
    do:  ("s" <-[entryPayloadSize] "$r0");;;
    (if: (((![entryPayloadSize] (struct.field_ref raft "uncommittedSize" (![ptrT] "r"))) > #(W64 0)) && ((![entryPayloadSize] "s") > #(W64 0))) && (((![entryPayloadSize] (struct.field_ref raft "uncommittedSize" (![ptrT] "r"))) + (![entryPayloadSize] "s")) > (![entryPayloadSize] (struct.field_ref raft "maxUncommittedSize" (![ptrT] "r"))))
    then return: (#false)
    else do:  #());;;
    do:  ((struct.field_ref raft "uncommittedSize" (![ptrT] "r")) <-[entryPayloadSize] ((![entryPayloadSize] (struct.field_ref raft "uncommittedSize" (![ptrT] "r"))) + (![entryPayloadSize] "s")));;;
    return: (#true)).

(* returns: accepted

   go: raft.go:816:16 *)
Definition raft__appendEntry : val :=
  rec: "raft__appendEntry" "r" "es" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "es" := (ref_ty (sliceT raftpb.Entry) "es") in
    let: "li" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := ((raftLog__lastIndex (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()) in
    do:  ("li" <-[uint64T] "$r0");;;
    do:  (let: "$range" := (![sliceT raftpb.Entry] "es") in
    slice.for_range raftpb.Entry "$range" (λ: "i" <>,
      let: "i" := ref_ty uint64T "i" in
      let: "$r0" := (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r"))) in
      do:  ((struct.field_ref raftpb.Entry "Term" (slice.elem_ref raftpb.Entry (![sliceT raftpb.Entry] "es") (![intT] "i"))) <-[uint64T] "$r0");;;
      let: "$r0" := (((![uint64T] "li") + #(W64 1)) + (![intT] "i")) in
      do:  ((struct.field_ref raftpb.Entry "Index" (slice.elem_ref raftpb.Entry (![sliceT raftpb.Entry] "es") (![intT] "i"))) <-[uint64T] "$r0")));;;
    (if: (~ (let: "$a0" := (![sliceT raftpb.Entry] "es") in
    (raft__increaseUncommittedSize (![ptrT] "r")) "$a0"))
    then
      do:  (let: "$a0" := #(str "%x appending new entries to log would exceed uncommitted entry size limit; dropping proposal") in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
      slice.literal interfaceT ["$sl0"])) in
      (interface.get "Warningf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
      return: (#false)
    else do:  #());;;
    do:  (let: "$a0" := (![ptrT] "r") in
    let: "$a1" := (![sliceT raftpb.Entry] "es") in
    traceReplicate "$a0" "$a1");;;
    let: "$r0" := (let: "$a0" := (![sliceT raftpb.Entry] "es") in
    (raftLog__append (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) "$a0") in
    do:  ("li" <-[uint64T] "$r0");;;
    do:  (let: "$a0" := (struct.make raftpb.Message [{
      "To" ::= ![uint64T] (struct.field_ref raft "id" (![ptrT] "r"));
      "Type" ::= raftpb.MsgAppResp;
      "Index" ::= ![uint64T] "li"
    }]) in
    (raft__send (![ptrT] "r")) "$a0");;;
    return: (#true)).

(* go: state_trace_nop.go:42:6 *)
Definition traceBecomeLeader : val :=
  rec: "traceBecomeLeader" "" :=
    exception_do (let: "" := (ref_ty ptrT "") in
    do:  #()).

(* tickHeartbeat is run by leaders to send a MsgBeat after r.heartbeatTimeout.

   go: raft.go:863:16 *)
Definition raft__tickHeartbeat : val :=
  rec: "raft__tickHeartbeat" "r" <> :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    do:  ((struct.field_ref raft "heartbeatElapsed" (![ptrT] "r")) <-[intT] ((![intT] (struct.field_ref raft "heartbeatElapsed" (![ptrT] "r"))) + #(W64 1)));;;
    do:  ((struct.field_ref raft "electionElapsed" (![ptrT] "r")) <-[intT] ((![intT] (struct.field_ref raft "electionElapsed" (![ptrT] "r"))) + #(W64 1)));;;
    (if: int_geq (![intT] (struct.field_ref raft "electionElapsed" (![ptrT] "r"))) (![intT] (struct.field_ref raft "electionTimeout" (![ptrT] "r")))
    then
      let: "$r0" := #(W64 0) in
      do:  ((struct.field_ref raft "electionElapsed" (![ptrT] "r")) <-[intT] "$r0");;;
      (if: ![boolT] (struct.field_ref raft "checkQuorum" (![ptrT] "r"))
      then
        (let: "err" := (ref_ty error (zero_val error)) in
        let: "$r0" := (let: "$a0" := (struct.make raftpb.Message [{
          "From" ::= ![uint64T] (struct.field_ref raft "id" (![ptrT] "r"));
          "Type" ::= raftpb.MsgCheckQuorum
        }]) in
        (raft__Step (![ptrT] "r")) "$a0") in
        do:  ("err" <-[error] "$r0");;;
        (if: (![error] "err") ≠ (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
        then
          do:  (let: "$a0" := #(str "error occurred during checking sending heartbeat: %v") in
          let: "$a1" := ((let: "$sl0" := (interface.make error__mset (![error] "err")) in
          slice.literal interfaceT ["$sl0"])) in
          (interface.get "Debugf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1")
        else do:  #()))
      else do:  #());;;
      (if: ((![StateType] (struct.field_ref raft "state" (![ptrT] "r"))) = StateLeader) && ((![uint64T] (struct.field_ref raft "leadTransferee" (![ptrT] "r"))) ≠ None)
      then do:  ((raft__abortLeaderTransfer (![ptrT] "r")) #())
      else do:  #())
    else do:  #());;;
    (if: (![StateType] (struct.field_ref raft "state" (![ptrT] "r"))) ≠ StateLeader
    then return: (#())
    else do:  #());;;
    (if: int_geq (![intT] (struct.field_ref raft "heartbeatElapsed" (![ptrT] "r"))) (![intT] (struct.field_ref raft "heartbeatTimeout" (![ptrT] "r")))
    then
      let: "$r0" := #(W64 0) in
      do:  ((struct.field_ref raft "heartbeatElapsed" (![ptrT] "r")) <-[intT] "$r0");;;
      (let: "err" := (ref_ty error (zero_val error)) in
      let: "$r0" := (let: "$a0" := (struct.make raftpb.Message [{
        "From" ::= ![uint64T] (struct.field_ref raft "id" (![ptrT] "r"));
        "Type" ::= raftpb.MsgBeat
      }]) in
      (raft__Step (![ptrT] "r")) "$a0") in
      do:  ("err" <-[error] "$r0");;;
      (if: (![error] "err") ≠ (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
      then
        do:  (let: "$a0" := #(str "error occurred during checking sending heartbeat: %v") in
        let: "$a1" := ((let: "$sl0" := (interface.make error__mset (![error] "err")) in
        slice.literal interfaceT ["$sl0"])) in
        (interface.get "Debugf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1")
      else do:  #()))
    else do:  #())).

(* go: raft.go:2055:16 *)
Definition raft__sendTimeoutNow : val :=
  rec: "raft__sendTimeoutNow" "r" "to" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "to" := (ref_ty uint64T "to") in
    do:  (let: "$a0" := (struct.make raftpb.Message [{
      "To" ::= ![uint64T] "to";
      "Type" ::= raftpb.MsgTimeoutNow
    }]) in
    (raft__send (![ptrT] "r")) "$a0")).

(* responseToReadIndexReq constructs a response for `req`. If `req` comes from the peer
   itself, a blank value will be returned.

   go: raft.go:2072:16 *)
Definition raft__responseToReadIndexReq : val :=
  rec: "raft__responseToReadIndexReq" "r" "req" "readIndex" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "readIndex" := (ref_ty uint64T "readIndex") in
    let: "req" := (ref_ty raftpb.Message "req") in
    (if: ((![uint64T] (struct.field_ref raftpb.Message "From" "req")) = None) || ((![uint64T] (struct.field_ref raftpb.Message "From" "req")) = (![uint64T] (struct.field_ref raft "id" (![ptrT] "r"))))
    then
      let: "$r0" := (let: "$a0" := (![sliceT ReadState] (struct.field_ref raft "readStates" (![ptrT] "r"))) in
      let: "$a1" := ((let: "$sl0" := (struct.make ReadState [{
        "Index" ::= ![uint64T] "readIndex";
        "RequestCtx" ::= ![sliceT byteT] (struct.field_ref raftpb.Entry "Data" (slice.elem_ref raftpb.Entry (![sliceT raftpb.Entry] (struct.field_ref raftpb.Message "Entries" "req")) #(W64 0)))
      }]) in
      slice.literal ReadState ["$sl0"])) in
      (slice.append (sliceT ReadState)) "$a0" "$a1") in
      do:  ((struct.field_ref raft "readStates" (![ptrT] "r")) <-[sliceT ReadState] "$r0");;;
      return: (struct.make raftpb.Message [{
       }])
    else do:  #());;;
    return: (struct.make raftpb.Message [{
       "Type" ::= raftpb.MsgReadIndexResp;
       "To" ::= ![uint64T] (struct.field_ref raftpb.Message "From" "req");
       "Index" ::= ![uint64T] "readIndex";
       "Entries" ::= ![sliceT raftpb.Entry] (struct.field_ref raftpb.Message "Entries" "req")
     }])).

Definition readIndexStatus : go_type := structT [
  "req" :: raftpb.Message;
  "index" :: uint64T;
  "acks" :: mapT uint64T boolT
]%struct.

(* advance advances the read only request queue kept by the readonly struct.
   It dequeues the requests until it finds the read only request that has
   the same context as the given `m`.

   go: read_only.go:81:21 *)
Definition readOnly__advance : val :=
  rec: "readOnly__advance" "ro" "m" :=
    exception_do (let: "ro" := (ref_ty ptrT "ro") in
    let: "m" := (ref_ty raftpb.Message "m") in
    let: "found" := (ref_ty boolT (zero_val boolT)) in
    let: "i" := (ref_ty intT (zero_val intT)) in
    let: "ctx" := (ref_ty stringT (zero_val stringT)) in
    let: "$r0" := (string.from_bytes (![sliceT byteT] (struct.field_ref raftpb.Message "Context" "m"))) in
    do:  ("ctx" <-[stringT] "$r0");;;
    let: "rss" := (ref_ty (sliceT ptrT) (zero_val (sliceT ptrT))) in
    do:  (let: "$range" := (![sliceT stringT] (struct.field_ref readOnly "readIndexQueue" (![ptrT] "ro"))) in
    slice.for_range stringT "$range" (λ: <> "okctx",
      let: "okctx" := ref_ty stringT "okctx" in
      do:  ("i" <-[intT] ((![intT] "i") + #(W64 1)));;;
      let: "ok" := (ref_ty boolT (zero_val boolT)) in
      let: "rs" := (ref_ty ptrT (zero_val ptrT)) in
      let: ("$ret0", "$ret1") := (map.get (![mapT stringT ptrT] (struct.field_ref readOnly "pendingReadIndex" (![ptrT] "ro"))) (![stringT] "okctx")) in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("rs" <-[ptrT] "$r0");;;
      do:  ("ok" <-[boolT] "$r1");;;
      (if: (~ (![boolT] "ok"))
      then
        do:  (let: "$a0" := (interface.make string__mset #(str "cannot find corresponding read state from pending map")) in
        Panic "$a0")
      else do:  #());;;
      let: "$r0" := (let: "$a0" := (![sliceT ptrT] "rss") in
      let: "$a1" := ((let: "$sl0" := (![ptrT] "rs") in
      slice.literal ptrT ["$sl0"])) in
      (slice.append (sliceT ptrT)) "$a0" "$a1") in
      do:  ("rss" <-[sliceT ptrT] "$r0");;;
      (if: (![stringT] "okctx") = (![stringT] "ctx")
      then
        let: "$r0" := #true in
        do:  ("found" <-[boolT] "$r0");;;
        break: #()
      else do:  #())));;;
    (if: ![boolT] "found"
    then
      let: "$r0" := (let: "$s" := (![sliceT stringT] (struct.field_ref readOnly "readIndexQueue" (![ptrT] "ro"))) in
      slice.slice stringT "$s" (![intT] "i") (slice.len "$s")) in
      do:  ((struct.field_ref readOnly "readIndexQueue" (![ptrT] "ro")) <-[sliceT stringT] "$r0");;;
      do:  (let: "$range" := (![sliceT ptrT] "rss") in
      slice.for_range ptrT "$range" (λ: <> "rs",
        let: "rs" := ref_ty ptrT "rs" in
        do:  (let: "$a0" := (![mapT stringT ptrT] (struct.field_ref readOnly "pendingReadIndex" (![ptrT] "ro"))) in
        let: "$a1" := (string.from_bytes (![sliceT byteT] (struct.field_ref raftpb.Entry "Data" (slice.elem_ref raftpb.Entry (![sliceT raftpb.Entry] (struct.field_ref raftpb.Message "Entries" (struct.field_ref readIndexStatus "req" (![ptrT] "rs")))) #(W64 0))))) in
        map.delete "$a0" "$a1")));;;
      return: (![sliceT ptrT] "rss")
    else do:  #());;;
    return: (slice.nil)).

(* recvAck notifies the readonly struct that the raft state machine received
   an acknowledgment of the heartbeat that attached with the read only request
   context.

   go: read_only.go:68:21 *)
Definition readOnly__recvAck : val :=
  rec: "readOnly__recvAck" "ro" "id" "context" :=
    exception_do (let: "ro" := (ref_ty ptrT "ro") in
    let: "context" := (ref_ty (sliceT byteT) "context") in
    let: "id" := (ref_ty uint64T "id") in
    let: "ok" := (ref_ty boolT (zero_val boolT)) in
    let: "rs" := (ref_ty ptrT (zero_val ptrT)) in
    let: ("$ret0", "$ret1") := (map.get (![mapT stringT ptrT] (struct.field_ref readOnly "pendingReadIndex" (![ptrT] "ro"))) (string.from_bytes (![sliceT byteT] "context"))) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("rs" <-[ptrT] "$r0");;;
    do:  ("ok" <-[boolT] "$r1");;;
    (if: (~ (![boolT] "ok"))
    then return: (map.nil)
    else do:  #());;;
    let: "$r0" := #true in
    do:  (map.insert (![mapT uint64T boolT] (struct.field_ref readIndexStatus "acks" (![ptrT] "rs"))) (![uint64T] "id") "$r0");;;
    return: (![mapT uint64T boolT] (struct.field_ref readIndexStatus "acks" (![ptrT] "rs")))).

Definition ReadOnlySafe : expr := #(W64 0).

Definition ReadOnlyLeaseBased : expr := #(W64 1).

(* sendHeartbeat sends a heartbeat RPC to the given peer.

   go: raft.go:692:16 *)
Definition raft__sendHeartbeat : val :=
  rec: "raft__sendHeartbeat" "r" "to" "ctx" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "ctx" := (ref_ty (sliceT byteT) "ctx") in
    let: "to" := (ref_ty uint64T "to") in
    let: "pr" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (Fst (map.get (![tracker.ProgressMap] (struct.field_ref tracker.ProgressTracker "Progress" (struct.field_ref raft "trk" (![ptrT] "r")))) (![uint64T] "to"))) in
    do:  ("pr" <-[ptrT] "$r0");;;
    let: "commit" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (let: "$a0" := (![uint64T] (struct.field_ref tracker.Progress "Match" (![ptrT] "pr"))) in
    let: "$a1" := (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r"))))) in
    (minUint64 2) "$a0" "$a1") in
    do:  ("commit" <-[uint64T] "$r0");;;
    do:  (let: "$a0" := (struct.make raftpb.Message [{
      "To" ::= ![uint64T] "to";
      "Type" ::= raftpb.MsgHeartbeat;
      "Commit" ::= ![uint64T] "commit";
      "Context" ::= ![sliceT byteT] "ctx"
    }]) in
    (raft__send (![ptrT] "r")) "$a0");;;
    do:  (let: "$a0" := (![uint64T] "commit") in
    (tracker.Progress__SentCommit (![ptrT] "pr")) "$a0")).

(* go: raft.go:731:16 *)
Definition raft__bcastHeartbeatWithCtx : val :=
  rec: "raft__bcastHeartbeatWithCtx" "r" "ctx" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "ctx" := (ref_ty (sliceT byteT) "ctx") in
    do:  (let: "$a0" := (λ: "id" <>,
      exception_do (let: <> := (ref_ty ptrT "_") in
      let: "id" := (ref_ty uint64T "id") in
      (if: (![uint64T] "id") = (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))
      then return: (#())
      else do:  #());;;
      do:  (let: "$a0" := (![uint64T] "id") in
      let: "$a1" := (![sliceT byteT] "ctx") in
      (raft__sendHeartbeat (![ptrT] "r")) "$a0" "$a1"))
      ) in
    (tracker.ProgressTracker__Visit (struct.field_ref raft "trk" (![ptrT] "r"))) "$a0")).

(* addRequest adds a read only request into readonly struct.
   `index` is the commit index of the raft state machine when it received
   the read only request.
   `m` is the original read only request message from the local or remote node.

   go: read_only.go:56:21 *)
Definition readOnly__addRequest : val :=
  rec: "readOnly__addRequest" "ro" "index" "m" :=
    exception_do (let: "ro" := (ref_ty ptrT "ro") in
    let: "m" := (ref_ty raftpb.Message "m") in
    let: "index" := (ref_ty uint64T "index") in
    let: "s" := (ref_ty stringT (zero_val stringT)) in
    let: "$r0" := (string.from_bytes (![sliceT byteT] (struct.field_ref raftpb.Entry "Data" (slice.elem_ref raftpb.Entry (![sliceT raftpb.Entry] (struct.field_ref raftpb.Message "Entries" "m")) #(W64 0))))) in
    do:  ("s" <-[stringT] "$r0");;;
    (let: "ok" := (ref_ty boolT (zero_val boolT)) in
    let: <> := (ref_ty ptrT (zero_val ptrT)) in
    let: ("$ret0", "$ret1") := (map.get (![mapT stringT ptrT] (struct.field_ref readOnly "pendingReadIndex" (![ptrT] "ro"))) (![stringT] "s")) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  "$r0";;;
    do:  ("ok" <-[boolT] "$r1");;;
    (if: ![boolT] "ok"
    then return: (#())
    else do:  #()));;;
    let: "$r0" := (ref_ty readIndexStatus (struct.make readIndexStatus [{
      "index" ::= ![uint64T] "index";
      "req" ::= ![raftpb.Message] "m";
      "acks" ::= map.make uint64T boolT #()
    }])) in
    do:  (map.insert (![mapT stringT ptrT] (struct.field_ref readOnly "pendingReadIndex" (![ptrT] "ro"))) (![stringT] "s") "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT stringT] (struct.field_ref readOnly "readIndexQueue" (![ptrT] "ro"))) in
    let: "$a1" := ((let: "$sl0" := (![stringT] "s") in
    slice.literal stringT ["$sl0"])) in
    (slice.append (sliceT stringT)) "$a0" "$a1") in
    do:  ((struct.field_ref readOnly "readIndexQueue" (![ptrT] "ro")) <-[sliceT stringT] "$r0")).

(* go: raft.go:2144:6 *)
Definition sendMsgReadIndexResponse : val :=
  rec: "sendMsgReadIndexResponse" "r" "m" :=
    exception_do (let: "m" := (ref_ty raftpb.Message "m") in
    let: "r" := (ref_ty ptrT "r") in
    let: "$sw" := (![ReadOnlyOption] (struct.field_ref readOnly "option" (![ptrT] (struct.field_ref raft "readOnly" (![ptrT] "r"))))) in
    (if: "$sw" = ReadOnlySafe
    then
      do:  (let: "$a0" := (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r"))))) in
      let: "$a1" := (![raftpb.Message] "m") in
      (readOnly__addRequest (![ptrT] (struct.field_ref raft "readOnly" (![ptrT] "r")))) "$a0" "$a1");;;
      do:  (let: "$a0" := (![uint64T] (struct.field_ref raft "id" (![ptrT] "r"))) in
      let: "$a1" := (![sliceT byteT] (struct.field_ref raftpb.Entry "Data" (slice.elem_ref raftpb.Entry (![sliceT raftpb.Entry] (struct.field_ref raftpb.Message "Entries" "m")) #(W64 0)))) in
      (readOnly__recvAck (![ptrT] (struct.field_ref raft "readOnly" (![ptrT] "r")))) "$a0" "$a1");;;
      do:  (let: "$a0" := (![sliceT byteT] (struct.field_ref raftpb.Entry "Data" (slice.elem_ref raftpb.Entry (![sliceT raftpb.Entry] (struct.field_ref raftpb.Message "Entries" "m")) #(W64 0)))) in
      (raft__bcastHeartbeatWithCtx (![ptrT] "r")) "$a0")
    else
      (if: "$sw" = ReadOnlyLeaseBased
      then
        (let: "resp" := (ref_ty raftpb.Message (zero_val raftpb.Message)) in
        let: "$r0" := (let: "$a0" := (![raftpb.Message] "m") in
        let: "$a1" := (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r"))))) in
        (raft__responseToReadIndexReq (![ptrT] "r")) "$a0" "$a1") in
        do:  ("resp" <-[raftpb.Message] "$r0");;;
        (if: (![uint64T] (struct.field_ref raftpb.Message "To" "resp")) ≠ None
        then
          do:  (let: "$a0" := (![raftpb.Message] "resp") in
          (raft__send (![ptrT] "r")) "$a0")
        else do:  #()))
      else #()))).

(* go: log.go:567:19 *)
Definition raftLog__zeroTermOnOutOfBounds : val :=
  rec: "raftLog__zeroTermOnOutOfBounds" "l" "t" "err" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "err" := (ref_ty error "err") in
    let: "t" := (ref_ty uint64T "t") in
    (if: (![error] "err") = (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
    then return: (![uint64T] "t")
    else do:  #());;;
    (if: ((![error] "err") = (![error] "ErrCompacted")) || ((![error] "err") = (![error] "ErrUnavailable"))
    then return: (#(W64 0))
    else do:  #());;;
    do:  (let: "$a0" := #(str "unexpected error (%v)") in
    let: "$a1" := ((let: "$sl0" := (interface.make error__mset (![error] "err")) in
    slice.literal interfaceT ["$sl0"])) in
    (interface.get "Panicf" (![Logger] (struct.field_ref raftLog "logger" (![ptrT] "l")))) "$a0" "$a1");;;
    return: (#(W64 0))).

(* committedEntryInCurrentTerm return true if the peer has committed an entry in its term.

   go: raft.go:2064:16 *)
Definition raft__committedEntryInCurrentTerm : val :=
  rec: "raft__committedEntryInCurrentTerm" "r" <> :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    return: ((let: ("$ret0", "$ret1") := ((let: "$a0" := (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r"))))) in
     (raftLog__term (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) "$a0")) in
     let: "$a0" := "$ret0" in
     let: "$a1" := "$ret1" in
     (raftLog__zeroTermOnOutOfBounds (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) "$a0" "$a1") = (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r"))))).

(* go: raft.go:2125:6 *)
Definition releasePendingReadIndexMessages : val :=
  rec: "releasePendingReadIndexMessages" "r" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    (if: (let: "$a0" := (![sliceT raftpb.Message] (struct.field_ref raft "pendingReadIndexMessages" (![ptrT] "r"))) in
    slice.len "$a0") = #(W64 0)
    then return: (#())
    else do:  #());;;
    (if: (~ ((raft__committedEntryInCurrentTerm (![ptrT] "r")) #()))
    then
      do:  (let: "$a0" := ((let: "$sl0" := (interface.make string__mset #(str "pending MsgReadIndex should be released only after first commit in current term")) in
      slice.literal interfaceT ["$sl0"])) in
      (interface.get "Error" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0");;;
      return: (#())
    else do:  #());;;
    let: "msgs" := (ref_ty (sliceT raftpb.Message) (zero_val (sliceT raftpb.Message))) in
    let: "$r0" := (![sliceT raftpb.Message] (struct.field_ref raft "pendingReadIndexMessages" (![ptrT] "r"))) in
    do:  ("msgs" <-[sliceT raftpb.Message] "$r0");;;
    let: "$r0" := slice.nil in
    do:  ((struct.field_ref raft "pendingReadIndexMessages" (![ptrT] "r")) <-[sliceT raftpb.Message] "$r0");;;
    do:  (let: "$range" := (![sliceT raftpb.Message] "msgs") in
    slice.for_range raftpb.Message "$range" (λ: <> "m",
      let: "m" := ref_ty raftpb.Message "m" in
      do:  (let: "$a0" := (![ptrT] "r") in
      let: "$a1" := (![raftpb.Message] "m") in
      sendMsgReadIndexResponse "$a0" "$a1")))).

(* findConflictByTerm returns a best guess on where this log ends matching
   another log, given that the only information known about the other log is the
   (index, term) of its single entry.

   Specifically, the first returned value is the max guessIndex <= index, such
   that term(guessIndex) <= term or term(guessIndex) is not known (because this
   index is compacted or not yet stored).

   The second returned value is the term(guessIndex), or 0 if it is unknown.

   This function is used by a follower and leader to resolve log conflicts after
   an unsuccessful append to a follower, and ultimately restore the steady flow
   of appends.

   go: log.go:181:19 *)
Definition raftLog__findConflictByTerm : val :=
  rec: "raftLog__findConflictByTerm" "l" "index" "term" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "term" := (ref_ty uint64T "term") in
    let: "index" := (ref_ty uint64T "index") in
    (for: (λ: <>, (![uint64T] "index") > #(W64 0)); (λ: <>, do:  ("index" <-[uint64T] ((![uint64T] "index") - #(W64 1)))) := λ: <>,
      (let: "err" := (ref_ty error (zero_val error)) in
      let: "ourTerm" := (ref_ty uint64T (zero_val uint64T)) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![uint64T] "index") in
      (raftLog__term (![ptrT] "l")) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("ourTerm" <-[uint64T] "$r0");;;
      do:  ("err" <-[error] "$r1");;;
      (if: (![error] "err") ≠ (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
      then return: (![uint64T] "index", #(W64 0))
      else
        (if: (![uint64T] "ourTerm") ≤ (![uint64T] "term")
        then return: (![uint64T] "index", ![uint64T] "ourTerm")
        else do:  #()))));;;
    return: (#(W64 0), #(W64 0))).

(* go: state_trace_nop.go:44:6 *)
Definition traceChangeConfEvent : val :=
  rec: "traceChangeConfEvent" "" "" :=
    exception_do (let: "" := (ref_ty ptrT "") in
    let: "" := (ref_ty raftpb.ConfChangeI "") in
    do:  #()).

(* lastPendingRequestCtx returns the context of the last pending read only
   request in readonly struct.

   go: read_only.go:116:21 *)
Definition readOnly__lastPendingRequestCtx : val :=
  rec: "readOnly__lastPendingRequestCtx" "ro" <> :=
    exception_do (let: "ro" := (ref_ty ptrT "ro") in
    (if: (let: "$a0" := (![sliceT stringT] (struct.field_ref readOnly "readIndexQueue" (![ptrT] "ro"))) in
    slice.len "$a0") = #(W64 0)
    then return: (#(str ""))
    else do:  #());;;
    return: (![stringT] (slice.elem_ref stringT (![sliceT stringT] (struct.field_ref readOnly "readIndexQueue" (![ptrT] "ro"))) ((let: "$a0" := (![sliceT stringT] (struct.field_ref readOnly "readIndexQueue" (![ptrT] "ro"))) in
     slice.len "$a0") - #(W64 1))))).

(* bcastHeartbeat sends RPC, without entries to all the peers.

   go: raft.go:722:16 *)
Definition raft__bcastHeartbeat : val :=
  rec: "raft__bcastHeartbeat" "r" <> :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "lastCtx" := (ref_ty stringT (zero_val stringT)) in
    let: "$r0" := ((readOnly__lastPendingRequestCtx (![ptrT] (struct.field_ref raft "readOnly" (![ptrT] "r")))) #()) in
    do:  ("lastCtx" <-[stringT] "$r0");;;
    (if: (let: "$a0" := (![stringT] "lastCtx") in
    StringLength "$a0") = #(W64 0)
    then
      do:  (let: "$a0" := slice.nil in
      (raft__bcastHeartbeatWithCtx (![ptrT] "r")) "$a0")
    else
      do:  (let: "$a0" := (string.to_bytes (![stringT] "lastCtx")) in
      (raft__bcastHeartbeatWithCtx (![ptrT] "r")) "$a0"))).

(* go: raft.go:1269:6 *)
Definition stepLeader : val :=
  rec: "stepLeader" "r" "m" :=
    exception_do (let: "m" := (ref_ty raftpb.Message "m") in
    let: "r" := (ref_ty ptrT "r") in
    let: "$sw" := (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) in
    (if: "$sw" = raftpb.MsgBeat
    then
      do:  ((raft__bcastHeartbeat (![ptrT] "r")) #());;;
      return: (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
    else
      (if: "$sw" = raftpb.MsgCheckQuorum
      then
        (if: (~ ((tracker.ProgressTracker__QuorumActive (struct.field_ref raft "trk" (![ptrT] "r"))) #()))
        then
          do:  (let: "$a0" := #(str "%x stepped down to follower since quorum is not active") in
          let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
          slice.literal interfaceT ["$sl0"])) in
          (interface.get "Warningf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
          do:  (let: "$a0" := (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r"))) in
          let: "$a1" := None in
          (raft__becomeFollower (![ptrT] "r")) "$a0" "$a1")
        else do:  #());;;
        do:  (let: "$a0" := (λ: "id" "pr",
          exception_do (let: "pr" := (ref_ty ptrT "pr") in
          let: "id" := (ref_ty uint64T "id") in
          (if: (![uint64T] "id") ≠ (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))
          then
            let: "$r0" := #false in
            do:  ((struct.field_ref tracker.Progress "RecentActive" (![ptrT] "pr")) <-[boolT] "$r0")
          else do:  #()))
          ) in
        (tracker.ProgressTracker__Visit (struct.field_ref raft "trk" (![ptrT] "r"))) "$a0");;;
        return: (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
      else
        (if: "$sw" = raftpb.MsgProp
        then
          (if: (let: "$a0" := (![sliceT raftpb.Entry] (struct.field_ref raftpb.Message "Entries" "m")) in
          slice.len "$a0") = #(W64 0)
          then
            do:  (let: "$a0" := #(str "%x stepped empty MsgProp") in
            let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
            slice.literal interfaceT ["$sl0"])) in
            (interface.get "Panicf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1")
          else do:  #());;;
          (if: (Fst (map.get (![tracker.ProgressMap] (struct.field_ref tracker.ProgressTracker "Progress" (struct.field_ref raft "trk" (![ptrT] "r")))) (![uint64T] (struct.field_ref raft "id" (![ptrT] "r"))))) = #null
          then return: (![error] "ErrProposalDropped")
          else do:  #());;;
          (if: (![uint64T] (struct.field_ref raft "leadTransferee" (![ptrT] "r"))) ≠ None
          then
            do:  (let: "$a0" := #(str "%x [term %d] transfer leadership to %x is in progress; dropping proposal") in
            let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
            let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
            let: "$sl2" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "leadTransferee" (![ptrT] "r")))) in
            slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
            (interface.get "Debugf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
            return: (![error] "ErrProposalDropped")
          else do:  #());;;
          do:  (let: "$range" := (![sliceT raftpb.Entry] (struct.field_ref raftpb.Message "Entries" "m")) in
          slice.for_range raftpb.Entry "$range" (λ: "i" <>,
            let: "i" := ref_ty uint64T "i" in
            let: "e" := (ref_ty ptrT (zero_val ptrT)) in
            let: "$r0" := (slice.elem_ref raftpb.Entry (![sliceT raftpb.Entry] (struct.field_ref raftpb.Message "Entries" "m")) (![intT] "i")) in
            do:  ("e" <-[ptrT] "$r0");;;
            let: "cc" := (ref_ty raftpb.ConfChangeI (zero_val raftpb.ConfChangeI)) in
            (if: (![raftpb.EntryType] (struct.field_ref raftpb.Entry "Type" (![ptrT] "e"))) = raftpb.EntryConfChange
            then
              let: "ccc" := (ref_ty raftpb.ConfChange (zero_val raftpb.ConfChange)) in
              (let: "err" := (ref_ty error (zero_val error)) in
              let: "$r0" := (let: "$a0" := (![sliceT byteT] (struct.field_ref raftpb.Entry "Data" (![ptrT] "e"))) in
              (raftpb.ConfChange__Unmarshal "ccc") "$a0") in
              do:  ("err" <-[error] "$r0");;;
              (if: (![error] "err") ≠ (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
              then
                do:  (let: "$a0" := (interface.make error__mset (![error] "err")) in
                Panic "$a0")
              else do:  #()));;;
              let: "$r0" := (interface.make raftpb.ConfChange__mset (![raftpb.ConfChange] "ccc")) in
              do:  ("cc" <-[raftpb.ConfChangeI] "$r0")
            else
              (if: (![raftpb.EntryType] (struct.field_ref raftpb.Entry "Type" (![ptrT] "e"))) = raftpb.EntryConfChangeV2
              then
                let: "ccc" := (ref_ty raftpb.ConfChangeV2 (zero_val raftpb.ConfChangeV2)) in
                (let: "err" := (ref_ty error (zero_val error)) in
                let: "$r0" := (let: "$a0" := (![sliceT byteT] (struct.field_ref raftpb.Entry "Data" (![ptrT] "e"))) in
                (raftpb.ConfChangeV2__Unmarshal "ccc") "$a0") in
                do:  ("err" <-[error] "$r0");;;
                (if: (![error] "err") ≠ (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
                then
                  do:  (let: "$a0" := (interface.make error__mset (![error] "err")) in
                  Panic "$a0")
                else do:  #()));;;
                let: "$r0" := (interface.make raftpb.ConfChangeV2__mset (![raftpb.ConfChangeV2] "ccc")) in
                do:  ("cc" <-[raftpb.ConfChangeI] "$r0")
              else do:  #()));;;
            (if: (![raftpb.ConfChangeI] "cc") ≠ (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
            then
              let: "alreadyPending" := (ref_ty boolT (zero_val boolT)) in
              let: "$r0" := ((![uint64T] (struct.field_ref raft "pendingConfIndex" (![ptrT] "r"))) > (![uint64T] (struct.field_ref raftLog "applied" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))))) in
              do:  ("alreadyPending" <-[boolT] "$r0");;;
              let: "alreadyJoint" := (ref_ty boolT (zero_val boolT)) in
              let: "$r0" := (int_gt (let: "$a0" := (![quorum.MajorityConfig] (array.elem_ref quorum.MajorityConfig (![quorum.JointConfig] (struct.field_ref tracker.Config "Voters" (struct.field_ref tracker.ProgressTracker "Config" (struct.field_ref raft "trk" (![ptrT] "r"))))) #(W64 1))) in
              map.len "$a0") #(W64 0)) in
              do:  ("alreadyJoint" <-[boolT] "$r0");;;
              let: "wantsLeaveJoint" := (ref_ty boolT (zero_val boolT)) in
              let: "$r0" := ((let: "$a0" := (struct.field_get raftpb.ConfChangeV2 "Changes" ((interface.get "AsV2" (![raftpb.ConfChangeI] "cc")) #())) in
              slice.len "$a0") = #(W64 0)) in
              do:  ("wantsLeaveJoint" <-[boolT] "$r0");;;
              let: "failedCheck" := (ref_ty stringT (zero_val stringT)) in
              (if: ![boolT] "alreadyPending"
              then
                let: "$r0" := (let: "$a0" := #(str "possible unapplied conf change at index %d (applied to %d)") in
                let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "pendingConfIndex" (![ptrT] "r")))) in
                let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftLog "applied" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))))) in
                slice.literal interfaceT ["$sl0"; "$sl1"])) in
                fmt.Sprintf "$a0" "$a1") in
                do:  ("failedCheck" <-[stringT] "$r0")
              else
                (if: (![boolT] "alreadyJoint") && (~ (![boolT] "wantsLeaveJoint"))
                then
                  let: "$r0" := #(str "must transition out of joint config first") in
                  do:  ("failedCheck" <-[stringT] "$r0")
                else
                  (if: (~ (![boolT] "alreadyJoint")) && (![boolT] "wantsLeaveJoint")
                  then
                    let: "$r0" := #(str "not in joint state; refusing empty conf change") in
                    do:  ("failedCheck" <-[stringT] "$r0")
                  else do:  #())));;;
              (if: ((![stringT] "failedCheck") ≠ #(str "")) && (~ (![boolT] (struct.field_ref raft "disableConfChangeValidation" (![ptrT] "r"))))
              then
                do:  (let: "$a0" := #(str "%x ignoring conf change %v at config %s: %s") in
                let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
                let: "$sl1" := (interface.make raftpb.ConfChangeI__mset (![raftpb.ConfChangeI] "cc")) in
                let: "$sl2" := (interface.make tracker.Config__mset (![tracker.Config] (struct.field_ref tracker.ProgressTracker "Config" (struct.field_ref raft "trk" (![ptrT] "r"))))) in
                let: "$sl3" := (interface.make string__mset (![stringT] "failedCheck")) in
                slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"])) in
                (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
                let: "$r0" := (struct.make raftpb.Entry [{
                  "Type" ::= raftpb.EntryNormal
                }]) in
                do:  ((slice.elem_ref raftpb.Entry (![sliceT raftpb.Entry] (struct.field_ref raftpb.Message "Entries" "m")) (![intT] "i")) <-[raftpb.Entry] "$r0")
              else
                let: "$r0" := ((((raftLog__lastIndex (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()) + (![intT] "i")) + #(W64 1)) in
                do:  ((struct.field_ref raft "pendingConfIndex" (![ptrT] "r")) <-[uint64T] "$r0");;;
                do:  (let: "$a0" := (![raftpb.ConfChangeI] "cc") in
                let: "$a1" := (![ptrT] "r") in
                traceChangeConfEvent "$a0" "$a1"))
            else do:  #())));;;
          (if: (~ (let: "$a0" := (![sliceT raftpb.Entry] (struct.field_ref raftpb.Message "Entries" "m")) in
          (raft__appendEntry (![ptrT] "r")) "$a0"))
          then return: (![error] "ErrProposalDropped")
          else do:  #());;;
          do:  ((raft__bcastAppend (![ptrT] "r")) #());;;
          return: (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
        else
          (if: "$sw" = raftpb.MsgReadIndex
          then
            (if: (tracker.ProgressTracker__IsSingleton (struct.field_ref raft "trk" (![ptrT] "r"))) #()
            then
              (let: "resp" := (ref_ty raftpb.Message (zero_val raftpb.Message)) in
              let: "$r0" := (let: "$a0" := (![raftpb.Message] "m") in
              let: "$a1" := (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r"))))) in
              (raft__responseToReadIndexReq (![ptrT] "r")) "$a0" "$a1") in
              do:  ("resp" <-[raftpb.Message] "$r0");;;
              (if: (![uint64T] (struct.field_ref raftpb.Message "To" "resp")) ≠ None
              then
                do:  (let: "$a0" := (![raftpb.Message] "resp") in
                (raft__send (![ptrT] "r")) "$a0")
              else do:  #()));;;
              return: (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
            else do:  #());;;
            (if: (~ ((raft__committedEntryInCurrentTerm (![ptrT] "r")) #()))
            then
              let: "$r0" := (let: "$a0" := (![sliceT raftpb.Message] (struct.field_ref raft "pendingReadIndexMessages" (![ptrT] "r"))) in
              let: "$a1" := ((let: "$sl0" := (![raftpb.Message] "m") in
              slice.literal raftpb.Message ["$sl0"])) in
              (slice.append (sliceT raftpb.Message)) "$a0" "$a1") in
              do:  ((struct.field_ref raft "pendingReadIndexMessages" (![ptrT] "r")) <-[sliceT raftpb.Message] "$r0");;;
              return: (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
            else do:  #());;;
            do:  (let: "$a0" := (![ptrT] "r") in
            let: "$a1" := (![raftpb.Message] "m") in
            sendMsgReadIndexResponse "$a0" "$a1");;;
            return: (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
          else
            (if: "$sw" = raftpb.MsgForgetLeader
            then return: (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
            else #())))));;;
    let: "pr" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (Fst (map.get (![tracker.ProgressMap] (struct.field_ref tracker.ProgressTracker "Progress" (struct.field_ref raft "trk" (![ptrT] "r")))) (![uint64T] (struct.field_ref raftpb.Message "From" "m")))) in
    do:  ("pr" <-[ptrT] "$r0");;;
    (if: (![ptrT] "pr") = #null
    then
      do:  (let: "$a0" := #(str "%x no progress available for %x") in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
      let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "From" "m"))) in
      slice.literal interfaceT ["$sl0"; "$sl1"])) in
      (interface.get "Debugf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
      return: (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
    else do:  #());;;
    let: "$sw" := (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) in
    (if: "$sw" = raftpb.MsgAppResp
    then
      let: "$r0" := #true in
      do:  ((struct.field_ref tracker.Progress "RecentActive" (![ptrT] "pr")) <-[boolT] "$r0");;;
      (if: ![boolT] (struct.field_ref raftpb.Message "Reject" "m")
      then
        do:  (let: "$a0" := #(str "%x received MsgAppResp(rejected, hint: (index %d, term %d)) from %x for index %d") in
        let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
        let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "RejectHint" "m"))) in
        let: "$sl2" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "LogTerm" "m"))) in
        let: "$sl3" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "From" "m"))) in
        let: "$sl4" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "Index" "m"))) in
        slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"; "$sl4"])) in
        (interface.get "Debugf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
        let: "nextProbeIdx" := (ref_ty uint64T (zero_val uint64T)) in
        let: "$r0" := (![uint64T] (struct.field_ref raftpb.Message "RejectHint" "m")) in
        do:  ("nextProbeIdx" <-[uint64T] "$r0");;;
        (if: (![uint64T] (struct.field_ref raftpb.Message "LogTerm" "m")) > #(W64 0)
        then
          let: ("$ret0", "$ret1") := (let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "RejectHint" "m")) in
          let: "$a1" := (![uint64T] (struct.field_ref raftpb.Message "LogTerm" "m")) in
          (raftLog__findConflictByTerm (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) "$a0" "$a1") in
          let: "$r0" := "$ret0" in
          let: "$r1" := "$ret1" in
          do:  ("nextProbeIdx" <-[uint64T] "$r0");;;
          do:  "$r1"
        else do:  #());;;
        (if: let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "Index" "m")) in
        let: "$a1" := (![uint64T] "nextProbeIdx") in
        (tracker.Progress__MaybeDecrTo (![ptrT] "pr")) "$a0" "$a1"
        then
          do:  (let: "$a0" := #(str "%x decreased progress of %x to [%s]") in
          let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
          let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "From" "m"))) in
          let: "$sl2" := (interface.make tracker.Progress__mset_ptr (![ptrT] "pr")) in
          slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
          (interface.get "Debugf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
          (if: (![tracker.StateType] (struct.field_ref tracker.Progress "State" (![ptrT] "pr"))) = tracker.StateReplicate
          then do:  ((tracker.Progress__BecomeProbe (![ptrT] "pr")) #())
          else do:  #());;;
          do:  (let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "From" "m")) in
          (raft__sendAppend (![ptrT] "r")) "$a0")
        else do:  #())
      else
        (if: (let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "Index" "m")) in
        (tracker.Progress__MaybeUpdate (![ptrT] "pr")) "$a0") || (((![uint64T] (struct.field_ref tracker.Progress "Match" (![ptrT] "pr"))) = (![uint64T] (struct.field_ref raftpb.Message "Index" "m"))) && ((![tracker.StateType] (struct.field_ref tracker.Progress "State" (![ptrT] "pr"))) = tracker.StateProbe))
        then
          let: "$sw" := #true in
          (if: "$sw" = ((![tracker.StateType] (struct.field_ref tracker.Progress "State" (![ptrT] "pr"))) = tracker.StateProbe)
          then do:  ((tracker.Progress__BecomeReplicate (![ptrT] "pr")) #())
          else
            (if: "$sw" = (((![tracker.StateType] (struct.field_ref tracker.Progress "State" (![ptrT] "pr"))) = tracker.StateSnapshot) && (((![uint64T] (struct.field_ref tracker.Progress "Match" (![ptrT] "pr"))) + #(W64 1)) ≥ ((raftLog__firstIndex (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #())))
            then
              do:  (let: "$a0" := #(str "%x recovered from needing snapshot, resumed sending replication messages to %x [%s]") in
              let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
              let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "From" "m"))) in
              let: "$sl2" := (interface.make tracker.Progress__mset_ptr (![ptrT] "pr")) in
              slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
              (interface.get "Debugf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
              do:  ((tracker.Progress__BecomeProbe (![ptrT] "pr")) #());;;
              do:  ((tracker.Progress__BecomeReplicate (![ptrT] "pr")) #())
            else
              (if: "$sw" = ((![tracker.StateType] (struct.field_ref tracker.Progress "State" (![ptrT] "pr"))) = tracker.StateReplicate)
              then
                do:  (let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "Index" "m")) in
                (tracker.Inflights__FreeLE (![ptrT] (struct.field_ref tracker.Progress "Inflights" (![ptrT] "pr")))) "$a0")
              else #())));;;
          (if: (raft__maybeCommit (![ptrT] "r")) #()
          then
            do:  (let: "$a0" := (![ptrT] "r") in
            releasePendingReadIndexMessages "$a0");;;
            do:  ((raft__bcastAppend (![ptrT] "r")) #())
          else
            (if: ((![uint64T] (struct.field_ref raft "id" (![ptrT] "r"))) ≠ (![uint64T] (struct.field_ref raftpb.Message "From" "m"))) && (let: "$a0" := (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r"))))) in
            (tracker.Progress__CanBumpCommit (![ptrT] "pr")) "$a0")
            then
              do:  (let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "From" "m")) in
              (raft__sendAppend (![ptrT] "r")) "$a0")
            else do:  #()));;;
          (if: (![uint64T] (struct.field_ref raft "id" (![ptrT] "r"))) ≠ (![uint64T] (struct.field_ref raftpb.Message "From" "m"))
          then
            (for: (λ: <>, let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "From" "m")) in
            let: "$a1" := #false in
            (raft__maybeSendAppend (![ptrT] "r")) "$a0" "$a1"); (λ: <>, Skip) := λ: <>,
              do:  #())
          else do:  #());;;
          (if: ((![uint64T] (struct.field_ref raftpb.Message "From" "m")) = (![uint64T] (struct.field_ref raft "leadTransferee" (![ptrT] "r")))) && ((![uint64T] (struct.field_ref tracker.Progress "Match" (![ptrT] "pr"))) = ((raftLog__lastIndex (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()))
          then
            do:  (let: "$a0" := #(str "%x sent MsgTimeoutNow to %x after received MsgAppResp") in
            let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
            let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "From" "m"))) in
            slice.literal interfaceT ["$sl0"; "$sl1"])) in
            (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
            do:  (let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "From" "m")) in
            (raft__sendTimeoutNow (![ptrT] "r")) "$a0")
          else do:  #())
        else do:  #()))
    else
      (if: "$sw" = raftpb.MsgHeartbeatResp
      then
        let: "$r0" := #true in
        do:  ((struct.field_ref tracker.Progress "RecentActive" (![ptrT] "pr")) <-[boolT] "$r0");;;
        let: "$r0" := #false in
        do:  ((struct.field_ref tracker.Progress "MsgAppFlowPaused" (![ptrT] "pr")) <-[boolT] "$r0");;;
        (if: ((![uint64T] (struct.field_ref tracker.Progress "Match" (![ptrT] "pr"))) < ((raftLog__lastIndex (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #())) || ((![tracker.StateType] (struct.field_ref tracker.Progress "State" (![ptrT] "pr"))) = tracker.StateProbe)
        then
          do:  (let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "From" "m")) in
          (raft__sendAppend (![ptrT] "r")) "$a0")
        else do:  #());;;
        (if: ((![ReadOnlyOption] (struct.field_ref readOnly "option" (![ptrT] (struct.field_ref raft "readOnly" (![ptrT] "r"))))) ≠ ReadOnlySafe) || ((let: "$a0" := (![sliceT byteT] (struct.field_ref raftpb.Message "Context" "m")) in
        slice.len "$a0") = #(W64 0))
        then return: (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
        else do:  #());;;
        (if: (let: "$a0" := (let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "From" "m")) in
        let: "$a1" := (![sliceT byteT] (struct.field_ref raftpb.Message "Context" "m")) in
        (readOnly__recvAck (![ptrT] (struct.field_ref raft "readOnly" (![ptrT] "r")))) "$a0" "$a1") in
        (quorum.JointConfig__VoteResult (![quorum.JointConfig] (struct.field_ref tracker.Config "Voters" (struct.field_ref tracker.ProgressTracker "Config" (struct.field_ref raft "trk" (![ptrT] "r")))))) "$a0") ≠ quorum.VoteWon
        then return: (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
        else do:  #());;;
        let: "rss" := (ref_ty (sliceT ptrT) (zero_val (sliceT ptrT))) in
        let: "$r0" := (let: "$a0" := (![raftpb.Message] "m") in
        (readOnly__advance (![ptrT] (struct.field_ref raft "readOnly" (![ptrT] "r")))) "$a0") in
        do:  ("rss" <-[sliceT ptrT] "$r0");;;
        do:  (let: "$range" := (![sliceT ptrT] "rss") in
        slice.for_range ptrT "$range" (λ: <> "rs",
          let: "rs" := ref_ty ptrT "rs" in
          (let: "resp" := (ref_ty raftpb.Message (zero_val raftpb.Message)) in
          let: "$r0" := (let: "$a0" := (![raftpb.Message] (struct.field_ref readIndexStatus "req" (![ptrT] "rs"))) in
          let: "$a1" := (![uint64T] (struct.field_ref readIndexStatus "index" (![ptrT] "rs"))) in
          (raft__responseToReadIndexReq (![ptrT] "r")) "$a0" "$a1") in
          do:  ("resp" <-[raftpb.Message] "$r0");;;
          (if: (![uint64T] (struct.field_ref raftpb.Message "To" "resp")) ≠ None
          then
            do:  (let: "$a0" := (![raftpb.Message] "resp") in
            (raft__send (![ptrT] "r")) "$a0")
          else do:  #()))))
      else
        (if: "$sw" = raftpb.MsgSnapStatus
        then
          (if: (![tracker.StateType] (struct.field_ref tracker.Progress "State" (![ptrT] "pr"))) ≠ tracker.StateSnapshot
          then return: (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
          else do:  #());;;
          (if: (~ (![boolT] (struct.field_ref raftpb.Message "Reject" "m")))
          then
            do:  ((tracker.Progress__BecomeProbe (![ptrT] "pr")) #());;;
            do:  (let: "$a0" := #(str "%x snapshot succeeded, resumed sending replication messages to %x [%s]") in
            let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
            let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "From" "m"))) in
            let: "$sl2" := (interface.make tracker.Progress__mset_ptr (![ptrT] "pr")) in
            slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
            (interface.get "Debugf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1")
          else
            let: "$r0" := #(W64 0) in
            do:  ((struct.field_ref tracker.Progress "PendingSnapshot" (![ptrT] "pr")) <-[uint64T] "$r0");;;
            do:  ((tracker.Progress__BecomeProbe (![ptrT] "pr")) #());;;
            do:  (let: "$a0" := #(str "%x snapshot failed, resumed sending replication messages to %x [%s]") in
            let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
            let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "From" "m"))) in
            let: "$sl2" := (interface.make tracker.Progress__mset_ptr (![ptrT] "pr")) in
            slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
            (interface.get "Debugf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1"));;;
          let: "$r0" := #true in
          do:  ((struct.field_ref tracker.Progress "MsgAppFlowPaused" (![ptrT] "pr")) <-[boolT] "$r0")
        else
          (if: "$sw" = raftpb.MsgUnreachable
          then
            (if: (![tracker.StateType] (struct.field_ref tracker.Progress "State" (![ptrT] "pr"))) = tracker.StateReplicate
            then do:  ((tracker.Progress__BecomeProbe (![ptrT] "pr")) #())
            else do:  #());;;
            do:  (let: "$a0" := #(str "%x failed to send message to %x because it is unreachable [%s]") in
            let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
            let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "From" "m"))) in
            let: "$sl2" := (interface.make tracker.Progress__mset_ptr (![ptrT] "pr")) in
            slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
            (interface.get "Debugf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1")
          else
            (if: "$sw" = raftpb.MsgTransferLeader
            then
              (if: ![boolT] (struct.field_ref tracker.Progress "IsLearner" (![ptrT] "pr"))
              then
                do:  (let: "$a0" := #(str "%x is learner. Ignored transferring leadership") in
                let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
                slice.literal interfaceT ["$sl0"])) in
                (interface.get "Debugf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
                return: (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
              else do:  #());;;
              let: "leadTransferee" := (ref_ty uint64T (zero_val uint64T)) in
              let: "$r0" := (![uint64T] (struct.field_ref raftpb.Message "From" "m")) in
              do:  ("leadTransferee" <-[uint64T] "$r0");;;
              let: "lastLeadTransferee" := (ref_ty uint64T (zero_val uint64T)) in
              let: "$r0" := (![uint64T] (struct.field_ref raft "leadTransferee" (![ptrT] "r"))) in
              do:  ("lastLeadTransferee" <-[uint64T] "$r0");;;
              (if: (![uint64T] "lastLeadTransferee") ≠ None
              then
                (if: (![uint64T] "lastLeadTransferee") = (![uint64T] "leadTransferee")
                then
                  do:  (let: "$a0" := #(str "%x [term %d] transfer leadership to %x is in progress, ignores request to same node %x") in
                  let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
                  let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
                  let: "$sl2" := (interface.make uint64__mset (![uint64T] "leadTransferee")) in
                  let: "$sl3" := (interface.make uint64__mset (![uint64T] "leadTransferee")) in
                  slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"])) in
                  (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
                  return: (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
                else do:  #());;;
                do:  ((raft__abortLeaderTransfer (![ptrT] "r")) #());;;
                do:  (let: "$a0" := #(str "%x [term %d] abort previous transferring leadership to %x") in
                let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
                let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
                let: "$sl2" := (interface.make uint64__mset (![uint64T] "lastLeadTransferee")) in
                slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
                (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1")
              else do:  #());;;
              (if: (![uint64T] "leadTransferee") = (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))
              then
                do:  (let: "$a0" := #(str "%x is already leader. Ignored transferring leadership to self") in
                let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
                slice.literal interfaceT ["$sl0"])) in
                (interface.get "Debugf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
                return: (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
              else do:  #());;;
              do:  (let: "$a0" := #(str "%x [term %d] starts to transfer leadership to %x") in
              let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
              let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
              let: "$sl2" := (interface.make uint64__mset (![uint64T] "leadTransferee")) in
              slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
              (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
              let: "$r0" := #(W64 0) in
              do:  ((struct.field_ref raft "electionElapsed" (![ptrT] "r")) <-[intT] "$r0");;;
              let: "$r0" := (![uint64T] "leadTransferee") in
              do:  ((struct.field_ref raft "leadTransferee" (![ptrT] "r")) <-[uint64T] "$r0");;;
              (if: (![uint64T] (struct.field_ref tracker.Progress "Match" (![ptrT] "pr"))) = ((raftLog__lastIndex (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #())
              then
                do:  (let: "$a0" := (![uint64T] "leadTransferee") in
                (raft__sendTimeoutNow (![ptrT] "r")) "$a0");;;
                do:  (let: "$a0" := #(str "%x sends MsgTimeoutNow to %x immediately as %x already has up-to-date log") in
                let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
                let: "$sl1" := (interface.make uint64__mset (![uint64T] "leadTransferee")) in
                let: "$sl2" := (interface.make uint64__mset (![uint64T] "leadTransferee")) in
                slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
                (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1")
              else
                do:  (let: "$a0" := (![uint64T] "leadTransferee") in
                (raft__sendAppend (![ptrT] "r")) "$a0"))
            else #())))));;;
    return: (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)).

(* go: raft.go:934:16 *)
Definition raft__becomeLeader : val :=
  rec: "raft__becomeLeader" "r" <> :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    (if: (![StateType] (struct.field_ref raft "state" (![ptrT] "r"))) = StateFollower
    then
      do:  (let: "$a0" := (interface.make string__mset #(str "invalid transition [follower -> leader]")) in
      Panic "$a0")
    else do:  #());;;
    let: "$r0" := stepLeader in
    do:  ((struct.field_ref raft "step" (![ptrT] "r")) <-[stepFunc] "$r0");;;
    do:  (let: "$a0" := (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r"))) in
    (raft__reset (![ptrT] "r")) "$a0");;;
    let: "$r0" := (raft__tickHeartbeat (![ptrT] "r")) in
    do:  ((struct.field_ref raft "tick" (![ptrT] "r")) <-[funcT] "$r0");;;
    let: "$r0" := (![uint64T] (struct.field_ref raft "id" (![ptrT] "r"))) in
    do:  ((struct.field_ref raft "lead" (![ptrT] "r")) <-[uint64T] "$r0");;;
    let: "$r0" := StateLeader in
    do:  ((struct.field_ref raft "state" (![ptrT] "r")) <-[StateType] "$r0");;;
    let: "pr" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (Fst (map.get (![tracker.ProgressMap] (struct.field_ref tracker.ProgressTracker "Progress" (struct.field_ref raft "trk" (![ptrT] "r")))) (![uint64T] (struct.field_ref raft "id" (![ptrT] "r"))))) in
    do:  ("pr" <-[ptrT] "$r0");;;
    do:  ((tracker.Progress__BecomeReplicate (![ptrT] "pr")) #());;;
    let: "$r0" := #true in
    do:  ((struct.field_ref tracker.Progress "RecentActive" (![ptrT] "pr")) <-[boolT] "$r0");;;
    let: "$r0" := ((raftLog__lastIndex (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()) in
    do:  ((struct.field_ref raft "pendingConfIndex" (![ptrT] "r")) <-[uint64T] "$r0");;;
    do:  (let: "$a0" := (![ptrT] "r") in
    traceBecomeLeader "$a0");;;
    let: "emptyEnt" := (ref_ty raftpb.Entry (zero_val raftpb.Entry)) in
    let: "$r0" := (struct.make raftpb.Entry [{
      "Data" ::= slice.nil
    }]) in
    do:  ("emptyEnt" <-[raftpb.Entry] "$r0");;;
    (if: (~ (let: "$a0" := ((let: "$sl0" := (![raftpb.Entry] "emptyEnt") in
    slice.literal raftpb.Entry ["$sl0"])) in
    (raft__appendEntry (![ptrT] "r")) "$a0"))
    then
      do:  (let: "$a0" := ((let: "$sl0" := (interface.make string__mset #(str "empty entry was dropped")) in
      slice.literal interfaceT ["$sl0"])) in
      (interface.get "Panic" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0")
    else do:  #());;;
    do:  (let: "$a0" := #(str "%x became leader at term %d") in
    let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
    let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
    slice.literal interfaceT ["$sl0"; "$sl1"])) in
    (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1")).

Definition StatePreCandidate : expr := #(W64 3).

(* campaign transitions the raft instance to candidate state. This must only be
   called after verifying that this is a legitimate transition.

   go: raft.go:1026:16 *)
Definition raft__campaign : val :=
  rec: "raft__campaign" "r" "t" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "t" := (ref_ty CampaignType "t") in
    (if: (~ ((raft__promotable (![ptrT] "r")) #()))
    then
      do:  (let: "$a0" := #(str "%x is unpromotable; campaign() should have been called") in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
      slice.literal interfaceT ["$sl0"])) in
      (interface.get "Warningf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1")
    else do:  #());;;
    let: "term" := (ref_ty uint64T (zero_val uint64T)) in
    let: "voteMsg" := (ref_ty raftpb.MessageType (zero_val raftpb.MessageType)) in
    (if: (![CampaignType] "t") = campaignPreElection
    then
      do:  ((raft__becomePreCandidate (![ptrT] "r")) #());;;
      let: "$r0" := raftpb.MsgPreVote in
      do:  ("voteMsg" <-[raftpb.MessageType] "$r0");;;
      let: "$r0" := ((![uint64T] (struct.field_ref raft "Term" (![ptrT] "r"))) + #(W64 1)) in
      do:  ("term" <-[uint64T] "$r0")
    else
      do:  ((raft__becomeCandidate (![ptrT] "r")) #());;;
      let: "$r0" := raftpb.MsgVote in
      do:  ("voteMsg" <-[raftpb.MessageType] "$r0");;;
      let: "$r0" := (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r"))) in
      do:  ("term" <-[uint64T] "$r0"));;;
    let: "ids" := (ref_ty (sliceT uint64T) (zero_val (sliceT uint64T))) in
    let: "idMap" := (ref_ty (mapT uint64T structT [
    ]%struct) (zero_val (mapT uint64T structT [
    ]%struct))) in
    let: "$r0" := ((quorum.JointConfig__IDs (![quorum.JointConfig] (struct.field_ref tracker.Config "Voters" (struct.field_ref tracker.ProgressTracker "Config" (struct.field_ref raft "trk" (![ptrT] "r")))))) #()) in
    do:  ("idMap" <-[mapT uint64T structT [
    ]%struct] "$r0");;;
    let: "$r0" := (slice.make3 uint64T #(W64 0) (let: "$a0" := (![mapT uint64T structT [
    ]%struct] "idMap") in
    map.len "$a0")) in
    do:  ("ids" <-[sliceT uint64T] "$r0");;;
    do:  (map.for_range (![mapT uint64T structT [
    ]%struct] "idMap") (λ: "id" <>,
      let: "$r0" := (let: "$a0" := (![sliceT uint64T] "ids") in
      let: "$a1" := ((let: "$sl0" := (![uint64T] "id") in
      slice.literal uint64T ["$sl0"])) in
      (slice.append (sliceT uint64T)) "$a0" "$a1") in
      do:  ("ids" <-[sliceT uint64T] "$r0")));;;
    do:  (let: "$a0" := (interface.make slice__mset (![sliceT uint64T] "ids")) in
    let: "$a1" := (λ: "i" "j",
      exception_do (let: "j" := (ref_ty intT "j") in
      let: "i" := (ref_ty intT "i") in
      return: ((![uint64T] (slice.elem_ref uint64T (![sliceT uint64T] "ids") (![intT] "i"))) < (![uint64T] (slice.elem_ref uint64T (![sliceT uint64T] "ids") (![intT] "j")))))
      ) in
    sort.Slice "$a0" "$a1");;;
    do:  (let: "$range" := (![sliceT uint64T] "ids") in
    slice.for_range uint64T "$range" (λ: <> "id",
      let: "id" := ref_ty uint64T "id" in
      (if: (![uint64T] "id") = (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))
      then
        do:  (let: "$a0" := (struct.make raftpb.Message [{
          "To" ::= ![uint64T] "id";
          "Term" ::= ![uint64T] "term";
          "Type" ::= let: "$a0" := (![raftpb.MessageType] "voteMsg") in
          voteRespMsgType "$a0"
        }]) in
        (raft__send (![ptrT] "r")) "$a0");;;
        continue: #()
      else do:  #());;;
      let: "last" := (ref_ty entryID (zero_val entryID)) in
      let: "$r0" := ((raftLog__lastEntryID (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()) in
      do:  ("last" <-[entryID] "$r0");;;
      do:  (let: "$a0" := #(str "%x [logterm: %d, index: %d] sent %s request to %x at term %d") in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
      let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref entryID "term" "last"))) in
      let: "$sl2" := (interface.make uint64__mset (![uint64T] (struct.field_ref entryID "index" "last"))) in
      let: "$sl3" := (interface.make raftpb.MessageType__mset (![raftpb.MessageType] "voteMsg")) in
      let: "$sl4" := (interface.make uint64__mset (![uint64T] "id")) in
      let: "$sl5" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
      slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"; "$sl4"; "$sl5"])) in
      (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
      let: "ctx" := (ref_ty (sliceT byteT) (zero_val (sliceT byteT))) in
      (if: (![CampaignType] "t") = campaignTransfer
      then
        let: "$r0" := (string.to_bytes (![CampaignType] "t")) in
        do:  ("ctx" <-[sliceT byteT] "$r0")
      else do:  #());;;
      do:  (let: "$a0" := (struct.make raftpb.Message [{
        "To" ::= ![uint64T] "id";
        "Term" ::= ![uint64T] "term";
        "Type" ::= ![raftpb.MessageType] "voteMsg";
        "Index" ::= ![uint64T] (struct.field_ref entryID "index" "last");
        "LogTerm" ::= ![uint64T] (struct.field_ref entryID "term" "last");
        "Context" ::= ![sliceT byteT] "ctx"
      }]) in
      (raft__send (![ptrT] "r")) "$a0")))).

Definition campaignElection : expr := #(str "CampaignElection").

(* returns (granted, rejected, result)

   go: raft.go:1077:16 *)
Definition raft__poll : val :=
  rec: "raft__poll" "r" "id" "t" "v" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "v" := (ref_ty boolT "v") in
    let: "t" := (ref_ty raftpb.MessageType "t") in
    let: "id" := (ref_ty uint64T "id") in
    (if: ![boolT] "v"
    then
      do:  (let: "$a0" := #(str "%x received %s from %x at term %d") in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
      let: "$sl1" := (interface.make raftpb.MessageType__mset (![raftpb.MessageType] "t")) in
      let: "$sl2" := (interface.make uint64__mset (![uint64T] "id")) in
      let: "$sl3" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
      slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"])) in
      (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1")
    else
      do:  (let: "$a0" := #(str "%x received %s rejection from %x at term %d") in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
      let: "$sl1" := (interface.make raftpb.MessageType__mset (![raftpb.MessageType] "t")) in
      let: "$sl2" := (interface.make uint64__mset (![uint64T] "id")) in
      let: "$sl3" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
      slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"])) in
      (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1"));;;
    do:  (let: "$a0" := (![uint64T] "id") in
    let: "$a1" := (![boolT] "v") in
    (tracker.ProgressTracker__RecordVote (struct.field_ref raft "trk" (![ptrT] "r"))) "$a0" "$a1");;;
    let: (("$ret0", "$ret1"), "$ret2") := (((tracker.ProgressTracker__TallyVotes (struct.field_ref raft "trk" (![ptrT] "r"))) #())) in
    return: ("$ret0", "$ret1", "$ret2")).

(* go: util.go:302:6 *)
Definition assertConfStatesEquivalent : val :=
  rec: "assertConfStatesEquivalent" "l" "cs1" "cs2" :=
    exception_do (let: "cs2" := (ref_ty raftpb.ConfState "cs2") in
    let: "cs1" := (ref_ty raftpb.ConfState "cs1") in
    let: "l" := (ref_ty Logger "l") in
    let: "err" := (ref_ty error (zero_val error)) in
    let: "$r0" := (let: "$a0" := (![raftpb.ConfState] "cs2") in
    (raftpb.ConfState__Equivalent (![raftpb.ConfState] "cs1")) "$a0") in
    do:  ("err" <-[error] "$r0");;;
    (if: (![error] "err") = (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
    then return: (#())
    else do:  #());;;
    do:  (let: "$a0" := ((let: "$sl0" := (interface.make error__mset (![error] "err")) in
    slice.literal interfaceT ["$sl0"])) in
    (interface.get "Panic" (![Logger] "l")) "$a0")).

(* switchToConfig reconfigures this node to use the provided configuration. It
   updates the in-memory state and, when necessary, carries out additional
   actions such as reacting to the removal of nodes or changed quorum
   requirements.

   The inputs usually result from restoring a ConfState or applying a ConfChange.

   go: raft.go:1977:16 *)
Definition raft__switchToConfig : val :=
  rec: "raft__switchToConfig" "r" "cfg" "trk" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "trk" := (ref_ty tracker.ProgressMap "trk") in
    let: "cfg" := (ref_ty tracker.Config "cfg") in
    do:  (let: "$a0" := (![tracker.Config] "cfg") in
    let: "$a1" := (![ptrT] "r") in
    traceConfChangeEvent "$a0" "$a1");;;
    let: "$r0" := (![tracker.Config] "cfg") in
    do:  ((struct.field_ref tracker.ProgressTracker "Config" (struct.field_ref raft "trk" (![ptrT] "r"))) <-[tracker.Config] "$r0");;;
    let: "$r0" := (![tracker.ProgressMap] "trk") in
    do:  ((struct.field_ref tracker.ProgressTracker "Progress" (struct.field_ref raft "trk" (![ptrT] "r"))) <-[tracker.ProgressMap] "$r0");;;
    do:  (let: "$a0" := #(str "%x switched to configuration %s") in
    let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
    let: "$sl1" := (interface.make tracker.Config__mset (![tracker.Config] (struct.field_ref tracker.ProgressTracker "Config" (struct.field_ref raft "trk" (![ptrT] "r"))))) in
    slice.literal interfaceT ["$sl0"; "$sl1"])) in
    (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
    let: "cs" := (ref_ty raftpb.ConfState (zero_val raftpb.ConfState)) in
    let: "$r0" := ((tracker.ProgressTracker__ConfState (struct.field_ref raft "trk" (![ptrT] "r"))) #()) in
    do:  ("cs" <-[raftpb.ConfState] "$r0");;;
    let: "ok" := (ref_ty boolT (zero_val boolT)) in
    let: "pr" := (ref_ty ptrT (zero_val ptrT)) in
    let: ("$ret0", "$ret1") := (map.get (![tracker.ProgressMap] (struct.field_ref tracker.ProgressTracker "Progress" (struct.field_ref raft "trk" (![ptrT] "r")))) (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("pr" <-[ptrT] "$r0");;;
    do:  ("ok" <-[boolT] "$r1");;;
    let: "$r0" := ((![boolT] "ok") && (![boolT] (struct.field_ref tracker.Progress "IsLearner" (![ptrT] "pr")))) in
    do:  ((struct.field_ref raft "isLearner" (![ptrT] "r")) <-[boolT] "$r0");;;
    (if: ((~ (![boolT] "ok")) || (![boolT] (struct.field_ref raft "isLearner" (![ptrT] "r")))) && ((![StateType] (struct.field_ref raft "state" (![ptrT] "r"))) = StateLeader)
    then
      (if: ![boolT] (struct.field_ref raft "stepDownOnRemoval" (![ptrT] "r"))
      then
        do:  (let: "$a0" := (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r"))) in
        let: "$a1" := None in
        (raft__becomeFollower (![ptrT] "r")) "$a0" "$a1")
      else do:  #());;;
      return: (![raftpb.ConfState] "cs")
    else do:  #());;;
    (if: ((![StateType] (struct.field_ref raft "state" (![ptrT] "r"))) ≠ StateLeader) || ((let: "$a0" := (![sliceT uint64T] (struct.field_ref raftpb.ConfState "Voters" "cs")) in
    slice.len "$a0") = #(W64 0))
    then return: (![raftpb.ConfState] "cs")
    else do:  #());;;
    (if: (raft__maybeCommit (![ptrT] "r")) #()
    then do:  ((raft__bcastAppend (![ptrT] "r")) #())
    else
      do:  (let: "$a0" := (λ: "id" <>,
        exception_do (let: <> := (ref_ty ptrT "_") in
        let: "id" := (ref_ty uint64T "id") in
        (if: (![uint64T] "id") = (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))
        then return: (#())
        else do:  #());;;
        do:  (let: "$a0" := (![uint64T] "id") in
        let: "$a1" := #false in
        (raft__maybeSendAppend (![ptrT] "r")) "$a0" "$a1"))
        ) in
      (tracker.ProgressTracker__Visit (struct.field_ref raft "trk" (![ptrT] "r"))) "$a0"));;;
    (let: "tOK" := (ref_ty boolT (zero_val boolT)) in
    let: <> := (ref_ty structT [
    ]%struct (zero_val structT [
    ]%struct)) in
    let: ("$ret0", "$ret1") := (map.get ((quorum.JointConfig__IDs (![quorum.JointConfig] (struct.field_ref tracker.Config "Voters" (struct.field_ref tracker.ProgressTracker "Config" (struct.field_ref raft "trk" (![ptrT] "r")))))) #()) (![uint64T] (struct.field_ref raft "leadTransferee" (![ptrT] "r")))) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  "$r0";;;
    do:  ("tOK" <-[boolT] "$r1");;;
    (if: (~ (![boolT] "tOK")) && ((![uint64T] (struct.field_ref raft "leadTransferee" (![ptrT] "r"))) ≠ #(W64 0))
    then do:  ((raft__abortLeaderTransfer (![ptrT] "r")) #())
    else do:  #()));;;
    return: (![raftpb.ConfState] "cs")).

(* go: log_unstable.go:189:20 *)
Definition unstable__restore : val :=
  rec: "unstable__restore" "u" "s" :=
    exception_do (let: "u" := (ref_ty ptrT "u") in
    let: "s" := (ref_ty raftpb.Snapshot "s") in
    let: "$r0" := ((![uint64T] (struct.field_ref raftpb.SnapshotMetadata "Index" (struct.field_ref raftpb.Snapshot "Metadata" "s"))) + #(W64 1)) in
    do:  ((struct.field_ref unstable "offset" (![ptrT] "u")) <-[uint64T] "$r0");;;
    let: "$r0" := (![uint64T] (struct.field_ref unstable "offset" (![ptrT] "u"))) in
    do:  ((struct.field_ref unstable "offsetInProgress" (![ptrT] "u")) <-[uint64T] "$r0");;;
    let: "$r0" := slice.nil in
    do:  ((struct.field_ref unstable "entries" (![ptrT] "u")) <-[sliceT raftpb.Entry] "$r0");;;
    let: "$r0" := "s" in
    do:  ((struct.field_ref unstable "snapshot" (![ptrT] "u")) <-[ptrT] "$r0");;;
    let: "$r0" := #false in
    do:  ((struct.field_ref unstable "snapshotInProgress" (![ptrT] "u")) <-[boolT] "$r0")).

(* go: log.go:100:19 *)
Definition raftLog__String : val :=
  rec: "raftLog__String" "l" <> :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    return: (let: "$a0" := #(str "committed=%d, applied=%d, applying=%d, unstable.offset=%d, unstable.offsetInProgress=%d, len(unstable.Entries)=%d") in
     let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] "l")))) in
     let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftLog "applied" (![ptrT] "l")))) in
     let: "$sl2" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftLog "applying" (![ptrT] "l")))) in
     let: "$sl3" := (interface.make uint64__mset (![uint64T] (struct.field_ref unstable "offset" (struct.field_ref raftLog "unstable" (![ptrT] "l"))))) in
     let: "$sl4" := (interface.make uint64__mset (![uint64T] (struct.field_ref unstable "offsetInProgress" (struct.field_ref raftLog "unstable" (![ptrT] "l"))))) in
     let: "$sl5" := (interface.make int__mset (let: "$a0" := (![sliceT raftpb.Entry] (struct.field_ref unstable "entries" (struct.field_ref raftLog "unstable" (![ptrT] "l")))) in
     slice.len "$a0")) in
     slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"; "$sl4"; "$sl5"])) in
     fmt.Sprintf "$a0" "$a1")).

(* maxAppliableIndex returns the maximum committed index that can be applied.
   If allowUnstable is true, committed entries from the unstable log can be
   applied; otherwise, only entries known to reside locally on stable storage
   can be applied.

   go: log.go:267:19 *)
Definition raftLog__maxAppliableIndex : val :=
  rec: "raftLog__maxAppliableIndex" "l" "allowUnstable" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "allowUnstable" := (ref_ty boolT "allowUnstable") in
    let: "hi" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] "l"))) in
    do:  ("hi" <-[uint64T] "$r0");;;
    (if: (~ (![boolT] "allowUnstable"))
    then
      let: "$r0" := (let: "$a0" := (![uint64T] "hi") in
      let: "$a1" := ((![uint64T] (struct.field_ref unstable "offset" (struct.field_ref raftLog "unstable" (![ptrT] "l")))) - #(W64 1)) in
      (minUint64 2) "$a0" "$a1") in
      do:  ("hi" <-[uint64T] "$r0")
    else do:  #());;;
    return: (![uint64T] "hi")).

(* go: log.go:347:19 *)
Definition raftLog__acceptApplying : val :=
  rec: "raftLog__acceptApplying" "l" "i" "size" "allowUnstable" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "allowUnstable" := (ref_ty boolT "allowUnstable") in
    let: "size" := (ref_ty entryEncodingSize "size") in
    let: "i" := (ref_ty uint64T "i") in
    (if: (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] "l"))) < (![uint64T] "i")
    then
      do:  (let: "$a0" := #(str "applying(%d) is out of range [prevApplying(%d), committed(%d)]") in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] "i")) in
      let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftLog "applying" (![ptrT] "l")))) in
      let: "$sl2" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] "l")))) in
      slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
      (interface.get "Panicf" (![Logger] (struct.field_ref raftLog "logger" (![ptrT] "l")))) "$a0" "$a1")
    else do:  #());;;
    let: "$r0" := (![uint64T] "i") in
    do:  ((struct.field_ref raftLog "applying" (![ptrT] "l")) <-[uint64T] "$r0");;;
    do:  ((struct.field_ref raftLog "applyingEntsSize" (![ptrT] "l")) <-[entryEncodingSize] ((![entryEncodingSize] (struct.field_ref raftLog "applyingEntsSize" (![ptrT] "l"))) + (![entryEncodingSize] "size")));;;
    let: "$r0" := (((![entryEncodingSize] (struct.field_ref raftLog "applyingEntsSize" (![ptrT] "l"))) ≥ (![entryEncodingSize] (struct.field_ref raftLog "maxApplyingEntsSize" (![ptrT] "l")))) || ((![uint64T] "i") < (let: "$a0" := (![boolT] "allowUnstable") in
    (raftLog__maxAppliableIndex (![ptrT] "l")) "$a0"))) in
    do:  ((struct.field_ref raftLog "applyingEntsPaused" (![ptrT] "l")) <-[boolT] "$r0")).

(* acceptInProgress marks all entries and the snapshot, if any, in the unstable
   as having begun the process of being written to storage. The entries/snapshot
   will no longer be returned from nextEntries/nextSnapshot. However, new
   entries/snapshots added after a call to acceptInProgress will be returned
   from those methods, until the next call to acceptInProgress.

   go: log_unstable.go:118:20 *)
Definition unstable__acceptInProgress : val :=
  rec: "unstable__acceptInProgress" "u" <> :=
    exception_do (let: "u" := (ref_ty ptrT "u") in
    (if: int_gt (let: "$a0" := (![sliceT raftpb.Entry] (struct.field_ref unstable "entries" (![ptrT] "u"))) in
    slice.len "$a0") #(W64 0)
    then
      let: "$r0" := ((![uint64T] (struct.field_ref raftpb.Entry "Index" (slice.elem_ref raftpb.Entry (![sliceT raftpb.Entry] (struct.field_ref unstable "entries" (![ptrT] "u"))) ((let: "$a0" := (![sliceT raftpb.Entry] (struct.field_ref unstable "entries" (![ptrT] "u"))) in
      slice.len "$a0") - #(W64 1))))) + #(W64 1)) in
      do:  ((struct.field_ref unstable "offsetInProgress" (![ptrT] "u")) <-[uint64T] "$r0")
    else do:  #());;;
    (if: (![ptrT] (struct.field_ref unstable "snapshot" (![ptrT] "u"))) ≠ #null
    then
      let: "$r0" := #true in
      do:  ((struct.field_ref unstable "snapshotInProgress" (![ptrT] "u")) <-[boolT] "$r0")
    else do:  #())).

(* acceptUnstable indicates that the application has started persisting the
   unstable entries in storage, and that the current unstable entries are thus
   to be marked as being in-progress, to avoid returning them with future calls
   to Ready().

   go: log.go:375:19 *)
Definition raftLog__acceptUnstable : val :=
  rec: "raftLog__acceptUnstable" "l" <> :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    do:  ((unstable__acceptInProgress (struct.field_ref raftLog "unstable" (![ptrT] "l"))) #())).

Definition noLimit : Z := math.MaxUint64.

(* allEntries returns all entries in the log.

   go: log.go:423:19 *)
Definition raftLog__allEntries : val :=
  rec: "raftLog__allEntries" "l" <> :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "err" := (ref_ty error (zero_val error)) in
    let: "ents" := (ref_ty (sliceT raftpb.Entry) (zero_val (sliceT raftpb.Entry))) in
    let: ("$ret0", "$ret1") := (let: "$a0" := ((raftLog__firstIndex (![ptrT] "l")) #()) in
    let: "$a1" := #(W64 noLimit) in
    (raftLog__entries (![ptrT] "l")) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("ents" <-[sliceT raftpb.Entry] "$r0");;;
    do:  ("err" <-[error] "$r1");;;
    (if: (![error] "err") = (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
    then return: (![sliceT raftpb.Entry] "ents")
    else do:  #());;;
    (if: (![error] "err") = (![error] "ErrCompacted")
    then return: (("raftLog__allEntries" (![ptrT] "l")) #())
    else do:  #());;;
    do:  (let: "$a0" := (interface.make error__mset (![error] "err")) in
    Panic "$a0")).

(* pbEntryID returns the ID of the given raftpb.Entry.

   go: types.go:34:6 *)
Definition pbEntryID : val :=
  rec: "pbEntryID" "entry" :=
    exception_do (let: "entry" := (ref_ty ptrT "entry") in
    return: (struct.make entryID [{
       "term" ::= ![uint64T] (struct.field_ref raftpb.Entry "Term" (![ptrT] "entry"));
       "index" ::= ![uint64T] (struct.field_ref raftpb.Entry "Index" (![ptrT] "entry"))
     }])).

(* findConflict finds the index of the conflict.
   It returns the first pair of conflicting entries between the existing
   entries and the given entries, if there are any.
   If there is no conflicting entries, and the existing entries contains
   all the given entries, zero will be returned.
   If there is no conflicting entries, but the given entries contains new
   entries, the index of the first new entry will be returned.
   An entry is considered to be conflicting if it has the same index but
   a different term.
   The index of the given entries MUST be continuously increasing.

   go: log.go:153:19 *)
Definition raftLog__findConflict : val :=
  rec: "raftLog__findConflict" "l" "ents" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "ents" := (ref_ty (sliceT raftpb.Entry) "ents") in
    do:  (let: "$range" := (![sliceT raftpb.Entry] "ents") in
    slice.for_range raftpb.Entry "$range" (λ: "i" <>,
      let: "i" := ref_ty uint64T "i" in
      (let: "id" := (ref_ty entryID (zero_val entryID)) in
      let: "$r0" := (let: "$a0" := (slice.elem_ref raftpb.Entry (![sliceT raftpb.Entry] "ents") (![intT] "i")) in
      pbEntryID "$a0") in
      do:  ("id" <-[entryID] "$r0");;;
      (if: (~ (let: "$a0" := (![entryID] "id") in
      (raftLog__matchTerm (![ptrT] "l")) "$a0"))
      then
        (if: (![uint64T] (struct.field_ref entryID "index" "id")) ≤ ((raftLog__lastIndex (![ptrT] "l")) #())
        then
          do:  (let: "$a0" := #(str "found conflict at index %d [existing term: %d, conflicting term: %d]") in
          let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref entryID "index" "id"))) in
          let: "$sl1" := (interface.make uint64__mset (let: ("$ret0", "$ret1") := ((let: "$a0" := (![uint64T] (struct.field_ref entryID "index" "id")) in
          (raftLog__term (![ptrT] "l")) "$a0")) in
          let: "$a0" := "$ret0" in
          let: "$a1" := "$ret1" in
          (raftLog__zeroTermOnOutOfBounds (![ptrT] "l")) "$a0" "$a1")) in
          let: "$sl2" := (interface.make uint64__mset (![uint64T] (struct.field_ref entryID "term" "id"))) in
          slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
          (interface.get "Infof" (![Logger] (struct.field_ref raftLog "logger" (![ptrT] "l")))) "$a0" "$a1")
        else do:  #());;;
        return: (![uint64T] (struct.field_ref entryID "index" "id"))
      else do:  #()))));;;
    return: (#(W64 0))).

(* hasNextCommittedEnts returns if there is any available entries for execution.
   This is a fast check without heavy raftLog.slice() in nextCommittedEnts().

   go: log.go:248:19 *)
Definition raftLog__hasNextCommittedEnts : val :=
  rec: "raftLog__hasNextCommittedEnts" "l" "allowUnstable" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "allowUnstable" := (ref_ty boolT "allowUnstable") in
    (if: ![boolT] (struct.field_ref raftLog "applyingEntsPaused" (![ptrT] "l"))
    then return: (#false)
    else do:  #());;;
    (if: (raftLog__hasNextOrInProgressSnapshot (![ptrT] "l")) #()
    then return: (#false)
    else do:  #());;;
    let: "hi" := (ref_ty uint64T (zero_val uint64T)) in
    let: "lo" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := ((![uint64T] (struct.field_ref raftLog "applying" (![ptrT] "l"))) + #(W64 1)) in
    let: "$r1" := ((let: "$a0" := (![boolT] "allowUnstable") in
    (raftLog__maxAppliableIndex (![ptrT] "l")) "$a0") + #(W64 1)) in
    do:  ("lo" <-[uint64T] "$r0");;;
    do:  ("hi" <-[uint64T] "$r1");;;
    return: ((![uint64T] "lo") < (![uint64T] "hi"))).

(* hasNextOrInProgressUnstableEnts returns if there are any entries that are
   available to be written to the local stable log or in the process of being
   written to the local stable log.

   go: log.go:210:19 *)
Definition raftLog__hasNextOrInProgressUnstableEnts : val :=
  rec: "raftLog__hasNextOrInProgressUnstableEnts" "l" <> :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    return: (int_gt (let: "$a0" := (![sliceT raftpb.Entry] (struct.field_ref unstable "entries" (struct.field_ref raftLog "unstable" (![ptrT] "l")))) in
     slice.len "$a0") #(W64 0))).

(* nextEntries returns the unstable entries that are not already in the process
   of being written to storage.

   go: log_unstable.go:96:20 *)
Definition unstable__nextEntries : val :=
  rec: "unstable__nextEntries" "u" <> :=
    exception_do (let: "u" := (ref_ty ptrT "u") in
    let: "inProgress" := (ref_ty intT (zero_val intT)) in
    let: "$r0" := ((![uint64T] (struct.field_ref unstable "offsetInProgress" (![ptrT] "u"))) - (![uint64T] (struct.field_ref unstable "offset" (![ptrT] "u")))) in
    do:  ("inProgress" <-[intT] "$r0");;;
    (if: (let: "$a0" := (![sliceT raftpb.Entry] (struct.field_ref unstable "entries" (![ptrT] "u"))) in
    slice.len "$a0") = (![intT] "inProgress")
    then return: (slice.nil)
    else do:  #());;;
    return: (let: "$s" := (![sliceT raftpb.Entry] (struct.field_ref unstable "entries" (![ptrT] "u"))) in
     slice.slice raftpb.Entry "$s" (![intT] "inProgress") (slice.len "$s"))).

(* nextUnstableEnts returns all entries that are available to be written to the
   local stable log and are not already in-progress.

   go: log.go:197:19 *)
Definition raftLog__nextUnstableEnts : val :=
  rec: "raftLog__nextUnstableEnts" "l" <> :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    return: ((unstable__nextEntries (struct.field_ref raftLog "unstable" (![ptrT] "l"))) #())).

(* hasNextUnstableEnts returns if there are any entries that are available to be
   written to the local stable log and are not already in-progress.

   go: log.go:203:19 *)
Definition raftLog__hasNextUnstableEnts : val :=
  rec: "raftLog__hasNextUnstableEnts" "l" <> :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    return: (int_gt (let: "$a0" := ((raftLog__nextUnstableEnts (![ptrT] "l")) #()) in
     slice.len "$a0") #(W64 0))).

(* nextSnapshot returns the unstable snapshot, if one exists that is not already
   in the process of being written to storage.

   go: log_unstable.go:106:20 *)
Definition unstable__nextSnapshot : val :=
  rec: "unstable__nextSnapshot" "u" <> :=
    exception_do (let: "u" := (ref_ty ptrT "u") in
    (if: ((![ptrT] (struct.field_ref unstable "snapshot" (![ptrT] "u"))) = #null) || (![boolT] (struct.field_ref unstable "snapshotInProgress" (![ptrT] "u")))
    then return: (#null)
    else do:  #());;;
    return: (![ptrT] (struct.field_ref unstable "snapshot" (![ptrT] "u")))).

(* hasNextUnstableSnapshot returns if there is a snapshot that is available to
   be applied to the local storage and is not already in-progress.

   go: log.go:283:19 *)
Definition raftLog__hasNextUnstableSnapshot : val :=
  rec: "raftLog__hasNextUnstableSnapshot" "l" <> :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    return: (((unstable__nextSnapshot (struct.field_ref raftLog "unstable" (![ptrT] "l"))) #()) ≠ #null)).

Definition logSlice : go_type := structT [
  "term" :: uint64T;
  "prev" :: entryID;
  "entries" :: sliceT raftpb.Entry
]%struct.

(* maybeAppend returns (0, false) if the entries cannot be appended. Otherwise,
   it returns (last index of new entries, true).

   go: log.go:107:19 *)
Definition raftLog__maybeAppend : val :=
  rec: "raftLog__maybeAppend" "l" "a" "committed" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "committed" := (ref_ty uint64T "committed") in
    let: "a" := (ref_ty logSlice "a") in
    let: "lastnewi" := (ref_ty uint64T (zero_val uint64T)) in
    (if: (~ (let: "$a0" := (![entryID] (struct.field_ref logSlice "prev" "a")) in
    (raftLog__matchTerm (![ptrT] "l")) "$a0"))
    then return: (#(W64 0), #false)
    else do:  #());;;
    let: "$r0" := ((![uint64T] (struct.field_ref entryID "index" (struct.field_ref logSlice "prev" "a"))) + (let: "$a0" := (![sliceT raftpb.Entry] (struct.field_ref logSlice "entries" "a")) in
    slice.len "$a0")) in
    do:  ("lastnewi" <-[uint64T] "$r0");;;
    let: "ci" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (let: "$a0" := (![sliceT raftpb.Entry] (struct.field_ref logSlice "entries" "a")) in
    (raftLog__findConflict (![ptrT] "l")) "$a0") in
    do:  ("ci" <-[uint64T] "$r0");;;
    let: "$sw" := #true in
    (if: "$sw" = ((![uint64T] "ci") = #(W64 0))
    then do:  #()
    else
      (if: "$sw" = ((![uint64T] "ci") ≤ (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] "l"))))
      then
        do:  (let: "$a0" := #(str "entry %d conflict with committed entry [committed(%d)]") in
        let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] "ci")) in
        let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] "l")))) in
        slice.literal interfaceT ["$sl0"; "$sl1"])) in
        (interface.get "Panicf" (![Logger] (struct.field_ref raftLog "logger" (![ptrT] "l")))) "$a0" "$a1")
      else
        let: "offset" := (ref_ty uint64T (zero_val uint64T)) in
        let: "$r0" := ((![uint64T] (struct.field_ref entryID "index" (struct.field_ref logSlice "prev" "a"))) + #(W64 1)) in
        do:  ("offset" <-[uint64T] "$r0");;;
        (if: ((![uint64T] "ci") - (![uint64T] "offset")) > (let: "$a0" := (![sliceT raftpb.Entry] (struct.field_ref logSlice "entries" "a")) in
        slice.len "$a0")
        then
          do:  (let: "$a0" := #(str "index, %d, is out of range [%d]") in
          let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset ((![uint64T] "ci") - (![uint64T] "offset"))) in
          let: "$sl1" := (interface.make int__mset (let: "$a0" := (![sliceT raftpb.Entry] (struct.field_ref logSlice "entries" "a")) in
          slice.len "$a0")) in
          slice.literal interfaceT ["$sl0"; "$sl1"])) in
          (interface.get "Panicf" (![Logger] (struct.field_ref raftLog "logger" (![ptrT] "l")))) "$a0" "$a1")
        else do:  #());;;
        do:  (let: "$a0" := (let: "$s" := (![sliceT raftpb.Entry] (struct.field_ref logSlice "entries" "a")) in
        slice.slice raftpb.Entry "$s" ((![uint64T] "ci") - (![uint64T] "offset")) (slice.len "$s")) in
        (raftLog__append (![ptrT] "l")) "$a0")));;;
    do:  (let: "$a0" := (let: "$a0" := (![uint64T] "committed") in
    let: "$a1" := (![uint64T] "lastnewi") in
    (minUint64 2) "$a0" "$a1") in
    (raftLog__commitTo (![ptrT] "l")) "$a0");;;
    return: (![uint64T] "lastnewi", #true)).

Definition entryEncodingSize__mset : list (string * val) := [
].

(* nextCommittedEnts returns all the available entries for execution.
   Entries can be committed even when the local raft instance has not durably
   appended them to the local raft log yet. If allowUnstable is true, committed
   entries from the unstable log may be returned; otherwise, only entries known
   to reside locally on stable storage will be returned.

   go: log.go:219:19 *)
Definition raftLog__nextCommittedEnts : val :=
  rec: "raftLog__nextCommittedEnts" "l" "allowUnstable" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "allowUnstable" := (ref_ty boolT "allowUnstable") in
    let: "ents" := (ref_ty (sliceT raftpb.Entry) (zero_val (sliceT raftpb.Entry))) in
    (if: ![boolT] (struct.field_ref raftLog "applyingEntsPaused" (![ptrT] "l"))
    then return: (slice.nil)
    else do:  #());;;
    (if: (raftLog__hasNextOrInProgressSnapshot (![ptrT] "l")) #()
    then return: (slice.nil)
    else do:  #());;;
    let: "hi" := (ref_ty uint64T (zero_val uint64T)) in
    let: "lo" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := ((![uint64T] (struct.field_ref raftLog "applying" (![ptrT] "l"))) + #(W64 1)) in
    let: "$r1" := ((let: "$a0" := (![boolT] "allowUnstable") in
    (raftLog__maxAppliableIndex (![ptrT] "l")) "$a0") + #(W64 1)) in
    do:  ("lo" <-[uint64T] "$r0");;;
    do:  ("hi" <-[uint64T] "$r1");;;
    (if: (![uint64T] "lo") ≥ (![uint64T] "hi")
    then return: (slice.nil)
    else do:  #());;;
    let: "maxSize" := (ref_ty entryEncodingSize (zero_val entryEncodingSize)) in
    let: "$r0" := ((![entryEncodingSize] (struct.field_ref raftLog "maxApplyingEntsSize" (![ptrT] "l"))) - (![entryEncodingSize] (struct.field_ref raftLog "applyingEntsSize" (![ptrT] "l")))) in
    do:  ("maxSize" <-[entryEncodingSize] "$r0");;;
    (if: (![entryEncodingSize] "maxSize") ≤ #(W64 0)
    then
      do:  (let: "$a0" := #(str "applying entry size (%d-%d)=%d not positive") in
      let: "$a1" := ((let: "$sl0" := (interface.make entryEncodingSize__mset (![entryEncodingSize] (struct.field_ref raftLog "maxApplyingEntsSize" (![ptrT] "l")))) in
      let: "$sl1" := (interface.make entryEncodingSize__mset (![entryEncodingSize] (struct.field_ref raftLog "applyingEntsSize" (![ptrT] "l")))) in
      let: "$sl2" := (interface.make entryEncodingSize__mset (![entryEncodingSize] "maxSize")) in
      slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
      (interface.get "Panicf" (![Logger] (struct.field_ref raftLog "logger" (![ptrT] "l")))) "$a0" "$a1")
    else do:  #());;;
    let: "err" := (ref_ty error (zero_val error)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![uint64T] "lo") in
    let: "$a1" := (![uint64T] "hi") in
    let: "$a2" := (![entryEncodingSize] "maxSize") in
    (raftLog__slice (![ptrT] "l")) "$a0" "$a1" "$a2") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("ents" <-[sliceT raftpb.Entry] "$r0");;;
    do:  ("err" <-[error] "$r1");;;
    (if: (![error] "err") ≠ (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
    then
      do:  (let: "$a0" := #(str "unexpected error when getting unapplied entries (%v)") in
      let: "$a1" := ((let: "$sl0" := (interface.make error__mset (![error] "err")) in
      slice.literal interfaceT ["$sl0"])) in
      (interface.get "Panicf" (![Logger] (struct.field_ref raftLog "logger" (![ptrT] "l")))) "$a0" "$a1")
    else do:  #());;;
    return: (![sliceT raftpb.Entry] "ents")).

(* nextUnstableSnapshot returns the snapshot, if present, that is available to
   be applied to the local storage and is not already in-progress.

   go: log.go:277:19 *)
Definition raftLog__nextUnstableSnapshot : val :=
  rec: "raftLog__nextUnstableSnapshot" "l" <> :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    return: ((unstable__nextSnapshot (struct.field_ref raftLog "unstable" (![ptrT] "l"))) #())).

(* go: log.go:466:19 *)
Definition raftLog__restore : val :=
  rec: "raftLog__restore" "l" "s" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "s" := (ref_ty raftpb.Snapshot "s") in
    do:  (let: "$a0" := #(str "log [%s] starts to restore snapshot [index: %d, term: %d]") in
    let: "$a1" := ((let: "$sl0" := (interface.make raftLog__mset_ptr (![ptrT] "l")) in
    let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.SnapshotMetadata "Index" (struct.field_ref raftpb.Snapshot "Metadata" "s")))) in
    let: "$sl2" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.SnapshotMetadata "Term" (struct.field_ref raftpb.Snapshot "Metadata" "s")))) in
    slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
    (interface.get "Infof" (![Logger] (struct.field_ref raftLog "logger" (![ptrT] "l")))) "$a0" "$a1");;;
    let: "$r0" := (![uint64T] (struct.field_ref raftpb.SnapshotMetadata "Index" (struct.field_ref raftpb.Snapshot "Metadata" "s"))) in
    do:  ((struct.field_ref raftLog "committed" (![ptrT] "l")) <-[uint64T] "$r0");;;
    do:  (let: "$a0" := (![raftpb.Snapshot] "s") in
    (unstable__restore (struct.field_ref raftLog "unstable" (![ptrT] "l"))) "$a0")).

(* scan visits all log entries in the [lo, hi) range, returning them via the
   given callback. The callback can be invoked multiple times, with consecutive
   sub-ranges of the requested range. Returns up to pageSize bytes worth of
   entries at a time. May return more if a single entry size exceeds the limit.

   The entries in [lo, hi) must exist, otherwise scan() eventually returns an
   error (possibly after passing some entries through the callback).

   If the callback returns an error, scan terminates and returns this error
   immediately. This can be used to stop the scan early ("break" the loop).

   go: log.go:482:19 *)
Definition raftLog__scan : val :=
  rec: "raftLog__scan" "l" "lo" "hi" "pageSize" "v" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "v" := (ref_ty funcT "v") in
    let: "pageSize" := (ref_ty entryEncodingSize "pageSize") in
    let: "hi" := (ref_ty uint64T "hi") in
    let: "lo" := (ref_ty uint64T "lo") in
    (for: (λ: <>, (![uint64T] "lo") < (![uint64T] "hi")); (λ: <>, Skip) := λ: <>,
      let: "err" := (ref_ty error (zero_val error)) in
      let: "ents" := (ref_ty (sliceT raftpb.Entry) (zero_val (sliceT raftpb.Entry))) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![uint64T] "lo") in
      let: "$a1" := (![uint64T] "hi") in
      let: "$a2" := (![entryEncodingSize] "pageSize") in
      (raftLog__slice (![ptrT] "l")) "$a0" "$a1" "$a2") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("ents" <-[sliceT raftpb.Entry] "$r0");;;
      do:  ("err" <-[error] "$r1");;;
      (if: (![error] "err") ≠ (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
      then return: (![error] "err")
      else
        (if: (let: "$a0" := (![sliceT raftpb.Entry] "ents") in
        slice.len "$a0") = #(W64 0)
        then
          return: (let: "$a0" := #(str "got 0 entries in [%d, %d)") in
           let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] "lo")) in
           let: "$sl1" := (interface.make uint64__mset (![uint64T] "hi")) in
           slice.literal interfaceT ["$sl0"; "$sl1"])) in
           fmt.Errorf "$a0" "$a1")
        else do:  #()));;;
      (let: "err" := (ref_ty error (zero_val error)) in
      let: "$r0" := (let: "$a0" := (![sliceT raftpb.Entry] "ents") in
      (![funcT] "v") "$a0") in
      do:  ("err" <-[error] "$r0");;;
      (if: (![error] "err") ≠ (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
      then return: (![error] "err")
      else do:  #()));;;
      do:  ("lo" <-[uint64T] ((![uint64T] "lo") + (let: "$a0" := (![sliceT raftpb.Entry] "ents") in
      slice.len "$a0"))));;;
    return: (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)).

Definition raftLog__mset_ptr : list (string * val) := [
  ("String", raftLog__String%V);
  ("acceptApplying", raftLog__acceptApplying%V);
  ("acceptUnstable", raftLog__acceptUnstable%V);
  ("allEntries", raftLog__allEntries%V);
  ("append", raftLog__append%V);
  ("appliedTo", raftLog__appliedTo%V);
  ("commitTo", raftLog__commitTo%V);
  ("entries", raftLog__entries%V);
  ("findConflict", raftLog__findConflict%V);
  ("findConflictByTerm", raftLog__findConflictByTerm%V);
  ("firstIndex", raftLog__firstIndex%V);
  ("hasNextCommittedEnts", raftLog__hasNextCommittedEnts%V);
  ("hasNextOrInProgressSnapshot", raftLog__hasNextOrInProgressSnapshot%V);
  ("hasNextOrInProgressUnstableEnts", raftLog__hasNextOrInProgressUnstableEnts%V);
  ("hasNextUnstableEnts", raftLog__hasNextUnstableEnts%V);
  ("hasNextUnstableSnapshot", raftLog__hasNextUnstableSnapshot%V);
  ("isUpToDate", raftLog__isUpToDate%V);
  ("lastEntryID", raftLog__lastEntryID%V);
  ("lastIndex", raftLog__lastIndex%V);
  ("matchTerm", raftLog__matchTerm%V);
  ("maxAppliableIndex", raftLog__maxAppliableIndex%V);
  ("maybeAppend", raftLog__maybeAppend%V);
  ("maybeCommit", raftLog__maybeCommit%V);
  ("mustCheckOutOfBounds", raftLog__mustCheckOutOfBounds%V);
  ("nextCommittedEnts", raftLog__nextCommittedEnts%V);
  ("nextUnstableEnts", raftLog__nextUnstableEnts%V);
  ("nextUnstableSnapshot", raftLog__nextUnstableSnapshot%V);
  ("restore", raftLog__restore%V);
  ("scan", raftLog__scan%V);
  ("slice", raftLog__slice%V);
  ("snapshot", raftLog__snapshot%V);
  ("stableSnapTo", raftLog__stableSnapTo%V);
  ("stableTo", raftLog__stableTo%V);
  ("term", raftLog__term%V);
  ("zeroTermOnOutOfBounds", raftLog__zeroTermOnOutOfBounds%V)
].

(* restore recovers the state machine from a snapshot. It restores the log and the
   configuration of state machine. If this method returns false, the snapshot was
   ignored, either because it was obsolete or because of an error.

   go: raft.go:1859:16 *)
Definition raft__restore : val :=
  rec: "raft__restore" "r" "s" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "s" := (ref_ty raftpb.Snapshot "s") in
    (if: (![uint64T] (struct.field_ref raftpb.SnapshotMetadata "Index" (struct.field_ref raftpb.Snapshot "Metadata" "s"))) ≤ (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))))
    then return: (#false)
    else do:  #());;;
    (if: (![StateType] (struct.field_ref raft "state" (![ptrT] "r"))) ≠ StateFollower
    then
      do:  (let: "$a0" := #(str "%x attempted to restore snapshot as leader; should never happen") in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
      slice.literal interfaceT ["$sl0"])) in
      (interface.get "Warningf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
      do:  (let: "$a0" := ((![uint64T] (struct.field_ref raft "Term" (![ptrT] "r"))) + #(W64 1)) in
      let: "$a1" := None in
      (raft__becomeFollower (![ptrT] "r")) "$a0" "$a1");;;
      return: (#false)
    else do:  #());;;
    let: "found" := (ref_ty boolT (zero_val boolT)) in
    let: "$r0" := #false in
    do:  ("found" <-[boolT] "$r0");;;
    let: "cs" := (ref_ty raftpb.ConfState (zero_val raftpb.ConfState)) in
    let: "$r0" := (![raftpb.ConfState] (struct.field_ref raftpb.SnapshotMetadata "ConfState" (struct.field_ref raftpb.Snapshot "Metadata" "s"))) in
    do:  ("cs" <-[raftpb.ConfState] "$r0");;;
    do:  (let: "$range" := ((let: "$sl0" := (![sliceT uint64T] (struct.field_ref raftpb.ConfState "Voters" "cs")) in
    let: "$sl1" := (![sliceT uint64T] (struct.field_ref raftpb.ConfState "Learners" "cs")) in
    let: "$sl2" := (![sliceT uint64T] (struct.field_ref raftpb.ConfState "VotersOutgoing" "cs")) in
    slice.literal (sliceT uint64T) ["$sl0"; "$sl1"; "$sl2"])) in
    slice.for_range (sliceT uint64T) "$range" (λ: <> "set",
      let: "set" := ref_ty (sliceT uint64T) "set" in
      do:  (let: "$range" := (![sliceT uint64T] "set") in
      slice.for_range uint64T "$range" (λ: <> "id",
        let: "id" := ref_ty uint64T "id" in
        (if: (![uint64T] "id") = (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))
        then
          let: "$r0" := #true in
          do:  ("found" <-[boolT] "$r0");;;
          break: #()
        else do:  #())));;;
      (if: ![boolT] "found"
      then break: #()
      else do:  #())));;;
    (if: (~ (![boolT] "found"))
    then
      do:  (let: "$a0" := #(str "%x attempted to restore snapshot but it is not in the ConfState %v; should never happen") in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
      let: "$sl1" := (interface.make raftpb.ConfState__mset (![raftpb.ConfState] "cs")) in
      slice.literal interfaceT ["$sl0"; "$sl1"])) in
      (interface.get "Warningf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
      return: (#false)
    else do:  #());;;
    let: "id" := (ref_ty entryID (zero_val entryID)) in
    let: "$r0" := (struct.make entryID [{
      "term" ::= ![uint64T] (struct.field_ref raftpb.SnapshotMetadata "Term" (struct.field_ref raftpb.Snapshot "Metadata" "s"));
      "index" ::= ![uint64T] (struct.field_ref raftpb.SnapshotMetadata "Index" (struct.field_ref raftpb.Snapshot "Metadata" "s"))
    }]) in
    do:  ("id" <-[entryID] "$r0");;;
    (if: let: "$a0" := (![entryID] "id") in
    (raftLog__matchTerm (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) "$a0"
    then
      let: "last" := (ref_ty entryID (zero_val entryID)) in
      let: "$r0" := ((raftLog__lastEntryID (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()) in
      do:  ("last" <-[entryID] "$r0");;;
      do:  (let: "$a0" := #(str "%x [commit: %d, lastindex: %d, lastterm: %d] fast-forwarded commit to snapshot [index: %d, term: %d]") in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
      let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))))) in
      let: "$sl2" := (interface.make uint64__mset (![uint64T] (struct.field_ref entryID "index" "last"))) in
      let: "$sl3" := (interface.make uint64__mset (![uint64T] (struct.field_ref entryID "term" "last"))) in
      let: "$sl4" := (interface.make uint64__mset (![uint64T] (struct.field_ref entryID "index" "id"))) in
      let: "$sl5" := (interface.make uint64__mset (![uint64T] (struct.field_ref entryID "term" "id"))) in
      slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"; "$sl4"; "$sl5"])) in
      (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
      do:  (let: "$a0" := (![uint64T] (struct.field_ref raftpb.SnapshotMetadata "Index" (struct.field_ref raftpb.Snapshot "Metadata" "s"))) in
      (raftLog__commitTo (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) "$a0");;;
      return: (#false)
    else do:  #());;;
    do:  (let: "$a0" := (![raftpb.Snapshot] "s") in
    (raftLog__restore (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) "$a0");;;
    let: "$r0" := (let: "$a0" := (![intT] (struct.field_ref tracker.ProgressTracker "MaxInflight" (struct.field_ref raft "trk" (![ptrT] "r")))) in
    let: "$a1" := (![uint64T] (struct.field_ref tracker.ProgressTracker "MaxInflightBytes" (struct.field_ref raft "trk" (![ptrT] "r")))) in
    tracker.MakeProgressTracker "$a0" "$a1") in
    do:  ((struct.field_ref raft "trk" (![ptrT] "r")) <-[tracker.ProgressTracker] "$r0");;;
    let: "err" := (ref_ty error (zero_val error)) in
    let: "trk" := (ref_ty tracker.ProgressMap (zero_val tracker.ProgressMap)) in
    let: "cfg" := (ref_ty tracker.Config (zero_val tracker.Config)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (struct.make confchange.Changer [{
      "Tracker" ::= ![tracker.ProgressTracker] (struct.field_ref raft "trk" (![ptrT] "r"));
      "LastIndex" ::= (raftLog__lastIndex (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()
    }]) in
    let: "$a1" := (![raftpb.ConfState] "cs") in
    confchange.Restore "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("cfg" <-[tracker.Config] "$r0");;;
    do:  ("trk" <-[tracker.ProgressMap] "$r1");;;
    do:  ("err" <-[error] "$r2");;;
    (if: (![error] "err") ≠ (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
    then
      do:  (let: "$a0" := (interface.make string__mset (let: "$a0" := #(str "unable to restore config %+v: %s") in
      let: "$a1" := ((let: "$sl0" := (interface.make raftpb.ConfState__mset (![raftpb.ConfState] "cs")) in
      let: "$sl1" := (interface.make error__mset (![error] "err")) in
      slice.literal interfaceT ["$sl0"; "$sl1"])) in
      fmt.Sprintf "$a0" "$a1")) in
      Panic "$a0")
    else do:  #());;;
    do:  (let: "$a0" := (![Logger] (struct.field_ref raft "logger" (![ptrT] "r"))) in
    let: "$a1" := (![raftpb.ConfState] "cs") in
    let: "$a2" := (let: "$a0" := (![tracker.Config] "cfg") in
    let: "$a1" := (![tracker.ProgressMap] "trk") in
    (raft__switchToConfig (![ptrT] "r")) "$a0" "$a1") in
    assertConfStatesEquivalent "$a0" "$a1" "$a2");;;
    let: "last" := (ref_ty entryID (zero_val entryID)) in
    let: "$r0" := ((raftLog__lastEntryID (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()) in
    do:  ("last" <-[entryID] "$r0");;;
    do:  (let: "$a0" := #(str "%x [commit: %d, lastindex: %d, lastterm: %d] restored snapshot [index: %d, term: %d]") in
    let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
    let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))))) in
    let: "$sl2" := (interface.make uint64__mset (![uint64T] (struct.field_ref entryID "index" "last"))) in
    let: "$sl3" := (interface.make uint64__mset (![uint64T] (struct.field_ref entryID "term" "last"))) in
    let: "$sl4" := (interface.make uint64__mset (![uint64T] (struct.field_ref entryID "index" "id"))) in
    let: "$sl5" := (interface.make uint64__mset (![uint64T] (struct.field_ref entryID "term" "id"))) in
    slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"; "$sl4"; "$sl5"])) in
    (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
    return: (#true)).

(* go: raft.go:1837:16 *)
Definition raft__handleSnapshot : val :=
  rec: "raft__handleSnapshot" "r" "m" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "m" := (ref_ty raftpb.Message "m") in
    let: "s" := (ref_ty raftpb.Snapshot (zero_val raftpb.Snapshot)) in
    (if: (![ptrT] (struct.field_ref raftpb.Message "Snapshot" "m")) ≠ #null
    then
      let: "$r0" := (![raftpb.Snapshot] (![ptrT] (struct.field_ref raftpb.Message "Snapshot" "m"))) in
      do:  ("s" <-[raftpb.Snapshot] "$r0")
    else do:  #());;;
    let: "sterm" := (ref_ty uint64T (zero_val uint64T)) in
    let: "sindex" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (![uint64T] (struct.field_ref raftpb.SnapshotMetadata "Index" (struct.field_ref raftpb.Snapshot "Metadata" "s"))) in
    let: "$r1" := (![uint64T] (struct.field_ref raftpb.SnapshotMetadata "Term" (struct.field_ref raftpb.Snapshot "Metadata" "s"))) in
    do:  ("sindex" <-[uint64T] "$r0");;;
    do:  ("sterm" <-[uint64T] "$r1");;;
    (if: let: "$a0" := (![raftpb.Snapshot] "s") in
    (raft__restore (![ptrT] "r")) "$a0"
    then
      do:  (let: "$a0" := #(str "%x [commit: %d] restored snapshot [index: %d, term: %d]") in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
      let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))))) in
      let: "$sl2" := (interface.make uint64__mset (![uint64T] "sindex")) in
      let: "$sl3" := (interface.make uint64__mset (![uint64T] "sterm")) in
      slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"])) in
      (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
      do:  (let: "$a0" := (struct.make raftpb.Message [{
        "To" ::= ![uint64T] (struct.field_ref raftpb.Message "From" "m");
        "Type" ::= raftpb.MsgAppResp;
        "Index" ::= (raftLog__lastIndex (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()
      }]) in
      (raft__send (![ptrT] "r")) "$a0")
    else
      do:  (let: "$a0" := #(str "%x [commit: %d] ignored snapshot [index: %d, term: %d]") in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
      let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))))) in
      let: "$sl2" := (interface.make uint64__mset (![uint64T] "sindex")) in
      let: "$sl3" := (interface.make uint64__mset (![uint64T] "sterm")) in
      slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"])) in
      (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
      do:  (let: "$a0" := (struct.make raftpb.Message [{
        "To" ::= ![uint64T] (struct.field_ref raftpb.Message "From" "m");
        "Type" ::= raftpb.MsgAppResp;
        "Index" ::= ![uint64T] (struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r"))))
      }]) in
      (raft__send (![ptrT] "r")) "$a0"))).

(* go: raft.go:1832:16 *)
Definition raft__handleHeartbeat : val :=
  rec: "raft__handleHeartbeat" "r" "m" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "m" := (ref_ty raftpb.Message "m") in
    do:  (let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "Commit" "m")) in
    (raftLog__commitTo (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) "$a0");;;
    do:  (let: "$a0" := (struct.make raftpb.Message [{
      "To" ::= ![uint64T] (struct.field_ref raftpb.Message "From" "m");
      "Type" ::= raftpb.MsgHeartbeatResp;
      "Context" ::= ![sliceT byteT] (struct.field_ref raftpb.Message "Context" "m")
    }]) in
    (raft__send (![ptrT] "r")) "$a0")).

(* logSliceFromMsgApp extracts the appended logSlice from a MsgApp message.

   go: raft.go:1779:6 *)
Definition logSliceFromMsgApp : val :=
  rec: "logSliceFromMsgApp" "m" :=
    exception_do (let: "m" := (ref_ty ptrT "m") in
    return: (struct.make logSlice [{
       "term" ::= ![uint64T] (struct.field_ref raftpb.Message "Term" (![ptrT] "m"));
       "prev" ::= struct.make entryID [{
         "term" ::= ![uint64T] (struct.field_ref raftpb.Message "LogTerm" (![ptrT] "m"));
         "index" ::= ![uint64T] (struct.field_ref raftpb.Message "Index" (![ptrT] "m"))
       }];
       "entries" ::= ![sliceT raftpb.Entry] (struct.field_ref raftpb.Message "Entries" (![ptrT] "m"))
     }])).

(* go: raft.go:1788:16 *)
Definition raft__handleAppendEntries : val :=
  rec: "raft__handleAppendEntries" "r" "m" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "m" := (ref_ty raftpb.Message "m") in
    let: "a" := (ref_ty logSlice (zero_val logSlice)) in
    let: "$r0" := (let: "$a0" := "m" in
    logSliceFromMsgApp "$a0") in
    do:  ("a" <-[logSlice] "$r0");;;
    (if: (![uint64T] (struct.field_ref entryID "index" (struct.field_ref logSlice "prev" "a"))) < (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))))
    then
      do:  (let: "$a0" := (struct.make raftpb.Message [{
        "To" ::= ![uint64T] (struct.field_ref raftpb.Message "From" "m");
        "Type" ::= raftpb.MsgAppResp;
        "Index" ::= ![uint64T] (struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r"))))
      }]) in
      (raft__send (![ptrT] "r")) "$a0");;;
      return: (#())
    else do:  #());;;
    (let: "ok" := (ref_ty boolT (zero_val boolT)) in
    let: "mlastIndex" := (ref_ty uint64T (zero_val uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![logSlice] "a") in
    let: "$a1" := (![uint64T] (struct.field_ref raftpb.Message "Commit" "m")) in
    (raftLog__maybeAppend (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("mlastIndex" <-[uint64T] "$r0");;;
    do:  ("ok" <-[boolT] "$r1");;;
    (if: ![boolT] "ok"
    then
      do:  (let: "$a0" := (struct.make raftpb.Message [{
        "To" ::= ![uint64T] (struct.field_ref raftpb.Message "From" "m");
        "Type" ::= raftpb.MsgAppResp;
        "Index" ::= ![uint64T] "mlastIndex"
      }]) in
      (raft__send (![ptrT] "r")) "$a0");;;
      return: (#())
    else do:  #()));;;
    do:  (let: "$a0" := #(str "%x [logterm: %d, index: %d] rejected MsgApp [logterm: %d, index: %d] from %x") in
    let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
    let: "$sl1" := (interface.make uint64__mset (let: ("$ret0", "$ret1") := ((let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "Index" "m")) in
    (raftLog__term (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) "$a0")) in
    let: "$a0" := "$ret0" in
    let: "$a1" := "$ret1" in
    (raftLog__zeroTermOnOutOfBounds (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) "$a0" "$a1")) in
    let: "$sl2" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "Index" "m"))) in
    let: "$sl3" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "LogTerm" "m"))) in
    let: "$sl4" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "Index" "m"))) in
    let: "$sl5" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "From" "m"))) in
    slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"; "$sl4"; "$sl5"])) in
    (interface.get "Debugf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
    let: "hintIndex" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "Index" "m")) in
    let: "$a1" := ((raftLog__lastIndex (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()) in
    (minUint64 2) "$a0" "$a1") in
    do:  ("hintIndex" <-[uint64T] "$r0");;;
    let: "hintTerm" := (ref_ty uint64T (zero_val uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![uint64T] "hintIndex") in
    let: "$a1" := (![uint64T] (struct.field_ref raftpb.Message "LogTerm" "m")) in
    (raftLog__findConflictByTerm (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("hintIndex" <-[uint64T] "$r0");;;
    do:  ("hintTerm" <-[uint64T] "$r1");;;
    do:  (let: "$a0" := (struct.make raftpb.Message [{
      "To" ::= ![uint64T] (struct.field_ref raftpb.Message "From" "m");
      "Type" ::= raftpb.MsgAppResp;
      "Index" ::= ![uint64T] (struct.field_ref raftpb.Message "Index" "m");
      "Reject" ::= #true;
      "RejectHint" ::= ![uint64T] "hintIndex";
      "LogTerm" ::= ![uint64T] "hintTerm"
    }]) in
    (raft__send (![ptrT] "r")) "$a0")).

(* stepCandidate is shared by StateCandidate and StatePreCandidate; the difference is
   whether they respond to MsgVoteResp or MsgPreVoteResp.

   go: raft.go:1670:6 *)
Definition stepCandidate : val :=
  rec: "stepCandidate" "r" "m" :=
    exception_do (let: "m" := (ref_ty raftpb.Message "m") in
    let: "r" := (ref_ty ptrT "r") in
    let: "myVoteRespType" := (ref_ty raftpb.MessageType (zero_val raftpb.MessageType)) in
    (if: (![StateType] (struct.field_ref raft "state" (![ptrT] "r"))) = StatePreCandidate
    then
      let: "$r0" := raftpb.MsgPreVoteResp in
      do:  ("myVoteRespType" <-[raftpb.MessageType] "$r0")
    else
      let: "$r0" := raftpb.MsgVoteResp in
      do:  ("myVoteRespType" <-[raftpb.MessageType] "$r0"));;;
    let: "$sw" := (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) in
    (if: "$sw" = raftpb.MsgProp
    then
      do:  (let: "$a0" := #(str "%x no leader at term %d; dropping proposal") in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
      let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
      slice.literal interfaceT ["$sl0"; "$sl1"])) in
      (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
      return: (![error] "ErrProposalDropped")
    else
      (if: "$sw" = raftpb.MsgApp
      then
        do:  (let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "Term" "m")) in
        let: "$a1" := (![uint64T] (struct.field_ref raftpb.Message "From" "m")) in
        (raft__becomeFollower (![ptrT] "r")) "$a0" "$a1");;;
        do:  (let: "$a0" := (![raftpb.Message] "m") in
        (raft__handleAppendEntries (![ptrT] "r")) "$a0")
      else
        (if: "$sw" = raftpb.MsgHeartbeat
        then
          do:  (let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "Term" "m")) in
          let: "$a1" := (![uint64T] (struct.field_ref raftpb.Message "From" "m")) in
          (raft__becomeFollower (![ptrT] "r")) "$a0" "$a1");;;
          do:  (let: "$a0" := (![raftpb.Message] "m") in
          (raft__handleHeartbeat (![ptrT] "r")) "$a0")
        else
          (if: "$sw" = raftpb.MsgSnap
          then
            do:  (let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "Term" "m")) in
            let: "$a1" := (![uint64T] (struct.field_ref raftpb.Message "From" "m")) in
            (raft__becomeFollower (![ptrT] "r")) "$a0" "$a1");;;
            do:  (let: "$a0" := (![raftpb.Message] "m") in
            (raft__handleSnapshot (![ptrT] "r")) "$a0")
          else
            (if: "$sw" = (![raftpb.MessageType] "myVoteRespType")
            then
              let: "res" := (ref_ty quorum.VoteResult (zero_val quorum.VoteResult)) in
              let: "rj" := (ref_ty intT (zero_val intT)) in
              let: "gr" := (ref_ty intT (zero_val intT)) in
              let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "From" "m")) in
              let: "$a1" := (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) in
              let: "$a2" := (~ (![boolT] (struct.field_ref raftpb.Message "Reject" "m"))) in
              (raft__poll (![ptrT] "r")) "$a0" "$a1" "$a2") in
              let: "$r0" := "$ret0" in
              let: "$r1" := "$ret1" in
              let: "$r2" := "$ret2" in
              do:  ("gr" <-[intT] "$r0");;;
              do:  ("rj" <-[intT] "$r1");;;
              do:  ("res" <-[quorum.VoteResult] "$r2");;;
              do:  (let: "$a0" := #(str "%x has received %d %s votes and %d vote rejections") in
              let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
              let: "$sl1" := (interface.make int__mset (![intT] "gr")) in
              let: "$sl2" := (interface.make raftpb.MessageType__mset (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m"))) in
              let: "$sl3" := (interface.make int__mset (![intT] "rj")) in
              slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"])) in
              (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
              let: "$sw" := (![quorum.VoteResult] "res") in
              (if: "$sw" = quorum.VoteWon
              then
                (if: (![StateType] (struct.field_ref raft "state" (![ptrT] "r"))) = StatePreCandidate
                then
                  do:  (let: "$a0" := campaignElection in
                  (raft__campaign (![ptrT] "r")) "$a0")
                else
                  do:  ((raft__becomeLeader (![ptrT] "r")) #());;;
                  do:  ((raft__bcastAppend (![ptrT] "r")) #()))
              else
                (if: "$sw" = quorum.VoteLost
                then
                  do:  (let: "$a0" := (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r"))) in
                  let: "$a1" := None in
                  (raft__becomeFollower (![ptrT] "r")) "$a0" "$a1")
                else #()))
            else
              (if: "$sw" = raftpb.MsgTimeoutNow
              then
                do:  (let: "$a0" := #(str "%x [term %d state %v] ignored MsgTimeoutNow from %x") in
                let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
                let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
                let: "$sl2" := (interface.make StateType__mset (![StateType] (struct.field_ref raft "state" (![ptrT] "r")))) in
                let: "$sl3" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "From" "m"))) in
                slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"])) in
                (interface.get "Debugf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1")
              else #()))))));;;
    return: (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)).

(* go: raft.go:903:16 *)
Definition raft__becomeCandidate : val :=
  rec: "raft__becomeCandidate" "r" <> :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    (if: (![StateType] (struct.field_ref raft "state" (![ptrT] "r"))) = StateLeader
    then
      do:  (let: "$a0" := (interface.make string__mset #(str "invalid transition [leader -> candidate]")) in
      Panic "$a0")
    else do:  #());;;
    let: "$r0" := stepCandidate in
    do:  ((struct.field_ref raft "step" (![ptrT] "r")) <-[stepFunc] "$r0");;;
    do:  (let: "$a0" := ((![uint64T] (struct.field_ref raft "Term" (![ptrT] "r"))) + #(W64 1)) in
    (raft__reset (![ptrT] "r")) "$a0");;;
    let: "$r0" := (raft__tickElection (![ptrT] "r")) in
    do:  ((struct.field_ref raft "tick" (![ptrT] "r")) <-[funcT] "$r0");;;
    let: "$r0" := (![uint64T] (struct.field_ref raft "id" (![ptrT] "r"))) in
    do:  ((struct.field_ref raft "Vote" (![ptrT] "r")) <-[uint64T] "$r0");;;
    let: "$r0" := StateCandidate in
    do:  ((struct.field_ref raft "state" (![ptrT] "r")) <-[StateType] "$r0");;;
    do:  (let: "$a0" := #(str "%x became candidate at term %d") in
    let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
    let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
    slice.literal interfaceT ["$sl0"; "$sl1"])) in
    (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
    do:  (let: "$a0" := (![ptrT] "r") in
    traceBecomeCandidate "$a0")).

Definition campaignPreElection : expr := #(str "CampaignPreElection").

(* go: raft.go:918:16 *)
Definition raft__becomePreCandidate : val :=
  rec: "raft__becomePreCandidate" "r" <> :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    (if: (![StateType] (struct.field_ref raft "state" (![ptrT] "r"))) = StateLeader
    then
      do:  (let: "$a0" := (interface.make string__mset #(str "invalid transition [leader -> pre-candidate]")) in
      Panic "$a0")
    else do:  #());;;
    let: "$r0" := stepCandidate in
    do:  ((struct.field_ref raft "step" (![ptrT] "r")) <-[stepFunc] "$r0");;;
    do:  ((tracker.ProgressTracker__ResetVotes (struct.field_ref raft "trk" (![ptrT] "r"))) #());;;
    let: "$r0" := (raft__tickElection (![ptrT] "r")) in
    do:  ((struct.field_ref raft "tick" (![ptrT] "r")) <-[funcT] "$r0");;;
    let: "$r0" := None in
    do:  ((struct.field_ref raft "lead" (![ptrT] "r")) <-[uint64T] "$r0");;;
    let: "$r0" := StatePreCandidate in
    do:  ((struct.field_ref raft "state" (![ptrT] "r")) <-[StateType] "$r0");;;
    do:  (let: "$a0" := #(str "%x became pre-candidate at term %d") in
    let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
    let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
    slice.literal interfaceT ["$sl0"; "$sl1"])) in
    (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1")).

(* go: raft.go:996:16 *)
Definition raft__hasUnappliedConfChanges : val :=
  rec: "raft__hasUnappliedConfChanges" "r" <> :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    (if: (![uint64T] (struct.field_ref raftLog "applied" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r"))))) ≥ (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))))
    then return: (#false)
    else do:  #());;;
    let: "found" := (ref_ty boolT (zero_val boolT)) in
    let: "$r0" := #false in
    do:  ("found" <-[boolT] "$r0");;;
    let: "hi" := (ref_ty uint64T (zero_val uint64T)) in
    let: "lo" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := ((![uint64T] (struct.field_ref raftLog "applied" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r"))))) + #(W64 1)) in
    let: "$r1" := ((![uint64T] (struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r"))))) + #(W64 1)) in
    do:  ("lo" <-[uint64T] "$r0");;;
    do:  ("hi" <-[uint64T] "$r1");;;
    let: "pageSize" := (ref_ty entryEncodingSize (zero_val entryEncodingSize)) in
    let: "$r0" := (![entryEncodingSize] (struct.field_ref raftLog "maxApplyingEntsSize" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r"))))) in
    do:  ("pageSize" <-[entryEncodingSize] "$r0");;;
    (let: "err" := (ref_ty error (zero_val error)) in
    let: "$r0" := (let: "$a0" := (![uint64T] "lo") in
    let: "$a1" := (![uint64T] "hi") in
    let: "$a2" := (![entryEncodingSize] "pageSize") in
    let: "$a3" := (λ: "ents",
      exception_do (let: "ents" := (ref_ty (sliceT raftpb.Entry) "ents") in
      do:  (let: "$range" := (![sliceT raftpb.Entry] "ents") in
      slice.for_range raftpb.Entry "$range" (λ: "i" <>,
        let: "i" := ref_ty uint64T "i" in
        (if: ((![raftpb.EntryType] (struct.field_ref raftpb.Entry "Type" (slice.elem_ref raftpb.Entry (![sliceT raftpb.Entry] "ents") (![intT] "i")))) = raftpb.EntryConfChange) || ((![raftpb.EntryType] (struct.field_ref raftpb.Entry "Type" (slice.elem_ref raftpb.Entry (![sliceT raftpb.Entry] "ents") (![intT] "i")))) = raftpb.EntryConfChangeV2)
        then
          let: "$r0" := #true in
          do:  ("found" <-[boolT] "$r0");;;
          return: (![error] "errBreak")
        else do:  #())));;;
      return: (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion))
      ) in
    (raftLog__scan (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) "$a0" "$a1" "$a2" "$a3") in
    do:  ("err" <-[error] "$r0");;;
    (if: ((![error] "err") ≠ (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)) && ((![error] "err") ≠ (![error] "errBreak"))
    then
      do:  (let: "$a0" := #(str "error scanning unapplied entries [%d, %d): %v") in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] "lo")) in
      let: "$sl1" := (interface.make uint64__mset (![uint64T] "hi")) in
      let: "$sl2" := (interface.make error__mset (![error] "err")) in
      slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
      (interface.get "Panicf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1")
    else do:  #()));;;
    return: (![boolT] "found")).

(* go: raft.go:974:16 *)
Definition raft__hup : val :=
  rec: "raft__hup" "r" "t" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "t" := (ref_ty CampaignType "t") in
    (if: (![StateType] (struct.field_ref raft "state" (![ptrT] "r"))) = StateLeader
    then
      do:  (let: "$a0" := #(str "%x ignoring MsgHup because already leader") in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
      slice.literal interfaceT ["$sl0"])) in
      (interface.get "Debugf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
      return: (#())
    else do:  #());;;
    (if: (~ ((raft__promotable (![ptrT] "r")) #()))
    then
      do:  (let: "$a0" := #(str "%x is unpromotable and can not campaign") in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
      slice.literal interfaceT ["$sl0"])) in
      (interface.get "Warningf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
      return: (#())
    else do:  #());;;
    (if: (raft__hasUnappliedConfChanges (![ptrT] "r")) #()
    then
      do:  (let: "$a0" := #(str "%x cannot campaign at term %d since there are still pending configuration changes to apply") in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
      let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
      slice.literal interfaceT ["$sl0"; "$sl1"])) in
      (interface.get "Warningf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
      return: (#())
    else do:  #());;;
    do:  (let: "$a0" := #(str "%x is starting a new election at term %d") in
    let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
    let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
    slice.literal interfaceT ["$sl0"; "$sl1"])) in
    (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
    do:  (let: "$a0" := (![CampaignType] "t") in
    (raft__campaign (![ptrT] "r")) "$a0")).

(* go: state_trace_nop.go:50:6 *)
Definition traceReceiveMessage : val :=
  rec: "traceReceiveMessage" "" "" :=
    exception_do (let: "" := (ref_ty ptrT "") in
    let: "" := (ref_ty ptrT "") in
    do:  #()).

(* go: raft.go:1715:6 *)
Definition stepFollower : val :=
  rec: "stepFollower" "r" "m" :=
    exception_do (let: "m" := (ref_ty raftpb.Message "m") in
    let: "r" := (ref_ty ptrT "r") in
    let: "$sw" := (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) in
    (if: "$sw" = raftpb.MsgProp
    then
      (if: (![uint64T] (struct.field_ref raft "lead" (![ptrT] "r"))) = None
      then
        do:  (let: "$a0" := #(str "%x no leader at term %d; dropping proposal") in
        let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
        let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
        slice.literal interfaceT ["$sl0"; "$sl1"])) in
        (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
        return: (![error] "ErrProposalDropped")
      else
        (if: ![boolT] (struct.field_ref raft "disableProposalForwarding" (![ptrT] "r"))
        then
          do:  (let: "$a0" := #(str "%x not forwarding to leader %x at term %d; dropping proposal") in
          let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
          let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "lead" (![ptrT] "r")))) in
          let: "$sl2" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
          slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
          (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
          return: (![error] "ErrProposalDropped")
        else do:  #()));;;
      let: "$r0" := (![uint64T] (struct.field_ref raft "lead" (![ptrT] "r"))) in
      do:  ((struct.field_ref raftpb.Message "To" "m") <-[uint64T] "$r0");;;
      do:  (let: "$a0" := (![raftpb.Message] "m") in
      (raft__send (![ptrT] "r")) "$a0")
    else
      (if: "$sw" = raftpb.MsgApp
      then
        let: "$r0" := #(W64 0) in
        do:  ((struct.field_ref raft "electionElapsed" (![ptrT] "r")) <-[intT] "$r0");;;
        let: "$r0" := (![uint64T] (struct.field_ref raftpb.Message "From" "m")) in
        do:  ((struct.field_ref raft "lead" (![ptrT] "r")) <-[uint64T] "$r0");;;
        do:  (let: "$a0" := (![raftpb.Message] "m") in
        (raft__handleAppendEntries (![ptrT] "r")) "$a0")
      else
        (if: "$sw" = raftpb.MsgHeartbeat
        then
          let: "$r0" := #(W64 0) in
          do:  ((struct.field_ref raft "electionElapsed" (![ptrT] "r")) <-[intT] "$r0");;;
          let: "$r0" := (![uint64T] (struct.field_ref raftpb.Message "From" "m")) in
          do:  ((struct.field_ref raft "lead" (![ptrT] "r")) <-[uint64T] "$r0");;;
          do:  (let: "$a0" := (![raftpb.Message] "m") in
          (raft__handleHeartbeat (![ptrT] "r")) "$a0")
        else
          (if: "$sw" = raftpb.MsgSnap
          then
            let: "$r0" := #(W64 0) in
            do:  ((struct.field_ref raft "electionElapsed" (![ptrT] "r")) <-[intT] "$r0");;;
            let: "$r0" := (![uint64T] (struct.field_ref raftpb.Message "From" "m")) in
            do:  ((struct.field_ref raft "lead" (![ptrT] "r")) <-[uint64T] "$r0");;;
            do:  (let: "$a0" := (![raftpb.Message] "m") in
            (raft__handleSnapshot (![ptrT] "r")) "$a0")
          else
            (if: "$sw" = raftpb.MsgTransferLeader
            then
              (if: (![uint64T] (struct.field_ref raft "lead" (![ptrT] "r"))) = None
              then
                do:  (let: "$a0" := #(str "%x no leader at term %d; dropping leader transfer msg") in
                let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
                let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
                slice.literal interfaceT ["$sl0"; "$sl1"])) in
                (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
                return: (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
              else do:  #());;;
              let: "$r0" := (![uint64T] (struct.field_ref raft "lead" (![ptrT] "r"))) in
              do:  ((struct.field_ref raftpb.Message "To" "m") <-[uint64T] "$r0");;;
              do:  (let: "$a0" := (![raftpb.Message] "m") in
              (raft__send (![ptrT] "r")) "$a0")
            else
              (if: "$sw" = raftpb.MsgForgetLeader
              then
                (if: (![ReadOnlyOption] (struct.field_ref readOnly "option" (![ptrT] (struct.field_ref raft "readOnly" (![ptrT] "r"))))) = ReadOnlyLeaseBased
                then
                  do:  (let: "$a0" := ((let: "$sl0" := (interface.make string__mset #(str "ignoring MsgForgetLeader due to ReadOnlyLeaseBased")) in
                  slice.literal interfaceT ["$sl0"])) in
                  (interface.get "Error" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0");;;
                  return: (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
                else do:  #());;;
                (if: (![uint64T] (struct.field_ref raft "lead" (![ptrT] "r"))) ≠ None
                then
                  do:  (let: "$a0" := #(str "%x forgetting leader %x at term %d") in
                  let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
                  let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "lead" (![ptrT] "r")))) in
                  let: "$sl2" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
                  slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
                  (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
                  let: "$r0" := None in
                  do:  ((struct.field_ref raft "lead" (![ptrT] "r")) <-[uint64T] "$r0")
                else do:  #())
              else
                (if: "$sw" = raftpb.MsgTimeoutNow
                then
                  do:  (let: "$a0" := #(str "%x [term %d] received MsgTimeoutNow from %x and starts an election to get leadership.") in
                  let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
                  let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
                  let: "$sl2" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "From" "m"))) in
                  slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
                  (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
                  do:  (let: "$a0" := campaignTransfer in
                  (raft__hup (![ptrT] "r")) "$a0")
                else
                  (if: "$sw" = raftpb.MsgReadIndex
                  then
                    (if: (![uint64T] (struct.field_ref raft "lead" (![ptrT] "r"))) = None
                    then
                      do:  (let: "$a0" := #(str "%x no leader at term %d; dropping index reading msg") in
                      let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
                      let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
                      slice.literal interfaceT ["$sl0"; "$sl1"])) in
                      (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
                      return: (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
                    else do:  #());;;
                    let: "$r0" := (![uint64T] (struct.field_ref raft "lead" (![ptrT] "r"))) in
                    do:  ((struct.field_ref raftpb.Message "To" "m") <-[uint64T] "$r0");;;
                    do:  (let: "$a0" := (![raftpb.Message] "m") in
                    (raft__send (![ptrT] "r")) "$a0")
                  else
                    (if: "$sw" = raftpb.MsgReadIndexResp
                    then
                      (if: (let: "$a0" := (![sliceT raftpb.Entry] (struct.field_ref raftpb.Message "Entries" "m")) in
                      slice.len "$a0") ≠ #(W64 1)
                      then
                        do:  (let: "$a0" := #(str "%x invalid format of MsgReadIndexResp from %x, entries count: %d") in
                        let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
                        let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "From" "m"))) in
                        let: "$sl2" := (interface.make int__mset (let: "$a0" := (![sliceT raftpb.Entry] (struct.field_ref raftpb.Message "Entries" "m")) in
                        slice.len "$a0")) in
                        slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
                        (interface.get "Errorf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
                        return: (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
                      else do:  #());;;
                      let: "$r0" := (let: "$a0" := (![sliceT ReadState] (struct.field_ref raft "readStates" (![ptrT] "r"))) in
                      let: "$a1" := ((let: "$sl0" := (struct.make ReadState [{
                        "Index" ::= ![uint64T] (struct.field_ref raftpb.Message "Index" "m");
                        "RequestCtx" ::= ![sliceT byteT] (struct.field_ref raftpb.Entry "Data" (slice.elem_ref raftpb.Entry (![sliceT raftpb.Entry] (struct.field_ref raftpb.Message "Entries" "m")) #(W64 0)))
                      }]) in
                      slice.literal ReadState ["$sl0"])) in
                      (slice.append (sliceT ReadState)) "$a0" "$a1") in
                      do:  ((struct.field_ref raft "readStates" (![ptrT] "r")) <-[sliceT ReadState] "$r0")
                    else #())))))))));;;
    return: (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)).

(* go: state_trace_nop.go:46:6 *)
Definition traceConfChangeEvent : val :=
  rec: "traceConfChangeEvent" "" "" :=
    exception_do (let: "" := (ref_ty ptrT "") in
    let: "" := (ref_ty tracker.Config "") in
    do:  #()).

(* go: raft.go:1949:16 *)
Definition raft__applyConfChange : val :=
  rec: "raft__applyConfChange" "r" "cc" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "cc" := (ref_ty raftpb.ConfChangeV2 "cc") in
    let: "err" := (ref_ty error (zero_val error)) in
    let: "trk" := (ref_ty tracker.ProgressMap (zero_val tracker.ProgressMap)) in
    let: "cfg" := (ref_ty tracker.Config (zero_val tracker.Config)) in
    let: (("$ret0", "$ret1"), "$ret2") := ((λ: <>,
      exception_do (let: "changer" := (ref_ty confchange.Changer (zero_val confchange.Changer)) in
      let: "$r0" := (struct.make confchange.Changer [{
        "Tracker" ::= ![tracker.ProgressTracker] (struct.field_ref raft "trk" (![ptrT] "r"));
        "LastIndex" ::= (raftLog__lastIndex (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()
      }]) in
      do:  ("changer" <-[confchange.Changer] "$r0");;;
      (if: (raftpb.ConfChangeV2__LeaveJoint (![raftpb.ConfChangeV2] "cc")) #()
      then
        let: (("$ret0", "$ret1"), "$ret2") := (((confchange.Changer__LeaveJoint (![confchange.Changer] "changer")) #())) in
        return: ("$ret0", "$ret1", "$ret2")
      else
        (let: "ok" := (ref_ty boolT (zero_val boolT)) in
        let: "autoLeave" := (ref_ty boolT (zero_val boolT)) in
        let: ("$ret0", "$ret1") := ((raftpb.ConfChangeV2__EnterJoint (![raftpb.ConfChangeV2] "cc")) #()) in
        let: "$r0" := "$ret0" in
        let: "$r1" := "$ret1" in
        do:  ("autoLeave" <-[boolT] "$r0");;;
        do:  ("ok" <-[boolT] "$r1");;;
        (if: ![boolT] "ok"
        then
          let: (("$ret0", "$ret1"), "$ret2") := ((let: "$a0" := (![boolT] "autoLeave") in
          let: "$a1" := (![sliceT raftpb.ConfChangeSingle] (struct.field_ref raftpb.ConfChangeV2 "Changes" "cc")) in
          (confchange.Changer__EnterJoint (![confchange.Changer] "changer")) "$a0" "$a1")) in
          return: ("$ret0", "$ret1", "$ret2")
        else do:  #())));;;
      let: (("$ret0", "$ret1"), "$ret2") := ((let: "$a0" := (![sliceT raftpb.ConfChangeSingle] (struct.field_ref raftpb.ConfChangeV2 "Changes" "cc")) in
      (confchange.Changer__Simple (![confchange.Changer] "changer")) "$a0")) in
      return: ("$ret0", "$ret1", "$ret2"))
      ) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("cfg" <-[tracker.Config] "$r0");;;
    do:  ("trk" <-[tracker.ProgressMap] "$r1");;;
    do:  ("err" <-[error] "$r2");;;
    (if: (![error] "err") ≠ (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
    then
      do:  (let: "$a0" := (interface.make error__mset (![error] "err")) in
      Panic "$a0")
    else do:  #());;;
    return: (let: "$a0" := (![tracker.Config] "cfg") in
     let: "$a1" := (![tracker.ProgressMap] "trk") in
     (raft__switchToConfig (![ptrT] "r")) "$a0" "$a1")).

(* Bootstrap initializes the RawNode for first use by appending configuration
   changes for the supplied peers. This method returns an error if the Storage
   is nonempty.

   It is recommended that instead of calling this method, applications bootstrap
   their state manually by setting up a Storage that has a first index > 1 and
   which stores the desired ConfState as its InitialState.

   go: bootstrap.go:30:20 *)
Definition RawNode__Bootstrap : val :=
  rec: "RawNode__Bootstrap" "rn" "peers" :=
    exception_do (let: "rn" := (ref_ty ptrT "rn") in
    let: "peers" := (ref_ty (sliceT Peer) "peers") in
    (if: (let: "$a0" := (![sliceT Peer] "peers") in
    slice.len "$a0") = #(W64 0)
    then
      return: (let: "$a0" := #(str "must provide at least one peer to Bootstrap") in
       errors.New "$a0")
    else do:  #());;;
    let: "err" := (ref_ty error (zero_val error)) in
    let: "lastIndex" := (ref_ty uint64T (zero_val uint64T)) in
    let: ("$ret0", "$ret1") := ((interface.get "LastIndex" (![Storage] (struct.field_ref raftLog "storage" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))))))) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("lastIndex" <-[uint64T] "$r0");;;
    do:  ("err" <-[error] "$r1");;;
    (if: (![error] "err") ≠ (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
    then return: (![error] "err")
    else do:  #());;;
    (if: (![uint64T] "lastIndex") ≠ #(W64 0)
    then
      return: (let: "$a0" := #(str "can't bootstrap a nonempty Storage") in
       errors.New "$a0")
    else do:  #());;;
    let: "$r0" := (![raftpb.HardState] "emptyState") in
    do:  ((struct.field_ref RawNode "prevHardSt" (![ptrT] "rn")) <-[raftpb.HardState] "$r0");;;
    do:  (let: "$a0" := #(W64 1) in
    let: "$a1" := None in
    (raft__becomeFollower (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))) "$a0" "$a1");;;
    let: "ents" := (ref_ty (sliceT raftpb.Entry) (zero_val (sliceT raftpb.Entry))) in
    let: "$r0" := (slice.make2 raftpb.Entry (let: "$a0" := (![sliceT Peer] "peers") in
    slice.len "$a0")) in
    do:  ("ents" <-[sliceT raftpb.Entry] "$r0");;;
    do:  (let: "$range" := (![sliceT Peer] "peers") in
    slice.for_range Peer "$range" (λ: "i" "peer",
      let: "i" := ref_ty uint64T "i" in
      let: "peer" := ref_ty Peer "peer" in
      let: "cc" := (ref_ty raftpb.ConfChange (zero_val raftpb.ConfChange)) in
      let: "$r0" := (struct.make raftpb.ConfChange [{
        "Type" ::= raftpb.ConfChangeAddNode;
        "NodeID" ::= ![uint64T] (struct.field_ref Peer "ID" "peer");
        "Context" ::= ![sliceT byteT] (struct.field_ref Peer "Context" "peer")
      }]) in
      do:  ("cc" <-[raftpb.ConfChange] "$r0");;;
      let: "err" := (ref_ty error (zero_val error)) in
      let: "data" := (ref_ty (sliceT byteT) (zero_val (sliceT byteT))) in
      let: ("$ret0", "$ret1") := ((raftpb.ConfChange__Marshal "cc") #()) in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("data" <-[sliceT byteT] "$r0");;;
      do:  ("err" <-[error] "$r1");;;
      (if: (![error] "err") ≠ (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
      then return: (![error] "err")
      else do:  #());;;
      let: "$r0" := (struct.make raftpb.Entry [{
        "Type" ::= raftpb.EntryConfChange;
        "Term" ::= #(W64 1);
        "Index" ::= (![intT] "i") + #(W64 1);
        "Data" ::= ![sliceT byteT] "data"
      }]) in
      do:  ((slice.elem_ref raftpb.Entry (![sliceT raftpb.Entry] "ents") (![intT] "i")) <-[raftpb.Entry] "$r0")));;;
    do:  (let: "$a0" := (![sliceT raftpb.Entry] "ents") in
    (raftLog__append (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))))) "$a0");;;
    let: "$r0" := (let: "$a0" := (![sliceT raftpb.Entry] "ents") in
    slice.len "$a0") in
    do:  ((struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))))) <-[uint64T] "$r0");;;
    do:  (let: "$range" := (![sliceT Peer] "peers") in
    slice.for_range Peer "$range" (λ: <> "peer",
      let: "peer" := ref_ty Peer "peer" in
      do:  (let: "$a0" := ((raftpb.ConfChange__AsV2 (struct.make raftpb.ConfChange [{
        "NodeID" ::= ![uint64T] (struct.field_ref Peer "ID" "peer");
        "Type" ::= raftpb.ConfChangeAddNode
      }])) #()) in
      (raft__applyConfChange (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))) "$a0")));;;
    return: (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)).

Definition raftLog__mset : list (string * val) := [
].

(* newLogWithSize returns a log using the given storage and max
   message size.

   go: log.go:73:6 *)
Definition newLogWithSize : val :=
  rec: "newLogWithSize" "storage" "logger" "maxApplyingEntsSize" :=
    exception_do (let: "maxApplyingEntsSize" := (ref_ty entryEncodingSize "maxApplyingEntsSize") in
    let: "logger" := (ref_ty Logger "logger") in
    let: "storage" := (ref_ty Storage "storage") in
    let: "err" := (ref_ty error (zero_val error)) in
    let: "firstIndex" := (ref_ty uint64T (zero_val uint64T)) in
    let: ("$ret0", "$ret1") := ((interface.get "FirstIndex" (![Storage] "storage")) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("firstIndex" <-[uint64T] "$r0");;;
    do:  ("err" <-[error] "$r1");;;
    (if: (![error] "err") ≠ (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
    then
      do:  (let: "$a0" := (interface.make error__mset (![error] "err")) in
      Panic "$a0")
    else do:  #());;;
    let: "lastIndex" := (ref_ty uint64T (zero_val uint64T)) in
    let: ("$ret0", "$ret1") := ((interface.get "LastIndex" (![Storage] "storage")) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("lastIndex" <-[uint64T] "$r0");;;
    do:  ("err" <-[error] "$r1");;;
    (if: (![error] "err") ≠ (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
    then
      do:  (let: "$a0" := (interface.make error__mset (![error] "err")) in
      Panic "$a0")
    else do:  #());;;
    return: (ref_ty raftLog (struct.make raftLog [{
       "storage" ::= ![Storage] "storage";
       "unstable" ::= struct.make unstable [{
         "offset" ::= (![uint64T] "lastIndex") + #(W64 1);
         "offsetInProgress" ::= (![uint64T] "lastIndex") + #(W64 1);
         "logger" ::= ![Logger] "logger"
       }];
       "maxApplyingEntsSize" ::= ![entryEncodingSize] "maxApplyingEntsSize";
       "committed" ::= (![uint64T] "firstIndex") - #(W64 1);
       "applying" ::= (![uint64T] "firstIndex") - #(W64 1);
       "applied" ::= (![uint64T] "firstIndex") - #(W64 1);
       "logger" ::= ![Logger] "logger"
     }]))).

(* newLog returns log using the given storage and default options. It
   recovers the log to the state that it just commits and applies the
   latest snapshot.

   go: log.go:67:6 *)
Definition newLog : val :=
  rec: "newLog" "storage" "logger" :=
    exception_do (let: "logger" := (ref_ty Logger "logger") in
    let: "storage" := (ref_ty Storage "storage") in
    return: (let: "$a0" := (![Storage] "storage") in
     let: "$a1" := (![Logger] "logger") in
     let: "$a2" := #(W64 noLimit) in
     newLogWithSize "$a0" "$a1" "$a2")).

Definition unstable__mset : list (string * val) := [
].

Definition unstable__mset_ptr : list (string * val) := [
  ("acceptInProgress", unstable__acceptInProgress%V);
  ("maybeFirstIndex", unstable__maybeFirstIndex%V);
  ("maybeLastIndex", unstable__maybeLastIndex%V);
  ("maybeTerm", unstable__maybeTerm%V);
  ("mustCheckOutOfBounds", unstable__mustCheckOutOfBounds%V);
  ("nextEntries", unstable__nextEntries%V);
  ("nextSnapshot", unstable__nextSnapshot%V);
  ("restore", unstable__restore%V);
  ("shrinkEntriesArray", unstable__shrinkEntriesArray%V);
  ("slice", unstable__slice%V);
  ("stableSnapTo", unstable__stableSnapTo%V);
  ("stableTo", unstable__stableTo%V);
  ("truncateAndAppend", unstable__truncateAndAppend%V)
].

(* go: logger.go:45:6 *)
Definition SetLogger : val :=
  rec: "SetLogger" "l" :=
    exception_do (let: "l" := (ref_ty Logger "l") in
    do:  ((sync.Mutex__Lock "raftLoggerMu") #());;;
    let: "$r0" := (![Logger] "l") in
    do:  ("raftLogger" <-[Logger] "$r0");;;
    do:  ((sync.Mutex__Unlock "raftLoggerMu") #())).

Definition DefaultLogger : go_type := structT [
  "Logger" :: ptrT;
  "debug" :: boolT
]%struct.

Definition calldepth : Z := 2.

(* go: logger.go:140:6 *)
Definition header : val :=
  rec: "header" "lvl" "msg" :=
    exception_do (let: "msg" := (ref_ty stringT "msg") in
    let: "lvl" := (ref_ty stringT "lvl") in
    return: (let: "$a0" := #(str "%s: %s") in
     let: "$a1" := ((let: "$sl0" := (interface.make string__mset (![stringT] "lvl")) in
     let: "$sl1" := (interface.make string__mset (![stringT] "msg")) in
     slice.literal interfaceT ["$sl0"; "$sl1"])) in
     fmt.Sprintf "$a0" "$a1")).

(* go: logger.go:86:25 *)
Definition DefaultLogger__Debug : val :=
  rec: "DefaultLogger__Debug" "l" "v" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "v" := (ref_ty (sliceT interfaceT) "v") in
    (if: ![boolT] (struct.field_ref DefaultLogger "debug" (![ptrT] "l"))
    then
      do:  (let: "$a0" := #(W64 calldepth) in
      let: "$a1" := (let: "$a0" := #(str "DEBUG") in
      let: "$a1" := (let: "$a0" := (![sliceT interfaceT] "v") in
      fmt.Sprint "$a0") in
      header "$a0" "$a1") in
      (log.Logger__Output (![ptrT] (struct.field_ref DefaultLogger "Logger" (![ptrT] "l")))) "$a0" "$a1")
    else do:  #())).

(* go: logger.go:92:25 *)
Definition DefaultLogger__Debugf : val :=
  rec: "DefaultLogger__Debugf" "l" "format" "v" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "v" := (ref_ty (sliceT interfaceT) "v") in
    let: "format" := (ref_ty stringT "format") in
    (if: ![boolT] (struct.field_ref DefaultLogger "debug" (![ptrT] "l"))
    then
      do:  (let: "$a0" := #(W64 calldepth) in
      let: "$a1" := (let: "$a0" := #(str "DEBUG") in
      let: "$a1" := (let: "$a0" := (![stringT] "format") in
      let: "$a1" := (![sliceT interfaceT] "v") in
      fmt.Sprintf "$a0" "$a1") in
      header "$a0" "$a1") in
      (log.Logger__Output (![ptrT] (struct.field_ref DefaultLogger "Logger" (![ptrT] "l")))) "$a0" "$a1")
    else do:  #())).

(* go: logger.go:82:25 *)
Definition DefaultLogger__EnableDebug : val :=
  rec: "DefaultLogger__EnableDebug" "l" <> :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "$r0" := #true in
    do:  ((struct.field_ref DefaultLogger "debug" (![ptrT] "l")) <-[boolT] "$r0")).

(* go: logger.go:78:25 *)
Definition DefaultLogger__EnableTimestamps : val :=
  rec: "DefaultLogger__EnableTimestamps" "l" <> :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    do:  (let: "$a0" := ((((log.Logger__Flags (![ptrT] (struct.field_ref DefaultLogger "Logger" (![ptrT] "l")))) #()) `or` log.Ldate) `or` log.Ltime) in
    (log.Logger__SetFlags (![ptrT] (struct.field_ref DefaultLogger "Logger" (![ptrT] "l")))) "$a0")).

(* go: logger.go:106:25 *)
Definition DefaultLogger__Error : val :=
  rec: "DefaultLogger__Error" "l" "v" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "v" := (ref_ty (sliceT interfaceT) "v") in
    do:  (let: "$a0" := #(W64 calldepth) in
    let: "$a1" := (let: "$a0" := #(str "ERROR") in
    let: "$a1" := (let: "$a0" := (![sliceT interfaceT] "v") in
    fmt.Sprint "$a0") in
    header "$a0" "$a1") in
    (log.Logger__Output (![ptrT] (struct.field_ref DefaultLogger "Logger" (![ptrT] "l")))) "$a0" "$a1")).

(* go: logger.go:110:25 *)
Definition DefaultLogger__Errorf : val :=
  rec: "DefaultLogger__Errorf" "l" "format" "v" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "v" := (ref_ty (sliceT interfaceT) "v") in
    let: "format" := (ref_ty stringT "format") in
    do:  (let: "$a0" := #(W64 calldepth) in
    let: "$a1" := (let: "$a0" := #(str "ERROR") in
    let: "$a1" := (let: "$a0" := (![stringT] "format") in
    let: "$a1" := (![sliceT interfaceT] "v") in
    fmt.Sprintf "$a0" "$a1") in
    header "$a0" "$a1") in
    (log.Logger__Output (![ptrT] (struct.field_ref DefaultLogger "Logger" (![ptrT] "l")))) "$a0" "$a1")).

(* go: logger.go:122:25 *)
Definition DefaultLogger__Fatal : val :=
  rec: "DefaultLogger__Fatal" "l" "v" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "v" := (ref_ty (sliceT interfaceT) "v") in
    do:  (let: "$a0" := #(W64 calldepth) in
    let: "$a1" := (let: "$a0" := #(str "FATAL") in
    let: "$a1" := (let: "$a0" := (![sliceT interfaceT] "v") in
    fmt.Sprint "$a0") in
    header "$a0" "$a1") in
    (log.Logger__Output (![ptrT] (struct.field_ref DefaultLogger "Logger" (![ptrT] "l")))) "$a0" "$a1");;;
    do:  (let: "$a0" := #(W64 1) in
    os.Exit "$a0")).

(* go: logger.go:127:25 *)
Definition DefaultLogger__Fatalf : val :=
  rec: "DefaultLogger__Fatalf" "l" "format" "v" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "v" := (ref_ty (sliceT interfaceT) "v") in
    let: "format" := (ref_ty stringT "format") in
    do:  (let: "$a0" := #(W64 calldepth) in
    let: "$a1" := (let: "$a0" := #(str "FATAL") in
    let: "$a1" := (let: "$a0" := (![stringT] "format") in
    let: "$a1" := (![sliceT interfaceT] "v") in
    fmt.Sprintf "$a0" "$a1") in
    header "$a0" "$a1") in
    (log.Logger__Output (![ptrT] (struct.field_ref DefaultLogger "Logger" (![ptrT] "l")))) "$a0" "$a1");;;
    do:  (let: "$a0" := #(W64 1) in
    os.Exit "$a0")).

(* go: logger.go:98:25 *)
Definition DefaultLogger__Info : val :=
  rec: "DefaultLogger__Info" "l" "v" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "v" := (ref_ty (sliceT interfaceT) "v") in
    do:  (let: "$a0" := #(W64 calldepth) in
    let: "$a1" := (let: "$a0" := #(str "INFO") in
    let: "$a1" := (let: "$a0" := (![sliceT interfaceT] "v") in
    fmt.Sprint "$a0") in
    header "$a0" "$a1") in
    (log.Logger__Output (![ptrT] (struct.field_ref DefaultLogger "Logger" (![ptrT] "l")))) "$a0" "$a1")).

(* go: logger.go:102:25 *)
Definition DefaultLogger__Infof : val :=
  rec: "DefaultLogger__Infof" "l" "format" "v" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "v" := (ref_ty (sliceT interfaceT) "v") in
    let: "format" := (ref_ty stringT "format") in
    do:  (let: "$a0" := #(W64 calldepth) in
    let: "$a1" := (let: "$a0" := #(str "INFO") in
    let: "$a1" := (let: "$a0" := (![stringT] "format") in
    let: "$a1" := (![sliceT interfaceT] "v") in
    fmt.Sprintf "$a0" "$a1") in
    header "$a0" "$a1") in
    (log.Logger__Output (![ptrT] (struct.field_ref DefaultLogger "Logger" (![ptrT] "l")))) "$a0" "$a1")).

(* go: logger.go:132:25 *)
Definition DefaultLogger__Panic : val :=
  rec: "DefaultLogger__Panic" "l" "v" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "v" := (ref_ty (sliceT interfaceT) "v") in
    do:  (let: "$a0" := (![sliceT interfaceT] "v") in
    (log.Logger__Panic (![ptrT] (struct.field_ref DefaultLogger "Logger" (![ptrT] "l")))) "$a0")).

(* go: logger.go:136:25 *)
Definition DefaultLogger__Panicf : val :=
  rec: "DefaultLogger__Panicf" "l" "format" "v" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "v" := (ref_ty (sliceT interfaceT) "v") in
    let: "format" := (ref_ty stringT "format") in
    do:  (let: "$a0" := (![stringT] "format") in
    let: "$a1" := (![sliceT interfaceT] "v") in
    (log.Logger__Panicf (![ptrT] (struct.field_ref DefaultLogger "Logger" (![ptrT] "l")))) "$a0" "$a1")).

(* go: logger.go:114:25 *)
Definition DefaultLogger__Warning : val :=
  rec: "DefaultLogger__Warning" "l" "v" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "v" := (ref_ty (sliceT interfaceT) "v") in
    do:  (let: "$a0" := #(W64 calldepth) in
    let: "$a1" := (let: "$a0" := #(str "WARN") in
    let: "$a1" := (let: "$a0" := (![sliceT interfaceT] "v") in
    fmt.Sprint "$a0") in
    header "$a0" "$a1") in
    (log.Logger__Output (![ptrT] (struct.field_ref DefaultLogger "Logger" (![ptrT] "l")))) "$a0" "$a1")).

(* go: logger.go:118:25 *)
Definition DefaultLogger__Warningf : val :=
  rec: "DefaultLogger__Warningf" "l" "format" "v" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "v" := (ref_ty (sliceT interfaceT) "v") in
    let: "format" := (ref_ty stringT "format") in
    do:  (let: "$a0" := #(W64 calldepth) in
    let: "$a1" := (let: "$a0" := #(str "WARN") in
    let: "$a1" := (let: "$a0" := (![stringT] "format") in
    let: "$a1" := (![sliceT interfaceT] "v") in
    fmt.Sprintf "$a0" "$a1") in
    header "$a0" "$a1") in
    (log.Logger__Output (![ptrT] (struct.field_ref DefaultLogger "Logger" (![ptrT] "l")))) "$a0" "$a1")).

Definition DefaultLogger__mset_ptr : list (string * val) := [
  ("Debug", DefaultLogger__Debug%V);
  ("Debugf", DefaultLogger__Debugf%V);
  ("EnableDebug", DefaultLogger__EnableDebug%V);
  ("EnableTimestamps", DefaultLogger__EnableTimestamps%V);
  ("Error", DefaultLogger__Error%V);
  ("Errorf", DefaultLogger__Errorf%V);
  ("Fatal", DefaultLogger__Fatal%V);
  ("Fatalf", DefaultLogger__Fatalf%V);
  ("Fatalln", (λ: "$recvAddr",
    log.Logger__Fatalln (![ptrT] (struct.field_ref DefaultLogger "Logger" "$recvAddr"))
    )%V);
  ("Flags", (λ: "$recvAddr",
    log.Logger__Flags (![ptrT] (struct.field_ref DefaultLogger "Logger" "$recvAddr"))
    )%V);
  ("Info", DefaultLogger__Info%V);
  ("Infof", DefaultLogger__Infof%V);
  ("Output", (λ: "$recvAddr",
    log.Logger__Output (![ptrT] (struct.field_ref DefaultLogger "Logger" "$recvAddr"))
    )%V);
  ("Panic", DefaultLogger__Panic%V);
  ("Panicf", DefaultLogger__Panicf%V);
  ("Panicln", (λ: "$recvAddr",
    log.Logger__Panicln (![ptrT] (struct.field_ref DefaultLogger "Logger" "$recvAddr"))
    )%V);
  ("Prefix", (λ: "$recvAddr",
    log.Logger__Prefix (![ptrT] (struct.field_ref DefaultLogger "Logger" "$recvAddr"))
    )%V);
  ("Print", (λ: "$recvAddr",
    log.Logger__Print (![ptrT] (struct.field_ref DefaultLogger "Logger" "$recvAddr"))
    )%V);
  ("Printf", (λ: "$recvAddr",
    log.Logger__Printf (![ptrT] (struct.field_ref DefaultLogger "Logger" "$recvAddr"))
    )%V);
  ("Println", (λ: "$recvAddr",
    log.Logger__Println (![ptrT] (struct.field_ref DefaultLogger "Logger" "$recvAddr"))
    )%V);
  ("SetFlags", (λ: "$recvAddr",
    log.Logger__SetFlags (![ptrT] (struct.field_ref DefaultLogger "Logger" "$recvAddr"))
    )%V);
  ("SetOutput", (λ: "$recvAddr",
    log.Logger__SetOutput (![ptrT] (struct.field_ref DefaultLogger "Logger" "$recvAddr"))
    )%V);
  ("SetPrefix", (λ: "$recvAddr",
    log.Logger__SetPrefix (![ptrT] (struct.field_ref DefaultLogger "Logger" "$recvAddr"))
    )%V);
  ("Warning", DefaultLogger__Warning%V);
  ("Warningf", DefaultLogger__Warningf%V);
  ("Writer", (λ: "$recvAddr",
    log.Logger__Writer (![ptrT] (struct.field_ref DefaultLogger "Logger" "$recvAddr"))
    )%V);
  ("output", (λ: "$recvAddr",
    log.Logger__output (![ptrT] (struct.field_ref DefaultLogger "Logger" "$recvAddr"))
    )%V)
].

(* go: logger.go:51:6 *)
Definition ResetDefaultLogger : val :=
  rec: "ResetDefaultLogger" <> :=
    exception_do (do:  (let: "$a0" := (interface.make DefaultLogger__mset_ptr (![ptrT] "defaultLogger")) in
    SetLogger "$a0")).

(* go: logger.go:55:6 *)
Definition getLogger : val :=
  rec: "getLogger" <> :=
    with_defer: (do:  ((sync.Mutex__Lock "raftLoggerMu") #());;;
    do:  (let: "$f" := (sync.Mutex__Unlock "raftLoggerMu") in
    "$defer" <-[funcT] (let: "$oldf" := (![funcT] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    return: (![Logger] "raftLogger")).

Definition DefaultLogger__mset : list (string * val) := [
  ("Fatalln", (λ: "$recv",
    log.Logger__Fatalln (struct.field_get DefaultLogger "Logger" "$recv")
    )%V);
  ("Flags", (λ: "$recv",
    log.Logger__Flags (struct.field_get DefaultLogger "Logger" "$recv")
    )%V);
  ("Output", (λ: "$recv",
    log.Logger__Output (struct.field_get DefaultLogger "Logger" "$recv")
    )%V);
  ("Panicln", (λ: "$recv",
    log.Logger__Panicln (struct.field_get DefaultLogger "Logger" "$recv")
    )%V);
  ("Prefix", (λ: "$recv",
    log.Logger__Prefix (struct.field_get DefaultLogger "Logger" "$recv")
    )%V);
  ("Print", (λ: "$recv",
    log.Logger__Print (struct.field_get DefaultLogger "Logger" "$recv")
    )%V);
  ("Printf", (λ: "$recv",
    log.Logger__Printf (struct.field_get DefaultLogger "Logger" "$recv")
    )%V);
  ("Println", (λ: "$recv",
    log.Logger__Println (struct.field_get DefaultLogger "Logger" "$recv")
    )%V);
  ("SetFlags", (λ: "$recv",
    log.Logger__SetFlags (struct.field_get DefaultLogger "Logger" "$recv")
    )%V);
  ("SetOutput", (λ: "$recv",
    log.Logger__SetOutput (struct.field_get DefaultLogger "Logger" "$recv")
    )%V);
  ("SetPrefix", (λ: "$recv",
    log.Logger__SetPrefix (struct.field_get DefaultLogger "Logger" "$recv")
    )%V);
  ("Writer", (λ: "$recv",
    log.Logger__Writer (struct.field_get DefaultLogger "Logger" "$recv")
    )%V);
  ("output", (λ: "$recv",
    log.Logger__output (struct.field_get DefaultLogger "Logger" "$recv")
    )%V)
].

Definition SnapshotStatus : go_type := intT.

Definition SnapshotStatus__mset : list (string * val) := [
].

Definition SnapshotStatus__mset_ptr : list (string * val) := [
].

Definition SnapshotFinish : expr := #(W64 1).

Definition SnapshotFailure : expr := #(W64 2).

Definition SoftState : go_type := structT [
  "Lead" :: uint64T;
  "RaftState" :: StateType
]%struct.

Definition SoftState__mset : list (string * val) := [
].

(* go: node.go:45:21 *)
Definition SoftState__equal : val :=
  rec: "SoftState__equal" "a" "b" :=
    exception_do (let: "a" := (ref_ty ptrT "a") in
    let: "b" := (ref_ty ptrT "b") in
    return: (((![uint64T] (struct.field_ref SoftState "Lead" (![ptrT] "a"))) = (![uint64T] (struct.field_ref SoftState "Lead" (![ptrT] "b")))) && ((![StateType] (struct.field_ref SoftState "RaftState" (![ptrT] "a"))) = (![StateType] (struct.field_ref SoftState "RaftState" (![ptrT] "b")))))).

Definition SoftState__mset_ptr : list (string * val) := [
  ("equal", SoftState__equal%V)
].

Definition Ready : go_type := structT [
  "SoftState" :: ptrT;
  "HardState" :: raftpb.HardState;
  "ReadStates" :: sliceT ReadState;
  "Entries" :: sliceT raftpb.Entry;
  "Snapshot" :: raftpb.Snapshot;
  "CommittedEntries" :: sliceT raftpb.Entry;
  "Messages" :: sliceT raftpb.Message;
  "MustSync" :: boolT
]%struct.

Definition Ready__mset : list (string * val) := [
  ("equal", (λ: "$recv",
    SoftState__equal (struct.field_get Ready "SoftState" "$recv")
    )%V)
].

Definition Ready__mset_ptr : list (string * val) := [
  ("Descriptor", (λ: "$recvAddr",
    raftpb.HardState__Descriptor (struct.field_ref Ready "HardState" "$recvAddr")
    )%V);
  ("Marshal", (λ: "$recvAddr",
    raftpb.HardState__Marshal (struct.field_ref Ready "HardState" "$recvAddr")
    )%V);
  ("MarshalTo", (λ: "$recvAddr",
    raftpb.HardState__MarshalTo (struct.field_ref Ready "HardState" "$recvAddr")
    )%V);
  ("MarshalToSizedBuffer", (λ: "$recvAddr",
    raftpb.HardState__MarshalToSizedBuffer (struct.field_ref Ready "HardState" "$recvAddr")
    )%V);
  ("ProtoMessage", (λ: "$recvAddr",
    raftpb.HardState__ProtoMessage (struct.field_ref Ready "HardState" "$recvAddr")
    )%V);
  ("Reset", (λ: "$recvAddr",
    raftpb.HardState__Reset (struct.field_ref Ready "HardState" "$recvAddr")
    )%V);
  ("Size", (λ: "$recvAddr",
    raftpb.HardState__Size (struct.field_ref Ready "HardState" "$recvAddr")
    )%V);
  ("String", (λ: "$recvAddr",
    raftpb.HardState__String (struct.field_ref Ready "HardState" "$recvAddr")
    )%V);
  ("Unmarshal", (λ: "$recvAddr",
    raftpb.HardState__Unmarshal (struct.field_ref Ready "HardState" "$recvAddr")
    )%V);
  ("XXX_DiscardUnknown", (λ: "$recvAddr",
    raftpb.HardState__XXX_DiscardUnknown (struct.field_ref Ready "HardState" "$recvAddr")
    )%V);
  ("XXX_Marshal", (λ: "$recvAddr",
    raftpb.HardState__XXX_Marshal (struct.field_ref Ready "HardState" "$recvAddr")
    )%V);
  ("XXX_Merge", (λ: "$recvAddr",
    raftpb.HardState__XXX_Merge (struct.field_ref Ready "HardState" "$recvAddr")
    )%V);
  ("XXX_Size", (λ: "$recvAddr",
    raftpb.HardState__XXX_Size (struct.field_ref Ready "HardState" "$recvAddr")
    )%V);
  ("XXX_Unmarshal", (λ: "$recvAddr",
    raftpb.HardState__XXX_Unmarshal (struct.field_ref Ready "HardState" "$recvAddr")
    )%V);
  ("equal", (λ: "$recvAddr",
    SoftState__equal (![ptrT] (struct.field_ref Ready "SoftState" "$recvAddr"))
    )%V)
].

(* go: node.go:117:6 *)
Definition isHardStateEqual : val :=
  rec: "isHardStateEqual" "a" "b" :=
    exception_do (let: "b" := (ref_ty raftpb.HardState "b") in
    let: "a" := (ref_ty raftpb.HardState "a") in
    return: ((((![uint64T] (struct.field_ref raftpb.HardState "Term" "a")) = (![uint64T] (struct.field_ref raftpb.HardState "Term" "b"))) && ((![uint64T] (struct.field_ref raftpb.HardState "Vote" "a")) = (![uint64T] (struct.field_ref raftpb.HardState "Vote" "b")))) && ((![uint64T] (struct.field_ref raftpb.HardState "Commit" "a")) = (![uint64T] (struct.field_ref raftpb.HardState "Commit" "b"))))).

(* IsEmptyHardState returns true if the given HardState is empty.

   go: node.go:122:6 *)
Definition IsEmptyHardState : val :=
  rec: "IsEmptyHardState" "st" :=
    exception_do (let: "st" := (ref_ty raftpb.HardState "st") in
    return: (let: "$a0" := (![raftpb.HardState] "st") in
     let: "$a1" := (![raftpb.HardState] "emptyState") in
     isHardStateEqual "$a0" "$a1")).

Definition Node : go_type := interfaceT.

Definition Peer__mset : list (string * val) := [
].

Definition Peer__mset_ptr : list (string * val) := [
].

Definition msgWithResult : go_type := structT [
  "m" :: raftpb.Message;
  "result" :: chanT error
]%struct.

Definition BasicStatus : go_type := structT [
  "ID" :: uint64T;
  "HardState" :: raftpb.HardState;
  "SoftState" :: SoftState;
  "Applied" :: uint64T;
  "LeadTransferee" :: uint64T
]%struct.

Definition Status : go_type := structT [
  "BasicStatus" :: BasicStatus;
  "Config" :: tracker.Config;
  "Progress" :: mapT uint64T tracker.Progress
]%struct.

Definition node : go_type := structT [
  "propc" :: chanT msgWithResult;
  "recvc" :: chanT raftpb.Message;
  "confc" :: chanT raftpb.ConfChangeV2;
  "confstatec" :: chanT raftpb.ConfState;
  "readyc" :: chanT Ready;
  "advancec" :: chanT structT [
  ]%struct;
  "tickc" :: chanT structT [
  ]%struct;
  "done" :: chanT structT [
  ]%struct;
  "stop" :: chanT structT [
  ]%struct;
  "status" :: chanT (chanT Status);
  "rn" :: ptrT
]%struct.

(* go: node.go:312:6 *)
Definition newNode : val :=
  rec: "newNode" "rn" :=
    exception_do (let: "rn" := (ref_ty ptrT "rn") in
    return: (struct.make node [{
       "propc" ::= chan.make msgWithResult #();
       "recvc" ::= chan.make raftpb.Message #();
       "confc" ::= chan.make raftpb.ConfChangeV2 #();
       "confstatec" ::= chan.make raftpb.ConfState #();
       "readyc" ::= chan.make Ready #();
       "advancec" ::= chan.make structT [
       ]%struct #();
       "tickc" ::= chan.make structT [
       ]%struct #();
       "done" ::= chan.make structT [
       ]%struct #();
       "stop" ::= chan.make structT [
       ]%struct #();
       "status" ::= chan.make (chanT Status) #();
       "rn" ::= ![ptrT] "rn"
     }])).

Definition Config : go_type := structT [
  "ID" :: uint64T;
  "ElectionTick" :: intT;
  "HeartbeatTick" :: intT;
  "Storage" :: Storage;
  "Applied" :: uint64T;
  "AsyncStorageWrites" :: boolT;
  "MaxSizePerMsg" :: uint64T;
  "MaxCommittedSizePerReady" :: uint64T;
  "MaxUncommittedEntriesSize" :: uint64T;
  "MaxInflightMsgs" :: intT;
  "MaxInflightBytes" :: uint64T;
  "CheckQuorum" :: boolT;
  "PreVote" :: boolT;
  "ReadOnlyOption" :: ReadOnlyOption;
  "Logger" :: Logger;
  "DisableProposalForwarding" :: boolT;
  "DisableConfChangeValidation" :: boolT;
  "StepDownOnRemoval" :: boolT;
  "TraceLogger" :: TraceLogger
]%struct.

(* go: raft.go:502:16 *)
Definition raft__hardState : val :=
  rec: "raft__hardState" "r" <> :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    return: (struct.make raftpb.HardState [{
       "Term" ::= ![uint64T] (struct.field_ref raft "Term" (![ptrT] "r"));
       "Vote" ::= ![uint64T] (struct.field_ref raft "Vote" (![ptrT] "r"));
       "Commit" ::= ![uint64T] (struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r"))))
     }])).

(* go: raft.go:500:16 *)
Definition raft__softState : val :=
  rec: "raft__softState" "r" <> :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    return: (struct.make SoftState [{
       "Lead" ::= ![uint64T] (struct.field_ref raft "lead" (![ptrT] "r"));
       "RaftState" ::= ![StateType] (struct.field_ref raft "state" (![ptrT] "r"))
     }])).

(* go: raft.go:2035:16 *)
Definition raft__loadState : val :=
  rec: "raft__loadState" "r" "state" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "state" := (ref_ty raftpb.HardState "state") in
    (if: ((![uint64T] (struct.field_ref raftpb.HardState "Commit" "state")) < (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))))) || ((![uint64T] (struct.field_ref raftpb.HardState "Commit" "state")) > ((raftLog__lastIndex (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()))
    then
      do:  (let: "$a0" := #(str "%x state.commit %d is out of range [%d, %d]") in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
      let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.HardState "Commit" "state"))) in
      let: "$sl2" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))))) in
      let: "$sl3" := (interface.make uint64__mset ((raftLog__lastIndex (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #())) in
      slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"])) in
      (interface.get "Panicf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1")
    else do:  #());;;
    let: "$r0" := (![uint64T] (struct.field_ref raftpb.HardState "Commit" "state")) in
    do:  ((struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) <-[uint64T] "$r0");;;
    let: "$r0" := (![uint64T] (struct.field_ref raftpb.HardState "Term" "state")) in
    do:  ((struct.field_ref raft "Term" (![ptrT] "r")) <-[uint64T] "$r0");;;
    let: "$r0" := (![uint64T] (struct.field_ref raftpb.HardState "Vote" "state")) in
    do:  ((struct.field_ref raft "Vote" (![ptrT] "r")) <-[uint64T] "$r0")).

(* go: state_trace_nop.go:30:6 *)
Definition traceInitState : val :=
  rec: "traceInitState" "" :=
    exception_do (let: "" := (ref_ty ptrT "") in
    do:  #()).

Definition LocalAppendThread : expr := math.MaxUint64.

Definition LocalApplyThread : expr := #(W64 (math.MaxUint64 - 1)).

(* go: util.go:65:6 *)
Definition IsLocalMsgTarget : val :=
  rec: "IsLocalMsgTarget" "id" :=
    exception_do (let: "id" := (ref_ty uint64T "id") in
    return: (((![uint64T] "id") = LocalAppendThread) || ((![uint64T] "id") = LocalApplyThread))).

(* go: raft.go:291:18 *)
Definition Config__validate : val :=
  rec: "Config__validate" "c" <> :=
    exception_do (let: "c" := (ref_ty ptrT "c") in
    (if: (![uint64T] (struct.field_ref Config "ID" (![ptrT] "c"))) = None
    then
      return: (let: "$a0" := #(str "cannot use none as id") in
       errors.New "$a0")
    else do:  #());;;
    (if: let: "$a0" := (![uint64T] (struct.field_ref Config "ID" (![ptrT] "c"))) in
    IsLocalMsgTarget "$a0"
    then
      return: (let: "$a0" := #(str "cannot use local target as id") in
       errors.New "$a0")
    else do:  #());;;
    (if: int_leq (![intT] (struct.field_ref Config "HeartbeatTick" (![ptrT] "c"))) #(W64 0)
    then
      return: (let: "$a0" := #(str "heartbeat tick must be greater than 0") in
       errors.New "$a0")
    else do:  #());;;
    (if: int_leq (![intT] (struct.field_ref Config "ElectionTick" (![ptrT] "c"))) (![intT] (struct.field_ref Config "HeartbeatTick" (![ptrT] "c")))
    then
      return: (let: "$a0" := #(str "election tick must be greater than heartbeat tick") in
       errors.New "$a0")
    else do:  #());;;
    (if: (![Storage] (struct.field_ref Config "Storage" (![ptrT] "c"))) = (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
    then
      return: (let: "$a0" := #(str "storage cannot be nil") in
       errors.New "$a0")
    else do:  #());;;
    (if: (![uint64T] (struct.field_ref Config "MaxUncommittedEntriesSize" (![ptrT] "c"))) = #(W64 0)
    then
      let: "$r0" := #(W64 noLimit) in
      do:  ((struct.field_ref Config "MaxUncommittedEntriesSize" (![ptrT] "c")) <-[uint64T] "$r0")
    else do:  #());;;
    (if: (![uint64T] (struct.field_ref Config "MaxCommittedSizePerReady" (![ptrT] "c"))) = #(W64 0)
    then
      let: "$r0" := (![uint64T] (struct.field_ref Config "MaxSizePerMsg" (![ptrT] "c"))) in
      do:  ((struct.field_ref Config "MaxCommittedSizePerReady" (![ptrT] "c")) <-[uint64T] "$r0")
    else do:  #());;;
    (if: int_leq (![intT] (struct.field_ref Config "MaxInflightMsgs" (![ptrT] "c"))) #(W64 0)
    then
      return: (let: "$a0" := #(str "max inflight messages must be greater than 0") in
       errors.New "$a0")
    else do:  #());;;
    (if: (![uint64T] (struct.field_ref Config "MaxInflightBytes" (![ptrT] "c"))) = #(W64 0)
    then
      let: "$r0" := #(W64 noLimit) in
      do:  ((struct.field_ref Config "MaxInflightBytes" (![ptrT] "c")) <-[uint64T] "$r0")
    else
      (if: (![uint64T] (struct.field_ref Config "MaxInflightBytes" (![ptrT] "c"))) < (![uint64T] (struct.field_ref Config "MaxSizePerMsg" (![ptrT] "c")))
      then
        return: (let: "$a0" := #(str "max inflight bytes must be >= max message size") in
         errors.New "$a0")
      else do:  #()));;;
    (if: (![Logger] (struct.field_ref Config "Logger" (![ptrT] "c"))) = (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
    then
      let: "$r0" := (getLogger #()) in
      do:  ((struct.field_ref Config "Logger" (![ptrT] "c")) <-[Logger] "$r0")
    else do:  #());;;
    (if: ((![ReadOnlyOption] (struct.field_ref Config "ReadOnlyOption" (![ptrT] "c"))) = ReadOnlyLeaseBased) && (~ (![boolT] (struct.field_ref Config "CheckQuorum" (![ptrT] "c"))))
    then
      return: (let: "$a0" := #(str "CheckQuorum must be enabled when ReadOnlyOption is ReadOnlyLeaseBased") in
       errors.New "$a0")
    else do:  #());;;
    return: (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)).

(* go: raft.go:437:6 *)
Definition newRaft : val :=
  rec: "newRaft" "c" :=
    exception_do (let: "c" := (ref_ty ptrT "c") in
    (let: "err" := (ref_ty error (zero_val error)) in
    let: "$r0" := ((Config__validate (![ptrT] "c")) #()) in
    do:  ("err" <-[error] "$r0");;;
    (if: (![error] "err") ≠ (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
    then
      do:  (let: "$a0" := (interface.make string__mset ((interface.get "Error" (![error] "err")) #())) in
      Panic "$a0")
    else do:  #()));;;
    let: "raftlog" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (let: "$a0" := (![Storage] (struct.field_ref Config "Storage" (![ptrT] "c"))) in
    let: "$a1" := (![Logger] (struct.field_ref Config "Logger" (![ptrT] "c"))) in
    let: "$a2" := (![uint64T] (struct.field_ref Config "MaxCommittedSizePerReady" (![ptrT] "c"))) in
    newLogWithSize "$a0" "$a1" "$a2") in
    do:  ("raftlog" <-[ptrT] "$r0");;;
    let: "err" := (ref_ty error (zero_val error)) in
    let: "cs" := (ref_ty raftpb.ConfState (zero_val raftpb.ConfState)) in
    let: "hs" := (ref_ty raftpb.HardState (zero_val raftpb.HardState)) in
    let: (("$ret0", "$ret1"), "$ret2") := ((interface.get "InitialState" (![Storage] (struct.field_ref Config "Storage" (![ptrT] "c")))) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("hs" <-[raftpb.HardState] "$r0");;;
    do:  ("cs" <-[raftpb.ConfState] "$r1");;;
    do:  ("err" <-[error] "$r2");;;
    (if: (![error] "err") ≠ (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
    then
      do:  (let: "$a0" := (interface.make error__mset (![error] "err")) in
      Panic "$a0")
    else do:  #());;;
    let: "r" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty raft (struct.make raft [{
      "id" ::= ![uint64T] (struct.field_ref Config "ID" (![ptrT] "c"));
      "lead" ::= None;
      "isLearner" ::= #false;
      "raftLog" ::= ![ptrT] "raftlog";
      "maxMsgSize" ::= ![uint64T] (struct.field_ref Config "MaxSizePerMsg" (![ptrT] "c"));
      "maxUncommittedSize" ::= ![uint64T] (struct.field_ref Config "MaxUncommittedEntriesSize" (![ptrT] "c"));
      "trk" ::= let: "$a0" := (![intT] (struct.field_ref Config "MaxInflightMsgs" (![ptrT] "c"))) in
      let: "$a1" := (![uint64T] (struct.field_ref Config "MaxInflightBytes" (![ptrT] "c"))) in
      tracker.MakeProgressTracker "$a0" "$a1";
      "electionTimeout" ::= ![intT] (struct.field_ref Config "ElectionTick" (![ptrT] "c"));
      "heartbeatTimeout" ::= ![intT] (struct.field_ref Config "HeartbeatTick" (![ptrT] "c"));
      "logger" ::= ![Logger] (struct.field_ref Config "Logger" (![ptrT] "c"));
      "checkQuorum" ::= ![boolT] (struct.field_ref Config "CheckQuorum" (![ptrT] "c"));
      "preVote" ::= ![boolT] (struct.field_ref Config "PreVote" (![ptrT] "c"));
      "readOnly" ::= let: "$a0" := (![ReadOnlyOption] (struct.field_ref Config "ReadOnlyOption" (![ptrT] "c"))) in
      newReadOnly "$a0";
      "disableProposalForwarding" ::= ![boolT] (struct.field_ref Config "DisableProposalForwarding" (![ptrT] "c"));
      "disableConfChangeValidation" ::= ![boolT] (struct.field_ref Config "DisableConfChangeValidation" (![ptrT] "c"));
      "stepDownOnRemoval" ::= ![boolT] (struct.field_ref Config "StepDownOnRemoval" (![ptrT] "c"));
      "traceLogger" ::= ![TraceLogger] (struct.field_ref Config "TraceLogger" (![ptrT] "c"))
    }])) in
    do:  ("r" <-[ptrT] "$r0");;;
    do:  (let: "$a0" := (![ptrT] "r") in
    traceInitState "$a0");;;
    let: "lastID" := (ref_ty entryID (zero_val entryID)) in
    let: "$r0" := ((raftLog__lastEntryID (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()) in
    do:  ("lastID" <-[entryID] "$r0");;;
    let: "trk" := (ref_ty tracker.ProgressMap (zero_val tracker.ProgressMap)) in
    let: "cfg" := (ref_ty tracker.Config (zero_val tracker.Config)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (struct.make confchange.Changer [{
      "Tracker" ::= ![tracker.ProgressTracker] (struct.field_ref raft "trk" (![ptrT] "r"));
      "LastIndex" ::= ![uint64T] (struct.field_ref entryID "index" "lastID")
    }]) in
    let: "$a1" := (![raftpb.ConfState] "cs") in
    confchange.Restore "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("cfg" <-[tracker.Config] "$r0");;;
    do:  ("trk" <-[tracker.ProgressMap] "$r1");;;
    do:  ("err" <-[error] "$r2");;;
    (if: (![error] "err") ≠ (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
    then
      do:  (let: "$a0" := (interface.make error__mset (![error] "err")) in
      Panic "$a0")
    else do:  #());;;
    do:  (let: "$a0" := (![Logger] (struct.field_ref raft "logger" (![ptrT] "r"))) in
    let: "$a1" := (![raftpb.ConfState] "cs") in
    let: "$a2" := (let: "$a0" := (![tracker.Config] "cfg") in
    let: "$a1" := (![tracker.ProgressMap] "trk") in
    (raft__switchToConfig (![ptrT] "r")) "$a0" "$a1") in
    assertConfStatesEquivalent "$a0" "$a1" "$a2");;;
    (if: (~ (let: "$a0" := (![raftpb.HardState] "hs") in
    IsEmptyHardState "$a0"))
    then
      do:  (let: "$a0" := (![raftpb.HardState] "hs") in
      (raft__loadState (![ptrT] "r")) "$a0")
    else do:  #());;;
    (if: (![uint64T] (struct.field_ref Config "Applied" (![ptrT] "c"))) > #(W64 0)
    then
      do:  (let: "$a0" := (![uint64T] (struct.field_ref Config "Applied" (![ptrT] "c"))) in
      let: "$a1" := #(W64 0) in
      (raftLog__appliedTo (![ptrT] "raftlog")) "$a0" "$a1")
    else do:  #());;;
    do:  (let: "$a0" := (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r"))) in
    let: "$a1" := None in
    (raft__becomeFollower (![ptrT] "r")) "$a0" "$a1");;;
    let: "nodesStrs" := (ref_ty (sliceT stringT) (zero_val (sliceT stringT))) in
    do:  (let: "$range" := ((tracker.ProgressTracker__VoterNodes (struct.field_ref raft "trk" (![ptrT] "r"))) #()) in
    slice.for_range uint64T "$range" (λ: <> "n",
      let: "n" := ref_ty uint64T "n" in
      let: "$r0" := (let: "$a0" := (![sliceT stringT] "nodesStrs") in
      let: "$a1" := ((let: "$sl0" := (let: "$a0" := #(str "%x") in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] "n")) in
      slice.literal interfaceT ["$sl0"])) in
      fmt.Sprintf "$a0" "$a1") in
      slice.literal stringT ["$sl0"])) in
      (slice.append (sliceT stringT)) "$a0" "$a1") in
      do:  ("nodesStrs" <-[sliceT stringT] "$r0")));;;
    do:  (let: "$a0" := #(str "newRaft %x [peers: [%s], term: %d, commit: %d, applied: %d, lastindex: %d, lastterm: %d]") in
    let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
    let: "$sl1" := (interface.make string__mset (let: "$a0" := (![sliceT stringT] "nodesStrs") in
    let: "$a1" := #(str ",") in
    strings.Join "$a0" "$a1")) in
    let: "$sl2" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
    let: "$sl3" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))))) in
    let: "$sl4" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftLog "applied" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))))) in
    let: "$sl5" := (interface.make uint64__mset (![uint64T] (struct.field_ref entryID "index" "lastID"))) in
    let: "$sl6" := (interface.make uint64__mset (![uint64T] (struct.field_ref entryID "term" "lastID"))) in
    slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"; "$sl4"; "$sl5"; "$sl6"])) in
    (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
    return: (![ptrT] "r")).

(* NewRawNode instantiates a RawNode from the given configuration.

   See Bootstrap() for bootstrapping an initial state; this replaces the former
   'peers' argument to this method (with identical behavior). However, It is
   recommended that instead of calling Bootstrap, applications bootstrap their
   state manually by setting up a Storage that has a first index > 1 and which
   stores the desired ConfState as its InitialState.

   go: rawnode.go:51:6 *)
Definition NewRawNode : val :=
  rec: "NewRawNode" "config" :=
    exception_do (let: "config" := (ref_ty ptrT "config") in
    let: "r" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (let: "$a0" := (![ptrT] "config") in
    newRaft "$a0") in
    do:  ("r" <-[ptrT] "$r0");;;
    let: "rn" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty RawNode (struct.make RawNode [{
      "raft" ::= ![ptrT] "r"
    }])) in
    do:  ("rn" <-[ptrT] "$r0");;;
    let: "$r0" := (![boolT] (struct.field_ref Config "AsyncStorageWrites" (![ptrT] "config"))) in
    do:  ((struct.field_ref RawNode "asyncStorageWrites" (![ptrT] "rn")) <-[boolT] "$r0");;;
    let: "ss" := (ref_ty SoftState (zero_val SoftState)) in
    let: "$r0" := ((raft__softState (![ptrT] "r")) #()) in
    do:  ("ss" <-[SoftState] "$r0");;;
    let: "$r0" := "ss" in
    do:  ((struct.field_ref RawNode "prevSoftSt" (![ptrT] "rn")) <-[ptrT] "$r0");;;
    let: "$r0" := ((raft__hardState (![ptrT] "r")) #()) in
    do:  ((struct.field_ref RawNode "prevHardSt" (![ptrT] "rn")) <-[raftpb.HardState] "$r0");;;
    return: (![ptrT] "rn", interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)).

(* go: node.go:250:6 *)
Definition setupNode : val :=
  rec: "setupNode" "c" "peers" :=
    exception_do (let: "peers" := (ref_ty (sliceT Peer) "peers") in
    let: "c" := (ref_ty ptrT "c") in
    (if: (let: "$a0" := (![sliceT Peer] "peers") in
    slice.len "$a0") = #(W64 0)
    then
      do:  (let: "$a0" := (interface.make string__mset #(str "no peers given; use RestartNode instead")) in
      Panic "$a0")
    else do:  #());;;
    let: "err" := (ref_ty error (zero_val error)) in
    let: "rn" := (ref_ty ptrT (zero_val ptrT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![ptrT] "c") in
    NewRawNode "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("rn" <-[ptrT] "$r0");;;
    do:  ("err" <-[error] "$r1");;;
    (if: (![error] "err") ≠ (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
    then
      do:  (let: "$a0" := (interface.make error__mset (![error] "err")) in
      Panic "$a0")
    else do:  #());;;
    let: "$r0" := (let: "$a0" := (![sliceT Peer] "peers") in
    (RawNode__Bootstrap (![ptrT] "rn")) "$a0") in
    do:  ("err" <-[error] "$r0");;;
    (if: (![error] "err") ≠ (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
    then
      do:  (let: "$a0" := #(str "error occurred during starting a new node: %v") in
      let: "$a1" := ((let: "$sl0" := (interface.make error__mset (![error] "err")) in
      slice.literal interfaceT ["$sl0"])) in
      (interface.get "Warningf" (![Logger] (struct.field_ref Config "Logger" (![ptrT] "c")))) "$a0" "$a1")
    else do:  #());;;
    let: "n" := (ref_ty node (zero_val node)) in
    let: "$r0" := (let: "$a0" := (![ptrT] "rn") in
    newNode "$a0") in
    do:  ("n" <-[node] "$r0");;;
    return: ("n")).

(* go: node.go:551:16 *)
Definition node__Advance : val :=
  rec: "node__Advance" "n" <> :=
    exception_do (let: "n" := (ref_ty ptrT "n") in
    do:  (chan.select [("$sendVal0", "$sendChan0", (λ: <>,
        do:  #()
        ))] [("$recvChan0", (λ: "$recvVal",
        do:  #()
        ))] (InjLV #()))).

(* go: node.go:558:16 *)
Definition node__ApplyConfChange : val :=
  rec: "node__ApplyConfChange" "n" "cc" :=
    exception_do (let: "n" := (ref_ty ptrT "n") in
    let: "cc" := (ref_ty raftpb.ConfChangeI "cc") in
    let: "cs" := (ref_ty raftpb.ConfState (zero_val raftpb.ConfState)) in
    do:  (chan.select [("$sendVal0", "$sendChan0", (λ: <>,
        do:  #()
        ))] [("$recvChan0", (λ: "$recvVal",
        do:  #()
        ))] (InjLV #()));;;
    do:  (chan.select [] [("$recvChan0", (λ: "$recvVal",
        let: "$r0" := (Fst "$recvVal") in
        do:  ("cs" <-[raftpb.ConfState] "$r0");;;
        do:  #()
        )); ("$recvChan1", (λ: "$recvVal",
        do:  #()
        ))] (InjLV #()));;;
    return: ("cs")).

(* Step advances the state machine using msgs. The ctx.Err() will be returned,
   if any.

   go: node.go:510:16 *)
Definition node__stepWithWaitOption : val :=
  rec: "node__stepWithWaitOption" "n" "ctx" "m" "wait" :=
    exception_do (let: "n" := (ref_ty ptrT "n") in
    let: "wait" := (ref_ty boolT "wait") in
    let: "m" := (ref_ty raftpb.Message "m") in
    let: "ctx" := (ref_ty context.Context "ctx") in
    (if: (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) ≠ raftpb.MsgProp
    then
      do:  (chan.select [("$sendVal0", "$sendChan0", (λ: <>,
          return: (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
          ))] [("$recvChan0", (λ: "$recvVal",
          return: ((interface.get "Err" (![context.Context] "ctx")) #())
          )); ("$recvChan1", (λ: "$recvVal",
          return: (![error] "ErrStopped")
          ))] (InjLV #()))
    else do:  #());;;
    let: "ch" := (ref_ty (chanT msgWithResult) (zero_val (chanT msgWithResult))) in
    let: "$r0" := (![chanT msgWithResult] (struct.field_ref node "propc" (![ptrT] "n"))) in
    do:  ("ch" <-[chanT msgWithResult] "$r0");;;
    let: "pm" := (ref_ty msgWithResult (zero_val msgWithResult)) in
    let: "$r0" := (struct.make msgWithResult [{
      "m" ::= ![raftpb.Message] "m"
    }]) in
    do:  ("pm" <-[msgWithResult] "$r0");;;
    (if: ![boolT] "wait"
    then
      let: "$r0" := (chan.make error #()) in
      do:  ((struct.field_ref msgWithResult "result" "pm") <-[chanT error] "$r0")
    else do:  #());;;
    do:  (chan.select [("$sendVal0", "$sendChan0", (λ: <>,
        (if: (~ (![boolT] "wait"))
        then return: (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
        else do:  #())
        ))] [("$recvChan0", (λ: "$recvVal",
        return: ((interface.get "Err" (![context.Context] "ctx")) #())
        )); ("$recvChan1", (λ: "$recvVal",
        return: (![error] "ErrStopped")
        ))] (InjLV #()));;;
    do:  (chan.select [] [("$recvChan0", (λ: "$recvVal",
        let: "err" := (ref_ty error (zero_val error)) in
        let: "$r0" := (Fst "$recvVal") in
        do:  ("err" <-[error] "$r0");;;
        (if: (![error] "err") ≠ (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
        then return: (![error] "err")
        else do:  #())
        )); ("$recvChan1", (λ: "$recvVal",
        return: ((interface.get "Err" (![context.Context] "ctx")) #())
        )); ("$recvChan2", (λ: "$recvVal",
        return: (![error] "ErrStopped")
        ))] (InjLV #()));;;
    return: (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)).

(* go: node.go:500:16 *)
Definition node__step : val :=
  rec: "node__step" "n" "ctx" "m" :=
    exception_do (let: "n" := (ref_ty ptrT "n") in
    let: "m" := (ref_ty raftpb.Message "m") in
    let: "ctx" := (ref_ty context.Context "ctx") in
    return: (let: "$a0" := (![context.Context] "ctx") in
     let: "$a1" := (![raftpb.Message] "m") in
     let: "$a2" := #false in
     (node__stepWithWaitOption (![ptrT] "n")) "$a0" "$a1" "$a2")).

(* go: node.go:467:16 *)
Definition node__Campaign : val :=
  rec: "node__Campaign" "n" "ctx" :=
    exception_do (let: "n" := (ref_ty ptrT "n") in
    let: "ctx" := (ref_ty context.Context "ctx") in
    return: (let: "$a0" := (![context.Context] "ctx") in
     let: "$a1" := (struct.make raftpb.Message [{
       "Type" ::= raftpb.MsgHup
     }]) in
     (node__step (![ptrT] "n")) "$a0" "$a1")).

(* go: node.go:606:16 *)
Definition node__ForgetLeader : val :=
  rec: "node__ForgetLeader" "n" "ctx" :=
    exception_do (let: "n" := (ref_ty ptrT "n") in
    let: "ctx" := (ref_ty context.Context "ctx") in
    return: (let: "$a0" := (![context.Context] "ctx") in
     let: "$a1" := (struct.make raftpb.Message [{
       "Type" ::= raftpb.MsgForgetLeader
     }]) in
     (node__step (![ptrT] "n")) "$a0" "$a1")).

(* go: node.go:504:16 *)
Definition node__stepWait : val :=
  rec: "node__stepWait" "n" "ctx" "m" :=
    exception_do (let: "n" := (ref_ty ptrT "n") in
    let: "m" := (ref_ty raftpb.Message "m") in
    let: "ctx" := (ref_ty context.Context "ctx") in
    return: (let: "$a0" := (![context.Context] "ctx") in
     let: "$a1" := (![raftpb.Message] "m") in
     let: "$a2" := #true in
     (node__stepWithWaitOption (![ptrT] "n")) "$a0" "$a1" "$a2")).

(* go: node.go:471:16 *)
Definition node__Propose : val :=
  rec: "node__Propose" "n" "ctx" "data" :=
    exception_do (let: "n" := (ref_ty ptrT "n") in
    let: "data" := (ref_ty (sliceT byteT) "data") in
    let: "ctx" := (ref_ty context.Context "ctx") in
    return: (let: "$a0" := (![context.Context] "ctx") in
     let: "$a1" := (struct.make raftpb.Message [{
       "Type" ::= raftpb.MsgProp;
       "Entries" ::= (let: "$sl0" := (struct.make raftpb.Entry [{
         "Data" ::= ![sliceT byteT] "data"
       }]) in
       slice.literal raftpb.Entry ["$sl0"])
     }]) in
     (node__stepWait (![ptrT] "n")) "$a0" "$a1")).

(* go: util.go:52:6 *)
Definition isMsgInArray : val :=
  rec: "isMsgInArray" "msgt" "arr" :=
    exception_do (let: "arr" := (ref_ty (sliceT boolT) "arr") in
    let: "msgt" := (ref_ty raftpb.MessageType "msgt") in
    let: "i" := (ref_ty intT (zero_val intT)) in
    let: "$r0" := (to_u64 (![raftpb.MessageType] "msgt")) in
    do:  ("i" <-[intT] "$r0");;;
    return: ((int_lt (![intT] "i") (let: "$a0" := (![sliceT boolT] "arr") in
     slice.len "$a0")) && (![boolT] (slice.elem_ref boolT (![sliceT boolT] "arr") (![intT] "i"))))).

(* go: util.go:57:6 *)
Definition IsLocalMsg : val :=
  rec: "IsLocalMsg" "msgt" :=
    exception_do (let: "msgt" := (ref_ty raftpb.MessageType "msgt") in
    return: (let: "$a0" := (![raftpb.MessageType] "msgt") in
     let: "$a1" := (let: "$a" := "isLocalMsg" in
     array.slice "$a" #(W64 0) (array.len (arrayT 23 boolT))) in
     isMsgInArray "$a0" "$a1")).

(* go: node.go:475:16 *)
Definition node__Step : val :=
  rec: "node__Step" "n" "ctx" "m" :=
    exception_do (let: "n" := (ref_ty ptrT "n") in
    let: "m" := (ref_ty raftpb.Message "m") in
    let: "ctx" := (ref_ty context.Context "ctx") in
    (if: (let: "$a0" := (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) in
    IsLocalMsg "$a0") && (~ (let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "From" "m")) in
    IsLocalMsgTarget "$a0"))
    then return: (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
    else do:  #());;;
    return: (let: "$a0" := (![context.Context] "ctx") in
     let: "$a1" := (![raftpb.Message] "m") in
     (node__step (![ptrT] "n")) "$a0" "$a1")).

(* go: node.go:492:16 *)
Definition node__ProposeConfChange : val :=
  rec: "node__ProposeConfChange" "n" "ctx" "cc" :=
    exception_do (let: "n" := (ref_ty ptrT "n") in
    let: "cc" := (ref_ty raftpb.ConfChangeI "cc") in
    let: "ctx" := (ref_ty context.Context "ctx") in
    let: "err" := (ref_ty error (zero_val error)) in
    let: "msg" := (ref_ty raftpb.Message (zero_val raftpb.Message)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![raftpb.ConfChangeI] "cc") in
    confChangeToMsg "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("msg" <-[raftpb.Message] "$r0");;;
    do:  ("err" <-[error] "$r1");;;
    (if: (![error] "err") ≠ (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
    then return: (![error] "err")
    else do:  #());;;
    return: (let: "$a0" := (![context.Context] "ctx") in
     let: "$a1" := (![raftpb.Message] "msg") in
     (node__Step (![ptrT] "n")) "$a0" "$a1")).

(* go: node.go:610:16 *)
Definition node__ReadIndex : val :=
  rec: "node__ReadIndex" "n" "ctx" "rctx" :=
    exception_do (let: "n" := (ref_ty ptrT "n") in
    let: "rctx" := (ref_ty (sliceT byteT) "rctx") in
    let: "ctx" := (ref_ty context.Context "ctx") in
    return: (let: "$a0" := (![context.Context] "ctx") in
     let: "$a1" := (struct.make raftpb.Message [{
       "Type" ::= raftpb.MsgReadIndex;
       "Entries" ::= (let: "$sl0" := (struct.make raftpb.Entry [{
         "Data" ::= ![sliceT byteT] "rctx"
       }]) in
       slice.literal raftpb.Entry ["$sl0"])
     }]) in
     (node__step (![ptrT] "n")) "$a0" "$a1")).

(* go: node.go:549:16 *)
Definition node__Ready : val :=
  rec: "node__Ready" "n" <> :=
    exception_do (let: "n" := (ref_ty ptrT "n") in
    return: (![chanT Ready] (struct.field_ref node "readyc" (![ptrT] "n")))).

(* go: node.go:588:16 *)
Definition node__ReportSnapshot : val :=
  rec: "node__ReportSnapshot" "n" "id" "status" :=
    exception_do (let: "n" := (ref_ty ptrT "n") in
    let: "status" := (ref_ty SnapshotStatus "status") in
    let: "id" := (ref_ty uint64T "id") in
    let: "rej" := (ref_ty boolT (zero_val boolT)) in
    let: "$r0" := ((![SnapshotStatus] "status") = SnapshotFailure) in
    do:  ("rej" <-[boolT] "$r0");;;
    do:  (chan.select [("$sendVal0", "$sendChan0", (λ: <>,
        do:  #()
        ))] [("$recvChan0", (λ: "$recvVal",
        do:  #()
        ))] (InjLV #()))).

(* go: node.go:581:16 *)
Definition node__ReportUnreachable : val :=
  rec: "node__ReportUnreachable" "n" "id" :=
    exception_do (let: "n" := (ref_ty ptrT "n") in
    let: "id" := (ref_ty uint64T "id") in
    do:  (chan.select [("$sendVal0", "$sendChan0", (λ: <>,
        do:  #()
        ))] [("$recvChan0", (λ: "$recvVal",
        do:  #()
        ))] (InjLV #()))).

(* go: node.go:571:16 *)
Definition node__Status : val :=
  rec: "node__Status" "n" <> :=
    exception_do (let: "n" := (ref_ty ptrT "n") in
    let: "c" := (ref_ty (chanT Status) (zero_val (chanT Status))) in
    let: "$r0" := (chan.make Status #()) in
    do:  ("c" <-[chanT Status] "$r0");;;
    do:  (chan.select [("$sendVal0", "$sendChan0", (λ: <>,
        return: (Fst (chan.receive (![chanT Status] "c")))
        ))] [("$recvChan0", (λ: "$recvVal",
        return: (struct.make Status [{
         }])
        ))] (InjLV #()))).

(* go: node.go:331:16 *)
Definition node__Stop : val :=
  rec: "node__Stop" "n" <> :=
    exception_do (let: "n" := (ref_ty ptrT "n") in
    do:  (chan.select [("$sendVal0", "$sendChan0", (λ: <>,
        do:  #()
        ))] [("$recvChan0", (λ: "$recvVal",
        return: (#())
        ))] (InjLV #()));;;
    do:  (Fst (chan.receive (![chanT structT [
    ]%struct] (struct.field_ref node "done" (![ptrT] "n")))))).

(* Tick increments the internal logical clock for this Node. Election timeouts
   and heartbeat timeouts are in units of ticks.

   go: node.go:458:16 *)
Definition node__Tick : val :=
  rec: "node__Tick" "n" <> :=
    exception_do (let: "n" := (ref_ty ptrT "n") in
    do:  (chan.select [("$sendVal0", "$sendChan0", (λ: <>,
        do:  #()
        ))] [("$recvChan0", (λ: "$recvVal",
        do:  #()
        ))] (InjR (λ: <>,
      do:  (let: "$a0" := #(str "%x A tick missed to fire. Node blocks too long!") in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] (struct.field_ref node "rn" (![ptrT] "n")))))))) in
      slice.literal interfaceT ["$sl0"])) in
      (interface.get "Warningf" (![Logger] (struct.field_ref raft "logger" (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] (struct.field_ref node "rn" (![ptrT] "n")))))))) "$a0" "$a1")
      )))).

(* go: node.go:597:16 *)
Definition node__TransferLeadership : val :=
  rec: "node__TransferLeadership" "n" "ctx" "lead" "transferee" :=
    exception_do (let: "n" := (ref_ty ptrT "n") in
    let: "transferee" := (ref_ty uint64T "transferee") in
    let: "lead" := (ref_ty uint64T "lead") in
    let: "ctx" := (ref_ty context.Context "ctx") in
    do:  (chan.select [("$sendVal0", "$sendChan0", (λ: <>,
        do:  #()
        ))] [("$recvChan0", (λ: "$recvVal",
        do:  #()
        )); ("$recvChan1", (λ: "$recvVal",
        do:  #()
        ))] (InjLV #()))).

(* go: util.go:61:6 *)
Definition IsResponseMsg : val :=
  rec: "IsResponseMsg" "msgt" :=
    exception_do (let: "msgt" := (ref_ty raftpb.MessageType "msgt") in
    return: (let: "$a0" := (![raftpb.MessageType] "msgt") in
     let: "$a1" := (let: "$a" := "isResponseMsg" in
     array.slice "$a" #(W64 0) (array.len (arrayT 23 boolT))) in
     isMsgInArray "$a0" "$a1")).

(* Tick advances the internal logical clock by a single tick.

   go: rawnode.go:64:20 *)
Definition RawNode__Tick : val :=
  rec: "RawNode__Tick" "rn" <> :=
    exception_do (let: "rn" := (ref_ty ptrT "rn") in
    do:  ((![funcT] (struct.field_ref raft "tick" (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn"))))) #())).

(* go: state_trace_nop.go:32:6 *)
Definition traceReady : val :=
  rec: "traceReady" "" :=
    exception_do (let: "" := (ref_ty ptrT "") in
    do:  #()).

(* applyUnstableEntries returns whether entries are allowed to be applied once
   they are known to be committed but before they have been written locally to
   stable storage.

   go: rawnode.go:448:20 *)
Definition RawNode__applyUnstableEntries : val :=
  rec: "RawNode__applyUnstableEntries" "rn" <> :=
    exception_do (let: "rn" := (ref_ty ptrT "rn") in
    return: ((~ (![boolT] (struct.field_ref RawNode "asyncStorageWrites" (![ptrT] "rn")))))).

(* go: rawnode.go:368:6 *)
Definition needStorageApplyMsg : val :=
  rec: "needStorageApplyMsg" "rd" :=
    exception_do (let: "rd" := (ref_ty Ready "rd") in
    return: (int_gt (let: "$a0" := (![sliceT raftpb.Entry] (struct.field_ref Ready "CommittedEntries" "rd")) in
     slice.len "$a0") #(W64 0))).

(* go: rawnode.go:369:6 *)
Definition needStorageApplyRespMsg : val :=
  rec: "needStorageApplyRespMsg" "rd" :=
    exception_do (let: "rd" := (ref_ty Ready "rd") in
    return: (let: "$a0" := (![Ready] "rd") in
     needStorageApplyMsg "$a0")).

(* newStorageApplyRespMsg creates the message that should be returned to node
   after the committed entries in the current Ready (along with those in all
   prior Ready structs) have been applied to the local state machine.

   go: rawnode.go:392:6 *)
Definition newStorageApplyRespMsg : val :=
  rec: "newStorageApplyRespMsg" "r" "ents" :=
    exception_do (let: "ents" := (ref_ty (sliceT raftpb.Entry) "ents") in
    let: "r" := (ref_ty ptrT "r") in
    return: (struct.make raftpb.Message [{
       "Type" ::= raftpb.MsgStorageApplyResp;
       "To" ::= ![uint64T] (struct.field_ref raft "id" (![ptrT] "r"));
       "From" ::= LocalApplyThread;
       "Term" ::= #(W64 0);
       "Entries" ::= ![sliceT raftpb.Entry] "ents"
     }])).

(* go: rawnode.go:212:6 *)
Definition needStorageAppendRespMsg : val :=
  rec: "needStorageAppendRespMsg" "r" "rd" :=
    exception_do (let: "rd" := (ref_ty Ready "rd") in
    let: "r" := (ref_ty ptrT "r") in
    return: (((raftLog__hasNextOrInProgressUnstableEnts (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()) || (~ (let: "$a0" := (![raftpb.Snapshot] (struct.field_ref Ready "Snapshot" "rd")) in
     IsEmptySnap "$a0")))).

(* newStorageAppendRespMsg creates the message that should be returned to node
   after the unstable log entries, hard state, and snapshot in the current Ready
   (along with those in all prior Ready structs) have been saved to stable
   storage.

   go: rawnode.go:268:6 *)
Definition newStorageAppendRespMsg : val :=
  rec: "newStorageAppendRespMsg" "r" "rd" :=
    exception_do (let: "rd" := (ref_ty Ready "rd") in
    let: "r" := (ref_ty ptrT "r") in
    let: "m" := (ref_ty raftpb.Message (zero_val raftpb.Message)) in
    let: "$r0" := (struct.make raftpb.Message [{
      "Type" ::= raftpb.MsgStorageAppendResp;
      "To" ::= ![uint64T] (struct.field_ref raft "id" (![ptrT] "r"));
      "From" ::= LocalAppendThread;
      "Term" ::= ![uint64T] (struct.field_ref raft "Term" (![ptrT] "r"))
    }]) in
    do:  ("m" <-[raftpb.Message] "$r0");;;
    (if: (raftLog__hasNextOrInProgressUnstableEnts (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()
    then
      let: "last" := (ref_ty entryID (zero_val entryID)) in
      let: "$r0" := ((raftLog__lastEntryID (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()) in
      do:  ("last" <-[entryID] "$r0");;;
      let: "$r0" := (![uint64T] (struct.field_ref entryID "index" "last")) in
      do:  ((struct.field_ref raftpb.Message "Index" "m") <-[uint64T] "$r0");;;
      let: "$r0" := (![uint64T] (struct.field_ref entryID "term" "last")) in
      do:  ((struct.field_ref raftpb.Message "LogTerm" "m") <-[uint64T] "$r0")
    else do:  #());;;
    (if: (~ (let: "$a0" := (![raftpb.Snapshot] (struct.field_ref Ready "Snapshot" "rd")) in
    IsEmptySnap "$a0"))
    then
      let: "snap" := (ref_ty raftpb.Snapshot (zero_val raftpb.Snapshot)) in
      let: "$r0" := (![raftpb.Snapshot] (struct.field_ref Ready "Snapshot" "rd")) in
      do:  ("snap" <-[raftpb.Snapshot] "$r0");;;
      let: "$r0" := "snap" in
      do:  ((struct.field_ref raftpb.Message "Snapshot" "m") <-[ptrT] "$r0")
    else do:  #());;;
    return: (![raftpb.Message] "m")).

(* acceptReady is called when the consumer of the RawNode has decided to go
   ahead and handle a Ready. Nothing must alter the state of the RawNode between
   this call and the prior call to Ready().

   go: rawnode.go:405:20 *)
Definition RawNode__acceptReady : val :=
  rec: "RawNode__acceptReady" "rn" "rd" :=
    exception_do (let: "rn" := (ref_ty ptrT "rn") in
    let: "rd" := (ref_ty Ready "rd") in
    (if: (![ptrT] (struct.field_ref Ready "SoftState" "rd")) ≠ #null
    then
      let: "$r0" := (![ptrT] (struct.field_ref Ready "SoftState" "rd")) in
      do:  ((struct.field_ref RawNode "prevSoftSt" (![ptrT] "rn")) <-[ptrT] "$r0")
    else do:  #());;;
    (if: (~ (let: "$a0" := (![raftpb.HardState] (struct.field_ref Ready "HardState" "rd")) in
    IsEmptyHardState "$a0"))
    then
      let: "$r0" := (![raftpb.HardState] (struct.field_ref Ready "HardState" "rd")) in
      do:  ((struct.field_ref RawNode "prevHardSt" (![ptrT] "rn")) <-[raftpb.HardState] "$r0")
    else do:  #());;;
    (if: (let: "$a0" := (![sliceT ReadState] (struct.field_ref Ready "ReadStates" "rd")) in
    slice.len "$a0") ≠ #(W64 0)
    then
      let: "$r0" := slice.nil in
      do:  ((struct.field_ref raft "readStates" (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))) <-[sliceT ReadState] "$r0")
    else do:  #());;;
    (if: (~ (![boolT] (struct.field_ref RawNode "asyncStorageWrites" (![ptrT] "rn"))))
    then
      (if: (let: "$a0" := (![sliceT raftpb.Message] (struct.field_ref RawNode "stepsOnAdvance" (![ptrT] "rn"))) in
      slice.len "$a0") ≠ #(W64 0)
      then
        do:  (let: "$a0" := #(str "two accepted Ready structs without call to Advance") in
        let: "$a1" := slice.nil in
        (interface.get "Panicf" (![Logger] (struct.field_ref raft "logger" (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))))) "$a0" "$a1")
      else do:  #());;;
      do:  (let: "$range" := (![sliceT raftpb.Message] (struct.field_ref raft "msgsAfterAppend" (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn"))))) in
      slice.for_range raftpb.Message "$range" (λ: <> "m",
        let: "m" := ref_ty raftpb.Message "m" in
        (if: (![uint64T] (struct.field_ref raftpb.Message "To" "m")) = (![uint64T] (struct.field_ref raft "id" (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))))
        then
          let: "$r0" := (let: "$a0" := (![sliceT raftpb.Message] (struct.field_ref RawNode "stepsOnAdvance" (![ptrT] "rn"))) in
          let: "$a1" := ((let: "$sl0" := (![raftpb.Message] "m") in
          slice.literal raftpb.Message ["$sl0"])) in
          (slice.append (sliceT raftpb.Message)) "$a0" "$a1") in
          do:  ((struct.field_ref RawNode "stepsOnAdvance" (![ptrT] "rn")) <-[sliceT raftpb.Message] "$r0")
        else do:  #())));;;
      (if: let: "$a0" := (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn"))) in
      let: "$a1" := (![Ready] "rd") in
      needStorageAppendRespMsg "$a0" "$a1"
      then
        let: "m" := (ref_ty raftpb.Message (zero_val raftpb.Message)) in
        let: "$r0" := (let: "$a0" := (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn"))) in
        let: "$a1" := (![Ready] "rd") in
        newStorageAppendRespMsg "$a0" "$a1") in
        do:  ("m" <-[raftpb.Message] "$r0");;;
        let: "$r0" := (let: "$a0" := (![sliceT raftpb.Message] (struct.field_ref RawNode "stepsOnAdvance" (![ptrT] "rn"))) in
        let: "$a1" := ((let: "$sl0" := (![raftpb.Message] "m") in
        slice.literal raftpb.Message ["$sl0"])) in
        (slice.append (sliceT raftpb.Message)) "$a0" "$a1") in
        do:  ((struct.field_ref RawNode "stepsOnAdvance" (![ptrT] "rn")) <-[sliceT raftpb.Message] "$r0")
      else do:  #());;;
      (if: let: "$a0" := (![Ready] "rd") in
      needStorageApplyRespMsg "$a0"
      then
        let: "m" := (ref_ty raftpb.Message (zero_val raftpb.Message)) in
        let: "$r0" := (let: "$a0" := (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn"))) in
        let: "$a1" := (![sliceT raftpb.Entry] (struct.field_ref Ready "CommittedEntries" "rd")) in
        newStorageApplyRespMsg "$a0" "$a1") in
        do:  ("m" <-[raftpb.Message] "$r0");;;
        let: "$r0" := (let: "$a0" := (![sliceT raftpb.Message] (struct.field_ref RawNode "stepsOnAdvance" (![ptrT] "rn"))) in
        let: "$a1" := ((let: "$sl0" := (![raftpb.Message] "m") in
        slice.literal raftpb.Message ["$sl0"])) in
        (slice.append (sliceT raftpb.Message)) "$a0" "$a1") in
        do:  ((struct.field_ref RawNode "stepsOnAdvance" (![ptrT] "rn")) <-[sliceT raftpb.Message] "$r0")
      else do:  #())
    else do:  #());;;
    let: "$r0" := slice.nil in
    do:  ((struct.field_ref raft "msgs" (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))) <-[sliceT raftpb.Message] "$r0");;;
    let: "$r0" := slice.nil in
    do:  ((struct.field_ref raft "msgsAfterAppend" (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))) <-[sliceT raftpb.Message] "$r0");;;
    do:  ((raftLog__acceptUnstable (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))))) #());;;
    (if: int_gt (let: "$a0" := (![sliceT raftpb.Entry] (struct.field_ref Ready "CommittedEntries" "rd")) in
    slice.len "$a0") #(W64 0)
    then
      let: "ents" := (ref_ty (sliceT raftpb.Entry) (zero_val (sliceT raftpb.Entry))) in
      let: "$r0" := (![sliceT raftpb.Entry] (struct.field_ref Ready "CommittedEntries" "rd")) in
      do:  ("ents" <-[sliceT raftpb.Entry] "$r0");;;
      let: "index" := (ref_ty uint64T (zero_val uint64T)) in
      let: "$r0" := (![uint64T] (struct.field_ref raftpb.Entry "Index" (slice.elem_ref raftpb.Entry (![sliceT raftpb.Entry] "ents") ((let: "$a0" := (![sliceT raftpb.Entry] "ents") in
      slice.len "$a0") - #(W64 1))))) in
      do:  ("index" <-[uint64T] "$r0");;;
      do:  (let: "$a0" := (![uint64T] "index") in
      let: "$a1" := (let: "$a0" := (![sliceT raftpb.Entry] "ents") in
      entsSize "$a0") in
      let: "$a2" := ((RawNode__applyUnstableEntries (![ptrT] "rn")) #()) in
      (raftLog__acceptApplying (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))))) "$a0" "$a1" "$a2")
    else do:  #());;;
    do:  (let: "$a0" := (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn"))) in
    traceReady "$a0")).

(* Advance notifies the RawNode that the application has applied and saved progress in the
   last Ready results.

   NOTE: Advance must not be called when using AsyncStorageWrites. Response messages from
   the local append and apply threads take its place.

   go: rawnode.go:482:20 *)
Definition RawNode__Advance : val :=
  rec: "RawNode__Advance" "rn" <> :=
    exception_do (let: "rn" := (ref_ty ptrT "rn") in
    let: <> := (ref_ty Ready "_") in
    (if: ![boolT] (struct.field_ref RawNode "asyncStorageWrites" (![ptrT] "rn"))
    then
      do:  (let: "$a0" := #(str "Advance must not be called when using AsyncStorageWrites") in
      let: "$a1" := slice.nil in
      (interface.get "Panicf" (![Logger] (struct.field_ref raft "logger" (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))))) "$a0" "$a1")
    else do:  #());;;
    do:  (let: "$range" := (![sliceT raftpb.Message] (struct.field_ref RawNode "stepsOnAdvance" (![ptrT] "rn"))) in
    slice.for_range raftpb.Message "$range" (λ: "i" "m",
      let: "i" := ref_ty uint64T "i" in
      let: "m" := ref_ty raftpb.Message "m" in
      let: "$r0" := (let: "$a0" := (![raftpb.Message] "m") in
      (raft__Step (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))) "$a0") in
      do:  "$r0";;;
      let: "$r0" := (struct.make raftpb.Message [{
      }]) in
      do:  ((slice.elem_ref raftpb.Message (![sliceT raftpb.Message] (struct.field_ref RawNode "stepsOnAdvance" (![ptrT] "rn"))) (![intT] "i")) <-[raftpb.Message] "$r0")));;;
    let: "$r0" := (let: "$s" := (![sliceT raftpb.Message] (struct.field_ref RawNode "stepsOnAdvance" (![ptrT] "rn"))) in
    slice.slice raftpb.Message "$s" #(W64 0) #(W64 0)) in
    do:  ((struct.field_ref RawNode "stepsOnAdvance" (![ptrT] "rn")) <-[sliceT raftpb.Message] "$r0")).

(* go: status.go:44:6 *)
Definition getProgressCopy : val :=
  rec: "getProgressCopy" "r" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "m" := (ref_ty (mapT uint64T tracker.Progress) (zero_val (mapT uint64T tracker.Progress))) in
    let: "$r0" := (map.make uint64T tracker.Progress #()) in
    do:  ("m" <-[mapT uint64T tracker.Progress] "$r0");;;
    do:  (let: "$a0" := (λ: "id" "pr",
      exception_do (let: "pr" := (ref_ty ptrT "pr") in
      let: "id" := (ref_ty uint64T "id") in
      let: "p" := (ref_ty tracker.Progress (zero_val tracker.Progress)) in
      let: "$r0" := (![tracker.Progress] (![ptrT] "pr")) in
      do:  ("p" <-[tracker.Progress] "$r0");;;
      let: "$r0" := ((tracker.Inflights__Clone (![ptrT] (struct.field_ref tracker.Progress "Inflights" (![ptrT] "pr")))) #()) in
      do:  ((struct.field_ref tracker.Progress "Inflights" "p") <-[ptrT] "$r0");;;
      let: "$r0" := #null in
      do:  ("pr" <-[ptrT] "$r0");;;
      let: "$r0" := (![tracker.Progress] "p") in
      do:  (map.insert (![mapT uint64T tracker.Progress] "m") (![uint64T] "id") "$r0"))
      ) in
    (tracker.ProgressTracker__Visit (struct.field_ref raft "trk" (![ptrT] "r"))) "$a0");;;
    return: (![mapT uint64T tracker.Progress] "m")).

(* go: status.go:56:6 *)
Definition getBasicStatus : val :=
  rec: "getBasicStatus" "r" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "s" := (ref_ty BasicStatus (zero_val BasicStatus)) in
    let: "$r0" := (struct.make BasicStatus [{
      "ID" ::= ![uint64T] (struct.field_ref raft "id" (![ptrT] "r"));
      "LeadTransferee" ::= ![uint64T] (struct.field_ref raft "leadTransferee" (![ptrT] "r"))
    }]) in
    do:  ("s" <-[BasicStatus] "$r0");;;
    let: "$r0" := ((raft__hardState (![ptrT] "r")) #()) in
    do:  ((struct.field_ref BasicStatus "HardState" "s") <-[raftpb.HardState] "$r0");;;
    let: "$r0" := ((raft__softState (![ptrT] "r")) #()) in
    do:  ((struct.field_ref BasicStatus "SoftState" "s") <-[SoftState] "$r0");;;
    let: "$r0" := (![uint64T] (struct.field_ref raftLog "applied" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r"))))) in
    do:  ((struct.field_ref BasicStatus "Applied" "s") <-[uint64T] "$r0");;;
    return: (![BasicStatus] "s")).

(* getStatus gets a copy of the current raft status.

   go: status.go:68:6 *)
Definition getStatus : val :=
  rec: "getStatus" "r" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "s" := (ref_ty Status (zero_val Status)) in
    let: "$r0" := (let: "$a0" := (![ptrT] "r") in
    getBasicStatus "$a0") in
    do:  ((struct.field_ref Status "BasicStatus" "s") <-[BasicStatus] "$r0");;;
    (if: (![StateType] (struct.field_ref SoftState "RaftState" (struct.field_ref BasicStatus "SoftState" (struct.field_ref Status "BasicStatus" "s")))) = StateLeader
    then
      let: "$r0" := (let: "$a0" := (![ptrT] "r") in
      getProgressCopy "$a0") in
      do:  ((struct.field_ref Status "Progress" "s") <-[mapT uint64T tracker.Progress] "$r0")
    else do:  #());;;
    let: "$r0" := ((tracker.Config__Clone (struct.field_ref tracker.ProgressTracker "Config" (struct.field_ref raft "trk" (![ptrT] "r")))) #()) in
    do:  ((struct.field_ref Status "Config" "s") <-[tracker.Config] "$r0");;;
    return: (![Status] "s")).

(* go: raft.go:498:16 *)
Definition raft__hasLeader : val :=
  rec: "raft__hasLeader" "r" <> :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    return: ((![uint64T] (struct.field_ref raft "lead" (![ptrT] "r"))) ≠ None)).

(* HasReady called when RawNode user need to check if any Ready pending.

   go: rawnode.go:453:20 *)
Definition RawNode__HasReady : val :=
  rec: "RawNode__HasReady" "rn" <> :=
    exception_do (let: "rn" := (ref_ty ptrT "rn") in
    let: "r" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn"))) in
    do:  ("r" <-[ptrT] "$r0");;;
    (let: "softSt" := (ref_ty SoftState (zero_val SoftState)) in
    let: "$r0" := ((raft__softState (![ptrT] "r")) #()) in
    do:  ("softSt" <-[SoftState] "$r0");;;
    (if: (~ (let: "$a0" := (![ptrT] (struct.field_ref RawNode "prevSoftSt" (![ptrT] "rn"))) in
    (SoftState__equal "softSt") "$a0"))
    then return: (#true)
    else do:  #()));;;
    (let: "hardSt" := (ref_ty raftpb.HardState (zero_val raftpb.HardState)) in
    let: "$r0" := ((raft__hardState (![ptrT] "r")) #()) in
    do:  ("hardSt" <-[raftpb.HardState] "$r0");;;
    (if: (~ (let: "$a0" := (![raftpb.HardState] "hardSt") in
    IsEmptyHardState "$a0")) && (~ (let: "$a0" := (![raftpb.HardState] "hardSt") in
    let: "$a1" := (![raftpb.HardState] (struct.field_ref RawNode "prevHardSt" (![ptrT] "rn"))) in
    isHardStateEqual "$a0" "$a1"))
    then return: (#true)
    else do:  #()));;;
    (if: (raftLog__hasNextUnstableSnapshot (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()
    then return: (#true)
    else do:  #());;;
    (if: (int_gt (let: "$a0" := (![sliceT raftpb.Message] (struct.field_ref raft "msgs" (![ptrT] "r"))) in
    slice.len "$a0") #(W64 0)) || (int_gt (let: "$a0" := (![sliceT raftpb.Message] (struct.field_ref raft "msgsAfterAppend" (![ptrT] "r"))) in
    slice.len "$a0") #(W64 0))
    then return: (#true)
    else do:  #());;;
    (if: ((raftLog__hasNextUnstableEnts (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()) || (let: "$a0" := ((RawNode__applyUnstableEntries (![ptrT] "rn")) #()) in
    (raftLog__hasNextCommittedEnts (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) "$a0")
    then return: (#true)
    else do:  #());;;
    (if: (let: "$a0" := (![sliceT ReadState] (struct.field_ref raft "readStates" (![ptrT] "r"))) in
    slice.len "$a0") ≠ #(W64 0)
    then return: (#true)
    else do:  #());;;
    return: (#false)).

(* newStorageApplyMsg creates the message that should be sent to the local
   apply thread to instruct it to apply committed log entries. The message
   also carries a response that should be delivered after the rest of the
   message is processed. Used with AsyncStorageWrites.

   go: rawnode.go:375:6 *)
Definition newStorageApplyMsg : val :=
  rec: "newStorageApplyMsg" "r" "rd" :=
    exception_do (let: "rd" := (ref_ty Ready "rd") in
    let: "r" := (ref_ty ptrT "r") in
    let: "ents" := (ref_ty (sliceT raftpb.Entry) (zero_val (sliceT raftpb.Entry))) in
    let: "$r0" := (![sliceT raftpb.Entry] (struct.field_ref Ready "CommittedEntries" "rd")) in
    do:  ("ents" <-[sliceT raftpb.Entry] "$r0");;;
    return: (struct.make raftpb.Message [{
       "Type" ::= raftpb.MsgStorageApply;
       "To" ::= LocalApplyThread;
       "From" ::= ![uint64T] (struct.field_ref raft "id" (![ptrT] "r"));
       "Term" ::= #(W64 0);
       "Entries" ::= ![sliceT raftpb.Entry] "ents";
       "Responses" ::= (let: "$sl0" := (let: "$a0" := (![ptrT] "r") in
       let: "$a1" := (![sliceT raftpb.Entry] "ents") in
       newStorageApplyRespMsg "$a0" "$a1") in
       slice.literal raftpb.Message ["$sl0"])
     }])).

(* go: rawnode.go:202:6 *)
Definition needStorageAppendMsg : val :=
  rec: "needStorageAppendMsg" "r" "rd" :=
    exception_do (let: "rd" := (ref_ty Ready "rd") in
    let: "r" := (ref_ty ptrT "r") in
    return: ((((int_gt (let: "$a0" := (![sliceT raftpb.Entry] (struct.field_ref Ready "Entries" "rd")) in
     slice.len "$a0") #(W64 0)) || (~ (let: "$a0" := (![raftpb.HardState] (struct.field_ref Ready "HardState" "rd")) in
     IsEmptyHardState "$a0"))) || (~ (let: "$a0" := (![raftpb.Snapshot] (struct.field_ref Ready "Snapshot" "rd")) in
     IsEmptySnap "$a0"))) || (int_gt (let: "$a0" := (![sliceT raftpb.Message] (struct.field_ref raft "msgsAfterAppend" (![ptrT] "r"))) in
     slice.len "$a0") #(W64 0)))).

(* newStorageAppendMsg creates the message that should be sent to the local
   append thread to instruct it to append log entries, write an updated hard
   state, and apply a snapshot. The message also carries a set of responses
   that should be delivered after the rest of the message is processed. Used
   with AsyncStorageWrites.

   go: rawnode.go:225:6 *)
Definition newStorageAppendMsg : val :=
  rec: "newStorageAppendMsg" "r" "rd" :=
    exception_do (let: "rd" := (ref_ty Ready "rd") in
    let: "r" := (ref_ty ptrT "r") in
    let: "m" := (ref_ty raftpb.Message (zero_val raftpb.Message)) in
    let: "$r0" := (struct.make raftpb.Message [{
      "Type" ::= raftpb.MsgStorageAppend;
      "To" ::= LocalAppendThread;
      "From" ::= ![uint64T] (struct.field_ref raft "id" (![ptrT] "r"));
      "Entries" ::= ![sliceT raftpb.Entry] (struct.field_ref Ready "Entries" "rd")
    }]) in
    do:  ("m" <-[raftpb.Message] "$r0");;;
    (if: (~ (let: "$a0" := (![raftpb.HardState] (struct.field_ref Ready "HardState" "rd")) in
    IsEmptyHardState "$a0"))
    then
      let: "$r0" := (![uint64T] (struct.field_ref raftpb.HardState "Term" (struct.field_ref Ready "HardState" "rd"))) in
      do:  ((struct.field_ref raftpb.Message "Term" "m") <-[uint64T] "$r0");;;
      let: "$r0" := (![uint64T] (struct.field_ref raftpb.HardState "Vote" (struct.field_ref Ready "HardState" "rd"))) in
      do:  ((struct.field_ref raftpb.Message "Vote" "m") <-[uint64T] "$r0");;;
      let: "$r0" := (![uint64T] (struct.field_ref raftpb.HardState "Commit" (struct.field_ref Ready "HardState" "rd"))) in
      do:  ((struct.field_ref raftpb.Message "Commit" "m") <-[uint64T] "$r0")
    else do:  #());;;
    (if: (~ (let: "$a0" := (![raftpb.Snapshot] (struct.field_ref Ready "Snapshot" "rd")) in
    IsEmptySnap "$a0"))
    then
      let: "snap" := (ref_ty raftpb.Snapshot (zero_val raftpb.Snapshot)) in
      let: "$r0" := (![raftpb.Snapshot] (struct.field_ref Ready "Snapshot" "rd")) in
      do:  ("snap" <-[raftpb.Snapshot] "$r0");;;
      let: "$r0" := "snap" in
      do:  ((struct.field_ref raftpb.Message "Snapshot" "m") <-[ptrT] "$r0")
    else do:  #());;;
    let: "$r0" := (![sliceT raftpb.Message] (struct.field_ref raft "msgsAfterAppend" (![ptrT] "r"))) in
    do:  ((struct.field_ref raftpb.Message "Responses" "m") <-[sliceT raftpb.Message] "$r0");;;
    (if: let: "$a0" := (![ptrT] "r") in
    let: "$a1" := (![Ready] "rd") in
    needStorageAppendRespMsg "$a0" "$a1"
    then
      let: "$r0" := (let: "$a0" := (![sliceT raftpb.Message] (struct.field_ref raftpb.Message "Responses" "m")) in
      let: "$a1" := ((let: "$sl0" := (let: "$a0" := (![ptrT] "r") in
      let: "$a1" := (![Ready] "rd") in
      newStorageAppendRespMsg "$a0" "$a1") in
      slice.literal raftpb.Message ["$sl0"])) in
      (slice.append (sliceT raftpb.Message)) "$a0" "$a1") in
      do:  ((struct.field_ref raftpb.Message "Responses" "m") <-[sliceT raftpb.Message] "$r0")
    else do:  #());;;
    return: (![raftpb.Message] "m")).

(* MustSync returns true if the hard state and count of Raft entries indicate
   that a synchronous write to persistent storage is required.

   go: rawnode.go:193:6 *)
Definition MustSync : val :=
  rec: "MustSync" "st" "prevst" "entsnum" :=
    exception_do (let: "entsnum" := (ref_ty intT "entsnum") in
    let: "prevst" := (ref_ty raftpb.HardState "prevst") in
    let: "st" := (ref_ty raftpb.HardState "st") in
    return: ((((![intT] "entsnum") ≠ #(W64 0)) || ((![uint64T] (struct.field_ref raftpb.HardState "Vote" "st")) ≠ (![uint64T] (struct.field_ref raftpb.HardState "Vote" "prevst")))) || ((![uint64T] (struct.field_ref raftpb.HardState "Term" "st")) ≠ (![uint64T] (struct.field_ref raftpb.HardState "Term" "prevst"))))).

(* readyWithoutAccept returns a Ready. This is a read-only operation, i.e. there
   is no obligation that the Ready must be handled.

   go: rawnode.go:141:20 *)
Definition RawNode__readyWithoutAccept : val :=
  rec: "RawNode__readyWithoutAccept" "rn" <> :=
    exception_do (let: "rn" := (ref_ty ptrT "rn") in
    let: "r" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn"))) in
    do:  ("r" <-[ptrT] "$r0");;;
    let: "rd" := (ref_ty Ready (zero_val Ready)) in
    let: "$r0" := (struct.make Ready [{
      "Entries" ::= (raftLog__nextUnstableEnts (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #();
      "CommittedEntries" ::= let: "$a0" := ((RawNode__applyUnstableEntries (![ptrT] "rn")) #()) in
      (raftLog__nextCommittedEnts (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) "$a0";
      "Messages" ::= ![sliceT raftpb.Message] (struct.field_ref raft "msgs" (![ptrT] "r"))
    }]) in
    do:  ("rd" <-[Ready] "$r0");;;
    (let: "softSt" := (ref_ty SoftState (zero_val SoftState)) in
    let: "$r0" := ((raft__softState (![ptrT] "r")) #()) in
    do:  ("softSt" <-[SoftState] "$r0");;;
    (if: (~ (let: "$a0" := (![ptrT] (struct.field_ref RawNode "prevSoftSt" (![ptrT] "rn"))) in
    (SoftState__equal "softSt") "$a0"))
    then
      let: "escapingSoftSt" := (ref_ty SoftState (zero_val SoftState)) in
      let: "$r0" := (![SoftState] "softSt") in
      do:  ("escapingSoftSt" <-[SoftState] "$r0");;;
      let: "$r0" := "escapingSoftSt" in
      do:  ((struct.field_ref Ready "SoftState" "rd") <-[ptrT] "$r0")
    else do:  #()));;;
    (let: "hardSt" := (ref_ty raftpb.HardState (zero_val raftpb.HardState)) in
    let: "$r0" := ((raft__hardState (![ptrT] "r")) #()) in
    do:  ("hardSt" <-[raftpb.HardState] "$r0");;;
    (if: (~ (let: "$a0" := (![raftpb.HardState] "hardSt") in
    let: "$a1" := (![raftpb.HardState] (struct.field_ref RawNode "prevHardSt" (![ptrT] "rn"))) in
    isHardStateEqual "$a0" "$a1"))
    then
      let: "$r0" := (![raftpb.HardState] "hardSt") in
      do:  ((struct.field_ref Ready "HardState" "rd") <-[raftpb.HardState] "$r0")
    else do:  #()));;;
    (if: (raftLog__hasNextUnstableSnapshot (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()
    then
      let: "$r0" := (![raftpb.Snapshot] ((raftLog__nextUnstableSnapshot (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #())) in
      do:  ((struct.field_ref Ready "Snapshot" "rd") <-[raftpb.Snapshot] "$r0")
    else do:  #());;;
    (if: (let: "$a0" := (![sliceT ReadState] (struct.field_ref raft "readStates" (![ptrT] "r"))) in
    slice.len "$a0") ≠ #(W64 0)
    then
      let: "$r0" := (![sliceT ReadState] (struct.field_ref raft "readStates" (![ptrT] "r"))) in
      do:  ((struct.field_ref Ready "ReadStates" "rd") <-[sliceT ReadState] "$r0")
    else do:  #());;;
    let: "$r0" := (let: "$a0" := ((raft__hardState (![ptrT] "r")) #()) in
    let: "$a1" := (![raftpb.HardState] (struct.field_ref RawNode "prevHardSt" (![ptrT] "rn"))) in
    let: "$a2" := (let: "$a0" := (![sliceT raftpb.Entry] (struct.field_ref Ready "Entries" "rd")) in
    slice.len "$a0") in
    MustSync "$a0" "$a1" "$a2") in
    do:  ((struct.field_ref Ready "MustSync" "rd") <-[boolT] "$r0");;;
    (if: ![boolT] (struct.field_ref RawNode "asyncStorageWrites" (![ptrT] "rn"))
    then
      (if: let: "$a0" := (![ptrT] "r") in
      let: "$a1" := (![Ready] "rd") in
      needStorageAppendMsg "$a0" "$a1"
      then
        let: "m" := (ref_ty raftpb.Message (zero_val raftpb.Message)) in
        let: "$r0" := (let: "$a0" := (![ptrT] "r") in
        let: "$a1" := (![Ready] "rd") in
        newStorageAppendMsg "$a0" "$a1") in
        do:  ("m" <-[raftpb.Message] "$r0");;;
        let: "$r0" := (let: "$a0" := (![sliceT raftpb.Message] (struct.field_ref Ready "Messages" "rd")) in
        let: "$a1" := ((let: "$sl0" := (![raftpb.Message] "m") in
        slice.literal raftpb.Message ["$sl0"])) in
        (slice.append (sliceT raftpb.Message)) "$a0" "$a1") in
        do:  ((struct.field_ref Ready "Messages" "rd") <-[sliceT raftpb.Message] "$r0")
      else do:  #());;;
      (if: let: "$a0" := (![Ready] "rd") in
      needStorageApplyMsg "$a0"
      then
        let: "m" := (ref_ty raftpb.Message (zero_val raftpb.Message)) in
        let: "$r0" := (let: "$a0" := (![ptrT] "r") in
        let: "$a1" := (![Ready] "rd") in
        newStorageApplyMsg "$a0" "$a1") in
        do:  ("m" <-[raftpb.Message] "$r0");;;
        let: "$r0" := (let: "$a0" := (![sliceT raftpb.Message] (struct.field_ref Ready "Messages" "rd")) in
        let: "$a1" := ((let: "$sl0" := (![raftpb.Message] "m") in
        slice.literal raftpb.Message ["$sl0"])) in
        (slice.append (sliceT raftpb.Message)) "$a0" "$a1") in
        do:  ((struct.field_ref Ready "Messages" "rd") <-[sliceT raftpb.Message] "$r0")
      else do:  #())
    else
      do:  (let: "$range" := (![sliceT raftpb.Message] (struct.field_ref raft "msgsAfterAppend" (![ptrT] "r"))) in
      slice.for_range raftpb.Message "$range" (λ: <> "m",
        let: "m" := ref_ty raftpb.Message "m" in
        (if: (![uint64T] (struct.field_ref raftpb.Message "To" "m")) ≠ (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))
        then
          let: "$r0" := (let: "$a0" := (![sliceT raftpb.Message] (struct.field_ref Ready "Messages" "rd")) in
          let: "$a1" := ((let: "$sl0" := (![raftpb.Message] "m") in
          slice.literal raftpb.Message ["$sl0"])) in
          (slice.append (sliceT raftpb.Message)) "$a0" "$a1") in
          do:  ((struct.field_ref Ready "Messages" "rd") <-[sliceT raftpb.Message] "$r0")
        else do:  #()))));;;
    return: (![Ready] "rd")).

(* go: node.go:343:16 *)
Definition node__run : val :=
  rec: "node__run" "n" <> :=
    exception_do (let: "n" := (ref_ty ptrT "n") in
    let: "propc" := (ref_ty (chanT msgWithResult) (zero_val (chanT msgWithResult))) in
    let: "readyc" := (ref_ty (chanT Ready) (zero_val (chanT Ready))) in
    let: "advancec" := (ref_ty (chanT structT [
    ]%struct) (zero_val (chanT structT [
    ]%struct))) in
    let: "rd" := (ref_ty Ready (zero_val Ready)) in
    let: "r" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] (struct.field_ref node "rn" (![ptrT] "n"))))) in
    do:  ("r" <-[ptrT] "$r0");;;
    let: "lead" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := None in
    do:  ("lead" <-[uint64T] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      (if: ((![chanT structT [
      ]%struct] "advancec") = chan.nil) && ((RawNode__HasReady (![ptrT] (struct.field_ref node "rn" (![ptrT] "n")))) #())
      then
        let: "$r0" := ((RawNode__readyWithoutAccept (![ptrT] (struct.field_ref node "rn" (![ptrT] "n")))) #()) in
        do:  ("rd" <-[Ready] "$r0");;;
        let: "$r0" := (![chanT Ready] (struct.field_ref node "readyc" (![ptrT] "n"))) in
        do:  ("readyc" <-[chanT Ready] "$r0")
      else do:  #());;;
      (if: (![uint64T] "lead") ≠ (![uint64T] (struct.field_ref raft "lead" (![ptrT] "r")))
      then
        (if: (raft__hasLeader (![ptrT] "r")) #()
        then
          (if: (![uint64T] "lead") = None
          then
            do:  (let: "$a0" := #(str "raft.node: %x elected leader %x at term %d") in
            let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
            let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "lead" (![ptrT] "r")))) in
            let: "$sl2" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
            slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
            (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1")
          else
            do:  (let: "$a0" := #(str "raft.node: %x changed leader from %x to %x at term %d") in
            let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
            let: "$sl1" := (interface.make uint64__mset (![uint64T] "lead")) in
            let: "$sl2" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "lead" (![ptrT] "r")))) in
            let: "$sl3" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
            slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"])) in
            (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1"));;;
          let: "$r0" := (![chanT msgWithResult] (struct.field_ref node "propc" (![ptrT] "n"))) in
          do:  ("propc" <-[chanT msgWithResult] "$r0")
        else
          do:  (let: "$a0" := #(str "raft.node: %x lost leader %x at term %d") in
          let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
          let: "$sl1" := (interface.make uint64__mset (![uint64T] "lead")) in
          let: "$sl2" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
          slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
          (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
          let: "$r0" := chan.nil in
          do:  ("propc" <-[chanT msgWithResult] "$r0"));;;
        let: "$r0" := (![uint64T] (struct.field_ref raft "lead" (![ptrT] "r"))) in
        do:  ("lead" <-[uint64T] "$r0")
      else do:  #());;;
      do:  (chan.select [("$sendVal0", "$sendChan0", (λ: <>,
          do:  (let: "$a0" := (![Ready] "rd") in
          (RawNode__acceptReady (![ptrT] (struct.field_ref node "rn" (![ptrT] "n")))) "$a0");;;
          (if: (~ (![boolT] (struct.field_ref RawNode "asyncStorageWrites" (![ptrT] (struct.field_ref node "rn" (![ptrT] "n"))))))
          then
            let: "$r0" := (![chanT structT [
            ]%struct] (struct.field_ref node "advancec" (![ptrT] "n"))) in
            do:  ("advancec" <-[chanT structT [
            ]%struct] "$r0")
          else
            let: "$r0" := (struct.make Ready [{
            }]) in
            do:  ("rd" <-[Ready] "$r0"));;;
          let: "$r0" := chan.nil in
          do:  ("readyc" <-[chanT Ready] "$r0")
          ))] [("$recvChan0", (λ: "$recvVal",
          let: "pm" := (ref_ty msgWithResult (zero_val msgWithResult)) in
          let: "$r0" := (Fst "$recvVal") in
          do:  ("pm" <-[msgWithResult] "$r0");;;
          let: "m" := (ref_ty raftpb.Message (zero_val raftpb.Message)) in
          let: "$r0" := (![raftpb.Message] (struct.field_ref msgWithResult "m" "pm")) in
          do:  ("m" <-[raftpb.Message] "$r0");;;
          let: "$r0" := (![uint64T] (struct.field_ref raft "id" (![ptrT] "r"))) in
          do:  ((struct.field_ref raftpb.Message "From" "m") <-[uint64T] "$r0");;;
          let: "err" := (ref_ty error (zero_val error)) in
          let: "$r0" := (let: "$a0" := (![raftpb.Message] "m") in
          (raft__Step (![ptrT] "r")) "$a0") in
          do:  ("err" <-[error] "$r0");;;
          (if: (![chanT error] (struct.field_ref msgWithResult "result" "pm")) ≠ chan.nil
          then
            do:  (let: "$chan" := (![chanT error] (struct.field_ref msgWithResult "result" "pm")) in
            let: "$v" := (![error] "err") in
            chan.send "$chan" "$v");;;
            do:  (let: "$a0" := (![chanT error] (struct.field_ref msgWithResult "result" "pm")) in
            chan.close "$a0")
          else do:  #())
          )); ("$recvChan1", (λ: "$recvVal",
          let: "m" := (ref_ty raftpb.Message (zero_val raftpb.Message)) in
          let: "$r0" := (Fst "$recvVal") in
          do:  ("m" <-[raftpb.Message] "$r0");;;
          (if: ((let: "$a0" := (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) in
          IsResponseMsg "$a0") && (~ (let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "From" "m")) in
          IsLocalMsgTarget "$a0"))) && ((Fst (map.get (![tracker.ProgressMap] (struct.field_ref tracker.ProgressTracker "Progress" (struct.field_ref raft "trk" (![ptrT] "r")))) (![uint64T] (struct.field_ref raftpb.Message "From" "m")))) = #null)
          then break: #()
          else do:  #());;;
          do:  (let: "$a0" := (![raftpb.Message] "m") in
          (raft__Step (![ptrT] "r")) "$a0")
          )); ("$recvChan2", (λ: "$recvVal",
          let: "cc" := (ref_ty raftpb.ConfChangeV2 (zero_val raftpb.ConfChangeV2)) in
          let: "$r0" := (Fst "$recvVal") in
          do:  ("cc" <-[raftpb.ConfChangeV2] "$r0");;;
          let: "okBefore" := (ref_ty boolT (zero_val boolT)) in
          let: <> := (ref_ty ptrT (zero_val ptrT)) in
          let: ("$ret0", "$ret1") := (map.get (![tracker.ProgressMap] (struct.field_ref tracker.ProgressTracker "Progress" (struct.field_ref raft "trk" (![ptrT] "r")))) (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
          let: "$r0" := "$ret0" in
          let: "$r1" := "$ret1" in
          do:  "$r0";;;
          do:  ("okBefore" <-[boolT] "$r1");;;
          let: "cs" := (ref_ty raftpb.ConfState (zero_val raftpb.ConfState)) in
          let: "$r0" := (let: "$a0" := (![raftpb.ConfChangeV2] "cc") in
          (raft__applyConfChange (![ptrT] "r")) "$a0") in
          do:  ("cs" <-[raftpb.ConfState] "$r0");;;
          (let: "okAfter" := (ref_ty boolT (zero_val boolT)) in
          let: <> := (ref_ty ptrT (zero_val ptrT)) in
          let: ("$ret0", "$ret1") := (map.get (![tracker.ProgressMap] (struct.field_ref tracker.ProgressTracker "Progress" (struct.field_ref raft "trk" (![ptrT] "r")))) (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
          let: "$r0" := "$ret0" in
          let: "$r1" := "$ret1" in
          do:  "$r0";;;
          do:  ("okAfter" <-[boolT] "$r1");;;
          (if: (![boolT] "okBefore") && (~ (![boolT] "okAfter"))
          then
            let: "found" := (ref_ty boolT (zero_val boolT)) in
            do:  (let: "$range" := ((let: "$sl0" := (![sliceT uint64T] (struct.field_ref raftpb.ConfState "Voters" "cs")) in
            let: "$sl1" := (![sliceT uint64T] (struct.field_ref raftpb.ConfState "VotersOutgoing" "cs")) in
            slice.literal (sliceT uint64T) ["$sl0"; "$sl1"])) in
            slice.for_range (sliceT uint64T) "$range" (λ: <> "sl",
              let: "sl" := ref_ty (sliceT uint64T) "sl" in
              do:  (let: "$range" := (![sliceT uint64T] "sl") in
              slice.for_range uint64T "$range" (λ: <> "id",
                let: "id" := ref_ty uint64T "id" in
                (if: (![uint64T] "id") = (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))
                then
                  let: "$r0" := #true in
                  do:  ("found" <-[boolT] "$r0");;;
                  break: #()
                else do:  #())));;;
              (if: ![boolT] "found"
              then break: #()
              else do:  #())));;;
            (if: (~ (![boolT] "found"))
            then
              let: "$r0" := chan.nil in
              do:  ("propc" <-[chanT msgWithResult] "$r0")
            else do:  #())
          else do:  #()));;;
          do:  (chan.select [("$sendVal0", "$sendChan0", (λ: <>,
              do:  #()
              ))] [("$recvChan0", (λ: "$recvVal",
              do:  #()
              ))] (InjLV #()))
          )); ("$recvChan3", (λ: "$recvVal",
          do:  ((RawNode__Tick (![ptrT] (struct.field_ref node "rn" (![ptrT] "n")))) #())
          )); ("$recvChan4", (λ: "$recvVal",
          do:  (let: "$a0" := (![Ready] "rd") in
          (RawNode__Advance (![ptrT] (struct.field_ref node "rn" (![ptrT] "n")))) "$a0");;;
          let: "$r0" := (struct.make Ready [{
          }]) in
          do:  ("rd" <-[Ready] "$r0");;;
          let: "$r0" := chan.nil in
          do:  ("advancec" <-[chanT structT [
          ]%struct] "$r0")
          )); ("$recvChan5", (λ: "$recvVal",
          let: "c" := (ref_ty (chanT Status) (zero_val (chanT Status))) in
          let: "$r0" := (Fst "$recvVal") in
          do:  ("c" <-[chanT Status] "$r0");;;
          do:  (let: "$chan" := (![chanT Status] "c") in
          let: "$v" := (let: "$a0" := (![ptrT] "r") in
          getStatus "$a0") in
          chan.send "$chan" "$v")
          )); ("$recvChan6", (λ: "$recvVal",
          do:  (let: "$a0" := (![chanT structT [
          ]%struct] (struct.field_ref node "done" (![ptrT] "n"))) in
          chan.close "$a0");;;
          return: (#())
          ))] (InjLV #())))).

Definition node__mset_ptr : list (string * val) := [
  ("Advance", node__Advance%V);
  ("ApplyConfChange", node__ApplyConfChange%V);
  ("Campaign", node__Campaign%V);
  ("ForgetLeader", node__ForgetLeader%V);
  ("Propose", node__Propose%V);
  ("ProposeConfChange", node__ProposeConfChange%V);
  ("ReadIndex", node__ReadIndex%V);
  ("Ready", node__Ready%V);
  ("ReportSnapshot", node__ReportSnapshot%V);
  ("ReportUnreachable", node__ReportUnreachable%V);
  ("Status", node__Status%V);
  ("Step", node__Step%V);
  ("Stop", node__Stop%V);
  ("Tick", node__Tick%V);
  ("TransferLeadership", node__TransferLeadership%V);
  ("run", node__run%V);
  ("step", node__step%V);
  ("stepWait", node__stepWait%V);
  ("stepWithWaitOption", node__stepWithWaitOption%V)
].

(* StartNode returns a new Node given configuration and a list of raft peers.
   It appends a ConfChangeAddNode entry for each given peer to the initial log.

   Peers must not be zero length; call RestartNode in that case.

   go: node.go:271:6 *)
Definition StartNode : val :=
  rec: "StartNode" "c" "peers" :=
    exception_do (let: "peers" := (ref_ty (sliceT Peer) "peers") in
    let: "c" := (ref_ty ptrT "c") in
    let: "n" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (let: "$a0" := (![ptrT] "c") in
    let: "$a1" := (![sliceT Peer] "peers") in
    setupNode "$a0" "$a1") in
    do:  ("n" <-[ptrT] "$r0");;;
    let: "$go" := (node__run (![ptrT] "n")) in
    do:  (Fork ("$go" #()));;;
    return: (interface.make node__mset_ptr (![ptrT] "n"))).

(* RestartNode is similar to StartNode but does not take a list of peers.
   The current membership of the cluster will be restored from the Storage.
   If the caller has an existing state machine, pass in the last log index that
   has been applied to it; otherwise use zero.

   go: node.go:281:6 *)
Definition RestartNode : val :=
  rec: "RestartNode" "c" :=
    exception_do (let: "c" := (ref_ty ptrT "c") in
    let: "err" := (ref_ty error (zero_val error)) in
    let: "rn" := (ref_ty ptrT (zero_val ptrT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![ptrT] "c") in
    NewRawNode "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("rn" <-[ptrT] "$r0");;;
    do:  ("err" <-[error] "$r1");;;
    (if: (![error] "err") ≠ (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
    then
      do:  (let: "$a0" := (interface.make error__mset (![error] "err")) in
      Panic "$a0")
    else do:  #());;;
    let: "n" := (ref_ty node (zero_val node)) in
    let: "$r0" := (let: "$a0" := (![ptrT] "rn") in
    newNode "$a0") in
    do:  ("n" <-[node] "$r0");;;
    let: "$go" := (node__run "n") in
    do:  (Fork ("$go" #()));;;
    return: (interface.make node__mset_ptr "n")).

Definition msgWithResult__mset : list (string * val) := [
].

Definition msgWithResult__mset_ptr : list (string * val) := [
].

Definition node__mset : list (string * val) := [
].

Definition numStates : expr := #(W64 4).

Definition ReadOnlyOption__mset : list (string * val) := [
].

Definition ReadOnlyOption__mset_ptr : list (string * val) := [
].

Definition lockedRand__mset : list (string * val) := [
].

Definition lockedRand__mset_ptr : list (string * val) := [
  ("Intn", lockedRand__Intn%V)
].

Definition CampaignType__mset : list (string * val) := [
].

Definition CampaignType__mset_ptr : list (string * val) := [
].

Definition StateType__mset_ptr : list (string * val) := [
  ("MarshalJSON", (λ: "$recvAddr",
    StateType__MarshalJSON (![StateType] "$recvAddr")
    )%V);
  ("String", (λ: "$recvAddr",
    StateType__String (![StateType] "$recvAddr")
    )%V)
].

Definition Config__mset : list (string * val) := [
].

Definition Config__mset_ptr : list (string * val) := [
  ("validate", Config__validate%V)
].

Definition raft__mset : list (string * val) := [
].

Definition raft__mset_ptr : list (string * val) := [
  ("Step", raft__Step%V);
  ("abortLeaderTransfer", raft__abortLeaderTransfer%V);
  ("appendEntry", raft__appendEntry%V);
  ("appliedSnap", raft__appliedSnap%V);
  ("appliedTo", raft__appliedTo%V);
  ("applyConfChange", raft__applyConfChange%V);
  ("bcastAppend", raft__bcastAppend%V);
  ("bcastHeartbeat", raft__bcastHeartbeat%V);
  ("bcastHeartbeatWithCtx", raft__bcastHeartbeatWithCtx%V);
  ("becomeCandidate", raft__becomeCandidate%V);
  ("becomeFollower", raft__becomeFollower%V);
  ("becomeLeader", raft__becomeLeader%V);
  ("becomePreCandidate", raft__becomePreCandidate%V);
  ("campaign", raft__campaign%V);
  ("committedEntryInCurrentTerm", raft__committedEntryInCurrentTerm%V);
  ("handleAppendEntries", raft__handleAppendEntries%V);
  ("handleHeartbeat", raft__handleHeartbeat%V);
  ("handleSnapshot", raft__handleSnapshot%V);
  ("hardState", raft__hardState%V);
  ("hasLeader", raft__hasLeader%V);
  ("hasUnappliedConfChanges", raft__hasUnappliedConfChanges%V);
  ("hup", raft__hup%V);
  ("increaseUncommittedSize", raft__increaseUncommittedSize%V);
  ("loadState", raft__loadState%V);
  ("maybeCommit", raft__maybeCommit%V);
  ("maybeSendAppend", raft__maybeSendAppend%V);
  ("maybeSendSnapshot", raft__maybeSendSnapshot%V);
  ("pastElectionTimeout", raft__pastElectionTimeout%V);
  ("poll", raft__poll%V);
  ("promotable", raft__promotable%V);
  ("reduceUncommittedSize", raft__reduceUncommittedSize%V);
  ("reset", raft__reset%V);
  ("resetRandomizedElectionTimeout", raft__resetRandomizedElectionTimeout%V);
  ("responseToReadIndexReq", raft__responseToReadIndexReq%V);
  ("restore", raft__restore%V);
  ("send", raft__send%V);
  ("sendAppend", raft__sendAppend%V);
  ("sendHeartbeat", raft__sendHeartbeat%V);
  ("sendTimeoutNow", raft__sendTimeoutNow%V);
  ("softState", raft__softState%V);
  ("switchToConfig", raft__switchToConfig%V);
  ("tickElection", raft__tickElection%V);
  ("tickHeartbeat", raft__tickHeartbeat%V)
].

Definition stepFunc__mset : list (string * val) := [
].

Definition stepFunc__mset_ptr : list (string * val) := [
].

Definition RawNode__mset : list (string * val) := [
].

(* ApplyConfChange applies a config change to the local node. The app must call
   this when it applies a configuration change, except when it decides to reject
   the configuration change, in which case no call must take place.

   go: rawnode.go:112:20 *)
Definition RawNode__ApplyConfChange : val :=
  rec: "RawNode__ApplyConfChange" "rn" "cc" :=
    exception_do (let: "rn" := (ref_ty ptrT "rn") in
    let: "cc" := (ref_ty raftpb.ConfChangeI "cc") in
    let: "cs" := (ref_ty raftpb.ConfState (zero_val raftpb.ConfState)) in
    let: "$r0" := (let: "$a0" := ((interface.get "AsV2" (![raftpb.ConfChangeI] "cc")) #()) in
    (raft__applyConfChange (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))) "$a0") in
    do:  ("cs" <-[raftpb.ConfState] "$r0");;;
    return: ("cs")).

(* BasicStatus returns a BasicStatus. Notably this does not contain the
   Progress map; see WithProgress for an allocation-free way to inspect it.

   go: rawnode.go:505:20 *)
Definition RawNode__BasicStatus : val :=
  rec: "RawNode__BasicStatus" "rn" <> :=
    exception_do (let: "rn" := (ref_ty ptrT "rn") in
    return: (let: "$a0" := (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn"))) in
     getBasicStatus "$a0")).

(* Campaign causes this RawNode to transition to candidate state.

   go: rawnode.go:83:20 *)
Definition RawNode__Campaign : val :=
  rec: "RawNode__Campaign" "rn" <> :=
    exception_do (let: "rn" := (ref_ty ptrT "rn") in
    return: (let: "$a0" := (struct.make raftpb.Message [{
       "Type" ::= raftpb.MsgHup
     }]) in
     (raft__Step (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))) "$a0")).

(* ForgetLeader forgets a follower's current leader, changing it to None.
   See (Node).ForgetLeader for details.

   go: rawnode.go:552:20 *)
Definition RawNode__ForgetLeader : val :=
  rec: "RawNode__ForgetLeader" "rn" <> :=
    exception_do (let: "rn" := (ref_ty ptrT "rn") in
    return: (let: "$a0" := (struct.make raftpb.Message [{
       "Type" ::= raftpb.MsgForgetLeader
     }]) in
     (raft__Step (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))) "$a0")).

(* Propose proposes data be appended to the raft log.

   go: rawnode.go:90:20 *)
Definition RawNode__Propose : val :=
  rec: "RawNode__Propose" "rn" "data" :=
    exception_do (let: "rn" := (ref_ty ptrT "rn") in
    let: "data" := (ref_ty (sliceT byteT) "data") in
    return: (let: "$a0" := (struct.make raftpb.Message [{
       "Type" ::= raftpb.MsgProp;
       "From" ::= ![uint64T] (struct.field_ref raft "id" (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn"))));
       "Entries" ::= (let: "$sl0" := (struct.make raftpb.Entry [{
         "Data" ::= ![sliceT byteT] "data"
       }]) in
       slice.literal raftpb.Entry ["$sl0"])
     }]) in
     (raft__Step (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))) "$a0")).

(* ProposeConfChange proposes a config change. See (Node).ProposeConfChange for
   details.

   go: rawnode.go:101:20 *)
Definition RawNode__ProposeConfChange : val :=
  rec: "RawNode__ProposeConfChange" "rn" "cc" :=
    exception_do (let: "rn" := (ref_ty ptrT "rn") in
    let: "cc" := (ref_ty raftpb.ConfChangeI "cc") in
    let: "err" := (ref_ty error (zero_val error)) in
    let: "m" := (ref_ty raftpb.Message (zero_val raftpb.Message)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![raftpb.ConfChangeI] "cc") in
    confChangeToMsg "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("m" <-[raftpb.Message] "$r0");;;
    do:  ("err" <-[error] "$r1");;;
    (if: (![error] "err") ≠ (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
    then return: (![error] "err")
    else do:  #());;;
    return: (let: "$a0" := (![raftpb.Message] "m") in
     (raft__Step (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))) "$a0")).

(* ReadIndex requests a read state. The read state will be set in ready.
   Read State has a read index. Once the application advances further than the read
   index, any linearizable read requests issued before the read request can be
   processed safely. The read state will have the same rctx attached.

   go: rawnode.go:560:20 *)
Definition RawNode__ReadIndex : val :=
  rec: "RawNode__ReadIndex" "rn" "rctx" :=
    exception_do (let: "rn" := (ref_ty ptrT "rn") in
    let: "rctx" := (ref_ty (sliceT byteT) "rctx") in
    let: "$r0" := (let: "$a0" := (struct.make raftpb.Message [{
      "Type" ::= raftpb.MsgReadIndex;
      "Entries" ::= (let: "$sl0" := (struct.make raftpb.Entry [{
        "Data" ::= ![sliceT byteT] "rctx"
      }]) in
      slice.literal raftpb.Entry ["$sl0"])
    }]) in
    (raft__Step (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))) "$a0") in
    do:  "$r0").

(* Ready returns the outstanding work that the application needs to handle. This
   includes appending and applying entries or a snapshot, updating the HardState,
   and sending messages. The returned Ready() *must* be handled and subsequently
   passed back via Advance().

   go: rawnode.go:133:20 *)
Definition RawNode__Ready : val :=
  rec: "RawNode__Ready" "rn" <> :=
    exception_do (let: "rn" := (ref_ty ptrT "rn") in
    let: "rd" := (ref_ty Ready (zero_val Ready)) in
    let: "$r0" := ((RawNode__readyWithoutAccept (![ptrT] "rn")) #()) in
    do:  ("rd" <-[Ready] "$r0");;;
    do:  (let: "$a0" := (![Ready] "rd") in
    (RawNode__acceptReady (![ptrT] "rn")) "$a0");;;
    return: (![Ready] "rd")).

(* ReportSnapshot reports the status of the sent snapshot.

   go: rawnode.go:539:20 *)
Definition RawNode__ReportSnapshot : val :=
  rec: "RawNode__ReportSnapshot" "rn" "id" "status" :=
    exception_do (let: "rn" := (ref_ty ptrT "rn") in
    let: "status" := (ref_ty SnapshotStatus "status") in
    let: "id" := (ref_ty uint64T "id") in
    let: "rej" := (ref_ty boolT (zero_val boolT)) in
    let: "$r0" := ((![SnapshotStatus] "status") = SnapshotFailure) in
    do:  ("rej" <-[boolT] "$r0");;;
    let: "$r0" := (let: "$a0" := (struct.make raftpb.Message [{
      "Type" ::= raftpb.MsgSnapStatus;
      "From" ::= ![uint64T] "id";
      "Reject" ::= ![boolT] "rej"
    }]) in
    (raft__Step (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))) "$a0") in
    do:  "$r0").

(* ReportUnreachable reports the given node is not reachable for the last send.

   go: rawnode.go:534:20 *)
Definition RawNode__ReportUnreachable : val :=
  rec: "RawNode__ReportUnreachable" "rn" "id" :=
    exception_do (let: "rn" := (ref_ty ptrT "rn") in
    let: "id" := (ref_ty uint64T "id") in
    let: "$r0" := (let: "$a0" := (struct.make raftpb.Message [{
      "Type" ::= raftpb.MsgUnreachable;
      "From" ::= ![uint64T] "id"
    }]) in
    (raft__Step (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))) "$a0") in
    do:  "$r0").

(* Status returns the current status of the given group. This allocates, see
   BasicStatus and WithProgress for allocation-friendlier choices.

   go: rawnode.go:498:20 *)
Definition RawNode__Status : val :=
  rec: "RawNode__Status" "rn" <> :=
    exception_do (let: "rn" := (ref_ty ptrT "rn") in
    let: "status" := (ref_ty Status (zero_val Status)) in
    let: "$r0" := (let: "$a0" := (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn"))) in
    getStatus "$a0") in
    do:  ("status" <-[Status] "$r0");;;
    return: (![Status] "status")).

(* Step advances the state machine using the given message.

   go: rawnode.go:118:20 *)
Definition RawNode__Step : val :=
  rec: "RawNode__Step" "rn" "m" :=
    exception_do (let: "rn" := (ref_ty ptrT "rn") in
    let: "m" := (ref_ty raftpb.Message "m") in
    (if: (let: "$a0" := (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) in
    IsLocalMsg "$a0") && (~ (let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "From" "m")) in
    IsLocalMsgTarget "$a0"))
    then return: (![error] "ErrStepLocalMsg")
    else do:  #());;;
    (if: ((let: "$a0" := (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) in
    IsResponseMsg "$a0") && (~ (let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "From" "m")) in
    IsLocalMsgTarget "$a0"))) && ((Fst (map.get (![tracker.ProgressMap] (struct.field_ref tracker.ProgressTracker "Progress" (struct.field_ref raft "trk" (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))))) (![uint64T] (struct.field_ref raftpb.Message "From" "m")))) = #null)
    then return: (![error] "ErrStepPeerNotFound")
    else do:  #());;;
    return: (let: "$a0" := (![raftpb.Message] "m") in
     (raft__Step (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))) "$a0")).

(* TickQuiesced advances the internal logical clock by a single tick without
   performing any other state machine processing. It allows the caller to avoid
   periodic heartbeats and elections when all of the peers in a Raft group are
   known to be at the same state. Expected usage is to periodically invoke Tick
   or TickQuiesced depending on whether the group is "active" or "quiesced".

   WARNING: Be very careful about using this method as it subverts the Raft
   state machine. You should probably be using Tick instead.

   DEPRECATED: This method will be removed in a future release.

   go: rawnode.go:78:20 *)
Definition RawNode__TickQuiesced : val :=
  rec: "RawNode__TickQuiesced" "rn" <> :=
    exception_do (let: "rn" := (ref_ty ptrT "rn") in
    do:  ((struct.field_ref raft "electionElapsed" (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))) <-[intT] ((![intT] (struct.field_ref raft "electionElapsed" (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn"))))) + #(W64 1)))).

(* TransferLeader tries to transfer leadership to the given transferee.

   go: rawnode.go:546:20 *)
Definition RawNode__TransferLeader : val :=
  rec: "RawNode__TransferLeader" "rn" "transferee" :=
    exception_do (let: "rn" := (ref_ty ptrT "rn") in
    let: "transferee" := (ref_ty uint64T "transferee") in
    let: "$r0" := (let: "$a0" := (struct.make raftpb.Message [{
      "Type" ::= raftpb.MsgTransferLeader;
      "From" ::= ![uint64T] "transferee"
    }]) in
    (raft__Step (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))) "$a0") in
    do:  "$r0").

Definition ProgressType : go_type := byteT.

Definition ProgressTypeLearner : expr := #(W8 1).

Definition ProgressTypePeer : expr := #(W8 0).

(* WithProgress is a helper to introspect the Progress for this node and its
   peers.

   go: rawnode.go:521:20 *)
Definition RawNode__WithProgress : val :=
  rec: "RawNode__WithProgress" "rn" "visitor" :=
    exception_do (let: "rn" := (ref_ty ptrT "rn") in
    let: "visitor" := (ref_ty funcT "visitor") in
    do:  (let: "$a0" := (λ: "id" "pr",
      exception_do (let: "pr" := (ref_ty ptrT "pr") in
      let: "id" := (ref_ty uint64T "id") in
      let: "typ" := (ref_ty ProgressType (zero_val ProgressType)) in
      let: "$r0" := ProgressTypePeer in
      do:  ("typ" <-[ProgressType] "$r0");;;
      (if: ![boolT] (struct.field_ref tracker.Progress "IsLearner" (![ptrT] "pr"))
      then
        let: "$r0" := ProgressTypeLearner in
        do:  ("typ" <-[ProgressType] "$r0")
      else do:  #());;;
      let: "p" := (ref_ty tracker.Progress (zero_val tracker.Progress)) in
      let: "$r0" := (![tracker.Progress] (![ptrT] "pr")) in
      do:  ("p" <-[tracker.Progress] "$r0");;;
      let: "$r0" := #null in
      do:  ((struct.field_ref tracker.Progress "Inflights" "p") <-[ptrT] "$r0");;;
      do:  (let: "$a0" := (![uint64T] "id") in
      let: "$a1" := (![ProgressType] "typ") in
      let: "$a2" := (![tracker.Progress] "p") in
      (![funcT] "visitor") "$a0" "$a1" "$a2"))
      ) in
    (tracker.ProgressTracker__Visit (struct.field_ref raft "trk" (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn"))))) "$a0")).

Definition RawNode__mset_ptr : list (string * val) := [
  ("Advance", RawNode__Advance%V);
  ("ApplyConfChange", RawNode__ApplyConfChange%V);
  ("BasicStatus", RawNode__BasicStatus%V);
  ("Bootstrap", RawNode__Bootstrap%V);
  ("Campaign", RawNode__Campaign%V);
  ("ForgetLeader", RawNode__ForgetLeader%V);
  ("HasReady", RawNode__HasReady%V);
  ("Propose", RawNode__Propose%V);
  ("ProposeConfChange", RawNode__ProposeConfChange%V);
  ("ReadIndex", RawNode__ReadIndex%V);
  ("Ready", RawNode__Ready%V);
  ("ReportSnapshot", RawNode__ReportSnapshot%V);
  ("ReportUnreachable", RawNode__ReportUnreachable%V);
  ("Status", RawNode__Status%V);
  ("Step", RawNode__Step%V);
  ("Tick", RawNode__Tick%V);
  ("TickQuiesced", RawNode__TickQuiesced%V);
  ("TransferLeader", RawNode__TransferLeader%V);
  ("WithProgress", RawNode__WithProgress%V);
  ("acceptReady", RawNode__acceptReady%V);
  ("applyUnstableEntries", RawNode__applyUnstableEntries%V);
  ("readyWithoutAccept", RawNode__readyWithoutAccept%V)
].

Definition ProgressType__mset : list (string * val) := [
].

Definition ProgressType__mset_ptr : list (string * val) := [
].

Definition ReadState__mset : list (string * val) := [
].

Definition ReadState__mset_ptr : list (string * val) := [
].

Definition readIndexStatus__mset : list (string * val) := [
].

Definition readIndexStatus__mset_ptr : list (string * val) := [
].

Definition readOnly__mset : list (string * val) := [
].

Definition readOnly__mset_ptr : list (string * val) := [
  ("addRequest", readOnly__addRequest%V);
  ("advance", readOnly__advance%V);
  ("lastPendingRequestCtx", readOnly__lastPendingRequestCtx%V);
  ("recvAck", readOnly__recvAck%V)
].

Definition StateTraceDeployed : bool := #false.

Definition TracingEvent : go_type := structT [
]%struct.

Definition TracingEvent__mset : list (string * val) := [
].

Definition TracingEvent__mset_ptr : list (string * val) := [
].

(* MarshalJSON translates the raft status into JSON.
   TODO: try to simplify this by introducing ID type into raft

   go: status.go:80:17 *)
Definition Status__MarshalJSON : val :=
  rec: "Status__MarshalJSON" "s" <> :=
    exception_do (let: "s" := (ref_ty Status "s") in
    let: "j" := (ref_ty stringT (zero_val stringT)) in
    let: "$r0" := (let: "$a0" := #(str "{"id":"%x","term":%d,"vote":"%x","commit":%d,"lead":"%x","raftState":%q,"applied":%d,"progress":{") in
    let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref BasicStatus "ID" (struct.field_ref Status "BasicStatus" "s")))) in
    let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.HardState "Term" (struct.field_ref BasicStatus "HardState" (struct.field_ref Status "BasicStatus" "s"))))) in
    let: "$sl2" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.HardState "Vote" (struct.field_ref BasicStatus "HardState" (struct.field_ref Status "BasicStatus" "s"))))) in
    let: "$sl3" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.HardState "Commit" (struct.field_ref BasicStatus "HardState" (struct.field_ref Status "BasicStatus" "s"))))) in
    let: "$sl4" := (interface.make uint64__mset (![uint64T] (struct.field_ref SoftState "Lead" (struct.field_ref BasicStatus "SoftState" (struct.field_ref Status "BasicStatus" "s"))))) in
    let: "$sl5" := (interface.make StateType__mset (![StateType] (struct.field_ref SoftState "RaftState" (struct.field_ref BasicStatus "SoftState" (struct.field_ref Status "BasicStatus" "s"))))) in
    let: "$sl6" := (interface.make uint64__mset (![uint64T] (struct.field_ref BasicStatus "Applied" (struct.field_ref Status "BasicStatus" "s")))) in
    slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"; "$sl4"; "$sl5"; "$sl6"])) in
    fmt.Sprintf "$a0" "$a1") in
    do:  ("j" <-[stringT] "$r0");;;
    (if: (let: "$a0" := (![mapT uint64T tracker.Progress] (struct.field_ref Status "Progress" "s")) in
    map.len "$a0") = #(W64 0)
    then do:  ("j" <-[stringT] ((![stringT] "j") + #(str "},")))
    else
      do:  (map.for_range (![mapT uint64T tracker.Progress] (struct.field_ref Status "Progress" "s")) (λ: "k" "v",
        let: "subj" := (ref_ty stringT (zero_val stringT)) in
        let: "$r0" := (let: "$a0" := #(str ""%x":{"match":%d,"next":%d,"state":%q},") in
        let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] "k")) in
        let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref tracker.Progress "Match" "v"))) in
        let: "$sl2" := (interface.make uint64__mset (![uint64T] (struct.field_ref tracker.Progress "Next" "v"))) in
        let: "$sl3" := (interface.make tracker.StateType__mset (![tracker.StateType] (struct.field_ref tracker.Progress "State" "v"))) in
        slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"])) in
        fmt.Sprintf "$a0" "$a1") in
        do:  ("subj" <-[stringT] "$r0");;;
        do:  ("j" <-[stringT] ((![stringT] "j") + (![stringT] "subj")))));;;
      let: "$r0" := ((string.from_bytes (let: "$s" := (string.to_bytes (![stringT] "j")) in
      slice.slice byteT "$s" #(W64 0) ((let: "$a0" := (![stringT] "j") in
      StringLength "$a0") - #(W64 1)))) + #(str "},")) in
      do:  ("j" <-[stringT] "$r0"));;;
    do:  ("j" <-[stringT] ((![stringT] "j") + (let: "$a0" := #(str ""leadtransferee":"%x"}") in
    let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref BasicStatus "LeadTransferee" (struct.field_ref Status "BasicStatus" "s")))) in
    slice.literal interfaceT ["$sl0"])) in
    fmt.Sprintf "$a0" "$a1")));;;
    return: (string.to_bytes (![stringT] "j"), interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)).

(* go: status.go:99:17 *)
Definition Status__String : val :=
  rec: "Status__String" "s" <> :=
    exception_do (let: "s" := (ref_ty Status "s") in
    let: "err" := (ref_ty error (zero_val error)) in
    let: "b" := (ref_ty (sliceT byteT) (zero_val (sliceT byteT))) in
    let: ("$ret0", "$ret1") := ((Status__MarshalJSON (![Status] "s")) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("b" <-[sliceT byteT] "$r0");;;
    do:  ("err" <-[error] "$r1");;;
    (if: (![error] "err") ≠ (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
    then
      do:  (let: "$a0" := #(str "unexpected error: %v") in
      let: "$a1" := ((let: "$sl0" := (interface.make error__mset (![error] "err")) in
      slice.literal interfaceT ["$sl0"])) in
      (interface.get "Panicf" (getLogger #())) "$a0" "$a1")
    else do:  #());;;
    return: (string.from_bytes (![sliceT byteT] "b"))).

Definition Status__mset : list (string * val) := [
  ("MarshalJSON", Status__MarshalJSON%V);
  ("String", Status__String%V)
].

Definition Status__mset_ptr : list (string * val) := [
  ("Descriptor", (λ: "$recvAddr",
    raftpb.HardState__Descriptor (struct.field_ref BasicStatus "HardState" (struct.field_ref Status "BasicStatus" "$recvAddr"))
    )%V);
  ("Marshal", (λ: "$recvAddr",
    raftpb.HardState__Marshal (struct.field_ref BasicStatus "HardState" (struct.field_ref Status "BasicStatus" "$recvAddr"))
    )%V);
  ("MarshalJSON", (λ: "$recvAddr",
    Status__MarshalJSON (![Status] "$recvAddr")
    )%V);
  ("MarshalTo", (λ: "$recvAddr",
    raftpb.HardState__MarshalTo (struct.field_ref BasicStatus "HardState" (struct.field_ref Status "BasicStatus" "$recvAddr"))
    )%V);
  ("MarshalToSizedBuffer", (λ: "$recvAddr",
    raftpb.HardState__MarshalToSizedBuffer (struct.field_ref BasicStatus "HardState" (struct.field_ref Status "BasicStatus" "$recvAddr"))
    )%V);
  ("ProtoMessage", (λ: "$recvAddr",
    raftpb.HardState__ProtoMessage (struct.field_ref BasicStatus "HardState" (struct.field_ref Status "BasicStatus" "$recvAddr"))
    )%V);
  ("Reset", (λ: "$recvAddr",
    raftpb.HardState__Reset (struct.field_ref BasicStatus "HardState" (struct.field_ref Status "BasicStatus" "$recvAddr"))
    )%V);
  ("Size", (λ: "$recvAddr",
    raftpb.HardState__Size (struct.field_ref BasicStatus "HardState" (struct.field_ref Status "BasicStatus" "$recvAddr"))
    )%V);
  ("String", (λ: "$recvAddr",
    Status__String (![Status] "$recvAddr")
    )%V);
  ("Unmarshal", (λ: "$recvAddr",
    raftpb.HardState__Unmarshal (struct.field_ref BasicStatus "HardState" (struct.field_ref Status "BasicStatus" "$recvAddr"))
    )%V);
  ("XXX_DiscardUnknown", (λ: "$recvAddr",
    raftpb.HardState__XXX_DiscardUnknown (struct.field_ref BasicStatus "HardState" (struct.field_ref Status "BasicStatus" "$recvAddr"))
    )%V);
  ("XXX_Marshal", (λ: "$recvAddr",
    raftpb.HardState__XXX_Marshal (struct.field_ref BasicStatus "HardState" (struct.field_ref Status "BasicStatus" "$recvAddr"))
    )%V);
  ("XXX_Merge", (λ: "$recvAddr",
    raftpb.HardState__XXX_Merge (struct.field_ref BasicStatus "HardState" (struct.field_ref Status "BasicStatus" "$recvAddr"))
    )%V);
  ("XXX_Size", (λ: "$recvAddr",
    raftpb.HardState__XXX_Size (struct.field_ref BasicStatus "HardState" (struct.field_ref Status "BasicStatus" "$recvAddr"))
    )%V);
  ("XXX_Unmarshal", (λ: "$recvAddr",
    raftpb.HardState__XXX_Unmarshal (struct.field_ref BasicStatus "HardState" (struct.field_ref Status "BasicStatus" "$recvAddr"))
    )%V);
  ("equal", (λ: "$recvAddr",
    SoftState__equal (struct.field_ref BasicStatus "SoftState" (struct.field_ref Status "BasicStatus" "$recvAddr"))
    )%V)
].

Definition BasicStatus__mset : list (string * val) := [
].

Definition BasicStatus__mset_ptr : list (string * val) := [
  ("Descriptor", (λ: "$recvAddr",
    raftpb.HardState__Descriptor (struct.field_ref BasicStatus "HardState" "$recvAddr")
    )%V);
  ("Marshal", (λ: "$recvAddr",
    raftpb.HardState__Marshal (struct.field_ref BasicStatus "HardState" "$recvAddr")
    )%V);
  ("MarshalTo", (λ: "$recvAddr",
    raftpb.HardState__MarshalTo (struct.field_ref BasicStatus "HardState" "$recvAddr")
    )%V);
  ("MarshalToSizedBuffer", (λ: "$recvAddr",
    raftpb.HardState__MarshalToSizedBuffer (struct.field_ref BasicStatus "HardState" "$recvAddr")
    )%V);
  ("ProtoMessage", (λ: "$recvAddr",
    raftpb.HardState__ProtoMessage (struct.field_ref BasicStatus "HardState" "$recvAddr")
    )%V);
  ("Reset", (λ: "$recvAddr",
    raftpb.HardState__Reset (struct.field_ref BasicStatus "HardState" "$recvAddr")
    )%V);
  ("Size", (λ: "$recvAddr",
    raftpb.HardState__Size (struct.field_ref BasicStatus "HardState" "$recvAddr")
    )%V);
  ("String", (λ: "$recvAddr",
    raftpb.HardState__String (struct.field_ref BasicStatus "HardState" "$recvAddr")
    )%V);
  ("Unmarshal", (λ: "$recvAddr",
    raftpb.HardState__Unmarshal (struct.field_ref BasicStatus "HardState" "$recvAddr")
    )%V);
  ("XXX_DiscardUnknown", (λ: "$recvAddr",
    raftpb.HardState__XXX_DiscardUnknown (struct.field_ref BasicStatus "HardState" "$recvAddr")
    )%V);
  ("XXX_Marshal", (λ: "$recvAddr",
    raftpb.HardState__XXX_Marshal (struct.field_ref BasicStatus "HardState" "$recvAddr")
    )%V);
  ("XXX_Merge", (λ: "$recvAddr",
    raftpb.HardState__XXX_Merge (struct.field_ref BasicStatus "HardState" "$recvAddr")
    )%V);
  ("XXX_Size", (λ: "$recvAddr",
    raftpb.HardState__XXX_Size (struct.field_ref BasicStatus "HardState" "$recvAddr")
    )%V);
  ("XXX_Unmarshal", (λ: "$recvAddr",
    raftpb.HardState__XXX_Unmarshal (struct.field_ref BasicStatus "HardState" "$recvAddr")
    )%V);
  ("equal", (λ: "$recvAddr",
    SoftState__equal (struct.field_ref BasicStatus "SoftState" "$recvAddr")
    )%V)
].

Definition inMemStorageCallStats : go_type := structT [
  "initialState" :: intT;
  "firstIndex" :: intT;
  "lastIndex" :: intT;
  "entries" :: intT;
  "term" :: intT;
  "snapshot" :: intT
]%struct.

Definition inMemStorageCallStats__mset : list (string * val) := [
].

Definition inMemStorageCallStats__mset_ptr : list (string * val) := [
].

Definition MemoryStorage : go_type := structT [
  "Mutex" :: sync.Mutex;
  "hardState" :: raftpb.HardState;
  "snapshot" :: raftpb.Snapshot;
  "ents" :: sliceT raftpb.Entry;
  "callStats" :: inMemStorageCallStats
]%struct.

Definition MemoryStorage__mset : list (string * val) := [
].

(* go: storage.go:181:26 *)
Definition MemoryStorage__lastIndex : val :=
  rec: "MemoryStorage__lastIndex" "ms" <> :=
    exception_do (let: "ms" := (ref_ty ptrT "ms") in
    return: (((![uint64T] (struct.field_ref raftpb.Entry "Index" (slice.elem_ref raftpb.Entry (![sliceT raftpb.Entry] (struct.field_ref MemoryStorage "ents" (![ptrT] "ms"))) #(W64 0)))) + (let: "$a0" := (![sliceT raftpb.Entry] (struct.field_ref MemoryStorage "ents" (![ptrT] "ms"))) in
     slice.len "$a0")) - #(W64 1))).

(* go: storage.go:193:26 *)
Definition MemoryStorage__firstIndex : val :=
  rec: "MemoryStorage__firstIndex" "ms" <> :=
    exception_do (let: "ms" := (ref_ty ptrT "ms") in
    return: ((![uint64T] (struct.field_ref raftpb.Entry "Index" (slice.elem_ref raftpb.Entry (![sliceT raftpb.Entry] (struct.field_ref MemoryStorage "ents" (![ptrT] "ms"))) #(W64 0)))) + #(W64 1))).

(* Append the new entries to storage.
   TODO (xiangli): ensure the entries are continuous and
   entries[0].Index > ms.entries[0].Index

   go: storage.go:277:26 *)
Definition MemoryStorage__Append : val :=
  rec: "MemoryStorage__Append" "ms" "entries" :=
    with_defer: (let: "ms" := (ref_ty ptrT "ms") in
    let: "entries" := (ref_ty (sliceT raftpb.Entry) "entries") in
    (if: (let: "$a0" := (![sliceT raftpb.Entry] "entries") in
    slice.len "$a0") = #(W64 0)
    then return: (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
    else do:  #());;;
    do:  ((sync.Mutex__Lock (struct.field_ref MemoryStorage "Mutex" (![ptrT] "ms"))) #());;;
    do:  (let: "$f" := (sync.Mutex__Unlock (struct.field_ref MemoryStorage "Mutex" (![ptrT] "ms"))) in
    "$defer" <-[funcT] (let: "$oldf" := (![funcT] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    let: "first" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := ((MemoryStorage__firstIndex (![ptrT] "ms")) #()) in
    do:  ("first" <-[uint64T] "$r0");;;
    let: "last" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (((![uint64T] (struct.field_ref raftpb.Entry "Index" (slice.elem_ref raftpb.Entry (![sliceT raftpb.Entry] "entries") #(W64 0)))) + (let: "$a0" := (![sliceT raftpb.Entry] "entries") in
    slice.len "$a0")) - #(W64 1)) in
    do:  ("last" <-[uint64T] "$r0");;;
    (if: (![uint64T] "last") < (![uint64T] "first")
    then return: (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
    else do:  #());;;
    (if: (![uint64T] "first") > (![uint64T] (struct.field_ref raftpb.Entry "Index" (slice.elem_ref raftpb.Entry (![sliceT raftpb.Entry] "entries") #(W64 0))))
    then
      let: "$r0" := (let: "$s" := (![sliceT raftpb.Entry] "entries") in
      slice.slice raftpb.Entry "$s" ((![uint64T] "first") - (![uint64T] (struct.field_ref raftpb.Entry "Index" (slice.elem_ref raftpb.Entry (![sliceT raftpb.Entry] "entries") #(W64 0))))) (slice.len "$s")) in
      do:  ("entries" <-[sliceT raftpb.Entry] "$r0")
    else do:  #());;;
    let: "offset" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := ((![uint64T] (struct.field_ref raftpb.Entry "Index" (slice.elem_ref raftpb.Entry (![sliceT raftpb.Entry] "entries") #(W64 0)))) - (![uint64T] (struct.field_ref raftpb.Entry "Index" (slice.elem_ref raftpb.Entry (![sliceT raftpb.Entry] (struct.field_ref MemoryStorage "ents" (![ptrT] "ms"))) #(W64 0))))) in
    do:  ("offset" <-[uint64T] "$r0");;;
    let: "$sw" := #true in
    (if: "$sw" = ((let: "$a0" := (![sliceT raftpb.Entry] (struct.field_ref MemoryStorage "ents" (![ptrT] "ms"))) in
    slice.len "$a0") > (![uint64T] "offset"))
    then
      let: "$r0" := (let: "$a0" := (let: "$s" := (![sliceT raftpb.Entry] (struct.field_ref MemoryStorage "ents" (![ptrT] "ms"))) in
      slice.full_slice raftpb.Entry "$s" #(W64 0) (![uint64T] "offset") (![uint64T] "offset")) in
      let: "$a1" := (![sliceT raftpb.Entry] "entries") in
      (slice.append (sliceT raftpb.Entry)) "$a0" "$a1") in
      do:  ((struct.field_ref MemoryStorage "ents" (![ptrT] "ms")) <-[sliceT raftpb.Entry] "$r0")
    else
      (if: "$sw" = ((let: "$a0" := (![sliceT raftpb.Entry] (struct.field_ref MemoryStorage "ents" (![ptrT] "ms"))) in
      slice.len "$a0") = (![uint64T] "offset"))
      then
        let: "$r0" := (let: "$a0" := (![sliceT raftpb.Entry] (struct.field_ref MemoryStorage "ents" (![ptrT] "ms"))) in
        let: "$a1" := (![sliceT raftpb.Entry] "entries") in
        (slice.append (sliceT raftpb.Entry)) "$a0" "$a1") in
        do:  ((struct.field_ref MemoryStorage "ents" (![ptrT] "ms")) <-[sliceT raftpb.Entry] "$r0")
      else
        do:  (let: "$a0" := #(str "missing log entry [last: %d, append at: %d]") in
        let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset ((MemoryStorage__lastIndex (![ptrT] "ms")) #())) in
        let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Entry "Index" (slice.elem_ref raftpb.Entry (![sliceT raftpb.Entry] "entries") #(W64 0))))) in
        slice.literal interfaceT ["$sl0"; "$sl1"])) in
        (interface.get "Panicf" (getLogger #())) "$a0" "$a1")));;;
    return: (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)).

(* ApplySnapshot overwrites the contents of this Storage object with
   those of the given snapshot.

   go: storage.go:207:26 *)
Definition MemoryStorage__ApplySnapshot : val :=
  rec: "MemoryStorage__ApplySnapshot" "ms" "snap" :=
    with_defer: (let: "ms" := (ref_ty ptrT "ms") in
    let: "snap" := (ref_ty raftpb.Snapshot "snap") in
    do:  ((sync.Mutex__Lock (struct.field_ref MemoryStorage "Mutex" (![ptrT] "ms"))) #());;;
    do:  (let: "$f" := (sync.Mutex__Unlock (struct.field_ref MemoryStorage "Mutex" (![ptrT] "ms"))) in
    "$defer" <-[funcT] (let: "$oldf" := (![funcT] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    let: "msIndex" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (![uint64T] (struct.field_ref raftpb.SnapshotMetadata "Index" (struct.field_ref raftpb.Snapshot "Metadata" (struct.field_ref MemoryStorage "snapshot" (![ptrT] "ms"))))) in
    do:  ("msIndex" <-[uint64T] "$r0");;;
    let: "snapIndex" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (![uint64T] (struct.field_ref raftpb.SnapshotMetadata "Index" (struct.field_ref raftpb.Snapshot "Metadata" "snap"))) in
    do:  ("snapIndex" <-[uint64T] "$r0");;;
    (if: (![uint64T] "msIndex") ≥ (![uint64T] "snapIndex")
    then return: (![error] "ErrSnapOutOfDate")
    else do:  #());;;
    let: "$r0" := (![raftpb.Snapshot] "snap") in
    do:  ((struct.field_ref MemoryStorage "snapshot" (![ptrT] "ms")) <-[raftpb.Snapshot] "$r0");;;
    let: "$r0" := ((let: "$sl0" := (struct.make raftpb.Entry [{
      "Term" ::= ![uint64T] (struct.field_ref raftpb.SnapshotMetadata "Term" (struct.field_ref raftpb.Snapshot "Metadata" "snap"));
      "Index" ::= ![uint64T] (struct.field_ref raftpb.SnapshotMetadata "Index" (struct.field_ref raftpb.Snapshot "Metadata" "snap"))
    }]) in
    slice.literal raftpb.Entry ["$sl0"])) in
    do:  ((struct.field_ref MemoryStorage "ents" (![ptrT] "ms")) <-[sliceT raftpb.Entry] "$r0");;;
    return: (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)).

(* Compact discards all log entries prior to compactIndex.
   It is the application's responsibility to not attempt to compact an index
   greater than raftLog.applied.

   go: storage.go:251:26 *)
Definition MemoryStorage__Compact : val :=
  rec: "MemoryStorage__Compact" "ms" "compactIndex" :=
    with_defer: (let: "ms" := (ref_ty ptrT "ms") in
    let: "compactIndex" := (ref_ty uint64T "compactIndex") in
    do:  ((sync.Mutex__Lock (struct.field_ref MemoryStorage "Mutex" (![ptrT] "ms"))) #());;;
    do:  (let: "$f" := (sync.Mutex__Unlock (struct.field_ref MemoryStorage "Mutex" (![ptrT] "ms"))) in
    "$defer" <-[funcT] (let: "$oldf" := (![funcT] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    let: "offset" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (![uint64T] (struct.field_ref raftpb.Entry "Index" (slice.elem_ref raftpb.Entry (![sliceT raftpb.Entry] (struct.field_ref MemoryStorage "ents" (![ptrT] "ms"))) #(W64 0)))) in
    do:  ("offset" <-[uint64T] "$r0");;;
    (if: (![uint64T] "compactIndex") ≤ (![uint64T] "offset")
    then return: (![error] "ErrCompacted")
    else do:  #());;;
    (if: (![uint64T] "compactIndex") > ((MemoryStorage__lastIndex (![ptrT] "ms")) #())
    then
      do:  (let: "$a0" := #(str "compact %d is out of bound lastindex(%d)") in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] "compactIndex")) in
      let: "$sl1" := (interface.make uint64__mset ((MemoryStorage__lastIndex (![ptrT] "ms")) #())) in
      slice.literal interfaceT ["$sl0"; "$sl1"])) in
      (interface.get "Panicf" (getLogger #())) "$a0" "$a1")
    else do:  #());;;
    let: "i" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := ((![uint64T] "compactIndex") - (![uint64T] "offset")) in
    do:  ("i" <-[uint64T] "$r0");;;
    let: "ents" := (ref_ty (sliceT raftpb.Entry) (zero_val (sliceT raftpb.Entry))) in
    let: "$r0" := (slice.make3 raftpb.Entry #(W64 1) ((let: "$a0" := (![sliceT raftpb.Entry] (struct.field_ref MemoryStorage "ents" (![ptrT] "ms"))) in
    slice.len "$a0") - (![uint64T] "i"))) in
    do:  ("ents" <-[sliceT raftpb.Entry] "$r0");;;
    let: "$r0" := (![uint64T] (struct.field_ref raftpb.Entry "Index" (slice.elem_ref raftpb.Entry (![sliceT raftpb.Entry] (struct.field_ref MemoryStorage "ents" (![ptrT] "ms"))) (![uint64T] "i")))) in
    do:  ((struct.field_ref raftpb.Entry "Index" (slice.elem_ref raftpb.Entry (![sliceT raftpb.Entry] "ents") #(W64 0))) <-[uint64T] "$r0");;;
    let: "$r0" := (![uint64T] (struct.field_ref raftpb.Entry "Term" (slice.elem_ref raftpb.Entry (![sliceT raftpb.Entry] (struct.field_ref MemoryStorage "ents" (![ptrT] "ms"))) (![uint64T] "i")))) in
    do:  ((struct.field_ref raftpb.Entry "Term" (slice.elem_ref raftpb.Entry (![sliceT raftpb.Entry] "ents") #(W64 0))) <-[uint64T] "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT raftpb.Entry] "ents") in
    let: "$a1" := (let: "$s" := (![sliceT raftpb.Entry] (struct.field_ref MemoryStorage "ents" (![ptrT] "ms"))) in
    slice.slice raftpb.Entry "$s" ((![uint64T] "i") + #(W64 1)) (slice.len "$s")) in
    (slice.append (sliceT raftpb.Entry)) "$a0" "$a1") in
    do:  ("ents" <-[sliceT raftpb.Entry] "$r0");;;
    let: "$r0" := (![sliceT raftpb.Entry] "ents") in
    do:  ((struct.field_ref MemoryStorage "ents" (![ptrT] "ms")) <-[sliceT raftpb.Entry] "$r0");;;
    return: (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)).

(* CreateSnapshot makes a snapshot which can be retrieved with Snapshot() and
   can be used to reconstruct the state at that point.
   If any configuration changes have been made since the last compaction,
   the result of the last ApplyConfChange must be passed in.

   go: storage.go:227:26 *)
Definition MemoryStorage__CreateSnapshot : val :=
  rec: "MemoryStorage__CreateSnapshot" "ms" "i" "cs" "data" :=
    with_defer: (let: "ms" := (ref_ty ptrT "ms") in
    let: "data" := (ref_ty (sliceT byteT) "data") in
    let: "cs" := (ref_ty ptrT "cs") in
    let: "i" := (ref_ty uint64T "i") in
    do:  ((sync.Mutex__Lock (struct.field_ref MemoryStorage "Mutex" (![ptrT] "ms"))) #());;;
    do:  (let: "$f" := (sync.Mutex__Unlock (struct.field_ref MemoryStorage "Mutex" (![ptrT] "ms"))) in
    "$defer" <-[funcT] (let: "$oldf" := (![funcT] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    (if: (![uint64T] "i") ≤ (![uint64T] (struct.field_ref raftpb.SnapshotMetadata "Index" (struct.field_ref raftpb.Snapshot "Metadata" (struct.field_ref MemoryStorage "snapshot" (![ptrT] "ms")))))
    then
      return: (struct.make raftpb.Snapshot [{
       }], ![error] "ErrSnapOutOfDate")
    else do:  #());;;
    let: "offset" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (![uint64T] (struct.field_ref raftpb.Entry "Index" (slice.elem_ref raftpb.Entry (![sliceT raftpb.Entry] (struct.field_ref MemoryStorage "ents" (![ptrT] "ms"))) #(W64 0)))) in
    do:  ("offset" <-[uint64T] "$r0");;;
    (if: (![uint64T] "i") > ((MemoryStorage__lastIndex (![ptrT] "ms")) #())
    then
      do:  (let: "$a0" := #(str "snapshot %d is out of bound lastindex(%d)") in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] "i")) in
      let: "$sl1" := (interface.make uint64__mset ((MemoryStorage__lastIndex (![ptrT] "ms")) #())) in
      slice.literal interfaceT ["$sl0"; "$sl1"])) in
      (interface.get "Panicf" (getLogger #())) "$a0" "$a1")
    else do:  #());;;
    let: "$r0" := (![uint64T] "i") in
    do:  ((struct.field_ref raftpb.SnapshotMetadata "Index" (struct.field_ref raftpb.Snapshot "Metadata" (struct.field_ref MemoryStorage "snapshot" (![ptrT] "ms")))) <-[uint64T] "$r0");;;
    let: "$r0" := (![uint64T] (struct.field_ref raftpb.Entry "Term" (slice.elem_ref raftpb.Entry (![sliceT raftpb.Entry] (struct.field_ref MemoryStorage "ents" (![ptrT] "ms"))) ((![uint64T] "i") - (![uint64T] "offset"))))) in
    do:  ((struct.field_ref raftpb.SnapshotMetadata "Term" (struct.field_ref raftpb.Snapshot "Metadata" (struct.field_ref MemoryStorage "snapshot" (![ptrT] "ms")))) <-[uint64T] "$r0");;;
    (if: (![ptrT] "cs") ≠ #null
    then
      let: "$r0" := (![raftpb.ConfState] (![ptrT] "cs")) in
      do:  ((struct.field_ref raftpb.SnapshotMetadata "ConfState" (struct.field_ref raftpb.Snapshot "Metadata" (struct.field_ref MemoryStorage "snapshot" (![ptrT] "ms")))) <-[raftpb.ConfState] "$r0")
    else do:  #());;;
    let: "$r0" := (![sliceT byteT] "data") in
    do:  ((struct.field_ref raftpb.Snapshot "Data" (struct.field_ref MemoryStorage "snapshot" (![ptrT] "ms"))) <-[sliceT byteT] "$r0");;;
    return: (![raftpb.Snapshot] (struct.field_ref MemoryStorage "snapshot" (![ptrT] "ms")), interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)).

(* Entries implements the Storage interface.

   go: storage.go:135:26 *)
Definition MemoryStorage__Entries : val :=
  rec: "MemoryStorage__Entries" "ms" "lo" "hi" "maxSize" :=
    with_defer: (let: "ms" := (ref_ty ptrT "ms") in
    let: "maxSize" := (ref_ty uint64T "maxSize") in
    let: "hi" := (ref_ty uint64T "hi") in
    let: "lo" := (ref_ty uint64T "lo") in
    do:  ((sync.Mutex__Lock (struct.field_ref MemoryStorage "Mutex" (![ptrT] "ms"))) #());;;
    do:  (let: "$f" := (sync.Mutex__Unlock (struct.field_ref MemoryStorage "Mutex" (![ptrT] "ms"))) in
    "$defer" <-[funcT] (let: "$oldf" := (![funcT] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    do:  ((struct.field_ref inMemStorageCallStats "entries" (struct.field_ref MemoryStorage "callStats" (![ptrT] "ms"))) <-[intT] ((![intT] (struct.field_ref inMemStorageCallStats "entries" (struct.field_ref MemoryStorage "callStats" (![ptrT] "ms")))) + #(W64 1)));;;
    let: "offset" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (![uint64T] (struct.field_ref raftpb.Entry "Index" (slice.elem_ref raftpb.Entry (![sliceT raftpb.Entry] (struct.field_ref MemoryStorage "ents" (![ptrT] "ms"))) #(W64 0)))) in
    do:  ("offset" <-[uint64T] "$r0");;;
    (if: (![uint64T] "lo") ≤ (![uint64T] "offset")
    then return: (slice.nil, ![error] "ErrCompacted")
    else do:  #());;;
    (if: (![uint64T] "hi") > (((MemoryStorage__lastIndex (![ptrT] "ms")) #()) + #(W64 1))
    then
      do:  (let: "$a0" := #(str "entries' hi(%d) is out of bound lastindex(%d)") in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] "hi")) in
      let: "$sl1" := (interface.make uint64__mset ((MemoryStorage__lastIndex (![ptrT] "ms")) #())) in
      slice.literal interfaceT ["$sl0"; "$sl1"])) in
      (interface.get "Panicf" (getLogger #())) "$a0" "$a1")
    else do:  #());;;
    (if: (let: "$a0" := (![sliceT raftpb.Entry] (struct.field_ref MemoryStorage "ents" (![ptrT] "ms"))) in
    slice.len "$a0") = #(W64 1)
    then return: (slice.nil, ![error] "ErrUnavailable")
    else do:  #());;;
    let: "ents" := (ref_ty (sliceT raftpb.Entry) (zero_val (sliceT raftpb.Entry))) in
    let: "$r0" := (let: "$a0" := (let: "$s" := (![sliceT raftpb.Entry] (struct.field_ref MemoryStorage "ents" (![ptrT] "ms"))) in
    slice.slice raftpb.Entry "$s" ((![uint64T] "lo") - (![uint64T] "offset")) ((![uint64T] "hi") - (![uint64T] "offset"))) in
    let: "$a1" := (![uint64T] "maxSize") in
    limitSize "$a0" "$a1") in
    do:  ("ents" <-[sliceT raftpb.Entry] "$r0");;;
    return: (let: "$s" := (![sliceT raftpb.Entry] "ents") in
     slice.full_slice raftpb.Entry "$s" #(W64 0) (let: "$a0" := (![sliceT raftpb.Entry] "ents") in
     slice.len "$a0") (let: "$a0" := (![sliceT raftpb.Entry] "ents") in
     slice.len "$a0"), interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)).

(* FirstIndex implements the Storage interface.

   go: storage.go:186:26 *)
Definition MemoryStorage__FirstIndex : val :=
  rec: "MemoryStorage__FirstIndex" "ms" <> :=
    with_defer: (let: "ms" := (ref_ty ptrT "ms") in
    do:  ((sync.Mutex__Lock (struct.field_ref MemoryStorage "Mutex" (![ptrT] "ms"))) #());;;
    do:  (let: "$f" := (sync.Mutex__Unlock (struct.field_ref MemoryStorage "Mutex" (![ptrT] "ms"))) in
    "$defer" <-[funcT] (let: "$oldf" := (![funcT] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    do:  ((struct.field_ref inMemStorageCallStats "firstIndex" (struct.field_ref MemoryStorage "callStats" (![ptrT] "ms"))) <-[intT] ((![intT] (struct.field_ref inMemStorageCallStats "firstIndex" (struct.field_ref MemoryStorage "callStats" (![ptrT] "ms")))) + #(W64 1)));;;
    return: ((MemoryStorage__firstIndex (![ptrT] "ms")) #(), interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)).

(* InitialState implements the Storage interface.

   go: storage.go:121:26 *)
Definition MemoryStorage__InitialState : val :=
  rec: "MemoryStorage__InitialState" "ms" <> :=
    exception_do (let: "ms" := (ref_ty ptrT "ms") in
    do:  ((struct.field_ref inMemStorageCallStats "initialState" (struct.field_ref MemoryStorage "callStats" (![ptrT] "ms"))) <-[intT] ((![intT] (struct.field_ref inMemStorageCallStats "initialState" (struct.field_ref MemoryStorage "callStats" (![ptrT] "ms")))) + #(W64 1)));;;
    return: (![raftpb.HardState] (struct.field_ref MemoryStorage "hardState" (![ptrT] "ms")), ![raftpb.ConfState] (struct.field_ref raftpb.SnapshotMetadata "ConfState" (struct.field_ref raftpb.Snapshot "Metadata" (struct.field_ref MemoryStorage "snapshot" (![ptrT] "ms")))), interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)).

(* LastIndex implements the Storage interface.

   go: storage.go:174:26 *)
Definition MemoryStorage__LastIndex : val :=
  rec: "MemoryStorage__LastIndex" "ms" <> :=
    with_defer: (let: "ms" := (ref_ty ptrT "ms") in
    do:  ((sync.Mutex__Lock (struct.field_ref MemoryStorage "Mutex" (![ptrT] "ms"))) #());;;
    do:  (let: "$f" := (sync.Mutex__Unlock (struct.field_ref MemoryStorage "Mutex" (![ptrT] "ms"))) in
    "$defer" <-[funcT] (let: "$oldf" := (![funcT] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    do:  ((struct.field_ref inMemStorageCallStats "lastIndex" (struct.field_ref MemoryStorage "callStats" (![ptrT] "ms"))) <-[intT] ((![intT] (struct.field_ref inMemStorageCallStats "lastIndex" (struct.field_ref MemoryStorage "callStats" (![ptrT] "ms")))) + #(W64 1)));;;
    return: ((MemoryStorage__lastIndex (![ptrT] "ms")) #(), interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)).

(* SetHardState saves the current HardState.

   go: storage.go:127:26 *)
Definition MemoryStorage__SetHardState : val :=
  rec: "MemoryStorage__SetHardState" "ms" "st" :=
    with_defer: (let: "ms" := (ref_ty ptrT "ms") in
    let: "st" := (ref_ty raftpb.HardState "st") in
    do:  ((sync.Mutex__Lock (struct.field_ref MemoryStorage "Mutex" (![ptrT] "ms"))) #());;;
    do:  (let: "$f" := (sync.Mutex__Unlock (struct.field_ref MemoryStorage "Mutex" (![ptrT] "ms"))) in
    "$defer" <-[funcT] (let: "$oldf" := (![funcT] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    let: "$r0" := (![raftpb.HardState] "st") in
    do:  ((struct.field_ref MemoryStorage "hardState" (![ptrT] "ms")) <-[raftpb.HardState] "$r0");;;
    return: (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)).

(* Snapshot implements the Storage interface.

   go: storage.go:198:26 *)
Definition MemoryStorage__Snapshot : val :=
  rec: "MemoryStorage__Snapshot" "ms" <> :=
    with_defer: (let: "ms" := (ref_ty ptrT "ms") in
    do:  ((sync.Mutex__Lock (struct.field_ref MemoryStorage "Mutex" (![ptrT] "ms"))) #());;;
    do:  (let: "$f" := (sync.Mutex__Unlock (struct.field_ref MemoryStorage "Mutex" (![ptrT] "ms"))) in
    "$defer" <-[funcT] (let: "$oldf" := (![funcT] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    do:  ((struct.field_ref inMemStorageCallStats "snapshot" (struct.field_ref MemoryStorage "callStats" (![ptrT] "ms"))) <-[intT] ((![intT] (struct.field_ref inMemStorageCallStats "snapshot" (struct.field_ref MemoryStorage "callStats" (![ptrT] "ms")))) + #(W64 1)));;;
    return: (![raftpb.Snapshot] (struct.field_ref MemoryStorage "snapshot" (![ptrT] "ms")), interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)).

(* Term implements the Storage interface.

   go: storage.go:159:26 *)
Definition MemoryStorage__Term : val :=
  rec: "MemoryStorage__Term" "ms" "i" :=
    with_defer: (let: "ms" := (ref_ty ptrT "ms") in
    let: "i" := (ref_ty uint64T "i") in
    do:  ((sync.Mutex__Lock (struct.field_ref MemoryStorage "Mutex" (![ptrT] "ms"))) #());;;
    do:  (let: "$f" := (sync.Mutex__Unlock (struct.field_ref MemoryStorage "Mutex" (![ptrT] "ms"))) in
    "$defer" <-[funcT] (let: "$oldf" := (![funcT] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    do:  ((struct.field_ref inMemStorageCallStats "term" (struct.field_ref MemoryStorage "callStats" (![ptrT] "ms"))) <-[intT] ((![intT] (struct.field_ref inMemStorageCallStats "term" (struct.field_ref MemoryStorage "callStats" (![ptrT] "ms")))) + #(W64 1)));;;
    let: "offset" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (![uint64T] (struct.field_ref raftpb.Entry "Index" (slice.elem_ref raftpb.Entry (![sliceT raftpb.Entry] (struct.field_ref MemoryStorage "ents" (![ptrT] "ms"))) #(W64 0)))) in
    do:  ("offset" <-[uint64T] "$r0");;;
    (if: (![uint64T] "i") < (![uint64T] "offset")
    then return: (#(W64 0), ![error] "ErrCompacted")
    else do:  #());;;
    (if: int_geq ((![uint64T] "i") - (![uint64T] "offset")) (let: "$a0" := (![sliceT raftpb.Entry] (struct.field_ref MemoryStorage "ents" (![ptrT] "ms"))) in
    slice.len "$a0")
    then return: (#(W64 0), ![error] "ErrUnavailable")
    else do:  #());;;
    return: (![uint64T] (struct.field_ref raftpb.Entry "Term" (slice.elem_ref raftpb.Entry (![sliceT raftpb.Entry] (struct.field_ref MemoryStorage "ents" (![ptrT] "ms"))) ((![uint64T] "i") - (![uint64T] "offset")))), interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)).

Definition MemoryStorage__mset_ptr : list (string * val) := [
  ("Append", MemoryStorage__Append%V);
  ("ApplySnapshot", MemoryStorage__ApplySnapshot%V);
  ("Compact", MemoryStorage__Compact%V);
  ("CreateSnapshot", MemoryStorage__CreateSnapshot%V);
  ("Entries", MemoryStorage__Entries%V);
  ("FirstIndex", MemoryStorage__FirstIndex%V);
  ("InitialState", MemoryStorage__InitialState%V);
  ("LastIndex", MemoryStorage__LastIndex%V);
  ("Lock", (λ: "$recvAddr",
    sync.Mutex__Lock (struct.field_ref MemoryStorage "Mutex" "$recvAddr")
    )%V);
  ("SetHardState", MemoryStorage__SetHardState%V);
  ("Snapshot", MemoryStorage__Snapshot%V);
  ("Term", MemoryStorage__Term%V);
  ("TryLock", (λ: "$recvAddr",
    sync.Mutex__TryLock (struct.field_ref MemoryStorage "Mutex" "$recvAddr")
    )%V);
  ("Unlock", (λ: "$recvAddr",
    sync.Mutex__Unlock (struct.field_ref MemoryStorage "Mutex" "$recvAddr")
    )%V);
  ("firstIndex", MemoryStorage__firstIndex%V);
  ("lastIndex", MemoryStorage__lastIndex%V);
  ("lockSlow", (λ: "$recvAddr",
    sync.Mutex__lockSlow (struct.field_ref MemoryStorage "Mutex" "$recvAddr")
    )%V);
  ("unlockSlow", (λ: "$recvAddr",
    sync.Mutex__unlockSlow (struct.field_ref MemoryStorage "Mutex" "$recvAddr")
    )%V)
].

(* NewMemoryStorage creates an empty MemoryStorage.

   go: storage.go:113:6 *)
Definition NewMemoryStorage : val :=
  rec: "NewMemoryStorage" <> :=
    exception_do (return: (ref_ty MemoryStorage (struct.make MemoryStorage [{
       "ents" ::= slice.make2 raftpb.Entry #(W64 1)
     }]))).

Definition entryID__mset : list (string * val) := [
].

Definition entryID__mset_ptr : list (string * val) := [
].

(* lastEntryID returns the ID of the last entry in this log slice, or prev if
   there are no entries.

   go: types.go:84:19 *)
Definition logSlice__lastEntryID : val :=
  rec: "logSlice__lastEntryID" "s" <> :=
    exception_do (let: "s" := (ref_ty logSlice "s") in
    (let: "ln" := (ref_ty intT (zero_val intT)) in
    let: "$r0" := (let: "$a0" := (![sliceT raftpb.Entry] (struct.field_ref logSlice "entries" "s")) in
    slice.len "$a0") in
    do:  ("ln" <-[intT] "$r0");;;
    (if: (![intT] "ln") ≠ #(W64 0)
    then
      return: (let: "$a0" := (slice.elem_ref raftpb.Entry (![sliceT raftpb.Entry] (struct.field_ref logSlice "entries" "s")) ((![intT] "ln") - #(W64 1))) in
       pbEntryID "$a0")
    else do:  #()));;;
    return: (![entryID] (struct.field_ref logSlice "prev" "s"))).

(* lastIndex returns the index of the last entry in this log slice. Returns
   prev.index if there are no entries.

   go: types.go:78:19 *)
Definition logSlice__lastIndex : val :=
  rec: "logSlice__lastIndex" "s" <> :=
    exception_do (let: "s" := (ref_ty logSlice "s") in
    return: ((![uint64T] (struct.field_ref entryID "index" (struct.field_ref logSlice "prev" "s"))) + (let: "$a0" := (![sliceT raftpb.Entry] (struct.field_ref logSlice "entries" "s")) in
     slice.len "$a0"))).

(* valid returns nil iff the logSlice is a well-formed log slice. See logSlice
   comment for details on what constitutes a valid raft log slice.

   go: types.go:93:19 *)
Definition logSlice__valid : val :=
  rec: "logSlice__valid" "s" <> :=
    exception_do (let: "s" := (ref_ty logSlice "s") in
    let: "prev" := (ref_ty entryID (zero_val entryID)) in
    let: "$r0" := (![entryID] (struct.field_ref logSlice "prev" "s")) in
    do:  ("prev" <-[entryID] "$r0");;;
    do:  (let: "$range" := (![sliceT raftpb.Entry] (struct.field_ref logSlice "entries" "s")) in
    slice.for_range raftpb.Entry "$range" (λ: "i" <>,
      let: "i" := ref_ty uint64T "i" in
      let: "id" := (ref_ty entryID (zero_val entryID)) in
      let: "$r0" := (let: "$a0" := (slice.elem_ref raftpb.Entry (![sliceT raftpb.Entry] (struct.field_ref logSlice "entries" "s")) (![intT] "i")) in
      pbEntryID "$a0") in
      do:  ("id" <-[entryID] "$r0");;;
      (if: ((![uint64T] (struct.field_ref entryID "term" "id")) < (![uint64T] (struct.field_ref entryID "term" "prev"))) || ((![uint64T] (struct.field_ref entryID "index" "id")) ≠ ((![uint64T] (struct.field_ref entryID "index" "prev")) + #(W64 1)))
      then
        return: (let: "$a0" := #(str "leader term %d: entries %+v and %+v not consistent") in
         let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref logSlice "term" "s"))) in
         let: "$sl1" := (interface.make entryID__mset (![entryID] "prev")) in
         let: "$sl2" := (interface.make entryID__mset (![entryID] "id")) in
         slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
         fmt.Errorf "$a0" "$a1")
      else do:  #());;;
      let: "$r0" := (![entryID] "id") in
      do:  ("prev" <-[entryID] "$r0")));;;
    (if: (![uint64T] (struct.field_ref logSlice "term" "s")) < (![uint64T] (struct.field_ref entryID "term" "prev"))
    then
      return: (let: "$a0" := #(str "leader term %d: entry %+v has a newer term") in
       let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref logSlice "term" "s"))) in
       let: "$sl1" := (interface.make entryID__mset (![entryID] "prev")) in
       slice.literal interfaceT ["$sl0"; "$sl1"])) in
       fmt.Errorf "$a0" "$a1")
    else do:  #());;;
    return: (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)).

Definition logSlice__mset : list (string * val) := [
  ("lastEntryID", logSlice__lastEntryID%V);
  ("lastIndex", logSlice__lastIndex%V);
  ("valid", logSlice__valid%V)
].

Definition logSlice__mset_ptr : list (string * val) := [
  ("lastEntryID", (λ: "$recvAddr",
    logSlice__lastEntryID (![logSlice] "$recvAddr")
    )%V);
  ("lastIndex", (λ: "$recvAddr",
    logSlice__lastIndex (![logSlice] "$recvAddr")
    )%V);
  ("valid", (λ: "$recvAddr",
    logSlice__valid (![logSlice] "$recvAddr")
    )%V)
].

(* go: util.go:81:6 *)
Definition DescribeHardState : val :=
  rec: "DescribeHardState" "hs" :=
    exception_do (let: "hs" := (ref_ty raftpb.HardState "hs") in
    let: "buf" := (ref_ty strings.Builder (zero_val strings.Builder)) in
    do:  (let: "$a0" := (interface.make strings.Builder__mset_ptr "buf") in
    let: "$a1" := #(str "Term:%d") in
    let: "$a2" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.HardState "Term" "hs"))) in
    slice.literal interfaceT ["$sl0"])) in
    fmt.Fprintf "$a0" "$a1" "$a2");;;
    (if: (![uint64T] (struct.field_ref raftpb.HardState "Vote" "hs")) ≠ #(W64 0)
    then
      do:  (let: "$a0" := (interface.make strings.Builder__mset_ptr "buf") in
      let: "$a1" := #(str " Vote:%d") in
      let: "$a2" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.HardState "Vote" "hs"))) in
      slice.literal interfaceT ["$sl0"])) in
      fmt.Fprintf "$a0" "$a1" "$a2")
    else do:  #());;;
    do:  (let: "$a0" := (interface.make strings.Builder__mset_ptr "buf") in
    let: "$a1" := #(str " Commit:%d") in
    let: "$a2" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.HardState "Commit" "hs"))) in
    slice.literal interfaceT ["$sl0"])) in
    fmt.Fprintf "$a0" "$a1" "$a2");;;
    return: ((strings.Builder__String "buf") #())).

(* go: util.go:91:6 *)
Definition DescribeSoftState : val :=
  rec: "DescribeSoftState" "ss" :=
    exception_do (let: "ss" := (ref_ty SoftState "ss") in
    return: (let: "$a0" := #(str "Lead:%d State:%s") in
     let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref SoftState "Lead" "ss"))) in
     let: "$sl1" := (interface.make StateType__mset (![StateType] (struct.field_ref SoftState "RaftState" "ss"))) in
     slice.literal interfaceT ["$sl0"; "$sl1"])) in
     fmt.Sprintf "$a0" "$a1")).

(* go: util.go:95:6 *)
Definition DescribeConfState : val :=
  rec: "DescribeConfState" "state" :=
    exception_do (let: "state" := (ref_ty raftpb.ConfState "state") in
    return: (let: "$a0" := #(str "Voters:%v VotersOutgoing:%v Learners:%v LearnersNext:%v AutoLeave:%v") in
     let: "$a1" := ((let: "$sl0" := (interface.make slice__mset (![sliceT uint64T] (struct.field_ref raftpb.ConfState "Voters" "state"))) in
     let: "$sl1" := (interface.make slice__mset (![sliceT uint64T] (struct.field_ref raftpb.ConfState "VotersOutgoing" "state"))) in
     let: "$sl2" := (interface.make slice__mset (![sliceT uint64T] (struct.field_ref raftpb.ConfState "Learners" "state"))) in
     let: "$sl3" := (interface.make slice__mset (![sliceT uint64T] (struct.field_ref raftpb.ConfState "LearnersNext" "state"))) in
     let: "$sl4" := (interface.make bool__mset (![boolT] (struct.field_ref raftpb.ConfState "AutoLeave" "state"))) in
     slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"; "$sl4"])) in
     fmt.Sprintf "$a0" "$a1")).

(* go: util.go:102:6 *)
Definition DescribeSnapshot : val :=
  rec: "DescribeSnapshot" "snap" :=
    exception_do (let: "snap" := (ref_ty raftpb.Snapshot "snap") in
    let: "m" := (ref_ty raftpb.SnapshotMetadata (zero_val raftpb.SnapshotMetadata)) in
    let: "$r0" := (![raftpb.SnapshotMetadata] (struct.field_ref raftpb.Snapshot "Metadata" "snap")) in
    do:  ("m" <-[raftpb.SnapshotMetadata] "$r0");;;
    return: (let: "$a0" := #(str "Index:%d Term:%d ConfState:%s") in
     let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.SnapshotMetadata "Index" "m"))) in
     let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.SnapshotMetadata "Term" "m"))) in
     let: "$sl2" := (interface.make string__mset (let: "$a0" := (![raftpb.ConfState] (struct.field_ref raftpb.SnapshotMetadata "ConfState" "m")) in
     DescribeConfState "$a0")) in
     slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
     fmt.Sprintf "$a0" "$a1")).

Definition EntryFormatter : go_type := funcT.

(* DescribeEntry returns a concise human-readable description of an
   Entry for debugging.

   go: util.go:206:6 *)
Definition DescribeEntry : val :=
  rec: "DescribeEntry" "e" "f" :=
    exception_do (let: "f" := (ref_ty EntryFormatter "f") in
    let: "e" := (ref_ty raftpb.Entry "e") in
    (if: (![EntryFormatter] "f") = nil
    then
      let: "$r0" := (λ: "data",
        exception_do (let: "data" := (ref_ty (sliceT byteT) "data") in
        return: (let: "$a0" := #(str "%q") in
         let: "$a1" := ((let: "$sl0" := (interface.make slice__mset (![sliceT byteT] "data")) in
         slice.literal interfaceT ["$sl0"])) in
         fmt.Sprintf "$a0" "$a1"))
        ) in
      do:  ("f" <-[EntryFormatter] "$r0")
    else do:  #());;;
    let: "formatConfChange" := (ref_ty funcT (zero_val funcT)) in
    let: "$r0" := (λ: "cc",
      exception_do (let: "cc" := (ref_ty raftpb.ConfChangeI "cc") in
      return: (let: "$a0" := (struct.field_get raftpb.ConfChangeV2 "Changes" ((interface.get "AsV2" (![raftpb.ConfChangeI] "cc")) #())) in
       raftpb.ConfChangesToString "$a0"))
      ) in
    do:  ("formatConfChange" <-[funcT] "$r0");;;
    let: "formatted" := (ref_ty stringT (zero_val stringT)) in
    let: "$sw" := (![raftpb.EntryType] (struct.field_ref raftpb.Entry "Type" "e")) in
    (if: "$sw" = raftpb.EntryNormal
    then
      let: "$r0" := (let: "$a0" := (![sliceT byteT] (struct.field_ref raftpb.Entry "Data" "e")) in
      (![EntryFormatter] "f") "$a0") in
      do:  ("formatted" <-[stringT] "$r0")
    else
      (if: "$sw" = raftpb.EntryConfChange
      then
        let: "cc" := (ref_ty raftpb.ConfChange (zero_val raftpb.ConfChange)) in
        (let: "err" := (ref_ty error (zero_val error)) in
        let: "$r0" := (let: "$a0" := (![sliceT byteT] (struct.field_ref raftpb.Entry "Data" "e")) in
        (raftpb.ConfChange__Unmarshal "cc") "$a0") in
        do:  ("err" <-[error] "$r0");;;
        (if: (![error] "err") ≠ (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
        then
          let: "$r0" := ((interface.get "Error" (![error] "err")) #()) in
          do:  ("formatted" <-[stringT] "$r0")
        else
          let: "$r0" := (let: "$a0" := (interface.make raftpb.ConfChange__mset (![raftpb.ConfChange] "cc")) in
          (![funcT] "formatConfChange") "$a0") in
          do:  ("formatted" <-[stringT] "$r0")))
      else
        (if: "$sw" = raftpb.EntryConfChangeV2
        then
          let: "cc" := (ref_ty raftpb.ConfChangeV2 (zero_val raftpb.ConfChangeV2)) in
          (let: "err" := (ref_ty error (zero_val error)) in
          let: "$r0" := (let: "$a0" := (![sliceT byteT] (struct.field_ref raftpb.Entry "Data" "e")) in
          (raftpb.ConfChangeV2__Unmarshal "cc") "$a0") in
          do:  ("err" <-[error] "$r0");;;
          (if: (![error] "err") ≠ (interface.make untyped nil__mset BUG: this should get overwritten by handleImplicitConversion)
          then
            let: "$r0" := ((interface.get "Error" (![error] "err")) #()) in
            do:  ("formatted" <-[stringT] "$r0")
          else
            let: "$r0" := (let: "$a0" := (interface.make raftpb.ConfChangeV2__mset (![raftpb.ConfChangeV2] "cc")) in
            (![funcT] "formatConfChange") "$a0") in
            do:  ("formatted" <-[stringT] "$r0")))
        else #())));;;
    (if: (![stringT] "formatted") ≠ #(str "")
    then
      let: "$r0" := (#(str " ") + (![stringT] "formatted")) in
      do:  ("formatted" <-[stringT] "$r0")
    else do:  #());;;
    return: (let: "$a0" := #(str "%d/%d %s%s") in
     let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Entry "Term" "e"))) in
     let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Entry "Index" "e"))) in
     let: "$sl2" := (interface.make raftpb.EntryType__mset (![raftpb.EntryType] (struct.field_ref raftpb.Entry "Type" "e"))) in
     let: "$sl3" := (interface.make string__mset (![stringT] "formatted")) in
     slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"])) in
     fmt.Sprintf "$a0" "$a1")).

(* go: util.go:191:6 *)
Definition describeTarget : val :=
  rec: "describeTarget" "id" :=
    exception_do (let: "id" := (ref_ty uint64T "id") in
    let: "$sw" := (![uint64T] "id") in
    (if: "$sw" = None
    then return: (#(str "None"))
    else
      (if: "$sw" = LocalAppendThread
      then return: (#(str "AppendThread"))
      else
        (if: "$sw" = LocalApplyThread
        then return: (#(str "ApplyThread"))
        else
          return: (let: "$a0" := #(str "%x") in
           let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] "id")) in
           slice.literal interfaceT ["$sl0"])) in
           fmt.Sprintf "$a0" "$a1"))))).

(* go: util.go:154:6 *)
Definition describeMessageWithIndent : val :=
  rec: "describeMessageWithIndent" "indent" "m" "f" :=
    exception_do (let: "f" := (ref_ty EntryFormatter "f") in
    let: "m" := (ref_ty raftpb.Message "m") in
    let: "indent" := (ref_ty stringT "indent") in
    let: "buf" := (ref_ty bytes.Buffer (zero_val bytes.Buffer)) in
    do:  (let: "$a0" := (interface.make bytes.Buffer__mset_ptr "buf") in
    let: "$a1" := #(str "%s%s->%s %v Term:%d Log:%d/%d") in
    let: "$a2" := ((let: "$sl0" := (interface.make string__mset (![stringT] "indent")) in
    let: "$sl1" := (interface.make string__mset (let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "From" "m")) in
    describeTarget "$a0")) in
    let: "$sl2" := (interface.make string__mset (let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "To" "m")) in
    describeTarget "$a0")) in
    let: "$sl3" := (interface.make raftpb.MessageType__mset (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m"))) in
    let: "$sl4" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "Term" "m"))) in
    let: "$sl5" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "LogTerm" "m"))) in
    let: "$sl6" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "Index" "m"))) in
    slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"; "$sl4"; "$sl5"; "$sl6"])) in
    fmt.Fprintf "$a0" "$a1" "$a2");;;
    (if: ![boolT] (struct.field_ref raftpb.Message "Reject" "m")
    then
      do:  (let: "$a0" := (interface.make bytes.Buffer__mset_ptr "buf") in
      let: "$a1" := #(str " Rejected (Hint: %d)") in
      let: "$a2" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "RejectHint" "m"))) in
      slice.literal interfaceT ["$sl0"])) in
      fmt.Fprintf "$a0" "$a1" "$a2")
    else do:  #());;;
    (if: (![uint64T] (struct.field_ref raftpb.Message "Commit" "m")) ≠ #(W64 0)
    then
      do:  (let: "$a0" := (interface.make bytes.Buffer__mset_ptr "buf") in
      let: "$a1" := #(str " Commit:%d") in
      let: "$a2" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "Commit" "m"))) in
      slice.literal interfaceT ["$sl0"])) in
      fmt.Fprintf "$a0" "$a1" "$a2")
    else do:  #());;;
    (if: (![uint64T] (struct.field_ref raftpb.Message "Vote" "m")) ≠ #(W64 0)
    then
      do:  (let: "$a0" := (interface.make bytes.Buffer__mset_ptr "buf") in
      let: "$a1" := #(str " Vote:%d") in
      let: "$a2" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "Vote" "m"))) in
      slice.literal interfaceT ["$sl0"])) in
      fmt.Fprintf "$a0" "$a1" "$a2")
    else do:  #());;;
    (let: "ln" := (ref_ty intT (zero_val intT)) in
    let: "$r0" := (let: "$a0" := (![sliceT raftpb.Entry] (struct.field_ref raftpb.Message "Entries" "m")) in
    slice.len "$a0") in
    do:  ("ln" <-[intT] "$r0");;;
    (if: (![intT] "ln") = #(W64 1)
    then
      do:  (let: "$a0" := (interface.make bytes.Buffer__mset_ptr "buf") in
      let: "$a1" := #(str " Entries:[%s]") in
      let: "$a2" := ((let: "$sl0" := (interface.make string__mset (let: "$a0" := (![raftpb.Entry] (slice.elem_ref raftpb.Entry (![sliceT raftpb.Entry] (struct.field_ref raftpb.Message "Entries" "m")) #(W64 0))) in
      let: "$a1" := (![EntryFormatter] "f") in
      DescribeEntry "$a0" "$a1")) in
      slice.literal interfaceT ["$sl0"])) in
      fmt.Fprintf "$a0" "$a1" "$a2")
    else
      (if: int_gt (![intT] "ln") #(W64 1)
      then
        do:  (let: "$a0" := (interface.make bytes.Buffer__mset_ptr "buf") in
        let: "$a1" := ((let: "$sl0" := (interface.make string__mset #(str " Entries:[")) in
        slice.literal interfaceT ["$sl0"])) in
        fmt.Fprint "$a0" "$a1");;;
        do:  (let: "$range" := (![sliceT raftpb.Entry] (struct.field_ref raftpb.Message "Entries" "m")) in
        slice.for_range raftpb.Entry "$range" (λ: <> "e",
          let: "e" := ref_ty raftpb.Entry "e" in
          do:  (let: "$a0" := (interface.make bytes.Buffer__mset_ptr "buf") in
          let: "$a1" := #(str "
          %s  ") in
          let: "$a2" := ((let: "$sl0" := (interface.make string__mset (![stringT] "indent")) in
          slice.literal interfaceT ["$sl0"])) in
          fmt.Fprintf "$a0" "$a1" "$a2");;;
          do:  (let: "$a0" := (let: "$a0" := (![raftpb.Entry] "e") in
          let: "$a1" := (![EntryFormatter] "f") in
          DescribeEntry "$a0" "$a1") in
          (bytes.Buffer__WriteString "buf") "$a0")));;;
        do:  (let: "$a0" := (interface.make bytes.Buffer__mset_ptr "buf") in
        let: "$a1" := #(str "
        %s]") in
        let: "$a2" := ((let: "$sl0" := (interface.make string__mset (![stringT] "indent")) in
        slice.literal interfaceT ["$sl0"])) in
        fmt.Fprintf "$a0" "$a1" "$a2")
      else do:  #())));;;
    (let: "s" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (![ptrT] (struct.field_ref raftpb.Message "Snapshot" "m")) in
    do:  ("s" <-[ptrT] "$r0");;;
    (if: ((![ptrT] "s") ≠ #null) && (~ (let: "$a0" := (![raftpb.Snapshot] (![ptrT] "s")) in
    IsEmptySnap "$a0"))
    then
      do:  (let: "$a0" := (interface.make bytes.Buffer__mset_ptr "buf") in
      let: "$a1" := #(str "
      %s  Snapshot: %s") in
      let: "$a2" := ((let: "$sl0" := (interface.make string__mset (![stringT] "indent")) in
      let: "$sl1" := (interface.make string__mset (let: "$a0" := (![raftpb.Snapshot] (![ptrT] "s")) in
      DescribeSnapshot "$a0")) in
      slice.literal interfaceT ["$sl0"; "$sl1"])) in
      fmt.Fprintf "$a0" "$a1" "$a2")
    else do:  #()));;;
    (if: int_gt (let: "$a0" := (![sliceT raftpb.Message] (struct.field_ref raftpb.Message "Responses" "m")) in
    slice.len "$a0") #(W64 0)
    then
      do:  (let: "$a0" := (interface.make bytes.Buffer__mset_ptr "buf") in
      let: "$a1" := #(str " Responses:[") in
      let: "$a2" := slice.nil in
      fmt.Fprintf "$a0" "$a1" "$a2");;;
      do:  (let: "$range" := (![sliceT raftpb.Message] (struct.field_ref raftpb.Message "Responses" "m")) in
      slice.for_range raftpb.Message "$range" (λ: <> "m",
        let: "m" := ref_ty raftpb.Message "m" in
        do:  (let: "$a0" := #(str "
        ") in
        (bytes.Buffer__WriteString "buf") "$a0");;;
        do:  (let: "$a0" := (let: "$a0" := ((![stringT] "indent") + #(str "  ")) in
        let: "$a1" := (![raftpb.Message] "m") in
        let: "$a2" := (![EntryFormatter] "f") in
        "describeMessageWithIndent" "$a0" "$a1" "$a2") in
        (bytes.Buffer__WriteString "buf") "$a0")));;;
      do:  (let: "$a0" := (interface.make bytes.Buffer__mset_ptr "buf") in
      let: "$a1" := #(str "
      %s]") in
      let: "$a2" := ((let: "$sl0" := (interface.make string__mset (![stringT] "indent")) in
      slice.literal interfaceT ["$sl0"])) in
      fmt.Fprintf "$a0" "$a1" "$a2")
    else do:  #());;;
    return: ((bytes.Buffer__String "buf") #())).

(* DescribeMessage returns a concise human-readable description of a
   Message for debugging.

   go: util.go:150:6 *)
Definition DescribeMessage : val :=
  rec: "DescribeMessage" "m" "f" :=
    exception_do (let: "f" := (ref_ty EntryFormatter "f") in
    let: "m" := (ref_ty raftpb.Message "m") in
    return: (let: "$a0" := #(str "") in
     let: "$a1" := (![raftpb.Message] "m") in
     let: "$a2" := (![EntryFormatter] "f") in
     describeMessageWithIndent "$a0" "$a1" "$a2")).

(* DescribeEntries calls DescribeEntry for each Entry, adding a newline to
   each.

   go: util.go:244:6 *)
Definition DescribeEntries : val :=
  rec: "DescribeEntries" "ents" "f" :=
    exception_do (let: "f" := (ref_ty EntryFormatter "f") in
    let: "ents" := (ref_ty (sliceT raftpb.Entry) "ents") in
    let: "buf" := (ref_ty bytes.Buffer (zero_val bytes.Buffer)) in
    do:  (let: "$range" := (![sliceT raftpb.Entry] "ents") in
    slice.for_range raftpb.Entry "$range" (λ: <> "e",
      let: "e" := ref_ty raftpb.Entry "e" in
      let: ("$ret0", "$ret1") := (let: "$a0" := ((let: "$a0" := (![raftpb.Entry] "e") in
      let: "$a1" := (![EntryFormatter] "f") in
      DescribeEntry "$a0" "$a1") + #(str "
      ")) in
      (bytes.Buffer__WriteString "buf") "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  "$r0";;;
      do:  "$r1"));;;
    return: ((bytes.Buffer__String "buf") #())).

(* go: util.go:107:6 *)
Definition DescribeReady : val :=
  rec: "DescribeReady" "rd" "f" :=
    exception_do (let: "f" := (ref_ty EntryFormatter "f") in
    let: "rd" := (ref_ty Ready "rd") in
    let: "buf" := (ref_ty strings.Builder (zero_val strings.Builder)) in
    (if: (![ptrT] (struct.field_ref Ready "SoftState" "rd")) ≠ #null
    then
      do:  (let: "$a0" := (interface.make strings.Builder__mset_ptr "buf") in
      let: "$a1" := ((let: "$sl0" := (interface.make string__mset (let: "$a0" := (![SoftState] (![ptrT] (struct.field_ref Ready "SoftState" "rd"))) in
      DescribeSoftState "$a0")) in
      slice.literal interfaceT ["$sl0"])) in
      fmt.Fprint "$a0" "$a1");;;
      do:  (let: "$a0" := #(W8 10) in
      (strings.Builder__WriteByte "buf") "$a0")
    else do:  #());;;
    (if: (~ (let: "$a0" := (![raftpb.HardState] (struct.field_ref Ready "HardState" "rd")) in
    IsEmptyHardState "$a0"))
    then
      do:  (let: "$a0" := (interface.make strings.Builder__mset_ptr "buf") in
      let: "$a1" := #(str "HardState %s") in
      let: "$a2" := ((let: "$sl0" := (interface.make string__mset (let: "$a0" := (![raftpb.HardState] (struct.field_ref Ready "HardState" "rd")) in
      DescribeHardState "$a0")) in
      slice.literal interfaceT ["$sl0"])) in
      fmt.Fprintf "$a0" "$a1" "$a2");;;
      do:  (let: "$a0" := #(W8 10) in
      (strings.Builder__WriteByte "buf") "$a0")
    else do:  #());;;
    (if: int_gt (let: "$a0" := (![sliceT ReadState] (struct.field_ref Ready "ReadStates" "rd")) in
    slice.len "$a0") #(W64 0)
    then
      do:  (let: "$a0" := (interface.make strings.Builder__mset_ptr "buf") in
      let: "$a1" := #(str "ReadStates %v
      ") in
      let: "$a2" := ((let: "$sl0" := (interface.make slice__mset (![sliceT ReadState] (struct.field_ref Ready "ReadStates" "rd"))) in
      slice.literal interfaceT ["$sl0"])) in
      fmt.Fprintf "$a0" "$a1" "$a2")
    else do:  #());;;
    (if: int_gt (let: "$a0" := (![sliceT raftpb.Entry] (struct.field_ref Ready "Entries" "rd")) in
    slice.len "$a0") #(W64 0)
    then
      do:  (let: "$a0" := #(str "Entries:
      ") in
      (strings.Builder__WriteString "buf") "$a0");;;
      do:  (let: "$a0" := (interface.make strings.Builder__mset_ptr "buf") in
      let: "$a1" := ((let: "$sl0" := (interface.make string__mset (let: "$a0" := (![sliceT raftpb.Entry] (struct.field_ref Ready "Entries" "rd")) in
      let: "$a1" := (![EntryFormatter] "f") in
      DescribeEntries "$a0" "$a1")) in
      slice.literal interfaceT ["$sl0"])) in
      fmt.Fprint "$a0" "$a1")
    else do:  #());;;
    (if: (~ (let: "$a0" := (![raftpb.Snapshot] (struct.field_ref Ready "Snapshot" "rd")) in
    IsEmptySnap "$a0"))
    then
      do:  (let: "$a0" := (interface.make strings.Builder__mset_ptr "buf") in
      let: "$a1" := #(str "Snapshot %s
      ") in
      let: "$a2" := ((let: "$sl0" := (interface.make string__mset (let: "$a0" := (![raftpb.Snapshot] (struct.field_ref Ready "Snapshot" "rd")) in
      DescribeSnapshot "$a0")) in
      slice.literal interfaceT ["$sl0"])) in
      fmt.Fprintf "$a0" "$a1" "$a2")
    else do:  #());;;
    (if: int_gt (let: "$a0" := (![sliceT raftpb.Entry] (struct.field_ref Ready "CommittedEntries" "rd")) in
    slice.len "$a0") #(W64 0)
    then
      do:  (let: "$a0" := #(str "CommittedEntries:
      ") in
      (strings.Builder__WriteString "buf") "$a0");;;
      do:  (let: "$a0" := (interface.make strings.Builder__mset_ptr "buf") in
      let: "$a1" := ((let: "$sl0" := (interface.make string__mset (let: "$a0" := (![sliceT raftpb.Entry] (struct.field_ref Ready "CommittedEntries" "rd")) in
      let: "$a1" := (![EntryFormatter] "f") in
      DescribeEntries "$a0" "$a1")) in
      slice.literal interfaceT ["$sl0"])) in
      fmt.Fprint "$a0" "$a1")
    else do:  #());;;
    (if: int_gt (let: "$a0" := (![sliceT raftpb.Message] (struct.field_ref Ready "Messages" "rd")) in
    slice.len "$a0") #(W64 0)
    then
      do:  (let: "$a0" := #(str "Messages:
      ") in
      (strings.Builder__WriteString "buf") "$a0");;;
      do:  (let: "$range" := (![sliceT raftpb.Message] (struct.field_ref Ready "Messages" "rd")) in
      slice.for_range raftpb.Message "$range" (λ: <> "msg",
        let: "msg" := ref_ty raftpb.Message "msg" in
        do:  (let: "$a0" := (interface.make strings.Builder__mset_ptr "buf") in
        let: "$a1" := ((let: "$sl0" := (interface.make string__mset (let: "$a0" := (![raftpb.Message] "msg") in
        let: "$a1" := (![EntryFormatter] "f") in
        DescribeMessage "$a0" "$a1")) in
        slice.literal interfaceT ["$sl0"])) in
        fmt.Fprint "$a0" "$a1");;;
        do:  (let: "$a0" := #(W8 10) in
        (strings.Builder__WriteByte "buf") "$a0")))
    else do:  #());;;
    (if: int_gt ((strings.Builder__Len "buf") #()) #(W64 0)
    then
      return: (let: "$a0" := #(str "Ready MustSync=%t:
       %s") in
       let: "$a1" := ((let: "$sl0" := (interface.make bool__mset (![boolT] (struct.field_ref Ready "MustSync" "rd"))) in
       let: "$sl1" := (interface.make string__mset ((strings.Builder__String "buf") #())) in
       slice.literal interfaceT ["$sl0"; "$sl1"])) in
       fmt.Sprintf "$a0" "$a1")
    else do:  #());;;
    return: (#(str "<empty Ready>"))).

Definition EntryFormatter__mset : list (string * val) := [
].

Definition EntryFormatter__mset_ptr : list (string * val) := [
].

Definition entryEncodingSize__mset_ptr : list (string * val) := [
].

Definition entryPayloadSize__mset : list (string * val) := [
].

Definition entryPayloadSize__mset_ptr : list (string * val) := [
].

End code.
