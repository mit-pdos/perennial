(* autogenerated from go.etcd.io/raft/v3 *)
From New.golang Require Import defn.
From New.code Require bytes.
From New.code Require context.
From New.code Require crypto.rand.
From New.code Require errors.
From New.code Require fmt.
From New.code Require github_com.stretchr.testify.assert.
From New.code Require go_etcd_io.raft.v3.confchange.
From New.code Require go_etcd_io.raft.v3.quorum.
From New.code Require go_etcd_io.raft.v3.raftpb.
From New.code Require go_etcd_io.raft.v3.tracker.
From New.code Require io.
From New.code Require log.
From New.code Require math.
From New.code Require math.big.
From New.code Require math.rand.
From New.code Require os.
From New.code Require sort.
From New.code Require strings.
From New.code Require sync.
From New.code Require testing.

Section code.
Context `{ffi_syntax}.

Definition Peer : go_type := structT [
  "ID" :: uint64T;
  "Context" :: sliceT
].

Definition RawNode : go_type := structT [
  "raft" :: ptrT;
  "asyncStorageWrites" :: boolT;
  "prevSoftSt" :: ptrT;
  "prevHardSt" :: raftpb.HardState;
  "stepsOnAdvance" :: sliceT
].

Definition ReadState : go_type := structT [
  "Index" :: uint64T;
  "RequestCtx" :: sliceT
].

Definition entryEncodingSize : go_type := uint64T.

Definition entryPayloadSize : go_type := uint64T.

Definition StateType : go_type := uint64T.

Definition Logger : go_type := interfaceT.

Definition TraceLogger : go_type := interfaceT.

Definition raft : go_type := structT [
  "id" :: uint64T;
  "Term" :: uint64T;
  "Vote" :: uint64T;
  "readStates" :: sliceT;
  "raftLog" :: ptrT;
  "maxMsgSize" :: entryEncodingSize;
  "maxUncommittedSize" :: entryPayloadSize;
  "trk" :: tracker.ProgressTracker;
  "state" :: StateType;
  "isLearner" :: boolT;
  "msgs" :: sliceT;
  "msgsAfterAppend" :: sliceT;
  "lead" :: uint64T;
  "leadTransferee" :: uint64T;
  "pendingConfIndex" :: uint64T;
  "disableConfChangeValidation" :: boolT;
  "uncommittedSize" :: entryPayloadSize;
  "readOnly" :: ptrT;
  "electionElapsed" :: intT;
  "heartbeatElapsed" :: intT;
  "checkQuorum" :: boolT;
  "preVote" :: boolT;
  "heartbeatTimeout" :: intT;
  "electionTimeout" :: intT;
  "randomizedElectionTimeout" :: intT;
  "disableProposalForwarding" :: boolT;
  "stepDownOnRemoval" :: boolT;
  "tickId" :: intT;
  "step" :: funcT;
  "StepHigherOrder" :: funcT;
  "logger" :: Logger;
  "pendingReadIndexMessages" :: sliceT;
  "traceLogger" :: TraceLogger
].

Definition None : expr := #(W64 0).

(* go: raft.go:2082:16 *)
Definition raft__abortLeaderTransfer : val :=
  rec: "raft__abortLeaderTransfer" "r" <> :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "$r0" := None in
    do:  ((struct.field_ref raft "leadTransferee" (![ptrT] "r")) <-[uint64T] "$r0")).

Definition Storage : go_type := interfaceT.

Definition unstable : go_type := structT [
  "snapshot" :: ptrT;
  "entries" :: sliceT;
  "offset" :: uint64T;
  "snapshotInProgress" :: boolT;
  "offsetInProgress" :: uint64T;
  "logger" :: Logger
].

Definition raftLog : go_type := structT [
  "storage" :: Storage;
  "unstable" :: unstable;
  "committed" :: uint64T;
  "applying" :: uint64T;
  "applied" :: uint64T;
  "logger" :: Logger;
  "maxApplyingEntsSize" :: entryEncodingSize;
  "applyingEntsSize" :: entryEncodingSize;
  "applyingEntsPaused" :: boolT
].

(* payloadSize is the size of the payload of the provided entry.

   go: util.go:289:6 *)
Definition payloadSize : val :=
  rec: "payloadSize" "e" :=
    exception_do (let: "e" := (ref_ty raftpb.Entry "e") in
    return: (let: "$a0" := (![sliceT] (struct.field_ref raftpb.Entry "Data" "e")) in
     slice.len "$a0")).

(* payloadsSize is the size of the payloads of the provided entries.

   go: util.go:294:6 *)
Definition payloadsSize : val :=
  rec: "payloadsSize" "ents" :=
    exception_do (let: "ents" := (ref_ty sliceT "ents") in
    let: "s" := (ref_ty entryPayloadSize (zero_val entryPayloadSize)) in
    do:  (let: "$range" := (![sliceT] "ents") in
    slice.for_range raftpb.Entry "$range" (λ: <> "e",
      let: "e" := ref_ty raftpb.Entry "e" in
      do:  ("s" <-[entryPayloadSize] ((![entryPayloadSize] "s") + (let: "$a0" := (![raftpb.Entry] "e") in
      payloadSize "$a0")))));;;
    return: (![entryPayloadSize] "s")).

(* go: state_trace_nop.go:48:6 *)
Definition traceSendMessage : val :=
  rec: "traceSendMessage" "" "" :=
    exception_do (let: "" := (ref_ty ptrT "") in
    let: "" := (ref_ty ptrT "") in
    do:  #()).

(* send schedules persisting state to a stable storage and AFTER that
   sending the message (as part of next Ready message processing).

   go: raft.go:520:16 *)
Definition raft__send : val :=
  rec: "raft__send" "r" "m" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "m" := (ref_ty raftpb.Message "m") in
    (if: (![uint64T] (struct.field_ref raftpb.Message "From" "m")) = None
    then
      let: "$r0" := (![uint64T] (struct.field_ref raft "id" (![ptrT] "r"))) in
      do:  ((struct.field_ref raftpb.Message "From" "m") <-[uint64T] "$r0")
    else do:  #());;;
    (if: ((((![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) = raftpb.MsgVote) || ((![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) = raftpb.MsgVoteResp)) || ((![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) = raftpb.MsgPreVote)) || ((![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) = raftpb.MsgPreVoteResp)
    then
      (if: (![uint64T] (struct.field_ref raftpb.Message "Term" "m")) = #(W64 0)
      then
        do:  (let: "$a0" := #"term should be set when sending %s" in
        let: "$a1" := ((let: "$sl0" := (interface.make raftpb.MessageType__mset (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m"))) in
        slice.literal interfaceT ["$sl0"])) in
        (interface.get "Panicf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1")
      else do:  #())
    else
      (if: (![uint64T] (struct.field_ref raftpb.Message "Term" "m")) ≠ #(W64 0)
      then
        do:  (let: "$a0" := #"term should not be set when sending %s (was %d)" in
        let: "$a1" := ((let: "$sl0" := (interface.make raftpb.MessageType__mset (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m"))) in
        let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "Term" "m"))) in
        slice.literal interfaceT ["$sl0"; "$sl1"])) in
        (interface.get "Panicf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1")
      else do:  #());;;
      (if: ((![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) ≠ raftpb.MsgProp) && ((![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) ≠ raftpb.MsgReadIndex)
      then
        let: "$r0" := (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r"))) in
        do:  ((struct.field_ref raftpb.Message "Term" "m") <-[uint64T] "$r0")
      else do:  #()));;;
    (if: (((![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) = raftpb.MsgAppResp) || ((![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) = raftpb.MsgVoteResp)) || ((![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) = raftpb.MsgPreVoteResp)
    then
      let: "$r0" := (let: "$a0" := (![sliceT] (struct.field_ref raft "msgsAfterAppend" (![ptrT] "r"))) in
      let: "$a1" := ((let: "$sl0" := (![raftpb.Message] "m") in
      slice.literal raftpb.Message ["$sl0"])) in
      (slice.append sliceT) "$a0" "$a1") in
      do:  ((struct.field_ref raft "msgsAfterAppend" (![ptrT] "r")) <-[sliceT] "$r0");;;
      do:  (let: "$a0" := (![ptrT] "r") in
      let: "$a1" := "m" in
      traceSendMessage "$a0" "$a1")
    else
      (if: (![uint64T] (struct.field_ref raftpb.Message "To" "m")) = (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))
      then
        do:  (let: "$a0" := #"message should not be self-addressed when sending %s" in
        let: "$a1" := ((let: "$sl0" := (interface.make raftpb.MessageType__mset (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m"))) in
        slice.literal interfaceT ["$sl0"])) in
        (interface.get "Panicf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1")
      else do:  #());;;
      let: "$r0" := (let: "$a0" := (![sliceT] (struct.field_ref raft "msgs" (![ptrT] "r"))) in
      let: "$a1" := ((let: "$sl0" := (![raftpb.Message] "m") in
      slice.literal raftpb.Message ["$sl0"])) in
      (slice.append sliceT) "$a0" "$a1") in
      do:  ((struct.field_ref raft "msgs" (![ptrT] "r")) <-[sliceT] "$r0");;;
      do:  (let: "$a0" := (![ptrT] "r") in
      let: "$a1" := "m" in
      traceSendMessage "$a0" "$a1"))).

(* maybeFirstIndex returns the index of the first possible entry in entries
   if it has a snapshot.

   go: log_unstable.go:54:20 *)
Definition unstable__maybeFirstIndex : val :=
  rec: "unstable__maybeFirstIndex" "u" <> :=
    exception_do (let: "u" := (ref_ty ptrT "u") in
    (if: (![ptrT] (struct.field_ref unstable "snapshot" (![ptrT] "u"))) ≠ #null
    then return: ((![uint64T] (struct.field_ref raftpb.SnapshotMetadata "Index" (struct.field_ref raftpb.Snapshot "Metadata" (![ptrT] (struct.field_ref unstable "snapshot" (![ptrT] "u")))))) + #(W64 1), #true)
    else do:  #());;;
    return: (#(W64 0), #false)).

(* go: log.go:300:19 *)
Definition raftLog__firstIndex : val :=
  rec: "raftLog__firstIndex" "l" <> :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    (let: "ok" := (ref_ty boolT (zero_val boolT)) in
    let: "i" := (ref_ty uint64T (zero_val uint64T)) in
    let: ("$ret0", "$ret1") := ((unstable__maybeFirstIndex (struct.field_ref raftLog "unstable" (![ptrT] "l"))) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("i" <-[uint64T] "$r0");;;
    do:  ("ok" <-[boolT] "$r1");;;
    (if: ![boolT] "ok"
    then return: (![uint64T] "i")
    else do:  #()));;;
    let: "err" := (ref_ty error (zero_val error)) in
    let: "index" := (ref_ty uint64T (zero_val uint64T)) in
    let: ("$ret0", "$ret1") := ((interface.get "FirstIndex" (![Storage] (struct.field_ref raftLog "storage" (![ptrT] "l")))) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("index" <-[uint64T] "$r0");;;
    do:  ("err" <-[error] "$r1");;;
    (if: (![error] "err") ≠ #interface.nil
    then
      do:  (let: "$a0" := (![error] "err") in
      Panic "$a0")
    else do:  #());;;
    return: (![uint64T] "index")).

(* IsEmptySnap returns true if the given Snapshot is empty.

   go: node.go:127:6 *)
Definition IsEmptySnap : val :=
  rec: "IsEmptySnap" "sp" :=
    exception_do (let: "sp" := (ref_ty raftpb.Snapshot "sp") in
    return: ((![uint64T] (struct.field_ref raftpb.SnapshotMetadata "Index" (struct.field_ref raftpb.Snapshot "Metadata" "sp"))) = #(W64 0))).

(* go: log.go:293:19 *)
Definition raftLog__snapshot : val :=
  rec: "raftLog__snapshot" "l" <> :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    (if: (![ptrT] (struct.field_ref unstable "snapshot" (struct.field_ref raftLog "unstable" (![ptrT] "l")))) ≠ #null
    then return: (![raftpb.Snapshot] (![ptrT] (struct.field_ref unstable "snapshot" (struct.field_ref raftLog "unstable" (![ptrT] "l")))), #interface.nil)
    else do:  #());;;
    let: ("$ret0", "$ret1") := (((interface.get "Snapshot" (![Storage] (struct.field_ref raftLog "storage" (![ptrT] "l")))) #())) in
    return: ("$ret0", "$ret1")).

(* maybeSendSnapshot fetches a snapshot from Storage, and sends it to the given
   node. Returns true iff the snapshot message has been emitted successfully.

   go: raft.go:672:16 *)
Definition raft__maybeSendSnapshot : val :=
  rec: "raft__maybeSendSnapshot" "r" "to" "pr" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "pr" := (ref_ty ptrT "pr") in
    let: "to" := (ref_ty uint64T "to") in
    (if: (~ (![boolT] (struct.field_ref tracker.Progress "RecentActive" (![ptrT] "pr"))))
    then
      do:  (let: "$a0" := #"ignore sending snapshot to %x since it is not recently active" in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] "to")) in
      slice.literal interfaceT ["$sl0"])) in
      (interface.get "Debugf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
      return: (#false)
    else do:  #());;;
    let: "err" := (ref_ty error (zero_val error)) in
    let: "snapshot" := (ref_ty raftpb.Snapshot (zero_val raftpb.Snapshot)) in
    let: ("$ret0", "$ret1") := ((raftLog__snapshot (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("snapshot" <-[raftpb.Snapshot] "$r0");;;
    do:  ("err" <-[error] "$r1");;;
    (if: (![error] "err") ≠ #interface.nil
    then
      (if: (![error] "err") = (![error] "ErrSnapshotTemporarilyUnavailable")
      then
        do:  (let: "$a0" := #"%x failed to send snapshot to %x because snapshot is temporarily unavailable" in
        let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
        let: "$sl1" := (interface.make uint64__mset (![uint64T] "to")) in
        slice.literal interfaceT ["$sl0"; "$sl1"])) in
        (interface.get "Debugf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
        return: (#false)
      else do:  #());;;
      do:  (let: "$a0" := (![error] "err") in
      Panic "$a0")
    else do:  #());;;
    (if: let: "$a0" := (![raftpb.Snapshot] "snapshot") in
    IsEmptySnap "$a0"
    then
      do:  (let: "$a0" := (interface.make string__mset #"need non-empty snapshot") in
      Panic "$a0")
    else do:  #());;;
    let: "sterm" := (ref_ty uint64T (zero_val uint64T)) in
    let: "sindex" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (![uint64T] (struct.field_ref raftpb.SnapshotMetadata "Index" (struct.field_ref raftpb.Snapshot "Metadata" "snapshot"))) in
    let: "$r1" := (![uint64T] (struct.field_ref raftpb.SnapshotMetadata "Term" (struct.field_ref raftpb.Snapshot "Metadata" "snapshot"))) in
    do:  ("sindex" <-[uint64T] "$r0");;;
    do:  ("sterm" <-[uint64T] "$r1");;;
    do:  (let: "$a0" := #"%x [firstindex: %d, commit: %d] sent snapshot[index: %d, term: %d] to %x [%s]" in
    let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
    let: "$sl1" := (interface.make uint64__mset ((raftLog__firstIndex (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #())) in
    let: "$sl2" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))))) in
    let: "$sl3" := (interface.make uint64__mset (![uint64T] "sindex")) in
    let: "$sl4" := (interface.make uint64__mset (![uint64T] "sterm")) in
    let: "$sl5" := (interface.make uint64__mset (![uint64T] "to")) in
    let: "$sl6" := (interface.make tracker.Progress__mset_ptr (![ptrT] "pr")) in
    slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"; "$sl4"; "$sl5"; "$sl6"])) in
    (interface.get "Debugf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
    do:  (let: "$a0" := (![uint64T] "sindex") in
    (tracker.Progress__BecomeSnapshot (![ptrT] "pr")) "$a0");;;
    do:  (let: "$a0" := #"%x paused sending replication messages to %x [%s]" in
    let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
    let: "$sl1" := (interface.make uint64__mset (![uint64T] "to")) in
    let: "$sl2" := (interface.make tracker.Progress__mset_ptr (![ptrT] "pr")) in
    slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
    (interface.get "Debugf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
    do:  (let: "$a0" := (struct.make raftpb.Message [{
      "To" ::= ![uint64T] "to";
      "Type" ::= raftpb.MsgSnap;
      "Snapshot" ::= "snapshot"
    }]) in
    (raft__send (![ptrT] "r")) "$a0");;;
    return: (#true)).

(* extend appends vals to the given dst slice. It differs from the standard
   slice append only in the way it allocates memory. If cap(dst) is not enough
   for appending the values, precisely size len(dst)+len(vals) is allocated.

   Use this instead of standard append in situations when this is the last
   append to dst, so there is no sense in allocating more than needed.

   go: util.go:316:6 *)
Definition extend : val :=
  rec: "extend" "dst" "vals" :=
    exception_do (let: "vals" := (ref_ty sliceT "vals") in
    let: "dst" := (ref_ty sliceT "dst") in
    let: "need" := (ref_ty intT (zero_val intT)) in
    let: "$r0" := ((let: "$a0" := (![sliceT] "dst") in
    slice.len "$a0") + (let: "$a0" := (![sliceT] "vals") in
    slice.len "$a0")) in
    do:  ("need" <-[intT] "$r0");;;
    (if: int_leq (![intT] "need") (let: "$a0" := (![sliceT] "dst") in
    slice.cap "$a0")
    then
      return: (let: "$a0" := (![sliceT] "dst") in
       let: "$a1" := (![sliceT] "vals") in
       (slice.append sliceT) "$a0" "$a1")
    else do:  #());;;
    let: "buf" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (slice.make3 raftpb.Entry (![intT] "need") (![intT] "need")) in
    do:  ("buf" <-[sliceT] "$r0");;;
    do:  (let: "$a0" := (![sliceT] "buf") in
    let: "$a1" := (![sliceT] "dst") in
    (slice.copy raftpb.Entry) "$a0" "$a1");;;
    do:  (let: "$a0" := (let: "$s" := (![sliceT] "buf") in
    slice.slice raftpb.Entry "$s" (let: "$a0" := (![sliceT] "dst") in
    slice.len "$a0") (slice.len "$s")) in
    let: "$a1" := (![sliceT] "vals") in
    (slice.copy raftpb.Entry) "$a0" "$a1");;;
    return: (![sliceT] "buf")).

(* go: util.go:256:6 *)
Definition entsSize : val :=
  rec: "entsSize" "ents" :=
    exception_do (let: "ents" := (ref_ty sliceT "ents") in
    let: "size" := (ref_ty entryEncodingSize (zero_val entryEncodingSize)) in
    do:  (let: "$range" := (![sliceT] "ents") in
    slice.for_range raftpb.Entry "$range" (λ: <> "ent",
      let: "ent" := ref_ty raftpb.Entry "ent" in
      do:  ("size" <-[entryEncodingSize] ((![entryEncodingSize] "size") + ((raftpb.Entry__Size "ent") #())))));;;
    return: (![entryEncodingSize] "size")).

(* limitSize returns the longest prefix of the given entries slice, such that
   its total byte size does not exceed maxSize. Always returns a non-empty slice
   if the input is non-empty, so, as an exception, if the size of the first
   entry exceeds maxSize, a non-empty slice with just this entry is returned.

   go: util.go:268:6 *)
Definition limitSize : val :=
  rec: "limitSize" "ents" "maxSize" :=
    exception_do (let: "maxSize" := (ref_ty entryEncodingSize "maxSize") in
    let: "ents" := (ref_ty sliceT "ents") in
    (if: (let: "$a0" := (![sliceT] "ents") in
    slice.len "$a0") = #(W64 0)
    then return: (![sliceT] "ents")
    else do:  #());;;
    let: "size" := (ref_ty intT (zero_val intT)) in
    let: "$r0" := ((raftpb.Entry__Size (slice.elem_ref raftpb.Entry (![sliceT] "ents") #(W64 0))) #()) in
    do:  ("size" <-[intT] "$r0");;;
    (let: "limit" := (ref_ty intT (zero_val intT)) in
    let: "$r0" := #(W64 1) in
    do:  ("limit" <-[intT] "$r0");;;
    (for: (λ: <>, int_lt (![intT] "limit") (let: "$a0" := (![sliceT] "ents") in
    slice.len "$a0")); (λ: <>, do:  ("limit" <-[intT] ((![intT] "limit") + #(W64 1)))) := λ: <>,
      do:  ("size" <-[intT] ((![intT] "size") + ((raftpb.Entry__Size (slice.elem_ref raftpb.Entry (![sliceT] "ents") (![intT] "limit"))) #())));;;
      (if: (![intT] "size") > (![entryEncodingSize] "maxSize")
      then
        return: (let: "$s" := (![sliceT] "ents") in
         slice.slice raftpb.Entry "$s" #(W64 0) (![intT] "limit"))
      else do:  #())));;;
    return: (![sliceT] "ents")).

(* u.offset <= lo <= hi <= u.offset+len(u.entries)

   go: log_unstable.go:238:20 *)
Definition unstable__mustCheckOutOfBounds : val :=
  rec: "unstable__mustCheckOutOfBounds" "u" "lo" "hi" :=
    exception_do (let: "u" := (ref_ty ptrT "u") in
    let: "hi" := (ref_ty uint64T "hi") in
    let: "lo" := (ref_ty uint64T "lo") in
    (if: (![uint64T] "lo") > (![uint64T] "hi")
    then
      do:  (let: "$a0" := #"invalid unstable.slice %d > %d" in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] "lo")) in
      let: "$sl1" := (interface.make uint64__mset (![uint64T] "hi")) in
      slice.literal interfaceT ["$sl0"; "$sl1"])) in
      (interface.get "Panicf" (![Logger] (struct.field_ref unstable "logger" (![ptrT] "u")))) "$a0" "$a1")
    else do:  #());;;
    let: "upper" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := ((![uint64T] (struct.field_ref unstable "offset" (![ptrT] "u"))) + (let: "$a0" := (![sliceT] (struct.field_ref unstable "entries" (![ptrT] "u"))) in
    slice.len "$a0")) in
    do:  ("upper" <-[uint64T] "$r0");;;
    (if: ((![uint64T] "lo") < (![uint64T] (struct.field_ref unstable "offset" (![ptrT] "u")))) || ((![uint64T] "hi") > (![uint64T] "upper"))
    then
      do:  (let: "$a0" := #"unstable.slice[%d,%d) out of bound [%d,%d]" in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] "lo")) in
      let: "$sl1" := (interface.make uint64__mset (![uint64T] "hi")) in
      let: "$sl2" := (interface.make uint64__mset (![uint64T] (struct.field_ref unstable "offset" (![ptrT] "u")))) in
      let: "$sl3" := (interface.make uint64__mset (![uint64T] "upper")) in
      slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"])) in
      (interface.get "Panicf" (![Logger] (struct.field_ref unstable "logger" (![ptrT] "u")))) "$a0" "$a1")
    else do:  #())).

(* slice returns the entries from the unstable log with indexes in the range
   [lo, hi). The entire range must be stored in the unstable log or the method
   will panic. The returned slice can be appended to, but the entries in it must
   not be changed because they are still shared with unstable.

   TODO(pavelkalinnikov): this, and similar []raftpb.Entry slices, may bubble up all
   the way to the application code through Ready struct. Protect other slices
   similarly, and document how the client can use them.

   go: log_unstable.go:229:20 *)
Definition unstable__slice : val :=
  rec: "unstable__slice" "u" "lo" "hi" :=
    exception_do (let: "u" := (ref_ty ptrT "u") in
    let: "hi" := (ref_ty uint64T "hi") in
    let: "lo" := (ref_ty uint64T "lo") in
    do:  (let: "$a0" := (![uint64T] "lo") in
    let: "$a1" := (![uint64T] "hi") in
    (unstable__mustCheckOutOfBounds (![ptrT] "u")) "$a0" "$a1");;;
    return: (let: "$s" := (![sliceT] (struct.field_ref unstable "entries" (![ptrT] "u"))) in
     slice.full_slice raftpb.Entry "$s" ((![uint64T] "lo") - (![uint64T] (struct.field_ref unstable "offset" (![ptrT] "u")))) ((![uint64T] "hi") - (![uint64T] (struct.field_ref unstable "offset" (![ptrT] "u")))) ((![uint64T] "hi") - (![uint64T] (struct.field_ref unstable "offset" (![ptrT] "u")))))).

(* maybeLastIndex returns the last index if it has at least one
   unstable entry or snapshot.

   go: log_unstable.go:63:20 *)
Definition unstable__maybeLastIndex : val :=
  rec: "unstable__maybeLastIndex" "u" <> :=
    exception_do (let: "u" := (ref_ty ptrT "u") in
    (let: "l" := (ref_ty intT (zero_val intT)) in
    let: "$r0" := (let: "$a0" := (![sliceT] (struct.field_ref unstable "entries" (![ptrT] "u"))) in
    slice.len "$a0") in
    do:  ("l" <-[intT] "$r0");;;
    (if: (![intT] "l") ≠ #(W64 0)
    then return: (((![uint64T] (struct.field_ref unstable "offset" (![ptrT] "u"))) + (![intT] "l")) - #(W64 1), #true)
    else do:  #()));;;
    (if: (![ptrT] (struct.field_ref unstable "snapshot" (![ptrT] "u"))) ≠ #null
    then return: (![uint64T] (struct.field_ref raftpb.SnapshotMetadata "Index" (struct.field_ref raftpb.Snapshot "Metadata" (![ptrT] (struct.field_ref unstable "snapshot" (![ptrT] "u"))))), #true)
    else do:  #());;;
    return: (#(W64 0), #false)).

(* go: log.go:311:19 *)
Definition raftLog__lastIndex : val :=
  rec: "raftLog__lastIndex" "l" <> :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    (let: "ok" := (ref_ty boolT (zero_val boolT)) in
    let: "i" := (ref_ty uint64T (zero_val uint64T)) in
    let: ("$ret0", "$ret1") := ((unstable__maybeLastIndex (struct.field_ref raftLog "unstable" (![ptrT] "l"))) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("i" <-[uint64T] "$r0");;;
    do:  ("ok" <-[boolT] "$r1");;;
    (if: ![boolT] "ok"
    then return: (![uint64T] "i")
    else do:  #()));;;
    let: "err" := (ref_ty error (zero_val error)) in
    let: "i" := (ref_ty uint64T (zero_val uint64T)) in
    let: ("$ret0", "$ret1") := ((interface.get "LastIndex" (![Storage] (struct.field_ref raftLog "storage" (![ptrT] "l")))) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("i" <-[uint64T] "$r0");;;
    do:  ("err" <-[error] "$r1");;;
    (if: (![error] "err") ≠ #interface.nil
    then
      do:  (let: "$a0" := (![error] "err") in
      Panic "$a0")
    else do:  #());;;
    return: (![uint64T] "i")).

(* l.firstIndex <= lo <= hi <= l.firstIndex + len(l.entries)

   go: log.go:551:19 *)
Definition raftLog__mustCheckOutOfBounds : val :=
  rec: "raftLog__mustCheckOutOfBounds" "l" "lo" "hi" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "hi" := (ref_ty uint64T "hi") in
    let: "lo" := (ref_ty uint64T "lo") in
    (if: (![uint64T] "lo") > (![uint64T] "hi")
    then
      do:  (let: "$a0" := #"invalid slice %d > %d" in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] "lo")) in
      let: "$sl1" := (interface.make uint64__mset (![uint64T] "hi")) in
      slice.literal interfaceT ["$sl0"; "$sl1"])) in
      (interface.get "Panicf" (![Logger] (struct.field_ref raftLog "logger" (![ptrT] "l")))) "$a0" "$a1")
    else do:  #());;;
    let: "fi" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := ((raftLog__firstIndex (![ptrT] "l")) #()) in
    do:  ("fi" <-[uint64T] "$r0");;;
    (if: (![uint64T] "lo") < (![uint64T] "fi")
    then return: (![error] "ErrCompacted")
    else do:  #());;;
    let: "length" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := ((((raftLog__lastIndex (![ptrT] "l")) #()) + #(W64 1)) - (![uint64T] "fi")) in
    do:  ("length" <-[uint64T] "$r0");;;
    (if: (![uint64T] "hi") > ((![uint64T] "fi") + (![uint64T] "length"))
    then
      do:  (let: "$a0" := #"slice[%d,%d) out of bound [%d,%d]" in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] "lo")) in
      let: "$sl1" := (interface.make uint64__mset (![uint64T] "hi")) in
      let: "$sl2" := (interface.make uint64__mset (![uint64T] "fi")) in
      let: "$sl3" := (interface.make uint64__mset ((raftLog__lastIndex (![ptrT] "l")) #())) in
      slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"])) in
      (interface.get "Panicf" (![Logger] (struct.field_ref raftLog "logger" (![ptrT] "l")))) "$a0" "$a1")
    else do:  #());;;
    return: (#interface.nil)).

(* slice returns a slice of log entries from lo through hi-1, inclusive.

   go: log.go:499:19 *)
Definition raftLog__slice : val :=
  rec: "raftLog__slice" "l" "lo" "hi" "maxSize" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "maxSize" := (ref_ty entryEncodingSize "maxSize") in
    let: "hi" := (ref_ty uint64T "hi") in
    let: "lo" := (ref_ty uint64T "lo") in
    (let: "err" := (ref_ty error (zero_val error)) in
    let: "$r0" := (let: "$a0" := (![uint64T] "lo") in
    let: "$a1" := (![uint64T] "hi") in
    (raftLog__mustCheckOutOfBounds (![ptrT] "l")) "$a0" "$a1") in
    do:  ("err" <-[error] "$r0");;;
    (if: (![error] "err") ≠ #interface.nil
    then return: (#slice.nil, ![error] "err")
    else do:  #()));;;
    (if: (![uint64T] "lo") = (![uint64T] "hi")
    then return: (#slice.nil, #interface.nil)
    else do:  #());;;
    (if: (![uint64T] "lo") ≥ (![uint64T] (struct.field_ref unstable "offset" (struct.field_ref raftLog "unstable" (![ptrT] "l"))))
    then
      let: "ents" := (ref_ty sliceT (zero_val sliceT)) in
      let: "$r0" := (let: "$a0" := (let: "$a0" := (![uint64T] "lo") in
      let: "$a1" := (![uint64T] "hi") in
      (unstable__slice (struct.field_ref raftLog "unstable" (![ptrT] "l"))) "$a0" "$a1") in
      let: "$a1" := (![entryEncodingSize] "maxSize") in
      limitSize "$a0" "$a1") in
      do:  ("ents" <-[sliceT] "$r0");;;
      return: (let: "$s" := (![sliceT] "ents") in
       slice.full_slice raftpb.Entry "$s" #(W64 0) (let: "$a0" := (![sliceT] "ents") in
       slice.len "$a0") (let: "$a0" := (![sliceT] "ents") in
       slice.len "$a0"), #interface.nil)
    else do:  #());;;
    let: "cut" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (let: "$a0" := (![uint64T] "hi") in
    let: "$a1" := (![uint64T] (struct.field_ref unstable "offset" (struct.field_ref raftLog "unstable" (![ptrT] "l")))) in
    (minUint64 2) "$a0" "$a1") in
    do:  ("cut" <-[uint64T] "$r0");;;
    let: "err" := (ref_ty error (zero_val error)) in
    let: "ents" := (ref_ty sliceT (zero_val sliceT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![uint64T] "lo") in
    let: "$a1" := (![uint64T] "cut") in
    let: "$a2" := (![entryEncodingSize] "maxSize") in
    (interface.get "Entries" (![Storage] (struct.field_ref raftLog "storage" (![ptrT] "l")))) "$a0" "$a1" "$a2") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("ents" <-[sliceT] "$r0");;;
    do:  ("err" <-[error] "$r1");;;
    (if: (![error] "err") = (![error] "ErrCompacted")
    then return: (#slice.nil, ![error] "err")
    else
      (if: (![error] "err") = (![error] "ErrUnavailable")
      then
        do:  (let: "$a0" := #"entries[%d:%d) is unavailable from storage" in
        let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] "lo")) in
        let: "$sl1" := (interface.make uint64__mset (![uint64T] "cut")) in
        slice.literal interfaceT ["$sl0"; "$sl1"])) in
        (interface.get "Panicf" (![Logger] (struct.field_ref raftLog "logger" (![ptrT] "l")))) "$a0" "$a1")
      else
        (if: (![error] "err") ≠ #interface.nil
        then
          do:  (let: "$a0" := (![error] "err") in
          Panic "$a0")
        else do:  #())));;;
    (if: (![uint64T] "hi") ≤ (![uint64T] (struct.field_ref unstable "offset" (struct.field_ref raftLog "unstable" (![ptrT] "l"))))
    then return: (![sliceT] "ents", #interface.nil)
    else do:  #());;;
    (if: (let: "$a0" := (![sliceT] "ents") in
    slice.len "$a0") < ((![uint64T] "cut") - (![uint64T] "lo"))
    then return: (![sliceT] "ents", #interface.nil)
    else do:  #());;;
    let: "size" := (ref_ty entryEncodingSize (zero_val entryEncodingSize)) in
    let: "$r0" := (let: "$a0" := (![sliceT] "ents") in
    entsSize "$a0") in
    do:  ("size" <-[entryEncodingSize] "$r0");;;
    (if: (![entryEncodingSize] "size") ≥ (![entryEncodingSize] "maxSize")
    then return: (![sliceT] "ents", #interface.nil)
    else do:  #());;;
    let: "unstable" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (let: "$a0" := (let: "$a0" := (![uint64T] (struct.field_ref unstable "offset" (struct.field_ref raftLog "unstable" (![ptrT] "l")))) in
    let: "$a1" := (![uint64T] "hi") in
    (unstable__slice (struct.field_ref raftLog "unstable" (![ptrT] "l"))) "$a0" "$a1") in
    let: "$a1" := ((![entryEncodingSize] "maxSize") - (![entryEncodingSize] "size")) in
    limitSize "$a0" "$a1") in
    do:  ("unstable" <-[sliceT] "$r0");;;
    (if: ((let: "$a0" := (![sliceT] "unstable") in
    slice.len "$a0") = #(W64 1)) && (((![entryEncodingSize] "size") + (let: "$a0" := (![sliceT] "unstable") in
    entsSize "$a0")) > (![entryEncodingSize] "maxSize"))
    then return: (![sliceT] "ents", #interface.nil)
    else do:  #());;;
    return: (let: "$a0" := (![sliceT] "ents") in
     let: "$a1" := (![sliceT] "unstable") in
     extend "$a0" "$a1", #interface.nil)).

(* go: log.go:415:19 *)
Definition raftLog__entries : val :=
  rec: "raftLog__entries" "l" "i" "maxSize" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "maxSize" := (ref_ty entryEncodingSize "maxSize") in
    let: "i" := (ref_ty uint64T "i") in
    (if: (![uint64T] "i") > ((raftLog__lastIndex (![ptrT] "l")) #())
    then return: (#slice.nil, #interface.nil)
    else do:  #());;;
    let: ("$ret0", "$ret1") := ((let: "$a0" := (![uint64T] "i") in
    let: "$a1" := (((raftLog__lastIndex (![ptrT] "l")) #()) + #(W64 1)) in
    let: "$a2" := (![entryEncodingSize] "maxSize") in
    (raftLog__slice (![ptrT] "l")) "$a0" "$a1" "$a2")) in
    return: ("$ret0", "$ret1")).

(* maybeTerm returns the term of the entry at index i, if there
   is any.

   go: log_unstable.go:75:20 *)
Definition unstable__maybeTerm : val :=
  rec: "unstable__maybeTerm" "u" "i" :=
    exception_do (let: "u" := (ref_ty ptrT "u") in
    let: "i" := (ref_ty uint64T "i") in
    (if: (![uint64T] "i") < (![uint64T] (struct.field_ref unstable "offset" (![ptrT] "u")))
    then
      (if: ((![ptrT] (struct.field_ref unstable "snapshot" (![ptrT] "u"))) ≠ #null) && ((![uint64T] (struct.field_ref raftpb.SnapshotMetadata "Index" (struct.field_ref raftpb.Snapshot "Metadata" (![ptrT] (struct.field_ref unstable "snapshot" (![ptrT] "u")))))) = (![uint64T] "i"))
      then return: (![uint64T] (struct.field_ref raftpb.SnapshotMetadata "Term" (struct.field_ref raftpb.Snapshot "Metadata" (![ptrT] (struct.field_ref unstable "snapshot" (![ptrT] "u"))))), #true)
      else do:  #());;;
      return: (#(W64 0), #false)
    else do:  #());;;
    let: "ok" := (ref_ty boolT (zero_val boolT)) in
    let: "last" := (ref_ty uint64T (zero_val uint64T)) in
    let: ("$ret0", "$ret1") := ((unstable__maybeLastIndex (![ptrT] "u")) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("last" <-[uint64T] "$r0");;;
    do:  ("ok" <-[boolT] "$r1");;;
    (if: (~ (![boolT] "ok"))
    then return: (#(W64 0), #false)
    else do:  #());;;
    (if: (![uint64T] "i") > (![uint64T] "last")
    then return: (#(W64 0), #false)
    else do:  #());;;
    return: (![uint64T] (struct.field_ref raftpb.Entry "Term" (slice.elem_ref raftpb.Entry (![sliceT] (struct.field_ref unstable "entries" (![ptrT] "u"))) ((![uint64T] "i") - (![uint64T] (struct.field_ref unstable "offset" (![ptrT] "u")))))), #true)).

(* go: log.go:387:19 *)
Definition raftLog__term : val :=
  rec: "raftLog__term" "l" "i" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "i" := (ref_ty uint64T "i") in
    (let: "ok" := (ref_ty boolT (zero_val boolT)) in
    let: "t" := (ref_ty uint64T (zero_val uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![uint64T] "i") in
    (unstable__maybeTerm (struct.field_ref raftLog "unstable" (![ptrT] "l"))) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("t" <-[uint64T] "$r0");;;
    do:  ("ok" <-[boolT] "$r1");;;
    (if: ![boolT] "ok"
    then return: (![uint64T] "t", #interface.nil)
    else do:  #()));;;
    (if: ((![uint64T] "i") + #(W64 1)) < ((raftLog__firstIndex (![ptrT] "l")) #())
    then return: (#(W64 0), ![error] "ErrCompacted")
    else do:  #());;;
    (if: (![uint64T] "i") > ((raftLog__lastIndex (![ptrT] "l")) #())
    then return: (#(W64 0), ![error] "ErrUnavailable")
    else do:  #());;;
    let: "err" := (ref_ty error (zero_val error)) in
    let: "t" := (ref_ty uint64T (zero_val uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![uint64T] "i") in
    (interface.get "Term" (![Storage] (struct.field_ref raftLog "storage" (![ptrT] "l")))) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("t" <-[uint64T] "$r0");;;
    do:  ("err" <-[error] "$r1");;;
    (if: (![error] "err") = #interface.nil
    then return: (![uint64T] "t", #interface.nil)
    else do:  #());;;
    (if: ((![error] "err") = (![error] "ErrCompacted")) || ((![error] "err") = (![error] "ErrUnavailable"))
    then return: (#(W64 0), ![error] "err")
    else do:  #());;;
    do:  (let: "$a0" := (![error] "err") in
    Panic "$a0")).

(* maybeSendAppend sends an append RPC with new entries to the given peer,
   if necessary. Returns true if a message was sent. The sendIfEmpty
   argument controls whether messages with no entries will be sent
   ("empty" messages are useful to convey updated Commit indexes, but
   are undesirable when we're sending multiple messages in a batch).

   TODO(pav-kv): make invocation of maybeSendAppend stateless. The Progress
   struct contains all the state necessary for deciding whether to send a
   message.

   go: raft.go:624:16 *)
Definition raft__maybeSendAppend : val :=
  rec: "raft__maybeSendAppend" "r" "to" "sendIfEmpty" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "sendIfEmpty" := (ref_ty boolT "sendIfEmpty") in
    let: "to" := (ref_ty uint64T "to") in
    let: "pr" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (Fst (map.get (![tracker.ProgressMap] (struct.field_ref tracker.ProgressTracker "Progress" (struct.field_ref raft "trk" (![ptrT] "r")))) (![uint64T] "to"))) in
    do:  ("pr" <-[ptrT] "$r0");;;
    (if: (tracker.Progress__IsPaused (![ptrT] "pr")) #()
    then return: (#false)
    else do:  #());;;
    let: "prevIndex" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := ((![uint64T] (struct.field_ref tracker.Progress "Next" (![ptrT] "pr"))) - #(W64 1)) in
    do:  ("prevIndex" <-[uint64T] "$r0");;;
    let: "err" := (ref_ty error (zero_val error)) in
    let: "prevTerm" := (ref_ty uint64T (zero_val uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![uint64T] "prevIndex") in
    (raftLog__term (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("prevTerm" <-[uint64T] "$r0");;;
    do:  ("err" <-[error] "$r1");;;
    (if: (![error] "err") ≠ #interface.nil
    then
      return: (let: "$a0" := (![uint64T] "to") in
       let: "$a1" := (![ptrT] "pr") in
       (raft__maybeSendSnapshot (![ptrT] "r")) "$a0" "$a1")
    else do:  #());;;
    let: "ents" := (ref_ty sliceT (zero_val sliceT)) in
    (if: ((![tracker.StateType] (struct.field_ref tracker.Progress "State" (![ptrT] "pr"))) ≠ tracker.StateReplicate) || (~ ((tracker.Inflights__Full (![ptrT] (struct.field_ref tracker.Progress "Inflights" (![ptrT] "pr")))) #()))
    then
      let: ("$ret0", "$ret1") := (let: "$a0" := (![uint64T] (struct.field_ref tracker.Progress "Next" (![ptrT] "pr"))) in
      let: "$a1" := (![entryEncodingSize] (struct.field_ref raft "maxMsgSize" (![ptrT] "r"))) in
      (raftLog__entries (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) "$a0" "$a1") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("ents" <-[sliceT] "$r0");;;
      do:  ("err" <-[error] "$r1")
    else do:  #());;;
    (if: ((let: "$a0" := (![sliceT] "ents") in
    slice.len "$a0") = #(W64 0)) && (~ (![boolT] "sendIfEmpty"))
    then return: (#false)
    else do:  #());;;
    (if: (![error] "err") ≠ #interface.nil
    then
      return: (let: "$a0" := (![uint64T] "to") in
       let: "$a1" := (![ptrT] "pr") in
       (raft__maybeSendSnapshot (![ptrT] "r")) "$a0" "$a1")
    else do:  #());;;
    do:  (let: "$a0" := (struct.make raftpb.Message [{
      "To" ::= ![uint64T] "to";
      "Type" ::= raftpb.MsgApp;
      "Index" ::= ![uint64T] "prevIndex";
      "LogTerm" ::= ![uint64T] "prevTerm";
      "Entries" ::= ![sliceT] "ents";
      "Commit" ::= ![uint64T] (struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r"))))
    }]) in
    (raft__send (![ptrT] "r")) "$a0");;;
    do:  (let: "$a0" := (let: "$a0" := (![sliceT] "ents") in
    slice.len "$a0") in
    let: "$a1" := (let: "$a0" := (![sliceT] "ents") in
    payloadsSize "$a0") in
    (tracker.Progress__SentEntries (![ptrT] "pr")) "$a0" "$a1");;;
    do:  (let: "$a0" := (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r"))))) in
    (tracker.Progress__SentCommit (![ptrT] "pr")) "$a0");;;
    return: (#true)).

Definition entryID : go_type := structT [
  "term" :: uint64T;
  "index" :: uint64T
].

(* go: log.go:447:19 *)
Definition raftLog__matchTerm : val :=
  rec: "raftLog__matchTerm" "l" "id" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "id" := (ref_ty entryID "id") in
    let: "err" := (ref_ty error (zero_val error)) in
    let: "t" := (ref_ty uint64T (zero_val uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![uint64T] (struct.field_ref entryID "index" "id")) in
    (raftLog__term (![ptrT] "l")) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("t" <-[uint64T] "$r0");;;
    do:  ("err" <-[error] "$r1");;;
    (if: (![error] "err") ≠ #interface.nil
    then return: (#false)
    else do:  #());;;
    return: ((![uint64T] "t") = (![uint64T] (struct.field_ref entryID "term" "id")))).

(* go: log.go:322:19 *)
Definition raftLog__commitTo : val :=
  rec: "raftLog__commitTo" "l" "tocommit" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "tocommit" := (ref_ty uint64T "tocommit") in
    (if: (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] "l"))) < (![uint64T] "tocommit")
    then
      (if: ((raftLog__lastIndex (![ptrT] "l")) #()) < (![uint64T] "tocommit")
      then
        do:  (let: "$a0" := #"tocommit(%d) is out of range [lastIndex(%d)]. Was the raft log corrupted, truncated, or lost?" in
        let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] "tocommit")) in
        let: "$sl1" := (interface.make uint64__mset ((raftLog__lastIndex (![ptrT] "l")) #())) in
        slice.literal interfaceT ["$sl0"; "$sl1"])) in
        (interface.get "Panicf" (![Logger] (struct.field_ref raftLog "logger" (![ptrT] "l")))) "$a0" "$a1")
      else do:  #());;;
      let: "$r0" := (![uint64T] "tocommit") in
      do:  ((struct.field_ref raftLog "committed" (![ptrT] "l")) <-[uint64T] "$r0")
    else do:  #())).

(* go: log.go:455:19 *)
Definition raftLog__maybeCommit : val :=
  rec: "raftLog__maybeCommit" "l" "at" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "at" := (ref_ty entryID "at") in
    (if: (((![uint64T] (struct.field_ref entryID "term" "at")) ≠ #(W64 0)) && ((![uint64T] (struct.field_ref entryID "index" "at")) > (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] "l"))))) && (let: "$a0" := (![entryID] "at") in
    (raftLog__matchTerm (![ptrT] "l")) "$a0")
    then
      do:  (let: "$a0" := (![uint64T] (struct.field_ref entryID "index" "at")) in
      (raftLog__commitTo (![ptrT] "l")) "$a0");;;
      return: (#true)
    else do:  #());;;
    return: (#false)).

(* go: state_trace_nop.go:34:6 *)
Definition traceCommit : val :=
  rec: "traceCommit" "" :=
    exception_do (let: "" := (ref_ty ptrT "") in
    do:  #()).

(* maybeCommit attempts to advance the commit index. Returns true if the commit
   index changed (in which case the caller should call r.bcastAppend). This can
   only be called in StateLeader.

   go: raft.go:786:16 *)
Definition raft__maybeCommit : val :=
  rec: "raft__maybeCommit" "r" <> :=
    with_defer: (let: "r" := (ref_ty ptrT "r") in
    do:  (let: "$a0" := (![ptrT] "r") in
    let: "$f" := traceCommit in
    "$defer" <-[funcT] (let: "$oldf" := (![funcT] "$defer") in
    (λ: <>,
      "$f" "a0";;
      "$oldf" #()
      )));;;
    return: (let: "$a0" := (struct.make entryID [{
       "term" ::= ![uint64T] (struct.field_ref raft "Term" (![ptrT] "r"));
       "index" ::= (tracker.ProgressTracker__Committed (struct.field_ref raft "trk" (![ptrT] "r"))) #()
     }]) in
     (raftLog__maybeCommit (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) "$a0")).

(* sendAppend sends an append RPC with new entries (if any) and the
   current commit index to the given peer.

   go: raft.go:611:16 *)
Definition raft__sendAppend : val :=
  rec: "raft__sendAppend" "r" "to" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "to" := (ref_ty uint64T "to") in
    do:  (let: "$a0" := (![uint64T] "to") in
    let: "$a1" := #true in
    (raft__maybeSendAppend (![ptrT] "r")) "$a0" "$a1")).

(* bcastAppend sends RPC, with entries to all peers that are not up-to-date
   according to the progress recorded in r.trk.

   go: raft.go:720:16 *)
Definition raft__bcastAppend : val :=
  rec: "raft__bcastAppend" "r" <> :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    do:  (let: "$a0" := (λ: "id" <>,
      exception_do (let: <> := (ref_ty ptrT "_") in
      let: "id" := (ref_ty uint64T "id") in
      (if: (![uint64T] "id") = (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))
      then return: (#())
      else do:  #());;;
      do:  (let: "$a0" := (![uint64T] "id") in
      (raft__sendAppend (![ptrT] "r")) "$a0"))
      ) in
    (tracker.ProgressTracker__Visit (struct.field_ref raft "trk" (![ptrT] "r"))) "$a0")).

Definition StateLeader : expr := #(W64 2).

(* go: state_trace_nop.go:38:6 *)
Definition traceBecomeFollower : val :=
  rec: "traceBecomeFollower" "" :=
    exception_do (let: "" := (ref_ty ptrT "") in
    do:  #()).

Definition StateFollower : expr := #(W64 0).

Definition tickElectionId : expr := #(W64 0).

Definition ReadOnlyOption : go_type := intT.

Definition readOnly : go_type := structT [
  "option" :: ReadOnlyOption;
  "pendingReadIndex" :: mapT stringT ptrT;
  "readIndexQueue" :: sliceT
].

(* go: read_only.go:45:6 *)
Definition newReadOnly : val :=
  rec: "newReadOnly" "option" :=
    exception_do (let: "option" := (ref_ty ReadOnlyOption "option") in
    return: (ref_ty readOnly (struct.make readOnly [{
       "option" ::= ![ReadOnlyOption] "option";
       "pendingReadIndex" ::= map.make stringT ptrT #()
     }]))).

Definition lockedRand : go_type := structT [
  "mu" :: sync.Mutex
].

(* go: raft.go:95:22 *)
Definition lockedRand__Intn : val :=
  rec: "lockedRand__Intn" "r" "n" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "n" := (ref_ty intT "n") in
    do:  ((sync.Mutex__Lock (struct.field_ref lockedRand "mu" (![ptrT] "r"))) #());;;
    let: "v" := (ref_ty ptrT (zero_val ptrT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := "global:Reader" in
    let: "$a1" := (let: "$a0" := (![intT] "n") in
    big.NewInt "$a0") in
    rand.Int "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("v" <-[ptrT] "$r0");;;
    do:  "$r1";;;
    do:  ((sync.Mutex__Unlock (struct.field_ref lockedRand "mu" (![ptrT] "r"))) #());;;
    return: ((big.Int__Int64 (![ptrT] "v")) #())).

(* go: raft.go:2074:16 *)
Definition raft__resetRandomizedElectionTimeout : val :=
  rec: "raft__resetRandomizedElectionTimeout" "r" <> :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "$r0" := ((![intT] (struct.field_ref raft "electionTimeout" (![ptrT] "r"))) + (let: "$a0" := (![intT] (struct.field_ref raft "electionTimeout" (![ptrT] "r"))) in
    (lockedRand__Intn (![ptrT] "globalRand")) "$a0")) in
    do:  ((struct.field_ref raft "randomizedElectionTimeout" (![ptrT] "r")) <-[intT] "$r0")).

(* go: raft.go:792:16 *)
Definition raft__reset : val :=
  rec: "raft__reset" "r" "term" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "term" := (ref_ty uint64T "term") in
    (if: (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r"))) ≠ (![uint64T] "term")
    then
      let: "$r0" := (![uint64T] "term") in
      do:  ((struct.field_ref raft "Term" (![ptrT] "r")) <-[uint64T] "$r0");;;
      let: "$r0" := None in
      do:  ((struct.field_ref raft "Vote" (![ptrT] "r")) <-[uint64T] "$r0")
    else do:  #());;;
    let: "$r0" := None in
    do:  ((struct.field_ref raft "lead" (![ptrT] "r")) <-[uint64T] "$r0");;;
    let: "$r0" := #(W64 0) in
    do:  ((struct.field_ref raft "electionElapsed" (![ptrT] "r")) <-[intT] "$r0");;;
    let: "$r0" := #(W64 0) in
    do:  ((struct.field_ref raft "heartbeatElapsed" (![ptrT] "r")) <-[intT] "$r0");;;
    do:  ((raft__resetRandomizedElectionTimeout (![ptrT] "r")) #());;;
    do:  ((raft__abortLeaderTransfer (![ptrT] "r")) #());;;
    do:  ((tracker.ProgressTracker__ResetVotes (struct.field_ref raft "trk" (![ptrT] "r"))) #());;;
    do:  (let: "$a0" := (λ: "id" "pr",
      exception_do (let: "pr" := (ref_ty ptrT "pr") in
      let: "id" := (ref_ty uint64T "id") in
      let: "$r0" := (struct.make tracker.Progress [{
        "Match" ::= #(W64 0);
        "Next" ::= ((raftLog__lastIndex (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()) + #(W64 1);
        "Inflights" ::= let: "$a0" := (![intT] (struct.field_ref tracker.ProgressTracker "MaxInflight" (struct.field_ref raft "trk" (![ptrT] "r")))) in
        let: "$a1" := (![uint64T] (struct.field_ref tracker.ProgressTracker "MaxInflightBytes" (struct.field_ref raft "trk" (![ptrT] "r")))) in
        tracker.NewInflights "$a0" "$a1";
        "IsLearner" ::= ![boolT] (struct.field_ref tracker.Progress "IsLearner" (![ptrT] "pr"))
      }]) in
      do:  ((![ptrT] "pr") <-[tracker.Progress] "$r0");;;
      (if: (![uint64T] "id") = (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))
      then
        let: "$r0" := ((raftLog__lastIndex (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()) in
        do:  ((struct.field_ref tracker.Progress "Match" (![ptrT] "pr")) <-[uint64T] "$r0")
      else do:  #()))
      ) in
    (tracker.ProgressTracker__Visit (struct.field_ref raft "trk" (![ptrT] "r"))) "$a0");;;
    let: "$r0" := #(W64 0) in
    do:  ((struct.field_ref raft "pendingConfIndex" (![ptrT] "r")) <-[uint64T] "$r0");;;
    let: "$r0" := #(W64 0) in
    do:  ((struct.field_ref raft "uncommittedSize" (![ptrT] "r")) <-[entryPayloadSize] "$r0");;;
    let: "$r0" := (let: "$a0" := (![ReadOnlyOption] (struct.field_ref readOnly "option" (![ptrT] (struct.field_ref raft "readOnly" (![ptrT] "r"))))) in
    newReadOnly "$a0") in
    do:  ((struct.field_ref raft "readOnly" (![ptrT] "r")) <-[ptrT] "$r0")).

(* go: raft.go:909:16 *)
Definition raft__becomeFollower : val :=
  rec: "raft__becomeFollower" "r" "term" "lead" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "lead" := (ref_ty uint64T "lead") in
    let: "term" := (ref_ty uint64T "term") in
    let: "$r0" := (![funcT] "stepFollowerGlobal") in
    do:  ((struct.field_ref raft "step" (![ptrT] "r")) <-[funcT] "$r0");;;
    do:  (let: "$a0" := (![uint64T] "term") in
    (raft__reset (![ptrT] "r")) "$a0");;;
    let: "$r0" := tickElectionId in
    do:  ((struct.field_ref raft "tickId" (![ptrT] "r")) <-[intT] "$r0");;;
    let: "$r0" := (![uint64T] "lead") in
    do:  ((struct.field_ref raft "lead" (![ptrT] "r")) <-[uint64T] "$r0");;;
    let: "$r0" := StateFollower in
    do:  ((struct.field_ref raft "state" (![ptrT] "r")) <-[StateType] "$r0");;;
    do:  (let: "$a0" := #"%x became follower at term %d" in
    let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
    let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
    slice.literal interfaceT ["$sl0"; "$sl1"])) in
    (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
    do:  (let: "$a0" := (![ptrT] "r") in
    traceBecomeFollower "$a0")).

(* go: state_trace_nop.go:46:6 *)
Definition traceConfChangeEvent : val :=
  rec: "traceConfChangeEvent" "" "" :=
    exception_do (let: "" := (ref_ty ptrT "") in
    let: "" := (ref_ty tracker.Config "") in
    do:  #()).

(* switchToConfig reconfigures this node to use the provided configuration. It
   updates the in-memory state and, when necessary, carries out additional
   actions such as reacting to the removal of nodes or changed quorum
   requirements.

   The inputs usually result from restoring a ConfState or applying a ConfChange.

   go: raft.go:2000:16 *)
Definition raft__switchToConfig : val :=
  rec: "raft__switchToConfig" "r" "cfg" "trk" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "trk" := (ref_ty tracker.ProgressMap "trk") in
    let: "cfg" := (ref_ty tracker.Config "cfg") in
    do:  (let: "$a0" := (![tracker.Config] "cfg") in
    let: "$a1" := (![ptrT] "r") in
    traceConfChangeEvent "$a0" "$a1");;;
    let: "$r0" := (![tracker.Config] "cfg") in
    do:  ((struct.field_ref tracker.ProgressTracker "Config" (struct.field_ref raft "trk" (![ptrT] "r"))) <-[tracker.Config] "$r0");;;
    let: "$r0" := (![tracker.ProgressMap] "trk") in
    do:  ((struct.field_ref tracker.ProgressTracker "Progress" (struct.field_ref raft "trk" (![ptrT] "r"))) <-[tracker.ProgressMap] "$r0");;;
    do:  (let: "$a0" := #"%x switched to configuration %s" in
    let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
    let: "$sl1" := (interface.make tracker.Config__mset (![tracker.Config] (struct.field_ref tracker.ProgressTracker "Config" (struct.field_ref raft "trk" (![ptrT] "r"))))) in
    slice.literal interfaceT ["$sl0"; "$sl1"])) in
    (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
    let: "cs" := (ref_ty raftpb.ConfState (zero_val raftpb.ConfState)) in
    let: "$r0" := ((tracker.ProgressTracker__ConfState (struct.field_ref raft "trk" (![ptrT] "r"))) #()) in
    do:  ("cs" <-[raftpb.ConfState] "$r0");;;
    let: "ok" := (ref_ty boolT (zero_val boolT)) in
    let: "pr" := (ref_ty ptrT (zero_val ptrT)) in
    let: ("$ret0", "$ret1") := (map.get (![tracker.ProgressMap] (struct.field_ref tracker.ProgressTracker "Progress" (struct.field_ref raft "trk" (![ptrT] "r")))) (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("pr" <-[ptrT] "$r0");;;
    do:  ("ok" <-[boolT] "$r1");;;
    let: "$r0" := ((![boolT] "ok") && (![boolT] (struct.field_ref tracker.Progress "IsLearner" (![ptrT] "pr")))) in
    do:  ((struct.field_ref raft "isLearner" (![ptrT] "r")) <-[boolT] "$r0");;;
    (if: ((~ (![boolT] "ok")) || (![boolT] (struct.field_ref raft "isLearner" (![ptrT] "r")))) && ((![StateType] (struct.field_ref raft "state" (![ptrT] "r"))) = StateLeader)
    then
      (if: ![boolT] (struct.field_ref raft "stepDownOnRemoval" (![ptrT] "r"))
      then
        do:  (let: "$a0" := (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r"))) in
        let: "$a1" := None in
        (raft__becomeFollower (![ptrT] "r")) "$a0" "$a1")
      else do:  #());;;
      return: (![raftpb.ConfState] "cs")
    else do:  #());;;
    (if: ((![StateType] (struct.field_ref raft "state" (![ptrT] "r"))) ≠ StateLeader) || ((let: "$a0" := (![sliceT] (struct.field_ref raftpb.ConfState "Voters" "cs")) in
    slice.len "$a0") = #(W64 0))
    then return: (![raftpb.ConfState] "cs")
    else do:  #());;;
    (if: (raft__maybeCommit (![ptrT] "r")) #()
    then do:  ((raft__bcastAppend (![ptrT] "r")) #())
    else
      do:  (let: "$a0" := (λ: "id" <>,
        exception_do (let: <> := (ref_ty ptrT "_") in
        let: "id" := (ref_ty uint64T "id") in
        (if: (![uint64T] "id") = (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))
        then return: (#())
        else do:  #());;;
        do:  (let: "$a0" := (![uint64T] "id") in
        let: "$a1" := #false in
        (raft__maybeSendAppend (![ptrT] "r")) "$a0" "$a1"))
        ) in
      (tracker.ProgressTracker__Visit (struct.field_ref raft "trk" (![ptrT] "r"))) "$a0"));;;
    (let: "tOK" := (ref_ty boolT (zero_val boolT)) in
    let: ("$ret0", "$ret1") := (map.get ((quorum.JointConfig__IDs (![quorum.JointConfig] (struct.field_ref tracker.Config "Voters" (struct.field_ref tracker.ProgressTracker "Config" (struct.field_ref raft "trk" (![ptrT] "r")))))) #()) (![uint64T] (struct.field_ref raft "leadTransferee" (![ptrT] "r")))) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  "$r0";;;
    do:  ("tOK" <-[boolT] "$r1");;;
    (if: (~ (![boolT] "tOK")) && ((![uint64T] (struct.field_ref raft "leadTransferee" (![ptrT] "r"))) ≠ #(W64 0))
    then do:  ((raft__abortLeaderTransfer (![ptrT] "r")) #())
    else do:  #()));;;
    return: (![raftpb.ConfState] "cs")).

(* go: raft.go:1972:16 *)
Definition raft__applyConfChange : val :=
  rec: "raft__applyConfChange" "r" "cc" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "cc" := (ref_ty raftpb.ConfChangeV2 "cc") in
    let: "err" := (ref_ty error (zero_val error)) in
    let: "trk" := (ref_ty tracker.ProgressMap (zero_val tracker.ProgressMap)) in
    let: "cfg" := (ref_ty tracker.Config (zero_val tracker.Config)) in
    let: (("$ret0", "$ret1"), "$ret2") := ((λ: <>,
      exception_do (let: "changer" := (ref_ty confchange.Changer (zero_val confchange.Changer)) in
      let: "$r0" := (struct.make confchange.Changer [{
        "Tracker" ::= ![tracker.ProgressTracker] (struct.field_ref raft "trk" (![ptrT] "r"));
        "LastIndex" ::= (raftLog__lastIndex (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()
      }]) in
      do:  ("changer" <-[confchange.Changer] "$r0");;;
      (if: (raftpb.ConfChangeV2__LeaveJoint (![raftpb.ConfChangeV2] "cc")) #()
      then
        let: (("$ret0", "$ret1"), "$ret2") := (((confchange.Changer__LeaveJoint (![confchange.Changer] "changer")) #())) in
        return: ("$ret0", "$ret1", "$ret2")
      else
        (let: "ok" := (ref_ty boolT (zero_val boolT)) in
        let: "autoLeave" := (ref_ty boolT (zero_val boolT)) in
        let: ("$ret0", "$ret1") := ((raftpb.ConfChangeV2__EnterJoint (![raftpb.ConfChangeV2] "cc")) #()) in
        let: "$r0" := "$ret0" in
        let: "$r1" := "$ret1" in
        do:  ("autoLeave" <-[boolT] "$r0");;;
        do:  ("ok" <-[boolT] "$r1");;;
        (if: ![boolT] "ok"
        then
          let: (("$ret0", "$ret1"), "$ret2") := ((let: "$a0" := (![boolT] "autoLeave") in
          let: "$a1" := (![sliceT] (struct.field_ref raftpb.ConfChangeV2 "Changes" "cc")) in
          (confchange.Changer__EnterJoint (![confchange.Changer] "changer")) "$a0" "$a1")) in
          return: ("$ret0", "$ret1", "$ret2")
        else do:  #())));;;
      let: (("$ret0", "$ret1"), "$ret2") := ((let: "$a0" := (![sliceT] (struct.field_ref raftpb.ConfChangeV2 "Changes" "cc")) in
      (confchange.Changer__Simple (![confchange.Changer] "changer")) "$a0")) in
      return: ("$ret0", "$ret1", "$ret2"))
      ) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("cfg" <-[tracker.Config] "$r0");;;
    do:  ("trk" <-[tracker.ProgressMap] "$r1");;;
    do:  ("err" <-[error] "$r2");;;
    (if: (![error] "err") ≠ #interface.nil
    then
      do:  (let: "$a0" := (![error] "err") in
      Panic "$a0")
    else do:  #());;;
    return: (let: "$a0" := (![tracker.Config] "cfg") in
     let: "$a1" := (![tracker.ProgressMap] "trk") in
     (raft__switchToConfig (![ptrT] "r")) "$a0" "$a1")).

(* go: log_unstable.go:197:20 *)
Definition unstable__truncateAndAppend : val :=
  rec: "unstable__truncateAndAppend" "u" "ents" :=
    exception_do (let: "u" := (ref_ty ptrT "u") in
    let: "ents" := (ref_ty sliceT "ents") in
    let: "fromIndex" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (![uint64T] (struct.field_ref raftpb.Entry "Index" (slice.elem_ref raftpb.Entry (![sliceT] "ents") #(W64 0)))) in
    do:  ("fromIndex" <-[uint64T] "$r0");;;
    let: "$sw" := #true in
    (if: "$sw" = ((![uint64T] "fromIndex") = ((![uint64T] (struct.field_ref unstable "offset" (![ptrT] "u"))) + (let: "$a0" := (![sliceT] (struct.field_ref unstable "entries" (![ptrT] "u"))) in
    slice.len "$a0")))
    then
      let: "$r0" := (let: "$a0" := (![sliceT] (struct.field_ref unstable "entries" (![ptrT] "u"))) in
      let: "$a1" := (![sliceT] "ents") in
      (slice.append sliceT) "$a0" "$a1") in
      do:  ((struct.field_ref unstable "entries" (![ptrT] "u")) <-[sliceT] "$r0")
    else
      (if: "$sw" = ((![uint64T] "fromIndex") ≤ (![uint64T] (struct.field_ref unstable "offset" (![ptrT] "u"))))
      then
        do:  (let: "$a0" := #"replace the unstable entries from index %d" in
        let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] "fromIndex")) in
        slice.literal interfaceT ["$sl0"])) in
        (interface.get "Infof" (![Logger] (struct.field_ref unstable "logger" (![ptrT] "u")))) "$a0" "$a1");;;
        let: "$r0" := (![sliceT] "ents") in
        do:  ((struct.field_ref unstable "entries" (![ptrT] "u")) <-[sliceT] "$r0");;;
        let: "$r0" := (![uint64T] "fromIndex") in
        do:  ((struct.field_ref unstable "offset" (![ptrT] "u")) <-[uint64T] "$r0");;;
        let: "$r0" := (![uint64T] (struct.field_ref unstable "offset" (![ptrT] "u"))) in
        do:  ((struct.field_ref unstable "offsetInProgress" (![ptrT] "u")) <-[uint64T] "$r0")
      else
        do:  (let: "$a0" := #"truncate the unstable entries before index %d" in
        let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] "fromIndex")) in
        slice.literal interfaceT ["$sl0"])) in
        (interface.get "Infof" (![Logger] (struct.field_ref unstable "logger" (![ptrT] "u")))) "$a0" "$a1");;;
        let: "keep" := (ref_ty sliceT (zero_val sliceT)) in
        let: "$r0" := (let: "$a0" := (![uint64T] (struct.field_ref unstable "offset" (![ptrT] "u"))) in
        let: "$a1" := (![uint64T] "fromIndex") in
        (unstable__slice (![ptrT] "u")) "$a0" "$a1") in
        do:  ("keep" <-[sliceT] "$r0");;;
        let: "$r0" := (let: "$a0" := (![sliceT] "keep") in
        let: "$a1" := (![sliceT] "ents") in
        (slice.append sliceT) "$a0" "$a1") in
        do:  ((struct.field_ref unstable "entries" (![ptrT] "u")) <-[sliceT] "$r0");;;
        let: "$r0" := (let: "$a0" := (![uint64T] (struct.field_ref unstable "offsetInProgress" (![ptrT] "u"))) in
        let: "$a1" := (![uint64T] "fromIndex") in
        (minUint64 2) "$a0" "$a1") in
        do:  ((struct.field_ref unstable "offsetInProgress" (![ptrT] "u")) <-[uint64T] "$r0")))).

(* go: log.go:132:19 *)
Definition raftLog__append : val :=
  rec: "raftLog__append" "l" "ents" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "ents" := (ref_ty sliceT "ents") in
    (if: (let: "$a0" := (![sliceT] "ents") in
    slice.len "$a0") = #(W64 0)
    then return: ((raftLog__lastIndex (![ptrT] "l")) #())
    else do:  #());;;
    (let: "after" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := ((![uint64T] (struct.field_ref raftpb.Entry "Index" (slice.elem_ref raftpb.Entry (![sliceT] "ents") #(W64 0)))) - #(W64 1)) in
    do:  ("after" <-[uint64T] "$r0");;;
    (if: (![uint64T] "after") < (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] "l")))
    then
      do:  (let: "$a0" := #"after(%d) is out of range [committed(%d)]" in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] "after")) in
      let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] "l")))) in
      slice.literal interfaceT ["$sl0"; "$sl1"])) in
      (interface.get "Panicf" (![Logger] (struct.field_ref raftLog "logger" (![ptrT] "l")))) "$a0" "$a1")
    else do:  #()));;;
    do:  (let: "$a0" := (![sliceT] "ents") in
    (unstable__truncateAndAppend (struct.field_ref raftLog "unstable" (![ptrT] "l"))) "$a0");;;
    return: ((raftLog__lastIndex (![ptrT] "l")) #())).

(* Bootstrap initializes the RawNode for first use by appending configuration
   changes for the supplied peers. This method returns an error if the Storage
   is nonempty.

   It is recommended that instead of calling this method, applications bootstrap
   their state manually by setting up a Storage that has a first index > 1 and
   which stores the desired ConfState as its InitialState.

   go: bootstrap.go:30:20 *)
Definition RawNode__Bootstrap : val :=
  rec: "RawNode__Bootstrap" "rn" "peers" :=
    exception_do (let: "rn" := (ref_ty ptrT "rn") in
    let: "peers" := (ref_ty sliceT "peers") in
    (if: (let: "$a0" := (![sliceT] "peers") in
    slice.len "$a0") = #(W64 0)
    then
      return: (let: "$a0" := #"must provide at least one peer to Bootstrap" in
       errors.New "$a0")
    else do:  #());;;
    let: "err" := (ref_ty error (zero_val error)) in
    let: "lastIndex" := (ref_ty uint64T (zero_val uint64T)) in
    let: ("$ret0", "$ret1") := ((interface.get "LastIndex" (![Storage] (struct.field_ref raftLog "storage" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))))))) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("lastIndex" <-[uint64T] "$r0");;;
    do:  ("err" <-[error] "$r1");;;
    (if: (![error] "err") ≠ #interface.nil
    then return: (![error] "err")
    else do:  #());;;
    (if: (![uint64T] "lastIndex") ≠ #(W64 0)
    then
      return: (let: "$a0" := #"can't bootstrap a nonempty Storage" in
       errors.New "$a0")
    else do:  #());;;
    let: "$r0" := (![raftpb.HardState] "emptyState") in
    do:  ((struct.field_ref RawNode "prevHardSt" (![ptrT] "rn")) <-[raftpb.HardState] "$r0");;;
    do:  (let: "$a0" := #(W64 1) in
    let: "$a1" := None in
    (raft__becomeFollower (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))) "$a0" "$a1");;;
    let: "ents" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (slice.make2 raftpb.Entry (let: "$a0" := (![sliceT] "peers") in
    slice.len "$a0")) in
    do:  ("ents" <-[sliceT] "$r0");;;
    do:  (let: "$range" := (![sliceT] "peers") in
    slice.for_range Peer "$range" (λ: "i" "peer",
      let: "i" := ref_ty uint64T "i" in
      let: "peer" := ref_ty Peer "peer" in
      let: "cc" := (ref_ty raftpb.ConfChange (zero_val raftpb.ConfChange)) in
      let: "$r0" := (struct.make raftpb.ConfChange [{
        "Type" ::= raftpb.ConfChangeAddNode;
        "NodeID" ::= ![uint64T] (struct.field_ref Peer "ID" "peer");
        "Context" ::= ![sliceT] (struct.field_ref Peer "Context" "peer")
      }]) in
      do:  ("cc" <-[raftpb.ConfChange] "$r0");;;
      let: "err" := (ref_ty error (zero_val error)) in
      let: "data" := (ref_ty sliceT (zero_val sliceT)) in
      let: ("$ret0", "$ret1") := ((raftpb.ConfChange__Marshal "cc") #()) in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("data" <-[sliceT] "$r0");;;
      do:  ("err" <-[error] "$r1");;;
      (if: (![error] "err") ≠ #interface.nil
      then return: (![error] "err")
      else do:  #());;;
      let: "$r0" := (struct.make raftpb.Entry [{
        "Type" ::= raftpb.EntryConfChange;
        "Term" ::= #(W64 1);
        "Index" ::= (![intT] "i") + #(W64 1);
        "Data" ::= ![sliceT] "data"
      }]) in
      do:  ((slice.elem_ref raftpb.Entry (![sliceT] "ents") (![intT] "i")) <-[raftpb.Entry] "$r0")));;;
    do:  (let: "$a0" := (![sliceT] "ents") in
    (raftLog__append (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))))) "$a0");;;
    let: "$r0" := (let: "$a0" := (![sliceT] "ents") in
    slice.len "$a0") in
    do:  ((struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))))) <-[uint64T] "$r0");;;
    do:  (let: "$range" := (![sliceT] "peers") in
    slice.for_range Peer "$range" (λ: <> "peer",
      let: "peer" := ref_ty Peer "peer" in
      do:  (let: "$a0" := ((raftpb.ConfChange__AsV2 (struct.make raftpb.ConfChange [{
        "NodeID" ::= ![uint64T] (struct.field_ref Peer "ID" "peer");
        "Type" ::= raftpb.ConfChangeAddNode
      }])) #()) in
      (raft__applyConfChange (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))) "$a0")));;;
    return: (#interface.nil)).

Definition raftLog__mset : list (string * val) := [
].

(* go: log.go:100:19 *)
Definition raftLog__String : val :=
  rec: "raftLog__String" "l" <> :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    return: (let: "$a0" := #"committed=%d, applied=%d, applying=%d, unstable.offset=%d, unstable.offsetInProgress=%d, len(unstable.Entries)=%d" in
     let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] "l")))) in
     let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftLog "applied" (![ptrT] "l")))) in
     let: "$sl2" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftLog "applying" (![ptrT] "l")))) in
     let: "$sl3" := (interface.make uint64__mset (![uint64T] (struct.field_ref unstable "offset" (struct.field_ref raftLog "unstable" (![ptrT] "l"))))) in
     let: "$sl4" := (interface.make uint64__mset (![uint64T] (struct.field_ref unstable "offsetInProgress" (struct.field_ref raftLog "unstable" (![ptrT] "l"))))) in
     let: "$sl5" := (interface.make int__mset (let: "$a0" := (![sliceT] (struct.field_ref unstable "entries" (struct.field_ref raftLog "unstable" (![ptrT] "l")))) in
     slice.len "$a0")) in
     slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"; "$sl4"; "$sl5"])) in
     fmt.Sprintf "$a0" "$a1")).

(* maxAppliableIndex returns the maximum committed index that can be applied.
   If allowUnstable is true, committed entries from the unstable log can be
   applied; otherwise, only entries known to reside locally on stable storage
   can be applied.

   go: log.go:267:19 *)
Definition raftLog__maxAppliableIndex : val :=
  rec: "raftLog__maxAppliableIndex" "l" "allowUnstable" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "allowUnstable" := (ref_ty boolT "allowUnstable") in
    let: "hi" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] "l"))) in
    do:  ("hi" <-[uint64T] "$r0");;;
    (if: (~ (![boolT] "allowUnstable"))
    then
      let: "$r0" := (let: "$a0" := (![uint64T] "hi") in
      let: "$a1" := ((![uint64T] (struct.field_ref unstable "offset" (struct.field_ref raftLog "unstable" (![ptrT] "l")))) - #(W64 1)) in
      (minUint64 2) "$a0" "$a1") in
      do:  ("hi" <-[uint64T] "$r0")
    else do:  #());;;
    return: (![uint64T] "hi")).

(* go: log.go:347:19 *)
Definition raftLog__acceptApplying : val :=
  rec: "raftLog__acceptApplying" "l" "i" "size" "allowUnstable" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "allowUnstable" := (ref_ty boolT "allowUnstable") in
    let: "size" := (ref_ty entryEncodingSize "size") in
    let: "i" := (ref_ty uint64T "i") in
    (if: (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] "l"))) < (![uint64T] "i")
    then
      do:  (let: "$a0" := #"applying(%d) is out of range [prevApplying(%d), committed(%d)]" in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] "i")) in
      let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftLog "applying" (![ptrT] "l")))) in
      let: "$sl2" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] "l")))) in
      slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
      (interface.get "Panicf" (![Logger] (struct.field_ref raftLog "logger" (![ptrT] "l")))) "$a0" "$a1")
    else do:  #());;;
    let: "$r0" := (![uint64T] "i") in
    do:  ((struct.field_ref raftLog "applying" (![ptrT] "l")) <-[uint64T] "$r0");;;
    do:  ((struct.field_ref raftLog "applyingEntsSize" (![ptrT] "l")) <-[entryEncodingSize] ((![entryEncodingSize] (struct.field_ref raftLog "applyingEntsSize" (![ptrT] "l"))) + (![entryEncodingSize] "size")));;;
    let: "$r0" := (((![entryEncodingSize] (struct.field_ref raftLog "applyingEntsSize" (![ptrT] "l"))) ≥ (![entryEncodingSize] (struct.field_ref raftLog "maxApplyingEntsSize" (![ptrT] "l")))) || ((![uint64T] "i") < (let: "$a0" := (![boolT] "allowUnstable") in
    (raftLog__maxAppliableIndex (![ptrT] "l")) "$a0"))) in
    do:  ((struct.field_ref raftLog "applyingEntsPaused" (![ptrT] "l")) <-[boolT] "$r0")).

(* acceptInProgress marks all entries and the snapshot, if any, in the unstable
   as having begun the process of being written to storage. The entries/snapshot
   will no longer be returned from nextEntries/nextSnapshot. However, new
   entries/snapshots added after a call to acceptInProgress will be returned
   from those methods, until the next call to acceptInProgress.

   go: log_unstable.go:118:20 *)
Definition unstable__acceptInProgress : val :=
  rec: "unstable__acceptInProgress" "u" <> :=
    exception_do (let: "u" := (ref_ty ptrT "u") in
    (if: int_gt (let: "$a0" := (![sliceT] (struct.field_ref unstable "entries" (![ptrT] "u"))) in
    slice.len "$a0") #(W64 0)
    then
      let: "$r0" := ((![uint64T] (struct.field_ref raftpb.Entry "Index" (slice.elem_ref raftpb.Entry (![sliceT] (struct.field_ref unstable "entries" (![ptrT] "u"))) ((let: "$a0" := (![sliceT] (struct.field_ref unstable "entries" (![ptrT] "u"))) in
      slice.len "$a0") - #(W64 1))))) + #(W64 1)) in
      do:  ((struct.field_ref unstable "offsetInProgress" (![ptrT] "u")) <-[uint64T] "$r0")
    else do:  #());;;
    (if: (![ptrT] (struct.field_ref unstable "snapshot" (![ptrT] "u"))) ≠ #null
    then
      let: "$r0" := #true in
      do:  ((struct.field_ref unstable "snapshotInProgress" (![ptrT] "u")) <-[boolT] "$r0")
    else do:  #())).

(* acceptUnstable indicates that the application has started persisting the
   unstable entries in storage, and that the current unstable entries are thus
   to be marked as being in-progress, to avoid returning them with future calls
   to Ready().

   go: log.go:375:19 *)
Definition raftLog__acceptUnstable : val :=
  rec: "raftLog__acceptUnstable" "l" <> :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    do:  ((unstable__acceptInProgress (struct.field_ref raftLog "unstable" (![ptrT] "l"))) #())).

Definition noLimit : Z := math.MaxUint64.

(* allEntries returns all entries in the log.

   go: log.go:423:19 *)
Definition raftLog__allEntries : val :=
  rec: "raftLog__allEntries" "l" <> :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "err" := (ref_ty error (zero_val error)) in
    let: "ents" := (ref_ty sliceT (zero_val sliceT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := ((raftLog__firstIndex (![ptrT] "l")) #()) in
    let: "$a1" := #(W64 noLimit) in
    (raftLog__entries (![ptrT] "l")) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("ents" <-[sliceT] "$r0");;;
    do:  ("err" <-[error] "$r1");;;
    (if: (![error] "err") = #interface.nil
    then return: (![sliceT] "ents")
    else do:  #());;;
    (if: (![error] "err") = (![error] "ErrCompacted")
    then return: (("raftLog__allEntries" (![ptrT] "l")) #())
    else do:  #());;;
    do:  (let: "$a0" := (![error] "err") in
    Panic "$a0")).

(* go: log.go:332:19 *)
Definition raftLog__appliedTo : val :=
  rec: "raftLog__appliedTo" "l" "i" "size" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "size" := (ref_ty entryEncodingSize "size") in
    let: "i" := (ref_ty uint64T "i") in
    (if: ((![uint64T] (struct.field_ref raftLog "committed" (![ptrT] "l"))) < (![uint64T] "i")) || ((![uint64T] "i") < (![uint64T] (struct.field_ref raftLog "applied" (![ptrT] "l"))))
    then
      do:  (let: "$a0" := #"applied(%d) is out of range [prevApplied(%d), committed(%d)]" in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] "i")) in
      let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftLog "applied" (![ptrT] "l")))) in
      let: "$sl2" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] "l")))) in
      slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
      (interface.get "Panicf" (![Logger] (struct.field_ref raftLog "logger" (![ptrT] "l")))) "$a0" "$a1")
    else do:  #());;;
    let: "$r0" := (![uint64T] "i") in
    do:  ((struct.field_ref raftLog "applied" (![ptrT] "l")) <-[uint64T] "$r0");;;
    let: "$r0" := (let: "$a0" := (![uint64T] (struct.field_ref raftLog "applying" (![ptrT] "l"))) in
    let: "$a1" := (![uint64T] "i") in
    (maxUint64 2) "$a0" "$a1") in
    do:  ((struct.field_ref raftLog "applying" (![ptrT] "l")) <-[uint64T] "$r0");;;
    (if: (![entryEncodingSize] (struct.field_ref raftLog "applyingEntsSize" (![ptrT] "l"))) > (![entryEncodingSize] "size")
    then do:  ((struct.field_ref raftLog "applyingEntsSize" (![ptrT] "l")) <-[entryEncodingSize] ((![entryEncodingSize] (struct.field_ref raftLog "applyingEntsSize" (![ptrT] "l"))) - (![entryEncodingSize] "size")))
    else
      let: "$r0" := #(W64 0) in
      do:  ((struct.field_ref raftLog "applyingEntsSize" (![ptrT] "l")) <-[entryEncodingSize] "$r0"));;;
    let: "$r0" := ((![entryEncodingSize] (struct.field_ref raftLog "applyingEntsSize" (![ptrT] "l"))) ≥ (![entryEncodingSize] (struct.field_ref raftLog "maxApplyingEntsSize" (![ptrT] "l")))) in
    do:  ((struct.field_ref raftLog "applyingEntsPaused" (![ptrT] "l")) <-[boolT] "$r0")).

(* go: log.go:567:19 *)
Definition raftLog__zeroTermOnOutOfBounds : val :=
  rec: "raftLog__zeroTermOnOutOfBounds" "l" "t" "err" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "err" := (ref_ty error "err") in
    let: "t" := (ref_ty uint64T "t") in
    (if: (![error] "err") = #interface.nil
    then return: (![uint64T] "t")
    else do:  #());;;
    (if: ((![error] "err") = (![error] "ErrCompacted")) || ((![error] "err") = (![error] "ErrUnavailable"))
    then return: (#(W64 0))
    else do:  #());;;
    do:  (let: "$a0" := #"unexpected error (%v)" in
    let: "$a1" := ((let: "$sl0" := (![error] "err") in
    slice.literal interfaceT ["$sl0"])) in
    (interface.get "Panicf" (![Logger] (struct.field_ref raftLog "logger" (![ptrT] "l")))) "$a0" "$a1");;;
    return: (#(W64 0))).

(* pbEntryID returns the ID of the given raftpb.Entry.

   go: types.go:34:6 *)
Definition pbEntryID : val :=
  rec: "pbEntryID" "entry" :=
    exception_do (let: "entry" := (ref_ty ptrT "entry") in
    return: (struct.make entryID [{
       "term" ::= ![uint64T] (struct.field_ref raftpb.Entry "Term" (![ptrT] "entry"));
       "index" ::= ![uint64T] (struct.field_ref raftpb.Entry "Index" (![ptrT] "entry"))
     }])).

(* findConflict finds the index of the conflict.
   It returns the first pair of conflicting entries between the existing
   entries and the given entries, if there are any.
   If there is no conflicting entries, and the existing entries contains
   all the given entries, zero will be returned.
   If there is no conflicting entries, but the given entries contains new
   entries, the index of the first new entry will be returned.
   An entry is considered to be conflicting if it has the same index but
   a different term.
   The index of the given entries MUST be continuously increasing.

   go: log.go:153:19 *)
Definition raftLog__findConflict : val :=
  rec: "raftLog__findConflict" "l" "ents" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "ents" := (ref_ty sliceT "ents") in
    do:  (let: "$range" := (![sliceT] "ents") in
    slice.for_range raftpb.Entry "$range" (λ: "i" <>,
      let: "i" := ref_ty uint64T "i" in
      (let: "id" := (ref_ty entryID (zero_val entryID)) in
      let: "$r0" := (let: "$a0" := (slice.elem_ref raftpb.Entry (![sliceT] "ents") (![intT] "i")) in
      pbEntryID "$a0") in
      do:  ("id" <-[entryID] "$r0");;;
      (if: (~ (let: "$a0" := (![entryID] "id") in
      (raftLog__matchTerm (![ptrT] "l")) "$a0"))
      then
        (if: (![uint64T] (struct.field_ref entryID "index" "id")) ≤ ((raftLog__lastIndex (![ptrT] "l")) #())
        then
          do:  (let: "$a0" := #"found conflict at index %d [existing term: %d, conflicting term: %d]" in
          let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref entryID "index" "id"))) in
          let: "$sl1" := (interface.make uint64__mset (let: ("$ret0", "$ret1") := ((let: "$a0" := (![uint64T] (struct.field_ref entryID "index" "id")) in
          (raftLog__term (![ptrT] "l")) "$a0")) in
          let: "$a0" := "$ret0" in
          let: "$a1" := "$ret1" in
          (raftLog__zeroTermOnOutOfBounds (![ptrT] "l")) "$a0" "$a1")) in
          let: "$sl2" := (interface.make uint64__mset (![uint64T] (struct.field_ref entryID "term" "id"))) in
          slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
          (interface.get "Infof" (![Logger] (struct.field_ref raftLog "logger" (![ptrT] "l")))) "$a0" "$a1")
        else do:  #());;;
        return: (![uint64T] (struct.field_ref entryID "index" "id"))
      else do:  #()))));;;
    return: (#(W64 0))).

(* findConflictByTerm returns a best guess on where this log ends matching
   another log, given that the only information known about the other log is the
   (index, term) of its single entry.

   Specifically, the first returned value is the max guessIndex <= index, such
   that term(guessIndex) <= term or term(guessIndex) is not known (because this
   index is compacted or not yet stored).

   The second returned value is the term(guessIndex), or 0 if it is unknown.

   This function is used by a follower and leader to resolve log conflicts after
   an unsuccessful append to a follower, and ultimately restore the steady flow
   of appends.

   go: log.go:181:19 *)
Definition raftLog__findConflictByTerm : val :=
  rec: "raftLog__findConflictByTerm" "l" "index" "term" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "term" := (ref_ty uint64T "term") in
    let: "index" := (ref_ty uint64T "index") in
    (for: (λ: <>, (![uint64T] "index") > #(W64 0)); (λ: <>, do:  ("index" <-[uint64T] ((![uint64T] "index") - #(W64 1)))) := λ: <>,
      (let: "err" := (ref_ty error (zero_val error)) in
      let: "ourTerm" := (ref_ty uint64T (zero_val uint64T)) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![uint64T] "index") in
      (raftLog__term (![ptrT] "l")) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("ourTerm" <-[uint64T] "$r0");;;
      do:  ("err" <-[error] "$r1");;;
      (if: (![error] "err") ≠ #interface.nil
      then return: (![uint64T] "index", #(W64 0))
      else
        (if: (![uint64T] "ourTerm") ≤ (![uint64T] "term")
        then return: (![uint64T] "index", ![uint64T] "ourTerm")
        else do:  #()))));;;
    return: (#(W64 0), #(W64 0))).

(* hasNextOrInProgressSnapshot returns if there is pending snapshot waiting for
   applying or in the process of being applied.

   go: log.go:289:19 *)
Definition raftLog__hasNextOrInProgressSnapshot : val :=
  rec: "raftLog__hasNextOrInProgressSnapshot" "l" <> :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    return: ((![ptrT] (struct.field_ref unstable "snapshot" (struct.field_ref raftLog "unstable" (![ptrT] "l")))) ≠ #null)).

(* hasNextCommittedEnts returns if there is any available entries for execution.
   This is a fast check without heavy raftLog.slice() in nextCommittedEnts().

   go: log.go:248:19 *)
Definition raftLog__hasNextCommittedEnts : val :=
  rec: "raftLog__hasNextCommittedEnts" "l" "allowUnstable" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "allowUnstable" := (ref_ty boolT "allowUnstable") in
    (if: ![boolT] (struct.field_ref raftLog "applyingEntsPaused" (![ptrT] "l"))
    then return: (#false)
    else do:  #());;;
    (if: (raftLog__hasNextOrInProgressSnapshot (![ptrT] "l")) #()
    then return: (#false)
    else do:  #());;;
    let: "hi" := (ref_ty uint64T (zero_val uint64T)) in
    let: "lo" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := ((![uint64T] (struct.field_ref raftLog "applying" (![ptrT] "l"))) + #(W64 1)) in
    let: "$r1" := ((let: "$a0" := (![boolT] "allowUnstable") in
    (raftLog__maxAppliableIndex (![ptrT] "l")) "$a0") + #(W64 1)) in
    do:  ("lo" <-[uint64T] "$r0");;;
    do:  ("hi" <-[uint64T] "$r1");;;
    return: ((![uint64T] "lo") < (![uint64T] "hi"))).

(* hasNextOrInProgressUnstableEnts returns if there are any entries that are
   available to be written to the local stable log or in the process of being
   written to the local stable log.

   go: log.go:210:19 *)
Definition raftLog__hasNextOrInProgressUnstableEnts : val :=
  rec: "raftLog__hasNextOrInProgressUnstableEnts" "l" <> :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    return: (int_gt (let: "$a0" := (![sliceT] (struct.field_ref unstable "entries" (struct.field_ref raftLog "unstable" (![ptrT] "l")))) in
     slice.len "$a0") #(W64 0))).

(* nextEntries returns the unstable entries that are not already in the process
   of being written to storage.

   go: log_unstable.go:96:20 *)
Definition unstable__nextEntries : val :=
  rec: "unstable__nextEntries" "u" <> :=
    exception_do (let: "u" := (ref_ty ptrT "u") in
    let: "inProgress" := (ref_ty intT (zero_val intT)) in
    let: "$r0" := ((![uint64T] (struct.field_ref unstable "offsetInProgress" (![ptrT] "u"))) - (![uint64T] (struct.field_ref unstable "offset" (![ptrT] "u")))) in
    do:  ("inProgress" <-[intT] "$r0");;;
    (if: (let: "$a0" := (![sliceT] (struct.field_ref unstable "entries" (![ptrT] "u"))) in
    slice.len "$a0") = (![intT] "inProgress")
    then return: (#slice.nil)
    else do:  #());;;
    return: (let: "$s" := (![sliceT] (struct.field_ref unstable "entries" (![ptrT] "u"))) in
     slice.slice raftpb.Entry "$s" (![intT] "inProgress") (slice.len "$s"))).

(* nextUnstableEnts returns all entries that are available to be written to the
   local stable log and are not already in-progress.

   go: log.go:197:19 *)
Definition raftLog__nextUnstableEnts : val :=
  rec: "raftLog__nextUnstableEnts" "l" <> :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    return: ((unstable__nextEntries (struct.field_ref raftLog "unstable" (![ptrT] "l"))) #())).

(* hasNextUnstableEnts returns if there are any entries that are available to be
   written to the local stable log and are not already in-progress.

   go: log.go:203:19 *)
Definition raftLog__hasNextUnstableEnts : val :=
  rec: "raftLog__hasNextUnstableEnts" "l" <> :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    return: (int_gt (let: "$a0" := ((raftLog__nextUnstableEnts (![ptrT] "l")) #()) in
     slice.len "$a0") #(W64 0))).

(* nextSnapshot returns the unstable snapshot, if one exists that is not already
   in the process of being written to storage.

   go: log_unstable.go:106:20 *)
Definition unstable__nextSnapshot : val :=
  rec: "unstable__nextSnapshot" "u" <> :=
    exception_do (let: "u" := (ref_ty ptrT "u") in
    (if: ((![ptrT] (struct.field_ref unstable "snapshot" (![ptrT] "u"))) = #null) || (![boolT] (struct.field_ref unstable "snapshotInProgress" (![ptrT] "u")))
    then return: (#null)
    else do:  #());;;
    return: (![ptrT] (struct.field_ref unstable "snapshot" (![ptrT] "u")))).

(* hasNextUnstableSnapshot returns if there is a snapshot that is available to
   be applied to the local storage and is not already in-progress.

   go: log.go:283:19 *)
Definition raftLog__hasNextUnstableSnapshot : val :=
  rec: "raftLog__hasNextUnstableSnapshot" "l" <> :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    return: (((unstable__nextSnapshot (struct.field_ref raftLog "unstable" (![ptrT] "l"))) #()) ≠ #null)).

(* lastEntryID returns the ID of the last entry in the log.

   go: log.go:378:19 *)
Definition raftLog__lastEntryID : val :=
  rec: "raftLog__lastEntryID" "l" <> :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "index" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := ((raftLog__lastIndex (![ptrT] "l")) #()) in
    do:  ("index" <-[uint64T] "$r0");;;
    let: "err" := (ref_ty error (zero_val error)) in
    let: "t" := (ref_ty uint64T (zero_val uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![uint64T] "index") in
    (raftLog__term (![ptrT] "l")) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("t" <-[uint64T] "$r0");;;
    do:  ("err" <-[error] "$r1");;;
    (if: (![error] "err") ≠ #interface.nil
    then
      do:  (let: "$a0" := #"unexpected error when getting the last term at %d: %v" in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] "index")) in
      let: "$sl1" := (![error] "err") in
      slice.literal interfaceT ["$sl0"; "$sl1"])) in
      (interface.get "Panicf" (![Logger] (struct.field_ref raftLog "logger" (![ptrT] "l")))) "$a0" "$a1")
    else do:  #());;;
    return: (struct.make entryID [{
       "term" ::= ![uint64T] "t";
       "index" ::= ![uint64T] "index"
     }])).

(* isUpToDate determines if a log with the given last entry is more up-to-date
   by comparing the index and term of the last entries in the existing logs.

   If the logs have last entries with different terms, then the log with the
   later term is more up-to-date. If the logs end with the same term, then
   whichever log has the larger lastIndex is more up-to-date. If the logs are
   the same, the given log is up-to-date.

   go: log.go:442:19 *)
Definition raftLog__isUpToDate : val :=
  rec: "raftLog__isUpToDate" "l" "their" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "their" := (ref_ty entryID "their") in
    let: "our" := (ref_ty entryID (zero_val entryID)) in
    let: "$r0" := ((raftLog__lastEntryID (![ptrT] "l")) #()) in
    do:  ("our" <-[entryID] "$r0");;;
    return: (((![uint64T] (struct.field_ref entryID "term" "their")) > (![uint64T] (struct.field_ref entryID "term" "our"))) || (((![uint64T] (struct.field_ref entryID "term" "their")) = (![uint64T] (struct.field_ref entryID "term" "our"))) && ((![uint64T] (struct.field_ref entryID "index" "their")) ≥ (![uint64T] (struct.field_ref entryID "index" "our")))))).

Definition logSlice : go_type := structT [
  "term" :: uint64T;
  "prev" :: entryID;
  "entries" :: sliceT
].

(* maybeAppend returns (0, false) if the entries cannot be appended. Otherwise,
   it returns (last index of new entries, true).

   go: log.go:107:19 *)
Definition raftLog__maybeAppend : val :=
  rec: "raftLog__maybeAppend" "l" "a" "committed" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "committed" := (ref_ty uint64T "committed") in
    let: "a" := (ref_ty logSlice "a") in
    let: "lastnewi" := (ref_ty uint64T (zero_val uint64T)) in
    (if: (~ (let: "$a0" := (![entryID] (struct.field_ref logSlice "prev" "a")) in
    (raftLog__matchTerm (![ptrT] "l")) "$a0"))
    then return: (#(W64 0), #false)
    else do:  #());;;
    let: "$r0" := ((![uint64T] (struct.field_ref entryID "index" (struct.field_ref logSlice "prev" "a"))) + (let: "$a0" := (![sliceT] (struct.field_ref logSlice "entries" "a")) in
    slice.len "$a0")) in
    do:  ("lastnewi" <-[uint64T] "$r0");;;
    let: "ci" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (let: "$a0" := (![sliceT] (struct.field_ref logSlice "entries" "a")) in
    (raftLog__findConflict (![ptrT] "l")) "$a0") in
    do:  ("ci" <-[uint64T] "$r0");;;
    let: "$sw" := #true in
    (if: "$sw" = ((![uint64T] "ci") = #(W64 0))
    then do:  #()
    else
      (if: "$sw" = ((![uint64T] "ci") ≤ (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] "l"))))
      then
        do:  (let: "$a0" := #"entry %d conflict with committed entry [committed(%d)]" in
        let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] "ci")) in
        let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] "l")))) in
        slice.literal interfaceT ["$sl0"; "$sl1"])) in
        (interface.get "Panicf" (![Logger] (struct.field_ref raftLog "logger" (![ptrT] "l")))) "$a0" "$a1")
      else
        let: "offset" := (ref_ty uint64T (zero_val uint64T)) in
        let: "$r0" := ((![uint64T] (struct.field_ref entryID "index" (struct.field_ref logSlice "prev" "a"))) + #(W64 1)) in
        do:  ("offset" <-[uint64T] "$r0");;;
        (if: ((![uint64T] "ci") - (![uint64T] "offset")) > (let: "$a0" := (![sliceT] (struct.field_ref logSlice "entries" "a")) in
        slice.len "$a0")
        then
          do:  (let: "$a0" := #"index, %d, is out of range [%d]" in
          let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset ((![uint64T] "ci") - (![uint64T] "offset"))) in
          let: "$sl1" := (interface.make int__mset (let: "$a0" := (![sliceT] (struct.field_ref logSlice "entries" "a")) in
          slice.len "$a0")) in
          slice.literal interfaceT ["$sl0"; "$sl1"])) in
          (interface.get "Panicf" (![Logger] (struct.field_ref raftLog "logger" (![ptrT] "l")))) "$a0" "$a1")
        else do:  #());;;
        do:  (let: "$a0" := (let: "$s" := (![sliceT] (struct.field_ref logSlice "entries" "a")) in
        slice.slice raftpb.Entry "$s" ((![uint64T] "ci") - (![uint64T] "offset")) (slice.len "$s")) in
        (raftLog__append (![ptrT] "l")) "$a0")));;;
    do:  (let: "$a0" := (let: "$a0" := (![uint64T] "committed") in
    let: "$a1" := (![uint64T] "lastnewi") in
    (minUint64 2) "$a0" "$a1") in
    (raftLog__commitTo (![ptrT] "l")) "$a0");;;
    return: (![uint64T] "lastnewi", #true)).

Definition entryEncodingSize__mset : list (string * val) := [
].

(* nextCommittedEnts returns all the available entries for execution.
   Entries can be committed even when the local raft instance has not durably
   appended them to the local raft log yet. If allowUnstable is true, committed
   entries from the unstable log may be returned; otherwise, only entries known
   to reside locally on stable storage will be returned.

   go: log.go:219:19 *)
Definition raftLog__nextCommittedEnts : val :=
  rec: "raftLog__nextCommittedEnts" "l" "allowUnstable" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "allowUnstable" := (ref_ty boolT "allowUnstable") in
    let: "ents" := (ref_ty sliceT (zero_val sliceT)) in
    (if: ![boolT] (struct.field_ref raftLog "applyingEntsPaused" (![ptrT] "l"))
    then return: (#slice.nil)
    else do:  #());;;
    (if: (raftLog__hasNextOrInProgressSnapshot (![ptrT] "l")) #()
    then return: (#slice.nil)
    else do:  #());;;
    let: "hi" := (ref_ty uint64T (zero_val uint64T)) in
    let: "lo" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := ((![uint64T] (struct.field_ref raftLog "applying" (![ptrT] "l"))) + #(W64 1)) in
    let: "$r1" := ((let: "$a0" := (![boolT] "allowUnstable") in
    (raftLog__maxAppliableIndex (![ptrT] "l")) "$a0") + #(W64 1)) in
    do:  ("lo" <-[uint64T] "$r0");;;
    do:  ("hi" <-[uint64T] "$r1");;;
    (if: (![uint64T] "lo") ≥ (![uint64T] "hi")
    then return: (#slice.nil)
    else do:  #());;;
    let: "maxSize" := (ref_ty entryEncodingSize (zero_val entryEncodingSize)) in
    let: "$r0" := ((![entryEncodingSize] (struct.field_ref raftLog "maxApplyingEntsSize" (![ptrT] "l"))) - (![entryEncodingSize] (struct.field_ref raftLog "applyingEntsSize" (![ptrT] "l")))) in
    do:  ("maxSize" <-[entryEncodingSize] "$r0");;;
    (if: (![entryEncodingSize] "maxSize") ≤ #(W64 0)
    then
      do:  (let: "$a0" := #"applying entry size (%d-%d)=%d not positive" in
      let: "$a1" := ((let: "$sl0" := (interface.make entryEncodingSize__mset (![entryEncodingSize] (struct.field_ref raftLog "maxApplyingEntsSize" (![ptrT] "l")))) in
      let: "$sl1" := (interface.make entryEncodingSize__mset (![entryEncodingSize] (struct.field_ref raftLog "applyingEntsSize" (![ptrT] "l")))) in
      let: "$sl2" := (interface.make entryEncodingSize__mset (![entryEncodingSize] "maxSize")) in
      slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
      (interface.get "Panicf" (![Logger] (struct.field_ref raftLog "logger" (![ptrT] "l")))) "$a0" "$a1")
    else do:  #());;;
    let: "err" := (ref_ty error (zero_val error)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![uint64T] "lo") in
    let: "$a1" := (![uint64T] "hi") in
    let: "$a2" := (![entryEncodingSize] "maxSize") in
    (raftLog__slice (![ptrT] "l")) "$a0" "$a1" "$a2") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("ents" <-[sliceT] "$r0");;;
    do:  ("err" <-[error] "$r1");;;
    (if: (![error] "err") ≠ #interface.nil
    then
      do:  (let: "$a0" := #"unexpected error when getting unapplied entries (%v)" in
      let: "$a1" := ((let: "$sl0" := (![error] "err") in
      slice.literal interfaceT ["$sl0"])) in
      (interface.get "Panicf" (![Logger] (struct.field_ref raftLog "logger" (![ptrT] "l")))) "$a0" "$a1")
    else do:  #());;;
    return: (![sliceT] "ents")).

(* nextUnstableSnapshot returns the snapshot, if present, that is available to
   be applied to the local storage and is not already in-progress.

   go: log.go:277:19 *)
Definition raftLog__nextUnstableSnapshot : val :=
  rec: "raftLog__nextUnstableSnapshot" "l" <> :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    return: ((unstable__nextSnapshot (struct.field_ref raftLog "unstable" (![ptrT] "l"))) #())).

(* go: log_unstable.go:189:20 *)
Definition unstable__restore : val :=
  rec: "unstable__restore" "u" "s" :=
    exception_do (let: "u" := (ref_ty ptrT "u") in
    let: "s" := (ref_ty raftpb.Snapshot "s") in
    let: "$r0" := ((![uint64T] (struct.field_ref raftpb.SnapshotMetadata "Index" (struct.field_ref raftpb.Snapshot "Metadata" "s"))) + #(W64 1)) in
    do:  ((struct.field_ref unstable "offset" (![ptrT] "u")) <-[uint64T] "$r0");;;
    let: "$r0" := (![uint64T] (struct.field_ref unstable "offset" (![ptrT] "u"))) in
    do:  ((struct.field_ref unstable "offsetInProgress" (![ptrT] "u")) <-[uint64T] "$r0");;;
    let: "$r0" := #slice.nil in
    do:  ((struct.field_ref unstable "entries" (![ptrT] "u")) <-[sliceT] "$r0");;;
    let: "$r0" := "s" in
    do:  ((struct.field_ref unstable "snapshot" (![ptrT] "u")) <-[ptrT] "$r0");;;
    let: "$r0" := #false in
    do:  ((struct.field_ref unstable "snapshotInProgress" (![ptrT] "u")) <-[boolT] "$r0")).

(* go: log.go:466:19 *)
Definition raftLog__restore : val :=
  rec: "raftLog__restore" "l" "s" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "s" := (ref_ty raftpb.Snapshot "s") in
    let: "$r0" := (![uint64T] (struct.field_ref raftpb.SnapshotMetadata "Index" (struct.field_ref raftpb.Snapshot "Metadata" "s"))) in
    do:  ((struct.field_ref raftLog "committed" (![ptrT] "l")) <-[uint64T] "$r0");;;
    do:  (let: "$a0" := (![raftpb.Snapshot] "s") in
    (unstable__restore (struct.field_ref raftLog "unstable" (![ptrT] "l"))) "$a0")).

(* scan visits all log entries in the [lo, hi) range, returning them via the
   given callback. The callback can be invoked multiple times, with consecutive
   sub-ranges of the requested range. Returns up to pageSize bytes worth of
   entries at a time. May return more if a single entry size exceeds the limit.

   The entries in [lo, hi) must exist, otherwise scan() eventually returns an
   error (possibly after passing some entries through the callback).

   If the callback returns an error, scan terminates and returns this error
   immediately. This can be used to stop the scan early ("break" the loop).

   go: log.go:482:19 *)
Definition raftLog__scan : val :=
  rec: "raftLog__scan" "l" "lo" "hi" "pageSize" "v" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "v" := (ref_ty funcT "v") in
    let: "pageSize" := (ref_ty entryEncodingSize "pageSize") in
    let: "hi" := (ref_ty uint64T "hi") in
    let: "lo" := (ref_ty uint64T "lo") in
    (for: (λ: <>, (![uint64T] "lo") < (![uint64T] "hi")); (λ: <>, Skip) := λ: <>,
      let: "err" := (ref_ty error (zero_val error)) in
      let: "ents" := (ref_ty sliceT (zero_val sliceT)) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![uint64T] "lo") in
      let: "$a1" := (![uint64T] "hi") in
      let: "$a2" := (![entryEncodingSize] "pageSize") in
      (raftLog__slice (![ptrT] "l")) "$a0" "$a1" "$a2") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("ents" <-[sliceT] "$r0");;;
      do:  ("err" <-[error] "$r1");;;
      (if: (![error] "err") ≠ #interface.nil
      then return: (![error] "err")
      else
        (if: (let: "$a0" := (![sliceT] "ents") in
        slice.len "$a0") = #(W64 0)
        then
          return: (let: "$a0" := #"got 0 entries in [%d, %d)" in
           let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] "lo")) in
           let: "$sl1" := (interface.make uint64__mset (![uint64T] "hi")) in
           slice.literal interfaceT ["$sl0"; "$sl1"])) in
           fmt.Errorf "$a0" "$a1")
        else do:  #()));;;
      (let: "err" := (ref_ty error (zero_val error)) in
      let: "$r0" := (let: "$a0" := (![sliceT] "ents") in
      (![funcT] "v") "$a0") in
      do:  ("err" <-[error] "$r0");;;
      (if: (![error] "err") ≠ #interface.nil
      then return: (![error] "err")
      else do:  #()));;;
      do:  ("lo" <-[uint64T] ((![uint64T] "lo") + (let: "$a0" := (![sliceT] "ents") in
      slice.len "$a0"))));;;
    return: (#interface.nil)).

(* go: log_unstable.go:182:20 *)
Definition unstable__stableSnapTo : val :=
  rec: "unstable__stableSnapTo" "u" "i" :=
    exception_do (let: "u" := (ref_ty ptrT "u") in
    let: "i" := (ref_ty uint64T "i") in
    (if: ((![ptrT] (struct.field_ref unstable "snapshot" (![ptrT] "u"))) ≠ #null) && ((![uint64T] (struct.field_ref raftpb.SnapshotMetadata "Index" (struct.field_ref raftpb.Snapshot "Metadata" (![ptrT] (struct.field_ref unstable "snapshot" (![ptrT] "u")))))) = (![uint64T] "i"))
    then
      let: "$r0" := #null in
      do:  ((struct.field_ref unstable "snapshot" (![ptrT] "u")) <-[ptrT] "$r0");;;
      let: "$r0" := #false in
      do:  ((struct.field_ref unstable "snapshotInProgress" (![ptrT] "u")) <-[boolT] "$r0")
    else do:  #())).

(* go: log.go:369:19 *)
Definition raftLog__stableSnapTo : val :=
  rec: "raftLog__stableSnapTo" "l" "i" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "i" := (ref_ty uint64T "i") in
    do:  (let: "$a0" := (![uint64T] "i") in
    (unstable__stableSnapTo (struct.field_ref raftLog "unstable" (![ptrT] "l"))) "$a0")).

Definition lenMultiple : Z := 2.

(* go: log_unstable.go:168:20 *)
Definition unstable__shrinkEntriesArray : val :=
  rec: "unstable__shrinkEntriesArray" "u" <> :=
    exception_do (let: "u" := (ref_ty ptrT "u") in
    (if: (let: "$a0" := (![sliceT] (struct.field_ref unstable "entries" (![ptrT] "u"))) in
    slice.len "$a0") = #(W64 0)
    then
      let: "$r0" := #slice.nil in
      do:  ((struct.field_ref unstable "entries" (![ptrT] "u")) <-[sliceT] "$r0")
    else
      (if: int_lt ((let: "$a0" := (![sliceT] (struct.field_ref unstable "entries" (![ptrT] "u"))) in
      slice.len "$a0") * #(W64 lenMultiple)) (let: "$a0" := (![sliceT] (struct.field_ref unstable "entries" (![ptrT] "u"))) in
      slice.cap "$a0")
      then
        let: "newEntries" := (ref_ty sliceT (zero_val sliceT)) in
        let: "$r0" := (slice.make2 raftpb.Entry (let: "$a0" := (![sliceT] (struct.field_ref unstable "entries" (![ptrT] "u"))) in
        slice.len "$a0")) in
        do:  ("newEntries" <-[sliceT] "$r0");;;
        do:  (let: "$a0" := (![sliceT] "newEntries") in
        let: "$a1" := (![sliceT] (struct.field_ref unstable "entries" (![ptrT] "u"))) in
        (slice.copy raftpb.Entry) "$a0" "$a1");;;
        let: "$r0" := (![sliceT] "newEntries") in
        do:  ((struct.field_ref unstable "entries" (![ptrT] "u")) <-[sliceT] "$r0")
      else do:  #()))).

(* stableTo marks entries up to the entry with the specified (index, term) as
   being successfully written to stable storage.

   The method should only be called when the caller can attest that the entries
   can not be overwritten by an in-progress log append. See the related comment
   in newStorageAppendRespMsg.

   go: log_unstable.go:134:20 *)
Definition unstable__stableTo : val :=
  rec: "unstable__stableTo" "u" "id" :=
    exception_do (let: "u" := (ref_ty ptrT "u") in
    let: "id" := (ref_ty entryID "id") in
    let: "ok" := (ref_ty boolT (zero_val boolT)) in
    let: "gt" := (ref_ty uint64T (zero_val uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![uint64T] (struct.field_ref entryID "index" "id")) in
    (unstable__maybeTerm (![ptrT] "u")) "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("gt" <-[uint64T] "$r0");;;
    do:  ("ok" <-[boolT] "$r1");;;
    (if: (~ (![boolT] "ok"))
    then
      do:  (let: "$a0" := #"entry at index %d missing from unstable log; ignoring" in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref entryID "index" "id"))) in
      slice.literal interfaceT ["$sl0"])) in
      (interface.get "Infof" (![Logger] (struct.field_ref unstable "logger" (![ptrT] "u")))) "$a0" "$a1");;;
      return: (#())
    else do:  #());;;
    (if: (![uint64T] (struct.field_ref entryID "index" "id")) < (![uint64T] (struct.field_ref unstable "offset" (![ptrT] "u")))
    then
      do:  (let: "$a0" := #"entry at index %d matched unstable snapshot; ignoring" in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref entryID "index" "id"))) in
      slice.literal interfaceT ["$sl0"])) in
      (interface.get "Infof" (![Logger] (struct.field_ref unstable "logger" (![ptrT] "u")))) "$a0" "$a1");;;
      return: (#())
    else do:  #());;;
    (if: (![uint64T] "gt") ≠ (![uint64T] (struct.field_ref entryID "term" "id"))
    then
      do:  (let: "$a0" := ("entry at (index,term)=(%d,%d) mismatched with " + "entry at (%d,%d) in unstable log; ignoring") in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref entryID "index" "id"))) in
      let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref entryID "term" "id"))) in
      let: "$sl2" := (interface.make uint64__mset (![uint64T] (struct.field_ref entryID "index" "id"))) in
      let: "$sl3" := (interface.make uint64__mset (![uint64T] "gt")) in
      slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"])) in
      (interface.get "Infof" (![Logger] (struct.field_ref unstable "logger" (![ptrT] "u")))) "$a0" "$a1");;;
      return: (#())
    else do:  #());;;
    let: "num" := (ref_ty intT (zero_val intT)) in
    let: "$r0" := (((![uint64T] (struct.field_ref entryID "index" "id")) + #(W64 1)) - (![uint64T] (struct.field_ref unstable "offset" (![ptrT] "u")))) in
    do:  ("num" <-[intT] "$r0");;;
    let: "$r0" := (let: "$s" := (![sliceT] (struct.field_ref unstable "entries" (![ptrT] "u"))) in
    slice.slice raftpb.Entry "$s" (![intT] "num") (slice.len "$s")) in
    do:  ((struct.field_ref unstable "entries" (![ptrT] "u")) <-[sliceT] "$r0");;;
    let: "$r0" := ((![uint64T] (struct.field_ref entryID "index" "id")) + #(W64 1)) in
    do:  ((struct.field_ref unstable "offset" (![ptrT] "u")) <-[uint64T] "$r0");;;
    let: "$r0" := (let: "$a0" := (![uint64T] (struct.field_ref unstable "offsetInProgress" (![ptrT] "u"))) in
    let: "$a1" := (![uint64T] (struct.field_ref unstable "offset" (![ptrT] "u"))) in
    (maxUint64 2) "$a0" "$a1") in
    do:  ((struct.field_ref unstable "offsetInProgress" (![ptrT] "u")) <-[uint64T] "$r0");;;
    do:  ((unstable__shrinkEntriesArray (![ptrT] "u")) #())).

(* go: log.go:367:19 *)
Definition raftLog__stableTo : val :=
  rec: "raftLog__stableTo" "l" "id" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "id" := (ref_ty entryID "id") in
    do:  (let: "$a0" := (![entryID] "id") in
    (unstable__stableTo (struct.field_ref raftLog "unstable" (![ptrT] "l"))) "$a0")).

Definition raftLog__mset_ptr : list (string * val) := [
  ("String", raftLog__String%V);
  ("acceptApplying", raftLog__acceptApplying%V);
  ("acceptUnstable", raftLog__acceptUnstable%V);
  ("allEntries", raftLog__allEntries%V);
  ("append", raftLog__append%V);
  ("appliedTo", raftLog__appliedTo%V);
  ("commitTo", raftLog__commitTo%V);
  ("entries", raftLog__entries%V);
  ("findConflict", raftLog__findConflict%V);
  ("findConflictByTerm", raftLog__findConflictByTerm%V);
  ("firstIndex", raftLog__firstIndex%V);
  ("hasNextCommittedEnts", raftLog__hasNextCommittedEnts%V);
  ("hasNextOrInProgressSnapshot", raftLog__hasNextOrInProgressSnapshot%V);
  ("hasNextOrInProgressUnstableEnts", raftLog__hasNextOrInProgressUnstableEnts%V);
  ("hasNextUnstableEnts", raftLog__hasNextUnstableEnts%V);
  ("hasNextUnstableSnapshot", raftLog__hasNextUnstableSnapshot%V);
  ("isUpToDate", raftLog__isUpToDate%V);
  ("lastEntryID", raftLog__lastEntryID%V);
  ("lastIndex", raftLog__lastIndex%V);
  ("matchTerm", raftLog__matchTerm%V);
  ("maxAppliableIndex", raftLog__maxAppliableIndex%V);
  ("maybeAppend", raftLog__maybeAppend%V);
  ("maybeCommit", raftLog__maybeCommit%V);
  ("mustCheckOutOfBounds", raftLog__mustCheckOutOfBounds%V);
  ("nextCommittedEnts", raftLog__nextCommittedEnts%V);
  ("nextUnstableEnts", raftLog__nextUnstableEnts%V);
  ("nextUnstableSnapshot", raftLog__nextUnstableSnapshot%V);
  ("restore", raftLog__restore%V);
  ("scan", raftLog__scan%V);
  ("slice", raftLog__slice%V);
  ("snapshot", raftLog__snapshot%V);
  ("stableSnapTo", raftLog__stableSnapTo%V);
  ("stableTo", raftLog__stableTo%V);
  ("term", raftLog__term%V);
  ("zeroTermOnOutOfBounds", raftLog__zeroTermOnOutOfBounds%V)
].

(* newLogWithSize returns a log using the given storage and max
   message size.

   go: log.go:73:6 *)
Definition newLogWithSize : val :=
  rec: "newLogWithSize" "storage" "logger" "maxApplyingEntsSize" :=
    exception_do (let: "maxApplyingEntsSize" := (ref_ty entryEncodingSize "maxApplyingEntsSize") in
    let: "logger" := (ref_ty Logger "logger") in
    let: "storage" := (ref_ty Storage "storage") in
    let: "err" := (ref_ty error (zero_val error)) in
    let: "firstIndex" := (ref_ty uint64T (zero_val uint64T)) in
    let: ("$ret0", "$ret1") := ((interface.get "FirstIndex" (![Storage] "storage")) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("firstIndex" <-[uint64T] "$r0");;;
    do:  ("err" <-[error] "$r1");;;
    (if: (![error] "err") ≠ #interface.nil
    then
      do:  (let: "$a0" := (![error] "err") in
      Panic "$a0")
    else do:  #());;;
    let: "lastIndex" := (ref_ty uint64T (zero_val uint64T)) in
    let: ("$ret0", "$ret1") := ((interface.get "LastIndex" (![Storage] "storage")) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("lastIndex" <-[uint64T] "$r0");;;
    do:  ("err" <-[error] "$r1");;;
    (if: (![error] "err") ≠ #interface.nil
    then
      do:  (let: "$a0" := (![error] "err") in
      Panic "$a0")
    else do:  #());;;
    return: (ref_ty raftLog (struct.make raftLog [{
       "storage" ::= ![Storage] "storage";
       "unstable" ::= struct.make unstable [{
         "offset" ::= (![uint64T] "lastIndex") + #(W64 1);
         "offsetInProgress" ::= (![uint64T] "lastIndex") + #(W64 1);
         "logger" ::= ![Logger] "logger"
       }];
       "maxApplyingEntsSize" ::= ![entryEncodingSize] "maxApplyingEntsSize";
       "committed" ::= (![uint64T] "firstIndex") - #(W64 1);
       "applying" ::= (![uint64T] "firstIndex") - #(W64 1);
       "applied" ::= (![uint64T] "firstIndex") - #(W64 1);
       "logger" ::= ![Logger] "logger"
     }]))).

(* newLog returns log using the given storage and default options. It
   recovers the log to the state that it just commits and applies the
   latest snapshot.

   go: log.go:67:6 *)
Definition newLog : val :=
  rec: "newLog" "storage" "logger" :=
    exception_do (let: "logger" := (ref_ty Logger "logger") in
    let: "storage" := (ref_ty Storage "storage") in
    return: (let: "$a0" := (![Storage] "storage") in
     let: "$a1" := (![Logger] "logger") in
     let: "$a2" := #(W64 noLimit) in
     newLogWithSize "$a0" "$a1" "$a2")).

Definition unstable__mset : list (string * val) := [
].

Definition unstable__mset_ptr : list (string * val) := [
  ("acceptInProgress", unstable__acceptInProgress%V);
  ("maybeFirstIndex", unstable__maybeFirstIndex%V);
  ("maybeLastIndex", unstable__maybeLastIndex%V);
  ("maybeTerm", unstable__maybeTerm%V);
  ("mustCheckOutOfBounds", unstable__mustCheckOutOfBounds%V);
  ("nextEntries", unstable__nextEntries%V);
  ("nextSnapshot", unstable__nextSnapshot%V);
  ("restore", unstable__restore%V);
  ("shrinkEntriesArray", unstable__shrinkEntriesArray%V);
  ("slice", unstable__slice%V);
  ("stableSnapTo", unstable__stableSnapTo%V);
  ("stableTo", unstable__stableTo%V);
  ("truncateAndAppend", unstable__truncateAndAppend%V)
].

(* go: logger.go:45:6 *)
Definition SetLogger : val :=
  rec: "SetLogger" "l" :=
    exception_do (let: "l" := (ref_ty Logger "l") in
    do:  ((sync.Mutex__Lock "raftLoggerMu") #());;;
    let: "$r0" := (![Logger] "l") in
    do:  ("raftLogger" <-[Logger] "$r0");;;
    do:  ((sync.Mutex__Unlock "raftLoggerMu") #())).

Definition DefaultLogger : go_type := structT [
  "Logger" :: ptrT;
  "debug" :: boolT
].

Definition calldepth : Z := 2.

(* go: logger.go:140:6 *)
Definition header : val :=
  rec: "header" "lvl" "msg" :=
    exception_do (let: "msg" := (ref_ty stringT "msg") in
    let: "lvl" := (ref_ty stringT "lvl") in
    return: (let: "$a0" := #"%s: %s" in
     let: "$a1" := ((let: "$sl0" := (interface.make string__mset (![stringT] "lvl")) in
     let: "$sl1" := (interface.make string__mset (![stringT] "msg")) in
     slice.literal interfaceT ["$sl0"; "$sl1"])) in
     fmt.Sprintf "$a0" "$a1")).

(* go: logger.go:86:25 *)
Definition DefaultLogger__Debug : val :=
  rec: "DefaultLogger__Debug" "l" "v" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "v" := (ref_ty sliceT "v") in
    (if: ![boolT] (struct.field_ref DefaultLogger "debug" (![ptrT] "l"))
    then
      do:  (let: "$a0" := #(W64 calldepth) in
      let: "$a1" := (let: "$a0" := #"DEBUG" in
      let: "$a1" := (let: "$a0" := (![sliceT] "v") in
      fmt.Sprint "$a0") in
      header "$a0" "$a1") in
      (log.Logger__Output (![ptrT] (struct.field_ref DefaultLogger "Logger" (![ptrT] "l")))) "$a0" "$a1")
    else do:  #())).

(* go: logger.go:92:25 *)
Definition DefaultLogger__Debugf : val :=
  rec: "DefaultLogger__Debugf" "l" "format" "v" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "v" := (ref_ty sliceT "v") in
    let: "format" := (ref_ty stringT "format") in
    (if: ![boolT] (struct.field_ref DefaultLogger "debug" (![ptrT] "l"))
    then
      do:  (let: "$a0" := #(W64 calldepth) in
      let: "$a1" := (let: "$a0" := #"DEBUG" in
      let: "$a1" := (let: "$a0" := (![stringT] "format") in
      let: "$a1" := (![sliceT] "v") in
      fmt.Sprintf "$a0" "$a1") in
      header "$a0" "$a1") in
      (log.Logger__Output (![ptrT] (struct.field_ref DefaultLogger "Logger" (![ptrT] "l")))) "$a0" "$a1")
    else do:  #())).

(* go: logger.go:82:25 *)
Definition DefaultLogger__EnableDebug : val :=
  rec: "DefaultLogger__EnableDebug" "l" <> :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "$r0" := #true in
    do:  ((struct.field_ref DefaultLogger "debug" (![ptrT] "l")) <-[boolT] "$r0")).

(* go: logger.go:78:25 *)
Definition DefaultLogger__EnableTimestamps : val :=
  rec: "DefaultLogger__EnableTimestamps" "l" <> :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    do:  (let: "$a0" := ((((log.Logger__Flags (![ptrT] (struct.field_ref DefaultLogger "Logger" (![ptrT] "l")))) #()) `or` #(W64 log.Ldate)) `or` #(W64 log.Ltime)) in
    (log.Logger__SetFlags (![ptrT] (struct.field_ref DefaultLogger "Logger" (![ptrT] "l")))) "$a0")).

(* go: logger.go:106:25 *)
Definition DefaultLogger__Error : val :=
  rec: "DefaultLogger__Error" "l" "v" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "v" := (ref_ty sliceT "v") in
    do:  (let: "$a0" := #(W64 calldepth) in
    let: "$a1" := (let: "$a0" := #"ERROR" in
    let: "$a1" := (let: "$a0" := (![sliceT] "v") in
    fmt.Sprint "$a0") in
    header "$a0" "$a1") in
    (log.Logger__Output (![ptrT] (struct.field_ref DefaultLogger "Logger" (![ptrT] "l")))) "$a0" "$a1")).

(* go: logger.go:110:25 *)
Definition DefaultLogger__Errorf : val :=
  rec: "DefaultLogger__Errorf" "l" "format" "v" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "v" := (ref_ty sliceT "v") in
    let: "format" := (ref_ty stringT "format") in
    do:  (let: "$a0" := #(W64 calldepth) in
    let: "$a1" := (let: "$a0" := #"ERROR" in
    let: "$a1" := (let: "$a0" := (![stringT] "format") in
    let: "$a1" := (![sliceT] "v") in
    fmt.Sprintf "$a0" "$a1") in
    header "$a0" "$a1") in
    (log.Logger__Output (![ptrT] (struct.field_ref DefaultLogger "Logger" (![ptrT] "l")))) "$a0" "$a1")).

(* go: logger.go:122:25 *)
Definition DefaultLogger__Fatal : val :=
  rec: "DefaultLogger__Fatal" "l" "v" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "v" := (ref_ty sliceT "v") in
    do:  (let: "$a0" := #(W64 calldepth) in
    let: "$a1" := (let: "$a0" := #"FATAL" in
    let: "$a1" := (let: "$a0" := (![sliceT] "v") in
    fmt.Sprint "$a0") in
    header "$a0" "$a1") in
    (log.Logger__Output (![ptrT] (struct.field_ref DefaultLogger "Logger" (![ptrT] "l")))) "$a0" "$a1");;;
    do:  (let: "$a0" := #(W64 1) in
    os.Exit "$a0")).

(* go: logger.go:127:25 *)
Definition DefaultLogger__Fatalf : val :=
  rec: "DefaultLogger__Fatalf" "l" "format" "v" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "v" := (ref_ty sliceT "v") in
    let: "format" := (ref_ty stringT "format") in
    do:  (let: "$a0" := #(W64 calldepth) in
    let: "$a1" := (let: "$a0" := #"FATAL" in
    let: "$a1" := (let: "$a0" := (![stringT] "format") in
    let: "$a1" := (![sliceT] "v") in
    fmt.Sprintf "$a0" "$a1") in
    header "$a0" "$a1") in
    (log.Logger__Output (![ptrT] (struct.field_ref DefaultLogger "Logger" (![ptrT] "l")))) "$a0" "$a1");;;
    do:  (let: "$a0" := #(W64 1) in
    os.Exit "$a0")).

(* go: logger.go:98:25 *)
Definition DefaultLogger__Info : val :=
  rec: "DefaultLogger__Info" "l" "v" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "v" := (ref_ty sliceT "v") in
    do:  (let: "$a0" := #(W64 calldepth) in
    let: "$a1" := (let: "$a0" := #"INFO" in
    let: "$a1" := (let: "$a0" := (![sliceT] "v") in
    fmt.Sprint "$a0") in
    header "$a0" "$a1") in
    (log.Logger__Output (![ptrT] (struct.field_ref DefaultLogger "Logger" (![ptrT] "l")))) "$a0" "$a1")).

(* go: logger.go:102:25 *)
Definition DefaultLogger__Infof : val :=
  rec: "DefaultLogger__Infof" "l" "format" "v" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "v" := (ref_ty sliceT "v") in
    let: "format" := (ref_ty stringT "format") in
    do:  (let: "$a0" := #(W64 calldepth) in
    let: "$a1" := (let: "$a0" := #"INFO" in
    let: "$a1" := (let: "$a0" := (![stringT] "format") in
    let: "$a1" := (![sliceT] "v") in
    fmt.Sprintf "$a0" "$a1") in
    header "$a0" "$a1") in
    (log.Logger__Output (![ptrT] (struct.field_ref DefaultLogger "Logger" (![ptrT] "l")))) "$a0" "$a1")).

(* go: logger.go:132:25 *)
Definition DefaultLogger__Panic : val :=
  rec: "DefaultLogger__Panic" "l" "v" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "v" := (ref_ty sliceT "v") in
    do:  (let: "$a0" := (![sliceT] "v") in
    (log.Logger__Panic (![ptrT] (struct.field_ref DefaultLogger "Logger" (![ptrT] "l")))) "$a0")).

(* go: logger.go:136:25 *)
Definition DefaultLogger__Panicf : val :=
  rec: "DefaultLogger__Panicf" "l" "format" "v" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "v" := (ref_ty sliceT "v") in
    let: "format" := (ref_ty stringT "format") in
    do:  (let: "$a0" := (![stringT] "format") in
    let: "$a1" := (![sliceT] "v") in
    (log.Logger__Panicf (![ptrT] (struct.field_ref DefaultLogger "Logger" (![ptrT] "l")))) "$a0" "$a1")).

(* go: logger.go:114:25 *)
Definition DefaultLogger__Warning : val :=
  rec: "DefaultLogger__Warning" "l" "v" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "v" := (ref_ty sliceT "v") in
    do:  (let: "$a0" := #(W64 calldepth) in
    let: "$a1" := (let: "$a0" := #"WARN" in
    let: "$a1" := (let: "$a0" := (![sliceT] "v") in
    fmt.Sprint "$a0") in
    header "$a0" "$a1") in
    (log.Logger__Output (![ptrT] (struct.field_ref DefaultLogger "Logger" (![ptrT] "l")))) "$a0" "$a1")).

(* go: logger.go:118:25 *)
Definition DefaultLogger__Warningf : val :=
  rec: "DefaultLogger__Warningf" "l" "format" "v" :=
    exception_do (let: "l" := (ref_ty ptrT "l") in
    let: "v" := (ref_ty sliceT "v") in
    let: "format" := (ref_ty stringT "format") in
    do:  (let: "$a0" := #(W64 calldepth) in
    let: "$a1" := (let: "$a0" := #"WARN" in
    let: "$a1" := (let: "$a0" := (![stringT] "format") in
    let: "$a1" := (![sliceT] "v") in
    fmt.Sprintf "$a0" "$a1") in
    header "$a0" "$a1") in
    (log.Logger__Output (![ptrT] (struct.field_ref DefaultLogger "Logger" (![ptrT] "l")))) "$a0" "$a1")).

Definition DefaultLogger__mset_ptr : list (string * val) := [
  ("Debug", DefaultLogger__Debug%V);
  ("Debugf", DefaultLogger__Debugf%V);
  ("EnableDebug", DefaultLogger__EnableDebug%V);
  ("EnableTimestamps", DefaultLogger__EnableTimestamps%V);
  ("Error", DefaultLogger__Error%V);
  ("Errorf", DefaultLogger__Errorf%V);
  ("Fatal", DefaultLogger__Fatal%V);
  ("Fatalf", DefaultLogger__Fatalf%V);
  ("Fatalln", (λ: "$recvAddr",
    log.Logger__Fatalln (![ptrT] (struct.field_ref DefaultLogger "Logger" "$recvAddr"))
    )%V);
  ("Flags", (λ: "$recvAddr",
    log.Logger__Flags (![ptrT] (struct.field_ref DefaultLogger "Logger" "$recvAddr"))
    )%V);
  ("Info", DefaultLogger__Info%V);
  ("Infof", DefaultLogger__Infof%V);
  ("Output", (λ: "$recvAddr",
    log.Logger__Output (![ptrT] (struct.field_ref DefaultLogger "Logger" "$recvAddr"))
    )%V);
  ("Panic", DefaultLogger__Panic%V);
  ("Panicf", DefaultLogger__Panicf%V);
  ("Panicln", (λ: "$recvAddr",
    log.Logger__Panicln (![ptrT] (struct.field_ref DefaultLogger "Logger" "$recvAddr"))
    )%V);
  ("Prefix", (λ: "$recvAddr",
    log.Logger__Prefix (![ptrT] (struct.field_ref DefaultLogger "Logger" "$recvAddr"))
    )%V);
  ("Print", (λ: "$recvAddr",
    log.Logger__Print (![ptrT] (struct.field_ref DefaultLogger "Logger" "$recvAddr"))
    )%V);
  ("Printf", (λ: "$recvAddr",
    log.Logger__Printf (![ptrT] (struct.field_ref DefaultLogger "Logger" "$recvAddr"))
    )%V);
  ("Println", (λ: "$recvAddr",
    log.Logger__Println (![ptrT] (struct.field_ref DefaultLogger "Logger" "$recvAddr"))
    )%V);
  ("SetFlags", (λ: "$recvAddr",
    log.Logger__SetFlags (![ptrT] (struct.field_ref DefaultLogger "Logger" "$recvAddr"))
    )%V);
  ("SetOutput", (λ: "$recvAddr",
    log.Logger__SetOutput (![ptrT] (struct.field_ref DefaultLogger "Logger" "$recvAddr"))
    )%V);
  ("SetPrefix", (λ: "$recvAddr",
    log.Logger__SetPrefix (![ptrT] (struct.field_ref DefaultLogger "Logger" "$recvAddr"))
    )%V);
  ("Warning", DefaultLogger__Warning%V);
  ("Warningf", DefaultLogger__Warningf%V);
  ("Writer", (λ: "$recvAddr",
    log.Logger__Writer (![ptrT] (struct.field_ref DefaultLogger "Logger" "$recvAddr"))
    )%V)
].

(* go: logger.go:51:6 *)
Definition ResetDefaultLogger : val :=
  rec: "ResetDefaultLogger" <> :=
    exception_do (do:  (let: "$a0" := (interface.make DefaultLogger__mset_ptr (![ptrT] "defaultLogger")) in
    SetLogger "$a0")).

(* go: logger.go:55:6 *)
Definition getLogger : val :=
  rec: "getLogger" <> :=
    with_defer: (do:  ((sync.Mutex__Lock "raftLoggerMu") #());;;
    do:  (let: "$f" := (sync.Mutex__Unlock "raftLoggerMu") in
    "$defer" <-[funcT] (let: "$oldf" := (![funcT] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    return: (![Logger] "raftLogger")).

Definition DefaultLogger__mset : list (string * val) := [
  ("Fatalln", (λ: "$recv",
    log.Logger__Fatalln (struct.field_get DefaultLogger "Logger" "$recv")
    )%V);
  ("Flags", (λ: "$recv",
    log.Logger__Flags (struct.field_get DefaultLogger "Logger" "$recv")
    )%V);
  ("Output", (λ: "$recv",
    log.Logger__Output (struct.field_get DefaultLogger "Logger" "$recv")
    )%V);
  ("Panicln", (λ: "$recv",
    log.Logger__Panicln (struct.field_get DefaultLogger "Logger" "$recv")
    )%V);
  ("Prefix", (λ: "$recv",
    log.Logger__Prefix (struct.field_get DefaultLogger "Logger" "$recv")
    )%V);
  ("Print", (λ: "$recv",
    log.Logger__Print (struct.field_get DefaultLogger "Logger" "$recv")
    )%V);
  ("Printf", (λ: "$recv",
    log.Logger__Printf (struct.field_get DefaultLogger "Logger" "$recv")
    )%V);
  ("Println", (λ: "$recv",
    log.Logger__Println (struct.field_get DefaultLogger "Logger" "$recv")
    )%V);
  ("SetFlags", (λ: "$recv",
    log.Logger__SetFlags (struct.field_get DefaultLogger "Logger" "$recv")
    )%V);
  ("SetOutput", (λ: "$recv",
    log.Logger__SetOutput (struct.field_get DefaultLogger "Logger" "$recv")
    )%V);
  ("SetPrefix", (λ: "$recv",
    log.Logger__SetPrefix (struct.field_get DefaultLogger "Logger" "$recv")
    )%V);
  ("Writer", (λ: "$recv",
    log.Logger__Writer (struct.field_get DefaultLogger "Logger" "$recv")
    )%V)
].

Definition SnapshotStatus : go_type := intT.

Definition SnapshotStatus__mset : list (string * val) := [
].

Definition SnapshotStatus__mset_ptr : list (string * val) := [
].

Definition SnapshotFinish : expr := #(W64 1).

Definition SnapshotFailure : expr := #(W64 2).

Definition SoftState : go_type := structT [
  "Lead" :: uint64T;
  "RaftState" :: StateType
].

Definition SoftState__mset : list (string * val) := [
].

(* go: node.go:45:21 *)
Definition SoftState__equal : val :=
  rec: "SoftState__equal" "a" "b" :=
    exception_do (let: "a" := (ref_ty ptrT "a") in
    let: "b" := (ref_ty ptrT "b") in
    return: (((![uint64T] (struct.field_ref SoftState "Lead" (![ptrT] "a"))) = (![uint64T] (struct.field_ref SoftState "Lead" (![ptrT] "b")))) && ((![StateType] (struct.field_ref SoftState "RaftState" (![ptrT] "a"))) = (![StateType] (struct.field_ref SoftState "RaftState" (![ptrT] "b")))))).

Definition SoftState__mset_ptr : list (string * val) := [
  ("equal", SoftState__equal%V)
].

Definition Ready : go_type := structT [
  "SoftState" :: ptrT;
  "HardState" :: raftpb.HardState;
  "ReadStates" :: sliceT;
  "Entries" :: sliceT;
  "Snapshot" :: raftpb.Snapshot;
  "CommittedEntries" :: sliceT;
  "Messages" :: sliceT;
  "MustSync" :: boolT
].

Definition Ready__mset : list (string * val) := [
].

Definition Ready__mset_ptr : list (string * val) := [
  ("Descriptor", (λ: "$recvAddr",
    raftpb.HardState__Descriptor (struct.field_ref Ready "HardState" "$recvAddr")
    )%V);
  ("Marshal", (λ: "$recvAddr",
    raftpb.HardState__Marshal (struct.field_ref Ready "HardState" "$recvAddr")
    )%V);
  ("MarshalTo", (λ: "$recvAddr",
    raftpb.HardState__MarshalTo (struct.field_ref Ready "HardState" "$recvAddr")
    )%V);
  ("MarshalToSizedBuffer", (λ: "$recvAddr",
    raftpb.HardState__MarshalToSizedBuffer (struct.field_ref Ready "HardState" "$recvAddr")
    )%V);
  ("ProtoMessage", (λ: "$recvAddr",
    raftpb.HardState__ProtoMessage (struct.field_ref Ready "HardState" "$recvAddr")
    )%V);
  ("Reset", (λ: "$recvAddr",
    raftpb.HardState__Reset (struct.field_ref Ready "HardState" "$recvAddr")
    )%V);
  ("Size", (λ: "$recvAddr",
    raftpb.HardState__Size (struct.field_ref Ready "HardState" "$recvAddr")
    )%V);
  ("String", (λ: "$recvAddr",
    raftpb.HardState__String (struct.field_ref Ready "HardState" "$recvAddr")
    )%V);
  ("Unmarshal", (λ: "$recvAddr",
    raftpb.HardState__Unmarshal (struct.field_ref Ready "HardState" "$recvAddr")
    )%V);
  ("XXX_DiscardUnknown", (λ: "$recvAddr",
    raftpb.HardState__XXX_DiscardUnknown (struct.field_ref Ready "HardState" "$recvAddr")
    )%V);
  ("XXX_Marshal", (λ: "$recvAddr",
    raftpb.HardState__XXX_Marshal (struct.field_ref Ready "HardState" "$recvAddr")
    )%V);
  ("XXX_Merge", (λ: "$recvAddr",
    raftpb.HardState__XXX_Merge (struct.field_ref Ready "HardState" "$recvAddr")
    )%V);
  ("XXX_Size", (λ: "$recvAddr",
    raftpb.HardState__XXX_Size (struct.field_ref Ready "HardState" "$recvAddr")
    )%V);
  ("XXX_Unmarshal", (λ: "$recvAddr",
    raftpb.HardState__XXX_Unmarshal (struct.field_ref Ready "HardState" "$recvAddr")
    )%V)
].

(* go: node.go:117:6 *)
Definition isHardStateEqual : val :=
  rec: "isHardStateEqual" "a" "b" :=
    exception_do (let: "b" := (ref_ty raftpb.HardState "b") in
    let: "a" := (ref_ty raftpb.HardState "a") in
    return: ((((![uint64T] (struct.field_ref raftpb.HardState "Term" "a")) = (![uint64T] (struct.field_ref raftpb.HardState "Term" "b"))) && ((![uint64T] (struct.field_ref raftpb.HardState "Vote" "a")) = (![uint64T] (struct.field_ref raftpb.HardState "Vote" "b")))) && ((![uint64T] (struct.field_ref raftpb.HardState "Commit" "a")) = (![uint64T] (struct.field_ref raftpb.HardState "Commit" "b"))))).

(* IsEmptyHardState returns true if the given HardState is empty.

   go: node.go:122:6 *)
Definition IsEmptyHardState : val :=
  rec: "IsEmptyHardState" "st" :=
    exception_do (let: "st" := (ref_ty raftpb.HardState "st") in
    return: (let: "$a0" := (![raftpb.HardState] "st") in
     let: "$a1" := (![raftpb.HardState] "emptyState") in
     isHardStateEqual "$a0" "$a1")).

Definition Node : go_type := interfaceT.

Definition Peer__mset : list (string * val) := [
].

Definition Peer__mset_ptr : list (string * val) := [
].

Definition msgWithResult : go_type := structT [
  "m" :: raftpb.Message;
  "result" :: chanT error
].

Definition BasicStatus : go_type := structT [
  "ID" :: uint64T;
  "HardState" :: raftpb.HardState;
  "SoftState" :: SoftState;
  "Applied" :: uint64T;
  "LeadTransferee" :: uint64T
].

Definition Status : go_type := structT [
  "BasicStatus" :: BasicStatus;
  "Config" :: tracker.Config;
  "Progress" :: mapT uint64T tracker.Progress
].

Definition node : go_type := structT [
  "propc" :: chanT msgWithResult;
  "recvc" :: chanT raftpb.Message;
  "confc" :: chanT raftpb.ConfChangeV2;
  "confstatec" :: chanT raftpb.ConfState;
  "readyc" :: chanT Ready;
  "advancec" :: chanT (structT [
  ]);
  "tickc" :: chanT (structT [
  ]);
  "done" :: chanT (structT [
  ]);
  "stop" :: chanT (structT [
  ]);
  "status" :: chanT (chanT Status);
  "rn" :: ptrT
].

(* go: node.go:312:6 *)
Definition newNode : val :=
  rec: "newNode" "rn" :=
    exception_do (let: "rn" := (ref_ty ptrT "rn") in
    return: (struct.make node [{
       "propc" ::= chan.make msgWithResult #();
       "recvc" ::= chan.make raftpb.Message #();
       "confc" ::= chan.make raftpb.ConfChangeV2 #();
       "confstatec" ::= chan.make raftpb.ConfState #();
       "readyc" ::= chan.make Ready #();
       "advancec" ::= chan.make (structT [
       ]) #();
       "tickc" ::= chan.make (structT [
       ]) #();
       "done" ::= chan.make (structT [
       ]) #();
       "stop" ::= chan.make (structT [
       ]) #();
       "status" ::= chan.make (chanT Status) #();
       "rn" ::= ![ptrT] "rn"
     }])).

Definition Config : go_type := structT [
  "ID" :: uint64T;
  "ElectionTick" :: intT;
  "HeartbeatTick" :: intT;
  "Storage" :: Storage;
  "Applied" :: uint64T;
  "AsyncStorageWrites" :: boolT;
  "MaxSizePerMsg" :: uint64T;
  "MaxCommittedSizePerReady" :: uint64T;
  "MaxUncommittedEntriesSize" :: uint64T;
  "MaxInflightMsgs" :: intT;
  "MaxInflightBytes" :: uint64T;
  "CheckQuorum" :: boolT;
  "PreVote" :: boolT;
  "ReadOnlyOption" :: ReadOnlyOption;
  "Logger" :: Logger;
  "DisableProposalForwarding" :: boolT;
  "DisableConfChangeValidation" :: boolT;
  "StepDownOnRemoval" :: boolT;
  "TraceLogger" :: TraceLogger
].

(* go: raft.go:510:16 *)
Definition raft__hardState : val :=
  rec: "raft__hardState" "r" <> :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    return: (struct.make raftpb.HardState [{
       "Term" ::= ![uint64T] (struct.field_ref raft "Term" (![ptrT] "r"));
       "Vote" ::= ![uint64T] (struct.field_ref raft "Vote" (![ptrT] "r"));
       "Commit" ::= ![uint64T] (struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r"))))
     }])).

(* go: raft.go:508:16 *)
Definition raft__softState : val :=
  rec: "raft__softState" "r" <> :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    return: (struct.make SoftState [{
       "Lead" ::= ![uint64T] (struct.field_ref raft "lead" (![ptrT] "r"));
       "RaftState" ::= ![StateType] (struct.field_ref raft "state" (![ptrT] "r"))
     }])).

(* go: raft.go:2058:16 *)
Definition raft__loadState : val :=
  rec: "raft__loadState" "r" "state" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "state" := (ref_ty raftpb.HardState "state") in
    (if: ((![uint64T] (struct.field_ref raftpb.HardState "Commit" "state")) < (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))))) || ((![uint64T] (struct.field_ref raftpb.HardState "Commit" "state")) > ((raftLog__lastIndex (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()))
    then
      do:  (let: "$a0" := #"%x state.commit %d is out of range [%d, %d]" in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
      let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.HardState "Commit" "state"))) in
      let: "$sl2" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))))) in
      let: "$sl3" := (interface.make uint64__mset ((raftLog__lastIndex (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #())) in
      slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"])) in
      (interface.get "Panicf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1")
    else do:  #());;;
    let: "$r0" := (![uint64T] (struct.field_ref raftpb.HardState "Commit" "state")) in
    do:  ((struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) <-[uint64T] "$r0");;;
    let: "$r0" := (![uint64T] (struct.field_ref raftpb.HardState "Term" "state")) in
    do:  ((struct.field_ref raft "Term" (![ptrT] "r")) <-[uint64T] "$r0");;;
    let: "$r0" := (![uint64T] (struct.field_ref raftpb.HardState "Vote" "state")) in
    do:  ((struct.field_ref raft "Vote" (![ptrT] "r")) <-[uint64T] "$r0")).

(* go: util.go:302:6 *)
Definition assertConfStatesEquivalent : val :=
  rec: "assertConfStatesEquivalent" "l" "cs1" "cs2" :=
    exception_do (let: "cs2" := (ref_ty raftpb.ConfState "cs2") in
    let: "cs1" := (ref_ty raftpb.ConfState "cs1") in
    let: "l" := (ref_ty Logger "l") in
    let: "err" := (ref_ty error (zero_val error)) in
    let: "$r0" := (let: "$a0" := (![raftpb.ConfState] "cs2") in
    (raftpb.ConfState__Equivalent (![raftpb.ConfState] "cs1")) "$a0") in
    do:  ("err" <-[error] "$r0");;;
    (if: (![error] "err") = #interface.nil
    then return: (#())
    else do:  #());;;
    do:  (let: "$a0" := ((let: "$sl0" := (![error] "err") in
    slice.literal interfaceT ["$sl0"])) in
    (interface.get "Panic" (![Logger] "l")) "$a0")).

(* go: state_trace_nop.go:30:6 *)
Definition traceInitState : val :=
  rec: "traceInitState" "" :=
    exception_do (let: "" := (ref_ty ptrT "") in
    do:  #()).

(* voteResponseType maps vote and prevote message types to their corresponding responses.

   go: util.go:70:6 *)
Definition voteRespMsgType : val :=
  rec: "voteRespMsgType" "msgt" :=
    exception_do (let: "msgt" := (ref_ty raftpb.MessageType "msgt") in
    let: "$sw" := (![raftpb.MessageType] "msgt") in
    (if: "$sw" = raftpb.MsgVote
    then return: (raftpb.MsgVoteResp)
    else
      (if: "$sw" = raftpb.MsgPreVote
      then return: (raftpb.MsgPreVoteResp)
      else
        do:  (let: "$a0" := (interface.make string__mset (let: "$a0" := #"not a vote message: %s" in
        let: "$a1" := ((let: "$sl0" := (interface.make raftpb.MessageType__mset (![raftpb.MessageType] "msgt")) in
        slice.literal interfaceT ["$sl0"])) in
        fmt.Sprintf "$a0" "$a1")) in
        Panic "$a0")))).

(* reduceUncommittedSize accounts for the newly committed entries by decreasing
   the uncommitted entry size limit.

   go: raft.go:2137:16 *)
Definition raft__reduceUncommittedSize : val :=
  rec: "raft__reduceUncommittedSize" "r" "s" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "s" := (ref_ty entryPayloadSize "s") in
    (if: (![entryPayloadSize] "s") > (![entryPayloadSize] (struct.field_ref raft "uncommittedSize" (![ptrT] "r")))
    then
      let: "$r0" := #(W64 0) in
      do:  ((struct.field_ref raft "uncommittedSize" (![ptrT] "r")) <-[entryPayloadSize] "$r0")
    else do:  ((struct.field_ref raft "uncommittedSize" (![ptrT] "r")) <-[entryPayloadSize] ((![entryPayloadSize] (struct.field_ref raft "uncommittedSize" (![ptrT] "r"))) - (![entryPayloadSize] "s"))))).

(* go: node.go:484:6 *)
Definition confChangeToMsg : val :=
  rec: "confChangeToMsg" "c" :=
    exception_do (let: "c" := (ref_ty raftpb.ConfChangeI "c") in
    let: "err" := (ref_ty error (zero_val error)) in
    let: "data" := (ref_ty sliceT (zero_val sliceT)) in
    let: "typ" := (ref_ty raftpb.EntryType (zero_val raftpb.EntryType)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![raftpb.ConfChangeI] "c") in
    raftpb.MarshalConfChange "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("typ" <-[raftpb.EntryType] "$r0");;;
    do:  ("data" <-[sliceT] "$r1");;;
    do:  ("err" <-[error] "$r2");;;
    (if: (![error] "err") ≠ #interface.nil
    then
      return: (struct.make raftpb.Message [{
       }], ![error] "err")
    else do:  #());;;
    return: (struct.make raftpb.Message [{
       "Type" ::= raftpb.MsgProp;
       "Entries" ::= (let: "$sl0" := (struct.make raftpb.Entry [{
         "Type" ::= ![raftpb.EntryType] "typ";
         "Data" ::= ![sliceT] "data"
       }]) in
       slice.literal raftpb.Entry ["$sl0"])
     }], #interface.nil)).

(* go: raft.go:748:16 *)
Definition raft__appliedTo : val :=
  rec: "raft__appliedTo" "r" "index" "size" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "size" := (ref_ty entryEncodingSize "size") in
    let: "index" := (ref_ty uint64T "index") in
    let: "oldApplied" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (![uint64T] (struct.field_ref raftLog "applied" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r"))))) in
    do:  ("oldApplied" <-[uint64T] "$r0");;;
    let: "newApplied" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (let: "$a0" := (![uint64T] "index") in
    let: "$a1" := (![uint64T] "oldApplied") in
    (maxUint64 2) "$a0" "$a1") in
    do:  ("newApplied" <-[uint64T] "$r0");;;
    do:  (let: "$a0" := (![uint64T] "newApplied") in
    let: "$a1" := (![entryEncodingSize] "size") in
    (raftLog__appliedTo (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) "$a0" "$a1");;;
    (if: ((![boolT] (struct.field_ref tracker.Config "AutoLeave" (struct.field_ref tracker.ProgressTracker "Config" (struct.field_ref raft "trk" (![ptrT] "r"))))) && ((![uint64T] "newApplied") ≥ (![uint64T] (struct.field_ref raft "pendingConfIndex" (![ptrT] "r"))))) && ((![StateType] (struct.field_ref raft "state" (![ptrT] "r"))) = StateLeader)
    then
      let: "err" := (ref_ty error (zero_val error)) in
      let: "m" := (ref_ty raftpb.Message (zero_val raftpb.Message)) in
      let: ("$ret0", "$ret1") := (let: "$a0" := #interface.nil in
      confChangeToMsg "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("m" <-[raftpb.Message] "$r0");;;
      do:  ("err" <-[error] "$r1");;;
      (if: (![error] "err") ≠ #interface.nil
      then
        do:  (let: "$a0" := (![error] "err") in
        Panic "$a0")
      else do:  #());;;
      (let: "err" := (ref_ty error (zero_val error)) in
      let: "$r0" := (let: "$a0" := (![raftpb.Message] "m") in
      (![funcT] (struct.field_ref raft "StepHigherOrder" (![ptrT] "r"))) "$a0") in
      do:  ("err" <-[error] "$r0");;;
      (if: (![error] "err") ≠ #interface.nil
      then
        do:  (let: "$a0" := #"not initiating automatic transition out of joint configuration %s: %v" in
        let: "$a1" := ((let: "$sl0" := (interface.make tracker.Config__mset (![tracker.Config] (struct.field_ref tracker.ProgressTracker "Config" (struct.field_ref raft "trk" (![ptrT] "r"))))) in
        let: "$sl1" := (![error] "err") in
        slice.literal interfaceT ["$sl0"; "$sl1"])) in
        (interface.get "Debugf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1")
      else
        do:  (let: "$a0" := #"initiating automatic transition out of joint configuration %s" in
        let: "$a1" := ((let: "$sl0" := (interface.make tracker.Config__mset (![tracker.Config] (struct.field_ref tracker.ProgressTracker "Config" (struct.field_ref raft "trk" (![ptrT] "r"))))) in
        slice.literal interfaceT ["$sl0"])) in
        (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1")))
    else do:  #())).

(* go: raft.go:777:16 *)
Definition raft__appliedSnap : val :=
  rec: "raft__appliedSnap" "r" "snap" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "snap" := (ref_ty ptrT "snap") in
    let: "index" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (![uint64T] (struct.field_ref raftpb.SnapshotMetadata "Index" (struct.field_ref raftpb.Snapshot "Metadata" (![ptrT] "snap")))) in
    do:  ("index" <-[uint64T] "$r0");;;
    do:  (let: "$a0" := (![uint64T] "index") in
    (raftLog__stableSnapTo (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) "$a0");;;
    do:  (let: "$a0" := (![uint64T] "index") in
    let: "$a1" := #(W64 0) in
    (raft__appliedTo (![ptrT] "r")) "$a0" "$a1")).

Definition CampaignType : go_type := stringT.

Definition campaignTransfer : expr := #"CampaignTransfer".

(* go: state_trace_nop.go:40:6 *)
Definition traceBecomeCandidate : val :=
  rec: "traceBecomeCandidate" "" :=
    exception_do (let: "" := (ref_ty ptrT "") in
    do:  #()).

Definition StateCandidate : expr := #(W64 1).

(* go: raft.go:920:16 *)
Definition raft__becomeCandidate : val :=
  rec: "raft__becomeCandidate" "r" <> :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    (if: (![StateType] (struct.field_ref raft "state" (![ptrT] "r"))) = StateLeader
    then
      do:  (let: "$a0" := (interface.make string__mset #"invalid transition [leader -> candidate]") in
      Panic "$a0")
    else do:  #());;;
    let: "$r0" := (![funcT] "stepCandidateGlobal") in
    do:  ((struct.field_ref raft "step" (![ptrT] "r")) <-[funcT] "$r0");;;
    do:  (let: "$a0" := ((![uint64T] (struct.field_ref raft "Term" (![ptrT] "r"))) + #(W64 1)) in
    (raft__reset (![ptrT] "r")) "$a0");;;
    let: "$r0" := tickElectionId in
    do:  ((struct.field_ref raft "tickId" (![ptrT] "r")) <-[intT] "$r0");;;
    let: "$r0" := (![uint64T] (struct.field_ref raft "id" (![ptrT] "r"))) in
    do:  ((struct.field_ref raft "Vote" (![ptrT] "r")) <-[uint64T] "$r0");;;
    let: "$r0" := StateCandidate in
    do:  ((struct.field_ref raft "state" (![ptrT] "r")) <-[StateType] "$r0");;;
    do:  (let: "$a0" := #"%x became candidate at term %d" in
    let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
    let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
    slice.literal interfaceT ["$sl0"; "$sl1"])) in
    (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
    do:  (let: "$a0" := (![ptrT] "r") in
    traceBecomeCandidate "$a0")).

Definition campaignPreElection : expr := #"CampaignPreElection".

Definition StatePreCandidate : expr := #(W64 3).

(* go: raft.go:935:16 *)
Definition raft__becomePreCandidate : val :=
  rec: "raft__becomePreCandidate" "r" <> :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    (if: (![StateType] (struct.field_ref raft "state" (![ptrT] "r"))) = StateLeader
    then
      do:  (let: "$a0" := (interface.make string__mset #"invalid transition [leader -> pre-candidate]") in
      Panic "$a0")
    else do:  #());;;
    let: "$r0" := (![funcT] "stepCandidateGlobal") in
    do:  ((struct.field_ref raft "step" (![ptrT] "r")) <-[funcT] "$r0");;;
    do:  ((tracker.ProgressTracker__ResetVotes (struct.field_ref raft "trk" (![ptrT] "r"))) #());;;
    let: "$r0" := tickElectionId in
    do:  ((struct.field_ref raft "tickId" (![ptrT] "r")) <-[intT] "$r0");;;
    let: "$r0" := None in
    do:  ((struct.field_ref raft "lead" (![ptrT] "r")) <-[uint64T] "$r0");;;
    let: "$r0" := StatePreCandidate in
    do:  ((struct.field_ref raft "state" (![ptrT] "r")) <-[StateType] "$r0");;;
    do:  (let: "$a0" := #"%x became pre-candidate at term %d" in
    let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
    let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
    slice.literal interfaceT ["$sl0"; "$sl1"])) in
    (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1")).

(* promotable indicates whether state machine can be promoted to leader,
   which is true when its own id is in progress list.

   go: raft.go:1967:16 *)
Definition raft__promotable : val :=
  rec: "raft__promotable" "r" <> :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "pr" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (Fst (map.get (![tracker.ProgressMap] (struct.field_ref tracker.ProgressTracker "Progress" (struct.field_ref raft "trk" (![ptrT] "r")))) (![uint64T] (struct.field_ref raft "id" (![ptrT] "r"))))) in
    do:  ("pr" <-[ptrT] "$r0");;;
    return: ((((![ptrT] "pr") ≠ #null) && (~ (![boolT] (struct.field_ref tracker.Progress "IsLearner" (![ptrT] "pr"))))) && (~ ((raftLog__hasNextOrInProgressSnapshot (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #())))).

(* campaign transitions the raft instance to candidate state. This must only be
   called after verifying that this is a legitimate transition.

   go: raft.go:1043:16 *)
Definition raft__campaign : val :=
  rec: "raft__campaign" "r" "t" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "t" := (ref_ty CampaignType "t") in
    (if: (~ ((raft__promotable (![ptrT] "r")) #()))
    then
      do:  (let: "$a0" := #"%x is unpromotable; campaign() should have been called" in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
      slice.literal interfaceT ["$sl0"])) in
      (interface.get "Warningf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1")
    else do:  #());;;
    let: "term" := (ref_ty uint64T (zero_val uint64T)) in
    let: "voteMsg" := (ref_ty raftpb.MessageType (zero_val raftpb.MessageType)) in
    (if: (![CampaignType] "t") = campaignPreElection
    then
      do:  ((raft__becomePreCandidate (![ptrT] "r")) #());;;
      let: "$r0" := raftpb.MsgPreVote in
      do:  ("voteMsg" <-[raftpb.MessageType] "$r0");;;
      let: "$r0" := ((![uint64T] (struct.field_ref raft "Term" (![ptrT] "r"))) + #(W64 1)) in
      do:  ("term" <-[uint64T] "$r0")
    else
      do:  ((raft__becomeCandidate (![ptrT] "r")) #());;;
      let: "$r0" := raftpb.MsgVote in
      do:  ("voteMsg" <-[raftpb.MessageType] "$r0");;;
      let: "$r0" := (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r"))) in
      do:  ("term" <-[uint64T] "$r0"));;;
    let: "ids" := (ref_ty sliceT (zero_val sliceT)) in
    let: "idMap" := (ref_ty (mapT uint64T (structT [
    ])) (zero_val (mapT uint64T (structT [
    ])))) in
    let: "$r0" := ((quorum.JointConfig__IDs (![quorum.JointConfig] (struct.field_ref tracker.Config "Voters" (struct.field_ref tracker.ProgressTracker "Config" (struct.field_ref raft "trk" (![ptrT] "r")))))) #()) in
    do:  ("idMap" <-[mapT uint64T (structT [
    ])] "$r0");;;
    let: "$r0" := (slice.make3 uint64T #(W64 0) (let: "$a0" := (![mapT uint64T (structT [
    ])] "idMap") in
    map.len "$a0")) in
    do:  ("ids" <-[sliceT] "$r0");;;
    do:  (map.for_range (![mapT uint64T (structT [
    ])] "idMap") (λ: "id" <>,
      let: "$r0" := (let: "$a0" := (![sliceT] "ids") in
      let: "$a1" := ((let: "$sl0" := (![uint64T] "id") in
      slice.literal uint64T ["$sl0"])) in
      (slice.append sliceT) "$a0" "$a1") in
      do:  ("ids" <-[sliceT] "$r0")));;;
    do:  (let: "$a0" := (interface.make slice__mset (![sliceT] "ids")) in
    let: "$a1" := (λ: "i" "j",
      exception_do (let: "j" := (ref_ty intT "j") in
      let: "i" := (ref_ty intT "i") in
      return: ((![uint64T] (slice.elem_ref uint64T (![sliceT] "ids") (![intT] "i"))) < (![uint64T] (slice.elem_ref uint64T (![sliceT] "ids") (![intT] "j")))))
      ) in
    sort.Slice "$a0" "$a1");;;
    do:  (let: "$range" := (![sliceT] "ids") in
    slice.for_range uint64T "$range" (λ: <> "id",
      let: "id" := ref_ty uint64T "id" in
      (if: (![uint64T] "id") = (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))
      then
        do:  (let: "$a0" := (struct.make raftpb.Message [{
          "To" ::= ![uint64T] "id";
          "Term" ::= ![uint64T] "term";
          "Type" ::= let: "$a0" := (![raftpb.MessageType] "voteMsg") in
          voteRespMsgType "$a0"
        }]) in
        (raft__send (![ptrT] "r")) "$a0");;;
        continue: #()
      else do:  #());;;
      let: "last" := (ref_ty entryID (zero_val entryID)) in
      let: "$r0" := ((raftLog__lastEntryID (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()) in
      do:  ("last" <-[entryID] "$r0");;;
      do:  (let: "$a0" := #"%x [logterm: %d, index: %d] sent %s request to %x at term %d" in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
      let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref entryID "term" "last"))) in
      let: "$sl2" := (interface.make uint64__mset (![uint64T] (struct.field_ref entryID "index" "last"))) in
      let: "$sl3" := (interface.make raftpb.MessageType__mset (![raftpb.MessageType] "voteMsg")) in
      let: "$sl4" := (interface.make uint64__mset (![uint64T] "id")) in
      let: "$sl5" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
      slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"; "$sl4"; "$sl5"])) in
      (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
      let: "ctx" := (ref_ty sliceT (zero_val sliceT)) in
      (if: (![CampaignType] "t") = campaignTransfer
      then
        let: "$r0" := (string.to_bytes (![CampaignType] "t")) in
        do:  ("ctx" <-[sliceT] "$r0")
      else do:  #());;;
      do:  (let: "$a0" := (struct.make raftpb.Message [{
        "To" ::= ![uint64T] "id";
        "Term" ::= ![uint64T] "term";
        "Type" ::= ![raftpb.MessageType] "voteMsg";
        "Index" ::= ![uint64T] (struct.field_ref entryID "index" "last");
        "LogTerm" ::= ![uint64T] (struct.field_ref entryID "term" "last");
        "Context" ::= ![sliceT] "ctx"
      }]) in
      (raft__send (![ptrT] "r")) "$a0")))).

(* go: raft.go:1013:16 *)
Definition raft__hasUnappliedConfChanges : val :=
  rec: "raft__hasUnappliedConfChanges" "r" <> :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    (if: (![uint64T] (struct.field_ref raftLog "applied" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r"))))) ≥ (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))))
    then return: (#false)
    else do:  #());;;
    let: "found" := (ref_ty boolT (zero_val boolT)) in
    let: "$r0" := #false in
    do:  ("found" <-[boolT] "$r0");;;
    let: "hi" := (ref_ty uint64T (zero_val uint64T)) in
    let: "lo" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := ((![uint64T] (struct.field_ref raftLog "applied" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r"))))) + #(W64 1)) in
    let: "$r1" := ((![uint64T] (struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r"))))) + #(W64 1)) in
    do:  ("lo" <-[uint64T] "$r0");;;
    do:  ("hi" <-[uint64T] "$r1");;;
    let: "pageSize" := (ref_ty entryEncodingSize (zero_val entryEncodingSize)) in
    let: "$r0" := (![entryEncodingSize] (struct.field_ref raftLog "maxApplyingEntsSize" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r"))))) in
    do:  ("pageSize" <-[entryEncodingSize] "$r0");;;
    (let: "err" := (ref_ty error (zero_val error)) in
    let: "$r0" := (let: "$a0" := (![uint64T] "lo") in
    let: "$a1" := (![uint64T] "hi") in
    let: "$a2" := (![entryEncodingSize] "pageSize") in
    let: "$a3" := (λ: "ents",
      exception_do (let: "ents" := (ref_ty sliceT "ents") in
      do:  (let: "$range" := (![sliceT] "ents") in
      slice.for_range raftpb.Entry "$range" (λ: "i" <>,
        let: "i" := ref_ty uint64T "i" in
        (if: ((![raftpb.EntryType] (struct.field_ref raftpb.Entry "Type" (slice.elem_ref raftpb.Entry (![sliceT] "ents") (![intT] "i")))) = raftpb.EntryConfChange) || ((![raftpb.EntryType] (struct.field_ref raftpb.Entry "Type" (slice.elem_ref raftpb.Entry (![sliceT] "ents") (![intT] "i")))) = raftpb.EntryConfChangeV2)
        then
          let: "$r0" := #true in
          do:  ("found" <-[boolT] "$r0");;;
          return: (![error] "errBreak")
        else do:  #())));;;
      return: (#interface.nil))
      ) in
    (raftLog__scan (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) "$a0" "$a1" "$a2" "$a3") in
    do:  ("err" <-[error] "$r0");;;
    (if: ((![error] "err") ≠ #interface.nil) && ((![error] "err") ≠ (![error] "errBreak"))
    then
      do:  (let: "$a0" := #"error scanning unapplied entries [%d, %d): %v" in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] "lo")) in
      let: "$sl1" := (interface.make uint64__mset (![uint64T] "hi")) in
      let: "$sl2" := (![error] "err") in
      slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
      (interface.get "Panicf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1")
    else do:  #()));;;
    return: (![boolT] "found")).

(* go: raft.go:991:16 *)
Definition raft__hup : val :=
  rec: "raft__hup" "r" "t" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "t" := (ref_ty CampaignType "t") in
    (if: (![StateType] (struct.field_ref raft "state" (![ptrT] "r"))) = StateLeader
    then
      do:  (let: "$a0" := #"%x ignoring MsgHup because already leader" in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
      slice.literal interfaceT ["$sl0"])) in
      (interface.get "Debugf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
      return: (#())
    else do:  #());;;
    (if: (~ ((raft__promotable (![ptrT] "r")) #()))
    then
      do:  (let: "$a0" := #"%x is unpromotable and can not campaign" in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
      slice.literal interfaceT ["$sl0"])) in
      (interface.get "Warningf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
      return: (#())
    else do:  #());;;
    (if: (raft__hasUnappliedConfChanges (![ptrT] "r")) #()
    then
      do:  (let: "$a0" := #"%x cannot campaign at term %d since there are still pending configuration changes to apply" in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
      let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
      slice.literal interfaceT ["$sl0"; "$sl1"])) in
      (interface.get "Warningf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
      return: (#())
    else do:  #());;;
    do:  (let: "$a0" := #"%x is starting a new election at term %d" in
    let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
    let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
    slice.literal interfaceT ["$sl0"; "$sl1"])) in
    (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
    do:  (let: "$a0" := (![CampaignType] "t") in
    (raft__campaign (![ptrT] "r")) "$a0")).

Definition campaignElection : expr := #"CampaignElection".

(* go: state_trace_nop.go:50:6 *)
Definition traceReceiveMessage : val :=
  rec: "traceReceiveMessage" "" "" :=
    exception_do (let: "" := (ref_ty ptrT "") in
    let: "" := (ref_ty ptrT "") in
    do:  #()).

(* go: raft.go:1104:16 *)
Definition raft__Step : val :=
  rec: "raft__Step" "r" "m" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "m" := (ref_ty raftpb.Message "m") in
    do:  (let: "$a0" := (![ptrT] "r") in
    let: "$a1" := "m" in
    traceReceiveMessage "$a0" "$a1");;;
    let: "$sw" := #true in
    (if: "$sw" = ((![uint64T] (struct.field_ref raftpb.Message "Term" "m")) = #(W64 0))
    then do:  #()
    else
      (if: "$sw" = ((![uint64T] (struct.field_ref raftpb.Message "Term" "m")) > (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r"))))
      then
        (if: ((![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) = raftpb.MsgVote) || ((![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) = raftpb.MsgPreVote)
        then
          let: "force" := (ref_ty boolT (zero_val boolT)) in
          let: "$r0" := (let: "$a0" := (![sliceT] (struct.field_ref raftpb.Message "Context" "m")) in
          let: "$a1" := (string.to_bytes campaignTransfer) in
          bytes.Equal "$a0" "$a1") in
          do:  ("force" <-[boolT] "$r0");;;
          let: "inLease" := (ref_ty boolT (zero_val boolT)) in
          let: "$r0" := (((![boolT] (struct.field_ref raft "checkQuorum" (![ptrT] "r"))) && ((![uint64T] (struct.field_ref raft "lead" (![ptrT] "r"))) ≠ None)) && (int_lt (![intT] (struct.field_ref raft "electionElapsed" (![ptrT] "r"))) (![intT] (struct.field_ref raft "electionTimeout" (![ptrT] "r"))))) in
          do:  ("inLease" <-[boolT] "$r0");;;
          (if: (~ (![boolT] "force")) && (![boolT] "inLease")
          then
            let: "last" := (ref_ty entryID (zero_val entryID)) in
            let: "$r0" := ((raftLog__lastEntryID (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()) in
            do:  ("last" <-[entryID] "$r0");;;
            do:  (let: "$a0" := #"%x [logterm: %d, index: %d, vote: %x] ignored %s from %x [logterm: %d, index: %d] at term %d: lease is not expired (remaining ticks: %d)" in
            let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
            let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref entryID "term" "last"))) in
            let: "$sl2" := (interface.make uint64__mset (![uint64T] (struct.field_ref entryID "index" "last"))) in
            let: "$sl3" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "Vote" (![ptrT] "r")))) in
            let: "$sl4" := (interface.make raftpb.MessageType__mset (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m"))) in
            let: "$sl5" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "From" "m"))) in
            let: "$sl6" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "LogTerm" "m"))) in
            let: "$sl7" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "Index" "m"))) in
            let: "$sl8" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
            let: "$sl9" := (interface.make int__mset ((![intT] (struct.field_ref raft "electionTimeout" (![ptrT] "r"))) - (![intT] (struct.field_ref raft "electionElapsed" (![ptrT] "r"))))) in
            slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"; "$sl4"; "$sl5"; "$sl6"; "$sl7"; "$sl8"; "$sl9"])) in
            (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
            return: (#interface.nil)
          else do:  #())
        else do:  #());;;
        let: "$sw" := #true in
        (if: "$sw" = ((![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) = raftpb.MsgPreVote)
        then do:  #()
        else
          (if: "$sw" = (((![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) = raftpb.MsgPreVoteResp) && (~ (![boolT] (struct.field_ref raftpb.Message "Reject" "m"))))
          then do:  #()
          else
            do:  (let: "$a0" := #"%x [term: %d] received a %s message with higher term from %x [term: %d]" in
            let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
            let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
            let: "$sl2" := (interface.make raftpb.MessageType__mset (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m"))) in
            let: "$sl3" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "From" "m"))) in
            let: "$sl4" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "Term" "m"))) in
            slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"; "$sl4"])) in
            (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
            (if: (((![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) = raftpb.MsgApp) || ((![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) = raftpb.MsgHeartbeat)) || ((![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) = raftpb.MsgSnap)
            then
              do:  (let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "Term" "m")) in
              let: "$a1" := (![uint64T] (struct.field_ref raftpb.Message "From" "m")) in
              (raft__becomeFollower (![ptrT] "r")) "$a0" "$a1")
            else
              do:  (let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "Term" "m")) in
              let: "$a1" := None in
              (raft__becomeFollower (![ptrT] "r")) "$a0" "$a1"))))
      else
        (if: "$sw" = ((![uint64T] (struct.field_ref raftpb.Message "Term" "m")) < (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r"))))
        then
          (if: ((![boolT] (struct.field_ref raft "checkQuorum" (![ptrT] "r"))) || (![boolT] (struct.field_ref raft "preVote" (![ptrT] "r")))) && (((![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) = raftpb.MsgHeartbeat) || ((![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) = raftpb.MsgApp))
          then
            do:  (let: "$a0" := (struct.make raftpb.Message [{
              "To" ::= ![uint64T] (struct.field_ref raftpb.Message "From" "m");
              "Type" ::= raftpb.MsgAppResp
            }]) in
            (raft__send (![ptrT] "r")) "$a0")
          else
            (if: (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) = raftpb.MsgPreVote
            then
              let: "last" := (ref_ty entryID (zero_val entryID)) in
              let: "$r0" := ((raftLog__lastEntryID (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()) in
              do:  ("last" <-[entryID] "$r0");;;
              do:  (let: "$a0" := #"%x [logterm: %d, index: %d, vote: %x] rejected %s from %x [logterm: %d, index: %d] at term %d" in
              let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
              let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref entryID "term" "last"))) in
              let: "$sl2" := (interface.make uint64__mset (![uint64T] (struct.field_ref entryID "index" "last"))) in
              let: "$sl3" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "Vote" (![ptrT] "r")))) in
              let: "$sl4" := (interface.make raftpb.MessageType__mset (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m"))) in
              let: "$sl5" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "From" "m"))) in
              let: "$sl6" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "LogTerm" "m"))) in
              let: "$sl7" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "Index" "m"))) in
              let: "$sl8" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
              slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"; "$sl4"; "$sl5"; "$sl6"; "$sl7"; "$sl8"])) in
              (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
              do:  (let: "$a0" := (struct.make raftpb.Message [{
                "To" ::= ![uint64T] (struct.field_ref raftpb.Message "From" "m");
                "Term" ::= ![uint64T] (struct.field_ref raft "Term" (![ptrT] "r"));
                "Type" ::= raftpb.MsgPreVoteResp;
                "Reject" ::= #true
              }]) in
              (raft__send (![ptrT] "r")) "$a0")
            else
              (if: (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) = raftpb.MsgStorageAppendResp
              then
                (if: (![uint64T] (struct.field_ref raftpb.Message "Index" "m")) ≠ #(W64 0)
                then
                  do:  (let: "$a0" := #"%x [term: %d] ignored entry appends from a %s message with lower term [term: %d]" in
                  let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
                  let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
                  let: "$sl2" := (interface.make raftpb.MessageType__mset (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m"))) in
                  let: "$sl3" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "Term" "m"))) in
                  slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"])) in
                  (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1")
                else do:  #());;;
                (if: (![ptrT] (struct.field_ref raftpb.Message "Snapshot" "m")) ≠ #null
                then
                  do:  (let: "$a0" := (![ptrT] (struct.field_ref raftpb.Message "Snapshot" "m")) in
                  (raft__appliedSnap (![ptrT] "r")) "$a0")
                else do:  #())
              else
                do:  (let: "$a0" := #"%x [term: %d] ignored a %s message with lower term from %x [term: %d]" in
                let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
                let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
                let: "$sl2" := (interface.make raftpb.MessageType__mset (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m"))) in
                let: "$sl3" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "From" "m"))) in
                let: "$sl4" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "Term" "m"))) in
                slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"; "$sl4"])) in
                (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1"))));;;
          return: (#interface.nil)
        else #())));;;
    let: "$sw" := (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) in
    (if: "$sw" = raftpb.MsgHup
    then
      (if: ![boolT] (struct.field_ref raft "preVote" (![ptrT] "r"))
      then
        do:  (let: "$a0" := campaignPreElection in
        (raft__hup (![ptrT] "r")) "$a0")
      else
        do:  (let: "$a0" := campaignElection in
        (raft__hup (![ptrT] "r")) "$a0"))
    else
      (if: "$sw" = raftpb.MsgStorageAppendResp
      then
        (if: (![uint64T] (struct.field_ref raftpb.Message "Index" "m")) ≠ #(W64 0)
        then
          do:  (let: "$a0" := (struct.make entryID [{
            "term" ::= ![uint64T] (struct.field_ref raftpb.Message "LogTerm" "m");
            "index" ::= ![uint64T] (struct.field_ref raftpb.Message "Index" "m")
          }]) in
          (raftLog__stableTo (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) "$a0")
        else do:  #());;;
        (if: (![ptrT] (struct.field_ref raftpb.Message "Snapshot" "m")) ≠ #null
        then
          do:  (let: "$a0" := (![ptrT] (struct.field_ref raftpb.Message "Snapshot" "m")) in
          (raft__appliedSnap (![ptrT] "r")) "$a0")
        else do:  #())
      else
        (if: "$sw" = raftpb.MsgStorageApplyResp
        then
          (if: int_gt (let: "$a0" := (![sliceT] (struct.field_ref raftpb.Message "Entries" "m")) in
          slice.len "$a0") #(W64 0)
          then
            let: "index" := (ref_ty uint64T (zero_val uint64T)) in
            let: "$r0" := (![uint64T] (struct.field_ref raftpb.Entry "Index" (slice.elem_ref raftpb.Entry (![sliceT] (struct.field_ref raftpb.Message "Entries" "m")) ((let: "$a0" := (![sliceT] (struct.field_ref raftpb.Message "Entries" "m")) in
            slice.len "$a0") - #(W64 1))))) in
            do:  ("index" <-[uint64T] "$r0");;;
            do:  (let: "$a0" := (![uint64T] "index") in
            let: "$a1" := (let: "$a0" := (![sliceT] (struct.field_ref raftpb.Message "Entries" "m")) in
            entsSize "$a0") in
            (raft__appliedTo (![ptrT] "r")) "$a0" "$a1");;;
            do:  (let: "$a0" := (let: "$a0" := (![sliceT] (struct.field_ref raftpb.Message "Entries" "m")) in
            payloadsSize "$a0") in
            (raft__reduceUncommittedSize (![ptrT] "r")) "$a0")
          else do:  #())
        else
          (if: ("$sw" = raftpb.MsgPreVote) || ("$sw" = raftpb.MsgVote)
          then
            let: "canVote" := (ref_ty boolT (zero_val boolT)) in
            let: "$r0" := ((((![uint64T] (struct.field_ref raft "Vote" (![ptrT] "r"))) = (![uint64T] (struct.field_ref raftpb.Message "From" "m"))) || (((![uint64T] (struct.field_ref raft "Vote" (![ptrT] "r"))) = None) && ((![uint64T] (struct.field_ref raft "lead" (![ptrT] "r"))) = None))) || (((![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) = raftpb.MsgPreVote) && ((![uint64T] (struct.field_ref raftpb.Message "Term" "m")) > (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))))) in
            do:  ("canVote" <-[boolT] "$r0");;;
            let: "lastID" := (ref_ty entryID (zero_val entryID)) in
            let: "$r0" := ((raftLog__lastEntryID (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()) in
            do:  ("lastID" <-[entryID] "$r0");;;
            let: "candLastID" := (ref_ty entryID (zero_val entryID)) in
            let: "$r0" := (struct.make entryID [{
              "term" ::= ![uint64T] (struct.field_ref raftpb.Message "LogTerm" "m");
              "index" ::= ![uint64T] (struct.field_ref raftpb.Message "Index" "m")
            }]) in
            do:  ("candLastID" <-[entryID] "$r0");;;
            (if: (![boolT] "canVote") && (let: "$a0" := (![entryID] "candLastID") in
            (raftLog__isUpToDate (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) "$a0")
            then
              do:  (let: "$a0" := #"%x [logterm: %d, index: %d, vote: %x] cast %s for %x [logterm: %d, index: %d] at term %d" in
              let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
              let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref entryID "term" "lastID"))) in
              let: "$sl2" := (interface.make uint64__mset (![uint64T] (struct.field_ref entryID "index" "lastID"))) in
              let: "$sl3" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "Vote" (![ptrT] "r")))) in
              let: "$sl4" := (interface.make raftpb.MessageType__mset (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m"))) in
              let: "$sl5" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "From" "m"))) in
              let: "$sl6" := (interface.make uint64__mset (![uint64T] (struct.field_ref entryID "term" "candLastID"))) in
              let: "$sl7" := (interface.make uint64__mset (![uint64T] (struct.field_ref entryID "index" "candLastID"))) in
              let: "$sl8" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
              slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"; "$sl4"; "$sl5"; "$sl6"; "$sl7"; "$sl8"])) in
              (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
              do:  (let: "$a0" := (struct.make raftpb.Message [{
                "To" ::= ![uint64T] (struct.field_ref raftpb.Message "From" "m");
                "Term" ::= ![uint64T] (struct.field_ref raftpb.Message "Term" "m");
                "Type" ::= let: "$a0" := (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) in
                voteRespMsgType "$a0"
              }]) in
              (raft__send (![ptrT] "r")) "$a0");;;
              (if: (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) = raftpb.MsgVote
              then
                let: "$r0" := #(W64 0) in
                do:  ((struct.field_ref raft "electionElapsed" (![ptrT] "r")) <-[intT] "$r0");;;
                let: "$r0" := (![uint64T] (struct.field_ref raftpb.Message "From" "m")) in
                do:  ((struct.field_ref raft "Vote" (![ptrT] "r")) <-[uint64T] "$r0")
              else do:  #())
            else
              do:  (let: "$a0" := #"%x [logterm: %d, index: %d, vote: %x] rejected %s from %x [logterm: %d, index: %d] at term %d" in
              let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
              let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref entryID "term" "lastID"))) in
              let: "$sl2" := (interface.make uint64__mset (![uint64T] (struct.field_ref entryID "index" "lastID"))) in
              let: "$sl3" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "Vote" (![ptrT] "r")))) in
              let: "$sl4" := (interface.make raftpb.MessageType__mset (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m"))) in
              let: "$sl5" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "From" "m"))) in
              let: "$sl6" := (interface.make uint64__mset (![uint64T] (struct.field_ref entryID "term" "candLastID"))) in
              let: "$sl7" := (interface.make uint64__mset (![uint64T] (struct.field_ref entryID "index" "candLastID"))) in
              let: "$sl8" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
              slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"; "$sl4"; "$sl5"; "$sl6"; "$sl7"; "$sl8"])) in
              (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
              do:  (let: "$a0" := (struct.make raftpb.Message [{
                "To" ::= ![uint64T] (struct.field_ref raftpb.Message "From" "m");
                "Term" ::= ![uint64T] (struct.field_ref raft "Term" (![ptrT] "r"));
                "Type" ::= let: "$a0" := (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) in
                voteRespMsgType "$a0";
                "Reject" ::= #true
              }]) in
              (raft__send (![ptrT] "r")) "$a0"))
          else
            let: "err" := (ref_ty error (zero_val error)) in
            let: "$r0" := (let: "$a0" := (![ptrT] "r") in
            let: "$a1" := (![raftpb.Message] "m") in
            (![funcT] (struct.field_ref raft "step" (![ptrT] "r"))) "$a0" "$a1") in
            do:  ("err" <-[error] "$r0");;;
            (if: (![error] "err") ≠ #interface.nil
            then return: (![error] "err")
            else do:  #())))));;;
    return: (#interface.nil)).

Definition ReadOnlyLeaseBased : expr := #(W64 1).

Definition LocalAppendThread : expr := #(W64 math.MaxUint64).

Definition LocalApplyThread : expr := #(W64 (math.MaxUint64 - 1)).

(* go: util.go:65:6 *)
Definition IsLocalMsgTarget : val :=
  rec: "IsLocalMsgTarget" "id" :=
    exception_do (let: "id" := (ref_ty uint64T "id") in
    return: (((![uint64T] "id") = LocalAppendThread) || ((![uint64T] "id") = LocalApplyThread))).

(* go: raft.go:291:18 *)
Definition Config__validate : val :=
  rec: "Config__validate" "c" <> :=
    exception_do (let: "c" := (ref_ty ptrT "c") in
    (if: (![uint64T] (struct.field_ref Config "ID" (![ptrT] "c"))) = None
    then
      return: (let: "$a0" := #"cannot use none as id" in
       errors.New "$a0")
    else do:  #());;;
    (if: let: "$a0" := (![uint64T] (struct.field_ref Config "ID" (![ptrT] "c"))) in
    IsLocalMsgTarget "$a0"
    then
      return: (let: "$a0" := #"cannot use local target as id" in
       errors.New "$a0")
    else do:  #());;;
    (if: int_leq (![intT] (struct.field_ref Config "HeartbeatTick" (![ptrT] "c"))) #(W64 0)
    then
      return: (let: "$a0" := #"heartbeat tick must be greater than 0" in
       errors.New "$a0")
    else do:  #());;;
    (if: int_leq (![intT] (struct.field_ref Config "ElectionTick" (![ptrT] "c"))) (![intT] (struct.field_ref Config "HeartbeatTick" (![ptrT] "c")))
    then
      return: (let: "$a0" := #"election tick must be greater than heartbeat tick" in
       errors.New "$a0")
    else do:  #());;;
    (if: (![Storage] (struct.field_ref Config "Storage" (![ptrT] "c"))) = #interface.nil
    then
      return: (let: "$a0" := #"storage cannot be nil" in
       errors.New "$a0")
    else do:  #());;;
    (if: (![uint64T] (struct.field_ref Config "MaxUncommittedEntriesSize" (![ptrT] "c"))) = #(W64 0)
    then
      let: "$r0" := #(W64 noLimit) in
      do:  ((struct.field_ref Config "MaxUncommittedEntriesSize" (![ptrT] "c")) <-[uint64T] "$r0")
    else do:  #());;;
    (if: (![uint64T] (struct.field_ref Config "MaxCommittedSizePerReady" (![ptrT] "c"))) = #(W64 0)
    then
      let: "$r0" := (![uint64T] (struct.field_ref Config "MaxSizePerMsg" (![ptrT] "c"))) in
      do:  ((struct.field_ref Config "MaxCommittedSizePerReady" (![ptrT] "c")) <-[uint64T] "$r0")
    else do:  #());;;
    (if: int_leq (![intT] (struct.field_ref Config "MaxInflightMsgs" (![ptrT] "c"))) #(W64 0)
    then
      return: (let: "$a0" := #"max inflight messages must be greater than 0" in
       errors.New "$a0")
    else do:  #());;;
    (if: (![uint64T] (struct.field_ref Config "MaxInflightBytes" (![ptrT] "c"))) = #(W64 0)
    then
      let: "$r0" := #(W64 noLimit) in
      do:  ((struct.field_ref Config "MaxInflightBytes" (![ptrT] "c")) <-[uint64T] "$r0")
    else
      (if: (![uint64T] (struct.field_ref Config "MaxInflightBytes" (![ptrT] "c"))) < (![uint64T] (struct.field_ref Config "MaxSizePerMsg" (![ptrT] "c")))
      then
        return: (let: "$a0" := #"max inflight bytes must be >= max message size" in
         errors.New "$a0")
      else do:  #()));;;
    (if: (![Logger] (struct.field_ref Config "Logger" (![ptrT] "c"))) = #interface.nil
    then
      let: "$r0" := (getLogger #()) in
      do:  ((struct.field_ref Config "Logger" (![ptrT] "c")) <-[Logger] "$r0")
    else do:  #());;;
    (if: ((![ReadOnlyOption] (struct.field_ref Config "ReadOnlyOption" (![ptrT] "c"))) = ReadOnlyLeaseBased) && (~ (![boolT] (struct.field_ref Config "CheckQuorum" (![ptrT] "c"))))
    then
      return: (let: "$a0" := #"CheckQuorum must be enabled when ReadOnlyOption is ReadOnlyLeaseBased" in
       errors.New "$a0")
    else do:  #());;;
    return: (#interface.nil)).

(* go: raft.go:444:6 *)
Definition newRaft : val :=
  rec: "newRaft" "c" :=
    exception_do (let: "c" := (ref_ty ptrT "c") in
    (let: "err" := (ref_ty error (zero_val error)) in
    let: "$r0" := ((Config__validate (![ptrT] "c")) #()) in
    do:  ("err" <-[error] "$r0");;;
    (if: (![error] "err") ≠ #interface.nil
    then
      do:  (let: "$a0" := (interface.make string__mset ((interface.get "Error" (![error] "err")) #())) in
      Panic "$a0")
    else do:  #()));;;
    let: "raftlog" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (let: "$a0" := (![Storage] (struct.field_ref Config "Storage" (![ptrT] "c"))) in
    let: "$a1" := (![Logger] (struct.field_ref Config "Logger" (![ptrT] "c"))) in
    let: "$a2" := (![uint64T] (struct.field_ref Config "MaxCommittedSizePerReady" (![ptrT] "c"))) in
    newLogWithSize "$a0" "$a1" "$a2") in
    do:  ("raftlog" <-[ptrT] "$r0");;;
    let: "err" := (ref_ty error (zero_val error)) in
    let: "cs" := (ref_ty raftpb.ConfState (zero_val raftpb.ConfState)) in
    let: "hs" := (ref_ty raftpb.HardState (zero_val raftpb.HardState)) in
    let: (("$ret0", "$ret1"), "$ret2") := ((interface.get "InitialState" (![Storage] (struct.field_ref Config "Storage" (![ptrT] "c")))) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("hs" <-[raftpb.HardState] "$r0");;;
    do:  ("cs" <-[raftpb.ConfState] "$r1");;;
    do:  ("err" <-[error] "$r2");;;
    (if: (![error] "err") ≠ #interface.nil
    then
      do:  (let: "$a0" := (![error] "err") in
      Panic "$a0")
    else do:  #());;;
    let: "r" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty raft (struct.make raft [{
      "id" ::= ![uint64T] (struct.field_ref Config "ID" (![ptrT] "c"));
      "lead" ::= None;
      "isLearner" ::= #false;
      "raftLog" ::= ![ptrT] "raftlog";
      "maxMsgSize" ::= ![uint64T] (struct.field_ref Config "MaxSizePerMsg" (![ptrT] "c"));
      "maxUncommittedSize" ::= ![uint64T] (struct.field_ref Config "MaxUncommittedEntriesSize" (![ptrT] "c"));
      "trk" ::= let: "$a0" := (![intT] (struct.field_ref Config "MaxInflightMsgs" (![ptrT] "c"))) in
      let: "$a1" := (![uint64T] (struct.field_ref Config "MaxInflightBytes" (![ptrT] "c"))) in
      tracker.MakeProgressTracker "$a0" "$a1";
      "electionTimeout" ::= ![intT] (struct.field_ref Config "ElectionTick" (![ptrT] "c"));
      "heartbeatTimeout" ::= ![intT] (struct.field_ref Config "HeartbeatTick" (![ptrT] "c"));
      "logger" ::= ![Logger] (struct.field_ref Config "Logger" (![ptrT] "c"));
      "checkQuorum" ::= ![boolT] (struct.field_ref Config "CheckQuorum" (![ptrT] "c"));
      "preVote" ::= ![boolT] (struct.field_ref Config "PreVote" (![ptrT] "c"));
      "readOnly" ::= let: "$a0" := (![ReadOnlyOption] (struct.field_ref Config "ReadOnlyOption" (![ptrT] "c"))) in
      newReadOnly "$a0";
      "disableProposalForwarding" ::= ![boolT] (struct.field_ref Config "DisableProposalForwarding" (![ptrT] "c"));
      "disableConfChangeValidation" ::= ![boolT] (struct.field_ref Config "DisableConfChangeValidation" (![ptrT] "c"));
      "stepDownOnRemoval" ::= ![boolT] (struct.field_ref Config "StepDownOnRemoval" (![ptrT] "c"));
      "traceLogger" ::= ![TraceLogger] (struct.field_ref Config "TraceLogger" (![ptrT] "c"))
    }])) in
    do:  ("r" <-[ptrT] "$r0");;;
    let: "$r0" := (raft__Step (![ptrT] "r")) in
    do:  ((struct.field_ref raft "StepHigherOrder" (![ptrT] "r")) <-[funcT] "$r0");;;
    do:  (let: "$a0" := (![ptrT] "r") in
    traceInitState "$a0");;;
    let: "lastID" := (ref_ty entryID (zero_val entryID)) in
    let: "$r0" := ((raftLog__lastEntryID (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()) in
    do:  ("lastID" <-[entryID] "$r0");;;
    let: "trk" := (ref_ty tracker.ProgressMap (zero_val tracker.ProgressMap)) in
    let: "cfg" := (ref_ty tracker.Config (zero_val tracker.Config)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (struct.make confchange.Changer [{
      "Tracker" ::= ![tracker.ProgressTracker] (struct.field_ref raft "trk" (![ptrT] "r"));
      "LastIndex" ::= ![uint64T] (struct.field_ref entryID "index" "lastID")
    }]) in
    let: "$a1" := (![raftpb.ConfState] "cs") in
    confchange.Restore "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("cfg" <-[tracker.Config] "$r0");;;
    do:  ("trk" <-[tracker.ProgressMap] "$r1");;;
    do:  ("err" <-[error] "$r2");;;
    (if: (![error] "err") ≠ #interface.nil
    then
      do:  (let: "$a0" := (![error] "err") in
      Panic "$a0")
    else do:  #());;;
    do:  (let: "$a0" := (![Logger] (struct.field_ref raft "logger" (![ptrT] "r"))) in
    let: "$a1" := (![raftpb.ConfState] "cs") in
    let: "$a2" := (let: "$a0" := (![tracker.Config] "cfg") in
    let: "$a1" := (![tracker.ProgressMap] "trk") in
    (raft__switchToConfig (![ptrT] "r")) "$a0" "$a1") in
    assertConfStatesEquivalent "$a0" "$a1" "$a2");;;
    (if: (~ (let: "$a0" := (![raftpb.HardState] "hs") in
    IsEmptyHardState "$a0"))
    then
      do:  (let: "$a0" := (![raftpb.HardState] "hs") in
      (raft__loadState (![ptrT] "r")) "$a0")
    else do:  #());;;
    (if: (![uint64T] (struct.field_ref Config "Applied" (![ptrT] "c"))) > #(W64 0)
    then
      do:  (let: "$a0" := (![uint64T] (struct.field_ref Config "Applied" (![ptrT] "c"))) in
      let: "$a1" := #(W64 0) in
      (raftLog__appliedTo (![ptrT] "raftlog")) "$a0" "$a1")
    else do:  #());;;
    do:  (let: "$a0" := (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r"))) in
    let: "$a1" := None in
    (raft__becomeFollower (![ptrT] "r")) "$a0" "$a1");;;
    let: "nodesStrs" := (ref_ty sliceT (zero_val sliceT)) in
    do:  (let: "$range" := ((tracker.ProgressTracker__VoterNodes (struct.field_ref raft "trk" (![ptrT] "r"))) #()) in
    slice.for_range uint64T "$range" (λ: <> "n",
      let: "n" := ref_ty uint64T "n" in
      let: "$r0" := (let: "$a0" := (![sliceT] "nodesStrs") in
      let: "$a1" := ((let: "$sl0" := (let: "$a0" := #"%x" in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] "n")) in
      slice.literal interfaceT ["$sl0"])) in
      fmt.Sprintf "$a0" "$a1") in
      slice.literal stringT ["$sl0"])) in
      (slice.append sliceT) "$a0" "$a1") in
      do:  ("nodesStrs" <-[sliceT] "$r0")));;;
    do:  (let: "$a0" := #"newRaft %x [peers: [%s], term: %d, commit: %d, applied: %d, lastindex: %d, lastterm: %d]" in
    let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
    let: "$sl1" := (interface.make string__mset (let: "$a0" := (![sliceT] "nodesStrs") in
    let: "$a1" := #"," in
    strings.Join "$a0" "$a1")) in
    let: "$sl2" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
    let: "$sl3" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))))) in
    let: "$sl4" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftLog "applied" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))))) in
    let: "$sl5" := (interface.make uint64__mset (![uint64T] (struct.field_ref entryID "index" "lastID"))) in
    let: "$sl6" := (interface.make uint64__mset (![uint64T] (struct.field_ref entryID "term" "lastID"))) in
    slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"; "$sl4"; "$sl5"; "$sl6"])) in
    (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
    return: (![ptrT] "r")).

(* NewRawNode instantiates a RawNode from the given configuration.

   See Bootstrap() for bootstrapping an initial state; this replaces the former
   'peers' argument to this method (with identical behavior). However, It is
   recommended that instead of calling Bootstrap, applications bootstrap their
   state manually by setting up a Storage that has a first index > 1 and which
   stores the desired ConfState as its InitialState.

   go: rawnode.go:51:6 *)
Definition NewRawNode : val :=
  rec: "NewRawNode" "config" :=
    exception_do (let: "config" := (ref_ty ptrT "config") in
    let: "r" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (let: "$a0" := (![ptrT] "config") in
    newRaft "$a0") in
    do:  ("r" <-[ptrT] "$r0");;;
    let: "rn" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty RawNode (struct.make RawNode [{
      "raft" ::= ![ptrT] "r"
    }])) in
    do:  ("rn" <-[ptrT] "$r0");;;
    let: "$r0" := (![boolT] (struct.field_ref Config "AsyncStorageWrites" (![ptrT] "config"))) in
    do:  ((struct.field_ref RawNode "asyncStorageWrites" (![ptrT] "rn")) <-[boolT] "$r0");;;
    let: "ss" := (ref_ty SoftState (zero_val SoftState)) in
    let: "$r0" := ((raft__softState (![ptrT] "r")) #()) in
    do:  ("ss" <-[SoftState] "$r0");;;
    let: "$r0" := "ss" in
    do:  ((struct.field_ref RawNode "prevSoftSt" (![ptrT] "rn")) <-[ptrT] "$r0");;;
    let: "$r0" := ((raft__hardState (![ptrT] "r")) #()) in
    do:  ((struct.field_ref RawNode "prevHardSt" (![ptrT] "rn")) <-[raftpb.HardState] "$r0");;;
    return: (![ptrT] "rn", #interface.nil)).

(* go: node.go:250:6 *)
Definition setupNode : val :=
  rec: "setupNode" "c" "peers" :=
    exception_do (let: "peers" := (ref_ty sliceT "peers") in
    let: "c" := (ref_ty ptrT "c") in
    (if: (let: "$a0" := (![sliceT] "peers") in
    slice.len "$a0") = #(W64 0)
    then
      do:  (let: "$a0" := (interface.make string__mset #"no peers given; use RestartNode instead") in
      Panic "$a0")
    else do:  #());;;
    let: "err" := (ref_ty error (zero_val error)) in
    let: "rn" := (ref_ty ptrT (zero_val ptrT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![ptrT] "c") in
    NewRawNode "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("rn" <-[ptrT] "$r0");;;
    do:  ("err" <-[error] "$r1");;;
    (if: (![error] "err") ≠ #interface.nil
    then
      do:  (let: "$a0" := (![error] "err") in
      Panic "$a0")
    else do:  #());;;
    let: "$r0" := (let: "$a0" := (![sliceT] "peers") in
    (RawNode__Bootstrap (![ptrT] "rn")) "$a0") in
    do:  ("err" <-[error] "$r0");;;
    (if: (![error] "err") ≠ #interface.nil
    then
      do:  (let: "$a0" := #"error occurred during starting a new node: %v" in
      let: "$a1" := ((let: "$sl0" := (![error] "err") in
      slice.literal interfaceT ["$sl0"])) in
      (interface.get "Warningf" (![Logger] (struct.field_ref Config "Logger" (![ptrT] "c")))) "$a0" "$a1")
    else do:  #());;;
    let: "n" := (ref_ty node (zero_val node)) in
    let: "$r0" := (let: "$a0" := (![ptrT] "rn") in
    newNode "$a0") in
    do:  ("n" <-[node] "$r0");;;
    return: ("n")).

(* go: node.go:551:16 *)
Definition node__Advance : val :=
  rec: "node__Advance" "n" <> :=
    exception_do (let: "n" := (ref_ty ptrT "n") in
    do:  (chan.select [("$sendVal0", "$sendChan0", (λ: <>,
        do:  #()
        ))] [("$recvChan0", (λ: "$recvVal",
        do:  #()
        ))] (InjLV #()))).

(* go: node.go:558:16 *)
Definition node__ApplyConfChange : val :=
  rec: "node__ApplyConfChange" "n" "cc" :=
    exception_do (let: "n" := (ref_ty ptrT "n") in
    let: "cc" := (ref_ty raftpb.ConfChangeI "cc") in
    let: "cs" := (ref_ty raftpb.ConfState (zero_val raftpb.ConfState)) in
    do:  (chan.select [("$sendVal0", "$sendChan0", (λ: <>,
        do:  #()
        ))] [("$recvChan0", (λ: "$recvVal",
        do:  #()
        ))] (InjLV #()));;;
    do:  (chan.select [] [("$recvChan0", (λ: "$recvVal",
        let: "$r0" := (Fst "$recvVal") in
        do:  ("cs" <-[raftpb.ConfState] "$r0");;;
        do:  #()
        )); ("$recvChan1", (λ: "$recvVal",
        do:  #()
        ))] (InjLV #()));;;
    return: ("cs")).

(* Step advances the state machine using msgs. The ctx.Err() will be returned,
   if any.

   go: node.go:510:16 *)
Definition node__stepWithWaitOption : val :=
  rec: "node__stepWithWaitOption" "n" "ctx" "m" "wait" :=
    exception_do (let: "n" := (ref_ty ptrT "n") in
    let: "wait" := (ref_ty boolT "wait") in
    let: "m" := (ref_ty raftpb.Message "m") in
    let: "ctx" := (ref_ty context.Context "ctx") in
    (if: (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) ≠ raftpb.MsgProp
    then
      do:  (chan.select [("$sendVal0", "$sendChan0", (λ: <>,
          return: (#interface.nil)
          ))] [("$recvChan0", (λ: "$recvVal",
          return: ((interface.get "Err" (![context.Context] "ctx")) #())
          )); ("$recvChan1", (λ: "$recvVal",
          return: (![error] "ErrStopped")
          ))] (InjLV #()))
    else do:  #());;;
    let: "ch" := (ref_ty (chanT msgWithResult) (zero_val (chanT msgWithResult))) in
    let: "$r0" := (![chanT msgWithResult] (struct.field_ref node "propc" (![ptrT] "n"))) in
    do:  ("ch" <-[chanT msgWithResult] "$r0");;;
    let: "pm" := (ref_ty msgWithResult (zero_val msgWithResult)) in
    let: "$r0" := (struct.make msgWithResult [{
      "m" ::= ![raftpb.Message] "m"
    }]) in
    do:  ("pm" <-[msgWithResult] "$r0");;;
    (if: ![boolT] "wait"
    then
      let: "$r0" := (chan.make error #()) in
      do:  ((struct.field_ref msgWithResult "result" "pm") <-[chanT error] "$r0")
    else do:  #());;;
    do:  (chan.select [("$sendVal0", "$sendChan0", (λ: <>,
        (if: (~ (![boolT] "wait"))
        then return: (#interface.nil)
        else do:  #())
        ))] [("$recvChan0", (λ: "$recvVal",
        return: ((interface.get "Err" (![context.Context] "ctx")) #())
        )); ("$recvChan1", (λ: "$recvVal",
        return: (![error] "ErrStopped")
        ))] (InjLV #()));;;
    do:  (chan.select [] [("$recvChan0", (λ: "$recvVal",
        let: "err" := (ref_ty error (zero_val error)) in
        let: "$r0" := (Fst "$recvVal") in
        do:  ("err" <-[error] "$r0");;;
        (if: (![error] "err") ≠ #interface.nil
        then return: (![error] "err")
        else do:  #())
        )); ("$recvChan1", (λ: "$recvVal",
        return: ((interface.get "Err" (![context.Context] "ctx")) #())
        )); ("$recvChan2", (λ: "$recvVal",
        return: (![error] "ErrStopped")
        ))] (InjLV #()));;;
    return: (#interface.nil)).

(* go: node.go:500:16 *)
Definition node__step : val :=
  rec: "node__step" "n" "ctx" "m" :=
    exception_do (let: "n" := (ref_ty ptrT "n") in
    let: "m" := (ref_ty raftpb.Message "m") in
    let: "ctx" := (ref_ty context.Context "ctx") in
    return: (let: "$a0" := (![context.Context] "ctx") in
     let: "$a1" := (![raftpb.Message] "m") in
     let: "$a2" := #false in
     (node__stepWithWaitOption (![ptrT] "n")) "$a0" "$a1" "$a2")).

(* go: node.go:467:16 *)
Definition node__Campaign : val :=
  rec: "node__Campaign" "n" "ctx" :=
    exception_do (let: "n" := (ref_ty ptrT "n") in
    let: "ctx" := (ref_ty context.Context "ctx") in
    return: (let: "$a0" := (![context.Context] "ctx") in
     let: "$a1" := (struct.make raftpb.Message [{
       "Type" ::= raftpb.MsgHup
     }]) in
     (node__step (![ptrT] "n")) "$a0" "$a1")).

(* go: node.go:606:16 *)
Definition node__ForgetLeader : val :=
  rec: "node__ForgetLeader" "n" "ctx" :=
    exception_do (let: "n" := (ref_ty ptrT "n") in
    let: "ctx" := (ref_ty context.Context "ctx") in
    return: (let: "$a0" := (![context.Context] "ctx") in
     let: "$a1" := (struct.make raftpb.Message [{
       "Type" ::= raftpb.MsgForgetLeader
     }]) in
     (node__step (![ptrT] "n")) "$a0" "$a1")).

(* go: node.go:504:16 *)
Definition node__stepWait : val :=
  rec: "node__stepWait" "n" "ctx" "m" :=
    exception_do (let: "n" := (ref_ty ptrT "n") in
    let: "m" := (ref_ty raftpb.Message "m") in
    let: "ctx" := (ref_ty context.Context "ctx") in
    return: (let: "$a0" := (![context.Context] "ctx") in
     let: "$a1" := (![raftpb.Message] "m") in
     let: "$a2" := #true in
     (node__stepWithWaitOption (![ptrT] "n")) "$a0" "$a1" "$a2")).

(* go: node.go:471:16 *)
Definition node__Propose : val :=
  rec: "node__Propose" "n" "ctx" "data" :=
    exception_do (let: "n" := (ref_ty ptrT "n") in
    let: "data" := (ref_ty sliceT "data") in
    let: "ctx" := (ref_ty context.Context "ctx") in
    return: (let: "$a0" := (![context.Context] "ctx") in
     let: "$a1" := (struct.make raftpb.Message [{
       "Type" ::= raftpb.MsgProp;
       "Entries" ::= (let: "$sl0" := (struct.make raftpb.Entry [{
         "Data" ::= ![sliceT] "data"
       }]) in
       slice.literal raftpb.Entry ["$sl0"])
     }]) in
     (node__stepWait (![ptrT] "n")) "$a0" "$a1")).

(* go: util.go:52:6 *)
Definition isMsgInArray : val :=
  rec: "isMsgInArray" "msgt" "arr" :=
    exception_do (let: "arr" := (ref_ty sliceT "arr") in
    let: "msgt" := (ref_ty raftpb.MessageType "msgt") in
    let: "i" := (ref_ty intT (zero_val intT)) in
    let: "$r0" := (to_u64 (![raftpb.MessageType] "msgt")) in
    do:  ("i" <-[intT] "$r0");;;
    return: ((int_lt (![intT] "i") (let: "$a0" := (![sliceT] "arr") in
     slice.len "$a0")) && (![boolT] (slice.elem_ref boolT (![sliceT] "arr") (![intT] "i"))))).

(* go: util.go:57:6 *)
Definition IsLocalMsg : val :=
  rec: "IsLocalMsg" "msgt" :=
    exception_do (let: "msgt" := (ref_ty raftpb.MessageType "msgt") in
    return: (let: "$a0" := (![raftpb.MessageType] "msgt") in
     let: "$a1" := (let: "$a" := "isLocalMsg" in
     array.slice "$a" #(W64 0) (array.len (arrayT 23 boolT))) in
     isMsgInArray "$a0" "$a1")).

(* go: node.go:475:16 *)
Definition node__Step : val :=
  rec: "node__Step" "n" "ctx" "m" :=
    exception_do (let: "n" := (ref_ty ptrT "n") in
    let: "m" := (ref_ty raftpb.Message "m") in
    let: "ctx" := (ref_ty context.Context "ctx") in
    (if: (let: "$a0" := (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) in
    IsLocalMsg "$a0") && (~ (let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "From" "m")) in
    IsLocalMsgTarget "$a0"))
    then return: (#interface.nil)
    else do:  #());;;
    return: (let: "$a0" := (![context.Context] "ctx") in
     let: "$a1" := (![raftpb.Message] "m") in
     (node__step (![ptrT] "n")) "$a0" "$a1")).

(* go: node.go:492:16 *)
Definition node__ProposeConfChange : val :=
  rec: "node__ProposeConfChange" "n" "ctx" "cc" :=
    exception_do (let: "n" := (ref_ty ptrT "n") in
    let: "cc" := (ref_ty raftpb.ConfChangeI "cc") in
    let: "ctx" := (ref_ty context.Context "ctx") in
    let: "err" := (ref_ty error (zero_val error)) in
    let: "msg" := (ref_ty raftpb.Message (zero_val raftpb.Message)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![raftpb.ConfChangeI] "cc") in
    confChangeToMsg "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("msg" <-[raftpb.Message] "$r0");;;
    do:  ("err" <-[error] "$r1");;;
    (if: (![error] "err") ≠ #interface.nil
    then return: (![error] "err")
    else do:  #());;;
    return: (let: "$a0" := (![context.Context] "ctx") in
     let: "$a1" := (![raftpb.Message] "msg") in
     (node__Step (![ptrT] "n")) "$a0" "$a1")).

(* go: node.go:610:16 *)
Definition node__ReadIndex : val :=
  rec: "node__ReadIndex" "n" "ctx" "rctx" :=
    exception_do (let: "n" := (ref_ty ptrT "n") in
    let: "rctx" := (ref_ty sliceT "rctx") in
    let: "ctx" := (ref_ty context.Context "ctx") in
    return: (let: "$a0" := (![context.Context] "ctx") in
     let: "$a1" := (struct.make raftpb.Message [{
       "Type" ::= raftpb.MsgReadIndex;
       "Entries" ::= (let: "$sl0" := (struct.make raftpb.Entry [{
         "Data" ::= ![sliceT] "rctx"
       }]) in
       slice.literal raftpb.Entry ["$sl0"])
     }]) in
     (node__step (![ptrT] "n")) "$a0" "$a1")).

(* go: node.go:549:16 *)
Definition node__Ready : val :=
  rec: "node__Ready" "n" <> :=
    exception_do (let: "n" := (ref_ty ptrT "n") in
    return: (![chanT Ready] (struct.field_ref node "readyc" (![ptrT] "n")))).

(* go: node.go:588:16 *)
Definition node__ReportSnapshot : val :=
  rec: "node__ReportSnapshot" "n" "id" "status" :=
    exception_do (let: "n" := (ref_ty ptrT "n") in
    let: "status" := (ref_ty SnapshotStatus "status") in
    let: "id" := (ref_ty uint64T "id") in
    let: "rej" := (ref_ty boolT (zero_val boolT)) in
    let: "$r0" := ((![SnapshotStatus] "status") = SnapshotFailure) in
    do:  ("rej" <-[boolT] "$r0");;;
    do:  (chan.select [("$sendVal0", "$sendChan0", (λ: <>,
        do:  #()
        ))] [("$recvChan0", (λ: "$recvVal",
        do:  #()
        ))] (InjLV #()))).

(* go: node.go:581:16 *)
Definition node__ReportUnreachable : val :=
  rec: "node__ReportUnreachable" "n" "id" :=
    exception_do (let: "n" := (ref_ty ptrT "n") in
    let: "id" := (ref_ty uint64T "id") in
    do:  (chan.select [("$sendVal0", "$sendChan0", (λ: <>,
        do:  #()
        ))] [("$recvChan0", (λ: "$recvVal",
        do:  #()
        ))] (InjLV #()))).

(* go: node.go:571:16 *)
Definition node__Status : val :=
  rec: "node__Status" "n" <> :=
    exception_do (let: "n" := (ref_ty ptrT "n") in
    let: "c" := (ref_ty (chanT Status) (zero_val (chanT Status))) in
    let: "$r0" := (chan.make Status #()) in
    do:  ("c" <-[chanT Status] "$r0");;;
    do:  (chan.select [("$sendVal0", "$sendChan0", (λ: <>,
        return: (Fst (chan.receive (![chanT Status] "c")))
        ))] [("$recvChan0", (λ: "$recvVal",
        return: (struct.make Status [{
         }])
        ))] (InjLV #()))).

(* go: node.go:331:16 *)
Definition node__Stop : val :=
  rec: "node__Stop" "n" <> :=
    exception_do (let: "n" := (ref_ty ptrT "n") in
    do:  (chan.select [("$sendVal0", "$sendChan0", (λ: <>,
        do:  #()
        ))] [("$recvChan0", (λ: "$recvVal",
        return: (#())
        ))] (InjLV #()));;;
    do:  (Fst (chan.receive (![chanT (structT [
    ])] (struct.field_ref node "done" (![ptrT] "n")))))).

(* Tick increments the internal logical clock for this Node. Election timeouts
   and heartbeat timeouts are in units of ticks.

   go: node.go:458:16 *)
Definition node__Tick : val :=
  rec: "node__Tick" "n" <> :=
    exception_do (let: "n" := (ref_ty ptrT "n") in
    do:  (chan.select [("$sendVal0", "$sendChan0", (λ: <>,
        do:  #()
        ))] [("$recvChan0", (λ: "$recvVal",
        do:  #()
        ))] (InjR (λ: <>,
      do:  (let: "$a0" := #"%x A tick missed to fire. Node blocks too long!" in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] (struct.field_ref node "rn" (![ptrT] "n")))))))) in
      slice.literal interfaceT ["$sl0"])) in
      (interface.get "Warningf" (![Logger] (struct.field_ref raft "logger" (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] (struct.field_ref node "rn" (![ptrT] "n")))))))) "$a0" "$a1")
      )))).

(* go: node.go:597:16 *)
Definition node__TransferLeadership : val :=
  rec: "node__TransferLeadership" "n" "ctx" "lead" "transferee" :=
    exception_do (let: "n" := (ref_ty ptrT "n") in
    let: "transferee" := (ref_ty uint64T "transferee") in
    let: "lead" := (ref_ty uint64T "lead") in
    let: "ctx" := (ref_ty context.Context "ctx") in
    do:  (chan.select [("$sendVal0", "$sendChan0", (λ: <>,
        do:  #()
        ))] [("$recvChan0", (λ: "$recvVal",
        do:  #()
        )); ("$recvChan1", (λ: "$recvVal",
        do:  #()
        ))] (InjLV #()))).

(* go: util.go:61:6 *)
Definition IsResponseMsg : val :=
  rec: "IsResponseMsg" "msgt" :=
    exception_do (let: "msgt" := (ref_ty raftpb.MessageType "msgt") in
    return: (let: "$a0" := (![raftpb.MessageType] "msgt") in
     let: "$a1" := (let: "$a" := "isResponseMsg" in
     array.slice "$a" #(W64 0) (array.len (arrayT 23 boolT))) in
     isMsgInArray "$a0" "$a1")).

Definition tickHeartbeatId : expr := #(W64 1).

(* tickHeartbeat is run by leaders to send a MsgBeat after r.heartbeatTimeout.

   go: raft.go:880:16 *)
Definition raft__tickHeartbeat : val :=
  rec: "raft__tickHeartbeat" "r" <> :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    do:  ((struct.field_ref raft "heartbeatElapsed" (![ptrT] "r")) <-[intT] ((![intT] (struct.field_ref raft "heartbeatElapsed" (![ptrT] "r"))) + #(W64 1)));;;
    do:  ((struct.field_ref raft "electionElapsed" (![ptrT] "r")) <-[intT] ((![intT] (struct.field_ref raft "electionElapsed" (![ptrT] "r"))) + #(W64 1)));;;
    (if: int_geq (![intT] (struct.field_ref raft "electionElapsed" (![ptrT] "r"))) (![intT] (struct.field_ref raft "electionTimeout" (![ptrT] "r")))
    then
      let: "$r0" := #(W64 0) in
      do:  ((struct.field_ref raft "electionElapsed" (![ptrT] "r")) <-[intT] "$r0");;;
      (if: ![boolT] (struct.field_ref raft "checkQuorum" (![ptrT] "r"))
      then
        (let: "err" := (ref_ty error (zero_val error)) in
        let: "$r0" := (let: "$a0" := (struct.make raftpb.Message [{
          "From" ::= ![uint64T] (struct.field_ref raft "id" (![ptrT] "r"));
          "Type" ::= raftpb.MsgCheckQuorum
        }]) in
        (raft__Step (![ptrT] "r")) "$a0") in
        do:  ("err" <-[error] "$r0");;;
        (if: (![error] "err") ≠ #interface.nil
        then
          do:  (let: "$a0" := #"error occurred during checking sending heartbeat: %v" in
          let: "$a1" := ((let: "$sl0" := (![error] "err") in
          slice.literal interfaceT ["$sl0"])) in
          (interface.get "Debugf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1")
        else do:  #()))
      else do:  #());;;
      (if: ((![StateType] (struct.field_ref raft "state" (![ptrT] "r"))) = StateLeader) && ((![uint64T] (struct.field_ref raft "leadTransferee" (![ptrT] "r"))) ≠ None)
      then do:  ((raft__abortLeaderTransfer (![ptrT] "r")) #())
      else do:  #())
    else do:  #());;;
    (if: (![StateType] (struct.field_ref raft "state" (![ptrT] "r"))) ≠ StateLeader
    then return: (#())
    else do:  #());;;
    (if: int_geq (![intT] (struct.field_ref raft "heartbeatElapsed" (![ptrT] "r"))) (![intT] (struct.field_ref raft "heartbeatTimeout" (![ptrT] "r")))
    then
      let: "$r0" := #(W64 0) in
      do:  ((struct.field_ref raft "heartbeatElapsed" (![ptrT] "r")) <-[intT] "$r0");;;
      (let: "err" := (ref_ty error (zero_val error)) in
      let: "$r0" := (let: "$a0" := (struct.make raftpb.Message [{
        "From" ::= ![uint64T] (struct.field_ref raft "id" (![ptrT] "r"));
        "Type" ::= raftpb.MsgBeat
      }]) in
      (raft__Step (![ptrT] "r")) "$a0") in
      do:  ("err" <-[error] "$r0");;;
      (if: (![error] "err") ≠ #interface.nil
      then
        do:  (let: "$a0" := #"error occurred during checking sending heartbeat: %v" in
        let: "$a1" := ((let: "$sl0" := (![error] "err") in
        slice.literal interfaceT ["$sl0"])) in
        (interface.get "Debugf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1")
      else do:  #()))
    else do:  #())).

(* pastElectionTimeout returns true if r.electionElapsed is greater
   than or equal to the randomized election timeout in
   [electiontimeout, 2 * electiontimeout - 1].

   go: raft.go:2070:16 *)
Definition raft__pastElectionTimeout : val :=
  rec: "raft__pastElectionTimeout" "r" <> :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    return: (int_geq (![intT] (struct.field_ref raft "electionElapsed" (![ptrT] "r"))) (![intT] (struct.field_ref raft "randomizedElectionTimeout" (![ptrT] "r"))))).

(* tickElection is run by followers and candidates after r.electionTimeout.

   go: raft.go:868:16 *)
Definition raft__tickElection : val :=
  rec: "raft__tickElection" "r" <> :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    do:  ((struct.field_ref raft "electionElapsed" (![ptrT] "r")) <-[intT] ((![intT] (struct.field_ref raft "electionElapsed" (![ptrT] "r"))) + #(W64 1)));;;
    (if: ((raft__promotable (![ptrT] "r")) #()) && ((raft__pastElectionTimeout (![ptrT] "r")) #())
    then
      let: "$r0" := #(W64 0) in
      do:  ((struct.field_ref raft "electionElapsed" (![ptrT] "r")) <-[intT] "$r0");;;
      (let: "err" := (ref_ty error (zero_val error)) in
      let: "$r0" := (let: "$a0" := (struct.make raftpb.Message [{
        "From" ::= ![uint64T] (struct.field_ref raft "id" (![ptrT] "r"));
        "Type" ::= raftpb.MsgHup
      }]) in
      (raft__Step (![ptrT] "r")) "$a0") in
      do:  ("err" <-[error] "$r0");;;
      (if: (![error] "err") ≠ #interface.nil
      then
        do:  (let: "$a0" := #"error occurred during election: %v" in
        let: "$a1" := ((let: "$sl0" := (![error] "err") in
        slice.literal interfaceT ["$sl0"])) in
        (interface.get "Debugf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1")
      else do:  #()))
    else do:  #())).

(* go: raft.go:858:16 *)
Definition raft__tick : val :=
  rec: "raft__tick" "r" <> :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "$sw" := (![intT] (struct.field_ref raft "tickId" (![ptrT] "r"))) in
    (if: "$sw" = tickElectionId
    then do:  ((raft__tickElection (![ptrT] "r")) #())
    else
      (if: "$sw" = tickHeartbeatId
      then do:  ((raft__tickHeartbeat (![ptrT] "r")) #())
      else #()))).

(* Tick advances the internal logical clock by a single tick.

   go: rawnode.go:64:20 *)
Definition RawNode__Tick : val :=
  rec: "RawNode__Tick" "rn" <> :=
    exception_do (let: "rn" := (ref_ty ptrT "rn") in
    do:  ((raft__tick (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))) #())).

(* go: state_trace_nop.go:32:6 *)
Definition traceReady : val :=
  rec: "traceReady" "" :=
    exception_do (let: "" := (ref_ty ptrT "") in
    do:  #()).

(* applyUnstableEntries returns whether entries are allowed to be applied once
   they are known to be committed but before they have been written locally to
   stable storage.

   go: rawnode.go:448:20 *)
Definition RawNode__applyUnstableEntries : val :=
  rec: "RawNode__applyUnstableEntries" "rn" <> :=
    exception_do (let: "rn" := (ref_ty ptrT "rn") in
    return: ((~ (![boolT] (struct.field_ref RawNode "asyncStorageWrites" (![ptrT] "rn")))))).

(* go: rawnode.go:368:6 *)
Definition needStorageApplyMsg : val :=
  rec: "needStorageApplyMsg" "rd" :=
    exception_do (let: "rd" := (ref_ty Ready "rd") in
    return: (int_gt (let: "$a0" := (![sliceT] (struct.field_ref Ready "CommittedEntries" "rd")) in
     slice.len "$a0") #(W64 0))).

(* go: rawnode.go:369:6 *)
Definition needStorageApplyRespMsg : val :=
  rec: "needStorageApplyRespMsg" "rd" :=
    exception_do (let: "rd" := (ref_ty Ready "rd") in
    return: (let: "$a0" := (![Ready] "rd") in
     needStorageApplyMsg "$a0")).

(* newStorageApplyRespMsg creates the message that should be returned to node
   after the committed entries in the current Ready (along with those in all
   prior Ready structs) have been applied to the local state machine.

   go: rawnode.go:392:6 *)
Definition newStorageApplyRespMsg : val :=
  rec: "newStorageApplyRespMsg" "r" "ents" :=
    exception_do (let: "ents" := (ref_ty sliceT "ents") in
    let: "r" := (ref_ty ptrT "r") in
    return: (struct.make raftpb.Message [{
       "Type" ::= raftpb.MsgStorageApplyResp;
       "To" ::= ![uint64T] (struct.field_ref raft "id" (![ptrT] "r"));
       "From" ::= LocalApplyThread;
       "Term" ::= #(W64 0);
       "Entries" ::= ![sliceT] "ents"
     }])).

(* go: rawnode.go:212:6 *)
Definition needStorageAppendRespMsg : val :=
  rec: "needStorageAppendRespMsg" "r" "rd" :=
    exception_do (let: "rd" := (ref_ty Ready "rd") in
    let: "r" := (ref_ty ptrT "r") in
    return: (((raftLog__hasNextOrInProgressUnstableEnts (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()) || (~ (let: "$a0" := (![raftpb.Snapshot] (struct.field_ref Ready "Snapshot" "rd")) in
     IsEmptySnap "$a0")))).

(* newStorageAppendRespMsg creates the message that should be returned to node
   after the unstable log entries, hard state, and snapshot in the current Ready
   (along with those in all prior Ready structs) have been saved to stable
   storage.

   go: rawnode.go:268:6 *)
Definition newStorageAppendRespMsg : val :=
  rec: "newStorageAppendRespMsg" "r" "rd" :=
    exception_do (let: "rd" := (ref_ty Ready "rd") in
    let: "r" := (ref_ty ptrT "r") in
    let: "m" := (ref_ty raftpb.Message (zero_val raftpb.Message)) in
    let: "$r0" := (struct.make raftpb.Message [{
      "Type" ::= raftpb.MsgStorageAppendResp;
      "To" ::= ![uint64T] (struct.field_ref raft "id" (![ptrT] "r"));
      "From" ::= LocalAppendThread;
      "Term" ::= ![uint64T] (struct.field_ref raft "Term" (![ptrT] "r"))
    }]) in
    do:  ("m" <-[raftpb.Message] "$r0");;;
    (if: (raftLog__hasNextOrInProgressUnstableEnts (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()
    then
      let: "last" := (ref_ty entryID (zero_val entryID)) in
      let: "$r0" := ((raftLog__lastEntryID (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()) in
      do:  ("last" <-[entryID] "$r0");;;
      let: "$r0" := (![uint64T] (struct.field_ref entryID "index" "last")) in
      do:  ((struct.field_ref raftpb.Message "Index" "m") <-[uint64T] "$r0");;;
      let: "$r0" := (![uint64T] (struct.field_ref entryID "term" "last")) in
      do:  ((struct.field_ref raftpb.Message "LogTerm" "m") <-[uint64T] "$r0")
    else do:  #());;;
    (if: (~ (let: "$a0" := (![raftpb.Snapshot] (struct.field_ref Ready "Snapshot" "rd")) in
    IsEmptySnap "$a0"))
    then
      let: "snap" := (ref_ty raftpb.Snapshot (zero_val raftpb.Snapshot)) in
      let: "$r0" := (![raftpb.Snapshot] (struct.field_ref Ready "Snapshot" "rd")) in
      do:  ("snap" <-[raftpb.Snapshot] "$r0");;;
      let: "$r0" := "snap" in
      do:  ((struct.field_ref raftpb.Message "Snapshot" "m") <-[ptrT] "$r0")
    else do:  #());;;
    return: (![raftpb.Message] "m")).

(* acceptReady is called when the consumer of the RawNode has decided to go
   ahead and handle a Ready. Nothing must alter the state of the RawNode between
   this call and the prior call to Ready().

   go: rawnode.go:405:20 *)
Definition RawNode__acceptReady : val :=
  rec: "RawNode__acceptReady" "rn" "rd" :=
    exception_do (let: "rn" := (ref_ty ptrT "rn") in
    let: "rd" := (ref_ty Ready "rd") in
    (if: (![ptrT] (struct.field_ref Ready "SoftState" "rd")) ≠ #null
    then
      let: "$r0" := (![ptrT] (struct.field_ref Ready "SoftState" "rd")) in
      do:  ((struct.field_ref RawNode "prevSoftSt" (![ptrT] "rn")) <-[ptrT] "$r0")
    else do:  #());;;
    (if: (~ (let: "$a0" := (![raftpb.HardState] (struct.field_ref Ready "HardState" "rd")) in
    IsEmptyHardState "$a0"))
    then
      let: "$r0" := (![raftpb.HardState] (struct.field_ref Ready "HardState" "rd")) in
      do:  ((struct.field_ref RawNode "prevHardSt" (![ptrT] "rn")) <-[raftpb.HardState] "$r0")
    else do:  #());;;
    (if: (let: "$a0" := (![sliceT] (struct.field_ref Ready "ReadStates" "rd")) in
    slice.len "$a0") ≠ #(W64 0)
    then
      let: "$r0" := #slice.nil in
      do:  ((struct.field_ref raft "readStates" (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))) <-[sliceT] "$r0")
    else do:  #());;;
    (if: (~ (![boolT] (struct.field_ref RawNode "asyncStorageWrites" (![ptrT] "rn"))))
    then
      (if: (let: "$a0" := (![sliceT] (struct.field_ref RawNode "stepsOnAdvance" (![ptrT] "rn"))) in
      slice.len "$a0") ≠ #(W64 0)
      then
        do:  (let: "$a0" := #"two accepted Ready structs without call to Advance" in
        let: "$a1" := #slice.nil in
        (interface.get "Panicf" (![Logger] (struct.field_ref raft "logger" (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))))) "$a0" "$a1")
      else do:  #());;;
      do:  (let: "$range" := (![sliceT] (struct.field_ref raft "msgsAfterAppend" (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn"))))) in
      slice.for_range raftpb.Message "$range" (λ: <> "m",
        let: "m" := ref_ty raftpb.Message "m" in
        (if: (![uint64T] (struct.field_ref raftpb.Message "To" "m")) = (![uint64T] (struct.field_ref raft "id" (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))))
        then
          let: "$r0" := (let: "$a0" := (![sliceT] (struct.field_ref RawNode "stepsOnAdvance" (![ptrT] "rn"))) in
          let: "$a1" := ((let: "$sl0" := (![raftpb.Message] "m") in
          slice.literal raftpb.Message ["$sl0"])) in
          (slice.append sliceT) "$a0" "$a1") in
          do:  ((struct.field_ref RawNode "stepsOnAdvance" (![ptrT] "rn")) <-[sliceT] "$r0")
        else do:  #())));;;
      (if: let: "$a0" := (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn"))) in
      let: "$a1" := (![Ready] "rd") in
      needStorageAppendRespMsg "$a0" "$a1"
      then
        let: "m" := (ref_ty raftpb.Message (zero_val raftpb.Message)) in
        let: "$r0" := (let: "$a0" := (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn"))) in
        let: "$a1" := (![Ready] "rd") in
        newStorageAppendRespMsg "$a0" "$a1") in
        do:  ("m" <-[raftpb.Message] "$r0");;;
        let: "$r0" := (let: "$a0" := (![sliceT] (struct.field_ref RawNode "stepsOnAdvance" (![ptrT] "rn"))) in
        let: "$a1" := ((let: "$sl0" := (![raftpb.Message] "m") in
        slice.literal raftpb.Message ["$sl0"])) in
        (slice.append sliceT) "$a0" "$a1") in
        do:  ((struct.field_ref RawNode "stepsOnAdvance" (![ptrT] "rn")) <-[sliceT] "$r0")
      else do:  #());;;
      (if: let: "$a0" := (![Ready] "rd") in
      needStorageApplyRespMsg "$a0"
      then
        let: "m" := (ref_ty raftpb.Message (zero_val raftpb.Message)) in
        let: "$r0" := (let: "$a0" := (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn"))) in
        let: "$a1" := (![sliceT] (struct.field_ref Ready "CommittedEntries" "rd")) in
        newStorageApplyRespMsg "$a0" "$a1") in
        do:  ("m" <-[raftpb.Message] "$r0");;;
        let: "$r0" := (let: "$a0" := (![sliceT] (struct.field_ref RawNode "stepsOnAdvance" (![ptrT] "rn"))) in
        let: "$a1" := ((let: "$sl0" := (![raftpb.Message] "m") in
        slice.literal raftpb.Message ["$sl0"])) in
        (slice.append sliceT) "$a0" "$a1") in
        do:  ((struct.field_ref RawNode "stepsOnAdvance" (![ptrT] "rn")) <-[sliceT] "$r0")
      else do:  #())
    else do:  #());;;
    let: "$r0" := #slice.nil in
    do:  ((struct.field_ref raft "msgs" (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))) <-[sliceT] "$r0");;;
    let: "$r0" := #slice.nil in
    do:  ((struct.field_ref raft "msgsAfterAppend" (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))) <-[sliceT] "$r0");;;
    do:  ((raftLog__acceptUnstable (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))))) #());;;
    (if: int_gt (let: "$a0" := (![sliceT] (struct.field_ref Ready "CommittedEntries" "rd")) in
    slice.len "$a0") #(W64 0)
    then
      let: "ents" := (ref_ty sliceT (zero_val sliceT)) in
      let: "$r0" := (![sliceT] (struct.field_ref Ready "CommittedEntries" "rd")) in
      do:  ("ents" <-[sliceT] "$r0");;;
      let: "index" := (ref_ty uint64T (zero_val uint64T)) in
      let: "$r0" := (![uint64T] (struct.field_ref raftpb.Entry "Index" (slice.elem_ref raftpb.Entry (![sliceT] "ents") ((let: "$a0" := (![sliceT] "ents") in
      slice.len "$a0") - #(W64 1))))) in
      do:  ("index" <-[uint64T] "$r0");;;
      do:  (let: "$a0" := (![uint64T] "index") in
      let: "$a1" := (let: "$a0" := (![sliceT] "ents") in
      entsSize "$a0") in
      let: "$a2" := ((RawNode__applyUnstableEntries (![ptrT] "rn")) #()) in
      (raftLog__acceptApplying (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))))) "$a0" "$a1" "$a2")
    else do:  #());;;
    do:  (let: "$a0" := (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn"))) in
    traceReady "$a0")).

(* Advance notifies the RawNode that the application has applied and saved progress in the
   last Ready results.

   NOTE: Advance must not be called when using AsyncStorageWrites. Response messages from
   the local append and apply threads take its place.

   go: rawnode.go:482:20 *)
Definition RawNode__Advance : val :=
  rec: "RawNode__Advance" "rn" <> :=
    exception_do (let: "rn" := (ref_ty ptrT "rn") in
    let: <> := (ref_ty Ready "_") in
    (if: ![boolT] (struct.field_ref RawNode "asyncStorageWrites" (![ptrT] "rn"))
    then
      do:  (let: "$a0" := #"Advance must not be called when using AsyncStorageWrites" in
      let: "$a1" := #slice.nil in
      (interface.get "Panicf" (![Logger] (struct.field_ref raft "logger" (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))))) "$a0" "$a1")
    else do:  #());;;
    do:  (let: "$range" := (![sliceT] (struct.field_ref RawNode "stepsOnAdvance" (![ptrT] "rn"))) in
    slice.for_range raftpb.Message "$range" (λ: "i" "m",
      let: "i" := ref_ty uint64T "i" in
      let: "m" := ref_ty raftpb.Message "m" in
      let: "$r0" := (let: "$a0" := (![raftpb.Message] "m") in
      (raft__Step (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))) "$a0") in
      do:  "$r0";;;
      let: "$r0" := (struct.make raftpb.Message [{
      }]) in
      do:  ((slice.elem_ref raftpb.Message (![sliceT] (struct.field_ref RawNode "stepsOnAdvance" (![ptrT] "rn"))) (![intT] "i")) <-[raftpb.Message] "$r0")));;;
    let: "$r0" := (let: "$s" := (![sliceT] (struct.field_ref RawNode "stepsOnAdvance" (![ptrT] "rn"))) in
    slice.slice raftpb.Message "$s" #(W64 0) #(W64 0)) in
    do:  ((struct.field_ref RawNode "stepsOnAdvance" (![ptrT] "rn")) <-[sliceT] "$r0")).

(* go: status.go:44:6 *)
Definition getProgressCopy : val :=
  rec: "getProgressCopy" "r" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "m" := (ref_ty (mapT uint64T tracker.Progress) (zero_val (mapT uint64T tracker.Progress))) in
    let: "$r0" := (map.make uint64T tracker.Progress #()) in
    do:  ("m" <-[mapT uint64T tracker.Progress] "$r0");;;
    do:  (let: "$a0" := (λ: "id" "pr",
      exception_do (let: "pr" := (ref_ty ptrT "pr") in
      let: "id" := (ref_ty uint64T "id") in
      let: "p" := (ref_ty tracker.Progress (zero_val tracker.Progress)) in
      let: "$r0" := (![tracker.Progress] (![ptrT] "pr")) in
      do:  ("p" <-[tracker.Progress] "$r0");;;
      let: "$r0" := ((tracker.Inflights__Clone (![ptrT] (struct.field_ref tracker.Progress "Inflights" (![ptrT] "pr")))) #()) in
      do:  ((struct.field_ref tracker.Progress "Inflights" "p") <-[ptrT] "$r0");;;
      let: "$r0" := #null in
      do:  ("pr" <-[ptrT] "$r0");;;
      let: "$r0" := (![tracker.Progress] "p") in
      do:  (map.insert (![mapT uint64T tracker.Progress] "m") (![uint64T] "id") "$r0"))
      ) in
    (tracker.ProgressTracker__Visit (struct.field_ref raft "trk" (![ptrT] "r"))) "$a0");;;
    return: (![mapT uint64T tracker.Progress] "m")).

(* go: status.go:56:6 *)
Definition getBasicStatus : val :=
  rec: "getBasicStatus" "r" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "s" := (ref_ty BasicStatus (zero_val BasicStatus)) in
    let: "$r0" := (struct.make BasicStatus [{
      "ID" ::= ![uint64T] (struct.field_ref raft "id" (![ptrT] "r"));
      "LeadTransferee" ::= ![uint64T] (struct.field_ref raft "leadTransferee" (![ptrT] "r"))
    }]) in
    do:  ("s" <-[BasicStatus] "$r0");;;
    let: "$r0" := ((raft__hardState (![ptrT] "r")) #()) in
    do:  ((struct.field_ref BasicStatus "HardState" "s") <-[raftpb.HardState] "$r0");;;
    let: "$r0" := ((raft__softState (![ptrT] "r")) #()) in
    do:  ((struct.field_ref BasicStatus "SoftState" "s") <-[SoftState] "$r0");;;
    let: "$r0" := (![uint64T] (struct.field_ref raftLog "applied" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r"))))) in
    do:  ((struct.field_ref BasicStatus "Applied" "s") <-[uint64T] "$r0");;;
    return: (![BasicStatus] "s")).

(* getStatus gets a copy of the current raft status.

   go: status.go:68:6 *)
Definition getStatus : val :=
  rec: "getStatus" "r" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "s" := (ref_ty Status (zero_val Status)) in
    let: "$r0" := (let: "$a0" := (![ptrT] "r") in
    getBasicStatus "$a0") in
    do:  ((struct.field_ref Status "BasicStatus" "s") <-[BasicStatus] "$r0");;;
    (if: (![StateType] (struct.field_ref SoftState "RaftState" (struct.field_ref BasicStatus "SoftState" (struct.field_ref Status "BasicStatus" "s")))) = StateLeader
    then
      let: "$r0" := (let: "$a0" := (![ptrT] "r") in
      getProgressCopy "$a0") in
      do:  ((struct.field_ref Status "Progress" "s") <-[mapT uint64T tracker.Progress] "$r0")
    else do:  #());;;
    let: "$r0" := ((tracker.Config__Clone (struct.field_ref tracker.ProgressTracker "Config" (struct.field_ref raft "trk" (![ptrT] "r")))) #()) in
    do:  ((struct.field_ref Status "Config" "s") <-[tracker.Config] "$r0");;;
    return: (![Status] "s")).

(* go: raft.go:506:16 *)
Definition raft__hasLeader : val :=
  rec: "raft__hasLeader" "r" <> :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    return: ((![uint64T] (struct.field_ref raft "lead" (![ptrT] "r"))) ≠ None)).

(* HasReady called when RawNode user need to check if any Ready pending.

   go: rawnode.go:453:20 *)
Definition RawNode__HasReady : val :=
  rec: "RawNode__HasReady" "rn" <> :=
    exception_do (let: "rn" := (ref_ty ptrT "rn") in
    let: "r" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn"))) in
    do:  ("r" <-[ptrT] "$r0");;;
    (let: "softSt" := (ref_ty SoftState (zero_val SoftState)) in
    let: "$r0" := ((raft__softState (![ptrT] "r")) #()) in
    do:  ("softSt" <-[SoftState] "$r0");;;
    (if: (~ (let: "$a0" := (![ptrT] (struct.field_ref RawNode "prevSoftSt" (![ptrT] "rn"))) in
    (SoftState__equal "softSt") "$a0"))
    then return: (#true)
    else do:  #()));;;
    (let: "hardSt" := (ref_ty raftpb.HardState (zero_val raftpb.HardState)) in
    let: "$r0" := ((raft__hardState (![ptrT] "r")) #()) in
    do:  ("hardSt" <-[raftpb.HardState] "$r0");;;
    (if: (~ (let: "$a0" := (![raftpb.HardState] "hardSt") in
    IsEmptyHardState "$a0")) && (~ (let: "$a0" := (![raftpb.HardState] "hardSt") in
    let: "$a1" := (![raftpb.HardState] (struct.field_ref RawNode "prevHardSt" (![ptrT] "rn"))) in
    isHardStateEqual "$a0" "$a1"))
    then return: (#true)
    else do:  #()));;;
    (if: (raftLog__hasNextUnstableSnapshot (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()
    then return: (#true)
    else do:  #());;;
    (if: (int_gt (let: "$a0" := (![sliceT] (struct.field_ref raft "msgs" (![ptrT] "r"))) in
    slice.len "$a0") #(W64 0)) || (int_gt (let: "$a0" := (![sliceT] (struct.field_ref raft "msgsAfterAppend" (![ptrT] "r"))) in
    slice.len "$a0") #(W64 0))
    then return: (#true)
    else do:  #());;;
    (if: ((raftLog__hasNextUnstableEnts (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()) || (let: "$a0" := ((RawNode__applyUnstableEntries (![ptrT] "rn")) #()) in
    (raftLog__hasNextCommittedEnts (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) "$a0")
    then return: (#true)
    else do:  #());;;
    (if: (let: "$a0" := (![sliceT] (struct.field_ref raft "readStates" (![ptrT] "r"))) in
    slice.len "$a0") ≠ #(W64 0)
    then return: (#true)
    else do:  #());;;
    return: (#false)).

(* newStorageApplyMsg creates the message that should be sent to the local
   apply thread to instruct it to apply committed log entries. The message
   also carries a response that should be delivered after the rest of the
   message is processed. Used with AsyncStorageWrites.

   go: rawnode.go:375:6 *)
Definition newStorageApplyMsg : val :=
  rec: "newStorageApplyMsg" "r" "rd" :=
    exception_do (let: "rd" := (ref_ty Ready "rd") in
    let: "r" := (ref_ty ptrT "r") in
    let: "ents" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (![sliceT] (struct.field_ref Ready "CommittedEntries" "rd")) in
    do:  ("ents" <-[sliceT] "$r0");;;
    return: (struct.make raftpb.Message [{
       "Type" ::= raftpb.MsgStorageApply;
       "To" ::= LocalApplyThread;
       "From" ::= ![uint64T] (struct.field_ref raft "id" (![ptrT] "r"));
       "Term" ::= #(W64 0);
       "Entries" ::= ![sliceT] "ents";
       "Responses" ::= (let: "$sl0" := (let: "$a0" := (![ptrT] "r") in
       let: "$a1" := (![sliceT] "ents") in
       newStorageApplyRespMsg "$a0" "$a1") in
       slice.literal raftpb.Message ["$sl0"])
     }])).

(* go: rawnode.go:202:6 *)
Definition needStorageAppendMsg : val :=
  rec: "needStorageAppendMsg" "r" "rd" :=
    exception_do (let: "rd" := (ref_ty Ready "rd") in
    let: "r" := (ref_ty ptrT "r") in
    return: ((((int_gt (let: "$a0" := (![sliceT] (struct.field_ref Ready "Entries" "rd")) in
     slice.len "$a0") #(W64 0)) || (~ (let: "$a0" := (![raftpb.HardState] (struct.field_ref Ready "HardState" "rd")) in
     IsEmptyHardState "$a0"))) || (~ (let: "$a0" := (![raftpb.Snapshot] (struct.field_ref Ready "Snapshot" "rd")) in
     IsEmptySnap "$a0"))) || (int_gt (let: "$a0" := (![sliceT] (struct.field_ref raft "msgsAfterAppend" (![ptrT] "r"))) in
     slice.len "$a0") #(W64 0)))).

(* newStorageAppendMsg creates the message that should be sent to the local
   append thread to instruct it to append log entries, write an updated hard
   state, and apply a snapshot. The message also carries a set of responses
   that should be delivered after the rest of the message is processed. Used
   with AsyncStorageWrites.

   go: rawnode.go:225:6 *)
Definition newStorageAppendMsg : val :=
  rec: "newStorageAppendMsg" "r" "rd" :=
    exception_do (let: "rd" := (ref_ty Ready "rd") in
    let: "r" := (ref_ty ptrT "r") in
    let: "m" := (ref_ty raftpb.Message (zero_val raftpb.Message)) in
    let: "$r0" := (struct.make raftpb.Message [{
      "Type" ::= raftpb.MsgStorageAppend;
      "To" ::= LocalAppendThread;
      "From" ::= ![uint64T] (struct.field_ref raft "id" (![ptrT] "r"));
      "Entries" ::= ![sliceT] (struct.field_ref Ready "Entries" "rd")
    }]) in
    do:  ("m" <-[raftpb.Message] "$r0");;;
    (if: (~ (let: "$a0" := (![raftpb.HardState] (struct.field_ref Ready "HardState" "rd")) in
    IsEmptyHardState "$a0"))
    then
      let: "$r0" := (![uint64T] (struct.field_ref raftpb.HardState "Term" (struct.field_ref Ready "HardState" "rd"))) in
      do:  ((struct.field_ref raftpb.Message "Term" "m") <-[uint64T] "$r0");;;
      let: "$r0" := (![uint64T] (struct.field_ref raftpb.HardState "Vote" (struct.field_ref Ready "HardState" "rd"))) in
      do:  ((struct.field_ref raftpb.Message "Vote" "m") <-[uint64T] "$r0");;;
      let: "$r0" := (![uint64T] (struct.field_ref raftpb.HardState "Commit" (struct.field_ref Ready "HardState" "rd"))) in
      do:  ((struct.field_ref raftpb.Message "Commit" "m") <-[uint64T] "$r0")
    else do:  #());;;
    (if: (~ (let: "$a0" := (![raftpb.Snapshot] (struct.field_ref Ready "Snapshot" "rd")) in
    IsEmptySnap "$a0"))
    then
      let: "snap" := (ref_ty raftpb.Snapshot (zero_val raftpb.Snapshot)) in
      let: "$r0" := (![raftpb.Snapshot] (struct.field_ref Ready "Snapshot" "rd")) in
      do:  ("snap" <-[raftpb.Snapshot] "$r0");;;
      let: "$r0" := "snap" in
      do:  ((struct.field_ref raftpb.Message "Snapshot" "m") <-[ptrT] "$r0")
    else do:  #());;;
    let: "$r0" := (![sliceT] (struct.field_ref raft "msgsAfterAppend" (![ptrT] "r"))) in
    do:  ((struct.field_ref raftpb.Message "Responses" "m") <-[sliceT] "$r0");;;
    (if: let: "$a0" := (![ptrT] "r") in
    let: "$a1" := (![Ready] "rd") in
    needStorageAppendRespMsg "$a0" "$a1"
    then
      let: "$r0" := (let: "$a0" := (![sliceT] (struct.field_ref raftpb.Message "Responses" "m")) in
      let: "$a1" := ((let: "$sl0" := (let: "$a0" := (![ptrT] "r") in
      let: "$a1" := (![Ready] "rd") in
      newStorageAppendRespMsg "$a0" "$a1") in
      slice.literal raftpb.Message ["$sl0"])) in
      (slice.append sliceT) "$a0" "$a1") in
      do:  ((struct.field_ref raftpb.Message "Responses" "m") <-[sliceT] "$r0")
    else do:  #());;;
    return: (![raftpb.Message] "m")).

(* MustSync returns true if the hard state and count of Raft entries indicate
   that a synchronous write to persistent storage is required.

   go: rawnode.go:193:6 *)
Definition MustSync : val :=
  rec: "MustSync" "st" "prevst" "entsnum" :=
    exception_do (let: "entsnum" := (ref_ty intT "entsnum") in
    let: "prevst" := (ref_ty raftpb.HardState "prevst") in
    let: "st" := (ref_ty raftpb.HardState "st") in
    return: ((((![intT] "entsnum") ≠ #(W64 0)) || ((![uint64T] (struct.field_ref raftpb.HardState "Vote" "st")) ≠ (![uint64T] (struct.field_ref raftpb.HardState "Vote" "prevst")))) || ((![uint64T] (struct.field_ref raftpb.HardState "Term" "st")) ≠ (![uint64T] (struct.field_ref raftpb.HardState "Term" "prevst"))))).

(* readyWithoutAccept returns a Ready. This is a read-only operation, i.e. there
   is no obligation that the Ready must be handled.

   go: rawnode.go:141:20 *)
Definition RawNode__readyWithoutAccept : val :=
  rec: "RawNode__readyWithoutAccept" "rn" <> :=
    exception_do (let: "rn" := (ref_ty ptrT "rn") in
    let: "r" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn"))) in
    do:  ("r" <-[ptrT] "$r0");;;
    let: "rd" := (ref_ty Ready (zero_val Ready)) in
    let: "$r0" := (struct.make Ready [{
      "Entries" ::= (raftLog__nextUnstableEnts (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #();
      "CommittedEntries" ::= let: "$a0" := ((RawNode__applyUnstableEntries (![ptrT] "rn")) #()) in
      (raftLog__nextCommittedEnts (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) "$a0";
      "Messages" ::= ![sliceT] (struct.field_ref raft "msgs" (![ptrT] "r"))
    }]) in
    do:  ("rd" <-[Ready] "$r0");;;
    (let: "softSt" := (ref_ty SoftState (zero_val SoftState)) in
    let: "$r0" := ((raft__softState (![ptrT] "r")) #()) in
    do:  ("softSt" <-[SoftState] "$r0");;;
    (if: (~ (let: "$a0" := (![ptrT] (struct.field_ref RawNode "prevSoftSt" (![ptrT] "rn"))) in
    (SoftState__equal "softSt") "$a0"))
    then
      let: "escapingSoftSt" := (ref_ty SoftState (zero_val SoftState)) in
      let: "$r0" := (![SoftState] "softSt") in
      do:  ("escapingSoftSt" <-[SoftState] "$r0");;;
      let: "$r0" := "escapingSoftSt" in
      do:  ((struct.field_ref Ready "SoftState" "rd") <-[ptrT] "$r0")
    else do:  #()));;;
    (let: "hardSt" := (ref_ty raftpb.HardState (zero_val raftpb.HardState)) in
    let: "$r0" := ((raft__hardState (![ptrT] "r")) #()) in
    do:  ("hardSt" <-[raftpb.HardState] "$r0");;;
    (if: (~ (let: "$a0" := (![raftpb.HardState] "hardSt") in
    let: "$a1" := (![raftpb.HardState] (struct.field_ref RawNode "prevHardSt" (![ptrT] "rn"))) in
    isHardStateEqual "$a0" "$a1"))
    then
      let: "$r0" := (![raftpb.HardState] "hardSt") in
      do:  ((struct.field_ref Ready "HardState" "rd") <-[raftpb.HardState] "$r0")
    else do:  #()));;;
    (if: (raftLog__hasNextUnstableSnapshot (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()
    then
      let: "$r0" := (![raftpb.Snapshot] ((raftLog__nextUnstableSnapshot (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #())) in
      do:  ((struct.field_ref Ready "Snapshot" "rd") <-[raftpb.Snapshot] "$r0")
    else do:  #());;;
    (if: (let: "$a0" := (![sliceT] (struct.field_ref raft "readStates" (![ptrT] "r"))) in
    slice.len "$a0") ≠ #(W64 0)
    then
      let: "$r0" := (![sliceT] (struct.field_ref raft "readStates" (![ptrT] "r"))) in
      do:  ((struct.field_ref Ready "ReadStates" "rd") <-[sliceT] "$r0")
    else do:  #());;;
    let: "$r0" := (let: "$a0" := ((raft__hardState (![ptrT] "r")) #()) in
    let: "$a1" := (![raftpb.HardState] (struct.field_ref RawNode "prevHardSt" (![ptrT] "rn"))) in
    let: "$a2" := (let: "$a0" := (![sliceT] (struct.field_ref Ready "Entries" "rd")) in
    slice.len "$a0") in
    MustSync "$a0" "$a1" "$a2") in
    do:  ((struct.field_ref Ready "MustSync" "rd") <-[boolT] "$r0");;;
    (if: ![boolT] (struct.field_ref RawNode "asyncStorageWrites" (![ptrT] "rn"))
    then
      (if: let: "$a0" := (![ptrT] "r") in
      let: "$a1" := (![Ready] "rd") in
      needStorageAppendMsg "$a0" "$a1"
      then
        let: "m" := (ref_ty raftpb.Message (zero_val raftpb.Message)) in
        let: "$r0" := (let: "$a0" := (![ptrT] "r") in
        let: "$a1" := (![Ready] "rd") in
        newStorageAppendMsg "$a0" "$a1") in
        do:  ("m" <-[raftpb.Message] "$r0");;;
        let: "$r0" := (let: "$a0" := (![sliceT] (struct.field_ref Ready "Messages" "rd")) in
        let: "$a1" := ((let: "$sl0" := (![raftpb.Message] "m") in
        slice.literal raftpb.Message ["$sl0"])) in
        (slice.append sliceT) "$a0" "$a1") in
        do:  ((struct.field_ref Ready "Messages" "rd") <-[sliceT] "$r0")
      else do:  #());;;
      (if: let: "$a0" := (![Ready] "rd") in
      needStorageApplyMsg "$a0"
      then
        let: "m" := (ref_ty raftpb.Message (zero_val raftpb.Message)) in
        let: "$r0" := (let: "$a0" := (![ptrT] "r") in
        let: "$a1" := (![Ready] "rd") in
        newStorageApplyMsg "$a0" "$a1") in
        do:  ("m" <-[raftpb.Message] "$r0");;;
        let: "$r0" := (let: "$a0" := (![sliceT] (struct.field_ref Ready "Messages" "rd")) in
        let: "$a1" := ((let: "$sl0" := (![raftpb.Message] "m") in
        slice.literal raftpb.Message ["$sl0"])) in
        (slice.append sliceT) "$a0" "$a1") in
        do:  ((struct.field_ref Ready "Messages" "rd") <-[sliceT] "$r0")
      else do:  #())
    else
      do:  (let: "$range" := (![sliceT] (struct.field_ref raft "msgsAfterAppend" (![ptrT] "r"))) in
      slice.for_range raftpb.Message "$range" (λ: <> "m",
        let: "m" := ref_ty raftpb.Message "m" in
        (if: (![uint64T] (struct.field_ref raftpb.Message "To" "m")) ≠ (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))
        then
          let: "$r0" := (let: "$a0" := (![sliceT] (struct.field_ref Ready "Messages" "rd")) in
          let: "$a1" := ((let: "$sl0" := (![raftpb.Message] "m") in
          slice.literal raftpb.Message ["$sl0"])) in
          (slice.append sliceT) "$a0" "$a1") in
          do:  ((struct.field_ref Ready "Messages" "rd") <-[sliceT] "$r0")
        else do:  #()))));;;
    return: (![Ready] "rd")).

(* go: node.go:343:16 *)
Definition node__run : val :=
  rec: "node__run" "n" <> :=
    exception_do (let: "n" := (ref_ty ptrT "n") in
    let: "propc" := (ref_ty (chanT msgWithResult) (zero_val (chanT msgWithResult))) in
    let: "readyc" := (ref_ty (chanT Ready) (zero_val (chanT Ready))) in
    let: "advancec" := (ref_ty (chanT (structT [
    ])) (zero_val (chanT (structT [
    ])))) in
    let: "rd" := (ref_ty Ready (zero_val Ready)) in
    let: "r" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] (struct.field_ref node "rn" (![ptrT] "n"))))) in
    do:  ("r" <-[ptrT] "$r0");;;
    let: "lead" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := None in
    do:  ("lead" <-[uint64T] "$r0");;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      (if: ((![chanT (structT [
      ])] "advancec") = #null) && ((RawNode__HasReady (![ptrT] (struct.field_ref node "rn" (![ptrT] "n")))) #())
      then
        let: "$r0" := ((RawNode__readyWithoutAccept (![ptrT] (struct.field_ref node "rn" (![ptrT] "n")))) #()) in
        do:  ("rd" <-[Ready] "$r0");;;
        let: "$r0" := (![chanT Ready] (struct.field_ref node "readyc" (![ptrT] "n"))) in
        do:  ("readyc" <-[chanT Ready] "$r0")
      else do:  #());;;
      (if: (![uint64T] "lead") ≠ (![uint64T] (struct.field_ref raft "lead" (![ptrT] "r")))
      then
        (if: (raft__hasLeader (![ptrT] "r")) #()
        then
          (if: (![uint64T] "lead") = None
          then
            do:  (let: "$a0" := #"raft.node: %x elected leader %x at term %d" in
            let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
            let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "lead" (![ptrT] "r")))) in
            let: "$sl2" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
            slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
            (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1")
          else
            do:  (let: "$a0" := #"raft.node: %x changed leader from %x to %x at term %d" in
            let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
            let: "$sl1" := (interface.make uint64__mset (![uint64T] "lead")) in
            let: "$sl2" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "lead" (![ptrT] "r")))) in
            let: "$sl3" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
            slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"])) in
            (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1"));;;
          let: "$r0" := (![chanT msgWithResult] (struct.field_ref node "propc" (![ptrT] "n"))) in
          do:  ("propc" <-[chanT msgWithResult] "$r0")
        else
          do:  (let: "$a0" := #"raft.node: %x lost leader %x at term %d" in
          let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
          let: "$sl1" := (interface.make uint64__mset (![uint64T] "lead")) in
          let: "$sl2" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
          slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
          (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
          let: "$r0" := #null in
          do:  ("propc" <-[chanT msgWithResult] "$r0"));;;
        let: "$r0" := (![uint64T] (struct.field_ref raft "lead" (![ptrT] "r"))) in
        do:  ("lead" <-[uint64T] "$r0")
      else do:  #());;;
      do:  (chan.select [("$sendVal0", "$sendChan0", (λ: <>,
          do:  (let: "$a0" := (![Ready] "rd") in
          (RawNode__acceptReady (![ptrT] (struct.field_ref node "rn" (![ptrT] "n")))) "$a0");;;
          (if: (~ (![boolT] (struct.field_ref RawNode "asyncStorageWrites" (![ptrT] (struct.field_ref node "rn" (![ptrT] "n"))))))
          then
            let: "$r0" := (![chanT (structT [
            ])] (struct.field_ref node "advancec" (![ptrT] "n"))) in
            do:  ("advancec" <-[chanT (structT [
            ])] "$r0")
          else
            let: "$r0" := (struct.make Ready [{
            }]) in
            do:  ("rd" <-[Ready] "$r0"));;;
          let: "$r0" := #null in
          do:  ("readyc" <-[chanT Ready] "$r0")
          ))] [("$recvChan0", (λ: "$recvVal",
          let: "pm" := (ref_ty msgWithResult (zero_val msgWithResult)) in
          let: "$r0" := (Fst "$recvVal") in
          do:  ("pm" <-[msgWithResult] "$r0");;;
          let: "m" := (ref_ty raftpb.Message (zero_val raftpb.Message)) in
          let: "$r0" := (![raftpb.Message] (struct.field_ref msgWithResult "m" "pm")) in
          do:  ("m" <-[raftpb.Message] "$r0");;;
          let: "$r0" := (![uint64T] (struct.field_ref raft "id" (![ptrT] "r"))) in
          do:  ((struct.field_ref raftpb.Message "From" "m") <-[uint64T] "$r0");;;
          let: "err" := (ref_ty error (zero_val error)) in
          let: "$r0" := (let: "$a0" := (![raftpb.Message] "m") in
          (raft__Step (![ptrT] "r")) "$a0") in
          do:  ("err" <-[error] "$r0");;;
          (if: (![chanT error] (struct.field_ref msgWithResult "result" "pm")) ≠ #null
          then
            do:  (let: "$chan" := (![chanT error] (struct.field_ref msgWithResult "result" "pm")) in
            let: "$v" := (![error] "err") in
            chan.send "$chan" "$v");;;
            do:  (let: "$a0" := (![chanT error] (struct.field_ref msgWithResult "result" "pm")) in
            chan.close "$a0")
          else do:  #())
          )); ("$recvChan1", (λ: "$recvVal",
          let: "m" := (ref_ty raftpb.Message (zero_val raftpb.Message)) in
          let: "$r0" := (Fst "$recvVal") in
          do:  ("m" <-[raftpb.Message] "$r0");;;
          (if: ((let: "$a0" := (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) in
          IsResponseMsg "$a0") && (~ (let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "From" "m")) in
          IsLocalMsgTarget "$a0"))) && ((Fst (map.get (![tracker.ProgressMap] (struct.field_ref tracker.ProgressTracker "Progress" (struct.field_ref raft "trk" (![ptrT] "r")))) (![uint64T] (struct.field_ref raftpb.Message "From" "m")))) = #null)
          then break: #()
          else do:  #());;;
          do:  (let: "$a0" := (![raftpb.Message] "m") in
          (raft__Step (![ptrT] "r")) "$a0")
          )); ("$recvChan2", (λ: "$recvVal",
          let: "cc" := (ref_ty raftpb.ConfChangeV2 (zero_val raftpb.ConfChangeV2)) in
          let: "$r0" := (Fst "$recvVal") in
          do:  ("cc" <-[raftpb.ConfChangeV2] "$r0");;;
          let: "okBefore" := (ref_ty boolT (zero_val boolT)) in
          let: ("$ret0", "$ret1") := (map.get (![tracker.ProgressMap] (struct.field_ref tracker.ProgressTracker "Progress" (struct.field_ref raft "trk" (![ptrT] "r")))) (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
          let: "$r0" := "$ret0" in
          let: "$r1" := "$ret1" in
          do:  "$r0";;;
          do:  ("okBefore" <-[boolT] "$r1");;;
          let: "cs" := (ref_ty raftpb.ConfState (zero_val raftpb.ConfState)) in
          let: "$r0" := (let: "$a0" := (![raftpb.ConfChangeV2] "cc") in
          (raft__applyConfChange (![ptrT] "r")) "$a0") in
          do:  ("cs" <-[raftpb.ConfState] "$r0");;;
          (let: "okAfter" := (ref_ty boolT (zero_val boolT)) in
          let: ("$ret0", "$ret1") := (map.get (![tracker.ProgressMap] (struct.field_ref tracker.ProgressTracker "Progress" (struct.field_ref raft "trk" (![ptrT] "r")))) (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
          let: "$r0" := "$ret0" in
          let: "$r1" := "$ret1" in
          do:  "$r0";;;
          do:  ("okAfter" <-[boolT] "$r1");;;
          (if: (![boolT] "okBefore") && (~ (![boolT] "okAfter"))
          then
            let: "found" := (ref_ty boolT (zero_val boolT)) in
            do:  (let: "$range" := ((let: "$sl0" := (![sliceT] (struct.field_ref raftpb.ConfState "Voters" "cs")) in
            let: "$sl1" := (![sliceT] (struct.field_ref raftpb.ConfState "VotersOutgoing" "cs")) in
            slice.literal sliceT ["$sl0"; "$sl1"])) in
            slice.for_range sliceT "$range" (λ: <> "sl",
              let: "sl" := ref_ty sliceT "sl" in
              do:  (let: "$range" := (![sliceT] "sl") in
              slice.for_range uint64T "$range" (λ: <> "id",
                let: "id" := ref_ty uint64T "id" in
                (if: (![uint64T] "id") = (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))
                then
                  let: "$r0" := #true in
                  do:  ("found" <-[boolT] "$r0");;;
                  break: #()
                else do:  #())));;;
              (if: ![boolT] "found"
              then break: #()
              else do:  #())));;;
            (if: (~ (![boolT] "found"))
            then
              let: "$r0" := #null in
              do:  ("propc" <-[chanT msgWithResult] "$r0")
            else do:  #())
          else do:  #()));;;
          do:  (chan.select [("$sendVal0", "$sendChan0", (λ: <>,
              do:  #()
              ))] [("$recvChan0", (λ: "$recvVal",
              do:  #()
              ))] (InjLV #()))
          )); ("$recvChan3", (λ: "$recvVal",
          do:  ((RawNode__Tick (![ptrT] (struct.field_ref node "rn" (![ptrT] "n")))) #())
          )); ("$recvChan4", (λ: "$recvVal",
          do:  (let: "$a0" := (![Ready] "rd") in
          (RawNode__Advance (![ptrT] (struct.field_ref node "rn" (![ptrT] "n")))) "$a0");;;
          let: "$r0" := (struct.make Ready [{
          }]) in
          do:  ("rd" <-[Ready] "$r0");;;
          let: "$r0" := #null in
          do:  ("advancec" <-[chanT (structT [
          ])] "$r0")
          )); ("$recvChan5", (λ: "$recvVal",
          let: "c" := (ref_ty (chanT Status) (zero_val (chanT Status))) in
          let: "$r0" := (Fst "$recvVal") in
          do:  ("c" <-[chanT Status] "$r0");;;
          do:  (let: "$chan" := (![chanT Status] "c") in
          let: "$v" := (let: "$a0" := (![ptrT] "r") in
          getStatus "$a0") in
          chan.send "$chan" "$v")
          )); ("$recvChan6", (λ: "$recvVal",
          do:  (let: "$a0" := (![chanT (structT [
          ])] (struct.field_ref node "done" (![ptrT] "n"))) in
          chan.close "$a0");;;
          return: (#())
          ))] (InjLV #())))).

Definition node__mset_ptr : list (string * val) := [
  ("Advance", node__Advance%V);
  ("ApplyConfChange", node__ApplyConfChange%V);
  ("Campaign", node__Campaign%V);
  ("ForgetLeader", node__ForgetLeader%V);
  ("Propose", node__Propose%V);
  ("ProposeConfChange", node__ProposeConfChange%V);
  ("ReadIndex", node__ReadIndex%V);
  ("Ready", node__Ready%V);
  ("ReportSnapshot", node__ReportSnapshot%V);
  ("ReportUnreachable", node__ReportUnreachable%V);
  ("Status", node__Status%V);
  ("Step", node__Step%V);
  ("Stop", node__Stop%V);
  ("Tick", node__Tick%V);
  ("TransferLeadership", node__TransferLeadership%V);
  ("run", node__run%V);
  ("step", node__step%V);
  ("stepWait", node__stepWait%V);
  ("stepWithWaitOption", node__stepWithWaitOption%V)
].

(* StartNode returns a new Node given configuration and a list of raft peers.
   It appends a ConfChangeAddNode entry for each given peer to the initial log.

   Peers must not be zero length; call RestartNode in that case.

   go: node.go:271:6 *)
Definition StartNode : val :=
  rec: "StartNode" "c" "peers" :=
    exception_do (let: "peers" := (ref_ty sliceT "peers") in
    let: "c" := (ref_ty ptrT "c") in
    let: "n" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (let: "$a0" := (![ptrT] "c") in
    let: "$a1" := (![sliceT] "peers") in
    setupNode "$a0" "$a1") in
    do:  ("n" <-[ptrT] "$r0");;;
    let: "$go" := (node__run (![ptrT] "n")) in
    do:  (Fork ("$go" #()));;;
    return: (interface.make node__mset_ptr (![ptrT] "n"))).

(* RestartNode is similar to StartNode but does not take a list of peers.
   The current membership of the cluster will be restored from the Storage.
   If the caller has an existing state machine, pass in the last log index that
   has been applied to it; otherwise use zero.

   go: node.go:281:6 *)
Definition RestartNode : val :=
  rec: "RestartNode" "c" :=
    exception_do (let: "c" := (ref_ty ptrT "c") in
    let: "err" := (ref_ty error (zero_val error)) in
    let: "rn" := (ref_ty ptrT (zero_val ptrT)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![ptrT] "c") in
    NewRawNode "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("rn" <-[ptrT] "$r0");;;
    do:  ("err" <-[error] "$r1");;;
    (if: (![error] "err") ≠ #interface.nil
    then
      do:  (let: "$a0" := (![error] "err") in
      Panic "$a0")
    else do:  #());;;
    let: "n" := (ref_ty node (zero_val node)) in
    let: "$r0" := (let: "$a0" := (![ptrT] "rn") in
    newNode "$a0") in
    do:  ("n" <-[node] "$r0");;;
    let: "$go" := (node__run "n") in
    do:  (Fork ("$go" #()));;;
    return: (interface.make node__mset_ptr "n")).

Definition msgWithResult__mset : list (string * val) := [
].

Definition msgWithResult__mset_ptr : list (string * val) := [
].

Definition node__mset : list (string * val) := [
].

Definition numStates : expr := #(W64 4).

Definition ReadOnlyOption__mset : list (string * val) := [
].

Definition ReadOnlyOption__mset_ptr : list (string * val) := [
].

Definition ReadOnlySafe : expr := #(W64 0).

Definition lockedRand__mset : list (string * val) := [
].

Definition lockedRand__mset_ptr : list (string * val) := [
  ("Intn", lockedRand__Intn%V)
].

Definition CampaignType__mset : list (string * val) := [
].

Definition CampaignType__mset_ptr : list (string * val) := [
].

(* go: raft.go:119:21 *)
Definition StateType__String : val :=
  rec: "StateType__String" "st" <> :=
    exception_do (let: "st" := (ref_ty StateType "st") in
    return: (![stringT] (array.elem_ref stringT (![arrayT 4 stringT] "stmap") (![StateType] "st")))).

(* go: util.go:25:21 *)
Definition StateType__MarshalJSON : val :=
  rec: "StateType__MarshalJSON" "st" <> :=
    exception_do (let: "st" := (ref_ty StateType "st") in
    return: (string.to_bytes (let: "$a0" := #"%q" in
     let: "$a1" := ((let: "$sl0" := (interface.make string__mset ((StateType__String (![StateType] "st")) #())) in
     slice.literal interfaceT ["$sl0"])) in
     fmt.Sprintf "$a0" "$a1"), #interface.nil)).

Definition StateType__mset : list (string * val) := [
  ("MarshalJSON", StateType__MarshalJSON%V);
  ("String", StateType__String%V)
].

Definition StateType__mset_ptr : list (string * val) := [
  ("MarshalJSON", (λ: "$recvAddr",
    StateType__MarshalJSON (![StateType] "$recvAddr")
    )%V);
  ("String", (λ: "$recvAddr",
    StateType__String (![StateType] "$recvAddr")
    )%V)
].

Definition Config__mset : list (string * val) := [
].

Definition Config__mset_ptr : list (string * val) := [
  ("validate", Config__validate%V)
].

Definition raft__mset : list (string * val) := [
].

(* go: raft2.go:107:16 *)
Definition raft__stepOrSend : val :=
  rec: "raft__stepOrSend" "r" "msgs" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "msgs" := (ref_ty sliceT "msgs") in
    do:  (let: "$range" := (![sliceT] "msgs") in
    slice.for_range raftpb.Message "$range" (λ: <> "m",
      let: "m" := ref_ty raftpb.Message "m" in
      (if: (![uint64T] (struct.field_ref raftpb.Message "To" "m")) = (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))
      then
        (let: "err" := (ref_ty error (zero_val error)) in
        let: "$r0" := (let: "$a0" := (![raftpb.Message] "m") in
        (raft__Step (![ptrT] "r")) "$a0") in
        do:  ("err" <-[error] "$r0");;;
        (if: (![error] "err") ≠ #interface.nil
        then return: (![error] "err")
        else do:  #()))
      else
        let: "$r0" := (let: "$a0" := (![sliceT] (struct.field_ref raft "msgs" (![ptrT] "r"))) in
        let: "$a1" := ((let: "$sl0" := (![raftpb.Message] "m") in
        slice.literal raftpb.Message ["$sl0"])) in
        (slice.append sliceT) "$a0" "$a1") in
        do:  ((struct.field_ref raft "msgs" (![ptrT] "r")) <-[sliceT] "$r0"))));;;
    return: (#interface.nil)).

(* go: raft2.go:101:16 *)
Definition raft__takeMessagesAfterAppend : val :=
  rec: "raft__takeMessagesAfterAppend" "r" <> :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "msgs" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (![sliceT] (struct.field_ref raft "msgsAfterAppend" (![ptrT] "r"))) in
    do:  ("msgs" <-[sliceT] "$r0");;;
    let: "$r0" := #slice.nil in
    do:  ((struct.field_ref raft "msgsAfterAppend" (![ptrT] "r")) <-[sliceT] "$r0");;;
    return: (![sliceT] "msgs")).

(* go: raft2.go:120:16 *)
Definition raft__advanceMessagesAfterAppend : val :=
  rec: "raft__advanceMessagesAfterAppend" "r" <> :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "msgs" := (ref_ty sliceT (zero_val sliceT)) in
      let: "$r0" := ((raft__takeMessagesAfterAppend (![ptrT] "r")) #()) in
      do:  ("msgs" <-[sliceT] "$r0");;;
      (if: (let: "$a0" := (![sliceT] "msgs") in
      slice.len "$a0") = #(W64 0)
      then break: #()
      else do:  #());;;
      do:  (let: "$a0" := (![sliceT] "msgs") in
      (raft__stepOrSend (![ptrT] "r")) "$a0"))).

(* go: state_trace_nop.go:36:6 *)
Definition traceReplicate : val :=
  rec: "traceReplicate" "" "" :=
    exception_do (let: "" := (ref_ty sliceT "") in
    let: "" := (ref_ty ptrT "") in
    do:  #()).

(* increaseUncommittedSize computes the size of the proposed entries and
   determines whether they would push leader over its maxUncommittedSize limit.
   If the new entries would exceed the limit, the method returns false. If not,
   the increase in uncommitted entry size is recorded and the method returns
   true.

   Empty payloads are never refused. This is used both for appending an empty
   entry at a new leader's term, as well as leaving a joint configuration.

   go: raft.go:2119:16 *)
Definition raft__increaseUncommittedSize : val :=
  rec: "raft__increaseUncommittedSize" "r" "ents" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "ents" := (ref_ty sliceT "ents") in
    let: "s" := (ref_ty entryPayloadSize (zero_val entryPayloadSize)) in
    let: "$r0" := (let: "$a0" := (![sliceT] "ents") in
    payloadsSize "$a0") in
    do:  ("s" <-[entryPayloadSize] "$r0");;;
    (if: (((![entryPayloadSize] (struct.field_ref raft "uncommittedSize" (![ptrT] "r"))) > #(W64 0)) && ((![entryPayloadSize] "s") > #(W64 0))) && (((![entryPayloadSize] (struct.field_ref raft "uncommittedSize" (![ptrT] "r"))) + (![entryPayloadSize] "s")) > (![entryPayloadSize] (struct.field_ref raft "maxUncommittedSize" (![ptrT] "r"))))
    then return: (#false)
    else do:  #());;;
    do:  ((struct.field_ref raft "uncommittedSize" (![ptrT] "r")) <-[entryPayloadSize] ((![entryPayloadSize] (struct.field_ref raft "uncommittedSize" (![ptrT] "r"))) + (![entryPayloadSize] "s")));;;
    return: (#true)).

(* returns: accepted

   go: raft.go:824:16 *)
Definition raft__appendEntry : val :=
  rec: "raft__appendEntry" "r" "es" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "es" := (ref_ty sliceT "es") in
    let: "li" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := ((raftLog__lastIndex (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()) in
    do:  ("li" <-[uint64T] "$r0");;;
    do:  (let: "$range" := (![sliceT] "es") in
    slice.for_range raftpb.Entry "$range" (λ: "i" <>,
      let: "i" := ref_ty uint64T "i" in
      let: "$r0" := (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r"))) in
      do:  ((struct.field_ref raftpb.Entry "Term" (slice.elem_ref raftpb.Entry (![sliceT] "es") (![intT] "i"))) <-[uint64T] "$r0");;;
      let: "$r0" := (((![uint64T] "li") + #(W64 1)) + (![intT] "i")) in
      do:  ((struct.field_ref raftpb.Entry "Index" (slice.elem_ref raftpb.Entry (![sliceT] "es") (![intT] "i"))) <-[uint64T] "$r0")));;;
    (if: (~ (let: "$a0" := (![sliceT] "es") in
    (raft__increaseUncommittedSize (![ptrT] "r")) "$a0"))
    then
      do:  (let: "$a0" := #"%x appending new entries to log would exceed uncommitted entry size limit; dropping proposal" in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
      slice.literal interfaceT ["$sl0"])) in
      (interface.get "Warningf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
      return: (#false)
    else do:  #());;;
    do:  (let: "$a0" := (![ptrT] "r") in
    let: "$a1" := (![sliceT] "es") in
    traceReplicate "$a0" "$a1");;;
    let: "$r0" := (let: "$a0" := (![sliceT] "es") in
    (raftLog__append (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) "$a0") in
    do:  ("li" <-[uint64T] "$r0");;;
    do:  (let: "$a0" := (struct.make raftpb.Message [{
      "To" ::= ![uint64T] (struct.field_ref raft "id" (![ptrT] "r"));
      "Type" ::= raftpb.MsgAppResp;
      "Index" ::= ![uint64T] "li"
    }]) in
    (raft__send (![ptrT] "r")) "$a0");;;
    return: (#true)).

(* sendHeartbeat sends a heartbeat RPC to the given peer.

   go: raft.go:700:16 *)
Definition raft__sendHeartbeat : val :=
  rec: "raft__sendHeartbeat" "r" "to" "ctx" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "ctx" := (ref_ty sliceT "ctx") in
    let: "to" := (ref_ty uint64T "to") in
    let: "pr" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (Fst (map.get (![tracker.ProgressMap] (struct.field_ref tracker.ProgressTracker "Progress" (struct.field_ref raft "trk" (![ptrT] "r")))) (![uint64T] "to"))) in
    do:  ("pr" <-[ptrT] "$r0");;;
    let: "commit" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (let: "$a0" := (![uint64T] (struct.field_ref tracker.Progress "Match" (![ptrT] "pr"))) in
    let: "$a1" := (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r"))))) in
    (minUint64 2) "$a0" "$a1") in
    do:  ("commit" <-[uint64T] "$r0");;;
    do:  (let: "$a0" := (struct.make raftpb.Message [{
      "To" ::= ![uint64T] "to";
      "Type" ::= raftpb.MsgHeartbeat;
      "Commit" ::= ![uint64T] "commit";
      "Context" ::= ![sliceT] "ctx"
    }]) in
    (raft__send (![ptrT] "r")) "$a0");;;
    do:  (let: "$a0" := (![uint64T] "commit") in
    (tracker.Progress__SentCommit (![ptrT] "pr")) "$a0")).

(* go: raft.go:739:16 *)
Definition raft__bcastHeartbeatWithCtx : val :=
  rec: "raft__bcastHeartbeatWithCtx" "r" "ctx" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "ctx" := (ref_ty sliceT "ctx") in
    do:  (let: "$a0" := (λ: "id" <>,
      exception_do (let: <> := (ref_ty ptrT "_") in
      let: "id" := (ref_ty uint64T "id") in
      (if: (![uint64T] "id") = (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))
      then return: (#())
      else do:  #());;;
      do:  (let: "$a0" := (![uint64T] "id") in
      let: "$a1" := (![sliceT] "ctx") in
      (raft__sendHeartbeat (![ptrT] "r")) "$a0" "$a1"))
      ) in
    (tracker.ProgressTracker__Visit (struct.field_ref raft "trk" (![ptrT] "r"))) "$a0")).

(* lastPendingRequestCtx returns the context of the last pending read only
   request in readonly struct.

   go: read_only.go:116:21 *)
Definition readOnly__lastPendingRequestCtx : val :=
  rec: "readOnly__lastPendingRequestCtx" "ro" <> :=
    exception_do (let: "ro" := (ref_ty ptrT "ro") in
    (if: (let: "$a0" := (![sliceT] (struct.field_ref readOnly "readIndexQueue" (![ptrT] "ro"))) in
    slice.len "$a0") = #(W64 0)
    then return: (#"")
    else do:  #());;;
    return: (![stringT] (slice.elem_ref stringT (![sliceT] (struct.field_ref readOnly "readIndexQueue" (![ptrT] "ro"))) ((let: "$a0" := (![sliceT] (struct.field_ref readOnly "readIndexQueue" (![ptrT] "ro"))) in
     slice.len "$a0") - #(W64 1))))).

(* bcastHeartbeat sends RPC, without entries to all the peers.

   go: raft.go:730:16 *)
Definition raft__bcastHeartbeat : val :=
  rec: "raft__bcastHeartbeat" "r" <> :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "lastCtx" := (ref_ty stringT (zero_val stringT)) in
    let: "$r0" := ((readOnly__lastPendingRequestCtx (![ptrT] (struct.field_ref raft "readOnly" (![ptrT] "r")))) #()) in
    do:  ("lastCtx" <-[stringT] "$r0");;;
    (if: (let: "$a0" := (![stringT] "lastCtx") in
    StringLength "$a0") = #(W64 0)
    then
      do:  (let: "$a0" := #slice.nil in
      (raft__bcastHeartbeatWithCtx (![ptrT] "r")) "$a0")
    else
      do:  (let: "$a0" := (string.to_bytes (![stringT] "lastCtx")) in
      (raft__bcastHeartbeatWithCtx (![ptrT] "r")) "$a0"))).

(* go: state_trace_nop.go:42:6 *)
Definition traceBecomeLeader : val :=
  rec: "traceBecomeLeader" "" :=
    exception_do (let: "" := (ref_ty ptrT "") in
    do:  #()).

(* go: raft.go:951:16 *)
Definition raft__becomeLeader : val :=
  rec: "raft__becomeLeader" "r" <> :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    (if: (![StateType] (struct.field_ref raft "state" (![ptrT] "r"))) = StateFollower
    then
      do:  (let: "$a0" := (interface.make string__mset #"invalid transition [follower -> leader]") in
      Panic "$a0")
    else do:  #());;;
    let: "$r0" := (![funcT] "stepLeaderGlobal") in
    do:  ((struct.field_ref raft "step" (![ptrT] "r")) <-[funcT] "$r0");;;
    do:  (let: "$a0" := (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r"))) in
    (raft__reset (![ptrT] "r")) "$a0");;;
    let: "$r0" := tickHeartbeatId in
    do:  ((struct.field_ref raft "tickId" (![ptrT] "r")) <-[intT] "$r0");;;
    let: "$r0" := (![uint64T] (struct.field_ref raft "id" (![ptrT] "r"))) in
    do:  ((struct.field_ref raft "lead" (![ptrT] "r")) <-[uint64T] "$r0");;;
    let: "$r0" := StateLeader in
    do:  ((struct.field_ref raft "state" (![ptrT] "r")) <-[StateType] "$r0");;;
    let: "pr" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (Fst (map.get (![tracker.ProgressMap] (struct.field_ref tracker.ProgressTracker "Progress" (struct.field_ref raft "trk" (![ptrT] "r")))) (![uint64T] (struct.field_ref raft "id" (![ptrT] "r"))))) in
    do:  ("pr" <-[ptrT] "$r0");;;
    do:  ((tracker.Progress__BecomeReplicate (![ptrT] "pr")) #());;;
    let: "$r0" := #true in
    do:  ((struct.field_ref tracker.Progress "RecentActive" (![ptrT] "pr")) <-[boolT] "$r0");;;
    let: "$r0" := ((raftLog__lastIndex (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()) in
    do:  ((struct.field_ref raft "pendingConfIndex" (![ptrT] "r")) <-[uint64T] "$r0");;;
    do:  (let: "$a0" := (![ptrT] "r") in
    traceBecomeLeader "$a0");;;
    let: "emptyEnt" := (ref_ty raftpb.Entry (zero_val raftpb.Entry)) in
    let: "$r0" := (struct.make raftpb.Entry [{
      "Data" ::= #slice.nil
    }]) in
    do:  ("emptyEnt" <-[raftpb.Entry] "$r0");;;
    (if: (~ (let: "$a0" := ((let: "$sl0" := (![raftpb.Entry] "emptyEnt") in
    slice.literal raftpb.Entry ["$sl0"])) in
    (raft__appendEntry (![ptrT] "r")) "$a0"))
    then
      do:  (let: "$a0" := ((let: "$sl0" := (interface.make string__mset #"empty entry was dropped") in
      slice.literal interfaceT ["$sl0"])) in
      (interface.get "Panic" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0")
    else do:  #());;;
    do:  (let: "$a0" := #"%x became leader at term %d" in
    let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
    let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
    slice.literal interfaceT ["$sl0"; "$sl1"])) in
    (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1")).

(* committedEntryInCurrentTerm return true if the peer has committed an entry in its term.

   go: raft.go:2087:16 *)
Definition raft__committedEntryInCurrentTerm : val :=
  rec: "raft__committedEntryInCurrentTerm" "r" <> :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    return: ((let: ("$ret0", "$ret1") := ((let: "$a0" := (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r"))))) in
     (raftLog__term (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) "$a0")) in
     let: "$a0" := "$ret0" in
     let: "$a1" := "$ret1" in
     (raftLog__zeroTermOnOutOfBounds (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) "$a0" "$a1") = (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r"))))).

(* logSliceFromMsgApp extracts the appended logSlice from a MsgApp message.

   go: raft.go:1802:6 *)
Definition logSliceFromMsgApp : val :=
  rec: "logSliceFromMsgApp" "m" :=
    exception_do (let: "m" := (ref_ty ptrT "m") in
    return: (struct.make logSlice [{
       "term" ::= ![uint64T] (struct.field_ref raftpb.Message "Term" (![ptrT] "m"));
       "prev" ::= struct.make entryID [{
         "term" ::= ![uint64T] (struct.field_ref raftpb.Message "LogTerm" (![ptrT] "m"));
         "index" ::= ![uint64T] (struct.field_ref raftpb.Message "Index" (![ptrT] "m"))
       }];
       "entries" ::= ![sliceT] (struct.field_ref raftpb.Message "Entries" (![ptrT] "m"))
     }])).

(* go: raft.go:1811:16 *)
Definition raft__handleAppendEntries : val :=
  rec: "raft__handleAppendEntries" "r" "m" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "m" := (ref_ty raftpb.Message "m") in
    let: "a" := (ref_ty logSlice (zero_val logSlice)) in
    let: "$r0" := (let: "$a0" := "m" in
    logSliceFromMsgApp "$a0") in
    do:  ("a" <-[logSlice] "$r0");;;
    (if: (![uint64T] (struct.field_ref entryID "index" (struct.field_ref logSlice "prev" "a"))) < (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))))
    then
      do:  (let: "$a0" := (struct.make raftpb.Message [{
        "To" ::= ![uint64T] (struct.field_ref raftpb.Message "From" "m");
        "Type" ::= raftpb.MsgAppResp;
        "Index" ::= ![uint64T] (struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r"))))
      }]) in
      (raft__send (![ptrT] "r")) "$a0");;;
      return: (#())
    else do:  #());;;
    (let: "ok" := (ref_ty boolT (zero_val boolT)) in
    let: "mlastIndex" := (ref_ty uint64T (zero_val uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![logSlice] "a") in
    let: "$a1" := (![uint64T] (struct.field_ref raftpb.Message "Commit" "m")) in
    (raftLog__maybeAppend (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("mlastIndex" <-[uint64T] "$r0");;;
    do:  ("ok" <-[boolT] "$r1");;;
    (if: ![boolT] "ok"
    then
      do:  (let: "$a0" := (struct.make raftpb.Message [{
        "To" ::= ![uint64T] (struct.field_ref raftpb.Message "From" "m");
        "Type" ::= raftpb.MsgAppResp;
        "Index" ::= ![uint64T] "mlastIndex"
      }]) in
      (raft__send (![ptrT] "r")) "$a0");;;
      return: (#())
    else do:  #()));;;
    do:  (let: "$a0" := #"%x [logterm: %d, index: %d] rejected MsgApp [logterm: %d, index: %d] from %x" in
    let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
    let: "$sl1" := (interface.make uint64__mset (let: ("$ret0", "$ret1") := ((let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "Index" "m")) in
    (raftLog__term (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) "$a0")) in
    let: "$a0" := "$ret0" in
    let: "$a1" := "$ret1" in
    (raftLog__zeroTermOnOutOfBounds (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) "$a0" "$a1")) in
    let: "$sl2" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "Index" "m"))) in
    let: "$sl3" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "LogTerm" "m"))) in
    let: "$sl4" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "Index" "m"))) in
    let: "$sl5" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "From" "m"))) in
    slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"; "$sl4"; "$sl5"])) in
    (interface.get "Debugf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
    let: "hintIndex" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "Index" "m")) in
    let: "$a1" := ((raftLog__lastIndex (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()) in
    (minUint64 2) "$a0" "$a1") in
    do:  ("hintIndex" <-[uint64T] "$r0");;;
    let: "hintTerm" := (ref_ty uint64T (zero_val uint64T)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![uint64T] "hintIndex") in
    let: "$a1" := (![uint64T] (struct.field_ref raftpb.Message "LogTerm" "m")) in
    (raftLog__findConflictByTerm (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("hintIndex" <-[uint64T] "$r0");;;
    do:  ("hintTerm" <-[uint64T] "$r1");;;
    do:  (let: "$a0" := (struct.make raftpb.Message [{
      "To" ::= ![uint64T] (struct.field_ref raftpb.Message "From" "m");
      "Type" ::= raftpb.MsgAppResp;
      "Index" ::= ![uint64T] (struct.field_ref raftpb.Message "Index" "m");
      "Reject" ::= #true;
      "RejectHint" ::= ![uint64T] "hintIndex";
      "LogTerm" ::= ![uint64T] "hintTerm"
    }]) in
    (raft__send (![ptrT] "r")) "$a0")).

(* go: raft.go:1855:16 *)
Definition raft__handleHeartbeat : val :=
  rec: "raft__handleHeartbeat" "r" "m" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "m" := (ref_ty raftpb.Message "m") in
    do:  (let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "Commit" "m")) in
    (raftLog__commitTo (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) "$a0");;;
    do:  (let: "$a0" := (struct.make raftpb.Message [{
      "To" ::= ![uint64T] (struct.field_ref raftpb.Message "From" "m");
      "Type" ::= raftpb.MsgHeartbeatResp;
      "Context" ::= ![sliceT] (struct.field_ref raftpb.Message "Context" "m")
    }]) in
    (raft__send (![ptrT] "r")) "$a0")).

(* restore recovers the state machine from a snapshot. It restores the log and the
   configuration of state machine. If this method returns false, the snapshot was
   ignored, either because it was obsolete or because of an error.

   go: raft.go:1882:16 *)
Definition raft__restore : val :=
  rec: "raft__restore" "r" "s" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "s" := (ref_ty raftpb.Snapshot "s") in
    (if: (![uint64T] (struct.field_ref raftpb.SnapshotMetadata "Index" (struct.field_ref raftpb.Snapshot "Metadata" "s"))) ≤ (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))))
    then return: (#false)
    else do:  #());;;
    (if: (![StateType] (struct.field_ref raft "state" (![ptrT] "r"))) ≠ StateFollower
    then
      do:  (let: "$a0" := #"%x attempted to restore snapshot as leader; should never happen" in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
      slice.literal interfaceT ["$sl0"])) in
      (interface.get "Warningf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
      do:  (let: "$a0" := ((![uint64T] (struct.field_ref raft "Term" (![ptrT] "r"))) + #(W64 1)) in
      let: "$a1" := None in
      (raft__becomeFollower (![ptrT] "r")) "$a0" "$a1");;;
      return: (#false)
    else do:  #());;;
    let: "found" := (ref_ty boolT (zero_val boolT)) in
    let: "$r0" := #false in
    do:  ("found" <-[boolT] "$r0");;;
    let: "cs" := (ref_ty raftpb.ConfState (zero_val raftpb.ConfState)) in
    let: "$r0" := (![raftpb.ConfState] (struct.field_ref raftpb.SnapshotMetadata "ConfState" (struct.field_ref raftpb.Snapshot "Metadata" "s"))) in
    do:  ("cs" <-[raftpb.ConfState] "$r0");;;
    do:  (let: "$range" := ((let: "$sl0" := (![sliceT] (struct.field_ref raftpb.ConfState "Voters" "cs")) in
    let: "$sl1" := (![sliceT] (struct.field_ref raftpb.ConfState "Learners" "cs")) in
    let: "$sl2" := (![sliceT] (struct.field_ref raftpb.ConfState "VotersOutgoing" "cs")) in
    slice.literal sliceT ["$sl0"; "$sl1"; "$sl2"])) in
    slice.for_range sliceT "$range" (λ: <> "set",
      let: "set" := ref_ty sliceT "set" in
      do:  (let: "$range" := (![sliceT] "set") in
      slice.for_range uint64T "$range" (λ: <> "id",
        let: "id" := ref_ty uint64T "id" in
        (if: (![uint64T] "id") = (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))
        then
          let: "$r0" := #true in
          do:  ("found" <-[boolT] "$r0");;;
          break: #()
        else do:  #())));;;
      (if: ![boolT] "found"
      then break: #()
      else do:  #())));;;
    (if: (~ (![boolT] "found"))
    then
      do:  (let: "$a0" := #"%x attempted to restore snapshot but it is not in the ConfState %v; should never happen" in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
      let: "$sl1" := (interface.make raftpb.ConfState__mset (![raftpb.ConfState] "cs")) in
      slice.literal interfaceT ["$sl0"; "$sl1"])) in
      (interface.get "Warningf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
      return: (#false)
    else do:  #());;;
    let: "id" := (ref_ty entryID (zero_val entryID)) in
    let: "$r0" := (struct.make entryID [{
      "term" ::= ![uint64T] (struct.field_ref raftpb.SnapshotMetadata "Term" (struct.field_ref raftpb.Snapshot "Metadata" "s"));
      "index" ::= ![uint64T] (struct.field_ref raftpb.SnapshotMetadata "Index" (struct.field_ref raftpb.Snapshot "Metadata" "s"))
    }]) in
    do:  ("id" <-[entryID] "$r0");;;
    (if: let: "$a0" := (![entryID] "id") in
    (raftLog__matchTerm (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) "$a0"
    then
      let: "last" := (ref_ty entryID (zero_val entryID)) in
      let: "$r0" := ((raftLog__lastEntryID (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()) in
      do:  ("last" <-[entryID] "$r0");;;
      do:  (let: "$a0" := #"%x [commit: %d, lastindex: %d, lastterm: %d] fast-forwarded commit to snapshot [index: %d, term: %d]" in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
      let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))))) in
      let: "$sl2" := (interface.make uint64__mset (![uint64T] (struct.field_ref entryID "index" "last"))) in
      let: "$sl3" := (interface.make uint64__mset (![uint64T] (struct.field_ref entryID "term" "last"))) in
      let: "$sl4" := (interface.make uint64__mset (![uint64T] (struct.field_ref entryID "index" "id"))) in
      let: "$sl5" := (interface.make uint64__mset (![uint64T] (struct.field_ref entryID "term" "id"))) in
      slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"; "$sl4"; "$sl5"])) in
      (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
      do:  (let: "$a0" := (![uint64T] (struct.field_ref raftpb.SnapshotMetadata "Index" (struct.field_ref raftpb.Snapshot "Metadata" "s"))) in
      (raftLog__commitTo (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) "$a0");;;
      return: (#false)
    else do:  #());;;
    do:  (let: "$a0" := (![raftpb.Snapshot] "s") in
    (raftLog__restore (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) "$a0");;;
    let: "$r0" := (let: "$a0" := (![intT] (struct.field_ref tracker.ProgressTracker "MaxInflight" (struct.field_ref raft "trk" (![ptrT] "r")))) in
    let: "$a1" := (![uint64T] (struct.field_ref tracker.ProgressTracker "MaxInflightBytes" (struct.field_ref raft "trk" (![ptrT] "r")))) in
    tracker.MakeProgressTracker "$a0" "$a1") in
    do:  ((struct.field_ref raft "trk" (![ptrT] "r")) <-[tracker.ProgressTracker] "$r0");;;
    let: "err" := (ref_ty error (zero_val error)) in
    let: "trk" := (ref_ty tracker.ProgressMap (zero_val tracker.ProgressMap)) in
    let: "cfg" := (ref_ty tracker.Config (zero_val tracker.Config)) in
    let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (struct.make confchange.Changer [{
      "Tracker" ::= ![tracker.ProgressTracker] (struct.field_ref raft "trk" (![ptrT] "r"));
      "LastIndex" ::= (raftLog__lastIndex (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()
    }]) in
    let: "$a1" := (![raftpb.ConfState] "cs") in
    confchange.Restore "$a0" "$a1") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    let: "$r2" := "$ret2" in
    do:  ("cfg" <-[tracker.Config] "$r0");;;
    do:  ("trk" <-[tracker.ProgressMap] "$r1");;;
    do:  ("err" <-[error] "$r2");;;
    (if: (![error] "err") ≠ #interface.nil
    then
      do:  (let: "$a0" := (interface.make string__mset (let: "$a0" := #"unable to restore config %+v: %s" in
      let: "$a1" := ((let: "$sl0" := (interface.make raftpb.ConfState__mset (![raftpb.ConfState] "cs")) in
      let: "$sl1" := (![error] "err") in
      slice.literal interfaceT ["$sl0"; "$sl1"])) in
      fmt.Sprintf "$a0" "$a1")) in
      Panic "$a0")
    else do:  #());;;
    do:  (let: "$a0" := (![Logger] (struct.field_ref raft "logger" (![ptrT] "r"))) in
    let: "$a1" := (![raftpb.ConfState] "cs") in
    let: "$a2" := (let: "$a0" := (![tracker.Config] "cfg") in
    let: "$a1" := (![tracker.ProgressMap] "trk") in
    (raft__switchToConfig (![ptrT] "r")) "$a0" "$a1") in
    assertConfStatesEquivalent "$a0" "$a1" "$a2");;;
    let: "last" := (ref_ty entryID (zero_val entryID)) in
    let: "$r0" := ((raftLog__lastEntryID (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()) in
    do:  ("last" <-[entryID] "$r0");;;
    do:  (let: "$a0" := #"%x [commit: %d, lastindex: %d, lastterm: %d] restored snapshot [index: %d, term: %d]" in
    let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
    let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))))) in
    let: "$sl2" := (interface.make uint64__mset (![uint64T] (struct.field_ref entryID "index" "last"))) in
    let: "$sl3" := (interface.make uint64__mset (![uint64T] (struct.field_ref entryID "term" "last"))) in
    let: "$sl4" := (interface.make uint64__mset (![uint64T] (struct.field_ref entryID "index" "id"))) in
    let: "$sl5" := (interface.make uint64__mset (![uint64T] (struct.field_ref entryID "term" "id"))) in
    slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"; "$sl4"; "$sl5"])) in
    (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
    return: (#true)).

(* go: raft.go:1860:16 *)
Definition raft__handleSnapshot : val :=
  rec: "raft__handleSnapshot" "r" "m" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "m" := (ref_ty raftpb.Message "m") in
    let: "s" := (ref_ty raftpb.Snapshot (zero_val raftpb.Snapshot)) in
    (if: (![ptrT] (struct.field_ref raftpb.Message "Snapshot" "m")) ≠ #null
    then
      let: "$r0" := (![raftpb.Snapshot] (![ptrT] (struct.field_ref raftpb.Message "Snapshot" "m"))) in
      do:  ("s" <-[raftpb.Snapshot] "$r0")
    else do:  #());;;
    let: "sterm" := (ref_ty uint64T (zero_val uint64T)) in
    let: "sindex" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (![uint64T] (struct.field_ref raftpb.SnapshotMetadata "Index" (struct.field_ref raftpb.Snapshot "Metadata" "s"))) in
    let: "$r1" := (![uint64T] (struct.field_ref raftpb.SnapshotMetadata "Term" (struct.field_ref raftpb.Snapshot "Metadata" "s"))) in
    do:  ("sindex" <-[uint64T] "$r0");;;
    do:  ("sterm" <-[uint64T] "$r1");;;
    (if: let: "$a0" := (![raftpb.Snapshot] "s") in
    (raft__restore (![ptrT] "r")) "$a0"
    then
      do:  (let: "$a0" := #"%x [commit: %d] restored snapshot [index: %d, term: %d]" in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
      let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))))) in
      let: "$sl2" := (interface.make uint64__mset (![uint64T] "sindex")) in
      let: "$sl3" := (interface.make uint64__mset (![uint64T] "sterm")) in
      slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"])) in
      (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
      do:  (let: "$a0" := (struct.make raftpb.Message [{
        "To" ::= ![uint64T] (struct.field_ref raftpb.Message "From" "m");
        "Type" ::= raftpb.MsgAppResp;
        "Index" ::= (raftLog__lastIndex (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()
      }]) in
      (raft__send (![ptrT] "r")) "$a0")
    else
      do:  (let: "$a0" := #"%x [commit: %d] ignored snapshot [index: %d, term: %d]" in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
      let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))))) in
      let: "$sl2" := (interface.make uint64__mset (![uint64T] "sindex")) in
      let: "$sl3" := (interface.make uint64__mset (![uint64T] "sterm")) in
      slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"])) in
      (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
      do:  (let: "$a0" := (struct.make raftpb.Message [{
        "To" ::= ![uint64T] (struct.field_ref raftpb.Message "From" "m");
        "Type" ::= raftpb.MsgAppResp;
        "Index" ::= ![uint64T] (struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r"))))
      }]) in
      (raft__send (![ptrT] "r")) "$a0"))).

(* returns (granted, rejected, result)

   go: raft.go:1094:16 *)
Definition raft__poll : val :=
  rec: "raft__poll" "r" "id" "t" "v" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "v" := (ref_ty boolT "v") in
    let: "t" := (ref_ty raftpb.MessageType "t") in
    let: "id" := (ref_ty uint64T "id") in
    (if: ![boolT] "v"
    then
      do:  (let: "$a0" := #"%x received %s from %x at term %d" in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
      let: "$sl1" := (interface.make raftpb.MessageType__mset (![raftpb.MessageType] "t")) in
      let: "$sl2" := (interface.make uint64__mset (![uint64T] "id")) in
      let: "$sl3" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
      slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"])) in
      (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1")
    else
      do:  (let: "$a0" := #"%x received %s rejection from %x at term %d" in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
      let: "$sl1" := (interface.make raftpb.MessageType__mset (![raftpb.MessageType] "t")) in
      let: "$sl2" := (interface.make uint64__mset (![uint64T] "id")) in
      let: "$sl3" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
      slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"])) in
      (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1"));;;
    do:  (let: "$a0" := (![uint64T] "id") in
    let: "$a1" := (![boolT] "v") in
    (tracker.ProgressTracker__RecordVote (struct.field_ref raft "trk" (![ptrT] "r"))) "$a0" "$a1");;;
    let: (("$ret0", "$ret1"), "$ret2") := (((tracker.ProgressTracker__TallyVotes (struct.field_ref raft "trk" (![ptrT] "r"))) #())) in
    return: ("$ret0", "$ret1", "$ret2")).

(* go: raft2.go:94:16 *)
Definition raft__readMessages : val :=
  rec: "raft__readMessages" "r" <> :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    do:  ((raft__advanceMessagesAfterAppend (![ptrT] "r")) #());;;
    let: "msgs" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (![sliceT] (struct.field_ref raft "msgs" (![ptrT] "r"))) in
    do:  ("msgs" <-[sliceT] "$r0");;;
    let: "$r0" := #slice.nil in
    do:  ((struct.field_ref raft "msgs" (![ptrT] "r")) <-[sliceT] "$r0");;;
    return: (![sliceT] "msgs")).

(* responseToReadIndexReq constructs a response for `req`. If `req` comes from the peer
   itself, a blank value will be returned.

   go: raft.go:2095:16 *)
Definition raft__responseToReadIndexReq : val :=
  rec: "raft__responseToReadIndexReq" "r" "req" "readIndex" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "readIndex" := (ref_ty uint64T "readIndex") in
    let: "req" := (ref_ty raftpb.Message "req") in
    (if: ((![uint64T] (struct.field_ref raftpb.Message "From" "req")) = None) || ((![uint64T] (struct.field_ref raftpb.Message "From" "req")) = (![uint64T] (struct.field_ref raft "id" (![ptrT] "r"))))
    then
      let: "$r0" := (let: "$a0" := (![sliceT] (struct.field_ref raft "readStates" (![ptrT] "r"))) in
      let: "$a1" := ((let: "$sl0" := (struct.make ReadState [{
        "Index" ::= ![uint64T] "readIndex";
        "RequestCtx" ::= ![sliceT] (struct.field_ref raftpb.Entry "Data" (slice.elem_ref raftpb.Entry (![sliceT] (struct.field_ref raftpb.Message "Entries" "req")) #(W64 0)))
      }]) in
      slice.literal ReadState ["$sl0"])) in
      (slice.append sliceT) "$a0" "$a1") in
      do:  ((struct.field_ref raft "readStates" (![ptrT] "r")) <-[sliceT] "$r0");;;
      return: (struct.make raftpb.Message [{
       }])
    else do:  #());;;
    return: (struct.make raftpb.Message [{
       "Type" ::= raftpb.MsgReadIndexResp;
       "To" ::= ![uint64T] (struct.field_ref raftpb.Message "From" "req");
       "Index" ::= ![uint64T] "readIndex";
       "Entries" ::= ![sliceT] (struct.field_ref raftpb.Message "Entries" "req")
     }])).

(* go: raft.go:2078:16 *)
Definition raft__sendTimeoutNow : val :=
  rec: "raft__sendTimeoutNow" "r" "to" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    let: "to" := (ref_ty uint64T "to") in
    do:  (let: "$a0" := (struct.make raftpb.Message [{
      "To" ::= ![uint64T] "to";
      "Type" ::= raftpb.MsgTimeoutNow
    }]) in
    (raft__send (![ptrT] "r")) "$a0")).

Definition raft__mset_ptr : list (string * val) := [
  ("Step", raft__Step%V);
  ("abortLeaderTransfer", raft__abortLeaderTransfer%V);
  ("advanceMessagesAfterAppend", raft__advanceMessagesAfterAppend%V);
  ("appendEntry", raft__appendEntry%V);
  ("appliedSnap", raft__appliedSnap%V);
  ("appliedTo", raft__appliedTo%V);
  ("applyConfChange", raft__applyConfChange%V);
  ("bcastAppend", raft__bcastAppend%V);
  ("bcastHeartbeat", raft__bcastHeartbeat%V);
  ("bcastHeartbeatWithCtx", raft__bcastHeartbeatWithCtx%V);
  ("becomeCandidate", raft__becomeCandidate%V);
  ("becomeFollower", raft__becomeFollower%V);
  ("becomeLeader", raft__becomeLeader%V);
  ("becomePreCandidate", raft__becomePreCandidate%V);
  ("campaign", raft__campaign%V);
  ("committedEntryInCurrentTerm", raft__committedEntryInCurrentTerm%V);
  ("handleAppendEntries", raft__handleAppendEntries%V);
  ("handleHeartbeat", raft__handleHeartbeat%V);
  ("handleSnapshot", raft__handleSnapshot%V);
  ("hardState", raft__hardState%V);
  ("hasLeader", raft__hasLeader%V);
  ("hasUnappliedConfChanges", raft__hasUnappliedConfChanges%V);
  ("hup", raft__hup%V);
  ("increaseUncommittedSize", raft__increaseUncommittedSize%V);
  ("loadState", raft__loadState%V);
  ("maybeCommit", raft__maybeCommit%V);
  ("maybeSendAppend", raft__maybeSendAppend%V);
  ("maybeSendSnapshot", raft__maybeSendSnapshot%V);
  ("pastElectionTimeout", raft__pastElectionTimeout%V);
  ("poll", raft__poll%V);
  ("promotable", raft__promotable%V);
  ("readMessages", raft__readMessages%V);
  ("reduceUncommittedSize", raft__reduceUncommittedSize%V);
  ("reset", raft__reset%V);
  ("resetRandomizedElectionTimeout", raft__resetRandomizedElectionTimeout%V);
  ("responseToReadIndexReq", raft__responseToReadIndexReq%V);
  ("restore", raft__restore%V);
  ("send", raft__send%V);
  ("sendAppend", raft__sendAppend%V);
  ("sendHeartbeat", raft__sendHeartbeat%V);
  ("sendTimeoutNow", raft__sendTimeoutNow%V);
  ("softState", raft__softState%V);
  ("stepOrSend", raft__stepOrSend%V);
  ("switchToConfig", raft__switchToConfig%V);
  ("takeMessagesAfterAppend", raft__takeMessagesAfterAppend%V);
  ("tick", raft__tick%V);
  ("tickElection", raft__tickElection%V);
  ("tickHeartbeat", raft__tickHeartbeat%V)
].

Definition stepFunc : go_type := funcT.

Definition stepFunc__mset : list (string * val) := [
].

Definition stepFunc__mset_ptr : list (string * val) := [
].

Definition readIndexStatus : go_type := structT [
  "req" :: raftpb.Message;
  "index" :: uint64T;
  "acks" :: mapT uint64T boolT
].

(* advance advances the read only request queue kept by the readonly struct.
   It dequeues the requests until it finds the read only request that has
   the same context as the given `m`.

   go: read_only.go:81:21 *)
Definition readOnly__advance : val :=
  rec: "readOnly__advance" "ro" "m" :=
    exception_do (let: "ro" := (ref_ty ptrT "ro") in
    let: "m" := (ref_ty raftpb.Message "m") in
    let: "found" := (ref_ty boolT (zero_val boolT)) in
    let: "i" := (ref_ty intT (zero_val intT)) in
    let: "ctx" := (ref_ty stringT (zero_val stringT)) in
    let: "$r0" := (string.from_bytes (![sliceT] (struct.field_ref raftpb.Message "Context" "m"))) in
    do:  ("ctx" <-[stringT] "$r0");;;
    let: "rss" := (ref_ty sliceT (zero_val sliceT)) in
    do:  (let: "$range" := (![sliceT] (struct.field_ref readOnly "readIndexQueue" (![ptrT] "ro"))) in
    slice.for_range stringT "$range" (λ: <> "okctx",
      let: "okctx" := ref_ty stringT "okctx" in
      do:  ("i" <-[intT] ((![intT] "i") + #(W64 1)));;;
      let: "ok" := (ref_ty boolT (zero_val boolT)) in
      let: "rs" := (ref_ty ptrT (zero_val ptrT)) in
      let: ("$ret0", "$ret1") := (map.get (![mapT stringT ptrT] (struct.field_ref readOnly "pendingReadIndex" (![ptrT] "ro"))) (![stringT] "okctx")) in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("rs" <-[ptrT] "$r0");;;
      do:  ("ok" <-[boolT] "$r1");;;
      (if: (~ (![boolT] "ok"))
      then
        do:  (let: "$a0" := (interface.make string__mset #"cannot find corresponding read state from pending map") in
        Panic "$a0")
      else do:  #());;;
      let: "$r0" := (let: "$a0" := (![sliceT] "rss") in
      let: "$a1" := ((let: "$sl0" := (![ptrT] "rs") in
      slice.literal ptrT ["$sl0"])) in
      (slice.append sliceT) "$a0" "$a1") in
      do:  ("rss" <-[sliceT] "$r0");;;
      (if: (![stringT] "okctx") = (![stringT] "ctx")
      then
        let: "$r0" := #true in
        do:  ("found" <-[boolT] "$r0");;;
        break: #()
      else do:  #())));;;
    (if: ![boolT] "found"
    then
      let: "$r0" := (let: "$s" := (![sliceT] (struct.field_ref readOnly "readIndexQueue" (![ptrT] "ro"))) in
      slice.slice stringT "$s" (![intT] "i") (slice.len "$s")) in
      do:  ((struct.field_ref readOnly "readIndexQueue" (![ptrT] "ro")) <-[sliceT] "$r0");;;
      do:  (let: "$range" := (![sliceT] "rss") in
      slice.for_range ptrT "$range" (λ: <> "rs",
        let: "rs" := ref_ty ptrT "rs" in
        do:  (let: "$a0" := (![mapT stringT ptrT] (struct.field_ref readOnly "pendingReadIndex" (![ptrT] "ro"))) in
        let: "$a1" := (string.from_bytes (![sliceT] (struct.field_ref raftpb.Entry "Data" (slice.elem_ref raftpb.Entry (![sliceT] (struct.field_ref raftpb.Message "Entries" (struct.field_ref readIndexStatus "req" (![ptrT] "rs")))) #(W64 0))))) in
        map.delete "$a0" "$a1")));;;
      return: (![sliceT] "rss")
    else do:  #());;;
    return: (#slice.nil)).

(* recvAck notifies the readonly struct that the raft state machine received
   an acknowledgment of the heartbeat that attached with the read only request
   context.

   go: read_only.go:68:21 *)
Definition readOnly__recvAck : val :=
  rec: "readOnly__recvAck" "ro" "id" "context" :=
    exception_do (let: "ro" := (ref_ty ptrT "ro") in
    let: "context" := (ref_ty sliceT "context") in
    let: "id" := (ref_ty uint64T "id") in
    let: "ok" := (ref_ty boolT (zero_val boolT)) in
    let: "rs" := (ref_ty ptrT (zero_val ptrT)) in
    let: ("$ret0", "$ret1") := (map.get (![mapT stringT ptrT] (struct.field_ref readOnly "pendingReadIndex" (![ptrT] "ro"))) (string.from_bytes (![sliceT] "context"))) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("rs" <-[ptrT] "$r0");;;
    do:  ("ok" <-[boolT] "$r1");;;
    (if: (~ (![boolT] "ok"))
    then return: (#null)
    else do:  #());;;
    let: "$r0" := #true in
    do:  (map.insert (![mapT uint64T boolT] (struct.field_ref readIndexStatus "acks" (![ptrT] "rs"))) (![uint64T] "id") "$r0");;;
    return: (![mapT uint64T boolT] (struct.field_ref readIndexStatus "acks" (![ptrT] "rs")))).

(* addRequest adds a read only request into readonly struct.
   `index` is the commit index of the raft state machine when it received
   the read only request.
   `m` is the original read only request message from the local or remote node.

   go: read_only.go:56:21 *)
Definition readOnly__addRequest : val :=
  rec: "readOnly__addRequest" "ro" "index" "m" :=
    exception_do (let: "ro" := (ref_ty ptrT "ro") in
    let: "m" := (ref_ty raftpb.Message "m") in
    let: "index" := (ref_ty uint64T "index") in
    let: "s" := (ref_ty stringT (zero_val stringT)) in
    let: "$r0" := (string.from_bytes (![sliceT] (struct.field_ref raftpb.Entry "Data" (slice.elem_ref raftpb.Entry (![sliceT] (struct.field_ref raftpb.Message "Entries" "m")) #(W64 0))))) in
    do:  ("s" <-[stringT] "$r0");;;
    (let: "ok" := (ref_ty boolT (zero_val boolT)) in
    let: ("$ret0", "$ret1") := (map.get (![mapT stringT ptrT] (struct.field_ref readOnly "pendingReadIndex" (![ptrT] "ro"))) (![stringT] "s")) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  "$r0";;;
    do:  ("ok" <-[boolT] "$r1");;;
    (if: ![boolT] "ok"
    then return: (#())
    else do:  #()));;;
    let: "$r0" := (ref_ty readIndexStatus (struct.make readIndexStatus [{
      "index" ::= ![uint64T] "index";
      "req" ::= ![raftpb.Message] "m";
      "acks" ::= map.make uint64T boolT #()
    }])) in
    do:  (map.insert (![mapT stringT ptrT] (struct.field_ref readOnly "pendingReadIndex" (![ptrT] "ro"))) (![stringT] "s") "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT] (struct.field_ref readOnly "readIndexQueue" (![ptrT] "ro"))) in
    let: "$a1" := ((let: "$sl0" := (![stringT] "s") in
    slice.literal stringT ["$sl0"])) in
    (slice.append sliceT) "$a0" "$a1") in
    do:  ((struct.field_ref readOnly "readIndexQueue" (![ptrT] "ro")) <-[sliceT] "$r0")).

(* go: raft.go:2167:6 *)
Definition sendMsgReadIndexResponse : val :=
  rec: "sendMsgReadIndexResponse" "r" "m" :=
    exception_do (let: "m" := (ref_ty raftpb.Message "m") in
    let: "r" := (ref_ty ptrT "r") in
    let: "$sw" := (![ReadOnlyOption] (struct.field_ref readOnly "option" (![ptrT] (struct.field_ref raft "readOnly" (![ptrT] "r"))))) in
    (if: "$sw" = ReadOnlySafe
    then
      do:  (let: "$a0" := (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r"))))) in
      let: "$a1" := (![raftpb.Message] "m") in
      (readOnly__addRequest (![ptrT] (struct.field_ref raft "readOnly" (![ptrT] "r")))) "$a0" "$a1");;;
      do:  (let: "$a0" := (![uint64T] (struct.field_ref raft "id" (![ptrT] "r"))) in
      let: "$a1" := (![sliceT] (struct.field_ref raftpb.Entry "Data" (slice.elem_ref raftpb.Entry (![sliceT] (struct.field_ref raftpb.Message "Entries" "m")) #(W64 0)))) in
      (readOnly__recvAck (![ptrT] (struct.field_ref raft "readOnly" (![ptrT] "r")))) "$a0" "$a1");;;
      do:  (let: "$a0" := (![sliceT] (struct.field_ref raftpb.Entry "Data" (slice.elem_ref raftpb.Entry (![sliceT] (struct.field_ref raftpb.Message "Entries" "m")) #(W64 0)))) in
      (raft__bcastHeartbeatWithCtx (![ptrT] "r")) "$a0")
    else
      (if: "$sw" = ReadOnlyLeaseBased
      then
        (let: "resp" := (ref_ty raftpb.Message (zero_val raftpb.Message)) in
        let: "$r0" := (let: "$a0" := (![raftpb.Message] "m") in
        let: "$a1" := (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r"))))) in
        (raft__responseToReadIndexReq (![ptrT] "r")) "$a0" "$a1") in
        do:  ("resp" <-[raftpb.Message] "$r0");;;
        (if: (![uint64T] (struct.field_ref raftpb.Message "To" "resp")) ≠ None
        then
          do:  (let: "$a0" := (![raftpb.Message] "resp") in
          (raft__send (![ptrT] "r")) "$a0")
        else do:  #()))
      else #()))).

(* go: raft.go:2148:6 *)
Definition releasePendingReadIndexMessages : val :=
  rec: "releasePendingReadIndexMessages" "r" :=
    exception_do (let: "r" := (ref_ty ptrT "r") in
    (if: (let: "$a0" := (![sliceT] (struct.field_ref raft "pendingReadIndexMessages" (![ptrT] "r"))) in
    slice.len "$a0") = #(W64 0)
    then return: (#())
    else do:  #());;;
    (if: (~ ((raft__committedEntryInCurrentTerm (![ptrT] "r")) #()))
    then
      do:  (let: "$a0" := ((let: "$sl0" := (interface.make string__mset #"pending MsgReadIndex should be released only after first commit in current term") in
      slice.literal interfaceT ["$sl0"])) in
      (interface.get "Error" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0");;;
      return: (#())
    else do:  #());;;
    let: "msgs" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (![sliceT] (struct.field_ref raft "pendingReadIndexMessages" (![ptrT] "r"))) in
    do:  ("msgs" <-[sliceT] "$r0");;;
    let: "$r0" := #slice.nil in
    do:  ((struct.field_ref raft "pendingReadIndexMessages" (![ptrT] "r")) <-[sliceT] "$r0");;;
    do:  (let: "$range" := (![sliceT] "msgs") in
    slice.for_range raftpb.Message "$range" (λ: <> "m",
      let: "m" := ref_ty raftpb.Message "m" in
      do:  (let: "$a0" := (![ptrT] "r") in
      let: "$a1" := (![raftpb.Message] "m") in
      sendMsgReadIndexResponse "$a0" "$a1")))).

(* go: state_trace_nop.go:44:6 *)
Definition traceChangeConfEvent : val :=
  rec: "traceChangeConfEvent" "" "" :=
    exception_do (let: "" := (ref_ty ptrT "") in
    let: "" := (ref_ty raftpb.ConfChangeI "") in
    do:  #()).

(* go: raft.go:1288:6 *)
Definition stepLeader : val :=
  rec: "stepLeader" "r" "m" :=
    exception_do (let: "m" := (ref_ty raftpb.Message "m") in
    let: "r" := (ref_ty ptrT "r") in
    let: "$sw" := (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) in
    (if: "$sw" = raftpb.MsgBeat
    then
      do:  ((raft__bcastHeartbeat (![ptrT] "r")) #());;;
      return: (#interface.nil)
    else
      (if: "$sw" = raftpb.MsgCheckQuorum
      then
        (if: (~ ((tracker.ProgressTracker__QuorumActive (struct.field_ref raft "trk" (![ptrT] "r"))) #()))
        then
          do:  (let: "$a0" := #"%x stepped down to follower since quorum is not active" in
          let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
          slice.literal interfaceT ["$sl0"])) in
          (interface.get "Warningf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
          do:  (let: "$a0" := (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r"))) in
          let: "$a1" := None in
          (raft__becomeFollower (![ptrT] "r")) "$a0" "$a1")
        else do:  #());;;
        do:  (let: "$a0" := (λ: "id" "pr",
          exception_do (let: "pr" := (ref_ty ptrT "pr") in
          let: "id" := (ref_ty uint64T "id") in
          (if: (![uint64T] "id") ≠ (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))
          then
            let: "$r0" := #false in
            do:  ((struct.field_ref tracker.Progress "RecentActive" (![ptrT] "pr")) <-[boolT] "$r0")
          else do:  #()))
          ) in
        (tracker.ProgressTracker__Visit (struct.field_ref raft "trk" (![ptrT] "r"))) "$a0");;;
        return: (#interface.nil)
      else
        (if: "$sw" = raftpb.MsgProp
        then
          (if: (let: "$a0" := (![sliceT] (struct.field_ref raftpb.Message "Entries" "m")) in
          slice.len "$a0") = #(W64 0)
          then
            do:  (let: "$a0" := #"%x stepped empty MsgProp" in
            let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
            slice.literal interfaceT ["$sl0"])) in
            (interface.get "Panicf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1")
          else do:  #());;;
          (if: (Fst (map.get (![tracker.ProgressMap] (struct.field_ref tracker.ProgressTracker "Progress" (struct.field_ref raft "trk" (![ptrT] "r")))) (![uint64T] (struct.field_ref raft "id" (![ptrT] "r"))))) = #null
          then return: (![error] "ErrProposalDropped")
          else do:  #());;;
          (if: (![uint64T] (struct.field_ref raft "leadTransferee" (![ptrT] "r"))) ≠ None
          then
            do:  (let: "$a0" := #"%x [term %d] transfer leadership to %x is in progress; dropping proposal" in
            let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
            let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
            let: "$sl2" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "leadTransferee" (![ptrT] "r")))) in
            slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
            (interface.get "Debugf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
            return: (![error] "ErrProposalDropped")
          else do:  #());;;
          do:  (let: "$range" := (![sliceT] (struct.field_ref raftpb.Message "Entries" "m")) in
          slice.for_range raftpb.Entry "$range" (λ: "i" <>,
            let: "i" := ref_ty uint64T "i" in
            let: "e" := (ref_ty ptrT (zero_val ptrT)) in
            let: "$r0" := (slice.elem_ref raftpb.Entry (![sliceT] (struct.field_ref raftpb.Message "Entries" "m")) (![intT] "i")) in
            do:  ("e" <-[ptrT] "$r0");;;
            let: "cc" := (ref_ty raftpb.ConfChangeI (zero_val raftpb.ConfChangeI)) in
            (if: (![raftpb.EntryType] (struct.field_ref raftpb.Entry "Type" (![ptrT] "e"))) = raftpb.EntryConfChange
            then
              let: "ccc" := (ref_ty raftpb.ConfChange (zero_val raftpb.ConfChange)) in
              (let: "err" := (ref_ty error (zero_val error)) in
              let: "$r0" := (let: "$a0" := (![sliceT] (struct.field_ref raftpb.Entry "Data" (![ptrT] "e"))) in
              (raftpb.ConfChange__Unmarshal "ccc") "$a0") in
              do:  ("err" <-[error] "$r0");;;
              (if: (![error] "err") ≠ #interface.nil
              then
                do:  (let: "$a0" := (![error] "err") in
                Panic "$a0")
              else do:  #()));;;
              let: "$r0" := (interface.make raftpb.ConfChange__mset (![raftpb.ConfChange] "ccc")) in
              do:  ("cc" <-[raftpb.ConfChangeI] "$r0")
            else
              (if: (![raftpb.EntryType] (struct.field_ref raftpb.Entry "Type" (![ptrT] "e"))) = raftpb.EntryConfChangeV2
              then
                let: "ccc" := (ref_ty raftpb.ConfChangeV2 (zero_val raftpb.ConfChangeV2)) in
                (let: "err" := (ref_ty error (zero_val error)) in
                let: "$r0" := (let: "$a0" := (![sliceT] (struct.field_ref raftpb.Entry "Data" (![ptrT] "e"))) in
                (raftpb.ConfChangeV2__Unmarshal "ccc") "$a0") in
                do:  ("err" <-[error] "$r0");;;
                (if: (![error] "err") ≠ #interface.nil
                then
                  do:  (let: "$a0" := (![error] "err") in
                  Panic "$a0")
                else do:  #()));;;
                let: "$r0" := (interface.make raftpb.ConfChangeV2__mset (![raftpb.ConfChangeV2] "ccc")) in
                do:  ("cc" <-[raftpb.ConfChangeI] "$r0")
              else do:  #()));;;
            (if: (![raftpb.ConfChangeI] "cc") ≠ #interface.nil
            then
              let: "alreadyPending" := (ref_ty boolT (zero_val boolT)) in
              let: "$r0" := ((![uint64T] (struct.field_ref raft "pendingConfIndex" (![ptrT] "r"))) > (![uint64T] (struct.field_ref raftLog "applied" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))))) in
              do:  ("alreadyPending" <-[boolT] "$r0");;;
              let: "alreadyJoint" := (ref_ty boolT (zero_val boolT)) in
              let: "$r0" := (int_gt (let: "$a0" := (![quorum.MajorityConfig] (array.elem_ref quorum.MajorityConfig (![quorum.JointConfig] (struct.field_ref tracker.Config "Voters" (struct.field_ref tracker.ProgressTracker "Config" (struct.field_ref raft "trk" (![ptrT] "r"))))) #(W64 1))) in
              map.len "$a0") #(W64 0)) in
              do:  ("alreadyJoint" <-[boolT] "$r0");;;
              let: "wantsLeaveJoint" := (ref_ty boolT (zero_val boolT)) in
              let: "$r0" := ((let: "$a0" := (struct.field_get raftpb.ConfChangeV2 "Changes" ((interface.get "AsV2" (![raftpb.ConfChangeI] "cc")) #())) in
              slice.len "$a0") = #(W64 0)) in
              do:  ("wantsLeaveJoint" <-[boolT] "$r0");;;
              let: "failedCheck" := (ref_ty stringT (zero_val stringT)) in
              (if: ![boolT] "alreadyPending"
              then
                let: "$r0" := (let: "$a0" := #"possible unapplied conf change at index %d (applied to %d)" in
                let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "pendingConfIndex" (![ptrT] "r")))) in
                let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftLog "applied" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))))) in
                slice.literal interfaceT ["$sl0"; "$sl1"])) in
                fmt.Sprintf "$a0" "$a1") in
                do:  ("failedCheck" <-[stringT] "$r0")
              else
                (if: (![boolT] "alreadyJoint") && (~ (![boolT] "wantsLeaveJoint"))
                then
                  let: "$r0" := #"must transition out of joint config first" in
                  do:  ("failedCheck" <-[stringT] "$r0")
                else
                  (if: (~ (![boolT] "alreadyJoint")) && (![boolT] "wantsLeaveJoint")
                  then
                    let: "$r0" := #"not in joint state; refusing empty conf change" in
                    do:  ("failedCheck" <-[stringT] "$r0")
                  else do:  #())));;;
              (if: ((![stringT] "failedCheck") ≠ #"") && (~ (![boolT] (struct.field_ref raft "disableConfChangeValidation" (![ptrT] "r"))))
              then
                do:  (let: "$a0" := #"%x ignoring conf change %v at config %s: %s" in
                let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
                let: "$sl1" := (![raftpb.ConfChangeI] "cc") in
                let: "$sl2" := (interface.make tracker.Config__mset (![tracker.Config] (struct.field_ref tracker.ProgressTracker "Config" (struct.field_ref raft "trk" (![ptrT] "r"))))) in
                let: "$sl3" := (interface.make string__mset (![stringT] "failedCheck")) in
                slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"])) in
                (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
                let: "$r0" := (struct.make raftpb.Entry [{
                  "Type" ::= raftpb.EntryNormal
                }]) in
                do:  ((slice.elem_ref raftpb.Entry (![sliceT] (struct.field_ref raftpb.Message "Entries" "m")) (![intT] "i")) <-[raftpb.Entry] "$r0")
              else
                let: "$r0" := ((((raftLog__lastIndex (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()) + (![intT] "i")) + #(W64 1)) in
                do:  ((struct.field_ref raft "pendingConfIndex" (![ptrT] "r")) <-[uint64T] "$r0");;;
                do:  (let: "$a0" := (![raftpb.ConfChangeI] "cc") in
                let: "$a1" := (![ptrT] "r") in
                traceChangeConfEvent "$a0" "$a1"))
            else do:  #())));;;
          (if: (~ (let: "$a0" := (![sliceT] (struct.field_ref raftpb.Message "Entries" "m")) in
          (raft__appendEntry (![ptrT] "r")) "$a0"))
          then return: (![error] "ErrProposalDropped")
          else do:  #());;;
          do:  ((raft__bcastAppend (![ptrT] "r")) #());;;
          return: (#interface.nil)
        else
          (if: "$sw" = raftpb.MsgReadIndex
          then
            (if: (tracker.ProgressTracker__IsSingleton (struct.field_ref raft "trk" (![ptrT] "r"))) #()
            then
              (let: "resp" := (ref_ty raftpb.Message (zero_val raftpb.Message)) in
              let: "$r0" := (let: "$a0" := (![raftpb.Message] "m") in
              let: "$a1" := (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r"))))) in
              (raft__responseToReadIndexReq (![ptrT] "r")) "$a0" "$a1") in
              do:  ("resp" <-[raftpb.Message] "$r0");;;
              (if: (![uint64T] (struct.field_ref raftpb.Message "To" "resp")) ≠ None
              then
                do:  (let: "$a0" := (![raftpb.Message] "resp") in
                (raft__send (![ptrT] "r")) "$a0")
              else do:  #()));;;
              return: (#interface.nil)
            else do:  #());;;
            (if: (~ ((raft__committedEntryInCurrentTerm (![ptrT] "r")) #()))
            then
              let: "$r0" := (let: "$a0" := (![sliceT] (struct.field_ref raft "pendingReadIndexMessages" (![ptrT] "r"))) in
              let: "$a1" := ((let: "$sl0" := (![raftpb.Message] "m") in
              slice.literal raftpb.Message ["$sl0"])) in
              (slice.append sliceT) "$a0" "$a1") in
              do:  ((struct.field_ref raft "pendingReadIndexMessages" (![ptrT] "r")) <-[sliceT] "$r0");;;
              return: (#interface.nil)
            else do:  #());;;
            do:  (let: "$a0" := (![ptrT] "r") in
            let: "$a1" := (![raftpb.Message] "m") in
            sendMsgReadIndexResponse "$a0" "$a1");;;
            return: (#interface.nil)
          else
            (if: "$sw" = raftpb.MsgForgetLeader
            then return: (#interface.nil)
            else #())))));;;
    let: "pr" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (Fst (map.get (![tracker.ProgressMap] (struct.field_ref tracker.ProgressTracker "Progress" (struct.field_ref raft "trk" (![ptrT] "r")))) (![uint64T] (struct.field_ref raftpb.Message "From" "m")))) in
    do:  ("pr" <-[ptrT] "$r0");;;
    (if: (![ptrT] "pr") = #null
    then
      do:  (let: "$a0" := #"%x no progress available for %x" in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
      let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "From" "m"))) in
      slice.literal interfaceT ["$sl0"; "$sl1"])) in
      (interface.get "Debugf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
      return: (#interface.nil)
    else do:  #());;;
    let: "$sw" := (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) in
    (if: "$sw" = raftpb.MsgAppResp
    then
      let: "$r0" := #true in
      do:  ((struct.field_ref tracker.Progress "RecentActive" (![ptrT] "pr")) <-[boolT] "$r0");;;
      (if: ![boolT] (struct.field_ref raftpb.Message "Reject" "m")
      then
        do:  (let: "$a0" := #"%x received MsgAppResp(rejected, hint: (index %d, term %d)) from %x for index %d" in
        let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
        let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "RejectHint" "m"))) in
        let: "$sl2" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "LogTerm" "m"))) in
        let: "$sl3" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "From" "m"))) in
        let: "$sl4" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "Index" "m"))) in
        slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"; "$sl4"])) in
        (interface.get "Debugf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
        let: "nextProbeIdx" := (ref_ty uint64T (zero_val uint64T)) in
        let: "$r0" := (![uint64T] (struct.field_ref raftpb.Message "RejectHint" "m")) in
        do:  ("nextProbeIdx" <-[uint64T] "$r0");;;
        (if: (![uint64T] (struct.field_ref raftpb.Message "LogTerm" "m")) > #(W64 0)
        then
          let: ("$ret0", "$ret1") := (let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "RejectHint" "m")) in
          let: "$a1" := (![uint64T] (struct.field_ref raftpb.Message "LogTerm" "m")) in
          (raftLog__findConflictByTerm (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) "$a0" "$a1") in
          let: "$r0" := "$ret0" in
          let: "$r1" := "$ret1" in
          do:  ("nextProbeIdx" <-[uint64T] "$r0");;;
          do:  "$r1"
        else do:  #());;;
        (if: let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "Index" "m")) in
        let: "$a1" := (![uint64T] "nextProbeIdx") in
        (tracker.Progress__MaybeDecrTo (![ptrT] "pr")) "$a0" "$a1"
        then
          do:  (let: "$a0" := #"%x decreased progress of %x to [%s]" in
          let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
          let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "From" "m"))) in
          let: "$sl2" := (interface.make tracker.Progress__mset_ptr (![ptrT] "pr")) in
          slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
          (interface.get "Debugf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
          (if: (![tracker.StateType] (struct.field_ref tracker.Progress "State" (![ptrT] "pr"))) = tracker.StateReplicate
          then do:  ((tracker.Progress__BecomeProbe (![ptrT] "pr")) #())
          else do:  #());;;
          do:  (let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "From" "m")) in
          (raft__sendAppend (![ptrT] "r")) "$a0")
        else do:  #())
      else
        (if: (let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "Index" "m")) in
        (tracker.Progress__MaybeUpdate (![ptrT] "pr")) "$a0") || (((![uint64T] (struct.field_ref tracker.Progress "Match" (![ptrT] "pr"))) = (![uint64T] (struct.field_ref raftpb.Message "Index" "m"))) && ((![tracker.StateType] (struct.field_ref tracker.Progress "State" (![ptrT] "pr"))) = tracker.StateProbe))
        then
          let: "$sw" := #true in
          (if: "$sw" = ((![tracker.StateType] (struct.field_ref tracker.Progress "State" (![ptrT] "pr"))) = tracker.StateProbe)
          then do:  ((tracker.Progress__BecomeReplicate (![ptrT] "pr")) #())
          else
            (if: "$sw" = (((![tracker.StateType] (struct.field_ref tracker.Progress "State" (![ptrT] "pr"))) = tracker.StateSnapshot) && (((![uint64T] (struct.field_ref tracker.Progress "Match" (![ptrT] "pr"))) + #(W64 1)) ≥ ((raftLog__firstIndex (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #())))
            then
              do:  (let: "$a0" := #"%x recovered from needing snapshot, resumed sending replication messages to %x [%s]" in
              let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
              let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "From" "m"))) in
              let: "$sl2" := (interface.make tracker.Progress__mset_ptr (![ptrT] "pr")) in
              slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
              (interface.get "Debugf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
              do:  ((tracker.Progress__BecomeProbe (![ptrT] "pr")) #());;;
              do:  ((tracker.Progress__BecomeReplicate (![ptrT] "pr")) #())
            else
              (if: "$sw" = ((![tracker.StateType] (struct.field_ref tracker.Progress "State" (![ptrT] "pr"))) = tracker.StateReplicate)
              then
                do:  (let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "Index" "m")) in
                (tracker.Inflights__FreeLE (![ptrT] (struct.field_ref tracker.Progress "Inflights" (![ptrT] "pr")))) "$a0")
              else #())));;;
          (if: (raft__maybeCommit (![ptrT] "r")) #()
          then
            do:  (let: "$a0" := (![ptrT] "r") in
            releasePendingReadIndexMessages "$a0");;;
            do:  ((raft__bcastAppend (![ptrT] "r")) #())
          else
            (if: ((![uint64T] (struct.field_ref raft "id" (![ptrT] "r"))) ≠ (![uint64T] (struct.field_ref raftpb.Message "From" "m"))) && (let: "$a0" := (![uint64T] (struct.field_ref raftLog "committed" (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r"))))) in
            (tracker.Progress__CanBumpCommit (![ptrT] "pr")) "$a0")
            then
              do:  (let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "From" "m")) in
              (raft__sendAppend (![ptrT] "r")) "$a0")
            else do:  #()));;;
          (if: (![uint64T] (struct.field_ref raft "id" (![ptrT] "r"))) ≠ (![uint64T] (struct.field_ref raftpb.Message "From" "m"))
          then
            (for: (λ: <>, let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "From" "m")) in
            let: "$a1" := #false in
            (raft__maybeSendAppend (![ptrT] "r")) "$a0" "$a1"); (λ: <>, Skip) := λ: <>,
              do:  #())
          else do:  #());;;
          (if: ((![uint64T] (struct.field_ref raftpb.Message "From" "m")) = (![uint64T] (struct.field_ref raft "leadTransferee" (![ptrT] "r")))) && ((![uint64T] (struct.field_ref tracker.Progress "Match" (![ptrT] "pr"))) = ((raftLog__lastIndex (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #()))
          then
            do:  (let: "$a0" := #"%x sent MsgTimeoutNow to %x after received MsgAppResp" in
            let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
            let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "From" "m"))) in
            slice.literal interfaceT ["$sl0"; "$sl1"])) in
            (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
            do:  (let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "From" "m")) in
            (raft__sendTimeoutNow (![ptrT] "r")) "$a0")
          else do:  #())
        else do:  #()))
    else
      (if: "$sw" = raftpb.MsgHeartbeatResp
      then
        let: "$r0" := #true in
        do:  ((struct.field_ref tracker.Progress "RecentActive" (![ptrT] "pr")) <-[boolT] "$r0");;;
        let: "$r0" := #false in
        do:  ((struct.field_ref tracker.Progress "MsgAppFlowPaused" (![ptrT] "pr")) <-[boolT] "$r0");;;
        (if: ((![uint64T] (struct.field_ref tracker.Progress "Match" (![ptrT] "pr"))) < ((raftLog__lastIndex (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #())) || ((![tracker.StateType] (struct.field_ref tracker.Progress "State" (![ptrT] "pr"))) = tracker.StateProbe)
        then
          do:  (let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "From" "m")) in
          (raft__sendAppend (![ptrT] "r")) "$a0")
        else do:  #());;;
        (if: ((![ReadOnlyOption] (struct.field_ref readOnly "option" (![ptrT] (struct.field_ref raft "readOnly" (![ptrT] "r"))))) ≠ ReadOnlySafe) || ((let: "$a0" := (![sliceT] (struct.field_ref raftpb.Message "Context" "m")) in
        slice.len "$a0") = #(W64 0))
        then return: (#interface.nil)
        else do:  #());;;
        (if: (let: "$a0" := (let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "From" "m")) in
        let: "$a1" := (![sliceT] (struct.field_ref raftpb.Message "Context" "m")) in
        (readOnly__recvAck (![ptrT] (struct.field_ref raft "readOnly" (![ptrT] "r")))) "$a0" "$a1") in
        (quorum.JointConfig__VoteResult (![quorum.JointConfig] (struct.field_ref tracker.Config "Voters" (struct.field_ref tracker.ProgressTracker "Config" (struct.field_ref raft "trk" (![ptrT] "r")))))) "$a0") ≠ quorum.VoteWon
        then return: (#interface.nil)
        else do:  #());;;
        let: "rss" := (ref_ty sliceT (zero_val sliceT)) in
        let: "$r0" := (let: "$a0" := (![raftpb.Message] "m") in
        (readOnly__advance (![ptrT] (struct.field_ref raft "readOnly" (![ptrT] "r")))) "$a0") in
        do:  ("rss" <-[sliceT] "$r0");;;
        do:  (let: "$range" := (![sliceT] "rss") in
        slice.for_range ptrT "$range" (λ: <> "rs",
          let: "rs" := ref_ty ptrT "rs" in
          (let: "resp" := (ref_ty raftpb.Message (zero_val raftpb.Message)) in
          let: "$r0" := (let: "$a0" := (![raftpb.Message] (struct.field_ref readIndexStatus "req" (![ptrT] "rs"))) in
          let: "$a1" := (![uint64T] (struct.field_ref readIndexStatus "index" (![ptrT] "rs"))) in
          (raft__responseToReadIndexReq (![ptrT] "r")) "$a0" "$a1") in
          do:  ("resp" <-[raftpb.Message] "$r0");;;
          (if: (![uint64T] (struct.field_ref raftpb.Message "To" "resp")) ≠ None
          then
            do:  (let: "$a0" := (![raftpb.Message] "resp") in
            (raft__send (![ptrT] "r")) "$a0")
          else do:  #()))))
      else
        (if: "$sw" = raftpb.MsgSnapStatus
        then
          (if: (![tracker.StateType] (struct.field_ref tracker.Progress "State" (![ptrT] "pr"))) ≠ tracker.StateSnapshot
          then return: (#interface.nil)
          else do:  #());;;
          (if: (~ (![boolT] (struct.field_ref raftpb.Message "Reject" "m")))
          then
            do:  ((tracker.Progress__BecomeProbe (![ptrT] "pr")) #());;;
            do:  (let: "$a0" := #"%x snapshot succeeded, resumed sending replication messages to %x [%s]" in
            let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
            let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "From" "m"))) in
            let: "$sl2" := (interface.make tracker.Progress__mset_ptr (![ptrT] "pr")) in
            slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
            (interface.get "Debugf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1")
          else
            let: "$r0" := #(W64 0) in
            do:  ((struct.field_ref tracker.Progress "PendingSnapshot" (![ptrT] "pr")) <-[uint64T] "$r0");;;
            do:  ((tracker.Progress__BecomeProbe (![ptrT] "pr")) #());;;
            do:  (let: "$a0" := #"%x snapshot failed, resumed sending replication messages to %x [%s]" in
            let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
            let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "From" "m"))) in
            let: "$sl2" := (interface.make tracker.Progress__mset_ptr (![ptrT] "pr")) in
            slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
            (interface.get "Debugf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1"));;;
          let: "$r0" := #true in
          do:  ((struct.field_ref tracker.Progress "MsgAppFlowPaused" (![ptrT] "pr")) <-[boolT] "$r0")
        else
          (if: "$sw" = raftpb.MsgUnreachable
          then
            (if: (![tracker.StateType] (struct.field_ref tracker.Progress "State" (![ptrT] "pr"))) = tracker.StateReplicate
            then do:  ((tracker.Progress__BecomeProbe (![ptrT] "pr")) #())
            else do:  #());;;
            do:  (let: "$a0" := #"%x failed to send message to %x because it is unreachable [%s]" in
            let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
            let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "From" "m"))) in
            let: "$sl2" := (interface.make tracker.Progress__mset_ptr (![ptrT] "pr")) in
            slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
            (interface.get "Debugf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1")
          else
            (if: "$sw" = raftpb.MsgTransferLeader
            then
              (if: ![boolT] (struct.field_ref tracker.Progress "IsLearner" (![ptrT] "pr"))
              then
                do:  (let: "$a0" := #"%x is learner. Ignored transferring leadership" in
                let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
                slice.literal interfaceT ["$sl0"])) in
                (interface.get "Debugf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
                return: (#interface.nil)
              else do:  #());;;
              let: "leadTransferee" := (ref_ty uint64T (zero_val uint64T)) in
              let: "$r0" := (![uint64T] (struct.field_ref raftpb.Message "From" "m")) in
              do:  ("leadTransferee" <-[uint64T] "$r0");;;
              let: "lastLeadTransferee" := (ref_ty uint64T (zero_val uint64T)) in
              let: "$r0" := (![uint64T] (struct.field_ref raft "leadTransferee" (![ptrT] "r"))) in
              do:  ("lastLeadTransferee" <-[uint64T] "$r0");;;
              (if: (![uint64T] "lastLeadTransferee") ≠ None
              then
                (if: (![uint64T] "lastLeadTransferee") = (![uint64T] "leadTransferee")
                then
                  do:  (let: "$a0" := #"%x [term %d] transfer leadership to %x is in progress, ignores request to same node %x" in
                  let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
                  let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
                  let: "$sl2" := (interface.make uint64__mset (![uint64T] "leadTransferee")) in
                  let: "$sl3" := (interface.make uint64__mset (![uint64T] "leadTransferee")) in
                  slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"])) in
                  (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
                  return: (#interface.nil)
                else do:  #());;;
                do:  ((raft__abortLeaderTransfer (![ptrT] "r")) #());;;
                do:  (let: "$a0" := #"%x [term %d] abort previous transferring leadership to %x" in
                let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
                let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
                let: "$sl2" := (interface.make uint64__mset (![uint64T] "lastLeadTransferee")) in
                slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
                (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1")
              else do:  #());;;
              (if: (![uint64T] "leadTransferee") = (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))
              then
                do:  (let: "$a0" := #"%x is already leader. Ignored transferring leadership to self" in
                let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
                slice.literal interfaceT ["$sl0"])) in
                (interface.get "Debugf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
                return: (#interface.nil)
              else do:  #());;;
              do:  (let: "$a0" := #"%x [term %d] starts to transfer leadership to %x" in
              let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
              let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
              let: "$sl2" := (interface.make uint64__mset (![uint64T] "leadTransferee")) in
              slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
              (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
              let: "$r0" := #(W64 0) in
              do:  ((struct.field_ref raft "electionElapsed" (![ptrT] "r")) <-[intT] "$r0");;;
              let: "$r0" := (![uint64T] "leadTransferee") in
              do:  ((struct.field_ref raft "leadTransferee" (![ptrT] "r")) <-[uint64T] "$r0");;;
              (if: (![uint64T] (struct.field_ref tracker.Progress "Match" (![ptrT] "pr"))) = ((raftLog__lastIndex (![ptrT] (struct.field_ref raft "raftLog" (![ptrT] "r")))) #())
              then
                do:  (let: "$a0" := (![uint64T] "leadTransferee") in
                (raft__sendTimeoutNow (![ptrT] "r")) "$a0");;;
                do:  (let: "$a0" := #"%x sends MsgTimeoutNow to %x immediately as %x already has up-to-date log" in
                let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
                let: "$sl1" := (interface.make uint64__mset (![uint64T] "leadTransferee")) in
                let: "$sl2" := (interface.make uint64__mset (![uint64T] "leadTransferee")) in
                slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
                (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1")
              else
                do:  (let: "$a0" := (![uint64T] "leadTransferee") in
                (raft__sendAppend (![ptrT] "r")) "$a0"))
            else #())))));;;
    return: (#interface.nil)).

(* stepCandidate is shared by StateCandidate and StatePreCandidate; the difference is
   whether they respond to MsgVoteResp or MsgPreVoteResp.

   go: raft.go:1691:6 *)
Definition stepCandidate : val :=
  rec: "stepCandidate" "r" "m" :=
    exception_do (let: "m" := (ref_ty raftpb.Message "m") in
    let: "r" := (ref_ty ptrT "r") in
    let: "myVoteRespType" := (ref_ty raftpb.MessageType (zero_val raftpb.MessageType)) in
    (if: (![StateType] (struct.field_ref raft "state" (![ptrT] "r"))) = StatePreCandidate
    then
      let: "$r0" := raftpb.MsgPreVoteResp in
      do:  ("myVoteRespType" <-[raftpb.MessageType] "$r0")
    else
      let: "$r0" := raftpb.MsgVoteResp in
      do:  ("myVoteRespType" <-[raftpb.MessageType] "$r0"));;;
    let: "$sw" := (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) in
    (if: "$sw" = raftpb.MsgProp
    then
      do:  (let: "$a0" := #"%x no leader at term %d; dropping proposal" in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
      let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
      slice.literal interfaceT ["$sl0"; "$sl1"])) in
      (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
      return: (![error] "ErrProposalDropped")
    else
      (if: "$sw" = raftpb.MsgApp
      then
        do:  (let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "Term" "m")) in
        let: "$a1" := (![uint64T] (struct.field_ref raftpb.Message "From" "m")) in
        (raft__becomeFollower (![ptrT] "r")) "$a0" "$a1");;;
        do:  (let: "$a0" := (![raftpb.Message] "m") in
        (raft__handleAppendEntries (![ptrT] "r")) "$a0")
      else
        (if: "$sw" = raftpb.MsgHeartbeat
        then
          do:  (let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "Term" "m")) in
          let: "$a1" := (![uint64T] (struct.field_ref raftpb.Message "From" "m")) in
          (raft__becomeFollower (![ptrT] "r")) "$a0" "$a1");;;
          do:  (let: "$a0" := (![raftpb.Message] "m") in
          (raft__handleHeartbeat (![ptrT] "r")) "$a0")
        else
          (if: "$sw" = raftpb.MsgSnap
          then
            do:  (let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "Term" "m")) in
            let: "$a1" := (![uint64T] (struct.field_ref raftpb.Message "From" "m")) in
            (raft__becomeFollower (![ptrT] "r")) "$a0" "$a1");;;
            do:  (let: "$a0" := (![raftpb.Message] "m") in
            (raft__handleSnapshot (![ptrT] "r")) "$a0")
          else
            (if: "$sw" = (![raftpb.MessageType] "myVoteRespType")
            then
              let: "res" := (ref_ty quorum.VoteResult (zero_val quorum.VoteResult)) in
              let: "rj" := (ref_ty intT (zero_val intT)) in
              let: "gr" := (ref_ty intT (zero_val intT)) in
              let: (("$ret0", "$ret1"), "$ret2") := (let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "From" "m")) in
              let: "$a1" := (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) in
              let: "$a2" := (~ (![boolT] (struct.field_ref raftpb.Message "Reject" "m"))) in
              (raft__poll (![ptrT] "r")) "$a0" "$a1" "$a2") in
              let: "$r0" := "$ret0" in
              let: "$r1" := "$ret1" in
              let: "$r2" := "$ret2" in
              do:  ("gr" <-[intT] "$r0");;;
              do:  ("rj" <-[intT] "$r1");;;
              do:  ("res" <-[quorum.VoteResult] "$r2");;;
              do:  (let: "$a0" := #"%x has received %d %s votes and %d vote rejections" in
              let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
              let: "$sl1" := (interface.make int__mset (![intT] "gr")) in
              let: "$sl2" := (interface.make raftpb.MessageType__mset (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m"))) in
              let: "$sl3" := (interface.make int__mset (![intT] "rj")) in
              slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"])) in
              (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
              let: "$sw" := (![quorum.VoteResult] "res") in
              (if: "$sw" = quorum.VoteWon
              then
                (if: (![StateType] (struct.field_ref raft "state" (![ptrT] "r"))) = StatePreCandidate
                then
                  do:  (let: "$a0" := campaignElection in
                  (raft__campaign (![ptrT] "r")) "$a0")
                else
                  do:  ((raft__becomeLeader (![ptrT] "r")) #());;;
                  do:  ((raft__bcastAppend (![ptrT] "r")) #()))
              else
                (if: "$sw" = quorum.VoteLost
                then
                  do:  (let: "$a0" := (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r"))) in
                  let: "$a1" := None in
                  (raft__becomeFollower (![ptrT] "r")) "$a0" "$a1")
                else #()))
            else
              (if: "$sw" = raftpb.MsgTimeoutNow
              then
                do:  (let: "$a0" := #"%x [term %d state %v] ignored MsgTimeoutNow from %x" in
                let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
                let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
                let: "$sl2" := (interface.make StateType__mset (![StateType] (struct.field_ref raft "state" (![ptrT] "r")))) in
                let: "$sl3" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "From" "m"))) in
                slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"])) in
                (interface.get "Debugf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1")
              else #()))))));;;
    return: (#interface.nil)).

(* go: raft.go:1738:6 *)
Definition stepFollower : val :=
  rec: "stepFollower" "r" "m" :=
    exception_do (let: "m" := (ref_ty raftpb.Message "m") in
    let: "r" := (ref_ty ptrT "r") in
    let: "$sw" := (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) in
    (if: "$sw" = raftpb.MsgProp
    then
      (if: (![uint64T] (struct.field_ref raft "lead" (![ptrT] "r"))) = None
      then
        do:  (let: "$a0" := #"%x no leader at term %d; dropping proposal" in
        let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
        let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
        slice.literal interfaceT ["$sl0"; "$sl1"])) in
        (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
        return: (![error] "ErrProposalDropped")
      else
        (if: ![boolT] (struct.field_ref raft "disableProposalForwarding" (![ptrT] "r"))
        then
          do:  (let: "$a0" := #"%x not forwarding to leader %x at term %d; dropping proposal" in
          let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
          let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "lead" (![ptrT] "r")))) in
          let: "$sl2" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
          slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
          (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
          return: (![error] "ErrProposalDropped")
        else do:  #()));;;
      let: "$r0" := (![uint64T] (struct.field_ref raft "lead" (![ptrT] "r"))) in
      do:  ((struct.field_ref raftpb.Message "To" "m") <-[uint64T] "$r0");;;
      do:  (let: "$a0" := (![raftpb.Message] "m") in
      (raft__send (![ptrT] "r")) "$a0")
    else
      (if: "$sw" = raftpb.MsgApp
      then
        let: "$r0" := #(W64 0) in
        do:  ((struct.field_ref raft "electionElapsed" (![ptrT] "r")) <-[intT] "$r0");;;
        let: "$r0" := (![uint64T] (struct.field_ref raftpb.Message "From" "m")) in
        do:  ((struct.field_ref raft "lead" (![ptrT] "r")) <-[uint64T] "$r0");;;
        do:  (let: "$a0" := (![raftpb.Message] "m") in
        (raft__handleAppendEntries (![ptrT] "r")) "$a0")
      else
        (if: "$sw" = raftpb.MsgHeartbeat
        then
          let: "$r0" := #(W64 0) in
          do:  ((struct.field_ref raft "electionElapsed" (![ptrT] "r")) <-[intT] "$r0");;;
          let: "$r0" := (![uint64T] (struct.field_ref raftpb.Message "From" "m")) in
          do:  ((struct.field_ref raft "lead" (![ptrT] "r")) <-[uint64T] "$r0");;;
          do:  (let: "$a0" := (![raftpb.Message] "m") in
          (raft__handleHeartbeat (![ptrT] "r")) "$a0")
        else
          (if: "$sw" = raftpb.MsgSnap
          then
            let: "$r0" := #(W64 0) in
            do:  ((struct.field_ref raft "electionElapsed" (![ptrT] "r")) <-[intT] "$r0");;;
            let: "$r0" := (![uint64T] (struct.field_ref raftpb.Message "From" "m")) in
            do:  ((struct.field_ref raft "lead" (![ptrT] "r")) <-[uint64T] "$r0");;;
            do:  (let: "$a0" := (![raftpb.Message] "m") in
            (raft__handleSnapshot (![ptrT] "r")) "$a0")
          else
            (if: "$sw" = raftpb.MsgTransferLeader
            then
              (if: (![uint64T] (struct.field_ref raft "lead" (![ptrT] "r"))) = None
              then
                do:  (let: "$a0" := #"%x no leader at term %d; dropping leader transfer msg" in
                let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
                let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
                slice.literal interfaceT ["$sl0"; "$sl1"])) in
                (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
                return: (#interface.nil)
              else do:  #());;;
              let: "$r0" := (![uint64T] (struct.field_ref raft "lead" (![ptrT] "r"))) in
              do:  ((struct.field_ref raftpb.Message "To" "m") <-[uint64T] "$r0");;;
              do:  (let: "$a0" := (![raftpb.Message] "m") in
              (raft__send (![ptrT] "r")) "$a0")
            else
              (if: "$sw" = raftpb.MsgForgetLeader
              then
                (if: (![ReadOnlyOption] (struct.field_ref readOnly "option" (![ptrT] (struct.field_ref raft "readOnly" (![ptrT] "r"))))) = ReadOnlyLeaseBased
                then
                  do:  (let: "$a0" := ((let: "$sl0" := (interface.make string__mset #"ignoring MsgForgetLeader due to ReadOnlyLeaseBased") in
                  slice.literal interfaceT ["$sl0"])) in
                  (interface.get "Error" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0");;;
                  return: (#interface.nil)
                else do:  #());;;
                (if: (![uint64T] (struct.field_ref raft "lead" (![ptrT] "r"))) ≠ None
                then
                  do:  (let: "$a0" := #"%x forgetting leader %x at term %d" in
                  let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
                  let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "lead" (![ptrT] "r")))) in
                  let: "$sl2" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
                  slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
                  (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
                  let: "$r0" := None in
                  do:  ((struct.field_ref raft "lead" (![ptrT] "r")) <-[uint64T] "$r0")
                else do:  #())
              else
                (if: "$sw" = raftpb.MsgTimeoutNow
                then
                  do:  (let: "$a0" := #"%x [term %d] received MsgTimeoutNow from %x and starts an election to get leadership." in
                  let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
                  let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
                  let: "$sl2" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "From" "m"))) in
                  slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
                  (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
                  do:  (let: "$a0" := campaignTransfer in
                  (raft__hup (![ptrT] "r")) "$a0")
                else
                  (if: "$sw" = raftpb.MsgReadIndex
                  then
                    (if: (![uint64T] (struct.field_ref raft "lead" (![ptrT] "r"))) = None
                    then
                      do:  (let: "$a0" := #"%x no leader at term %d; dropping index reading msg" in
                      let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
                      let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "Term" (![ptrT] "r")))) in
                      slice.literal interfaceT ["$sl0"; "$sl1"])) in
                      (interface.get "Infof" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
                      return: (#interface.nil)
                    else do:  #());;;
                    let: "$r0" := (![uint64T] (struct.field_ref raft "lead" (![ptrT] "r"))) in
                    do:  ((struct.field_ref raftpb.Message "To" "m") <-[uint64T] "$r0");;;
                    do:  (let: "$a0" := (![raftpb.Message] "m") in
                    (raft__send (![ptrT] "r")) "$a0")
                  else
                    (if: "$sw" = raftpb.MsgReadIndexResp
                    then
                      (if: (let: "$a0" := (![sliceT] (struct.field_ref raftpb.Message "Entries" "m")) in
                      slice.len "$a0") ≠ #(W64 1)
                      then
                        do:  (let: "$a0" := #"%x invalid format of MsgReadIndexResp from %x, entries count: %d" in
                        let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "id" (![ptrT] "r")))) in
                        let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "From" "m"))) in
                        let: "$sl2" := (interface.make int__mset (let: "$a0" := (![sliceT] (struct.field_ref raftpb.Message "Entries" "m")) in
                        slice.len "$a0")) in
                        slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
                        (interface.get "Errorf" (![Logger] (struct.field_ref raft "logger" (![ptrT] "r")))) "$a0" "$a1");;;
                        return: (#interface.nil)
                      else do:  #());;;
                      let: "$r0" := (let: "$a0" := (![sliceT] (struct.field_ref raft "readStates" (![ptrT] "r"))) in
                      let: "$a1" := ((let: "$sl0" := (struct.make ReadState [{
                        "Index" ::= ![uint64T] (struct.field_ref raftpb.Message "Index" "m");
                        "RequestCtx" ::= ![sliceT] (struct.field_ref raftpb.Entry "Data" (slice.elem_ref raftpb.Entry (![sliceT] (struct.field_ref raftpb.Message "Entries" "m")) #(W64 0)))
                      }]) in
                      slice.literal ReadState ["$sl0"])) in
                      (slice.append sliceT) "$a0" "$a1") in
                      do:  ((struct.field_ref raft "readStates" (![ptrT] "r")) <-[sliceT] "$r0")
                    else #())))))))));;;
    return: (#interface.nil)).

(* go: raft.go:2185:6 *)
Definition init : val :=
  rec: "init" <> :=
    exception_do (let: "$r0" := stepFollower in
    do:  ("stepFollowerGlobal" <-[funcT] "$r0");;;
    let: "$r0" := stepCandidate in
    do:  ("stepCandidateGlobal" <-[funcT] "$r0");;;
    let: "$r0" := stepLeader in
    do:  ("stepLeaderGlobal" <-[funcT] "$r0")).

(* go: raft2.go:10:6 *)
Definition newTestConfig : val :=
  rec: "newTestConfig" "id" "election" "heartbeat" "storage" :=
    exception_do (let: "storage" := (ref_ty Storage "storage") in
    let: "heartbeat" := (ref_ty intT "heartbeat") in
    let: "election" := (ref_ty intT "election") in
    let: "id" := (ref_ty uint64T "id") in
    return: (ref_ty Config (struct.make Config [{
       "ID" ::= ![uint64T] "id";
       "ElectionTick" ::= ![intT] "election";
       "HeartbeatTick" ::= ![intT] "heartbeat";
       "Storage" ::= ![Storage] "storage";
       "MaxSizePerMsg" ::= #(W64 noLimit);
       "MaxInflightMsgs" ::= #(W64 256)
     }]))).

Definition inMemStorageCallStats : go_type := structT [
  "initialState" :: intT;
  "firstIndex" :: intT;
  "lastIndex" :: intT;
  "entries" :: intT;
  "term" :: intT;
  "snapshot" :: intT
].

Definition MemoryStorage : go_type := structT [
  "Mutex" :: sync.Mutex;
  "hardState" :: raftpb.HardState;
  "snapshot" :: raftpb.Snapshot;
  "ents" :: sliceT;
  "callStats" :: inMemStorageCallStats
].

(* go: storage.go:181:26 *)
Definition MemoryStorage__lastIndex : val :=
  rec: "MemoryStorage__lastIndex" "ms" <> :=
    exception_do (let: "ms" := (ref_ty ptrT "ms") in
    return: (((![uint64T] (struct.field_ref raftpb.Entry "Index" (slice.elem_ref raftpb.Entry (![sliceT] (struct.field_ref MemoryStorage "ents" (![ptrT] "ms"))) #(W64 0)))) + (let: "$a0" := (![sliceT] (struct.field_ref MemoryStorage "ents" (![ptrT] "ms"))) in
     slice.len "$a0")) - #(W64 1))).

(* go: storage.go:193:26 *)
Definition MemoryStorage__firstIndex : val :=
  rec: "MemoryStorage__firstIndex" "ms" <> :=
    exception_do (let: "ms" := (ref_ty ptrT "ms") in
    return: ((![uint64T] (struct.field_ref raftpb.Entry "Index" (slice.elem_ref raftpb.Entry (![sliceT] (struct.field_ref MemoryStorage "ents" (![ptrT] "ms"))) #(W64 0)))) + #(W64 1))).

(* Append the new entries to storage.
   TODO (xiangli): ensure the entries are continuous and
   entries[0].Index > ms.entries[0].Index

   go: storage.go:277:26 *)
Definition MemoryStorage__Append : val :=
  rec: "MemoryStorage__Append" "ms" "entries" :=
    with_defer: (let: "ms" := (ref_ty ptrT "ms") in
    let: "entries" := (ref_ty sliceT "entries") in
    (if: (let: "$a0" := (![sliceT] "entries") in
    slice.len "$a0") = #(W64 0)
    then return: (#interface.nil)
    else do:  #());;;
    do:  ((sync.Mutex__Lock (struct.field_ref MemoryStorage "Mutex" (![ptrT] "ms"))) #());;;
    do:  (let: "$f" := (sync.Mutex__Unlock (struct.field_ref MemoryStorage "Mutex" (![ptrT] "ms"))) in
    "$defer" <-[funcT] (let: "$oldf" := (![funcT] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    let: "first" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := ((MemoryStorage__firstIndex (![ptrT] "ms")) #()) in
    do:  ("first" <-[uint64T] "$r0");;;
    let: "last" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (((![uint64T] (struct.field_ref raftpb.Entry "Index" (slice.elem_ref raftpb.Entry (![sliceT] "entries") #(W64 0)))) + (let: "$a0" := (![sliceT] "entries") in
    slice.len "$a0")) - #(W64 1)) in
    do:  ("last" <-[uint64T] "$r0");;;
    (if: (![uint64T] "last") < (![uint64T] "first")
    then return: (#interface.nil)
    else do:  #());;;
    (if: (![uint64T] "first") > (![uint64T] (struct.field_ref raftpb.Entry "Index" (slice.elem_ref raftpb.Entry (![sliceT] "entries") #(W64 0))))
    then
      let: "$r0" := (let: "$s" := (![sliceT] "entries") in
      slice.slice raftpb.Entry "$s" ((![uint64T] "first") - (![uint64T] (struct.field_ref raftpb.Entry "Index" (slice.elem_ref raftpb.Entry (![sliceT] "entries") #(W64 0))))) (slice.len "$s")) in
      do:  ("entries" <-[sliceT] "$r0")
    else do:  #());;;
    let: "offset" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := ((![uint64T] (struct.field_ref raftpb.Entry "Index" (slice.elem_ref raftpb.Entry (![sliceT] "entries") #(W64 0)))) - (![uint64T] (struct.field_ref raftpb.Entry "Index" (slice.elem_ref raftpb.Entry (![sliceT] (struct.field_ref MemoryStorage "ents" (![ptrT] "ms"))) #(W64 0))))) in
    do:  ("offset" <-[uint64T] "$r0");;;
    let: "$sw" := #true in
    (if: "$sw" = ((let: "$a0" := (![sliceT] (struct.field_ref MemoryStorage "ents" (![ptrT] "ms"))) in
    slice.len "$a0") > (![uint64T] "offset"))
    then
      let: "$r0" := (let: "$a0" := (let: "$s" := (![sliceT] (struct.field_ref MemoryStorage "ents" (![ptrT] "ms"))) in
      slice.full_slice raftpb.Entry "$s" #(W64 0) (![uint64T] "offset") (![uint64T] "offset")) in
      let: "$a1" := (![sliceT] "entries") in
      (slice.append sliceT) "$a0" "$a1") in
      do:  ((struct.field_ref MemoryStorage "ents" (![ptrT] "ms")) <-[sliceT] "$r0")
    else
      (if: "$sw" = ((let: "$a0" := (![sliceT] (struct.field_ref MemoryStorage "ents" (![ptrT] "ms"))) in
      slice.len "$a0") = (![uint64T] "offset"))
      then
        let: "$r0" := (let: "$a0" := (![sliceT] (struct.field_ref MemoryStorage "ents" (![ptrT] "ms"))) in
        let: "$a1" := (![sliceT] "entries") in
        (slice.append sliceT) "$a0" "$a1") in
        do:  ((struct.field_ref MemoryStorage "ents" (![ptrT] "ms")) <-[sliceT] "$r0")
      else
        do:  (let: "$a0" := #"missing log entry [last: %d, append at: %d]" in
        let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset ((MemoryStorage__lastIndex (![ptrT] "ms")) #())) in
        let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Entry "Index" (slice.elem_ref raftpb.Entry (![sliceT] "entries") #(W64 0))))) in
        slice.literal interfaceT ["$sl0"; "$sl1"])) in
        (interface.get "Panicf" (getLogger #())) "$a0" "$a1")));;;
    return: (#interface.nil)).

(* ApplySnapshot overwrites the contents of this Storage object with
   those of the given snapshot.

   go: storage.go:207:26 *)
Definition MemoryStorage__ApplySnapshot : val :=
  rec: "MemoryStorage__ApplySnapshot" "ms" "snap" :=
    with_defer: (let: "ms" := (ref_ty ptrT "ms") in
    let: "snap" := (ref_ty raftpb.Snapshot "snap") in
    do:  ((sync.Mutex__Lock (struct.field_ref MemoryStorage "Mutex" (![ptrT] "ms"))) #());;;
    do:  (let: "$f" := (sync.Mutex__Unlock (struct.field_ref MemoryStorage "Mutex" (![ptrT] "ms"))) in
    "$defer" <-[funcT] (let: "$oldf" := (![funcT] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    let: "msIndex" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (![uint64T] (struct.field_ref raftpb.SnapshotMetadata "Index" (struct.field_ref raftpb.Snapshot "Metadata" (struct.field_ref MemoryStorage "snapshot" (![ptrT] "ms"))))) in
    do:  ("msIndex" <-[uint64T] "$r0");;;
    let: "snapIndex" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (![uint64T] (struct.field_ref raftpb.SnapshotMetadata "Index" (struct.field_ref raftpb.Snapshot "Metadata" "snap"))) in
    do:  ("snapIndex" <-[uint64T] "$r0");;;
    (if: (![uint64T] "msIndex") ≥ (![uint64T] "snapIndex")
    then return: (![error] "ErrSnapOutOfDate")
    else do:  #());;;
    let: "$r0" := (![raftpb.Snapshot] "snap") in
    do:  ((struct.field_ref MemoryStorage "snapshot" (![ptrT] "ms")) <-[raftpb.Snapshot] "$r0");;;
    let: "$r0" := ((let: "$sl0" := (struct.make raftpb.Entry [{
      "Term" ::= ![uint64T] (struct.field_ref raftpb.SnapshotMetadata "Term" (struct.field_ref raftpb.Snapshot "Metadata" "snap"));
      "Index" ::= ![uint64T] (struct.field_ref raftpb.SnapshotMetadata "Index" (struct.field_ref raftpb.Snapshot "Metadata" "snap"))
    }]) in
    slice.literal raftpb.Entry ["$sl0"])) in
    do:  ((struct.field_ref MemoryStorage "ents" (![ptrT] "ms")) <-[sliceT] "$r0");;;
    return: (#interface.nil)).

(* Compact discards all log entries prior to compactIndex.
   It is the application's responsibility to not attempt to compact an index
   greater than raftLog.applied.

   go: storage.go:251:26 *)
Definition MemoryStorage__Compact : val :=
  rec: "MemoryStorage__Compact" "ms" "compactIndex" :=
    with_defer: (let: "ms" := (ref_ty ptrT "ms") in
    let: "compactIndex" := (ref_ty uint64T "compactIndex") in
    do:  ((sync.Mutex__Lock (struct.field_ref MemoryStorage "Mutex" (![ptrT] "ms"))) #());;;
    do:  (let: "$f" := (sync.Mutex__Unlock (struct.field_ref MemoryStorage "Mutex" (![ptrT] "ms"))) in
    "$defer" <-[funcT] (let: "$oldf" := (![funcT] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    let: "offset" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (![uint64T] (struct.field_ref raftpb.Entry "Index" (slice.elem_ref raftpb.Entry (![sliceT] (struct.field_ref MemoryStorage "ents" (![ptrT] "ms"))) #(W64 0)))) in
    do:  ("offset" <-[uint64T] "$r0");;;
    (if: (![uint64T] "compactIndex") ≤ (![uint64T] "offset")
    then return: (![error] "ErrCompacted")
    else do:  #());;;
    (if: (![uint64T] "compactIndex") > ((MemoryStorage__lastIndex (![ptrT] "ms")) #())
    then
      do:  (let: "$a0" := #"compact %d is out of bound lastindex(%d)" in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] "compactIndex")) in
      let: "$sl1" := (interface.make uint64__mset ((MemoryStorage__lastIndex (![ptrT] "ms")) #())) in
      slice.literal interfaceT ["$sl0"; "$sl1"])) in
      (interface.get "Panicf" (getLogger #())) "$a0" "$a1")
    else do:  #());;;
    let: "i" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := ((![uint64T] "compactIndex") - (![uint64T] "offset")) in
    do:  ("i" <-[uint64T] "$r0");;;
    let: "ents" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (slice.make3 raftpb.Entry #(W64 1) ((let: "$a0" := (![sliceT] (struct.field_ref MemoryStorage "ents" (![ptrT] "ms"))) in
    slice.len "$a0") - (![uint64T] "i"))) in
    do:  ("ents" <-[sliceT] "$r0");;;
    let: "$r0" := (![uint64T] (struct.field_ref raftpb.Entry "Index" (slice.elem_ref raftpb.Entry (![sliceT] (struct.field_ref MemoryStorage "ents" (![ptrT] "ms"))) (![uint64T] "i")))) in
    do:  ((struct.field_ref raftpb.Entry "Index" (slice.elem_ref raftpb.Entry (![sliceT] "ents") #(W64 0))) <-[uint64T] "$r0");;;
    let: "$r0" := (![uint64T] (struct.field_ref raftpb.Entry "Term" (slice.elem_ref raftpb.Entry (![sliceT] (struct.field_ref MemoryStorage "ents" (![ptrT] "ms"))) (![uint64T] "i")))) in
    do:  ((struct.field_ref raftpb.Entry "Term" (slice.elem_ref raftpb.Entry (![sliceT] "ents") #(W64 0))) <-[uint64T] "$r0");;;
    let: "$r0" := (let: "$a0" := (![sliceT] "ents") in
    let: "$a1" := (let: "$s" := (![sliceT] (struct.field_ref MemoryStorage "ents" (![ptrT] "ms"))) in
    slice.slice raftpb.Entry "$s" ((![uint64T] "i") + #(W64 1)) (slice.len "$s")) in
    (slice.append sliceT) "$a0" "$a1") in
    do:  ("ents" <-[sliceT] "$r0");;;
    let: "$r0" := (![sliceT] "ents") in
    do:  ((struct.field_ref MemoryStorage "ents" (![ptrT] "ms")) <-[sliceT] "$r0");;;
    return: (#interface.nil)).

(* CreateSnapshot makes a snapshot which can be retrieved with Snapshot() and
   can be used to reconstruct the state at that point.
   If any configuration changes have been made since the last compaction,
   the result of the last ApplyConfChange must be passed in.

   go: storage.go:227:26 *)
Definition MemoryStorage__CreateSnapshot : val :=
  rec: "MemoryStorage__CreateSnapshot" "ms" "i" "cs" "data" :=
    with_defer: (let: "ms" := (ref_ty ptrT "ms") in
    let: "data" := (ref_ty sliceT "data") in
    let: "cs" := (ref_ty ptrT "cs") in
    let: "i" := (ref_ty uint64T "i") in
    do:  ((sync.Mutex__Lock (struct.field_ref MemoryStorage "Mutex" (![ptrT] "ms"))) #());;;
    do:  (let: "$f" := (sync.Mutex__Unlock (struct.field_ref MemoryStorage "Mutex" (![ptrT] "ms"))) in
    "$defer" <-[funcT] (let: "$oldf" := (![funcT] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    (if: (![uint64T] "i") ≤ (![uint64T] (struct.field_ref raftpb.SnapshotMetadata "Index" (struct.field_ref raftpb.Snapshot "Metadata" (struct.field_ref MemoryStorage "snapshot" (![ptrT] "ms")))))
    then
      return: (struct.make raftpb.Snapshot [{
       }], ![error] "ErrSnapOutOfDate")
    else do:  #());;;
    let: "offset" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (![uint64T] (struct.field_ref raftpb.Entry "Index" (slice.elem_ref raftpb.Entry (![sliceT] (struct.field_ref MemoryStorage "ents" (![ptrT] "ms"))) #(W64 0)))) in
    do:  ("offset" <-[uint64T] "$r0");;;
    (if: (![uint64T] "i") > ((MemoryStorage__lastIndex (![ptrT] "ms")) #())
    then
      do:  (let: "$a0" := #"snapshot %d is out of bound lastindex(%d)" in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] "i")) in
      let: "$sl1" := (interface.make uint64__mset ((MemoryStorage__lastIndex (![ptrT] "ms")) #())) in
      slice.literal interfaceT ["$sl0"; "$sl1"])) in
      (interface.get "Panicf" (getLogger #())) "$a0" "$a1")
    else do:  #());;;
    let: "$r0" := (![uint64T] "i") in
    do:  ((struct.field_ref raftpb.SnapshotMetadata "Index" (struct.field_ref raftpb.Snapshot "Metadata" (struct.field_ref MemoryStorage "snapshot" (![ptrT] "ms")))) <-[uint64T] "$r0");;;
    let: "$r0" := (![uint64T] (struct.field_ref raftpb.Entry "Term" (slice.elem_ref raftpb.Entry (![sliceT] (struct.field_ref MemoryStorage "ents" (![ptrT] "ms"))) ((![uint64T] "i") - (![uint64T] "offset"))))) in
    do:  ((struct.field_ref raftpb.SnapshotMetadata "Term" (struct.field_ref raftpb.Snapshot "Metadata" (struct.field_ref MemoryStorage "snapshot" (![ptrT] "ms")))) <-[uint64T] "$r0");;;
    (if: (![ptrT] "cs") ≠ #null
    then
      let: "$r0" := (![raftpb.ConfState] (![ptrT] "cs")) in
      do:  ((struct.field_ref raftpb.SnapshotMetadata "ConfState" (struct.field_ref raftpb.Snapshot "Metadata" (struct.field_ref MemoryStorage "snapshot" (![ptrT] "ms")))) <-[raftpb.ConfState] "$r0")
    else do:  #());;;
    let: "$r0" := (![sliceT] "data") in
    do:  ((struct.field_ref raftpb.Snapshot "Data" (struct.field_ref MemoryStorage "snapshot" (![ptrT] "ms"))) <-[sliceT] "$r0");;;
    return: (![raftpb.Snapshot] (struct.field_ref MemoryStorage "snapshot" (![ptrT] "ms")), #interface.nil)).

(* Entries implements the Storage interface.

   go: storage.go:135:26 *)
Definition MemoryStorage__Entries : val :=
  rec: "MemoryStorage__Entries" "ms" "lo" "hi" "maxSize" :=
    with_defer: (let: "ms" := (ref_ty ptrT "ms") in
    let: "maxSize" := (ref_ty uint64T "maxSize") in
    let: "hi" := (ref_ty uint64T "hi") in
    let: "lo" := (ref_ty uint64T "lo") in
    do:  ((sync.Mutex__Lock (struct.field_ref MemoryStorage "Mutex" (![ptrT] "ms"))) #());;;
    do:  (let: "$f" := (sync.Mutex__Unlock (struct.field_ref MemoryStorage "Mutex" (![ptrT] "ms"))) in
    "$defer" <-[funcT] (let: "$oldf" := (![funcT] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    do:  ((struct.field_ref inMemStorageCallStats "entries" (struct.field_ref MemoryStorage "callStats" (![ptrT] "ms"))) <-[intT] ((![intT] (struct.field_ref inMemStorageCallStats "entries" (struct.field_ref MemoryStorage "callStats" (![ptrT] "ms")))) + #(W64 1)));;;
    let: "offset" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (![uint64T] (struct.field_ref raftpb.Entry "Index" (slice.elem_ref raftpb.Entry (![sliceT] (struct.field_ref MemoryStorage "ents" (![ptrT] "ms"))) #(W64 0)))) in
    do:  ("offset" <-[uint64T] "$r0");;;
    (if: (![uint64T] "lo") ≤ (![uint64T] "offset")
    then return: (#slice.nil, ![error] "ErrCompacted")
    else do:  #());;;
    (if: (![uint64T] "hi") > (((MemoryStorage__lastIndex (![ptrT] "ms")) #()) + #(W64 1))
    then
      do:  (let: "$a0" := #"entries' hi(%d) is out of bound lastindex(%d)" in
      let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] "hi")) in
      let: "$sl1" := (interface.make uint64__mset ((MemoryStorage__lastIndex (![ptrT] "ms")) #())) in
      slice.literal interfaceT ["$sl0"; "$sl1"])) in
      (interface.get "Panicf" (getLogger #())) "$a0" "$a1")
    else do:  #());;;
    (if: (let: "$a0" := (![sliceT] (struct.field_ref MemoryStorage "ents" (![ptrT] "ms"))) in
    slice.len "$a0") = #(W64 1)
    then return: (#slice.nil, ![error] "ErrUnavailable")
    else do:  #());;;
    let: "ents" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (let: "$a0" := (let: "$s" := (![sliceT] (struct.field_ref MemoryStorage "ents" (![ptrT] "ms"))) in
    slice.slice raftpb.Entry "$s" ((![uint64T] "lo") - (![uint64T] "offset")) ((![uint64T] "hi") - (![uint64T] "offset"))) in
    let: "$a1" := (![uint64T] "maxSize") in
    limitSize "$a0" "$a1") in
    do:  ("ents" <-[sliceT] "$r0");;;
    return: (let: "$s" := (![sliceT] "ents") in
     slice.full_slice raftpb.Entry "$s" #(W64 0) (let: "$a0" := (![sliceT] "ents") in
     slice.len "$a0") (let: "$a0" := (![sliceT] "ents") in
     slice.len "$a0"), #interface.nil)).

(* FirstIndex implements the Storage interface.

   go: storage.go:186:26 *)
Definition MemoryStorage__FirstIndex : val :=
  rec: "MemoryStorage__FirstIndex" "ms" <> :=
    with_defer: (let: "ms" := (ref_ty ptrT "ms") in
    do:  ((sync.Mutex__Lock (struct.field_ref MemoryStorage "Mutex" (![ptrT] "ms"))) #());;;
    do:  (let: "$f" := (sync.Mutex__Unlock (struct.field_ref MemoryStorage "Mutex" (![ptrT] "ms"))) in
    "$defer" <-[funcT] (let: "$oldf" := (![funcT] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    do:  ((struct.field_ref inMemStorageCallStats "firstIndex" (struct.field_ref MemoryStorage "callStats" (![ptrT] "ms"))) <-[intT] ((![intT] (struct.field_ref inMemStorageCallStats "firstIndex" (struct.field_ref MemoryStorage "callStats" (![ptrT] "ms")))) + #(W64 1)));;;
    return: ((MemoryStorage__firstIndex (![ptrT] "ms")) #(), #interface.nil)).

(* InitialState implements the Storage interface.

   go: storage.go:121:26 *)
Definition MemoryStorage__InitialState : val :=
  rec: "MemoryStorage__InitialState" "ms" <> :=
    exception_do (let: "ms" := (ref_ty ptrT "ms") in
    do:  ((struct.field_ref inMemStorageCallStats "initialState" (struct.field_ref MemoryStorage "callStats" (![ptrT] "ms"))) <-[intT] ((![intT] (struct.field_ref inMemStorageCallStats "initialState" (struct.field_ref MemoryStorage "callStats" (![ptrT] "ms")))) + #(W64 1)));;;
    return: (![raftpb.HardState] (struct.field_ref MemoryStorage "hardState" (![ptrT] "ms")), ![raftpb.ConfState] (struct.field_ref raftpb.SnapshotMetadata "ConfState" (struct.field_ref raftpb.Snapshot "Metadata" (struct.field_ref MemoryStorage "snapshot" (![ptrT] "ms")))), #interface.nil)).

(* LastIndex implements the Storage interface.

   go: storage.go:174:26 *)
Definition MemoryStorage__LastIndex : val :=
  rec: "MemoryStorage__LastIndex" "ms" <> :=
    with_defer: (let: "ms" := (ref_ty ptrT "ms") in
    do:  ((sync.Mutex__Lock (struct.field_ref MemoryStorage "Mutex" (![ptrT] "ms"))) #());;;
    do:  (let: "$f" := (sync.Mutex__Unlock (struct.field_ref MemoryStorage "Mutex" (![ptrT] "ms"))) in
    "$defer" <-[funcT] (let: "$oldf" := (![funcT] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    do:  ((struct.field_ref inMemStorageCallStats "lastIndex" (struct.field_ref MemoryStorage "callStats" (![ptrT] "ms"))) <-[intT] ((![intT] (struct.field_ref inMemStorageCallStats "lastIndex" (struct.field_ref MemoryStorage "callStats" (![ptrT] "ms")))) + #(W64 1)));;;
    return: ((MemoryStorage__lastIndex (![ptrT] "ms")) #(), #interface.nil)).

(* SetHardState saves the current HardState.

   go: storage.go:127:26 *)
Definition MemoryStorage__SetHardState : val :=
  rec: "MemoryStorage__SetHardState" "ms" "st" :=
    with_defer: (let: "ms" := (ref_ty ptrT "ms") in
    let: "st" := (ref_ty raftpb.HardState "st") in
    do:  ((sync.Mutex__Lock (struct.field_ref MemoryStorage "Mutex" (![ptrT] "ms"))) #());;;
    do:  (let: "$f" := (sync.Mutex__Unlock (struct.field_ref MemoryStorage "Mutex" (![ptrT] "ms"))) in
    "$defer" <-[funcT] (let: "$oldf" := (![funcT] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    let: "$r0" := (![raftpb.HardState] "st") in
    do:  ((struct.field_ref MemoryStorage "hardState" (![ptrT] "ms")) <-[raftpb.HardState] "$r0");;;
    return: (#interface.nil)).

(* Snapshot implements the Storage interface.

   go: storage.go:198:26 *)
Definition MemoryStorage__Snapshot : val :=
  rec: "MemoryStorage__Snapshot" "ms" <> :=
    with_defer: (let: "ms" := (ref_ty ptrT "ms") in
    do:  ((sync.Mutex__Lock (struct.field_ref MemoryStorage "Mutex" (![ptrT] "ms"))) #());;;
    do:  (let: "$f" := (sync.Mutex__Unlock (struct.field_ref MemoryStorage "Mutex" (![ptrT] "ms"))) in
    "$defer" <-[funcT] (let: "$oldf" := (![funcT] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    do:  ((struct.field_ref inMemStorageCallStats "snapshot" (struct.field_ref MemoryStorage "callStats" (![ptrT] "ms"))) <-[intT] ((![intT] (struct.field_ref inMemStorageCallStats "snapshot" (struct.field_ref MemoryStorage "callStats" (![ptrT] "ms")))) + #(W64 1)));;;
    return: (![raftpb.Snapshot] (struct.field_ref MemoryStorage "snapshot" (![ptrT] "ms")), #interface.nil)).

(* Term implements the Storage interface.

   go: storage.go:159:26 *)
Definition MemoryStorage__Term : val :=
  rec: "MemoryStorage__Term" "ms" "i" :=
    with_defer: (let: "ms" := (ref_ty ptrT "ms") in
    let: "i" := (ref_ty uint64T "i") in
    do:  ((sync.Mutex__Lock (struct.field_ref MemoryStorage "Mutex" (![ptrT] "ms"))) #());;;
    do:  (let: "$f" := (sync.Mutex__Unlock (struct.field_ref MemoryStorage "Mutex" (![ptrT] "ms"))) in
    "$defer" <-[funcT] (let: "$oldf" := (![funcT] "$defer") in
    (λ: <>,
      "$f" #();;
      "$oldf" #()
      )));;;
    do:  ((struct.field_ref inMemStorageCallStats "term" (struct.field_ref MemoryStorage "callStats" (![ptrT] "ms"))) <-[intT] ((![intT] (struct.field_ref inMemStorageCallStats "term" (struct.field_ref MemoryStorage "callStats" (![ptrT] "ms")))) + #(W64 1)));;;
    let: "offset" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := (![uint64T] (struct.field_ref raftpb.Entry "Index" (slice.elem_ref raftpb.Entry (![sliceT] (struct.field_ref MemoryStorage "ents" (![ptrT] "ms"))) #(W64 0)))) in
    do:  ("offset" <-[uint64T] "$r0");;;
    (if: (![uint64T] "i") < (![uint64T] "offset")
    then return: (#(W64 0), ![error] "ErrCompacted")
    else do:  #());;;
    (if: int_geq ((![uint64T] "i") - (![uint64T] "offset")) (let: "$a0" := (![sliceT] (struct.field_ref MemoryStorage "ents" (![ptrT] "ms"))) in
    slice.len "$a0")
    then return: (#(W64 0), ![error] "ErrUnavailable")
    else do:  #());;;
    return: (![uint64T] (struct.field_ref raftpb.Entry "Term" (slice.elem_ref raftpb.Entry (![sliceT] (struct.field_ref MemoryStorage "ents" (![ptrT] "ms"))) ((![uint64T] "i") - (![uint64T] "offset")))), #interface.nil)).

Definition MemoryStorage__mset_ptr : list (string * val) := [
  ("Append", MemoryStorage__Append%V);
  ("ApplySnapshot", MemoryStorage__ApplySnapshot%V);
  ("Compact", MemoryStorage__Compact%V);
  ("CreateSnapshot", MemoryStorage__CreateSnapshot%V);
  ("Entries", MemoryStorage__Entries%V);
  ("FirstIndex", MemoryStorage__FirstIndex%V);
  ("InitialState", MemoryStorage__InitialState%V);
  ("LastIndex", MemoryStorage__LastIndex%V);
  ("Lock", (λ: "$recvAddr",
    sync.Mutex__Lock (struct.field_ref MemoryStorage "Mutex" "$recvAddr")
    )%V);
  ("SetHardState", MemoryStorage__SetHardState%V);
  ("Snapshot", MemoryStorage__Snapshot%V);
  ("Term", MemoryStorage__Term%V);
  ("TryLock", (λ: "$recvAddr",
    sync.Mutex__TryLock (struct.field_ref MemoryStorage "Mutex" "$recvAddr")
    )%V);
  ("Unlock", (λ: "$recvAddr",
    sync.Mutex__Unlock (struct.field_ref MemoryStorage "Mutex" "$recvAddr")
    )%V);
  ("firstIndex", MemoryStorage__firstIndex%V);
  ("lastIndex", MemoryStorage__lastIndex%V)
].

(* NewMemoryStorage creates an empty MemoryStorage.

   go: storage.go:113:6 *)
Definition NewMemoryStorage : val :=
  rec: "NewMemoryStorage" <> :=
    exception_do (return: (ref_ty MemoryStorage (struct.make MemoryStorage [{
       "ents" ::= slice.make2 raftpb.Entry #(W64 1)
     }]))).

(* go: raft2.go:21:6 *)
Definition entsWithConfig : val :=
  rec: "entsWithConfig" "configFunc" "terms" :=
    exception_do (let: "terms" := (ref_ty sliceT "terms") in
    let: "configFunc" := (ref_ty funcT "configFunc") in
    let: "storage" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (NewMemoryStorage #()) in
    do:  ("storage" <-[ptrT] "$r0");;;
    do:  (let: "$range" := (![sliceT] "terms") in
    slice.for_range uint64T "$range" (λ: "i" "term",
      let: "i" := ref_ty uint64T "i" in
      let: "term" := ref_ty uint64T "term" in
      do:  (let: "$a0" := ((let: "$sl0" := (struct.make raftpb.Entry [{
        "Index" ::= (![intT] "i") + #(W64 1);
        "Term" ::= ![uint64T] "term"
      }]) in
      slice.literal raftpb.Entry ["$sl0"])) in
      (MemoryStorage__Append (![ptrT] "storage")) "$a0")));;;
    let: "cfg" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (let: "$a0" := #(W64 1) in
    let: "$a1" := #(W64 5) in
    let: "$a2" := #(W64 1) in
    let: "$a3" := (interface.make MemoryStorage__mset_ptr (![ptrT] "storage")) in
    newTestConfig "$a0" "$a1" "$a2" "$a3") in
    do:  ("cfg" <-[ptrT] "$r0");;;
    (if: (![funcT] "configFunc") ≠ #func.nil
    then
      do:  (let: "$a0" := (![ptrT] "cfg") in
      (![funcT] "configFunc") "$a0")
    else do:  #());;;
    let: "sm" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (let: "$a0" := (![ptrT] "cfg") in
    newRaft "$a0") in
    do:  ("sm" <-[ptrT] "$r0");;;
    do:  (let: "$a0" := (![uint64T] (slice.elem_ref uint64T (![sliceT] "terms") ((let: "$a0" := (![sliceT] "terms") in
    slice.len "$a0") - #(W64 1)))) in
    (raft__reset (![ptrT] "sm")) "$a0");;;
    return: (![ptrT] "sm")).

Definition blackHole : go_type := structT [
].

(* go: raft2.go:37:18 *)
Definition blackHole__Step : val :=
  rec: "blackHole__Step" <> "" :=
    exception_do (let: <> := (ref_ty blackHole "_") in
    let: "" := (ref_ty raftpb.Message "") in
    return: (#interface.nil)).

(* go: raft2.go:39:18 *)
Definition blackHole__advanceMessagesAfterAppend : val :=
  rec: "blackHole__advanceMessagesAfterAppend" <> <> :=
    exception_do (let: <> := (ref_ty blackHole "_") in
    do:  #()).

(* go: raft2.go:38:18 *)
Definition blackHole__readMessages : val :=
  rec: "blackHole__readMessages" <> <> :=
    exception_do (let: <> := (ref_ty blackHole "_") in
    return: (#slice.nil)).

Definition blackHole__mset : list (string * val) := [
  ("Step", blackHole__Step%V);
  ("advanceMessagesAfterAppend", blackHole__advanceMessagesAfterAppend%V);
  ("readMessages", blackHole__readMessages%V)
].

Definition blackHole__mset_ptr : list (string * val) := [
  ("Step", (λ: "$recvAddr",
    blackHole__Step (![blackHole] "$recvAddr")
    )%V);
  ("advanceMessagesAfterAppend", (λ: "$recvAddr",
    blackHole__advanceMessagesAfterAppend (![blackHole] "$recvAddr")
    )%V);
  ("readMessages", (λ: "$recvAddr",
    blackHole__readMessages (![blackHole] "$recvAddr")
    )%V)
].

(* go: raft2.go:43:6 *)
Definition preVoteConfig : val :=
  rec: "preVoteConfig" "c" :=
    exception_do (let: "c" := (ref_ty ptrT "c") in
    let: "$r0" := #true in
    do:  ((struct.field_ref Config "PreVote" (![ptrT] "c")) <-[boolT] "$r0")).

Definition stateMachine : go_type := interfaceT.

Definition connem : go_type := structT [
  "from" :: uint64T;
  "to" :: uint64T
].

Definition connem__mset : list (string * val) := [
].

Definition connem__mset_ptr : list (string * val) := [
].

Definition network : go_type := structT [
  "t" :: ptrT;
  "peers" :: mapT uint64T stateMachine;
  "storage" :: mapT uint64T ptrT;
  "dropm64" :: mapT connem uint64T;
  "ignorem" :: mapT raftpb.MessageType boolT;
  "msgHook" :: funcT
].

Definition network__mset : list (string * val) := [
].

(* go: raft2.go:159:20 *)
Definition network__filter : val :=
  rec: "network__filter" "nw" "msgs" :=
    exception_do (let: "nw" := (ref_ty ptrT "nw") in
    let: "msgs" := (ref_ty sliceT "msgs") in
    let: "mm" := (ref_ty sliceT (zero_val sliceT)) in
    do:  (let: "$range" := (![sliceT] "msgs") in
    slice.for_range raftpb.Message "$range" (λ: <> "m",
      let: "m" := ref_ty raftpb.Message "m" in
      (if: Fst (map.get (![mapT raftpb.MessageType boolT] (struct.field_ref network "ignorem" (![ptrT] "nw"))) (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")))
      then continue: #()
      else do:  #());;;
      let: "$sw" := (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) in
      (if: "$sw" = raftpb.MsgHup
      then
        do:  (let: "$a0" := (interface.make string__mset #"unexpected msgHup") in
        Panic "$a0")
      else
        let: "perc64" := (ref_ty uint64T (zero_val uint64T)) in
        let: "$r0" := (Fst (map.get (![mapT connem uint64T] (struct.field_ref network "dropm64" (![ptrT] "nw"))) (struct.make connem [{
          "from" ::= ![uint64T] (struct.field_ref raftpb.Message "From" "m");
          "to" ::= ![uint64T] (struct.field_ref raftpb.Message "To" "m")
        }]))) in
        do:  ("perc64" <-[uint64T] "$r0");;;
        (let: "n" := (ref_ty uint64T (zero_val uint64T)) in
        let: "$r0" := (rand.Uint64 #()) in
        do:  ("n" <-[uint64T] "$r0");;;
        (if: (![uint64T] "n") < (![uint64T] "perc64")
        then continue: #()
        else do:  #())));;;
      (if: (![funcT] (struct.field_ref network "msgHook" (![ptrT] "nw"))) ≠ #func.nil
      then
        (if: (~ (let: "$a0" := (![raftpb.Message] "m") in
        (![funcT] (struct.field_ref network "msgHook" (![ptrT] "nw"))) "$a0"))
        then continue: #()
        else do:  #())
      else do:  #());;;
      let: "$r0" := (let: "$a0" := (![sliceT] "mm") in
      let: "$a1" := ((let: "$sl0" := (![raftpb.Message] "m") in
      slice.literal raftpb.Message ["$sl0"])) in
      (slice.append sliceT) "$a0" "$a1") in
      do:  ("mm" <-[sliceT] "$r0")));;;
    return: (![sliceT] "mm")).

Definition EntryFormatter : go_type := funcT.

(* go: util.go:95:6 *)
Definition DescribeConfState : val :=
  rec: "DescribeConfState" "state" :=
    exception_do (let: "state" := (ref_ty raftpb.ConfState "state") in
    return: (let: "$a0" := #"Voters:%v VotersOutgoing:%v Learners:%v LearnersNext:%v AutoLeave:%v" in
     let: "$a1" := ((let: "$sl0" := (interface.make slice__mset (![sliceT] (struct.field_ref raftpb.ConfState "Voters" "state"))) in
     let: "$sl1" := (interface.make slice__mset (![sliceT] (struct.field_ref raftpb.ConfState "VotersOutgoing" "state"))) in
     let: "$sl2" := (interface.make slice__mset (![sliceT] (struct.field_ref raftpb.ConfState "Learners" "state"))) in
     let: "$sl3" := (interface.make slice__mset (![sliceT] (struct.field_ref raftpb.ConfState "LearnersNext" "state"))) in
     let: "$sl4" := (interface.make bool__mset (![boolT] (struct.field_ref raftpb.ConfState "AutoLeave" "state"))) in
     slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"; "$sl4"])) in
     fmt.Sprintf "$a0" "$a1")).

(* go: util.go:102:6 *)
Definition DescribeSnapshot : val :=
  rec: "DescribeSnapshot" "snap" :=
    exception_do (let: "snap" := (ref_ty raftpb.Snapshot "snap") in
    let: "m" := (ref_ty raftpb.SnapshotMetadata (zero_val raftpb.SnapshotMetadata)) in
    let: "$r0" := (![raftpb.SnapshotMetadata] (struct.field_ref raftpb.Snapshot "Metadata" "snap")) in
    do:  ("m" <-[raftpb.SnapshotMetadata] "$r0");;;
    return: (let: "$a0" := #"Index:%d Term:%d ConfState:%s" in
     let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.SnapshotMetadata "Index" "m"))) in
     let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.SnapshotMetadata "Term" "m"))) in
     let: "$sl2" := (interface.make string__mset (let: "$a0" := (![raftpb.ConfState] (struct.field_ref raftpb.SnapshotMetadata "ConfState" "m")) in
     DescribeConfState "$a0")) in
     slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
     fmt.Sprintf "$a0" "$a1")).

(* DescribeEntry returns a concise human-readable description of an
   Entry for debugging.

   go: util.go:206:6 *)
Definition DescribeEntry : val :=
  rec: "DescribeEntry" "e" "f" :=
    exception_do (let: "f" := (ref_ty EntryFormatter "f") in
    let: "e" := (ref_ty raftpb.Entry "e") in
    (if: (![EntryFormatter] "f") = #func.nil
    then
      let: "$r0" := (λ: "data",
        exception_do (let: "data" := (ref_ty sliceT "data") in
        return: (let: "$a0" := #"%q" in
         let: "$a1" := ((let: "$sl0" := (interface.make slice__mset (![sliceT] "data")) in
         slice.literal interfaceT ["$sl0"])) in
         fmt.Sprintf "$a0" "$a1"))
        ) in
      do:  ("f" <-[EntryFormatter] "$r0")
    else do:  #());;;
    let: "formatConfChange" := (ref_ty funcT (zero_val funcT)) in
    let: "$r0" := (λ: "cc",
      exception_do (let: "cc" := (ref_ty raftpb.ConfChangeI "cc") in
      return: (let: "$a0" := (struct.field_get raftpb.ConfChangeV2 "Changes" ((interface.get "AsV2" (![raftpb.ConfChangeI] "cc")) #())) in
       raftpb.ConfChangesToString "$a0"))
      ) in
    do:  ("formatConfChange" <-[funcT] "$r0");;;
    let: "formatted" := (ref_ty stringT (zero_val stringT)) in
    let: "$sw" := (![raftpb.EntryType] (struct.field_ref raftpb.Entry "Type" "e")) in
    (if: "$sw" = raftpb.EntryNormal
    then
      let: "$r0" := (let: "$a0" := (![sliceT] (struct.field_ref raftpb.Entry "Data" "e")) in
      (![EntryFormatter] "f") "$a0") in
      do:  ("formatted" <-[stringT] "$r0")
    else
      (if: "$sw" = raftpb.EntryConfChange
      then
        let: "cc" := (ref_ty raftpb.ConfChange (zero_val raftpb.ConfChange)) in
        (let: "err" := (ref_ty error (zero_val error)) in
        let: "$r0" := (let: "$a0" := (![sliceT] (struct.field_ref raftpb.Entry "Data" "e")) in
        (raftpb.ConfChange__Unmarshal "cc") "$a0") in
        do:  ("err" <-[error] "$r0");;;
        (if: (![error] "err") ≠ #interface.nil
        then
          let: "$r0" := ((interface.get "Error" (![error] "err")) #()) in
          do:  ("formatted" <-[stringT] "$r0")
        else
          let: "$r0" := (let: "$a0" := (interface.make raftpb.ConfChange__mset (![raftpb.ConfChange] "cc")) in
          (![funcT] "formatConfChange") "$a0") in
          do:  ("formatted" <-[stringT] "$r0")))
      else
        (if: "$sw" = raftpb.EntryConfChangeV2
        then
          let: "cc" := (ref_ty raftpb.ConfChangeV2 (zero_val raftpb.ConfChangeV2)) in
          (let: "err" := (ref_ty error (zero_val error)) in
          let: "$r0" := (let: "$a0" := (![sliceT] (struct.field_ref raftpb.Entry "Data" "e")) in
          (raftpb.ConfChangeV2__Unmarshal "cc") "$a0") in
          do:  ("err" <-[error] "$r0");;;
          (if: (![error] "err") ≠ #interface.nil
          then
            let: "$r0" := ((interface.get "Error" (![error] "err")) #()) in
            do:  ("formatted" <-[stringT] "$r0")
          else
            let: "$r0" := (let: "$a0" := (interface.make raftpb.ConfChangeV2__mset (![raftpb.ConfChangeV2] "cc")) in
            (![funcT] "formatConfChange") "$a0") in
            do:  ("formatted" <-[stringT] "$r0")))
        else #())));;;
    (if: (![stringT] "formatted") ≠ #""
    then
      let: "$r0" := (#" " + (![stringT] "formatted")) in
      do:  ("formatted" <-[stringT] "$r0")
    else do:  #());;;
    return: (let: "$a0" := #"%d/%d %s%s" in
     let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Entry "Term" "e"))) in
     let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Entry "Index" "e"))) in
     let: "$sl2" := (interface.make raftpb.EntryType__mset (![raftpb.EntryType] (struct.field_ref raftpb.Entry "Type" "e"))) in
     let: "$sl3" := (interface.make string__mset (![stringT] "formatted")) in
     slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"])) in
     fmt.Sprintf "$a0" "$a1")).

(* go: util.go:191:6 *)
Definition describeTarget : val :=
  rec: "describeTarget" "id" :=
    exception_do (let: "id" := (ref_ty uint64T "id") in
    let: "$sw" := (![uint64T] "id") in
    (if: "$sw" = None
    then return: (#"None")
    else
      (if: "$sw" = LocalAppendThread
      then return: (#"AppendThread")
      else
        (if: "$sw" = LocalApplyThread
        then return: (#"ApplyThread")
        else
          return: (let: "$a0" := #"%x" in
           let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] "id")) in
           slice.literal interfaceT ["$sl0"])) in
           fmt.Sprintf "$a0" "$a1"))))).

(* go: util.go:154:6 *)
Definition describeMessageWithIndent : val :=
  rec: "describeMessageWithIndent" "indent" "m" "f" :=
    exception_do (let: "f" := (ref_ty EntryFormatter "f") in
    let: "m" := (ref_ty raftpb.Message "m") in
    let: "indent" := (ref_ty stringT "indent") in
    let: "buf" := (ref_ty bytes.Buffer (zero_val bytes.Buffer)) in
    do:  (let: "$a0" := (interface.make bytes.Buffer__mset_ptr "buf") in
    let: "$a1" := #"%s%s->%s %v Term:%d Log:%d/%d" in
    let: "$a2" := ((let: "$sl0" := (interface.make string__mset (![stringT] "indent")) in
    let: "$sl1" := (interface.make string__mset (let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "From" "m")) in
    describeTarget "$a0")) in
    let: "$sl2" := (interface.make string__mset (let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "To" "m")) in
    describeTarget "$a0")) in
    let: "$sl3" := (interface.make raftpb.MessageType__mset (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m"))) in
    let: "$sl4" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "Term" "m"))) in
    let: "$sl5" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "LogTerm" "m"))) in
    let: "$sl6" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "Index" "m"))) in
    slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"; "$sl4"; "$sl5"; "$sl6"])) in
    fmt.Fprintf "$a0" "$a1" "$a2");;;
    (if: ![boolT] (struct.field_ref raftpb.Message "Reject" "m")
    then
      do:  (let: "$a0" := (interface.make bytes.Buffer__mset_ptr "buf") in
      let: "$a1" := #" Rejected (Hint: %d)" in
      let: "$a2" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "RejectHint" "m"))) in
      slice.literal interfaceT ["$sl0"])) in
      fmt.Fprintf "$a0" "$a1" "$a2")
    else do:  #());;;
    (if: (![uint64T] (struct.field_ref raftpb.Message "Commit" "m")) ≠ #(W64 0)
    then
      do:  (let: "$a0" := (interface.make bytes.Buffer__mset_ptr "buf") in
      let: "$a1" := #" Commit:%d" in
      let: "$a2" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "Commit" "m"))) in
      slice.literal interfaceT ["$sl0"])) in
      fmt.Fprintf "$a0" "$a1" "$a2")
    else do:  #());;;
    (if: (![uint64T] (struct.field_ref raftpb.Message "Vote" "m")) ≠ #(W64 0)
    then
      do:  (let: "$a0" := (interface.make bytes.Buffer__mset_ptr "buf") in
      let: "$a1" := #" Vote:%d" in
      let: "$a2" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.Message "Vote" "m"))) in
      slice.literal interfaceT ["$sl0"])) in
      fmt.Fprintf "$a0" "$a1" "$a2")
    else do:  #());;;
    (let: "ln" := (ref_ty intT (zero_val intT)) in
    let: "$r0" := (let: "$a0" := (![sliceT] (struct.field_ref raftpb.Message "Entries" "m")) in
    slice.len "$a0") in
    do:  ("ln" <-[intT] "$r0");;;
    (if: (![intT] "ln") = #(W64 1)
    then
      do:  (let: "$a0" := (interface.make bytes.Buffer__mset_ptr "buf") in
      let: "$a1" := #" Entries:[%s]" in
      let: "$a2" := ((let: "$sl0" := (interface.make string__mset (let: "$a0" := (![raftpb.Entry] (slice.elem_ref raftpb.Entry (![sliceT] (struct.field_ref raftpb.Message "Entries" "m")) #(W64 0))) in
      let: "$a1" := (![EntryFormatter] "f") in
      DescribeEntry "$a0" "$a1")) in
      slice.literal interfaceT ["$sl0"])) in
      fmt.Fprintf "$a0" "$a1" "$a2")
    else
      (if: int_gt (![intT] "ln") #(W64 1)
      then
        do:  (let: "$a0" := (interface.make bytes.Buffer__mset_ptr "buf") in
        let: "$a1" := ((let: "$sl0" := (interface.make string__mset #" Entries:[") in
        slice.literal interfaceT ["$sl0"])) in
        fmt.Fprint "$a0" "$a1");;;
        do:  (let: "$range" := (![sliceT] (struct.field_ref raftpb.Message "Entries" "m")) in
        slice.for_range raftpb.Entry "$range" (λ: <> "e",
          let: "e" := ref_ty raftpb.Entry "e" in
          do:  (let: "$a0" := (interface.make bytes.Buffer__mset_ptr "buf") in
          let: "$a1" := #"
          %s  " in
          let: "$a2" := ((let: "$sl0" := (interface.make string__mset (![stringT] "indent")) in
          slice.literal interfaceT ["$sl0"])) in
          fmt.Fprintf "$a0" "$a1" "$a2");;;
          do:  (let: "$a0" := (let: "$a0" := (![raftpb.Entry] "e") in
          let: "$a1" := (![EntryFormatter] "f") in
          DescribeEntry "$a0" "$a1") in
          (bytes.Buffer__WriteString "buf") "$a0")));;;
        do:  (let: "$a0" := (interface.make bytes.Buffer__mset_ptr "buf") in
        let: "$a1" := #"
        %s]" in
        let: "$a2" := ((let: "$sl0" := (interface.make string__mset (![stringT] "indent")) in
        slice.literal interfaceT ["$sl0"])) in
        fmt.Fprintf "$a0" "$a1" "$a2")
      else do:  #())));;;
    (let: "s" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (![ptrT] (struct.field_ref raftpb.Message "Snapshot" "m")) in
    do:  ("s" <-[ptrT] "$r0");;;
    (if: ((![ptrT] "s") ≠ #null) && (~ (let: "$a0" := (![raftpb.Snapshot] (![ptrT] "s")) in
    IsEmptySnap "$a0"))
    then
      do:  (let: "$a0" := (interface.make bytes.Buffer__mset_ptr "buf") in
      let: "$a1" := #"
      %s  Snapshot: %s" in
      let: "$a2" := ((let: "$sl0" := (interface.make string__mset (![stringT] "indent")) in
      let: "$sl1" := (interface.make string__mset (let: "$a0" := (![raftpb.Snapshot] (![ptrT] "s")) in
      DescribeSnapshot "$a0")) in
      slice.literal interfaceT ["$sl0"; "$sl1"])) in
      fmt.Fprintf "$a0" "$a1" "$a2")
    else do:  #()));;;
    (if: int_gt (let: "$a0" := (![sliceT] (struct.field_ref raftpb.Message "Responses" "m")) in
    slice.len "$a0") #(W64 0)
    then
      do:  (let: "$a0" := (interface.make bytes.Buffer__mset_ptr "buf") in
      let: "$a1" := #" Responses:[" in
      let: "$a2" := #slice.nil in
      fmt.Fprintf "$a0" "$a1" "$a2");;;
      do:  (let: "$range" := (![sliceT] (struct.field_ref raftpb.Message "Responses" "m")) in
      slice.for_range raftpb.Message "$range" (λ: <> "m",
        let: "m" := ref_ty raftpb.Message "m" in
        do:  (let: "$a0" := #"
        " in
        (bytes.Buffer__WriteString "buf") "$a0");;;
        do:  (let: "$a0" := (let: "$a0" := ((![stringT] "indent") + #"  ") in
        let: "$a1" := (![raftpb.Message] "m") in
        let: "$a2" := (![EntryFormatter] "f") in
        "describeMessageWithIndent" "$a0" "$a1" "$a2") in
        (bytes.Buffer__WriteString "buf") "$a0")));;;
      do:  (let: "$a0" := (interface.make bytes.Buffer__mset_ptr "buf") in
      let: "$a1" := #"
      %s]" in
      let: "$a2" := ((let: "$sl0" := (interface.make string__mset (![stringT] "indent")) in
      slice.literal interfaceT ["$sl0"])) in
      fmt.Fprintf "$a0" "$a1" "$a2")
    else do:  #());;;
    return: ((bytes.Buffer__String "buf") #())).

(* DescribeMessage returns a concise human-readable description of a
   Message for debugging.

   go: util.go:150:6 *)
Definition DescribeMessage : val :=
  rec: "DescribeMessage" "m" "f" :=
    exception_do (let: "f" := (ref_ty EntryFormatter "f") in
    let: "m" := (ref_ty raftpb.Message "m") in
    return: (let: "$a0" := #"" in
     let: "$a1" := (![raftpb.Message] "m") in
     let: "$a2" := (![EntryFormatter] "f") in
     describeMessageWithIndent "$a0" "$a1" "$a2")).

(* go: raft2.go:185:20 *)
Definition network__send : val :=
  rec: "network__send" "nw" "msgs" :=
    exception_do (let: "nw" := (ref_ty ptrT "nw") in
    let: "msgs" := (ref_ty sliceT "msgs") in
    (for: (λ: <>, int_gt (let: "$a0" := (![sliceT] "msgs") in
    slice.len "$a0") #(W64 0)); (λ: <>, Skip) := λ: <>,
      let: "m" := (ref_ty raftpb.Message (zero_val raftpb.Message)) in
      let: "$r0" := (![raftpb.Message] (slice.elem_ref raftpb.Message (![sliceT] "msgs") #(W64 0))) in
      do:  ("m" <-[raftpb.Message] "$r0");;;
      let: "p" := (ref_ty stateMachine (zero_val stateMachine)) in
      let: "$r0" := (Fst (map.get (![mapT uint64T stateMachine] (struct.field_ref network "peers" (![ptrT] "nw"))) (![uint64T] (struct.field_ref raftpb.Message "To" "m")))) in
      do:  ("p" <-[stateMachine] "$r0");;;
      (if: (![ptrT] (struct.field_ref network "t" (![ptrT] "nw"))) ≠ #null
      then
        do:  (let: "$a0" := ((let: "$sl0" := (interface.make string__mset (let: "$a0" := (![raftpb.Message] "m") in
        let: "$a1" := #func.nil in
        DescribeMessage "$a0" "$a1")) in
        slice.literal interfaceT ["$sl0"])) in
        (testing.common__Log (struct.field_ref testing.T "common" (![ptrT] (struct.field_ref network "t" (![ptrT] "nw"))))) "$a0")
      else do:  #());;;
      let: "$r0" := (let: "$a0" := (![raftpb.Message] "m") in
      (interface.get "Step" (![stateMachine] "p")) "$a0") in
      do:  "$r0";;;
      do:  ((interface.get "advanceMessagesAfterAppend" (![stateMachine] "p")) #());;;
      let: "$r0" := (let: "$a0" := (let: "$s" := (![sliceT] "msgs") in
      slice.slice raftpb.Message "$s" #(W64 1) (slice.len "$s")) in
      let: "$a1" := (let: "$a0" := ((interface.get "readMessages" (![stateMachine] "p")) #()) in
      (network__filter (![ptrT] "nw")) "$a0") in
      (slice.append sliceT) "$a0" "$a1") in
      do:  ("msgs" <-[sliceT] "$r0"))).

Definition network__mset_ptr : list (string * val) := [
  ("filter", network__filter%V);
  ("send", network__send%V)
].

(* go: raft2.go:70:6 *)
Definition idsBySize : val :=
  rec: "idsBySize" "size" :=
    exception_do (let: "size" := (ref_ty intT "size") in
    let: "ids" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (slice.make2 uint64T (![intT] "size")) in
    do:  ("ids" <-[sliceT] "$r0");;;
    (let: "i" := (ref_ty intT (zero_val intT)) in
    let: "$r0" := #(W64 0) in
    do:  ("i" <-[intT] "$r0");;;
    (for: (λ: <>, int_lt (![intT] "i") (![intT] "size")); (λ: <>, do:  ("i" <-[intT] ((![intT] "i") + #(W64 1)))) := λ: <>,
      let: "$r0" := (#(W64 1) + (![intT] "i")) in
      do:  ((slice.elem_ref uint64T (![sliceT] "ids") (![intT] "i")) <-[uint64T] "$r0")));;;
    return: (![sliceT] "ids")).

Definition testMemoryStorageOptions : go_type := funcT.

(* go: raft2.go:78:6 *)
Definition withPeers : val :=
  rec: "withPeers" "peers" :=
    exception_do (let: "peers" := (ref_ty sliceT "peers") in
    return: ((λ: "ms",
       exception_do (let: "ms" := (ref_ty ptrT "ms") in
       let: "$r0" := (![sliceT] "peers") in
       do:  ((struct.field_ref raftpb.ConfState "Voters" (struct.field_ref raftpb.SnapshotMetadata "ConfState" (struct.field_ref raftpb.Snapshot "Metadata" (struct.field_ref MemoryStorage "snapshot" (![ptrT] "ms"))))) <-[sliceT] "$r0"))
       ))).

Definition testMemoryStorageOptions__mset : list (string * val) := [
].

Definition testMemoryStorageOptions__mset_ptr : list (string * val) := [
].

(* go: raft2.go:86:6 *)
Definition newTestMemoryStorage : val :=
  rec: "newTestMemoryStorage" "opts" :=
    exception_do (let: "opts" := (ref_ty sliceT "opts") in
    let: "ms" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (NewMemoryStorage #()) in
    do:  ("ms" <-[ptrT] "$r0");;;
    do:  (let: "$range" := (![sliceT] "opts") in
    slice.for_range testMemoryStorageOptions "$range" (λ: <> "o",
      let: "o" := ref_ty testMemoryStorageOptions "o" in
      do:  (let: "$a0" := (![ptrT] "ms") in
      (![testMemoryStorageOptions] "o") "$a0")));;;
    return: (![ptrT] "ms")).

(* go: raft2.go:130:6 *)
Definition newNetworkWithConfigInit : val :=
  rec: "newNetworkWithConfigInit" "configFunc" "peers" :=
    exception_do (let: "peers" := (ref_ty sliceT "peers") in
    let: "configFunc" := (ref_ty funcT "configFunc") in
    let: "size" := (ref_ty intT (zero_val intT)) in
    let: "$r0" := (let: "$a0" := (![sliceT] "peers") in
    slice.len "$a0") in
    do:  ("size" <-[intT] "$r0");;;
    let: "peerAddrs" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (let: "$a0" := (![intT] "size") in
    idsBySize "$a0") in
    do:  ("peerAddrs" <-[sliceT] "$r0");;;
    let: "npeers" := (ref_ty (mapT uint64T stateMachine) (zero_val (mapT uint64T stateMachine))) in
    let: "$r0" := (map.make uint64T stateMachine #()) in
    do:  ("npeers" <-[mapT uint64T stateMachine] "$r0");;;
    let: "nstorage" := (ref_ty (mapT uint64T ptrT) (zero_val (mapT uint64T ptrT))) in
    let: "$r0" := (map.make uint64T ptrT #()) in
    do:  ("nstorage" <-[mapT uint64T ptrT] "$r0");;;
    do:  (let: "$range" := (![sliceT] "peers") in
    slice.for_range stateMachine "$range" (λ: "j" "p",
      let: "j" := ref_ty uint64T "j" in
      let: "p" := ref_ty stateMachine "p" in
      let: "id" := (ref_ty uint64T (zero_val uint64T)) in
      let: "$r0" := (![uint64T] (slice.elem_ref uint64T (![sliceT] "peerAddrs") (![intT] "j"))) in
      do:  ("id" <-[uint64T] "$r0");;;
      (if: (![stateMachine] "p") = #interface.nil
      then
        let: "$r0" := (let: "$a0" := ((let: "$sl0" := (let: "$a0" := (![sliceT] "peerAddrs") in
        withPeers "$a0") in
        slice.literal testMemoryStorageOptions ["$sl0"])) in
        newTestMemoryStorage "$a0") in
        do:  (map.insert (![mapT uint64T ptrT] "nstorage") (![uint64T] "id") "$r0");;;
        let: "cfg" := (ref_ty ptrT (zero_val ptrT)) in
        let: "$r0" := (let: "$a0" := (![uint64T] "id") in
        let: "$a1" := #(W64 10) in
        let: "$a2" := #(W64 1) in
        let: "$a3" := (interface.make MemoryStorage__mset_ptr (Fst (map.get (![mapT uint64T ptrT] "nstorage") (![uint64T] "id")))) in
        newTestConfig "$a0" "$a1" "$a2" "$a3") in
        do:  ("cfg" <-[ptrT] "$r0");;;
        (if: (![funcT] "configFunc") ≠ #func.nil
        then
          do:  (let: "$a0" := (![ptrT] "cfg") in
          (![funcT] "configFunc") "$a0")
        else do:  #());;;
        let: "sm" := (ref_ty ptrT (zero_val ptrT)) in
        let: "$r0" := (let: "$a0" := (![ptrT] "cfg") in
        newRaft "$a0") in
        do:  ("sm" <-[ptrT] "$r0");;;
        let: "$r0" := (interface.make raft__mset_ptr (![ptrT] "sm")) in
        do:  (map.insert (![mapT uint64T stateMachine] "npeers") (![uint64T] "id") "$r0")
      else
        let: "$r0" := (![stateMachine] "p") in
        do:  (map.insert (![mapT uint64T stateMachine] "npeers") (![uint64T] "id") "$r0"))));;;
    return: (ref_ty network (struct.make network [{
       "peers" ::= ![mapT uint64T stateMachine] "npeers";
       "storage" ::= ![mapT uint64T ptrT] "nstorage";
       "dropm64" ::= map.make connem uint64T #();
       "ignorem" ::= map.make raftpb.MessageType boolT #()
     }]))).

Definition testLeaderElectionStruct : go_type := structT [
  "network" :: ptrT;
  "state" :: StateType;
  "expTerm" :: uint64T
].

Definition testLeaderElectionStruct__mset : list (string * val) := [
].

Definition testLeaderElectionStruct__mset_ptr : list (string * val) := [
].

(* go: raft2.go:203:6 *)
Definition testLeaderElection2 : val :=
  rec: "testLeaderElection2" "t" "preVote" :=
    exception_do (let: "preVote" := (ref_ty boolT "preVote") in
    let: "t" := (ref_ty ptrT "t") in
    let: "cfg" := (ref_ty funcT (zero_val funcT)) in
    let: "candState" := (ref_ty StateType (zero_val StateType)) in
    let: "$r0" := StateCandidate in
    do:  ("candState" <-[StateType] "$r0");;;
    let: "candTerm" := (ref_ty uint64T (zero_val uint64T)) in
    let: "$r0" := #(W64 1) in
    do:  ("candTerm" <-[uint64T] "$r0");;;
    (if: ![boolT] "preVote"
    then
      let: "$r0" := preVoteConfig in
      do:  ("cfg" <-[funcT] "$r0");;;
      let: "$r0" := StatePreCandidate in
      do:  ("candState" <-[StateType] "$r0");;;
      let: "$r0" := #(W64 0) in
      do:  ("candTerm" <-[uint64T] "$r0")
    else do:  #());;;
    let: "nopStepper" := (ref_ty ptrT (zero_val ptrT)) in
    let: "$r0" := (ref_ty blackHole (struct.make blackHole [{
    }])) in
    do:  ("nopStepper" <-[ptrT] "$r0");;;
    let: "tests" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := ((let: "$sl0" := (struct.make testLeaderElectionStruct [{
      "network" ::= let: "$a0" := (![funcT] "cfg") in
      let: "$a1" := ((let: "$sl0" := #interface.nil in
      let: "$sl1" := #interface.nil in
      let: "$sl2" := #interface.nil in
      slice.literal stateMachine ["$sl0"; "$sl1"; "$sl2"])) in
      newNetworkWithConfigInit "$a0" "$a1";
      "state" ::= StateLeader;
      "expTerm" ::= #(W64 1)
    }]) in
    let: "$sl1" := (struct.make testLeaderElectionStruct [{
      "network" ::= let: "$a0" := (![funcT] "cfg") in
      let: "$a1" := ((let: "$sl0" := #interface.nil in
      let: "$sl1" := #interface.nil in
      let: "$sl2" := (interface.make blackHole__mset_ptr (![ptrT] "nopStepper")) in
      slice.literal stateMachine ["$sl0"; "$sl1"; "$sl2"])) in
      newNetworkWithConfigInit "$a0" "$a1";
      "state" ::= StateLeader;
      "expTerm" ::= #(W64 1)
    }]) in
    let: "$sl2" := (struct.make testLeaderElectionStruct [{
      "network" ::= let: "$a0" := (![funcT] "cfg") in
      let: "$a1" := ((let: "$sl0" := #interface.nil in
      let: "$sl1" := (interface.make blackHole__mset_ptr (![ptrT] "nopStepper")) in
      let: "$sl2" := (interface.make blackHole__mset_ptr (![ptrT] "nopStepper")) in
      slice.literal stateMachine ["$sl0"; "$sl1"; "$sl2"])) in
      newNetworkWithConfigInit "$a0" "$a1";
      "state" ::= ![StateType] "candState";
      "expTerm" ::= ![uint64T] "candTerm"
    }]) in
    let: "$sl3" := (struct.make testLeaderElectionStruct [{
      "network" ::= let: "$a0" := (![funcT] "cfg") in
      let: "$a1" := ((let: "$sl0" := #interface.nil in
      let: "$sl1" := (interface.make blackHole__mset_ptr (![ptrT] "nopStepper")) in
      let: "$sl2" := (interface.make blackHole__mset_ptr (![ptrT] "nopStepper")) in
      let: "$sl3" := #interface.nil in
      slice.literal stateMachine ["$sl0"; "$sl1"; "$sl2"; "$sl3"])) in
      newNetworkWithConfigInit "$a0" "$a1";
      "state" ::= ![StateType] "candState";
      "expTerm" ::= ![uint64T] "candTerm"
    }]) in
    let: "$sl4" := (struct.make testLeaderElectionStruct [{
      "network" ::= let: "$a0" := (![funcT] "cfg") in
      let: "$a1" := ((let: "$sl0" := #interface.nil in
      let: "$sl1" := (interface.make blackHole__mset_ptr (![ptrT] "nopStepper")) in
      let: "$sl2" := (interface.make blackHole__mset_ptr (![ptrT] "nopStepper")) in
      let: "$sl3" := #interface.nil in
      let: "$sl4" := #interface.nil in
      slice.literal stateMachine ["$sl0"; "$sl1"; "$sl2"; "$sl3"; "$sl4"])) in
      newNetworkWithConfigInit "$a0" "$a1";
      "state" ::= StateLeader;
      "expTerm" ::= #(W64 1)
    }]) in
    let: "$sl5" := (struct.make testLeaderElectionStruct [{
      "network" ::= let: "$a0" := (![funcT] "cfg") in
      let: "$a1" := ((let: "$sl0" := #interface.nil in
      let: "$sl1" := (interface.make raft__mset_ptr (let: "$a0" := (![funcT] "cfg") in
      let: "$a1" := ((let: "$sl0" := #(W64 1) in
      slice.literal uint64T ["$sl0"])) in
      entsWithConfig "$a0" "$a1")) in
      let: "$sl2" := (interface.make raft__mset_ptr (let: "$a0" := (![funcT] "cfg") in
      let: "$a1" := ((let: "$sl0" := #(W64 1) in
      slice.literal uint64T ["$sl0"])) in
      entsWithConfig "$a0" "$a1")) in
      let: "$sl3" := (interface.make raft__mset_ptr (let: "$a0" := (![funcT] "cfg") in
      let: "$a1" := ((let: "$sl0" := #(W64 1) in
      let: "$sl1" := #(W64 1) in
      slice.literal uint64T ["$sl0"; "$sl1"])) in
      entsWithConfig "$a0" "$a1")) in
      let: "$sl4" := #interface.nil in
      slice.literal stateMachine ["$sl0"; "$sl1"; "$sl2"; "$sl3"; "$sl4"])) in
      newNetworkWithConfigInit "$a0" "$a1";
      "state" ::= StateFollower;
      "expTerm" ::= #(W64 1)
    }]) in
    slice.literal testLeaderElectionStruct ["$sl0"; "$sl1"; "$sl2"; "$sl3"; "$sl4"; "$sl5"])) in
    do:  ("tests" <-[sliceT] "$r0");;;
    do:  (let: "$range" := (![sliceT] "tests") in
    slice.for_range testLeaderElectionStruct "$range" (λ: "i" "tt",
      let: "i" := ref_ty uint64T "i" in
      let: "tt" := ref_ty testLeaderElectionStruct "tt" in
      do:  (let: "$a0" := ((let: "$sl0" := (struct.make raftpb.Message [{
        "From" ::= #(W64 1);
        "To" ::= #(W64 1);
        "Type" ::= raftpb.MsgHup
      }]) in
      slice.literal raftpb.Message ["$sl0"])) in
      (network__send (![ptrT] (struct.field_ref testLeaderElectionStruct "network" "tt"))) "$a0");;;
      let: "sm" := (ref_ty ptrT (zero_val ptrT)) in
      let: "$r0" := (Fst (map.get (![mapT uint64T stateMachine] (struct.field_ref network "peers" (![ptrT] (struct.field_ref testLeaderElectionStruct "network" "tt")))) #(W64 1))) in
      do:  ("sm" <-[ptrT] "$r0");;;
      do:  (let: "$a0" := (interface.make testing.T__mset_ptr (![ptrT] "t")) in
      let: "$a1" := (interface.make StateType__mset (![StateType] (struct.field_ref testLeaderElectionStruct "state" "tt"))) in
      let: "$a2" := (interface.make StateType__mset (![StateType] (struct.field_ref raft "state" (![ptrT] "sm")))) in
      let: "$a3" := ((let: "$sl0" := (interface.make string__mset #"#%d") in
      let: "$sl1" := (interface.make int__mset (![intT] "i")) in
      slice.literal interfaceT ["$sl0"; "$sl1"])) in
      assert.Equal "$a0" "$a1" "$a2" "$a3");;;
      do:  (let: "$a0" := (interface.make testing.T__mset_ptr (![ptrT] "t")) in
      let: "$a1" := (interface.make uint64__mset (![uint64T] (struct.field_ref testLeaderElectionStruct "expTerm" "tt"))) in
      let: "$a2" := (interface.make uint64__mset (![uint64T] (struct.field_ref raft "Term" (![ptrT] "sm")))) in
      let: "$a3" := ((let: "$sl0" := (interface.make string__mset #"#%d") in
      let: "$sl1" := (interface.make int__mset (![intT] "i")) in
      slice.literal interfaceT ["$sl0"; "$sl1"])) in
      assert.Equal "$a0" "$a1" "$a2" "$a3")))).

Definition RawNode__mset : list (string * val) := [
].

(* ApplyConfChange applies a config change to the local node. The app must call
   this when it applies a configuration change, except when it decides to reject
   the configuration change, in which case no call must take place.

   go: rawnode.go:112:20 *)
Definition RawNode__ApplyConfChange : val :=
  rec: "RawNode__ApplyConfChange" "rn" "cc" :=
    exception_do (let: "rn" := (ref_ty ptrT "rn") in
    let: "cc" := (ref_ty raftpb.ConfChangeI "cc") in
    let: "cs" := (ref_ty raftpb.ConfState (zero_val raftpb.ConfState)) in
    let: "$r0" := (let: "$a0" := ((interface.get "AsV2" (![raftpb.ConfChangeI] "cc")) #()) in
    (raft__applyConfChange (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))) "$a0") in
    do:  ("cs" <-[raftpb.ConfState] "$r0");;;
    return: ("cs")).

(* BasicStatus returns a BasicStatus. Notably this does not contain the
   Progress map; see WithProgress for an allocation-free way to inspect it.

   go: rawnode.go:505:20 *)
Definition RawNode__BasicStatus : val :=
  rec: "RawNode__BasicStatus" "rn" <> :=
    exception_do (let: "rn" := (ref_ty ptrT "rn") in
    return: (let: "$a0" := (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn"))) in
     getBasicStatus "$a0")).

(* Campaign causes this RawNode to transition to candidate state.

   go: rawnode.go:83:20 *)
Definition RawNode__Campaign : val :=
  rec: "RawNode__Campaign" "rn" <> :=
    exception_do (let: "rn" := (ref_ty ptrT "rn") in
    return: (let: "$a0" := (struct.make raftpb.Message [{
       "Type" ::= raftpb.MsgHup
     }]) in
     (raft__Step (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))) "$a0")).

(* ForgetLeader forgets a follower's current leader, changing it to None.
   See (Node).ForgetLeader for details.

   go: rawnode.go:552:20 *)
Definition RawNode__ForgetLeader : val :=
  rec: "RawNode__ForgetLeader" "rn" <> :=
    exception_do (let: "rn" := (ref_ty ptrT "rn") in
    return: (let: "$a0" := (struct.make raftpb.Message [{
       "Type" ::= raftpb.MsgForgetLeader
     }]) in
     (raft__Step (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))) "$a0")).

(* Propose proposes data be appended to the raft log.

   go: rawnode.go:90:20 *)
Definition RawNode__Propose : val :=
  rec: "RawNode__Propose" "rn" "data" :=
    exception_do (let: "rn" := (ref_ty ptrT "rn") in
    let: "data" := (ref_ty sliceT "data") in
    return: (let: "$a0" := (struct.make raftpb.Message [{
       "Type" ::= raftpb.MsgProp;
       "From" ::= ![uint64T] (struct.field_ref raft "id" (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn"))));
       "Entries" ::= (let: "$sl0" := (struct.make raftpb.Entry [{
         "Data" ::= ![sliceT] "data"
       }]) in
       slice.literal raftpb.Entry ["$sl0"])
     }]) in
     (raft__Step (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))) "$a0")).

(* ProposeConfChange proposes a config change. See (Node).ProposeConfChange for
   details.

   go: rawnode.go:101:20 *)
Definition RawNode__ProposeConfChange : val :=
  rec: "RawNode__ProposeConfChange" "rn" "cc" :=
    exception_do (let: "rn" := (ref_ty ptrT "rn") in
    let: "cc" := (ref_ty raftpb.ConfChangeI "cc") in
    let: "err" := (ref_ty error (zero_val error)) in
    let: "m" := (ref_ty raftpb.Message (zero_val raftpb.Message)) in
    let: ("$ret0", "$ret1") := (let: "$a0" := (![raftpb.ConfChangeI] "cc") in
    confChangeToMsg "$a0") in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("m" <-[raftpb.Message] "$r0");;;
    do:  ("err" <-[error] "$r1");;;
    (if: (![error] "err") ≠ #interface.nil
    then return: (![error] "err")
    else do:  #());;;
    return: (let: "$a0" := (![raftpb.Message] "m") in
     (raft__Step (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))) "$a0")).

(* ReadIndex requests a read state. The read state will be set in ready.
   Read State has a read index. Once the application advances further than the read
   index, any linearizable read requests issued before the read request can be
   processed safely. The read state will have the same rctx attached.

   go: rawnode.go:560:20 *)
Definition RawNode__ReadIndex : val :=
  rec: "RawNode__ReadIndex" "rn" "rctx" :=
    exception_do (let: "rn" := (ref_ty ptrT "rn") in
    let: "rctx" := (ref_ty sliceT "rctx") in
    let: "$r0" := (let: "$a0" := (struct.make raftpb.Message [{
      "Type" ::= raftpb.MsgReadIndex;
      "Entries" ::= (let: "$sl0" := (struct.make raftpb.Entry [{
        "Data" ::= ![sliceT] "rctx"
      }]) in
      slice.literal raftpb.Entry ["$sl0"])
    }]) in
    (raft__Step (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))) "$a0") in
    do:  "$r0").

(* Ready returns the outstanding work that the application needs to handle. This
   includes appending and applying entries or a snapshot, updating the HardState,
   and sending messages. The returned Ready() *must* be handled and subsequently
   passed back via Advance().

   go: rawnode.go:133:20 *)
Definition RawNode__Ready : val :=
  rec: "RawNode__Ready" "rn" <> :=
    exception_do (let: "rn" := (ref_ty ptrT "rn") in
    let: "rd" := (ref_ty Ready (zero_val Ready)) in
    let: "$r0" := ((RawNode__readyWithoutAccept (![ptrT] "rn")) #()) in
    do:  ("rd" <-[Ready] "$r0");;;
    do:  (let: "$a0" := (![Ready] "rd") in
    (RawNode__acceptReady (![ptrT] "rn")) "$a0");;;
    return: (![Ready] "rd")).

(* ReportSnapshot reports the status of the sent snapshot.

   go: rawnode.go:539:20 *)
Definition RawNode__ReportSnapshot : val :=
  rec: "RawNode__ReportSnapshot" "rn" "id" "status" :=
    exception_do (let: "rn" := (ref_ty ptrT "rn") in
    let: "status" := (ref_ty SnapshotStatus "status") in
    let: "id" := (ref_ty uint64T "id") in
    let: "rej" := (ref_ty boolT (zero_val boolT)) in
    let: "$r0" := ((![SnapshotStatus] "status") = SnapshotFailure) in
    do:  ("rej" <-[boolT] "$r0");;;
    let: "$r0" := (let: "$a0" := (struct.make raftpb.Message [{
      "Type" ::= raftpb.MsgSnapStatus;
      "From" ::= ![uint64T] "id";
      "Reject" ::= ![boolT] "rej"
    }]) in
    (raft__Step (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))) "$a0") in
    do:  "$r0").

(* ReportUnreachable reports the given node is not reachable for the last send.

   go: rawnode.go:534:20 *)
Definition RawNode__ReportUnreachable : val :=
  rec: "RawNode__ReportUnreachable" "rn" "id" :=
    exception_do (let: "rn" := (ref_ty ptrT "rn") in
    let: "id" := (ref_ty uint64T "id") in
    let: "$r0" := (let: "$a0" := (struct.make raftpb.Message [{
      "Type" ::= raftpb.MsgUnreachable;
      "From" ::= ![uint64T] "id"
    }]) in
    (raft__Step (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))) "$a0") in
    do:  "$r0").

(* Status returns the current status of the given group. This allocates, see
   BasicStatus and WithProgress for allocation-friendlier choices.

   go: rawnode.go:498:20 *)
Definition RawNode__Status : val :=
  rec: "RawNode__Status" "rn" <> :=
    exception_do (let: "rn" := (ref_ty ptrT "rn") in
    let: "status" := (ref_ty Status (zero_val Status)) in
    let: "$r0" := (let: "$a0" := (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn"))) in
    getStatus "$a0") in
    do:  ("status" <-[Status] "$r0");;;
    return: (![Status] "status")).

(* Step advances the state machine using the given message.

   go: rawnode.go:118:20 *)
Definition RawNode__Step : val :=
  rec: "RawNode__Step" "rn" "m" :=
    exception_do (let: "rn" := (ref_ty ptrT "rn") in
    let: "m" := (ref_ty raftpb.Message "m") in
    (if: (let: "$a0" := (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) in
    IsLocalMsg "$a0") && (~ (let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "From" "m")) in
    IsLocalMsgTarget "$a0"))
    then return: (![error] "ErrStepLocalMsg")
    else do:  #());;;
    (if: ((let: "$a0" := (![raftpb.MessageType] (struct.field_ref raftpb.Message "Type" "m")) in
    IsResponseMsg "$a0") && (~ (let: "$a0" := (![uint64T] (struct.field_ref raftpb.Message "From" "m")) in
    IsLocalMsgTarget "$a0"))) && ((Fst (map.get (![tracker.ProgressMap] (struct.field_ref tracker.ProgressTracker "Progress" (struct.field_ref raft "trk" (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))))) (![uint64T] (struct.field_ref raftpb.Message "From" "m")))) = #null)
    then return: (![error] "ErrStepPeerNotFound")
    else do:  #());;;
    return: (let: "$a0" := (![raftpb.Message] "m") in
     (raft__Step (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))) "$a0")).

(* TickQuiesced advances the internal logical clock by a single tick without
   performing any other state machine processing. It allows the caller to avoid
   periodic heartbeats and elections when all of the peers in a Raft group are
   known to be at the same state. Expected usage is to periodically invoke Tick
   or TickQuiesced depending on whether the group is "active" or "quiesced".

   WARNING: Be very careful about using this method as it subverts the Raft
   state machine. You should probably be using Tick instead.

   DEPRECATED: This method will be removed in a future release.

   go: rawnode.go:78:20 *)
Definition RawNode__TickQuiesced : val :=
  rec: "RawNode__TickQuiesced" "rn" <> :=
    exception_do (let: "rn" := (ref_ty ptrT "rn") in
    do:  ((struct.field_ref raft "electionElapsed" (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))) <-[intT] ((![intT] (struct.field_ref raft "electionElapsed" (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn"))))) + #(W64 1)))).

(* TransferLeader tries to transfer leadership to the given transferee.

   go: rawnode.go:546:20 *)
Definition RawNode__TransferLeader : val :=
  rec: "RawNode__TransferLeader" "rn" "transferee" :=
    exception_do (let: "rn" := (ref_ty ptrT "rn") in
    let: "transferee" := (ref_ty uint64T "transferee") in
    let: "$r0" := (let: "$a0" := (struct.make raftpb.Message [{
      "Type" ::= raftpb.MsgTransferLeader;
      "From" ::= ![uint64T] "transferee"
    }]) in
    (raft__Step (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn")))) "$a0") in
    do:  "$r0").

Definition ProgressType : go_type := byteT.

Definition ProgressTypeLearner : expr := #(W8 1).

Definition ProgressTypePeer : expr := #(W8 0).

(* WithProgress is a helper to introspect the Progress for this node and its
   peers.

   go: rawnode.go:521:20 *)
Definition RawNode__WithProgress : val :=
  rec: "RawNode__WithProgress" "rn" "visitor" :=
    exception_do (let: "rn" := (ref_ty ptrT "rn") in
    let: "visitor" := (ref_ty funcT "visitor") in
    do:  (let: "$a0" := (λ: "id" "pr",
      exception_do (let: "pr" := (ref_ty ptrT "pr") in
      let: "id" := (ref_ty uint64T "id") in
      let: "typ" := (ref_ty ProgressType (zero_val ProgressType)) in
      let: "$r0" := ProgressTypePeer in
      do:  ("typ" <-[ProgressType] "$r0");;;
      (if: ![boolT] (struct.field_ref tracker.Progress "IsLearner" (![ptrT] "pr"))
      then
        let: "$r0" := ProgressTypeLearner in
        do:  ("typ" <-[ProgressType] "$r0")
      else do:  #());;;
      let: "p" := (ref_ty tracker.Progress (zero_val tracker.Progress)) in
      let: "$r0" := (![tracker.Progress] (![ptrT] "pr")) in
      do:  ("p" <-[tracker.Progress] "$r0");;;
      let: "$r0" := #null in
      do:  ((struct.field_ref tracker.Progress "Inflights" "p") <-[ptrT] "$r0");;;
      do:  (let: "$a0" := (![uint64T] "id") in
      let: "$a1" := (![ProgressType] "typ") in
      let: "$a2" := (![tracker.Progress] "p") in
      (![funcT] "visitor") "$a0" "$a1" "$a2"))
      ) in
    (tracker.ProgressTracker__Visit (struct.field_ref raft "trk" (![ptrT] (struct.field_ref RawNode "raft" (![ptrT] "rn"))))) "$a0")).

Definition RawNode__mset_ptr : list (string * val) := [
  ("Advance", RawNode__Advance%V);
  ("ApplyConfChange", RawNode__ApplyConfChange%V);
  ("BasicStatus", RawNode__BasicStatus%V);
  ("Bootstrap", RawNode__Bootstrap%V);
  ("Campaign", RawNode__Campaign%V);
  ("ForgetLeader", RawNode__ForgetLeader%V);
  ("HasReady", RawNode__HasReady%V);
  ("Propose", RawNode__Propose%V);
  ("ProposeConfChange", RawNode__ProposeConfChange%V);
  ("ReadIndex", RawNode__ReadIndex%V);
  ("Ready", RawNode__Ready%V);
  ("ReportSnapshot", RawNode__ReportSnapshot%V);
  ("ReportUnreachable", RawNode__ReportUnreachable%V);
  ("Status", RawNode__Status%V);
  ("Step", RawNode__Step%V);
  ("Tick", RawNode__Tick%V);
  ("TickQuiesced", RawNode__TickQuiesced%V);
  ("TransferLeader", RawNode__TransferLeader%V);
  ("WithProgress", RawNode__WithProgress%V);
  ("acceptReady", RawNode__acceptReady%V);
  ("applyUnstableEntries", RawNode__applyUnstableEntries%V);
  ("readyWithoutAccept", RawNode__readyWithoutAccept%V)
].

Definition ProgressType__mset : list (string * val) := [
].

Definition ProgressType__mset_ptr : list (string * val) := [
].

Definition ReadState__mset : list (string * val) := [
].

Definition ReadState__mset_ptr : list (string * val) := [
].

Definition readIndexStatus__mset : list (string * val) := [
].

Definition readIndexStatus__mset_ptr : list (string * val) := [
].

Definition readOnly__mset : list (string * val) := [
].

Definition readOnly__mset_ptr : list (string * val) := [
  ("addRequest", readOnly__addRequest%V);
  ("advance", readOnly__advance%V);
  ("lastPendingRequestCtx", readOnly__lastPendingRequestCtx%V);
  ("recvAck", readOnly__recvAck%V)
].

Definition StateTraceDeployed : expr := #false.

Definition TracingEvent : go_type := structT [
].

Definition TracingEvent__mset : list (string * val) := [
].

Definition TracingEvent__mset_ptr : list (string * val) := [
].

(* MarshalJSON translates the raft status into JSON.
   TODO: try to simplify this by introducing ID type into raft

   go: status.go:80:17 *)
Definition Status__MarshalJSON : val :=
  rec: "Status__MarshalJSON" "s" <> :=
    exception_do (let: "s" := (ref_ty Status "s") in
    let: "j" := (ref_ty stringT (zero_val stringT)) in
    let: "$r0" := (let: "$a0" := #"{""id"":""%x"",""term"":%d,""vote"":""%x"",""commit"":%d,""lead"":""%x"",""raftState"":%q,""applied"":%d,""progress"":{" in
    let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref BasicStatus "ID" (struct.field_ref Status "BasicStatus" "s")))) in
    let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.HardState "Term" (struct.field_ref BasicStatus "HardState" (struct.field_ref Status "BasicStatus" "s"))))) in
    let: "$sl2" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.HardState "Vote" (struct.field_ref BasicStatus "HardState" (struct.field_ref Status "BasicStatus" "s"))))) in
    let: "$sl3" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.HardState "Commit" (struct.field_ref BasicStatus "HardState" (struct.field_ref Status "BasicStatus" "s"))))) in
    let: "$sl4" := (interface.make uint64__mset (![uint64T] (struct.field_ref SoftState "Lead" (struct.field_ref BasicStatus "SoftState" (struct.field_ref Status "BasicStatus" "s"))))) in
    let: "$sl5" := (interface.make StateType__mset (![StateType] (struct.field_ref SoftState "RaftState" (struct.field_ref BasicStatus "SoftState" (struct.field_ref Status "BasicStatus" "s"))))) in
    let: "$sl6" := (interface.make uint64__mset (![uint64T] (struct.field_ref BasicStatus "Applied" (struct.field_ref Status "BasicStatus" "s")))) in
    slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"; "$sl4"; "$sl5"; "$sl6"])) in
    fmt.Sprintf "$a0" "$a1") in
    do:  ("j" <-[stringT] "$r0");;;
    (if: (let: "$a0" := (![mapT uint64T tracker.Progress] (struct.field_ref Status "Progress" "s")) in
    map.len "$a0") = #(W64 0)
    then do:  ("j" <-[stringT] ((![stringT] "j") + #"},"))
    else
      do:  (map.for_range (![mapT uint64T tracker.Progress] (struct.field_ref Status "Progress" "s")) (λ: "k" "v",
        let: "subj" := (ref_ty stringT (zero_val stringT)) in
        let: "$r0" := (let: "$a0" := #"""%x"":{""match"":%d,""next"":%d,""state"":%q}," in
        let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] "k")) in
        let: "$sl1" := (interface.make uint64__mset (![uint64T] (struct.field_ref tracker.Progress "Match" "v"))) in
        let: "$sl2" := (interface.make uint64__mset (![uint64T] (struct.field_ref tracker.Progress "Next" "v"))) in
        let: "$sl3" := (interface.make tracker.StateType__mset (![tracker.StateType] (struct.field_ref tracker.Progress "State" "v"))) in
        slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"; "$sl3"])) in
        fmt.Sprintf "$a0" "$a1") in
        do:  ("subj" <-[stringT] "$r0");;;
        do:  ("j" <-[stringT] ((![stringT] "j") + (![stringT] "subj")))));;;
      let: "$r0" := ((string.from_bytes (let: "$s" := (string.to_bytes (![stringT] "j")) in
      slice.slice byteT "$s" #(W64 0) ((let: "$a0" := (![stringT] "j") in
      StringLength "$a0") - #(W64 1)))) + #"},") in
      do:  ("j" <-[stringT] "$r0"));;;
    do:  ("j" <-[stringT] ((![stringT] "j") + (let: "$a0" := #"""leadtransferee"":""%x""}" in
    let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref BasicStatus "LeadTransferee" (struct.field_ref Status "BasicStatus" "s")))) in
    slice.literal interfaceT ["$sl0"])) in
    fmt.Sprintf "$a0" "$a1")));;;
    return: (string.to_bytes (![stringT] "j"), #interface.nil)).

(* go: status.go:99:17 *)
Definition Status__String : val :=
  rec: "Status__String" "s" <> :=
    exception_do (let: "s" := (ref_ty Status "s") in
    let: "err" := (ref_ty error (zero_val error)) in
    let: "b" := (ref_ty sliceT (zero_val sliceT)) in
    let: ("$ret0", "$ret1") := ((Status__MarshalJSON (![Status] "s")) #()) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("b" <-[sliceT] "$r0");;;
    do:  ("err" <-[error] "$r1");;;
    (if: (![error] "err") ≠ #interface.nil
    then
      do:  (let: "$a0" := #"unexpected error: %v" in
      let: "$a1" := ((let: "$sl0" := (![error] "err") in
      slice.literal interfaceT ["$sl0"])) in
      (interface.get "Panicf" (getLogger #())) "$a0" "$a1")
    else do:  #());;;
    return: (string.from_bytes (![sliceT] "b"))).

Definition Status__mset : list (string * val) := [
  ("MarshalJSON", Status__MarshalJSON%V);
  ("String", Status__String%V)
].

Definition Status__mset_ptr : list (string * val) := [
  ("Descriptor", (λ: "$recvAddr",
    raftpb.HardState__Descriptor (struct.field_ref BasicStatus "HardState" (struct.field_ref Status "BasicStatus" "$recvAddr"))
    )%V);
  ("Marshal", (λ: "$recvAddr",
    raftpb.HardState__Marshal (struct.field_ref BasicStatus "HardState" (struct.field_ref Status "BasicStatus" "$recvAddr"))
    )%V);
  ("MarshalJSON", (λ: "$recvAddr",
    Status__MarshalJSON (![Status] "$recvAddr")
    )%V);
  ("MarshalTo", (λ: "$recvAddr",
    raftpb.HardState__MarshalTo (struct.field_ref BasicStatus "HardState" (struct.field_ref Status "BasicStatus" "$recvAddr"))
    )%V);
  ("MarshalToSizedBuffer", (λ: "$recvAddr",
    raftpb.HardState__MarshalToSizedBuffer (struct.field_ref BasicStatus "HardState" (struct.field_ref Status "BasicStatus" "$recvAddr"))
    )%V);
  ("ProtoMessage", (λ: "$recvAddr",
    raftpb.HardState__ProtoMessage (struct.field_ref BasicStatus "HardState" (struct.field_ref Status "BasicStatus" "$recvAddr"))
    )%V);
  ("Reset", (λ: "$recvAddr",
    raftpb.HardState__Reset (struct.field_ref BasicStatus "HardState" (struct.field_ref Status "BasicStatus" "$recvAddr"))
    )%V);
  ("Size", (λ: "$recvAddr",
    raftpb.HardState__Size (struct.field_ref BasicStatus "HardState" (struct.field_ref Status "BasicStatus" "$recvAddr"))
    )%V);
  ("String", (λ: "$recvAddr",
    Status__String (![Status] "$recvAddr")
    )%V);
  ("Unmarshal", (λ: "$recvAddr",
    raftpb.HardState__Unmarshal (struct.field_ref BasicStatus "HardState" (struct.field_ref Status "BasicStatus" "$recvAddr"))
    )%V);
  ("XXX_DiscardUnknown", (λ: "$recvAddr",
    raftpb.HardState__XXX_DiscardUnknown (struct.field_ref BasicStatus "HardState" (struct.field_ref Status "BasicStatus" "$recvAddr"))
    )%V);
  ("XXX_Marshal", (λ: "$recvAddr",
    raftpb.HardState__XXX_Marshal (struct.field_ref BasicStatus "HardState" (struct.field_ref Status "BasicStatus" "$recvAddr"))
    )%V);
  ("XXX_Merge", (λ: "$recvAddr",
    raftpb.HardState__XXX_Merge (struct.field_ref BasicStatus "HardState" (struct.field_ref Status "BasicStatus" "$recvAddr"))
    )%V);
  ("XXX_Size", (λ: "$recvAddr",
    raftpb.HardState__XXX_Size (struct.field_ref BasicStatus "HardState" (struct.field_ref Status "BasicStatus" "$recvAddr"))
    )%V);
  ("XXX_Unmarshal", (λ: "$recvAddr",
    raftpb.HardState__XXX_Unmarshal (struct.field_ref BasicStatus "HardState" (struct.field_ref Status "BasicStatus" "$recvAddr"))
    )%V)
].

Definition BasicStatus__mset : list (string * val) := [
].

Definition BasicStatus__mset_ptr : list (string * val) := [
  ("Descriptor", (λ: "$recvAddr",
    raftpb.HardState__Descriptor (struct.field_ref BasicStatus "HardState" "$recvAddr")
    )%V);
  ("Marshal", (λ: "$recvAddr",
    raftpb.HardState__Marshal (struct.field_ref BasicStatus "HardState" "$recvAddr")
    )%V);
  ("MarshalTo", (λ: "$recvAddr",
    raftpb.HardState__MarshalTo (struct.field_ref BasicStatus "HardState" "$recvAddr")
    )%V);
  ("MarshalToSizedBuffer", (λ: "$recvAddr",
    raftpb.HardState__MarshalToSizedBuffer (struct.field_ref BasicStatus "HardState" "$recvAddr")
    )%V);
  ("ProtoMessage", (λ: "$recvAddr",
    raftpb.HardState__ProtoMessage (struct.field_ref BasicStatus "HardState" "$recvAddr")
    )%V);
  ("Reset", (λ: "$recvAddr",
    raftpb.HardState__Reset (struct.field_ref BasicStatus "HardState" "$recvAddr")
    )%V);
  ("Size", (λ: "$recvAddr",
    raftpb.HardState__Size (struct.field_ref BasicStatus "HardState" "$recvAddr")
    )%V);
  ("String", (λ: "$recvAddr",
    raftpb.HardState__String (struct.field_ref BasicStatus "HardState" "$recvAddr")
    )%V);
  ("Unmarshal", (λ: "$recvAddr",
    raftpb.HardState__Unmarshal (struct.field_ref BasicStatus "HardState" "$recvAddr")
    )%V);
  ("XXX_DiscardUnknown", (λ: "$recvAddr",
    raftpb.HardState__XXX_DiscardUnknown (struct.field_ref BasicStatus "HardState" "$recvAddr")
    )%V);
  ("XXX_Marshal", (λ: "$recvAddr",
    raftpb.HardState__XXX_Marshal (struct.field_ref BasicStatus "HardState" "$recvAddr")
    )%V);
  ("XXX_Merge", (λ: "$recvAddr",
    raftpb.HardState__XXX_Merge (struct.field_ref BasicStatus "HardState" "$recvAddr")
    )%V);
  ("XXX_Size", (λ: "$recvAddr",
    raftpb.HardState__XXX_Size (struct.field_ref BasicStatus "HardState" "$recvAddr")
    )%V);
  ("XXX_Unmarshal", (λ: "$recvAddr",
    raftpb.HardState__XXX_Unmarshal (struct.field_ref BasicStatus "HardState" "$recvAddr")
    )%V)
].

Definition inMemStorageCallStats__mset : list (string * val) := [
].

Definition inMemStorageCallStats__mset_ptr : list (string * val) := [
].

Definition MemoryStorage__mset : list (string * val) := [
].

Definition entryID__mset : list (string * val) := [
].

Definition entryID__mset_ptr : list (string * val) := [
].

(* lastEntryID returns the ID of the last entry in this log slice, or prev if
   there are no entries.

   go: types.go:84:19 *)
Definition logSlice__lastEntryID : val :=
  rec: "logSlice__lastEntryID" "s" <> :=
    exception_do (let: "s" := (ref_ty logSlice "s") in
    (let: "ln" := (ref_ty intT (zero_val intT)) in
    let: "$r0" := (let: "$a0" := (![sliceT] (struct.field_ref logSlice "entries" "s")) in
    slice.len "$a0") in
    do:  ("ln" <-[intT] "$r0");;;
    (if: (![intT] "ln") ≠ #(W64 0)
    then
      return: (let: "$a0" := (slice.elem_ref raftpb.Entry (![sliceT] (struct.field_ref logSlice "entries" "s")) ((![intT] "ln") - #(W64 1))) in
       pbEntryID "$a0")
    else do:  #()));;;
    return: (![entryID] (struct.field_ref logSlice "prev" "s"))).

(* lastIndex returns the index of the last entry in this log slice. Returns
   prev.index if there are no entries.

   go: types.go:78:19 *)
Definition logSlice__lastIndex : val :=
  rec: "logSlice__lastIndex" "s" <> :=
    exception_do (let: "s" := (ref_ty logSlice "s") in
    return: ((![uint64T] (struct.field_ref entryID "index" (struct.field_ref logSlice "prev" "s"))) + (let: "$a0" := (![sliceT] (struct.field_ref logSlice "entries" "s")) in
     slice.len "$a0"))).

(* valid returns nil iff the logSlice is a well-formed log slice. See logSlice
   comment for details on what constitutes a valid raft log slice.

   go: types.go:93:19 *)
Definition logSlice__valid : val :=
  rec: "logSlice__valid" "s" <> :=
    exception_do (let: "s" := (ref_ty logSlice "s") in
    let: "prev" := (ref_ty entryID (zero_val entryID)) in
    let: "$r0" := (![entryID] (struct.field_ref logSlice "prev" "s")) in
    do:  ("prev" <-[entryID] "$r0");;;
    do:  (let: "$range" := (![sliceT] (struct.field_ref logSlice "entries" "s")) in
    slice.for_range raftpb.Entry "$range" (λ: "i" <>,
      let: "i" := ref_ty uint64T "i" in
      let: "id" := (ref_ty entryID (zero_val entryID)) in
      let: "$r0" := (let: "$a0" := (slice.elem_ref raftpb.Entry (![sliceT] (struct.field_ref logSlice "entries" "s")) (![intT] "i")) in
      pbEntryID "$a0") in
      do:  ("id" <-[entryID] "$r0");;;
      (if: ((![uint64T] (struct.field_ref entryID "term" "id")) < (![uint64T] (struct.field_ref entryID "term" "prev"))) || ((![uint64T] (struct.field_ref entryID "index" "id")) ≠ ((![uint64T] (struct.field_ref entryID "index" "prev")) + #(W64 1)))
      then
        return: (let: "$a0" := #"leader term %d: entries %+v and %+v not consistent" in
         let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref logSlice "term" "s"))) in
         let: "$sl1" := (interface.make entryID__mset (![entryID] "prev")) in
         let: "$sl2" := (interface.make entryID__mset (![entryID] "id")) in
         slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
         fmt.Errorf "$a0" "$a1")
      else do:  #());;;
      let: "$r0" := (![entryID] "id") in
      do:  ("prev" <-[entryID] "$r0")));;;
    (if: (![uint64T] (struct.field_ref logSlice "term" "s")) < (![uint64T] (struct.field_ref entryID "term" "prev"))
    then
      return: (let: "$a0" := #"leader term %d: entry %+v has a newer term" in
       let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref logSlice "term" "s"))) in
       let: "$sl1" := (interface.make entryID__mset (![entryID] "prev")) in
       slice.literal interfaceT ["$sl0"; "$sl1"])) in
       fmt.Errorf "$a0" "$a1")
    else do:  #());;;
    return: (#interface.nil)).

Definition logSlice__mset : list (string * val) := [
  ("lastEntryID", logSlice__lastEntryID%V);
  ("lastIndex", logSlice__lastIndex%V);
  ("valid", logSlice__valid%V)
].

Definition logSlice__mset_ptr : list (string * val) := [
  ("lastEntryID", (λ: "$recvAddr",
    logSlice__lastEntryID (![logSlice] "$recvAddr")
    )%V);
  ("lastIndex", (λ: "$recvAddr",
    logSlice__lastIndex (![logSlice] "$recvAddr")
    )%V);
  ("valid", (λ: "$recvAddr",
    logSlice__valid (![logSlice] "$recvAddr")
    )%V)
].

(* go: util.go:81:6 *)
Definition DescribeHardState : val :=
  rec: "DescribeHardState" "hs" :=
    exception_do (let: "hs" := (ref_ty raftpb.HardState "hs") in
    let: "buf" := (ref_ty strings.Builder (zero_val strings.Builder)) in
    do:  (let: "$a0" := (interface.make strings.Builder__mset_ptr "buf") in
    let: "$a1" := #"Term:%d" in
    let: "$a2" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.HardState "Term" "hs"))) in
    slice.literal interfaceT ["$sl0"])) in
    fmt.Fprintf "$a0" "$a1" "$a2");;;
    (if: (![uint64T] (struct.field_ref raftpb.HardState "Vote" "hs")) ≠ #(W64 0)
    then
      do:  (let: "$a0" := (interface.make strings.Builder__mset_ptr "buf") in
      let: "$a1" := #" Vote:%d" in
      let: "$a2" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.HardState "Vote" "hs"))) in
      slice.literal interfaceT ["$sl0"])) in
      fmt.Fprintf "$a0" "$a1" "$a2")
    else do:  #());;;
    do:  (let: "$a0" := (interface.make strings.Builder__mset_ptr "buf") in
    let: "$a1" := #" Commit:%d" in
    let: "$a2" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref raftpb.HardState "Commit" "hs"))) in
    slice.literal interfaceT ["$sl0"])) in
    fmt.Fprintf "$a0" "$a1" "$a2");;;
    return: ((strings.Builder__String "buf") #())).

(* go: util.go:91:6 *)
Definition DescribeSoftState : val :=
  rec: "DescribeSoftState" "ss" :=
    exception_do (let: "ss" := (ref_ty SoftState "ss") in
    return: (let: "$a0" := #"Lead:%d State:%s" in
     let: "$a1" := ((let: "$sl0" := (interface.make uint64__mset (![uint64T] (struct.field_ref SoftState "Lead" "ss"))) in
     let: "$sl1" := (interface.make StateType__mset (![StateType] (struct.field_ref SoftState "RaftState" "ss"))) in
     slice.literal interfaceT ["$sl0"; "$sl1"])) in
     fmt.Sprintf "$a0" "$a1")).

(* DescribeEntries calls DescribeEntry for each Entry, adding a newline to
   each.

   go: util.go:244:6 *)
Definition DescribeEntries : val :=
  rec: "DescribeEntries" "ents" "f" :=
    exception_do (let: "f" := (ref_ty EntryFormatter "f") in
    let: "ents" := (ref_ty sliceT "ents") in
    let: "buf" := (ref_ty bytes.Buffer (zero_val bytes.Buffer)) in
    do:  (let: "$range" := (![sliceT] "ents") in
    slice.for_range raftpb.Entry "$range" (λ: <> "e",
      let: "e" := ref_ty raftpb.Entry "e" in
      let: ("$ret0", "$ret1") := (let: "$a0" := ((let: "$a0" := (![raftpb.Entry] "e") in
      let: "$a1" := (![EntryFormatter] "f") in
      DescribeEntry "$a0" "$a1") + #"
      ") in
      (bytes.Buffer__WriteString "buf") "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  "$r0";;;
      do:  "$r1"));;;
    return: ((bytes.Buffer__String "buf") #())).

(* go: util.go:107:6 *)
Definition DescribeReady : val :=
  rec: "DescribeReady" "rd" "f" :=
    exception_do (let: "f" := (ref_ty EntryFormatter "f") in
    let: "rd" := (ref_ty Ready "rd") in
    let: "buf" := (ref_ty strings.Builder (zero_val strings.Builder)) in
    (if: (![ptrT] (struct.field_ref Ready "SoftState" "rd")) ≠ #null
    then
      do:  (let: "$a0" := (interface.make strings.Builder__mset_ptr "buf") in
      let: "$a1" := ((let: "$sl0" := (interface.make string__mset (let: "$a0" := (![SoftState] (![ptrT] (struct.field_ref Ready "SoftState" "rd"))) in
      DescribeSoftState "$a0")) in
      slice.literal interfaceT ["$sl0"])) in
      fmt.Fprint "$a0" "$a1");;;
      do:  (let: "$a0" := #(W8 10) in
      (strings.Builder__WriteByte "buf") "$a0")
    else do:  #());;;
    (if: (~ (let: "$a0" := (![raftpb.HardState] (struct.field_ref Ready "HardState" "rd")) in
    IsEmptyHardState "$a0"))
    then
      do:  (let: "$a0" := (interface.make strings.Builder__mset_ptr "buf") in
      let: "$a1" := #"HardState %s" in
      let: "$a2" := ((let: "$sl0" := (interface.make string__mset (let: "$a0" := (![raftpb.HardState] (struct.field_ref Ready "HardState" "rd")) in
      DescribeHardState "$a0")) in
      slice.literal interfaceT ["$sl0"])) in
      fmt.Fprintf "$a0" "$a1" "$a2");;;
      do:  (let: "$a0" := #(W8 10) in
      (strings.Builder__WriteByte "buf") "$a0")
    else do:  #());;;
    (if: int_gt (let: "$a0" := (![sliceT] (struct.field_ref Ready "ReadStates" "rd")) in
    slice.len "$a0") #(W64 0)
    then
      do:  (let: "$a0" := (interface.make strings.Builder__mset_ptr "buf") in
      let: "$a1" := #"ReadStates %v
      " in
      let: "$a2" := ((let: "$sl0" := (interface.make slice__mset (![sliceT] (struct.field_ref Ready "ReadStates" "rd"))) in
      slice.literal interfaceT ["$sl0"])) in
      fmt.Fprintf "$a0" "$a1" "$a2")
    else do:  #());;;
    (if: int_gt (let: "$a0" := (![sliceT] (struct.field_ref Ready "Entries" "rd")) in
    slice.len "$a0") #(W64 0)
    then
      do:  (let: "$a0" := #"Entries:
      " in
      (strings.Builder__WriteString "buf") "$a0");;;
      do:  (let: "$a0" := (interface.make strings.Builder__mset_ptr "buf") in
      let: "$a1" := ((let: "$sl0" := (interface.make string__mset (let: "$a0" := (![sliceT] (struct.field_ref Ready "Entries" "rd")) in
      let: "$a1" := (![EntryFormatter] "f") in
      DescribeEntries "$a0" "$a1")) in
      slice.literal interfaceT ["$sl0"])) in
      fmt.Fprint "$a0" "$a1")
    else do:  #());;;
    (if: (~ (let: "$a0" := (![raftpb.Snapshot] (struct.field_ref Ready "Snapshot" "rd")) in
    IsEmptySnap "$a0"))
    then
      do:  (let: "$a0" := (interface.make strings.Builder__mset_ptr "buf") in
      let: "$a1" := #"Snapshot %s
      " in
      let: "$a2" := ((let: "$sl0" := (interface.make string__mset (let: "$a0" := (![raftpb.Snapshot] (struct.field_ref Ready "Snapshot" "rd")) in
      DescribeSnapshot "$a0")) in
      slice.literal interfaceT ["$sl0"])) in
      fmt.Fprintf "$a0" "$a1" "$a2")
    else do:  #());;;
    (if: int_gt (let: "$a0" := (![sliceT] (struct.field_ref Ready "CommittedEntries" "rd")) in
    slice.len "$a0") #(W64 0)
    then
      do:  (let: "$a0" := #"CommittedEntries:
      " in
      (strings.Builder__WriteString "buf") "$a0");;;
      do:  (let: "$a0" := (interface.make strings.Builder__mset_ptr "buf") in
      let: "$a1" := ((let: "$sl0" := (interface.make string__mset (let: "$a0" := (![sliceT] (struct.field_ref Ready "CommittedEntries" "rd")) in
      let: "$a1" := (![EntryFormatter] "f") in
      DescribeEntries "$a0" "$a1")) in
      slice.literal interfaceT ["$sl0"])) in
      fmt.Fprint "$a0" "$a1")
    else do:  #());;;
    (if: int_gt (let: "$a0" := (![sliceT] (struct.field_ref Ready "Messages" "rd")) in
    slice.len "$a0") #(W64 0)
    then
      do:  (let: "$a0" := #"Messages:
      " in
      (strings.Builder__WriteString "buf") "$a0");;;
      do:  (let: "$range" := (![sliceT] (struct.field_ref Ready "Messages" "rd")) in
      slice.for_range raftpb.Message "$range" (λ: <> "msg",
        let: "msg" := ref_ty raftpb.Message "msg" in
        do:  (let: "$a0" := (interface.make strings.Builder__mset_ptr "buf") in
        let: "$a1" := ((let: "$sl0" := (interface.make string__mset (let: "$a0" := (![raftpb.Message] "msg") in
        let: "$a1" := (![EntryFormatter] "f") in
        DescribeMessage "$a0" "$a1")) in
        slice.literal interfaceT ["$sl0"])) in
        fmt.Fprint "$a0" "$a1");;;
        do:  (let: "$a0" := #(W8 10) in
        (strings.Builder__WriteByte "buf") "$a0")))
    else do:  #());;;
    (if: int_gt ((strings.Builder__Len "buf") #()) #(W64 0)
    then
      return: (let: "$a0" := #"Ready MustSync=%t:
       %s" in
       let: "$a1" := ((let: "$sl0" := (interface.make bool__mset (![boolT] (struct.field_ref Ready "MustSync" "rd"))) in
       let: "$sl1" := (interface.make string__mset ((strings.Builder__String "buf") #())) in
       slice.literal interfaceT ["$sl0"; "$sl1"])) in
       fmt.Sprintf "$a0" "$a1")
    else do:  #());;;
    return: (#"<empty Ready>")).

Definition EntryFormatter__mset : list (string * val) := [
].

Definition EntryFormatter__mset_ptr : list (string * val) := [
].

Definition entryEncodingSize__mset_ptr : list (string * val) := [
].

Definition entryPayloadSize__mset : list (string * val) := [
].

Definition entryPayloadSize__mset_ptr : list (string * val) := [
].

End code.
