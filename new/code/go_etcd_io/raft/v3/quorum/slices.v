(* autogenerated from go.etcd.io/raft/v3/quorum/slices *)
From New.golang Require Import defn.
Module pkg_id.
Definition slices : go_string := "go.etcd.io/raft/v3/quorum/slices".

End pkg_id.
Export pkg_id.
Module slices.

Definition Tup {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/raft/v3/quorum/slices.Tup"%go [].

#[global] Opaque Tup.

Definition CompareUint64 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3/quorum/slices.CompareUint64"%go.

Definition SortUint64 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3/quorum/slices.SortUint64"%go.

Definition SortFuncTup {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3/quorum/slices.SortFuncTup"%go.

#[global] Instance info' : PkgInfo pkg_id.slices :=
{|
  pkg_imported_pkgs := []
|}.

Axiom _'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init pkg_id.slices (λ: <>,
      exception_do (do:  #())
      ).

Module Tup.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  ID' : w64;
  Idx' : w64;
  Ok' : bool;
  Bar' : w64;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End Tup.

Definition Tup'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "ID"%go go.uint64);
  (go.FieldDecl "Idx"%go go.uint64);
  (go.FieldDecl "Ok"%go go.bool);
  (go.FieldDecl "Bar"%go go.int)
].
Program Definition Tup'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (Tup'fds_unsealed).
Global Instance equals_unfold_Tup {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Tup'fds =→ Tup'fds_unsealed.
Proof. rewrite /Tup'fds seal_eq //. Qed.

Definition Tupⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (Tup'fds).

Class Tup_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Tup_type_repr  :: go.TypeReprUnderlying Tupⁱᵐᵖˡ Tup.t;
  #[global] Tup_underlying :: (Tup) <u (Tupⁱᵐᵖˡ);
  #[global] Tup_get_ID (x : Tup.t) :: ⟦StructFieldGet (Tupⁱᵐᵖˡ) "ID", #x⟧ ⤳[under] #x.(Tup.ID');
  #[global] Tup_set_ID (x : Tup.t) y :: ⟦StructFieldSet (Tupⁱᵐᵖˡ) "ID", (#x, #y)⟧ ⤳[under] #(x <|Tup.ID' := y|>);
  #[global] Tup_get_Idx (x : Tup.t) :: ⟦StructFieldGet (Tupⁱᵐᵖˡ) "Idx", #x⟧ ⤳[under] #x.(Tup.Idx');
  #[global] Tup_set_Idx (x : Tup.t) y :: ⟦StructFieldSet (Tupⁱᵐᵖˡ) "Idx", (#x, #y)⟧ ⤳[under] #(x <|Tup.Idx' := y|>);
  #[global] Tup_get_Ok (x : Tup.t) :: ⟦StructFieldGet (Tupⁱᵐᵖˡ) "Ok", #x⟧ ⤳[under] #x.(Tup.Ok');
  #[global] Tup_set_Ok (x : Tup.t) y :: ⟦StructFieldSet (Tupⁱᵐᵖˡ) "Ok", (#x, #y)⟧ ⤳[under] #(x <|Tup.Ok' := y|>);
  #[global] Tup_get_Bar (x : Tup.t) :: ⟦StructFieldGet (Tupⁱᵐᵖˡ) "Bar", #x⟧ ⤳[under] #x.(Tup.Bar');
  #[global] Tup_set_Bar (x : Tup.t) y :: ⟦StructFieldSet (Tupⁱᵐᵖˡ) "Bar", (#x, #y)⟧ ⤳[under] #(x <|Tup.Bar' := y|>);
}.

Class Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Tup_instance :: Tup_Assumptions;
}.
End slices.
