(* autogenerated from go.etcd.io/raft/v3/quorum *)
Require Export New.code.fmt.
Require Export New.code.math.
Require Export New.code.strings.
Require Export New.code.go_etcd_io.raft.v3.quorum.slices.
Require Export New.code.strconv.
From New.golang Require Import defn.
Module pkg_id.
Definition quorum : go_string := "go.etcd.io/raft/v3/quorum".

End pkg_id.
Export pkg_id.
Module quorum.

Definition JointConfig {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/raft/v3/quorum.JointConfig"%go [].

Definition MajorityConfig {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/raft/v3/quorum.MajorityConfig"%go [].

Definition Index' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/raft/v3/quorum.Index"%go [].

Definition AckedIndexer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/raft/v3/quorum.AckedIndexer"%go [].

Definition mapAckIndexer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/raft/v3/quorum.mapAckIndexer"%go [].

Definition VoteResult {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/raft/v3/quorum.VoteResult"%go [].

Definition VotePending {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W8 1).

Definition VoteLost {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W8 2).

Definition VoteWon {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W8 3).

Definition _VoteResult_name {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #"VotePendingVoteLostVoteWon"%go.

Definition _VoteResult_index {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3/quorum._VoteResult_index"%go.

(* go: joint.go:21:22 *)
Definition JointConfig__Stringⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "c" <>,
    exception_do (let: "c" := (GoAlloc JointConfig "c") in
    (if: Convert go.untyped_bool go.bool ((let: "$a0" := (![MajorityConfig] (IndexRef JointConfig (![JointConfig] "c", #(W64 1)))) in
    (FuncResolve go.len [MajorityConfig] #()) "$a0") >⟨go.int⟩ #(W64 0))
    then return: ((((MethodResolve MajorityConfig "String"%go (![MajorityConfig] (IndexRef JointConfig (![JointConfig] "c", #(W64 0))))) #()) +⟨go.string⟩ #"&&"%go) +⟨go.string⟩ ((MethodResolve MajorityConfig "String"%go (![MajorityConfig] (IndexRef JointConfig (![JointConfig] "c", #(W64 1))))) #()))
    else do:  #());;;
    return: ((MethodResolve MajorityConfig "String"%go (![MajorityConfig] (IndexRef JointConfig (![JointConfig] "c", #(W64 0))))) #())).

(* IDs returns a newly initialized map representing the set of voters present
   in the joint configuration.

   go: joint.go:30:22 *)
Definition JointConfig__IDsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "c" <>,
    exception_do (let: "c" := (GoAlloc JointConfig "c") in
    let: "m" := (GoAlloc (go.MapType go.uint64 (go.StructType [

    ])) (GoZeroVal (go.MapType go.uint64 (go.StructType [

    ])) #())) in
    let: "$r0" := (CompositeLiteral (go.MapType go.uint64 (go.StructType [

    ])) (LiteralValue [])) in
    do:  ("m" <-[go.MapType go.uint64 (go.StructType [

    ])] "$r0");;;
    let: "$range" := (![MajorityConfig] (IndexRef JointConfig (![JointConfig] "c", #(W64 0)))) in
    (let: "id" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    map.for_range go.uint64 (go.StructType [

    ]) "$range" (λ: "$key" "value",
      do:  ("id" <-[go.uint64] "$key");;;
      let: "$r0" := (CompositeLiteral (go.StructType [

      ]) (LiteralValue [])) in
      do:  (map.insert go.uint64 (![go.MapType go.uint64 (go.StructType [

      ])] "m") (![go.uint64] "id") "$r0")));;;
    let: "$range" := (![MajorityConfig] (IndexRef JointConfig (![JointConfig] "c", #(W64 1)))) in
    (let: "id" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    map.for_range go.uint64 (go.StructType [

    ]) "$range" (λ: "$key" "value",
      do:  ("id" <-[go.uint64] "$key");;;
      let: "$r0" := (CompositeLiteral (go.StructType [

      ]) (LiteralValue [])) in
      do:  (map.insert go.uint64 (![go.MapType go.uint64 (go.StructType [

      ])] "m") (![go.uint64] "id") "$r0")));;;
    return: (![go.MapType go.uint64 (go.StructType [

     ])] "m")).

(* Describe returns a (multi-line) representation of the commit indexes for the
   given lookuper.

   go: joint.go:43:22 *)
Definition JointConfig__Describeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "c" "l",
    exception_do (let: "c" := (GoAlloc JointConfig "c") in
    let: "l" := (GoAlloc AckedIndexer "l") in
    return: (let: "$a0" := (![AckedIndexer] "l") in
     (MethodResolve MajorityConfig "Describe"%go ((MethodResolve JointConfig "IDs"%go (![JointConfig] "c")) #())) "$a0")).

(* CommittedIndex returns the largest committed index for the given joint
   quorum. An index is jointly committed if it is committed in both constituent
   majorities.

   go: joint.go:50:22 *)
Definition JointConfig__CommittedIndexⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "c" "l",
    exception_do (let: "c" := (GoAlloc JointConfig "c") in
    let: "l" := (GoAlloc AckedIndexer "l") in
    let: "idx0" := (GoAlloc Index' (GoZeroVal Index' #())) in
    let: "$r0" := (let: "$a0" := (![AckedIndexer] "l") in
    (MethodResolve MajorityConfig "CommittedIndex"%go (![MajorityConfig] (IndexRef JointConfig (![JointConfig] "c", #(W64 0))))) "$a0") in
    do:  ("idx0" <-[Index'] "$r0");;;
    let: "idx1" := (GoAlloc Index' (GoZeroVal Index' #())) in
    let: "$r0" := (let: "$a0" := (![AckedIndexer] "l") in
    (MethodResolve MajorityConfig "CommittedIndex"%go (![MajorityConfig] (IndexRef JointConfig (![JointConfig] "c", #(W64 1))))) "$a0") in
    do:  ("idx1" <-[Index'] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![Index'] "idx0") <⟨go.uint64⟩ (![Index'] "idx1"))
    then return: (![Index'] "idx0")
    else do:  #());;;
    return: (![Index'] "idx1")).

(* VoteResult takes a mapping of voters to yes/no (true/false) votes and returns
   a result indicating whether the vote is pending, lost, or won. A joint quorum
   requires both majority quorums to vote in favor.

   go: joint.go:62:22 *)
Definition JointConfig__VoteResultⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "c" "votes",
    exception_do (let: "c" := (GoAlloc JointConfig "c") in
    let: "votes" := (GoAlloc (go.MapType go.uint64 go.bool) "votes") in
    let: "r1" := (GoAlloc VoteResult (GoZeroVal VoteResult #())) in
    let: "$r0" := (let: "$a0" := (![go.MapType go.uint64 go.bool] "votes") in
    (MethodResolve MajorityConfig "VoteResult"%go (![MajorityConfig] (IndexRef JointConfig (![JointConfig] "c", #(W64 0))))) "$a0") in
    do:  ("r1" <-[VoteResult] "$r0");;;
    let: "r2" := (GoAlloc VoteResult (GoZeroVal VoteResult #())) in
    let: "$r0" := (let: "$a0" := (![go.MapType go.uint64 go.bool] "votes") in
    (MethodResolve MajorityConfig "VoteResult"%go (![MajorityConfig] (IndexRef JointConfig (![JointConfig] "c", #(W64 1))))) "$a0") in
    do:  ("r2" <-[VoteResult] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![VoteResult] "r1") =⟨go.uint8⟩ (![VoteResult] "r2"))
    then return: (![VoteResult] "r1")
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool (((![VoteResult] "r1") =⟨go.uint8⟩ VoteLost) || ((![VoteResult] "r2") =⟨go.uint8⟩ VoteLost))
    then return: (VoteLost)
    else do:  #());;;
    return: (VotePending)).

(* go: majority.go:28:25 *)
Definition MajorityConfig__Stringⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "c" <>,
    exception_do (let: "c" := (GoAlloc MajorityConfig "c") in
    let: "sl" := (GoAlloc (go.SliceType go.uint64) (GoZeroVal (go.SliceType go.uint64) #())) in
    let: "$r0" := ((FuncResolve go.make3 [go.SliceType go.uint64] #()) #(W64 0) (let: "$a0" := (![MajorityConfig] "c") in
    (FuncResolve go.len [MajorityConfig] #()) "$a0")) in
    do:  ("sl" <-[go.SliceType go.uint64] "$r0");;;
    let: "$range" := (![MajorityConfig] "c") in
    (let: "id" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    map.for_range go.uint64 (go.StructType [

    ]) "$range" (λ: "$key" "value",
      do:  ("id" <-[go.uint64] "$key");;;
      let: "$r0" := (let: "$a0" := (![go.SliceType go.uint64] "sl") in
      let: "$a1" := ((let: "$sl0" := (![go.uint64] "id") in
      CompositeLiteral (go.SliceType go.uint64) (LiteralValue [KeyedElement None (ElementExpression go.uint64 "$sl0")]))) in
      (FuncResolve go.append [go.SliceType go.uint64] #()) "$a0" "$a1") in
      do:  ("sl" <-[go.SliceType go.uint64] "$r0")));;;
    do:  (let: "$a0" := (![go.SliceType go.uint64] "sl") in
    (FuncResolve slices.SortUint64 [] #()) "$a0");;;
    let: "buf" := (GoAlloc strings.Builder (GoZeroVal strings.Builder #())) in
    do:  (let: "$a0" := #(W8 40) in
    (MethodResolve (go.PointerType strings.Builder) "WriteByte"%go "buf") "$a0");;;
    let: "$range" := (![go.SliceType go.uint64] "sl") in
    (let: "i" := (GoAlloc go.int (GoZeroVal go.int #())) in
    slice.for_range go.uint64 "$range" (λ: "$key" "$value",
      do:  ("i" <-[go.int] "$key");;;
      (if: Convert go.untyped_bool go.bool ((![go.int] "i") >⟨go.int⟩ #(W64 0))
      then
        do:  (let: "$a0" := #(W8 32) in
        (MethodResolve (go.PointerType strings.Builder) "WriteByte"%go "buf") "$a0")
      else do:  #());;;
      do:  (let: "$a0" := (Convert (go.PointerType strings.Builder) io.Writer "buf") in
      let: "$a1" := ((let: "$sl0" := (Convert go.uint64 go.any (![go.uint64] (IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "sl", ![go.int] "i")))) in
      CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0")]))) in
      (FuncResolve fmt.Fprint [] #()) "$a0" "$a1")));;;
    do:  (let: "$a0" := #(W8 41) in
    (MethodResolve (go.PointerType strings.Builder) "WriteByte"%go "buf") "$a0");;;
    return: ((MethodResolve (go.PointerType strings.Builder) "String"%go "buf") #())).

(* Describe returns a (multi-line) representation of the commit indexes for the
   given lookuper.

   go: majority.go:48:25 *)
Definition MajorityConfig__Describeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "c" "l",
    exception_do (let: "c" := (GoAlloc MajorityConfig "c") in
    let: "l" := (GoAlloc AckedIndexer "l") in
    (if: Convert go.untyped_bool go.bool ((let: "$a0" := (![MajorityConfig] "c") in
    (FuncResolve go.len [MajorityConfig] #()) "$a0") =⟨go.int⟩ #(W64 0))
    then return: (#"<empty majority quorum>"%go)
    else do:  #());;;
    let: "n" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := (let: "$a0" := (![MajorityConfig] "c") in
    (FuncResolve go.len [MajorityConfig] #()) "$a0") in
    do:  ("n" <-[go.int] "$r0");;;
    let: "info" := (GoAlloc (go.SliceType slices.Tup) (GoZeroVal (go.SliceType slices.Tup) #())) in
    let: "$r0" := ((FuncResolve go.make3 [go.SliceType slices.Tup] #()) #(W64 0) (![go.int] "n")) in
    do:  ("info" <-[go.SliceType slices.Tup] "$r0");;;
    let: "$range" := (![MajorityConfig] "c") in
    (let: "id" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    map.for_range go.uint64 (go.StructType [

    ]) "$range" (λ: "$key" "value",
      do:  ("id" <-[go.uint64] "$key");;;
      let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
      let: "idx" := (GoAlloc Index' (GoZeroVal Index' #())) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![go.uint64] "id") in
      (MethodResolve AckedIndexer "AckedIndex"%go (![AckedIndexer] "l")) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("idx" <-[Index'] "$r0");;;
      do:  ("ok" <-[go.bool] "$r1");;;
      let: "$r0" := (let: "$a0" := (![go.SliceType slices.Tup] "info") in
      let: "$a1" := ((let: "$sl0" := (CompositeLiteral slices.Tup (LiteralValue [KeyedElement (Some (KeyField "ID"%go)) (ElementExpression go.uint64 (![go.uint64] "id")); KeyedElement (Some (KeyField "Idx"%go)) (ElementExpression go.uint64 (![Index'] "idx")); KeyedElement (Some (KeyField "Ok"%go)) (ElementExpression go.bool (![go.bool] "ok"))])) in
      CompositeLiteral (go.SliceType slices.Tup) (LiteralValue [KeyedElement None (ElementExpression slices.Tup "$sl0")]))) in
      (FuncResolve go.append [go.SliceType slices.Tup] #()) "$a0" "$a1") in
      do:  ("info" <-[go.SliceType slices.Tup] "$r0")));;;
    do:  (let: "$a0" := (![go.SliceType slices.Tup] "info") in
    let: "$a1" := (λ: "a" "b",
      exception_do (let: "b" := (GoAlloc slices.Tup "b") in
      let: "a" := (GoAlloc slices.Tup "a") in
      (let: "n" := (GoAlloc go.int (GoZeroVal go.int #())) in
      let: "$r0" := (let: "$a0" := (![go.uint64] (StructFieldRef slices.Tup "Idx"%go "a")) in
      let: "$a1" := (![go.uint64] (StructFieldRef slices.Tup "Idx"%go "b")) in
      (FuncResolve slices.CompareUint64 [] #()) "$a0" "$a1") in
      do:  ("n" <-[go.int] "$r0");;;
      (if: Convert go.untyped_bool go.bool ((![go.int] "n") ≠⟨go.int⟩ #(W64 0))
      then return: (![go.int] "n")
      else do:  #()));;;
      return: (let: "$a0" := (![go.uint64] (StructFieldRef slices.Tup "ID"%go "a")) in
       let: "$a1" := (![go.uint64] (StructFieldRef slices.Tup "ID"%go "b")) in
       (FuncResolve slices.CompareUint64 [] #()) "$a0" "$a1"))
      ) in
    (FuncResolve slices.SortFuncTup [] #()) "$a0" "$a1");;;
    let: "$range" := (![go.SliceType slices.Tup] "info") in
    (let: "i" := (GoAlloc go.int (GoZeroVal go.int #())) in
    slice.for_range slices.Tup "$range" (λ: "$key" "$value",
      do:  ("i" <-[go.int] "$key");;;
      (if: Convert go.untyped_bool go.bool (((![go.int] "i") >⟨go.int⟩ #(W64 0)) && ((![go.uint64] (StructFieldRef slices.Tup "Idx"%go (IndexRef (go.SliceType slices.Tup) (![go.SliceType slices.Tup] "info", (![go.int] "i") -⟨go.int⟩ #(W64 1))))) <⟨go.uint64⟩ (![go.uint64] (StructFieldRef slices.Tup "Idx"%go (IndexRef (go.SliceType slices.Tup) (![go.SliceType slices.Tup] "info", ![go.int] "i"))))))
      then
        let: "$r0" := (![go.int] "i") in
        do:  ((StructFieldRef slices.Tup "Bar"%go (IndexRef (go.SliceType slices.Tup) (![go.SliceType slices.Tup] "info", ![go.int] "i"))) <-[go.int] "$r0")
      else do:  #())));;;
    do:  (let: "$a0" := (![go.SliceType slices.Tup] "info") in
    let: "$a1" := (λ: "a" "b",
      exception_do (let: "b" := (GoAlloc slices.Tup "b") in
      let: "a" := (GoAlloc slices.Tup "a") in
      return: (let: "$a0" := (![go.uint64] (StructFieldRef slices.Tup "ID"%go "a")) in
       let: "$a1" := (![go.uint64] (StructFieldRef slices.Tup "ID"%go "b")) in
       (FuncResolve slices.CompareUint64 [] #()) "$a0" "$a1"))
      ) in
    (FuncResolve slices.SortFuncTup [] #()) "$a0" "$a1");;;
    let: "buf" := (GoAlloc strings.Builder (GoZeroVal strings.Builder #())) in
    do:  (let: "$a0" := (Convert (go.PointerType strings.Builder) io.Writer "buf") in
    let: "$a1" := ((let: "$sl0" := (Convert go.string go.any ((let: "$a0" := #" "%go in
    let: "$a1" := (![go.int] "n") in
    (FuncResolve strings.Repeat [] #()) "$a0" "$a1") +⟨go.string⟩ #"    idx
    "%go)) in
    CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0")]))) in
    (FuncResolve fmt.Fprint [] #()) "$a0" "$a1");;;
    let: "$range" := (![go.SliceType slices.Tup] "info") in
    (let: "i" := (GoAlloc go.int (GoZeroVal go.int #())) in
    slice.for_range slices.Tup "$range" (λ: "$key" "$value",
      do:  ("i" <-[go.int] "$key");;;
      let: "bar" := (GoAlloc go.int (GoZeroVal go.int #())) in
      let: "$r0" := (![go.int] (StructFieldRef slices.Tup "Bar"%go (IndexRef (go.SliceType slices.Tup) (![go.SliceType slices.Tup] "info", ![go.int] "i")))) in
      do:  ("bar" <-[go.int] "$r0");;;
      (if: (⟨go.bool⟩! (![go.bool] (StructFieldRef slices.Tup "Ok"%go (IndexRef (go.SliceType slices.Tup) (![go.SliceType slices.Tup] "info", ![go.int] "i")))))
      then
        do:  (let: "$a0" := (Convert (go.PointerType strings.Builder) io.Writer "buf") in
        let: "$a1" := ((let: "$sl0" := (Convert go.string go.any (#"?"%go +⟨go.string⟩ (let: "$a0" := #" "%go in
        let: "$a1" := (![go.int] "n") in
        (FuncResolve strings.Repeat [] #()) "$a0" "$a1"))) in
        CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0")]))) in
        (FuncResolve fmt.Fprint [] #()) "$a0" "$a1")
      else
        do:  (let: "$a0" := (Convert (go.PointerType strings.Builder) io.Writer "buf") in
        let: "$a1" := ((let: "$sl0" := (Convert go.string go.any (((let: "$a0" := #"x"%go in
        let: "$a1" := (![go.int] "bar") in
        (FuncResolve strings.Repeat [] #()) "$a0" "$a1") +⟨go.string⟩ #">"%go) +⟨go.string⟩ (let: "$a0" := #" "%go in
        let: "$a1" := ((![go.int] "n") -⟨go.int⟩ (![go.int] "bar")) in
        (FuncResolve strings.Repeat [] #()) "$a0" "$a1"))) in
        CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0")]))) in
        (FuncResolve fmt.Fprint [] #()) "$a0" "$a1"));;;
      do:  (let: "$a0" := (Convert (go.PointerType strings.Builder) io.Writer "buf") in
      let: "$a1" := #" %5d    (id=%d)
      "%go in
      let: "$a2" := ((let: "$sl0" := (Convert go.uint64 go.any (![go.uint64] (StructFieldRef slices.Tup "Idx"%go (IndexRef (go.SliceType slices.Tup) (![go.SliceType slices.Tup] "info", ![go.int] "i"))))) in
      let: "$sl1" := (Convert go.uint64 go.any (![go.uint64] (StructFieldRef slices.Tup "ID"%go (IndexRef (go.SliceType slices.Tup) (![go.SliceType slices.Tup] "info", ![go.int] "i"))))) in
      CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0"); KeyedElement None (ElementExpression go.any "$sl1")]))) in
      (FuncResolve fmt.Fprintf [] #()) "$a0" "$a1" "$a2")));;;
    return: ((MethodResolve (go.PointerType strings.Builder) "String"%go "buf") #())).

(* Slice returns the MajorityConfig as a sorted slice.

   go: majority.go:101:25 *)
Definition MajorityConfig__Sliceⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "c" <>,
    exception_do (let: "c" := (GoAlloc MajorityConfig "c") in
    let: "sl" := (GoAlloc (go.SliceType go.uint64) (GoZeroVal (go.SliceType go.uint64) #())) in
    let: "$range" := (![MajorityConfig] "c") in
    (let: "id" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    map.for_range go.uint64 (go.StructType [

    ]) "$range" (λ: "$key" "value",
      do:  ("id" <-[go.uint64] "$key");;;
      let: "$r0" := (let: "$a0" := (![go.SliceType go.uint64] "sl") in
      let: "$a1" := ((let: "$sl0" := (![go.uint64] "id") in
      CompositeLiteral (go.SliceType go.uint64) (LiteralValue [KeyedElement None (ElementExpression go.uint64 "$sl0")]))) in
      (FuncResolve go.append [go.SliceType go.uint64] #()) "$a0" "$a1") in
      do:  ("sl" <-[go.SliceType go.uint64] "$r0")));;;
    do:  (let: "$a0" := (![go.SliceType go.uint64] "sl") in
    (FuncResolve slices.SortUint64 [] #()) "$a0");;;
    return: (![go.SliceType go.uint64] "sl")).

(* CommittedIndex computes the committed index from those supplied via the
   provided AckedIndexer (for the active config).

   go: majority.go:112:25 *)
Definition MajorityConfig__CommittedIndexⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "c" "l",
    exception_do (let: "c" := (GoAlloc MajorityConfig "c") in
    let: "l" := (GoAlloc AckedIndexer "l") in
    let: "n" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := (let: "$a0" := (![MajorityConfig] "c") in
    (FuncResolve go.len [MajorityConfig] #()) "$a0") in
    do:  ("n" <-[go.int] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.int] "n") =⟨go.int⟩ #(W64 0))
    then return: (Convert go.untyped_int Index' math.MaxUint64)
    else do:  #());;;
    let: "stk" := (GoAlloc (go.ArrayType 7 go.uint64) (GoZeroVal (go.ArrayType 7 go.uint64) #())) in
    let: "srt" := (GoAlloc (go.SliceType go.uint64) (GoZeroVal (go.SliceType go.uint64) #())) in
    (if: Convert go.untyped_bool go.bool ((FuncResolve go.len [go.ArrayType 7 go.uint64] #()) ≥⟨go.int⟩ (![go.int] "n"))
    then
      let: "$r0" := (let: "$s" := (![go.ArrayType 7 go.uint64] "stk") in
      Slice (go.ArrayType 7 go.uint64) ("$s", #(W64 0), ![go.int] "n")) in
      do:  ("srt" <-[go.SliceType go.uint64] "$r0")
    else
      let: "$r0" := ((FuncResolve go.make2 [go.SliceType go.uint64] #()) (![go.int] "n")) in
      do:  ("srt" <-[go.SliceType go.uint64] "$r0"));;;
    let: "i" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := ((![go.int] "n") -⟨go.int⟩ #(W64 1)) in
    do:  ("i" <-[go.int] "$r0");;;
    let: "$range" := (![MajorityConfig] "c") in
    (let: "id" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    map.for_range go.uint64 (go.StructType [

    ]) "$range" (λ: "$key" "value",
      do:  ("id" <-[go.uint64] "$key");;;
      (let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
      let: "idx" := (GoAlloc Index' (GoZeroVal Index' #())) in
      let: ("$ret0", "$ret1") := (let: "$a0" := (![go.uint64] "id") in
      (MethodResolve AckedIndexer "AckedIndex"%go (![AckedIndexer] "l")) "$a0") in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("idx" <-[Index'] "$r0");;;
      do:  ("ok" <-[go.bool] "$r1");;;
      (if: ![go.bool] "ok"
      then
        let: "$r0" := (![Index'] "idx") in
        do:  ((IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "srt", ![go.int] "i")) <-[go.uint64] "$r0");;;
        do:  ("i" <-[go.int] ((![go.int] "i") -⟨go.int⟩ #(W64 1)))
      else do:  #()))));;;
    do:  (let: "$a0" := (![go.SliceType go.uint64] "srt") in
    (FuncResolve slices.SortUint64 [] #()) "$a0");;;
    let: "pos" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := ((![go.int] "n") -⟨go.int⟩ (((![go.int] "n") /⟨go.int⟩ #(W64 2)) +⟨go.int⟩ #(W64 1))) in
    do:  ("pos" <-[go.int] "$r0");;;
    return: (![go.uint64] (IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "srt", ![go.int] "pos")))).

(* VoteResult takes a mapping of voters to yes/no (true/false) votes and returns
   a result indicating whether the vote is pending (i.e. neither a quorum of
   yes/no has been reached), won (a quorum of yes has been reached), or lost (a
   quorum of no has been reached).

   go: majority.go:161:25 *)
Definition MajorityConfig__VoteResultⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "c" "votes",
    exception_do (let: "c" := (GoAlloc MajorityConfig "c") in
    let: "votes" := (GoAlloc (go.MapType go.uint64 go.bool) "votes") in
    (if: Convert go.untyped_bool go.bool ((let: "$a0" := (![MajorityConfig] "c") in
    (FuncResolve go.len [MajorityConfig] #()) "$a0") =⟨go.int⟩ #(W64 0))
    then return: (VoteWon)
    else do:  #());;;
    let: "votedCnt" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "missing" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$range" := (![MajorityConfig] "c") in
    (let: "id" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    map.for_range go.uint64 (go.StructType [

    ]) "$range" (λ: "$key" "value",
      do:  ("id" <-[go.uint64] "$key");;;
      let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
      let: "v" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
      let: ("$ret0", "$ret1") := (map.lookup2 go.uint64 go.bool (![go.MapType go.uint64 go.bool] "votes") (![go.uint64] "id")) in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("v" <-[go.bool] "$r0");;;
      do:  ("ok" <-[go.bool] "$r1");;;
      (if: (⟨go.bool⟩! (![go.bool] "ok"))
      then
        do:  ("missing" <-[go.int] ((![go.int] "missing") +⟨go.int⟩ #(W64 1)));;;
        continue: #()
      else do:  #());;;
      (if: ![go.bool] "v"
      then do:  ("votedCnt" <-[go.int] ((![go.int] "votedCnt") +⟨go.int⟩ #(W64 1)))
      else do:  #())));;;
    let: "q" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := (((let: "$a0" := (![MajorityConfig] "c") in
    (FuncResolve go.len [MajorityConfig] #()) "$a0") /⟨go.int⟩ #(W64 2)) +⟨go.int⟩ #(W64 1)) in
    do:  ("q" <-[go.int] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.int] "votedCnt") ≥⟨go.int⟩ (![go.int] "q"))
    then return: (VoteWon)
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool (((![go.int] "votedCnt") +⟨go.int⟩ (![go.int] "missing")) ≥⟨go.int⟩ (![go.int] "q"))
    then return: (VotePending)
    else do:  #());;;
    return: (VoteLost)).

(* go: quorum.go:25:16 *)
Definition Index__Stringⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "i" <>,
    exception_do (let: "i" := (GoAlloc Index' "i") in
    (if: Convert go.untyped_bool go.bool ((![Index'] "i") =⟨go.uint64⟩ (Convert go.untyped_int Index' math.MaxUint64))
    then return: (#"∞"%go)
    else do:  #());;;
    return: (let: "$a0" := (![Index'] "i") in
     let: "$a1" := #(W64 10) in
     (FuncResolve strconv.FormatUint [] #()) "$a0" "$a1")).

(* go: quorum.go:40:24 *)
Definition mapAckIndexer__AckedIndexⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "m" "id",
    exception_do (let: "m" := (GoAlloc mapAckIndexer "m") in
    let: "id" := (GoAlloc go.uint64 "id") in
    let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "idx" := (GoAlloc Index' (GoZeroVal Index' #())) in
    let: ("$ret0", "$ret1") := (map.lookup2 go.uint64 Index' (![mapAckIndexer] "m") (![go.uint64] "id")) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("idx" <-[Index'] "$r0");;;
    do:  ("ok" <-[go.bool] "$r1");;;
    return: (![Index'] "idx", ![go.bool] "ok")).

(* go: voteresult_string.go:20:21 *)
Definition VoteResult__Stringⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "i" <>,
    exception_do (let: "i" := (GoAlloc VoteResult "i") in
    do:  ("i" <-[VoteResult] ((![VoteResult] "i") -⟨go.uint8⟩ #(W8 1)));;;
    (if: Convert go.untyped_bool go.bool ((![VoteResult] "i") ≥⟨go.uint8⟩ (Convert go.int VoteResult ((FuncResolve go.len [go.ArrayType 4 go.uint8] #()) -⟨go.int⟩ #(W64 1))))
    then
      return: ((#"VoteResult("%go +⟨go.string⟩ (let: "$a0" := (Convert VoteResult go.int64 ((![VoteResult] "i") +⟨go.uint8⟩ #(W8 1))) in
       let: "$a1" := #(W64 10) in
       (FuncResolve strconv.FormatInt [] #()) "$a0" "$a1")) +⟨go.string⟩ #")"%go)
    else do:  #());;;
    return: (Convert (go.SliceType go.byte) go.string (let: "$s" := (Convert go.string (go.SliceType go.byte) (Convert go.untyped_string go.string _VoteResult_name)) in
     Slice (go.SliceType go.byte) ("$s", ![go.uint8] (IndexRef (go.ArrayType 4 go.uint8) (![go.ArrayType 4 go.uint8] (GlobalVarAddr _VoteResult_index #()), Convert VoteResult go.int (![VoteResult] "i"))), ![go.uint8] (IndexRef (go.ArrayType 4 go.uint8) (![go.ArrayType 4 go.uint8] (GlobalVarAddr _VoteResult_index #()), Convert VoteResult go.int ((![VoteResult] "i") +⟨go.uint8⟩ #(W8 1)))))))).

#[global] Instance info' : PkgInfo pkg_id.quorum :=
{|
  pkg_imported_pkgs := [code.fmt.pkg_id.fmt; code.math.pkg_id.math; code.strings.pkg_id.strings; code.go_etcd_io.raft.v3.quorum.slices.pkg_id.slices; code.strconv.pkg_id.strconv]
|}.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init pkg_id.quorum (λ: <>,
      exception_do (do:  (go.GlobalAlloc _VoteResult_index (go.ArrayType 4 go.uint8) #());;;
      do:  (strconv.initialize' #());;;
      do:  (slices.initialize' #());;;
      do:  (strings.initialize' #());;;
      do:  (math.initialize' #());;;
      do:  (fmt.initialize' #());;;
      let: "$r0" := (CompositeLiteral (go.ArrayType 4 go.uint8) (LiteralValue [KeyedElement None (ElementExpression go.uint8 #(W8 0)); KeyedElement None (ElementExpression go.uint8 #(W8 11)); KeyedElement None (ElementExpression go.uint8 #(W8 19)); KeyedElement None (ElementExpression go.uint8 #(W8 26))])) in
      do:  ((GlobalVarAddr _VoteResult_index #()) <-[go.ArrayType 4 go.uint8] "$r0"))
      ).

Module MajorityConfig.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := map.t.
End def.
End MajorityConfig.

Definition MajorityConfigⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.MapType go.uint64 (go.StructType [

]).

Class MajorityConfig_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] MajorityConfig_underlying :: (MajorityConfig) <u (MajorityConfigⁱᵐᵖˡ);
  #[global] MajorityConfig_CommittedIndex_unfold :: MethodUnfold (MajorityConfig) "CommittedIndex" (MajorityConfig__CommittedIndexⁱᵐᵖˡ);
  #[global] MajorityConfig_Describe_unfold :: MethodUnfold (MajorityConfig) "Describe" (MajorityConfig__Describeⁱᵐᵖˡ);
  #[global] MajorityConfig_Slice_unfold :: MethodUnfold (MajorityConfig) "Slice" (MajorityConfig__Sliceⁱᵐᵖˡ);
  #[global] MajorityConfig_String_unfold :: MethodUnfold (MajorityConfig) "String" (MajorityConfig__Stringⁱᵐᵖˡ);
  #[global] MajorityConfig_VoteResult_unfold :: MethodUnfold (MajorityConfig) "VoteResult" (MajorityConfig__VoteResultⁱᵐᵖˡ);
  #[global] MajorityConfig'ptr_CommittedIndex_unfold :: MethodUnfold (go.PointerType (MajorityConfig)) "CommittedIndex" (λ: "$r", MethodResolve (MajorityConfig) "CommittedIndex" (![(MajorityConfig)] "$r"));
  #[global] MajorityConfig'ptr_Describe_unfold :: MethodUnfold (go.PointerType (MajorityConfig)) "Describe" (λ: "$r", MethodResolve (MajorityConfig) "Describe" (![(MajorityConfig)] "$r"));
  #[global] MajorityConfig'ptr_Slice_unfold :: MethodUnfold (go.PointerType (MajorityConfig)) "Slice" (λ: "$r", MethodResolve (MajorityConfig) "Slice" (![(MajorityConfig)] "$r"));
  #[global] MajorityConfig'ptr_String_unfold :: MethodUnfold (go.PointerType (MajorityConfig)) "String" (λ: "$r", MethodResolve (MajorityConfig) "String" (![(MajorityConfig)] "$r"));
  #[global] MajorityConfig'ptr_VoteResult_unfold :: MethodUnfold (go.PointerType (MajorityConfig)) "VoteResult" (λ: "$r", MethodResolve (MajorityConfig) "VoteResult" (![(MajorityConfig)] "$r"));
}.

Module JointConfig.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := (array.t quorum.MajorityConfig.t 2).
End def.
End JointConfig.

Definition JointConfigⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.ArrayType 2 MajorityConfig.

Class JointConfig_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] JointConfig_underlying :: (JointConfig) <u (JointConfigⁱᵐᵖˡ);
  #[global] JointConfig_CommittedIndex_unfold :: MethodUnfold (JointConfig) "CommittedIndex" (JointConfig__CommittedIndexⁱᵐᵖˡ);
  #[global] JointConfig_Describe_unfold :: MethodUnfold (JointConfig) "Describe" (JointConfig__Describeⁱᵐᵖˡ);
  #[global] JointConfig_IDs_unfold :: MethodUnfold (JointConfig) "IDs" (JointConfig__IDsⁱᵐᵖˡ);
  #[global] JointConfig_String_unfold :: MethodUnfold (JointConfig) "String" (JointConfig__Stringⁱᵐᵖˡ);
  #[global] JointConfig_VoteResult_unfold :: MethodUnfold (JointConfig) "VoteResult" (JointConfig__VoteResultⁱᵐᵖˡ);
  #[global] JointConfig'ptr_CommittedIndex_unfold :: MethodUnfold (go.PointerType (JointConfig)) "CommittedIndex" (λ: "$r", MethodResolve (JointConfig) "CommittedIndex" (![(JointConfig)] "$r"));
  #[global] JointConfig'ptr_Describe_unfold :: MethodUnfold (go.PointerType (JointConfig)) "Describe" (λ: "$r", MethodResolve (JointConfig) "Describe" (![(JointConfig)] "$r"));
  #[global] JointConfig'ptr_IDs_unfold :: MethodUnfold (go.PointerType (JointConfig)) "IDs" (λ: "$r", MethodResolve (JointConfig) "IDs" (![(JointConfig)] "$r"));
  #[global] JointConfig'ptr_String_unfold :: MethodUnfold (go.PointerType (JointConfig)) "String" (λ: "$r", MethodResolve (JointConfig) "String" (![(JointConfig)] "$r"));
  #[global] JointConfig'ptr_VoteResult_unfold :: MethodUnfold (go.PointerType (JointConfig)) "VoteResult" (λ: "$r", MethodResolve (JointConfig) "VoteResult" (![(JointConfig)] "$r"));
}.

Module Index'.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := w64.
End def.
End Index'.

Definition Index'ⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.uint64.

Class Index_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Index_underlying :: (Index') <u (Index'ⁱᵐᵖˡ);
  #[global] Index_String_unfold :: MethodUnfold (Index') "String" (Index__Stringⁱᵐᵖˡ);
  #[global] Index'ptr_String_unfold :: MethodUnfold (go.PointerType (Index')) "String" (λ: "$r", MethodResolve (Index') "String" (![(Index')] "$r"));
}.

Module AckedIndexer.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := interface.t.
End def.
End AckedIndexer.

Definition AckedIndexerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.InterfaceType [go.MethodElem "AckedIndex"%go (go.Signature [go.uint64] false [Index'; go.bool])].

Class AckedIndexer_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] AckedIndexer_underlying :: (AckedIndexer) <u (AckedIndexerⁱᵐᵖˡ);
}.

Module mapAckIndexer.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := map.t.
End def.
End mapAckIndexer.

Definition mapAckIndexerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.MapType go.uint64 Index'.

Class mapAckIndexer_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] mapAckIndexer_underlying :: (mapAckIndexer) <u (mapAckIndexerⁱᵐᵖˡ);
  #[global] mapAckIndexer_AckedIndex_unfold :: MethodUnfold (mapAckIndexer) "AckedIndex" (mapAckIndexer__AckedIndexⁱᵐᵖˡ);
  #[global] mapAckIndexer'ptr_AckedIndex_unfold :: MethodUnfold (go.PointerType (mapAckIndexer)) "AckedIndex" (λ: "$r", MethodResolve (mapAckIndexer) "AckedIndex" (![(mapAckIndexer)] "$r"));
}.

Module VoteResult.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := w8.
End def.
End VoteResult.

Definition VoteResultⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.uint8.

Class VoteResult_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] VoteResult_underlying :: (VoteResult) <u (VoteResultⁱᵐᵖˡ);
  #[global] VoteResult_String_unfold :: MethodUnfold (VoteResult) "String" (VoteResult__Stringⁱᵐᵖˡ);
  #[global] VoteResult'ptr_String_unfold :: MethodUnfold (go.PointerType (VoteResult)) "String" (λ: "$r", MethodResolve (VoteResult) "String" (![(VoteResult)] "$r"));
}.

Class Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] JointConfig_instance :: JointConfig_Assumptions;
  #[global] MajorityConfig_instance :: MajorityConfig_Assumptions;
  #[global] Index_instance :: Index_Assumptions;
  #[global] AckedIndexer_instance :: AckedIndexer_Assumptions;
  #[global] mapAckIndexer_instance :: mapAckIndexer_Assumptions;
  #[global] VoteResult_instance :: VoteResult_Assumptions;
  #[global] import_fmt_Assumption :: fmt.Assumptions;
  #[global] import_math_Assumption :: math.Assumptions;
  #[global] import_strings_Assumption :: strings.Assumptions;
  #[global] import_slices_Assumption :: slices.Assumptions;
  #[global] import_strconv_Assumption :: strconv.Assumptions;
}.
End quorum.
