(* autogenerated from go.etcd.io/raft/v3/tracker *)
Require Export New.code.fmt.
Require Export New.code.strings.
Require Export New.code.go_etcd_io.raft.v3.quorum.slices.
Require Export New.code.go_etcd_io.raft.v3.quorum.
Require Export New.code.go_etcd_io.raft.v3.raftpb.
From New.golang Require Import defn.
Module pkg_id.
Definition tracker : go_string := "go.etcd.io/raft/v3/tracker".

End pkg_id.
Export pkg_id.
Module tracker.

Definition inflight {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/raft/v3/tracker.inflight"%go [].

Definition Inflights {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/raft/v3/tracker.Inflights"%go [].

Definition Progress {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/raft/v3/tracker.Progress"%go [].

Definition ProgressMap {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/raft/v3/tracker.ProgressMap"%go [].

Definition StateType {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/raft/v3/tracker.StateType"%go [].

Definition Config {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/raft/v3/tracker.Config"%go [].

Definition ProgressTracker {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/raft/v3/tracker.ProgressTracker"%go [].

Definition matchAckIndexer {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "go.etcd.io/raft/v3/tracker.matchAckIndexer"%go [].

Definition StateProbe {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 0).

Definition StateReplicate {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 1).

Definition StateSnapshot {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val := #(W64 2).

Definition prstmap {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3/tracker.prstmap"%go.

Definition NewInflights {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3/tracker.NewInflights"%go.

Definition MakeProgressTracker {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "go.etcd.io/raft/v3/tracker.MakeProgressTracker"%go.

(* NewInflights sets up an Inflights that allows up to size inflight messages,
   with the total byte size up to maxBytes. If maxBytes is 0 then there is no
   byte size limit. The maxBytes limit is soft, i.e. we accept a single message
   that brings it from size < maxBytes to size >= maxBytes.

   go: inflights.go:46:6 *)
Definition NewInflightsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "size" "maxBytes",
    exception_do (let: "maxBytes" := (GoAlloc go.uint64 "maxBytes") in
    let: "size" := (GoAlloc go.int "size") in
    return: (GoAlloc Inflights (CompositeLiteral Inflights (LiteralValue [KeyedElement (Some (KeyField "size"%go)) (ElementExpression go.int (![go.int] "size")); KeyedElement (Some (KeyField "maxBytes"%go)) (ElementExpression go.uint64 (![go.uint64] "maxBytes"))])))).

(* Clone returns an *Inflights that is identical to but shares no memory with
   the receiver.

   go: inflights.go:55:22 *)
Definition Inflights__Cloneⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "in" <>,
    exception_do (let: "in" := (GoAlloc (go.PointerType Inflights) "in") in
    let: "ins" := (GoAlloc Inflights (GoZeroVal Inflights #())) in
    let: "$r0" := (![Inflights] (![go.PointerType Inflights] "in")) in
    do:  ("ins" <-[Inflights] "$r0");;;
    let: "$r0" := (let: "$a0" := (Convert go.untyped_nil (go.SliceType inflight) UntypedNil) in
    let: "$a1" := (![go.SliceType inflight] (StructFieldRef Inflights "buffer"%go (![go.PointerType Inflights] "in"))) in
    (FuncResolve go.append [go.SliceType inflight] #()) "$a0" "$a1") in
    do:  ((StructFieldRef Inflights "buffer"%go "ins") <-[go.SliceType inflight] "$r0");;;
    return: ("ins")).

(* Add notifies the Inflights that a new message with the given index and byte
   size is being dispatched. Full() must be called prior to Add() to verify that
   there is room for one more message, and consecutive calls to Add() must
   provide a monotonic sequence of indexes.

   go: inflights.go:65:22 *)
Definition Inflights__Addⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "in" "index" "bytes",
    exception_do (let: "in" := (GoAlloc (go.PointerType Inflights) "in") in
    let: "bytes" := (GoAlloc go.uint64 "bytes") in
    let: "index" := (GoAlloc go.uint64 "index") in
    (if: (MethodResolve (go.PointerType Inflights) "Full"%go (![go.PointerType Inflights] "in")) #()
    then
      do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"cannot add into a Full inflights"%go) in
      (FuncResolve go.panic [] #()) "$a0")
    else do:  #());;;
    let: "next" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := ((![go.int] (StructFieldRef Inflights "start"%go (![go.PointerType Inflights] "in"))) +⟨go.int⟩ (![go.int] (StructFieldRef Inflights "count"%go (![go.PointerType Inflights] "in")))) in
    do:  ("next" <-[go.int] "$r0");;;
    let: "size" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := (![go.int] (StructFieldRef Inflights "size"%go (![go.PointerType Inflights] "in"))) in
    do:  ("size" <-[go.int] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.int] "next") ≥⟨go.int⟩ (![go.int] "size"))
    then do:  ("next" <-[go.int] ((![go.int] "next") -⟨go.int⟩ (![go.int] "size")))
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool ((![go.int] "next") ≥⟨go.int⟩ (let: "$a0" := (![go.SliceType inflight] (StructFieldRef Inflights "buffer"%go (![go.PointerType Inflights] "in"))) in
    (FuncResolve go.len [go.SliceType inflight] #()) "$a0"))
    then do:  ((MethodResolve (go.PointerType Inflights) "grow"%go (![go.PointerType Inflights] "in")) #())
    else do:  #());;;
    let: "$r0" := (CompositeLiteral inflight (LiteralValue [KeyedElement (Some (KeyField "index"%go)) (ElementExpression go.uint64 (![go.uint64] "index")); KeyedElement (Some (KeyField "bytes"%go)) (ElementExpression go.uint64 (![go.uint64] "bytes"))])) in
    do:  ((IndexRef (go.SliceType inflight) (![go.SliceType inflight] (StructFieldRef Inflights "buffer"%go (![go.PointerType Inflights] "in")), ![go.int] "next")) <-[inflight] "$r0");;;
    do:  ((StructFieldRef Inflights "count"%go (![go.PointerType Inflights] "in")) <-[go.int] ((![go.int] (StructFieldRef Inflights "count"%go (![go.PointerType Inflights] "in"))) +⟨go.int⟩ #(W64 1)));;;
    do:  ((StructFieldRef Inflights "bytes"%go (![go.PointerType Inflights] "in")) <-[go.uint64] ((![go.uint64] (StructFieldRef Inflights "bytes"%go (![go.PointerType Inflights] "in"))) +⟨go.uint64⟩ (![go.uint64] "bytes")));;;
    return: #()).

(* grow the inflight buffer by doubling up to inflights.size. We grow on demand
   instead of preallocating to inflights.size to handle systems which have
   thousands of Raft groups per process.

   go: inflights.go:85:22 *)
Definition Inflights__growⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "in" <>,
    exception_do (let: "in" := (GoAlloc (go.PointerType Inflights) "in") in
    let: "newSize" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := ((let: "$a0" := (![go.SliceType inflight] (StructFieldRef Inflights "buffer"%go (![go.PointerType Inflights] "in"))) in
    (FuncResolve go.len [go.SliceType inflight] #()) "$a0") *⟨go.int⟩ #(W64 2)) in
    do:  ("newSize" <-[go.int] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.int] "newSize") =⟨go.int⟩ #(W64 0))
    then
      let: "$r0" := #(W64 1) in
      do:  ("newSize" <-[go.int] "$r0")
    else
      (if: Convert go.untyped_bool go.bool ((![go.int] "newSize") >⟨go.int⟩ (![go.int] (StructFieldRef Inflights "size"%go (![go.PointerType Inflights] "in"))))
      then
        let: "$r0" := (![go.int] (StructFieldRef Inflights "size"%go (![go.PointerType Inflights] "in"))) in
        do:  ("newSize" <-[go.int] "$r0")
      else do:  #()));;;
    let: "newBuffer" := (GoAlloc (go.SliceType inflight) (GoZeroVal (go.SliceType inflight) #())) in
    let: "$r0" := ((FuncResolve go.make2 [go.SliceType inflight] #()) (![go.int] "newSize")) in
    do:  ("newBuffer" <-[go.SliceType inflight] "$r0");;;
    do:  (let: "$a0" := (![go.SliceType inflight] "newBuffer") in
    let: "$a1" := (![go.SliceType inflight] (StructFieldRef Inflights "buffer"%go (![go.PointerType Inflights] "in"))) in
    (FuncResolve go.copy [go.SliceType inflight] #()) "$a0" "$a1");;;
    let: "$r0" := (![go.SliceType inflight] "newBuffer") in
    do:  ((StructFieldRef Inflights "buffer"%go (![go.PointerType Inflights] "in")) <-[go.SliceType inflight] "$r0");;;
    return: #()).

(* FreeLE frees the inflights smaller or equal to the given `to` flight.

   go: inflights.go:98:22 *)
Definition Inflights__FreeLEⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "in" "to",
    exception_do (let: "in" := (GoAlloc (go.PointerType Inflights) "in") in
    let: "to" := (GoAlloc go.uint64 "to") in
    (if: Convert go.untyped_bool go.bool (((![go.int] (StructFieldRef Inflights "count"%go (![go.PointerType Inflights] "in"))) =⟨go.int⟩ #(W64 0)) || ((![go.uint64] "to") <⟨go.uint64⟩ (![go.uint64] (StructFieldRef inflight "index"%go (IndexRef (go.SliceType inflight) (![go.SliceType inflight] (StructFieldRef Inflights "buffer"%go (![go.PointerType Inflights] "in")), ![go.int] (StructFieldRef Inflights "start"%go (![go.PointerType Inflights] "in"))))))))
    then return: (#())
    else do:  #());;;
    let: "idx" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := (![go.int] (StructFieldRef Inflights "start"%go (![go.PointerType Inflights] "in"))) in
    do:  ("idx" <-[go.int] "$r0");;;
    let: "i" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "bytes" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    (let: "$r0" := #(W64 0) in
    do:  ("i" <-[go.int] "$r0");;;
    (for: (λ: <>, (![go.int] "i") <⟨go.int⟩ (![go.int] (StructFieldRef Inflights "count"%go (![go.PointerType Inflights] "in")))); (λ: <>, do:  ("i" <-[go.int] ((![go.int] "i") +⟨go.int⟩ #(W64 1)))) := λ: <>,
      (if: Convert go.untyped_bool go.bool ((![go.uint64] "to") <⟨go.uint64⟩ (![go.uint64] (StructFieldRef inflight "index"%go (IndexRef (go.SliceType inflight) (![go.SliceType inflight] (StructFieldRef Inflights "buffer"%go (![go.PointerType Inflights] "in")), ![go.int] "idx")))))
      then break: #()
      else do:  #());;;
      do:  ("bytes" <-[go.uint64] ((![go.uint64] "bytes") +⟨go.uint64⟩ (![go.uint64] (StructFieldRef inflight "bytes"%go (IndexRef (go.SliceType inflight) (![go.SliceType inflight] (StructFieldRef Inflights "buffer"%go (![go.PointerType Inflights] "in")), ![go.int] "idx"))))));;;
      let: "size" := (GoAlloc go.int (GoZeroVal go.int #())) in
      let: "$r0" := (![go.int] (StructFieldRef Inflights "size"%go (![go.PointerType Inflights] "in"))) in
      do:  ("size" <-[go.int] "$r0");;;
      (do:  ("idx" <-[go.int] ((![go.int] "idx") +⟨go.int⟩ #(W64 1)));;;
      (if: Convert go.untyped_bool go.bool ((![go.int] "idx") ≥⟨go.int⟩ (![go.int] "size"))
      then do:  ("idx" <-[go.int] ((![go.int] "idx") -⟨go.int⟩ (![go.int] "size")))
      else do:  #()))));;;
    do:  ((StructFieldRef Inflights "count"%go (![go.PointerType Inflights] "in")) <-[go.int] ((![go.int] (StructFieldRef Inflights "count"%go (![go.PointerType Inflights] "in"))) -⟨go.int⟩ (![go.int] "i")));;;
    do:  ((StructFieldRef Inflights "bytes"%go (![go.PointerType Inflights] "in")) <-[go.uint64] ((![go.uint64] (StructFieldRef Inflights "bytes"%go (![go.PointerType Inflights] "in"))) -⟨go.uint64⟩ (![go.uint64] "bytes")));;;
    let: "$r0" := (![go.int] "idx") in
    do:  ((StructFieldRef Inflights "start"%go (![go.PointerType Inflights] "in")) <-[go.int] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.int] (StructFieldRef Inflights "count"%go (![go.PointerType Inflights] "in"))) =⟨go.int⟩ #(W64 0))
    then
      let: "$r0" := #(W64 0) in
      do:  ((StructFieldRef Inflights "start"%go (![go.PointerType Inflights] "in")) <-[go.int] "$r0")
    else do:  #());;;
    return: #()).

(* Full returns true if no more messages can be sent at the moment.

   go: inflights.go:131:22 *)
Definition Inflights__Fullⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "in" <>,
    exception_do (let: "in" := (GoAlloc (go.PointerType Inflights) "in") in
    return: (((![go.int] (StructFieldRef Inflights "count"%go (![go.PointerType Inflights] "in"))) =⟨go.int⟩ (![go.int] (StructFieldRef Inflights "size"%go (![go.PointerType Inflights] "in")))) || (((![go.uint64] (StructFieldRef Inflights "maxBytes"%go (![go.PointerType Inflights] "in"))) ≠⟨go.uint64⟩ #(W64 0)) && ((![go.uint64] (StructFieldRef Inflights "bytes"%go (![go.PointerType Inflights] "in"))) ≥⟨go.uint64⟩ (![go.uint64] (StructFieldRef Inflights "maxBytes"%go (![go.PointerType Inflights] "in"))))))).

(* Count returns the number of inflight messages.

   go: inflights.go:136:22 *)
Definition Inflights__Countⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "in" <>,
    exception_do (let: "in" := (GoAlloc (go.PointerType Inflights) "in") in
    return: (![go.int] (StructFieldRef Inflights "count"%go (![go.PointerType Inflights] "in")))).

(* reset frees all inflights.

   go: inflights.go:139:22 *)
Definition Inflights__resetⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "in" <>,
    exception_do (let: "in" := (GoAlloc (go.PointerType Inflights) "in") in
    let: "$r0" := #(W64 0) in
    do:  ((StructFieldRef Inflights "start"%go (![go.PointerType Inflights] "in")) <-[go.int] "$r0");;;
    let: "$r0" := #(W64 0) in
    do:  ((StructFieldRef Inflights "count"%go (![go.PointerType Inflights] "in")) <-[go.int] "$r0");;;
    let: "$r0" := #(W64 0) in
    do:  ((StructFieldRef Inflights "bytes"%go (![go.PointerType Inflights] "in")) <-[go.uint64] "$r0");;;
    return: #()).

(* ResetState moves the Progress into the specified State, resetting MsgAppFlowPaused,
   PendingSnapshot, and Inflights.

   go: progress.go:122:21 *)
Definition Progress__ResetStateⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "pr" "state",
    exception_do (let: "pr" := (GoAlloc (go.PointerType Progress) "pr") in
    let: "state" := (GoAlloc StateType "state") in
    let: "$r0" := #false in
    do:  ((StructFieldRef Progress "MsgAppFlowPaused"%go (![go.PointerType Progress] "pr")) <-[go.bool] "$r0");;;
    let: "$r0" := #(W64 0) in
    do:  ((StructFieldRef Progress "PendingSnapshot"%go (![go.PointerType Progress] "pr")) <-[go.uint64] "$r0");;;
    let: "$r0" := (![StateType] "state") in
    do:  ((StructFieldRef Progress "State"%go (![go.PointerType Progress] "pr")) <-[StateType] "$r0");;;
    do:  ((MethodResolve (go.PointerType Inflights) "reset"%go (![go.PointerType Inflights] (StructFieldRef Progress "Inflights"%go (![go.PointerType Progress] "pr")))) #());;;
    return: #()).

(* BecomeProbe transitions into StateProbe. Next is reset to Match+1 or,
   optionally and if larger, the index of the pending snapshot.

   go: progress.go:131:21 *)
Definition Progress__BecomeProbeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "pr" <>,
    exception_do (let: "pr" := (GoAlloc (go.PointerType Progress) "pr") in
    (if: Convert go.untyped_bool go.bool ((![StateType] (StructFieldRef Progress "State"%go (![go.PointerType Progress] "pr"))) =⟨go.uint64⟩ StateSnapshot)
    then
      let: "pendingSnapshot" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      let: "$r0" := (![go.uint64] (StructFieldRef Progress "PendingSnapshot"%go (![go.PointerType Progress] "pr"))) in
      do:  ("pendingSnapshot" <-[go.uint64] "$r0");;;
      do:  (let: "$a0" := StateProbe in
      (MethodResolve (go.PointerType Progress) "ResetState"%go (![go.PointerType Progress] "pr")) "$a0");;;
      let: "$r0" := (let: "$a0" := ((![go.uint64] (StructFieldRef Progress "Match"%go (![go.PointerType Progress] "pr"))) +⟨go.uint64⟩ #(W64 1)) in
      let: "$a1" := ((![go.uint64] "pendingSnapshot") +⟨go.uint64⟩ #(W64 1)) in
      (FuncResolve go.max [go.uint64; go.uint64] #()) "$a0" "$a1") in
      do:  ((StructFieldRef Progress "Next"%go (![go.PointerType Progress] "pr")) <-[go.uint64] "$r0")
    else
      do:  (let: "$a0" := StateProbe in
      (MethodResolve (go.PointerType Progress) "ResetState"%go (![go.PointerType Progress] "pr")) "$a0");;;
      let: "$r0" := ((![go.uint64] (StructFieldRef Progress "Match"%go (![go.PointerType Progress] "pr"))) +⟨go.uint64⟩ #(W64 1)) in
      do:  ((StructFieldRef Progress "Next"%go (![go.PointerType Progress] "pr")) <-[go.uint64] "$r0"));;;
    let: "$r0" := (let: "$a0" := (![go.uint64] (StructFieldRef Progress "sentCommit"%go (![go.PointerType Progress] "pr"))) in
    let: "$a1" := ((![go.uint64] (StructFieldRef Progress "Next"%go (![go.PointerType Progress] "pr"))) -⟨go.uint64⟩ #(W64 1)) in
    (FuncResolve go.min [go.uint64; go.uint64] #()) "$a0" "$a1") in
    do:  ((StructFieldRef Progress "sentCommit"%go (![go.PointerType Progress] "pr")) <-[go.uint64] "$r0");;;
    return: #()).

(* BecomeReplicate transitions into StateReplicate, resetting Next to Match+1.

   go: progress.go:147:21 *)
Definition Progress__BecomeReplicateⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "pr" <>,
    exception_do (let: "pr" := (GoAlloc (go.PointerType Progress) "pr") in
    do:  (let: "$a0" := StateReplicate in
    (MethodResolve (go.PointerType Progress) "ResetState"%go (![go.PointerType Progress] "pr")) "$a0");;;
    let: "$r0" := ((![go.uint64] (StructFieldRef Progress "Match"%go (![go.PointerType Progress] "pr"))) +⟨go.uint64⟩ #(W64 1)) in
    do:  ((StructFieldRef Progress "Next"%go (![go.PointerType Progress] "pr")) <-[go.uint64] "$r0");;;
    return: #()).

(* BecomeSnapshot moves the Progress to StateSnapshot with the specified pending
   snapshot index.

   go: progress.go:154:21 *)
Definition Progress__BecomeSnapshotⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "pr" "snapshoti",
    exception_do (let: "pr" := (GoAlloc (go.PointerType Progress) "pr") in
    let: "snapshoti" := (GoAlloc go.uint64 "snapshoti") in
    do:  (let: "$a0" := StateSnapshot in
    (MethodResolve (go.PointerType Progress) "ResetState"%go (![go.PointerType Progress] "pr")) "$a0");;;
    let: "$r0" := (![go.uint64] "snapshoti") in
    do:  ((StructFieldRef Progress "PendingSnapshot"%go (![go.PointerType Progress] "pr")) <-[go.uint64] "$r0");;;
    let: "$r0" := ((![go.uint64] "snapshoti") +⟨go.uint64⟩ #(W64 1)) in
    do:  ((StructFieldRef Progress "Next"%go (![go.PointerType Progress] "pr")) <-[go.uint64] "$r0");;;
    let: "$r0" := (![go.uint64] "snapshoti") in
    do:  ((StructFieldRef Progress "sentCommit"%go (![go.PointerType Progress] "pr")) <-[go.uint64] "$r0");;;
    return: #()).

(* SentEntries updates the progress on the given number of consecutive entries
   being sent in a MsgApp, with the given total bytes size, appended at log
   indices >= pr.Next.

   Must be used with StateProbe or StateReplicate.

   go: progress.go:166:21 *)
Definition Progress__SentEntriesⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "pr" "entries" "bytes",
    exception_do (let: "pr" := (GoAlloc (go.PointerType Progress) "pr") in
    let: "bytes" := (GoAlloc go.uint64 "bytes") in
    let: "entries" := (GoAlloc go.int "entries") in
    let: "$sw" := (![StateType] (StructFieldRef Progress "State"%go (![go.PointerType Progress] "pr"))) in
    (if: "$sw" =⟨StateType⟩ StateReplicate
    then
      (if: Convert go.untyped_bool go.bool ((![go.int] "entries") >⟨go.int⟩ #(W64 0))
      then
        do:  ((StructFieldRef Progress "Next"%go (![go.PointerType Progress] "pr")) <-[go.uint64] ((![go.uint64] (StructFieldRef Progress "Next"%go (![go.PointerType Progress] "pr"))) +⟨go.uint64⟩ (Convert go.int go.uint64 (![go.int] "entries"))));;;
        do:  (let: "$a0" := ((![go.uint64] (StructFieldRef Progress "Next"%go (![go.PointerType Progress] "pr"))) -⟨go.uint64⟩ #(W64 1)) in
        let: "$a1" := (![go.uint64] "bytes") in
        (MethodResolve (go.PointerType Inflights) "Add"%go (![go.PointerType Inflights] (StructFieldRef Progress "Inflights"%go (![go.PointerType Progress] "pr")))) "$a0" "$a1")
      else do:  #());;;
      let: "$r0" := ((MethodResolve (go.PointerType Inflights) "Full"%go (![go.PointerType Inflights] (StructFieldRef Progress "Inflights"%go (![go.PointerType Progress] "pr")))) #()) in
      do:  ((StructFieldRef Progress "MsgAppFlowPaused"%go (![go.PointerType Progress] "pr")) <-[go.bool] "$r0")
    else
      (if: "$sw" =⟨StateType⟩ StateProbe
      then
        (if: Convert go.untyped_bool go.bool ((![go.int] "entries") >⟨go.int⟩ #(W64 0))
        then
          let: "$r0" := #true in
          do:  ((StructFieldRef Progress "MsgAppFlowPaused"%go (![go.PointerType Progress] "pr")) <-[go.bool] "$r0")
        else do:  #())
      else
        do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) (let: "$a0" := #"sending append in unhandled state %s"%go in
        let: "$a1" := ((let: "$sl0" := (Convert StateType go.any (![StateType] (StructFieldRef Progress "State"%go (![go.PointerType Progress] "pr")))) in
        CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0")]))) in
        (FuncResolve fmt.Sprintf [] #()) "$a0" "$a1")) in
        (FuncResolve go.panic [] #()) "$a0")));;;
    return: #()).

(* CanBumpCommit returns true if sending the given commit index can potentially
   advance the follower's commit index.

   go: progress.go:190:21 *)
Definition Progress__CanBumpCommitⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "pr" "index",
    exception_do (let: "pr" := (GoAlloc (go.PointerType Progress) "pr") in
    let: "index" := (GoAlloc go.uint64 "index") in
    return: (((![go.uint64] "index") >⟨go.uint64⟩ (![go.uint64] (StructFieldRef Progress "sentCommit"%go (![go.PointerType Progress] "pr")))) && ((![go.uint64] (StructFieldRef Progress "sentCommit"%go (![go.PointerType Progress] "pr"))) <⟨go.uint64⟩ ((![go.uint64] (StructFieldRef Progress "Next"%go (![go.PointerType Progress] "pr"))) -⟨go.uint64⟩ #(W64 1))))).

(* SentCommit updates the sentCommit.

   go: progress.go:199:21 *)
Definition Progress__SentCommitⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "pr" "commit",
    exception_do (let: "pr" := (GoAlloc (go.PointerType Progress) "pr") in
    let: "commit" := (GoAlloc go.uint64 "commit") in
    let: "$r0" := (![go.uint64] "commit") in
    do:  ((StructFieldRef Progress "sentCommit"%go (![go.PointerType Progress] "pr")) <-[go.uint64] "$r0");;;
    return: #()).

(* MaybeUpdate is called when an MsgAppResp arrives from the follower, with the
   index acked by it. The method returns false if the given n index comes from
   an outdated message. Otherwise it updates the progress and returns true.

   go: progress.go:206:21 *)
Definition Progress__MaybeUpdateⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "pr" "n",
    exception_do (let: "pr" := (GoAlloc (go.PointerType Progress) "pr") in
    let: "n" := (GoAlloc go.uint64 "n") in
    (if: Convert go.untyped_bool go.bool ((![go.uint64] "n") ≤⟨go.uint64⟩ (![go.uint64] (StructFieldRef Progress "Match"%go (![go.PointerType Progress] "pr"))))
    then return: (#false)
    else do:  #());;;
    let: "$r0" := (![go.uint64] "n") in
    do:  ((StructFieldRef Progress "Match"%go (![go.PointerType Progress] "pr")) <-[go.uint64] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.uint64] (StructFieldRef Progress "Next"%go (![go.PointerType Progress] "pr"))) in
    let: "$a1" := ((![go.uint64] "n") +⟨go.uint64⟩ #(W64 1)) in
    (FuncResolve go.max [go.uint64; go.uint64] #()) "$a0" "$a1") in
    do:  ((StructFieldRef Progress "Next"%go (![go.PointerType Progress] "pr")) <-[go.uint64] "$r0");;;
    let: "$r0" := #false in
    do:  ((StructFieldRef Progress "MsgAppFlowPaused"%go (![go.PointerType Progress] "pr")) <-[go.bool] "$r0");;;
    return: (#true)).

(* MaybeDecrTo adjusts the Progress to the receipt of a MsgApp rejection. The
   arguments are the index of the append message rejected by the follower, and
   the hint that we want to decrease to.

   Rejections can happen spuriously as messages are sent out of order or
   duplicated. In such cases, the rejection pertains to an index that the
   Progress already knows were previously acknowledged, and false is returned
   without changing the Progress.

   If the rejection is genuine, Next is lowered sensibly, and the Progress is
   cleared for sending log entries.

   go: progress.go:227:21 *)
Definition Progress__MaybeDecrToⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "pr" "rejected" "matchHint",
    exception_do (let: "pr" := (GoAlloc (go.PointerType Progress) "pr") in
    let: "matchHint" := (GoAlloc go.uint64 "matchHint") in
    let: "rejected" := (GoAlloc go.uint64 "rejected") in
    (if: Convert go.untyped_bool go.bool ((![StateType] (StructFieldRef Progress "State"%go (![go.PointerType Progress] "pr"))) =⟨go.uint64⟩ StateReplicate)
    then
      (if: Convert go.untyped_bool go.bool ((![go.uint64] "rejected") ≤⟨go.uint64⟩ (![go.uint64] (StructFieldRef Progress "Match"%go (![go.PointerType Progress] "pr"))))
      then return: (#false)
      else do:  #());;;
      let: "$r0" := ((![go.uint64] (StructFieldRef Progress "Match"%go (![go.PointerType Progress] "pr"))) +⟨go.uint64⟩ #(W64 1)) in
      do:  ((StructFieldRef Progress "Next"%go (![go.PointerType Progress] "pr")) <-[go.uint64] "$r0");;;
      let: "$r0" := (let: "$a0" := (![go.uint64] (StructFieldRef Progress "sentCommit"%go (![go.PointerType Progress] "pr"))) in
      let: "$a1" := ((![go.uint64] (StructFieldRef Progress "Next"%go (![go.PointerType Progress] "pr"))) -⟨go.uint64⟩ #(W64 1)) in
      (FuncResolve go.min [go.uint64; go.uint64] #()) "$a0" "$a1") in
      do:  ((StructFieldRef Progress "sentCommit"%go (![go.PointerType Progress] "pr")) <-[go.uint64] "$r0");;;
      return: (#true)
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool (((![go.uint64] (StructFieldRef Progress "Next"%go (![go.PointerType Progress] "pr"))) -⟨go.uint64⟩ #(W64 1)) ≠⟨go.uint64⟩ (![go.uint64] "rejected"))
    then return: (#false)
    else do:  #());;;
    let: "$r0" := (let: "$a0" := (let: "$a0" := (![go.uint64] "rejected") in
    let: "$a1" := ((![go.uint64] "matchHint") +⟨go.uint64⟩ #(W64 1)) in
    (FuncResolve go.min [go.uint64; go.uint64] #()) "$a0" "$a1") in
    let: "$a1" := ((![go.uint64] (StructFieldRef Progress "Match"%go (![go.PointerType Progress] "pr"))) +⟨go.uint64⟩ #(W64 1)) in
    (FuncResolve go.max [go.uint64; go.uint64] #()) "$a0" "$a1") in
    do:  ((StructFieldRef Progress "Next"%go (![go.PointerType Progress] "pr")) <-[go.uint64] "$r0");;;
    let: "$r0" := (let: "$a0" := (![go.uint64] (StructFieldRef Progress "sentCommit"%go (![go.PointerType Progress] "pr"))) in
    let: "$a1" := ((![go.uint64] (StructFieldRef Progress "Next"%go (![go.PointerType Progress] "pr"))) -⟨go.uint64⟩ #(W64 1)) in
    (FuncResolve go.min [go.uint64; go.uint64] #()) "$a0" "$a1") in
    do:  ((StructFieldRef Progress "sentCommit"%go (![go.PointerType Progress] "pr")) <-[go.uint64] "$r0");;;
    let: "$r0" := #false in
    do:  ((StructFieldRef Progress "MsgAppFlowPaused"%go (![go.PointerType Progress] "pr")) <-[go.bool] "$r0");;;
    return: (#true)).

(* IsPaused returns whether sending log entries to this node has been throttled.
   This is done when a node has rejected recent MsgApps, is currently waiting
   for a snapshot, or has reached the MaxInflightMsgs limit. In normal
   operation, this is false. A throttled node will be contacted less frequently
   until it has reached a state in which it's able to accept a steady stream of
   log entries again.

   go: progress.go:263:21 *)
Definition Progress__IsPausedⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "pr" <>,
    exception_do (let: "pr" := (GoAlloc (go.PointerType Progress) "pr") in
    let: "$sw" := (![StateType] (StructFieldRef Progress "State"%go (![go.PointerType Progress] "pr"))) in
    (if: "$sw" =⟨StateType⟩ StateProbe
    then return: (![go.bool] (StructFieldRef Progress "MsgAppFlowPaused"%go (![go.PointerType Progress] "pr")))
    else
      (if: "$sw" =⟨StateType⟩ StateReplicate
      then return: (![go.bool] (StructFieldRef Progress "MsgAppFlowPaused"%go (![go.PointerType Progress] "pr")))
      else
        (if: "$sw" =⟨StateType⟩ StateSnapshot
        then return: (#true)
        else
          do:  (let: "$a0" := (Convert go.string (go.InterfaceType []) #"unexpected state"%go) in
          (FuncResolve go.panic [] #()) "$a0"))))).

(* go: progress.go:276:21 *)
Definition Progress__Stringⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "pr" <>,
    exception_do (let: "pr" := (GoAlloc (go.PointerType Progress) "pr") in
    let: "buf" := (GoAlloc strings.Builder (GoZeroVal strings.Builder #())) in
    do:  (let: "$a0" := (Convert (go.PointerType strings.Builder) io.Writer "buf") in
    let: "$a1" := #"%s match=%d next=%d"%go in
    let: "$a2" := ((let: "$sl0" := (Convert StateType go.any (![StateType] (StructFieldRef Progress "State"%go (![go.PointerType Progress] "pr")))) in
    let: "$sl1" := (Convert go.uint64 go.any (![go.uint64] (StructFieldRef Progress "Match"%go (![go.PointerType Progress] "pr")))) in
    let: "$sl2" := (Convert go.uint64 go.any (![go.uint64] (StructFieldRef Progress "Next"%go (![go.PointerType Progress] "pr")))) in
    CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0"); KeyedElement None (ElementExpression go.any "$sl1"); KeyedElement None (ElementExpression go.any "$sl2")]))) in
    (FuncResolve fmt.Fprintf [] #()) "$a0" "$a1" "$a2");;;
    (if: ![go.bool] (StructFieldRef Progress "IsLearner"%go (![go.PointerType Progress] "pr"))
    then
      do:  (let: "$a0" := (Convert (go.PointerType strings.Builder) io.Writer "buf") in
      let: "$a1" := ((let: "$sl0" := (Convert go.string go.any #" learner"%go) in
      CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0")]))) in
      (FuncResolve fmt.Fprint [] #()) "$a0" "$a1")
    else do:  #());;;
    (if: (MethodResolve (go.PointerType Progress) "IsPaused"%go (![go.PointerType Progress] "pr")) #()
    then
      do:  (let: "$a0" := (Convert (go.PointerType strings.Builder) io.Writer "buf") in
      let: "$a1" := ((let: "$sl0" := (Convert go.string go.any #" paused"%go) in
      CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0")]))) in
      (FuncResolve fmt.Fprint [] #()) "$a0" "$a1")
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool ((![go.uint64] (StructFieldRef Progress "PendingSnapshot"%go (![go.PointerType Progress] "pr"))) >⟨go.uint64⟩ #(W64 0))
    then
      do:  (let: "$a0" := (Convert (go.PointerType strings.Builder) io.Writer "buf") in
      let: "$a1" := #" pendingSnap=%d"%go in
      let: "$a2" := ((let: "$sl0" := (Convert go.uint64 go.any (![go.uint64] (StructFieldRef Progress "PendingSnapshot"%go (![go.PointerType Progress] "pr")))) in
      CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0")]))) in
      (FuncResolve fmt.Fprintf [] #()) "$a0" "$a1" "$a2")
    else do:  #());;;
    (if: (⟨go.bool⟩! (![go.bool] (StructFieldRef Progress "RecentActive"%go (![go.PointerType Progress] "pr"))))
    then
      do:  (let: "$a0" := (Convert (go.PointerType strings.Builder) io.Writer "buf") in
      let: "$a1" := ((let: "$sl0" := (Convert go.string go.any #" inactive"%go) in
      CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0")]))) in
      (FuncResolve fmt.Fprint [] #()) "$a0" "$a1")
    else do:  #());;;
    (let: "n" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := ((MethodResolve (go.PointerType Inflights) "Count"%go (![go.PointerType Inflights] (StructFieldRef Progress "Inflights"%go (![go.PointerType Progress] "pr")))) #()) in
    do:  ("n" <-[go.int] "$r0");;;
    (if: Convert go.untyped_bool go.bool ((![go.int] "n") >⟨go.int⟩ #(W64 0))
    then
      do:  (let: "$a0" := (Convert (go.PointerType strings.Builder) io.Writer "buf") in
      let: "$a1" := #" inflight=%d"%go in
      let: "$a2" := ((let: "$sl0" := (Convert go.int go.any (![go.int] "n")) in
      CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0")]))) in
      (FuncResolve fmt.Fprintf [] #()) "$a0" "$a1" "$a2");;;
      (if: (MethodResolve (go.PointerType Inflights) "Full"%go (![go.PointerType Inflights] (StructFieldRef Progress "Inflights"%go (![go.PointerType Progress] "pr")))) #()
      then
        do:  (let: "$a0" := (Convert (go.PointerType strings.Builder) io.Writer "buf") in
        let: "$a1" := ((let: "$sl0" := (Convert go.string go.any #"[full]"%go) in
        CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0")]))) in
        (FuncResolve fmt.Fprint [] #()) "$a0" "$a1")
      else do:  #())
    else do:  #()));;;
    return: ((MethodResolve (go.PointerType strings.Builder) "String"%go "buf") #())).

(* String prints the ProgressMap in sorted key order, one Progress per line.

   go: progress.go:304:22 *)
Definition ProgressMap__Stringⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "m" <>,
    exception_do (let: "m" := (GoAlloc ProgressMap "m") in
    let: "ids" := (GoAlloc (go.SliceType go.uint64) (GoZeroVal (go.SliceType go.uint64) #())) in
    let: "$r0" := ((FuncResolve go.make3 [go.SliceType go.uint64] #()) #(W64 0) (let: "$a0" := (![ProgressMap] "m") in
    (FuncResolve go.len [ProgressMap] #()) "$a0")) in
    do:  ("ids" <-[go.SliceType go.uint64] "$r0");;;
    let: "$range" := (![ProgressMap] "m") in
    (let: "k" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    map.for_range go.uint64 (go.PointerType Progress) "$range" (λ: "$key" "value",
      do:  ("k" <-[go.uint64] "$key");;;
      let: "$r0" := (let: "$a0" := (![go.SliceType go.uint64] "ids") in
      let: "$a1" := ((let: "$sl0" := (![go.uint64] "k") in
      CompositeLiteral (go.SliceType go.uint64) (LiteralValue [KeyedElement None (ElementExpression go.uint64 "$sl0")]))) in
      (FuncResolve go.append [go.SliceType go.uint64] #()) "$a0" "$a1") in
      do:  ("ids" <-[go.SliceType go.uint64] "$r0")));;;
    do:  (let: "$a0" := (![go.SliceType go.uint64] "ids") in
    (FuncResolve slices.SortUint64 [] #()) "$a0");;;
    let: "buf" := (GoAlloc strings.Builder (GoZeroVal strings.Builder #())) in
    let: "$range" := (![go.SliceType go.uint64] "ids") in
    (let: "id" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    slice.for_range go.uint64 "$range" (λ: "$key" "$value",
      do:  ("id" <-[go.uint64] "$value");;;
      do:  "$key";;;
      do:  (let: "$a0" := (Convert (go.PointerType strings.Builder) io.Writer "buf") in
      let: "$a1" := #"%d: %s
      "%go in
      let: "$a2" := ((let: "$sl0" := (Convert go.uint64 go.any (![go.uint64] "id")) in
      let: "$sl1" := (Convert (go.PointerType Progress) go.any (map.lookup1 go.uint64 (go.PointerType Progress) (![ProgressMap] "m") (![go.uint64] "id"))) in
      CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0"); KeyedElement None (ElementExpression go.any "$sl1")]))) in
      (FuncResolve fmt.Fprintf [] #()) "$a0" "$a1" "$a2")));;;
    return: ((MethodResolve (go.PointerType strings.Builder) "String"%go "buf") #())).

(* go: state.go:42:21 *)
Definition StateType__Stringⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "st" <>,
    exception_do (let: "st" := (GoAlloc StateType "st") in
    return: (![go.string] (IndexRef (go.ArrayType 3 go.string) (![go.ArrayType 3 go.string] (GlobalVarAddr prstmap #()), Convert StateType go.int (![StateType] "st"))))).

(* go: tracker.go:80:17 *)
Definition Config__Stringⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "c" <>,
    exception_do (let: "c" := (GoAlloc Config "c") in
    let: "buf" := (GoAlloc strings.Builder (GoZeroVal strings.Builder #())) in
    do:  (let: "$a0" := (Convert (go.PointerType strings.Builder) io.Writer "buf") in
    let: "$a1" := #"voters=%s"%go in
    let: "$a2" := ((let: "$sl0" := (Convert quorum.JointConfig go.any (![quorum.JointConfig] (StructFieldRef Config "Voters"%go "c"))) in
    CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0")]))) in
    (FuncResolve fmt.Fprintf [] #()) "$a0" "$a1" "$a2");;;
    (if: Convert go.untyped_bool go.bool ((![go.MapType go.uint64 (go.StructType [

    ])] (StructFieldRef Config "Learners"%go "c")) ≠⟨go.MapType go.uint64 (go.StructType [

    ])⟩ (Convert go.untyped_nil (go.MapType go.uint64 (go.StructType [

    ])) UntypedNil))
    then
      do:  (let: "$a0" := (Convert (go.PointerType strings.Builder) io.Writer "buf") in
      let: "$a1" := #" learners=%s"%go in
      let: "$a2" := ((let: "$sl0" := (Convert go.string go.any ((MethodResolve quorum.MajorityConfig "String"%go (![go.MapType go.uint64 (go.StructType [

      ])] (StructFieldRef Config "Learners"%go "c"))) #())) in
      CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0")]))) in
      (FuncResolve fmt.Fprintf [] #()) "$a0" "$a1" "$a2")
    else do:  #());;;
    (if: Convert go.untyped_bool go.bool ((![go.MapType go.uint64 (go.StructType [

    ])] (StructFieldRef Config "LearnersNext"%go "c")) ≠⟨go.MapType go.uint64 (go.StructType [

    ])⟩ (Convert go.untyped_nil (go.MapType go.uint64 (go.StructType [

    ])) UntypedNil))
    then
      do:  (let: "$a0" := (Convert (go.PointerType strings.Builder) io.Writer "buf") in
      let: "$a1" := #" learners_next=%s"%go in
      let: "$a2" := ((let: "$sl0" := (Convert go.string go.any ((MethodResolve quorum.MajorityConfig "String"%go (![go.MapType go.uint64 (go.StructType [

      ])] (StructFieldRef Config "LearnersNext"%go "c"))) #())) in
      CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0")]))) in
      (FuncResolve fmt.Fprintf [] #()) "$a0" "$a1" "$a2")
    else do:  #());;;
    (if: ![go.bool] (StructFieldRef Config "AutoLeave"%go "c")
    then
      do:  (let: "$a0" := (Convert (go.PointerType strings.Builder) io.Writer "buf") in
      let: "$a1" := ((let: "$sl0" := (Convert go.string go.any #" autoleave"%go) in
      CompositeLiteral (go.SliceType go.any) (LiteralValue [KeyedElement None (ElementExpression go.any "$sl0")]))) in
      (FuncResolve fmt.Fprint [] #()) "$a0" "$a1")
    else do:  #());;;
    return: ((MethodResolve (go.PointerType strings.Builder) "String"%go "buf") #())).

(* Clone returns a copy of the Config that shares no memory with the original.

   go: tracker.go:96:18 *)
Definition Config__Cloneⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "c" <>,
    exception_do (let: "c" := (GoAlloc (go.PointerType Config) "c") in
    let: "clone" := (GoAlloc (go.FunctionType (go.Signature [go.MapType go.uint64 (go.StructType [

     ])] false [go.MapType go.uint64 (go.StructType [

     ])])) (GoZeroVal (go.FunctionType (go.Signature [go.MapType go.uint64 (go.StructType [

     ])] false [go.MapType go.uint64 (go.StructType [

     ])])) #())) in
    let: "$r0" := (λ: "m",
      exception_do (let: "m" := (GoAlloc (go.MapType go.uint64 (go.StructType [

      ])) "m") in
      (if: Convert go.untyped_bool go.bool ((![go.MapType go.uint64 (go.StructType [

      ])] "m") =⟨go.MapType go.uint64 (go.StructType [

      ])⟩ (Convert go.untyped_nil (go.MapType go.uint64 (go.StructType [

      ])) UntypedNil))
      then
        return: (Convert go.untyped_nil (go.MapType go.uint64 (go.StructType [

         ])) UntypedNil)
      else do:  #());;;
      let: "mm" := (GoAlloc (go.MapType go.uint64 (go.StructType [

      ])) (GoZeroVal (go.MapType go.uint64 (go.StructType [

      ])) #())) in
      let: "$r0" := ((FuncResolve go.make2 [go.MapType go.uint64 (go.StructType [

       ])] #()) (let: "$a0" := (![go.MapType go.uint64 (go.StructType [

      ])] "m") in
      (FuncResolve go.len [go.MapType go.uint64 (go.StructType [

       ])] #()) "$a0")) in
      do:  ("mm" <-[go.MapType go.uint64 (go.StructType [

      ])] "$r0");;;
      let: "$range" := (![go.MapType go.uint64 (go.StructType [

      ])] "m") in
      (let: "k" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
      map.for_range go.uint64 (go.StructType [

      ]) "$range" (λ: "$key" "value",
        do:  ("k" <-[go.uint64] "$key");;;
        let: "$r0" := (CompositeLiteral (go.StructType [

        ]) (LiteralValue [])) in
        do:  (map.insert go.uint64 (![go.MapType go.uint64 (go.StructType [

        ])] "mm") (![go.uint64] "k") "$r0")));;;
      return: (![go.MapType go.uint64 (go.StructType [

       ])] "mm"))
      ) in
    do:  ("clone" <-[go.FunctionType (go.Signature [go.MapType go.uint64 (go.StructType [

     ])] false [go.MapType go.uint64 (go.StructType [

     ])])] "$r0");;;
    return: (CompositeLiteral Config (LiteralValue [KeyedElement (Some (KeyField "Voters"%go)) (ElementExpression quorum.JointConfig (CompositeLiteral quorum.JointConfig (LiteralValue [KeyedElement None (ElementExpression (go.MapType go.uint64 (go.StructType [

       ])) (let: "$a0" := (![quorum.MajorityConfig] (IndexRef quorum.JointConfig (![quorum.JointConfig] (StructFieldRef Config "Voters"%go (![go.PointerType Config] "c")), #(W64 0)))) in
       (![go.FunctionType (go.Signature [go.MapType go.uint64 (go.StructType [

        ])] false [go.MapType go.uint64 (go.StructType [

        ])])] "clone") "$a0")); KeyedElement None (ElementExpression (go.MapType go.uint64 (go.StructType [

       ])) (let: "$a0" := (![quorum.MajorityConfig] (IndexRef quorum.JointConfig (![quorum.JointConfig] (StructFieldRef Config "Voters"%go (![go.PointerType Config] "c")), #(W64 1)))) in
       (![go.FunctionType (go.Signature [go.MapType go.uint64 (go.StructType [

        ])] false [go.MapType go.uint64 (go.StructType [

        ])])] "clone") "$a0"))]))); KeyedElement (Some (KeyField "Learners"%go)) (ElementExpression (go.MapType go.uint64 (go.StructType [

      ])) (let: "$a0" := (![go.MapType go.uint64 (go.StructType [

      ])] (StructFieldRef Config "Learners"%go (![go.PointerType Config] "c"))) in
      (![go.FunctionType (go.Signature [go.MapType go.uint64 (go.StructType [

       ])] false [go.MapType go.uint64 (go.StructType [

       ])])] "clone") "$a0")); KeyedElement (Some (KeyField "LearnersNext"%go)) (ElementExpression (go.MapType go.uint64 (go.StructType [

      ])) (let: "$a0" := (![go.MapType go.uint64 (go.StructType [

      ])] (StructFieldRef Config "LearnersNext"%go (![go.PointerType Config] "c"))) in
      (![go.FunctionType (go.Signature [go.MapType go.uint64 (go.StructType [

       ])] false [go.MapType go.uint64 (go.StructType [

       ])])] "clone") "$a0"))]))).

(* MakeProgressTracker initializes a ProgressTracker.

   go: tracker.go:129:6 *)
Definition MakeProgressTrackerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "maxInflight" "maxBytes",
    exception_do (let: "maxBytes" := (GoAlloc go.uint64 "maxBytes") in
    let: "maxInflight" := (GoAlloc go.int "maxInflight") in
    let: "p" := (GoAlloc ProgressTracker (GoZeroVal ProgressTracker #())) in
    let: "$r0" := (CompositeLiteral ProgressTracker (LiteralValue [KeyedElement (Some (KeyField "MaxInflight"%go)) (ElementExpression go.int (![go.int] "maxInflight")); KeyedElement (Some (KeyField "MaxInflightBytes"%go)) (ElementExpression go.uint64 (![go.uint64] "maxBytes")); KeyedElement (Some (KeyField "Config"%go)) (ElementExpression Config (CompositeLiteral Config (LiteralValue [KeyedElement (Some (KeyField "Voters"%go)) (ElementExpression quorum.JointConfig (CompositeLiteral quorum.JointConfig (LiteralValue [KeyedElement None (ElementExpression quorum.MajorityConfig (CompositeLiteral quorum.MajorityConfig (LiteralValue []))); KeyedElement None (ElementExpression go.untyped_nil UntypedNil)]))); KeyedElement (Some (KeyField "Learners"%go)) (ElementExpression go.untyped_nil UntypedNil); KeyedElement (Some (KeyField "LearnersNext"%go)) (ElementExpression go.untyped_nil UntypedNil)]))); KeyedElement (Some (KeyField "Votes"%go)) (ElementExpression (go.MapType go.uint64 go.bool) (CompositeLiteral (go.MapType go.uint64 go.bool) (LiteralValue []))); KeyedElement (Some (KeyField "Progress"%go)) (ElementExpression (go.MapType go.uint64 (go.PointerType Progress)) (CompositeLiteral (go.MapType go.uint64 (go.PointerType Progress)) (LiteralValue [])))])) in
    do:  ("p" <-[ProgressTracker] "$r0");;;
    return: (![ProgressTracker] "p")).

(* ConfState returns a ConfState representing the active configuration.

   go: tracker.go:148:27 *)
Definition ProgressTracker__ConfStateⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "p" <>,
    exception_do (let: "p" := (GoAlloc (go.PointerType ProgressTracker) "p") in
    return: (CompositeLiteral raftpb.ConfState (LiteralValue [KeyedElement (Some (KeyField "Voters"%go)) (ElementExpression (go.SliceType go.uint64) ((MethodResolve quorum.MajorityConfig "Slice"%go (![quorum.MajorityConfig] (IndexRef quorum.JointConfig (![quorum.JointConfig] (StructFieldRef Config "Voters"%go (StructFieldRef ProgressTracker "Config"%go (![go.PointerType ProgressTracker] "p"))), #(W64 0))))) #())); KeyedElement (Some (KeyField "VotersOutgoing"%go)) (ElementExpression (go.SliceType go.uint64) ((MethodResolve quorum.MajorityConfig "Slice"%go (![quorum.MajorityConfig] (IndexRef quorum.JointConfig (![quorum.JointConfig] (StructFieldRef Config "Voters"%go (StructFieldRef ProgressTracker "Config"%go (![go.PointerType ProgressTracker] "p"))), #(W64 1))))) #())); KeyedElement (Some (KeyField "Learners"%go)) (ElementExpression (go.SliceType go.uint64) ((MethodResolve quorum.MajorityConfig "Slice"%go (![go.MapType go.uint64 (go.StructType [

      ])] (StructFieldRef Config "Learners"%go (StructFieldRef ProgressTracker "Config"%go (![go.PointerType ProgressTracker] "p"))))) #())); KeyedElement (Some (KeyField "LearnersNext"%go)) (ElementExpression (go.SliceType go.uint64) ((MethodResolve quorum.MajorityConfig "Slice"%go (![go.MapType go.uint64 (go.StructType [

      ])] (StructFieldRef Config "LearnersNext"%go (StructFieldRef ProgressTracker "Config"%go (![go.PointerType ProgressTracker] "p"))))) #())); KeyedElement (Some (KeyField "AutoLeave"%go)) (ElementExpression go.bool (![go.bool] (StructFieldRef Config "AutoLeave"%go (StructFieldRef ProgressTracker "Config"%go (![go.PointerType ProgressTracker] "p")))))]))).

(* IsSingleton returns true if (and only if) there is only one voting member
   (i.e. the leader) in the current configuration.

   go: tracker.go:160:27 *)
Definition ProgressTracker__IsSingletonⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "p" <>,
    exception_do (let: "p" := (GoAlloc (go.PointerType ProgressTracker) "p") in
    return: (((let: "$a0" := (![quorum.MajorityConfig] (IndexRef quorum.JointConfig (![quorum.JointConfig] (StructFieldRef Config "Voters"%go (StructFieldRef ProgressTracker "Config"%go (![go.PointerType ProgressTracker] "p"))), #(W64 0)))) in
     (FuncResolve go.len [quorum.MajorityConfig] #()) "$a0") =⟨go.int⟩ #(W64 1)) && ((let: "$a0" := (![quorum.MajorityConfig] (IndexRef quorum.JointConfig (![quorum.JointConfig] (StructFieldRef Config "Voters"%go (StructFieldRef ProgressTracker "Config"%go (![go.PointerType ProgressTracker] "p"))), #(W64 1)))) in
     (FuncResolve go.len [quorum.MajorityConfig] #()) "$a0") =⟨go.int⟩ #(W64 0)))).

(* AckedIndex implements IndexLookuper.

   go: tracker.go:169:26 *)
Definition matchAckIndexer__AckedIndexⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "l" "id",
    exception_do (let: "l" := (GoAlloc matchAckIndexer "l") in
    let: "id" := (GoAlloc go.uint64 "id") in
    let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: "pr" := (GoAlloc (go.PointerType Progress) (GoZeroVal (go.PointerType Progress) #())) in
    let: ("$ret0", "$ret1") := (map.lookup2 go.uint64 (go.PointerType Progress) (![matchAckIndexer] "l") (![go.uint64] "id")) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("pr" <-[go.PointerType Progress] "$r0");;;
    do:  ("ok" <-[go.bool] "$r1");;;
    (if: (⟨go.bool⟩! (![go.bool] "ok"))
    then return: (#(W64 0), #false)
    else do:  #());;;
    return: (![go.uint64] (StructFieldRef Progress "Match"%go (![go.PointerType Progress] "pr")), #true)).

(* Committed returns the largest log index known to be committed based on what
   the voting members of the group have acknowledged.

   go: tracker.go:179:27 *)
Definition ProgressTracker__Committedⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "p" <>,
    exception_do (let: "p" := (GoAlloc (go.PointerType ProgressTracker) "p") in
    return: (let: "$a0" := (Convert matchAckIndexer quorum.AckedIndexer (![ProgressMap] (StructFieldRef ProgressTracker "Progress"%go (![go.PointerType ProgressTracker] "p")))) in
     (MethodResolve quorum.JointConfig "CommittedIndex"%go (![quorum.JointConfig] (StructFieldRef Config "Voters"%go (StructFieldRef ProgressTracker "Config"%go (![go.PointerType ProgressTracker] "p"))))) "$a0")).

(* Visit invokes the supplied closure for all tracked progresses in stable order.

   go: tracker.go:184:27 *)
Definition ProgressTracker__Visitⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "p" "f",
    exception_do (let: "p" := (GoAlloc (go.PointerType ProgressTracker) "p") in
    let: "f" := (GoAlloc (go.FunctionType (go.Signature [go.uint64; go.PointerType Progress] false [])) "f") in
    let: "n" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "$r0" := (let: "$a0" := (![ProgressMap] (StructFieldRef ProgressTracker "Progress"%go (![go.PointerType ProgressTracker] "p"))) in
    (FuncResolve go.len [ProgressMap] #()) "$a0") in
    do:  ("n" <-[go.int] "$r0");;;
    let: "sl" := (GoAlloc (go.ArrayType 7 go.uint64) (GoZeroVal (go.ArrayType 7 go.uint64) #())) in
    let: "ids" := (GoAlloc (go.SliceType go.uint64) (GoZeroVal (go.SliceType go.uint64) #())) in
    (if: Convert go.untyped_bool go.bool ((FuncResolve go.len [go.ArrayType 7 go.uint64] #()) ≥⟨go.int⟩ (![go.int] "n"))
    then
      let: "$r0" := (let: "$s" := (![go.ArrayType 7 go.uint64] "sl") in
      Slice (go.ArrayType 7 go.uint64) ("$s", #(W64 0), ![go.int] "n")) in
      do:  ("ids" <-[go.SliceType go.uint64] "$r0")
    else
      let: "$r0" := ((FuncResolve go.make2 [go.SliceType go.uint64] #()) (![go.int] "n")) in
      do:  ("ids" <-[go.SliceType go.uint64] "$r0"));;;
    let: "$range" := (![ProgressMap] (StructFieldRef ProgressTracker "Progress"%go (![go.PointerType ProgressTracker] "p"))) in
    (let: "id" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    map.for_range go.uint64 (go.PointerType Progress) "$range" (λ: "$key" "value",
      do:  ("id" <-[go.uint64] "$key");;;
      do:  ("n" <-[go.int] ((![go.int] "n") -⟨go.int⟩ #(W64 1)));;;
      let: "$r0" := (![go.uint64] "id") in
      do:  ((IndexRef (go.SliceType go.uint64) (![go.SliceType go.uint64] "ids", ![go.int] "n")) <-[go.uint64] "$r0")));;;
    do:  (let: "$a0" := (![go.SliceType go.uint64] "ids") in
    (FuncResolve slices.SortUint64 [] #()) "$a0");;;
    let: "$range" := (![go.SliceType go.uint64] "ids") in
    (let: "id" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    slice.for_range go.uint64 "$range" (λ: "$key" "$value",
      do:  ("id" <-[go.uint64] "$value");;;
      do:  "$key";;;
      do:  (let: "$a0" := (![go.uint64] "id") in
      let: "$a1" := (map.lookup1 go.uint64 (go.PointerType Progress) (![ProgressMap] (StructFieldRef ProgressTracker "Progress"%go (![go.PointerType ProgressTracker] "p"))) (![go.uint64] "id")) in
      (![go.FunctionType (go.Signature [go.uint64; go.PointerType Progress] false [])] "f") "$a0" "$a1")));;;
    return: #()).

(* QuorumActive returns true if the quorum is active from the view of the local
   raft state machine. Otherwise, it returns false.

   go: tracker.go:208:27 *)
Definition ProgressTracker__QuorumActiveⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "p" <>,
    exception_do (let: "p" := (GoAlloc (go.PointerType ProgressTracker) "p") in
    let: "votes" := (GoAlloc (go.MapType go.uint64 go.bool) (GoZeroVal (go.MapType go.uint64 go.bool) #())) in
    let: "$r0" := (CompositeLiteral (go.MapType go.uint64 go.bool) (LiteralValue [])) in
    do:  ("votes" <-[go.MapType go.uint64 go.bool] "$r0");;;
    do:  (let: "$a0" := (λ: "id" "pr",
      exception_do (let: "pr" := (GoAlloc (go.PointerType Progress) "pr") in
      let: "id" := (GoAlloc go.uint64 "id") in
      (if: ![go.bool] (StructFieldRef Progress "IsLearner"%go (![go.PointerType Progress] "pr"))
      then return: (#())
      else do:  #());;;
      let: "$r0" := (![go.bool] (StructFieldRef Progress "RecentActive"%go (![go.PointerType Progress] "pr"))) in
      do:  (map.insert go.uint64 (![go.MapType go.uint64 go.bool] "votes") (![go.uint64] "id") "$r0");;;
      return: #())
      ) in
    (MethodResolve (go.PointerType ProgressTracker) "Visit"%go (![go.PointerType ProgressTracker] "p")) "$a0");;;
    return: ((let: "$a0" := (![go.MapType go.uint64 go.bool] "votes") in
     (MethodResolve quorum.JointConfig "VoteResult"%go (![quorum.JointConfig] (StructFieldRef Config "Voters"%go (StructFieldRef ProgressTracker "Config"%go (![go.PointerType ProgressTracker] "p"))))) "$a0") =⟨go.uint8⟩ quorum.VoteWon)).

(* VoterNodes returns a sorted slice of voters.

   go: tracker.go:221:27 *)
Definition ProgressTracker__VoterNodesⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "p" <>,
    exception_do (let: "p" := (GoAlloc (go.PointerType ProgressTracker) "p") in
    let: "m" := (GoAlloc (go.MapType go.uint64 (go.StructType [

    ])) (GoZeroVal (go.MapType go.uint64 (go.StructType [

    ])) #())) in
    let: "$r0" := ((MethodResolve quorum.JointConfig "IDs"%go (![quorum.JointConfig] (StructFieldRef Config "Voters"%go (StructFieldRef ProgressTracker "Config"%go (![go.PointerType ProgressTracker] "p"))))) #()) in
    do:  ("m" <-[go.MapType go.uint64 (go.StructType [

    ])] "$r0");;;
    let: "nodes" := (GoAlloc (go.SliceType go.uint64) (GoZeroVal (go.SliceType go.uint64) #())) in
    let: "$r0" := ((FuncResolve go.make3 [go.SliceType go.uint64] #()) #(W64 0) (let: "$a0" := (![go.MapType go.uint64 (go.StructType [

    ])] "m") in
    (FuncResolve go.len [go.MapType go.uint64 (go.StructType [

     ])] #()) "$a0")) in
    do:  ("nodes" <-[go.SliceType go.uint64] "$r0");;;
    let: "$range" := (![go.MapType go.uint64 (go.StructType [

    ])] "m") in
    (let: "id" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    map.for_range go.uint64 (go.StructType [

    ]) "$range" (λ: "$key" "value",
      do:  ("id" <-[go.uint64] "$key");;;
      let: "$r0" := (let: "$a0" := (![go.SliceType go.uint64] "nodes") in
      let: "$a1" := ((let: "$sl0" := (![go.uint64] "id") in
      CompositeLiteral (go.SliceType go.uint64) (LiteralValue [KeyedElement None (ElementExpression go.uint64 "$sl0")]))) in
      (FuncResolve go.append [go.SliceType go.uint64] #()) "$a0" "$a1") in
      do:  ("nodes" <-[go.SliceType go.uint64] "$r0")));;;
    do:  (let: "$a0" := (![go.SliceType go.uint64] "nodes") in
    (FuncResolve slices.SortUint64 [] #()) "$a0");;;
    return: (![go.SliceType go.uint64] "nodes")).

(* LearnerNodes returns a sorted slice of learners.

   go: tracker.go:232:27 *)
Definition ProgressTracker__LearnerNodesⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "p" <>,
    exception_do (let: "p" := (GoAlloc (go.PointerType ProgressTracker) "p") in
    (if: Convert go.untyped_bool go.bool ((let: "$a0" := (![go.MapType go.uint64 (go.StructType [

    ])] (StructFieldRef Config "Learners"%go (StructFieldRef ProgressTracker "Config"%go (![go.PointerType ProgressTracker] "p")))) in
    (FuncResolve go.len [go.MapType go.uint64 (go.StructType [

     ])] #()) "$a0") =⟨go.int⟩ #(W64 0))
    then return: (Convert go.untyped_nil (go.SliceType go.uint64) UntypedNil)
    else do:  #());;;
    let: "nodes" := (GoAlloc (go.SliceType go.uint64) (GoZeroVal (go.SliceType go.uint64) #())) in
    let: "$r0" := ((FuncResolve go.make3 [go.SliceType go.uint64] #()) #(W64 0) (let: "$a0" := (![go.MapType go.uint64 (go.StructType [

    ])] (StructFieldRef Config "Learners"%go (StructFieldRef ProgressTracker "Config"%go (![go.PointerType ProgressTracker] "p")))) in
    (FuncResolve go.len [go.MapType go.uint64 (go.StructType [

     ])] #()) "$a0")) in
    do:  ("nodes" <-[go.SliceType go.uint64] "$r0");;;
    let: "$range" := (![go.MapType go.uint64 (go.StructType [

    ])] (StructFieldRef Config "Learners"%go (StructFieldRef ProgressTracker "Config"%go (![go.PointerType ProgressTracker] "p")))) in
    (let: "id" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    map.for_range go.uint64 (go.StructType [

    ]) "$range" (λ: "$key" "value",
      do:  ("id" <-[go.uint64] "$key");;;
      let: "$r0" := (let: "$a0" := (![go.SliceType go.uint64] "nodes") in
      let: "$a1" := ((let: "$sl0" := (![go.uint64] "id") in
      CompositeLiteral (go.SliceType go.uint64) (LiteralValue [KeyedElement None (ElementExpression go.uint64 "$sl0")]))) in
      (FuncResolve go.append [go.SliceType go.uint64] #()) "$a0" "$a1") in
      do:  ("nodes" <-[go.SliceType go.uint64] "$r0")));;;
    do:  (let: "$a0" := (![go.SliceType go.uint64] "nodes") in
    (FuncResolve slices.SortUint64 [] #()) "$a0");;;
    return: (![go.SliceType go.uint64] "nodes")).

(* ResetVotes prepares for a new round of vote counting via recordVote.

   go: tracker.go:245:27 *)
Definition ProgressTracker__ResetVotesⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "p" <>,
    exception_do (let: "p" := (GoAlloc (go.PointerType ProgressTracker) "p") in
    let: "$r0" := (CompositeLiteral (go.MapType go.uint64 go.bool) (LiteralValue [])) in
    do:  ((StructFieldRef ProgressTracker "Votes"%go (![go.PointerType ProgressTracker] "p")) <-[go.MapType go.uint64 go.bool] "$r0");;;
    return: #()).

(* RecordVote records that the node with the given id voted for this Raft
   instance if v == true (and declined it otherwise).

   go: tracker.go:251:27 *)
Definition ProgressTracker__RecordVoteⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "p" "id" "v",
    exception_do (let: "p" := (GoAlloc (go.PointerType ProgressTracker) "p") in
    let: "v" := (GoAlloc go.bool "v") in
    let: "id" := (GoAlloc go.uint64 "id") in
    let: "ok" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
    let: ("$ret0", "$ret1") := (map.lookup2 go.uint64 go.bool (![go.MapType go.uint64 go.bool] (StructFieldRef ProgressTracker "Votes"%go (![go.PointerType ProgressTracker] "p"))) (![go.uint64] "id")) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  "$r0";;;
    do:  ("ok" <-[go.bool] "$r1");;;
    (if: (⟨go.bool⟩! (![go.bool] "ok"))
    then
      let: "$r0" := (![go.bool] "v") in
      do:  (map.insert go.uint64 (![go.MapType go.uint64 go.bool] (StructFieldRef ProgressTracker "Votes"%go (![go.PointerType ProgressTracker] "p"))) (![go.uint64] "id") "$r0")
    else do:  #());;;
    return: #()).

(* TallyVotes returns the number of granted and rejected Votes, and whether the
   election outcome is known.

   go: tracker.go:260:27 *)
Definition ProgressTracker__TallyVotesⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: "p" <>,
    exception_do (let: <> := (GoAlloc quorum.VoteResult (GoZeroVal quorum.VoteResult #())) in
    let: "rejected" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "granted" := (GoAlloc go.int (GoZeroVal go.int #())) in
    let: "p" := (GoAlloc (go.PointerType ProgressTracker) "p") in
    let: "$range" := (![ProgressMap] (StructFieldRef ProgressTracker "Progress"%go (![go.PointerType ProgressTracker] "p"))) in
    (let: "pr" := (GoAlloc (go.PointerType Progress) (GoZeroVal (go.PointerType Progress) #())) in
    let: "id" := (GoAlloc go.uint64 (GoZeroVal go.uint64 #())) in
    map.for_range go.uint64 (go.PointerType Progress) "$range" (λ: "$key" "value",
      do:  ("pr" <-[go.PointerType Progress] "$value");;;
      do:  ("id" <-[go.uint64] "$key");;;
      (if: ![go.bool] (StructFieldRef Progress "IsLearner"%go (![go.PointerType Progress] "pr"))
      then continue: #()
      else do:  #());;;
      let: "voted" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
      let: "v" := (GoAlloc go.bool (GoZeroVal go.bool #())) in
      let: ("$ret0", "$ret1") := (map.lookup2 go.uint64 go.bool (![go.MapType go.uint64 go.bool] (StructFieldRef ProgressTracker "Votes"%go (![go.PointerType ProgressTracker] "p"))) (![go.uint64] "id")) in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("v" <-[go.bool] "$r0");;;
      do:  ("voted" <-[go.bool] "$r1");;;
      (if: (⟨go.bool⟩! (![go.bool] "voted"))
      then continue: #()
      else do:  #());;;
      (if: ![go.bool] "v"
      then do:  ("granted" <-[go.int] ((![go.int] "granted") +⟨go.int⟩ #(W64 1)))
      else do:  ("rejected" <-[go.int] ((![go.int] "rejected") +⟨go.int⟩ #(W64 1))))));;;
    let: "result" := (GoAlloc quorum.VoteResult (GoZeroVal quorum.VoteResult #())) in
    let: "$r0" := (let: "$a0" := (![go.MapType go.uint64 go.bool] (StructFieldRef ProgressTracker "Votes"%go (![go.PointerType ProgressTracker] "p"))) in
    (MethodResolve quorum.JointConfig "VoteResult"%go (![quorum.JointConfig] (StructFieldRef Config "Voters"%go (StructFieldRef ProgressTracker "Config"%go (![go.PointerType ProgressTracker] "p"))))) "$a0") in
    do:  ("result" <-[quorum.VoteResult] "$r0");;;
    return: (![go.int] "granted", ![go.int] "rejected", ![quorum.VoteResult] "result")).

#[global] Instance info' : PkgInfo pkg_id.tracker :=
{|
  pkg_imported_pkgs := [code.fmt.pkg_id.fmt; code.strings.pkg_id.strings; code.go_etcd_io.raft.v3.quorum.slices.pkg_id.slices; code.go_etcd_io.raft.v3.quorum.pkg_id.quorum; code.go_etcd_io.raft.v3.raftpb.pkg_id.raftpb]
|}.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init pkg_id.tracker (λ: <>,
      exception_do (do:  (go.GlobalAlloc prstmap (go.ArrayType 3 go.string) #());;;
      do:  (raftpb.initialize' #());;;
      do:  (quorum.initialize' #());;;
      do:  (slices.initialize' #());;;
      do:  (strings.initialize' #());;;
      do:  (fmt.initialize' #());;;
      let: "$r0" := (CompositeLiteral (go.ArrayType 3 go.string) (LiteralValue [KeyedElement None (ElementExpression go.string #"StateProbe"%go); KeyedElement None (ElementExpression go.string #"StateReplicate"%go); KeyedElement None (ElementExpression go.string #"StateSnapshot"%go)])) in
      do:  ((GlobalVarAddr prstmap #()) <-[go.ArrayType 3 go.string] "$r0");;;
      let: "$r0" := (Convert matchAckIndexer quorum.AckedIndexer (Convert go.untyped_nil matchAckIndexer UntypedNil)) in
      do:  #())
      ).

Module inflight.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  index' : w64;
  bytes' : w64;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End inflight.

Definition inflight'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "index"%go go.uint64);
  (go.FieldDecl "bytes"%go go.uint64)
].
Program Definition inflight'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (inflight'fds_unsealed).
Global Instance equals_unfold_inflight {ext : ffi_syntax} {go_gctx : GoGlobalContext} : inflight'fds =→ inflight'fds_unsealed.
Proof. rewrite /inflight'fds seal_eq //. Qed.

Definition inflightⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (inflight'fds).

Class inflight_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] inflight_type_repr  :: go.TypeReprUnderlying inflightⁱᵐᵖˡ inflight.t;
  #[global] inflight_underlying :: (inflight) <u (inflightⁱᵐᵖˡ);
  #[global] inflight_get_index (x : inflight.t) :: ⟦StructFieldGet (inflightⁱᵐᵖˡ) "index", #x⟧ ⤳[under] #x.(inflight.index');
  #[global] inflight_set_index (x : inflight.t) y :: ⟦StructFieldSet (inflightⁱᵐᵖˡ) "index", (#x, #y)⟧ ⤳[under] #(x <|inflight.index' := y|>);
  #[global] inflight_get_bytes (x : inflight.t) :: ⟦StructFieldGet (inflightⁱᵐᵖˡ) "bytes", #x⟧ ⤳[under] #x.(inflight.bytes');
  #[global] inflight_set_bytes (x : inflight.t) y :: ⟦StructFieldSet (inflightⁱᵐᵖˡ) "bytes", (#x, #y)⟧ ⤳[under] #(x <|inflight.bytes' := y|>);
}.

Module Inflights.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  start' : w64;
  count' : w64;
  bytes' : w64;
  size' : w64;
  maxBytes' : w64;
  buffer' : slice.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End Inflights.

Definition Inflights'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "start"%go go.int);
  (go.FieldDecl "count"%go go.int);
  (go.FieldDecl "bytes"%go go.uint64);
  (go.FieldDecl "size"%go go.int);
  (go.FieldDecl "maxBytes"%go go.uint64);
  (go.FieldDecl "buffer"%go (go.SliceType inflight))
].
Program Definition Inflights'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (Inflights'fds_unsealed).
Global Instance equals_unfold_Inflights {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Inflights'fds =→ Inflights'fds_unsealed.
Proof. rewrite /Inflights'fds seal_eq //. Qed.

Definition Inflightsⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (Inflights'fds).

Class Inflights_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Inflights_type_repr  :: go.TypeReprUnderlying Inflightsⁱᵐᵖˡ Inflights.t;
  #[global] Inflights_underlying :: (Inflights) <u (Inflightsⁱᵐᵖˡ);
  #[global] Inflights_get_start (x : Inflights.t) :: ⟦StructFieldGet (Inflightsⁱᵐᵖˡ) "start", #x⟧ ⤳[under] #x.(Inflights.start');
  #[global] Inflights_set_start (x : Inflights.t) y :: ⟦StructFieldSet (Inflightsⁱᵐᵖˡ) "start", (#x, #y)⟧ ⤳[under] #(x <|Inflights.start' := y|>);
  #[global] Inflights_get_count (x : Inflights.t) :: ⟦StructFieldGet (Inflightsⁱᵐᵖˡ) "count", #x⟧ ⤳[under] #x.(Inflights.count');
  #[global] Inflights_set_count (x : Inflights.t) y :: ⟦StructFieldSet (Inflightsⁱᵐᵖˡ) "count", (#x, #y)⟧ ⤳[under] #(x <|Inflights.count' := y|>);
  #[global] Inflights_get_bytes (x : Inflights.t) :: ⟦StructFieldGet (Inflightsⁱᵐᵖˡ) "bytes", #x⟧ ⤳[under] #x.(Inflights.bytes');
  #[global] Inflights_set_bytes (x : Inflights.t) y :: ⟦StructFieldSet (Inflightsⁱᵐᵖˡ) "bytes", (#x, #y)⟧ ⤳[under] #(x <|Inflights.bytes' := y|>);
  #[global] Inflights_get_size (x : Inflights.t) :: ⟦StructFieldGet (Inflightsⁱᵐᵖˡ) "size", #x⟧ ⤳[under] #x.(Inflights.size');
  #[global] Inflights_set_size (x : Inflights.t) y :: ⟦StructFieldSet (Inflightsⁱᵐᵖˡ) "size", (#x, #y)⟧ ⤳[under] #(x <|Inflights.size' := y|>);
  #[global] Inflights_get_maxBytes (x : Inflights.t) :: ⟦StructFieldGet (Inflightsⁱᵐᵖˡ) "maxBytes", #x⟧ ⤳[under] #x.(Inflights.maxBytes');
  #[global] Inflights_set_maxBytes (x : Inflights.t) y :: ⟦StructFieldSet (Inflightsⁱᵐᵖˡ) "maxBytes", (#x, #y)⟧ ⤳[under] #(x <|Inflights.maxBytes' := y|>);
  #[global] Inflights_get_buffer (x : Inflights.t) :: ⟦StructFieldGet (Inflightsⁱᵐᵖˡ) "buffer", #x⟧ ⤳[under] #x.(Inflights.buffer');
  #[global] Inflights_set_buffer (x : Inflights.t) y :: ⟦StructFieldSet (Inflightsⁱᵐᵖˡ) "buffer", (#x, #y)⟧ ⤳[under] #(x <|Inflights.buffer' := y|>);
  #[global] Inflights'ptr_Add_unfold :: MethodUnfold (go.PointerType (Inflights)) "Add" (Inflights__Addⁱᵐᵖˡ);
  #[global] Inflights'ptr_Clone_unfold :: MethodUnfold (go.PointerType (Inflights)) "Clone" (Inflights__Cloneⁱᵐᵖˡ);
  #[global] Inflights'ptr_Count_unfold :: MethodUnfold (go.PointerType (Inflights)) "Count" (Inflights__Countⁱᵐᵖˡ);
  #[global] Inflights'ptr_FreeLE_unfold :: MethodUnfold (go.PointerType (Inflights)) "FreeLE" (Inflights__FreeLEⁱᵐᵖˡ);
  #[global] Inflights'ptr_Full_unfold :: MethodUnfold (go.PointerType (Inflights)) "Full" (Inflights__Fullⁱᵐᵖˡ);
  #[global] Inflights'ptr_grow_unfold :: MethodUnfold (go.PointerType (Inflights)) "grow" (Inflights__growⁱᵐᵖˡ);
  #[global] Inflights'ptr_reset_unfold :: MethodUnfold (go.PointerType (Inflights)) "reset" (Inflights__resetⁱᵐᵖˡ);
}.

Module StateType.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := w64.
End def.
End StateType.

Definition StateTypeⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.uint64.

Class StateType_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] StateType_underlying :: (StateType) <u (StateTypeⁱᵐᵖˡ);
  #[global] StateType_String_unfold :: MethodUnfold (StateType) "String" (StateType__Stringⁱᵐᵖˡ);
  #[global] StateType'ptr_String_unfold :: MethodUnfold (go.PointerType (StateType)) "String" (λ: "$r", MethodResolve (StateType) "String" (![(StateType)] "$r"));
}.

Module Progress.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  Match' : w64;
  Next' : w64;
  sentCommit' : w64;
  State' : tracker.StateType.t;
  PendingSnapshot' : w64;
  RecentActive' : bool;
  MsgAppFlowPaused' : bool;
  Inflights' : loc;
  IsLearner' : bool;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End Progress.

Definition Progress'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "Match"%go go.uint64);
  (go.FieldDecl "Next"%go go.uint64);
  (go.FieldDecl "sentCommit"%go go.uint64);
  (go.FieldDecl "State"%go StateType);
  (go.FieldDecl "PendingSnapshot"%go go.uint64);
  (go.FieldDecl "RecentActive"%go go.bool);
  (go.FieldDecl "MsgAppFlowPaused"%go go.bool);
  (go.FieldDecl "Inflights"%go (go.PointerType Inflights));
  (go.FieldDecl "IsLearner"%go go.bool)
].
Program Definition Progress'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (Progress'fds_unsealed).
Global Instance equals_unfold_Progress {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Progress'fds =→ Progress'fds_unsealed.
Proof. rewrite /Progress'fds seal_eq //. Qed.

Definition Progressⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (Progress'fds).

Class Progress_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Progress_type_repr  :: go.TypeReprUnderlying Progressⁱᵐᵖˡ Progress.t;
  #[global] Progress_underlying :: (Progress) <u (Progressⁱᵐᵖˡ);
  #[global] Progress_get_Match (x : Progress.t) :: ⟦StructFieldGet (Progressⁱᵐᵖˡ) "Match", #x⟧ ⤳[under] #x.(Progress.Match');
  #[global] Progress_set_Match (x : Progress.t) y :: ⟦StructFieldSet (Progressⁱᵐᵖˡ) "Match", (#x, #y)⟧ ⤳[under] #(x <|Progress.Match' := y|>);
  #[global] Progress_get_Next (x : Progress.t) :: ⟦StructFieldGet (Progressⁱᵐᵖˡ) "Next", #x⟧ ⤳[under] #x.(Progress.Next');
  #[global] Progress_set_Next (x : Progress.t) y :: ⟦StructFieldSet (Progressⁱᵐᵖˡ) "Next", (#x, #y)⟧ ⤳[under] #(x <|Progress.Next' := y|>);
  #[global] Progress_get_sentCommit (x : Progress.t) :: ⟦StructFieldGet (Progressⁱᵐᵖˡ) "sentCommit", #x⟧ ⤳[under] #x.(Progress.sentCommit');
  #[global] Progress_set_sentCommit (x : Progress.t) y :: ⟦StructFieldSet (Progressⁱᵐᵖˡ) "sentCommit", (#x, #y)⟧ ⤳[under] #(x <|Progress.sentCommit' := y|>);
  #[global] Progress_get_State (x : Progress.t) :: ⟦StructFieldGet (Progressⁱᵐᵖˡ) "State", #x⟧ ⤳[under] #x.(Progress.State');
  #[global] Progress_set_State (x : Progress.t) y :: ⟦StructFieldSet (Progressⁱᵐᵖˡ) "State", (#x, #y)⟧ ⤳[under] #(x <|Progress.State' := y|>);
  #[global] Progress_get_PendingSnapshot (x : Progress.t) :: ⟦StructFieldGet (Progressⁱᵐᵖˡ) "PendingSnapshot", #x⟧ ⤳[under] #x.(Progress.PendingSnapshot');
  #[global] Progress_set_PendingSnapshot (x : Progress.t) y :: ⟦StructFieldSet (Progressⁱᵐᵖˡ) "PendingSnapshot", (#x, #y)⟧ ⤳[under] #(x <|Progress.PendingSnapshot' := y|>);
  #[global] Progress_get_RecentActive (x : Progress.t) :: ⟦StructFieldGet (Progressⁱᵐᵖˡ) "RecentActive", #x⟧ ⤳[under] #x.(Progress.RecentActive');
  #[global] Progress_set_RecentActive (x : Progress.t) y :: ⟦StructFieldSet (Progressⁱᵐᵖˡ) "RecentActive", (#x, #y)⟧ ⤳[under] #(x <|Progress.RecentActive' := y|>);
  #[global] Progress_get_MsgAppFlowPaused (x : Progress.t) :: ⟦StructFieldGet (Progressⁱᵐᵖˡ) "MsgAppFlowPaused", #x⟧ ⤳[under] #x.(Progress.MsgAppFlowPaused');
  #[global] Progress_set_MsgAppFlowPaused (x : Progress.t) y :: ⟦StructFieldSet (Progressⁱᵐᵖˡ) "MsgAppFlowPaused", (#x, #y)⟧ ⤳[under] #(x <|Progress.MsgAppFlowPaused' := y|>);
  #[global] Progress_get_Inflights (x : Progress.t) :: ⟦StructFieldGet (Progressⁱᵐᵖˡ) "Inflights", #x⟧ ⤳[under] #x.(Progress.Inflights');
  #[global] Progress_set_Inflights (x : Progress.t) y :: ⟦StructFieldSet (Progressⁱᵐᵖˡ) "Inflights", (#x, #y)⟧ ⤳[under] #(x <|Progress.Inflights' := y|>);
  #[global] Progress_get_IsLearner (x : Progress.t) :: ⟦StructFieldGet (Progressⁱᵐᵖˡ) "IsLearner", #x⟧ ⤳[under] #x.(Progress.IsLearner');
  #[global] Progress_set_IsLearner (x : Progress.t) y :: ⟦StructFieldSet (Progressⁱᵐᵖˡ) "IsLearner", (#x, #y)⟧ ⤳[under] #(x <|Progress.IsLearner' := y|>);
  #[global] Progress'ptr_BecomeProbe_unfold :: MethodUnfold (go.PointerType (Progress)) "BecomeProbe" (Progress__BecomeProbeⁱᵐᵖˡ);
  #[global] Progress'ptr_BecomeReplicate_unfold :: MethodUnfold (go.PointerType (Progress)) "BecomeReplicate" (Progress__BecomeReplicateⁱᵐᵖˡ);
  #[global] Progress'ptr_BecomeSnapshot_unfold :: MethodUnfold (go.PointerType (Progress)) "BecomeSnapshot" (Progress__BecomeSnapshotⁱᵐᵖˡ);
  #[global] Progress'ptr_CanBumpCommit_unfold :: MethodUnfold (go.PointerType (Progress)) "CanBumpCommit" (Progress__CanBumpCommitⁱᵐᵖˡ);
  #[global] Progress'ptr_IsPaused_unfold :: MethodUnfold (go.PointerType (Progress)) "IsPaused" (Progress__IsPausedⁱᵐᵖˡ);
  #[global] Progress'ptr_MaybeDecrTo_unfold :: MethodUnfold (go.PointerType (Progress)) "MaybeDecrTo" (Progress__MaybeDecrToⁱᵐᵖˡ);
  #[global] Progress'ptr_MaybeUpdate_unfold :: MethodUnfold (go.PointerType (Progress)) "MaybeUpdate" (Progress__MaybeUpdateⁱᵐᵖˡ);
  #[global] Progress'ptr_ResetState_unfold :: MethodUnfold (go.PointerType (Progress)) "ResetState" (Progress__ResetStateⁱᵐᵖˡ);
  #[global] Progress'ptr_SentCommit_unfold :: MethodUnfold (go.PointerType (Progress)) "SentCommit" (Progress__SentCommitⁱᵐᵖˡ);
  #[global] Progress'ptr_SentEntries_unfold :: MethodUnfold (go.PointerType (Progress)) "SentEntries" (Progress__SentEntriesⁱᵐᵖˡ);
  #[global] Progress'ptr_String_unfold :: MethodUnfold (go.PointerType (Progress)) "String" (Progress__Stringⁱᵐᵖˡ);
}.

Module ProgressMap.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := map.t.
End def.
End ProgressMap.

Definition ProgressMapⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.MapType go.uint64 (go.PointerType Progress).

Class ProgressMap_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] ProgressMap_underlying :: (ProgressMap) <u (ProgressMapⁱᵐᵖˡ);
  #[global] ProgressMap_String_unfold :: MethodUnfold (ProgressMap) "String" (ProgressMap__Stringⁱᵐᵖˡ);
  #[global] ProgressMap'ptr_String_unfold :: MethodUnfold (go.PointerType (ProgressMap)) "String" (λ: "$r", MethodResolve (ProgressMap) "String" (![(ProgressMap)] "$r"));
}.

Module Config.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  Voters' : quorum.JointConfig.t;
  AutoLeave' : bool;
  Learners' : map.t;
  LearnersNext' : map.t;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End Config.

Definition Config'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.FieldDecl "Voters"%go quorum.JointConfig);
  (go.FieldDecl "AutoLeave"%go go.bool);
  (go.FieldDecl "Learners"%go (go.MapType go.uint64 (go.StructType [

  ])));
  (go.FieldDecl "LearnersNext"%go (go.MapType go.uint64 (go.StructType [

  ])))
].
Program Definition Config'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (Config'fds_unsealed).
Global Instance equals_unfold_Config {ext : ffi_syntax} {go_gctx : GoGlobalContext} : Config'fds =→ Config'fds_unsealed.
Proof. rewrite /Config'fds seal_eq //. Qed.

Definition Configⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (Config'fds).

Class Config_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Config_type_repr  :: go.TypeReprUnderlying Configⁱᵐᵖˡ Config.t;
  #[global] Config_underlying :: (Config) <u (Configⁱᵐᵖˡ);
  #[global] Config_get_Voters (x : Config.t) :: ⟦StructFieldGet (Configⁱᵐᵖˡ) "Voters", #x⟧ ⤳[under] #x.(Config.Voters');
  #[global] Config_set_Voters (x : Config.t) y :: ⟦StructFieldSet (Configⁱᵐᵖˡ) "Voters", (#x, #y)⟧ ⤳[under] #(x <|Config.Voters' := y|>);
  #[global] Config_get_AutoLeave (x : Config.t) :: ⟦StructFieldGet (Configⁱᵐᵖˡ) "AutoLeave", #x⟧ ⤳[under] #x.(Config.AutoLeave');
  #[global] Config_set_AutoLeave (x : Config.t) y :: ⟦StructFieldSet (Configⁱᵐᵖˡ) "AutoLeave", (#x, #y)⟧ ⤳[under] #(x <|Config.AutoLeave' := y|>);
  #[global] Config_get_Learners (x : Config.t) :: ⟦StructFieldGet (Configⁱᵐᵖˡ) "Learners", #x⟧ ⤳[under] #x.(Config.Learners');
  #[global] Config_set_Learners (x : Config.t) y :: ⟦StructFieldSet (Configⁱᵐᵖˡ) "Learners", (#x, #y)⟧ ⤳[under] #(x <|Config.Learners' := y|>);
  #[global] Config_get_LearnersNext (x : Config.t) :: ⟦StructFieldGet (Configⁱᵐᵖˡ) "LearnersNext", #x⟧ ⤳[under] #x.(Config.LearnersNext');
  #[global] Config_set_LearnersNext (x : Config.t) y :: ⟦StructFieldSet (Configⁱᵐᵖˡ) "LearnersNext", (#x, #y)⟧ ⤳[under] #(x <|Config.LearnersNext' := y|>);
  #[global] Config_String_unfold :: MethodUnfold (Config) "String" (Config__Stringⁱᵐᵖˡ);
  #[global] Config'ptr_Clone_unfold :: MethodUnfold (go.PointerType (Config)) "Clone" (Config__Cloneⁱᵐᵖˡ);
  #[global] Config'ptr_String_unfold :: MethodUnfold (go.PointerType (Config)) "String" (λ: "$r", MethodResolve (Config) "String" (![(Config)] "$r"));
}.

Module ProgressTracker.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Record t :=
mk {
  Config' : tracker.Config.t;
  Progress' : tracker.ProgressMap.t;
  Votes' : map.t;
  MaxInflight' : w64;
  MaxInflightBytes' : w64;
}.

#[global] Instance zero_val : ZeroVal t := {| zero_val := mk (zero_val _) (zero_val _) (zero_val _) (zero_val _) (zero_val _)|}.
#[global] Arguments mk : clear implicits.
#[global] Arguments t : clear implicits.
End def.

End ProgressTracker.

Definition ProgressTracker'fds_unsealed {ext : ffi_syntax} {go_gctx : GoGlobalContext} : list go.field_decl := [
  (go.EmbeddedField "Config"%go Config);
  (go.FieldDecl "Progress"%go ProgressMap);
  (go.FieldDecl "Votes"%go (go.MapType go.uint64 go.bool));
  (go.FieldDecl "MaxInflight"%go go.int);
  (go.FieldDecl "MaxInflightBytes"%go go.uint64)
].
Program Definition ProgressTracker'fds {ext : ffi_syntax} {go_gctx : GoGlobalContext} := sealed (ProgressTracker'fds_unsealed).
Global Instance equals_unfold_ProgressTracker {ext : ffi_syntax} {go_gctx : GoGlobalContext} : ProgressTracker'fds =→ ProgressTracker'fds_unsealed.
Proof. rewrite /ProgressTracker'fds seal_eq //. Qed.

Definition ProgressTrackerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.StructType (ProgressTracker'fds).

Class ProgressTracker_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] ProgressTracker_type_repr  :: go.TypeReprUnderlying ProgressTrackerⁱᵐᵖˡ ProgressTracker.t;
  #[global] ProgressTracker_underlying :: (ProgressTracker) <u (ProgressTrackerⁱᵐᵖˡ);
  #[global] ProgressTracker_get_Config (x : ProgressTracker.t) :: ⟦StructFieldGet (ProgressTrackerⁱᵐᵖˡ) "Config", #x⟧ ⤳[under] #x.(ProgressTracker.Config');
  #[global] ProgressTracker_set_Config (x : ProgressTracker.t) y :: ⟦StructFieldSet (ProgressTrackerⁱᵐᵖˡ) "Config", (#x, #y)⟧ ⤳[under] #(x <|ProgressTracker.Config' := y|>);
  #[global] ProgressTracker_get_Progress (x : ProgressTracker.t) :: ⟦StructFieldGet (ProgressTrackerⁱᵐᵖˡ) "Progress", #x⟧ ⤳[under] #x.(ProgressTracker.Progress');
  #[global] ProgressTracker_set_Progress (x : ProgressTracker.t) y :: ⟦StructFieldSet (ProgressTrackerⁱᵐᵖˡ) "Progress", (#x, #y)⟧ ⤳[under] #(x <|ProgressTracker.Progress' := y|>);
  #[global] ProgressTracker_get_Votes (x : ProgressTracker.t) :: ⟦StructFieldGet (ProgressTrackerⁱᵐᵖˡ) "Votes", #x⟧ ⤳[under] #x.(ProgressTracker.Votes');
  #[global] ProgressTracker_set_Votes (x : ProgressTracker.t) y :: ⟦StructFieldSet (ProgressTrackerⁱᵐᵖˡ) "Votes", (#x, #y)⟧ ⤳[under] #(x <|ProgressTracker.Votes' := y|>);
  #[global] ProgressTracker_get_MaxInflight (x : ProgressTracker.t) :: ⟦StructFieldGet (ProgressTrackerⁱᵐᵖˡ) "MaxInflight", #x⟧ ⤳[under] #x.(ProgressTracker.MaxInflight');
  #[global] ProgressTracker_set_MaxInflight (x : ProgressTracker.t) y :: ⟦StructFieldSet (ProgressTrackerⁱᵐᵖˡ) "MaxInflight", (#x, #y)⟧ ⤳[under] #(x <|ProgressTracker.MaxInflight' := y|>);
  #[global] ProgressTracker_get_MaxInflightBytes (x : ProgressTracker.t) :: ⟦StructFieldGet (ProgressTrackerⁱᵐᵖˡ) "MaxInflightBytes", #x⟧ ⤳[under] #x.(ProgressTracker.MaxInflightBytes');
  #[global] ProgressTracker_set_MaxInflightBytes (x : ProgressTracker.t) y :: ⟦StructFieldSet (ProgressTrackerⁱᵐᵖˡ) "MaxInflightBytes", (#x, #y)⟧ ⤳[under] #(x <|ProgressTracker.MaxInflightBytes' := y|>);
  #[global] ProgressTracker_String_unfold :: MethodUnfold (ProgressTracker) "String" (λ: "$r", MethodResolve Config "String" (StructFieldGet (ProgressTracker) "Config" "$r" ))%V;
  #[global] ProgressTracker'ptr_Clone_unfold :: MethodUnfold (go.PointerType (ProgressTracker)) "Clone" (λ: "$r", MethodResolve (go.PointerType Config) "Clone" (StructFieldRef ProgressTracker "Config"%go "$r"));
  #[global] ProgressTracker'ptr_Committed_unfold :: MethodUnfold (go.PointerType (ProgressTracker)) "Committed" (ProgressTracker__Committedⁱᵐᵖˡ);
  #[global] ProgressTracker'ptr_ConfState_unfold :: MethodUnfold (go.PointerType (ProgressTracker)) "ConfState" (ProgressTracker__ConfStateⁱᵐᵖˡ);
  #[global] ProgressTracker'ptr_IsSingleton_unfold :: MethodUnfold (go.PointerType (ProgressTracker)) "IsSingleton" (ProgressTracker__IsSingletonⁱᵐᵖˡ);
  #[global] ProgressTracker'ptr_LearnerNodes_unfold :: MethodUnfold (go.PointerType (ProgressTracker)) "LearnerNodes" (ProgressTracker__LearnerNodesⁱᵐᵖˡ);
  #[global] ProgressTracker'ptr_QuorumActive_unfold :: MethodUnfold (go.PointerType (ProgressTracker)) "QuorumActive" (ProgressTracker__QuorumActiveⁱᵐᵖˡ);
  #[global] ProgressTracker'ptr_RecordVote_unfold :: MethodUnfold (go.PointerType (ProgressTracker)) "RecordVote" (ProgressTracker__RecordVoteⁱᵐᵖˡ);
  #[global] ProgressTracker'ptr_ResetVotes_unfold :: MethodUnfold (go.PointerType (ProgressTracker)) "ResetVotes" (ProgressTracker__ResetVotesⁱᵐᵖˡ);
  #[global] ProgressTracker'ptr_String_unfold :: MethodUnfold (go.PointerType (ProgressTracker)) "String" (λ: "$r", MethodResolve (go.PointerType Config) "String" (StructFieldRef ProgressTracker "Config"%go "$r"));
  #[global] ProgressTracker'ptr_TallyVotes_unfold :: MethodUnfold (go.PointerType (ProgressTracker)) "TallyVotes" (ProgressTracker__TallyVotesⁱᵐᵖˡ);
  #[global] ProgressTracker'ptr_Visit_unfold :: MethodUnfold (go.PointerType (ProgressTracker)) "Visit" (ProgressTracker__Visitⁱᵐᵖˡ);
  #[global] ProgressTracker'ptr_VoterNodes_unfold :: MethodUnfold (go.PointerType (ProgressTracker)) "VoterNodes" (ProgressTracker__VoterNodesⁱᵐᵖˡ);
}.

Module matchAckIndexer.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Definition t : Type := map.t.
End def.
End matchAckIndexer.

Definition matchAckIndexerⁱᵐᵖˡ {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.MapType go.uint64 (go.PointerType Progress).

Class matchAckIndexer_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] matchAckIndexer_underlying :: (matchAckIndexer) <u (matchAckIndexerⁱᵐᵖˡ);
  #[global] matchAckIndexer_AckedIndex_unfold :: MethodUnfold (matchAckIndexer) "AckedIndex" (matchAckIndexer__AckedIndexⁱᵐᵖˡ);
  #[global] matchAckIndexer'ptr_AckedIndex_unfold :: MethodUnfold (go.PointerType (matchAckIndexer)) "AckedIndex" (λ: "$r", MethodResolve (matchAckIndexer) "AckedIndex" (![(matchAckIndexer)] "$r"));
}.

Class Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] inflight_instance :: inflight_Assumptions;
  #[global] Inflights_instance :: Inflights_Assumptions;
  #[global] Progress_instance :: Progress_Assumptions;
  #[global] ProgressMap_instance :: ProgressMap_Assumptions;
  #[global] StateType_instance :: StateType_Assumptions;
  #[global] Config_instance :: Config_Assumptions;
  #[global] ProgressTracker_instance :: ProgressTracker_Assumptions;
  #[global] matchAckIndexer_instance :: matchAckIndexer_Assumptions;
  #[global] NewInflights_unfold :: FuncUnfold NewInflights [] (NewInflightsⁱᵐᵖˡ);
  #[global] MakeProgressTracker_unfold :: FuncUnfold MakeProgressTracker [] (MakeProgressTrackerⁱᵐᵖˡ);
  #[global] import_fmt_Assumption :: fmt.Assumptions;
  #[global] import_strings_Assumption :: strings.Assumptions;
  #[global] import_slices_Assumption :: slices.Assumptions;
  #[global] import_quorum_Assumption :: quorum.Assumptions;
  #[global] import_raftpb_Assumption :: raftpb.Assumptions;
}.
End tracker.
