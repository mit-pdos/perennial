(* autogenerated from go.etcd.io/raft/v3/tracker *)
From New.golang Require Import defn.
From New.code Require Import fmt.
From New.code Require Import go_etcd_io.raft.v3.quorum.
From New.code Require Import go_etcd_io.raft.v3.quorum.slices64.
From New.code Require Import go_etcd_io.raft.v3.raftpb.
From New.code Require Import sort.
From New.code Require Import strings.

Module tracker.
Section code.
Context `{ffi_syntax}.


Definition inflight : go_type := structT [
  "index" :: uint64T;
  "bytes" :: uint64T
].

Definition Inflights : go_type := structT [
  "start" :: intT;
  "count" :: intT;
  "bytes" :: uint64T;
  "size" :: intT;
  "maxBytes" :: uint64T;
  "buffer" :: sliceT
].

(* NewInflights sets up an Inflights that allows up to size inflight messages,
   with the total byte size up to maxBytes. If maxBytes is 0 then there is no
   byte size limit. The maxBytes limit is soft, i.e. we accept a single message
   that brings it from size < maxBytes to size >= maxBytes.

   go: inflights.go:46:6 *)
Definition NewInflights : val :=
  rec: "NewInflights" "size" "maxBytes" :=
    exception_do (let: "maxBytes" := (ref_ty uint64T "maxBytes") in
    let: "size" := (ref_ty intT "size") in
    return: (ref_ty Inflights (let: "$size" := (![intT] "size") in
     let: "$maxBytes" := (![uint64T] "maxBytes") in
     struct.make Inflights [{
       "start" ::= zero_val intT;
       "count" ::= zero_val intT;
       "bytes" ::= zero_val uint64T;
       "size" ::= "$size";
       "maxBytes" ::= "$maxBytes";
       "buffer" ::= zero_val sliceT
     }]))).

(* Clone returns an *Inflights that is identical to but shares no memory with
   the receiver.

   go: inflights.go:55:22 *)
Definition Inflights__Clone : val :=
  rec: "Inflights__Clone" "in" <> :=
    exception_do (let: "in" := (ref_ty ptrT "in") in
    let: "ins" := (ref_ty Inflights (zero_val Inflights)) in
    let: "$r0" := (![Inflights] (![ptrT] "in")) in
    do:  ("ins" <-[Inflights] "$r0");;;
    let: "$r0" := (let: "$a0" := #slice.nil in
    let: "$a1" := (![sliceT] (struct.field_ref Inflights "buffer" (![ptrT] "in"))) in
    (slice.append sliceT) "$a0" "$a1") in
    do:  ((struct.field_ref Inflights "buffer" "ins") <-[sliceT] "$r0");;;
    return: ("ins")).

Definition pkg_name' : go_string := "go.etcd.io/raft/v3/tracker".

(* Add notifies the Inflights that a new message with the given index and byte
   size is being dispatched. Full() must be called prior to Add() to verify that
   there is room for one more message, and consecutive calls to Add() must
   provide a monotonic sequence of indexes.

   go: inflights.go:65:22 *)
Definition Inflights__Add : val :=
  rec: "Inflights__Add" "in" "index" "bytes" :=
    exception_do (let: "in" := (ref_ty ptrT "in") in
    let: "bytes" := (ref_ty uint64T "bytes") in
    let: "index" := (ref_ty uint64T "index") in
    (if: (method_call #pkg_name' #"Inflights'ptr" #"Full" (![ptrT] "in")) #()
    then
      do:  (let: "$a0" := (interface.make #""%go #"string"%go #"cannot add into a Full inflights"%go) in
      Panic "$a0")
    else do:  #());;;
    let: "next" := (ref_ty intT (zero_val intT)) in
    let: "$r0" := ((![intT] (struct.field_ref Inflights "start" (![ptrT] "in"))) + (![intT] (struct.field_ref Inflights "count" (![ptrT] "in")))) in
    do:  ("next" <-[intT] "$r0");;;
    let: "size" := (ref_ty intT (zero_val intT)) in
    let: "$r0" := (![intT] (struct.field_ref Inflights "size" (![ptrT] "in"))) in
    do:  ("size" <-[intT] "$r0");;;
    (if: int_geq (![intT] "next") (![intT] "size")
    then do:  ("next" <-[intT] ((![intT] "next") - (![intT] "size")))
    else do:  #());;;
    (if: int_geq (![intT] "next") (let: "$a0" := (![sliceT] (struct.field_ref Inflights "buffer" (![ptrT] "in"))) in
    slice.len "$a0")
    then do:  ((method_call #pkg_name' #"Inflights'ptr" #"grow" (![ptrT] "in")) #())
    else do:  #());;;
    let: "$r0" := (let: "$index" := (![uint64T] "index") in
    let: "$bytes" := (![uint64T] "bytes") in
    struct.make inflight [{
      "index" ::= "$index";
      "bytes" ::= "$bytes"
    }]) in
    do:  ((slice.elem_ref inflight (![sliceT] (struct.field_ref Inflights "buffer" (![ptrT] "in"))) (![intT] "next")) <-[inflight] "$r0");;;
    do:  ((struct.field_ref Inflights "count" (![ptrT] "in")) <-[intT] ((![intT] (struct.field_ref Inflights "count" (![ptrT] "in"))) + #(W64 1)));;;
    do:  ((struct.field_ref Inflights "bytes" (![ptrT] "in")) <-[uint64T] ((![uint64T] (struct.field_ref Inflights "bytes" (![ptrT] "in"))) + (![uint64T] "bytes")))).

(* grow the inflight buffer by doubling up to inflights.size. We grow on demand
   instead of preallocating to inflights.size to handle systems which have
   thousands of Raft groups per process.

   go: inflights.go:85:22 *)
Definition Inflights__grow : val :=
  rec: "Inflights__grow" "in" <> :=
    exception_do (let: "in" := (ref_ty ptrT "in") in
    let: "newSize" := (ref_ty intT (zero_val intT)) in
    let: "$r0" := ((let: "$a0" := (![sliceT] (struct.field_ref Inflights "buffer" (![ptrT] "in"))) in
    slice.len "$a0") * #(W64 2)) in
    do:  ("newSize" <-[intT] "$r0");;;
    (if: (![intT] "newSize") = #(W64 0)
    then
      let: "$r0" := #(W64 1) in
      do:  ("newSize" <-[intT] "$r0")
    else
      (if: int_gt (![intT] "newSize") (![intT] (struct.field_ref Inflights "size" (![ptrT] "in")))
      then
        let: "$r0" := (![intT] (struct.field_ref Inflights "size" (![ptrT] "in"))) in
        do:  ("newSize" <-[intT] "$r0")
      else do:  #()));;;
    let: "newBuffer" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (slice.make2 inflight (![intT] "newSize")) in
    do:  ("newBuffer" <-[sliceT] "$r0");;;
    do:  (let: "$a0" := (![sliceT] "newBuffer") in
    let: "$a1" := (![sliceT] (struct.field_ref Inflights "buffer" (![ptrT] "in"))) in
    (slice.copy inflight) "$a0" "$a1");;;
    let: "$r0" := (![sliceT] "newBuffer") in
    do:  ((struct.field_ref Inflights "buffer" (![ptrT] "in")) <-[sliceT] "$r0")).

(* FreeLE frees the inflights smaller or equal to the given `to` flight.

   go: inflights.go:98:22 *)
Definition Inflights__FreeLE : val :=
  rec: "Inflights__FreeLE" "in" "to" :=
    exception_do (let: "in" := (ref_ty ptrT "in") in
    let: "to" := (ref_ty uint64T "to") in
    (if: ((![intT] (struct.field_ref Inflights "count" (![ptrT] "in"))) = #(W64 0)) || ((![uint64T] "to") < (![uint64T] (struct.field_ref inflight "index" (slice.elem_ref inflight (![sliceT] (struct.field_ref Inflights "buffer" (![ptrT] "in"))) (![intT] (struct.field_ref Inflights "start" (![ptrT] "in")))))))
    then return: (#())
    else do:  #());;;
    let: "idx" := (ref_ty intT (zero_val intT)) in
    let: "$r0" := (![intT] (struct.field_ref Inflights "start" (![ptrT] "in"))) in
    do:  ("idx" <-[intT] "$r0");;;
    let: "i" := (ref_ty intT (zero_val intT)) in
    let: "bytes" := (ref_ty uint64T (zero_val uint64T)) in
    (let: "$r0" := #(W64 0) in
    do:  ("i" <-[intT] "$r0");;;
    (for: (λ: <>, int_lt (![intT] "i") (![intT] (struct.field_ref Inflights "count" (![ptrT] "in")))); (λ: <>, do:  ("i" <-[intT] ((![intT] "i") + #(W64 1)))) := λ: <>,
      (if: (![uint64T] "to") < (![uint64T] (struct.field_ref inflight "index" (slice.elem_ref inflight (![sliceT] (struct.field_ref Inflights "buffer" (![ptrT] "in"))) (![intT] "idx"))))
      then break: #()
      else do:  #());;;
      do:  ("bytes" <-[uint64T] ((![uint64T] "bytes") + (![uint64T] (struct.field_ref inflight "bytes" (slice.elem_ref inflight (![sliceT] (struct.field_ref Inflights "buffer" (![ptrT] "in"))) (![intT] "idx"))))));;;
      let: "size" := (ref_ty intT (zero_val intT)) in
      let: "$r0" := (![intT] (struct.field_ref Inflights "size" (![ptrT] "in"))) in
      do:  ("size" <-[intT] "$r0");;;
      (do:  ("idx" <-[intT] ((![intT] "idx") + #(W64 1)));;;
      (if: int_geq (![intT] "idx") (![intT] "size")
      then do:  ("idx" <-[intT] ((![intT] "idx") - (![intT] "size")))
      else do:  #()))));;;
    do:  ((struct.field_ref Inflights "count" (![ptrT] "in")) <-[intT] ((![intT] (struct.field_ref Inflights "count" (![ptrT] "in"))) - (![intT] "i")));;;
    do:  ((struct.field_ref Inflights "bytes" (![ptrT] "in")) <-[uint64T] ((![uint64T] (struct.field_ref Inflights "bytes" (![ptrT] "in"))) - (![uint64T] "bytes")));;;
    let: "$r0" := (![intT] "idx") in
    do:  ((struct.field_ref Inflights "start" (![ptrT] "in")) <-[intT] "$r0");;;
    (if: (![intT] (struct.field_ref Inflights "count" (![ptrT] "in"))) = #(W64 0)
    then
      let: "$r0" := #(W64 0) in
      do:  ((struct.field_ref Inflights "start" (![ptrT] "in")) <-[intT] "$r0")
    else do:  #())).

(* Full returns true if no more messages can be sent at the moment.

   go: inflights.go:131:22 *)
Definition Inflights__Full : val :=
  rec: "Inflights__Full" "in" <> :=
    exception_do (let: "in" := (ref_ty ptrT "in") in
    return: (((![intT] (struct.field_ref Inflights "count" (![ptrT] "in"))) = (![intT] (struct.field_ref Inflights "size" (![ptrT] "in")))) || (((![uint64T] (struct.field_ref Inflights "maxBytes" (![ptrT] "in"))) ≠ #(W64 0)) && ((![uint64T] (struct.field_ref Inflights "bytes" (![ptrT] "in"))) ≥ (![uint64T] (struct.field_ref Inflights "maxBytes" (![ptrT] "in"))))))).

(* Count returns the number of inflight messages.

   go: inflights.go:136:22 *)
Definition Inflights__Count : val :=
  rec: "Inflights__Count" "in" <> :=
    exception_do (let: "in" := (ref_ty ptrT "in") in
    return: (![intT] (struct.field_ref Inflights "count" (![ptrT] "in")))).

(* reset frees all inflights.

   go: inflights.go:139:22 *)
Definition Inflights__reset : val :=
  rec: "Inflights__reset" "in" <> :=
    exception_do (let: "in" := (ref_ty ptrT "in") in
    let: "$r0" := #(W64 0) in
    do:  ((struct.field_ref Inflights "start" (![ptrT] "in")) <-[intT] "$r0");;;
    let: "$r0" := #(W64 0) in
    do:  ((struct.field_ref Inflights "count" (![ptrT] "in")) <-[intT] "$r0");;;
    let: "$r0" := #(W64 0) in
    do:  ((struct.field_ref Inflights "bytes" (![ptrT] "in")) <-[uint64T] "$r0")).

Definition StateType : go_type := uint64T.

Definition Progress : go_type := structT [
  "Match" :: uint64T;
  "Next" :: uint64T;
  "sentCommit" :: uint64T;
  "State" :: StateType;
  "PendingSnapshot" :: uint64T;
  "RecentActive" :: boolT;
  "MsgAppFlowPaused" :: boolT;
  "Inflights" :: ptrT;
  "IsLearner" :: boolT
].

(* ResetState moves the Progress into the specified State, resetting MsgAppFlowPaused,
   PendingSnapshot, and Inflights.

   go: progress.go:121:21 *)
Definition Progress__ResetState : val :=
  rec: "Progress__ResetState" "pr" "state" :=
    exception_do (let: "pr" := (ref_ty ptrT "pr") in
    let: "state" := (ref_ty StateType "state") in
    let: "$r0" := #false in
    do:  ((struct.field_ref Progress "MsgAppFlowPaused" (![ptrT] "pr")) <-[boolT] "$r0");;;
    let: "$r0" := #(W64 0) in
    do:  ((struct.field_ref Progress "PendingSnapshot" (![ptrT] "pr")) <-[uint64T] "$r0");;;
    let: "$r0" := (![StateType] "state") in
    do:  ((struct.field_ref Progress "State" (![ptrT] "pr")) <-[StateType] "$r0");;;
    do:  ((method_call #pkg_name' #"Inflights'ptr" #"reset" (![ptrT] (struct.field_ref Progress "Inflights" (![ptrT] "pr")))) #())).

Definition StateProbe : expr := #(W64 0).

Definition StateSnapshot : expr := #(W64 2).

(* BecomeProbe transitions into StateProbe. Next is reset to Match+1 or,
   optionally and if larger, the index of the pending snapshot.

   go: progress.go:130:21 *)
Definition Progress__BecomeProbe : val :=
  rec: "Progress__BecomeProbe" "pr" <> :=
    exception_do (let: "pr" := (ref_ty ptrT "pr") in
    (if: (![StateType] (struct.field_ref Progress "State" (![ptrT] "pr"))) = StateSnapshot
    then
      let: "pendingSnapshot" := (ref_ty uint64T (zero_val uint64T)) in
      let: "$r0" := (![uint64T] (struct.field_ref Progress "PendingSnapshot" (![ptrT] "pr"))) in
      do:  ("pendingSnapshot" <-[uint64T] "$r0");;;
      do:  (let: "$a0" := StateProbe in
      (method_call #pkg_name' #"Progress'ptr" #"ResetState" (![ptrT] "pr")) "$a0");;;
      let: "$r0" := (let: "$a0" := ((![uint64T] (struct.field_ref Progress "Match" (![ptrT] "pr"))) + #(W64 1)) in
      let: "$a1" := ((![uint64T] "pendingSnapshot") + #(W64 1)) in
      (maxUint64 2) "$a0" "$a1") in
      do:  ((struct.field_ref Progress "Next" (![ptrT] "pr")) <-[uint64T] "$r0")
    else
      do:  (let: "$a0" := StateProbe in
      (method_call #pkg_name' #"Progress'ptr" #"ResetState" (![ptrT] "pr")) "$a0");;;
      let: "$r0" := ((![uint64T] (struct.field_ref Progress "Match" (![ptrT] "pr"))) + #(W64 1)) in
      do:  ((struct.field_ref Progress "Next" (![ptrT] "pr")) <-[uint64T] "$r0"));;;
    let: "$r0" := (let: "$a0" := (![uint64T] (struct.field_ref Progress "sentCommit" (![ptrT] "pr"))) in
    let: "$a1" := ((![uint64T] (struct.field_ref Progress "Next" (![ptrT] "pr"))) - #(W64 1)) in
    (minUint64 2) "$a0" "$a1") in
    do:  ((struct.field_ref Progress "sentCommit" (![ptrT] "pr")) <-[uint64T] "$r0")).

Definition StateReplicate : expr := #(W64 1).

(* BecomeReplicate transitions into StateReplicate, resetting Next to Match+1.

   go: progress.go:146:21 *)
Definition Progress__BecomeReplicate : val :=
  rec: "Progress__BecomeReplicate" "pr" <> :=
    exception_do (let: "pr" := (ref_ty ptrT "pr") in
    do:  (let: "$a0" := StateReplicate in
    (method_call #pkg_name' #"Progress'ptr" #"ResetState" (![ptrT] "pr")) "$a0");;;
    let: "$r0" := ((![uint64T] (struct.field_ref Progress "Match" (![ptrT] "pr"))) + #(W64 1)) in
    do:  ((struct.field_ref Progress "Next" (![ptrT] "pr")) <-[uint64T] "$r0")).

(* BecomeSnapshot moves the Progress to StateSnapshot with the specified pending
   snapshot index.

   go: progress.go:153:21 *)
Definition Progress__BecomeSnapshot : val :=
  rec: "Progress__BecomeSnapshot" "pr" "snapshoti" :=
    exception_do (let: "pr" := (ref_ty ptrT "pr") in
    let: "snapshoti" := (ref_ty uint64T "snapshoti") in
    do:  (let: "$a0" := StateSnapshot in
    (method_call #pkg_name' #"Progress'ptr" #"ResetState" (![ptrT] "pr")) "$a0");;;
    let: "$r0" := (![uint64T] "snapshoti") in
    do:  ((struct.field_ref Progress "PendingSnapshot" (![ptrT] "pr")) <-[uint64T] "$r0");;;
    let: "$r0" := ((![uint64T] "snapshoti") + #(W64 1)) in
    do:  ((struct.field_ref Progress "Next" (![ptrT] "pr")) <-[uint64T] "$r0");;;
    let: "$r0" := (![uint64T] "snapshoti") in
    do:  ((struct.field_ref Progress "sentCommit" (![ptrT] "pr")) <-[uint64T] "$r0")).

(* SentEntries updates the progress on the given number of consecutive entries
   being sent in a MsgApp, with the given total bytes size, appended at log
   indices >= pr.Next.

   Must be used with StateProbe or StateReplicate.

   go: progress.go:165:21 *)
Definition Progress__SentEntries : val :=
  rec: "Progress__SentEntries" "pr" "entries" "bytes" :=
    exception_do (let: "pr" := (ref_ty ptrT "pr") in
    let: "bytes" := (ref_ty uint64T "bytes") in
    let: "entries" := (ref_ty intT "entries") in
    let: "$sw" := (![StateType] (struct.field_ref Progress "State" (![ptrT] "pr"))) in
    (if: "$sw" = StateReplicate
    then
      (if: int_gt (![intT] "entries") #(W64 0)
      then
        do:  ((struct.field_ref Progress "Next" (![ptrT] "pr")) <-[uint64T] ((![uint64T] (struct.field_ref Progress "Next" (![ptrT] "pr"))) + (![intT] "entries")));;;
        do:  (let: "$a0" := ((![uint64T] (struct.field_ref Progress "Next" (![ptrT] "pr"))) - #(W64 1)) in
        let: "$a1" := (![uint64T] "bytes") in
        (method_call #pkg_name' #"Inflights'ptr" #"Add" (![ptrT] (struct.field_ref Progress "Inflights" (![ptrT] "pr")))) "$a0" "$a1")
      else do:  #());;;
      let: "$r0" := ((method_call #pkg_name' #"Inflights'ptr" #"Full" (![ptrT] (struct.field_ref Progress "Inflights" (![ptrT] "pr")))) #()) in
      do:  ((struct.field_ref Progress "MsgAppFlowPaused" (![ptrT] "pr")) <-[boolT] "$r0")
    else
      (if: "$sw" = StateProbe
      then
        (if: int_gt (![intT] "entries") #(W64 0)
        then
          let: "$r0" := #true in
          do:  ((struct.field_ref Progress "MsgAppFlowPaused" (![ptrT] "pr")) <-[boolT] "$r0")
        else do:  #())
      else
        do:  (let: "$a0" := (interface.make #""%go #"string"%go (let: "$a0" := #"sending append in unhandled state %s"%go in
        let: "$a1" := ((let: "$sl0" := (interface.make #pkg_name' #"StateType" (![StateType] (struct.field_ref Progress "State" (![ptrT] "pr")))) in
        slice.literal interfaceT ["$sl0"])) in
        (func_call #fmt.pkg_name' #"Sprintf"%go) "$a0" "$a1")) in
        Panic "$a0")))).

(* CanBumpCommit returns true if sending the given commit index can potentially
   advance the follower's commit index.

   go: progress.go:189:21 *)
Definition Progress__CanBumpCommit : val :=
  rec: "Progress__CanBumpCommit" "pr" "index" :=
    exception_do (let: "pr" := (ref_ty ptrT "pr") in
    let: "index" := (ref_ty uint64T "index") in
    return: (((![uint64T] "index") > (![uint64T] (struct.field_ref Progress "sentCommit" (![ptrT] "pr")))) && ((![uint64T] (struct.field_ref Progress "sentCommit" (![ptrT] "pr"))) < ((![uint64T] (struct.field_ref Progress "Next" (![ptrT] "pr"))) - #(W64 1))))).

(* SentCommit updates the sentCommit.

   go: progress.go:198:21 *)
Definition Progress__SentCommit : val :=
  rec: "Progress__SentCommit" "pr" "commit" :=
    exception_do (let: "pr" := (ref_ty ptrT "pr") in
    let: "commit" := (ref_ty uint64T "commit") in
    let: "$r0" := (![uint64T] "commit") in
    do:  ((struct.field_ref Progress "sentCommit" (![ptrT] "pr")) <-[uint64T] "$r0")).

(* MaybeUpdate is called when an MsgAppResp arrives from the follower, with the
   index acked by it. The method returns false if the given n index comes from
   an outdated message. Otherwise it updates the progress and returns true.

   go: progress.go:205:21 *)
Definition Progress__MaybeUpdate : val :=
  rec: "Progress__MaybeUpdate" "pr" "n" :=
    exception_do (let: "pr" := (ref_ty ptrT "pr") in
    let: "n" := (ref_ty uint64T "n") in
    (if: (![uint64T] "n") ≤ (![uint64T] (struct.field_ref Progress "Match" (![ptrT] "pr")))
    then return: (#false)
    else do:  #());;;
    let: "$r0" := (![uint64T] "n") in
    do:  ((struct.field_ref Progress "Match" (![ptrT] "pr")) <-[uint64T] "$r0");;;
    let: "$r0" := (let: "$a0" := (![uint64T] (struct.field_ref Progress "Next" (![ptrT] "pr"))) in
    let: "$a1" := ((![uint64T] "n") + #(W64 1)) in
    (maxUint64 2) "$a0" "$a1") in
    do:  ((struct.field_ref Progress "Next" (![ptrT] "pr")) <-[uint64T] "$r0");;;
    let: "$r0" := #false in
    do:  ((struct.field_ref Progress "MsgAppFlowPaused" (![ptrT] "pr")) <-[boolT] "$r0");;;
    return: (#true)).

(* MaybeDecrTo adjusts the Progress to the receipt of a MsgApp rejection. The
   arguments are the index of the append message rejected by the follower, and
   the hint that we want to decrease to.

   Rejections can happen spuriously as messages are sent out of order or
   duplicated. In such cases, the rejection pertains to an index that the
   Progress already knows were previously acknowledged, and false is returned
   without changing the Progress.

   If the rejection is genuine, Next is lowered sensibly, and the Progress is
   cleared for sending log entries.

   go: progress.go:226:21 *)
Definition Progress__MaybeDecrTo : val :=
  rec: "Progress__MaybeDecrTo" "pr" "rejected" "matchHint" :=
    exception_do (let: "pr" := (ref_ty ptrT "pr") in
    let: "matchHint" := (ref_ty uint64T "matchHint") in
    let: "rejected" := (ref_ty uint64T "rejected") in
    (if: (![StateType] (struct.field_ref Progress "State" (![ptrT] "pr"))) = StateReplicate
    then
      (if: (![uint64T] "rejected") ≤ (![uint64T] (struct.field_ref Progress "Match" (![ptrT] "pr")))
      then return: (#false)
      else do:  #());;;
      let: "$r0" := ((![uint64T] (struct.field_ref Progress "Match" (![ptrT] "pr"))) + #(W64 1)) in
      do:  ((struct.field_ref Progress "Next" (![ptrT] "pr")) <-[uint64T] "$r0");;;
      let: "$r0" := (let: "$a0" := (![uint64T] (struct.field_ref Progress "sentCommit" (![ptrT] "pr"))) in
      let: "$a1" := ((![uint64T] (struct.field_ref Progress "Next" (![ptrT] "pr"))) - #(W64 1)) in
      (minUint64 2) "$a0" "$a1") in
      do:  ((struct.field_ref Progress "sentCommit" (![ptrT] "pr")) <-[uint64T] "$r0");;;
      return: (#true)
    else do:  #());;;
    (if: ((![uint64T] (struct.field_ref Progress "Next" (![ptrT] "pr"))) - #(W64 1)) ≠ (![uint64T] "rejected")
    then return: (#false)
    else do:  #());;;
    let: "$r0" := (let: "$a0" := (let: "$a0" := (![uint64T] "rejected") in
    let: "$a1" := ((![uint64T] "matchHint") + #(W64 1)) in
    (minUint64 2) "$a0" "$a1") in
    let: "$a1" := ((![uint64T] (struct.field_ref Progress "Match" (![ptrT] "pr"))) + #(W64 1)) in
    (maxUint64 2) "$a0" "$a1") in
    do:  ((struct.field_ref Progress "Next" (![ptrT] "pr")) <-[uint64T] "$r0");;;
    let: "$r0" := (let: "$a0" := (![uint64T] (struct.field_ref Progress "sentCommit" (![ptrT] "pr"))) in
    let: "$a1" := ((![uint64T] (struct.field_ref Progress "Next" (![ptrT] "pr"))) - #(W64 1)) in
    (minUint64 2) "$a0" "$a1") in
    do:  ((struct.field_ref Progress "sentCommit" (![ptrT] "pr")) <-[uint64T] "$r0");;;
    let: "$r0" := #false in
    do:  ((struct.field_ref Progress "MsgAppFlowPaused" (![ptrT] "pr")) <-[boolT] "$r0");;;
    return: (#true)).

(* IsPaused returns whether sending log entries to this node has been throttled.
   This is done when a node has rejected recent MsgApps, is currently waiting
   for a snapshot, or has reached the MaxInflightMsgs limit. In normal
   operation, this is false. A throttled node will be contacted less frequently
   until it has reached a state in which it's able to accept a steady stream of
   log entries again.

   go: progress.go:262:21 *)
Definition Progress__IsPaused : val :=
  rec: "Progress__IsPaused" "pr" <> :=
    exception_do (let: "pr" := (ref_ty ptrT "pr") in
    let: "$sw" := (![StateType] (struct.field_ref Progress "State" (![ptrT] "pr"))) in
    (if: "$sw" = StateProbe
    then return: (![boolT] (struct.field_ref Progress "MsgAppFlowPaused" (![ptrT] "pr")))
    else
      (if: "$sw" = StateReplicate
      then return: (![boolT] (struct.field_ref Progress "MsgAppFlowPaused" (![ptrT] "pr")))
      else
        (if: "$sw" = StateSnapshot
        then return: (#true)
        else
          do:  (let: "$a0" := (interface.make #""%go #"string"%go #"unexpected state"%go) in
          Panic "$a0"))))).

(* go: progress.go:275:21 *)
Definition Progress__String : val :=
  rec: "Progress__String" "pr" <> :=
    exception_do (let: "pr" := (ref_ty ptrT "pr") in
    let: "buf" := (ref_ty strings.Builder (zero_val strings.Builder)) in
    do:  (let: "$a0" := (interface.make #strings.pkg_name' #"Builder'ptr" "buf") in
    let: "$a1" := #"%s match=%d next=%d"%go in
    let: "$a2" := ((let: "$sl0" := (interface.make #pkg_name' #"StateType" (![StateType] (struct.field_ref Progress "State" (![ptrT] "pr")))) in
    let: "$sl1" := (interface.make #""%go #"uint64"%go (![uint64T] (struct.field_ref Progress "Match" (![ptrT] "pr")))) in
    let: "$sl2" := (interface.make #""%go #"uint64"%go (![uint64T] (struct.field_ref Progress "Next" (![ptrT] "pr")))) in
    slice.literal interfaceT ["$sl0"; "$sl1"; "$sl2"])) in
    (func_call #fmt.pkg_name' #"Fprintf"%go) "$a0" "$a1" "$a2");;;
    (if: ![boolT] (struct.field_ref Progress "IsLearner" (![ptrT] "pr"))
    then
      do:  (let: "$a0" := (interface.make #strings.pkg_name' #"Builder'ptr" "buf") in
      let: "$a1" := ((let: "$sl0" := (interface.make #""%go #"string"%go #" learner"%go) in
      slice.literal interfaceT ["$sl0"])) in
      (func_call #fmt.pkg_name' #"Fprint"%go) "$a0" "$a1")
    else do:  #());;;
    (if: (method_call #pkg_name' #"Progress'ptr" #"IsPaused" (![ptrT] "pr")) #()
    then
      do:  (let: "$a0" := (interface.make #strings.pkg_name' #"Builder'ptr" "buf") in
      let: "$a1" := ((let: "$sl0" := (interface.make #""%go #"string"%go #" paused"%go) in
      slice.literal interfaceT ["$sl0"])) in
      (func_call #fmt.pkg_name' #"Fprint"%go) "$a0" "$a1")
    else do:  #());;;
    (if: (![uint64T] (struct.field_ref Progress "PendingSnapshot" (![ptrT] "pr"))) > #(W64 0)
    then
      do:  (let: "$a0" := (interface.make #strings.pkg_name' #"Builder'ptr" "buf") in
      let: "$a1" := #" pendingSnap=%d"%go in
      let: "$a2" := ((let: "$sl0" := (interface.make #""%go #"uint64"%go (![uint64T] (struct.field_ref Progress "PendingSnapshot" (![ptrT] "pr")))) in
      slice.literal interfaceT ["$sl0"])) in
      (func_call #fmt.pkg_name' #"Fprintf"%go) "$a0" "$a1" "$a2")
    else do:  #());;;
    (if: (~ (![boolT] (struct.field_ref Progress "RecentActive" (![ptrT] "pr"))))
    then
      do:  (let: "$a0" := (interface.make #strings.pkg_name' #"Builder'ptr" "buf") in
      let: "$a1" := ((let: "$sl0" := (interface.make #""%go #"string"%go #" inactive"%go) in
      slice.literal interfaceT ["$sl0"])) in
      (func_call #fmt.pkg_name' #"Fprint"%go) "$a0" "$a1")
    else do:  #());;;
    (let: "n" := (ref_ty intT (zero_val intT)) in
    let: "$r0" := ((method_call #pkg_name' #"Inflights'ptr" #"Count" (![ptrT] (struct.field_ref Progress "Inflights" (![ptrT] "pr")))) #()) in
    do:  ("n" <-[intT] "$r0");;;
    (if: int_gt (![intT] "n") #(W64 0)
    then
      do:  (let: "$a0" := (interface.make #strings.pkg_name' #"Builder'ptr" "buf") in
      let: "$a1" := #" inflight=%d"%go in
      let: "$a2" := ((let: "$sl0" := (interface.make #""%go #"int"%go (![intT] "n")) in
      slice.literal interfaceT ["$sl0"])) in
      (func_call #fmt.pkg_name' #"Fprintf"%go) "$a0" "$a1" "$a2");;;
      (if: (method_call #pkg_name' #"Inflights'ptr" #"Full" (![ptrT] (struct.field_ref Progress "Inflights" (![ptrT] "pr")))) #()
      then
        do:  (let: "$a0" := (interface.make #strings.pkg_name' #"Builder'ptr" "buf") in
        let: "$a1" := ((let: "$sl0" := (interface.make #""%go #"string"%go #"[full]"%go) in
        slice.literal interfaceT ["$sl0"])) in
        (func_call #fmt.pkg_name' #"Fprint"%go) "$a0" "$a1")
      else do:  #())
    else do:  #()));;;
    return: ((method_call #strings.pkg_name' #"Builder'ptr" #"String" "buf") #())).

Definition ProgressMap : go_type := mapT uint64T ptrT.

(* String prints the ProgressMap in sorted key order, one Progress per line.

   go: progress.go:303:22 *)
Definition ProgressMap__String : val :=
  rec: "ProgressMap__String" "m" <> :=
    exception_do (let: "m" := (ref_ty ProgressMap "m") in
    let: "ids" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (slice.make3 uint64T #(W64 0) (let: "$a0" := (![ProgressMap] "m") in
    map.len "$a0")) in
    do:  ("ids" <-[sliceT] "$r0");;;
    do:  (map.for_range (![ProgressMap] "m") (λ: "k" <>,
      let: "$r0" := (let: "$a0" := (![sliceT] "ids") in
      let: "$a1" := ((let: "$sl0" := (![uint64T] "k") in
      slice.literal uint64T ["$sl0"])) in
      (slice.append sliceT) "$a0" "$a1") in
      do:  ("ids" <-[sliceT] "$r0")));;;
    do:  (let: "$a0" := (interface.make #"slice'"%go (![sliceT] "ids")) in
    let: "$a1" := (λ: "i" "j",
      exception_do (let: "j" := (ref_ty intT "j") in
      let: "i" := (ref_ty intT "i") in
      return: ((![uint64T] (slice.elem_ref uint64T (![sliceT] "ids") (![intT] "i"))) < (![uint64T] (slice.elem_ref uint64T (![sliceT] "ids") (![intT] "j")))))
      ) in
    (func_call #sort.pkg_name' #"Slice"%go) "$a0" "$a1");;;
    let: "buf" := (ref_ty strings.Builder (zero_val strings.Builder)) in
    do:  (let: "$range" := (![sliceT] "ids") in
    slice.for_range uint64T "$range" (λ: <> "id",
      let: "id" := ref_ty uint64T "id" in
      do:  (let: "$a0" := (interface.make #strings.pkg_name' #"Builder'ptr" "buf") in
      let: "$a1" := #"%d: %s
      "%go in
      let: "$a2" := ((let: "$sl0" := (interface.make #""%go #"uint64"%go (![uint64T] "id")) in
      let: "$sl1" := (interface.make #pkg_name' #"Progress'ptr" (Fst (map.get (![ProgressMap] "m") (![uint64T] "id")))) in
      slice.literal interfaceT ["$sl0"; "$sl1"])) in
      (func_call #fmt.pkg_name' #"Fprintf"%go) "$a0" "$a1" "$a2")));;;
    return: ((method_call #strings.pkg_name' #"Builder'ptr" #"String" "buf") #())).

(* go: state.go:42:21 *)
Definition StateType__String : val :=
  rec: "StateType__String" "st" <> :=
    exception_do (let: "st" := (ref_ty StateType "st") in
    return: (![stringT] (array.elem_ref stringT (![arrayT 3 stringT] (globals.get #pkg_name' #"prstmap"%go)) (![StateType] "st")))).

Definition Config : go_type := structT [
  "Voters" :: quorum.JointConfig;
  "AutoLeave" :: boolT;
  "Learners" :: mapT uint64T (structT [
  ]);
  "LearnersNext" :: mapT uint64T (structT [
  ])
].

(* go: tracker.go:81:17 *)
Definition Config__String : val :=
  rec: "Config__String" "c" <> :=
    exception_do (let: "c" := (ref_ty Config "c") in
    let: "buf" := (ref_ty strings.Builder (zero_val strings.Builder)) in
    do:  (let: "$a0" := (interface.make #strings.pkg_name' #"Builder'ptr" "buf") in
    let: "$a1" := #"voters=%s"%go in
    let: "$a2" := ((let: "$sl0" := (interface.make #quorum.pkg_name' #"JointConfig" (![quorum.JointConfig] (struct.field_ref Config "Voters" "c"))) in
    slice.literal interfaceT ["$sl0"])) in
    (func_call #fmt.pkg_name' #"Fprintf"%go) "$a0" "$a1" "$a2");;;
    (if: (![mapT uint64T (structT [
    ])] (struct.field_ref Config "Learners" "c")) ≠ #null
    then
      do:  (let: "$a0" := (interface.make #strings.pkg_name' #"Builder'ptr" "buf") in
      let: "$a1" := #" learners=%s"%go in
      let: "$a2" := ((let: "$sl0" := (interface.make #""%go #"string"%go ((method_call #quorum.pkg_name' #"MajorityConfig" #"String" "String" #() (![mapT uint64T (structT [
      ])] (struct.field_ref Config "Learners" "c"))) #())) in
      slice.literal interfaceT ["$sl0"])) in
      (func_call #fmt.pkg_name' #"Fprintf"%go) "$a0" "$a1" "$a2")
    else do:  #());;;
    (if: (![mapT uint64T (structT [
    ])] (struct.field_ref Config "LearnersNext" "c")) ≠ #null
    then
      do:  (let: "$a0" := (interface.make #strings.pkg_name' #"Builder'ptr" "buf") in
      let: "$a1" := #" learners_next=%s"%go in
      let: "$a2" := ((let: "$sl0" := (interface.make #""%go #"string"%go ((method_call #quorum.pkg_name' #"MajorityConfig" #"String" "String" #() (![mapT uint64T (structT [
      ])] (struct.field_ref Config "LearnersNext" "c"))) #())) in
      slice.literal interfaceT ["$sl0"])) in
      (func_call #fmt.pkg_name' #"Fprintf"%go) "$a0" "$a1" "$a2")
    else do:  #());;;
    (if: ![boolT] (struct.field_ref Config "AutoLeave" "c")
    then
      do:  (let: "$a0" := (interface.make #strings.pkg_name' #"Builder'ptr" "buf") in
      let: "$a1" := ((let: "$sl0" := (interface.make #""%go #"string"%go #" autoleave"%go) in
      slice.literal interfaceT ["$sl0"])) in
      (func_call #fmt.pkg_name' #"Fprint"%go) "$a0" "$a1")
    else do:  #());;;
    return: ((method_call #strings.pkg_name' #"Builder'ptr" #"String" "buf") #())).

(* Clone returns a copy of the Config that shares no memory with the original.

   go: tracker.go:97:18 *)
Definition Config__Clone : val :=
  rec: "Config__Clone" "c" <> :=
    exception_do (let: "c" := (ref_ty ptrT "c") in
    let: "clone" := (ref_ty funcT (zero_val funcT)) in
    let: "$r0" := (λ: "m",
      exception_do (let: "m" := (ref_ty (mapT uint64T (structT [
      ])) "m") in
      (if: (![mapT uint64T (structT [
      ])] "m") = #null
      then return: (#null)
      else do:  #());;;
      let: "mm" := (ref_ty (mapT uint64T (structT [
      ])) (zero_val (mapT uint64T (structT [
      ])))) in
      let: "$r0" := (map.make uint64T (structT [
      ]) #()) in
      do:  ("mm" <-[mapT uint64T (structT [
      ])] "$r0");;;
      do:  (map.for_range (![mapT uint64T (structT [
      ])] "m") (λ: "k" <>,
        let: "$r0" := (struct.make (structT [
        ]) [{
        }]) in
        do:  (map.insert (![mapT uint64T (structT [
        ])] "mm") (![uint64T] "k") "$r0")));;;
      return: (![mapT uint64T (structT [
       ])] "mm"))
      ) in
    do:  ("clone" <-[funcT] "$r0");;;
    return: (let: "$Voters" := ((let: "$ar0" := (let: "$a0" := (![quorum.MajorityConfig] (array.elem_ref quorum.MajorityConfig (![quorum.JointConfig] (struct.field_ref Config "Voters" (![ptrT] "c"))) #(W64 0))) in
     (![funcT] "clone") "$a0") in
     let: "$ar1" := (let: "$a0" := (![quorum.MajorityConfig] (array.elem_ref quorum.MajorityConfig (![quorum.JointConfig] (struct.field_ref Config "Voters" (![ptrT] "c"))) #(W64 1))) in
     (![funcT] "clone") "$a0") in
     array.literal ["$ar0"; "$ar1"])) in
     let: "$Learners" := (let: "$a0" := (![mapT uint64T (structT [
     ])] (struct.field_ref Config "Learners" (![ptrT] "c"))) in
     (![funcT] "clone") "$a0") in
     let: "$LearnersNext" := (let: "$a0" := (![mapT uint64T (structT [
     ])] (struct.field_ref Config "LearnersNext" (![ptrT] "c"))) in
     (![funcT] "clone") "$a0") in
     struct.make Config [{
       "Voters" ::= "$Voters";
       "AutoLeave" ::= zero_val boolT;
       "Learners" ::= "$Learners";
       "LearnersNext" ::= "$LearnersNext"
     }])).

Definition ProgressTracker : go_type := structT [
  "Config" :: Config;
  "Progress" :: ProgressMap;
  "Votes" :: mapT uint64T boolT;
  "MaxInflight" :: intT;
  "MaxInflightBytes" :: uint64T
].

(* MakeProgressTracker initializes a ProgressTracker.

   go: tracker.go:130:6 *)
Definition MakeProgressTracker : val :=
  rec: "MakeProgressTracker" "maxInflight" "maxBytes" :=
    exception_do (let: "maxBytes" := (ref_ty uint64T "maxBytes") in
    let: "maxInflight" := (ref_ty intT "maxInflight") in
    let: "p" := (ref_ty ProgressTracker (zero_val ProgressTracker)) in
    let: "$r0" := (let: "$MaxInflight" := (![intT] "maxInflight") in
    let: "$MaxInflightBytes" := (![uint64T] "maxBytes") in
    let: "$Config" := (let: "$Voters" := ((let: "$ar0" := (map.make uint64T (structT [
    ]) #()) in
    let: "$ar1" := #null in
    array.literal ["$ar0"; "$ar1"])) in
    let: "$Learners" := #null in
    let: "$LearnersNext" := #null in
    struct.make Config [{
      "Voters" ::= "$Voters";
      "AutoLeave" ::= zero_val boolT;
      "Learners" ::= "$Learners";
      "LearnersNext" ::= "$LearnersNext"
    }]) in
    let: "$Votes" := (map.make uint64T boolT #()) in
    let: "$Progress" := (map.make uint64T ptrT #()) in
    struct.make ProgressTracker [{
      "Config" ::= "$Config";
      "Progress" ::= "$Progress";
      "Votes" ::= "$Votes";
      "MaxInflight" ::= "$MaxInflight";
      "MaxInflightBytes" ::= "$MaxInflightBytes"
    }]) in
    do:  ("p" <-[ProgressTracker] "$r0");;;
    return: (![ProgressTracker] "p")).

(* ConfState returns a ConfState representing the active configuration.

   go: tracker.go:149:27 *)
Definition ProgressTracker__ConfState : val :=
  rec: "ProgressTracker__ConfState" "p" <> :=
    exception_do (let: "p" := (ref_ty ptrT "p") in
    return: (let: "$Voters" := ((method_call #quorum.pkg_name' #"MajorityConfig" #"Slice" (![quorum.MajorityConfig] (array.elem_ref quorum.MajorityConfig (![quorum.JointConfig] (struct.field_ref Config "Voters" (struct.field_ref ProgressTracker "Config" (![ptrT] "p")))) #(W64 0)))) #()) in
     let: "$VotersOutgoing" := ((method_call #quorum.pkg_name' #"MajorityConfig" #"Slice" (![quorum.MajorityConfig] (array.elem_ref quorum.MajorityConfig (![quorum.JointConfig] (struct.field_ref Config "Voters" (struct.field_ref ProgressTracker "Config" (![ptrT] "p")))) #(W64 1)))) #()) in
     let: "$Learners" := ((method_call #quorum.pkg_name' #"MajorityConfig" #"Slice" "Slice" #() (![mapT uint64T (structT [
     ])] (struct.field_ref Config "Learners" (struct.field_ref ProgressTracker "Config" (![ptrT] "p"))))) #()) in
     let: "$LearnersNext" := ((method_call #quorum.pkg_name' #"MajorityConfig" #"Slice" "Slice" #() (![mapT uint64T (structT [
     ])] (struct.field_ref Config "LearnersNext" (struct.field_ref ProgressTracker "Config" (![ptrT] "p"))))) #()) in
     let: "$AutoLeave" := (![boolT] (struct.field_ref Config "AutoLeave" (struct.field_ref ProgressTracker "Config" (![ptrT] "p")))) in
     struct.make raftpb.ConfState [{
       "Voters" ::= "$Voters";
       "Learners" ::= "$Learners";
       "VotersOutgoing" ::= "$VotersOutgoing";
       "LearnersNext" ::= "$LearnersNext";
       "AutoLeave" ::= "$AutoLeave"
     }])).

(* IsSingleton returns true if (and only if) there is only one voting member
   (i.e. the leader) in the current configuration.

   go: tracker.go:161:27 *)
Definition ProgressTracker__IsSingleton : val :=
  rec: "ProgressTracker__IsSingleton" "p" <> :=
    exception_do (let: "p" := (ref_ty ptrT "p") in
    return: (((let: "$a0" := (![quorum.MajorityConfig] (array.elem_ref quorum.MajorityConfig (![quorum.JointConfig] (struct.field_ref Config "Voters" (struct.field_ref ProgressTracker "Config" (![ptrT] "p")))) #(W64 0))) in
     map.len "$a0") = #(W64 1)) && ((let: "$a0" := (![quorum.MajorityConfig] (array.elem_ref quorum.MajorityConfig (![quorum.JointConfig] (struct.field_ref Config "Voters" (struct.field_ref ProgressTracker "Config" (![ptrT] "p")))) #(W64 1))) in
     map.len "$a0") = #(W64 0)))).

Definition matchAckIndexer : go_type := mapT uint64T ptrT.

(* AckedIndex implements IndexLookuper.

   go: tracker.go:170:26 *)
Definition matchAckIndexer__AckedIndex : val :=
  rec: "matchAckIndexer__AckedIndex" "l" "id" :=
    exception_do (let: "l" := (ref_ty matchAckIndexer "l") in
    let: "id" := (ref_ty uint64T "id") in
    let: "ok" := (ref_ty boolT (zero_val boolT)) in
    let: "pr" := (ref_ty ptrT (zero_val ptrT)) in
    let: ("$ret0", "$ret1") := (map.get (![matchAckIndexer] "l") (![uint64T] "id")) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  ("pr" <-[ptrT] "$r0");;;
    do:  ("ok" <-[boolT] "$r1");;;
    (if: (~ (![boolT] "ok"))
    then return: (#(W64 0), #false)
    else do:  #());;;
    return: (![uint64T] (struct.field_ref Progress "Match" (![ptrT] "pr")), #true)).

(* Committed returns the largest log index known to be committed based on what
   the voting members of the group have acknowledged.

   go: tracker.go:180:27 *)
Definition ProgressTracker__Committed : val :=
  rec: "ProgressTracker__Committed" "p" <> :=
    exception_do (let: "p" := (ref_ty ptrT "p") in
    return: (let: "$a0" := (interface.make #pkg_name' #"matchAckIndexer" (![ProgressMap] (struct.field_ref ProgressTracker "Progress" (![ptrT] "p")))) in
     (method_call #quorum.pkg_name' #"JointConfig" #"CommittedIndex" (![quorum.JointConfig] (struct.field_ref Config "Voters" (struct.field_ref ProgressTracker "Config" (![ptrT] "p"))))) "$a0")).

(* Visit invokes the supplied closure for all tracked progresses in stable order.

   go: tracker.go:185:27 *)
Definition ProgressTracker__Visit : val :=
  rec: "ProgressTracker__Visit" "p" "f" :=
    exception_do (let: "p" := (ref_ty ptrT "p") in
    let: "f" := (ref_ty funcT "f") in
    let: "n" := (ref_ty intT (zero_val intT)) in
    let: "$r0" := (let: "$a0" := (![ProgressMap] (struct.field_ref ProgressTracker "Progress" (![ptrT] "p"))) in
    map.len "$a0") in
    do:  ("n" <-[intT] "$r0");;;
    let: "sl" := (ref_ty (arrayT 7 uint64T) (zero_val (arrayT 7 uint64T))) in
    let: "ids" := (ref_ty sliceT (zero_val sliceT)) in
    (if: int_geq (array.len (arrayT 7 uint64T)) (![intT] "n")
    then
      let: "$r0" := (let: "$a" := "sl" in
      array.slice "$a" #(W64 0) (![intT] "n")) in
      do:  ("ids" <-[sliceT] "$r0")
    else
      let: "$r0" := (slice.make2 uint64T (![intT] "n")) in
      do:  ("ids" <-[sliceT] "$r0"));;;
    do:  (map.for_range (![ProgressMap] (struct.field_ref ProgressTracker "Progress" (![ptrT] "p"))) (λ: "id" <>,
      do:  ("n" <-[intT] ((![intT] "n") - #(W64 1)));;;
      let: "$r0" := (![uint64T] "id") in
      do:  ((slice.elem_ref uint64T (![sliceT] "ids") (![intT] "n")) <-[uint64T] "$r0")));;;
    do:  (let: "$a0" := (![sliceT] "ids") in
    (func_call #slices64.pkg_name' #"Sort"%go) "$a0");;;
    do:  (let: "$range" := (![sliceT] "ids") in
    slice.for_range uint64T "$range" (λ: <> "id",
      let: "id" := ref_ty uint64T "id" in
      do:  (let: "$a0" := (![uint64T] "id") in
      let: "$a1" := (Fst (map.get (![ProgressMap] (struct.field_ref ProgressTracker "Progress" (![ptrT] "p"))) (![uint64T] "id"))) in
      (![funcT] "f") "$a0" "$a1")))).

(* QuorumActive returns true if the quorum is active from the view of the local
   raft state machine. Otherwise, it returns false.

   go: tracker.go:209:27 *)
Definition ProgressTracker__QuorumActive : val :=
  rec: "ProgressTracker__QuorumActive" "p" <> :=
    exception_do (let: "p" := (ref_ty ptrT "p") in
    let: "votes" := (ref_ty (mapT uint64T boolT) (zero_val (mapT uint64T boolT))) in
    let: "$r0" := (map.make uint64T boolT #()) in
    do:  ("votes" <-[mapT uint64T boolT] "$r0");;;
    do:  (let: "$a0" := (λ: "id" "pr",
      exception_do (let: "pr" := (ref_ty ptrT "pr") in
      let: "id" := (ref_ty uint64T "id") in
      (if: ![boolT] (struct.field_ref Progress "IsLearner" (![ptrT] "pr"))
      then return: (#())
      else do:  #());;;
      let: "$r0" := (![boolT] (struct.field_ref Progress "RecentActive" (![ptrT] "pr"))) in
      do:  (map.insert (![mapT uint64T boolT] "votes") (![uint64T] "id") "$r0"))
      ) in
    (method_call #pkg_name' #"ProgressTracker'ptr" #"Visit" (![ptrT] "p")) "$a0");;;
    return: ((let: "$a0" := (![mapT uint64T boolT] "votes") in
     (method_call #quorum.pkg_name' #"JointConfig" #"VoteResult" (![quorum.JointConfig] (struct.field_ref Config "Voters" (struct.field_ref ProgressTracker "Config" (![ptrT] "p"))))) "$a0") = quorum.VoteWon)).

(* VoterNodes returns a sorted slice of voters.

   go: tracker.go:222:27 *)
Definition ProgressTracker__VoterNodes : val :=
  rec: "ProgressTracker__VoterNodes" "p" <> :=
    exception_do (let: "p" := (ref_ty ptrT "p") in
    let: "m" := (ref_ty (mapT uint64T (structT [
    ])) (zero_val (mapT uint64T (structT [
    ])))) in
    let: "$r0" := ((method_call #quorum.pkg_name' #"JointConfig" #"IDs" (![quorum.JointConfig] (struct.field_ref Config "Voters" (struct.field_ref ProgressTracker "Config" (![ptrT] "p"))))) #()) in
    do:  ("m" <-[mapT uint64T (structT [
    ])] "$r0");;;
    let: "nodes" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (slice.make3 uint64T #(W64 0) (let: "$a0" := (![mapT uint64T (structT [
    ])] "m") in
    map.len "$a0")) in
    do:  ("nodes" <-[sliceT] "$r0");;;
    do:  (map.for_range (![mapT uint64T (structT [
    ])] "m") (λ: "id" <>,
      let: "$r0" := (let: "$a0" := (![sliceT] "nodes") in
      let: "$a1" := ((let: "$sl0" := (![uint64T] "id") in
      slice.literal uint64T ["$sl0"])) in
      (slice.append sliceT) "$a0" "$a1") in
      do:  ("nodes" <-[sliceT] "$r0")));;;
    do:  (let: "$a0" := (interface.make #"slice'"%go (![sliceT] "nodes")) in
    let: "$a1" := (λ: "i" "j",
      exception_do (let: "j" := (ref_ty intT "j") in
      let: "i" := (ref_ty intT "i") in
      return: ((![uint64T] (slice.elem_ref uint64T (![sliceT] "nodes") (![intT] "i"))) < (![uint64T] (slice.elem_ref uint64T (![sliceT] "nodes") (![intT] "j")))))
      ) in
    (func_call #sort.pkg_name' #"Slice"%go) "$a0" "$a1");;;
    return: (![sliceT] "nodes")).

(* LearnerNodes returns a sorted slice of learners.

   go: tracker.go:233:27 *)
Definition ProgressTracker__LearnerNodes : val :=
  rec: "ProgressTracker__LearnerNodes" "p" <> :=
    exception_do (let: "p" := (ref_ty ptrT "p") in
    (if: (let: "$a0" := (![mapT uint64T (structT [
    ])] (struct.field_ref Config "Learners" (struct.field_ref ProgressTracker "Config" (![ptrT] "p")))) in
    map.len "$a0") = #(W64 0)
    then return: (#slice.nil)
    else do:  #());;;
    let: "nodes" := (ref_ty sliceT (zero_val sliceT)) in
    let: "$r0" := (slice.make3 uint64T #(W64 0) (let: "$a0" := (![mapT uint64T (structT [
    ])] (struct.field_ref Config "Learners" (struct.field_ref ProgressTracker "Config" (![ptrT] "p")))) in
    map.len "$a0")) in
    do:  ("nodes" <-[sliceT] "$r0");;;
    do:  (map.for_range (![mapT uint64T (structT [
    ])] (struct.field_ref Config "Learners" (struct.field_ref ProgressTracker "Config" (![ptrT] "p")))) (λ: "id" <>,
      let: "$r0" := (let: "$a0" := (![sliceT] "nodes") in
      let: "$a1" := ((let: "$sl0" := (![uint64T] "id") in
      slice.literal uint64T ["$sl0"])) in
      (slice.append sliceT) "$a0" "$a1") in
      do:  ("nodes" <-[sliceT] "$r0")));;;
    do:  (let: "$a0" := (interface.make #"slice'"%go (![sliceT] "nodes")) in
    let: "$a1" := (λ: "i" "j",
      exception_do (let: "j" := (ref_ty intT "j") in
      let: "i" := (ref_ty intT "i") in
      return: ((![uint64T] (slice.elem_ref uint64T (![sliceT] "nodes") (![intT] "i"))) < (![uint64T] (slice.elem_ref uint64T (![sliceT] "nodes") (![intT] "j")))))
      ) in
    (func_call #sort.pkg_name' #"Slice"%go) "$a0" "$a1");;;
    return: (![sliceT] "nodes")).

(* ResetVotes prepares for a new round of vote counting via recordVote.

   go: tracker.go:246:27 *)
Definition ProgressTracker__ResetVotes : val :=
  rec: "ProgressTracker__ResetVotes" "p" <> :=
    exception_do (let: "p" := (ref_ty ptrT "p") in
    let: "$r0" := (map.make uint64T boolT #()) in
    do:  ((struct.field_ref ProgressTracker "Votes" (![ptrT] "p")) <-[mapT uint64T boolT] "$r0")).

(* RecordVote records that the node with the given id voted for this Raft
   instance if v == true (and declined it otherwise).

   go: tracker.go:252:27 *)
Definition ProgressTracker__RecordVote : val :=
  rec: "ProgressTracker__RecordVote" "p" "id" "v" :=
    exception_do (let: "p" := (ref_ty ptrT "p") in
    let: "v" := (ref_ty boolT "v") in
    let: "id" := (ref_ty uint64T "id") in
    let: "ok" := (ref_ty boolT (zero_val boolT)) in
    let: ("$ret0", "$ret1") := (map.get (![mapT uint64T boolT] (struct.field_ref ProgressTracker "Votes" (![ptrT] "p"))) (![uint64T] "id")) in
    let: "$r0" := "$ret0" in
    let: "$r1" := "$ret1" in
    do:  "$r0";;;
    do:  ("ok" <-[boolT] "$r1");;;
    (if: (~ (![boolT] "ok"))
    then
      let: "$r0" := (![boolT] "v") in
      do:  (map.insert (![mapT uint64T boolT] (struct.field_ref ProgressTracker "Votes" (![ptrT] "p"))) (![uint64T] "id") "$r0")
    else do:  #())).

(* TallyVotes returns the number of granted and rejected Votes, and whether the
   election outcome is known.

   go: tracker.go:261:27 *)
Definition ProgressTracker__TallyVotes : val :=
  rec: "ProgressTracker__TallyVotes" "p" <> :=
    exception_do (let: "p" := (ref_ty ptrT "p") in
    let: "rejected" := (ref_ty intT (zero_val intT)) in
    let: "granted" := (ref_ty intT (zero_val intT)) in
    do:  (map.for_range (![ProgressMap] (struct.field_ref ProgressTracker "Progress" (![ptrT] "p"))) (λ: "id" "pr",
      (if: ![boolT] (struct.field_ref Progress "IsLearner" (![ptrT] "pr"))
      then continue: #()
      else do:  #());;;
      let: "voted" := (ref_ty boolT (zero_val boolT)) in
      let: "v" := (ref_ty boolT (zero_val boolT)) in
      let: ("$ret0", "$ret1") := (map.get (![mapT uint64T boolT] (struct.field_ref ProgressTracker "Votes" (![ptrT] "p"))) (![uint64T] "id")) in
      let: "$r0" := "$ret0" in
      let: "$r1" := "$ret1" in
      do:  ("v" <-[boolT] "$r0");;;
      do:  ("voted" <-[boolT] "$r1");;;
      (if: (~ (![boolT] "voted"))
      then continue: #()
      else do:  #());;;
      (if: ![boolT] "v"
      then do:  ("granted" <-[intT] ((![intT] "granted") + #(W64 1)))
      else do:  ("rejected" <-[intT] ((![intT] "rejected") + #(W64 1))))));;;
    let: "result" := (ref_ty quorum.VoteResult (zero_val quorum.VoteResult)) in
    let: "$r0" := (let: "$a0" := (![mapT uint64T boolT] (struct.field_ref ProgressTracker "Votes" (![ptrT] "p"))) in
    (method_call #quorum.pkg_name' #"JointConfig" #"VoteResult" (![quorum.JointConfig] (struct.field_ref Config "Voters" (struct.field_ref ProgressTracker "Config" (![ptrT] "p"))))) "$a0") in
    do:  ("result" <-[quorum.VoteResult] "$r0");;;
    return: (![intT] "granted", ![intT] "rejected", ![quorum.VoteResult] "result")).

Definition vars' : list (go_string * go_type) := [("prstmap"%go, arrayT 3 stringT); ("_"%go, quorum.AckedIndexer)].

Definition functions' : list (go_string * val) := [("NewInflights"%go, NewInflights); ("MakeProgressTracker"%go, MakeProgressTracker)].

Definition msets' : list (go_string * (list (go_string * val))) := [("inflight"%go, []); ("inflight'ptr"%go, []); ("Inflights"%go, []); ("Inflights'ptr"%go, [("Add"%go, Inflights__Add); ("Clone"%go, Inflights__Clone); ("Count"%go, Inflights__Count); ("FreeLE"%go, Inflights__FreeLE); ("Full"%go, Inflights__Full); ("grow"%go, Inflights__grow); ("reset"%go, Inflights__reset)]); ("Progress"%go, []); ("Progress'ptr"%go, [("BecomeProbe"%go, Progress__BecomeProbe); ("BecomeReplicate"%go, Progress__BecomeReplicate); ("BecomeSnapshot"%go, Progress__BecomeSnapshot); ("CanBumpCommit"%go, Progress__CanBumpCommit); ("IsPaused"%go, Progress__IsPaused); ("MaybeDecrTo"%go, Progress__MaybeDecrTo); ("MaybeUpdate"%go, Progress__MaybeUpdate); ("ResetState"%go, Progress__ResetState); ("SentCommit"%go, Progress__SentCommit); ("SentEntries"%go, Progress__SentEntries); ("String"%go, Progress__String)]); ("ProgressMap"%go, [("String"%go, ProgressMap__String)]); ("ProgressMap'ptr"%go, [("String"%go, (λ: "$recvAddr",
                 method_call #pkg_name' #"ProgressMap" #"String" (![ProgressMap] "$recvAddr")
                 )%V)]); ("StateType"%go, [("String"%go, StateType__String)]); ("StateType'ptr"%go, [("String"%go, (λ: "$recvAddr",
                 method_call #pkg_name' #"StateType" #"String" (![StateType] "$recvAddr")
                 )%V)]); ("Config"%go, [("String"%go, Config__String)]); ("Config'ptr"%go, [("Clone"%go, Config__Clone); ("String"%go, (λ: "$recvAddr",
                 method_call #pkg_name' #"Config" #"String" (![Config] "$recvAddr")
                 )%V)]); ("ProgressTracker"%go, [("String"%go, (λ: "$recv",
                 method_call #pkg_name' #"Config" #"String" "String" #() (struct.field_get ProgressTracker "Config" "$recv")
                 )%V)]); ("ProgressTracker'ptr"%go, [("Clone"%go, (λ: "$recvAddr",
                 method_call #pkg_name' #"Config'ptr" #"Clone" (struct.field_ref ProgressTracker "Config" "$recvAddr")
                 )%V); ("Committed"%go, ProgressTracker__Committed); ("ConfState"%go, ProgressTracker__ConfState); ("IsSingleton"%go, ProgressTracker__IsSingleton); ("LearnerNodes"%go, ProgressTracker__LearnerNodes); ("QuorumActive"%go, ProgressTracker__QuorumActive); ("RecordVote"%go, ProgressTracker__RecordVote); ("ResetVotes"%go, ProgressTracker__ResetVotes); ("String"%go, (λ: "$recvAddr",
                 method_call #pkg_name' #"Config" #"String" (![Config] (struct.field_ref ProgressTracker "Config" "$recvAddr"))
                 )%V); ("TallyVotes"%go, ProgressTracker__TallyVotes); ("Visit"%go, ProgressTracker__Visit); ("VoterNodes"%go, ProgressTracker__VoterNodes)]); ("matchAckIndexer"%go, [("AckedIndex"%go, matchAckIndexer__AckedIndex)]); ("matchAckIndexer'ptr"%go, [("AckedIndex"%go, (λ: "$recvAddr",
                 method_call #pkg_name' #"matchAckIndexer" #"AckedIndex" (![matchAckIndexer] "$recvAddr")
                 )%V)])].

Definition initialize' : val :=
  rec: "initialize'" <> :=
    globals.package_init pkg_name' vars' functions' msets' (λ: <>,
      exception_do (do:  raftpb.initialize';;;
      do:  slices64.initialize';;;
      do:  quorum.initialize';;;
      do:  strings.initialize';;;
      do:  sort.initialize';;;
      do:  fmt.initialize';;;
      let: "$r0" := ((let: "$ar0" := #"StateProbe"%go in
      let: "$ar1" := #"StateReplicate"%go in
      let: "$ar2" := #"StateSnapshot"%go in
      array.literal ["$ar0"; "$ar1"; "$ar2"])) in
      do:  ((globals.get #pkg_name' #"prstmap"%go) <-[arrayT 3 stringT] "$r0");;;
      let: "$r0" := (interface.make #pkg_name' #"matchAckIndexer" #null) in
      do:  #())
      ).

End code.
End tracker.
