(* autogenerated from math/big *)
From New.golang Require Import defn.
Module pkg_id.
Definition big : go_string := "math/big".

End pkg_id.
Export pkg_id.
Module big.

Definition Word {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "math/big.Word"%go [].

Definition decimal {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "math/big.decimal"%go [].

Definition Float {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "math/big.Float"%go [].

Definition ErrNaN {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "math/big.ErrNaN"%go [].

Definition form {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "math/big.form"%go [].

Definition RoundingMode {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "math/big.RoundingMode"%go [].

Definition Accuracy {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "math/big.Accuracy"%go [].

Definition Int {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "math/big.Int"%go [].

Definition byteReader {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "math/big.byteReader"%go [].

Definition nat {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "math/big.nat"%go [].

Definition stack {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "math/big.stack"%go [].

Definition divisor {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "math/big.divisor"%go [].

Definition Rat {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go.type := go.Named "math/big.Rat"%go [].

Axiom Wordⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom decimalⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom Floatⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom ErrNaNⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom formⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom RoundingModeⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom Accuracyⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom Intⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom byteReaderⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom natⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom stackⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom divisorⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom Ratⁱᵐᵖˡ : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, go.type.

Axiom _Accuracy_name : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom _S : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom _W : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom _B : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom _M : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom maxShift : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom debugFloat : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom MaxExp : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom MinExp : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom MaxPrec : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom zero : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom finite : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom inf : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom ToNearestEven : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom ToNearestAway : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom ToZero : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom AwayFromZero : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom ToNegativeInf : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom ToPositiveInf : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom Below : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom Exact : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom Above : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom floatGobVersion : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom intGobVersion : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom digits : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom MaxBase : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom maxBaseSmall : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom ratGobVersion : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Axiom _RoundingMode_name : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition _Accuracy_index {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big._Accuracy_index"%go.

Axiom _Accuracy_index'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition hasADX {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.hasADX"%go.

Axiom hasADX'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition floatZero {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.floatZero"%go.

Definition pow5tab {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.pow5tab"%go.

Axiom pow5tab'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition intOne {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.intOne"%go.

Axiom intOne'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition natOne {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.natOne"%go.

Axiom natOne'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition natTwo {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.natTwo"%go.

Axiom natTwo'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition natFive {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.natFive"%go.

Axiom natFive'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition natTen {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.natTen"%go.

Axiom natTen'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition stackPool {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.stackPool"%go.

Definition errNoDigits {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.errNoDigits"%go.

Axiom errNoDigits'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition errInvalSep {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.errInvalSep"%go.

Axiom errInvalSep'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition leafSize {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.leafSize"%go.

Axiom leafSize'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition cacheBase10 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.cacheBase10"%go.

Definition divRecursiveThreshold {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.divRecursiveThreshold"%go.

Axiom divRecursiveThreshold'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition karatsubaThreshold {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.karatsubaThreshold"%go.

Axiom karatsubaThreshold'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition basicSqrThreshold {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.basicSqrThreshold"%go.

Axiom basicSqrThreshold'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition karatsubaSqrThreshold {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.karatsubaSqrThreshold"%go.

Axiom karatsubaSqrThreshold'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition ratZero {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.ratZero"%go.

Definition _RoundingMode_index {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big._RoundingMode_index"%go.

Axiom _RoundingMode_index'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition threeOnce {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.threeOnce"%go.

Definition mulWW {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.mulWW"%go.

Definition mulAddWWW_g {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.mulAddWWW_g"%go.

Definition nlz {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.nlz"%go.

Definition addVV_g {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.addVV_g"%go.

Definition subVV_g {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.subVV_g"%go.

Definition addVW {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.addVW"%go.

Definition addVW_ref {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.addVW_ref"%go.

Definition subVW {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.subVW"%go.

Definition subVW_ref {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.subVW_ref"%go.

Definition lshVU_g {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.lshVU_g"%go.

Definition rshVU_g {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.rshVU_g"%go.

Definition mulAddVWW_g {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.mulAddVWW_g"%go.

Definition addMulVVWW_g {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.addMulVVWW_g"%go.

Definition divWW {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.divWW"%go.

Definition reciprocalWord {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.reciprocalWord"%go.

Definition addVV {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.addVV"%go.

Definition subVV {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.subVV"%go.

Definition shlVU {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.shlVU"%go.

Definition lshVU {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.lshVU"%go.

Definition rshVU {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.rshVU"%go.

Definition mulAddVWW {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.mulAddVWW"%go.

Definition addMulVVW {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.addMulVVW"%go.

Definition addMulVVWW {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.addMulVVWW"%go.

Definition rsh {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.rsh"%go.

Definition appendZeros {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.appendZeros"%go.

Definition shouldRoundUp {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.shouldRoundUp"%go.

Definition trim {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.trim"%go.

Definition NewFloat {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.NewFloat"%go.

Definition makeAcc {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.makeAcc"%go.

Definition fnorm {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.fnorm"%go.

Definition msb32 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.msb32"%go.

Definition msb64 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.msb64"%go.

Definition validateBinaryOperands {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.validateBinaryOperands"%go.

Definition ParseFloat {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.ParseFloat"%go.

Definition roundShortest {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.roundShortest"%go.

Definition fmtE {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.fmtE"%go.

Definition fmtF {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.fmtF"%go.

Definition NewInt {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.NewInt"%go.

Definition low32 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.low32"%go.

Definition low64 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.low64"%go.

Definition lehmerSimulate {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.lehmerSimulate"%go.

Definition lehmerUpdate {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.lehmerUpdate"%go.

Definition mulW {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.mulW"%go.

Definition euclidUpdate {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.euclidUpdate"%go.

Definition Jacobi {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.Jacobi"%go.

Definition writeMultiple {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.writeMultiple"%go.

Definition scanSign {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.scanSign"%go.

Definition alias {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.alias"%go.

Definition addTo {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.addTo"%go.

Definition getStack {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.getStack"%go.

Definition same {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.same"%go.

Definition bigEndianWord {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.bigEndianWord"%go.

Definition maxPow {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.maxPow"%go.

Definition pow {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.pow"%go.

Definition divisors {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.divisors"%go.

Definition divWVW {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.divWVW"%go.

Definition greaterThan {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.greaterThan"%go.

Definition basicSqr {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.basicSqr"%go.

Definition basicMul {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.basicMul"%go.

Definition karatsuba {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.karatsuba"%go.

Definition karatsubaSqr {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.karatsubaSqr"%go.

Definition ifmt {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.ifmt"%go.

Definition trace {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.trace"%go.

Definition NewRat {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.NewRat"%go.

Definition quotToFloat32 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.quotToFloat32"%go.

Definition quotToFloat64 {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.quotToFloat64"%go.

Definition mulDenom {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.mulDenom"%go.

Definition ratTok {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.ratTok"%go.

Definition scanExponent {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.scanExponent"%go.

Definition three {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.three"%go.

Definition newFloat {ext : ffi_syntax} {go_gctx : GoGlobalContext} : go_string := "math/big.newFloat"%go.

#[global] Instance info' : PkgInfo pkg_id.big :=
{|
  pkg_imported_pkgs := []
|}.

Axiom _'init : ∀ {ext : ffi_syntax} {go_gctx : GoGlobalContext}, val.

Definition initialize' {ext : ffi_syntax} {go_gctx : GoGlobalContext} : val :=
  λ: <>,
    package.init pkg_id.big (λ: <>,
      exception_do (do:  (_Accuracy_index'init #());;;
      do:  (hasADX'init #());;;
      do:  (pow5tab'init #());;;
      do:  (_'init #());;;
      do:  (_'init #());;;
      do:  (natOne'init #());;;
      do:  (intOne'init #());;;
      do:  (_'init #());;;
      do:  (_'init #());;;
      do:  (natTwo'init #());;;
      do:  (natFive'init #());;;
      do:  (natTen'init #());;;
      do:  (errNoDigits'init #());;;
      do:  (errInvalSep'init #());;;
      do:  (leafSize'init #());;;
      do:  (divRecursiveThreshold'init #());;;
      do:  (karatsubaThreshold'init #());;;
      do:  (basicSqrThreshold'init #());;;
      do:  (karatsubaSqrThreshold'init #());;;
      do:  (_'init #());;;
      do:  (_RoundingMode_index'init #()))
      ).

Module Word.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End Word.

Class Word_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Word_type_repr  :: go.TypeReprUnderlying Wordⁱᵐᵖˡ Word.t;
  #[global] Word_underlying :: (Word) <u (Wordⁱᵐᵖˡ);
  #[global] Wordⁱᵐᵖˡ_underlying :: (Wordⁱᵐᵖˡ) ↓u (Wordⁱᵐᵖˡ);
}.

Module decimal.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End decimal.

Class decimal_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] decimal_type_repr  :: go.TypeReprUnderlying decimalⁱᵐᵖˡ decimal.t;
  #[global] decimal_underlying :: (decimal) <u (decimalⁱᵐᵖˡ);
  #[global] decimalⁱᵐᵖˡ_underlying :: (decimalⁱᵐᵖˡ) ↓u (decimalⁱᵐᵖˡ);
}.

Module Float.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End Float.

Class Float_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Float_type_repr  :: go.TypeReprUnderlying Floatⁱᵐᵖˡ Float.t;
  #[global] Float_underlying :: (Float) <u (Floatⁱᵐᵖˡ);
  #[global] Floatⁱᵐᵖˡ_underlying :: (Floatⁱᵐᵖˡ) ↓u (Floatⁱᵐᵖˡ);
}.

Module ErrNaN.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End ErrNaN.

Class ErrNaN_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] ErrNaN_type_repr  :: go.TypeReprUnderlying ErrNaNⁱᵐᵖˡ ErrNaN.t;
  #[global] ErrNaN_underlying :: (ErrNaN) <u (ErrNaNⁱᵐᵖˡ);
  #[global] ErrNaNⁱᵐᵖˡ_underlying :: (ErrNaNⁱᵐᵖˡ) ↓u (ErrNaNⁱᵐᵖˡ);
}.

Module form.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End form.

Class form_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] form_type_repr  :: go.TypeReprUnderlying formⁱᵐᵖˡ form.t;
  #[global] form_underlying :: (form) <u (formⁱᵐᵖˡ);
  #[global] formⁱᵐᵖˡ_underlying :: (formⁱᵐᵖˡ) ↓u (formⁱᵐᵖˡ);
}.

Module RoundingMode.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End RoundingMode.

Class RoundingMode_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] RoundingMode_type_repr  :: go.TypeReprUnderlying RoundingModeⁱᵐᵖˡ RoundingMode.t;
  #[global] RoundingMode_underlying :: (RoundingMode) <u (RoundingModeⁱᵐᵖˡ);
  #[global] RoundingModeⁱᵐᵖˡ_underlying :: (RoundingModeⁱᵐᵖˡ) ↓u (RoundingModeⁱᵐᵖˡ);
}.

Module Accuracy.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End Accuracy.

Class Accuracy_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Accuracy_type_repr  :: go.TypeReprUnderlying Accuracyⁱᵐᵖˡ Accuracy.t;
  #[global] Accuracy_underlying :: (Accuracy) <u (Accuracyⁱᵐᵖˡ);
  #[global] Accuracyⁱᵐᵖˡ_underlying :: (Accuracyⁱᵐᵖˡ) ↓u (Accuracyⁱᵐᵖˡ);
}.

Module Int.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End Int.

Class Int_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Int_type_repr  :: go.TypeReprUnderlying Intⁱᵐᵖˡ Int.t;
  #[global] Int_underlying :: (Int) <u (Intⁱᵐᵖˡ);
  #[global] Intⁱᵐᵖˡ_underlying :: (Intⁱᵐᵖˡ) ↓u (Intⁱᵐᵖˡ);
}.

Module byteReader.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End byteReader.

Class byteReader_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] byteReader_type_repr  :: go.TypeReprUnderlying byteReaderⁱᵐᵖˡ byteReader.t;
  #[global] byteReader_underlying :: (byteReader) <u (byteReaderⁱᵐᵖˡ);
  #[global] byteReaderⁱᵐᵖˡ_underlying :: (byteReaderⁱᵐᵖˡ) ↓u (byteReaderⁱᵐᵖˡ);
}.

Module nat.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End nat.

Class nat_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] nat_type_repr  :: go.TypeReprUnderlying natⁱᵐᵖˡ nat.t;
  #[global] nat_underlying :: (nat) <u (natⁱᵐᵖˡ);
  #[global] natⁱᵐᵖˡ_underlying :: (natⁱᵐᵖˡ) ↓u (natⁱᵐᵖˡ);
}.

Module stack.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End stack.

Class stack_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] stack_type_repr  :: go.TypeReprUnderlying stackⁱᵐᵖˡ stack.t;
  #[global] stack_underlying :: (stack) <u (stackⁱᵐᵖˡ);
  #[global] stackⁱᵐᵖˡ_underlying :: (stackⁱᵐᵖˡ) ↓u (stackⁱᵐᵖˡ);
}.

Module divisor.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End divisor.

Class divisor_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] divisor_type_repr  :: go.TypeReprUnderlying divisorⁱᵐᵖˡ divisor.t;
  #[global] divisor_underlying :: (divisor) <u (divisorⁱᵐᵖˡ);
  #[global] divisorⁱᵐᵖˡ_underlying :: (divisorⁱᵐᵖˡ) ↓u (divisorⁱᵐᵖˡ);
}.

Module Rat.
Section def.
Context {ext : ffi_syntax} {go_gctx : GoGlobalContext}.
Axiom t : Type.
Axiom zero_val : ZeroVal t.
#[global] Existing Instance zero_val.
End def.
End Rat.

Class Rat_Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Rat_type_repr  :: go.TypeReprUnderlying Ratⁱᵐᵖˡ Rat.t;
  #[global] Rat_underlying :: (Rat) <u (Ratⁱᵐᵖˡ);
  #[global] Ratⁱᵐᵖˡ_underlying :: (Ratⁱᵐᵖˡ) ↓u (Ratⁱᵐᵖˡ);
}.

Class Assumptions {ext : ffi_syntax} `{!GoGlobalContext} `{!GoLocalContext} `{!GoSemanticsFunctions} : Prop :=
{
  #[global] Word_instance :: Word_Assumptions;
  #[global] decimal_instance :: decimal_Assumptions;
  #[global] Float_instance :: Float_Assumptions;
  #[global] ErrNaN_instance :: ErrNaN_Assumptions;
  #[global] form_instance :: form_Assumptions;
  #[global] RoundingMode_instance :: RoundingMode_Assumptions;
  #[global] Accuracy_instance :: Accuracy_Assumptions;
  #[global] Int_instance :: Int_Assumptions;
  #[global] byteReader_instance :: byteReader_Assumptions;
  #[global] nat_instance :: nat_Assumptions;
  #[global] stack_instance :: stack_Assumptions;
  #[global] divisor_instance :: divisor_Assumptions;
  #[global] Rat_instance :: Rat_Assumptions;
}.
End big.
