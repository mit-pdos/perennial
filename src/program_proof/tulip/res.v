From iris.algebra Require Import mono_nat mono_list gmap_view gset.
From iris.algebra.lib Require Import dfrac_agree.
From Perennial.Helpers Require Import gmap_algebra.
From Perennial.base_logic Require Import ghost_map.
From Perennial.program_proof Require Import grove_prelude.
From Perennial.program_proof.tulip Require Import base.
From Perennial.program_proof.rsm Require Import big_sep.
From Perennial.program_proof.rsm.pure Require Import list fin_maps vslice.
From Perennial.program_proof.tulip Require Import big_sep.
From Perennial.program_proof.tulip Require Export res_txnsys res_group res_replica res_network.

(** This file contains resources exposed to the users or owned by multiple
subsystems. Resources onwed exclusively to one subsystem should be defined in
their respective files. *)

Section res.
  Context `{!tulip_ghostG Σ}.

  Section db_ptsto.

    (** Single-value logical database values. One half in the txnsys invariant,
    one half given to the client. *)

    Definition own_db_ptsto γ (k : dbkey) (v : dbval) : iProp Σ :=
      own γ.(db_ptsto) {[ k := (to_dfrac_agree (DfracOwn (1 / 2)) v) ]}.

    Definition own_db_ptstos γ (m : dbmap) : iProp Σ :=
      [∗ map] k ↦ v ∈ m, own_db_ptsto γ k v.

    Lemma db_ptsto_update {γ k v1 v2} v :
      own_db_ptsto γ k v1 -∗
      own_db_ptsto γ k v2 ==∗
      own_db_ptsto γ k v ∗ own_db_ptsto γ k v.
    Proof.
      iIntros "Hv1 Hv2".
      iCombine "Hv1 Hv2" as "Hv".
      rewrite -own_op singleton_op.
      iApply (own_update with "Hv").
      apply singleton_update.
      apply dfrac_agree_update_2.
      by rewrite dfrac_op_own Qp.half_half.
    Qed.

    Lemma db_ptsto_agree γ k v1 v2 :
      own_db_ptsto γ k v1 -∗
      own_db_ptsto γ k v2 -∗
      ⌜v2 = v1⌝.
    Proof.
      iIntros "Hv1 Hv2".
      iDestruct (own_valid_2 with "Hv1 Hv2") as %Hvalid.
      rewrite singleton_op singleton_valid dfrac_agree_op_valid_L in Hvalid.
      by destruct Hvalid as [_ ?].
    Qed.

  End db_ptsto.

  Section repl_hist.

    (** History generated by replicated transactions for a certain key. One half
    owned by the txnsys invariant, the other by the key invariant. *)

    Definition own_repl_hist_half γ (k : dbkey) (h : dbhist) : iProp Σ :=
      own γ.(repl_hist) {[ k := ●ML{#(1 / 2)} h ]}.

    Definition is_repl_hist_lb γ (k : dbkey) (h : dbhist) : iProp Σ :=
      own γ.(repl_hist) {[ k := ◯ML h ]}.

    Definition is_repl_hist_at γ (k : dbkey) (ts : nat) (v : dbval) : iProp Σ :=
      ∃ lb, is_repl_hist_lb γ k lb ∗ ⌜lb !! ts = Some v⌝.

    #[global]
    Instance is_repl_hist_lb_persistent α key hist :
      Persistent (is_repl_hist_lb α key hist).
    Proof. apply _. Defined.

    Lemma repl_hist_agree {γ} k h1 h2 :
      own_repl_hist_half γ k h1 -∗
      own_repl_hist_half γ k h2 -∗
      ⌜h2 = h1⌝.
    Proof.
      iIntros "Hh1 Hh2".
      iDestruct (own_valid_2 with "Hh1 Hh2") as %Hvalid.
      rewrite singleton_op singleton_valid mono_list_auth_dfrac_op_valid_L in Hvalid.
      by destruct Hvalid as [_ ?].
    Qed.

    Lemma repl_hist_big_agree {γ histm1 histm2} :
      dom histm1 = dom histm2 ->
      ([∗ map] k ↦ ts ∈ histm1, own_repl_hist_half γ k ts) -∗
      ([∗ map] k ↦ ts ∈ histm2, own_repl_hist_half γ k ts) -∗
      ⌜histm2 = histm1⌝.
    Proof.
      iIntros (Hdom) "Hhistm1 Hhistm2".
      rewrite map_eq_iff.
      iIntros (k).
      destruct (histm1 !! k) as [h1 |] eqn:Hh1, (histm2 !! k) as [h2 |] eqn:Hh2.
      { iDestruct (big_sepM_lookup with "Hhistm1") as "Hh1"; first apply Hh1.
        iDestruct (big_sepM_lookup with "Hhistm2") as "Hh2"; first apply Hh2.
        by iDestruct (repl_hist_agree with "Hh1 Hh2") as %->.
      }
      { by rewrite -not_elem_of_dom -Hdom elem_of_dom Hh1 -eq_None_not_Some in Hh2. }
      { by rewrite -not_elem_of_dom Hdom elem_of_dom Hh2 -eq_None_not_Some in Hh1. }
      done.
    Qed.

    Lemma repl_hist_update {γ k h1} h2 :
      prefix h1 h2 ->
      own_repl_hist_half γ k h1 -∗
      own_repl_hist_half γ k h1 ==∗
      own_repl_hist_half γ k h2 ∗ own_repl_hist_half γ k h2.
    Proof.
      iIntros (Hprefix) "Hh1 Hh2".
      iCombine "Hh1 Hh2" as "Hh".
      rewrite -own_op singleton_op.
      iApply (own_update with "Hh").
      rewrite -mono_list_auth_dfrac_op dfrac_op_own Qp.half_half.
      apply singleton_update.
      by apply mono_list_update.
    Qed.

    Lemma repl_hist_big_update {γ hs1} hs2 :
      map_Forall2 (λ _ h1 h2, prefix h1 h2) hs1 hs2 ->
      ([∗ map] k ↦ h ∈ hs1, own_repl_hist_half γ k h) -∗
      ([∗ map] k ↦ h ∈ hs1, own_repl_hist_half γ k h) ==∗
      ([∗ map] k ↦ h ∈ hs2, own_repl_hist_half γ k h) ∗
      ([∗ map] k ↦ h ∈ hs2, own_repl_hist_half γ k h).
    Proof.
      iIntros (Hprefixes) "Hhs1x Hhs1y".
      iCombine "Hhs1x Hhs1y" as "Hhs1".
      rewrite -2!big_sepM_sep.
      iApply big_sepM_bupd.
      iApply (big_sepM_impl_dom_eq with "Hhs1").
      { symmetry. apply (map_Forall2_dom_L _ _ _ Hprefixes). }
      iIntros (k h1 h2 Hh1 Hh2) "!> [Hh1x Hh1y]".
      iApply (repl_hist_update with "Hh1x Hh1y").
      apply (map_Forall2_lookup_Some _ _ _ _ _ _ Hh1 Hh2 Hprefixes).
    Qed.

    Lemma repl_hist_witness {γ k h} :
      own_repl_hist_half γ k h -∗
      is_repl_hist_lb γ k h.
    Proof.
      iApply own_mono.
      apply singleton_included_mono.
      apply mono_list_included.
    Qed.

    Lemma repl_hist_prefix {γ k h hlb} :
      own_repl_hist_half γ k h -∗
      is_repl_hist_lb γ k hlb -∗
      ⌜prefix hlb h⌝.
    Proof.
      iIntros "Hh Hlb".
      iDestruct (own_valid_2 with "Hh Hlb") as %Hvalid.
      iPureIntro. revert Hvalid.
      rewrite singleton_op singleton_valid.
      rewrite mono_list_both_dfrac_valid_L.
      by intros [_ ?].
    Qed.

    Definition repl_hist_at γ (k : dbkey) (ts : nat) (v : dbval) : iProp Σ :=
      ∃ hist, is_repl_hist_lb γ k hist ∗ ⌜hist !! ts = Some v⌝.

    Lemma repl_hist_lookup γ k h ts v :
      own_repl_hist_half γ k h -∗
      repl_hist_at γ k ts v -∗
      ⌜h !! ts = Some v⌝.
    Proof.
      iIntros "Hhalf (%lb & #Hlb & %Hv)".
      iDestruct (repl_hist_prefix with "Hhalf Hlb") as %Hprefix.
      iPureIntro.
      by eapply prefix_lookup_Some.
    Qed.

    Lemma repl_hist_lb_weaken {γ k hlb1} hlb2 :
      prefix hlb2 hlb1 ->
      is_repl_hist_lb γ k hlb1 -∗
      is_repl_hist_lb γ k hlb2.
    Proof.
      iIntros (Hprefix).
      iApply own_mono.
      apply singleton_included_mono.
      by apply mono_list_lb_mono.
    Qed.

  End repl_hist.

  Section repl_ts.

    (** Timestamped-lock generated by replicated transactions for a certain
    key. One half owned by the txnsys invariant, the other by the key
    invariant. *)

    Definition own_repl_ts_half γ (k : dbkey) (ts : nat) : iProp Σ :=
      own γ.(repl_ts) {[ k := (to_dfrac_agree (DfracOwn (1 / 2)) ts) ]}.

    Lemma repl_ts_agree {γ k ts1 ts2} :
      own_repl_ts_half γ k ts1 -∗
      own_repl_ts_half γ k ts2 -∗
      ⌜ts2 = ts1⌝.
    Proof.
      iIntros "Hv1 Hv2".
      iDestruct (own_valid_2 with "Hv1 Hv2") as %Hvalid.
      rewrite singleton_op singleton_valid dfrac_agree_op_valid_L in Hvalid.
      by destruct Hvalid as [_ ?].
    Qed.

    Lemma repl_ts_update {γ k ts1 ts2} ts' :
      own_repl_ts_half γ k ts1 -∗
      own_repl_ts_half γ k ts2 ==∗
      own_repl_ts_half γ k ts' ∗ own_repl_ts_half γ k ts'.
    Proof.
      iIntros "Hv1 Hv2".
      iCombine "Hv1 Hv2" as "Hv".
      rewrite -own_op singleton_op.
      iApply (own_update with "Hv").
      apply singleton_update.
      apply dfrac_agree_update_2.
      by rewrite dfrac_op_own Qp.half_half.
    Qed.

    Lemma repl_ts_big_agree {γ tsm1 tsm2} :
      dom tsm1 = dom tsm2 ->
      ([∗ map] k ↦ ts ∈ tsm1, own_repl_ts_half γ k ts) -∗
      ([∗ map] k ↦ ts ∈ tsm2, own_repl_ts_half γ k ts) -∗
      ⌜tsm2 = tsm1⌝.
    Proof.
      iIntros (Hdom) "Htsm1 Htsm2".
      rewrite map_eq_iff.
      iIntros (k).
      destruct (tsm1 !! k) as [h1 |] eqn:Hh1, (tsm2 !! k) as [h2 |] eqn:Hh2.
      { iDestruct (big_sepM_lookup with "Htsm1") as "Hh1"; first apply Hh1.
        iDestruct (big_sepM_lookup with "Htsm2") as "Hh2"; first apply Hh2.
        by iDestruct (repl_ts_agree with "Hh1 Hh2") as %->.
      }
      { by rewrite -not_elem_of_dom -Hdom elem_of_dom Hh1 -eq_None_not_Some in Hh2. }
      { by rewrite -not_elem_of_dom Hdom elem_of_dom Hh2 -eq_None_not_Some in Hh1. }
      done.
    Qed.

    Lemma repl_ts_big_update {γ tss} tss' :
      dom tss = dom tss' ->
      ([∗ map] k ↦ t ∈ tss, own_repl_ts_half γ k t) -∗
      ([∗ map] k ↦ t ∈ tss, own_repl_ts_half γ k t) ==∗
      ([∗ map] k ↦ t ∈ tss', own_repl_ts_half γ k t) ∗
      ([∗ map] k ↦ t ∈ tss', own_repl_ts_half γ k t).
    Proof.
      iIntros (Hdom) "Hhs1x Hhs1y".
      iCombine "Hhs1x Hhs1y" as "Hhs1".
      rewrite -2!big_sepM_sep.
      iApply big_sepM_bupd.
      iApply (big_sepM_impl_dom_eq with "Hhs1"); first done.
      iIntros (k h1 h2 Hh1 Hh2) "!> [Hh1x Hh1y]".
      iApply (repl_ts_update with "Hh1x Hh1y").
    Qed.

  End repl_ts.

  Section repl_tuple.

    (** Replicated tuple [tuple_repl] simply combines [repl_hist] and [repl_ts]. *)

    Definition own_repl_tuple_half γ (k : dbkey) (t : dbtpl) : iProp Σ :=
      own_repl_hist_half γ k t.1 ∗ own_repl_ts_half γ k t.2.

  End repl_tuple.

  Section lnrz_kmod.

    (** Key-modification made by linearized transactions. One half owned by the
    txnsys invariant, and the other half by the group invariant. *)

    Definition own_lnrz_kmod_half γ (k : dbkey) (kmod : dbkmod) : iProp Σ :=
      own γ.(lnrz_kmod) {[ k := (to_dfrac_agree (DfracOwn (1 / 2)) kmod) ]}.

    Lemma lnrz_kmod_agree {γ k m1 m2} :
      own_lnrz_kmod_half γ k m1 -∗
      own_lnrz_kmod_half γ k m2 -∗
      ⌜m2 = m1⌝.
    Proof.
      iIntros "Hv1 Hv2".
      iDestruct (own_valid_2 with "Hv1 Hv2") as %Hvalid.
      rewrite singleton_op singleton_valid dfrac_agree_op_valid_L in Hvalid.
      by destruct Hvalid as [_ ?].
    Qed.

    Lemma lnrz_kmod_vslice_agree {γ k m im} :
      k ∈ keys_all ->
      ([∗ set] key ∈ keys_all, own_lnrz_kmod_half γ key (vslice m key)) -∗
      own_lnrz_kmod_half γ k im -∗
      ⌜im = vslice m k⌝.
    Proof.
      iIntros (Hin) "Hkeys Hk".
      iDestruct (big_sepS_elem_of with "Hkeys") as "Hkey"; first apply Hin.
      by iDestruct (lnrz_kmod_agree with "Hkey Hk") as %?.
    Qed.

    Lemma lnrz_kmod_update {γ k kmod1 kmod2} kmod :
      own_lnrz_kmod_half γ k kmod1 -∗
      own_lnrz_kmod_half γ k kmod2 ==∗
      own_lnrz_kmod_half γ k kmod ∗ own_lnrz_kmod_half γ k kmod.
    Proof.
      iIntros "Hv1 Hv2".
      iCombine "Hv1 Hv2" as "Hv".
      rewrite -own_op singleton_op.
      iApply (own_update with "Hv").
      apply singleton_update.
      apply dfrac_agree_update_2.
      by rewrite dfrac_op_own Qp.half_half.
    Qed.

    Lemma lnrz_kmod_big_agree {γ keys kmods f} :
      dom kmods = keys ->
      ([∗ set] k ∈ keys, own_lnrz_kmod_half γ k (f k)) -∗
      ([∗ map] k ↦ kmod ∈ kmods, own_lnrz_kmod_half γ k kmod) -∗
      ⌜map_Forall (λ k kmod, kmod = f k) kmods⌝.
    Proof.
      iIntros (Hdom) "Hkeys Hkmods".
      rewrite -Hdom.
      rewrite big_sepS_big_sepM.
      iCombine "Hkmods Hkeys" as "Hkmods".
      rewrite -big_sepM_sep.
      iApply big_sepM_pure.
      iApply (big_sepM_impl with "Hkmods").
      iIntros "!>" (k kmod Hkmod) "[Hkmod Hf]".
      iApply (lnrz_kmod_agree with "Hf Hkmod").
    Qed.

    Lemma lnrz_kmod_big_update {γ keys kmods f} f' :
      dom kmods = keys ->
      ([∗ set] k ∈ keys, own_lnrz_kmod_half γ k (f k)) -∗
      ([∗ map] k ↦ kmod ∈ kmods, own_lnrz_kmod_half γ k kmod) ==∗
      ([∗ set] k ∈ keys, own_lnrz_kmod_half γ k (f' k)) ∗
      ([∗ map] k ↦ kmod ∈ kmods, own_lnrz_kmod_half γ k (f' k)).
    Proof.
      iIntros (Hdom) "Hkeys Hkmods".
      rewrite -Hdom.
      rewrite 2!big_sepS_big_sepM.
      iCombine "Hkmods Hkeys" as "Hkmods".
      rewrite -2!big_sepM_sep.
      iApply big_sepM_bupd.
      iApply (big_sepM_mono with "Hkmods").
      iIntros (k kmod Hkmod) "[Hkmod Hf]".
      iMod (lnrz_kmod_update (f' k) with "Hkmod Hf") as "[Hkmod Hf]".
      by iFrame.
    Qed.

  End lnrz_kmod.

  Section cmtd_kmod.

    (** Key-modification made by committed transactions. One half owned by the
    txnsys invariant, and the other half by the group invariant. *)

    Definition own_cmtd_kmod_half γ (k : dbkey) (kmod : dbkmod) : iProp Σ :=
      own γ.(cmtd_kmod) {[ k := (to_dfrac_agree (DfracOwn (1 / 2)) kmod) ]}.

    Lemma cmtd_kmod_agree {γ k m1 m2} :
      own_cmtd_kmod_half γ k m1 -∗
      own_cmtd_kmod_half γ k m2 -∗
      ⌜m2 = m1⌝.
    Proof.
      iIntros "Hv1 Hv2".
      iDestruct (own_valid_2 with "Hv1 Hv2") as %Hvalid.
      rewrite singleton_op singleton_valid dfrac_agree_op_valid_L in Hvalid.
      by destruct Hvalid as [_ ?].
    Qed.

    Lemma cmtd_kmod_vslice_agree {γ k m im} :
      k ∈ keys_all ->
      ([∗ set] key ∈ keys_all, own_cmtd_kmod_half γ key (vslice m key)) -∗
      own_cmtd_kmod_half γ k im -∗
      ⌜im = vslice m k⌝.
    Proof.
      iIntros (Hin) "Hkeys Hk".
      iDestruct (big_sepS_elem_of with "Hkeys") as "Hkey"; first apply Hin.
      by iDestruct (cmtd_kmod_agree with "Hkey Hk") as %?.
    Qed.

    Lemma cmtd_kmod_update {γ k kmod1 kmod2} kmod :
      own_cmtd_kmod_half γ k kmod1 -∗
      own_cmtd_kmod_half γ k kmod2 ==∗
      own_cmtd_kmod_half γ k kmod ∗ own_cmtd_kmod_half γ k kmod.
    Proof.
      iIntros "Hv1 Hv2".
      iCombine "Hv1 Hv2" as "Hv".
      rewrite -own_op singleton_op.
      iApply (own_update with "Hv").
      apply singleton_update.
      apply dfrac_agree_update_2.
      by rewrite dfrac_op_own Qp.half_half.
    Qed.

    Lemma cmtd_kmod_big_agree {γ keys kmods f} :
      dom kmods = keys ->
      ([∗ set] k ∈ keys, own_cmtd_kmod_half γ k (f k)) -∗
      ([∗ map] k ↦ kmod ∈ kmods, own_cmtd_kmod_half γ k kmod) -∗
      ⌜map_Forall (λ k kmod, kmod = f k) kmods⌝.
    Proof.
      iIntros (Hdom) "Hkeys Hkmods".
      rewrite -Hdom.
      rewrite big_sepS_big_sepM.
      iCombine "Hkmods Hkeys" as "Hkmods".
      rewrite -big_sepM_sep.
      iApply big_sepM_pure.
      iApply (big_sepM_impl with "Hkmods").
      iIntros "!>" (k kmod Hkmod) "[Hkmod Hf]".
      iApply (cmtd_kmod_agree with "Hf Hkmod").
    Qed.

    Lemma cmtd_kmod_big_update {γ keys kmods f} f' :
      dom kmods = keys ->
      ([∗ set] k ∈ keys, own_cmtd_kmod_half γ k (f k)) -∗
      ([∗ map] k ↦ kmod ∈ kmods, own_cmtd_kmod_half γ k kmod) ==∗
      ([∗ set] k ∈ keys, own_cmtd_kmod_half γ k (f' k)) ∗
      ([∗ map] k ↦ kmod ∈ kmods, own_cmtd_kmod_half γ k (f' k)).
    Proof.
      iIntros (Hdom) "Hkeys Hkmods".
      rewrite -Hdom.
      rewrite 2!big_sepS_big_sepM.
      iCombine "Hkmods Hkeys" as "Hkmods".
      rewrite -2!big_sepM_sep.
      iApply big_sepM_bupd.
      iApply (big_sepM_mono with "Hkmods").
      iIntros (k kmod Hkmod) "[Hkmod Hf]".
      iMod (cmtd_kmod_update (f' k) with "Hkmod Hf") as "[Hkmod Hf]".
      by iFrame.
    Qed.

  End cmtd_kmod.

  Section txn_consensus.

    (** Consensus resource with transaction semantics. One half owned by the
    group invariant, the other half by the txnlog invariant. *)

    Definition own_txn_log_half γ (gid : u64) (log : dblog) : iProp Σ :=
      own γ.(txn_log) {[ gid := mono_list_auth (DfracOwn (1 / 2)) log ]}.

    Definition is_txn_log_lb γ (gid : u64) (log : dblog) : iProp Σ :=
      own γ.(txn_log) {[ gid := mono_list_lb log ]}.

    #[global]
    Instance is_txn_log_lb_persistent γ gid log :
      Persistent (is_txn_log_lb γ gid log).
    Proof. apply _. Defined.

    Definition is_txn_log_lbs γ (logs : gmap u64 dblog) : iProp Σ :=
      [∗ map] gid ↦ log ∈ logs, is_txn_log_lb γ gid log.

    Definition own_txn_cpool_half γ (gid : u64) (cpool : gset ccommand) : iProp Σ :=
      own γ.(txn_cpool) {[ gid := to_dfrac_agree (DfracOwn (1 / 2)) cpool ]}.

    Definition own_txn_consensus_half
      γ (gid : u64) (log : dblog) (cpool : gset ccommand) : iProp Σ :=
      own_txn_log_half γ gid log ∗ own_txn_cpool_half γ gid cpool.

    Lemma txn_log_witness γ gid log :
      own_txn_log_half γ gid log -∗
      is_txn_log_lb γ gid log.
    Proof.
      iApply own_mono.
      rewrite singleton_included_total.
      apply mono_list_included.
    Qed.

    Lemma txn_log_prefix γ gid log logp :
      own_txn_log_half γ gid log -∗
      is_txn_log_lb γ gid logp -∗
      ⌜prefix logp log⌝.
    Proof.
      iIntros "Hauth Hlb".
      iDestruct (own_valid_2 with "Hauth Hlb") as %Hvalid.
      rewrite singleton_op singleton_valid in Hvalid.
      by apply mono_list_both_dfrac_valid_L in Hvalid as [_ ?].
    Qed.

    Lemma txn_log_agree γ gid log1 log2 :
      own_txn_log_half γ gid log1 -∗
      own_txn_log_half γ gid log2 -∗
      ⌜log2 = log1⌝.
    Proof.
      iIntros "Hauth1 Hauth2".
      iDestruct (own_valid_2 with "Hauth1 Hauth2") as %Hvalid.
      rewrite singleton_op singleton_valid in Hvalid.
      by apply mono_list_auth_dfrac_op_valid_L in Hvalid as [_ ?].
    Qed.

    Lemma txn_log_lb_prefix γ gid logp1 logp2 :
      is_txn_log_lb γ gid logp1 -∗
      is_txn_log_lb γ gid logp2 -∗
      ⌜prefix logp1 logp2 ∨ prefix logp2 logp1⌝.
    Proof.
      iIntros "Hlb1 Hlb2".
      iDestruct (own_valid_2 with "Hlb1 Hlb2") as %Hvalid.
      by rewrite singleton_op singleton_valid mono_list_lb_op_valid_L in Hvalid.
    Qed.

    Lemma txn_log_lb_weaken {γ gid} logp1 logp2 :
      prefix logp1 logp2 ->
      is_txn_log_lb γ gid logp2 -∗
      is_txn_log_lb γ gid logp1.
    Proof.
      intros Hprefix.
      iApply own_mono.
      rewrite singleton_included_total.
      by apply mono_list_lb_mono.
    Qed.

    Lemma txn_cpool_agree γ gid cpool1 cpool2 :
      own_txn_cpool_half γ gid cpool1 -∗
      own_txn_cpool_half γ gid cpool2 -∗
      ⌜cpool2 = cpool1⌝.
    Proof.
      iIntros "Hauth1 Hauth2".
      iDestruct (own_valid_2 with "Hauth1 Hauth2") as %Hvalid.
      rewrite singleton_op singleton_valid in Hvalid.
      by apply dfrac_agree_op_valid_L in Hvalid as [_ ?].
    Qed.

    Definition txn_cpool_subsume_log (cpool : gset ccommand) (log : list ccommand) :=
      Forall (λ c, c ∈ cpool) log.

    Lemma txn_log_extend {γ gid log} logext :
      own_txn_log_half γ gid log -∗
      own_txn_log_half γ gid log ==∗
      own_txn_log_half γ gid (log ++ logext) ∗
      own_txn_log_half γ gid (log ++ logext).
    Proof.
      iIntros "Hauth1 Hauth2".
      iCombine "Hauth1 Hauth2" as "Hauth".
      rewrite -own_op singleton_op.
      iApply (own_update with "Hauth").
      apply singleton_update.
      rewrite -mono_list_auth_dfrac_op dfrac_op_own Qp.half_half.
      apply mono_list_update.
      by apply prefix_app_r.
    Qed.

    (* TODO: the ⊆ is not required *)
    Lemma txn_cpool_update {γ gid cpool} cpool' :
      own_txn_cpool_half γ gid cpool -∗
      own_txn_cpool_half γ gid cpool ==∗
      own_txn_cpool_half γ gid cpool' ∗
      own_txn_cpool_half γ gid cpool'.
    Proof.
      iIntros "Hauth1 Hauth2".
      iCombine "Hauth1 Hauth2" as "Hauth".
      rewrite -own_op singleton_op.
      iApply (own_update with "Hauth").
      apply singleton_update.
      apply dfrac_agree_update_2.
      by rewrite dfrac_op_own Qp.half_half.
    Qed.

  End txn_consensus.

End res.

Section alloc.
  Context `{!tulip_ghostG Σ}.

  Definition replica_init_res γ (g : u64) : iProp Σ :=
    (* per-replica validated transaction IDs *)
    ([∗ set] r ∈ rids_all, own_replica_validated_tss γ g r ∅) ∗
    (* per-replica validation history *)
    ([∗ set] r ∈ rids_all, [∗ set] k ∈ keys_all, own_replica_key_validation γ g r k [false]) ∗
    (* per-replica consistent log *)
    ([∗ set] r ∈ rids_all, own_replica_clog_half γ g r []) ∗
    (* per-replica inconsistent log *)
    ([∗ set] r ∈ rids_all, own_replica_ilog_half γ g r []) ∗
    (* per-replica vote-history map *)
    ([∗ set] r ∈ rids_all, own_replica_ballot_map γ g r ∅) ∗
    (* per-replica backup-vote map *)
    ([∗ set] r ∈ rids_all, own_replica_backup_vote_map γ g r ∅) ∗
    (* per-replica backup-tokens map *)
    ([∗ set] r ∈ rids_all, own_replica_backup_tokens_map γ g r ∅).

  Lemma tulip_res_alloc (gfnames : gmap (u64 * u64) byte_string) :
    ⊢ |==> ∃ γ,
      (* database points-to | client *)
      ([∗ set] k ∈ keys_all, own_db_ptsto γ k None) ∗
      (* transaction result map | txnsys *)
      own_txn_resm γ ∅ ∗
      (* transaction write-set | txnsys *)
      own_txn_oneshot_wrsm γ ∅ ∗
      (* IDs of linearized transaction | txnsys *)
      own_lnrz_tids γ ∅ ∗
      (* IDs of transaction predicted to abort | txnsys *)
      own_wabt_tids γ ∅ ∗
      (* IDs and write-sets of transaction predicted to commit or has committed | txnsys *)
      own_cmt_tmods γ ∅ ∗
      (* exclusive transaction tokens to partition predictions | txnsys *)
      own_excl_tids γ ∅ ∗
      (* exclusive (transaction, group) tokens for ownerhsip of slow-path prepare proposal | txnsys *)
      own_txn_client_tokens γ ∅ ∗
      (* transaction post-condition | txnsys *)
      own_txn_postconds γ ∅ ∗
      (* largest assigned timestamp | txnsys *)
      own_largest_ts γ O ∗
      (* database points-to | key *)
      ([∗ set] k ∈ keys_all, own_db_ptsto γ k None) ∗
      (* per-key replicated tuples | group / key *)
      ([∗ set] k ∈ keys_all, own_repl_hist_half γ k [None]) ∗
      ([∗ set] k ∈ keys_all, own_repl_hist_half γ k [None]) ∗
      ([∗ set] k ∈ keys_all, own_repl_ts_half γ k O) ∗
      ([∗ set] k ∈ keys_all, own_repl_ts_half γ k O) ∗
      (* per-key committed history | txnsys *)
      ([∗ set] k ∈ keys_all, own_cmtd_hist γ k [None]) ∗
      (* per-key linearized history | txnsys *)
      ([∗ set] k ∈ keys_all, own_lnrz_hist γ k [None]) ∗
      (* per-key linearized modification | txnsys / key *)
      ([∗ set] k ∈ keys_all, own_lnrz_kmod_half γ k ∅) ∗
      ([∗ set] k ∈ keys_all, own_lnrz_kmod_half γ k ∅) ∗
      (* per-key committed modification | txnsys / key *)
      ([∗ set] k ∈ keys_all, own_cmtd_kmod_half γ k ∅) ∗
      ([∗ set] k ∈ keys_all, own_cmtd_kmod_half γ k ∅) ∗
      (* per-group txn consensus | group / txnlog *)
      ([∗ set] g ∈ gids_all, own_txn_log_half γ g []) ∗
      ([∗ set] g ∈ gids_all, own_txn_log_half γ g []) ∗
      ([∗ set] g ∈ gids_all, own_txn_cpool_half γ g ∅) ∗
      ([∗ set] g ∈ gids_all, own_txn_cpool_half γ g ∅) ∗
      (* per-group prepare map | group *)
      ([∗ set] g ∈ gids_all, own_group_prepm γ g ∅) ∗
      (* per-group prepare proposal map | group *)
      ([∗ set] g ∈ gids_all, own_group_prepare_proposals_map γ g ∅) ∗
      (* per-group prepare map | group *)
      ([∗ set] g ∈ gids_all, own_group_commit_map γ g ∅) ∗
      (* per-replica ilog file name | file *)
      ([∗ map] gr ↦ fname ∈ gfnames, is_replica_ilog_fname γ gr.1 gr.2 fname) ∗
      (* per-replica inconsistent log | file *)
      ([∗ set] gr ∈ gset_cprod gids_all rids_all, own_replica_ilog_quarter γ gr.1 gr.2 []) ∗
      (* per-group network terminals | network *)
      ([∗ set] g ∈ gids_all, own_terminals γ g ∅ ) ∗
      (* per-replica resources *)
      ([∗ set] g ∈ gids_all, replica_init_res γ g) ∗
      (* per-replica consistent and inconsistent log | replica lock *)
      ([∗ set] g ∈ gids_all, [∗ set] r ∈ rids_all,
         own_replica_clog_half γ g r [] ∗ own_replica_ilog_quarter γ g r []) ∗
      (* gentid init *)
      gentid_init γ.
  Proof.
    iMod (own_alloc (gset_to_gmap (to_dfrac_agree (DfracOwn 1) (None : dbval)) keys_all)) as
           (γdb_ptsto) "Hdb_ptsto".
    { apply gset_to_gmap_valid. rewrite //=. }
    iDestruct (own_gset_to_gmap_singleton_sep_half γdb_ptsto keys_all (None : dbval) with "Hdb_ptsto")
      as "(Hdb_ptsto1&Hdb_ptsto2)".

    iMod (ghost_map_alloc_empty (K := nat) (V := txnres)) as
      (γtxn_res) "Htxn_res".

    iMod (ghost_map_alloc_empty (K := nat) (V := option dbmap)) as
      (γtxn_oneshot_wrs) "Htxn_oneshot".

    iMod (ghost_map_alloc_empty (K := nat) (V := unit)) as
      (γlnrz_tid) "Hlnrz_tid".

    iMod (ghost_map_alloc_empty (K := nat) (V := unit)) as
      (γwabt_tid) "Hwabt_tid".

    iMod (ghost_map_alloc_empty (K := nat) (V := dbmap)) as
      (γcmt_tmod) "Hcmt_tmod".

    iMod (ghost_map_alloc_empty (K := nat) (V := unit)) as
      (γexcl_tid) "Hexcl_tid".

    iMod (ghost_map_alloc_empty (K := nat * w64) (V := unit)) as
      (γtxn_client_token) "Htxn_client_token".

    (* TODO: if the own_txn_postconds become iProp instead of Prop,
       this probably needs to become a map to gnames, and then have a
       separate family of saved_preds *)
    iMod (ghost_map_alloc_empty (K := nat) (V := (dbmap → Prop))) as
      (γtxn_postcond) "Htxn_postcond".

    iMod (mono_nat.mono_nat_own_alloc 0) as
      (γlargest_ts) "((Hlargest1&Hlargest2)&Hlb)".

    iMod (own_alloc (gset_to_gmap (●ML ([None] : dbhist)) keys_all)) as
           (γrepl_hist) "Hrepl_hist".
    { apply gset_to_gmap_valid; apply mono_list_auth_valid. }

    iMod (own_alloc (gset_to_gmap (to_dfrac_agree (DfracOwn 1) 0%nat) keys_all)) as
           (γrepl_ts) "Hrepl_ts".
    { apply gset_to_gmap_valid. rewrite //=. }

    iMod (own_alloc (gset_to_gmap (●ML ([None] : dbhist)) keys_all)) as
           (γcmtd_hist) "Hcmtd_hist".
    { apply gset_to_gmap_valid; apply mono_list_auth_valid. }

    iMod (own_alloc (gset_to_gmap (●ML ([None] : dbhist)) keys_all)) as
           (γlnrz_hist) "Hlnrz_hist".
    { apply gset_to_gmap_valid; apply mono_list_auth_valid. }

    iMod (own_alloc (gset_to_gmap (to_dfrac_agree (DfracOwn 1) (∅ : dbkmod)) keys_all)) as
           (γlnrz_kmod) "Hlnrz_kmod".
    { apply gset_to_gmap_valid. rewrite //=. }

    iMod (own_alloc (gset_to_gmap (to_dfrac_agree (DfracOwn 1) (∅ : dbkmod)) keys_all)) as
           (γcmtd_kmod) "Hcmtd_kmod".
    { apply gset_to_gmap_valid. rewrite //=. }

    iMod (own_alloc (gset_to_gmap (●ML ([] : dblog)) gids_all)) as
           (γtxn_log) "Htxn_log".
    { apply gset_to_gmap_valid; apply mono_list_auth_valid. }

    iMod (own_alloc (i := tulip_ghostG0.(@txn_cpoolG Σ))
            (gset_to_gmap (to_dfrac_agree (DfracOwn 1) (∅ : ccommandsR)) gids_all)) as
           (γtxn_cpool) "Htxn_cpool".
    { apply gset_to_gmap_valid. rewrite //=. }

    iMod (own_alloc (gset_to_gmap (gmap_view_auth (DfracOwn 1) (to_agree <$> ∅)) gids_all)) as
           (γgroup_prep) "Hgroup_prep".
    { apply gset_to_gmap_valid; apply gmap_view_auth_valid. }

    iMod (own_alloc (gset_to_gmap (gmap_view_auth (DfracOwn 1) (to_agree <$> (∅ : gmap (nat * nat) bool)))
                       gids_all)) as
           (γgroup_prepare_proposal) "Hgroup_prepare_proposal".
    { apply gset_to_gmap_valid; apply gmap_view_auth_valid. }

    iMod (own_alloc (gset_to_gmap (gmap_view_auth (DfracOwn 1) (to_agree <$> (∅ : gmap nat bool)))
                       gids_all)) as
           (γgroup_commit) "Hgroup_commit".
    { apply gset_to_gmap_valid; apply gmap_view_auth_valid. }

    iMod (own_alloc (gset_to_gmap (gmap_view_auth (DfracOwn 1) (gset_to_gmap () ∅ : gmap chan unit))
                       gids_all)) as
           (γgroup_trmlm) "Hgroup_trmlm".
    { apply gset_to_gmap_valid; apply gmap_view_auth_valid. }

    iMod (own_alloc (gset_to_gmap (gmap_view_auth (DfracOwn 1) (gset_to_gmap () ∅ : (gmap nat unit)))
                       (gset_cprod gids_all rids_all))) as
           (γreplica_validated_ts) "Hreplica_validated".
    { apply gset_to_gmap_valid; apply gmap_view_auth_valid. }

    iMod (own_alloc (gset_to_gmap (●ML ([false] : list bool))
                       (gset_cprod (gset_cprod gids_all rids_all) keys_all)))
              as
           (γreplica_key_validation) "Hreplica_key_validation".
    { apply gset_to_gmap_valid; apply mono_list_auth_valid. }

    iMod (own_alloc (gset_to_gmap (to_dfrac_agree (A := clogO) (DfracOwn 1) ([] : (list ccommand)))
                       (gset_cprod gids_all rids_all))) as
           (γreplica_clog) "Hreplica_clog".
    { apply gset_to_gmap_valid. rewrite //=. }

    iMod (own_alloc (gset_to_gmap (to_dfrac_agree (A := ilogO) (DfracOwn 1) ([] : (list (nat * icommand))))
                       (gset_cprod gids_all rids_all))) as
           (γreplica_ilog) "Hreplica_ilog".
    { apply gset_to_gmap_valid. rewrite //=. }

    iMod (own_alloc (gset_to_gmap (gmap_view_auth (DfracOwn 1) (to_agree <$> (∅ : gmap nat gname)))
                       (gset_cprod gids_all rids_all))) as
           (γreplica_ballot) "Hreplica_ballot".
    { apply gset_to_gmap_valid; apply gmap_view_auth_valid. }

    iMod (own_alloc (gset_to_gmap (gmap_view_auth (DfracOwn 1) (to_agree <$> (∅ : gmap (nat * nat) coordid)))
                       (gset_cprod gids_all rids_all))) as
           (γreplica_vote) "Hreplica_vote".
    { apply gset_to_gmap_valid; apply gmap_view_auth_valid. }

    iMod (own_alloc (gset_to_gmap (gmap_view_auth (DfracOwn 1) (gset_to_gmap tt (∅ : gset (nat * nat * u64))))
                       (gset_cprod gids_all rids_all))) as
           (γreplica_token) "Hreplica_token".
    { apply gset_to_gmap_valid; apply gmap_view_auth_valid. }

    (* TODO: currently we just throw these away, the lemma probably should be strengthened
             to use these *)

    iMod (own_alloc (gset_to_gmap (Excl tt) (∅ : gset u64))) as (γsids) "Hγsids".
    { apply gset_to_gmap_valid. econstructor. }

    iMod (ghost_map_alloc_empty (K := u64) (V := gname)) as
      (γgentid_reserved) "Hgentid".

    iMod (own_alloc ((to_agree <$> gfnames) : gmapR (u64 * u64) (agreeR byte_stringO))) as
           (γreplica_ilog_fname) "Hilog_wal_fname".
    { intros k. rewrite lookup_fmap; destruct (gfnames !! k) eqn:Heq; rewrite Heq //=. }

    set γ := {|
    db_ptsto := γdb_ptsto;
    repl_hist := γrepl_hist;
    repl_ts := γrepl_ts;
    lnrz_kmod := γlnrz_kmod;
    cmtd_kmod := γcmtd_kmod;
    txn_log := γtxn_log;
    txn_cpool := γtxn_cpool;
    cmtd_hist := γcmtd_hist;
    lnrz_hist := γlnrz_hist;
    txn_res := γtxn_res;
    txn_oneshot_wrs := γtxn_oneshot_wrs;
    lnrz_tid := γlnrz_tid;
    wabt_tid := γwabt_tid;
    cmt_tmod := γcmt_tmod;
    excl_tid := γexcl_tid;
    txn_client_token := γtxn_client_token;
    txn_postcond := γtxn_postcond;
    largest_ts := γlargest_ts;
    group_prep := γgroup_prep;
    group_prepare_proposal := γgroup_prepare_proposal;
    group_commit := γgroup_commit;
    replica_validated_ts := γreplica_validated_ts;
    replica_key_validation := γreplica_key_validation;
    replica_clog := γreplica_clog;
    replica_ilog := γreplica_ilog;
    replica_ballot := γreplica_ballot;
    replica_vote := γreplica_vote;
    replica_token := γreplica_token;
    replica_ilog_fname := γreplica_ilog_fname;
    group_trmlm := γgroup_trmlm;
    sids := γsids;
    gentid_reserved := γgentid_reserved |}.

    iModIntro.
    iExists γ.
    iSplitL "Hdb_ptsto1".
    { by iFrame. }
    iSplitL "Htxn_res".
    { iFrame. done. }
    iSplitL "Htxn_oneshot".
    { iFrame. }
    iSplitL "Hlnrz_tid".
    { iFrame. }
    iSplitL "Hwabt_tid".
    { iFrame. }
    iSplitL "Hcmt_tmod".
    { iFrame. }
    iSplitL "Hexcl_tid".
    { iFrame. }
    iSplitL "Htxn_client_token".
    { rewrite /own_txn_client_tokens. iExists ∅. iSplit; first by iFrame.
      set_solver. }
    iSplitL "Htxn_postcond".
    { iFrame. }
    iSplitL "Hlargest1".
    { iFrame. }
    iSplitL "Hdb_ptsto2".
    { iFrame. }
    iDestruct (own_gset_to_gmap_singleton_is_op with "Hrepl_hist") as "(Hrep1&Hrep2)".
    iSplitL "Hrep1".
    { iFrame. }
    iSplitL "Hrep2".
    { iFrame. }

    iDestruct (own_gset_to_gmap_singleton_sep_half with "Hrepl_ts") as "($&$)".
    iSplitL "Hcmtd_hist".
    { rewrite -big_opS_gset_to_gmap big_opS_own_1. iFrame. }
    iSplitL "Hlnrz_hist".
    { rewrite -big_opS_gset_to_gmap big_opS_own_1. iFrame. }
    iDestruct (own_gset_to_gmap_singleton_sep_half with "Hlnrz_kmod") as "($&$)".
    iDestruct (own_gset_to_gmap_singleton_sep_half with "Hcmtd_kmod") as "($&$)".
    iDestruct (own_gset_to_gmap_singleton_is_op with "Htxn_log") as "($&$)".
    iDestruct (own_gset_to_gmap_singleton_sep_half with "Htxn_cpool") as "($&$)".
    iSplitL "Hgroup_prep".
    { rewrite /own_group_prepm.
      rewrite -big_opS_gset_to_gmap big_opS_own_1.
      iApply (big_sepS_mono with "Hgroup_prep").
      iIntros (? Hin) "H". iFrame "H". rewrite //=. }
    iSplitL "Hgroup_prepare_proposal".
    { rewrite /own_group_prepare_proposals_map.
      rewrite -big_opS_gset_to_gmap big_opS_own_1.
      iApply (big_sepS_mono with "Hgroup_prepare_proposal").
      iIntros (? Hin) "H". iExists ∅. iFrame "H". rewrite big_sepM_empty //=. iSplit; first done.
      iPureIntro. naive_solver.
    }
    iSplitL "Hgroup_commit".
    { rewrite /own_group_commit_map.
      rewrite -big_opS_gset_to_gmap big_opS_own_1.
      iApply (big_sepS_mono with "Hgroup_commit").
      iIntros (? Hin) "H". rewrite big_sepM_empty //=. iFrame.
    }
    iSplitL "Hilog_wal_fname".
    { rewrite -big_opM_own_1.
      setoid_rewrite <- surjective_pairing.
      rewrite -big_opM_fmap big_opM_singletons //.
    }

    iDestruct (own_gset_to_gmap_singleton_sep_half with "Hreplica_ilog")
      as "(Hreplica_ilog1&Hreplica_ilog2)".

    iDestruct (big_sepS_singleton_sep
                 _ (gset_cprod gids_all rids_all) (λ _, ([] : ilogO))
                 (1 / 4)%Qp (1 / 4)%Qp
                with "[Hreplica_ilog2]") as "[Hreplica_ilog2 Hreplica_ilog3]".
    { by rewrite Qp.quarter_quarter. }

    iSplitL "Hreplica_ilog3".
    { rewrite /own_replica_ilog_quarter /own_replica_ilog_frac.
      by setoid_rewrite <- surjective_pairing.
    }
    iSplitL "Hgroup_trmlm".
    { rewrite -big_opS_gset_to_gmap big_opS_own_1.
      iApply (big_sepS_mono with "Hgroup_trmlm").
      iIntros (? Hin) "H". rewrite /own_terminals. rewrite big_sepS_empty //=.
      iFrame.
    }

    iDestruct (own_gset_to_gmap_singleton_sep_half with "Hreplica_clog")
      as "(Hreplica_clog1&Hreplica_clog2)".

    iSplitR "Hreplica_clog2 Hreplica_ilog2 Hlargest2 Hgentid".
    {
      rewrite /replica_init_res. rewrite ?big_sepS_sep.
      iSplitL "Hreplica_validated".
      {
        rewrite -big_opS_gset_to_gmap big_opS_own_1.
        iDestruct (big_sepS_gset_cprod' with "Hreplica_validated") as "H".
        iApply (big_sepS_mono with "H").
        iIntros (gid Hgid_in) "H".
        rewrite /replica_init_res.
        { rewrite /own_replica_validated_tss. rewrite /own_replica_validated_tss_auth.
          iApply (big_sepS_mono with "H").
          { iIntros (??) "$". rewrite //=. }
        }
      }
      iSplitL "Hreplica_key_validation".
      {
        rewrite -big_opS_gset_to_gmap big_opS_own_1.
        iDestruct (big_sepS_gset_cprod' with "Hreplica_key_validation") as "H".
        iDestruct (big_sepS_gset_cprod' with "H") as "H".
        auto.
      }
      iSplitL "Hreplica_clog1".
      { iDestruct (big_sepS_gset_cprod' with "Hreplica_clog1") as "$". }
      iSplitL "Hreplica_ilog1".
      { iDestruct (big_sepS_gset_cprod' with "Hreplica_ilog1") as "$". }
      iSplitL "Hreplica_ballot".
      {
        rewrite -big_opS_gset_to_gmap big_opS_own_1.
        iDestruct (big_sepS_gset_cprod' with "Hreplica_ballot") as "H".
        iApply (big_sepS_mono with "H").
        iIntros (gid Hgid_in) "H".
        rewrite /own_replica_ballot_map.
        iApply (big_sepS_mono with "H").
        iIntros (rid Hrid_in) "H".
        iExists ∅. iFrame. rewrite big_sepM2_empty big_sepM_empty //.
      }
      iSplitL "Hreplica_vote".
      {
        rewrite -big_opS_gset_to_gmap big_opS_own_1.
        iDestruct (big_sepS_gset_cprod' with "Hreplica_vote") as "H".
        iApply (big_sepS_mono with "H").
        iIntros (gid Hgid_in) "H".
        rewrite /own_replica_ballot_map.
        iApply (big_sepS_mono with "H").
        iIntros (rid Hrid_in) "H".
        iExists ∅. iFrame. iPureIntro. set_solver.
      }
      {
        rewrite -big_opS_gset_to_gmap big_opS_own_1.
        iDestruct (big_sepS_gset_cprod' with "Hreplica_token") as "H".
        iApply (big_sepS_mono with "H").
        iIntros (gid Hgid_in) "H".
        rewrite /own_replica_ballot_map.
        iApply (big_sepS_mono with "H").
        iIntros (rid Hrid_in) "H".
        iExists ∅. iFrame. iPureIntro. set_solver.
      }
    }

    iDestruct (big_sepS_sep with "[$Hreplica_clog2 $Hreplica_ilog2]") as "H".
    iDestruct (big_sepS_gset_cprod' with "H") as "H".
    iFrame.
  Qed.

End alloc.
